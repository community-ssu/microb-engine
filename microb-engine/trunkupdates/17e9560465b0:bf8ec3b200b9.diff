diff -r 17e9560465b0 .hgignore
--- a/.hgignore	Thu Oct 23 09:51:35 2008 -0700
+++ b/.hgignore	Thu Oct 30 05:41:44 2008 -0400
@@ -26,3 +26,6 @@
 _DBG\.OBJ/
 _OPT\.OBJ/
 
+# SpiderMonkey configury
+^js/src/configure$
+^js/src/autom4te.cache$
diff -r 17e9560465b0 accessible/src/base/nsAccUtils.cpp
--- a/accessible/src/base/nsAccUtils.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/accessible/src/base/nsAccUtils.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -442,6 +442,78 @@
   }
 }
 
+already_AddRefed<nsIAccessibleText>
+nsAccUtils::GetTextAccessibleFromSelection(nsISelection *aSelection,
+                                           nsIDOMNode **aNode)
+{
+  // Get accessible from selection's focus DOM point (the DOM point where
+  // selection is ended).
+
+  nsCOMPtr<nsIDOMNode> resultNode;
+  aSelection->GetFocusNode(getter_AddRefs(resultNode));
+  if (!resultNode)
+    return nsnull;
+
+  // Get DOM node that focus DOM point points to.
+  nsCOMPtr<nsIContent> content(do_QueryInterface(resultNode));
+  if (content && content->IsNodeOfType(nsINode::eELEMENT)) {
+    PRInt32 offset = 0;
+    aSelection->GetFocusOffset(&offset);
+
+    PRInt32 childCount = static_cast<PRInt32>(content->GetChildCount());
+    NS_ASSERTION(offset >= 0 && offset <= childCount,
+                 "Wrong focus offset in selection!");
+
+    // The offset can be after last child of container node that means DOM point
+    // is placed immediately after the last child. In this case use focusNode
+    // as result node.
+    if (offset != childCount) {
+      nsCOMPtr<nsIContent> child = content->GetChildAt(offset);
+      resultNode = do_QueryInterface(child);
+    }
+  }
+
+  nsIAccessibilityService *accService = nsAccessNode::GetAccService();
+
+  // Get text accessible containing the result node.
+  while (resultNode) {
+    // Make sure to get the correct starting node for selection events inside
+    // XBL content trees.
+    nsCOMPtr<nsIDOMNode> relevantNode;
+    nsresult rv = accService->
+      GetRelevantContentNodeFor(resultNode, getter_AddRefs(relevantNode));
+    if (NS_FAILED(rv))
+      return nsnull;
+
+    if (relevantNode)
+      resultNode.swap(relevantNode);
+
+    nsCOMPtr<nsIContent> content = do_QueryInterface(resultNode);
+    if (!content || !content->IsNodeOfType(nsINode::eTEXT)) {
+      nsCOMPtr<nsIAccessible> accessible;
+      accService->GetAccessibleFor(resultNode, getter_AddRefs(accessible));
+      if (accessible) {
+        nsIAccessibleText *textAcc = nsnull;
+        CallQueryInterface(accessible, &textAcc);
+        if (textAcc) {
+          if (aNode)
+            NS_ADDREF(*aNode = resultNode);
+
+          return textAcc;
+        }
+      }
+    }
+
+    nsCOMPtr<nsIDOMNode> parentNode;
+    resultNode->GetParentNode(getter_AddRefs(parentNode));
+    resultNode.swap(parentNode);
+  }
+
+  NS_NOTREACHED("No nsIAccessibleText for selection change event!");
+
+  return nsnull;
+}
+
 nsresult
 nsAccUtils::ConvertToScreenCoords(PRInt32 aX, PRInt32 aY,
                                   PRUint32 aCoordinateType,
diff -r 17e9560465b0 accessible/src/base/nsAccUtils.h
--- a/accessible/src/base/nsAccUtils.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/accessible/src/base/nsAccUtils.h	Thu Oct 30 05:41:44 2008 -0400
@@ -42,6 +42,7 @@
 #include "nsIAccessible.h"
 #include "nsIAccessNode.h"
 #include "nsIAccessibleRole.h"
+#include "nsIAccessibleText.h"
 #include "nsARIAMap.h"
 
 #include "nsIDOMNode.h"
@@ -159,6 +160,18 @@
      GetARIATreeItemParent(nsIAccessible *aStartTreeItem,
                            nsIContent *aStartTreeItemContent,
                            nsIAccessible **aTreeItemParent);
+
+  /**
+   * Return text accessible containing focus point of the given selection.
+   * Used for normal and misspelling selection changes processing.
+   *
+   * @param aSelection  [in] the given selection
+   * @param aNode       [out, optional] the DOM node of text accessible
+   * @return            text accessible
+   */
+  static already_AddRefed<nsIAccessibleText>
+    GetTextAccessibleFromSelection(nsISelection *aSelection,
+                                   nsIDOMNode **aNode = nsnull);
 
   /**
    * Converts the given coordinates to coordinates relative screen.
diff -r 17e9560465b0 accessible/src/base/nsAccessibilityAtomList.h
--- a/accessible/src/base/nsAccessibilityAtomList.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/accessible/src/base/nsAccessibilityAtomList.h	Thu Oct 30 05:41:44 2008 -0400
@@ -157,7 +157,6 @@
 ACCESSIBILITY_ATOM(contenteditable, "contenteditable")
 ACCESSIBILITY_ATOM(control, "control")
 ACCESSIBILITY_ATOM(disabled, "disabled")
-ACCESSIBILITY_ATOM(display, "display")
 ACCESSIBILITY_ATOM(_class, "class")
 ACCESSIBILITY_ATOM(cycles, "cycles") // used for XUL cycler attribute
 ACCESSIBILITY_ATOM(curpos, "curpos") // XUL
@@ -186,6 +185,11 @@
 ACCESSIBILITY_ATOM(tooltiptext, "tooltiptext")
 ACCESSIBILITY_ATOM(type, "type")
 ACCESSIBILITY_ATOM(value, "value")
+
+  // Alphabetical list of object attributes
+ACCESSIBILITY_ATOM(display, "display")
+ACCESSIBILITY_ATOM(textAlign, "text-align")
+ACCESSIBILITY_ATOM(textIndent, "text-indent")
 
   // Alphabetical list of text attributes (AT API)
 ACCESSIBILITY_ATOM(backgroundColor, "background-color")
diff -r 17e9560465b0 accessible/src/base/nsAccessibilityService.cpp
--- a/accessible/src/base/nsAccessibilityService.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/accessible/src/base/nsAccessibilityService.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -592,16 +592,8 @@
   nsCOMPtr<nsIContent> content(do_QueryInterface(node));
   NS_ENSURE_TRUE(content, NS_ERROR_FAILURE);
   
-  if (nsCoreUtils::HasListener(content, NS_LITERAL_STRING("click"))) {
-    // nsLinkableAccessible inherits from nsHyperTextAccessible, but
-    // it also includes code for dealing with the onclick
-    *aAccessible = new nsLinkableAccessible(node, weakShell);
-  }
-  else {
-    *aAccessible = new nsHyperTextAccessibleWrap(node, weakShell);
-  }
-  if (nsnull == *aAccessible)
-    return NS_ERROR_OUT_OF_MEMORY;
+  *aAccessible = new nsHyperTextAccessibleWrap(node, weakShell);
+  NS_ENSURE_TRUE(*aAccessible, NS_ERROR_OUT_OF_MEMORY);
 
   NS_ADDREF(*aAccessible);
   return NS_OK;
diff -r 17e9560465b0 accessible/src/base/nsAccessible.cpp
--- a/accessible/src/base/nsAccessible.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/accessible/src/base/nsAccessible.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -1154,15 +1154,16 @@
   nsresult rv = GetDeepestChildAtPoint(aX, aY, aAccessible);
   NS_ENSURE_SUCCESS(rv, rv);
 
-  if (!*aAccessible)
+  if (!*aAccessible || *aAccessible == this)
     return NS_OK;
 
+  // Get direct child containing the deepest child at the given point.
   nsCOMPtr<nsIAccessible> parent, accessible(*aAccessible);
   while (PR_TRUE) {
     accessible->GetParent(getter_AddRefs(parent));
     if (!parent) {
-      NS_ASSERTION(PR_FALSE,
-                   "Obtained accessible isn't a child of this accessible.");
+      NS_NOTREACHED("Obtained accessible isn't a child of this accessible.");
+
       // Reached the top of the hierarchy. These bounds were inside an
       // accessible that is not a descendant of this one.
 
@@ -1623,11 +1624,16 @@
   // Append all the text into one flat string
   PRUint32 numChildren = 0;
   nsCOMPtr<nsIDOMXULSelectControlElement> selectControlEl(do_QueryInterface(aContent));
-  
-  if (!selectControlEl && aContent->Tag() != nsAccessibilityAtoms::textarea) {
+  nsCOMPtr<nsIAtom> tag = aContent->Tag();
+
+  if (!selectControlEl && 
+      tag != nsAccessibilityAtoms::textarea && 
+      tag != nsAccessibilityAtoms::select) {
     // Don't walk children of elements with options, just get label directly.
     // Don't traverse the children of a textarea, we want the value, not the
     // static text node.
+    // Don't traverse the children of a select element, we only want the
+    // current value.
     numChildren = aContent->GetChildCount();
   }
 
@@ -2181,13 +2187,28 @@
   }
 
   // Expose 'display' attribute.
-  nsAutoString displayValue;
+  nsAutoString value;
   nsresult rv = GetComputedStyleValue(EmptyString(),
                                       NS_LITERAL_STRING("display"),
-                                      displayValue);
+                                      value);
   if (NS_SUCCEEDED(rv))
     nsAccUtils::SetAccAttr(aAttributes, nsAccessibilityAtoms::display,
-                           displayValue);
+                           value);
+
+  // Expose 'text-align' attribute.
+  rv = GetComputedStyleValue(EmptyString(), NS_LITERAL_STRING("text-align"),
+                             value);
+  if (NS_SUCCEEDED(rv))
+    nsAccUtils::SetAccAttr(aAttributes, nsAccessibilityAtoms::textAlign,
+                           value);
+
+  // Expose 'text-indent' attribute.
+  rv = GetComputedStyleValue(EmptyString(), NS_LITERAL_STRING("text-indent"),
+                             value);
+  if (NS_SUCCEEDED(rv))
+    nsAccUtils::SetAccAttr(aAttributes, nsAccessibilityAtoms::textIndent,
+                           value);
+
   return NS_OK;
 }
 
diff -r 17e9560465b0 accessible/src/base/nsCaretAccessible.cpp
--- a/accessible/src/base/nsCaretAccessible.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/accessible/src/base/nsCaretAccessible.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -195,6 +195,20 @@
                                           nsISelection *aSel,
                                           PRInt16 aReason)
 {
+  NS_ENSURE_ARG(aDoc);
+
+  nsCOMPtr<nsIDOMNode> docNode(do_QueryInterface(aDoc));
+  nsCOMPtr<nsIAccessibleDocument> accDoc =
+    nsAccessNode::GetDocAccessibleFor(docNode);
+
+  // Don't fire events until document is loaded.
+  if (!accDoc)
+    return NS_OK;
+
+  nsCOMPtr<nsIAccessible> accForDoc(do_QueryInterface(accDoc));
+  if (nsAccUtils::State(accForDoc) & nsIAccessibleStates::STATE_BUSY)
+    return NS_OK;
+
   nsCOMPtr<nsISelection2> sel2(do_QueryInterface(aSel));
 
   PRInt16 type = 0;
@@ -217,72 +231,22 @@
 
   mLastUsedSelection = do_GetWeakReference(aSel);
 
-  nsCOMPtr<nsIDocument> doc = do_QueryInterface(aDoc);
-  NS_ENSURE_TRUE(doc, NS_OK);
-  nsIPresShell *presShell = doc->GetPrimaryShell();
-  NS_ENSURE_TRUE(presShell, NS_OK);
+  PRInt32 rangeCount = 0;
+  nsresult rv = aSel->GetRangeCount(&rangeCount);
+  NS_ENSURE_SUCCESS(rv, rv);
 
-  // Get first nsIAccessibleText in parent chain and fire caret-move, selection-change event for it
-  nsCOMPtr<nsIAccessible> accessible;
-  nsIAccessibilityService *accService = mRootAccessible->GetAccService();
-  NS_ENSURE_TRUE(accService, NS_ERROR_FAILURE);
-  // Get accessible from selection's focus node or its parent
-  nsCOMPtr<nsIDOMNode> focusNode;
-  aSel->GetFocusNode(getter_AddRefs(focusNode));
-  if (!focusNode) {
+  if (rangeCount == 0) {
     mLastTextAccessible = nsnull;
     return NS_OK; // No selection
   }
 
-  nsCOMPtr<nsIAccessibleDocument> docAccessible =
-    nsAccessNode::GetDocAccessibleFor(focusNode);
-  nsCOMPtr<nsIAccessible> accessibleForDoc =
-    do_QueryInterface(docAccessible);
-  if (!accessibleForDoc) {
-    return NS_OK;
-  }
-  PRUint32 docState;
-  accessibleForDoc->GetFinalState(&docState, nsnull);
-  if (docState & nsIAccessibleStates::STATE_BUSY) {
-    return NS_OK;  // Don't fire caret moves until doc loaded
-  }
-
-  // Get focused node.
-  nsCOMPtr<nsIContent> focusContainer(do_QueryInterface(focusNode));
-  if (focusContainer && focusContainer->IsNodeOfType(nsINode::eELEMENT)) {
-    PRInt32 focusOffset = 0;
-    aSel->GetFocusOffset(&focusOffset);
-
-    nsCOMPtr<nsIContent> focusContent = focusContainer->GetChildAt(focusOffset);
-    focusNode = do_QueryInterface(focusContent);
-  }
-
-  // Get relevant accessible for the focused node.
-  nsCOMPtr<nsIAccessibleText> textAcc;
-  while (focusNode) {
-    // Make sure to get the correct starting node for selection events inside XBL content trees
-    nsCOMPtr<nsIDOMNode> relevantNode;
-    if (NS_SUCCEEDED(accService->GetRelevantContentNodeFor(focusNode, getter_AddRefs(relevantNode))) && relevantNode) {
-      focusNode  = relevantNode;
-    }
-
-    nsCOMPtr<nsIContent> content = do_QueryInterface(focusNode);
-    if (!content || !content->IsNodeOfType(nsINode::eTEXT)) {
-      accService->GetAccessibleInShell(focusNode, presShell,  getter_AddRefs(accessible));
-      textAcc = do_QueryInterface(accessible);
-      if (textAcc) {
-        break;
-      }
-    }
-    nsCOMPtr<nsIDOMNode> parentNode;
-    focusNode->GetParentNode(getter_AddRefs(parentNode));
-    focusNode.swap(parentNode);
-  }
-  NS_ASSERTION(textAcc, "No nsIAccessibleText for caret move event!"); // No nsIAccessibleText for caret move event!
-  NS_ENSURE_TRUE(textAcc, NS_ERROR_FAILURE);
+  nsCOMPtr<nsIDOMNode> textNode;
+  nsCOMPtr<nsIAccessibleText> textAcc =
+    nsAccUtils::GetTextAccessibleFromSelection(aSel, getter_AddRefs(textNode));
+  NS_ENSURE_STATE(textAcc);
 
   PRInt32 caretOffset;
-  nsresult rv = textAcc->GetCaretOffset(&caretOffset);
+  rv = textAcc->GetCaretOffset(&caretOffset);
   NS_ENSURE_SUCCESS(rv, rv);
 
   if (textAcc == mLastTextAccessible && caretOffset == mLastCaretOffset) {
@@ -296,7 +260,7 @@
   mLastTextAccessible = textAcc;
 
   nsCOMPtr<nsIAccessibleCaretMoveEvent> event =
-    new nsAccCaretMoveEvent(focusNode);
+    new nsAccCaretMoveEvent(textNode);
   NS_ENSURE_TRUE(event, NS_ERROR_OUT_OF_MEMORY);
 
   return mRootAccessible->FireDelayedAccessibleEvent(event);
@@ -311,34 +275,16 @@
   // the same accessible for newly appended range of the selection (for every
   // misspelled word). If spellchecking is disabled (for example,
   // @spellcheck="false" on html:body) then we won't fire any event.
-  nsCOMPtr<nsIDOMNode> targetNode;
-  aSel->GetFocusNode(getter_AddRefs(targetNode));
-  if (!targetNode)
-    return NS_OK;
 
-  // Get focused node.
-  nsCOMPtr<nsIContent> focusContainer(do_QueryInterface(targetNode));
-  if (focusContainer && focusContainer->IsNodeOfType(nsINode::eELEMENT)) {
-    PRInt32 focusOffset = 0;
-    aSel->GetFocusOffset(&focusOffset);
-    
-    nsCOMPtr<nsIContent> focusContent = focusContainer->GetChildAt(focusOffset);
-    targetNode = do_QueryInterface(focusContent);
-  }
+  nsCOMPtr<nsIAccessibleText> textAcc =
+    nsAccUtils::GetTextAccessibleFromSelection(aSel);
+  NS_ENSURE_STATE(textAcc);
 
-  nsCOMPtr<nsIAccessibleDocument> docAccessible =
-    nsAccessNode::GetDocAccessibleFor(targetNode);
-  NS_ENSURE_STATE(docAccessible);
-
-  nsCOMPtr<nsIAccessible> containerAccessible;
-  nsresult rv =
-    docAccessible->GetAccessibleInParentChain(targetNode, PR_TRUE,
-                                              getter_AddRefs(containerAccessible));
-  NS_ENSURE_SUCCESS(rv, rv);
+  nsCOMPtr<nsIAccessible> acc(do_QueryInterface(textAcc));
 
   nsCOMPtr<nsIAccessibleEvent> event =
     new nsAccEvent(nsIAccessibleEvent::EVENT_TEXT_ATTRIBUTE_CHANGED,
-                   containerAccessible, nsnull);
+                   acc, nsnull);
   NS_ENSURE_TRUE(event, NS_ERROR_OUT_OF_MEMORY);
 
   return mRootAccessible->FireAccessibleEvent(event);
diff -r 17e9560465b0 accessible/src/base/nsCoreUtils.cpp
--- a/accessible/src/base/nsCoreUtils.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/accessible/src/base/nsCoreUtils.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -167,8 +167,12 @@
   if (node->IsNodeOfType(nsINode::eELEMENT))
     CallQueryInterface(node, &element);
 
-  else if (node->IsNodeOfType(nsINode::eTEXT))
-    CallQueryInterface(node->GetNodeParent(), &element);
+  else if (node->IsNodeOfType(nsINode::eTEXT)) {
+    nsCOMPtr<nsINode> nodeParent = node->GetNodeParent();
+    NS_ASSERTION(nodeParent, "Text node has no parent!");
+    if (nodeParent)
+      CallQueryInterface(nodeParent, &element);
+  }
 
   else if (node->IsNodeOfType(nsINode::eDOCUMENT)) {
     nsCOMPtr<nsIDOMHTMLDocument> htmlDoc(do_QueryInterface(node));
diff -r 17e9560465b0 accessible/src/base/nsDocAccessible.cpp
--- a/accessible/src/base/nsDocAccessible.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/accessible/src/base/nsDocAccessible.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -510,7 +510,7 @@
       nsCoreUtils::GetDOMElementFor(DOMDocument);
     nsCOMPtr<nsIContent> content(do_QueryInterface(DOMElement));
 
-    if (!content->HasFlag(NODE_IS_EDITABLE))
+    if (!content || !content->HasFlag(NODE_IS_EDITABLE))
       return NS_OK;
   }
 
diff -r 17e9560465b0 accessible/src/base/nsTextUtils.cpp
--- a/accessible/src/base/nsTextUtils.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/accessible/src/base/nsTextUtils.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -87,8 +87,6 @@
   { "font-weight",       kAnyValue,       kCopyName,                  kCopyValue },
   { "text-decoration",   "line-through",  "text-line-through-style",  "solid" },
   { "text-decoration",   "underline",     "text-underline-style",     "solid" },
-  { "text-align",        kAnyValue,       kCopyName,                  kCopyValue },
-  { "text-indent",       kAnyValue,       kCopyName,                  kCopyValue },
   { "vertical-align",    kAnyValue,       "text-position",            kCopyValue }
 };
 
diff -r 17e9560465b0 accessible/src/html/nsHyperTextAccessible.cpp
--- a/accessible/src/html/nsHyperTextAccessible.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/accessible/src/html/nsHyperTextAccessible.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -1685,7 +1685,7 @@
   NS_ENSURE_TRUE(caretFrame, -1);
 
   PRInt32 lineNumber = 1;
-  nsCOMPtr<nsILineIterator> lineIterForCaret;
+  nsAutoLineIterator lineIterForCaret;
   nsCOMPtr<nsIContent> hyperTextContent = do_QueryInterface(mDOMNode);
   while (caretFrame) {
     if (hyperTextContent == caretFrame->GetContent()) {
@@ -1698,11 +1698,10 @@
     // Add lines for the sibling frames before the caret
     nsIFrame *sibling = parentFrame->GetFirstChild(nsnull);
     while (sibling && sibling != caretFrame) {
-      nsCOMPtr<nsILineIterator> lineIterForSibling = do_QueryInterface(sibling);
+      nsAutoLineIterator lineIterForSibling = sibling->GetLineIterator();
       if (lineIterForSibling) {
-        PRInt32 addLines;
         // For the frames before that grab all the lines
-        lineIterForSibling->GetNumLines(&addLines);
+        PRInt32 addLines = lineIterForSibling->GetNumLines();
         lineNumber += addLines;
       }
       sibling = sibling->GetNextSibling();
@@ -1710,11 +1709,10 @@
 
     // Get the line number relative to the container with lines
     if (!lineIterForCaret) {   // Add the caret line just once
-      lineIterForCaret = do_QueryInterface(parentFrame);
+      lineIterForCaret = parentFrame->GetLineIterator();
       if (lineIterForCaret) {
         // Ancestor of caret
-        PRInt32 addLines;
-        lineIterForCaret->FindLineContaining(caretFrame, &addLines);
+        PRInt32 addLines = lineIterForCaret->FindLineContaining(caretFrame);
         lineNumber += addLines;
       }
     }
diff -r 17e9560465b0 accessible/tests/mochitest/Makefile.in
--- a/accessible/tests/mochitest/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/accessible/tests/mochitest/Makefile.in	Thu Oct 30 05:41:44 2008 -0400
@@ -48,6 +48,7 @@
 _TEST_FILES =\
 		moz.png \
 		longdesc_src.html \
+		attributes.js \
 		common.js \
 		nsIAccessible_actions.js \
 		nsIAccessible_name.css \
diff -r 17e9560465b0 accessible/tests/mochitest/attributes.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/accessible/tests/mochitest/attributes.js	Thu Oct 30 05:41:44 2008 -0400
@@ -0,0 +1,141 @@
+////////////////////////////////////////////////////////////////////////////////
+// Object attributes.
+
+/**
+ * Test object attributes.
+ *
+ * @param aID                   [in] the ID of DOM element having accessible
+ * @param aAttrs                [in] the map of expected object attributes
+ *                              (name/value pairs)
+ * @param aSkipUnexpectedAttrs  [in] points this function doesn't fail if
+ *                              unexpected attribute is encountered
+ */
+function testAttrs(aID, aAttrs, aSkipUnexpectedAttrs)
+{
+  var accessible = getAccessible(aID);
+  if (!accessible)
+    return;
+
+  var attrs = null;
+  try {
+    attrs = accessible.attributes;
+  } catch (e) { }
+  
+  if (!attrs) {
+    ok(false, "Can't get object attributes for " + aID);
+    return;
+  }
+  
+  var errorMsg = " for " + aID;
+  compareAttrs(errorMsg, attrs, aAttrs, aSkipUnexpectedAttrs);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// Text attributes.
+
+/**
+ * Test text attributes.
+ *
+ * @param aID                   [in] the ID of DOM element having text
+ *                              accessible
+ * @param aOffset               [in] the offset inside text accessible to fetch
+ *                              text attributes
+ * @param aAttrs                [in] the map of expected text attributes
+ *                              (name/value pairs)
+ * @param aStartOffset          [in] expected start offset where text attributes
+ *                              are applied
+ * @param aEndOffset            [in] expected end offset where text attribute
+ *                              are applied
+ * @param aSkipUnexpectedAttrs  [in] points the function doesn't fail if
+ *                              unexpected attribute is encountered
+ */
+function testTextAttrs(aID, aOffset, aAttrs, aStartOffset, aEndOffset,
+                       aSkipUnexpectedAttrs)
+{
+  var accessible = getAccessible(aID, [nsIAccessibleText]);
+  if (!accessible)
+    return;
+
+  var startOffset = { value: -1 };
+  var endOffset = { value: -1 };
+  var attrs = null;
+  try {
+    attrs = accessible.getTextAttributes(false, aOffset,
+                                         startOffset, endOffset);
+  } catch (e) {
+  }
+
+  if (!attrs) {
+    ok(false, "Can't get text attributes for " + aID);
+    return;
+  }
+
+  var errorMsg = " for " + aID + " at offset " + aOffset;
+
+  is(startOffset.value, aStartOffset, "Wrong start offset" + errorMsg);
+  is(endOffset.value, aEndOffset, "Wrong end offset" + errorMsg);
+
+  compareAttrs(errorMsg, attrs, aAttrs, aSkipUnexpectedAttrs);
+}
+
+/**
+ * Test default text attributes.
+ *
+ * @param aID                   [in] the ID of DOM element having text
+ *                              accessible
+ * @param aDefAttrs             [in] the map of expected text attributes
+ *                              (name/value pairs)
+ * @param aSkipUnexpectedAttrs  [in] points the function doesn't fail if
+ *                              unexpected attribute is encountered
+ */
+function testDefaultTextAttrs(aID, aDefAttrs, aSkipUnexpectedAttrs)
+{
+  var accessible = getAccessible(aID, [nsIAccessibleText]);
+  if (!accessible)
+    return;
+  
+  var defAttrs = null;
+  try{
+    defAttrs = accessible.defaultTextAttributes;
+  } catch (e) {
+  }
+  
+  if (!defAttrs) {
+    ok(false, "Can't get default text attributes for " + aID);
+    return;
+  }
+  
+  var errorMsg = ". Getting default text attributes for " + aID;
+  compareAttrs(errorMsg, defAttrs, aDefAttrs, aSkipUnexpectedAttrs);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// Private.
+
+function compareAttrs(aErrorMsg, aAttrs, aExpectedAttrs, aSkipUnexpectedAttrs)
+{
+  var enumerate = aAttrs.enumerate();
+  while (enumerate.hasMoreElements()) {
+    var prop = enumerate.getNext().QueryInterface(nsIPropertyElement);
+
+    if (!(prop.key in aExpectedAttrs)) {
+      if (!aSkipUnexpectedAttrs)
+        ok(false, "Unexpected attribute '" + prop.key + "' having '" +
+           prop.value + "'" + aErrorMsg);
+    } else {
+      is(prop.value, aExpectedAttrs[prop.key],
+         "Attribute '" + prop.key + " 'has wrong value" + aErrorMsg);
+    }
+  }
+
+  for (var name in aExpectedAttrs) {
+    var value = "";
+    try {
+      value = aAttrs.getStringProperty(name);
+    } catch(e) { }
+
+    if (!value)
+      ok(false,
+         "There is no expected attribute '" + name + "' " + aErrorMsg);
+  }
+}
diff -r 17e9560465b0 accessible/tests/mochitest/common.js
--- a/accessible/tests/mochitest/common.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/accessible/tests/mochitest/common.js	Thu Oct 30 05:41:44 2008 -0400
@@ -29,6 +29,7 @@
 const nsIObserverService = Components.interfaces.nsIObserverService;
 
 const nsIDOMNode = Components.interfaces.nsIDOMNode;
+const nsIPropertyElement = Components.interfaces.nsIPropertyElement;
 
 ////////////////////////////////////////////////////////////////////////////////
 // Roles
@@ -36,6 +37,7 @@
 const ROLE_COMBOBOX = nsIAccessibleRole.ROLE_COMBOBOX;
 const ROLE_COMBOBOX_LIST = nsIAccessibleRole.ROLE_COMBOBOX_LIST;
 const ROLE_COMBOBOX_OPTION = nsIAccessibleRole.ROLE_COMBOBOX_OPTION;
+const ROLE_DOCUMENT = nsIAccessibleRole.ROLE_DOCUMENT;
 const ROLE_LABEL = nsIAccessibleRole.ROLE_LABEL;
 const ROLE_LIST = nsIAccessibleRole.ROLE_LIST;
 const ROLE_OPTION = nsIAccessibleRole.ROLE_OPTION;
diff -r 17e9560465b0 accessible/tests/mochitest/test_aria_activedescendant.html
--- a/accessible/tests/mochitest/test_aria_activedescendant.html	Thu Oct 23 09:51:35 2008 -0700
+++ b/accessible/tests/mochitest/test_aria_activedescendant.html	Thu Oct 30 05:41:44 2008 -0400
@@ -1,76 +1,72 @@
-<!DOCTYPE html>
-<html>
-<!--
-https://bugzilla.mozilla.org/show_bug.cgi?id=429547
--->
-<head>
-  <title>Table indexes chrome tests</title>
-  <link rel="stylesheet" type="text/css" href="chrome://mochikit/content/tests/SimpleTest/test.css" />
-
-  <script type="application/javascript" src="chrome://mochikit/content/MochiKit/packed.js"></script>
-  <script type="application/javascript" src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>
-
-  <script type="application/javascript">
-    const nsIAccessibleRetrieval = Components.interfaces.nsIAccessibleRetrieval;
-    const ELEMENT_NODE = Components.interfaces.nsIDOMNode.ELEMENT_NODE;
-
-    var gAccRetrieval = null;
-    var gContainerFocused = false;
-
-    function doTest()
-    {
-      var focusHandler = {
-        handleEvent: function handleEvent(aEvent) {
-          var target = aEvent.target;
-          if (target.nodeType ==  ELEMENT_NODE &&
-              target.getAttribute("id") == "container")
-            gContainerFocused = true;
-        }
-      };
-
-      var container = document.getElementById("container");
-      container.addEventListener("focus", focusHandler, false);
-
-      gAccRetrieval = Components.classes["@mozilla.org/accessibleRetrieval;1"].
-                      getService(nsIAccessibleRetrieval);
-
-      var item2 = document.getElementById("item2");
-      var item2Acc = null;
-      try {
-        item2Acc = gAccRetrieval.getAccessibleFor(item2);
-      } catch (e) {}
-      ok (item2Acc,
-          "The element with ID and an ancestor with 'aria-activedescedant' attribute should be accessible.");
-
-      if (item2Acc)
-        item2Acc.takeFocus();
-
-      ok(gContainerFocused,
-         "Container with active descedant didn't recieved the focus.");
-
-      SimpleTest.finish();
-    }
-
-    SimpleTest.waitForExplicitFinish();
-    addLoadEvent(doTest);
-  </script>
-</head>
-<body>
-
-  <a target="_blank"
-     href="https://bugzilla.mozilla.org/show_bug.cgi?id=429547"
-     title="Support aria-activedescendant usage in nsIAccesible::TakeFocus()">
-    Mozilla Bug 429547
-  </a>
-  <p id="display"></p>
-  <div id="content" style="display: none"></div>
-  <pre id="test">
-  </pre>
-
-  <div aria-activedescendant="item1" id="container" tabindex="1">
-    <div id="item1">item1</div>
-    <div id="item2">item2</div>
-    <div id="item3">item3</div>
-  </div>
-</body>
-</html>
+<!DOCTYPE html>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=429547
+-->
+<head>
+  <title>aria-activedescendant property chrome tests</title>
+  <link rel="stylesheet" type="text/css" href="chrome://mochikit/content/tests/SimpleTest/test.css" />
+
+  <script type="application/javascript"
+          src="chrome://mochikit/content/MochiKit/packed.js"></script>
+  <script type="application/javascript"
+          src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>
+
+  <script type="application/javascript"
+          src="chrome://mochikit/content/a11y/accessible/common.js"></script>
+
+  <script type="application/javascript">
+    const ELEMENT_NODE = nsIDOMNode.ELEMENT_NODE;
+
+    var gContainerFocused = false;
+
+    function doTest()
+    {
+      var focusHandler = {
+        handleEvent: function handleEvent(aEvent) {
+          var target = aEvent.target;
+          if (target.nodeType ==  ELEMENT_NODE &&
+              target.getAttribute("id") == "container")
+            gContainerFocused = true;
+        }
+      };
+
+      var container = document.getElementById("container");
+      container.addEventListener("focus", focusHandler, false);
+
+      var item2Acc = getAccessible("item2");
+      if (item2Acc) {
+        item2Acc.takeFocus();
+  
+        ok(gContainerFocused,
+           "Container with active descendant didn't receive the focus.");
+      }
+
+      container.removeEventListener("focus", focusHandler, false);
+
+      SimpleTest.finish();
+    }
+
+    SimpleTest.waitForExplicitFinish();
+    addLoadEvent(doTest);
+  </script>
+</head>
+<body>
+
+  <a target="_blank"
+     href="https://bugzilla.mozilla.org/show_bug.cgi?id=429547"
+     title="Support aria-activedescendant usage in nsIAccesible::TakeFocus()">
+    Mozilla Bug 429547
+  </a>
+  <p id="display"></p>
+  <div id="content" style="display: none"></div>
+  <pre id="test">
+  </pre>
+
+  <div aria-activedescendant="item1" id="container" tabindex="1">
+    <div id="item1">item1</div>
+    <div id="item2">item2</div>
+    <div id="item3">item3</div>
+  </div>
+</body>
+</html>
diff -r 17e9560465b0 accessible/tests/mochitest/test_aria_role_article.html
--- a/accessible/tests/mochitest/test_aria_role_article.html	Thu Oct 23 09:51:35 2008 -0700
+++ b/accessible/tests/mochitest/test_aria_role_article.html	Thu Oct 30 05:41:44 2008 -0400
@@ -1,51 +1,47 @@
-<!DOCTYPE html>
-<html>
-<!--
-https://bugzilla.mozilla.org/show_bug.cgi?id=429666
--->
-<head>
-  <title>Expose ROLE_DOCUMENT for ARIA landmarks that inherit from document chrome tests</title>
-  <link rel="stylesheet" type="text/css" href="chrome://mochikit/content/tests/SimpleTest/test.css" />
-
-  <script type="application/javascript" src="chrome://mochikit/content/MochiKit/packed.js"></script>
-  <script type="application/javascript" src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>
-
-  <script type="application/javascript">
-    function doTest()
-    {
-      var accRetrieval = Components.classes["@mozilla.org/accessibleRetrieval;1"].
-                       getService(Components.interfaces.nsIAccessibleRetrieval);
-
-      // Test article exposed as document
-      var articleElement = document.getElementById("testArticle");
-      var articleAcc = null;
-      try {
-        articleAcc = accRetrieval.getAccessibleFor(articleElement);
-      } catch(e) { }
-      ok(articleAcc, "no accessible for article!");
-      if (articleAcc) {
-        is(articleAcc.finalRole,
-           Components.interfaces.nsIAccessibleRole.ROLE_DOCUMENT,
-           "Wrong role for article!");
-        is(articleAcc.name, "Test article", "Wrong name for article!");
-      }
-
-      SimpleTest.finish();
-    }
-
-    SimpleTest.waitForExplicitFinish();
-    addLoadEvent(doTest);
-  </script>
-</head>
-<body>
-
-  <a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=429666">Mozilla Bug 429666</a>
-  <p id="display"></p>
-  <div id="content" style="display: none"></div>
-  <pre id="test">
-  </pre>
-  <div id="testArticle" role="article" title="Test article">
-    <p>This is a paragraph inside the article.</p>
-  </div>
-</body>
-</html>
+<!DOCTYPE html>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=429666
+-->
+<head>
+  <title>Expose ROLE_DOCUMENT for ARIA landmarks that inherit from document chrome tests</title>
+  <link rel="stylesheet" type="text/css" href="chrome://mochikit/content/tests/SimpleTest/test.css" />
+
+  <script type="application/javascript"
+          src="chrome://mochikit/content/MochiKit/packed.js"></script>
+  <script type="application/javascript"
+          src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>
+
+  <script type="application/javascript"
+          src="chrome://mochikit/content/a11y/accessible/common.js"></script>
+
+  <script type="application/javascript">
+    function doTest()
+    {
+      // Test article exposed as document
+      var articleAcc = getAccessible("testArticle");
+      if (articleAcc) {
+        is(articleAcc.finalRole, ROLE_DOCUMENT,
+           "Wrong role for article!");
+        is(articleAcc.name, "Test article", "Wrong name for article!");
+      }
+
+      SimpleTest.finish();
+    }
+
+    SimpleTest.waitForExplicitFinish();
+    addLoadEvent(doTest);
+  </script>
+</head>
+<body>
+
+  <a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=429666">Mozilla Bug 429666</a>
+  <p id="display"></p>
+  <div id="content" style="display: none"></div>
+  <pre id="test">
+  </pre>
+  <div id="testArticle" role="article" title="Test article">
+    <p>This is a paragraph inside the article.</p>
+  </div>
+</body>
+</html>
diff -r 17e9560465b0 accessible/tests/mochitest/test_cssattrs.html
--- a/accessible/tests/mochitest/test_cssattrs.html	Thu Oct 23 09:51:35 2008 -0700
+++ b/accessible/tests/mochitest/test_cssattrs.html	Thu Oct 30 05:41:44 2008 -0400
@@ -1,57 +1,46 @@
 <html>
 <!--
 https://bugzilla.mozilla.org/show_bug.cgi?id=439566
+https://bugzilla.mozilla.org/show_bug.cgi?id=460932
 -->
 <head>
   <title>CSS-like attributes tests</title>
-  <link rel="stylesheet" type="text/css" href="chrome://mochikit/content/tests/SimpleTest/test.css" />
+  <link rel="stylesheet" type="text/css"
+        href="chrome://mochikit/content/tests/SimpleTest/test.css" />
 
-  <script type="application/javascript" src="chrome://mochikit/content/MochiKit/packed.js"></script>
-  <script type="application/javascript" src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>
+  <script type="application/javascript"
+          src="chrome://mochikit/content/MochiKit/packed.js"></script>
+  <script type="application/javascript"
+          src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>
+
+  <script type="application/javascript"
+          src="chrome://mochikit/content/a11y/accessible/common.js"></script>
+  <script type="application/javascript"
+          src="chrome://mochikit/content/a11y/accessible/attributes.js"></script>
 
   <script type="application/javascript">
-    const nsIAccessibleRetrieval = Components.interfaces.nsIAccessibleRetrieval;
+    function testCSSAttrs(aID)
+    {
+      var node = document.getElementById(aID);
+      var computedStyle = document.defaultView.getComputedStyle(node, "");
 
-    var gAccRetrieval = null;
-
-    function testAttr(aID, aName, aValue)
-    {
-      var acc = null;
-      try {
-        acc = gAccRetrieval.getAccessibleFor(document.getElementById(aID));
-      } catch(e) { }
-
-      if (!acc) {
-        ok(false, "Can't get accessible object for " + aID);
-        return;
-      }
-
-      var attrs = null;
-      try {
-        attrs = acc.attributes;
-      } catch(e) { }
-
-      if (!attrs) {
-        ok(false, "Can't get accessible attributes for " + aID);
-        return;
-      }
-      
-      is(attrs.getStringProperty(aName), aValue,
-         "Accessible with ID " + aID + " has wrong attribute value");
+      var attrs = {
+        "display": computedStyle.display,
+        "text-align": computedStyle.textAlign,
+        "text-indent": computedStyle.textIndent
+      };
+      testAttrs(aID, attrs, true);
     }
 
     function doTest()
     {
-      gAccRetrieval = Components.classes["@mozilla.org/accessibleRetrieval;1"].
-                      getService(nsIAccessibleRetrieval);
-
-      testAttr("span", "display", "inline");
-      testAttr("div", "display", "block");
-      testAttr("p", "display", "block");
-      testAttr("input", "display", "inline");
-      testAttr("table", "display", "table");
-      testAttr("tr", "display", "table-row");
-      testAttr("td", "display", "table-cell");
+      testCSSAttrs("span");
+      testCSSAttrs("div");
+      testCSSAttrs("p");
+      testCSSAttrs("input");
+      testCSSAttrs("table");
+      testCSSAttrs("tr");
+      testCSSAttrs("td");
 
       SimpleTest.finish();
     }
@@ -67,6 +56,12 @@
      title="Include the css display property as an IAccessible2 object attribute">
     Mozilla Bug 439566
   </a>
+  <a target="_blank"
+     href="https://bugzilla.mozilla.org/show_bug.cgi?id=460932"
+     title="text-indent and text-align should really be object attribute">
+    Mozilla Bug 460932
+  </a>
+
   <p id="display"></p>
   <div id="content" style="display: none"></div>
   <pre id="test">
diff -r 17e9560465b0 accessible/tests/mochitest/test_events_caretmove.html
--- a/accessible/tests/mochitest/test_events_caretmove.html	Thu Oct 23 09:51:35 2008 -0700
+++ b/accessible/tests/mochitest/test_events_caretmove.html	Thu Oct 30 05:41:44 2008 -0400
@@ -44,6 +44,26 @@
       }
     }
 
+    function synthFocusTest(aNode)
+    {
+      // bug 460417
+      this.node = aNode;
+      this.testFunc = function testFunc()
+      {
+        this.node.focus();
+      }
+    }
+
+    function synthSelectAllTest(aNode)
+    {
+      // bug 460417
+      this.node = aNode;
+      this.testFunc = function testFunc()
+      {
+        this.node.select();
+      }
+    }
+
     var gTestsArray = [];
     var gTestIdx = -1;
 
@@ -83,6 +103,8 @@
     function doTests()
     {
       var textbox = document.getElementById("textbox");
+      gTestsArray.push(new synthFocusTest(textbox));
+      gTestsArray.push(new synthSelectAllTest(textbox));
       gTestsArray.push(new synthMouseTest(textbox));
       gTestsArray.push(new synthKeyTest(textbox, "VK_RIGHT"));
 
diff -r 17e9560465b0 accessible/tests/mochitest/test_groupattrs.xul
--- a/accessible/tests/mochitest/test_groupattrs.xul	Thu Oct 23 09:51:35 2008 -0700
+++ b/accessible/tests/mochitest/test_groupattrs.xul	Thu Oct 30 05:41:44 2008 -0400
@@ -10,43 +10,29 @@
           src="chrome://mochikit/content/MochiKit/packed.js"></script>
   <script type="application/javascript"
           src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js" />
+
+  <script type="application/javascript"
+          src="chrome://mochikit/content/a11y/accessible/common.js" />
+  <script type="application/javascript"
+          src="chrome://mochikit/content/a11y/accessible/attributes.js" />
+
   <script type="application/javascript">
   <![CDATA[
-    var gAccService = null;
-
-    function accAttributes(aId)
-    {
-      this.getAttribute = function getAttribute(aName)
-      {
-        try {
-          return this.mAttrs.getStringProperty(aName);
-        } catch (e) {
-          return "";
-        }
-      }
-
-      this.mAcc = gAccService.getAccessibleFor(document.getElementById(aId));
-      ok(this.mAcc, "Can't get accessible for " + aId);
-
-      if (this.mAcc)
-        this.mAttrs = this.mAcc.attributes;
-    }
-
     function testGroupAttrs(aID, aPosInSet, aSetSize, aLevel)
     {
-      var attrs = new accAttributes(aID);
-      is(attrs.getAttribute("posinset"), aPosInSet, "Wrong posinset on " + aID);
-      is(attrs.getAttribute("setsize"), aSetSize, "Wrong setsize on " + aID);
+      var attrs = {
+        "posinset": aPosInSet,
+        "setsize": aSetSize
+      };
+
       if (aLevel)
-        is(attrs.getAttribute("level"), aLevel, "Wrong level on " + aID);
+        attrs["level"] = aLevel;
+
+      testAttrs(aID, attrs, true);
     }
 
     function doTest()
     {
-      // Activate accessibility, otherwise events aren't fired.
-      gAccService = Components.classes["@mozilla.org/accessibleRetrieval;1"].
-                    getService(Components.interfaces.nsIAccessibleRetrieval);
-
       //////////////////////////////////////////////////////////////////////////
       // xul:listbox (bug 417317)
       testGroupAttrs("item1", "1", "2");
diff -r 17e9560465b0 accessible/tests/mochitest/test_nsIAccessible_name.html
--- a/accessible/tests/mochitest/test_nsIAccessible_name.html	Thu Oct 23 09:51:35 2008 -0700
+++ b/accessible/tests/mochitest/test_nsIAccessible_name.html	Thu Oct 30 05:41:44 2008 -0400
@@ -128,6 +128,11 @@
 
       testName("textareawithchild", "Story: Bar");
 
+      /////////////////////////////////////////////////////////////////////////
+      // label with nested combobox
+
+      testName("comboinmiddle", "Subscribe to ATOM feed.");
+	   
       SimpleTest.finish();
     }
 
@@ -281,5 +286,17 @@
     </label>
   </form>
 
+  <!-- A label with a nested control in the middle -->
+  <form>
+    <label id="comboinmiddle">
+      Subscribe to
+      <select id="combo3" name="occupation">
+        <option>ATOM</option>
+        <option>RSS</option>
+      </select>
+      feed.
+    </label>
+  </form>
+
 </body>
 </html>
diff -r 17e9560465b0 accessible/tests/mochitest/test_textattrs.html
--- a/accessible/tests/mochitest/test_textattrs.html	Thu Oct 23 09:51:35 2008 -0700
+++ b/accessible/tests/mochitest/test_textattrs.html	Thu Oct 30 05:41:44 2008 -0400
@@ -4,139 +4,22 @@
   <title>Text attributes tests</title>
   <link rel="stylesheet" type="text/css" href="chrome://mochikit/content/tests/SimpleTest/test.css" />
 
-  <script type="application/javascript" src="chrome://mochikit/content/MochiKit/packed.js"></script>
-  <script type="application/javascript" src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>
+  <script type="application/javascript"
+          src="chrome://mochikit/content/MochiKit/packed.js"></script>
+  <script type="application/javascript"
+          src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>
+
+  <script type="application/javascript"
+          src="chrome://mochikit/content/a11y/accessible/common.js"></script>
+  <script type="application/javascript"
+          src="chrome://mochikit/content/a11y/accessible/attributes.js"></script>
 
   <script type="application/javascript">
-    const nsIAccessibleRetrieval = Components.interfaces.nsIAccessibleRetrieval;
-    const nsIAccessibleText = Components.interfaces.nsIAccessibleText;
-    const nsIAccessibleEvent = Components.interfaces.nsIAccessibleEvent;
 
     const nsIDOMNSEditableElement =
       Components.interfaces.nsIDOMNSEditableElement;
-    const nsIObserverService = Components.interfaces.nsIObserverService;
 
-    var gAccRetrieval = null;
     var gComputedStyle = null;
-
-    /**
-     * Test text attributes.
-     *
-     * @param aID               the ID of DOM element having text accessible
-     * @param aOffset           the offset inside text accessible to fetch
-     *                          text attributes
-     * @param aAttrs            the map of text attributes (name/value pairs)
-     * @param aStartOffset      the start offset where text attributes are
-     *                          applied
-     * @param aEndOffset        the end offset where text attribute are applied
-     */
-    function testTextAttrs(aID, aOffset,
-                           aAttrs, aStartOffset, aEndOffset)
-    {
-      var accessible = getTextAccessible(aID);
-      if (!accessible)
-        return;
-
-      var startOffset = { value: -1 };
-      var endOffset = { value: -1 };
-      var attrs = null;
-      try {
-        attrs = accessible.getTextAttributes(false,
-                                             aOffset,
-                                             startOffset, endOffset);
-      } catch (e) {
-      }
-
-      if (!attrs) {
-        ok(false, "Can't get text attributes for " + aID);
-        return;
-      }
-
-      var errorMsg = " for " + aID + " at offset " + aOffset;
-      is(startOffset.value, aStartOffset,
-         "Wrong start offset" + errorMsg);
-      is(endOffset.value, aEndOffset,
-          "Wrong end offset" + errorMsg);
-
-      compareTextAttrs(errorMsg, attrs, aAttrs);
-   }
-
-   /**
-    * Test default text attributes.
-    *
-    * @param aID               the ID of DOM element having text accessible
-    * @param aDefAttrs         the list of default text attributes (name/value
-    *                          pairs)
-    */
-   function testDefaultTextAttrs(aID, aDefAttrs)
-   {
-     var accessible = getTextAccessible(aID);
-     if (!accessible)
-       return;
-
-      var defAttrs = null;
-      try{
-        defAttrs = accessible.defaultTextAttributes;
-      } catch (e) {
-      }
-
-      if (!defAttrs) {
-        ok(false, "Can't get default attributes for " + aID);
-        return;
-      }
-
-      var errorMsg = ". Getting default attributes for " + aID;
-      compareTextAttrs(errorMsg, defAttrs, aDefAttrs);
-    }
-
-    function getTextAccessible(aID)
-    {
-      var node = document.getElementById(aID);
-      if (!node) {
-        ok(false, "Can't get the element with ID " + aID);
-        return;
-      }
-
-      var accessible = null;
-      try {
-        accessible = gAccRetrieval.getAccessibleFor(node);
-        accessible.QueryInterface(nsIAccessibleText);
-      } catch (e) {
-      }
-
-      if (!accessible)
-        ok(false, "Can't query nsIAccessibleText interface for " + aID);
-
-      return accessible;
-    }
-
-    function compareTextAttrs(aErrorMsg, aAttrs, aExpectedAttrs)
-    {
-      var enumerate = aAttrs.enumerate();
-      while (enumerate.hasMoreElements()) {
-        var prop = enumerate.getNext().
-          QueryInterface(Components.interfaces.nsIPropertyElement);
-
-        if (!(prop.key in aExpectedAttrs))
-          ok(false,
-             "Unexpected attribute '" + prop.key + "' having '" + prop.value + "'" + aErrorMsg);
-        else
-          is(prop.value, aExpectedAttrs[prop.key],
-             "Attribute '" + prop.key + " 'has wrong value" + aErrorMsg);
-      }
-
-      for (var name in aExpectedAttrs) {
-        var value = "";
-        try {
-          value = aAttrs.getStringProperty(name);
-        } catch(e) {
-        }
-
-        if (!value)
-          ok(false,
-             "There is no expected attribute '" + name + "' " + aErrorMsg);
-      }
-    }
 
     var gObserverService = null;
     var gA11yEventObserver = null;
@@ -161,7 +44,7 @@
 
       // Add accessibility event listeners
       var gObserverService = Components.classes["@mozilla.org/observer-service;1"].
-                            getService(nsIObserverService);
+                             getService(nsIObserverService);
 
       gObserverService.addObserver(gA11yEventObserver, "accessible-event",
                                   false);
@@ -180,11 +63,9 @@
           gComputedStyle = document.defaultView.getComputedStyle(node, "");
           var defAttrs = {
             "font-style": gComputedStyle.fontStyle,
-            "text-align": gComputedStyle.textAlign,
             "font-size": gComputedStyle.fontSize,
             "background-color": gComputedStyle.backgroundColor,
             "font-weight": gComputedStyle.fontWeight,
-            "text-indent": gComputedStyle.textIndent,
             "color": gComputedStyle.color,
             "font-family": gComputedStyle.fontFamily,
             "text-position": gComputedStyle.verticalAlign
@@ -214,9 +95,6 @@
 
     function doTest()
     {
-      gAccRetrieval = Components.classes["@mozilla.org/accessibleRetrieval;1"].
-                      getService(nsIAccessibleRetrieval);
-
       //////////////////////////////////////////////////////////////////////////
       // area1
       var ID = "area1";
@@ -224,11 +102,9 @@
       gComputedStyle = document.defaultView.getComputedStyle(tempElem, "");
       var defAttrs = {
         "font-style": gComputedStyle.fontStyle,
-        "text-align": gComputedStyle.textAlign,
         "font-size": gComputedStyle.fontSize,
         "background-color": "rgb(0, 0, 0)", // XXX 455834
         "font-weight": gComputedStyle.fontWeight,
-        "text-indent": gComputedStyle.textIndent,
         "color": gComputedStyle.color,
         "font-family": gComputedStyle.fontFamily,
         "text-position": gComputedStyle.verticalAlign
@@ -254,11 +130,9 @@
       gComputedStyle = document.defaultView.getComputedStyle(tempElem, "");
       defAttrs = {
         "font-style": gComputedStyle.fontStyle,
-        "text-align": gComputedStyle.textAlign,
         "font-size": gComputedStyle.fontSize,
         "background-color": "rgb(0, 0, 0)", // XXX bug 455834
         "font-weight": gComputedStyle.fontWeight,
-        "text-indent": gComputedStyle.textIndent,
         "color": gComputedStyle.color,
         "font-family": gComputedStyle.fontFamily,
         "text-position": gComputedStyle.verticalAlign
@@ -295,11 +169,9 @@
       gComputedStyle = document.defaultView.getComputedStyle(tempElem, "");
       defAttrs = {
         "font-style": gComputedStyle.fontStyle,
-        "text-align": gComputedStyle.textAlign,
         "font-size": gComputedStyle.fontSize,
         "background-color": gComputedStyle.backgroundColor,
         "font-weight": gComputedStyle.fontWeight,
-        "text-indent": gComputedStyle.textIndent,
         "color": gComputedStyle.color,
         "font-family": gComputedStyle.fontFamily,
         "text-position": gComputedStyle.verticalAlign
@@ -335,11 +207,9 @@
       gComputedStyle = document.defaultView.getComputedStyle(tempElem, "");
       defAttrs = {
         "font-style": gComputedStyle.fontStyle,
-        "text-align": gComputedStyle.textAlign,
         "font-size": gComputedStyle.fontSize,
         "background-color": "rgb(0, 0, 0)", // XXX bug 455834
         "font-weight": gComputedStyle.fontWeight,
-        "text-indent": gComputedStyle.textIndent,
         "color": gComputedStyle.color,
         "font-family": gComputedStyle.fontFamily,
         "text-position": gComputedStyle.verticalAlign
@@ -369,11 +239,9 @@
       gComputedStyle = document.defaultView.getComputedStyle(tempElem, "");
       defAttrs = {
         "font-style": gComputedStyle.fontStyle,
-        "text-align": gComputedStyle.textAlign,
         "font-size": gComputedStyle.fontSize,
         "background-color": "rgb(0, 0, 0)", // XXX bug 455834
         "font-weight": gComputedStyle.fontWeight,
-        "text-indent": gComputedStyle.textIndent,
         "color": gComputedStyle.color,
         "font-family": gComputedStyle.fontFamily,
         "text-position": gComputedStyle.verticalAlign
@@ -404,11 +272,9 @@
       gComputedStyle = document.defaultView.getComputedStyle(tempElem, "");
       defAttrs = {
         "font-style": gComputedStyle.fontStyle,
-        "text-align": gComputedStyle.textAlign,
         "font-size": gComputedStyle.fontSize,
         "background-color": "rgb(0, 0, 0)", // XXX bug 455834
         "font-weight": gComputedStyle.fontWeight,
-        "text-indent": gComputedStyle.textIndent,
         "color": gComputedStyle.color,
         "font-family": gComputedStyle.fontFamily,
         "text-position": gComputedStyle.verticalAlign
@@ -457,11 +323,9 @@
       gComputedStyle = document.defaultView.getComputedStyle(tempElem, "");
       defAttrs = {
         "font-style": gComputedStyle.fontStyle,
-        "text-align": gComputedStyle.textAlign,
         "font-size": gComputedStyle.fontSize,
         "background-color": "rgb(0, 0, 0)", // XXX 455834
         "font-weight": gComputedStyle.fontWeight,
-        "text-indent": gComputedStyle.textIndent,
         "color": gComputedStyle.color,
         "font-family": gComputedStyle.fontFamily,
         "text-position": gComputedStyle.verticalAlign
diff -r 17e9560465b0 browser/app/profile/firefox.js
--- a/browser/app/profile/firefox.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/app/profile/firefox.js	Thu Oct 30 05:41:44 2008 -0400
@@ -624,6 +624,8 @@
 pref("browser.safebrowsing.provider.0.reportGenericURL", "http://{moz:locale}.phish-generic.mozilla.com/?hl={moz:locale}");
 pref("browser.safebrowsing.provider.0.reportErrorURL", "http://{moz:locale}.phish-error.mozilla.com/?hl={moz:locale}");
 pref("browser.safebrowsing.provider.0.reportPhishURL", "http://{moz:locale}.phish-report.mozilla.com/?hl={moz:locale}");
+pref("browser.safebrowsing.provider.0.reportMalwareURL", "http://{moz:locale}.malware-report.mozilla.com/?hl={moz:locale}");
+pref("browser.safebrowsing.provider.0.reportMalwareErrorURL", "http://{moz:locale}.malware-error.mozilla.com/?hl={moz:locale}");
 
 // FAQ URL
 pref("browser.safebrowsing.warning.infoURL", "http://%LOCALE%.www.mozilla.com/%LOCALE%/firefox/phishing-protection/");
@@ -745,7 +747,7 @@
 // 0 - don't pre-populate anything
 // 1 - pre-populate site URL, but don't fetch certificate
 // 2 - pre-populate site URL and pre-fetch certificate
-pref("browser.ssl_override_behavior", 1);
+pref("browser.ssl_override_behavior", 2);
 
 // Controls the display of domain in the identity box for SSL connections.
 // 0 - do not show domain
@@ -771,3 +773,6 @@
 
 // base URL for web-based support pages
 pref("app.support.baseURL", "http://support.mozilla.com/1/%APP%/%VERSION%/%OS%/%LOCALE%/");
+
+// Name of alternate about: page for certificate errors (when undefined, defaults to about:neterror)
+pref("security.alternate_certificate_error_page", "certerror");
diff -r 17e9560465b0 browser/base/content/browser-context.inc
--- a/browser/base/content/browser-context.inc	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/base/content/browser-context.inc	Thu Oct 30 05:41:44 2008 -0400
@@ -99,13 +99,18 @@
                 accesskey="&mediaHideControls.accesskey;"
                 oncommand="gContextMenu.mediaCommand('hidecontrols');"/>
       <menuseparator id="context-media-sep-commands"/>
-      <menuitem id="context-showimage"
-                label="&showImageCmd.label;"
-                accesskey="&showImageCmd.accesskey;"
-                oncommand="gContextMenu.showImage();"/>
+      <menuitem id="context-reloadimage"
+                label="&reloadImageCmd.label;"
+                accesskey="&reloadImageCmd.accesskey;"
+                oncommand="gContextMenu.reloadImage();"/>
       <menuitem id="context-viewimage"
                 label="&viewImageCmd.label;"
                 accesskey="&viewImageCmd.accesskey;"
+                oncommand="gContextMenu.viewMedia(event);"
+                onclick="checkForMiddleClick(this, event);"/>
+      <menuitem id="context-viewvideo"
+                label="&viewVideoCmd.label;"
+                accesskey="&viewVideoCmd.accesskey;"
                 oncommand="gContextMenu.viewMedia(event);"
                 onclick="checkForMiddleClick(this, event);"/>
 #ifdef CONTEXT_COPY_IMAGE_CONTENTS
diff -r 17e9560465b0 browser/base/content/browser-places.js
--- a/browser/base/content/browser-places.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/base/content/browser-places.js	Thu Oct 30 05:41:44 2008 -0400
@@ -462,14 +462,12 @@
   bookmarkLink: function PCH_bookmarkLink(aParent, aURL, aTitle) {
     var linkURI = makeURI(aURL);
     var itemId = PlacesUtils.getMostRecentBookmarkForURI(linkURI);
-    if (itemId == -1) {
-      StarUI.beginBatch();
-      var txn = PlacesUIUtils.ptm.createItem(linkURI, aParent, -1, aTitle);
-      PlacesUIUtils.ptm.doTransaction(txn);
-      itemId = PlacesUtils.getMostRecentBookmarkForURI(linkURI);
+    if (itemId == -1)
+      PlacesUIUtils.showMinimalAddBookmarkUI(linkURI, aTitle);
+    else {
+      PlacesUIUtils.showItemProperties(itemId,
+                                       PlacesUtils.bookmarks.TYPE_BOOKMARK);
     }
-
-    StarUI.showEditBookmarkPopup(itemId, getBrowser(), "overlap");
   },
 
   /**
diff -r 17e9560465b0 browser/base/content/browser.js
--- a/browser/base/content/browser.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/base/content/browser.js	Thu Oct 30 05:41:44 2008 -0400
@@ -43,6 +43,8 @@
 #   Johnathan Nightingale <johnath@mozilla.com>
 #   Ehsan Akhgari <ehsan.akhgari@gmail.com>
 #   Do Gottwald <dao@mozilla.com>
+#   Thomas K. Dyas <tdyas@zecador.org>
+#   Edward Lee <edward.lee@engineering.uiuc.edu>
 #
 # Alternatively, the contents of this file may be used under the terms of
 # either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -130,14 +132,10 @@
 * We can avoid adding multiple load event listeners and save some time by adding
 * one listener that calls all real handlers.
 */
-
-function pageShowEventHandlers(event)
-{
+function pageShowEventHandlers(event) {
   // Filter out events that are not about the document load we are interested in
   if (event.originalTarget == content.document) {
-    checkForDirectoryListing();
     charsetLoadListener(event);
-    
     XULBrowserWindow.asyncUpdateUI();
   }
 }
@@ -667,6 +665,143 @@
   }
 };
 
+// Simple gestures support
+//
+// As per bug #412486, web content must not be allowed to receive any
+// simple gesture events.  Multi-touch gesture APIs are in their
+// infancy and we do NOT want to be forced into supporting an API that
+// will probably have to change in the future.  (The current Mac OS X
+// API is undocumented and was reverse-engineered.)  Until support is
+// implemented in the event dispatcher to keep these events as
+// chrome-only, we must listen for the simple gesture events during
+// the capturing phase and call stopPropagation on every event.
+
+let gGestureSupport = {
+  /**
+   * Add or remove mouse gesture event listeners
+   *
+   * @param aAddListener
+   *        True to add/init listeners and false to remove/uninit
+   */
+  init: function GS_init(aAddListener) {
+    const gestureEvents = ["SwipeGesture",
+      "MagnifyGestureStart", "MagnifyGestureUpdate", "MagnifyGesture",
+      "RotateGesture", "RotateGestureUpdate", "RotateGesture"];
+
+    let addRemove = aAddListener ? window.addEventListener :
+      window.removeEventListener;
+
+    for each (let event in gestureEvents)
+      addRemove("Moz" + event, this, true);
+  },
+
+  /**
+   * Dispatch events based on the type of mouse gesture event.
+   * For now, make sure to stop propagation of every gesture event
+   *
+   * @param aEvent
+   *        The gesture event to handle
+   */
+  handleEvent: function GS_handleEvent(aEvent) {
+    aEvent.stopPropagation();
+
+    switch (aEvent.type) {
+      case "MozSwipeGesture":
+        this.onSwipe(aEvent);
+        break;
+      case "MozMagnifyGestureStart":
+      case "MozRotateGestureStart":
+        this.onStart(aEvent);
+        break;
+      case "MozMagnifyGestureUpdate":
+        this.onMagnify(aEvent);
+        break;
+      case "MozRotateGestureUpdate":
+        this.onRotate(aEvent);
+        break;
+    }
+  },
+
+  /**
+   * Convert the swipe gesture into a browser action based on the direction
+   *
+   * @param aEvent
+   *        The swipe event to handle
+   */
+  onSwipe: function GS_onSwipe(aEvent) {
+    // Create a fake event that pretends the swipe is a button click
+    let fakeEvent = { shiftKey: aEvent.shiftKey, ctrlKey: aEvent.ctrlKey,
+      metaKey: aEvent.metaKey, altKey: aEvent.altKey, button: 0 };
+
+    if (aEvent.direction == SimpleGestureEvent.DIRECTION_LEFT)
+      BrowserBack(fakeEvent);
+    else if (aEvent.direction == SimpleGestureEvent.DIRECTION_RIGHT)
+      BrowserForward(fakeEvent);
+    else if (aEvent.direction == SimpleGestureEvent.DIRECTION_UP)
+      goDoCommand("cmd_scrollTop");
+    else if (aEvent.direction == SimpleGestureEvent.DIRECTION_DOWN)
+      goDoCommand("cmd_scrollBottom");
+  },
+
+  // Keep track of offsets for continual motion events, e.g., zoom and rotate
+  _lastOffset: 0,
+
+  /**
+   * Handle the beginning of a continual motion event
+   *
+   * @param aEvent
+   *        The continual motion event
+   */
+  onStart: function GS_onStart(aEvent) {
+    this._lastOffset = 0;
+  },
+
+  /**
+   * Helper function to determine if a continual motion event has passed some
+   * threshold and should trigger some action. If the action is triggered, the
+   * tracking of the motion is reset as if a new motion has started.
+   *
+   * @param aEvent
+   *        The continual motion event to handle
+   * @param aThreshold
+   *        Minimum positive/negative difference before the action is triggered
+   * @param aIncDec
+   *        Callback function that takes in the current offset
+   */
+  _handleUpdate: function GS__handleUpdate(aEvent, aThreshold, aIncDec) {
+    // Update the offset with new event data
+    this._lastOffset += aEvent.delta;
+
+    // Inform the callback that we passed the threshold and then reset motion
+    if (Math.abs(this._lastOffset) > aThreshold) {
+      aIncDec(this._lastOffset);
+      this.onStart(aEvent);
+    }
+  },
+
+  /**
+   * Convert zoom motions into a page zoom in/out
+   *
+   * @param aEvent
+   *        The zoom event to handle
+   */
+  onMagnify: function GS_onMagnify(aEvent) {
+    this._handleUpdate(aEvent, 100, function(aOffset) aOffset > 0 ?
+      FullZoom.enlarge() : FullZoom.reduce());
+  },
+
+  /**
+   * Convert rotate motions into a next/prev tab
+   *
+   * @param aEvent
+   *        The rotate event to handle
+   */
+  onRotate: function GS_onRotate(aEvent) {
+    this._handleUpdate(aEvent, 22.5, function(aOffset) gBrowser.mTabContainer.
+      advanceSelectedTab(aOffset > 0 ? 1 : -1, true));
+  },
+};
+
 function BrowserStartup() {
   var uriToLoad = null;
 
@@ -908,61 +1043,9 @@
 
   // setup our common DOMLinkAdded listener
   gBrowser.addEventListener("DOMLinkAdded", DOMLinkHandler, false);
-}
-
-function setupGeolocationPrompt()
-{
-  var geolocationService = Cc["@mozilla.org/geolocation/service;1"].getService(Ci.nsIGeolocationService);
-  
-  if (geolocationService.prompt)
-    return;
-
-  geolocationService.prompt = function(request) {
-
-    function getChromeWindow(aWindow) {
-      var chromeWin = aWindow 
-        .QueryInterface(Ci.nsIInterfaceRequestor)
-        .getInterface(Ci.nsIWebNavigation)
-        .QueryInterface(Ci.nsIDocShellTreeItem)
-        .rootTreeItem
-        .QueryInterface(Ci.nsIInterfaceRequestor)
-        .getInterface(Ci.nsIDOMWindow)
-        .QueryInterface(Ci.nsIDOMChromeWindow);
-      return chromeWin;
-    }
-
-    var requestingWindow = request.requestingWindow.top;
-    var tabbrowser = getChromeWindow(requestingWindow).wrappedJSObject.gBrowser;
-    var browser = tabbrowser.getBrowserForDocument(requestingWindow.document);
-    var notificationBox = tabbrowser.getNotificationBox(browser);
-
-    var notification = notificationBox.getNotificationWithValue("geolocation");
-    if (!notification) {
-
-      var buttons = [{
-        label: gNavigatorBundle.getString("geolocation.exactLocation"),
-        accessKey: gNavigatorBundle.getString("geolocation.exactLocationKey"),
-        callback: function() request.allow() ,
-        },
-        {
-        label: gNavigatorBundle.getString("geolocation.neighborhoodLocation"),
-        accessKey: gNavigatorBundle.getString("geolocation.neighborhoodLocationKey"),
-        callback: function() request.allowButFuzz() ,
-        },
-        {
-        label: gNavigatorBundle.getString("geolocation.nothingLocation"),
-        accessKey: gNavigatorBundle.getString("geolocation.nothingLocationKey"),
-        callback: function() request.cancel() ,
-        }];
-      
-      var message = gNavigatorBundle.getFormattedString("geolocation.requestMessage", [request.requestingURI.spec]);      
-      notificationBox.appendNotification(message,
-                                         "geolocation",
-                                         "chrome://browser/skin/Info.png",
-                                         notificationBox.PRIORITY_INFO_HIGH,
-                                         buttons);
-    }
-  };
+
+  // setup simple gestures support
+  gGestureSupport.init(true);
 }
 
 function delayedStartup(isLoadingBlank, mustLoadSidebar) {
@@ -1070,14 +1153,6 @@
     SetClickAndHoldHandlers();
 #endif
 
-  // Initialize the microsummary service by retrieving it, prompting its factory
-  // to create its singleton, whose constructor initializes the service.
-  try {
-    Cc["@mozilla.org/microsummary/service;1"].getService(Ci.nsIMicrosummaryService);
-  } catch (ex) {
-    Components.utils.reportError("Failed to init microsummary service:\n" + ex);
-  }
-
   // Initialize the full zoom setting.
   // We do this before the session restore service gets initialized so we can
   // apply full zoom settings to tabs restored by the session restore service.
@@ -1133,11 +1208,22 @@
        gPrefService.getBoolPref("browser.ctrlTab.mostRecentlyUsed"))
     ctrlTab.init();
 
+  // Initialize the microsummary service by retrieving it, prompting its factory
+  // to create its singleton, whose constructor initializes the service.
+  // Started 4 seconds after delayedStartup (before the livemarks service below).
+  setTimeout(function() {
+    try {
+      Cc["@mozilla.org/microsummary/service;1"].getService(Ci.nsIMicrosummaryService);
+    } catch (ex) {
+      Components.utils.reportError("Failed to init microsummary service:\n" + ex);
+    }
+  }, 4000);
+
   // Delayed initialization of the livemarks update timer.
   // Livemark updates don't need to start until after bookmark UI 
   // such as the toolbar has initialized. Starting 5 seconds after
-  // delayedStartup in order to stagger this before the download
-  // manager starts (see below).
+  // delayedStartup in order to stagger this after the microsummary
+  // service (see above) and before the download manager starts (see below).
   setTimeout(function() PlacesUtils.livemarks.start(), 5000);
 
   // Initialize the download manager some time after the app starts so that
@@ -1160,15 +1246,14 @@
   placesContext.addEventListener("popuphiding", updateEditUIVisibility, false);
 #endif
 
-  // hook up the geolocation prompt to our notificationBox
-  setupGeolocationPrompt();
-
 }
 
 function BrowserShutdown()
 {
   tabPreviews.uninit();
   ctrlTab.uninit();
+
+  gGestureSupport.init(false);
 
   try {
     FullZoom.destroy();
@@ -1858,11 +1943,11 @@
 function BrowserPageInfo(doc, initialTab)
 {
   var args = {doc: doc, initialTab: initialTab};
-  toOpenDialogByTypeAndUrl("Browser:page-info",
-                           doc ? doc.location : window.content.document.location,
-                           "chrome://browser/content/pageinfo/pageInfo.xul",
-                           "chrome,toolbar,dialog=no,resizable",
-                           args);
+  return toOpenDialogByTypeAndUrl("Browser:page-info",
+                                  doc ? doc.location : window.content.document.location,
+                                  "chrome://browser/content/pageinfo/pageInfo.xul",
+                                  "chrome,toolbar,dialog=no,resizable",
+                                  args);
 }
 
 #ifdef DEBUG
@@ -1914,15 +1999,6 @@
   leakDetector.verbose = (verbose == "true");
 }
 #endif
-
-function checkForDirectoryListing()
-{
-  if ( "HTTPIndex" in content &&
-       content.HTTPIndex instanceof Components.interfaces.nsIHTTPIndex ) {
-    content.wrappedJSObject.defaultCharacterset =
-      getMarkupDocumentViewer().defaultCharacterSet;
-  }
-}
 
 function URLBarSetURI(aURI, aValid) {
   var value = gBrowser.userTypedValue;
@@ -2111,7 +2187,7 @@
 
     // If the event came from an ssl error page, it is probably either the "Add
     // Exception" or "Get me out of here!" button
-    if (/^about:neterror\?e=nssBadCert/.test(errorDoc.documentURI)) {
+    if (/^about:certerror/.test(errorDoc.documentURI)) {
       if (ot == errorDoc.getElementById('exceptionDialogButton')) {
         var params = { exceptionAdded : false };
         
@@ -2139,6 +2215,9 @@
     }
     else if (/^about:blocked/.test(errorDoc.documentURI)) {
       // The event came from a button on a malware/phishing block page
+      // First check whether it's malware or phishing, so that we can
+      // use the right strings/links
+      var isMalware = /e=malwareBlocked/.test(errorDoc.documentURI);
       
       if (ot == errorDoc.getElementById('getMeOutButton')) {
         getMeOutOfHere();
@@ -2150,7 +2229,7 @@
         var formatter = Cc["@mozilla.org/toolkit/URLFormatterService;1"]
                        .getService(Components.interfaces.nsIURLFormatter);
         
-        if (/e=malwareBlocked/.test(errorDoc.documentURI)) {
+        if (isMalware) {
           // Get the stop badware "why is this blocked" report url,
           // append the current url, and go there.
           try {
@@ -2161,7 +2240,7 @@
             Components.utils.reportError("Couldn't get malware report URL: " + e);
           }
         }
-        else if (/e=phishingBlocked/.test(errorDoc.documentURI)) {
+        else { // It's a phishing site, not malware
           try {
             content.location = formatter.formatURLPref("browser.safebrowsing.warning.infoURL");
           } catch (e) {
@@ -2176,13 +2255,39 @@
         gBrowser.loadURIWithFlags(content.location.href,
                                   nsIWebNavigation.LOAD_FLAGS_BYPASS_CLASSIFIER,
                                   null, null, null);
+        var buttons = [{
+          label: gNavigatorBundle.getString("safebrowsing.getMeOutOfHereButton.label"),
+          accessKey: gNavigatorBundle.getString("safebrowsing.getMeOutOfHereButton.accessKey"),
+          callback: function() { getMeOutOfHere(); }
+        }];
+        
+        if (isMalware) {
+          var title = gNavigatorBundle.getString("safebrowsing.reportedAttackSite");
+          buttons[1] = {
+            label: gNavigatorBundle.getString("safebrowsing.notAnAttackButton.label"),
+            accessKey: gNavigatorBundle.getString("safebrowsing.notAnAttackButton.accessKey"),
+            callback: function() {
+              openUILinkIn(safebrowsing.getReportURL('MalwareError'), 'tab');
+            }
+          };
+        } else {
+          title = gNavigatorBundle.getString("safebrowsing.reportedWebForgery");
+          buttons[1] = {
+            label: gNavigatorBundle.getString("safebrowsing.notAForgeryButton.label"),
+            accessKey: gNavigatorBundle.getString("safebrowsing.notAForgeryButton.accessKey"),
+            callback: function() {
+              openUILinkIn(safebrowsing.getReportURL('Error'), 'tab');
+            }
+          };
+        }
+        
         var notificationBox = gBrowser.getNotificationBox();
         notificationBox.appendNotification(
-          errorDoc.title, /* Re-use the error page's title, e.g. "Reported Web Forgery!" */
+          title,
           "blocked-badware-page",
           "chrome://global/skin/icons/blacklist_favicon.png",
           notificationBox.PRIORITY_CRITICAL_HIGH,
-          null
+          buttons
         );
       }
     }
@@ -2631,8 +2736,10 @@
             // only allow chrome:// favicons
             const aboutNeterr = /^about:neterror\?/;
             const aboutBlocked = /^about:blocked\?/;
+            const aboutCert = /^about:certerror\?/;
             if (!(aboutNeterr.test(targetDoc.documentURI) ||
-                  aboutBlocked.test(targetDoc.documentURI)) ||
+                  aboutBlocked.test(targetDoc.documentURI) ||
+                  aboutCert.test(targetDoc.documentURI)) ||
                 !uri.schemeIs("chrome")) {
               var ssm = Cc["@mozilla.org/scriptsecuritymanager;1"].
                         getService(Ci.nsIScriptSecurityManager);
@@ -2963,9 +3070,9 @@
 
   // We didn't find a matching window, so open a new one.
   if (features)
-    window.openDialog(windowUri, "_blank", features, extraArgument);
-  else
-    window.openDialog(windowUri, "_blank", "chrome,extrachrome,menubar,resizable,scrollbars,status,toolbar", extraArgument);
+    return window.openDialog(windowUri, "_blank", features, extraArgument);
+
+  return window.openDialog(windowUri, "_blank", "chrome,extrachrome,menubar,resizable,scrollbars,status,toolbar", extraArgument);
 }
 
 function OpenBrowserWindow()
@@ -3512,6 +3619,7 @@
   startTime: 0,
   statusText: "",
   lastURI: null,
+  isBusy: false,
 
   statusTimeoutInEffect: false,
 
@@ -3650,6 +3758,8 @@
           aRequest && aWebProgress.DOMWindow == content)
         this.startDocumentLoad(aRequest);
 
+      this.isBusy = true;
+
       if (this.throbberElement) {
         // Turn the throbber on.
         this.throbberElement.setAttribute("busy", "true");
@@ -3720,6 +3830,8 @@
         else
           this.isImage.setAttribute('disabled', 'true');
       }
+
+      this.isBusy = false;
 
       // Turn the progress meter and throbber off.
       gProgressCollapseTimer = window.setTimeout(function () {
diff -r 17e9560465b0 browser/base/content/browser.xul
--- a/browser/base/content/browser.xul	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/base/content/browser.xul	Thu Oct 30 05:41:44 2008 -0400
@@ -272,11 +272,7 @@
            defaultmode="icons">
     <!-- Menu -->
     <toolbar type="menubar" id="toolbar-menubar" class="chromeclass-menubar" customizable="true"
-#ifdef XP_MACOSX
              defaultset="menubar-items"
-#else
-             defaultset="menubar-items,spring,throbber-box"
-#endif
              mode="icons" iconsize="small" defaulticonsize="small"
              context="toolbar-context-menu">
       <toolbaritem id="menubar-items" align="center">
@@ -417,9 +413,9 @@
                      label="&printButton.label;" command="cmd_print"
                      tooltiptext="&printButton.tooltip;"/>
 
-      <toolbaritem id="throbber-box" title="&throbberItem.title;" align="center" pack="center"
+      <toolbaritem id="navigator-throbber" title="&throbberItem.title;" align="center" pack="center"
                    mousethrough="always">
-        <button id="navigator-throbber" disabled="true"/>
+        <image/>
       </toolbaritem>
 
       <toolbaritem flex="1" id="personal-bookmarks" title="&bookmarksItem.title;">
@@ -483,7 +479,7 @@
              fullscreentoolbar="true" mode="icons" iconsize="large"
              customizable="true"
 #ifdef XP_MACOSX
-             defaultset="unified-back-forward-button,reload-button,stop-button,home-button,urlbar-container,search-container,throbber-box"
+             defaultset="unified-back-forward-button,reload-button,stop-button,home-button,urlbar-container,search-container"
 #else
              defaultset="unified-back-forward-button,reload-button,stop-button,home-button,urlbar-container,search-container,fullscreenflex,window-controls"
 #endif
diff -r 17e9560465b0 browser/base/content/nsContextMenu.js
--- a/browser/base/content/nsContextMenu.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/base/content/nsContextMenu.js	Thu Oct 30 05:41:44 2008 -0400
@@ -84,7 +84,6 @@
   this.hasBGImage        = false;
   this.isTextSelected    = false;
   this.isContentSelected = false;
-  this.inDirList         = false;
   this.shouldDisplay     = true;
   this.isDesignMode      = false;
   this.possibleSpellChecking = false;
@@ -144,8 +143,7 @@
                           mailtoHandler.preferredAction == Ci.nsIHandlerInfo.useHelperApp &&
                           (mailtoHandler.preferredApplicationHandler instanceof Ci.nsIWebHandlerApp));
     }
-    var shouldShow = this.onSaveableLink || isMailtoInternal ||
-                     (this.inDirList && this.onLink);
+    var shouldShow = this.onSaveableLink || isMailtoInternal;
     this.showItem("context-openlink", shouldShow);
     this.showItem("context-openlinkintab", shouldShow);
     this.showItem("context-sep-open", shouldShow);
@@ -166,7 +164,7 @@
   },
 
   initSaveItems: function CM_initSaveItems() {
-    var shouldShow = !(this.inDirList || this.onTextInput || this.onLink ||
+    var shouldShow = !(this.onTextInput || this.onLink ||
                        this.isContentSelected || this.onImage ||
                        this.onCanvas || this.onVideo || this.onAudio);
     this.showItem("context-savepage", shouldShow);
@@ -193,7 +191,7 @@
     this.showItem("context-viewpartialsource-mathml",
                   this.onMathML && !this.isContentSelected);
 
-    var shouldShow = !(this.inDirList || this.isContentSelected ||
+    var shouldShow = !(this.isContentSelected ||
                        this.onImage || this.onCanvas ||
                        this.onVideo || this.onAudio ||
                        this.onLink || this.onTextInput);
@@ -201,7 +199,7 @@
     this.showItem("context-viewinfo", shouldShow);
 
     this.showItem("context-sep-properties",
-                  !(this.inDirList || this.isContentSelected ||
+                  !(this.isContentSelected ||
                     this.onTextInput || this.onCanvas ||
                     this.onVideo || this.onAudio));
 
@@ -222,13 +220,15 @@
               .disabled = this.disableSetDesktopBackground();
     }
 
-    // Show image depends on an image that's not fully loaded
-    this.showItem("context-showimage", (this.onImage && !this.onCompletedImage));
+    // Reload image depends on an image that's not fully loaded
+    this.showItem("context-reloadimage", (this.onImage && !this.onCompletedImage));
 
     // View image depends on having an image that's not standalone
     // (or is in a frame), or a canvas.
     this.showItem("context-viewimage", (this.onImage &&
                   (!this.onStandaloneImage || this.inFrame)) || this.onCanvas);
+
+    this.showItem("context-viewvideo", this.onVideo);
 
     // View background image depends on whether there is one.
     this.showItem("context-viewbgimage", shouldShow);
@@ -465,11 +465,11 @@
       }
       else if (this.target instanceof HTMLVideoElement) {
         this.onVideo = true;
-        this.mediaURL = this.target.src;
+        this.mediaURL = this.target.currentSrc;
       }
       else if (this.target instanceof HTMLAudioElement) {
         this.onAudio = true;
-        this.mediaURL = this.target.src;
+        this.mediaURL = this.target.currentSrc;
       }
       else if (this.target instanceof HTMLInputElement ) {
         this.onTextInput = this.isTargetATextBox(this.target);
@@ -499,40 +499,6 @@
             this.bgImageURL = makeURLAbsolute(bodyElt.baseURI,
                                               computedURL);
           }
-        }
-      }
-      else if ("HTTPIndex" in content &&
-               content.HTTPIndex instanceof Ci.nsIHTTPIndex) {
-        this.inDirList = true;
-        // Bubble outward till we get to an element with URL attribute
-        // (which should be the href).
-        var root = this.target;
-        while (root && !this.link) {
-          if (root.tagName == "tree") {
-            // Hit root of tree; must have clicked in empty space;
-            // thus, no link.
-            break;
-          }
-
-          if (root.getAttribute("URL")) {
-            // Build pseudo link object so link-related functions work.
-            this.onLink = true;
-            this.link = { href : root.getAttribute("URL"),
-                          getAttribute: function (aAttr) {
-                            if (aAttr == "title") {
-                              return root.firstChild.firstChild
-                                         .getAttribute("label");
-                            }
-                            else
-                              return "";
-                           }
-                         };
-
-            // If element is a directory, then you can't save it.
-            this.onSaveableLink = root.getAttribute("container") != "true";
-          }
-          else
-            root = root.parentNode;
         }
       }
     }
@@ -776,7 +742,7 @@
     BrowserPageInfo(this.target.ownerDocument);
   },
 
-  showImage: function(e) {
+  reloadImage: function(e) {
     urlSecurityCheck(this.mediaURL,
                      this.browser.contentPrincipal,
                      Ci.nsIScriptSecurityManager.DISALLOW_SCRIPT);
diff -r 17e9560465b0 browser/base/content/pageinfo/pageInfo.js
--- a/browser/base/content/pageinfo/pageInfo.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/base/content/pageinfo/pageInfo.js	Thu Oct 30 05:41:44 2008 -0400
@@ -313,6 +313,9 @@
   radioGroup.selectedItem = initialTab;
   radioGroup.selectedItem.doCommand();
   radioGroup.focus();
+  Components.classes["@mozilla.org/observer-service;1"]
+            .getService(Components.interfaces.nsIObserverService)
+            .notifyObservers(window, "page-info-dialog-loaded", null);
 }
 
 function loadPageInfo()
diff -r 17e9560465b0 browser/base/content/sanitize.xul
--- a/browser/base/content/sanitize.xul	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/base/content/sanitize.xul	Thu Oct 30 05:41:44 2008 -0400
@@ -192,8 +192,8 @@
               accesskey="&itemPasswords.accesskey;"
               preference="privacy.item.passwords"
               onsyncfrompreference="return gSanitizePromptDialog.onReadGeneric();"/>
-    <checkbox label="&itemSessions.label;"
-              accesskey="&itemSessions.accesskey;"
+    <checkbox label="&itemActiveLogins.label;"
+              accesskey="&itemActiveLogins.accesskey;"
               preference="privacy.item.sessions"
               onsyncfrompreference="return gSanitizePromptDialog.onReadGeneric();"/>
 
diff -r 17e9560465b0 browser/base/content/tabbrowser.xml
--- a/browser/base/content/tabbrowser.xml	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/base/content/tabbrowser.xml	Thu Oct 30 05:41:44 2008 -0400
@@ -1021,8 +1021,7 @@
             // Get the first tab all hooked up with a title listener and popup blocking listener.
             this.mCurrentBrowser.addEventListener("DOMTitleChanged", this.onTitleChanged, true);
 
-            var throbberElement = document.getElementById("navigator-throbber");
-            if (throbberElement && throbberElement.hasAttribute("busy")) {
+            if (XULBrowserWindow.isBusy) {
               this.mCurrentTab.setAttribute("busy", "true");
               this.mIsBusy = true;
               this.setTabTitleLoading(this.mCurrentTab);
diff -r 17e9560465b0 browser/base/content/test/Makefile.in
--- a/browser/base/content/test/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/base/content/test/Makefile.in	Thu Oct 30 05:41:44 2008 -0400
@@ -69,6 +69,14 @@
                  page_style_sample.html \
                  browser_ctrlTab.js \
                  browser_selectTabAtIndex.js \
+                 browser_gestureSupport.js \
+                 browser_feed_tab.js \
+                 feed_tab.html \
+                 browser_pluginnotification.js \
+                 plugin_unknown.html \
+                 plugin_test.html \
+                 plugin_both.html \
+                 plugin_both2.html \
     $(NULL)
 
 ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
diff -r 17e9560465b0 browser/base/content/test/browser_feed_tab.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/base/content/test/browser_feed_tab.js	Thu Oct 30 05:41:44 2008 -0400
@@ -0,0 +1,54 @@
+function test() {
+  waitForExplicitFinish();
+
+  var pageInfo, obs;
+  var gTestPage = gBrowser.addTab();
+  gBrowser.selectedTab = gTestPage;
+  gTestPage.linkedBrowser.addEventListener("load", handleLoad, true);
+  content.location =
+    "http://localhost:8888/browser/browser/base/content/test/feed_tab.html";
+  gTestPage.focus();
+
+  var observer = {
+    observe: function(win, topic, data) {
+      if (topic != "page-info-dialog-loaded")
+        return;
+
+      obs.removeObserver(observer, "page-info-dialog-loaded");
+      handlePageInfo();
+    }
+  };
+
+  function handleLoad() {
+
+    pageInfo = BrowserPageInfo();
+    obs = Components.classes["@mozilla.org/observer-service;1"]
+            .getService(Components.interfaces.nsIObserverService);
+    obs.addObserver(observer, "page-info-dialog-loaded", false);
+  }
+
+  function handlePageInfo() {
+    function $(aId) { return pageInfo.document.getElementById(aId) };
+    var feedTab = $("feedTab");
+    var feedListbox = $("feedListbox");
+
+    ok(feedListbox, "Feed list is null (feeds tab is broken)");
+
+    var feedRowsNum = feedListbox.getRowCount();
+
+    ok(feedRowsNum == 3, "Number of feeds listed: " +
+                         feedRowsNum + ", should be 3");
+
+
+    for (var i = 0; i < feedRowsNum; i++) {
+      let feedItem = feedListbox.getItemAtIndex(i);
+      ok(feedItem.getAttribute("name") == (i+1), 
+         "Name given: " + feedItem.getAttribute("name") + ", should be " + (i+1));
+    }
+
+    pageInfo.close();
+    gTestPage.focus();
+    gBrowser.removeCurrentTab();
+    finish();
+  }
+}
diff -r 17e9560465b0 browser/base/content/test/browser_gestureSupport.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/base/content/test/browser_gestureSupport.js	Thu Oct 30 05:41:44 2008 -0400
@@ -0,0 +1,225 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Firefox Gesture Support Test Code
+ *
+ * The Initial Developer of the Original Code is
+ * Thomas K. Dyas <tdyas@zecador.org>
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Edward Lee <edward.lee@engineering.uiuc.edu>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+// Simple gestures tests
+//
+// These tests require the ability to disable the fact that the
+// Firefox chrome intentionally prevents "simple gesture" events from
+// reaching web content.
+
+let test_utils;
+
+function test()
+{
+  // Disable the default gestures support during the test
+  gGestureSupport.init(false);
+
+  // Enable privileges so we can use nsIDOMWindowUtils interface
+  netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
+  test_utils = window.QueryInterface(Components.interfaces.nsIInterfaceRequestor).
+    getInterface(Components.interfaces.nsIDOMWindowUtils);
+
+  // Run the tests of "simple gesture" events generally
+  test_EnsureConstantsAreDisjoint();
+  test_TestEventListeners();
+  test_TestEventCreation();
+
+  // Reenable the default gestures support
+  gGestureSupport.init(true);
+}
+
+let test_eventCount = 0;
+let test_expectedType;
+let test_expectedDirection;
+let test_expectedDelta;
+let test_expectedModifiers;
+
+function test_gestureListener(evt)
+{
+  is(evt.type, test_expectedType,
+     "evt.type (" + evt.type + ") does not match expected value");
+  is(evt.direction, test_expectedDirection,
+     "evt.direction (" + evt.direction + ") does not match expected value");
+  is(evt.delta, test_expectedDelta,
+     "evt.delta (" + evt.delta + ") does not match expected value");
+
+  is(evt.shiftKey, (test_expectedModifiers & Components.interfaces.nsIDOMNSEvent.SHIFT_MASK) != 0,
+     "evt.shiftKey did not match expected value");
+  is(evt.ctrlKey, (test_expectedModifiers & Components.interfaces.nsIDOMNSEvent.CONTROL_MASK) != 0,
+     "evt.ctrlKey did not match expected value");
+  is(evt.altKey, (test_expectedModifiers & Components.interfaces.nsIDOMNSEvent.ALT_MASK) != 0,
+     "evt.altKey did not match expected value");
+  is(evt.metaKey, (test_expectedModifiers & Components.interfaces.nsIDOMNSEvent.META_MASK) != 0,
+     "evt.metaKey did not match expected value");
+
+  test_eventCount++;
+}
+
+function test_helper1(type, direction, delta, modifiers)
+{
+  // Setup the expected values
+  test_expectedType = type;
+  test_expectedDirection = direction;
+  test_expectedDelta = delta;
+  test_expectedModifiers = modifiers;
+
+  let expectedEventCount = test_eventCount + 1;
+
+  document.addEventListener(type, test_gestureListener, true);
+  test_utils.sendSimpleGestureEvent(type, direction, delta, modifiers);
+  document.removeEventListener(type, test_gestureListener, true);
+
+  is(expectedEventCount, test_eventCount, "Event (" + type + ") was never received by event listener");
+}
+
+function test_TestEventListeners()
+{
+  let e = test_helper1;  // easier to type this name
+
+  // Swipe gesture event
+  e("MozSwipeGesture", SimpleGestureEvent.DIRECTION_LEFT, 0.0, 0);
+  e("MozSwipeGesture", SimpleGestureEvent.DIRECTION_RIGHT, 0.0, 0);
+  e("MozSwipeGesture", SimpleGestureEvent.DIRECTION_UP, 0.0, 0);
+  e("MozSwipeGesture", SimpleGestureEvent.DIRECTION_DOWN, 0.0, 0);
+  e("MozSwipeGesture",
+    SimpleGestureEvent.DIRECTION_UP | SimpleGestureEvent.DIRECTION_LEFT, 0.0, 0);
+  e("MozSwipeGesture",
+    SimpleGestureEvent.DIRECTION_DOWN | SimpleGestureEvent.DIRECTION_RIGHT, 0.0, 0);
+  e("MozSwipeGesture",
+    SimpleGestureEvent.DIRECTION_UP | SimpleGestureEvent.DIRECTION_RIGHT, 0.0, 0);
+  e("MozSwipeGesture",
+    SimpleGestureEvent.DIRECTION_DOWN | SimpleGestureEvent.DIRECTION_LEFT, 0.0, 0);
+
+  // magnify gesture events
+  e("MozMagnifyGestureStart", 0, 50.0, 0);
+  e("MozMagnifyGestureUpdate", 0, -25.0, 0);
+  e("MozMagnifyGestureUpdate", 0, 5.0, 0);
+  e("MozMagnifyGesture", 0, 30.0, 0);
+
+  // rotate gesture events
+  e("MozRotateGestureStart", SimpleGestureEvent.DIRECTION_RIGHT, 33.0, 0);
+  e("MozRotateGestureUpdate", SimpleGestureEvent.DIRECTION_LEFT, -13.0, 0);
+  e("MozRotateGestureUpdate", SimpleGestureEvent.DIRECTION_RIGHT, 13.0, 0);
+  e("MozRotateGesture", SimpleGestureEvent.DIRECTION_RIGHT, 33.0, 0);
+
+  // event.shiftKey
+  let modifier = Components.interfaces.nsIDOMNSEvent.SHIFT_MASK;
+  e("MozSwipeGesture", SimpleGestureEvent.DIRECTION_RIGHT, 0, modifier);
+
+  // event.metaKey
+  modifier = Components.interfaces.nsIDOMNSEvent.META_MASK;
+  e("MozSwipeGesture", SimpleGestureEvent.DIRECTION_RIGHT, 0, modifier);
+
+  // event.altKey
+  modifier = Components.interfaces.nsIDOMNSEvent.ALT_MASK;
+  e("MozSwipeGesture", SimpleGestureEvent.DIRECTION_RIGHT, 0, modifier);
+
+  // event.ctrlKey
+  modifier = Components.interfaces.nsIDOMNSEvent.CONTROL_MASK;
+  e("MozSwipeGesture", SimpleGestureEvent.DIRECTION_RIGHT, 0, modifier);
+}
+
+function test_eventDispatchListener(evt)
+{
+  test_eventCount++;
+  evt.stopPropagation();
+}
+
+function test_helper2(type, direction, delta, altKey, ctrlKey, shiftKey, metaKey)
+{
+  let event = null;
+  let successful;
+
+  try {
+    event = document.createEvent("SimpleGestureEvent");
+    successful = true;
+  }
+  catch (ex) {
+    successful = false;
+  }
+  ok(successful, "Unable to create SimpleGestureEvent");
+
+  try {
+    event.initSimpleGestureEvent(type, true, true, null, 0, direction,
+                                 delta, altKey, ctrlKey, shiftKey, metaKey);
+    successful = true;
+  }
+  catch (ex) {
+    successful = false;
+  }
+  ok(successful, "event.initSimpleGestureEvent should not fail");
+
+  // Make sure the event fields match the expected values
+  is(event.type, type, "Mismatch on evt.type");
+  is(event.direction, direction, "Mismatch on evt.direction");
+  is(event.delta, delta, "Mismatch on evt.delta");
+  is(event.altKey, altKey, "Mismatch on evt.altKey");
+  is(event.ctrlKey, ctrlKey, "Mismatch on evt.ctrlKey");
+  is(event.shiftKey, shiftKey, "Mismatch on evt.shiftKey");
+  is(event.metaKey, metaKey, "Mismatch on evt.metaKey");
+
+  // Test event dispatch
+  let expectedEventCount = test_eventCount + 1;
+  document.addEventListener(type, test_eventDispatchListener, true);
+  document.dispatchEvent(event);
+  document.removeEventListener(type, test_eventDispatchListener, true);
+  is(expectedEventCount, test_eventCount, "Dispatched event was never received by listener");
+}
+
+function test_TestEventCreation()
+{
+  // Event creation
+  test_helper2("MozMagnifyGesture", SimpleGestureEvent.DIRECTION_RIGHT, 20.0,
+               true, false, true, false);
+  test_helper2("MozMagnifyGesture", SimpleGestureEvent.DIRECTION_LEFT, -20.0,
+               false, true, false, true);
+}
+
+function test_EnsureConstantsAreDisjoint()
+{
+  let up = SimpleGestureEvent.DIRECTION_UP;
+  let down = SimpleGestureEvent.DIRECTION_DOWN;
+  let left = SimpleGestureEvent.DIRECTION_LEFT;
+  let right = SimpleGestureEvent.DIRECTION_RIGHT;
+
+  ok(up ^ down, "DIRECTION_UP and DIRECTION_DOWN are not bitwise disjoint");
+  ok(up ^ left, "DIRECTION_UP and DIRECTION_LEFT are not bitwise disjoint");
+  ok(up ^ right, "DIRECTION_UP and DIRECTION_RIGHT are not bitwise disjoint");
+  ok(down ^ left, "DIRECTION_DOWN and DIRECTION_LEFT are not bitwise disjoint");
+  ok(down ^ right, "DIRECTION_DOWN and DIRECTION_RIGHT are not bitwise disjoint");
+  ok(left ^ right, "DIRECTION_LEFT and DIRECTION_RIGHT are not bitwise disjoint");
+}
diff -r 17e9560465b0 browser/base/content/test/browser_pluginnotification.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/base/content/test/browser_pluginnotification.js	Thu Oct 30 05:41:44 2008 -0400
@@ -0,0 +1,196 @@
+const gTestRoot = "chrome://mochikit/content/browser/browser/base/content/test/";
+
+var gTestBrowser = null;
+var gNextTest = null;
+
+function get_test_plugin() {
+  var ph = Components.classes["@mozilla.org/plugin/host;1"]
+                     .getService(Components.interfaces.nsIPluginHost);
+  var tags = ph.getPluginTags({});
+  
+  // Find the test plugin
+  for (var i = 0; i < tags.length; i++) {
+    if (tags[i].name == "Test Plug-in")
+      return tags[i];
+  }
+}
+
+// This listens for the next opened window and checks it is of the right url.
+// opencallback is called when the new window is fully loaded
+// closecallback is called when the window is closed
+function WindowOpenListener(url, opencallback, closecallback) {
+  this.url = url;
+  this.opencallback = opencallback;
+  this.closecallback = closecallback;
+
+  var wm = Components.classes["@mozilla.org/appshell/window-mediator;1"]
+                     .getService(Components.interfaces.nsIWindowMediator);
+  wm.addListener(this);
+}
+
+WindowOpenListener.prototype = {
+  url: null,
+  opencallback: null,
+  closecallback: null,
+  window: null,
+  domwindow: null,
+
+  handleEvent: function(event) {
+    is(this.domwindow.document.location.href, this.url, "Should have opened the correct window");
+
+    this.domwindow.removeEventListener("load", this, false);
+    // Allow any other load handlers to execute
+    var self = this;
+    executeSoon(function() { self.opencallback(self.domwindow); } );
+  },
+
+  onWindowTitleChange: function(window, title) {
+  },
+
+  onOpenWindow: function(window) {
+    if (this.window)
+      return;
+
+    this.window = window;
+    this.domwindow = window.QueryInterface(Components.interfaces.nsIInterfaceRequestor)
+                           .getInterface(Components.interfaces.nsIDOMWindowInternal);
+    this.domwindow.addEventListener("load", this, false);
+  },
+
+  onCloseWindow: function(window) {
+    if (this.window != window)
+      return;
+
+    var wm = Components.classes["@mozilla.org/appshell/window-mediator;1"]
+                       .getService(Components.interfaces.nsIWindowMediator);
+    wm.removeListener(this);
+    this.opencallback = null;
+    this.window = null;
+    this.domwindow = null;
+
+    // Let the window close complete
+    executeSoon(this.closecallback);
+    this.closecallback = null;
+  }
+};
+
+function test() {
+  waitForExplicitFinish();
+
+  var newTab = gBrowser.addTab();
+  gBrowser.selectedTab = newTab;
+  gTestBrowser = gBrowser.selectedBrowser;
+  gTestBrowser.addEventListener("load", pageLoad, true);
+  prepareTest(test1, gTestRoot + "plugin_unknown.html");
+}
+
+function finishTest() {
+  gTestBrowser.removeEventListener("load", pageLoad, true);
+  gBrowser.removeCurrentTab();
+  window.focus();
+  finish();
+}
+
+function pageLoad() {
+  // The plugin events are async dispatched and can come after the load event
+  // This just allows the events to fire before we then go on to test the states
+  executeSoon(gNextTest);
+}
+
+function prepareTest(nextTest, url) {
+  gNextTest = nextTest;
+  gTestBrowser.contentWindow.location = url;
+}
+
+// Tests a page with an unknown plugin in it.
+function test1() {
+  var notificationBox = gBrowser.getNotificationBox(gTestBrowser);
+  ok(notificationBox.getNotificationWithValue("missing-plugins"), "Test 1, Should have displayed the missing plugin notification");
+  ok(!notificationBox.getNotificationWithValue("blocked-plugins"), "Test 1, Should not have displayed the blocked plugin notification");
+  ok(gTestBrowser.missingPlugins, "Test 1, Should be a missing plugin list");
+  ok("application/x-unknown" in gTestBrowser.missingPlugins, "Test 1, Should know about application/x-unknown");
+  ok(!("application/x-test" in gTestBrowser.missingPlugins), "Test 1, Should not know about application/x-test");
+
+  var plugin = get_test_plugin();
+  ok(plugin, "Should have a test plugin");
+  plugin.disabled = false;
+  plugin.blocklisted = false;
+  prepareTest(test2, gTestRoot + "plugin_test.html");
+}
+
+// Tests a page with a working plugin in it.
+function test2() {
+  var notificationBox = gBrowser.getNotificationBox(gTestBrowser);
+  ok(!notificationBox.getNotificationWithValue("missing-plugins"), "Test 2, Should not have displayed the missing plugin notification");
+  ok(!notificationBox.getNotificationWithValue("blocked-plugins"), "Test 2, Should not have displayed the blocked plugin notification");
+  ok(!gTestBrowser.missingPlugins, "Test 2, Should not be a missing plugin list");
+
+  var plugin = get_test_plugin();
+  ok(plugin, "Should have a test plugin");
+  plugin.disabled = true;
+  prepareTest(test3, gTestRoot + "plugin_test.html");
+}
+
+// Tests a page with a disabled plugin in it.
+function test3() {
+  var notificationBox = gBrowser.getNotificationBox(gTestBrowser);
+  ok(!notificationBox.getNotificationWithValue("missing-plugins"), "Test 3, Should not have displayed the missing plugin notification");
+  ok(!notificationBox.getNotificationWithValue("blocked-plugins"), "Test 3, Should not have displayed the blocked plugin notification");
+  ok(!gTestBrowser.missingPlugins, "Test 3, Should not be a missing plugin list");
+
+  new WindowOpenListener("chrome://mozapps/content/extensions/extensions.xul", test4, prepareTest5);
+
+  EventUtils.synthesizeMouse(gTestBrowser.contentDocument.getElementById("test"),
+                             0, 0, {}, gTestBrowser.contentWindow);
+}
+
+function test4(win) {
+  is(win.gView, "plugins", "Should have displayed the plugins pane");
+  win.close();
+}
+
+function prepareTest5() {
+  var plugin = get_test_plugin();
+  plugin.disabled = false;
+  plugin.blocklisted = true;
+  prepareTest(test5, gTestRoot + "plugin_test.html");
+}
+
+// Tests a page with a blocked plugin in it.
+function test5() {
+  var notificationBox = gBrowser.getNotificationBox(gTestBrowser);
+  ok(!notificationBox.getNotificationWithValue("missing-plugins"), "Test 5, Should not have displayed the missing plugin notification");
+  ok(notificationBox.getNotificationWithValue("blocked-plugins"), "Test 5, Should have displayed the blocked plugin notification");
+  ok(gTestBrowser.missingPlugins, "Test 5, Should be a missing plugin list");
+  ok("application/x-test" in gTestBrowser.missingPlugins, "Test 5, Should know about application/x-test");
+  ok(!("application/x-unknown" in gTestBrowser.missingPlugins), "Test 5, Should not know about application/x-unknown");
+
+  prepareTest(test6, gTestRoot + "plugin_both.html");
+}
+
+// Tests a page with a blocked and unknown plugin in it.
+function test6() {
+  var notificationBox = gBrowser.getNotificationBox(gTestBrowser);
+  ok(notificationBox.getNotificationWithValue("missing-plugins"), "Test 6, Should have displayed the missing plugin notification");
+  ok(!notificationBox.getNotificationWithValue("blocked-plugins"), "Test 6, Should not have displayed the blocked plugin notification");
+  ok(gTestBrowser.missingPlugins, "Test 6, Should be a missing plugin list");
+  ok("application/x-unknown" in gTestBrowser.missingPlugins, "Test 6, Should know about application/x-unknown");
+  ok("application/x-test" in gTestBrowser.missingPlugins, "Test 6, Should know about application/x-test");
+
+  prepareTest(test7, gTestRoot + "plugin_both2.html");
+}
+
+// Tests a page with a blocked and unknown plugin in it (alternate order to above).
+function test7() {
+  var notificationBox = gBrowser.getNotificationBox(gTestBrowser);
+  ok(notificationBox.getNotificationWithValue("missing-plugins"), "Test 7, Should have displayed the missing plugin notification");
+  ok(!notificationBox.getNotificationWithValue("blocked-plugins"), "Test 7, Should not have displayed the blocked plugin notification");
+  ok(gTestBrowser.missingPlugins, "Test 7, Should be a missing plugin list");
+  ok("application/x-unknown" in gTestBrowser.missingPlugins, "Test 7, Should know about application/x-unknown");
+  ok("application/x-test" in gTestBrowser.missingPlugins, "Test 7, Should know about application/x-test");
+
+  var plugin = get_test_plugin();
+  plugin.disabled = false;
+  plugin.blocklisted = false;
+  finishTest();
+}
diff -r 17e9560465b0 browser/base/content/test/feed_tab.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/base/content/test/feed_tab.html	Thu Oct 30 05:41:44 2008 -0400
@@ -0,0 +1,17 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=458579
+-->
+  <head>
+    <title>Test for page info feeds tab</title>
+
+    <!-- Straight up standard -->
+    <link rel="alternate" type="application/atom+xml" title="1" href="/1.atom" />
+    <link rel="alternate" type="application/rss+xml" title="2" href="/2.rss" />
+    <link rel="feed" title="3" href="/3.xml" />
+
+  </head>
+  <body>
+  </body>
+</html>
diff -r 17e9560465b0 browser/base/content/test/plugin_both.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/base/content/test/plugin_both.html	Thu Oct 30 05:41:44 2008 -0400
@@ -0,0 +1,6 @@
+<html>
+<body>
+<embed id="unknown" style="width: 100px; height: 100px" type="application/x-unknown">
+<embed id="test" style="width: 100px; height: 100px" type="application/x-test">
+</body>
+</html>
diff -r 17e9560465b0 browser/base/content/test/plugin_both2.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/base/content/test/plugin_both2.html	Thu Oct 30 05:41:44 2008 -0400
@@ -0,0 +1,6 @@
+<html>
+<body>
+<embed id="test" style="width: 100px; height: 100px" type="application/x-test">
+<embed id="unknown" style="width: 100px; height: 100px" type="application/x-unknown">
+</body>
+</html>
diff -r 17e9560465b0 browser/base/content/test/plugin_test.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/base/content/test/plugin_test.html	Thu Oct 30 05:41:44 2008 -0400
@@ -0,0 +1,5 @@
+<html>
+<body>
+<embed id="test" style="width: 100px; height: 100px" type="application/x-test">
+</body>
+</html>
diff -r 17e9560465b0 browser/base/content/test/plugin_unknown.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/base/content/test/plugin_unknown.html	Thu Oct 30 05:41:44 2008 -0400
@@ -0,0 +1,5 @@
+<html>
+<body>
+<embed id="unknown" style="width: 100px; height: 100px" type="application/x-unknown">
+</body>
+</html>
diff -r 17e9560465b0 browser/base/content/test/test_contextmenu.html
--- a/browser/base/content/test/test_contextmenu.html	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/base/content/test/test_contextmenu.html	Thu Oct 30 05:41:44 2008 -0400
@@ -240,6 +240,7 @@
                           "context-media-mute",
                           "context-media-showcontrols",
                           "---",
+                          "context-viewvideo",
                           "context-copyvideourl",
                           "---",
                           "context-savevideo",
@@ -337,12 +338,10 @@
 // The frame causes an extra menu item, and prevents running the test
 // standalone (ie, clicking the test name in the Mochitest window) to see
 // success/failure messages.
-// XXX Disable test to diagnose cause of other test failures.
-todo(false, "Test disabled");
-//var subwindow = window.open("./subtst_contextmenu.html", "contextmenu-subtext", "width=600,height=700");
-//subwindow.onload = startTest;
+var subwindow = window.open("./subtst_contextmenu.html", "contextmenu-subtext", "width=600,height=700");
+subwindow.onload = startTest;
 
-//SimpleTest.waitForExplicitFinish();
+SimpleTest.waitForExplicitFinish();
 </script>
 </pre>
 </body>
diff -r 17e9560465b0 browser/base/content/urlbarBindings.xml
--- a/browser/base/content/urlbarBindings.xml	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/base/content/urlbarBindings.xml	Thu Oct 30 05:41:44 2008 -0400
@@ -72,14 +72,13 @@
 
       <method name="handleRevert">
         <body><![CDATA[
-          var throbberElement = document.getElementById("navigator-throbber");
           var isScrolling = this.popupOpen;
 
           gBrowser.userTypedValue = null;
 
           // don't revert to last valid url unless page is NOT loading
           // and user is NOT key-scrolling through autocomplete list
-          if ((!throbberElement || !throbberElement.hasAttribute("busy")) && !isScrolling) {
+          if (!XULBrowserWindow.isBusy && !isScrolling) {
             URLBarSetURI();
 
             // If the value isn't empty and the urlbar has focus, select the value.
diff -r 17e9560465b0 browser/components/Makefile.in
--- a/browser/components/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/components/Makefile.in	Thu Oct 30 05:41:44 2008 -0400
@@ -59,6 +59,7 @@
 EXTRA_JS_MODULES = distribution.js
 
 DIRS = \
+	certerror \
 	dirprovider \
 	microsummaries \
 	migration \
diff -r 17e9560465b0 browser/components/certerror/Makefile.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/components/certerror/Makefile.in	Thu Oct 30 05:41:44 2008 -0400
@@ -0,0 +1,55 @@
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+# Netscape Communications Corporation.
+# Portions created by the Initial Developer are Copyright (C) 1998
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+
+DEPTH     = ../../..
+topsrcdir = @top_srcdir@
+srcdir    = @srcdir@
+VPATH     = @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+ifdef ENABLE_TESTS
+DIRS += test
+endif
+
+# EXTRA_COMPONENTS installs components written in JS to dist/bin/components
+EXTRA_PP_COMPONENTS = \
+         aboutCertError.js \
+         $(NULL)
+
+include $(topsrcdir)/config/rules.mk
diff -r 17e9560465b0 browser/components/certerror/aboutCertError.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/components/certerror/aboutCertError.js	Thu Oct 30 05:41:44 2008 -0400
@@ -0,0 +1,75 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is about:robots
+ *
+ * The Initial Developer of the Original Code is Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ryan Flint <rflint@mozilla.com>
+ *   Justin Dolske <dolske@mozilla.com>
+ *   Johnathan Nightingale <johnath@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+const Cc = Components.classes;
+const Ci = Components.interfaces;
+
+Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");
+
+function AboutCertError() {}
+AboutCertError.prototype = {
+  classDescription: "About Cert Error",
+  contractID: "@mozilla.org/network/protocol/about;1?what=certerror",
+  classID: Components.ID("{78d2286f-de9d-47ac-9c26-e8675aedf3be}"),
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIAboutModule]),
+ 
+  getURIFlags: function(aURI) {
+    return (Ci.nsIAboutModule.ALLOW_SCRIPT |
+            Ci.nsIAboutModule.URI_SAFE_FOR_UNTRUSTED_CONTENT);
+  },
+
+  newChannel: function(aURI) {
+    var ios = Cc["@mozilla.org/network/io-service;1"].
+              getService(Ci.nsIIOService);
+
+    var secMan = Cc["@mozilla.org/scriptsecuritymanager;1"].
+                 getService(Ci.nsIScriptSecurityManager);
+
+    var channel = ios.newChannel("chrome://browser/content/certerror/aboutCertError.xhtml",
+                                 null, null);
+    var principal = secMan.getCodebasePrincipal(aURI);
+
+    channel.originalURI = aURI;
+    channel.owner = principal;
+
+    return channel;
+  }
+};
+
+function NSGetModule(compMgr, fileSpec) {
+  return XPCOMUtils.generateModule([AboutCertError]);
+}
diff -r 17e9560465b0 browser/components/certerror/content/aboutCertError.css
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/components/certerror/content/aboutCertError.css	Thu Oct 30 05:41:44 2008 -0400
@@ -0,0 +1,59 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   William Price <bugzilla@mob.rice.edu>
+ *   Steven Garrity <steven@silverorange.com>
+ *   Henrik Skupin  <mozilla@hskupin.info>
+ *   Johnathan Nightingale <johnath@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/* Logical CSS rules belong here, but presentation & theming rules
+   should live in the CSS of the appropriate theme */
+
+#technicalContentText {
+  overflow: auto;
+  white-space: pre-wrap;
+}
+
+#technicalContent > h2, #expertContent > h2 {
+  cursor: pointer;
+  padding-left: 20px;
+  position: relative;
+  left: -20px;
+}
+
+div[collapsed] > p,
+div[collapsed] > div {
+  display: none;
+}
diff -r 17e9560465b0 browser/components/certerror/content/aboutCertError.xhtml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/components/certerror/content/aboutCertError.xhtml	Thu Oct 30 05:41:44 2008 -0400
@@ -0,0 +1,278 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<!DOCTYPE html [
+  <!ENTITY % htmlDTD
+    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
+    "DTD/xhtml1-strict.dtd">
+  %htmlDTD;
+  <!ENTITY % globalDTD
+    SYSTEM "chrome://global/locale/global.dtd">
+  %globalDTD;
+  <!ENTITY % certerrorDTD
+    SYSTEM "chrome://browser/locale/aboutCertError.dtd">
+  %certerrorDTD;
+]>
+
+<!-- ***** BEGIN LICENSE BLOCK *****
+   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
+   -
+   - The contents of this file are subject to the Mozilla Public License Version
+   - 1.1 (the "License"); you may not use this file except in compliance with
+   - the License. You may obtain a copy of the License at
+   - http://www.mozilla.org/MPL/
+   -
+   - Software distributed under the License is distributed on an "AS IS" basis,
+   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+   - for the specific language governing rights and limitations under the
+   - License.
+   -
+   - The Original Code is netError.xhtml.
+   -
+   - The Initial Developer of the Original Code is
+   - Netscape Communications Corporation.
+   - Portions created by the Initial Developer are Copyright (C) 1998
+   - the Initial Developer. All Rights Reserved.
+   -
+   - Contributor(s):
+   -   Adam Lock <adamlock@netscape.com>
+   -   William R. Price <wrprice@alumni.rice.edu>
+   -   Henrik Skupin <mozilla@hskupin.info>
+   -   Jeff Walden <jwalden+code@mit.edu>
+   -   Johnathan Nightingale <johnath@mozilla.com>
+   -   Ehsan Akhgari <ehsan.akhgari@gmail.com>
+   -
+   - Alternatively, the contents of this file may be used under the terms of
+   - either the GNU General Public License Version 2 or later (the "GPL"), or
+   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+   - in which case the provisions of the GPL or the LGPL are applicable instead
+   - of those above. If you wish to allow use of your version of this file only
+   - under the terms of either the GPL or the LGPL, and not to allow others to
+   - use your version of this file under the terms of the MPL, indicate your
+   - decision by deleting the provisions above and replace them with the notice
+   - and other provisions required by the LGPL or the GPL. If you do not delete
+   - the provisions above, a recipient may use your version of this file under
+   - the terms of any one of the MPL, the GPL or the LGPL.
+   -
+   - ***** END LICENSE BLOCK ***** -->
+<html xmlns="http://www.w3.org/1999/xhtml">
+  <head>
+    <title>&certerror.pagetitle;</title>
+    <link rel="stylesheet" href="chrome://browser/skin/aboutCertError.css" type="text/css" media="all" />
+    <link rel="stylesheet" href="chrome://browser/content/certerror/aboutCertError.css" type="text/css" media="all" />
+    <!-- This page currently uses the same favicon as neterror.xhtml.
+         If the location of the favicon is changed for both pages, the
+         FAVICON_ERRORPAGE_URL symbol in toolkit/components/places/src/nsFaviconService.h
+         should be updated. If this page starts using a different favicon
+         than neterrorm nsFaviconService->DoSetAndLoadFaviconForPage
+         should be updated to ignore this one as well. -->
+    <link rel="icon" type="image/png" id="favicon" href="chrome://global/skin/icons/warning-16.png"/>
+
+    <script type="application/x-javascript"><![CDATA[
+      // Error url MUST be formatted like this:
+      //   about:certerror?e=error&u=url&d=desc
+
+      // Note that this file uses document.documentURI to get
+      // the URL (with the format from above). This is because
+      // document.location.href gets the current URI off the docshell,
+      // which is the URL displayed in the location bar, i.e.
+      // the URI that the user attempted to load.
+
+      function getCSSClass()
+      {
+        var url = document.documentURI;
+        var matches = url.match(/s\=([^&]+)\&/);
+        // s is optional, if no match just return nothing
+        if (!matches || matches.length < 2)
+          return "";
+
+        // parenthetical match is the second entry
+        return decodeURIComponent(matches[1]);
+      }
+
+      function getDescription()
+      {
+        var url = document.documentURI;
+        var desc = url.search(/d\=/);
+
+        // desc == -1 if not found; if so, return an empty string
+        // instead of what would turn out to be portions of the URI
+        if (desc == -1)
+          return "";
+
+        return decodeURIComponent(url.slice(desc + 2));
+      }
+
+      function initPage()
+      {
+        // Replace the "#1" string in the intro with the hostname.  Trickier
+        // than it might seem since we want to preserve the <b> tags, but
+        // not allow for any injection by just using innerHTML.  Instead,
+        // just find the right target text node.
+        var intro = document.getElementById('introContentP1');
+        function replaceWithHost(node) {
+          if (node.textContent == "#1")
+            node.textContent = location.host;
+          else
+            for(var i = 0; i < node.childNodes.length; i++)
+              replaceWithHost(node.childNodes[i]);
+        };
+        replaceWithHost(intro);
+        
+        if (getCSSClass() == "expertBadCert") {
+          toggle('expertContent');
+        }
+        
+        var tech = document.getElementById("technicalContentText");
+        if (tech)
+          tech.textContent = getDescription();
+        
+        addDomainErrorLink();
+      }
+      
+      /* In the case of SSL error pages about domain mismatch, see if
+         we can hyperlink the user to the correct site.  We don't want
+         to do this generically since it allows MitM attacks to redirect
+         users to a site under attacker control, but in certain cases
+         it is safe (and helpful!) to do so.  Bug 402210
+      */
+      function addDomainErrorLink() {
+        // Rather than textContent, we need to treat description as HTML
+        var sd = document.getElementById("technicalContentText");
+        if (sd) {
+          var desc = getDescription();
+          
+          // sanitize description text - see bug 441169
+          
+          // First, find the index of the <a> tag we care about, being careful not to
+          // use an over-greedy regex
+          var re = /<a id="cert_domain_link" title="([^"]+)">/;
+          var result = re.exec(desc);
+          if(!result)
+            return;
+          
+          // Remove sd's existing children
+          sd.textContent = "";
+
+          // Everything up to the link should be text content
+          sd.appendChild(document.createTextNode(desc.slice(0, result.index)));
+          
+          // Now create the link itself
+          var anchorEl = document.createElement("a");
+          anchorEl.setAttribute("id", "cert_domain_link");
+          anchorEl.setAttribute("title", result[1]);
+          anchorEl.appendChild(document.createTextNode(result[1]));
+          sd.appendChild(anchorEl);
+          
+          // Finally, append text for anything after the closing </a>
+          sd.appendChild(document.createTextNode(desc.slice(desc.indexOf("</a>") + "</a>".length)));
+        }
+
+        var link = document.getElementById('cert_domain_link');
+        if (!link)
+          return;
+        
+        var okHost = link.getAttribute("title");
+        var thisHost = document.location.hostname;
+        var proto = document.location.protocol;
+
+        // If okHost is a wildcard domain ("*.example.com") let's
+        // use "www" instead.  "*.example.com" isn't going to
+        // get anyone anywhere useful. bug 432491
+        okHost = okHost.replace(/^\*\./, "www.");
+
+        /* case #1: 
+         * example.com uses an invalid security certificate.
+         *
+         * The certificate is only valid for www.example.com
+         *
+         * Make sure to include the "." ahead of thisHost so that
+         * a MitM attack on paypal.com doesn't hyperlink to "notpaypal.com"
+         *
+         * We'd normally just use a RegExp here except that we lack a
+         * library function to escape them properly (bug 248062), and
+         * domain names are famous for having '.' characters in them,
+         * which would allow spurious and possibly hostile matches.
+         */
+        if (endsWith(okHost, "." + thisHost))
+          link.href = proto + okHost;
+
+        /* case #2:
+         * browser.garage.maemo.org uses an invalid security certificate.
+         *
+         * The certificate is only valid for garage.maemo.org
+         */
+        if (endsWith(thisHost, "." + okHost))
+          link.href = proto + okHost;
+          
+        // If we set a link, meaning there's something helpful for
+        // the user here, expand the section by default
+        if (link.href)
+          toggle("technicalContent");
+      }
+      
+      function endsWith(haystack, needle) {
+        return haystack.slice(-needle.length) == needle;
+      }
+
+      function toggle(id) {
+        var el = document.getElementById(id);
+        if (el.getAttribute("collapsed"))
+          el.removeAttribute("collapsed");
+        else
+          el.setAttribute("collapsed", true);
+      }
+    ]]></script>
+  </head>
+
+  <body dir="&locale.dir;">
+
+    <!-- PAGE CONTAINER (for styling purposes only) -->
+    <div id="errorPageContainer">
+    
+      <!-- Error Title -->
+      <div id="errorTitle">
+        <h1 id="errorTitleText">&certerror.longpagetitle;</h1>
+      </div>
+      
+      <!-- LONG CONTENT (the section most likely to require scrolling) -->
+      <div id="errorLongContent">
+        <div id="introContent">
+          <p id="introContentP1">&certerror.introPara1;</p>
+          <p>&certerror.introPara2;</p>
+        </div>
+        
+        <div id="whatShouldIDoContent">
+          <h2>&certerror.whatShouldIDo.heading;</h2>
+          <div id="whatShouldIDoContentText">
+            <p>&certerror.whatShouldIDo.content;</p>
+            <xul:button xmlns:xul='http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul' id='getMeOutOfHereButton' label='&certerror.getMeOutOfHere.label;'/>
+          </div>
+        </div>
+        
+        <div id="technicalContent" collapsed="true">
+          <h2 onclick="toggle('technicalContent');" id="technicalContentHeading">&certerror.technical.heading;</h2>
+          <p id="technicalContentText"/>
+        </div>
+        
+        <!-- This section can be unhidden by default by setting the
+        "browser.xul.error_pages.expert_bad_cert" pref to true -->
+        <div id="expertContent" collapsed="true">
+          <h2 onclick="toggle('expertContent');" id="expertContentHeading">&certerror.expert.heading;</h2>
+          <div>
+            <p>&certerror.expert.content;</p>
+            <p>&certerror.expert.contentPara2;</p>
+            <xul:button xmlns:xul='http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul' id='exceptionDialogButton' label='&certerror.addException.label;'/>
+          </div>
+        </div>
+      </div>
+    </div>
+
+    <!--
+    - Note: It is important to run the script this way, instead of using
+    - an onload handler. This is because error pages are loaded as
+    - LOAD_BACKGROUND, which means that onload handlers will not be executed.
+    -->
+    <script type="application/x-javascript">initPage();</script>
+
+  </body>
+</html>
diff -r 17e9560465b0 browser/components/certerror/jar.mn
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/components/certerror/jar.mn	Thu Oct 30 05:41:44 2008 -0400
@@ -0,0 +1,3 @@
+browser.jar:
+  content/browser/certerror/aboutCertError.xhtml               (content/aboutCertError.xhtml)
+  content/browser/certerror/aboutCertError.css                 (content/aboutCertError.css)
diff -r 17e9560465b0 browser/components/certerror/test/Makefile.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/components/certerror/test/Makefile.in	Thu Oct 30 05:41:44 2008 -0400
@@ -0,0 +1,53 @@
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+#    Mozilla Corporation.
+# Portions created by the Initial Developer are Copyright (C) 2008
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Johnathan Nightingale <johnath@mozilla.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+relativesrcdir  = browser/components/certerror/test
+
+include $(DEPTH)/config/autoconf.mk
+include $(topsrcdir)/config/rules.mk
+
+_BROWSER_FILES = browser_bug431826.js \
+    $(NULL)
+
+libs::	$(_BROWSER_FILES)
+	$(INSTALL) $(foreach f,$^,"$f") $(DEPTH)/_tests/testing/mochitest/browser/$(relativesrcdir)
+
diff -r 17e9560465b0 browser/components/certerror/test/browser_bug431826.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/components/certerror/test/browser_bug431826.js	Thu Oct 30 05:41:44 2008 -0400
@@ -0,0 +1,43 @@
+var newBrowser
+
+function test() {
+  waitForExplicitFinish();
+  
+  var newTab = gBrowser.addTab();
+  gBrowser.selectedTab = newTab;
+  newBrowser = gBrowser.getBrowserForTab(newTab);
+  
+  // Navigate to a site with a broken cert
+  newBrowser.contentWindow.location = 'https://nocert.example.com/';
+  // XXX - This timer and the next should be replaced with an event
+  // handler when bug 425001 is fixed.
+  window.setTimeout(testBrokenCert, 2000);
+}
+
+function testBrokenCert() {
+  
+  // Confirm that we are displaying the contributed error page, not the default
+  ok(/^about:certerror/.test(gBrowser.contentWindow.document.documentURI), "Broken page should go to about:certerror, not about:neterror");
+  
+  // Confirm that the expert section is collapsed
+  var expertDiv = gBrowser.contentWindow.document.getElementById("expertContent");
+  ok(expertDiv, "Expert content div should exist");
+  ok(expertDiv.hasAttribute("collapsed"), "Expert content should be collapsed by default");
+  
+  // Tweak the expert mode pref
+  Cc["@mozilla.org/preferences-service;1"].getService(Ci.nsIPrefBranch)
+                                          .setBoolPref("browser.xul.error_pages.expert_bad_cert", true);
+  
+  newBrowser.reload();
+  window.setTimeout(testExpertPref, 2000);
+}
+
+function testExpertPref() {
+  
+  var expertDiv = gBrowser.contentWindow.document.getElementById("expertContent");
+  ok(!expertDiv.hasAttribute("collapsed"), "Expert content should not be collapsed with the expert mode pref set");
+  
+  // Clean up
+  gBrowser.removeCurrentTab();
+  finish();
+}
diff -r 17e9560465b0 browser/components/nsBrowserGlue.js
--- a/browser/components/nsBrowserGlue.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/components/nsBrowserGlue.js	Thu Oct 30 05:41:44 2008 -0400
@@ -784,7 +784,68 @@
   ]
 }
 
+function GeolocationPrompt() {}
+
+GeolocationPrompt.prototype = {
+  classDescription: "Geolocation Prompting Component",
+  classID:          Components.ID("{C6E8C44D-9F39-4AF7-BCC0-76E38A8310F5}"),
+  contractID:       "@mozilla.org/geolocation/prompt;1",
+
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIGeolocationPrompt]),
+ 
+  prompt: function(request) {
+
+    function getChromeWindow(aWindow) {
+      var chromeWin = aWindow 
+        .QueryInterface(Ci.nsIInterfaceRequestor)
+        .getInterface(Ci.nsIWebNavigation)
+        .QueryInterface(Ci.nsIDocShellTreeItem)
+        .rootTreeItem
+        .QueryInterface(Ci.nsIInterfaceRequestor)
+        .getInterface(Ci.nsIDOMWindow)
+        .QueryInterface(Ci.nsIDOMChromeWindow);
+      return chromeWin;
+    }
+
+    var requestingWindow = request.requestingWindow.top;
+    var tabbrowser = getChromeWindow(requestingWindow).wrappedJSObject.gBrowser;
+    var browser = tabbrowser.getBrowserForDocument(requestingWindow.document);
+    var notificationBox = tabbrowser.getNotificationBox(browser);
+
+    var notification = notificationBox.getNotificationWithValue("geolocation");
+    if (!notification) {
+      var bundleService = Cc["@mozilla.org/intl/stringbundle;1"].getService(Ci.nsIStringBundleService);
+      var browserBundle = bundleService.createBundle("chrome://browser/locale/browser.properties");
+
+      var buttons = [{
+        label: browserBundle.GetStringFromName("geolocation.exactLocation"),
+        accessKey: browserBundle.GetStringFromName("geolocation.exactLocationKey"),
+        callback: function() request.allow() ,
+        },
+        {
+        label: browserBundle.GetStringFromName("geolocation.neighborhoodLocation"),
+        accessKey: browserBundle.GetStringFromName("geolocation.neighborhoodLocationKey"),
+        callback: function() request.allowButFuzz() ,
+        },
+        {
+        label: browserBundle.GetStringFromName("geolocation.nothingLocation"),
+        accessKey: browserBundle.GetStringFromName("geolocation.nothingLocationKey"),
+        callback: function() request.cancel() ,
+        }];
+      
+      var message = browserBundle.formatStringFromName("geolocation.requestMessage",
+                                                       [request.requestingURI.spec], 1);      
+      notificationBox.appendNotification(message,
+                                         "geolocation",
+                                         "chrome://browser/skin/Info.png",
+                                         notificationBox.PRIORITY_INFO_HIGH,
+                                         buttons);
+    }
+  },
+};
+
+
 //module initialization
 function NSGetModule(aCompMgr, aFileSpec) {
-  return XPCOMUtils.generateModule([BrowserGlue]);
+  return XPCOMUtils.generateModule([BrowserGlue, GeolocationPrompt]);
 }
diff -r 17e9560465b0 browser/components/places/content/bookmarkProperties.js
--- a/browser/components/places/content/bookmarkProperties.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/components/places/content/bookmarkProperties.js	Thu Oct 30 05:41:44 2008 -0400
@@ -22,7 +22,7 @@
  *   Joe Hughes <jhughes@google.com>
  *   Dietrich Ayala <dietrich@mozilla.com>
  *   Asaf Romano <mano@mozilla.com>
- *   Marco Bonardo <mak77@supereva.it>
+ *   Marco Bonardo <mak77@bonardo.net>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -53,20 +53,21 @@
  *         - "livemark"
  *       @ uri (nsIURI object) - optional, the default uri for the new item.
  *         The property is not used for the "folder with items" type.
- *       @ title (String) - optional, the defualt title for the new item.
+ *       @ title (String) - optional, the default title for the new item.
  *       @ description (String) - optional, the default description for the new
  *         item.
  *       @ defaultInsertionPoint (InsertionPoint JS object) - optional, the
  *         default insertion point for the new item.
  *       @ keyword (String) - optional, the default keyword for the new item.
  *       @ postData (String) - optional, POST data to accompany the keyword.
+ *       @ charSet (String) - optional, character-set to accompany the keyword.
  *      Notes:
  *        1) If |uri| is set for a bookmark/livemark item and |title| isn't,
  *           the dialog will query the history tables for the title associated
  *           with the given uri. If the dialog is set to adding a folder with
  *           bookmark items under it (see URIList), a default static title is
  *           used ("[Folder Name]").
- *        2) The index field of the the default insertion point is ignored if
+ *        2) The index field of the default insertion point is ignored if
  *           the folder picker is shown.
  *     - "edit" - for editing a bookmark item or a folder.
  *       @ type (String). Possible values:
@@ -81,20 +82,15 @@
  *     - "location"
  *     - "description"
  *     - "keyword"
+ *     - "tags"
  *     - "loadInSidebar"
- *     - "feedURI"
- *     - "siteURI"
- *     - "folder picker" - hides both the tree and the menu.
+ *     - "feedLocation"
+ *     - "siteLocation"
+ *     - "folderPicker" - hides both the tree and the menu.
  *
  * window.arguments[0].performed is set to true if any transaction has
  * been performed by the dialog.
  */
-
-const LAST_USED_ANNO = "bookmarkPropertiesDialog/folderLastUsed";
-const STATIC_TITLE_ANNO = "bookmarks/staticTitle";
-
-// This doesn't include "static" special folders (first two menu items)
-const MAX_FOLDER_ITEM_IN_MENU_LIST = 5;
 
 const BOOKMARK_ITEM = 0;
 const BOOKMARK_FOLDER = 1;
@@ -118,21 +114,19 @@
   _itemType: null,
   _itemId: -1,
   _uri: null,
-  _loadBookmarkInSidebar: false,
-  _itemTitle: "",
-  _itemDescription: "",
-  _microsummaries: null,
-  _URIList: null,
+  _loadInSidebar: false,
+  _title: "",
+  _description: "",
+  _URIs: [],
+  _keyword: "",
   _postData: null,
   _charSet: "",
+  _feedURI: null,
+  _siteURI: null,
 
-  // sizeToContent is not usable due to bug 90276, so we'll use resizeTo
-  // instead and cache the bookmarks tree view size. See WSucks in the legacy
-  // UI code (addBookmark2.js).
-  //
-  // XXXmano: this doesn't work as expected yet, need to figure out if we're
-  // facing cocoa-widget resizeTo issue here.
-  _folderTreeHeight: null,
+  _defaultInsertionPoint: null,
+  _hiddenRows: [],
+  _batching: false,
 
   /**
    * This method returns the correct label for the dialog's "accept"
@@ -140,10 +134,16 @@
    */
   _getAcceptLabel: function BPP__getAcceptLabel() {
     if (this._action == ACTION_ADD) {
-      if (this._URIList)
+      if (this._URIs.length)
         return this._strings.getString("dialogAcceptLabelAddMulti");
 
-      return this._strings.getString("dialogAcceptLabelAddItem");
+      if (this._itemType == LIVEMARK_CONTAINER)
+        return this._strings.getString("dialogAcceptLabelAddLivemark");
+
+      if (this._dummyItem || this._loadInSidebar)
+        return this._strings.getString("dialogAcceptLabelAddItem");
+
+      return this._strings.getString("dialogAcceptLabelSaveItem");
     }
     return this._strings.getString("dialogAcceptLabelEdit");
   },
@@ -159,16 +159,15 @@
       if (this._itemType == LIVEMARK_CONTAINER)
         return this._strings.getString("dialogTitleAddLivemark");
 
-      // folder
-      NS_ASSERT(this._itemType == BOOKMARK_FOLDER, "bogus item type");
-      if (this._URIList)
+      // add folder
+      NS_ASSERT(this._itemType == BOOKMARK_FOLDER, "Unknown item type");
+      if (this._URIs.length)
         return this._strings.getString("dialogTitleAddMulti");
 
       return this._strings.getString("dialogTitleAddFolder");
     }
     if (this._action == ACTION_EDIT) {
-      return this._strings
-                 .getFormattedString("dialogTitleEdit", [this._itemTitle]);
+      return this._strings.getFormattedString("dialogTitleEdit", [this._title]);
     }
     return "";
   },
@@ -178,136 +177,124 @@
    */
   _determineItemInfo: function BPP__determineItemInfo() {
     var dialogInfo = window.arguments[0];
-    NS_ASSERT("action" in dialogInfo, "missing action property");
-    var action = dialogInfo.action;
-
-    if (action == "add") {
+    this._action = dialogInfo.action == "add" ? ACTION_ADD : ACTION_EDIT;
+    this._hiddenRows = dialogInfo.hiddenRows ? dialogInfo.hiddenRows : [];
+    if (this._action == ACTION_ADD) {
       NS_ASSERT("type" in dialogInfo, "missing type property for add action");
 
       if ("title" in dialogInfo)
-        this._itemTitle = dialogInfo.title;
-      if ("defaultInsertionPoint" in dialogInfo)
+        this._title = dialogInfo.title;
+
+      if ("defaultInsertionPoint" in dialogInfo) {
         this._defaultInsertionPoint = dialogInfo.defaultInsertionPoint;
-      else {
-        // default to the bookmarks root
+      }
+      else
         this._defaultInsertionPoint =
-          new InsertionPoint(PlacesUtils.bookmarksMenuFolderId, -1);
-      }
+          new InsertionPoint(PlacesUtils.bookmarksMenuFolderId,
+                             PlacesUtils.bookmarks.DEFAULT_INDEX,
+                             Ci.nsITreeView.DROP_ON);
 
       switch(dialogInfo.type) {
         case "bookmark":
-          this._action = ACTION_ADD;
           this._itemType = BOOKMARK_ITEM;
           if ("uri" in dialogInfo) {
             NS_ASSERT(dialogInfo.uri instanceof Ci.nsIURI,
                       "uri property should be a uri object");
             this._uri = dialogInfo.uri;
+            if (typeof(this._title) != "string") {
+              this._title = this._getURITitleFromHistory(this._uri) ||
+                            this._uri.spec;
+            }
           }
-          if (typeof(this._itemTitle) != "string") {
-            if (this._uri) {
-              this._itemTitle =
-                this._getURITitleFromHistory(this._uri);
-              if (!this._itemTitle)
-                this._itemTitle = this._uri.spec;
-            }
-            else
-              this._itemTitle = this._strings.getString("newBookmarkDefault");
+          else {
+            this._uri = PlacesUtils._uri("about:blank");
+            this._title = this._strings.getString("newBookmarkDefault");
+            this._dummyItem = true;
           }
 
           if ("loadBookmarkInSidebar" in dialogInfo)
-            this._loadBookmarkInSidebar = dialogInfo.loadBookmarkInSidebar;
+            this._loadInSidebar = dialogInfo.loadBookmarkInSidebar;
 
           if ("keyword" in dialogInfo) {
-            this._bookmarkKeyword = dialogInfo.keyword;
+            this._keyword = dialogInfo.keyword;
             if ("postData" in dialogInfo)
               this._postData = dialogInfo.postData;
             if ("charSet" in dialogInfo)
               this._charSet = dialogInfo.charSet;
           }
+          break;
 
-          break;
         case "folder":
-          this._action = ACTION_ADD;
           this._itemType = BOOKMARK_FOLDER;
-          if (!this._itemTitle) {
+          if (!this._title) {
             if ("URIList" in dialogInfo) {
-              this._itemTitle =
-                this._strings.getString("bookmarkAllTabsDefault");
-              this._URIList = dialogInfo.URIList;
+              this._title = this._strings.getString("bookmarkAllTabsDefault");
+              this._URIs = dialogInfo.URIList;
             }
             else
-              this._itemTitle = this._strings.getString("newFolderDefault");
+              this._title = this._strings.getString("newFolderDefault");
+              this._dummyItem = true;
           }
           break;
+
         case "livemark":
-          this._action = ACTION_ADD;
           this._itemType = LIVEMARK_CONTAINER;
           if ("feedURI" in dialogInfo)
             this._feedURI = dialogInfo.feedURI;
           if ("siteURI" in dialogInfo)
             this._siteURI = dialogInfo.siteURI;
 
-          if (!this._itemTitle) {
+          if (!this._title) {
             if (this._feedURI) {
-              this._itemTitle =
-                this._getURITitleFromHistory(this._feedURI);
-              if (!this._itemTitle)
-                this._itemTitle = this._feedURI.spec;
+              this._title = this._getURITitleFromHistory(this._feedURI) ||
+                            this._feedURI.spec;
             }
             else
-              this._itemTitle = this._strings.getString("newLivemarkDefault");
+              this._title = this._strings.getString("newLivemarkDefault");
           }
       }
 
       if ("description" in dialogInfo)
-        this._itemDescription = dialogInfo.description;
+        this._description = dialogInfo.description;
     }
     else { // edit
-      const annos = PlacesUtils.annotations;
-      const bookmarks = PlacesUtils.bookmarks;
+      NS_ASSERT("itemId" in dialogInfo);
+      this._itemId = dialogInfo.itemId;
+      this._title = PlacesUtils.bookmarks.getItemTitle(this._itemId);
+      // Don't show folderPicker when editing
+      this._hiddenRows.push("folderPicker");
 
       switch (dialogInfo.type) {
         case "bookmark":
-          NS_ASSERT("itemId" in dialogInfo);
+          this._itemType = BOOKMARK_ITEM;
 
-          this._action = ACTION_EDIT;
-          this._itemType = BOOKMARK_ITEM;
-          this._itemId = dialogInfo.itemId;
+          this._uri = PlacesUtils.bookmarks.getBookmarkURI(this._itemId);
+          // keyword
+          this._keyword = PlacesUtils.bookmarks
+                                     .getKeywordForBookmark(this._itemId);
+          // Load In Sidebar
+          this._loadInSidebar = PlacesUtils.annotations
+                                           .itemHasAnnotation(this._itemId,
+                                                              LOAD_IN_SIDEBAR_ANNO);
+          break;
 
-          this._uri = bookmarks.getBookmarkURI(this._itemId);
-          this._itemTitle = bookmarks.getItemTitle(this._itemId);
-
-          // keyword
-          this._bookmarkKeyword =
-            bookmarks.getKeywordForBookmark(this._itemId);
-
-          // Load In Sidebar
-          this._loadBookmarkInSidebar =
-            annos.itemHasAnnotation(this._itemId, LOAD_IN_SIDEBAR_ANNO);
-
-          break;
         case "folder":
-          NS_ASSERT("itemId" in dialogInfo);
-
-          this._action = ACTION_EDIT;
-          this._itemId = dialogInfo.itemId;
-
-          const livemarks = PlacesUtils.livemarks;
-          if (livemarks.isLivemark(this._itemId)) {
+          if (PlacesUtils.livemarks.isLivemark(this._itemId)) {
             this._itemType = LIVEMARK_CONTAINER;
-            this._feedURI = livemarks.getFeedURI(this._itemId);
-            this._siteURI = livemarks.getSiteURI(this._itemId);
+            this._feedURI = PlacesUtils.livemarks.getFeedURI(this._itemId);
+            this._siteURI = PlacesUtils.livemarks.getSiteURI(this._itemId);
           }
           else
             this._itemType = BOOKMARK_FOLDER;
-          this._itemTitle = bookmarks.getItemTitle(this._itemId);
           break;
       }
 
       // Description
-      if (annos.itemHasAnnotation(this._itemId, DESCRIPTION_ANNO)) {
-        this._itemDescription = annos.getItemAnnotation(this._itemId,
-                                                        DESCRIPTION_ANNO);
+      if (PlacesUtils.annotations
+                     .itemHasAnnotation(this._itemId, DESCRIPTION_ANNO)) {
+        this._description = PlacesUtils.annotations
+                                       .getItemAnnotation(this._itemId,
+                                                          DESCRIPTION_ANNO);
       }
     }
   },
@@ -336,340 +323,170 @@
    */
   onDialogLoad: function BPP_onDialogLoad() {
     this._determineItemInfo();
-    this._populateProperties();
-    this.validateChanges();
 
-    this._folderMenuList = this._element("folderMenuList");
-    this._folderTree = this._element("folderTree");
-    if (!this._element("folderRow").hidden)
-      this._initFolderMenuList();
+    document.title = this._getDialogTitle();
+    var acceptButton = document.documentElement.getButton("accept");
+    acceptButton.label = this._getAcceptLabel();
+
+    this._beginBatch();
+
+    switch (this._action) {
+      case ACTION_EDIT:
+        this._fillEditProperties();
+        break;
+      case ACTION_ADD:
+        this._fillAddProperties();
+        // if this is an uri related dialog disable accept button until
+        // the user fills an uri value.
+        if (this._itemType == BOOKMARK_ITEM ||
+            this._itemType == LIVEMARK_CONTAINER)
+          acceptButton.disabled = !this._inputIsValid();
+        break;
+    }
+
+    // When collapsible elements change their collapsed attribute we must
+    // resize the dialog.
+    // sizeToContent is not usable due to bug 90276, so we'll use resizeTo
+    // instead and cache the element size. See WSucks in the legacy
+    // UI code (addBookmark2.js).
+    this._resizeListener = {
+      _elementsHeight: [],
+      handleEvent: function(event) {
+        // this is called when collapsing a node, but also its direct children,
+        // we only need to resize when the original node changes.
+        if (event.attrName == "collapsed" &&
+            event.target == event.originalTarget) {
+          var element = event.target;
+          var id = element.id;
+          var newHeight = window.outerHeight;
+          if (event.newValue) // is collapsed
+            newHeight -= this._elementsHeight[id];
+          else {
+            this._elementsHeight[id] = element.boxObject.height;
+            newHeight += this._elementsHeight[id];
+          }
+
+          window.resizeTo(window.outerWidth, newHeight);
+        }
+      }
+    };
+
+    if (!this._element("tagsRow").collapsed) {
+      this._element("tagsSelector")
+          .addEventListener("DOMAttrModified", this._resizeListener, false);
+    }
+    if (!this._element("folderRow").collapsed) {
+      this._element("folderTree")
+          .addEventListener("DOMAttrModified", this._resizeListener, false);
+      this._element("newFolderBox")
+          .addEventListener("DOMAttrModified", this._resizeListener, false);
+    }
+
+    // Listen on uri fields to enable accept button if input is valid
+    this._inputListener = {
+      _self: this,
+      handleEvent: function(event) {
+        document.documentElement.getButton("accept").disabled =
+          !this._self._inputIsValid();
+      }
+    };
+    if (this._itemType == BOOKMARK_ITEM) {
+      this._element("locationField")
+          .addEventListener("input", this._inputListener, false);
+    }
+    else if (this._itemType == LIVEMARK_CONTAINER) {
+      this._element("feedLocationField")
+          .addEventListener("input", this._inputListener, false);
+      this._element("siteLocationField")
+          .addEventListener("input", this._inputListener, false);
+    }
 
     window.sizeToContent();
-
-    // read the persisted attribute.
-    this._folderTreeHeight = parseInt(this._folderTree.getAttribute("height"));
   },
 
-  /**
-   * Appends a menu-item representing a bookmarks folder to a menu-popup.
-   * @param aMenupopup
-   *        The popup to which the menu-item should be added.
-   * @param aFolderId
-   *        The identifier of the bookmarks folder.
-   * @return the new menu item.
-   */
-  _appendFolderItemToMenupopup:
-  function BPP__appendFolderItemToMenupopup(aMenupopup, aFolderId) {
-    try {
-      var folderTitle = PlacesUtils.bookmarks.getItemTitle(aFolderId);
-    }
-    catch (ex) {
-      NS_ASSERT(folderTitle, "no title found for folderId of " + aFolderId);
-      return null;
-    }
+  _beginBatch: function BPP__beginBatch() {
+    if (this._batching)
+      return;
 
-    // First make sure the folders-separator is visible
-    this._element("foldersSeparator").hidden = false;
+    PlacesUIUtils.ptm.beginBatch();
+    this._batching = true;
 
-    var folderMenuItem = document.createElement("menuitem");
-    folderMenuItem.folderId = aFolderId;
-    folderMenuItem.setAttribute("label", folderTitle);
-    folderMenuItem.className = "menuitem-iconic folder-icon";
-    aMenupopup.appendChild(folderMenuItem);
-    return folderMenuItem;
+    // XXXmano hack: We push a no-op transaction on the stack so it's always
+    // safe for the Cancel button to call undoTransaction after endBatch.
+    // Otherwise, if no changes were done in the edit-item panel, the last
+    // transaction on the undo stack may be the initial createItem transaction,
+    // or worse, the batched editing of some other item.
+    PlacesUIUtils.ptm.doTransaction({ doTransaction: function() { },
+                                      undoTransaction: function() { },
+                                      redoTransaction: function() { },
+                                      isTransient: false,
+                                      merge: function() { return false; } });
   },
 
-  _initFolderMenuList: function BPP__initFolderMenuList() {
-    // Build the static list
-    var bms = PlacesUtils.bookmarks;
-    var bmMenuItem = this._element("bookmarksRootItem");
-    bmMenuItem.label = bms.getItemTitle(PlacesUtils.bookmarksMenuFolderId);
-    bmMenuItem.folderId = PlacesUtils.bookmarksMenuFolderId;
-    var toolbarItem = this._element("toolbarFolderItem");
-    toolbarItem.label = bms.getItemTitle(PlacesUtils.toolbarFolderId);
-    toolbarItem.folderId = PlacesUtils.toolbarFolderId;
+  _endBatch: function BPP__endBatch() {
+    if (!this._batching)
+      return;
 
-    // List of recently used folders:
-    var annos = PlacesUtils.annotations;
-    var folderIds = annos.getItemsWithAnnotation(LAST_USED_ANNO, { });
+    PlacesUIUtils.ptm.endBatch();
+    this._batching = false;
+  },
 
-    // Hide the folders-separator if no folder is annotated as recently-used
-    if (folderIds.length == 0) {
-      this._element("foldersSeparator").hidden = true;
-      return;
-    }
+  _fillEditProperties: function BPP__fillEditProperties() {
+    gEditItemOverlay.initPanel(this._itemId,
+                               { hiddenRows: this._hiddenRows });
+  },
 
-    /**
-     * The value of the LAST_USED_ANNO annotation is the time (in the form of
-     * Date.getTime) at which the folder has been last used.
-     *
-     * First we build the annotated folders array, each item has both the
-     * folder identifier and the time at which it was last-used by this dialog
-     * set. Then we sort it descendingly based on the time field.
-     */
-    var folders = [];
-    for (var i=0; i < folderIds.length; i++) {
-      var lastUsed = annos.getItemAnnotation(folderIds[i], LAST_USED_ANNO);
-      folders.push({ folderId: folderIds[i], lastUsed: lastUsed });
-    }
-    folders.sort(function(a, b) {
-      if (b.lastUsed < a.lastUsed)
-        return -1;
-      if (b.lastUsed > a.lastUsed)
-        return 1;
-      return 0;
-    });
-
-    var numberOfItems = Math.min(MAX_FOLDER_ITEM_IN_MENU_LIST, folders.length);
-    var menupopup = this._folderMenuList.menupopup;
-    for (i=0; i < numberOfItems; i++) {
-      this._appendFolderItemToMenupopup(menupopup, folders[i].folderId);
-    }
-
-    var defaultItem =
-      this._getFolderMenuItem(this._defaultInsertionPoint.itemId);
-
-    // if we fail to get a menuitem for the default insertion point
-    // use the Bookmarks root
-    if (!defaultItem)
-      defaultItem = this._element("bookmarksRootItem");
-
-    this._folderMenuList.selectedItem = defaultItem;
+  _fillAddProperties: function BPP__fillAddProperties() {
+    this._createNewItem();
+    // Edit the new item
+    gEditItemOverlay.initPanel(this._itemId,
+                               { hiddenRows: this._hiddenRows });
+    // Empty location field if the uri is about:blank, this way inserting a new
+    // url will be easier for the user, Accept button will be automatically
+    // disabled by the input listener until the user fills the field.
+    var locationField = this._element("locationField");
+    if (locationField.value == "about:blank")
+      locationField.value = "";
   },
 
   QueryInterface: function BPP_QueryInterface(aIID) {
-    if (aIID.equals(Ci.nsIMicrosummaryObserver) ||
-        aIID.equals(Ci.nsISupports))
+    if (aIID.equals(Ci.nsISupports))
       return this;
 
     throw Cr.NS_ERROR_NO_INTERFACE;
   },
 
   _element: function BPP__element(aID) {
-    return document.getElementById(aID);
-  },
-
-  /**
-   * Show or hides fields based on item type.
-   */
-  _showHideRows: function BPP__showHideRows() {
-    var hiddenRows = window.arguments[0].hiddenRows || new Array();
-
-    var isBookmark = this._itemType == BOOKMARK_ITEM;
-    var isLivemark = this._itemType == LIVEMARK_CONTAINER;
-
-    var isQuery = false;
-    if (this._uri)
-      isQuery = this._uri.schemeIs("place");
-
-    this._element("namePicker").hidden =
-      hiddenRows.indexOf("title") != -1;
-    this._element("locationRow").hidden =
-      hiddenRows.indexOf("location") != -1 || isQuery || !isBookmark;
-    this._element("keywordRow").hidden =
-      hiddenRows.indexOf("keyword") != -1 || isQuery || !isBookmark;
-    this._element("descriptionRow").hidden =
-      hiddenRows.indexOf("description")!= -1
-    this._element("folderRow").hidden =
-      hiddenRows.indexOf("folder picker") != -1 || this._action == ACTION_EDIT;
-    this._element("livemarkFeedLocationRow").hidden =
-      hiddenRows.indexOf("feedURI") != -1 || !isLivemark;
-    this._element("livemarkSiteLocationRow").hidden =
-      hiddenRows.indexOf("siteURI") != -1 || !isLivemark;
-    this._element("loadInSidebarCheckbox").hidden =
-      hiddenRows.indexOf("loadInSidebar") != -1 || isQuery || !isBookmark;
-  },
-
-  /**
-   * This method fills in the data values for the fields in the dialog.
-   */
-  _populateProperties: function BPP__populateProperties() {
-    document.title = this._getDialogTitle();
-    document.documentElement.getButton("accept").label = this._getAcceptLabel();
-
-    this._initNamePicker();
-    this._element("descriptionTextfield").value = this._itemDescription;
-
-    if (this._itemType == BOOKMARK_ITEM) {
-      if (this._uri)
-        this._element("editURLBar").value = this._uri.spec;
-
-      if (typeof(this._bookmarkKeyword) == "string")
-        this._element("keywordTextfield").value = this._bookmarkKeyword;
-
-      if (this._loadBookmarkInSidebar)
-        this._element("loadInSidebarCheckbox").checked = true;
-    }
-
-    if (this._itemType == LIVEMARK_CONTAINER) {
-      if (this._feedURI)
-        this._element("feedLocationTextfield").value = this._feedURI.spec;
-      if (this._siteURI)
-        this._element("feedSiteLocationTextfield").value = this._siteURI.spec;
-    }
-
-    this._showHideRows();
-  },
-
-  _createMicrosummaryMenuItem:
-  function BPP__createMicrosummaryMenuItem(aMicrosummary) {
-    var menuItem = document.createElement("menuitem");
-
-    // Store a reference to the microsummary in the menu item, so we know
-    // which microsummary this menu item represents when it's time to
-    // save changes or load its content.
-    menuItem.microsummary = aMicrosummary;
-
-    // Content may have to be generated asynchronously; we don't necessarily
-    // have it now.  If we do, great; otherwise, fall back to the generator
-    // name, then the URI, and we trigger a microsummary content update. Once
-    // the update completes, the microsummary will notify our observer to
-    // update the corresponding menu-item.
-    // XXX Instead of just showing the generator name or (heaven forbid)
-    // its URI when we don't have content, we should tell the user that
-    // we're loading the microsummary, perhaps with some throbbing to let
-    // her know it is in progress.
-    if (aMicrosummary.content)
-      menuItem.setAttribute("label", aMicrosummary.content);
-    else {
-      menuItem.setAttribute("label", aMicrosummary.generator.name ||
-                                     aMicrosummary.generator.uri.spec);
-      aMicrosummary.update();
-    }
-
-    return menuItem;
-  },
-
-  _initNamePicker: function BPP_initNamePicker() {
-    var userEnteredNameField = this._element("userEnteredName");
-    var namePicker = this._element("namePicker");
-    const annos = PlacesUtils.annotations;
-
-    if (annos.itemHasAnnotation(this._itemId, STATIC_TITLE_ANNO)) {
-      userEnteredNameField.label = annos.getItemAnnotation(this._itemId,
-                                                           STATIC_TITLE_ANNO);
-    }
-    else
-      userEnteredNameField.label = this._itemTitle;
-
-    // Non-bookmark items always use the item-title itself
-    if (this._itemType != BOOKMARK_ITEM || !this._uri) {
-      namePicker.selectedItem = userEnteredNameField;
-      return;
-    }
-
-    var itemToSelect = userEnteredNameField;
-    try {
-      this._microsummaries =
-        PlacesUIUtils.microsummaries.getMicrosummaries(this._uri,
-                                                       this._itemId);
-    }
-    catch(ex) {
-      // getMicrosummaries will throw an exception if the page to which the URI
-      // refers isn't HTML or XML (the only two content types the service knows
-      // how to summarize).
-      this._microsummaries = null;
-    }
-    if (this._microsummaries) {
-      var enumerator = this._microsummaries.Enumerate();
-
-      if (enumerator.hasMoreElements()) {
-        // Show the drop marker if there are microsummaries
-        namePicker.setAttribute("droppable", "true");
-
-        var menupopup = namePicker.menupopup;
-        while (enumerator.hasMoreElements()) {
-          var microsummary = enumerator.getNext()
-                                       .QueryInterface(Ci.nsIMicrosummary);
-          var menuItem = this._createMicrosummaryMenuItem(microsummary);
-
-          if (this._action == ACTION_EDIT &&
-              PlacesUIUtils.microsummaries
-                           .isMicrosummary(this._itemId, microsummary))
-            itemToSelect = menuItem;
-
-          menupopup.appendChild(menuItem);
-        }
-      }
-
-      this._microsummaries.addObserver(this);
-    }
-
-    namePicker.selectedItem = itemToSelect;
-  },
-
-  // nsIMicrosummaryObserver
-  onContentLoaded: function BPP_onContentLoaded(aMicrosummary) {
-    var namePicker = this._element("namePicker");
-    var childNodes = namePicker.menupopup.childNodes;
-
-    // 0: user-entered item; 1: separator
-    for (var i = 2; i < childNodes.length; i++) {
-      if (childNodes[i].microsummary == aMicrosummary) {
-        var newLabel = aMicrosummary.content;
-        // XXXmano: non-editable menulist would do this for us, see bug 360220
-        // We should fix editable-menulsits to set the DOMAttrModified handler
-        // as well.
-        //
-        // Also note the order importance: if the label of the menu-item is
-        // set the something different than the menulist's current value,
-        // the menulist no longer has selectedItem set
-        if (namePicker.selectedItem == childNodes[i])
-          namePicker.value = newLabel;
-
-        childNodes[i].label = newLabel;
-        return;
-      }
-    }
-  },
-
-  onElementAppended: function BPP_onElementAppended(aMicrosummary) {
-    var namePicker = this._element("namePicker");
-    namePicker.menupopup
-              .appendChild(this._createMicrosummaryMenuItem(aMicrosummary));
-
-    // Make sure the drop-marker is shown
-    namePicker.setAttribute("droppable", "true");
-  },
-
-  onError: function BPP_onError(aMicrosummary) {
-    var namePicker = this._element("namePicker");
-    var childNodes = namePicker.menupopup.childNodes;
-
-    // 0: user-entered item; 1: separator
-    for (var i = 2; i < childNodes.length; i++) {
-      if (childNodes[i].microsummary == aMicrosummary &&
-          aMicrosummary.needsRemoval)
-          namePicker.menupopup.removeChild(childNodes[i]);
-    }
+    return gEditItemOverlay._element(aID);
   },
 
   onDialogUnload: function BPP_onDialogUnload() {
-    if (this._microsummaries)
-      this._microsummaries.removeObserver(this);
-
-    // persist the folder tree height
-    if (!this._folderTree.collapsed) {
-      this._folderTree.setAttribute("height",
-                                    this._folderTree.boxObject.height);
-    }
+    gEditItemOverlay.uninitPanel(true);
+    // Calling removeEventListener with arguments which do not identify any
+    // currently registered EventListener on the EventTarget has no effect.
+    this._element("tagsSelector")
+        .removeEventListener("DOMAttrModified", this._resizeListener, false);
+    this._element("folderTree")
+        .removeEventListener("DOMAttrModified", this._resizeListener, false);
+    this._element("newFolderBox")
+        .removeEventListener("DOMAttrModified", this._resizeListener, false);
+    this._element("locationField")
+        .removeEventListener("input", this._inputListener, false);
+    this._element("feedLocationField")
+        .removeEventListener("input", this._inputListener, false);
+    this._element("siteLocationField")
+        .removeEventListener("input", this._inputListener, false);
   },
 
   onDialogAccept: function BPP_onDialogAccept() {
-    if (this._action == ACTION_ADD)
-      this._createNewItem();
-    else
-      this._saveChanges();
+    this._endBatch();
+    window.arguments[0].performed = true;
   },
 
-  /**
-   * This method checks the current state of the input fields in the
-   * dialog, and if any of them are in an invalid state, it will disable
-   * the submit button.  This method should be called after every
-   * significant change to the input.
-   */
-  validateChanges: function BPP_validateChanges() {
-    document.documentElement.getButton("accept").disabled = !this._inputIsValid();
+  onDialogCancel: function BPP_onDialogCancel() {
+    this._endBatch();
+    PlacesUIUtils.ptm.undoTransaction();
+    window.arguments[0].performed = false;
   },
 
   /**
@@ -678,16 +495,17 @@
    * @returns  true if the input is valid, false otherwise
    */
   _inputIsValid: function BPP__inputIsValid() {
-    if (this._itemType == BOOKMARK_ITEM && !this._containsValidURI("editURLBar"))
+    if (this._itemType == BOOKMARK_ITEM &&
+        !this._containsValidURI("locationField"))
       return false;
 
     // Feed Location has to be a valid URI;
     // Site Location has to be a valid URI or empty
     if (this._itemType == LIVEMARK_CONTAINER) {
-      if (!this._containsValidURI("feedLocationTextfield"))
+      if (!this._containsValidURI("feedLocationField"))
         return false;
-      if (!this._containsValidURI("feedSiteLocationTextfield") &&
-          (this._element("feedSiteLocationTextfield").value.length > 0))
+      if (!this._containsValidURI("siteLocationField") &&
+          (this._element("siteLocationField").value.length > 0))
         return false;
     }
 
@@ -712,14 +530,6 @@
       }
     } catch (e) { }
     return false;
-  },
-
-  /**
-   * Get an edit title transaction for the item edit/added in the dialog
-   */
-  _getEditTitleTransaction:
-  function BPP__getEditTitleTransaction(aItemId, aNewTitle) {
-    return PlacesUIUtils.ptm.editItemTitle(aItemId, aNewTitle);
   },
 
   /**
@@ -785,99 +595,6 @@
   },
 
   /**
-   * Dialog-accept code path when editing an item (any type).
-   *
-   * Save any changes that might have been made while the properties dialog
-   * was open.
-   */
-  _saveChanges: function BPP__saveChanges() {
-    var itemId = this._itemId;
-
-    var transactions = [];
-
-    // title
-    var newTitle = this._element("userEnteredName").label;
-    if (newTitle != this._itemTitle)
-      transactions.push(this._getEditTitleTransaction(itemId, newTitle));
-
-    // description
-    var description = this._element("descriptionTextfield").value;
-    if (description != this._itemDescription) {
-      transactions.push(PlacesUIUtils.ptm.
-                        editItemDescription(itemId, description,
-                        this._itemType != BOOKMARK_ITEM));
-    }
-
-    if (this._itemType == BOOKMARK_ITEM) {
-      // location
-      var url = PlacesUIUtils.createFixedURI(this._element("editURLBar").value);
-      if (!this._uri.equals(url))
-        transactions.push(PlacesUIUtils.ptm.editBookmarkURI(itemId, url));
-
-      // keyword transactions
-      var newKeyword = this._element("keywordTextfield").value;
-      if (newKeyword != this._bookmarkKeyword) {
-        transactions.push(PlacesUIUtils.ptm.
-                          editBookmarkKeyword(itemId, newKeyword));
-      }
-
-      // microsummaries
-      var namePicker = this._element("namePicker");
-      var newMicrosummary = namePicker.selectedItem.microsummary;
-
-      // Only add a microsummary update to the transaction if the
-      // microsummary has actually changed, i.e. the user selected no
-      // microsummary, but the bookmark previously had one, or the user
-      // selected a microsummary which is not the one the bookmark previously
-      // had.
-      if ((newMicrosummary == null &&
-           PlacesUIUtils.microsummaries.hasMicrosummary(itemId)) ||
-          (newMicrosummary != null &&
-           !PlacesUIUtils.microsummaries
-                         .isMicrosummary(itemId, newMicrosummary))) {
-        transactions.push(
-          PlacesUIUtils.ptm.editBookmarkMicrosummary(itemId, newMicrosummary));
-      }
-
-      // load in sidebar
-      var loadInSidebarChecked = this._element("loadInSidebarCheckbox").checked;
-      if (loadInSidebarChecked != this._loadBookmarkInSidebar) {
-        transactions.push(
-          PlacesUIUtils.ptm.setLoadInSidebar(itemId, loadInSidebarChecked));
-      }
-    }
-    else if (this._itemType == LIVEMARK_CONTAINER) {
-      var feedURIString = this._element("feedLocationTextfield").value;
-      var feedURI = PlacesUIUtils.createFixedURI(feedURIString);
-      if (!this._feedURI.equals(feedURI)) {
-        transactions.push(
-          PlacesUIUtils.ptm.editLivemarkFeedURI(this._itemId, feedURI));
-      }
-
-      // Site Location is empty, we can set its URI to null
-      var newSiteURIString = this._element("feedSiteLocationTextfield").value;
-      var newSiteURI = null;
-      if (newSiteURIString)
-        newSiteURI = PlacesUIUtils.createFixedURI(newSiteURIString);
-
-      if ((!newSiteURI && this._siteURI)  ||
-          (newSiteURI && (!this._siteURI || !this._siteURI.equals(newSiteURI)))) {
-        transactions.push(
-          PlacesUIUtils.ptm.editLivemarkSiteURI(this._itemId, newSiteURI));
-      }
-    }
-
-    // If we have any changes to perform, do them via the
-    // transaction manager passed by the opener so they can be undone.
-    if (transactions.length > 0) {
-      window.arguments[0].performed = true;
-      var aggregate =
-        PlacesUIUtils.ptm.aggregateTransactions(this._getDialogTitle(), transactions);
-      PlacesUIUtils.ptm.doTransaction(aggregate);
-    }
-  },
-
-  /**
    * [New Item Mode] Get the insertion point details for the new item, given
    * dialog state and opening arguments.
    *
@@ -885,13 +602,8 @@
    * the form of [containerIdentifier, insertionIndex]
    */
   _getInsertionPointDetails: function BPP__getInsertionPointDetails() {
-    var containerId, indexInContainer = -1;
-    if (!this._element("folderRow").hidden)
-      containerId = this._getFolderIdFromMenuList();
-    else {
-      containerId = this._defaultInsertionPoint.itemId;
-      indexInContainer = this._defaultInsertionPoint.index;
-    }
+    var containerId = this._defaultInsertionPoint.itemId;
+    var indexInContainer = this._defaultInsertionPoint.index;
 
     return [containerId, indexInContainer];
   },
@@ -902,39 +614,30 @@
    */
   _getCreateNewBookmarkTransaction:
   function BPP__getCreateNewBookmarkTransaction(aContainer, aIndex) {
-    var uri = PlacesUIUtils.createFixedURI(this._element("editURLBar").value);
-    var title = this._element("userEnteredName").label;
-    var keyword = this._element("keywordTextfield").value;
     var annotations = [];
-    var description = this._element("descriptionTextfield").value;
-    if (description)
-      annotations.push(this._getDescriptionAnnotation(description));
-
-    var loadInSidebar = this._element("loadInSidebarCheckbox").checked;
-    if (loadInSidebar)
+    if (this._description)
+      annotations.push(this._getDescriptionAnnotation(this._description));
+    if (this._loadInSidebar)
       annotations.push(this._getLoadInSidebarAnnotation(true));
 
     var childTransactions = [];
-    var microsummary = this._element("namePicker").selectedItem.microsummary;
-    if (microsummary) {
-      childTransactions.push(
-        PlacesUIUtils.ptm.editBookmarkMicrosummary(-1, microsummary));
-    }
-
     if (this._postData) {
       childTransactions.push(
         PlacesUIUtils.ptm.editBookmarkPostData(-1, this._postData));
     }
 
+    //XXX TODO: this should be in a transaction!
     if (this._charSet)
       PlacesUtils.history.setCharsetForURI(this._uri, this._charSet);
 
-    var transactions = [PlacesUIUtils.ptm.createItem(uri, aContainer, aIndex,
-                                                     title, keyword,
+    var transactions = [PlacesUIUtils.ptm.createItem(this._uri,
+                                                     aContainer, aIndex,
+                                                     this._title, this._keyword,
                                                      annotations,
                                                      childTransactions)];
 
-    return PlacesUIUtils.ptm.aggregateTransactions(this._getDialogTitle(), transactions);
+    return PlacesUIUtils.ptm.aggregateTransactions(this._getDialogTitle(),
+                                                   transactions);
   },
 
   /**
@@ -943,8 +646,8 @@
    */
   _getTransactionsForURIList: function BPP__getTransactionsForURIList() {
     var transactions = [];
-    for (var i = 0; i < this._URIList.length; ++i) {
-      var uri = this._URIList[i];
+    for (var i = 0; i < this._URIs.length; ++i) {
+      var uri = this._URIs[i];
       var title = this._getURITitleFromHistory(uri);
       transactions.push(PlacesUIUtils.ptm.createItem(uri, -1, -1, title));
     }
@@ -957,16 +660,15 @@
    */
   _getCreateNewFolderTransaction:
   function BPP__getCreateNewFolderTransaction(aContainer, aIndex) {
-    var folderName = this._element("namePicker").value;
     var annotations = [];
     var childItemsTransactions;
-    if (this._URIList)
+    if (this._URIs.length)
       childItemsTransactions = this._getTransactionsForURIList();
-    var description = this._element("descriptionTextfield").value;
-    if (description)
-      annotations.push(this._getDescriptionAnnotation(description));
 
-    return PlacesUIUtils.ptm.createFolder(folderName, aContainer, aIndex,
+    if (this._description)
+      annotations.push(this._getDescriptionAnnotation(this._description));
+
+    return PlacesUIUtils.ptm.createFolder(this._title, aContainer, aIndex,
                                           annotations, childItemsTransactions);
   },
 
@@ -976,16 +678,8 @@
    */
   _getCreateNewLivemarkTransaction:
   function BPP__getCreateNewLivemarkTransaction(aContainer, aIndex) {
-    var feedURIString = this._element("feedLocationTextfield").value;
-    var feedURI = PlacesUIUtils.createFixedURI(feedURIString);
-
-    var siteURIString = this._element("feedSiteLocationTextfield").value;
-    var siteURI = null;
-    if (siteURIString)
-      siteURI = PlacesUIUtils.createFixedURI(siteURIString);
-
-    var name = this._element("namePicker").value;
-    return PlacesUIUtils.ptm.createLivemark(feedURI, siteURI, name,
+    return PlacesUIUtils.ptm.createLivemark(this._feedURI, this._siteURI,
+                                            this._title,
                                             aContainer, aIndex);
   },
 
@@ -994,69 +688,26 @@
    */
   _createNewItem: function BPP__getCreateItemTransaction() {
     var [container, index] = this._getInsertionPointDetails();
-    var createTxn;
-    if (this._itemType == BOOKMARK_FOLDER)
-      createTxn = this._getCreateNewFolderTransaction(container, index);
-    else if (this._itemType == LIVEMARK_CONTAINER)
-      createTxn = this._getCreateNewLivemarkTransaction(container, index);
-    else // BOOKMARK_ITEM
-      createTxn = this._getCreateNewBookmarkTransaction(container, index);
+    var txn;
 
-    // Mark the containing folder as recently-used if it isn't in the static
-    // list
-    if (container != PlacesUtils.toolbarFolderId &&
-        container != PlacesUtils.bookmarksMenuFolderId)
-      this._markFolderAsRecentlyUsed(container);
+    switch (this._itemType) {
+      case BOOKMARK_FOLDER:
+        txn = this._getCreateNewFolderTransaction(container, index);
+        break;
+      case LIVEMARK_CONTAINER:
+        txn = this._getCreateNewLivemarkTransaction(container, index);
+        break;      
+      default: // BOOKMARK_ITEM
+        txn = this._getCreateNewBookmarkTransaction(container, index);
+    }
 
-    // perfrom our transaction do via the transaction manager passed by the
-    // opener so it can be undone.
-    window.arguments[0].performed = true;
-    PlacesUIUtils.ptm.doTransaction(createTxn);
-  },
-
-  onNamePickerInput: function BPP_onNamePickerInput() {
-    this._element("userEnteredName").label = this._element("namePicker").value;
-  },
-
-  toggleTreeVisibility: function BPP_toggleTreeVisibility() {
-    var expander = this._element("expander");
-    if (!this._folderTree.collapsed) { // if (willCollapse)
-      expander.className = "down";
-      expander.setAttribute("tooltiptext",
-                            expander.getAttribute("tooltiptextdown"));
-      document.documentElement.buttons = "accept,cancel";
-
-      this._folderTreeHeight = this._folderTree.boxObject.height;
-      this._folderTree.setAttribute("height", this._folderTreeHeight);
-      this._folderTree.collapsed = true;
-      resizeTo(window.outerWidth, window.outerHeight - this._folderTreeHeight);
-    }
-    else {
-      expander.className = "up";
-      expander.setAttribute("tooltiptext",
-                            expander.getAttribute("tooltiptextup"));
-      document.documentElement.buttons = "accept,cancel,extra2";
-
-      this._folderTree.collapsed = false;
-
-      if (!this._folderTree.place) {
-        const FOLDER_TREE_PLACE_URI =
-          "place:excludeItems=1&excludeQueries=1&excludeReadOnlyFolders=1&folder=" +
-          PlacesUIUtils.allBookmarksFolderId;
-        this._folderTree.place = FOLDER_TREE_PLACE_URI;
-      }
-
-      var currentFolder = this._getFolderIdFromMenuList();
-      this._folderTree.selectItems([currentFolder]);
-      this._folderTree.focus();
-
-      resizeTo(window.outerWidth, window.outerHeight + this._folderTreeHeight);
-    }
+    PlacesUIUtils.ptm.doTransaction(txn);
+    this._itemId = PlacesUtils.bookmarks.getIdForItemAt(container, index);
   },
 
   _getFolderIdFromMenuList:
   function BPP__getFolderIdFromMenuList() {
-    var selectedItem = this._folderMenuList.selectedItem;
+    var selectedItem = this._element("folderPicker").selectedItem;
     NS_ASSERT("folderId" in selectedItem,
               "Invalid menuitem in the folders-menulist");
     return selectedItem.folderId;
@@ -1074,7 +725,7 @@
   function BPP__getFolderMenuItem(aFolderId) {
     var menupopup = this._folderMenuList.menupopup;
 
-    for (var i=0; i < menupopup.childNodes.length; i++) {
+    for (var i = 0; i < menupopup.childNodes.length; i++) {
       if (menupopup.childNodes[i].folderId == aFolderId)
         return menupopup.childNodes[i];
     }
@@ -1084,41 +735,5 @@
       menupopup.removeChild(menupopup.lastChild);
 
     return this._appendFolderItemToMenupopup(menupopup, aFolderId);
-  },
-
-  onMenuListFolderSelect: function BPP_onMenuListFolderSelect(aEvent) {
-    if (this._folderTree.collapsed)
-      return;
-
-    this._folderTree.selectItems([this._getFolderIdFromMenuList()]);
-  },
-
-  onFolderTreeSelect: function BPP_onFolderTreeSelect() {
-    var selectedNode = this._folderTree.selectedNode;
-    if (!selectedNode)
-      return;
-
-    var folderId = PlacesUtils.getConcreteItemId(selectedNode);
-    if (this._getFolderIdFromMenuList() == folderId)
-      return;
-
-    var folderItem = this._getFolderMenuItem(folderId);
-    this._folderMenuList.selectedItem = folderItem;
-  },
-
-  _markFolderAsRecentlyUsed:
-  function BPP__markFolderAsRecentlyUsed(aFolderId) {
-    // We'll figure out when/if to expire the annotation if it turns out
-    // we keep this recently-used-folders implementation
-    PlacesUtils.annotations
-               .setItemAnnotation(aFolderId, LAST_USED_ANNO,
-                                  new Date().getTime(), 0,
-                                  Ci.nsIAnnotationService.EXPIRE_NEVER);
-  },
-
-  newFolder: function BPP_newFolder() {
-    // The command is disabled when the tree is not focused
-    this._folderTree.focus();
-    goDoCommand("placesCmd_new:folder");
   }
 };
diff -r 17e9560465b0 browser/components/places/content/bookmarkProperties.xul
--- a/browser/components/places/content/bookmarkProperties.xul	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/components/places/content/bookmarkProperties.xul	Thu Oct 30 05:41:44 2008 -0400
@@ -23,6 +23,7 @@
    -   Joe Hughes <jhughes@google.com>
    -   Asaf Romano <mano@mozilla.com>
    -   Ehsan Akhgari <ehsan.akhgari@gmail.com>
+   -   Marco Bonardo <mak77@bonardo.net>
    -
    - Alternatively, the contents of this file may be used under the terms of
    - either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -39,24 +40,22 @@
    - ***** END LICENSE BLOCK ***** -->
 
 <?xml-stylesheet href="chrome://global/skin/"?>
-<?xml-stylesheet href="chrome://browser/skin/places/bookmarkProperties.css"?>
+<?xml-stylesheet href="chrome://browser/skin/places/editBookmarkOverlay.css"?>
 <?xml-stylesheet href="chrome://browser/skin/places/places.css"?>
 <?xml-stylesheet href="chrome://browser/content/places/places.css"?>
+
 <?xul-overlay href="chrome://browser/content/places/placesOverlay.xul"?>
+<?xul-overlay href="chrome://browser/content/places/editBookmarkOverlay.xul"?>
 
 <!DOCTYPE dialog [
-  <!ENTITY % propertiesDTD SYSTEM "chrome://browser/locale/places/bookmarkProperties.dtd">
-  %propertiesDTD;
-  <!ENTITY % placesDTD SYSTEM "chrome://browser/locale/places/places.dtd">
-  %placesDTD;
+  <!ENTITY % editBookmarkOverlayDTD SYSTEM "chrome://browser/locale/places/editBookmarkOverlay.dtd">
+  %editBookmarkOverlayDTD;
 ]>
 
 <dialog id="bookmarkproperties"
         buttons="accept, cancel"
-        buttonlabelextra2="&bookmarks.newFolderButton.label;"
-        buttonaccesskeyextra2="&bookmarks.newFolderButton.accesskey;"
         ondialogaccept="BookmarkPropertiesPanel.onDialogAccept();"
-        ondialogextra2="BookmarkPropertiesPanel.newFolder();"
+        ondialogcancel="BookmarkPropertiesPanel.onDialogCancel();"
         xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
         onload="BookmarkPropertiesPanel.onDialogLoad();"
         onunload="BookmarkPropertiesPanel.onDialogUnload();"
@@ -68,103 +67,11 @@
                   src="chrome://browser/locale/places/bookmarkProperties.properties"/>
   </stringbundleset>
 
-  <script type="application/x-javascript"
+  <script type="application/javascript"
+          src="chrome://browser/content/places/editBookmarkOverlay.js"/>
+  <script type="application/javascript"
           src="chrome://browser/content/places/bookmarkProperties.js"/>
 
-  <grid id="placesInfoGrid">
-    <columns>
-      <column/>
-      <column flex="1"/>
-    </columns>
-    <rows id="placesInfoRows">
-      <row id="titleRow" align="center">
-        <label value="&bookmarks.name.label;" accesskey="&bookmarks.name.accesskey;"
-               control="namePicker"/>
-        <menulist id="namePicker"
-                  editable="true"
-                  droppable="false"
-                  oninput="BookmarkPropertiesPanel.onNamePickerInput();">
-          <menupopup>
-            <menuitem id="userEnteredName"/>
-            <menuitem disabled="true">
-              <menuseparator flex="1"/>
-              <label value="&bookmarks.liveTitlesSeparator.label;"/>
-            </menuitem>
-          </menupopup>
-        </menulist>
-      </row>
-      <row id="locationRow" align="center">
-        <label value="&bookmarks.location.label;" accesskey="&bookmarks.location.accesskey;"
-               control="editURLBar"/>
-        <textbox id="editURLBar" size="10"
-                 onchange="BookmarkPropertiesPanel.validateChanges();"
-                 oninput="BookmarkPropertiesPanel.validateChanges();"/>
-      </row>
-      <row id="livemarkFeedLocationRow" align="center">
-        <label value="&bookmarks.feed_location.label;" accesskey="&bookmarks.feed_location.accesskey;"
-               control="feedLocationTextfield"/>
-        <textbox id="feedLocationTextfield"
-                 onchange="BookmarkPropertiesPanel.validateChanges();"
-                 oninput="BookmarkPropertiesPanel.validateChanges();"/>
-      </row>
-      <row id="livemarkSiteLocationRow" align="center">
-        <label value="&bookmarks.site_location.label;" accesskey="&bookmarks.site_location.accesskey;"
-               control="feedSiteLocationTextfield"/>
-        <textbox id="feedSiteLocationTextfield"
-                 onchange="BookmarkPropertiesPanel.validateChanges();"
-                 oninput="BookmarkPropertiesPanel.validateChanges();"/>
-      </row>
-      <row id="keywordRow" align="center">
-        <label value="&bookmarks.keyword.label;" accesskey="&bookmarks.keyword.accesskey;"
-               control="keywordTextfield"/>
-        <textbox id="keywordTextfield"/>
-      </row>
-      <row id="descriptionRow">
-        <label value="&bookmarks.description.label;" accesskey="&bookmarks.description.accesskey;"
-               control="descriptionTextfield"/>
-        <textbox id="descriptionTextfield" multiline="true"/>
-      </row>
-      <row id="folderRow" align="center">
-        <label value="&bookmarks.createIn.label;" accesskey="&bookmarks.createIn.accesskey;"
-               control="folderMenuList"/>
-        <menulist id="folderMenuList"
-                  class="folder-icon"
-                  oncommand="BookmarkPropertiesPanel.onMenuListFolderSelect();">
-          <menupopup>
-            <!-- Static item for special folders -->
-            <menuitem id="bookmarksRootItem"
-                      class="menuitem-iconic folder-icon"/>
-            <menuitem id="toolbarFolderItem"
-                      class="menuitem-iconic folder-icon"/>
-            <menuseparator id="foldersSeparator" hidden="true"/>
-          </menupopup>
-        </menulist>
-        <button id="expander"
-                class="down"
-                tooltiptext="&bookmarks.expanderDown.tooltip;"
-                tooltiptextdown="&bookmarks.expanderDown.tooltip;"
-                tooltiptextup="&bookmarks.expanderUp.tooltip;"
-                oncommand="BookmarkPropertiesPanel.toggleTreeVisibility();"/>
-      </row>
-      <checkbox id="loadInSidebarCheckbox"
-                label="&bookmarks.loadInSidebar.label;"
-                accesskey="&bookmarks.loadInSidebar.accesskey;"/>
-    </rows>
-  </grid>
+<vbox id="editBookmarkPanelContent"/>
 
-  <separator class="thin"/>
-  <tree id="folderTree"
-        class="placesTree"
-        collapsed="true"
-        flex="1"
-        type="places"
-        height="150"
-        persist="height"
-        onselect="BookmarkPropertiesPanel.onFolderTreeSelect();"
-        hidecolumnpicker="true">
-    <treecols>
-      <treecol id="title" flex="1" primary="true" hideheader="true"/>
-    </treecols>
-    <treechildren id="placesListChildren" view="placesList" flex="1"/>
-  </tree>
 </dialog>
diff -r 17e9560465b0 browser/components/places/content/editBookmarkOverlay.js
--- a/browser/components/places/content/editBookmarkOverlay.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/components/places/content/editBookmarkOverlay.js	Thu Oct 30 05:41:44 2008 -0400
@@ -334,6 +334,10 @@
 
     var defaultItem = this._getFolderMenuItem(aSelectedFolder);
     this._folderMenuList.selectedItem = defaultItem;
+
+    // Set a selectedIndex attribute to show special icons
+    this._folderMenuList.setAttribute("selectedIndex",
+                                      this._folderMenuList.selectedIndex);
 
     // Hide the folders-separator if no folder is annotated as recently-used
     this._element("foldersSeparator").hidden = (menupopup.childNodes.length <= 6);
@@ -798,6 +802,9 @@
   },
 
   onFolderMenuListCommand: function EIO_onFolderMenuListCommand(aEvent) {
+    // Set a selectedIndex attribute to show special icons
+    this._folderMenuList.setAttribute("selectedIndex",
+                                      this._folderMenuList.selectedIndex);
     if (aEvent.target.id == "editBMPanel_chooseFolderMenuItem") {
       // reset the selection back to where it was and expand the tree
       // (this menu-item is hidden when the tree is already visible
diff -r 17e9560465b0 browser/components/places/content/editBookmarkOverlay.xul
--- a/browser/components/places/content/editBookmarkOverlay.xul	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/components/places/content/editBookmarkOverlay.xul	Thu Oct 30 05:41:44 2008 -0400
@@ -35,12 +35,9 @@
 #
 # ***** END LICENSE BLOCK *****
 
-<!-- XXXmano: temporary also use moveBookmarks for the "New Folder" button -->
 <!DOCTYPE overlay [
 <!ENTITY % editBookmarkOverlayDTD SYSTEM "chrome://browser/locale/places/editBookmarkOverlay.dtd">
 %editBookmarkOverlayDTD;
-<!ENTITY % moveBookmarksDTD SYSTEM "chrome://browser/locale/places/moveBookmarks.dtd">
-%moveBookmarksDTD;
 ]>
 
 <?xml-stylesheet href="chrome://browser/skin/places/editBookmarkOverlay.css"?>
@@ -121,15 +118,15 @@
                     observes="paneElementsBroadcaster">
             <menupopup>
               <!-- Static item for special folders -->
-              <menuitem id="editBMPanel_unfiledRootItem"
+              <menuitem id="editBMPanel_toolbarFolderItem"
                         class="menuitem-iconic folder-icon"/>
               <menuitem id="editBMPanel_bmRootItem"
                         class="menuitem-iconic folder-icon"/>
-              <menuitem id="editBMPanel_toolbarFolderItem"
+              <menuitem id="editBMPanel_unfiledRootItem"
                         class="menuitem-iconic folder-icon"/>
               <menuseparator id="editBMPanel_chooseFolderSeparator"/>
               <menuitem id="editBMPanel_chooseFolderMenuItem"
-	        label="&editBookmarkOverlay.choose.label;"
+                        label="&editBookmarkOverlay.choose.label;"
                         class="menuitem-iconic folder-icon"/>
               <menuseparator id="editBMPanel_foldersSeparator" hidden="true"/>
             </menupopup>
@@ -159,9 +156,9 @@
         </tree>
 
         <hbox id="editBMPanel_newFolderBox" collapsed="true">
-          <button label="&newFolderButton.label;"
+          <button label="&editBookmarkOverlay.newFolderButton.label;"
                   id="editBMPanel_newFolderButton"
-                  accesskey="&newFolderButton.accesskey;"
+                  accesskey="&editBookmarkOverlay.newFolderButton.accesskey;"
                   oncommand="gEditItemOverlay.newFolder();"/>
           <spacer flex="1"/>
         </hbox>
diff -r 17e9560465b0 browser/components/places/content/utils.js
--- a/browser/components/places/content/utils.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/components/places/content/utils.js	Thu Oct 30 05:41:44 2008 -0400
@@ -460,7 +460,7 @@
     if (aDefaultInsertionPoint) {
       info.defaultInsertionPoint = aDefaultInsertionPoint;
       if (!aShowPicker)
-        info.hiddenRows = ["folder picker"];
+        info.hiddenRows = ["folderPicker"];
     }
 
     if (aLoadInSidebar)
@@ -496,7 +496,7 @@
     var info = {
       action: "add",
       type: "bookmark",
-      hiddenRows: ["location", "description", "loadInSidebar"]
+      hiddenRows: ["description"]
     };
     if (aURI)
       info.uri = aURI;
@@ -511,14 +511,18 @@
     if (aDefaultInsertionPoint) {
       info.defaultInsertionPoint = aDefaultInsertionPoint;
       if (!aShowPicker)
-        info.hiddenRows.push("folder picker");
+        info.hiddenRows.push("folderPicker");
     }
 
     if (aLoadInSidebar)
       info.loadBookmarkInSidebar = true;
+    else
+      info.hiddenRows = info.hiddenRows.concat(["location", "loadInSidebar"]);
 
     if (typeof(aKeyword) == "string") {
       info.keyword = aKeyword;
+      // hide the Tags field if we are adding a keyword
+      info.hiddenRows.push("tags");
       if (typeof(aPostData) == "string")
         info.postData = aPostData;
       if (typeof(aCharSet) == "string")
@@ -578,7 +582,7 @@
     if (aDefaultInsertionPoint) {
       info.defaultInsertionPoint = aDefaultInsertionPoint;
       if (!aShowPicker)
-        info.hiddenRows = ["folder picker"];
+        info.hiddenRows = ["folderPicker"];
     }
     return this._showBookmarkDialog(info);
   },
@@ -598,7 +602,7 @@
     var info = {
       action: "add",
       type: "livemark",
-      hiddenRows: ["feedURI", "siteURI", "description"]
+      hiddenRows: ["feedLocation", "siteLocation", "description"]
     };
 
     if (aFeedURI)
@@ -616,7 +620,7 @@
     if (aDefaultInsertionPoint) {
       info.defaultInsertionPoint = aDefaultInsertionPoint;
       if (!aShowPicker)
-        info.hiddenRows.push("folder picker");
+        info.hiddenRows.push("folderPicker");
     }
     this._showBookmarkDialog(info, true);
   },
@@ -689,7 +693,7 @@
     if (aDefaultInsertionPoint) {
       info.defaultInsertionPoint = aDefaultInsertionPoint;
       if (!aShowPicker)
-        info.hiddenRows.push("folder picker");
+        info.hiddenRows.push("folderPicker");
     }
     return this._showBookmarkDialog(info);
   },
@@ -704,11 +708,7 @@
    *        [optional] if true, the dialog is opened by its alternative
    *        chrome: uri.
    *
-   * Note: In minimal UI mode, we open the dialog non-modal on any system but
-   *       Mac OS X.
    * @return true if any transaction has been performed, false otherwise.
-   * Note: the return value of this method is not reliable in minimal UI mode
-   * since the dialog may not be opened modally.
    */
   _showBookmarkDialog: function PU__showBookmarkDialog(aInfo, aMinimalUI) {
     var dialogURL = aMinimalUI ?
@@ -717,11 +717,7 @@
 
     var features;
     if (aMinimalUI)
-#ifdef XP_MACOSX
       features = "centerscreen,chrome,dialog,resizable,modal";
-#else
-      features = "centerscreen,chrome,dialog,resizable,dependent";
-#endif
     else
       features = "centerscreen,chrome,modal,resizable=no";
     window.openDialog(dialogURL, "",  features, aInfo);
diff -r 17e9560465b0 browser/components/places/src/nsPlacesImportExportService.cpp
--- a/browser/components/places/src/nsPlacesImportExportService.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/components/places/src/nsPlacesImportExportService.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -241,62 +241,67 @@
 char *
 nsEscapeHTML(const char * string)
 {
-	/* XXX Hardcoded max entity len. The +1 is for the trailing null. */
-	char *rv = (char *) nsMemory::Alloc(strlen(string) * 6 + 1);
-	char *ptr = rv;
+    /* XXX Hardcoded max entity len. The +1 is for the trailing null. */
+    char *rv = nsnull;
+    PRUint32 len = strlen(string);
+    if (len >= (PR_UINT32_MAX / 6))
+      return nsnull;
 
-	if(rv)
-	  {
-		for(; *string != '\0'; string++)
-		  {
-			if(*string == '<')
-			  {
-				*ptr++ = '&';
-				*ptr++ = 'l';
-				*ptr++ = 't';
-				*ptr++ = ';';
-			  }
-			else if(*string == '>')
-			  {
-				*ptr++ = '&';
-				*ptr++ = 'g';
-				*ptr++ = 't';
-				*ptr++ = ';';
-			  }
-			else if(*string == '&')
-			  {
-				*ptr++ = '&';
-				*ptr++ = 'a';
-				*ptr++ = 'm';
-				*ptr++ = 'p';
-				*ptr++ = ';';
-			  }
-			else if (*string == '"')
-			  {
-				*ptr++ = '&';
-				*ptr++ = 'q';
-				*ptr++ = 'u';
-				*ptr++ = 'o';
-				*ptr++ = 't';
-				*ptr++ = ';';
-			  }			
-			else if (*string == '\'')
-			  {
-				*ptr++ = '&';
-				*ptr++ = '#';
-				*ptr++ = '3';
-				*ptr++ = '9';
-				*ptr++ = ';';
-			  }
-			else
-			  {
-				*ptr++ = *string;
-			  }
-		  }
-		*ptr = '\0';
-	  }
+    rv = (char *) NS_Alloc((len * 6) + 1);
+    char *ptr = rv;
 
-	return(rv);
+    if(rv)
+      {
+        for(; *string != '\0'; string++)
+          {
+            if(*string == '<')
+              {
+                *ptr++ = '&';
+                *ptr++ = 'l';
+                *ptr++ = 't';
+                *ptr++ = ';';
+              }
+            else if(*string == '>')
+              {
+                *ptr++ = '&';
+                *ptr++ = 'g';
+                *ptr++ = 't';
+                *ptr++ = ';';
+              }
+            else if(*string == '&')
+              {
+                *ptr++ = '&';
+                *ptr++ = 'a';
+                *ptr++ = 'm';
+                *ptr++ = 'p';
+                *ptr++ = ';';
+              }
+            else if (*string == '"')
+              {
+                *ptr++ = '&';
+                *ptr++ = 'q';
+                *ptr++ = 'u';
+                *ptr++ = 'o';
+                *ptr++ = 't';
+                *ptr++ = ';';
+              }            
+            else if (*string == '\'')
+              {
+                *ptr++ = '&';
+                *ptr++ = '#';
+                *ptr++ = '3';
+                *ptr++ = '9';
+                *ptr++ = ';';
+              }
+            else
+              {
+                *ptr++ = *string;
+              }
+          }
+        *ptr = '\0';
+      }
+
+    return(rv);
 }
 
 NS_IMPL_ISUPPORTS2(nsPlacesImportExportService, nsIPlacesImportExportService,
diff -r 17e9560465b0 browser/components/preferences/sanitize.xul
--- a/browser/components/preferences/sanitize.xul	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/components/preferences/sanitize.xul	Thu Oct 30 05:41:44 2008 -0400
@@ -92,8 +92,8 @@
     <checkbox label="&itemPasswords.label;"
               accesskey="&itemPasswords.accesskey;"
               preference="privacy.item.passwords"/>
-    <checkbox label="&itemSessions.label;"
-              accesskey="&itemSessions.accesskey;"
+    <checkbox label="&itemActiveLogins.label;"
+              accesskey="&itemActiveLogins.accesskey;"
               preference="privacy.item.sessions"/>
 
   </prefpane>
diff -r 17e9560465b0 browser/components/safebrowsing/content/globalstore.js
--- a/browser/components/safebrowsing/content/globalstore.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/components/safebrowsing/content/globalstore.js	Thu Oct 30 05:41:44 2008 -0400
@@ -113,6 +113,8 @@
   this.reportGenericURL_ = this.getUrlPref_(basePref + "reportGenericURL");
   this.reportErrorURL_ = this.getUrlPref_(basePref + "reportErrorURL");
   this.reportPhishURL_ = this.getUrlPref_(basePref + "reportPhishURL");
+  this.reportMalwareURL_ = this.getUrlPref_(basePref + "reportMalwareURL")
+  this.reportMalwareErrorURL_ = this.getUrlPref_(basePref + "reportMalwareErrorURL")
 
   // Propagate the changes to the list-manager.
   this.updateListManager_();
@@ -220,3 +222,9 @@
 PROT_DataProvider.prototype.getReportPhishURL = function() {
   return this.reportPhishURL_;
 }
+PROT_DataProvider.prototype.getReportMalwareURL = function() {
+  return this.reportMalwareURL_;
+}
+PROT_DataProvider.prototype.getReportMalwareErrorURL = function() {
+  return this.reportMalwareErrorURL_;
+}
diff -r 17e9560465b0 browser/components/safebrowsing/content/sb-loader.js
--- a/browser/components/safebrowsing/content/sb-loader.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/components/safebrowsing/content/sb-loader.js	Thu Oct 30 05:41:44 2008 -0400
@@ -85,7 +85,7 @@
 
   /**
    * Used to report a phishing page or a false positive
-   * @param name String either "Phish" or "Error"
+   * @param name String One of "Phish", "Error", "Malware" or "MalwareError"
    * @return String the report phishing URL.
    */
   getReportURL: function(name) {
diff -r 17e9560465b0 browser/components/sessionstore/content/aboutSessionRestore.js
--- a/browser/components/sessionstore/content/aboutSessionRestore.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/components/sessionstore/content/aboutSessionRestore.js	Thu Oct 30 05:41:44 2008 -0400
@@ -115,21 +115,24 @@
   }
   var stateString = gStateObject.toSource();
   
+  var ss = Cc["@mozilla.org/browser/sessionstore;1"].getService(Ci.nsISessionStore);
+  var top = getBrowserWindow();
+  
+  // if there's only this page open, reuse the window for restoring the session
+  if (top.gBrowser.tabContainer.childNodes.length == 1) {
+    ss.setWindowState(top, stateString, true);
+    return;
+  }
+  
   // restore the session into a new window and close the current tab
-  var top = getBrowserWindow();
-  var selfBrowser = top.gBrowser.getBrowserForDocument(document);
   var newWindow = top.openDialog(top.location, "_blank", "chrome,dialog=no,all");
   newWindow.addEventListener("load", function() {
     newWindow.removeEventListener("load", arguments.callee, true);
-    
-    var ss = Cc["@mozilla.org/browser/sessionstore;1"].getService(Ci.nsISessionStore);
     ss.setWindowState(newWindow, stateString, true);
     
     var tabbrowser = top.gBrowser;
-    if (tabbrowser.tabContainer.childNodes.length == 1)
-      top.close();
-    else
-      tabbrowser.removeTab(getTabForBrowser(selfBrowser));
+    var tabIndex = tabbrowser.getBrowserIndexForDocument(document);
+    tabbrowser.removeTab(tabbrowser.tabContainer.childNodes[tabIndex]);
   }, true);
 }
 
@@ -183,11 +186,6 @@
   return window.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIWebNavigation)
                .QueryInterface(Ci.nsIDocShellTreeItem).rootTreeItem
                .QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindow);
-}
-
-function getTabForBrowser(aBrowser) {
-  return Array.filter(getBrowserWindow().gBrowser.tabContainer.childNodes,
-                      function(aTab) aTab.linkedBrowser == aBrowser)[0];
 }
 
 function toggleRowChecked(aIx) {
diff -r 17e9560465b0 browser/components/sessionstore/content/aboutSessionRestore.xhtml
--- a/browser/components/sessionstore/content/aboutSessionRestore.xhtml	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/components/sessionstore/content/aboutSessionRestore.xhtml	Thu Oct 30 05:41:44 2008 -0400
@@ -49,7 +49,7 @@
 
 <html xmlns="http://www.w3.org/1999/xhtml">
   <head>
-    <title>&restorepage.title;</title>
+    <title>&restorepage.tabtitle;</title>
     <link rel="stylesheet" href="chrome://global/skin/netError.css" type="text/css" media="all"/>
     <link rel="stylesheet" href="chrome://browser/skin/aboutSessionRestore.css" type="text/css" media="all"/>
     <link rel="icon" type="image/png" href="chrome://global/skin/icons/question-16.png"/>
@@ -64,7 +64,7 @@
     
       <!-- Error Title -->
       <div id="errorTitle">
-        <h1 id="errorTitleText">&restorepage.titletext;</h1>
+        <h1 id="errorTitleText">&restorepage.pagetitle;</h1>
       </div>
       
       <!-- LONG CONTENT (the section most likely to require scrolling) -->
@@ -72,7 +72,7 @@
       
         <!-- Short Description -->
         <div id="errorShortDesc">
-          <p id="errorShortDescText">&restorepage.shortDesc;</p>
+          <p id="errorShortDescText">&restorepage.issueDesc;</p>
         </div>
 
         <!-- Long Description (Note: See netError.dtd for used XHTML tags) -->
@@ -102,12 +102,21 @@
 
       <!-- Buttons -->
       <hbox xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul" id="buttons">
+#ifdef XP_UNIX
+        <button id="errorCancel" label="&restorepage.cancelButton;"
+                accesskey="&restorepage.cancel.access;"
+                oncommand="startNewSession();"/>
+        <button id="errorTryAgain" label="&restorepage.restoreButton;"
+                accesskey="&restorepage.restore.access;"
+                oncommand="restoreSession();"/>
+#else
         <button id="errorTryAgain" label="&restorepage.restoreButton;"
                 accesskey="&restorepage.restore.access;"
                 oncommand="restoreSession();"/>
         <button id="errorCancel" label="&restorepage.cancelButton;"
                 accesskey="&restorepage.cancel.access;"
                 oncommand="startNewSession();"/>
+#endif
       </hbox>
       <!-- holds the session data for when the tab is closed -->
       <input type="text" id="sessionData" style="display: none;"/>
diff -r 17e9560465b0 browser/components/sessionstore/src/nsSessionStore.js
--- a/browser/components/sessionstore/src/nsSessionStore.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/components/sessionstore/src/nsSessionStore.js	Thu Oct 30 05:41:44 2008 -0400
@@ -213,16 +213,10 @@
         // parse the session state into JS objects
         this._initialState = this._safeEval(iniString);
         
-        // if last session crashed, backup the session
         let lastSessionCrashed =
           this._initialState.session && this._initialState.session.state &&
           this._initialState.session.state == STATE_RUNNING_STR;
         if (lastSessionCrashed) {
-          try {
-            this._writeFile(this._sessionFileBackup, iniString);
-          }
-          catch (ex) { } // nothing else we can do here
-          
           this._recentCrashes = (this._initialState.session &&
                                  this._initialState.session.recentCrashes || 0) + 1;
           
@@ -241,7 +235,16 @@
     // remove the session data files if crash recovery is disabled
     if (!this._resume_from_crash)
       this._clearDisk();
-    
+    else { // create a backup if the session data file exists
+      try {
+        if (this._sessionFileBackup.exists())
+          this._sessionFileBackup.remove(false);
+        if (this._sessionFile.exists())
+          this._sessionFile.copyTo(null, this._sessionFileBackup.leafName);
+      }
+      catch (ex) { Cu.reportError(ex); } // file was write-locked?
+    }
+
     // at this point, we've as good as resumed the session, so we can
     // clear the resume_session_once flag, if it's set
     if (this._loadState != STATE_QUITTING &&
@@ -1488,16 +1491,6 @@
    *        bool this isn't the restoration of the first window
    */
   restoreWindow: function sss_restoreWindow(aWindow, aState, aOverwriteTabs, aFollowUp) {
-    if (this._restoreCount) {
-      this._restoreCount--;
-      if (this._restoreCount == 0) {
-        // This was the last window restored at startup, notify observers.
-        var observerService = Cc["@mozilla.org/observer-service;1"].
-                              getService(Ci.nsIObserverService);
-        observerService.notifyObservers(null, NOTIFY_WINDOWS_RESTORED, "");
-      }
-    }
-
     if (!aFollowUp) {
       this.windowToFocus = aWindow;
     }
@@ -1508,11 +1501,13 @@
     try {
       var root = typeof aState == "string" ? this._safeEval(aState) : aState;
       if (!root.windows[0]) {
+        this._notifyIfAllWindowsRestored();
         return; // nothing to restore
       }
     }
     catch (ex) { // invalid state object - don't restore anything 
       debug(ex);
+      this._notifyIfAllWindowsRestored();
       return;
     }
     
@@ -1579,6 +1574,8 @@
     
     this.restoreHistoryPrecursor(aWindow, winData.tabs, (aOverwriteTabs ?
       (parseInt(winData.selected) || 1) : 0), 0, 0);
+
+    this._notifyIfAllWindowsRestored();
   },
 
   /**
@@ -2350,6 +2347,11 @@
         winData[0].tabs[0].entries[0].url == "about:sessionrestore")
       return false;
     
+    // don't automatically restore in Safe Mode
+    let XRE = Cc["@mozilla.org/xre/app-info;1"].getService(Ci.nsIXULRuntime);
+    if (XRE.inSafeMode)
+      return true;
+    
     let max_resumed_crashes =
       this._prefBranch.getIntPref("sessionstore.max_resumed_crashes");
     let sessionAge = aState.session && aState.session.lastUpdate &&
@@ -2385,6 +2387,18 @@
       throw new Error("JSON conversion failed unexpectedly!");
     
     return str;
+  },
+
+  _notifyIfAllWindowsRestored: function sss_notifyIfAllWindowsRestored() {
+    if (this._restoreCount) {
+      this._restoreCount--;
+      if (this._restoreCount == 0) {
+        // This was the last window restored at startup, notify observers.
+        var observerService = Cc["@mozilla.org/observer-service;1"].
+                              getService(Ci.nsIObserverService);
+        observerService.notifyObservers(null, NOTIFY_WINDOWS_RESTORED, "");
+      }
+    }
   },
 
 /* ........ Storage API .............. */
diff -r 17e9560465b0 browser/installer/unix/packages-static
--- a/browser/installer/unix/packages-static	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/installer/unix/packages-static	Thu Oct 30 05:41:44 2008 -0400
@@ -236,6 +236,7 @@
 bin/components/txEXSLTRegExFunctions.js
 bin/components/nsLivemarkService.js
 bin/components/nsTaggingService.js
+bin/components/nsPlacesDBFlush.js
 bin/components/nsDefaultCLH.js
 bin/components/nsContentPrefService.js
 bin/components/nsContentDispatchChooser.js
@@ -243,6 +244,7 @@
 bin/components/nsWebHandlerApp.js
 bin/components/libdbusservice.so
 bin/components/aboutRobots.js
+bin/components/aboutCertError.js
 bin/components/nsBadCertHandler.js
 
 ; Modules
diff -r 17e9560465b0 browser/installer/windows/Makefile.in
--- a/browser/installer/windows/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/installer/windows/Makefile.in	Thu Oct 30 05:41:44 2008 -0400
@@ -68,8 +68,8 @@
 
 DEFINES += \
 	-DAB_CD=$(AB_CD) \
-	-DPKG_BASENAME=$(PKG_BASENAME) \
-	-DPKG_INST_BASENAME=$(PKG_INST_BASENAME) \
+	-DPKG_BASENAME="$(PKG_BASENAME)" \
+	-DPKG_INST_BASENAME="$(PKG_INST_BASENAME)" \
 	-DMOZ_APP_VERSION=$(MOZ_APP_VERSION) \
 	-DMOZ_APP_NAME=$(MOZ_APP_NAME) \
 	-DMOZ_APP_DISPLAYNAME=${MOZ_APP_DISPLAYNAME} \
diff -r 17e9560465b0 browser/installer/windows/packages-static
--- a/browser/installer/windows/packages-static	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/installer/windows/packages-static	Thu Oct 30 05:41:44 2008 -0400
@@ -243,12 +243,14 @@
 bin\components\txEXSLTRegExFunctions.js
 bin\components\nsLivemarkService.js
 bin\components\nsTaggingService.js
+bin\components\nsPlacesDBFlush.js
 bin\components\nsDefaultCLH.js
 bin\components\nsContentPrefService.js
 bin\components\nsContentDispatchChooser.js
 bin\components\nsHandlerService.js
 bin\components\nsWebHandlerApp.js
 bin\components\aboutRobots.js
+bin\components\aboutCertError.js
 bin\components\nsBadCertHandler.js
 
 ; Modules
diff -r 17e9560465b0 browser/locales/Makefile.in
--- a/browser/locales/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/locales/Makefile.in	Thu Oct 30 05:41:44 2008 -0400
@@ -374,8 +374,8 @@
 	@echo "Downloaded $(EN_US_BINARY_URL)/$(PACKAGE) to $(_ABS_DIST)/$(PACKAGE)"
 ifeq ($(OS_ARCH), WINNT)
 	$(NSINSTALL) -D $(_ABS_DIST)/$(PKG_INST_PATH)
-	(cd $(_ABS_DIST) && $(WGET) -nv -N "$(EN_US_BINARY_URL)/$(PKG_PATH)$(PKG_INST_BASENAME).exe")
-	@echo "Downloaded $(EN_US_BINARY_URL)/$(PKG_PATH)$(PKG_INST_BASENAME).exe to $(_ABS_DIST)/$(PKG_INST_PATH)$(PKG_INST_BASENAME)"
+	(cd $(_ABS_DIST)/$(PKG_INST_PATH) && $(WGET) -nv -N "$(EN_US_BINARY_URL)/$(PKG_PATH)$(PKG_INST_BASENAME).exe")
+	@echo "Downloaded $(EN_US_BINARY_URL)/$(PKG_PATH)$(PKG_INST_BASENAME).exe to $(_ABS_DIST)/$(PKG_INST_PATH)$(PKG_INST_BASENAME).exe"
 endif
 
 ident:
diff -r 17e9560465b0 browser/locales/all-locales
--- a/browser/locales/all-locales	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/locales/all-locales	Thu Oct 30 05:41:44 2008 -0400
@@ -3,6 +3,7 @@
 as
 be
 bg
+bn-IN
 ca
 cs
 cy
@@ -34,7 +35,9 @@
 ko
 ku
 lt
+lv
 mk
+ml
 mn
 mr
 nb-NO
diff -r 17e9560465b0 browser/locales/en-US/chrome/browser/aboutCertError.dtd
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/locales/en-US/chrome/browser/aboutCertError.dtd	Thu Oct 30 05:41:44 2008 -0400
@@ -0,0 +1,36 @@
+<!ENTITY % brandDTD
+    SYSTEM "chrome://branding/locale/brand.dtd">
+  %brandDTD;
+
+<!-- These strings are used by Firefox's custom about:certerror page,
+a replacement for the standard security certificate errors produced
+by NSS/PSM via netError.xhtml. -->
+
+<!ENTITY certerror.pagetitle  "Untrusted Connection">
+<!ENTITY certerror.longpagetitle "This Connection is Untrusted">
+
+<!-- Localization note (certerror.introPara1) - The string "#1" will
+be replaced at runtime with the name of the server to which the user
+was trying to connect. -->
+<!ENTITY certerror.introPara1 "You have asked &brandShortName; to connect
+securely to <b>#1</b>, but we can't confirm that your connection is secure.">
+<!ENTITY certerror.introPara2 "Normally, when you try to connect securely,
+sites will present trusted identification to prove that you are
+going to the right place. However, this site's identity can't be verified.">
+
+<!ENTITY certerror.whatShouldIDo.heading "What Should I Do?">
+<!ENTITY certerror.whatShouldIDo.content "If you usually connect to
+this site without problems, this error could mean that someone is
+trying to impersonate the site, and you shouldn't continue.">
+<!ENTITY certerror.getMeOutOfHere.label "Get me out of here!">
+
+<!ENTITY certerror.expert.heading "I Understand the Risks">
+<!ENTITY certerror.expert.content "If you understand what's going on, you
+can tell &brandShortName; to start trusting this site's identification.
+<b>Even if you trust the site, this error could mean that someone is
+tampering with your connection.</b>">
+<!ENTITY certerror.expert.contentPara2 "Don't add an exception unless
+you know there's a good reason why this site doesn't use trusted identification.">
+<!ENTITY certerror.addException.label "Add Exception">
+
+<!ENTITY certerror.technical.heading "Technical Details">
diff -r 17e9560465b0 browser/locales/en-US/chrome/browser/aboutSessionRestore.dtd
--- a/browser/locales/en-US/chrome/browser/aboutSessionRestore.dtd	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/locales/en-US/chrome/browser/aboutSessionRestore.dtd	Thu Oct 30 05:41:44 2008 -0400
@@ -1,9 +1,11 @@
-<!ENTITY restorepage.title          "Restore Previous Session">
-<!ENTITY restorepage.titletext      "Your Last &brandShortName; Session Closed Unexpectedly">
-<!ENTITY restorepage.shortDesc      "You can restore the tabs and windows from your previous session, or start a new session if they are no longer needed. Our apologies for the inconvenience.">
+<!ENTITY restorepage.tabtitle       "Restore Session">
+<!ENTITY restorepage.pagetitle      "Would You Like to Restore Your Session?">
+<!-- LOCALIZATION NOTE: If "closed unexpectedly" sounds too awkward in the translation,
+                        you may translate "crash" instead (even though it's IT-speak) -->
+<!ENTITY restorepage.issueDesc      "Your previous &brandShortName; session closed unexpectedly. We sincerely apologize for the inconvenience. You can restore the tabs and windows from your previous session, or start a new session if they are no longer needed.">
 <!ENTITY restorepage.remedies       "If &brandShortName; closes repeatedly:">
 <!ENTITY restorepage.dueToChrome    "Try disabling any recently added extensions in the Add-ons Manager.">
-<!ENTITY restorepage.dueToContent   "Try restoring your session without any Web pages you suspect might be causing the crash:">
+<!ENTITY restorepage.dueToContent   "Try restoring your session without any Web pages you suspect might be causing the problem:">
 
 <!ENTITY restorepage.restoreButton  "Restore Previous Session">
 <!ENTITY restorepage.restore.access "R">
@@ -12,5 +14,5 @@
 
 <!ENTITY restorepage.restoreHeader  "Restore">
 <!ENTITY restorepage.listHeader     "Windows and Tabs">
-<!-- LOCALIZATION NOTE: %S will be replaced with a number. -->
-<!ENTITY restorepage.windowLabel    "Window #&#37;S">
+<!-- LOCALIZATION NOTE: &#37;S will be replaced with a number. -->
+<!ENTITY restorepage.windowLabel    "Window &#37;S">
diff -r 17e9560465b0 browser/locales/en-US/chrome/browser/browser.dtd
--- a/browser/locales/en-US/chrome/browser/browser.dtd	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/locales/en-US/chrome/browser/browser.dtd	Thu Oct 30 05:41:44 2008 -0400
@@ -233,10 +233,12 @@
 <!ENTITY viewPageInfoCmd.accesskey    "I">
 <!ENTITY viewFrameInfoCmd.label       "View Frame Info">
 <!ENTITY viewFrameInfoCmd.accesskey   "I">
-<!ENTITY showImageCmd.label           "Show Image">
-<!ENTITY showImageCmd.accesskey       "S">
+<!ENTITY reloadImageCmd.label         "Reload Image">
+<!ENTITY reloadImageCmd.accesskey     "R">
 <!ENTITY viewImageCmd.label           "View Image">
 <!ENTITY viewImageCmd.accesskey       "I">
+<!ENTITY viewVideoCmd.label           "View Video">
+<!ENTITY viewVideoCmd.accesskey       "I">
 <!ENTITY viewBGImageCmd.label         "View Background Image">
 <!ENTITY viewBGImageCmd.accesskey     "w">
 <!ENTITY setDesktopBackgroundCmd.label      "Set As Desktop Background">
diff -r 17e9560465b0 browser/locales/en-US/chrome/browser/browser.properties
--- a/browser/locales/en-US/chrome/browser/browser.properties	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/locales/en-US/chrome/browser/browser.properties	Thu Oct 30 05:41:44 2008 -0400
@@ -148,3 +148,16 @@
 geolocation.nothingLocation=Nothing
 geolocation.nothingLocationKey=o
 geolocation.requestMessage=%S wants to know where you are.  Tell them:
+
+# Phishing/Malware Notification Bar.
+# LOCALIZATION NOTE (notAForgery, notAnAttack)
+# The two button strings will never be shown at the same time, so
+# it's okay for them to have the same access key
+safebrowsing.getMeOutOfHereButton.label=Get me out of here!
+safebrowsing.getMeOutOfHereButton.accessKey=G
+safebrowsing.reportedWebForgery=Reported Web Forgery!
+safebrowsing.notAForgeryButton.label=This isn't a web forgery
+safebrowsing.notAForgeryButton.accessKey=F
+safebrowsing.reportedAttackSite=Reported Attack Site!
+safebrowsing.notAnAttackButton.label=This isn't an attack site
+safebrowsing.notAnAttackButton.accessKey=A
diff -r 17e9560465b0 browser/locales/en-US/chrome/browser/places/bookmarkProperties.dtd
--- a/browser/locales/en-US/chrome/browser/places/bookmarkProperties.dtd	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,21 +0,0 @@
-<!ENTITY bookmarks.name.label                 "Name:">
-<!ENTITY bookmarks.name.accesskey             "N">
-<!ENTITY bookmarks.location.label             "Location:">
-<!ENTITY bookmarks.location.accesskey         "L">
-<!ENTITY bookmarks.keyword.label              "Keyword:">
-<!ENTITY bookmarks.keyword.accesskey          "K">
-<!ENTITY bookmarks.description.label          "Description:">
-<!ENTITY bookmarks.description.accesskey      "D">
-<!ENTITY bookmarks.liveTitlesSeparator.label  "Live Titles">
-<!ENTITY bookmarks.createIn.label             "Create in:">
-<!ENTITY bookmarks.createIn.accesskey         "C">
-<!ENTITY bookmarks.feed_location.label        "Feed Location:">
-<!ENTITY bookmarks.feed_location.accesskey    "F">
-<!ENTITY bookmarks.site_location.label        "Site Location:">
-<!ENTITY bookmarks.site_location.accesskey    "S">
-<!ENTITY bookmarks.loadInSidebar.label        "Load this bookmark in the sidebar">
-<!ENTITY bookmarks.loadInSidebar.accesskey    "o">
-<!ENTITY bookmarks.expanderDown.tooltip       "Show all the bookmarks folders">
-<!ENTITY bookmarks.expanderUp.tooltip         "Hide">
-<!ENTITY bookmarks.newFolderButton.label      "New Folder">
-<!ENTITY bookmarks.newFolderButton.accesskey  "e">
diff -r 17e9560465b0 browser/locales/en-US/chrome/browser/places/bookmarkProperties.properties
--- a/browser/locales/en-US/chrome/browser/places/bookmarkProperties.properties	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/locales/en-US/chrome/browser/places/bookmarkProperties.properties	Thu Oct 30 05:41:44 2008 -0400
@@ -1,10 +1,12 @@
 dialogAcceptLabelAddItem=Add
+dialogAcceptLabelSaveItem=Save
+dialogAcceptLabelAddLivemark=Subscribe
 dialogAcceptLabelAddMulti=Add Bookmarks
-dialogAcceptLabelEdit=Save Changes
-dialogTitleAddBookmark=Add Bookmark
-dialogTitleAddLivemark=Add Live Bookmark
-dialogTitleAddFolder=Add Folder
-dialogTitleAddMulti=Bookmark All Tabs
+dialogAcceptLabelEdit=Save
+dialogTitleAddBookmark=New Bookmark
+dialogTitleAddLivemark=Subscribe to Live Bookmark
+dialogTitleAddFolder=New Folder
+dialogTitleAddMulti=New Bookmarks
 dialogTitleEdit=Properties for "%S"
 
 bookmarkAllTabsDefault=[Folder Name]
diff -r 17e9560465b0 browser/locales/en-US/chrome/browser/places/editBookmarkOverlay.dtd
--- a/browser/locales/en-US/chrome/browser/places/editBookmarkOverlay.dtd	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/locales/en-US/chrome/browser/places/editBookmarkOverlay.dtd	Thu Oct 30 05:41:44 2008 -0400
@@ -21,3 +21,5 @@
 <!ENTITY editBookmarkOverlay.loadInSidebar.label             "Load this bookmark in the sidebar">
 <!ENTITY editBookmarkOverlay.loadInSidebar.accesskey         "h">
 <!ENTITY editBookmarkOverlay.choose.label                    "Choose">
+<!ENTITY editBookmarkOverlay.newFolderButton.label           "New Folder">
+<!ENTITY editBookmarkOverlay.newFolderButton.accesskey       "N">
diff -r 17e9560465b0 browser/locales/en-US/chrome/browser/sanitize.dtd
--- a/browser/locales/en-US/chrome/browser/sanitize.dtd	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/locales/en-US/chrome/browser/sanitize.dtd	Thu Oct 30 05:41:44 2008 -0400
@@ -19,6 +19,6 @@
 <!ENTITY itemOfflineApps.accesskey    "O">
 <!ENTITY itemDownloads.label          "Download History">
 <!ENTITY itemDownloads.accesskey      "D">
-<!ENTITY itemSessions.label           "Authenticated Sessions">
-<!ENTITY itemSessions.accesskey       "S">
+<!ENTITY itemActiveLogins.label       "Active Logins">
+<!ENTITY itemActiveLogins.accesskey   "L">
 <!ENTITY window.width                 "30em">
diff -r 17e9560465b0 browser/locales/en-US/profile/chrome/userChrome-example.css
--- a/browser/locales/en-US/profile/chrome/userChrome-example.css	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/locales/en-US/profile/chrome/userChrome-example.css	Thu Oct 30 05:41:44 2008 -0400
@@ -41,14 +41,6 @@
  */
 
 /*
- * Eliminate the throbber and its annoying movement:
- *
- * #throbber-box {
- *   display: none !important;
- * }
- */
-
-/*
  * For more examples see http://www.mozilla.org/unix/customizing.html
  */
  
diff -r 17e9560465b0 browser/locales/jar.mn
--- a/browser/locales/jar.mn	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/locales/jar.mn	Thu Oct 30 05:41:44 2008 -0400
@@ -2,6 +2,7 @@
 
 @AB_CD@.jar:
 % locale browser @AB_CD@ %locale/browser/
+    locale/browser/aboutCertError.dtd              (%chrome/browser/aboutCertError.dtd)
     locale/browser/aboutDialog.dtd                 (%chrome/browser/aboutDialog.dtd)
     locale/browser/aboutRobots.dtd                 (%chrome/browser/aboutRobots.dtd)
     locale/browser/aboutSessionRestore.dtd         (%chrome/browser/aboutSessionRestore.dtd)
@@ -30,7 +31,6 @@
     locale/browser/places/places.dtd               (%chrome/browser/places/places.dtd)
     locale/browser/places/places.properties        (%chrome/browser/places/places.properties)
     locale/browser/places/editBookmarkOverlay.dtd  (%chrome/browser/places/editBookmarkOverlay.dtd)
-    locale/browser/places/bookmarkProperties.dtd   (%chrome/browser/places/bookmarkProperties.dtd)
     locale/browser/places/bookmarkProperties.properties (%chrome/browser/places/bookmarkProperties.properties)
     locale/browser/preferences/selectBookmark.dtd  (%chrome/browser/preferences/selectBookmark.dtd)
     locale/browser/places/moveBookmarks.dtd        (%chrome/browser/places/moveBookmarks.dtd)
diff -r 17e9560465b0 browser/themes/gnomestripe/browser/aboutCertError.css
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/themes/gnomestripe/browser/aboutCertError.css	Thu Oct 30 05:41:44 2008 -0400
@@ -0,0 +1,95 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   William Price <bugzilla@mob.rice.edu>
+ *   Steven Garrity <steven@silverorange.com>
+ *   Henrik Skupin  <mozilla@hskupin.info>
+ *   Johnathan Nightingale <johnath@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+
+html {
+  background: -moz-Dialog;
+}
+
+body {
+  margin: 0;
+  padding: 0 1em;
+  color: -moz-FieldText;
+  font: message-box;
+}
+
+h1 {
+  margin: 0 0 .6em 0;
+  border-bottom: 1px solid ThreeDLightShadow;
+  font-size: 160%;
+}
+
+h2 {
+  font-size: 130%;
+}
+
+#errorPageContainer {
+  position: relative;
+  min-width: 13em;
+  max-width: 52em;
+  margin: 4em auto;
+  border: 1px solid #FFBD09; /* pale yellow extracted from yellow passport icon */
+  -moz-border-radius: 10px;
+  padding: 3em;
+  -moz-padding-start: 30px;
+  background: url("chrome://global/skin/icons/sslWarning.png") left 0 no-repeat -moz-Field;
+  -moz-background-origin: content;
+}
+
+body[dir="rtl"] #errorPageContainer {
+  background-position: right 0;
+}
+
+#errorTitle {
+  -moz-margin-start: 80px;
+}
+
+#errorLongContent {
+  -moz-margin-start: 80px;
+}
+
+#technicalContent > h2, #expertContent > h2 {
+  background : url("chrome://browser/skin/section_expanded.png") left 0 no-repeat;
+}
+
+#technicalContent[collapsed] > h2,
+#expertContent[collapsed] > h2{
+  background-image: url("chrome://browser/skin/section_collapsed.png");
+}
diff -r 17e9560465b0 browser/themes/gnomestripe/browser/aboutSessionRestore.css
--- a/browser/themes/gnomestripe/browser/aboutSessionRestore.css	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/themes/gnomestripe/browser/aboutSessionRestore.css	Thu Oct 30 05:41:44 2008 -0400
@@ -75,8 +75,7 @@
 }
 
 #buttons {
-  width: 100%;
-  -moz-box-direction: reverse;
+  -moz-margin-start: 80px; /* same as #errorLongContent in netError.css */
 }
 #buttons > button {
   margin-top: 2em;
diff -r 17e9560465b0 browser/themes/gnomestripe/browser/browser.css
--- a/browser/themes/gnomestripe/browser/browser.css	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/themes/gnomestripe/browser/browser.css	Thu Oct 30 05:41:44 2008 -0400
@@ -137,19 +137,6 @@
 
 .bookmark-item > .menu-iconic-left > .menu-iconic-icon {
   -moz-padding-start: 0px;
-}
-
-/* Bookmark panel dropdown menu items */
-#editBMPanel_toolbarFolderItem {
-  list-style-image: url("chrome://browser/skin/places/bookmarksToolbar.png") !important;  
-}
-
-#editBMPanel_bmRootItem {
-  list-style-image: url("chrome://browser/skin/places/bookmarksMenu.png") !important;  
-}
-
-#editBMPanel_unfiledRootItem {
-  list-style-image: url("chrome://browser/skin/places/unsortedBookmarks.png") !important;  
 }
 
 /* Bookmark drag and drop styles */
@@ -1156,13 +1143,9 @@
 
 /* Throbber */
 #navigator-throbber {
-  -moz-appearance: none;
-  -moz-user-focus: ignore;
-  margin: 0 !important;
-  border: none !important;
-  padding: 0px !important;
-  min-width: 0;
-  background-color: transparent;
+  width: 16px;
+  min-height: 16px;
+  margin: 0 3px;
   list-style-image: url("chrome://global/skin/icons/notloading_16.png");
 }
 
@@ -1170,20 +1153,6 @@
   list-style-image: url("chrome://global/skin/icons/loading_16.png");
 }
 
-#navigator-throbber > hbox {
-  border-top: 0px;
-  border-bottom: 0px;
-  padding-bottom: 1px;
-}
-
-toolbar[mode="text"] #navigator-throbber,
-toolbar[iconsize="small"] #navigator-throbber {
-  list-style-image: url("chrome://global/skin/icons/notloading_16.png");
-}
-toolbar[mode="text"] #navigator-throbber[busy="true"],
-toolbar[iconsize="small"] #navigator-throbber[busy="true"] {
-  list-style-image: url("chrome://global/skin/icons/loading_16.png");
-}
 
 tabpanels {
   -moz-appearance: none;
diff -r 17e9560465b0 browser/themes/gnomestripe/browser/jar.mn
--- a/browser/themes/gnomestripe/browser/jar.mn	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/themes/gnomestripe/browser/jar.mn	Thu Oct 30 05:41:44 2008 -0400
@@ -1,6 +1,7 @@
 classic.jar:
 % skin browser classic/1.0 %skin/classic/browser/
 * skin/classic/browser/aboutSessionRestore.css        (aboutSessionRestore.css)
+  skin/classic/browser/aboutCertError.css             (aboutCertError.css)
 * skin/classic/browser/browser.css                    (browser.css)
   skin/classic/browser/browser.xml
 * skin/classic/browser/engineManager.css              (engineManager.css)
@@ -16,6 +17,8 @@
   skin/classic/browser/searchbar.css                  (searchbar.css)
   skin/classic/browser/Search-glass.png
   skin/classic/browser/Search-glass-rtl.png
+  skin/classic/browser/section_collapsed.png
+  skin/classic/browser/section_expanded.png
   skin/classic/browser/Secure.png
   skin/classic/browser/Security-broken.png
   skin/classic/browser/setDesktopBackground.css
@@ -32,7 +35,6 @@
   skin/classic/browser/feeds/audioFeedIcon.png        (feeds/audioFeedIcon.png)
   skin/classic/browser/feeds/audioFeedIcon16.png      (feeds/audioFeedIcon16.png)
   skin/classic/browser/feeds/subscribe.css            (feeds/subscribe.css)
-* skin/classic/browser/places/bookmarkProperties.css  (places/bookmarkProperties.css)
   skin/classic/browser/places/bookmarksMenu.png       (places/bookmarksMenu.png)
   skin/classic/browser/places/bookmarksToolbar.png    (places/bookmarksToolbar.png)
   skin/classic/browser/places/calendar.png            (places/calendar.png)
diff -r 17e9560465b0 browser/themes/gnomestripe/browser/places/bookmarkProperties.css
--- a/browser/themes/gnomestripe/browser/places/bookmarkProperties.css	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,106 +0,0 @@
-%if 0
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Firefox.
- *
- * The Initial Developer of the Original Code is Mozilla.
- * Portions created by the Initial Developer are Copyright (C) 2006
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Myk Melez <myk@mozilla.org>
- *   Simon Bnzli <zeniko@gmail.com>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-%endif
-/**** folder menulist ****/
-.folder-icon > .menulist-label-box > .menulist-icon {
-  width: 16px;
-  height: 16px;
-}
-
-.folder-icon > .menu-iconic-left {
-  display: -moz-box;
-}
-
-.folder-icon {
-  list-style-image: url("moz-icon://stock/gtk-directory?size=menu") !important;
-}
-
-/**** expander ****/
-#expander {
-  min-width: 0;
-}
-
-.up {
-  list-style-image: url("chrome://global/skin/arrow/arrow-up.gif");
-}
-
-.up:hover {
-  list-style-image: url("chrome://global/skin/arrow/arrow-up-hov.gif");
-}
-
-.down {
-  list-style-image: url("chrome://global/skin/arrow/arrow-dn.gif");
-}
-
-.down:hover {
-  list-style-image: url("chrome://global/skin/arrow/arrow-dn-hov.gif");
-}
-
-/**** name picker ****/
-
-/* Make the microsummary picker look like a regular textbox instead of 
- * an editable menulist when no microsummaries are available.
- */
-
-menulist#namePicker[droppable="false"] {
-  /* These rules come from the textbox element in textbox.css. */
-
-  /* Normal editable menulists set this to "none". */
-  -moz-appearance: textfield;
-  cursor: text;
-
-  border: 2px solid;
-  -moz-border-top-colors: ThreeDShadow ThreeDDarkShadow;
-  -moz-border-right-colors: ThreeDHighlight ThreeDLightShadow;
-  -moz-border-bottom-colors: ThreeDHighlight ThreeDLightShadow;
-  -moz-border-left-colors: ThreeDShadow ThreeDDarkShadow;
-  background-color: -moz-Field;
-  color: -moz-FieldText;
-}
-
-menulist#namePicker[droppable="false"] > .menulist-editable-box {
-  /* Normal editable menulists set this to "menulist-textfield". */
-  -moz-appearance: none;
-  padding: 2px 2px 3px 4px;
-}
-
-/* Hide the drop marker and the popup when no microsummaries are available. */
-menulist#namePicker[droppable="false"] > .menulist-dropmarker,
-menulist#namePicker[droppable="false"] > menupopup {
-  display: none;
-}
diff -r 17e9560465b0 browser/themes/gnomestripe/browser/places/editBookmarkOverlay.css
--- a/browser/themes/gnomestripe/browser/places/editBookmarkOverlay.css	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/themes/gnomestripe/browser/places/editBookmarkOverlay.css	Thu Oct 30 05:41:44 2008 -0400
@@ -56,6 +56,8 @@
 .expander-up,
 .expander-down {
   min-width: 0;
+  padding: 2px 0;
+  -moz-padding-start: 2px;
 }
 
 .expander-up {
@@ -72,6 +74,11 @@
 
 .expander-up:hover:active {
 	list-style-image: url("chrome://global/skin/arrow/arrow-up-hov.gif");
+}
+
+#editBMPanel_tagsSelector[collapsed="true"],
+#editBMPanel_folderTree[collapsed="true"] {
+  display: none;
 }
 
 /**** name picker ****/
@@ -107,3 +114,20 @@
 #editBMPanel_namePicker[droppable="false"] > menupopup {
   display: none;
 }
+
+
+/* Bookmark panel dropdown menu items */
+#editBMPanel_folderMenuList[selectedIndex="0"],
+#editBMPanel_toolbarFolderItem {
+  list-style-image: url("chrome://browser/skin/places/bookmarksToolbar.png") !important;  
+}
+
+#editBMPanel_folderMenuList[selectedIndex="1"],
+#editBMPanel_bmRootItem {
+  list-style-image: url("chrome://browser/skin/places/bookmarksMenu.png") !important;  
+}
+
+#editBMPanel_folderMenuList[selectedIndex="2"],
+#editBMPanel_unfiledRootItem {
+  list-style-image: url("chrome://browser/skin/places/unsortedBookmarks.png") !important;  
+}
diff -r 17e9560465b0 browser/themes/gnomestripe/browser/section_collapsed.png
Binary file browser/themes/gnomestripe/browser/section_collapsed.png has changed
diff -r 17e9560465b0 browser/themes/gnomestripe/browser/section_expanded.png
Binary file browser/themes/gnomestripe/browser/section_expanded.png has changed
diff -r 17e9560465b0 browser/themes/pinstripe/browser/aboutCertError.css
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/themes/pinstripe/browser/aboutCertError.css	Thu Oct 30 05:41:44 2008 -0400
@@ -0,0 +1,95 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   William Price <bugzilla@mob.rice.edu>
+ *   Steven Garrity <steven@silverorange.com>
+ *   Henrik Skupin  <mozilla@hskupin.info>
+ *   Johnathan Nightingale <johnath@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+
+html {
+  background: -moz-Dialog;
+}
+
+body {
+  margin: 0;
+  padding: 0 1em;
+  color: -moz-FieldText;
+  font: message-box;
+}
+
+h1 {
+  margin: 0 0 .6em 0;
+  border-bottom: 1px solid ThreeDLightShadow;
+  font-size: 160%;
+}
+
+h2 {
+  font-size: 130%;
+}
+
+#errorPageContainer {
+  position: relative;
+  min-width: 13em;
+  max-width: 52em;
+  margin: 4em auto;
+  border: 1px solid #FFBD09; /* pale yellow extracted from yellow passport icon */
+  -moz-border-radius: 10px;
+  padding: 3em;
+  -moz-padding-start: 30px;
+  background: url("chrome://global/skin/icons/sslWarning.png") left 0 no-repeat -moz-Field;
+  -moz-background-origin: content;
+}
+
+body[dir="rtl"] #errorPageContainer {
+  background-position: right 0;
+}
+
+#errorTitle {
+  -moz-margin-start: 80px;
+}
+
+#errorLongContent {
+  -moz-margin-start: 80px;
+}
+
+#technicalContent > h2, #expertContent > h2 {
+  background : url("chrome://browser/skin/section_expanded.png") left 0 no-repeat;
+}
+
+#technicalContent[collapsed] > h2,
+#expertContent[collapsed] > h2{
+  background-image: url("chrome://browser/skin/section_collapsed.png");
+}
diff -r 17e9560465b0 browser/themes/pinstripe/browser/aboutSessionRestore.css
--- a/browser/themes/pinstripe/browser/aboutSessionRestore.css	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/themes/pinstripe/browser/aboutSessionRestore.css	Thu Oct 30 05:41:44 2008 -0400
@@ -37,7 +37,7 @@
 %endif
 
 #errorPageContainer {
-  background-image: url("chrome://global/skin/icons/question-48.png");
+  background-image: url("chrome://global/skin/icons/question-64.png");
 }
 
 #tabList {
@@ -57,11 +57,7 @@
   list-style-image: url("chrome://mozapps/skin/places/defaultFavicon.png");
 }
 treechildren::-moz-tree-image(container, noicon) {
-  list-style-image: url("chrome://global/skin/icons/folder-item.png");
-  -moz-image-region: rect(0px, 32px, 16px, 16px);
-}
-treechildren::-moz-tree-image(container, open, noicon) {
-  -moz-image-region: rect(16px, 32px, 32px, 16px);
+  list-style-image: url("chrome://global/skin/tree/folder.png");
 }
 treechildren::-moz-tree-image(checked) {
   list-style-image: url("chrome://global/skin/checkbox/cbox-check.gif");
@@ -70,19 +66,10 @@
   list-style-image: url("chrome://global/skin/checkbox/cbox-check-dis.gif");
 }
 
-treechildren::-moz-tree-row(odd) {
-  background-color: -moz-field;
-}
-treechildren::-moz-tree-row(alternate) {
-  background-color: -moz-oddtreerow;
-}
-treechildren::-moz-tree-row(alternate, selected) {
-  background-color: -moz-mac-secondaryhighlight;
-}
-
 #buttons {
-  width: 100%;
+  -moz-margin-start: 80px; /* same as #errorLongContent in netError.css */
 }
 #buttons > button {
   margin-top: 2em;
+  -moz-margin-start: 6px;
 }
diff -r 17e9560465b0 browser/themes/pinstripe/browser/browser.css
--- a/browser/themes/pinstripe/browser/browser.css	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/themes/pinstripe/browser/browser.css	Thu Oct 30 05:41:44 2008 -0400
@@ -298,20 +298,6 @@
 
 #bookmarksToolbarFolderMenu {
   list-style-image: url("chrome://browser/skin/places/bookmarksToolbar.png");  
-}
-
-/* ----- BOOKMARK PANEL DROPDOWN MENU ITEMS ----- */	
-
-#editBMPanel_toolbarFolderItem {
-  list-style-image: url("chrome://browser/skin/places/bookmarksToolbar.png") !important;  
-}
-
-#editBMPanel_bmRootItem {
-  list-style-image: url("chrome://browser/skin/places/bookmarksMenu.png") !important;  
-}
-
-#editBMPanel_unfiledRootItem {
-  list-style-image: url("chrome://browser/skin/places/unfiledBookmarks.png") !important;  
 }
 
 /* ----- PRIMARY TOOLBAR BUTTONS ----- */	
@@ -1492,35 +1478,16 @@
 /* ----- THROBBER ----- */
 
 #navigator-throbber {
-  -moz-appearance: none;
-  -moz-user-focus: ignore;
-  -moz-box-pack: center;
-  margin: 0px 4px !important;
-  border: none !important;
-  padding: 0;
-  min-width: 0;
-  background-color: transparent;
-  height: 16px;
-  width: 17px;  
-}
-
-/* XXXmano: hack until we figure out why the throbber uses a button instead
-   of a toolbarbutton */
-#navigator-throbber .button-text {
-  display: none;
-  margin: 0 !important;
+  width: 17px;
+  min-height: 16px;
+  margin: 0 4px;
 }
 
 #navigator-throbber[busy="true"] {
   list-style-image: url("chrome://global/skin/icons/loading_16.png");
 }
 
-toolbar[iconsize="small"] #navigator-throbber[busy="true"],
-toolbar[mode="text"] #navigator-throbber[busy="true"] {
-  list-style-image: url("chrome://global/skin/icons/loading_16.png");
-}
-
-#wrapper-throbber-box > #throbber-box > #navigator-throbber {
+#wrapper-navigator-throbber > #navigator-throbber {
   list-style-image: url("chrome://global/skin/icons/notloading_16.png");
 }
 
diff -r 17e9560465b0 browser/themes/pinstripe/browser/jar.mn
--- a/browser/themes/pinstripe/browser/jar.mn	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/themes/pinstripe/browser/jar.mn	Thu Oct 30 05:41:44 2008 -0400
@@ -1,6 +1,7 @@
 classic.jar:
 % skin browser classic/1.0 %skin/classic/browser/
 * skin/classic/browser/aboutSessionRestore.css              (aboutSessionRestore.css)
+  skin/classic/browser/aboutCertError.css                   (aboutCertError.css)
   skin/classic/browser/bookmark_toolbar_background.png
   skin/classic/browser/bookmark-open-left.png
   skin/classic/browser/bookmark-open-mid.png
@@ -42,6 +43,8 @@
   skin/classic/browser/search-bar-background-left.png
   skin/classic/browser/search-bar-background-mid.png
   skin/classic/browser/search-bar-background-right.png
+  skin/classic/browser/section_collapsed.png
+  skin/classic/browser/section_expanded.png
   skin/classic/browser/Secure-Glyph-White.png
   skin/classic/browser/Secure.png
   skin/classic/browser/Security-broken.png
@@ -83,7 +86,6 @@
   skin/classic/browser/places/folderDropArrow.png           (places/folderDropArrow.png)
   skin/classic/browser/places/livemarkFolder.png            (places/livemarkFolder.png)
   skin/classic/browser/places/back-forward.png              (places/back-forward.png)
-  skin/classic/browser/places/bookmarkProperties.css        (places/bookmarkProperties.css)
   skin/classic/browser/places/editBookmarkOverlay.css       (places/editBookmarkOverlay.css)
   skin/classic/browser/places/menubutton-start.png          (places/menubutton-start.png)
   skin/classic/browser/places/menubutton-start-rtl.png      (places/menubutton-start-rtl.png)
diff -r 17e9560465b0 browser/themes/pinstripe/browser/places/bookmarkProperties.css
--- a/browser/themes/pinstripe/browser/places/bookmarkProperties.css	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,140 +0,0 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Firefox.
- *
- * The Initial Developer of the Original Code is Mozilla.
- * Portions created by the Initial Developer are Copyright (C) 2006
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Myk Melez <myk@mozilla.org>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-@namespace url("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul");
-@namespace html url("http://www.w3.org/1999/xhtml");
-
-/**** folder menulist ****/
-.folder-icon > .menulist-label-box > .menulist-icon,
-.folder-icon > .menu-iconic-left > .menu-iconic-icon {
-  width: 16px;
-  height: 16px;
-}
-
-.folder-icon > .menu-iconic-left {
-  display: -moz-box;
-}
-
-.folder-icon {
-  list-style-image: url("chrome://global/skin/tree/folder.png") !important;
-}
-
-.menulist-icon {
-	margin: 0px !important;
-}
-
-/**** folder tree ****/
-#folderTree {
-   margin: 6px 0;
-}
-
-/**** expander ****/
-#expander {
-  -moz-appearance: none;
-  margin-left: 8px;
-  padding: 0;
-  min-width: 0;
-}
-
-.up {
-	list-style-image: url("chrome://browser/skin/places/expander-open.png") !important;
-}
-
-.down {
-	list-style-image: url("chrome://browser/skin/places/expander-closed.png") !important;
-}
-
-.down:hover:active {
-	list-style-image: url("chrome://browser/skin/places/expander-closed-active.png") !important;
-}
-
-.up:hover:active {
-	list-style-image: url("chrome://browser/skin/places/expander-open-active.png") !important;
-}
-
-/**** name picker ****/
-
-/* Make the microsummary picker look like a regular textbox instead of 
- * an editable menulist when no microsummaries are available.
- */
-
-menulist#namePicker[droppable="false"] {
-  -moz-appearance: none;
-  margin: 0px;
-  border: none;
-  padding: 0px;
-  height: auto !important;
-}
-
-menulist#namePicker[droppable="false"] > .menulist-dropmarker {
-  display: none;
-}
-
-menulist#namePicker[droppable="false"] > .menulist-editable-box {
-  /* These rules are duplicates of the rules for the textbox element
-   * in textbox.css and should track changes in that file.
-   */
-  -moz-appearance: textfield;
-  cursor: text;
-  margin: 2px 4px;
-  border: 2px solid;
-  -moz-border-top-colors: ThreeDShadow ThreeDDarkShadow;
-  -moz-border-right-colors: ThreeDHighlight ThreeDLightShadow;
-  -moz-border-bottom-colors: ThreeDHighlight ThreeDLightShadow;
-  -moz-border-left-colors: ThreeDShadow ThreeDDarkShadow;
-  padding: 2px 2px 3px 4px;
-  background-color: -moz-Field;
-  color: -moz-FieldText;
-}
-
-menulist#namePicker[droppable="false"] > .menulist-editable-box > html|*.textbox-input {
-  margin: 0px !important;
-  border: none !important;
-  padding: 0px !important;
-  background-color: inherit;
-  color: inherit;
-  font: inherit;
-}
-
-/* Hide the drop marker and the popup. */
-
-menulist#namePicker[droppable="false"] > .menulist-dropmarker {
-  display: none;
-}
-
-menulist#namePicker[droppable="false"] > menupopup {
-  display: none;
-}
diff -r 17e9560465b0 browser/themes/pinstripe/browser/places/editBookmarkOverlay.css
--- a/browser/themes/pinstripe/browser/places/editBookmarkOverlay.css	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/themes/pinstripe/browser/places/editBookmarkOverlay.css	Thu Oct 30 05:41:44 2008 -0400
@@ -152,3 +152,21 @@
 #editBMPanel_namePicker[droppable="false"] > menupopup {
   display: none;
 }
+
+
+/* ----- BOOKMARK PANEL DROPDOWN MENU ITEMS ----- */	
+
+#editBMPanel_folderMenuList[selectedIndex="0"],
+#editBMPanel_toolbarFolderItem {
+  list-style-image: url("chrome://browser/skin/places/bookmarksToolbar.png") !important;  
+}
+
+#editBMPanel_folderMenuList[selectedIndex="1"],
+#editBMPanel_bmRootItem {
+  list-style-image: url("chrome://browser/skin/places/bookmarksMenu.png") !important;  
+}
+
+#editBMPanel_folderMenuList[selectedIndex="2"],
+#editBMPanel_unfiledRootItem {
+  list-style-image: url("chrome://browser/skin/places/unfiledBookmarks.png") !important;  
+}
diff -r 17e9560465b0 browser/themes/pinstripe/browser/section_collapsed.png
Binary file browser/themes/pinstripe/browser/section_collapsed.png has changed
diff -r 17e9560465b0 browser/themes/pinstripe/browser/section_expanded.png
Binary file browser/themes/pinstripe/browser/section_expanded.png has changed
diff -r 17e9560465b0 browser/themes/winstripe/browser/aboutCertError.css
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/themes/winstripe/browser/aboutCertError.css	Thu Oct 30 05:41:44 2008 -0400
@@ -0,0 +1,95 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   William Price <bugzilla@mob.rice.edu>
+ *   Steven Garrity <steven@silverorange.com>
+ *   Henrik Skupin  <mozilla@hskupin.info>
+ *   Johnathan Nightingale <johnath@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+
+html {
+  background: -moz-Dialog;
+}
+
+body {
+  margin: 0;
+  padding: 0 1em;
+  color: -moz-FieldText;
+  font: message-box;
+}
+
+h1 {
+  margin: 0 0 .6em 0;
+  border-bottom: 1px solid ThreeDLightShadow;
+  font-size: 160%;
+}
+
+h2 {
+  font-size: 130%;
+}
+
+#errorPageContainer {
+  position: relative;
+  min-width: 13em;
+  max-width: 52em;
+  margin: 4em auto;
+  border: 1px solid #FFBD09; /* pale yellow extracted from yellow passport icon */
+  -moz-border-radius: 10px;
+  padding: 3em;
+  -moz-padding-start: 30px;
+  background: url("chrome://global/skin/icons/sslWarning.png") left 0 no-repeat -moz-Field;
+  -moz-background-origin: content;
+}
+
+body[dir="rtl"] #errorPageContainer {
+  background-position: right 0;
+}
+
+#errorTitle {
+  -moz-margin-start: 80px;
+}
+
+#errorLongContent {
+  -moz-margin-start: 80px;
+}
+
+#technicalContent > h2, #expertContent > h2 {
+  background : url("chrome://browser/skin/section_expanded.png") left 0 no-repeat;
+}
+
+#technicalContent[collapsed] > h2,
+#expertContent[collapsed] > h2{
+  background-image: url("chrome://browser/skin/section_collapsed.png");
+}
diff -r 17e9560465b0 browser/themes/winstripe/browser/browser.css
--- a/browser/themes/winstripe/browser/browser.css	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/themes/winstripe/browser/browser.css	Thu Oct 30 05:41:44 2008 -0400
@@ -203,23 +203,6 @@
 .bookmark-item[query][hostContainer][open] {
   list-style-image: url("chrome://global/skin/icons/folder-item.png");
   -moz-image-region: rect(16px, 32px, 32px, 16px);
-}
-
-/* ::::: bookmark panel dropdown icons ::::: */
-
-#editBMPanel_toolbarFolderItem {
-  list-style-image: url("chrome://browser/skin/places/bookmarksToolbar.png") !important;
-  -moz-image-region: auto !important;
-}
-
-#editBMPanel_bmRootItem {
-  list-style-image: url("chrome://browser/skin/places/bookmarksMenu.png") !important;
-  -moz-image-region: auto !important;
-}
-
-#editBMPanel_unfiledRootItem {
-  list-style-image: url("chrome://browser/skin/places/unsortedBookmarks.png") !important;
-  -moz-image-region: auto !important;
 }
 
 /* ::::: primary toolbar buttons ::::: */
@@ -1292,34 +1275,13 @@
 /* ::::: throbber ::::: */
 
 #navigator-throbber {
-  -moz-appearance: none;
-  -moz-user-focus: ignore;
-  margin: 0 !important;
-  border: none !important;
-  padding: 0px !important;
-  min-width: 0;
-  background-color: transparent;
+  width: 16px;
+  min-height: 16px;
+  margin: 0 3px;
   list-style-image: url("chrome://global/skin/icons/notloading_16.png");
 }
 
 #navigator-throbber[busy="true"] {
-  list-style-image: url("chrome://global/skin/icons/loading_16.png");
-}
-
-/* the default settings for the throbber hbox is too tall for vista menus */
-#navigator-throbber > hbox {
-  border-top: 0px;
-  border-bottom: 0px;
-  padding-bottom: 1px;
-  -moz-margin-end: 1px;
-}
-
-toolbar[iconsize="small"] #navigator-throbber,
-toolbar[mode="text"] #navigator-throbber {
-  list-style-image: url("chrome://global/skin/icons/notloading_16.png");
-}
-toolbar[iconsize="small"] #navigator-throbber[busy="true"],
-toolbar[mode="text"] #navigator-throbber[busy="true"] {
   list-style-image: url("chrome://global/skin/icons/loading_16.png");
 }
 
diff -r 17e9560465b0 browser/themes/winstripe/browser/jar.mn
--- a/browser/themes/winstripe/browser/jar.mn	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/themes/winstripe/browser/jar.mn	Thu Oct 30 05:41:44 2008 -0400
@@ -4,6 +4,7 @@
 # NOTE: If you add a new file here, you'll need to add it to the aero
 # section at the bottom of this file
 *       skin/classic/browser/aboutSessionRestore.css                 (aboutSessionRestore.css)
+        skin/classic/browser/aboutCertError.css                      (aboutCertError.css)
 *       skin/classic/browser/browser.css                             (browser.css)
 *       skin/classic/browser/engineManager.css                       (engineManager.css)
         skin/classic/browser/Info.png                                (Info.png)
@@ -29,6 +30,8 @@
         skin/classic/browser/Search-glass.png                        (Search-glass.png)
         skin/classic/browser/Search-glass-rtl.png                    (Search-glass-rtl.png)
         skin/classic/browser/Search-addengines.png
+        skin/classic/browser/section_collapsed.png
+        skin/classic/browser/section_expanded.png
         skin/classic/browser/setDesktopBackground.css
         skin/classic/browser/menu-back.png                           (menu-back.png)
         skin/classic/browser/menu-forward.png                        (menu-forward.png)
@@ -66,7 +69,6 @@
         skin/classic/browser/places/organize.png                     (places/organize.png)
         skin/classic/browser/places/view.png                         (places/view.png)
         skin/classic/browser/places/searching_16.png                 (places/searching_16.png)
-        skin/classic/browser/places/bookmarkProperties.css           (places/bookmarkProperties.css)
         skin/classic/browser/preferences/alwaysAsk.png               (preferences/alwaysAsk.png)
         skin/classic/browser/preferences/application.png             (preferences/application.png)
         skin/classic/browser/preferences/mail.png                    (preferences/mail.png)
@@ -92,6 +94,7 @@
 classic.jar:
 % skin browser classic/1.0 %skin/classic/aero/browser/ os=WINNT osversion>=6
 *       skin/classic/aero/browser/aboutSessionRestore.css            (aboutSessionRestore.css)
+        skin/classic/aero/browser/aboutCertError.css                 (aboutCertError.css)
 *       skin/classic/aero/browser/browser.css                        (browser-aero.css)
 *       skin/classic/aero/browser/engineManager.css                  (engineManager.css)
         skin/classic/aero/browser/Info.png                           (Info-aero.png)
@@ -155,7 +158,6 @@
         skin/classic/aero/browser/places/view.png                    (places/view-aero.png)
         skin/classic/aero/browser/places/searching_16.png            (places/searching_16-aero.png)
         skin/classic/aero/browser/places/organize.png                (places/organize-aero.png)
-        skin/classic/aero/browser/places/bookmarkProperties.css      (places/bookmarkProperties.css)
         skin/classic/aero/browser/preferences/alwaysAsk.png          (preferences/alwaysAsk-aero.png)
         skin/classic/aero/browser/preferences/application.png        (preferences/application-aero.png)
         skin/classic/aero/browser/preferences/mail.png               (preferences/mail-aero.png)
diff -r 17e9560465b0 browser/themes/winstripe/browser/places/bookmarkProperties.css
--- a/browser/themes/winstripe/browser/places/bookmarkProperties.css	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,106 +0,0 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Firefox.
- *
- * The Initial Developer of the Original Code is Mozilla.
- * Portions created by the Initial Developer are Copyright (C) 2006
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Myk Melez <myk@mozilla.org>
- *   Simon Bnzli <zeniko@gmail.com>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-/**** folder menulist ****/
-.folder-icon > .menulist-label-box > .menulist-icon {
-  width: 16px;
-  height: 16px;
-}
-
-.folder-icon > .menu-iconic-left {
-  display: -moz-box;
-}
-
-.folder-icon {
-  list-style-image: url("chrome://global/skin/icons/folder-item.png") !important;
-  -moz-image-region: rect(0px, 32px, 16px, 16px) !important;
-}
-
-/**** expander ****/
-#expander {
-  min-width: 0;
-}
-
-.up {
-  list-style-image: url("chrome://global/skin/arrow/arrow-up.gif");
-}
-
-.up:hover {
-  list-style-image: url("chrome://global/skin/arrow/arrow-up-hov.gif");
-}
-
-.down {
-  list-style-image: url("chrome://global/skin/arrow/arrow-dn.gif");
-}
-
-.down:hover {
-  list-style-image: url("chrome://global/skin/arrow/arrow-dn-hov.gif");
-}
-
-/**** name picker ****/
-
-/* Make the microsummary picker look like a regular textbox instead of 
- * an editable menulist when no microsummaries are available.
- */
-
-menulist#namePicker[droppable="false"] {
-  /* These rules come from the textbox element in textbox.css. */
-
-  /* Normal editable menulists set this to "none". */
-  -moz-appearance: textfield;
-  cursor: text;
-
-  border: 2px solid;
-  -moz-border-top-colors: ThreeDShadow ThreeDDarkShadow;
-  -moz-border-right-colors: ThreeDHighlight ThreeDLightShadow;
-  -moz-border-bottom-colors: ThreeDHighlight ThreeDLightShadow;
-  -moz-border-left-colors: ThreeDShadow ThreeDDarkShadow;
-  background-color: -moz-Field;
-  color: -moz-FieldText;
-}
-
-menulist#namePicker[droppable="false"] > .menulist-editable-box {
-  /* Normal editable menulists set this to "menulist-textfield". */
-  -moz-appearance: none;
-  padding: 2px 2px 3px 4px;
-}
-
-/* Hide the drop marker and the popup when no microsummaries are available. */
-menulist#namePicker[droppable="false"] > .menulist-dropmarker,
-menulist#namePicker[droppable="false"] > menupopup {
-  display: none;
-}
diff -r 17e9560465b0 browser/themes/winstripe/browser/places/editBookmarkOverlay.css
--- a/browser/themes/winstripe/browser/places/editBookmarkOverlay.css	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/themes/winstripe/browser/places/editBookmarkOverlay.css	Thu Oct 30 05:41:44 2008 -0400
@@ -56,6 +56,7 @@
 .expander-up,
 .expander-down {
   min-width: 0;
+  margin: 0;
 }
 
 .expander-up > hbox,
@@ -69,6 +70,11 @@
 
 .expander-down {
   list-style-image: url("chrome://global/skin/icons/expand.png");
+}
+
+#editBMPanel_tagsSelector[collapsed="true"],
+#editBMPanel_folderTree[collapsed="true"] {
+  display: none;
 }
 
 /**** name picker ****/
@@ -105,3 +111,24 @@
 #editBMPanel_namePicker[droppable="false"] > menupopup {
   display: none;
 }
+
+
+/* ::::: bookmark panel dropdown icons ::::: */
+
+#editBMPanel_folderMenuList[selectedIndex="0"],
+#editBMPanel_toolbarFolderItem {
+  list-style-image: url("chrome://browser/skin/places/bookmarksToolbar.png") !important;
+  -moz-image-region: auto !important;
+}
+
+#editBMPanel_folderMenuList[selectedIndex="1"],
+#editBMPanel_bmRootItem {
+  list-style-image: url("chrome://browser/skin/places/bookmarksMenu.png") !important;
+  -moz-image-region: auto !important;
+}
+
+#editBMPanel_folderMenuList[selectedIndex="2"],
+#editBMPanel_unfiledRootItem {
+  list-style-image: url("chrome://browser/skin/places/unsortedBookmarks.png") !important;
+  -moz-image-region: auto !important;
+}
diff -r 17e9560465b0 browser/themes/winstripe/browser/places/organizer.css
--- a/browser/themes/winstripe/browser/places/organizer.css	Thu Oct 23 09:51:35 2008 -0700
+++ b/browser/themes/winstripe/browser/places/organizer.css	Thu Oct 30 05:41:44 2008 -0400
@@ -241,6 +241,7 @@
 #infoBoxExpanderLabel {
   margin: 0;
   padding: 5px 0;
+  -moz-padding-start: 2px;
 }
 
 #organizerScopeBar {
diff -r 17e9560465b0 browser/themes/winstripe/browser/section_collapsed.png
Binary file browser/themes/winstripe/browser/section_collapsed.png has changed
diff -r 17e9560465b0 browser/themes/winstripe/browser/section_expanded.png
Binary file browser/themes/winstripe/browser/section_expanded.png has changed
diff -r 17e9560465b0 build/wince/shunt/a2w.cpp
--- a/build/wince/shunt/a2w.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,153 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code, released
- * Jan 28, 2003.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 2003
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Garrett Arch Blythe, 28-January-2003
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#include "mozce_internal.h"
-
-int a2w_buffer(const char* inACPString, int inACPChars, unsigned short* outWideString, int inWideChars)
-{
-    int retval = 0;
-    
-    /*
-    **  Start off by terminating the out argument if appropriate.
-    */
-    if(NULL != outWideString && 0 != inWideChars)
-    {
-        *outWideString = L'\0';
-    }
-    
-    /*
-    **  Sanity check arguments.
-    */
-    if(NULL != inACPString && 0 != inACPChars && (0 == inWideChars || NULL != outWideString))
-    {
-        /*
-        **  Attempt the conversion.
-        */
-        retval = MultiByteToWideChar(
-                                     CP_ACP,
-                                     0,
-                                     inACPString,
-                                     inACPChars,
-                                     outWideString,
-                                     inWideChars
-                                     );
-    }
-    
-    return retval;
-}
-
-
-unsigned short* a2w_malloc(const char* inACPString, int inACPChars, int* outWideChars)
-{
-    LPWSTR retval = NULL;
-    
-    /*
-    **  Initialize any out arguments.
-    */
-    if(NULL != outWideChars)
-    {
-        *outWideChars = 0;
-    }
-    
-    /*
-    **  Initialize the acp char length if requested.
-    **  We do this here to avoid doing it twice in calls to a2w_buffer.
-    */
-    if(-1 == inACPChars)
-    {
-        if(NULL != inACPString)
-        {
-            /*
-            **  Plus one so the terminating character is included.
-            */
-            inACPChars = (int)strlen(inACPString) + 1;
-        }
-        else
-        {
-            inACPChars = 0;
-        }
-    }
-    
-    /*
-    **  Sanity check arguments.
-    */
-    if(NULL != inACPString && 0 != inACPChars)
-    {
-        int charsRequired = 0;
-        
-        /*
-        **  Determine the size of buffer required for the conversion.
-        */
-        charsRequired = a2w_buffer(inACPString, inACPChars, NULL, 0);
-        if(0 != charsRequired)
-        {
-            LPWSTR heapBuffer = NULL;
-            
-            heapBuffer = (LPWSTR)malloc((size_t)charsRequired * sizeof(WCHAR));
-            if(NULL != heapBuffer)
-            {
-                int wideChars = 0;
-                
-                /*
-                **  Real thing this time.
-                */
-                wideChars = a2w_buffer(inACPString, inACPChars, heapBuffer, charsRequired);
-                if(0 != wideChars)
-                {
-                    retval = heapBuffer;
-                    if(NULL != outWideChars)
-                    {
-                        *outWideChars = wideChars;
-                    }
-                }
-                else
-                {
-                    /*
-                    **  Something wrong.
-                    **  Clean up.
-                    */
-                    free(heapBuffer);
-                }
-            }
-        }
-    }
-    
-    return retval;
-}
diff -r 17e9560465b0 build/wince/shunt/assert.cpp
--- a/build/wince/shunt/assert.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,62 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code, released
- * Jan 28, 2003.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 2003
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Garrett Arch Blythe, 28-January-2003
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#include "mozce_internal.h"
-
-extern "C" {
-#if 0
-}
-#endif
-
-MOZCE_SHUNT_API void mozce_assert(int inExpression)
-{
-    WINCE_LOG_API_CALL("mozce_assert called\n");
-
-    if(0 == inExpression)
-    {
-        DebugBreak();
-    }
-}
-
-#if 0
-{
-#endif
-} /* extern "C" */
-
diff -r 17e9560465b0 build/wince/shunt/build/vs8/mozce_shunt_static.vcproj
--- a/build/wince/shunt/build/vs8/mozce_shunt_static.vcproj	Thu Oct 23 09:51:35 2008 -0700
+++ b/build/wince/shunt/build/vs8/mozce_shunt_static.vcproj	Thu Oct 30 05:41:44 2008 -0400
@@ -1,1220 +1,1032 @@
-<?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="8.00"
-	Name="mozce_shunt_static"
-	ProjectGUID="{082BAB06-D10F-4C57-B123-F84DC06C246D}"
-	RootNamespace="mozce_shunt_static"
-	Keyword="Win32Proj"
-	>
-	<Platforms>
-		<Platform
-			Name="Pocket PC 2003 (ARMV4)"
-		/>
-		<Platform
-			Name="Smartphone 2003 (ARMV4)"
-		/>
-		<Platform
-			Name="Windows Mobile 6 Professional SDK (ARMV4I)"
-		/>
-		<Platform
-			Name="Windows Mobile 6 Standard SDK (ARMV4I)"
-		/>
-		<Platform
-			Name="Windows Mobile 5.0 Pocket PC SDK (ARMV4I)"
-		/>
-		<Platform
-			Name="Windows Mobile 5.0 Smartphone SDK (ARMV4I)"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Pocket PC 2003 (ARMV4)"
-			OutputDirectory="Pocket PC 2003 (ARMV4)\$(ConfigurationName)"
-			IntermediateDirectory="Pocket PC 2003 (ARMV4)\$(ConfigurationName)"
-			ConfigurationType="4"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="1"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				ExecutionBucket="7"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\include"
-				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);_DEBUG;DEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
-				MinimalRebuild="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="1"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				TreatWChar_tAsBuiltInType="false"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(IntDir)"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				AdditionalOptions=" /subsystem:windowsce,5.01 /machine:THUMB"
-				OutputFile="$(InputDir)/shunt_dbg.lib"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCCodeSignTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-			<DeploymentTool
-				ForceDirty="-1"
-				RemoteDirectory=""
-				RegisterOutput="0"
-				AdditionalFiles=""
-			/>
-			<DebuggerTool
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|Smartphone 2003 (ARMV4)"
-			OutputDirectory="Smartphone 2003 (ARMV4)\$(ConfigurationName)"
-			IntermediateDirectory="Smartphone 2003 (ARMV4)\$(ConfigurationName)"
-			ConfigurationType="4"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="1"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				ExecutionBucket="7"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\include"
-				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);_DEBUG;DEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
-				MinimalRebuild="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="1"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				TreatWChar_tAsBuiltInType="false"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(IntDir)"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				AdditionalOptions=" /subsystem:windowsce,5.01 /machine:THUMB"
-				OutputFile="$(InputDir)/shunt_dbg.lib"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCCodeSignTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-			<DeploymentTool
-				ForceDirty="-1"
-				RemoteDirectory=""
-				RegisterOutput="0"
-				AdditionalFiles=""
-			/>
-			<DebuggerTool
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|Windows Mobile 6 Professional SDK (ARMV4I)"
-			OutputDirectory="Windows Mobile 6 Professional SDK (ARMV4I)\$(ConfigurationName)"
-			IntermediateDirectory="Windows Mobile 6 Professional SDK (ARMV4I)\$(ConfigurationName)"
-			ConfigurationType="2"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="1"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				ExecutionBucket="7"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\include"
-				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);_DEBUG;DEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_SHUNT_EXPORTS;DEBUG_NSPR_ALL;TIMELINE"
-				MinimalRebuild="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="1"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				TreatWChar_tAsBuiltInType="false"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				DebugInformationFormat="3"
-				CompileAs="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(IntDir)"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions=" /SUBSYSTEM:WINDOWSCE,5.02"
-				OutputFile="$(OutDir)\mozce_shunt.dll"
-				GenerateDebugInformation="true"
-				ImportLibrary="$(OutDir)\mozce_shunt.lib"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCCodeSignTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-				CommandLine="copy &quot;$(TargetDir)$(TargetName).dll&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;copy &quot;$(TargetDir)$(TargetName).lib&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;"
-			/>
-			<DeploymentTool
-				ForceDirty="-1"
-				RemoteDirectory="\Storage Card\dist\bin\"
-				RegisterOutput="0"
-				AdditionalFiles=""
-			/>
-			<DebuggerTool
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|Windows Mobile 6 Standard SDK (ARMV4I)"
-			OutputDirectory="Windows Mobile 6 Standard SDK (ARMV4I)\$(ConfigurationName)"
-			IntermediateDirectory="Windows Mobile 6 Standard SDK (ARMV4I)\$(ConfigurationName)"
-			ConfigurationType="2"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="1"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				ExecutionBucket="7"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\include"
-				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);_DEBUG;DEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_SHUNT_EXPORTS;DEBUG_NSPR_ALL;TIMELINE"
-				MinimalRebuild="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="1"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				TreatWChar_tAsBuiltInType="false"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				DebugInformationFormat="3"
-				CompileAs="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(IntDir)"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions=" /SUBSYSTEM:WINDOWSCE,5.02"
-				OutputFile="$(OutDir)\mozce_shunt.dll"
-				GenerateDebugInformation="true"
-				ImportLibrary="$(OutDir)\mozce_shunt.lib"
-				TargetMachine="0"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCCodeSignTool"
-				AuthenticodeSignature="false"
-				ProvisionDevice="0"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-				CommandLine="copy &quot;$(TargetDir)$(TargetName).dll&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;copy &quot;$(TargetDir)$(TargetName).lib&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;"
-			/>
-			<DeploymentTool
-				ForceDirty="-1"
-				RemoteDirectory="\"
-				RegisterOutput="0"
-				AdditionalFiles=""
-			/>
-			<DebuggerTool
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Pocket PC 2003 (ARMV4)"
-			OutputDirectory="Pocket PC 2003 (ARMV4)\$(ConfigurationName)"
-			IntermediateDirectory="Pocket PC 2003 (ARMV4)\$(ConfigurationName)"
-			ConfigurationType="4"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="1"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				ExecutionBucket="7"
-				Optimization="2"
-				AdditionalIncludeDirectories="..\..\include"
-				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);NDEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
-				ExceptionHandling="1"
-				RuntimeLibrary="0"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				FloatingPointModel="2"
-				TreatWChar_tAsBuiltInType="false"
-				RuntimeTypeInfo="true"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				DebugInformationFormat="3"
-				CompileForArchitecture="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(IntDir)"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				AdditionalOptions=" /subsystem:windowsce,5.01 /machine:THUMB"
-				OutputFile="$(InputDir)/shunt.lib"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCCodeSignTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-			<DeploymentTool
-				ForceDirty="-1"
-				RemoteDirectory=""
-				RegisterOutput="0"
-				AdditionalFiles=""
-			/>
-			<DebuggerTool
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Smartphone 2003 (ARMV4)"
-			OutputDirectory="Smartphone 2003 (ARMV4)\$(ConfigurationName)"
-			IntermediateDirectory="Smartphone 2003 (ARMV4)\$(ConfigurationName)"
-			ConfigurationType="4"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="1"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				ExecutionBucket="7"
-				Optimization="2"
-				AdditionalIncludeDirectories="..\..\include"
-				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);NDEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
-				ExceptionHandling="1"
-				RuntimeLibrary="0"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				FloatingPointModel="2"
-				TreatWChar_tAsBuiltInType="false"
-				RuntimeTypeInfo="true"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				DebugInformationFormat="3"
-				CompileForArchitecture="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(IntDir)"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				AdditionalOptions=" /subsystem:windowsce,5.01 /machine:THUMB"
-				OutputFile="$(InputDir)/shunt.lib"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCCodeSignTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-			<DeploymentTool
-				ForceDirty="-1"
-				RemoteDirectory=""
-				RegisterOutput="0"
-				AdditionalFiles=""
-			/>
-			<DebuggerTool
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Windows Mobile 6 Professional SDK (ARMV4I)"
-			OutputDirectory="Windows Mobile 6 Professional SDK (ARMV4I)\$(ConfigurationName)"
-			IntermediateDirectory="Windows Mobile 6 Professional SDK (ARMV4I)\$(ConfigurationName)"
-			ConfigurationType="2"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-				CommandLine=""
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="1"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				ExecutionBucket="7"
-				Optimization="2"
-				AdditionalIncludeDirectories="..\..\include"
-				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);NDEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_SHUNT_EXPORTS"
-				ExceptionHandling="1"
-				RuntimeLibrary="0"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				FloatingPointModel="2"
-				TreatWChar_tAsBuiltInType="false"
-				RuntimeTypeInfo="false"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				DebugInformationFormat="3"
-				CompileAs="0"
-				CompileForArchitecture="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(IntDir)"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions=" /SUBSYSTEM:WINDOWSCE,5.02"
-				OutputFile="$(OutDir)\mozce_shunt.dll"
-				ImportLibrary="$(OutDir)\mozce_shunt.lib"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCCodeSignTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-				CommandLine="copy &quot;$(TargetDir)$(TargetName).dll&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;copy &quot;$(TargetDir)$(TargetName).lib&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;"
-			/>
-			<DeploymentTool
-				ForceDirty="-1"
-				RemoteDirectory=""
-				RegisterOutput="0"
-				AdditionalFiles=""
-			/>
-			<DebuggerTool
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Windows Mobile 6 Standard SDK (ARMV4I)"
-			OutputDirectory="Windows Mobile 6 Standard SDK (ARMV4I)\$(ConfigurationName)"
-			IntermediateDirectory="Windows Mobile 6 Standard SDK (ARMV4I)\$(ConfigurationName)"
-			ConfigurationType="2"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-				CommandLine=""
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="1"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				ExecutionBucket="7"
-				Optimization="2"
-				AdditionalIncludeDirectories="..\..\include"
-				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);NDEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_SHUNT_EXPORTS"
-				ExceptionHandling="1"
-				RuntimeLibrary="0"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				FloatingPointModel="2"
-				TreatWChar_tAsBuiltInType="false"
-				RuntimeTypeInfo="false"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				DebugInformationFormat="3"
-				CompileAs="0"
-				CompileForArchitecture="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(IntDir)"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions=" /SUBSYSTEM:WINDOWSCE,5.02"
-				OutputFile="$(OutDir)\mozce_shunt.dll"
-				ImportLibrary="$(OutDir)\mozce_shunt.lib"
-				TargetMachine="0"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCCodeSignTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-				CommandLine="copy &quot;$(TargetDir)$(TargetName).dll&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;copy &quot;$(TargetDir)$(TargetName).lib&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;"
-			/>
-			<DeploymentTool
-				ForceDirty="-1"
-				RemoteDirectory=""
-				RegisterOutput="0"
-				AdditionalFiles=""
-			/>
-			<DebuggerTool
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|Windows Mobile 5.0 Pocket PC SDK (ARMV4I)"
-			OutputDirectory="$(PlatformName)\Debug"
-			IntermediateDirectory="$(PlatformName)\Debug"
-			ConfigurationType="4"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				ExecutionBucket="7"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\include"
-				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);_DEBUG;DEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
-				MinimalRebuild="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="1"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				TreatWChar_tAsBuiltInType="false"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(IntDir)"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				AdditionalOptions=" /subsystem:windowsce,5.01 /machine:THUMB"
-				OutputFile="$(InputDir)/shunt_dbg.lib"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCCodeSignTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-			<DeploymentTool
-				ForceDirty="-1"
-				RemoteDirectory=""
-				RegisterOutput="0"
-				AdditionalFiles=""
-			/>
-			<DebuggerTool
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Windows Mobile 5.0 Pocket PC SDK (ARMV4I)"
-			OutputDirectory="$(PlatformName)\Release"
-			IntermediateDirectory="$(PlatformName)\Release"
-			ConfigurationType="4"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				ExecutionBucket="7"
-				Optimization="2"
-				AdditionalIncludeDirectories="..\..\include"
-				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);NDEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
-				ExceptionHandling="0"
-				RuntimeLibrary="0"
-				BufferSecurityCheck="false"
-				TreatWChar_tAsBuiltInType="false"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(IntDir)"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				AdditionalOptions=" /subsystem:windowsce,5.01 /machine:THUMB"
-				OutputFile="$(InputDir)/shunt.lib"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCCodeSignTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-			<DeploymentTool
-				ForceDirty="-1"
-				RemoteDirectory=""
-				RegisterOutput="0"
-				AdditionalFiles=""
-			/>
-			<DebuggerTool
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|Windows Mobile 5.0 Smartphone SDK (ARMV4I)"
-			OutputDirectory="Windows Mobile 5.0 Smartphone SDK (ARMV4I)\$(ConfigurationName)"
-			IntermediateDirectory="Windows Mobile 5.0 Smartphone SDK (ARMV4I)\$(ConfigurationName)"
-			ConfigurationType="4"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="1"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				ExecutionBucket="7"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\include"
-				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);_DEBUG;DEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
-				MinimalRebuild="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="1"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				TreatWChar_tAsBuiltInType="false"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(IntDir)"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				AdditionalOptions=" /subsystem:windowsce,5.01 /machine:THUMB"
-				OutputFile="$(InputDir)/shunt_dbg.lib"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCCodeSignTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-			<DeploymentTool
-				ForceDirty="-1"
-				RemoteDirectory=""
-				RegisterOutput="0"
-				AdditionalFiles=""
-			/>
-			<DebuggerTool
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Windows Mobile 5.0 Smartphone SDK (ARMV4I)"
-			OutputDirectory="Windows Mobile 5.0 Smartphone SDK (ARMV4I)\$(ConfigurationName)"
-			IntermediateDirectory="Windows Mobile 5.0 Smartphone SDK (ARMV4I)\$(ConfigurationName)"
-			ConfigurationType="4"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="1"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				ExecutionBucket="7"
-				Optimization="2"
-				AdditionalIncludeDirectories="..\..\include"
-				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);NDEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
-				ExceptionHandling="0"
-				RuntimeLibrary="0"
-				BufferSecurityCheck="false"
-				TreatWChar_tAsBuiltInType="false"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(IntDir)"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				AdditionalOptions=" /subsystem:windowsce,5.01 /machine:THUMB"
-				OutputFile="$(InputDir)/shunt.lib"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCCodeSignTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-			<DeploymentTool
-				ForceDirty="-1"
-				RemoteDirectory=""
-				RegisterOutput="0"
-				AdditionalFiles=""
-			/>
-			<DebuggerTool
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
-			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
-			>
-			<File
-				RelativePath="..\..\a2w.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\assert.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\clipboard.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\direct.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\errno.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\io.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\map.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\mbstring.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\nclog.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\process.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\signal.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\stat.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\stdio.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\stdlib.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\string.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\time.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\w2a.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\win32.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\win32A.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\win32W.cpp"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl;inc;xsd"
-			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
-			>
-			<File
-				RelativePath="..\..\include\crtdbg.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\ddeml.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\direct.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\dlgs.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\errno.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\fcntl.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\intshcut.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\io.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\map.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\mbstring.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\mozce_defs.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\mozce_internal.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\mozce_shunt.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\new.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\process.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\rasdlg.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\signal.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\time_conversions.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\unistd.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\varargs.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\winresrc.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\winsock2.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\winspool.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\winsvc.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\zmouse.h"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Resource Files"
-			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
-			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
-			>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8.00"
+	Name="mozce_shunt_static"
+	ProjectGUID="{082BAB06-D10F-4C57-B123-F84DC06C246D}"
+	RootNamespace="mozce_shunt_static"
+	Keyword="Win32Proj"
+	>
+	<Platforms>
+		<Platform
+			Name="Pocket PC 2003 (ARMV4)"
+		/>
+		<Platform
+			Name="Smartphone 2003 (ARMV4)"
+		/>
+		<Platform
+			Name="Windows Mobile 6 Professional SDK (ARMV4I)"
+		/>
+		<Platform
+			Name="Windows Mobile 6 Standard SDK (ARMV4I)"
+		/>
+		<Platform
+			Name="Windows Mobile 5.0 Pocket PC SDK (ARMV4I)"
+		/>
+		<Platform
+			Name="Windows Mobile 5.0 Smartphone SDK (ARMV4I)"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Pocket PC 2003 (ARMV4)"
+			OutputDirectory="Pocket PC 2003 (ARMV4)\$(ConfigurationName)"
+			IntermediateDirectory="Pocket PC 2003 (ARMV4)\$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="1"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);_DEBUG;DEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
+				MinimalRebuild="true"
+				ExceptionHandling="0"
+				RuntimeLibrary="1"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				TreatWChar_tAsBuiltInType="false"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				AdditionalOptions=" /subsystem:windowsce,5.01 /machine:THUMB"
+				OutputFile="$(InputDir)/shunt_dbg.lib"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory=""
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Smartphone 2003 (ARMV4)"
+			OutputDirectory="Smartphone 2003 (ARMV4)\$(ConfigurationName)"
+			IntermediateDirectory="Smartphone 2003 (ARMV4)\$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="1"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);_DEBUG;DEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
+				MinimalRebuild="true"
+				ExceptionHandling="0"
+				RuntimeLibrary="1"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				TreatWChar_tAsBuiltInType="false"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				AdditionalOptions=" /subsystem:windowsce,5.01 /machine:THUMB"
+				OutputFile="$(InputDir)/shunt_dbg.lib"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory=""
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Windows Mobile 6 Professional SDK (ARMV4I)"
+			OutputDirectory="Windows Mobile 6 Professional SDK (ARMV4I)\$(ConfigurationName)"
+			IntermediateDirectory="Windows Mobile 6 Professional SDK (ARMV4I)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="1"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);_DEBUG;DEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_SHUNT_EXPORTS;DEBUG_NSPR_ALL;TIMELINE"
+				MinimalRebuild="true"
+				ExceptionHandling="0"
+				RuntimeLibrary="1"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				TreatWChar_tAsBuiltInType="false"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions=" /SUBSYSTEM:WINDOWSCE,5.02"
+				OutputFile="$(OutDir)\mozce_shunt.dll"
+				GenerateDebugInformation="true"
+				ImportLibrary="$(OutDir)\mozce_shunt.lib"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy &quot;$(TargetDir)$(TargetName).dll&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;copy &quot;$(TargetDir)$(TargetName).lib&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory="\Storage Card\dist\bin\"
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Windows Mobile 6 Standard SDK (ARMV4I)"
+			OutputDirectory="Windows Mobile 6 Standard SDK (ARMV4I)\$(ConfigurationName)"
+			IntermediateDirectory="Windows Mobile 6 Standard SDK (ARMV4I)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="1"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);_DEBUG;DEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_SHUNT_EXPORTS;DEBUG_NSPR_ALL;TIMELINE"
+				MinimalRebuild="true"
+				ExceptionHandling="0"
+				RuntimeLibrary="1"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				TreatWChar_tAsBuiltInType="false"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions=" /SUBSYSTEM:WINDOWSCE,5.02"
+				OutputFile="$(OutDir)\mozce_shunt.dll"
+				GenerateDebugInformation="true"
+				ImportLibrary="$(OutDir)\mozce_shunt.lib"
+				TargetMachine="0"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+				AuthenticodeSignature="false"
+				ProvisionDevice="0"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy &quot;$(TargetDir)$(TargetName).dll&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;copy &quot;$(TargetDir)$(TargetName).lib&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory="\"
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Pocket PC 2003 (ARMV4)"
+			OutputDirectory="Pocket PC 2003 (ARMV4)\$(ConfigurationName)"
+			IntermediateDirectory="Pocket PC 2003 (ARMV4)\$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="1"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="2"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);NDEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
+				ExceptionHandling="1"
+				RuntimeLibrary="0"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				FloatingPointModel="2"
+				TreatWChar_tAsBuiltInType="false"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+				CompileForArchitecture="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				AdditionalOptions=" /subsystem:windowsce,5.01 /machine:THUMB"
+				OutputFile="$(InputDir)/shunt.lib"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory=""
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Smartphone 2003 (ARMV4)"
+			OutputDirectory="Smartphone 2003 (ARMV4)\$(ConfigurationName)"
+			IntermediateDirectory="Smartphone 2003 (ARMV4)\$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="1"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="2"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);NDEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
+				ExceptionHandling="1"
+				RuntimeLibrary="0"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				FloatingPointModel="2"
+				TreatWChar_tAsBuiltInType="false"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+				CompileForArchitecture="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				AdditionalOptions=" /subsystem:windowsce,5.01 /machine:THUMB"
+				OutputFile="$(InputDir)/shunt.lib"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory=""
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Windows Mobile 6 Professional SDK (ARMV4I)"
+			OutputDirectory="Windows Mobile 6 Professional SDK (ARMV4I)\$(ConfigurationName)"
+			IntermediateDirectory="Windows Mobile 6 Professional SDK (ARMV4I)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+				CommandLine=""
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="1"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="2"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);NDEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_SHUNT_EXPORTS"
+				ExceptionHandling="1"
+				RuntimeLibrary="0"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				FloatingPointModel="2"
+				TreatWChar_tAsBuiltInType="false"
+				RuntimeTypeInfo="false"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+				CompileAs="0"
+				CompileForArchitecture="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions=" /SUBSYSTEM:WINDOWSCE,5.02"
+				OutputFile="$(OutDir)\mozce_shunt.dll"
+				ImportLibrary="$(OutDir)\mozce_shunt.lib"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy &quot;$(TargetDir)$(TargetName).dll&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;copy &quot;$(TargetDir)$(TargetName).lib&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory=""
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Windows Mobile 6 Standard SDK (ARMV4I)"
+			OutputDirectory="Windows Mobile 6 Standard SDK (ARMV4I)\$(ConfigurationName)"
+			IntermediateDirectory="Windows Mobile 6 Standard SDK (ARMV4I)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+				CommandLine=""
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="1"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="2"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);NDEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_SHUNT_EXPORTS"
+				ExceptionHandling="1"
+				RuntimeLibrary="0"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				FloatingPointModel="2"
+				TreatWChar_tAsBuiltInType="false"
+				RuntimeTypeInfo="false"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+				CompileAs="0"
+				CompileForArchitecture="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions=" /SUBSYSTEM:WINDOWSCE,5.02"
+				OutputFile="$(OutDir)\mozce_shunt.dll"
+				ImportLibrary="$(OutDir)\mozce_shunt.lib"
+				TargetMachine="0"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy &quot;$(TargetDir)$(TargetName).dll&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;copy &quot;$(TargetDir)$(TargetName).lib&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory=""
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Windows Mobile 5.0 Pocket PC SDK (ARMV4I)"
+			OutputDirectory="$(PlatformName)\Debug"
+			IntermediateDirectory="$(PlatformName)\Debug"
+			ConfigurationType="4"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);_DEBUG;DEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
+				MinimalRebuild="true"
+				ExceptionHandling="0"
+				RuntimeLibrary="1"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				TreatWChar_tAsBuiltInType="false"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				AdditionalOptions=" /subsystem:windowsce,5.01 /machine:THUMB"
+				OutputFile="$(InputDir)/shunt_dbg.lib"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory=""
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Windows Mobile 5.0 Pocket PC SDK (ARMV4I)"
+			OutputDirectory="$(PlatformName)\Release"
+			IntermediateDirectory="$(PlatformName)\Release"
+			ConfigurationType="4"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="2"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);NDEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
+				ExceptionHandling="0"
+				RuntimeLibrary="0"
+				BufferSecurityCheck="false"
+				TreatWChar_tAsBuiltInType="false"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				AdditionalOptions=" /subsystem:windowsce,5.01 /machine:THUMB"
+				OutputFile="$(InputDir)/shunt.lib"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory=""
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Windows Mobile 5.0 Smartphone SDK (ARMV4I)"
+			OutputDirectory="Windows Mobile 5.0 Smartphone SDK (ARMV4I)\$(ConfigurationName)"
+			IntermediateDirectory="Windows Mobile 5.0 Smartphone SDK (ARMV4I)\$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="1"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);_DEBUG;DEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
+				MinimalRebuild="true"
+				ExceptionHandling="0"
+				RuntimeLibrary="1"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				TreatWChar_tAsBuiltInType="false"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				AdditionalOptions=" /subsystem:windowsce,5.01 /machine:THUMB"
+				OutputFile="$(InputDir)/shunt_dbg.lib"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory=""
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Windows Mobile 5.0 Smartphone SDK (ARMV4I)"
+			OutputDirectory="Windows Mobile 5.0 Smartphone SDK (ARMV4I)\$(ConfigurationName)"
+			IntermediateDirectory="Windows Mobile 5.0 Smartphone SDK (ARMV4I)\$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="1"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="2"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);NDEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
+				ExceptionHandling="0"
+				RuntimeLibrary="0"
+				BufferSecurityCheck="false"
+				TreatWChar_tAsBuiltInType="false"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				AdditionalOptions=" /subsystem:windowsce,5.01 /machine:THUMB"
+				OutputFile="$(InputDir)/shunt.lib"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory=""
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
+			>
+			<File
+				RelativePath="..\..\map.cpp"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -r 17e9560465b0 build/wince/shunt/build/vs9/mozce_shunt_static.vcproj
--- a/build/wince/shunt/build/vs9/mozce_shunt_static.vcproj	Thu Oct 23 09:51:35 2008 -0700
+++ b/build/wince/shunt/build/vs9/mozce_shunt_static.vcproj	Thu Oct 30 05:41:44 2008 -0400
@@ -1,1261 +1,1069 @@
-<?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="9.00"
-	Name="mozce_shunt_static"
-	ProjectGUID="{082BAB06-D10F-4C57-B123-F84DC06C246D}"
-	RootNamespace="mozce_shunt_static"
-	Keyword="Win32Proj"
-	TargetFrameworkVersion="131072"
-	>
-	<Platforms>
-		<Platform
-			Name="Pocket PC 2003 (ARMV4)"
-		/>
-		<Platform
-			Name="Smartphone 2003 (ARMV4)"
-		/>
-		<Platform
-			Name="Windows Mobile 5.0 Pocket PC SDK (ARMV4I)"
-		/>
-		<Platform
-			Name="Windows Mobile 5.0 Smartphone SDK (ARMV4I)"
-		/>
-		<Platform
-			Name="Windows Mobile 6 Professional SDK (ARMV4I)"
-		/>
-		<Platform
-			Name="Windows Mobile 6 Standard SDK (ARMV4I)"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Pocket PC 2003 (ARMV4)"
-			OutputDirectory="Pocket PC 2003 (ARMV4)\$(ConfigurationName)"
-			IntermediateDirectory="Pocket PC 2003 (ARMV4)\$(ConfigurationName)"
-			ConfigurationType="4"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="1"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				ExecutionBucket="7"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\include"
-				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);_DEBUG;DEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
-				MinimalRebuild="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="1"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				TreatWChar_tAsBuiltInType="false"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(IntDir)"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				AdditionalOptions=" /subsystem:windowsce,5.01 /machine:THUMB"
-				OutputFile="$(InputDir)/shunt_dbg.lib"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCCodeSignTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-			<DeploymentTool
-				ForceDirty="-1"
-				RemoteDirectory=""
-				RegisterOutput="0"
-				AdditionalFiles=""
-			/>
-			<DebuggerTool
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|Smartphone 2003 (ARMV4)"
-			OutputDirectory="Smartphone 2003 (ARMV4)\$(ConfigurationName)"
-			IntermediateDirectory="Smartphone 2003 (ARMV4)\$(ConfigurationName)"
-			ConfigurationType="4"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="1"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				ExecutionBucket="7"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\include"
-				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);_DEBUG;DEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
-				MinimalRebuild="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="1"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				TreatWChar_tAsBuiltInType="false"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(IntDir)"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				AdditionalOptions=" /subsystem:windowsce,5.01 /machine:THUMB"
-				OutputFile="$(InputDir)/shunt_dbg.lib"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCCodeSignTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-			<DeploymentTool
-				ForceDirty="-1"
-				RemoteDirectory=""
-				RegisterOutput="0"
-				AdditionalFiles=""
-			/>
-			<DebuggerTool
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|Windows Mobile 5.0 Pocket PC SDK (ARMV4I)"
-			OutputDirectory="$(PlatformName)\Debug"
-			IntermediateDirectory="$(PlatformName)\Debug"
-			ConfigurationType="2"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				ExecutionBucket="7"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\include"
-				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);_DEBUG;DEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
-				MinimalRebuild="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="1"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				TreatWChar_tAsBuiltInType="false"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(IntDir)"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions=" /SUBSYSTEM:WINDOWSCE,5.01 /MACHINE:THUMB"
-				OutputFile="$(OutDir)\mozce_shunt.dll"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCCodeSignTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-			<DeploymentTool
-				ForceDirty="-1"
-				RemoteDirectory=""
-				RegisterOutput="0"
-				AdditionalFiles=""
-			/>
-			<DebuggerTool
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|Windows Mobile 5.0 Smartphone SDK (ARMV4I)"
-			OutputDirectory="Windows Mobile 5.0 Smartphone SDK (ARMV4I)\$(ConfigurationName)"
-			IntermediateDirectory="Windows Mobile 5.0 Smartphone SDK (ARMV4I)\$(ConfigurationName)"
-			ConfigurationType="2"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="1"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				ExecutionBucket="7"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\include"
-				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);_DEBUG;DEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
-				MinimalRebuild="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="1"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				TreatWChar_tAsBuiltInType="false"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(IntDir)"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions=" /SUBSYSTEM:WINDOWSCE,5.01 /MACHINE:THUMB"
-				OutputFile="$(OutDir)\mozce_shunt.dll"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCCodeSignTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-			<DeploymentTool
-				ForceDirty="-1"
-				RemoteDirectory=""
-				RegisterOutput="0"
-				AdditionalFiles=""
-			/>
-			<DebuggerTool
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|Windows Mobile 6 Professional SDK (ARMV4I)"
-			OutputDirectory="Windows Mobile 6 Professional SDK (ARMV4I)\$(ConfigurationName)"
-			IntermediateDirectory="Windows Mobile 6 Professional SDK (ARMV4I)\$(ConfigurationName)"
-			ConfigurationType="2"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="1"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				ExecutionBucket="7"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\include"
-				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);_DEBUG;DEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_SHUNT_EXPORTS;DEBUG_NSPR_ALL;TIMELINE;API_LOGGING;WINCE_MEMORY_CHECKPOINTING;SHUNT_LOG_ENABLED"
-				MinimalRebuild="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="1"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				TreatWChar_tAsBuiltInType="false"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				DebugInformationFormat="3"
-				CompileAs="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(IntDir)"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions=" /SUBSYSTEM:WINDOWSCE,5.02"
-				OutputFile="$(OutDir)\mozce_shunt.dll"
-				GenerateDebugInformation="true"
-				ImportLibrary="$(OutDir)\mozce_shunt.lib"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCCodeSignTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-				CommandLine="copy &quot;$(TargetDir)$(TargetName).dll&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;copy &quot;$(TargetDir)$(TargetName).lib&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;"
-			/>
-			<DeploymentTool
-				ForceDirty="-1"
-				RemoteDirectory="\"
-				RegisterOutput="0"
-				AdditionalFiles=""
-			/>
-			<DebuggerTool
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|Windows Mobile 6 Standard SDK (ARMV4I)"
-			OutputDirectory="Windows Mobile 6 Standard SDK (ARMV4I)\$(ConfigurationName)"
-			IntermediateDirectory="Windows Mobile 6 Standard SDK (ARMV4I)\$(ConfigurationName)"
-			ConfigurationType="2"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="1"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				ExecutionBucket="7"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\include"
-				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);_DEBUG;DEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_SHUNT_EXPORTS;DEBUG_NSPR_ALL;TIMELINE;API_LOGGING;WINCE_MEMORY_CHECKPOINTING;SHUNT_LOG_ENABLED"
-				MinimalRebuild="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="1"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				TreatWChar_tAsBuiltInType="false"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				DebugInformationFormat="3"
-				CompileAs="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(IntDir)"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions=" /SUBSYSTEM:WINDOWSCE,5.02"
-				OutputFile="$(OutDir)\mozce_shunt.dll"
-				GenerateDebugInformation="true"
-				ImportLibrary="$(OutDir)\mozce_shunt.lib"
-				TargetMachine="0"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCCodeSignTool"
-				AuthenticodeSignature="false"
-				ProvisionDevice="0"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-				CommandLine="copy &quot;$(TargetDir)$(TargetName).dll&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;copy &quot;$(TargetDir)$(TargetName).lib&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;"
-			/>
-			<DeploymentTool
-				ForceDirty="-1"
-				RemoteDirectory="\"
-				RegisterOutput="0"
-				AdditionalFiles=""
-			/>
-			<DebuggerTool
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Pocket PC 2003 (ARMV4)"
-			OutputDirectory="Pocket PC 2003 (ARMV4)\$(ConfigurationName)"
-			IntermediateDirectory="Pocket PC 2003 (ARMV4)\$(ConfigurationName)"
-			ConfigurationType="4"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="1"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				ExecutionBucket="7"
-				Optimization="2"
-				AdditionalIncludeDirectories="..\..\include"
-				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);NDEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
-				ExceptionHandling="1"
-				RuntimeLibrary="0"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				FloatingPointModel="2"
-				TreatWChar_tAsBuiltInType="false"
-				RuntimeTypeInfo="true"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				DebugInformationFormat="3"
-				CompileForArchitecture="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(IntDir)"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				AdditionalOptions=" /subsystem:windowsce,5.01 /machine:THUMB"
-				OutputFile="$(InputDir)/shunt.lib"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCCodeSignTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-			<DeploymentTool
-				ForceDirty="-1"
-				RemoteDirectory=""
-				RegisterOutput="0"
-				AdditionalFiles=""
-			/>
-			<DebuggerTool
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Smartphone 2003 (ARMV4)"
-			OutputDirectory="Smartphone 2003 (ARMV4)\$(ConfigurationName)"
-			IntermediateDirectory="Smartphone 2003 (ARMV4)\$(ConfigurationName)"
-			ConfigurationType="4"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="1"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				ExecutionBucket="7"
-				Optimization="2"
-				AdditionalIncludeDirectories="..\..\include"
-				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);NDEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
-				ExceptionHandling="1"
-				RuntimeLibrary="0"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				FloatingPointModel="2"
-				TreatWChar_tAsBuiltInType="false"
-				RuntimeTypeInfo="true"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				DebugInformationFormat="3"
-				CompileForArchitecture="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(IntDir)"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				AdditionalOptions=" /subsystem:windowsce,5.01 /machine:THUMB"
-				OutputFile="$(InputDir)/shunt.lib"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCCodeSignTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-			<DeploymentTool
-				ForceDirty="-1"
-				RemoteDirectory=""
-				RegisterOutput="0"
-				AdditionalFiles=""
-			/>
-			<DebuggerTool
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Windows Mobile 5.0 Pocket PC SDK (ARMV4I)"
-			OutputDirectory="$(PlatformName)\Release"
-			IntermediateDirectory="$(PlatformName)\Release"
-			ConfigurationType="2"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				ExecutionBucket="7"
-				Optimization="2"
-				AdditionalIncludeDirectories="..\..\include"
-				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);NDEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
-				ExceptionHandling="0"
-				RuntimeLibrary="0"
-				BufferSecurityCheck="false"
-				TreatWChar_tAsBuiltInType="false"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(IntDir)"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions=" /SUBSYSTEM:WINDOWSCE,5.01 /MACHINE:THUMB"
-				OutputFile="$(OutDir)\mozce_shunt.dll"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCCodeSignTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-			<DeploymentTool
-				ForceDirty="-1"
-				RemoteDirectory=""
-				RegisterOutput="0"
-				AdditionalFiles=""
-			/>
-			<DebuggerTool
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Windows Mobile 5.0 Smartphone SDK (ARMV4I)"
-			OutputDirectory="Windows Mobile 5.0 Smartphone SDK (ARMV4I)\$(ConfigurationName)"
-			IntermediateDirectory="Windows Mobile 5.0 Smartphone SDK (ARMV4I)\$(ConfigurationName)"
-			ConfigurationType="2"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="1"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				ExecutionBucket="7"
-				Optimization="2"
-				AdditionalIncludeDirectories="..\..\include"
-				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);NDEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
-				ExceptionHandling="0"
-				RuntimeLibrary="0"
-				BufferSecurityCheck="false"
-				TreatWChar_tAsBuiltInType="false"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(IntDir)"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions=" /SUBSYSTEM:WINDOWSCE,5.01 /MACHINE:THUMB"
-				OutputFile="$(OutDir)\mozce_shunt.dll"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCCodeSignTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-			<DeploymentTool
-				ForceDirty="-1"
-				RemoteDirectory=""
-				RegisterOutput="0"
-				AdditionalFiles=""
-			/>
-			<DebuggerTool
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Windows Mobile 6 Professional SDK (ARMV4I)"
-			OutputDirectory="Windows Mobile 6 Professional SDK (ARMV4I)\$(ConfigurationName)"
-			IntermediateDirectory="Windows Mobile 6 Professional SDK (ARMV4I)\$(ConfigurationName)"
-			ConfigurationType="2"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-				CommandLine=""
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="1"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				ExecutionBucket="7"
-				Optimization="2"
-				AdditionalIncludeDirectories="..\..\include"
-				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);NDEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_SHUNT_EXPORTS"
-				ExceptionHandling="1"
-				RuntimeLibrary="0"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				FloatingPointModel="2"
-				TreatWChar_tAsBuiltInType="false"
-				RuntimeTypeInfo="false"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				DebugInformationFormat="3"
-				CompileAs="0"
-				CompileForArchitecture="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(IntDir)"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions=" /SUBSYSTEM:WINDOWSCE,5.02"
-				OutputFile="$(OutDir)\mozce_shunt.dll"
-				ImportLibrary="$(OutDir)\mozce_shunt.lib"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCCodeSignTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-				CommandLine="copy &quot;$(TargetDir)$(TargetName).dll&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;copy &quot;$(TargetDir)$(TargetName).lib&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;"
-			/>
-			<DeploymentTool
-				ForceDirty="-1"
-				RemoteDirectory=""
-				RegisterOutput="0"
-				AdditionalFiles=""
-			/>
-			<DebuggerTool
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Windows Mobile 6 Standard SDK (ARMV4I)"
-			OutputDirectory="Windows Mobile 6 Standard SDK (ARMV4I)\$(ConfigurationName)"
-			IntermediateDirectory="Windows Mobile 6 Standard SDK (ARMV4I)\$(ConfigurationName)"
-			ConfigurationType="2"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-				CommandLine=""
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="1"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				ExecutionBucket="7"
-				Optimization="2"
-				AdditionalIncludeDirectories="..\..\include"
-				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);NDEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_SHUNT_EXPORTS"
-				ExceptionHandling="1"
-				RuntimeLibrary="0"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				FloatingPointModel="2"
-				TreatWChar_tAsBuiltInType="false"
-				RuntimeTypeInfo="false"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				DebugInformationFormat="3"
-				CompileAs="0"
-				CompileForArchitecture="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(IntDir)"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions=" /SUBSYSTEM:WINDOWSCE,5.02"
-				OutputFile="$(OutDir)\mozce_shunt.dll"
-				ImportLibrary="$(OutDir)\mozce_shunt.lib"
-				TargetMachine="0"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCCodeSignTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-				CommandLine="copy &quot;$(TargetDir)$(TargetName).dll&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;copy &quot;$(TargetDir)$(TargetName).lib&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;"
-			/>
-			<DeploymentTool
-				ForceDirty="-1"
-				RemoteDirectory=""
-				RegisterOutput="0"
-				AdditionalFiles=""
-			/>
-			<DebuggerTool
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
-			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
-			>
-			<File
-				RelativePath="..\..\a2w.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\assert.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\clipboard.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\direct.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\errno.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\io.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\map.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\mbstring.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\mozce_dbg.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\nclog.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\process.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\signal.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\stat.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\stdio.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\stdlib.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\string.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\time.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\w2a.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\win32.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\win32A.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\win32W.cpp"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl;inc;xsd"
-			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
-			>
-			<File
-				RelativePath="..\..\include\crtdbg.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\ddeml.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\direct.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\dlgs.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\errno.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\fcntl.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\intshcut.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\io.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\map.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\mbstring.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\mozce_defs.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\mozce_internal.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\mozce_shunt.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\new.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\process.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\rasdlg.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\signal.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\time_conversions.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\unistd.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\varargs.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\winresrc.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\winsock2.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\winspool.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\winsvc.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\zmouse.h"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Resource Files"
-			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
-			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
-			>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="mozce_shunt_static"
+	ProjectGUID="{082BAB06-D10F-4C57-B123-F84DC06C246D}"
+	RootNamespace="mozce_shunt_static"
+	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
+	>
+	<Platforms>
+		<Platform
+			Name="Pocket PC 2003 (ARMV4)"
+		/>
+		<Platform
+			Name="Smartphone 2003 (ARMV4)"
+		/>
+		<Platform
+			Name="Windows Mobile 5.0 Pocket PC SDK (ARMV4I)"
+		/>
+		<Platform
+			Name="Windows Mobile 5.0 Smartphone SDK (ARMV4I)"
+		/>
+		<Platform
+			Name="Windows Mobile 6 Professional SDK (ARMV4I)"
+		/>
+		<Platform
+			Name="Windows Mobile 6 Standard SDK (ARMV4I)"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Pocket PC 2003 (ARMV4)"
+			OutputDirectory="Pocket PC 2003 (ARMV4)\$(ConfigurationName)"
+			IntermediateDirectory="Pocket PC 2003 (ARMV4)\$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="1"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);_DEBUG;DEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
+				MinimalRebuild="true"
+				ExceptionHandling="0"
+				RuntimeLibrary="1"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				TreatWChar_tAsBuiltInType="false"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				AdditionalOptions=" /subsystem:windowsce,5.01 /machine:THUMB"
+				OutputFile="$(InputDir)/shunt_dbg.lib"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory=""
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Smartphone 2003 (ARMV4)"
+			OutputDirectory="Smartphone 2003 (ARMV4)\$(ConfigurationName)"
+			IntermediateDirectory="Smartphone 2003 (ARMV4)\$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="1"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);_DEBUG;DEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
+				MinimalRebuild="true"
+				ExceptionHandling="0"
+				RuntimeLibrary="1"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				TreatWChar_tAsBuiltInType="false"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				AdditionalOptions=" /subsystem:windowsce,5.01 /machine:THUMB"
+				OutputFile="$(InputDir)/shunt_dbg.lib"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory=""
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Windows Mobile 5.0 Pocket PC SDK (ARMV4I)"
+			OutputDirectory="$(PlatformName)\Debug"
+			IntermediateDirectory="$(PlatformName)\Debug"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);_DEBUG;DEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
+				MinimalRebuild="true"
+				ExceptionHandling="0"
+				RuntimeLibrary="1"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				TreatWChar_tAsBuiltInType="false"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions=" /SUBSYSTEM:WINDOWSCE,5.01 /MACHINE:THUMB"
+				OutputFile="$(OutDir)\mozce_shunt.dll"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory=""
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Windows Mobile 5.0 Smartphone SDK (ARMV4I)"
+			OutputDirectory="Windows Mobile 5.0 Smartphone SDK (ARMV4I)\$(ConfigurationName)"
+			IntermediateDirectory="Windows Mobile 5.0 Smartphone SDK (ARMV4I)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="1"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);_DEBUG;DEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
+				MinimalRebuild="true"
+				ExceptionHandling="0"
+				RuntimeLibrary="1"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				TreatWChar_tAsBuiltInType="false"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions=" /SUBSYSTEM:WINDOWSCE,5.01 /MACHINE:THUMB"
+				OutputFile="$(OutDir)\mozce_shunt.dll"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory=""
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Windows Mobile 6 Professional SDK (ARMV4I)"
+			OutputDirectory="Windows Mobile 6 Professional SDK (ARMV4I)\$(ConfigurationName)"
+			IntermediateDirectory="Windows Mobile 6 Professional SDK (ARMV4I)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="1"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);_DEBUG;DEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_SHUNT_EXPORTS;DEBUG_NSPR_ALL;TIMELINE;API_LOGGING;WINCE_MEMORY_CHECKPOINTING;SHUNT_LOG_ENABLED"
+				MinimalRebuild="true"
+				ExceptionHandling="0"
+				RuntimeLibrary="1"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				TreatWChar_tAsBuiltInType="false"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions=" /SUBSYSTEM:WINDOWSCE,5.02"
+				OutputFile="$(OutDir)\mozce_shunt.dll"
+				GenerateDebugInformation="true"
+				ImportLibrary="$(OutDir)\mozce_shunt.lib"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy &quot;$(TargetDir)$(TargetName).dll&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;copy &quot;$(TargetDir)$(TargetName).lib&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory="\"
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Windows Mobile 6 Standard SDK (ARMV4I)"
+			OutputDirectory="Windows Mobile 6 Standard SDK (ARMV4I)\$(ConfigurationName)"
+			IntermediateDirectory="Windows Mobile 6 Standard SDK (ARMV4I)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="1"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);_DEBUG;DEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_SHUNT_EXPORTS;DEBUG_NSPR_ALL;TIMELINE;API_LOGGING;WINCE_MEMORY_CHECKPOINTING;SHUNT_LOG_ENABLED"
+				MinimalRebuild="true"
+				ExceptionHandling="0"
+				RuntimeLibrary="1"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				TreatWChar_tAsBuiltInType="false"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions=" /SUBSYSTEM:WINDOWSCE,5.02"
+				OutputFile="$(OutDir)\mozce_shunt.dll"
+				GenerateDebugInformation="true"
+				ImportLibrary="$(OutDir)\mozce_shunt.lib"
+				TargetMachine="0"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+				AuthenticodeSignature="false"
+				ProvisionDevice="0"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy &quot;$(TargetDir)$(TargetName).dll&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;copy &quot;$(TargetDir)$(TargetName).lib&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory="\"
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Pocket PC 2003 (ARMV4)"
+			OutputDirectory="Pocket PC 2003 (ARMV4)\$(ConfigurationName)"
+			IntermediateDirectory="Pocket PC 2003 (ARMV4)\$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="1"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="2"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);NDEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
+				ExceptionHandling="1"
+				RuntimeLibrary="0"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				FloatingPointModel="2"
+				TreatWChar_tAsBuiltInType="false"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+				CompileForArchitecture="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				AdditionalOptions=" /subsystem:windowsce,5.01 /machine:THUMB"
+				OutputFile="$(InputDir)/shunt.lib"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory=""
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Smartphone 2003 (ARMV4)"
+			OutputDirectory="Smartphone 2003 (ARMV4)\$(ConfigurationName)"
+			IntermediateDirectory="Smartphone 2003 (ARMV4)\$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="1"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="2"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);NDEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
+				ExceptionHandling="1"
+				RuntimeLibrary="0"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				FloatingPointModel="2"
+				TreatWChar_tAsBuiltInType="false"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+				CompileForArchitecture="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				AdditionalOptions=" /subsystem:windowsce,5.01 /machine:THUMB"
+				OutputFile="$(InputDir)/shunt.lib"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory=""
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Windows Mobile 5.0 Pocket PC SDK (ARMV4I)"
+			OutputDirectory="$(PlatformName)\Release"
+			IntermediateDirectory="$(PlatformName)\Release"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="2"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);NDEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
+				ExceptionHandling="0"
+				RuntimeLibrary="0"
+				BufferSecurityCheck="false"
+				TreatWChar_tAsBuiltInType="false"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions=" /SUBSYSTEM:WINDOWSCE,5.01 /MACHINE:THUMB"
+				OutputFile="$(OutDir)\mozce_shunt.dll"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory=""
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Windows Mobile 5.0 Smartphone SDK (ARMV4I)"
+			OutputDirectory="Windows Mobile 5.0 Smartphone SDK (ARMV4I)\$(ConfigurationName)"
+			IntermediateDirectory="Windows Mobile 5.0 Smartphone SDK (ARMV4I)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="1"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="2"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);NDEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
+				ExceptionHandling="0"
+				RuntimeLibrary="0"
+				BufferSecurityCheck="false"
+				TreatWChar_tAsBuiltInType="false"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions=" /SUBSYSTEM:WINDOWSCE,5.01 /MACHINE:THUMB"
+				OutputFile="$(OutDir)\mozce_shunt.dll"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory=""
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Windows Mobile 6 Professional SDK (ARMV4I)"
+			OutputDirectory="Windows Mobile 6 Professional SDK (ARMV4I)\$(ConfigurationName)"
+			IntermediateDirectory="Windows Mobile 6 Professional SDK (ARMV4I)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+				CommandLine=""
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="1"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="2"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);NDEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_SHUNT_EXPORTS"
+				ExceptionHandling="1"
+				RuntimeLibrary="0"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				FloatingPointModel="2"
+				TreatWChar_tAsBuiltInType="false"
+				RuntimeTypeInfo="false"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+				CompileAs="0"
+				CompileForArchitecture="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions=" /SUBSYSTEM:WINDOWSCE,5.02"
+				OutputFile="$(OutDir)\mozce_shunt.dll"
+				ImportLibrary="$(OutDir)\mozce_shunt.lib"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy &quot;$(TargetDir)$(TargetName).dll&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;copy &quot;$(TargetDir)$(TargetName).lib&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory=""
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Windows Mobile 6 Standard SDK (ARMV4I)"
+			OutputDirectory="Windows Mobile 6 Standard SDK (ARMV4I)\$(ConfigurationName)"
+			IntermediateDirectory="Windows Mobile 6 Standard SDK (ARMV4I)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+				CommandLine=""
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="1"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="2"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);NDEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_SHUNT_EXPORTS"
+				ExceptionHandling="1"
+				RuntimeLibrary="0"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				FloatingPointModel="2"
+				TreatWChar_tAsBuiltInType="false"
+				RuntimeTypeInfo="false"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+				CompileAs="0"
+				CompileForArchitecture="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions=" /SUBSYSTEM:WINDOWSCE,5.02"
+				OutputFile="$(OutDir)\mozce_shunt.dll"
+				ImportLibrary="$(OutDir)\mozce_shunt.lib"
+				TargetMachine="0"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy &quot;$(TargetDir)$(TargetName).dll&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;copy &quot;$(TargetDir)$(TargetName).lib&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory=""
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
+			>
+			<File
+				RelativePath="..\..\map.cpp"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -r 17e9560465b0 build/wince/shunt/clipboard.cpp
--- a/build/wince/shunt/clipboard.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,282 +0,0 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is WinCE Shunt
- *
- * The Initial Developer of the Original Code is 
- * Douglas F. Turner II  <dougt@meer.net>
- * Portions created by the Initial Developer are Copyright (C) 2005
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-#define OleSetClipboard __not_supported_on_device_OleSetClipboard
-#define OleGetClipboard __not_supported_on_device_OleGetClipboard
-#define OleFlushClipboard __not_supported_on_device_OleFlushClipboard
-
-#include "mozce_internal.h"
-
-#undef OleSetClipboard
-#undef OleGetClipboard
-#undef OleFlushClipboard
-
-extern "C" {
-#if 0
-}
-#endif
-
-static IDataObject* gDataObject = NULL;
-static HWND gClipboardWND = NULL; /* we may need to free this */
-
-void oleSetup()
-{
-  if (gClipboardWND)
-    return;
-  
-  WNDCLASS wndclass;
-  ZeroMemory( &wndclass, sizeof(WNDCLASS));
-  
-  
-  wndclass.style          = CS_GLOBALCLASS;
-  wndclass.lpfnWndProc    = DefWindowProc;
-  wndclass.lpszClassName  = L"OLE_CLIPBOARD";
-  
-  RegisterClass(&wndclass);
-  
-  gClipboardWND = CreateWindow(L"OLE_Clipboard",
-                         0,
-                         0,
-                         CW_USEDEFAULT, CW_USEDEFAULT,
-                         CW_USEDEFAULT, CW_USEDEFAULT,
-                         0,
-                         0,
-                         0,
-                         0);
-}
-
-class ClipDataObj : public IDataObject
-{
-public:
-  ClipDataObj()
-  {
-    mRefCnt = 0;
-  } 
-  
-  ~ClipDataObj()
-  {  
-  }
-  
-  STDMETHODIMP_(ULONG) AddRef()
-  {
-    mRefCnt++; 
-    return mRefCnt; 
-  }
-  
-  STDMETHODIMP QueryInterface(REFIID iid, void **ppvObject)
-  {
-    // check to see what interface has been requested
-    if(iid == IID_IDataObject || iid == IID_IUnknown)
-    {
-      AddRef();
-      *ppvObject = this;
-      return S_OK;
-    }
-    else
-    {
-      *ppvObject = 0;
-      return E_NOINTERFACE;
-    }
-  }
-  
-  STDMETHODIMP_(ULONG) Release()
-  {
-    mRefCnt--;
-    if (mRefCnt == 0)
-    {
-      delete this;
-      return 0;
-    }
-    
-    return mRefCnt;
-  }
-  
-  STDMETHODIMP GetData	(FORMATETC *pFormatEtc, STGMEDIUM *pMedium)
-  {
-    
-    oleSetup();
-    
-    BOOL b = OpenClipboard(gClipboardWND);
-    
-    if (!b)
-      return E_FAIL;
-    
-    HANDLE hData = GetClipboardData(pFormatEtc->cfFormat);
-    
-    LPVOID src = GlobalLock(hData);
-    if(src) {
-      ULONG  size  = GlobalSize(hData);
-      HANDLE hDest = GlobalAlloc(GHND, size);
-      LPVOID dest  = GlobalLock(hDest);
-      memcpy(dest, src, size);
-      
-      GlobalUnlock(hDest);
-      GlobalUnlock(hData);
-      
-      hData = hDest;
-    }
-    
-    pMedium->tymed = (hData == 0) ? TYMED_NULL : TYMED_HGLOBAL;
-    pMedium->hGlobal = (HGLOBAL)hData;
-    pMedium->pUnkForRelease = NULL;
-    
-    return S_OK;
-  }
-  
-  STDMETHODIMP GetDataHere (LPFORMATETC pFE, LPSTGMEDIUM pSTM)
-  {
-    return DATA_E_FORMATETC;
-  }
-  
-  STDMETHODIMP QueryGetData (LPFORMATETC pFE)
-  {
-    return S_OK;
-  }
-  
-  STDMETHODIMP GetCanonicalFormatEtc (LPFORMATETC pFE, LPFORMATETC pCanonFE)
-  {
-    pFE->ptd = NULL;
-    return E_NOTIMPL;
-  }
-  
-  STDMETHODIMP SetData	(LPFORMATETC pFE, LPSTGMEDIUM pSTM, BOOL release)
-  {
-    return E_NOTIMPL;
-  }
-  
-  STDMETHODIMP EnumFormatEtc	(DWORD dwDirection, LPENUMFORMATETC* ppEnum)
-  {
-    return E_NOTIMPL;
-  }
-  
-  STDMETHODIMP DAdvise	(LPFORMATETC pFE, DWORD flags, LPADVISESINK pAdvise, DWORD* pConn)
-  {
-    return OLE_E_ADVISENOTSUPPORTED;
-  }
-  
-  STDMETHODIMP DUnadvise (DWORD pConn)
-  {
-    return OLE_E_ADVISENOTSUPPORTED;
-  }
-  
-  STDMETHODIMP EnumDAdvise (LPENUMSTATDATA *ppEnum)
-  {
-    return OLE_E_ADVISENOTSUPPORTED;
-  }
-private:
-  LONG	   mRefCnt;
-};
-
-
-
-MOZCE_SHUNT_API HRESULT OleSetClipboard(IDataObject * pDataObj)
-{
-	oleSetup();
-  
-  if (gDataObject)
-    gDataObject->Release();
-  
-  gDataObject = pDataObj;
-  
-  if (pDataObj) 
-  {
-    BOOL b = OpenClipboard(gClipboardWND);
-    
-    if (!b)
-      return E_FAIL;
-    
-    EmptyClipboard();
-    
-    pDataObj->AddRef();
-    
-    IEnumFORMATETC* enumerator = NULL;
-    pDataObj->EnumFormatEtc(DATADIR_GET, &enumerator);
-    if (!enumerator)
-      return S_OK;
-    
-    FORMATETC etc;
-    
-    while (S_OK == enumerator->Next(1, &etc, NULL))
-    {
-      if ( etc.tymed == TYMED_HGLOBAL )
-      {
-
-		STGMEDIUM medium;
-		pDataObj->GetData(&etc, &medium);
-        SetClipboardData( etc.cfFormat, medium.hGlobal);
-      }
-    }
-    
-    enumerator->Release();
-    
-    CloseClipboard();
-    
-  }
-  return S_OK;
-}
-
-// dougt??  do we need this clipboard function
-MOZCE_SHUNT_API HRESULT OleGetClipboard(IDataObject ** pDataObj)
-{
-    oleSetup();
-  
-  if (pDataObj)
-    *pDataObj = gDataObject;
-  
-  if (!*pDataObj)
-  {
-    *pDataObj = new ClipDataObj();
-    if (!*pDataObj)
-      return E_FAIL;
-
-    gDataObject = *pDataObj;
-  }
-  
-  (*pDataObj)->AddRef();
-  return S_OK;
-}
-
-MOZCE_SHUNT_API HRESULT OleFlushClipboard()
-{
-    oleSetup();
-  
-  OleSetClipboard(NULL);
-  return S_OK;
-}
-
-#if 0
-{
-#endif
-} /* extern "C" */
diff -r 17e9560465b0 build/wince/shunt/direct.cpp
--- a/build/wince/shunt/direct.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,100 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code, released
- * Jan 28, 2003.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 2003
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Garrett Arch Blythe, 28-January-2003
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#include "mozce_internal.h"
-
-
-extern "C" {
-#if 0
-}
-#endif
-
-
-MOZCE_SHUNT_API int mkdir(const char* inDirname)
-{
-    WINCE_LOG_API_CALL("mkdir called\n");
-    
-    int retval = -1;
-    
-    if(NULL != inDirname)
-    {
-        unsigned short wDirname[MAX_PATH];
-        
-        if(0 != a2w_buffer(inDirname, -1, wDirname, sizeof(wDirname) / sizeof(unsigned short)))
-        {
-            if(FALSE != CreateDirectoryW(wDirname, NULL))
-            {
-                retval = 0;
-            }
-        }
-    }
-    
-    return retval;
-}
-
-
-MOZCE_SHUNT_API int rmdir(const char* inDirname)
-{
-    WINCE_LOG_API_CALL_1("rmdir called (%s)\n", inDirname);
-    
-    int retval = -1;
-    
-    if(NULL != inDirname)
-    {
-        unsigned short wDirname[MAX_PATH];
-        
-        if(0 != a2w_buffer(inDirname, -1, wDirname, sizeof(wDirname) / sizeof(unsigned short)))
-        {
-            if(FALSE != RemoveDirectoryW(wDirname))
-            {
-                retval = 0;
-            }
-        }
-    }
-    
-    return retval;
-}
-
-
-#if 0
-{
-#endif
-} /* extern "C" */
-
diff -r 17e9560465b0 build/wince/shunt/errno.cpp
--- a/build/wince/shunt/errno.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,55 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code, released
- * Jan 28, 2003.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 2003
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Garrett Arch Blythe, 28-January-2003
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#include "mozce_internal.h"
-
-extern "C" {
-#if 0
-}
-#endif
-
-MOZCE_SHUNT_API int errno = 0;
-
-void nevercalled_but_needed_to_export_errno() {}
-#if 0
-{
-#endif
-} /* extern "C" */
-
diff -r 17e9560465b0 build/wince/shunt/include/aclapi.h
--- a/build/wince/shunt/include/aclapi.h	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,2 +0,0 @@
-#include "mozce_shunt.h"
-
diff -r 17e9560465b0 build/wince/shunt/include/direct.h
--- a/build/wince/shunt/include/direct.h	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,1 +0,0 @@
-#include "mozce_shunt.h"
diff -r 17e9560465b0 build/wince/shunt/include/dlgs.h
--- a/build/wince/shunt/include/dlgs.h	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,1 +0,0 @@
-#include "mozce_shunt.h"
diff -r 17e9560465b0 build/wince/shunt/include/errno.h
--- a/build/wince/shunt/include/errno.h	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,1 +0,0 @@
-#include "mozce_shunt.h"
diff -r 17e9560465b0 build/wince/shunt/include/fcntl.h
--- a/build/wince/shunt/include/fcntl.h	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,1 +0,0 @@
-#include "mozce_shunt.h"
diff -r 17e9560465b0 build/wince/shunt/include/intshcut.h
--- a/build/wince/shunt/include/intshcut.h	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,1 +0,0 @@
-#include "mozce_shunt.h"
diff -r 17e9560465b0 build/wince/shunt/include/io.h
--- a/build/wince/shunt/include/io.h	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,1 +0,0 @@
-#include "mozce_shunt.h"
diff -r 17e9560465b0 build/wince/shunt/include/map.h
--- a/build/wince/shunt/include/map.h	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,45 +0,0 @@
-#ifndef mozce_map_h
-#define mozce_map_h
-
-extern "C" {
-#if 0
-}
-#endif
-struct mapping{
-char* key;
-char* value;
-mapping* next;
-};
-
-
-int map_put(const char* key,const char* val);
-char*  map_get(const char* key);
-static int init_i =1;
-static mapping initial_map[] = {
-#ifdef DEBUG_NSPR_ALL
-    {"NSPR_LOG_MODULES", "all:5",initial_map + (init_i++)},
-    {"NSPR_LOG_FILE","nspr.log",initial_map + (init_i++)},
-#endif  
-#ifdef TIMELINE
-    {"NS_TIMELINE_LOG_FILE","\\bin\\timeline.log",initial_map + (init_i++)},
-    {"NS_TIMELINE_ENABLE", "1",initial_map + (init_i++)},
-#endif
-    {"tmp", "/Temp",initial_map + (init_i++)},
-    {"GRE_HOME",".",initial_map + (init_i++)},
-    {"NSS_DEFAULT_DB_TYPE", "sql",initial_map + (init_i++)},
-    {"NSPR_FD_CACHE_SIZE_LOW", "10",initial_map + (init_i++)},              
-    {"NSPR_FD_CACHE_SIZE_HIGH", "30",initial_map + (init_i++)},
-    {"XRE_PROFILE_PATH", "\\Application Data\\Mozilla\\Profiles",initial_map + (init_i++)},
-    {"XRE_PROFILE_LOCAL_PATH","./profile",initial_map + (init_i++)},
-    {"XRE_PROFILE_NAME","default",0}
-};
-
-static mapping* head = initial_map;
-
-
-#if 0
-{
-#endif
-} /* extern "C" */
-
-#endif
diff -r 17e9560465b0 build/wince/shunt/include/mbstring.h
--- a/build/wince/shunt/include/mbstring.h	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,1 +0,0 @@
-#include "mozce_shunt.h"
diff -r 17e9560465b0 build/wince/shunt/include/mozce_defs.h
--- a/build/wince/shunt/include/mozce_defs.h	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,830 +0,0 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is MOZCE Lib.
- *
- * The Initial Developer of the Original Code is Doug Turner <dougt@meer.net>.
-
- * Portions created by the Initial Developer are Copyright (C) 2005
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#ifndef _MOZCE_DEFS
-#define _MOZCE_DEFS
-
-#include <bldver.h> // for build version macros
-
-//#ifndef MOZCE_STATIC_BUILD
-#ifdef MOZCE_SHUNT_EXPORTS
-#define MOZCE_SHUNT_API __declspec(dllexport)
-#else
-#define MOZCE_SHUNT_API __declspec(dllimport)
-#endif
-//#else
-//#define MOZCE_SHUNT_API
-//#endif
-
-//#define USE_NC_LOGGING 1
-
-#define NOMINMAX
-
-#ifndef XP_WIN
-#define XP_WIN
-#endif
-
-#ifndef XP_WIN32
-#define XP_WIN32 1
-#endif
-
-#include <windows.h>
-
-#ifdef HINSTANCE_ERROR
-#undef HINSTANCE_ERROR
-#endif
-#define HINSTANCE_ERROR -1
-
-#ifdef IDI_APPLICATION
-#undef IDI_APPLICATION
-#endif
-#ifdef RC_INVOKED
-#define IDI_APPLICATION 32512
-#else
-#define IDI_APPLICATION MAKEINTRESOURCE(32512)
-#endif
-
-//////////////////////////////////////////////////////////
-// Various Definations
-//////////////////////////////////////////////////////////
-
-// From errno.h
-#define EPERM           1
-#define ENOENT          2
-#define ESRCH           3
-#define EINTR           4
-#define EIO             5
-#define ENXIO           6
-#define E2BIG           7
-#define ENOEXEC         8
-#define EBADF           9
-#define ECHILD          10
-#define EAGAIN          11
-#define ENOMEM          12
-#define EACCES          13
-#define EFAULT          14
-#define EBUSY           16
-#define EEXIST          17
-#define EXDEV           18
-#define ENODEV          19
-#define ENOTDIR         20
-#define EISDIR          21
-#define EINVAL          22
-#define ENFILE          23
-#define EMFILE          24
-#define ENOTTY          25
-#define EFBIG           27
-#define ENOSPC          28
-#define ESPIPE          29
-#define EROFS           30
-#define EMLINK          31
-#define EPIPE           32
-#define EDOM            33
-#define ERANGE          34
-#define EDEADLK         36
-#ifndef ENAMETOOLONG
-#define ENAMETOOLONG    38
-#endif
-#define ENOLCK          39
-#define ENOSYS          40
-#ifndef ENOTEMPTY
-#define ENOTEMPTY       41
-#endif
-// From cderr.h
-#ifdef FNERR_INVALIDFILENAME
-#undef FNERR_INVALIDFILENAME
-#endif
-#define FNERR_INVALIDFILENAME  0x3002
-
-// From signal.h
-#define SIGABRT         0
-#define SIGSEGV         1
-#define _SIGCOUNT       2 /* LAST ONE, SIZES BUFFER */
-
-// From stdio.h
-
-#define _MAX_FNAME     256
-
-#define BUFSIZ 512
-#define O_RDONLY       0x0000  // open for reading only
-#define O_WRONLY       0x0001  // open for writing only
-#define O_RDWR         0x0002  // open for reading and writing
-#define O_APPEND       0x0008  // writes done at eof
-
-#define O_TEXT         0x4000  // file mode is text (translated)
-#define O_BINARY       0x8000  // file mode is binary (untranslated)
-
-#define O_CREAT        0x0100  // create and open file
-#define O_TRUNC        0x0200  // open and truncate
-#define O_EXCL         0x0400  // open only if file doesn't already exist
-
-#define _O_TEMPORARY    0x0040  // temporary file bit
-
-#define _O_CREAT        O_CREAT
-#define _O_TRUNC        O_TRUNC
-#define _O_WRONLY       O_WRONLY
-
-#define _IONBF          0x0004
-
-// From stdlib.h
-#define _MAX_PATH       MAX_PATH
-
-// From sys/types.h
-typedef int ptrdiff_t;
-typedef long _off_t;
-typedef long off_t;
-
-// Not defined anywhere
-typedef INT_PTR intptr_t; 
-
-// From sys/stat.h
-#if !defined(_STAT_DEFINED)
-#define _STAT_DEFINED
-#define _S_IFDIR    0040000 /* stat, is a directory */
-#define _S_IFREG    0100000 /* stat, is a normal file */
-#define _S_IREAD    0000400 /* stat, can read */
-#define _S_IWRITE   0000200 /* stat, can write */
-#define _S_IEXEC    0000100
-
-#define S_IFREG     0x8000
-
-struct stat
-{
-    unsigned short st_mode;
-    _off_t st_size;
-    time_t st_ctime;
-    time_t st_atime;
-    time_t st_mtime;
-};
-
-#define _stat stat
-#endif /* _STAT_DEFINED */
-
-#ifdef HANDLE_FLAG_INHERIT
-#undef HANDLE_FLAG_INHERIT
-#endif
-#define HANDLE_FLAG_INHERIT 0x00000001
-
-
-typedef struct GLYPHMETRICS 
-{ 
-  UINT  gmBlackBoxX; 
-  UINT  gmBlackBoxY; 
-  POINT gmptGlyphOrigin; 
-  short gmCellIncX; 
-  short gmCellIncY; 
-} GLYPHMETRICS;
-
-typedef struct tagWCRANGE {
-  WCHAR  wcLow;
-  USHORT cGlyphs;
-} WCRANGE, *PWCRANGE;
-
-typedef struct tagGLYPHSET {
-  DWORD    cbThis;
-  DWORD    flAccel;
-  DWORD    cGlyphsSupported;
-  DWORD    cRanges;
-  WCRANGE  ranges[1];
-} GLYPHSET, *PGLYPHSET;
-
-#define SW_SHOWDEFAULT 0
-#define SW_SHOWMINIMIZED 2 
-#define GGO_METRICS 0
-/*really defined as 1, but we cant do glyphs on wince */
-#define GGO_GLYPH_INDEX 0 
-
-/****************************************************************************
-**  exdispid.h
-**
-**  ??? Wondering what these really should be.
-****************************************************************************/
-#define DISPID_QUIT                     (__LINE__ + 3000) /* 103 */
-#define DISPID_PROGRESSCHANGE           (__LINE__ + 3000) /* 108 */
-#define DISPID_WINDOWMOVE               (__LINE__ + 3000) /* 109 */
-#define DISPID_WINDOWRESIZE             (__LINE__ + 3000) /* 110 */
-#define DISPID_WINDOWACTIVATE           (__LINE__ + 3000) /* 111 */
-
-#define CBM_INIT 4
-
-#ifndef MM_TEXT
-#define MM_TEXT             1
-#endif
-
-#ifndef SM_CYVTHUMB
-#define SM_CYVTHUMB 9
-#endif
-
-#ifndef SM_CXHTHUMB
-#define SM_CXHTHUMB 10
-#endif
-
-#ifndef DFCS_SCROLLSIZEGRIP
-#define DFCS_SCROLLSIZEGRIP     0x0008
-#endif
-
-
-#ifndef RDW_NOINTERNALPAINT
-#define RDW_NOINTERNALPAINT 0
-#endif
-
-#ifndef LR_LOADFROMFILE
-#define LR_LOADFROMFILE 0
-#endif
-
-#ifndef MA_NOACTIVATE
-#define MA_NOACTIVATE 1
-#endif
-
-#ifndef MA_ACTIVATE
-#define MA_ACTIVATE 1
-#endif
-
-typedef struct WINDOWPLACEMENT
-{
-  UINT  length;
-  UINT  flags;
-  UINT  showCmd;
-  POINT ptMinPosition;
-  POINT ptMaxPosition;
-  RECT  rcNormalPosition;
-} WINDOWPLACEMENT, *PWINDOWPLACEMENT, *LPWINDOWPLACEMENT;
-
-typedef void (*_sigsig)(int inSignal);
-
-
-typedef struct FIXED { 
-  WORD  fract; 
-  short value; 
-} FIXED; 
-
-typedef struct MAT2 { 
-  FIXED eM11; 
-  FIXED eM12; 
-  FIXED eM21; 
-  FIXED eM22; 
-} MAT2; 
-
-#define AC_SRC_OVER                 0x00
-
-//
-// alpha format flags
-//
-
-#define AC_SRC_ALPHA                0x01
-
-  
-struct color{
-    unsigned char Red;
-    unsigned char Green;
-    unsigned char Blue;
-    double Alpha;
-};
-
-#ifndef SEE_MASK_FLAG_DDEWAIT
-#define SEE_MASK_FLAG_DDEWAIT   0
-#endif
-
-#ifndef SEE_MASK_INVOKEIDLIST
-#define SEE_MASK_INVOKEIDLIST   0
-#endif
-
-
-
-// if using WINCE 5.0 SDK, you need these:
-#define LPRASPBDLG void*
-#define LPRASDIALDLG void*
-
-/* Graphics Modes */
-#define GM_COMPATIBLE       1
-#define GM_ADVANCED         2
-
-//
-// usp10.h: unicode
-//
-typedef void *SCRIPT_CACHE; 
-
-typedef struct tag_SCRIPT_STATE { 
-  WORD uBidiLevel :5; 
-  WORD fOverrideDirection :1; 
-  WORD fInhibitSymSwap :1; 
-  WORD fCharShape :1; 
-  WORD fDigitSubstitute :1; 
-  WORD fInhibitLigate :1; 
-  WORD fDisplayZWG :1; 
-  WORD fArabicNumContext :1; 
-  WORD fGcpClusters :1; 
-  WORD fReserved :1; 
-  WORD fEngineReserved :2; 
-} SCRIPT_STATE;
-
-typedef struct tag_SCRIPT_ANALYSIS {
-  WORD eScript      :10; 
-  WORD fRTL          :1; 
-  WORD fLayoutRTL    :1; 
-  WORD fLinkBefore   :1; 
-  WORD fLinkAfter    :1; 
-  WORD fLogicalOrder :1; 
-  WORD fNoGlyphIndex :1; 
-  SCRIPT_STATE s ; 
-} SCRIPT_ANALYSIS;
-
-typedef struct tag_SCRIPT_ITEM { 
-  int iCharPos; 
-  SCRIPT_ANALYSIS a; 
-} SCRIPT_ITEM;
-
-typedef struct {
-  int   cBytes; 
-  WORD  wgBlank; 
-  WORD  wgDefault; 
-  WORD  wgInvalid; 
-  WORD  wgKashida; 
-  int   iKashidaWidth; 
-} SCRIPT_FONTPROPERTIES;
-
-typedef struct {
-  DWORD   langid              :16;  
-  DWORD   fNumeric            :1;
-  DWORD   fComplex            :1;
-  DWORD   fNeedsWordBreaking  :1;   
-  DWORD   fNeedsCaretInfo     :1;
-  DWORD   bCharSet            :8;   
-  DWORD   fControl            :1;   
-  DWORD   fPrivateUseArea     :1;   
-  DWORD   fNeedsCharacterJustify :1;
-  DWORD   fInvalidGlyph       :1;
-  DWORD   fInvalidLogAttr     :1;
-  DWORD   fCDM                :1;
-  DWORD   fAmbiguousCharSet   :1;
-  DWORD   fClusterSizeVaries  :1;
-  DWORD   fRejectInvalid      :1;
-} SCRIPT_PROPERTIES;
-
-typedef struct tag_SCRIPT_VISATTR { 
-  WORD uJustification :4; 
-  WORD fClusterStart :1; 
-  WORD fDiacritic :1; 
-  WORD fZeroWidth :1; 
-  WORD fReserved :1; 
-  WORD fShapeReserved :8; 
-} SCRIPT_VISATTR;
-
-#ifndef LSDEFS_DEFINED
-typedef struct tagGOFFSET {
-    LONG  du;
-    LONG  dv;
-} GOFFSET;
-#endif
-
-#define SCRIPT_UNDEFINED  0
-
-
-typedef struct tag_SCRIPT_LOGATTR { 
-  BYTE fSoftBreak :1; 
-  BYTE fWhiteSpace :1; 
-  BYTE fCharStop :1; 
-  BYTE fWordStop :1; 
-  BYTE fInvalid :1; 
-  BYTE fReserved :3; 
-} SCRIPT_LOGATTR;
-
-typedef struct tag_SCRIPT_CONTROL { 
-  DWORD uDefaultLanguage :16; 
-  DWORD fContextDigits :1; 
-  DWORD fInvertPreBoundDir :1; 
-  DWORD fInvertPostBoundDir :1; 
-  DWORD fLinkStringBefore :1; 
-  DWORD fLinkStringAfter :1; 
-  DWORD fNeutralOverride :1; 
-  DWORD fNumericOverride :1; 
-  DWORD fLegacyBidiClass :1; 
-  DWORD fReserved :8; 
-} SCRIPT_CONTROL;
-
-
-typedef struct tagGCP_RESULTSA
-    {
-    DWORD   lStructSize;
-    LPSTR     lpOutString;
-    UINT FAR *lpOrder;
-    int FAR  *lpDx;
-    int FAR  *lpCaretPos;
-    LPSTR   lpClass;
-    LPWSTR  lpGlyphs;
-    UINT    nGlyphs;
-    int     nMaxFit;
-    } GCP_RESULTSA, FAR* LPGCP_RESULTSA;
-typedef struct tagGCP_RESULTSW
-    {
-    DWORD   lStructSize;
-    LPWSTR    lpOutString;
-    UINT FAR *lpOrder;
-    int FAR  *lpDx;
-    int FAR  *lpCaretPos;
-    LPSTR   lpClass;
-    LPWSTR  lpGlyphs;
-    UINT    nGlyphs;
-    int     nMaxFit;
-    } GCP_RESULTSW, FAR* LPGCP_RESULTSW;
-#ifdef UNICODE
-typedef GCP_RESULTSW GCP_RESULTS;
-typedef LPGCP_RESULTSW LPGCP_RESULTS;
-#else
-typedef GCP_RESULTSA GCP_RESULTS;
-typedef LPGCP_RESULTSA LPGCP_RESULTS;
-#endif // UNICODE
-
-
-#define GCP_DBCS           0x0001
-#define GCP_REORDER        0x0002
-#define GCP_USEKERNING     0x0008
-#define GCP_GLYPHSHAPE     0x0010
-#define GCP_LIGATE         0x0020
-////#define GCP_GLYPHINDEXING  0x0080
-#define GCP_DIACRITIC      0x0100
-#define GCP_KASHIDA        0x0400
-#define GCP_ERROR          0x8000
-#define FLI_MASK           0x103B
-
-#define GCP_JUSTIFY        0x00010000L
-////#define GCP_NODIACRITICS   0x00020000L
-#define FLI_GLYPHS         0x00040000L
-#define GCP_CLASSIN        0x00080000L
-#define GCP_MAXEXTENT      0x00100000L
-#define GCP_JUSTIFYIN      0x00200000L
-#define GCP_DISPLAYZWG      0x00400000L
-#define GCP_SYMSWAPOFF      0x00800000L
-#define GCP_NUMERICOVERRIDE 0x01000000L
-#define GCP_NEUTRALOVERRIDE 0x02000000L
-#define GCP_NUMERICSLATIN   0x04000000L
-#define GCP_NUMERICSLOCAL   0x08000000L
-
-/*ETO_GLYPH_INDEX is really this 0x0010, but we can't do glyphs*/
-#define ETO_GLYPH_INDEX    0      
-
-#define GGO_NATIVE         2
-#define TT_POLYGON_TYPE   24
-
-#define TT_PRIM_LINE       1
-#define TT_PRIM_QSPLINE    2
-#define TT_PRIM_CSPLINE    3
-
-typedef struct tagPOINTFX
-{
-    FIXED x;
-    FIXED y;
-} POINTFX, FAR* LPPOINTFX;
-
-typedef struct tagTTPOLYCURVE
-{
-    WORD    wType;
-    WORD    cpfx;
-    POINTFX apfx[1];
-} TTPOLYCURVE, FAR* LPTTPOLYCURVE;
-
-typedef struct tagTTPOLYGONHEADER
-{
-    DWORD   cb;
-    DWORD   dwType;
-    POINTFX pfxStart;
-} TTPOLYGONHEADER, FAR* LPTTPOLYGONHEADER;
-
-#define HALFTONE                     4
-
-/* ETO_PDY is really 0x2000 */
-#define ETO_PDY                      0       
-#define ALTERNATE                    1
-#define WINDING                      2
-
-#define PS_USERSTYLE        7
-
-#define PS_ENDCAP_ROUND     0x00000000
-#define PS_ENDCAP_SQUARE    0x00000100
-#define PS_ENDCAP_FLAT      0x00000200
-#define PS_ENDCAP_MASK      0x00000F00
-
-#define PS_JOIN_ROUND       0x00000000
-#define PS_JOIN_BEVEL       0x00001000
-#define PS_JOIN_MITER       0x00002000
-#define PS_JOIN_MASK        0x0000F000
-
-#define PS_COSMETIC         0x00000000
-#define PS_GEOMETRIC        0x00010000
-#define PS_TYPE_MASK        0x000F0000
-
-typedef struct tag_SCRIPT_DIGITSUBSTITUTE {
-    DWORD  NationalDigitLanguage    :16;   // Language for native substitution
-    DWORD  TraditionalDigitLanguage :16;   // Language for traditional substitution
-    DWORD  DigitSubstitute          :8;    // Substitution type
-    DWORD  dwReserved;                     // Reserved
-} SCRIPT_DIGITSUBSTITUTE;
-
-// Defines missing from widget/src/build
-// WinNT.h
-typedef struct _OSVERSIONINFOEXA {
-    DWORD dwOSVersionInfoSize;
-    DWORD dwMajorVersion;
-    DWORD dwMinorVersion;
-    DWORD dwBuildNumber;
-    DWORD dwPlatformId;
-    CHAR   szCSDVersion[ 128 ];     // Maintenance string for PSS usage
-    WORD   wServicePackMajor;
-    WORD   wServicePackMinor;
-    WORD   wSuiteMask;
-    BYTE  wProductType;
-    BYTE  wReserved;
-} OSVERSIONINFOEXA, *POSVERSIONINFOEXA, *LPOSVERSIONINFOEXA;
-typedef struct _OSVERSIONINFOEXW {
-    DWORD dwOSVersionInfoSize;
-    DWORD dwMajorVersion;
-    DWORD dwMinorVersion;
-    DWORD dwBuildNumber;
-    DWORD dwPlatformId;
-    WCHAR  szCSDVersion[ 128 ];     // Maintenance string for PSS usage
-    WORD   wServicePackMajor;
-    WORD   wServicePackMinor;
-    WORD   wSuiteMask;
-    BYTE  wProductType;
-    BYTE  wReserved;
-} OSVERSIONINFOEXW, *POSVERSIONINFOEXW, *LPOSVERSIONINFOEXW, RTL_OSVERSIONINFOEXW, *PRTL_OSVERSIONINFOEXW;
-#ifdef UNICODE
-typedef OSVERSIONINFOEXW OSVERSIONINFOEX;
-typedef POSVERSIONINFOEXW POSVERSIONINFOEX;
-typedef LPOSVERSIONINFOEXW LPOSVERSIONINFOEX;
-#else
-typedef OSVERSIONINFOEXA OSVERSIONINFOEX;
-typedef POSVERSIONINFOEXA POSVERSIONINFOEX;
-typedef LPOSVERSIONINFOEXA LPOSVERSIONINFOEX;
-#endif // UNICODE
-
-// WinUser.h
-#define WM_ENDSESSION                   0x0016
-
-// defines required by msaa.h
-typedef struct tagWINDOWINFO
-{
-    DWORD cbSize;
-    RECT rcWindow;
-    RECT rcClient;
-    DWORD dwStyle;
-    DWORD dwExStyle;
-    DWORD dwWindowStatus;
-    UINT cxWindowBorders;
-    UINT cyWindowBorders;
-    ATOM atomWindowType;
-    WORD wCreatorVersion;
-} WINDOWINFO, *PWINDOWINFO, *LPWINDOWINFO;
-
-typedef struct tagCURSORINFO
-{
-    DWORD   cbSize;
-    DWORD   flags;
-    HCURSOR hCursor;
-    POINT   ptScreenPos;
-} CURSORINFO, *PCURSORINFO, *LPCURSORINFO;
-
-#define CCHILDREN_TITLEBAR              5
-#define CCHILDREN_SCROLLBAR             5
-
-typedef struct tagTITLEBARINFO
-{
-    DWORD cbSize;
-    RECT rcTitleBar;
-    DWORD rgstate[CCHILDREN_TITLEBAR + 1];
-} TITLEBARINFO, *PTITLEBARINFO, *LPTITLEBARINFO;
-
-typedef struct tagSCROLLBARINFO
-{
-    DWORD cbSize;
-    RECT rcScrollBar;
-    int dxyLineButton;
-    int xyThumbTop;
-    int xyThumbBottom;
-    int reserved;
-    DWORD rgstate[CCHILDREN_SCROLLBAR + 1];
-} SCROLLBARINFO, *PSCROLLBARINFO, *LPSCROLLBARINFO;
-
-typedef struct tagMENUBARINFO
-{
-    DWORD cbSize;
-    RECT rcBar;          // rect of bar, popup, item
-    HMENU hMenu;         // real menu handle of bar, popup
-    HWND hwndMenu;       // hwnd of item submenu if one
-    BOOL fBarFocused:1;  // bar, popup has the focus
-    BOOL fFocused:1;     // item has the focus
-} MENUBARINFO, *PMENUBARINFO, *LPMENUBARINFO;
-
-// comment? typedef DWORD HWINEVENTHOOK;
-
-typedef struct tagGUITHREADINFO
-{
-    DWORD   cbSize;
-    DWORD   flags;
-    HWND    hwndActive;
-    HWND    hwndFocus;
-    HWND    hwndCapture;
-    HWND    hwndMenuOwner;
-    HWND    hwndMoveSize;
-    HWND    hwndCaret;
-    RECT    rcCaret;
-} GUITHREADINFO, *PGUITHREADINFO, FAR * LPGUITHREADINFO;
-
-typedef struct tagALTTABINFO
-{
-    DWORD cbSize;
-    int cItems;
-    int cColumns;
-    int cRows;
-    int iColFocus;
-    int iRowFocus;
-    int cxItem;
-    int cyItem;
-    POINT ptStart;
-} ALTTABINFO, *PALTTABINFO, *LPALTTABINFO;
-
-#define     GA_ROOT         2
-
-#define NTM_TYPE1           0x00100000
-#define SPI_GETDRAGFULLWINDOWS      0x0026
-
-typedef ULONG SFGAOF;
-
-
-typedef unsigned int   uintptr_t;
-// From winuser.h
-#define GR_GDIOBJECTS     0       /* Count of GDI objects */
-#define GR_USEROBJECTS    1       /* Count of USER objects */
-// wingdi.h
-#define MWT_IDENTITY        1
-
-typedef VOID CALLBACK LINEDDAPROC(
-  int X,          // x-coordinate of point
-  int Y,          // y-coordinate of point
-  LPARAM lpData   // application-defined data
-);
-
-#define MOVEFILE_REPLACE_EXISTING       0x00000001
-#define MOVEFILE_COPY_ALLOWED           0x00000002
-#define MOVEFILE_DELAY_UNTIL_REBOOT     0x00000004
-#define MOVEFILE_WRITE_THROUGH          0x00000008
-
-#define MB_TASKMODAL MB_APPLMODAL
-
-#define     GA_PARENT       1
-#define     GA_ROOT         2
-#define     GA_ROOTOWNER    3
-
-//
-// FILEDESCRIPTOR.dwFlags field indicate which fields are to be used
-//
-
-typedef struct _FILEDESCRIPTORA { // fod
-    DWORD dwFlags;
-
-    CLSID clsid;
-    SIZEL sizel;
-    POINTL pointl;
-
-    DWORD dwFileAttributes;
-    FILETIME ftCreationTime;
-    FILETIME ftLastAccessTime;
-    FILETIME ftLastWriteTime;
-    DWORD nFileSizeHigh;
-    DWORD nFileSizeLow;
-    CHAR   cFileName[ MAX_PATH ];
-} FILEDESCRIPTORA, *LPFILEDESCRIPTORA;
-
-typedef struct _FILEDESCRIPTORW { // fod
-    DWORD dwFlags;
-
-    CLSID clsid;
-    SIZEL sizel;
-    POINTL pointl;
-
-    DWORD dwFileAttributes;
-    FILETIME ftCreationTime;
-    FILETIME ftLastAccessTime;
-    FILETIME ftLastWriteTime;
-    DWORD nFileSizeHigh;
-    DWORD nFileSizeLow;
-    WCHAR  cFileName[ MAX_PATH ];
-} FILEDESCRIPTORW, *LPFILEDESCRIPTORW;
-
-#ifdef UNICODE
-#define FILEDESCRIPTOR      FILEDESCRIPTORW
-#define LPFILEDESCRIPTOR    LPFILEDESCRIPTORW
-#else
-#define FILEDESCRIPTOR      FILEDESCRIPTORA
-#define LPFILEDESCRIPTOR    LPFILEDESCRIPTORA
-#endif
-
-//
-// format of CF_FILEGROUPDESCRIPTOR
-//
-typedef struct _FILEGROUPDESCRIPTORA { // fgd
-     UINT cItems;
-     FILEDESCRIPTORA fgd[1];
-} FILEGROUPDESCRIPTORA, * LPFILEGROUPDESCRIPTORA;
-
-typedef struct _FILEGROUPDESCRIPTORW { // fgd
-     UINT cItems;
-     FILEDESCRIPTORW fgd[1];
-} FILEGROUPDESCRIPTORW, * LPFILEGROUPDESCRIPTORW;
-
-#ifdef UNICODE
-#define FILEGROUPDESCRIPTOR     FILEGROUPDESCRIPTORW
-#define LPFILEGROUPDESCRIPTOR   LPFILEGROUPDESCRIPTORW
-#else
-#define FILEGROUPDESCRIPTOR     FILEGROUPDESCRIPTORA
-#define LPFILEGROUPDESCRIPTOR   LPFILEGROUPDESCRIPTORA
-#endif
-
-typedef struct
-{
-    SIZE        sizeDragImage;      // OUT - The length and Width of the
-                                    //        rendered image
-    POINT       ptOffset;           // OUT - The Offset from the mouse cursor to
-                                    //        the upper left corner of the image
-    HBITMAP     hbmpDragImage;      // OUT - The Bitmap containing the rendered
-                                    //        drag images
-    COLORREF    crColorKey;         // OUT - The COLORREF that has been blitted
-                                    //        to the background of the images
-} SHDRAGIMAGE, *LPSHDRAGIMAGE;
-
-#ifndef max
-#define max(a,b) (((a) > (b)) ? (a) : (b))
-#endif
-
-#define SHGetSpecialFolderPathW SHGetSpecialFolderPath
-#define SHGetFileInfoW SHGetFileInfo
-
-// On Windows CE, there are some functions that are wide, but there
-// isn't a function named "functionW".
-
-#define SHGetPathFromIDListW SHGetPathFromIDList 
-#define GetUserNameW         GetUserName
-#define RemovePropW          RemoveProp
-#define GetPropW             GetProp
-#define SetPropW             SetProp
-#define FONTENUMPROCW        FONTENUMPROC
-#define GetLongPathNameW     GetLongPathName
-
-// ACL Defines
-
-
-typedef enum _SE_OBJECT_TYPE {
-  SE_UNKNOWN_OBJECT_TYPE       = 0,
-  SE_FILE_OBJECT,
-  SE_SERVICE,
-  SE_PRINTER,
-  SE_REGISTRY_KEY,
-  SE_LMSHARE,
-  SE_KERNEL_OBJECT,
-  SE_WINDOW_OBJECT,
-  SE_DS_OBJECT,
-  SE_DS_OBJECT_ALL,
-  SE_PROVIDER_DEFINED_OBJECT,
-  SE_WMIGUID_OBJECT,
-  SE_REGISTRY_WOW64_32KEY 
-} SE_OBJECT_TYPE;
-
-typedef DWORD SECURITY_INFORMATION, *PSECURITY_INFORMATION;
-
-#define UNPROTECTED_DACL_SECURITY_INFORMATION 0x0
-
-
-#endif // _MOZCE_DEFS
diff -r 17e9560465b0 build/wince/shunt/include/mozce_shunt.h
--- a/build/wince/shunt/include/mozce_shunt.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/build/wince/shunt/include/mozce_shunt.h	Thu Oct 30 05:41:44 2008 -0400
@@ -39,407 +39,56 @@
 #ifndef MOZCE_SHUNT_H
 #define MOZCE_SHUNT_H
 
-// This is to silence the #pragma deprecated warnings
-#pragma warning(disable: 4068)
-
-#include "mozce_defs.h"
-#include "../mozce_internal.h"
-
-#include <commdlg.h>
-#include <stdio.h>
-
-#include <shellapi.h>
-
-//////////////////////////////////////////////////////////
-// Function Mapping
-//////////////////////////////////////////////////////////
-#ifndef MOZCE_SHUNT_EXPORTS
-
-#define _mkdir		mkdir
-#define _rmdir		rmdir
-#define _chmod		chmod
-#define _isatty		isatty
-#undef fileno
-#define fileno      (int)_fileno
-#define _mbctolower tolower
-#define _mbsicmp    mbsicmp
-#define _mbsdec     mbsdec
-#define _getpid		getpid
-#define _access		access
-#define	_fdopen		fdopen
-#define _getcwd     getcwd
-#define _open open
-#define _fullpath	fullpath
-#define _splitpath	splitpath
-#define _makepath	makepath
-#define lstrlenA  strlen
-#define lstrcpyA  strcpy
-#define lstrcmpA  strcmp
-#define lstrcmpiA strcmpi
-#define lstrcatA  strcat
-#define strdup      _strdup
-#define stricmp     _stricmp
-#define strcmpi     _stricmp
-#define strnicmp    _strnicmp
-#ifdef localeconv
-#undef localeconv
+#ifdef MOZCE_SHUNT_EXPORTS
+#define MOZCE_SHUNT_API __declspec(dllexport)
+#else
+#define MOZCE_SHUNT_API __declspec(dllimport)
 #endif
-#define localeconv  mozce_localeconv
-
-
-// From win32.cpp
-
-#define _beginthreadex(security, stack_size, start_proc, arg, flags, pid) \
-        CreateThread(security, stack_size,(LPTHREAD_START_ROUTINE) start_proc, arg, flags, pid)
-
-#define ExpandEnvironmentStrings   ExpandEnvironmentStringsA
-#if 0
-#ifdef GetMessageA
-#undef GetMessageA
-#endif
-#define GetMessageA               GetMessageW
-#define PostMessageA              PostMessageW
-#define GetShortPathNameA         GetShortPathName
-
-#define PeekMessageA              PeekMessageW
-
-#define ShellExecuteA             ShellExecute
-
-// We use a method named CreateEvent.  We do not want to map
-// CreateEvent to CreateEventA
-#ifdef CreateEvent
-#undef CreateEvent
-#endif
-#define CreateEvent               CreateEvent
-#endif  // if 0
-
-#define GetSystemDirectory        GetSystemDirectoryW
-#define GetWindowsDirectory       GetWindowsDirectoryW
-#define SetCurrentDirectory       SetCurrentDirectoryW
-#define SetEnvironmentVariable    SetEnvironmentVariableW
-#define CreateDialogIndirectParamA CreateDialogIndirectParamW
-#define SystemParametersInfoA      SystemParametersInfoW
-#define DispatchMessageA           DispatchMessageW
-#define CallWindowProcA            CallWindowProcW
-#define GetWindowLongA             GetWindowLongW
-#define SetWindowLongA             SetWindowLongW
-#define GetMonitorInfoW           GetMonitorInfo
-
-#undef  GetProcAddress
-#define GetProcAddress            GetProcAddressA
-
-#define SHELLEXECUTEINFOW         SHELLEXECUTEINFO
-#define ShellExecuteExW(x)        ShellExecuteEx(x)
-
-#define MapVirtualKeyEx(a,b,c)    MapVirtualKey(a,b)
-
-
-//still need these
-#define GetCurrentDirectory       GetCurrentDirectoryW
-#define OpenSemaphore             OpenSemaphoreW
-#define SetCurrentDirectoryW      SetCurrentDirectoryW
-
-#endif // MOZCE_SHUNT_EXPORTS
-
-//////////////////////////////////////////////////////////
-// Function Declarations
-//////////////////////////////////////////////////////////
+  
+#define strdup  _strdup
+#define strcmpi _stricmp
+#define stricmp _stricmp
+#define wgetcwd _wgetcwd
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-  MOZCE_SHUNT_API BOOL InitializeAcl(PACL apAcl, DWORD len, DWORD rev);
-  MOZCE_SHUNT_API DWORD SetNamedSecurityInfoW(unsigned short* pObjectName,
-					      SE_OBJECT_TYPE ObjectType,
-					      SECURITY_INFORMATION SecurityInfo,
-					      PSID psidOwner,
-					      PSID psidGroup,
-					      PACL pDacl,
-					      PACL pSacl);
+MOZCE_SHUNT_API void abort(void);
+  
+/* Environment stuff */
+MOZCE_SHUNT_API char* getenv(const char* inName);
+MOZCE_SHUNT_API int putenv(const char *a);
+MOZCE_SHUNT_API char SetEnvironmentVariableW(const unsigned short * name, const unsigned short * value );
+MOZCE_SHUNT_API char GetEnvironmentVariableW(const unsigned short * lpName, unsigned short* lpBuffer, unsigned long nSize);
+  
+/* File system stuff */
+MOZCE_SHUNT_API unsigned short * _wgetcwd(unsigned short* dir, unsigned long size);
+MOZCE_SHUNT_API unsigned short *_wfullpath( unsigned short *absPath, const unsigned short *relPath, unsigned long maxLength );
+MOZCE_SHUNT_API int _unlink(const char *filename );
+  
+/* The time stuff should be defined here, but it can't be because it
+   is already defined in time.h.
+  
+ MOZCE_SHUNT_API size_t strftime(char *, size_t, const char *, const struct tm *)
+ MOZCE_SHUNT_API struct tm* localtime(const time_t* inTimeT)
+ MOZCE_SHUNT_API struct tm* mozce_gmtime_r(const time_t* inTimeT, struct tm* outRetval)
+ MOZCE_SHUNT_API struct tm* gmtime(const time_t* inTimeT)
+ MOZCE_SHUNT_API time_t mktime(struct tm* inTM)
+ MOZCE_SHUNT_API time_t time(time_t *)
+ MOZCE_SHUNT_API clock_t clock() 
+  
+*/
+  
+/* Locale Stuff */
+  
+/* The locale stuff should be defined here, but it can't be because it
+   is already defined in locale.h.
+  
+ MOZCE_SHUNT_API struct lconv * localeconv(void)
+  
+*/
 
-  // From assert.cpp
-  MOZCE_SHUNT_API void mozce_assert(int inExpression);
-
-  // From direct.cpp
-  MOZCE_SHUNT_API int mkdir(const char* inDirname);
-  MOZCE_SHUNT_API int rmdir(const char* inDirname);
-
-  // From errno.cpp
-  extern MOZCE_SHUNT_API int errno;
-
-  // From io.cpp
-  MOZCE_SHUNT_API void setbuf(FILE*, char*);
-  MOZCE_SHUNT_API int chmod(const char* inFilename, int inMode);
-  MOZCE_SHUNT_API int isatty(int inHandle);
-
-
-  // From mbstring.cpp
-  MOZCE_SHUNT_API unsigned char* _mbsinc(const unsigned char* inCurrent);
-  MOZCE_SHUNT_API unsigned char* _mbspbrk(const unsigned char* inString, const unsigned char* inStrCharSet);
-  MOZCE_SHUNT_API unsigned char* mbschr(const unsigned char* inString, unsigned int inC);
-  MOZCE_SHUNT_API unsigned char* mbsrchr(const unsigned char* inString, unsigned int inC);
-  MOZCE_SHUNT_API int            mbsicmp(const unsigned char *string1, const unsigned char *string2);
-  MOZCE_SHUNT_API unsigned char* mbsdec(const unsigned char *string1, const unsigned char *string2);
-
-  // From process.cpp
-  MOZCE_SHUNT_API void abort(void);
-  MOZCE_SHUNT_API char* getenv(const char* inName);
-  MOZCE_SHUNT_API int putenv(const char *a);
-  MOZCE_SHUNT_API int getpid(void);
-
-  // From signal.cpp
-  MOZCE_SHUNT_API int raise(int inSignal);
-  MOZCE_SHUNT_API _sigsig signal(int inSignal, _sigsig inFunc);
-
-  // From stat.cpp
-  MOZCE_SHUNT_API int stat(const char *inPath, struct stat * outStat);
-
-  // From stdio.cpp
-
-  MOZCE_SHUNT_API int _waccess(const wchar_t *path, int mode);
-
-  MOZCE_SHUNT_API int access(const char *path, int mode);
-  MOZCE_SHUNT_API void rewind(FILE* inStream);
-  MOZCE_SHUNT_API FILE* fdopen(int inFD, const char* inMode);
-  MOZCE_SHUNT_API void perror(const char* inString);
-  MOZCE_SHUNT_API int remove(const char* inPath);
-
-  MOZCE_SHUNT_API char* getcwd(char* buff, size_t size);
-
-  MOZCE_SHUNT_API int mozce_printf(const char *, ...);
-
-  MOZCE_SHUNT_API int open(const char *pathname, int flags, int mode);
-  MOZCE_SHUNT_API int close(int fp);
-  MOZCE_SHUNT_API size_t read(int fp, void* buffer, size_t count);
-  MOZCE_SHUNT_API size_t write(int fp, const void* buffer, size_t count);
-  MOZCE_SHUNT_API int unlink(const char *pathname);
-  MOZCE_SHUNT_API int lseek(int fildes, int offset, int whence);
-
-  MOZCE_SHUNT_API int fstat(FILE* handle, struct stat* buff);
-
-  // From stdlib.cpp
-  MOZCE_SHUNT_API void splitpath(const char* inPath, char* outDrive, char* outDir, char* outFname, char* outExt);
-  MOZCE_SHUNT_API void makepath(char* outPath, const char* inDrive, const char* inDir, const char* inFname, const char* inExt);
-  MOZCE_SHUNT_API char* fullpath(char *, const char *, size_t);
-  MOZCE_SHUNT_API int _unlink(const char *filename );
-
-  // From string.cpp
-  MOZCE_SHUNT_API char* strerror(int);
-
-  // From time.cpp
-
-  MOZCE_SHUNT_API BOOL CreatePipe(PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize);
-
-  MOZCE_SHUNT_API DWORD_PTR SetThreadAffinityMask(HANDLE hThread, DWORD_PTR dwThreadAffinityMask);
-  MOZCE_SHUNT_API BOOL GetProcessAffinityMask(HANDLE hProcess, PDWORD_PTR lpProcessAffinityMask, PDWORD_PTR lpSystemAffinityMask);
-
-  VOID CALLBACK LineDDAProc(int X, int Y, LPARAM lpData);
-  typedef void (*mozce_LINEDDAPROC) (int X, int Y, LPARAM lpData);
-
-  //dd  MOZCE_SHUNT_API int MulDiv(int inNumber, int inNumerator, int inDenominator);
-  MOZCE_SHUNT_API int GetDIBits(HDC inDC, HBITMAP inBMP, UINT inStartScan, UINT inScanLines, LPVOID inBits, LPBITMAPINFO inInfo, UINT inUsage);
-  MOZCE_SHUNT_API int SetDIBits(HDC inDC, HBITMAP inBMP, UINT inStartScan, UINT inScanLines, CONST LPVOID inBits, CONST LPBITMAPINFO inInfo, UINT inUsage);
-//dd  MOZCE_SHUNT_API DWORD CommDlgExtendedError(void);
-  MOZCE_SHUNT_API HBITMAP CreateDIBitmap(HDC inDC, CONST BITMAPINFOHEADER *inBMIH, DWORD inInit, CONST VOID *inBInit, CONST BITMAPINFO *inBMI, UINT inUsage);
-  MOZCE_SHUNT_API int SetPolyFillMode(HDC inDC, int inPolyFillMode);
-//dd  MOZCE_SHUNT_API int SetStretchBltMode(HDC inDC, int inStretchMode);
-  MOZCE_SHUNT_API int ExtSelectClipRgn(HDC inDC, HRGN inRGN, int inMode);
-  MOZCE_SHUNT_API DWORD ExpandEnvironmentStrings(LPCTSTR lpSrc, LPTSTR lpDst, DWORD nSize);
-  MOZCE_SHUNT_API DWORD ExpandEnvironmentStringsW(const unsigned short * lpSrc, const unsigned short * lpDst, DWORD nSize);
-
-  MOZCE_SHUNT_API BOOL LineDDA(int inXStart, int inYStart, int inXEnd, int inYEnd, LINEDDAPROC inLineFunc, LPARAM inData);
-  MOZCE_SHUNT_API int FrameRect(HDC inDC, CONST RECT *inRect, HBRUSH inBrush);
-  MOZCE_SHUNT_API BOOL GdiFlush(void);
-  MOZCE_SHUNT_API int SetArcDirection(HDC inDC, int inArcDirection);
-  MOZCE_SHUNT_API BOOL Arc(HDC inDC, int inLeftRect, int inTopRect, int inRightRect, int inBottomRect, int inXStartArc, int inYStartArc, int inXEndArc, int inYEndArc);
-  MOZCE_SHUNT_API BOOL Pie(HDC inDC, int inLeftRect, int inTopRect, int inRightRect, int inBottomRect, int inXRadial1, int inYRadial1, int inXRadial2, int inYRadial2);
-
-  #define GetDriveTypeW GetDriveType
-  MOZCE_SHUNT_API UINT GetDriveType(const char* lpRootPathName);
-
-//dd  MOZCE_SHUNT_API DWORD GetFontData(HDC inDC, DWORD inTable, DWORD inOffset, LPVOID outBuffer, DWORD inData);
-  MOZCE_SHUNT_API UINT GetTextCharset(HDC inDC);
-  MOZCE_SHUNT_API UINT GetTextCharsetInfo(HDC inDC, LPFONTSIGNATURE outSig, DWORD inFlags);
-  MOZCE_SHUNT_API int GetMapMode(HDC inDC);
-//dd  MOZCE_SHUNT_API BOOL GetIconInfo(HICON inIcon, PICONINFO outIconinfo);
-  MOZCE_SHUNT_API BOOL LPtoDP(HDC inDC, LPPOINT inoutPoints, int inCount);
-  MOZCE_SHUNT_API LONG RegCreateKey(HKEY inKey, LPCTSTR inSubKey, PHKEY outResult);
-  MOZCE_SHUNT_API BOOL WaitMessage(VOID);
-  MOZCE_SHUNT_API BOOL FlashWindow(HWND inWnd, BOOL inInvert);
-  MOZCE_SHUNT_API BOOL EnumChildWindows(HWND inParent, WNDENUMPROC inFunc, LPARAM inParam);
-  MOZCE_SHUNT_API BOOL EnumThreadWindows(DWORD inThreadID, WNDENUMPROC inFunc, LPARAM inParam);
-  MOZCE_SHUNT_API BOOL IsIconic(HWND inWnd);
-  MOZCE_SHUNT_API BOOL OpenIcon(HWND inWnd);
-  MOZCE_SHUNT_API HANDLE OpenFileMapping(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCTSTR lpName);
-  MOZCE_SHUNT_API HHOOK SetWindowsHookEx(int inType, void* inFunc, HINSTANCE inMod, DWORD inThreadId);
-  MOZCE_SHUNT_API HINSTANCE ShellExecute(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd);
-  MOZCE_SHUNT_API HINSTANCE ShellExecuteW(HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd);
-  MOZCE_SHUNT_API BOOL UnhookWindowsHookEx(HHOOK inHook);
-  MOZCE_SHUNT_API LRESULT CallNextHookEx(HHOOK inHook, int inCode, WPARAM wParam, LPARAM lParam);
-
-  MOZCE_SHUNT_API BOOL GetWindowPlacement(HWND window, WINDOWPLACEMENT *lpwndpl);
-  MOZCE_SHUNT_API BOOL InvertRgn(HDC inDC, HRGN inRGN);
-  MOZCE_SHUNT_API int GetScrollPos(HWND inWnd, int inBar);
-  MOZCE_SHUNT_API BOOL GetScrollRange(HWND inWnd, int inBar, LPINT outMinPos, LPINT outMaxPos);
-  MOZCE_SHUNT_API HRESULT CoLockObjectExternal(IUnknown* inUnk, BOOL inLock, BOOL inLastUnlockReleases);
-  MOZCE_SHUNT_API HRESULT CoInitialize(LPVOID pvReserved);
-
-  //MOZCE_SHUNT_API void* mozce_SHBrowseForFolder(void* /*LPBROWSEINFOS*/ inBI);
-  MOZCE_SHUNT_API BOOL SetMenu(HWND inWnd, HMENU inMenu);
-  MOZCE_SHUNT_API BOOL GetUserName(LPTSTR inBuffer, LPDWORD inoutSize);
-  MOZCE_SHUNT_API DWORD GetShortPathName(LPCTSTR inLongPath, LPTSTR outShortPath, DWORD inBufferSize);
-  MOZCE_SHUNT_API DWORD GetShortPathNameW(LPCWSTR aLPATH, LPWSTR aSPATH, DWORD aLen);
-
-  MOZCE_SHUNT_API DWORD GetEnvironmentVariable(LPCSTR lpName, LPCSTR lpBuffer, DWORD nSize);
-  MOZCE_SHUNT_API DWORD GetEnvironmentVariableW(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize);
-  MOZCE_SHUNT_API void GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime);
-
-
-  MOZCE_SHUNT_API DWORD GetLongPathNameW(LPCWSTR lpszShortPath, LPCWSTR lpszLongPath, DWORD cchBuffer);
-
-  #define GetFullPathNameW GetFullPathName
-  MOZCE_SHUNT_API DWORD GetFullPathName(const char* lpFileName, DWORD nBufferLength, const char* lpBuffer, const char** lpFilePart);
-
-//dd  MOZCE_SHUNT_API UINT GetACP(void);
-
-  MOZCE_SHUNT_API BOOL mozce_PeekMessage(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
-  MOZCE_SHUNT_API BOOL mozce_GetMessage(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
-  MOZCE_SHUNT_API LONG GetMessageTime(void);
-
-  MOZCE_SHUNT_API BOOL LockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh,
-                                      DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh);
-  MOZCE_SHUNT_API BOOL UnlockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh,
-                                        DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh);
-  MOZCE_SHUNT_API BOOL SetWorldTransform(HDC hdc, CONST XFORM *lpXform );
-  MOZCE_SHUNT_API BOOL GetWorldTransform(HDC hdc, LPXFORM lpXform );
-  MOZCE_SHUNT_API int  SetGraphicsMode(HDC hdc, int iMode);
-
-  // From win32w.cpp
-  MOZCE_SHUNT_API BOOL SetCurrentDirectoryW(LPCTSTR inPathName);
-  MOZCE_SHUNT_API DWORD GetCurrentDirectoryW(DWORD inBufferLength, LPTSTR outBuffer);
-  MOZCE_SHUNT_API DWORD GetGlyphOutlineW(HDC inDC, WCHAR inChar, UINT inFormat, void* inGM, DWORD inBufferSize, LPVOID outBuffer, CONST VOID* inMAT2);
-  MOZCE_SHUNT_API HANDLE OpenSemaphoreW(DWORD inDesiredAccess, BOOL inInheritHandle, LPCWSTR inName);
-  MOZCE_SHUNT_API UINT GetSystemDirectoryW(LPWSTR inBuffer, UINT inSize);
-  MOZCE_SHUNT_API UINT GetWindowsDirectoryW(LPWSTR inBuffer, UINT inSize);
-//  MOZCE_SHUNT_API BOOL SHGetSpecialFolderPathW(HWND hwnd, LPWSTR pszPath, int csidl, BOOL fCreate);
-  MOZCE_SHUNT_API BOOL SetEnvironmentVariableW( LPCWSTR name, LPCWSTR value );
-
-  // uniscribe usp10.h & WinGDI.h
-  MOZCE_SHUNT_API HRESULT ScriptFreeCache(SCRIPT_CACHE* psc );
-
-#define GGI_MARK_NONEXISTING_GLYPHS  0X0001
-
-  MOZCE_SHUNT_API DWORD WINAPI GetGlyphIndicesA( HDC hdc,LPCSTR lpstr, int c, LPWORD pgi, DWORD fl);
-  MOZCE_SHUNT_API DWORD WINAPI GetGlyphIndicesW( HDC hdc, LPCWSTR lpstr, int c,  LPWORD pgi, DWORD fl);
-#define DEFAULT_GUI_FONT    SYSTEM_FONT
-
-#define SIC_COMPLEX     1   // Treat complex script letters as complex
-  MOZCE_SHUNT_API HRESULT WINAPI ScriptIsComplex(const WCHAR *pwcInChars, int cInChars, DWORD   dwFlags);
-  MOZCE_SHUNT_API BOOL  WINAPI GetTextExtentExPointI (HDC hdc, LPWORD lpwszString,int cwchString,int nMaxExtent,LPINT lpnFit,LPINT lpnDx,LPSIZE lpSize);
-  MOZCE_SHUNT_API HRESULT WINAPI ScriptGetProperties( const SCRIPT_PROPERTIES ***ppSp, int *piNumScripts);
-  MOZCE_SHUNT_API HRESULT WINAPI ScriptGetFontProperties(HDC hdc, SCRIPT_CACHE *psc, SCRIPT_FONTPROPERTIES *sfp );
-  MOZCE_SHUNT_API HRESULT WINAPI ScriptBreak(  const WCHAR *pwcChars, int cChars, const SCRIPT_ANALYSIS *psa, SCRIPT_LOGATTR *psla );
-  MOZCE_SHUNT_API HRESULT WINAPI ScriptItemize( const WCHAR *pwcInChars, int cInChars, int cMaxItems, const SCRIPT_CONTROL *psControl, const SCRIPT_STATE *psState, SCRIPT_ITEM *pItems, int *pcItems );
-  MOZCE_SHUNT_API BOOL WINAPI GetICMProfileW(HDC hDC, LPDWORD lpcbName,LPWSTR lpszFilename);
-  MOZCE_SHUNT_API DWORD WINAPI GetGuiResources(HANDLE hProcess,DWORD uiFlags);
-  MOZCE_SHUNT_API HRESULT WINAPI ScriptRecordDigitSubstitution(LCID Locale, SCRIPT_DIGITSUBSTITUTE  *psds);
-
-MOZCE_SHUNT_API HRESULT WINAPI ScriptItemize(const WCHAR *pwcInChars, int cInChars, int cMaxItems, const SCRIPT_CONTROL *psControl, const SCRIPT_STATE *psState,  SCRIPT_ITEM *pItems, int *pcItems );
-
-MOZCE_SHUNT_API HWND WINAPI GetTopWindow(HWND hWnd);
-#define GetNextWindow(hWnd, wCmd) GetWindow(hWnd, wCmd)
-
-MOZCE_SHUNT_API BOOL WINAPI UpdateLayeredWindow(HWND hWnd, HDC hdcDst, POINT *pptDst,
-                                SIZE *psize, HDC hdcSrc, POINT *pptSrc,
-                                COLORREF crKey, BLENDFUNCTION *pblend,
-                                DWORD dwFlags);
-
-MOZCE_SHUNT_API BOOL
-WINAPI
-InitializeCriticalSectionAndSpinCount(
-    __out LPCRITICAL_SECTION lpCriticalSection,
-    __in  DWORD dwSpinCount
-    );
-
-MOZCE_SHUNT_API
-DWORD
-WINAPI
-SetCriticalSectionSpinCount(
-    __inout LPCRITICAL_SECTION lpCriticalSection,
-    __in    DWORD dwSpinCount
-    );
-
-MOZCE_SHUNT_API
-BOOL
-WINAPI
-GetSystemTimeAdjustment(
-    __out PDWORD lpTimeAdjustment,
-    __out PDWORD lpTimeIncrement,
-    __out PBOOL  lpTimeAdjustmentDisabled
-    );
-
-MOZCE_SHUNT_API BOOL  WINAPI PolyBezierTo(__in HDC hdc, __in_ecount(cpt) CONST POINT * apt, __in DWORD cpt);
-MOZCE_SHUNT_API BOOL WINAPI CloseFigure(__in HDC hdc);
-MOZCE_SHUNT_API BOOL WINAPI SelectClipPath(__in HDC hdc, __in int mode);
-MOZCE_SHUNT_API BOOL WINAPI EndPath(__in HDC hdc);
-MOZCE_SHUNT_API BOOL WINAPI BeginPath(__in HDC hdc);
-MOZCE_SHUNT_API BOOL WINAPI ModifyWorldTransform( __in HDC hdc, __in_opt CONST XFORM * lpxf, __in DWORD mode);
-MOZCE_SHUNT_API BOOL WINAPI WidenPath(__in HDC hdc);
-MOZCE_SHUNT_API BOOL WINAPI StrokePath(__in HDC hdc);
-MOZCE_SHUNT_API HPEN WINAPI ExtCreatePen( __in DWORD iPenStyle,
-                                    __in DWORD cWidth,
-                                    __in CONST LOGBRUSH *plbrush,
-                                    __in DWORD cStyle,
-                                    __in_ecount_opt(cStyle) CONST DWORD *pstyle);
-MOZCE_SHUNT_API BOOL WINAPI SetMiterLimit(__in HDC hdc, __in FLOAT limit, __out_opt PFLOAT old);
-MOZCE_SHUNT_API BOOL WINAPI FillPath(__in HDC hdc);
-
-MOZCE_SHUNT_API BOOL	      WINAPI GetICMProfileW(    __in HDC hdc,
-                                                __inout LPDWORD pBufSize,
-                                                __out_ecount_opt(*pBufSize) LPWSTR pszFilename);
-MOZCE_SHUNT_API HRESULT WINAPI ScriptShape(
-    HDC                 hdc,            // In    Optional (see under caching)
-    SCRIPT_CACHE       *psc,            // InOut Cache handle
-    const WCHAR        *pwcChars,       // In    Logical unicode run
-    int                 cChars,         // In    Length of unicode run
-    int                 cMaxGlyphs,     // In    Max glyphs to generate
-    SCRIPT_ANALYSIS    *psa,            // InOut Result of ScriptItemize (may have fNoGlyphIndex set)
-    WORD               *pwOutGlyphs,    // Out   Output glyph buffer
-    WORD               *pwLogClust,     // Out   Logical clusters
-    SCRIPT_VISATTR     *psva,           // Out   Visual glyph attributes
-    int                *pcGlyphs);      // Out   Count of glyphs generated
-
-MOZCE_SHUNT_API HRESULT WINAPI ScriptPlace(
-    HDC                     hdc,        // In    Optional (see under caching)
-    SCRIPT_CACHE           *psc,        // InOut Cache handle
-    const WORD             *pwGlyphs,   // In    Glyph buffer from prior ScriptShape call
-    int                     cGlyphs,    // In    Number of glyphs
-    const SCRIPT_VISATTR   *psva,       // In    Visual glyph attributes
-    SCRIPT_ANALYSIS        *psa,        // InOut Result of ScriptItemize (may have fNoGlyphIndex set)
-    int                    *piAdvance,  // Out   Advance wdiths
-    GOFFSET                *pGoffset,   // Out   x,y offset for combining glyph
-    ABC                    *pABC);      // Out   Composite ABC for the whole run (Optional)
-
-MOZCE_SHUNT_API int   WINAPI SetMapMode(HDC, int);
-MOZCE_SHUNT_API DWORD WINAPI GetCharacterPlacementW(  __in HDC hdc, __in_ecount(nCount) LPCWSTR lpString, __in int nCount, __in int nMexExtent, __inout LPGCP_RESULTSW lpResults, __in DWORD dwFlags);
-
-MOZCE_SHUNT_API BOOL MoveFileExW(
-    __in LPCWSTR lpExistingFileName,
-    __in LPCWSTR lpNewFileName,
-    __in DWORD dwFlags
-    );
-
-MOZCE_SHUNT_API int  _wrmdir(const wchar_t * _Path);
-MOZCE_SHUNT_API int _wremove(const wchar_t * _Filename);
-MOZCE_SHUNT_API int _wchmod(const wchar_t * _Filename, int _Mode);
-MOZCE_SHUNT_API wchar_t *_wgetcwd(wchar_t *buffer,int maxlen);
-MOZCE_SHUNT_API wchar_t *_wfullpath(wchar_t *abspath, const wchar_t *relpath, int maxlen);
-
-MOZCE_SHUNT_API HWND GetAncestor(HWND hwnd, UINT gaFlags);
-
-MOZCE_SHUNT_API int _chdir (const char *dirname);
-MOZCE_SHUNT_API int _wchdir (const wchar_t *dirname);
 
 #ifdef __cplusplus
 };
diff -r 17e9560465b0 build/wince/shunt/include/process.h
--- a/build/wince/shunt/include/process.h	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,1 +0,0 @@
-#include "mozce_shunt.h"
diff -r 17e9560465b0 build/wince/shunt/include/rasdlg.h
--- a/build/wince/shunt/include/rasdlg.h	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,1 +0,0 @@
-#include "mozce_shunt.h"
diff -r 17e9560465b0 build/wince/shunt/include/signal.h
--- a/build/wince/shunt/include/signal.h	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,1 +0,0 @@
-#include "mozce_shunt.h"
diff -r 17e9560465b0 build/wince/shunt/include/sys/socket.h
--- a/build/wince/shunt/include/sys/socket.h	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,1 +0,0 @@
-#include "mozce_shunt.h"
diff -r 17e9560465b0 build/wince/shunt/include/sys/stat.h
--- a/build/wince/shunt/include/sys/stat.h	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,1 +0,0 @@
-#include "mozce_shunt.h"
diff -r 17e9560465b0 build/wince/shunt/include/sys/timeb.h
--- a/build/wince/shunt/include/sys/timeb.h	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,1 +0,0 @@
-#include "mozce_shunt.h"
diff -r 17e9560465b0 build/wince/shunt/include/sys/types.h
--- a/build/wince/shunt/include/sys/types.h	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,1 +0,0 @@
-#include "mozce_shunt.h"
diff -r 17e9560465b0 build/wince/shunt/include/time_conversions.h
--- a/build/wince/shunt/include/time_conversions.h	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,156 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code, released
- * Jan 28, 2003.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 2003
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Garrett Arch Blythe, 28-January-2003
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#if !defined(__time_conversions_h)
-#define __time_conversions_h
-
-
-#define TIME_BEGIN_MACRO do {
-#define TIME_END_MACRO } while(0);
-
-/*
- * FILETIME has an epoch of 1601.
- * Precomputed the 1970 epoch so we do not have to below.
- */
-#define FILETIME_1970 116444736000000000i64
-
-/*
- * Marco to support add/sub/mul/div on a FILETIME level.
- */
-#define FILETIME_ARITH(outFileTime, inFileTime, inOperation, inValue) \
-    TIME_BEGIN_MACRO \
-        ULARGE_INTEGER buffer1; \
-        \
-        buffer1.LowPart = inFileTime.dwLowDateTime; \
-        buffer1.HighPart = inFileTime.dwHighDateTime; \
-        buffer1.QuadPart = buffer1.QuadPart inOperation inValue; \
-        outFileTime.dwLowDateTime = buffer1.LowPart; \
-        outFileTime.dwHighDateTime = buffer1.HighPart; \
-    TIME_END_MACRO
-
-/*
- * FILETIME is in 100 nanosecond units.
- * Provide macros for conversion to other second units.
- */
-#define FILETIME_2_MICROSECONDS(outTime, inFileTime) \
-    TIME_BEGIN_MACRO \
-        ULARGE_INTEGER buffer2; \
-        \
-        buffer2.LowPart = inFileTime.dwLowDateTime; \
-        buffer2.HighPart = inFileTime.dwHighDateTime; \
-        outTime = buffer2.QuadPart / 10i64; \
-    TIME_END_MACRO
-#define FILETIME_2_MILLISECONDS(outTime, inFileTime) \
-    TIME_BEGIN_MACRO \
-        ULARGE_INTEGER buffer3; \
-        \
-        buffer3.LowPart = inFileTime.dwLowDateTime; \
-        buffer3.HighPart = inFileTime.dwHighDateTime; \
-        outTime = buffer3.QuadPart / 10000i64; \
-    TIME_END_MACRO
-#define FILETIME_2_SECONDS(outTime, inFileTime) \
-    TIME_BEGIN_MACRO \
-        ULARGE_INTEGER buffer4; \
-        \
-        buffer4.LowPart = inFileTime.dwLowDateTime; \
-        buffer4.HighPart = inFileTime.dwHighDateTime; \
-        outTime = buffer4.QuadPart / 10000000i64; \
-    TIME_END_MACRO
-#define SECONDS_2_FILETIME(outFileTime, inTime) \
-    TIME_BEGIN_MACRO \
-        ULARGE_INTEGER buffer5; \
-        \
-        buffer5.QuadPart = (ULONGLONG)inTime * 10000000i64; \
-        outFileTime.dwLowDateTime = buffer5.LowPart; \
-        outFileTime.dwHighDateTime = buffer5.HighPart; \
-    TIME_END_MACRO
-
-/*
- * Conversions from FILETIME 1601 epoch time to LIBC 1970 time.epoch.
- */
-#define FILETIME_2_time_t(outTimeT, inFileTime) \
-    TIME_BEGIN_MACRO \
-        FILETIME result6; \
-        ULONGLONG conversion6; \
-        \
-        FILETIME_ARITH(result6, inFileTime, -, FILETIME_1970); \
-        FILETIME_2_SECONDS(conversion6, result6); \
-        outTimeT = (time_t)conversion6; \
-    TIME_END_MACRO
-#define time_t_2_FILETIME(outFileTime, inTimeT) \
-    TIME_BEGIN_MACRO \
-        FILETIME conversion7; \
-        \
-        SECONDS_2_FILETIME(conversion7, inTimeT); \
-        FILETIME_ARITH(outFileTime, conversion7, +, FILETIME_1970); \
-    TIME_END_MACRO
-
-
-/*
- * Sometimes SYSTEMTIME needs to be handled as well.
- */
-#define SYSTEMTIME_2_time_t(outTimeT, inSystemTime) \
-    TIME_BEGIN_MACRO \
-        FILETIME result8; \
-        \
-        SystemTimeToFileTime(&inSystemTime, &result8); \
-        FILETIME_2_time_t(outTimeT, result8); \
-    TIME_END_MACRO
-#define time_t_2_SYSTEMTIME(outSystemTime, inTimeT) \
-    TIME_BEGIN_MACRO \
-        FILETIME conversion9; \
-        \
-        time_t_2_FILETIME(conversion9, inTimeT); \
-        FileTimeToSystemTime(&conversion9, &outSystemTime); \
-    TIME_END_MACRO
-#define time_t_2_LOCALSYSTEMTIME(outSystemTime, inTimeT) \
-    TIME_BEGIN_MACRO \
-        FILETIME conversion10; \
-        FILETIME localConversion10; \
-        \
-        time_t_2_FILETIME(conversion10, inTimeT); \
-        FileTimeToLocalFileTime(&conversion10, &localConversion10); \
-        FileTimeToSystemTime(&localConversion10, &outSystemTime); \
-    TIME_END_MACRO
-
-
-
-#endif /* __time_conversions_h */
-
diff -r 17e9560465b0 build/wince/shunt/include/winspool.h
--- a/build/wince/shunt/include/winspool.h	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,1 +0,0 @@
-#include "mozce_shunt.h"
diff -r 17e9560465b0 build/wince/shunt/include/zmouse.h
--- a/build/wince/shunt/include/zmouse.h	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,1 +0,0 @@
-#include "mozce_shunt.h"
diff -r 17e9560465b0 build/wince/shunt/io.cpp
--- a/build/wince/shunt/io.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,106 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code, released
- * Jan 28, 2003.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 2003
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Garrett Arch Blythe, 28-January-2003
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#include "mozce_internal.h"
-
-extern "C" {
-#if 0
-}
-#endif
-
-MOZCE_SHUNT_API void setbuf(FILE *, char *)
-{
-}
-
-MOZCE_SHUNT_API int chmod(const char* inFilename, int inMode)
-{
-    WINCE_LOG_API_CALL("chmod called\n");
-    
-    int retval = -1;
-    
-    if(NULL != inFilename)
-    {
-        unsigned short buffer[MAX_PATH];
-        
-        int convRes = a2w_buffer(inFilename, -1, buffer, sizeof(buffer) / sizeof(unsigned short));
-        if(0 != convRes)
-        {
-            DWORD attribs = 0;
-            
-            attribs = GetFileAttributesW(buffer);
-            if(0 != attribs)
-            {
-                if(0 != (_S_IWRITE & inMode))
-                {
-                    attribs |= FILE_ATTRIBUTE_READONLY;
-                }
-                else
-                {
-                    attribs &= ~FILE_ATTRIBUTE_READONLY;
-                }
-                
-                BOOL setRes = SetFileAttributesW(buffer, attribs);
-                if(FALSE != setRes)
-                {
-                    retval = 0;
-                }
-            }
-        }
-    }
-    
-    return retval;
-}
-
-
-MOZCE_SHUNT_API int isatty(int inHandle)
-{
-    WINCE_LOG_API_CALL("-- isatty called\n");
-    
-    int retval = 0;
-    
-    return retval;
-}
-
-
-#if 0
-{
-#endif
-} /* extern "C" */
-
diff -r 17e9560465b0 build/wince/shunt/map.cpp
--- a/build/wince/shunt/map.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/build/wince/shunt/map.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -1,13 +1,83 @@
-#include "map.h"
-#include "stdlib.h"
+/* -*- Mode: C; tab-width: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is MOZCE Lib.
+ *
+ * The Initial Developer of the Original Code is Doug Turner <dougt@meer.net>.
+ 
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  John Wolfe <wolfe@lobo.us>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
 
-//right now, I'm assuming this stucture won't be huge, so implmenting with a linked list
-extern "C" {
-#if 0
-}
+
+ #include "stdlib.h"
+ #include "Windows.h"
+ 
+#include "mozce_shunt.h"
+#include "time_conversions.h"
+
+////////////////////////////////////////////////////////
+//  Environment Variable Stuff
+////////////////////////////////////////////////////////
+
+// Convert to registry soon!
+
+struct mapping{
+char* key;
+char* value;
+mapping* next;
+};
+
+static int init_i =1;
+static mapping initial_map[] = {
+#ifdef DEBUG_NSPR_ALL
+    {"NSPR_LOG_MODULES", "all:5",initial_map + (init_i++)},
+    {"NSPR_LOG_FILE","nspr.log",initial_map + (init_i++)},
+#endif  
+#ifdef TIMELINE
+    {"NS_TIMELINE_LOG_FILE","\\bin\\timeline.log",initial_map + (init_i++)},
+    {"NS_TIMELINE_ENABLE", "1",initial_map + (init_i++)},
 #endif
+    {"tmp", "/Temp",initial_map + (init_i++)},
+    {"GRE_HOME",".",initial_map + (init_i++)},
+    {"NSS_DEFAULT_DB_TYPE", "sql",initial_map + (init_i++)},
+    {"NSPR_FD_CACHE_SIZE_LOW", "10",initial_map + (init_i++)},              
+    {"NSPR_FD_CACHE_SIZE_HIGH", "30",initial_map + (init_i++)},
+    {"XRE_PROFILE_PATH", "\\Application Data\\Mozilla\\Profiles",initial_map + (init_i++)},
+    {"XRE_PROFILE_LOCAL_PATH","./profile",initial_map + (init_i++)},
+    {"XRE_PROFILE_NAME","default",0}
+};
 
+static mapping* head = initial_map;
 
+ 
 mapping* getMapping(const char* key)
 {
   mapping* cur = head;
@@ -18,7 +88,7 @@
   }
   return NULL;
 }
- 
+
 int map_put(const char* key,const char* val)
 {
   mapping* map = getMapping(key);
@@ -26,7 +96,7 @@
     if(!((map > initial_map) && 
          (map < (initial_map + init_i))))
       free( map->value);
-  }else{	
+  }else{        
     map = (mapping*)malloc(sizeof(mapping));
     map->key = (char*)malloc((strlen(key)+1)*sizeof(char));
     strcpy(map->key,key);
@@ -45,10 +115,339 @@
     return map->value;
   return NULL;
 }
+ 
+MOZCE_SHUNT_API char* getenv(const char* inName)
+{
+  return map_get(inName);
+}
+ 
+MOZCE_SHUNT_API int putenv(const char *a)
+{
+  int len = strlen(a);
+  char* key = (char*) malloc(len*sizeof(char));
+  strcpy(key,a);
+  char* val = strchr(key,'=');
+  val[0] = '\0';
+  int rv;
+  val++;
+  rv = map_put(key,val);
+  free(key);
+  return rv;
+}
 
+MOZCE_SHUNT_API char GetEnvironmentVariableW(const unsigned short * lpName, unsigned short* lpBuffer, unsigned long nSize)
+{
+  char key[256];
+  int rv = WideCharToMultiByte(CP_ACP,
+                               0,
+                               lpName,
+                               -1,
+                               key,
+                               256,
+                               NULL,
+                               NULL);
+  if(rv < 0)
+    return rv;
+  
+  char* val = map_get(key);
+  
+  if(val) 
+    {
+      MultiByteToWideChar(CP_ACP,
+                          0,
+                          val,
+                          strlen(val)+1,
+                          lpBuffer,
+                          nSize );
+      return ERROR_SUCCESS;
+    }
+  return -1;
+}
 
+MOZCE_SHUNT_API char SetEnvironmentVariableW( const unsigned short * name, const unsigned short * value )
+{
+  char key[256];
+  char val[256];
+  int rv = WideCharToMultiByte(CP_ACP,
+                               0,
+                               name,
+                               -1,
+                               key,
+                               256,
+                               NULL,
+                               NULL);
+  if(rv < 0)
+    return rv;
+  
+  rv = WideCharToMultiByte(CP_ACP,
+                           0,
+                           value,
+                           -1,
+                           val,
+                           256,
+                           NULL,
+                           NULL);
+  if(rv < 0)
+    return rv;
+  
+  return map_put(key,val);
+}
+
+////////////////////////////////////////////////////////
+//  File System Stuff
+////////////////////////////////////////////////////////
+
+MOZCE_SHUNT_API unsigned short * _wgetcwd(unsigned short * dir, unsigned long size)
+{
+  unsigned long i;
+  GetModuleFileName(GetModuleHandle (NULL), dir, MAX_PATH);
+  for (i = _tcslen(dir); i && dir[i] != TEXT('\\'); i--) {}
+  dir[i + 1] = TCHAR('\0');
+  return dir;
+}
+
+MOZCE_SHUNT_API unsigned short *_wfullpath( unsigned short *absPath, const unsigned short *relPath, unsigned long maxLength )
+{
+  if(absPath == NULL){
+    absPath = (unsigned short *)malloc(maxLength*sizeof(unsigned short));
+  }
+  _wgetcwd( absPath, maxLength);
+  unsigned long len = wcslen(absPath);
+  if(!(absPath[len-1] == TCHAR('/') || absPath[len-1] == TCHAR('\\'))&& len< maxLength){
+    absPath[len] = TCHAR('\\');
+    absPath[++len] = TCHAR('\0');
+  }
+  if(len+wcslen(relPath) < maxLength){
+    return wcscat(absPath,relPath);
+  }
+  return NULL;
+}
+
+MOZCE_SHUNT_API int _unlink(const char *filename)
+{
+  unsigned short wname[MAX_PATH];
+  
+  MultiByteToWideChar(CP_ACP,
+                      0,
+                      filename,
+                      strlen(filename)+1,
+                      wname,
+                      MAX_PATH );
+  return DeleteFileW(wname);
+}
+
+MOZCE_SHUNT_API void abort(void)
+{
+#if defined(DEBUG)
+  DebugBreak();
+#endif
+  TerminateProcess((HANDLE) GetCurrentProcessId(), 3);
+}
+
+////////////////////////////////////////////////////////
+//  Time Stuff
+////////////////////////////////////////////////////////
+
+// This is the kind of crap that makes me hate microsoft.  defined in their system headers, but not implemented anywhere.
+#define strftime __not_supported_on_device_strftime
+#define localtime __not_supported_on_device_localtime
+#define mktime __not_supported_on_device_mktime
+#define gmtime __not_supported_on_device_gmtime
+#define time __not_supported_on_device_time
+#define clock __not_supported_on_device_clock
+#include <time.h>
+#undef strftime
+#undef localtime
+#undef mktime
+#undef gmtime
+#undef time
+#undef clock
+
+extern "C" {
 #if 0
+}
+#endif
+
+static const int sDaysOfYear[12] = {
+  0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334
+};
+static struct tm tmStorage;
+
+#ifdef strftime
+#undef strftime
+#endif
+
+MOZCE_SHUNT_API size_t strftime(char *, size_t, const char *, const struct tm *)
 {
-#endif
-} /* extern "C" */
+  return 0;
+}
 
+static struct tm* mozce_gmtime_r(const time_t* inTimeT, struct tm* outRetval)
+{
+  struct tm* retval = NULL;
+  
+  if(NULL != inTimeT) {
+    SYSTEMTIME winGMTime;
+    
+    time_t_2_SYSTEMTIME(winGMTime, *inTimeT);
+    
+    outRetval->tm_sec = (int)winGMTime.wSecond;
+    outRetval->tm_min = (int)winGMTime.wMinute;
+    outRetval->tm_hour = (int)winGMTime.wHour;
+    outRetval->tm_mday = (int)winGMTime.wDay;
+    outRetval->tm_mon = (int)(winGMTime.wMonth - 1);
+    outRetval->tm_year = (int)(winGMTime.wYear - 1900);
+    outRetval->tm_wday = (int)winGMTime.wDayOfWeek;
+    outRetval->tm_isdst = -1;
+    
+    outRetval->tm_yday = (int)winGMTime.wDay + sDaysOfYear[outRetval->tm_mon];
+    if(0 == (winGMTime.wYear & 3)) {
+      if(2 < winGMTime.wMonth) {
+        if(0 == winGMTime.wYear % 100) {
+          if(0 == winGMTime.wYear % 400) {
+            outRetval->tm_yday++;
+          }
+        }else {
+          outRetval->tm_yday++;
+        }
+      }
+    }
+    retval = outRetval;
+  }
+  return retval;
+}
+
+static struct tm* mozce_localtime_r(const time_t* inTimeT,struct tm* outRetval)
+{
+  struct tm* retval = NULL;
+  
+  if(NULL != inTimeT && NULL != outRetval) {
+    SYSTEMTIME winLocalTime;
+    
+    time_t_2_LOCALSYSTEMTIME(winLocalTime, *inTimeT);
+    
+    outRetval->tm_sec = (int)winLocalTime.wSecond;
+    outRetval->tm_min = (int)winLocalTime.wMinute;
+    outRetval->tm_hour = (int)winLocalTime.wHour;
+    outRetval->tm_mday = (int)winLocalTime.wDay;
+    outRetval->tm_mon = (int)(winLocalTime.wMonth - 1);
+    outRetval->tm_year = (int)(winLocalTime.wYear - 1900);
+    outRetval->tm_wday = (int)winLocalTime.wDayOfWeek;
+    outRetval->tm_isdst = -1;
+    
+    outRetval->tm_yday = (int)winLocalTime.wDay + sDaysOfYear[outRetval->tm_mon];
+    if(0 == (winLocalTime.wYear & 3)) {
+      if(2 < winLocalTime.wMonth) {
+        if(0 == winLocalTime.wYear % 100) {
+          if(0 == winLocalTime.wYear % 400) {
+            outRetval->tm_yday++;
+          }
+        } else {
+          outRetval->tm_yday++;
+        }
+      }
+    }
+    retval = outRetval;
+  }
+  return retval;
+}
+
+
+MOZCE_SHUNT_API struct tm* localtime(const time_t* inTimeT)
+{
+  return mozce_localtime_r(inTimeT, &tmStorage);
+}
+
+MOZCE_SHUNT_API struct tm* gmtime(const time_t* inTimeT)
+{
+  return mozce_gmtime_r(inTimeT, &tmStorage);
+}
+
+
+MOZCE_SHUNT_API time_t mktime(struct tm* inTM)
+{
+  time_t retval = (time_t)-1;
+  
+  if(NULL != inTM) {
+    SYSTEMTIME winTime;
+    struct tm* gmTime = NULL;
+    
+    memset(&winTime, 0, sizeof(winTime));
+    
+    /*
+     * Ignore tm_wday and tm_yday.
+     * We likely have some problems with dst.
+     */
+    winTime.wSecond = inTM->tm_sec;
+    winTime.wMinute = inTM->tm_min;
+    winTime.wHour = inTM->tm_hour;
+    winTime.wDay = inTM->tm_mday;
+    winTime.wMonth = inTM->tm_mon + 1;
+    winTime.wYear = inTM->tm_year + 1900;
+    
+    /*
+     * First get our time_t.
+     */
+    SYSTEMTIME_2_time_t(retval, winTime);
+    
+    /*
+     * Now overwrite the struct passed in with what we believe it should be.
+     */
+    gmTime = mozce_gmtime_r(&retval, inTM);
+  }
+  return retval;
+}
+
+MOZCE_SHUNT_API time_t time(time_t *)
+{
+  time_t retval;
+  SYSTEMTIME winTime;
+  ::GetSystemTime(&winTime);
+  SYSTEMTIME_2_time_t(retval, winTime);
+  return retval;
+}
+
+MOZCE_SHUNT_API clock_t clock() 
+{
+  return -1;
+}
+
+////////////////////////////////////////////////////////
+//  Locale Stuff
+////////////////////////////////////////////////////////
+
+#define localeconv __not_supported_on_device_localeconv
+#include <locale.h>
+#undef localeconv
+
+static struct lconv s_locale_conv =
+  {
+    ".",   /* decimal_point */
+    ",",   /* thousands_sep */
+    "333", /* grouping */
+    "$",   /* int_curr_symbol */
+    "$",   /* currency_symbol */
+    "",    /* mon_decimal_point */
+    "",    /* mon_thousands_sep */
+    "",    /* mon_grouping */
+    "+",   /* positive_sign */
+    "-",   /* negative_sign */
+    '2',   /* int_frac_digits */
+    '2',   /* frac_digits */
+    1,     /* p_cs_precedes */
+    1,     /* p_sep_by_space */
+    1,     /* n_cs_precedes */
+    1,     /* n_sep_by_space */
+    1,     /* p_sign_posn */
+    1,     /* n_sign_posn */
+  };
+
+MOZCE_SHUNT_API struct lconv * localeconv(void)
+{
+  return &s_locale_conv;
+}
+ 
+ #if 0
+ {
+ #endif
+ } /* extern "C" */
diff -r 17e9560465b0 build/wince/shunt/mbstring.cpp
--- a/build/wince/shunt/mbstring.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,110 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code, released
- * Jan 28, 2003.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 2003
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Garrett Arch Blythe, 28-January-2003
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#include "mozce_internal.h"
-
-extern "C" {
-#if 0
-}
-#endif
-
-/*
-**  One day, these multi-byte routines will need to really do thier job.
-**
-**  Right now, bail with a default implementation.
-*/
-
-MOZCE_SHUNT_API unsigned char* _mbsinc(const unsigned char* inCurrent)
-{
-    WINCE_LOG_API_CALL("mbsinc called\n");
-    //IsDBCSLeadByte(path[len-1])
-    return (unsigned char*)(inCurrent + 1);
-}
-
-
-MOZCE_SHUNT_API unsigned char* _mbspbrk(const unsigned char* inString, const unsigned char* inStrCharSet)
-{
-    WINCE_LOG_API_CALL("mbspbrk called\n");
-
-    LPWSTR wstring = a2w_malloc((const char *)inString, -1, NULL);
-    LPWSTR wset    = a2w_malloc((const char *)inStrCharSet, -1, NULL);
-    LPWSTR result  = wcspbrk(wstring, wset);
-    free(wstring);
-    free(wset);
-    return (unsigned char *)result;
-}
-
-
-MOZCE_SHUNT_API unsigned char* mbsrchr(const unsigned char* inString, unsigned int inC)
-{
-    WINCE_LOG_API_CALL("mbsrchr called\n");
-
-    return (unsigned char*) strrchr((char*)inString, inC);
-}
-
-
-MOZCE_SHUNT_API unsigned char* mbschr(const unsigned char* inString, unsigned int inC)
-{
-    WINCE_LOG_API_CALL("mbschr called\n");
-    return (unsigned char*)strchr((const char*)inString, (int)inC);
-}
-
-
-MOZCE_SHUNT_API int mbsicmp(const unsigned char *string1, const unsigned char *string2)
-{
-    WINCE_LOG_API_CALL("mbsicmp called\n");
-    return _stricmp((const char*)string1, (const char*)string2);
-}
-
-MOZCE_SHUNT_API unsigned char* mbsdec(const unsigned char *string1, const unsigned char *string2)
-{
-    WINCE_LOG_API_CALL("mbsdec called\n");
-    
-    if (string1 == string2)
-        return 0;
-    
-    return (unsigned char *)string2 - 1;
-}
-
-#if 0
-{
-#endif
-} /* extern "C" */
-
diff -r 17e9560465b0 build/wince/shunt/mozce_dbg.c
--- a/build/wince/shunt/mozce_dbg.c	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,81 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla CE Shunt Library.
- *
- * The Initial Developer of the Original Code is Mozilla Corporation.
- * Portions created by the Initial Developer are Copyright (C) 2008
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   John Wolfe, 21-July-2008
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#include "mozce_internal.h"
-
-#include <stdarg.h>
-
-
-#ifndef SHUNT_LOG_ENABLED
-
-void mozce_DebugInit() { };
-void mozce_DebugDeinit() { };
-void mozce_DebugWriteToLog(char *str) { };
-
-#else
-
-#define LOGFILE     "\\Storage Card\\shuntlog.txt"
-
-FILE *gpDebugFile = NULL;
-
-void mozce_DebugInit()
-{
-    if ( NULL == gpDebugFile )
-        gpDebugFile = fopen(LOGFILE, "a+");
-}
-
-void mozce_DebugDeinit()
-{
-    if ( gpDebugFile ) {
-        fclose( gpDebugFile );
-        gpDebugFile = NULL;
-    }
-}
-
-void mozce_DebugWriteToLog(char *str)
-{
-    if ( NULL == gpDebugFile )
-        mozce_DebugInit();
-
-    if ( gpDebugFile ) {
-        fprintf(gpDebugFile, "%s", str);
-        fflush(gpDebugFile);
-    }
-}
-
-#endif
diff -r 17e9560465b0 build/wince/shunt/mozce_internal.h
--- a/build/wince/shunt/mozce_internal.h	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,193 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code, released
- * Jan 28, 2003.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 2003
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Garrett Arch Blythe, 28-January-2003
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-
-
-#if !defined __mozce_internal_h
-#define __mozce_internal_h
-
-#include <windows.h>
-#include <winsock2.h>
-
-#include "mozce_defs.h"
-
-/*
-**  Perform the requested conversion using the buffer provided.
-**
-**  inACPString     The wide character string to convert.
-**  inACPChars      Count of acp multibyte characters in inACPString to be
-**                      converted.
-**                  If -1, assume a terminated string and the terminating
-**                      character will also be appended to outWideString.
-**  outWideString   The buffer to store the converted string.
-**  inWideChars     Number of characters (not bytes) outWideString can hold.
-**                  If this value is zero, then the character count required
-**                      for the conversion is returned and outWideString is
-**                      untouched.
-**  returns int     The number of characters (not bytes) converted/required.
-**                  Zero indicates failure.
-**                  Generally you could use this value - 1 to avoid a
-**                      wcslen() call after the conversion took place
-**                      should the string be terminated (i.e. if inACPChars
-**                      included a terminating character for the conversion).
-*/
-
-int a2w_buffer(const char* inACPString, int inACPChars, unsigned short* outWideString, int inWideChars);
-
-/*
-**  Perform the requested conversion using heap memory.
-**  The caller/client of this function must use free() to release the
-**      resultant string to the heap once finished with said string.
-**  This function is best used when the conversion length of inACPString
-**      is not known beforehand.
-**
-**  inACPString     The acp multibyte character string to convert.
-**  inACPChars      Count of acp multibyte characters in inACPString to be
-**                      converted.
-**                  If -1, assume a terminated string and the terminating
-**                      character will also be appended to the return value.
-**  outWideChars    Optional argument, can be NULL.
-**                  Holds number of characters (not bytes) written into
-**                      return value.
-**                  Generally you would use outWideChars - 1 to avoid a
-**                      wcslen() call after the conversion took place
-**                      should the string be terminated (i.e. if inACPChars
-**                      included a terminating character for the conversion).
-**  returns LPWSTR  The malloced converted string which must eventually be
-**                      free()d.
-**                  NULL on failure.
-*/
-
-unsigned short* a2w_malloc(const char* inACPString, int inACPChars, int* outWideChars);
-
-/*
-**  Perform the requested conversion using the buffer provided.
-**
-**  inWideString    The wide character string to convert.
-**  inWideChars     Count of wide characters (not bytes) in
-**                      inWideString to be converted.
-**                  If -1, assume a terminated string and the terminating
-**                      character will also be appended to outACPString.
-**  outACPString    The buffer to store the converted string.
-**  inACPChars      Number of characters outACPString can hold.
-**                  If this value is zero, then the character count required
-**                      for the conversion is returned and outACPString is
-**                      untouched.
-**  returns int     The number of characters converted or required.
-**                  Zero indicates failure.
-**                  Generally you could use this value - 1 to avoid a
-**                      strlen() call after the conversion took place
-**                      should the string be terminated (i.e. if inWideChars
-**                      included a terminating character for the conversion).
-*/
-int w2a_buffer( unsigned short* inWideString, int inWideChars, char* outACPString, int inACPChars);
-
-/*
-**  Perform the requested conversion using heap memory.
-**  The caller/client of this function must use free() to release the
-**      resultant string to the heap once finished with said string.
-**  This function is best used when the conversion length of inWideString
-**      is not known beforehand.
-**
-**  inWideString    The wide character string to convert.
-**  inWideChars     Count of wide characters (not bytes) in
-**                      inWideString to be converted.
-**                  If -1, assume a terminated string and the terminating
-**                      character will also be appended to the return value.
-**  outACPChars     Optional argument, can be NULL.
-**                  Holds number of characters written into return value.
-**                  Generally you would use outACPChars - 1 to avoid a
-**                      strlen() call after the conversion took place
-**                      should the string be terminated (i.e. if inWideChars
-**                      included a terminating character for the conversion).
-**  returns LPSTR   The malloced converted string which must eventually be
-**                      free()d.
-**                  NULL on failure.
-*/
-
-char* w2a_malloc(unsigned short* inWideString, int inWideChars, int* outACPChars);
-
-
-#define charcount(array) (sizeof(array) / sizeof(array[0]))
-
-
-// We use this API internally as well as externally.
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-	MOZCE_SHUNT_API int mozce_printf(const char *, ...);
-
-#ifdef SHUNT_LOG_ENABLED
-    void mozce_DebugInit();
-    void mozce_DebugDeinit();
-    void mozce_DebugWriteToLog(char * str);
-#endif
-
-#ifdef API_LOGGING
-
-#ifdef WINCE_MEMORY_CHECKPOINTING
-    MOZCE_SHUNT_API void mozce_MemoryCheckpoint();
-
-#define WINCE_LOG_API_CALL(x)          mozce_MemoryCheckpoint(); mozce_printf(x)
-#define WINCE_LOG_API_CALL_1(x,y)      mozce_MemoryCheckpoint(); mozce_printf(x,y)
-#define WINCE_LOG_API_CALL_2(x,y,z)    mozce_MemoryCheckpoint(); mozce_printf(x,y,z)
-#else
-#define WINCE_LOG_API_CALL(x)          mozce_printf(x)
-#define WINCE_LOG_API_CALL_1(x,y)      mozce_printf(x,y)
-#define WINCE_LOG_API_CALL_2(x,y,z)    mozce_printf(x,y,z)
-#endif
-
-#else
-
-#define WINCE_LOG_API_CALL(x)
-#define WINCE_LOG_API_CALL_1(x,y)
-#define WINCE_LOG_API_CALL_2(x,y,z)
-
-#endif          // #ifdef API_LOGGING
-
-#ifdef __cplusplus
-};
-#endif
-
-int nclog (const char *fmt, ...);
-void nclograw(const char* data, long length);
-
-#endif /* __mozce_internal_h */
diff -r 17e9560465b0 build/wince/shunt/nclog.cpp
--- a/build/wince/shunt/nclog.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,164 +0,0 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is NCLog.
- *
- * The Initial Developer of the Original Code is Marco Manfredini.
- *
- * Code posted to USENET:
- *
- *     http://groups-beta.google.com/group/microsoft.public.windowsce.embedded/
- *            browse_thread/thread/352904e5ff1bfeb/
- *            9ad05ef17dda0203?q=outputdebugstring+wince#9ad05ef17dda0203
- *
- * Portions created by the Initial Developer are Copyright (C) 2005
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *    Doug Turner <dougt@meer.net>
- * 
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-
-#include "mozce_internal.h"
-
-#ifdef USE_NC_LOGGING
-
-
-#include "winsock.h"
-#include <stdarg.h>
-#include <stdio.h>
-
-static SOCKET wsa_socket=INVALID_SOCKET;
-#pragma comment(lib , "winsock")
-
-static unsigned short theLogPort;
-
-// bind the log socket to a specific port.
-static bool wsa_bind(unsigned short port)
-{
-  SOCKADDR_IN addr;
-  addr.sin_family = AF_INET;
-  addr.sin_port = htons(port);
-  addr.sin_addr.s_addr = htonl(INADDR_ANY);
-  int r=bind(wsa_socket,(sockaddr*)&addr,sizeof(addr));
-  if (r==0) theLogPort=port;
-  return (r==0);
-  
-}
-
-// initialize everything, if the socket isn't open.
-static bool wsa_init()
-{
-  if (wsa_socket != INVALID_SOCKET) return true;
-  int r;
-  WSADATA wd;
-  BOOL bc=true;
-  
-  if (0 != WSAStartup(0x101, &wd)) 
-  {
-	  MessageBox(0, L"WSAStartup failed", L"ERROR", 0);
-  	  goto error;
-  }
-  wsa_socket=socket(PF_INET, SOCK_DGRAM, 0);
-  if (wsa_socket == INVALID_SOCKET)
-  {
-	  MessageBox(0, L"socket failed", L"ERROR", 0);
-	  goto error;
-  }
-  r=setsockopt(wsa_socket, SOL_SOCKET, SO_BROADCAST, (char*)&bc,
-               sizeof(bc));
-  if (r!=0)
-  {
-	MessageBox(0, L"setsockopt failed", L"ERROR", 0);
-	goto error;
-  }
-
-  if (wsa_bind(9998)) return true; // bind to default port.
-
-  MessageBox(0, L"Can Not Bind To Port", L"ERROR", 0);
-
-error:
-  if (wsa_socket != INVALID_SOCKET) closesocket(wsa_socket);
-  return false;
-
-}
-
-// can be called externally to select a different port for operations
-bool set_nclog_port(unsigned short x) { return wsa_bind(x); }
-
-static void wsa_send(const char *x)
-{
-  SOCKADDR_IN sa;
-  sa.sin_family = AF_INET;
-  sa.sin_port = htons(theLogPort);
-  sa.sin_addr.s_addr = htonl(INADDR_BROADCAST);
-  
-  sendto(wsa_socket, x, strlen(x), 0, (sockaddr*)&sa, sizeof(sa));
-}
-
-// format input, convert to 8-bit and send.
-int nclog (const char *fmt, ...)
-{
-  va_list vl;
-  va_start(vl,fmt);
-  char buf[1024]; // to bad CE hasn't got wvnsprintf
-  sprintf(buf,fmt,vl);
-  wsa_init();
-  wsa_send(buf);
-  return 0;
-}
-
-void nclograw(const char* data, long length)
-{
-  wsa_init();
-  
-  SOCKADDR_IN sa;
-  sa.sin_family = AF_INET;
-  sa.sin_port = htons(theLogPort);
-  sa.sin_addr.s_addr = htonl(INADDR_BROADCAST);
-  
-  sendto(wsa_socket, data, length, 0, (sockaddr*)&sa, sizeof(sa));
-}
-
-// finalize the socket on program termination.
-struct _nclog_module
-{
-  ~_nclog_module()
-  {
-    if (wsa_socket!=INVALID_SOCKET)
-    {
-      nclog("nclog goes down\n");
-      shutdown(wsa_socket,2);
-      closesocket(wsa_socket);
-    }
-  }
-  
-};
-
-static _nclog_module module; 
-
-
-#endif
diff -r 17e9560465b0 build/wince/shunt/process.cpp
--- a/build/wince/shunt/process.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,102 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * ***** BEG LICENSE BLOCK *****
- * ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code, released
- * Jan 28, 2003.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 2003
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Garrett Arch Blythe, 28-January-2003
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#include "mozce_internal.h"
-
-#include "map.h"
-
-
-extern "C" {
-#if 0
-}
-#endif
-
-#include "kfuncs.h"
-
-MOZCE_SHUNT_API void abort(void)
-{
-    WINCE_LOG_API_CALL("abort called\n");
-
-#if defined(DEBUG)
-    DebugBreak();
-#endif
-    TerminateProcess((HANDLE) GetCurrentProcessId(), 3);
-}
-
-
-MOZCE_SHUNT_API char* getenv(const char* inName)
-{
-    return map_get(inName);
-}
-
-MOZCE_SHUNT_API int putenv(const char *a)
-{
-    WINCE_LOG_API_CALL_1("mozce_PutEnv called %s\n",a);
-
-    int len = strlen(a);
-    char* key = (char*) malloc(len*sizeof(char));
-    strcpy(key,a);
-    char* val = strchr(key,'=');
-    val[0] = '\0';
-    int rv;
-    val++;
-    rv = map_put(key,val);
-    free(key);
-    return rv;
-}
-
-MOZCE_SHUNT_API int getpid(void)
-{
-    WINCE_LOG_API_CALL("getpid called\n");
-    
-    int retval = 0;
-    
-    retval = (int)GetCurrentProcessId();
-    
-    return retval;
-}
-
-
-#if 0
-{
-#endif
-} /* extern "C" */
-
diff -r 17e9560465b0 build/wince/shunt/signal.cpp
--- a/build/wince/shunt/signal.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,102 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code, released
- * Jan 28, 2003.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 2003
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Garrett Arch Blythe, 28-January-2003
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#include "mozce_internal.h"
-
-extern "C" {
-#if 0
-}
-#endif
-
-
-static _sigsig sigArray[_SIGCOUNT];
-
-
-static void defaultSighandler(int inSignal)
-{
-    // From process.cpp
-    extern void abort(void);
-    abort();
-}
-
-
-MOZCE_SHUNT_API int raise(int inSignal)
-{
-    WINCE_LOG_API_CALL("raise called\n");
-
-    void (*handler)(int inSignal) = defaultSighandler;
-
-    if(inSignal >= 0 && inSignal < _SIGCOUNT)
-    {
-        if(NULL != sigArray[inSignal])
-        {
-            handler = sigArray[inSignal];
-        }
-    }
-
-    handler(inSignal);
-    return 0;
-}
-
-
-MOZCE_SHUNT_API _sigsig signal(int inSignal, _sigsig inFunc)
-{
-    WINCE_LOG_API_CALL("signal called\n");
-
-    void (*retval)(int inSignal) = defaultSighandler;
-
-    if(inSignal >= 0 && inSignal < _SIGCOUNT)
-    {
-        if(NULL != sigArray[inSignal])
-        {
-            retval = sigArray[inSignal];
-        }
-        sigArray[inSignal] = inFunc;
-    }
-
-    return retval;
-}
-
-
-#if 0
-{
-#endif
-} /* extern "C" */
-
diff -r 17e9560465b0 build/wince/shunt/stat.cpp
--- a/build/wince/shunt/stat.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,150 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code, released
- * Jan 28, 2003.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 2003
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Garrett Arch Blythe, 28-January-2003
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#include "mozce_internal.h"
-#include "mozce_defs.h"
-#include "time_conversions.h"
-
-extern "C" {
-#if 0
-}
-#endif
-
-MOZCE_SHUNT_API int fstat(FILE* handle, struct stat* buff)
-{
-    WINCE_LOG_API_CALL("fstat called\n");
-
-    int position = ftell(handle);
-    if (position < 0)
-        return -1;
-
-    if (fseek(handle, 0, SEEK_END) < 0)
-        return -1;
-
-    buff->st_size = ftell(handle);
-
-    if (fseek(handle, position, SEEK_SET) < 0)
-        return -1;
-
-    if (buff->st_size < 0)
-        return -1;
-
-    buff->st_mode = _S_IFREG | _S_IREAD | _S_IWRITE | _S_IEXEC;
-    /* can't get time from a file handle on wince */
-    buff->st_ctime = 0;
-    buff->st_atime = 0;
-    buff->st_mtime = 0;
-    return 0;
-}
-
-MOZCE_SHUNT_API int stat(const char* inPath, struct stat* outStats)
-{
-    WINCE_LOG_API_CALL("stat called\n");
-    
-    int retval = -1;
-    
-    if(NULL != outStats)
-    {
-        memset(outStats, 0, sizeof(struct stat));
-        
-        if(NULL != inPath)
-        {
-            WCHAR wPath[MAX_PATH];
-            
-            int convRes = a2w_buffer(inPath, -1, wPath, sizeof(wPath) / sizeof(WCHAR));
-            if(0 != convRes)
-            {
-                HANDLE readHandle;
-                WIN32_FIND_DATA findData;
-                readHandle = FindFirstFileW(wPath, &findData); 
-                
-                if (readHandle != INVALID_HANDLE_VALUE && readHandle != NULL)
-                {
-                    retval = 0;
-                    outStats->st_size = findData.nFileSizeLow;
-                    
-                    if(findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
-                    {
-                        outStats->st_mode = _S_IFDIR;
-                    }
-                    else
-                    {
-                        outStats->st_mode = _S_IFREG;
-                    }
-                    
-                    
-                    FILETIME_2_time_t(outStats->st_ctime, findData.ftCreationTime);
-                    FILETIME_2_time_t(outStats->st_atime, findData.ftLastAccessTime);
-                    FILETIME_2_time_t(outStats->st_mtime, findData.ftLastWriteTime);
-                    
-                    outStats->st_mode |= _S_IREAD;
-                    if(0 == (FILE_ATTRIBUTE_READONLY & findData.dwFileAttributes))
-                    {
-                        outStats->st_mode |= _S_IWRITE;
-                    }
-                    if(FILE_ATTRIBUTE_DIRECTORY & findData.dwFileAttributes)
-                    {
-                        outStats->st_mode |= _S_IFDIR;
-                    }
-                    else
-                    {
-                        outStats->st_mode |= _S_IFREG;
-                    }
-                    
-                }
-                else
-                {	
-                    // From Errno.
-                    extern int errno;
-                    errno = ENOENT;
-                }
-            }
-        }
-    }
-    
-    return retval;
-}
-
-
-#if 0
-{
-#endif
-} /* extern "C" */
-
diff -r 17e9560465b0 build/wince/shunt/stdio.cpp
--- a/build/wince/shunt/stdio.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,343 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code, released
- * Jan 28, 2003.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 2003
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Garrett Arch Blythe, 28-January-2003
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#include "mozce_internal.h"
-
-#include <stdarg.h>
-
-extern "C" {
-#if 0
-}
-#endif
-
-
-#define MAXFDS 100
-
-typedef struct _fdtab_block
-{
-    int fd;
-    FILE* file;
-    
-} _fdtab_block;
-
-
-_fdtab_block _fdtab[MAXFDS];
-
-
-
-
-
-void
-_initfds()
-{
-    static int fdsinitialized = 0;
-    
-    if(fdsinitialized)
-        return;
-    
-    for (int i = 0; i < MAXFDS; i++)
-        _fdtab[i].fd = -1;
-    
-    fdsinitialized = 1;
-}
-
-int
-_getnewfd()
-{
-    int i;
-    
-    for(i = 0; i < MAXFDS; i++)
-    {
-        if(_fdtab[i].fd == -1)
-            return i;
-    }
-    
-    return -1;
-}
-
-
-MOZCE_SHUNT_API int _waccess(const wchar_t *path, int mode)
-{
-    WINCE_LOG_API_CALL("-- _waccess called\n");
-    
-    return 0;
-}
-
-
-MOZCE_SHUNT_API int access(const char *path, int mode)
-{
-    WINCE_LOG_API_CALL("-- access called\n");
-    
-    return 0;
-}
-
-MOZCE_SHUNT_API void rewind(FILE* inStream)
-{
-    WINCE_LOG_API_CALL("rewind called\n");
-    
-    fseek(inStream, 0, SEEK_SET);
-}
-
-
-MOZCE_SHUNT_API FILE* fdopen(int fd, const char* inMode)
-{
-    WINCE_LOG_API_CALL("-- fdopen called (mode is ignored!) \n");
-    
-    if(fd < 0 || fd >= MAXFDS || _fdtab[fd].fd == -1)
-        return 0;
-    
-    return _fdtab[fd].file;
-}
-
-
-MOZCE_SHUNT_API void perror(const char* inString)
-{
-    WINCE_LOG_API_CALL("perror called\n");
-    
-    fprintf(stderr, "%s", inString);
-}
-
-
-MOZCE_SHUNT_API int remove(const char* inPath)
-{
-    WINCE_LOG_API_CALL_1("remove called on %s\n", inPath);
-    
-    int retval = -1;
-    
-    if(NULL != inPath)
-    {
-        unsigned short wPath[MAX_PATH];
-        
-        if(0 != a2w_buffer(inPath, -1, wPath, sizeof(wPath) / sizeof(unsigned short)))
-        {
-            if(FALSE != DeleteFileW(wPath))
-            {
-                retval = 0;
-                
-            }
-        }
-    }
-    
-    return retval;
-}
-
-MOZCE_SHUNT_API int setmode(FILE*, int) 
-{
-    return 0;
-}
-MOZCE_SHUNT_API int _chdir (const char *dirname)
-{
-    return 0;
-}
-MOZCE_SHUNT_API int _wchdir (const wchar_t *dirname)
-{
-    return 0;
-}
-MOZCE_SHUNT_API char* getcwd(char* buff, size_t size)
-{
-    WINCE_LOG_API_CALL("getcwd called.\n");
-
-    int i;
-    unsigned short dir[MAX_PATH];
-    GetModuleFileName(GetModuleHandle (NULL), dir, MAX_PATH);
-    for (i = _tcslen(dir); i && dir[i] != TEXT('\\'); i--) {}
-    dir[i + 1] = TCHAR('\0');
-    
-    w2a_buffer(dir, -1, buff, size);
-    
-    return buff;
-}
-
-MOZCE_SHUNT_API int mozce_printf(const char * format, ...)
-{
-    //#ifdef API_LOGGING
-#define MAX_CHARS_IN_VARIABLE_STRING 1024
-    
-    char buf[MAX_CHARS_IN_VARIABLE_STRING];
-    
-    TCHAR tBuf[MAX_CHARS_IN_VARIABLE_STRING];
-    
-    va_list ptr;
-    va_start(ptr,format);
-    vsprintf(buf,format,ptr);
-    
-    mbstowcs(tBuf, buf, MAX_CHARS_IN_VARIABLE_STRING);
-    
-    OutputDebugString(tBuf);
-
-#ifdef SHUNT_LOG_ENABLED
-    mozce_DebugWriteToLog(buf);
-#endif
-    
-    return 1;
-    //#endif
-
-    return 0;
-}
-
-static void flags2binstr(int flags, char* buffer)
-{
-		// this is not even close to correct.
-		// we need this only temporarly -- we are hoping to remove
-		// open/close/read/write in favor of fopen directly.
-
-    if (flags & O_RDWR || (flags & O_WRONLY))  // write only == read|write
-    {
-        if (flags & O_APPEND)
-        {
-            strcpy(buffer, "ab+");
-        }
-        else
-        {
-            strcpy(buffer, "wb+");
-        }
-    }
-    else
-    {
-        strcpy(buffer, "rb");
-    }
-}
-
-MOZCE_SHUNT_API int open(const char *pathname, int flags, int mode)
-{
-    WINCE_LOG_API_CALL("open called\n");
-    
-    _initfds();
-    
-    
-    char flagsstr[10];
-    *flagsstr = '\0';
-    
-    flags2binstr(flags, flagsstr);
-    if (*flagsstr == '\0')
-        return -1;
-    
-    
-    FILE* file = fopen(pathname, flagsstr);
-    
-    int fd = -1;
-    
-    if (file)
-    {
-        fd = _getnewfd();
-        
-        _fdtab[fd].fd = fd;
-        _fdtab[fd].file = file;
-        
-        fflush(file);
-        fread(NULL, 0, 0, file);
-    }
-    
-    return fd;
-}
-
-
-MOZCE_SHUNT_API int close(int fd)
-{
-    WINCE_LOG_API_CALL("close called\n");
-    
-    if(fd < 0 || fd >= MAXFDS || _fdtab[fd].fd == -1)
-        return -1;
-    
-    fclose(_fdtab[fd].file);
-    _fdtab[fd].fd = -1;
-    
-    return 0;
-}
-
-MOZCE_SHUNT_API size_t read(int fd, void* buffer, size_t count)
-{
-    WINCE_LOG_API_CALL("read called\n");
-    
-    if(fd < 0 || fd >= MAXFDS || _fdtab[fd].fd == -1)
-        return -1;
-    
-    size_t num = fread(buffer, 1, count, _fdtab[fd].file);
-    
-    if (ferror(_fdtab[fd].file))
-        return -1;
-    
-    return num;
-}
-
-
-MOZCE_SHUNT_API size_t write(int fd, const void* buffer, size_t count)
-{
-    WINCE_LOG_API_CALL("write called\n");
-    
-    if(fd < 0 || fd >= MAXFDS || _fdtab[fd].fd == -1)
-        return -1;
-    
-    size_t num = fwrite(buffer, 1, count, _fdtab[fd].file);
-    if (ferror(_fdtab[fd].file))
-        return -1;
-    
-    return num;
-}
-
-
-MOZCE_SHUNT_API int unlink(const char *pathname)
-{
-    WINCE_LOG_API_CALL("unlink called\n");
-    return remove(pathname);
-}
-
-
-MOZCE_SHUNT_API int lseek(int fd, int offset, int whence)
-{
-    WINCE_LOG_API_CALL("lseek called\n");
-    
-    if(fd < 0 || fd >= MAXFDS || _fdtab[fd].fd == -1)
-        return -1;
-    
-    int newpos = -1;
-    int error = fseek(_fdtab[fd].file, offset, whence);
-    
-    if (!error)
-        newpos = ftell(_fdtab[fd].file);
-    return newpos;
-}
-
-
-#if 0
-{
-#endif
-} /* extern "C" */
-
diff -r 17e9560465b0 build/wince/shunt/stdlib.cpp
--- a/build/wince/shunt/stdlib.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,231 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code, released
- * Jan 28, 2003.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 2003
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Garrett Arch Blythe, 28-January-2003
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-#include <string.h>
-#include <stdio.h>
-#include "mozce_internal.h"
-
-#define _MAX_FNAME          256
-#define _MAX_DIR            _MAX_FNAME
-#define _MAX_EXT            _MAX_FNAME
-
-
-extern "C" {
-#if 0
-}
-#endif
-
-MOZCE_SHUNT_API char *fullpath(char *absPath, const char *relPath, size_t maxLength)
-{
-    WINCE_LOG_API_CALL("fullpath called\n");
-
-    if (relPath[0] != '\\') 
-    {
-        int i;
-        unsigned short dir[MAX_PATH];
-        GetModuleFileName(GetModuleHandle (NULL), dir, MAX_PATH);
-        for (i = _tcslen(dir); i && dir[i] != TEXT('\\'); i--) {}
-        
-        dir[i + 1] = TCHAR('\0');
-        
-        w2a_buffer(dir, -1, absPath, maxLength);
-    }
-    strcpy(absPath, relPath);
-    
-    return absPath;
-}
-
-MOZCE_SHUNT_API void splitpath(const char* inPath, char* outDrive, char* outDir, char* outFname, char* outExt)
-{
-    WINCE_LOG_API_CALL("splitpath called\n");
-
-    if(NULL != outDrive)
-    {
-        *outDrive = '\0';
-    }
-    if(NULL != outDir)
-    {
-        *outDir = '\0';
-    }
-    if(NULL != outFname)
-    {
-        *outFname = '\0';
-    }
-    if(NULL != outExt)
-    {
-        *outExt = '\0';
-    }
-
-    if(NULL != inPath && '\0' != *inPath)
-    {
-                char* dup = (char*) malloc(strlen(inPath));
-                if(NULL != dup)
-        {
-            strcpy(dup, inPath);
-                        /*
-            **  Change all forward slashes to back.
-            */
-            char* convert = dup;
-            do
-            {
-                if('/' == *convert)
-                {
-                    *convert = '\\';
-                }
-                convert++;
-            }
-            while(*convert);
-
-            /*
-            **  Find last slash first.
-            */
-            char* slash = strrchr(dup, '\\');
-
-            /*
-            **  Find extension, must be after any slash.
-            */
-            char* ext = NULL;
-            if(NULL == slash)
-            {
-                ext = strchr(dup, '.');
-            }
-            else
-            {
-                ext = strchr(slash, '.');
-            }
-
-            /*
-            **  Reap extension.
-            */
-            if(NULL != ext)
-            {
-                if(NULL != outExt)
-                {
-                    strncpy(outExt, ext, _MAX_EXT);
-                }
-
-                *ext = '\0';
-            }
-
-            /*
-            **  Reap filename.
-            */
-            char* fname = NULL;
-            if(NULL == slash)
-            {
-                fname = dup;
-            }
-            else
-            {
-                fname = slash + 1;
-            }
-
-            if(NULL != outFname)
-            {
-                strncpy(outFname, fname, _MAX_FNAME);
-            }
-
-            *fname = '\0';
-
-            /*
-            **  Reap directory.
-            */
-            if(NULL != slash && NULL != outDir)
-            {
-                strncpy(outDir, dup, _MAX_DIR);
-            }
-
-            free(dup);
-        }
-    }
-}
-
-
-MOZCE_SHUNT_API void makepath(char* outPath, const char* inDrive, const char* inDir, const char* inFname, const char* inExt)
-{
-    WINCE_LOG_API_CALL("makepath called\n");
-
-    if(NULL != outPath)
-    {
-        int dirLen = 0;
-        if(NULL != inDir)
-        {
-            dirLen = strlen(inDir);
-            if(dirLen)
-            {
-                dirLen--;
-            }
-        }
-        _snprintf(outPath, _MAX_PATH, "%s%s%s%s%s",
-                  (NULL != inDir) ? inDir : "",
-                  (NULL != inDir && '\\' != inDir[dirLen] && '/' != inDir[dirLen]) ? "\\" : "",
-                  (NULL != inFname) ? inFname : "",
-                  (NULL != inExt && '.' != inExt[0]) ? "." : "",
-                  (NULL != inExt) ? inExt : ""
-                  );
-    }
-}
-
-MOZCE_SHUNT_API int mozce_strcmpi(const char *dest, const char *src)
-{
-    WINCE_LOG_API_CALL("mozce_strcmpi called\n");
-
-    int f,l;
-    
-    do {
-        if ( ((f = (unsigned char)(*(dest++))) >= 'A') && (f <= 'Z') )
-            f -= ('A' - 'a');
-        
-        if ( ((l = (unsigned char)(*(src++))) >= 'A') && (l <= 'Z') )
-            l -= ('A' - 'a');
-    } while ( f && (f == l) );
-
-    return(f - l);
-}
-
-MOZCE_SHUNT_API int _unlink(const char *filename )
-{
-    wchar_t wname[MAX_PATH];
-    a2w_buffer(filename, MAX_PATH, wname, MAX_PATH);
-    return ::DeleteFileW(wname);
-}
-#if 0
-{
-#endif
-} /* extern "C" */
diff -r 17e9560465b0 build/wince/shunt/string.cpp
--- a/build/wince/shunt/string.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,58 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code, released
- * Jan 28, 2003.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 2003
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Garrett Arch Blythe, 28-January-2003
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#include "mozce_internal.h"
-
-extern "C" {
-#if 0
-}
-#endif
-
-MOZCE_SHUNT_API char* strerror(int inErrno)
-{
-    WINCE_LOG_API_CALL("strerror called\n");
-    return "Unknown Error";
-}
-
-#if 0
-{
-#endif
-} /* extern "C" */
-
diff -r 17e9560465b0 build/wince/shunt/time.cpp
--- a/build/wince/shunt/time.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,238 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code, released
- * Jan 28, 2003.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 2003
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Garrett Arch Blythe, 28-January-2003
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#include "mozce_internal.h"
-#include "time_conversions.h"
-
-#define strftime __not_supported_on_device_strftime
-#define localtime __not_supported_on_device_localtime
-#define mktime __not_supported_on_device_mktime
-#define gmtime __not_supported_on_device_gmtime
-#define time __not_supported_on_device_time
-#include <time.h>
-#undef strftime
-#undef localtime
-#undef mktime
-#undef gmtime
-#undef time
-
-extern "C" {
-#if 0
-}
-#endif
-
-
-static const int sDaysOfYear[12] = {
-    0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334
-};
-static struct tm tmStorage;
-
-#ifdef strftime
-#undef strftime
-#endif
-
-MOZCE_SHUNT_API size_t strftime(char *, size_t, const char *, const struct tm *)
-{
-    WINCE_LOG_API_CALL("mozce_strftime called\n");
-    return 0;
-}
-
-
-MOZCE_SHUNT_API struct tm* mozce_localtime_r(const time_t* inTimeT,struct tm* outRetval)
-{
-    WINCE_LOG_API_CALL("tm* mozce_localtime_r called\n");
-
-    struct tm* retval = NULL;
-
-    if(NULL != inTimeT && NULL != outRetval)
-    {
-        SYSTEMTIME winLocalTime;
-        
-        time_t_2_LOCALSYSTEMTIME(winLocalTime, *inTimeT);
-        
-        outRetval->tm_sec = (int)winLocalTime.wSecond;
-        outRetval->tm_min = (int)winLocalTime.wMinute;
-        outRetval->tm_hour = (int)winLocalTime.wHour;
-        outRetval->tm_mday = (int)winLocalTime.wDay;
-        outRetval->tm_mon = (int)(winLocalTime.wMonth - 1);
-        outRetval->tm_year = (int)(winLocalTime.wYear - 1900);
-        outRetval->tm_wday = (int)winLocalTime.wDayOfWeek;
-        outRetval->tm_isdst = -1;
-
-        outRetval->tm_yday = (int)winLocalTime.wDay + sDaysOfYear[outRetval->tm_mon];
-        if(0 == (winLocalTime.wYear & 3))
-        {
-            if(2 < winLocalTime.wMonth)
-            {
-                if(0 == winLocalTime.wYear % 100)
-                {
-                    if(0 == winLocalTime.wYear % 400)
-                    {
-                        outRetval->tm_yday++;
-                    }
-                }
-                else
-                {
-                    outRetval->tm_yday++;
-                }
-            }
-        }
-
-        retval = outRetval;
-    }
-
-    return retval;
-}
-
-
-MOZCE_SHUNT_API struct tm* localtime(const time_t* inTimeT)
-{
-    WINCE_LOG_API_CALL("tm* mozce_localtime called\n");
-
-    return mozce_localtime_r(inTimeT, &tmStorage);
-}
-
-
-MOZCE_SHUNT_API struct tm* mozce_gmtime_r(const time_t* inTimeT, struct tm* outRetval)
-{
-    WINCE_LOG_API_CALL("tm* mozce_gmtime_r called\n");
-
-    struct tm* retval = NULL;
-
-    if(NULL != inTimeT)
-    {
-        SYSTEMTIME winGMTime;
-        
-        time_t_2_SYSTEMTIME(winGMTime, *inTimeT);
-        
-        outRetval->tm_sec = (int)winGMTime.wSecond;
-        outRetval->tm_min = (int)winGMTime.wMinute;
-        outRetval->tm_hour = (int)winGMTime.wHour;
-        outRetval->tm_mday = (int)winGMTime.wDay;
-        outRetval->tm_mon = (int)(winGMTime.wMonth - 1);
-        outRetval->tm_year = (int)(winGMTime.wYear - 1900);
-        outRetval->tm_wday = (int)winGMTime.wDayOfWeek;
-        outRetval->tm_isdst = -1;
-
-        outRetval->tm_yday = (int)winGMTime.wDay + sDaysOfYear[outRetval->tm_mon];
-        if(0 == (winGMTime.wYear & 3))
-        {
-            if(2 < winGMTime.wMonth)
-            {
-                if(0 == winGMTime.wYear % 100)
-                {
-                    if(0 == winGMTime.wYear % 400)
-                    {
-                        outRetval->tm_yday++;
-                    }
-                }
-                else
-                {
-                    outRetval->tm_yday++;
-                }
-            }
-        }
-
-        retval = outRetval;
-    }
-
-    return retval;
-}
-
-
-MOZCE_SHUNT_API struct tm* gmtime(const time_t* inTimeT)
-{
-    WINCE_LOG_API_CALL("tm* mozce_gmtime called\n");
-
-    return mozce_gmtime_r(inTimeT, &tmStorage);
-}
-
-
-MOZCE_SHUNT_API time_t mktime(struct tm* inTM)
-{
-    WINCE_LOG_API_CALL("mozce_mktime called\n");
-
-    time_t retval = (time_t)-1;
-
-    if(NULL != inTM)
-    {
-        SYSTEMTIME winTime;
-        struct tm* gmTime = NULL;
-
-        memset(&winTime, 0, sizeof(winTime));
-
-        /*
-         * Ignore tm_wday and tm_yday.
-         * We likely have some problems with dst.
-         */
-        winTime.wSecond = inTM->tm_sec;
-        winTime.wMinute = inTM->tm_min;
-        winTime.wHour = inTM->tm_hour;
-        winTime.wDay = inTM->tm_mday;
-        winTime.wMonth = inTM->tm_mon + 1;
-        winTime.wYear = inTM->tm_year + 1900;
-
-        /*
-         * First get our time_t.
-         */
-        SYSTEMTIME_2_time_t(retval, winTime);
-
-        /*
-         * Now overwrite the struct passed in with what we believe it should be.
-         */
-        gmTime = mozce_gmtime_r(&retval, inTM);
-    }
-
-    return retval;
-}
-
-MOZCE_SHUNT_API time_t time(time_t *)
-{
-  time_t retval;
-  SYSTEMTIME winTime;
-  ::GetSystemTime(&winTime);
-  SYSTEMTIME_2_time_t(retval, winTime);
-  return retval;
-}
-#if 0
-{
-#endif
-} /* extern "C" */
-
diff -r 17e9560465b0 build/wince/shunt/time_conversions.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/build/wince/shunt/time_conversions.h	Thu Oct 30 05:41:44 2008 -0400
@@ -0,0 +1,156 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code, released
+ * Jan 28, 2003.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2003
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Garrett Arch Blythe, 28-January-2003
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#if !defined(__time_conversions_h)
+#define __time_conversions_h
+
+
+#define TIME_BEGIN_MACRO do {
+#define TIME_END_MACRO } while(0);
+
+/*
+ * FILETIME has an epoch of 1601.
+ * Precomputed the 1970 epoch so we do not have to below.
+ */
+#define FILETIME_1970 116444736000000000i64
+
+/*
+ * Marco to support add/sub/mul/div on a FILETIME level.
+ */
+#define FILETIME_ARITH(outFileTime, inFileTime, inOperation, inValue) \
+    TIME_BEGIN_MACRO \
+        ULARGE_INTEGER buffer1; \
+        \
+        buffer1.LowPart = inFileTime.dwLowDateTime; \
+        buffer1.HighPart = inFileTime.dwHighDateTime; \
+        buffer1.QuadPart = buffer1.QuadPart inOperation inValue; \
+        outFileTime.dwLowDateTime = buffer1.LowPart; \
+        outFileTime.dwHighDateTime = buffer1.HighPart; \
+    TIME_END_MACRO
+
+/*
+ * FILETIME is in 100 nanosecond units.
+ * Provide macros for conversion to other second units.
+ */
+#define FILETIME_2_MICROSECONDS(outTime, inFileTime) \
+    TIME_BEGIN_MACRO \
+        ULARGE_INTEGER buffer2; \
+        \
+        buffer2.LowPart = inFileTime.dwLowDateTime; \
+        buffer2.HighPart = inFileTime.dwHighDateTime; \
+        outTime = buffer2.QuadPart / 10i64; \
+    TIME_END_MACRO
+#define FILETIME_2_MILLISECONDS(outTime, inFileTime) \
+    TIME_BEGIN_MACRO \
+        ULARGE_INTEGER buffer3; \
+        \
+        buffer3.LowPart = inFileTime.dwLowDateTime; \
+        buffer3.HighPart = inFileTime.dwHighDateTime; \
+        outTime = buffer3.QuadPart / 10000i64; \
+    TIME_END_MACRO
+#define FILETIME_2_SECONDS(outTime, inFileTime) \
+    TIME_BEGIN_MACRO \
+        ULARGE_INTEGER buffer4; \
+        \
+        buffer4.LowPart = inFileTime.dwLowDateTime; \
+        buffer4.HighPart = inFileTime.dwHighDateTime; \
+        outTime = buffer4.QuadPart / 10000000i64; \
+    TIME_END_MACRO
+#define SECONDS_2_FILETIME(outFileTime, inTime) \
+    TIME_BEGIN_MACRO \
+        ULARGE_INTEGER buffer5; \
+        \
+        buffer5.QuadPart = (ULONGLONG)inTime * 10000000i64; \
+        outFileTime.dwLowDateTime = buffer5.LowPart; \
+        outFileTime.dwHighDateTime = buffer5.HighPart; \
+    TIME_END_MACRO
+
+/*
+ * Conversions from FILETIME 1601 epoch time to LIBC 1970 time.epoch.
+ */
+#define FILETIME_2_time_t(outTimeT, inFileTime) \
+    TIME_BEGIN_MACRO \
+        FILETIME result6; \
+        ULONGLONG conversion6; \
+        \
+        FILETIME_ARITH(result6, inFileTime, -, FILETIME_1970); \
+        FILETIME_2_SECONDS(conversion6, result6); \
+        outTimeT = (time_t)conversion6; \
+    TIME_END_MACRO
+#define time_t_2_FILETIME(outFileTime, inTimeT) \
+    TIME_BEGIN_MACRO \
+        FILETIME conversion7; \
+        \
+        SECONDS_2_FILETIME(conversion7, inTimeT); \
+        FILETIME_ARITH(outFileTime, conversion7, +, FILETIME_1970); \
+    TIME_END_MACRO
+
+
+/*
+ * Sometimes SYSTEMTIME needs to be handled as well.
+ */
+#define SYSTEMTIME_2_time_t(outTimeT, inSystemTime) \
+    TIME_BEGIN_MACRO \
+        FILETIME result8; \
+        \
+        SystemTimeToFileTime(&inSystemTime, &result8); \
+        FILETIME_2_time_t(outTimeT, result8); \
+    TIME_END_MACRO
+#define time_t_2_SYSTEMTIME(outSystemTime, inTimeT) \
+    TIME_BEGIN_MACRO \
+        FILETIME conversion9; \
+        \
+        time_t_2_FILETIME(conversion9, inTimeT); \
+        FileTimeToSystemTime(&conversion9, &outSystemTime); \
+    TIME_END_MACRO
+#define time_t_2_LOCALSYSTEMTIME(outSystemTime, inTimeT) \
+    TIME_BEGIN_MACRO \
+        FILETIME conversion10; \
+        FILETIME localConversion10; \
+        \
+        time_t_2_FILETIME(conversion10, inTimeT); \
+        FileTimeToLocalFileTime(&conversion10, &localConversion10); \
+        FileTimeToSystemTime(&localConversion10, &outSystemTime); \
+    TIME_END_MACRO
+
+
+
+#endif /* __time_conversions_h */
+
diff -r 17e9560465b0 build/wince/shunt/w2a.cpp
--- a/build/wince/shunt/w2a.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,155 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code, released
- * Jan 28, 2003.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 2003
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Garrett Arch Blythe, 28-January-2003
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#include "mozce_internal.h"
-
-int w2a_buffer( unsigned short* inWideString, int inWideChars, char* outACPString, int inACPChars)
-{
-    int retval = 0;
-
-    /*
-    **  Start off by terminating the out argument if appropriate.
-    */
-    if(NULL != outACPString && 0 != inACPChars)
-    {
-        *outACPString = '\0';
-    }
-
-    /*
-    **  Sanity check arguments.
-    */
-    if(NULL != inWideString && 0 != inWideChars && (0 == inACPChars || NULL != outACPString))
-    {
-        /*
-        **  Attempt the conversion.
-        */
-        retval = WideCharToMultiByte(
-                                     CP_ACP,
-                                     0,
-                                     inWideString,
-                                     inWideChars,
-                                     outACPString,
-                                     inACPChars,
-                                     NULL,
-                                     NULL
-                                     );
-    }
-
-    return retval;
-}
-
-
-char* w2a_malloc(unsigned short* inWideString, int inWideChars, int* outACPChars)
-{
-    LPSTR retval = NULL;
-
-    /*
-    **  Initialize any out arguments.
-    */
-    if(NULL != outACPChars)
-    {
-        *outACPChars = 0;
-    }
-
-    /*
-    **  Initialize the wide char length if requested.
-    **  We do this here to avoid doing it twice in calls to w2a_buffer.
-    */
-    if(-1 == inWideChars)
-    {
-        if(NULL != inWideString)
-        {
-            /*
-            **  Plus one so the terminating character is included.
-            */
-            inWideChars = (int)wcslen(inWideString) + 1;
-        }
-        else
-        {
-            inWideChars = 0;
-        }
-    }
-
-    /*
-    **  Sanity check arguments.
-    */
-    if(NULL != inWideString && 0 != inWideChars)
-    {
-        int charsRequired = 0;
-
-        /*
-        **  Determine the size of buffer required for the conversion.
-        */
-        charsRequired = w2a_buffer(inWideString, inWideChars, NULL, 0);
-        if(0 != charsRequired)
-        {
-            LPSTR heapBuffer = NULL;
-
-            heapBuffer = (LPSTR)malloc((size_t)charsRequired * sizeof(CHAR));
-            if(NULL != heapBuffer)
-            {
-                int acpChars = 0;
-
-                /*
-                **  Real thing this time.
-                */
-                acpChars = w2a_buffer(inWideString, inWideChars, heapBuffer, charsRequired);
-                if(0 != acpChars)
-                {
-                    retval = heapBuffer;
-                    if(NULL != outACPChars)
-                    {
-                        *outACPChars = acpChars;
-                    }
-                }
-                else
-                {
-                    /*
-                    **  Something wrong.
-                    **  Clean up.
-                    */
-                    free(heapBuffer);
-                }
-            }
-        }
-    }
-
-    return retval;
-}
diff -r 17e9560465b0 build/wince/shunt/win32.cpp
--- a/build/wince/shunt/win32.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,1224 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code, released
- * Jan 28, 20.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 2003
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Garrett Arch Bly the, 28-January-2003
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#include "mozce_internal.h"
-#include <mstask.h>
-#include "map.h"
-
-extern "C" {
-#if 0
-}
-#endif
-
-#include "kfuncs.h"
-#include "wingdi.h"
-#include "Windows.h"
-#include "locale.h"
-#include <winbase.h>
-
-#define MOZCE_NOT_IMPLEMENTED(fname) \
-  SetLastError(0); \
-  mozce_printf("-- %s called\n", fname); \
-  SetLastError(ERROR_CALL_NOT_IMPLEMENTED); \
-  return 0;
-
-#define MOZCE_NOT_IMPLEMENTED_RV(fname, rv) \
-  SetLastError(0); \
-  mozce_printf("-- %s called\n", fname); \
-  SetLastError(ERROR_CALL_NOT_IMPLEMENTED); \
-  return rv;
-
-#define wcharcount(array) (sizeof(array) / sizeof(TCHAR))
-
-
-
-static int memory_checkpoint_count = 0;
-
-MOZCE_SHUNT_API void mozce_MemoryCheckpoint()
-{
-#ifdef API_LOGGING
-#ifdef WINCE_MEMORY_CHECKPOINTING
-    MEMORYSTATUS memInfo;
-    STORE_INFORMATION si;
-
-    // Program memory.
-    memInfo.dwLength = sizeof(memInfo);
-    GlobalMemoryStatus(&memInfo);
-    GetStoreInformation(&si);
-    // OUTPUT: MEM_CHECKPOINT_STRING, counter, Storage Memory Free, RAM TOTAL, RAM FREE, RAM USED
-    // Can then grep for "MEM, ", put all those lines into one file,
-    // save the file, and use the resulting text file as 
-    // comma-delimited-text-file input into excel.
-    //   -- wolfe@lobo.us
-    if (memory_checkpoint_count == 0)
-        mozce_printf("MEM, counter, Storage Memory Free, RAM TOTAL, RAM FREE, RAM USED\n");
-
-    mozce_printf("MEM, %d, %d, %d, %d, %d\n", memory_checkpoint_count, si.dwFreeSize, memInfo.dwTotalPhys, memInfo.dwAvailPhys, memInfo.dwTotalPhys - memInfo.dwAvailPhys);
-    memory_checkpoint_count++;
-#endif
-#endif
-}
-
-/*this is defined in the WM6 header commdlg.h, but the sdk is missing commdlg.lib*/
-
-MOZCE_SHUNT_API DWORD CommDlgExtendedError()
-{
-    WINCE_LOG_API_CALL("CommDlgExtendedError called\n");
-    
-    return -1 /*CDERR_DIALOGFAILURE*/;
-}
-
-
-MOZCE_SHUNT_API HBITMAP CreateDIBitmap(HDC inDC, CONST BITMAPINFOHEADER *inBMIH, DWORD inInit, CONST VOID *inBInit, CONST BITMAPINFO *inBMI, UINT inUsage)
-{
-    MOZCE_NOT_IMPLEMENTED(__FUNCTION__);
-}
-
-
-MOZCE_SHUNT_API int SetPolyFillMode(HDC inDC, int inPolyFillMode)
-{
-    MOZCE_NOT_IMPLEMENTED(__FUNCTION__);
-}
-
-MOZCE_SHUNT_API int SetArcDirection(HDC inDC, int inArcDirection)
-{
-    MOZCE_NOT_IMPLEMENTED(__FUNCTION__);
-}
-
-MOZCE_SHUNT_API BOOL Arc(HDC inDC, int inLeftRect, int inTopRect, int inRightRect, int inBottomRect, int inXStartArc, int inYStartArc, int inXEndArc, int inYEndArc)
-{
-    MOZCE_NOT_IMPLEMENTED(__FUNCTION__);
-}
-
-
-MOZCE_SHUNT_API BOOL Pie(HDC inDC, int inLeftRect, int inTopRect, int inRightRect, int inBottomRect, int inXRadial1, int inYRadial1, int inXRadial2, int inYRadial2)
-{
-    MOZCE_NOT_IMPLEMENTED(__FUNCTION__);
-}
-
-
-MOZCE_SHUNT_API BOOL LPtoDP(HDC inDC, LPPOINT inoutPoints, int inCount)
-{
-    MOZCE_NOT_IMPLEMENTED(__FUNCTION__);
-}
-
-MOZCE_SHUNT_API BOOL LineDDA(int inXStart, int inYStart, int inXEnd, int inYEnd, LINEDDAPROC inLineFunc, LPARAM inData)
-{
-    MOZCE_NOT_IMPLEMENTED(__FUNCTION__);
-}
-
-MOZCE_SHUNT_API int ExtSelectClipRgn(HDC inDC, HRGN inRGN, int inMode)
-{
-    WINCE_LOG_API_CALL("ExtSelectClipRgn called\n");
-
-    // inModes are defined as:
-    // RGN_AND = 1
-    // RGN_OR = 2
-    // RGN_XOR = 3
-    // RGN_DIFF = 4
-    // RGN_COPY = 5
-
-
-    if (inMode == RGN_COPY)
-    {
-        return SelectClipRgn(inDC, inRGN);
-    }
-
-    HRGN cRGN = NULL;
-    int result = GetClipRgn(inDC, cRGN);
-
-    // if there is no current clipping region, set it to the
-    // tightest bounding rectangle that can be drawn around
-    // the current visible area on the device
-
-    if (result != 1)
-    {
-        RECT cRect;
-        GetClipBox(inDC,&cRect);
-        cRGN = CreateRectRgn(cRect.left,cRect.top,cRect.right,cRect.bottom);
-    }
-
-    // now select the proper region as the current clipping region
-    result = SelectClipRgn(inDC,cRGN);
-
-    if (result == NULLREGION)
-    {
-        if (inMode == RGN_DIFF || inMode == RGN_AND)
-            result = SelectClipRgn(inDC,NULL);
-        else
-            result = SelectClipRgn(inDC,inRGN);
-
-        DeleteObject(cRGN);
-        return result;
-    }
-
-    if (result == SIMPLEREGION || result == COMPLEXREGION)
-    {
-        if (inMode == RGN_DIFF)
-            CombineRgn(cRGN, cRGN, inRGN, inMode);
-        else
-            CombineRgn(cRGN, inRGN, cRGN, inMode);
-        result = SelectClipRgn(inDC,cRGN);
-        DeleteObject(cRGN);
-        return result;
-    }
-
-    HRGN rgn = CreateRectRgn(0, 0, 32000, 32000);
-    result = SelectClipRgn(inDC, rgn);
-    DeleteObject(rgn);
-
-    return result;
-}
-
-
-MOZCE_SHUNT_API int FrameRect(HDC inDC, CONST RECT *inRect, HBRUSH inBrush)
-{
-    WINCE_LOG_API_CALL("FrameRect called\n");
-
-    HBRUSH oldBrush = (HBRUSH)SelectObject(inDC, inBrush);
-    RECT myRect = *inRect;
-    InflateRect(&myRect, 1, 1); // The width and height of
-                                // the border are always one
-                                // logical unit.
-
-    // 1  ---->   2
-    //
-    //            |
-    //            v
-    //
-    // 4  ---->   3
-
-    MoveToEx(inDC, myRect.left, myRect.top, (LPPOINT) NULL);
-
-    // 1 -> 2
-    LineTo(inDC, myRect.right, myRect.top);
-
-    // 2 -> 3
-    LineTo(inDC, myRect.right, myRect.bottom);
-
-    // 3 -> 4
-    LineTo(inDC, myRect.left, myRect.bottom);
-
-    SelectObject(inDC, oldBrush);
-
-    return 1;
-}
-
-
-
-MOZCE_SHUNT_API UINT GetTextCharset(HDC inDC)
-{
-    WINCE_LOG_API_CALL("GetTextCharset called\n");
-
-    UINT retval = DEFAULT_CHARSET;
-
-    TEXTMETRIC tm;
-    if(GetTextMetrics(inDC, &tm))
-    {
-        retval = tm.tmCharSet;
-    }
-
-    return retval;
-}
-
-
-MOZCE_SHUNT_API UINT GetTextCharsetInfo(HDC inDC, LPFONTSIGNATURE outSig, DWORD inFlags)
-{
-    WINCE_LOG_API_CALL("GetTextCharsetInfo called\n");
-
-    // Zero out the FONTSIGNATURE as we do not know how to fill it out properly.
-    if(NULL != outSig)
-    {
-        memset(outSig, 0, sizeof(FONTSIGNATURE));
-    }
-
-    return GetTextCharset(inDC);
-}
-
-#define FACENAME_MAX 128
-typedef struct __struct_CollectFaces
-{
-    UINT    mCount;
-    LPTSTR  mNames[FACENAME_MAX];
-}
-CollectFaces;
-
-static int CALLBACK collectProc(CONST LOGFONT* inLF, CONST TEXTMETRIC* inTM, DWORD inFontType, LPARAM inParam)
-{
-    int retval = 0;
-    CollectFaces* collection = (CollectFaces*)inParam;
-
-    if(FACENAME_MAX > collection->mCount)
-    {
-        retval = 1;
-
-        collection->mNames[collection->mCount] = _tcsdup(inLF->lfFaceName);
-        if(NULL != collection->mNames[collection->mCount])
-        {
-            collection->mCount++;
-        }
-    }
-
-    return retval;
-}
-
-MOZCE_SHUNT_API int GetMapMode(HDC inDC)
-{
-    WINCE_LOG_API_CALL("GetMapMode called\n");
-
-    int retval = MM_TEXT;
-    return retval;
-}
-
-
-
-MOZCE_SHUNT_API LONG RegCreateKey(HKEY inKey, LPCTSTR inSubKey, PHKEY outResult)
-{
-    WINCE_LOG_API_CALL("RegCreateKey called\n");
-
-    LONG retval = ERROR_SUCCESS;
-    DWORD disp = 0;
-
-    retval = RegCreateKeyEx(inKey, inSubKey, 0, NULL, 0, 0, NULL, outResult, &disp);
-
-    return retval;
-}
-
-
-MOZCE_SHUNT_API BOOL WaitMessage(VOID)
-{
-    WINCE_LOG_API_CALL("WaitMessage called\n");
-
-    BOOL retval = TRUE;
-
-    HANDLE hThread = GetCurrentThread();
-    DWORD waitRes = MsgWaitForMultipleObjectsEx(1, &hThread, INFINITE, QS_ALLEVENTS, 0);
-    if((DWORD)-1 == waitRes)
-    {
-        retval = FALSE;
-    }
-
-    return retval;
-}
-
-
-MOZCE_SHUNT_API BOOL FlashWindow(HWND inWnd, BOOL inInvert)
-{
-   MOZCE_NOT_IMPLEMENTED_RV(__FUNCTION__, FALSE);
-}
-
-
-typedef struct ECWWindows
-{
-    LPARAM      params;
-    WNDENUMPROC func;
-    HWND        parent;
-} ECWWindows;
-
-static BOOL CALLBACK MyEnumWindowsProc(HWND hwnd, LPARAM lParam)
-{
-    ECWWindows *myParams = (ECWWindows*) lParam;
-
-    if (IsChild(myParams->parent, hwnd))
-    {
-        return myParams->func(hwnd, myParams->params);
-    }
-
-    return TRUE;
-}
-
-MOZCE_SHUNT_API BOOL EnumChildWindows(HWND inParent, WNDENUMPROC inFunc, LPARAM inParam)
-{
-    WINCE_LOG_API_CALL("EnumChildWindows called\n");
-
-    ECWWindows myParams;
-    myParams.params = inParam;
-    myParams.func   = inFunc;
-    myParams.parent = inParent;
-
-    return EnumWindows(MyEnumWindowsProc, (LPARAM) &myParams);
-}
-
-
-MOZCE_SHUNT_API BOOL EnumThreadWindows(DWORD inThreadID, WNDENUMPROC inFunc, LPARAM inParam)
-{
-    MOZCE_NOT_IMPLEMENTED_RV(__FUNCTION__, FALSE);
-}
-
-
-MOZCE_SHUNT_API BOOL IsIconic(HWND inWnd)
-{
-    return false;
-}
-
-
-MOZCE_SHUNT_API BOOL OpenIcon(HWND inWnd)
-{
-    WINCE_LOG_API_CALL("OpenIcon called\n");
-    return SetActiveWindow(inWnd) ? 1:0;
-}
-
-
-MOZCE_SHUNT_API HHOOK SetWindowsHookEx(int inType, void* inFunc, HINSTANCE inMod, DWORD inThreadId)
-{
-   MOZCE_NOT_IMPLEMENTED_RV(__FUNCTION__, NULL);
-}
-
-
-MOZCE_SHUNT_API BOOL UnhookWindowsHookEx(HHOOK inHook)
-{
-   MOZCE_NOT_IMPLEMENTED_RV(__FUNCTION__, FALSE);
-}
-
-
-MOZCE_SHUNT_API LRESULT CallNextHookEx(HHOOK inHook, int inCode, WPARAM wParam, LPARAM lParam)
-{
-   MOZCE_NOT_IMPLEMENTED_RV(__FUNCTION__, NULL);
-
-}
-
-
-MOZCE_SHUNT_API BOOL InvertRgn(HDC inDC, HRGN inRGN)
-{
-   MOZCE_NOT_IMPLEMENTED_RV(__FUNCTION__, FALSE);
-
-}
-
-
-MOZCE_SHUNT_API int GetScrollPos(HWND inWnd, int inBar)
-{
-    WINCE_LOG_API_CALL("GetScrollPos called\n");
-
-    int retval = 0;
-    SCROLLINFO info;
-
-    if(GetScrollInfo(inWnd, inBar, &info))
-    {
-        return info.nPos;
-    }
-
-    return retval;
-}
-
-
-MOZCE_SHUNT_API BOOL GetScrollRange(HWND inWnd, int inBar, LPINT outMinPos, LPINT outMaxPos)
-{
-    WINCE_LOG_API_CALL("GetScrollRange called\n");
-
-    BOOL retval = FALSE;
-    SCROLLINFO info;
-
-    if((retval = GetScrollInfo(inWnd, inBar, &info)))
-    {
-        if(NULL != outMinPos)
-        {
-            *outMinPos = info.nMin;
-        }
-        if(NULL != outMaxPos)
-        {
-            *outMaxPos = info.nMax;
-        }
-    }
-
-    return retval;
-}
-
-
-MOZCE_SHUNT_API HRESULT CoLockObjectExternal(IUnknown* inUnk, BOOL inLock, BOOL inLastUnlockReleases)
-{
-    WINCE_LOG_API_CALL("CoLockObjectExternal called\n");
-
-    HRESULT retval = S_OK;
-
-    if(NULL != inUnk)
-    {
-        if(FALSE == inLock)
-        {
-            inUnk->Release();
-        }
-        else
-        {
-            inUnk->AddRef();
-        }
-    }
-    else
-    {
-        retval = E_INVALIDARG;
-    }
-
-    return retval;
-}
-
-//LPITEMIDLIST
-MOZCE_SHUNT_API void* mozce_SHBrowseForFolder(void* /*LPBROWSEINFOS*/ inBI)
-{
-   MOZCE_NOT_IMPLEMENTED_RV(__FUNCTION__, 0);
-}
-
-
-MOZCE_SHUNT_API BOOL SetMenu(HWND inWnd, HMENU inMenu)
-{
-   MOZCE_NOT_IMPLEMENTED_RV(__FUNCTION__, FALSE);
-
-}
-
-
-MOZCE_SHUNT_API BOOL GetUserName(LPTSTR inBuffer, LPDWORD inoutSize)
-{
-    *inoutSize = 0;
-    MOZCE_NOT_IMPLEMENTED_RV(__FUNCTION__, FALSE);
-}
-
-
-MOZCE_SHUNT_API DWORD GetShortPathName(LPCSTR inLongPath, LPSTR outShortPath, DWORD inBufferSize)
-{
-    MOZCE_NOT_IMPLEMENTED_RV(__FUNCTION__, 0);
-}
-
-MOZCE_SHUNT_API DWORD GetShortPathNameW(LPCWSTR inLongPath, LPWSTR outShortPath, DWORD inBufferSize)
-{
-    MOZCE_NOT_IMPLEMENTED_RV(__FUNCTION__, 0);
-}
-
-
-MOZCE_SHUNT_API DWORD GetEnvironmentVariableW(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize)
-{
-	char key[256];
-	int rv =WideCharToMultiByte( CP_ACP, 0, lpName, -1, key, 256, NULL, NULL );
-	if(rv<0){
-		return rv;
-	}
-	char* val = map_get(key);
-	if(val){
-		 MultiByteToWideChar( CP_ACP, 0, val, strlen(val)+1, lpBuffer,
-     nSize );
-		return ERROR_SUCCESS ;
-	}else{
-		return ERROR_ENVVAR_NOT_FOUND;
-	}
-}
-MOZCE_SHUNT_API DWORD GetEnvironmentVariable(LPCWSTR lpName, LPCSTR lpBuffer, DWORD nSize)
-{
-#ifdef UNICODE
-    return GetEnvironmentVariableW((LPCWSTR)lpName,(LPWSTR)lpBuffer,nSize);
-#else
-	return get(lpName,lpBuffer);
-#endif
-}
-
-MOZCE_SHUNT_API void GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime)
-{
-    WINCE_LOG_API_CALL("GetSystemTimeAsFileTime called\n");
-
-    SYSTEMTIME st;
-    GetSystemTime(&st);
-    SystemTimeToFileTime(&st,lpSystemTimeAsFileTime);
-}
-
-MOZCE_SHUNT_API DWORD GetLongPathNameW(LPCWSTR lpszShortPath, LPCWSTR lpszLongPath, DWORD cchBuffer)
-{
-    WINCE_LOG_API_CALL("GetLongPathNameW called\n");
-
-    return 0;
-}
-
-MOZCE_SHUNT_API DWORD GetFullPathName(const char* lpFileName,
-                                      DWORD nBufferLength,
-                                      const char* lpBuffer,
-                                      const char** lpFilePart)
-{
-    WINCE_LOG_API_CALL("GetFullPathName called\n");
-
-    DWORD len = strlen(lpFileName);
-    if (len > nBufferLength)
-        return len;
-
-    strncpy((char*)lpBuffer, lpFileName, len);
-    ((char*)lpBuffer)[len] = '\0';
-
-    if(lpFilePart)
-    {
-        char* sep = strrchr(lpBuffer, '\\');
-        if (sep) {
-            sep++; // pass the seperator
-            *lpFilePart = sep;
-        }
-        else
-            *lpFilePart = lpBuffer;
-    }
-
-    WINCE_LOG_API_CALL_2("GetFullPathName called %s (%s)\n", lpBuffer, *lpFilePart);
-    return len;
-}
-
-static LONG gGetMessageTime = 0;
-
-MOZCE_SHUNT_API BOOL mozce_GetMessage(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax )
-{
-    SetLastError(0);
-
-    WINCE_LOG_API_CALL("mozce_GetMessage called\n");
-
-    BOOL b = GetMessage(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMin);
-
-    if (b)
-        gGetMessageTime = lpMsg->time;
-
-    return b;
-}
-
-
-MOZCE_SHUNT_API BOOL mozce_PeekMessage(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg)
-{
-    SetLastError(0);
-
-    WINCE_LOG_API_CALL("mozce_PeekMessageA called\n");
-
-    BOOL b = PeekMessageW(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
-
-    if (b && wRemoveMsg == PM_REMOVE)
-        gGetMessageTime = lpMsg->time;
-
-    return b;
-}
-
-
-MOZCE_SHUNT_API LONG GetMessageTime(void)
-{
-    SetLastError(0);
-
-    WINCE_LOG_API_CALL("GetMessageTime called\n");
-
-  return gGetMessageTime;
-}
-
-MOZCE_SHUNT_API DWORD ExpandEnvironmentStrings(LPCTSTR lpSrc, LPTSTR lpDst, DWORD nSize)
-{
-    MOZCE_NOT_IMPLEMENTED_RV(__FUNCTION__, 0);
-}
-
-MOZCE_SHUNT_API DWORD ExpandEnvironmentStringsW(const unsigned short* lpSrc, const unsigned short* lpDst, DWORD nSize)
-{
-     MOZCE_NOT_IMPLEMENTED_RV(__FUNCTION__, 0);
-}
-
-MOZCE_SHUNT_API BOOL GdiFlush(void)
-{
-    return TRUE;
-}
-
-MOZCE_SHUNT_API BOOL GetWindowPlacement(HWND hWnd, WINDOWPLACEMENT *lpwndpl)
-{
-    SetLastError(0);
-
-    WINCE_LOG_API_CALL("GetWindowPlacement called\n");
-
-   memset(lpwndpl, 0, sizeof(WINDOWPLACEMENT));
-
-   // This is wrong when the window is minimized.
-   lpwndpl->showCmd = SW_SHOWNORMAL;
-   GetWindowRect(hWnd, &lpwndpl->rcNormalPosition);
-
-   return TRUE;
-}
-
-MOZCE_SHUNT_API HINSTANCE ShellExecute(HWND hwnd,
-                                             LPCSTR lpOperation,
-                                             LPCSTR lpFile,
-                                             LPCSTR lpParameters,
-                                             LPCSTR lpDirectory,
-                                             INT nShowCmd)
-{
-
-    LPTSTR op   = a2w_malloc(lpOperation, -1, NULL);
-    LPTSTR file = a2w_malloc(lpFile, -1, NULL);
-    LPTSTR parm = a2w_malloc(lpParameters, -1, NULL);
-    LPTSTR dir  = a2w_malloc(lpDirectory, -1, NULL);
-
-    SHELLEXECUTEINFO info;
-    info.cbSize = sizeof(SHELLEXECUTEINFO);
-    info.fMask  = SEE_MASK_NOCLOSEPROCESS;
-    info.hwnd   = hwnd;
-    info.lpVerb = op;
-    info.lpFile = file;
-    info.lpParameters = parm;
-    info.lpDirectory  = dir;
-    info.nShow  = nShowCmd;
-
-    BOOL b = ShellExecuteEx(&info);
-
-    if (op)
-        free(op);
-    if (file)
-        free(file);
-    if (parm)
-        free(parm);
-    if (dir)
-        free(dir);
-
-    return (HINSTANCE) info.hProcess;
-}
-
-MOZCE_SHUNT_API HINSTANCE ShellExecuteW(HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd)
-{
-    SetLastError(0);
-
-    WINCE_LOG_API_CALL("ShellExecuteW called\n");
-
-    SHELLEXECUTEINFO info;
-    info.cbSize = sizeof(SHELLEXECUTEINFO);
-    info.fMask  = SEE_MASK_NOCLOSEPROCESS;
-    info.hwnd   = hwnd;
-    info.lpVerb = lpOperation;
-    info.lpFile = lpFile;
-    info.lpParameters = lpParameters;
-    info.lpDirectory  = lpDirectory;
-    info.nShow  = nShowCmd;
-
-    BOOL b = ShellExecuteEx(&info);
-
-    return (HINSTANCE) info.hProcess;
-}
-
-struct lconv s_locale_conv =
-{
-    ".",   /* decimal_point */
-    ",",   /* thousands_sep */
-    "333", /* grouping */
-    "$",   /* int_curr_symbol */
-    "$",   /* currency_symbol */
-    "",    /* mon_decimal_point */
-    "",    /* mon_thousands_sep */
-    "",    /* mon_grouping */
-    "+",   /* positive_sign */
-    "-",   /* negative_sign */
-    '2',   /* int_frac_digits */
-    '2',   /* frac_digits */
-    1,     /* p_cs_precedes */
-    1,     /* p_sep_by_space */
-    1,     /* n_cs_precedes */
-    1,     /* n_sep_by_space */
-    1,     /* p_sign_posn */
-    1,     /* n_sign_posn */
-};
-
-MOZCE_SHUNT_API struct lconv * mozce_localeconv(void)
-{
-    WINCE_LOG_API_CALL("mozce_localeconv called\n");
-    return &s_locale_conv;
-}
-
-MOZCE_SHUNT_API BOOL CreatePipe(PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize)
-{
-    MOZCE_NOT_IMPLEMENTED_RV(__FUNCTION__, FALSE);
-}
-MOZCE_SHUNT_API DWORD_PTR SetThreadAffinityMask(HANDLE hThread, DWORD_PTR dwThreadAffinityMask)
-{
-    MOZCE_NOT_IMPLEMENTED_RV(__FUNCTION__, 0);
-}
-MOZCE_SHUNT_API BOOL GetProcessAffinityMask(HANDLE hProcess, PDWORD_PTR lpProcessAffinityMask, PDWORD_PTR lpSystemAffinityMask)
-{
-    MOZCE_NOT_IMPLEMENTED_RV(__FUNCTION__, FALSE);
-}
-
-MOZCE_SHUNT_API HANDLE OpenFileMapping(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCTSTR lpName)
-{
-    MOZCE_NOT_IMPLEMENTED_RV(__FUNCTION__, 0);
-}
-
-MOZCE_SHUNT_API UINT GetDriveType(const char* lpRootPathName)
-{
-    MOZCE_NOT_IMPLEMENTED_RV(__FUNCTION__, 0);
-}
-
-MOZCE_SHUNT_API BOOL SetHandleInformation(HANDLE hObject, DWORD dwMask, DWORD dwFlags)
-{
-    MOZCE_NOT_IMPLEMENTED_RV(__FUNCTION__, 0);
-}
-
-MOZCE_SHUNT_API BOOL GetHandleInformation(HANDLE hObject, LPDWORD lpdwFlags)
-{
-    MOZCE_NOT_IMPLEMENTED_RV(__FUNCTION__, 0);
-}
-
-MOZCE_SHUNT_API BOOL LockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh,
-                                    DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh)
-{
-  OVERLAPPED over = {0};
-  over.Offset = dwFileOffsetLow;
-  over.OffsetHigh = dwFileOffsetHigh;
-  return ::LockFileEx(hFile, 0, 0, nNumberOfBytesToLockLow, nNumberOfBytesToLockHigh, &over);
-}
-
-MOZCE_SHUNT_API BOOL UnlockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh,
-                                    DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh)
-{
-  OVERLAPPED over = {0};
-  over.Offset = dwFileOffsetLow;
-  over.OffsetHigh = dwFileOffsetHigh;
-  return ::UnlockFileEx(hFile, 0, nNumberOfBytesToLockLow, nNumberOfBytesToLockHigh, &over);
-
-}
-
-MOZCE_SHUNT_API BOOL GetDiskFreeSpaceA(LPCTSTR lpRootPathName, LPDWORD lpSectorsPerCluster,
-                                            LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters)
-{
-    MOZCE_NOT_IMPLEMENTED_RV(__FUNCTION__, 0);
-}
-
-
-MOZCE_SHUNT_API BOOL SetWorldTransform(HDC hdc, CONST XFORM *lpXform )
-{
-    return 1;
-}
-
-MOZCE_SHUNT_API BOOL GetWorldTransform(HDC hdc, LPXFORM lpXform )
-{
- MOZCE_NOT_IMPLEMENTED(__FUNCTION__);
-}
-
-MOZCE_SHUNT_API int  SetGraphicsMode(HDC hdc, int iMode)
-{
-    return 1;
-}
-
-MOZCE_SHUNT_API int GetGraphicsMode(HDC hdc)
-{
-    return 1; /*GM_COMPATIBLE*/
-}
-
-MOZCE_SHUNT_API HRESULT ScriptFreeCache(SCRIPT_CACHE* psc )
-{
-  MOZCE_NOT_IMPLEMENTED(__FUNCTION__);
-}
-MOZCE_SHUNT_API DWORD WINAPI GetGlyphIndicesA( HDC hdc,LPCSTR lpstr, int c, LPWORD pgi, DWORD fl)
-{
-  memcpy(pgi,lpstr,c);
-  return c;
-
-}
-MOZCE_SHUNT_API DWORD WINAPI GetGlyphIndicesW( HDC hdc, LPCWSTR lpstr, int c,  LPWORD pgi, DWORD fl)
-{
-    for (int i = 0; i < c; i++)
-    {
-        char asciiChar = (char) lpstr[i];
-        pgi[i] = asciiChar;
-    }
-    return c;
-}
-
-MOZCE_SHUNT_API DWORD GetFontUnicodeRanges(HDC hdc, GLYPHSET *lpgs)
-{
-    MOZCE_NOT_IMPLEMENTED_RV(__FUNCTION__, ERROR_CALL_NOT_IMPLEMENTED);
-}
-
-MOZCE_SHUNT_API HRESULT WINAPI ScriptIsComplex(const WCHAR *pwcInChars, int cInChars, DWORD   dwFlags)
-{
-    MOZCE_NOT_IMPLEMENTED_RV(__FUNCTION__, ERROR_CALL_NOT_IMPLEMENTED);
-}
-MOZCE_SHUNT_API BOOL GetTextExtentExPointI( HDC hdc, LPWORD pgiIn, int cgi,int nMaxExtent, LPINT lpnFit, LPINT alpDx, LPSIZE lpSize)
-{
-	return GetTextExtentExPoint(hdc, pgiIn, cgi, nMaxExtent, lpnFit, alpDx, lpSize);
-}
-MOZCE_SHUNT_API HRESULT WINAPI ScriptGetProperties( const SCRIPT_PROPERTIES ***ppSp, int *piNumScripts)
-{
-  MOZCE_NOT_IMPLEMENTED(__FUNCTION__);
-}
-MOZCE_SHUNT_API HRESULT WINAPI ScriptGetFontProperties(HDC hdc, SCRIPT_CACHE *psc, SCRIPT_FONTPROPERTIES *sfp )
-{
-  MOZCE_NOT_IMPLEMENTED(__FUNCTION__);
-}
-MOZCE_SHUNT_API HRESULT WINAPI ScriptBreak(  const WCHAR *pwcChars, int cChars, const SCRIPT_ANALYSIS *psa, SCRIPT_LOGATTR *psla )
-{
-  MOZCE_NOT_IMPLEMENTED(__FUNCTION__);
-}
-
-MOZCE_SHUNT_API HRESULT WINAPI ScriptItemize(const WCHAR *pwcInChars, int cInChars, int cMaxItems, const SCRIPT_CONTROL *psControl,
-                                             const SCRIPT_STATE *psState,  SCRIPT_ITEM *pItems, int *pcItems )
-{
-  MOZCE_NOT_IMPLEMENTED(__FUNCTION__);
-}
-
-MOZCE_SHUNT_API BOOL WINAPI GetICMProfile(HDC hDC, LPDWORD lpcbName,LPWSTR lpszFilename)
-{
-  MOZCE_NOT_IMPLEMENTED(__FUNCTION__);
-}
-MOZCE_SHUNT_API DWORD WINAPI GetGuiResources(HANDLE hProcess,DWORD uiFlags)
-{
-  return 1;
-}
-MOZCE_SHUNT_API BOOL UpdateLayeredWindow(HWND hWnd, HDC hdcDst, POINT *pptDst,
-                                         SIZE *psize, HDC hdcSrc, POINT *pptSrc,
-                                         COLORREF crKey, BLENDFUNCTION *pblend,
-                                         DWORD dwFlags)
-{
-    MOZCE_NOT_IMPLEMENTED(__FUNCTION__);
-}
-
-MOZCE_SHUNT_API HRESULT WINAPI ScriptRecordDigitSubstitution(LCID Locale, SCRIPT_DIGITSUBSTITUTE  *psds)
-{
-
-  psds->DigitSubstitute =1;
-  psds->dwReserved =0;
-  psds->NationalDigitLanguage =9;
-  psds->TraditionalDigitLanguage =9;
-  return S_OK;
-}
-MOZCE_SHUNT_API HWND WINAPI GetTopWindow(HWND hWnd)
-{
-  MOZCE_NOT_IMPLEMENTED(__FUNCTION__);
-}
-
-MOZCE_SHUNT_API BOOL
-WINAPI
-InitializeCriticalSectionAndSpinCount(
-    __out LPCRITICAL_SECTION InitializeCriticalSection,
-    __in  DWORD dwSpinCount
-    )
-{
-    ::InitializeCriticalSection(InitializeCriticalSection);
-    return TRUE;
-}
-
-MOZCE_SHUNT_API
-DWORD
-WINAPI
-SetCriticalSectionSpinCount(
-    __inout LPCRITICAL_SECTION lpCriticalSection,
-    __in    DWORD dwSpinCount
-    )
-{
-    return 0;
-}
-MOZCE_SHUNT_API
-BOOL
-WINAPI
-GetSystemTimeAdjustment(
-    __out PDWORD lpTimeAdjustment,
-    __out PDWORD lpTimeIncrement,
-    __out PBOOL  lpTimeAdjustmentDisabled
-    )
-{
-    *lpTimeAdjustmentDisabled = TRUE;
-    return TRUE;
-}
-
-MOZCE_SHUNT_API BOOL  WINAPI PolyBezierTo(__in HDC hdc, __in_ecount(cpt) CONST POINT * apt, __in DWORD cpt){
- MOZCE_NOT_IMPLEMENTED(__FUNCTION__); }
-
-MOZCE_SHUNT_API BOOL WINAPI CloseFigure(__in HDC hdc){
- MOZCE_NOT_IMPLEMENTED(__FUNCTION__);
-}
-
-MOZCE_SHUNT_API BOOL WINAPI SelectClipPath(__in HDC hdc, __in int mode){
- MOZCE_NOT_IMPLEMENTED(__FUNCTION__);
-}
-
-MOZCE_SHUNT_API BOOL WINAPI EndPath(__in HDC hdc){
- MOZCE_NOT_IMPLEMENTED(__FUNCTION__);
-}
-
-MOZCE_SHUNT_API BOOL WINAPI BeginPath(__in HDC hdc){
- MOZCE_NOT_IMPLEMENTED(__FUNCTION__);
-}
-
-MOZCE_SHUNT_API BOOL WINAPI ModifyWorldTransform( __in HDC hdc, __in_opt CONST XFORM * lpxf, __in DWORD mode){
- MOZCE_NOT_IMPLEMENTED(__FUNCTION__);
-}
-
-MOZCE_SHUNT_API BOOL WINAPI WidenPath(__in HDC hdc){
- MOZCE_NOT_IMPLEMENTED(__FUNCTION__);
-}
-
-MOZCE_SHUNT_API BOOL WINAPI StrokePath(__in HDC hdc){
- MOZCE_NOT_IMPLEMENTED(__FUNCTION__);
-}
-
-MOZCE_SHUNT_API HPEN WINAPI ExtCreatePen( __in DWORD iPenStyle,
-                                    __in DWORD cWidth,
-                                    __in CONST LOGBRUSH *plbrush,
-                                    __in DWORD cStyle,
-                                    __in_ecount_opt(cStyle) CONST DWORD *pstyle){
- MOZCE_NOT_IMPLEMENTED(__FUNCTION__);
-}
-
-MOZCE_SHUNT_API BOOL WINAPI SetMiterLimit(__in HDC hdc, __in FLOAT limit, __out_opt PFLOAT old){
- MOZCE_NOT_IMPLEMENTED(__FUNCTION__);
-}
-
-MOZCE_SHUNT_API BOOL WINAPI FillPath(__in HDC hdc){
- MOZCE_NOT_IMPLEMENTED(__FUNCTION__);
-}
-
-MOZCE_SHUNT_API BOOL	      WINAPI GetICMProfileW(    __in HDC hdc,
-                                                __inout LPDWORD pBufSize,
-                                                __out_ecount_opt(*pBufSize) LPWSTR pszFilename)
-{
- MOZCE_NOT_IMPLEMENTED(__FUNCTION__);
-}
-
-HRESULT WINAPI ScriptShape(
-    HDC                 hdc,            // In    Optional (see under caching)
-    SCRIPT_CACHE       *psc,            // InOut Cache handle
-    const WCHAR        *pwcChars,       // In    Logical unicode run
-    int                 cChars,         // In    Length of unicode run
-    int                 cMaxGlyphs,     // In    Max glyphs to generate
-    SCRIPT_ANALYSIS    *psa,            // InOut Result of ScriptItemize (may have fNoGlyphIndex set)
-    WORD               *pwOutGlyphs,    // Out   Output glyph buffer
-    WORD               *pwLogClust,     // Out   Logical clusters
-    SCRIPT_VISATTR     *psva,           // Out   Visual glyph attributes
-    int                *pcGlyphs){
- MOZCE_NOT_IMPLEMENTED(__FUNCTION__);
-}
-      // Out   Count of glyphs generated
-
-HRESULT WINAPI ScriptPlace(
-    HDC                     hdc,        // In    Optional (see under caching)
-    SCRIPT_CACHE           *psc,        // InOut Cache handle
-    const WORD             *pwGlyphs,   // In    Glyph buffer from prior ScriptShape call
-    int                     cGlyphs,    // In    Number of glyphs
-    const SCRIPT_VISATTR   *psva,       // In    Visual glyph attributes
-    SCRIPT_ANALYSIS        *psa,        // InOut Result of ScriptItemize (may have fNoGlyphIndex set)
-    int                    *piAdvance,  // Out   Advance wdiths
-    GOFFSET                *pGoffset,   // Out   x,y offset for combining glyph
-    ABC                    *pABC){
- MOZCE_NOT_IMPLEMENTED(__FUNCTION__);
-}
-      // Out   Composite ABC for the whole run (Optional)
-
-MOZCE_SHUNT_API int WINAPI SetMapMode(HDC, int)
-{
-    // We only support one Map Mode.
-    return 1;
-}
-
-MOZCE_SHUNT_API DWORD WINAPI GetCharacterPlacementW(  __in HDC hdc, __in_ecount(nCount) LPCWSTR lpString, __in int nCount, __in int nMexExtent, __inout LPGCP_RESULTSW lpResults, __in DWORD dwFlags)
-{
-    MOZCE_NOT_IMPLEMENTED(__FUNCTION__);
-}
-
-MOZCE_SHUNT_API wchar_t* wgetcwd(wchar_t* dir, size_t size)
-{
-    WINCE_LOG_API_CALL("getcwd called.\n");
-    int i;
-
-    GetModuleFileName(GetModuleHandle (NULL), dir, MAX_PATH);
-    for (i = _tcslen(dir); i && dir[i] != TEXT('\\'); i--) {}
-    dir[i + 1] = TCHAR('\0');
-
-    return dir;
-}
-
-MOZCE_SHUNT_API wchar_t *_wgetcwd(wchar_t *buffer, int maxlen)
-{
-	return wgetcwd(buffer,  maxlen);
-}
-
-MOZCE_SHUNT_API int  _wrmdir(const wchar_t * _Path)
-{
-    return ::RemoveDirectoryW(_Path);
-}
-
-MOZCE_SHUNT_API int _wremove(const wchar_t * _Filename)
-{
-    return ::DeleteFileW(_Filename);
-}
-
-MOZCE_SHUNT_API int wchmod(const wchar_t * buffer, int inMode)
-{
-    WINCE_LOG_API_CALL("wchmod called\n");
-
-    int retval = -1;
-
-    if(NULL != buffer)
-    {
-
-            DWORD attribs = 0;
-
-            attribs = GetFileAttributesW(buffer);
-            if(0 != attribs)
-            {
-                if(0 != (_S_IWRITE & inMode))
-                {
-                    attribs |= FILE_ATTRIBUTE_READONLY;
-                }
-                else
-                {
-                    attribs &= ~FILE_ATTRIBUTE_READONLY;
-                }
-
-                BOOL setRes = SetFileAttributesW(buffer, attribs);
-                if(FALSE != setRes)
-                {
-                    retval = 0;
-                }
-            }
-
-    }
-
-    return retval;
-}
-
-MOZCE_SHUNT_API int _wchmod(const wchar_t * _Filename, int _Mode)
-{
-    return wchmod(_Filename,  _Mode);
-}
-
-MOZCE_SHUNT_API wchar_t *_wfullpath( wchar_t *absPath, const wchar_t *relPath, size_t maxLength )
-{
-    if(absPath ==NULL){
-        absPath = (wchar_t*)malloc(maxLength*sizeof(wchar_t));
-    }
-    wgetcwd( absPath, maxLength);
-    size_t  len = wcslen(absPath);
-    if(!(absPath[len-1] == TCHAR('/') || absPath[len-1] == TCHAR('\\'))&& len< maxLength){
-        absPath[len] = TCHAR('\\');
-        absPath[++len] = TCHAR('\0');
-    }
-    if(len+wcslen(relPath) < maxLength){
-        return wcscat(absPath,relPath);
-    }
-    return NULL;
-}
-
-
-// Copied from msaa.h
-MOZCE_SHUNT_API HWND GetAncestor(HWND hwnd, UINT gaFlags)
-{
-    HWND	hwndParent;
-    HWND	hwndDesktop;
-    DWORD   dwStyle;
-
-     // HERE IS THE FAKE IMPLEMENTATION
-    if (!IsWindow(hwnd))
-        return(NULL);
-
-    hwndDesktop = GetDesktopWindow();
-    if (hwnd == hwndDesktop)
-        return(NULL);
-    dwStyle = GetWindowLong (hwnd,GWL_STYLE);
-
-    switch (gaFlags)
-    {
-        case GA_PARENT:
-            if (dwStyle & WS_CHILD)
-                hwndParent = GetParent(hwnd);
-            else
-                hwndParent = GetWindow (hwnd,GW_OWNER);
-
-            if (hwndParent == NULL)
-                hwndParent = hwnd;
-            break;
-
-        case GA_ROOT:
-            if (dwStyle & WS_CHILD)
-                hwndParent = GetParent(hwnd);
-            else
-                hwndParent = GetWindow (hwnd,GW_OWNER);
-
-            while (hwndParent != hwndDesktop &&
-                   hwndParent != NULL)
-            {
-                hwnd = hwndParent;
-                dwStyle = GetWindowLong(hwnd,GWL_STYLE);
-                if (dwStyle & WS_CHILD)
-                    hwndParent = GetParent(hwnd);
-                else
-                    hwndParent = GetWindow (hwnd,GW_OWNER);
-            }
-            break;
-
-        case GA_ROOTOWNER:
-            while (hwndParent = GetParent(hwnd))
-                hwnd = hwndParent;
-            break;
-        default:
-            return NULL;
-    }
-
-    return(hwndParent);
-}
-
-MOZCE_SHUNT_API BOOL InitializeAcl(PACL apAcl, DWORD len, DWORD rev)
-{
-    return FALSE;
-}
-
-MOZCE_SHUNT_API DWORD SetNamedSecurityInfoW(unsigned short* pObjectName,
-                                            SE_OBJECT_TYPE ObjectType,
-                                            SECURITY_INFORMATION SecurityInfo,
-                                            PSID psidOwner,
-                                            PSID psidGroup,
-                                            PACL pDacl,
-                                            PACL pSacl)
-{
-    return 0;
-}
-
-
-MOZCE_SHUNT_API void FatalAppExitW(UINT uAction, LPCWSTR lpMessageText)
-{
-  if ( ::MessageBoxW(NULL, lpMessageText, L"Runtime Error", MB_OKCANCEL | MB_ICONERROR) == IDCANCEL )
-    return;
-
-  exit(-1);
-}
-
-MOZCE_SHUNT_API int clock() 
-{
-    return -1;
-}
-
-MOZCE_SHUNT_API int GetDIBits(HDC hdc, HBITMAP hbmp, UINT uStartScan, UINT cScanLines, 
-                              LPVOID lpvBits, LPBITMAPINFO lpbi, UINT uUsage) 
-{
-  
-#if 0
-    return GetBitmapBits(hbmp,lpbi->bmiHeader.biSize, lpvBits); 
-#else
-    return 0;
-#endif                 
-                 
-}
-
-#if 0
-{
-#endif
-} /* extern "C" */
diff -r 17e9560465b0 build/wince/shunt/win32W.cpp
--- a/build/wince/shunt/win32W.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,182 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code, released
- * Jan 28, 2003.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 2003
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Garrett Arch Blythe, 28-January-2003
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#include "mozce_internal.h"
-#include "map.h"
-
-extern "C" {
-#if 0
-}
-#endif
-
-/*
-**  Help figure the character count of a TCHAR array.
-*/
-#define wcharcount(array) (sizeof(array) / sizeof(TCHAR))
-
-#define MOZCE_NOT_IMPLEMENTED_RV(fname, rv) \
-  SetLastError(0); \
-  mozce_printf("-- fname called\n"); \
-  SetLastError(ERROR_CALL_NOT_IMPLEMENTED); \
-  return rv;
-
-MOZCE_SHUNT_API UINT GetWindowsDirectoryW(LPWSTR inBuffer, UINT inSize)
-{
-    SetLastError(0);
-#ifdef API_LOGGING
-    mozce_printf("GetWindowsDirectoryW called\n");
-#endif
-
-    UINT retval = 0;
-
-    if(inSize < 9)
-    {
-        retval = 9;
-    }
-    else
-    {
-        wcscpy(inBuffer, L"\\WINDOWS");
-        retval = 8;
-    }
-
-    return retval;
-}
-
-
-MOZCE_SHUNT_API UINT GetSystemDirectoryW(LPWSTR inBuffer, UINT inSize)
-{
-    SetLastError(0);
-#ifdef API_LOGGING
-    mozce_printf("GetSystemDirectoryW called\n");
-#endif
-
-    UINT retval = 0;
-
-    if(inSize < 9)
-    {
-        retval = 9;
-    }
-    else
-    {
-        wcscpy(inBuffer, L"\\WINDOWS");
-        retval = 8;
-    }
-
-    return retval;
-}
-
-
-MOZCE_SHUNT_API HANDLE OpenSemaphoreW(DWORD inDesiredAccess, BOOL inInheritHandle, LPCWSTR inName)
-{
-#ifdef API_LOGGING
-    mozce_printf("OpenSemaphoreW called\n");
-#endif
-
-    HANDLE retval = NULL;
-    HANDLE semaphore = NULL;
-
-    semaphore = CreateSemaphoreW(NULL, 0, 0x7fffffff, inName);
-    if(NULL != semaphore)
-    {
-        DWORD lastErr = GetLastError();
-        
-        if(ERROR_ALREADY_EXISTS != lastErr)
-        {
-            CloseHandle(semaphore);
-        }
-        else
-        {
-            retval = semaphore;
-        }
-    }
-
-    return retval;
-}
-
-
-MOZCE_SHUNT_API DWORD GetGlyphOutlineW(HDC inDC, WCHAR inChar, UINT inFormat, void* inGM, DWORD inBufferSize, LPVOID outBuffer, CONST VOID* inMAT2)
-{
-   MOZCE_NOT_IMPLEMENTED_RV(__FUNCTION__, GDI_ERROR); 
-}
-
-
-MOZCE_SHUNT_API DWORD GetCurrentDirectoryW(DWORD inBufferLength, LPTSTR outBuffer)
-{
-    if(NULL != outBuffer && 0 < inBufferLength)
-    {
-        outBuffer[0] = _T('\0');
-    }
-   MOZCE_NOT_IMPLEMENTED_RV(__FUNCTION__, 0); 
-}
-
-
-MOZCE_SHUNT_API BOOL SetCurrentDirectoryW(LPCTSTR inPathName)
-{
-    MOZCE_NOT_IMPLEMENTED_RV(__FUNCTION__, FALSE); 
-}
-
-MOZCE_SHUNT_API BOOL MoveFileExW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName,DWORD dwFlags)
-{
-#ifdef API_LOGGING
-    mozce_printf("MoveFileExW called\n");
-#endif
-    BOOL retval = ::MoveFileW(lpExistingFileName, lpNewFileName);
-    return retval;
-}
-
-MOZCE_SHUNT_API BOOL SetEnvironmentVariableW( LPCWSTR name, LPCWSTR value )
-{
-    char key[256];
-    char val[256];
-    int rv =WideCharToMultiByte( CP_ACP, 0, name, -1, key, 256, NULL, NULL );
-    if(rv<0){
-        return rv;
-    }
-    rv =WideCharToMultiByte( CP_ACP, 0, value, -1, val, 256, NULL, NULL );
-    if(rv<0){
-        return rv;
-    }
-    return map_put(key,val);
-}
-
-#if 0
-{
-#endif
-} /* extern "C" */
diff -r 17e9560465b0 build/wince/tools/vs8ppc2003arm/arm-wince-gcc.c
--- a/build/wince/tools/vs8ppc2003arm/arm-wince-gcc.c	Thu Oct 23 09:51:35 2008 -0700
+++ b/build/wince/tools/vs8ppc2003arm/arm-wince-gcc.c	Thu Oct 30 05:41:44 2008 -0400
@@ -28,6 +28,7 @@
 //  args[i++] = "/DWIN32_PLATFORM_PSPC";
 //  args[i++] = "/DPOCKETPC2003_UI_MODEL";
   args[i++] = "/D_WINDOWS";
+  args[i++] = "/DNO_ERRNO";
 
   args[i++] = "/Zc:wchar_t-";          //
   args[i++] = "/GS-";                  // disable security checks
diff -r 17e9560465b0 build/wince/tools/vs8ppc2003arm/toolspath.h
--- a/build/wince/tools/vs8ppc2003arm/toolspath.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/build/wince/tools/vs8ppc2003arm/toolspath.h	Thu Oct 30 05:41:44 2008 -0400
@@ -7,7 +7,7 @@
 #endif
 
 #define WCE_BIN   "c:\\Program Files\\Microsoft Visual Studio 8\\VC\\ce\\bin\\x86_arm\\"
-#define WCE_CRT   "c:\\Program Files\\Microsoft Visual Studio 8\\VC/ce\\lib\\armv4i"
+#define WCE_CRT   "c:\\Program Files\\Microsoft Visual Studio 8\\VC\\ce\\lib\\armv4i"
 #define WCE_INC   "c:\\Program Files\\Windows Mobile 6 SDK\\PocketPC\\Include\\Armv4i"
 #define WCE_LIB   "c:\\Program Files\\Windows Mobile 6 SDK\\PocketPC\\Lib\\Armv4i"
 
@@ -109,7 +109,7 @@
       {
         // Deal with -OUT:/c/....
         //
-        // NOTE: THERE IS A BUG IN THIS IMPLEMENTATION IF 
+        // NOTE: THERE IS A BUG IN THIS IMPLEMENTATION IF
         //       THERE IS A SPACE IN THE TOPSRCDIR PATH.
         //
         // Should really check for spaces, then double-quote
diff -r 17e9560465b0 build/wince/tools/vs9ppc2003arm/arm-wince-gcc.c
--- a/build/wince/tools/vs9ppc2003arm/arm-wince-gcc.c	Thu Oct 23 09:51:35 2008 -0700
+++ b/build/wince/tools/vs9ppc2003arm/arm-wince-gcc.c	Thu Oct 30 05:41:44 2008 -0400
@@ -28,6 +28,7 @@
 //  args[i++] = "/DWIN32_PLATFORM_PSPC";
 //  args[i++] = "/DPOCKETPC2003_UI_MODEL";
   args[i++] = "/D_WINDOWS";
+  args[i++] = "/DNO_ERRNO";
 
   args[i++] = "/Zc:wchar_t-";          //
   args[i++] = "/GS-";                  // disable security checks
diff -r 17e9560465b0 client.mk
--- a/client.mk	Thu Oct 23 09:51:35 2008 -0700
+++ b/client.mk	Thu Oct 30 05:41:44 2008 -0400
@@ -169,6 +169,7 @@
 # 'configure' scripts generated by autoconf.
 CONFIGURES := $(TOPSRCDIR)/configure
 CONFIGURES += $(TOPSRCDIR)/nsprpub/configure
+CONFIGURES += $(TOPSRCDIR)/js/src/configure
 
 #######################################################################
 # Rules
@@ -277,6 +278,7 @@
 EXTRA_CONFIG_DEPS := \
 	$(TOPSRCDIR)/aclocal.m4 \
 	$(wildcard $(TOPSRCDIR)/build/autoconf/*.m4) \
+	$(TOPSRCDIR)/js/src/aclocal.m4 \
 	$(NULL)
 
 $(CONFIGURES): %: %.in $(EXTRA_CONFIG_DEPS)
diff -r 17e9560465b0 config/config.mk
--- a/config/config.mk	Thu Oct 23 09:51:35 2008 -0700
+++ b/config/config.mk	Thu Oct 30 05:41:44 2008 -0400
@@ -515,7 +515,7 @@
   --treehydra-modules=$(subst $(NULL) ,$(COMMA),$(strip $(TREEHYDRA_MODULES))) \
   $(NULL)
 
-DEHYDRA_FLAGS = -fplugin=$(DEHYDRA_PATH) -fplugin-arg="$(DEHYDRA_SCRIPT) $(DEHYDRA_ARGS)"
+DEHYDRA_FLAGS = -fplugin=$(DEHYDRA_PATH) -fplugin-arg='$(DEHYDRA_SCRIPT) $(DEHYDRA_ARGS)'
 
 ifdef DEHYDRA_PATH
 OS_CXXFLAGS += $(DEHYDRA_FLAGS)
diff -r 17e9560465b0 config/js/Makefile.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/config/js/Makefile.in	Thu Oct 30 05:41:44 2008 -0400
@@ -0,0 +1,65 @@
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code. This file was copied from parts of
+# mozilla/config/Makefile.in
+#
+# The Initial Developer of the Original Code is
+# Netscape Communications Corporation.
+# Portions created by the Initial Developer are Copyright (C) 1998
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Robert Ginda <rginda@netscape.com>
+#   John Taylor <jtaylor@netscape.com>
+#   Benjamin Smedberg <benjamin@smedbergs.us>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH = ../..
+topsrcdir = @top_srcdir@
+srcdir = @srcdir@
+VPATH = @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+JS_OBJDIR	= $(DEPTH)/js/src
+JS_CONFIG	= $(DIST)/bin/js-config
+
+include $(topsrcdir)/config/rules.mk
+
+# These rules assume that we configured js with an appropriate bindir,
+# libdir, and includedir, so that the 'make install' will put things
+# mostly in the right places.  The install-runtime-libs target takes
+# care of getting the needed libraries into the 'bin' directory as
+# well as the 'lib' directory.
+export::
+	$(MAKE) -C $(JS_OBJDIR) install
+	$(MAKE) -C $(JS_OBJDIR) install-runtime-libs libdir=$(DIST)/bin
+	$(INSTALL) $(IFLAGS2) $(JS_CONFIG) $(SDK_BIN_DIR)
+
+check::
+	$(MAKE) -C $(JS_OBJDIR) $@
diff -r 17e9560465b0 config/js/build.mk
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/config/js/build.mk	Thu Oct 30 05:41:44 2008 -0400
@@ -0,0 +1,40 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Mozilla build system.
+#
+# The Initial Developer of the Original Code is
+# the Mozilla Foundation <http://www.mozilla.org/>.
+# Portions created by the Initial Developer are Copyright (C) 2006
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Benjamin Smedberg <benjamin@smedbergs.us> (Initial Code)
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+TIERS += js
+tier_js_staticdirs = js/src
+tier_js_dirs = config/js
diff -r 17e9560465b0 config/rules.mk
--- a/config/rules.mk	Thu Oct 23 09:51:35 2008 -0700
+++ b/config/rules.mk	Thu Oct 30 05:41:44 2008 -0400
@@ -365,6 +365,11 @@
     @$(EXIT_ON_ERROR) \
     $(foreach dir,$(DIRS),$(UPDATE_TITLE) $(MAKE) -C $(dir) $@; ) true
 
+# we only use this for the makefiles target and other stuff that doesn't matter
+LOOP_OVER_PARALLEL_DIRS = \
+    @$(EXIT_ON_ERROR) \
+    $(foreach dir,$(PARALLEL_DIRS),$(UPDATE_TITLE) $(MAKE) -C $(dir) $@; ) true
+
 LOOP_OVER_STATIC_DIRS = \
     @$(EXIT_ON_ERROR) \
     $(foreach dir,$(STATIC_DIRS),$(UPDATE_TITLE) $(MAKE) -C $(dir) $@; ) true
@@ -372,6 +377,13 @@
 LOOP_OVER_TOOL_DIRS = \
     @$(EXIT_ON_ERROR) \
     $(foreach dir,$(TOOL_DIRS),$(UPDATE_TITLE) $(MAKE) -C $(dir) $@; ) true
+
+ifdef PARALLEL_DIRS
+# create a bunch of fake targets for order-only processing
+PARALLEL_DIRS_export = $(addsuffix _export,$(PARALLEL_DIRS))
+PARALLEL_DIRS_libs = $(addsuffix _libs,$(PARALLEL_DIRS))
+PARALLEL_DIRS_tools = $(addsuffix _tools,$(PARALLEL_DIRS))
+endif
 
 #
 # Now we can differentiate between objects used to build a library, and
@@ -582,6 +594,8 @@
 # SUBMAKEFILES: List of Makefiles for next level down.
 #   This is used to update or create the Makefiles before invoking them.
 SUBMAKEFILES += $(addsuffix /Makefile, $(DIRS) $(TOOL_DIRS))
+PARALLEL_SUBMAKEFILES += $(addsuffix /Makefile, $(PARALLEL_DIRS))
+SUBMAKEFILES += $(PARALLEL_SUBMAKEFILES)
 
 # The root makefile doesn't want to do a plain export/libs, because
 # of the tiers and because of libxul. Suppress the default rules in favor
@@ -677,14 +691,29 @@
 
 # Target to only regenerate makefiles
 makefiles: $(SUBMAKEFILES)
-ifneq (,$(DIRS)$(TOOL_DIRS))
+ifneq (,$(DIRS)$(TOOL_DIRS)$(PARALLEL_DIRS))
+	+$(LOOP_OVER_PARALLEL_DIRS)
 	+$(LOOP_OVER_DIRS)
 	+$(LOOP_OVER_TOOL_DIRS)
+endif
+
+ifdef PARALLEL_DIRS
+export:: $(PARALLEL_SUBMAKEFILES) | $(PARALLEL_DIRS_export)
+
+$(PARALLEL_DIRS_export):: %_export:
+	+$(MAKE) -C $* export
 endif
 
 export:: $(SUBMAKEFILES) $(MAKE_DIRS) $(if $(EXPORTS)$(XPIDLSRCS)$(SDK_HEADERS)$(SDK_XPIDLSRCS),$(PUBLIC)) $(if $(SDK_HEADERS)$(SDK_XPIDLSRCS),$(SDK_PUBLIC)) $(if $(XPIDLSRCS),$(IDL_DIR)) $(if $(SDK_XPIDLSRCS),$(SDK_IDL_DIR))
 	+$(LOOP_OVER_DIRS)
 	+$(LOOP_OVER_TOOL_DIRS)
+
+ifdef PARALLEL_DIRS
+tools:: $(PARALLEL_SUBMAKEFILES) | $(PARALLEL_DIRS_tools)
+
+$(PARALLEL_DIRS_tools):: %_tools:
+	+$(MAKE) -C $* tools
+endif
 
 tools:: $(SUBMAKEFILES) $(MAKE_DIRS)
 	+$(LOOP_OVER_DIRS)
@@ -718,6 +747,13 @@
 DSO_LDOPTS_DEPS = $(EXTRA_DSO_LIBS) $(filter %.$(LIB_SUFFIX), $(EXTRA_DSO_LDOPTS))
 
 ##############################################
+ifdef PARALLEL_DIRS
+libs:: $(PARALLEL_SUBMAKEFILES) | $(PARALLEL_DIRS_libs)
+
+$(PARALLEL_DIRS_libs):: %_libs:
+	+$(MAKE) -C $* libs
+endif
+
 libs:: $(SUBMAKEFILES) $(MAKE_DIRS) $(HOST_LIBRARY) $(LIBRARY) $(SHARED_LIBRARY) $(IMPORT_LIBRARY) $(HOST_PROGRAM) $(PROGRAM) $(HOST_SIMPLE_PROGRAMS) $(SIMPLE_PROGRAMS) $(JAVA_LIBRARY)
 ifndef NO_DIST_INSTALL
 ifdef LIBRARY
@@ -825,11 +861,13 @@
 clean clobber realclean clobber_all:: $(SUBMAKEFILES)
 	-rm -f $(ALL_TRASH)
 	-rm -rf $(ALL_TRASH_DIRS)
+	+-$(LOOP_OVER_PARALLEL_DIRS)
 	+-$(LOOP_OVER_DIRS)
 	+-$(LOOP_OVER_STATIC_DIRS)
 	+-$(LOOP_OVER_TOOL_DIRS)
 
 distclean:: $(SUBMAKEFILES)
+	+-$(LOOP_OVER_PARALLEL_DIRS)
 	+-$(LOOP_OVER_DIRS)
 	+-$(LOOP_OVER_STATIC_DIRS)
 	+-$(LOOP_OVER_TOOL_DIRS)
@@ -1605,6 +1643,7 @@
 	$(INSTALL) $(IFLAGS1) $^
 endif
 endif
+	+$(LOOP_OVER_PARALLEL_DIRS)
 	+$(LOOP_OVER_DIRS)
 	+$(LOOP_OVER_TOOL_DIRS)
 
@@ -1751,6 +1790,7 @@
 
 chrome::
 	$(MAKE) realchrome
+	+$(LOOP_OVER_PARALLEL_DIRS)
 	+$(LOOP_OVER_DIRS)
 	+$(LOOP_OVER_TOOL_DIRS)
 
@@ -1977,11 +2017,13 @@
 else
 depend:: $(SUBMAKEFILES)
 endif
+	+$(LOOP_OVER_PARALLEL_DIRS)
 	+$(LOOP_OVER_DIRS)
 	+$(LOOP_OVER_TOOL_DIRS)
 
 dependclean:: $(SUBMAKEFILES)
 	rm -f $(MDDEPFILES)
+	+$(LOOP_OVER_PARALLEL_DIRS)
 	+$(LOOP_OVER_DIRS)
 	+$(LOOP_OVER_TOOL_DIRS)
 
@@ -2083,6 +2125,7 @@
 
 TAGS: $(SUBMAKEFILES) $(CSRCS) $(CPPSRCS) $(wildcard *.h)
 	-etags $(CSRCS) $(CPPSRCS) $(wildcard *.h)
+	+$(LOOP_OVER_PARALLEL_DIRS)
 	+$(LOOP_OVER_DIRS)
 
 echo-variable-%:
@@ -2106,6 +2149,7 @@
 else
 	@$(if $(REQUIRES),echo $(subst $(topsrcdir)/,,$(srcdir)): $(MODULE): $(REQUIRES))
 endif
+	+$(LOOP_OVER_PARALLEL_DIRS)
 	+$(LOOP_OVER_DIRS)
 
 echo-depth-path:
@@ -2135,6 +2179,7 @@
 	@echo "DEPENDENT_LIBS      = $(DEPENDENT_LIBS)"
 	@echo --------------------------------------------------------------------------------
 endif
+	+$(LOOP_OVER_PARALLEL_DIRS)
 	+$(LOOP_OVER_DIRS)
 
 showbuild:
@@ -2196,6 +2241,7 @@
 ifneq (,$(filter $(PROGRAM) $(SIMPLE_PROGRAMS) $(LIBRARY) $(SHARED_LIBRARY),$(TARGETS)))
 	zip $(DEPTH)/makefiles $(subst $(topsrcdir),$(MOZ_SRC)/mozilla,$(srcdir)/Makefile.in)
 endif
+	+$(LOOP_OVER_PARALLEL_DIRS)
 	+$(LOOP_OVER_DIRS)
 
 documentation:
@@ -2203,5 +2249,6 @@
 	$(DOXYGEN) $(DEPTH)/config/doxygen.cfg
 
 check:: $(SUBMAKEFILES) $(MAKE_DIRS)
+	+$(LOOP_OVER_PARALLEL_DIRS)
 	+$(LOOP_OVER_DIRS)
 	+$(LOOP_OVER_TOOL_DIRS)
diff -r 17e9560465b0 configure.in
--- a/configure.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/configure.in	Thu Oct 30 05:41:44 2008 -0400
@@ -120,7 +120,7 @@
 PERL_VERSION=5.006
 LIBART_VERSION=2.3.4
 CAIRO_VERSION=1.6.0
-PANGO_VERSION=1.10.0
+PANGO_VERSION=1.14.0
 GTK2_VERSION=2.10.0
 MAKE_VERSION=3.78
 WINDRES_VERSION=2.14.90
@@ -4290,7 +4290,6 @@
 MOZ_BRANDING_DIRECTORY=
 MOZ_DBGRINFO_MODULES=
 MOZ_ENABLE_CANVAS=1
-MOZ_EXTENSIONS_ALL=" wallet p3p venkman inspector irc typeaheadfind gnomevfs sroaming datetime finger cview layout-debug tasks sql xforms schema-validation reporter"
 MOZ_FEEDS=1
 MOZ_IMG_DECODERS_DEFAULT="png gif jpeg bmp xbm icon"
 MOZ_IMG_ENCODERS_DEFAULT="png jpeg"
@@ -5473,7 +5472,7 @@
 [  --enable-extensions     Enable extensions],
 [ for option in `echo $enableval | sed 's/,/ /g'`; do
     if test "$option" = "yes" || test "$option" = "all"; then
-        MOZ_EXTENSIONS="$MOZ_EXTENSIONS $MOZ_EXTENSIONS_ALL"
+        AC_MSG_ERROR([--enable-extensions=$option is no longer supported.])
     elif test "$option" = "no" || test "$option" = "none"; then
         MOZ_EXTENSIONS=""
     elif test "$option" = "default"; then
@@ -8049,8 +8048,6 @@
 fi
 AC_SUBST(MOZ_MOVEMAIL)
 
-AC_DEFINE(JS_THREADSAFE)
-
 if test "$MOZ_DEBUG"; then
     AC_DEFINE(MOZ_REFLOW_PERF)
     AC_DEFINE(MOZ_REFLOW_PERF_DSP)
@@ -8283,5 +8280,21 @@
     rm -f config/autoconf.mk.bak
 fi
 
-fi # COMPILE_ENVIRONMENT
-
+# Run the SpiderMonkey 'configure' script.
+dist=$MOZ_BUILD_ROOT/dist
+ac_configure_args="$_SUBDIR_CONFIG_ARGS"
+ac_configure_args="$ac_configure_args --enable-threadsafe"
+ac_configure_args="$ac_configure_args --with-nspr-cflags='$NSPR_CFLAGS'"
+ac_configure_args="$ac_configure_args --with-nspr-libs='$NSPR_LIBS'"
+ac_configure_args="$ac_configure_args --includedir=$dist/include"
+ac_configure_args="$ac_configure_args --bindir=$dist/bin"
+ac_configure_args="$ac_configure_args --libdir=$dist/lib"
+ac_configure_args="$ac_configure_args --with-sync-build-files=$srcdir"
+if test "$MOZ_MEMORY"; then
+   ac_configure_args="$ac_configure_args --enable-jemalloc"  
+fi
+AC_OUTPUT_SUBDIRS(js/src)
+ac_configure_args="$_SUBDIR_CONFIG_ARGS"
+
+fi # COMPILE_ENVIRONMENT
+
diff -r 17e9560465b0 content/Makefile.in
--- a/content/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/Makefile.in	Thu Oct 30 05:41:44 2008 -0400
@@ -43,27 +43,27 @@
 include $(DEPTH)/config/autoconf.mk
 
 MODULE		= content
-DIRS		= base canvas html xml xul xbl xslt
+PARALLEL_DIRS		= base canvas html xml xul xbl xslt
 
 ifdef MOZ_MEDIA
-DIRS		+= \
+PARALLEL_DIRS	+= \
 		media \
 		$(NULL)
 endif
 
 ifdef MOZ_SVG
-DIRS		+= svg
+PARALLEL_DIRS	+= svg
 endif
 
 ifdef MOZ_XTF
-DIRS            += xtf
+PARALLEL_DIRS   += xtf
 endif
 
 ifdef MOZ_MATHML
-DIRS            += mathml
+PARALLEL_DIRS   += mathml
 endif
 
-DIRS           += events
+PARALLEL_DIRS   += events
 
 ifdef ENABLE_TESTS
 TOOL_DIRS += test
diff -r 17e9560465b0 content/base/Makefile.in
--- a/content/base/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/base/Makefile.in	Thu Oct 30 05:41:44 2008 -0400
@@ -42,7 +42,7 @@
 
 include $(DEPTH)/config/autoconf.mk
 
-DIRS		= public src
+PARALLEL_DIRS	= public src
 
 ifdef ENABLE_TESTS
 TOOL_DIRS		+= test
diff -r 17e9560465b0 content/base/public/nsContentCID.h
--- a/content/base/public/nsContentCID.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/base/public/nsContentCID.h	Thu Oct 30 05:41:44 2008 -0400
@@ -281,6 +281,15 @@
 
 #endif // MOZ_SVG
 
+#ifdef MOZ_MEDIA
+
+// {d899a152-9412-46b2-b651-2e71c5c2f05f}
+#define NS_VIDEODOCUMENT_CID   \
+{ 0xd899a152, 0x9412, 0x46b2,  \
+  { 0xb6, 0x51, 0x2e, 0x71, 0xc5, 0xc2, 0xf0, 0x5f } }
+
+#endif
+
 #define NS_SYNCLOADDOMSERVICE_CID                   \
  { /* 0e4e7d00-f71a-439f-9178-1a71ff11b55f */       \
   0x0e4e7d00, 0xf71a, 0x439f,                       \
diff -r 17e9560465b0 content/base/public/nsIDocument.h
--- a/content/base/public/nsIDocument.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/base/public/nsIDocument.h	Thu Oct 30 05:41:44 2008 -0400
@@ -96,8 +96,8 @@
 
 // IID for the nsIDocument interface
 #define NS_IDOCUMENT_IID      \
-{ 0x189ebc9e, 0x779b, 0x4c49, \
- { 0x90, 0x8b, 0x9a, 0x80, 0x25, 0x9b, 0xaf, 0xa7 } }
+{ 0x6304ae8e, 0x2634, 0x45ed, \
+  { 0x9e, 0x09, 0x83, 0x09, 0x5b, 0x46, 0x72, 0x8b } }
 
 // Flag for AddStyleSheet().
 #define NS_STYLESHEET_FROM_CATALOG                (1 << 0)
@@ -567,11 +567,6 @@
   virtual nsIScriptGlobalObject*
     GetScriptHandlingObject(PRBool& aHasHadScriptHandlingObject) const = 0;
   virtual void SetScriptHandlingObject(nsIScriptGlobalObject* aScriptObject) = 0;
-
-  /**
-   * Sets script handling object to null and marks that document has had one.
-   */
-  virtual void ClearScriptHandlingObject() = 0;
 
   /**
    * Get the object that is used as the scope for all of the content
@@ -1262,6 +1257,11 @@
 nsresult
 NS_NewImageDocument(nsIDocument** aInstancePtrResult);
 
+#ifdef MOZ_MEDIA
+nsresult
+NS_NewVideoDocument(nsIDocument** aInstancePtrResult);
+#endif
+
 nsresult
 NS_NewDocumentFragment(nsIDOMDocumentFragment** aInstancePtrResult,
                        nsNodeInfoManager *aNodeInfoManager);
diff -r 17e9560465b0 content/base/src/nsContentUtils.cpp
--- a/content/base/src/nsContentUtils.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/base/src/nsContentUtils.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -479,7 +479,16 @@
     { &nsGkAtoms::ondurationchange,              { NS_DURATIONCHANGE, EventNameType_HTML }},
     { &nsGkAtoms::onvolumechange,                { NS_VOLUMECHANGE, EventNameType_HTML }},
 #endif //MOZ_MEDIA
-    { &nsGkAtoms::onMozAfterPaint,               { NS_AFTERPAINT, EventNameType_None }}
+    { &nsGkAtoms::onMozAfterPaint,               { NS_AFTERPAINT, EventNameType_None }},
+
+    // Simple gesture events
+    { &nsGkAtoms::onMozSwipeGesture,             { NS_SIMPLE_GESTURE_SWIPE, EventNameType_None } },
+    { &nsGkAtoms::onMozMagnifyGestureStart,      { NS_SIMPLE_GESTURE_MAGNIFY_START, EventNameType_None } },
+    { &nsGkAtoms::onMozMagnifyGestureUpdate,     { NS_SIMPLE_GESTURE_MAGNIFY_UPDATE, EventNameType_None } },
+    { &nsGkAtoms::onMozMagnifyGesture,           { NS_SIMPLE_GESTURE_MAGNIFY, EventNameType_None } },
+    { &nsGkAtoms::onMozRotateGestureStart,       { NS_SIMPLE_GESTURE_ROTATE_START, EventNameType_None } },
+    { &nsGkAtoms::onMozRotateGestureUpdate,      { NS_SIMPLE_GESTURE_ROTATE_UPDATE, EventNameType_None } },
+    { &nsGkAtoms::onMozRotateGesture,            { NS_SIMPLE_GESTURE_ROTATE, EventNameType_None } }
   };
 
   sEventTable = new nsDataHashtable<nsISupportsHashKey, EventNameMapping>;
diff -r 17e9560465b0 content/base/src/nsDocument.h
--- a/content/base/src/nsDocument.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/base/src/nsDocument.h	Thu Oct 30 05:41:44 2008 -0400
@@ -695,12 +695,6 @@
     GetScriptHandlingObject(PRBool& aHasHadScriptHandlingObject) const;
   virtual void SetScriptHandlingObject(nsIScriptGlobalObject* aScriptObject);
 
-  virtual void ClearScriptHandlingObject()
-  {
-    mScriptObject = nsnull;
-    mHasHadScriptHandlingObject = PR_TRUE;
-  }
-
   virtual nsIScriptGlobalObject* GetScopeObject();
 
   /**
diff -r 17e9560465b0 content/base/src/nsGkAtomList.h
--- a/content/base/src/nsGkAtomList.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/base/src/nsGkAtomList.h	Thu Oct 30 05:41:44 2008 -0400
@@ -1457,6 +1457,16 @@
 GK_ATOM(secondsFromDateTime, "seconds-from-dateTime")
 #endif
 
+// Simple gestures support
+GK_ATOM(onMozSwipeGesture, "onMozSwipeGesture")
+GK_ATOM(onMozMagnifyGestureStart, "onMozMagnifyGestureStart")
+GK_ATOM(onMozMagnifyGestureUpdate, "onMozMagnifyGestureUpdate")
+GK_ATOM(onMozMagnifyGesture, "onMozMagnifyGesture")
+GK_ATOM(onMozRotateGestureStart, "onMozRotateGestureStart")
+GK_ATOM(onMozRotateGestureUpdate, "onMozRotateGestureUpdate")
+GK_ATOM(onMozRotateGesture, "onMozRotateGesture")
+
+
 //---------------------------------------------------------------------------
 // Special atoms
 //---------------------------------------------------------------------------
diff -r 17e9560465b0 content/base/src/nsXMLHttpRequest.cpp
--- a/content/base/src/nsXMLHttpRequest.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/base/src/nsXMLHttpRequest.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -1176,6 +1176,8 @@
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mContext)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mChannel)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mReadRequest)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mResponseXML)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mACGetChannel)
 
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOnUploadProgressListener)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOnReadystatechangeListener)
@@ -1195,6 +1197,8 @@
   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mContext)
   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mChannel)
   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mReadRequest)
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mResponseXML)
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mACGetChannel)
 
   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mOnUploadProgressListener)
   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mOnReadystatechangeListener)
diff -r 17e9560465b0 content/base/src/nsXMLHttpRequest.h
--- a/content/base/src/nsXMLHttpRequest.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/base/src/nsXMLHttpRequest.h	Thu Oct 30 05:41:44 2008 -0400
@@ -460,7 +460,7 @@
   PRPackedBool mTimerIsActive;
   PRPackedBool mProgressEventWasDelayed;
   PRPackedBool mLoadLengthComputable;
-  PRUint32 mLoadTotal; // 0 if not known.
+  PRUint64 mLoadTotal; // 0 if not known.
   nsCOMPtr<nsITimer> mProgressNotifier;
 
   PRPackedBool mFirstStartRequestSeen;
diff -r 17e9560465b0 content/canvas/Makefile.in
--- a/content/canvas/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/canvas/Makefile.in	Thu Oct 30 05:41:44 2008 -0400
@@ -43,7 +43,7 @@
 
 include $(DEPTH)/config/autoconf.mk
 
-DIRS		= public src
+PARALLEL_DIRS	= public src
 
 ifdef ENABLE_TESTS
 DIRS		+= test
diff -r 17e9560465b0 content/events/Makefile.in
--- a/content/events/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/events/Makefile.in	Thu Oct 30 05:41:44 2008 -0400
@@ -42,7 +42,7 @@
 
 include $(DEPTH)/config/autoconf.mk
 
-DIRS		= public src
+PARALLEL_DIRS	= public src
 
 ifdef ENABLE_TESTS
 DIRS		+= test
diff -r 17e9560465b0 content/events/public/nsIPrivateDOMEvent.h
--- a/content/events/public/nsIPrivateDOMEvent.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/events/public/nsIPrivateDOMEvent.h	Thu Oct 30 05:41:44 2008 -0400
@@ -112,4 +112,6 @@
 NS_NewDOMProgressEvent(nsIDOMEvent** aInstancePtrResult, nsPresContext* aPresContext, class nsEvent* aEvent);
 nsresult
 NS_NewDOMNotifyPaintEvent(nsIDOMEvent** aResult, nsPresContext* aPresContext, class nsNotifyPaintEvent* aEvent);
+nsresult
+NS_NewDOMSimpleGestureEvent(nsIDOMEvent** aInstancePtrResult, nsPresContext* aPresContext, class nsSimpleGestureEvent* aEvent);
 #endif // nsIPrivateDOMEvent_h__
diff -r 17e9560465b0 content/events/src/Makefile.in
--- a/content/events/src/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/events/src/Makefile.in	Thu Oct 30 05:41:44 2008 -0400
@@ -95,6 +95,7 @@
 		nsDOMProgressEvent.cpp \
 		nsDOMDataTransfer.cpp \
 		nsDOMNotifyPaintEvent.cpp \
+		nsDOMSimpleGestureEvent.cpp \
 		$(NULL)
 
 # we don't want the shared lib, but we want to force the creation of a static lib.
@@ -110,6 +111,7 @@
              -I$(srcdir)/../../../dom/src/base \
              -I$(srcdir)/../../../layout/generic \
              -I$(srcdir)/../../../layout/xul/base/src \
+             -I$(srcdir)/../../../layout/xul/base/src/tree/src \
              $(NULL)
 
 DEFINES += -D_IMPL_NS_LAYOUT
diff -r 17e9560465b0 content/events/src/nsDOMDataContainerEvent.h
--- a/content/events/src/nsDOMDataContainerEvent.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/events/src/nsDOMDataContainerEvent.h	Thu Oct 30 05:41:44 2008 -0400
@@ -41,7 +41,6 @@
 
 #include "nsIDOMDataContainerEvent.h"
 #include "nsDOMEvent.h"
-#include "nsInterfaceHashtable.h"
 
 class nsDOMDataContainerEvent : public nsDOMEvent,
                                 public nsIDOMDataContainerEvent
diff -r 17e9560465b0 content/events/src/nsDOMEvent.cpp
--- a/content/events/src/nsDOMEvent.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/events/src/nsDOMEvent.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -83,7 +83,14 @@
   "canshowcurrentframe", "canplay", "canplaythrough", "ratechange",
   "durationchange", "volumechange",
 #endif // MOZ_MEDIA
-  "MozAfterPaint"
+  "MozAfterPaint",
+  "MozSwipeGesture",
+  "MozMagnifyGestureStart",
+  "MozMagnifyGestureUpdate",
+  "MozMagnifyGesture",
+  "MozRotateGestureStart",
+  "MozRotateGestureUpdate",
+  "MozRotateGesture"
 };
 
 static char *sPopupAllowedEvents;
@@ -650,6 +657,22 @@
     if (atom == nsGkAtoms::onMozAfterPaint)
       mEvent->message = NS_AFTERPAINT;
   }
+  else if (mEvent->eventStructType == NS_SIMPLE_GESTURE_EVENT) {
+    if (atom == nsGkAtoms::onMozSwipeGesture)
+      mEvent->message = NS_SIMPLE_GESTURE_SWIPE;
+    else if (atom == nsGkAtoms::onMozMagnifyGestureStart)
+      mEvent->message = NS_SIMPLE_GESTURE_MAGNIFY_START;
+    else if (atom == nsGkAtoms::onMozMagnifyGestureUpdate)
+      mEvent->message = NS_SIMPLE_GESTURE_MAGNIFY_UPDATE;
+    else if (atom == nsGkAtoms::onMozMagnifyGesture)
+      mEvent->message = NS_SIMPLE_GESTURE_MAGNIFY;
+    else if (atom == nsGkAtoms::onMozRotateGestureStart)
+      mEvent->message = NS_SIMPLE_GESTURE_ROTATE_START;
+    else if (atom == nsGkAtoms::onMozRotateGestureUpdate)
+      mEvent->message = NS_SIMPLE_GESTURE_ROTATE_UPDATE;
+    else if (atom == nsGkAtoms::onMozRotateGesture)
+      mEvent->message = NS_SIMPLE_GESTURE_ROTATE;
+  }
 
   if (mEvent->message == NS_USER_DEFINED_EVENT)
     mEvent->userType = atom;
@@ -970,6 +993,22 @@
       newEvent =
         new nsNotifyPaintEvent(PR_FALSE, msg,
                                event->sameDocRegion, event->crossDocRegion);
+      break;
+    }
+    case NS_SIMPLE_GESTURE_EVENT:
+    {
+      nsSimpleGestureEvent* oldSimpleGestureEvent = static_cast<nsSimpleGestureEvent*>(mEvent);
+      nsSimpleGestureEvent* simpleGestureEvent = 
+        new nsSimpleGestureEvent(PR_FALSE, msg, nsnull, 0, 0.0);
+      NS_ENSURE_TRUE(simpleGestureEvent, NS_ERROR_OUT_OF_MEMORY);
+      isInputEvent = PR_TRUE;
+      simpleGestureEvent->direction = oldSimpleGestureEvent->direction;
+      simpleGestureEvent->delta = oldSimpleGestureEvent->delta;
+      simpleGestureEvent->isAlt = oldSimpleGestureEvent->isAlt;
+      simpleGestureEvent->isControl = oldSimpleGestureEvent->isControl;
+      simpleGestureEvent->isShift = oldSimpleGestureEvent->isShift;
+      simpleGestureEvent->isMeta = oldSimpleGestureEvent->isMeta;
+      newEvent = simpleGestureEvent;
       break;
     }
     default:
@@ -1471,6 +1510,20 @@
 #endif
   case NS_AFTERPAINT:
     return sEventNames[eDOMEvents_afterpaint];
+  case NS_SIMPLE_GESTURE_SWIPE:
+    return sEventNames[eDOMEvents_MozSwipeGesture];
+  case NS_SIMPLE_GESTURE_MAGNIFY_START:
+    return sEventNames[eDOMEvents_MozMagnifyGestureStart];
+  case NS_SIMPLE_GESTURE_MAGNIFY_UPDATE:
+    return sEventNames[eDOMEvents_MozMagnifyGestureUpdate];
+  case NS_SIMPLE_GESTURE_MAGNIFY:
+    return sEventNames[eDOMEvents_MozMagnifyGesture];
+  case NS_SIMPLE_GESTURE_ROTATE_START:
+    return sEventNames[eDOMEvents_MozRotateGestureStart];
+  case NS_SIMPLE_GESTURE_ROTATE_UPDATE:
+    return sEventNames[eDOMEvents_MozRotateGestureUpdate];
+  case NS_SIMPLE_GESTURE_ROTATE:
+    return sEventNames[eDOMEvents_MozRotateGesture];
   default:
     break;
   }
diff -r 17e9560465b0 content/events/src/nsDOMEvent.h
--- a/content/events/src/nsDOMEvent.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/events/src/nsDOMEvent.h	Thu Oct 30 05:41:44 2008 -0400
@@ -161,7 +161,14 @@
     eDOMEvents_durationchange,
     eDOMEvents_volumechange,
 #endif
-    eDOMEvents_afterpaint
+    eDOMEvents_afterpaint,
+    eDOMEvents_MozSwipeGesture,
+    eDOMEvents_MozMagnifyGestureStart,
+    eDOMEvents_MozMagnifyGestureUpdate,
+    eDOMEvents_MozMagnifyGesture,
+    eDOMEvents_MozRotateGestureStart,
+    eDOMEvents_MozRotateGestureUpdate,
+    eDOMEvents_MozRotateGesture
   };
 
   nsDOMEvent(nsPresContext* aPresContext, nsEvent* aEvent);
diff -r 17e9560465b0 content/events/src/nsDOMSimpleGestureEvent.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/events/src/nsDOMSimpleGestureEvent.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -0,0 +1,153 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Thomas K. Dyas <tdyas@zecador.org>.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsDOMSimpleGestureEvent.h"
+#include "nsGUIEvent.h"
+#include "nsContentUtils.h"
+
+
+nsDOMSimpleGestureEvent::nsDOMSimpleGestureEvent(nsPresContext* aPresContext, nsSimpleGestureEvent* aEvent)
+  : nsDOMUIEvent(aPresContext, aEvent ? aEvent : new nsSimpleGestureEvent(PR_FALSE, 0, nsnull, 0, 0.0))
+{
+  NS_ASSERTION(mEvent->eventStructType == NS_SIMPLE_GESTURE_EVENT, "event type mismatch");
+
+  if (aEvent) {
+    mEventIsInternal = PR_FALSE;
+  } else {
+    mEventIsInternal = PR_TRUE;
+    mEvent->time = PR_Now();
+  }
+}
+
+nsDOMSimpleGestureEvent::~nsDOMSimpleGestureEvent()
+{
+  if (mEventIsInternal) {
+    delete static_cast<nsSimpleGestureEvent*>(mEvent);
+    mEvent = nsnull;
+  }
+}
+
+NS_IMPL_ADDREF_INHERITED(nsDOMSimpleGestureEvent, nsDOMUIEvent)
+NS_IMPL_RELEASE_INHERITED(nsDOMSimpleGestureEvent, nsDOMUIEvent)
+
+NS_INTERFACE_MAP_BEGIN(nsDOMSimpleGestureEvent)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMSimpleGestureEvent)
+  NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SimpleGestureEvent)
+NS_INTERFACE_MAP_END_INHERITING(nsDOMUIEvent)
+
+/* readonly attribute unsigned long direction; */
+NS_IMETHODIMP
+nsDOMSimpleGestureEvent::GetDirection(PRUint32 *aDirection)
+{
+  NS_ENSURE_ARG_POINTER(aDirection);
+  *aDirection = static_cast<nsSimpleGestureEvent*>(mEvent)->direction;
+  return NS_OK;
+}
+
+/* readonly attribute float delta; */
+NS_IMETHODIMP
+nsDOMSimpleGestureEvent::GetDelta(PRFloat64 *aDelta)
+{
+  NS_ENSURE_ARG_POINTER(aDelta);
+  *aDelta = static_cast<nsSimpleGestureEvent*>(mEvent)->delta;
+  return NS_OK;
+}
+
+/* readonly attribute boolean altKey; */
+NS_IMETHODIMP
+nsDOMSimpleGestureEvent::GetAltKey(PRBool* aIsDown)
+{
+  NS_ENSURE_ARG_POINTER(aIsDown);
+  *aIsDown = static_cast<nsInputEvent*>(mEvent)->isAlt;
+  return NS_OK;
+}
+
+/* readonly attribute boolean ctrlKey; */
+NS_IMETHODIMP
+nsDOMSimpleGestureEvent::GetCtrlKey(PRBool* aIsDown)
+{
+  NS_ENSURE_ARG_POINTER(aIsDown);
+  *aIsDown = static_cast<nsInputEvent*>(mEvent)->isControl;
+  return NS_OK;
+}
+
+/* readonly attribute boolean shiftKey; */
+NS_IMETHODIMP
+nsDOMSimpleGestureEvent::GetShiftKey(PRBool* aIsDown)
+{
+  NS_ENSURE_ARG_POINTER(aIsDown);
+  *aIsDown = static_cast<nsInputEvent*>(mEvent)->isShift;
+  return NS_OK;
+}
+
+/* readonly attribute boolean metaKey; */
+NS_IMETHODIMP
+nsDOMSimpleGestureEvent::GetMetaKey(PRBool* aIsDown)
+{
+  NS_ENSURE_ARG_POINTER(aIsDown);
+  *aIsDown = static_cast<nsInputEvent*>(mEvent)->isMeta;
+  return NS_OK;
+}
+
+
+NS_IMETHODIMP
+nsDOMSimpleGestureEvent::InitSimpleGestureEvent(const nsAString & typeArg, PRBool canBubbleArg, PRBool cancelableArg, nsIDOMAbstractView *viewArg, PRInt32 detailArg, PRUint32 directionArg, PRFloat64 deltaArg, PRBool altKeyArg, PRBool ctrlKeyArg, PRBool shiftKeyArg, PRBool metaKeyArg)
+{
+  nsresult rv = nsDOMUIEvent::InitUIEvent(typeArg, canBubbleArg, cancelableArg, viewArg, detailArg);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsSimpleGestureEvent* simpleGestureEvent = static_cast<nsSimpleGestureEvent*>(mEvent);
+  simpleGestureEvent->direction = directionArg;
+  simpleGestureEvent->delta = deltaArg;
+  simpleGestureEvent->isAlt = altKeyArg;
+  simpleGestureEvent->isControl = ctrlKeyArg;
+  simpleGestureEvent->isShift = shiftKeyArg;
+  simpleGestureEvent->isMeta = metaKeyArg;
+
+  return NS_OK;
+}
+
+nsresult NS_NewDOMSimpleGestureEvent(nsIDOMEvent** aInstancePtrResult,
+                                     nsPresContext* aPresContext,
+                                     nsSimpleGestureEvent *aEvent)
+{
+  nsDOMSimpleGestureEvent *it = new nsDOMSimpleGestureEvent(aPresContext, aEvent);
+  if (nsnull == it) {
+    return NS_ERROR_OUT_OF_MEMORY;
+  }
+  return CallQueryInterface(it, aInstancePtrResult);
+}
diff -r 17e9560465b0 content/events/src/nsDOMSimpleGestureEvent.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/events/src/nsDOMSimpleGestureEvent.h	Thu Oct 30 05:41:44 2008 -0400
@@ -0,0 +1,60 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Thomas K. Dyas <tdyas@zecador.org>.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsDOMSimpleGestureEvent_h__
+#define nsDOMSimpleGestureEvent_h__
+
+#include "nsIDOMSimpleGestureEvent.h"
+#include "nsDOMUIEvent.h"
+
+class nsPresContext;
+
+class nsDOMSimpleGestureEvent : public nsIDOMSimpleGestureEvent,
+  public nsDOMUIEvent
+{
+public:
+  nsDOMSimpleGestureEvent(nsPresContext*, nsSimpleGestureEvent*);
+  virtual ~nsDOMSimpleGestureEvent();
+
+  NS_DECL_ISUPPORTS_INHERITED
+
+  NS_DECL_NSIDOMSIMPLEGESTUREEVENT
+
+  // Forward to base class
+  NS_FORWARD_TO_NSDOMUIEVENT
+};
+
+#endif
diff -r 17e9560465b0 content/events/src/nsEventDispatcher.cpp
--- a/content/events/src/nsEventDispatcher.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/events/src/nsEventDispatcher.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -649,6 +649,9 @@
       return NS_NewDOMNotifyPaintEvent(aDOMEvent, aPresContext,
                                        static_cast<nsNotifyPaintEvent*>
                                                      (aEvent));
+    case NS_SIMPLE_GESTURE_EVENT:
+      return NS_NewDOMSimpleGestureEvent(aDOMEvent, aPresContext,
+                                         static_cast<nsSimpleGestureEvent*>(aEvent));
     }
 
     // For all other types of events, create a vanilla event object.
@@ -707,6 +710,8 @@
     return NS_NewDOMProgressEvent(aDOMEvent, aPresContext, nsnull);
   if (aEventType.LowerCaseEqualsLiteral("notifypaintevent"))
     return NS_NewDOMNotifyPaintEvent(aDOMEvent, aPresContext, nsnull);
+  if (aEventType.LowerCaseEqualsLiteral("simplegestureevent"))
+    return NS_NewDOMSimpleGestureEvent(aDOMEvent, aPresContext, nsnull);
 
   return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
 }
diff -r 17e9560465b0 content/events/src/nsEventStateManager.cpp
--- a/content/events/src/nsEventStateManager.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/events/src/nsEventStateManager.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -149,7 +149,7 @@
 #include "nsDOMDataTransfer.h"
 #include "nsContentAreaDragDrop.h"
 #ifdef MOZ_XUL
-#include "nsITreeBoxObject.h"
+#include "nsTreeBodyFrame.h"
 #endif
 
 #ifdef XP_MACOSX
@@ -2304,9 +2304,9 @@
           if (presShell) {
             nsIFrame* frame = presShell->GetPrimaryFrameFor(content);
             if (frame) {
-              nsITreeBoxObject* treeBoxObject;
-              CallQueryInterface(frame, &treeBoxObject);
-              treeBoxObject->GetSelectionRegion(getter_AddRefs(region));
+              nsTreeBodyFrame* treeBody;
+              CallQueryInterface(frame, &treeBody);
+              treeBody->GetSelectionRegion(getter_AddRefs(region));
             }
           }
         }
@@ -4362,7 +4362,7 @@
   nsresult rv;
   nsCOMPtr<nsIFrameTraversal> trav(do_CreateInstance(kFrameTraversalCID, &rv));
   NS_ENSURE_SUCCESS(rv, rv);
-  nsCOMPtr<nsIBidirectionalEnumerator> frameTraversal;
+  nsCOMPtr<nsIFrameEnumerator> frameTraversal;
 
   // --- Get frame to start with ---
   if (!aStartFrame) {
@@ -4381,7 +4381,7 @@
                                 );
     NS_ENSURE_SUCCESS(rv, rv);
     if (!forward) {
-      rv = frameTraversal->Last();
+      frameTraversal->Last();
     }
   }
   else {
@@ -4397,15 +4397,16 @@
         !aStartContent->IsNodeOfType(nsINode::eHTML)) {
       // Need to do special check in case we're in an imagemap which has multiple
       // content per frame, so don't skip over the starting frame.
-      rv = forward ? frameTraversal->Next() : frameTraversal->Prev();
+      if (forward)
+        frameTraversal->Next();
+      else
+        frameTraversal->Prev();
     }
   }
 
   // -- Walk frames to find something tabbable matching mCurrentTabIndex --
-  while (NS_SUCCEEDED(rv)) {
-    nsISupports* currentItem;
-    frameTraversal->CurrentItem(&currentItem);
-    *aResultFrame = (nsIFrame*)currentItem;
+  while (1) {
+    *aResultFrame = frameTraversal->CurrentItem();
     if (!*aResultFrame) {
       break;
     }
@@ -4437,7 +4438,10 @@
         return NS_OK;
       }
     }
-    rv = forward ? frameTraversal->Next() : frameTraversal->Prev();
+    if (forward)
+      frameTraversal->Next();
+    else
+      frameTraversal->Prev();
   }
 
   // -- Reached end or beginning of document --
@@ -5544,7 +5548,7 @@
         if (nodeValue.Length() == *aStartOffset && !isFormControl &&
             startContent != mDocument->GetRootContent()) {
           // Yes, indeed we were at the end of the last node
-          nsCOMPtr<nsIBidirectionalEnumerator> frameTraversal;
+          nsCOMPtr<nsIFrameEnumerator> frameTraversal;
 
           nsCOMPtr<nsIFrameTraversal> trav(do_CreateInstance(kFrameTraversalCID,
                                                              &rv));
@@ -5566,9 +5570,8 @@
             // Continue getting the next frame until the primary content for the frame
             // we are on changes - we don't want to be stuck in the same place
             frameTraversal->Next();
-            nsISupports* currentItem;
-            frameTraversal->CurrentItem(&currentItem);
-            if (nsnull == (newCaretFrame = static_cast<nsIFrame*>(currentItem))) {
+            newCaretFrame = frameTraversal->CurrentItem();
+            if (nsnull == newCaretFrame) {
               break;
             }
             newCaretContent = newCaretFrame->GetContent();            
diff -r 17e9560465b0 content/events/test/test_bug350471.xul
--- a/content/events/test/test_bug350471.xul	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/events/test/test_bug350471.xul	Thu Oct 30 05:41:44 2008 -0400
@@ -134,9 +134,8 @@
   });
 }
 
-function testDefaultHandling() {
+function testDefaultHandling(andThen) {
   let scrollbox = document.getElementById("scrollbox");
-  let currentTest = "";
   
   function scrollWithPreventDefault(aEvent, aDoConsume) {
     function listener(e) {
@@ -150,7 +149,13 @@
     scrollbox.removeEventListener("MozMousePixelScroll", listener, true);
   }
   
-  function helper(aType, aHasPixels, aAxis, aStart, aDelta, aConsumeLine, aConsumePixel, aPositionShouldChange) {
+  let tests = [];
+  function helper(aType, aHasPixels, aAxis, aStart, aDelta, aConsumeLine, aConsumePixel, aPositionShouldChange, aCurrentTest) {
+    tests.push([aType, aHasPixels, aAxis, aStart, aDelta, aConsumeLine, aConsumePixel, aPositionShouldChange, aCurrentTest]);
+  }
+  function exec() {
+    let [aType, aHasPixels, aAxis, aStart, aDelta, aConsumeLine, aConsumePixel, aPositionShouldChange, currentTest] = tests[0];
+    tests.shift();
     scrollbox.scrollLeft = aStart;
     scrollbox.scrollTop = aStart;
     scrollWithPreventDefault({
@@ -162,23 +167,29 @@
       "DOMMouseScroll": aConsumeLine,
       "MozMousePixelScroll": aConsumePixel
     });
-    let newPos = scrollbox[aAxis == "horizontal" ? "scrollLeft" : "scrollTop"];
-    let newPosWrongAxis = scrollbox[aAxis == "horizontal" ? "scrollTop" : "scrollLeft"];
-
-    is(newPosWrongAxis, aStart, currentTest + " wrong axis scrolled - type: " + aType);
-
-    if (aPositionShouldChange) {
-      if (aType == "MozMousePixelScroll") {
-        // aDelta is in pixels, no conversion necessary
-        is(newPos, aStart + aDelta, currentTest + " wrong scroll position - type: " + aType);
+    setTimeout(function() {
+      let newPos = scrollbox[aAxis == "horizontal" ? "scrollLeft" : "scrollTop"];
+      let newPosWrongAxis = scrollbox[aAxis == "horizontal" ? "scrollTop" : "scrollLeft"];
+  
+      is(newPosWrongAxis, aStart, currentTest + " wrong axis scrolled - type: " + aType);
+  
+      if (aPositionShouldChange) {
+        if (aType == "MozMousePixelScroll") {
+          // aDelta is in pixels, no conversion necessary
+          is(newPos, aStart + aDelta, currentTest + " wrong scroll position - type: " + aType);
+        } else {
+          // Use minLineHeight and maxLineHeight as an estimate for the conversion factor.
+          isbetween(newPos, aStart + aDelta * minLineHeight, aStart + aDelta * maxLineHeight,
+                    currentTest + " wrong scroll position - type: " + aType);
+        }
       } else {
-        // Use minLineHeight and maxLineHeight as an estimate for the conversion factor.
-        isbetween(newPos, aStart + aDelta * minLineHeight, aStart + aDelta * maxLineHeight,
-                  currentTest + " wrong scroll position - type: " + aType);
+        is(newPos, aStart, currentTest + " The scroll position shouldn't have changed. - type: " + aType);
       }
-    } else {
-      is(newPos, aStart, currentTest + " The scroll position shouldn't have changed. - type: " + aType);
-    }
+      if (tests.length)
+        exec();
+      else
+        andThen();
+    }, 0);
   }
 
   ["horizontal", "vertical"].forEach(function(aAxis) {
@@ -186,12 +197,13 @@
       [false, true].forEach(function(aConsumeLine) {
         [false, true].forEach(function(aConsumePixel) {
           let shouldScroll = !aConsumeLine && !aConsumePixel;
+          let currentTest = "";
           
           currentTest = "normal DOMMouseScroll: only scroll if neither line nor pixel scroll are consumed.";
-          helper("DOMMouseScroll", false, aAxis, 4000, aDelta, aConsumeLine, aConsumePixel, shouldScroll);
+          helper("DOMMouseScroll", false, aAxis, 4000, aDelta, aConsumeLine, aConsumePixel, shouldScroll, currentTest);
           
           currentTest = "DOMMouseScroll with hasPixels: never scroll.";
-          helper("DOMMouseScroll", true, aAxis, 4000, aDelta, aConsumeLine, aConsumePixel, false);
+          helper("DOMMouseScroll", true, aAxis, 4000, aDelta, aConsumeLine, aConsumePixel, false, currentTest);
           
           currentTest = "MozMousePixelScroll (consumed: " + aConsumePixel +
                         ") with preceding DOMMouseScroll (consumed: " + aConsumeLine +
@@ -199,16 +211,18 @@
           // It shouldn't matter:
           //  1. whether hasPixels is set on the preceding DOMMouseScroll event or
           //  2. whether the preceding DOMMouseScroll event's MozMousePixelScroll event is consumed.
-          helper("DOMMouseScroll", true, aAxis, 4000, aDelta, aConsumeLine, false, false);
-          helper("MozMousePixelScroll", false, aAxis, 4000, aDelta, false, aConsumePixel, shouldScroll);
-          helper("DOMMouseScroll", false, aAxis, 4000, aDelta, aConsumeLine, false, !aConsumeLine);
-          helper("MozMousePixelScroll", false, aAxis, 4000, aDelta, false, aConsumePixel, shouldScroll);
-          helper("DOMMouseScroll", false, aAxis, 4000, aDelta, aConsumeLine, true, false);
-          helper("MozMousePixelScroll", false, aAxis, 4000, aDelta, false, aConsumePixel, shouldScroll);
+          helper("DOMMouseScroll", true, aAxis, 4000, aDelta, aConsumeLine, false, false, currentTest);
+          helper("MozMousePixelScroll", false, aAxis, 4000, aDelta, false, aConsumePixel, shouldScroll, currentTest);
+          helper("DOMMouseScroll", false, aAxis, 4000, aDelta, aConsumeLine, false, !aConsumeLine, currentTest);
+          helper("MozMousePixelScroll", false, aAxis, 4000, aDelta, false, aConsumePixel, shouldScroll, currentTest);
+          helper("DOMMouseScroll", false, aAxis, 4000, aDelta, aConsumeLine, true, false, currentTest);
+          helper("MozMousePixelScroll", false, aAxis, 4000, aDelta, false, aConsumePixel, shouldScroll, currentTest);
         });
       });
     });
   });
+  
+  exec();
 }
 
 function runTests() {
@@ -222,9 +236,7 @@
   setTimeout(runOtherTests, 1000);
 }
 function runOtherTests() {
-  testDefaultHandling();
-
-  SimpleTest.finish();
+  testDefaultHandling(SimpleTest.finish);
 }
 
 window.onload = function() { setTimeout(runTests, 0); };
diff -r 17e9560465b0 content/html/Makefile.in
--- a/content/html/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/html/Makefile.in	Thu Oct 30 05:41:44 2008 -0400
@@ -42,6 +42,6 @@
 
 include $(DEPTH)/config/autoconf.mk
 
-DIRS		= content document
+PARALLEL_DIRS	= content document
 
 include $(topsrcdir)/config/rules.mk
diff -r 17e9560465b0 content/html/content/Makefile.in
--- a/content/html/content/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/html/content/Makefile.in	Thu Oct 30 05:41:44 2008 -0400
@@ -42,7 +42,7 @@
 
 include $(DEPTH)/config/autoconf.mk
 
-DIRS		= public src
+PARALLEL_DIRS	= public src
 
 ifdef ENABLE_TESTS
 DIRS		+= test
diff -r 17e9560465b0 content/html/content/public/nsHTMLAudioElement.h
--- a/content/html/content/public/nsHTMLAudioElement.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/html/content/public/nsHTMLAudioElement.h	Thu Oct 30 05:41:44 2008 -0400
@@ -72,6 +72,4 @@
                               PRBool aCompileEventHandlers);
   virtual void UnbindFromTree(PRBool aDeep = PR_TRUE,
                               PRBool aNullParent = PR_TRUE);
-protected:
-  virtual nsresult InitializeDecoder(nsAString& aChosenMediaResource);
 };
diff -r 17e9560465b0 content/html/content/public/nsHTMLMediaElement.h
--- a/content/html/content/public/nsHTMLMediaElement.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/html/content/public/nsHTMLMediaElement.h	Thu Oct 30 05:41:44 2008 -0400
@@ -38,6 +38,7 @@
 #include "nsIDOMHTMLMediaElement.h"
 #include "nsGenericHTMLElement.h"
 #include "nsMediaDecoder.h"
+#include "nsIChannel.h"
 
 // Define to output information on decoding and painting framerate
 /* #define DEBUG_FRAME_RATE 1 */
@@ -50,6 +51,16 @@
 public:
   nsHTMLMediaElement(nsINodeInfo *aNodeInfo, PRBool aFromParser = PR_FALSE);
   virtual ~nsHTMLMediaElement();
+
+  /**
+   * This is used when the browser is constructing a video element to play
+   * a channel that we've already started loading. The src attribute and
+   * <source> children are ignored. 
+   * @param aChannel the channel to use
+   * @param aListener returns a stream listener that should receive
+   * notifications for the stream
+   */ 
+  nsresult LoadWithChannel(nsIChannel *aChannel, nsIStreamListener **aListener);
 
   // nsIDOMHTMLMediaElement
   NS_DECL_NSIDOMHTMLMEDIAELEMENT
@@ -142,9 +153,45 @@
   // main thread when/if the size changes.
   void UpdateMediaSize(nsIntSize size);
 
+  // Handle moving into and out of the bfcache by pausing and playing
+  // as needed.
+  void Freeze();
+  void Thaw();
+
+  // Returns true if we can handle this MIME type in a <video> or <audio>
+  // element
+  static PRBool CanHandleMediaType(const char* aMIMEType);
+
+  /**
+   * Initialize data for available media types
+   */
+  static void InitMediaTypes();
+  /**
+   * Shutdown data for available media types
+   */
+  static void ShutdownMediaTypes();
+
 protected:
-  nsresult PickMediaElement(nsAString& aChosenMediaResource);
-  virtual nsresult InitializeDecoder(nsAString& aChosenMediaResource);
+  /**
+   * Figure out which resource to load (either the 'src' attribute or
+   * a <source> child) and create the decoder for it.
+   */
+  nsresult PickMediaElement();
+  /**
+   * Create a decoder for the given aMIMEType. Returns false if we
+   * were unable to create the decoder.
+   */
+  PRBool CreateDecoder(const nsACString& aMIMEType);
+  /**
+   * Initialize a decoder to load the given URI.
+   */
+  nsresult InitializeDecoder(const nsAString& aURISpec);
+  /**
+   * Initialize a decoder to load the given channel. The decoder's stream
+   * listener is returned via aListener.
+   */
+  nsresult InitializeDecoderForChannel(nsIChannel *aChannel,
+                                       nsIStreamListener **aListener);
 
   nsRefPtr<nsMediaDecoder> mDecoder;
 
@@ -213,4 +260,9 @@
   // or was not actively playing before the current seek. Used to decide whether
   // to raise the 'waiting' event as per 4.7.1.8 in HTML 5 specification.
   PRPackedBool mPlayingBeforeSeek;
+
+  // PR_TRUE if the video was paused before Freeze was called. This is checked
+  // to ensure that the playstate doesn't change when the user goes Forward/Back
+  // from the bfcache.
+  PRPackedBool mPausedBeforeFreeze;
 };
diff -r 17e9560465b0 content/html/content/public/nsHTMLVideoElement.h
--- a/content/html/content/public/nsHTMLVideoElement.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/html/content/public/nsHTMLVideoElement.h	Thu Oct 30 05:41:44 2008 -0400
@@ -73,8 +73,4 @@
   // Returns the current video frame width and height.
   // If there is no video frame, returns the given default size.
   nsIntSize GetVideoSize(nsIntSize defaultSize);
-
-protected:
-  virtual nsresult InitializeDecoder(nsAString& aChosenMediaResource);
-
 };
diff -r 17e9560465b0 content/html/content/src/nsGenericHTMLElement.cpp
--- a/content/html/content/src/nsGenericHTMLElement.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/html/content/src/nsGenericHTMLElement.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -1178,13 +1178,17 @@
 nsGenericHTMLElement::UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aAttribute,
                                 PRBool aNotify)
 {
+  PRBool contentEditable = PR_FALSE;
+  PRInt32 contentEditableChange;
+
+  if (aNameSpaceID == kNameSpaceID_None) {
+    contentEditable = PR_TRUE;
+    contentEditableChange = GetContentEditableValue() == eTrue ? -1 : 0;
+  }
+
   // Check for event handlers
   if (aNameSpaceID == kNameSpaceID_None) {
-    if (aAttribute == nsGkAtoms::contenteditable) {
-      ChangeEditableState(GetContentEditableValue() == eTrue ? -1 : 0);
-    }
-    else if (nsContentUtils::IsEventAttributeName(aAttribute,
-                                                  EventNameType_HTML)) {
+    if (nsContentUtils::IsEventAttributeName(aAttribute, EventNameType_HTML)) {
       nsCOMPtr<nsIEventListenerManager> manager;
       GetListenerManager(PR_FALSE, getter_AddRefs(manager));
 
@@ -1194,8 +1198,15 @@
     }
   }
 
-  return nsGenericHTMLElementBase::UnsetAttr(aNameSpaceID, aAttribute,
-                                             aNotify);
+  nsresult rv = nsGenericHTMLElementBase::UnsetAttr(aNameSpaceID, aAttribute,
+                                                    aNotify);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  if (contentEditable) {
+    ChangeEditableState(contentEditableChange);
+  }
+
+  return NS_OK;
 }
 
 already_AddRefed<nsIURI>
diff -r 17e9560465b0 content/html/content/src/nsHTMLAudioElement.cpp
--- a/content/html/content/src/nsHTMLAudioElement.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/html/content/src/nsHTMLAudioElement.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -110,11 +110,3 @@
 
   nsHTMLMediaElement::UnbindFromTree(aDeep, aNullParent);
 }
-
-nsresult nsHTMLAudioElement::InitializeDecoder(nsAString& aChosenMediaResource)
-{
-  if (mDecoder) 
-    mDecoder->ElementAvailable(this);
-
-  return nsHTMLMediaElement::InitializeDecoder(aChosenMediaResource);
-}
diff -r 17e9560465b0 content/html/content/src/nsHTMLInputElement.cpp
--- a/content/html/content/src/nsHTMLInputElement.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/html/content/src/nsHTMLInputElement.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -64,6 +64,7 @@
 #include "nsIDocument.h"
 #include "nsIPresShell.h"
 #include "nsIFormControlFrame.h"
+#include "nsITextControlFrame.h"
 #include "nsIFrame.h"
 #include "nsIEventStateManager.h"
 #include "nsIServiceManager.h"
@@ -2255,11 +2256,11 @@
   nsIFormControlFrame* formControlFrame = GetFormControlFrame(PR_TRUE);
 
   if (formControlFrame) {
-    nsCOMPtr<nsIPhonetic>
-      phonetic(do_QueryInterface(formControlFrame));
+    nsITextControlFrame* textControlFrame = nsnull;
+    CallQueryInterface(formControlFrame, &textControlFrame);
 
-    if (phonetic)
-      phonetic->GetPhonetic(aPhonetic);
+    if (textControlFrame)
+      textControlFrame->GetPhonetic(aPhonetic);
   }
 
   return NS_OK;
diff -r 17e9560465b0 content/html/content/src/nsHTMLMediaElement.cpp
--- a/content/html/content/src/nsHTMLMediaElement.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/html/content/src/nsHTMLMediaElement.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -67,6 +67,7 @@
 #include "nsIDOMDocumentEvent.h"
 #include "nsIDOMProgressEvent.h"
 #include "nsHTMLMediaError.h"
+#include "nsICategoryManager.h"
 
 #ifdef MOZ_OGG
 #include "nsOggDecoder.h"
@@ -220,6 +221,19 @@
 /* void load (); */
 NS_IMETHODIMP nsHTMLMediaElement::Load()
 {
+  return LoadWithChannel(nsnull, nsnull);
+}
+
+nsresult nsHTMLMediaElement::LoadWithChannel(nsIChannel *aChannel,
+                                             nsIStreamListener **aListener)
+{
+  NS_ASSERTION((aChannel == nsnull) == (aListener == nsnull),
+               "channel and listener should both be null or both non-null");
+
+  if (aListener) {
+    *aListener = nsnull;
+  }
+
   if (mBegun) {
     mBegun = PR_FALSE;
     
@@ -245,14 +259,12 @@
     DispatchSimpleEvent(NS_LITERAL_STRING("emptied"));
   }
 
-  nsAutoString chosenMediaResource;
-  nsresult rv = PickMediaElement(chosenMediaResource);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  mNetworkState = nsIDOMHTMLMediaElement::LOADING;
-  
-  // This causes the currentSrc attribute to become valid
-  rv = InitializeDecoder(chosenMediaResource);
+  nsresult rv;
+  if (aChannel) {
+    rv = InitializeDecoderForChannel(aChannel, aListener);
+  } else {
+    rv = PickMediaElement();
+  }
   NS_ENSURE_SUCCESS(rv, rv);
 
   mBegun = PR_TRUE;
@@ -312,8 +324,8 @@
   return NS_OK;
 }
 
-/* readonly attribute unsigned short paused; */
-NS_IMETHODIMP nsHTMLMediaElement::GetPaused(PRUint16 *aPaused)
+/* readonly attribute boolean paused; */
+NS_IMETHODIMP nsHTMLMediaElement::GetPaused(PRBool *aPaused)
 {
   *aPaused = mPaused;
 
@@ -564,7 +576,8 @@
                                                  aCompileEventHandlers);
   NS_ENSURE_SUCCESS(rv, rv);
 
-  if (mIsDoneAddingChildren && mNetworkState == nsIDOMHTMLMediaElement::EMPTY) {
+  if (mIsDoneAddingChildren &&
+      mNetworkState == nsIDOMHTMLMediaElement::EMPTY) {
     Load();
   }
 
@@ -580,16 +593,98 @@
   nsGenericHTMLElement::UnbindFromTree(aDeep, aNullParent);
 }
 
+#ifdef MOZ_OGG
+static const char gOggTypes[][16] = {
+  "video/ogg",
+  "audio/ogg",
+  "application/ogg"
+};
 
-nsresult nsHTMLMediaElement::PickMediaElement(nsAString& aChosenMediaResource)
+static PRBool IsOggType(const nsACString& aType)
+{
+  for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(gOggTypes); ++i) {
+    if (aType.EqualsASCII(gOggTypes[i]))
+      return PR_TRUE;
+  }
+  return PR_FALSE;
+}
+#endif
+
+/* static */
+PRBool nsHTMLMediaElement::CanHandleMediaType(const char* aMIMEType)
+{
+#ifdef MOZ_OGG
+  if (IsOggType(nsDependentCString(aMIMEType)))
+    return PR_TRUE;
+#endif
+  return PR_FALSE;
+}
+
+/* static */
+void nsHTMLMediaElement::InitMediaTypes()
+{
+  nsresult rv;
+  nsCOMPtr<nsICategoryManager> catMan(do_GetService(NS_CATEGORYMANAGER_CONTRACTID, &rv));
+  if (NS_SUCCEEDED(rv)) {
+#ifdef MOZ_OGG
+    for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(gOggTypes); i++) {
+      catMan->AddCategoryEntry("Gecko-Content-Viewers", gOggTypes[i],
+                               "@mozilla.org/content/document-loader-factory;1",
+                               PR_FALSE, PR_TRUE, nsnull);
+    }
+#endif
+  }
+}
+
+/* static */
+void nsHTMLMediaElement::ShutdownMediaTypes()
+{
+  nsresult rv;
+  nsCOMPtr<nsICategoryManager> catMan(do_GetService(NS_CATEGORYMANAGER_CONTRACTID, &rv));
+  if (NS_SUCCEEDED(rv)) {
+#ifdef MOZ_OGG
+    for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(gOggTypes); i++) {
+      catMan->DeleteCategoryEntry("Gecko-Content-Viewers", gOggTypes[i], PR_FALSE);
+    }
+#endif
+  }
+}
+
+PRBool nsHTMLMediaElement::CreateDecoder(const nsACString& aType)
+{
+#ifdef MOZ_OGG
+  if (IsOggType(aType)) {
+    mDecoder = new nsOggDecoder();
+    if (mDecoder && !mDecoder->Init()) {
+      mDecoder = nsnull;
+    }
+  }
+#endif
+  return mDecoder != nsnull;
+}
+
+nsresult nsHTMLMediaElement::InitializeDecoderForChannel(nsIChannel *aChannel,
+                                                         nsIStreamListener **aListener)
+{
+  nsCAutoString mimeType;
+  aChannel->GetContentType(mimeType);
+
+  if (!CreateDecoder(mimeType))
+    return NS_ERROR_FAILURE;
+
+  mNetworkState = nsIDOMHTMLMediaElement::LOADING;
+  mDecoder->ElementAvailable(this);
+  
+  return mDecoder->Load(nsnull, aChannel, aListener);
+}
+
+nsresult nsHTMLMediaElement::PickMediaElement()
 {
   // Implements:
   // http://www.whatwg.org/specs/web-apps/current-work/#pick-a
   nsAutoString src;
   if (HasAttr(kNameSpaceID_None, nsGkAtoms::src)) {
     if (GetAttr(kNameSpaceID_None, nsGkAtoms::src, src)) {
-      aChosenMediaResource = src;
-
 #ifdef MOZ_OGG
       // Currently assuming an Ogg file
       // TODO: Instantiate decoder based on type
@@ -604,7 +699,7 @@
         mDecoder = nsnull;
       }
 #endif
-      return NS_OK;
+      return InitializeDecoder(src);
     }
   }
 
@@ -619,31 +714,22 @@
     if (source) {
       if (source->HasAttr(kNameSpaceID_None, nsGkAtoms::src)) {
         nsAutoString type;
-
-        if (source->GetAttr(kNameSpaceID_None, nsGkAtoms::type, type)) {
-#if MOZ_OGG
-          if (type.EqualsLiteral("video/ogg") || type.EqualsLiteral("application/ogg")) {
-            nsAutoString src;
-            if (source->GetAttr(kNameSpaceID_None, nsGkAtoms::src, src)) {
-              mDecoder = new nsOggDecoder();
-              if (mDecoder && !mDecoder->Init()) {
-                mDecoder = nsnull;
-              }
-              aChosenMediaResource = src;
-              return NS_OK;
-            }
-          }
-#endif
-        }
+        nsAutoString src;
+        if (source->GetAttr(kNameSpaceID_None, nsGkAtoms::type, type) &&
+            source->GetAttr(kNameSpaceID_None, nsGkAtoms::src, src) &&
+            CreateDecoder(NS_ConvertUTF16toUTF8(type)))
+          return InitializeDecoder(src);
       }
-    }    
-  }        
+    }
+  }
 
   return NS_ERROR_DOM_INVALID_STATE_ERR;
 }
 
-nsresult nsHTMLMediaElement::InitializeDecoder(nsAString& aChosenMediaResource)
+nsresult nsHTMLMediaElement::InitializeDecoder(const nsAString& aURISpec)
 {
+  mNetworkState = nsIDOMHTMLMediaElement::LOADING;
+
   nsCOMPtr<nsIDocument> doc = GetOwnerDoc();
   if (!doc) {
     return NS_ERROR_DOM_INVALID_STATE_ERR;
@@ -653,15 +739,15 @@
   nsCOMPtr<nsIURI> uri;
   nsCOMPtr<nsIURI> baseURL = GetBaseURI();
   const nsAFlatCString &charset = doc->GetDocumentCharacterSet();
-  rv = NS_NewURI(getter_AddRefs(uri), 
-                 aChosenMediaResource, 
+  rv = NS_NewURI(getter_AddRefs(uri), aURISpec,
                  charset.IsEmpty() ? nsnull : charset.get(), 
                  baseURL, 
                  nsContentUtils::GetIOService());
   NS_ENSURE_SUCCESS(rv, rv);
 
   if (mDecoder) {
-    rv = mDecoder->Load(uri);
+    mDecoder->ElementAvailable(this);
+    rv = mDecoder->Load(uri, nsnull, nsnull);
     if (NS_FAILED(rv)) {
       mDecoder = nsnull;
     }
@@ -887,3 +973,18 @@
   }
   nsGenericHTMLElement::DestroyContent();
 }
+
+void nsHTMLMediaElement::Freeze()
+{
+  mPausedBeforeFreeze = mPaused;
+  if (!mPaused) {
+    Pause();
+  }
+}
+
+void nsHTMLMediaElement::Thaw()
+{
+  if (!mPausedBeforeFreeze) {
+    Play();
+  }
+}
diff -r 17e9560465b0 content/html/content/src/nsHTMLTableElement.cpp
--- a/content/html/content/src/nsHTMLTableElement.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/html/content/src/nsHTMLTableElement.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -154,7 +154,8 @@
 NS_IMPL_CYCLE_COLLECTING_RELEASE(TableRowsCollection)
 
 NS_INTERFACE_TABLE_HEAD(TableRowsCollection)
-  NS_INTERFACE_TABLE1(TableRowsCollection, nsIDOMHTMLCollection)
+  NS_INTERFACE_TABLE2(TableRowsCollection, nsIHTMLCollection,
+                      nsIDOMHTMLCollection)
   NS_INTERFACE_TABLE_TO_MAP_SEGUE_CYCLE_COLLECTION(TableRowsCollection)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(HTMLGenericCollection)
 NS_INTERFACE_MAP_END
diff -r 17e9560465b0 content/html/content/src/nsHTMLVideoElement.cpp
--- a/content/html/content/src/nsHTMLVideoElement.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/html/content/src/nsHTMLVideoElement.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -134,12 +134,3 @@
   if (mDecoder) 
     mDecoder->ElementUnavailable();
 }
-
-nsresult nsHTMLVideoElement::InitializeDecoder(nsAString& aChosenMediaResource)
-{
-  if (mDecoder) 
-    mDecoder->ElementAvailable(this);
-
-  return nsHTMLMediaElement::InitializeDecoder(aChosenMediaResource);
-}
-
diff -r 17e9560465b0 content/html/content/test/Makefile.in
--- a/content/html/content/test/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/html/content/test/Makefile.in	Thu Oct 30 05:41:44 2008 -0400
@@ -122,6 +122,7 @@
 		test_bug441930.html \
 		test_bug442801.html \
 		test_bug448166.html \
+		test_bug460568.html \
 		$(NULL)
 
 libs:: $(_TEST_FILES)
diff -r 17e9560465b0 content/html/content/test/test_bug460568.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/html/content/test/test_bug460568.html	Thu Oct 30 05:41:44 2008 -0400
@@ -0,0 +1,77 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=460568
+-->
+<head>
+  <title>Test for Bug 460568</title>
+  <script type="text/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>        
+  <script type="text/javascript" src="/tests/SimpleTest/EventUtils.js"></script>        
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=460568">Mozilla Bug 460568</a>
+<p id="display"><a href="" id="anchor">a[href]</a></p>
+<div id="editor">
+  <a href="" id="anchorInEditor">a[href] in editor</a>
+</div>
+<pre id="test">
+<script class="testbody" type="text/javascript">
+
+/** Test for Bug 460568 **/
+
+function runTest()
+{
+  var editor = document.getElementById("editor");
+  var anchor = document.getElementById("anchor");
+  var anchorInEditor = document.getElementById("anchorInEditor");
+
+  var focused;
+  anchorInEditor.onfocus = function() { focused = true; };
+
+  focused = false;
+  anchor.focus();
+  editor.setAttribute("contenteditable", "true");
+  anchorInEditor.focus();
+  is(focused, false, "focus moved to element in contenteditable=true");
+
+  focused = false;
+  anchor.focus();
+  editor.setAttribute("contenteditable", "false");
+  anchorInEditor.focus();
+  is(focused, true, "focus didn't move to element in contenteditable=false");
+
+  focused = false;
+  anchor.focus();
+  editor.setAttribute("contenteditable", "true");
+  anchorInEditor.focus();
+  is(focused, false, "focus moved to element in contenteditable=true");
+
+  focused = false;
+  anchor.focus();
+  editor.removeAttribute("contenteditable");
+  anchorInEditor.focus();
+  is(focused, true, "focus didn't move to element in contenteditable removed element");
+
+  focused = false;
+  anchor.focus();
+  editor.contentEditable = true;
+  anchorInEditor.focus();
+  is(focused, false, "focus moved to element in contenteditable=true by property");
+
+  focused = false;
+  anchor.focus();
+  editor.contentEditable = false;
+  anchorInEditor.focus();
+  is(focused, true, "focus didn't move to element in contenteditable=false by property");
+}
+
+SimpleTest.waitForExplicitFinish();
+addLoadEvent(runTest);
+addLoadEvent(SimpleTest.finish);
+
+</script>
+</pre>
+</body>
+</html>
diff -r 17e9560465b0 content/html/document/Makefile.in
--- a/content/html/document/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/html/document/Makefile.in	Thu Oct 30 05:41:44 2008 -0400
@@ -42,7 +42,7 @@
 
 include $(DEPTH)/config/autoconf.mk
 
-DIRS		= public src
+PARALLEL_DIRS	= public src
 
 ifdef ENABLE_TESTS
 DIRS		+= test
diff -r 17e9560465b0 content/html/document/src/Makefile.in
--- a/content/html/document/src/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/html/document/src/Makefile.in	Thu Oct 30 05:41:44 2008 -0400
@@ -81,12 +81,16 @@
 		nsHTMLContentSink.cpp \
 		nsHTMLFragmentContentSink.cpp \
 		nsHTMLDocument.cpp \
+		nsImageDocument.cpp \
 		nsMediaDocument.cpp \
 		nsPluginDocument.cpp \
-		nsImageDocument.cpp \
 		nsWyciwygChannel.cpp \
 		nsWyciwygProtocolHandler.cpp \
 		$(NULL)
+
+ifdef MOZ_MEDIA
+CPPSRCS += nsVideoDocument.cpp
+endif
 
 EXPORTS		= \
 		nsIHTMLDocument.h \
diff -r 17e9560465b0 content/html/document/src/nsHTMLDocument.cpp
--- a/content/html/document/src/nsHTMLDocument.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/html/document/src/nsHTMLDocument.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -3794,7 +3794,7 @@
   *_retval = PR_FALSE;
 
   // if editing is not on, bail
-  if (!IsEditingOn())
+  if (!IsEditingOnAfterFlush())
     return NS_ERROR_FAILURE;
 
   // if they are requesting UI from us, let's fail since we have no UI
@@ -3869,7 +3869,7 @@
   *_retval = PR_FALSE;
 
   // if editing is not on, bail
-  if (!IsEditingOn())
+  if (!IsEditingOnAfterFlush())
     return NS_ERROR_FAILURE;
 
   return NS_ERROR_NOT_IMPLEMENTED;
@@ -3884,7 +3884,7 @@
   *_retval = PR_FALSE;
 
   // if editing is not on, bail
-  if (!IsEditingOn())
+  if (!IsEditingOnAfterFlush())
     return NS_ERROR_FAILURE;
 
   // get command manager and dispatch command to our window if it's acceptable
@@ -3913,7 +3913,7 @@
   *_retval = PR_FALSE;
 
   // if editing is not on, bail
-  if (!IsEditingOn())
+  if (!IsEditingOnAfterFlush())
     return NS_ERROR_FAILURE;
 
   // get command manager and dispatch command to our window if it's acceptable
@@ -3955,7 +3955,7 @@
   *_retval = PR_FALSE;
 
   // if editing is not on, bail
-  if (!IsEditingOn())
+  if (!IsEditingOnAfterFlush())
     return NS_ERROR_FAILURE;
 
   // get command manager and dispatch command to our window if it's acceptable
@@ -4017,7 +4017,7 @@
   *_retval = PR_FALSE;
 
   // if editing is not on, bail
-  if (!IsEditingOn())
+  if (!IsEditingOnAfterFlush())
     return NS_ERROR_FAILURE;
 
   return NS_ERROR_NOT_IMPLEMENTED;
@@ -4031,7 +4031,7 @@
   _retval.SetLength(0);
 
   // if editing is not on, bail
-  if (!IsEditingOn())
+  if (!IsEditingOnAfterFlush())
     return NS_ERROR_FAILURE;
 
   return NS_ERROR_NOT_IMPLEMENTED;
@@ -4045,7 +4045,7 @@
   _retval.SetLength(0);
 
   // if editing is not on, bail
-  if (!IsEditingOn())
+  if (!IsEditingOnAfterFlush())
     return NS_ERROR_FAILURE;
 
   // get command manager and dispatch command to our window if it's acceptable
@@ -4139,3 +4139,16 @@
 
   return CallQueryInterface(clone.get(), aResult);
 }
+
+PRBool
+nsHTMLDocument::IsEditingOnAfterFlush()
+{
+  nsIDocument* doc = GetParentDocument();
+  if (doc) {
+    // Make sure frames are up to date, since that can affect whether
+    // we're editable.
+    doc->FlushPendingNotifications(Flush_Frames);
+  }
+
+  return IsEditingOn();
+}
diff -r 17e9560465b0 content/html/document/src/nsHTMLDocument.h
--- a/content/html/document/src/nsHTMLDocument.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/html/document/src/nsHTMLDocument.h	Thu Oct 30 05:41:44 2008 -0400
@@ -262,6 +262,11 @@
   nsresult CreateAndAddWyciwygChannel(void);
   nsresult RemoveWyciwygChannel(void);
 
+  /**
+   * Like IsEditingOn(), but will flush as needed first.
+   */
+  PRBool IsEditingOnAfterFlush();
+
   void *GenerateParserKey(void);
 
   virtual PRInt32 GetDefaultNamespaceID() const
diff -r 17e9560465b0 content/html/document/src/nsImageDocument.cpp
--- a/content/html/document/src/nsImageDocument.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/html/document/src/nsImageDocument.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -120,7 +120,7 @@
 
   friend class ImageListener;
 protected:
-  nsresult CreateSyntheticDocument();
+  virtual nsresult CreateSyntheticDocument();
 
   nsresult CheckOverflowing(PRBool changeState);
 
diff -r 17e9560465b0 content/html/document/src/nsMediaDocument.h
--- a/content/html/document/src/nsMediaDocument.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/html/document/src/nsMediaDocument.h	Thu Oct 30 05:41:44 2008 -0400
@@ -105,7 +105,6 @@
 
   NS_DECL_NSISTREAMLISTENER
 
-protected:
   nsRefPtr<nsMediaDocument>    mDocument;
   nsCOMPtr<nsIStreamListener>  mNextStream;
 };
diff -r 17e9560465b0 content/html/document/src/nsVideoDocument.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/html/document/src/nsVideoDocument.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -0,0 +1,140 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsMediaDocument.h"
+#include "nsGkAtoms.h"
+#include "nsNodeInfoManager.h"
+#include "nsContentCreatorFunctions.h"
+#include "nsHTMLMediaElement.h"
+
+class nsVideoDocument : public nsMediaDocument
+{
+public:
+  virtual nsresult StartDocumentLoad(const char*         aCommand,
+                                     nsIChannel*         aChannel,
+                                     nsILoadGroup*       aLoadGroup,
+                                     nsISupports*        aContainer,
+                                     nsIStreamListener** aDocListener,
+                                     PRBool              aReset = PR_TRUE,
+                                     nsIContentSink*     aSink = nsnull);
+
+protected:
+  nsresult CreateSyntheticVideoDocument(nsIChannel* aChannel,
+                                        nsIStreamListener** aListener);
+
+  nsRefPtr<nsMediaDocumentStreamListener> mStreamListener;
+};
+
+nsresult
+nsVideoDocument::StartDocumentLoad(const char*         aCommand,
+                                   nsIChannel*         aChannel,
+                                   nsILoadGroup*       aLoadGroup,
+                                   nsISupports*        aContainer,
+                                   nsIStreamListener** aDocListener,
+                                   PRBool              aReset,
+                                   nsIContentSink*     aSink)
+{
+  nsresult rv =
+    nsMediaDocument::StartDocumentLoad(aCommand, aChannel, aLoadGroup,
+                                       aContainer, aDocListener, aReset,
+                                       aSink);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  mStreamListener = new nsMediaDocumentStreamListener(this);
+  if (!mStreamListener)
+    return NS_ERROR_OUT_OF_MEMORY;
+
+  // Create synthetic document
+  rv = CreateSyntheticVideoDocument(aChannel,
+      getter_AddRefs(mStreamListener->mNextStream));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  NS_ADDREF(*aDocListener = mStreamListener);
+  return rv;
+}
+
+nsresult
+nsVideoDocument::CreateSyntheticVideoDocument(nsIChannel* aChannel,
+                                              nsIStreamListener** aListener)
+{
+  // make our generic document
+  nsresult rv = nsMediaDocument::CreateSyntheticDocument();
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsIContent* body = GetBodyContent();
+  if (!body) {
+    NS_WARNING("no body on video document!");
+    return NS_ERROR_FAILURE;
+  }
+
+  // make content
+  nsCOMPtr<nsINodeInfo> nodeInfo;
+  nodeInfo = mNodeInfoManager->GetNodeInfo(nsGkAtoms::video, nsnull,
+                                           kNameSpaceID_None);
+  NS_ENSURE_TRUE(nodeInfo, NS_ERROR_FAILURE);
+
+  nsRefPtr<nsHTMLMediaElement> element =
+    static_cast<nsHTMLMediaElement*>(NS_NewHTMLVideoElement(nodeInfo, PR_FALSE));
+  if (!element)
+    return NS_ERROR_OUT_OF_MEMORY;
+
+  element->SetAutoplay(PR_TRUE);
+  element->SetControls(PR_TRUE);
+  element->LoadWithChannel(aChannel, aListener);
+
+  return body->AppendChildTo(element, PR_FALSE);
+}
+
+nsresult
+NS_NewVideoDocument(nsIDocument** aResult)
+{
+  nsVideoDocument* doc = new nsVideoDocument();
+  if (!doc) {
+    return NS_ERROR_OUT_OF_MEMORY;
+  }
+
+  NS_ADDREF(doc);
+  nsresult rv = doc->Init();
+
+  if (NS_FAILED(rv)) {
+    NS_RELEASE(doc);
+  }
+
+  *aResult = doc;
+
+  return rv;
+}
diff -r 17e9560465b0 content/media/video/Makefile.in
--- a/content/media/video/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/media/video/Makefile.in	Thu Oct 30 05:41:44 2008 -0400
@@ -41,7 +41,7 @@
 
 include $(DEPTH)/config/autoconf.mk
 
-DIRS		= \
+PARALLEL_DIRS	= \
 		public \
 		src \
 		$(NULL)
diff -r 17e9560465b0 content/media/video/public/nsAudioStream.h
--- a/content/media/video/public/nsAudioStream.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/media/video/public/nsAudioStream.h	Thu Oct 30 05:41:44 2008 -0400
@@ -45,7 +45,7 @@
  public:
   // Initialize Audio Library. Some Audio backends (eg. PortAudio) require initializing
   // library before using it. 
-  static nsresult InitLibrary();
+  static void InitLibrary();
 
   // Shutdown Audio Library. Some Audio backends (eg. PortAudio) require shutting down
   // the library after using it. 
@@ -56,50 +56,32 @@
   // Initialize the audio stream. aNumChannels is the number of audio channels 
   // (1 for mono, 2 for stereo, etc) and aRate is the frequency of the sound 
   // samples (22050, 44100, etc).
-  nsresult Init(PRInt32 aNumChannels, PRInt32 aRate);
+  void Init(PRInt32 aNumChannels, PRInt32 aRate);
 
   // Closes the stream. All future use of the stream is an error.
-  nsresult Shutdown();
-
-  // Pause sound playback. 
-  nsresult Pause();
-
-  // Resume playback of sound.
-  nsresult Resume();
+  void Shutdown();
 
   // Write sound data to the audio hardware. aBuf is an array of floats of
   // length aCount. aCount should be evenly divisible by the number of 
   // channels in this audio stream.
-  nsresult Write(float* aBuf, PRUint32 count);
+  void Write(float* aBuf, PRUint32 count);
 
   // Return the number of sound samples that can be written to the audio device
   // without blocking.
   PRInt32 Available();
 
-  // Store in aTime the position (in seconds) of the audio sample currently 
-  // being played by the audio hardware.
-  nsresult GetTime(double* aTime);
-
   // Store in aVolume the value of the volume setting. This is a value from
   // 0 (meaning muted) to 1 (meaning full volume).
-  nsresult GetVolume(float* aVolume);
+  float GetVolume();
 
   // Set the current volume of the audio playback. This is a value from
   // 0 (meaning muted) to 1 (meaning full volume).
-  nsresult SetVolume(float aVolume);
+  void SetVolume(float aVolume);
 
  private:
   double mVolume;
-#if defined(SYDNEY_AUDIO_NO_POSITION)
-  // The time, in seconds, that playback was last paused.
-  double mPauseTime;
-#else
-  // The byte position in the audio buffer where playback
-  // was last paused.
-  PRInt64 mPauseBytes;
-#endif
   void* mAudioHandle;
   int mRate;
   int mChannels;
-  PRBool mPaused;
+  PRPackedBool mMute;
 };
diff -r 17e9560465b0 content/media/video/public/nsChannelReader.h
--- a/content/media/video/public/nsChannelReader.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/media/video/public/nsChannelReader.h	Thu Oct 30 05:41:44 2008 -0400
@@ -44,14 +44,24 @@
 
 #include "oggplay/oggplay.h"
 
+class nsIChannel;
+class nsIStreamListener;
+
 class nsChannelReader : public OggPlayReader
 {
 public:
   nsChannelReader();
   ~nsChannelReader();
 
-  // Initialize the reader with the given decoder and URI.
-  nsresult Init(nsMediaDecoder* aDecoder, nsIURI* aURI);
+  /**
+   * Initialize the reader with the given decoder, URI, and
+   * optional channel.
+   * @param aChannel may be null
+   * @param aStreamListener if aChannel is non-null, this will return
+   * a stream listener which should be attached to the channel.
+   */
+  nsresult Init(nsMediaDecoder* aDecoder, nsIURI* aURI, nsIChannel* aChannel,
+                nsIStreamListener** aStreamListener);
 
   // Cancel any blocking request currently in progress and cause that
   // request to return an error. Call on main thread only.
diff -r 17e9560465b0 content/media/video/public/nsMediaDecoder.h
--- a/content/media/video/public/nsMediaDecoder.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/media/video/public/nsMediaDecoder.h	Thu Oct 30 05:41:44 2008 -0400
@@ -109,10 +109,13 @@
   // Stop playback of a video, and stop download of video stream.
   virtual void Stop() = 0;
 
-  // Start downloading the video at the given URI. Decode
-  // the downloaded data up to the point of the first frame
-  // of data. 
-  virtual nsresult Load(nsIURI* aURI) = 0;
+  // Start downloading the video. Decode the downloaded data up to the
+  // point of the first frame of data.
+  // Exactly one of aURI and aChannel must be null. aListener must be
+  // null if and only if aChannel is.
+  virtual nsresult Load(nsIURI* aURI,
+                        nsIChannel* aChannel,
+                        nsIStreamListener **aListener) = 0;
 
   // Draw the latest video data. This is done
   // here instead of in nsVideoFrame so that the lock around the
diff -r 17e9560465b0 content/media/video/public/nsMediaStream.h
--- a/content/media/video/public/nsMediaStream.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/media/video/public/nsMediaStream.h	Thu Oct 30 05:41:44 2008 -0400
@@ -70,7 +70,14 @@
 
   // These methods have the same thread calling requirements 
   // as those with the same name in nsMediaStream
-  virtual nsresult Open() = 0;
+
+  /**
+   * @param aStreamListener if null, the strategy should open mChannel
+   * itself. Otherwise, mChannel is already open and the strategy
+   * should just return its stream listener in aStreamListener (or set
+   * *aStreamListener to null, if it doesn't need a listener).
+   */
+  virtual nsresult Open(nsIStreamListener** aStreamListener) = 0;
   virtual nsresult Close() = 0;
   virtual nsresult Read(char* aBuffer, PRUint32 aCount, PRUint32* aBytes) = 0;
   virtual nsresult Seek(PRInt32 aWhence, PRInt64 aOffset) = 0;
@@ -121,9 +128,15 @@
   nsMediaStream();
   ~nsMediaStream();
 
-  // Create a channel for the stream, reading data from the 
-  // media resource at the URI. Call on main thread only.
-  nsresult Open(nsMediaDecoder *aDecoder, nsIURI* aURI);
+  /**
+   * Create a channel for the stream, reading data from the 
+   * media resource at the URI. Call on main thread only.
+   * @param aChannel if non-null, this channel is used and aListener
+   * is set to the listener we want for the channel. aURI must
+   * be the URI for the channel, obtained via NS_GetFinalChannelURI.
+   */
+  nsresult Open(nsMediaDecoder* aDecoder, nsIURI* aURI,
+                nsIChannel* aChannel, nsIStreamListener** aListener);
 
   // Close the stream, stop any listeners, channels, etc.
   // Call on main thread only.
diff -r 17e9560465b0 content/media/video/public/nsOggDecoder.h
--- a/content/media/video/public/nsOggDecoder.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/media/video/public/nsOggDecoder.h	Thu Oct 30 05:41:44 2008 -0400
@@ -297,34 +297,33 @@
 
   // This method must be called by the owning object before that
   // object disposes of this decoder object.
-  void Shutdown();
+  virtual void Shutdown();
   
-  float GetCurrentTime();
+  virtual float GetCurrentTime();
 
-  // Start downloading the video at the given URI. Decode
-  // the downloaded data up to the point of the first frame
-  // of data. 
-  nsresult Load(nsIURI* aURI);
+  virtual nsresult Load(nsIURI* aURI,
+                        nsIChannel* aChannel,
+                        nsIStreamListener **aListener);
 
   // Start playback of a video. 'Load' must have previously been
   // called.
-  nsresult Play();
+  virtual nsresult Play();
 
   // Stop playback of a video, and stop download of video stream.
   virtual void Stop();
 
   // Seek to the time position in (seconds) from the start of the video.
-  nsresult Seek(float time);
+  virtual nsresult Seek(float time);
 
-  nsresult PlaybackRateChanged();
+  virtual nsresult PlaybackRateChanged();
 
-  void Pause();
-  float GetVolume();
-  void SetVolume(float volume);
-  float GetDuration();
+  virtual void Pause();
+  virtual float GetVolume();
+  virtual void SetVolume(float volume);
+  virtual float GetDuration();
 
-  void GetCurrentURI(nsIURI** aURI);
-  nsIPrincipal* GetCurrentPrincipal();
+  virtual void GetCurrentURI(nsIURI** aURI);
+  virtual nsIPrincipal* GetCurrentPrincipal();
 
   virtual void UpdateBytesDownloaded(PRUint64 aBytes);
 
diff -r 17e9560465b0 content/media/video/src/Makefile.in
--- a/content/media/video/src/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/media/video/src/Makefile.in	Thu Oct 30 05:41:44 2008 -0400
@@ -40,12 +40,6 @@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
-
-ifdef MOZ_OGG
-ifneq (,$(filter WINNT WINCE,$(OS_ARCH)))
-DEFINES += -DSYDNEY_AUDIO_NO_VOLUME -DSYDNEY_AUDIO_NO_POSITION
-endif
-endif
 
 MODULE		= content
 LIBRARY_NAME	= gkconvideo_s
diff -r 17e9560465b0 content/media/video/src/nsAudioStream.cpp
--- a/content/media/video/src/nsAudioStream.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/media/video/src/nsAudioStream.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -49,12 +49,11 @@
 PRLogModuleInfo* gAudioStreamLog = nsnull;
 #endif
 
-nsresult nsAudioStream::InitLibrary()
+void nsAudioStream::InitLibrary()
 {
 #ifdef PR_LOGGING
   gAudioStreamLog = PR_NewLogModule("nsAudioStream");
 #endif
-  return NS_OK;
 }
 
 void nsAudioStream::ShutdownLibrary()
@@ -63,19 +62,13 @@
 
 nsAudioStream::nsAudioStream() :
   mVolume(1.0),
-#if defined(SYDNEY_AUDIO_NO_POSITION)
-  mPauseTime(0.0),
-#else
-  mPauseBytes(0),
-#endif
   mAudioHandle(0),
   mRate(0),
-  mChannels(0),
-  mPaused(PR_FALSE)
+  mChannels(0)
 {
 }
 
-nsresult nsAudioStream::Init(PRInt32 aNumChannels, PRInt32 aRate)
+void nsAudioStream::Init(PRInt32 aNumChannels, PRInt32 aRate)
 {
   mRate = aRate;
   mChannels = aNumChannels;
@@ -87,96 +80,37 @@
                            aNumChannels) != SA_SUCCESS) {
     mAudioHandle = nsnull;
     PR_LOG(gAudioStreamLog, PR_LOG_ERROR, ("nsAudioStream: sa_stream_create_pcm error"));
-    return NS_OK;
+    return;
   }
   
   if (sa_stream_open(reinterpret_cast<sa_stream_t*>(mAudioHandle)) != SA_SUCCESS) {
     sa_stream_destroy((sa_stream_t*)mAudioHandle);
     mAudioHandle = nsnull;
     PR_LOG(gAudioStreamLog, PR_LOG_ERROR, ("nsAudioStream: sa_stream_open error"));
-    return NS_OK;
+    return;
   }
-
-#if defined(SYDNEY_AUDIO_NO_POSITION)
-    mPauseTime = double(PR_IntervalToMilliseconds(PR_IntervalNow()))/1000.0;
-#endif
-
-  return NS_OK;
 }
 
-nsresult nsAudioStream::Shutdown()
+void nsAudioStream::Shutdown()
 {
   if (!mAudioHandle) 
-    return NS_OK;
+    return;
 
   sa_stream_destroy(reinterpret_cast<sa_stream_t*>(mAudioHandle));
   mAudioHandle = nsnull;
-
-  return NS_OK;
 }
 
-nsresult nsAudioStream::Pause()
-{
-#if defined(USE_SYDNEY_AUDIO_OLD)
-  return NS_ERROR_NOT_IMPLEMENTED;
-#else
-  if (mPaused) 
-    return NS_OK;
-
-  mPaused = PR_TRUE;
-
-  if (!mAudioHandle) 
-    return NS_OK;
-
-#if defined(SYDNEY_AUDIO_NO_POSITION)
-  mPauseTime -= double(PR_IntervalToMilliseconds(PR_IntervalNow()))/1000.0;
-#else
-  // The audio hardware resets the count of the number of bytes
-  // when paused so we need to save it.
-  int64_t bytes = 0;
-  sa_stream_get_position(reinterpret_cast<sa_stream_t*>(mAudioHandle), SA_POSITION_WRITE_SOFTWARE, &bytes);
-  mPauseBytes += bytes;
-  sa_stream_pause(reinterpret_cast<sa_stream_t*>(mAudioHandle));
-#endif
-
-  return NS_OK;
-#endif
-}
-
-nsresult nsAudioStream::Resume()
-{
-#if defined(USE_SYDNEY_AUDIO_OLD)
-  return NS_ERROR_NOT_IMPLEMENTED;
-#else
-  if (!mPaused)
-    return NS_OK;
-
-  mPaused = PR_FALSE;
-
-  if (!mAudioHandle)
-    return NS_OK;
-
-  sa_stream_resume(reinterpret_cast<sa_stream_t*>(mAudioHandle));
-
-#if defined(SYDNEY_AUDIO_NO_POSITION)
-  mPauseTime += double(PR_IntervalToMilliseconds(PR_IntervalNow()))/1000.0;
-#endif
-
-  return NS_OK;
-#endif
-}
-
-nsresult nsAudioStream::Write(float* aBuf, PRUint32 aCount)
+void nsAudioStream::Write(float* aBuf, PRUint32 aCount)
 {
   if (!mAudioHandle)
-    return NS_OK;
+    return;
 
   // Convert array of floats, to an array of signed shorts
   nsAutoArrayPtr<short> s_data(new short[aCount]);
 
   if (s_data) {
     for (PRUint32 i=0; i <  aCount; ++i) {
-      float scaled_value = floorf(0.5 + 32768 * aBuf[i]);
+      float scaled_value = floorf(0.5 + 32768 * aBuf[i] * mVolume);
       if (aBuf[i] < 0.0) {
         s_data[i] = (scaled_value < -32768.0) ? 
           -32768 : 
@@ -189,19 +123,11 @@
       }
     }
     
-#if defined(SYDNEY_AUDIO_NO_VOLUME)
-    if (mVolume > 0.00001) {
-#endif
-      if (sa_stream_write(reinterpret_cast<sa_stream_t*>(mAudioHandle), s_data.get(), aCount * sizeof(short)) != SA_SUCCESS) {
-        PR_LOG(gAudioStreamLog, PR_LOG_ERROR, ("nsAudioStream: sa_stream_write error"));
-        Shutdown();
-      }     
-#if defined(SYDNEY_AUDIO_NO_VOLUME)
-    }
-#endif
+    if (sa_stream_write(reinterpret_cast<sa_stream_t*>(mAudioHandle), s_data.get(), aCount * sizeof(short)) != SA_SUCCESS) {
+      PR_LOG(gAudioStreamLog, PR_LOG_ERROR, ("nsAudioStream: sa_stream_write error"));
+      Shutdown();
+    }     
   }
-
-  return NS_OK;
 }
 
 PRInt32 nsAudioStream::Available()
@@ -214,55 +140,12 @@
   return s / sizeof(short);
 }
 
-nsresult nsAudioStream::GetTime(double *aTime)
+float nsAudioStream::GetVolume()
 {
-  if (!aTime)
-    return NS_OK;
-
-#if defined(SYDNEY_AUDIO_NO_POSITION)
-  *aTime = double(PR_IntervalToMilliseconds(PR_IntervalNow()))/1000.0 - mPauseTime;
-#else
-  int64_t bytes = 0;
-  if (mAudioHandle) {
-    sa_stream_get_position(reinterpret_cast<sa_stream_t*>(mAudioHandle), SA_POSITION_WRITE_SOFTWARE, &bytes);
-    *aTime = float(bytes + mPauseBytes) / (sizeof(short) * mChannels * mRate);
-  }
-  else {
-    return NS_ERROR_NOT_IMPLEMENTED;
-  }
-  
-#endif
-  return NS_OK;
+  return mVolume;
 }
 
-nsresult nsAudioStream::GetVolume(float *aVolume)
+void nsAudioStream::SetVolume(float aVolume)
 {
-  if (!aVolume)
-    return NS_OK;
-
-#if defined(SYDNEY_AUDIO_NO_VOLUME)
-  *aVolume = mVolume;
-#else
-  float volume = 0.0;
-  if (mAudioHandle) {
-    sa_stream_get_volume_abs(reinterpret_cast<sa_stream_t*>(mAudioHandle), &volume);
-  }
-    
-  *aVolume = volume;
-#endif
-
-  return NS_OK;
+  mVolume = aVolume;
 }
-
-nsresult nsAudioStream::SetVolume(float aVolume)
-{
-#if defined(SYDNEY_AUDIO_NO_VOLUME) 
-  mVolume = aVolume;
-#else
-  if (!mAudioHandle)
-    return NS_OK;
-
-  sa_stream_set_volume_abs(reinterpret_cast<sa_stream_t*>(mAudioHandle), aVolume);
-#endif
-  return NS_OK;
-}
diff -r 17e9560465b0 content/media/video/src/nsChannelReader.cpp
--- a/content/media/video/src/nsChannelReader.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/media/video/src/nsChannelReader.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -79,7 +79,7 @@
 {
   PRUint32 bytes = 0;
   nsresult rv = mStream.Read(aBuffer, aCount, &bytes);
-  if (!NS_SUCCEEDED(rv) || bytes == 0) {
+  if (!NS_SUCCEEDED(rv)) {
     return static_cast<size_t>(OGGZ_ERR_SYSTEM);
   }
   mCurrentPosition += bytes;
@@ -147,10 +147,12 @@
   return me->duration();
 }
 
-nsresult nsChannelReader::Init(nsMediaDecoder* aDecoder, nsIURI* aURI)
+nsresult nsChannelReader::Init(nsMediaDecoder* aDecoder, nsIURI* aURI,
+                               nsIChannel* aChannel,
+                               nsIStreamListener** aStreamListener)
 {
   mCurrentPosition = 0;
-  return mStream.Open(aDecoder, aURI);
+  return mStream.Open(aDecoder, aURI, aChannel, aStreamListener);
 }
 
 nsChannelReader::~nsChannelReader()
diff -r 17e9560465b0 content/media/video/src/nsMediaStream.cpp
--- a/content/media/video/src/nsMediaStream.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/media/video/src/nsMediaStream.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -67,7 +67,7 @@
   
   // These methods have the same thread calling requirements 
   // as those with the same name in nsMediaStream
-  virtual nsresult Open();
+  virtual nsresult Open(nsIStreamListener** aStreamListener);
   virtual nsresult Close();
   virtual nsresult Read(char* aBuffer, PRUint32 aCount, PRUint32* aBytes);
   virtual nsresult Seek(PRInt32 aWhence, PRInt64 aOffset);
@@ -89,19 +89,26 @@
   nsCOMPtr<nsIInputStream>  mPipeInput;
 };
 
-nsresult nsDefaultStreamStrategy::Open()
+nsresult nsDefaultStreamStrategy::Open(nsIStreamListener** aStreamListener)
 {
-  nsresult rv;
+  if (aStreamListener) {
+    *aStreamListener = nsnull;
+  }
 
   mListener = new nsChannelToPipeListener(mDecoder);
   NS_ENSURE_TRUE(mListener, NS_ERROR_OUT_OF_MEMORY);
 
-  rv = mListener->Init();
+  nsresult rv = mListener->Init();
   NS_ENSURE_SUCCESS(rv, rv);
-  
-  rv = mChannel->AsyncOpen(mListener, nsnull);
-  NS_ENSURE_SUCCESS(rv, rv);
-  
+
+  if (aStreamListener) {
+    *aStreamListener = mListener;
+    NS_ADDREF(mListener);
+  } else {
+    rv = mChannel->AsyncOpen(mListener, nsnull);
+    NS_ENSURE_SUCCESS(rv, rv);
+  }
+
   rv = mListener->GetInputStream(getter_AddRefs(mPipeInput));
   NS_ENSURE_SUCCESS(rv, rv);
 
@@ -189,7 +196,7 @@
   
   // These methods have the same thread calling requirements 
   // as those with the same name in nsMediaStream
-  virtual nsresult Open();
+  virtual nsresult Open(nsIStreamListener** aStreamListener);
   virtual nsresult Close();
   virtual nsresult Read(char* aBuffer, PRUint32 aCount, PRUint32* aBytes);
   virtual nsresult Seek(PRInt32 aWhence, PRInt64 aOffset);
@@ -211,35 +218,54 @@
   nsCOMPtr<nsIPrincipal> mPrincipal;
 };
 
-nsresult nsFileStreamStrategy::Open()
+nsresult nsFileStreamStrategy::Open(nsIStreamListener** aStreamListener)
 {
+  if (aStreamListener) {
+    *aStreamListener = nsnull;
+  }
+
   nsresult rv;
+  if (aStreamListener) {
+    // The channel is already open. We need a synchronous stream that
+    // implements nsISeekableStream, so we have to find the underlying
+    // file and reopen it
+    nsCOMPtr<nsIFileChannel> fc(do_QueryInterface(mChannel));
+    if (!fc)
+      return NS_ERROR_UNEXPECTED;
 
-  rv = mChannel->Open(getter_AddRefs(mInput));
+    nsCOMPtr<nsIFile> file; 
+    rv = fc->GetFile(getter_AddRefs(file));
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    rv = NS_NewLocalFileInputStream(getter_AddRefs(mInput), file);
+  } else {
+    rv = mChannel->Open(getter_AddRefs(mInput));
+  }
   NS_ENSURE_SUCCESS(rv, rv);
 
   mSeekable = do_QueryInterface(mInput);
+  if (!mSeekable) {
+    // XXX The file may just be a .url or similar
+    // shortcut that points to a Web site. We need to fix this by
+    // doing an async open and waiting until we locate the real resource,
+    // then using that (if it's still a file!).
+    return NS_ERROR_FAILURE;
+  }
 
-  // Get the file size and inform the decoder
-  nsCOMPtr<nsIFileChannel> fc(do_QueryInterface(mChannel));
-  if (fc) {
-    nsCOMPtr<nsIFile> file;
-    rv = fc->GetFile(getter_AddRefs(file));
-    if (NS_SUCCEEDED(rv)) {
-      PRInt64 size = 0;
-      rv = file->GetFileSize(&size);
-      if (NS_SUCCEEDED(rv)) {
-        mDecoder->SetTotalBytes(size);
-      }
-    }
+  // Get the file size and inform the decoder. Only files up to 4GB are
+  // supported here.
+  PRUint32 size;
+  rv = mInput->Available(&size);
+  if (NS_SUCCEEDED(rv)) {
+    mDecoder->SetTotalBytes(size);
   }
 
   /* Get our principal */
   nsCOMPtr<nsIScriptSecurityManager> secMan =
     do_GetService("@mozilla.org/scriptsecuritymanager;1");
   if (secMan) {
-    nsresult rv = secMan->GetChannelPrincipal(mChannel,
-                                              getter_AddRefs(mPrincipal));
+    rv = secMan->GetChannelPrincipal(mChannel,
+                                     getter_AddRefs(mPrincipal));
     if (NS_FAILED(rv)) {
       return rv;
     }
@@ -251,7 +277,7 @@
     NS_NEW_RUNNABLE_METHOD(nsMediaDecoder, mDecoder, ResourceLoaded); 
   NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
   
-  return mSeekable ? NS_OK : NS_ERROR_FAILURE;
+  return NS_OK;
 }
 
 nsresult nsFileStreamStrategy::Close()
@@ -324,7 +350,7 @@
   
   // These methods have the same thread calling requirements 
   // as those with the same name in nsMediaStream
-  virtual nsresult Open();
+  virtual nsresult Open(nsIStreamListener** aListener);
   virtual nsresult Close();
   virtual nsresult Read(char* aBuffer, PRUint32 aCount, PRUint32* aBytes);
   virtual nsresult Seek(PRInt32 aWhence, PRInt64 aOffset);
@@ -383,18 +409,25 @@
   mPipeInput = aStream;
 }
 
-nsresult nsHttpStreamStrategy::Open()
+nsresult nsHttpStreamStrategy::Open(nsIStreamListener **aStreamListener)
 {
-  nsresult rv;
+  if (aStreamListener) {
+    *aStreamListener = nsnull;
+  }
 
   mListener = new nsChannelToPipeListener(mDecoder);
   NS_ENSURE_TRUE(mListener, NS_ERROR_OUT_OF_MEMORY);
 
-  rv = mListener->Init();
+  nsresult rv = mListener->Init();
   NS_ENSURE_SUCCESS(rv, rv);
   
-  rv = mChannel->AsyncOpen(mListener, nsnull);
-  NS_ENSURE_SUCCESS(rv, rv);
+  if (aStreamListener) {
+    *aStreamListener = mListener;
+    NS_ADDREF(*aStreamListener);
+  } else {
+    rv = mChannel->AsyncOpen(mListener, nsnull);
+    NS_ENSURE_SUCCESS(rv, rv);
+  }
   
   rv = mListener->GetInputStream(getter_AddRefs(mPipeInput));
   NS_ENSURE_SUCCESS(rv, rv);
@@ -684,21 +717,24 @@
   MOZ_COUNT_DTOR(nsMediaStream);
 }
 
-nsresult nsMediaStream::Open(nsMediaDecoder* aDecoder, nsIURI* aURI)
+nsresult nsMediaStream::Open(nsMediaDecoder* aDecoder, nsIURI* aURI,
+                             nsIChannel* aChannel, nsIStreamListener** aListener)
 {
   NS_ASSERTION(NS_IsMainThread(), 
 	       "nsMediaStream::Open called on non-main thread");
 
-  nsresult rv;
-
   nsCOMPtr<nsIChannel> channel;
-  rv = NS_NewChannel(getter_AddRefs(channel), 
-                     aURI, 
-                     nsnull,
-                     nsnull,
-                     nsnull,
-                     nsIRequest::LOAD_NORMAL);
-  NS_ENSURE_SUCCESS(rv, rv);
+  if (aChannel) {
+    channel = aChannel;
+  } else {
+    nsresult rv = NS_NewChannel(getter_AddRefs(channel), 
+                                aURI, 
+                                nsnull,
+                                nsnull,
+                                nsnull,
+                                nsIRequest::LOAD_NORMAL);
+    NS_ENSURE_SUCCESS(rv, rv);
+  }
 
   nsCOMPtr<nsIFileChannel> fc = do_QueryInterface(channel);
   nsCOMPtr<nsIHttpChannel> hc = do_QueryInterface(channel);
@@ -712,7 +748,7 @@
   mPlaybackRateCount = 0;
   mPlaybackRateStart = PR_IntervalNow();
 
-  return mStreamStrategy->Open();
+  return mStreamStrategy->Open(aListener);
 }
 
 nsresult nsMediaStream::Close()
diff -r 17e9560465b0 content/media/video/src/nsOggDecoder.cpp
--- a/content/media/video/src/nsOggDecoder.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/media/video/src/nsOggDecoder.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -49,6 +49,7 @@
 #include "nsIObserverService.h"
 #include "nsAutoLock.h"
 #include "nsTArray.h"
+#include "nsNetUtil.h"
 #include "nsOggDecoder.h"
 
 /* 
@@ -1165,10 +1166,26 @@
   nsAutoMonitor::DestroyMonitor(mMonitor);
 }
 
-nsresult nsOggDecoder::Load(nsIURI* aURI) 
+nsresult nsOggDecoder::Load(nsIURI* aURI, nsIChannel* aChannel,
+                            nsIStreamListener** aStreamListener)
 {
-  nsresult rv;
-  mURI = aURI;
+  if (aStreamListener) {
+    *aStreamListener = nsnull;
+  }
+
+  if (aURI) {
+    NS_ASSERTION(!aStreamListener, "No listener should be requested here");
+    mURI = aURI;
+  } else {
+    NS_ASSERTION(aChannel, "Either a URI or a channel is required");
+    NS_ASSERTION(aStreamListener, "A listener should be requested here");
+
+    // If the channel was redirected, we want the post-redirect URI;
+    // but if the URI scheme was expanded, say from chrome: to jar:file:,
+    // we want the original URI.
+    nsresult rv = NS_GetFinalChannelURI(aChannel, getter_AddRefs(mURI));
+    NS_ENSURE_SUCCESS(rv, rv);
+  }
 
   StartProgress();
 
@@ -1177,7 +1194,7 @@
   mReader = new nsChannelReader();
   NS_ENSURE_TRUE(mReader, NS_ERROR_OUT_OF_MEMORY);
 
-  rv = mReader->Init(this, aURI);
+  nsresult rv = mReader->Init(this, mURI, aChannel, aStreamListener);
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = NS_NewThread(getter_AddRefs(mDecodeThread));
@@ -1457,9 +1474,12 @@
     // If we've completed playback then the decode and display threads
     // have been shutdown. To honor the state change request we need
     // to reload the resource and restart the threads.
+    // Like seeking, this will require opening a new channel, which means
+    // we may not actually get the same resource --- a server may send
+    // us something different.
     mNextState = aState;
     mPlayState = PLAY_STATE_LOADING;
-    Load(mURI);
+    Load(mURI, nsnull, nsnull);
     return;
   }
 
diff -r 17e9560465b0 content/media/video/test/Makefile.in
--- a/content/media/video/test/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/media/video/test/Makefile.in	Thu Oct 30 05:41:44 2008 -0400
@@ -44,6 +44,7 @@
 include $(topsrcdir)/config/rules.mk
 
 _TEST_FILES = 	test_autoplay.html \
+                test_bug461281.html \
                 test_constants.html \
                 test_controls.html \
                 test_currentTime.html \
@@ -63,11 +64,13 @@
                 test_seek6.html \
                 test_seek7.html \
                 test_seek8.html \
+                test_standalone.html \
                 test_timeupdate1.html \
                 test_timeupdate2.html \
                 test_timeupdate3.html \
                 test_volume.html \
                 320x240.ogg \
+                bug461281.ogg \
                 seek.ogg \
 #                test_bug448534.html \
                 $(NULL)
diff -r 17e9560465b0 content/media/video/test/bug461281.ogg
Binary file content/media/video/test/bug461281.ogg has changed
diff -r 17e9560465b0 content/media/video/test/test_bug461281.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/media/video/test/test_bug461281.html	Thu Oct 30 05:41:44 2008 -0400
@@ -0,0 +1,49 @@
+<!DOCTYPE HTML>
+<html>
+<head>
+  <title>Media test: Bug 461281 - Ogg Streams with eof marker</title>
+  <script type="text/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+<video id='v'
+       src='bug461281.ogg'
+       onloadedmetadata='return startTest();'
+       onended='return playbackEnded();'></video>
+<pre id="test">
+<script class="testbody" type="text/javascript">
+// Test if the ended event occurs with media without an eos marker
+var v = document.getElementById('v');
+var endPassed = false;
+var completed = false;
+var timeout;
+
+function startTest() {
+  if (completed)
+    return false;
+
+  v.play();
+  return false;
+}
+
+function playbackEnded() {
+  if (completed)
+    return false
+
+  completed = true;
+  ok(v.ended, "Checking playback has ended");
+  clearTimeout(timeout);
+  SimpleTest.finish();
+  return false;
+}
+timeout = setTimeout(function () {
+                       ok(false, "Test timed out");
+                       SimpleTest.finish();
+                     }, 30000);
+
+SimpleTest.waitForExplicitFinish();
+</script>
+</pre>
+</body>
+</html>
diff -r 17e9560465b0 content/media/video/test/test_standalone.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/media/video/test/test_standalone.html	Thu Oct 30 05:41:44 2008 -0400
@@ -0,0 +1,29 @@
+<!DOCTYPE HTML>
+<html>
+<head>
+  <title>Media test: standalone video documents</title>
+  <script type="text/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body onload="doTest()">
+
+<iframe id="i" src="320x240.ogg"></iframe>
+
+<pre id="test">
+<script class="testbody" type="text/javascript">
+SimpleTest.waitForExplicitFinish();
+
+function doTest()
+{
+  var elem = document.getElementById("i").contentDocument.body.firstChild;
+  is(elem.tagName.toLowerCase(), "video", "Is video element");
+  is(elem.currentSrc.substring(elem.currentSrc.length - 11), "320x240.ogg", "currentSrc");
+  is(elem.controls, true, "Controls set");
+  is(elem.autoplay, true, "Autoplay set");
+  SimpleTest.finish();
+}
+</script>
+</pre>
+</body>
+</html>
diff -r 17e9560465b0 content/svg/Makefile.in
--- a/content/svg/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/svg/Makefile.in	Thu Oct 30 05:41:44 2008 -0400
@@ -42,6 +42,6 @@
 
 include $(DEPTH)/config/autoconf.mk
 
-DIRS		= document content
+PARALLEL_DIRS	= document content
 
 include $(topsrcdir)/config/rules.mk
diff -r 17e9560465b0 content/svg/content/Makefile.in
--- a/content/svg/content/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/svg/content/Makefile.in	Thu Oct 30 05:41:44 2008 -0400
@@ -43,7 +43,7 @@
 
 include $(DEPTH)/config/autoconf.mk
 
-DIRS		= src
+PARALLEL_DIRS		= src
 
 ifdef ENABLE_TESTS
 DIRS += test
diff -r 17e9560465b0 content/svg/content/src/nsSVGFeatures.cpp
--- a/content/svg/content/src/nsSVGFeatures.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/svg/content/src/nsSVGFeatures.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -22,6 +22,7 @@
  *
  * Contributor(s):
  *   Scooter Morris <scootermorris@comcast.net>
+ *   Frederic Wang <fred.wang@free.fr> - requiredExtensions
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -87,6 +88,43 @@
   nsWhitespaceTokenizer tokenizer(aFeatures);
   while (tokenizer.hasMoreTokens()) {
     if (!NS_SVG_HaveFeature(tokenizer.nextToken())) {
+      return PR_FALSE;
+    }
+  }
+  return PR_TRUE;
+}
+
+/**
+ * Check whether we support the given extension string.
+ *
+ * @param aExtension the URI of an extension. Known extensions are
+ *   MathML and XHTML.
+ */
+static PRBool
+HaveExtension(const nsAString& aExtension)
+{
+#define SVG_SUPPORTED_EXTENSION(str) if (aExtension.Equals(NS_LITERAL_STRING(str).get())) return PR_TRUE;
+  SVG_SUPPORTED_EXTENSION("http://www.w3.org/1999/xhtml")
+#ifdef MOZ_MATHML
+  SVG_SUPPORTED_EXTENSION("http://www.w3.org/1998/Math/MathML")
+#endif
+#undef SVG_SUPPORTED_EXTENSION
+
+  return PR_FALSE;
+}
+
+/**
+ * Check whether we support the given list of extension strings.
+ *
+ * @param aExtension a whitespace separated list containing one or more
+ *   extension strings
+ */
+static PRBool
+HaveExtensions(const nsSubstring& aExtensions)
+{
+  nsWhitespaceTokenizer tokenizer(aExtensions);
+  while (tokenizer.hasMoreTokens()) {
+    if (!HaveExtension(tokenizer.nextToken())) {
       return PR_FALSE;
     }
   }
@@ -174,11 +212,11 @@
   // extensions. Language extensions are capabilities within a user agent that
   // go beyond the feature set defined in the SVG specification.
   // Each extension is identified by a URI reference.
-  // For now, claim that mozilla's SVG implementation supports
-  // no extensions.  So, if extensions are required, we don't have
-  // them available.
-  if (aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::requiredExtensions)) {
-    return PR_FALSE;
+  // For now, claim that mozilla's SVG implementation supports XHTML and MathML.
+  if (aContent->GetAttr(kNameSpaceID_None, nsGkAtoms::requiredExtensions, value)) {
+    if (value.IsEmpty() || !HaveExtensions(value)) {
+      return PR_FALSE;
+    }
   }
 
   // systemLanguage
diff -r 17e9560465b0 content/svg/content/src/nsSVGPathSeg.cpp
--- a/content/svg/content/src/nsSVGPathSeg.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/svg/content/src/nsSVGPathSeg.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -53,6 +53,16 @@
 
 //----------------------------------------------------------------------
 // implementation helper macros
+
+#define NS_IMPL_SVGPATHSEG(type, letter)                      \
+NS_IMETHODIMP                                                 \
+GetPathSegType(PRUint16 *aPathSegType) {                      \
+  *aPathSegType = type; return NS_OK; }                       \
+                                                              \
+NS_IMETHODIMP                                                 \
+GetPathSegTypeAsLetter(nsAString & aPathSegTypeAsLetter) {    \
+  aPathSegTypeAsLetter.Assign(letter);                        \
+  return NS_OK; }
 
 #define NS_IMPL_NSISUPPORTS_SVGPATHSEG(basename)              \
 NS_IMPL_ADDREF(ns##basename)                                  \
@@ -133,11 +143,6 @@
 ////////////////////////////////////////////////////////////////////////
 // nsSVGPathSeg
 
-char nsSVGPathSeg::mTypeLetters[] = {
-  'X', 'z', 'M', 'm', 'L', 'l', 'C', 'c', 'S', 's',
-  'A', 'a', 'H', 'h', 'V', 'v', 'Q', 'q', 'T', 't'
-};
-
 nsQueryReferent
 nsSVGPathSeg::GetCurrentList() const
 {
@@ -154,20 +159,6 @@
   nsresult rv;
   mCurrentList = do_GetWeakReference(aList, &rv);
   return rv;
-}
-
-NS_IMETHODIMP
-nsSVGPathSeg::GetPathSegType(PRUint16 *aPathSegType)
-{
-  *aPathSegType = GetSegType();
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-nsSVGPathSeg::GetPathSegTypeAsLetter(nsAString & aPathSegTypeAsLetter)
-{
-  aPathSegTypeAsLetter.AssignASCII(&mTypeLetters[GetSegType()], 1);
-  return NS_OK;
 }
 
 void
@@ -211,8 +202,7 @@
   // nsSVGPathSeg methods:
   NS_IMETHOD GetValueString(nsAString& aValue);
   virtual float GetLength(nsSVGPathSegTraversalState *ts);
-  virtual PRUint16 GetSegType()
-    { return nsIDOMSVGPathSeg::PATHSEG_CLOSEPATH; }
+  NS_IMPL_SVGPATHSEG(PATHSEG_CLOSEPATH, 'z')
 };
 
 //----------------------------------------------------------------------
@@ -265,8 +255,7 @@
   // nsSVGPathSeg methods:
   NS_IMETHOD GetValueString(nsAString& aValue);
   virtual float GetLength(nsSVGPathSegTraversalState *ts);
-  virtual PRUint16 GetSegType()
-    { return nsIDOMSVGPathSeg::PATHSEG_MOVETO_ABS; }
+  NS_IMPL_SVGPATHSEG(PATHSEG_MOVETO_ABS, 'M')
 
 protected:
   float mX, mY;
@@ -361,8 +350,7 @@
   // nsSVGPathSeg methods:
   NS_IMETHOD GetValueString(nsAString& aValue);
   virtual float GetLength(nsSVGPathSegTraversalState *ts);
-  virtual PRUint16 GetSegType()
-    { return nsIDOMSVGPathSeg::PATHSEG_MOVETO_REL; }
+  NS_IMPL_SVGPATHSEG(PATHSEG_MOVETO_REL, 'm')
 
 protected:
   float mX, mY;
@@ -456,8 +444,7 @@
   // nsSVGPathSeg methods:
   NS_IMETHOD GetValueString(nsAString& aValue);
   virtual float GetLength(nsSVGPathSegTraversalState *ts);
-  virtual PRUint16 GetSegType()
-    { return nsIDOMSVGPathSeg::PATHSEG_LINETO_ABS; }
+  NS_IMPL_SVGPATHSEG(PATHSEG_LINETO_ABS, 'L')
 
 protected:
   float mX, mY;
@@ -554,8 +541,7 @@
   // nsSVGPathSeg methods:
   NS_IMETHOD GetValueString(nsAString& aValue);
   virtual float GetLength(nsSVGPathSegTraversalState *ts);
-  virtual PRUint16 GetSegType()
-    { return nsIDOMSVGPathSeg::PATHSEG_LINETO_REL; }
+  NS_IMPL_SVGPATHSEG(PATHSEG_LINETO_REL, 'l')
 
 protected:
   float mX, mY;
@@ -652,8 +638,7 @@
   // nsSVGPathSeg methods:
   NS_IMETHOD GetValueString(nsAString& aValue);
   virtual float GetLength(nsSVGPathSegTraversalState *ts);
-  virtual PRUint16 GetSegType()
-    { return nsIDOMSVGPathSeg::PATHSEG_CURVETO_CUBIC_ABS; }
+  NS_IMPL_SVGPATHSEG(PATHSEG_CURVETO_CUBIC_ABS, 'C')
 
 protected:
   float mX, mY, mX1, mY1, mX2, mY2;
@@ -819,8 +804,7 @@
   // nsSVGPathSeg methods:
   NS_IMETHOD GetValueString(nsAString& aValue);
   virtual float GetLength(nsSVGPathSegTraversalState *ts);
-  virtual PRUint16 GetSegType()
-    { return nsIDOMSVGPathSeg::PATHSEG_CURVETO_CUBIC_REL; }
+  NS_IMPL_SVGPATHSEG(PATHSEG_CURVETO_CUBIC_REL, 'c')
 
 protected:
   float mX, mY, mX1, mY1, mX2, mY2;
@@ -981,8 +965,7 @@
   // nsSVGPathSeg methods:
   NS_IMETHOD GetValueString(nsAString& aValue);
   virtual float GetLength(nsSVGPathSegTraversalState *ts);
-  virtual PRUint16 GetSegType()
-    { return nsIDOMSVGPathSeg::PATHSEG_CURVETO_QUADRATIC_ABS; }
+  NS_IMPL_SVGPATHSEG(PATHSEG_CURVETO_QUADRATIC_ABS, 'Q')
 
 protected:
   float mX, mY, mX1, mY1;
@@ -1115,9 +1098,7 @@
   // nsSVGPathSeg methods:
   NS_IMETHOD GetValueString(nsAString& aValue);
   virtual float GetLength(nsSVGPathSegTraversalState *ts);
-  virtual PRUint16 GetSegType()
-    { return nsIDOMSVGPathSeg::PATHSEG_CURVETO_QUADRATIC_REL; }
-
+  NS_IMPL_SVGPATHSEG(PATHSEG_CURVETO_QUADRATIC_REL, 'q')
 
 protected:
   float mX, mY, mX1, mY1;
@@ -1251,8 +1232,7 @@
   // nsSVGPathSeg methods:
   NS_IMETHOD GetValueString(nsAString& aValue);
   virtual float GetLength(nsSVGPathSegTraversalState *ts);
-  virtual PRUint16 GetSegType()
-    { return nsIDOMSVGPathSeg::PATHSEG_ARC_ABS; }
+  NS_IMPL_SVGPATHSEG(PATHSEG_ARC_ABS, 'A')
 
 protected:
   float  mX, mY, mR1, mR2, mAngle;
@@ -1437,8 +1417,7 @@
   // nsSVGPathSeg methods:
   NS_IMETHOD GetValueString(nsAString& aValue);
   virtual float GetLength(nsSVGPathSegTraversalState *ts);
-  virtual PRUint16 GetSegType()
-    { return nsIDOMSVGPathSeg::PATHSEG_ARC_REL; }
+  NS_IMPL_SVGPATHSEG(PATHSEG_ARC_REL, 'a')
 
 protected:
   float  mX, mY, mR1, mR2, mAngle;
@@ -1621,8 +1600,7 @@
   // nsSVGPathSeg methods:
   NS_IMETHOD GetValueString(nsAString& aValue);
   virtual float GetLength(nsSVGPathSegTraversalState *ts);
-  virtual PRUint16 GetSegType()
-    { return nsIDOMSVGPathSeg::PATHSEG_LINETO_HORIZONTAL_ABS; }
+  NS_IMPL_SVGPATHSEG(PATHSEG_LINETO_HORIZONTAL_ABS, 'H')
 
 protected:
   float mX;
@@ -1704,8 +1682,7 @@
   // nsSVGPathSeg methods:
   NS_IMETHOD GetValueString(nsAString& aValue);
   virtual float GetLength(nsSVGPathSegTraversalState *ts);
-  virtual PRUint16 GetSegType()
-    { return nsIDOMSVGPathSeg::PATHSEG_LINETO_HORIZONTAL_REL; }
+  NS_IMPL_SVGPATHSEG(PATHSEG_LINETO_HORIZONTAL_REL, 'h')
 
 protected:
   float mX;
@@ -1786,8 +1763,7 @@
   // nsSVGPathSeg methods:
   NS_IMETHOD GetValueString(nsAString& aValue);
   virtual float GetLength(nsSVGPathSegTraversalState *ts);
-  virtual PRUint16 GetSegType()
-    { return nsIDOMSVGPathSeg::PATHSEG_LINETO_VERTICAL_ABS; }
+  NS_IMPL_SVGPATHSEG(PATHSEG_LINETO_VERTICAL_ABS, 'V')
 
 protected:
   float mY;
@@ -1869,9 +1845,7 @@
   // nsSVGPathSeg methods:
   NS_IMETHOD GetValueString(nsAString& aValue);
   virtual float GetLength(nsSVGPathSegTraversalState *ts);
-  virtual PRUint16 GetSegType()
-    { return nsIDOMSVGPathSeg::PATHSEG_LINETO_VERTICAL_REL; }
-
+  NS_IMPL_SVGPATHSEG(PATHSEG_LINETO_VERTICAL_REL, 'v')
 
 protected:
   float mY;
@@ -1953,8 +1927,7 @@
   // nsSVGPathSeg methods:
   NS_IMETHOD GetValueString(nsAString& aValue);
   virtual float GetLength(nsSVGPathSegTraversalState *ts);
-  virtual PRUint16 GetSegType()
-    { return nsIDOMSVGPathSeg::PATHSEG_CURVETO_CUBIC_SMOOTH_ABS; }
+  NS_IMPL_SVGPATHSEG(PATHSEG_CURVETO_CUBIC_SMOOTH_ABS, 'S')
 
 protected:
   float mX, mY, mX2, mY2;
@@ -2092,8 +2065,7 @@
   // nsSVGPathSeg methods:
   NS_IMETHOD GetValueString(nsAString& aValue);
   virtual float GetLength(nsSVGPathSegTraversalState *ts);
-  virtual PRUint16 GetSegType()
-    { return nsIDOMSVGPathSeg::PATHSEG_CURVETO_CUBIC_SMOOTH_REL; }
+  NS_IMPL_SVGPATHSEG(PATHSEG_CURVETO_CUBIC_SMOOTH_REL, 's')
 
 protected:
   float mX, mY, mX2, mY2;
@@ -2228,8 +2200,7 @@
   // nsSVGPathSeg methods:
   NS_IMETHOD GetValueString(nsAString& aValue);
   virtual float GetLength(nsSVGPathSegTraversalState *ts);
-  virtual PRUint16 GetSegType()
-    { return nsIDOMSVGPathSeg::PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS; }
+  NS_IMPL_SVGPATHSEG(PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS, 'T')
 
 protected:
   float mX, mY;
@@ -2331,9 +2302,7 @@
   // nsSVGPathSeg methods:
   NS_IMETHOD GetValueString(nsAString& aValue);
   virtual float GetLength(nsSVGPathSegTraversalState *ts);
-  virtual PRUint16 GetSegType()
-    { return nsIDOMSVGPathSeg::PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL; }
-
+  NS_IMPL_SVGPATHSEG(PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL, 't')
 
 protected:
   float mX, mY;
diff -r 17e9560465b0 content/svg/content/src/nsSVGPathSeg.h
--- a/content/svg/content/src/nsSVGPathSeg.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/svg/content/src/nsSVGPathSeg.h	Thu Oct 30 05:41:44 2008 -0400
@@ -84,18 +84,17 @@
   NS_DECL_ISUPPORTS
 
   // nsIDOMSVGPathSeg interface:
-  NS_DECL_NSIDOMSVGPATHSEG
-  NS_IMETHOD GetValueString(nsAString& aValue) = 0;
+  NS_IMETHOD GetPathSegType(PRUint16 *aPathSegType) = 0;
+  NS_IMETHOD GetPathSegTypeAsLetter(nsAString & aPathSegTypeAsLetter) = 0;
 
   // nsSVGPathSeg methods:
+  NS_IMETHOD GetValueString(nsAString& aValue) = 0;
   virtual float GetLength(nsSVGPathSegTraversalState *ts) = 0;
 
 protected:
-  virtual PRUint16 GetSegType() = 0;
   void DidModify();
 
 private:
-  static char mTypeLetters[];
   nsCOMPtr<nsIWeakReference> mCurrentList;
 };
 
diff -r 17e9560465b0 content/test/reftest/bug439965-ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/test/reftest/bug439965-ref.html	Thu Oct 30 05:41:44 2008 -0400
@@ -0,0 +1,20 @@
+<!DOCTYPE html>
+<html>
+<body>
+<script>
+function doe(aEl) {
+var doc = aEl.contentDocument;
+doc.designMode = 'on';
+
+try {
+doc.execCommand("insertHTML",false,'some text');
+} catch(e) {
+  document.getElementById('result').innerHTML = e;
+}
+}
+</script>
+
+<iframe onload="doe(this)"></iframe><br>
+<pre id="result" style="background-color: red; width: 300px; white-space: -moz-pre-wrap;"></pre>
+</body>
+</html>
diff -r 17e9560465b0 content/test/reftest/bug439965.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/test/reftest/bug439965.html	Thu Oct 30 05:41:44 2008 -0400
@@ -0,0 +1,21 @@
+<!DOCTYPE html>
+<html>
+<body>
+<script>
+function doe(aEl) {
+aEl.style.display = '';
+var doc = aEl.contentDocument;
+doc.designMode = 'on';
+
+try {
+doc.execCommand("insertHTML",false,'some text');
+} catch(e) {
+  document.getElementById('result').innerHTML = e;
+}
+}
+</script>
+
+<iframe onload="doe(this)" style="display:none"></iframe><br>
+<pre id="result" style="background-color: red; width: 300px; white-space: -moz-pre-wrap;"></pre>
+</body>
+</html>
diff -r 17e9560465b0 content/test/reftest/reftest.list
--- a/content/test/reftest/reftest.list	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/test/reftest/reftest.list	Thu Oct 30 05:41:44 2008 -0400
@@ -1,4 +1,5 @@
 == bug453105.html bug453105-ref.html
 == optiontext.html optiontext-ref.html
 == bug456008.xhtml bug456008-ref.html
+== bug439965.html bug439965-ref.html
 == bug427779.xml bug427779-ref.xml
diff -r 17e9560465b0 content/xbl/Makefile.in
--- a/content/xbl/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/xbl/Makefile.in	Thu Oct 30 05:41:44 2008 -0400
@@ -42,7 +42,7 @@
 
 include $(DEPTH)/config/autoconf.mk
 
-DIRS		= public src builtin
+PARALLEL_DIRS	= public src builtin
 
 ifdef ENABLE_TESTS
 DIRS		+= test
diff -r 17e9560465b0 content/xbl/src/nsXBLService.cpp
--- a/content/xbl/src/nsXBLService.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/xbl/src/nsXBLService.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -423,9 +423,6 @@
     NS_WARNING("XBL load did not complete until after document went away! Modal dialog bug?\n");
   }
   else {
-    // Clear script handling object on asynchronously loaded XBL documents.
-    doc->ClearScriptHandlingObject();
-
     // We have to do a flush prior to notification of the document load.
     // This has to happen since the HTML content sink can be holding on
     // to notifications related to our children (e.g., if you bind to the
@@ -1289,9 +1286,6 @@
   rv = nsSyncLoadService::PushSyncStreamToListener(in, listener, channel);
   NS_ENSURE_SUCCESS(rv, rv);
 
-  // Clear script handling on synchronously loaded XBL documents.
-  doc->ClearScriptHandlingObject();
-
   doc.swap(*aResult);
 
   return NS_OK;
diff -r 17e9560465b0 content/xml/Makefile.in
--- a/content/xml/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/xml/Makefile.in	Thu Oct 30 05:41:44 2008 -0400
@@ -42,7 +42,7 @@
 
 include $(DEPTH)/config/autoconf.mk
 
-DIRS		= content document
+PARALLEL_DIRS	= content document
 
 include $(topsrcdir)/config/rules.mk
 
diff -r 17e9560465b0 content/xml/document/Makefile.in
--- a/content/xml/document/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/xml/document/Makefile.in	Thu Oct 30 05:41:44 2008 -0400
@@ -42,7 +42,7 @@
 
 include $(DEPTH)/config/autoconf.mk
 
-DIRS		= public resources src
+PARALLEL_DIRS	= public resources src
 
 ifdef ENABLE_TESTS
 DIRS            += test
diff -r 17e9560465b0 content/xslt/Makefile.in
--- a/content/xslt/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/xslt/Makefile.in	Thu Oct 30 05:41:44 2008 -0400
@@ -42,7 +42,7 @@
 
 include $(DEPTH)/config/autoconf.mk
 
-DIRS = public src
+PARALLEL_DIRS = public src
 
 ifdef ENABLE_TESTS
 DIRS += tests/buster \
diff -r 17e9560465b0 content/xslt/src/Makefile.in
--- a/content/xslt/src/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/xslt/src/Makefile.in	Thu Oct 30 05:41:44 2008 -0400
@@ -42,10 +42,10 @@
 
 include $(DEPTH)/config/autoconf.mk
 
-DIRS            = base xml xpath xslt 
+PARALLEL_DIRS   = base xml xpath xslt 
 
 ifdef MOZ_XSLT_STANDALONE
-DIRS += main
+PARALLEL_DIRS += main
 endif
 
 include $(topsrcdir)/config/rules.mk
diff -r 17e9560465b0 content/xtf/Makefile.in
--- a/content/xtf/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/xtf/Makefile.in	Thu Oct 30 05:41:44 2008 -0400
@@ -42,7 +42,7 @@
 
 include $(DEPTH)/config/autoconf.mk
 
-DIRS		=  public src
+PARALLEL_DIRS	=  public src
 
 ifdef ENABLE_TESTS
 DIRS  += test
diff -r 17e9560465b0 content/xul/Makefile.in
--- a/content/xul/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/xul/Makefile.in	Thu Oct 30 05:41:44 2008 -0400
@@ -46,10 +46,10 @@
 # interfaces and implementations.
 # Likewise for content, because of nsXULAtoms.
 
-DIRS		= document content
+PARALLEL_DIRS	= document content
 
 ifdef MOZ_XUL
-DIRS		+= templates
+PARALLEL_DIRS	+= templates
 endif
 
 include $(topsrcdir)/config/rules.mk
diff -r 17e9560465b0 content/xul/content/Makefile.in
--- a/content/xul/content/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/xul/content/Makefile.in	Thu Oct 30 05:41:44 2008 -0400
@@ -43,7 +43,7 @@
 include $(DEPTH)/config/autoconf.mk
 
 MODULE		= xul
-DIRS		= src test
+PARALLEL_DIRS	= src test
 
 include $(topsrcdir)/config/rules.mk
 
diff -r 17e9560465b0 content/xul/content/src/nsXULPopupListener.cpp
--- a/content/xul/content/src/nsXULPopupListener.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/xul/content/src/nsXULPopupListener.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -69,6 +69,7 @@
 #include "nsLayoutUtils.h"
 #include "nsFrameManager.h"
 #include "nsHTMLReflowState.h"
+#include "nsIObjectLoadingContent.h"
 
 // for event firing in context menus
 #include "nsPresContext.h"
@@ -177,6 +178,15 @@
     PRBool eventEnabled =
       nsContentUtils::GetBoolPref("dom.event.contextmenu.enabled", PR_TRUE);
     if (!eventEnabled) {
+      // If the target node is for plug-in, we should not open XUL context
+      // menu on windowless plug-ins.
+      nsCOMPtr<nsIObjectLoadingContent> olc = do_QueryInterface(targetNode);
+      PRUint32 type;
+      if (olc && NS_SUCCEEDED(olc->GetDisplayedType(&type)) &&
+          type == nsIObjectLoadingContent::TYPE_PLUGIN) {
+        return NS_OK;
+      }
+
       // The user wants his contextmenus.  Let's make sure that this is a website
       // and not chrome since there could be places in chrome which don't want
       // contextmenus.
diff -r 17e9560465b0 content/xul/document/Makefile.in
--- a/content/xul/document/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/xul/document/Makefile.in	Thu Oct 30 05:41:44 2008 -0400
@@ -43,7 +43,7 @@
 include $(DEPTH)/config/autoconf.mk
 
 MODULE		= xuldoc
-DIRS		= public src
+PARALLEL_DIRS	= public src
 
 ifdef ENABLE_TESTS
 DIRS		+= test
diff -r 17e9560465b0 content/xul/templates/Makefile.in
--- a/content/xul/templates/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/content/xul/templates/Makefile.in	Thu Oct 30 05:41:44 2008 -0400
@@ -43,7 +43,7 @@
 include $(DEPTH)/config/autoconf.mk
 
 MODULE		= xultmpl
-DIRS		= public src
+PARALLEL_DIRS	= public src
 
 include $(topsrcdir)/config/rules.mk
 
diff -r 17e9560465b0 db/sqlite3/src/Makefile.in
--- a/db/sqlite3/src/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/db/sqlite3/src/Makefile.in	Thu Oct 30 05:41:44 2008 -0400
@@ -91,7 +91,17 @@
 # don't have to vacuum to make sure the data is not visible in the file.
 # -DSQLITE_ENABLE_FTS3=1 enables the full-text index module.
 # -DSQLITE_CORE=1 statically links that module into the SQLite library.
-DEFINES = -DSQLITE_SECURE_DELETE=1 -DTHREADSAFE=1 -DSQLITE_CORE=1 -DSQLITE_ENABLE_FTS3=1
+DEFINES = \
+  -DSQLITE_SECURE_DELETE=1 \
+  -DTHREADSAFE=1 \
+  -DSQLITE_CORE=1 \
+  -DSQLITE_ENABLE_FTS3=1 \
+  $(NULL)
+
+# -DSQLITE_ENABLE_LOCKING_STYLE=1 to help with AFP folders
+ifeq ($(MOZ_WIDGET_TOOLKIT),cocoa)
+DEFINES += -DSQLITE_ENABLE_LOCKING_STYLE=1
+endif
 
 ifeq ($(OS_ARCH),OS2)
 ifdef MOZ_OS2_HIGH_MEMORY
diff -r 17e9560465b0 docshell/base/nsAboutRedirector.cpp
--- a/docshell/base/nsAboutRedirector.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/docshell/base/nsAboutRedirector.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -81,7 +81,6 @@
       nsIAboutModule::URI_SAFE_FOR_UNTRUSTED_CONTENT },
     { "licence", "chrome://global/content/license.html",
       nsIAboutModule::URI_SAFE_FOR_UNTRUSTED_CONTENT },
-    { "about", "chrome://global/content/aboutAbout.html", 0 },
     { "neterror", "chrome://global/content/netError.xhtml",
       nsIAboutModule::URI_SAFE_FOR_UNTRUSTED_CONTENT |
       nsIAboutModule::ALLOW_SCRIPT }
diff -r 17e9560465b0 docshell/base/nsDocShell.cpp
--- a/docshell/base/nsDocShell.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/docshell/base/nsDocShell.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -3067,6 +3067,13 @@
                 if (expert) {
                     cssClass.AssignLiteral("expertBadCert");
                 }
+                
+                // See if an alternate cert error page is registered
+                nsXPIDLCString alternateErrorPage;
+                mPrefs->GetCharPref("security.alternate_certificate_error_page",
+                                    getter_Copies(alternateErrorPage));
+                if (alternateErrorPage)
+                    errorPage.Assign(alternateErrorPage);
             } else {
                 error.AssignLiteral("nssFailure2");
             }
diff -r 17e9560465b0 docshell/build/nsDocShellModule.cpp
--- a/docshell/build/nsDocShellModule.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/docshell/build/nsDocShellModule.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -211,11 +211,6 @@
       NS_ABOUT_MODULE_CONTRACTID_PREFIX "licence",
       nsAboutRedirector::Create
     },
-    { "about:about",
-      NS_ABOUT_REDIRECTOR_MODULE_CID,
-      NS_ABOUT_MODULE_CONTRACTID_PREFIX "about",
-      nsAboutRedirector::Create
-    },
     { "about:neterror",
       NS_ABOUT_REDIRECTOR_MODULE_CID,
       NS_ABOUT_MODULE_CONTRACTID_PREFIX "neterror",
diff -r 17e9560465b0 dom/public/idl/base/nsIDOMWindowUtils.idl
--- a/dom/public/idl/base/nsIDOMWindowUtils.idl	Thu Oct 23 09:51:35 2008 -0700
+++ b/dom/public/idl/base/nsIDOMWindowUtils.idl	Thu Oct 30 05:41:44 2008 -0400
@@ -47,7 +47,7 @@
 
 interface nsIDOMElement;
 
-[scriptable, uuid(9a1ff4e0-5e31-46af-b393-2cbab8093442)]
+[scriptable, uuid(440D036F-0879-4497-9364-35DE49F6849F)]
 interface nsIDOMWindowUtils : nsISupports {
 
   /**
@@ -119,13 +119,16 @@
    * @param aButton button to synthesize
    * @param aClickCount number of clicks that have been performed
    * @param aModifiers modifiers pressed, using constants defined in nsIDOMNSEvent
+   * @param aIgnoreScrollFrame whether the event should ignore viewport bounds
+   *                           during dispatch
    */
   void sendMouseEvent(in AString aType,
                       in long aX,
                       in long aY,
                       in long aButton,
                       in long aClickCount,
-                      in long aModifiers);
+                      in long aModifiers,
+                      [optional] in boolean aIgnoreScrollFrame);
 
   /** Synthesize a mouse scroll event for a window. The event types supported
    *  are: 
@@ -204,14 +207,13 @@
   void activateNativeMenuItemAt(in AString indexString);
 
   /**
-   * See nsIWidget::ForceNativeMenuReload
+   * See nsIWidget::ForceUpdateNativeMenuAt
    *
-   * This is used for native menu system testing. Calling this forces a full
-   * reload of the menu system, reloading all native menus and their items.
-   * This is important for testing because changes to the DOM can affect the
-   * native menu system lazily.
+   * Cannot be accessed from unprivileged context (not content-accessible)
+   * Will throw a DOM security error if called without UniversalXPConnect
+   * privileges.
    */
-  void forceNativeMenuReload();
+  void forceUpdateNativeMenuAt(in AString indexString);
 
   /**
    * Focus the element aElement. The element should be in the same document
@@ -240,4 +242,24 @@
    */
 
   void processUpdates();
+
+  /** Synthesize a simple gesture event for a window. The event types
+   *  supported are: MozSwipeGesture, MozMagnifyGestureStart,
+   *  MozMagnifyGestureUpdate, MozMagnifyGesture,
+   *  MozRotateGestureStart, MozRotateGestureUpdate, and
+   *  MozRotateGesture.
+   *
+   * Cannot be accessed from unprivileged context (not
+   * content-accessible) Will throw a DOM security error if called
+   * without UniversalXPConnect privileges.
+   *
+   * @param aType event type
+   * @param aDirection direction, using constants defined in nsIDOMSimpleGestureEvent
+   * @param aDelta  amount of magnification or rotation for magnify and rotation events
+   * @param aModifiers modifiers pressed, using constants defined in nsIDOMNSEvent
+   */
+  void sendSimpleGestureEvent(in AString aType,
+                              in unsigned long aDirection,
+                              in double aDelta,
+                              in long aModifiers);
 };
diff -r 17e9560465b0 dom/public/idl/events/Makefile.in
--- a/dom/public/idl/events/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/dom/public/idl/events/Makefile.in	Thu Oct 30 05:41:44 2008 -0400
@@ -76,6 +76,7 @@
 	nsIDOMCommandEvent.idl			\
 	nsIDOMMessageEvent.idl			\
 	nsIDOMNotifyPaintEvent.idl              \
+	nsIDOMSimpleGestureEvent.idl		\
 	$(NULL)
 
 include $(topsrcdir)/config/rules.mk
diff -r 17e9560465b0 dom/public/idl/events/nsIDOMSimpleGestureEvent.idl
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/public/idl/events/nsIDOMSimpleGestureEvent.idl	Thu Oct 30 05:41:44 2008 -0400
@@ -0,0 +1,141 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Thomas K. Dyas <tdyas@zecador.org>.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+
+#include "nsIDOMUIEvent.idl"
+
+/**
+ * The nsIDOMSimpleGestureEvent interface is the datatype for all
+ * Mozila-specific simple gesture events in the Document Object Model.
+ *
+ * The following events are generated:
+ *
+ * MozSwipeGesture - Generated when the user swipes their fingers
+ * across the input device.
+ *
+ * MozMagnifyGestureStart - Generated when the user begins the magnify
+ * ("pinch") gesture.  The "delta" value represents the initial
+ * movement.
+ *
+ * MozMagnifyGestureUpdate - Generated periodically while the user is
+ * continuing the magnify ("pinch") gesture.  The "delta" value
+ * represents the movement since the last MozMagnifyGestureStart or
+ * MozMagnifyGestureUpdate event.
+ *
+ * MozMagnifyGesture - Generated when the user has completed the
+ * magnify ("pinch") gesture.  If you only want to receive a single
+ * event when the magnify gesture is complete, you only need to hook
+ * this event and can safely ignore the MozMagnifyGestureStart and the
+ * MozMagnifyGestureUpdate events. The "delta" value is the cumulative
+ * amount represented by the user's gesture.
+ *
+ * MozRotateGestureStart - Generated when the user begins the rotation
+ * gesture.  The "delta" value represents the initial rotation.
+ *
+ * MozRotateGestureUpdate - Generated periodically while the user is
+ * continuing the rotation gesture.  The "delta" value represents the
+ * rotation since the last MozRotateGestureStart or
+ * MozRotateGestureUpdate event.
+ *
+ * MozRotateGesture - Generated when the user has completed the
+ * rotation gesture.  If you only want to receive a single event when
+ * the rotation gesture is complete, you only need to hook this event
+ * and can safely ignore the MozRotateGestureStart and the
+ * MozRotateGestureUpdate events.  The "delta" value is the cumulative
+ * amount of rotation represented by the user's gesture.
+ */
+
+[scriptable, uuid(20AB8E74-BF9B-4D1D-8A18-B5EE0F3C0A36)]
+interface nsIDOMSimpleGestureEvent : nsIDOMUIEvent
+{
+  /* Direction constants */
+  const unsigned long DIRECTION_UP = 1;
+  const unsigned long DIRECTION_DOWN = 2;
+  const unsigned long DIRECTION_LEFT = 4;
+  const unsigned long DIRECTION_RIGHT = 8;
+  
+  /* Direction of a gesture. Diagonals are indicated by OR'ing the
+   * applicable constants together.
+   *
+   * Swipes gestures may occur in any direction.
+   *
+   * Magnify gestures do not have a direction.
+   *
+   * Rotation gestures will be either DIRECTION_LEFT or
+   * DIRECTION_RIGHT (i.e., counter-clockwise and clockwise).
+   */
+  readonly attribute unsigned long direction;
+
+  /* Delta value for magnify and rotate gestures.
+   * 
+   * For rotation, the value is in degrees and is positive for
+   * clockwise rotation and negative for counterclockwise
+   * rotation. The "direction" attribute also denotes the direction of
+   * the rotation: clockwise is DIRECTION_RIGHT and counterclockwise
+   * is DIRECTION_LEFT.
+   *
+   * For magnification, the value will be positive for a "zoom in"
+   * (i.e, increased magnification) and negative for a "zoom out"
+   * (i.e., decreased magnification).  The particular units
+   * represented by the "delta" are currently implementation specific.
+   *
+   * XXX - The units for measuring magnification are currently
+   * unspecified because the units used by Mac OS X are currently
+   * undocumented.  The values are typically in the range of 0.0 to
+   * 100.0, but it is only safe currently to rely on the delta being
+   * positive or negative.
+   */
+  readonly attribute double delta;
+
+  /* Modifier keys that may have been pressed during the gesture. */
+  readonly attribute boolean altKey;
+  readonly attribute boolean ctrlKey;
+  readonly attribute boolean shiftKey;
+  readonly attribute boolean metaKey;
+
+  void initSimpleGestureEvent(in DOMString typeArg,
+                              in boolean canBubbleArg,
+                              in boolean cancelableArg,
+                              in nsIDOMAbstractView viewArg,
+                              in long detailArg,
+                              in unsigned long directionArg,
+                              in double deltaArg,
+                              in boolean altKeyArg,
+                              in boolean ctrlKeyArg,
+                              in boolean shiftKeyArg,
+                              in boolean metaKeyArg);
+};
diff -r 17e9560465b0 dom/public/idl/geolocation/nsIDOMGeoPosition.idl
--- a/dom/public/idl/geolocation/nsIDOMGeoPosition.idl	Thu Oct 23 09:51:35 2008 -0700
+++ b/dom/public/idl/geolocation/nsIDOMGeoPosition.idl	Thu Oct 30 05:41:44 2008 -0400
@@ -46,6 +46,6 @@
   readonly attribute double accuracy;
   readonly attribute double altitudeAccuracy;
   readonly attribute double heading;
-  readonly attribute double velocity;
+  readonly attribute double speed;
   readonly attribute DOMTimeStamp timestamp;
 };
diff -r 17e9560465b0 dom/public/idl/geolocation/nsIDOMGeoPositionErrorCallback.idl
--- a/dom/public/idl/geolocation/nsIDOMGeoPositionErrorCallback.idl	Thu Oct 23 09:51:35 2008 -0700
+++ b/dom/public/idl/geolocation/nsIDOMGeoPositionErrorCallback.idl	Thu Oct 30 05:41:44 2008 -0400
@@ -41,5 +41,5 @@
 
 [scriptable, function, uuid(7D9B09D9-4843-43EB-A7A7-67F7DDA6B3C4)]
 interface nsIDOMGeoPositionErrorCallback : nsISupports {
-  void handleEvent(in nsIDOMGeoPositionError position);
+  void handleEvent(in nsIDOMGeoPositionError positionError);
 };
diff -r 17e9560465b0 dom/public/idl/geolocation/nsIGeolocationProvider.idl
--- a/dom/public/idl/geolocation/nsIGeolocationProvider.idl	Thu Oct 23 09:51:35 2008 -0700
+++ b/dom/public/idl/geolocation/nsIGeolocationProvider.idl	Thu Oct 30 05:41:44 2008 -0400
@@ -42,14 +42,6 @@
 interface nsIDOMWindow;
 interface nsIDOMGeoPosition;
 interface nsIGeolocationPrompt;
-
-/**
- * nsIGeolocationService
- */
-[scriptable, uuid(68300FFD-802C-431B-BF92-0A657696B853)]
-interface nsIGeolocationService : nsISupports {
-  attribute nsIGeolocationPrompt prompt;
-};
 
 /**
  * Interface allows access to a geolocation and is passed to
@@ -136,6 +128,15 @@
 };
 
 %{C++
-#define NS_GEOLOCATION_SERVICE_CONTRACTID  "@mozilla.org/geolocation/service;1"
+/*  
+    This must be implemented by geolocation providers.  It
+    must support nsIGeolocationProvider.
+*/
 #define NS_GEOLOCATION_PROVIDER_CONTRACTID "@mozilla.org/geolocation/provider;1"
+
+/*  
+    This must be implemented by embedders.  It must support
+    nsIGeolocationPrompt.
+*/
+#define NS_GEOLOCATION_PROMPT_CONTRACTID   "@mozilla.org/geolocation/prompt;1"
 %}
diff -r 17e9560465b0 dom/public/idl/html/nsIDOMHTMLMediaElement.idl
--- a/dom/public/idl/html/nsIDOMHTMLMediaElement.idl	Thu Oct 23 09:51:35 2008 -0700
+++ b/dom/public/idl/html/nsIDOMHTMLMediaElement.idl	Thu Oct 30 05:41:44 2008 -0400
@@ -85,7 +85,7 @@
   // playback state
            attribute float currentTime;
   readonly attribute float duration;
-  readonly attribute unsigned short paused;
+  readonly attribute boolean paused;
            attribute float defaultPlaybackRate;
            attribute float playbackRate;
   readonly attribute nsIDOMHTMLTimeRanges played;
diff -r 17e9560465b0 dom/public/nsDOMClassInfoID.h
--- a/dom/public/nsDOMClassInfoID.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/dom/public/nsDOMClassInfoID.h	Thu Oct 30 05:41:44 2008 -0400
@@ -452,6 +452,8 @@
 
   eDOMClassInfo_NotifyPaintEvent_id,
 
+  eDOMClassInfo_SimpleGestureEvent_id,
+
   // This one better be the last one in this list
   eDOMClassInfoIDCount
 };
diff -r 17e9560465b0 dom/src/base/nsDOMClassInfo.cpp
--- a/dom/src/base/nsDOMClassInfo.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/dom/src/base/nsDOMClassInfo.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -465,6 +465,9 @@
 #include "nsDOMFile.h"
 #include "nsIDOMFileException.h"
 
+// Simple gestures include
+#include "nsIDOMSimpleGestureEvent.h"
+
 static NS_DEFINE_CID(kCPluginManagerCID, NS_PLUGINMANAGER_CID);
 static NS_DEFINE_CID(kDOMSOF_CID, NS_DOM_SCRIPT_OBJECT_FACTORY_CID);
 
@@ -1292,6 +1295,9 @@
                            DOM_DEFAULT_SCRIPTABLE_FLAGS)
 
   NS_DEFINE_CLASSINFO_DATA(NotifyPaintEvent, nsDOMGenericSH,
+                           DOM_DEFAULT_SCRIPTABLE_FLAGS)
+
+  NS_DEFINE_CLASSINFO_DATA(SimpleGestureEvent, nsDOMGenericSH,
                            DOM_DEFAULT_SCRIPTABLE_FLAGS)
 };
 
@@ -3531,6 +3537,11 @@
     DOM_CLASSINFO_EVENT_MAP_ENTRIES
   DOM_CLASSINFO_MAP_END
 
+  DOM_CLASSINFO_MAP_BEGIN(SimpleGestureEvent, nsIDOMSimpleGestureEvent)
+    DOM_CLASSINFO_MAP_ENTRY(nsIDOMSimpleGestureEvent)
+    DOM_CLASSINFO_UI_EVENT_MAP_ENTRIES
+  DOM_CLASSINFO_MAP_END
+
 #ifdef NS_DEBUG
   {
     PRUint32 i = NS_ARRAY_LENGTH(sClassInfoData);
@@ -5915,7 +5926,7 @@
       jsval val;
 
       *_retval = (::JS_ValueToId(cx, id, &interned_id) &&
-                  ::JS_LookupPropertyByIdWithFlags(cx, innerObj, interned_id,
+                  ::JS_LookupPropertyWithFlagsById(cx, innerObj, interned_id,
                                                    flags, &pobj, &val));
 
       if (*_retval && pobj) {
@@ -6414,7 +6425,7 @@
         jsval val;
 
         if (!::JS_ValueToId(cx, id, &interned_id) ||
-            !::JS_LookupPropertyByIdWithFlags(cx, proto, interned_id, flags,
+            !::JS_LookupPropertyWithFlagsById(cx, proto, interned_id, flags,
                                               &pobj, &val)) {
           *_retval = JS_FALSE;
 
diff -r 17e9560465b0 dom/src/base/nsDOMWindowUtils.cpp
--- a/dom/src/base/nsDOMWindowUtils.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/dom/src/base/nsDOMWindowUtils.cpp	Thu Oct 30 05:41:44 2008 -0400
@@ -199,7 +199,8 @@
                                  PRInt32 aY,
                                  PRInt32 aButton,
                                  PRInt32 aClickCount,
-                                 PRInt32 aModifiers)
+                                 PRInt32 aModifiers,
+                                 PRBool aIgnoreScrollFrame)
 {
   PRBool hasCap = PR_FALSE;
   if (NS_FAILED(nsContentUtils::GetSecurityManager()->IsCapabilityEnabled("UniversalXPConnect", &hasCap))
@@ -243,6 +244,7 @@
   event.time = PR_IntervalNow();
   event.refPoint.x = aX;
   event.refPoint.y = aY;
+  event.ignoreScrollFrame = aIgnoreScrollFrame;
 
   nsEventStatus status;
   return widget->DispatchEvent(&event, status);
@@ -382,9 +384,8 @@
   return widget->ActivateNativeMenuItemAt(indexString);
 }
 
-
 NS_IMETHODIMP
-nsDOMWindowUtils::ForceNativeMenuReload()
+nsDOMWindowUtils::ForceUpdateNativeMenuAt(const nsAString& indexString)
 {
   PRBool hasCap = PR_FALSE;
   if (NS_FAILED(nsContentUtils::GetSecurityManager()->IsCapabilityEnabled("UniversalXPConnect", &hasCap))
@@ -396,9 +397,8 @@
   if (!widget)
     return NS_ERROR_FAILURE;
 
-  return widget->ForceNativeMenuReload();
+  return widget->ForceUpdateNativeMenuAt(indexString);
 }
-
 
 nsIWidget*
 nsDOMWindowUtils::GetWidget()
@@ -493,3 +493,48 @@
   batch.EndUpdateViewBatch(NS_VMREFRESH_IMMEDIATE);
   return NS_OK;
 }
+
+NS_IMETHODIMP
+nsDOMWindowUtils::SendSimpleGestureEvent(const nsAString& aType,
+                                         PRUint32 aDirection,
+                                         PRFloat64 aDelta,
+                                         PRInt32 aModifiers)
+{
+  PRBool hasCap = PR_FALSE;
+  if (NS_FAILED(nsContentUtils::GetSecurityManager()->IsCapabilityEnabled("UniversalXPConnect", &hasCap))
+      || !hasCap)
+    return NS_ERROR_DOM_SECURITY_ERR;
+
+  // get the widget to send the event to
+  nsCOMPtr<nsIWidget> widget = GetWidget();
+  if (!widget)
+    return NS_ERROR_FAILURE;
+
+  PRInt32 msg;
+  if (aType.EqualsLiteral("MozSwipeGesture"))
+    msg = NS_SIMPLE_GESTURE_SWIPE;
+  else if (aType.EqualsLiteral("MozMagnifyGestureStart"))
+    msg = NS_SIMPLE_GESTURE_MAGNIFY_START;
+  else if (aType.EqualsLiteral("MozMagnifyGestureUpdate"))
+    msg = NS_SIMPLE_GESTURE_MAGNIFY_UPDATE;
+  else if (aType.EqualsLiteral("MozMagnifyGesture"))
+    msg = NS_SIMPLE_GESTURE_MAGNIFY;
+  else if (aType.EqualsLiteral("MozRotateGestureStart"))
+    msg = NS_SIMPLE_GESTURE_ROTATE_START;
+  else if (aType.EqualsLiteral("MozRotateGestureUpdate"))
+    msg = NS_SIMPLE_GESTURE_ROTATE_UPDATE;
+  else if (aType.EqualsLiteral("MozRotateGesture"))
+    msg = NS_SIMPLE_GESTURE_ROTATE;
+  else
+    return NS_ERROR_FAILURE;
+ 
+  nsSimpleGestureEvent event(PR_TRUE, msg, widget, aDirection, aDelta);
+  event.isShift = (aModifiers & nsIDOMNSEvent::SHIFT_MASK) ? PR_TRUE : PR_FALSE;
+  event.isControl = (aModifiers & nsIDOMNSEvent::CONTROL_MASK) ? PR_TRUE : PR_FALSE;
+  event.isAlt = (aModifiers & nsIDOMNSEvent::ALT_MASK) ? PR_TRUE : PR_FALSE;
+  event.isMeta = (aModifiers & nsIDOMNSEvent::META_MASK) ? PR_TRUE : PR_FALSE;
+  event.time = PR_IntervalNow();
+
+  nsEventStatus status;
+  return widget->DispatchEvent(&event, status);
+}
diff -r 17e9560465b0 dom/src/base/nsJSEnvironment.cpp
--- a/dom/src/base/nsJSEnvironment.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/dom/src/base/nsJSEnvironment.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -1172,6 +1172,12 @@
   PRBool useJIT = nsContentUtils::GetBoolPref(chromeWindow ?
                                               js_jit_chrome_str :
                                               js_jit_content_str);
+
+#ifdef MOZ_JSDEBUGGER
+  if (context->mContext->debugHooks->debuggerHandler)
+    useJIT = PR_FALSE;
+#endif
+
   if (useJIT)
     newDefaultJSOptions |= JSOPTION_JIT;
   else
@@ -2313,9 +2319,10 @@
   JSObject *newInnerJSObject = (JSObject *)aNewInner->GetScriptGlobal(JAVASCRIPT);
   JSObject *myobject = (JSObject *)aOuterGlobal;
 
-  // *Don't* call JS_ClearScope here since it's unnecessary
-  // and it confuses the JS engine as to which Function is
-  // on which window. See bug 343966.
+  // Call ClearScope to nuke any properties (e.g. Function and Object) on the
+  // outer object. From now on, anybody asking the outer object for these
+  // properties will be forwarded to the inner window.
+  ::JS_ClearScope(mContext, myobject);
 
   // Make the inner and outer window both share the same
   // prototype. The prototype we share is the outer window's
diff -r 17e9560465b0 dom/src/geolocation/nsGeolocation.cpp
--- a/dom/src/geolocation/nsGeolocation.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/dom/src/geolocation/nsGeolocation.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -267,7 +267,7 @@
     // need to make a copy because nsIDOMGeoPosition is
     // readonly, and we are not sure of its implementation.
 
-    double lat, lon, alt, herror, verror, heading, velocity;
+    double lat, lon, alt, herror, verror, heading, speed;
     DOMTimeStamp time;
     aPosition->GetLatitude(&lat);
     aPosition->GetLongitude(&lon);
@@ -275,7 +275,7 @@
     aPosition->GetAccuracy(&herror);
     aPosition->GetAltitudeAccuracy(&verror);
     aPosition->GetHeading(&heading);
-    aPosition->GetVelocity(&velocity);
+    aPosition->GetSpeed(&speed);
     aPosition->GetTimestamp(&time); 
 
     // Truncate ?
@@ -287,7 +287,7 @@
     lon = 0;
     herror = 0;
     heading = 0; 
-    velocity = 0;
+    speed = 0;
     alt = 0;
     verror = 0;
 
@@ -297,7 +297,7 @@
                                                           herror,
                                                           verror,
                                                           heading,
-                                                          velocity,
+                                                          speed,
                                                           time);
     mCallback->HandleEvent(somewhere);
   }
@@ -376,9 +376,9 @@
 }
 
 NS_IMETHODIMP
-nsGeoPosition::GetVelocity(double *aVelocity)
+nsGeoPosition::GetSpeed(double *aSpeed)
 {
-  *aVelocity = mVelocity;
+  *aSpeed = mSpeed;
   return NS_OK;
 }
 
@@ -395,7 +395,6 @@
 NS_INTERFACE_MAP_BEGIN(nsGeolocationService)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIGeolocationUpdate)
   NS_INTERFACE_MAP_ENTRY(nsIGeolocationUpdate)
-  NS_INTERFACE_MAP_ENTRY(nsIGeolocationService)
   NS_INTERFACE_MAP_ENTRY(nsIObserver)
 NS_INTERFACE_MAP_END
 
@@ -433,8 +432,6 @@
 
     StopDevice();
 
-    // Remove our reference to any prompt that may have been set.
-    mPrompt = nsnull;
     return NS_OK;
   }
   
@@ -455,22 +452,6 @@
   }
 
   return NS_ERROR_FAILURE;
-}
-
-NS_IMETHODIMP
-nsGeolocationService::GetPrompt(nsIGeolocationPrompt * *aPrompt)
-{
-  NS_ENSURE_ARG_POINTER(aPrompt);
-  *aPrompt = mPrompt;
-  NS_IF_ADDREF(*aPrompt);
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-nsGeolocationService::SetPrompt(nsIGeolocationPrompt * aPrompt)
-{
-  mPrompt = aPrompt;
-  return NS_OK;
 }
 
 NS_IMETHODIMP
@@ -719,7 +700,8 @@
                                   nsIDOMGeoPositionErrorCallback *errorCallback,
                                   nsIDOMGeoPositionOptions *options)
 {
-  nsIGeolocationPrompt* prompt = mService->GetPrompt();
+
+  nsCOMPtr<nsIGeolocationPrompt> prompt = do_GetService(NS_GEOLOCATION_PROMPT_CONTRACTID);
   if (prompt == nsnull)
     return NS_ERROR_NOT_AVAILABLE;
 
@@ -740,7 +722,7 @@
                              nsIDOMGeoPositionOptions *aOptions, 
                              PRUint16 *_retval NS_OUTPARAM)
 {
-  nsIGeolocationPrompt* prompt = mService->GetPrompt();
+  nsCOMPtr<nsIGeolocationPrompt> prompt = do_GetService(NS_GEOLOCATION_PROMPT_CONTRACTID);
   if (prompt == nsnull)
     return NS_ERROR_NOT_AVAILABLE;
     
diff -r 17e9560465b0 dom/src/geolocation/nsGeolocation.h
--- a/dom/src/geolocation/nsGeolocation.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/dom/src/geolocation/nsGeolocation.h	Thu Oct 30 05:41:45 2008 -0400
@@ -108,19 +108,19 @@
   NS_DECL_ISUPPORTS
   NS_DECL_NSIDOMGEOPOSITION
 
-    nsGeoPosition(double aLat, double aLong, double aAlt, double aHError, double aVError, double aHeading, double aVelocity, long long aTimestamp)
-    : mLat(aLat), mLong(aLong), mAlt(aAlt), mHError(aHError), mVError(aVError), mHeading(aHeading), mVelocity(aVelocity), mTimestamp(aTimestamp){};
+    nsGeoPosition(double aLat, double aLong, double aAlt, double aHError, double aVError, double aHeading, double aSpeed, long long aTimestamp)
+    : mLat(aLat), mLong(aLong), mAlt(aAlt), mHError(aHError), mVError(aVError), mHeading(aHeading), mSpeed(aSpeed), mTimestamp(aTimestamp){};
 
 private:
   ~nsGeoPosition(){}
-  double mLat, mLong, mAlt, mHError, mVError, mHeading, mVelocity;
+  double mLat, mLong, mAlt, mHError, mVError, mHeading, mSpeed;
   long long mTimestamp;
 };
 
 /**
  * Singleton that manages the geolocation provider
  */
-class nsGeolocationService : public nsIGeolocationService, public nsIGeolocationUpdate, public nsIObserver
+class nsGeolocationService : public nsIGeolocationUpdate, public nsIObserver
 {
 public:
 
@@ -131,7 +131,6 @@
   NS_DECL_ISUPPORTS
   NS_DECL_NSIGEOLOCATIONUPDATE
   NS_DECL_NSIOBSERVER
-  NS_DECL_NSIGEOLOCATIONSERVICE
 
   nsGeolocationService();
 
@@ -142,9 +141,6 @@
   // Returns the last geolocation we have seen since calling StartDevice()
   already_AddRefed<nsIDOMGeoPosition> GetLastKnownPosition();
   
-  // Returns the application defined UI prompt
-  nsIGeolocationPrompt* GetPrompt() { return mPrompt; } // does not addref.
-
   // Returns true if the we have successfully found and started a
   // geolocation device
   PRBool   IsDeviceReady();
@@ -177,9 +173,6 @@
   // addes them to this list, and their destructor removes
   // them from this list.
   nsTArray<nsGeolocation*> mGeolocators;
-
-  // prompt callback, if any
-  nsCOMPtr<nsIGeolocationPrompt> mPrompt;
 };
 
 
diff -r 17e9560465b0 dom/tests/mochitest/geolocation/geolocation_common.js
--- a/dom/tests/mochitest/geolocation/geolocation_common.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/dom/tests/mochitest/geolocation/geolocation_common.js	Thu Oct 30 05:41:45 2008 -0400
@@ -43,7 +43,7 @@
   ok("accuracy" in location, "Check to see if there is a accuracy");
   ok("altitudeAccuracy" in location, "Check to see if there is a alt accuracy");
   ok("heading" in location, "Check to see if there is a heading");
-  ok("velocity" in location, "Check to see if there is a velocity");
+  ok("speed" in location, "Check to see if there is a speed");
   ok("timestamp" in location, "Check to see if there is a timestamp");
 
 }
@@ -107,21 +107,46 @@
   setTimeout(geolocation_prompt, prompt_delay, request);
 }
 
+var TestPromptFactory = {
+    QueryInterface: function(iid) {
+        if (iid.equals(Components.interfaces.nsISupports) || iid.equals(Components.interfaces.nsIFactory))
+            return this;
+        throw Components.results.NS_ERROR_NO_INTERFACE;
+    },
+
+    createInstance: function(outer, iid) {
+        if (outer)
+            throw Components.results.NS_ERROR_NO_AGGREGATION;
+
+        if(DELAYED_PROMPT)
+            return delayed_prompt;
+        else
+            return  geolocation_prompt;
+    },
+
+    lockFactory: function(lock) {
+        throw Components.results.NS_ERROR_NOT_IMPLEMENTED;
+    },
+};
+
 function attachPrompt() {
   netscape.security.PrivilegeManager.enablePrivilege('UniversalXPConnect');
-  var geolocationService = Components.classes["@mozilla.org/geolocation/service;1"]
-                           .getService(Components.interfaces.nsIGeolocationService);
-  old_prompt = geolocationService.prompt;
+  old_prompt  =  Components.manager.nsIComponentRegistrar.contractIDToCID("@mozilla.org/geolocation/prompt;1");
+  old_factory =  Components.manager.getClassObjectByContractID("@mozilla.org/geolocation/prompt;1", Components.interfaces.nsIFactory)
 
-  if(DELAYED_PROMPT)
-    geolocationService.prompt = delayed_prompt;
-  else
-    geolocationService.prompt = geolocation_prompt;
+  const testing_prompt_cid = Components.ID("{20C27ECF-A22E-4022-9757-2CFDA88EAEAA}");
+  Components.manager.nsIComponentRegistrar.registerFactory(testing_prompt_cid,
+                                                           "Test Geolocation Prompt",
+                                                           "@mozilla.org/geolocation/prompt;1",
+                                                           TestPromptFactory);
 }
 
 function removePrompt() {
   netscape.security.PrivilegeManager.enablePrivilege('UniversalXPConnect');
-  var geolocationService = Components.classes["@mozilla.org/geolocation/service;1"]
-                           .getService(Components.interfaces.nsIGeolocationService);
-  geolocationService.prompt = old_prompt;
+  const testing_prompt_cid = Components.ID("{20C27ECF-A22E-4022-9757-2CFDA88EAEAA}");
+  Components.manager.nsIComponentRegistrar.unregisterFactory(testing_prompt_cid, TestPromptFactory);
+  Components.manager.nsIComponentRegistrar.registerFactory(old_prompt,
+                                                           "Geolocation Prompt restored!",
+                                                           "@mozilla.org/geolocation/prompt;1",
+                                                           old_factory);
 }
diff -r 17e9560465b0 dom/tests/mochitest/geolocation/testLocationProvider.js
--- a/dom/tests/mochitest/geolocation/testLocationProvider.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/dom/tests/mochitest/geolocation/testLocationProvider.js	Thu Oct 30 05:41:45 2008 -0400
@@ -28,7 +28,7 @@
     accuracy: 1,
     altitudeAccuracy: 1,
     heading: 1,
-    velocity: 1,
+    speed: 1,
     timestamp: 1,
 };
 
diff -r 17e9560465b0 embedding/components/printingui/src/win/nsPrintDialogUtil.cpp
--- a/embedding/components/printingui/src/win/nsPrintDialogUtil.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/embedding/components/printingui/src/win/nsPrintDialogUtil.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -194,7 +194,7 @@
 //----------------------------------------------------------------------------------
 // Map an incoming size to a Windows Native enum in the DevMode
 static void 
-MapPaperSizeToNativeEnum(LPDEVMODE aDevMode,
+MapPaperSizeToNativeEnum(LPDEVMODEW aDevMode,
                          PRInt16   aType, 
                          double    aW, 
                          double    aH)
@@ -249,7 +249,7 @@
 // Setup Paper Size & Orientation options into the DevMode
 // 
 static void 
-SetupDevModeFromSettings(LPDEVMODE aDevMode, nsIPrintSettings* aPrintSettings)
+SetupDevModeFromSettings(LPDEVMODEW aDevMode, nsIPrintSettings* aPrintSettings)
 {
   // Setup paper size
   if (aPrintSettings) {
@@ -753,28 +753,28 @@
 //   This function assumes that aPrintName has already been converted from 
 //   unicode
 //
-static HGLOBAL CreateGlobalDevModeAndInit(LPCTSTR aPrintName, nsIPrintSettings* aPS)
+static HGLOBAL CreateGlobalDevModeAndInit(LPCWSTR aPrintName, nsIPrintSettings* aPS)
 {
   HGLOBAL hGlobalDevMode = NULL;
 
   nsresult rv = NS_ERROR_FAILURE;
   HANDLE hPrinter = NULL;
   // const cast kludge for silly Win32 api's
-  LPTSTR printName = const_cast<char*>(aPrintName);
-  BOOL status = ::OpenPrinter(printName, &hPrinter, NULL);
+  LPWSTR printName = const_cast<wchar_t*>(aPrintName);
+  BOOL status = ::OpenPrinterW(printName, &hPrinter, NULL);
   if (status) {
 
-    LPDEVMODE   pNewDevMode;
+    LPDEVMODEW  pNewDevMode;
     DWORD       dwNeeded, dwRet;
 
     // Get the buffer size
-    dwNeeded = ::DocumentProperties(gParentWnd, hPrinter, printName, NULL, NULL, 0);
+    dwNeeded = ::DocumentPropertiesW(gParentWnd, hPrinter, printName, NULL, NULL, 0);
     if (dwNeeded == 0) {
       return NULL;
     }
 
     // Allocate a buffer of the correct size.
-    pNewDevMode = (LPDEVMODE)::HeapAlloc (::GetProcessHeap(), HEAP_ZERO_MEMORY, dwNeeded);
+    pNewDevMode = (LPDEVMODEW)::HeapAlloc (::GetProcessHeap(), HEAP_ZERO_MEMORY, dwNeeded);
     if (!pNewDevMode) return NULL;
 
     hGlobalDevMode = (HGLOBAL)::GlobalAlloc(GHND, dwNeeded);
@@ -783,7 +783,7 @@
       return NULL;
     }
 
-    dwRet = ::DocumentProperties(gParentWnd, hPrinter, printName, pNewDevMode, NULL, DM_OUT_BUFFER);
+    dwRet = ::DocumentPropertiesW(gParentWnd, hPrinter, printName, pNewDevMode, NULL, DM_OUT_BUFFER);
 
     if (dwRet != IDOK) {
       ::HeapFree(::GetProcessHeap(), 0, pNewDevMode);
@@ -794,14 +794,14 @@
 
     // Lock memory and copy contents from DEVMODE (current printer)
     // to Global Memory DEVMODE
-    LPDEVMODE devMode = (DEVMODE *)::GlobalLock(hGlobalDevMode);
+    LPDEVMODEW devMode = (DEVMODEW *)::GlobalLock(hGlobalDevMode);
     if (devMode) {
       memcpy(devMode, pNewDevMode, dwNeeded);
       // Initialize values from the PrintSettings
       SetupDevModeFromSettings(devMode, aPS);
 
       // Sets back the changes we made to the DevMode into the Printer Driver
-      dwRet = ::DocumentProperties(gParentWnd, hPrinter, printName, devMode, devMode, DM_IN_BUFFER | DM_OUT_BUFFER);
+      dwRet = ::DocumentPropertiesW(gParentWnd, hPrinter, printName, devMode, devMode, DM_IN_BUFFER | DM_OUT_BUFFER);
       if (dwRet != IDOK) {
         ::GlobalUnlock(hGlobalDevMode);
         ::GlobalFree(hGlobalDevMode);
@@ -882,10 +882,7 @@
     printerName = GetDefaultPrinterNameFromGlobalPrinters();
   } else {
     HANDLE hPrinter = NULL;
-    nsCAutoString printerNameNative;
-    NS_CopyUnicodeToNative(nsDependentString(printerName), printerNameNative);
-    LPTSTR tempPrinterName = const_cast<char*>(printerNameNative.get());
-    if(!::OpenPrinter(tempPrinterName, &hPrinter, NULL)) {
+    if(!::OpenPrinterW(const_cast<wchar_t*>(printerName), &hPrinter, NULL)) {
       // If the last used printer is not found, we should use default printer.
       printerName = GetDefaultPrinterNameFromGlobalPrinters();
     } else {
@@ -897,20 +894,18 @@
   if (!printerName) return NS_ERROR_FAILURE;
 
   // Now create a DEVNAMES struct so the the dialog is initialized correctly.
-  nsCAutoString tempPrinterName;
-  rv = NS_CopyUnicodeToNative(nsDependentString(printerName), tempPrinterName);
-  NS_ENSURE_SUCCESS(rv, rv);
 
-  PRUint32 len = tempPrinterName.Length();
-  hDevNames = (HGLOBAL)::GlobalAlloc(GHND, len+sizeof(DEVNAMES)+1);
+  PRUint32 len = wcslen(printerName);
+  hDevNames = (HGLOBAL)::GlobalAlloc(GHND, sizeof(wchar_t) * (len + 1) + 
+                                     sizeof(DEVNAMES));
   DEVNAMES* pDevNames = (DEVNAMES*)::GlobalLock(hDevNames);
   pDevNames->wDriverOffset = sizeof(DEVNAMES);
   pDevNames->wDeviceOffset = sizeof(DEVNAMES);
   pDevNames->wOutputOffset = sizeof(DEVNAMES)+len+1;
   pDevNames->wDefault      = 0;
 
-  char* device = &(((char*)pDevNames)[pDevNames->wDeviceOffset]);
-  strcpy(device, tempPrinterName.get());
+  wchar_t* device = &(((wchar_t*)pDevNames)[pDevNames->wDeviceOffset]);
+  wcscpy(device, printerName);
   ::GlobalUnlock(hDevNames);
 
   // Create a Moveable Memory Object that holds a new DevMode
@@ -919,11 +914,11 @@
   // NOTE: We only need to free hGlobalDevMode when the dialog is cancelled
   // When the user prints, it comes back in the printdlg struct and 
   // is used and cleaned up later
-  hGlobalDevMode = CreateGlobalDevModeAndInit(tempPrinterName.get(), aPrintSettings);
+  hGlobalDevMode = CreateGlobalDevModeAndInit(printerName, aPrintSettings);
 
   // Prepare to Display the Print Dialog
-  PRINTDLG  prntdlg;
-  memset(&prntdlg, 0, sizeof(PRINTDLG));
+  PRINTDLGW  prntdlg;
+  memset(&prntdlg, 0, sizeof(PRINTDLGW));
 
   prntdlg.lStructSize = sizeof(prntdlg);
   prntdlg.hwndOwner   = aHWnd;
@@ -969,7 +964,7 @@
     prntdlg.Flags            |= PD_ENABLEPRINTHOOK;
   }
 
-  BOOL result = ::PrintDlg(&prntdlg);
+  BOOL result = ::PrintDlgW(&prntdlg);
 
   if (TRUE == result) {
     // check to make sure we don't have any NULL pointers
@@ -986,8 +981,8 @@
       return NS_ERROR_FAILURE;
     }
 
-    char* device = &(((char *)devnames)[devnames->wDeviceOffset]);
-    char* driver = &(((char *)devnames)[devnames->wDriverOffset]);
+    wchar_t* device = &(((wchar_t *)devnames)[devnames->wDeviceOffset]);
+    wchar_t* driver = &(((wchar_t *)devnames)[devnames->wDriverOffset]);
 
     // Check to see if the "Print To File" control is checked
     // then take the name from devNames and set it in the PrintSettings
@@ -998,9 +993,9 @@
     // if the "Print To File" checkbox is checked it MUST be "FILE:"
     // We assert as an extra safety check.
     if (prntdlg.Flags & PD_PRINTTOFILE) {
-      char* fileName = &(((char *)devnames)[devnames->wOutputOffset]);
-      NS_ASSERTION(strcmp(fileName, "FILE:") == 0, "FileName must be `FILE:`");
-      aPrintSettings->SetToFileName(NS_ConvertASCIItoUTF16(fileName).get());
+      wchar_t* fileName = &(((wchar_t *)devnames)[devnames->wOutputOffset]);
+      NS_ASSERTION(wcscmp(fileName, L"FILE:") == 0, "FileName must be `FILE:`");
+      aPrintSettings->SetToFileName(fileName);
       aPrintSettings->SetPrintToFile(PR_TRUE);
     } else {
       // clear "print to file" info
@@ -1015,18 +1010,15 @@
     }
 
     // Setup local Data members
-    psWin->SetDeviceName(NS_ConvertUTF8toUTF16(device).get());
-    psWin->SetDriverName(NS_ConvertUTF8toUTF16(driver).get());
+    psWin->SetDeviceName(device);
+    psWin->SetDriverName(driver);
 
 #if defined(DEBUG_rods) || defined(DEBUG_dcone)
-    printf("printer: driver %s, device %s  flags: %d\n", driver, device, prntdlg.Flags);
+    wprintf(L"printer: driver %s, device %s  flags: %d\n", driver, device, prntdlg.Flags);
 #endif
     // fill the print options with the info from the dialog
-    nsDependentCString printerNameNative(device);
-    nsAutoString printerName;
-    NS_CopyNativeToUnicode(printerNameNative, printerName);
 
-    aPrintSettings->SetPrinterName(printerName.get());
+    aPrintSettings->SetPrinterName(device);
 
     if (prntdlg.Flags & PD_SELECTION) {
       aPrintSettings->SetPrintRange(nsIPrintSettings::kRangeSelection);
@@ -1247,10 +1239,8 @@
   aPrintSettings->GetPrinterName(&printerName);
   HGLOBAL hGlobalDevMode = NULL;
   if (printerName) {
-    nsCAutoString tempPrinterName;
-    rv = NS_CopyUnicodeToNative(nsDependentString(printerName), tempPrinterName));
     NS_ENSURE_SUCCESS(rv, rv);
-    hGlobalDevMode = CreateGlobalDevModeAndInit(tempPrinterName.get(), aPrintSettings);
+    hGlobalDevMode = CreateGlobalDevModeAndInit(printerName, aPrintSettings);
   }
 
   // Prepare to Display the Print Dialog
@@ -1407,7 +1397,7 @@
     ::GlobalUnlock(prntdlg.hDevNames);
 
     // Transfer the settings from the native data to the PrintSettings
-    LPDEVMODE devMode = (LPDEVMODE)::GlobalLock(prntdlg.hDevMode);
+    LPDEVMODEW devMode = (LPDEVMODEW)::GlobalLock(prntdlg.hDevMode);
     if (devMode == NULL) {
       ::GlobalFree(hGlobalDevMode);
       return NS_ERROR_FAILURE;
diff -r 17e9560465b0 gfx/public/nsColorNames.h
--- a/gfx/public/nsColorNames.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/gfx/public/nsColorNames.h	Thu Oct 30 05:41:45 2008 -0400
@@ -38,39 +38,12 @@
 #ifndef nsColorNames_h___
 #define nsColorNames_h___
 
-#include "nsColor.h"
 #include "gfxCore.h"
-#include "nsStringFwd.h"
-
-/*
-   Declare the enum list using the magic of preprocessing
-   enum values are "eColorName_foo" (where foo is the color name)
-
-   To change the list of colors, see nsColorNameList.h
-
- */
-#define GFX_COLOR(_name, _value) eColorName_##_name,
-enum nsColorName {
-  eColorName_UNKNOWN = -1,
-#include "nsColorNameList.h"
-  eColorName_COUNT
-};
-#undef GFX_COLOR
 
 class NS_GFX nsColorNames {
 public:
   static void AddRefTable(void);
   static void ReleaseTable(void);
-
-  // Given a color name, return the color enum value
-  // This only functions provided a valid ref on the table
-  static nsColorName LookupName(const nsAString& aName);
-  static nsColorName LookupName(const nsACString& aName);
-
-  static const nsAFlatCString& GetStringValue(nsColorName aColorName);
-
-  // Color id to rgb value table
-  static NS_GFX_STATIC_MEMBER_(const nscolor) kColors[];
 };
 
 #endif /* nsColorNames_h___ */
diff -r 17e9560465b0 gfx/src/Makefile.in
--- a/gfx/src/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/gfx/src/Makefile.in	Thu Oct 30 05:41:45 2008 -0400
@@ -67,7 +67,6 @@
 
 CPPSRCS = \
         nsColor.cpp \
-        nsColorNames.cpp \
         nsDeviceContext.cpp \
         nsFont.cpp \
         nsRect.cpp \
diff -r 17e9560465b0 gfx/src/nsColor.cpp
--- a/gfx/src/nsColor.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/gfx/src/nsColor.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -45,6 +45,56 @@
 #include "nsIServiceManager.h"
 #include <math.h>
 #include "prprf.h"
+#include "nsStaticNameTable.h"
+
+// define an array of all color names
+#define GFX_COLOR(_name, _value) #_name,
+static const char* const kColorNames[] = {
+#include "nsColorNameList.h"
+};
+#undef GFX_COLOR
+
+// define an array of all color name values
+#define GFX_COLOR(_name, _value) _value,
+static const nscolor kColors[] = {
+#include "nsColorNameList.h"
+};
+#undef GFX_COLOR
+
+#define eColorName_COUNT (NS_ARRAY_LENGTH(kColorNames))
+#define eColorName_UNKNOWN (-1)
+
+static nsStaticCaseInsensitiveNameTable* gColorTable = nsnull;
+
+void nsColorNames::AddRefTable(void) 
+{
+  NS_ASSERTION(!gColorTable, "pre existing array!");
+  if (!gColorTable) {
+    gColorTable = new nsStaticCaseInsensitiveNameTable();
+    if (gColorTable) {
+#ifdef DEBUG
+    {
+      // let's verify the table...
+      for (PRInt32 index = 0; index < eColorName_COUNT; ++index) {
+        nsCAutoString temp1(kColorNames[index]);
+        nsCAutoString temp2(kColorNames[index]);
+        ToLowerCase(temp1);
+        NS_ASSERTION(temp1.Equals(temp2), "upper case char in table");
+      }
+    }
+#endif      
+      gColorTable->Init(kColorNames, eColorName_COUNT); 
+    }
+  }
+}
+
+void nsColorNames::ReleaseTable(void)
+{
+  if (gColorTable) {
+    delete gColorTable;
+    gColorTable = nsnull;
+  }
+}
 
 static int ComponentValue(const PRUnichar* aColorSpec, int aLen, int color, int dpc)
 {
@@ -161,11 +211,13 @@
 
 NS_GFX_(PRBool) NS_ColorNameToRGB(const nsAString& aColorName, nscolor* aResult)
 {
-  nsColorName id = nsColorNames::LookupName(aColorName);
+  if (!gColorTable) return PR_FALSE;
+
+  PRInt32 id = gColorTable->Lookup(aColorName);
   if (eColorName_UNKNOWN < id) {
     NS_ASSERTION(id < eColorName_COUNT, "LookupName mess up");
-    if (nsnull != aResult) {
-      *aResult = nsColorNames::kColors[id];
+    if (aResult) {
+      *aResult = kColors[id];
     }
     return PR_TRUE;
   }
diff -r 17e9560465b0 gfx/src/nsColorNames.cpp
--- a/gfx/src/nsColorNames.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/gfx/src/nsColorNames.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -1,125 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 1999
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either of the GNU General Public License Version 2 or later (the "GPL"),
- * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#include "nsColorNames.h"
-#include "nsString.h"
-#include "nsStaticNameTable.h"
-#include "nsReadableUtils.h"
-
-// define an array of all color names
-#define GFX_COLOR(_name, _value) #_name,
-const char* const kColorNames[] = {
-#include "nsColorNameList.h"
-};
-#undef GFX_COLOR
-
-// define an array of all color name values
-#define GFX_COLOR(_name, _value) _value,
-const nscolor nsColorNames::kColors[] = {
-#include "nsColorNameList.h"
-};
-#undef GFX_COLOR
-
-static PRInt32 gTableRefCount;
-static nsStaticCaseInsensitiveNameTable* gColorTable;
-
-void
-nsColorNames::AddRefTable(void) 
-{
-  if (0 == gTableRefCount++) {
-    NS_ASSERTION(!gColorTable, "pre existing array!");
-    gColorTable = new nsStaticCaseInsensitiveNameTable();
-    if (gColorTable) {
-#ifdef DEBUG
-    {
-      // let's verify the table...
-      for (PRInt32 index = 0; index < eColorName_COUNT; ++index) {
-        nsCAutoString temp1(kColorNames[index]);
-        nsCAutoString temp2(kColorNames[index]);
-        ToLowerCase(temp1);
-        NS_ASSERTION(temp1.Equals(temp2), "upper case char in table");
-      }
-    }
-#endif      
-      gColorTable->Init(kColorNames, eColorName_COUNT); 
-    }
-  }
-}
-
-void
-nsColorNames::ReleaseTable(void) 
-{
-  if (0 == --gTableRefCount) {
-    if (gColorTable) {
-      delete gColorTable;
-      gColorTable = nsnull;
-    }
-  }
-}
-
-nsColorName 
-nsColorNames::LookupName(const nsACString& aColor)
-{
-  NS_ASSERTION(gColorTable, "no lookup table, needs addref");
-  if (gColorTable) {
-    return nsColorName(gColorTable->Lookup(aColor));
-  }  
-  return eColorName_UNKNOWN;
-}
-
-nsColorName 
-nsColorNames::LookupName(const nsAString& aColor)
-{
-  NS_ASSERTION(gColorTable, "no lookup table, needs addref");
-  if (gColorTable) {
-    return nsColorName(gColorTable->Lookup(aColor));
-  }  
-  return eColorName_UNKNOWN;
-}
-
-const nsAFlatCString& 
-nsColorNames::GetStringValue(nsColorName aColor)
-{
-  NS_ASSERTION(gColorTable, "no lookup table, needs addref");
-  if (gColorTable) {
-    return gColorTable->GetStringValue(PRInt32(aColor));
-  } else {
-    static nsDependentCString kNullStr("");
-    return kNullStr;
-  }
-}
-
diff -r 17e9560465b0 gfx/tests/DumpColors.cpp
--- a/gfx/tests/DumpColors.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/gfx/tests/DumpColors.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -1,52 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 1998
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either of the GNU General Public License Version 2 or later (the "GPL"),
- * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#include <stdio.h>
-#include "nsColor.h"
-#include "nsColorNames.h"
-#include "nsString.h"
-
-int main(int argc, char** argv)
-{
-  for (int i = 0; i < eColorName_COUNT; i++) {
-    nscolor rgba = nsColorNames::kColors[i];
-    printf("%s: NS_RGB(%d,%d,%d,%d)\n",
-       nsColorNames::GetStringValue(nsColorName(i)).get(),
-	   NS_GET_R(rgba), NS_GET_G(rgba), NS_GET_B(rgba), NS_GET_A(rgba));
-  }
-  return 0;
-}
diff -r 17e9560465b0 gfx/tests/Makefile.in
--- a/gfx/tests/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/gfx/tests/Makefile.in	Thu Oct 30 05:41:45 2008 -0400
@@ -50,7 +50,6 @@
 		  $(NULL)
 
 CPPSRCS		= \
-		DumpColors.cpp \
 		TestColorNames.cpp \
 		TestRect.cpp \
 		$(NULL)
diff -r 17e9560465b0 gfx/tests/TestColorNames.cpp
--- a/gfx/tests/TestColorNames.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/gfx/tests/TestColorNames.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -39,9 +39,24 @@
 
 #include <stdio.h>
 #include <string.h>
+#include "nsColor.h"
 #include "nsColorNames.h"
 #include "prprf.h"
 #include "nsString.h"
+
+// define an array of all color names
+#define GFX_COLOR(_name, _value) #_name,
+static const char* const kColorNames[] = {
+#include "nsColorNameList.h"
+};
+#undef GFX_COLOR
+
+// define an array of all color name values
+#define GFX_COLOR(_name, _value) _value,
+static const nscolor kColors[] = {
+#include "nsColorNameList.h"
+};
+#undef GFX_COLOR
 
 static const char* kJunkNames[] = {
   nsnull,
@@ -54,8 +69,7 @@
 
 int main(int argc, char** argv)
 {
-  nsColorName id;
-  nsColorName index;
+  nscolor rgb;
   int rv = 0;
 
   // Everything appears to assert if we don't do this first...
@@ -65,49 +79,30 @@
   // be in the table. Futz with the case to make sure any case will
   // work
     
-  index = eColorName_UNKNOWN;
-  while (PRInt32(index) < (PRInt32 (eColorName_COUNT) - 1)) {
+  for (int index = 0 ; index < NS_ARRAY_LENGTH(kColorNames); index++) {
     // Lookup color by name and make sure it has the right id
-    index = nsColorName(PRInt32(index) + 1);
-    nsCString tagName(nsColorNames::GetStringValue(index));
-    if (tagName.IsEmpty()) {
-      printf("bug: tagName for nsColorNames::GetStringValue(%d) is ''\n", index);
-      rv = -1;
-      continue;
-    }
+    nsCString tagName(kColorNames[index]);
 
-    id = nsColorNames::LookupName(NS_ConvertASCIItoUTF16(tagName));
-    if (id == eColorName_UNKNOWN) {
+    // Check that color lookup by name gets the right rgb value
+    if (!NS_ColorNameToRGB(NS_ConvertASCIItoUTF16(tagName), &rgb)) {
       printf("bug: can't find '%s'\n", tagName.get());
       rv = -1;
     }
-    if (id != index) {
-      printf("bug: name='%s' id=%d index=%d\n", tagName.get(), id, index);
+    if (rgb != kColors[index]) {
+      printf("bug: name='%s' ColorNameToRGB=%x kColors[%d]=%08x\n",
+             tagName.get(), rgb, index, kColors[index]);
       rv = -1;
     }
 
     // fiddle with the case to make sure we can still find it
     tagName.SetCharAt(tagName.CharAt(0) - 32, 0);
-    id = nsColorNames::LookupName(NS_ConvertASCIItoUTF16(tagName));
-    if (id == eColorName_UNKNOWN) {
+    if (!NS_ColorNameToRGB(NS_ConvertASCIItoUTF16(tagName), &rgb)) {
       printf("bug: can't find '%s'\n", tagName.get());
       rv = -1;
     }
-    if (id != index) {
-      printf("bug: name='%s' id=%d index=%d\n", tagName.get(), id, index);
-      rv = -1;
-    }
-
-    // Check that color lookup by name gets the right rgb value
-    nscolor rgb;
-    if (!NS_ColorNameToRGB(NS_ConvertASCIItoUTF16(tagName), &rgb)) {
-      printf("bug: name='%s' didn't NS_ColorNameToRGB\n", tagName.get());
-      rv = -1;
-    }
-    if (nsColorNames::kColors[index] != rgb) {
-      printf("bug: name='%s' ColorNameToRGB=%x kColors[%d]=%x\n",
-             tagName.get(), rgb, nsColorNames::kColors[index],
-             nsColorNames::kColors[index]);
+    if (rgb != kColors[index]) {
+      printf("bug: name='%s' ColorNameToRGB=%x kColors[%d]=%08x\n",
+             tagName.get(), rgb, index, kColors[index]);
       rv = -1;
     }
 
@@ -129,14 +124,15 @@
   }
 
   // Now make sure we don't find some garbage
-  for (int i = 0; i < (int) (sizeof(kJunkNames) / sizeof(const char*)); i++) {
-    const char* tag = kJunkNames[i];
-    id = nsColorNames::LookupName(NS_ConvertASCIItoUTF16(tag));
-    if (id > eColorName_UNKNOWN) {
-      printf("bug: found '%s'\n", tag ? tag : "(null)");
+  for (int i = 0; i < NS_ARRAY_LENGTH(kJunkNames); i++) {
+    nsCString tag(kJunkNames[i]);
+    if (NS_ColorNameToRGB(NS_ConvertASCIItoUTF16(tag), &rgb)) {
+      printf("bug: found '%s'\n", kJunkNames[i] ? kJunkNames[i] : "(null)");
       rv = -1;
     }
   }
 
+  nsColorNames::ReleaseTable();
+
   return rv;
 }
diff -r 17e9560465b0 gfx/thebes/public/gfxContext.h
--- a/gfx/thebes/public/gfxContext.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/gfx/thebes/public/gfxContext.h	Thu Oct 30 05:41:45 2008 -0400
@@ -615,7 +615,15 @@
          * When this flag is set, snapping to device pixels is disabled.
          * It simply never does anything.
          */
-        FLAG_DISABLE_SNAPPING = (1 << 1)
+        FLAG_DISABLE_SNAPPING = (1 << 1),
+        /**
+         * When this flag is set, rendering through this context
+         * is destined to be (eventually) drawn on the screen. It can be
+         * useful to know this, for example so that windowed plugins are
+         * not unnecessarily rendered (since they will already appear
+         * on the screen, thanks to their windows).
+         */
+        FLAG_DESTINED_FOR_SCREEN = (1 << 2)
     };
 
     void SetFlag(PRInt32 aFlag) { mFlags |= aFlag; }
diff -r 17e9560465b0 gfx/thebes/public/gfxFontUtils.h
--- a/gfx/thebes/public/gfxFontUtils.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/gfx/thebes/public/gfxFontUtils.h	Thu Oct 30 05:41:45 2008 -0400
@@ -317,11 +317,11 @@
     }
     
     static nsresult
-    ReadCMAPTableFormat12(PRUint8 *aBuf, PRInt32 aLength, 
+    ReadCMAPTableFormat12(PRUint8 *aBuf, PRUint32 aLength, 
                           gfxSparseBitSet& aCharacterMap);
     
     static nsresult 
-    ReadCMAPTableFormat4(PRUint8 *aBuf, PRInt32 aLength, 
+    ReadCMAPTableFormat4(PRUint8 *aBuf, PRUint32 aLength, 
                          gfxSparseBitSet& aCharacterMap);
 
     static nsresult
@@ -336,9 +336,15 @@
     // EOT header on output aIsCFF returns whether the font has PS style
     // glyphs or not (as opposed to TrueType glyphs)
     static nsresult
-    MakeEOTHeader(nsIFile *aFontData, nsTArray<PRUint8> *aHeader, PRBool *aIsCFF);
+    MakeEOTHeader(const PRUint8 *aFontData, PRUint32 aFontDataLength,
+                            nsTArray<PRUint8> *aHeader, PRBool *aIsCFF);
 #endif
 
+    // checks for valid SFNT table structure, returns true if valid
+    // does *not* guarantee that all font data is valid
+    static PRBool
+    ValidateSFNTHeaders(const PRUint8 *aFontData, PRUint32 aFontDataLength);
+    
     static inline bool IsJoiner(PRUint32 ch) {
         return (ch == 0x200C ||
                 ch == 0x200D ||
diff -r 17e9560465b0 gfx/thebes/public/gfxPlatform.h
--- a/gfx/thebes/public/gfxPlatform.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/gfx/thebes/public/gfxPlatform.h	Thu Oct 30 05:41:45 2008 -0400
@@ -60,7 +60,6 @@
 class gfxFontGroup;
 struct gfxFontStyle;
 class gfxUserFontSet;
-struct gfxDownloadedFontData;
 class gfxFontEntry;
 class nsIURI;
 
@@ -200,10 +199,8 @@
     /**
      * Activate a platform font (needed to support @font-face src url() )
      *
-     * Note: MakePlatformFont implementation is responsible for removing font file data, since data may need to 
-     * persist beyond this call.
      */
-    virtual gfxFontEntry* MakePlatformFont(const gfxFontEntry *aProxyEntry, const gfxDownloadedFontData* aFontData) { return nsnull; }
+    virtual gfxFontEntry* MakePlatformFont(const gfxFontEntry *aProxyEntry, const PRUint8 *aFontData, PRUint32 aLength) { return nsnull; }
 
     /**
      * Whether to allow downloadable fonts via @font-face rules
diff -r 17e9560465b0 gfx/thebes/public/gfxPlatformMac.h
--- a/gfx/thebes/public/gfxPlatformMac.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/gfx/thebes/public/gfxPlatformMac.h	Thu Oct 30 05:41:45 2008 -0400
@@ -71,7 +71,7 @@
 
     gfxFontEntry* LookupLocalFont(const nsAString& aFontName);
 
-    gfxFontEntry* MakePlatformFont(const gfxFontEntry *aProxyEntry, const gfxDownloadedFontData* aFontData);
+    gfxFontEntry* MakePlatformFont(const gfxFontEntry *aProxyEntry, const PRUint8 *aFontData, PRUint32 aLength);
 
     PRBool IsFontFormatSupported(nsIURI *aFontURI, PRUint32 aFormatFlags);
 
diff -r 17e9560465b0 gfx/thebes/public/gfxUserFontSet.h
--- a/gfx/thebes/public/gfxUserFontSet.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/gfx/thebes/public/gfxUserFontSet.h	Thu Oct 30 05:41:45 2008 -0400
@@ -61,20 +61,6 @@
     // (e.g. TrueType, EOT, SVG, etc.)
     // see FLAG_FORMAT_* enum values below
     PRUint32               mFormatFlags;
-};
-
-// data needed to initialize platform font
-// After download completes, platform-specific code is responsible for
-// removing temp file and managing cache token. Depending on the
-// platform, these may need to persist after the platform font has been
-// created.
-// lifetime: time during which font is downloaded and active
-struct gfxDownloadedFontData {
-    nsCOMPtr<nsIFile>      mFontFile;     // file containing font data
-    nsCOMPtr<nsISupports>  mDownloader;   // need to a ref to this to prevent file from being deleted
-
-    // format hint flags, union of all possible formats
-    PRUint32               mFormatFlags;  // opentype, truetype, svg, etc. (if known)
 };
 
 // subclassed by loader code to contain needed context info
@@ -216,7 +202,7 @@
     // returns true if platform font creation sucessful (or local()
     // reference was next in line)
     PRBool OnLoadComplete(gfxFontEntry *aFontToLoad, 
-                          const gfxDownloadedFontData& aFontData, 
+                          const PRUint8 *aFontData, PRUint32 aLength,
                           nsresult aDownloadStatus);
 
     // generation - each time a face is loaded, generation is
diff -r 17e9560465b0 gfx/thebes/public/gfxWindowsPlatform.h
--- a/gfx/thebes/public/gfxWindowsPlatform.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/gfx/thebes/public/gfxWindowsPlatform.h	Thu Oct 30 05:41:45 2008 -0400
@@ -86,7 +86,7 @@
     /**
      * Activate a platform font (needed to support @font-face src url() )
      */
-    virtual gfxFontEntry* MakePlatformFont(const gfxFontEntry *aProxyEntry, const gfxDownloadedFontData* aFontData);
+    virtual gfxFontEntry* MakePlatformFont(const gfxFontEntry *aProxyEntry, const PRUint8 *aFontData, PRUint32 aLength);
 
     /**
      * Check whether format is supported on a platform or not (if unclear, returns true)
diff -r 17e9560465b0 gfx/thebes/src/gfxFont.cpp
--- a/gfx/thebes/src/gfxFont.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/gfx/thebes/src/gfxFont.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -2223,6 +2223,12 @@
         // be skipped; the last GlyphRun will cover its character range.
         if (i == 0 || runs[i].mFont != runs[i - 1].mFont) {
             mGlyphRuns.AppendElement(runs[i]);
+            // If two fonts have the same character offset, Sort() will have
+            // randomized the order.
+            NS_ASSERTION(i == 0 ||
+                         runs[i].mCharacterOffset !=
+                         runs[i - 1].mCharacterOffset,
+                         "Two fonts for the same run, glyph indices may not match the font");
         }
     }
 }
diff -r 17e9560465b0 gfx/thebes/src/gfxFontUtils.cpp
--- a/gfx/thebes/src/gfxFontUtils.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/gfx/thebes/src/gfxFontUtils.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -222,7 +222,7 @@
 
 
 nsresult
-gfxFontUtils::ReadCMAPTableFormat12(PRUint8 *aBuf, PRInt32 aLength, gfxSparseBitSet& aCharacterMap) 
+gfxFontUtils::ReadCMAPTableFormat12(PRUint8 *aBuf, PRUint32 aLength, gfxSparseBitSet& aCharacterMap) 
 {
     enum {
         OffsetFormat = 0,
@@ -262,7 +262,7 @@
 }
 
 nsresult 
-gfxFontUtils::ReadCMAPTableFormat4(PRUint8 *aBuf, PRInt32 aLength, gfxSparseBitSet& aCharacterMap)
+gfxFontUtils::ReadCMAPTableFormat4(PRUint8 *aBuf, PRUint32 aLength, gfxSparseBitSet& aCharacterMap)
 {
     enum {
         OffsetFormat = 0,
@@ -471,34 +471,31 @@
 
 }
 
-// for now, this is only needed on Windows
-
-#ifdef XP_WIN
-
 // TrueType/OpenType table handling code
 
 // need byte aligned structs
 #pragma pack(1)
 
 struct AutoSwap_PRUint16 {
-    operator PRUint16() { return NS_SWAP16(value); }
-    operator PRUint32() { return NS_SWAP16(value); }
-    PRUint16  value;
+    operator PRUint16() const { return NS_SWAP16(value); }
+    operator PRUint32() const { return NS_SWAP16(value); }
+    operator PRUint64() const { return NS_SWAP16(value); }
+    PRUint16 value;
 };
 
 struct AutoSwap_PRInt16 {
-    operator PRInt16() { return NS_SWAP16(value); }
-    operator PRUint32() { return NS_SWAP16(value); }
+    operator PRInt16() const { return NS_SWAP16(value); }
+    operator PRUint32() const { return NS_SWAP16(value); }
     PRInt16  value;
 };
 
 struct AutoSwap_PRUint32 {
-    operator PRUint32() { return NS_SWAP32(value); }
+    operator PRUint32() const { return NS_SWAP32(value); }
     PRUint32  value;
 };
 
 struct AutoSwap_PRUint64 {
-    operator PRUint64() { return NS_SWAP64(value); }
+    operator PRUint64() const { return NS_SWAP64(value); }
     PRUint64  value;
 };
 
@@ -519,7 +516,8 @@
 
 struct HeadTable {
     enum {
-        HEAD_MAGIC_NUMBER = 0x5F0F3CF5
+        HEAD_MAGIC_NUMBER = 0x5F0F3CF5,
+        HEAD_CHECKSUM_CALC_CONST = 0xB1B0AFBA
     };
 
     AutoSwap_PRUint32    tableVersionNumber;    // Fixed, 0x00010000 for version 1.0.
@@ -568,6 +566,15 @@
     };
 };
 
+// name table stores set of name record structures, followed by
+// large block containing all the strings.  name record offset and length
+// indicates the offset and length within that block.
+// http://www.microsoft.com/typography/otspec/name.htm
+struct NameRecordData {
+    PRUint32  offset;
+    PRUint32  length;
+};
+
 struct OS2Table {
     AutoSwap_PRUint16    version;                // 0004 = OpenType 1.5
     AutoSwap_PRInt16     xAvgCharWidth;
@@ -607,6 +614,189 @@
     AutoSwap_PRUint16    usBreakChar;
     AutoSwap_PRUint16    usMaxContext;
 };
+
+static PRBool
+IsValidSFNTVersion(PRUint32 version)
+{
+    // normally 0x00010000, CFF-style OT fonts == 'OTTO' and Apple TT fonts = 'true'
+    // 'typ1' is also possible for old Type 1 fonts in a SFNT container but not supported
+    return version == 0x10000 || version == 'OTTO' || version == 'true';
+}
+
+// copy and swap UTF-16 values, assume no surrogate pairs, can be in place
+static void
+CopySwapUTF16(const PRUint16 *aInBuf, PRUint16 *aOutBuf, PRUint32 aLen)
+{
+    const PRUint16 *end = aInBuf + aLen;
+    while (aInBuf < end) {
+        PRUint16 value = *aInBuf;
+        *aOutBuf = (value >> 8) | (value & 0xff) << 8;
+        aOutBuf++;
+        aInBuf++;
+    }
+}
+
+PRBool
+gfxFontUtils::ValidateSFNTHeaders(const PRUint8 *aFontData, PRUint32 aFontDataLength)
+{
+    NS_ASSERTION(aFontData && aFontDataLength != 0, "null font data");
+
+    PRUint64 dataLength(aFontDataLength);
+    
+    // read in the sfnt header
+    if (sizeof(SFNTHeader) > aFontDataLength) {
+        NS_WARNING("invalid font (insufficient data)");
+        return PR_FALSE;
+    }
+    
+    const SFNTHeader *sfntHeader = reinterpret_cast<const SFNTHeader*>(aFontData);
+    PRUint32 sfntVersion = sfntHeader->sfntVersion;
+    if (!IsValidSFNTVersion(sfntVersion)) {
+        NS_WARNING("invalid font (SFNT version)");
+        return PR_FALSE;
+    }
+
+    // iterate through the table headers to find the head, name and OS/2 tables
+    PRBool foundHead = PR_FALSE, foundOS2 = PR_FALSE, foundName = PR_FALSE;
+    PRBool foundGlyphs = PR_FALSE, foundCFF = PR_FALSE;
+    PRUint32 headOffset, headLen, nameOffset, nameLen;
+    PRUint32 i, numTables;
+
+    numTables = sfntHeader->numTables;
+    PRUint32 headerLen = sizeof(SFNTHeader) + sizeof(TableDirEntry) * numTables;
+    if (headerLen > aFontDataLength) {
+        NS_WARNING("invalid font (table directory)");
+        return PR_FALSE;
+    }
+    
+    // table directory entries begin immediately following SFNT header
+    const TableDirEntry *dirEntry = reinterpret_cast<const TableDirEntry*>(aFontData + sizeof(SFNTHeader));
+    PRUint32 checksum = 0;
+    
+    // checksum for font = (checksum of header) + (checksum of tables)
+    const AutoSwap_PRUint32 *headerData = reinterpret_cast<const AutoSwap_PRUint32*>(aFontData);
+
+    // header length is in bytes, checksum calculated in longwords
+    for (i = 0; i < (headerLen >> 2); i++, headerData++) {
+        checksum += *headerData;
+    }
+    
+    for (i = 0; i < numTables; i++, dirEntry++) {
+    
+        // sanity check on offset, length values
+        if (PRUint64(dirEntry->offset) + PRUint64(dirEntry->length) > dataLength) {
+            NS_WARNING("invalid font (table directory entry)");
+            return PR_FALSE;
+        }
+
+        checksum += dirEntry->checkSum;
+        
+        switch (dirEntry->tag) {
+
+        case 'head':
+            foundHead = PR_TRUE;
+            headOffset = dirEntry->offset;
+            headLen = dirEntry->length;
+            if (headLen < sizeof(HeadTable)) {
+                NS_WARNING("invalid font (head table length)");
+                return PR_FALSE;
+            }
+            break;
+
+        case 'name':
+            foundName = PR_TRUE;
+            nameOffset = dirEntry->offset;
+            nameLen = dirEntry->length;
+            break;
+
+        case 'OS/2':
+            foundOS2 = PR_TRUE;
+            break;
+
+        case 'glyf':  // TrueType-style quadratic glyph table
+            foundGlyphs = PR_TRUE;
+            break;
+
+        case 'CFF ':  // PS-style cubic glyph table
+            foundCFF = PR_TRUE;
+            break;
+
+        default:
+            break;
+        }
+
+    }
+
+    // simple sanity checks
+    
+    // -- fonts need head, name tables
+    if (!foundHead || !foundName) {
+        NS_WARNING("invalid font (missing head/name table)");
+        return PR_FALSE;
+    }
+    
+    // -- on Windows need OS/2 table
+#ifdef XP_WIN
+    if (!foundOS2) {
+        NS_WARNING("invalid font (missing OS/2 table)");
+        return PR_FALSE;
+    }
+#endif
+
+    // -- head table data
+    const HeadTable *headData = reinterpret_cast<const HeadTable*>(aFontData + headOffset);
+
+    if (headData->magicNumber != HeadTable::HEAD_MAGIC_NUMBER) {
+        NS_WARNING("invalid font (head magic number)");
+        return PR_FALSE;
+    }
+
+    if (headData->checkSumAdjustment != (HeadTable::HEAD_CHECKSUM_CALC_CONST - checksum)) {
+        NS_WARNING("invalid font (bad checksum)");
+        return PR_FALSE;
+    }
+    
+    // need glyf or CFF table based on sfnt version
+    if (sfntVersion == 'OTTO') {
+        if (!foundCFF) {
+            NS_WARNING("invalid font (missing CFF table)");
+            return PR_FALSE;
+        }
+    } else {
+        if (!foundGlyphs) {
+            NS_WARNING("invalid font (missing glyf table)");
+            return PR_FALSE;
+        }
+    }
+    
+    // -- name table data
+    const NameHeader *nameHeader = reinterpret_cast<const NameHeader*>(aFontData + nameOffset);
+
+    PRUint32 nameCount = nameHeader->count;
+
+    // -- sanity check the number of name records
+    if (PRUint64(nameCount) * sizeof(NameRecord) + PRUint64(nameOffset) > dataLength) {
+        NS_WARNING("invalid font (name records)");
+        return PR_FALSE;
+    }
+    
+    // -- iterate through name records
+    const NameRecord *nameRecord = reinterpret_cast<const NameRecord*>(aFontData + nameOffset + sizeof(NameHeader));
+    PRUint64 nameStringsBase = PRUint64(nameOffset) + PRUint64(nameHeader->stringOffset);
+
+    for (i = 0; i < nameCount; i++, nameRecord++) {
+        PRUint32 namelen = nameRecord->length;
+        PRUint32 nameoff = nameRecord->offset;  // offset from base of string storage
+
+        if (nameStringsBase + PRUint64(nameoff) + PRUint64(namelen) > dataLength) {
+            NS_WARNING("invalid font (name table strings)");
+            return PR_FALSE;
+        }
+    }
+
+    // everything seems consistent
+    return PR_TRUE;
+}
 
 // Embedded OpenType (EOT) handling
 // needed for dealing with downloadable fonts on Windows
@@ -657,6 +847,10 @@
 
 };
 
+// EOT headers are only used on Windows
+
+#ifdef XP_WIN
+
 // EOT variable-sized header (version 0x00020001 - contains 4 name
 // fields, each with the structure):
 //
@@ -676,61 +870,9 @@
 //   rootString  - used to restrict font usage to a specific domain
 //
 
-class AutoCloseFile {
-public:
-    AutoCloseFile(PRFileDesc *aFileDesc) 
-        : mFile(aFileDesc) { }
-    ~AutoCloseFile() { PR_Close(mFile); }
-    PRFileDesc *mFile;
-};
-
-static PRFileDesc *
-OpenFontFile(nsIFile *aFontData)
-{
-    // open up the font file
-    nsCOMPtr<nsILocalFile> localFile = do_QueryInterface(aFontData);
-    if (!localFile)
-        return nsnull;
-
-    PRFileDesc *fd;
-    nsresult rv = localFile->OpenNSPRFileDesc(PR_RDONLY, 0, &fd);
-    if (NS_FAILED(rv) || !fd)
-        return nsnull;
-
-    return fd;
-}
-
-static PRBool
-IsValidVersion(PRUint32 version)
-{
-    // normally 0x00010000, CFF-style OT fonts == 'OTTO' and Apple TT fonts = 'true'
-    return version == 0x10000 || version == 'OTTO' || version == 'true';
-}
-
-// copy and swap UTF-16 values, assume no surrogate pairs, can be in place
-static void
-CopySwapUTF16(PRUint16 *aInBuf, PRUint16 *aOutBuf, PRUint32 aLen)
-{
-    PRUint16 *end = aInBuf + aLen;
-    while (aInBuf < end) {
-        PRUint16 value = *aInBuf;
-        *aOutBuf = (value >> 8) | (value & 0xff) << 8;
-        aOutBuf++;
-        aInBuf++;
-    }
-}
-
-// name table stores set of name record structures, followed by
-// large block containing all the strings.  name record offset and length
-// indicates the offset and length within that block.
-// http://www.microsoft.com/typography/otspec/name.htm
-struct NameRecordData {
-    PRUint32  offset;
-    PRUint32  length;
-};
-
 #if DEBUG
-static void DumpEOTHeader(PRUint8 *aHeader, PRUint32 aHeaderLen)
+static void 
+DumpEOTHeader(PRUint8 *aHeader, PRUint32 aHeaderLen)
 {
     PRUint32 offset = 0;
     PRUint8 *ch = aHeader;
@@ -749,17 +891,17 @@
 #endif
 
 nsresult
-gfxFontUtils::MakeEOTHeader(nsIFile *aFontData, nsTArray<PRUint8> *aHeader, 
-                            PRBool *aIsCFF)
+gfxFontUtils::MakeEOTHeader(const PRUint8 *aFontData, PRUint32 aFontDataLength,
+                            nsTArray<PRUint8> *aHeader, PRBool *aIsCFF)
 {
-    PRInt32 bytesRead;
+
+    NS_ASSERTION(aFontData && aFontDataLength != 0, "null font data");
+    NS_ASSERTION(aHeader, "null header");
+    NS_ASSERTION(aHeader->Length() == 0, "non-empty header passed in");
+    NS_ASSERTION(aIsCFF, "null boolean ptr");
 
     // assume TrueType
     *aIsCFF = PR_FALSE;
-
-    NS_ASSERTION(aHeader, "null header");
-    NS_ASSERTION(aHeader->Length() == 0, "non-empty header passed in");
-    NS_ASSERTION(aIsCFF, "null boolean ptr");
 
     if (!aHeader->AppendElements(sizeof(EOTFixedHeader)))
         return NS_ERROR_OUT_OF_MEMORY;
@@ -767,19 +909,7 @@
     EOTFixedHeader *eotHeader = reinterpret_cast<EOTFixedHeader*> (aHeader->Elements());
     memset(eotHeader, 0, sizeof(EOTFixedHeader));
 
-    // open the font file
-    PRFileDesc *fd = OpenFontFile(aFontData);
-    if (!fd)
-        return NS_ERROR_FAILURE;
-
-    AutoCloseFile autoCloseFile(fd);
-
-    PRFileInfo64 fileInfo;
-    if (PR_GetOpenFileInfo64(fd, &fileInfo) != PR_SUCCESS 
-        || fileInfo.size > PRInt64(0xFFFFFFFF)) 
-        return NS_ERROR_FAILURE;
-
-    PRUint32 fontDataSize = PRUint32(fileInfo.size);
+    PRUint32 fontDataSize = aFontDataLength;
 
     // set up header fields
     eotHeader->fontDataSize = fontDataSize;
@@ -790,9 +920,11 @@
     eotHeader->magicNumber = EOTFixedHeader::EOT_MAGIC_NUMBER;
 
     // read in the sfnt header
-    SFNTHeader sfntHeader;
-    bytesRead = PR_Read(fd, &sfntHeader, sizeof(SFNTHeader));
-    if (bytesRead != sizeof(SFNTHeader) || !IsValidVersion(sfntHeader.sfntVersion))
+    if (sizeof(SFNTHeader) > aFontDataLength)
+        return NS_ERROR_FAILURE;
+    
+    const SFNTHeader *sfntHeader = reinterpret_cast<const SFNTHeader*>(aFontData);
+    if (!IsValidSFNTVersion(sfntHeader->sfntVersion))
         return NS_ERROR_FAILURE;
 
     // iterate through the table headers to find the head, name and OS/2 tables
@@ -800,33 +932,41 @@
     PRUint32 headOffset, headLen, nameOffset, nameLen, os2Offset, os2Len;
     PRUint32 i, numTables;
 
-    numTables = sfntHeader.numTables;
-    for (i = 0; i < numTables; i++) {
-        TableDirEntry dirEntry;
-        bytesRead = PR_Read(fd, &dirEntry, sizeof(TableDirEntry));
-        if (bytesRead != sizeof(TableDirEntry))
+    numTables = sfntHeader->numTables;
+    if (sizeof(SFNTHeader) + sizeof(TableDirEntry) * numTables > aFontDataLength)
+        return NS_ERROR_FAILURE;
+    
+    PRUint64 dataLength(aFontDataLength);
+    
+    // table directory entries begin immediately following SFNT header
+    const TableDirEntry *dirEntry = reinterpret_cast<const TableDirEntry*>(aFontData + sizeof(SFNTHeader));
+    
+    for (i = 0; i < numTables; i++, dirEntry++) {
+    
+        // sanity check on offset, length values
+        if (PRUint64(dirEntry->offset) + PRUint64(dirEntry->length) > dataLength)
             return NS_ERROR_FAILURE;
 
-        switch (dirEntry.tag) {
+        switch (dirEntry->tag) {
 
         case 'head':
             foundHead = PR_TRUE;
-            headOffset = dirEntry.offset;
-            headLen = dirEntry.length;
+            headOffset = dirEntry->offset;
+            headLen = dirEntry->length;
             if (headLen < sizeof(HeadTable))
                 return NS_ERROR_FAILURE;
             break;
 
         case 'name':
             foundName = PR_TRUE;
-            nameOffset = dirEntry.offset;
-            nameLen = dirEntry.length;
+            nameOffset = dirEntry->offset;
+            nameLen = dirEntry->length;
             break;
 
         case 'OS/2':
             foundOS2 = PR_TRUE;
-            os2Offset = dirEntry.offset;
-            os2Len = dirEntry.length;
+            os2Offset = dirEntry->offset;
+            os2Len = dirEntry->length;
             break;
 
         case 'glyf':  // TrueType-style quadratic glyph table
@@ -850,72 +990,62 @@
     if (!foundHead || !foundName || !foundOS2)
         return NS_ERROR_FAILURE;
 
+    // at this point, all table offset/length values are within bounds
+    
     // read in the data from those tables
-    PROffset64 offset;
 
     // -- head table data
-    HeadTable  headData;
-    offset = PR_Seek64(fd, PROffset64(headOffset), PR_SEEK_SET);
-    if (offset == -1)
-        return NS_ERROR_FAILURE;
-    bytesRead = PR_Read(fd, &headData, sizeof(HeadTable));
-    if (bytesRead != sizeof(HeadTable) || headData.magicNumber != HeadTable::HEAD_MAGIC_NUMBER)
+    const HeadTable  *headData = reinterpret_cast<const HeadTable*>(aFontData + headOffset);
+
+    if (headData->magicNumber != HeadTable::HEAD_MAGIC_NUMBER)
         return NS_ERROR_FAILURE;
 
-    eotHeader->checkSumAdjustment = headData.checkSumAdjustment;
+    eotHeader->checkSumAdjustment = headData->checkSumAdjustment;
 
     // -- name table data
 
     // -- first, read name table header
-    NameHeader nameHeader;
+    const NameHeader *nameHeader = reinterpret_cast<const NameHeader*>(aFontData + nameOffset);
 
-    offset = PR_Seek64(fd, PROffset64(nameOffset), PR_SEEK_SET);
-    if (offset == -1)
+    PRUint32 nameCount = nameHeader->count;
+
+    // -- sanity check the number of name records
+    if (PRUint64(nameCount) * sizeof(NameRecord) + PRUint64(nameOffset) > dataLength)
         return NS_ERROR_FAILURE;
-    bytesRead = PR_Read(fd, &nameHeader, sizeof(NameHeader));
-    if (bytesRead != sizeof(NameHeader))
-        return NS_ERROR_FAILURE;
-
-    // -- seek point is now at the start of name records
-
+    
     // -- iterate through name records, look for specific name ids with
     //    matching platform/encoding/etc. and store offset/lengths
     NameRecordData names[EOTFixedHeader::EOT_NUM_NAMES] = {0};
-    PRUint32 nameCount = nameHeader.count;
+    const NameRecord *nameRecord = reinterpret_cast<const NameRecord*>(aFontData + nameOffset + sizeof(NameHeader));
 
-    for (i = 0; i < nameCount; i++) {
-        NameRecord nameRecord;
-
-        bytesRead = PR_Read(fd, &nameRecord, sizeof(NameRecord));
-        if (bytesRead != sizeof(NameRecord))
-            return NS_ERROR_FAILURE;
+    for (i = 0; i < nameCount; i++, nameRecord++) {
 
         // looking for Microsoft English US name strings, skip others
-        if (PRUint32(nameRecord.platformID) != NameRecord::PLATFORM_ID_MICROSOFT || 
-                PRUint32(nameRecord.encodingID) != NameRecord::ENCODING_ID_MICROSOFT_UNICODEBMP || 
-                PRUint32(nameRecord.languageID) != NameRecord::LANG_ID_MICROSOFT_EN_US)
+        if (PRUint32(nameRecord->platformID) != NameRecord::PLATFORM_ID_MICROSOFT || 
+                PRUint32(nameRecord->encodingID) != NameRecord::ENCODING_ID_MICROSOFT_UNICODEBMP || 
+                PRUint32(nameRecord->languageID) != NameRecord::LANG_ID_MICROSOFT_EN_US)
             continue;
 
-        switch ((PRUint32)nameRecord.nameID) {
+        switch ((PRUint32)nameRecord->nameID) {
 
         case NameRecord::NAME_ID_FAMILY:
-            names[EOTFixedHeader::EOT_FAMILY_NAME_INDEX].offset = nameRecord.offset;
-            names[EOTFixedHeader::EOT_FAMILY_NAME_INDEX].length = nameRecord.length;
+            names[EOTFixedHeader::EOT_FAMILY_NAME_INDEX].offset = nameRecord->offset;
+            names[EOTFixedHeader::EOT_FAMILY_NAME_INDEX].length = nameRecord->length;
             break;
 
         case NameRecord::NAME_ID_STYLE:
-            names[EOTFixedHeader::EOT_STYLE_NAME_INDEX].offset = nameRecord.offset;
-            names[EOTFixedHeader::EOT_STYLE_NAME_INDEX].length = nameRecord.length;
+            names[EOTFixedHeader::EOT_STYLE_NAME_INDEX].offset = nameRecord->offset;
+            names[EOTFixedHeader::EOT_STYLE_NAME_INDEX].length = nameRecord->length;
             break;
 
         case NameRecord::NAME_ID_FULL:
-            names[EOTFixedHeader::EOT_FULL_NAME_INDEX].offset = nameRecord.offset;
-            names[EOTFixedHeader::EOT_FULL_NAME_INDEX].length = nameRecord.length;
+            names[EOTFixedHeader::EOT_FULL_NAME_INDEX].offset = nameRecord->offset;
+            names[EOTFixedHeader::EOT_FULL_NAME_INDEX].length = nameRecord->length;
             break;
 
         case NameRecord::NAME_ID_VERSION:
-            names[EOTFixedHeader::EOT_VERSION_NAME_INDEX].offset = nameRecord.offset;
-            names[EOTFixedHeader::EOT_VERSION_NAME_INDEX].length = nameRecord.length;
+            names[EOTFixedHeader::EOT_VERSION_NAME_INDEX].offset = nameRecord->offset;
+            names[EOTFixedHeader::EOT_VERSION_NAME_INDEX].length = nameRecord->length;
             break;
 
         default:
@@ -952,31 +1082,25 @@
 
     // append the string data to the end of the EOT header
     PRUint8 *eotEnd = aHeader->Elements() + sizeof(EOTFixedHeader);
-    PROffset64 strOffset;
-    PRUint32 strLen;
+    PRUint32 strOffset, strLen;
 
     for (i = 0; i < EOTFixedHeader::EOT_NUM_NAMES; i++) {
         PRUint32 namelen = names[i].length;
         PRUint32 nameoff = names[i].offset;  // offset from base of string storage
 
-        strOffset = nameOffset + PRUint32(nameHeader.stringOffset) + nameoff;
-        offset = PR_Seek64(fd, strOffset, PR_SEEK_SET);
-        if (offset == -1)
+        // sanity check the name string location
+        if (PRUint64(nameOffset) + PRUint64(PRUint32(nameHeader->stringOffset)) + PRUint64(nameoff) + PRUint64(namelen) > dataLength)
             return NS_ERROR_FAILURE;
+    
+        strOffset = nameOffset + PRUint32(nameHeader->stringOffset) + nameoff + namelen;
 
         // output 2-byte str size   
         strLen = namelen & (~1);  // UTF-16 string len must be even
         *((PRUint16*) eotEnd) = PRUint16(strLen);
         eotEnd += 2;
 
-        // read in actual string and swap bytes from big-endian
-        // (TrueType/OpenType) to little-endian (EOT)
-        bytesRead = PR_Read(fd, eotEnd, strLen);
-        if (PRUint32(bytesRead) != strLen)
-            return NS_ERROR_FAILURE;
-
         // length is number of UTF-16 chars, not bytes    
-        CopySwapUTF16(reinterpret_cast<PRUint16*>(eotEnd), 
+        CopySwapUTF16(reinterpret_cast<const PRUint16*>(aFontData + strOffset), 
                       reinterpret_cast<PRUint16*>(eotEnd), 
                       (strLen >> 1));  
         eotEnd += strLen;
@@ -999,24 +1123,18 @@
                  "header length calculation incorrect");
                  
     // -- OS/2 table data
-    OS2Table  os2Data;
-    offset = PR_Seek64(fd, PROffset64(os2Offset), PR_SEEK_SET);
-    if (offset == -1)
-        return NS_ERROR_FAILURE;
-    bytesRead = PR_Read(fd, &os2Data, sizeof(OS2Table));
-    if (bytesRead != sizeof(OS2Table))
-        return NS_ERROR_FAILURE;
+    const OS2Table *os2Data = reinterpret_cast<const OS2Table*>(aFontData + os2Offset);
 
-    memcpy(eotHeader->panose, os2Data.panose, sizeof(eotHeader->panose));
+    memcpy(eotHeader->panose, os2Data->panose, sizeof(eotHeader->panose));
 
-    eotHeader->italic = (PRUint16) os2Data.fsSelection & 0x01;
-    eotHeader->weight = os2Data.usWeightClass;
-    eotHeader->unicodeRange1 = os2Data.unicodeRange1;
-    eotHeader->unicodeRange2 = os2Data.unicodeRange2;
-    eotHeader->unicodeRange3 = os2Data.unicodeRange3;
-    eotHeader->unicodeRange4 = os2Data.unicodeRange4;
-    eotHeader->codePageRange1 = os2Data.codePageRange1;
-    eotHeader->codePageRange2 = os2Data.codePageRange2;
+    eotHeader->italic = (PRUint16) os2Data->fsSelection & 0x01;
+    eotHeader->weight = os2Data->usWeightClass;
+    eotHeader->unicodeRange1 = os2Data->unicodeRange1;
+    eotHeader->unicodeRange2 = os2Data->unicodeRange2;
+    eotHeader->unicodeRange3 = os2Data->unicodeRange3;
+    eotHeader->unicodeRange4 = os2Data->unicodeRange4;
+    eotHeader->codePageRange1 = os2Data->codePageRange1;
+    eotHeader->codePageRange2 = os2Data->codePageRange2;
 
     eotHeader->eotSize = aHeader->Length() + fontDataSize;
 
@@ -1025,4 +1143,4 @@
     return NS_OK;
 }
 
-#endif
+#endif
\ No newline at end of file
diff -r 17e9560465b0 gfx/thebes/src/gfxPangoFonts.cpp
--- a/gfx/thebes/src/gfxPangoFonts.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/gfx/thebes/src/gfxPangoFonts.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -2221,7 +2221,7 @@
         gfxFcFont *font =
             gfxPangoFcFont::GfxFont(GFX_PANGO_FC_FONT(item->analysis.font));
 
-        nsresult rv = aTextRun->AddGlyphRun(font, utf16Offset, PR_TRUE);
+        nsresult rv = aTextRun->AddGlyphRun(font, utf16Offset);
         if (NS_FAILED(rv)) {
             NS_ERROR("AddGlyphRun Failed");
             goto out;
@@ -2253,8 +2253,6 @@
             SetGlyphs(aTextRun, text, len, &utf16Offset, glyphString, spaceWidth, PR_FALSE);
         }
     }
-
-    aTextRun->SortGlyphRuns();
 
 out:
     if (glyphString)
diff -r 17e9560465b0 gfx/thebes/src/gfxPlatformMac.cpp
--- a/gfx/thebes/src/gfxPlatformMac.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/gfx/thebes/src/gfxPlatformMac.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -129,9 +129,9 @@
 }
 
 gfxFontEntry* 
-gfxPlatformMac::MakePlatformFont(const gfxFontEntry *aProxyEntry, const gfxDownloadedFontData* aFontData)
+gfxPlatformMac::MakePlatformFont(const gfxFontEntry *aProxyEntry, const PRUint8 *aFontData, PRUint32 aLength)
 {
-    return gfxQuartzFontCache::SharedFontCache()->MakePlatformFont(aProxyEntry, aFontData);
+    return gfxQuartzFontCache::SharedFontCache()->MakePlatformFont(aProxyEntry, aFontData, aLength);
 }
 
 PRBool
diff -r 17e9560465b0 gfx/thebes/src/gfxQuartzFontCache.h
--- a/gfx/thebes/src/gfxQuartzFontCache.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/gfx/thebes/src/gfxQuartzFontCache.h	Thu Oct 30 05:41:45 2008 -0400
@@ -227,7 +227,7 @@
 
     gfxFontEntry* LookupLocalFont(const nsAString& aFontName);
     
-    gfxFontEntry* MakePlatformFont(const gfxFontEntry *aProxyEntry, const gfxDownloadedFontData* aFontData);
+    gfxFontEntry* MakePlatformFont(const gfxFontEntry *aProxyEntry, const PRUint8 *aFontData, PRUint32 aLength);
 
 private:
     static PLDHashOperator FindFontForCharProc(nsStringHashKey::KeyType aKey,
diff -r 17e9560465b0 gfx/thebes/src/gfxQuartzFontCache.mm
--- a/gfx/thebes/src/gfxQuartzFontCache.mm	Thu Oct 23 09:51:35 2008 -0700
+++ b/gfx/thebes/src/gfxQuartzFontCache.mm	Thu Oct 30 05:41:45 2008 -0400
@@ -142,7 +142,7 @@
     mTraits = (mItalic ? NSItalicFontMask : NSUnitalicFontMask) |
               (mFixedPitch ? NSFixedPitchFontMask : 0) |
               (mWeight >= 600 ? NSBoldFontMask : NSUnboldFontMask);
-              
+
     // get the postscript name
     OSStatus err;
     NSString *psname = NULL;
@@ -154,11 +154,11 @@
         [psname release];
     } else {
         mIsValid = PR_FALSE;
-#if DEBUG
+#ifdef DEBUG
         char warnBuf[1024];
         sprintf(warnBuf, "ATSFontGetPostScriptName err = %d", (PRInt32)err);
         NS_WARNING(warnBuf);
-#endif    
+#endif        
     }
 }
 
@@ -1301,10 +1301,8 @@
 
 class MacOSUserFontData : public gfxUserFontData {
 public:
-    MacOSUserFontData(ATSFontContainerRef aContainerRef, nsIFile *aFontFile, 
-                      nsISupports *aDownloader)
-        : mContainerRef(aContainerRef), mFontFile(aFontFile), 
-          mDownloader(aDownloader)
+    MacOSUserFontData(ATSFontContainerRef aContainerRef)
+        : mContainerRef(aContainerRef)
     { }
 
     virtual ~MacOSUserFontData()
@@ -1312,84 +1310,83 @@
         // deactivate font
         if (mContainerRef)
             ATSFontDeactivate(mContainerRef, NULL, kATSOptionFlagsDefault);
-
-        if (mFontFile) {
-            mFontFile->Remove(PR_FALSE); // ignore errors
-        }
     }
 
     ATSFontContainerRef     mContainerRef;
-    nsCOMPtr<nsIFile>       mFontFile;
-
-    // maintaining a ref to this keeps temp file around or cache file pinned
-    nsCOMPtr<nsISupports>   mDownloader;  
 };
-
-static OSStatus
-MakeFSSpec(FSSpec *aFSSpec, NSString *path)
-{
-    FSRef fsref;
-    OSStatus err = FSPathMakeRef((UInt8*)([path fileSystemRepresentation]), &fsref, NULL);
-
-    if (err == noErr)
-        err = FSGetCatalogInfo(&fsref, kFSCatInfoNone, NULL, NULL, aFSSpec, NULL);
-
-    return err;
-}
 
 gfxFontEntry* 
 gfxQuartzFontCache::MakePlatformFont(const gfxFontEntry *aProxyEntry, 
-                                     const gfxDownloadedFontData* aFontData)
+                                     const PRUint8 *aFontData, PRUint32 aLength)
 {
     OSStatus err;
-    FSSpec spec;
-    nsAutoString filePath;
-
-    NS_ASSERTION(aFontData && aFontData->mFontFile, 
-                 "MakePlatformFont called with null file ptr");
-
-    if (!aFontData->mFontFile)
+    
+    NS_ASSERTION(aFontData && aLength != 0, 
+                 "MakePlatformFont called with null data ptr");
+                 
+    // do simple validation check on font data before 
+    // attempting to activate it
+    if (!gfxFontUtils::ValidateSFNTHeaders(aFontData, aLength)) {
+#if DEBUG
+        char warnBuf[1024];
+        const gfxProxyFontEntry *proxyEntry = 
+            static_cast<const gfxProxyFontEntry*> (aProxyEntry);
+        sprintf(warnBuf, "downloaded font error, invalid font data for (%s)",
+                NS_ConvertUTF16toUTF8(proxyEntry->mFamily->Name()).get());
+        NS_WARNING(warnBuf);
+#endif    
         return nsnull;
-
-    aFontData->mFontFile->GetPath(filePath);
-
-    NSString *path = GetNSStringForString(filePath);
-    if (!path)
-        return nsnull;
-
-    // assumption: filename is already in the form xxx.ttf, otherwise
-    // ATS will reject
-
-    err = MakeFSSpec(&spec, path);
-    if (err != noErr)
-        return nsnull;
+    }
 
     ATSUFontID fontID;
     ATSFontContainerRef containerRef;
 
-    err = ATSFontActivateFromFileSpecification(&spec, 
-                                               kPrivateATSFontContextPrivate, 
-                                               kATSFontFormatUnspecified,
-                                               NULL, 
-                                               kATSOptionFlagsDoNotNotify, 
-                                               &containerRef);
-    if (err != noErr)
+    err = ATSFontActivateFromMemory(const_cast<PRUint8*>(aFontData), aLength, 
+                                    kPrivateATSFontContextPrivate,
+                                    kATSFontFormatUnspecified,
+                                    NULL, 
+                                    kATSOptionFlagsDoNotNotify, 
+                                    &containerRef);
+
+    if (err != noErr) {
+#if DEBUG
+        char warnBuf[1024];
+        const gfxProxyFontEntry *proxyEntry = 
+            static_cast<const gfxProxyFontEntry*> (aProxyEntry);
+        sprintf(warnBuf, "downloaded font error, ATSFontActivateFromMemory err: %d for (%s)",
+                PRInt32(err),
+                NS_ConvertUTF16toUTF8(proxyEntry->mFamily->Name()).get());
+        NS_WARNING(warnBuf);
+#endif    
         return nsnull;
+    }
 
     mATSGeneration = ATSGeneration();
 
     // ignoring containers with multiple fonts, use the first face only for now
     err = ATSFontFindFromContainer(containerRef, kATSOptionFlagsDefault, 1, 
                                    (ATSFontRef*)&fontID, NULL);
-    if (err != noErr)
+    if (err != noErr) {
+#if DEBUG
+        char warnBuf[1024];
+        const gfxProxyFontEntry *proxyEntry = 
+            static_cast<const gfxProxyFontEntry*> (aProxyEntry);
+        sprintf(warnBuf, "downloaded font error, ATSFontFindFromContainer err: %d for (%s)",
+                PRInt32(err),
+                NS_ConvertUTF16toUTF8(proxyEntry->mFamily->Name()).get());
+        NS_WARNING(warnBuf);
+#endif  
+        ATSFontDeactivate(containerRef, NULL, kATSOptionFlagsDefault);
         return nsnull;
-
+    }
+    
     // font entry will own this
-    MacOSUserFontData *userFontData = new MacOSUserFontData(containerRef, 
-                                                            aFontData->mFontFile, 
-                                                            aFontData->mDownloader);
-    if (!userFontData)
+    MacOSUserFontData *userFontData = new MacOSUserFontData(containerRef);
+    
+    if (!userFontData) {
+        ATSFontDeactivate(containerRef, NULL, kATSOptionFlagsDefault);
         return nsnull;
+    }
 
     PRUint16 w = aProxyEntry->mWeight;
     NS_ASSERTION(w >= 100 && w <= 900, "bogus font weight value!");
@@ -1401,14 +1398,18 @@
                                        FONT_STYLE_NORMAL), 
                            userFontData);
 
+    if (!newFontEntry) {
+        delete userFontData;
+        return nsnull;
+    }
+    
     // if something is funky about this font, delete immediately
     if (newFontEntry && !newFontEntry->mIsValid) {
 #if DEBUG
         char warnBuf[1024];
         const gfxProxyFontEntry *proxyEntry = 
             static_cast<const gfxProxyFontEntry*> (aProxyEntry);
-        sprintf(warnBuf, "downloaded font not loaded properly, removed (%s) for (%s)", 
-                [path UTF8String], 
+        sprintf(warnBuf, "downloaded font not loaded properly, removed face for (%s)", 
                 NS_ConvertUTF16toUTF8(proxyEntry->mFamily->Name()).get());
         NS_WARNING(warnBuf);
 #endif    
diff -r 17e9560465b0 gfx/thebes/src/gfxUserFontSet.cpp
--- a/gfx/thebes/src/gfxUserFontSet.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/gfx/thebes/src/gfxUserFontSet.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -210,7 +210,7 @@
 
 PRBool 
 gfxUserFontSet::OnLoadComplete(gfxFontEntry *aFontToLoad, 
-                               const gfxDownloadedFontData& aFontData, 
+                               const PRUint8 *aFontData, PRUint32 aLength, 
                                nsresult aDownloadStatus)
 {
     NS_ASSERTION(aFontToLoad->mIsProxy, "trying to load font data for wrong font entry type");
@@ -222,7 +222,8 @@
 
     // download successful, make platform font using font data
     if (NS_SUCCEEDED(aDownloadStatus)) {
-        gfxFontEntry *fe = gfxPlatform::GetPlatform()->MakePlatformFont(pe, &aFontData);
+        gfxFontEntry *fe = 
+           gfxPlatform::GetPlatform()->MakePlatformFont(pe, aFontData, aLength);
         if (fe) {
             pe->mFamily->ReplaceFontEntry(pe, fe);
             IncrementGeneration();
@@ -231,13 +232,10 @@
                 nsCAutoString fontURI;
                 pe->mSrcList[pe->mSrcIndex].mURI->GetSpec(fontURI);
 
-                nsAutoString filePath;
-                aFontData.mFontFile->GetPath(filePath);
-
-                LOG(("userfonts (%p) [src %d] loaded uri: (%s) file: (%s) for (%s) gen: %8.8x\n", 
+                LOG(("userfonts (%p) [src %d] loaded uri: (%s) for (%s) gen: %8.8x\n", 
                      this, pe->mSrcIndex, fontURI.get(), 
-                     NS_ConvertUTF16toUTF8(filePath).get(), 
-                     NS_ConvertUTF16toUTF8(pe->mFamily->Name()).get(), PRUint32(mGeneration)));
+                     NS_ConvertUTF16toUTF8(pe->mFamily->Name()).get(), 
+                     PRUint32(mGeneration)));
             }
 #endif
             return PR_TRUE;
diff -r 17e9560465b0 gfx/thebes/src/gfxWindowsPlatform.cpp
--- a/gfx/thebes/src/gfxWindowsPlatform.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/gfx/thebes/src/gfxWindowsPlatform.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -722,57 +722,32 @@
 
 class EOTFontStreamReader {
 public:
-    EOTFontStreamReader(nsILocalFile *aFontFile, PRUint8 *aEOTHeader, 
+    EOTFontStreamReader(const PRUint8 *aFontData, PRUint32 aLength, PRUint8 *aEOTHeader, 
                         PRUint32 aEOTHeaderLen)
-        : mFontFile(aFontFile), mFd(nsnull), mOpenError(PR_FALSE), 
-          mInHeader(PR_TRUE), mHeaderOffset(0), mEOTHeader(aEOTHeader), 
-          mEOTHeaderLen(aEOTHeaderLen)
+        : mInHeader(PR_TRUE), mHeaderOffset(0), mEOTHeader(aEOTHeader), 
+          mEOTHeaderLen(aEOTHeaderLen), mFontData(aFontData), mFontDataLen(aLength),
+          mFontDataOffset(0)
     {
     
     }
 
     ~EOTFontStreamReader() 
     { 
-        if (mFd) {
-            PR_Close(mFd);
-        }
 
-        mFontFile->Remove(PR_FALSE);
     }
 
-    nsCOMPtr<nsILocalFile>  mFontFile;
-    PRFileDesc              *mFd;
-    PRPackedBool            mOpenError;
     PRPackedBool            mInHeader;
     PRUint32                mHeaderOffset;
     PRUint8                 *mEOTHeader;
     PRUint32                mEOTHeaderLen;
-
-    PRBool OpenFontFile()
-    {
-        nsresult rv;
-
-        rv = mFontFile->OpenNSPRFileDesc(PR_RDONLY, 0, &mFd);
-        if (NS_FAILED(rv) || !mFd)
-            return PR_FALSE;
-
-        return PR_TRUE;
-    }
+    const PRUint8           *mFontData;
+    PRUint32                mFontDataLen;
+    PRUint32                mFontDataOffset;
 
     unsigned long Read(void *outBuffer, const unsigned long aBytesToRead)
     {
         PRUint32 bytesLeft = aBytesToRead;
         PRUint8 *out = static_cast<PRUint8*> (outBuffer);
-
-        if (mOpenError)
-            return 0;
-
-        if (!mFd) {
-            if (!OpenFontFile()) {
-                mOpenError = PR_TRUE;
-                return 0;
-            }
-        }
 
         // read from EOT header
         if (mInHeader) {
@@ -786,7 +761,10 @@
         }
 
         if (bytesLeft) {
-            PRInt32 bytesRead = PR_Read(mFd, out, bytesLeft);
+            PRInt32 bytesRead = PR_MIN(bytesLeft, mFontDataLen - mFontDataOffset);
+            memcpy(out, mFontData, bytesRead);
+            mFontData += bytesRead;
+            mFontDataOffset += bytesRead;
             if (bytesRead > 0)
                 bytesLeft -= bytesRead;
         }
@@ -806,12 +784,15 @@
 
 gfxFontEntry* 
 gfxWindowsPlatform::MakePlatformFont(const gfxFontEntry *aProxyEntry, 
-                                     const gfxDownloadedFontData* aFontData)
+                                     const PRUint8 *aFontData, PRUint32 aLength)
 {
     // if calls aren't available, bail
     if (!TTLoadEmbeddedFontPtr || !TTDeleteEmbeddedFontPtr)
         return nsnull;
 
+    if (!gfxFontUtils::ValidateSFNTHeaders(aFontData, aLength))
+        return nsnull;
+        
     // create an eot header
     nsAutoTArray<PRUint8,2048> eotHeader;
     PRUint8 *buffer;
@@ -824,11 +805,7 @@
     PRInt32 ret;
 
     {
-        nsCOMPtr<nsILocalFile> fontFile(do_QueryInterface(aFontData->mFontFile, &rv));
-        if (NS_FAILED(rv))
-            return nsnull;
-
-        rv = gfxFontUtils::MakeEOTHeader(fontFile, &eotHeader, &isCFF);
+        rv = gfxFontUtils::MakeEOTHeader(aFontData, aLength, &eotHeader, &isCFF);
         if (NS_FAILED(rv))
             return nsnull;
 
@@ -838,7 +815,7 @@
         
         ULONG privStatus, pulStatus;
         MakeUniqueFontName(fontName);
-        EOTFontStreamReader eotReader(fontFile, buffer, eotlen);
+        EOTFontStreamReader eotReader(aFontData, aLength, buffer, eotlen);
 
         ret = TTLoadEmbeddedFontPtr(&fontRef, TTLOAD_PRIVATE, &privStatus, 
                                    LICENSE_PREVIEWPRINT, &pulStatus, 
diff -r 17e9560465b0 intl/build/intl.pkg
--- a/intl/build/intl.pkg	Thu Oct 23 09:51:35 2008 -0700
+++ b/intl/build/intl.pkg	Thu Oct 30 05:41:45 2008 -0400
@@ -23,13 +23,8 @@
 #if ENABLE_TESTS
 [gecko-tests]
 dist/bin/UnicharSelfTest@BINS@
-dist/bin/StringBundleTest@BINS@
 dist/bin/TestLineBreak@BINS@
 dist/bin/res/strres.properties
-dist/bin/res/strres-test.html
-dist/bin/res/strres-test.xul
-dist/bin/res/strres-test.dtd
-dist/bin/res/strres-test.js
 #if OS_ARCH==WINNT
 dist/bin/DetectCharset@BINS@
 #endif
diff -r 17e9560465b0 js/src/Makefile.in
--- a/js/src/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/Makefile.in	Thu Oct 30 05:41:45 2008 -0400
@@ -37,15 +37,24 @@
 #
 # ***** END LICENSE BLOCK *****
 
-DEPTH		= ../..
+DEPTH		= .
 topsrcdir	= @top_srcdir@
 srcdir		= @srcdir@
+
+DIRS		= config
 
 include $(DEPTH)/config/autoconf.mk
 
 MODULE		= js
 LIBRARY_NAME	= mozjs
 GRE_MODULE	= 1
+
+PROGRAM         = js$(BIN_SUFFIX)
+# The shell uses some 'HIDDEN' symbols to produce statistics, so we
+# link directly against the .o files, not against the JS shared
+# library.
+PROGOBJS	= js.$(OBJ_SUFFIX) $(OBJS)
+LIBS		= $(NSPR_LIBS)
 
 ifdef GNU_CC
 ifdef INTEL_CC
@@ -160,7 +169,8 @@
 		jsdtracef.c
 endif
 
-EXPORTS		= \
+INSTALLED_HEADERS = \
+		js-config.h \
 		jsautocfg.h \
 		jsautokw.h \
 		js.msg \
@@ -214,7 +224,7 @@
 ifdef ENABLE_JIT
 VPATH		+= $(srcdir)/nanojit
 
-EXPORTS += \
+INSTALLED_HEADERS += \
 		builtins.tbl    \
 		jsbuiltins.h    \
 		Assembler.h     \
@@ -247,14 +257,14 @@
 endif
 
 ifdef HAVE_DTRACE
-EXPORTS 	+= \
+INSTALLED_HEADERS += \
 		jsdtracef.h \
 		javascript-trace.h \
 		$(NULL)
 endif
 
 ifeq (,$(filter-out WINNT WINCE,$(OS_ARCH)))
-EXPORTS		+= jscpucfg.h
+INSTALLED_HEADERS += jscpucfg.h
 endif
 
 JS_SAFE_ARENA	= 1
@@ -322,6 +332,27 @@
 endif
 
 include $(topsrcdir)/config/rules.mk
+
+ifdef MOZ_SYNC_BUILD_FILES
+# Because the SpiderMonkey can be distributed and built independently
+# of the Mozilla source tree, it contains its own copies of many of
+# the files used by the top-level Mozilla build process, from the
+# 'config' and 'build' subtrees.
+#
+# To make it simpler to keep the copies in sync, we follow the policy
+# that the SpiderMonkey copies must always be exact copies of those in
+# the containing Mozilla tree.  If you've made a change in one, it
+# belongs in the other as well.  If the change isn't right for both
+# places, then that's something to bring up with the other developers.
+#
+# Some files are reasonable to diverge; for example,
+# js/config/autoconf.mk.in doesn't need most of the stuff in
+# config/autoconf.mk.in.
+check-sync-dirs = $(PYTHON) $(srcdir)/config/check-sync-dirs.py
+check::
+	$(check-sync-dirs) $(srcdir)/config $(MOZ_SYNC_BUILD_FILES)/config
+	$(check-sync-dirs) $(srcdir)/build $(MOZ_SYNC_BUILD_FILES)/build
+endif
 
 # our build system doesn't handle subdir srcs very gracefully today
 export::
@@ -481,6 +512,8 @@
 
 jsopcode.h jsopcode.cpp: jsopcode.tbl
 
+export:: jsautocfg.h
+
 ifeq (,$(CROSS_COMPILE)$(filter-out WINNT,$(OS_ARCH)))
 jsautocfg.h:
 	touch $@
@@ -541,6 +574,64 @@
 endif
 endif
 
+# Compute the linker flags that programs linking against SpiderMonkey should
+# pass to get SpiderMonkey and its dependencies, beyond just the -L and -l
+# for the SpiderMonkey library itself.
+# - EXTRA_DSO_LDOPTS includes the NSPR -L and -l flags.
+# - OS_LIBS includes libraries selected by the configure script.
+# - EXTRA_LIBS includes libraries selected by this Makefile.
+JS_CONFIG_LIBS=$(EXTRA_DSO_LDOPTS) $(OS_LIBS) $(EXTRA_LIBS) 
+
+# The configure script invokes this rule explicitly at configure time!
+# It's important that js-config be ready by the time we're done
+# configuring, because we may be running other configure scripts that
+# would like to run js-config themselves, before js is built.
+#
+# This file and rules.mk go through a certain amount of work to decide
+# which libraries to build, what to name them, and what flags to pass
+# when linking them (and thus what flags its own clients must pass).
+# All this information needs to go into the js-config script.  To
+# avoid trying to re-compute all that in the configure script, we just
+# have the configure script generate this Makefile, and then invoke
+# this rule.
+at=@
+js-config: js-config.in Makefile $(DEPTH)/config/autoconf.mk $(topsrcdir)/config/config.mk $(topsrcdir)/config/rules.mk
+	rm -f js-config.tmp
+	sed < $< > js-config.tmp \
+	-e 's|$(at)prefix$(at)|$(prefix)|' \
+	-e 's|$(at)exec_prefix$(at)|$(exec_prefix)|' \
+	-e 's|$(at)includedir$(at)|$(includedir)|' \
+	-e 's|$(at)libdir$(at)|$(libdir)|' \
+	-e 's|$(at)MOZILLA_VERSION$(at)|$(MOZILLA_VERSION)|' \
+	-e 's|$(at)LIBRARY_NAME$(at)|$(LIBRARY_NAME)|' \
+	-e 's|$(at)NSPR_CFLAGS$(at)|$(NSPR_CFLAGS)|' \
+	-e 's|$(at)JS_CONFIG_LIBS$(at)|$(JS_CONFIG_LIBS)|' \
+	-e 's|$(at)MOZ_JS_LIBS$(at)|$(MOZ_JS_LIBS)|' \
+	&& mv js-config.tmp $@ && chmod +x $@
+
+SCRIPTS = js-config
+
+install:: $(INSTALLED_HEADERS)
+	$(SYSINSTALL) $(IFLAGS1) $^ $(includedir)/$(MODULE)
+
+install:: $(SCRIPTS) $(PROGRAM)
+	$(SYSINSTALL) $(IFLAGS2) $^ $(bindir)
+
+# The Mozilla top-level makefiles use install-runtime-libs directly to
+# place an additional copy of the libraries in the 'dist/bin'
+# directory.
+install:: install-runtime-libs
+install-runtime-libs:: $(LIBRARY) $(SHARED_LIBRARY) $(IMPORT_LIBRARY)
+ifneq (,$(LIBRARY))
+	$(SYSINSTALL) $(IFLAGS1) $(LIBRARY) $(libdir)
+endif
+ifneq (,$(SHARED_LIBRARY))
+	$(SYSINSTALL) $(IFLAGS2) $(SHARED_LIBRARY) $(libdir)
+endif
+ifneq (,$(IMPORT_LIBRARY))
+	$(SYSINSTALL) $(IFLAGS2) $(IMPORT_LIBRARY) $(libdir)
+endif
+
 # Extra dependancies and rules for auto-generated headers
 host_jskwgen.$(OBJ_SUFFIX): jsversion.h jskeyword.tbl
 
diff -r 17e9560465b0 js/src/Makefile.ref
--- a/js/src/Makefile.ref	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,449 +0,0 @@
-# -*- Mode: makefile -*-
-# vim: ft=make
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#   Michael Ang <mang@subcarrier.org>
-#   Kevin Buhr <buhr@stat.wisc.edu>
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either of the GNU General Public License Version 2 or later (the "GPL"),
-# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# JSRef GNUmake makefile.
-#
-# Note: dependency rules are missing for some files (some
-#       .h, all .msg, etc.)  Re-make clean if in doubt.
-#
-
-
-DEPTH = .
-
-include config.mk
-
-#NS_USE_NATIVE = 1
-
-ifndef NANOJIT_ARCH
-$(warning NANOJIT_ARCH not defined in config/$(OS_CONFIG).mk, JIT disabled)
-else
-ifdef DISABLE_JIT
-$(warning disabling JIT per build specification)
-else
-ENABLE_JIT=1
-endif
-endif
-
-ifdef ENABLE_JIT
-DEFINES += -DJS_TRACER
-DEFINES += -DFEATURE_NANOJIT
-INCLUDES += -Inanojit
-endif
-
-#ifndef BUILD_OPT
-#DEFINES += -Ivprof
-#endif
-
-ifdef NARCISSUS
-DEFINES += -DNARCISSUS
-endif
-
-# Look in OBJDIR to find jsautocfg.h and jsautokw.h
-INCLUDES   += -I. -I$(OBJDIR)
-
-ifdef JS_THREADSAFE
-DEFINES += -DJS_THREADSAFE
-INCLUDES += -I$(DIST)/include/nspr
-ifdef USE_MSVC
-OTHER_LIBS += $(DIST)/lib/libnspr$(NSPR_LIBSUFFIX).lib
-else
-OTHER_LIBS += -L$(DIST)/lib -lnspr$(NSPR_LIBSUFFIX)
-endif
-endif
-
-ifdef JS_NO_THIN_LOCKS
-DEFINES += -DJS_USE_ONLY_NSPR_LOCKS
-endif
-
-ifdef JS_HAS_FILE_OBJECT
-DEFINES += -DJS_HAS_FILE_OBJECT
-endif
-
-
-#
-# XCFLAGS may be set in the environment or on the gmake command line
-#
-#CFLAGS += -DDEBUG -DDEBUG_brendan -DJS_ARENAMETER -DJS_HASHMETER -DJS_DUMP_PROPTREE_STATS -DJS_DUMP_SCOPE_METERS -DJS_SCOPE_DEPTH_METER -DJS_BASIC_STATS
-CFLAGS          += $(OPTIMIZER) $(OS_CFLAGS) $(DEFINES) $(INCLUDES) $(XCFLAGS)
-INTERP_CFLAGS   += $(INTERP_OPTIMIZER) $(OS_CFLAGS) $(DEFINES) $(INCLUDES) $(XCFLAGS) $(INTERP_XCFLAGS)
-BUILTINS_CFLAGS += $(BUILTINS_OPTIMIZER) $(OS_CFLAGS) $(DEFINES) $(INCLUDES) $(XCFLAGS) $(BUILTINS_XCFLAGS)
-
-LDFLAGS		= $(XLDFLAGS)
-LDFLAGS += $(OS_LDFLAGS)
-
-ifdef MOZ_SHARK
-DEFINES += -DMOZ_SHARK
-CFLAGS += -F/System/Library/PrivateFrameworks
-LDFLAGS += -F/System/Library/PrivateFrameworks -framework CHUD
-endif
-ifdef MOZ_CALLGRIND
-DEFINES += -DMOZ_CALLGRIND
-endif
-ifdef MOZ_VTUNE
-DEFINES += -DMOZ_VTUNE
-CXXFLAGS += -IC:/Program\ Files/Intel/VTune/Analyzer/Include
-OTHER_LIBS += C:/Program\ Files/Intel/VTune/Analyzer/Lib/VtuneApi.lib
-endif
-
-ifndef NO_LIBM
-LDFLAGS += -lm
-endif
-
-# Prevent floating point errors caused by VC++ optimizations
-ifeq ($(OS_ARCH),WINNT)
-_MSC_VER = $(shell $(CXX) 2>&1 | sed -n 's/.*Compiler Version \([0-9]*\)\.\([0-9]*\).*/\1\2/p')
-ifeq (,$(filter-out 1200 1300 1310,$(_MSC_VER)))
-CFLAGS += -Op
-else
-CFLAGS += -fp:precise
-endif
-endif # WINNT
-
-#
-#	Server-related changes :
-#
-ifdef NES40
-DEFINES += -DNES40
-endif
-
-#
-# Line editing support.
-# Define JS_READLINE or JS_EDITLINE to enable line editing in the
-# js command-line interpreter.
-#
-ifdef JS_READLINE
-# For those platforms with the readline library installed.
-DEFINES += -DEDITLINE
-PROG_LIBS += -lreadline -ltermcap
-else
-ifdef JS_EDITLINE
-# Use the editline library, built locally.
-PREDIRS += editline
-DEFINES += -DEDITLINE
-PROG_LIBS += $(OBJDIR)/editline/libedit.a
-endif
-endif
-
-# For purify
-PURE_CFLAGS     = -DXP_UNIX $(OPTIMIZER) $(PURE_OS_CFLAGS) $(DEFINES) \
-                  $(INCLUDES) $(XCFLAGS)
-
-#
-# JS file lists
-#
-JS_HFILES =		\
-	jsarray.h	\
-	jsatom.h	\
-	jsbool.h	\
-	jscntxt.h	\
-	jsdate.h	\
-	jsemit.h	\
-	jsexn.h		\
-	jsfun.h		\
-	jsgc.h		\
-	jsinterp.h	\
-	jsiter.h	\
-	jslibmath.h	\
-	jslock.h	\
-	jsmath.h	\
-	jsnum.h		\
-	jsobj.h		\
-	json.h		\
-	jsopcode.h	\
-	jsparse.h	\
-	jsarena.h	\
-	jsclist.h	\
-	jsdhash.h	\
-	jsdtoa.h	\
-	jshash.h	\
-	jslong.h	\
-	jstypes.h	\
-	jsprvtd.h	\
-	jspubtd.h	\
-	jsregexp.h	\
-	jsscan.h	\
-	jsscope.h	\
-	jsscript.h	\
-	jsstr.h		\
-	jsversion.h	\
-	jsxdrapi.h	\
-	jsxml.h		\
-	$(NULL)
-
-ifdef ENABLE_JIT
-JS_HFILES +=			\
-	jstracer.h		\
-	nanojit/Assembler.h     \
-	nanojit/LIR.h		\
-	nanojit/Native$(NANOJIT_ARCH).h	\
-	nanojit/avmplus.h	\
-	nanojit/vm_fops.h	\
-	nanojit/Fragmento.h	\
-	nanojit/Native.h	\
-	nanojit/RegAlloc.h	\
-	nanojit/nanojit.h	\
-	nanojit/TraceTreeDrawer.h \
-	$(NULL)
-endif
-
-ifndef BUILD_OPT
-#JS_HFILES +=            \
-#        vprof/vprof.h   \
-#        $(NULL)
-endif
-
-API_HFILES =		\
-	jsapi.h		\
-	jsdbgapi.h	\
-	$(NULL)
-
-OTHER_HFILES =		\
-	jsbit.h		\
-	jscompat.h	\
-	jscpucfg.h	\
-	jsotypes.h	\
-	jsstddef.h	\
-	prmjtime.h	\
-	resource.h	\
-	jsopcode.tbl	\
-	jsproto.tbl     \
-	js.msg		\
-	jsshell.msg	\
-	jskeyword.tbl	\
-	$(NULL)
-
-ifdef ENABLE_JIT
-OTHER_HFILES += builtins.tbl
-endif
-
-ifndef PREBUILT_CPUCFG
-OTHER_HFILES += $(OBJDIR)/jsautocfg.h
-endif
-OTHER_HFILES += $(OBJDIR)/jsautokw.h
-
-HFILES = $(JS_HFILES) $(API_HFILES) $(OTHER_HFILES)
-
-JS_CPPFILES =		\
-	jsapi.cpp	\
-	jsarena.cpp	\
-	jsarray.cpp	\
-	jsatom.cpp	\
-	jsbool.cpp	\
-	jscntxt.cpp	\
-	jsdate.cpp	\
-	jsdbgapi.cpp	\
-	jsdhash.cpp	\
-	jsdtoa.cpp	\
-	jsemit.cpp	\
-	jsexn.cpp	\
-	jsfun.cpp	\
-	jsgc.cpp	\
-	jshash.cpp	\
-	jsinterp.cpp	\
-	jsinvoke.cpp    \
-	jsiter.cpp	\
-	jslock.cpp	\
-	jslog2.cpp	\
-	jslong.cpp	\
-	jsmath.cpp	\
-	jsnum.cpp	\
-	jsobj.cpp	\
-	json.cpp	\
-	jsopcode.cpp	\
-	jsparse.cpp	\
-	jsprf.cpp	\
-	jsregexp.cpp	\
-	jsscan.cpp	\
-	jsscope.cpp	\
-	jsscript.cpp	\
-	jsstr.cpp	\
-	jsutil.cpp	\
-	jsxdrapi.cpp	\
-	jsxml.cpp	\
-	prmjtime.cpp	\
-	$(NULL)
-
-ifdef ENABLE_JIT
-JS_CPPFILES +=		       \
-	jsbuiltins.cpp         \
-	jstracer.cpp	       \
-	nanojit/Assembler.cpp  \
-	nanojit/Fragmento.cpp  \
-	nanojit/LIR.cpp        \
-	nanojit/Native$(NANOJIT_ARCH).cpp \
-	nanojit/RegAlloc.cpp   \
-	nanojit/avmplus.cpp    \
-	$(NULL)
-
-ifdef DEBUG
-JS_CPPFILES += nanojit/TraceTreeDrawer.cpp
-endif
-endif
-
-ifndef BUILD_OPT
-#JS_CPPFILES +=                 \
-#        vprof/vprof.cpp        \
-#        $(NULL)
-endif
-
-ifdef JS_LIVECONNECT
-DIRS      += liveconnect
-endif
-
-ifdef JS_HAS_FILE_OBJECT
-JS_CPPFILES += jsfile.cpp
-JS_HFILES += jsfile.h
-endif
-
-LIB_CPPFILES  = $(JS_CPPFILES)
-LIB_ASFILES := $(wildcard *_$(OS_ARCH).s)
-PROG_CPPFILES = js.cpp
-
-ifdef USE_MSVC
-LIBRARY = $(OBJDIR)/js32.lib
-SHARED_LIBRARY = $(OBJDIR)/js32.dll
-PROGRAM = $(OBJDIR)/js.exe
-else
-LIBRARY = $(OBJDIR)/libjs.a
-SHARED_LIBRARY = $(OBJDIR)/libjs.$(SO_SUFFIX)
-PROGRAM = $(OBJDIR)/js
-endif
-
-include rules.mk
-
-MOZ_DEPTH = ../..
-include jsconfig.mk
-
-nsinstall-target:
-	cd ../../config; $(MAKE) OBJDIR=$(OBJDIR) OBJDIR_NAME=$(OBJDIR)
-
-#
-# Automatic header generation
-#
-
-AUTO_HEADERS = $(OBJDIR)/jsautokw.h $(OBJDIR)/jsautooplen.h
-
-$(OBJDIR)/jsautokw.h: jskeyword.tbl
-
-$(OBJDIR)/jsautooplen.h: jsopcode.tbl
-
-GARBAGE += $(AUTO_HEADERS)
-GARBAGE	+= $(AUTO_HEADERS:$(OBJDIR)/jsauto%.h=$(OBJDIR)/js%gen$(HOST_BIN_SUFFIX))
-
-ifdef USE_MSVC
-
-GARBAGE	+= $(AUTO_HEADERS:$(OBJDIR)/jsauto%.h=$(OBJDIR)/js%gen.obj)
-
-$(AUTO_HEADERS): $(OBJDIR)/jsauto%.h: js%gen.cpp
-	@$(MAKE_OBJDIR)
-	$(CXX) -Fo$(OBJDIR)/ -c $(CFLAGS) $<
-	link.exe -out:"$(OBJDIR)/js$*gen$(HOST_BIN_SUFFIX)" $(EXE_LINK_FLAGS) $(OBJDIR)/js$*gen.obj
-	$(OBJDIR)/js$*gen$(HOST_BIN_SUFFIX) $@
-else
-
-GARBAGE	+= $(AUTO_HEADERS:$(OBJDIR)/jsauto%.h=$(OBJDIR)/js%gen.d)
-$(AUTO_HEADERS): $(OBJDIR)/jsauto%.h: js%gen.cpp
-	@$(MAKE_OBJDIR)
-	$(CXX) -o $(OBJDIR)/js$*gen$(HOST_BIN_SUFFIX) $(CFLAGS) $(LDFLAGS) $<
-	$(OBJDIR)/js$*gen$(HOST_BIN_SUFFIX) $@
-
-endif
-
-# force creation of autoheaders before compiling any source that may use them
-$(LIB_OBJS) : $(AUTO_HEADERS)
-
-#
-# JS shell executable
-#
-
-ifdef USE_MSVC
-$(PROGRAM): $(PROG_OBJS) $(LIBRARY)
-	link.exe -out:"$@" $(EXE_LINK_FLAGS) $^
-else
-$(PROGRAM): $(PROG_OBJS) $(LIBRARY)
-	$(CXX) -o $@ $(CFLAGS) $(PROG_OBJS) $(LIBRARY) $(LDFLAGS) $(OTHER_LIBS) \
-	    $(PROG_LIBS)
-endif
-
-$(PROGRAM).pure: $(PROG_OBJS) $(LIBRARY)
-	purify $(PUREFLAGS) \
-	    $(CXX) -o $@ $(PURE_OS_CFLAGS) $(PROG_OBJS) $(LIBRARY) $(LDFLAGS) \
-		$(OTHER_LIBS) $(PROG_LIBS)
-
-ifndef PREBUILT_CPUCFG
-$(filter-out jscpucfg.h $(OBJDIR)/jsautocfg.h, $(HFILES)) $(CPPFILES): $(OBJDIR)/jsautocfg.h
-
-$(OBJDIR)/jsautocfg.h: $(OBJDIR)/jscpucfg
-	rm -f $@
-	$(OBJDIR)/jscpucfg > $@
-
-$(OBJDIR)/jscpucfg: $(OBJDIR)/jscpucfg.o
-	$(CXX) $(OS_LDFLAGS) -o $@ $(OBJDIR)/jscpucfg.o
-
-GARBAGE += $(OBJDIR)/jsautocfg.h $(OBJDIR)/jscpucfg \
-	   $(OBJDIR)/jscpucfg.o $(OBJDIR)/jscpucfg.d
-endif
-
-# Automatic make dependencies files
-DEPENDENCIES    = $(CPPFILES:%.cpp=$(OBJDIR)/%.d)
-
-#
-# Hardwire dependencies for some files 
-#
-ifdef USE_MSVC
-OBJ=obj
-else
-OBJ=o
-endif
-
-$(OBJDIR)/jsinvoke.$(OBJ): jsinterp.h jsinterp.cpp
-$(OBJDIR)/jsinvoke.obj : jsinterp.h jsinterp.cpp
-
--include $(DEPENDENCIES)
-
-TARNAME = jsref.tar
-TARFILES = files `cat files`
-
-SUFFIXES: .i
-%.i: %.cpp
-	$(CXX) -C -E $(CFLAGS) $< > $*.i
diff -r 17e9560465b0 js/src/aclocal.m4
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/aclocal.m4	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,10 @@
+dnl
+dnl Local autoconf macros used with mozilla
+dnl The contents of this file are under the Public Domain.
+dnl 
+
+builtin(include, build/autoconf/glib.m4)dnl
+builtin(include, build/autoconf/pkg.m4)dnl
+builtin(include, build/autoconf/nspr.m4)dnl
+builtin(include, build/autoconf/altoptions.m4)dnl
+
diff -r 17e9560465b0 js/src/build.mk
--- a/js/src/build.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,42 +0,0 @@
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is the Mozilla build system.
-#
-# The Initial Developer of the Original Code is
-# the Mozilla Foundation <http://www.mozilla.org/>.
-# Portions created by the Initial Developer are Copyright (C) 2006
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#   Benjamin Smedberg <benjamin@smedbergs.us> (Initial Code)
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-TIERS += js
-
-tier_js_dirs += \
-	js/src \
-	$(NULL)
diff -r 17e9560465b0 js/src/build/autoconf/acoutput-fast.pl
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/build/autoconf/acoutput-fast.pl	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,202 @@
+#! /usr/bin/env perl
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+# Netscape Communications Corporation.
+# Portions created by the Initial Developer are Copyright (C) 1999
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+# acoutput-fast.pl - Quickly create makefiles that are in a common format.
+#
+# Most of the makefiles in mozilla only refer to two configure variables:
+#     @srcdir@
+#     @top_srcdir@
+# However, configure does not know any better and it runs sed on each file
+# with over 150 replacement rules (slow as molasses).
+#
+# This script takes a list of makefiles as input. For example,
+#   
+#     echo $MAKEFILES | acoutput-fast.pl
+#
+# The script creates each Makefile that only references @srcdir@ and
+# @top_srcdir@. For other files, it lists them in a shell command that is
+# printed to stdout:
+#
+#     CONFIG_FILES="unhandled_files..."; export CONFIG_FILES
+#
+# This command can be used to have config.status create the unhandled
+# files. For example,
+#
+#     eval "echo $MAKEFILES | acoutput-fast.pl"
+#     AC_OUTPUT($MAKEFILES)
+#
+# Send comments, improvements, bugs to Steve Lamm (slamm@netscape.com).
+
+#use File::Basename;
+sub dirname {
+  my $dir = $_[0];
+  return '.' if not $dir =~ m%/%;
+  $dir =~ s%/[^/][^/]*$%%;
+  return $dir;
+}
+
+# Create one directory. Assumes it doesn't already exist.
+# Will create parent(s) if needed.
+sub create_directory {
+  my $dir = $_[0];
+  my $parent = dirname($dir);
+  create_directory($parent) if not -d $parent;
+  mkdir "$dir",0777;
+}
+
+# Create all the directories at once.
+#   This can be much faster than calling mkdir() for each one.
+sub create_directories {
+  my @makefiles = @_;
+  my @dirs = ();
+  my $ac_file;
+  foreach $ac_file (@makefiles) {
+    push @dirs, dirname($ac_file);
+  }
+  # Call mkdir with the directories sorted by subdir count (how many /'s)
+  if (@dirs) {
+    foreach $dir (@dirs) {
+      if (not -d $dir) {
+        print STDERR "Creating directory $dir\n";
+        create_directory($dir);
+      }
+    }
+  }
+}
+
+while($arg = shift) {
+    if ($arg =~ /^--srcdir=/) {
+        $ac_given_srcdir = (split /=/, $arg)[1];
+    }
+    if ($arg =~ /^--cygwin-srcdir/) {
+        $ac_cygwin_srcdir = (split /=/, $arg)[1];
+    }
+}
+
+if (!$ac_given_srcdir) {
+  $ac_given_srcdir = $0;
+  $ac_given_srcdir =~ s|/?build/autoconf/.*$||;
+  $ac_given_srcdir = '.' if $ac_given_srcdir eq '';
+}
+
+if (!$ac_cygwin_srcdir) {
+    $ac_cygwin_srcdir = $ac_given_srcdir;
+}
+
+# Read list of makefiles from the stdin or,
+#   from files listed on the command-line.
+#
+@makefiles=();
+push @makefiles, split while (<STDIN>);
+
+# Create all the directories at once.
+#   This can be much faster than calling mkdir() for each one.
+create_directories(@makefiles);
+
+# Output the makefiles.
+#
+@unhandled=();
+foreach $ac_file (@makefiles) {
+  if (not $ac_file =~ /Makefile$/ or $ac_file =~ /:/) {
+    push @unhandled, $ac_file;
+    next;
+  }
+  $ac_file_in = "$ac_given_srcdir/$ac_file.in";
+  $ac_dir = dirname($ac_file);
+  if ($ac_dir eq '.') {
+    $ac_dir_suffix = '';
+    $ac_dots = '';
+  } else {
+    $ac_dir_suffix = "/$ac_dir";
+    $ac_dir_suffix =~ s%^/\./%/%;
+    $ac_dots = $ac_dir_suffix;
+    $ac_dots =~ s%/[^/]*%../%g;
+  }
+  if ($ac_given_srcdir eq '.') {
+    $srcdir = '.';
+    if ($ac_dots eq '') {
+      $top_srcdir = '.'
+    } else {
+      $top_srcdir = $ac_dots;
+      $top_srcdir =~ s%/$%%;
+    }
+  } elsif ($ac_cygwin_srcdir =~ m%^/% or $ac_cygwin_srcdir =~ m%^.:/%) {
+    $srcdir     = "$ac_cygwin_srcdir$ac_dir_suffix";
+    $top_srcdir = "$ac_cygwin_srcdir";
+  } else {
+    $srcdir     = "$ac_dots$ac_cygwin_srcdir$ac_dir_suffix";
+    $top_srcdir = "$ac_dots$ac_cygwin_srcdir";
+  }
+
+  if (-e $ac_file) {
+    next if -M _ < -M $ac_file_in;
+    print STDERR "updating $ac_file\n";
+  } else {
+    print STDERR "creating $ac_file\n";
+  }
+
+  open (INFILE, "<$ac_file_in")
+    or ( warn "can't read $ac_file_in: No such file or directory\n" and next);
+  open (OUTFILE, ">$ac_file")
+    or ( warn "Unable to create $ac_file\n" and next);
+
+  while (<INFILE>) {
+    #if (/\@[_a-zA-Z]*\@.*\@[_a-zA-Z]*\@/) {
+    #  warn "Two defines on a line:$ac_file:$.:$_";
+    #  push @unhandled, $ac_file;
+    #  last;
+    #}
+
+    s/\@srcdir\@/$srcdir/g;
+    s/\@top_srcdir\@/$top_srcdir/g;
+
+    if (/\@[_a-zA-Z]*\@/) {
+      warn "Unknown variable:$ac_file:$.:$_";
+      push @unhandled, $ac_file;
+      last;
+    }
+    print OUTFILE;
+  }
+  close INFILE;
+  close OUTFILE;
+}
+
+# Print the shell command to be evaluated by configure.
+#
+print "CONFIG_FILES=\"".join(' ', @unhandled)."\"; export CONFIG_FILES\n";
+
diff -r 17e9560465b0 js/src/build/autoconf/altoptions.m4
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/build/autoconf/altoptions.m4	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,154 @@
+dnl ***** BEGIN LICENSE BLOCK *****
+dnl Version: MPL 1.1/GPL 2.0/LGPL 2.1
+dnl
+dnl The contents of this file are subject to the Mozilla Public License Version
+dnl 1.1 (the "License"); you may not use this file except in compliance with
+dnl the License. You may obtain a copy of the License at
+dnl http://www.mozilla.org/MPL/
+dnl
+dnl Software distributed under the License is distributed on an "AS IS" basis,
+dnl WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+dnl for the specific language governing rights and limitations under the
+dnl License.
+dnl
+dnl The Original Code is mozilla.org code.
+dnl
+dnl The Initial Developer of the Original Code is
+dnl Netscape Communications Corporation.
+dnl Portions created by the Initial Developer are Copyright (C) 1999
+dnl the Initial Developer. All Rights Reserved.
+dnl
+dnl Contributor(s):
+dnl
+dnl Alternatively, the contents of this file may be used under the terms of
+dnl either of the GNU General Public License Version 2 or later (the "GPL"),
+dnl or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+dnl in which case the provisions of the GPL or the LGPL are applicable instead
+dnl of those above. If you wish to allow use of your version of this file only
+dnl under the terms of either the GPL or the LGPL, and not to allow others to
+dnl use your version of this file under the terms of the MPL, indicate your
+dnl decision by deleting the provisions above and replace them with the notice
+dnl and other provisions required by the GPL or the LGPL. If you do not delete
+dnl the provisions above, a recipient may use your version of this file under
+dnl the terms of any one of the MPL, the GPL or the LGPL.
+dnl
+dnl ***** END LICENSE BLOCK *****
+
+dnl altoptions.m4 - An alternative way of specifying command-line options.
+dnl    These macros are needed to support a menu-based configurator.
+dnl    This file also includes the macro, AM_READ_MYCONFIG, for reading
+dnl    the 'myconfig.m4' file.
+
+dnl Send comments, improvements, bugs to Steve Lamm (slamm@netscape.com).
+
+
+dnl MOZ_ARG_ENABLE_BOOL(           NAME, HELP, IF-YES [, IF-NO [, ELSE]])
+dnl MOZ_ARG_DISABLE_BOOL(          NAME, HELP, IF-NO [, IF-YES [, ELSE]])
+dnl MOZ_ARG_ENABLE_STRING(         NAME, HELP, IF-SET [, ELSE])
+dnl MOZ_ARG_ENABLE_BOOL_OR_STRING( NAME, HELP, IF-YES, IF-NO, IF-SET[, ELSE]]])
+dnl MOZ_ARG_WITH_BOOL(             NAME, HELP, IF-YES [, IF-NO [, ELSE])
+dnl MOZ_ARG_WITHOUT_BOOL(          NAME, HELP, IF-NO [, IF-YES [, ELSE])
+dnl MOZ_ARG_WITH_STRING(           NAME, HELP, IF-SET [, ELSE])
+dnl MOZ_ARG_HEADER(Comment)
+dnl MOZ_CHECK_PTHREADS(            NAME, IF-YES [, ELSE ])
+dnl MOZ_READ_MYCONFIG() - Read in 'myconfig.sh' file
+
+
+dnl MOZ_TWO_STRING_TEST(NAME, VAL, STR1, IF-STR1, STR2, IF-STR2 [, ELSE])
+AC_DEFUN([MOZ_TWO_STRING_TEST],
+[if test "[$2]" = "[$3]"; then
+    ifelse([$4], , :, [$4])
+  elif test "[$2]" = "[$5]"; then
+    ifelse([$6], , :, [$6])
+  else
+    ifelse([$7], ,
+      [AC_MSG_ERROR([Option, [$1], does not take an argument ([$2]).])],
+      [$7])
+  fi])
+
+dnl MOZ_ARG_ENABLE_BOOL(NAME, HELP, IF-YES [, IF-NO [, ELSE]])
+AC_DEFUN([MOZ_ARG_ENABLE_BOOL],
+[AC_ARG_ENABLE([$1], [$2], 
+ [MOZ_TWO_STRING_TEST([$1], [$enableval], yes, [$3], no, [$4])],
+ [$5])])
+
+dnl MOZ_ARG_DISABLE_BOOL(NAME, HELP, IF-NO [, IF-YES [, ELSE]])
+AC_DEFUN([MOZ_ARG_DISABLE_BOOL],
+[AC_ARG_ENABLE([$1], [$2],
+ [MOZ_TWO_STRING_TEST([$1], [$enableval], no, [$3], yes, [$4])],
+ [$5])])
+
+dnl MOZ_ARG_ENABLE_STRING(NAME, HELP, IF-SET [, ELSE])
+AC_DEFUN([MOZ_ARG_ENABLE_STRING],
+[AC_ARG_ENABLE([$1], [$2], [$3], [$4])])
+
+dnl MOZ_ARG_ENABLE_BOOL_OR_STRING(NAME, HELP, IF-YES, IF-NO, IF-SET[, ELSE]]])
+AC_DEFUN([MOZ_ARG_ENABLE_BOOL_OR_STRING],
+[ifelse([$5], , 
+ [errprint([Option, $1, needs an "IF-SET" argument.
+])
+  m4exit(1)],
+ [AC_ARG_ENABLE([$1], [$2],
+  [MOZ_TWO_STRING_TEST([$1], [$enableval], yes, [$3], no, [$4], [$5])],
+  [$6])])])
+
+dnl MOZ_ARG_WITH_BOOL(NAME, HELP, IF-YES [, IF-NO [, ELSE])
+AC_DEFUN([MOZ_ARG_WITH_BOOL],
+[AC_ARG_WITH([$1], [$2],
+ [MOZ_TWO_STRING_TEST([$1], [$withval], yes, [$3], no, [$4])],
+ [$5])])
+
+dnl MOZ_ARG_WITHOUT_BOOL(NAME, HELP, IF-NO [, IF-YES [, ELSE])
+AC_DEFUN([MOZ_ARG_WITHOUT_BOOL],
+[AC_ARG_WITH([$1], [$2],
+ [MOZ_TWO_STRING_TEST([$1], [$withval], no, [$3], yes, [$4])],
+ [$5])])
+
+dnl MOZ_ARG_WITH_STRING(NAME, HELP, IF-SET [, ELSE])
+AC_DEFUN([MOZ_ARG_WITH_STRING],
+[AC_ARG_WITH([$1], [$2], [$3], [$4])])
+
+dnl MOZ_ARG_HEADER(Comment)
+dnl This is used by webconfig to group options
+define(MOZ_ARG_HEADER, [# $1])
+
+dnl
+dnl Apparently, some systems cannot properly check for the pthread
+dnl library unless <pthread.h> is included so we need to test
+dnl using it
+dnl
+dnl MOZ_CHECK_PTHREADS(lib, success, failure)
+AC_DEFUN([MOZ_CHECK_PTHREADS],
+[
+AC_MSG_CHECKING([for pthread_create in -l$1])
+echo "
+    #include <pthread.h>
+    #include <stdlib.h>
+    void *foo(void *v) { int a = 1;  } 
+    int main() { 
+        pthread_t t;
+        if (!pthread_create(&t, 0, &foo, 0)) {
+            pthread_join(t, 0);
+        }
+        exit(0);
+    }" > dummy.c ;
+    echo "${CC-cc} -o dummy${ac_exeext} dummy.c $CFLAGS $CPPFLAGS -l[$1] $LDFLAGS $LIBS" 1>&5;
+    ${CC-cc} -o dummy${ac_exeext} dummy.c $CFLAGS $CPPFLAGS -l[$1] $LDFLAGS $LIBS 2>&5;
+    _res=$? ;
+    rm -f dummy.c dummy${ac_exeext} ;
+    if test "$_res" = "0"; then
+        AC_MSG_RESULT([yes])
+        [$2]
+    else
+        AC_MSG_RESULT([no])
+        [$3]
+    fi
+])
+
+dnl MOZ_READ_MYCONFIG() - Read in 'myconfig.sh' file
+AC_DEFUN([MOZ_READ_MOZCONFIG],
+[AC_REQUIRE([AC_INIT_BINSH])dnl
+# Read in '.mozconfig' script to set the initial options.
+# See the mozconfig2configure script for more details.
+_AUTOCONF_TOOLS_DIR=`dirname [$]0`/[$1]/build/autoconf
+. $_AUTOCONF_TOOLS_DIR/mozconfig2configure])
diff -r 17e9560465b0 js/src/build/autoconf/config.guess
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/build/autoconf/config.guess	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,1481 @@
+#! /bin/sh
+# Attempt to guess a canonical system name.
+#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
+#   2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+
+timestamp='2005-10-13'
+
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
+# 02110-1301, USA.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+
+# Originally written by Per Bothner <per@bothner.com>.
+# Please send patches to <config-patches@gnu.org>.  Submit a context
+# diff and a properly formatted ChangeLog entry.
+#
+# This script attempts to guess a canonical system name similar to
+# config.sub.  If it succeeds, it prints the system name on stdout, and
+# exits with 0.  Otherwise, it exits with 1.
+#
+# The plan is that this can be called by configure scripts if you
+# don't specify an explicit build system type.
+
+me=`echo "$0" | sed -e 's,.*/,,'`
+
+usage="\
+Usage: $0 [OPTION]
+
+Output the configuration name of the system \`$me' is run on.
+
+Operation modes:
+  -h, --help         print this help, then exit
+  -t, --time-stamp   print date of last modification, then exit
+  -v, --version      print version number, then exit
+
+Report bugs and patches to <config-patches@gnu.org>."
+
+version="\
+GNU config.guess ($timestamp)
+
+Originally written by Per Bothner.
+Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
+Free Software Foundation, Inc.
+
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
+
+help="
+Try \`$me --help' for more information."
+
+# Parse command line
+while test $# -gt 0 ; do
+  case $1 in
+    --time-stamp | --time* | -t )
+       echo "$timestamp" ; exit ;;
+    --version | -v )
+       echo "$version" ; exit ;;
+    --help | --h* | -h )
+       echo "$usage"; exit ;;
+    -- )     # Stop option processing
+       shift; break ;;
+    - )	# Use stdin as input.
+       break ;;
+    -* )
+       echo "$me: invalid option $1$help" >&2
+       exit 1 ;;
+    * )
+       break ;;
+  esac
+done
+
+if test $# != 0; then
+  echo "$me: too many arguments$help" >&2
+  exit 1
+fi
+
+trap 'exit 1' 1 2 15
+
+# CC_FOR_BUILD -- compiler used by this script. Note that the use of a
+# compiler to aid in system detection is discouraged as it requires
+# temporary files to be created and, as you can see below, it is a
+# headache to deal with in a portable fashion.
+
+# Historically, `CC_FOR_BUILD' used to be named `HOST_CC'. We still
+# use `HOST_CC' if defined, but it is deprecated.
+
+# Portable tmp directory creation inspired by the Autoconf team.
+
+set_cc_for_build='
+trap "exitcode=\$?; (rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null) && exit \$exitcode" 0 ;
+trap "rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null; exit 1" 1 2 13 15 ;
+: ${TMPDIR=/tmp} ;
+ { tmp=`(umask 077 && mktemp -d -q "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
+ { test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir $tmp) ; } ||
+ { tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir $tmp) && echo "Warning: creating insecure temp directory" >&2 ; } ||
+ { echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; } ;
+dummy=$tmp/dummy ;
+tmpfiles="$dummy.c $dummy.o $dummy.rel $dummy" ;
+case $CC_FOR_BUILD,$HOST_CC,$CC in
+ ,,)    echo "int x;" > $dummy.c ;
+	for c in cc gcc c89 c99 ; do
+	  if ($c -c -o $dummy.o $dummy.c) >/dev/null 2>&1 ; then
+	     CC_FOR_BUILD="$c"; break ;
+	  fi ;
+	done ;
+	if test x"$CC_FOR_BUILD" = x ; then
+	  CC_FOR_BUILD=no_compiler_found ;
+	fi
+	;;
+ ,,*)   CC_FOR_BUILD=$CC ;;
+ ,*,*)  CC_FOR_BUILD=$HOST_CC ;;
+esac ; set_cc_for_build= ;'
+
+# This is needed to find uname on a Pyramid OSx when run in the BSD universe.
+# (ghazi@noc.rutgers.edu 1994-08-24)
+if (test -f /.attbin/uname) >/dev/null 2>&1 ; then
+	PATH=$PATH:/.attbin ; export PATH
+fi
+
+UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
+UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
+UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
+UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
+
+# Note: order is significant - the case branches are not exclusive.
+
+case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
+    *:NetBSD:*:*)
+	# NetBSD (nbsd) targets should (where applicable) match one or
+	# more of the tupples: *-*-netbsdelf*, *-*-netbsdaout*,
+	# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently
+	# switched to ELF, *-*-netbsd* would select the old
+	# object file format.  This provides both forward
+	# compatibility and a consistent mechanism for selecting the
+	# object file format.
+	#
+	# Note: NetBSD doesn't particularly care about the vendor
+	# portion of the name.  We always set it to "unknown".
+	sysctl="sysctl -n hw.machine_arch"
+	UNAME_MACHINE_ARCH=`(/sbin/$sysctl 2>/dev/null || \
+	    /usr/sbin/$sysctl 2>/dev/null || echo unknown)`
+	case "${UNAME_MACHINE_ARCH}" in
+	    armeb) machine=armeb-unknown ;;
+	    arm*) machine=arm-unknown ;;
+	    sh3el) machine=shl-unknown ;;
+	    sh3eb) machine=sh-unknown ;;
+	    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;
+	esac
+	# The Operating System including object format, if it has switched
+	# to ELF recently, or will in the future.
+	case "${UNAME_MACHINE_ARCH}" in
+	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
+		eval $set_cc_for_build
+		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
+			| grep __ELF__ >/dev/null
+		then
+		    # Once all utilities can be ECOFF (netbsdecoff) or a.out (netbsdaout).
+		    # Return netbsd for either.  FIX?
+		    os=netbsd
+		else
+		    os=netbsdelf
+		fi
+		;;
+	    *)
+	        os=netbsd
+		;;
+	esac
+	# The OS release
+	# Debian GNU/NetBSD machines have a different userland, and
+	# thus, need a distinct triplet. However, they do not need
+	# kernel version information, so it can be replaced with a
+	# suitable tag, in the style of linux-gnu.
+	case "${UNAME_VERSION}" in
+	    Debian*)
+		release='-gnu'
+		;;
+	    *)
+		release=`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+		;;
+	esac
+	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
+	# contains redundant information, the shorter form:
+	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
+	echo "${machine}-${os}${release}"
+	exit ;;
+    *:OpenBSD:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
+	echo ${UNAME_MACHINE_ARCH}-unknown-openbsd${UNAME_RELEASE}
+	exit ;;
+    *:ekkoBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-ekkobsd${UNAME_RELEASE}
+	exit ;;
+    macppc:MirBSD:*:*)
+	echo powerppc-unknown-mirbsd${UNAME_RELEASE}
+	exit ;;
+    *:MirBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-mirbsd${UNAME_RELEASE}
+	exit ;;
+    alpha:OSF1:*:*)
+	case $UNAME_RELEASE in
+	*4.0)
+		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
+		;;
+	*5.*)
+	        UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`
+		;;
+	esac
+	# According to Compaq, /usr/sbin/psrinfo has been available on
+	# OSF/1 and Tru64 systems produced since 1995.  I hope that
+	# covers most systems running today.  This code pipes the CPU
+	# types through head -n 1, so we only detect the type of CPU 0.
+	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
+	case "$ALPHA_CPU_TYPE" in
+	    "EV4 (21064)")
+		UNAME_MACHINE="alpha" ;;
+	    "EV4.5 (21064)")
+		UNAME_MACHINE="alpha" ;;
+	    "LCA4 (21066/21068)")
+		UNAME_MACHINE="alpha" ;;
+	    "EV5 (21164)")
+		UNAME_MACHINE="alphaev5" ;;
+	    "EV5.6 (21164A)")
+		UNAME_MACHINE="alphaev56" ;;
+	    "EV5.6 (21164PC)")
+		UNAME_MACHINE="alphapca56" ;;
+	    "EV5.7 (21164PC)")
+		UNAME_MACHINE="alphapca57" ;;
+	    "EV6 (21264)")
+		UNAME_MACHINE="alphaev6" ;;
+	    "EV6.7 (21264A)")
+		UNAME_MACHINE="alphaev67" ;;
+	    "EV6.8CB (21264C)")
+		UNAME_MACHINE="alphaev68" ;;
+	    "EV6.8AL (21264B)")
+		UNAME_MACHINE="alphaev68" ;;
+	    "EV6.8CX (21264D)")
+		UNAME_MACHINE="alphaev68" ;;
+	    "EV6.9A (21264/EV69A)")
+		UNAME_MACHINE="alphaev69" ;;
+	    "EV7 (21364)")
+		UNAME_MACHINE="alphaev7" ;;
+	    "EV7.9 (21364A)")
+		UNAME_MACHINE="alphaev79" ;;
+	esac
+	# A Pn.n version is a patched version.
+	# A Vn.n version is a released version.
+	# A Tn.n version is a released field test version.
+	# A Xn.n version is an unreleased experimental baselevel.
+	# 1.2 uses "1.2" for uname -r.
+	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
+	exit ;;
+    Alpha\ *:Windows_NT*:*)
+	# How do we know it's Interix rather than the generic POSIX subsystem?
+	# Should we change UNAME_MACHINE based on the output of uname instead
+	# of the specific Alpha model?
+	echo alpha-pc-interix
+	exit ;;
+    21064:Windows_NT:50:3)
+	echo alpha-dec-winnt3.5
+	exit ;;
+    Amiga*:UNIX_System_V:4.0:*)
+	echo m68k-unknown-sysv4
+	exit ;;
+    *:[Aa]miga[Oo][Ss]:*:*)
+	echo ${UNAME_MACHINE}-unknown-amigaos
+	exit ;;
+    *:[Mm]orph[Oo][Ss]:*:*)
+	echo ${UNAME_MACHINE}-unknown-morphos
+	exit ;;
+    *:OS/390:*:*)
+	echo i370-ibm-openedition
+	exit ;;
+    *:z/VM:*:*)
+	echo s390-ibm-zvmoe
+	exit ;;
+    *:OS400:*:*)
+        echo powerpc-ibm-os400
+	exit ;;
+    arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
+	echo arm-acorn-riscix${UNAME_RELEASE}
+	exit ;;
+    arm:riscos:*:*|arm:RISCOS:*:*)
+	echo arm-unknown-riscos
+	exit ;;
+    SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
+	echo hppa1.1-hitachi-hiuxmpp
+	exit ;;
+    Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
+	# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
+	if test "`(/bin/universe) 2>/dev/null`" = att ; then
+		echo pyramid-pyramid-sysv3
+	else
+		echo pyramid-pyramid-bsd
+	fi
+	exit ;;
+    NILE*:*:*:dcosx)
+	echo pyramid-pyramid-svr4
+	exit ;;
+    DRS?6000:unix:4.0:6*)
+	echo sparc-icl-nx6
+	exit ;;
+    DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)
+	case `/usr/bin/uname -p` in
+	    sparc) echo sparc-icl-nx7; exit ;;
+	esac ;;
+    sun4H:SunOS:5.*:*)
+	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
+    sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
+	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
+    i86pc:SunOS:5.*:*)
+	echo i386-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
+    sun4*:SunOS:6*:*)
+	# According to config.sub, this is the proper way to canonicalize
+	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
+	# it's likely to be more like Solaris than SunOS4.
+	echo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
+    sun4*:SunOS:*:*)
+	case "`/usr/bin/arch -k`" in
+	    Series*|S4*)
+		UNAME_RELEASE=`uname -v`
+		;;
+	esac
+	# Japanese Language versions have a version number like `4.1.3-JL'.
+	echo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`
+	exit ;;
+    sun3*:SunOS:*:*)
+	echo m68k-sun-sunos${UNAME_RELEASE}
+	exit ;;
+    sun*:*:4.2BSD:*)
+	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
+	test "x${UNAME_RELEASE}" = "x" && UNAME_RELEASE=3
+	case "`/bin/arch`" in
+	    sun3)
+		echo m68k-sun-sunos${UNAME_RELEASE}
+		;;
+	    sun4)
+		echo sparc-sun-sunos${UNAME_RELEASE}
+		;;
+	esac
+	exit ;;
+    aushp:SunOS:*:*)
+	echo sparc-auspex-sunos${UNAME_RELEASE}
+	exit ;;
+    # The situation for MiNT is a little confusing.  The machine name
+    # can be virtually everything (everything which is not
+    # "atarist" or "atariste" at least should have a processor
+    # > m68000).  The system name ranges from "MiNT" over "FreeMiNT"
+    # to the lowercase version "mint" (or "freemint").  Finally
+    # the system name "TOS" denotes a system which is actually not
+    # MiNT.  But MiNT is downward compatible to TOS, so this should
+    # be no problem.
+    atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
+        echo m68k-atari-mint${UNAME_RELEASE}
+	exit ;;
+    atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
+	echo m68k-atari-mint${UNAME_RELEASE}
+        exit ;;
+    *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
+        echo m68k-atari-mint${UNAME_RELEASE}
+	exit ;;
+    milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
+        echo m68k-milan-mint${UNAME_RELEASE}
+        exit ;;
+    hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
+        echo m68k-hades-mint${UNAME_RELEASE}
+        exit ;;
+    *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
+        echo m68k-unknown-mint${UNAME_RELEASE}
+        exit ;;
+    m68k:machten:*:*)
+	echo m68k-apple-machten${UNAME_RELEASE}
+	exit ;;
+    powerpc:machten:*:*)
+	echo powerpc-apple-machten${UNAME_RELEASE}
+	exit ;;
+    RISC*:Mach:*:*)
+	echo mips-dec-mach_bsd4.3
+	exit ;;
+    RISC*:ULTRIX:*:*)
+	echo mips-dec-ultrix${UNAME_RELEASE}
+	exit ;;
+    VAX*:ULTRIX*:*:*)
+	echo vax-dec-ultrix${UNAME_RELEASE}
+	exit ;;
+    2020:CLIX:*:* | 2430:CLIX:*:*)
+	echo clipper-intergraph-clix${UNAME_RELEASE}
+	exit ;;
+    mips:*:*:UMIPS | mips:*:*:RISCos)
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+#ifdef __cplusplus
+#include <stdio.h>  /* for printf() prototype */
+	int main (int argc, char *argv[]) {
+#else
+	int main (argc, argv) int argc; char *argv[]; {
+#endif
+	#if defined (host_mips) && defined (MIPSEB)
+	#if defined (SYSTYPE_SYSV)
+	  printf ("mips-mips-riscos%ssysv\n", argv[1]); exit (0);
+	#endif
+	#if defined (SYSTYPE_SVR4)
+	  printf ("mips-mips-riscos%ssvr4\n", argv[1]); exit (0);
+	#endif
+	#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)
+	  printf ("mips-mips-riscos%sbsd\n", argv[1]); exit (0);
+	#endif
+	#endif
+	  exit (-1);
+	}
+EOF
+	$CC_FOR_BUILD -o $dummy $dummy.c &&
+	  dummyarg=`echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` &&
+	  SYSTEM_NAME=`$dummy $dummyarg` &&
+	    { echo "$SYSTEM_NAME"; exit; }
+	echo mips-mips-riscos${UNAME_RELEASE}
+	exit ;;
+    Motorola:PowerMAX_OS:*:*)
+	echo powerpc-motorola-powermax
+	exit ;;
+    Motorola:*:4.3:PL8-*)
+	echo powerpc-harris-powermax
+	exit ;;
+    Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)
+	echo powerpc-harris-powermax
+	exit ;;
+    Night_Hawk:Power_UNIX:*:*)
+	echo powerpc-harris-powerunix
+	exit ;;
+    m88k:CX/UX:7*:*)
+	echo m88k-harris-cxux7
+	exit ;;
+    m88k:*:4*:R4*)
+	echo m88k-motorola-sysv4
+	exit ;;
+    m88k:*:3*:R3*)
+	echo m88k-motorola-sysv3
+	exit ;;
+    AViiON:dgux:*:*)
+        # DG/UX returns AViiON for all architectures
+        UNAME_PROCESSOR=`/usr/bin/uname -p`
+	if [ $UNAME_PROCESSOR = mc88100 ] || [ $UNAME_PROCESSOR = mc88110 ]
+	then
+	    if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx ] || \
+	       [ ${TARGET_BINARY_INTERFACE}x = x ]
+	    then
+		echo m88k-dg-dgux${UNAME_RELEASE}
+	    else
+		echo m88k-dg-dguxbcs${UNAME_RELEASE}
+	    fi
+	else
+	    echo i586-dg-dgux${UNAME_RELEASE}
+	fi
+ 	exit ;;
+    M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
+	echo m88k-dolphin-sysv3
+	exit ;;
+    M88*:*:R3*:*)
+	# Delta 88k system running SVR3
+	echo m88k-motorola-sysv3
+	exit ;;
+    XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
+	echo m88k-tektronix-sysv3
+	exit ;;
+    Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
+	echo m68k-tektronix-bsd
+	exit ;;
+    *:IRIX*:*:*)
+	echo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`
+	exit ;;
+    ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
+	echo romp-ibm-aix     # uname -m gives an 8 hex-code CPU id
+	exit ;;               # Note that: echo "'`uname -s`'" gives 'AIX '
+    i*86:AIX:*:*)
+	echo i386-ibm-aix
+	exit ;;
+    ia64:AIX:*:*)
+	if [ -x /usr/bin/oslevel ] ; then
+		IBM_REV=`/usr/bin/oslevel`
+	else
+		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
+	fi
+	echo ${UNAME_MACHINE}-ibm-aix${IBM_REV}
+	exit ;;
+    *:AIX:2:3)
+	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
+		eval $set_cc_for_build
+		sed 's/^		//' << EOF >$dummy.c
+		#include <sys/systemcfg.h>
+
+		main()
+			{
+			if (!__power_pc())
+				exit(1);
+			puts("powerpc-ibm-aix3.2.5");
+			exit(0);
+			}
+EOF
+		if $CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy`
+		then
+			echo "$SYSTEM_NAME"
+		else
+			echo rs6000-ibm-aix3.2.5
+		fi
+	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
+		echo rs6000-ibm-aix3.2.4
+	else
+		echo rs6000-ibm-aix3.2
+	fi
+	exit ;;
+    *:AIX:*:[45])
+	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
+	if /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' >/dev/null 2>&1; then
+		IBM_ARCH=rs6000
+	else
+		IBM_ARCH=powerpc
+	fi
+	if [ -x /usr/bin/oslevel ] ; then
+		IBM_REV=`/usr/bin/oslevel`
+	else
+		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
+	fi
+	echo ${IBM_ARCH}-ibm-aix${IBM_REV}
+	exit ;;
+    *:AIX:*:*)
+	echo rs6000-ibm-aix
+	exit ;;
+    ibmrt:4.4BSD:*|romp-ibm:BSD:*)
+	echo romp-ibm-bsd4.4
+	exit ;;
+    ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
+	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
+	exit ;;                             # report: romp-ibm BSD 4.3
+    *:BOSX:*:*)
+	echo rs6000-bull-bosx
+	exit ;;
+    DPX/2?00:B.O.S.:*:*)
+	echo m68k-bull-sysv3
+	exit ;;
+    9000/[34]??:4.3bsd:1.*:*)
+	echo m68k-hp-bsd
+	exit ;;
+    hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
+	echo m68k-hp-bsd4.4
+	exit ;;
+    9000/[34678]??:HP-UX:*:*)
+	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
+	case "${UNAME_MACHINE}" in
+	    9000/31? )            HP_ARCH=m68000 ;;
+	    9000/[34]?? )         HP_ARCH=m68k ;;
+	    9000/[678][0-9][0-9])
+		if [ -x /usr/bin/getconf ]; then
+		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
+                    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
+                    case "${sc_cpu_version}" in
+                      523) HP_ARCH="hppa1.0" ;; # CPU_PA_RISC1_0
+                      528) HP_ARCH="hppa1.1" ;; # CPU_PA_RISC1_1
+                      532)                      # CPU_PA_RISC2_0
+                        case "${sc_kernel_bits}" in
+                          32) HP_ARCH="hppa2.0n" ;;
+                          64) HP_ARCH="hppa2.0w" ;;
+			  '') HP_ARCH="hppa2.0" ;;   # HP-UX 10.20
+                        esac ;;
+                    esac
+		fi
+		if [ "${HP_ARCH}" = "" ]; then
+		    eval $set_cc_for_build
+		    sed 's/^              //' << EOF >$dummy.c
+
+              #define _HPUX_SOURCE
+              #include <stdlib.h>
+              #include <unistd.h>
+
+              int main ()
+              {
+              #if defined(_SC_KERNEL_BITS)
+                  long bits = sysconf(_SC_KERNEL_BITS);
+              #endif
+                  long cpu  = sysconf (_SC_CPU_VERSION);
+
+                  switch (cpu)
+              	{
+              	case CPU_PA_RISC1_0: puts ("hppa1.0"); break;
+              	case CPU_PA_RISC1_1: puts ("hppa1.1"); break;
+              	case CPU_PA_RISC2_0:
+              #if defined(_SC_KERNEL_BITS)
+              	    switch (bits)
+              		{
+              		case 64: puts ("hppa2.0w"); break;
+              		case 32: puts ("hppa2.0n"); break;
+              		default: puts ("hppa2.0"); break;
+              		} break;
+              #else  /* !defined(_SC_KERNEL_BITS) */
+              	    puts ("hppa2.0"); break;
+              #endif
+              	default: puts ("hppa1.0"); break;
+              	}
+                  exit (0);
+              }
+EOF
+		    (CCOPTS= $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`
+		    test -z "$HP_ARCH" && HP_ARCH=hppa
+		fi ;;
+	esac
+	if [ ${HP_ARCH} = "hppa2.0w" ]
+	then
+	    eval $set_cc_for_build
+
+	    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating
+	    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler
+	    # generating 64-bit code.  GNU and HP use different nomenclature:
+	    #
+	    # $ CC_FOR_BUILD=cc ./config.guess
+	    # => hppa2.0w-hp-hpux11.23
+	    # $ CC_FOR_BUILD="cc +DA2.0w" ./config.guess
+	    # => hppa64-hp-hpux11.23
+
+	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) |
+		grep __LP64__ >/dev/null
+	    then
+		HP_ARCH="hppa2.0w"
+	    else
+		HP_ARCH="hppa64"
+	    fi
+	fi
+	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
+	exit ;;
+    ia64:HP-UX:*:*)
+	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
+	echo ia64-hp-hpux${HPUX_REV}
+	exit ;;
+    3050*:HI-UX:*:*)
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+	#include <unistd.h>
+	int
+	main ()
+	{
+	  long cpu = sysconf (_SC_CPU_VERSION);
+	  /* The order matters, because CPU_IS_HP_MC68K erroneously returns
+	     true for CPU_PA_RISC1_0.  CPU_IS_PA_RISC returns correct
+	     results, however.  */
+	  if (CPU_IS_PA_RISC (cpu))
+	    {
+	      switch (cpu)
+		{
+		  case CPU_PA_RISC1_0: puts ("hppa1.0-hitachi-hiuxwe2"); break;
+		  case CPU_PA_RISC1_1: puts ("hppa1.1-hitachi-hiuxwe2"); break;
+		  case CPU_PA_RISC2_0: puts ("hppa2.0-hitachi-hiuxwe2"); break;
+		  default: puts ("hppa-hitachi-hiuxwe2"); break;
+		}
+	    }
+	  else if (CPU_IS_HP_MC68K (cpu))
+	    puts ("m68k-hitachi-hiuxwe2");
+	  else puts ("unknown-hitachi-hiuxwe2");
+	  exit (0);
+	}
+EOF
+	$CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy` &&
+		{ echo "$SYSTEM_NAME"; exit; }
+	echo unknown-hitachi-hiuxwe2
+	exit ;;
+    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )
+	echo hppa1.1-hp-bsd
+	exit ;;
+    9000/8??:4.3bsd:*:*)
+	echo hppa1.0-hp-bsd
+	exit ;;
+    *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)
+	echo hppa1.0-hp-mpeix
+	exit ;;
+    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )
+	echo hppa1.1-hp-osf
+	exit ;;
+    hp8??:OSF1:*:*)
+	echo hppa1.0-hp-osf
+	exit ;;
+    i*86:OSF1:*:*)
+	if [ -x /usr/sbin/sysversion ] ; then
+	    echo ${UNAME_MACHINE}-unknown-osf1mk
+	else
+	    echo ${UNAME_MACHINE}-unknown-osf1
+	fi
+	exit ;;
+    parisc*:Lites*:*:*)
+	echo hppa1.1-hp-lites
+	exit ;;
+    C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
+	echo c1-convex-bsd
+        exit ;;
+    C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
+	if getsysinfo -f scalar_acc
+	then echo c32-convex-bsd
+	else echo c2-convex-bsd
+	fi
+        exit ;;
+    C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
+	echo c34-convex-bsd
+        exit ;;
+    C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
+	echo c38-convex-bsd
+        exit ;;
+    C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
+	echo c4-convex-bsd
+        exit ;;
+    CRAY*Y-MP:*:*:*)
+	echo ymp-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    CRAY*[A-Z]90:*:*:*)
+	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
+	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
+	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \
+	      -e 's/\.[^.]*$/.X/'
+	exit ;;
+    CRAY*TS:*:*:*)
+	echo t90-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    CRAY*T3E:*:*:*)
+	echo alphaev5-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    CRAY*SV1:*:*:*)
+	echo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    *:UNICOS/mp:*:*)
+	echo craynv-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
+	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
+        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
+        FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
+        echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+        exit ;;
+    5000:UNIX_System_V:4.*:*)
+        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
+        FUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`
+        echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+	exit ;;
+    i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
+	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
+	exit ;;
+    sparc*:BSD/OS:*:*)
+	echo sparc-unknown-bsdi${UNAME_RELEASE}
+	exit ;;
+    *:BSD/OS:*:*)
+	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
+	exit ;;
+    *:FreeBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
+	exit ;;
+    i*:CYGWIN*:*)
+	echo ${UNAME_MACHINE}-pc-cygwin
+	exit ;;
+    i*:MINGW*:*)
+	echo ${UNAME_MACHINE}-pc-mingw32
+	exit ;;
+#### MozillaHack 
+# Netscape's hacked uname
+    xx:WINNT:* | xx:WIN95:*)
+	echo i586-pc-msvc
+	exit ;;
+###  End MozillaHack
+    i*:windows32*:*)
+    	# uname -m includes "-pc" on this system.
+    	echo ${UNAME_MACHINE}-mingw32
+	exit ;;
+    i*:PW*:*)
+	echo ${UNAME_MACHINE}-pc-pw32
+	exit ;;
+    x86:Interix*:[34]*)
+	echo i586-pc-interix${UNAME_RELEASE}|sed -e 's/\..*//'
+	exit ;;
+    [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)
+	echo i${UNAME_MACHINE}-pc-mks
+	exit ;;
+    i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
+	# How do we know it's Interix rather than the generic POSIX subsystem?
+	# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
+	# UNAME_MACHINE based on the output of uname instead of i386?
+	echo i586-pc-interix
+	exit ;;
+    i*:UWIN*:*)
+	echo ${UNAME_MACHINE}-pc-uwin
+	exit ;;
+    amd64:CYGWIN*:*:* | x86_64:CYGWIN*:*:*)
+	echo x86_64-unknown-cygwin
+	exit ;;
+    p*:CYGWIN*:*)
+	echo powerpcle-unknown-cygwin
+	exit ;;
+    prep*:SunOS:5.*:*)
+	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
+    *:GNU:*:*)
+	# the GNU system
+	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
+	exit ;;
+    *:GNU/*:*:*)
+	# other systems with GNU libc and userland
+	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-gnu
+	exit ;;
+    i*86:Minix:*:*)
+	echo ${UNAME_MACHINE}-pc-minix
+	exit ;;
+    arm*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    cris:Linux:*:*)
+	echo cris-axis-linux-gnu
+	exit ;;
+    crisv32:Linux:*:*)
+	echo crisv32-axis-linux-gnu
+	exit ;;
+    frv:Linux:*:*)
+    	echo frv-unknown-linux-gnu
+	exit ;;
+    ia64:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    m32r*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    m68*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    mips:Linux:*:*)
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+	#undef CPU
+	#undef mips
+	#undef mipsel
+	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
+	CPU=mipsel
+	#else
+	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
+	CPU=mips
+	#else
+	CPU=
+	#endif
+	#endif
+EOF
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^CPU=`
+	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
+	;;
+    mips64:Linux:*:*)
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+	#undef CPU
+	#undef mips64
+	#undef mips64el
+	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
+	CPU=mips64el
+	#else
+	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
+	CPU=mips64
+	#else
+	CPU=
+	#endif
+	#endif
+EOF
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^CPU=`
+	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
+	;;
+    or32:Linux:*:*)
+	echo or32-unknown-linux-gnu
+	exit ;;
+    ppc:Linux:*:*)
+	echo powerpc-unknown-linux-gnu
+	exit ;;
+    ppc64:Linux:*:*)
+	echo powerpc64-unknown-linux-gnu
+	exit ;;
+    alpha:Linux:*:*)
+	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
+	  EV5)   UNAME_MACHINE=alphaev5 ;;
+	  EV56)  UNAME_MACHINE=alphaev56 ;;
+	  PCA56) UNAME_MACHINE=alphapca56 ;;
+	  PCA57) UNAME_MACHINE=alphapca56 ;;
+	  EV6)   UNAME_MACHINE=alphaev6 ;;
+	  EV67)  UNAME_MACHINE=alphaev67 ;;
+	  EV68*) UNAME_MACHINE=alphaev68 ;;
+        esac
+	objdump --private-headers /bin/sh | grep ld.so.1 >/dev/null
+	if test "$?" = 0 ; then LIBC="libc1" ; else LIBC="" ; fi
+	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
+	exit ;;
+    parisc:Linux:*:* | hppa:Linux:*:*)
+	# Look for CPU level
+	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
+	  PA7*) echo hppa1.1-unknown-linux-gnu ;;
+	  PA8*) echo hppa2.0-unknown-linux-gnu ;;
+	  *)    echo hppa-unknown-linux-gnu ;;
+	esac
+	exit ;;
+    parisc64:Linux:*:* | hppa64:Linux:*:*)
+	echo hppa64-unknown-linux-gnu
+	exit ;;
+    s390:Linux:*:* | s390x:Linux:*:*)
+	echo ${UNAME_MACHINE}-ibm-linux
+	exit ;;
+    sh64*:Linux:*:*)
+    	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    sh*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    sparc:Linux:*:* | sparc64:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    x86_64:Linux:*:*)
+	echo x86_64-unknown-linux-gnu
+	exit ;;
+    i*86:Linux:*:*)
+	# The BFD linker knows what the default object file format is, so
+	# first see if it will tell us. cd to the root directory to prevent
+	# problems with other programs or directories called `ld' in the path.
+	# Set LC_ALL=C to ensure ld outputs messages in English.
+	ld_supported_targets=`cd /; LC_ALL=C ld --help 2>&1 \
+			 | sed -ne '/supported targets:/!d
+				    s/[ 	][ 	]*/ /g
+				    s/.*supported targets: *//
+				    s/ .*//
+				    p'`
+        case "$ld_supported_targets" in
+	  elf32-i386)
+		TENTATIVE="${UNAME_MACHINE}-pc-linux-gnu"
+		;;
+	  a.out-i386-linux)
+		echo "${UNAME_MACHINE}-pc-linux-gnuaout"
+		exit ;;
+	  coff-i386)
+		echo "${UNAME_MACHINE}-pc-linux-gnucoff"
+		exit ;;
+	  "")
+		# Either a pre-BFD a.out linker (linux-gnuoldld) or
+		# one that does not give us useful --help.
+		echo "${UNAME_MACHINE}-pc-linux-gnuoldld"
+		exit ;;
+	esac
+	# Determine whether the default compiler is a.out or elf
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+	#include <features.h>
+	#ifdef __ELF__
+	# ifdef __GLIBC__
+	#  if __GLIBC__ >= 2
+	LIBC=gnu
+	#  else
+	LIBC=gnulibc1
+	#  endif
+	# else
+	LIBC=gnulibc1
+	# endif
+	#else
+	#ifdef __INTEL_COMPILER
+	LIBC=gnu
+	#else
+	LIBC=gnuaout
+	#endif
+	#endif
+	#ifdef __dietlibc__
+	LIBC=dietlibc
+	#endif
+EOF
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^LIBC=`
+	test x"${LIBC}" != x && {
+		echo "${UNAME_MACHINE}-pc-linux-${LIBC}"
+		exit
+	}
+	test x"${TENTATIVE}" != x && { echo "${TENTATIVE}"; exit; }
+	;;
+    i*86:DYNIX/ptx:4*:*)
+	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
+	# earlier versions are messed up and put the nodename in both
+	# sysname and nodename.
+	echo i386-sequent-sysv4
+	exit ;;
+    i*86:UNIX_SV:4.2MP:2.*)
+        # Unixware is an offshoot of SVR4, but it has its own version
+        # number series starting with 2...
+        # I am not positive that other SVR4 systems won't match this,
+	# I just have to hope.  -- rms.
+        # Use sysv4.2uw... so that sysv4* matches it.
+	echo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}
+	exit ;;
+    i*86:OS/2:*:*)
+	# If we were able to find `uname', then EMX Unix compatibility
+	# is probably installed.
+	echo ${UNAME_MACHINE}-pc-os2-emx
+	exit ;;
+    i*86:XTS-300:*:STOP)
+	echo ${UNAME_MACHINE}-unknown-stop
+	exit ;;
+    i*86:atheos:*:*)
+	echo ${UNAME_MACHINE}-unknown-atheos
+	exit ;;
+    i*86:syllable:*:*)
+	echo ${UNAME_MACHINE}-pc-syllable
+	exit ;;
+    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.0*:*)
+	echo i386-unknown-lynxos${UNAME_RELEASE}
+	exit ;;
+    i*86:*DOS:*:*)
+	echo ${UNAME_MACHINE}-pc-msdosdjgpp
+	exit ;;
+    i*86:*:4.*:* | i*86:SYSTEM_V:4.*:*)
+	UNAME_REL=`echo ${UNAME_RELEASE} | sed 's/\/MP$//'`
+	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
+		echo ${UNAME_MACHINE}-univel-sysv${UNAME_REL}
+	else
+		echo ${UNAME_MACHINE}-pc-sysv${UNAME_REL}
+	fi
+	exit ;;
+    i*86:*:5:[678]*)
+    	# UnixWare 7.x, OpenUNIX and OpenServer 6.
+	case `/bin/uname -X | grep "^Machine"` in
+	    *486*)	     UNAME_MACHINE=i486 ;;
+	    *Pentium)	     UNAME_MACHINE=i586 ;;
+	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
+	esac
+	echo ${UNAME_MACHINE}-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}
+	exit ;;
+    i*86:*:3.2:*)
+	if test -f /usr/options/cb.name; then
+		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
+		echo ${UNAME_MACHINE}-pc-isc$UNAME_REL
+	elif /bin/uname -X 2>/dev/null >/dev/null ; then
+		UNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`
+		(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486
+		(/bin/uname -X|grep '^Machine.*Pentium' >/dev/null) \
+			&& UNAME_MACHINE=i586
+		(/bin/uname -X|grep '^Machine.*Pent *II' >/dev/null) \
+			&& UNAME_MACHINE=i686
+		(/bin/uname -X|grep '^Machine.*Pentium Pro' >/dev/null) \
+			&& UNAME_MACHINE=i686
+		echo ${UNAME_MACHINE}-pc-sco$UNAME_REL
+	else
+		echo ${UNAME_MACHINE}-pc-sysv32
+	fi
+	exit ;;
+    pc:*:*:*)
+	# Left here for compatibility:
+        # uname -m prints for DJGPP always 'pc', but it prints nothing about
+        # the processor, so we play safe by assuming i386.
+	echo i386-pc-msdosdjgpp
+        exit ;;
+    Intel:Mach:3*:*)
+	echo i386-pc-mach3
+	exit ;;
+    paragon:*:*:*)
+	echo i860-intel-osf1
+	exit ;;
+    i860:*:4.*:*) # i860-SVR4
+	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
+	  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4
+	else # Add other i860-SVR4 vendors below as they are discovered.
+	  echo i860-unknown-sysv${UNAME_RELEASE}  # Unknown i860-SVR4
+	fi
+	exit ;;
+    mini*:CTIX:SYS*5:*)
+	# "miniframe"
+	echo m68010-convergent-sysv
+	exit ;;
+    mc68k:UNIX:SYSTEM5:3.51m)
+	echo m68k-convergent-sysv
+	exit ;;
+    M680?0:D-NIX:5.3:*)
+	echo m68k-diab-dnix
+	exit ;;
+    M68*:*:R3V[5678]*:*)
+	test -r /sysV68 && { echo 'm68k-motorola-sysv'; exit; } ;;
+    3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0 | S7501*:*:4.0:3.0)
+	OS_REL=''
+	test -r /etc/.relid \
+	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	  && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
+	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
+	  && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
+    3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
+        /bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+          && { echo i486-ncr-sysv4; exit; } ;;
+    m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
+	echo m68k-unknown-lynxos${UNAME_RELEASE}
+	exit ;;
+    mc68030:UNIX_System_V:4.*:*)
+	echo m68k-atari-sysv4
+	exit ;;
+    TSUNAMI:LynxOS:2.*:*)
+	echo sparc-unknown-lynxos${UNAME_RELEASE}
+	exit ;;
+    rs6000:LynxOS:2.*:*)
+	echo rs6000-unknown-lynxos${UNAME_RELEASE}
+	exit ;;
+    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.0*:*)
+	echo powerpc-unknown-lynxos${UNAME_RELEASE}
+	exit ;;
+    SM[BE]S:UNIX_SV:*:*)
+	echo mips-dde-sysv${UNAME_RELEASE}
+	exit ;;
+    RM*:ReliantUNIX-*:*:*)
+	echo mips-sni-sysv4
+	exit ;;
+    RM*:SINIX-*:*:*)
+	echo mips-sni-sysv4
+	exit ;;
+    *:SINIX-*:*:*)
+	if uname -p 2>/dev/null >/dev/null ; then
+		UNAME_MACHINE=`(uname -p) 2>/dev/null`
+		echo ${UNAME_MACHINE}-sni-sysv4
+	else
+		echo ns32k-sni-sysv
+	fi
+	exit ;;
+    PENTIUM:*:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
+                      # says <Richard.M.Bartel@ccMail.Census.GOV>
+        echo i586-unisys-sysv4
+        exit ;;
+#### MozillaHack 
+    *:*OpenVMS*:*:*)
+        case "${UNAME_SYSTEM}" in
+            POSIX_for_OpenVMS_AXP) echo alpha-dec-openvmsposix ;;
+            POSIX_for_OpenVMS_VAX) echo vax-dec-openvmsposix ;;
+            OpenVMS) echo alpha-dec-openvms ;;
+            *) echo unknown-dec-openvms ;;
+        esac
+        exit ;;
+#### End MozillaHack 
+    *:UNIX_System_V:4*:FTX*)
+	# From Gerald Hewes <hewes@openmarket.com>.
+	# How about differentiating between stratus architectures? -djm
+	echo hppa1.1-stratus-sysv4
+	exit ;;
+    *:*:*:FTX*)
+	# From seanf@swdc.stratus.com.
+	echo i860-stratus-sysv4
+	exit ;;
+    i*86:VOS:*:*)
+	# From Paul.Green@stratus.com.
+	echo ${UNAME_MACHINE}-stratus-vos
+	exit ;;
+    *:VOS:*:*)
+	# From Paul.Green@stratus.com.
+	echo hppa1.1-stratus-vos
+	exit ;;
+    mc68*:A/UX:*:*)
+	echo m68k-apple-aux${UNAME_RELEASE}
+	exit ;;
+    news*:NEWS-OS:6*:*)
+	echo mips-sony-newsos6
+	exit ;;
+    R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
+	if [ -d /usr/nec ]; then
+	        echo mips-nec-sysv${UNAME_RELEASE}
+	else
+	        echo mips-unknown-sysv${UNAME_RELEASE}
+	fi
+        exit ;;
+    BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
+	echo powerpc-be-beos
+	exit ;;
+    BeMac:BeOS:*:*)	# BeOS running on Mac or Mac clone, PPC only.
+	echo powerpc-apple-beos
+	exit ;;
+    BePC:BeOS:*:*)	# BeOS running on Intel PC compatible.
+	echo i586-pc-beos
+	exit ;;
+    SX-4:SUPER-UX:*:*)
+	echo sx4-nec-superux${UNAME_RELEASE}
+	exit ;;
+    SX-5:SUPER-UX:*:*)
+	echo sx5-nec-superux${UNAME_RELEASE}
+	exit ;;
+    SX-6:SUPER-UX:*:*)
+	echo sx6-nec-superux${UNAME_RELEASE}
+	exit ;;
+    Power*:Rhapsody:*:*)
+	echo powerpc-apple-rhapsody${UNAME_RELEASE}
+	exit ;;
+    *:Rhapsody:*:*)
+	echo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}
+	exit ;;
+    *:Darwin:*:*)
+	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
+	case $UNAME_PROCESSOR in
+	    unknown) UNAME_PROCESSOR=powerpc ;;
+	esac
+	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
+	exit ;;
+    *:procnto*:*:* | *:QNX:[0123456789]*:*)
+	UNAME_PROCESSOR=`uname -p`
+	if test "$UNAME_PROCESSOR" = "x86"; then
+		UNAME_PROCESSOR=i386
+		UNAME_MACHINE=pc
+	fi
+	echo ${UNAME_PROCESSOR}-${UNAME_MACHINE}-nto-qnx${UNAME_RELEASE}
+	exit ;;
+    *:QNX:*:4*)
+	echo i386-pc-qnx
+	exit ;;
+    NSE-?:NONSTOP_KERNEL:*:*)
+	echo nse-tandem-nsk${UNAME_RELEASE}
+	exit ;;
+    NSR-?:NONSTOP_KERNEL:*:*)
+	echo nsr-tandem-nsk${UNAME_RELEASE}
+	exit ;;
+    *:NonStop-UX:*:*)
+	echo mips-compaq-nonstopux
+	exit ;;
+    BS2000:POSIX*:*:*)
+	echo bs2000-siemens-sysv
+	exit ;;
+    DS/*:UNIX_System_V:*:*)
+	echo ${UNAME_MACHINE}-${UNAME_SYSTEM}-${UNAME_RELEASE}
+	exit ;;
+    *:Plan9:*:*)
+	# "uname -m" is not consistent, so use $cputype instead. 386
+	# is converted to i386 for consistency with other x86
+	# operating systems.
+	if test "$cputype" = "386"; then
+	    UNAME_MACHINE=i386
+	else
+	    UNAME_MACHINE="$cputype"
+	fi
+	echo ${UNAME_MACHINE}-unknown-plan9
+	exit ;;
+    *:TOPS-10:*:*)
+	echo pdp10-unknown-tops10
+	exit ;;
+    *:TENEX:*:*)
+	echo pdp10-unknown-tenex
+	exit ;;
+    KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)
+	echo pdp10-dec-tops20
+	exit ;;
+    XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)
+	echo pdp10-xkl-tops20
+	exit ;;
+    *:TOPS-20:*:*)
+	echo pdp10-unknown-tops20
+	exit ;;
+    *:ITS:*:*)
+	echo pdp10-unknown-its
+	exit ;;
+    SEI:*:*:SEIUX)
+        echo mips-sei-seiux${UNAME_RELEASE}
+	exit ;;
+    *:DragonFly:*:*)
+	echo ${UNAME_MACHINE}-unknown-dragonfly`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
+	exit ;;
+    *:*VMS:*:*)
+    	UNAME_MACHINE=`(uname -p) 2>/dev/null`
+	case "${UNAME_MACHINE}" in
+	    A*) echo alpha-dec-vms ; exit ;;
+	    I*) echo ia64-dec-vms ; exit ;;
+	    V*) echo vax-dec-vms ; exit ;;
+	esac ;;
+    *:XENIX:*:SysV)
+	echo i386-pc-xenix
+	exit ;;
+    i*86:skyos:*:*)
+	echo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE}` | sed -e 's/ .*$//'
+	exit ;;
+esac
+
+#echo '(No uname command or uname output not recognized.)' 1>&2
+#echo "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" 1>&2
+
+eval $set_cc_for_build
+cat >$dummy.c <<EOF
+#ifdef _SEQUENT_
+# include <sys/types.h>
+# include <sys/utsname.h>
+#endif
+main ()
+{
+#if defined (sony)
+#if defined (MIPSEB)
+  /* BFD wants "bsd" instead of "newsos".  Perhaps BFD should be changed,
+     I don't know....  */
+  printf ("mips-sony-bsd\n"); exit (0);
+#else
+#include <sys/param.h>
+  printf ("m68k-sony-newsos%s\n",
+#ifdef NEWSOS4
+          "4"
+#else
+	  ""
+#endif
+         ); exit (0);
+#endif
+#endif
+
+#if defined (__arm) && defined (__acorn) && defined (__unix)
+  printf ("arm-acorn-riscix\n"); exit (0);
+#endif
+
+#if defined (hp300) && !defined (hpux)
+  printf ("m68k-hp-bsd\n"); exit (0);
+#endif
+
+#if defined (NeXT)
+#if !defined (__ARCHITECTURE__)
+#define __ARCHITECTURE__ "m68k"
+#endif
+  int version;
+  version=`(hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2>/dev/null`;
+  if (version < 4)
+    printf ("%s-next-nextstep%d\n", __ARCHITECTURE__, version);
+  else
+    printf ("%s-next-openstep%d\n", __ARCHITECTURE__, version);
+  exit (0);
+#endif
+
+#if defined (MULTIMAX) || defined (n16)
+#if defined (UMAXV)
+  printf ("ns32k-encore-sysv\n"); exit (0);
+#else
+#if defined (CMU)
+  printf ("ns32k-encore-mach\n"); exit (0);
+#else
+  printf ("ns32k-encore-bsd\n"); exit (0);
+#endif
+#endif
+#endif
+
+#if defined (__386BSD__)
+  printf ("i386-pc-bsd\n"); exit (0);
+#endif
+
+#if defined (sequent)
+#if defined (i386)
+  printf ("i386-sequent-dynix\n"); exit (0);
+#endif
+#if defined (ns32000)
+  printf ("ns32k-sequent-dynix\n"); exit (0);
+#endif
+#endif
+
+#if defined (_SEQUENT_)
+    struct utsname un;
+
+    uname(&un);
+
+    if (strncmp(un.version, "V2", 2) == 0) {
+	printf ("i386-sequent-ptx2\n"); exit (0);
+    }
+    if (strncmp(un.version, "V1", 2) == 0) { /* XXX is V1 correct? */
+	printf ("i386-sequent-ptx1\n"); exit (0);
+    }
+    printf ("i386-sequent-ptx\n"); exit (0);
+
+#endif
+
+#if defined (vax)
+# if !defined (ultrix)
+#  include <sys/param.h>
+#  if defined (BSD)
+#   if BSD == 43
+      printf ("vax-dec-bsd4.3\n"); exit (0);
+#   else
+#    if BSD == 199006
+      printf ("vax-dec-bsd4.3reno\n"); exit (0);
+#    else
+      printf ("vax-dec-bsd\n"); exit (0);
+#    endif
+#   endif
+#  else
+    printf ("vax-dec-bsd\n"); exit (0);
+#  endif
+# else
+    printf ("vax-dec-ultrix\n"); exit (0);
+# endif
+#endif
+
+#if defined (alliant) && defined (i860)
+  printf ("i860-alliant-bsd\n"); exit (0);
+#endif
+
+  exit (1);
+}
+EOF
+
+$CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && SYSTEM_NAME=`$dummy` &&
+	{ echo "$SYSTEM_NAME"; exit; }
+
+# Apollos put the system type in the environment.
+
+test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit; }
+
+# Convex versions that predate uname can use getsysinfo(1)
+
+if [ -x /usr/convex/getsysinfo ]
+then
+    case `getsysinfo -f cpu_type` in
+    c1*)
+	echo c1-convex-bsd
+	exit ;;
+    c2*)
+	if getsysinfo -f scalar_acc
+	then echo c32-convex-bsd
+	else echo c2-convex-bsd
+	fi
+	exit ;;
+    c34*)
+	echo c34-convex-bsd
+	exit ;;
+    c38*)
+	echo c38-convex-bsd
+	exit ;;
+    c4*)
+	echo c4-convex-bsd
+	exit ;;
+    esac
+fi
+
+cat >&2 <<EOF
+$0: unable to guess system type
+
+This script, last modified $timestamp, has failed to recognize
+the operating system you are using. It is advised that you
+download the most up to date version of the config scripts from
+
+  http://savannah.gnu.org/cgi-bin/viewcvs/*checkout*/config/config/config.guess
+and
+  http://savannah.gnu.org/cgi-bin/viewcvs/*checkout*/config/config/config.sub
+
+If the version you run ($0) is already up to date, please
+send the following data and any information you think might be
+pertinent to <config-patches@gnu.org> in order to provide the needed
+information to handle your system.
+
+config.guess timestamp = $timestamp
+
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null`
+
+hostinfo               = `(hostinfo) 2>/dev/null`
+/bin/universe          = `(/bin/universe) 2>/dev/null`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null`
+/bin/arch              = `(/bin/arch) 2>/dev/null`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null`
+
+UNAME_MACHINE = ${UNAME_MACHINE}
+UNAME_RELEASE = ${UNAME_RELEASE}
+UNAME_SYSTEM  = ${UNAME_SYSTEM}
+UNAME_VERSION = ${UNAME_VERSION}
+EOF
+
+exit 1
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "timestamp='"
+# time-stamp-format: "%:y-%02m-%02d"
+# time-stamp-end: "'"
+# End:
diff -r 17e9560465b0 js/src/build/autoconf/config.sub
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/build/autoconf/config.sub	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,1595 @@
+#! /bin/sh
+# Configuration validation subroutine script.
+#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
+#   2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+
+timestamp='2005-10-13'
+
+# This file is (in principle) common to ALL GNU software.
+# The presence of a machine in this file suggests that SOME GNU software
+# can handle that machine.  It does not imply ALL GNU software can.
+#
+# This file is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
+# 02110-1301, USA.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+
+# Please send patches to <config-patches@gnu.org>.  Submit a context
+# diff and a properly formatted ChangeLog entry.
+#
+# Configuration subroutine to validate and canonicalize a configuration type.
+# Supply the specified configuration type as an argument.
+# If it is invalid, we print an error message on stderr and exit with code 1.
+# Otherwise, we print the canonical config type on stdout and succeed.
+
+# This file is supposed to be the same for all GNU packages
+# and recognize all the CPU types, system types and aliases
+# that are meaningful with *any* GNU software.
+# Each package is responsible for reporting which valid configurations
+# it does not support.  The user should be able to distinguish
+# a failure to support a valid configuration from a meaningless
+# configuration.
+
+# The goal of this file is to map all the various variations of a given
+# machine specification into a single specification in the form:
+#	CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
+# or in some cases, the newer four-part form:
+#	CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
+# It is wrong to echo any other type of specification.
+
+me=`echo "$0" | sed -e 's,.*/,,'`
+
+usage="\
+Usage: $0 [OPTION] CPU-MFR-OPSYS
+       $0 [OPTION] ALIAS
+
+Canonicalize a configuration name.
+
+Operation modes:
+  -h, --help         print this help, then exit
+  -t, --time-stamp   print date of last modification, then exit
+  -v, --version      print version number, then exit
+
+Report bugs and patches to <config-patches@gnu.org>."
+
+version="\
+GNU config.sub ($timestamp)
+
+Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
+Free Software Foundation, Inc.
+
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
+
+help="
+Try \`$me --help' for more information."
+
+# Parse command line
+while test $# -gt 0 ; do
+  case $1 in
+    --time-stamp | --time* | -t )
+       echo "$timestamp" ; exit ;;
+    --version | -v )
+       echo "$version" ; exit ;;
+    --help | --h* | -h )
+       echo "$usage"; exit ;;
+    -- )     # Stop option processing
+       shift; break ;;
+    - )	# Use stdin as input.
+       break ;;
+    -* )
+       echo "$me: invalid option $1$help"
+       exit 1 ;;
+
+    *local*)
+       # First pass through any local machine types.
+       echo $1
+       exit ;;
+
+    * )
+       break ;;
+  esac
+done
+
+case $# in
+ 0) echo "$me: missing argument$help" >&2
+    exit 1;;
+ 1) ;;
+ *) echo "$me: too many arguments$help" >&2
+    exit 1;;
+esac
+
+# Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).
+# Here we must recognize all the valid KERNEL-OS combinations.
+maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
+case $maybe_os in
+  nto-qnx* | linux-gnu* | linux-dietlibc | linux-uclibc* | uclinux-uclibc* | uclinux-gnu* | \
+  kfreebsd*-gnu* | knetbsd*-gnu* | netbsd*-gnu* | storm-chaos* | os2-emx* | rtmk-nova*)
+    os=-$maybe_os
+    basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
+    ;;
+  *)
+    basic_machine=`echo $1 | sed 's/-[^-]*$//'`
+    if [ $basic_machine != $1 ]
+    then os=`echo $1 | sed 's/.*-/-/'`
+    else os=; fi
+    ;;
+esac
+
+### Let's recognize common machines as not being operating systems so
+### that things like config.sub decstation-3100 work.  We also
+### recognize some manufacturers as not being operating systems, so we
+### can provide default operating systems below.
+case $os in
+	-sun*os*)
+		# Prevent following clause from handling this invalid input.
+		;;
+	-dec* | -mips* | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \
+	-att* | -7300* | -3300* | -delta* | -motorola* | -sun[234]* | \
+	-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \
+	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
+	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
+	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
+	-apple | -axis | -knuth | -cray)
+		os=
+		basic_machine=$1
+		;;
+	-sim | -cisco | -oki | -wec | -winbond)
+		os=
+		basic_machine=$1
+		;;
+	-scout)
+		;;
+	-wrs)
+		os=-vxworks
+		basic_machine=$1
+		;;
+	-chorusos*)
+		os=-chorusos
+		basic_machine=$1
+		;;
+ 	-chorusrdb)
+ 		os=-chorusrdb
+		basic_machine=$1
+ 		;;
+	-hiux*)
+		os=-hiuxwe2
+		;;
+	-sco5)
+		os=-sco3.2v5
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco4)
+		os=-sco3.2v4
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco3.2.[4-9]*)
+		os=`echo $os | sed -e 's/sco3.2./sco3.2v/'`
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco3.2v[4-9]*)
+		# Don't forget version if it is 3.2v4 or newer.
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco*)
+		os=-sco3.2v2
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-udk*)
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-isc)
+		os=-isc2.2
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-clix*)
+		basic_machine=clipper-intergraph
+		;;
+	-isc*)
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-lynx*)
+		os=-lynxos
+		;;
+	-ptx*)
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-sequent/'`
+		;;
+	-windowsnt*)
+		os=`echo $os | sed -e 's/windowsnt/winnt/'`
+		;;
+	-psos*)
+		os=-psos
+		;;
+	-mint | -mint[0-9]*)
+		basic_machine=m68k-atari
+		os=-mint
+		;;
+esac
+
+# Decode aliases for certain CPU-COMPANY combinations.
+case $basic_machine in
+	# Recognize the basic CPU types without company name.
+	# Some are omitted here because they have special meanings below.
+#### MozillaHack 
+# mips*el
+#### End MozillaHack 
+	1750a | 580 \
+	| a29k \
+	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
+	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
+	| am33_2.0 \
+	| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr \
+	| bfin \
+	| c4x | clipper \
+	| d10v | d30v | dlx | dsp16xx \
+	| fr30 | frv \
+	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
+	| i370 | i860 | i960 | ia64 \
+	| ip2k | iq2000 \
+	| m32r | m32rle | m68000 | m68k | m88k | maxq | mcore \
+	| mips | mipsbe | mipseb | mips*el | mipsle \
+	| mips16 \
+	| mips64 | mips64el \
+	| mips64vr | mips64vrel \
+	| mips64orion | mips64orionel \
+	| mips64vr4100 | mips64vr4100el \
+	| mips64vr4300 | mips64vr4300el \
+	| mips64vr5000 | mips64vr5000el \
+	| mips64vr5900 | mips64vr5900el \
+	| mipsisa32 | mipsisa32el \
+	| mipsisa32r2 | mipsisa32r2el \
+	| mipsisa64 | mipsisa64el \
+	| mipsisa64r2 | mipsisa64r2el \
+	| mipsisa64sb1 | mipsisa64sb1el \
+	| mipsisa64sr71k | mipsisa64sr71kel \
+	| mipstx39 | mipstx39el \
+	| mn10200 | mn10300 \
+	| ms1 \
+	| msp430 \
+	| ns16k | ns32k \
+	| or32 \
+	| pdp10 | pdp11 | pj | pjl \
+	| powerpc | powerpc64 | powerpc64le | powerpcle | ppcbe \
+	| pyramid \
+	| sh | sh[1234] | sh[24]a | sh[23]e | sh[34]eb | shbe | shle | sh[1234]le | sh3ele \
+	| sh64 | sh64le \
+	| sparc | sparc64 | sparc64b | sparc86x | sparclet | sparclite \
+	| sparcv8 | sparcv9 | sparcv9b \
+	| strongarm \
+	| tahoe | thumb | tic4x | tic80 | tron \
+	| v850 | v850e \
+	| we32k \
+	| x86 | xscale | xscalee[bl] | xstormy16 | xtensa \
+	| z8k)
+		basic_machine=$basic_machine-unknown
+		;;
+	m32c)
+		basic_machine=$basic_machine-unknown
+		;;
+	m6811 | m68hc11 | m6812 | m68hc12)
+		# Motorola 68HC11/12.
+		basic_machine=$basic_machine-unknown
+		os=-none
+		;;
+	m88110 | m680[12346]0 | m683?2 | m68360 | m5200 | v70 | w65 | z8k)
+		;;
+
+	# We use `pc' rather than `unknown'
+	# because (1) that's what they normally are, and
+	# (2) the word "unknown" tends to confuse beginning users.
+	i*86 | x86_64)
+	  basic_machine=$basic_machine-pc
+	  ;;
+	# Object if more than one company name word.
+	*-*-*)
+		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
+		exit 1
+		;;
+	# Recognize the basic CPU types with company name.
+#### MozillaHack 
+# mips*el
+#### End MozillaHack 
+	580-* \
+	| a29k-* \
+	| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \
+	| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \
+	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* \
+	| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \
+	| avr-* \
+	| bfin-* | bs2000-* \
+	| c[123]* | c30-* | [cjt]90-* | c4x-* | c54x-* | c55x-* | c6x-* \
+	| clipper-* | craynv-* | cydra-* \
+	| d10v-* | d30v-* | dlx-* \
+	| elxsi-* \
+	| f30[01]-* | f700-* | fr30-* | frv-* | fx80-* \
+	| h8300-* | h8500-* \
+	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
+	| i*86-* | i860-* | i960-* | ia64-* \
+	| ip2k-* | iq2000-* \
+	| m32r-* | m32rle-* \
+	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
+	| m88110-* | m88k-* | maxq-* | mcore-* \
+	| mips-* | mipsbe-* | mipseb-* | mips*el-* | mipsle-* \
+	| mips16-* \
+	| mips64-* | mips64el-* \
+	| mips64vr-* | mips64vrel-* \
+	| mips64orion-* | mips64orionel-* \
+	| mips64vr4100-* | mips64vr4100el-* \
+	| mips64vr4300-* | mips64vr4300el-* \
+	| mips64vr5000-* | mips64vr5000el-* \
+	| mips64vr5900-* | mips64vr5900el-* \
+	| mipsisa32-* | mipsisa32el-* \
+	| mipsisa32r2-* | mipsisa32r2el-* \
+	| mipsisa64-* | mipsisa64el-* \
+	| mipsisa64r2-* | mipsisa64r2el-* \
+	| mipsisa64sb1-* | mipsisa64sb1el-* \
+	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
+	| mipstx39-* | mipstx39el-* \
+	| mmix-* \
+	| ms1-* \
+	| msp430-* \
+	| none-* | np1-* | ns16k-* | ns32k-* \
+	| orion-* \
+	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
+	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* | ppcbe-* \
+	| pyramid-* \
+	| romp-* | rs6000-* \
+	| sh-* | sh[1234]-* | sh[24]a-* | sh[23]e-* | sh[34]eb-* | shbe-* \
+	| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \
+	| sparc-* | sparc64-* | sparc64b-* | sparc86x-* | sparclet-* \
+	| sparclite-* \
+	| sparcv8-* | sparcv9-* | sparcv9b-* | strongarm-* | sv1-* | sx?-* \
+	| tahoe-* | thumb-* \
+	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \
+	| tron-* \
+	| v850-* | v850e-* | vax-* \
+	| we32k-* \
+	| x86-* | x86_64-* | xps100-* | xscale-* | xscalee[bl]-* \
+	| xstormy16-* | xtensa-* \
+	| ymp-* \
+	| z8k-*)
+		;;
+	m32c-*)
+		;;
+	# Recognize the various machine names and aliases which stand
+	# for a CPU type and a company and sometimes even an OS.
+	386bsd)
+		basic_machine=i386-unknown
+		os=-bsd
+		;;
+	3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)
+		basic_machine=m68000-att
+		;;
+	3b*)
+		basic_machine=we32k-att
+		;;
+	a29khif)
+		basic_machine=a29k-amd
+		os=-udi
+		;;
+    	abacus)
+		basic_machine=abacus-unknown
+		;;
+	adobe68k)
+		basic_machine=m68010-adobe
+		os=-scout
+		;;
+	alliant | fx80)
+		basic_machine=fx80-alliant
+		;;
+	altos | altos3068)
+		basic_machine=m68k-altos
+		;;
+	am29k)
+		basic_machine=a29k-none
+		os=-bsd
+		;;
+	amd64)
+		basic_machine=x86_64-pc
+		;;
+	amd64-*)
+		basic_machine=x86_64-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	amdahl)
+		basic_machine=580-amdahl
+		os=-sysv
+		;;
+	amiga | amiga-*)
+		basic_machine=m68k-unknown
+		;;
+	amigaos | amigados)
+		basic_machine=m68k-unknown
+		os=-amigaos
+		;;
+	amigaunix | amix)
+		basic_machine=m68k-unknown
+		os=-sysv4
+		;;
+	apollo68)
+		basic_machine=m68k-apollo
+		os=-sysv
+		;;
+	apollo68bsd)
+		basic_machine=m68k-apollo
+		os=-bsd
+		;;
+	aux)
+		basic_machine=m68k-apple
+		os=-aux
+		;;
+	balance)
+		basic_machine=ns32k-sequent
+		os=-dynix
+		;;
+	c90)
+		basic_machine=c90-cray
+		os=-unicos
+		;;
+	convex-c1)
+		basic_machine=c1-convex
+		os=-bsd
+		;;
+	convex-c2)
+		basic_machine=c2-convex
+		os=-bsd
+		;;
+	convex-c32)
+		basic_machine=c32-convex
+		os=-bsd
+		;;
+	convex-c34)
+		basic_machine=c34-convex
+		os=-bsd
+		;;
+	convex-c38)
+		basic_machine=c38-convex
+		os=-bsd
+		;;
+	cray | j90)
+		basic_machine=j90-cray
+		os=-unicos
+		;;
+	craynv)
+		basic_machine=craynv-cray
+		os=-unicosmp
+		;;
+	cr16c)
+		basic_machine=cr16c-unknown
+		os=-elf
+		;;
+	crds | unos)
+		basic_machine=m68k-crds
+		;;
+	crisv32 | crisv32-* | etraxfs*)
+		basic_machine=crisv32-axis
+		;;
+	cris | cris-* | etrax*)
+		basic_machine=cris-axis
+		;;
+	crx)
+		basic_machine=crx-unknown
+		os=-elf
+		;;
+	da30 | da30-*)
+		basic_machine=m68k-da30
+		;;
+	decstation | decstation-3100 | pmax | pmax-* | pmin | dec3100 | decstatn)
+		basic_machine=mips-dec
+		;;
+	decsystem10* | dec10*)
+		basic_machine=pdp10-dec
+		os=-tops10
+		;;
+	decsystem20* | dec20*)
+		basic_machine=pdp10-dec
+		os=-tops20
+		;;
+	delta | 3300 | motorola-3300 | motorola-delta \
+	      | 3300-motorola | delta-motorola)
+		basic_machine=m68k-motorola
+		;;
+	delta88)
+		basic_machine=m88k-motorola
+		os=-sysv3
+		;;
+	djgpp)
+		basic_machine=i586-pc
+		os=-msdosdjgpp
+		;;
+	dpx20 | dpx20-*)
+		basic_machine=rs6000-bull
+		os=-bosx
+		;;
+	dpx2* | dpx2*-bull)
+		basic_machine=m68k-bull
+		os=-sysv3
+		;;
+	ebmon29k)
+		basic_machine=a29k-amd
+		os=-ebmon
+		;;
+	elxsi)
+		basic_machine=elxsi-elxsi
+		os=-bsd
+		;;
+	encore | umax | mmax)
+		basic_machine=ns32k-encore
+		;;
+	es1800 | OSE68k | ose68k | ose | OSE)
+		basic_machine=m68k-ericsson
+		os=-ose
+		;;
+	fx2800)
+		basic_machine=i860-alliant
+		;;
+	genix)
+		basic_machine=ns32k-ns
+		;;
+	gmicro)
+		basic_machine=tron-gmicro
+		os=-sysv
+		;;
+	go32)
+		basic_machine=i386-pc
+		os=-go32
+		;;
+	h3050r* | hiux*)
+		basic_machine=hppa1.1-hitachi
+		os=-hiuxwe2
+		;;
+	h8300hms)
+		basic_machine=h8300-hitachi
+		os=-hms
+		;;
+	h8300xray)
+		basic_machine=h8300-hitachi
+		os=-xray
+		;;
+	h8500hms)
+		basic_machine=h8500-hitachi
+		os=-hms
+		;;
+	harris)
+		basic_machine=m88k-harris
+		os=-sysv3
+		;;
+	hp300-*)
+		basic_machine=m68k-hp
+		;;
+	hp300bsd)
+		basic_machine=m68k-hp
+		os=-bsd
+		;;
+	hp300hpux)
+		basic_machine=m68k-hp
+		os=-hpux
+		;;
+	hp3k9[0-9][0-9] | hp9[0-9][0-9])
+		basic_machine=hppa1.0-hp
+		;;
+	hp9k2[0-9][0-9] | hp9k31[0-9])
+		basic_machine=m68000-hp
+		;;
+	hp9k3[2-9][0-9])
+		basic_machine=m68k-hp
+		;;
+	hp9k6[0-9][0-9] | hp6[0-9][0-9])
+		basic_machine=hppa1.0-hp
+		;;
+	hp9k7[0-79][0-9] | hp7[0-79][0-9])
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k78[0-9] | hp78[0-9])
+		# FIXME: really hppa2.0-hp
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k8[67]1 | hp8[67]1 | hp9k80[24] | hp80[24] | hp9k8[78]9 | hp8[78]9 | hp9k893 | hp893)
+		# FIXME: really hppa2.0-hp
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k8[0-9][13679] | hp8[0-9][13679])
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k8[0-9][0-9] | hp8[0-9][0-9])
+		basic_machine=hppa1.0-hp
+		;;
+	hppa-next)
+		os=-nextstep3
+		;;
+	hppaosf)
+		basic_machine=hppa1.1-hp
+		os=-osf
+		;;
+	hppro)
+		basic_machine=hppa1.1-hp
+		os=-proelf
+		;;
+	i370-ibm* | ibm*)
+		basic_machine=i370-ibm
+		;;
+# I'm not sure what "Sysv32" means.  Should this be sysv3.2?
+	i*86v32)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-sysv32
+		;;
+	i*86v4*)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-sysv4
+		;;
+	i*86v)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-sysv
+		;;
+	i*86sol2)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-solaris2
+		;;
+	i386mach)
+		basic_machine=i386-mach
+		os=-mach
+		;;
+	i386-vsta | vsta)
+		basic_machine=i386-unknown
+		os=-vsta
+		;;
+	iris | iris4d)
+		basic_machine=mips-sgi
+		case $os in
+		    -irix*)
+			;;
+		    *)
+			os=-irix4
+			;;
+		esac
+		;;
+	isi68 | isi)
+		basic_machine=m68k-isi
+		os=-sysv
+		;;
+	m88k-omron*)
+		basic_machine=m88k-omron
+		;;
+	magnum | m3230)
+		basic_machine=mips-mips
+		os=-sysv
+		;;
+	merlin)
+		basic_machine=ns32k-utek
+		os=-sysv
+		;;
+	mingw32)
+		basic_machine=i386-pc
+		os=-mingw32
+		;;
+#### MozillaHack 
+	i386-msvc | msvc)
+		basic_machine=i386-pc
+		os=-msvc
+		;;
+#### End MozillaHack 
+	miniframe)
+		basic_machine=m68000-convergent
+		;;
+	*mint | -mint[0-9]* | *MiNT | *MiNT[0-9]*)
+		basic_machine=m68k-atari
+		os=-mint
+		;;
+	mips3*-*)
+		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`
+		;;
+	mips3*)
+		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown
+		;;
+	monitor)
+		basic_machine=m68k-rom68k
+		os=-coff
+		;;
+	morphos)
+		basic_machine=powerpc-unknown
+		os=-morphos
+		;;
+	msdos)
+		basic_machine=i386-pc
+		os=-msdos
+		;;
+	mvs)
+		basic_machine=i370-ibm
+		os=-mvs
+		;;
+	ncr3000)
+		basic_machine=i486-ncr
+		os=-sysv4
+		;;
+	netbsd386)
+		basic_machine=i386-unknown
+		os=-netbsd
+		;;
+	netwinder)
+		basic_machine=armv4l-rebel
+		os=-linux
+		;;
+	news | news700 | news800 | news900)
+		basic_machine=m68k-sony
+		os=-newsos
+		;;
+	news1000)
+		basic_machine=m68030-sony
+		os=-newsos
+		;;
+	news-3600 | risc-news)
+		basic_machine=mips-sony
+		os=-newsos
+		;;
+	necv70)
+		basic_machine=v70-nec
+		os=-sysv
+		;;
+	next | m*-next )
+		basic_machine=m68k-next
+		case $os in
+		    -nextstep* )
+			;;
+		    -ns2*)
+		      os=-nextstep2
+			;;
+		    *)
+		      os=-nextstep3
+			;;
+		esac
+		;;
+	nh3000)
+		basic_machine=m68k-harris
+		os=-cxux
+		;;
+	nh[45]000)
+		basic_machine=m88k-harris
+		os=-cxux
+		;;
+	nindy960)
+		basic_machine=i960-intel
+		os=-nindy
+		;;
+	mon960)
+		basic_machine=i960-intel
+		os=-mon960
+		;;
+	nonstopux)
+		basic_machine=mips-compaq
+		os=-nonstopux
+		;;
+	np1)
+		basic_machine=np1-gould
+		;;
+	nsr-tandem)
+		basic_machine=nsr-tandem
+		;;
+	op50n-* | op60c-*)
+		basic_machine=hppa1.1-oki
+		os=-proelf
+		;;
+	openrisc | openrisc-*)
+		basic_machine=or32-unknown
+		;;
+	os400)
+		basic_machine=powerpc-ibm
+		os=-os400
+		;;
+	OSE68000 | ose68000)
+		basic_machine=m68000-ericsson
+		os=-ose
+		;;
+	os68k)
+		basic_machine=m68k-none
+		os=-os68k
+		;;
+	pa-hitachi)
+		basic_machine=hppa1.1-hitachi
+		os=-hiuxwe2
+		;;
+	paragon)
+		basic_machine=i860-intel
+		os=-osf
+		;;
+	pbd)
+		basic_machine=sparc-tti
+		;;
+	pbb)
+		basic_machine=m68k-tti
+		;;
+	pc532 | pc532-*)
+		basic_machine=ns32k-pc532
+		;;
+	pentium | p5 | k5 | k6 | nexgen | viac3)
+		basic_machine=i586-pc
+		;;
+	pentiumpro | p6 | 6x86 | athlon | athlon_*)
+		basic_machine=i686-pc
+		;;
+	pentiumii | pentium2 | pentiumiii | pentium3)
+		basic_machine=i686-pc
+		;;
+	pentium4)
+		basic_machine=i786-pc
+		;;
+	pentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)
+		basic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pentiumpro-* | p6-* | 6x86-* | athlon-*)
+		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)
+		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pentium4-*)
+		basic_machine=i786-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pn)
+		basic_machine=pn-gould
+		;;
+	power)	basic_machine=power-ibm
+		;;
+	ppc)	basic_machine=powerpc-unknown
+		;;
+	ppc-*)	basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ppcle | powerpclittle | ppc-le | powerpc-little)
+		basic_machine=powerpcle-unknown
+		;;
+	ppcle-* | powerpclittle-*)
+		basic_machine=powerpcle-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ppc64)	basic_machine=powerpc64-unknown
+		;;
+	ppc64-*) basic_machine=powerpc64-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ppc64le | powerpc64little | ppc64-le | powerpc64-little)
+		basic_machine=powerpc64le-unknown
+		;;
+	ppc64le-* | powerpc64little-*)
+		basic_machine=powerpc64le-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ps2)
+		basic_machine=i386-ibm
+		;;
+	pw32)
+		basic_machine=i586-unknown
+		os=-pw32
+		;;
+	rom68k)
+		basic_machine=m68k-rom68k
+		os=-coff
+		;;
+	rm[46]00)
+		basic_machine=mips-siemens
+		;;
+	rtpc | rtpc-*)
+		basic_machine=romp-ibm
+		;;
+	s390 | s390-*)
+		basic_machine=s390-ibm
+		;;
+	s390x | s390x-*)
+		basic_machine=s390x-ibm
+		;;
+	sa29200)
+		basic_machine=a29k-amd
+		os=-udi
+		;;
+	sb1)
+		basic_machine=mipsisa64sb1-unknown
+		;;
+	sb1el)
+		basic_machine=mipsisa64sb1el-unknown
+		;;
+	sei)
+		basic_machine=mips-sei
+		os=-seiux
+		;;
+	sequent)
+		basic_machine=i386-sequent
+		;;
+	sh)
+		basic_machine=sh-hitachi
+		os=-hms
+		;;
+	sh64)
+		basic_machine=sh64-unknown
+		;;
+	sparclite-wrs | simso-wrs)
+		basic_machine=sparclite-wrs
+		os=-vxworks
+		;;
+	sps7)
+		basic_machine=m68k-bull
+		os=-sysv2
+		;;
+	spur)
+		basic_machine=spur-unknown
+		;;
+	st2000)
+		basic_machine=m68k-tandem
+		;;
+	stratus)
+		basic_machine=i860-stratus
+		os=-sysv4
+		;;
+	sun2)
+		basic_machine=m68000-sun
+		;;
+	sun2os3)
+		basic_machine=m68000-sun
+		os=-sunos3
+		;;
+	sun2os4)
+		basic_machine=m68000-sun
+		os=-sunos4
+		;;
+	sun3os3)
+		basic_machine=m68k-sun
+		os=-sunos3
+		;;
+	sun3os4)
+		basic_machine=m68k-sun
+		os=-sunos4
+		;;
+	sun4os3)
+		basic_machine=sparc-sun
+		os=-sunos3
+		;;
+	sun4os4)
+		basic_machine=sparc-sun
+		os=-sunos4
+		;;
+	sun4sol2)
+		basic_machine=sparc-sun
+		os=-solaris2
+		;;
+	sun3 | sun3-*)
+		basic_machine=m68k-sun
+		;;
+	sun4)
+		basic_machine=sparc-sun
+		;;
+	sun386 | sun386i | roadrunner)
+		basic_machine=i386-sun
+		;;
+	sv1)
+		basic_machine=sv1-cray
+		os=-unicos
+		;;
+	symmetry)
+		basic_machine=i386-sequent
+		os=-dynix
+		;;
+	t3e)
+		basic_machine=alphaev5-cray
+		os=-unicos
+		;;
+	t90)
+		basic_machine=t90-cray
+		os=-unicos
+		;;
+	tic54x | c54x*)
+		basic_machine=tic54x-unknown
+		os=-coff
+		;;
+	tic55x | c55x*)
+		basic_machine=tic55x-unknown
+		os=-coff
+		;;
+	tic6x | c6x*)
+		basic_machine=tic6x-unknown
+		os=-coff
+		;;
+	tx39)
+		basic_machine=mipstx39-unknown
+		;;
+	tx39el)
+		basic_machine=mipstx39el-unknown
+		;;
+	toad1)
+		basic_machine=pdp10-xkl
+		os=-tops20
+		;;
+	tower | tower-32)
+		basic_machine=m68k-ncr
+		;;
+	tpf)
+		basic_machine=s390x-ibm
+		os=-tpf
+		;;
+	udi29k)
+		basic_machine=a29k-amd
+		os=-udi
+		;;
+	ultra3)
+		basic_machine=a29k-nyu
+		os=-sym1
+		;;
+	v810 | necv810)
+		basic_machine=v810-nec
+		os=-none
+		;;
+	vaxv)
+		basic_machine=vax-dec
+		os=-sysv
+		;;
+	vms)
+		basic_machine=vax-dec
+		os=-vms
+		;;
+	vpp*|vx|vx-*)
+		basic_machine=f301-fujitsu
+		;;
+	vxworks960)
+		basic_machine=i960-wrs
+		os=-vxworks
+		;;
+	vxworks68)
+		basic_machine=m68k-wrs
+		os=-vxworks
+		;;
+	vxworks29k)
+		basic_machine=a29k-wrs
+		os=-vxworks
+		;;
+	w65*)
+		basic_machine=w65-wdc
+		os=-none
+		;;
+	w89k-*)
+		basic_machine=hppa1.1-winbond
+		os=-proelf
+		;;
+	xbox)
+		basic_machine=i686-pc
+		os=-mingw32
+		;;
+	xps | xps100)
+		basic_machine=xps100-honeywell
+		;;
+	ymp)
+		basic_machine=ymp-cray
+		os=-unicos
+		;;
+	z8k-*-coff)
+		basic_machine=z8k-unknown
+		os=-sim
+		;;
+	none)
+		basic_machine=none-none
+		os=-none
+		;;
+
+# Here we handle the default manufacturer of certain CPU types.  It is in
+# some cases the only manufacturer, in others, it is the most popular.
+	w89k)
+		basic_machine=hppa1.1-winbond
+		;;
+	op50n)
+		basic_machine=hppa1.1-oki
+		;;
+	op60c)
+		basic_machine=hppa1.1-oki
+		;;
+	romp)
+		basic_machine=romp-ibm
+		;;
+	mmix)
+		basic_machine=mmix-knuth
+		;;
+	rs6000)
+		basic_machine=rs6000-ibm
+		;;
+	vax)
+		basic_machine=vax-dec
+		;;
+	pdp10)
+		# there are many clones, so DEC is not a safe bet
+		basic_machine=pdp10-unknown
+		;;
+	pdp11)
+		basic_machine=pdp11-dec
+		;;
+	we32k)
+		basic_machine=we32k-att
+		;;
+	sh[1234] | sh[24]a | sh[34]eb | sh[1234]le | sh[23]ele)
+		basic_machine=sh-unknown
+		;;
+	sparc | sparcv8 | sparcv9 | sparcv9b)
+		basic_machine=sparc-sun
+		;;
+	cydra)
+		basic_machine=cydra-cydrome
+		;;
+	orion)
+		basic_machine=orion-highlevel
+		;;
+	orion105)
+		basic_machine=clipper-highlevel
+		;;
+	mac | mpw | mac-mpw)
+		basic_machine=m68k-apple
+		;;
+	pmac | pmac-mpw)
+		basic_machine=powerpc-apple
+		;;
+	*-unknown)
+		# Make sure to match an already-canonicalized machine name.
+		;;
+	*)
+		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
+		exit 1
+		;;
+esac
+
+# Here we canonicalize certain aliases for manufacturers.
+case $basic_machine in
+	*-digital*)
+		basic_machine=`echo $basic_machine | sed 's/digital.*/dec/'`
+		;;
+	*-commodore*)
+		basic_machine=`echo $basic_machine | sed 's/commodore.*/cbm/'`
+		;;
+	*)
+		;;
+esac
+
+# Decode manufacturer-specific aliases for certain operating systems.
+
+if [ x"$os" != x"" ]
+then
+case $os in
+        # First match some system type aliases
+        # that might get confused with valid system types.
+	# -solaris* is a basic system type, with this one exception.
+	-solaris1 | -solaris1.*)
+		os=`echo $os | sed -e 's|solaris1|sunos4|'`
+		;;
+	-solaris)
+		os=-solaris2
+		;;
+	-svr4*)
+		os=-sysv4
+		;;
+	-unixware*)
+		os=-sysv4.2uw
+		;;
+	-gnu/linux*)
+		os=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`
+		;;
+	# First accept the basic system types.
+	# The portable systems comes first.
+	# Each alternative MUST END IN A *, to match a version number.
+	# -sysv* is not here because it comes later, after sysvr4.
+#### MozillaHack 
+# msvc
+#### End MozillaHack 
+	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
+	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -sunos | -sunos[34]*\
+	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -solaris* | -sym* \
+	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
+	      | -aos* \
+	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
+	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
+	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* | -openbsd* \
+	      | -ekkobsd* | -kfreebsd* | -freebsd* | -riscix* | -lynxos* \
+	      | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
+	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
+	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
+	      | -chorusos* | -chorusrdb* \
+	      | -cygwin* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
+	      | -mingw32* | -linux-gnu* | -linux-uclibc* | -uxpv* | -beos* | -mpeix* | -udk* \
+	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
+	      | -msvc* \
+	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
+	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
+	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
+	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
+	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
+	      | -skyos* | -haiku*)
+	# Remember, each alternative MUST END IN *, to match a version number.
+		;;
+	-qnx*)
+		case $basic_machine in
+		    x86-* | i*86-*)
+			;;
+		    *)
+			os=-nto$os
+			;;
+		esac
+		;;
+	-nto-qnx*)
+		;;
+	-nto*)
+		os=`echo $os | sed -e 's|nto|nto-qnx|'`
+		;;
+	-sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \
+	      | -windows* | -osx | -abug | -netware* | -os9* | -beos* | -haiku* \
+	      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)
+		;;
+	-mac*)
+		os=`echo $os | sed -e 's|mac|macos|'`
+		;;
+	-linux-dietlibc)
+		os=-linux-dietlibc
+		;;
+	-linux*)
+		os=`echo $os | sed -e 's|linux|linux-gnu|'`
+		;;
+	-sunos5*)
+		os=`echo $os | sed -e 's|sunos5|solaris2|'`
+		;;
+	-sunos6*)
+		os=`echo $os | sed -e 's|sunos6|solaris3|'`
+		;;
+	-opened*)
+		os=-openedition
+		;;
+        -os400*)
+		os=-os400
+		;;
+	-wince*)
+		os=-wince
+		;;
+	-osfrose*)
+		os=-osfrose
+		;;
+	-osf*)
+		os=-osf
+		;;
+	-utek*)
+		os=-bsd
+		;;
+	-dynix*)
+		os=-bsd
+		;;
+	-acis*)
+		os=-aos
+		;;
+	-atheos*)
+		os=-atheos
+		;;
+	-syllable*)
+		os=-syllable
+		;;
+	-386bsd)
+		os=-bsd
+		;;
+	-ctix* | -uts*)
+		os=-sysv
+		;;
+	-nova*)
+		os=-rtmk-nova
+		;;
+	-ns2 )
+		os=-nextstep2
+		;;
+	-nsk*)
+		os=-nsk
+		;;
+	# Preserve the version number of sinix5.
+	-sinix5.*)
+		os=`echo $os | sed -e 's|sinix|sysv|'`
+		;;
+	-sinix*)
+		os=-sysv4
+		;;
+        -tpf*)
+		os=-tpf
+		;;
+	-triton*)
+		os=-sysv3
+		;;
+	-oss*)
+		os=-sysv3
+		;;
+	-svr4)
+		os=-sysv4
+		;;
+	-svr3)
+		os=-sysv3
+		;;
+	-sysvr4)
+		os=-sysv4
+		;;
+	# This must come after -sysvr4.
+	-sysv*)
+		;;
+	-ose*)
+		os=-ose
+		;;
+	-es1800*)
+		os=-ose
+		;;
+	-xenix)
+		os=-xenix
+		;;
+	-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
+		os=-mint
+		;;
+	-aros*)
+		os=-aros
+		;;
+	-kaos*)
+		os=-kaos
+		;;
+	-zvmoe)
+		os=-zvmoe
+		;;
+	-none)
+		;;
+	*)
+		# Get rid of the `-' at the beginning of $os.
+		os=`echo $os | sed 's/[^-]*-//'`
+		echo Invalid configuration \`$1\': system \`$os\' not recognized 1>&2
+		exit 1
+		;;
+esac
+else
+
+# Here we handle the default operating systems that come with various machines.
+# The value should be what the vendor currently ships out the door with their
+# machine or put another way, the most popular os provided with the machine.
+
+# Note that if you're going to try to match "-MANUFACTURER" here (say,
+# "-sun"), then you have to tell the case statement up towards the top
+# that MANUFACTURER isn't an operating system.  Otherwise, code above
+# will signal an error saying that MANUFACTURER isn't an operating
+# system, and we'll never get to this point.
+
+case $basic_machine in
+	*-acorn)
+		os=-riscix1.2
+		;;
+	arm*-rebel)
+		os=-linux
+		;;
+	arm*-semi)
+		os=-aout
+		;;
+    c4x-* | tic4x-*)
+        os=-coff
+        ;;
+	# This must come before the *-dec entry.
+	pdp10-*)
+		os=-tops20
+		;;
+	pdp11-*)
+		os=-none
+		;;
+	*-dec | vax-*)
+		os=-ultrix4.2
+		;;
+	m68*-apollo)
+		os=-domain
+		;;
+	i386-sun)
+		os=-sunos4.0.2
+		;;
+	m68000-sun)
+		os=-sunos3
+		# This also exists in the configure program, but was not the
+		# default.
+		# os=-sunos4
+		;;
+	m68*-cisco)
+		os=-aout
+		;;
+	mips*-cisco)
+		os=-elf
+		;;
+	mips*-*)
+		os=-elf
+		;;
+	or32-*)
+		os=-coff
+		;;
+	*-tti)	# must be before sparc entry or we get the wrong os.
+		os=-sysv3
+		;;
+	sparc-* | *-sun)
+		os=-sunos4.1.1
+		;;
+	*-be)
+		os=-beos
+		;;
+	*-haiku)
+		os=-haiku
+		;;
+	*-ibm)
+		os=-aix
+		;;
+    	*-knuth)
+		os=-mmixware
+		;;
+	*-wec)
+		os=-proelf
+		;;
+	*-winbond)
+		os=-proelf
+		;;
+	*-oki)
+		os=-proelf
+		;;
+	*-hp)
+		os=-hpux
+		;;
+	*-hitachi)
+		os=-hiux
+		;;
+	i860-* | *-att | *-ncr | *-altos | *-motorola | *-convergent)
+		os=-sysv
+		;;
+	*-cbm)
+		os=-amigaos
+		;;
+	*-dg)
+		os=-dgux
+		;;
+	*-dolphin)
+		os=-sysv3
+		;;
+	m68k-ccur)
+		os=-rtu
+		;;
+	m88k-omron*)
+		os=-luna
+		;;
+	*-next )
+		os=-nextstep
+		;;
+	*-sequent)
+		os=-ptx
+		;;
+	*-crds)
+		os=-unos
+		;;
+	*-ns)
+		os=-genix
+		;;
+	i370-*)
+		os=-mvs
+		;;
+	*-next)
+		os=-nextstep3
+		;;
+	*-gould)
+		os=-sysv
+		;;
+	*-highlevel)
+		os=-bsd
+		;;
+	*-encore)
+		os=-bsd
+		;;
+	*-sgi)
+		os=-irix
+		;;
+	*-siemens)
+		os=-sysv4
+		;;
+	*-masscomp)
+		os=-rtu
+		;;
+	f30[01]-fujitsu | f700-fujitsu)
+		os=-uxpv
+		;;
+	*-rom68k)
+		os=-coff
+		;;
+	*-*bug)
+		os=-coff
+		;;
+	*-apple)
+		os=-macos
+		;;
+	*-atari*)
+		os=-mint
+		;;
+	*)
+		os=-none
+		;;
+esac
+fi
+
+# Here we handle the case where we know the os, and the CPU type, but not the
+# manufacturer.  We pick the logical manufacturer.
+vendor=unknown
+case $basic_machine in
+	*-unknown)
+		case $os in
+			-riscix*)
+				vendor=acorn
+				;;
+			-sunos*)
+				vendor=sun
+				;;
+			-aix*)
+				vendor=ibm
+				;;
+			-beos*)
+				vendor=be
+				;;
+			-hpux*)
+				vendor=hp
+				;;
+			-mpeix*)
+				vendor=hp
+				;;
+			-hiux*)
+				vendor=hitachi
+				;;
+			-unos*)
+				vendor=crds
+				;;
+			-dgux*)
+				vendor=dg
+				;;
+			-luna*)
+				vendor=omron
+				;;
+			-genix*)
+				vendor=ns
+				;;
+			-mvs* | -opened*)
+				vendor=ibm
+				;;
+			-os400*)
+				vendor=ibm
+				;;
+			-ptx*)
+				vendor=sequent
+				;;
+			-tpf*)
+				vendor=ibm
+				;;
+			-vxsim* | -vxworks* | -windiss*)
+				vendor=wrs
+				;;
+			-aux*)
+				vendor=apple
+				;;
+			-hms*)
+				vendor=hitachi
+				;;
+			-mpw* | -macos*)
+				vendor=apple
+				;;
+			-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
+				vendor=atari
+				;;
+			-vos*)
+				vendor=stratus
+				;;
+		esac
+		basic_machine=`echo $basic_machine | sed "s/unknown/$vendor/"`
+		;;
+esac
+
+echo $basic_machine$os
+exit
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "timestamp='"
+# time-stamp-format: "%:y-%02m-%02d"
+# time-stamp-end: "'"
+# End:
diff -r 17e9560465b0 js/src/build/autoconf/glib.m4
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/build/autoconf/glib.m4	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,200 @@
+# Configure paths for GLIB
+# Owen Taylor     97-11-3
+
+dnl AM_PATH_GLIB([MINIMUM-VERSION, [ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND [, MODULES]]]])
+dnl Test for GLIB, and define GLIB_CFLAGS and GLIB_LIBS, if "gmodule" or 
+dnl gthread is specified in MODULES, pass to glib-config
+dnl
+AC_DEFUN([AM_PATH_GLIB],
+[dnl 
+dnl Get the cflags and libraries from the glib-config script
+dnl
+AC_ARG_WITH(glib-prefix,[  --with-glib-prefix=PFX  Prefix where GLIB is installed (optional)],
+            glib_config_prefix="$withval", glib_config_prefix="")
+AC_ARG_WITH(glib-exec-prefix,[  --with-glib-exec-prefix=PFX
+                          Exec prefix where GLIB is installed (optional)],
+            glib_config_exec_prefix="$withval", glib_config_exec_prefix="")
+AC_ARG_ENABLE(glibtest, [  --disable-glibtest      Do not try to compile and run a test GLIB program],
+		    , enable_glibtest=yes)
+
+  if test x$glib_config_exec_prefix != x ; then
+     glib_config_args="$glib_config_args --exec-prefix=$glib_config_exec_prefix"
+     if test x${GLIB_CONFIG+set} != xset ; then
+        GLIB_CONFIG=$glib_config_exec_prefix/bin/glib-config
+     fi
+  fi
+  if test x$glib_config_prefix != x ; then
+     glib_config_args="$glib_config_args --prefix=$glib_config_prefix"
+     if test x${GLIB_CONFIG+set} != xset ; then
+        GLIB_CONFIG=$glib_config_prefix/bin/glib-config
+     fi
+  fi
+
+  for module in . $4
+  do
+      case "$module" in
+         gmodule) 
+             glib_config_args="$glib_config_args gmodule"
+         ;;
+         gthread) 
+             glib_config_args="$glib_config_args gthread"
+         ;;
+      esac
+  done
+
+  dnl Force a version check to keep upgraded versions from being overridden by the cached value.
+  unset ac_cv_path_GLIB_CONFIG
+
+  AC_PATH_PROG(GLIB_CONFIG, glib-config, no)
+  min_glib_version=ifelse([$1], ,0.99.7,$1)
+  AC_MSG_CHECKING(for GLIB - version >= $min_glib_version)
+  no_glib=""
+  if test "$GLIB_CONFIG" = "no" ; then
+    no_glib=yes
+  else
+    GLIB_CFLAGS=`$GLIB_CONFIG $glib_config_args --cflags`
+    GLIB_LIBS=`$GLIB_CONFIG $glib_config_args --libs`
+    glib_config_major_version=`$GLIB_CONFIG $glib_config_args --version | \
+           sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\1/'`
+    glib_config_minor_version=`$GLIB_CONFIG $glib_config_args --version | \
+           sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\2/'`
+    glib_config_micro_version=`$GLIB_CONFIG $glib_config_args --version | \
+           sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\3/'`
+    if test "x$enable_glibtest" = "xyes" ; then
+      ac_save_CFLAGS="$CFLAGS"
+      ac_save_LIBS="$LIBS"
+      CFLAGS="$CFLAGS $GLIB_CFLAGS"
+      LIBS="$GLIB_LIBS $LIBS"
+dnl
+dnl Now check if the installed GLIB is sufficiently new. (Also sanity
+dnl checks the results of glib-config to some extent
+dnl
+      rm -f conf.glibtest
+      AC_TRY_RUN([
+#include <glib.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+int 
+main ()
+{
+  int major, minor, micro;
+  char *tmp_version;
+
+  system ("touch conf.glibtest");
+
+  /* HP/UX 9 (%@#!) writes to sscanf strings */
+  tmp_version = g_strdup("$min_glib_version");
+  if (sscanf(tmp_version, "%d.%d.%d", &major, &minor, &micro) != 3) {
+     printf("%s, bad version string\n", "$min_glib_version");
+     exit(1);
+   }
+
+  if ((glib_major_version != $glib_config_major_version) ||
+      (glib_minor_version != $glib_config_minor_version) ||
+      (glib_micro_version != $glib_config_micro_version))
+    {
+      printf("\n*** 'glib-config --version' returned %d.%d.%d, but GLIB (%d.%d.%d)\n", 
+             $glib_config_major_version, $glib_config_minor_version, $glib_config_micro_version,
+             glib_major_version, glib_minor_version, glib_micro_version);
+      printf ("*** was found! If glib-config was correct, then it is best\n");
+      printf ("*** to remove the old version of GLIB. You may also be able to fix the error\n");
+      printf("*** by modifying your LD_LIBRARY_PATH environment variable, or by editing\n");
+      printf("*** /etc/ld.so.conf. Make sure you have run ldconfig if that is\n");
+      printf("*** required on your system.\n");
+      printf("*** If glib-config was wrong, set the environment variable GLIB_CONFIG\n");
+      printf("*** to point to the correct copy of glib-config, and remove the file config.cache\n");
+      printf("*** before re-running configure\n");
+    } 
+  else if ((glib_major_version != GLIB_MAJOR_VERSION) ||
+	   (glib_minor_version != GLIB_MINOR_VERSION) ||
+           (glib_micro_version != GLIB_MICRO_VERSION))
+    {
+      printf("*** GLIB header files (version %d.%d.%d) do not match\n",
+	     GLIB_MAJOR_VERSION, GLIB_MINOR_VERSION, GLIB_MICRO_VERSION);
+      printf("*** library (version %d.%d.%d)\n",
+	     glib_major_version, glib_minor_version, glib_micro_version);
+    }
+  else
+    {
+      if ((glib_major_version > major) ||
+        ((glib_major_version == major) && (glib_minor_version > minor)) ||
+        ((glib_major_version == major) && (glib_minor_version == minor) && (glib_micro_version >= micro)))
+      {
+        return 0;
+       }
+     else
+      {
+        printf("\n*** An old version of GLIB (%d.%d.%d) was found.\n",
+               glib_major_version, glib_minor_version, glib_micro_version);
+        printf("*** You need a version of GLIB newer than %d.%d.%d. The latest version of\n",
+	       major, minor, micro);
+        printf("*** GLIB is always available from ftp://ftp.gtk.org.\n");
+        printf("***\n");
+        printf("*** If you have already installed a sufficiently new version, this error\n");
+        printf("*** probably means that the wrong copy of the glib-config shell script is\n");
+        printf("*** being found. The easiest way to fix this is to remove the old version\n");
+        printf("*** of GLIB, but you can also set the GLIB_CONFIG environment to point to the\n");
+        printf("*** correct copy of glib-config. (In this case, you will have to\n");
+        printf("*** modify your LD_LIBRARY_PATH environment variable, or edit /etc/ld.so.conf\n");
+        printf("*** so that the correct libraries are found at run-time))\n");
+      }
+    }
+  return 1;
+}
+],, no_glib=yes,[echo $ac_n "cross compiling; assumed OK... $ac_c"])
+       CFLAGS="$ac_save_CFLAGS"
+       LIBS="$ac_save_LIBS"
+     fi
+  fi
+  if test "x$no_glib" = x ; then
+     AC_MSG_RESULT(yes)
+     ifelse([$2], , :, [$2])     
+  else
+     AC_MSG_RESULT(no)
+     if test "$GLIB_CONFIG" = "no" ; then
+       echo "*** The glib-config script installed by GLIB could not be found"
+       echo "*** If GLIB was installed in PREFIX, make sure PREFIX/bin is in"
+       echo "*** your path, or set the GLIB_CONFIG environment variable to the"
+       echo "*** full path to glib-config."
+     else
+       if test -f conf.glibtest ; then
+        :
+       else
+          echo "*** Could not run GLIB test program, checking why..."
+          CFLAGS="$CFLAGS $GLIB_CFLAGS"
+          LIBS="$LIBS $GLIB_LIBS"
+          AC_TRY_LINK([
+#include <glib.h>
+#include <stdio.h>
+],      [ return ((glib_major_version) || (glib_minor_version) || (glib_micro_version)); ],
+        [ echo "*** The test program compiled, but did not run. This usually means"
+          echo "*** that the run-time linker is not finding GLIB or finding the wrong"
+          echo "*** version of GLIB. If it is not finding GLIB, you'll need to set your"
+          echo "*** LD_LIBRARY_PATH environment variable, or edit /etc/ld.so.conf to point"
+          echo "*** to the installed location  Also, make sure you have run ldconfig if that"
+          echo "*** is required on your system"
+	  echo "***"
+          echo "*** If you have an old version installed, it is best to remove it, although"
+          echo "*** you may also be able to get things to work by modifying LD_LIBRARY_PATH"
+          echo "***"
+          echo "*** If you have a RedHat 5.0 system, you should remove the GTK package that"
+          echo "*** came with the system with the command"
+          echo "***"
+          echo "***    rpm --erase --nodeps gtk gtk-devel" ],
+        [ echo "*** The test program failed to compile or link. See the file config.log for the"
+          echo "*** exact error that occured. This usually means GLIB was incorrectly installed"
+          echo "*** or that you have moved GLIB since it was installed. In the latter case, you"
+          echo "*** may want to edit the glib-config script: $GLIB_CONFIG" ])
+          CFLAGS="$ac_save_CFLAGS"
+          LIBS="$ac_save_LIBS"
+       fi
+     fi
+     GLIB_CFLAGS=""
+     GLIB_LIBS=""
+     ifelse([$3], , :, [$3])
+  fi
+  AC_SUBST(GLIB_CFLAGS)
+  AC_SUBST(GLIB_LIBS)
+  rm -f conf.glibtest
+])
diff -r 17e9560465b0 js/src/build/autoconf/install-sh
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/build/autoconf/install-sh	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,119 @@
+#!/bin/sh
+
+#
+# install - install a program, script, or datafile
+# This comes from X11R5; it is not part of GNU.
+#
+# $XConsortium: install.sh,v 1.2 89/12/18 14:47:22 jim Exp $
+#
+# This script is compatible with the BSD install script, but was written
+# from scratch.
+#
+
+
+# set DOITPROG to echo to test this script
+
+# Don't use :- since 4.3BSD and earlier shells don't like it.
+doit="${DOITPROG-}"
+
+
+# put in absolute paths if you don't have them in your path; or use env. vars.
+
+mvprog="${MVPROG-mv}"
+cpprog="${CPPROG-cp}"
+chmodprog="${CHMODPROG-chmod}"
+chownprog="${CHOWNPROG-chown}"
+chgrpprog="${CHGRPPROG-chgrp}"
+stripprog="${STRIPPROG-strip}"
+rmprog="${RMPROG-rm}"
+
+instcmd="$mvprog"
+chmodcmd=""
+chowncmd=""
+chgrpcmd=""
+stripcmd=""
+rmcmd="$rmprog -f"
+mvcmd="$mvprog"
+src=""
+dst=""
+
+while [ x"$1" != x ]; do
+    case $1 in
+	-c) instcmd="$cpprog"
+	    shift
+	    continue;;
+
+	-m) chmodcmd="$chmodprog $2"
+	    shift
+	    shift
+	    continue;;
+
+	-o) chowncmd="$chownprog $2"
+	    shift
+	    shift
+	    continue;;
+
+	-g) chgrpcmd="$chgrpprog $2"
+	    shift
+	    shift
+	    continue;;
+
+	-s) stripcmd="$stripprog"
+	    shift
+	    continue;;
+
+	*)  if [ x"$src" = x ]
+	    then
+		src=$1
+	    else
+		dst=$1
+	    fi
+	    shift
+	    continue;;
+    esac
+done
+
+if [ x"$src" = x ]
+then
+	echo "install:  no input file specified"
+	exit 1
+fi
+
+if [ x"$dst" = x ]
+then
+	echo "install:  no destination specified"
+	exit 1
+fi
+
+
+# If destination is a directory, append the input filename; if your system
+# does not like double slashes in filenames, you may need to add some logic
+
+if [ -d $dst ]
+then
+	dst="$dst"/`basename $src`
+fi
+
+# Make a temp file name in the proper directory.
+
+dstdir=`dirname $dst`
+dsttmp=$dstdir/#inst.$$#
+
+# Move or copy the file name to the temp name
+
+$doit $instcmd $src $dsttmp
+
+# and set any options; do chmod last to preserve setuid bits
+
+if [ x"$chowncmd" != x ]; then $doit $chowncmd $dsttmp; fi
+if [ x"$chgrpcmd" != x ]; then $doit $chgrpcmd $dsttmp; fi
+if [ x"$stripcmd" != x ]; then $doit $stripcmd $dsttmp; fi
+if [ x"$chmodcmd" != x ]; then $doit $chmodcmd $dsttmp; fi
+
+# Now rename the file to the real destination.
+
+$doit $rmcmd $dst
+$doit $mvcmd $dsttmp $dst
+
+
+exit 0
diff -r 17e9560465b0 js/src/build/autoconf/make-makefile
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/build/autoconf/make-makefile	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,315 @@
+#! /usr/bin/env perl
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+# Netscape Communications Corporation.
+# Portions created by the Initial Developer are Copyright (C) 1999
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+# make-makefiles - Quickly create Makefiles for subdirectories.
+#      Also, creates any needed subdirectories.
+#
+# usage: make-makefiles [ -t <topsrcdir> -p <print_topsrcdir> -d <depth> ] [ <subdir> | <subdir>/Makefile ] ...
+
+# Send comments, improvements, bugs to Steve Lamm (slamm@netscape.com).
+
+#$debug = 1;
+
+# Determine various tree path variables
+#
+($topsrcdir, $ptopsrcdir, $depth, @makefiles) = parse_arguments(@ARGV);
+
+$object_fullpath = `pwd`;
+chdir $depth;
+$object_root = `pwd`;
+chomp $object_fullpath;
+chomp $object_root;
+
+# $source_subdir is the path from the object root to where
+#    'make-makefile' was called. For example, if make-makefile was
+#    called from "mozilla/gfx/src", then $source_subdir would be
+#    "gfx/src/".
+$source_subdir = "$object_fullpath/";
+my $quoted_object_root = quotemeta($object_root);
+$source_subdir =~ s|^$quoted_object_root/||;
+
+# Prefix makefiles with $source_subdir so that paths
+# will be relative to the top of the object tree.
+#
+for $makefile (@makefiles) {
+  $makefile = "$source_subdir$makefile";
+}
+
+create_directories(@makefiles);
+
+# Find the path to the source directory based on how 'make-makefile'
+#  was invoked. The path is either relative to the object directory
+#  or an absolute path.
+$given_srcdir = find_srcdir($topsrcdir, $depth);
+$pgiven_srcdir = find_srcdir($ptopsrcdir, $depth);
+
+if ($debug) {
+  warn "object_fullpath = $object_fullpath\n";
+  warn "object_root     = $object_root\n";
+  warn "source_subdir   = $source_subdir\n";
+  warn "makefiles       = @makefiles\n";
+  warn "given_srcdir    = $given_srcdir\n";
+}
+
+@unhandled = update_makefiles($given_srcdir, $pgiven_srcdir, @makefiles);
+
+run_config_status(@unhandled);
+
+# end of Main
+############################################################
+
+sub dirname {
+ return $_[0] =~ /(.*)\/.*/ ? "$1" : '.';
+}
+
+# find_depth: Pull the value of DEPTH out of a Makefile (or Makefile.in)
+sub find_depth {
+  my $depth = '';
+  open(MAKEFILE, "<$_[0]") || die "Unable to open $_[0]: $!\n";
+  while (<MAKEFILE>) {
+    next unless /^DEPTH\s*=\s*(\..*)/;
+    $depth = $1;
+    last;
+  }
+  close MAKEFILE;
+  return $depth;
+}
+
+sub parse_arguments {
+  my @args = @_;
+  my $depth = '';
+  my $topsrcdir = '';
+  my $ptopsrcdir;
+  my @makefiles = ();
+
+  while (1) {
+    if ($args[0] eq '-d') {
+      $depth = $args[1];
+      shift @args; 
+      shift @args; 
+    } elsif ($args[0] eq '-t') {
+      $topsrcdir = $args[1];
+      shift @args; 
+      shift @args; 
+    } elsif ($args[0] eq '-p') {
+      $ptopsrcdir = $args[1];
+      shift @args;
+      shift @args;
+    } else {
+      last;
+    }
+  }
+
+  if ($topsrcdir eq '') {
+    $topsrcdir = $0; # Figure out topsrcdir based on program name.
+    $topsrcdir =~ s|/?build/autoconf/.*$||;
+  }
+  if ($ptopsrcdir eq '') {
+    $ptopsrcdir = $topsrcdir;
+  }
+  if ($depth eq '') {
+    # Use $(DEPTH) in the Makefile or Makefile.in to determine the depth
+    if (-e "Makefile.in") {
+      $depth = find_depth("Makefile.in");
+    } elsif (-e "Makefile") {
+      $depth = find_depth("Makefile");
+    } elsif (-e "../Makefile") {
+      $depth = "../".find_depth("../Makefile");
+      $depth =~ s/\/\.$//;
+    } else {
+      warn "Unable to determine depth (e.g. ../..) to root of objdir tree.\n";
+      die  "No Makefile(.in) present. Try running with '-d <depth>'\n";
+    }
+  } 
+
+  # Build the list of makefiles to generate
+  #
+  @makefiles = ();
+  my $makefile;
+  foreach $makefile (@args) {
+    $makefile =~ s/\.in$//;
+    $makefile =~ s/\/$//;
+    $makefile =~ /Makefile$/ or $makefile .= "/Makefile";
+    push @makefiles, "$makefile";
+  }
+  @makefiles = "Makefile" unless @args;
+
+  return ($topsrcdir, $ptopsrcdir, $depth, @makefiles);
+}
+
+
+# Create all the directories at once.
+#   This can be much faster than calling mkdir() for each one.
+sub create_directories {
+  my @makefiles = @_;
+  my @dirs = ();
+  my $ac_file;
+  foreach $ac_file (@makefiles) {
+    push @dirs, dirname($ac_file);
+  }
+  # Call mkdir with the directories sorted by subdir count (how many /'s)
+  system "mkdir -p ". join(' ', map("\"$_\"", @dirs)) if @dirs;
+}
+
+# Find the top of the source directory
+# (Assuming that the executable is in $top_srcdir/build/autoconf)
+sub find_srcdir {
+  my ($ac_given_srcdir, $depth) = @_;
+
+  if ($debug) {
+    print "ac_given_srcdir = $ac_given_srcdir\n";
+    print "depth           = $depth\n";
+  }
+  if ($ac_given_srcdir =~ /^\./ and $depth ne '.') {
+    my $quoted_depth = quotemeta($depth);
+    $ac_given_srcdir =~ s|^$quoted_depth/?||;
+  }
+  if ($debug) {
+    print "ac_given_srcdir = $ac_given_srcdir\n";
+  }
+  $ac_given_srcdir = '.' if $ac_given_srcdir eq '';
+  return $ac_given_srcdir;
+}
+
+# Output the makefiles.
+#
+sub update_makefiles {
+  my ($ac_given_srcdir, $pac_given_srcdir, @makefiles) = @_;
+  my @unhandled=();
+
+  my $ac_file;
+  foreach $ac_file (@makefiles) {
+    my $ac_file_in    = "$ac_given_srcdir/${ac_file}.in";
+    my $ac_dir        = dirname($ac_file);
+    my $ac_dots       = '';
+    my $ac_dir_suffix = '';
+    my $srcdir        = '.';
+    my $top_srcdir    = '.';
+
+    # Determine $srcdir and $top_srcdir
+    #
+    if ($ac_dir ne '.') {
+      $ac_dir_suffix = "/$ac_dir";
+      $ac_dir_suffix =~ s%^/\./%/%;
+      $ac_dots = $ac_dir_suffix;
+      # Remove .. components from the provided dir suffix, and
+      # also the forward path components they were reversing.
+      my $backtracks = $ac_dots =~ s%\.\.(/|$)%%g;
+      while ($backtracks--) {
+        $ac_dots =~ s%/[^/]*%%;
+      }
+      $ac_dots =~ s%/[^/]*%../%g;
+    }
+    if ($ac_given_srcdir eq '.') {
+      if ($ac_dots ne '') {
+        $top_srcdir = $ac_dots;
+        $top_srcdir =~ s%/$%%;
+      }
+    } elsif ($pac_given_srcdir =~ m%^/% or $pac_given_srcdir =~ m%^.:/%) {
+      $srcdir     = "$pac_given_srcdir$ac_dir_suffix";
+      $top_srcdir = "$pac_given_srcdir";
+    } else {
+      if ($debug) {
+      	print "ac_dots       = $ac_dots\n";
+	print "ac_dir_suffix = $ac_dir_suffix\n";
+      }
+      $srcdir     = "$ac_dots$ac_given_srcdir$ac_dir_suffix";
+      $top_srcdir = "$ac_dots$ac_given_srcdir";
+    }
+
+    if ($debug) {
+      print "ac_dir     = $ac_dir\n";
+      print "ac_file    = $ac_file\n";
+      print "ac_file_in = $ac_file_in\n";
+      print "srcdir     = $srcdir\n";
+      print "top_srcdir = $top_srcdir\n";
+      print "cwd        = " . `pwd` . "\n";
+    }
+
+    # Copy the file and make substitutions.
+    #    @srcdir@     -> value of $srcdir
+    #    @top_srcdir@ -> value of $top_srcdir
+    #
+    if (-e $ac_file) {
+      next if -M _ < -M $ac_file_in;  # Next if Makefile is up-to-date.
+      warn "updating $ac_file\n";
+    } else {
+      warn "creating $ac_file\n";
+    }
+
+    open INFILE, "<$ac_file_in" or do {
+      warn "$0: Cannot read $ac_file_in: No such file or directory\n";
+      next;
+    };
+    open OUTFILE, ">$ac_file" or do {
+      warn "$0: Unable to create $ac_file\n";
+      next;
+    };
+
+    while (<INFILE>) {
+      #if (/\@[_a-zA-Z]*\@.*\@[_a-zA-Z]*\@/) {
+      #  #warn "Two defines on a line:$ac_file:$.:$_";
+      #  push @unhandled, $ac_file;
+      #  last;
+      #}
+
+      s/\@srcdir\@/$srcdir/g;
+      s/\@top_srcdir\@/$top_srcdir/g;
+
+      if (/\@[_a-zA-Z]*\@/) {
+        #warn "Unknown variable:$ac_file:$.:$_";
+        push @unhandled, $ac_file;
+        last;
+      }
+      print OUTFILE;
+    }
+    close INFILE;
+    close OUTFILE;
+  }
+  return @unhandled;
+}
+
+sub run_config_status {
+  my @unhandled = @_;
+
+  # Run config.status with any unhandled files.
+  #
+  if (@unhandled) {
+    $ENV{CONFIG_FILES}= join ' ', @unhandled;
+    system "./config.status";
+  }
+}
diff -r 17e9560465b0 js/src/build/autoconf/match-dir.sh
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/build/autoconf/match-dir.sh	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,101 @@
+#!/bin/sh
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+# Netscape Communications Corporation.
+# Portions created by the Initial Developer are Copyright (C) 1998
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+#
+# This script will match a dir with a set of dirs.
+#
+# Usage: match-dir.sh match [dir1 dir2 ... dirn]
+#
+# Send comments, improvements, bugs to ramiro@netscape.com
+# 
+
+if [ -f Makefile ]; then
+	MAKEFILE="Makefile"
+else
+	if [ -f Makefile.in ]; then
+		MAKEFILE="Makefile.in"
+	else
+		echo
+		echo "There ain't no 'Makefile' or 'Makefile.in' over here: $pwd, dude."
+		echo
+		exit 1
+	fi
+fi
+
+# Use DEPTH in the Makefile.in to determine the depth
+depth=`grep -w DEPTH ${MAKEFILE}  | grep "\.\." | awk -F"=" '{ print $2; }'`
+cwd=`pwd`
+
+# Determine the depth count
+n=`echo $depth | tr '/' ' ' | wc -w`
+
+cd $depth
+objdir=`pwd`
+
+path=`echo $cwd | sed "s|^${objdir}/||"`
+
+match=$path
+
+for i in $*
+do
+#	echo "Looking for $match in $i"
+
+	echo $i | grep -q -x $match
+
+	if [ $? -eq 0 ]
+	then
+		echo "1"
+
+		exit 0
+	fi
+
+#	echo "Looking for $i in $match"
+
+	echo $match | grep -q $i
+
+	if [ $? -eq 0 ]
+	then
+		echo "1"
+
+		exit 0
+	fi
+done
+
+echo "0"
+
+exit 0
diff -r 17e9560465b0 js/src/build/autoconf/nspr.m4
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/build/autoconf/nspr.m4	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,82 @@
+# -*- tab-width: 4; -*-
+# Configure paths for NSPR
+# Public domain - Chris Seawood <cls@seawood.org> 2001-04-05
+# Based upon gtk.m4 (also PD) by Owen Taylor
+
+dnl AM_PATH_NSPR([MINIMUM-VERSION, [ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND]]])
+dnl Test for NSPR, and define NSPR_CFLAGS and NSPR_LIBS
+AC_DEFUN([AM_PATH_NSPR],
+[dnl
+
+AC_ARG_WITH(nspr-prefix,
+	[  --with-nspr-prefix=PFX  Prefix where NSPR is installed],
+	nspr_config_prefix="$withval",
+	nspr_config_prefix="")
+
+AC_ARG_WITH(nspr-exec-prefix,
+	[  --with-nspr-exec-prefix=PFX
+                          Exec prefix where NSPR is installed],
+	nspr_config_exec_prefix="$withval",
+	nspr_config_exec_prefix="")
+
+	if test -n "$nspr_config_exec_prefix"; then
+		nspr_config_args="$nspr_config_args --exec-prefix=$nspr_config_exec_prefix"
+		if test -z "$NSPR_CONFIG"; then
+			NSPR_CONFIG=$nspr_config_exec_prefix/bin/nspr-config
+		fi
+	fi
+	if test -n "$nspr_config_prefix"; then
+		nspr_config_args="$nspr_config_args --prefix=$nspr_config_prefix"
+		if test -z "$NSPR_CONFIG"; then
+			NSPR_CONFIG=$nspr_config_prefix/bin/nspr-config
+		fi
+	fi
+
+	unset ac_cv_path_NSPR_CONFIG
+	AC_PATH_PROG(NSPR_CONFIG, nspr-config, no)
+	min_nspr_version=ifelse([$1], ,4.0.0,$1)
+	AC_MSG_CHECKING(for NSPR - version >= $min_nspr_version)
+
+	no_nspr=""
+	if test "$NSPR_CONFIG" = "no"; then
+		no_nspr="yes"
+	else
+		NSPR_CFLAGS=`$NSPR_CONFIG $nspr_config_args --cflags`
+		NSPR_LIBS=`$NSPR_CONFIG $nspr_config_args --libs`
+
+		nspr_config_major_version=`$NSPR_CONFIG $nspr_config_args --version | \
+			sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\1/'`
+		nspr_config_minor_version=`$NSPR_CONFIG $nspr_config_args --version | \
+			sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\2/'`
+		nspr_config_micro_version=`$NSPR_CONFIG $nspr_config_args --version | \
+			sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\3/'`
+		min_nspr_major_version=`echo $min_nspr_version | \
+			sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\1/'`
+		min_nspr_minor_version=`echo $min_nspr_version | \
+			sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\2/'`
+		min_nspr_micro_version=`echo $min_nspr_version | \
+			sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\3/'`
+		if test "$nspr_config_major_version" -ne "$min_nspr_major_version"; then
+			no_nspr="yes"
+		elif test "$nspr_config_major_version" -eq "$min_nspr_major_version" &&
+		     test "$nspr_config_minor_version" -lt "$min_nspr_minor_version"; then
+			no_nspr="yes"
+		elif test "$nspr_config_major_version" -eq "$min_nspr_major_version" &&
+		     test "$nspr_config_minor_version" -eq "$min_nspr_minor_version" &&
+		     test "$nspr_config_micro_version" -lt "$min_nspr_micro_version"; then
+			no_nspr="yes"
+		fi
+	fi
+
+	if test -z "$no_nspr"; then
+		AC_MSG_RESULT(yes)
+		ifelse([$2], , :, [$2])     
+	else
+		AC_MSG_RESULT(no)
+	fi
+
+
+	AC_SUBST(NSPR_CFLAGS)
+	AC_SUBST(NSPR_LIBS)
+
+])
diff -r 17e9560465b0 js/src/build/autoconf/pkg.m4
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/build/autoconf/pkg.m4	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,59 @@
+# PKG_CHECK_MODULES(GSTUFF, gtk+-2.0 >= 1.3 glib = 1.3.4, action-if, action-not)
+# defines GSTUFF_LIBS, GSTUFF_CFLAGS, see pkg-config man page
+# also defines GSTUFF_PKG_ERRORS on error
+AC_DEFUN([PKG_CHECK_MODULES],
+[succeeded=no
+
+  if test -z "$PKG_CONFIG"; then
+    AC_PATH_PROG(PKG_CONFIG, pkg-config, no)
+  fi
+
+  if test "$PKG_CONFIG" = "no" ; then
+     echo "*** The pkg-config script could not be found. Make sure it is"
+     echo "*** in your path, or set the PKG_CONFIG environment variable"
+     echo "*** to the full path to pkg-config."
+     echo "*** Or see http://www.freedesktop.org/software/pkgconfig to get pkg-config."
+  else
+     PKG_CONFIG_MIN_VERSION=0.9.0
+     if $PKG_CONFIG --atleast-pkgconfig-version $PKG_CONFIG_MIN_VERSION; then
+        AC_MSG_CHECKING(for $2)
+
+        if $PKG_CONFIG --exists "$2" ; then
+            AC_MSG_RESULT(yes)
+            succeeded=yes
+
+            AC_MSG_CHECKING($1_CFLAGS)
+            $1_CFLAGS=`$PKG_CONFIG --cflags "$2"`
+            AC_MSG_RESULT($$1_CFLAGS)
+
+            AC_MSG_CHECKING($1_LIBS)
+            ## Remove evil flags like -Wl,--export-dynamic
+            $1_LIBS="`$PKG_CONFIG --libs \"$2\" |sed s/-Wl,--export-dynamic//g`"
+            AC_MSG_RESULT($$1_LIBS)
+        else
+            $1_CFLAGS=""
+            $1_LIBS=""
+            ## If we have a custom action on failure, don't print errors, but 
+            ## do set a variable so people can do so.
+            $1_PKG_ERRORS=`$PKG_CONFIG --errors-to-stdout --print-errors "$2"`
+            ifelse([$4], ,echo $$1_PKG_ERRORS,)
+        fi
+
+        AC_SUBST($1_CFLAGS)
+        AC_SUBST($1_LIBS)
+     else
+        echo "*** Your version of pkg-config is too old. You need version $PKG_CONFIG_MIN_VERSION or newer."
+        echo "*** See http://www.freedesktop.org/software/pkgconfig"
+     fi
+  fi
+
+  if test $succeeded = yes; then
+     ifelse([$3], , :, [$3])
+  else
+     if test "$COMPILE_ENVIRONMENT"; then 
+       ifelse([$4], , AC_MSG_ERROR([Library requirements ($2) not met; consider adjusting the PKG_CONFIG_PATH environment variable if your libraries are in a nonstandard prefix so pkg-config can find them.]), [$4])
+     fi
+  fi
+])
+
+
diff -r 17e9560465b0 js/src/build/autoconf/update-makefile.sh
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/build/autoconf/update-makefile.sh	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,118 @@
+#!/bin/sh
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+# Netscape Communications Corporation.
+# Portions created by the Initial Developer are Copyright (C) 1998
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+#
+# This script will generate a single Makefile from a Makefile.in using
+# the config.status script.
+#
+# The config.status script is generated the first time you run 
+# ./configure.
+#
+#
+# Usage: update-makefile.sh
+#
+# Send comments, improvements, bugs to ramiro@netscape.com
+# 
+
+update_makefile_usage() {
+  _progname=`expr //$0 : '.*/\(.*\)'`
+  cat <<END_USAGE 2>&1
+
+Usage: $_progname [-h -u] [<keyword>]
+     -d <dir>     Subdir to update
+     -h           Print usage
+END_USAGE
+}
+
+# Parse the command-line options
+#
+subdir=
+while getopts d:h OPT; do
+    case $OPT in
+       d) # Make sure "subdir" has exactly one ending slash
+          subdir=`echo $OPTARG | sed 's/\/$//;'`"/" ;;
+    \?|h) update_makefile_usage
+          exit 1
+          ;;
+    esac
+done
+
+
+# find_depth: Pull the value of DEPTH out of Makefile (or Makefile.in)
+find_depth() {
+  egrep '^DEPTH[ 	]*=[ 	]*\.' $1 | awk -F= '{ print $2; }'
+}
+
+# The Makefile to create
+target_makefile=`pwd`"/${subdir}Makefile"
+
+# Use $(DEPTH) in the Makefile or Makefile.in to determine the depth
+if [ -f Makefile.in ]
+then
+    depth=`find_depth Makefile.in`
+elif [ -f Makefile ]
+then
+    depth=`find_depth Makefile`
+elif [ -f ../Makefile ]
+then
+    depth="../"`find_depth Makefile`
+else
+    echo
+    echo "There ain't no 'Makefile' or 'Makefile.in' over here: $pwd"
+    echo
+    exit
+fi
+
+# 'cd' to the root of the tree to run "config.status" there
+cd $depth
+
+# Strip the tree root off the Makefile's path
+#
+root_path=`pwd`
+target_makefile=`expr $target_makefile : $root_path'/\(.*\)'`
+
+# Make sure config.status exists
+#
+if [ -f config.status ]
+then
+    CONFIG_FILES=$target_makefile ./config.status
+else
+    echo
+    echo "There ain't no 'config.status' over here: $pwd"
+    echo
+fi
diff -r 17e9560465b0 js/src/build/cygwin-wrapper
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/build/cygwin-wrapper	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,75 @@
+#!/bin/sh
+#
+# Stupid wrapper to avoid win32 dospath/cygdrive issues
+# Try not to spawn programs from within this file. If the stuff in here looks royally 
+# confusing, see bug: http://bugzilla.mozilla.org/show_bug.cgi?id=206643
+# and look at the older versions of this file that are easier to read, but
+# do basically the same thing
+#
+
+prog=$1
+shift
+if test -z "$prog"; then
+    exit 0
+fi
+
+# If $CYGDRIVE_MOUNT was not set in configure, give $mountpoint the results of mount -p
+mountpoint=$CYGDRIVE_MOUNT
+if test -z "$mountpoint"; then
+    mountpoint=`mount -p`
+    if test -z "$mountpoint"; then
+       print "Cannot determine cygwin mount points. Exiting"
+       exit 1
+    fi
+fi
+
+# Delete everything but "/cygdrive" (or other mountpoint) from mount=`mount -p`
+mountpoint=${mountpoint#*/}
+mountpoint=/${mountpoint%%[!A-Za-z0-9_]*}
+mountpoint=${mountpoint%/}
+
+args=""
+up=""
+if test "${prog}" = "-up"; then
+    up=1
+    prog=${1}
+    shift
+fi
+
+process=1
+
+# Convert the mountpoint in parameters to Win32 filenames
+# For instance: /cygdrive/c/foo -> c:/foo
+for i in "${@}"
+do
+    if test "${i}" = "-wrap"; then
+        process=1
+    else
+        if test "${i}" = "-nowrap"; then
+            process=
+        else
+            if test -n "${process}"; then
+                if test -n "${up}"; then
+                    pathname=${i#-I[a-zA-Z]:/}
+                    if ! test "${pathname}" = "${i}"; then
+                        no_i=${i#-I}
+                        driveletter=${no_i%%:*}
+                        i=-I${mountpoint}/${driveletter}/${pathname}
+                    fi
+                else
+                    eval 'leader=${i%%'${mountpoint}'/[a-zA-Z]/*}'
+                    if ! test "${leader}" = "${i}"; then
+                        eval 'pathname=${i#'${leader}${mountpoint}'/[a-zA-Z]/}'
+                        eval 'no_mountpoint=${i#'${leader}${mountpoint}'/}'
+                        driveletter=${no_mountpoint%%/*}
+                        i=${leader}${driveletter}:/${pathname}
+                    fi
+                fi
+            fi
+
+            args="${args} ${i}"
+        fi
+    fi
+done
+
+exec $prog $args
diff -r 17e9560465b0 js/src/build/hcc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/build/hcc	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,111 @@
+#!/bin/sh
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+# Netscape Communications Corporation.
+# Portions created by the Initial Developer are Copyright (C) 1998
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+#
+# Fix brain-damaged compilers that don't understand -o and -c together
+#
+CC=`echo $1 | sed -e "s|'||g" -e 's|"||g'`
+shift
+DASH_C=0
+DASH_O=0
+DUMMY="XxxXxxX"
+GET_OBJECT=0
+OBJ="${DUMMY}"
+OBJECT="${DUMMY}"
+
+for i in $*
+do
+	[ "${CHECK_O}" = yes ]  && {
+	case $i in
+		./*/*.o)	OBJECT="$i"
+			OPTS="${OPTS} -o"
+   			DASH_O=1
+			;;
+		./*.o)	OBJECT="`basename $i`"
+			i=""
+   			DASH_O=1
+			;;
+		*.o)	if [ $i = `basename $i` ]
+			then
+				OBJECT="$i"
+				i=""
+			else
+				OPTS="${OPTS} -o"
+			fi
+   			DASH_O=1
+			;;
+		*)	OPTS="${OPTS} -o $i"
+   			DASH_O=1
+			i=""
+			;;
+	esac
+	CHECK_O=no
+	}
+   case $i in
+   -c)     DASH_C=1
+	OPTS="${OPTS} -c"
+		;;
+   -o)     CHECK_O=yes
+		;;
+   *.c)    C_SRC=$i
+	OPTS="${OPTS} $i"
+# cc always creates the .o from the .c name
+	OBJ=`basename $C_SRC .c`.o
+		;;
+   *.s)    S_SRC=$i
+	OPTS="${OPTS} $i"
+# or the .o from the .s name
+	OBJ=`basename $S_SRC .s`.o
+		;;
+   *.o)    OBJECT=$i
+	OPTS="${OPTS} $i"
+		;;
+   *) 	OPTS="${OPTS} $i"
+		;;
+   esac
+done
+
+${CC} ${OPTS} || exit $?
+
+# if there was no -c and -o we're done
+[ $DASH_C = 1 -a $DASH_O = 1 ] || exit 0
+
+# if $OBJ and $OBJECT are the same we're done
+[ $OBJ = $OBJECT ] && exit 0
+
+[ -f $OBJ ] && mv -f $OBJ $OBJECT
diff -r 17e9560465b0 js/src/build/hcpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/build/hcpp	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,155 @@
+#!/bin/sh
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+# Netscape Communications Corporation.
+# Portions created by the Initial Developer are Copyright (C) 1998
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+#
+# Wrapper for brain-damaged compilers that don't understand -o and -c together.
+#
+CXX=`echo $1 | sed -e "s|'||g" -e 's|"||g'`
+shift
+DUMMY="XxxXxxX"
+DASH_C=0
+DASH_O=0
+GET_OBJECT=0
+C_SRC="${DUMMY}"
+CC_SRC="${DUMMY}"
+CPP_SRC="${DUMMY}"
+S_SRC="${DUMMY}"
+OBJECT="${DUMMY}"
+NEW_i="${DUMMY}"
+PLATFORM=`uname -s`
+
+for i in $*
+do
+	[ ${GET_OBJECT} -eq 1 ]  && {
+	case $i in
+		./*/*.o)	OBJECT="$i"
+			OPTS="${OPTS} -o"
+   			DASH_O=1
+			;;
+		./*.o)	OBJECT="`basename $i`"
+			i=""
+   			DASH_O=1
+			;;
+		*.o)	if [ $i = `basename $i` ]
+			then
+				i=""
+			else
+				OPTS="${OPTS} -o"
+   				DASH_O=1
+			fi
+			;;
+		*)	OPTS="${OPTS} -o $i"
+   			DASH_O=1
+			i=""
+			;;
+	esac
+	GET_OBJECT=0
+	}
+	case $i in
+		-c)
+			DASH_C=1
+			OPTS="${OPTS} -c"
+			;;
+		-o)
+			GET_OBJECT=1
+			;;
+		*.c)
+			C_SRC="$i"
+			OPTS="${OPTS} $i"
+# cc always creates the .o from the .c name
+			OBJ=`basename ${C_SRC} .c`.o
+			;;
+		+.*)
+			OPTS="${OPTS} $i"
+			;;
+		*.cpp)
+			CPP_SRC="$i"
+			if [ "${PLATFORM}" = "SCO_SV" ]; then
+				OPTS="${OPTS} +.cpp $i"
+			elif [ "${PLATFORM}" = "IRIX" ]; then
+				NEW_i=`basename ${CPP_SRC} .cpp`.C
+				rm -f ${NEW_i}
+				cp $i ${NEW_i}
+				OPTS="${OPTS} ${NEW_i}"
+			else
+				OPTS="${OPTS} $i"
+			fi
+# cc always creates the .o from the .cpp name
+			OBJ=`basename ${CPP_SRC} .cpp`.o
+			;;
+		*.cc)
+			CC_SRC="$i"
+			OPTS="${OPTS} $i"
+# cc always creates the .o from the .cc name
+			OBJ=`basename ${CC_SRC} .cc`.o
+			;;
+		*.s)
+			S_SRC="$i"
+			OPTS="${OPTS} $i"
+# cc always creates the .o from the .s name
+			OBJ=`basename ${S_SRC} .s`.o
+			;;
+   		*.o)    OBJECT=$i
+			OPTS="${OPTS} $i"
+			;;
+   		*) 	OPTS="${OPTS} $i"
+			;;
+	esac
+done
+
+${CXX} ${OPTS} || exit $?
+rm -f ${NEW_i}
+
+# Really only needed for NSPR now.
+if [ "${PLATFORM}" = "IRIX" -a "$OBJ" != "$OBJECT" ]; then
+	OBJ=$OBJECT
+fi
+
+# LAME!!!
+if [ -f -O ]; then
+	mv -f -- -O ${OBJECT}
+fi
+
+# if there was no -c and -o we're done
+[ ${DASH_C} -eq 1 -a ${DASH_O} -eq 1 ] || exit 0
+
+# if $OBJ and $OBJECT are the same we're done
+[ $OBJ = $OBJECT ] && exit 0
+
+[ -f $OBJ ] && mv -f $OBJ $OBJECT
+
diff -r 17e9560465b0 js/src/build/unix/mddepend.pl
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/build/unix/mddepend.pl	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,165 @@
+#!/usr/bin/env perl
+
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is this file as it was released upon March 8, 1999.
+#
+# The Initial Developer of the Original Code is
+# Netscape Communications Corporation.
+# Portions created by the Initial Developer are Copyright (C) 1999
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+# mddepend.pl - Reads in dependencies generated my -MD flag. Prints list
+#   of objects that need to be rebuilt. These can then be added to the
+#   PHONY target. Using this script copes with the problem of header
+#   files that have been removed from the build.
+#    
+# Usage:
+#   mddepend.pl <output_file> <dependency_files...>
+#
+# Send comments, improvements, bugs to Steve Lamm (slamm@netscape.com).
+
+use strict;
+
+use constant DEBUG => 0;
+
+my $outfile = shift @ARGV;
+my $silent = $ENV{MAKEFLAGS} =~ /^\w*s|\s-s/;
+
+my $line = '';
+my %alldeps;
+# Parse dependency files
+while (<>) {
+  s/\r?\n$//; # Handle both unix and DOS line endings
+  $line .= $_;
+  if ($line =~ /\\$/) {
+    chop $line;
+    next;
+  }
+
+  my ($obj,$rest) = split /\s*:\s+/, $line, 2;
+  $line = '';
+  next if !$obj || !$rest;
+
+  my @deps = split /\s+/, $rest;
+  push @{$alldeps{$obj}}, @deps;
+  if (DEBUG >= 2) {
+    foreach my $dep (@deps) { print "add $obj $dep\n"; }
+  }
+}
+
+# Test dependencies
+my %modtimes; # cache
+my @objs;     # force rebuild on these
+OBJ_LOOP: foreach my $obj (keys %alldeps) {
+  my $mtime = (stat $obj)[9] or next;
+
+  my %not_in_cache;
+  my $deps = $alldeps{$obj};
+  foreach my $dep_file (@{$deps}) {
+    my $dep_mtime = $modtimes{$dep_file};
+    if (not defined $dep_mtime) {
+      print "Skipping $dep_file for $obj, will stat() later\n" if DEBUG >= 2;
+      $not_in_cache{$dep_file} = 1;
+      next;
+    }
+
+    print "Found $dep_file in cache\n" if DEBUG >= 2;
+
+    if ($dep_mtime > $mtime) {
+      print "$dep_file($dep_mtime) newer than $obj($mtime)\n" if DEBUG;
+    }
+    elsif ($dep_mtime == -1) {
+      print "Couldn't stat $dep_file for $obj\n" if DEBUG;
+    }
+    else {
+      print "$dep_file($dep_mtime) older than $obj($mtime)\n" if DEBUG >= 2;
+      next;
+    }
+
+    push @objs, $obj; # dependency is missing or newer
+    next OBJ_LOOP; # skip checking the rest of the dependencies
+  }
+
+  foreach my $dep_file (keys %not_in_cache) {
+    print "STAT $dep_file for $obj\n" if DEBUG >= 2;
+    my $dep_mtime = $modtimes{$dep_file} = (stat $dep_file)[9] || -1;
+
+    if ($dep_mtime > $mtime) {
+      print "$dep_file($dep_mtime) newer than $obj($mtime)\n" if DEBUG;
+    }
+    elsif ($dep_mtime == -1) {
+      print "Couldn't stat $dep_file for $obj\n" if DEBUG;
+    }
+    else {
+      print "$dep_file($dep_mtime) older than $obj($mtime)\n" if DEBUG >= 2;
+      next;
+    }
+
+    push @objs, $obj; # dependency is missing or newer
+    next OBJ_LOOP; # skip checking the rest of the dependencies
+  }
+
+  # If we get here it means nothing needs to be done for $obj
+}
+
+# Output objects to rebuild (if needed).
+if (@objs) {
+  my $old_output;
+  my $new_output = "@objs: FORCE\n";
+
+  # Read in the current dependencies file.
+  open(OLD, "<$outfile")
+    and $old_output = <OLD>;
+  close(OLD);
+
+  # Only write out the dependencies if they are different.
+  if ($new_output ne $old_output) {
+    open(OUT, ">$outfile") and print OUT "$new_output";
+    print "Updating dependencies file, $outfile\n" unless $silent;
+    if (DEBUG) {
+      print "new: $new_output\n";
+      print "was: $old_output\n" if $old_output ne '';
+    }
+  }
+} elsif (-s $outfile) {
+  # Remove the old dependencies because all objects are up to date.
+  print "Removing old dependencies file, $outfile\n" unless $silent;
+
+  if (DEBUG) {
+    my $old_output;
+    open(OLD, "<$outfile")
+      and $old_output = <OLD>;
+    close(OLD);
+    print "was: $old_output\n";
+  }
+
+  unlink $outfile;
+}
diff -r 17e9560465b0 js/src/build/unix/uniq.pl
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/build/unix/uniq.pl	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,63 @@
+#!/usr/bin/env perl
+
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is this file as it was released upon December 26, 2000.
+#
+# The Initial Developer of the Original Code is
+# Netscape Communications Corporation.
+# Portions created by the Initial Developer are Copyright (C) 2000
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Christopher Seawood <cls@seawood.org>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+use Getopt::Std;
+
+getopts('rs');
+$regexp = 1 if (defined($opt_r));
+$sort = 1 if (defined($opt_s));
+
+undef @out;
+if ($sort) {
+    @in = sort @ARGV;
+} else {
+    @in = @ARGV;
+}
+foreach $d (@in) { 
+    if ($regexp) {
+        $found = 0; 
+        foreach $dir (@out) {
+            $found++, last if ($d =~ m/^$dir\// || $d eq $dir);
+        }
+        push @out, $d if (!$found);
+    } else {
+        push @out, $d if (!grep(/^$d$/, @out));
+    }
+}
+print "@out\n"
diff -r 17e9560465b0 js/src/build/win32/pgomerge.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/build/win32/pgomerge.py	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,40 @@
+#!/usr/bin/python
+# Usage: pgomerge.py <binary basename> <dist/bin>
+# Gathers .pgc files from dist/bin and merges them into
+# $PWD/$basename.pgd using pgomgr, then deletes them.
+# No errors if any of these files don't exist.
+
+import sys, os, os.path, subprocess
+if not sys.platform == "win32":
+    raise Exception("This script was only meant for Windows.")
+
+def MergePGOFiles(basename, pgddir, pgcdir):
+  """Merge pgc files produced from an instrumented binary
+     into the pgd file for the second pass of profile-guided optimization
+     with MSVC.  |basename| is the name of the DLL or EXE without the
+     extension.  |pgddir| is the path that contains <basename>.pgd
+     (should be the objdir it was built in).  |pgcdir| is the path
+     containing basename!N.pgc files, which is probably dist/bin.
+     Calls pgomgr to merge each pgc file into the pgd, then deletes
+     the pgc files."""
+  if not os.path.isdir(pgddir) or not os.path.isdir(pgcdir):
+    return
+  pgdfile = os.path.abspath(os.path.join(pgddir, basename + ".pgd"))
+  if not os.path.isfile(pgdfile):
+    return
+  for file in os.listdir(pgcdir):
+    if file.startswith(basename) and file.endswith(".pgc"):
+      try:
+        pgcfile = os.path.normpath(os.path.join(pgcdir, file))
+        subprocess.call(['pgomgr', '-merge',
+                         pgcfile,
+                         pgdfile])
+        os.remove(pgcfile)
+      except OSError:
+        pass
+
+if __name__ == '__main__':
+  if len(sys.argv) != 3:
+      print >>sys.stderr, "Usage: pgomerge.py <binary basename> <dist/bin>"
+      sys.exit(1)
+  MergePGOFiles(sys.argv[1], os.getcwd(), sys.argv[2])
diff -r 17e9560465b0 js/src/builtins.tbl
--- a/js/src/builtins.tbl	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/builtins.tbl	Thu Oct 30 05:41:45 2008 -0400
@@ -43,6 +43,9 @@
  *
  * The macro arguments are:
  *
+ * - 'extern' to indicate extern linkage for these functions and the associated
+ *   CallInfo.
+ *
  * - The return type. This identifier must name one of the _JS_TYPEINFO_*
  *   macros defined in jsbuiltins.h.
  *
@@ -63,31 +66,31 @@
  * Do not use bool FASTCALL, use JSBool only!
  */
 
-BUILTIN2(JSVAL,     BoxDouble, CONTEXT, DOUBLE,                                 1, 1)
-BUILTIN2(JSVAL,     BoxInt32, CONTEXT, INT32,                                   1, 1)
-BUILTIN1(DOUBLE,    UnboxDouble, JSVAL,                                         1, 1)
-BUILTIN1(INT32,     UnboxInt32, JSVAL,                                          1, 1)
-BUILTIN2(DOUBLE,    dmod, DOUBLE, DOUBLE,                                       1, 1)
-BUILTIN2(INT32,     imod, INT32, INT32,                                         1, 1)
-BUILTIN1(INT32,     DoubleToInt32, DOUBLE,                                      1, 1)
-BUILTIN1(UINT32,    DoubleToUint32, DOUBLE,                                     1, 1)
+BUILTIN2(extern, JSVAL,     js_BoxDouble, CONTEXT, DOUBLE,                      1, 1)
+BUILTIN2(extern, JSVAL,     js_BoxInt32, CONTEXT, INT32,                        1, 1)
+BUILTIN1(extern, DOUBLE,    js_UnboxDouble, JSVAL,                              1, 1)
+BUILTIN1(extern, INT32,     js_UnboxInt32, JSVAL,                               1, 1)
+BUILTIN2(extern, DOUBLE,    js_dmod, DOUBLE, DOUBLE,                            1, 1)
+BUILTIN2(extern, INT32,     js_imod, INT32, INT32,                              1, 1)
+BUILTIN1(extern, INT32,     js_DoubleToInt32, DOUBLE,                           1, 1)
+BUILTIN1(extern, UINT32,    js_DoubleToUint32, DOUBLE,                          1, 1)
 
-BUILTIN2(DOUBLE,    StringToNumber, CONTEXT, STRING,                            1, 1)
-BUILTIN2(INT32,     StringToInt32, CONTEXT, STRING,                             1, 1)
-BUILTIN3(JSVAL,     Any_getprop, CONTEXT, OBJECT, STRING,                       0, 0)
-BUILTIN4(BOOL,      Any_setprop, CONTEXT, OBJECT, STRING, JSVAL,                0, 0)
-BUILTIN3(JSVAL,     Any_getelem, CONTEXT, OBJECT, UINT32,                       0, 0)
-BUILTIN4(BOOL,      Any_setelem, CONTEXT, OBJECT, UINT32, JSVAL,                0, 0)
-BUILTIN3(OBJECT,    FastValueToIterator, CONTEXT, UINT32, JSVAL,                0, 0)
-BUILTIN2(JSVAL,     FastCallIteratorNext, CONTEXT, OBJECT,                      0, 0)
-BUILTIN2(BOOL,      CloseIterator, CONTEXT, JSVAL,                              0, 0)
-BUILTIN2(GUARDRECORD, CallTree, INTERPSTATE, FRAGMENT,                          0, 0)
-BUILTIN2(OBJECT,    FastNewObject, CONTEXT, OBJECT,                             0, 0)
-BUILTIN3(BOOL,      AddProperty, CONTEXT, OBJECT, SCOPEPROP,                    0, 0)
-BUILTIN3(BOOL,      HasNamedProperty, CONTEXT, OBJECT, STRING,                  0, 0)
-BUILTIN3(JSVAL,     CallGetter, CONTEXT, OBJECT, SCOPEPROP,                     0, 0)
-BUILTIN2(STRING,    TypeOfObject, CONTEXT, OBJECT,                              1, 1)
-BUILTIN2(STRING,    TypeOfBoolean, CONTEXT, INT32,                              1, 1)
-BUILTIN2(DOUBLE,    BooleanToNumber, CONTEXT, INT32,                            1, 1)
-BUILTIN2(STRING,    ObjectToString, CONTEXT, OBJECT,                            0, 0)
-BUILTIN1(OBJECT,    Arguments, CONTEXT,                                         0, 0)
+BUILTIN2(extern, DOUBLE,    js_StringToNumber, CONTEXT, STRING,                 1, 1)
+BUILTIN2(extern, INT32,     js_StringToInt32, CONTEXT, STRING,                  1, 1)
+BUILTIN3(extern, JSVAL,     js_Any_getprop, CONTEXT, OBJECT, STRING,            0, 0)
+BUILTIN4(extern, BOOL,      js_Any_setprop, CONTEXT, OBJECT, STRING, JSVAL,     0, 0)
+BUILTIN3(extern, JSVAL,     js_Any_getelem, CONTEXT, OBJECT, INT32,             0, 0)
+BUILTIN4(extern, BOOL,      js_Any_setelem, CONTEXT, OBJECT, INT32, JSVAL,      0, 0)
+BUILTIN3(extern, OBJECT,    js_FastValueToIterator, CONTEXT, UINT32, JSVAL,     0, 0)
+BUILTIN2(extern, JSVAL,     js_FastCallIteratorNext, CONTEXT, OBJECT,           0, 0)
+BUILTIN2(FRIEND, BOOL,      js_CloseIterator, CONTEXT, JSVAL,                   0, 0)
+BUILTIN2(extern, SIDEEXIT,  js_CallTree, INTERPSTATE, FRAGMENT,                 0, 0)
+BUILTIN2(extern, OBJECT,    js_FastNewObject, CONTEXT, OBJECT,                  0, 0)
+BUILTIN3(extern, BOOL,      js_AddProperty, CONTEXT, OBJECT, SCOPEPROP,         0, 0)
+BUILTIN3(extern, BOOL,      js_HasNamedProperty, CONTEXT, OBJECT, STRING,       0, 0)
+BUILTIN3(extern, JSVAL,     js_CallGetter, CONTEXT, OBJECT, SCOPEPROP,          0, 0)
+BUILTIN2(extern, STRING,    js_TypeOfObject, CONTEXT, OBJECT,                   1, 1)
+BUILTIN2(extern, STRING,    js_TypeOfBoolean, CONTEXT, INT32,                   1, 1)
+BUILTIN2(extern, DOUBLE,    js_BooleanToNumber, CONTEXT, INT32,                 1, 1)
+BUILTIN2(extern, STRING,    js_ObjectToString, CONTEXT, OBJECT,                 0, 0)
+BUILTIN1(extern, OBJECT,    js_Arguments, CONTEXT,                              0, 0)
diff -r 17e9560465b0 js/src/config.mk
--- a/js/src/config.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,206 +0,0 @@
-# -*- Mode: makefile -*-
-# 
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-# 
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-# 
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998-1999
-# the Initial Developer. All Rights Reserved.
-# 
-# Contributor(s):
-# 
-# Alternatively, the contents of this file may be used under the terms of
-# either of the GNU General Public License Version 2 or later (the "GPL"),
-# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-# 
-# ***** END LICENSE BLOCK *****
-
-ifdef JS_DIST
-DIST = $(JS_DIST)
-else
-DIST = $(DEPTH)/../../dist
-endif
-
-# Set os+release dependent make variables
-OS_ARCH         := $(subst /,_,$(shell uname -s | sed /\ /s//_/))
-
-# Attempt to differentiate between SunOS 5.4 and x86 5.4
-OS_CPUARCH      := $(shell uname -m)
-ifeq ($(OS_CPUARCH),i86pc)
-OS_RELEASE      := $(shell uname -r)_$(OS_CPUARCH)
-else
-ifeq ($(OS_ARCH),AIX)
-OS_RELEASE      := $(shell uname -v).$(shell uname -r)
-else
-OS_RELEASE      := $(shell uname -r)
-endif
-endif
-ifeq ($(OS_ARCH),IRIX64)
-OS_ARCH         := IRIX
-endif
-
-# Handle output from win32 unames other than Netscape's version
-ifeq (,$(filter-out Windows_95 Windows_98 CYGWIN_95-4.0 CYGWIN_98-4.10, $(OS_ARCH)))
-	OS_ARCH   := WIN95
-endif
-ifeq ($(OS_ARCH),WIN95)
-	OS_ARCH	   := WINNT
-	OS_RELEASE := 4.0
-endif
-ifeq ($(OS_ARCH), Windows_NT)
-	OS_ARCH    := WINNT
-	OS_MINOR_RELEASE := $(shell uname -v)
-	ifeq ($(OS_MINOR_RELEASE),00)
-		OS_MINOR_RELEASE = 0
-	endif
-	OS_RELEASE := $(OS_RELEASE).$(OS_MINOR_RELEASE)
-endif
-ifeq (CYGWIN_NT,$(findstring CYGWIN_NT,$(OS_ARCH)))
-	OS_RELEASE := $(patsubst CYGWIN_NT-%,%,$(OS_ARCH))
-	OS_ARCH    := WINNT
-endif
-ifeq ($(OS_ARCH), CYGWIN32_NT)
-	OS_ARCH    := WINNT
-endif
-ifeq (MINGW32_NT,$(findstring MINGW32_NT,$(OS_ARCH)))
-	OS_RELEASE := $(patsubst MINGW32_NT-%,%,$(OS_ARCH))
-	OS_ARCH    := WINNT
-endif
-
-# Virtually all Linux versions are identical.
-# Any distinctions are handled in linux.h
-ifeq ($(OS_ARCH),Linux)
-OS_CONFIG      := Linux_All
-else
-ifeq ($(OS_ARCH),dgux)
-OS_CONFIG      := dgux
-else
-ifeq ($(OS_ARCH),Darwin)
-OS_CONFIG      := Darwin
-else
-ifeq ($(OS_ARCH),Darwin64)
-OS_CONFIG       := Darwin64
-else
-OS_CONFIG       := $(OS_ARCH)$(OS_OBJTYPE)$(OS_RELEASE)
-endif
-endif
-endif
-endif
-
-ASFLAGS         =
-DEFINES         =
-
-ifeq ($(OS_ARCH), WINNT)
-INSTALL = nsinstall
-CP = cp
-else
-INSTALL	= $(DIST)/bin/nsinstall
-CP = cp
-endif
-
-ifdef BUILD_OPT
-ifdef USE_MSVC
-OPTIMIZER  = -O2 -GL
-INTERP_OPTIMIZER = -O2 -GL
-BUILTINS_OPTIMIZER = -O2 -GL
-LDFLAGS    += -LTCG
-else
-OPTIMIZER  = -Os -fno-exceptions -fno-rtti -fstrict-aliasing -Wall -Wstrict-aliasing=2
-BUILTINS_OPTIMIZER = -O9 -fstrict-aliasing -fno-exceptions -fno-rtti
-INTERP_OPTIMIZER = -O3 -fstrict-aliasing -fno-exceptions -fno-rtti
-endif
-DEFINES    += -UDEBUG -DNDEBUG -UDEBUG_$(USER)
-OBJDIR_TAG = _OPT
-else
-ifdef USE_MSVC
-OPTIMIZER  = -Zi
-INTERP_OPTIMIZER = -Zi
-BUILTINS_OPTIMIZER = $(INTERP_OPTIMIZER)
-else
-OPTIMIZER  = -g3 -fno-exceptions -fno-rtti -Wall -fstrict-aliasing -Wstrict-aliasing=2
-INTERP_OPTIMIZER = -g3 -fno-exceptions -fno-rtti -Wall -fstrict-aliasing
-BUILTINS_OPTIMIZER = $(INTERP_OPTIMIZER)
-endif
-DEFINES    += -DDEBUG -DDEBUG_$(USER)
-OBJDIR_TAG = _DBG
-endif
-
-SO_SUFFIX = so
-
-NS_USE_NATIVE = 1
-
-# Java stuff
-CLASSDIR     = $(DEPTH)/liveconnect/classes
-JAVA_CLASSES = $(patsubst %.java,%.class,$(JAVA_SRCS))
-TARGETS     += $(addprefix $(CLASSDIR)/$(OBJDIR)/$(JARPATH)/, $(JAVA_CLASSES))
-JAVAC        = $(JDK)/bin/javac
-JAVAC_FLAGS  = -classpath "$(CLASSPATH)" -d $(CLASSDIR)/$(OBJDIR)
-ifeq ($(OS_ARCH), WINNT)
-  SEP        = ;
-else
-  SEP        = :
-endif
-CLASSPATH    = $(JDK)/lib/classes.zip$(SEP)$(CLASSDIR)/$(OBJDIR)
-
-include $(DEPTH)/config/$(OS_CONFIG).mk
-
-ifndef OBJ_SUFFIX
-ifdef USE_MSVC
-OBJ_SUFFIX = obj
-else
-OBJ_SUFFIX = o
-endif
-endif
-
-ifndef HOST_BIN_SUFFIX
-ifeq ($(OS_ARCH),WINNT)
-HOST_BIN_SUFFIX = .exe
-else
-HOST_BIN_SUFFIX =
-endif
-endif
-
-# Name of the binary code directories
-ifdef OBJROOT
-# prepend $(DEPTH) to the root unless it is an absolute path
-OBJDIR = $(if $(filter /%,$(OBJROOT)),$(OBJROOT),$(DEPTH)/$(OBJROOT))
-else
-ifeq ($(DEPTH),.)
-OBJDIR = $(OS_CONFIG)$(OBJDIR_TAG).$(if $(BUILD_IDG),OBJD,OBJ)
-else
-OBJDIR = $(DEPTH)/$(OS_CONFIG)$(OBJDIR_TAG).$(if $(BUILD_IDG),OBJD,OBJ)
-endif
-endif
-
-VPATH = $(OBJDIR)
-
-LCJAR = js15lc30.jar
-
-# Library name
-LIBDIR := lib
-ifeq ($(CPU_ARCH), x86_64)
-LIBDIR := lib64
-endif
-
diff -r 17e9560465b0 js/src/config/AIX4.1.mk
--- a/js/src/config/AIX4.1.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,65 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config stuff for AIX
-#
-
-CC = xlC_r
-CCC = xlC_r
-
-RANLIB = ranlib
-
-#.c.o:
-#	$(CC) -c -MD $*.d $(CFLAGS) $<
-ARCH := aix
-CPU_ARCH = rs6000
-GFX_ARCH = x
-INLINES = js_compare_and_swap:js_fast_lock1:js_fast_unlock1:js_lock_get_slot:js_lock_set_slot:js_lock_scope1
-
-OS_CFLAGS = -qarch=com -qinline+$(INLINES) -DXP_UNIX -DAIX -DAIXV3 -DSYSV -DHAVE_LOCALTIME_R
-OS_LIBS = -lbsd -lsvld -lm
-#-lpthreads -lc_r
-
-MKSHLIB = $(LD) -bM:SRE -bh:4 -bnoentry -berok
-XLDFLAGS += -lc
-
-ifdef JS_THREADSAFE
-XLDFLAGS += -lsvld
-endif
diff -r 17e9560465b0 js/src/config/AIX4.2.mk
--- a/js/src/config/AIX4.2.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,64 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config stuff for AIX
-#
-
-CC = xlC_r
-CCC = xlC_r
-CFLAGS += -qarch=com -qnoansialias -qinline+$(INLINES) -DXP_UNIX -DAIX -DAIXV3 -DSYSV -DHAVE_LOCALTIME_R
-
-RANLIB = ranlib
-
-#.c.o:
-#	$(CC) -c -MD $*.d $(CFLAGS) $<
-ARCH := aix
-CPU_ARCH = rs6000
-GFX_ARCH = x
-INLINES = js_compare_and_swap:js_fast_lock1:js_fast_unlock1:js_lock_get_slot:js_lock_set_slot:js_lock_scope1
-
-#-lpthreads -lc_r
-
-MKSHLIB = /usr/lpp/xlC/bin/makeC++SharedLib_r -p 0 -G -berok
-
-ifdef JS_THREADSAFE
-XLDFLAGS += -ldl
-endif
-
diff -r 17e9560465b0 js/src/config/AIX4.3.mk
--- a/js/src/config/AIX4.3.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,65 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config stuff for AIX
-#
-
-CC = xlC_r
-CCC = xlC_r
-CFLAGS += -qarch=com -qnoansialias -qinline+$(INLINES) -DXP_UNIX -DAIX -DAIXV3 -DSYSV -DAIX4_3 -DHAVE_LOCALTIME_R
-
-RANLIB = ranlib
-
-#.c.o:
-#	$(CC) -c -MD $*.d $(CFLAGS) $<
-ARCH := aix
-CPU_ARCH = rs6000
-GFX_ARCH = x
-INLINES = js_compare_and_swap:js_fast_lock1:js_fast_unlock1:js_lock_get_slot:js_lock_set_slot:js_lock_scope1
-
-#-lpthreads -lc_r
-
-MKSHLIB_BIN = /usr/ibmcxx/bin/makeC++SharedLib_r
-MKSHLIB = $(MKSHLIB_BIN) -p 0 -G -berok -bM:UR
-
-ifdef JS_THREADSAFE
-XLDFLAGS += -ldl
-endif
-
diff -r 17e9560465b0 js/src/config/Darwin.mk
--- a/js/src/config/Darwin.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,85 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#   Steve Zellers (zellers@apple.com)
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config for Mac OS X as of PR3
-# Just ripped from Linux config
-#
-
-CC = gcc
-CCC = g++
-CFLAGS +=  -Wall -Wno-format -MMD
-OS_CFLAGS = -DXP_UNIX -DSVR4 -DSYSV -D_BSD_SOURCE -DPOSIX_SOURCE -DDARWIN
-
-RANLIB = ranlib
-MKSHLIB = $(CCC) -dynamiclib $(XMKSHLIBOPTS) -framework System
-
-SO_SUFFIX = dylib
-
-#.c.o:
-#      $(CC) -c -MD $*.d $(CFLAGS) $<
-
-CPU_ARCH = $(shell uname -m)
-ifeq (86,$(findstring 86,$(CPU_ARCH)))
-CPU_ARCH = x86
-OS_CFLAGS+= -DX86_LINUX
-OS_CFLAGS += -DAVMPLUS_IA32 -DAVMPLUS_UNIX
-NANOJIT_ARCH = i386
-endif
-GFX_ARCH = x
-
-OS_LIBS = -lc -framework System
-
-ASFLAGS += -x assembler-with-cpp
-
-ifeq ($(CPU_ARCH),alpha)
-
-# Ask the C compiler on alpha linux to let us work with denormalized
-# double values, which are required by the ECMA spec.
-
-OS_CFLAGS += -mieee
-endif
-
-# Use the editline library to provide line-editing support.
-JS_EDITLINE = 1
-
-# Don't allow Makefile.ref to use libmath
-NO_LIBM = 1
-
diff -r 17e9560465b0 js/src/config/Darwin1.3.mk
--- a/js/src/config/Darwin1.3.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,81 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#   Steve Zellers (zellers@apple.com)
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config for Mac OS X as of PR3
-# Just ripped from Linux config
-#
-
-CC = cc
-CCC = g++
-CFLAGS +=  -Wall -Wno-format
-OS_CFLAGS = -DXP_UNIX -DSVR4 -DSYSV -D_BSD_SOURCE -DPOSIX_SOURCE -DRHAPSODY
-
-RANLIB = ranlib
-MKSHLIB = libtool $(XMKSHLIBOPTS) -framework System
-
-#.c.o:
-#      $(CC) -c -MD $*.d $(CFLAGS) $<
-
-CPU_ARCH = $(shell uname -m)
-ifeq (86,$(findstring 86,$(CPU_ARCH)))
-CPU_ARCH = x86
-OS_CFLAGS+= -DX86_LINUX
-endif
-GFX_ARCH = x
-
-OS_LIBS = -lc -framework System
-
-ASFLAGS += -x assembler-with-cpp
-
-ifeq ($(CPU_ARCH),alpha)
-
-# Ask the C compiler on alpha linux to let us work with denormalized
-# double values, which are required by the ECMA spec.
-
-OS_CFLAGS += -mieee
-endif
-
-# Use the editline library to provide line-editing support.
-JS_EDITLINE = 1
-
-# Don't allow Makefile.ref to use libmath
-NO_LIBM = 1
-
diff -r 17e9560465b0 js/src/config/Darwin1.4.mk
--- a/js/src/config/Darwin1.4.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,41 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#   Mike McCabe <mike+mozilla@meer.net>
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-include $(DEPTH)/config/Darwin1.3.mk
diff -r 17e9560465b0 js/src/config/Darwin5.2.mk
--- a/js/src/config/Darwin5.2.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,81 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#   Steve Zellers (zellers@apple.com)
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config for Mac OS X as of PR3
-# Just ripped from Linux config
-#
-
-CC = cc
-CCC = g++
-CFLAGS +=  -Wall -Wno-format
-OS_CFLAGS = -DXP_UNIX -DSVR4 -DSYSV -D_BSD_SOURCE -DPOSIX_SOURCE -DDARWIN
-
-RANLIB = ranlib
-MKSHLIB = libtool $(XMKSHLIBOPTS) -framework System
-
-#.c.o:
-#      $(CC) -c -MD $*.d $(CFLAGS) $<
-
-CPU_ARCH = $(shell uname -m)
-ifeq (86,$(findstring 86,$(CPU_ARCH)))
-CPU_ARCH = x86
-OS_CFLAGS+= -DX86_LINUX
-endif
-GFX_ARCH = x
-
-OS_LIBS = -lc -framework System
-
-ASFLAGS += -x assembler-with-cpp
-
-ifeq ($(CPU_ARCH),alpha)
-
-# Ask the C compiler on alpha linux to let us work with denormalized
-# double values, which are required by the ECMA spec.
-
-OS_CFLAGS += -mieee
-endif
-
-# Use the editline library to provide line-editing support.
-JS_EDITLINE = 1
-
-# Don't allow Makefile.ref to use libmath
-NO_LIBM = 1
-
diff -r 17e9560465b0 js/src/config/Darwin5.3.mk
--- a/js/src/config/Darwin5.3.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,81 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#   Steve Zellers (zellers@apple.com)
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config for Mac OS X as of PR3
-# Just ripped from Linux config
-#
-
-CC = cc
-CCC = g++
-CFLAGS +=  -Wall -Wno-format
-OS_CFLAGS = -DXP_UNIX -DSVR4 -DSYSV -D_BSD_SOURCE -DPOSIX_SOURCE -DDARWIN
-
-RANLIB = ranlib
-MKSHLIB = libtool $(XMKSHLIBOPTS) -framework System
-
-#.c.o:
-#      $(CC) -c -MD $*.d $(CFLAGS) $<
-
-CPU_ARCH = $(shell uname -m)
-ifeq (86,$(findstring 86,$(CPU_ARCH)))
-CPU_ARCH = x86
-OS_CFLAGS+= -DX86_LINUX
-endif
-GFX_ARCH = x
-
-OS_LIBS = -lc -framework System
-
-ASFLAGS += -x assembler-with-cpp
-
-ifeq ($(CPU_ARCH),alpha)
-
-# Ask the C compiler on alpha linux to let us work with denormalized
-# double values, which are required by the ECMA spec.
-
-OS_CFLAGS += -mieee
-endif
-
-# Use the editline library to provide line-editing support.
-JS_EDITLINE = 1
-
-# Don't allow Makefile.ref to use libmath
-NO_LIBM = 1
-
diff -r 17e9560465b0 js/src/config/Darwin64.mk
--- a/js/src/config/Darwin64.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,72 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#   Steve Zellers (zellers@apple.com)
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config for Mac OS X as of PR3
-# Just ripped from Linux config
-#
-
-CC = cc
-CCC = g++
-CFLAGS +=  -Wall -Wno-format -MMD
-OS_LDFLAGS += -m64
-OS_CFLAGS = -m64 -DXP_UNIX -DSVR4 -DSYSV -D_BSD_SOURCE -DPOSIX_SOURCE -DDARWIN 
-
-RANLIB = ranlib
-MKSHLIB = $(CCC) -dynamiclib $(XMKSHLIBOPTS) -framework System
-
-SO_SUFFIX = dylib
-
-#.c.o:
-#      $(CC) -c -MD $*.d $(CFLAGS) $<
-
-CPU_ARCH = x86_64
-GFX_ARCH = x
-
-OS_LIBS = -lc -framework System
-
-ASFLAGS += -x assembler-with-cpp
-
-# Use the editline library to provide line-editing support.
-JS_EDITLINE = 1
-
-# Don't allow Makefile.ref to use libmath
-NO_LIBM = 1
-
diff -r 17e9560465b0 js/src/config/HP-UXB.10.10.mk
--- a/js/src/config/HP-UXB.10.10.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,77 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config stuff for HPUX
-#
-
-# CC = gcc
-# CCC = g++
-# CFLAGS +=  -Wall -Wno-format -fPIC
-
-CC  = cc -Ae +Z
-CCC = CC -Ae +a1 +eh +Z
-
-RANLIB = echo
-MKSHLIB = $(LD) -b
-
-SO_SUFFIX = sl
-
-#.c.o:
-#	$(CC) -c -MD $*.d $(CFLAGS) $<
-
-CPU_ARCH = hppa
-GFX_ARCH = x
-
-OS_CFLAGS = -DXP_UNIX -DHPUX -DSYSV -DHAVE_LOCALTIME_R
-OS_LIBS = -ldld
-
-ifeq ($(OS_RELEASE),B.10)
-PLATFORM_FLAGS		+= -DHPUX10 -Dhpux10
-PORT_FLAGS		+= -DRW_NO_OVERLOAD_SCHAR -DHAVE_MODEL_H
-ifeq ($(OS_VERSION),.10)
-PLATFORM_FLAGS		+= -DHPUX10_10
-endif
-ifeq ($(OS_VERSION),.20)
-PLATFORM_FLAGS		+= -DHPUX10_20
-endif
-ifeq ($(OS_VERSION),.30)
-PLATFORM_FLAGS		+= -DHPUX10_30
-endif
-endif
diff -r 17e9560465b0 js/src/config/HP-UXB.10.20.mk
--- a/js/src/config/HP-UXB.10.20.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,77 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config stuff for HPUX
-#
-
-# CC = gcc
-# CCC = g++
-# CFLAGS +=  -Wall -Wno-format -fPIC
-
-CC  = cc -Ae +Z
-CCC = CC -Ae +a1 +eh +Z
-
-RANLIB = echo
-MKSHLIB = $(LD) -b
-
-SO_SUFFIX = sl
-
-#.c.o:
-#	$(CC) -c -MD $*.d $(CFLAGS) $<
-
-CPU_ARCH = hppa
-GFX_ARCH = x
-
-OS_CFLAGS = -DXP_UNIX -DHPUX -DSYSV -DHAVE_LOCALTIME_R
-OS_LIBS = -ldld
-
-ifeq ($(OS_RELEASE),B.10)
-PLATFORM_FLAGS		+= -DHPUX10 -Dhpux10
-PORT_FLAGS		+= -DRW_NO_OVERLOAD_SCHAR -DHAVE_MODEL_H
-ifeq ($(OS_VERSION),.10)
-PLATFORM_FLAGS		+= -DHPUX10_10
-endif
-ifeq ($(OS_VERSION),.20)
-PLATFORM_FLAGS		+= -DHPUX10_20
-endif
-ifeq ($(OS_VERSION),.30)
-PLATFORM_FLAGS		+= -DHPUX10_30
-endif
-endif
diff -r 17e9560465b0 js/src/config/HP-UXB.11.00.mk
--- a/js/src/config/HP-UXB.11.00.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,80 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config stuff for HPUX
-#
-
-ifdef NS_USE_NATIVE
-  CC  = cc +Z +DAportable +DS2.0 +u4
-#  LD  = aCC +Z -b -Wl,+s -Wl,-B,symbolic
-else
-  CC = gcc -Wall -Wno-format -fPIC
-  CCC = g++ -Wall -Wno-format -fPIC
-endif
-
-RANLIB = echo
-MKSHLIB = $(LD) -b
-
-SO_SUFFIX = sl
-
-#.c.o:
-#	$(CC) -c -MD $*.d $(CFLAGS) $<
-
-CPU_ARCH = hppa
-GFX_ARCH = x
-
-OS_CFLAGS = -DXP_UNIX -DHPUX -DSYSV -D_HPUX -DNATIVE -D_POSIX_C_SOURCE=199506L -DHAVE_LOCALTIME_R
-OS_LIBS = -ldld
-
-XLDFLAGS = -lpthread
-
-ifeq ($(OS_RELEASE),B.10)
-PLATFORM_FLAGS		+= -DHPUX10 -Dhpux10
-PORT_FLAGS		+= -DRW_NO_OVERLOAD_SCHAR -DHAVE_MODEL_H
-ifeq ($(OS_VERSION),.10)
-PLATFORM_FLAGS		+= -DHPUX10_10
-endif
-ifeq ($(OS_VERSION),.20)
-PLATFORM_FLAGS		+= -DHPUX10_20
-endif
-ifeq ($(OS_VERSION),.30)
-PLATFORM_FLAGS		+= -DHPUX10_30
-endif
-endif
diff -r 17e9560465b0 js/src/config/IRIX.mk
--- a/js/src/config/IRIX.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,87 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config stuff for IRIX
-#
-
-CPU_ARCH = mips
-GFX_ARCH = x
-
-RANLIB = /bin/true
-
-#NS_USE_GCC = 1
-
-ifndef NS_USE_NATIVE
-CC = gcc
-CCC = g++
-AS = $(CC) -x assembler-with-cpp
-ODD_CFLAGS = -Wall -Wno-format
-ifdef BUILD_OPT
-OPTIMIZER = -O6
-endif
-else
-ifeq ($(OS_RELEASE),6.2)
-CC	= cc -n32 -DIRIX6_2
-endif
-ifeq ($(OS_RELEASE),6.3)
-CC	= cc -n32 -DIRIX6_3
-endif
-ifeq ($(OS_RELEASE),6.5)
-CC	= cc -n32 -DIRIX6_5
-endif
-CCC = CC
-# LD  = CC
-ODD_CFLAGS = -fullwarn -xansi
-ifdef BUILD_OPT
-OPTIMIZER += -Olimit 4000
-endif
-endif
-
-# For purify
-HAVE_PURIFY = 1
-PURE_OS_CFLAGS = $(ODD_CFLAGS) -DXP_UNIX -DSVR4 -DSW_THREADS -DIRIX -DHAVE_LOCALTIME_R
-
-OS_CFLAGS = $(PURE_OS_CFLAGS) -MDupdate $(DEPENDENCIES)
-
-BSDECHO	= echo
-MKSHLIB = $(LD) -n32 -shared
-
-# Use the editline library to provide line-editing support.
-JS_EDITLINE = 1
diff -r 17e9560465b0 js/src/config/IRIX5.3.mk
--- a/js/src/config/IRIX5.3.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,44 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config stuff for IRIX5.3
-#
-
-include $(DEPTH)/config/IRIX.mk
diff -r 17e9560465b0 js/src/config/IRIX6.1.mk
--- a/js/src/config/IRIX6.1.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,44 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config stuff for IRIX6.3
-#
-
-include $(DEPTH)/config/IRIX.mk
diff -r 17e9560465b0 js/src/config/IRIX6.2.mk
--- a/js/src/config/IRIX6.2.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,44 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config stuff for IRIX6.3
-#
-
-include $(DEPTH)/config/IRIX.mk
diff -r 17e9560465b0 js/src/config/IRIX6.3.mk
--- a/js/src/config/IRIX6.3.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,44 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config stuff for IRIX6.3
-#
-
-include $(DEPTH)/config/IRIX.mk
diff -r 17e9560465b0 js/src/config/IRIX6.5.mk
--- a/js/src/config/IRIX6.5.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,44 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config stuff for IRIX6.3
-#
-
-include $(DEPTH)/config/IRIX.mk
diff -r 17e9560465b0 js/src/config/Linux_All.mk
--- a/js/src/config/Linux_All.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,104 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config for all versions of Linux
-#
-
-CC = gcc
-CCC = g++
-LD = g++
-CFLAGS +=  -Wall -Wno-format -MMD
-OS_CFLAGS = -DXP_UNIX -DSVR4 -DSYSV -D_BSD_SOURCE -DPOSIX_SOURCE -DHAVE_LOCALTIME_R -DLINUX
-
-RANLIB = echo
-MKSHLIB = $(LD) -shared $(XMKSHLIBOPTS)
-
-#.c.o:
-#      $(CC) -c -MD $*.d $(CFLAGS) $<
-
-CPU_ARCH = $(shell uname -m)
-# don't filter in x86-64 architecture
-ifneq (x86_64,$(CPU_ARCH))
-ifeq (86,$(findstring 86,$(CPU_ARCH)))
-CPU_ARCH = x86
-OS_CFLAGS += -DX86_LINUX -DAVMPLUS_IA32 -DAVMPLUS_UNIX -DAVMPLUS_LINUX
-NANOJIT_ARCH = i386
-endif # 86
-endif # !x86_64
-
-ifeq ($(CPU_ARCH),x86_64)
-OS_CFLAGS += -DAVMPLUS_AMD64 -DAVMPLUS_64BIT -DAVMPLUS_UNIX -DAVMPLUS_LINUX
-NANOJIT_ARCH = i386
-endif
-
-ifeq ($(CPU_ARCH),arm)
-OS_CFLAGS += -DAVMPLUS_ARM -DAVMPLUS_UNIX -DAVMPLUS_LINUX
-NANOJIT_ARCH = ARM
-endif
-
-GFX_ARCH = x
-
-OS_LIBS = -lm -lc
-
-ASFLAGS += -x assembler-with-cpp
-
-
-ifeq ($(CPU_ARCH),alpha)
-
-# Ask the C compiler on alpha linux to let us work with denormalized
-# double values, which are required by the ECMA spec.
-
-OS_CFLAGS += -mieee
-endif
-
-# Use the editline library to provide line-editing support.
-JS_EDITLINE = 1
-
-ifeq ($(CPU_ARCH),x86_64)
-# Use VA_COPY() standard macro on x86-64
-# FIXME: better use it everywhere
-OS_CFLAGS += -DHAVE_VA_COPY -DVA_COPY=va_copy
-endif
-
-ifeq ($(CPU_ARCH),x86_64)
-# We need PIC code for shared libraries
-# FIXME: better patch rules.mk & fdlibm/Makefile*
-OS_CFLAGS += -DPIC -fPIC
-endif
diff -r 17e9560465b0 js/src/config/Mac_OS10.0.mk
--- a/js/src/config/Mac_OS10.0.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,82 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#   Steve Zellers (zellers@apple.com)
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config for Mac OS X as of PR3
-# Just ripped from Linux config
-#
-
-CC = cc
-CCC = g++
-CFLAGS +=  -Wall -Wno-format
-OS_CFLAGS = -DXP_UNIX -DSVR4 -DSYSV -D_BSD_SOURCE -DPOSIX_SOURCE 
--DRHAPSODY
-
-RANLIB = ranlib
-MKSHLIB = libtool -dynamic $(XMKSHLIBOPTS) -framework System
-
-#.c.o:
-#      $(CC) -c -MD $*.d $(CFLAGS) $<
-
-CPU_ARCH = $(shell uname -m)
-ifeq (86,$(findstring 86,$(CPU_ARCH)))
-CPU_ARCH = x86
-OS_CFLAGS+= -DX86_LINUX
-endif
-GFX_ARCH = x
-
-OS_LIBS = -lc -framework System
-
-ASFLAGS += -x assembler-with-cpp
-
-ifeq ($(CPU_ARCH),alpha)
-
-# Ask the C compiler on alpha linux to let us work with denormalized
-# double values, which are required by the ECMA spec.
-
-OS_CFLAGS += -mieee
-endif
-
-# Use the editline library to provide line-editing support.
-JS_EDITLINE = 1
-
-# Don't allow Makefile.ref to use libmath
-NO_LIBM = 1
-
diff -r 17e9560465b0 js/src/config/Makefile.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/Makefile.in	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,121 @@
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+# Netscape Communications Corporation.
+# Portions created by the Initial Developer are Copyright (C) 1998
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Robert Ginda <rginda@netscape.com>
+#   John Taylor <jtaylor@netscape.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+# For sanity's sake, we compile nsinstall without the wrapped system
+# headers, so that we can use it to set up the wrapped system headers.
+VISIBILITY_FLAGS =
+
+ifneq (,$(CROSS_COMPILE)$(filter-out WINNT OS2,$(OS_ARCH)))
+ifneq ($(OS_ARCH), WINCE)
+HOST_PROGRAM	= nsinstall$(HOST_BIN_SUFFIX)
+HOST_CSRCS	= nsinstall.c pathsub.c
+endif
+endif
+
+PLSRCS		= nfspwd.pl revdepth.pl
+
+TARGETS		= $(HOST_PROGRAM) $(PLSRCS:.pl=) $(SIMPLE_PROGRAMS)
+
+ifndef CROSS_COMPILE
+ifdef USE_ELF_DYNSTR_GC
+TARGETS		+= elf-dynstr-gc
+MAKE_DIRS	+= $(MDDEPDIR)
+GARBAGE_DIRS	+= $(MDDEPDIR)
+endif
+endif
+
+# IMPORTANT: Disable NSBUILDROOT for this directory only, otherwise we have
+# a recursive rule for finding nsinstall and the Perl scripts.
+ifdef NSBUILDROOT
+override NSBUILDROOT :=
+endif
+
+ifdef GNU_CC
+MODULE_OPTIMIZE_FLAGS = -O3
+endif
+
+ifndef COMPILER_DEPEND
+ifndef MOZ_NATIVE_MAKEDEPEND
+DIRS		+= mkdepend
+endif
+endif
+
+include $(topsrcdir)/config/config.mk
+
+# Do not install util programs
+NO_INSTALL=1
+
+include $(topsrcdir)/config/rules.mk
+
+export:: $(TARGETS)
+ifdef HOST_PROGRAM
+	$(INSTALL) $(HOST_PROGRAM) $(DIST)/bin
+endif
+
+ifdef WRAP_SYSTEM_INCLUDES
+export::
+	if test ! -d system_wrappers; then mkdir system_wrappers; fi
+	$(PERL) $(srcdir)/preprocessor.pl $(DEFINES) $(ACDEFINES) \
+		-DBUILD_STATIC_LIBS=$(BUILD_STATIC_LIBS) \
+		$(srcdir)/system-headers | $(PERL) $(srcdir)/make-system-wrappers.pl system_wrappers
+	$(INSTALL) system_wrappers $(DIST)/include
+
+GARBAGE_DIRS += system_wrappers
+endif
+
+ifndef CROSS_COMPILE
+ifdef USE_ELF_DYNSTR_GC
+elf-dynstr-gc: elf-dynstr-gc.c Makefile Makefile.in
+	$(CC) $(COMPILE_CFLAGS) $(GLIB_CFLAGS) -o $@ $< $(LDFLAGS) $(GLIB_LIBS) 
+endif
+endif
+
+FORCE:
+
+ifdef MKDEPEND_DIR
+clean clobber realclean clobber_all::
+	cd $(MKDEPEND_DIR); $(MAKE) $@
+endif
diff -r 17e9560465b0 js/src/config/Moz/Milestone.pm
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/Moz/Milestone.pm	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,232 @@
+#!/usr/bin/perl -w
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Win32 Version System.
+#
+# The Initial Developer of the Original Code is Netscape Communications Corporation
+# Portions created by the Initial Developer are Copyright (C) 2002
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+package Moz::Milestone;
+use strict;
+
+use vars qw($officialMilestone
+            $milestone);
+
+local $Moz::Milestone::milestone;
+local $Moz::Milestone::officialMilestone;
+
+#
+# Usage:  getOfficialMilestone($milestoneFile)
+# Returns full milestone (x.x.x.x[ab12pre+])
+#
+sub getOfficialMilestone($) {
+  my $mfile = $_[0];
+  open(FILE,"$mfile") ||
+    die ("Can't open $mfile for reading!");
+
+  my $num = <FILE>;
+  while($num =~ /^\s*#/ || $num !~ /^\d/) {
+      $num = <FILE>;
+  }
+
+  close(FILE);
+  if ($num !~ /^\d/) { return; }
+  chomp($num);
+  # Remove extra ^M caused by using dos-mode line-endings
+  chop $num if (substr($num, -1, 1) eq "\r");
+  $Moz::Milestone::officialMilestone = $num;
+  $Moz::Milestone::milestone = &getMilestoneNum;
+  return $num;
+}
+
+#
+# Usage: getMilestoneNum($num)
+# Returns: milestone without a + if it exists.
+#
+sub getMilestoneNum {
+  if (defined($Moz::Milestone::milestone)) {
+    return $Moz::Milestone::milestone;
+  }
+
+  if (defined($Moz::Milestone::officialMilestone)) {
+    $Moz::Milestone::milestone = $Moz::Milestone::officialMilestone;
+  } else {
+    $Moz::Milestone::milestone = $_[0];
+  }
+
+  if ($Moz::Milestone::milestone =~ /\+$/) {    # for x.x.x+, strip off the +
+    $Moz::Milestone::milestone =~ s/\+$//;
+  }
+
+  return $Moz::Milestone::milestone;
+}
+
+#
+# Usage: getMilestoneQualifier($num)
+# Returns: + if it exists.
+#
+sub getMilestoneQualifier {
+  my $milestoneQualifier;
+  if (defined($Moz::Milestone::officialMilestone)) {
+    $milestoneQualifier = $Moz::Milestone::officialMilestone;
+  } else {
+    $milestoneQualifier = $_[0];
+  }
+
+  if ($milestoneQualifier =~ /\+$/) {
+    return "+";
+  }
+}
+
+sub getMilestoneMajor {
+  my $milestoneMajor;
+  if (defined($Moz::Milestone::milestone)) {
+    $milestoneMajor = $Moz::Milestone::milestone;
+  } else {
+    $milestoneMajor = $_[0];
+  }
+  my @parts = split(/\./,$milestoneMajor);
+  return $parts[0];
+}
+
+sub getMilestoneMinor {
+  my $milestoneMinor;
+  if (defined($Moz::Milestone::milestone)) {
+    $milestoneMinor = $Moz::Milestone::milestone;
+  } else {
+    $milestoneMinor = $_[0];
+  }
+  my @parts = split(/\./,$milestoneMinor);
+
+  if ($#parts < 1 ) { return 0; }
+  return $parts[1];
+}
+
+sub getMilestoneMini {
+  my $milestoneMini;
+  if (defined($Moz::Milestone::milestone)) {
+    $milestoneMini = $Moz::Milestone::milestone;
+  } else {
+    $milestoneMini = $_[0];
+  }
+  my @parts = split(/\./,$milestoneMini);
+
+  if ($#parts < 2 ) { return 0; }
+  return $parts[2];
+}
+
+sub getMilestoneMicro {
+  my $milestoneMicro;
+  if (defined($Moz::Milestone::milestone)) {
+    $milestoneMicro = $Moz::Milestone::milestone;
+  } else {
+    $milestoneMicro = $_[0];
+  }
+  my @parts = split(/\./,$milestoneMicro);
+
+  if ($#parts < 3 ) { return 0; }
+  return $parts[3];
+}
+
+sub getMilestoneAB {
+  my $milestoneAB;
+  if (defined($Moz::Milestone::milestone)) {
+    $milestoneAB = $Moz::Milestone::milestone;
+  } else {
+    $milestoneAB = $_[0];
+  }
+  
+  if ($milestoneAB =~ /a/) { return "alpha"; }
+  if ($milestoneAB =~ /b/) { return "beta"; }
+  return "final";
+}
+
+#
+# build_file($template_file,$output_file)
+#
+sub build_file($$) {
+  my @FILE;
+  my @MILESTONE_PARTS;
+  my $MINI_VERSION = 0;
+  my $MICRO_VERSION = 0;
+  my $OFFICIAL = 0;
+  my $QUALIFIER = "";
+
+  if (!defined($Moz::Milestone::milestone)) { die("$0: no milestone file set!\n"); }
+  @MILESTONE_PARTS = split(/\./, &getMilestoneNum);
+  if ($#MILESTONE_PARTS >= 2) {
+    $MINI_VERSION = 1;
+  } else {
+    $MILESTONE_PARTS[2] = 0;
+  }
+  if ($#MILESTONE_PARTS >= 3) {
+    $MICRO_VERSION = 1;
+  } else {
+    $MILESTONE_PARTS[3] = 0;
+  }
+  if (! &getMilestoneQualifier) {
+    $OFFICIAL = 1;
+  } else {
+    $QUALIFIER = "+";
+  }
+
+  if (-e $_[0]) {
+    open(FILE, "$_[0]") || die("$0: Can't open $_[0] for reading!\n");
+    @FILE = <FILE>;
+    close(FILE);
+
+    open(FILE, ">$_[1]") || die("$0: Can't open $_[1] for writing!\n");
+
+    #
+    # There will be more of these based on what we need for files.
+    #
+    foreach(@FILE) {
+      s/__MOZ_MAJOR_VERSION__/$MILESTONE_PARTS[0]/g;
+      s/__MOZ_MINOR_VERSION__/$MILESTONE_PARTS[1]/g;
+      s/__MOZ_MINI_VERSION__/$MILESTONE_PARTS[2]/g;
+      s/__MOZ_MICRO_VERSION__/$MILESTONE_PARTS[3]/g;
+      if ($MINI_VERSION) {
+        s/__MOZ_OPTIONAL_MINI_VERSION__/.$MILESTONE_PARTS[2]/g;
+      }
+      if ($MICRO_VERSION) {
+        s/__MOZ_OPTIONAL_MICRO_VERSION__/.$MILESTONE_PARTS[3]/g;
+      }
+
+      print FILE $_;
+    }
+    close(FILE);
+  } else {
+    die("$0: $_[0] doesn't exist for autoversioning!\n");
+  }
+
+}
+
+1;
diff -r 17e9560465b0 js/src/config/OSF1V4.0.mk
--- a/js/src/config/OSF1V4.0.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,72 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config stuff for Data General DG/UX
-#
-
-#
-#  Initial DG/UX port by Marc Fraioli (fraioli@dg-rtp.dg.com)
-#
-
-ifndef NS_USE_NATIVE
-CC = gcc
-CCC = g++
-CFLAGS +=  -mieee -Wall -Wno-format
-else
-CC  = cc
-CCC = cxx
-CFLAGS += -ieee -std
-# LD  = cxx
-endif
-
-RANLIB = echo
-MKSHLIB = $(LD) -shared -taso -all -expect_unresolved "*"
-
-#
-#  _DGUX_SOURCE is needed to turn on a lot of stuff in the headers if 
-#      you're not using DG's compiler.  It shouldn't hurt if you are.
-#
-#  _POSIX4A_DRAFT10_SOURCE is needed to pick up localtime_r, used in
-#      prtime.c
-#
-OS_CFLAGS = -DXP_UNIX -DSVR4 -DSYSV -DDGUX -D_DGUX_SOURCE -D_POSIX4A_DRAFT10_SOURCE -DOSF1 -DHAVE_LOCALTIME_R
-OS_LIBS = -lsocket -lnsl 
-
-NOSUCHFILE = /no-such-file
diff -r 17e9560465b0 js/src/config/OSF1V5.0.mk
--- a/js/src/config/OSF1V5.0.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,69 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config stuff for Tru64 Unix 5.0
-#
-
-#
-#  Initial DG/UX port by Marc Fraioli (fraioli@dg-rtp.dg.com)
-#
-
-ifndef NS_USE_NATIVE
-CC = gcc
-CCC = g++
-CFLAGS +=  -mieee -Wall -Wno-format
-else
-CC  = cc
-CCC = cxx
-CFLAGS += -ieee -std -pthread
-# LD  = cxx
-endif
-
-RANLIB = echo
-MKSHLIB = $(LD) -shared -all -expect_unresolved "*"
-
-#
-#  _POSIX4A_DRAFT10_SOURCE is needed to pick up localtime_r, used in
-#      prtime.c
-#
-OS_CFLAGS = -DXP_UNIX -DSVR4 -DSYSV -D_POSIX4A_DRAFT10_SOURCE -DOSF1 -DHAVE_LOCALTIME_R
-OS_LIBS = -lsocket -lnsl 
-
-NOSUCHFILE = /no-such-file
diff -r 17e9560465b0 js/src/config/SunOS4.1.4.mk
--- a/js/src/config/SunOS4.1.4.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,101 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config stuff for SunOS4.1
-#
-
-CC = gcc
-CCC = g++
-RANLIB = ranlib
-
-#.c.o:
-#	$(CC) -c -MD $*.d $(CFLAGS) $<
-
-CPU_ARCH = sparc
-GFX_ARCH = x
-
-# A pile of -D's to build xfe on sunos
-MOZ_CFLAGS = -DSTRINGS_ALIGNED -DNO_REGEX -DNO_ISDIR -DUSE_RE_COMP \
-	     -DNO_REGCOMP -DUSE_GETWD -DNO_MEMMOVE -DNO_ALLOCA \
-	     -DBOGUS_MB_MAX -DNO_CONST
-
-# Purify doesn't like -MDupdate
-NOMD_OS_CFLAGS = -DXP_UNIX -Wall -Wno-format -DSW_THREADS -DSUNOS4 -DNEED_SYSCALL \
-		 $(MOZ_CFLAGS)
-
-OS_CFLAGS = $(NOMD_OS_CFLAGS) -MDupdate $(DEPENDENCIES)
-OS_LIBS = -ldl -lm
-
-MKSHLIB = $(LD) -L$(MOTIF)/lib
-
-HAVE_PURIFY = 1
-MOTIF = /home/motif/usr
-MOTIFLIB = -L$(MOTIF)/lib -lXm
-INCLUDES += -I/usr/X11R5/include -I$(MOTIF)/include
-
-NOSUCHFILE = /solaris-rm-f-sucks
-
-LOCALE_MAP = $(DEPTH)/cmd/xfe/intl/sunos.lm
-
-EN_LOCALE = en_US
-DE_LOCALE = de
-FR_LOCALE = fr
-JP_LOCALE = ja
-SJIS_LOCALE = ja_JP.SJIS
-KR_LOCALE = ko
-CN_LOCALE = zh
-TW_LOCALE = zh_TW
-I2_LOCALE = i2
-IT_LOCALE = it
-SV_LOCALE = sv
-ES_LOCALE = es
-NL_LOCALE = nl
-PT_LOCALE = pt
-
-LOC_LIB_DIR = /usr/openwin/lib/locale
-
-BSDECHO	= echo
-
-#
-# These defines are for building unix plugins
-#
-BUILD_UNIX_PLUGINS = 1
-DSO_LDOPTS =
-DSO_LDFLAGS =
diff -r 17e9560465b0 js/src/config/SunOS5.10.mk
--- a/js/src/config/SunOS5.10.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,50 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1999
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config stuff for SunOS5.10, using vendor gcc and NSPR
-#
-
-include $(DEPTH)/config/SunOS5.5.mk
-
-INCLUDES += -I/usr/sfw/include/mozilla/nspr
-OTHER_LIBS += -L/usr/sfw/lib/mozilla -R/usr/sfw/lib/mozilla
-
-CC=gcc
-
diff -r 17e9560465b0 js/src/config/SunOS5.3.mk
--- a/js/src/config/SunOS5.3.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,91 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config stuff for SunOS5.3
-#
-
-CC = gcc
-CCC = g++
-CFLAGS +=  -Wall -Wno-format
-
-#CC = /opt/SUNWspro/SC3.0.1/bin/cc
-RANLIB = echo
-
-#.c.o:
-#	$(CC) -c -MD $*.d $(CFLAGS) $<
-
-CPU_ARCH = sparc
-GFX_ARCH = x
-
-OS_CFLAGS = -DXP_UNIX -DSVR4 -DSYSV -DSOLARIS -DHAVE_LOCALTIME_R
-OS_LIBS = -lsocket -lnsl -ldl
-
-ASFLAGS	        += -P -L -K PIC -D_ASM -D__STDC__=0
-
-HAVE_PURIFY = 1
-
-NOSUCHFILE = /solaris-rm-f-sucks
-
-ifndef JS_NO_ULTRA
-ULTRA_OPTIONS := -xarch=v8plus
-ULTRA_OPTIONSD := -DULTRA_SPARC
-else
-ULTRA_OPTIONS := -xarch=v8
-ULTRA_OPTIONSD :=
-endif
-
-ifeq ($(OS_CPUARCH),sun4u)
-DEFINES 	+= $(ULTRA_OPTIONSD)
-ifeq ($(findstring gcc,$(CC)),gcc)
-DEFINES         += -Wa,$(ULTRA_OPTIONS),$(ULTRA_OPTIONSD)
-else
-ASFLAGS         += $(ULTRA_OPTIONS) $(ULTRA_OPTIONSD)
-endif
-endif
-
-ifeq ($(OS_CPUARCH),sun4m)
-ifeq ($(findstring gcc,$(CC)),gcc)
-DEFINES         += -Wa,-xarch=v8
-else
-ASFLAGS         += -xarch=v8
-endif
-endif
-
-MKSHLIB = $(LD) -G
diff -r 17e9560465b0 js/src/config/SunOS5.4.mk
--- a/js/src/config/SunOS5.4.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,92 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config stuff for SunOS5.4
-#
-
-ifdef NS_USE_NATIVE
-CC = cc
-CCC = CC
-else
-CC = gcc
-CCC = g++
-CFLAGS += -Wall -Wno-format
-endif
-
-RANLIB = echo
-
-CPU_ARCH = sparc
-GFX_ARCH = x
-
-OS_CFLAGS = -DXP_UNIX -DSVR4 -DSYSV -D__svr4 -DSOLARIS -DHAVE_LOCALTIME_R
-OS_LIBS = -lsocket -lnsl -ldl
-
-ASFLAGS	        += -P -L -K PIC -D_ASM -D__STDC__=0
-
-HAVE_PURIFY = 1
-
-NOSUCHFILE = /solaris-rm-f-sucks
-
-ifndef JS_NO_ULTRA
-ULTRA_OPTIONS := -xarch=v8plus
-ULTRA_OPTIONSD := -DULTRA_SPARC
-else
-ULTRA_OPTIONS := -xarch=v8
-ULTRA_OPTIONSD :=
-endif
-
-ifeq ($(OS_CPUARCH),sun4u)
-DEFINES 	+= $(ULTRA_OPTIONSD)
-ifeq ($(findstring gcc,$(CC)),gcc)
-DEFINES         += -Wa,$(ULTRA_OPTIONS),$(ULTRA_OPTIONSD)
-else
-ASFLAGS         += $(ULTRA_OPTIONS) $(ULTRA_OPTIONSD)
-endif
-endif
-
-ifeq ($(OS_CPUARCH),sun4m)
-ifeq ($(findstring gcc,$(CC)),gcc)
-DEFINES         += -Wa,-xarch=v8
-else
-ASFLAGS         += -xarch=v8
-endif
-endif
-
-MKSHLIB = $(LD) -G
diff -r 17e9560465b0 js/src/config/SunOS5.5.1.mk
--- a/js/src/config/SunOS5.5.1.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,44 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config stuff for SunOS5.5.1
-#
-
-include $(DEPTH)/config/SunOS5.5.mk
diff -r 17e9560465b0 js/src/config/SunOS5.5.mk
--- a/js/src/config/SunOS5.5.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,87 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config stuff for SunOS5.5
-#
-
-AS = /usr/ccs/bin/as
-ifndef NS_USE_NATIVE
-CC = gcc
-CCC = g++
-CFLAGS +=  -Wall -Wno-format
-else
-CC = cc
-CCC = CC
-endif
-
-RANLIB = echo
-
-#.c.o:
-#	$(CC) -c -MD $*.d $(CFLAGS) $<
-
-CPU_ARCH = sparc
-GFX_ARCH = x
-
-OS_CFLAGS = -DXP_UNIX -DSVR4 -DSYSV -DSOLARIS -DHAVE_LOCALTIME_R
-OS_LIBS = -lsocket -lnsl -ldl
-
-ASFLAGS	        += -P -L -K PIC -D_ASM -D__STDC__=0
-
-HAVE_PURIFY = 1
-
-NOSUCHFILE = /solaris-rm-f-sucks
-
-ifeq ($(OS_CPUARCH),sun4u)	# ultra sparc?
-ifeq ($(CC),gcc)		# using gcc?
-ifndef JS_NO_ULTRA		# do we want ultra?
-ifdef JS_THREADSAFE		# only in thread-safe mode
-DEFINES 	+= -DULTRA_SPARC
-DEFINES         += -Wa,-xarch=v8plus,-DULTRA_SPARC
-else
-ASFLAGS         += -xarch=v8plus -DULTRA_SPARC
-endif
-endif
-endif
-endif
-
-MKSHLIB = $(LD) -G
-
-# Use the editline library to provide line-editing support.
-JS_EDITLINE = 1
diff -r 17e9560465b0 js/src/config/SunOS5.6.mk
--- a/js/src/config/SunOS5.6.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,89 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config stuff for SunOS5.5
-#
-
-AS = /usr/ccs/bin/as
-ifndef NS_USE_NATIVE
-  CC = gcc
-  CCC = g++
-  CFLAGS +=  -Wall -Wno-format
-else
-  CC = cc
-  CCC = CC
-  CFLAGS += -mt -KPIC
-#  LD = CC
-endif
-
-RANLIB = echo
-
-#.c.o:
-#	$(CC) -c -MD $*.d $(CFLAGS) $<
-
-CPU_ARCH = sparc
-GFX_ARCH = x
-
-OS_CFLAGS = -DXP_UNIX -DSVR4 -DSYSV -DSOLARIS -DHAVE_LOCALTIME_R
-OS_LIBS = -lsocket -lnsl -ldl
-
-ASFLAGS	        += -P -L -K PIC -D_ASM -D__STDC__=0
-
-HAVE_PURIFY = 1
-
-NOSUCHFILE = /solaris-rm-f-sucks
-
-ifeq ($(OS_CPUARCH),sun4u)	# ultra sparc?
-ifeq ($(CC),gcc)		# using gcc?
-ifndef JS_NO_ULTRA		# do we want ultra?
-ifdef JS_THREADSAFE		# only in thread-safe mode
-DEFINES 	+= -DULTRA_SPARC
-DEFINES         += -Wa,-xarch=v8plus,-DULTRA_SPARC
-else
-ASFLAGS         += -xarch=v8plus -DULTRA_SPARC
-endif
-endif
-endif
-endif
-
-MKSHLIB = $(LD) -G
-
-# Use the editline library to provide line-editing support.
-JS_EDITLINE = 1
diff -r 17e9560465b0 js/src/config/SunOS5.7.mk
--- a/js/src/config/SunOS5.7.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,44 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1999
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config stuff for SunOS5.7
-#
-
-include $(DEPTH)/config/SunOS5.5.mk
diff -r 17e9560465b0 js/src/config/SunOS5.8.mk
--- a/js/src/config/SunOS5.8.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,44 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1999
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config stuff for SunOS5.8
-#
-
-include $(DEPTH)/config/SunOS5.5.mk
diff -r 17e9560465b0 js/src/config/SunOS5.9.mk
--- a/js/src/config/SunOS5.9.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,44 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1999
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config stuff for SunOS5.9
-#
-
-include $(DEPTH)/config/SunOS5.5.mk
diff -r 17e9560465b0 js/src/config/WINNT4.0.mk
--- a/js/src/config/WINNT4.0.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,118 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config for Windows NT using MS Visual C++ (version?)
-#
-
-CC = cl
-CXX = cl
-
-RANLIB = echo
-
-PDBFILE = $(basename $(@F)).pdb
-
-#.c.o:
-#      $(CC) -c -MD $*.d $(CFLAGS) $<
-
-CPU_ARCH = x86 # XXX fixme
-GFX_ARCH = win32
-
-# MSVC compiler options for both debug/optimize
-# -nologo  - suppress copyright message
-# -W3      - Warning level 3
-# -Gm      - enable minimal rebuild
-# -Z7      - put debug info into the executable, not in .pdb file
-# -Zi      - put debug info into .pdb file
-# -YX      - automatic precompiled headers
-# -GX      - enable C++ exception support
-WIN_CFLAGS = -nologo -W3 
-
-# MSVC compiler options for debug builds linked to MSVCRTD.DLL
-# -MDd     - link with MSVCRTD.LIB (Dynamically-linked, multi-threaded, debug C-runtime)
-# -Od      - minimal optimization
-WIN_IDG_CFLAGS = -MDd -Od -Z7 
-
-# MSVC compiler options for debug builds linked to MSVCRT.DLL
-# -MD      - link with MSVCRT.LIB (Dynamically-linked, multi-threaded, debug C-runtime)
-# -Od      - minimal optimization
-WIN_DEBUG_CFLAGS = -MD -Od -Zi -Fd$(OBJDIR)/$(PDBFILE)
-
-# MSVC compiler options for release (optimized) builds
-# -MD      - link with MSVCRT.LIB (Dynamically-linked, multi-threaded, C-runtime)
-# -O2      - Optimize for speed
-# -G5      - Optimize for Pentium
-WIN_OPT_CFLAGS = -MD -O2
-
-ifdef BUILD_OPT
-OPTIMIZER = $(WIN_OPT_CFLAGS)
-else
-ifdef BUILD_IDG
-OPTIMIZER = $(WIN_IDG_CFLAGS)
-else
-OPTIMIZER = $(WIN_DEBUG_CFLAGS)
-endif
-endif
-
-OS_CFLAGS = -D_X86_=1 -DXP_WIN -DXP_WIN32 -DWIN32 -D_WINDOWS -D_WIN32 $(WIN_CFLAGS)
-JSDLL_CFLAGS = -DEXPORT_JS_API
-OS_LIBS = -lm -lc
-
-PREBUILT_CPUCFG = 1
-USE_MSVC = 1
-
-LIB_LINK_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\
- advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib oldnames.lib \
- winmm.lib \
- -nologo\
- -subsystem:windows -dll -debug -pdb:$(OBJDIR)/$(PDBFILE)\
- -machine:I386\
- -opt:ref -opt:noicf
-
-EXE_LINK_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\
- advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib oldnames.lib -nologo\
- -subsystem:console -debug -pdb:$(OBJDIR)/$(PDBFILE)\
- -machine:I386\
- -opt:ref -opt:noicf
-
-# CAFEDIR = t:/cafe
-# JCLASSPATH = $(CAFEDIR)/Java/Lib/classes.zip
-# JAVAC = $(CAFEDIR)/Bin/sj.exe
-# JAVAH = $(CAFEDIR)/Java/Bin/javah.exe
-# JCFLAGS = -I$(CAFEDIR)/Java/Include -I$(CAFEDIR)/Java/Include/win32
diff -r 17e9560465b0 js/src/config/WINNT5.0.mk
--- a/js/src/config/WINNT5.0.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,118 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config for Windows NT using MS Visual C++ (version?)
-#
-
-CC = cl
-CXX = cl
-
-RANLIB = echo
-
-PDBFILE = $(basename $(@F)).pdb
-
-#.c.o:
-#      $(CC) -c -MD $*.d $(CFLAGS) $<
-
-CPU_ARCH = x86 # XXX fixme
-GFX_ARCH = win32
-
-# MSVC compiler options for both debug/optimize
-# -nologo  - suppress copyright message
-# -W3      - Warning level 3
-# -Gm      - enable minimal rebuild
-# -Z7      - put debug info into the executable, not in .pdb file
-# -Zi      - put debug info into .pdb file
-# -YX      - automatic precompiled headers
-# -GX      - enable C++ exception support
-WIN_CFLAGS = -nologo -W3 
-
-# MSVC compiler options for debug builds linked to MSVCRTD.DLL
-# -MDd     - link with MSVCRTD.LIB (Dynamically-linked, multi-threaded, debug C-runtime)
-# -Od      - minimal optimization
-WIN_IDG_CFLAGS = -MDd -Od -Z7 
-
-# MSVC compiler options for debug builds linked to MSVCRT.DLL
-# -MD      - link with MSVCRT.LIB (Dynamically-linked, multi-threaded, debug C-runtime)
-# -Od      - minimal optimization
-WIN_DEBUG_CFLAGS = -MD -Od -Zi -Fd$(OBJDIR)/$(PDBFILE)
-
-# MSVC compiler options for release (optimized) builds
-# -MD      - link with MSVCRT.LIB (Dynamically-linked, multi-threaded, C-runtime)
-# -O2      - Optimize for speed
-# -G5      - Optimize for Pentium
-WIN_OPT_CFLAGS = -MD -O2
-
-ifdef BUILD_OPT
-OPTIMIZER = $(WIN_OPT_CFLAGS)
-else
-ifdef BUILD_IDG
-OPTIMIZER = $(WIN_IDG_CFLAGS)
-else
-OPTIMIZER = $(WIN_DEBUG_CFLAGS)
-endif
-endif
-
-OS_CFLAGS = -D_X86_=1 -DXP_WIN -DXP_WIN32 -DWIN32 -D_WINDOWS -D_WIN32 -DWINVER=0x500 -D_WIN32_WINNT=0x500 $(WIN_CFLAGS)
-JSDLL_CFLAGS = -DEXPORT_JS_API
-OS_LIBS = -lm -lc
-
-PREBUILT_CPUCFG = 1
-USE_MSVC = 1
-
-LIB_LINK_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\
- advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib oldnames.lib \
- winmm.lib \
- -nologo\
- -subsystem:windows -dll -debug -pdb:$(OBJDIR)/$(PDBFILE)\
- -machine:I386\
- -opt:ref -opt:noicf
-
-EXE_LINK_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\
- advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib oldnames.lib -nologo\
- -subsystem:console -debug -pdb:$(OBJDIR)/$(PDBFILE)\
- -machine:I386\
- -opt:ref -opt:noicf
-
-# CAFEDIR = t:/cafe
-# JCLASSPATH = $(CAFEDIR)/Java/Lib/classes.zip
-# JAVAC = $(CAFEDIR)/Bin/sj.exe
-# JAVAH = $(CAFEDIR)/Java/Bin/javah.exe
-# JCFLAGS = -I$(CAFEDIR)/Java/Include -I$(CAFEDIR)/Java/Include/win32
diff -r 17e9560465b0 js/src/config/WINNT5.1.mk
--- a/js/src/config/WINNT5.1.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,118 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config for Windows NT using MS Visual C++ (version?)
-#
-
-CC = cl
-CXX = cl
-
-RANLIB = echo
-
-PDBFILE = $(basename $(@F)).pdb
-
-#.c.o:
-#      $(CC) -c -MD $*.d $(CFLAGS) $<
-
-CPU_ARCH = x86 # XXX fixme
-GFX_ARCH = win32
-
-# MSVC compiler options for both debug/optimize
-# -nologo  - suppress copyright message
-# -W3      - Warning level 3
-# -Gm      - enable minimal rebuild
-# -Z7      - put debug info into the executable, not in .pdb file
-# -Zi      - put debug info into .pdb file
-# -YX      - automatic precompiled headers
-# -GX      - enable C++ exception support
-WIN_CFLAGS = -nologo -W3 
-
-# MSVC compiler options for debug builds linked to MSVCRTD.DLL
-# -MDd     - link with MSVCRTD.LIB (Dynamically-linked, multi-threaded, debug C-runtime)
-# -Od      - minimal optimization
-WIN_IDG_CFLAGS = -MDd -Od -Z7 
-
-# MSVC compiler options for debug builds linked to MSVCRT.DLL
-# -MD      - link with MSVCRT.LIB (Dynamically-linked, multi-threaded, debug C-runtime)
-# -Od      - minimal optimization
-WIN_DEBUG_CFLAGS = -MD -Od -Zi -Fd$(OBJDIR)/$(PDBFILE)
-
-# MSVC compiler options for release (optimized) builds
-# -MD      - link with MSVCRT.LIB (Dynamically-linked, multi-threaded, C-runtime)
-# -O2      - Optimize for speed
-# -G5      - Optimize for Pentium
-WIN_OPT_CFLAGS = -MD -O2
-
-ifdef BUILD_OPT
-OPTIMIZER = $(WIN_OPT_CFLAGS)
-else
-ifdef BUILD_IDG
-OPTIMIZER = $(WIN_IDG_CFLAGS)
-else
-OPTIMIZER = $(WIN_DEBUG_CFLAGS)
-endif
-endif
-
-OS_CFLAGS = -D_X86_=1 -DXP_WIN -DXP_WIN32 -DWIN32 -D_WINDOWS -D_WIN32 -DWINVER=0x500 -D_WIN32_WINNT=0x500 $(WIN_CFLAGS)
-JSDLL_CFLAGS = -DEXPORT_JS_API
-OS_LIBS = -lm -lc
-
-PREBUILT_CPUCFG = 1
-USE_MSVC = 1
-
-LIB_LINK_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\
- advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib oldnames.lib \
- winmm.lib \
- -nologo\
- -subsystem:windows -dll -debug -pdb:$(OBJDIR)/$(PDBFILE)\
- -machine:I386\
- -opt:ref -opt:noicf
-
-EXE_LINK_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\
- advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib oldnames.lib -nologo\
- -subsystem:console -debug -pdb:$(OBJDIR)/$(PDBFILE)\
- -machine:I386\
- -opt:ref -opt:noicf
-
-# CAFEDIR = t:/cafe
-# JCLASSPATH = $(CAFEDIR)/Java/Lib/classes.zip
-# JAVAC = $(CAFEDIR)/Bin/sj.exe
-# JAVAH = $(CAFEDIR)/Java/Bin/javah.exe
-# JCFLAGS = -I$(CAFEDIR)/Java/Include -I$(CAFEDIR)/Java/Include/win32
diff -r 17e9560465b0 js/src/config/WINNT5.2.mk
--- a/js/src/config/WINNT5.2.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,118 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config for Windows NT using MS Visual C++ (version?)
-#
-
-CC = cl
-CXX = cl
-
-RANLIB = echo
-
-PDBFILE = $(basename $(@F)).pdb
-
-#.c.o:
-#      $(CC) -c -MD $*.d $(CFLAGS) $<
-
-CPU_ARCH = x86 # XXX fixme
-GFX_ARCH = win32
-
-# MSVC compiler options for both debug/optimize
-# -nologo  - suppress copyright message
-# -W3      - Warning level 3
-# -Gm      - enable minimal rebuild
-# -Z7      - put debug info into the executable, not in .pdb file
-# -Zi      - put debug info into .pdb file
-# -YX      - automatic precompiled headers
-# -GX      - enable C++ exception support
-WIN_CFLAGS = -nologo -W3 
-
-# MSVC compiler options for debug builds linked to MSVCRTD.DLL
-# -MDd     - link with MSVCRTD.LIB (Dynamically-linked, multi-threaded, debug C-runtime)
-# -Od      - minimal optimization
-WIN_IDG_CFLAGS = -MDd -Od -Z7 
-
-# MSVC compiler options for debug builds linked to MSVCRT.DLL
-# -MD      - link with MSVCRT.LIB (Dynamically-linked, multi-threaded, debug C-runtime)
-# -Od      - minimal optimization
-WIN_DEBUG_CFLAGS = -MD -Od -Zi -Fd$(OBJDIR)/$(PDBFILE)
-
-# MSVC compiler options for release (optimized) builds
-# -MD      - link with MSVCRT.LIB (Dynamically-linked, multi-threaded, C-runtime)
-# -O2      - Optimize for speed
-# -G5      - Optimize for Pentium
-WIN_OPT_CFLAGS = -MD -O2
-
-ifdef BUILD_OPT
-OPTIMIZER = $(WIN_OPT_CFLAGS)
-else
-ifdef BUILD_IDG
-OPTIMIZER = $(WIN_IDG_CFLAGS)
-else
-OPTIMIZER = $(WIN_DEBUG_CFLAGS)
-endif
-endif
-
-OS_CFLAGS = -D_X86_=1 -DXP_WIN -DXP_WIN32 -DWIN32 -D_WINDOWS -D_WIN32 -DWINVER=0x500 -D_WIN32_WINNT=0x500 $(WIN_CFLAGS) -DAVMPLUS_WIN32 -DAVMPLUS_IA32
-JSDLL_CFLAGS = -DEXPORT_JS_API
-OS_LIBS = -lm -lc
-
-PREBUILT_CPUCFG = 1
-USE_MSVC = 1
-
-LIB_LINK_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\
- advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib oldnames.lib \
- winmm.lib \
- -nologo\
- -subsystem:windows -dll -debug -pdb:$(OBJDIR)/$(PDBFILE)\
- -machine:I386\
- -opt:ref -opt:noicf
-
-EXE_LINK_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\
- advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib oldnames.lib -nologo\
- -subsystem:console -debug -pdb:$(OBJDIR)/$(PDBFILE)\
- -machine:I386\
- -opt:ref -opt:noicf
-
-# CAFEDIR = t:/cafe
-# JCLASSPATH = $(CAFEDIR)/Java/Lib/classes.zip
-# JAVAC = $(CAFEDIR)/Bin/sj.exe
-# JAVAH = $(CAFEDIR)/Java/Bin/javah.exe
-# JCFLAGS = -I$(CAFEDIR)/Java/Include -I$(CAFEDIR)/Java/Include/win32
diff -r 17e9560465b0 js/src/config/WINNT6.0.mk
--- a/js/src/config/WINNT6.0.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,118 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config for Windows NT using MS Visual C++ (version?)
-#
-
-CC = cl
-CXX = cl
-
-RANLIB = echo
-
-PDBFILE = $(basename $(@F)).pdb
-
-#.c.o:
-#      $(CC) -c -MD $*.d $(CFLAGS) $<
-
-CPU_ARCH = x86 # XXX fixme
-GFX_ARCH = win32
-
-# MSVC compiler options for both debug/optimize
-# -nologo  - suppress copyright message
-# -W3      - Warning level 3
-# -Gm      - enable minimal rebuild
-# -Z7      - put debug info into the executable, not in .pdb file
-# -Zi      - put debug info into .pdb file
-# -YX      - automatic precompiled headers
-# -GX      - enable C++ exception support
-WIN_CFLAGS = -nologo -W3 
-
-# MSVC compiler options for debug builds linked to MSVCRTD.DLL
-# -MDd     - link with MSVCRTD.LIB (Dynamically-linked, multi-threaded, debug C-runtime)
-# -Od      - minimal optimization
-WIN_IDG_CFLAGS = -MDd -Od -Z7 
-
-# MSVC compiler options for debug builds linked to MSVCRT.DLL
-# -MD      - link with MSVCRT.LIB (Dynamically-linked, multi-threaded, debug C-runtime)
-# -Od      - minimal optimization
-WIN_DEBUG_CFLAGS = -MD -Od -Zi -Fd$(OBJDIR)/$(PDBFILE)
-
-# MSVC compiler options for release (optimized) builds
-# -MD      - link with MSVCRT.LIB (Dynamically-linked, multi-threaded, C-runtime)
-# -O2      - Optimize for speed
-# -G5      - Optimize for Pentium
-WIN_OPT_CFLAGS = -MD -O2
-
-ifdef BUILD_OPT
-OPTIMIZER = $(WIN_OPT_CFLAGS)
-else
-ifdef BUILD_IDG
-OPTIMIZER = $(WIN_IDG_CFLAGS)
-else
-OPTIMIZER = $(WIN_DEBUG_CFLAGS)
-endif
-endif
-
-OS_CFLAGS = -D_X86_=1 -DXP_WIN -DXP_WIN32 -DWIN32 -D_WINDOWS -D_WIN32 -DWINVER=0x500 -D_WIN32_WINNT=0x500 $(WIN_CFLAGS)
-JSDLL_CFLAGS = -DEXPORT_JS_API
-OS_LIBS = -lm -lc
-
-PREBUILT_CPUCFG = 1
-USE_MSVC = 1
-
-LIB_LINK_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\
- advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib oldnames.lib \
- winmm.lib \
- -nologo\
- -subsystem:windows -dll -debug -pdb:$(OBJDIR)/$(PDBFILE)\
- -machine:I386\
- -opt:ref -opt:noicf
-
-EXE_LINK_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\
- advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib oldnames.lib -nologo\
- -subsystem:console -debug -pdb:$(OBJDIR)/$(PDBFILE)\
- -machine:I386\
- -opt:ref -opt:noicf
-
-# CAFEDIR = t:/cafe
-# JCLASSPATH = $(CAFEDIR)/Java/Lib/classes.zip
-# JAVAC = $(CAFEDIR)/Bin/sj.exe
-# JAVAH = $(CAFEDIR)/Java/Bin/javah.exe
-# JCFLAGS = -I$(CAFEDIR)/Java/Include -I$(CAFEDIR)/Java/Include/win32
diff -r 17e9560465b0 js/src/config/autoconf.mk.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/autoconf.mk.in	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,354 @@
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is this file as it was released upon August 6, 1998.
+#
+# The Initial Developer of the Original Code is
+# Christopher Seawood.
+# Portions created by the Initial Developer are Copyright (C) 1998
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Benjamin Smedberg <benjamin@smedbergs.us>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+# A netscape style .mk file for autoconf builds
+
+INCLUDED_AUTOCONF_MK = 1
+USE_AUTOCONF 	= 1
+MOZILLA_CLIENT	= 1
+target          = @target@
+ac_configure_args = @ac_configure_args@
+BUILD_MODULES	= @BUILD_MODULES@
+MOZILLA_VERSION = @MOZILLA_VERSION@
+
+MOZ_BUILD_APP = @MOZ_BUILD_APP@
+MOZ_APP_NAME	= @MOZ_APP_NAME@
+MOZ_APP_DISPLAYNAME = @MOZ_APP_DISPLAYNAME@
+MOZ_APP_VERSION = @MOZ_APP_VERSION@
+
+MOZ_PKG_SPECIAL = @MOZ_PKG_SPECIAL@
+
+prefix		= @prefix@
+exec_prefix	= @exec_prefix@
+bindir		= @bindir@
+includedir	= @includedir@
+libdir		= @libdir@
+datadir		= @datadir@
+mandir		= @mandir@
+
+installdir	= $(libdir)/$(MOZ_APP_NAME)-$(MOZ_APP_VERSION)
+sdkdir		= $(libdir)/$(MOZ_APP_NAME)-devel-$(MOZ_APP_VERSION)
+
+DIST		= $(DEPTH)/dist
+
+MOZ_JS_LIBS		   = @MOZ_JS_LIBS@
+
+MOZ_SYNC_BUILD_FILES = @MOZ_SYNC_BUILD_FILES@
+
+MOZ_DEBUG	= @MOZ_DEBUG@
+MOZ_DEBUG_MODULES = @MOZ_DEBUG_MODULES@
+MOZ_PROFILE_MODULES = @MOZ_PROFILE_MODULES@
+MOZ_DEBUG_ENABLE_DEFS		= @MOZ_DEBUG_ENABLE_DEFS@
+MOZ_DEBUG_DISABLE_DEFS	= @MOZ_DEBUG_DISABLE_DEFS@
+MOZ_DEBUG_FLAGS	= @MOZ_DEBUG_FLAGS@
+MOZ_DEBUG_LDFLAGS=@MOZ_DEBUG_LDFLAGS@
+MOZ_DBGRINFO_MODULES	= @MOZ_DBGRINFO_MODULES@
+MOZ_EXTENSIONS  = @MOZ_EXTENSIONS@
+MOZ_IMG_DECODERS= @MOZ_IMG_DECODERS@
+MOZ_IMG_ENCODERS= @MOZ_IMG_ENCODERS@
+MOZ_JSDEBUGGER  = @MOZ_JSDEBUGGER@
+MOZ_PERF_METRICS = @MOZ_PERF_METRICS@
+MOZ_LEAKY	= @MOZ_LEAKY@
+MOZ_MEMORY      = @MOZ_MEMORY@
+MOZ_JPROF       = @MOZ_JPROF@
+MOZ_SHARK       = @MOZ_SHARK@
+MOZ_CALLGRIND   = @MOZ_CALLGRIND@
+MOZ_VTUNE       = @MOZ_VTUNE@
+DEHYDRA_PATH    = @DEHYDRA_PATH@
+
+ENABLE_EAZEL_PROFILER=@ENABLE_EAZEL_PROFILER@
+EAZEL_PROFILER_CFLAGS=@EAZEL_PROFILER_CFLAGS@
+EAZEL_PROFILER_LIBS=@EAZEL_PROFILER_LIBS@
+GC_LEAK_DETECTOR = @GC_LEAK_DETECTOR@
+NS_TRACE_MALLOC = @NS_TRACE_MALLOC@
+USE_ELF_DYNSTR_GC = @USE_ELF_DYNSTR_GC@
+INCREMENTAL_LINKER = @INCREMENTAL_LINKER@
+MACOSX_DEPLOYMENT_TARGET = @MACOSX_DEPLOYMENT_TARGET@
+BUILD_STATIC_LIBS = @BUILD_STATIC_LIBS@
+ENABLE_TESTS	= @ENABLE_TESTS@
+JS_ULTRASPARC_OPTS = @JS_ULTRASPARC_OPTS@
+JS_STATIC_BUILD = @JS_STATIC_BUILD@
+
+TAR=@TAR@
+
+# The MOZ_UI_LOCALE var is used to build a particular locale. Do *not*
+# use the var to change any binary files. Do *not* use this var unless you
+# write rules for the "clean-locale" and "locale" targets.
+MOZ_UI_LOCALE = @MOZ_UI_LOCALE@
+
+MOZ_COMPONENTS_VERSION_SCRIPT_LDFLAGS = @MOZ_COMPONENTS_VERSION_SCRIPT_LDFLAGS@
+MOZ_COMPONENT_NSPR_LIBS=@MOZ_COMPONENT_NSPR_LIBS@
+
+MOZ_FIX_LINK_PATHS=@MOZ_FIX_LINK_PATHS@
+
+XPCOM_FROZEN_LDOPTS=@XPCOM_FROZEN_LDOPTS@
+XPCOM_LIBS=@XPCOM_LIBS@
+MOZ_TIMELINE=@MOZ_TIMELINE@
+
+ENABLE_STRIP	= @ENABLE_STRIP@
+PKG_SKIP_STRIP	= @PKG_SKIP_STRIP@
+
+MOZ_POST_DSO_LIB_COMMAND = @MOZ_POST_DSO_LIB_COMMAND@
+MOZ_POST_PROGRAM_COMMAND = @MOZ_POST_PROGRAM_COMMAND@
+
+MOZ_BUILD_ROOT             = @MOZ_BUILD_ROOT@
+
+MOZ_INSURE = @MOZ_INSURE@
+MOZ_INSURIFYING = @MOZ_INSURIFYING@
+MOZ_INSURE_DIRS = @MOZ_INSURE_DIRS@
+MOZ_INSURE_EXCLUDE_DIRS = @MOZ_INSURE_EXCLUDE_DIRS@
+
+MOZ_NATIVE_NSPR = @MOZ_NATIVE_NSPR@
+
+CROSS_COMPILE   = @CROSS_COMPILE@
+
+WCHAR_CFLAGS	= @WCHAR_CFLAGS@
+
+OS_CPPFLAGS	= @CPPFLAGS@
+OS_CFLAGS	= $(OS_CPPFLAGS) @CFLAGS@
+OS_CXXFLAGS	= $(OS_CPPFLAGS) @CXXFLAGS@
+OS_LDFLAGS	= @LDFLAGS@
+
+OS_COMPILE_CFLAGS = $(OS_CPPFLAGS) @COMPILE_CFLAGS@
+OS_COMPILE_CXXFLAGS = $(OS_CPPFLAGS) @COMPILE_CXXFLAGS@
+
+OS_INCLUDES	= $(NSPR_CFLAGS)
+OS_LIBS		= @LIBS@
+ACDEFINES	= @MOZ_DEFINES@
+
+WARNINGS_AS_ERRORS = @WARNINGS_AS_ERRORS@
+
+MOZ_OPTIMIZE	= @MOZ_OPTIMIZE@
+MOZ_OPTIMIZE_FLAGS = @MOZ_OPTIMIZE_FLAGS@
+MOZ_OPTIMIZE_LDFLAGS = @MOZ_OPTIMIZE_LDFLAGS@
+MOZ_OPTIMIZE_SIZE_TWEAK = @MOZ_OPTIMIZE_SIZE_TWEAK@
+
+MOZ_RTTI_FLAGS_ON = @_MOZ_RTTI_FLAGS_ON@
+
+MOZ_PROFILE_GUIDED_OPTIMIZE_DISABLE = @MOZ_PROFILE_GUIDED_OPTIMIZE_DISABLE@
+PROFILE_GEN_CFLAGS = @PROFILE_GEN_CFLAGS@
+PROFILE_GEN_LDFLAGS = @PROFILE_GEN_LDFLAGS@
+PROFILE_USE_CFLAGS = @PROFILE_USE_CFLAGS@
+PROFILE_USE_LDFLAGS = @PROFILE_USE_LDFLAGS@
+
+WIN_TOP_SRC	= @WIN_TOP_SRC@
+CYGWIN_WRAPPER	= @CYGWIN_WRAPPER@
+AS_PERL         = @AS_PERL@
+CYGDRIVE_MOUNT	= @CYGDRIVE_MOUNT@
+AR		= @AR@
+AR_FLAGS	= @AR_FLAGS@
+AR_EXTRACT	= @AR_EXTRACT@
+AR_LIST		= @AR_LIST@
+AR_DELETE	= @AR_DELETE@
+AS		= @AS@
+ASFLAGS		= @ASFLAGS@
+AS_DASH_C_FLAG	= @AS_DASH_C_FLAG@
+LD		= @LD@
+RC		= @RC@
+RCFLAGS		= @RCFLAGS@
+WINDRES		= @WINDRES@
+USE_SHORT_LIBNAME = @USE_SHORT_LIBNAME@
+IMPLIB		= @IMPLIB@
+FILTER		= @FILTER@
+BIN_FLAGS	= @BIN_FLAGS@
+MIDL		= @MIDL@
+MIDL_FLAGS	= @MIDL_FLAGS@
+_MSC_VER	= @_MSC_VER@
+
+DLL_PREFIX	= @DLL_PREFIX@
+LIB_PREFIX	= @LIB_PREFIX@
+OBJ_SUFFIX	= @OBJ_SUFFIX@
+LIB_SUFFIX	= @LIB_SUFFIX@
+DLL_SUFFIX	= @DLL_SUFFIX@
+BIN_SUFFIX	= @BIN_SUFFIX@
+ASM_SUFFIX	= @ASM_SUFFIX@
+IMPORT_LIB_SUFFIX = @IMPORT_LIB_SUFFIX@
+USE_N32		= @USE_N32@
+HAVE_64BIT_OS	= @HAVE_64BIT_OS@
+
+# Temp hack.  It is not my intention to leave this crap in here for ever.
+# Im talking to fur right now to solve the problem without introducing 
+# NS_USE_NATIVE to the build system -ramiro.
+NS_USE_NATIVE = @NS_USE_NATIVE@
+
+CC		    = @CC@
+CXX		    = @CXX@
+
+CC_VERSION	= @CC_VERSION@
+CXX_VERSION	= @CXX_VERSION@
+
+GNU_AS		= @GNU_AS@
+GNU_LD		= @GNU_LD@
+GNU_CC		= @GNU_CC@
+GNU_CXX		= @GNU_CXX@
+HAVE_GCC3_ABI	= @HAVE_GCC3_ABI@
+INTEL_CC	= @INTEL_CC@
+INTEL_CXX	= @INTEL_CXX@
+
+HOST_CC		= @HOST_CC@
+HOST_CXX	= @HOST_CXX@
+HOST_CFLAGS	= @HOST_CFLAGS@
+HOST_CXXFLAGS	= @HOST_CXXFLAGS@
+HOST_OPTIMIZE_FLAGS = @HOST_OPTIMIZE_FLAGS@
+HOST_NSPR_MDCPUCFG = @HOST_NSPR_MDCPUCFG@
+HOST_AR		= @HOST_AR@
+HOST_AR_FLAGS	= @HOST_AR_FLAGS@
+HOST_LD		= @HOST_LD@
+HOST_RANLIB	= @HOST_RANLIB@
+HOST_BIN_SUFFIX	= @HOST_BIN_SUFFIX@
+
+HOST_OS_ARCH	= @HOST_OS_ARCH@
+host_cpu	= @host_cpu@
+host_vendor	= @host_vendor@
+host_os		= @host_os@
+
+TARGET_NSPR_MDCPUCFG = @TARGET_NSPR_MDCPUCFG@
+TARGET_CPU	= @TARGET_CPU@
+TARGET_VENDOR	= @TARGET_VENDOR@
+TARGET_OS	= @TARGET_OS@
+TARGET_MD_ARCH	= @TARGET_MD_ARCH@
+TARGET_XPCOM_ABI = @TARGET_XPCOM_ABI@
+
+AUTOCONF	= @AUTOCONF@
+PERL		= @PERL@
+PYTHON		= @PYTHON@
+RANLIB		= @RANLIB@
+WHOAMI		= @WHOAMI@
+UNZIP		= @UNZIP@
+ZIP		= @ZIP@
+XARGS		= @XARGS@
+STRIP		= @STRIP@
+DOXYGEN		= @DOXYGEN@
+MAKE		= @MAKE@
+PBBUILD_BIN	= @PBBUILD@
+SDP		= @SDP@
+NSINSTALL_BIN	= @NSINSTALL_BIN@
+
+NSPR_CONFIG	= @NSPR_CONFIG@
+NSPR_CFLAGS	= @NSPR_CFLAGS@
+NSPR_LIBS	= @NSPR_LIBS@
+
+USE_DEPENDENT_LIBS = @USE_DEPENDENT_LIBS@
+
+# MKSHLIB_FORCE_ALL is used to force the linker to include all object
+# files present in an archive. MKSHLIB_UNFORCE_ALL reverts the linker
+# to normal behavior. Makefile's that create shared libraries out of
+# archives use these flags to force in all of the .o files in the
+# archives into the shared library.
+WRAP_MALLOC_LIB         = @WRAP_MALLOC_LIB@
+WRAP_MALLOC_CFLAGS      = @WRAP_MALLOC_CFLAGS@
+DSO_CFLAGS              = @DSO_CFLAGS@
+DSO_PIC_CFLAGS          = @DSO_PIC_CFLAGS@
+MKSHLIB                 = @MKSHLIB@
+MKCSHLIB                = @MKCSHLIB@
+MKSHLIB_FORCE_ALL       = @MKSHLIB_FORCE_ALL@
+MKSHLIB_UNFORCE_ALL     = @MKSHLIB_UNFORCE_ALL@
+DSO_LDOPTS              = @DSO_LDOPTS@
+DLL_SUFFIX              = @DLL_SUFFIX@
+
+NO_LD_ARCHIVE_FLAGS     = @NO_LD_ARCHIVE_FLAGS@
+
+MOZ_TOOLKIT_REGISTRY_CFLAGS = \
+	$(TK_CFLAGS)
+
+GLIB_CFLAGS	= @GLIB_CFLAGS@
+GLIB_LIBS	= @GLIB_LIBS@
+GLIB_GMODULE_LIBS	= @GLIB_GMODULE_LIBS@
+
+MOZ_NATIVE_MAKEDEPEND	= @SYSTEM_MAKEDEPEND@
+
+# Used for LD_LIBRARY_PATH
+LIBS_PATH       = @LIBS_PATH@
+
+MOZ_AUTO_DEPS	= @MOZ_AUTO_DEPS@
+COMPILER_DEPEND = @COMPILER_DEPEND@
+MDDEPDIR        := @MDDEPDIR@
+
+MOZ_DEMANGLE_SYMBOLS = @MOZ_DEMANGLE_SYMBOLS@
+
+# XXX - these need to be cleaned up and have real checks added -cls
+CM_BLDTYPE=dbg
+AWT_11=1
+MOZ_BITS=32
+OS_TARGET=@OS_TARGET@
+OS_ARCH=@OS_ARCH@
+OS_RELEASE=@OS_RELEASE@
+OS_TEST=@OS_TEST@
+
+TARGET_DEVICE = @TARGET_DEVICE@
+
+# For AIX build
+AIX_OBJMODEL = @AIX_OBJMODEL@
+
+# For OS/2 build
+MOZ_OS2_TOOLS = @MOZ_OS2_TOOLS@
+MOZ_OS2_USE_DECLSPEC = @MOZ_OS2_USE_DECLSPEC@
+MOZ_OS2_HIGH_MEMORY = @MOZ_OS2_HIGH_MEMORY@
+
+MOZILLA_OFFICIAL = @MOZILLA_OFFICIAL@
+BUILD_OFFICIAL = @BUILD_OFFICIAL@
+MOZ_MILESTONE_RELEASE = @MOZ_MILESTONE_RELEASE@
+
+# Win32 options
+MOZ_PROFILE	= @MOZ_PROFILE@
+MOZ_BROWSE_INFO	= @MOZ_BROWSE_INFO@
+MOZ_TOOLS_DIR	= @MOZ_TOOLS_DIR@
+MOZ_DEBUG_SYMBOLS = @MOZ_DEBUG_SYMBOLS@
+MOZ_QUANTIFY	= @MOZ_QUANTIFY@
+MSMANIFEST_TOOL = @MSMANIFEST_TOOL@
+WIN32_REDIST_DIR = @WIN32_REDIST_DIR@
+WIN32_CRT_SRC_DIR = @WIN32_CRT_SRC_DIR@
+WIN32_CUSTOM_CRT_DIR = @WIN32_CUSTOM_CRT_DIR@
+
+# Codesighs tools option, enables win32 mapfiles.
+MOZ_MAPINFO	= @MOZ_MAPINFO@
+
+WINCE		= @WINCE@
+
+MACOS_SDK_DIR	= @MACOS_SDK_DIR@
+NEXT_ROOT	= @NEXT_ROOT@
+GCC_VERSION	= @GCC_VERSION@
+XCODEBUILD_VERSION= @XCODEBUILD_VERSION@
+HAS_XCODE_2_1	= @HAS_XCODE_2_1@
+UNIVERSAL_BINARY= @UNIVERSAL_BINARY@
+HAVE_DTRACE= @HAVE_DTRACE@
+
+VISIBILITY_FLAGS = @VISIBILITY_FLAGS@
+WRAP_SYSTEM_INCLUDES = @WRAP_SYSTEM_INCLUDES@
+
+HAVE_ARM_SIMD= @HAVE_ARM_SIMD@
diff -r 17e9560465b0 js/src/config/check-sync-dirs.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/check-sync-dirs.py	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,108 @@
+# check-sync-dirs.py --- check that one directory is an exact subset of another
+#
+# Usage: python check-sync-dirs.py COPY ORIGINAL
+#
+# Check that the files present in the directory tree COPY are exact
+# copies of their counterparts in the directory tree ORIGINAL.  COPY
+# need not have all the files in ORIGINAL, but COPY may not have files
+# absent from ORIGINAL.
+# 
+# Each directory in COPY may have a file named
+# 'check-sync-exceptions', which lists files in COPY that need not be
+# the same as the corresponding file in ORIGINAL, or exist at all in
+# ORIGINAL.  (The 'check-sync-exceptions' file itself is always
+# treated as exceptional.)  Blank lines and '#' comments in the file
+# are ignored.
+
+import sys
+import os
+from os.path import join
+import filecmp
+import textwrap
+import fnmatch
+
+if len(sys.argv) != 3:
+    print >> sys.stderr, "Usage: %s COPY ORIGINAL" % sys.argv[0]
+    sys.exit(1)
+
+copy = sys.argv[1]
+original = sys.argv[2]
+
+# Ignore detritus left lying around by editing tools.
+ignored_patterns = ['*~', '.#*', '#*#', '*.orig', '*.rej']
+
+# Return the contents of FILENAME, a 'check-sync-exceptions' file, as
+# a dictionary whose keys are exactly the list of filenames, along
+# with the basename of FILENAME itself.  If FILENAME does not exist,
+# return the empty dictionary.
+def read_exceptions(filename):
+    if (os.path.exists(filename)):
+        f = file(filename)
+        exceptions={}
+        for line in f:
+            line = line.strip()
+            if line != '' and line[0] != '#':
+                exceptions[line] = None
+        exceptions[os.path.basename (filename)] = None
+        f.close()
+        return exceptions
+    else:
+        return {}
+
+# Return true if FILENAME matches any pattern in the list of filename
+# patterns PATTERNS.
+def fnmatch_any(filename, patterns):
+    for pattern in patterns:
+        if fnmatch.fnmatch(filename, pattern):
+            return True
+    return False
+
+# Check the contents of the directory tree COPY against ORIGINAL.  For each
+# file that differs, apply REPORT to COPY, ORIGINAL, and the file's
+# relative path.  COPY and ORIGINAL should be absolute.  Ignore files 
+# that match patterns given in the list IGNORE.
+def check(copy, original, ignore, report):
+    os.chdir(copy)
+    for (dirpath, dirnames, filenames) in os.walk('.'):
+        exceptions = read_exceptions(join(dirpath, 'check-sync-exceptions'))
+        for filename in filenames:
+            if filename in exceptions:
+                continue
+            if fnmatch_any(filename, ignore):
+                continue
+            relative_name = join(dirpath, filename)
+            original_name = join(original, relative_name)
+            if (os.path.exists(original_name)
+                and filecmp.cmp(relative_name, original_name)):
+                continue
+            report(copy, original, relative_name)
+
+
+differences_found = False
+
+# Print an error message for DIFFERING, which was found to differ
+# between COPY and ORIGINAL.  Set the global variable differences_found.
+def report(copy, original, differing):
+    global differences_found
+    if not differences_found:
+        print >> sys.stderr, "TEST-FAIL | build file copies are not in sync"
+        print >> sys.stderr, "file(s) found in:               %s" % (copy)
+        print >> sys.stderr, ("differ from their originals in: %s"
+                              % (original))
+    print >> sys.stderr, "file differs: %s" % (differing)
+    differences_found = True
+
+check(os.path.abspath(copy),
+      os.path.abspath(original),
+      ignored_patterns,
+      report)
+
+if differences_found:
+    msg=('''In general, the files in '%s' should always be exact copies of
+originals in '%s'.  A change made to one should also be made to the
+other.  See 'check-sync-dirs.py' for more details.'''
+         % (copy, original))
+    print >> sys.stderr, textwrap.fill(msg, 75)
+    sys.exit(1)
+
+sys.exit(0)
diff -r 17e9560465b0 js/src/config/check-sync-exceptions
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/check-sync-exceptions	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,6 @@
+Makefile.in
+autoconf.mk.in
+check-sync-dirs.py
+
+# This is a copy of nspr's config/make-system-wrappers.pl.
+make-system-wrappers.pl
diff -r 17e9560465b0 js/src/config/config.mk
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/config.mk	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,884 @@
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+# Netscape Communications Corporation.
+# Portions created by the Initial Developer are Copyright (C) 1998
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Benjamin Smedberg <benjamin@smedbergs.us>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+#
+# config.mk
+#
+# Determines the platform and builds the macros needed to load the
+# appropriate platform-specific .mk file, then defines all (most?)
+# of the generic macros.
+#
+
+# Define an include-at-most-once flag
+INCLUDED_CONFIG_MK = 1
+
+EXIT_ON_ERROR = set -e; # Shell loops continue past errors without this.
+
+ifndef topsrcdir
+topsrcdir	= $(DEPTH)
+endif
+
+ifndef INCLUDED_AUTOCONF_MK
+include $(DEPTH)/config/autoconf.mk
+endif
+ifndef INCLUDED_INSURE_MK
+ifdef MOZ_INSURIFYING
+include $(topsrcdir)/config/insure.mk
+endif
+endif
+
+COMMA = ,
+
+# Sanity check some variables
+CHECK_VARS := \
+ XPI_NAME \
+ LIBRARY_NAME \
+ MODULE \
+ DEPTH \
+ SHORT_LIBNAME \
+ XPI_PKGNAME \
+ INSTALL_EXTENSION_ID \
+ $(NULL)
+
+# checks for internal spaces or trailing spaces in the variable
+# named by $x
+check-variable = $(if $(filter-out 0 1,$(words $($(x))z)),$(error Spaces are not allowed in $(x)))
+
+$(foreach x,$(CHECK_VARS),$(check-variable))
+
+# FINAL_TARGET specifies the location into which we copy end-user-shipped
+# build products (typelibs, components, chrome).
+#
+# It will usually be the well-loved $(DIST)/bin, today, but can also be an
+# XPI-contents staging directory for ambitious and right-thinking extensions.
+FINAL_TARGET = $(if $(XPI_NAME),$(DIST)/xpi-stage/$(XPI_NAME),$(DIST)/bin)
+
+# MAKE_JARS_TARGET is a staging area for make-jars.pl.  When packaging in
+# the jar format, make-jars leaves behind a directory structure that's not
+# needed in $(FINAL_TARGET).  For both, flat, and symlink, the directory
+# structure contains the chrome, so leave it in $(FINAL_TARGET).
+ifeq (jar,$(MOZ_CHROME_FILE_FORMAT))
+MAKE_JARS_TARGET = $(if $(XPI_NAME),$(FINAL_TARGET).stage,$(DIST)/chrome-stage)
+else
+MAKE_JARS_TARGET = $(FINAL_TARGET)
+endif
+
+#
+# The VERSION_NUMBER is suffixed onto the end of the DLLs we ship.
+# Since the longest of these is 5 characters without the suffix,
+# be sure to not set VERSION_NUMBER to anything longer than 3 
+# characters for Win16's sake.
+#
+VERSION_NUMBER		= 50
+
+ifeq ($(HOST_OS_ARCH),WINNT)
+win_srcdir	:= $(subst $(topsrcdir),$(WIN_TOP_SRC),$(srcdir))
+BUILD_TOOLS	= $(WIN_TOP_SRC)/build/unix
+else
+win_srcdir	:= $(srcdir)
+BUILD_TOOLS	= $(topsrcdir)/build/unix
+endif
+
+CONFIG_TOOLS	= $(MOZ_BUILD_ROOT)/config
+AUTOCONF_TOOLS	= $(topsrcdir)/build/autoconf
+
+ifeq ($(OS_ARCH),QNX)
+ifeq ($(OS_TARGET),NTO)
+LD		:= qcc -Vgcc_ntox86 -nostdlib
+else
+LD		:= $(CC)
+endif
+endif
+ifeq ($(OS_ARCH),BeOS)
+BEOS_ADDON_WORKAROUND	= 1
+endif
+
+#
+# Strip off the excessively long version numbers on these platforms,
+# but save the version to allow multiple versions of the same base
+# platform to be built in the same tree.
+#
+ifneq (,$(filter FreeBSD HP-UX IRIX Linux NetBSD OpenBSD OSF1 SunOS,$(OS_ARCH)))
+OS_RELEASE	:= $(basename $(OS_RELEASE))
+
+# Allow the user to ignore the OS_VERSION, which is usually irrelevant.
+ifdef WANT_MOZILLA_CONFIG_OS_VERSION
+OS_VERS		:= $(suffix $(OS_RELEASE))
+OS_VERSION	:= $(shell echo $(OS_VERS) | sed 's/-.*//')
+endif
+
+endif
+
+OS_CONFIG	:= $(OS_ARCH)$(OS_RELEASE)
+
+FINAL_LINK_LIBS = $(DEPTH)/config/final-link-libs
+FINAL_LINK_COMPS = $(DEPTH)/config/final-link-comps
+FINAL_LINK_COMP_NAMES = $(DEPTH)/config/final-link-comp-names
+
+MOZ_UNICHARUTIL_LIBS = $(LIBXUL_DIST)/lib/$(LIB_PREFIX)unicharutil_s.$(LIB_SUFFIX)
+MOZ_WIDGET_SUPPORT_LIBS    = $(DIST)/lib/$(LIB_PREFIX)widgetsupport_s.$(LIB_SUFFIX)
+
+ifdef MOZ_MEMORY
+ifneq ($(OS_ARCH),WINNT)
+JEMALLOC_LIBS = $(MKSHLIB_FORCE_ALL) $(call EXPAND_LIBNAME,jemalloc) $(MKSHLIB_UNFORCE_ALL)
+endif
+endif
+
+# determine debug-related options
+_DEBUG_CFLAGS :=
+_DEBUG_LDFLAGS :=
+
+ifndef MOZ_DEBUG
+  # global debugging is disabled 
+  # check if it was explicitly enabled for this module
+  ifneq (, $(findstring $(MODULE), $(MOZ_DEBUG_MODULES)))
+    MOZ_DEBUG:=1
+  endif
+else
+  # global debugging is enabled
+  # check if it was explicitly disabled for this module
+  ifneq (, $(findstring ^$(MODULE), $(MOZ_DEBUG_MODULES)))
+    MOZ_DEBUG:=
+  endif
+endif
+
+ifdef MOZ_DEBUG
+  _DEBUG_CFLAGS += $(MOZ_DEBUG_ENABLE_DEFS)
+  XULPPFLAGS += $(MOZ_DEBUG_ENABLE_DEFS)
+else
+  _DEBUG_CFLAGS += $(MOZ_DEBUG_DISABLE_DEFS)
+  XULPPFLAGS += $(MOZ_DEBUG_DISABLE_DEFS)
+endif
+
+# determine if -g should be passed to the compiler, based on
+# the current module, and the value of MOZ_DBGRINFO_MODULES
+
+ifdef MOZ_DEBUG
+  MOZ_DBGRINFO_MODULES += ALL_MODULES
+  pattern := ALL_MODULES ^ALL_MODULES
+else
+  MOZ_DBGRINFO_MODULES += ^ALL_MODULES
+  pattern := ALL_MODULES ^ALL_MODULES
+endif
+
+ifdef MODULE
+  # our current Makefile specifies a module name - add it to our pattern
+  pattern += $(MODULE) ^$(MODULE)
+endif
+
+# start by finding the first relevant module name 
+# (remember that the order of the module names in MOZ_DBGRINFO_MODULES 
+# is reversed from the order the user specified to configure - 
+# this allows the user to put general names at the beginning
+# of the list, and to override them with explicit module names later 
+# in the list)
+
+first_match:=$(firstword $(filter $(pattern), $(MOZ_DBGRINFO_MODULES)))
+
+ifeq ($(first_match), $(MODULE))
+  # the user specified explicitly that 
+  # this module should be compiled with -g
+  _DEBUG_CFLAGS += $(MOZ_DEBUG_FLAGS)
+  _DEBUG_LDFLAGS += $(MOZ_DEBUG_LDFLAGS)
+else
+  ifeq ($(first_match), ^$(MODULE))
+    # the user specified explicitly that this module 
+    # should not be compiled with -g (nothing to do)
+  else
+    ifeq ($(first_match), ALL_MODULES)
+      # the user didn't mention this module explicitly, 
+      # but wanted all modules to be compiled with -g
+      _DEBUG_CFLAGS += $(MOZ_DEBUG_FLAGS)
+      _DEBUG_LDFLAGS += $(MOZ_DEBUG_LDFLAGS)      
+    else
+      ifeq ($(first_match), ^ALL_MODULES)
+        # the user didn't mention this module explicitly, 
+        # but wanted all modules to be compiled without -g (nothing to do)
+      endif
+    endif
+  endif
+endif
+
+
+# append debug flags 
+# (these might have been above when processing MOZ_DBGRINFO_MODULES)
+OS_CFLAGS += $(_DEBUG_CFLAGS)
+OS_CXXFLAGS += $(_DEBUG_CFLAGS)
+OS_LDFLAGS += $(_DEBUG_LDFLAGS)
+
+# MOZ_PROFILE equivs for win32
+ifeq ($(OS_ARCH)_$(GNU_CC),WINNT_)
+ifdef MOZ_DEBUG
+ifneq (,$(MOZ_BROWSE_INFO)$(MOZ_BSCFILE))
+OS_CFLAGS += -FR
+OS_CXXFLAGS += -FR
+endif
+else # ! MOZ_DEBUG
+
+# MOZ_DEBUG_SYMBOLS generates debug symbols in separate PDB files.
+# Used for generating an optimized build with debugging symbols.
+# Used in the Windows nightlies to generate symbols for crash reporting.
+ifdef MOZ_DEBUG_SYMBOLS
+OS_CXXFLAGS += -Zi -UDEBUG -DNDEBUG
+OS_CFLAGS += -Zi -UDEBUG -DNDEBUG
+OS_LDFLAGS += -DEBUG -OPT:REF -OPT:nowin98
+endif
+
+ifdef MOZ_QUANTIFY
+# -FIXED:NO is needed for Quantify to work, but it increases the size
+# of executables, so only use it if building for Quantify.
+WIN32_EXE_LDFLAGS += -FIXED:NO
+
+# We need -OPT:NOICF to prevent identical methods from being merged together.
+# Otherwise, Quantify doesn't know which method was actually called when it's
+# showing you the profile.
+OS_LDFLAGS += -OPT:NOICF
+endif
+
+#
+# Handle trace-malloc in optimized builds.
+# No opt to give sane callstacks.
+#
+ifdef NS_TRACE_MALLOC
+MOZ_OPTIMIZE_FLAGS=-Zi -Od -UDEBUG -DNDEBUG
+OS_LDFLAGS = -DEBUG -PDB:NONE -OPT:REF -OPT:nowin98
+endif # NS_TRACE_MALLOC
+
+endif # MOZ_DEBUG
+endif # WINNT && !GNU_CC
+
+#
+# Build using PIC by default
+# Do not use PIC if not building a shared lib (see exceptions below)
+#
+
+ifndef BUILD_STATIC_LIBS
+_ENABLE_PIC=1
+endif
+ifneq (,$(FORCE_SHARED_LIB)$(FORCE_USE_PIC))
+_ENABLE_PIC=1
+endif
+
+# In Firefox, all components are linked into either libxul or the static
+# meta-component, and should be compiled with PIC.
+ifdef MOZ_META_COMPONENT
+_ENABLE_PIC=1
+endif
+
+# If module is going to be merged into the nsStaticModule, 
+# make sure that the entry points are translated and 
+# the module is built static.
+
+ifdef IS_COMPONENT
+ifdef EXPORT_LIBRARY
+ifneq (,$(BUILD_STATIC_LIBS))
+ifdef MODULE_NAME
+DEFINES += -DXPCOM_TRANSLATE_NSGM_ENTRY_POINT=1
+FORCE_STATIC_LIB=1
+endif
+endif
+endif
+endif
+
+# Determine if module being compiled is destined 
+# to be merged into libxul
+
+ifdef MOZ_ENABLE_LIBXUL
+ifdef LIBXUL_LIBRARY
+ifdef IS_COMPONENT
+ifdef MODULE_NAME
+DEFINES += -DXPCOM_TRANSLATE_NSGM_ENTRY_POINT=1
+else
+$(error Component makefile does not specify MODULE_NAME.)
+endif
+endif
+FORCE_STATIC_LIB=1
+_ENABLE_PIC=1
+SHORT_LIBNAME=
+endif
+endif
+
+# If we are building this component into an extension/xulapp, it cannot be
+# statically linked. In the future we may want to add a xulapp meta-component
+# build option.
+
+ifdef XPI_NAME
+_ENABLE_PIC=1
+ifdef IS_COMPONENT
+EXPORT_LIBRARY=
+FORCE_STATIC_LIB=
+FORCE_SHARED_LIB=1
+endif
+endif
+
+#
+# Disable PIC if necessary
+#
+
+ifndef _ENABLE_PIC
+DSO_CFLAGS=
+ifeq ($(OS_ARCH)_$(HAVE_GCC3_ABI),Darwin_1)
+DSO_PIC_CFLAGS=-mdynamic-no-pic
+else
+DSO_PIC_CFLAGS=
+endif
+endif
+
+# This comes from configure
+ifdef MOZ_PROFILE_GUIDED_OPTIMIZE_DISABLE
+NO_PROFILE_GUIDED_OPTIMIZE = 1
+endif
+
+# Enable profile-based feedback
+ifndef NO_PROFILE_GUIDED_OPTIMIZE
+ifdef MOZ_PROFILE_GENERATE
+# No sense in profiling tools
+ifndef INTERNAL_TOOLS
+OS_CFLAGS += $(PROFILE_GEN_CFLAGS)
+OS_CXXFLAGS += $(PROFILE_GEN_CFLAGS)
+OS_LDFLAGS += $(PROFILE_GEN_LDFLAGS)
+ifeq (WINNT,$(OS_ARCH))
+AR_FLAGS += -LTCG
+endif
+endif # INTERNAL_TOOLS
+endif # MOZ_PROFILE_GENERATE
+
+ifdef MOZ_PROFILE_USE
+ifndef INTERNAL_TOOLS
+OS_CFLAGS += $(PROFILE_USE_CFLAGS)
+OS_CXXFLAGS += $(PROFILE_USE_CFLAGS)
+OS_LDFLAGS += $(PROFILE_USE_LDFLAGS)
+ifeq (WINNT,$(OS_ARCH))
+AR_FLAGS += -LTCG
+endif
+endif # INTERNAL_TOOLS
+endif # MOZ_PROFILE_USE
+endif # NO_PROFILE_GUIDED_OPTIMIZE
+
+
+# Does the makefile specifies the internal XPCOM API linkage?
+ifneq (,$(MOZILLA_INTERNAL_API)$(LIBXUL_LIBRARY))
+DEFINES += -DMOZILLA_INTERNAL_API
+endif
+
+# Force XPCOM/widget/gfx methods to be _declspec(dllexport) when we're
+# building libxul libraries
+ifdef MOZ_ENABLE_LIBXUL
+ifdef LIBXUL_LIBRARY
+DEFINES += \
+		-D_IMPL_NS_COM \
+		-DEXPORT_XPT_API \
+		-DEXPORT_XPTC_API \
+		-D_IMPL_NS_COM_OBSOLETE \
+		-D_IMPL_NS_GFX \
+		-D_IMPL_NS_WIDGET \
+		-DIMPL_XREAPI \
+		-DIMPL_NS_NET \
+		-DIMPL_THEBES \
+		$(NULL)
+
+ifndef MOZ_NATIVE_ZLIB
+DEFINES += -DZLIB_INTERNAL
+endif
+endif
+endif
+
+# Force _all_ exported methods to be |_declspec(dllexport)| when we're
+# building them into the executable.
+
+ifeq (,$(filter-out WINNT WINCE OS2, $(OS_ARCH)))
+ifdef BUILD_STATIC_LIBS
+DEFINES += \
+        -D_IMPL_NS_GFX \
+        -D_IMPL_NS_MSG_BASE \
+        -D_IMPL_NS_WIDGET \
+        $(NULL)
+endif
+endif
+
+# Flags passed to make-jars.pl
+
+MAKE_JARS_FLAGS = \
+	-t $(topsrcdir) \
+	-f $(MOZ_CHROME_FILE_FORMAT) \
+	$(NULL)
+
+ifdef USE_EXTENSION_MANIFEST
+MAKE_JARS_FLAGS += -e
+endif
+
+ifdef BOTH_MANIFESTS
+MAKE_JARS_FLAGS += --both-manifests
+endif
+
+TAR_CREATE_FLAGS = -cvhf
+
+ifeq ($(OS_ARCH),BSD_OS)
+TAR_CREATE_FLAGS = -cvLf
+endif
+
+ifeq ($(OS_ARCH),OS2)
+TAR_CREATE_FLAGS = -cvf
+endif
+
+#
+# Personal makefile customizations go in these optional make include files.
+#
+MY_CONFIG	:= $(DEPTH)/config/myconfig.mk
+MY_RULES	:= $(DEPTH)/config/myrules.mk
+
+#
+# Default command macros; can be overridden in <arch>.mk.
+#
+CCC		= $(CXX)
+NFSPWD		= $(CONFIG_TOOLS)/nfspwd
+PURIFY		= purify $(PURIFYOPTIONS)
+QUANTIFY	= quantify $(QUANTIFYOPTIONS)
+ifdef CROSS_COMPILE
+XPIDL_COMPILE 	= $(CYGWIN_WRAPPER) $(LIBXUL_DIST)/host/bin/host_xpidl$(HOST_BIN_SUFFIX)
+XPIDL_LINK	= $(CYGWIN_WRAPPER) $(LIBXUL_DIST)/host/bin/host_xpt_link$(HOST_BIN_SUFFIX)
+else
+XPIDL_COMPILE 	= $(CYGWIN_WRAPPER) $(LIBXUL_DIST)/bin/xpidl$(BIN_SUFFIX)
+XPIDL_LINK	= $(CYGWIN_WRAPPER) $(LIBXUL_DIST)/bin/xpt_link$(BIN_SUFFIX)
+endif
+
+# Java macros
+JAVA_GEN_DIR  = _javagen
+JAVA_DIST_DIR = $(DEPTH)/$(JAVA_GEN_DIR)
+JAVA_IFACES_PKG_NAME = org/mozilla/interfaces
+
+REQ_INCLUDES	= -I$(srcdir) -I. $(foreach d,$(REQUIRES),-I$(DIST)/include/$d) -I$(DIST)/include 
+ifdef LIBXUL_SDK
+REQ_INCLUDES_SDK = $(foreach d,$(REQUIRES),-I$(LIBXUL_SDK)/include/$d) -I$(LIBXUL_SDK)/include
+endif
+
+INCLUDES	= $(LOCAL_INCLUDES) $(REQ_INCLUDES) $(REQ_INCLUDES_SDK) -I$(PUBLIC) $(OS_INCLUDES)
+
+ifndef MOZILLA_INTERNAL_API
+INCLUDES	+= -I$(LIBXUL_DIST)/sdk/include
+endif
+
+# The entire tree should be subject to static analysis using the XPCOM
+# script. Additional scripts may be added by specific subdirectories.
+
+DEHYDRA_SCRIPT = $(topsrcdir)/xpcom/analysis/static-checking.js
+
+DEHYDRA_MODULES = \
+  $(topsrcdir)/xpcom/analysis/final.js \
+  $(NULL)
+
+TREEHYDRA_MODULES = \
+  $(topsrcdir)/xpcom/analysis/outparams.js \
+  $(topsrcdir)/xpcom/analysis/stack.js \
+  $(topsrcdir)/xpcom/analysis/flow.js \
+  $(NULL)
+
+DEHYDRA_ARGS = \
+  --topsrcdir=$(topsrcdir) \
+  --objdir=$(DEPTH) \
+  --dehydra-modules=$(subst $(NULL) ,$(COMMA),$(strip $(DEHYDRA_MODULES))) \
+  --treehydra-modules=$(subst $(NULL) ,$(COMMA),$(strip $(TREEHYDRA_MODULES))) \
+  $(NULL)
+
+DEHYDRA_FLAGS = -fplugin=$(DEHYDRA_PATH) -fplugin-arg='$(DEHYDRA_SCRIPT) $(DEHYDRA_ARGS)'
+
+ifdef DEHYDRA_PATH
+OS_CXXFLAGS += $(DEHYDRA_FLAGS)
+endif
+
+CFLAGS		= $(OS_CFLAGS)
+CXXFLAGS	= $(OS_CXXFLAGS)
+LDFLAGS		= $(OS_LDFLAGS) $(MOZ_FIX_LINK_PATHS)
+
+# Allow each module to override the *default* optimization settings
+# by setting MODULE_OPTIMIZE_FLAGS if the developer has not given
+# arguments to --enable-optimize
+ifdef MOZ_OPTIMIZE
+ifeq (1,$(MOZ_OPTIMIZE))
+ifdef MODULE_OPTIMIZE_FLAGS
+CFLAGS		+= $(MODULE_OPTIMIZE_FLAGS)
+CXXFLAGS	+= $(MODULE_OPTIMIZE_FLAGS)
+else
+CFLAGS		+= $(MOZ_OPTIMIZE_FLAGS)
+CXXFLAGS	+= $(MOZ_OPTIMIZE_FLAGS)
+endif # MODULE_OPTIMIZE_FLAGS
+else
+CFLAGS		+= $(MOZ_OPTIMIZE_FLAGS)
+CXXFLAGS	+= $(MOZ_OPTIMIZE_FLAGS)
+endif # MOZ_OPTIMIZE == 1
+LDFLAGS		+= $(MOZ_OPTIMIZE_LDFLAGS)
+endif # MOZ_OPTIMIZE
+
+ifdef CROSS_COMPILE
+HOST_CFLAGS	+= $(HOST_OPTIMIZE_FLAGS)
+else
+ifdef MOZ_OPTIMIZE
+ifeq (1,$(MOZ_OPTIMIZE))
+ifdef MODULE_OPTIMIZE_FLAGS
+HOST_CFLAGS	+= $(MODULE_OPTIMIZE_FLAGS)
+else
+HOST_CFLAGS	+= $(MOZ_OPTIMIZE_FLAGS)
+endif # MODULE_OPTIMIZE_FLAGS
+else
+HOST_CFLAGS	+= $(MOZ_OPTIMIZE_FLAGS)
+endif # MOZ_OPTIMIZE == 1
+endif # MOZ_OPTIMIZE
+endif # CROSS_COMPILE
+
+
+ifeq ($(OS_ARCH)_$(GNU_CC),WINNT_)
+#// Currently, unless USE_STATIC_LIBS is defined, the multithreaded
+#// DLL version of the RTL is used...
+#//
+#//------------------------------------------------------------------------
+ifdef USE_STATIC_LIBS
+RTL_FLAGS=-MT          # Statically linked multithreaded RTL
+ifneq (,$(MOZ_DEBUG)$(NS_TRACE_MALLOC))
+ifndef MOZ_NO_DEBUG_RTL
+RTL_FLAGS=-MTd         # Statically linked multithreaded MSVC4.0 debug RTL
+endif
+endif # MOZ_DEBUG || NS_TRACE_MALLOC
+
+else # !USE_STATIC_LIBS
+
+RTL_FLAGS=-MD          # Dynamically linked, multithreaded RTL
+ifneq (,$(MOZ_DEBUG)$(NS_TRACE_MALLOC))
+ifndef MOZ_NO_DEBUG_RTL
+RTL_FLAGS=-MDd         # Dynamically linked, multithreaded MSVC4.0 debug RTL
+endif 
+endif # MOZ_DEBUG || NS_TRACE_MALLOC
+endif # USE_STATIC_LIBS
+endif # WINNT && !GNU_CC
+
+ifeq ($(OS_ARCH),Darwin)
+# Darwin doesn't cross-compile, so just set both types of flags here.
+HOST_CMFLAGS += -fobjc-exceptions
+HOST_CMMFLAGS += -fobjc-exceptions
+OS_COMPILE_CMFLAGS += -fobjc-exceptions
+OS_COMPILE_CMMFLAGS += -fobjc-exceptions
+endif
+
+COMPILE_CFLAGS	= $(VISIBILITY_FLAGS) $(DEFINES) $(INCLUDES) $(XCFLAGS) $(PROFILER_CFLAGS) $(DSO_CFLAGS) $(DSO_PIC_CFLAGS) $(CFLAGS) $(RTL_FLAGS) $(OS_COMPILE_CFLAGS)
+COMPILE_CXXFLAGS = $(VISIBILITY_FLAGS) $(DEFINES) $(INCLUDES) $(XCFLAGS) $(PROFILER_CFLAGS) $(DSO_CFLAGS) $(DSO_PIC_CFLAGS)  $(CXXFLAGS) $(RTL_FLAGS) $(OS_COMPILE_CXXFLAGS)
+COMPILE_CMFLAGS = $(OS_COMPILE_CMFLAGS)
+COMPILE_CMMFLAGS = $(OS_COMPILE_CMMFLAGS)
+
+ifndef CROSS_COMPILE
+HOST_CFLAGS += $(RTL_FLAGS)
+endif
+
+#
+# Name of the binary code directories
+#
+# Override defaults
+
+# We need to know where to find the libraries we
+# put on the link line for binaries, and should
+# we link statically or dynamic?  Assuming dynamic for now.
+
+ifneq (WINNT_,$(OS_ARCH)_$(GNU_CC))
+ifneq (,$(filter-out WINCE,$(OS_ARCH)))
+LIBS_DIR	= -L$(DIST)/bin -L$(DIST)/lib
+ifdef LIBXUL_SDK
+LIBS_DIR	+= -L$(LIBXUL_SDK)/bin -L$(LIBXUL_SDK)/lib
+endif
+endif
+endif
+
+# Default location of include files
+IDL_DIR		= $(DIST)/idl
+ifdef MODULE
+PUBLIC		= $(DIST)/include/$(MODULE)
+else
+PUBLIC		= $(DIST)/include
+endif
+
+XPIDL_FLAGS = -I$(srcdir) -I$(IDL_DIR)
+ifdef LIBXUL_SDK
+XPIDL_FLAGS += -I$(LIBXUL_SDK)/idl
+endif
+
+SDK_PUBLIC  = $(DIST)/sdk/include
+SDK_IDL_DIR = $(DIST)/sdk/idl
+SDK_LIB_DIR = $(DIST)/sdk/lib
+SDK_BIN_DIR = $(DIST)/sdk/bin
+
+DEPENDENCIES	= .md
+
+MOZ_COMPONENT_LIBS=$(XPCOM_LIBS) $(MOZ_COMPONENT_NSPR_LIBS)
+
+ifdef GC_LEAK_DETECTOR
+XPCOM_LIBS += -lboehm
+endif
+
+ifeq (xpconnect, $(findstring xpconnect, $(BUILD_MODULES)))
+DEFINES +=  -DXPCONNECT_STANDALONE
+endif
+
+ifeq ($(OS_ARCH),OS2)
+ELF_DYNSTR_GC	= echo
+else
+ELF_DYNSTR_GC	= :
+endif
+
+ifndef CROSS_COMPILE
+ifdef USE_ELF_DYNSTR_GC
+ifdef MOZ_COMPONENTS_VERSION_SCRIPT_LDFLAGS
+ELF_DYNSTR_GC 	= $(DEPTH)/config/elf-dynstr-gc
+endif
+endif
+endif
+
+ifeq ($(OS_ARCH),Darwin)
+ifdef NEXT_ROOT
+export NEXT_ROOT
+PBBUILD = NEXT_ROOT= $(PBBUILD_BIN)
+else # NEXT_ROOT
+PBBUILD = $(PBBUILD_BIN)
+endif # NEXT_ROOT
+PBBUILD_SETTINGS = GCC_VERSION="$(GCC_VERSION)" SYMROOT=build ARCHS="$(OS_TEST)"
+ifdef MACOS_SDK_DIR
+PBBUILD_SETTINGS += SDKROOT="$(MACOS_SDK_DIR)"
+endif # MACOS_SDK_DIR
+ifdef MACOSX_DEPLOYMENT_TARGET
+export MACOSX_DEPLOYMENT_TARGET
+PBBUILD_SETTINGS += MACOSX_DEPLOYMENT_TARGET="$(MACOSX_DEPLOYMENT_TARGET)"
+endif # MACOSX_DEPLOYMENT_TARGET
+ifdef MOZ_OPTIMIZE
+ifeq (2,$(MOZ_OPTIMIZE))
+# Only override project defaults if the config specified explicit settings
+PBBUILD_SETTINGS += GCC_MODEL_TUNING= OPTIMIZATION_CFLAGS="$(MOZ_OPTIMIZE_FLAGS)"
+endif # MOZ_OPTIMIZE=2
+endif # MOZ_OPTIMIZE
+ifeq (1,$(HAS_XCODE_2_1))
+# Xcode 2.1 puts its build products in a directory corresponding to the
+# selected build style/configuration.
+XCODE_PRODUCT_DIR = build/$(BUILDSTYLE)
+else
+XCODE_PRODUCT_DIR = build
+endif # HAS_XCODE_2_1=1
+endif # OS_ARCH=Darwin
+
+
+ifdef MOZ_NATIVE_MAKEDEPEND
+MKDEPEND_DIR	=
+MKDEPEND	= $(CYGWIN_WRAPPER) $(MOZ_NATIVE_MAKEDEPEND)
+else
+MKDEPEND_DIR	= $(CONFIG_TOOLS)/mkdepend
+MKDEPEND	= $(CYGWIN_WRAPPER) $(MKDEPEND_DIR)/mkdepend$(BIN_SUFFIX)
+endif
+
+# Set link flags according to whether we want a console.
+ifdef MOZ_WINCONSOLE
+ifeq ($(MOZ_WINCONSOLE),1)
+ifeq ($(OS_ARCH),OS2)
+BIN_FLAGS	+= -Zlinker -PM:VIO
+endif
+ifeq ($(OS_ARCH),WINNT)
+ifdef GNU_CC
+WIN32_EXE_LDFLAGS	+= -mconsole
+else
+WIN32_EXE_LDFLAGS	+= -SUBSYSTEM:CONSOLE
+endif
+endif
+else # MOZ_WINCONSOLE
+ifeq ($(OS_ARCH),OS2)
+BIN_FLAGS	+= -Zlinker -PM:PM
+endif
+ifeq ($(OS_ARCH),WINNT)
+ifdef GNU_CC
+WIN32_EXE_LDFLAGS	+= -mwindows
+else
+WIN32_EXE_LDFLAGS	+= -SUBSYSTEM:WINDOWS
+endif
+endif
+endif
+endif
+
+# Flags needed to link against the component library
+ifdef MOZ_COMPONENTLIB
+MOZ_COMPONENTLIB_EXTRA_DSO_LIBS = mozcomps xpcom_compat
+
+# Tell the linker where NSS is, if we're building crypto
+ifeq ($(OS_ARCH),Darwin)
+ifeq (,$(findstring crypto,$(MOZ_META_COMPONENTS)))
+MOZ_COMPONENTLIB_EXTRA_LIBS = $(foreach library, $(patsubst -l%, $(LIB_PREFIX)%$(DLL_SUFFIX), $(filter -l%, $(NSS_LIBS))), -dylib_file @executable_path/$(library):$(DIST)/bin/$(library))
+endif
+endif
+endif
+
+# If we're building a component on MSVC, we don't want to generate an
+# import lib, because that import lib will collide with the name of a
+# static version of the same library.
+ifeq ($(GNU_LD)$(OS_ARCH),WINNT)
+ifdef IS_COMPONENT
+LDFLAGS += -IMPLIB:fake.lib
+DELETE_AFTER_LINK = fake.lib fake.exp
+endif
+endif
+
+#
+# Include any personal overrides the user might think are needed.
+#
+-include $(topsrcdir)/$(MOZ_BUILD_APP)/app-config.mk
+-include $(MY_CONFIG)
+
+######################################################################
+# Now test variables that might have been set or overridden by $(MY_CONFIG).
+
+DEFINES		+= -DOSTYPE=\"$(OS_CONFIG)\"
+DEFINES		+= -DOSARCH=$(OS_ARCH)
+
+# For profiling
+ifdef ENABLE_EAZEL_PROFILER
+ifndef INTERNAL_TOOLS
+ifneq ($(LIBRARY_NAME), xpt)
+ifneq (, $(findstring $(shell $(topsrcdir)/build/unix/print-depth-path.sh | awk -F/ '{ print $$2; }'), $(MOZ_PROFILE_MODULES)))
+PROFILER_CFLAGS	= $(EAZEL_PROFILER_CFLAGS) -DENABLE_EAZEL_PROFILER
+PROFILER_LIBS	= $(EAZEL_PROFILER_LIBS)
+endif
+endif
+endif
+endif
+
+######################################################################
+
+GARBAGE		+= $(DEPENDENCIES) $(MKDEPENDENCIES) $(MKDEPENDENCIES).bak core $(wildcard core.[0-9]*) $(wildcard *.err) $(wildcard *.pure) $(wildcard *_pure_*.o) Templates.DB
+
+ifeq ($(OS_ARCH),Darwin)
+ifndef NSDISTMODE
+NSDISTMODE=absolute_symlink
+endif
+PWD := $(shell pwd)
+endif
+
+ifdef NSINSTALL_BIN
+NSINSTALL	= $(CYGWIN_WRAPPER) $(NSINSTALL_BIN)
+else
+ifeq (WINNT,$(CROSS_COMPILE)$(OS_ARCH))
+NSINSTALL	= $(CYGWIN_WRAPPER) $(MOZ_TOOLS_DIR)/bin/nsinstall
+else
+ifeq (OS2,$(CROSS_COMPILE)$(OS_ARCH))
+NSINSTALL	= $(MOZ_TOOLS_DIR)/nsinstall
+else
+NSINSTALL	= $(CONFIG_TOOLS)/nsinstall
+endif # OS2
+endif # WINNT
+endif # NSINSTALL_BIN
+
+
+ifeq (,$(CROSS_COMPILE)$(filter-out WINNT OS2, $(OS_ARCH)))
+INSTALL		= $(NSINSTALL)
+else
+ifeq ($(NSDISTMODE),copy)
+# copy files, but preserve source mtime
+INSTALL		= $(NSINSTALL) -t
+else
+ifeq ($(NSDISTMODE),absolute_symlink)
+# install using absolute symbolic links
+ifeq ($(OS_ARCH),Darwin)
+INSTALL		= $(NSINSTALL) -L $(PWD)
+else
+INSTALL		= $(NSINSTALL) -L `$(NFSPWD)`
+endif # Darwin
+else
+# install using relative symbolic links
+INSTALL		= $(NSINSTALL) -R
+endif # absolute_symlink
+endif # copy
+endif # WINNT/OS2
+
+ifeq (,$(filter-out WINCE,$(OS_ARCH)))
+NSINSTALL	= $(CYGWIN_WRAPPER) nsinstall
+INSTALL     = $(CYGWIN_WRAPPER) nsinstall 
+endif
+
+# Use nsinstall in copy mode to install files on the system
+SYSINSTALL	= $(NSINSTALL) -t
+
+ifeq ($(OS_ARCH),WINNT)
+ifneq (,$(CYGDRIVE_MOUNT))
+export CYGDRIVE_MOUNT
+endif
+endif
+
+#
+# Localization build automation
+#
+
+# Because you might wish to "make locales AB_CD=ab-CD", we don't hardcode
+# MOZ_UI_LOCALE directly, but use an intermediate variable that can be
+# overridden by the command line. (Besides, AB_CD is prettier).
+AB_CD = $(MOZ_UI_LOCALE)
+
+ifndef L10NBASEDIR
+L10NBASEDIR = $(error L10NBASEDIR not defined by configure)
+endif
+
+EXPAND_LOCALE_SRCDIR = $(if $(filter en-US,$(AB_CD)),$(topsrcdir)/$(1)/en-US,$(L10NBASEDIR)/$(AB_CD)/$(subst /locales,,$(1)))
+
+ifdef relativesrcdir
+LOCALE_SRCDIR = $(call EXPAND_LOCALE_SRCDIR,$(relativesrcdir))
+endif
+
+ifdef LOCALE_SRCDIR
+# if LOCALE_MERGEDIR is set, use mergedir first, then the localization,
+# and finally en-US
+ifdef LOCALE_MERGEDIR
+MAKE_JARS_FLAGS += -c $(LOCALE_MERGEDIR)/$(subst /locales,,$(relativesrcdir))
+endif
+MAKE_JARS_FLAGS += -c $(LOCALE_SRCDIR)
+ifdef LOCALE_MERGEDIR
+MAKE_JARS_FLAGS += -c $(topsrcdir)/$(relativesrcdir)/en-US
+endif
+endif
+
+ifeq (,$(filter WINCE WINNT OS2,$(OS_ARCH)))
+RUN_TEST_PROGRAM = $(DIST)/bin/run-mozilla.sh
+endif
+
+#
+# Java macros
+#
+
+# Make sure any compiled classes work with at least JVM 1.4
+JAVAC_FLAGS += -source 1.4
+
+ifdef MOZ_DEBUG
+JAVAC_FLAGS += -g
+endif
diff -r 17e9560465b0 js/src/config/dgux.mk
--- a/js/src/config/dgux.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,64 +0,0 @@
-# -*- Mode: makefile -*-
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-#
-# Config stuff for Data General DG/UX
-#
-
-#
-#  Initial DG/UX port by Marc Fraioli (fraioli@dg-rtp.dg.com)
-#
-
-AS = as
-CC = gcc 
-CCC = g++ 
-
-RANLIB = echo
-
-#
-#  _DGUX_SOURCE is needed to turn on a lot of stuff in the headers if 
-#      you're not using DG's compiler.  It shouldn't hurt if you are.
-#
-#  _POSIX4A_DRAFT10_SOURCE is needed to pick up localtime_r, used in
-#      prtime.c
-#
-OS_CFLAGS = -DXP_UNIX -DSVR4 -DSYSV -DDGUX -D_DGUX_SOURCE -D_POSIX4A_DRAFT10_SOURCE -DHAVE_LOCALTIME_R
-OS_LIBS = -lsocket -lnsl 
-
-NOSUCHFILE = /no-such-file
diff -r 17e9560465b0 js/src/config/elf-dynstr-gc.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/elf-dynstr-gc.c	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,1245 @@
+/* elf_gc_dynst
+ *
+ * This is a program that removes unreferenced strings from the .dynstr
+ * section in ELF shared objects. It also shrinks the .dynstr section and
+ * relocates all symbols after it.
+ *
+ * This program was written and copyrighted by:
+ *   Alexander Larsson <alla@lysator.liu.se>
+ *
+ *
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org Code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2001
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+
+#include <stdio.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/mman.h>
+
+#include <elf.h>
+#include <glib.h>
+#include <string.h>
+
+
+Elf32_Ehdr *elf_header = NULL;
+#define FILE_OFFSET(offset) ((unsigned char *)(elf_header) + (offset))
+
+struct dynamic_symbol {
+  Elf32_Word old_index;
+  Elf32_Word new_index;
+  char *string;
+};
+
+GHashTable *used_dynamic_symbols = NULL;
+/* Data is dynamic_symbols, hashes on old_index */
+Elf32_Word hole_index;
+Elf32_Word hole_end;
+Elf32_Word hole_len;
+
+Elf32_Addr hole_addr_start;
+Elf32_Addr hole_addr_remap_start;
+Elf32_Addr hole_addr_remap_end;
+
+int need_byteswap;
+
+unsigned char machine_type;
+
+Elf32_Word
+read_word(Elf32_Word w)
+{
+  if (need_byteswap) 
+    w = GUINT32_SWAP_LE_BE(w);
+  return w;
+}
+
+Elf32_Sword
+read_sword(Elf32_Sword w)
+{
+  if (need_byteswap) 
+    w = (Elf32_Sword)GUINT32_SWAP_LE_BE((guint32)w);
+  return w;
+}
+
+void 
+write_word(Elf32_Word *ptr, Elf32_Word w)
+{
+  if (need_byteswap) 
+    w = GUINT32_SWAP_LE_BE(w);
+  *ptr = w;
+}
+
+Elf32_Half
+read_half(Elf32_Half h)
+{
+  if (need_byteswap) 
+    h = GUINT16_SWAP_LE_BE(h);
+  return h;
+}
+
+void 
+write_half(Elf32_Half *ptr, Elf32_Half h)
+{
+  if (need_byteswap) 
+    h = GUINT16_SWAP_LE_BE(h);
+  *ptr = h;
+}
+
+void
+setup_byteswapping(unsigned char ei_data)
+{
+  need_byteswap = 0;
+#if G_BYTE_ORDER == G_BIG_ENDIAN
+  if (ei_data == ELFDATA2LSB)
+    need_byteswap = 1;
+#endif
+#if G_BYTE_ORDER == G_LITTLE_ENDIAN
+  if (ei_data == ELFDATA2MSB)
+    need_byteswap = 1;
+#endif
+}
+
+
+Elf32_Shdr *
+elf_find_section_num(int section_index)
+{
+  Elf32_Shdr *section;
+  Elf32_Word sectionsize;
+
+  section = (Elf32_Shdr *)FILE_OFFSET(read_word(elf_header->e_shoff));
+  sectionsize = read_half(elf_header->e_shentsize);
+
+  section = (Elf32_Shdr *)((char *)section + sectionsize*section_index);
+
+  return section;
+}
+
+Elf32_Shdr *
+elf_find_section_named(char *name)
+{
+  Elf32_Shdr *section;
+  Elf32_Shdr *strtab_section;
+  Elf32_Word sectionsize;
+  int numsections;
+  char *strtab;
+  int i = 0;
+
+  section = (Elf32_Shdr *)FILE_OFFSET(read_word(elf_header->e_shoff));
+
+  strtab_section = elf_find_section_num(read_half(elf_header->e_shstrndx));
+  
+  strtab = (char *)FILE_OFFSET(read_word(strtab_section->sh_offset));
+  
+  sectionsize = read_half(elf_header->e_shentsize);
+  numsections = read_half(elf_header->e_shnum);
+
+  for (i=0;i<numsections;i++) {
+    if (strcmp(&strtab[read_word(section->sh_name)], name) == 0) {
+      return section;
+    }
+    section = (Elf32_Shdr *)((char *)section + sectionsize);
+  }
+  return NULL;
+}
+
+
+Elf32_Shdr *
+elf_find_section(Elf32_Word sh_type)
+{
+  Elf32_Shdr *section;
+  Elf32_Word sectionsize;
+  int numsections;
+  int i = 0;
+
+  section = (Elf32_Shdr *)FILE_OFFSET(read_word(elf_header->e_shoff));
+  sectionsize = read_half(elf_header->e_shentsize);
+  numsections = read_half(elf_header->e_shnum);
+
+  for (i=0;i<numsections;i++) {
+    if (read_word(section->sh_type) == sh_type) {
+      return section;
+    }
+    section = (Elf32_Shdr *)((char *)section + sectionsize);
+  }
+  return NULL;
+}
+
+Elf32_Shdr *
+elf_find_next_higher_section(Elf32_Word offset)
+{
+  Elf32_Shdr *section;
+  Elf32_Shdr *higher;
+  Elf32_Word sectionsize;
+  int numsections;
+  int i = 0;
+
+  section = (Elf32_Shdr *)FILE_OFFSET(read_word(elf_header->e_shoff));
+  sectionsize = read_half(elf_header->e_shentsize);
+  numsections = read_half(elf_header->e_shnum);
+
+  higher = NULL;
+
+  for (i=0;i<numsections;i++) {
+    if (read_word(section->sh_offset) >= offset) {
+      if (higher == NULL) {
+	higher = section;
+      } else if (read_word(section->sh_offset) < read_word(higher->sh_offset)) {
+	higher = section;
+      }
+    }
+    
+    section = (Elf32_Shdr *)((char *)section + sectionsize);
+  }
+  
+  return higher;
+}
+
+Elf32_Word
+vma_to_offset(Elf32_Addr addr)
+{
+  Elf32_Shdr *section;
+  Elf32_Shdr *higher;
+  Elf32_Word sectionsize;
+  int numsections;
+  int i = 0;
+
+  section = (Elf32_Shdr *)FILE_OFFSET(read_word(elf_header->e_shoff));
+  sectionsize = read_half(elf_header->e_shentsize);
+  numsections = read_half(elf_header->e_shnum);
+
+  higher = NULL;
+
+  for (i=0;i<numsections;i++) {
+    if ( (addr >= read_word(section->sh_addr)) &&
+	 (addr < read_word(section->sh_addr) + read_word(section->sh_size)) ) {
+      return read_word(section->sh_offset) + (addr - read_word(section->sh_addr));
+    }
+    
+    section = (Elf32_Shdr *)((char *)section + sectionsize);
+  }
+
+  fprintf(stderr, "Warning, unable to convert address %d (0x%x) to file offset\n",
+	 addr, addr);
+  return 0;
+}
+
+
+void
+find_segment_addr_min_max(Elf32_Word file_offset,
+			  Elf32_Addr *start, Elf32_Addr *end)
+{
+  Elf32_Phdr *segment;
+  Elf32_Word segmentsize;
+  int numsegments;
+  int i = 0;
+
+  segment = (Elf32_Phdr *)FILE_OFFSET(read_word(elf_header->e_phoff));
+  segmentsize = read_half(elf_header->e_phentsize);
+  numsegments = read_half(elf_header->e_phnum);
+
+  for (i=0;i<numsegments;i++) {
+    if ((file_offset >= read_word(segment->p_offset)) &&
+	(file_offset < read_word(segment->p_offset) + read_word(segment->p_filesz)))  {
+      *start = read_word(segment->p_vaddr);
+      *end = read_word(segment->p_vaddr) + read_word(segment->p_memsz);
+      return;
+    }
+
+    segment = (Elf32_Phdr *)((char *)segment + segmentsize);
+  }
+  fprintf(stderr, "Error: Couldn't find segment in find_segment_addr_min_max()\n");
+}
+
+void *
+dynamic_find_tag(Elf32_Shdr *dynamic, Elf32_Sword d_tag)
+{
+  int i;
+  Elf32_Dyn *element;
+
+  element = (Elf32_Dyn *)FILE_OFFSET(read_word(dynamic->sh_offset));
+  for (i=0; read_sword(element[i].d_tag) != DT_NULL; i++) {
+    if (read_sword(element[i].d_tag) == d_tag) {
+      return FILE_OFFSET(read_word(element[i].d_un.d_ptr));
+    }
+  }
+  
+  return NULL;
+}
+
+Elf32_Word
+fixup_offset(Elf32_Word offset)
+{
+  if (offset >= hole_index) {
+    return offset - hole_len;
+  }
+  return offset;
+}
+
+Elf32_Word
+fixup_size(Elf32_Word offset, Elf32_Word size)
+{
+  /* Note: Doesn't handle the cases where the hole and the size intersect
+     partially. */
+  
+  if ( (hole_index >= offset) &&
+       (hole_index < offset + size)){
+    return size - hole_len;
+  }
+  
+  return size;
+}
+
+Elf32_Addr
+fixup_addr(Elf32_Addr addr)
+{
+  if (addr == 0)
+    return 0;
+
+  /*
+  if ( (addr < hole_addr_remap_start) ||
+       (addr >= hole_addr_remap_end))
+    return addr;
+  */
+  
+  if (addr >= hole_addr_start) {
+    return addr - hole_len;
+  }
+  return addr;
+}
+
+Elf32_Word
+fixup_addr_size(Elf32_Addr addr, Elf32_Word size)
+{
+  /* Note: Doesn't handle the cases where the hole and the size intersect
+     partially. */
+  /*
+  if ( (addr < hole_addr_remap_start) ||
+       (addr >= hole_addr_remap_end))
+    return size;
+  */
+  if ( (hole_addr_start >= addr) &&
+       (hole_addr_start < addr + size)){
+    return size - hole_len;
+  }
+  
+  return size;
+}
+
+void
+possibly_add_string(int name_idx, const char *name)
+{
+  struct dynamic_symbol *dynamic_symbol;
+  if (name_idx != 0) {
+    dynamic_symbol = g_hash_table_lookup(used_dynamic_symbols, (gpointer) name_idx);
+    
+    if (dynamic_symbol == NULL) {
+      
+      dynamic_symbol = g_new(struct dynamic_symbol, 1);
+      
+      dynamic_symbol->old_index = name_idx;
+      dynamic_symbol->new_index = 0;
+      dynamic_symbol->string = g_strdup(name);
+      
+      g_hash_table_insert(used_dynamic_symbols, (gpointer)name_idx, dynamic_symbol);
+      /*printf("added dynamic string: %s (%d)\n", dynamic_symbol->string, name_idx);*/
+    }
+  }
+}
+
+Elf32_Word
+fixup_string(Elf32_Word old_idx)
+{
+  struct dynamic_symbol *dynamic_symbol;
+
+  if (old_idx == 0)
+    return 0;
+  
+  dynamic_symbol = g_hash_table_lookup(used_dynamic_symbols, (gpointer) old_idx);
+
+  if (dynamic_symbol == NULL) {
+    fprintf(stderr, "AAAAAAAAAAAARGH!? Unknown string found in fixup (index: %d)!\n", old_idx);
+    return 0;
+  }
+  
+  return dynamic_symbol->new_index;
+}
+
+
+
+void
+add_strings_from_dynsym(Elf32_Shdr *dynsym, char *strtab)
+{
+  Elf32_Sym *symbol;
+  Elf32_Sym *symbol_end;
+  Elf32_Word entry_size;
+  
+
+  symbol = (Elf32_Sym *)FILE_OFFSET(read_word(dynsym->sh_offset));
+  symbol_end = (Elf32_Sym *)FILE_OFFSET(read_word(dynsym->sh_offset) + read_word(dynsym->sh_size));
+  entry_size = read_word(dynsym->sh_entsize);
+
+  while (symbol < symbol_end) {
+    int name_idx;
+    struct dynamic_symbol *dynamic_symbol;
+
+    name_idx = read_word(symbol->st_name);
+    possibly_add_string(name_idx, &strtab[name_idx]);
+
+    
+    symbol = (Elf32_Sym *)((char *)symbol + entry_size);
+  }
+}
+
+
+void
+fixup_strings_in_dynsym(Elf32_Shdr *dynsym)
+{
+  Elf32_Sym *symbol;
+  Elf32_Sym *symbol_end;
+  Elf32_Word entry_size;
+  
+
+  symbol = (Elf32_Sym *)FILE_OFFSET(read_word(dynsym->sh_offset));
+  symbol_end = (Elf32_Sym *)FILE_OFFSET(read_word(dynsym->sh_offset) + read_word(dynsym->sh_size));
+  entry_size = read_word(dynsym->sh_entsize);
+  
+  while (symbol < symbol_end) {
+    struct dynamic_symbol *dynamic_symbol;
+
+    write_word(&symbol->st_name,
+	       fixup_string(read_word(symbol->st_name)));
+			 
+    symbol = (Elf32_Sym *)((char *)symbol + entry_size);
+  }
+}
+
+
+void
+add_strings_from_dynamic(Elf32_Shdr *dynamic, char *strtab)
+{
+  int i;
+  int name_idx;
+  Elf32_Dyn *element;
+  Elf32_Word entry_size;
+
+  entry_size = read_word(dynamic->sh_entsize);
+  
+
+  element = (Elf32_Dyn *)FILE_OFFSET(read_word(dynamic->sh_offset));
+  while (read_sword(element->d_tag) != DT_NULL) {
+
+    switch(read_sword(element->d_tag)) {
+    case DT_NEEDED:
+    case DT_SONAME:
+    case DT_RPATH:
+      name_idx = read_word(element->d_un.d_val);
+      /*if (name_idx) printf("d_tag: %d\n", element->d_tag);*/
+      possibly_add_string(name_idx, &strtab[name_idx]);
+      break;
+    default:
+      ;
+      /*printf("unhandled d_tag: %d (0x%x)\n", element->d_tag, element->d_tag);*/
+    }
+
+    element = (Elf32_Dyn *)((char *)element + entry_size);
+  }
+  
+}
+
+void
+fixup_strings_in_dynamic(Elf32_Shdr *dynamic)
+{
+  int i;
+  int name_idx;
+  Elf32_Dyn *element;
+  Elf32_Word entry_size;
+
+  entry_size = read_word(dynamic->sh_entsize);
+
+  element = (Elf32_Dyn *)FILE_OFFSET(read_word(dynamic->sh_offset));
+  while (read_sword(element->d_tag) != DT_NULL) {
+
+    switch(read_sword(element->d_tag)) {
+    case DT_NEEDED:
+    case DT_SONAME:
+    case DT_RPATH:
+      write_word(&element->d_un.d_val,
+		 fixup_string(read_word(element->d_un.d_val)));
+      break;
+    default:
+      ;
+      /*printf("unhandled d_tag: %d (0x%x)\n", element->d_tag, element->d_tag);*/
+    }
+
+    element = (Elf32_Dyn *)((char *)element + entry_size);
+  }
+  
+}
+
+
+void
+add_strings_from_ver_d(Elf32_Shdr *ver_d, char *strtab)
+{
+  Elf32_Verdaux *veraux;
+  Elf32_Verdef *verdef;
+  int num_aux;
+  int name_idx;
+  int i;
+  int cont;
+
+  verdef = (Elf32_Verdef *)FILE_OFFSET(read_word(ver_d->sh_offset));
+
+  do {
+    num_aux = read_half(verdef->vd_cnt);
+    veraux = (Elf32_Verdaux *)((char *)verdef + read_word(verdef->vd_aux));
+    for (i=0; i<num_aux; i++) {
+      name_idx = read_word(veraux->vda_name);
+      possibly_add_string(name_idx, &strtab[name_idx]);
+      veraux = (Elf32_Verdaux *)((char *)veraux + read_word(veraux->vda_next));
+    }
+
+    cont = read_word(verdef->vd_next) != 0;
+    verdef = (Elf32_Verdef *)((char *)verdef + read_word(verdef->vd_next));
+  } while (cont);
+  
+}
+
+void
+fixup_strings_in_ver_d(Elf32_Shdr *ver_d)
+{
+  Elf32_Verdaux *veraux;
+  Elf32_Verdef *verdef;
+  int num_aux;
+  int name_idx;
+  int i;
+  int cont;
+
+  verdef = (Elf32_Verdef *)FILE_OFFSET(read_word(ver_d->sh_offset));
+
+  do {
+    num_aux = read_half(verdef->vd_cnt);
+    veraux = (Elf32_Verdaux *)((char *)verdef + read_word(verdef->vd_aux));
+    for (i=0; i<num_aux; i++) {
+      write_word(&veraux->vda_name,
+		 fixup_string(read_word(veraux->vda_name)));
+      veraux = (Elf32_Verdaux *)((char *)veraux + read_word(veraux->vda_next));
+    }
+
+    cont = read_word(verdef->vd_next) != 0;
+    verdef = (Elf32_Verdef *)((char *)verdef + read_word(verdef->vd_next));
+  } while (cont);
+  
+}
+
+void
+add_strings_from_ver_r(Elf32_Shdr *ver_r, char *strtab)
+{
+  Elf32_Vernaux *veraux;
+  Elf32_Verneed *verneed;
+  int num_aux;
+  int name_idx;
+  int i;
+  int cont;
+
+  verneed = (Elf32_Verneed *)FILE_OFFSET(read_word(ver_r->sh_offset));
+
+  do {
+    name_idx = read_word(verneed->vn_file);
+    possibly_add_string(name_idx, &strtab[name_idx]);
+    num_aux = read_half(verneed->vn_cnt);
+    veraux = (Elf32_Vernaux *)((char *)verneed + read_word(verneed->vn_aux));
+    for (i=0; i<num_aux; i++) {
+      name_idx = read_word(veraux->vna_name);
+      possibly_add_string(name_idx, &strtab[name_idx]);
+      veraux = (Elf32_Vernaux *)((char *)veraux + read_word(veraux->vna_next));
+    }
+
+    cont = read_word(verneed->vn_next) != 0;
+    verneed = (Elf32_Verneed *)((char *)verneed + read_word(verneed->vn_next));
+  } while (cont);
+}
+
+void
+fixup_strings_in_ver_r(Elf32_Shdr *ver_r)
+{
+  Elf32_Vernaux *veraux;
+  Elf32_Verneed *verneed;
+  int num_aux;
+  int name_idx;
+  int i;
+  int cont;
+
+  verneed = (Elf32_Verneed *)FILE_OFFSET(read_word(ver_r->sh_offset));
+
+  do {
+    write_word(&verneed->vn_file,
+	       fixup_string(read_word(verneed->vn_file)));
+    num_aux = read_half(verneed->vn_cnt);
+    veraux = (Elf32_Vernaux *)((char *)verneed + read_word(verneed->vn_aux));
+    for (i=0; i<num_aux; i++) {
+      write_word(&veraux->vna_name,
+		 fixup_string(read_word(veraux->vna_name)));
+      veraux = (Elf32_Vernaux *)((char *)veraux + read_word(veraux->vna_next));
+    }
+
+    cont = read_word(verneed->vn_next) != 0;
+    verneed = (Elf32_Verneed *)((char *)verneed + read_word(verneed->vn_next));
+  } while (cont);
+}
+
+gboolean sum_size(gpointer	key,
+		  struct dynamic_symbol *sym,
+		  int *size)
+{
+  *size += strlen(sym->string) + 1;
+  return 1;
+}
+
+struct index_n_dynstr {
+  int index;
+  unsigned char *dynstr;
+};
+
+gboolean output_string(gpointer	key,
+		       struct dynamic_symbol *sym,
+		       struct index_n_dynstr *x)
+{
+  sym->new_index = x->index;
+  memcpy(x->dynstr + x->index, sym->string, strlen(sym->string) + 1);
+  x->index += strlen(sym->string) + 1;
+  return 1;
+}
+
+
+unsigned char *
+generate_new_dynstr(Elf32_Word *size_out)
+{
+  int size;
+  unsigned char *new_dynstr;
+  struct index_n_dynstr x;
+
+  size = 1; /* first a zero */
+  g_hash_table_foreach	(used_dynamic_symbols,
+			 (GHFunc)sum_size,
+			 &size);
+
+
+  new_dynstr = g_malloc(size);
+
+  new_dynstr[0] = 0;
+  x.index = 1;
+  x.dynstr = new_dynstr;
+  g_hash_table_foreach	(used_dynamic_symbols,
+			 (GHFunc)output_string,
+			 &x);
+  
+  *size_out = size;
+  return new_dynstr;
+}
+
+void
+remap_sections(void)
+{
+  Elf32_Shdr *section;
+  Elf32_Word sectionsize;
+  int numsections;
+  int i = 0;
+
+  section = (Elf32_Shdr *)FILE_OFFSET(read_word(elf_header->e_shoff));
+  sectionsize = read_half(elf_header->e_shentsize);
+  numsections = read_half(elf_header->e_shnum);
+
+  for (i=0;i<numsections;i++) {
+    write_word(&section->sh_size,
+	       fixup_size(read_word(section->sh_offset),
+			  read_word(section->sh_size)));
+    write_word(&section->sh_offset,
+	       fixup_offset(read_word(section->sh_offset)));
+    write_word(&section->sh_addr,
+	       fixup_addr(read_word(section->sh_addr)));
+    
+    section = (Elf32_Shdr *)((char *)section + sectionsize);
+  }
+}
+
+
+void
+remap_segments(void)
+{
+  Elf32_Phdr *segment;
+  Elf32_Word segmentsize;
+  Elf32_Word p_align;
+  int numsegments;
+  int i = 0;
+
+  segment = (Elf32_Phdr *)FILE_OFFSET(read_word(elf_header->e_phoff));
+  segmentsize = read_half(elf_header->e_phentsize);
+  numsegments = read_half(elf_header->e_phnum);
+
+  for (i=0;i<numsegments;i++) {
+    write_word(&segment->p_filesz,
+	       fixup_size(read_word(segment->p_offset),
+			  read_word(segment->p_filesz)));
+    write_word(&segment->p_offset,
+	       fixup_offset(read_word(segment->p_offset)));
+
+    write_word(&segment->p_memsz,
+	       fixup_addr_size(read_word(segment->p_vaddr),
+			       read_word(segment->p_memsz)));
+    write_word(&segment->p_vaddr,
+	       fixup_addr(read_word(segment->p_vaddr)));
+    write_word(&segment->p_paddr,
+	       read_word(segment->p_vaddr));
+
+    /* Consistancy checking: */
+    p_align = read_word(segment->p_align);
+    if (p_align > 1) {
+      if ((read_word(segment->p_vaddr) - read_word(segment->p_offset))%p_align != 0) {
+	fprintf(stderr, "Warning, creating non-aligned segment addr: %x offset: %x allign: %x\n",
+		read_word(segment->p_vaddr), read_word(segment->p_offset), p_align);
+      }
+    }
+    
+    segment = (Elf32_Phdr *)((char *)segment + segmentsize);
+  }
+}
+
+void
+remap_elf_header(void)
+{
+  write_word(&elf_header->e_phoff,
+	     fixup_offset(read_word(elf_header->e_phoff)));
+  write_word(&elf_header->e_shoff,
+	     fixup_offset(read_word(elf_header->e_shoff)));
+
+  write_word(&elf_header->e_entry,
+	     fixup_addr(read_word(elf_header->e_entry)));
+}
+
+void
+remap_symtab(Elf32_Shdr *symtab)
+{
+  Elf32_Sym *symbol;
+  Elf32_Sym *symbol_end;
+  Elf32_Word entry_size;
+
+  symbol = (Elf32_Sym *)FILE_OFFSET(read_word(symtab->sh_offset));
+  symbol_end = (Elf32_Sym *)FILE_OFFSET(read_word(symtab->sh_offset) +
+					read_word(symtab->sh_size));
+  entry_size = read_word(symtab->sh_entsize);
+
+  while (symbol < symbol_end) {
+    write_word(&symbol->st_value,
+	       fixup_addr(read_word(symbol->st_value)));
+    symbol = (Elf32_Sym *)((char *)symbol + entry_size);
+  }
+}
+
+
+/* Ugly global variables: */
+Elf32_Addr got_data_start = 0;
+Elf32_Addr got_data_end = 0;
+
+
+void
+remap_rel_section(Elf32_Rel *rel, Elf32_Word size, Elf32_Word entry_size)
+{
+  Elf32_Rel *rel_end;
+  Elf32_Word offset;
+  Elf32_Addr *addr;
+  Elf32_Word type;
+
+  rel_end = (Elf32_Rel *)((char *)rel + size);
+
+  while (rel < rel_end) {
+    type = ELF32_R_TYPE(read_word(rel->r_info)); 
+    switch (machine_type) {
+    case EM_386:
+      if ((type == R_386_RELATIVE) || (type == R_386_JMP_SLOT)) {
+	/* We need to relocate the data this is pointing to too. */
+	offset = vma_to_offset(read_word(rel->r_offset));
+	
+	addr =  (Elf32_Addr *)FILE_OFFSET(offset);
+	write_word(addr, 
+		   fixup_addr(read_word(*addr)));
+      }
+      write_word(&rel->r_offset,
+		 fixup_addr(read_word(rel->r_offset)));
+      break;
+    case EM_PPC:
+      /* The PPC always uses RELA relocations */
+      break;
+    }
+
+    
+    rel = (Elf32_Rel *)((char *)rel + entry_size);
+  }
+}
+
+void
+remap_rela_section(Elf32_Rela *rela, Elf32_Word size, Elf32_Word entry_size)
+{
+  Elf32_Rela *rela_end;
+  Elf32_Addr *addr;
+  Elf32_Word offset;
+  Elf32_Word type;
+  Elf32_Word bitmask;
+
+  rela_end = (Elf32_Rela *)((char *)rela + size);
+
+  while (rela < rela_end) {
+    type = ELF32_R_TYPE(read_word(rela->r_info));
+    switch (machine_type) {
+    case EM_386:
+      if ((type == R_386_RELATIVE) || (type == R_386_JMP_SLOT)) {
+	/* We need to relocate the data this is pointing to too. */
+	offset = vma_to_offset(read_word(rela->r_offset));
+	
+	addr =  (Elf32_Addr *)FILE_OFFSET(offset);
+	write_word(addr,
+		   fixup_addr(read_word(*addr)));
+      }
+      write_word(&rela->r_offset,
+		 fixup_addr(read_word(rela->r_offset)));
+      break;
+    case EM_PPC:
+/* Some systems do not have PowerPC relocations defined */
+#ifdef R_PPC_NONE
+      switch (type) {
+      case R_PPC_RELATIVE:
+	write_word((Elf32_Word *)&rela->r_addend,
+		   fixup_addr(read_word(rela->r_addend)));
+	/* Fall through for 32bit offset fixup */
+      case R_PPC_ADDR32:
+      case R_PPC_GLOB_DAT:
+      case R_PPC_JMP_SLOT:
+	write_word(&rela->r_offset,
+		   fixup_addr(read_word(rela->r_offset)));
+	break;
+      case R_PPC_NONE:
+	break;
+      default:
+	fprintf(stderr, "Warning, unhandled PPC relocation type %d\n", type);
+      }
+#endif
+      break;
+    }
+    
+    rela = (Elf32_Rela *)((char *)rela + entry_size);
+  }
+}
+
+void 
+remap_i386_got(void)
+{
+  Elf32_Shdr *got_section;
+  Elf32_Addr *got;
+  Elf32_Addr *got_end;
+  Elf32_Word entry_size;
+
+  got_section = elf_find_section_named(".got");
+  if (got_section == NULL) {
+    fprintf(stderr, "Warning, no .got section\n");
+    return;
+  }
+
+  got_data_start = read_word(got_section->sh_offset);
+  got_data_end = got_data_start + read_word(got_section->sh_size);
+  
+  got = (Elf32_Addr *)FILE_OFFSET(got_data_start);
+  got_end = (Elf32_Addr *)FILE_OFFSET(got_data_end);
+  entry_size = read_word(got_section->sh_entsize);
+
+  write_word(got,
+	     fixup_addr(read_word(*got))); /* Pointer to .dynamic */
+}
+
+void 
+remap_ppc_got(void)
+{
+  Elf32_Shdr *got_section;
+  Elf32_Addr *got;
+  Elf32_Addr *got_end;
+  Elf32_Word entry_size;
+
+  got_section = elf_find_section_named(".got");
+  if (got_section == NULL) {
+    fprintf(stderr, "Warning, no .got section\n");
+    return;
+  }
+
+  got_data_start = read_word(got_section->sh_offset);
+  got_data_end = got_data_start + read_word(got_section->sh_size);
+  
+  got = (Elf32_Addr *)FILE_OFFSET(got_data_start);
+  got_end = (Elf32_Addr *)FILE_OFFSET(got_data_end);
+  entry_size = read_word(got_section->sh_entsize);
+
+  /* Skip reserved part.
+   * Note that this should really be found by finding the
+   * _GLOBAL_OFFSET_TABLE symbol, as it could (according to
+   * the spec) point to the middle of the got.
+   */
+  got = (Elf32_Addr *)((char *)got + entry_size); /* Skip blrl instruction */
+  write_word(got,
+	     fixup_addr(read_word(*got))); /* Pointer to .dynamic */
+}
+
+
+Elf32_Word
+get_dynamic_val(Elf32_Shdr *dynamic, Elf32_Sword tag)
+{
+  Elf32_Dyn *element;
+  Elf32_Word entry_size;
+
+  entry_size = read_word(dynamic->sh_entsize);
+
+  element = (Elf32_Dyn *)FILE_OFFSET(read_word(dynamic->sh_offset));
+  while (read_sword(element->d_tag) != DT_NULL) {
+    if (read_sword(element->d_tag) == tag) {
+      return read_word(element->d_un.d_val);
+    }
+    element = (Elf32_Dyn *)((char *)element + entry_size);
+  }
+  return 0;
+}
+
+void
+remap_dynamic(Elf32_Shdr *dynamic, Elf32_Word new_dynstr_size)
+{
+  Elf32_Dyn *element;
+  Elf32_Word entry_size;
+  Elf32_Word rel_size;
+  Elf32_Word rel_entry_size;
+  Elf32_Rel *rel;
+  Elf32_Rela *rela;
+  int jmprel_overlaps;
+  Elf32_Word rel_start, rel_end, jmprel_start, jmprel_end;
+    
+  entry_size = read_word(dynamic->sh_entsize);
+
+  /* Find out if REL/RELA and JMPREL overlaps: */
+  if (get_dynamic_val(dynamic, DT_PLTREL) == DT_REL) {
+    rel_start = get_dynamic_val(dynamic, DT_REL);
+    rel_end = rel_start + get_dynamic_val(dynamic, DT_RELSZ);
+  } else {
+    rel_start = get_dynamic_val(dynamic, DT_RELA);
+    rel_end = rel_start + get_dynamic_val(dynamic, DT_RELASZ);
+  }
+  jmprel_start = get_dynamic_val(dynamic, DT_JMPREL);
+  
+  jmprel_overlaps = 0;
+  if ((jmprel_start >= rel_start) && (jmprel_start < rel_end))
+    jmprel_overlaps = 1;
+    
+  element = (Elf32_Dyn *)FILE_OFFSET(read_word(dynamic->sh_offset));
+  while (read_sword(element->d_tag) != DT_NULL) {
+    switch(read_sword(element->d_tag)) {
+    case DT_STRSZ:
+      write_word(&element->d_un.d_val, new_dynstr_size);
+      break;
+    case DT_PLTGOT:
+    case DT_HASH:
+    case DT_STRTAB:
+    case DT_INIT:
+    case DT_FINI:
+    case DT_VERDEF:
+    case DT_VERNEED:
+    case DT_VERSYM:
+      write_word(&element->d_un.d_ptr,
+		 fixup_addr(read_word(element->d_un.d_ptr)));
+      break;
+    case DT_JMPREL:
+      rel_size = get_dynamic_val(dynamic, DT_PLTRELSZ);
+      if (!jmprel_overlaps) {
+	if (get_dynamic_val(dynamic, DT_PLTREL) == DT_REL) {
+	  rel_entry_size = get_dynamic_val(dynamic, DT_RELENT);
+	  rel = (Elf32_Rel *)FILE_OFFSET(vma_to_offset(read_word(element->d_un.d_ptr)));
+	  remap_rel_section(rel, rel_size, rel_entry_size);
+	} else {
+	  rel_entry_size = get_dynamic_val(dynamic, DT_RELAENT);
+	  rela = (Elf32_Rela *)FILE_OFFSET(vma_to_offset(read_word(element->d_un.d_ptr)));
+	  remap_rela_section(rela, rel_size, rel_entry_size);
+	}
+      }
+      write_word(&element->d_un.d_ptr,
+		 fixup_addr(read_word(element->d_un.d_ptr)));
+      break;
+    case DT_REL:
+      rel_size = get_dynamic_val(dynamic, DT_RELSZ);
+      rel_entry_size = get_dynamic_val(dynamic, DT_RELENT);
+      rel = (Elf32_Rel *)FILE_OFFSET(vma_to_offset(read_word(element->d_un.d_ptr)));
+      remap_rel_section(rel, rel_size, rel_entry_size);
+
+      write_word(&element->d_un.d_ptr,
+		 fixup_addr(read_word(element->d_un.d_ptr)));
+      break;
+    case DT_RELA:
+      rel_size = get_dynamic_val(dynamic, DT_RELASZ);
+      rel_entry_size = get_dynamic_val(dynamic, DT_RELAENT);
+      rela = (Elf32_Rela *)FILE_OFFSET(vma_to_offset(read_word(element->d_un.d_ptr)));
+      remap_rela_section(rela, rel_size, rel_entry_size);
+
+      write_word(&element->d_un.d_ptr,
+		 fixup_addr(read_word(element->d_un.d_ptr)));
+      break;
+    default:
+      /*printf("unhandled d_tag: %d (0x%x)\n", read_sword(element->d_tag), read_sword(element->d_tag));*/
+      break;
+    }
+
+    element = (Elf32_Dyn *)((char *)element + entry_size);
+  }
+}
+
+void
+align_hole(Elf32_Word *start, Elf32_Word *end)
+{
+  Elf32_Word len;
+  Elf32_Word align;
+  Elf32_Shdr *section;
+  Elf32_Word sectionsize;
+  int numsections;
+  int i = 0;
+  int unaligned;
+  
+  len = *end - *start;
+  align = 0;
+    
+  sectionsize = read_half(elf_header->e_shentsize);
+  numsections = read_half(elf_header->e_shnum);
+  do {
+    section = (Elf32_Shdr *)FILE_OFFSET(read_word(elf_header->e_shoff));
+    unaligned = 0;
+    
+    for (i=0;i<numsections;i++) {
+      if ( (read_word(section->sh_addralign) > 1) &&
+	   ( (read_word(section->sh_offset) - len + align)%read_word(section->sh_addralign) != 0) ) {
+	unaligned = 1;
+      }
+      
+      section = (Elf32_Shdr *)((char *)section + sectionsize);
+    }
+
+    if (unaligned) {
+      align++;
+    }
+      
+  } while (unaligned);
+
+  *start += align;
+}
+
+int
+main(int argc, char *argv[])
+{
+  int fd;
+  unsigned char *mapping;
+  Elf32_Word size;
+  struct stat statbuf;
+  Elf32_Shdr *dynamic;
+  Elf32_Shdr *dynsym;
+  Elf32_Shdr *symtab;
+  Elf32_Shdr *dynstr;
+  Elf32_Shdr *hash;
+  Elf32_Shdr *higher_section;
+  Elf32_Word dynstr_index;
+  Elf32_Shdr *ver_r;
+  Elf32_Shdr *ver_d;
+  char *dynstr_data;
+  unsigned char *new_dynstr;
+  Elf32_Word old_dynstr_size;
+  Elf32_Word new_dynstr_size;
+  
+  if (argc != 2) {
+    fprintf(stderr, "Usage: %s <filename>\n", argv[0]);
+    return 1;
+  }
+
+  fd = open(argv[1], O_RDWR);
+  if (fd == -1) {
+    fprintf(stderr, "Cannot open file %s\n", argv[1]);
+    return 1;
+  }
+  
+  if (fstat(fd, &statbuf) == -1) {
+    fprintf(stderr, "Cannot stat file %s\n", argv[1]);
+    return 1;
+  }
+  
+  size = statbuf.st_size;
+    
+  mapping = mmap(0, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+
+  if (mapping == (unsigned char *)-1) {
+    fprintf(stderr, "Cannot mmap file %s\n", argv[1]);
+    return 1;
+  }
+
+  used_dynamic_symbols = g_hash_table_new(g_direct_hash, g_direct_equal);
+
+  elf_header = (Elf32_Ehdr *)mapping;
+
+  if (strncmp((void *)elf_header, ELFMAG, SELFMAG)!=0) {
+    fprintf(stderr, "Not an ELF file\n");
+    return 1;
+  }
+
+  if (elf_header->e_ident[EI_VERSION] != EV_CURRENT) {
+    fprintf(stderr, "Wrong ELF file version\n");
+    return 1;
+  }
+
+  if (elf_header->e_ident[EI_CLASS] != ELFCLASS32) {
+    fprintf(stderr, "Only 32bit ELF files supported\n");
+    return 1;
+  }
+  
+  setup_byteswapping(elf_header->e_ident[EI_DATA]);
+
+  machine_type = read_half(elf_header->e_machine);
+  if ( (machine_type != EM_386) &&
+       (machine_type != EM_PPC) ) {
+    fprintf(stderr, "Unsupported architecture. Supported are: x86, ppc\n");
+    return 1;
+  }
+
+  if (read_half(elf_header->e_type) != ET_DYN) {
+    fprintf(stderr, "Not an ELF shared object\n");
+    return 1;
+  }
+  
+  dynamic = elf_find_section(SHT_DYNAMIC);
+  dynsym = elf_find_section(SHT_DYNSYM);
+  symtab = elf_find_section(SHT_SYMTAB);
+  dynstr_index = read_word(dynsym->sh_link);
+  dynstr = elf_find_section_num(dynstr_index);
+  dynstr_data = (char *)FILE_OFFSET(read_word(dynstr->sh_offset));
+  old_dynstr_size = read_word(dynstr->sh_size);
+  ver_d = elf_find_section(SHT_GNU_verdef);
+  ver_r = elf_find_section(SHT_GNU_verneed);
+  hash = elf_find_section(SHT_HASH);
+
+  /* Generate hash table with all used strings: */
+  
+  add_strings_from_dynsym(dynsym, dynstr_data);
+  add_strings_from_dynamic(dynamic, dynstr_data);
+  if (ver_d && (read_word(ver_d->sh_link) == dynstr_index))
+    add_strings_from_ver_d(ver_d, dynstr_data);
+  if (ver_r && (read_word(ver_r->sh_link) == dynstr_index))
+    add_strings_from_ver_r(ver_r, dynstr_data);
+
+  /* Generate new dynstr section from the used strings hashtable: */
+  
+  new_dynstr = generate_new_dynstr(&new_dynstr_size);
+  /*
+  printf("New dynstr size: %d\n", new_dynstr_size);
+  printf("Old dynstr size: %d\n", old_dynstr_size);
+  */
+  
+  if (new_dynstr_size >= old_dynstr_size) {
+    fprintf(stderr, "Couldn't GC any strings, exiting.\n");
+    return 0;
+  }
+
+  /* Fixup all references: */
+  fixup_strings_in_dynsym(dynsym);
+  fixup_strings_in_dynamic(dynamic);
+  if (ver_d && (read_word(ver_d->sh_link) == dynstr_index))
+    fixup_strings_in_ver_d(ver_d);
+  if (ver_r && (read_word(ver_r->sh_link) == dynstr_index))
+    fixup_strings_in_ver_r(ver_r);
+  
+  /* Copy over the new dynstr: */
+  memcpy(dynstr_data, new_dynstr, new_dynstr_size);
+  memset(dynstr_data + new_dynstr_size, ' ', old_dynstr_size-new_dynstr_size);
+
+  /* Compact the dynstr section and the file: */
+
+  /* 1. Set up the data for the fixup_offset() function: */
+  hole_index = read_word(dynstr->sh_offset) + new_dynstr_size;
+  higher_section = elf_find_next_higher_section(hole_index);
+  hole_end = read_word(higher_section->sh_offset);
+
+  align_hole(&hole_index, &hole_end);
+  hole_len = hole_end - hole_index;
+
+  hole_addr_start = hole_index; /* TODO: Fix this to something better */
+
+  find_segment_addr_min_max(read_word(dynstr->sh_offset),
+			    &hole_addr_remap_start, &hole_addr_remap_end);
+  
+  /*
+  printf("Hole remap: 0x%lx - 0x%lx\n", hole_addr_remap_start, hole_addr_remap_end);
+
+  printf("hole: %lu - %lu (%lu bytes)\n", hole_index, hole_end, hole_len);
+  printf("hole: 0x%lx - 0x%lx (0x%lx bytes)\n", hole_index, hole_end, hole_len);
+  */
+  
+  /* 2. Change all section and segment sizes and offsets: */
+  remap_symtab(dynsym);
+  if (symtab)
+    remap_symtab(symtab);
+
+  if (machine_type == EM_386)
+    remap_i386_got();
+  if (machine_type == EM_PPC)
+    remap_ppc_got();
+  
+  remap_dynamic(dynamic, new_dynstr_size);
+  remap_sections(); /* After this line the section headers are wrong */
+  remap_segments();
+  remap_elf_header();
+    
+  /* 3. Do the real compacting. */
+
+  memmove(mapping + hole_index,
+	  mapping + hole_index + hole_len,
+	  size - (hole_index + hole_len));
+  
+  munmap(mapping, size);
+
+  ftruncate(fd, size - hole_len);
+  close(fd);
+
+  return 0;
+}
+
+
+
diff -r 17e9560465b0 js/src/config/fastcwd.pl
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/fastcwd.pl	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,66 @@
+#!perl5
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+# Netscape Communications Corporation.
+# Portions created by the Initial Developer are Copyright (C) 1998
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+sub fastcwd {
+	local($odev, $oino, $cdev, $cino, $tdev, $tino);
+	local(@path, $path);
+	local(*DIR);
+
+	($cdev, $cino) = stat('.');
+	for (;;) {
+		($odev, $oino) = ($cdev, $cino);
+		chdir('..');
+		($cdev, $cino) = stat('.');
+		last if $odev == $cdev && $oino == $cino;
+		opendir(DIR, '.');
+		for (;;) {
+			$_ = readdir(DIR);
+			next if $_ eq '.';
+			next if $_ eq '..';
+
+			last unless $_;
+			($tdev, $tino) = lstat($_);
+			last unless $tdev != $odev || $tino != $oino;
+		}
+		closedir(DIR);
+		unshift(@path, $_);
+	}
+	chdir($path = '/' . join('/', @path));
+	$path;
+}
+1;
diff -r 17e9560465b0 js/src/config/gcc_hidden.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/gcc_hidden.h	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,2 @@
+/* Begin all files as hidden visibility */
+#pragma GCC visibility push(hidden)
diff -r 17e9560465b0 js/src/config/insure.mk
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/insure.mk	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,53 @@
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+# Netscape Communications Corporation.
+# Portions created by the Initial Developer are Copyright (C) 1998
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+INCLUDED_INSURE_MK = 1
+
+INSURE_MATCH_SCRIPT=$(topsrcdir)/build/autoconf/match-dir.sh
+
+INSURE_EXCLUDE=$(shell $(INSURE_MATCH_SCRIPT) $(MOZ_INSURE_EXCLUDE_DIRS))
+
+INSURE_INCLUDE=$(shell $(INSURE_MATCH_SCRIPT) $(MOZ_INSURE_DIRS))
+
+ifeq ($(INSURE_EXCLUDE),0)
+
+ifeq ($(INSURE_INCLUDE),1)
+CC		:= $(MOZ_INSURE)
+CXX		:= $(MOZ_INSURE)
+endif # INSURE_INCLUDE == 1
+
+endif # INSURE_EXCLUDE == 0
diff -r 17e9560465b0 js/src/config/make-system-wrappers.pl
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/make-system-wrappers.pl	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,59 @@
+#!/usr/bin/perl
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+# IBM Corporation.
+# Portions created by the Initial Developer are Copyright (C) 2004
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Brian Ryner <bryner@brianryner.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+$output_dir = shift;
+
+while (<STDIN>) {
+    chomp;
+    if (-e "$output_dir/$_") {
+	next;
+    }
+
+    if (/(.*)\/[^\/*]/) {
+	mkdir "$output_dir/$1";
+    }
+
+    open OUT, ">$output_dir/$_";
+    print OUT "#pragma GCC system_header\n";  # suppress include_next warning
+    print OUT "#pragma GCC visibility push(default)\n";
+    print OUT "#include_next \<$_\>\n";
+    print OUT "#pragma GCC visibility pop\n";
+    close OUT;
+}
+
diff -r 17e9560465b0 js/src/config/milestone.pl
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/milestone.pl	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,112 @@
+#!/usr/bin/perl -w
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Win32 Version System.
+#
+# The Initial Developer of the Original Code is Netscape Communications Corporation
+# Portions created by the Initial Developer are Copyright (C) 2002
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+use Getopt::Long;
+
+use strict;
+use vars qw(
+            $OBJDIR
+            $SRCDIR
+            $TOPSRCDIR
+            $SCRIPTDIR
+            @TEMPLATE_FILE
+            $MILESTONE_FILE
+            $MILESTONE
+            $MILESTONE_NUM
+            @MILESTONE_PARTS
+            $MINI_VERSION
+            $MICRO_VERSION
+            $opt_debug
+            $opt_template
+            $opt_help
+            );
+
+$SCRIPTDIR = $0;
+$SCRIPTDIR =~ s/[^\/]*$//;
+push(@INC,$SCRIPTDIR);
+
+require "Moz/Milestone.pm";
+
+&GetOptions('topsrcdir=s' => \$TOPSRCDIR, 'srcdir=s' => \$SRCDIR, 'objdir=s' => \$OBJDIR, 'debug', 'help', 'template');
+
+if (defined($opt_help)) {
+    &usage();
+    exit;
+}
+
+if (defined($opt_template)) {
+    @TEMPLATE_FILE = @ARGV;
+    if ($opt_debug) {
+        print("TEMPLATE_FILE = --@TEMPLATE_FILE--\n");
+    }
+}
+
+if (!defined($SRCDIR)) { $SRCDIR = '.'; }
+if (!defined($OBJDIR)) { $OBJDIR = '.'; }
+
+$MILESTONE_FILE  = "$TOPSRCDIR/config/milestone.txt";
+@MILESTONE_PARTS = (0, 0, 0, 0);
+
+#
+# Grab milestone (top line of $MILESTONE_FILE that starts with a digit)
+#
+my $milestone = Moz::Milestone::getOfficialMilestone($MILESTONE_FILE);
+
+if (defined(@TEMPLATE_FILE)) {
+  my $TFILE;
+
+  foreach $TFILE (@TEMPLATE_FILE) {
+    my $BUILT_FILE = "$OBJDIR/$TFILE";
+    $TFILE = "$SRCDIR/$TFILE.tmpl";
+
+    if (-e $TFILE) {
+
+      Moz::Milestone::build_file($TFILE,$BUILT_FILE);
+
+    } else {
+      warn("$0:  No such file $TFILE!\n");
+    }
+  }
+} else {
+  print "$milestone\n";
+}
+
+sub usage() {
+  print <<END
+`milestone.pl [--topsrcdir TOPSRCDIR] [--objdir OBJDIR] [--srcdir SRCDIR] --template [file list]`  # will build file list from .tmpl files
+END
+    ;
+}
diff -r 17e9560465b0 js/src/config/milestone.txt
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/milestone.txt	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,13 @@
+# Holds the current milestone.
+# Should be in the format of
+#
+#    x.x.x
+#    x.x.x.x
+#    x.x.x+
+#
+# Referenced by milestone.pl.
+# Hopefully I'll be able to automate replacement of *all*
+# hardcoded milestones in the tree from these two files.
+#--------------------------------------------------------
+
+1.9.1b2pre
diff -r 17e9560465b0 js/src/config/mkdepend/Makefile.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/mkdepend/Makefile.in	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,84 @@
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+# Netscape Communications Corporation.
+# Portions created by the Initial Developer are Copyright (C) 1998
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+# undefine (as best we can, thanks gmake!) so we don't need build_number
+MOZILLA_OFFICIAL =
+BUILD_OFFICIAL   =
+MODULE		 = mkdepend
+HOST_PROGRAM	 = mkdepend$(BIN_SUFFIX)
+ifdef GNU_CC
+MODULE_OPTIMIZE_FLAGS = -O3
+else
+ifeq ($(OS_ARCH),SunOS)
+MODULE_OPTIMIZE_FLAGS = -fast
+endif
+endif
+
+ifeq ($(OS_ARCH),WINNT)
+ifndef GNU_CC
+MODULE_OPTIMIZE_FLAGS = -Ox
+endif
+endif
+
+HOST_CSRCS	= \
+		cppsetup.c \
+		ifparser.c \
+		include.c \
+		main.c \
+		parse.c \
+		pr.c \
+		$(NULL)
+
+include $(topsrcdir)/config/rules.mk
+
+HOST_CFLAGS	+= -DINCLUDEDIR=\"/usr/include\" -DOBJSUFFIX=\".$(OBJ_SUFFIX)\"
+
+ifdef GNU_CC
+_GCCDIR		= $(shell $(CC) -print-file-name=include)
+HOST_CFLAGS	+= -DPREINCDIR=\"$(_GCCDIR)\"
+endif
+
+export:: $(HOST_PROGRAM)
+
+$(HOST_OBJS): def.h ifparser.h imakemdep.h
diff -r 17e9560465b0 js/src/config/mkdepend/cppsetup.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/mkdepend/cppsetup.c	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,233 @@
+/* $Xorg: cppsetup.c,v 1.5 2001/02/09 02:03:16 xorgcvs Exp $ */
+/*
+
+Copyright (c) 1993, 1994, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+*/
+/* $XFree86: xc/config/makedepend/cppsetup.c,v 3.11 2001/12/17 20:52:22 dawes Exp $ */
+
+#include "def.h"
+
+#ifdef	CPP
+/*
+ * This file is strictly for the sake of cpy.y and yylex.c (if
+ * you indeed have the source for cpp).
+ */
+#define IB 1
+#define SB 2
+#define NB 4
+#define CB 8
+#define QB 16
+#define WB 32
+#define SALT '#'
+#if defined(pdp11) || defined(vax) || defined(ns16000) || defined(mc68000) || defined(ibm032)
+#define COFF 128
+#else
+#define COFF 0
+#endif
+/*
+ * These variables used by cpy.y and yylex.c
+ */
+extern char	*outp, *inp, *newp, *pend;
+extern char	*ptrtab;
+extern char	fastab[];
+extern char	slotab[];
+
+/*
+ * cppsetup
+ */
+struct filepointer	*currentfile;
+struct inclist		*currentinc;
+
+int
+cppsetup(char *line, struct filepointer *filep, struct inclist *inc)
+{
+	char *p, savec;
+	static boolean setupdone = FALSE;
+	boolean	value;
+
+	if (!setupdone) {
+		cpp_varsetup();
+		setupdone = TRUE;
+	}
+
+	currentfile = filep;
+	currentinc = inc;
+	inp = newp = line;
+	for (p=newp; *p; p++)
+		;
+
+	/*
+	 * put a newline back on the end, and set up pend, etc.
+	 */
+	*p++ = '\n';
+	savec = *p;
+	*p = '\0';
+	pend = p;
+
+	ptrtab = slotab+COFF;
+	*--inp = SALT; 
+	outp=inp; 
+	value = yyparse();
+	*p = savec;
+	return(value);
+}
+
+struct symtab **lookup(symbol)
+	char	*symbol;
+{
+	static struct symtab    *undefined;
+	struct symtab   **sp;
+
+	sp = isdefined(symbol, currentinc, NULL);
+	if (sp == NULL) {
+		sp = &undefined;
+		(*sp)->s_value = NULL;
+	}
+	return (sp);
+}
+
+pperror(tag, x0,x1,x2,x3,x4)
+	int	tag,x0,x1,x2,x3,x4;
+{
+	warning("\"%s\", line %d: ", currentinc->i_file, currentfile->f_line);
+	warning(x0,x1,x2,x3,x4);
+}
+
+
+yyerror(s)
+	register char	*s;
+{
+	fatalerr("Fatal error: %s\n", s);
+}
+#else /* not CPP */
+
+#include "ifparser.h"
+struct _parse_data {
+    struct filepointer *filep;
+    struct inclist *inc;
+    char *filename;
+    const char *line;
+};
+
+static const char *
+my_if_errors (IfParser *ip, const char *cp, const char *expecting)
+{
+    struct _parse_data *pd = (struct _parse_data *) ip->data;
+    int lineno = pd->filep->f_line;
+    char *filename = pd->filename;
+    char prefix[300];
+    int prefixlen;
+    int i;
+
+    sprintf (prefix, "\"%s\":%d", filename, lineno);
+    prefixlen = strlen(prefix);
+    fprintf (stderr, "%s:  %s", prefix, pd->line);
+    i = cp - pd->line;
+    if (i > 0 && pd->line[i-1] != '\n') {
+	putc ('\n', stderr);
+    }
+    for (i += prefixlen + 3; i > 0; i--) {
+	putc (' ', stderr);
+    }
+    fprintf (stderr, "^--- expecting %s\n", expecting);
+    return NULL;
+}
+
+
+#define MAXNAMELEN 256
+
+static struct symtab **
+lookup_variable (IfParser *ip, const char *var, int len)
+{
+    char tmpbuf[MAXNAMELEN + 1];
+    struct _parse_data *pd = (struct _parse_data *) ip->data;
+
+    if (len > MAXNAMELEN)
+	return 0;
+
+    strncpy (tmpbuf, var, len);
+    tmpbuf[len] = '\0';
+    return isdefined (tmpbuf, pd->inc, NULL);
+}
+
+
+static int
+my_eval_defined (IfParser *ip, const char *var, int len)
+{
+    if (lookup_variable (ip, var, len))
+	return 1;
+    else
+	return 0;
+}
+
+#define isvarfirstletter(ccc) (isalpha(ccc) || (ccc) == '_')
+
+static long
+my_eval_variable (IfParser *ip, const char *var, int len)
+{
+    long val;
+    struct symtab **s;
+
+    s = lookup_variable (ip, var, len);
+    if (!s)
+	return 0;
+    do {
+	var = (*s)->s_value;
+	if (!isvarfirstletter(*var) || !strcmp((*s)->s_name, var))
+	    break;
+	s = lookup_variable (ip, var, strlen(var));
+    } while (s);
+
+    var = ParseIfExpression(ip, var, &val);
+    if (var && *var) debug(4, ("extraneous: '%s'\n", var));
+    return val;
+}
+
+int
+cppsetup(char *filename,
+	 char *line,
+	 struct filepointer *filep,
+	 struct inclist *inc)
+{
+    IfParser ip;
+    struct _parse_data pd;
+    long val = 0;
+
+    pd.filep = filep;
+    pd.inc = inc;
+    pd.line = line;
+    pd.filename = filename;
+    ip.funcs.handle_error = my_if_errors;
+    ip.funcs.eval_defined = my_eval_defined;
+    ip.funcs.eval_variable = my_eval_variable;
+    ip.data = (char *) &pd;
+
+    (void) ParseIfExpression (&ip, line, &val);
+    if (val)
+	return IF;
+    else
+	return IFFALSE;
+}
+#endif /* CPP */
+
diff -r 17e9560465b0 js/src/config/mkdepend/def.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/mkdepend/def.h	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,184 @@
+/* $Xorg: def.h,v 1.4 2001/02/09 02:03:16 xorgcvs Exp $ */
+/*
+
+Copyright (c) 1993, 1994, 1998 The Open Group.
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+*/
+/* $XFree86: xc/config/makedepend/def.h,v 3.14 2003/01/17 17:09:49 tsi Exp $ */
+
+#ifndef NO_X11
+#include <X11/Xos.h>
+#include <X11/Xfuncproto.h>
+#endif
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#if 0
+#ifndef X_NOT_POSIX
+#ifndef _POSIX_SOURCE
+#define _POSIX_SOURCE
+#endif
+#endif
+#endif
+#include <sys/types.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+
+#define MAXDEFINES	512
+#define MAXFILES	1024
+#define MAXINCFILES	256	/* "-include" files */
+#define MAXDIRS		1024
+#define SYMTABINC	10	/* must be > 1 for define() to work right */
+#define	TRUE		1
+#define	FALSE		0
+
+/* the following must match the directives table in main.c */
+#define	IF		0
+#define	IFDEF		1
+#define	IFNDEF		2
+#define	ELSE		3
+#define	ENDIF		4
+#define	DEFINE		5
+#define	UNDEF		6
+#define	INCLUDE		7
+#define	LINE		8
+#define	PRAGMA		9
+#define ERROR           10
+#define IDENT           11
+#define SCCS            12
+#define ELIF            13
+#define EJECT           14
+#define WARNING         15
+#define INCLUDENEXT     16
+#define IFFALSE         17     /* pseudo value --- never matched */
+#define ELIFFALSE       18     /* pseudo value --- never matched */
+#define INCLUDEDOT      19     /* pseudo value --- never matched */
+#define IFGUESSFALSE    20     /* pseudo value --- never matched */
+#define ELIFGUESSFALSE  21     /* pseudo value --- never matched */
+#define INCLUDENEXTDOT  22     /* pseudo value --- never matched */
+
+#ifdef DEBUG
+extern int	_debugmask;
+/*
+ * debug levels are:
+ * 
+ *     0	show ifn*(def)*,endif
+ *     1	trace defined/!defined
+ *     2	show #include
+ *     3	show #include SYMBOL
+ *     4-6	unused
+ */
+#define debug(level,arg) { if (_debugmask & (1 << level)) warning arg; }
+#else
+#define	debug(level,arg) /**/
+#endif /* DEBUG */
+
+typedef	unsigned char boolean;
+
+struct symtab {
+	char	*s_name;
+	char	*s_value;
+};
+
+/* possible i_flag */
+#define DEFCHECKED	(1<<0)	/* whether defines have been checked */
+#define NOTIFIED	(1<<1)	/* whether we have revealed includes */
+#define MARKED		(1<<2)	/* whether it's in the makefile */
+#define SEARCHED	(1<<3)	/* whether we have read this */
+#define FINISHED	(1<<4)	/* whether we are done reading this */
+#define INCLUDED_SYM	(1<<5)	/* whether #include SYMBOL was found
+				   Can't use i_list if TRUE */
+struct	inclist {
+	char		*i_incstring;	/* string from #include line */
+	char		*i_file;	/* path name of the include file */
+	struct inclist	**i_list;	/* list of files it itself includes */
+	int		i_listlen;	/* length of i_list */
+	struct symtab	**i_defs;	/* symbol table for this file and its
+					   children when merged */
+	int		i_ndefs;	/* current # defines */
+	boolean		*i_merged;      /* whether we have merged child
+					   defines */
+	unsigned char   i_flags;
+};
+
+struct filepointer {
+	char	*f_name;
+	char	*f_p;
+	char	*f_base;
+	char	*f_end;
+	long	f_len;
+	long	f_line;
+	long	cmdinc_count;
+	char	**cmdinc_list;
+	long	cmdinc_line;
+};
+
+#include <stdlib.h>
+#if defined(macII) && !defined(__STDC__)  /* stdlib.h fails to define these */
+char *malloc(), *realloc();
+#endif /* macII */
+
+char			*copy(char *str);
+int                     match(char *str, char **list);
+char			*base_name(char *file);
+char			*getnextline(struct filepointer *fp);
+struct symtab		**slookup(char *symbol, struct inclist *file);
+struct symtab		**isdefined(char *symbol, struct inclist *file,
+				    struct inclist **srcfile);
+struct symtab		**fdefined(char *symbol, struct inclist *file,
+				   struct inclist **srcfile);
+struct filepointer	*getfile(char *file);
+void                    included_by(struct inclist *ip, 
+				    struct inclist *newfile);
+struct inclist		*newinclude(char *newfile, char *incstring);
+void                    inc_clean (void);
+struct inclist		*inc_path(char *file, char *include, int type);
+
+void                    freefile(struct filepointer *fp);
+
+void                    define2(char *name, char *val, struct inclist *file);
+void                    define(char *def, struct inclist *file);
+void                    undefine(char *symbol, struct inclist *file);
+int                     find_includes(struct filepointer *filep, 
+				      struct inclist *file, 
+				      struct inclist *file_red, 
+				      int recursion, boolean failOK);
+
+void                    recursive_pr_include(struct inclist *head, 
+					     char *file, char *base);
+void                    add_include(struct filepointer *filep, 
+				    struct inclist *file, 
+				    struct inclist *file_red, 
+				    char *include, int type,
+				    boolean failOK);
+
+int                     cppsetup(char *filename,
+				 char *line,
+				 struct filepointer *filep,
+				 struct inclist *inc);
+
+
+extern void fatalerr(char *, ...);
+extern void warning(char *, ...);
+extern void warning1(char *, ...);
diff -r 17e9560465b0 js/src/config/mkdepend/ifparser.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/mkdepend/ifparser.c	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,549 @@
+/*
+ * $Xorg: ifparser.c,v 1.3 2000/08/17 19:41:50 cpqbld Exp $
+ *
+ * Copyright 1992 Network Computing Devices, Inc.
+ * 
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation for any purpose and without fee is hereby granted, provided
+ * that the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Network Computing Devices may not be
+ * used in advertising or publicity pertaining to distribution of the software
+ * without specific, written prior permission.  Network Computing Devices makes
+ * no representations about the suitability of this software for any purpose.
+ * It is provided ``as is'' without express or implied warranty.
+ * 
+ * NETWORK COMPUTING DEVICES DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS,
+ * IN NO EVENT SHALL NETWORK COMPUTING DEVICES BE LIABLE FOR ANY SPECIAL,
+ * INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
+ * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
+ * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ * 
+ * Author:  Jim Fulton
+ *          Network Computing Devices, Inc.
+ * 
+ * Simple if statement processor
+ *
+ * This module can be used to evaluate string representations of C language
+ * if constructs.  It accepts the following grammar:
+ * 
+ *     EXPRESSION	:=	VALUE
+ * 			 |	VALUE  BINOP	EXPRESSION
+ *			 |	VALUE	'?'	EXPRESSION ':'	EXPRESSION
+ * 
+ *     VALUE		:=	'('  EXPRESSION  ')'
+ * 			 |	'!'  VALUE
+ * 			 |	'-'  VALUE
+ * 			 |	'+'  VALUE
+ *			 |	'~'  VALUE
+ * 			 |	'defined'  '('  variable  ')'
+ * 			 |	'defined'  variable
+ *			 |	# variable '(' variable-list ')'
+ * 			 |	variable
+ * 			 |	number
+ * 
+ *     BINOP		:=	'*'	|  '/'	|  '%'
+ * 			 |	'+'	|  '-'
+ * 			 |	'<<'	|  '>>'
+ * 			 |	'<'	|  '>'	|  '<='  |  '>='
+ * 			 |	'=='	|  '!='
+ * 			 |	'&'	|  '^'  |  '|'
+ * 			 |	'&&'	|  '||'
+ * 
+ * The normal C order of precedence is supported.
+ * 
+ * 
+ * External Entry Points:
+ * 
+ *     ParseIfExpression		parse a string for #if
+ */
+/* $XFree86: xc/config/makedepend/ifparser.c,v 3.11 2002/09/23 01:48:08 tsi Exp $ */
+
+#include "ifparser.h"
+#include <ctype.h>
+#include <stdlib.h>
+#include <string.h>
+
+/****************************************************************************
+		   Internal Macros and Utilities for Parser
+ ****************************************************************************/
+
+#define DO(val) if (!(val)) return NULL
+#define CALLFUNC(ggg,fff) (*((ggg)->funcs.fff))
+#define SKIPSPACE(ccc) while (isspace(*ccc)) ccc++
+#define isvarfirstletter(ccc) (isalpha(ccc) || (ccc) == '_')
+
+
+static const char *
+parse_variable (IfParser *g, const char *cp, const char **varp)
+{
+    SKIPSPACE (cp);
+
+    if (!isvarfirstletter (*cp))
+	return CALLFUNC(g, handle_error) (g, cp, "variable name");
+
+    *varp = cp;
+    /* EMPTY */
+    for (cp++; isalnum(*cp) || *cp == '_'; cp++) ;
+    return cp;
+}
+
+
+static const char *
+parse_number (IfParser *g, const char *cp, long *valp)
+{
+    long base = 10;
+    SKIPSPACE (cp);
+
+    if (!isdigit(*cp))
+	return CALLFUNC(g, handle_error) (g, cp, "number");
+
+    *valp = 0;
+
+    if (*cp == '0') {
+	cp++;
+	if ((*cp == 'x') || (*cp == 'X')) {
+	    base = 16;
+	    cp++;
+	} else {
+	    base = 8;
+	}
+    }
+
+    /* Ignore overflows and assume ASCII, what source is usually written in */
+    while (1) {
+	int increment = -1;
+	if (base == 8) {
+	    if ((*cp >= '0') && (*cp <= '7'))
+		increment = *cp++ - '0';
+	} else if (base == 16) {
+	    if ((*cp >= '0') && (*cp <= '9'))
+		increment = *cp++ - '0';
+	    else if ((*cp >= 'A') &&  (*cp <= 'F'))
+		increment = *cp++ - ('A' - 10);
+	    else if ((*cp >= 'a') && (*cp <= 'f'))
+		increment = *cp++ - ('a' - 10);
+	} else {	/* Decimal */
+	    if ((*cp >= '0') && (*cp <= '9'))
+		increment = *cp++ - '0';
+	}
+	if (increment < 0)
+	    break;
+	*valp = (*valp * base) + increment;
+    }
+
+    /* Skip trailing qualifiers */
+    while (*cp == 'U' || *cp == 'u' || *cp == 'L' || *cp == 'l') cp++;
+    return cp;
+}
+
+static const char *
+parse_character (IfParser *g, const char *cp, long *valp)
+{
+    char val;
+
+    SKIPSPACE (cp);
+    if (*cp == '\\')
+	switch (cp[1]) {
+	case 'n': val = '\n'; break;
+	case 't': val = '\t'; break;
+	case 'v': val = '\v'; break;
+	case 'b': val = '\b'; break;
+	case 'r': val = '\r'; break;
+	case 'f': val = '\f'; break;
+	case 'a': val = '\a'; break;
+	case '\\': val = '\\'; break;
+	case '?': val = '\?'; break;
+	case '\'': val = '\''; break;
+	case '\"': val = '\"'; break;
+	case 'x': val = (char) strtol (cp + 2, NULL, 16); break;
+	default: val = (char) strtol (cp + 1, NULL, 8); break;
+	}
+    else
+	val = *cp;
+    while (*cp != '\'') cp++;
+    *valp = (long) val;
+    return cp;
+}
+
+static const char *
+parse_value (IfParser *g, const char *cp, long *valp)
+{
+    const char *var, *varend;
+
+    *valp = 0;
+
+    SKIPSPACE (cp);
+    if (!*cp)
+	return cp;
+
+    switch (*cp) {
+      case '(':
+	DO (cp = ParseIfExpression (g, cp + 1, valp));
+	SKIPSPACE (cp);
+	if (*cp != ')') 
+	    return CALLFUNC(g, handle_error) (g, cp, ")");
+
+	return cp + 1;			/* skip the right paren */
+
+      case '!':
+	DO (cp = parse_value (g, cp + 1, valp));
+	*valp = !(*valp);
+	return cp;
+
+      case '-':
+	DO (cp = parse_value (g, cp + 1, valp));
+	*valp = -(*valp);
+	return cp;
+
+      case '+':
+	DO (cp = parse_value (g, cp + 1, valp));
+	return cp;
+
+      case '~':
+	DO (cp = parse_value (g, cp + 1, valp));
+	*valp = ~(*valp);
+	return cp;
+
+      case '#':
+	DO (cp = parse_variable (g, cp + 1, &var));
+	SKIPSPACE (cp);
+	if (*cp != '(')
+	    return CALLFUNC(g, handle_error) (g, cp, "(");
+	do {
+	    DO (cp = parse_variable (g, cp + 1, &var));
+	    SKIPSPACE (cp);
+	} while (*cp && *cp != ')');
+	if (*cp != ')')
+	    return CALLFUNC(g, handle_error) (g, cp, ")");
+	*valp = 1; /* XXX */
+	return cp + 1;
+
+      case '\'':
+	DO (cp = parse_character (g, cp + 1, valp));
+	if (*cp != '\'')
+	    return CALLFUNC(g, handle_error) (g, cp, "'");
+	return cp + 1;
+
+      case 'd':
+	if (strncmp (cp, "defined", 7) == 0 && !isalnum(cp[7])) {
+	    int paren = 0;
+	    int len;
+
+	    cp += 7;
+	    SKIPSPACE (cp);
+	    if (*cp == '(') {
+		paren = 1;
+		cp++;
+	    }
+	    DO (cp = parse_variable (g, cp, &var));
+	    len = cp - var;
+	    SKIPSPACE (cp);
+	    if (paren && *cp != ')')
+		return CALLFUNC(g, handle_error) (g, cp, ")");
+	    *valp = (*(g->funcs.eval_defined)) (g, var, len);
+	    return cp + paren;		/* skip the right paren */
+	}
+	/* fall out */
+    }
+
+    if (isdigit(*cp)) {
+	DO (cp = parse_number (g, cp, valp));
+    } else if (!isvarfirstletter(*cp))
+	return CALLFUNC(g, handle_error) (g, cp, "variable or number");
+    else {
+	DO (cp = parse_variable (g, cp, &var));
+	varend = cp;
+	SKIPSPACE(cp);
+	if (*cp != '(') {
+	    *valp = (*(g->funcs.eval_variable)) (g, var, varend - var);
+	} else {
+	    do {
+		long dummy;
+		DO (cp = ParseIfExpression (g, cp + 1, &dummy));
+		SKIPSPACE(cp);
+		if (*cp == ')')
+		    break;
+		if (*cp != ',')
+		    return CALLFUNC(g, handle_error) (g, cp, ",");
+	    } while (1);
+
+	    *valp = 1;	/* XXX */
+	    cp++;
+	}
+    }
+    
+    return cp;
+}
+
+
+
+static const char *
+parse_product (IfParser *g, const char *cp, long *valp)
+{
+    long rightval;
+
+    DO (cp = parse_value (g, cp, valp));
+    SKIPSPACE (cp);
+
+    switch (*cp) {
+      case '*':
+	DO (cp = parse_product (g, cp + 1, &rightval));
+	*valp = (*valp * rightval);
+	break;
+
+      case '/':
+	DO (cp = parse_product (g, cp + 1, &rightval));
+	*valp = (*valp / rightval);
+	break;
+
+      case '%':
+	DO (cp = parse_product (g, cp + 1, &rightval));
+	*valp = (*valp % rightval);
+	break;
+    }
+    return cp;
+}
+
+
+static const char *
+parse_sum (IfParser *g, const char *cp, long *valp)
+{
+    long rightval;
+
+    DO (cp = parse_product (g, cp, valp));
+    SKIPSPACE (cp);
+
+    switch (*cp) {
+      case '+':
+	DO (cp = parse_sum (g, cp + 1, &rightval));
+	*valp = (*valp + rightval);
+	break;
+
+      case '-':
+	DO (cp = parse_sum (g, cp + 1, &rightval));
+	*valp = (*valp - rightval);
+	break;
+    }
+    return cp;
+}
+
+
+static const char *
+parse_shift (IfParser *g, const char *cp, long *valp)
+{
+    long rightval;
+
+    DO (cp = parse_sum (g, cp, valp));
+    SKIPSPACE (cp);
+
+    switch (*cp) {
+      case '<':
+	if (cp[1] == '<') {
+	    DO (cp = parse_shift (g, cp + 2, &rightval));
+	    *valp = (*valp << rightval);
+	}
+	break;
+
+      case '>':
+	if (cp[1] == '>') {
+	    DO (cp = parse_shift (g, cp + 2, &rightval));
+	    *valp = (*valp >> rightval);
+	}
+	break;
+    }
+    return cp;
+}
+
+
+static const char *
+parse_inequality (IfParser *g, const char *cp, long *valp)
+{
+    long rightval;
+
+    DO (cp = parse_shift (g, cp, valp));
+    SKIPSPACE (cp);
+
+    switch (*cp) {
+      case '<':
+	if (cp[1] == '=') {
+	    DO (cp = parse_inequality (g, cp + 2, &rightval));
+	    *valp = (*valp <= rightval);
+	} else {
+	    DO (cp = parse_inequality (g, cp + 1, &rightval));
+	    *valp = (*valp < rightval);
+	}
+	break;
+
+      case '>':
+	if (cp[1] == '=') {
+	    DO (cp = parse_inequality (g, cp + 2, &rightval));
+	    *valp = (*valp >= rightval);
+	} else {
+	    DO (cp = parse_inequality (g, cp + 1, &rightval));
+	    *valp = (*valp > rightval);
+	}
+	break;
+    }
+    return cp;
+}
+
+
+static const char *
+parse_equality (IfParser *g, const char *cp, long *valp)
+{
+    long rightval;
+
+    DO (cp = parse_inequality (g, cp, valp));
+    SKIPSPACE (cp);
+
+    switch (*cp) {
+      case '=':
+	if (cp[1] == '=')
+	    cp++;
+	DO (cp = parse_equality (g, cp + 1, &rightval));
+	*valp = (*valp == rightval);
+	break;
+
+      case '!':
+	if (cp[1] != '=')
+	    break;
+	DO (cp = parse_equality (g, cp + 2, &rightval));
+	*valp = (*valp != rightval);
+	break;
+    }
+    return cp;
+}
+
+
+static const char *
+parse_band (IfParser *g, const char *cp, long *valp)
+{
+    long rightval;
+
+    DO (cp = parse_equality (g, cp, valp));
+    SKIPSPACE (cp);
+
+    switch (*cp) {
+      case '&':
+	if (cp[1] != '&') {
+	    DO (cp = parse_band (g, cp + 1, &rightval));
+	    *valp = (*valp & rightval);
+	}
+	break;
+    }
+    return cp;
+}
+
+
+static const char *
+parse_bxor (IfParser *g, const char *cp, long *valp)
+{
+    long rightval;
+
+    DO (cp = parse_band (g, cp, valp));
+    SKIPSPACE (cp);
+
+    switch (*cp) {
+      case '^':
+	DO (cp = parse_bxor (g, cp + 1, &rightval));
+	*valp = (*valp ^ rightval);
+	break;
+    }
+    return cp;
+}
+
+
+static const char *
+parse_bor (IfParser *g, const char *cp, long *valp)
+{
+    long rightval;
+
+    DO (cp = parse_bxor (g, cp, valp));
+    SKIPSPACE (cp);
+
+    switch (*cp) {
+      case '|':
+	if (cp[1] != '|') {
+	    DO (cp = parse_bor (g, cp + 1, &rightval));
+	    *valp = (*valp | rightval);
+	}
+	break;
+    }
+    return cp;
+}
+
+
+static const char *
+parse_land (IfParser *g, const char *cp, long *valp)
+{
+    long rightval;
+
+    DO (cp = parse_bor (g, cp, valp));
+    SKIPSPACE (cp);
+
+    switch (*cp) {
+      case '&':
+	if (cp[1] != '&')
+	    return CALLFUNC(g, handle_error) (g, cp, "&&");
+	DO (cp = parse_land (g, cp + 2, &rightval));
+	*valp = (*valp && rightval);
+	break;
+    }
+    return cp;
+}
+
+
+static const char *
+parse_lor (IfParser *g, const char *cp, long *valp)
+{
+    long rightval;
+
+    DO (cp = parse_land (g, cp, valp));
+    SKIPSPACE (cp);
+
+    switch (*cp) {
+      case '|':
+	if (cp[1] != '|')
+	    return CALLFUNC(g, handle_error) (g, cp, "||");
+	DO (cp = parse_lor (g, cp + 2, &rightval));
+	*valp = (*valp || rightval);
+	break;
+    }
+    return cp;
+}
+
+
+static const char *
+parse_cond(IfParser *g, const char *cp, long *valp)
+{
+    long trueval, falseval;
+
+    DO (cp = parse_lor (g, cp, valp));
+    SKIPSPACE (cp);
+
+    switch (*cp) {
+      case '?':
+	DO (cp = parse_cond (g, cp + 1, &trueval));
+	SKIPSPACE (cp);
+	if (*cp != ':')
+	    return CALLFUNC(g, handle_error) (g, cp, ":");
+	DO (cp = parse_cond (g, cp + 1, &falseval));
+	*valp = (*valp ? trueval : falseval);
+	break;
+    }
+    return cp;
+}
+
+
+/****************************************************************************
+			     External Entry Points
+ ****************************************************************************/
+
+const char *
+ParseIfExpression (IfParser *g, const char *cp, long *valp)
+{
+    return parse_cond (g, cp, valp);
+}
diff -r 17e9560465b0 js/src/config/mkdepend/ifparser.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/mkdepend/ifparser.h	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,83 @@
+/*
+ * $Xorg: ifparser.h,v 1.3 2000/08/17 19:41:51 cpqbld Exp $
+ *
+ * Copyright 1992 Network Computing Devices, Inc.
+ * 
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation for any purpose and without fee is hereby granted, provided
+ * that the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Network Computing Devices may not be
+ * used in advertising or publicity pertaining to distribution of the software
+ * without specific, written prior permission.  Network Computing Devices makes
+ * no representations about the suitability of this software for any purpose.
+ * It is provided ``as is'' without express or implied warranty.
+ * 
+ * NETWORK COMPUTING DEVICES DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS,
+ * IN NO EVENT SHALL NETWORK COMPUTING DEVICES BE LIABLE FOR ANY SPECIAL,
+ * INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
+ * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
+ * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ * 
+ * Author:  Jim Fulton
+ *          Network Computing Devices, Inc.
+ * 
+ * Simple if statement processor
+ *
+ * This module can be used to evaluate string representations of C language
+ * if constructs.  It accepts the following grammar:
+ * 
+ *     EXPRESSION	:=	VALUE
+ * 			 |	VALUE  BINOP	EXPRESSION
+ *			 |	VALUE	'?'	EXPRESSION ':'	EXPRESSION
+ * 
+ *     VALUE		:=	'('  EXPRESSION  ')'
+ * 			 |	'!'  VALUE
+ * 			 |	'-'  VALUE
+ *			 |	'~'  VALUE
+ * 			 |	'defined'  '('  variable  ')'
+ * 			 |	variable
+ * 			 |	number
+ * 
+ *     BINOP		:=	'*'	|  '/'	|  '%'
+ * 			 |	'+'	|  '-'
+ * 			 |	'<<'	|  '>>'
+ * 			 |	'<'	|  '>'	|  '<='  |  '>='
+ * 			 |	'=='	|  '!='
+ * 			 |	'&'	|  '^'  |  '|'
+ * 			 |	'&&'	|  '||'
+ * 
+ * The normal C order of precedence is supported.
+ * 
+ * 
+ * External Entry Points:
+ * 
+ *     ParseIfExpression		parse a string for #if
+ */
+
+/* $XFree86: xc/config/makedepend/ifparser.h,v 3.5 2001/07/25 15:04:40 dawes Exp $ */
+
+#include <stdio.h>
+
+typedef int Bool;
+#define False 0
+#define True 1
+
+typedef struct _if_parser {
+    struct {				/* functions */
+	const char *(*handle_error) (struct _if_parser *, const char *,
+				     const char *);
+	long (*eval_variable) (struct _if_parser *, const char *, int);
+	int (*eval_defined) (struct _if_parser *, const char *, int);
+    } funcs;
+    char *data;
+} IfParser;
+
+const char *ParseIfExpression (
+    IfParser *, 
+    const char *, 
+    long *
+);
+
diff -r 17e9560465b0 js/src/config/mkdepend/imakemdep.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/mkdepend/imakemdep.h	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,733 @@
+
+/* $XConsortium: imakemdep.h,v 1.83 95/04/07 19:47:46 kaleb Exp $ */
+/* $XFree86: xc/config/imake/imakemdep.h,v 3.12 1995/07/08 10:22:17 dawes Exp $ */
+/*
+
+Copyright (c) 1993, 1994  X Consortium
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of the X Consortium shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from the X Consortium.
+
+*/
+
+
+/* 
+ * This file contains machine-dependent constants for the imake utility.
+ * When porting imake, read each of the steps below and add in any necessary
+ * definitions.  In general you should *not* edit ccimake.c or imake.c!
+ */
+
+#ifdef CCIMAKE
+/*
+ * Step 1:  imake_ccflags
+ *     Define any special flags that will be needed to get imake.c to compile.
+ *     These will be passed to the compile along with the contents of the
+ *     make variable BOOTSTRAPCFLAGS.
+ */
+#ifdef hpux
+#ifdef hp9000s800
+#define imake_ccflags "-DSYSV"
+#else
+#define imake_ccflags "-Wc,-Nd4000,-Ns3000 -DSYSV"
+#endif
+#endif
+
+#if defined(macII) || defined(_AUX_SOURCE)
+#define imake_ccflags "-DmacII -DSYSV"
+#endif
+
+#ifdef stellar
+#define imake_ccflags "-DSYSV"
+#endif
+
+#if defined(USL) || defined(Oki) || defined(NCR)
+#define imake_ccflags "-Xc -DSVR4"
+#endif
+
+#ifdef sony
+#if defined(SYSTYPE_SYSV) || defined(_SYSTYPE_SYSV)
+#define imake_ccflags "-DSVR4"
+#else
+#include <sys/param.h>
+#if NEWSOS < 41
+#define imake_ccflags "-Dbsd43 -DNOSTDHDRS"
+#else
+#if NEWSOS < 42
+#define imake_ccflags "-Dbsd43"
+#endif
+#endif
+#endif
+#endif
+
+#ifdef _CRAY
+#define imake_ccflags "-DSYSV -DUSG"
+#endif
+
+#if defined(_IBMR2) || defined(aix)
+#define imake_ccflags "-Daix -DSYSV"
+#endif
+
+#ifdef Mips
+#  if defined(SYSTYPE_BSD) || defined(BSD) || defined(BSD43)
+#    define imake_ccflags "-DBSD43"
+#  else 
+#    define imake_ccflags "-DSYSV"
+#  endif
+#endif 
+
+#ifdef is68k
+#define imake_ccflags "-Dluna -Duniosb"
+#endif
+
+#ifdef SYSV386
+# ifdef SVR4
+#  define imake_ccflags "-Xc -DSVR4"
+# else
+#  define imake_ccflags "-DSYSV"
+# endif
+#endif
+
+#ifdef SVR4
+# ifdef i386
+#  define imake_ccflags "-Xc -DSVR4"
+# endif
+#endif
+
+#ifdef SYSV
+# ifdef i386
+#  define imake_ccflags "-DSYSV"
+# endif
+#endif
+
+#ifdef __convex__
+#define imake_ccflags "-fn -tm c1"
+#endif
+
+#ifdef apollo
+#define imake_ccflags "-DX_NOT_POSIX"
+#endif
+
+#ifdef WIN32
+#define imake_ccflags "-nologo -batch -D__STDC__"
+#endif
+
+#ifdef __uxp__
+#define imake_ccflags "-DSVR4 -DANSICPP"
+#endif
+
+#ifdef __sxg__
+#define imake_ccflags "-DSYSV -DUSG -DNOSTDHDRS"
+#endif
+
+#ifdef sequent
+#define imake_ccflags "-DX_NOT_STDC_ENV -DX_NOT_POSIX"
+#endif
+
+#ifdef _SEQUENT_
+#define imake_ccflags "-DSYSV -DUSG"
+#endif
+
+#if defined(SX) || defined(PC_UX)
+#define imake_ccflags "-DSYSV"
+#endif
+
+#ifdef nec_ews_svr2
+#define imake_ccflags "-DUSG"
+#endif
+
+#if defined(nec_ews_svr4) || defined(_nec_ews_svr4) || defined(_nec_up) || defined(_nec_ft)
+#define imake_ccflags "-DSVR4"
+#endif
+
+#ifdef	MACH
+#define imake_ccflags "-DNOSTDHDRS"
+#endif
+
+/* this is for OS/2 under EMX. This won't work with DOS */
+#if defined(__EMX__) 
+#define imake_ccflags "-DBSD43"
+#endif
+
+#else /* not CCIMAKE */
+#ifndef MAKEDEPEND
+/*
+ * Step 2:  dup2
+ *     If your OS doesn't have a dup2() system call to duplicate one file
+ *     descriptor onto another, define such a mechanism here (if you don't
+ *     already fall under the existing category(ies).
+ */
+#if defined(SYSV) && !defined(_CRAY) && !defined(Mips) && !defined(_SEQUENT_)
+#define	dup2(fd1,fd2)	((fd1 == fd2) ? fd1 : (close(fd2), \
+					       fcntl(fd1, F_DUPFD, fd2)))
+#endif
+
+
+/*
+ * Step 3:  FIXUP_CPP_WHITESPACE
+ *     If your cpp collapses tabs macro expansions into a single space and
+ *     replaces escaped newlines with a space, define this symbol.  This will
+ *     cause imake to attempt to patch up the generated Makefile by looking
+ *     for lines that have colons in them (this is why the rules file escapes
+ *     all colons).  One way to tell if you need this is to see whether or not
+ *     your Makefiles have no tabs in them and lots of @@ strings.
+ */
+#if defined(sun) || defined(SYSV) || defined(SVR4) || defined(hcx) || defined(WIN32) || (defined(AMOEBA) && defined(CROSS_COMPILE))
+#define FIXUP_CPP_WHITESPACE
+#endif
+#ifdef WIN32
+#define REMOVE_CPP_LEADSPACE
+#define INLINE_SYNTAX
+#define MAGIC_MAKE_VARS
+#endif
+#ifdef __minix_vmd
+#define FIXUP_CPP_WHITESPACE
+#endif
+
+/*
+ * Step 4:  USE_CC_E, DEFAULT_CC, DEFAULT_CPP
+ *     If you want to use cc -E instead of cpp, define USE_CC_E.
+ *     If use cc -E but want a different compiler, define DEFAULT_CC.
+ *     If the cpp you need is not in /lib/cpp, define DEFAULT_CPP.
+ */
+#ifdef hpux
+#define USE_CC_E
+#endif
+#ifdef WIN32
+#define USE_CC_E
+#define DEFAULT_CC "cl"
+#endif
+#ifdef apollo
+#define DEFAULT_CPP "/usr/lib/cpp"
+#endif
+#if defined(_IBMR2) && !defined(DEFAULT_CPP)
+#define DEFAULT_CPP "/usr/lpp/X11/Xamples/util/cpp/cpp"
+#endif
+#if defined(sun) && defined(SVR4)
+#define DEFAULT_CPP "/usr/ccs/lib/cpp"
+#endif
+#ifdef __bsdi__
+#define DEFAULT_CPP "/usr/bin/cpp"
+#endif
+#ifdef __uxp__
+#define DEFAULT_CPP "/usr/ccs/lib/cpp"
+#endif
+#ifdef __sxg__
+#define DEFAULT_CPP "/usr/lib/cpp"
+#endif
+#ifdef _CRAY
+#define DEFAULT_CPP "/lib/pcpp"
+#endif
+#if defined(__386BSD__) || defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__)
+#define DEFAULT_CPP "/usr/libexec/cpp"
+#endif
+#ifdef	MACH
+#define USE_CC_E
+#endif
+#ifdef __minix_vmd
+#define DEFAULT_CPP "/usr/lib/cpp"
+#endif
+#if defined(__EMX__)
+/* expects cpp in PATH */
+#define DEFAULT_CPP "cpp"
+#endif
+
+/*
+ * Step 5:  cpp_argv
+ *     The following table contains the flags that should be passed
+ *     whenever a Makefile is being generated.  If your preprocessor 
+ *     doesn't predefine any unique symbols, choose one and add it to the
+ *     end of this table.  Then, do the following:
+ * 
+ *         a.  Use this symbol in Imake.tmpl when setting MacroFile.
+ *         b.  Put this symbol in the definition of BootstrapCFlags in your
+ *             <platform>.cf file.
+ *         c.  When doing a make World, always add "BOOTSTRAPCFLAGS=-Dsymbol" 
+ *             to the end of the command line.
+ * 
+ *     Note that you may define more than one symbol (useful for platforms 
+ *     that support multiple operating systems).
+ */
+
+#define	ARGUMENTS 50	/* number of arguments in various arrays */
+char *cpp_argv[ARGUMENTS] = {
+	"cc",		/* replaced by the actual program to exec */
+	"-I.",		/* add current directory to include path */
+#ifdef unix
+	"-Uunix",	/* remove unix symbol so that filename unix.c okay */
+#endif
+#if defined(__386BSD__) || defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(MACH)
+# ifdef __i386__
+	"-D__i386__",
+# endif
+# ifdef __x86_64__
+	"-D__x86_64__",
+# endif
+# ifdef __GNUC__
+	"-traditional",
+# endif
+#endif
+#ifdef M4330
+	"-DM4330",	/* Tektronix */
+#endif
+#ifdef M4310
+	"-DM4310",	/* Tektronix */
+#endif
+#if defined(macII) || defined(_AUX_SOURCE)
+	"-DmacII",	/* Apple A/UX */
+#endif
+#ifdef USL
+	"-DUSL",	/* USL */
+#endif
+#ifdef sony
+	"-Dsony",	/* Sony */
+#if !defined(SYSTYPE_SYSV) && !defined(_SYSTYPE_SYSV) && NEWSOS < 42
+	"-Dbsd43",
+#endif
+#endif
+#ifdef _IBMR2
+	"-D_IBMR2",	/* IBM RS-6000 (we ensured that aix is defined above */
+#ifndef aix
+#define aix		/* allow BOOTSTRAPCFLAGS="-D_IBMR2" */
+#endif
+#endif /* _IBMR2 */
+#ifdef aix
+	"-Daix",	/* AIX instead of AOS */
+#ifndef ibm
+#define ibm		/* allow BOOTSTRAPCFLAGS="-Daix" */
+#endif
+#endif /* aix */
+#ifdef ibm
+	"-Dibm",	/* IBM PS/2 and RT under both AOS and AIX */
+#endif
+#ifdef luna
+	"-Dluna",	/* OMRON luna 68K and 88K */
+#ifdef luna1
+	"-Dluna1",
+#endif
+#ifdef luna88k		/* need not on UniOS-Mach Vers. 1.13 */
+	"-traditional", /* for some older version            */
+#endif			/* instead of "-DXCOMM=\\#"          */
+#ifdef uniosb
+	"-Duniosb",
+#endif
+#ifdef uniosu
+	"-Duniosu",
+#endif
+#endif /* luna */
+#ifdef _CRAY		/* Cray */
+	"-Ucray",
+#endif
+#ifdef Mips
+	"-DMips",	/* Define and use Mips for Mips Co. OS/mach. */
+# if defined(SYSTYPE_BSD) || defined(BSD) || defined(BSD43)
+	"-DBSD43",	/* Mips RISCOS supports two environments */
+# else
+	"-DSYSV",	/* System V environment is the default */
+# endif
+#endif /* Mips */
+#ifdef MOTOROLA
+	"-DMOTOROLA",    /* Motorola Delta Systems */
+# ifdef SYSV
+	"-DSYSV", 
+# endif
+# ifdef SVR4
+	"-DSVR4",
+# endif
+#endif /* MOTOROLA */
+#ifdef i386
+	"-Di386",
+# ifdef SVR4
+	"-DSVR4",
+# endif
+# ifdef SYSV
+	"-DSYSV",
+#  ifdef ISC
+	"-DISC",
+#   ifdef ISC40
+	"-DISC40",       /* ISC 4.0 */
+#   else
+#    ifdef ISC202
+	"-DISC202",      /* ISC 2.0.2 */
+#    else
+#     ifdef ISC30
+	"-DISC30",       /* ISC 3.0 */
+#     else
+	"-DISC22",       /* ISC 2.2.1 */
+#     endif
+#    endif
+#   endif
+#  endif
+#  ifdef SCO
+	"-DSCO",
+#   ifdef SCO324
+	"-DSCO324",
+#   endif
+#  endif
+# endif
+# ifdef ESIX
+	"-DESIX",
+# endif
+# ifdef ATT
+	"-DATT",
+# endif
+# ifdef DELL
+	"-DDELL",
+# endif
+#endif
+#ifdef SYSV386           /* System V/386 folks, obsolete */
+	"-Di386",
+# ifdef SVR4
+	"-DSVR4",
+# endif
+# ifdef ISC
+	"-DISC",
+#  ifdef ISC40
+	"-DISC40",       /* ISC 4.0 */
+#  else
+#   ifdef ISC202
+	"-DISC202",      /* ISC 2.0.2 */
+#   else
+#    ifdef ISC30
+	"-DISC30",       /* ISC 3.0 */
+#    else
+	"-DISC22",       /* ISC 2.2.1 */
+#    endif
+#   endif
+#  endif
+# endif
+# ifdef SCO
+	"-DSCO",
+#  ifdef SCO324
+	"-DSCO324",
+#  endif
+# endif
+# ifdef ESIX
+	"-DESIX",
+# endif
+# ifdef ATT
+	"-DATT",
+# endif
+# ifdef DELL
+	"-DDELL",
+# endif
+#endif
+#ifdef __osf__
+	"-D__osf__",
+# ifdef __mips__
+	"-D__mips__",
+# endif
+# ifdef __alpha
+	"-D__alpha",
+# endif
+# ifdef __i386__
+	"-D__i386__",
+# endif
+# ifdef __GNUC__
+	"-traditional",
+# endif
+#endif
+#ifdef Oki
+	"-DOki",
+#endif
+#ifdef sun
+#ifdef SVR4
+	"-DSVR4",
+#endif
+#endif
+#ifdef WIN32
+	"-DWIN32",
+	"-nologo",
+	"-batch",
+	"-D__STDC__",
+#endif
+#ifdef NCR
+	"-DNCR",	/* NCR */
+#endif
+#ifdef linux
+        "-traditional",
+        "-Dlinux",
+#endif
+#ifdef __uxp__
+	"-D__uxp__",
+#endif
+#ifdef __sxg__
+	"-D__sxg__",
+#endif
+#ifdef nec_ews_svr2
+	"-Dnec_ews_svr2",
+#endif
+#ifdef AMOEBA
+	"-DAMOEBA",
+# ifdef CROSS_COMPILE
+	"-DCROSS_COMPILE",
+#  ifdef CROSS_i80386
+	"-Di80386",
+#  endif
+#  ifdef CROSS_sparc
+	"-Dsparc",
+#  endif
+#  ifdef CROSS_mc68000
+	"-Dmc68000",
+#  endif
+# else
+#  ifdef i80386
+	"-Di80386",
+#  endif
+#  ifdef sparc
+	"-Dsparc",
+#  endif
+#  ifdef mc68000
+	"-Dmc68000",
+#  endif
+# endif
+#endif
+#ifdef __minix_vmd
+        "-Dminix",
+#endif
+
+#if defined(__EMX__)
+	"-traditional",
+	"-Demxos2",
+#endif
+
+};
+#else /* else MAKEDEPEND */
+/*
+ * Step 6:  predefs
+ *     If your compiler and/or preprocessor define any specific symbols, add
+ *     them to the the following table.  The definition of struct symtab is
+ *     in util/makedepend/def.h.
+ */
+struct symtab	predefs[] = {
+#ifdef apollo
+	{"apollo", "1"},
+#endif
+#ifdef ibm032
+	{"ibm032", "1"},
+#endif
+#ifdef ibm
+	{"ibm", "1"},
+#endif
+#ifdef aix
+	{"aix", "1"},
+#endif
+#ifdef sun
+	{"sun", "1"},
+#endif
+#ifdef sun2
+	{"sun2", "1"},
+#endif
+#ifdef sun3
+	{"sun3", "1"},
+#endif
+#ifdef sun4
+	{"sun4", "1"},
+#endif
+#ifdef sparc
+	{"sparc", "1"},
+#endif
+#ifdef __sparc__
+	{"__sparc__", "1"},
+#endif
+#ifdef hpux
+	{"hpux", "1"},
+#endif
+#ifdef __hpux
+	{"__hpux", "1"},
+#endif
+#ifdef __hp9000s800
+	{"__hp9000s800", "1"},
+#endif
+#ifdef __hp9000s700
+	{"__hp9000s700", "1"},
+#endif
+#ifdef vax
+	{"vax", "1"},
+#endif
+#ifdef VMS
+	{"VMS", "1"},
+#endif
+#ifdef cray
+	{"cray", "1"},
+#endif
+#ifdef CRAY
+	{"CRAY", "1"},
+#endif
+#ifdef _CRAY
+	{"_CRAY", "1"},
+#endif
+#ifdef att
+	{"att", "1"},
+#endif
+#ifdef mips
+	{"mips", "1"},
+#endif
+#ifdef __mips__
+	{"__mips__", "1"},
+#endif
+#ifdef ultrix
+	{"ultrix", "1"},
+#endif
+#ifdef stellar
+	{"stellar", "1"},
+#endif
+#ifdef mc68000
+	{"mc68000", "1"},
+#endif
+#ifdef mc68020
+	{"mc68020", "1"},
+#endif
+#ifdef __GNUC__
+	{"__GNUC__", "1"},
+#endif
+#if __STDC__
+	{"__STDC__", "1"},
+#endif
+#ifdef __HIGHC__
+	{"__HIGHC__", "1"},
+#endif
+#ifdef CMU
+	{"CMU", "1"},
+#endif
+#ifdef luna
+	{"luna", "1"},
+#ifdef luna1
+	{"luna1", "1"},
+#endif
+#ifdef luna2
+	{"luna2", "1"},
+#endif
+#ifdef luna88k
+	{"luna88k", "1"},
+#endif
+#ifdef uniosb
+	{"uniosb", "1"},
+#endif
+#ifdef uniosu
+	{"uniosu", "1"},
+#endif
+#endif
+#ifdef ieeep754
+	{"ieeep754", "1"},
+#endif
+#ifdef is68k
+	{"is68k", "1"},
+#endif
+#ifdef m68k
+        {"m68k", "1"},
+#endif
+#ifdef m88k
+        {"m88k", "1"},
+#endif
+#ifdef __m88k__
+	{"__m88k__", "1"},
+#endif
+#ifdef bsd43
+	{"bsd43", "1"},
+#endif
+#ifdef hcx
+	{"hcx", "1"},
+#endif
+#ifdef sony
+	{"sony", "1"},
+#ifdef SYSTYPE_SYSV
+	{"SYSTYPE_SYSV", "1"},
+#endif
+#ifdef _SYSTYPE_SYSV
+	{"_SYSTYPE_SYSV", "1"},
+#endif
+#endif
+#ifdef __OSF__
+	{"__OSF__", "1"},
+#endif
+#ifdef __osf__
+	{"__osf__", "1"},
+#endif
+#ifdef __alpha
+	{"__alpha", "1"},
+#endif
+#ifdef __DECC
+	{"__DECC",  "1"},
+#endif
+#ifdef __decc
+	{"__decc",  "1"},
+#endif
+#ifdef __uxp__
+	{"__uxp__", "1"},
+#endif
+#ifdef __sxg__
+	{"__sxg__", "1"},
+#endif
+#ifdef _SEQUENT_
+	{"_SEQUENT_", "1"},
+	{"__STDC__", "1"},
+#endif
+#ifdef __bsdi__
+	{"__bsdi__", "1"},
+#endif
+#ifdef nec_ews_svr2
+	{"nec_ews_svr2", "1"},
+#endif
+#ifdef nec_ews_svr4
+	{"nec_ews_svr4", "1"},
+#endif
+#ifdef _nec_ews_svr4
+	{"_nec_ews_svr4", "1"},
+#endif
+#ifdef _nec_up
+	{"_nec_up", "1"},
+#endif
+#ifdef SX
+	{"SX", "1"},
+#endif
+#ifdef nec
+	{"nec", "1"},
+#endif
+#ifdef _nec_ft
+	{"_nec_ft", "1"},
+#endif
+#ifdef PC_UX
+	{"PC_UX", "1"},
+#endif
+#ifdef sgi
+	{"sgi", "1"},
+#endif
+#ifdef __sgi
+	{"__sgi", "1"},
+#endif
+#ifdef __FreeBSD__
+	{"__FreeBSD__", "1"},
+#endif
+#ifdef __NetBSD__
+	{"__NetBSD__", "1"},
+#endif
+#ifdef __OpenBSD__
+	{"__OpenBSD__", "1"},
+#endif
+#ifdef __EMX__
+	{"__EMX__", "1"},
+#endif
+	/* add any additional symbols before this line */
+	{NULL, NULL}
+};
+
+#endif /* MAKEDEPEND */
+#endif /* CCIMAKE */
diff -r 17e9560465b0 js/src/config/mkdepend/include.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/mkdepend/include.c	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,337 @@
+/* $Xorg: include.c,v 1.4 2001/02/09 02:03:16 xorgcvs Exp $ */
+/*
+
+Copyright (c) 1993, 1994, 1998 The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+*/
+/* $XFree86: xc/config/makedepend/include.c,v 3.7 2001/12/14 19:53:20 dawes Exp $ */
+
+
+#include "def.h"
+
+#ifdef _MSC_VER
+#include <windows.h>
+static int
+does_file_exist(char *file)
+{
+  WIN32_FILE_ATTRIBUTE_DATA data;
+  BOOL b = GetFileAttributesExA(file, GetFileExInfoStandard, &data);
+  if (!b)
+    return 0;
+  return (data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0;
+}
+#else
+static int
+does_file_exist(char *file)
+{
+  struct stat sb;
+  return stat(file, &sb) == 0 && !S_ISDIR(sb.st_mode);
+}
+#endif
+
+extern struct	inclist	inclist[ MAXFILES ],
+			*inclistp, *inclistnext;
+extern char	*includedirs[ ],
+		**includedirsnext;
+extern char	*notdotdot[ ];
+extern boolean show_where_not;
+extern boolean warn_multiple;
+
+static boolean
+isdot(char *p)
+{
+	if(p && *p++ == '.' && *p++ == '\0')
+		return(TRUE);
+	return(FALSE);
+}
+
+static boolean
+isdotdot(char *p)
+{
+	if(p && *p++ == '.' && *p++ == '.' && *p++ == '\0')
+		return(TRUE);
+	return(FALSE);
+}
+
+static boolean
+issymbolic(char *dir, char *component)
+{
+#ifdef S_IFLNK
+	struct stat	st;
+	char	buf[ BUFSIZ ], **pp;
+
+	sprintf(buf, "%s%s%s", dir, *dir ? "/" : "", component);
+	for (pp=notdotdot; *pp; pp++)
+		if (strcmp(*pp, buf) == 0)
+			return (TRUE);
+	if (lstat(buf, &st) == 0
+	&& (st.st_mode & S_IFMT) == S_IFLNK) {
+		*pp++ = copy(buf);
+		if (pp >= &notdotdot[ MAXDIRS ])
+			fatalerr("out of .. dirs, increase MAXDIRS\n");
+		return(TRUE);
+	}
+#endif
+	return(FALSE);
+}
+
+/*
+ * Occasionally, pathnames are created that look like .../x/../y
+ * Any of the 'x/..' sequences within the name can be eliminated.
+ * (but only if 'x' is not a symbolic link!!)
+ */
+static void
+remove_dotdot(char *path)
+{
+	register char	*end, *from, *to, **cp;
+	char		*components[ MAXFILES ],
+			newpath[ BUFSIZ ];
+	boolean		component_copied;
+
+	/*
+	 * slice path up into components.
+	 */
+	to = newpath;
+	if (*path == '/')
+		*to++ = '/';
+	*to = '\0';
+	cp = components;
+	for (from=end=path; *end; end++)
+		if (*end == '/') {
+			while (*end == '/')
+				*end++ = '\0';
+			if (*from)
+				*cp++ = from;
+			from = end;
+		}
+	*cp++ = from;
+	*cp = NULL;
+
+	/*
+	 * Recursively remove all 'x/..' component pairs.
+	 */
+	cp = components;
+	while(*cp) {
+		if (!isdot(*cp) && !isdotdot(*cp) && isdotdot(*(cp+1))
+		    && !issymbolic(newpath, *cp))
+		{
+		    char **fp = cp + 2;
+		    char **tp = cp;
+
+		    do 
+			*tp++ = *fp; /* move all the pointers down */
+		    while (*fp++);
+		    if (cp != components)
+			cp--;	/* go back and check for nested ".." */
+		} else {
+		    cp++;
+		}
+	}
+	/*
+	 * Concatenate the remaining path elements.
+	 */
+	cp = components;
+	component_copied = FALSE;
+	while(*cp) {
+		if (component_copied)
+			*to++ = '/';
+		component_copied = TRUE;
+		for (from = *cp; *from; )
+			*to++ = *from++;
+		*to = '\0';
+		cp++;
+	}
+	*to++ = '\0';
+
+	/*
+	 * copy the reconstituted path back to our pointer.
+	 */
+	strcpy(path, newpath);
+}
+
+/*
+ * Add an include file to the list of those included by 'file'.
+ */
+struct inclist *
+newinclude(char *newfile, char *incstring)
+{
+	register struct inclist	*ip;
+
+	/*
+	 * First, put this file on the global list of include files.
+	 */
+	ip = inclistp++;
+	if (inclistp == inclist + MAXFILES - 1)
+		fatalerr("out of space: increase MAXFILES\n");
+	ip->i_file = copy(newfile);
+
+	if (incstring == NULL)
+		ip->i_incstring = ip->i_file;
+	else
+		ip->i_incstring = copy(incstring);
+
+	inclistnext = inclistp;
+	return(ip);
+}
+
+void
+included_by(struct inclist *ip, struct inclist *newfile)
+{
+	register int i;
+
+	if (ip == NULL)
+		return;
+	/*
+	 * Put this include file (newfile) on the list of files included
+	 * by 'file'.  If 'file' is NULL, then it is not an include
+	 * file itself (i.e. was probably mentioned on the command line).
+	 * If it is already on the list, don't stick it on again.
+	 */
+	if (ip->i_list == NULL) {
+		ip->i_list = (struct inclist **)
+			malloc(sizeof(struct inclist *) * ++ip->i_listlen);
+		ip->i_merged = (boolean *)
+		    malloc(sizeof(boolean) * ip->i_listlen);
+	} else {
+		for (i=0; i<ip->i_listlen; i++)
+			if (ip->i_list[ i ] == newfile) {
+			    i = strlen(newfile->i_file);
+			    if (!(ip->i_flags & INCLUDED_SYM) &&
+				!(i > 2 &&
+				  newfile->i_file[i-1] == 'c' &&
+				  newfile->i_file[i-2] == '.'))
+			    {
+				/* only bitch if ip has */
+				/* no #include SYMBOL lines  */
+				/* and is not a .c file */
+				if (warn_multiple)
+				{
+					warning("%s includes %s more than once!\n",
+						ip->i_file, newfile->i_file);
+					warning1("Already have\n");
+					for (i=0; i<ip->i_listlen; i++)
+						warning1("\t%s\n", ip->i_list[i]->i_file);
+				}
+			    }
+			    return;
+			}
+		ip->i_list = (struct inclist **) realloc(ip->i_list,
+			sizeof(struct inclist *) * ++ip->i_listlen);
+		ip->i_merged = (boolean *)
+		    realloc(ip->i_merged, sizeof(boolean) * ip->i_listlen);
+	}
+	ip->i_list[ ip->i_listlen-1 ] = newfile;
+	ip->i_merged[ ip->i_listlen-1 ] = FALSE;
+}
+
+void
+inc_clean (void)
+{
+	register struct inclist *ip;
+
+	for (ip = inclist; ip < inclistp; ip++) {
+		ip->i_flags &= ~MARKED;
+	}
+}
+
+struct inclist *
+inc_path(char *file, char *include, int type)
+{
+	static char		path[ BUFSIZ ];
+	register char		**pp, *p;
+	register struct inclist	*ip;
+
+	/*
+	 * Check all previously found include files for a path that
+	 * has already been expanded.
+	 */
+	if ((type == INCLUDE) || (type == INCLUDEDOT))
+		inclistnext = inclist;
+	ip = inclistnext;
+
+	for (; ip->i_file; ip++) {
+		if ((strcmp(ip->i_incstring, include) == 0) &&
+		    !(ip->i_flags & INCLUDED_SYM)) {
+			inclistnext = ip + 1;
+			return ip;
+		}
+	}
+
+	if (inclistnext == inclist) {
+		/*
+		 * If the path was surrounded by "" or is an absolute path,
+		 * then check the exact path provided.
+		 */
+		if ((type == INCLUDEDOT) ||
+		    (type == INCLUDENEXTDOT) ||
+		    (*include == '/')) {
+			if (does_file_exist(include))
+				return newinclude(include, include);
+			if (show_where_not)
+				warning1("\tnot in %s\n", include);
+		}
+
+		/*
+		 * If the path was surrounded by "" see if this include file is
+		 * in the directory of the file being parsed.
+		 */
+		if ((type == INCLUDEDOT) || (type == INCLUDENEXTDOT)) {
+			for (p=file+strlen(file); p>file; p--)
+				if (*p == '/')
+					break;
+			if (p == file) {
+				strcpy(path, include);
+			} else {
+				strncpy(path, file, (p-file) + 1);
+				path[ (p-file) + 1 ] = '\0';
+				strcpy(path + (p-file) + 1, include);
+			}
+			remove_dotdot(path);
+			if (does_file_exist(path))
+				return newinclude(path, include);
+			if (show_where_not)
+				warning1("\tnot in %s\n", path);
+		}
+	}
+
+	/*
+	 * Check the include directories specified.  Standard include dirs
+	 * should be at the end.
+	 */
+	if ((type == INCLUDE) || (type == INCLUDEDOT))
+		includedirsnext = includedirs;
+	pp = includedirsnext;
+
+	for (; *pp; pp++) {
+		sprintf(path, "%s/%s", *pp, include);
+		remove_dotdot(path);
+		if (does_file_exist(path)) {
+			includedirsnext = pp + 1;
+			return newinclude(path, include);
+		}
+		if (show_where_not)
+			warning1("\tnot in %s\n", path);
+	}
+
+	return NULL;
+}
diff -r 17e9560465b0 js/src/config/mkdepend/main.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/mkdepend/main.c	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,860 @@
+/* $Xorg: main.c,v 1.5 2001/02/09 02:03:16 xorgcvs Exp $ */
+/*
+
+Copyright (c) 1993, 1994, 1998 The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+*/
+/* $XFree86: xc/config/makedepend/main.c,v 3.32 2003/03/26 20:43:48 tsi Exp $ */
+
+#include "def.h"
+#ifdef hpux
+#define sigvec sigvector
+#endif /* hpux */
+
+#ifdef X_POSIX_C_SOURCE
+#define _POSIX_C_SOURCE X_POSIX_C_SOURCE
+#include <signal.h>
+#undef _POSIX_C_SOURCE
+#else
+#if defined(X_NOT_POSIX) || defined(_POSIX_SOURCE)
+#include <signal.h>
+#else
+#define _POSIX_SOURCE
+#include <signal.h>
+#undef _POSIX_SOURCE
+#endif
+#endif
+
+#include <stdarg.h>
+
+#ifdef MINIX
+#define USE_CHMOD	1
+#endif
+
+#ifdef DEBUG
+int	_debugmask;
+#endif
+
+/* #define DEBUG_DUMP */
+#ifdef DEBUG_DUMP
+#define DBG_PRINT(file, fmt, args)   fprintf(file, fmt, args)
+#else
+#define DBG_PRINT(file, fmt, args)   /* empty */
+#endif
+
+#define DASH_INC_PRE    "#include \""
+#define DASH_INC_POST   "\""
+
+char *ProgramName;
+
+char	*directives[] = {
+	"if",
+	"ifdef",
+	"ifndef",
+	"else",
+	"endif",
+	"define",
+	"undef",
+	"include",
+	"line",
+	"pragma",
+	"error",
+	"ident",
+	"sccs",
+	"elif",
+	"eject",
+	"warning",
+	"include_next",
+	NULL
+};
+
+#define MAKEDEPEND
+#include "imakemdep.h"	/* from config sources */
+#undef MAKEDEPEND
+
+struct	inclist inclist[ MAXFILES ],
+		*inclistp = inclist,
+		*inclistnext = inclist,
+		maininclist;
+
+static char	*filelist[ MAXFILES ];
+char		*includedirs[ MAXDIRS + 1 ],
+		**includedirsnext = includedirs;
+char		*notdotdot[ MAXDIRS ];
+static int	cmdinc_count = 0;
+static char	*cmdinc_list[ 2 * MAXINCFILES ];
+char		*objprefix = "";
+char		*objsuffix = OBJSUFFIX;
+static char	*startat = "# DO NOT DELETE";
+int		width = 78;
+static boolean	append = FALSE;
+boolean		printed = FALSE;
+boolean		verbose = FALSE;
+boolean		show_where_not = FALSE;
+/* Warn on multiple includes of same file */
+boolean 	warn_multiple = FALSE;
+
+static void setfile_cmdinc(struct filepointer *filep, long count, char **list);
+static void redirect(char *line, char *makefile);
+
+static
+#ifdef SIGNALRETURNSINT
+int
+#else
+void
+#endif
+catch (int sig)
+{
+	fflush (stdout);
+	fatalerr ("got signal %d\n", sig);
+}
+
+#if defined(USG) || (defined(i386) && defined(SYSV)) || defined(WIN32) || defined(__UNIXOS2__) || defined(Lynx_22) || defined(__CYGWIN__)
+#define USGISH
+#endif
+
+#ifndef USGISH
+#ifdef X_NOT_POSIX
+#define sigaction sigvec
+#define sa_handler sv_handler
+#define sa_mask sv_mask
+#define sa_flags sv_flags
+#endif
+struct sigaction sig_act;
+#endif /* USGISH */
+
+int
+main(int argc, char *argv[])
+{
+	char	**fp = filelist;
+	char	**incp = includedirs;
+	char	*p;
+	struct inclist	*ip;
+	char	*makefile = NULL;
+	struct filepointer	*filecontent;
+	struct symtab *psymp = predefs;
+	char *endmarker = NULL;
+	char *defincdir = NULL;
+	char **undeflist = NULL;
+	int numundefs = 0, i;
+	register char offset;
+
+	ProgramName = argv[0];
+
+	while (psymp->s_name)
+	{
+	    define2(psymp->s_name, psymp->s_value, &maininclist);
+	    psymp++;
+	}
+	if (argc == 2 && argv[1][0] == '@') {
+	    struct stat ast;
+	    int afd;
+	    char *args;
+	    char **nargv;
+	    int nargc;
+	    char quotechar = '\0';
+
+	    nargc = 1;
+	    if ((afd = open(argv[1]+1, O_RDONLY)) < 0)
+		fatalerr("cannot open \"%s\"\n", argv[1]+1);
+	    fstat(afd, &ast);
+	    args = (char *)malloc(ast.st_size + 1);
+	    if ((ast.st_size = read(afd, args, ast.st_size)) < 0)
+		fatalerr("failed to read %s\n", argv[1]+1);
+	    args[ast.st_size] = '\0';
+	    close(afd);
+	    for (p = args; *p; p++) {
+		if (quotechar) {
+		    if (quotechar == '\\' ||
+			(*p == quotechar && p[-1] != '\\'))
+			quotechar = '\0';
+		    continue;
+		}
+		switch (*p) {
+		case '\\':
+		case '"':
+		case '\'':
+		    quotechar = *p;
+		    break;
+		case ' ':
+		case '\n':
+		    *p = '\0';
+		    if (p > args && p[-1])
+			nargc++;
+		    break;
+		}
+	    }
+	    if (p[-1])
+		nargc++;
+	    nargv = (char **)malloc(nargc * sizeof(char *));
+	    nargv[0] = argv[0];
+	    argc = 1;
+	    for (p = args; argc < nargc; p += strlen(p) + 1)
+		if (*p) nargv[argc++] = p;
+	    argv = nargv;
+	}
+	for(argc--, argv++; argc; argc--, argv++) {
+	    	/* if looking for endmarker then check before parsing */
+		if (endmarker && strcmp (endmarker, *argv) == 0) {
+		    endmarker = NULL;
+		    continue;
+		}
+		if (**argv != '-') {
+			/* treat +thing as an option for C++ */
+			if (endmarker && **argv == '+')
+				continue;
+			*fp++ = argv[0];
+			continue;
+		}
+		switch(argv[0][1]) {
+		case '-':
+			endmarker = &argv[0][2];
+			if (endmarker[0] == '\0') endmarker = "--";
+			break;
+		case 'D':
+			offset = 2;
+			if (argv[0][2] == '\0') {
+				argv++;
+				argc--;
+				offset = 0;
+			}
+			/* offset +1 here since first def letter
+			 * cannot be `=`
+			 */
+			for (p = argv[0] + offset + 1; *p; p++)
+				if (*p == '=') {
+					*p = ' ';
+					break;
+				}
+			define(argv[0] + offset, &maininclist);
+			break;
+		case 'I':
+			if (incp >= includedirs + MAXDIRS)
+			    fatalerr("Too many -I flags.\n");
+			*incp++ = argv[0]+2;
+			if (**(incp-1) == '\0') {
+				*(incp-1) = *(++argv);
+				argc--;
+			}
+			break;
+		case 'U':
+			/* Undef's override all -D's so save them up */
+			numundefs++;
+			if (numundefs == 1)
+			    undeflist = malloc(sizeof(char *));
+			else
+			    undeflist = realloc(undeflist,
+						numundefs * sizeof(char *));
+			offset = 2;
+			if (argv[0][2] == '\0') {
+				argv++;
+				argc--;
+				offset = 0;
+			}
+			undeflist[numundefs - 1] = argv[0] + offset;
+			break;
+		case 'Y':
+			defincdir = argv[0]+2;
+			break;
+		/* do not use if endmarker processing */
+		case 'a':
+			if (endmarker) break;
+			append = TRUE;
+			break;
+		case 'w':
+			if (endmarker) break;
+			if (argv[0][2] == '\0') {
+				argv++;
+				argc--;
+				width = atoi(argv[0]);
+			} else
+				width = atoi(argv[0]+2);
+			break;
+		case 'o':
+			if (endmarker) break;
+			if (argv[0][2] == '\0') {
+				argv++;
+				argc--;
+				objsuffix = argv[0];
+			} else
+				objsuffix = argv[0]+2;
+			break;
+		case 'p':
+			if (endmarker) break;
+			if (argv[0][2] == '\0') {
+				argv++;
+				argc--;
+				objprefix = argv[0];
+			} else
+				objprefix = argv[0]+2;
+			break;
+		case 'v':
+			if (endmarker) break;
+			verbose = TRUE;
+#ifdef DEBUG
+			if (argv[0][2])
+				_debugmask = atoi(argv[0]+2);
+#endif
+			break;
+		case 's':
+			if (endmarker) break;
+			startat = argv[0]+2;
+			if (*startat == '\0') {
+				startat = *(++argv);
+				argc--;
+			}
+			if (*startat != '#')
+				fatalerr("-s flag's value should start %s\n",
+					"with '#'.");
+			break;
+		case 'f':
+			if (endmarker) break;
+			makefile = argv[0]+2;
+			if (*makefile == '\0') {
+				makefile = *(++argv);
+				argc--;
+			}
+			break;
+
+		case 'm':
+			warn_multiple = TRUE;
+			break;
+			
+		/* Ignore -O, -g so we can just pass ${CFLAGS} to
+		   makedepend
+		 */
+		case 'O':
+		case 'g':
+			break;
+		case 'i':
+			if (strcmp(&argv[0][1],"include") == 0) {
+				char *buf;
+				if (argc<2)
+					fatalerr("option -include is a "
+						 "missing its parameter\n");
+				if (cmdinc_count >= MAXINCFILES)
+					fatalerr("Too many -include flags.\n");
+				argc--;
+				argv++;
+				buf = malloc(strlen(DASH_INC_PRE) +
+					     strlen(argv[0]) +
+					     strlen(DASH_INC_POST) + 1);
+                		if(!buf)
+					fatalerr("out of memory at "
+						 "-include string\n");
+				cmdinc_list[2 * cmdinc_count + 0] = argv[0];
+				cmdinc_list[2 * cmdinc_count + 1] = buf;
+				cmdinc_count++;
+				break;
+			}
+			/* intentional fall through */
+		default:
+			if (endmarker) break;
+	/*		fatalerr("unknown opt = %s\n", argv[0]); */
+			warning("ignoring option %s\n", argv[0]);
+		}
+	}
+	/* Now do the undefs from the command line */
+	for (i = 0; i < numundefs; i++)
+	    undefine(undeflist[i], &maininclist);
+	if (numundefs > 0)
+	    free(undeflist);
+
+	if (!defincdir) {
+#ifdef PREINCDIR
+	    if (incp >= includedirs + MAXDIRS)
+		fatalerr("Too many -I flags.\n");
+	    *incp++ = PREINCDIR;
+#endif
+#ifdef __UNIXOS2__
+	    {
+		char *emxinc = getenv("C_INCLUDE_PATH");
+		/* can have more than one component */
+		if (emxinc) {
+		    char *beg, *end;
+		    beg= (char*)strdup(emxinc);
+		    for (;;) {
+			end = (char*)strchr(beg,';');
+			if (end) *end = 0;
+		    	if (incp >= includedirs + MAXDIRS)
+				fatalerr("Too many include dirs\n");
+			*incp++ = beg;
+			if (!end) break;
+			beg = end+1;
+		    }
+		}
+	    }
+#else /* !__UNIXOS2__, does not use INCLUDEDIR at all */
+	    if (incp >= includedirs + MAXDIRS)
+		fatalerr("Too many -I flags.\n");
+	    *incp++ = INCLUDEDIR;
+#endif
+
+#ifdef EXTRAINCDIR
+	    if (incp >= includedirs + MAXDIRS)
+		fatalerr("Too many -I flags.\n");
+	    *incp++ = EXTRAINCDIR;
+#endif
+
+#ifdef POSTINCDIR
+	    if (incp >= includedirs + MAXDIRS)
+		fatalerr("Too many -I flags.\n");
+	    *incp++ = POSTINCDIR;
+#endif
+	} else if (*defincdir) {
+	    if (incp >= includedirs + MAXDIRS)
+		fatalerr("Too many -I flags.\n");
+	    *incp++ = defincdir;
+	}
+
+	redirect(startat, makefile);
+
+	/*
+	 * catch signals.
+	 */
+#ifdef USGISH
+/*  should really reset SIGINT to SIG_IGN if it was.  */
+#ifdef SIGHUP
+	signal (SIGHUP, catch);
+#endif
+	signal (SIGINT, catch);
+#ifdef SIGQUIT
+	signal (SIGQUIT, catch);
+#endif
+	signal (SIGILL, catch);
+#ifdef SIGBUS
+	signal (SIGBUS, catch);
+#endif
+	signal (SIGSEGV, catch);
+#ifdef SIGSYS
+	signal (SIGSYS, catch);
+#endif
+#else
+	sig_act.sa_handler = catch;
+#if defined(_POSIX_SOURCE) || !defined(X_NOT_POSIX)
+	sigemptyset(&sig_act.sa_mask);
+	sigaddset(&sig_act.sa_mask, SIGINT);
+	sigaddset(&sig_act.sa_mask, SIGQUIT);
+#ifdef SIGBUS
+	sigaddset(&sig_act.sa_mask, SIGBUS);
+#endif
+	sigaddset(&sig_act.sa_mask, SIGILL);
+	sigaddset(&sig_act.sa_mask, SIGSEGV);
+	sigaddset(&sig_act.sa_mask, SIGHUP);
+	sigaddset(&sig_act.sa_mask, SIGPIPE);
+#ifdef SIGSYS
+	sigaddset(&sig_act.sa_mask, SIGSYS);
+#endif
+#else
+	sig_act.sa_mask = ((1<<(SIGINT -1))
+			   |(1<<(SIGQUIT-1))
+#ifdef SIGBUS
+			   |(1<<(SIGBUS-1))
+#endif
+			   |(1<<(SIGILL-1))
+			   |(1<<(SIGSEGV-1))
+			   |(1<<(SIGHUP-1))
+			   |(1<<(SIGPIPE-1))
+#ifdef SIGSYS
+			   |(1<<(SIGSYS-1))
+#endif
+			   );
+#endif /* _POSIX_SOURCE */
+	sig_act.sa_flags = 0;
+	sigaction(SIGHUP, &sig_act, (struct sigaction *)0);
+	sigaction(SIGINT, &sig_act, (struct sigaction *)0);
+	sigaction(SIGQUIT, &sig_act, (struct sigaction *)0);
+	sigaction(SIGILL, &sig_act, (struct sigaction *)0);
+#ifdef SIGBUS
+	sigaction(SIGBUS, &sig_act, (struct sigaction *)0);
+#endif
+	sigaction(SIGSEGV, &sig_act, (struct sigaction *)0);
+#ifdef SIGSYS
+	sigaction(SIGSYS, &sig_act, (struct sigaction *)0);
+#endif
+#endif /* USGISH */
+
+	/*
+	 * now peruse through the list of files.
+	 */
+	for(fp=filelist; *fp; fp++) {
+		DBG_PRINT(stderr,"file: %s\n",*fp);
+		filecontent = getfile(*fp);
+		setfile_cmdinc(filecontent, cmdinc_count, cmdinc_list);
+		ip = newinclude(*fp, (char *)NULL);
+
+		find_includes(filecontent, ip, ip, 0, FALSE);
+		freefile(filecontent);
+		recursive_pr_include(ip, ip->i_file, base_name(*fp));
+		inc_clean();
+	}
+	if (printed)
+		printf("\n");
+	return 0;
+}
+
+#ifdef __UNIXOS2__
+/*
+ * eliminate \r chars from file
+ */
+static int 
+elim_cr(char *buf, int sz)
+{
+	int i,wp;
+	for (i= wp = 0; i<sz; i++) {
+		if (buf[i] != '\r')
+			buf[wp++] = buf[i];
+	}
+	return wp;
+}
+#endif
+
+struct filepointer *
+getfile(char *file)
+{
+	int	fd;
+	struct filepointer	*content;
+	struct stat	st;
+
+	content = (struct filepointer *)malloc(sizeof(struct filepointer));
+	content->f_name = file;
+	if ((fd = open(file, O_RDONLY)) < 0) {
+		warning("cannot open \"%s\"\n", file);
+		content->f_p = content->f_base = content->f_end = (char *)malloc(1);
+		*content->f_p = '\0';
+		return(content);
+	}
+	fstat(fd, &st);
+	content->f_base = (char *)malloc(st.st_size+1);
+	if (content->f_base == NULL)
+		fatalerr("cannot allocate mem\n");
+	if ((st.st_size = read(fd, content->f_base, st.st_size)) < 0)
+		fatalerr("failed to read %s\n", file);
+#ifdef __UNIXOS2__
+	st.st_size = elim_cr(content->f_base,st.st_size);
+#endif
+	close(fd);
+	content->f_len = st.st_size+1;
+	content->f_p = content->f_base;
+	content->f_end = content->f_base + st.st_size;
+	*content->f_end = '\0';
+	content->f_line = 0;
+	content->cmdinc_count = 0;
+	content->cmdinc_list = NULL;
+	content->cmdinc_line = 0;
+	return(content);
+}
+
+void
+setfile_cmdinc(struct filepointer* filep, long count, char** list)
+{
+	filep->cmdinc_count = count;
+	filep->cmdinc_list = list;
+	filep->cmdinc_line = 0;
+}
+
+void
+freefile(struct filepointer *fp)
+{
+	free(fp->f_base);
+	free(fp);
+}
+
+char *copy(char *str)
+{
+	char	*p = (char *)malloc(strlen(str) + 1);
+
+	strcpy(p, str);
+	return(p);
+}
+
+int
+match(char *str, char **list)
+{
+	int	i;
+
+	for (i=0; *list; i++, list++)
+		if (strcmp(str, *list) == 0)
+			return(i);
+	return(-1);
+}
+
+/*
+ * Get the next line.  We only return lines beginning with '#' since that
+ * is all this program is ever interested in.
+ */
+char *getnextline(struct filepointer *filep)
+{
+	char	*p,	/* walking pointer */
+		*eof,	/* end of file pointer */
+		*bol;	/* beginning of line pointer */
+	int	lineno;	/* line number */
+	boolean whitespace = FALSE;
+
+	/*
+	 * Fake the "-include" line files in form of #include to the
+	 * start of each file.
+	 */
+	if (filep->cmdinc_line < filep->cmdinc_count) {
+		char *inc = filep->cmdinc_list[2 * filep->cmdinc_line + 0];
+		char *buf = filep->cmdinc_list[2 * filep->cmdinc_line + 1];
+		filep->cmdinc_line++;
+		sprintf(buf,"%s%s%s",DASH_INC_PRE,inc,DASH_INC_POST);
+		DBG_PRINT(stderr,"%s\n",buf);
+		return(buf);
+	}
+
+	p = filep->f_p;
+	eof = filep->f_end;
+	if (p >= eof)
+		return((char *)NULL);
+	lineno = filep->f_line;
+
+	for (bol = p--; ++p < eof; ) {
+		if ((bol == p) && ((*p == ' ') || (*p == '\t')))
+		{
+			/* Consume leading white-spaces for this line */
+			while (((p+1) < eof) && ((*p == ' ') || (*p == '\t')))
+			{
+				p++;
+				bol++;
+			}
+			whitespace = TRUE;
+		}
+        
+		if (*p == '/' && (p+1) < eof && *(p+1) == '*') {
+			/* Consume C comments */
+			*(p++) = ' ';
+			*(p++) = ' ';
+			while (p < eof && *p) {
+				if (*p == '*' && (p+1) < eof && *(p+1) == '/') {
+					*(p++) = ' ';
+					*(p++) = ' ';
+					break;
+				}
+				if (*p == '\n')
+					lineno++;
+				*(p++) = ' ';
+			}
+			--p;
+		}
+		else if (*p == '/' && (p+1) < eof && *(p+1) == '/') {
+			/* Consume C++ comments */
+			*(p++) = ' ';
+			*(p++) = ' ';
+			while (p < eof && *p) {
+				if (*p == '\\' && (p+1) < eof &&
+				    *(p+1) == '\n') {
+					*(p++) = ' ';
+					lineno++;
+				}
+				else if (*p == '?' && (p+3) < eof &&
+					 *(p+1) == '?' && 
+					 *(p+2) == '/' &&
+					 *(p+3) == '\n') {
+					*(p++) = ' ';
+					*(p++) = ' ';
+					*(p++) = ' ';
+					lineno++;
+				}
+				else if (*p == '\n')
+					break;	/* to process end of line */
+				*(p++) = ' ';
+			}
+			--p;
+		}
+		else if (*p == '\\' && (p+1) < eof && *(p+1) == '\n') {
+			/* Consume backslash line terminations */
+			*(p++) = ' ';
+			*p = ' ';
+			lineno++;
+		}
+		else if (*p == '?' && (p+3) < eof &&
+			 *(p+1) == '?' && *(p+2) == '/' && *(p+3) == '\n') {
+			/* Consume trigraph'ed backslash line terminations */
+			*(p++) = ' ';
+			*(p++) = ' ';
+			*(p++) = ' ';
+			*p = ' ';
+			lineno++;
+		}
+		else if (*p == '\n') {
+			lineno++;
+			if (*bol == '#') {
+				char *cp;
+
+				*(p++) = '\0';
+				/* punt lines with just # (yacc generated) */
+				for (cp = bol+1; 
+				     *cp && (*cp == ' ' || *cp == '\t'); cp++);
+				if (*cp) goto done;
+				--p;
+			}
+			bol = p+1;
+			whitespace = FALSE;
+		}
+	}
+	if (*bol != '#')
+		bol = NULL;
+done:
+	if (bol && whitespace) {
+		warning("%s:  non-portable whitespace encountered at line %d\n",
+			filep->f_name, lineno);
+	}
+	filep->f_p = p;
+	filep->f_line = lineno;
+#ifdef DEBUG_DUMP
+	if (bol)
+		DBG_PRINT(stderr,"%s\n",bol);
+#endif
+	return(bol);
+}
+
+/*
+ * Strip the file name down to what we want to see in the Makefile.
+ * It will have objprefix and objsuffix around it.
+ */
+char *base_name(char *file)
+{
+	char	*p;
+
+	file = copy(file);
+	for(p=file+strlen(file); p>file && *p != '.'; p--) ;
+
+	if (*p == '.')
+		*p = '\0';
+	return(file);
+}
+
+#if defined(USG) && !defined(CRAY) && !defined(SVR4) && !defined(__UNIXOS2__) && !defined(clipper) && !defined(__clipper__)
+int rename (char *from, char *to)
+{
+    (void) unlink (to);
+    if (link (from, to) == 0) {
+	unlink (from);
+	return 0;
+    } else {
+	return -1;
+    }
+}
+#endif /* USGISH */
+
+void
+redirect(char *line, char *makefile)
+{
+	struct stat	st;
+	FILE	*fdin, *fdout;
+	char	backup[ BUFSIZ ],
+		buf[ BUFSIZ ];
+	boolean	found = FALSE;
+	int	len;
+
+	/*
+	 * if makefile is "-" then let it pour onto stdout.
+	 */
+	if (makefile && *makefile == '-' && *(makefile+1) == '\0') {
+		puts(line);
+		return;
+	}
+
+	/*
+	 * use a default makefile is not specified.
+	 */
+	if (!makefile) {
+		if (stat("Makefile", &st) == 0)
+			makefile = "Makefile";
+		else if (stat("makefile", &st) == 0)
+			makefile = "makefile";
+		else
+			fatalerr("[mM]akefile is not present\n");
+	}
+	else
+	    stat(makefile, &st);
+	if ((fdin = fopen(makefile, "r")) == NULL)
+		fatalerr("cannot open \"%s\"\n", makefile);
+	sprintf(backup, "%s.bak", makefile);
+	unlink(backup);
+#if defined(WIN32) || defined(__UNIXOS2__) || defined(__CYGWIN__)
+	fclose(fdin);
+#endif
+	if (rename(makefile, backup) < 0)
+		fatalerr("cannot rename %s to %s\n", makefile, backup);
+#if defined(WIN32) || defined(__UNIXOS2__) || defined(__CYGWIN__)
+	if ((fdin = fopen(backup, "r")) == NULL)
+		fatalerr("cannot open \"%s\"\n", backup);
+#endif
+	if ((fdout = freopen(makefile, "w", stdout)) == NULL)
+		fatalerr("cannot open \"%s\"\n", backup);
+	len = strlen(line);
+	while (!found && fgets(buf, BUFSIZ, fdin)) {
+		if (*buf == '#' && strncmp(line, buf, len) == 0)
+			found = TRUE;
+		fputs(buf, fdout);
+	}
+	if (!found) {
+		if (verbose)
+		warning("Adding new delimiting line \"%s\" and dependencies...\n",
+			line);
+		puts(line); /* same as fputs(fdout); but with newline */
+	} else if (append) {
+	    while (fgets(buf, BUFSIZ, fdin)) {
+		fputs(buf, fdout);
+	    }
+	}
+	fflush(fdout);
+#if defined(USGISH) || defined(_SEQUENT_) || defined(USE_CHMOD)
+	chmod(makefile, st.st_mode);
+#else
+        fchmod(fileno(fdout), st.st_mode);
+#endif /* USGISH */
+}
+
+void
+fatalerr(char *msg, ...)
+{
+	va_list args;
+	fprintf(stderr, "%s: error:  ", ProgramName);
+	va_start(args, msg);
+	vfprintf(stderr, msg, args);
+	va_end(args);
+	exit (1);
+}
+
+void
+warning(char *msg, ...)
+{
+	va_list args;
+	fprintf(stderr, "%s: warning:  ", ProgramName);
+	va_start(args, msg);
+	vfprintf(stderr, msg, args);
+	va_end(args);
+}
+
+void
+warning1(char *msg, ...)
+{
+	va_list args;
+	va_start(args, msg);
+	vfprintf(stderr, msg, args);
+	va_end(args);
+}
diff -r 17e9560465b0 js/src/config/mkdepend/mkdepend.man
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/mkdepend/mkdepend.man	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,382 @@
+.\" $Xorg: mkdepend.man,v 1.5 2001/02/09 02:03:16 xorgcvs Exp $
+.\" Copyright (c) 1993, 1994, 1998 The Open Group
+.\" 
+.\" Permission to use, copy, modify, distribute, and sell this software and its
+.\" documentation for any purpose is hereby granted without fee, provided that
+.\" the above copyright notice appear in all copies and that both that
+.\" copyright notice and this permission notice appear in supporting
+.\" documentation.
+.\" 
+.\" The above copyright notice and this permission notice shall be included in
+.\" all copies or substantial portions of the Software.
+.\" 
+.\" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+.\" IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+.\" FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL 
+.\" THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
+.\" WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF 
+.\" OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
+.\" SOFTWARE.
+.\" 
+.\" Except as contained in this notice, the name of The Open Group shall not 
+.\" be used in advertising or otherwise to promote the sale, use or other 
+.\" dealing in this Software without prior written authorization from The
+.\" Open Group.
+.\"
+.\" $XFree86: xc/config/makedepend/mkdepend.man,v 1.7 2002/12/14 02:39:45 dawes Exp $
+.\"
+.TH MAKEDEPEND 1 __xorgversion__
+.UC 4
+.SH NAME
+makedepend \- create dependencies in makefiles
+.SH SYNOPSIS
+.B makedepend
+[
+.BI \-D name\fB=\fPdef
+] [
+.BI \-D name
+] [
+.BI \-I includedir
+] [
+.BI \-Y includedir
+] [
+.B \-a
+] [
+.BI \-f makefile
+] [
+.BI \-include \ file
+] [
+.BI \-o objsuffix
+] [
+.BI \-p objprefix
+] [
+.BI \-s string
+] [
+.BI \-w width
+] [
+.B \-v
+] [
+.B \-m
+] [
+\-\^\-
+.I otheroptions
+\-\^\-
+]
+.I sourcefile
+\&.\|.\|.
+.br
+.SH DESCRIPTION
+The
+.B makedepend
+program reads each
+.I sourcefile
+in sequence and parses it like a C-preprocessor,
+processing all
+.I #include,
+.I #define,
+.I #undef,
+.I #ifdef,
+.I #ifndef,
+.I #endif,
+.I #if,
+.I #elif
+and
+.I #else
+directives so that it can correctly tell which
+.I #include,
+directives would be used in a compilation.
+Any
+.I #include,
+directives can reference files having other
+.I #include
+directives, and parsing will occur in these files as well.
+.PP
+Every file that a
+.I sourcefile
+includes,
+directly or indirectly,
+is what
+.B makedepend
+calls a \fIdependency.\fP
+These dependencies are then written to a
+.I makefile
+in such a way that
+.B make(1)
+will know which object files must be recompiled when a dependency has changed.
+.PP
+By default,
+.B makedepend
+places its output in the file named
+.I makefile
+if it exists, otherwise
+.I Makefile.
+An alternate makefile may be specified with the
+.B \-f
+option.
+It first searches the makefile for
+the line
+.sp
+\&    # DO NOT DELETE THIS LINE \-\^\- make depend depends on it.
+.sp
+or one provided with the
+.B \-s
+option,
+as a delimiter for the dependency output.
+If it finds it, it will delete everything
+following this to the end of the makefile
+and put the output after this line.
+If it doesn't find it, the program
+will append the string to the end of the makefile
+and place the output following that.
+For each
+.I sourcefile
+appearing on the command line,
+.B makedepend
+puts lines in the makefile of the form
+.sp
+     sourcefile.o:\0dfile .\|.\|.
+.sp
+Where \fIsourcefile.o\fP is the name from the command
+line with its suffix replaced with ``.o'',
+and \fIdfile\fP is a dependency discovered in a
+.I #include
+directive while parsing
+.I sourcefile
+or one of the files it included.
+.SH EXAMPLE
+Normally,
+.B makedepend
+will be used in a makefile target so that typing ``make depend'' will
+bring the dependencies up to date for the makefile.
+For example,
+.nf
+    SRCS\0=\0file1.c\0file2.c\0.\|.\|.
+    CFLAGS\0=\0\-O\0\-DHACK\0\-I\^.\^.\^/foobar\0\-xyz
+    depend:
+            makedepend\0\-\^\-\0$(CFLAGS)\0\-\^\-\0$(SRCS)
+.fi
+.SH OPTIONS
+The program
+will ignore any option that it does not understand so that you may use
+the same arguments that you would for
+.B cc(1).
+.TP 5
+.B \-D\fIname\fP=\fIdef\fP \fRor\fP \-D\fIname\fP
+Define.
+This places a definition for
+.I name
+in
+.B makedepend's
+symbol table.
+Without 
+.I =def\|
+the symbol becomes defined as ``1''.
+.TP 5
+.B \-I\fIincludedir\fP
+Include directory.
+This option tells
+.B makedepend
+to prepend
+.I includedir
+to its list of directories to search when it encounters
+a
+.I #include
+directive.
+By default,
+.B makedepend
+only searches the standard include directories (usually /usr/include
+and possibly a compiler-dependent directory).
+.TP 5
+.B \-Y\fIincludedir\fP
+Replace all of the standard include directories with the single specified
+include directory; you can omit the
+.I includedir
+to simply prevent searching the standard include directories.
+.TP 5
+.B \-a
+Append the dependencies to the end of the file instead of replacing them. 
+.TP 5
+.B \-f\fImakefile\fP
+Filename.
+This allows you to specify an alternate makefile in which
+.B makedepend
+can place its output.
+Specifying ``\-'' as the file name (i.e., \fB\-f\-\fP) sends the
+output to standard output instead of modifying an existing file.
+.TP 5
+.B \-include \fIfile\fP
+Process file as input, and include all the resulting output
+before processing the regular input file. This has the same
+affect as if the specified file is an include statement that
+appears before the very first line of the regular input file.
+.TP 5
+.B \-o\fIobjsuffix\fP
+Object file suffix.
+Some systems may have object files whose suffix is something other
+than ``.o''.
+This option allows you to specify another suffix, such as
+``.b'' with
+.I \-o.b
+or ``:obj''
+with
+.I \-o:obj
+and so forth.
+.TP 5
+.B \-p\fIobjprefix\fP
+Object file prefix.
+The prefix is prepended to the name of the object file. This is
+usually used to designate a different directory for the object file.
+The default is the empty string.
+.TP 5
+.B \-s\fIstring\fP
+Starting string delimiter.
+This option permits you to specify
+a different string for
+.B makedepend
+to look for in the makefile.
+.TP 5
+.B \-w\fIwidth\fP
+Line width.
+Normally,
+.B makedepend
+will ensure that every output line that it writes will be no wider than
+78 characters for the sake of readability.
+This option enables you to change this width.
+.TP 5
+.B \-v
+Verbose operation.
+This option causes 
+.B makedepend
+to emit the list of files included by each input file.
+.TP 5
+.B \-m
+Warn about multiple inclusion.
+This option causes 
+.B makedepend
+to produce a warning if any input file includes another file more than
+once.  In previous versions of 
+.B makedepend
+this was the default behavior; the default has been changed to better
+match the behavior of the C compiler, which does not consider multiple
+inclusion to be an error.  This option is provided for backward 
+compatibility, and to aid in debugging problems related to multiple
+inclusion.
+.TP 5
+.B "\-\^\- \fIoptions\fP \-\^\-"
+If
+.B makedepend
+encounters a double hyphen (\-\^\-) in the argument list,
+then any unrecognized argument following it
+will be silently ignored; a second double hyphen terminates this
+special treatment.
+In this way,
+.B makedepend
+can be made to safely ignore esoteric compiler arguments that might
+normally be found in a CFLAGS
+.B make
+macro (see the
+.B EXAMPLE
+section above).
+All options that
+.B makedepend
+recognizes and appear between the pair of double hyphens
+are processed normally.
+.SH ALGORITHM
+The approach used in this program enables it to run an order of magnitude
+faster than any other ``dependency generator'' I have ever seen.
+Central to this performance are two assumptions:
+that all files compiled by a single
+makefile will be compiled with roughly the same
+.I \-I
+and
+.I \-D
+options;
+and that most files in a single directory will include largely the
+same files.
+.PP
+Given these assumptions,
+.B makedepend
+expects to be called once for each makefile, with
+all source files that are maintained by the
+makefile appearing on the command line.
+It parses each source and include
+file exactly once, maintaining an internal symbol table
+for each.
+Thus, the first file on the command line will take an amount of time
+proportional to the amount of time that a normal C preprocessor takes.
+But on subsequent files, if it encounters an include file
+that it has already parsed, it does not parse it again.
+.PP
+For example,
+imagine you are compiling two files,
+.I file1.c
+and
+.I file2.c,
+they each include the header file
+.I header.h,
+and the file
+.I header.h
+in turn includes the files
+.I def1.h
+and
+.I def2.h.
+When you run the command
+.sp
+    makedepend\0file1.c\0file2.c
+.sp
+.B makedepend
+will parse
+.I file1.c
+and consequently,
+.I header.h
+and then
+.I def1.h
+and
+.I def2.h.
+It then decides that the dependencies for this file are
+.sp
+    file1.o:\0header.h\0def1.h\0def2.h
+.sp
+But when the program parses
+.I file2.c
+and discovers that it, too, includes
+.I header.h,
+it does not parse the file,
+but simply adds
+.I header.h,
+.I def1.h
+and
+.I def2.h
+to the list of dependencies for
+.I file2.o.
+.SH "SEE ALSO"
+cc(1), make(1)
+.SH BUGS
+.B makedepend
+parses, but does not currently evaluate, the SVR4 #predicate(token-list)
+preprocessor expression; such expressions are simply assumed to be true.
+This may cause the wrong
+.I #include
+directives to be evaluated.
+.PP
+Imagine you are parsing two files,
+say
+.I file1.c
+and
+.I file2.c,
+each includes the file
+.I def.h.
+The list of files that
+.I def.h
+includes might truly be different when
+.I def.h
+is included by
+.I file1.c
+than when it is included by
+.I file2.c.
+But once
+.B makedepend
+arrives at a list of dependencies for a file,
+it is cast in concrete.
+.SH AUTHOR
+Todd Brunhoff, Tektronix, Inc. and MIT Project Athena
diff -r 17e9560465b0 js/src/config/mkdepend/parse.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/mkdepend/parse.c	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,686 @@
+/* $Xorg: parse.c,v 1.6 2001/02/09 02:03:16 xorgcvs Exp $ */
+/*
+
+Copyright (c) 1993, 1994, 1998 The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+*/
+/* $XFree86: xc/config/makedepend/parse.c,v 1.12 2002/02/26 05:09:10 tsi Exp $ */
+
+#include "def.h"
+
+extern char	*directives[];
+extern struct inclist	inclist[ MAXFILES ],
+			*inclistnext,
+			maininclist;
+extern char	*includedirs[ ],
+		**includedirsnext;
+
+static int deftype (char *line, struct filepointer *filep,
+		    struct inclist *file_red, struct inclist *file,
+		    int parse_it);
+static int zero_value(char *filename, char *exp, struct filepointer *filep,
+		    struct inclist *file_red);
+static int merge2defines(struct inclist *file1, struct inclist *file2);
+
+static int
+gobble(struct filepointer *filep, struct inclist *file,
+       struct inclist *file_red)
+{
+	char	*line;
+	int	type;
+
+	while ((line = getnextline(filep))) {
+		switch(type = deftype(line, filep, file_red, file, FALSE)) {
+		case IF:
+		case IFFALSE:
+		case IFGUESSFALSE:
+		case IFDEF:
+		case IFNDEF:
+			type = gobble(filep, file, file_red);
+			while ((type == ELIF) || (type == ELIFFALSE) ||
+			       (type == ELIFGUESSFALSE))
+			    type = gobble(filep, file, file_red);
+			if (type == ELSE)
+			        (void)gobble(filep, file, file_red);
+			break;
+		case ELSE:
+		case ENDIF:
+			debug(0,("%s, line %d: #%s\n",
+				file->i_file, filep->f_line,
+				directives[type]));
+			return(type);
+		case DEFINE:
+		case UNDEF:
+		case INCLUDE:
+		case INCLUDEDOT:
+		case PRAGMA:
+		case ERROR:
+		case IDENT:
+		case SCCS:
+		case EJECT:
+		case WARNING:
+		case INCLUDENEXT:
+		case INCLUDENEXTDOT:
+			break;
+		case ELIF:
+		case ELIFFALSE:
+		case ELIFGUESSFALSE:
+			return(type);
+		case -1:
+			warning("%s", file_red->i_file);
+			if (file_red != file)
+				warning1(" (reading %s)", file->i_file);
+			warning1(", line %d: unknown directive == \"%s\"\n",
+				filep->f_line, line);
+			break;
+		}
+	}
+	return(-1);
+}
+
+/*
+ * Decide what type of # directive this line is.
+ */
+static int 
+deftype (char *line, struct filepointer *filep, 
+	     struct inclist *file_red, struct inclist *file, int parse_it)
+{
+	register char	*p;
+	char	*directive, savechar, *q;
+	register int	ret;
+
+	/*
+	 * Parse the directive...
+	 */
+	directive=line+1;
+	while (*directive == ' ' || *directive == '\t')
+		directive++;
+
+	p = directive;
+	while ((*p == '_') || (*p >= 'a' && *p <= 'z'))
+		p++;
+	savechar = *p;
+	*p = '\0';
+	ret = match(directive, directives);
+	*p = savechar;
+
+	/* If we don't recognize this compiler directive or we happen to just
+	 * be gobbling up text while waiting for an #endif or #elif or #else
+	 * in the case of an #elif we must check the zero_value and return an
+	 * ELIF or an ELIFFALSE.
+	 */
+
+	if (ret == ELIF && !parse_it)
+	{
+	    while (*p == ' ' || *p == '\t')
+		p++;
+	    /*
+	     * parse an expression.
+	     */
+	    debug(0,("%s, line %d: #elif %s ",
+		   file->i_file, filep->f_line, p));
+	    ret = zero_value(file->i_file, p, filep, file_red);
+	    if (ret != IF)
+	    {
+		debug(0,("false...\n"));
+		if (ret == IFFALSE)
+		    return(ELIFFALSE);
+		else
+		    return(ELIFGUESSFALSE);
+	    }
+	    else
+	    {
+		debug(0,("true...\n"));
+		return(ELIF);
+	    }
+	}
+
+	if (ret < 0 || ! parse_it)
+		return(ret);
+
+	/*
+	 * now decide how to parse the directive, and do it.
+	 */
+	while (*p == ' ' || *p == '\t')
+		p++;
+	q = p + strlen(p);
+	do {
+		q--;
+	} while (*q == ' ' || *q == '\t');
+	q[1] = '\0';
+	switch (ret) {
+	case IF:
+		/*
+		 * parse an expression.
+		 */
+		ret = zero_value(file->i_file, p, filep, file_red);
+		debug(0,("%s, line %d: %s #if %s\n",
+			 file->i_file, filep->f_line, ret?"false":"true", p));
+		break;
+	case IFDEF:
+	case IFNDEF:
+		debug(0,("%s, line %d: #%s %s\n",
+			file->i_file, filep->f_line, directives[ret], p));
+	case UNDEF:
+		/*
+		 * separate the name of a single symbol.
+		 */
+		while (isalnum(*p) || *p == '_')
+			*line++ = *p++;
+		*line = '\0';
+		break;
+	case INCLUDE:
+	case INCLUDENEXT:
+		debug(2,("%s, line %d: #include%s %s\n",
+			file->i_file, filep->f_line,
+			(ret == INCLUDE) ? "" : "_next", p));
+
+		/* Support ANSI macro substitution */
+		while (1) {
+			struct symtab **sym;
+
+			if (!*p || *p == '"' || *p == '<')
+				break;
+
+		    	sym = isdefined(p, file_red, NULL);
+			if (!sym)
+				break;
+
+			p = (*sym)->s_value;
+			debug(3,("%s : #includes SYMBOL %s = %s\n",
+			       file->i_incstring,
+			       (*sym) -> s_name,
+			       (*sym) -> s_value));
+			/* mark file as having included a 'soft include' */
+			file->i_flags |= INCLUDED_SYM; 
+		}
+
+		/*
+		 * Separate the name of the include file.
+		 */
+		while (*p && *p != '"' && *p != '<')
+			p++;
+		if (! *p)
+			return(-2);
+		if (*p++ == '"') {
+			if (ret == INCLUDE)
+				ret = INCLUDEDOT;
+			else
+				ret = INCLUDENEXTDOT;
+			while (*p && *p != '"')
+				*line++ = *p++;
+		} else
+			while (*p && *p != '>')
+				*line++ = *p++;
+		*line = '\0';
+		break;
+	case DEFINE:
+		/*
+		 * copy the definition back to the beginning of the line.
+		 */
+		strcpy (line, p);
+		break;
+	case ELSE:
+	case ENDIF:
+	case ELIF:
+	case PRAGMA:
+	case ERROR:
+	case IDENT:
+	case SCCS:
+	case EJECT:
+	case WARNING:
+		debug(0,("%s, line %d: #%s\n",
+			file->i_file, filep->f_line, directives[ret]));
+		/*
+		 * nothing to do.
+		 */
+		break;
+	}
+	return(ret);
+}
+
+struct symtab **
+fdefined(char *symbol, struct inclist *file, struct inclist **srcfile)
+{
+	struct inclist	**ip;
+	struct symtab	**val;
+	int	i;
+	static int	recurse_lvl = 0;
+
+	if (file->i_flags & DEFCHECKED)
+		return(NULL);
+	debug(2,("Looking for %s in %s\n", symbol, file->i_file));
+	file->i_flags |= DEFCHECKED;
+	if ((val = slookup(symbol, file)))
+		debug(1,("%s defined in %s as %s\n",
+			 symbol, file->i_file, (*val)->s_value));
+	if (val == NULL && file->i_list)
+	{
+		for (ip = file->i_list, i=0; i < file->i_listlen; i++, ip++)
+			if (file->i_merged[i]==FALSE) {
+				val = fdefined(symbol, *ip, srcfile);
+				file->i_merged[i]=merge2defines(file,*ip);
+				if (val!=NULL) break;
+			}
+	}
+	else if (val != NULL && srcfile != NULL) *srcfile = file;
+	recurse_lvl--;
+	file->i_flags &= ~DEFCHECKED;
+
+	return(val);
+}
+
+struct symtab **
+isdefined(char *symbol, struct inclist *file, struct inclist **srcfile)
+{
+	struct symtab	**val;
+
+	if ((val = slookup(symbol, &maininclist))) {
+		debug(1,("%s defined on command line\n", symbol));
+		if (srcfile != NULL) *srcfile = &maininclist;
+		return(val);
+	}
+	if ((val = fdefined(symbol, file, srcfile)))
+		return(val);
+	debug(1,("%s not defined in %s\n", symbol, file->i_file));
+	return(NULL);
+}
+
+/*
+ * Return type based on if the #if expression evaluates to 0
+ */
+static int
+zero_value(char *filename,
+	   char *exp,
+	   struct filepointer *filep,
+	   struct inclist *file_red)
+{
+	if (cppsetup(filename, exp, filep, file_red))
+	    return(IFFALSE);
+	else
+	    return(IF);
+}
+
+void
+define2(char *name, char *val, struct inclist *file)
+{
+    int first, last, below;
+    register struct symtab **sp = NULL, **dest;
+    struct symtab *stab;
+
+    /* Make space if it's needed */
+    if (file->i_defs == NULL)
+    {
+	file->i_defs = (struct symtab **)
+			malloc(sizeof (struct symtab*) * SYMTABINC);
+	file->i_ndefs = 0;
+    }
+    else if (!(file->i_ndefs % SYMTABINC))
+	file->i_defs = (struct symtab **)
+			realloc(file->i_defs,
+			   sizeof(struct symtab*)*(file->i_ndefs+SYMTABINC));
+
+    if (file->i_defs == NULL)
+	fatalerr("malloc()/realloc() failure in insert_defn()\n");
+
+    below = first = 0;
+    last = file->i_ndefs - 1;
+    while (last >= first)
+    {
+	/* Fast inline binary search */
+	register char *s1;
+	register char *s2;
+	register int middle = (first + last) / 2;
+
+	/* Fast inline strchr() */
+	s1 = name;
+	s2 = file->i_defs[middle]->s_name;
+	while (*s1++ == *s2++)
+	    if (s2[-1] == '\0') break;
+
+	/* If exact match, set sp and break */
+	if (*--s1 == *--s2) 
+	{
+	    sp = file->i_defs + middle;
+	    break;
+	}
+
+	/* If name > i_defs[middle] ... */
+	if (*s1 > *s2) 
+	{
+	    below = first;
+	    first = middle + 1;
+	}
+	/* else ... */
+	else
+	{
+	    below = last = middle - 1;
+	}
+    }
+
+    /* Search is done.  If we found an exact match to the symbol name,
+       just replace its s_value */
+    if (sp != NULL)
+    {
+	debug(1,("redefining %s from %s to %s in file %s\n",
+		name, (*sp)->s_value, val, file->i_file));
+	free((*sp)->s_value);
+	(*sp)->s_value = copy(val);
+	return;
+    }
+
+    sp = file->i_defs + file->i_ndefs++;
+    dest = file->i_defs + below + 1;
+    while (sp > dest)
+    {
+	*sp = sp[-1];
+	sp--;
+    }
+    stab = (struct symtab *) malloc(sizeof (struct symtab));
+    if (stab == NULL)
+	fatalerr("malloc()/realloc() failure in insert_defn()\n");
+
+    debug(1,("defining %s to %s in file %s\n", name, val, file->i_file));
+    stab->s_name = copy(name);
+    stab->s_value = copy(val);
+    *sp = stab;
+}
+
+void
+define(char *def, struct inclist *file)
+{
+    char *val;
+
+    /* Separate symbol name and its value */
+    val = def;
+    while (isalnum(*val) || *val == '_')
+	val++;
+    if (*val)
+	*val++ = '\0';
+    while (*val == ' ' || *val == '\t')
+	val++;
+
+    if (!*val)
+	val = "1";
+    define2(def, val, file);
+}
+
+struct symtab **
+slookup(char *symbol, struct inclist *file)
+{
+	register int first = 0;
+	register int last = file->i_ndefs - 1;
+
+	if (file) while (last >= first)
+	{
+	    /* Fast inline binary search */
+	    register char *s1;
+	    register char *s2;
+	    register int middle = (first + last) / 2;
+
+	    /* Fast inline strchr() */
+	    s1 = symbol;
+	    s2 = file->i_defs[middle]->s_name;
+	    while (*s1++ == *s2++)
+	        if (s2[-1] == '\0') break;
+
+	    /* If exact match, we're done */
+	    if (*--s1 == *--s2) 
+	    {
+	        return file->i_defs + middle;
+	    }
+
+	    /* If symbol > i_defs[middle] ... */
+	    if (*s1 > *s2) 
+	    {
+	        first = middle + 1;
+	    }
+	    /* else ... */
+	    else
+	    {
+	        last = middle - 1;
+	    }
+	}
+	return(NULL);
+}
+
+static int 
+merge2defines(struct inclist *file1, struct inclist *file2)
+{
+	int i;
+
+	if ((file1==NULL) || (file2==NULL) ||
+	    !(file2->i_flags & FINISHED))
+		return 0;
+
+	for (i=0; i < file2->i_listlen; i++)
+		if (file2->i_merged[i]==FALSE)
+			return 0;
+
+	{
+		int first1 = 0;
+		int last1 = file1->i_ndefs - 1;
+
+		int first2 = 0;
+		int last2 = file2->i_ndefs - 1;
+
+                int first=0;
+                struct symtab** i_defs = NULL;
+		int deflen=file1->i_ndefs+file2->i_ndefs;
+
+		debug(2,("merging %s into %s\n",
+			file2->i_file, file1->i_file));
+
+                if (deflen>0)
+                { 
+                	/* make sure deflen % SYMTABINC == 0 is still true */
+                	deflen += (SYMTABINC - deflen % SYMTABINC) % SYMTABINC;
+                	i_defs=(struct symtab**)
+			    malloc(deflen*sizeof(struct symtab*));
+                	if (i_defs==NULL) return 0;
+        	}
+
+        	while ((last1 >= first1) && (last2 >= first2))
+        	{
+	    		char *s1=file1->i_defs[first1]->s_name;
+	    		char *s2=file2->i_defs[first2]->s_name;
+
+     			if (strcmp(s1,s2) < 0)
+                        	i_defs[first++]=file1->i_defs[first1++];
+     			else if (strcmp(s1,s2) > 0)
+                        	i_defs[first++]=file2->i_defs[first2++];
+                        else /* equal */
+                        {
+                        	i_defs[first++]=file2->i_defs[first2++];
+                                first1++;
+                        }
+        	}
+        	while (last1 >= first1)
+        	{
+                        i_defs[first++]=file1->i_defs[first1++];
+        	}
+        	while (last2 >= first2)
+        	{
+                        i_defs[first++]=file2->i_defs[first2++];
+        	}
+
+                if (file1->i_defs) free(file1->i_defs);
+                file1->i_defs=i_defs;
+                file1->i_ndefs=first;
+                
+		return 1;
+  	}
+}
+
+void
+undefine(char *symbol, struct inclist *file)
+{
+	register struct symtab **ptr;
+	struct inclist *srcfile;
+	while ((ptr = isdefined(symbol, file, &srcfile)) != NULL)
+	{
+	    srcfile->i_ndefs--;
+	    for (; ptr < srcfile->i_defs + srcfile->i_ndefs; ptr++)
+		*ptr = ptr[1];
+	}
+}
+
+int
+find_includes(struct filepointer *filep, struct inclist *file, 
+	      struct inclist *file_red, int recursion, boolean failOK)
+{
+	struct inclist	*inclistp;
+	char		**includedirsp;
+	register char	*line;
+	register int	type;
+	boolean recfailOK;
+
+	while ((line = getnextline(filep))) {
+		switch(type = deftype(line, filep, file_red, file, TRUE)) {
+		case IF:
+		doif:
+			type = find_includes(filep, file,
+				file_red, recursion+1, failOK);
+			while ((type == ELIF) || (type == ELIFFALSE) ||
+			       (type == ELIFGUESSFALSE))
+				type = gobble(filep, file, file_red);
+			if (type == ELSE)
+				gobble(filep, file, file_red);
+			break;
+		case IFFALSE:
+		case IFGUESSFALSE:
+		    doiffalse:
+			if (type == IFGUESSFALSE || type == ELIFGUESSFALSE)
+			    recfailOK = TRUE;
+			else
+			    recfailOK = failOK;
+			type = gobble(filep, file, file_red);
+			if (type == ELSE)
+			    find_includes(filep, file,
+					  file_red, recursion+1, recfailOK);
+			else
+			if (type == ELIF)
+			    goto doif;
+			else
+			if ((type == ELIFFALSE) || (type == ELIFGUESSFALSE))
+			    goto doiffalse;
+			break;
+		case IFDEF:
+		case IFNDEF:
+			if ((type == IFDEF && isdefined(line, file_red, NULL))
+			 || (type == IFNDEF && !isdefined(line, file_red, NULL))) {
+				debug(1,(type == IFNDEF ?
+				    "line %d: %s !def'd in %s via %s%s\n" : "",
+				    filep->f_line, line,
+				    file->i_file, file_red->i_file, ": doit"));
+				type = find_includes(filep, file,
+					file_red, recursion+1, failOK);
+				while (type == ELIF || type == ELIFFALSE || type == ELIFGUESSFALSE)
+					type = gobble(filep, file, file_red);
+				if (type == ELSE)
+					gobble(filep, file, file_red);
+			}
+			else {
+				debug(1,(type == IFDEF ?
+				    "line %d: %s !def'd in %s via %s%s\n" : "",
+				    filep->f_line, line,
+				    file->i_file, file_red->i_file, ": gobble"));
+				type = gobble(filep, file, file_red);
+				if (type == ELSE)
+					find_includes(filep, file,
+						file_red, recursion+1, failOK);
+				else if (type == ELIF)
+				    	goto doif;
+				else if (type == ELIFFALSE || type == ELIFGUESSFALSE)
+				    	goto doiffalse;
+			}
+			break;
+		case ELSE:
+		case ELIFFALSE:
+		case ELIFGUESSFALSE:
+		case ELIF:
+			if (!recursion)
+				gobble(filep, file, file_red);
+		case ENDIF:
+			if (recursion)
+				return(type);
+		case DEFINE:
+			define(line, file);
+			break;
+		case UNDEF:
+			if (!*line) {
+			    warning("%s", file_red->i_file);
+			    if (file_red != file)
+				warning1(" (reading %s)", file->i_file);
+			    warning1(", line %d: incomplete undef == \"%s\"\n",
+				filep->f_line, line);
+			    break;
+			}
+			undefine(line, file_red);
+			break;
+		case INCLUDE:
+		case INCLUDEDOT:
+		case INCLUDENEXT:
+		case INCLUDENEXTDOT:
+			inclistp = inclistnext;
+			includedirsp = includedirsnext;
+			debug(2,("%s, reading %s, includes %s\n",
+				file_red->i_file, file->i_file, line));
+			add_include(filep, file, file_red, line, type, failOK);
+			inclistnext = inclistp;
+			includedirsnext = includedirsp;
+			break;
+		case ERROR:
+		case WARNING:
+		    	warning("%s", file_red->i_file);
+			if (file_red != file)
+				warning1(" (reading %s)", file->i_file);
+			warning1(", line %d: %s\n",
+				 filep->f_line, line);
+		    	break;
+		    
+		case PRAGMA:
+		case IDENT:
+		case SCCS:
+		case EJECT:
+			break;
+		case -1:
+			warning("%s", file_red->i_file);
+			if (file_red != file)
+			    warning1(" (reading %s)", file->i_file);
+			warning1(", line %d: unknown directive == \"%s\"\n",
+				 filep->f_line, line);
+			break;
+		case -2:
+			warning("%s", file_red->i_file);
+			if (file_red != file)
+			    warning1(" (reading %s)", file->i_file);
+			warning1(", line %d: incomplete include == \"%s\"\n",
+				 filep->f_line, line);
+			break;
+		}
+	}
+	file->i_flags |= FINISHED;
+	debug(2,("finished with %s\n", file->i_file));
+	return(-1);
+}
diff -r 17e9560465b0 js/src/config/mkdepend/pr.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/mkdepend/pr.c	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,124 @@
+/* $Xorg: pr.c,v 1.4 2001/02/09 02:03:16 xorgcvs Exp $ */
+/*
+
+Copyright (c) 1993, 1994, 1998 The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+*/
+/* $XFree86: xc/config/makedepend/pr.c,v 1.5 2001/12/14 19:53:21 dawes Exp $ */
+
+#include "def.h"
+
+extern struct	inclist	inclist[ MAXFILES ],
+			*inclistp;
+extern char	*objprefix;
+extern char	*objsuffix;
+extern int	width;
+extern boolean	printed;
+extern boolean	verbose;
+extern boolean	show_where_not;
+
+void
+add_include(struct filepointer *filep, struct inclist *file, 
+	    struct inclist *file_red, char *include, int type,
+	    boolean failOK)
+{
+	register struct inclist	*newfile;
+	register struct filepointer	*content;
+
+	/*
+	 * First decide what the pathname of this include file really is.
+	 */
+	newfile = inc_path(file->i_file, include, type);
+	if (newfile == NULL) {
+		if (failOK)
+		    return;
+		if (file != file_red)
+			warning("%s (reading %s, line %d): ",
+				file_red->i_file, file->i_file, filep->f_line);
+		else
+			warning("%s, line %d: ", file->i_file, filep->f_line);
+		warning1("cannot find include file \"%s\"\n", include);
+		show_where_not = TRUE;
+		newfile = inc_path(file->i_file, include, type);
+		show_where_not = FALSE;
+	}
+
+	if (newfile) {
+		included_by(file, newfile);
+		if (!(newfile->i_flags & SEARCHED)) {
+			newfile->i_flags |= SEARCHED;
+			content = getfile(newfile->i_file);
+			find_includes(content, newfile, file_red, 0, failOK);
+			freefile(content);
+		}
+	}
+}
+
+static void
+pr(struct inclist *ip, char *file, char *base)
+{
+	static char	*lastfile;
+	static int	current_len;
+	register int	len, i;
+	char	buf[ BUFSIZ ];
+
+	printed = TRUE;
+	len = strlen(ip->i_file)+1;
+	if (current_len + len > width || file != lastfile) {
+		lastfile = file;
+		sprintf(buf, "\n%s%s%s: %s", objprefix, base, objsuffix,
+			ip->i_file);
+		len = current_len = strlen(buf);
+	}
+	else {
+		buf[0] = ' ';
+		strcpy(buf+1, ip->i_file);
+		current_len += len;
+	}
+	fwrite(buf, len, 1, stdout);
+
+	/*
+	 * If verbose is set, then print out what this file includes.
+	 */
+	if (! verbose || ip->i_list == NULL || ip->i_flags & NOTIFIED)
+		return;
+	ip->i_flags |= NOTIFIED;
+	lastfile = NULL;
+	printf("\n# %s includes:", ip->i_file);
+	for (i=0; i<ip->i_listlen; i++)
+		printf("\n#\t%s", ip->i_list[ i ]->i_incstring);
+}
+
+void
+recursive_pr_include(struct inclist *head, char *file, char *base)
+{
+	int	i;
+
+	if (head->i_flags & MARKED)
+		return;
+	head->i_flags |= MARKED;
+	if (head->i_file != file)
+		pr(head, file, base);
+	for (i=0; i<head->i_listlen; i++)
+		recursive_pr_include(head->i_list[ i ], file, base);
+}
diff -r 17e9560465b0 js/src/config/nfspwd.pl
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/nfspwd.pl	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,50 @@
+#! perl
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+# Netscape Communications Corporation.
+# Portions created by the Initial Developer are Copyright (C) 1998
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+require "fastcwd.pl";
+
+$_ = &fastcwd;
+if (m@^/[uh]/@o || s@^/tmp_mnt/@/@o) {
+    print("$_\n");
+} elsif ((($user, $rest) = m@^/usr/people/(\w+)/(.*)@o)
+      && readlink("/u/$user") eq "/usr/people/$user") {
+    print("/u/$user/$rest\n");
+} else {
+    chop($host = `hostname`);
+    print("/h/$host$_\n");
+}
diff -r 17e9560465b0 js/src/config/nsinstall.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/nsinstall.c	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,481 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+/*
+** Netscape portable install command.
+**
+** Brendan Eich, 7/20/95
+*/
+#include <stdio.h>  /* OSF/1 requires this before grp.h, so put it first */
+#include <assert.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <dirent.h>
+#include <limits.h>
+#include <grp.h>
+#include <pwd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <utime.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include "pathsub.h"
+
+#ifdef HAVE_GETOPT_H
+#include <getopt.h>
+#endif
+
+#ifdef SUNOS4
+#include "sunos4.h"
+#endif
+
+#ifdef NEXTSTEP
+#include <bsd/libc.h>
+#endif
+
+#ifdef __QNX__
+#include <unix.h>
+#endif
+
+#ifdef NEED_S_ISLNK
+#if !defined(S_ISLNK) && defined(S_IFLNK)
+#define S_ISLNK(a)	(((a) & S_IFMT) == S_IFLNK)
+#endif
+#endif
+
+#ifndef _DIRECTORY_SEPARATOR
+#define _DIRECTORY_SEPARATOR "/"
+#endif /* _DIRECTORY_SEPARATOR */
+
+#ifdef NEED_FCHMOD_PROTO
+extern int fchmod(int fildes, mode_t mode);
+#endif
+
+static void
+usage(void)
+{
+    fprintf(stderr,
+	"usage: %s [-C cwd] [-L linkprefix] [-m mode] [-o owner] [-g group]\n"
+	"       %*s [-DdltR] file [file ...] directory\n",
+	program, (int) strlen(program), "");
+    exit(2);
+}
+
+static int
+mkdirs(char *path, mode_t mode)
+{
+    char *cp;
+    struct stat sb;
+    int res;
+    int l;
+
+    /* strip trailing "/." */
+    l = strlen(path);
+    if(l > 1 && path[l - 1] == '.' && path[l - 2] == '/')
+        path[l - 2] = 0;
+
+    while (*path == '/' && path[1] == '/')
+	path++;
+    for (cp = strrchr(path, '/'); cp && cp != path && *(cp - 1) == '/'; cp--);
+    if (cp && cp != path) {
+	*cp = '\0';
+	if ((lstat(path, &sb) < 0 || !S_ISDIR(sb.st_mode)) &&
+	    mkdirs(path, mode) < 0) {
+	    return -1;
+	}
+	*cp = '/';
+    }
+    
+    res = mkdir(path, mode);
+    if ((res != 0) && (errno == EEXIST))
+      return 0;
+    else
+      return res;
+}
+
+static uid_t
+touid(char *owner)
+{
+    struct passwd *pw;
+    uid_t uid;
+    char *cp;
+
+    pw = getpwnam(owner);
+    if (pw)
+	return pw->pw_uid;
+    uid = strtol(owner, &cp, 0);
+    if (uid == 0 && cp == owner)
+	fail("cannot find uid for %s", owner);
+    return uid;
+}
+
+static gid_t
+togid(char *group)
+{
+    struct group *gr;
+    gid_t gid;
+    char *cp;
+
+    gr = getgrnam(group);
+    if (gr)
+	return gr->gr_gid;
+    gid = strtol(group, &cp, 0);
+    if (gid == 0 && cp == group)
+	fail("cannot find gid for %s", group);
+    return gid;
+}
+
+static void
+copyfile( char *name, char *toname, mode_t mode, char *group, char *owner,
+          int dotimes, uid_t uid, gid_t gid )
+{
+  int fromfd, tofd = -1, cc, wc, exists;
+  char buf[BUFSIZ], *bp;
+  struct stat sb, tosb;
+  struct utimbuf utb;
+
+  exists = (lstat(toname, &tosb) == 0);
+
+  fromfd = open(name, O_RDONLY);
+  if (fromfd < 0 || fstat(fromfd, &sb) < 0)
+    fail("cannot access %s", name);
+  if (exists) {
+    if (S_ISREG(tosb.st_mode)) {
+      /* See if we can open it. This is more reliable than 'access'. */
+      tofd = open(toname, O_CREAT | O_WRONLY, 0666);
+    }
+    if (tofd < 0) {
+      (void) (S_ISDIR(tosb.st_mode) ? rmdir : unlink)(toname);
+    }
+  }
+  if (tofd < 0) {
+    tofd = open(toname, O_CREAT | O_WRONLY, 0666);
+    if (tofd < 0)
+      fail("cannot create %s", toname);
+  }
+
+  bp = buf;
+  while ((cc = read(fromfd, bp, sizeof buf)) > 0)
+  {
+    while ((wc = write(tofd, bp, (unsigned int)cc)) > 0)
+    {
+      if ((cc -= wc) == 0)
+        break;
+      bp += wc;
+    }
+    if (wc < 0)
+      fail("cannot write to %s", toname);
+  }
+  if (cc < 0)
+    fail("cannot read from %s", name);
+
+  if (ftruncate(tofd, sb.st_size) < 0)
+    fail("cannot truncate %s", toname);
+#if !defined(VMS)
+  if (dotimes)
+  {
+    utb.actime = sb.st_atime;
+    utb.modtime = sb.st_mtime;
+    if (utime(toname, &utb) < 0)
+      fail("cannot set times of %s", toname);
+  }
+#ifdef HAVE_FCHMOD
+  if (fchmod(tofd, mode) < 0)
+#else
+  if (chmod(toname, mode) < 0)
+#endif
+    fail("cannot change mode of %s", toname);
+#endif
+  if ((owner || group) && fchown(tofd, uid, gid) < 0)
+    fail("cannot change owner of %s", toname);
+
+  /* Must check for delayed (NFS) write errors on close. */
+  if (close(tofd) < 0)
+    fail("cannot write to %s", toname);
+  close(fromfd);
+#if defined(VMS)
+  if (chmod(toname, (mode & (S_IREAD | S_IWRITE))) < 0)
+    fail("cannot change mode of %s", toname);
+  if (dotimes)
+  {
+    utb.actime = sb.st_atime;
+    utb.modtime = sb.st_mtime;
+    if (utime(toname, &utb) < 0)
+      fail("cannot set times of %s", toname);
+  }
+#endif
+}
+
+static void
+copydir( char *from, char *to, mode_t mode, char *group, char *owner,
+         int dotimes, uid_t uid, gid_t gid)
+{
+  int i;
+  DIR *dir;
+  struct dirent *ep;
+  struct stat sb;
+  char *base, *destdir, *direntry, *destentry;
+
+  base = xbasename(from);
+
+  /* create destination directory */
+  destdir = xmalloc((unsigned int)(strlen(to) + 1 + strlen(base) + 1));
+  sprintf(destdir, "%s%s%s", to, _DIRECTORY_SEPARATOR, base);
+  if (mkdirs(destdir, mode) != 0) {
+    fail("cannot make directory %s\n", destdir);
+    return;
+  }
+
+  dir = opendir(from);
+
+  direntry = xmalloc((unsigned int)PATH_MAX);
+  destentry = xmalloc((unsigned int)PATH_MAX);
+
+  while ((ep = readdir(dir)))
+  {
+    if (strcmp(ep->d_name, ".") == 0 || strcmp(ep->d_name, "..") == 0)
+      continue;
+
+    sprintf(direntry, "%s/%s", from, ep->d_name);
+    sprintf(destentry, "%s%s%s", destdir, _DIRECTORY_SEPARATOR, ep->d_name);
+
+    if (stat(direntry, &sb) == 0 && S_ISDIR(sb.st_mode))
+      copydir( direntry, destdir, mode, group, owner, dotimes, uid, gid );
+    else
+      copyfile( direntry, destentry, mode, group, owner, dotimes, uid, gid );
+  }
+
+  free(direntry);
+  free(destentry);
+  closedir(dir);
+}
+
+int
+main(int argc, char **argv)
+{
+    int onlydir, dodir, dolink, dorelsymlink, dotimes, opt, len, lplen, tdlen, bnlen, exists, fromfd, tofd, cc, wc;
+    mode_t mode = 0755;
+    char *linkprefix, *owner, *group, *cp, *cwd, *todir, *toname, *name, *base, *linkname, *bp, buf[BUFSIZ];
+    uid_t uid;
+    gid_t gid;
+    struct stat sb, tosb, fromsb;
+    struct utimbuf utb;
+
+    program = argv[0];
+    cwd = linkname = linkprefix = owner = group = 0;
+    onlydir = dodir = dolink = dorelsymlink = dotimes = lplen = 0;
+
+    while ((opt = getopt(argc, argv, "C:DdlL:Rm:o:g:t")) != EOF) {
+	switch (opt) {
+	  case 'C':
+	    cwd = optarg;
+	    break;
+	  case 'D':
+	    onlydir = 1;
+	    break;
+	  case 'd':
+	    dodir = 1;
+	    break;
+	  case 'l':
+	    dolink = 1;
+	    break;
+	  case 'L':
+	    linkprefix = optarg;
+	    lplen = strlen(linkprefix);
+	    dolink = 1;
+	    break;
+     case 'R':
+	    dolink = dorelsymlink = 1;
+	    break;
+	  case 'm':
+	    mode = strtoul(optarg, &cp, 8);
+	    if (mode == 0 && cp == optarg)
+		usage();
+	    break;
+	  case 'o':
+	    owner = optarg;
+	    break;
+	  case 'g':
+	    group = optarg;
+	    break;
+	  case 't':
+	    dotimes = 1;
+	    break;
+	  default:
+	    usage();
+	}
+    }
+
+    argc -= optind;
+    argv += optind;
+    if (argc < 2 - onlydir)
+	usage();
+
+    todir = argv[argc-1];
+    if ((stat(todir, &sb) < 0 || !S_ISDIR(sb.st_mode)) &&
+	mkdirs(todir, 0777) < 0) {
+	fail("cannot make directory %s", todir);
+    }
+    if (onlydir)
+	return 0;
+
+    if (!cwd) {
+#ifndef NEEDS_GETCWD
+#ifndef GETCWD_CANT_MALLOC
+	cwd = getcwd(0, PATH_MAX);
+#else
+	cwd = malloc(PATH_MAX + 1);
+	cwd = getcwd(cwd, PATH_MAX);
+#endif
+#else
+	cwd = malloc(PATH_MAX + 1);
+	cwd = getwd(cwd);
+#endif
+    }
+
+    xchdir(todir);
+#ifndef NEEDS_GETCWD
+#ifndef GETCWD_CANT_MALLOC
+    todir = getcwd(0, PATH_MAX);
+#else
+    todir = malloc(PATH_MAX + 1);
+    todir = getcwd(todir, PATH_MAX);
+#endif
+#else
+    todir = malloc(PATH_MAX + 1);
+    todir = getwd(todir);
+#endif
+    tdlen = strlen(todir);
+    xchdir(cwd);
+    tdlen = strlen(todir);
+
+    uid = owner ? touid(owner) : (uid_t)(-1);
+    gid = group ? togid(group) : (gid_t)(-1);
+
+    while (--argc > 0) {
+	name = *argv++;
+	len = strlen(name);
+	base = xbasename(name);
+	bnlen = strlen(base);
+	toname = xmalloc((unsigned int)(tdlen + 1 + bnlen + 1));
+	sprintf(toname, "%s%s%s", todir, _DIRECTORY_SEPARATOR, base);
+	exists = (lstat(toname, &tosb) == 0);
+
+	if (dodir) {
+	    /* -d means create a directory, always */
+	    if (exists && !S_ISDIR(tosb.st_mode)) {
+		(void) unlink(toname);
+		exists = 0;
+	    }
+	    if (!exists && mkdir(toname, mode) < 0)
+		fail("cannot make directory %s", toname);
+	    if ((owner || group) && chown(toname, uid, gid) < 0)
+		fail("cannot change owner of %s", toname);
+	} else if (dolink) {
+            if (access(name, R_OK) != 0) {
+                fail("cannot access %s", name);
+            }
+	    if (*name == '/') {
+		/* source is absolute pathname, link to it directly */
+		linkname = 0;
+	    } else {
+		if (linkprefix) {
+		    /* -L implies -l and prefixes names with a $cwd arg. */
+		    len += lplen + 1;
+		    linkname = xmalloc((unsigned int)(len + 1));
+		    sprintf(linkname, "%s/%s", linkprefix, name);
+		} else if (dorelsymlink) {
+		    /* Symlink the relative path from todir to source name. */
+		    linkname = xmalloc(PATH_MAX);
+
+		    if (*todir == '/') {
+			/* todir is absolute: skip over common prefix. */
+			lplen = relatepaths(todir, cwd, linkname);
+			strcpy(linkname + lplen, name);
+		    } else {
+			/* todir is named by a relative path: reverse it. */
+			reversepath(todir, name, len, linkname);
+			xchdir(cwd);
+		    }
+
+		    len = strlen(linkname);
+		}
+		name = linkname;
+	    }
+
+	    /* Check for a pre-existing symlink with identical content. */
+	    if ((exists && (!S_ISLNK(tosb.st_mode) ||
+						readlink(toname, buf, sizeof buf) != len ||
+						strncmp(buf, name, (unsigned int)len) != 0)) || 
+			((stat(name, &fromsb) == 0) && 
+			 (fromsb.st_mtime > tosb.st_mtime))) {
+		(void) (S_ISDIR(tosb.st_mode) ? rmdir : unlink)(toname);
+		exists = 0;
+	    }
+	    if (!exists && symlink(name, toname) < 0)
+		fail("cannot make symbolic link %s", toname);
+#ifdef HAVE_LCHOWN
+	    if ((owner || group) && lchown(toname, uid, gid) < 0)
+		fail("cannot change owner of %s", toname);
+#endif
+
+	    if (linkname) {
+		free(linkname);
+		linkname = 0;
+	    }
+	} else {
+	    /* Copy from name to toname, which might be the same file. */
+      if( stat(name, &sb) == 0 && S_IFDIR & sb.st_mode )
+      {
+        /* then is directory: must explicitly create destination dir  */
+        /*  and manually copy files over                              */
+        copydir( name, todir, mode, group, owner, dotimes, uid, gid );
+      } 
+      else
+      {
+        copyfile(name, toname, mode, group, owner, dotimes, uid, gid);
+      }
+    }
+
+	free(toname);
+    }
+
+    free(cwd);
+    free(todir);
+    return 0;
+}
diff -r 17e9560465b0 js/src/config/nsinstall.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/nsinstall.py	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,139 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is Mozilla.
+#
+# The Initial Developer of the Original Code is
+# the Mozilla Foundation.
+# Portions created by the Initial Developer are Copyright (C) 2007
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Axel Hecht <axel@pike.org>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+# This is a partial python port of nsinstall.
+# It's intended to be used when there's no natively compile nsinstall
+# available, and doesn't intend to be fully equivalent.
+# Its major use is for l10n repackaging on systems that don't have
+# a full build environment set up.
+# The basic limitation is, it doesn't even try to link and ignores
+# all related options.
+
+from optparse import OptionParser
+import os
+import os.path
+import sys
+import shutil
+
+usage = "usage: %prog [options] arg1 [arg2 ...] target-directory"
+p = OptionParser(usage=usage)
+
+p.add_option('-D', action="store_true",
+             help="Create a single directory only")
+p.add_option('-t', action="store_true",
+             help="Preserve time stamp")
+p.add_option('-m', action="store",
+             help="Set mode", metavar="mode")
+p.add_option('-d', action="store_true",
+             help="Create directories in target")
+p.add_option('-R', action="store_true",
+             help="Use relative symbolic links (ignored)")
+p.add_option('-l', action="store_true",
+             help="Create link (ignored)")
+p.add_option('-L', action="store", metavar="linkprefix",
+             help="Link prefix (ignored)")
+
+# The remaining arguments are not used in our tree, thus they're not
+# implented.
+def BadArg(option, opt, value, parser):
+  parser.error('option not supported: %s' % opt)
+
+p.add_option('-C', action="callback", metavar="CWD",
+             callback=BadArg,
+             help="NOT SUPPORTED")
+p.add_option('-o', action="callback", callback=BadArg,
+             help="Set owner (NOT SUPPORTED)", metavar="owner")
+p.add_option('-g', action="callback", callback=BadArg,
+             help="Set group (NOT SUPPORTED)", metavar="group")
+
+(options, args) = p.parse_args()
+
+if options.m:
+  # mode is specified
+  try:
+    options.m = int(options.m, 8)
+  except:
+    sys.stderr.write('nsinstall: ' + options.m + ' is not a valid mode\n')
+    sys.exit(1)
+
+# just create one directory?
+if options.D:
+  if len(args) != 1:
+    sys.exit(1)
+  if os.path.exists(args[0]):
+    if not os.path.isdir(args[0]):
+      sys.stderr.write('nsinstall: ' + args[0] + ' is not a directory\n')
+      sys.exit(1)
+    if options.m:
+      os.chmod(args[0], options.m)
+    sys.exit()
+  if options.m:
+    os.makedirs(args[0], options.m)
+  else:
+    os.makedirs(args[0])
+  sys.exit()
+
+# nsinstall arg1 [...] directory
+if len(args) < 2:
+  p.error('not enough arguments')
+
+# set up handler
+if options.d:
+  # we're supposed to create directories
+  def handleTarget(srcpath, targetpath):
+    # target directory was already created, just use mkdir
+    os.mkdir(dest)
+else:
+  # we're supposed to copy files
+  def handleTarget(srcpath, targetpath):
+    if options.t:
+      shutil.copy2(srcpath, targetpath)
+    else:
+      shutil.copy(srcpath, targetpath)
+
+# the last argument is the target directory
+target = args.pop()
+# ensure target directory
+if not os.path.isdir(target):
+  os.makedirs(target)
+
+for f in args:
+  dest = os.path.join(target,
+                      os.path.basename(os.path.normpath(f)))
+  handleTarget(f, dest)
+  if options.m:
+    os.chmod(dest, options.m)
diff -r 17e9560465b0 js/src/config/pathsub.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/pathsub.c	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,247 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+/*
+** Pathname subroutines.
+**
+** Brendan Eich, 8/29/95
+*/
+#include <assert.h>
+#include <sys/types.h>
+#include <dirent.h>
+#include <errno.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include "pathsub.h"
+
+#ifdef USE_REENTRANT_LIBC
+#include <libc_r.h>
+#endif
+
+#ifdef SUNOS4
+#include "sunos4.h"
+#endif
+
+#ifndef D_INO
+#define D_INO	d_ino
+#endif
+
+char *program;
+
+void
+fail(char *format, ...)
+{
+    int error;
+    va_list ap;
+
+#ifdef USE_REENTRANT_LIBC
+    R_STRERROR_INIT_R();
+#endif
+
+    error = errno;
+    fprintf(stderr, "%s: ", program);
+    va_start(ap, format);
+    vfprintf(stderr, format, ap);
+    va_end(ap);
+    if (error) {
+
+#ifdef USE_REENTRANT_LIBC
+    R_STRERROR_R(errno);
+	fprintf(stderr, ": %s", r_strerror_r);
+#else
+	fprintf(stderr, ": %s", strerror(errno));
+#endif
+    }
+
+    putc('\n', stderr);
+    exit(1);
+}
+
+char *
+getcomponent(char *path, char *name)
+{
+    if (*path == '\0')
+	return 0;
+    if (*path == '/') {
+	*name++ = '/';
+    } else {
+	do {
+	    *name++ = *path++;
+	} while (*path != '/' && *path != '\0');
+    }
+    *name = '\0';
+    while (*path == '/')
+	path++;
+    return path;
+}
+
+#ifdef LAME_READDIR
+#include <sys/param.h>
+/*
+** The static buffer in Unixware's readdir is too small.
+*/
+struct dirent *readdir(DIR *d)
+{
+        static struct dirent *buf = NULL;
+
+        if(buf == NULL)
+                buf = (struct dirent *) malloc(sizeof(struct dirent) + MAXPATHLEN);
+        return(readdir_r(d, buf));
+}
+#endif
+
+char *
+ino2name(ino_t ino, char *dir)
+{
+    DIR *dp;
+    struct dirent *ep;
+    char *name;
+
+    dp = opendir("..");
+    if (!dp)
+	fail("cannot read parent directory");
+    for (;;) {
+	if (!(ep = readdir(dp)))
+	    fail("cannot find current directory");
+	if (ep->D_INO == ino)
+	    break;
+    }
+    name = xstrdup(ep->d_name);
+    closedir(dp);
+    return name;
+}
+
+void *
+xmalloc(size_t size)
+{
+    void *p = malloc(size);
+    if (!p)
+	fail("cannot allocate %u bytes", size);
+    return p;
+}
+
+char *
+xstrdup(char *s)
+{
+    return strcpy(xmalloc(strlen(s) + 1), s);
+}
+
+char *
+xbasename(char *path)
+{
+    char *cp;
+
+    while ((cp = strrchr(path, '/')) && cp[1] == '\0')
+	*cp = '\0';
+    if (!cp) return path;
+    return cp + 1;
+}
+
+void
+xchdir(char *dir)
+{
+    if (chdir(dir) < 0)
+	fail("cannot change directory to %s", dir);
+}
+
+int
+relatepaths(char *from, char *to, char *outpath)
+{
+    char *cp, *cp2;
+    int len;
+    char buf[NAME_MAX];
+
+    assert(*from == '/' && *to == '/');
+    for (cp = to, cp2 = from; *cp == *cp2; cp++, cp2++)
+	if (*cp == '\0')
+	    break;
+    while (cp[-1] != '/')
+	cp--, cp2--;
+    if (cp - 1 == to) {
+	/* closest common ancestor is /, so use full pathname */
+	len = strlen(strcpy(outpath, to));
+	if (outpath[len] != '/') {
+	    outpath[len++] = '/';
+	    outpath[len] = '\0';
+	}
+    } else {
+	len = 0;
+	while ((cp2 = getcomponent(cp2, buf)) != 0) {
+	    strcpy(outpath + len, "../");
+	    len += 3;
+	}
+	while ((cp = getcomponent(cp, buf)) != 0) {
+	    sprintf(outpath + len, "%s/", buf);
+	    len += strlen(outpath + len);
+	}
+    }
+    return len;
+}
+
+void
+reversepath(char *inpath, char *name, int len, char *outpath)
+{
+    char *cp, *cp2;
+    char buf[NAME_MAX];
+    struct stat sb;
+
+    cp = strcpy(outpath + PATH_MAX - (len + 1), name);
+    cp2 = inpath;
+    while ((cp2 = getcomponent(cp2, buf)) != 0) {
+	if (strcmp(buf, ".") == 0)
+	    continue;
+	if (strcmp(buf, "..") == 0) {
+	    if (stat(".", &sb) < 0)
+		fail("cannot stat current directory");
+	    name = ino2name(sb.st_ino, "..");
+	    len = strlen(name);
+	    cp -= len + 1;
+	    strcpy(cp, name);
+	    cp[len] = '/';
+	    free(name);
+	    xchdir("..");
+	} else {
+	    cp -= 3;
+	    strncpy(cp, "../", 3);
+	    xchdir(buf);
+	}
+    }
+    strcpy(outpath, cp);
+}
diff -r 17e9560465b0 js/src/config/pathsub.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/pathsub.h	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,74 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef pathsub_h___
+#define pathsub_h___
+/*
+** Pathname subroutines.
+**
+** Brendan Eich, 8/29/95
+*/
+#include <limits.h>
+#include <sys/types.h>
+
+#ifndef PATH_MAX
+#define PATH_MAX 1024
+#endif
+
+/*
+ * Just prevent stupidity
+ */
+#undef NAME_MAX
+#define NAME_MAX 256
+
+extern char *program;
+
+extern void fail(char *format, ...);
+extern char *getcomponent(char *path, char *name);
+extern char *ino2name(ino_t ino, char *dir);
+extern void *xmalloc(size_t size);
+extern char *xstrdup(char *s);
+extern char *xbasename(char *path);
+extern void xchdir(char *dir);
+
+/* Relate absolute pathnames from and to returning the result in outpath. */
+extern int relatepaths(char *from, char *to, char *outpath);
+
+/* XXX changes current working directory -- caveat emptor */
+extern void reversepath(char *inpath, char *name, int len, char *outpath);
+
+#endif /* pathsub_h___ */
diff -r 17e9560465b0 js/src/config/preprocessor.pl
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/preprocessor.pl	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,671 @@
+#!/usr/bin/perl -w
+# -*- Mode: perl; tab-width: 4; indent-tabs-mode: nil; -*-
+#
+# Preprocessor
+# Version 1.1
+#
+# Copyright (c) 2002, 2003, 2004 by Ian Hickson
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+# Thanks to bryner and bsmedberg for suggestions.
+# Thanks to jon rekai for a patch to not require File::Spec 0.8.
+
+use strict;
+
+# takes as arguments the files to process
+# defaults to stdin
+# output to stdout
+
+my $stack = new stack;
+my $marker = '#';
+
+# command line arguments
+my @includes;
+while ($_ = $ARGV[0], defined($_) && /^-./) {
+    shift;
+    last if /^--$/os;
+    if (/^-D(.*)$/os) { 
+        for ($1) {
+            if (/^([\w\.]+)=(.*)$/os) {
+                $stack->define($1, $2);
+            } elsif (/^([\w\.]+)$/os) {
+                $stack->define($1, 1);
+            } else {
+                die "$0: invalid argument to -D: $_\n";
+            }
+        }
+    } elsif (/^-F(.*)$/os) { 
+        for ($1) {
+            if (/^(\w+)$/os) {
+                $stack->filter($1, 1);
+            } else {
+                die "$0: invalid argument to -F: $_\n";
+            }
+        }
+    } elsif (/^-I(.*)$/os) { 
+        push(@includes, $1);
+    } elsif (/^-E$/os) { 
+        foreach (keys %ENV) {
+            # define all variables that have valid names
+            $stack->define($_, $ENV{$_}) unless m/\W/;
+        }
+    } elsif (/^-d$/os) { 
+        $stack->{'dependencies'} = 1;
+    } elsif (/^--line-endings=crlf$/os) { 
+        $stack->{'lineEndings'} = "\x0D\x0A";
+    } elsif (/^--line-endings=cr$/os) { 
+        $stack->{'lineEndings'} = "\x0D";
+    } elsif (/^--line-endings=lf$/os) { 
+        $stack->{'lineEndings'} = "\x0A";
+    } elsif (/^--line-endings=(.+)$/os) { 
+        die "$0: unrecognised line ending: $1\n";
+    } elsif (/^--marker=(.)$/os) {
+        $marker = $1;
+    } else {
+        die "$0: invalid argument: $_\n";
+    }
+}
+unshift(@ARGV, '-') unless @ARGV;
+unshift(@ARGV, @includes);
+
+# do the work
+foreach (@ARGV) { include($stack, $_); }
+exit(0);
+
+########################################################################
+
+package main;
+use File::Spec;
+use File::Spec::Unix; # on all platforms, because the #include syntax is unix-based
+
+# Note: Ideally we would use File::Spec 0.8. When this becomes
+# possible, add "0.8" to the first "use" line above, then replace
+# occurrences of "::_0_8::" with "->" below. And remove the code for
+# File::Spec 0.8 much lower down the file.
+
+sub include {
+    my($stack, $filename) = @_;
+    my $directory = $stack->{'variables'}->{'DIRECTORY'};
+    if ($filename ne '-') {
+        $filename = File::Spec::_0_8::rel2abs($filename, $directory);
+        # splitpath expects forward-slash paths on windows, so we have to
+        # change the slashes if using Activestate Perl.
+        $filename =~ s?\\?/?g if "$^O" eq "MSWin32";
+        my($volume, $path) = File::Spec::_0_8::splitpath($filename);
+        $directory = File::Spec::_0_8::catpath($volume, $path, '');
+    }
+    local $stack->{'variables'}->{'DIRECTORY'} = $directory;
+    local $stack->{'variables'}->{'FILE'} = $filename;
+    local $stack->{'variables'}->{'LINE'} = 0;
+    local *FILE;
+    open(FILE, $filename) or die "Couldn't open $filename: $!\n";
+    my $lineout = 0;
+    while (<FILE>) {
+        # on cygwin, line endings are screwed up, so normalise them.
+        s/[\x0D\x0A]+$/\n/os if ($^O eq 'msys' || $^O eq 'cygwin' || "$^O" eq "MSWin32");
+        $stack->newline;
+        if (/^\Q$marker\E([a-z]+)\n?$/os) { # argumentless processing instruction
+            process($stack, $1);
+        } elsif (/^\Q$marker\E([a-z]+)\s(.*?)\n?$/os) { # processing instruction with arguments
+            process($stack, $1, $2);
+        } elsif (/^\Q$marker\E/os) { # comment
+            # ignore it
+        } elsif ($stack->enabled) {
+            next if $stack->{'dependencies'};
+
+            # set the current line number in JavaScript if necessary
+            my $linein = $stack->{'variables'}->{'LINE'};
+            if (++$lineout != $linein) {
+                if ($filename =~ /\.js(|\.in)$/o) {
+                    $stack->print("//\@line $linein \"$filename\"\n")
+                }
+                $lineout = $linein;
+            }
+
+            # print it, including any newlines
+            $stack->print(filtered($stack, $_));
+        }
+    }
+    close(FILE);
+}
+
+sub process {
+    my($stack, $instruction, @arguments) = @_;
+    my $method = 'preprocessor'->can($instruction);
+    if (not defined($method)) {
+        fatal($stack, 'unknown instruction', $instruction);
+    }
+    eval { &$method($stack, @arguments) };
+    if ($@) {
+        fatal($stack, "error evaluating $instruction:", $@);
+    }
+}
+
+sub filtered {
+    my($stack, $text) = @_;
+    foreach my $filter (sort keys %{$stack->{'filters'}}) {
+        next unless $stack->{'filters'}->{$filter};
+        my $method = 'filter'->can($filter);
+        if (not defined($method)) {
+            fatal($stack, 'unknown filter', $filter);
+        }
+        $text = eval { &$method($stack, $text) };
+        if ($@) {
+            fatal($stack, "error using $filter:", $@);
+        }                
+    }
+    return $text;
+}
+
+sub fatal {
+    my $stack = shift;
+    my $filename = $stack->{'variables'}->{'FILE'};
+    local $" = ' ';
+    print STDERR "$0:$filename:$.: @_\n";
+    exit(1);
+}
+
+
+########################################################################
+
+package stack;
+
+# condition evaluated just prior to this context was false
+use constant COND_FALSE => 0;
+
+# condition evaluated just prior to this context was true
+use constant COND_TRUE => 1;
+
+# some prior condition at this level already evaluated to true (or a
+# parent condition evaluated to false or must be ignored), so we're
+# ignoring all remaining conditions at current level (and nested
+# conditions, too)
+use constant COND_COMPLETED => 2;
+
+sub new {
+    return bless {
+        'variables' => {
+            # %ENV,
+            'LINE' => 0, # the line number in the source file
+            'DIRECTORY' => '', # current directory
+            'FILE' => '', # source filename
+            '1' => 1, # for convenience (the constant '1' is thus true)
+        },
+        'filters' => {
+            # filters
+        },
+        'values' => [], # the value of the last condition evaluated at the nth level
+        'lastConditionState' => [], # whether the condition in the nth-level context was true, false, or not applicable
+        'conditionState' => COND_TRUE,
+        'dependencies' => 0, # whether we are showing dependencies
+        'lineEndings' => "\n", # default to platform conventions
+    };
+}
+
+sub newline {
+    my $self = shift;
+    $self->{'variables'}->{'LINE'}++;
+}
+
+sub define {
+    my $self = shift;
+    my($variable, $value) = @_;
+    die "not a valid variable name: '$variable'\n" if $variable =~ m/[^\w\.]/;
+    $self->{'variables'}->{$variable} = $value;
+}
+
+sub defined {
+    my $self = shift;
+    my($variable) = @_;
+    die "not a valid variable name: '$variable'\n" if $variable =~ m/[^\w\.]/;
+    return defined($self->{'variables'}->{$variable});
+}
+
+sub undefine {
+    my $self = shift;
+    my($variable) = @_;
+    die "not a valid variable name: '$variable'\n" if $variable =~ m/[^\w\.]/;
+    delete($self->{'variables'}->{$variable});
+}
+
+sub get {
+    my $self = shift;
+    my($variable, $required) = @_;
+    die "not a valid variable name: '$variable'\n" if $variable =~ m/[^\w\.]/;
+    my $value = $self->{'variables'}->{$variable};
+    if (defined($value)) {
+        return $value;
+    } else {
+        die "variable '$variable' is not defined\n" if $required;
+        return '';
+    }
+}
+
+sub replace {
+    my $self = shift;
+    my ($value) = @_;
+
+    ${$self->{'values'}}[-1] = $value;
+    $self->{'conditionState'} = $self->{'conditionState'} != COND_FALSE
+                              ? COND_COMPLETED
+                              : $value ? COND_TRUE : COND_FALSE;
+}
+
+sub push {
+    my $self = shift;
+    my($value) = @_;
+
+    push(@{$self->{'values'}}, $value);
+    my $lastCondition = $self->{'conditionState'};
+    push(@{$self->{'lastConditionState'}}, $lastCondition);
+    $self->{'conditionState'} = $lastCondition != COND_TRUE
+                              ? COND_COMPLETED
+                              : $value ? COND_TRUE : COND_FALSE;
+}
+
+sub pop {
+    my $self = shift;
+    $self->{'conditionState'} = pop(@{$self->{'lastConditionState'}});
+    return pop(@{$self->{'values'}});
+}
+
+sub enabled {
+    my $self = shift;
+    return $self->{'conditionState'} == COND_TRUE;
+}
+
+sub disabled {
+    my $self = shift;
+    return $self->{'conditionState'} != COND_TRUE;
+}
+
+sub filter {
+    my $self = shift;
+    my($filter, $value) = @_;
+    die "not a valid filter name: '$filter'\n" if $filter =~ m/\W/;
+    $self->{'filters'}->{$filter} = $value;
+}
+
+sub expand {
+    my $self = shift;
+    my($line) = @_;
+    $line =~ s/__(\w+)__/$self->get($1)/gose;
+    return $line;
+}
+
+sub print {
+    my $self = shift;
+    return if $self->{'dependencies'};
+    foreach my $line (@_) {
+        if (chomp $line) {
+            CORE::print("$line$self->{'lineEndings'}");
+        } else {
+            CORE::print($line);
+        }
+    }
+}
+
+sub visit {
+    my $self = shift;
+    my($filename) = @_;
+    my $directory = $stack->{'variables'}->{'DIRECTORY'};
+    $filename = File::Spec::_0_8::abs2rel(File::Spec::_0_8::rel2abs($filename, $directory));
+    CORE::print("$filename\n");
+}
+
+########################################################################
+
+package preprocessor;
+
+sub define {
+    my $stack = shift;
+    return if $stack->disabled;
+    die "argument expected\n" unless @_;
+    my $argument = shift;
+    for ($argument) {
+        /^(\w+)\s(.*)$/os && do {
+            return $stack->define($1, $2);
+        };
+        /^(\w+)$/os && do {
+            return $stack->define($1, 1);
+        };
+        die "invalid argument: '$_'\n";
+    }
+}
+
+sub undef {
+    my $stack = shift;
+    return if $stack->disabled;
+    die "argument expected\n" unless @_;
+    $stack->undefine(@_);
+}
+
+sub ifdef {
+    my $stack = shift;
+    my $variable = shift;
+    my $replace = defined(shift);
+    die "argument expected\n" unless defined($variable);
+    if ($replace) {
+        $stack->replace($stack->defined($variable));
+    } else {
+        $stack->push($stack->defined($variable));
+    }
+}
+
+sub ifndef {
+    my $stack = shift;
+    my $variable = shift;
+    my $replace = defined(shift);
+    die "argument expected\n" unless defined($variable);
+    if ($replace) {
+        $stack->replace(not $stack->defined($variable));
+    } else {
+        $stack->push(not $stack->defined($variable));
+    }
+}
+
+sub if {
+    my $stack = shift;
+    die "argument expected\n" unless @_;
+    my $argument = shift;
+    my $replace = defined(shift);
+    for ($argument) {
+        /^(\w+)==(.*)$/os && do {
+            # equality
+            if ($replace) {
+                return $stack->replace($stack->get($1) eq $2);
+            } else {
+                return $stack->push($stack->get($1) eq $2);
+            }
+        };
+        /^(\w+)!=(.*)$/os && do {
+            # inequality
+            if ($replace) {
+                return $stack->replace($stack->get($1) ne $2);
+            } else {
+                return $stack->push($stack->get($1) ne $2);
+            }
+        };
+        /^(\w+)$/os && do {
+            # true value
+            if ($replace) {
+                return $stack->replace($stack->get($1));
+            } else {
+                return $stack->push($stack->get($1));
+            }
+        };
+        /^!(\w+)$/os && do {
+            # false value
+            if ($replace) {
+                return $stack->replace(not $stack->get($1));
+            } else {
+                return $stack->push(not $stack->get($1));
+            }
+        };
+        die "invalid argument: '$_'\n";
+    }
+}
+
+sub else {
+    my $stack = shift;
+    die "argument unexpected\n" if @_;
+    $stack->replace(1);
+}
+
+sub elif {
+    my $stack = shift;
+    die "argument expected\n" unless @_;
+    &if($stack, @_, 1);
+}
+
+sub elifdef {
+    my $stack = shift;
+    die "argument expected\n" unless @_;
+    &ifdef($stack, @_, 1);
+}
+
+sub elifndef {
+    my $stack = shift;
+    die "argument expected\n" unless @_;
+    &ifndef($stack, @_, 1);
+}
+
+sub endif {
+    my $stack = shift;
+    die "argument unexpected\n" if @_;
+    $stack->pop;
+}
+
+sub error {
+    my $stack = shift;
+    return if $stack->disabled;
+    die "argument expected\n" unless @_;
+    my $line = $stack->expand(@_);
+    die "$line\n";
+}
+
+sub expand {
+    my $stack = shift;
+    return if $stack->disabled;
+    die "argument expected\n" unless @_;
+    my $line = $stack->expand(@_);
+    $stack->print("$line\n");
+}
+
+sub literal {
+    my $stack = shift;
+    return if $stack->disabled;
+    die "argument expected\n" unless @_;
+    my $line = shift;
+    $stack->print("$line\n");
+}
+
+sub include {
+    my $stack = shift;
+    return if $stack->disabled;
+    die "argument expected\n" unless @_;
+    my $filename = File::Spec::_0_8::catpath(File::Spec::_0_8::splitpath(@_));
+    if ($stack->{'dependencies'}) {
+        $stack->visit($filename);
+    } else {
+        main::include($stack, $filename);
+    }
+}
+
+sub includesubst {
+    my ($stack, $filename) = @_;
+    return if $stack->disabled;
+    die "argument expected\n" unless $filename;
+    $filename =~ s/@(\w+)@/$stack->get($1, 1)/gose;
+    $filename = File::Spec::_0_8::catpath(File::Spec::_0_8::splitpath($filename));
+    if ($stack->{'dependencies'}) {
+        $stack->visit($filename);
+    } else {
+        main::include($stack, $filename);
+    }
+}
+
+sub filter {
+    my $stack = shift;
+    return if $stack->disabled;
+    die "argument expected\n" unless @_;
+    foreach (split(/\s/os, shift)) {
+        $stack->filter($_, 1);
+    }
+}
+
+sub unfilter {
+    my $stack = shift;
+    return if $stack->disabled;
+    die "argument expected\n" unless @_;
+    foreach (split(/\s/os, shift)) {
+        $stack->filter($_, 0);
+    }
+}
+
+
+########################################################################
+
+package filter;
+
+sub emptyLines {
+    my($stack, $text) = @_;
+    $text = "" if $text eq "\n";
+    return $text;
+}
+
+sub spaces {
+    my($stack, $text) = @_;
+    $text =~ s/ +/ /gos; # middle spaces
+    $text =~ s/^ //gos; # start spaces
+    $text =~ s/ (\n?)$/$1/gos; # end spaces
+    return $text;
+}
+
+sub slashslash {
+    my($stack, $text) = @_;
+    $text =~ s|//.*?(\n?)$|$1|gos;
+    return $text;
+}
+
+sub substitution {
+    my($stack, $text) = @_;
+    $text =~ s/@(\w+)@/$stack->get($1, 1)/gose;
+    return $text;
+}
+
+sub attemptSubstitution {
+    my($stack, $text) = @_;
+    $text =~ s/@(\w+)@/$stack->get($1, 0)/gose;
+    return $text;
+}
+
+########################################################################
+
+########################################################################
+# This code is from File::Spec::Unix 0.8.
+# It is not considered a part of the preprocessor.pl source file
+# This code is licensed under the same license as File::Spec itself.
+
+package File::Spec::_0_8;
+
+use Cwd;
+
+sub rel2abs {
+    my ($path, $base) = @_;
+    if ( ! File::Spec->file_name_is_absolute( $path ) ) {
+        if ( !defined( $base ) || $base eq '' ) {
+            $base = cwd() ;
+        } elsif ( ! File::Spec->file_name_is_absolute( $base ) ) {
+            $base = rel2abs( $base );
+        } else {
+            $base = File::Spec->canonpath( $base );
+        }
+        $path = File::Spec->catdir( $base, $path );
+    }
+    return File::Spec->canonpath( $path );
+}
+
+sub splitdir {
+    return split m|/|, $_[1], -1;  # Preserve trailing fields
+}
+
+sub splitpath {
+    my ($path, $nofile) = @_;
+
+    my ($volume,$directory,$file) = ('','','');
+
+    if ( $nofile ) {
+        $directory = $path;
+    }
+    else {
+        $path =~ m|^ ( (?: .* / (?: \.\.?\Z(?!\n) )? )? ) ([^/]*) |xs;
+        $directory = $1;
+        $file      = $2;
+    }
+
+    return ($volume,$directory,$file);
+}
+
+sub catpath {
+    my ($volume,$directory,$file) = @_;
+
+    if ( $directory ne ''                && 
+         $file ne ''                     && 
+         substr( $directory, -1 ) ne '/' && 
+         substr( $file, 0, 1 ) ne '/' 
+    ) {
+        $directory .= "/$file" ;
+    }
+    else {
+        $directory .= $file ;
+    }
+
+    return $directory ;
+}
+
+sub abs2rel {
+    my($path,$base) = @_;
+
+    # Clean up $path
+    if ( ! File::Spec->file_name_is_absolute( $path ) ) {
+        $path = rel2abs( $path ) ;
+    }
+    else {
+        $path = File::Spec->canonpath( $path ) ;
+    }
+
+    # Figure out the effective $base and clean it up.
+    if ( !defined( $base ) || $base eq '' ) {
+        $base = cwd();
+    }
+    elsif ( ! File::Spec->file_name_is_absolute( $base ) ) {
+        $base = rel2abs( $base ) ;
+    }
+    else {
+        $base = File::Spec->canonpath( $base ) ;
+    }
+
+    # Now, remove all leading components that are the same
+    my @pathchunks = File::Spec::_0_8::splitdir( $path);
+    my @basechunks = File::Spec::_0_8::splitdir( $base);
+
+    while (@pathchunks && @basechunks && $pathchunks[0] eq $basechunks[0]) {
+        shift @pathchunks ;
+        shift @basechunks ;
+    }
+
+    $path = CORE::join( '/', @pathchunks );
+    $base = CORE::join( '/', @basechunks );
+
+    # $base now contains the directories the resulting relative path 
+    # must ascend out of before it can descend to $path_directory.  So, 
+    # replace all names with $parentDir
+    $base =~ s|[^/]+|..|g ;
+
+    # Glue the two together, using a separator if necessary, and preventing an
+    # empty result.
+    if ( $path ne '' && $base ne '' ) {
+        $path = "$base/$path" ;
+    } else {
+        $path = "$base$path" ;
+    }
+
+    return File::Spec->canonpath( $path ) ;
+}
+
+# End code from File::Spec::Unix 0.8.
+########################################################################
diff -r 17e9560465b0 js/src/config/revdepth-nt.pl
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/revdepth-nt.pl	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,48 @@
+#! perl
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+# Netscape Communications Corporation.
+# Portions created by the Initial Developer are Copyright (C) 1998
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+require "/ns/config/fastcwd.pl";
+
+$cur = &fastcwd;
+chdir($ARGV[0]);
+$newcur = &fastcwd;
+$newcurlen = length($newcur);
+
+# Skip common separating / unless $newcur is "/"
+$cur = substr($cur, $newcurlen + ($newcurlen > 1));
+print $cur;
diff -r 17e9560465b0 js/src/config/revdepth.pl
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/revdepth.pl	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,51 @@
+#! perl
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+# Netscape Communications Corporation.
+# Portions created by the Initial Developer are Copyright (C) 1998
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+unshift(@INC, '/usr/lib/perl');
+unshift(@INC, '/usr/local/lib/perl');
+
+require "fastcwd.pl";
+
+$cur = &fastcwd;
+chdir($ARGV[0]);
+$newcur = &fastcwd;
+$newcurlen = length($newcur);
+
+# Skip common separating / unless $newcur is "/"
+$cur = substr($cur, $newcurlen + ($newcurlen > 1));
+print $cur;
diff -r 17e9560465b0 js/src/config/rules.mk
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/rules.mk	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,2254 @@
+# vim:set ts=8 sw=8 sts=8 noet:
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+# Netscape Communications Corporation.
+# Portions created by the Initial Developer are Copyright (C) 1998
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#  Chase Phillips <chase@mozilla.org>
+#  Benjamin Smedberg <benjamin@smedbergs.us>
+#  Jeff Walden <jwalden+code@mit.edu>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+ifndef topsrcdir
+topsrcdir		= $(DEPTH)
+endif
+
+ifndef MOZILLA_DIR
+MOZILLA_DIR = $(topsrcdir)
+endif
+
+ifndef INCLUDED_CONFIG_MK
+include $(topsrcdir)/config/config.mk
+endif
+
+ifndef INCLUDED_VERSION_MK
+include $(topsrcdir)/config/version.mk
+endif
+
+REPORT_BUILD = @echo $(notdir $<)
+
+ifeq ($(OS_ARCH),OS2)
+EXEC			=
+else
+EXEC			= exec
+endif
+
+# ELOG prints out failed command when building silently (gmake -s).
+ifneq (,$(findstring -s,$(MAKEFLAGS)))
+  ELOG := $(EXEC) sh $(BUILD_TOOLS)/print-failed-commands.sh
+else
+  ELOG :=
+endif
+
+ifeq (,$(filter-out WINNT WINCE,$(OS_ARCH)))
+ifndef GNU_CC
+_LIBNAME_RELATIVE_PATHS=1
+endif
+endif
+
+ifeq (,$(filter-out WINNT WINCE,$(OS_ARCH)))
+PWD := $(shell pwd)
+_VPATH_SRCS = $(if $(filter /%,$<),$<,$(PWD)/$<)
+else
+_VPATH_SRCS = $<
+endif
+
+# Add $(DIST)/lib to VPATH so that -lfoo dependencies are followed
+VPATH += $(DIST)/lib
+ifdef LIBXUL_SDK
+VPATH += $(LIBXUL_SDK)/lib
+endif
+
+# EXPAND_LIBNAME - $(call EXPAND_LIBNAME,foo)
+# expands to foo.lib on platforms with import libs and -lfoo otherwise
+
+# EXPAND_LIBNAME_PATH - $(call EXPAND_LIBNAME_PATH,foo,dir)
+# expands to dir/foo.lib on platforms with import libs and
+# -Ldir -lfoo otherwise
+
+# EXPAND_MOZLIBNAME - $(call EXPAND_MOZLIBNAME,foo)
+# expands to $(DIST)/lib/foo.lib on platforms with import libs and
+# -lfoo otherwise
+
+ifdef _LIBNAME_RELATIVE_PATHS
+EXPAND_LIBNAME = $(foreach lib,$(1),$(LIB_PREFIX)$(lib).$(LIB_SUFFIX))
+EXPAND_LIBNAME_PATH = $(foreach lib,$(1),$(2)/$(LIB_PREFIX)$(lib).$(LIB_SUFFIX))
+EXPAND_MOZLIBNAME = $(foreach lib,$(1),$(DIST)/lib/$(LIB_PREFIX)$(lib).$(LIB_SUFFIX))
+else
+EXPAND_LIBNAME = $(addprefix -l,$(1))
+EXPAND_LIBNAME_PATH = -L$(2) $(addprefix -l,$(1))
+EXPAND_MOZLIBNAME = $(addprefix -l,$(1))
+endif
+
+ifdef EXTRA_DSO_LIBS
+EXTRA_DSO_LIBS	:= $(call EXPAND_MOZLIBNAME,$(EXTRA_DSO_LIBS))
+endif
+
+#
+# Library rules
+#
+# If BUILD_STATIC_LIBS or FORCE_STATIC_LIB is set, build a static library.
+# Otherwise, build a shared library.
+#
+
+ifndef LIBRARY
+ifdef LIBRARY_NAME
+ifneq (,$(filter OS2 WINNT WINCE,$(OS_ARCH)))
+ifdef SHORT_LIBNAME
+LIBRARY_NAME		:= $(SHORT_LIBNAME)
+endif
+endif
+LIBRARY			:= $(LIB_PREFIX)$(LIBRARY_NAME).$(LIB_SUFFIX)
+endif
+endif
+
+ifndef HOST_LIBRARY
+ifdef HOST_LIBRARY_NAME
+HOST_LIBRARY		:= $(LIB_PREFIX)$(HOST_LIBRARY_NAME).$(LIB_SUFFIX)
+endif
+endif
+
+ifdef LIBRARY
+ifneq (_1,$(FORCE_SHARED_LIB)_$(BUILD_STATIC_LIBS))
+ifdef MKSHLIB
+
+ifdef LIB_IS_C_ONLY
+MKSHLIB			= $(MKCSHLIB)
+endif
+
+ifdef MAKE_FRAMEWORK
+SHARED_LIBRARY		:= $(LIBRARY_NAME)
+else
+SHARED_LIBRARY		:= $(DLL_PREFIX)$(LIBRARY_NAME)$(DLL_SUFFIX)
+endif
+
+ifeq ($(OS_ARCH),OS2)
+DEF_FILE		:= $(SHARED_LIBRARY:.dll=.def)
+endif
+
+ifneq (,$(filter OS2 WINNT WINCE,$(OS_ARCH)))
+IMPORT_LIBRARY		:= $(LIB_PREFIX)$(LIBRARY_NAME).$(IMPORT_LIB_SUFFIX)
+endif
+
+ifdef MOZ_ENABLE_LIBXUL
+EMBED_MANIFEST_AT=2
+endif
+
+endif # MKSHLIB
+endif # FORCE_SHARED_LIB && !BUILD_STATIC_LIBS
+endif # LIBRARY
+
+ifeq (,$(BUILD_STATIC_LIBS)$(FORCE_STATIC_LIB))
+LIBRARY			:= $(NULL)
+endif
+
+ifeq (_1,$(FORCE_SHARED_LIB)_$(BUILD_STATIC_LIBS))
+SHARED_LIBRARY		:= $(NULL)
+DEF_FILE		:= $(NULL)
+IMPORT_LIBRARY		:= $(NULL)
+endif
+
+ifdef FORCE_STATIC_LIB
+ifndef FORCE_SHARED_LIB
+SHARED_LIBRARY		:= $(NULL)
+DEF_FILE		:= $(NULL)
+IMPORT_LIBRARY		:= $(NULL)
+endif
+endif
+
+ifdef FORCE_SHARED_LIB
+ifndef FORCE_STATIC_LIB
+LIBRARY			:= $(NULL)
+endif
+endif
+
+ifdef JAVA_LIBRARY_NAME
+JAVA_LIBRARY := $(JAVA_LIBRARY_NAME).jar
+endif
+
+ifeq (,$(filter-out WINNT WINCE,$(OS_ARCH)))
+ifndef GNU_CC
+
+# Previously when possible we wrote to $LIBRARY_NAME.pdb.  This broke parallel
+# make builds on Windows.  Now we just write to a pdb file per compiled file.
+# See bug 286179 <https://bugzilla.mozilla.org/show_bug.cgi?id=286179> for
+# details. -- chase@mozilla.org
+#
+# Changes to the PDBFILE naming scheme should also be reflected in HOST_PDBFILE
+# 
+ifdef LIBRARY_NAME
+PDBFILE=$(LIBRARY_NAME).pdb
+ifdef MOZ_DEBUG
+CODFILE=$(LIBRARY_NAME).cod
+endif
+else
+PDBFILE=$(basename $(@F)).pdb
+ifdef MOZ_DEBUG
+CODFILE=$(basename $(@F)).cod
+endif
+endif # LIBRARY_NAME
+
+ifdef MOZ_MAPINFO
+ifdef LIBRARY_NAME
+MAPFILE=$(LIBRARY_NAME).map
+else
+MAPFILE=$(basename $(@F)).map
+endif # LIBRARY_NAME
+endif # MOZ_MAPINFO
+
+ifdef DEFFILE
+OS_LDFLAGS += -DEF:$(DEFFILE)
+EXTRA_DEPS += $(DEFFILE)
+endif
+
+ifdef MAPFILE
+OS_LDFLAGS += -MAP:$(MAPFILE)
+#CFLAGS += -Fm$(MAPFILE)
+#CXXFLAGS += -Fm$(MAPFILE)
+endif
+
+#ifdef CODFILE
+#CFLAGS += -Fa$(CODFILE) -FAsc
+#CFLAGS += -Fa$(CODFILE) -FAsc
+#endif
+
+endif # !GNU_CC
+
+ifdef ENABLE_CXX_EXCEPTIONS
+ifdef GNU_CC
+CXXFLAGS		+= -fexceptions
+else
+ifeq (,$(filter-out 1200 1300 1310,$(_MSC_VER)))
+CXXFLAGS		+= -GX
+else
+CXXFLAGS		+= -EHsc
+endif # _MSC_VER
+endif # GNU_CC
+endif # ENABLE_CXX_EXCEPTIONS
+endif # WINNT
+
+ifeq (,$(filter-out WINNT WINCE,$(HOST_OS_ARCH)))
+HOST_PDBFILE=$(basename $(@F)).pdb
+endif
+
+ifndef TARGETS
+TARGETS			= $(LIBRARY) $(SHARED_LIBRARY) $(PROGRAM) $(SIMPLE_PROGRAMS) $(HOST_LIBRARY) $(HOST_PROGRAM) $(HOST_SIMPLE_PROGRAMS) $(JAVA_LIBRARY)
+endif
+
+ifndef OBJS
+_OBJS			= \
+	$(JRI_STUB_CFILES) \
+	$(addsuffix .$(OBJ_SUFFIX), $(JMC_GEN)) \
+	$(CSRCS:.c=.$(OBJ_SUFFIX)) \
+	$(patsubst %.cc,%.$(OBJ_SUFFIX),$(CPPSRCS:.cpp=.$(OBJ_SUFFIX))) \
+	$(CMSRCS:.m=.$(OBJ_SUFFIX)) \
+	$(CMMSRCS:.mm=.$(OBJ_SUFFIX)) \
+	$(ASFILES:.$(ASM_SUFFIX)=.$(OBJ_SUFFIX))
+OBJS	= $(strip $(_OBJS))
+endif
+
+ifndef HOST_OBJS
+_HOST_OBJS		= \
+        $(addprefix host_,$(HOST_CSRCS:.c=.$(OBJ_SUFFIX))) \
+	$(addprefix host_,$(patsubst %.cc,%.$(OBJ_SUFFIX),$(HOST_CPPSRCS:.cpp=.$(OBJ_SUFFIX)))) \
+	$(addprefix host_,$(HOST_CMSRCS:.m=.$(OBJ_SUFFIX))) \
+	$(addprefix host_,$(HOST_CMMSRCS:.mm=.$(OBJ_SUFFIX)))
+HOST_OBJS = $(strip $(_HOST_OBJS))
+endif
+
+LIBOBJS			:= $(addprefix \", $(OBJS))
+LIBOBJS			:= $(addsuffix \", $(LIBOBJS))
+
+ifndef MOZ_AUTO_DEPS
+ifneq (,$(OBJS)$(XPIDLSRCS)$(SDK_XPIDLSRCS)$(SIMPLE_PROGRAMS))
+MDDEPFILES		= $(addprefix $(MDDEPDIR)/,$(OBJS:.$(OBJ_SUFFIX)=.pp))
+ifndef NO_GEN_XPT
+MDDEPFILES		+= $(addprefix $(MDDEPDIR)/,$(XPIDLSRCS:.idl=.xpt)) \
+			   $(addprefix $(MDDEPDIR)/,$(SDK_XPIDLSRCS:.idl=.xpt))
+endif
+endif
+endif
+
+ALL_TRASH = \
+	$(GARBAGE) $(TARGETS) $(OBJS) $(PROGOBJS) LOGS TAGS a.out \
+	$(filter-out $(ASFILES),$(OBJS:.$(OBJ_SUFFIX)=.s)) $(OBJS:.$(OBJ_SUFFIX)=.ii) \
+	$(OBJS:.$(OBJ_SUFFIX)=.i) \
+	$(HOST_PROGOBJS) $(HOST_OBJS) $(IMPORT_LIBRARY) $(DEF_FILE)\
+	$(EXE_DEF_FILE) so_locations _gen _stubs $(wildcard *.res) $(wildcard *.RES) \
+	$(wildcard *.pdb) $(CODFILE) $(MAPFILE) $(IMPORT_LIBRARY) \
+	$(SHARED_LIBRARY:$(DLL_SUFFIX)=.exp) $(wildcard *.ilk) \
+	$(PROGRAM:$(BIN_SUFFIX)=.exp) $(SIMPLE_PROGRAMS:$(BIN_SUFFIX)=.exp) \
+	$(PROGRAM:$(BIN_SUFFIX)=.lib) $(SIMPLE_PROGRAMS:$(BIN_SUFFIX)=.lib) \
+	$(SIMPLE_PROGRAMS:$(BIN_SUFFIX)=.$(OBJ_SUFFIX)) \
+	$(wildcard gts_tmp_*) $(LIBRARY:%.a=.%.timestamp)
+ALL_TRASH_DIRS = \
+	$(GARBAGE_DIRS) /no-such-file
+
+ifdef QTDIR
+GARBAGE                 += $(MOCSRCS)
+endif
+
+ifdef SIMPLE_PROGRAMS
+GARBAGE			+= $(SIMPLE_PROGRAMS:%=%.$(OBJ_SUFFIX))
+endif
+
+ifdef HOST_SIMPLE_PROGRAMS
+GARBAGE			+= $(HOST_SIMPLE_PROGRAMS:%=%.$(OBJ_SUFFIX))
+endif
+
+#
+# the Solaris WorkShop template repository cache.  it occasionally can get
+# out of sync, so targets like clobber should kill it.
+#
+ifeq ($(OS_ARCH),SunOS)
+ifeq ($(GNU_CXX),)
+GARBAGE_DIRS += SunWS_cache
+endif
+endif
+
+ifeq ($(OS_ARCH),OpenVMS)
+GARBAGE			+= $(wildcard *.*_defines)
+ifdef SHARED_LIBRARY
+VMS_SYMVEC_FILE		= $(SHARED_LIBRARY:$(DLL_SUFFIX)=_symvec.opt)
+ifdef MOZ_DEBUG
+VMS_SYMVEC_FILE_MODULE	= $(topsrcdir)/build/unix/vms/$(notdir $(SHARED_LIBRARY:$(DLL_SUFFIX)=_dbg_symvec.opt))
+else
+VMS_SYMVEC_FILE_MODULE	= $(topsrcdir)/build/unix/vms/$(notdir $(SHARED_LIBRARY:$(DLL_SUFFIX)=_symvec.opt))
+endif
+VMS_SYMVEC_FILE_COMP	= $(topsrcdir)/build/unix/vms/component_symvec.opt
+GARBAGE			+= $(VMS_SYMVEC_FILE)
+ifdef IS_COMPONENT
+DSO_LDOPTS := $(filter-out -auto_symvec,$(DSO_LDOPTS)) $(VMS_SYMVEC_FILE)
+endif
+endif
+endif
+
+XPIDL_GEN_DIR		= _xpidlgen
+
+ifdef MOZ_UPDATE_XTERM
+# Its good not to have a newline at the end of the titlebar string because it
+# makes the make -s output easier to read.  Echo -n does not work on all
+# platforms, but we can trick sed into doing it.
+UPDATE_TITLE = sed -e "s!Y!$@ in $(shell $(BUILD_TOOLS)/print-depth-path.sh)/$(dir)!" $(MOZILLA_DIR)/config/xterm.str;
+endif
+
+LOOP_OVER_DIRS = \
+    @$(EXIT_ON_ERROR) \
+    $(foreach dir,$(DIRS),$(UPDATE_TITLE) $(MAKE) -C $(dir) $@; ) true
+
+# we only use this for the makefiles target and other stuff that doesn't matter
+LOOP_OVER_PARALLEL_DIRS = \
+    @$(EXIT_ON_ERROR) \
+    $(foreach dir,$(PARALLEL_DIRS),$(UPDATE_TITLE) $(MAKE) -C $(dir) $@; ) true
+
+LOOP_OVER_STATIC_DIRS = \
+    @$(EXIT_ON_ERROR) \
+    $(foreach dir,$(STATIC_DIRS),$(UPDATE_TITLE) $(MAKE) -C $(dir) $@; ) true
+
+LOOP_OVER_TOOL_DIRS = \
+    @$(EXIT_ON_ERROR) \
+    $(foreach dir,$(TOOL_DIRS),$(UPDATE_TITLE) $(MAKE) -C $(dir) $@; ) true
+
+ifdef PARALLEL_DIRS
+# create a bunch of fake targets for order-only processing
+PARALLEL_DIRS_export = $(addsuffix _export,$(PARALLEL_DIRS))
+PARALLEL_DIRS_libs = $(addsuffix _libs,$(PARALLEL_DIRS))
+PARALLEL_DIRS_tools = $(addsuffix _tools,$(PARALLEL_DIRS))
+endif
+
+#
+# Now we can differentiate between objects used to build a library, and
+# objects used to build an executable in the same directory.
+#
+ifndef PROGOBJS
+PROGOBJS		= $(OBJS)
+endif
+
+ifndef HOST_PROGOBJS
+HOST_PROGOBJS		= $(HOST_OBJS)
+endif
+
+# MAKE_DIRS: List of directories to build while looping over directories.
+ifneq (,$(OBJS)$(XPIDLSRCS)$(SDK_XPIDLSRCS)$(SIMPLE_PROGRAMS))
+MAKE_DIRS		+= $(MDDEPDIR)
+GARBAGE_DIRS		+= $(MDDEPDIR)
+endif
+
+#
+# Tags: emacs (etags), vi (ctags)
+# TAG_PROGRAM := ctags -L -
+#
+TAG_PROGRAM		= xargs etags -a
+
+#
+# Turn on C++ linking if we have any .cpp or .mm files
+# (moved this from config.mk so that config.mk can be included 
+#  before the CPPSRCS are defined)
+#
+ifneq ($(CPPSRCS)$(CMMSRCS),)
+CPP_PROG_LINK		= 1
+endif
+
+#
+# Make sure to wrap static libs inside linker specific flags to turn on & off
+# inclusion of all symbols inside the static libs
+#
+ifndef NO_LD_ARCHIVE_FLAGS
+ifdef SHARED_LIBRARY_LIBS
+EXTRA_DSO_LDOPTS := $(MKSHLIB_FORCE_ALL) $(SHARED_LIBRARY_LIBS) $(MKSHLIB_UNFORCE_ALL) $(EXTRA_DSO_LDOPTS)
+endif
+endif
+
+#
+# This will strip out symbols that the component should not be 
+# exporting from the .dynsym section.
+#
+ifdef IS_COMPONENT
+EXTRA_DSO_LDOPTS += $(MOZ_COMPONENTS_VERSION_SCRIPT_LDFLAGS)
+endif # IS_COMPONENT
+
+#
+# Enforce the requirement that MODULE_NAME must be set 
+# for components in static builds
+#
+ifdef IS_COMPONENT
+ifdef EXPORT_LIBRARY
+ifndef FORCE_SHARED_LIB
+ifndef MODULE_NAME
+$(error MODULE_NAME is required for components which may be used in static builds)
+endif
+endif
+endif
+endif
+
+#
+# MacOS X specific stuff
+#
+
+ifeq ($(OS_ARCH),Darwin)
+ifdef SHARED_LIBRARY
+ifdef IS_COMPONENT
+EXTRA_DSO_LDOPTS	+= -bundle
+else
+EXTRA_DSO_LDOPTS	+= -dynamiclib -install_name @executable_path/$(SHARED_LIBRARY) -compatibility_version 1 -current_version 1 -single_module
+endif
+endif
+endif
+
+#
+# On NetBSD a.out systems, use -Bsymbolic.  This fixes what would otherwise be
+# fatal symbol name clashes between components.
+#
+ifeq ($(OS_ARCH),NetBSD)
+ifeq ($(DLL_SUFFIX),.so.1.0)
+ifdef IS_COMPONENT
+EXTRA_DSO_LDOPTS += -Wl,-Bsymbolic
+endif
+endif
+endif
+
+ifeq ($(OS_ARCH),FreeBSD)
+ifdef IS_COMPONENT
+EXTRA_DSO_LDOPTS += -Wl,-Bsymbolic
+endif
+endif
+
+ifeq ($(OS_ARCH),NetBSD)
+ifneq (,$(filter arc cobalt hpcmips mipsco newsmips pmax sgimips,$(OS_TEST)))
+ifeq ($(MODULE),layout)
+OS_CFLAGS += -Wa,-xgot
+OS_CXXFLAGS += -Wa,-xgot
+endif
+endif
+endif
+
+ifeq ($(OS_ARCH),Linux)
+ifneq (,$(filter mips mipsel,$(OS_TEST)))
+ifeq ($(MODULE),layout)
+OS_CFLAGS += -Wa,-xgot
+OS_CXXFLAGS += -Wa,-xgot
+endif
+endif
+endif
+
+#
+# HP-UXBeOS specific section: for COMPONENTS only, add -Bsymbolic flag
+# which uses internal symbols first
+#
+ifeq ($(OS_ARCH),HP-UX)
+ifdef IS_COMPONENT
+ifeq ($(GNU_CC)$(GNU_CXX),)
+EXTRA_DSO_LDOPTS += -Wl,-Bsymbolic
+ifneq ($(HAS_EXTRAEXPORTS),1)
+MKSHLIB  += -Wl,+eNSGetModule -Wl,+eerrno
+MKCSHLIB += +eNSGetModule +eerrno
+ifneq ($(OS_TEST),ia64)
+MKSHLIB  += -Wl,+e_shlInit
+MKCSHLIB += +e_shlInit
+endif # !ia64
+endif # !HAS_EXTRAEXPORTS
+endif # non-gnu compilers
+endif # IS_COMPONENT
+endif # HP-UX
+
+ifeq ($(OS_ARCH),AIX)
+ifdef IS_COMPONENT
+ifneq ($(HAS_EXTRAEXPORTS),1)
+MKSHLIB += -bE:$(MOZILLA_DIR)/build/unix/aix.exp -bnoexpall
+MKCSHLIB += -bE:$(MOZILLA_DIR)/build/unix/aix.exp -bnoexpall
+endif # HAS_EXTRAEXPORTS
+endif # IS_COMPONENT
+endif # AIX
+
+#
+# OSF1: add -B symbolic flag for components
+#
+ifeq ($(OS_ARCH),OSF1)
+ifdef IS_COMPONENT
+ifeq ($(GNU_CC)$(GNU_CXX),)
+EXTRA_DSO_LDOPTS += -B symbolic
+endif  
+endif  
+endif
+
+#
+# Linux: add -Bsymbolic flag for components
+# 
+ifeq ($(OS_ARCH),Linux)
+ifdef IS_COMPONENT
+EXTRA_DSO_LDOPTS += -Wl,-Bsymbolic
+endif
+endif 
+
+#
+# MINGW32
+#
+ifeq ($(OS_ARCH),WINNT)
+ifdef GNU_CC
+ifndef IS_COMPONENT
+DSO_LDOPTS += -Wl,--out-implib -Wl,$(IMPORT_LIBRARY)
+endif
+endif
+endif
+
+ifeq ($(USE_TVFS),1)
+IFLAGS1 = -rb
+IFLAGS2 = -rb
+else
+IFLAGS1 = -m 644
+IFLAGS2 = -m 755
+endif
+
+ifeq (_WINNT,$(GNU_CC)_$(OS_ARCH))
+OUTOPTION = -Fo# eol
+else
+OUTOPTION = -o # eol
+endif # WINNT && !GNU_CC
+ifneq (,$(filter WINCE,$(OS_ARCH)))
+OUTOPTION = -Fo# eol
+endif
+
+ifeq ($(OS_TARGET), WINCE)
+OUTOPTION = -Fo# eol
+HOST_OUTOPTION = -Fo# eol
+else
+
+ifeq (,$(CROSS_COMPILE))
+HOST_OUTOPTION = $(OUTOPTION)
+else
+HOST_OUTOPTION = -o # eol
+endif
+
+endif
+################################################################################
+
+# SUBMAKEFILES: List of Makefiles for next level down.
+#   This is used to update or create the Makefiles before invoking them.
+SUBMAKEFILES += $(addsuffix /Makefile, $(DIRS) $(TOOL_DIRS))
+PARALLEL_SUBMAKEFILES += $(addsuffix /Makefile, $(PARALLEL_DIRS))
+SUBMAKEFILES += $(PARALLEL_SUBMAKEFILES)
+
+# The root makefile doesn't want to do a plain export/libs, because
+# of the tiers and because of libxul. Suppress the default rules in favor
+# of something else. Makefiles which use this var *must* provide a sensible
+# default rule before including rules.mk
+ifndef SUPPRESS_DEFAULT_RULES
+ifdef TIERS
+
+DIRS += $(foreach tier,$(TIERS),$(tier_$(tier)_dirs))
+STATIC_DIRS += $(foreach tier,$(TIERS),$(tier_$(tier)_staticdirs))
+
+default all alldep::
+	$(EXIT_ON_ERROR) \
+	$(foreach tier,$(TIERS),$(MAKE) tier_$(tier); ) true
+
+else
+
+default all::
+	@$(EXIT_ON_ERROR) \
+	$(foreach dir,$(STATIC_DIRS),$(MAKE) -C $(dir); ) true
+	$(MAKE) export
+	$(MAKE) libs
+	$(MAKE) tools
+
+# Do depend as well
+alldep:: 
+	$(MAKE) export
+	$(MAKE) depend
+	$(MAKE) libs
+	$(MAKE) tools
+
+endif # TIERS
+endif # SUPPRESS_DEFAULT_RULES
+
+ifeq ($(filter s,$(MAKEFLAGS)),)
+ECHO := echo
+QUIET :=
+else
+ECHO := true
+QUIET := -q
+endif
+
+MAKE_TIER_SUBMAKEFILES = +$(if $(tier_$*_dirs),$(MAKE) $(addsuffix /Makefile,$(tier_$*_dirs)))
+
+export_tier_%: 
+	@$(ECHO) "$@"
+	@$(MAKE_TIER_SUBMAKEFILES)
+	@$(EXIT_ON_ERROR) \
+	$(foreach dir,$(tier_$*_dirs),$(MAKE) -C $(dir) export; ) true
+
+libs_tier_%:
+	@$(ECHO) "$@"
+	@$(MAKE_TIER_SUBMAKEFILES)
+	@$(EXIT_ON_ERROR) \
+	$(foreach dir,$(tier_$*_dirs),$(MAKE) -C $(dir) libs; ) true
+
+tools_tier_%:
+	@$(ECHO) "$@"
+	@$(MAKE_TIER_SUBMAKEFILES)
+	@$(EXIT_ON_ERROR) \
+	$(foreach dir,$(tier_$*_dirs),$(MAKE) -C $(dir) tools; ) true
+
+$(foreach tier,$(TIERS),tier_$(tier))::
+	@$(ECHO) "$@: $($@_staticdirs) $($@_dirs)"
+	@$(EXIT_ON_ERROR) \
+	$(foreach dir,$($@_staticdirs),$(MAKE) -C $(dir); ) true
+	$(MAKE) export_$@
+	$(MAKE) libs_$@
+
+# Do everything from scratch
+everything::
+	$(MAKE) clean
+	$(MAKE) alldep
+
+# Add dummy depend target for tinderboxes
+depend::
+
+ifdef ALL_PLATFORMS
+all_platforms:: $(NFSPWD)
+	@d=`$(NFSPWD)`;							\
+	if test ! -d LOGS; then rm -rf LOGS; mkdir LOGS; else true; fi;	\
+	for h in $(PLATFORM_HOSTS); do					\
+		echo "On $$h: $(MAKE) $(ALL_PLATFORMS) >& LOGS/$$h.log";\
+		rsh $$h -n "(chdir $$d;					\
+			     $(MAKE) $(ALL_PLATFORMS) >& LOGS/$$h.log;	\
+			     echo DONE) &" 2>&1 > LOGS/$$h.pid &	\
+		sleep 1;						\
+	done
+
+$(NFSPWD):
+	cd $(@D); $(MAKE) $(@F)
+endif
+
+# Target to only regenerate makefiles
+makefiles: $(SUBMAKEFILES)
+ifneq (,$(DIRS)$(TOOL_DIRS)$(PARALLEL_DIRS))
+	+$(LOOP_OVER_PARALLEL_DIRS)
+	+$(LOOP_OVER_DIRS)
+	+$(LOOP_OVER_TOOL_DIRS)
+endif
+
+ifdef PARALLEL_DIRS
+export:: $(PARALLEL_SUBMAKEFILES) | $(PARALLEL_DIRS_export)
+
+$(PARALLEL_DIRS_export):: %_export:
+	+$(MAKE) -C $* export
+endif
+
+export:: $(SUBMAKEFILES) $(MAKE_DIRS) $(if $(EXPORTS)$(XPIDLSRCS)$(SDK_HEADERS)$(SDK_XPIDLSRCS),$(PUBLIC)) $(if $(SDK_HEADERS)$(SDK_XPIDLSRCS),$(SDK_PUBLIC)) $(if $(XPIDLSRCS),$(IDL_DIR)) $(if $(SDK_XPIDLSRCS),$(SDK_IDL_DIR))
+	+$(LOOP_OVER_DIRS)
+	+$(LOOP_OVER_TOOL_DIRS)
+
+ifdef PARALLEL_DIRS
+tools:: $(PARALLEL_SUBMAKEFILES) | $(PARALLEL_DIRS_tools)
+
+$(PARALLEL_DIRS_tools):: %_tools:
+	+$(MAKE) -C $* tools
+endif
+
+tools:: $(SUBMAKEFILES) $(MAKE_DIRS)
+	+$(LOOP_OVER_DIRS)
+ifdef TOOL_DIRS
+	@$(EXIT_ON_ERROR) \
+	$(foreach dir,$(TOOL_DIRS),$(UPDATE_TITLE) $(MAKE) -C $(dir) libs; ) true
+endif
+
+#
+# Rule to create list of libraries for final link
+#
+export::
+ifdef LIBRARY_NAME
+ifdef EXPORT_LIBRARY
+ifdef IS_COMPONENT
+ifdef BUILD_STATIC_LIBS
+	@$(PERL) -I$(MOZILLA_DIR)/config $(MOZILLA_DIR)/config/build-list.pl $(FINAL_LINK_COMPS) $(LIBRARY_NAME)
+ifdef MODULE_NAME
+	@$(PERL) -I$(MOZILLA_DIR)/config $(MOZILLA_DIR)/config/build-list.pl $(FINAL_LINK_COMP_NAMES) $(MODULE_NAME)
+endif
+endif
+else
+	$(PERL) -I$(MOZILLA_DIR)/config $(MOZILLA_DIR)/config/build-list.pl $(FINAL_LINK_LIBS) $(LIBRARY_NAME)
+endif # IS_COMPONENT
+endif # EXPORT_LIBRARY
+endif # LIBRARY_NAME
+
+# Create dependencies on static (and shared EXTRA_DSO_LIBS) libraries
+LIBS_DEPS = $(filter %.$(LIB_SUFFIX), $(LIBS))
+HOST_LIBS_DEPS = $(filter %.$(LIB_SUFFIX), $(HOST_LIBS))
+DSO_LDOPTS_DEPS = $(EXTRA_DSO_LIBS) $(filter %.$(LIB_SUFFIX), $(EXTRA_DSO_LDOPTS))
+
+##############################################
+ifdef PARALLEL_DIRS
+libs:: $(PARALLEL_SUBMAKEFILES) | $(PARALLEL_DIRS_libs)
+
+$(PARALLEL_DIRS_libs):: %_libs:
+	+$(MAKE) -C $* libs
+endif
+
+libs:: $(SUBMAKEFILES) $(MAKE_DIRS) $(HOST_LIBRARY) $(LIBRARY) $(SHARED_LIBRARY) $(IMPORT_LIBRARY) $(HOST_PROGRAM) $(PROGRAM) $(HOST_SIMPLE_PROGRAMS) $(SIMPLE_PROGRAMS) $(JAVA_LIBRARY)
+ifndef NO_DIST_INSTALL
+ifdef LIBRARY
+ifdef EXPORT_LIBRARY # Stage libs that will be linked into a static build
+ifdef IS_COMPONENT
+	$(INSTALL) $(IFLAGS1) $(LIBRARY) $(DEPTH)/staticlib/components
+else
+	$(INSTALL) $(IFLAGS1) $(LIBRARY) $(DEPTH)/staticlib
+endif
+endif # EXPORT_LIBRARY
+ifdef DIST_INSTALL
+ifdef IS_COMPONENT
+	$(error Shipping static component libs makes no sense.)
+else
+	$(INSTALL) $(IFLAGS1) $(LIBRARY) $(DIST)/lib
+endif
+endif # DIST_INSTALL
+endif # LIBRARY
+ifdef SHARED_LIBRARY
+ifdef IS_COMPONENT
+	$(INSTALL) $(IFLAGS2) $(SHARED_LIBRARY) $(FINAL_TARGET)/components
+	$(ELF_DYNSTR_GC) $(FINAL_TARGET)/components/$(SHARED_LIBRARY)
+ifdef BEOS_ADDON_WORKAROUND
+	( cd $(FINAL_TARGET)/components && $(CC) -nostart -o $(SHARED_LIBRARY).stub $(SHARED_LIBRARY) )
+endif
+else # ! IS_COMPONENT
+ifneq (,$(filter OS2 WINNT WINCE,$(OS_ARCH)))
+	$(INSTALL) $(IFLAGS2) $(IMPORT_LIBRARY) $(DIST)/lib
+else
+	$(INSTALL) $(IFLAGS2) $(SHARED_LIBRARY) $(DIST)/lib
+endif
+	$(INSTALL) $(IFLAGS2) $(SHARED_LIBRARY) $(FINAL_TARGET)
+ifdef BEOS_ADDON_WORKAROUND
+	( cd $(FINAL_TARGET) && $(CC) -nostart -o $(SHARED_LIBRARY).stub $(SHARED_LIBRARY) )
+endif
+endif # IS_COMPONENT
+endif # SHARED_LIBRARY
+ifdef PROGRAM
+	$(INSTALL) $(IFLAGS2) $(PROGRAM) $(FINAL_TARGET)
+endif
+ifdef SIMPLE_PROGRAMS
+	$(INSTALL) $(IFLAGS2) $(SIMPLE_PROGRAMS) $(FINAL_TARGET)
+endif
+ifdef HOST_PROGRAM
+	$(INSTALL) $(IFLAGS2) $(HOST_PROGRAM) $(DIST)/host/bin
+endif
+ifdef HOST_SIMPLE_PROGRAMS
+	$(INSTALL) $(IFLAGS2) $(HOST_SIMPLE_PROGRAMS) $(DIST)/host/bin
+endif
+ifdef HOST_LIBRARY
+	$(INSTALL) $(IFLAGS1) $(HOST_LIBRARY) $(DIST)/host/lib
+endif
+ifdef JAVA_LIBRARY
+ifdef IS_COMPONENT
+	$(INSTALL) $(IFLAGS1) $(JAVA_LIBRARY) $(FINAL_TARGET)/components
+else
+	$(INSTALL) $(IFLAGS1) $(JAVA_LIBRARY) $(FINAL_TARGET)
+endif
+endif # JAVA_LIBRARY
+endif # !NO_DIST_INSTALL
+	+$(LOOP_OVER_DIRS)
+
+##############################################
+
+ifndef NO_PROFILE_GUIDED_OPTIMIZE
+ifneq (,$(MOZ_PROFILE_GENERATE)$(MOZ_PROFILE_USE))
+ifeq ($(OS_ARCH)_$(GNU_CC)$(INTERNAL_TOOLS), WINNT_)
+# Force re-linking when building with PGO, since
+# the MSVC linker does all the work.  We force re-link
+# in both stages so you can do depend builds with PGO.
+ifdef SHARED_LIBRARY
+$(SHARED_LIBRARY): FORCE
+BINARY_BASENAME = $(SHARED_LIBRARY:$(DLL_SUFFIX)=)
+endif
+ifdef PROGRAM
+$(PROGRAM): FORCE
+BINARY_BASENAME = $(PROGRAM:$(BIN_SUFFIX)=)
+endif
+
+ifdef MOZ_PROFILE_USE
+# In the second pass, we need to merge the pgc files into the pgd file.
+# The compiler would do this for us automatically if they were in the right
+# place, but they're in dist/bin.
+ifdef BINARY_BASENAME
+export::
+	$(PYTHON) $(topsrcdir)/build/win32/pgomerge.py \
+	  $(BINARY_BASENAME) $(DIST)/bin
+endif
+endif # MOZ_PROFILE_USE
+endif # WINNT_
+endif # MOZ_PROFILE_GENERATE || MOZ_PROFILE_USE
+endif # NO_PROFILE_GUIDED_OPTIMIZE
+
+##############################################
+
+checkout:
+	$(MAKE) -C $(topsrcdir) -f client.mk checkout
+
+run_viewer: $(FINAL_TARGET)/viewer
+	cd $(FINAL_TARGET); \
+	MOZILLA_FIVE_HOME=`pwd` \
+	LD_LIBRARY_PATH=".:$(LIBS_PATH):$$LD_LIBRARY_PATH" \
+	viewer
+
+clean clobber realclean clobber_all:: $(SUBMAKEFILES)
+	-rm -f $(ALL_TRASH)
+	-rm -rf $(ALL_TRASH_DIRS)
+	+-$(LOOP_OVER_PARALLEL_DIRS)
+	+-$(LOOP_OVER_DIRS)
+	+-$(LOOP_OVER_STATIC_DIRS)
+	+-$(LOOP_OVER_TOOL_DIRS)
+
+distclean:: $(SUBMAKEFILES)
+	+-$(LOOP_OVER_PARALLEL_DIRS)
+	+-$(LOOP_OVER_DIRS)
+	+-$(LOOP_OVER_STATIC_DIRS)
+	+-$(LOOP_OVER_TOOL_DIRS)
+	-rm -rf $(ALL_TRASH_DIRS) 
+	-rm -f $(ALL_TRASH)  \
+	Makefile .HSancillary \
+	$(wildcard *.$(OBJ_SUFFIX)) $(wildcard *.ho) $(wildcard host_*.o*) \
+	$(wildcard *.$(LIB_SUFFIX)) $(wildcard *$(DLL_SUFFIX)) \
+	$(wildcard *.$(IMPORT_LIB_SUFFIX))
+ifeq ($(OS_ARCH),OS2)
+	-rm -f $(PROGRAM:.exe=.map)
+endif
+
+alltags:
+	rm -f TAGS
+	find $(topsrcdir) -name dist -prune -o \( -name '*.[hc]' -o -name '*.cp' -o -name '*.cpp' -o -name '*.idl' \) -print | $(TAG_PROGRAM)
+
+#
+# PROGRAM = Foo
+# creates OBJS, links with LIBS to create Foo
+#
+$(PROGRAM): $(PROGOBJS) $(LIBS_DEPS) $(EXTRA_DEPS) $(EXE_DEF_FILE) $(RESFILE) Makefile Makefile.in
+ifeq (WINCE,$(OS_ARCH))
+	$(LD) -NOLOGO -OUT:$@ $(WIN32_EXE_LDFLAGS) $(LDFLAGS) $(PROGOBJS) $(RESFILE) $(LIBS) $(EXTRA_LIBS) $(OS_LIBS)
+else
+ifeq (_WINNT,$(GNU_CC)_$(OS_ARCH))
+	$(LD) -NOLOGO -OUT:$@ -PDB:$(PDBFILE) $(WIN32_EXE_LDFLAGS) $(LDFLAGS) $(PROGOBJS) $(RESFILE) $(LIBS) $(EXTRA_LIBS) $(OS_LIBS)
+ifdef MSMANIFEST_TOOL
+	@if test -f $@.manifest; then \
+		if test -f "$(srcdir)/$@.manifest"; then \
+			mt.exe -NOLOGO -MANIFEST "$(win_srcdir)/$@.manifest" $@.manifest -OUTPUTRESOURCE:$@\;1; \
+		else \
+			mt.exe -NOLOGO -MANIFEST $@.manifest -OUTPUTRESOURCE:$@\;1; \
+		fi; \
+		rm -f $@.manifest; \
+	fi
+endif	# MSVC with manifest tool
+else
+ifeq ($(CPP_PROG_LINK),1)
+	$(CCC) -o $@ $(CXXFLAGS) $(WRAP_MALLOC_CFLAGS) $(PROGOBJS) $(RESFILE) $(WIN32_EXE_LDFLAGS) $(SOLARIS_JEMALLOC_LDFLAGS) $(LDFLAGS) $(LIBS_DIR) $(LIBS) $(OS_LIBS) $(EXTRA_LIBS) $(BIN_FLAGS) $(WRAP_MALLOC_LIB) $(PROFILER_LIBS) $(EXE_DEF_FILE)
+else # ! CPP_PROG_LINK
+	$(CC) -o $@ $(CFLAGS) $(PROGOBJS) $(RESFILE) $(WIN32_EXE_LDFLAGS) $(SOLARIS_JEMALLOC_LDFLAGS) $(LDFLAGS) $(LIBS_DIR) $(LIBS) $(OS_LIBS) $(EXTRA_LIBS) $(BIN_FLAGS) $(EXE_DEF_FILE)
+endif # CPP_PROG_LINK
+endif # WINNT && !GNU_CC
+endif # WINCE
+
+ifdef ENABLE_STRIP
+	$(STRIP) $@
+endif
+ifdef MOZ_POST_PROGRAM_COMMAND
+	$(MOZ_POST_PROGRAM_COMMAND) $@
+endif
+ifeq ($(OS_ARCH),BeOS)
+ifdef BEOS_PROGRAM_RESOURCE
+	xres -o $@ $(BEOS_PROGRAM_RESOURCE)
+	mimeset $@
+endif
+endif # BeOS
+
+$(HOST_PROGRAM): $(HOST_PROGOBJS) $(HOST_LIBS_DEPS) $(HOST_EXTRA_DEPS) Makefile Makefile.in
+ifeq (WINCE,$(OS_ARCH))
+	$(HOST_LD) -NOLOGO -OUT:$@ $(HOST_OBJS) $(WIN32_EXE_LDFLAGS) $(HOST_LIBS) $(HOST_EXTRA_LIBS)
+else
+ifeq (_WINNT,$(GNU_CC)_$(HOST_OS_ARCH))
+	$(HOST_LD) -NOLOGO -OUT:$@ -PDB:$(PDBFILE) $(HOST_OBJS) $(WIN32_EXE_LDFLAGS) $(HOST_LIBS) $(HOST_EXTRA_LIBS)
+ifdef MSMANIFEST_TOOL
+	@if test -f $@.manifest; then \
+		mt.exe -NOLOGO -MANIFEST $@.manifest -OUTPUTRESOURCE:$@\;1; \
+		rm -f $@.manifest; \
+	fi
+endif	# MSVC with manifest tool
+else
+ifeq ($(CPP_PROG_LINK),1)
+	$(HOST_CXX) -o $@ $(HOST_CXXFLAGS) $(HOST_LDFLAGS) $(HOST_PROGOBJS) $(HOST_LIBS) $(HOST_EXTRA_LIBS)
+else
+	$(HOST_CC) -o $@ $(HOST_CFLAGS) $(HOST_LDFLAGS) $(HOST_PROGOBJS) $(HOST_LIBS) $(HOST_EXTRA_LIBS)
+endif # CPP_PROG_LINK
+endif
+endif
+
+#
+# This is an attempt to support generation of multiple binaries
+# in one directory, it assumes everything to compile Foo is in
+# Foo.o (from either Foo.c or Foo.cpp).
+#
+# SIMPLE_PROGRAMS = Foo Bar
+# creates Foo.o Bar.o, links with LIBS to create Foo, Bar.
+#
+$(SIMPLE_PROGRAMS): %$(BIN_SUFFIX): %.$(OBJ_SUFFIX) $(LIBS_DEPS) $(EXTRA_DEPS) Makefile Makefile.in
+ifeq (WINCE,$(OS_ARCH))
+	$(LD) -nologo  -entry:main -out:$@ $< $(WIN32_EXE_LDFLAGS) $(LDFLAGS) $(LIBS) $(EXTRA_LIBS) $(OS_LIBS)
+else
+ifeq (_WINNT,$(GNU_CC)_$(OS_ARCH))
+	$(LD) -nologo -out:$@ -pdb:$(PDBFILE) $< $(WIN32_EXE_LDFLAGS) $(LDFLAGS) $(LIBS) $(EXTRA_LIBS) $(OS_LIBS)
+ifdef MSMANIFEST_TOOL
+	@if test -f $@.manifest; then \
+		mt.exe -NOLOGO -MANIFEST $@.manifest -OUTPUTRESOURCE:$@\;1; \
+		rm -f $@.manifest; \
+	fi
+endif	# MSVC with manifest tool
+else
+ifeq ($(CPP_PROG_LINK),1)
+	$(CCC) $(WRAP_MALLOC_CFLAGS) $(CXXFLAGS) -o $@ $< $(WIN32_EXE_LDFLAGS) $(SOLARIS_JEMALLOC_LDFLAGS) $(LDFLAGS) $(LIBS_DIR) $(LIBS) $(OS_LIBS) $(EXTRA_LIBS) $(WRAP_MALLOC_LIB) $(PROFILER_LIBS) $(BIN_FLAGS)
+else
+	$(CC) $(WRAP_MALLOC_CFLAGS) $(CFLAGS) $(OUTOPTION)$@ $< $(WIN32_EXE_LDFLAGS) $(SOLARIS_JEMALLOC_LDFLAGS) $(LDFLAGS) $(LIBS_DIR) $(LIBS) $(OS_LIBS) $(EXTRA_LIBS) $(WRAP_MALLOC_LIB) $(PROFILER_LIBS) $(BIN_FLAGS)
+endif # CPP_PROG_LINK
+endif # WINNT && !GNU_CC
+endif # WINCE
+
+ifdef ENABLE_STRIP
+	$(STRIP) $@
+endif
+ifdef MOZ_POST_PROGRAM_COMMAND
+	$(MOZ_POST_PROGRAM_COMMAND) $@
+endif
+
+$(HOST_SIMPLE_PROGRAMS): host_%$(HOST_BIN_SUFFIX): host_%.$(OBJ_SUFFIX) $(HOST_LIBS_DEPS) $(HOST_EXTRA_DEPS) Makefile Makefile.in
+ifeq (WINCE,$(OS_ARCH))
+	$(HOST_LD) -NOLOGO -OUT:$@ $(WIN32_EXE_LDFLAGS) $< $(HOST_LIBS) $(HOST_EXTRA_LIBS)
+else
+ifeq (WINNT_,$(HOST_OS_ARCH)_$(GNU_CC))
+	$(HOST_LD) -NOLOGO -OUT:$@ -PDB:$(PDBFILE) $< $(WIN32_EXE_LDFLAGS) $(HOST_LIBS) $(HOST_EXTRA_LIBS)
+else
+ifneq (,$(HOST_CPPSRCS)$(USE_HOST_CXX))
+	$(HOST_CXX) $(HOST_OUTOPTION)$@ $(HOST_CXXFLAGS) $(INCLUDES) $< $(HOST_LIBS) $(HOST_EXTRA_LIBS)
+else
+	$(HOST_CC) $(HOST_OUTOPTION)$@ $(HOST_CFLAGS) $(INCLUDES) $< $(HOST_LIBS) $(HOST_EXTRA_LIBS)
+endif
+endif
+endif
+
+#
+# Purify target.  Solaris/sparc only to start.
+# Purify does not recognize "egcs" or "c++" so we go with 
+# "gcc" and "g++" for now.
+#
+pure:	$(PROGRAM)
+ifeq ($(CPP_PROG_LINK),1)
+	$(PURIFY) $(CCC) -o $^.pure $(CXXFLAGS) $(PROGOBJS) $(LDFLAGS) $(LIBS_DIR) $(LIBS) $(OS_LIBS) $(EXTRA_LIBS)
+else
+	$(PURIFY) $(CC) -o $^.pure $(CFLAGS) $(PROGOBJS) $(LDFLAGS) $(LIBS_DIR) $(LIBS) $(OS_LIBS) $(EXTRA_LIBS)
+endif
+ifndef NO_DIST_INSTALL
+	$(INSTALL) $(IFLAGS2) $^.pure $(FINAL_TARGET)
+endif
+
+quantify: $(PROGRAM)
+ifeq ($(CPP_PROG_LINK),1)
+	$(QUANTIFY) $(CCC) -o $^.quantify $(CXXFLAGS) $(PROGOBJS) $(LDFLAGS) $(LIBS_DIR) $(LIBS) $(OS_LIBS) $(EXTRA_LIBS)
+else
+	$(QUANTIFY) $(CC) -o $^.quantify $(CFLAGS) $(PROGOBJS) $(LDFLAGS) $(LIBS_DIR) $(LIBS) $(OS_LIBS) $(EXTRA_LIBS)
+endif
+ifndef NO_DIST_INSTALL
+	$(INSTALL) $(IFLAGS2) $^.quantify $(FINAL_TARGET)
+endif
+
+#
+# This allows us to create static versions of the shared libraries
+# that are built using other static libraries.  Confused...?
+#
+ifdef SHARED_LIBRARY_LIBS
+ifeq (,$(GNU_LD)$(filter-out OS2 WINNT WINCE, $(OS_ARCH)))
+ifneq (,$(BUILD_STATIC_LIBS)$(FORCE_STATIC_LIB))
+LOBJS	+= $(SHARED_LIBRARY_LIBS)
+endif
+else
+ifneq (,$(filter OSF1 BSD_OS FreeBSD NetBSD OpenBSD SunOS Darwin,$(OS_ARCH)))
+CLEANUP1	:= | egrep -v '(________64ELEL_|__.SYMDEF)'
+CLEANUP2	:= rm -f ________64ELEL_ __.SYMDEF
+else
+CLEANUP2	:= true
+endif
+SUB_LOBJS	= $(shell for lib in $(SHARED_LIBRARY_LIBS); do $(AR_LIST) $${lib} $(CLEANUP1); done;)
+endif
+endif
+ifdef MOZILLA_PROBE_LIBS
+PROBE_LOBJS	= $(shell for lib in $(MOZILLA_PROBE_LIBS); do $(AR_LIST) $${lib} $(CLEANUP1); done;)
+endif
+ifdef DTRACE_PROBE_OBJ
+EXTRA_DEPS += $(DTRACE_PROBE_OBJ)
+endif
+
+$(LIBRARY): $(OBJS) $(LOBJS) $(SHARED_LIBRARY_LIBS) $(EXTRA_DEPS) Makefile Makefile.in
+	rm -f $@
+ifneq (,$(GNU_LD)$(filter-out OS2 WINNT WINCE, $(OS_ARCH)))
+ifdef SHARED_LIBRARY_LIBS
+	@rm -f $(SUB_LOBJS)
+	@for lib in $(SHARED_LIBRARY_LIBS); do $(AR_EXTRACT) $${lib}; $(CLEANUP2); done
+endif
+endif
+	$(AR) $(AR_FLAGS) $(OBJS) $(LOBJS) $(SUB_LOBJS)
+	$(RANLIB) $@
+	@rm -f foodummyfilefoo $(SUB_LOBJS)
+
+ifeq (,$(filter-out WINNT WINCE, $(OS_ARCH)))
+$(IMPORT_LIBRARY): $(SHARED_LIBRARY)
+endif
+
+ifeq ($(OS_ARCH),OS2)
+$(DEF_FILE): $(OBJS) $(SHARED_LIBRARY_LIBS)
+	rm -f $@
+	echo LIBRARY $(LIBRARY_NAME) INITINSTANCE TERMINSTANCE > $@
+	echo PROTMODE >> $@
+	echo CODE    LOADONCALL MOVEABLE DISCARDABLE >> $@
+	echo DATA    PRELOAD MOVEABLE MULTIPLE NONSHARED >> $@
+	echo EXPORTS >> $@
+ifeq ($(IS_COMPONENT),1)
+ifeq ($(HAS_EXTRAEXPORTS),1)
+ifndef MOZ_OS2_USE_DECLSPEC
+	$(FILTER) $(OBJS) $(SHARED_LIBRARY_LIBS) >> $@
+endif	
+else
+	echo    _NSGetModule >> $@
+endif
+else
+ifndef MOZ_OS2_USE_DECLSPEC
+	$(FILTER) $(OBJS) $(SHARED_LIBRARY_LIBS) >> $@
+endif	
+endif
+	$(ADD_TO_DEF_FILE)
+
+ifdef MOZ_OS2_USE_DECLSPEC
+$(IMPORT_LIBRARY): $(SHARED_LIBRARY)
+else
+$(IMPORT_LIBRARY): $(DEF_FILE)
+endif
+	rm -f $@
+	$(IMPLIB) $@ $^
+	$(RANLIB) $@
+endif # OS/2
+
+$(HOST_LIBRARY): $(HOST_OBJS) Makefile
+	rm -f $@
+	$(HOST_AR) $(HOST_AR_FLAGS) $(HOST_OBJS)
+	$(HOST_RANLIB) $@
+
+ifdef NO_LD_ARCHIVE_FLAGS
+SUB_SHLOBJS = $(SUB_LOBJS)
+endif
+
+ifdef HAVE_DTRACE
+ifndef XP_MACOSX
+ifdef DTRACE_PROBE_OBJ
+ifndef DTRACE_LIB_DEPENDENT
+$(DTRACE_PROBE_OBJ): $(OBJS)
+	dtrace -G -C -32 -s $(MOZILLA_DTRACE_SRC) -o $(DTRACE_PROBE_OBJ) $(OBJS)
+endif
+endif
+endif
+endif
+
+# On Darwin (Mac OS X), dwarf2 debugging uses debug info left in .o files,
+# so instead of deleting .o files after repacking them into a dylib, we make
+# symlinks back to the originals. The symlinks are a no-op for stabs debugging,
+# so no need to conditionalize on OS version or debugging format.
+
+$(SHARED_LIBRARY): $(OBJS) $(LOBJS) $(DEF_FILE) $(RESFILE) $(SHARED_LIBRARY_LIBS) $(EXTRA_DEPS) $(DSO_LDOPTS_DEPS) Makefile Makefile.in
+ifndef INCREMENTAL_LINKER
+	rm -f $@
+endif
+ifeq ($(OS_ARCH),OpenVMS)
+	@if test ! -f $(VMS_SYMVEC_FILE); then \
+	  if test -f $(VMS_SYMVEC_FILE_MODULE); then \
+	    echo Creating specific component options file $(VMS_SYMVEC_FILE); \
+	    cp $(VMS_SYMVEC_FILE_MODULE) $(VMS_SYMVEC_FILE); \
+	  fi; \
+	fi
+ifdef IS_COMPONENT
+	@if test ! -f $(VMS_SYMVEC_FILE); then \
+	  echo Creating generic component options file $(VMS_SYMVEC_FILE); \
+	  cp $(VMS_SYMVEC_FILE_COMP) $(VMS_SYMVEC_FILE); \
+	fi
+endif
+endif # OpenVMS
+ifdef NO_LD_ARCHIVE_FLAGS
+ifdef SHARED_LIBRARY_LIBS
+	@rm -f $(SUB_SHLOBJS)
+	@for lib in $(SHARED_LIBRARY_LIBS); do $(AR_EXTRACT) $${lib}; $(CLEANUP2); done
+ifeq ($(OS_ARCH),Darwin)
+	@echo Making symlinks to the original object files in the archive libraries $(SHARED_LIBRARY_LIBS)
+	@for lib in $(SHARED_LIBRARY_LIBS); do \
+		libdir=`echo $$lib|sed -e 's,/[^/]*\.a,,'`; \
+		ofiles=`$(AR_LIST) $${lib}`; \
+		for ofile in $$ofiles; do \
+			if [ -f $$libdir/$$ofile ]; then \
+				rm -f $$ofile; \
+				ln -s $$libdir/$$ofile $$ofile; \
+			fi; \
+		done; \
+	done
+endif
+endif # SHARED_LIBRARY_LIBS
+endif # NO_LD_ARCHIVE_FLAGS
+ifdef DTRACE_LIB_DEPENDENT
+	@rm -f $(PROBE_LOBJS)
+	@for lib in $(MOZILLA_PROBE_LIBS); do $(AR_EXTRACT) $${lib}; $(CLEANUP2); done
+ifndef XP_MACOSX
+	dtrace -G -C -32 -s $(MOZILLA_DTRACE_SRC) -o  $(DTRACE_PROBE_OBJ) $(PROBE_LOBJS)
+endif
+	@for lib in $(MOZILLA_PROBE_LIBS); do \
+		ofiles=`$(AR_LIST) $${lib}`; \
+		$(AR_DELETE) $${lib} $$ofiles; \
+	done
+	$(MKSHLIB) $(SHLIB_LDSTARTFILE) $(OBJS) $(LOBJS) $(SUB_SHLOBJS) $(DTRACE_PROBE_OBJ) $(PROBE_LOBJS) $(RESFILE) $(LDFLAGS) $(EXTRA_DSO_LDOPTS) $(OS_LIBS) $(EXTRA_LIBS) $(DEF_FILE) $(SHLIB_LDENDFILE)
+	@rm -f $(PROBE_LOBJS)
+	@rm -f $(DTRACE_PROBE_OBJ)
+	@for lib in $(MOZILLA_PROBE_LIBS); do \
+		if [ -L $${lib} ]; then rm -f `readlink $${lib}`; fi; \
+	done
+	@rm -f $(MOZILLA_PROBE_LIBS)
+
+else # ! DTRACE_LIB_DEPENDENT
+	$(MKSHLIB) $(SHLIB_LDSTARTFILE) $(OBJS) $(DTRACE_PROBE_OBJ) $(LOBJS) $(SUB_SHLOBJS) $(RESFILE) $(LDFLAGS) $(EXTRA_DSO_LDOPTS) $(OS_LIBS) $(EXTRA_LIBS) $(DEF_FILE) $(SHLIB_LDENDFILE)
+endif # DTRACE_LIB_DEPENDENT
+
+ifeq (_WINNT,$(GNU_CC)_$(OS_ARCH))
+ifdef MSMANIFEST_TOOL
+ifdef EMBED_MANIFEST_AT
+	@if test -f $@.manifest; then \
+		mt.exe -NOLOGO -MANIFEST $@.manifest -OUTPUTRESOURCE:$@\;$(EMBED_MANIFEST_AT); \
+		rm -f $@.manifest; \
+	fi
+endif   # EMBED_MANIFEST_AT
+endif	# MSVC with manifest tool
+endif	# WINNT && !GCC
+ifeq ($(OS_ARCH),Darwin)
+else # non-Darwin
+	@rm -f $(SUB_SHLOBJS)
+endif # Darwin
+	@rm -f foodummyfilefoo $(DELETE_AFTER_LINK)
+	chmod +x $@
+ifdef ENABLE_STRIP
+	$(STRIP) $@
+endif
+ifdef MOZ_POST_DSO_LIB_COMMAND
+	$(MOZ_POST_DSO_LIB_COMMAND) $@
+endif
+
+ifdef MOZ_AUTO_DEPS
+ifdef COMPILER_DEPEND
+ifeq (__SunOS,$(GNU_CC)_$(GNU_CXX)_$(OS_ARCH))
+_MDDEPFILE = $(MDDEPDIR)/$(@F).pp
+
+define MAKE_DEPS_AUTO_CC
+if test -d $(@D); then \
+	echo "Building deps for $< using Sun Studio cc"; \
+	$(CC) $(COMPILE_CFLAGS) -xM  $< >$(_MDDEPFILE) ; \
+fi
+endef
+define MAKE_DEPS_AUTO_CXX
+if test -d $(@D); then \
+	echo "Building deps for $< using Sun Studio CC"; \
+	$(CXX) $(COMPILE_CXXFLAGS) -xM $< >$(_MDDEPFILE) ; \
+fi
+endef
+endif # Sun Studio on Solaris
+else # COMPILER_DEPEND
+#
+# Generate dependencies on the fly
+#
+_MDDEPFILE = $(MDDEPDIR)/$(@F).pp
+
+define MAKE_DEPS_AUTO
+if test -d $(@D); then \
+	echo "Building deps for $<"; \
+	$(MKDEPEND) -o'.$(OBJ_SUFFIX)' -f- $(DEFINES) $(ACDEFINES) $(INCLUDES) $< 2>/dev/null | sed -e "s|^[^ ]*/||" > $(_MDDEPFILE) ; \
+fi
+endef
+
+MAKE_DEPS_AUTO_CC = $(MAKE_DEPS_AUTO)
+MAKE_DEPS_AUTO_CXX = $(MAKE_DEPS_AUTO)
+
+endif # COMPILER_DEPEND
+
+endif # MOZ_AUTO_DEPS
+
+ifdef MOZ_MEMORY
+ifeq ($(OS_ARCH),SunOS)
+SOLARIS_JEMALLOC_LDFLAGS = $(call EXPAND_LIBNAME_PATH,jemalloc,$(DIST)/lib)
+endif
+endif
+
+# Rules for building native targets must come first because of the host_ prefix
+host_%.$(OBJ_SUFFIX): %.c Makefile Makefile.in
+	$(REPORT_BUILD)
+	$(ELOG) $(HOST_CC) $(HOST_OUTOPTION)$@ -c $(HOST_CFLAGS) $(INCLUDES) $(NSPR_CFLAGS) $(_VPATH_SRCS)
+
+host_%.$(OBJ_SUFFIX): %.cpp Makefile Makefile.in
+	$(REPORT_BUILD)
+	$(ELOG) $(HOST_CXX) $(HOST_OUTOPTION)$@ -c $(HOST_CXXFLAGS) $(INCLUDES) $(NSPR_CFLAGS) $(_VPATH_SRCS)
+
+host_%.$(OBJ_SUFFIX): %.cc Makefile Makefile.in
+	$(REPORT_BUILD)
+	$(ELOG) $(HOST_CXX) $(HOST_OUTOPTION)$@ -c $(HOST_CXXFLAGS) $(INCLUDES) $(NSPR_CFLAGS) $(_VPATH_SRCS)
+
+host_%.$(OBJ_SUFFIX): %.m Makefile Makefile.in
+	$(REPORT_BUILD)
+	$(ELOG) $(HOST_CC) $(HOST_OUTOPTION)$@ -c $(HOST_CFLAGS) $(HOST_CMFLAGS) $(INCLUDES) $(NSPR_CFLAGS) $(_VPATH_SRCS)
+
+host_%.$(OBJ_SUFFIX): %.mm Makefile Makefile.in
+	$(REPORT_BUILD)
+	$(ELOG) $(HOST_CXX) $(HOST_OUTOPTION)$@ -c $(HOST_CXXFLAGS) $(HOST_CMMFLAGS) $(INCLUDES) $(NSPR_CFLAGS) $(_VPATH_SRCS)
+
+%: %.c Makefile Makefile.in
+	$(REPORT_BUILD)
+	@$(MAKE_DEPS_AUTO_CC)
+	$(ELOG) $(CC) $(CFLAGS) $(LDFLAGS) $(OUTOPTION)$@ $(_VPATH_SRCS)
+
+%.$(OBJ_SUFFIX): %.c Makefile Makefile.in
+	$(REPORT_BUILD)
+	@$(MAKE_DEPS_AUTO_CC)
+	$(ELOG) $(CC) $(OUTOPTION)$@ -c $(COMPILE_CFLAGS) $(_VPATH_SRCS)
+
+moc_%.cpp: %.h Makefile Makefile.in
+	$(MOC) $< $(OUTOPTION)$@ 
+
+ifdef ASFILES
+# The AS_DASH_C_FLAG is needed cause not all assemblers (Solaris) accept
+# a '-c' flag.
+%.$(OBJ_SUFFIX): %.$(ASM_SUFFIX) Makefile Makefile.in
+	$(AS) -o $@ $(ASFLAGS) $(AS_DASH_C_FLAG) $(_VPATH_SRCS)
+endif
+
+%.$(OBJ_SUFFIX): %.S Makefile Makefile.in
+	$(AS) -o $@ $(ASFLAGS) -c $<
+
+%: %.cpp Makefile Makefile.in
+	@$(MAKE_DEPS_AUTO_CXX)
+	$(CCC) $(OUTOPTION)$@ $(CXXFLAGS) $(_VPATH_SRCS) $(LDFLAGS)
+
+#
+# Please keep the next two rules in sync.
+#
+%.$(OBJ_SUFFIX): %.cc Makefile Makefile.in
+	$(REPORT_BUILD)
+	@$(MAKE_DEPS_AUTO_CXX)
+	$(ELOG) $(CCC) $(OUTOPTION)$@ -c $(COMPILE_CXXFLAGS) $(_VPATH_SRCS)
+
+%.$(OBJ_SUFFIX): %.cpp Makefile Makefile.in
+	$(REPORT_BUILD)
+	@$(MAKE_DEPS_AUTO_CXX)
+ifdef STRICT_CPLUSPLUS_SUFFIX
+	echo "#line 1 \"$*.cpp\"" | cat - $*.cpp > t_$*.cc
+	$(ELOG) $(CCC) -o $@ -c $(COMPILE_CXXFLAGS) t_$*.cc
+	rm -f t_$*.cc
+else
+	$(ELOG) $(CCC) $(OUTOPTION)$@ -c $(COMPILE_CXXFLAGS) $(_VPATH_SRCS)
+endif #STRICT_CPLUSPLUS_SUFFIX
+
+$(OBJ_PREFIX)%.$(OBJ_SUFFIX): %.mm Makefile Makefile.in
+	$(REPORT_BUILD)
+	@$(MAKE_DEPS_AUTO_CXX)
+	$(ELOG) $(CCC) -o $@ -c $(COMPILE_CXXFLAGS) $(COMPILE_CMMFLAGS) $(_VPATH_SRCS)
+
+$(OBJ_PREFIX)%.$(OBJ_SUFFIX): %.m Makefile Makefile.in
+	$(REPORT_BUILD)
+	@$(MAKE_DEPS_AUTO_CC)
+	$(ELOG) $(CC) -o $@ -c $(COMPILE_CFLAGS) $(COMPILE_CMFLAGS) $(_VPATH_SRCS)
+
+%.s: %.cpp
+	$(CCC) -S $(COMPILE_CXXFLAGS) $(_VPATH_SRCS)
+
+%.s: %.cc
+	$(CCC) -S $(COMPILE_CXXFLAGS) $(_VPATH_SRCS)
+
+%.s: %.c
+	$(CC) -S $(COMPILE_CFLAGS) $(_VPATH_SRCS)
+
+%.i: %.cpp
+	$(CCC) -C -E $(COMPILE_CXXFLAGS) $(_VPATH_SRCS) > $*.i
+
+%.i: %.cc
+	$(CCC) -C -E $(COMPILE_CXXFLAGS) $(_VPATH_SRCS) > $*.i
+
+%.i: %.c
+	$(CC) -C -E $(COMPILE_CFLAGS) $(_VPATH_SRCS) > $*.i
+
+%.i: %.mm
+	$(CCC) -C -E $(COMPILE_CXXFLAGS) $(COMPILE_CMMFLAGS) $(_VPATH_SRCS) > $*.i
+
+%.res: %.rc
+	@echo Creating Resource file: $@
+ifeq ($(OS_ARCH),OS2)
+	$(RC) $(RCFLAGS:-D%=-d %) -i $(subst /,\,$(srcdir)) -r $< $@
+else
+ifdef GNU_CC
+	$(RC) $(RCFLAGS) $(filter-out -U%,$(DEFINES)) $(INCLUDES:-I%=--include-dir %) $(OUTOPTION)$@ $(_VPATH_SRCS)
+else
+	$(RC) $(RCFLAGS) -r $(DEFINES) $(INCLUDES) $(OUTOPTION)$@ $(_VPATH_SRCS)
+endif
+endif
+
+# need 3 separate lines for OS/2
+%: %.pl
+	rm -f $@
+	cp $< $@
+	chmod +x $@
+
+%: %.sh
+	rm -f $@; cp $< $@; chmod +x $@
+
+# Cancel these implicit rules
+#
+%: %,v
+
+%: RCS/%,v
+
+%: s.%
+
+%: SCCS/s.%
+
+###############################################################################
+# Java rules
+###############################################################################
+ifneq (,$(filter OS2 WINNT WINCE,$(OS_ARCH)))
+SEP := ;
+else
+SEP := :
+endif
+
+EMPTY :=
+SPACE := $(EMPTY) $(EMPTY)
+
+# Cygwin and MSYS have their own special path form, but javac expects the source
+# and class paths to be in the DOS form (i.e. e:/builds/...).  This function
+# does the appropriate conversion on Windows, but is a noop on other systems.
+ifeq (,$(filter-out WINNT WINCE, $(HOST_OS_ARCH)))
+ifdef CYGWIN_WRAPPER
+normalizepath = $(foreach p,$(1),$(shell cygpath -m $(p)))
+else
+# assume MSYS
+#  We use 'pwd -W' to get DOS form of the path.  However, since the given path
+#  could be a file or a non-existent path, we cannot call 'pwd -W' directly
+#  on the path.  Instead, we extract the root path (i.e. "c:/"), call 'pwd -W'
+#  on it, then merge with the rest of the path.
+root-path = $(shell echo $(1) | sed -e "s|\(/[^/]*\)/\?\(.*\)|\1|")
+non-root-path = $(shell echo $(1) | sed -e "s|\(/[^/]*\)/\?\(.*\)|\2|")
+normalizepath = $(foreach p,$(1),$(if $(filter /%,$(1)),$(shell cd $(call root-path,$(1)) && pwd -W)$(call non-root-path,$(1)),$(1)))
+endif
+else
+normalizepath = $(1)
+endif
+
+_srcdir = $(call normalizepath,$(srcdir))
+ifdef JAVA_SOURCEPATH
+SP = $(subst $(SPACE),$(SEP),$(call normalizepath,$(strip $(JAVA_SOURCEPATH))))
+_JAVA_SOURCEPATH = ".$(SEP)$(_srcdir)$(SEP)$(SP)"
+else
+_JAVA_SOURCEPATH = ".$(SEP)$(_srcdir)"
+endif
+
+ifdef JAVA_CLASSPATH
+CP = $(subst $(SPACE),$(SEP),$(call normalizepath,$(strip $(JAVA_CLASSPATH))))
+_JAVA_CLASSPATH = ".$(SEP)$(CP)"
+else
+_JAVA_CLASSPATH = .
+endif
+
+_JAVA_DIR = _java
+$(_JAVA_DIR)::
+	$(NSINSTALL) -D $@
+
+$(_JAVA_DIR)/%.class: %.java Makefile Makefile.in $(_JAVA_DIR)
+	$(CYGWIN_WRAPPER) $(JAVAC) $(JAVAC_FLAGS) -classpath $(_JAVA_CLASSPATH) \
+			-sourcepath $(_JAVA_SOURCEPATH) -d $(_JAVA_DIR) $(_VPATH_SRCS)
+
+$(JAVA_LIBRARY): $(addprefix $(_JAVA_DIR)/,$(JAVA_SRCS:.java=.class)) Makefile Makefile.in
+	$(JAR) cf $@ -C $(_JAVA_DIR) .
+
+GARBAGE_DIRS += $(_JAVA_DIR)
+
+###############################################################################
+# Update Makefiles
+###############################################################################
+
+# In GNU make 3.80, makefiles must use the /cygdrive syntax, even if we're
+# processing them with AS perl. See bug 232003
+ifdef AS_PERL
+CYGWIN_TOPSRCDIR = -nowrap -p $(topsrcdir) -wrap
+endif
+
+# Note: Passing depth to make-makefile is optional.
+#       It saves the script some work, though.
+Makefile: Makefile.in
+	@$(PERL) $(AUTOCONF_TOOLS)/make-makefile -t $(topsrcdir) -d $(DEPTH) $(CYGWIN_TOPSRCDIR)
+
+ifdef SUBMAKEFILES
+# VPATH does not work on some machines in this case, so add $(srcdir)
+$(SUBMAKEFILES): % : $(srcdir)/%.in
+	$(PERL) $(AUTOCONF_TOOLS)/make-makefile -t $(topsrcdir) -d $(DEPTH) $(CYGWIN_TOPSRCDIR) $@
+endif
+
+ifdef AUTOUPDATE_CONFIGURE
+$(topsrcdir)/configure: $(topsrcdir)/configure.in
+	(cd $(topsrcdir) && $(AUTOCONF)) && (cd $(DEPTH) && ./config.status --recheck)
+endif
+
+###############################################################################
+# Bunch of things that extend the 'export' rule (in order):
+###############################################################################
+
+################################################################################
+# Copy each element of EXPORTS to $(PUBLIC)
+
+ifneq ($(EXPORTS)$(XPIDLSRCS)$(SDK_HEADERS)$(SDK_XPIDLSRCS),)
+$(SDK_PUBLIC) $(PUBLIC)::
+	@if test ! -d $@; then $(ECHO) Creating $@; rm -rf $@; $(NSINSTALL) -D $@; else true; fi
+endif
+
+ifdef MOZ_JAVAXPCOM
+ifneq ($(XPIDLSRCS)$(SDK_XPIDLSRCS),)
+$(JAVA_DIST_DIR)::
+	$(NSINSTALL) -D $@
+endif
+endif
+
+ifneq ($(XPI_NAME),)
+export::
+	@if test ! -d $(FINAL_TARGET); then echo Creating $(FINAL_TARGET); rm -fr $(FINAL_TARGET); $(NSINSTALL) -D $(FINAL_TARGET); else true; fi
+endif
+
+ifndef NO_DIST_INSTALL
+ifneq ($(EXPORTS),)
+export:: $(EXPORTS) $(PUBLIC)
+	$(INSTALL) $(IFLAGS1) $^
+endif 
+
+ifneq ($(SDK_HEADERS),)
+export:: $(SDK_HEADERS) $(SDK_PUBLIC)
+	$(INSTALL) $(IFLAGS1) $^
+
+export:: $(SDK_HEADERS) $(PUBLIC)
+	$(INSTALL) $(IFLAGS1) $^
+endif 
+endif # NO_DIST_INSTALL
+
+################################################################################
+# Copy each element of PREF_JS_EXPORTS
+
+ifdef GRE_MODULE
+PREF_DIR = greprefs
+else
+ifneq (,$(XPI_NAME)$(LIBXUL_SDK))
+PREF_DIR = defaults/preferences
+else
+PREF_DIR = defaults/pref
+endif
+endif
+
+ifneq ($(PREF_JS_EXPORTS),)
+# on win32, pref files need CRLF line endings... see bug 206029
+ifeq (WINNT,$(OS_ARCH))
+PREF_PPFLAGS = --line-endings=crlf
+endif
+
+ifndef NO_DIST_INSTALL
+libs:: $(PREF_JS_EXPORTS)
+	if test ! -d $(FINAL_TARGET)/$(PREF_DIR); then $(NSINSTALL) -D $(FINAL_TARGET)/$(PREF_DIR); fi
+	$(EXIT_ON_ERROR)  \
+	for i in $(PREF_JS_EXPORTS); do \
+	  dest=$(FINAL_TARGET)/$(PREF_DIR)/`basename $$i`; \
+	  $(RM) -f $$dest; \
+	  $(PYTHON) $(topsrcdir)/config/Preprocessor.py $(PREF_PPFLAGS) $(DEFINES) $(ACDEFINES) $(XULPPFLAGS) $$i > $$dest; \
+	done
+endif
+endif
+
+################################################################################
+# Copy each element of AUTOCFG_JS_EXPORTS to $(FINAL_TARGET)/defaults/autoconfig
+
+ifneq ($(AUTOCFG_JS_EXPORTS),)
+$(FINAL_TARGET)/defaults/autoconfig::
+	@if test ! -d $@; then echo Creating $@; rm -rf $@; $(NSINSTALL) -D $@; else true; fi
+
+ifndef NO_DIST_INSTALL
+export:: $(AUTOCFG_JS_EXPORTS) $(FINAL_TARGET)/defaults/autoconfig
+	$(INSTALL) $(IFLAGS1) $^
+endif
+
+endif 
+################################################################################
+# Export the elements of $(XPIDLSRCS) & $(SDK_XPIDLSRCS), 
+# generating .h and .xpt files and moving them to the appropriate places.
+
+ifneq ($(XPIDLSRCS)$(SDK_XPIDLSRCS),)
+
+export:: $(patsubst %.idl,$(XPIDL_GEN_DIR)/%.h, $(XPIDLSRCS))
+
+ifndef XPIDL_MODULE
+XPIDL_MODULE		= $(MODULE)
+endif
+
+ifeq ($(XPIDL_MODULE),) # we need $(XPIDL_MODULE) to make $(XPIDL_MODULE).xpt
+export:: FORCE
+	@echo
+	@echo "*** Error processing XPIDLSRCS:"
+	@echo "Please define MODULE or XPIDL_MODULE when defining XPIDLSRCS,"
+	@echo "so we have a module name to use when creating MODULE.xpt."
+	@echo; sleep 2; false
+endif
+
+$(SDK_IDL_DIR) $(IDL_DIR)::
+	@if test ! -d $@; then echo Creating $@; rm -rf $@; $(NSINSTALL) -D $@; else true; fi
+
+# generate .h files from into $(XPIDL_GEN_DIR), then export to $(PUBLIC);
+# warn against overriding existing .h file. 
+$(XPIDL_GEN_DIR)/.done:
+	@if test ! -d $(XPIDL_GEN_DIR); then echo Creating $(XPIDL_GEN_DIR)/.done; rm -rf $(XPIDL_GEN_DIR); mkdir $(XPIDL_GEN_DIR); fi
+	@touch $@
+
+# don't depend on $(XPIDL_GEN_DIR), because the modification date changes
+# with any addition to the directory, regenerating all .h files -> everything.
+
+$(XPIDL_GEN_DIR)/%.h: %.idl $(XPIDL_COMPILE) $(XPIDL_GEN_DIR)/.done
+	$(REPORT_BUILD)
+	$(ELOG) $(XPIDL_COMPILE) -m header -w $(XPIDL_FLAGS) -o $(XPIDL_GEN_DIR)/$* $(_VPATH_SRCS)
+	@if test -n "$(findstring $*.h, $(EXPORTS) $(SDK_HEADERS))"; \
+	  then echo "*** WARNING: file $*.h generated from $*.idl overrides $(srcdir)/$*.h"; else true; fi
+
+ifndef NO_GEN_XPT
+# generate intermediate .xpt files into $(XPIDL_GEN_DIR), then link
+# into $(XPIDL_MODULE).xpt and export it to $(FINAL_TARGET)/components.
+$(XPIDL_GEN_DIR)/%.xpt: %.idl $(XPIDL_COMPILE) $(XPIDL_GEN_DIR)/.done
+	$(REPORT_BUILD)
+	$(ELOG) $(XPIDL_COMPILE) -m typelib -w $(XPIDL_FLAGS) -e $@ -d $(MDDEPDIR)/$*.pp $(_VPATH_SRCS)
+
+# no need to link together if XPIDLSRCS contains only XPIDL_MODULE
+ifneq ($(XPIDL_MODULE).idl,$(strip $(XPIDLSRCS)))
+$(XPIDL_GEN_DIR)/$(XPIDL_MODULE).xpt: $(patsubst %.idl,$(XPIDL_GEN_DIR)/%.xpt,$(XPIDLSRCS) $(SDK_XPIDLSRCS)) Makefile.in Makefile $(XPIDL_LINK)
+	$(XPIDL_LINK) $(XPIDL_GEN_DIR)/$(XPIDL_MODULE).xpt $(patsubst %.idl,$(XPIDL_GEN_DIR)/%.xpt,$(XPIDLSRCS) $(SDK_XPIDLSRCS)) 
+endif # XPIDL_MODULE.xpt != XPIDLSRCS
+
+libs:: $(XPIDL_GEN_DIR)/$(XPIDL_MODULE).xpt
+ifndef NO_DIST_INSTALL
+	$(INSTALL) $(IFLAGS1) $(XPIDL_GEN_DIR)/$(XPIDL_MODULE).xpt $(FINAL_TARGET)/components
+endif
+
+endif # NO_GEN_XPT
+
+GARBAGE_DIRS		+= $(XPIDL_GEN_DIR)
+
+endif # XPIDLSRCS || SDK_XPIDLSRCS
+
+ifneq ($(XPIDLSRCS),)
+# export .idl files to $(IDL_DIR)
+ifndef NO_DIST_INSTALL
+export:: $(XPIDLSRCS) $(IDL_DIR)
+	$(INSTALL) $(IFLAGS1) $^
+
+export:: $(patsubst %.idl,$(XPIDL_GEN_DIR)/%.h, $(XPIDLSRCS)) $(PUBLIC)
+	$(INSTALL) $(IFLAGS1) $^ 
+endif # NO_DIST_INSTALL
+
+endif # XPIDLSRCS
+
+
+
+#
+# General rules for exporting idl files.
+#
+# WORK-AROUND ONLY, for mozilla/tools/module-deps/bootstrap.pl build.
+# Bug to fix idl dependency problems w/o this extra build pass is
+#   http://bugzilla.mozilla.org/show_bug.cgi?id=145777
+#
+$(IDL_DIR)::
+	@if test ! -d $@; then echo Creating $@; rm -rf $@; $(NSINSTALL) -D $@; else true; fi
+
+export-idl:: $(SUBMAKEFILES) $(MAKE_DIRS)
+
+ifneq ($(XPIDLSRCS)$(SDK_XPIDLSRCS),)
+ifndef NO_DIST_INSTALL
+export-idl:: $(XPIDLSRCS) $(SDK_XPIDLSRCS) $(IDL_DIR)
+	$(INSTALL) $(IFLAGS1) $^
+endif
+endif
+	+$(LOOP_OVER_PARALLEL_DIRS)
+	+$(LOOP_OVER_DIRS)
+	+$(LOOP_OVER_TOOL_DIRS)
+
+
+
+
+ifneq ($(SDK_XPIDLSRCS),)
+# export .idl files to $(IDL_DIR) & $(SDK_IDL_DIR)
+ifndef NO_DIST_INSTALL
+export:: $(SDK_XPIDLSRCS) $(IDL_DIR)
+	$(INSTALL) $(IFLAGS1) $^
+
+export:: $(SDK_XPIDLSRCS) $(SDK_IDL_DIR)
+	$(INSTALL) $(IFLAGS1) $^
+
+export:: $(patsubst %.idl,$(XPIDL_GEN_DIR)/%.h, $(SDK_XPIDLSRCS)) $(PUBLIC)
+	$(INSTALL) $(IFLAGS1) $^
+
+export:: $(patsubst %.idl,$(XPIDL_GEN_DIR)/%.h, $(SDK_XPIDLSRCS)) $(SDK_PUBLIC)
+	$(INSTALL) $(IFLAGS1) $^
+endif
+
+endif # SDK_XPIDLSRCS
+
+
+
+ifdef MOZ_JAVAXPCOM
+ifneq ($(XPIDLSRCS)$(SDK_XPIDLSRCS),)
+
+JAVA_XPIDLSRCS = $(XPIDLSRCS) $(SDK_XPIDLSRCS)
+
+# A single IDL file can contain multiple interfaces, which result in multiple
+# Java interface files.  So use hidden dependency files.
+JAVADEPFILES = $(addprefix $(JAVA_GEN_DIR)/.,$(JAVA_XPIDLSRCS:.idl=.java.pp))
+
+$(JAVA_GEN_DIR):
+	$(NSINSTALL) -D $@
+GARBAGE_DIRS += $(JAVA_GEN_DIR)
+
+# generate .java files into _javagen/[package name dirs]
+_JAVA_GEN_DIR = $(JAVA_GEN_DIR)/$(JAVA_IFACES_PKG_NAME)
+$(_JAVA_GEN_DIR):
+	$(NSINSTALL) -D $@
+
+$(JAVA_GEN_DIR)/.%.java.pp: %.idl $(XPIDL_COMPILE) $(_JAVA_GEN_DIR)
+	$(REPORT_BUILD)
+	$(ELOG) $(XPIDL_COMPILE) -m java -w -I$(srcdir) -I$(IDL_DIR) -o $(_JAVA_GEN_DIR)/$* $(_VPATH_SRCS)
+	@touch $@
+
+# "Install" generated Java interfaces.  We segregate them based on the XPI_NAME.
+# If XPI_NAME is not set, install into the "default" directory.
+ifneq ($(XPI_NAME),)
+JAVA_INSTALL_DIR = $(JAVA_DIST_DIR)/$(XPI_NAME)
+else
+JAVA_INSTALL_DIR = $(JAVA_DIST_DIR)/default
+endif
+
+$(JAVA_INSTALL_DIR):
+	$(NSINSTALL) -D $@
+
+export:: $(JAVA_DIST_DIR) $(JAVADEPFILES) $(JAVA_INSTALL_DIR)
+	(cd $(JAVA_GEN_DIR) && tar $(TAR_CREATE_FLAGS) - .) | (cd $(JAVA_INSTALL_DIR) && tar -xf -)
+
+endif # XPIDLSRCS || SDK_XPIDLSRCS
+endif # MOZ_JAVAXPCOM
+
+################################################################################
+# Copy each element of EXTRA_COMPONENTS to $(FINAL_TARGET)/components
+ifdef EXTRA_COMPONENTS
+libs:: $(EXTRA_COMPONENTS)
+ifndef NO_DIST_INSTALL
+	$(INSTALL) $(IFLAGS1) $^ $(FINAL_TARGET)/components
+endif
+
+endif
+
+ifdef EXTRA_PP_COMPONENTS
+libs:: $(EXTRA_PP_COMPONENTS)
+ifndef NO_DIST_INSTALL
+	$(EXIT_ON_ERROR) \
+	$(NSINSTALL) -D $(FINAL_TARGET)/components; \
+	for i in $^; do \
+	  dest=$(FINAL_TARGET)/components/`basename $$i`; \
+	  $(RM) -f $$dest; \
+	  $(PYTHON) $(topsrcdir)/config/Preprocessor.py $(DEFINES) $(ACDEFINES) $(XULPPFLAGS) $$i > $$dest; \
+	done
+endif
+
+endif
+
+################################################################################
+# Copy each element of EXTRA_JS_MODULES to $(FINAL_TARGET)/modules
+ifdef EXTRA_JS_MODULES
+libs:: $(EXTRA_JS_MODULES)
+ifndef NO_DIST_INSTALL
+	$(INSTALL) $(IFLAGS1) $^ $(FINAL_TARGET)/modules
+endif
+
+endif
+
+ifdef EXTRA_PP_JS_MODULES
+libs:: $(EXTRA_PP_JS_MODULES)
+ifndef NO_DIST_INSTALL
+	$(EXIT_ON_ERROR) \
+	$(NSINSTALL) -D $(FINAL_TARGET)/modules; \
+	for i in $^; do \
+	  dest=$(FINAL_TARGET)/modules/`basename $$i`; \
+	  $(RM) -f $$dest; \
+	  $(PYTHON) $(topsrcdir)/config/Preprocessor.py $(DEFINES) $(ACDEFINES) $(XULPPFLAGS) $$i > $$dest; \
+	done
+endif
+
+endif
+
+################################################################################
+# SDK
+
+ifneq (,$(SDK_LIBRARY))
+$(SDK_LIB_DIR)::
+	@if test ! -d $@; then echo Creating $@; rm -rf $@; $(NSINSTALL) -D $@; else true; fi
+
+ifndef NO_DIST_INSTALL
+libs:: $(SDK_LIBRARY) $(SDK_LIB_DIR)
+	$(INSTALL) $(IFLAGS2) $^
+endif
+
+endif # SDK_LIBRARY
+
+ifneq (,$(SDK_BINARY))
+$(SDK_BIN_DIR)::
+	@if test ! -d $@; then echo Creating $@; rm -rf $@; $(NSINSTALL) -D $@; else true; fi
+
+ifndef NO_DIST_INSTALL
+libs:: $(SDK_BINARY) $(SDK_BIN_DIR)
+	$(INSTALL) $(IFLAGS2) $^
+endif
+
+endif # SDK_BINARY
+
+################################################################################
+# CHROME PACKAGING
+
+JAR_MANIFEST := $(srcdir)/jar.mn
+
+chrome::
+	$(MAKE) realchrome
+	+$(LOOP_OVER_PARALLEL_DIRS)
+	+$(LOOP_OVER_DIRS)
+	+$(LOOP_OVER_TOOL_DIRS)
+
+libs realchrome:: $(CHROME_DEPS)
+ifndef NO_DIST_INSTALL
+	@$(EXIT_ON_ERROR) \
+	if test -f $(JAR_MANIFEST); then \
+	  if test ! -d $(FINAL_TARGET)/chrome; then $(NSINSTALL) -D $(FINAL_TARGET)/chrome; fi; \
+	  $(PYTHON) $(MOZILLA_DIR)/config/JarMaker.py \
+	    $(QUIET) -j $(FINAL_TARGET)/chrome \
+	    $(MAKE_JARS_FLAGS) $(XULPPFLAGS) $(DEFINES) $(ACDEFINES) \
+	    $(JAR_MANIFEST); \
+	fi
+endif
+
+ifneq ($(DIST_FILES),)
+libs:: $(DIST_FILES)
+	@$(EXIT_ON_ERROR) \
+	for f in $(DIST_FILES); do \
+	  dest=$(FINAL_TARGET)/`basename $$f`; \
+	  $(RM) -f $$dest; \
+	  $(PYTHON) $(MOZILLA_DIR)/config/Preprocessor.py \
+	    $(XULAPP_DEFINES) $(DEFINES) $(ACDEFINES) $(XULPPFLAGS) \
+	    $(srcdir)/$$f > $$dest; \
+	done
+endif
+
+ifneq ($(DIST_CHROME_FILES),)
+libs:: $(DIST_CHROME_FILES)
+	@$(EXIT_ON_ERROR) \
+	for f in $(DIST_CHROME_FILES); do \
+	  dest=$(FINAL_TARGET)/chrome/`basename $$f`; \
+	  $(RM) -f $$dest; \
+	  $(PYTHON) $(MOZILLA_DIR)/config/Preprocessor.py \
+	    $(XULAPP_DEFINES) $(DEFINES) $(ACDEFINES) $(XULPPFLAGS) \
+	    $(srcdir)/$$f > $$dest; \
+	done
+endif
+
+ifneq ($(XPI_PKGNAME),)
+libs realchrome::
+ifdef STRIP_XPI
+ifndef MOZ_DEBUG
+	@echo "Stripping $(XPI_PKGNAME) package directory..."
+	@echo $(FINAL_TARGET)
+	@cd $(FINAL_TARGET) && find . ! -type d \
+			! -name "*.js" \
+			! -name "*.xpt" \
+			! -name "*.gif" \
+			! -name "*.jpg" \
+			! -name "*.png" \
+			! -name "*.xpm" \
+			! -name "*.txt" \
+			! -name "*.rdf" \
+			! -name "*.sh" \
+			! -name "*.properties" \
+			! -name "*.dtd" \
+			! -name "*.html" \
+			! -name "*.xul" \
+			! -name "*.css" \
+			! -name "*.xml" \
+			! -name "*.jar" \
+			! -name "*.dat" \
+			! -name "*.tbl" \
+			! -name "*.src" \
+			! -name "*.reg" \
+			$(PLATFORM_EXCLUDE_LIST) \
+			-exec $(STRIP) $(STRIP_FLAGS) {} >/dev/null 2>&1 \;
+endif
+endif
+	@echo "Packaging $(XPI_PKGNAME).xpi..."
+	cd $(FINAL_TARGET) && $(ZIP) -qr ../$(XPI_PKGNAME).xpi *
+endif
+
+ifdef INSTALL_EXTENSION_ID
+ifndef XPI_NAME
+$(error XPI_NAME must be set for INSTALL_EXTENSION_ID)
+endif
+
+libs::
+	$(RM) -rf "$(DIST)/bin/extensions/$(INSTALL_EXTENSION_ID)"
+	$(NSINSTALL) -D "$(DIST)/bin/extensions/$(INSTALL_EXTENSION_ID)"
+	cd $(FINAL_TARGET) && tar $(TAR_CREATE_FLAGS) - . | (cd "../../bin/extensions/$(INSTALL_EXTENSION_ID)" && tar -xf -)
+
+endif
+
+ifneq (,$(filter flat symlink,$(MOZ_CHROME_FILE_FORMAT)))
+_JAR_REGCHROME_DISABLE_JAR=1
+else
+_JAR_REGCHROME_DISABLE_JAR=0
+endif
+
+REGCHROME = $(PERL) -I$(MOZILLA_DIR)/config $(MOZILLA_DIR)/config/add-chrome.pl \
+	$(if $(filter gtk2,$(MOZ_WIDGET_TOOLKIT)),-x) \
+	$(if $(CROSS_COMPILE),-o $(OS_ARCH)) $(FINAL_TARGET)/chrome/installed-chrome.txt \
+	$(_JAR_REGCHROME_DISABLE_JAR)
+
+REGCHROME_INSTALL = $(PERL) -I$(MOZILLA_DIR)/config $(MOZILLA_DIR)/config/add-chrome.pl \
+	$(if $(filter gtk2,$(MOZ_WIDGET_TOOLKIT)),-x) \
+	$(if $(CROSS_COMPILE),-o $(OS_ARCH)) $(DESTDIR)$(mozappdir)/chrome/installed-chrome.txt \
+	$(_JAR_REGCHROME_DISABLE_JAR)
+
+
+################################################################################
+# Testing frameworks support
+################################################################################
+
+ifdef ENABLE_TESTS
+
+ifdef XPCSHELL_TESTS
+ifndef MODULE
+$(error Must define MODULE when defining XPCSHELL_TESTS.)
+endif
+
+# Test file installation
+libs::
+	@$(EXIT_ON_ERROR) \
+	for testdir in $(XPCSHELL_TESTS); do \
+	  $(INSTALL) \
+	    $(srcdir)/$$testdir/*.js \
+	    $(DEPTH)/_tests/xpcshell-simple/$(MODULE)/$$testdir; \
+	done
+
+# Path formats on Windows are hard.  We require a topsrcdir formatted so that
+# it may be passed to nsILocalFile.initWithPath (in other words, an absolute
+# path of the form X:\path\to\topsrcdir), which we store in NATIVE_TOPSRCDIR.
+# We require a forward-slashed path to topsrcdir so that it may be combined
+# with a relative forward-slashed path for loading scripts, both dynamically
+# and statically for head/test/tail JS files.  Of course, on non-Windows none
+# of this matters, and things will work correctly because everything's
+# forward-slashed, everywhere, always.
+ifdef CYGWIN_WRAPPER
+NATIVE_TOPSRCDIR   := `cygpath -wa $(topsrcdir)`
+FWDSLASH_TOPSRCDIR := `cygpath -ma $(topsrcdir)`
+else
+FWDSLASH_TOPSRCDIR := $(topsrcdir)
+ifeq ($(HOST_OS_ARCH),WINNT)
+NATIVE_TOPSRCDIR   := $(subst /,\\,$(WIN_TOP_SRC))
+else 
+NATIVE_TOPSRCDIR   := $(topsrcdir)
+endif
+endif # CYGWIN_WRAPPER
+
+# Test execution
+check::
+	@$(EXIT_ON_ERROR) \
+	for testdir in $(XPCSHELL_TESTS); do \
+	  $(RUN_TEST_PROGRAM) \
+	    $(topsrcdir)/tools/test-harness/xpcshell-simple/test_all.sh \
+	      $(DIST)/bin/xpcshell \
+	      $(FWDSLASH_TOPSRCDIR) \
+	      $(NATIVE_TOPSRCDIR) \
+	      $(DEPTH)/_tests/xpcshell-simple/$(MODULE)/$$testdir; \
+	done
+
+# Test execution
+check-interactive::
+	@$(EXIT_ON_ERROR) \
+	$(RUN_TEST_PROGRAM) \
+	  $(topsrcdir)/tools/test-harness/xpcshell-simple/test_one.sh \
+	    $(DIST)/bin/xpcshell \
+	    $(FWDSLASH_TOPSRCDIR) \
+	    $(NATIVE_TOPSRCDIR) \
+	    $(DEPTH)/_tests/xpcshell-simple/$(MODULE)/$$testdir \
+	    $(SOLO_FILE) 1;
+
+# Test execution
+check-one::
+	@$(EXIT_ON_ERROR) \
+	$(RUN_TEST_PROGRAM) \
+	  $(topsrcdir)/tools/test-harness/xpcshell-simple/test_one.sh \
+	    $(DIST)/bin/xpcshell \
+	    $(FWDSLASH_TOPSRCDIR) \
+	    $(NATIVE_TOPSRCDIR) \
+	    $(DEPTH)/_tests/xpcshell-simple/$(MODULE)/$$testdir \
+	    $(SOLO_FILE) 0;
+
+endif # XPCSHELL_TESTS
+
+endif # ENABLE_TESTS
+
+
+#############################################################################
+# Dependency system
+#############################################################################
+ifdef COMPILER_DEPEND
+depend::
+	@echo "$(MAKE): No need to run depend target.\
+			Using compiler-based depend." 1>&2
+ifeq ($(GNU_CC)$(GNU_CXX),)
+# Non-GNU compilers
+	@echo "`echo '$(MAKE):'|sed 's/./ /g'`"\
+	'(Compiler-based depend was turned on by "--enable-md".)' 1>&2
+else
+# GNU compilers
+	@space="`echo '$(MAKE): '|sed 's/./ /g'`";\
+	echo "$$space"'Since you are using a GNU compiler,\
+		it is on by default.' 1>&2; \
+	echo "$$space"'To turn it off, pass --disable-md to configure.' 1>&2
+endif
+
+else # ! COMPILER_DEPEND
+
+ifndef MOZ_AUTO_DEPS
+
+define MAKE_DEPS_NOAUTO
+	$(MKDEPEND) -w1024 -o'.$(OBJ_SUFFIX)' -f- $(DEFINES) $(ACDEFINES) $(INCLUDES) $< 2>/dev/null | sed -e "s|^[^ ]*/||" > $@
+endef
+
+$(MDDEPDIR)/%.pp: %.c
+	$(REPORT_BUILD)
+	@$(MAKE_DEPS_NOAUTO)
+
+$(MDDEPDIR)/%.pp: %.cpp
+	$(REPORT_BUILD)
+	@$(MAKE_DEPS_NOAUTO)
+
+$(MDDEPDIR)/%.pp: %.s
+	$(REPORT_BUILD)
+	@$(MAKE_DEPS_NOAUTO)
+
+ifneq (,$(OBJS)$(XPIDLSRCS)$(SDK_XPIDLSRCS)$(SIMPLE_PROGRAMS))
+depend:: $(SUBMAKEFILES) $(MAKE_DIRS) $(MDDEPFILES)
+else
+depend:: $(SUBMAKEFILES)
+endif
+	+$(LOOP_OVER_PARALLEL_DIRS)
+	+$(LOOP_OVER_DIRS)
+	+$(LOOP_OVER_TOOL_DIRS)
+
+dependclean:: $(SUBMAKEFILES)
+	rm -f $(MDDEPFILES)
+	+$(LOOP_OVER_PARALLEL_DIRS)
+	+$(LOOP_OVER_DIRS)
+	+$(LOOP_OVER_TOOL_DIRS)
+
+endif # MOZ_AUTO_DEPS
+
+endif # COMPILER_DEPEND
+
+
+#############################################################################
+# MDDEPDIR is the subdirectory where all the dependency files are placed.
+#   This uses a make rule (instead of a macro) to support parallel
+#   builds (-jN). If this were done in the LOOP_OVER_DIRS macro, two
+#   processes could simultaneously try to create the same directory.
+#
+$(MDDEPDIR):
+	@if test ! -d $@; then echo Creating $@; rm -rf $@; mkdir $@; else true; fi
+
+ifneq (,$(filter-out all chrome default export realchrome tools clean clobber clobber_all distclean realclean,$(MAKECMDGOALS)))
+ifneq (,$(OBJS)$(XPIDLSRCS)$(SDK_XPIDLSRCS)$(SIMPLE_PROGRAMS))
+MDDEPEND_FILES		:= $(strip $(wildcard $(MDDEPDIR)/*.pp))
+
+ifneq (,$(MDDEPEND_FILES))
+ifdef PERL
+# The script mddepend.pl checks the dependencies and writes to stdout
+# one rule to force out-of-date objects. For example,
+#   foo.o boo.o: FORCE
+# The script has an advantage over including the *.pp files directly
+# because it handles the case when header files are removed from the build.
+# 'make' would complain that there is no way to build missing headers.
+ifeq (,$(MAKE_RESTARTS))
+$(MDDEPDIR)/.all.pp: FORCE
+	@$(PERL) $(BUILD_TOOLS)/mddepend.pl $@ $(MDDEPEND_FILES)
+endif
+-include $(MDDEPDIR)/.all.pp
+else
+include $(MDDEPEND_FILES)
+endif
+endif
+
+endif
+endif
+#############################################################################
+
+-include $(topsrcdir)/$(MOZ_BUILD_APP)/app-rules.mk
+-include $(MY_RULES)
+
+#
+# This speeds up gmake's processing if these files don't exist.
+#
+$(MY_CONFIG) $(MY_RULES):
+	@touch $@
+
+#
+# Generate Emacs tags in a file named TAGS if ETAGS was set in $(MY_CONFIG)
+# or in $(MY_RULES)
+#
+ifdef ETAGS
+ifneq ($(CSRCS)$(CPPSRCS)$(HEADERS),)
+all:: TAGS
+TAGS:: $(CSRCS) $(CPPSRCS) $(HEADERS)
+	$(ETAGS) $(CSRCS) $(CPPSRCS) $(HEADERS)
+endif
+endif
+
+################################################################################
+# Special gmake rules.
+################################################################################
+
+
+#
+# Disallow parallel builds with MSVC < 8
+#
+ifneq (,$(filter 1200 1300 1310,$(_MSC_VER)))
+.NOTPARALLEL:
+endif
+
+#
+# Re-define the list of default suffixes, so gmake won't have to churn through
+# hundreds of built-in suffix rules for stuff we don't need.
+#
+.SUFFIXES:
+
+#
+# Fake targets.  Always run these rules, even if a file/directory with that
+# name already exists.
+#
+.PHONY: all all_platforms alltags boot checkout chrome realchrome clean clobber clobber_all export install libs makefiles realclean run_viewer run_apprunner tools $(DIRS) $(TOOL_DIRS) FORCE check check-interactive check-one
+
+# Used as a dependency to force targets to rebuild
+FORCE:
+
+# Delete target if error occurs when building target
+.DELETE_ON_ERROR:
+
+# Properly set LIBPATTERNS for the platform
+.LIBPATTERNS = $(if $(IMPORT_LIB_SUFFIX),$(LIB_PREFIX)%.$(IMPORT_LIB_SUFFIX)) $(LIB_PREFIX)%.$(LIB_SUFFIX) $(DLL_PREFIX)%$(DLL_SUFFIX) 
+
+tags: TAGS
+
+TAGS: $(SUBMAKEFILES) $(CSRCS) $(CPPSRCS) $(wildcard *.h)
+	-etags $(CSRCS) $(CPPSRCS) $(wildcard *.h)
+	+$(LOOP_OVER_PARALLEL_DIRS)
+	+$(LOOP_OVER_DIRS)
+
+echo-variable-%:
+	@echo $($*)
+
+echo-tiers:
+	@echo $(TIERS)
+
+echo-dirs:
+	@echo $(DIRS)
+
+echo-module:
+	@echo $(MODULE)
+
+echo-requires:
+	@echo $(REQUIRES)
+
+echo-requires-recursive::
+ifdef _REPORT_ALL_DIRS
+	@echo $(subst $(topsrcdir)/,,$(srcdir)): $(MODULE): $(REQUIRES)
+else
+	@$(if $(REQUIRES),echo $(subst $(topsrcdir)/,,$(srcdir)): $(MODULE): $(REQUIRES))
+endif
+	+$(LOOP_OVER_PARALLEL_DIRS)
+	+$(LOOP_OVER_DIRS)
+
+echo-depth-path:
+	@$(topsrcdir)/build/unix/print-depth-path.sh
+
+echo-module-name:
+	@$(topsrcdir)/build/package/rpm/print-module-name.sh
+
+echo-module-filelist:
+	@$(topsrcdir)/build/package/rpm/print-module-filelist.sh
+
+showtargs:
+ifneq (,$(filter $(PROGRAM) $(HOST_PROGRAM) $(SIMPLE_PROGRAMS) $(HOST_LIBRARY) $(LIBRARY) $(SHARED_LIBRARY),$(TARGETS)))
+	@echo --------------------------------------------------------------------------------
+	@echo "PROGRAM             = $(PROGRAM)"
+	@echo "SIMPLE_PROGRAMS     = $(SIMPLE_PROGRAMS)"
+	@echo "LIBRARY             = $(LIBRARY)"
+	@echo "SHARED_LIBRARY      = $(SHARED_LIBRARY)"
+	@echo "SHARED_LIBRARY_LIBS = $(SHARED_LIBRARY_LIBS)"
+	@echo "LIBS                = $(LIBS)"
+	@echo "DEF_FILE            = $(DEF_FILE)"
+	@echo "IMPORT_LIBRARY      = $(IMPORT_LIBRARY)"
+	@echo "STATIC_LIBS         = $(STATIC_LIBS)"
+	@echo "SHARED_LIBS         = $(SHARED_LIBS)"
+	@echo "EXTRA_DSO_LIBS      = $(EXTRA_DSO_LIBS)"
+	@echo "EXTRA_DSO_LDOPTS    = $(EXTRA_DSO_LDOPTS)"
+	@echo "DEPENDENT_LIBS      = $(DEPENDENT_LIBS)"
+	@echo --------------------------------------------------------------------------------
+endif
+	+$(LOOP_OVER_PARALLEL_DIRS)
+	+$(LOOP_OVER_DIRS)
+
+showbuild:
+	@echo "MOZ_BUILD_ROOT     = $(MOZ_BUILD_ROOT)"
+	@echo "MOZ_WIDGET_TOOLKIT = $(MOZ_WIDGET_TOOLKIT)"
+	@echo "CC                 = $(CC)"
+	@echo "CXX                = $(CXX)"
+	@echo "CCC                = $(CCC)"
+	@echo "CPP                = $(CPP)"
+	@echo "LD                 = $(LD)"
+	@echo "AR                 = $(AR)"
+	@echo "IMPLIB             = $(IMPLIB)"
+	@echo "FILTER             = $(FILTER)"
+	@echo "MKSHLIB            = $(MKSHLIB)"
+	@echo "MKCSHLIB           = $(MKCSHLIB)"
+	@echo "RC                 = $(RC)"
+	@echo "CFLAGS             = $(CFLAGS)"
+	@echo "OS_CFLAGS          = $(OS_CFLAGS)"
+	@echo "COMPILE_CFLAGS     = $(COMPILE_CFLAGS)"
+	@echo "CXXFLAGS           = $(CXXFLAGS)"
+	@echo "OS_CXXFLAGS        = $(OS_CXXFLAGS)"
+	@echo "COMPILE_CXXFLAGS   = $(COMPILE_CXXFLAGS)"
+	@echo "COMPILE_CMFLAGS    = $(COMPILE_CMFLAGS)"
+	@echo "COMPILE_CMMFLAGS   = $(COMPILE_CMMFLAGS)"
+	@echo "LDFLAGS            = $(LDFLAGS)"
+	@echo "OS_LDFLAGS         = $(OS_LDFLAGS)"
+	@echo "DSO_LDOPTS         = $(DSO_LDOPTS)"
+	@echo "OS_INCLUDES        = $(OS_INCLUDES)"
+	@echo "OS_LIBS            = $(OS_LIBS)"
+	@echo "EXTRA_LIBS         = $(EXTRA_LIBS)"
+	@echo "BIN_FLAGS          = $(BIN_FLAGS)"
+	@echo "INCLUDES           = $(INCLUDES)"
+	@echo "DEFINES            = $(DEFINES)"
+	@echo "ACDEFINES          = $(ACDEFINES)"
+	@echo "BIN_SUFFIX         = $(BIN_SUFFIX)"
+	@echo "LIB_SUFFIX         = $(LIB_SUFFIX)"
+	@echo "DLL_SUFFIX         = $(DLL_SUFFIX)"
+	@echo "IMPORT_LIB_SUFFIX  = $(IMPORT_LIB_SUFFIX)"
+	@echo "INSTALL            = $(INSTALL)"
+
+showhost:
+	@echo "HOST_CC            = $(HOST_CC)"
+	@echo "HOST_CXX           = $(HOST_CXX)"
+	@echo "HOST_CFLAGS        = $(HOST_CFLAGS)"
+	@echo "HOST_LDFLAGS       = $(HOST_LDFLAGS)"
+	@echo "HOST_LIBS          = $(HOST_LIBS)"
+	@echo "HOST_EXTRA_LIBS    = $(HOST_EXTRA_LIBS)"
+	@echo "HOST_EXTRA_DEPS    = $(HOST_EXTRA_DEPS)"
+	@echo "HOST_PROGRAM       = $(HOST_PROGRAM)"
+	@echo "HOST_OBJS          = $(HOST_OBJS)"
+	@echo "HOST_PROGOBJS      = $(HOST_PROGOBJS)"
+	@echo "HOST_LIBRARY       = $(HOST_LIBRARY)"
+
+showbuildmods::
+	@echo "Build Modules	= $(BUILD_MODULES)"
+	@echo "Module dirs	= $(BUILD_MODULE_DIRS)"
+
+zipmakes:
+ifneq (,$(filter $(PROGRAM) $(SIMPLE_PROGRAMS) $(LIBRARY) $(SHARED_LIBRARY),$(TARGETS)))
+	zip $(DEPTH)/makefiles $(subst $(topsrcdir),$(MOZ_SRC)/mozilla,$(srcdir)/Makefile.in)
+endif
+	+$(LOOP_OVER_PARALLEL_DIRS)
+	+$(LOOP_OVER_DIRS)
+
+documentation:
+	@cd $(DEPTH)
+	$(DOXYGEN) $(DEPTH)/config/doxygen.cfg
+
+check:: $(SUBMAKEFILES) $(MAKE_DIRS)
+	+$(LOOP_OVER_PARALLEL_DIRS)
+	+$(LOOP_OVER_DIRS)
+	+$(LOOP_OVER_TOOL_DIRS)
diff -r 17e9560465b0 js/src/config/system-headers
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/system-headers	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,1038 @@
+A4Stuff.h
+activscp.h
+AEDataModel.h
+AEObjects.h
+AEPackObject.h
+AERegistry.h
+AEUtils.h
+afxcmn.h
+afxcoll.h
+afxcview.h
+afxdisp.h
+afxdtctl.h
+afxext.h
+afxmt.h
+afxpriv.h
+afxtempl.h
+afxwin.h
+algorithm
+Aliases.h
+all.h
+alloca.h
+alloc.h
+alsa/asoundlib.h
+alsa/pcm.h
+alsa/mixer.h
+ansi_parms.h
+a.out.h
+app/Cursor.h
+Appearance.h
+AppFileInfo.h
+AppKit.h
+AppleEvents.h
+Application.h
+app/Message.h
+app/MessageRunner.h
+arpa/inet.h
+arpa/nameser.h
+asm/sigcontext.h
+asm/signal.h
+ASRegistry.h
+assert.h
+atk/atk.h
+atlbase.h
+atlcom.h
+atlconv.h
+atlctl.cpp
+atlctl.h
+ATLCTL.H
+atlhost.h
+atlimpl.cpp
+atlwin.cpp
+ATSTypes.h
+ATSUnicode.h
+Balloons.h
+base/pblock.h
+base/PCR_Base.h
+base/session.h
+basetyps.h
+be/app/Application.h
+Beep.h
+be/kernel/image.h
+be/kernel/OS.h
+bfd.h
+Bitmap.h
+bsd/libc.h
+bsd/syscall.h
+bstring.h
+builtin.h
+Button.h
+byteswap.h
+#if MOZ_ENABLE_LIBXUL!=1
+#define WRAP_CAIRO_HEADERS
+#endif
+#if MOZ_TREE_CAIRO!=1
+#define WRAP_CAIRO_HEADERS
+#endif
+#ifdef WRAP_CAIRO_HEADERS
+cairo.h
+cairo-atsui.h
+cairo-beos.h
+cairo-ft.h
+cairo-glitz.h
+cairo-os2.h
+cairo-pdf.h
+cairo-ps.h
+cairo-quartz.h
+cairo-win32.h
+cairo-xlib.h
+cairo-xlib-xrender.h
+cairo-directfb.h
+cairo-qpainter.h
+#endif
+dfiff.h
+fusion/reactor.h
+fusion/property.h
+fusion/conf.h
+fusion/build.h
+fusion/hash.h
+fusion/shm/shm.h
+fusion/shm/shm_internal.h
+fusion/shm/pool.h
+fusion/ref.h
+fusion/fusion_internal.h
+fusion/lock.h
+fusion/types.h
+fusion/vector.h
+fusion/call.h
+fusion/shmalloc.h
+fusion/protocol.h
+fusion/fusion.h
+fusion/arena.h
+fusion/object.h
+directfbgl.h
+directfb_version.h
+directfb.h
+directfb_util.h
+directfb_keynames.h
+dgiff.h
+direct/util.h
+direct/memcpy.h
+direct/interface.h
+direct/conf.h
+direct/tree.h
+direct/signals.h
+direct/build.h
+direct/interface_implementation.h
+direct/utf8.h
+direct/serial.h
+direct/hash.h
+direct/direct.h
+direct/clock.h
+direct/types.h
+direct/mem.h
+direct/thread.h
+direct/debug.h
+direct/stream.h
+direct/messages.h
+direct/trace.h
+direct/modules.h
+direct/log.h
+direct/system.h
+direct/list.h
+dfb_types.h
+directfb_strings.h
+directfb_keyboard.h
+callconv.h
+Carbon/Carbon.h
+CarbonEvents.h
+Carbon.h
+cassert
+c_asm.h
+cctype
+cderr.h
+cerrno
+cert.h
+CFBase.h
+CFBundle.h
+CFData.h
+CFDictionary.h
+cf.h
+CFNumber.h
+CFPlugIn.h
+CFPreferences.h
+CFString.h
+CFURL.h
+CGAffineTransform.h
+CheckBox.h
+climits
+Clipboard.h
+cmplrs/stsupport.h
+Cocoa/Cocoa.h
+CodeFragments.h
+comdef.h
+commctrl.h
+COMMCTRL.H
+commdlg.h
+compat.h
+condapi.h
+ConditionalMacros.h
+config.h
+conio.h
+console.h
+ControlDefinitions.h
+Controls.h
+CoreFoundation/CoreFoundation.h
+CoreServices/CoreServices.h
+CPalmRec.cpp
+Cpalmrec.h
+CPCatgry.cpp
+CPDbBMgr.h
+CPString.cpp
+CPString.h
+crtdbg.h
+crt_externs.h
+crypt.h
+cstdio
+cstdlib
+cstring
+ctime
+ctype.h
+curl/curl.h
+curl/easy.h
+curl/types.h
+curses.h
+cxxabi.h
+DateTimeUtils.h
+dbus/dbus.h
+dbus/dbus-glib.h
+dbus/dbus-glib-lowlevel.h
+ddeml.h
+Debug.h
+dem.h
+descrip.h
+Devices.h
+Dialogs.h
+direct.h
+dirent.h
+DiskInit.h
+dlfcn.h
+dlgs.h
+dl.h
+docobj.h
+dos/dosextens.h
+dos.h
+Drag.h
+DriverServices.h
+DriverSynchronization.h
+DropInPanel.h
+dvidef.h
+elf.h
+endian.h
+Entry.h
+errno.h
+Errors.h
+Events.h
+exdisp.h
+ExDisp.h
+exe386.h
+execinfo.h
+extras.h
+fabdef.h
+fcntl.h
+features.h
+fibdef.h
+File.h
+filehdr.h
+files.h
+Files.h
+FindDirectory.h
+Finder.h
+FinderRegistry.h
+FixMath.h
+float.h
+Folders.h
+fontconfig/fontconfig.h
+fontconfig/fcfreetype.h
+Font.h
+Fonts.h
+fp.h
+fpieee.h
+frame/log.h
+frame/req.h
+freetype/freetype.h
+freetype/ftcache.h
+freetype/ftglyph.h
+freetype/ftsynth.h
+freetype/ftoutln.h
+freetype/ttnameid.h
+freetype/tttables.h
+freetype/t1tables.h
+fribidi/fribidi.h
+FSp_fopen.h
+fstream.h
+ft2build.h
+gconf/gconf-client.h
+Gdiplus.h
+gdk/gdkevents.h
+gdk/gdk.h
+gdk/gdkkeysyms.h
+gdk/gdkpango.h
+gdk/gdkprivate.h
+gdk/gdkscreen.h
+gdk/gdkregion.h
+gdk/gdkwindow.h
+gdk/gdkx.h
+gdk/gdkdirectfb.h
+gdk-pixbuf/gdk-pixbuf.h
+Gestalt.h
+getopt.h
+glibconfig.h
+glib.h
+glib-object.h
+gmodule.h
+gnome.h
+gnu/libc-version.h
+grp.h
+gssapi_generic.h
+gssapi/gssapi_generic.h
+gssapi/gssapi.h
+gssapi.h
+gtk/gtkbindings.h
+gtk/gtkbutton.h
+gtk/gtkclipboard.h
+gtk/gtkcontainer.h
+gtk/gtkdialog.h
+gtk/gtkentry.h
+gtk/gtkfixed.h
+gtk/gtk.h
+gtk/gtkiconfactory.h
+gtk/gtkimage.h
+gtk/gtkimmulticontext.h
+gtk/gtkinvisible.h
+gtk/gtkmain.h
+gtk/gtkmessagedialog.h
+gtk/gtkobject.h
+gtk/gtkprinter.h
+gtk/gtkprintjob.h
+gtk/gtkprintunixdialog.h
+gtk/gtkprivate.h
+gtk/gtkselection.h
+gtk/gtksignal.h
+gtk/gtksocket.h
+gtk/gtkstock.h
+gtk/gtkstyle.h
+gtk/gtktextview.h
+gtk/gtkvscrollbar.h
+gtk/gtkwidget.h
+gtk/gtkwindow.h
+gtk/gtkversion.h
+HIToolbox/HIToolbox.h
+hlink.h
+htiface.h
+ia64/sys/inline.h
+Icons.h
+iconv.h
+IDL.h
+ieeefp.h
+ifaddrs.h
+image.h
+imagehlp.h
+imm.h
+initguid.h
+InterfaceDefs.h
+InternetConfig.h
+IntlResources.h
+ints.h
+intshcut.h
+inttypes.h
+iodef.h
+io.h
+IOKit/IOKitLib.h
+IOKit/IOMessage.h
+IOKit/pwr_mgt/IOPMLib.h
+iomanip
+iostream
+iostream.h
+jar.h
+JavaControl.h
+JavaEmbedding/JavaControl.h
+JavaVM/jni.h
+JManager.h
+JNIEnvTests.h
+jni.h
+#if MOZ_NATIVE_JPEG==1
+jpeglib.h
+#endif
+JVMManagerTests.h
+Kerberos/Kerberos.h
+kernel/image.h
+kernel/OS.h
+key.h
+keyt.h
+keythi.h
+LAction.h
+langinfo.h
+LApplication.h
+LArray.h
+LArrayIterator.h
+LAttachable.h
+LAttachment.h
+LaunchServices.h
+lber.h
+LBroadcaster.h
+LButton.h
+lcache.h
+LCaption.h
+LCheckBox.h
+LCicnButton.h
+LClipboard.h
+LCommander.h
+LComparator.h
+LControl.h
+ldap.h
+ldaplog.h
+ldappr.h
+ldap_ssl.h
+LDataStream.h
+ldfcn.h
+LDialogBox.h
+ldif.h
+LDocApplication.h
+LDocument.h
+LDragAndDrop.h
+LDragTask.h
+LEditField.h
+LEditText.h
+LEventDispatcher.h
+LFile.h
+LFileStream.h
+LFileTypeList.h
+LFocusBox.h
+LGrafPortView.h
+LHandleStream.h
+libc_r.h
+libelf.h
+libelf/libelf.h
+libgen.h
+libgnome/gnome-url.h
+libgnome/libgnome.h
+libgnomeui/gnome-icon-lookup.h
+libgnomeui/gnome-icon-theme.h
+libgnomeui/gnome-ui-init.h
+libgnomevfs/gnome-vfs-application-registry.h
+libgnomevfs/gnome-vfs-file-info.h
+libgnomevfs/gnome-vfs.h
+libgnomevfs/gnome-vfs-init.h
+libgnomevfs/gnome-vfs-mime.h
+libgnomevfs/gnome-vfs-mime-handlers.h
+libgnomevfs/gnome-vfs-mime-info.h
+libgnomevfs/gnome-vfs-mime-utils.h
+libgnomevfs/gnome-vfs-ops.h
+libgnomevfs/gnome-vfs-standard-callbacks.h
+libIDL/IDL.h
+lib$routines.h
+limits
+limits.h
+link.h
+linux/kernel.h
+linux/limits.h
+linux/rtc.h
+linux/version.h
+list
+List.h
+Lists.h
+LiveConnectManagerTests.h
+LListBox.h
+LListener.h
+LMenuBar.h
+LMenu.h
+LModelDirector.h
+LModelObject.h
+LModelProperty.h
+loader.h
+locale
+locale.h
+LOffscreenView.h
+logkeys.h
+logstrng.h
+Looper.h
+LowMem.h
+LPane.h
+LPeriodical.h
+LPicture.h
+LPlaceHolder.h
+LPrintout.h
+LProgressBar.h
+LPushButton.h
+LRadioGroup.h
+LRadioGroupView.h
+LRunArray.h
+LScroller.h
+LSharable.h
+LSingleDoc.h
+LStaticText.h
+LStdControl.h
+LStream.h
+LString.h
+LTabGroup.h
+LTabGroupView.h
+LTableArrayStorage.h
+LTableMonoGeometry.h
+LTableSingleSelector.h
+LTableView.h
+LTextEditView.h
+LTextTableView.h
+LUndoer.h
+LVariableArray.h
+LView.h
+LWindow.h
+m68881.h
+MacErrors.h
+MacHeadersCarbon.h
+machine/ansi.h
+machine/builtins.h
+machine/clock.h
+machine/endian.h
+machine/frame.h
+machine/inline.h
+machine/limits.h
+machine/signal.h
+machine/trap.h
+mach/mach_host.h
+mach/mach_init.h
+mach/mach_interface.h
+mach/mach_port.h
+mach-o/dyld.h
+MacLocales.h
+MacMemory.h
+MacTCP.h
+MacTypes.h
+MacWindows.h
+malloc.h
+map
+mapicode.h
+mapidefs.h
+mapiguid.h
+mapi.h
+mapitags.h
+mapiutil.h
+mapix.h
+Math64.h
+math.h
+mbstring.h
+mem.h
+memory
+memory.h
+Memory.h
+MenuBar.h
+Menu.h
+Menus.h
+Message.h
+Mime.h
+MixedMode.h
+mlang.h
+mmsystem.h
+model.h
+Movies.h
+mpw/errno.h
+mshtmhst.h
+mshtml.h
+mswsock.h
+Multiprocessing.h
+mutex.h
+Navigation.h
+ncompat.h
+ncurses.h
+netCore.h
+netdb.h
+net/if.h
+netinet/in.h
+netinet/in_systm.h
+netinet/tcp.h
+new
+newexe.h
+new.h
+nl_types.h
+NodeInfo.h
+nss.h
+nssilock.h
+objbase.h
+objidl.h
+Objsafe.h
+ojiapitests.h
+ole2.h
+oleidl.h
+OpenTptInternet.h
+OpenTransport.h
+os2.h
+OS.h
+osreldate.h
+OSUtils.h
+Packages.h
+Palettes.h
+PALM_CMN.H
+pango-engine.h
+pango-glyph.h
+pango-modules.h
+pango/pangocairo.h
+pango/pangofc-decoder.h
+pango/pangofc-font.h
+pango/pangofc-fontmap.h
+pango/pango-break.h
+pango/pango-fontmap.h
+pango/pango.h
+pango/pangoxft.h
+pango/pangox.h
+pango/pango-utils.h
+pango-types.h
+pascal.h
+Patches.h
+Path.h
+pcfs/pc_dir.h
+Pgenerr.h
+PGenErr.h
+Ph.h
+photon/Pg.h
+photon/PhProto.h
+photon/PhRender.h
+photon/PpProto.h
+photon/PtProgress.h
+photon/PtServer.h
+photon/PtWebClient.h
+photon/PxImage.h
+pk11func.h
+pk11pub.h
+pkcs11t.h
+PLStringFuncs.h
+PMApplication.h
+pmddim.h
+poll.h
+Polygon.h
+portable.h
+Power.h
+PP_ClassHeaders.cp
+PP_Constants.h
+PPCToolbox.h
+PP_DebugHeaders.cp
+PP_KeyCodes.h
+PP_Macros.h
+PP_Messages.h
+PP_Prefix.h
+PP_Resources.h
+PP_Types.h
+Printing.h
+Print/PMPrintingDialogExtensions.h
+private/qucomextra_p.h
+Processes.h
+process.h
+Process.h
+proto/dos.h
+proto/exec.h
+psap.h
+Pt.h
+pthread.h
+pwd.h
+Python.h
+QDOffscreen.h
+Quickdraw.h
+QuickDraw.h
+QuickTimeComponents.h
+quipu/attr.h
+rasdlg.h
+raserror.h
+ras.h
+regex.h
+Region.h
+resolv.h
+Resources.h
+Retrace.h
+rld_interface.h
+rmsdef.h
+Roster.h
+rpc.h
+rpcproxy.h
+rpc/types.h
+sane/sane.h
+sane/sanei.h
+sane/saneopts.h
+Scrap.h
+Screen.h
+Script.h
+ScrollBar.h
+seccomon.h
+sec.h
+secmod.h
+secmodt.h
+secrng.h
+security.h
+secutil.h
+semaphore.h
+servprov.h
+setjmp.h
+SFNTLayoutTypes.h
+SFNTTypes.h
+share.h
+shellapi.h
+shlguid.h
+shlobj.h
+sigcontext.h
+signal.h
+SimpleGameSound.h
+SIOUX.h
+size_t.h
+someincludefile.h
+Sound.h
+sqlite3.h
+ssdef.h
+sslerr.h
+ssl.h
+sslproto.h
+sstream
+stack
+StandardFile.h
+starlet.h
+stat.h
+statreg.cpp
+statreg.h
+stdarg.h
+stdbool.h
+stddef.h
+stdint.h
+stdio.h
+stdlib.h
+storage/FindDirectory.h
+StorageKit.h
+string
+StringCompare.h
+string.h
+String.h
+strings.h
+Strings.h
+StringView.h
+stropts.h
+strstrea.h
+structs.h
+stsdef.h
+SupportDefs.h
+support/String.h
+support/SupportDefs.h
+support/TLS.h
+svrcore.h
+symconst.h
+sym.h
+synch.h
+syncmgr.h
+sys/atomic_op.h
+sys/bitypes.h
+sys/byteorder.h
+syscall.h
+sys/cdefs.h
+sys/cfgodm.h
+sys/elf.h
+sys/endian.h
+sys/errno.h
+sys/fault.h
+sys/fcntl.h
+sys/file.h
+sys/filio.h
+sys/frame.h
+sys/immu.h
+sys/inttypes.h
+sys/ioccom.h
+sys/ioctl.h
+sys/ipc.h
+sys/ldr.h
+sys/link.h
+sys/locking.h
+syslog.h
+sys/lwp.h
+sys/machine.h
+sys/mman.h
+sys/mmu.h
+sys/mount.h
+sys/mpctl.h
+sys/param.h
+sys/pda.h
+sys/poll.h
+sys/ppc.h
+sys/prctl.h
+sys/priv.h
+sys/procfs.h
+sys/pstat.h
+sys/ptrace.h
+sys/queue.h
+sys/reg.h
+sys/regset.h
+sys/resource.h
+sys/sched.h
+sys/select.h
+sys/sem.h
+sys/sendfile.h
+sys/shm.h
+sys/siginfo.h
+sys/signal.h
+sys/socket.h
+sys/sockio.h
+sys/sparc/frame.h
+sys/stack.h
+sys/statfs.h
+sys/stat.h
+sys/statvfs.h
+sys/syscall.h
+sys/sysctl.h
+sys/sysinfo.h
+sys/sysmp.h
+sys/syssgi.h
+sys/systeminfo.h
+sys/timeb.h
+sys/time.h
+sys/times.h
+sys/ttycom.h
+sys/types.h
+sys/ucontext.h
+sys/uio.h
+sys/un.h
+sys/unistd.h
+sys/utsname.h
+sys/vfs.h
+sys/wait.h
+tables.h
+TArray.h
+TArrayIterator.h
+task.h
+tchar.h
+TCHAR.H
+termios.h
+TextCommon.h
+TextEdit.h
+TextEncodingConverter.h
+TextServices.h
+TextUtils.h
+TextView.h
+th/PCR_Th.h
+thread.h
+ThreadManagerTests.h
+Threads.h
+time.h
+Timer.h
+tlhelp32.h
+ToolUtils.h
+trace.h
+Traps.h
+typeinfo
+types.h
+Types.h
+UAppleEventsMgr.h
+UAttachments.h
+ucontext.h
+uconv.h
+UCursor.h
+ucx$inetdef.h
+UDebugging.h
+UDesktop.h
+UDrawingState.h
+UDrawingUtils.h
+UEnvironment.h
+UEventMgr.h
+UException.h
+UExtractFromAEDesc.h
+UGWorld.h
+UKeyFilters.h
+ulocks.h
+ulserrno.h
+UMemoryMgr.h
+UModalDialogs.h
+UNavServicesDialogs.h
+UnicodeBlockObjects.h
+UnicodeConverter.h
+UnicodeUtilities.h
+unidef.h
+unikbd.h
+unistd.h
+unix.h
+unixio.h
+unixlib.h
+unknwn.h
+UPrinting.h
+UQuickTime.h
+UReanimator.h
+URegions.h
+URegistrar.h
+UResourceMgr.h
+urlhist.h
+urlmon.h
+UScrap.h
+UScreenPort.h
+UTCUtils.h
+UTETextAction.h
+UTEViewTextAction.h
+UTextEdit.h
+UTextTraits.h
+utility
+utime.h
+UWindows.h
+values.h
+varargs.h
+vcclr.h
+vector
+View.h
+Volume.h
+wab.h
+wait.h
+wchar.h
+winbase.h
+win/compobj.h
+windef.h
+Window.h
+windows.h
+Windows.h
+windowsx.h
+Wininet.h
+winnls.h
+winperf.h
+winreg.h
+Winreg.h
+winsock2.h
+winsock.h
+winspool.h
+winsvc.h
+winuser.h
+winver.h
+wmem.h
+workbench/startup.h
+wtypes.h
+wx/image.h
+wx/listctrl.h
+wx/log.h
+wx/toolbar.h
+wx/wx.h
+wx/xrc/xmlres.h
+X11/cursorfont.h
+X11/extensions/Print.h
+X11/extensions/shape.h
+X11/extensions/XIElib.h
+X11/extensions/XShm.h
+X11/extensions/Xrender.h
+X11/Intrinsic.h
+X11/keysymdef.h
+X11/keysym.h
+X11/Shell.h
+X11/StringDefs.h
+X11/Xatom.h
+X11/Xft/Xft.h
+X11/Xfuncproto.h
+X11/X.h
+X11/XKBlib.h
+X11/Xlib.h
+X11/Xlibint.h
+X11/Xlocale.h
+X11/Xos.h
+X11/Xutil.h
+xpt_struct.h
+xpt_xdr.h
+zmouse.h
+sslt.h
+smime.h
+cms.h
+sechash.h
+secoidt.h
+certdb.h
+secerr.h
+nssb64.h
+secasn1.h
+secder.h
+certt.h
+ocsp.h
+keyhi.h
+cryptohi.h
+crmf.h
+pk11pqg.h
+cmmf.h
+base64.h
+secdert.h
+secitem.h
+secmime.h
+nssckbi.h
+pkcs12.h
+p12plcy.h
+pk11sdr.h
+nspr.h
+pratom.h
+prbit.h
+prclist.h
+prcmon.h
+prcountr.h
+prcvar.h
+prdtoa.h
+prenv.h
+prerr.h
+prerror.h
+prinet.h
+prinit.h
+prinrval.h
+prio.h
+pripcsem.h
+prlink.h
+prlock.h
+prlog.h
+prlong.h
+prmem.h
+prmon.h
+prmwait.h
+prnetdb.h
+prolock.h
+prpdce.h
+prprf.h
+prproces.h
+prrng.h
+prrwlock.h
+prshm.h
+prshma.h
+prsystem.h
+prthread.h
+prtime.h
+prtpool.h
+prtrace.h
+prtypes.h
+prvrsion.h
+plbase64.h
+plerror.h
+plgetopt.h
+plresolv.h
+plstr.h
+plarenas.h
+plarena.h
+plhash.h
+#if MOZ_NATIVE_PNG==1
+png.h
+#endif
+#if MOZ_NATIVE_ZLIB==1
+zlib.h
+#endif
+#if MOZ_ENABLE_LIBXUL!=1
+#if BUILD_STATIC_LIBS!=1
+#define WRAP_LCMS_HEADERS
+#endif
+#endif
+#if MOZ_NATIVE_LCMS==1
+#define WRAP_LCMS_HEADERS
+#endif
+#ifdef WRAP_LCMS_HEADERS
+icc34.h
+lcms.h
+#endif
+#ifdef MOZ_ENABLE_STARTUP_NOTIFICATION
+libsn/sn.h
+libsn/sn-common.h
+libsn/sn-launchee.h
+libsn/sn-launcher.h
+libsn/sn-monitor.h
+libsn/sn-util.h
+#endif
+#if MOZ_NATIVE_HUNSPELL==1
+hunspell.hxx
+#endif
+#if MOZ_NATIVE_BZ2==1
+bzlib.h
+#endif
diff -r 17e9560465b0 js/src/config/version.mk
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/version.mk	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,85 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Win32 Version System.
+#
+# The Initial Developer of the Original Code is Netscape Communications Corporation
+# Portions created by the Initial Developer are Copyright (C) 2002
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+ifndef INCLUDED_VERSION_MK
+INCLUDED_VERSION_MK=1
+
+# Windows gmake build:
+# Build default .rc file if $(RESFILE) isn't defined.
+# TODO:
+# PBI      : Private build info.  Not used currently.
+#            Guessing the best way would be to set an env var.
+# BINARY   : Binary name.  Not used currently.
+ifeq ($(MOZ_WIDGET_TOOLKIT),windows)
+ifndef RESFILE
+RCFILE=./module.rc
+RESFILE=./module.res
+_RC_STRING = -QUIET 1 -DEPTH $(DEPTH) -TOPSRCDIR $(topsrcdir) -BITS $(MOZ_BITS) -OBJDIR . -SRCDIR $(srcdir) -DISPNAME $(MOZ_APP_DISPLAYNAME)
+ifneq ($(BUILD_OFFICIAL)_$(MOZILLA_OFFICIAL),_)
+_RC_STRING += -OFFICIAL 1
+endif
+ifdef MOZ_DEBUG
+_RC_STRING += -DEBUG 1
+endif
+ifdef MODULE
+_RC_STRING += -MODNAME $(MODULE)
+endif
+ifdef PROGRAM
+_RC_STRING += -BINARY $(PROGRAM)
+else
+ifdef _PROGRAM
+_RC_STRING += -BINARY $(_PROGRAM)
+else
+ifdef SHARED_LIBRARY
+_RC_STRING += -BINARY $(SHARED_LIBRARY)
+endif
+endif
+endif
+ifdef RCINCLUDE
+_RC_STRING += -RCINCLUDE $(srcdir)/$(RCINCLUDE)
+endif
+
+GARBAGE += $(RESFILE) $(RCFILE)
+
+#dummy target so $(RCFILE) doesn't become the default =P
+all::
+
+$(RCFILE): $(RCINCLUDE) $(topsrcdir)/config/version_win.pl
+	$(PERL) $(topsrcdir)/config/version_win.pl $(_RC_STRING)
+
+endif  # RESFILE
+endif  # Windows
+
+endif
diff -r 17e9560465b0 js/src/config/version_win.pl
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/config/version_win.pl	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,423 @@
+#!/usr/bin/perl -w
+
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Win32 Version System.
+#
+# The Initial Developer of the Original Code is Brian Bober <netdemonz@yahoo.com>
+# Portions created by the Initial Developer are Copyright (C) 2001
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+#use diagnostics;
+require strict;
+my $dir = $0;
+$dir =~ s/[^\/]*$//;
+push(@INC, "$dir");
+require "Moz/Milestone.pm";
+use Getopt::Long;
+use Getopt::Std;
+use POSIX;
+
+# Calculate the number of days since Jan. 1, 2000 from a buildid string
+sub daysFromBuildID
+{
+    my ($buildid,) = @_;
+
+    my ($y, $m, $d, $h) = ($buildid =~ /^(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})$/);
+    $d || die("Unrecognized buildid string.");
+
+    my $secondstodays = 60 * 60 * 24;
+    return (POSIX::mktime(00, 00, 00, $d, $m, $y - 1900) -
+            POSIX::mktime(00, 00, 00, 01, 01, 100)) / $secondstodays;
+}
+
+#Creates version resource file
+
+#Paramaters are passed on the command line:
+
+#Example: -MODNAME nsToolkitCompsModule -DEBUG=1
+
+# DEBUG - Mozilla's global debug variable - tells if its debug version
+# OFFICIAL - tells Mozilla is building a milestone or nightly
+# MSTONE - tells which milestone is being built;
+# OBJDIR - Holds the object directory;
+# MODNAME - tells what the name of the module is like nsBMPModule
+# DEPTH - Holds the path to the root obj dir
+# TOPSRCDIR - Holds the path to the root mozilla dir
+# SRCDIR - Holds module.ver and source
+# BINARY - Holds the name of the binary file
+# DISPNAME - Holds the display name of the built application
+# BITS - 16 or 32 bit
+# RCINCLUDE - Holds the name of the RC File to include or ""
+# QUIET - Turns off output
+
+#Description and Comment come from module.ver
+#Bug 23560
+#http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/rc_7x2d.asp
+
+#Get next .ver file entry
+sub getNextEntry
+{
+	while (<VERFILE>) 
+	{ 
+		my $mline = $_;
+		($mline) = split(/#/,$mline);
+		my ($entry, $value)=split(/=/,$mline,2);
+		if (defined($entry))
+		{
+			if (defined($value))
+			{
+				$entry =~ s/^\s*(.*?)\s*$/$1/;
+				$value =~ s/^\s*(.*?)\s*$/$1/;
+				return ($entry,$value);
+			}
+		}
+	}
+	return undef;
+}
+
+my ($quiet,$objdir,$debug,$official,$milestone,$buildid,$module,$binary,$depth,$rcinclude,$bits,$srcdir,$fileversion,$productversion);
+
+GetOptions( "QUIET" => \$quiet,
+		"DEBUG=s" => \$debug,
+		"OFFICIAL=s" => \$official,
+		"MSTONE=s" => \$milestone,
+		"MODNAME=s" => \$module,
+		"BINARY=s" => \$binary,
+		"DISPNAME=s" => \$displayname,
+		"SRCDIR=s" => \$srcdir,
+		"TOPSRCDIR=s" => \$topsrcdir,
+		"DEPTH=s" => \$depth,
+		"RCINCLUDE=s" => \$rcinclude,
+		"OBJDIR=s" => \$objdir,
+		"BITS=s" => \$bits);
+if (!defined($debug)) {$debug="";}
+if (!defined($official)) {$official="";}
+if (!defined($milestone)) {$milestone="";}
+if (!defined($module)) {$module="";}
+if (!defined($binary)) {$binary="";}
+if (!defined($displayname)) {$displayname="Mozilla";}
+if (!defined($depth)) {$depth=".";}
+if (!defined($rcinclude)) {$rcinclude="";}
+if (!defined($objdir)) {$objdir=".";}
+if (!defined($srcdir)) {$srcdir=".";}
+if (!defined($topsrcdir)) {$topsrcdir=".";}
+if (!defined($bits)) {$bits="";}
+my $mfversion = "Personal";
+my $mpversion = "Personal";
+my @fileflags = ("0");
+my $comment="";
+my $description="";
+if (!defined($module))
+{
+	$module = $binary;
+	($module) = split(/\./,$module);
+}
+
+my $fileos = "VOS__WINDOWS32";
+if ($bits eq "16") { $fileos="VOS__WINDOWS16"; }
+
+my $bufferstr="    ";
+
+my $MILESTONE_FILE = "$topsrcdir/config/milestone.txt";
+my $BUILDID_FILE = "$depth/config/buildid";
+
+#Read module.ver file
+#Version file overrides for WIN32:
+#WIN32_MODULE_COMMENT
+#WIN32_MODULE_DESCRIPTION
+#WIN32_MODULE_FILEVERSION
+#WIN32_MODULE_COMPANYNAME
+#WIN32_MODULE_FILEVERSION_STRING
+#WIN32_MODULE_NAME
+#WIN32_MODULE_COPYRIGHT
+#WIN32_MODULE_TRADEMARKS
+#WIN32_MODULE_ORIGINAL_FILENAME
+#WIN32_MODULE_PRODUCTNAME
+#WIN32_MODULE_PRODUCTVERSION
+#WIN32_MODULE_PRODUCTVERSION_STRING
+
+#Override values obtained from the .ver file
+my $override_comment;
+my $override_description;
+my $override_fileversion;
+my $override_company;
+my $override_mfversion;
+my $override_module;
+my $override_copyright;
+my $override_trademarks;
+my $override_filename;
+my $override_productname;
+my $override_productversion;
+my $override_mpversion;
+if (open(VERFILE, "<$srcdir/module.ver")) 
+{
+
+	my ($a,$b) = getNextEntry();
+	while (defined($a))
+	{
+		if ($a eq "WIN32_MODULE_COMMENT") { $override_comment = $b; }
+		if ($a eq "WIN32_MODULE_DESCRIPTION") { $override_description = $b; }
+		if ($a eq "WIN32_MODULE_FILEVERSION") { $override_fileversion = $b; }
+		if ($a eq "WIN32_MODULE_COMPANYNAME") { $override_company = $b; }
+		if ($a eq "WIN32_MODULE_FILEVERSION_STRING") { $override_mfversion = $b; }
+		if ($a eq "WIN32_MODULE_NAME") { $override_module = $b; }
+		if ($a eq "WIN32_MODULE_COPYRIGHT") { $override_copyright = $b; }
+		if ($a eq "WIN32_MODULE_TRADEMARKS") { $override_trademarks = $b; }
+		if ($a eq "WIN32_MODULE_ORIGINAL_FILENAME") { $override_filename = $b; }
+		if ($a eq "WIN32_MODULE_PRODUCTNAME") { $override_productname = $b; }
+		if ($a eq "WIN32_MODULE_PRODUCTVERSION") { $override_productversion = $b; }
+		if ($a eq "WIN32_MODULE_PRODUCTVERSION_STRING") { $override_mpversion = $b; }
+		($a,$b) = getNextEntry();
+	}
+	close(VERFILE)
+}
+else
+{
+	if (!$quiet || $quiet ne "1") { print "$bufferstr" . "WARNING: No module.ver file included ($module, $binary). Default values used\n"; }
+}
+#Get rid of trailing and leading whitespace
+$debug =~ s/^\s*(.*)\s*$/$1/;
+$comment =~ s/^\s*(.*)\s*$/$1/;
+$official =~ s/^\s*(.*)\s*$/$1/;
+$milestone =~ s/^\s*(.*)\s*$/$1/;
+$description =~ s/^\s*(.*)\s*$/$1/;
+$module =~ s/^\s*(.*)\s*$/$1/;
+$depth =~ s/^\s*(.*)\s*$/$1/;
+$binary =~ s/^\s*(.*)\s*$/$1/;
+$displayname =~ s/^\s*(.*)\s*$/$1/;
+
+open(BUILDID, "<", $BUILDID_FILE) || die("Couldn't open buildid file: $BUILDID_FILE");
+$buildid = <BUILDID>;
+$buildid =~ s/\s*$//;
+close BUILDID;
+
+my $daycount = daysFromBuildID($buildid);
+
+if ($milestone eq "") {
+    $milestone = Moz::Milestone::getOfficialMilestone($MILESTONE_FILE);
+}
+
+$mfversion = $mpversion = $milestone;
+
+if ($debug eq "1")
+{
+	push @fileflags, "VS_FF_DEBUG";
+	$mpversion .= " Debug";
+	$mfversion .= " Debug";
+}
+
+if ($official ne "1") {
+    push @fileflags, "VS_FF_PRIVATEBUILD";
+}
+
+if ($milestone =~ /[a-z]/) {
+    push @fileflags, "VS_FF_PRERELEASE";
+}
+
+my @mstone = split(/\./,$milestone);
+$mstone[1] =~s/\D.*$//;
+if (!$mstone[2]) {
+    $mstone[2] = "0";
+}
+else {
+    $mstone[2] =~s/\D.*$//;
+}
+$fileversion = $productversion="$mstone[0],$mstone[1],$mstone[2],$daycount";
+
+my $copyright = "License: MPL 1.1/GPL 2.0/LGPL 2.1";
+my $company = "Mozilla Foundation";
+my $trademarks = "Mozilla";
+my $productname = $displayname;
+
+
+if (defined($override_comment)){$override_comment =~ s/\@MOZ_APP_DISPLAYNAME\@/$displayname/g; $comment=$override_comment;}
+if (defined($override_description)){$override_description =~ s/\@MOZ_APP_DISPLAYNAME\@/$displayname/g; $description=$override_description;}
+if (defined($override_fileversion)){$fileversion=$override_fileversion;}
+if (defined($override_mfversion)){$mfversion=$override_mfversion;}
+if (defined($override_company)){$company=$override_company;}
+if (defined($override_module)){$override_module =~ s/\@MOZ_APP_DISPLAYNAME\@/$displayname/g; $module=$override_module;}
+if (defined($override_copyright)){$override_copyright =~ s/\@MOZ_APP_DISPLAYNAME\@/$displayname/g; $copyright=$override_copyright;}
+if (defined($override_trademarks)){$override_trademarks =~ s/\@MOZ_APP_DISPLAYNAME\@/$displayname/g; $trademarks=$override_trademarks;}
+if (defined($override_filename)){$binary=$override_filename;}
+if (defined($override_productname)){$override_productname =~ s/\@MOZ_APP_DISPLAYNAME\@/$displayname/g; $productname=$override_productname;}
+if (defined($override_productversion)){$productversion=$override_productversion;}
+if (defined($override_mpversion)){$mpversion=$override_mpversion;}
+
+
+#Override section
+
+open(RCFILE, ">$objdir/module.rc") || die("Can't edit module.rc - It must be locked.\n");
+print RCFILE qq{
+// ***** BEGIN LICENSE BLOCK *****
+// Version: MPL 1.1/GPL 2.0/LGPL 2.1
+//
+// The contents of this file are subject to the Mozilla Public License Version
+// 1.1 (the "License"); you may not use this file except in compliance with
+// the License. You may obtain a copy of the License at
+// http://www.mozilla.org/MPL/
+//
+// Software distributed under the License is distributed on an "AS IS" basis,
+// WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+// for the specific language governing rights and limitations under the
+// License.
+//
+// The Original Code is the Win32 Version System.
+//
+// The Initial Developer of the Original Code is Brian Bober <netdemonz\@yahoo.com>
+// Portions created by the Initial Developer are Copyright (C) 2001
+// the Initial Developer. All Rights Reserved.
+//
+// Contributor(s):
+//
+// Alternatively, the contents of this file may be used under the terms of
+// either the GNU General Public License Version 2 or later (the "GPL"), or
+// the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+// in which case the provisions of the GPL or the LGPL are applicable instead
+// of those above. If you wish to allow use of your version of this file only
+// under the terms of either the GPL or the LGPL, and not to allow others to
+// use your version of this file under the terms of the MPL, indicate your
+// decision by deleting the provisions above and replace them with the notice
+// and other provisions required by the GPL or the LGPL. If you do not delete
+// the provisions above, a recipient may use your version of this file under
+// the terms of any one of the MPL, the GPL or the LGPL.
+//
+// ***** END LICENSE BLOCK *****
+
+#include<winver.h>
+
+// Note: if you contain versioning information in an included 
+// RC script, it will be discarded
+// Use module.ver to explicitly set these values
+
+// Do not edit this file. Changes won't affect the build.
+
+};
+
+my $versionlevel=0;
+my $insideversion=0;
+if (open(RCINCLUDE, "<$rcinclude")) 
+{
+	print RCFILE "// From included resource $rcinclude\n";
+#	my $mstring="";
+	while (<RCINCLUDE>) 
+	{
+		$_ =~ s/\@MOZ_APP_DISPLAYNAME\@/$displayname/g;
+		print RCFILE $_;
+#		my $instr=$_;
+#		chomp($instr);
+#		$mstring .= "$instr\;";
+	}
+	close(RCINCLUDE);
+#	$mstring =~ s/\/\*.*\*\///g;
+#	my @mlines = split(/\;/,$mstring);
+#	for(@mlines)
+#	{
+#		my ($nocomment)=split(/\/\//,$_);
+#		if (defined($nocomment) && $nocomment ne "")
+#		{
+#			my ($firststring,$secondstring) = split(/\s+/,$nocomment);
+#			if (!defined($firststring)) {$firststring="";}
+#			if (!defined($secondstring)) {$secondstring="";}
+#			if ($secondstring eq "VERSIONINFO") 
+#			{
+#if (!$quiet || $quiet ne "1") { 
+#				print "$bufferstr" . "WARNING: Included RC file ($rcinclude, $module, $binary)\n";
+#				print "$bufferstr" . "WARNING: contains versioning information that will be discarded\n";
+#				print "$bufferstr" . "WARNING: Remove it and use relevant overrides (in module.ver)\n";
+#}
+#				$versionlevel = 0;
+#				$insideversion = 1; 
+#			}
+#			if ($firststring eq "BEGIN") { $versionlevel++; }
+#			if ($secondstring eq "END") 
+#			{ 
+#				$versionlevel--; 
+#				if ($insideversion==1 && $versionlevel==0) {$versionlevel=0;}
+#			}
+#			my $includecheck = $firststring . $secondstring;
+#			$includecheck =~ s/<|>/"/g;
+#			$includecheck = lc($includecheck);
+#			if ($includecheck ne "#include\"winver.h\"")
+#			{
+#				if ($insideversion == 0 && $versionlevel == 0)
+#				{
+#					print RCFILE "$nocomment\n";	
+#				}
+#			}
+#		}
+#	}
+	
+}
+
+my $fileflags = join(' | ', @fileflags);
+
+print RCFILE qq{
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// Version
+//
+
+1 VERSIONINFO
+ FILEVERSION    $fileversion
+ PRODUCTVERSION $productversion
+ FILEFLAGSMASK 0x3fL
+ FILEFLAGS $fileflags
+ FILEOS $fileos
+ FILETYPE VFT_DLL
+ FILESUBTYPE 0x0L
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "000004b0"
+        BEGIN
+            VALUE "Comments", "$comment"
+            VALUE "LegalCopyright", "$copyright"
+            VALUE "CompanyName", "$company"
+            VALUE "FileDescription", "$description"
+            VALUE "FileVersion", "$mfversion"
+            VALUE "ProductVersion", "$mpversion"
+            VALUE "InternalName", "$module"
+            VALUE "LegalTrademarks", "$trademarks"
+            VALUE "OriginalFilename", "$binary"
+            VALUE "ProductName", "$productname"
+            VALUE "BuildID", "$buildid"
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x0, 1200
+    END
+END
+
+};
+close(RCFILE);
diff -r 17e9560465b0 js/src/configure.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/configure.in	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,5225 @@
+dnl -*- Mode: Autoconf; tab-width: 4; indent-tabs-mode: nil; -*-
+dnl vi: set tabstop=4 shiftwidth=4 expandtab:
+dnl ***** BEGIN LICENSE BLOCK *****
+dnl Version: MPL 1.1/GPL 2.0/LGPL 2.1
+dnl
+dnl The contents of this file are subject to the Mozilla Public License Version
+dnl 1.1 (the "License"); you may not use this file except in compliance with
+dnl the License. You may obtain a copy of the License at
+dnl http://www.mozilla.org/MPL/
+dnl
+dnl Software distributed under the License is distributed on an "AS IS" basis,
+dnl WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+dnl for the specific language governing rights and limitations under the
+dnl License.
+dnl
+dnl The Original Code is this file as it was released upon August 6, 1998.
+dnl
+dnl The Initial Developer of the Original Code is
+dnl Christopher Seawood.
+dnl Portions created by the Initial Developer are Copyright (C) 1998-2001
+dnl the Initial Developer. All Rights Reserved.
+dnl
+dnl Contributor(s):
+dnl   Jamie Zawinski <jwz@jwz.org>
+dnl   gettimeofday args check
+dnl   Christopher Blizzard <blizzard@appliedtheory.com>
+dnl   gnomefe update & enable-pthreads
+dnl   Ramiro Estrugo <ramiro@netscape.com>
+dnl   X11 makedepend support
+dnl   Insure support.
+dnl   Henry Sobotka <sobotka@axess.com>
+dnl   OS/2 support
+dnl   Dan Mosedale <dmose@mozilla.org>
+dnl   LDAP support
+dnl   Seth Spitzer <sspitzer@netscape.com>
+dnl   xpctools support
+dnl   Benjamin Smedberg <benjamin@smedbergs.us>
+dnl   Howard Chu <hyc@symas.com>
+dnl   MSYS support
+dnl   Mark Mentovai <mark@moxienet.com>:
+dnl   Mac OS X 10.4 support
+dnl   Giorgio Maone <g.maone@informaction.com>
+dnl   MSVC l10n compatible version check
+dnl   Ben Turner <mozilla@songbirdnest.com>
+dnl
+dnl Alternatively, the contents of this file may be used under the terms of
+dnl either the GNU General Public License Version 2 or later (the "GPL"), or
+dnl the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+dnl in which case the provisions of the GPL or the LGPL are applicable instead
+dnl of those above. If you wish to allow use of your version of this file only
+dnl under the terms of either the GPL or the LGPL, and not to allow others to
+dnl use your version of this file under the terms of the MPL, indicate your
+dnl decision by deleting the provisions above and replace them with the notice
+dnl and other provisions required by the GPL or the LGPL. If you do not delete
+dnl the provisions above, a recipient may use your version of this file under
+dnl the terms of any one of the MPL, the GPL or the LGPL.
+dnl
+dnl ***** END LICENSE BLOCK *****
+
+dnl Process this file with autoconf to produce a configure script.
+dnl ========================================================
+
+AC_PREREQ(2.13)
+AC_INIT(jsapi.h)
+AC_CONFIG_AUX_DIR(${srcdir}/build/autoconf)
+AC_CONFIG_HEADER(js-config.h)
+AC_CANONICAL_SYSTEM
+TARGET_CPU="${target_cpu}"
+TARGET_VENDOR="${target_vendor}"
+TARGET_OS="${target_os}"
+
+dnl ========================================================
+dnl =
+dnl = Don't change the following two lines.  Doing so breaks:
+dnl =
+dnl = CFLAGS="-foo" ./configure
+dnl =
+dnl ========================================================
+CFLAGS="${CFLAGS=}"
+CPPFLAGS="${CPPFLAGS=}"
+CXXFLAGS="${CXXFLAGS=}"
+LDFLAGS="${LDFLAGS=}"
+HOST_CFLAGS="${HOST_CFLAGS=}"
+HOST_CXXFLAGS="${HOST_CXXFLAGS=}"
+HOST_LDFLAGS="${HOST_LDFLAGS=}"
+
+dnl ========================================================
+dnl = Preserve certain environment flags passed to configure
+dnl = We want sub projects to receive the same flags
+dnl = untainted by this configure script
+dnl ========================================================
+_SUBDIR_CC="$CC"
+_SUBDIR_CXX="$CXX"
+_SUBDIR_CFLAGS="$CFLAGS"
+_SUBDIR_CPPFLAGS="$CPPFLAGS"
+_SUBDIR_CXXFLAGS="$CXXFLAGS"
+_SUBDIR_LDFLAGS="$LDFLAGS"
+_SUBDIR_HOST_CC="$HOST_CC"
+_SUBDIR_HOST_CFLAGS="$HOST_CFLAGS"
+_SUBDIR_HOST_CXXFLAGS="$HOST_CXXFLAGS"
+_SUBDIR_HOST_LDFLAGS="$HOST_LDFLAGS"
+_SUBDIR_CONFIG_ARGS="$ac_configure_args"
+
+dnl Set the version number of the libs included with mozilla
+dnl ========================================================
+NSPR_VERSION=4
+
+dnl Set the minimum version of toolkit libs used by mozilla
+dnl ========================================================
+GLIB_VERSION=1.2.0
+PERL_VERSION=5.006
+MAKE_VERSION=3.78
+WINDRES_VERSION=2.14.90
+W32API_VERSION=3.8
+
+MSMANIFEST_TOOL=
+
+dnl Set various checks
+dnl ========================================================
+MISSING_X=
+AC_PROG_AWK
+
+dnl Initialize the Pthread test variables early so they can be
+dnl  overridden by each platform.
+dnl ========================================================
+USE_PTHREADS=
+_PTHREAD_LDFLAGS=""
+
+dnl Do not allow a separate objdir build if a srcdir build exists.
+dnl ==============================================================
+_topsrcdir=`cd \`dirname $0\`; pwd`
+_objdir=`pwd`
+
+if test "$_topsrcdir" != "$_objdir"
+then
+  # Check for a couple representative files in the source tree
+  _conflict_files=
+  for file in $_topsrcdir/Makefile $_topsrcdir/config/autoconf.mk; do
+    if test -f $file; then
+      _conflict_files="$_conflict_files $file"
+    fi
+  done
+  if test "$_conflict_files"; then
+    echo "***"
+    echo "*   Your source tree contains these files:"
+    for file in $_conflict_files; do
+      echo "*         $file"
+    done
+    cat 1>&2 <<-EOF
+	*   This indicates that you previously built in the source tree.
+	*   A source tree build can confuse the separate objdir build.
+	*
+	*   To clean up the source tree:
+	*     1. cd $_topsrcdir
+	*     2. gmake distclean
+	***
+	EOF
+    exit 1
+    break
+  fi
+fi
+MOZ_BUILD_ROOT=`pwd`
+
+dnl Default to MSVC for win32
+dnl ==============================================================
+if test -z "$CROSS_COMPILE"; then
+case "$target" in
+*-cygwin*|*-mingw*|*-msvc*|*-mks*)
+    MAKE_VERSION=3.79
+    if test -z "$CC"; then CC=cl; fi
+    if test -z "$CXX"; then CXX=cl; fi
+    if test -z "$CPP"; then CPP="cl -E -nologo"; fi
+    if test -z "$CXXCPP"; then CXXCPP="cl -TP -E -nologo"; ac_cv_prog_CXXCPP="$CXXCPP"; fi
+    if test -z "$LD"; then LD=link; fi
+    if test -z "$AS"; then AS=ml; fi
+    if test -z "$MIDL"; then MIDL=midl; fi
+    ;;
+esac
+fi
+
+COMPILE_ENVIRONMENT=1
+MOZ_ARG_ENABLE_BOOL(compile-environment,
+[  --disable-compile-environment
+                           Disable compiler/library checks.],
+    COMPILE_ENVIRONMENT=1,
+    COMPILE_ENVIRONMENT= )
+
+dnl ========================================================
+dnl Checks for compilers.
+dnl ========================================================
+dnl Set CROSS_COMPILE in the environment when running configure
+dnl to use the cross-compile setup for now
+dnl ========================================================
+
+if test "$COMPILE_ENVIRONMENT"; then
+
+dnl Do some special WinCE toolchain stuff
+case "$target" in
+*wince)
+    echo -----------------------------------------------------------------------------
+    echo Building Windows CE Shunt Library and Tool Chain
+    echo -----------------------------------------------------------------------------
+
+    ac_exeext=.exe
+
+    echo -n "#define TOPSRCDIR \"" > $srcdir/build/wince/tools/topsrcdir.h
+    echo `cd "$_topsrcdir" && pwd -W | tr '\n' '\"'` >> $srcdir/build/wince/tools/topsrcdir.h
+    make -C $srcdir/build/wince/tools
+    echo -----------------------------------------------------------------------------
+    ;;
+esac
+
+if test -n "$CROSS_COMPILE" && test "$target" != "$host"; then
+    echo "cross compiling from $host to $target"
+    cross_compiling=yes
+
+    _SAVE_CC="$CC"
+    _SAVE_CFLAGS="$CFLAGS"
+    _SAVE_LDFLAGS="$LDFLAGS"
+
+    AC_MSG_CHECKING([for host c compiler])
+    AC_CHECK_PROGS(HOST_CC, $HOST_CC gcc cc /usr/ucb/cc cl icc, "")
+    if test -z "$HOST_CC"; then
+        AC_MSG_ERROR([no acceptable c compiler found in \$PATH])
+    fi
+    AC_MSG_RESULT([$HOST_CC])
+    AC_MSG_CHECKING([for host c++ compiler])
+    AC_CHECK_PROGS(HOST_CXX, $HOST_CXX $CCC c++ g++ gcc CC cxx cc++ cl icc, "")
+    if test -z "$HOST_CXX"; then
+        AC_MSG_ERROR([no acceptable c++ compiler found in \$PATH])
+    fi
+    AC_MSG_RESULT([$HOST_CXX])
+
+    if test -z "$HOST_CFLAGS"; then
+        HOST_CFLAGS="$CFLAGS"
+    fi
+    if test -z "$HOST_CXXFLAGS"; then
+        HOST_CXXFLAGS="$CXXFLAGS"
+    fi
+    if test -z "$HOST_LDFLAGS"; then
+        HOST_LDFLAGS="$LDFLAGS"
+    fi
+    AC_CHECK_PROGS(HOST_RANLIB, $HOST_RANLIB ranlib, ranlib, :)
+    AC_CHECK_PROGS(HOST_AR, $HOST_AR ar, ar, :)
+    CC="$HOST_CC"
+    CFLAGS="$HOST_CFLAGS"
+    LDFLAGS="$HOST_LDFLAGS"
+
+    AC_MSG_CHECKING([whether the host c compiler ($HOST_CC $HOST_CFLAGS $HOST_LDFLAGS) works])
+    AC_TRY_COMPILE([], [return(0);], 
+	[ac_cv_prog_hostcc_works=1 AC_MSG_RESULT([yes])],
+	AC_MSG_ERROR([installation or configuration problem: host compiler $HOST_CC cannot create executables.]) )
+
+    CC="$HOST_CXX"
+    CFLAGS="$HOST_CXXFLAGS"
+
+    AC_MSG_CHECKING([whether the host c++ compiler ($HOST_CXX $HOST_CXXFLAGS $HOST_LDFLAGS) works])
+    AC_TRY_COMPILE([], [return(0);], 
+	[ac_cv_prog_hostcxx_works=1 AC_MSG_RESULT([yes])],
+	AC_MSG_ERROR([installation or configuration problem: host compiler $HOST_CXX cannot create executables.]) )
+    
+    CC=$_SAVE_CC
+    CFLAGS=$_SAVE_CFLAGS
+    LDFLAGS=$_SAVE_LDFLAGS
+
+    case "$build:$target" in
+      powerpc-apple-darwin8*:i?86-apple-darwin*)
+        dnl The Darwin cross compiler doesn't necessarily point itself at a
+        dnl root that has libraries for the proper architecture, it defaults
+        dnl to the system root.  The libraries in the system root on current
+        dnl versions of PPC OS X 10.4 aren't fat, so these target compiler
+        dnl checks will fail.  Fake a working SDK in that case.
+        _SAVE_CFLAGS=$CFLAGS
+        _SAVE_CXXFLAGS=$CXXLAGS
+        CFLAGS="-isysroot /Developer/SDKs/MacOSX10.4u.sdk $CFLAGS"
+        CXXFLAGS="-isysroot /Developer/SDKs/MacOSX10.4u.sdk $CXXFLAGS"
+        ;;
+    esac
+
+    AC_CHECK_PROGS(CC, $CC "${target_alias}-gcc" "${target}-gcc", :)
+    unset ac_cv_prog_CC
+    AC_PROG_CC
+    AC_CHECK_PROGS(CXX, $CXX "${target_alias}-g++" "${target}-g++", :)
+    unset ac_cv_prog_CXX
+    AC_PROG_CXX
+
+    case "$build:$target" in
+      powerpc-apple-darwin8*:i?86-apple-darwin*)
+        dnl Revert the changes made above.  From this point on, the target
+        dnl compiler will never be used without applying the SDK to CFLAGS
+        dnl (see --with-macos-sdk below).
+        CFLAGS=$_SAVE_CFLAGS
+        CXXFLAGS=$_SAVE_CXXFLAGS
+        ;;
+    esac
+
+    AC_CHECK_PROGS(RANLIB, $RANLIB "${target_alias}-ranlib" "${target}-ranlib", :)
+    AC_CHECK_PROGS(AR, $AR "${target_alias}-ar" "${target}-ar", :)
+    AC_PATH_PROGS(AS, $AS "${target_alias}-as" "${target}-as", :)
+    AC_CHECK_PROGS(LD, $LD "${target_alias}-ld" "${target}-ld", :)
+    AC_CHECK_PROGS(STRIP, $STRIP "${target_alias}-strip" "${target}-strip", :)
+    AC_CHECK_PROGS(WINDRES, $WINDRES "${target_alias}-windres" "${target}-windres", :)
+    AC_DEFINE(CROSS_COMPILE)
+else
+    AC_PROG_CC
+    AC_PROG_CXX
+    AC_PROG_RANLIB
+    AC_PATH_PROGS(AS, $AS as, $CC)
+    AC_CHECK_PROGS(AR, ar, :)
+    AC_CHECK_PROGS(LD, ld, :)
+    AC_CHECK_PROGS(STRIP, strip, :)
+    AC_CHECK_PROGS(WINDRES, windres, :)
+    if test -z "$HOST_CC"; then
+        HOST_CC="$CC"
+    fi
+    if test -z "$HOST_CFLAGS"; then
+        HOST_CFLAGS="$CFLAGS"
+    fi
+    if test -z "$HOST_CXX"; then
+        HOST_CXX="$CXX"
+    fi
+    if test -z "$HOST_CXXFLAGS"; then
+        HOST_CXXFLAGS="$CXXFLAGS"
+    fi
+    if test -z "$HOST_LDFLAGS"; then
+        HOST_LDFLAGS="$LDFLAGS"
+    fi
+    if test -z "$HOST_RANLIB"; then
+        HOST_RANLIB="$RANLIB"
+    fi
+    if test -z "$HOST_AR"; then
+       HOST_AR="$AR"
+    fi
+fi
+
+GNU_AS=
+GNU_LD=
+GNU_CC=
+GNU_CXX=
+CC_VERSION='N/A'
+CXX_VERSION='N/A'
+if test "$GCC" = "yes"; then
+    GNU_CC=1
+    CC_VERSION=`$CC -v 2>&1 | grep 'gcc version'`
+fi
+if test "$GXX" = "yes"; then
+    GNU_CXX=1
+    CXX_VERSION=`$CXX -v 2>&1 | grep 'gcc version'`
+fi
+if test "`echo | $AS -v 2>&1 | grep -c GNU`" != "0"; then
+    GNU_AS=1
+fi
+if test "`echo | $LD -v 2>&1 | grep -c GNU`" != "0"; then
+    GNU_LD=1
+fi
+if test "$GNU_CC"; then
+    if `$CC -print-prog-name=ld` -v 2>&1 | grep -c GNU >/dev/null; then
+        GCC_USE_GNU_LD=1
+    fi
+fi
+
+INTEL_CC=
+INTEL_CXX=
+if test "$GCC" = yes; then
+   if test "`$CC -help 2>&1 | grep -c 'Intel(R) C Compiler'`" != "0"; then
+     INTEL_CC=1
+   fi
+fi
+
+if test "$GXX" = yes; then
+   if test "`$CXX -help 2>&1 | grep -c 'Intel(R) C++ Compiler'`" != "0"; then
+     INTEL_CXX=1
+   fi
+fi
+
+dnl Special win32 checks
+dnl ========================================================
+case "$target" in
+*-wince)
+    WINVER=500
+    ;;
+*)
+    if test -n "$GNU_CC"; then  
+        WINVER=501
+    else    
+        WINVER=500
+    fi
+    ;;
+esac
+
+MOZ_ARG_WITH_STRING(windows-version,
+[  --with-windows-version=WINVER
+                          Minimum Windows version (WINVER) to support
+                              400: Windows 95
+                              500: Windows 2000
+                              501: Windows XP],
+  WINVER=$withval)
+
+case "$WINVER" in
+400|500|501)
+    ;;
+
+*)
+    AC_MSG_ERROR([Invalid value --with-windows-version, must be 400, 500 or 501]);
+    ;;
+
+esac
+
+case "$target" in
+*-cygwin*|*-mingw*|*-msvc*|*-mks*|*-wince)
+    if test "$GCC" != "yes"; then
+        # Check to see if we are really running in a msvc environemnt
+        _WIN32_MSVC=1
+        AC_CHECK_PROGS(MIDL, midl)
+
+        # Make sure compilers are valid
+        CFLAGS="$CFLAGS -TC -nologo"
+        CXXFLAGS="$CXXFLAGS -TP -nologo"
+        AC_LANG_SAVE
+        AC_LANG_C
+        AC_TRY_COMPILE([#include <stdio.h>],
+            [ printf("Hello World\n"); ],,
+            AC_MSG_ERROR([\$(CC) test failed.  You must have MS VC++ in your path to build.]) )
+
+        AC_LANG_CPLUSPLUS
+        AC_TRY_COMPILE([#include <new.h>],
+            [ unsigned *test = new unsigned(42); ],,
+            AC_MSG_ERROR([\$(CXX) test failed.  You must have MS VC++ in your path to build.]) )
+        AC_LANG_RESTORE
+        
+        changequote(,)
+        _MSVC_VER_FILTER='s|.* ([0-9]+\.[0-9]+\.[0-9]+(\.[0-9]+)?).*|\1|p'
+        changequote([,])
+        
+        # Determine compiler version
+        CC_VERSION=`"${CC}" -v 2>&1 | sed -nre "$_MSVC_VER_FILTER"`
+        _CC_MAJOR_VERSION=`echo ${CC_VERSION} | $AWK -F\. '{ print $1 }'`
+        _CC_MINOR_VERSION=`echo ${CC_VERSION} | $AWK -F\. '{ print $2 }'`
+        _CC_RELEASE=`echo ${CC_VERSION} | $AWK -F\. '{ print $3 }'`
+        _CC_BUILD=`echo ${CC_VERSION} | $AWK -F\. '{ print $4 }'`
+        _MSC_VER=${_CC_MAJOR_VERSION}${_CC_MINOR_VERSION}
+
+        CXX_VERSION=`"${CXX}" -v 2>&1 | sed -nre "$_MSVC_VER_FILTER"`
+        _CXX_MAJOR_VERSION=`echo ${CXX_VERSION} | $AWK -F\. '{ print $1 }'`
+
+        if test "$_CC_MAJOR_VERSION" != "$_CXX_MAJOR_VERSION"; then
+            AC_MSG_ERROR([The major versions of \$CC and \$CXX do not match.])
+        fi
+        if test "$_CC_MAJOR_VERSION" = "12"; then
+            _CC_SUITE=6
+        elif test "$_CC_MAJOR_VERSION" = "13"; then
+            _CC_SUITE=7
+        elif test "$_CC_MAJOR_VERSION" = "14"; then
+            _CC_SUITE=8
+            CXXFLAGS="$CXXFLAGS -Zc:wchar_t-"
+            dnl -DYNAMICBASE is only supported on VC8SP1 or newer,
+            dnl so be very specific here!
+            dnl VC8 is 14.00.50727.42, VC8SP1 is 14.00.50727.762
+            if test $_CC_RELEASE -gt 50727; then
+               _USE_DYNAMICBASE=1
+            elif test $_CC_BUILD -ge 762; then
+               _USE_DYNAMICBASE=1
+            fi
+            AC_DEFINE(_CRT_SECURE_NO_DEPRECATE)
+            AC_DEFINE(_CRT_NONSTDC_NO_DEPRECATE)
+        elif test "$_CC_MAJOR_VERSION" = "15"; then
+            _CC_SUITE=9
+            CXXFLAGS="$CXXFLAGS -Zc:wchar_t-"
+            LDFLAGS="$LDFLAGS -MANIFESTUAC:NO"
+            _USE_DYNAMICBASE=1
+            AC_DEFINE(_CRT_SECURE_NO_WARNINGS)
+            AC_DEFINE(_CRT_NONSTDC_NO_WARNINGS)
+        else
+            AC_MSG_ERROR([This version of the MSVC compiler, $CC_VERSION , is unsupported.])
+        fi
+
+        _MOZ_RTTI_FLAGS_ON='-GR'
+        _MOZ_RTTI_FLAGS_OFF='-GR-'
+        _MOZ_EXCEPTIONS_FLAGS_ON='-EHsc'
+        _MOZ_EXCEPTIONS_FLAGS_OFF=''
+
+        if test -n "$WIN32_REDIST_DIR"; then
+            WIN32_REDIST_DIR=`cd "$WIN32_REDIST_DIR" && pwd`
+        fi
+	
+        # bug #249782
+        # ensure that mt.exe is Microsoft (R) Manifest Tool and not magnetic tape manipulation utility (or something else)
+        if test "$_CC_SUITE" -ge "8"; then
+                changequote(,)
+                _MSMT_VER_FILTER='s|.* \([0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\).*|\1|p'
+                changequote([,])
+
+                MSMT_TOOL=`mt 2>&1|grep 'Microsoft (R) Manifest Tool'`
+                if test -n "$MSMT_TOOL"; then
+                        MSMANIFEST_TOOL_VERSION=`echo ${MSMT_TOOL}|sed -ne "$_MSMT_VER_FILTER"`
+                        if test -z "$MSMANIFEST_TOOL_VERSION"; then
+                                AC_MSG_WARN([Unknown version of the Microsoft (R) Manifest Tool.])
+                        fi
+                        MSMANIFEST_TOOL=1
+                        unset MSMT_TOOL
+                else
+                        AC_MSG_ERROR([Microsoft (R) Manifest Tool must be in your \$PATH.])
+                fi
+        fi
+
+        # Check linker version
+        _LD_FULL_VERSION=`"${LD}" -v 2>&1 | sed -nre "$_MSVC_VER_FILTER"`
+        _LD_MAJOR_VERSION=`echo ${_LD_FULL_VERSION} | $AWK -F\. '{ print $1 }'`
+        if test "$_LD_MAJOR_VERSION" != "$_CC_SUITE"; then
+            AC_MSG_ERROR([The linker major version, $_LD_FULL_VERSION,  does not match the compiler suite version, $_CC_SUITE.])
+        fi
+        INCREMENTAL_LINKER=1
+
+        # Check midl version
+        _MIDL_FULL_VERSION=`"${MIDL}" -v 2>&1 | sed -nre "$_MSVC_VER_FILTER"`
+        _MIDL_MAJOR_VERSION=`echo ${_MIDL_FULL_VERSION} | $AWK -F\. '{ print $1 }'`
+        _MIDL_MINOR_VERSION=`echo ${_MIDL_FULL_VERSION} | $AWK -F\. '{ print $2 }'`
+        _MIDL_REV_VERSION=`echo ${_MIDL_FULL_VERSION} | $AWK -F\. '{ print $3 }'`
+         # Add flags if necessary
+         AC_MSG_CHECKING([for midl flags])
+         if test \( "$_MIDL_MAJOR_VERSION" -gt "6" \) -o \( "$_MIDL_MAJOR_VERSION" = "6" -a "$_MIDL_MINOR_VERSION" -gt "0" \) -o \( "$_MIDL_MAJOR_VERSION" = "6" -a "$_MIDL_MINOR_VERSION" = "00" -a "$_MIDL_REV_VERSION" -gt "359" \); then
+             # Starting with MIDL version 6.0.359, the MIDL compiler
+             # generates /Oicf /robust stubs by default, which is not
+             # compatible with versions of Windows older than Win2k.
+             # This switches us back to the old behaviour. When we drop
+             # support for Windows older than Win2k, we should remove
+             # this.
+             MIDL_FLAGS="${MIDL_FLAGS} -no_robust"
+             AC_MSG_RESULT([need -no_robust])
+         else
+             MIDL_FLAGS="${MIDL_FLAGS}"
+             AC_MSG_RESULT([none needed])
+        fi
+        
+        unset _MSVC_VER_FILTER
+        
+    else
+        # Check w32api version
+        _W32API_MAJOR_VERSION=`echo $W32API_VERSION | $AWK -F\. '{ print $1 }'`
+        _W32API_MINOR_VERSION=`echo $W32API_VERSION | $AWK -F\. '{ print $2 }'`
+        AC_MSG_CHECKING([for w32api version >= $W32API_VERSION])
+        AC_TRY_COMPILE([#include <w32api.h>],
+            #if (__W32API_MAJOR_VERSION < $_W32API_MAJOR_VERSION) || \
+                (__W32API_MAJOR_VERSION == $_W32API_MAJOR_VERSION && \
+                 __W32API_MINOR_VERSION < $_W32API_MINOR_VERSION)
+                #error "test failed."
+            #endif
+            , [ res=yes ], [ res=no ])
+        AC_MSG_RESULT([$res])
+        if test "$res" != "yes"; then
+            AC_MSG_ERROR([w32api version $W32API_VERSION or higher required.])
+        fi
+        # Check windres version
+        AC_MSG_CHECKING([for windres version >= $WINDRES_VERSION])
+        _WINDRES_VERSION=`${WINDRES} --version 2>&1 | grep -i windres 2>/dev/null | $AWK '{ print $3 }'`
+        AC_MSG_RESULT([$_WINDRES_VERSION])
+        _WINDRES_MAJOR_VERSION=`echo $_WINDRES_VERSION | $AWK -F\. '{ print $1 }'`
+        _WINDRES_MINOR_VERSION=`echo $_WINDRES_VERSION | $AWK -F\. '{ print $2 }'`
+        _WINDRES_RELEASE_VERSION=`echo $_WINDRES_VERSION | $AWK -F\. '{ print $3 }'`
+        WINDRES_MAJOR_VERSION=`echo $WINDRES_VERSION | $AWK -F\. '{ print $1 }'`
+        WINDRES_MINOR_VERSION=`echo $WINDRES_VERSION | $AWK -F\. '{ print $2 }'`
+        WINDRES_RELEASE_VERSION=`echo $WINDRES_VERSION | $AWK -F\. '{ print $3 }'`
+        if test "$_WINDRES_MAJOR_VERSION" -lt "$WINDRES_MAJOR_VERSION" -o \
+                "$_WINDRES_MAJOR_VERSION" -eq "$WINDRES_MAJOR_VERSION" -a \
+                "$_WINDRES_MINOR_VERSION" -lt "$WINDRES_MINOR_VERSION" -o \
+                "$_WINDRES_MAJOR_VERSION" -eq "$WINDRES_MAJOR_VERSION" -a \
+                "$_WINDRES_MINOR_VERSION" -eq "$WINDRES_MINOR_VERSION" -a \
+                "$_WINDRES_RELEASE_VERSION" -lt "$WINDRES_RELEASE_VERSION"
+        then
+            AC_MSG_ERROR([windres version $WINDRES_VERSION or higher is required to build.])
+        fi
+    fi # !GNU_CC
+
+    AC_DEFINE_UNQUOTED(WINVER,0x$WINVER)
+    AC_DEFINE_UNQUOTED(_WIN32_WINNT,0x$WINVER)
+    # Require OS features provided by IE 5.0
+    AC_DEFINE_UNQUOTED(_WIN32_IE,0x0500)
+    ;;
+esac
+
+dnl Test breaks icc on OS/2 && MSVC
+if test "$CC" != "icc" -a -z "$_WIN32_MSVC"; then
+    AC_PROG_CC_C_O
+    if grep "NO_MINUS_C_MINUS_O 1" ./confdefs.h >/dev/null; then
+        USING_HCC=1
+        _OLDCC=$CC
+        _OLDCXX=$CXX
+        CC="${srcdir}/build/hcc '$CC'"
+        CXX="${srcdir}/build/hcpp '$CXX'"
+    fi
+fi
+
+AC_PROG_CPP
+AC_PROG_CXXCPP
+
+if test -n "$_WIN32_MSVC"; then
+    SKIP_PATH_CHECKS=1
+    SKIP_COMPILER_CHECKS=1
+    SKIP_LIBRARY_CHECKS=1
+fi
+
+fi # COMPILE_ENVIRONMENT
+
+AC_SUBST(MIDL_FLAGS)
+AC_SUBST(_MSC_VER)
+
+AC_SUBST(GNU_AS)
+AC_SUBST(GNU_LD)
+AC_SUBST(GNU_CC)
+AC_SUBST(GNU_CXX)
+AC_SUBST(INTEL_CC)
+AC_SUBST(INTEL_CXX)
+
+dnl ========================================================
+dnl Checks for programs.
+dnl ========================================================
+AC_PROG_INSTALL
+AC_PROG_LN_S
+AC_PATH_PROGS(PERL, $PERL perl5 perl )
+if test -z "$PERL" || test "$PERL" = ":"; then
+    AC_MSG_ERROR([perl not found in \$PATH])
+fi
+
+if test -z "$TINDERBOX_SKIP_PERL_VERSION_CHECK"; then
+AC_MSG_CHECKING([for minimum required perl version >= $PERL_VERSION])
+_perl_version=`PERL_VERSION=$PERL_VERSION $PERL -e 'print "$]"; if ($] >= $ENV{PERL_VERSION}) { exit(0); } else { exit(1); }' 2>&5`
+_perl_res=$?
+AC_MSG_RESULT([$_perl_version])
+
+if test "$_perl_res" != 0; then
+    AC_MSG_ERROR([Perl $PERL_VERSION or higher is required.])
+fi
+fi
+
+AC_MSG_CHECKING([for full perl installation])
+_perl_archlib=`$PERL -e 'use Config; if ( -d $Config{archlib} ) { exit(0); } else { exit(1); }' 2>&5`
+_perl_res=$?
+if test "$_perl_res" != 0; then
+    AC_MSG_RESULT([no])
+    AC_MSG_ERROR([Cannot find Config.pm or \$Config{archlib}.  A full perl installation is required.])
+else
+    AC_MSG_RESULT([yes])    
+fi
+
+AC_PATH_PROGS(PYTHON, $PYTHON python)
+if test -z "$PYTHON"; then
+    AC_MSG_ERROR([python was not found in \$PATH])
+fi
+echo PYTHON="$PYTHON"
+
+AC_PATH_PROGS(NSINSTALL_BIN, nsinstall )
+if test -z "$COMPILE_ENVIRONMENT"; then
+if test -z "$NSINSTALL_BIN" || test "$NSINSTALL_BIN" = ":"; then
+    NSINSTALL_BIN='$(PYTHON) $(topsrcdir)/config/nsinstall.py'
+fi
+fi
+AC_SUBST(NSINSTALL_BIN)
+
+AC_PATH_PROG(DOXYGEN, doxygen, :)
+AC_PATH_PROG(WHOAMI, whoami, :)
+AC_PATH_PROG(AUTOCONF, autoconf, :)
+AC_PATH_PROG(UNZIP, unzip, :)
+AC_PATH_PROGS(ZIP, zip)
+if test -z "$ZIP" || test "$ZIP" = ":"; then
+    AC_MSG_ERROR([zip not found in \$PATH])
+fi
+AC_PATH_PROG(SYSTEM_MAKEDEPEND, makedepend)
+AC_PATH_PROG(XARGS, xargs)
+if test -z "$XARGS" || test "$XARGS" = ":"; then
+    AC_MSG_ERROR([xargs not found in \$PATH .])
+fi
+
+if test "$COMPILE_ENVIRONMENT"; then
+
+dnl ========================================================
+dnl = Mac OS X toolchain support
+dnl ========================================================
+
+case "$target_os" in
+darwin*)
+    dnl Current known valid versions for GCC_VERSION are 2.95.2 3.1 3.3 4.0.
+    dnl 4.0 identifies itself as 4.0.x, so strip the decidecimal for
+    dnl the environment and includedir purposes (when using an SDK, below),
+    dnl but remember the full version number for the libdir (SDK).
+    changequote(,)
+    GCC_VERSION_FULL=`echo $CXX_VERSION | $PERL -pe 's/^.*gcc version ([^ ]*).*/$1/'`
+    GCC_VERSION=`echo $GCC_VERSION_FULL | $PERL -pe '(split(/\./))[0]>=4&&s/(^\d*\.\d*).*/$1/;'`
+    changequote([,])
+    if test "$GCC_VERSION_FULL" = "4.0.0" ; then
+        dnl Bug 280479, but this keeps popping up in bug 292530 too because
+        dnl 4.0.0/4061 is the default compiler in Tiger.
+        changequote(,)
+        GCC_BUILD=`echo $CXX_VERSION | $PERL -pe 's/^.*build ([^ )]*).*/$1/'`
+        changequote([,])
+        if test "$GCC_BUILD" = "4061" ; then
+            AC_MSG_ERROR([You are attempting to use Apple gcc 4.0 build 4061.
+This compiler was supplied with Xcode 2.0, and contains bugs that prevent it
+from building Mozilla. Upgrade to Xcode 2.1 or later.])
+        fi
+    fi
+
+    dnl xcodebuild needs GCC_VERSION defined in the environment, since it
+    dnl doesn't respect the CC/CXX setting.  With GCC_VERSION set, it will use
+    dnl /usr/bin/g(cc|++)-$GCC_VERSION.
+    AC_PATH_PROGS(PBBUILD, pbbuild xcodebuild pbxbuild)
+
+    case "$PBBUILD" in
+      *xcodebuild*)
+        changequote(,)
+        XCODEBUILD_VERSION=`$PBBUILD -version 2>/dev/null | xargs | sed -e 's/.*DevToolsCore-\([0-9]*\).*/\1/'`
+        changequote([,])
+        if test -n "$XCODEBUILD_VERSION" && test "$XCODEBUILD_VERSION" -ge 620 ; then
+          HAS_XCODE_2_1=1;
+        fi
+      ;;
+    esac
+
+    dnl sdp was formerly in /Developer/Tools.  As of Mac OS X 10.4 (Darwin 8),
+    dnl it has moved into /usr/bin.
+    AC_PATH_PROG(SDP, sdp, :, [$PATH:/usr/bin:/Developer/Tools])
+    ;;
+esac
+
+AC_SUBST(GCC_VERSION)
+AC_SUBST(XCODEBUILD_VERSION)
+AC_SUBST(HAS_XCODE_2_1)
+
+dnl The universal machinery sets UNIVERSAL_BINARY to inform packager.mk
+dnl that a universal binary is being produced.
+AC_SUBST(UNIVERSAL_BINARY)
+
+dnl ========================================================
+dnl Check for MacOS deployment target version
+dnl ========================================================
+
+MOZ_ARG_ENABLE_STRING(macos-target,
+                      [  --enable-macos-target=VER (default=10.4)
+                          Set the minimum MacOS version needed at runtime],
+                      [_MACOSX_DEPLOYMENT_TARGET=$enableval])
+
+case "$target" in
+*-darwin*)
+    if test -n "$_MACOSX_DEPLOYMENT_TARGET" ; then
+        dnl Use the specified value
+        export MACOSX_DEPLOYMENT_TARGET=$_MACOSX_DEPLOYMENT_TARGET
+        AC_DEFINE_UNQUOTED(__ENVIRONMENT_MAC_OS_X_VERION_MIN_REQUIRED__,$_MACOSX_DEPLOYMENT_TARGET)
+    elif test -z "$MACOSX_DEPLOYMENT_TARGET" ; then
+        dnl No value specified on the command line or in the environment,
+        dnl use the lesser of the application's minimum or the architecture's
+        dnl minimum.
+        export MACOSX_DEPLOYMENT_TARGET=10.4
+    fi
+    ;;
+esac
+
+AC_SUBST(MACOSX_DEPLOYMENT_TARGET)
+
+dnl ========================================================
+dnl = Mac OS X SDK support
+dnl ========================================================
+MACOS_SDK_DIR=
+NEXT_ROOT=
+MOZ_ARG_WITH_STRING(macos-sdk,
+[  --with-macos-sdk=dir   Location of platform SDK to use (Mac OS X only)],
+    MACOS_SDK_DIR=$withval)
+
+dnl MACOS_SDK_DIR will be set to the SDK location whenever one is in use.
+dnl NEXT_ROOT will be set and exported only if it's needed.
+AC_SUBST(MACOS_SDK_DIR)
+AC_SUBST(NEXT_ROOT)
+
+if test "$MACOS_SDK_DIR"; then
+  dnl Sync this section with the ones in NSPR and NSS.
+  dnl Changes to the cross environment here need to be accounted for in
+  dnl the libIDL checks (below) and xpidl build.
+
+  if test ! -d "$MACOS_SDK_DIR"; then
+    AC_MSG_ERROR([SDK not found.  When using --with-macos-sdk, you must
+specify a valid SDK.  SDKs are installed when the optional cross-development
+tools are selected during the Xcode/Developer Tools installation.])
+  fi
+
+  GCC_VERSION_MAJOR=`echo $GCC_VERSION_FULL | $PERL -pe 's/(^\d*).*/$1/;'`
+  if test "$GCC_VERSION_MAJOR" -lt "4" ; then
+    SDK_C_INCLUDE="-isystem ${MACOS_SDK_DIR}/usr/include/gcc/darwin/${GCC_VERSION} -isystem ${MACOS_SDK_DIR}/usr/include -F${MACOS_SDK_DIR}/System/Library/Frameworks"
+    if test -d "${MACOS_SDK_DIR}/Library/Frameworks" ; then
+      SDK_C_INCLUDE="$SDK_C_INCLUDE -F${MACOS_SDK_DIR}/Library/Frameworks"
+    fi
+    SDK_CXX_INCLUDE="-I${MACOS_SDK_DIR}/usr/include/gcc/darwin/${GCC_VERSION}/c++ -I${MACOS_SDK_DIR}/usr/include/gcc/darwin/${GCC_VERSION}/c++/ppc-darwin -I${MACOS_SDK_DIR}/usr/include/gcc/darwin/${GCC_VERSION}/c++/backward"
+
+    CFLAGS="$CFLAGS -nostdinc ${SDK_C_INCLUDE}"
+    CXXFLAGS="$CXXFLAGS -nostdinc -nostdinc++ ${SDK_CXX_INCLUDE} ${SDK_C_INCLUDE}"
+
+    dnl CPP/CXXCPP needs to be set for AC_CHECK_HEADER.
+    CPP="$CPP -nostdinc ${SDK_C_INCLUDE}"
+    CXXCPP="$CXXCPP -nostdinc -nostdinc++ ${SDK_CXX_INCLUDE} ${SDK_C_INCLUDE}"
+
+    dnl ld support for -syslibroot is compiler-agnostic, but only available
+    dnl on Tiger.  Although it's possible to switch on the build host's
+    dnl OS release to use ld -syslibroot when available, ld -syslibroot will
+    dnl cause warnings as long as NEXT_ROOT is set.  NEXT_ROOT should be
+    dnl set because both the compiler and linker use it.
+    LIBS="-L${MACOS_SDK_DIR}/usr/lib/gcc/darwin -L${MACOS_SDK_DIR}/usr/lib/gcc/darwin/${GCC_VERSION_FULL} -L${MACOS_SDK_DIR}/usr/lib $LIBS"
+    export NEXT_ROOT=$MACOS_SDK_DIR
+
+    if test -n "$CROSS_COMPILE" ; then
+      dnl NEXT_ROOT will be in the environment, but it shouldn't be set for
+      dnl the build host.  HOST_CXX is presently unused.
+      HOST_CC="NEXT_ROOT= $HOST_CC"
+      HOST_CXX="NEXT_ROOT= $HOST_CXX"
+    fi
+  else
+    dnl gcc >= 4.0 uses different paths than above, but knows how to find
+    dnl them itself.
+    CFLAGS="$CFLAGS -isysroot ${MACOS_SDK_DIR}"
+    CXXFLAGS="$CXXFLAGS -isysroot ${MACOS_SDK_DIR}"
+
+    dnl CPP/CXXCPP needs to be set for AC_CHECK_HEADER.
+    CPP="$CPP -isysroot ${MACOS_SDK_DIR}"
+    CXXCPP="$CXXCPP -isysroot ${MACOS_SDK_DIR}"
+
+    if test "$GCC_VERSION_FULL" = "4.0.0" ; then
+      dnl If gcc >= 4.0, we're guaranteed to be on Tiger, which has an ld
+      dnl that supports -syslibroot.  Don't set NEXT_ROOT because it will
+      dnl be ignored and cause warnings when -syslibroot is specified.
+      dnl gcc 4.0.1 will pass -syslibroot to ld automatically based on
+      dnl the -isysroot it receives, so this is only needed with 4.0.0.
+      LDFLAGS="$LDFLAGS -Wl,-syslibroot,${MACOS_SDK_DIR}"
+    fi
+  fi
+
+  AC_LANG_SAVE
+  AC_MSG_CHECKING([for valid compiler/Mac OS X SDK combination])
+  AC_LANG_CPLUSPLUS
+  AC_TRY_COMPILE([#include <new>
+                 int main() { return 0; }],
+   result=yes,
+   result=no)
+  AC_LANG_RESTORE
+  AC_MSG_RESULT($result)
+
+  if test "$result" = "no" ; then
+    AC_MSG_ERROR([The selected compiler and Mac OS X SDK are incompatible.])
+  fi
+fi
+
+fi # COMPILE_ENVIRONMENT
+
+dnl Be sure the make we use is GNU make.
+dnl on win32, gmake.exe is the generally the wrong version
+case "$host_os" in
+cygwin*|mingw*|mks*|msvc*)
+    AC_PATH_PROGS(MAKE, $MAKE make gmake, :)
+    ;;
+*)
+    AC_PATH_PROGS(MAKE, $MAKE gmake make, :)
+    ;;
+esac
+_make_try=`$MAKE --version 2>/dev/null | grep GNU`
+if test ! "$_make_try"
+then
+	echo
+	echo "*** $MAKE is not GNU Make.  You will not be able to build Mozilla without GNU Make."
+	echo
+	exit 1
+fi
+dnl Now exit if version if < MAKE_VERSION
+rm -f dummy.mk
+echo 'all: ; @echo $(MAKE_VERSION)' > dummy.mk
+_make_vers=`$MAKE --no-print-directory -f dummy.mk all 2>/dev/null`
+rm -f dummy.mk
+_MAKE_MAJOR_VERSION=`echo $_make_vers | $AWK -F\. '{ print $1 }'`
+_MAKE_MINOR_VERSION=`echo $_make_vers | $AWK -F\. '{ print $2 }'`
+MAKE_MAJOR_VERSION=`echo $MAKE_VERSION | $AWK -F\. '{ print $1 }'`
+MAKE_MINOR_VERSION=`echo $MAKE_VERSION | $AWK -F\. '{ print $2 }'`
+if test "$_MAKE_MAJOR_VERSION" -lt "$MAKE_MAJOR_VERSION" || \
+   test "$_MAKE_MAJOR_VERSION" = "$MAKE_MAJOR_VERSION" -a \
+        "$_MAKE_MINOR_VERSION" -lt "$MAKE_MINOR_VERSION"; then
+   AC_MSG_ERROR([GNU Make $MAKE_VERSION or higher is required to build Mozilla.])
+fi
+AC_SUBST(MAKE)
+
+if test "$COMPILE_ENVIRONMENT"; then
+
+AC_PATH_XTRA
+
+dnl Check in X11 include directory too.
+if test "$no_x" != "yes"; then
+    CPPFLAGS="$CPPFLAGS $X_CFLAGS"
+fi
+
+XCFLAGS="$X_CFLAGS"
+
+fi # COMPILE_ENVIRONMENT
+
+dnl ========================================================
+dnl set the defaults first
+dnl ========================================================
+AS_BIN=$AS
+AR_FLAGS='cr $@'
+AR_LIST='$(AR) t'
+AR_EXTRACT='$(AR) x'
+AR_DELETE='$(AR) d'
+AS='$(CC)'
+AS_DASH_C_FLAG='-c'
+DLL_PREFIX=lib
+LIB_PREFIX=lib
+DLL_SUFFIX=.so
+OBJ_SUFFIX=o
+LIB_SUFFIX=a
+ASM_SUFFIX=s
+IMPORT_LIB_SUFFIX=
+TARGET_MD_ARCH=unix
+DIRENT_INO=d_ino
+CYGWIN_WRAPPER=
+WIN_TOP_SRC=
+MOZ_USER_DIR=".mozilla"
+HOST_AR='$(AR)'
+HOST_AR_FLAGS='$(AR_FLAGS)'
+
+MOZ_JS_LIBS='-L$(libdir) -lmozjs'
+MOZ_FIX_LINK_PATHS='-Wl,-rpath-link,$(LIBXUL_DIST)/bin -Wl,-rpath-link,$(PREFIX)/lib'
+
+MOZ_COMPONENT_NSPR_LIBS='-L$(LIBXUL_DIST)/bin $(NSPR_LIBS)'
+MOZ_XPCOM_OBSOLETE_LIBS='-L$(LIBXUL_DIST)/lib -lxpcom_compat'
+
+USE_DEPENDENT_LIBS=1
+
+_PLATFORM_DEFAULT_TOOLKIT=cairo-gtk2
+MOZ_GFX_TOOLKIT='$(MOZ_WIDGET_TOOLKIT)'
+
+MOZ_ENABLE_POSTSCRIPT=1 
+
+if test -n "$CROSS_COMPILE"; then
+    OS_TARGET="${target_os}"
+    OS_ARCH=`echo $target_os | sed -e 's|/|_|g'`
+    OS_RELEASE=
+    case "${target_os}" in
+        linux*)       OS_ARCH=Linux OS_TARGET=Linux ;;
+        kfreebsd*-gnu) OS_ARCH=GNU_kFreeBSD OS_TARGET=GNU_kFreeBSD ;;
+        solaris*)     OS_ARCH=SunOS OS_RELEASE=5 ;;
+        mingw*)       OS_ARCH=WINNT ;;
+        wince*)       OS_ARCH=WINCE ;;
+        darwin*)      OS_ARCH=Darwin OS_TARGET=Darwin ;;
+    esac
+else
+    OS_TARGET=`uname -s`
+    OS_ARCH=`uname -s | sed -e 's|/|_|g'`
+    OS_RELEASE=`uname -r`
+fi
+
+# Before this used `uname -m` when not cross compiling
+# but that breaks when you have a 64 bit kernel with a 32 bit userland.
+OS_TEST="${target_cpu}"
+
+_COMPILER_PREFIX=
+
+HOST_OS_ARCH=`echo $host_os | sed -e 's|/|_|g'`
+
+#######################################################################
+# Master "Core Components" macros for getting the OS target           #
+#######################################################################
+
+#
+# Note: OS_TARGET should be specified on the command line for gmake.
+# When OS_TARGET=WIN95 is specified, then a Windows 95 target is built.
+# The difference between the Win95 target and the WinNT target is that
+# the WinNT target uses Windows NT specific features not available
+# in Windows 95. The Win95 target will run on Windows NT, but (supposedly)
+# at lesser performance (the Win95 target uses threads; the WinNT target
+# uses fibers).
+#
+# If OS_TARGET is not specified, it defaults to $(OS_ARCH), i.e., no
+# cross-compilation.
+#
+
+#
+# The following hack allows one to build on a WIN95 machine (as if
+# s/he were cross-compiling on a WINNT host for a WIN95 target).
+# It also accomodates for MKS's uname.exe.  If you never intend
+# to do development on a WIN95 machine, you don't need this hack.
+#
+case "$OS_ARCH" in
+WIN95)
+    OS_ARCH=WINNT
+    OS_TARGET=WIN95
+    ;;
+Windows_95)
+    OS_ARCH=Windows_NT
+    OS_TARGET=WIN95
+    ;;
+Windows_98)
+    OS_ARCH=Windows_NT
+    OS_TARGET=WIN95
+    ;;
+CYGWIN_9*|CYGWIN_ME*)
+    OS_ARCH='CYGWIN_NT-4.0'
+    OS_TARGET=WIN95
+    ;;
+esac
+
+#
+# Define and override various archtecture-specific variables, including
+# HOST_OS_ARCH
+# OS_ARCH
+# OS_TEST
+# OS_TARGET
+# OS_RELEASE
+# OS_MINOR_RELEASE
+#
+
+case "$HOST_OS_ARCH" in
+cygwin*|mingw*|mks*|msvc*)
+    HOST_OS_ARCH=WINNT
+    ;;
+linux*)
+    HOST_OS_ARCH=Linux
+    ;;
+solaris*)
+    HOST_OS_ARCH=SunOS
+    ;;
+BSD_386)
+    HOST_OS_ARCH=BSD
+    ;;
+dgux)
+    HOST_OS_ARCH=DGUX
+    ;;
+IRIX64)
+    HOST_OS_ARCH=IRIX
+    ;;
+UNIX_SV)
+    if "`cat /etc/bcheckrc | grep -c NCR 2>/dev/null`" != "0"; then
+        HOST_OS_ARCH=NCR
+    else
+        HOST_OS_ARCH=UNIXWARE
+    fi
+    ;;
+ncr)
+    HOST_OS_ARCH=NCR
+    ;;
+UNIX_SYSTEM_V)
+    HOST_OS_ARCH=NEC
+    ;;
+OSF1)
+    ;;
+*OpenVMS*)
+    HOST_OS_ARCH=OpenVMS
+    ;;
+OS_2)
+    HOST_OS_ARCH=OS2
+    ;;
+QNX)
+    ;;
+SCO_SV)
+    HOST_OS_ARCH=SCOOS
+    ;;
+SINIX-N | SINIX-Y | SINIX-Z |ReliantUNIX-M)
+    HOST_OS_ARCH=SINIX
+    ;;
+UnixWare)
+    HOST_OS_ARCH=UNIXWARE
+    ;;
+esac
+
+case "$OS_ARCH" in
+WINNT)
+    OS_TEST=`uname -p`
+    ;;
+Windows_NT)
+#
+# If uname -s returns "Windows_NT", we assume that we are using
+# the uname.exe in MKS toolkit.
+#
+# The -r option of MKS uname only returns the major version number.
+# So we need to use its -v option to get the minor version number.
+# Moreover, it doesn't have the -p option, so we need to use uname -m.
+#
+    OS_ARCH=WINNT
+    OS_TARGET=WINNT
+    OS_MINOR_RELEASE=`uname -v`
+    if test "$OS_MINOR_RELEASE" = "00"; then
+        OS_MINOR_RELEASE=0
+    fi
+    OS_RELEASE="${OS_RELEASE}.${OS_MINOR_RELEASE}"
+    ;;
+CYGWIN32_NT|CYGWIN_NT*|MINGW*_NT*)
+#
+# If uname -s returns "CYGWIN_NT-4.0", we assume that we are using
+# the uname.exe in the Cygwin tools.
+# Prior to the Beta 20 release, Cygwin was called GNU-Win32.
+# If uname -s returns "CYGWIN32/NT", we assume that we are using
+# the uname.exe in the GNU-Win32 tools.
+# If uname -s returns MINGW32_NT-5.1, we assume that we are using
+# the uname.exe in the MSYS tools.
+#
+    OS_RELEASE=`expr $OS_ARCH : '.*NT-\(.*\)'`
+    OS_ARCH=WINNT
+    OS_TARGET=WINNT
+    ;;
+AIX)
+    OS_RELEASE=`uname -v`.`uname -r`
+    OS_TEST=${target_cpu}
+    ;;
+BSD_386)
+    OS_ARCH=BSD
+    ;;
+dgux)
+    OS_ARCH=DGUX
+    ;;
+IRIX64)
+    OS_ARCH=IRIX
+    ;;
+UNIX_SV)
+    if "`cat /etc/bcheckrc | grep -c NCR 2>/dev/null`" != "0"; then
+        OS_ARCH=NCR
+    else
+        OS_ARCH=UNIXWARE
+        OS_RELEASE=`uname -v`
+    fi
+    ;;
+ncr)
+    OS_ARCH=NCR
+    ;;
+UNIX_SYSTEM_V)
+    OS_ARCH=NEC
+    ;;
+OSF1)
+    case `uname -v` in
+    148)
+        OS_RELEASE=V3.2C
+        ;;
+    564)
+        OS_RELEASE=V4.0B
+        ;;
+    878)
+        OS_RELEASE=V4.0D
+        ;;
+    esac
+    ;;
+*OpenVMS*)
+    OS_ARCH=OpenVMS
+    OS_RELEASE=`uname -v`
+    OS_TEST=`uname -p`
+    ;;
+OS_2)
+    OS_ARCH=OS2
+    OS_TARGET=OS2
+    OS_RELEASE=`uname -v`
+    ;;
+QNX)
+    if test "$OS_TARGET" != "NTO"; then
+        changequote(,)
+        OS_RELEASE=`uname -v | sed 's/^\([0-9]\)\([0-9]*\)$/\1.\2/'`
+        changequote([,])
+    fi
+    OS_TEST=x86
+    ;;
+SCO_SV)
+    OS_ARCH=SCOOS
+    OS_RELEASE=5.0
+    ;;
+SINIX-N | SINIX-Y | SINIX-Z |ReliantUNIX-M)
+    OS_ARCH=SINIX
+    OS_TEST=`uname -p`
+    ;;
+UnixWare)
+    OS_ARCH=UNIXWARE
+    OS_RELEASE=`uname -v`
+    ;;
+WINCE)
+    OS_ARCH=WINCE
+    OS_TARGET=WINCE
+    ;;
+Darwin)
+    case "${target_cpu}" in
+    powerpc*)
+        OS_TEST=ppc
+        ;;
+    i*86*)
+        OS_TEST=i386 
+        ;;
+    *)
+        if test -z "$CROSS_COMPILE" ; then
+            OS_TEST=`uname -p`
+        fi
+        ;;
+    esac
+    ;;
+esac
+
+if test "$OS_ARCH" = "NCR"; then
+    changequote(,)
+    OS_RELEASE=`awk '{print $3}' /etc/.relid | sed 's/^\([0-9]\)\(.\)\(..\)\(.*\)$/\2.\3/'`
+    changequote([,])
+fi
+
+# Only set CPU_ARCH if we recognize the value of OS_TEST
+
+case "$OS_TEST" in
+*86 | i86pc)
+    CPU_ARCH=x86
+    ;;
+
+powerpc* | ppc | rs6000)
+    CPU_ARCH=ppc
+    ;;
+
+Alpha | alpha | ALPHA)
+    CPU_ARCH=Alpha
+    ;;
+
+hppa* | parisc)
+    CPU_ARCH=hppa
+    ;;
+
+sun4u | sparc*)
+    CPU_ARCH=sparc
+    ;;
+
+x86_64 | ia64)
+    CPU_ARCH="$OS_TEST"
+    ;;
+esac
+
+if test -z "$OS_TARGET"; then
+    OS_TARGET=$OS_ARCH
+fi
+if test "$OS_TARGET" = "WIN95"; then
+    OS_RELEASE="4.0"
+fi
+OS_CONFIG="${OS_TARGET}${OS_RELEASE}"
+
+dnl ========================================================
+dnl GNU specific defaults
+dnl ========================================================
+if test "$GNU_CC"; then
+    # FIXME: Let us build with strict aliasing. bug 414641.
+    CFLAGS="$CFLAGS -fno-strict-aliasing"
+    MKSHLIB='$(CXX) $(CXXFLAGS) $(DSO_PIC_CFLAGS) $(DSO_LDOPTS) -Wl,-h,$@ -o $@'
+    MKCSHLIB='$(CC) $(CFLAGS) $(DSO_PIC_CFLAGS) $(DSO_LDOPTS) -Wl,-h,$@ -o $@'
+    DSO_LDOPTS='-shared'
+    if test "$GCC_USE_GNU_LD"; then
+        # Don't allow undefined symbols in libraries
+        DSO_LDOPTS="$DSO_LDOPTS -Wl,-z,defs"
+    fi
+    WARNINGS_AS_ERRORS='-Werror'
+    DSO_CFLAGS=''
+    DSO_PIC_CFLAGS='-fPIC'
+    ASFLAGS="$ASFLAGS -fPIC"
+    _MOZ_RTTI_FLAGS_ON=${_COMPILER_PREFIX}-frtti
+    _MOZ_RTTI_FLAGS_OFF=${_COMPILER_PREFIX}-fno-rtti
+    _MOZ_EXCEPTIONS_FLAGS_ON='-fhandle-exceptions'
+    _MOZ_EXCEPTIONS_FLAGS_OFF='-fno-handle-exceptions'
+
+    # Turn on GNU specific features
+    # -Wall - turn on all warnings
+    # -pedantic - make compiler warn about non-ANSI stuff, and
+    #             be a little bit stricter
+    # Warnings slamm took out for now (these were giving more noise than help):
+    # -Wbad-function-cast - warns when casting a function to a new return type
+    # -Wshadow - removed because it generates more noise than help --pete
+    _WARNINGS_CFLAGS="${_WARNINGS_CFLAGS} -Wall -W -Wno-unused -Wpointer-arith"
+    if test -z "$INTEL_CC"; then
+       # Don't use -Wcast-align with ICC
+       case "$CPU_ARCH" in
+           # And don't use it on hppa, ia64, sparc, since it's noisy there
+           hppa | ia64 | sparc)
+           ;;
+           *)
+        _WARNINGS_CFLAGS="${_WARNINGS_CFLAGS} -Wcast-align"
+           ;;
+       esac
+    fi
+
+    dnl Turn pedantic on but disable the warnings for long long
+    _PEDANTIC=1
+
+    if test -z "$INTEL_CC"; then
+      _IGNORE_LONG_LONG_WARNINGS=1
+      _WARNINGS_CFLAGS="${_WARNINGS_CFLAGS} -W"
+    else
+      _IGNORE_LONG_LONG_WARNINGS=
+    fi
+
+
+    _DEFINES_CFLAGS='-include $(DEPTH)/mozilla-config.h -DMOZILLA_CLIENT'
+    _USE_CPP_INCLUDE_FLAG=1
+else
+    MKSHLIB='$(LD) $(DSO_LDOPTS) -h $@ -o $@'
+    MKCSHLIB='$(LD) $(DSO_LDOPTS) -h $@ -o $@'
+
+    DSO_LDOPTS='-shared'
+    if test "$GNU_LD"; then
+        # Don't allow undefined symbols in libraries
+        DSO_LDOPTS="$DSO_LDOPTS -z defs"
+    fi
+
+    DSO_CFLAGS=''
+    DSO_PIC_CFLAGS='-KPIC'
+    _DEFINES_CFLAGS='$(ACDEFINES) -D_MOZILLA_CONFIG_H_ -DMOZILLA_CLIENT'
+fi
+
+if test "$GNU_CXX"; then
+    # FIXME: Let us build with strict aliasing. bug 414641.
+    CXXFLAGS="$CXXFLAGS -fno-strict-aliasing"
+    # Turn on GNU specific features
+    _WARNINGS_CXXFLAGS="${_WARNINGS_CXXFLAGS} -Wall -Wpointer-arith -Woverloaded-virtual -Wsynth -Wno-ctor-dtor-privacy -Wno-non-virtual-dtor"
+    if test -z "$INTEL_CC"; then
+       # Don't use -Wcast-align with ICC
+       case "$CPU_ARCH" in
+           # And don't use it on hppa, ia64, sparc, since it's noisy there
+           hppa | ia64 | sparc)
+           ;;
+           *)
+        _WARNINGS_CXXFLAGS="${_WARNINGS_CXXFLAGS} -Wcast-align"
+           ;;
+       esac
+    fi
+
+    _DEFINES_CXXFLAGS='-DMOZILLA_CLIENT -include $(DEPTH)/mozilla-config.h'
+    _USE_CPP_INCLUDE_FLAG=1
+
+    AC_CACHE_CHECK(whether the compiler supports -Wno-invalid-offsetof,
+                   ac_has_wno_invalid_offsetof,
+        [
+            AC_LANG_SAVE
+            AC_LANG_CPLUSPLUS
+            _SAVE_CXXFLAGS="$CXXFLAGS"
+            CXXFLAGS="$CXXFLAGS ${_COMPILER_PREFIX}-Wno-invalid-offsetof"
+            AC_TRY_COMPILE([],
+                           [return(0);],
+                           ac_has_wno_invalid_offsetof="yes",
+                           ac_has_wno_invalid_offsetof="no")
+            CXXFLAGS="$_SAVE_CXXFLAGS"
+            AC_LANG_RESTORE
+        ])
+    if test "$ac_has_wno_invalid_offsetof" = "yes"; then
+        _WARNINGS_CXXFLAGS="${_WARNINGS_CXXFLAGS} ${_COMPILER_PREFIX}-Wno-invalid-offsetof"
+    fi
+else
+    _DEFINES_CXXFLAGS='-DMOZILLA_CLIENT -D_MOZILLA_CONFIG_H_ $(ACDEFINES)'
+fi
+
+dnl gcc can come with its own linker so it is better to use the pass-thru calls
+dnl MKSHLIB_FORCE_ALL is used to force the linker to include all object
+dnl files present in an archive. MKSHLIB_UNFORCE_ALL reverts the linker to
+dnl normal behavior.
+dnl ========================================================
+MKSHLIB_FORCE_ALL=
+MKSHLIB_UNFORCE_ALL=
+
+if test "$COMPILE_ENVIRONMENT"; then
+if test "$GNU_CC"; then
+  AC_MSG_CHECKING(whether ld has archive extraction flags)
+  AC_CACHE_VAL(ac_cv_mkshlib_force_and_unforce,
+   [_SAVE_LDFLAGS=$LDFLAGS; _SAVE_LIBS=$LIBS
+    ac_cv_mkshlib_force_and_unforce="no"
+    exec 3<&0 <<LOOP_INPUT
+	force="-Wl,--whole-archive";   unforce="-Wl,--no-whole-archive"
+	force="-Wl,-z -Wl,allextract"; unforce="-Wl,-z -Wl,defaultextract"
+	force="-Wl,-all";              unforce="-Wl,-none"
+LOOP_INPUT
+    while read line
+    do
+      eval $line
+      LDFLAGS=$force
+      LIBS=$unforce
+      AC_TRY_LINK(,, ac_cv_mkshlib_force_and_unforce=$line; break)
+    done
+    exec 0<&3 3<&-
+    LDFLAGS=$_SAVE_LDFLAGS; LIBS=$_SAVE_LIBS
+   ])
+  if test "$ac_cv_mkshlib_force_and_unforce" = "no"; then
+    AC_MSG_RESULT(no)
+  else
+    AC_MSG_RESULT(yes)
+    eval $ac_cv_mkshlib_force_and_unforce
+    MKSHLIB_FORCE_ALL=$force
+    MKSHLIB_UNFORCE_ALL=$unforce
+  fi
+fi # GNU_CC
+fi # COMPILE_ENVIRONMENT
+
+dnl =================================================================
+dnl Set up and test static assertion macros used to avoid AC_TRY_RUN,
+dnl which is bad when cross compiling.
+dnl =================================================================
+if test "$COMPILE_ENVIRONMENT"; then
+configure_static_assert_macros='
+#define CONFIGURE_STATIC_ASSERT(condition) CONFIGURE_STATIC_ASSERT_IMPL(condition, __LINE__)
+#define CONFIGURE_STATIC_ASSERT_IMPL(condition, line) CONFIGURE_STATIC_ASSERT_IMPL2(condition, line)
+#define CONFIGURE_STATIC_ASSERT_IMPL2(condition, line) typedef int static_assert_line_##line[(condition) ? 1 : -1]
+'
+
+dnl test that the macros actually work:
+AC_MSG_CHECKING(that static assertion macros used in autoconf tests work)
+AC_CACHE_VAL(ac_cv_static_assertion_macros_work,
+ [AC_LANG_SAVE
+  AC_LANG_C
+  ac_cv_static_assertion_macros_work="yes"
+  AC_TRY_COMPILE([$configure_static_assert_macros],
+                 [CONFIGURE_STATIC_ASSERT(1)],
+                 ,
+                 ac_cv_static_assertion_macros_work="no")
+  AC_TRY_COMPILE([$configure_static_assert_macros],
+                 [CONFIGURE_STATIC_ASSERT(0)],
+                 ac_cv_static_assertion_macros_work="no",
+                 )
+  AC_LANG_CPLUSPLUS
+  AC_TRY_COMPILE([$configure_static_assert_macros],
+                 [CONFIGURE_STATIC_ASSERT(1)],
+                 ,
+                 ac_cv_static_assertion_macros_work="no")
+  AC_TRY_COMPILE([$configure_static_assert_macros],
+                 [CONFIGURE_STATIC_ASSERT(0)],
+                 ac_cv_static_assertion_macros_work="no",
+                 )
+  AC_LANG_RESTORE
+ ])
+AC_MSG_RESULT("$ac_cv_static_assertion_macros_work")
+if test "$ac_cv_static_assertion_macros_work" = "no"; then
+    AC_MSG_ERROR([Compiler cannot compile macros used in autoconf tests.])
+fi
+fi # COMPILE_ENVIRONMENT
+
+dnl ========================================================
+dnl Checking for 64-bit OS
+dnl ========================================================
+if test "$COMPILE_ENVIRONMENT"; then
+AC_LANG_SAVE
+AC_LANG_C
+AC_MSG_CHECKING(for 64-bit OS)
+AC_TRY_COMPILE([$configure_static_assert_macros],
+               [CONFIGURE_STATIC_ASSERT(sizeof(long) == 8)],
+               result="yes", result="no")
+AC_MSG_RESULT("$result")
+if test "$result" = "yes"; then
+    AC_DEFINE(HAVE_64BIT_OS)
+    HAVE_64BIT_OS=1
+fi
+AC_SUBST(HAVE_64BIT_OS)
+AC_LANG_RESTORE
+fi # COMPILE_ENVIRONMENT
+
+dnl ========================================================
+dnl Enable high-memory support on OS/2 by default.
+dnl ========================================================
+MOZ_OS2_HIGH_MEMORY=1
+MOZ_ARG_DISABLE_BOOL(os2-high-mem,
+[  --disable-os2-high-mem  Disable high-memory support on OS/2],
+    MOZ_OS2_HIGH_MEMORY=,
+    MOZ_OS2_HIGH_MEMORY=1 )
+AC_SUBST(MOZ_OS2_HIGH_MEMORY)
+
+dnl ========================================================
+dnl System overrides of the defaults for host
+dnl ========================================================
+case "$host" in
+*-beos*)
+    HOST_CFLAGS="$HOST_CFLAGS -DXP_BEOS -DBeOS -DBEOS -D_POSIX_SOURCE -DNO_X11"
+    HOST_NSPR_MDCPUCFG='\"md/_beos.cfg\"'
+    HOST_OPTIMIZE_FLAGS="${HOST_OPTIMIZE_FLAGS=-O3}"
+    ;;
+
+*cygwin*|*mingw*|*mks*|*msvc*|*wince)
+    if test -n "$_WIN32_MSVC"; then
+        HOST_AR=lib
+        HOST_AR_FLAGS='-NOLOGO -OUT:"$@"'
+        HOST_CFLAGS="$HOST_CFLAGS -TC -nologo -Fd\$(HOST_PDBFILE)"
+        HOST_RANLIB='echo ranlib'
+    else
+        HOST_CFLAGS="$HOST_CFLAGS -mno-cygwin"
+    fi
+    HOST_CFLAGS="$HOST_CFLAGS -DXP_WIN32 -DXP_WIN -DWIN32 -D_WIN32 -DNO_X11"
+    HOST_NSPR_MDCPUCFG='\"md/_winnt.cfg\"'
+    HOST_OPTIMIZE_FLAGS="${HOST_OPTIMIZE_FLAGS=-O2}"
+    HOST_BIN_SUFFIX=.exe
+    case "$host" in
+    *mingw*)
+    dnl MinGW/MSYS does not need CYGWIN_WRAPPER
+        ;;
+    *)
+        CYGWIN_WRAPPER="${srcdir}/build/cygwin-wrapper"
+        if test "`echo ${srcdir} | grep -c ^/ 2>/dev/null`" = 0; then
+            _pwd=`pwd`
+            CYGWIN_WRAPPER="${_pwd}/${srcdir}/build/cygwin-wrapper"
+        fi
+        if test "`${PERL} -v | grep -c cygwin  2>/dev/null`" = 0; then
+            AS_PERL=1
+            PERL="${CYGWIN_WRAPPER} $PERL"
+        fi
+
+        if test "`${PYTHON} -c 'import sys; print sys.platform;'`" != "cygwin"; then
+            PYTHON="${CYGWIN_WRAPPER} $PYTHON"
+        fi
+        ;;
+    esac
+    ;;
+
+*-darwin*)
+    HOST_CFLAGS="$HOST_CFLAGS -DXP_UNIX -DXP_MACOSX -DNO_X11"
+    HOST_NSPR_MDCPUCFG='\"md/_darwin.cfg\"'
+    HOST_OPTIMIZE_FLAGS="${HOST_OPTIMIZE_FLAGS=-O3}"
+    MOZ_FIX_LINK_PATHS='-Wl,-executable_path,$(LIBXUL_DIST)/bin'
+    LIBXUL_LIBS='$(XPCOM_FROZEN_LDOPTS) $(LIBXUL_DIST)/bin/XUL -lobjc'
+    ;;
+
+*-linux*|*-kfreebsd*-gnu)
+    HOST_CFLAGS="$HOST_CFLAGS -DXP_UNIX"
+    HOST_NSPR_MDCPUCFG='\"md/_linux.cfg\"'
+    HOST_OPTIMIZE_FLAGS="${HOST_OPTIMIZE_FLAGS=-O3}"
+    ;;
+
+*os2*)
+    HOST_CFLAGS="$HOST_CFLAGS -DXP_OS2 -DNO_X11 -Zomf"
+    HOST_NSPR_MDCPUCFG='\"md/_os2.cfg\"'
+    HOST_OPTIMIZE_FLAGS="${HOST_OPTIMIZE_FLAGS=-O2}"
+    HOST_BIN_SUFFIX=.exe
+    MOZ_FIX_LINK_PATHS=
+    ;;
+
+*-osf*)
+    HOST_CFLAGS="$HOST_CFLAGS -DXP_UNIX"
+    HOST_NSPR_MDCPUCFG='\"md/_osf1.cfg\"'
+    HOST_OPTIMIZE_FLAGS="${HOST_OPTIMIZE_FLAGS=-O2}"
+    ;;
+
+*)
+    HOST_CFLAGS="$HOST_CFLAGS -DXP_UNIX"
+    HOST_OPTIMIZE_FLAGS="${HOST_OPTIMIZE_FLAGS=-O2}"
+    ;;
+esac
+
+dnl ========================================================
+dnl System overrides of the defaults for target
+dnl ========================================================
+
+case "$target" in
+*-aix*)
+    AC_DEFINE(AIX)
+    if test ! "$GNU_CC"; then
+        if test ! "$HAVE_64BIT_OS"; then
+            # Compiling with Visual Age C++ object model compat is the
+            # default. To compile with object model ibm, add 
+            # AIX_OBJMODEL=ibm to .mozconfig.
+            if test "$AIX_OBJMODEL" = "ibm"; then
+                CXXFLAGS="$CXXFLAGS -qobjmodel=ibm"
+            else
+                AIX_OBJMODEL=compat
+            fi
+        else
+            AIX_OBJMODEL=compat
+        fi
+        AC_SUBST(AIX_OBJMODEL)
+        DSO_LDOPTS='-qmkshrobj=1'
+        DSO_CFLAGS='-qflag=w:w'
+        DSO_PIC_CFLAGS=
+        LDFLAGS="$LDFLAGS -Wl,-brtl -blibpath:/usr/lib:/lib"
+        AC_MSG_WARN([Clearing MOZ_FIX_LINK_PATHS till we can fix bug 332075.])
+        MOZ_FIX_LINK_PATHS=
+        MKSHLIB='$(CXX) $(DSO_LDOPTS) -o $@'
+        MKCSHLIB='$(CC) $(DSO_LDOPTS) -o $@'
+        if test "$COMPILE_ENVIRONMENT"; then
+            AC_LANG_SAVE
+            AC_LANG_CPLUSPLUS
+            AC_MSG_CHECKING([for VisualAge C++ compiler version >= 6.0.0.3])
+            AC_TRY_COMPILE([],
+                [#if (__IBMCPP__ < 600)
+                 #error "Bad compiler"
+                 #endif],
+                _BAD_COMPILER=,_BAD_COMPILER=1)
+            if test -n "$_BAD_COMPILER"; then
+                AC_MSG_RESULT([no])    
+                AC_MSG_ERROR([VisualAge C++ version 6.0.0.3 or higher is required to build.])
+            else
+                AC_MSG_RESULT([yes])    
+            fi
+            AC_LANG_RESTORE
+            TARGET_COMPILER_ABI="ibmc"
+            CC_VERSION=`lslpp -Lcq vac.C 2>/dev/null | awk -F: '{ print $3 }'`
+            CXX_VERSION=`lslpp -Lcq vacpp.cmp.core 2>/dev/null | awk -F: '{ print $3 }'`
+        fi
+    fi
+    case "${target_os}" in
+    aix4.1*)
+        DLL_SUFFIX='_shr.a'
+        ;;
+    esac
+    if test "$COMPILE_ENVIRONMENT"; then
+        AC_CHECK_HEADERS(sys/inttypes.h)
+    fi
+    AC_DEFINE(NSCAP_DISABLE_DEBUG_PTR_TYPES)
+    ;;
+
+*-beos*)
+    no_x=yes
+    MKSHLIB='$(CXX) $(CXXFLAGS) $(DSO_LDOPTS) -Wl,-h,$@ -o $@'
+    _PLATFORM_DEFAULT_TOOLKIT="cairo-beos"
+    DSO_LDOPTS='-nostart'
+    TK_LIBS='-lbe -lroot'
+    LIBS="$LIBS -lbe"
+    if test "$COMPILE_ENVIRONMENT"; then
+        AC_CHECK_LIB(bind,main,LIBS="$LIBS -lbind")
+        AC_CHECK_LIB(zeta,main,LIBS="$LIBS -lzeta")
+    fi
+    _WARNINGS_CFLAGS="${_WARNINGS_CFLAGS} -Wno-multichar"
+    _WARNINGS_CXXFLAGS="${_WARNINGS_CXXFLAGS} -Wno-multichar"
+    _MOZ_USE_RTTI=1
+    USE_DEPENDENT_LIBS=
+    MOZ_USER_DIR="Mozilla"
+    ;;
+
+*-bsdi*)
+    dnl -pedantic doesn't play well with BSDI's _very_ modified gcc (shlicc2)
+    _PEDANTIC=
+    _IGNORE_LONG_LONG_WARNINGS=
+    case $OS_RELEASE in
+	4.*|5.*)
+            STRIP="$STRIP -d"
+            ;;
+	*)
+	    DSO_CFLAGS=''
+	    DSO_LDOPTS='-r'
+	    _WARNINGS_CFLAGS="-Wall"
+	    _WARNINGS_CXXFLAGS="-Wall"
+	    # The test above doesn't work properly, at least on 3.1.
+	    MKSHLIB_FORCE_ALL=''
+	    MKSHLIB_UNFORCE_ALL=''
+	;;
+    esac
+    ;;
+
+*-darwin*) 
+    MKSHLIB='$(CXX) $(CXXFLAGS) $(DSO_PIC_CFLAGS) $(DSO_LDOPTS) -o $@'
+    MKCSHLIB='$(CC) $(CFLAGS) $(DSO_PIC_CFLAGS) $(DSO_LDOPTS) -o $@'
+    MOZ_OPTIMIZE_FLAGS="-O2"
+    _PEDANTIC=
+    CFLAGS="$CFLAGS -fpascal-strings -fno-common"
+    CXXFLAGS="$CXXFLAGS -fpascal-strings -fno-common"
+    DLL_SUFFIX=".dylib"
+    DSO_LDOPTS=''
+    STRIP="$STRIP -x -S"
+    _PLATFORM_DEFAULT_TOOLKIT='cairo-cocoa'
+    MOZ_ENABLE_POSTSCRIPT=
+    TARGET_NSPR_MDCPUCFG='\"md/_darwin.cfg\"'
+    LDFLAGS="$LDFLAGS -framework Cocoa"
+    # The ExceptionHandling framework is needed for Objective-C exception
+    # logging code in nsObjCExceptions.h. Currently we only use that in debug
+    # builds.
+    MOZ_DEBUG_LDFLAGS="$MOZ_DEBUG_LDFLAGS -framework ExceptionHandling"
+    # set MACOSX to generate lib/mac/MoreFiles/Makefile
+    MACOSX=1
+
+    dnl DTrace and -dead_strip don't interact well. See bug 403132.
+    dnl ===================================================================
+    if test "x$enable_dtrace" = "xyes"; then
+        echo "Skipping -dead_strip because DTrace is enabled. See bug 403132."
+    else
+        dnl check for the presence of the -dead_strip linker flag
+        AC_MSG_CHECKING([for -dead_strip option to ld])
+        _SAVE_LDFLAGS=$LDFLAGS
+        LDFLAGS="$LDFLAGS -Wl,-dead_strip"
+        AC_TRY_LINK(,[return 0;],_HAVE_DEAD_STRIP=1,_HAVE_DEAD_STRIP=)
+        if test -n "$_HAVE_DEAD_STRIP" ; then
+            AC_MSG_RESULT([yes])
+            MOZ_OPTIMIZE_LDFLAGS="-Wl,-dead_strip"
+        else
+            AC_MSG_RESULT([no])
+        fi
+        
+        LDFLAGS=$_SAVE_LDFLAGS
+    fi
+    ;;
+
+*-freebsd*)
+    if test `test -x /usr/bin/objformat && /usr/bin/objformat || echo elf` != "elf"; then
+	DLL_SUFFIX=".so.1.0"
+	DSO_LDOPTS="-shared"
+    fi
+    if test ! "$GNU_CC"; then
+	DSO_LDOPTS="-Bshareable $DSO_LDOPTS"
+    fi
+# Can't have force w/o an unforce.
+#    # Hack for FreeBSD 2.2
+#    if test -z "$MKSHLIB_FORCE_ALL"; then
+#	MKSHLIB_FORCE_ALL='-Wl,-Bforcearchive'
+#	MKSHLIB_UNFORCE_ALL=''
+#    fi
+    ;; 
+
+*-hpux*)
+    DLL_SUFFIX=".sl"
+    if test ! "$GNU_CC"; then
+    	DSO_LDOPTS='-b -Wl,+s'
+    	DSO_CFLAGS=""
+    	DSO_PIC_CFLAGS="+Z"
+    	MKSHLIB='$(CXX) $(CXXFLAGS) $(DSO_LDOPTS) -L$(LIBXUL_DIST)/bin -o $@'
+    	MKCSHLIB='$(LD) -b +s -L$(LIBXUL_DIST)/bin -o $@'
+        CXXFLAGS="$CXXFLAGS -Wc,-ansi_for_scope,on"
+    else
+        DSO_LDOPTS='-b -E +s'
+        MKSHLIB='$(LD) $(DSO_LDOPTS) -L$(LIBXUL_DIST)/bin -L$(LIBXUL_DIST)/lib -o $@'
+        MKCSHLIB='$(LD) $(DSO_LDOPTS) -L$(LIBXUL_DIST)/bin -L$(LIBXUL_DIST)/lib -o $@'
+    fi
+    MOZ_POST_PROGRAM_COMMAND='chatr +s enable'
+    AC_DEFINE(NSCAP_DISABLE_DEBUG_PTR_TYPES)
+    ;;
+
+*-irix5*)
+    AC_DEFINE(IRIX)
+    DSO_LDOPTS='-elf -shared'
+
+    if test "$GNU_CC"; then
+       MKSHLIB='$(CXX) $(CXXFLAGS) $(DSO_PIC_CFLAGS) $(DSO_LDOPTS) -o $@'
+       MKCSHLIB='$(CC) $(CFLAGS) $(DSO_PIC_CFLAGS) $(DSO_LDOPTS) -o $@'
+       MKSHLIB_FORCE_ALL='-Wl,-all'
+       MKSHLIB_UNFORCE_ALL='-Wl,-none'
+       CXXFLAGS="$CXXFLAGS -D_LANGUAGE_C_PLUS_PLUS"
+    else
+       MKSHLIB='$(LD) $(DSO_LDOPTS) -o $@'
+       MKCSHLIB='$(LD) $(DSO_LDOPTS) -o $@'
+       MKSHLIB_FORCE_ALL='-all'
+       MKSHLIB_UNFORCE_ALL='-none'
+    fi
+    ;;
+
+*-irix6*)
+    AC_DEFINE(IRIX)
+    dnl the irix specific xptcinvoke code is written against the n32 ABI so we *must* 
+    dnl compile and link using -n32
+    USE_N32=1
+    TARGET_COMPILER_ABI=n32
+    DSO_LDOPTS='-elf -shared'
+    MKSHLIB='$(CCC) $(CXXFLAGS) $(DSO_PIC_CFLAGS) $(DSO_LDOPTS) -o $@'
+    MKCSHLIB='$(CC) $(CFLAGS) $(DSO_PIC_CFLAGS) $(DSO_LDOPTS) -o $@'
+    _MOZ_EXCEPTIONS_FLAGS_OFF="-LANG:exceptions=OFF"
+    _MOZ_EXCEPTIONS_FLAGS_ON="-LANG:exceptions=ON"
+    if test "$GNU_CC"; then
+       MKSHLIB_FORCE_ALL='-Wl,-all'
+       MKSHLIB_UNFORCE_ALL='-Wl,-none'
+       _WARNINGS_CFLAGS="-Wall"
+       _WARNINGS_CXXFLAGS="-Wall"
+       CXXFLAGS="$CXXFLAGS -D_LANGUAGE_C_PLUS_PLUS"
+    else
+       MKSHLIB_FORCE_ALL='-all'
+       MKSHLIB_UNFORCE_ALL='-none'
+	   AR_LIST="$AR t"
+	   AR_EXTRACT="$AR x"
+	   AR_DELETE="$AR d"
+	   AR='$(CXX) -ar'
+	   AR_FLAGS='-o $@'
+       CFLAGS="$CFLAGS -woff 3262 -G 4"
+       CXXFLAGS="$CXXFLAGS -woff 3262 -G 4"
+       if test -n "$USE_N32"; then
+	   ASFLAGS="$ASFLAGS -n32"
+	   CFLAGS="$CFLAGS -n32"
+	   CXXFLAGS="$CXXFLAGS -n32"
+	   LDFLAGS="$LDFLAGS -n32"
+       fi
+       AC_DEFINE(NSCAP_DISABLE_DEBUG_PTR_TYPES)
+       AC_MSG_WARN([Clearing MOZ_FIX_LINK_PATHS for OSF/1 as fix for bug 333545 (till the reference bug 332075 is fixed.])
+       MOZ_FIX_LINK_PATHS=
+    fi
+    if test -z "$GNU_CXX"; then
+      MIPSPRO_CXX=1
+    fi
+    ;;
+
+*-*linux*)
+    if test "$GNU_CC"; then
+        GCC_VERSION=`$CC -v 2>&1 | awk '/^gcc version/ { print $3 }'`
+        case $GCC_VERSION in
+        4.1.*|4.2.*)
+            # -Os is broken on gcc 4.1.x and 4.2.x, we need to tweak it to get good results.
+            MOZ_OPTIMIZE_SIZE_TWEAK="-finline-limit=50"
+        esac
+    fi
+
+    TARGET_NSPR_MDCPUCFG='\"md/_linux.cfg\"'
+    MOZ_OPTIMIZE_FLAGS="-Os -freorder-blocks -fno-reorder-functions $MOZ_OPTIMIZE_SIZE_TWEAK"
+    MOZ_DEBUG_FLAGS="-g -fno-inline"  # most people on linux use gcc/gdb,
+                                      # and that combo is not yet good at
+                                      # debugging inlined functions (even
+                                      # when using DWARF2 as the debugging
+                                      # format)    
+
+
+    case "${target_cpu}" in
+    alpha*)
+    	CFLAGS="$CFLAGS -mieee"
+    	CXXFLAGS="$CXXFLAGS -mieee"
+    ;;
+    i*86)
+    	USE_ELF_DYNSTR_GC=1
+        MOZ_ENABLE_OLD_ABI_COMPAT_WRAPPERS=1
+    ;;
+    mips*)
+        MOZ_DEBUG_FLAGS="-g" # We want inlining
+    ;;
+    esac
+    ;;
+
+*-wince*)
+
+    MOZ_TOOLS_DIR=`echo $MOZ_TOOLS`
+    AR_LIST="$AR -list"
+    AR_EXTRACT="$AR -extract"
+    AR_DELETE="$AR d"
+    AR_FLAGS='-OUT:"$@"'
+
+    if test -z "$AS_BIN"; then
+        AS="$AS_BIN"
+    fi
+    DSO_CFLAGS=
+    DSO_PIC_CFLAGS=
+    DLL_SUFFIX=.dll
+    BIN_SUFFIX='.exe'
+    if test -z "$RC"; then 
+        RC=rc.exe  
+    fi
+    # certain versions of cygwin's makedepend barf on the 
+    # #include <string> vs -I./dist/include/string issue so don't use it
+    SYSTEM_MAKEDEPEND=
+
+    HOST_CC=cl
+    HOST_CXX=cl
+    HOST_LD=link
+    HOST_AR='lib -OUT:$@'
+    HOST_RANLIB='echo ranlib'
+    HOST_CFLAGS="$HOST_CFLAGS -D_X86_"
+        
+        
+    WARNINGS_AS_ERRORS='-WX'
+	MOZ_OPTIMIZE_FLAGS='-O1'
+    AR_FLAGS='-NOLOGO -OUT:"$@"'
+    ASM_SUFFIX=asm
+    CFLAGS="$CFLAGS -W3 -Gy -Fd\$(PDBFILE)"
+    CXXFLAGS="$CXXFLAGS -W3 -Gy -Fd\$(PDBFILE)"
+    DLL_PREFIX=
+    DOXYGEN=:
+    DSO_LDOPTS=-SUBSYSTEM:WINDOWSCE
+    DYNAMIC_XPCOM_LIBS='$(LIBXUL_DIST)/lib/xpcom.lib $(LIBXUL_DIST)/lib/xpcom_core.lib'
+    GARBAGE=
+    IMPORT_LIB_SUFFIX=lib
+    LIBS="$LIBS"
+    LIBXUL_LIBS='$(LIBXUL_DIST)/lib/xpcom.lib $(LIBXUL_DIST)/lib/xul.lib'
+    LIB_PREFIX=
+    LIB_SUFFIX=lib 
+    MKCSHLIB='$(LD) -NOLOGO -DLL -OUT:$@ $(DSO_LDOPTS)'
+    MKSHLIB='$(LD) -NOLOGO -DLL -OUT:$@ $(DSO_LDOPTS)'
+    MKSHLIB_FORCE_ALL=
+    MKSHLIB_UNFORCE_ALL=
+    MOZ_COMPONENT_NSPR_LIBS='$(NSPR_LIBS)'
+    MOZ_COMPONENT_NSPR_LIBS='$(NSPR_LIBS)'
+    MOZ_DEBUG_FLAGS='-Zi'
+    MOZ_DEBUG_LDFLAGS='-DEBUG -DEBUGTYPE:CV'
+    MOZ_FIX_LINK_PATHS=
+    MOZ_JS_LIBS='$(libdir)/js$(MOZ_BITS)$(VERSION_NUMBER).lib'
+    MOZ_XPCOM_OBSOLETE_LIBS='$(LIBXUL_DIST)/lib/xpcom_compat.lib'
+    OBJ_SUFFIX=obj
+    RANLIB='echo not_ranlib'
+    STRIP='echo not_strip'
+    TARGET_NSPR_MDCPUCFG='\"md/_wince.cfg\"'
+    UNZIP=unzip
+    XARGS=xargs
+    XPCOM_FROZEN_LDOPTS='$(LIBXUL_DIST)/lib/xpcom.lib'
+    ZIP=zip
+
+    AC_DEFINE(HAVE_SNPRINTF)
+    AC_DEFINE(_WINDOWS)
+    AC_DEFINE(_WIN32)
+    AC_DEFINE(WIN32)
+    AC_DEFINE(XP_WIN)
+    AC_DEFINE(XP_WIN32)
+    AC_DEFINE(HW_THREADS)
+    AC_DEFINE(STDC_HEADERS)
+    AC_DEFINE(NEW_H, <new>)
+    AC_DEFINE(WIN32_LEAN_AND_MEAN)
+
+    TARGET_MD_ARCH=win32
+    _PLATFORM_DEFAULT_TOOLKIT='windows'
+    BIN_SUFFIX='.exe'
+    USE_SHORT_LIBNAME=1
+    MOZ_ENABLE_POSTSCRIPT=
+    MOZ_USER_DIR="Mozilla"
+;;
+
+
+*-mingw*|*-cygwin*|*-msvc*|*-mks*)
+    DSO_CFLAGS=
+    DSO_PIC_CFLAGS=
+    DLL_SUFFIX=.dll
+    RC=rc.exe
+    # certain versions of cygwin's makedepend barf on the 
+    # #include <string> vs -I./dist/include/string issue so don't use it
+    SYSTEM_MAKEDEPEND=
+    if test -n "$GNU_CC"; then
+        CC="$CC -mno-cygwin"
+        CXX="$CXX -mno-cygwin"
+        CPP="$CPP -mno-cygwin"
+        CFLAGS="$CFLAGS -mms-bitfields"
+        CXXFLAGS="$CXXFLAGS -mms-bitfields"
+        DSO_LDOPTS='-shared'
+        MKSHLIB='$(CXX) $(DSO_LDOPTS) -o $@'
+        MKCSHLIB='$(CC) $(DSO_LDOPTS) -o $@'
+        RC='$(WINDRES)'
+        # Use temp file for windres (bug 213281)
+        RCFLAGS='-O coff --use-temp-file'
+        # mingw doesn't require kernel32, user32, and advapi32 explicitly
+        LIBS="$LIBS -lgdi32 -lwinmm -lwsock32"
+        MOZ_JS_LIBS='-L$(libdir) -ljs$(MOZ_BITS)$(VERSION_NUMBER)'
+        MOZ_FIX_LINK_PATHS=
+        DYNAMIC_XPCOM_LIBS='-L$(LIBXUL_DIST)/lib -lxpcom -lxpcom_core'
+        XPCOM_FROZEN_LDOPTS='-L$(LIBXUL_DIST)/lib -lxpcom'
+        DLL_PREFIX=
+        IMPORT_LIB_SUFFIX=dll.a
+    else
+        TARGET_COMPILER_ABI=msvc
+        HOST_CC='$(CC)'
+        HOST_CXX='$(CXX)'
+        HOST_LD='$(LD)'
+        AR='lib -NOLOGO -OUT:"$@"'
+        AR_FLAGS=
+        RANLIB='echo not_ranlib'
+        STRIP='echo not_strip'
+        XARGS=xargs
+        ZIP=zip
+        UNZIP=unzip
+        DOXYGEN=:
+        GARBAGE='$(OBJDIR)/vc20.pdb $(OBJDIR)/vc40.pdb'
+        OBJ_SUFFIX=obj
+        LIB_SUFFIX=lib
+        DLL_PREFIX=
+        LIB_PREFIX=
+        IMPORT_LIB_SUFFIX=lib
+        MKSHLIB='$(LD) -NOLOGO -DLL -OUT:$@ -PDB:$(PDBFILE) $(DSO_LDOPTS)'
+        MKCSHLIB='$(LD) -NOLOGO -DLL -OUT:$@ -PDB:$(PDBFILE) $(DSO_LDOPTS)'
+        MKSHLIB_FORCE_ALL=
+        MKSHLIB_UNFORCE_ALL=
+        DSO_LDOPTS=-SUBSYSTEM:WINDOWS
+        CFLAGS="$CFLAGS -W3 -Gy -Fd\$(PDBFILE)"
+        CXXFLAGS="$CXXFLAGS -W3 -Gy -Fd\$(PDBFILE)"
+        LIBS="$LIBS kernel32.lib user32.lib gdi32.lib winmm.lib wsock32.lib advapi32.lib"
+        MOZ_DEBUG_FLAGS='-Zi'
+        MOZ_DEBUG_LDFLAGS='-DEBUG -DEBUGTYPE:CV'
+        WARNINGS_AS_ERRORS='-WX'
+    	MOZ_OPTIMIZE_FLAGS='-O1'
+        MOZ_JS_LIBS='$(libdir)/js$(MOZ_BITS)$(VERSION_NUMBER).lib'
+        MOZ_FIX_LINK_PATHS=
+        DYNAMIC_XPCOM_LIBS='$(LIBXUL_DIST)/lib/xpcom.lib $(LIBXUL_DIST)/lib/xpcom_core.lib'
+        XPCOM_FROZEN_LDOPTS='$(LIBXUL_DIST)/lib/xpcom.lib'
+        LIBXUL_LIBS='$(LIBXUL_DIST)/lib/xpcom.lib $(LIBXUL_DIST)/lib/xul.lib'
+        MOZ_COMPONENT_NSPR_LIBS='$(NSPR_LIBS)'
+        MOZ_XPCOM_OBSOLETE_LIBS='$(LIBXUL_DIST)/lib/xpcom_compat.lib'
+        if test $_MSC_VER -ge 1400; then
+            LDFLAGS="$LDFLAGS -NXCOMPAT -SAFESEH"
+            dnl For profile-guided optimization
+            PROFILE_GEN_CFLAGS="-GL"
+            PROFILE_GEN_LDFLAGS="-LTCG:PGINSTRUMENT"
+            dnl XXX: PGO builds can fail with warnings treated as errors,
+            dnl specifically "no profile data available" appears to be
+            dnl treated as an error sometimes. This might be a consequence
+            dnl of using WARNINGS_AS_ERRORS in some modules, combined
+            dnl with the linker doing most of the work in the whole-program
+            dnl optimization/PGO case. I think it's probably a compiler bug,
+            dnl but we work around it here.
+            PROFILE_USE_CFLAGS="-GL -wd4624 -wd4952"
+            dnl XXX: should be -LTCG:PGOPTIMIZE, but that fails on libxul.
+            dnl Probably also a compiler bug, but what can you do?
+            PROFILE_USE_LDFLAGS="-LTCG:PGUPDATE"
+            if test -n "$_USE_DYNAMICBASE"; then
+               LDFLAGS="$LDFLAGS -DYNAMICBASE"
+            fi
+        fi
+    fi
+    AC_DEFINE(HAVE_SNPRINTF)
+    AC_DEFINE(_WINDOWS)
+    AC_DEFINE(_WIN32)
+    AC_DEFINE(WIN32)
+    AC_DEFINE(XP_WIN)
+    AC_DEFINE(XP_WIN32)
+    AC_DEFINE(HW_THREADS)
+    AC_DEFINE(STDC_HEADERS)
+    AC_DEFINE(NEW_H, <new>)
+    AC_DEFINE(WIN32_LEAN_AND_MEAN)
+    TARGET_MD_ARCH=win32
+    _PLATFORM_DEFAULT_TOOLKIT='cairo-windows'
+    BIN_SUFFIX='.exe'
+    USE_SHORT_LIBNAME=1
+    MOZ_ENABLE_POSTSCRIPT=
+    MOZ_USER_DIR="Mozilla"
+
+    dnl Hardcode to win95 for now - cls
+    TARGET_NSPR_MDCPUCFG='\"md/_win95.cfg\"'
+
+    dnl set NO_X11 defines here as the general check is skipped on win32
+    no_x=yes
+    AC_DEFINE(NO_X11)
+
+    dnl MinGW/MSYS doesn't provide or need cygpath
+    case "$host" in
+    *-mingw*)
+	CYGPATH_W=echo
+	CYGPATH_S=cat
+	MOZ_BUILD_ROOT=`cd $MOZ_BUILD_ROOT && pwd -W`
+	;;
+    *-cygwin*|*-msvc*|*-mks*)
+	CYGPATH_W="cygpath -a -w"
+	CYGPATH_S="sed -e s|\\\\|/|g"
+	MOZ_BUILD_ROOT=`$CYGPATH_W $MOZ_BUILD_ROOT | $CYGPATH_S`
+	;;
+    esac
+    case "$host" in
+    *-mingw*|*-cygwin*|*-msvc*|*-mks*)
+
+    if test -z "$MOZ_TOOLS"; then
+        AC_MSG_ERROR([MOZ_TOOLS is not set])
+    fi
+
+    MOZ_TOOLS_DIR=`cd $MOZ_TOOLS && pwd`
+    if test "$?" != "0" || test -z "$MOZ_TOOLS_DIR"; then
+        AC_MSG_ERROR([cd \$MOZ_TOOLS failed. MOZ_TOOLS ==? $MOZ_TOOLS])
+    fi
+    if test `echo ${PATH}: | grep -ic "$MOZ_TOOLS_DIR/bin:"` = 0; then
+        AC_MSG_ERROR([\$MOZ_TOOLS\\bin must be in your path.])
+    fi
+    MOZ_TOOLS_DIR=`$CYGPATH_W $MOZ_TOOLS_DIR | $CYGPATH_S`
+
+    if test -n "$GLIB_PREFIX"; then
+        _GLIB_PREFIX_DIR=`cd $GLIB_PREFIX && pwd`
+        if test "$?" = "0"; then
+            if test `echo ${PATH}: | grep -ic "$_GLIB_PREFIX_DIR/bin:"` = 0; then
+                AC_MSG_ERROR([GLIB_PREFIX must be in your \$PATH.])
+            fi
+            _GLIB_PREFIX_DIR=`$CYGPATH_W $_GLIB_PREFIX_DIR | $CYGPATH_S`
+        else
+            AC_MSG_ERROR([GLIB_PREFIX is set but "${GLIB_PREFIX}" is not a directory.])
+        fi
+    else
+        _GLIB_PREFIX_DIR=$MOZ_TOOLS_DIR
+    fi
+    if test ! -f "${_GLIB_PREFIX_DIR}/include/glib.h"; then
+        AC_MSG_ERROR([Cannot find $_GLIB_PREFIX_DIR/include/glib.h .])
+    fi
+    GLIB_CFLAGS="-I${_GLIB_PREFIX_DIR}/include"
+    if test -f "${_GLIB_PREFIX_DIR}/lib/glib-1.2_s.lib"; then
+        GLIB_LIBS="${_GLIB_PREFIX_DIR}/lib/glib-1.2_s.lib"
+    elif test -f "${_GLIB_PREFIX_DIR}/lib/glib-1.2.lib"; then
+        GLIB_LIBS="${_GLIB_PREFIX_DIR}/lib/glib-1.2.lib"
+    else
+        AC_MSG_ERROR([Cannot find $_GLIB_PREFIX_DIR/lib/glib-1.2.lib or $_GLIB_PREFIX_DIR/lib/glib-1.2_s.lib])
+    fi
+    ;;
+
+    *) # else cross-compiling
+        if test -n "$GLIB_PREFIX"; then
+            GLIB_CFLAGS="-I${GLIB_PREFIX}/include"
+            if test -f "${GLIB_PREFIX}/lib/glib-1.2_s.lib"; then
+                GLIB_LIBS="${GLIB_PREFIX}/lib/glib-1.2_s.lib"
+            elif test -f "${GLIB_PREFIX}/lib/glib-1.2.lib"; then
+                GLIB_LIBS="${GLIB_PREFIX}/lib/glib-1.2.lib"
+            else
+                AC_MSG_ERROR([Cannot find $GLIB_PREFIX/lib/glib-1.2.lib or $GLIB_PREFIX/lib/glib-1.2_s.lib])
+            fi
+        fi
+        ;;
+    esac 
+
+
+    case "$host_os" in
+    cygwin*|msvc*|mks*)
+        AC_MSG_WARN([Using a cygwin build environment is unsupported. Configure cannot check for the presence of necessary headers. Please upgrade to MozillaBuild; see http://developer.mozilla.org/en/docs/Windows_Build_Prerequisites])
+        ;;
+
+    *)
+        AC_CHECK_HEADERS(mmintrin.h oleacc.idl)
+
+        AC_LANG_SAVE
+        AC_LANG_CPLUSPLUS
+        AC_CHECK_HEADERS(atlbase.h wpcapi.h)
+        AC_LANG_RESTORE
+        ;;
+    esac
+
+    case "$target" in
+    i*86-*)
+    	AC_DEFINE(_X86_)
+	;;
+    alpha-*)
+    	AC_DEFINE(_ALPHA_)
+	;;
+    mips-*)
+    	AC_DEFINE(_MIPS_)
+	;;
+    *)
+    	AC_DEFINE(_CPU_ARCH_NOT_DEFINED)
+	;;
+    esac
+    ;;
+
+*-netbsd*)
+    DSO_CFLAGS=''
+    CFLAGS="$CFLAGS -Dunix"
+    CXXFLAGS="$CXXFLAGS -Dunix"
+    if $CC -E - -dM </dev/null | grep __ELF__ >/dev/null; then
+        DLL_SUFFIX=".so"
+        DSO_PIC_CFLAGS='-fPIC -DPIC'
+        DSO_LDOPTS='-shared'
+	BIN_FLAGS='-Wl,--export-dynamic'
+    else
+    	DSO_PIC_CFLAGS='-fPIC -DPIC'
+    	DLL_SUFFIX=".so.1.0"
+    	DSO_LDOPTS='-shared'
+    fi
+    # This will fail on a.out systems prior to 1.5.1_ALPHA.
+    MKSHLIB_FORCE_ALL='-Wl,--whole-archive'
+    MKSHLIB_UNFORCE_ALL='-Wl,--no-whole-archive'
+    if test "$LIBRUNPATH"; then
+	DSO_LDOPTS="-Wl,-R$LIBRUNPATH $DSO_LDOPTS"
+    fi
+    MKSHLIB='$(CXX) $(CXXFLAGS) $(DSO_PIC_CFLAGS) $(DSO_LDOPTS) -Wl,-soname,lib$(LIBRARY_NAME)$(DLL_SUFFIX) -o $@'
+    MKCSHLIB='$(CC) $(CFLAGS) $(DSO_PIC_CFLAGS) $(DSO_LDOPTS) -Wl,-soname,lib$(LIBRARY_NAME)$(DLL_SUFFIX) -o $@'
+    ;;
+
+*-nto*) 
+	AC_DEFINE(NTO)	
+	AC_DEFINE(_QNX_SOURCE)
+	AC_DEFINE(_i386)
+	OS_TARGET=NTO
+	WARNINGS_AS_ERRORS=''
+	MOZ_OPTIMIZE_FLAGS="-O"
+	MOZ_DEBUG_FLAGS="-gstabs"
+	USE_PTHREADS=1
+	_PEDANTIC=
+	LIBS="$LIBS -lsocket -lstdc++"
+	_DEFINES_CFLAGS='-Wp,-include -Wp,$(DEPTH)/mozilla-config.h -DMOZILLA_CLIENT -D_POSIX_C_SOURCE=199506'
+	_DEFINES_CXXFLAGS='-DMOZILLA_CLIENT -Wp,-include -Wp,$(DEPTH)/mozilla-config.h -D_POSIX_C_SOURCE=199506'
+	if test "$with_x" != "yes"
+	then
+		_PLATFORM_DEFAULT_TOOLKIT="photon"
+	    TK_CFLAGS='-I/usr/include/photon'
+		TK_LIBS='-lph'
+	fi
+	case "${target_cpu}" in
+	ppc*)
+	AC_DEFINE(HAVE_VA_LIST_AS_ARRAY)	
+	;;
+	esac
+	case "${host_cpu}" in
+	i*86)
+	USE_ELF_DYNSTR_GC=1
+	;;
+	esac
+	;;
+
+*-openbsd*)
+    DLL_SUFFIX=".so.1.0"
+    DSO_CFLAGS=''
+    DSO_PIC_CFLAGS='-fPIC'
+    DSO_LDOPTS='-shared -fPIC'
+    if test "$LIBRUNPATH"; then
+	DSO_LDOPTS="-R$LIBRUNPATH $DSO_LDOPTS"
+    fi
+    ;;
+
+*-openvms*) 
+    AC_DEFINE(NO_PW_GECOS)
+    AC_DEFINE(NO_UDSOCK)
+    AC_DEFINE(POLL_WITH_XCONNECTIONNUMBER)
+    USE_PTHREADS=1
+    MKSHLIB_FORCE_ALL='-all'
+    MKSHLIB_UNFORCE_ALL='-none'
+    AS='as'
+    AS_DASH_C_FLAG='-Wc/names=as_is'
+    AR_FLAGS='c $@'
+    DSO_LDOPTS='-shared -auto_symvec'
+    DSO_PIC_CFLAGS=
+    MOZ_DEBUG_LDFLAGS='-g'
+    COMPAQ_CXX=1
+    CC_VERSION=`$CC -V 2>&1 | awk '/ C / { print $3 }'`
+    CXX_VERSION=`$CXX -V 2>&1 | awk '/ C\+\+ / { print $3 }'`
+    ;;
+
+
+*-os2*)
+    MKSHLIB='$(CXX) $(CXXFLAGS) $(DSO_PIC_CFLAGS) $(DSO_LDOPTS) -o $@'
+    MKCSHLIB='$(CC) $(CFLAGS) $(DSO_PIC_CFLAGS) $(DSO_LDOPTS) -o $@'
+    AC_DEFINE(OS2)
+    AC_DEFINE(XP_OS2)
+    AC_DEFINE(OS2EMX_PLAIN_CHAR)
+    AC_DEFINE(TCPV40HDRS)
+    USE_SHORT_LIBNAME=1
+    DLL_PREFIX=
+    LIB_PREFIX=
+    LIB_SUFFIX=lib
+    BIN_SUFFIX=".exe"
+    DLL_SUFFIX=".dll"
+    IMPORT_LIB_SUFFIX=lib
+    DSO_PIC_CFLAGS=
+    AR=emxomfar
+    AR_FLAGS='r $@'
+    CFLAGS="$CFLAGS -Zomf"
+    CXXFLAGS="$CXXFLAGS -Zomf"
+    DSO_LDOPTS='-Zdll'
+    BIN_FLAGS='-Zlinker /ST:0x100000'
+    IMPLIB='emximp -o'
+    FILTER='emxexp -o'
+    LDFLAGS='-Zmap'
+    WARNINGS_AS_ERRORS='-Werror'
+    MOZ_DEBUG_FLAGS="-g -fno-inline"
+    MOZ_OPTIMIZE_FLAGS="-O2"
+    MOZ_OPTIMIZE_LDFLAGS="-s -Zlinker /EXEPACK:2 -Zlinker /PACKCODE -Zlinker /PACKDATA"
+    MOZ_XPCOM_OBSOLETE_LIBS='-L$(LIBXUL_DIST)/lib $(LIBXUL_DIST)/lib/xpcomct.lib'
+    DYNAMIC_XPCOM_LIBS='-L$(LIBXUL_DIST)/lib $(LIBXUL_DIST)/lib/xpcom.lib $(LIBXUL_DIST)/lib/xpcomcor.lib'
+    LIBXUL_LIBS='-L$(LIBXUL_DIST)/lib $(LIBXUL_DIST)/lib/xpcom.lib $(LIBXUL_DIST)/lib/xul.lib'
+    TARGET_MD_ARCH=os2
+    _PLATFORM_DEFAULT_TOOLKIT="cairo-os2"
+    MOZ_ENABLE_POSTSCRIPT=
+    RC=rc.exe
+    RCFLAGS='-n'
+    MOZ_USER_DIR="Mozilla"
+
+    if test "$MOZTOOLS"; then
+        MOZ_TOOLS_DIR=`echo $MOZTOOLS | sed -e 's|\\\\|/|g'`
+    else
+        AC_MSG_ERROR([MOZTOOLS is not set])
+    fi
+    if test -n "$MOZ_OS2_HIGH_MEMORY"; then
+        DSO_LDOPTS="$DSO_LDOPTS -Zhigh-mem"
+        LDFLAGS="$LDFLAGS -Zhigh-mem"
+        MOZ_OPTIMIZE_LDFLAGS="$MOZ_OPTIMIZE_LDFLAGS -Zhigh-mem"
+        AC_DEFINE(MOZ_OS2_HIGH_MEMORY)
+    fi
+
+    # GCC for OS/2 currently predefines these, but we don't want them
+    _DEFINES_CFLAGS="$_DEFINES_CFLAGS -Uunix -U__unix -U__unix__"
+    _DEFINES_CXXFLAGS="$_DEFINES_CXXFLAGS -Uunix -U__unix -U__unix__"
+
+    AC_CACHE_CHECK(for __declspec(dllexport),
+        ac_os2_declspec,
+        [AC_TRY_COMPILE([__declspec(dllexport) void ac_os2_declspec(void) {}],
+                        [return 0;],
+                        ac_os2_declspec="yes",
+                        ac_os2_declspec="no")])
+    if test "$ac_os2_declspec" = "yes"; then
+        FILTER='true'
+        MOZ_OS2_USE_DECLSPEC='1'
+    fi
+    ;;
+
+alpha*-*-osf*)
+    if test "$GNU_CC"; then
+      MKSHLIB='$(CXX) $(CXXFLAGS) $(DSO_PIC_CFLAGS) $(DSO_LDOPTS) -Wl,-soname,$@ -o $@'
+      MKCSHLIB='$(CC) $(CFLAGS) $(DSO_PIC_CFLAGS) $(DSO_LDOPTS) -Wl,-soname,$@ -o $@'
+
+    else
+	MOZ_DEBUG_FLAGS='-g'
+	ASFLAGS='-I$(topsrcdir)/xpcom/reflect/xptcall/public -g'
+	CFLAGS="$CFLAGS -ieee"
+	CXXFLAGS="$CXXFLAGS "'-noexceptions -ieee  -ptr $(DIST)/cxx_repository'
+	DSO_LDOPTS='-shared -msym -expect_unresolved \* -update_registry $(DIST)/so_locations'
+	DSO_CFLAGS=
+	DSO_PIC_CFLAGS=
+	MKCSHLIB='$(CC) $(CFLAGS) $(DSO_PIC_CFLAGS) $(DSO_LDOPTS) -soname $@ -o $@'
+	MKSHLIB='$(CXX) $(CXXFLAGS) $(DSO_PIC_CFLAGS) $(DSO_LDOPTS) -soname $@ -o $@'
+	MKSHLIB_FORCE_ALL='-all'
+	MKSHLIB_UNFORCE_ALL='-none'
+	dnl Might fix the libxpcom.so breakage on this platform as well....
+	AC_DEFINE(NSCAP_DISABLE_TEST_DONTQUERY_CASES)
+	AC_DEFINE(NSCAP_DISABLE_DEBUG_PTR_TYPES)
+    fi
+    if test -z "$GNU_CXX"; then
+      COMPAQ_CXX=1
+    fi
+    AC_DEFINE(NEED_USLEEP_PROTOTYPE)
+    ;;
+
+*-qnx*) 
+    DIRENT_INO=d_stat.st_ino
+    dnl Solves the problems the QNX compiler has with nsCOMPtr.h.
+    AC_DEFINE(NSCAP_DISABLE_TEST_DONTQUERY_CASES)
+    AC_DEFINE(NSCAP_DISABLE_DEBUG_PTR_TYPES)
+    dnl Explicit set STDC_HEADERS to workaround QNX 6.0's failing of std test
+    AC_DEFINE(STDC_HEADERS)
+    if test "$no_x" = "yes"; then
+	    _PLATFORM_DEFAULT_TOOLKIT='photon'
+	    TK_CFLAGS='-I/usr/nto/include/photon'
+	    TK_LIBS='-lphoton -lphrender'
+    fi
+    ;;
+
+*-sco*) 
+    AC_DEFINE(NSCAP_DISABLE_TEST_DONTQUERY_CASES)
+    AC_DEFINE(NSCAP_DISABLE_DEBUG_PTR_TYPES)
+    CXXFLAGS="$CXXFLAGS -I/usr/include/CC"
+    if test ! "$GNU_CC"; then
+       DSO_LDOPTS='-G'
+    fi
+    ;;
+
+dnl the qsort routine under solaris is faulty
+*-solaris*) 
+    AC_DEFINE(SOLARIS)
+    TARGET_NSPR_MDCPUCFG='\"md/_solaris.cfg\"'
+    SYSTEM_MAKEDEPEND=
+    # $ORIGIN/.. is for shared libraries under components/ to locate shared
+    # libraries one level up (e.g. libnspr4.so)
+    LDFLAGS="$LDFLAGS -z ignore -R '\$\$ORIGIN:\$\$ORIGIN/..'"
+    LIBS="-lCrun -lCstd $LIBS"
+    if test -z "$GNU_CC"; then
+       NS_USE_NATIVE=1
+       MOZ_FIX_LINK_PATHS=
+       AC_DEFINE(NSCAP_DISABLE_DEBUG_PTR_TYPES)
+
+       if test "$CPU_ARCH" != "sparc"; then
+          CFLAGS="$CFLAGS -xlibmieee -xstrconst -xbuiltin=%all"
+          CXXFLAGS="$CXXFLAGS -xlibmieee -xbuiltin=%all -features=tmplife -norunpath"
+       else
+          # Do not use -xbuiltin on SPARC to get around a bug of compiler
+          CFLAGS="$CFLAGS -xlibmieee -xstrconst -xbuiltin=%none"
+          CXXFLAGS="$CXXFLAGS -xlibmieee -xbuiltin=%none -features=tmplife -norunpath"
+       fi
+
+       LDFLAGS="-xildoff -z lazyload -z combreloc $LDFLAGS"
+       if test -z "$CROSS_COMPILE" && test -f /usr/lib/ld/map.noexstk; then
+           _SAVE_LDFLAGS=$LDFLAGS
+           LDFLAGS="-M /usr/lib/ld/map.noexstk $LDFLAGS" 
+           AC_TRY_LINK([#include <stdio.h>],
+                       [printf("Hello World\n");],
+                       ,
+                       [LDFLAGS=$_SAVE_LDFLAGS])
+       fi
+       WARNINGS_AS_ERRORS='-Werror'
+       MOZ_OPTIMIZE_FLAGS="-xO4"
+       MKSHLIB='$(CXX) $(CXXFLAGS) $(DSO_PIC_FLAGS) $(DSO_LDOPTS) -h $@ -o $@'
+       MKCSHLIB='$(CC) $(CFLAGS) $(DSO_PIC_FLAGS) -G -z muldefs -h $@ -o $@'
+       MKSHLIB_FORCE_ALL='-z allextract'
+       MKSHLIB_UNFORCE_ALL='-z defaultextract'
+       DSO_LDOPTS='-G -z muldefs'
+       AR_LIST="$AR t"
+       AR_EXTRACT="$AR x"
+       AR_DELETE="$AR d"
+       AR='$(CXX) -xar'
+       AR_FLAGS='-o $@'
+       AS='/usr/ccs/bin/as'
+       ASFLAGS="$ASFLAGS -K PIC -L -P -D_ASM -D__STDC__=0"
+       AS_DASH_C_FLAG=''
+       TARGET_COMPILER_ABI="sunc"
+        CC_VERSION=`$CC -V 2>&1 | grep '^cc:' 2>/dev/null | $AWK -F\: '{ print $2 }'`
+        CXX_VERSION=`$CXX -V 2>&1 | grep '^CC:' 2>/dev/null | $AWK -F\: '{ print $2 }'`
+       AC_MSG_CHECKING([for Forte compiler version >= WS6U2])
+       AC_LANG_SAVE
+       AC_LANG_CPLUSPLUS
+       AC_TRY_COMPILE([],
+           [#if (__SUNPRO_CC < 0x530)
+           #error "Denied"
+           #endif],
+           _BAD_COMPILER=,_BAD_COMPILER=1)
+        if test -n "$_BAD_COMPILER"; then
+            _res="no"
+            AC_MSG_ERROR([Forte version WS6U2 or higher is required to build. Your compiler version is $CC_VERSION .])
+        else
+            _res="yes"
+        fi
+        AC_MSG_RESULT([$_res])
+        AC_LANG_RESTORE
+    else
+       ASFLAGS="$ASFLAGS -fPIC"
+       DSO_LDOPTS='-G'
+       _WARNINGS_CFLAGS=''
+       _WARNINGS_CXXFLAGS=''
+       if test "$OS_RELEASE" = "5.3"; then
+	  AC_DEFINE(MUST_UNDEF_HAVE_BOOLEAN_AFTER_INCLUDES)
+       fi
+    fi
+    if test "$OS_RELEASE" = "5.5.1"; then
+       AC_DEFINE(NEED_USLEEP_PROTOTYPE)
+    fi
+    ;;
+
+*-sunos*) 
+    DSO_LDOPTS='-Bdynamic'
+    MKSHLIB='-$(LD) $(DSO_LDOPTS) -o $@'
+    MKCSHLIB='-$(LD) $(DSO_LDOPTS) -o $@'
+    AC_DEFINE(SUNOS4)
+    AC_DEFINE(SPRINTF_RETURNS_STRING)
+    case "$(target_os)" in
+    sunos4.1*)
+        DLL_SUFFIX='.so.1.0'
+        ;;
+    esac
+    ;;
+
+*-sysv4.2uw7*) 
+	NSPR_LIBS="-lnspr$NSPR_VERSION -lplc$NSPR_VERSION -lplds$NSPR_VERSION -L/usr/ccs/lib -lcrt"
+    ;;
+
+*-os2*)
+    HOST_NSPR_MDCPUCFG='\"md/_os2.cfg\"'
+    ;;
+
+esac
+
+dnl Only one oddball right now (QNX), but this gives us flexibility
+dnl if any other platforms need to override this in the future.
+AC_DEFINE_UNQUOTED(D_INO,$DIRENT_INO)
+
+dnl ========================================================
+dnl Any platform that doesn't have MKSHLIB_FORCE_ALL defined
+dnl by now will not have any way to link most binaries (tests
+dnl as well as viewer, apprunner, etc.), because some symbols
+dnl will be left out of the "composite" .so's by ld as unneeded.
+dnl So, by defining NO_LD_ARCHIVE_FLAGS for these platforms,
+dnl they can link in the static libs that provide the missing
+dnl symbols.
+dnl ========================================================
+NO_LD_ARCHIVE_FLAGS=
+if test -z "$MKSHLIB_FORCE_ALL" || test -z "$MKSHLIB_UNFORCE_ALL"; then
+    NO_LD_ARCHIVE_FLAGS=1
+fi
+case "$target" in
+*-os2*)
+    NO_LD_ARCHIVE_FLAGS=
+    ;;
+*-aix4.3*|*-aix5*)
+    NO_LD_ARCHIVE_FLAGS=
+    ;;
+*-openvms*)
+    NO_LD_ARCHIVE_FLAGS=
+    ;;
+*-msvc*|*-mks*|*-mingw*|*-cygwin*|*-wince)
+    if test -z "$GNU_CC"; then
+        NO_LD_ARCHIVE_FLAGS=
+    fi
+    ;;
+esac
+AC_SUBST(NO_LD_ARCHIVE_FLAGS)
+
+dnl
+dnl Indicate that platform requires special thread safe 
+dnl locking when starting up the OJI JVM 
+dnl (see mozilla/modules/oji/src/nsJVMManager.cpp)
+dnl ========================================================
+case "$target" in
+    *-hpux*)      
+        AC_DEFINE(MOZ_OJI_REQUIRE_THREAD_SAFE_ON_STARTUP)
+        ;;
+esac
+
+dnl ========================================================
+dnl = Flags to strip unused symbols from .so components
+dnl ========================================================
+case "$target" in
+    *-linux*|*-kfreebsd*-gnu)
+        MOZ_COMPONENTS_VERSION_SCRIPT_LDFLAGS='-Wl,--version-script -Wl,$(BUILD_TOOLS)/gnu-ld-scripts/components-version-script'
+        ;;
+    *-solaris*)
+        if test -z "$GNU_CC"; then
+         MOZ_COMPONENTS_VERSION_SCRIPT_LDFLAGS='-M $(BUILD_TOOLS)/gnu-ld-scripts/components-mapfile'
+        else
+         if test -z "$GCC_USE_GNU_LD"; then
+          MOZ_COMPONENTS_VERSION_SCRIPT_LDFLAGS='-Wl,-M -Wl,$(BUILD_TOOLS)/gnu-ld-scripts/components-mapfile'
+         else
+          MOZ_COMPONENTS_VERSION_SCRIPT_LDFLAGS='-Wl,--version-script -Wl,$(BUILD_TOOLS)/gnu-ld-scripts/components-version-script'
+         fi
+        fi
+        ;;
+    *-nto*) 
+        MOZ_COMPONENTS_VERSION_SCRIPT_LDFLAGS='-Wl,--version-script,$(BUILD_TOOLS)/gnu-ld-scripts/components-version-script'
+        ;;
+    *-darwin*)
+        MOZ_COMPONENTS_VERSION_SCRIPT_LDFLAGS='-Wl,-exported_symbols_list -Wl,$(BUILD_TOOLS)/gnu-ld-scripts/components-export-list'
+        ;;
+    *-cygwin*|*-mingw*|*-mks*|*-msvc|*-wince)
+        if test -n "$GNU_CC"; then
+           MOZ_COMPONENTS_VERSION_SCRIPT_LDFLAGS='-Wl,--version-script,$(BUILD_TOOLS)/gnu-ld-scripts/components-version-script'
+        fi
+        ;;
+esac
+
+if test -z "$COMPILE_ENVIRONMENT"; then
+    SKIP_COMPILER_CHECKS=1
+    SKIP_LIBRARY_CHECKS=1
+fi
+
+if test -z "$SKIP_COMPILER_CHECKS"; then
+dnl Checks for typedefs, structures, and compiler characteristics.
+dnl ========================================================
+AC_LANG_C
+AC_HEADER_STDC
+AC_C_CONST
+AC_TYPE_MODE_T
+AC_TYPE_OFF_T
+AC_TYPE_PID_T
+AC_TYPE_SIZE_T
+AC_STRUCT_ST_BLKSIZE
+AC_MSG_CHECKING(for siginfo_t)
+AC_CACHE_VAL(ac_cv_siginfo_t,
+ [AC_TRY_COMPILE([#define _POSIX_C_SOURCE 199506L
+                  #include <signal.h>],
+                 [siginfo_t* info;],
+                 [ac_cv_siginfo_t=true],
+                 [ac_cv_siginfo_t=false])])
+if test "$ac_cv_siginfo_t" = true ; then
+  AC_DEFINE(HAVE_SIGINFO_T)
+  AC_MSG_RESULT(yes)
+else
+  AC_MSG_RESULT(no)
+fi
+
+dnl Check for int16_t, int32_t, int64_t, int64, uint, uint_t, and uint16_t.
+dnl ========================================================
+AC_MSG_CHECKING(for int16_t)
+AC_CACHE_VAL(ac_cv_int16_t,
+ [AC_TRY_COMPILE([#include <stdio.h>
+                  #include <sys/types.h>],
+                 [int16_t foo = 0;],
+                 [ac_cv_int16_t=true],
+                 [ac_cv_int16_t=false])])
+if test "$ac_cv_int16_t" = true ; then
+  AC_DEFINE(HAVE_INT16_T)
+  AC_MSG_RESULT(yes)
+else
+  AC_MSG_RESULT(no)
+fi
+AC_MSG_CHECKING(for int32_t)
+AC_CACHE_VAL(ac_cv_int32_t,
+ [AC_TRY_COMPILE([#include <stdio.h>
+                  #include <sys/types.h>],
+                 [int32_t foo = 0;],
+                 [ac_cv_int32_t=true],
+                 [ac_cv_int32_t=false])])
+if test "$ac_cv_int32_t" = true ; then
+  AC_DEFINE(HAVE_INT32_T)
+  AC_MSG_RESULT(yes)
+else
+  AC_MSG_RESULT(no)
+fi
+AC_MSG_CHECKING(for int64_t)
+AC_CACHE_VAL(ac_cv_int64_t,
+ [AC_TRY_COMPILE([#include <stdio.h>
+                  #include <sys/types.h>],
+                 [int64_t foo = 0;],
+                 [ac_cv_int64_t=true],
+                 [ac_cv_int64_t=false])])
+if test "$ac_cv_int64_t" = true ; then
+  AC_DEFINE(HAVE_INT64_T)
+  AC_MSG_RESULT(yes)
+else
+  AC_MSG_RESULT(no)
+fi
+AC_MSG_CHECKING(for int64)
+AC_CACHE_VAL(ac_cv_int64,
+ [AC_TRY_COMPILE([#include <stdio.h>
+                  #include <sys/types.h>],
+                 [int64 foo = 0;],
+                 [ac_cv_int64=true],
+                 [ac_cv_int64=false])])
+if test "$ac_cv_int64" = true ; then
+  AC_DEFINE(HAVE_INT64)
+  AC_MSG_RESULT(yes)
+else
+  AC_MSG_RESULT(no)
+fi
+AC_MSG_CHECKING(for uint)
+AC_CACHE_VAL(ac_cv_uint,
+ [AC_TRY_COMPILE([#include <stdio.h>
+                  #include <sys/types.h>],
+                 [uint foo = 0;],
+                 [ac_cv_uint=true],
+                 [ac_cv_uint=false])])
+if test "$ac_cv_uint" = true ; then
+  AC_DEFINE(HAVE_UINT)
+  AC_MSG_RESULT(yes)
+else
+  AC_MSG_RESULT(no)
+fi
+AC_MSG_CHECKING(for uint_t)
+AC_CACHE_VAL(ac_cv_uint_t,
+ [AC_TRY_COMPILE([#include <stdio.h>
+                  #include <sys/types.h>],
+                 [uint_t foo = 0;],
+                 [ac_cv_uint_t=true],
+                 [ac_cv_uint_t=false])])
+if test "$ac_cv_uint_t" = true ; then
+  AC_DEFINE(HAVE_UINT_T)
+  AC_MSG_RESULT(yes)
+else
+  AC_MSG_RESULT(no)
+fi
+AC_MSG_CHECKING(for uint16_t)
+AC_CACHE_VAL(ac_cv_uint16_t,
+ [AC_TRY_COMPILE([#include <stdio.h>
+                  #include <sys/types.h>],
+                 [uint16_t foo = 0;],
+                 [ac_cv_uint16_t=true],
+                 [ac_cv_uint16_t=false])])
+if test "$ac_cv_uint16_t" = true ; then
+  AC_DEFINE(HAVE_UINT16_T)
+  AC_MSG_RESULT(yes)
+else
+  AC_MSG_RESULT(no)
+fi
+
+dnl On the gcc trunk (as of 2001-02-09) _GNU_SOURCE, and thus __USE_GNU,
+dnl are defined when compiling C++ but not C.  Since the result of this
+dnl test is used only in C++, do it in C++.
+AC_LANG_CPLUSPLUS
+
+AC_MSG_CHECKING(for uname.domainname)
+AC_CACHE_VAL(ac_cv_have_uname_domainname_field,
+    [AC_TRY_COMPILE([#include <sys/utsname.h>],
+        [ struct utsname *res; char *domain; 
+            (void)uname(res);  if (res != 0) { domain = res->domainname; } ],
+        [ac_cv_have_uname_domainname_field=true],
+        [ac_cv_have_uname_domainname_field=false])])
+
+if test "$ac_cv_have_uname_domainname_field" = "true"; then
+    AC_DEFINE(HAVE_UNAME_DOMAINNAME_FIELD)
+    AC_MSG_RESULT(yes)
+else
+    AC_MSG_RESULT(no)
+fi
+
+AC_MSG_CHECKING(for uname.__domainname)
+AC_CACHE_VAL(ac_cv_have_uname_us_domainname_field,
+    [AC_TRY_COMPILE([#include <sys/utsname.h>],
+        [ struct utsname *res; char *domain; 
+            (void)uname(res);  if (res != 0) { domain = res->__domainname; } ],
+        [ac_cv_have_uname_us_domainname_field=true],
+        [ac_cv_have_uname_us_domainname_field=false])])
+
+if test "$ac_cv_have_uname_us_domainname_field" = "true"; then
+    AC_DEFINE(HAVE_UNAME_US_DOMAINNAME_FIELD)
+    AC_MSG_RESULT(yes)
+else
+    AC_MSG_RESULT(no)
+fi
+
+AC_LANG_C
+
+dnl Check for usable wchar_t (2 bytes, unsigned)
+dnl (we really don't need the unsignedness check anymore)
+dnl ========================================================
+
+AC_CACHE_CHECK(for usable wchar_t (2 bytes, unsigned),
+    ac_cv_have_usable_wchar_v2,
+    [AC_TRY_COMPILE([#include <stddef.h>
+                     $configure_static_assert_macros],
+                    [CONFIGURE_STATIC_ASSERT(sizeof(wchar_t) == 2);
+                     CONFIGURE_STATIC_ASSERT((wchar_t)-1 > (wchar_t) 0)],
+                    ac_cv_have_usable_wchar_v2="yes",
+                    ac_cv_have_usable_wchar_v2="no")])
+if test "$ac_cv_have_usable_wchar_v2" = "yes"; then
+    AC_DEFINE(HAVE_CPP_2BYTE_WCHAR_T)
+    HAVE_CPP_2BYTE_WCHAR_T=1
+else
+dnl This is really gcc-only
+dnl Do this test using CXX only since some versions of gcc
+dnl 2.95-2.97 have a signed wchar_t in c++ only and some versions
+dnl only have short-wchar support for c++.
+dnl Note that we assume that mac & win32 have short wchar (see nscore.h)
+
+    AC_LANG_SAVE
+    AC_LANG_CPLUSPLUS
+    _SAVE_CXXFLAGS=$CXXFLAGS
+    CXXFLAGS="$CXXFLAGS -fshort-wchar"
+
+    AC_CACHE_CHECK(for compiler -fshort-wchar option, 
+        ac_cv_have_usable_wchar_option_v2,
+        [AC_TRY_LINK([#include <stddef.h>
+                      $configure_static_assert_macros],
+                     [CONFIGURE_STATIC_ASSERT(sizeof(wchar_t) == 2);
+                      CONFIGURE_STATIC_ASSERT((wchar_t)-1 > (wchar_t) 0)],
+                     ac_cv_have_usable_wchar_option_v2="yes",
+                     ac_cv_have_usable_wchar_option_v2="no")])
+
+    if test "$ac_cv_have_usable_wchar_option_v2" = "yes"; then
+        AC_DEFINE(HAVE_CPP_2BYTE_WCHAR_T)
+        HAVE_CPP_2BYTE_WCHAR_T=1
+        WCHAR_CFLAGS="-fshort-wchar"
+    else    
+        CXXFLAGS=$_SAVE_CXXFLAGS
+    fi
+    AC_LANG_RESTORE
+fi
+
+dnl Check for .hidden assembler directive and visibility attribute.
+dnl Borrowed from glibc configure.in
+dnl ===============================================================
+if test "$GNU_CC"; then
+  AC_CACHE_CHECK(for visibility(hidden) attribute,
+                 ac_cv_visibility_hidden,
+                 [cat > conftest.c <<EOF
+                  int foo __attribute__ ((visibility ("hidden"))) = 1;
+EOF
+                  ac_cv_visibility_hidden=no
+                  if ${CC-cc} -Werror -S conftest.c -o conftest.s >/dev/null 2>&1; then
+                    if egrep '\.(hidden|private_extern).*foo' conftest.s >/dev/null; then
+                      ac_cv_visibility_hidden=yes
+                    fi
+                  fi
+                  rm -f conftest.[cs]
+                 ])
+  if test "$ac_cv_visibility_hidden" = "yes"; then
+    AC_DEFINE(HAVE_VISIBILITY_HIDDEN_ATTRIBUTE)
+
+    AC_CACHE_CHECK(for visibility(default) attribute,
+                   ac_cv_visibility_default,
+                   [cat > conftest.c <<EOF
+                    int foo __attribute__ ((visibility ("default"))) = 1;
+EOF
+                    ac_cv_visibility_default=no
+                    if ${CC-cc} -fvisibility=hidden -Werror -S conftest.c -o conftest.s >/dev/null 2>&1; then
+                      if ! egrep '\.(hidden|private_extern).*foo' conftest.s >/dev/null; then
+                        ac_cv_visibility_default=yes
+                      fi
+                    fi
+                    rm -f conftest.[cs]
+                   ])
+    if test "$ac_cv_visibility_default" = "yes"; then
+      AC_DEFINE(HAVE_VISIBILITY_ATTRIBUTE)
+
+      AC_CACHE_CHECK(for visibility pragma support,
+                     ac_cv_visibility_pragma,
+                     [cat > conftest.c <<EOF
+#pragma GCC visibility push(hidden)
+                      int foo_hidden = 1;
+#pragma GCC visibility push(default)
+                      int foo_default = 1;
+EOF
+                      ac_cv_visibility_pragma=no
+                      if ${CC-cc} -Werror -S conftest.c -o conftest.s >/dev/null 2>&1; then
+                        if egrep '\.(hidden|private_extern).*foo_hidden' conftest.s >/dev/null; then
+                          if ! egrep '\.(hidden|private_extern).*foo_default' conftest.s > /dev/null; then
+                            ac_cv_visibility_pragma=yes
+                          fi
+                        fi
+                      fi
+                      rm -f conftest.[cs]
+                    ])
+      if test "$ac_cv_visibility_pragma" = "yes"; then
+        AC_CACHE_CHECK(For gcc visibility bug with class-level attributes (GCC bug 26905),
+                       ac_cv_have_visibility_class_bug,
+                       [cat > conftest.c <<EOF
+#pragma GCC visibility push(hidden)
+struct __attribute__ ((visibility ("default"))) TestStruct {
+  static void Init();
+};
+__attribute__ ((visibility ("default"))) void TestFunc() {
+  TestStruct::Init();
+}
+EOF
+                       ac_cv_have_visibility_class_bug=no
+                       if ! ${CXX-g++} ${CXXFLAGS} ${DSO_PIC_CFLAGS} ${DSO_LDOPTS} -S -o conftest.S conftest.c > /dev/null 2>&1 ; then
+                         ac_cv_have_visibility_class_bug=yes
+                       else
+                         if test `egrep -c '@PLT|\\$stub' conftest.S` = 0; then
+                           ac_cv_have_visibility_class_bug=yes
+                         fi
+                       fi
+                       rm -rf conftest.{c,S}
+                       ])
+
+        AC_CACHE_CHECK(For x86_64 gcc visibility bug with builtins (GCC bug 20297),
+                       ac_cv_have_visibility_builtin_bug,
+                       [cat > conftest.c <<EOF
+#pragma GCC visibility push(hidden)
+#pragma GCC visibility push(default)
+#include <string.h>
+#pragma GCC visibility pop
+
+__attribute__ ((visibility ("default"))) void Func() {
+  char c[[100]];
+  memset(c, 0, sizeof(c));
+}
+EOF
+                       ac_cv_have_visibility_builtin_bug=no
+                       if ! ${CC-cc} ${CFLAGS} ${DSO_PIC_CFLAGS} ${DSO_LDOPTS} -O2 -S -o conftest.S conftest.c > /dev/null 2>&1 ; then
+                         ac_cv_have_visibility_builtin_bug=yes
+                       else
+                         if test `grep -c "@PLT" conftest.S` = 0; then
+                           ac_cv_visibility_builtin_bug=yes
+                         fi
+                       fi
+                       rm -f conftest.{c,S}
+                       ])
+        if test "$ac_cv_have_visibility_builtin_bug" = "no" -a \
+                "$ac_cv_have_visibility_class_bug" = "no"; then
+          VISIBILITY_FLAGS='-I$(DIST)/include/system_wrappers -include $(topsrcdir)/config/gcc_hidden.h'
+          WRAP_SYSTEM_INCLUDES=1
+        else
+          VISIBILITY_FLAGS='-fvisibility=hidden'
+        fi # have visibility pragma bug
+      fi   # have visibility pragma
+    fi     # have visibility(default) attribute
+  fi       # have visibility(hidden) attribute
+fi         # GNU_CC
+
+# visibility hidden flag for Sun Studio on Solaris
+if test -z "$GNU_CC" && test -z "$GNU_CXX" && test "$OS_ARCH" = "SunOS"; then
+VISIBILITY_FLAGS='-xldscope=hidden'
+fi         # Sun Studio on Solaris
+
+AC_SUBST(WRAP_SYSTEM_INCLUDES)
+AC_SUBST(VISIBILITY_FLAGS)
+
+dnl Checks for header files.
+dnl ========================================================
+AC_HEADER_DIRENT
+case "$target_os" in
+freebsd*)
+# for stuff like -lXshm
+    CPPFLAGS="${CPPFLAGS} ${X_CFLAGS}"
+    ;;
+esac
+AC_CHECK_HEADERS(sys/byteorder.h compat.h getopt.h)
+AC_CHECK_HEADERS(sys/bitypes.h memory.h unistd.h)
+AC_CHECK_HEADERS(gnu/libc-version.h nl_types.h)
+AC_CHECK_HEADERS(malloc.h)
+AC_CHECK_HEADERS(X11/XKBlib.h)
+
+dnl These are all the places some variant of statfs can be hiding.
+AC_CHECK_HEADERS(sys/statvfs.h sys/statfs.h sys/vfs.h sys/mount.h)
+
+dnl Try for MMX support
+dnl NB - later gcc versions require -mmmx for this header to be successfully
+dnl included (or another option which implies it, such as -march=pentium-mmx)
+AC_CHECK_HEADERS(mmintrin.h)
+
+AC_MSG_CHECKING(for ARM SIMD support)
+AC_TRY_COMPILE([],
+               [asm("uqadd8 r1, r1, r2");],
+               result="yes", result="no")
+AC_MSG_RESULT("$result")
+if test "$result" = "yes"; then
+    AC_DEFINE(HAVE_ARM_SIMD)
+    HAVE_ARM_SIMD=1
+fi
+AC_SUBST(HAVE_ARM_SIMD)
+
+dnl Check whether the compiler supports the new-style C++ standard
+dnl library headers (i.e. <new>) or needs the old "new.h"
+AC_LANG_CPLUSPLUS
+NEW_H=new.h
+AC_CHECK_HEADER(new, [NEW_H=new])
+AC_DEFINE_UNQUOTED(NEW_H, <$NEW_H>)
+AC_LANG_C
+
+AC_ARG_ENABLE(dtrace,
+              [  --enable-dtrace         build with dtrace support if available (default=no)],
+              [enable_dtrace="yes"],)
+if test "x$enable_dtrace" = "xyes"; then
+  AC_CHECK_HEADER(sys/sdt.h, HAVE_DTRACE=1)
+  if test -n "$HAVE_DTRACE"; then
+      AC_DEFINE(INCLUDE_MOZILLA_DTRACE)
+  else
+      AC_MSG_ERROR([dtrace enabled but sys/sdt.h not found]);
+  fi
+fi
+AC_SUBST(HAVE_DTRACE)
+
+case $target in
+*-aix4.3*|*-aix5*)
+	;;
+*)
+	AC_CHECK_HEADERS(sys/cdefs.h)
+	;;
+esac
+
+dnl Checks for libraries.
+dnl ========================================================
+case $target in
+*-hpux11.*)
+	;;
+*)
+	AC_CHECK_LIB(c_r, gethostbyname_r)
+	;;
+esac
+
+dnl We don't want to link with libdl even if it's present on OS X, since
+dnl it's not used and not part of the default installation.
+dnl The same goes for BeOS.
+dnl We don't want to link against libm or libpthread on Darwin since
+dnl they both are just symlinks to libSystem and explicitly linking
+dnl against libSystem causes issues when debugging (see bug 299601).
+case $target in
+*-darwin*)
+    ;;
+*-beos*)
+    ;;
+*)
+    AC_CHECK_LIB(m, atan)
+    AC_CHECK_LIB(dl, dlopen,
+    AC_CHECK_HEADER(dlfcn.h, 
+        LIBS="-ldl $LIBS"
+        AC_DEFINE(HAVE_LIBDL)))
+    ;;
+esac
+
+_SAVE_CFLAGS="$CFLAGS"
+CFLAGS="$CFLAGS -D_GNU_SOURCE"
+AC_CHECK_FUNCS(dladdr)
+CFLAGS="$_SAVE_CFLAGS"
+
+if test ! "$GNU_CXX"; then
+
+    case $target in
+    *-aix*)
+	AC_CHECK_LIB(C_r, demangle)
+	;;
+     *)
+	AC_CHECK_LIB(C, demangle)
+	;;
+     esac
+fi
+AC_CHECK_LIB(socket, socket)
+
+dnl ========================================================
+dnl = pthread support
+dnl = Start by checking whether the system support pthreads
+dnl ========================================================
+case "$target_os" in
+darwin*)
+    USE_PTHREADS=1
+    ;;
+*)
+    MOZ_CHECK_PTHREADS(pthreads,
+        USE_PTHREADS=1 _PTHREAD_LDFLAGS="-lpthreads",
+        MOZ_CHECK_PTHREADS(pthread,
+            USE_PTHREADS=1 _PTHREAD_LDFLAGS="-lpthread",
+            MOZ_CHECK_PTHREADS(c_r,
+                USE_PTHREADS=1 _PTHREAD_LDFLAGS="-lc_r",
+                MOZ_CHECK_PTHREADS(c,
+                    USE_PTHREADS=1
+                )
+            )
+        )
+    )
+    ;;
+esac
+
+dnl ========================================================
+dnl Check the command line for --with-pthreads 
+dnl ========================================================
+MOZ_ARG_WITH_BOOL(pthreads,
+[  --with-pthreads         Force use of system pthread library with NSPR ],
+[ if test "$USE_PTHREADS"x = x; then
+    AC_MSG_ERROR([ --with-pthreads specified for a system without pthread support ]);
+fi],
+    USE_PTHREADS=
+    _PTHREAD_LDFLAGS=
+)
+
+dnl ========================================================
+dnl Do the platform specific pthread hackery
+dnl ========================================================
+if test "$USE_PTHREADS"x != x
+then
+	dnl
+	dnl See if -pthread is supported.
+	dnl
+	rm -f conftest*
+	ac_cv_have_dash_pthread=no
+	AC_MSG_CHECKING(whether ${CC-cc} accepts -pthread)
+	echo 'int main() { return 0; }' | cat > conftest.c
+	${CC-cc} -pthread -o conftest conftest.c > conftest.out 2>&1
+	if test $? -eq 0; then
+		if test -z "`egrep -i '(unrecognize|unknown)' conftest.out | grep pthread`" && test -z "`egrep -i '(error|incorrect)' conftest.out`" ; then
+			ac_cv_have_dash_pthread=yes
+	        case "$target_os" in
+	        freebsd*)
+# Freebsd doesn't use -pthread for compiles, it uses them for linking
+                ;;
+	        *)
+			    CFLAGS="$CFLAGS -pthread"
+			    CXXFLAGS="$CXXFLAGS -pthread"
+                ;;
+	        esac
+		fi
+	fi
+	rm -f conftest*
+    AC_MSG_RESULT($ac_cv_have_dash_pthread)
+
+	dnl
+	dnl See if -pthreads is supported.
+	dnl
+    ac_cv_have_dash_pthreads=no
+    if test "$ac_cv_have_dash_pthread" = "no"; then
+	    AC_MSG_CHECKING(whether ${CC-cc} accepts -pthreads)
+    	echo 'int main() { return 0; }' | cat > conftest.c
+	    ${CC-cc} -pthreads -o conftest conftest.c > conftest.out 2>&1
+    	if test $? -eq 0; then
+	    	if test -z "`egrep -i '(unrecognize|unknown)' conftest.out | grep pthreads`" && test -z "`egrep -i '(error|incorrect)' conftest.out`" ; then
+			    ac_cv_have_dash_pthreads=yes
+			    CFLAGS="$CFLAGS -pthreads"
+			    CXXFLAGS="$CXXFLAGS -pthreads"
+		    fi
+	    fi
+	    rm -f conftest*
+    	AC_MSG_RESULT($ac_cv_have_dash_pthreads)
+    fi
+
+	case "$target" in
+	    *-*-freebsd*)
+			AC_DEFINE(_REENTRANT)
+			AC_DEFINE(_THREAD_SAFE)
+			dnl -pthread links in -lc_r, so don't specify it explicitly.
+			if test "$ac_cv_have_dash_pthread" = "yes"; then
+				_PTHREAD_LDFLAGS="-pthread"
+			else
+				_PTHREAD_LDFLAGS="-lc_r"
+			fi
+			;;
+
+	    *-*-openbsd*|*-*-bsdi*)
+			AC_DEFINE(_REENTRANT)
+			AC_DEFINE(_THREAD_SAFE)
+			dnl -pthread links in -lc_r, so don't specify it explicitly.
+			if test "$ac_cv_have_dash_pthread" = "yes"; then
+                _PTHREAD_LDFLAGS="-pthread"
+			fi
+			;;
+
+	    *-*-linux*|*-*-kfreebsd*-gnu)
+			AC_DEFINE(_REENTRANT) 
+			;;
+
+	    *-*-nto*) 
+			AC_DEFINE(_REENTRANT) 
+			;;
+
+	    *-aix4.3*|*-aix5*)
+			AC_DEFINE(_REENTRANT) 
+			;;
+
+	    *-hpux11.*)
+			AC_DEFINE(_REENTRANT) 
+			;;
+
+	    alpha*-*-osf*)
+			AC_DEFINE(_REENTRANT)
+			;;
+
+	    *-*-solaris*) 
+    			AC_DEFINE(_REENTRANT) 
+			if test ! "$GNU_CC"; then
+				CFLAGS="$CFLAGS -mt" 
+				CXXFLAGS="$CXXFLAGS -mt" 
+			fi
+			;;
+	esac
+    LDFLAGS="${_PTHREAD_LDFLAGS} ${LDFLAGS}"
+fi
+
+dnl ========================================================
+dnl See if mmap sees writes
+dnl For cross compiling, just define it as no, which is a safe default
+dnl ========================================================
+AC_MSG_CHECKING(whether mmap() sees write()s)
+
+changequote(,)
+mmap_test_prog='
+    #include <stdlib.h>
+    #include <unistd.h>
+    #include <sys/mman.h>
+    #include <sys/types.h>
+    #include <sys/stat.h>
+    #include <fcntl.h>
+
+    char fname[] = "conftest.file";
+    char zbuff[1024]; /* Fractional page is probably worst case */
+
+    int main() {
+	char *map;
+	int fd;
+	int i;
+	unlink(fname);
+	fd = open(fname, O_RDWR | O_CREAT, 0660);
+	if(fd<0) return 1;
+	unlink(fname);
+	write(fd, zbuff, sizeof(zbuff));
+	lseek(fd, 0, SEEK_SET);
+	map = (char*)mmap(0, sizeof(zbuff), PROT_READ, MAP_SHARED, fd, 0);
+	if(map==(char*)-1) return 2;
+	for(i=0; fname[i]; i++) {
+	    int rc = write(fd, &fname[i], 1);
+	    if(map[i]!=fname[i]) return 4;
+	}
+	return 0;
+    }
+'
+changequote([,])
+
+AC_TRY_RUN($mmap_test_prog , result="yes", result="no", result="yes")
+
+AC_MSG_RESULT("$result")
+
+if test "$result" = "no"; then
+    AC_DEFINE(MMAP_MISSES_WRITES)
+fi
+
+
+dnl Checks for library functions.
+dnl ========================================================
+AC_PROG_GCC_TRADITIONAL
+AC_FUNC_MEMCMP
+AC_CHECK_FUNCS(random strerror lchown fchmod snprintf statvfs memmove rint stat64 lstat64 truncate64 statvfs64)
+AC_CHECK_FUNCS(flockfile getpagesize)
+
+dnl localtime_r and strtok_r are only present on MacOS version 10.2 and higher
+if test -z "$MACOS_DEPLOYMENT_TARGET" || test "$MACOS_DEPLOYMENT_TARGET" -ge "100200"; then
+  AC_CHECK_FUNCS(localtime_r strtok_r)
+fi
+
+dnl check for wcrtomb/mbrtowc
+dnl =======================================================================
+if test -z "$MACOS_DEPLOYMENT_TARGET" || test "$MACOS_DEPLOYMENT_TARGET" -ge "100300"; then
+AC_LANG_SAVE
+AC_LANG_CPLUSPLUS
+AC_CACHE_CHECK(for wcrtomb,
+    ac_cv_have_wcrtomb,
+    [AC_TRY_LINK([#include <wchar.h>],
+                 [mbstate_t ps={0};wcrtomb(0,'f',&ps);],
+                 ac_cv_have_wcrtomb="yes",
+                 ac_cv_have_wcrtomb="no")])
+if test "$ac_cv_have_wcrtomb" = "yes"; then
+    AC_DEFINE(HAVE_WCRTOMB)
+fi
+AC_CACHE_CHECK(for mbrtowc,
+    ac_cv_have_mbrtowc,
+    [AC_TRY_LINK([#include <wchar.h>],
+                 [mbstate_t ps={0};mbrtowc(0,0,0,&ps);],
+                 ac_cv_have_mbrtowc="yes",
+                 ac_cv_have_mbrtowc="no")])
+if test "$ac_cv_have_mbrtowc" = "yes"; then
+    AC_DEFINE(HAVE_MBRTOWC)
+fi
+AC_LANG_RESTORE
+fi
+
+AC_CACHE_CHECK(
+    [for res_ninit()],
+    ac_cv_func_res_ninit,
+    [AC_TRY_LINK([
+        #ifdef linux
+        #define _BSD_SOURCE 1
+        #endif
+        #include <resolv.h>
+        ],
+        [int foo = res_ninit(&_res);],
+        [ac_cv_func_res_ninit=yes],
+        [ac_cv_func_res_ninit=no])
+    ])
+
+if test "$ac_cv_func_res_ninit" = "yes"; then
+    AC_DEFINE(HAVE_RES_NINIT)
+dnl must add the link line we do something as foolish as this... dougt
+dnl else
+dnl    AC_CHECK_LIB(bind, res_ninit, AC_DEFINE(HAVE_RES_NINIT),
+dnl        AC_CHECK_LIB(resolv, res_ninit, AC_DEFINE(HAVE_RES_NINIT)))
+fi
+
+AC_LANG_CPLUSPLUS
+AC_CACHE_CHECK(
+    [for gnu_get_libc_version()],
+    ac_cv_func_gnu_get_libc_version,
+    [AC_TRY_LINK([
+        #ifdef HAVE_GNU_LIBC_VERSION_H
+        #include <gnu/libc-version.h>
+        #endif
+        ],
+        [const char *glibc_version = gnu_get_libc_version();],
+        [ac_cv_func_gnu_get_libc_version=yes],
+        [ac_cv_func_gnu_get_libc_version=no] 
+        )]
+    )
+
+if test "$ac_cv_func_gnu_get_libc_version" = "yes"; then
+    AC_DEFINE(HAVE_GNU_GET_LIBC_VERSION)
+fi
+
+case $target_os in
+    os2*|msvc*|mks*|cygwin*|mingw*|darwin*|wince*|beos*)
+        ;;
+    *)
+    
+AC_CHECK_LIB(c, iconv, [_ICONV_LIBS="$_ICONV_LIBS"],
+    AC_CHECK_LIB(iconv, iconv, [_ICONV_LIBS="$_ICONV_LIBS -liconv"],
+        AC_CHECK_LIB(iconv, libiconv, [_ICONV_LIBS="$_ICONV_LIBS -liconv"])))
+_SAVE_LIBS=$LIBS
+LIBS="$LIBS $_ICONV_LIBS"
+AC_CACHE_CHECK(
+    [for iconv()],
+    ac_cv_func_iconv,
+    [AC_TRY_LINK([
+        #include <stdlib.h>
+        #include <iconv.h>
+        ],
+        [
+            iconv_t h = iconv_open("", "");
+            iconv(h, NULL, NULL, NULL, NULL);
+            iconv_close(h);
+        ],
+        [ac_cv_func_iconv=yes],
+        [ac_cv_func_iconv=no] 
+        )]
+    )
+if test "$ac_cv_func_iconv" = "yes"; then
+    AC_DEFINE(HAVE_ICONV)
+    DYNAMIC_XPCOM_LIBS="$DYNAMIC_XPCOM_LIBS $_ICONV_LIBS"
+    LIBXUL_LIBS="$LIBXUL_LIBS $_ICONV_LIBS"
+    LIBICONV="$_ICONV_LIBS"
+    AC_CACHE_CHECK(
+        [for iconv() with const input],
+        ac_cv_func_const_iconv,
+        [AC_TRY_COMPILE([
+            #include <stdlib.h>
+            #include <iconv.h>
+            ],
+            [
+                const char *input = "testing";
+                iconv_t h = iconv_open("", "");
+                iconv(h, &input, NULL, NULL, NULL);
+                iconv_close(h);
+            ],
+            [ac_cv_func_const_iconv=yes],
+            [ac_cv_func_const_iconv=no] 
+            )]
+        )
+    if test "$ac_cv_func_const_iconv" = "yes"; then
+        AC_DEFINE(HAVE_ICONV_WITH_CONST_INPUT)
+    fi
+fi
+LIBS=$_SAVE_LIBS
+
+    ;;
+esac
+
+AC_LANG_C
+
+dnl **********************
+dnl *** va_copy checks ***
+dnl **********************
+dnl we currently check for all three va_copy possibilities, so we get
+dnl all results in config.log for bug reports.
+AC_MSG_CHECKING(for an implementation of va_copy())
+AC_CACHE_VAL(ac_cv_va_copy,[
+    AC_TRY_RUN([
+        #include <stdarg.h>
+        void f (int i, ...) {
+            va_list args1, args2;
+            va_start (args1, i);
+            va_copy (args2, args1);
+            if (va_arg (args2, int) != 42 || va_arg (args1, int) != 42)
+                exit (1);
+            va_end (args1); va_end (args2);
+        }
+        int main() { f (0, 42); return 0; }],
+        ac_cv_va_copy=yes,
+        ac_cv_va_copy=no,
+        ac_cv_va_copy=no
+    )
+])
+AC_MSG_RESULT($ac_cv_va_copy)
+AC_MSG_CHECKING(for an implementation of __va_copy())
+AC_CACHE_VAL(ac_cv___va_copy,[
+    AC_TRY_RUN([
+        #include <stdarg.h>
+        void f (int i, ...) {
+            va_list args1, args2;
+            va_start (args1, i);
+            __va_copy (args2, args1);
+            if (va_arg (args2, int) != 42 || va_arg (args1, int) != 42)
+                exit (1);
+            va_end (args1); va_end (args2);
+        }
+        int main() { f (0, 42); return 0; }],
+        ac_cv___va_copy=yes,
+        ac_cv___va_copy=no,
+        ac_cv___va_copy=no
+    )
+])
+AC_MSG_RESULT($ac_cv___va_copy)
+AC_MSG_CHECKING(whether va_lists can be copied by value)
+AC_CACHE_VAL(ac_cv_va_val_copy,[
+    AC_TRY_RUN([
+        #include <stdarg.h>
+        void f (int i, ...) {
+            va_list args1, args2;
+            va_start (args1, i);
+            args2 = args1;
+            if (va_arg (args2, int) != 42 || va_arg (args1, int) != 42)
+                exit (1);
+            va_end (args1); va_end (args2);
+        }
+        int main() { f (0, 42); return 0; }],
+        ac_cv_va_val_copy=yes,
+        ac_cv_va_val_copy=no,
+        ac_cv_va_val_copy=yes
+    )
+])
+if test "x$ac_cv_va_copy" = "xyes"; then
+    AC_DEFINE(VA_COPY, va_copy)
+    AC_DEFINE(HAVE_VA_COPY)
+elif test "x$ac_cv___va_copy" = "xyes"; then
+    AC_DEFINE(VA_COPY, __va_copy)
+    AC_DEFINE(HAVE_VA_COPY)
+fi
+
+if test "x$ac_cv_va_val_copy" = "xno"; then
+   AC_DEFINE(HAVE_VA_LIST_AS_ARRAY)
+fi
+AC_MSG_RESULT($ac_cv_va_val_copy)
+
+dnl Check for dll-challenged libc's.
+dnl This check is apparently only needed for Linux.
+case "$target" in
+	*-linux*)
+	    dnl ===================================================================
+	    _curdir=`pwd`
+	    export _curdir
+	    rm -rf conftest* _conftest
+	    mkdir _conftest
+	    cat >> conftest.C <<\EOF
+#include <stdio.h>
+#include <link.h>
+#include <dlfcn.h>
+#ifdef _dl_loaded
+void __dump_link_map(void) {
+  struct link_map *map = _dl_loaded;
+  while (NULL != map) {printf("0x%08x %s\n", map->l_addr, map->l_name); map = map->l_next;}
+}
+int main() {
+  dlopen("./conftest1.so",RTLD_LAZY);
+  dlopen("./../_conftest/conftest1.so",RTLD_LAZY);
+  dlopen("CURDIR/_conftest/conftest1.so",RTLD_LAZY);
+  dlopen("CURDIR/_conftest/../_conftest/conftest1.so",RTLD_LAZY);
+  __dump_link_map();
+}
+#else
+/* _dl_loaded isn't defined, so this should be either a libc5 (glibc1) system, or a glibc2 system that doesn't have the multiple load bug (i.e., RH6.0).*/
+int main() { printf("./conftest1.so\n"); }
+#endif
+EOF
+
+	    $PERL -p -i -e "s/CURDIR/\$ENV{_curdir}/g;" conftest.C
+
+	    cat >> conftest1.C <<\EOF
+#include <stdio.h>
+void foo(void) {printf("foo in dll called\n");}
+EOF
+	    ${CXX-g++} -fPIC -c -g conftest1.C
+	    ${CXX-g++} -shared -Wl,-h -Wl,conftest1.so -o conftest1.so conftest1.o
+	    ${CXX-g++} -g conftest.C -o conftest -ldl
+	    cp -f conftest1.so conftest _conftest
+	    cd _conftest
+	    if test `./conftest | grep conftest1.so | wc -l` -gt 1
+	    then
+		echo
+		echo "*** Your libc has a bug that can result in loading the same dynamic"
+		echo "*** library multiple times.  This bug is known to be fixed in glibc-2.0.7-32"
+		echo "*** or later.  However, if you choose not to upgrade, the only effect"
+		echo "*** will be excessive memory usage at runtime."
+		echo
+	    fi
+	    cd ${_curdir}
+	    rm -rf conftest* _conftest
+	    dnl ===================================================================
+	    ;;
+esac
+
+dnl ===================================================================
+dnl ========================================================
+dnl By default, turn rtti and exceptions off on g++/egcs
+dnl ========================================================
+if test "$GNU_CXX"; then
+
+  AC_MSG_CHECKING(for C++ exceptions flag)
+
+  dnl They changed -f[no-]handle-exceptions to -f[no-]exceptions in g++ 2.8
+  AC_CACHE_VAL(ac_cv_cxx_exceptions_flags,
+  [echo "int main() { return 0; }" | cat > conftest.C
+
+  ${CXX-g++} ${CXXFLAGS} -c -fno-handle-exceptions conftest.C > conftest.out 2>&1
+
+  if egrep "warning.*renamed" conftest.out >/dev/null; then
+    ac_cv_cxx_exceptions_flags=${_COMPILER_PREFIX}-fno-exceptions
+  else
+    ac_cv_cxx_exceptions_flags=${_COMPILER_PREFIX}-fno-handle-exceptions
+  fi
+
+  rm -f conftest*])
+
+  AC_MSG_RESULT($ac_cv_cxx_exceptions_flags)
+  _MOZ_EXCEPTIONS_FLAGS_OFF=$ac_cv_cxx_exceptions_flags
+  _MOZ_EXCEPTIONS_FLAGS_ON=`echo $ac_cv_cxx_exceptions_flags | sed 's|no-||'`
+fi
+
+dnl ========================================================
+dnl Put your C++ language/feature checks below
+dnl ========================================================
+AC_LANG_CPLUSPLUS
+
+HAVE_GCC3_ABI=
+if test "$GNU_CC"; then
+  AC_CACHE_CHECK(for gcc 3.0 ABI,
+      ac_cv_gcc_three_abi,
+      [AC_TRY_COMPILE([],
+                      [
+#if defined(__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100 /* G++ V3 ABI */
+  return 0;
+#else
+#error Not gcc3.
+#endif
+                      ],
+                      ac_cv_gcc_three_abi="yes",
+                      ac_cv_gcc_three_abi="no")])
+  if test "$ac_cv_gcc_three_abi" = "yes"; then
+      TARGET_COMPILER_ABI="${TARGET_COMPILER_ABI-gcc3}"
+      HAVE_GCC3_ABI=1
+  else
+      TARGET_COMPILER_ABI="${TARGET_COMPILER_ABI-gcc2}"
+  fi
+fi
+AC_SUBST(HAVE_GCC3_ABI)
+
+
+AC_CACHE_CHECK(for C++ \"explicit\" keyword,
+               ac_cv_cpp_explicit,
+               [AC_TRY_COMPILE(class X {
+                               public: explicit X(int i) : i_(i) {}
+                               private: int i_;
+                               };,
+                               X x(3);,
+                               ac_cv_cpp_explicit=yes,
+                               ac_cv_cpp_explicit=no)])
+if test "$ac_cv_cpp_explicit" = yes ; then
+   AC_DEFINE(HAVE_CPP_EXPLICIT)
+fi
+
+AC_CACHE_CHECK(for C++ \"typename\" keyword,
+               ac_cv_cpp_typename,
+               [AC_TRY_COMPILE(class param {
+                               public:
+                                   typedef unsigned long num_type;
+                               };
+
+                               template <class T> class tplt {
+                               public:
+                                   typedef typename T::num_type t_num_type;
+                                   t_num_type foo(typename T::num_type num) {
+                                       return num;
+                                   }
+                               };,
+                               tplt<param> A;
+                               A.foo(0);,
+                               ac_cv_cpp_typename=yes,
+                               ac_cv_cpp_typename=no)])
+if test "$ac_cv_cpp_typename" = yes ; then
+   AC_DEFINE(HAVE_CPP_TYPENAME)
+fi
+
+dnl Check for support of modern template specialization syntax
+dnl Test code and requirement from scc@netscape.com.
+dnl Autoconf cut-and-paste job by waterson@netscape.com
+AC_CACHE_CHECK(for modern C++ template specialization syntax support,
+               ac_cv_cpp_modern_specialize_template_syntax,
+               [AC_TRY_COMPILE(template <class T> struct X { int a; };
+                               class Y {};
+                               template <> struct X<Y> { double a; };,
+                               X<int> int_x;
+                               X<Y> y_x;,
+                               ac_cv_cpp_modern_specialize_template_syntax=yes,
+                               ac_cv_cpp_modern_specialize_template_syntax=no)])
+if test "$ac_cv_cpp_modern_specialize_template_syntax" = yes ; then
+  AC_DEFINE(HAVE_CPP_MODERN_SPECIALIZE_TEMPLATE_SYNTAX)
+fi
+
+
+dnl Some compilers support only full specialization, and some don't.
+AC_CACHE_CHECK(whether partial template specialization works,
+               ac_cv_cpp_partial_specialization,
+               [AC_TRY_COMPILE(template <class T> class Foo {};
+                               template <class T> class Foo<T*> {};,
+                               return 0;,
+                               ac_cv_cpp_partial_specialization=yes,
+                               ac_cv_cpp_partial_specialization=no)])
+if test "$ac_cv_cpp_partial_specialization" = yes ; then
+  AC_DEFINE(HAVE_CPP_PARTIAL_SPECIALIZATION)
+fi
+
+dnl Some compilers have limited support for operators with templates;
+dnl specifically, it is necessary to define derived operators when a base
+dnl class's operator declaration should suffice.
+AC_CACHE_CHECK(whether operators must be re-defined for templates derived from templates,
+               ac_cv_need_derived_template_operators,
+               [AC_TRY_COMPILE([template <class T> class Base { };
+                                template <class T>
+                                Base<T> operator+(const Base<T>& lhs, const Base<T>& rhs) { return lhs; }
+                                template <class T> class Derived : public Base<T> { };],
+                               [Derived<char> a, b;
+                                Base<char> c = a + b;
+                                return 0;],
+                               ac_cv_need_derived_template_operators=no,
+                               ac_cv_need_derived_template_operators=yes)])
+if test "$ac_cv_need_derived_template_operators" = yes ; then
+  AC_DEFINE(NEED_CPP_DERIVED_TEMPLATE_OPERATORS)
+fi
+
+
+dnl Some compilers have trouble detecting that a template class
+dnl that derives from another template is actually an instance
+dnl of the base class. This test checks for that.
+AC_CACHE_CHECK(whether we need to cast a derived template to pass as its base class,
+               ac_cv_need_cpp_template_cast_to_base,
+               [AC_TRY_COMPILE([template <class T> class Base { };
+                                template <class T> class Derived : public Base<T> { };
+                                template <class T> int foo(const Base<T>&) { return 0; }],
+                               [Derived<char> bar; return foo(bar);],
+                               ac_cv_need_cpp_template_cast_to_base=no,
+                               ac_cv_need_cpp_template_cast_to_base=yes)])
+if test "$ac_cv_need_cpp_template_cast_to_base" = yes ; then
+  AC_DEFINE(NEED_CPP_TEMPLATE_CAST_TO_BASE)
+fi
+
+dnl Some compilers have trouble resolving the ambiguity between two
+dnl functions whose arguments differ only by cv-qualifications.
+AC_CACHE_CHECK(whether the compiler can resolve const ambiguities for templates,
+               ac_cv_can_resolve_const_ambiguity,
+               [AC_TRY_COMPILE([
+                                template <class T> class ptrClass {
+                                  public: T* ptr;
+                                };
+
+                                template <class T> T* a(ptrClass<T> *arg) {
+                                  return arg->ptr;
+                                }
+
+                                template <class T>
+                                const T* a(const ptrClass<T> *arg) {
+                                  return arg->ptr;
+                                }
+                               ],
+                               [ ptrClass<int> i;
+                                 a(&i); ],
+                               ac_cv_can_resolve_const_ambiguity=yes,
+                               ac_cv_can_resolve_const_ambiguity=no)])
+if test "$ac_cv_can_resolve_const_ambiguity" = no ; then
+  AC_DEFINE(CANT_RESOLVE_CPP_CONST_AMBIGUITY)
+fi
+
+dnl
+dnl We don't do exceptions on unix.  The only reason this used to be here
+dnl is that mozilla/xpcom/tests/TestCOMPtr.cpp has a test which uses 
+dnl exceptions.  But, we turn exceptions off by default and this test breaks.
+dnl So im commenting this out until someone writes some artificial 
+dnl intelligence to detect not only if the compiler has exceptions, but if 
+dnl they are enabled as well.
+dnl 
+dnl AC_CACHE_CHECK(for C++ \"exceptions\",
+dnl                ac_cv_cpp_exceptions,
+dnl                [AC_TRY_COMPILE(class X { public: X() {} };
+dnl                                static void F() { throw X(); },
+dnl                                try { F(); } catch(X & e) { },
+dnl                                ac_cv_cpp_exceptions=yes,
+dnl                                ac_cv_cpp_exceptions=no)])
+dnl if test $ac_cv_cpp_exceptions = yes ; then
+dnl    AC_DEFINE(HAVE_CPP_EXCEPTIONS)
+dnl fi
+
+dnl Some compilers have marginal |using| support; for example, gcc-2.7.2.3
+dnl supports it well enough to allow us to use it to change access, but not
+dnl to resolve ambiguity. The next two tests determine how well the |using|
+dnl keyword is supported.
+dnl
+dnl Check to see if we can change access with |using|.  Test both a
+dnl legal and an illegal example.
+AC_CACHE_CHECK(whether the C++ \"using\" keyword can change access,
+               ac_cv_cpp_access_changing_using2,
+               [AC_TRY_COMPILE(
+                   class A { protected: int foo() { return 0; } };
+                   class B : public A { public: using A::foo; };,
+                   B b; return b.foo();,
+                   [AC_TRY_COMPILE(
+                       class A { public: int foo() { return 1; } };
+                       class B : public A { private: using A::foo; };,
+                       B b; return b.foo();,
+                       ac_cv_cpp_access_changing_using2=no,
+                       ac_cv_cpp_access_changing_using2=yes)],
+                   ac_cv_cpp_access_changing_using2=no)])
+if test "$ac_cv_cpp_access_changing_using2" = yes ; then
+   AC_DEFINE(HAVE_CPP_ACCESS_CHANGING_USING)
+fi
+
+dnl Check to see if we can resolve ambiguity with |using|.
+AC_CACHE_CHECK(whether the C++ \"using\" keyword resolves ambiguity,
+               ac_cv_cpp_ambiguity_resolving_using,
+               [AC_TRY_COMPILE(class X { 
+                                 public: int go(const X&) {return 3;}
+                                         int jo(const X&) {return 3;}
+                               };
+                               class Y : public X {
+                                 public:  int go(int) {return 2;}
+                                          int jo(int) {return 2;}
+                                          using X::jo;
+                                 private: using X::go;
+                               };,
+                               X x; Y y; y.jo(x);,
+                               ac_cv_cpp_ambiguity_resolving_using=yes,
+                               ac_cv_cpp_ambiguity_resolving_using=no)])
+if test "$ac_cv_cpp_ambiguity_resolving_using" = yes ; then
+   AC_DEFINE(HAVE_CPP_AMBIGUITY_RESOLVING_USING)
+fi
+
+dnl Check to see if the |std| namespace is supported. If so, we'll want
+dnl to qualify any standard library calls with "std::" to ensure that
+dnl those functions can be resolved.
+AC_CACHE_CHECK(for \"std::\" namespace,
+               ac_cv_cpp_namespace_std,
+               [AC_TRY_COMPILE([#include <algorithm>],
+                               [return std::min(0, 1);],
+                               ac_cv_cpp_namespace_std=yes,
+                               ac_cv_cpp_namespace_std=no)])
+if test "$ac_cv_cpp_namespace_std" = yes ; then
+   AC_DEFINE(HAVE_CPP_NAMESPACE_STD)
+fi
+
+dnl Older compilers are overly ambitious with respect to using the standard
+dnl template library's |operator!=()| when |operator==()| is defined. In
+dnl which case, defining |operator!=()| in addition to |operator==()| causes
+dnl ambiguity at compile-time. This test checks for that case.
+AC_CACHE_CHECK(whether standard template operator!=() is ambiguous,
+               ac_cv_cpp_unambiguous_std_notequal,
+               [AC_TRY_COMPILE([#include <algorithm>
+                                struct T1 {};
+                                int operator==(const T1&, const T1&) { return 0; }
+                                int operator!=(const T1&, const T1&) { return 0; }],
+                               [T1 a,b; return a != b;],
+                               ac_cv_cpp_unambiguous_std_notequal=unambiguous,
+                               ac_cv_cpp_unambiguous_std_notequal=ambiguous)])
+if test "$ac_cv_cpp_unambiguous_std_notequal" = unambiguous ; then
+  AC_DEFINE(HAVE_CPP_UNAMBIGUOUS_STD_NOTEQUAL)
+fi
+
+
+AC_CACHE_CHECK(for C++ reinterpret_cast,
+               ac_cv_cpp_reinterpret_cast,
+               [AC_TRY_COMPILE(struct X { int i; };
+                               struct Y { int i; };,
+                               X x; X*const z = &x;Y*y = reinterpret_cast<Y*>(z);,
+                               ac_cv_cpp_reinterpret_cast=yes,
+                               ac_cv_cpp_reinterpret_cast=no)])
+if test "$ac_cv_cpp_reinterpret_cast" = yes ; then
+   AC_DEFINE(HAVE_CPP_NEW_CASTS)
+fi
+
+dnl See if a dynamic_cast to void* gives the most derived object.
+AC_CACHE_CHECK(for C++ dynamic_cast to void*,
+               ac_cv_cpp_dynamic_cast_void_ptr,
+               [AC_TRY_RUN([class X { int i; public: virtual ~X() { } };
+                            class Y { int j; public: virtual ~Y() { } };
+                            class Z : public X, public Y { int k; };
+
+                            int main() {
+                                 Z mdo;
+                                 X *subx = (X*)&mdo;
+                                 Y *suby = (Y*)&mdo;
+                                 return !((((void*)&mdo != (void*)subx) &&
+                                           ((void*)&mdo == dynamic_cast<void*>(subx))) ||
+                                          (((void*)&mdo != (void*)suby) &&
+                                           ((void*)&mdo == dynamic_cast<void*>(suby))));
+                            }],
+                           ac_cv_cpp_dynamic_cast_void_ptr=yes,
+                           ac_cv_cpp_dynamic_cast_void_ptr=no,
+                           ac_cv_cpp_dynamic_cast_void_ptr=no)])
+if test "$ac_cv_cpp_dynamic_cast_void_ptr" = yes ; then
+   AC_DEFINE(HAVE_CPP_DYNAMIC_CAST_TO_VOID_PTR)
+fi
+
+
+dnl note that this one is reversed - if the test fails, then
+dnl we require implementations of unused virtual methods. Which
+dnl really blows because it means we'll have useless vtable
+dnl bloat.
+AC_CACHE_CHECK(whether C++ requires implementation of unused virtual methods,
+               ac_cv_cpp_unused_required,
+               [AC_TRY_LINK(class X {private: virtual void never_called();};,
+                               X x;,
+                               ac_cv_cpp_unused_required=no,
+                               ac_cv_cpp_unused_required=yes)])
+if test "$ac_cv_cpp_unused_required" = yes ; then
+   AC_DEFINE(NEED_CPP_UNUSED_IMPLEMENTATIONS)
+fi
+
+
+dnl Some compilers have trouble comparing a constant reference to a templatized
+dnl class to zero, and require an explicit operator==() to be defined that takes
+dnl an int. This test separates the strong from the weak.
+
+AC_CACHE_CHECK(for trouble comparing to zero near std::operator!=(),
+               ac_cv_trouble_comparing_to_zero,
+               [AC_TRY_COMPILE([#include <algorithm>
+                                template <class T> class Foo {};
+                                class T2;
+                                template <class T> int operator==(const T2*, const T&) { return 0; }
+                                template <class T> int operator!=(const T2*, const T&) { return 0; }],
+                               [Foo<int> f; return (0 != f);],
+                               ac_cv_trouble_comparing_to_zero=no,
+                               ac_cv_trouble_comparing_to_zero=yes)])
+if test "$ac_cv_trouble_comparing_to_zero" = yes ; then
+  AC_DEFINE(HAVE_CPP_TROUBLE_COMPARING_TO_ZERO)
+fi
+
+
+
+dnl End of C++ language/feature checks
+AC_LANG_C
+
+dnl ========================================================
+dnl =  Internationalization checks
+dnl ========================================================
+dnl
+dnl Internationalization and Locale support is different
+dnl on various UNIX platforms.  Checks for specific i18n
+dnl features go here.
+
+dnl check for LC_MESSAGES
+AC_CACHE_CHECK(for LC_MESSAGES,
+		ac_cv_i18n_lc_messages,
+		[AC_TRY_COMPILE([#include <locale.h>],
+				[int category = LC_MESSAGES;],
+				ac_cv_i18n_lc_messages=yes,
+				ac_cv_i18n_lc_messages=no)])
+if test "$ac_cv_i18n_lc_messages" = yes; then
+   AC_DEFINE(HAVE_I18N_LC_MESSAGES)
+fi 	
+
+fi # SKIP_COMPILER_CHECKS
+
+TARGET_XPCOM_ABI=
+if test -n "${CPU_ARCH}" -a -n "${TARGET_COMPILER_ABI}"; then
+    TARGET_XPCOM_ABI="${CPU_ARCH}-${TARGET_COMPILER_ABI}"
+fi
+
+dnl Mozilla specific options
+dnl ========================================================
+dnl The macros used for command line options
+dnl are defined in build/autoconf/altoptions.m4.
+
+
+dnl ========================================================
+dnl =
+dnl = Check for external package dependencies
+dnl =
+dnl ========================================================
+MOZ_ARG_HEADER(External Packages)
+
+dnl ========================================================
+dnl = Find the right NSPR to use.
+dnl ========================================================
+MOZ_ARG_WITH_BOOL(system-nspr,
+[  --with-system-nspr      Use an NSPR that is already built and installed.
+                          Use the 'nspr-config' script in the current path,
+                          or look for the script in the directories given with
+                          --with-nspr-exec-prefix or --with-nspr-prefix.],
+    _USE_SYSTEM_NSPR=1 )
+
+MOZ_ARG_WITH_STRING(nspr-cflags,
+[  --with-nspr-cflags=FLAGS Pass FLAGS to CC when building code that uses NSPR.
+                          Use this when there's no accurate nspr-config
+                          script available.  This is the case when building
+                          SpiderMonkey as part of the Mozilla tree: the
+                          top-level configure script computes NSPR flags
+                          that accomodate the quirks of that environment.],
+    NSPR_CFLAGS=$withval)
+MOZ_ARG_WITH_STRING(nspr-libs,
+[  --with-nspr-libs=LIBS   Pass LIBS to LD when linking code that uses NSPR.
+                          See --with-nspr-cflags for more details.],
+    NSPR_LIBS=$withval)
+AC_SUBST(NSPR_CFLAGS)
+AC_SUBST(NSPR_LIBS)
+
+dnl Pass either --with-system-nspr or (--with-nspr-cflags and
+dnl --with-nspr-libs), but not both.
+if test "$_USE_SYSTEM_NSPR" && (test "$NSPR_CFLAGS" || test "$NSPR_LIBS"); then
+    AC_MSG_ERROR([--with-system-nspr and --with-nspr-libs/cflags are mutually exclusive.
+See 'configure --help'.])
+fi
+
+if test -n "$_USE_SYSTEM_NSPR"; then
+    MOZ_NATIVE_NSPR=
+    AM_PATH_NSPR(4.7.0, [MOZ_NATIVE_NSPR=1])
+    if test -z "$MOZ_NATIVE_NSPR"; then
+        AC_MSG_ERROR([--with-system-nspr given, but configure could not find a suitable NSPR.
+Pass --with-nspr-exec-prefix, --with-nspr-prefix, or --with-nspr-cflags/libs.
+See 'configure --help'.])
+    fi
+fi
+
+if test -n "$MOZ_NATIVE_NSPR"; then
+    _SAVE_CFLAGS=$CFLAGS
+    CFLAGS="$CFLAGS $NSPR_CFLAGS"
+    AC_TRY_COMPILE([#include "prlog.h"],
+                [#ifndef PR_STATIC_ASSERT
+                 #error PR_STATIC_ASSERT not defined
+                 #endif],
+                [MOZ_NATIVE_NSPR=1],
+                AC_MSG_ERROR([system NSPR does not support PR_STATIC_ASSERT]))
+    CFLAGS=$_SAVE_CFLAGS
+fi
+
+dnl ========================================================
+dnl Use ARM userspace kernel helpers; tell NSPR to enable
+dnl their usage and use them in spidermonkey.
+dnl ========================================================
+MOZ_ARG_WITH_BOOL(arm-kuser,
+[  --with-arm-kuser         Use kuser helpers (Linux/ARM only -- requires kernel 2.6.13 or later)],
+    USE_ARM_KUSER=1,
+    USE_ARM_KUSER=)
+if test -n "$USE_ARM_KUSER"; then
+   AC_DEFINE(USE_ARM_KUSER)
+fi
+
+dnl ========================================================
+dnl =
+dnl = Application
+dnl =
+dnl ========================================================
+
+MOZ_ARG_HEADER(Application)
+
+BUILD_STATIC_LIBS=
+ENABLE_TESTS=1
+MOZ_DBGRINFO_MODULES=
+JS_STATIC_BUILD=
+
+dnl ========================================================
+dnl =
+dnl = Components & Features
+dnl = 
+dnl ========================================================
+MOZ_ARG_HEADER(Components and Features)
+
+dnl ========================================================
+dnl = Localization
+dnl ========================================================
+MOZ_ARG_ENABLE_STRING(ui-locale,
+[  --enable-ui-locale=ab-CD
+                          Select the user interface locale (default: en-US)],
+    MOZ_UI_LOCALE=$enableval )
+AC_SUBST(MOZ_UI_LOCALE)
+
+dnl ========================================================
+dnl build the tests by default
+dnl ========================================================
+MOZ_ARG_DISABLE_BOOL(tests,
+[  --disable-tests         Do not build test libraries & programs],
+    ENABLE_TESTS=,
+    ENABLE_TESTS=1 )
+
+dnl ========================================================
+dnl =
+dnl = Module specific options
+dnl =
+dnl ========================================================
+MOZ_ARG_HEADER(Individual module options)
+
+dnl ========================================================
+dnl = Enable Ultrasparc specific optimizations for JS
+dnl ========================================================
+MOZ_ARG_ENABLE_BOOL(js-ultrasparc,
+[  --enable-js-ultrasparc  Use UltraSPARC optimizations in JS],
+    JS_ULTRASPARC_OPTS=1,
+    JS_ULTRASPARC_OPTS= )
+
+dnl only enable option for ultrasparcs
+if test `echo "$target_os" | grep -c \^solaris 2>/dev/null` = 0 -o \
+    "$OS_TEST" != "sun4u"; then
+    JS_ULTRASPARC_OPTS=
+fi
+AC_SUBST(JS_ULTRASPARC_OPTS)
+
+dnl ========================================================
+dnl =
+dnl = Debugging Options
+dnl = 
+dnl ========================================================
+MOZ_ARG_HEADER(Debugging and Optimizations)
+
+dnl ========================================================
+dnl = Disable building with debug info.
+dnl = Debugging is OFF by default
+dnl ========================================================
+if test -z "$MOZ_DEBUG_FLAGS"
+then
+    case "$target" in
+    *-irix*)
+        if test "$GNU_CC"; then
+            GCC_VERSION=`$CC -v 2>&1 | awk '/version/ { print $3 }'`
+            case "$GCC_VERSION" in
+            2.95.*)
+                MOZ_DEBUG_FLAGS=""
+                ;;
+            *)
+                MOZ_DEBUG_FLAGS="-g"
+                ;;
+            esac
+        else
+            MOZ_DEBUG_FLAGS="-g"
+        fi
+        ;;
+    *)
+    	MOZ_DEBUG_FLAGS="-g"
+        ;;
+    esac
+fi
+
+MOZ_ARG_ENABLE_STRING(debug,
+[  --enable-debug[=DBG]    Enable building with developer debug info
+                          (Using compiler flags DBG)],
+[ if test "$enableval" != "no"; then
+    MOZ_DEBUG=1
+    if test -n "$enableval" && test "$enableval" != "yes"; then
+        MOZ_DEBUG_FLAGS=`echo $enableval | sed -e 's|\\\ | |g'`
+    fi
+  else
+    MOZ_DEBUG=
+  fi ],
+  MOZ_DEBUG=)
+
+MOZ_DEBUG_ENABLE_DEFS="-DDEBUG -D_DEBUG"
+ case "${target_os}" in
+    beos*)
+        MOZ_DEBUG_ENABLE_DEFS="$MOZ_DEBUG_ENABLE_DEFS -DDEBUG_${USER}"
+        ;;
+    msvc*|mks*|cygwin*|mingw*|os2*|wince*)
+        MOZ_DEBUG_ENABLE_DEFS="$MOZ_DEBUG_ENABLE_DEFS -DDEBUG_`echo ${USERNAME} | sed -e 's| |_|g'`"
+        ;;
+    *) 
+        MOZ_DEBUG_ENABLE_DEFS="$MOZ_DEBUG_ENABLE_DEFS -DDEBUG_`$WHOAMI`"
+        ;;
+  esac
+MOZ_DEBUG_ENABLE_DEFS="$MOZ_DEBUG_ENABLE_DEFS -DTRACING"
+
+MOZ_DEBUG_DISABLE_DEFS="-DNDEBUG -DTRIMMED"
+
+if test -n "$MOZ_DEBUG"; then
+    AC_MSG_CHECKING([for valid debug flags])
+    _SAVE_CFLAGS=$CFLAGS
+    CFLAGS="$CFLAGS $MOZ_DEBUG_FLAGS"
+    AC_TRY_COMPILE([#include <stdio.h>], 
+        [printf("Hello World\n");],
+        _results=yes,
+        _results=no)
+    AC_MSG_RESULT([$_results])
+    if test "$_results" = "no"; then
+        AC_MSG_ERROR([These compiler flags are invalid: $MOZ_DEBUG_FLAGS])
+    fi
+    CFLAGS=$_SAVE_CFLAGS
+fi
+
+dnl ========================================================
+dnl = Enable code optimization. ON by default.
+dnl ========================================================
+if test -z "$MOZ_OPTIMIZE_FLAGS"; then
+	MOZ_OPTIMIZE_FLAGS="-O"
+fi
+
+MOZ_ARG_ENABLE_STRING(optimize,
+[  --disable-optimize      Disable compiler optimization
+  --enable-optimize=[OPT] Specify compiler optimization flags [OPT=-O]],
+[ if test "$enableval" != "no"; then
+    MOZ_OPTIMIZE=1
+    if test -n "$enableval" && test "$enableval" != "yes"; then
+        MOZ_OPTIMIZE_FLAGS=`echo "$enableval" | sed -e 's|\\\ | |g'`
+        MOZ_OPTIMIZE=2
+    fi
+else
+    MOZ_OPTIMIZE=
+fi ], MOZ_OPTIMIZE=1)
+
+if test "$COMPILE_ENVIRONMENT"; then
+if test -n "$MOZ_OPTIMIZE"; then
+    AC_MSG_CHECKING([for valid optimization flags])
+    _SAVE_CFLAGS=$CFLAGS
+    CFLAGS="$CFLAGS $MOZ_OPTIMIZE_FLAGS"
+    AC_TRY_COMPILE([#include <stdio.h>], 
+        [printf("Hello World\n");],
+        _results=yes,
+        _results=no)
+    AC_MSG_RESULT([$_results])
+    if test "$_results" = "no"; then
+        AC_MSG_ERROR([These compiler flags are invalid: $MOZ_OPTIMIZE_FLAGS])
+    fi
+    CFLAGS=$_SAVE_CFLAGS
+fi
+fi # COMPILE_ENVIRONMENT
+
+AC_SUBST(MOZ_OPTIMIZE)
+AC_SUBST(MOZ_OPTIMIZE_FLAGS)
+AC_SUBST(MOZ_OPTIMIZE_LDFLAGS)
+AC_SUBST(MOZ_OPTIMIZE_SIZE_TWEAK)
+
+dnl ========================================================
+dnl = Enable/disable debug for specific modules only
+dnl =   module names beginning with ^ will be disabled 
+dnl ========================================================
+MOZ_ARG_ENABLE_STRING(debug-modules,
+[  --enable-debug-modules  Enable/disable debug info for specific modules],
+[ MOZ_DEBUG_MODULES=`echo $enableval| sed 's/,/ /g'` ] )
+
+dnl ========================================================
+dnl = Enable/disable generation of debugger info for specific modules only
+dnl =    the special module name ALL_MODULES can be used to denote all modules
+dnl =    module names beginning with ^ will be disabled
+dnl ========================================================
+MOZ_ARG_ENABLE_STRING(debugger-info-modules,
+[  --enable-debugger-info-modules
+                          Enable/disable debugger info for specific modules],
+[ for i in `echo $enableval | sed 's/,/ /g'`; do
+      dnl note that the list of module names is reversed as it is copied
+      dnl this is important, as it will allow config.mk to interpret stuff like
+      dnl "^ALL_MODULES xpcom" properly
+      if test "$i" = "no"; then
+        i="^ALL_MODULES"
+      fi
+      if test "$i" = "yes"; then
+        i="ALL_MODULES"
+      fi
+      MOZ_DBGRINFO_MODULES="$i $MOZ_DBGRINFO_MODULES";
+    done ])
+
+dnl ========================================================
+dnl Enable garbage collector
+dnl ========================================================
+MOZ_ARG_ENABLE_BOOL(boehm,
+[  --enable-boehm          Enable the Boehm Garbage Collector],
+    GC_LEAK_DETECTOR=1,
+    GC_LEAK_DETECTOR= )
+if test -n "$GC_LEAK_DETECTOR"; then
+    AC_DEFINE(GC_LEAK_DETECTOR)
+fi
+
+dnl ========================================================
+dnl = Enable trace malloc
+dnl ========================================================
+NS_TRACE_MALLOC=${MOZ_TRACE_MALLOC}
+MOZ_ARG_ENABLE_BOOL(trace-malloc,
+[  --enable-trace-malloc   Enable malloc tracing],
+    NS_TRACE_MALLOC=1,
+    NS_TRACE_MALLOC= )
+if test "$NS_TRACE_MALLOC"; then
+  # Please, Mr. Linker Man, don't take away our symbol names
+  MOZ_COMPONENTS_VERSION_SCRIPT_LDFLAGS=
+  USE_ELF_DYNSTR_GC=
+  AC_DEFINE(NS_TRACE_MALLOC)
+fi
+AC_SUBST(NS_TRACE_MALLOC)
+
+dnl ========================================================
+dnl = Enable jemalloc
+dnl ========================================================
+MOZ_ARG_ENABLE_BOOL(jemalloc,
+[  --enable-jemalloc       Replace memory allocator with jemalloc],
+    MOZ_MEMORY=1,
+    MOZ_MEMORY=)
+
+if test "$NS_TRACE_MALLOC"; then
+    MOZ_MEMORY=
+fi
+
+if test "$MOZ_MEMORY"; then
+
+  dnl Don't try to run compiler tests on Windows  
+  if test "$OS_ARCH" = "WINNT"; then
+    if test -z "$HAVE_64BIT_OS"; then
+      AC_DEFINE_UNQUOTED([MOZ_MEMORY_SIZEOF_PTR_2POW], 2)
+    else
+      AC_DEFINE_UNQUOTED([MOZ_MEMORY_SIZEOF_PTR_2POW], 3)
+    fi
+  else
+    AC_CHECK_SIZEOF([int *], [4])
+    case "${ac_cv_sizeof_int_p}" in
+    4)
+      AC_DEFINE_UNQUOTED([MOZ_MEMORY_SIZEOF_PTR_2POW], 2)
+      ;;
+    8)
+      AC_DEFINE_UNQUOTED([MOZ_MEMORY_SIZEOF_PTR_2POW], 3)
+      ;;
+    *)
+      AC_MSG_ERROR([Unexpected pointer size])
+      ;;
+    esac
+  fi
+
+  AC_DEFINE(MOZ_MEMORY)
+  if test "x$MOZ_DEBUG" = "x1"; then
+    AC_DEFINE(MOZ_MEMORY_DEBUG)
+  fi
+  dnl The generic feature tests that determine how to compute ncpus are long and
+  dnl complicated.  Therefore, simply define special cpp variables for the
+  dnl platforms we have special knowledge of.
+  case "${target_os}" in
+  darwin*)
+    AC_DEFINE(MOZ_MEMORY_DARWIN)
+    ;;
+  *freebsd*)
+    AC_DEFINE(MOZ_MEMORY_BSD)
+    ;;
+  *linux*)
+    AC_DEFINE(MOZ_MEMORY_LINUX)
+    ;;
+  netbsd*)
+    AC_DEFINE(MOZ_MEMORY_BSD)
+    ;;
+  solaris*)
+    AC_DEFINE(MOZ_MEMORY_SOLARIS)
+    ;;
+  msvc*|mks*|cygwin*|mingw*)
+    AC_DEFINE(MOZ_MEMORY_WINDOWS)
+    dnl XXX: should test for vc8sp1 here, otherwise patching the crt src
+    dnl will fail miserably
+    if test "$_CC_SUITE" -lt "8"; then
+        AC_MSG_ERROR([Building jemalloc requires Visual C++ 2005 or better])
+    fi
+    if test -z "$WIN32_CRT_SRC_DIR" -a -z "$WIN32_CUSTOM_CRT_DIR"; then
+      if test -z "$VCINSTALLDIR" -o ! -d "$VCINSTALLDIR"; then
+        AC_MSG_ERROR([When building jemalloc, either set WIN32_CRT_SRC_DIR to the path to the Visual C++ CRT source (usually VCINSTALLDIR\crt\src), or set WIN32_CUSTOM_CRT_DIR to the path to a folder containing a pre-built CRT DLL.])
+      else
+        WIN32_CRT_SRC_DIR="$VCINSTALLDIR\crt\src"
+      fi
+    fi
+    if test -z "$WIN32_CRT_SRC_DIR"; then
+      # pre-built dll
+      WIN32_CUSTOM_CRT_DIR=`cd "$WIN32_CUSTOM_CRT_DIR" && pwd`
+      _WIN_UNIX_CRT_PATH="$WIN32_CUSTOM_CRT_DIR"
+    else
+      # CRT source directory
+      WIN32_CRT_SRC_DIR=`cd "$WIN32_CRT_SRC_DIR" && pwd`
+      _CRT_BASE_DIR=`basename "$WIN32_CRT_SRC_DIR"`
+      _WIN_UNIX_CRT_PATH="$_objdir/memory/jemalloc/$_CRT_BASE_DIR/build/intel"
+    fi
+    dnl need win32 paths in LIB, hence this python abuse.  extra brackets
+    dnl are to avoid m4
+    _WIN_CRT_PATH=[`$PYTHON -c 'import sys, os.path; print os.path.normpath(sys.argv[1])' "$_WIN_UNIX_CRT_PATH"`]
+    MOZ_LIB="$_WIN_CRT_PATH;$LIB"
+    dnl Needs to be in PATH too, since our tools will wind up linked against it.
+    dnl This needs to be unix style.
+    MOZ_PATH="$PATH:$_WIN_UNIX_CRT_PATH"
+    dnl Statically link the C++ stdlib.  We only use this for Breakpad anyway.
+    AC_DEFINE(_STATIC_CPPLIB)
+    dnl Don't generate a manifest, since we're linking to a custom CRT.
+    LDFLAGS="$LDFLAGS -MANIFEST:NO"
+    dnl Also pass this to NSPR/NSS
+    DLLFLAGS="$DLLFLAGS -MANIFEST:NO"
+    export DLLFLAGS
+    ;;
+  *)
+    AC_MSG_ERROR([--enable-jemalloc not supported on ${target}])
+    ;;
+  esac
+
+  AC_ARG_WITH([valgrind],
+    [  --with-valgrind         Enable valgrind integration hooks],
+    [enable_valgrind="yes"], [enable_valgrind="no"])
+  AC_CHECK_HEADER([valgrind/valgrind.h], [], [enable_valgrind="no"])
+  if test "x$enable_valgrind" = "xyes" ; then
+    AC_DEFINE(MOZ_VALGRIND)
+  fi
+fi
+AC_SUBST(MOZ_MEMORY)
+AC_SUBST(WIN32_CRT_SRC_DIR)
+AC_SUBST(WIN32_CUSTOM_CRT_DIR)
+AC_SUBST(MOZ_LIB)
+AC_SUBST(MOZ_PATH)
+dnl Need to set this for make because NSS doesn't have configure
+AC_SUBST(DLLFLAGS)
+
+dnl ========================================================
+dnl = Use malloc wrapper lib
+dnl ========================================================
+MOZ_ARG_ENABLE_BOOL(wrap-malloc,
+[  --enable-wrap-malloc    Wrap malloc calls (gnu linker only)],
+    _WRAP_MALLOC=1,
+    _WRAP_MALLOC= )
+
+if test -n "$_WRAP_MALLOC"; then
+    if test "$GNU_CC"; then
+    WRAP_MALLOC_CFLAGS="${LDFLAGS} -Wl,--wrap -Wl,malloc -Wl,--wrap -Wl,free -Wl,--wrap -Wl,realloc -Wl,--wrap -Wl,__builtin_new -Wl,--wrap -Wl,__builtin_vec_new -Wl,--wrap -Wl,__builtin_delete -Wl,--wrap -Wl,__builtin_vec_delete -Wl,--wrap -Wl,PR_Free -Wl,--wrap -Wl,PR_Malloc -Wl,--wrap -Wl,PR_Calloc -Wl,--wrap -Wl,PR_Realloc"
+    MKSHLIB='$(CXX) $(DSO_LDOPTS) $(WRAP_MALLOC_CFLAGS) -o $@'
+    fi
+fi
+
+dnl ========================================================
+dnl = Location of malloc wrapper lib
+dnl ========================================================
+MOZ_ARG_WITH_STRING(wrap-malloc,
+[  --with-wrap-malloc=DIR  Location of malloc wrapper library],
+    WRAP_MALLOC_LIB=$withval)
+
+dnl ========================================================
+dnl = Use Electric Fence
+dnl ========================================================
+MOZ_ARG_ENABLE_BOOL(efence,
+[  --enable-efence         Link with Electric Fence],
+    _ENABLE_EFENCE=1,
+    _ENABLE_EFENCE= )
+if test -n "$_ENABLE_EFENCE"; then
+    AC_CHECK_LIB(efence,malloc)
+fi
+
+dnl ========================================================
+dnl jprof
+dnl ========================================================
+MOZ_ARG_ENABLE_BOOL(jprof,
+[  --enable-jprof          Enable jprof profiling tool (needs mozilla/tools/jprof)],
+    MOZ_JPROF=1,
+    MOZ_JPROF= )
+if test -n "$MOZ_JPROF"; then
+    AC_DEFINE(MOZ_JPROF)
+fi
+
+dnl ========================================================
+dnl shark
+dnl ========================================================
+MOZ_ARG_ENABLE_BOOL(shark,
+[  --enable-shark          Enable shark remote profiling (needs CHUD framework)],
+    MOZ_SHARK=1,
+    MOZ_SHARK= )
+if test -n "$MOZ_SHARK"; then
+    AC_DEFINE(MOZ_SHARK)
+fi
+
+dnl ========================================================
+dnl callgrind
+dnl ========================================================
+MOZ_ARG_ENABLE_BOOL(callgrind,
+[  --enable-callgrind      Enable callgrind profiling],
+    MOZ_CALLGRIND=1,
+    MOZ_CALLGRIND= )
+if test -n "$MOZ_CALLGRIND"; then
+    AC_DEFINE(MOZ_CALLGRIND)
+fi
+
+dnl ========================================================
+dnl vtune
+dnl ========================================================
+MOZ_ARG_ENABLE_BOOL(vtune,
+[  --enable-vtune          Enable vtune profiling],
+    MOZ_VTUNE=1,
+    MOZ_VTUNE= )
+if test -n "$MOZ_VTUNE"; then
+    AC_DEFINE(MOZ_VTUNE)
+fi
+
+dnl ========================================================
+dnl = Enable static checking using gcc-dehydra
+dnl ========================================================
+
+MOZ_ARG_WITH_STRING(static-checking,
+[  --with-static-checking=path/to/gcc_dehydra.so
+                            Enable static checking of code using GCC-dehydra],
+    DEHYDRA_PATH=$withval,
+    DEHYDRA_PATH= )
+
+if test -n "$DEHYDRA_PATH"; then
+    if ! test -f "$DEHYDRA_PATH"; then
+        AC_MSG_ERROR([The dehydra plugin is not at the specified path.])
+    fi
+    AC_DEFINE(NS_STATIC_CHECKING)
+fi
+AC_SUBST(DEHYDRA_PATH)
+
+dnl ========================================================
+dnl = Enable stripping of libs & executables
+dnl ========================================================
+MOZ_ARG_ENABLE_BOOL(strip,
+[  --enable-strip          Enable stripping of libs & executables ],
+    ENABLE_STRIP=1,
+    ENABLE_STRIP= )
+
+dnl ========================================================
+dnl = Enable stripping of libs & executables when packaging
+dnl ========================================================
+MOZ_ARG_ENABLE_BOOL(install-strip,
+[  --enable-install-strip  Enable stripping of libs & executables when packaging ],
+    PKG_SKIP_STRIP= ,
+    PKG_SKIP_STRIP=1)
+
+dnl ========================================================
+dnl = --enable-elf-dynstr-gc
+dnl ========================================================
+MOZ_ARG_ENABLE_BOOL(elf-dynstr-gc,
+[  --enable-elf-dynstr-gc  Enable elf dynstr garbage collector (opt builds only)],
+    USE_ELF_DYNSTR_GC=1,
+    USE_ELF_DYNSTR_GC= )
+
+dnl ========================================================
+dnl = --enable-old-abi-compat-wrappers
+dnl ========================================================
+dnl on x86 linux, the current builds of some popular plugins (notably
+dnl flashplayer and real) expect a few builtin symbols from libgcc
+dnl which were available in some older versions of gcc.  However,
+dnl they're _NOT_ available in newer versions of gcc (eg 3.1), so if
+dnl we want those plugin to work with a gcc-3.1 built binary, we need
+dnl to provide these symbols.  MOZ_ENABLE_OLD_ABI_COMPAT_WRAPPERS defaults
+dnl to true on x86 linux, and false everywhere else.
+dnl
+
+MOZ_ARG_ENABLE_BOOL(old-abi-compat-wrappers,
+[  --enable-old-abi-compat-wrappers
+                          Support old GCC ABI symbols to ease the pain 
+                          of the linux compiler change],
+    MOZ_ENABLE_OLD_ABI_COMPAT_WRAPPERS=1,
+    MOZ_ENABLE_OLD_ABI_COMPAT_WRAPPERS= )
+if test "$COMPILE_ENVIRONMENT"; then
+if test "$MOZ_ENABLE_OLD_ABI_COMPAT_WRAPPERS"; then
+    AC_LANG_SAVE
+    AC_LANG_CPLUSPLUS
+    AC_CHECK_FUNCS(__builtin_vec_new __builtin_vec_delete __builtin_new __builtin_delete __pure_virtual)
+    AC_LANG_RESTORE
+    AC_DEFINE(MOZ_ENABLE_OLD_ABI_COMPAT_WRAPPERS)
+fi
+fi # COMPILE_ENVIRONMENT
+
+dnl ========================================================
+dnl = 
+dnl = Profiling and Instrumenting
+dnl = 
+dnl ========================================================
+MOZ_ARG_HEADER(Profiling and Instrumenting)
+
+dnl ========================================================
+dnl = Enable timeline service, which provides lightweight
+dnl = instrumentation of mozilla for performance measurement.
+dnl = Timeline is off by default.
+dnl ========================================================
+MOZ_ARG_ENABLE_BOOL(timeline,
+[  --enable-timeline       Enable timeline services ],
+    MOZ_TIMELINE=1,
+    MOZ_TIMELINE= )
+if test -n "$MOZ_TIMELINE"; then
+    AC_DEFINE(MOZ_TIMELINE)
+fi
+
+dnl ========================================================
+dnl = Add support for Eazel profiler
+dnl ========================================================
+MOZ_ARG_ENABLE_BOOL(eazel-profiler-support,
+[  --enable-eazel-profiler-support
+                          Enable Corel/Eazel profiler support],
+    ENABLE_EAZEL_PROFILER=1,
+    ENABLE_EAZEL_PROFILER= )
+if test -n "$ENABLE_EAZEL_PROFILER"; then
+    AC_DEFINE(ENABLE_EAZEL_PROFILER)
+    USE_ELF_DYNSTR_GC=
+    MOZ_COMPONENTS_VERSION_SCRIPT_LDFLAGS=
+    EAZEL_PROFILER_CFLAGS="-g -O -gdwarf-2 -finstrument-functions -D__NO_STRING_INLINES  -D__NO_MATH_INLINES"
+    EAZEL_PROFILER_LIBS="-lprofiler -lpthread"
+fi
+
+MOZ_ARG_ENABLE_STRING(profile-modules,
+[  --enable-profile-modules
+                          Enable/disable profiling for specific modules],
+[ MOZ_PROFILE_MODULES=`echo $enableval| sed 's/,/ /g'` ] )
+
+MOZ_ARG_ENABLE_BOOL(insure,
+[  --enable-insure         Enable insure++ instrumentation (linux only)],
+    _ENABLE_INSURE=1,
+    _ENABLE_INSURE= )
+if test -n "$_ENABLE_INSURE"; then
+    MOZ_INSURE="insure"
+    MOZ_INSURIFYING=1
+    MOZ_INSURE_DIRS="."
+    MOZ_INSURE_EXCLUDE_DIRS="config"
+fi
+
+MOZ_ARG_WITH_STRING(insure-dirs,
+[  --with-insure-dirs=DIRS
+                          Dirs to instrument with insure ],
+    MOZ_INSURE_DIRS=$withval )
+
+MOZ_ARG_WITH_STRING(insure-exclude-dirs,
+[  --with-insure-exclude-dirs=DIRS
+                          Dirs to not instrument with insure ],
+    MOZ_INSURE_EXCLUDE_DIRS="config $withval" )
+
+dnl ========================================================
+dnl = Support for Quantify (Windows)
+dnl ========================================================
+MOZ_ARG_ENABLE_BOOL(quantify,
+[  --enable-quantify      Enable Quantify support (Windows only) ],
+    MOZ_QUANTIFY=1,
+    MOZ_QUANTIFY= )
+
+dnl ========================================================
+dnl = Support for demangling undefined symbols
+dnl ========================================================
+if test -z "$SKIP_LIBRARY_CHECKS"; then
+    AC_LANG_SAVE
+    AC_LANG_CPLUSPLUS
+    AC_CHECK_FUNCS(__cxa_demangle, HAVE_DEMANGLE=1, HAVE_DEMANGLE=)
+    AC_LANG_RESTORE
+fi
+
+# Demangle only for debug or trace-malloc builds
+MOZ_DEMANGLE_SYMBOLS=
+if test "$HAVE_DEMANGLE" -a "$HAVE_GCC3_ABI" && test "$MOZ_DEBUG" -o "$NS_TRACE_MALLOC"; then
+    MOZ_DEMANGLE_SYMBOLS=1
+    AC_DEFINE(MOZ_DEMANGLE_SYMBOLS)
+fi
+AC_SUBST(MOZ_DEMANGLE_SYMBOLS)
+
+dnl ========================================================
+dnl = Support for gcc stack unwinding (from gcc 3.3)
+dnl ========================================================
+if test "$HAVE_GCC3_ABI" && test -z "$SKIP_LIBRARY_CHECKS"; then
+    AC_CHECK_HEADER(unwind.h, AC_CHECK_FUNCS(_Unwind_Backtrace))
+fi
+
+dnl ========================================================
+dnl =
+dnl = Misc. Options
+dnl = 
+dnl ========================================================
+MOZ_ARG_HEADER(Misc. Options)
+
+dnl ========================================================
+dnl update xterm title
+dnl ========================================================
+MOZ_ARG_ENABLE_BOOL(xterm-updates,
+[  --enable-xterm-updates  Update XTERM titles with current command.],
+    MOZ_UPDATE_XTERM=1,
+    MOZ_UPDATE_XTERM= )
+
+if test -z "$SKIP_COMPILER_CHECKS"; then
+dnl ========================================================
+dnl =
+dnl = Compiler Options
+dnl = 
+dnl ========================================================
+MOZ_ARG_HEADER(Compiler Options)
+
+dnl ========================================================
+dnl Check for gcc -pipe support
+dnl ========================================================
+AC_MSG_CHECKING([for gcc -pipe support])
+if test -n "$GNU_CC" && test -n "$GNU_CXX" && test -n "$GNU_AS"; then
+    echo '#include <stdio.h>' > dummy-hello.c
+    echo 'int main() { printf("Hello World\n"); exit(0); }' >> dummy-hello.c
+    ${CC} -S dummy-hello.c -o dummy-hello.s 2>&5
+    cat dummy-hello.s | ${AS_BIN} -o dummy-hello.S - 2>&5
+    if test $? = 0; then
+        _res_as_stdin="yes"
+    else
+        _res_as_stdin="no"
+    fi
+    if test "$_res_as_stdin" = "yes"; then
+        _SAVE_CFLAGS=$CFLAGS
+        CFLAGS="$CFLAGS -pipe"
+        AC_TRY_COMPILE( [ #include <stdio.h> ],
+            [printf("Hello World\n");],
+            [_res_gcc_pipe="yes"],
+            [_res_gcc_pipe="no"] )
+        CFLAGS=$_SAVE_CFLAGS
+    fi
+    if test "$_res_as_stdin" = "yes" && test "$_res_gcc_pipe" = "yes"; then
+        _res="yes";
+        CFLAGS="$CFLAGS -pipe"
+        CXXFLAGS="$CXXFLAGS -pipe"
+    else
+        _res="no"
+    fi
+    rm -f dummy-hello.c dummy-hello.s dummy-hello.S dummy-hello a.out
+    AC_MSG_RESULT([$_res])
+else
+    AC_MSG_RESULT([no])
+fi
+
+dnl pass -Wno-long-long to the compiler
+MOZ_ARG_ENABLE_BOOL(long-long-warning,
+[  --enable-long-long-warning 
+                          Warn about use of non-ANSI long long type],
+    _IGNORE_LONG_LONG_WARNINGS=,
+    _IGNORE_LONG_LONG_WARNINGS=1)
+
+if test "$_IGNORE_LONG_LONG_WARNINGS"; then
+     _SAVE_CFLAGS="$CFLAGS"
+     CFLAGS="$CFLAGS ${_COMPILER_PREFIX}-Wno-long-long"
+     AC_MSG_CHECKING([whether compiler supports -Wno-long-long])
+     AC_TRY_COMPILE([], [return(0);], 
+	[ _WARNINGS_CFLAGS="${_WARNINGS_CFLAGS} ${_COMPILER_PREFIX}-Wno-long-long"
+	  _WARNINGS_CXXFLAGS="${_WARNINGS_CXXFLAGS} ${_COMPILER_PREFIX}-Wno-long-long"
+	  result="yes" ], result="no")
+     AC_MSG_RESULT([$result])
+     CFLAGS="$_SAVE_CFLAGS"
+fi
+
+dnl ========================================================
+dnl Profile guided optimization
+dnl ========================================================
+dnl Test for profiling options
+dnl Under gcc 3.3, use -fprofile-arcs/-fbranch-probabilities
+dnl Under gcc 3.4+, use -fprofile-generate/-fprofile-use
+
+dnl Provide a switch to disable PGO even when called via profiledbuild.
+MOZ_ARG_DISABLE_BOOL(profile-guided-optimization,
+[  --disable-profile-guided-optimization
+                           Don't build with PGO even if called via make profiledbuild],
+MOZ_PROFILE_GUIDED_OPTIMIZE_DISABLE=1,
+MOZ_PROFILE_GUIDED_OPTIMIZE_DISABLE=)
+
+AC_SUBST(MOZ_PROFILE_GUIDED_OPTIMIZE_DISABLE)
+
+_SAVE_CFLAGS="$CFLAGS"
+CFLAGS="$CFLAGS -fprofile-generate"
+
+AC_MSG_CHECKING([whether C compiler supports -fprofile-generate])
+AC_TRY_COMPILE([], [return 0;],
+               [ PROFILE_GEN_CFLAGS="-fprofile-generate"
+                 result="yes" ], result="no")
+AC_MSG_RESULT([$result])
+
+if test $result = "yes"; then
+  PROFILE_GEN_LDFLAGS="-fprofile-generate"
+  PROFILE_USE_CFLAGS="-fprofile-use"
+  PROFILE_USE_LDFLAGS="-fprofile-use"
+else
+  CFLAGS="$_SAVE_CFLAGS -fprofile-arcs"
+  AC_MSG_CHECKING([whether C compiler supports -fprofile-arcs])
+  AC_TRY_COMPILE([], [return 0;],
+                 [ PROFILE_GEN_CFLAGS="-fprofile-arcs"
+                   result="yes" ], result="no")
+  AC_MSG_RESULT([$result])
+  if test $result = "yes"; then
+    PROFILE_USE_CFLAGS="-fbranch-probabilities"
+  fi
+  # don't really care, this is an old GCC
+  PROFILE_GEN_LDFLAGS=
+  PROFILE_USE_LDFLAGS=
+fi
+
+CFLAGS="$_SAVE_CFLAGS"
+
+if test -n "$INTEL_CC"; then
+  PROFILE_GEN_CFLAGS="-prof-gen -prof-dir ."
+  PROFILE_GEN_LDFLAGS=
+  PROFILE_USE_CFLAGS="-prof-use -prof-dir ."
+  PROFILE_USE_LDFLAGS=
+fi
+
+dnl Sun Studio on Solaris
+if test -z "$GNU_CC" && test -z "$GNU_CXX" && test "$OS_ARCH" = "SunOS"; then
+  PROFILE_GEN_CFLAGS="-xprofile=collect:$_objdir/$enable_application"
+  PROFILE_GEN_LDFLAGS="-xprofile=collect:$_objdir/$enable_application"
+  if test "$CPU_ARCH" != "sparc"; then
+    PROFILE_USE_CFLAGS="-xprofile=use:$_objdir/$enable_application"
+    PROFILE_USE_LDFLAGS="-xprofile=use:$_objdir/$enable_application"
+  else
+    PROFILE_USE_CFLAGS="-xlinkopt=2 -xprofile=use:$_objdir/$enable_application"
+    PROFILE_USE_LDFLAGS="-xlinkopt=2 -xprofile=use:$_objdir/$enable_application"
+  fi
+fi
+
+AC_SUBST(PROFILE_GEN_CFLAGS)
+AC_SUBST(PROFILE_GEN_LDFLAGS)
+AC_SUBST(PROFILE_USE_CFLAGS)
+AC_SUBST(PROFILE_USE_LDFLAGS)
+
+AC_LANG_CPLUSPLUS
+
+dnl ========================================================
+dnl Test for -pedantic bustage
+dnl ========================================================
+MOZ_ARG_DISABLE_BOOL(pedantic,
+[  --disable-pedantic      Issue all warnings demanded by strict ANSI C ],
+_PEDANTIC= )
+if test "$_PEDANTIC"; then
+    _SAVE_CXXFLAGS=$CXXFLAGS
+    CXXFLAGS="$CXXFLAGS ${_WARNINGS_CXXFLAGS} ${_COMPILER_PREFIX}-pedantic"
+    AC_MSG_CHECKING([whether C++ compiler has -pedantic long long bug])
+    AC_TRY_COMPILE([$configure_static_assert_macros],
+                   [CONFIGURE_STATIC_ASSERT(sizeof(long long) == 8)],
+                   result="no", result="yes" )
+    AC_MSG_RESULT([$result])
+    CXXFLAGS="$_SAVE_CXXFLAGS"
+
+    case "$result" in
+    no)
+        _WARNINGS_CFLAGS="${_WARNINGS_CFLAGS} ${_COMPILER_PREFIX}-pedantic"
+        _WARNINGS_CXXFLAGS="${_WARNINGS_CXXFLAGS} ${_COMPILER_PREFIX}-pedantic"
+        ;;
+    yes)
+        AC_MSG_ERROR([Your compiler appears to have a known bug where long long is miscompiled when using -pedantic.  Reconfigure using --disable-pedantic. ])
+        ;;
+    esac
+fi
+
+dnl ========================================================
+dnl Test for correct temporary object destruction order
+dnl ========================================================
+dnl We want to make sure the compiler follows the C++ spec here as 
+dnl xpcom and the string classes depend on it (bug 235381).
+AC_MSG_CHECKING([for correct temporary object destruction order])
+AC_TRY_RUN([ class A {
+             public:  A(int& x) : mValue(x) {}
+                      ~A() { mValue--; }
+                      operator char**() { return 0; }
+             private:  int& mValue;
+             };
+             void func(char **arg) {}
+             int m=2;
+             void test() {
+                  func(A(m));
+                  if (m==1) m = 0;
+             }
+             int main() {
+                 test();
+                 return(m);
+             }
+             ],
+     result="yes", result="no", result="maybe")
+AC_MSG_RESULT([$result])
+
+if test "$result" = "no"; then
+    AC_MSG_ERROR([Your compiler does not follow the C++ specification for temporary object destruction order.])
+fi
+
+dnl ========================================================
+dnl Autoconf test for gcc 2.7.2.x (and maybe others?) so that we don't
+dnl provide non-const forms of the operator== for comparing nsCOMPtrs to
+dnl raw pointers in nsCOMPtr.h.  (VC++ has the same bug.)
+dnl ========================================================
+_SAVE_CXXFLAGS=$CXXFLAGS
+CXXFLAGS="$CXXFLAGS ${_WARNINGS_CXXFLAGS}"
+AC_CACHE_CHECK(for correct overload resolution with const and templates,
+    ac_nscap_nonconst_opeq_bug,
+    [AC_TRY_COMPILE([
+                      template <class T>
+                      class Pointer
+                        {
+                        public:
+                          T* myPtr;
+                        };
+                      
+                      template <class T, class U>
+                      int operator==(const Pointer<T>& rhs, U* lhs)
+                        {
+                          return rhs.myPtr == lhs;
+                        }
+                      
+                      template <class T, class U>
+                      int operator==(const Pointer<T>& rhs, const U* lhs)
+                        {
+                          return rhs.myPtr == lhs;
+                        }
+                    ],
+                    [
+                      Pointer<int> foo;
+                      const int* bar;
+                      return foo == bar;
+                    ],
+                    ac_nscap_nonconst_opeq_bug="no",
+                    ac_nscap_nonconst_opeq_bug="yes")])
+CXXFLAGS="$_SAVE_CXXFLAGS"
+
+if test "$ac_nscap_nonconst_opeq_bug" = "yes" ; then
+    AC_DEFINE(NSCAP_DONT_PROVIDE_NONCONST_OPEQ)
+fi
+fi # SKIP_COMPILER_CHECKS
+
+dnl ========================================================
+dnl C++ rtti
+dnl Should be smarter and check that the compiler does indeed have rtti
+dnl ========================================================
+MOZ_ARG_ENABLE_BOOL(cpp-rtti,
+[  --enable-cpp-rtti       Enable C++ RTTI ],
+[ _MOZ_USE_RTTI=1 ],
+[ _MOZ_USE_RTTI= ])
+
+if test "$_MOZ_USE_RTTI"; then
+   _MOZ_RTTI_FLAGS=$_MOZ_RTTI_FLAGS_ON
+else
+   _MOZ_RTTI_FLAGS=$_MOZ_RTTI_FLAGS_OFF
+fi
+
+AC_SUBST(_MOZ_RTTI_FLAGS_ON)
+
+dnl ========================================================
+dnl C++ exceptions (g++/egcs only - for now)
+dnl Should be smarter and check that the compiler does indeed have exceptions
+dnl ========================================================
+MOZ_ARG_ENABLE_BOOL(cpp-exceptions,
+[  --enable-cpp-exceptions Enable C++ exceptions ],
+[ _MOZ_CPP_EXCEPTIONS=1 ],
+[ _MOZ_CPP_EXCEPTIONS= ])
+
+if test "$_MOZ_CPP_EXCEPTIONS"; then
+    _MOZ_EXCEPTIONS_FLAGS=$_MOZ_EXCEPTIONS_FLAGS_ON
+else
+    _MOZ_EXCEPTIONS_FLAGS=$_MOZ_EXCEPTIONS_FLAGS_OFF
+fi
+
+# Irix & OSF native compilers do not like exception declarations 
+# when exceptions are disabled
+if test -n "$MIPSPRO_CXX" -o -n "$COMPAQ_CXX" -o -n "$VACPP"; then
+    AC_DEFINE(CPP_THROW_NEW, [])
+else
+    AC_DEFINE(CPP_THROW_NEW, [throw()])
+fi
+AC_LANG_C
+
+dnl ========================================================
+dnl =
+dnl = Build depencency options
+dnl =
+dnl ========================================================
+MOZ_ARG_HEADER(Build dependencies)
+
+dnl ========================================================
+dnl = Do not auto generate dependency info
+dnl ========================================================
+MOZ_AUTO_DEPS=1
+MOZ_ARG_DISABLE_BOOL(auto-deps,
+[  --disable-auto-deps     Do not automatically generate dependency info],
+    MOZ_AUTO_DEPS=,
+    MOZ_AUTO_DEPS=1)
+
+if test -n "$MOZ_AUTO_DEPS"; then
+dnl ========================================================
+dnl = Use mkdepend instead of $CC -MD for dependency generation
+dnl ========================================================
+_cpp_md_flag=
+MOZ_ARG_DISABLE_BOOL(md,
+[  --disable-md            Do not use compiler-based dependencies ],
+  [_cpp_md_flag=],
+  [_cpp_md_flag=1],
+  [dnl Default is to turn on -MD if using GNU-compatible compilers
+   if test "$GNU_CC" -a "$GNU_CXX" -a "$OS_ARCH" != "WINNT" -a "$OS_ARCH" != "WINCE"; then
+     _cpp_md_flag=1
+   fi
+  dnl Default is to use -xM if using Sun Studio on Solaris
+   if test -z "$GNU_CC" && test -z "$GNU_CXX" && test "$OS_ARCH" = "SunOS"; then
+     _cpp_md_flag=1
+   fi])
+if test "$_cpp_md_flag"; then
+  COMPILER_DEPEND=1
+  if test "$OS_ARCH" = "OpenVMS"; then
+    _DEPEND_CFLAGS='$(subst =, ,$(filter-out %/.pp,-MM=-MD=-MF=$(MDDEPDIR)/$(basename $(@F)).pp))'
+  else
+    _DEPEND_CFLAGS='$(filter-out %/.pp,-Wp,-MD,$(MDDEPDIR)/$(basename $(@F)).pp)'
+  fi
+  dnl Sun Studio on Solaris use -xM instead of -MD, see config/rules.mk
+  if test -z "$GNU_CC" && test -z "$GNU_CXX" && test "$OS_ARCH" = "SunOS"; then
+    _DEPEND_CFLAGS=
+  fi
+else
+  COMPILER_DEPEND=
+  _USE_CPP_INCLUDE_FLAG=
+  _DEFINES_CFLAGS='$(ACDEFINES) -D_MOZILLA_CONFIG_H_ -DMOZILLA_CLIENT'
+  _DEFINES_CXXFLAGS='$(ACDEFINES) -D_MOZILLA_CONFIG_H_ -DMOZILLA_CLIENT'
+fi
+fi # MOZ_AUTO_DEPS
+MDDEPDIR='.deps'
+AC_SUBST(MOZ_AUTO_DEPS)
+AC_SUBST(COMPILER_DEPEND)
+AC_SUBST(MDDEPDIR)
+
+
+dnl ========================================================
+dnl =
+dnl = Static Build Options
+dnl =
+dnl ========================================================
+MOZ_ARG_HEADER(Static build options)
+
+MOZ_ARG_ENABLE_BOOL(static,
+[  --enable-static         Enable building of internal static libs],
+    BUILD_STATIC_LIBS=1,
+    BUILD_STATIC_LIBS=)
+
+dnl ========================================================
+dnl = Force JS to be a static lib
+dnl ========================================================
+MOZ_ARG_ENABLE_BOOL(js-static-build,
+[  --enable-js-static-build  Force js to be a static lib],
+    JS_STATIC_BUILD=1,
+    JS_STATIC_BUILD= )
+
+AC_SUBST(JS_STATIC_BUILD)
+        
+if test -n "$JS_STATIC_BUILD"; then
+    AC_DEFINE(EXPORT_JS_API)
+
+if test -z "$BUILD_STATIC_LIBS"; then
+    AC_MSG_ERROR([--enable-js-static-build is only compatible with --enable-static])
+fi
+
+fi
+
+dnl ========================================================
+dnl =
+dnl = Standalone module options
+dnl = 
+dnl ========================================================
+MOZ_ARG_HEADER(Standalone module options (Not for building Mozilla))
+
+if test -z "$SKIP_PATH_CHECKS"; then
+if test -z "${GLIB_CFLAGS}" || test -z "${GLIB_LIBS}" ; then
+    PKG_CHECK_MODULES(GLIB, glib-2.0 >= 1.3.7 gobject-2.0)
+fi
+fi
+
+if test -z "${GLIB_GMODULE_LIBS}" -a -n "${GLIB_CONFIG}"; then
+    GLIB_GMODULE_LIBS=`$GLIB_CONFIG gmodule --libs`
+fi
+
+AC_SUBST(GLIB_CFLAGS)
+AC_SUBST(GLIB_LIBS)
+AC_SUBST(GLIB_GMODULE_LIBS)
+
+dnl ========================================================
+if test "$MOZ_DEBUG" || test "$NS_TRACE_MALLOC"; then
+    MOZ_COMPONENTS_VERSION_SCRIPT_LDFLAGS=
+fi
+
+MOZ_ARG_WITH_STRING(sync-build-files,
+[  --with-sync-build-files=DIR
+                          Check that files in 'config' and 'build' match
+                          their originals in 'DIR/config' and 'DIR/build'.
+                          This helps keep the SpiderMonkey build machinery
+                          in sync with Mozilla's, on which it is based.],
+[MOZ_SYNC_BUILD_FILES=$withval ] )
+AC_SUBST(MOZ_SYNC_BUILD_FILES)
+
+dnl ========================================================
+dnl =
+dnl = Maintainer debug option (no --enable equivalent)
+dnl =
+dnl ========================================================
+
+AC_SUBST(AR)
+AC_SUBST(AR_FLAGS)
+AC_SUBST(AR_LIST)
+AC_SUBST(AR_EXTRACT)
+AC_SUBST(AR_DELETE)
+AC_SUBST(AS)
+AC_SUBST(ASFLAGS)
+AC_SUBST(AS_DASH_C_FLAG)
+AC_SUBST(LD)
+AC_SUBST(RC)
+AC_SUBST(RCFLAGS)
+AC_SUBST(WINDRES)
+AC_SUBST(USE_SHORT_LIBNAME)
+AC_SUBST(IMPLIB)
+AC_SUBST(FILTER)
+AC_SUBST(BIN_FLAGS)
+AC_SUBST(NS_USE_NATIVE)
+AC_SUBST(MOZ_JS_LIBS)
+AC_SUBST(MOZ_PSM)
+AC_SUBST(MOZ_DEBUG)
+AC_SUBST(MOZ_DEBUG_MODULES)
+AC_SUBST(MOZ_PROFILE_MODULES)
+AC_SUBST(MOZ_DEBUG_ENABLE_DEFS)
+AC_SUBST(MOZ_DEBUG_DISABLE_DEFS)
+AC_SUBST(MOZ_DEBUG_FLAGS)
+AC_SUBST(MOZ_DEBUG_LDFLAGS)
+AC_SUBST(WARNINGS_AS_ERRORS)
+AC_SUBST(MOZ_DBGRINFO_MODULES)
+AC_SUBST(ENABLE_EAZEL_PROFILER)
+AC_SUBST(EAZEL_PROFILER_CFLAGS)
+AC_SUBST(EAZEL_PROFILER_LIBS)
+AC_SUBST(MOZ_PERF_METRICS)
+AC_SUBST(GC_LEAK_DETECTOR)
+AC_SUBST(MOZ_LEAKY)
+AC_SUBST(MOZ_JPROF)
+AC_SUBST(MOZ_SHARK)
+AC_SUBST(MOZ_CALLGRIND)
+AC_SUBST(MOZ_VTUNE)
+AC_SUBST(MOZ_XPCTOOLS)
+AC_SUBST(MOZ_JSLOADER)
+AC_SUBST(MOZ_INSURE)
+AC_SUBST(MOZ_INSURE_DIRS)
+AC_SUBST(MOZ_INSURE_EXCLUDE_DIRS)
+AC_SUBST(MOZ_QUANTIFY)
+AC_SUBST(MOZ_INSURIFYING)
+AC_SUBST(LIBICONV)
+
+AC_SUBST(BUILD_STATIC_LIBS)
+AC_SUBST(ENABLE_TESTS)
+
+AC_SUBST(ENABLE_STRIP)
+AC_SUBST(PKG_SKIP_STRIP)
+AC_SUBST(USE_ELF_DYNSTR_GC)
+AC_SUBST(INCREMENTAL_LINKER)
+AC_SUBST(MOZ_COMPONENTS_VERSION_SCRIPT_LDFLAGS)
+AC_SUBST(MOZ_COMPONENT_NSPR_LIBS)
+
+AC_SUBST(MOZ_FIX_LINK_PATHS)
+
+AC_SUBST(USE_DEPENDENT_LIBS)
+
+AC_SUBST(MOZ_BUILD_ROOT)
+AC_SUBST(MOZ_OS2_TOOLS)
+AC_SUBST(MOZ_OS2_USE_DECLSPEC)
+
+AC_SUBST(MOZ_POST_DSO_LIB_COMMAND)
+AC_SUBST(MOZ_POST_PROGRAM_COMMAND)
+AC_SUBST(MOZ_TIMELINE)
+AC_SUBST(WINCE)
+AC_SUBST(TARGET_DEVICE)
+
+AC_SUBST(MOZ_APP_NAME)
+AC_SUBST(MOZ_APP_DISPLAYNAME)
+AC_SUBST(MOZ_APP_VERSION)
+
+AC_SUBST(MOZ_PKG_SPECIAL)
+
+AC_SUBST(MOZILLA_OFFICIAL)
+AC_SUBST(BUILD_OFFICIAL)
+AC_SUBST(MOZ_MILESTONE_RELEASE)
+
+dnl win32 options
+AC_SUBST(MOZ_PROFILE)
+AC_SUBST(MOZ_DEBUG_SYMBOLS)
+AC_SUBST(MOZ_MAPINFO)
+AC_SUBST(MOZ_BROWSE_INFO)
+AC_SUBST(MOZ_TOOLS_DIR)
+AC_SUBST(CYGWIN_WRAPPER)
+AC_SUBST(AS_PERL)
+AC_SUBST(WIN32_REDIST_DIR)
+AC_SUBST(PYTHON)
+
+dnl Echo the CFLAGS to remove extra whitespace.
+CFLAGS=`echo \
+	$_WARNINGS_CFLAGS \
+	$CFLAGS`
+
+CXXFLAGS=`echo \
+	$_MOZ_RTTI_FLAGS \
+	$_MOZ_EXCEPTIONS_FLAGS \
+	$_WARNINGS_CXXFLAGS \
+	$CXXFLAGS`
+
+COMPILE_CFLAGS=`echo \
+    $_DEFINES_CFLAGS \
+	$_DEPEND_CFLAGS \
+    $COMPILE_CFLAGS`
+
+COMPILE_CXXFLAGS=`echo \
+    $_DEFINES_CXXFLAGS \
+	$_DEPEND_CFLAGS \
+    $COMPILE_CXXFLAGS`
+
+AC_SUBST(SYSTEM_MAKEDEPEND)
+
+AC_SUBST(NSPR_CFLAGS)
+AC_SUBST(NSPR_LIBS)
+AC_SUBST(MOZ_NATIVE_NSPR)
+
+AC_SUBST(CFLAGS)
+AC_SUBST(CXXFLAGS)
+AC_SUBST(CPPFLAGS)
+AC_SUBST(COMPILE_CFLAGS)
+AC_SUBST(COMPILE_CXXFLAGS)
+AC_SUBST(LDFLAGS)
+AC_SUBST(LIBS)
+AC_SUBST(CROSS_COMPILE)
+AC_SUBST(WCHAR_CFLAGS)
+
+AC_SUBST(HOST_CC)
+AC_SUBST(HOST_CXX)
+AC_SUBST(HOST_CFLAGS)
+AC_SUBST(HOST_CXXFLAGS)
+AC_SUBST(HOST_OPTIMIZE_FLAGS)
+AC_SUBST(HOST_AR)
+AC_SUBST(HOST_AR_FLAGS)
+AC_SUBST(HOST_LD)
+AC_SUBST(HOST_RANLIB)
+AC_SUBST(HOST_NSPR_MDCPUCFG)
+AC_SUBST(HOST_BIN_SUFFIX)
+AC_SUBST(HOST_OS_ARCH)
+
+AC_SUBST(TARGET_CPU)
+AC_SUBST(TARGET_VENDOR)
+AC_SUBST(TARGET_OS)
+AC_SUBST(TARGET_NSPR_MDCPUCFG)
+AC_SUBST(TARGET_MD_ARCH)
+AC_SUBST(TARGET_XPCOM_ABI)
+AC_SUBST(OS_TARGET)
+AC_SUBST(OS_ARCH)
+AC_SUBST(OS_RELEASE)
+AC_SUBST(OS_TEST)
+
+AC_SUBST(WRAP_MALLOC_CFLAGS)
+AC_SUBST(WRAP_MALLOC_LIB)
+AC_SUBST(MKSHLIB)
+AC_SUBST(MKCSHLIB)
+AC_SUBST(MKSHLIB_FORCE_ALL)
+AC_SUBST(MKSHLIB_UNFORCE_ALL)
+AC_SUBST(DSO_CFLAGS)
+AC_SUBST(DSO_PIC_CFLAGS)
+AC_SUBST(DSO_LDOPTS)
+AC_SUBST(LIB_PREFIX)
+AC_SUBST(DLL_PREFIX)
+AC_SUBST(DLL_SUFFIX)
+AC_DEFINE_UNQUOTED(MOZ_DLL_SUFFIX, "$DLL_SUFFIX")
+AC_SUBST(LIB_SUFFIX)
+AC_SUBST(OBJ_SUFFIX)
+AC_SUBST(BIN_SUFFIX)
+AC_SUBST(ASM_SUFFIX)
+AC_SUBST(IMPORT_LIB_SUFFIX)
+AC_SUBST(USE_N32)
+AC_SUBST(CC_VERSION)
+AC_SUBST(CXX_VERSION)
+AC_SUBST(MSMANIFEST_TOOL)
+
+if test "$USING_HCC"; then
+   CC='${topsrcdir}/build/hcc'
+   CC="$CC '$_OLDCC'"
+   CXX='${topsrcdir}/build/hcpp'
+   CXX="$CXX '$_OLDCXX'"
+   AC_SUBST(CC)
+   AC_SUBST(CXX)
+fi
+
+dnl Check for missing components
+if test "$COMPILE_ENVIRONMENT"; then
+if test "$MOZ_X11"; then
+    dnl ====================================================
+    dnl = Check if X headers exist
+    dnl ====================================================
+    _SAVE_CFLAGS=$CFLAGS
+    CFLAGS="$CFLAGS $XCFLAGS"
+    AC_TRY_COMPILE([
+        #include <stdio.h>
+        #include <stdlib.h>
+        #include <X11/Xlib.h>
+        #include <X11/Intrinsic.h>
+    ],
+    [
+        Display *dpy = 0;
+        if ((dpy = XOpenDisplay(NULL)) == NULL) {
+            fprintf(stderr, ": can't open %s\n", XDisplayName(NULL));
+            exit(1);
+        }
+    ], [], 
+    [ AC_MSG_ERROR([Could not compile basic X program.]) ])
+    CFLAGS="$_SAVE_CFLAGS"
+
+    if test ! -z "$MISSING_X"; then
+        AC_MSG_ERROR([ Could not find the following X libraries: $MISSING_X ]);
+    fi
+
+fi # MOZ_X11
+fi # COMPILE_ENVIRONMENT
+
+dnl Set various defines and substitutions
+dnl ========================================================
+
+if test "$OS_ARCH" = "BeOS"; then
+  AC_DEFINE(XP_BEOS)
+  MOZ_MOVEMAIL=1
+elif test "$OS_ARCH" = "Darwin"; then
+  AC_DEFINE(XP_UNIX)
+  AC_DEFINE(UNIX_ASYNC_DNS)
+  MOZ_MOVEMAIL=1
+elif test "$OS_ARCH" = "OpenVMS"; then
+  AC_DEFINE(XP_UNIX)
+elif test "$OS_ARCH" != "WINNT" -a "$OS_ARCH" != "OS2" -a "$OS_ARCH" != "WINCE"; then
+  AC_DEFINE(XP_UNIX)
+  AC_DEFINE(UNIX_ASYNC_DNS)
+  MOZ_MOVEMAIL=1
+fi
+AC_SUBST(MOZ_MOVEMAIL)
+
+AC_ARG_ENABLE(threadsafe,
+              [  --enable-threadsafe     Enable support for multiple threads.],
+              [AC_DEFINE(JS_THREADSAFE)],)
+
+if test "$MOZ_DEBUG"; then
+    AC_DEFINE(MOZ_REFLOW_PERF)
+    AC_DEFINE(MOZ_REFLOW_PERF_DSP)
+fi
+
+if test "$ACCESSIBILITY" -a "$MOZ_ENABLE_GTK2" ; then
+    AC_DEFINE(MOZ_ACCESSIBILITY_ATK)
+    ATK_FULL_VERSION=`$PKG_CONFIG --modversion atk`
+    ATK_MAJOR_VERSION=`echo ${ATK_FULL_VERSION} | $AWK -F\. '{ print $1 }'`
+    ATK_MINOR_VERSION=`echo ${ATK_FULL_VERSION} | $AWK -F\. '{ print $2 }'`
+    ATK_REV_VERSION=`echo ${ATK_FULL_VERSION} | $AWK -F\. '{ print $3 }'`
+    AC_DEFINE_UNQUOTED(ATK_MAJOR_VERSION, $ATK_MAJOR_VERSION)
+    AC_DEFINE_UNQUOTED(ATK_MINOR_VERSION, $ATK_MINOR_VERSION)
+    AC_DEFINE_UNQUOTED(ATK_REV_VERSION, $ATK_REV_VERSION)
+fi
+
+# Used for LD_LIBRARY_PATH of run_viewer target
+LIBS_PATH=
+for lib_arg in $NSPR_LIBS $TK_LIBS; do
+  case $lib_arg in
+    -L* ) LIBS_PATH="${LIBS_PATH:+$LIBS_PATH:}"`expr $lib_arg : "-L\(.*\)"` ;;
+      * ) ;;
+  esac
+done
+AC_SUBST(LIBS_PATH)
+
+dnl ========================================================
+dnl Use cygwin wrapper for win32 builds, except MSYS/MinGW
+dnl ========================================================
+case "$host_os" in
+mingw*)
+    WIN_TOP_SRC=`cd $srcdir; pwd -W`
+    ;;
+cygwin*|msvc*|mks*)
+    HOST_CC="\$(CYGWIN_WRAPPER) $HOST_CC"
+    HOST_CXX="\$(CYGWIN_WRAPPER) $HOST_CXX"
+    CC="\$(CYGWIN_WRAPPER) $CC"
+    CXX="\$(CYGWIN_WRAPPER) $CXX"
+    CPP="\$(CYGWIN_WRAPPER) $CPP"
+    LD="\$(CYGWIN_WRAPPER) $LD"
+    AS="\$(CYGWIN_WRAPPER) $AS"
+    RC="\$(CYGWIN_WRAPPER) $RC"
+    MIDL="\$(CYGWIN_WRAPPER) $MIDL"
+    CYGDRIVE_MOUNT=`mount -p | awk '{ if (/^\//) { print $1; exit } }'`
+    WIN_TOP_SRC=`cygpath -a -w $srcdir | sed -e 's|\\\\|/|g'`
+    ;;
+esac
+
+AC_SUBST(CYGDRIVE_MOUNT)
+AC_SUBST(WIN_TOP_SRC)
+
+AC_SUBST(MOZILLA_VERSION)
+
+AC_SUBST(ac_configure_args)
+
+dnl Spit out some output
+dnl ========================================================
+
+# Save the defines header file before autoconf removes it.
+# (Do not add AC_DEFINE calls after this line.)
+  _CONFIG_TMP=confdefs-tmp.h
+  _CONFIG_DEFS_H=mozilla-config.h
+
+  cat > $_CONFIG_TMP <<\EOF
+/* List of defines generated by configure. Included with preprocessor flag,
+ * -include, to avoid long list of -D defines on the compile command-line.
+ * Do not edit.
+ */
+
+#ifndef _MOZILLA_CONFIG_H_
+#define _MOZILLA_CONFIG_H_
+EOF
+
+_EGREP_PATTERN='^#define ('
+if test -n "$_NON_GLOBAL_ACDEFINES"; then
+    for f in $_NON_GLOBAL_ACDEFINES; do
+        _EGREP_PATTERN="${_EGREP_PATTERN}$f|"
+    done
+fi
+_EGREP_PATTERN="${_EGREP_PATTERN}dummy_never_defined)"
+ 
+  sort confdefs.h | egrep -v "$_EGREP_PATTERN" >> $_CONFIG_TMP
+
+  cat >> $_CONFIG_TMP <<\EOF
+
+#endif /* _MOZILLA_CONFIG_H_ */
+
+EOF
+
+  # Only write mozilla-config.h when something changes (or it doesn't exist)
+  if cmp -s $_CONFIG_TMP $_CONFIG_DEFS_H; then
+    rm $_CONFIG_TMP
+  else
+    AC_MSG_RESULT("creating $_CONFIG_DEFS_H")
+    mv -f $_CONFIG_TMP $_CONFIG_DEFS_H
+
+    echo ==== $_CONFIG_DEFS_H =================================
+    cat $_CONFIG_DEFS_H
+  fi
+
+dnl Probably shouldn't call this manually but we always want the output of DEFS
+rm -f confdefs.h.save
+mv confdefs.h confdefs.h.save
+egrep -v "$_EGREP_PATTERN" confdefs.h.save > confdefs.h
+AC_OUTPUT_MAKE_DEFS()
+MOZ_DEFINES=$DEFS
+AC_SUBST(MOZ_DEFINES)
+rm -f confdefs.h
+mv confdefs.h.save confdefs.h
+
+MAKEFILES="
+  Makefile
+  config/Makefile
+  config/autoconf.mk
+  config/mkdepend/Makefile
+"
+
+dnl 
+dnl Run a perl script to quickly create the makefiles.
+dnl If it succeeds, it outputs a shell command to set CONFIG_FILES
+dnl   for the files it cannot handle correctly. This way, config.status
+dnl   will handle these files.
+dnl If it fails, nothing is set and config.status will run as usual.
+dnl
+dnl This does not change the $MAKEFILES variable.
+dnl
+dnl OpenVMS gets a line overflow on the long eval command, so use a temp file.
+dnl
+if test -z "${AS_PERL}"; then
+echo $MAKEFILES | ${PERL} $srcdir/build/autoconf/acoutput-fast.pl > conftest.sh
+else
+echo $MAKEFILES | ${PERL} $srcdir/build/autoconf/acoutput-fast.pl -nowrap --cygwin-srcdir=$srcdir > conftest.sh
+fi
+. ./conftest.sh
+rm conftest.sh
+
+echo $MAKEFILES > unallmakefiles
+
+AC_OUTPUT($MAKEFILES)
+
+# Produce the js-config script at configure time; see the comments for
+# 'js-config' in Makefile.in.
+AC_MSG_RESULT(invoking make to create js-config script)
+$MAKE js-config
diff -r 17e9560465b0 js/src/jitstats.tbl
--- a/js/src/jitstats.tbl	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/jitstats.tbl	Thu Oct 30 05:41:45 2008 -0400
@@ -48,3 +48,4 @@
 JITSTAT(unstableLoopVariable)
 JITSTAT(breakLoopExits)
 JITSTAT(returnLoopExits)
+JITSTAT(mergedLoopExits)
diff -r 17e9560465b0 js/src/js-config.h.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/js-config.h.in	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,55 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * vim: set ts=8 sw=4 et tw=78:
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released
+ * March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef js_config_h___
+#define js_config_h___
+
+/* Definitions set at build time that affect SpiderMonkey's public API.
+   This header file is generated by the SpiderMonkey configure script,
+   and installed along with jsapi.h.  */
+
+/* Define to 1 if SpiderMonkey should support multi-threaded clients.  */
+#undef JS_THREADSAFE
+
+/* Define to 1 if SpiderMonkey should support the ability to perform
+   entirely too much GC.  */
+#undef JS_GC_ZEAL
+
+#endif /* js_config_h___ */
diff -r 17e9560465b0 js/src/js-config.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/js-config.in	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,111 @@
+#!/bin/sh
+
+prefix='@prefix@'
+mozilla_version='@MOZILLA_VERSION@'
+LIBRARY_NAME='@LIBRARY_NAME@'
+NSPR_CFLAGS='@NSPR_CFLAGS@'
+JS_CONFIG_LIBS='@JS_CONFIG_LIBS@'
+MOZ_JS_LIBS='@MOZ_JS_LIBS@'
+
+usage()
+{
+	cat <<EOF
+Usage: js-config [OPTIONS]
+Options:
+	[--prefix[=DIR]]
+	[--exec-prefix[=DIR]]
+	[--includedir[=DIR]]
+	[--libdir[=DIR]]
+	[--version]
+	[--libs]
+	[--cflags]
+	[--lib-filenames]
+EOF
+	exit $1
+}
+
+if test $# -eq 0; then
+	usage 1 1>&2
+fi
+
+while test $# -gt 0; do
+  case "$1" in
+  -*=*) optarg=`echo "$1" | sed 's/[-_a-zA-Z0-9]*=//'` ;;
+  *) optarg= ;;
+  esac
+
+  case $1 in
+    --prefix=*)
+      prefix=$optarg
+      ;;
+    --prefix)
+      echo_prefix=yes
+      ;;
+    --exec-prefix=*)
+      exec_prefix=$optarg
+      ;;
+    --exec-prefix)
+      echo_exec_prefix=yes
+      ;;
+    --includedir=*)
+      includedir=$optarg
+      ;;
+    --includedir)
+      echo_includedir=yes
+      ;;
+    --libdir=*)
+      libdir=$optarg
+      ;;
+    --libdir)
+      echo_libdir=yes
+      ;;
+    --version)
+      echo "$mozilla_version"
+      ;;
+    --cflags)
+      echo_cflags=yes
+      ;;
+    --libs)
+      echo_libs=yes
+      ;;
+    *)
+      usage 1 1>&2
+      ;;
+  esac
+  shift
+done
+
+# Set variables that may be dependent upon other variables
+if test -z "$exec_prefix"; then
+    exec_prefix=@exec_prefix@
+fi
+if test -z "$includedir"; then
+    includedir=@includedir@
+fi
+if test -z "$libdir"; then
+    libdir=@libdir@
+fi
+
+if test "$echo_prefix" = "yes"; then
+    echo $prefix
+fi
+
+if test "$echo_exec_prefix" = "yes"; then
+    echo $exec_prefix
+fi
+
+if test "$echo_includedir" = "yes"; then
+    echo $includedir
+fi
+
+if test "$echo_libdir" = "yes"; then
+    echo $libdir
+fi
+
+if test "$echo_cflags" = "yes"; then
+    echo "-I$includedir/js $NSPR_CFLAGS"
+fi
+
+if test "$echo_libs" = "yes"; then
+    echo "$MOZ_JS_LIBS $JS_CONFIG_LIBS"
+fi      
diff -r 17e9560465b0 js/src/js.cpp
--- a/js/src/js.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/js.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -54,6 +54,7 @@
 #include "jsapi.h"
 #include "jsarray.h"
 #include "jsatom.h"
+#include "jsbuiltins.h"
 #include "jscntxt.h"
 #include "jsdbgapi.h"
 #include "jsemit.h"
@@ -758,6 +759,20 @@
     *vp = STRING_TO_JSVAL(str);
     return JS_TRUE;
 }
+
+#ifdef JS_TRACER
+static jsval JS_FASTCALL
+Print_tn(JSContext *cx, JSString *str)
+{
+    char *bytes = JS_EncodeString(cx, str);
+    if (!bytes)
+        return JSVAL_ERROR_COOKIE;
+    fprintf(gOutFile, "%s\n", bytes);
+    JS_free(cx, bytes);
+    fflush(gOutFile);
+    return JSVAL_VOID;
+}
+#endif
 
 static JSBool
 Print(JSContext *cx, uintN argc, jsval *vp)
@@ -2540,10 +2555,31 @@
     return ok;
 }
 
-#ifdef JS_THREADSAFE
-
-static JSBool
-Sleep(JSContext *cx, uintN argc, jsval *vp)
+static int32 JS_FASTCALL
+ShapeOf_tn(JSObject *obj)
+{
+    if (!obj)
+        return 0;
+    if (!OBJ_IS_NATIVE(obj))
+        return -1;
+    return OBJ_SHAPE(obj);
+}
+
+static JSBool
+ShapeOf(JSContext *cx, uintN argc, jsval *vp)
+{
+    jsval v = JS_ARGV(cx, vp)[0];
+    if (!JSVAL_IS_OBJECT(v)) {
+        JS_ReportError(cx, "shapeOf: object expected");
+        return JS_FALSE;
+    }
+    return JS_NewNumberValue(cx, ShapeOf_tn(JSVAL_TO_OBJECT(v)), vp);
+}
+
+#ifdef JS_THREADSAFE
+
+static JSBool
+Sleep_fn(JSContext *cx, uintN argc, jsval *vp)
 {
     jsdouble t_secs;
     PRUint32 t_ticks;
@@ -2803,13 +2839,16 @@
 
 #endif
 
+JS_DEFINE_TRCINFO_1(Print, (2, (static, JSVAL_FAIL, Print_tn, CONTEXT, STRING, 0, 0)))
+JS_DEFINE_TRCINFO_1(ShapeOf, (1, (static, INT32, ShapeOf_tn, OBJECT, 0, 0)))
+
 /* We use a mix of JS_FS and JS_FN to test both kinds of natives. */
 static JSFunctionSpec shell_functions[] = {
     JS_FS("version",        Version,        0,0,0),
     JS_FS("options",        Options,        0,0,0),
     JS_FS("load",           Load,           1,0,0),
     JS_FN("readline",       ReadLine,       0,0),
-    JS_FN("print",          Print,          0,0),
+    JS_TN("print",          Print,          0,0, Print_trcinfo),
     JS_FS("help",           Help,           0,0,0),
     JS_FS("quit",           Quit,           0,0,0),
     JS_FN("gc",             GC,             0,0),
@@ -2847,6 +2886,7 @@
     JS_FN("getslx",         GetSLX,         1,0),
     JS_FN("toint32",        ToInt32,        1,0),
     JS_FS("evalcx",         EvalInContext,  1,0,0),
+    JS_TN("shapeOf",        ShapeOf,        1,0, ShapeOf_trcinfo),
 #ifdef MOZ_SHARK
     JS_FS("startShark",      js_StartShark,      0,0,0),
     JS_FS("stopShark",       js_StopShark,       0,0,0),
@@ -2868,7 +2908,7 @@
     JS_FS("arrayInfo",       js_ArrayInfo,       1,0,0),
 #endif
 #ifdef JS_THREADSAFE
-    JS_FN("sleep",          Sleep,          1,0),
+    JS_FN("sleep",          Sleep_fn,       1,0),
     JS_FN("scatter",        Scatter,        1,0),
 #endif
     JS_FS_END
@@ -2931,6 +2971,7 @@
 "  Evaluate s in optional sandbox object o\n"
 "  if (s == '' && !o) return new o with eager standard classes\n"
 "  if (s == 'lazy' && !o) return new o with lazy standard classes",
+"shapeOf(obj)             Get the shape of obj (an implementation detail)",
 #ifdef MOZ_SHARK
 "startShark()             Start a Shark session.\n"
 "                         Shark must be running with programatic sampling.",
diff -r 17e9560465b0 js/src/jsapi.cpp
--- a/js/src/jsapi.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/jsapi.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -3113,6 +3113,20 @@
 }
 
 static JSBool
+DefinePropertyById(JSContext *cx, JSObject *obj, jsid id, jsval value,
+                   JSPropertyOp getter, JSPropertyOp setter, uintN attrs,
+                   uintN flags, intN tinyid)
+{
+    if (flags != 0 && OBJ_IS_NATIVE(obj)) {
+        JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED | JSRESOLVE_DECLARING);
+        return js_DefineNativeProperty(cx, obj, id, value, getter, setter,
+                                       attrs, flags, tinyid, NULL);
+    }
+    return OBJ_DEFINE_PROPERTY(cx, obj, id, value, getter, setter, attrs,
+                               NULL);   
+}
+
+static JSBool
 DefineProperty(JSContext *cx, JSObject *obj, const char *name, jsval value,
                JSPropertyOp getter, JSPropertyOp setter, uintN attrs,
                uintN flags, intN tinyid)
@@ -3130,13 +3144,8 @@
             return JS_FALSE;
         id = ATOM_TO_JSID(atom);
     }
-    if (flags != 0 && OBJ_IS_NATIVE(obj)) {
-        JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED | JSRESOLVE_DECLARING);
-        return js_DefineNativeProperty(cx, obj, id, value, getter, setter,
-                                       attrs, flags, tinyid, NULL);
-    }
-    return OBJ_DEFINE_PROPERTY(cx, obj, id, value, getter, setter, attrs,
-                               NULL);
+    return DefinePropertyById(cx, obj, id, value, getter, setter, attrs,
+                              flags, tinyid);
 }
 
 #define AUTO_NAMELEN(s,n)   (((n) == (size_t)-1) ? js_strlen(s) : (n))
@@ -3226,6 +3235,14 @@
 {
     CHECK_REQUEST(cx);
     return DefineProperty(cx, obj, name, value, getter, setter, attrs, 0, 0);
+}
+
+JS_PUBLIC_API(JSBool)
+JS_DefinePropertyById(JSContext *cx, JSObject *obj, jsid id, jsval value,
+                      JSPropertyOp getter, JSPropertyOp setter, uintN attrs)
+{
+    CHECK_REQUEST(cx);
+    return DefinePropertyById(cx, obj, id, value, getter, setter, attrs, 0, 0);
 }
 
 JS_PUBLIC_API(JSBool)
@@ -3478,6 +3495,14 @@
 }
 
 JS_PUBLIC_API(JSBool)
+JS_AlreadyHasOwnPropertyById(JSContext *cx, JSObject *obj, jsid id,
+                             JSBool *foundp)
+{
+    CHECK_REQUEST(cx);
+    return AlreadyHasOwnPropertyHelper(cx, obj, id, foundp);
+}
+
+JS_PUBLIC_API(JSBool)
 JS_HasProperty(JSContext *cx, JSObject *obj, const char *name, JSBool *foundp)
 {
     JSBool ok;
@@ -3497,6 +3522,25 @@
 }
 
 JS_PUBLIC_API(JSBool)
+JS_HasPropertyById(JSContext *cx, JSObject *obj, jsid id, JSBool *foundp)
+{
+    JSBool ok;
+    JSObject *obj2;
+    JSProperty *prop;
+
+    CHECK_REQUEST(cx);
+    ok = LookupPropertyById(cx, obj, id,
+                            JSRESOLVE_QUALIFIED | JSRESOLVE_DETECTING,
+                            &obj2, &prop);
+    if (ok) {
+       *foundp = (prop != NULL);
+       if (prop)
+           OBJ_DROP_PROPERTY(cx, obj2, prop);
+    }
+    return ok;
+}
+
+JS_PUBLIC_API(JSBool)
 JS_LookupProperty(JSContext *cx, JSObject *obj, const char *name, jsval *vp)
 {
     JSBool ok;
@@ -3511,6 +3555,20 @@
 }
 
 JS_PUBLIC_API(JSBool)
+JS_LookupPropertyById(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
+{
+    JSBool ok;
+    JSObject *obj2;
+    JSProperty *prop;
+
+    CHECK_REQUEST(cx);
+    ok = LookupPropertyById(cx, obj, id, JSRESOLVE_QUALIFIED, &obj2, &prop);
+    if (ok)
+        *vp = LookupResult(cx, obj, obj2, prop);
+    return ok;
+}
+
+JS_PUBLIC_API(JSBool)
 JS_LookupPropertyWithFlags(JSContext *cx, JSObject *obj, const char *name,
                            uintN flags, jsval *vp)
 {
@@ -3519,12 +3577,12 @@
 
     atom = js_Atomize(cx, name, strlen(name), 0);
     return atom &&
-           JS_LookupPropertyByIdWithFlags(cx, obj, ATOM_TO_JSID(atom), flags,
+           JS_LookupPropertyWithFlagsById(cx, obj, ATOM_TO_JSID(atom), flags,
                                           &obj2, vp);
 }
 
 JS_PUBLIC_API(JSBool)
-JS_LookupPropertyByIdWithFlags(JSContext *cx, JSObject *obj, jsid id,
+JS_LookupPropertyWithFlagsById(JSContext *cx, JSObject *obj, jsid id,
                                uintN flags, JSObject **objp, jsval *vp)
 {
     JSBool ok;
@@ -3554,6 +3612,14 @@
 }
 
 JS_PUBLIC_API(JSBool)
+JS_GetPropertyById(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
+{
+    CHECK_REQUEST(cx);
+    JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
+    return OBJ_GET_PROPERTY(cx, obj, id, vp);
+}
+
+JS_PUBLIC_API(JSBool)
 JS_GetMethodById(JSContext *cx, JSObject *obj, jsid id, JSObject **objp,
                  jsval *vp)
 {
@@ -3606,11 +3672,18 @@
 }
 
 JS_PUBLIC_API(JSBool)
+JS_SetPropertyById(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
+{
+    CHECK_REQUEST(cx);
+    JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED | JSRESOLVE_ASSIGNING);
+    return OBJ_SET_PROPERTY(cx, obj, id, vp);
+}
+
+JS_PUBLIC_API(JSBool)
 JS_DeleteProperty(JSContext *cx, JSObject *obj, const char *name)
 {
     jsval junk;
 
-    CHECK_REQUEST(cx);
     return JS_DeleteProperty2(cx, obj, name, &junk);
 }
 
@@ -3627,6 +3700,22 @@
 
     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
     return OBJ_DELETE_PROPERTY(cx, obj, ATOM_TO_JSID(atom), rval);
+}
+
+JS_PUBLIC_API(JSBool)
+JS_DeletePropertyById(JSContext *cx, JSObject *obj, jsid id)
+{
+    jsval junk;
+
+    return JS_DeletePropertyById2(cx, obj, id, &junk);
+}
+
+JS_PUBLIC_API(JSBool)
+JS_DeletePropertyById2(JSContext *cx, JSObject *obj, jsid id, jsval *rval)
+{
+    CHECK_REQUEST(cx);
+    JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
+    return OBJ_DELETE_PROPERTY(cx, obj, id, rval);
 }
 
 JS_PUBLIC_API(JSBool)
diff -r 17e9560465b0 js/src/jsapi.h
--- a/js/src/jsapi.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/jsapi.h	Thu Oct 30 05:41:45 2008 -0400
@@ -45,6 +45,7 @@
  */
 #include <stddef.h>
 #include <stdio.h>
+#include "js-config.h"
 #include "jspubtd.h"
 #include "jsutil.h"
 
@@ -1569,6 +1570,10 @@
 JS_DefineProperty(JSContext *cx, JSObject *obj, const char *name, jsval value,
                   JSPropertyOp getter, JSPropertyOp setter, uintN attrs);
 
+extern JS_PUBLIC_API(JSBool)
+JS_DefinePropertyById(JSContext *cx, JSObject *obj, jsid id, jsval value,
+                      JSPropertyOp getter, JSPropertyOp setter, uintN attrs);
+
 /*
  * Determine the attributes (JSPROP_* flags) of a property on a given object.
  *
@@ -1616,21 +1621,34 @@
                          JSBool *foundp);
 
 extern JS_PUBLIC_API(JSBool)
+JS_AlreadyHasOwnPropertyById(JSContext *cx, JSObject *obj, jsid id,
+                             JSBool *foundp);
+
+extern JS_PUBLIC_API(JSBool)
 JS_HasProperty(JSContext *cx, JSObject *obj, const char *name, JSBool *foundp);
 
 extern JS_PUBLIC_API(JSBool)
+JS_HasPropertyById(JSContext *cx, JSObject *obj, jsid id, JSBool *foundp);
+
+extern JS_PUBLIC_API(JSBool)
 JS_LookupProperty(JSContext *cx, JSObject *obj, const char *name, jsval *vp);
+
+extern JS_PUBLIC_API(JSBool)
+JS_LookupPropertyById(JSContext *cx, JSObject *obj, jsid id, jsval *vp);
 
 extern JS_PUBLIC_API(JSBool)
 JS_LookupPropertyWithFlags(JSContext *cx, JSObject *obj, const char *name,
                            uintN flags, jsval *vp);
 
 extern JS_PUBLIC_API(JSBool)
-JS_LookupPropertyByIdWithFlags(JSContext *cx, JSObject *obj, jsid id,
+JS_LookupPropertyWithFlagsById(JSContext *cx, JSObject *obj, jsid id,
                                uintN flags, JSObject **objp, jsval *vp);
 
 extern JS_PUBLIC_API(JSBool)
 JS_GetProperty(JSContext *cx, JSObject *obj, const char *name, jsval *vp);
+
+extern JS_PUBLIC_API(JSBool)
+JS_GetPropertyById(JSContext *cx, JSObject *obj, jsid id, jsval *vp);
 
 extern JS_PUBLIC_API(JSBool)
 JS_GetMethodById(JSContext *cx, JSObject *obj, jsid id, JSObject **objp,
@@ -1644,11 +1662,20 @@
 JS_SetProperty(JSContext *cx, JSObject *obj, const char *name, jsval *vp);
 
 extern JS_PUBLIC_API(JSBool)
+JS_SetPropertyById(JSContext *cx, JSObject *obj, jsid id, jsval *vp);
+
+extern JS_PUBLIC_API(JSBool)
 JS_DeleteProperty(JSContext *cx, JSObject *obj, const char *name);
 
 extern JS_PUBLIC_API(JSBool)
 JS_DeleteProperty2(JSContext *cx, JSObject *obj, const char *name,
                    jsval *rval);
+
+extern JS_PUBLIC_API(JSBool)
+JS_DeletePropertyById(JSContext *cx, JSObject *obj, jsid id);
+
+extern JS_PUBLIC_API(JSBool)
+JS_DeletePropertyById2(JSContext *cx, JSObject *obj, jsid id, jsval *rval);
 
 extern JS_PUBLIC_API(JSBool)
 JS_DefineUCProperty(JSContext *cx, JSObject *obj,
diff -r 17e9560465b0 js/src/jsarray.cpp
--- a/js/src/jsarray.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/jsarray.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -1538,8 +1538,8 @@
 }
 
 #ifdef JS_TRACER
-JSString* FASTCALL
-js_Array_p_join(JSContext* cx, JSObject* obj, JSString *str)
+static JSString* FASTCALL
+Array_p_join(JSContext* cx, JSObject* obj, JSString *str)
 {
     jsval v;
     if (!array_join_sub(cx, obj, TO_STRING, str, &v))
@@ -2126,8 +2126,8 @@
 }
 
 #ifdef JS_TRACER
-jsval FASTCALL
-js_Array_p_push1(JSContext* cx, JSObject* obj, jsval v)
+static jsval FASTCALL
+Array_p_push1(JSContext* cx, JSObject* obj, jsval v)
 {
     if (OBJ_IS_DENSE_ARRAY(cx, obj) 
         ? array_push1_dense(cx, obj, v, &v)
@@ -2197,8 +2197,8 @@
 }
 
 #ifdef JS_TRACER
-jsval FASTCALL
-js_Array_p_pop(JSContext* cx, JSObject* obj)
+static jsval FASTCALL
+Array_p_pop(JSContext* cx, JSObject* obj)
 {
     jsval v;
     if (OBJ_IS_DENSE_ARRAY(cx, obj) 
@@ -2967,23 +2967,12 @@
     {0,0,0,0,0}
 };
 
-#ifdef JS_TRACER
-
-JS_DEFINE_CALLINFO_3(STRING,    Array_p_join, CONTEXT, OBJECT, STRING,  0, 0)
-JS_DEFINE_CALLINFO_3(JSVAL,     Array_p_push1, CONTEXT, OBJECT, JSVAL,  0, 0)
-JS_DEFINE_CALLINFO_2(JSVAL,     Array_p_pop, CONTEXT, OBJECT,           0, 0)
-
-static JSTraceableNative array_join_trcinfo[] = {
-    { array_join, &ci_Array_p_join,  "TC",  "s", FAIL_NULL }
-};
-static JSTraceableNative array_push_trcinfo[] = {
-    { array_push, &ci_Array_p_push1, "TC",  "v", FAIL_JSVAL }
-};
-static JSTraceableNative array_pop_trcinfo[] = {
-    { array_pop,  &ci_Array_p_pop,   "TC",  "",  FAIL_JSVAL }
-};
-
-#endif /* JS_TRACER */
+JS_DEFINE_TRCINFO_1(array_join,
+    (3, (static, STRING_FAIL, Array_p_join, CONTEXT, THIS, STRING,  0, 0)))
+JS_DEFINE_TRCINFO_1(array_push,
+    (3, (static, JSVAL_FAIL, Array_p_push1, CONTEXT, THIS, JSVAL,  0, 0)))
+JS_DEFINE_TRCINFO_1(array_pop,
+    (2, (static, JSVAL_FAIL, Array_p_pop, CONTEXT, THIS,           0, 0)))
 
 static JSFunctionSpec array_methods[] = {
 #if JS_HAS_TOSOURCE
@@ -3417,9 +3406,9 @@
     return JS_TRUE;
 }
 
-JS_DEFINE_CALLINFO_4(BOOL,      Array_dense_setelem, CONTEXT, OBJECT, INT32, JSVAL,   0, 0)
-JS_DEFINE_CALLINFO_2(OBJECT,    FastNewArray, CONTEXT, OBJECT,                        0, 0)
-JS_DEFINE_CALLINFO_3(OBJECT,    Array_1int, CONTEXT, OBJECT, INT32,                   0, 0)
-JS_DEFINE_CALLINFO_3(OBJECT,    Array_1str, CONTEXT, OBJECT, STRING,                  0, 0)
-JS_DEFINE_CALLINFO_4(OBJECT,    Array_2obj, CONTEXT, OBJECT, OBJECT, OBJECT,          0, 0)
-JS_DEFINE_CALLINFO_5(OBJECT,    Array_3num, CONTEXT, OBJECT, DOUBLE, DOUBLE, DOUBLE,  0, 0)
+JS_DEFINE_CALLINFO_4(extern, BOOL,   js_Array_dense_setelem, CONTEXT, OBJECT, INT32, JSVAL,   0, 0)
+JS_DEFINE_CALLINFO_2(extern, OBJECT, js_FastNewArray, CONTEXT, OBJECT,                        0, 0)
+JS_DEFINE_CALLINFO_3(extern, OBJECT, js_Array_1int, CONTEXT, OBJECT, INT32,                   0, 0)
+JS_DEFINE_CALLINFO_3(extern, OBJECT, js_Array_1str, CONTEXT, OBJECT, STRING,                  0, 0)
+JS_DEFINE_CALLINFO_4(extern, OBJECT, js_Array_2obj, CONTEXT, OBJECT, OBJECT, OBJECT,          0, 0)
+JS_DEFINE_CALLINFO_5(extern, OBJECT, js_Array_3num, CONTEXT, OBJECT, DOUBLE, DOUBLE, DOUBLE,  0, 0)
diff -r 17e9560465b0 js/src/jsbuiltins.cpp
--- a/js/src/jsbuiltins.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/jsbuiltins.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -210,7 +210,7 @@
 }
 
 jsval FASTCALL
-js_Any_getelem(JSContext* cx, JSObject* obj, uint32 index)
+js_Any_getelem(JSContext* cx, JSObject* obj, int32 index)
 {
     jsval v;
     jsid id;
@@ -224,7 +224,7 @@
 }
 
 JSBool FASTCALL
-js_Any_setelem(JSContext* cx, JSObject* obj, uint32 index, jsval v)
+js_Any_setelem(JSContext* cx, JSObject* obj, int32 index, jsval v)
 {
     jsid id;
     if (index < 0)
@@ -251,22 +251,23 @@
     return v;
 }
 
-GuardRecord* FASTCALL
+SideExit* FASTCALL
 js_CallTree(InterpState* state, Fragment* f)
 {
-    GuardRecord* lr;
     union { NIns *code; GuardRecord* (FASTCALL *func)(InterpState*, Fragment*); } u;
 
     u.code = f->code();
     JS_ASSERT(u.code);
 
+    GuardRecord* rec;
 #if defined(JS_NO_FASTCALL) && defined(NANOJIT_IA32)
-    SIMULATE_FASTCALL(lr, state, NULL, u.func);
+    SIMULATE_FASTCALL(rec, state, NULL, u.func);
 #else
-    lr = u.func(state, NULL);
+    rec = u.func(state, NULL);
 #endif
+    SideExit* lr = rec->exit;
 
-    if (lr->exit->exitType == NESTED_EXIT) {
+    if (lr->exitType == NESTED_EXIT) {
         /* This only occurs once a tree call guard mismatches and we unwind the tree call stack.
            We store the first (innermost) tree call guard in state and we will try to grow
            the outer tree the failing call was in starting at that guard. */
diff -r 17e9560465b0 js/src/jsbuiltins.h
--- a/js/src/jsbuiltins.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/jsbuiltins.h	Thu Oct 30 05:41:45 2008 -0400
@@ -42,7 +42,7 @@
 
 #ifdef JS_TRACER
 
-#include "nanojit.h"
+#include "nanojit/nanojit.h"
 
 enum JSTNErrType { INFALLIBLE, FAIL_NULL, FAIL_NEG, FAIL_VOID, FAIL_JSVAL };
 enum { JSTN_ERRTYPE_MASK = 7, JSTN_MORE = 8 };
@@ -91,13 +91,6 @@
  */
 #define JSVAL_ERROR_COOKIE OBJECT_TO_JSVAL((void*)0x10)
 
-/*
- * We also need a magic unboxed 32-bit integer that signals an error.  Again if
- * this number is hit we experience a performance regression, not a runtime
- * error.
- */
-#define INT32_ERROR_COOKIE 0xffffabcd
-
 /* Macros used by JS_DEFINE_CALLINFOn. */
 #ifdef DEBUG
 #define _JS_CI_NAME(op) ,#op
@@ -116,107 +109,246 @@
 # define _JS_PTR_RETSIZE    nanojit::ARGSIZE_LO
 #endif
 
-/* Supported types for builtin functions. */
-#define _JS_TYPEINFO(ctype, size)  (ctype, size)
-#define _JS_TYPEINFO_CONTEXT       _JS_TYPEINFO(JSContext *,             _JS_PTR)
-#define _JS_TYPEINFO_RUNTIME       _JS_TYPEINFO(JSRuntime *,             _JS_PTR)
-#define _JS_TYPEINFO_JSVAL         _JS_TYPEINFO(jsval,                   _JS_I32)
-#define _JS_TYPEINFO_BOOL          _JS_TYPEINFO(JSBool,                  _JS_I32)
-#define _JS_TYPEINFO_INT32         _JS_TYPEINFO(int32,                   _JS_I32)
-#define _JS_TYPEINFO_UINT32        _JS_TYPEINFO(uint32,                  _JS_I32)
-#define _JS_TYPEINFO_DOUBLE        _JS_TYPEINFO(jsdouble,                _JS_F64)
-#define _JS_TYPEINFO_STRING        _JS_TYPEINFO(JSString *,              _JS_PTR)
-#define _JS_TYPEINFO_OBJECT        _JS_TYPEINFO(JSObject *,              _JS_PTR)
-#define _JS_TYPEINFO_SCOPEPROP     _JS_TYPEINFO(JSScopeProperty *,       _JS_PTR)
-#define _JS_TYPEINFO_PC            _JS_TYPEINFO(jsbytecode *,            _JS_PTR)
-#define _JS_TYPEINFO_GUARDRECORD   _JS_TYPEINFO(nanojit::GuardRecord *,  _JS_PTR)
-#define _JS_TYPEINFO_INTERPSTATE   _JS_TYPEINFO(avmplus::InterpState *,  _JS_PTR)
-#define _JS_TYPEINFO_FRAGMENT      _JS_TYPEINFO(nanojit::Fragment *,     _JS_PTR)
+/*
+ * Supported types for builtin functions. 
+ *
+ * Types with -- for the two string fields are not permitted as argument types
+ * in JS_DEFINE_TRCINFO.
+ *
+ * If a traceable native can fail, the values that indicate failure are part of
+ * the return type:
+ *     JSVAL_FAIL: JSVAL_ERROR_COOKIE
+ *     BOOL_FAIL: JSVAL_TO_BOOLEAN(JSVAL_VOID)
+ *     INT32_FAIL: any negative value
+ *     STRING_FAIL: NULL
+ *     OBJECT_FAIL_NULL: NULL
+ *     OBJECT_FAIL_VOID: JSVAL_TO_OBJECT(JSVAL_VOID)
+ *         (NULL means the function successfully returned JS null.)
+ *
+ * Special builtins known to the tracer can have their own idiosyncratic
+ * error codes.
+ *
+ * When a traceable native returns a value indicating failure, we fall off
+ * trace.  If an exception is pending, it is thrown; otherwise, we assume the
+ * builtin had no side effects and retry the current bytecode in the
+ * interpreter.
+ * 
+ * So a builtin must not return a value indicating failure after causing side
+ * effects (such as reporting an error), without setting an exception pending.
+ * The operation would be retried, despite the first attempt's observable
+ * effects.
+ */
+#define _JS_CTYPE(ctype, size, pch, ach, flags)     (ctype, size, pch, ach, flags)
+#define _JS_CTYPE_CONTEXT          _JS_CTYPE(JSContext *,            _JS_PTR,"C", "", INFALLIBLE)
+#define _JS_CTYPE_RUNTIME          _JS_CTYPE(JSRuntime *,            _JS_PTR,"R", "", INFALLIBLE)
+#define _JS_CTYPE_THIS             _JS_CTYPE(JSObject *,             _JS_PTR,"T", "", INFALLIBLE)
+#define _JS_CTYPE_THIS_DOUBLE      _JS_CTYPE(jsdouble,               _JS_F64,"D", "", INFALLIBLE)
+#define _JS_CTYPE_THIS_STRING      _JS_CTYPE(JSString *,             _JS_PTR,"S", "", INFALLIBLE)
+#define _JS_CTYPE_PC               _JS_CTYPE(jsbytecode *,           _JS_PTR,"P", "", INFALLIBLE)
+#define _JS_CTYPE_JSVAL            _JS_CTYPE(jsval,                  _JS_PTR, "","v", INFALLIBLE)
+#define _JS_CTYPE_JSVAL_FAIL       _JS_CTYPE(jsval,                  _JS_PTR, --, --, FAIL_JSVAL)
+#define _JS_CTYPE_BOOL             _JS_CTYPE(JSBool,                 _JS_I32, "","i", INFALLIBLE)
+#define _JS_CTYPE_BOOL_FAIL        _JS_CTYPE(int32,                  _JS_I32, --, --, FAIL_VOID)
+#define _JS_CTYPE_INT32            _JS_CTYPE(int32,                  _JS_I32, "","i", INFALLIBLE)
+#define _JS_CTYPE_INT32_FAIL       _JS_CTYPE(int32,                  _JS_I32, --, --, FAIL_NEG)
+#define _JS_CTYPE_UINT32           _JS_CTYPE(uint32,                 _JS_I32, --, --, INFALLIBLE)
+#define _JS_CTYPE_DOUBLE           _JS_CTYPE(jsdouble,               _JS_F64, "","d", INFALLIBLE)
+#define _JS_CTYPE_STRING           _JS_CTYPE(JSString *,             _JS_PTR, "","s", INFALLIBLE)
+#define _JS_CTYPE_STRING_FAIL      _JS_CTYPE(JSString *,             _JS_PTR, --, --, FAIL_NULL)
+#define _JS_CTYPE_OBJECT           _JS_CTYPE(JSObject *,             _JS_PTR, "","o", INFALLIBLE)
+#define _JS_CTYPE_OBJECT_FAIL_NULL _JS_CTYPE(JSObject *,             _JS_PTR, --, --, FAIL_NULL)
+#define _JS_CTYPE_OBJECT_FAIL_VOID _JS_CTYPE(JSObject *,             _JS_PTR, --, --, FAIL_VOID)
+#define _JS_CTYPE_REGEXP           _JS_CTYPE(JSObject *,             _JS_PTR, "","r", INFALLIBLE)
+#define _JS_CTYPE_SCOPEPROP        _JS_CTYPE(JSScopeProperty *,      _JS_PTR, --, --, INFALLIBLE)
+#define _JS_CTYPE_SIDEEXIT         _JS_CTYPE(nanojit::SideExit *,    _JS_PTR, --, --, INFALLIBLE)
+#define _JS_CTYPE_INTERPSTATE      _JS_CTYPE(avmplus::InterpState *, _JS_PTR, --, --, INFALLIBLE)
+#define _JS_CTYPE_FRAGMENT         _JS_CTYPE(nanojit::Fragment *,    _JS_PTR, --, --, INFALLIBLE)
 
 #define _JS_EXPAND(tokens)  tokens
 
-#define _JS_CTYPE2(ctype, size)    ctype
-#define _JS_CTYPE(tyname)          _JS_EXPAND(_JS_CTYPE2 _JS_TYPEINFO_##tyname)
-#define _JS_RETSIZE2(ctype, size)  size##_ARGSIZE
-#define _JS_RETSIZE(tyname)        _JS_EXPAND(_JS_RETSIZE2 _JS_TYPEINFO_##tyname)
-#define _JS_ARGSIZE2(ctype, size)  size##_RETSIZE
-#define _JS_ARGSIZE(tyname)        _JS_EXPAND(_JS_ARGSIZE2 _JS_TYPEINFO_##tyname)
+#define _JS_CTYPE_TYPE2(t,s,p,a,f)      t
+#define _JS_CTYPE_TYPE(tyname)          _JS_EXPAND(_JS_CTYPE_TYPE2    _JS_CTYPE_##tyname)
+#define _JS_CTYPE_RETSIZE2(t,s,p,a,f)   s##_RETSIZE
+#define _JS_CTYPE_RETSIZE(tyname)       _JS_EXPAND(_JS_CTYPE_RETSIZE2 _JS_CTYPE_##tyname)
+#define _JS_CTYPE_ARGSIZE2(t,s,p,a,f)   s##_ARGSIZE
+#define _JS_CTYPE_ARGSIZE(tyname)       _JS_EXPAND(_JS_CTYPE_ARGSIZE2 _JS_CTYPE_##tyname)
+#define _JS_CTYPE_PCH2(t,s,p,a,f)       p
+#define _JS_CTYPE_PCH(tyname)           _JS_EXPAND(_JS_CTYPE_PCH2     _JS_CTYPE_##tyname)
+#define _JS_CTYPE_ACH2(t,s,p,a,f)       a
+#define _JS_CTYPE_ACH(tyname)           _JS_EXPAND(_JS_CTYPE_ACH2     _JS_CTYPE_##tyname)
+#define _JS_CTYPE_FLAGS2(t,s,p,a,f)     f
+#define _JS_CTYPE_FLAGS(tyname)         _JS_EXPAND(_JS_CTYPE_FLAGS2   _JS_CTYPE_##tyname)
 
-#define _JS_DEFINE_CALLINFO(name, crtype, cargtypes, argtypes, cse, fold)      \
-    crtype FASTCALL js_##name cargtypes;                                       \
-    const nanojit::CallInfo ci_##name =                                        \
-        { (intptr_t) &js_##name, argtypes, cse, fold _JS_CI_NAME(name) };
+#define _JS_static_TN(t)  static t
+#define _JS_static_CI     static
+#define _JS_extern_TN(t)  extern t
+#define _JS_extern_CI
+#define _JS_FRIEND_TN(t)  extern JS_FRIEND_API(t)
+#define _JS_FRIEND_CI
+#define _JS_TN_LINKAGE(linkage, t)  _JS_##linkage##_TN(t)
+#define _JS_CI_LINKAGE(linkage)     _JS_##linkage##_CI
+
+#define _JS_CALLINFO(name) name##_ci
+
+#define _JS_DEFINE_CALLINFO(linkage, name, crtype, cargtypes, argtypes, cse, fold)                \
+    _JS_TN_LINKAGE(linkage, crtype) FASTCALL name cargtypes;                                      \
+    _JS_CI_LINKAGE(linkage) const nanojit::CallInfo _JS_CALLINFO(name) =                          \
+        { (intptr_t) &name, argtypes, cse, fold, nanojit::ABI_FASTCALL _JS_CI_NAME(name) };
 
 /*
- * Declare a C function named js_<op> and a CallInfo struct named ci_<op> so
- * the tracer can call it.
+ * Declare a C function named <op> and a CallInfo struct named <op>_callinfo so the
+ * tracer can call it. |linkage| controls the visibility of both the function
+ * and the CallInfo global. It can be extern, static, or FRIEND, which
+ * specifies JS_FRIEND_API linkage for the function.
  */
-#define JS_DEFINE_CALLINFO_1(rt, op, at0, cse, fold)                                              \
-    _JS_DEFINE_CALLINFO(op, _JS_CTYPE(rt), (_JS_CTYPE(at0)),                                      \
-                        (_JS_ARGSIZE(at0) << 2) | _JS_RETSIZE(rt), cse, fold)
-#define JS_DEFINE_CALLINFO_2(rt, op, at0, at1, cse, fold)                                         \
-    _JS_DEFINE_CALLINFO(op, _JS_CTYPE(rt), (_JS_CTYPE(at0), _JS_CTYPE(at1)),                      \
-                        (_JS_ARGSIZE(at0) << 4) | (_JS_ARGSIZE(at1) << 2) | _JS_RETSIZE(rt),      \
+#define JS_DEFINE_CALLINFO_1(linkage, rt, op, at0, cse, fold)                                     \
+    _JS_DEFINE_CALLINFO(linkage, op, _JS_CTYPE_TYPE(rt), (_JS_CTYPE_TYPE(at0)),                   \
+                        (_JS_CTYPE_ARGSIZE(at0) << 2) | _JS_CTYPE_RETSIZE(rt), cse, fold)
+#define JS_DEFINE_CALLINFO_2(linkage, rt, op, at0, at1, cse, fold)                                \
+    _JS_DEFINE_CALLINFO(linkage, op, _JS_CTYPE_TYPE(rt),                                          \
+                        (_JS_CTYPE_TYPE(at0), _JS_CTYPE_TYPE(at1)),                               \
+                        (_JS_CTYPE_ARGSIZE(at0) << 4) | (_JS_CTYPE_ARGSIZE(at1) << 2) |           \
+                        _JS_CTYPE_RETSIZE(rt),                                                    \
                         cse, fold)
-#define JS_DEFINE_CALLINFO_3(rt, op, at0, at1, at2, cse, fold)                                    \
-    _JS_DEFINE_CALLINFO(op, _JS_CTYPE(rt), (_JS_CTYPE(at0), _JS_CTYPE(at1), _JS_CTYPE(at2)),      \
-                        (_JS_ARGSIZE(at0) << 6) | (_JS_ARGSIZE(at1) << 4) |                       \
-                        (_JS_ARGSIZE(at2) << 2) | _JS_RETSIZE(rt),                                \
+#define JS_DEFINE_CALLINFO_3(linkage, rt, op, at0, at1, at2, cse, fold)                           \
+    _JS_DEFINE_CALLINFO(linkage, op, _JS_CTYPE_TYPE(rt),                                          \
+                        (_JS_CTYPE_TYPE(at0), _JS_CTYPE_TYPE(at1), _JS_CTYPE_TYPE(at2)),          \
+                        (_JS_CTYPE_ARGSIZE(at0) << 6) | (_JS_CTYPE_ARGSIZE(at1) << 4) |           \
+                        (_JS_CTYPE_ARGSIZE(at2) << 2) | _JS_CTYPE_RETSIZE(rt),                    \
                         cse, fold)
-#define JS_DEFINE_CALLINFO_4(rt, op, at0, at1, at2, at3, cse, fold)                               \
-    _JS_DEFINE_CALLINFO(op, _JS_CTYPE(rt), (_JS_CTYPE(at0), _JS_CTYPE(at1), _JS_CTYPE(at2),       \
-                                            _JS_CTYPE(at3)),                                      \
-                        (_JS_ARGSIZE(at0) << 8) | (_JS_ARGSIZE(at1) << 6) |                       \
-                        (_JS_ARGSIZE(at2) << 4) | (_JS_ARGSIZE(at3) << 2) | _JS_RETSIZE(rt),      \
+#define JS_DEFINE_CALLINFO_4(linkage, rt, op, at0, at1, at2, at3, cse, fold)                      \
+    _JS_DEFINE_CALLINFO(linkage, op, _JS_CTYPE_TYPE(rt),                                          \
+                        (_JS_CTYPE_TYPE(at0), _JS_CTYPE_TYPE(at1), _JS_CTYPE_TYPE(at2),           \
+                         _JS_CTYPE_TYPE(at3)),                                                    \
+                        (_JS_CTYPE_ARGSIZE(at0) << 8) | (_JS_CTYPE_ARGSIZE(at1) << 6) |           \
+                        (_JS_CTYPE_ARGSIZE(at2) << 4) | (_JS_CTYPE_ARGSIZE(at3) << 2) |           \
+                        _JS_CTYPE_RETSIZE(rt),                                                    \
                         cse, fold)
-#define JS_DEFINE_CALLINFO_5(rt, op, at0, at1, at2, at3, at4, cse, fold)                          \
-    _JS_DEFINE_CALLINFO(op, _JS_CTYPE(rt), (_JS_CTYPE(at0), _JS_CTYPE(at1), _JS_CTYPE(at2),       \
-                                            _JS_CTYPE(at3), _JS_CTYPE(at4)),                      \
-                        (_JS_ARGSIZE(at0) << 10) | (_JS_ARGSIZE(at1) << 8) |                      \
-                        (_JS_ARGSIZE(at2) << 6) | (_JS_ARGSIZE(at3) << 4) |                       \
-                        (_JS_ARGSIZE(at4) << 2) | _JS_RETSIZE(rt),                                \
+#define JS_DEFINE_CALLINFO_5(linkage, rt, op, at0, at1, at2, at3, at4, cse, fold)                 \
+    _JS_DEFINE_CALLINFO(linkage, op, _JS_CTYPE_TYPE(rt),                                          \
+                        (_JS_CTYPE_TYPE(at0), _JS_CTYPE_TYPE(at1), _JS_CTYPE_TYPE(at2),           \
+                         _JS_CTYPE_TYPE(at3), _JS_CTYPE_TYPE(at4)),                               \
+                        (_JS_CTYPE_ARGSIZE(at0) << 10) | (_JS_CTYPE_ARGSIZE(at1) << 8) |          \
+                        (_JS_CTYPE_ARGSIZE(at2) << 6) | (_JS_CTYPE_ARGSIZE(at3) << 4) |           \
+                        (_JS_CTYPE_ARGSIZE(at4) << 2) | _JS_CTYPE_RETSIZE(rt),                    \
                         cse, fold)
 
-#define JS_DECLARE_CALLINFO(name)  extern const nanojit::CallInfo ci_##name;
+#define JS_DECLARE_CALLINFO(name)  extern const nanojit::CallInfo _JS_CALLINFO(name);
+
+#define _JS_TN_INIT_HELPER_n(n, args)  _JS_TN_INIT_HELPER_##n args
+
+#define _JS_TN_INIT_HELPER_1(linkage, rt, op, at0, cse, fold)                                     \
+    &_JS_CALLINFO(op),                                                                            \
+    _JS_CTYPE_PCH(at0),                                                                           \
+    _JS_CTYPE_ACH(at0),                                                                           \
+    _JS_CTYPE_FLAGS(rt)
+
+#define _JS_TN_INIT_HELPER_2(linkage, rt, op, at0, at1, cse, fold)                                \
+    &_JS_CALLINFO(op),                                                                            \
+    _JS_CTYPE_PCH(at1) _JS_CTYPE_PCH(at0),                                                        \
+    _JS_CTYPE_ACH(at0) _JS_CTYPE_ACH(at1),                                                        \
+    _JS_CTYPE_FLAGS(rt)
+
+#define _JS_TN_INIT_HELPER_3(linkage, rt, op, at0, at1, at2, cse, fold)                           \
+    &_JS_CALLINFO(op),                                                                            \
+    _JS_CTYPE_PCH(at2) _JS_CTYPE_PCH(at1) _JS_CTYPE_PCH(at0),                                     \
+    _JS_CTYPE_ACH(at0) _JS_CTYPE_ACH(at1) _JS_CTYPE_ACH(at2),                                     \
+    _JS_CTYPE_FLAGS(rt)
+
+#define _JS_TN_INIT_HELPER_4(linkage, rt, op, at0, at1, at2, at3, cse, fold)                      \
+    &_JS_CALLINFO(op),                                                                            \
+    _JS_CTYPE_PCH(at3) _JS_CTYPE_PCH(at2) _JS_CTYPE_PCH(at1) _JS_CTYPE_PCH(at0),                  \
+    _JS_CTYPE_ACH(at0) _JS_CTYPE_ACH(at1) _JS_CTYPE_ACH(at2) _JS_CTYPE_ACH(at3),                  \
+    _JS_CTYPE_FLAGS(rt)
+
+#define _JS_TN_INIT_HELPER_5(linkage, rt, op, at0, at1, at2, at3, at4, cse, fold)                 \
+    &_JS_CALLINFO(op),                                                                            \
+    _JS_CTYPE_PCH(at4) _JS_CTYPE_PCH(at3) _JS_CTYPE_PCH(at2) _JS_CTYPE_PCH(at1)                   \
+        _JS_CTYPE_PCH(at0),                                                                       \
+    _JS_CTYPE_ACH(at0) _JS_CTYPE_ACH(at1) _JS_CTYPE_ACH(at2) _JS_CTYPE_ACH(at3)                   \
+        _JS_CTYPE_ACH(at4),                                                                       \
+    _JS_CTYPE_FLAGS(rt)
+
+#define JS_DEFINE_TRCINFO_1(name, tn0)                                                            \
+    _JS_DEFINE_CALLINFO_n tn0                                                                     \
+    JSTraceableNative name##_trcinfo[] = {                                                        \
+        { name, _JS_TN_INIT_HELPER_n tn0 }                                                        \
+    };
+
+#define JS_DEFINE_TRCINFO_2(name, tn0, tn1)                                                       \
+    _JS_DEFINE_CALLINFO_n tn0                                                                     \
+    _JS_DEFINE_CALLINFO_n tn1                                                                     \
+    JSTraceableNative name##_trcinfo[] = {                                                        \
+        { name, _JS_TN_INIT_HELPER_n tn0 | JSTN_MORE },                                           \
+        { name, _JS_TN_INIT_HELPER_n tn1 }                                                        \
+    };
+
+#define JS_DEFINE_TRCINFO_3(name, tn0, tn1, tn2)                                                  \
+    _JS_DEFINE_CALLINFO_n tn0                                                                     \
+    _JS_DEFINE_CALLINFO_n tn1                                                                     \
+    _JS_DEFINE_CALLINFO_n tn2                                                                     \
+    JSTraceableNative name##_trcinfo[] = {                                                        \
+        { name, _JS_TN_INIT_HELPER_n tn0 | JSTN_MORE },                                           \
+        { name, _JS_TN_INIT_HELPER_n tn1 | JSTN_MORE },                                           \
+        { name, _JS_TN_INIT_HELPER_n tn2 }                                                        \
+    };
+
+#define JS_DEFINE_TRCINFO_4(name, tn0, tn1, tn2, tn3)                                             \
+    _JS_DEFINE_CALLINFO_n tn0                                                                     \
+    _JS_DEFINE_CALLINFO_n tn1                                                                     \
+    _JS_DEFINE_CALLINFO_n tn2                                                                     \
+    _JS_DEFINE_CALLINFO_n tn3                                                                     \
+    JSTraceableNative name##_trcinfo[] = {                                                        \
+        { name, _JS_TN_INIT_HELPER_n tn0 | JSTN_MORE },                                           \
+        { name, _JS_TN_INIT_HELPER_n tn1 | JSTN_MORE },                                           \
+        { name, _JS_TN_INIT_HELPER_n tn2 | JSTN_MORE },                                           \
+        { name, _JS_TN_INIT_HELPER_n tn3 }                                                        \
+    };
+
+#define _JS_DEFINE_CALLINFO_n(n, args)  JS_DEFINE_CALLINFO_##n args
 
 #else
 
-#define JS_DEFINE_CALLINFO_1(rt, op, at0, cse, fold)
-#define JS_DEFINE_CALLINFO_2(rt, op, at0, at1, cse, fold)
-#define JS_DEFINE_CALLINFO_3(rt, op, at0, at1, at2, cse, fold)
-#define JS_DEFINE_CALLINFO_4(rt, op, at0, at1, at2, at3, cse, fold)
-#define JS_DEFINE_CALLINFO_5(rt, op, at0, at1, at2, at3, at4, cse, fold)
+#define JS_DEFINE_CALLINFO_1(linkage, rt, op, at0, cse, fold)
+#define JS_DEFINE_CALLINFO_2(linkage, rt, op, at0, at1, cse, fold)
+#define JS_DEFINE_CALLINFO_3(linkage, rt, op, at0, at1, at2, cse, fold)
+#define JS_DEFINE_CALLINFO_4(linkage, rt, op, at0, at1, at2, at3, cse, fold)
+#define JS_DEFINE_CALLINFO_5(linkage, rt, op, at0, at1, at2, at3, at4, cse, fold)
 #define JS_DECLARE_CALLINFO(name)
+#define JS_DEFINE_TRCINFO_1(name, tn0)
+#define JS_DEFINE_TRCINFO_2(name, tn0, tn1)
+#define JS_DEFINE_TRCINFO_3(name, tn0, tn1, tn2)
+#define JS_DEFINE_TRCINFO_4(name, tn0, tn1, tn2, tn3)
 
 #endif /* !JS_TRACER */
 
 /* Defined in jsarray.cpp */
-JS_DECLARE_CALLINFO(Array_dense_setelem)
-JS_DECLARE_CALLINFO(FastNewArray)
-JS_DECLARE_CALLINFO(Array_1int)
-JS_DECLARE_CALLINFO(Array_1str)
-JS_DECLARE_CALLINFO(Array_2obj)
-JS_DECLARE_CALLINFO(Array_3num)
+JS_DECLARE_CALLINFO(js_Array_dense_setelem)
+JS_DECLARE_CALLINFO(js_FastNewArray)
+JS_DECLARE_CALLINFO(js_Array_1int)
+JS_DECLARE_CALLINFO(js_Array_1str)
+JS_DECLARE_CALLINFO(js_Array_2obj)
+JS_DECLARE_CALLINFO(js_Array_3num)
 
 /* Defined in jsdate.cpp */
-JS_DECLARE_CALLINFO(FastNewDate)
+JS_DECLARE_CALLINFO(js_FastNewDate)
 
 /* Defined in jsnum.cpp */
-JS_DECLARE_CALLINFO(NumberToString)
+JS_DECLARE_CALLINFO(js_NumberToString)
 
 /* Defined in jsstr.cpp */
-JS_DECLARE_CALLINFO(ConcatStrings)
-JS_DECLARE_CALLINFO(String_getelem)
-JS_DECLARE_CALLINFO(String_p_charCodeAt)
-JS_DECLARE_CALLINFO(EqualStrings)
-JS_DECLARE_CALLINFO(CompareStrings)
+JS_DECLARE_CALLINFO(js_ConcatStrings)
+JS_DECLARE_CALLINFO(js_String_getelem)
+JS_DECLARE_CALLINFO(js_String_p_charCodeAt)
+JS_DECLARE_CALLINFO(js_EqualStrings)
+JS_DECLARE_CALLINFO(js_CompareStrings)
 
 /* Defined in jsbuiltins.cpp */
-#define BUILTIN1(rt, op, at0,                     cse, fold)  JS_DECLARE_CALLINFO(op)
-#define BUILTIN2(rt, op, at0, at1,                cse, fold)  JS_DECLARE_CALLINFO(op)
-#define BUILTIN3(rt, op, at0, at1, at2,           cse, fold)  JS_DECLARE_CALLINFO(op)
-#define BUILTIN4(rt, op, at0, at1, at2, at3,      cse, fold)  JS_DECLARE_CALLINFO(op)
-#define BUILTIN5(rt, op, at0, at1, at2, at3, at4, cse, fold)  JS_DECLARE_CALLINFO(op)
+#define BUILTIN1(linkage, rt, op, at0,                     cse, fold)  JS_DECLARE_CALLINFO(op)
+#define BUILTIN2(linkage, rt, op, at0, at1,                cse, fold)  JS_DECLARE_CALLINFO(op)
+#define BUILTIN3(linkage, rt, op, at0, at1, at2,           cse, fold)  JS_DECLARE_CALLINFO(op)
+#define BUILTIN4(linkage, rt, op, at0, at1, at2, at3,      cse, fold)  JS_DECLARE_CALLINFO(op)
+#define BUILTIN5(linkage, rt, op, at0, at1, at2, at3, at4, cse, fold)  JS_DECLARE_CALLINFO(op)
 #include "builtins.tbl"
 #undef BUILTIN
 #undef BUILTIN1
diff -r 17e9560465b0 js/src/jscntxt.h
--- a/js/src/jscntxt.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/jscntxt.h	Thu Oct 30 05:41:45 2008 -0400
@@ -141,6 +141,7 @@
     JSFragmentCacheEntry    fcache[JS_FRAGMENT_CACHE_SIZE];
     jsval                   *recoveryDoublePool;
     jsval                   *recoveryDoublePoolPtr;
+    uint32                  jitCacheGen;
 } JSTraceMonitor;
 
 #ifdef JS_TRACER
diff -r 17e9560465b0 js/src/jsconfig.mk
--- a/js/src/jsconfig.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,181 +0,0 @@
-# -*- Mode: makefile -*-
-# 
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-# 
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-# 
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998-1999
-# the Initial Developer. All Rights Reserved.
-# 
-# Contributor(s):
-# 
-# Alternatively, the contents of this file may be used under the terms of
-# either of the GNU General Public License Version 2 or later (the "GPL"),
-# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-# 
-# ***** END LICENSE BLOCK *****
-
-ifndef OBJDIR
-  ifdef OBJDIR_NAME
-    OBJDIR = $(OBJDIR_NAME)
-  endif
-endif
-
-NSPR_VERSION = v4.0
-NSPR_LIBSUFFIX = 4
-
-NSPR_LOCAL       = $(MOZ_DEPTH)/dist/$(OBJDIR)/nspr
-NSPR_DIST        = $(MOZ_DEPTH)/dist/$(OBJDIR)
-NSPR_OBJDIR      = $(OBJDIR)
-ifeq ($(OS_ARCH), SunOS)
-  NSPR_OBJDIR   := $(subst _sparc,,$(NSPR_OBJDIR))
-endif
-ifeq ($(OS_ARCH), Linux)
-  LINUX_REL     := $(shell uname -r)
-  ifneq (,$(findstring 2.0,$(LINUX_REL)))
-    NSPR_OBJDIR := $(subst _All,2.0_x86_glibc_PTH,$(NSPR_OBJDIR))
-  else
-    NSPR_OBJDIR := $(subst _All,2.2_x86_glibc_PTH,$(NSPR_OBJDIR))
-  endif
-endif
-ifeq ($(OS_ARCH), AIX)
-  NSPR_OBJDIR   := $(subst 4.1,4.2,$(NSPR_OBJDIR))
-endif
-ifeq ($(OS_CONFIG), IRIX6.2)
-  NSPR_OBJDIR   := $(subst 6.2,6.2_n32_PTH,$(NSPR_OBJDIR))
-endif
-ifeq ($(OS_CONFIG), IRIX6.5)
-  NSPR_OBJDIR   := $(subst 6.5,6.5_n32_PTH,$(NSPR_OBJDIR))
-endif
-ifeq ($(OS_ARCH), WINNT)
-  ifeq ($(OBJDIR), WIN32_D.OBJ)
-    NSPR_OBJDIR  = WINNT4.0_DBG.OBJ
-  endif
-  ifeq ($(OBJDIR), WIN32_O.OBJ)
-    NSPR_OBJDIR  = WINNT4.0_OPT.OBJ
-  endif
-endif
-NSPR_SHARED      = /share/builds/components/nspr20/$(NSPR_VERSION)/$(NSPR_OBJDIR)
-ifeq ($(OS_ARCH), WINNT)
-  NSPR_SHARED    = nspr20/$(NSPR_VERSION)/$(NSPR_OBJDIR)
-endif
-NSPR_VERSIONFILE = $(NSPR_LOCAL)/Version
-NSPR_CURVERSION := $(shell cat $(NSPR_VERSIONFILE) 2>/dev/null)
-
-get_nspr:
-	@echo "Grabbing NSPR component..."
-ifeq ($(NSPR_VERSION), $(NSPR_CURVERSION))
-	@echo "No need, NSPR is up to date in this tree (ver=$(NSPR_VERSION))."
-else
-	mkdir -p $(NSPR_LOCAL)
-	mkdir -p $(NSPR_DIST)
-  ifneq ($(OS_ARCH), WINNT)
-	cp       $(NSPR_SHARED)/*.jar $(NSPR_LOCAL)
-  else
-	sh       $(MOZ_DEPTH)/../reltools/compftp.sh $(NSPR_SHARED) $(NSPR_LOCAL) *.jar
-  endif
-	unzip -o $(NSPR_LOCAL)/mdbinary.jar -d $(NSPR_DIST)
-	mkdir -p $(NSPR_DIST)/include
-	unzip -o $(NSPR_LOCAL)/mdheader.jar -d $(NSPR_DIST)/include
-	rm -rf   $(NSPR_DIST)/META-INF
-	rm -rf   $(NSPR_DIST)/include/META-INF
-	echo $(NSPR_VERSION) > $(NSPR_VERSIONFILE)
-endif
-
-SHIP_DIST  = $(MOZ_DEPTH)/dist/$(OBJDIR)
-SHIP_DIR   = $(SHIP_DIST)/SHIP
-
-SHIP_LIBS      = libjs.$(SO_SUFFIX) libjs.a
-ifdef JS_LIVECONNECT
-  SHIP_LIBS   += libjsj.$(SO_SUFFIX) libjsj.a
-endif
-ifeq ($(OS_ARCH), WINNT)
-  SHIP_LIBS    = js32.dll js32.lib
-  ifdef JS_LIVECONNECT
-    SHIP_LIBS += jsj.dll jsj.lib
-  endif
-endif
-SHIP_LIBS     += $(LCJAR)
-SHIP_LIBS     := $(addprefix $(SHIP_DIST)/lib/, $(SHIP_LIBS))
-
-SHIP_INCS      = js*.h prmjtime.h resource.h *.msg *.tbl
-ifdef JS_LIVECONNECT
-  SHIP_INCS   += netscape*.h nsC*.h nsI*.h
-endif
-SHIP_INCS     := $(addprefix $(SHIP_DIST)/include/, $(SHIP_INCS))
-
-SHIP_BINS      = js
-ifdef JS_LIVECONNECT
-  SHIP_BINS   += lcshell
-endif
-ifeq ($(OS_ARCH), WINNT)
-  SHIP_BINS   := $(addsuffix .exe, $(SHIP_BINS))
-endif
-SHIP_BINS     := $(addprefix $(SHIP_DIST)/bin/, $(SHIP_BINS))
-
-ifdef BUILD_OPT
-  JSREFJAR = jsref_opt.jar
-else
-ifdef BUILD_IDG
-  JSREFJAR = jsref_idg.jar
-else
-  JSREFJAR = jsref_dbg.jar
-endif
-endif
-
-ship:
-	mkdir -p $(SHIP_DIR)/$(LIBDIR)
-	mkdir -p $(SHIP_DIR)/include
-	mkdir -p $(SHIP_DIR)/bin
-	cp $(SHIP_LIBS) $(SHIP_DIR)/$(LIBDIR)
-	cp $(SHIP_INCS) $(SHIP_DIR)/include
-	cp $(SHIP_BINS) $(SHIP_DIR)/bin
-	cd $(SHIP_DIR); \
-	  zip -r $(JSREFJAR) bin lib include
-ifdef BUILD_SHIP
-	cp $(SHIP_DIR)/$(JSREFJAR) $(BUILD_SHIP)
-endif
-
-CWD = $(shell pwd)
-shipSource: $(SHIP_DIR)/jsref_src.lst .FORCE
-	mkdir -p $(SHIP_DIR)
-	cd $(MOZ_DEPTH)/.. ; \
-	  zip $(CWD)/$(SHIP_DIR)/jsref_src.jar -@ < $(CWD)/$(SHIP_DIR)/jsref_src.lst
-ifdef BUILD_SHIP
-	cp $(SHIP_DIR)/jsref_src.jar $(BUILD_SHIP)
-endif
-
-JSREFSRCDIRS := $(shell cat $(DEPTH)/SpiderMonkey.rsp)
-$(SHIP_DIR)/jsref_src.lst: .FORCE
-	mkdir -p $(SHIP_DIR)
-	rm -f $@
-	touch $@
-	for d in $(JSREFSRCDIRS); do                                \
-	  cd $(MOZ_DEPTH)/..;                                       \
-	  ls -1 -d $$d | grep -v CVS | grep -v \.OBJ >> $(CWD)/$@;  \
-	  cd $(CWD);                                                \
-	done
-
-.FORCE:
diff -r 17e9560465b0 js/src/jsdate.cpp
--- a/js/src/jsdate.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/jsdate.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -920,8 +920,8 @@
 }
 
 #ifdef JS_TRACER
-jsdouble FASTCALL
-js_Date_now(JSContext*)
+static jsdouble FASTCALL
+date_now_tn(JSContext*)
 {
     return PRMJ_Now() / PRMJ_USEC_PER_MSEC;
 }
@@ -1992,22 +1992,11 @@
     return date_toString(cx, argc, vp);
 }
 
-/*
- * creation and destruction
- */
-
-#ifdef JS_TRACER
+JS_DEFINE_CALLINFO_2(extern, OBJECT, js_FastNewDate, CONTEXT, OBJECT, 0, 0)
 
 // Don't really need an argument here, but we don't support arg-less builtins
-JS_DEFINE_CALLINFO_1(DOUBLE, Date_now, CONTEXT, 0, 0)
-
-JS_DEFINE_CALLINFO_2(OBJECT, FastNewDate, CONTEXT, OBJECT, 0, 0)
-
-static JSTraceableNative date_now_trcinfo[] = {
-    { date_now, &ci_Date_now, "C", "", INFALLIBLE }
-};
-
-#endif /* JS_TRACER */
+JS_DEFINE_TRCINFO_1(date_now,
+    (1, (static, DOUBLE, date_now_tn, CONTEXT, 0, 0)))
 
 static JSFunctionSpec date_static_methods[] = {
     JS_FN("UTC",                 date_UTC,                MAXARGS,0),
@@ -2169,10 +2158,12 @@
     jsdouble* date = js_NewWeaklyRootedDouble(cx, 0.0);
     if (!date)
         return NULL;
-    *date = js_Date_now(cx);
+    *date = date_now_tn(cx);
     obj->fslots[JSSLOT_UTC_TIME] = DOUBLE_TO_JSVAL(date);
-    obj->fslots[JSSLOT_LOCAL_TIME] = DOUBLE_TO_JSVAL(cx->runtime->jsNaN);;
-
+    obj->fslots[JSSLOT_LOCAL_TIME] = DOUBLE_TO_JSVAL(cx->runtime->jsNaN);
+    for (unsigned i = JSSLOT_LOCAL_TIME + 1; i != JS_INITIAL_NSLOTS; ++i)
+        obj->fslots[i] = JSVAL_VOID;
+    
     JS_ASSERT(!clasp->getObjectOps);
     JS_ASSERT(proto->map->ops == &js_ObjectOps);
     obj->map = js_HoldObjectMap(cx, proto->map);
diff -r 17e9560465b0 js/src/jsemit.cpp
--- a/js/src/jsemit.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/jsemit.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -2078,11 +2078,16 @@
         break;
 
       case PN_LIST:
-        if (pn->pn_type == TOK_NEW ||
-            pn->pn_type == TOK_LP ||
-            pn->pn_type == TOK_LB ||
-            pn->pn_type == TOK_RB ||
-            pn->pn_type == TOK_RC) {
+        if (pn->pn_op == JSOP_NOP ||
+            pn->pn_op == JSOP_OR || pn->pn_op == JSOP_AND ||
+            pn->pn_op == JSOP_STRICTEQ || pn->pn_op == JSOP_STRICTNE) {
+            /*
+             * Non-operators along with ||, &&, ===, and !== never invoke
+             * toString or valueOf.
+             */
+            for (pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next)
+                ok &= CheckSideEffects(cx, cg, pn2, answer);
+        } else {
             /*
              * All invocation operations (construct: TOK_NEW, call: TOK_LP)
              * are presumed to be useful, because they may have side effects
@@ -2094,14 +2099,12 @@
              * (the JSOP_ARGUMENTS special case below, in the PN_BINARY case,
              * does not apply here: arguments[i][j] might invoke a getter).
              *
-             * Array and object initializers (TOK_RB and TOK_RC lists) must be
-             * considered useful, because they are sugar for constructor calls
-             * (to Array and Object, respectively).
+             * Likewise, array and object initialisers may call prototype
+             * setters (the __defineSetter__ built-in, and writable __proto__
+             * on Array.prototype create this hazard). Initialiser list nodes
+             * have JSOP_NEWINIT in their pn_op.
              */
             *answer = JS_TRUE;
-        } else {
-            for (pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next)
-                ok &= CheckSideEffects(cx, cg, pn2, answer);
         }
         break;
 
@@ -2138,11 +2141,21 @@
                 }
             }
         } else {
-            /*
-             * We can't easily prove that neither operand ever denotes an
-             * object with a toString or valueOf method.
-             */
-            *answer = JS_TRUE;
+            if (pn->pn_op == JSOP_OR || pn->pn_op == JSOP_AND ||
+                pn->pn_op == JSOP_STRICTEQ || pn->pn_op == JSOP_STRICTNE) {
+                /*
+                 * ||, &&, ===, and !== do not convert their operands via
+                 * toString or valueOf method calls.
+                 */
+                ok = CheckSideEffects(cx, cg, pn->pn_left, answer) &&
+                     CheckSideEffects(cx, cg, pn->pn_right, answer);
+            } else {
+                /*
+                 * We can't easily prove that neither operand ever denotes an
+                 * object with a toString or valueOf method.
+                 */
+                *answer = JS_TRUE;
+            }
         }
         break;
 
@@ -2172,6 +2185,14 @@
                 break;
             }
             break;
+
+          case TOK_UNARYOP:
+            if (pn->pn_op == JSOP_NOT) {
+                /* ! does not convert its operand via toString or valueOf. */
+                ok = CheckSideEffects(cx, cg, pn->pn_kid, answer);
+                break;
+            }
+            /* FALL THROUGH */
 
           default:
             /*
@@ -3648,8 +3669,7 @@
                 JS_ASSERT(noteIndex < 0 && !pn2->pn_next);
                 op = JSOP_POP;
                 if (!MaybeEmitGroupAssignment(cx, cg,
-                                              inLetHead ? JSOP_POP :
-                                              PN_OP(pn),
+                                              inLetHead ? JSOP_POP : PN_OP(pn),
                                               pn2, &op)) {
                     return JS_FALSE;
                 }
@@ -3829,6 +3849,28 @@
            js_Emit1(cx, cg, JSOP_NOP) >= 0;
 }
 
+/* FIXME: 458851 -- that bug's patch should re-inline this into one place. */
+static JSBool
+EmitForInLoopBody(JSContext *cx, JSCodeGenerator *cg, JSStmtInfo *stmt,
+                  JSParseNode *body, intN noteIndex, ptrdiff_t jmp)
+{
+    /* Set the first srcnote offset so we can find the start of the loop body. */
+    if (!js_SetSrcNoteOffset(cx, cg, (uintN)noteIndex, 0, CG_OFFSET(cg) - jmp))
+        return JS_FALSE;
+
+    /* Emit code for the loop body. */
+    if (!js_EmitTree(cx, cg, body))
+        return JS_FALSE;
+
+    /* Set loop and enclosing "update" offsets, for continue. */
+    do {
+        stmt->update = CG_OFFSET(cg);
+    } while ((stmt = stmt->down) != NULL && stmt->type == STMT_LABEL);
+
+    CHECK_AND_SET_JUMP_OFFSET_AT(cx, cg, jmp);
+    return JS_TRUE;
+}
+
 JSBool
 js_EmitTree(JSContext *cx, JSCodeGenerator *cg, JSParseNode *pn)
 {
@@ -4152,11 +4194,8 @@
         js_PushStatement(&cg->treeContext, &stmtInfo, STMT_FOR_LOOP, top);
 
         if (pn2->pn_type == TOK_IN) {
-            JSBool emitIFEQ;
-
             /* Set stmtInfo type for later testing. */
             stmtInfo.type = STMT_FOR_IN_LOOP;
-            noteIndex = -1;
 
             /*
              * If the left part is 'var x', emit code to define x if necessary
@@ -4201,6 +4240,19 @@
              */
             JS_ASSERT(pn->pn_op == JSOP_ITER);
             if (js_Emit2(cx, cg, PN_OP(pn), (uint8) pn->pn_iflags) < 0)
+                return JS_FALSE;
+
+            /* Annotate so the decompiler can find the loop-closing jump. */
+            noteIndex = js_NewSrcNote(cx, cg, SRC_FOR_IN);
+            if (noteIndex < 0)
+                return JS_FALSE;
+
+            /*
+             * Jump down to the loop condition to minimize overhead assuming at
+             * least one iteration, as the other loop forms do.
+             */
+            jmp = EmitJump(cx, cg, JSOP_GOTO, 0);
+            if (jmp < 0)
                 return JS_FALSE;
 
             top = CG_OFFSET(cg);
@@ -4216,7 +4268,6 @@
              * assignment, so JSOP_SETNAME is not critical here; many similar
              * ops could be used -- just not JSOP_NOP (which means 'let').
              */
-            emitIFEQ = JS_TRUE;
             op = JSOP_SETNAME;
             switch (type) {
 #if JS_HAS_BLOCK_SCOPE
@@ -4237,29 +4288,31 @@
 #else
                 JS_ASSERT(pn3->pn_type == TOK_NAME);
 #endif
+                /* FALL THROUGH */
+
+              case TOK_NAME:
+                if (!EmitForInLoopBody(cx, cg, &stmtInfo, pn->pn_right, noteIndex, jmp))
+                    return JS_FALSE;
+
                 /*
                  * Always annotate JSOP_FORLOCAL if given input of the form
                  * 'for (let x in * o)' -- the decompiler must not hoist the
                  * 'let x' out of the loop head, or x will be bound in the
                  * wrong scope.  Likewise, but in this case only for the sake
                  * of higher decompilation fidelity only, do not hoist 'var x'
-                 * when given 'for (var x in o)'.  But 'for (var x = i in o)'
-                 * requires hoisting in order to preserve the initializer i.
-                 * The decompiler can only handle so much!
+                 * when given 'for (var x in o)'.
                  */
                 if ((
 #if JS_HAS_BLOCK_SCOPE
                      type == TOK_LET ||
 #endif
-                     !pn3->pn_expr) &&
+                     (type == TOK_VAR && !pn3->pn_expr)) &&
                     js_NewSrcNote2(cx, cg, SRC_DECL,
                                    type == TOK_VAR
                                    ? SRC_DECL_VAR
                                    : SRC_DECL_LET) < 0) {
                     return JS_FALSE;
                 }
-                /* FALL THROUGH */
-              case TOK_NAME:
                 if (pn3->pn_slot >= 0) {
                     op = PN_OP(pn3);
                     switch (op) {
@@ -4291,10 +4344,16 @@
                 break;
 
               case TOK_DOT:
+                /*
+                 * 'for (o.p in q)' can use JSOP_FORPROP only if evaluating 'o'
+                 * has no side effects.
+                 */
                 useful = JS_FALSE;
                 if (!CheckSideEffects(cx, cg, pn3->pn_expr, &useful))
                     return JS_FALSE;
                 if (!useful) {
+                    if (!EmitForInLoopBody(cx, cg, &stmtInfo, pn->pn_right, noteIndex, jmp))
+                        return JS_FALSE;
                     if (!EmitPropOp(cx, pn3, JSOP_FORPROP, cg, JS_FALSE))
                         return JS_FALSE;
                     break;
@@ -4302,49 +4361,29 @@
                 /* FALL THROUGH */
 
 #if JS_HAS_DESTRUCTURING
-              case TOK_RB:
-              case TOK_RC:
               destructuring_for:
 #endif
-#if JS_HAS_XML_SUPPORT
-              case TOK_UNARYOP:
-#endif
-#if JS_HAS_LVALUE_RETURN
-              case TOK_LP:
-#endif
-              case TOK_LB:
+              default:
                 /*
                  * We separate the first/next bytecode from the enumerator
                  * variable binding to avoid any side-effects in the index
                  * expression (e.g., for (x[i++] in {}) should not bind x[i]
                  * or increment i at all).
-                 */
-                emitIFEQ = JS_FALSE;
-                if (js_Emit1(cx, cg, JSOP_FORELEM) < 0)
-                    return JS_FALSE;
-
-                /*
-                 * Emit a SRC_WHILE note with offset telling the distance to
-                 * the loop-closing jump (we can't reckon from the branch at
-                 * the top of the loop, because the loop-closing jump might
-                 * need to be an extended jump, independent of whether the
-                 * branch is short or long).
-                 */
-                noteIndex = js_NewSrcNote(cx, cg, SRC_WHILE);
-                if (noteIndex < 0)
-                    return JS_FALSE;
-                beq = EmitJump(cx, cg, JSOP_IFEQ, 0);
-                if (beq < 0)
-                    return JS_FALSE;
-
+                 *
+                 * At this point, JSOP_FORELEM (emitted after the loop body)
+                 * has pushed the next value to iterate, but it is downstream
+                 * of us in js_Emit* order, so we must adjust the stack depth
+                 * manually.
+                 */
+                if ((uintN) ++cg->stackDepth > cg->maxStackDepth)
+                    cg->maxStackDepth = cg->stackDepth;
 #if JS_HAS_DESTRUCTURING
                 if (pn3->pn_type == TOK_RB || pn3->pn_type == TOK_RC) {
                     if (!EmitDestructuringOps(cx, cg, op, pn3))
                         return JS_FALSE;
                     if (js_Emit1(cx, cg, JSOP_POP) < 0)
                         return JS_FALSE;
-                    break;
-                }
+                } else
 #endif
 #if JS_HAS_LVALUE_RETURN
                 if (pn3->pn_type == TOK_LP) {
@@ -4353,8 +4392,7 @@
                         return JS_FALSE;
                     if (js_Emit1(cx, cg, JSOP_ENUMELEM) < 0)
                         return JS_FALSE;
-                    break;
-                }
+                } else
 #endif
 #if JS_HAS_XML_SUPPORT
                 if (pn3->pn_type == TOK_UNARYOP) {
@@ -4363,45 +4401,34 @@
                         return JS_FALSE;
                     if (js_Emit1(cx, cg, JSOP_ENUMELEM) < 0)
                         return JS_FALSE;
-                    break;
-                }
-#endif
-
-                /* Now that we're safely past the IFEQ, commit side effects. */
+                } else
+#endif
                 if (!EmitElemOp(cx, pn3, JSOP_ENUMELEM, cg))
                     return JS_FALSE;
-                break;
-
-              default:
-                JS_ASSERT(0);
-            }
-
-            if (emitIFEQ) {
-                /* Annotate so the decompiler can find the loop-closing jump. */
-                noteIndex = js_NewSrcNote(cx, cg, SRC_WHILE);
-                if (noteIndex < 0)
-                    return JS_FALSE;
-
-                /* Pop and test the loop condition generated by JSOP_FOR*. */
-                beq = EmitJump(cx, cg, JSOP_IFEQ, 0);
-                if (beq < 0)
-                    return JS_FALSE;
-            }
-
-            /* Emit code for the loop body. */
-            if (!js_EmitTree(cx, cg, pn->pn_right))
-                return JS_FALSE;
-
-            /* Emit the loop-closing jump and fixup all jump offsets. */
-            jmp = EmitJump(cx, cg, JSOP_GOTO, top - CG_OFFSET(cg));
-            if (jmp < 0)
-                return JS_FALSE;
-            if (beq > 0)
-                CHECK_AND_SET_JUMP_OFFSET_AT(cx, cg, beq);
-
-            /* Set the SRC_WHILE note offset so we can find the closing jump. */
-            JS_ASSERT(noteIndex != -1);
-            if (!js_SetSrcNoteOffset(cx, cg, (uintN)noteIndex, 0, jmp - beq))
+
+                if (!EmitForInLoopBody(cx, cg, &stmtInfo, pn->pn_right, noteIndex, jmp))
+                    return JS_FALSE;
+
+                /*
+                 * JSOP_FORELEM has nuses 1, ndefs 3, modeling the case where
+                 * it pushes the next value and then true, to keep iterating.
+                 * For symmetry here, we manually drop cg->stackDepth after to
+                 * reflect the fact that we've emitted JSOP_ENUMELEM already.
+                 */
+                if (js_Emit1(cx, cg, JSOP_FORELEM) < 0)
+                    return JS_FALSE;
+                JS_ASSERT(cg->stackDepth >= 3);
+                --cg->stackDepth;
+                break;
+            }
+
+            /* Pop and test the loop condition generated by JSOP_FOR*. */
+            beq = EmitJump(cx, cg, JSOP_IFNE, top - CG_OFFSET(cg));
+            if (beq < 0)
+                return JS_FALSE;
+
+            /* Set the second srcnote offset so we can find the closing jump. */
+            if (!js_SetSrcNoteOffset(cx, cg, (uintN)noteIndex, 1, beq - jmp))
                 return JS_FALSE;
         } else {
             /* C-style for (init; cond; update) ... loop. */
@@ -5699,8 +5726,7 @@
           default:
             /*
              * If useless, just emit JSOP_TRUE; otherwise convert delete foo()
-             * to foo(), true (a comma expression, requiring SRC_PCDELTA, and
-             * also JSOP_GROUP for correctly parenthesized decompilation).
+             * to foo(), true (a comma expression, requiring SRC_PCDELTA).
              */
             useful = JS_FALSE;
             if (!CheckSideEffects(cx, cg, pn2, &useful))
@@ -5722,8 +5748,6 @@
                 if (!js_SetSrcNoteOffset(cx, cg, (uintN)noteIndex, 0, tmp-off))
                     return JS_FALSE;
             }
-            if (js_Emit1(cx, cg, JSOP_GROUP) < 0)
-                return JS_FALSE;
         }
         break;
 
@@ -5831,8 +5855,6 @@
 
         argc = pn->pn_count - 1;
         if (js_Emit3(cx, cg, PN_OP(pn), ARGC_HI(argc), ARGC_LO(argc)) < 0)
-            return JS_FALSE;
-        if (js_Emit1(cx, cg, JSOP_RESUME) < 0)
             return JS_FALSE;
         if (PN_OP(pn) == JSOP_EVAL) 
             EMIT_UINT16_IMM_OP(JSOP_LINENO, pn->pn_pos.begin.lineno);
@@ -6144,8 +6166,6 @@
         if (!js_EmitTree(cx, cg, pn->pn_kid))
             return JS_FALSE;
         cg->treeContext.flags |= oldflags & TCF_IN_FOR_INIT;
-        if (js_Emit1(cx, cg, JSOP_GROUP) < 0)
-            return JS_FALSE;
         break;
       }
 
@@ -6361,8 +6381,8 @@
     {"null",            0,      0,      0},
     {"if",              0,      0,      0},
     {"if-else",         2,      0,      1},
+    {"for",             3,      1,      1},
     {"while",           1,      0,      1},
-    {"for",             3,      1,      1},
     {"continue",        0,      0,      0},
     {"decl",            1,      1,      1},
     {"pcdelta",         1,      0,      1},
diff -r 17e9560465b0 js/src/jsemit.h
--- a/js/src/jsemit.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/jsemit.h	Thu Oct 30 05:41:45 2008 -0400
@@ -589,8 +589,12 @@
                                    or a destructuring object initialiser */
     SRC_GENEXP      = 1,        /* JSOP_ANONFUNOBJ from generator expression */
     SRC_IF_ELSE     = 2,        /* JSOP_IFEQ bytecode is from an if-then-else */
-    SRC_WHILE       = 3,        /* JSOP_IFEQ is from a while loop */
-    SRC_FOR         = 4,        /* JSOP_NOP or JSOP_POP in for loop head */
+    SRC_FOR_IN      = 2,        /* JSOP_GOTO to for-in loop condition from
+                                   before loop (same arity as SRC_IF_ELSE) */
+    SRC_FOR         = 3,        /* JSOP_NOP or JSOP_POP in for(;;) loop head */
+    SRC_WHILE       = 4,        /* JSOP_GOTO to for or while loop condition
+                                   from before loop, else JSOP_NOP at top of
+                                   do-while loop */
     SRC_CONTINUE    = 5,        /* JSOP_GOTO is a continue, not a break;
                                    also used on JSOP_ENDINIT if extra comma
                                    at end of array literal: [1,2,,] */
diff -r 17e9560465b0 js/src/jsinterp.cpp
--- a/js/src/jsinterp.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/jsinterp.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -2572,6 +2572,7 @@
 #ifdef JS_TRACER
     /* We had better not be entering the interpreter from JIT-compiled code. */
     TraceRecorder *tr = NULL;
+    uint32 jitCacheGen = JS_TRACE_MONITOR(cx).jitCacheGen;
     if (JS_ON_TRACE(cx)) {
         tr = TRACE_RECORDER(cx);
         SET_TRACE_RECORDER(cx, NULL);
@@ -2738,12 +2739,17 @@
 
     LOAD_INTERRUPT_HANDLER(cx);
 
-    /* Initialize the pc and pc registers unless we're resuming a generator. */
+#if !JS_HAS_GENERATORS
+    JS_ASSERT(!fp->regs);
+#else
+    /* Initialize the pc and sp registers unless we're resuming a generator. */
     if (JS_LIKELY(!fp->regs)) {
+#endif
         ASSERT_NOT_THROWING(cx);
         regs.pc = script->code;
         regs.sp = StackBase(fp);
         fp->regs = &regs;
+#if JS_HAS_GENERATORS
     } else {
         JSGenerator *gen;
 
@@ -2771,6 +2777,7 @@
             goto error;
         }
     }
+#endif /* JS_HAS_GENERATORS */
 
     /*
      * It is important that "op" be initialized before calling DO_OP because
@@ -2851,7 +2858,6 @@
 
           /* No-ops for ease of decompilation. */
           ADD_EMPTY_CASE(JSOP_NOP)
-          ADD_EMPTY_CASE(JSOP_GROUP)
           ADD_EMPTY_CASE(JSOP_CONDSWITCH)
           ADD_EMPTY_CASE(JSOP_TRY)
           ADD_EMPTY_CASE(JSOP_FINALLY)
@@ -4780,9 +4786,7 @@
                 goto error;
             regs.sp = vp + 1;
             LOAD_INTERRUPT_HANDLER(cx);
-            JS_ASSERT(regs.pc[JSOP_NEW_LENGTH] == JSOP_RESUME);
-            len = JSOP_NEW_LENGTH + JSOP_RESUME_LENGTH;
-          END_VARLEN_CASE
+          END_CASE(JSOP_NEW)
 
           BEGIN_CASE(JSOP_CALL)
           BEGIN_CASE(JSOP_EVAL)
@@ -5049,13 +5053,7 @@
                 cx->rval2set = JS_FALSE;
             }
 #endif /* JS_HAS_LVALUE_RETURN */
-            JS_ASSERT(regs.pc[JSOP_CALL_LENGTH] == JSOP_RESUME);
-            len = JSOP_CALL_LENGTH + JSOP_RESUME_LENGTH;
-            END_VARLEN_CASE
-
-          BEGIN_CASE(JSOP_RESUME)
-            /* This case is not truly empty. The tracer is invoked transparently. */
-          END_CASE(JSOP_RESUME)
+          END_CASE(JSOP_CALL)
 
 #if JS_HAS_LVALUE_RETURN
           BEGIN_CASE(JSOP_SETCALL)
@@ -5066,10 +5064,8 @@
             LOAD_INTERRUPT_HANDLER(cx);
             if (!ok)
                 goto error;
-            JS_ASSERT(regs.pc[JSOP_SETCALL_LENGTH] == JSOP_RESUME);
-            len = JSOP_SETCALL_LENGTH + JSOP_RESUME_LENGTH;
             if (!cx->rval2set) {
-                op2 = (JSOp) regs.pc[len];
+                op2 = (JSOp) regs.pc[JSOP_SETCALL_LENGTH];
                 if (op2 != JSOP_DELELEM) {
                     JS_ASSERT(!(js_CodeSpec[op2].format & JOF_DEL));
                     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
@@ -5083,7 +5079,7 @@
                  * it doesn't seem worth the code for this obscure case.
                  */
                 *vp = JSVAL_TRUE;
-                regs.pc += len + JSOP_DELELEM_LENGTH;
+                regs.pc += JSOP_SETCALL_LENGTH + JSOP_DELELEM_LENGTH;
                 op = (JSOp) *regs.pc;
                 DO_OP();
             }
@@ -5131,15 +5127,11 @@
             if (!prop) {
                 /* Kludge to allow (typeof foo == "undefined") tests. */
                 endpc = script->code + script->length;
-                for (pc2 = regs.pc + JSOP_NAME_LENGTH; pc2 < endpc; pc2++) {
-                    op2 = (JSOp)*pc2;
-                    if (op2 == JSOP_TYPEOF) {
-                        PUSH_OPND(JSVAL_VOID);
-                        len = JSOP_NAME_LENGTH;
-                        DO_NEXT_OP(len);
-                    }
-                    if (op2 != JSOP_GROUP)
-                        break;
+                op2 = (JSOp) regs.pc[JSOP_NAME_LENGTH];
+                if (op2 == JSOP_TYPEOF) {
+                    PUSH_OPND(JSVAL_VOID);
+                    len = JSOP_NAME_LENGTH;
+                    DO_NEXT_OP(len);
                 }
                 goto atom_not_defined;
             }
@@ -6831,10 +6823,12 @@
           L_JSOP_DEFXMLNS:
 # endif
 
+          L_JSOP_UNUSED74:
           L_JSOP_UNUSED76:
           L_JSOP_UNUSED77:
           L_JSOP_UNUSED78:
           L_JSOP_UNUSED79:
+          L_JSOP_UNUSED131:
           L_JSOP_UNUSED201:
           L_JSOP_UNUSED202:
           L_JSOP_UNUSED203:
@@ -7053,6 +7047,7 @@
     if (TRACE_RECORDER(cx))
         js_AbortRecording(cx, "recording out of js_Interpret");
 #endif
+#if JS_HAS_GENERATORS
     if (JS_UNLIKELY(fp->flags & JSFRAME_YIELDING)) {
         JSGenerator *gen;
 
@@ -7061,7 +7056,9 @@
         gen->frame.regs = &gen->savedRegs;
         JS_PROPERTY_CACHE(cx).disabled -= js_CountWithBlocks(cx, fp);
         JS_ASSERT(JS_PROPERTY_CACHE(cx).disabled >= 0);
-    } else {
+    } else
+#endif /* JS_HAS_GENERATORS */
+    {
         JS_ASSERT(!fp->blockChain);
         JS_ASSERT(!js_IsActiveWithOrBlock(cx, fp->scopeChain, 0));
         fp->regs = NULL;
@@ -7080,6 +7077,8 @@
         JS_TRACE_MONITOR(cx).onTrace = JS_TRUE;
         SET_TRACE_RECORDER(cx, tr);
         tr->deepAbort();
+        if (jitCacheGen != JS_TRACE_MONITOR(cx).jitCacheGen)
+            tr->safeCleanup();
     }
 #endif
     return ok;
diff -r 17e9560465b0 js/src/jsmath.cpp
--- a/js/src/jsmath.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/jsmath.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -344,16 +344,12 @@
             *vp = DOUBLE_TO_JSVAL(cx->runtime->jsNaN);
             return JS_TRUE;
         }
-        if (x == 0 && x == z && js_copysign(1.0, z) == -1)
-            z = x;
-        else
-            /* 
-             * Note: it is essential that you write the ternary expression
-             * here such that the false branch produces z not x, as the case
-             * of x=-0, z=0, for which we wind up in this expression but
-             * evaluate either > order as false, whether we do x>z *or* z>x.
-             */
+        if (x == 0 && x == z) {
+            if (js_copysign(1.0, z) == -1)
+                z = x;
+        } else {
             z = (x > z) ? x : z;
+        }
     }
     return js_NewNumberInRootedValue(cx, z, vp);
 }
@@ -378,10 +374,12 @@
             *vp = DOUBLE_TO_JSVAL(cx->runtime->jsNaN);
             return JS_TRUE;
         }
-        if (x == 0 && x == z && js_copysign(1.0,x) == -1)
-            z = x;
-        else
+        if (x == 0 && x == z) {
+            if (js_copysign(1.0, x) == -1)
+                z = x;
+        } else {
             z = (x < z) ? x : z;
+        }
     }
     return js_NewNumberInRootedValue(cx, z, vp);
 }
@@ -596,10 +594,9 @@
 #ifdef JS_TRACER
 
 #define MATH_BUILTIN_1(name)                                                  \
-    jsdouble FASTCALL js_Math_##name(jsdouble d) { return name(d); }          \
-    JS_DEFINE_CALLINFO_1(DOUBLE, Math_##name, DOUBLE, 1, 1)                   \
-    static const JSTraceableNative math_##name##_trcinfo =                    \
-        { math_##name, &ci_Math_##name, "", "d", INFALLIBLE };
+    static jsdouble FASTCALL math_##name##_tn(jsdouble d) { return name(d); } \
+    JS_DEFINE_TRCINFO_1(math_##name,                                          \
+        (1, (static, DOUBLE, math_##name##_tn, DOUBLE, 1, 1)))
 
 MATH_BUILTIN_1(sin)
 MATH_BUILTIN_1(cos)
@@ -607,8 +604,8 @@
 MATH_BUILTIN_1(floor)
 MATH_BUILTIN_1(ceil)
 
-jsdouble FASTCALL
-js_Math_log(jsdouble d)
+static jsdouble FASTCALL
+math_log_tn(jsdouble d)
 {
 #if defined(SOLARIS) && defined(__GNUC__)
     if (d < 0)
@@ -617,19 +614,22 @@
     return log(d);
 }
 
-jsdouble FASTCALL
-js_Math_max(jsdouble d, jsdouble p)
+static jsdouble FASTCALL
+math_max_tn(jsdouble d, jsdouble p)
 {
     if (JSDOUBLE_IS_NaN(d) || JSDOUBLE_IS_NaN(p))
         return js_NaN;
 
-    if (p == 0 && p == d && js_copysign(1.0, d) == -1)
-        return p;
-    return (d > p) ? d : p;
+    if (p == 0 && p == d) {
+        if (js_copysign(1.0, d) == -1)
+            return p;
+        return d;
+    }
+    return (p > d) ? p : d;
 }
 
-jsdouble FASTCALL
-js_Math_pow(jsdouble d, jsdouble p)
+static jsdouble FASTCALL
+math_pow_tn(jsdouble d, jsdouble p)
 {
     if (!JSDOUBLE_IS_FINITE(p) && (d == 1.0 || d == -1.0))
         return js_NaN;
@@ -638,8 +638,8 @@
     return pow(d, p);
 }
 
-jsdouble FASTCALL
-js_Math_random(JSRuntime* rt)
+static jsdouble FASTCALL
+math_random_tn(JSRuntime* rt)
 {
     JS_LOCK_RUNTIME(rt);
     js_random_init(rt);
@@ -648,19 +648,14 @@
     return z;
 }
 
-JS_DEFINE_CALLINFO_1(DOUBLE, Math_log,    DOUBLE,          1, 1)
-JS_DEFINE_CALLINFO_2(DOUBLE, Math_max,    DOUBLE, DOUBLE,  1, 1)
-JS_DEFINE_CALLINFO_2(DOUBLE, Math_pow,    DOUBLE, DOUBLE,  1, 1)
-JS_DEFINE_CALLINFO_1(DOUBLE, Math_random, RUNTIME,         0, 0)
-
-static const JSTraceableNative math_log_trcinfo =
-    { math_log,    &ci_Math_log,    "",    "d",    INFALLIBLE };
-static const JSTraceableNative math_max_trcinfo =
-    { math_max,    &ci_Math_max,    "",    "dd",   INFALLIBLE };
-static const JSTraceableNative math_pow_trcinfo =
-    { math_pow,    &ci_Math_pow,    "",    "dd",   INFALLIBLE };
-static const JSTraceableNative math_random_trcinfo =
-    { math_random, &ci_Math_random, "R",   "",     INFALLIBLE };
+JS_DEFINE_TRCINFO_1(math_log,
+    (1, (static, DOUBLE, math_log_tn, DOUBLE,           1, 1)))
+JS_DEFINE_TRCINFO_1(math_max,
+    (2, (static, DOUBLE, math_max_tn, DOUBLE, DOUBLE,   1, 1)))
+JS_DEFINE_TRCINFO_1(math_pow,
+    (2, (static, DOUBLE, math_pow_tn, DOUBLE, DOUBLE,   1, 1)))
+JS_DEFINE_TRCINFO_1(math_random,
+    (1, (static, DOUBLE, math_random_tn, RUNTIME,       0, 0)))
 
 #endif /* JS_TRACER */
 
@@ -673,18 +668,18 @@
     JS_FN("asin",           math_asin,            1, 0),
     JS_FN("atan",           math_atan,            1, 0),
     JS_FN("atan2",          math_atan2,           2, 0),
-    JS_TN("ceil",           math_ceil,            1, 0, &math_ceil_trcinfo),
-    JS_TN("cos",            math_cos,             1, 0, &math_cos_trcinfo),
+    JS_TN("ceil",           math_ceil,            1, 0, math_ceil_trcinfo),
+    JS_TN("cos",            math_cos,             1, 0, math_cos_trcinfo),
     JS_FN("exp",            math_exp,             1, 0),
-    JS_TN("floor",          math_floor,           1, 0, &math_floor_trcinfo),
-    JS_TN("log",            math_log,             1, 0, &math_log_trcinfo),
-    JS_TN("max",            math_max,             2, 0, &math_max_trcinfo),
+    JS_TN("floor",          math_floor,           1, 0, math_floor_trcinfo),
+    JS_TN("log",            math_log,             1, 0, math_log_trcinfo),
+    JS_TN("max",            math_max,             2, 0, math_max_trcinfo),
     JS_FN("min",            math_min,             2, 0),
-    JS_TN("pow",            math_pow,             2, 0, &math_pow_trcinfo),
-    JS_TN("random",         math_random,          0, 0, &math_random_trcinfo),
+    JS_TN("pow",            math_pow,             2, 0, math_pow_trcinfo),
+    JS_TN("random",         math_random,          0, 0, math_random_trcinfo),
     JS_FN("round",          math_round,           1, 0),
-    JS_TN("sin",            math_sin,             1, 0, &math_sin_trcinfo),
-    JS_TN("sqrt",           math_sqrt,            1, 0, &math_sqrt_trcinfo),
+    JS_TN("sin",            math_sin,             1, 0, math_sin_trcinfo),
+    JS_TN("sqrt",           math_sqrt,            1, 0, math_sqrt_trcinfo),
     JS_FN("tan",            math_tan,             1, 0),
     JS_FS_END
 };
diff -r 17e9560465b0 js/src/jsnum.cpp
--- a/js/src/jsnum.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/jsnum.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -124,8 +124,8 @@
 }
 
 #ifdef JS_TRACER
-jsdouble FASTCALL
-js_ParseFloat(JSContext* cx, JSString* str)
+static jsdouble FASTCALL
+ParseFloat(JSContext* cx, JSString* str)
 {
     const jschar* bp;
     const jschar* end;
@@ -183,8 +183,8 @@
 }
 
 #ifdef JS_TRACER
-jsdouble FASTCALL
-js_ParseInt(JSContext* cx, JSString* str)
+static jsdouble FASTCALL
+ParseInt(JSContext* cx, JSString* str)
 {
     const jschar* bp;
     const jschar* end;
@@ -197,8 +197,8 @@
     return d;
 }
 
-jsdouble FASTCALL
-js_ParseIntDouble(jsdouble d)
+static jsdouble FASTCALL
+ParseIntDouble(jsdouble d)
 {
     if (!JSDOUBLE_IS_FINITE(d))
         return js_NaN;
@@ -215,23 +215,18 @@
 
 #ifdef JS_TRACER
 
-JS_DEFINE_CALLINFO_2(DOUBLE, ParseInt, CONTEXT, STRING,     1, 1)
-JS_DEFINE_CALLINFO_1(DOUBLE, ParseIntDouble, DOUBLE,        1, 1)
-JS_DEFINE_CALLINFO_2(DOUBLE, ParseFloat, CONTEXT, STRING,   1, 1)
+JS_DEFINE_TRCINFO_2(num_parseInt,
+    (2, (static, DOUBLE, ParseInt, CONTEXT, STRING,     1, 1)),
+    (1, (static, DOUBLE, ParseIntDouble, DOUBLE,        1, 1)))
 
-static const JSTraceableNative num_parseInt_trcinfo[] = {
-    { num_parseInt,             &ci_ParseInt,             "C",   "s",    INFALLIBLE | JSTN_MORE },
-    { num_parseInt,             &ci_ParseIntDouble,       "",    "d",    INFALLIBLE }
-};
-static const JSTraceableNative num_parseFloat_trcinfo[] = {
-    { num_parseFloat,           &ci_ParseFloat,           "C",   "s",    INFALLIBLE }
-};
+JS_DEFINE_TRCINFO_1(num_parseFloat,
+    (2, (static, DOUBLE, ParseFloat, CONTEXT, STRING,   1, 1)))
 
 #endif /* JS_TRACER */
 
 static JSFunctionSpec number_functions[] = {
-    JS_FN(js_isNaN_str,         num_isNaN,              1,0),
-    JS_FN(js_isFinite_str,      num_isFinite,           1,0),
+    JS_FN(js_isNaN_str,         num_isNaN,           1,0),
+    JS_FN(js_isFinite_str,      num_isFinite,        1,0),
     JS_TN(js_parseFloat_str,    num_parseFloat,      1,0, num_parseFloat_trcinfo),
     JS_TN(js_parseInt_str,      num_parseInt,        2,0, num_parseInt_trcinfo),
     JS_FS_END
@@ -304,7 +299,7 @@
 
 /* The buf must be big enough for MIN_INT to fit including '-' and '\0'. */
 char *
-js_IntToCString(jsint i, char *buf, size_t bufSize)
+js_IntToCString(jsint i, jsint base, char *buf, size_t bufSize)
 {
     char *cp;
     jsuint u;
@@ -318,12 +313,30 @@
      * Build the string from behind. We use multiply and subtraction
      * instead of modulus because that's much faster.
      */
-    do {
-        jsuint newu = u / 10;
-        *--cp = (char)(u - newu * 10) + '0';
-        u = newu;
-    } while (u != 0);
-
+    switch (base) {
+    case 10:
+      do {
+          jsuint newu = u / 10;
+          *--cp = (char)(u - newu * 10) + '0';
+          u = newu;
+      } while (u != 0);
+      break;
+    case 16:
+      do {
+          jsuint newu = u / 16;
+          *--cp = "0123456789abcdef"[u - newu * 16];
+          u = newu;
+      } while (u != 0);
+      break;
+    default:
+      JS_ASSERT(base >= 2 && base <= 36);
+      do {
+          jsuint newu = u / base;
+          *--cp = "0123456789abcdefghijklmnopqrstuvwxyz"[u - newu * base];
+          u = newu;
+      } while (u != 0);
+      break;
+    }
     if (i < 0)
         *--cp = '-';
 
@@ -350,7 +363,7 @@
             return JS_FALSE;
         if (base < 2 || base > 36) {
             char numBuf[12];
-            char *numStr = js_IntToCString(base, numBuf, sizeof numBuf);
+            char *numStr = js_IntToCString(base, 10, numBuf, sizeof numBuf);
             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_RADIX,
                                  numStr);
             return JS_FALSE;
@@ -579,11 +592,9 @@
 
 #ifdef JS_TRACER
 
-JS_DEFINE_CALLINFO_2(STRING, NumberToString, CONTEXT, DOUBLE, 1, 1)
-
-static const JSTraceableNative num_toString_trcinfo[] = {
-    { num_toString,             &ci_NumberToString,       "DC",   "",    FAIL_NULL }
-};
+JS_DEFINE_TRCINFO_2(num_toString,
+    (3, (static, STRING, NumberToStringWithBase, CONTEXT, THIS_DOUBLE, INT32, 1, 1)),
+    (2, (extern, STRING, js_NumberToString,      CONTEXT, THIS_DOUBLE,        1, 1)))
 
 #endif /* JS_TRACER */
 
@@ -777,16 +788,19 @@
 }
 
 char *
-js_NumberToCString(JSContext *cx, jsdouble d, char *buf, size_t bufSize)
+js_NumberToCString(JSContext *cx, jsdouble d, jsint base, char *buf, size_t bufSize)
 {
     jsint i;
     char *numStr;
 
     JS_ASSERT(bufSize >= DTOSTR_STANDARD_BUFFER_SIZE);
     if (JSDOUBLE_IS_INT(d, i)) {
-        numStr = js_IntToCString(i, buf, bufSize);
+        numStr = js_IntToCString(i, base, buf, bufSize);
     } else {
-        numStr = JS_dtostr(buf, bufSize, DTOSTR_STANDARD, 0, d);
+        if (base == 10)
+            numStr = JS_dtostr(buf, bufSize, DTOSTR_STANDARD, 0, d);
+        else
+            numStr = JS_dtobasestr(base, d);
         if (!numStr) {
             JS_ReportOutOfMemory(cx);
             return NULL;
@@ -795,16 +809,24 @@
     return numStr;
 }
 
-JSString * JS_FASTCALL
-js_NumberToString(JSContext *cx, jsdouble d)
+static JSString * JS_FASTCALL
+NumberToStringWithBase(JSContext *cx, jsdouble d, jsint base)
 {
     char buf[DTOSTR_STANDARD_BUFFER_SIZE];
     char *numStr;
 
-    numStr = js_NumberToCString(cx, d, buf, sizeof buf);
+    if (base < 2 || base > 36)
+        return NULL;
+    numStr = js_NumberToCString(cx, d, base, buf, sizeof buf);
     if (!numStr)
         return NULL;
     return JS_NewStringCopyZ(cx, numStr);
+}
+
+JSString * JS_FASTCALL
+js_NumberToString(JSContext *cx, jsdouble d)
+{
+    return NumberToStringWithBase(cx, d, 10);
 }
 
 jsdouble
diff -r 17e9560465b0 js/src/jsnum.h
--- a/js/src/jsnum.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/jsnum.h	Thu Oct 30 05:41:45 2008 -0400
@@ -187,14 +187,14 @@
  * including '-' and '\0'.
  */
 char *
-js_IntToCString(jsint i, char *buf, size_t bufSize);
+js_IntToCString(jsint i, jsint base, char *buf, size_t bufSize);
 
 /*
  * Convert a number to C string. The buf must be at least
  * DTOSTR_STANDARD_BUFFER_SIZE.
  */
 char *
-js_NumberToCString(JSContext *cx, jsdouble d, char *buf, size_t bufSize);
+js_NumberToCString(JSContext *cx, jsdouble d, jsint base, char *buf, size_t bufSize);
 
 /*
  * Convert a value to a number. On exit JSVAL_IS_NULL(*vp) iff there was an
diff -r 17e9560465b0 js/src/jsobj.cpp
--- a/js/src/jsobj.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/jsobj.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -1168,9 +1168,8 @@
     }
 
     if (caller->regs && *caller->regs->pc == JSOP_EVAL) {
-        JS_ASSERT(caller->regs->pc[JSOP_EVAL_LENGTH] == JSOP_RESUME);
-        JS_ASSERT(caller->regs->pc[JSOP_EVAL_LENGTH + JSOP_RESUME_LENGTH] == JSOP_LINENO);
-        *linenop = GET_UINT16(caller->regs->pc + JSOP_EVAL_LENGTH + JSOP_RESUME_LENGTH);
+        JS_ASSERT(caller->regs->pc[JSOP_EVAL_LENGTH] == JSOP_LINENO);
+        *linenop = GET_UINT16(caller->regs->pc + JSOP_EVAL_LENGTH);
     } else {
         *linenop = js_PCToLineNumber(cx, caller->script,
                                      caller->regs ? caller->regs->pc : NULL);
@@ -1557,11 +1556,14 @@
 }
 
 #ifdef JS_TRACER
-int32 FASTCALL
-js_Object_p_hasOwnProperty(JSContext* cx, JSObject* obj, JSString *str)
-{
-    jsid id = ATOM_TO_JSID(STRING_TO_JSVAL(str));
-    jsval v;
+static int32 FASTCALL
+Object_p_hasOwnProperty(JSContext* cx, JSObject* obj, JSString *str)
+{
+    jsid id;
+    jsval v;
+
+    if (!js_ValueToStringId(cx, STRING_TO_JSVAL(str), &id))
+        return JSVAL_TO_BOOLEAN(JSVAL_VOID);
     if (!js_HasOwnProperty(cx, obj->map->ops->lookupProperty, obj, id, &v))
         return JSVAL_TO_BOOLEAN(JSVAL_VOID);
     JS_ASSERT(JSVAL_IS_BOOLEAN(v));
@@ -1598,8 +1600,8 @@
 }
 
 #ifdef JS_TRACER
-int32 FASTCALL
-js_Object_p_propertyIsEnumerable(JSContext* cx, JSObject* obj, JSString *str)
+static int32 FASTCALL
+Object_p_propertyIsEnumerable(JSContext* cx, JSObject* obj, JSString *str)
 {
     jsid id = ATOM_TO_JSID(STRING_TO_JSVAL(str));
     jsval v;
@@ -1809,19 +1811,10 @@
 const char js_lookupSetter_str[] = "__lookupSetter__";
 #endif
 
-#ifdef JS_TRACER
-
-JS_DEFINE_CALLINFO_3(INT32, Object_p_hasOwnProperty, CONTEXT, OBJECT, STRING,       0, 0)
-JS_DEFINE_CALLINFO_3(INT32, Object_p_propertyIsEnumerable, CONTEXT, OBJECT, STRING, 0, 0)
-
-static const JSTraceableNative obj_hasOwnProperty_trcinfo[] = {
-    { obj_hasOwnProperty,       &ci_Object_p_hasOwnProperty,       "TC",  "s", FAIL_VOID }
-};
-static const JSTraceableNative obj_propertyIsEnumerable_trcinfo[] = {
-    { obj_propertyIsEnumerable, &ci_Object_p_propertyIsEnumerable, "TC",  "s", FAIL_VOID }
-};
-
-#endif /* JS_TRACER */
+JS_DEFINE_TRCINFO_1(obj_hasOwnProperty,
+    (3, (static, BOOL_FAIL, Object_p_hasOwnProperty, CONTEXT, THIS, STRING,       0, 0)))
+JS_DEFINE_TRCINFO_1(obj_propertyIsEnumerable,
+    (3, (static, BOOL_FAIL, Object_p_propertyIsEnumerable, CONTEXT, THIS, STRING, 0, 0)))
 
 static JSFunctionSpec object_methods[] = {
 #if JS_HAS_TOSOURCE
@@ -3323,9 +3316,6 @@
                        op == JSOP_STRICTEQ || op == JSOP_STRICTNE;
             }
             return JS_FALSE;
-
-          case JSOP_GROUP:
-            break;
 
           default:
             /*
diff -r 17e9560465b0 js/src/jsopcode.cpp
--- a/js/src/jsopcode.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/jsopcode.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -63,6 +63,7 @@
 #include "jsemit.h"
 #include "jsfun.h"
 #include "jsiter.h"
+#include "jsnum.h"
 #include "jsobj.h"
 #include "jsopcode.h"
 #include "jsregexp.h"
@@ -72,10 +73,6 @@
 #include "jsstr.h"
 #include "jsstaticcheck.h"
 
-#if JS_HAS_DESTRUCTURING
-# include "jsnum.h"
-#endif
-
 #include "jsautooplen.h"
 
 /* Verify JSOP_XXX_LENGTH constant definitions. */
@@ -85,6 +82,7 @@
 #undef OPDEF
 
 static const char js_incop_strs[][3] = {"++", "--"};
+static const char js_for_each_str[]  = "for each";
 
 const JSCodeSpec js_CodeSpec[] = {
 #define OPDEF(op,val,name,token,length,nuses,ndefs,prec,format) \
@@ -968,10 +966,10 @@
 }
 
 static ptrdiff_t
-PopOff(SprintStack *ss, JSOp op)
+PopOffPrec(SprintStack *ss, uint8 prec)
 {
     uintN top;
-    const JSCodeSpec *cs, *topcs;
+    const JSCodeSpec *topcs;
     ptrdiff_t off;
 
     /* ss->top points to the next free slot; be paranoid about underflow. */
@@ -983,8 +981,7 @@
     ss->top = --top;
     off = GetOff(ss, top);
     topcs = &js_CodeSpec[ss->opcodes[top]];
-    cs = &js_CodeSpec[op];
-    if (topcs->prec != 0 && topcs->prec < cs->prec) {
+    if (topcs->prec != 0 && topcs->prec < prec) {
         ss->sprinter.offset = ss->offsets[top] = off - 2;
         off = Sprint(&ss->sprinter, "(%s)", OFF2STR(&ss->sprinter, off));
     } else {
@@ -994,12 +991,24 @@
 }
 
 static const char *
+PopStrPrec(SprintStack *ss, uint8 prec)
+{
+    ptrdiff_t off;
+
+    off = PopOffPrec(ss, prec);
+    return OFF2STR(&ss->sprinter, off);
+}
+
+static ptrdiff_t
+PopOff(SprintStack *ss, JSOp op)
+{
+    return PopOffPrec(ss, js_CodeSpec[op].prec);
+}
+
+static const char *
 PopStr(SprintStack *ss, JSOp op)
 {
-    ptrdiff_t off;
-
-    off = PopOff(ss, op);
-    return OFF2STR(&ss->sprinter, off);
+    return PopStrPrec(ss, js_CodeSpec[op].prec);
 }
 
 typedef struct TableEntry {
@@ -1270,11 +1279,6 @@
 #undef LOCAL_ASSERT
 }
 
-#if JS_HAS_DESTRUCTURING
-
-#define LOCAL_ASSERT(expr)  LOCAL_ASSERT_RV(expr, NULL)
-#define LOAD_OP_DATA(pc)    (oplen = (cs = &js_CodeSpec[op=(JSOp)*pc])->length)
-
 static JSBool
 IsVarSlot(JSPrinter *jp, jsbytecode *pc, jsint *indexp)
 {
@@ -1293,6 +1297,11 @@
     *indexp = slot;
     return JS_FALSE;
 }
+
+#if JS_HAS_DESTRUCTURING
+
+#define LOCAL_ASSERT(expr)  LOCAL_ASSERT_RV(expr, NULL)
+#define LOAD_OP_DATA(pc)    (oplen = (cs = &js_CodeSpec[op=(JSOp)*pc])->length)
 
 static jsbytecode *
 DecompileDestructuring(SprintStack *ss, jsbytecode *pc, jsbytecode *endpc);
@@ -1709,7 +1718,7 @@
 {
     JSContext *cx;
     JSPrinter *jp, *jp2;
-    jsbytecode *startpc, *endpc, *pc2, *done, *forelem_tail, *forelem_done;
+    jsbytecode *startpc, *endpc, *pc2, *done;
     ptrdiff_t tail, todo, len, oplen, cond, next;
     JSOp op, lastop, saveop;
     const JSCodeSpec *cs;
@@ -1740,6 +1749,7 @@
     static const char preindex_format[]  = "%s%s[%s]";
     static const char postindex_format[] = "%s[%s]%s";
     static const char ss_format[]        = "%s%s";
+    static const char sss_format[]       = "%s%s%s";
 
     /* Argument and variables decompilation uses the following to share code. */
     JS_STATIC_ASSERT(ARGNO_LEN == SLOTNO_LEN);
@@ -1747,10 +1757,20 @@
 /*
  * Local macros
  */
+#define LOCAL_ASSERT(expr)    LOCAL_ASSERT_RV(expr, NULL)
 #define DECOMPILE_CODE(pc,nb) if (!Decompile(ss, pc, nb, JSOP_NOP)) return NULL
 #define NEXT_OP(pc)           (((pc) + (len) == endpc) ? nextop : pc[len])
 #define POP_STR()             PopStr(ss, op)
-#define LOCAL_ASSERT(expr)    LOCAL_ASSERT_RV(expr, NULL)
+#define POP_STR_PREC(prec)    PopStrPrec(ss, prec)
+
+/*
+ * Pop a condition expression for if/for/while. JSOP_IFEQ's precedence forces
+ * extra parens around assignment, which avoids a strict-mode warning.
+ */
+#define POP_COND_STR()                                                        \
+    PopStr(ss, (js_CodeSpec[ss->opcodes[ss->top - 1]].format & JOF_SET)       \
+               ? JSOP_IFEQ                                                    \
+               : JSOP_NOP)
 
 /*
  * Callers know that ATOM_IS_STRING(atom), and we leave it to the optimizer to
@@ -1811,13 +1831,29 @@
         GET_QUOTE_AND_FMT(qfmt, ufmt, rval);                                  \
     JS_END_MACRO
 
+/*
+ * Per spec, new x(y).z means (new x(y))).z. For example new (x(y).z) must
+ * decompile with the constructor parenthesized, but new x.z should not. The
+ * normal rules give x(y).z and x.z identical precedence: both are produced by
+ * JSOP_GETPROP.
+ *
+ * Therefore, we need to know in case JSOP_NEW whether the constructor
+ * expression contains any unparenthesized function calls. So when building a
+ * MemberExpression or CallExpression, we set ss->opcodes[n] to JSOP_CALL if
+ * this is true. x(y).z gets JSOP_CALL, not JSOP_GETPROP.
+ */
+#define PROPAGATE_CALLNESS()                                                  \
+    JS_BEGIN_MACRO                                                            \
+        if (ss->opcodes[ss->top - 1] == JSOP_CALL)                            \
+            saveop = JSOP_CALL;                                               \
+    JS_END_MACRO
+
     cx = ss->sprinter.context;
     JS_CHECK_RECURSION(cx, return NULL);
 
     jp = ss->printer;
     startpc = pc;
     endpc = (nb < 0) ? jp->script->code + jp->script->length : pc + nb;
-    forelem_tail = forelem_done = NULL;
     tail = -1;
     todo = -2;                  /* NB: different from Sprint() error return. */
     saveop = JSOP_NOP;
@@ -1987,20 +2023,21 @@
                      * problem).
                      */
                     op = (JSOp) pc[oplen];
-                    LOCAL_ASSERT(op != saveop);
-                }
-                rval = POP_STR();
-                lval = POP_STR();
-                if (op != saveop) {
+                    rval = POP_STR();
+                    lval = POP_STR();
                     /* Print only the right operand of the assignment-op. */
                     todo = SprintCString(&ss->sprinter, rval);
                     op = saveop;
                 } else if (!inXML) {
+                    rval = POP_STR_PREC(cs->prec + !!(cs->format & JOF_LEFTASSOC));
+                    lval = POP_STR_PREC(cs->prec + !(cs->format & JOF_LEFTASSOC));
                     todo = Sprint(&ss->sprinter, "%s %s %s",
                                   lval, token, rval);
                 } else {
                     /* In XML, just concatenate the two operands. */
                     LOCAL_ASSERT(op == JSOP_ADD);
+                    rval = POP_STR();
+                    lval = POP_STR();
                     todo = Sprint(&ss->sprinter, ss_format, lval, rval);
                 }
                 break;
@@ -2038,7 +2075,7 @@
                     jp->indent += 4;
                     DECOMPILE_CODE(pc, tail);
                     jp->indent -= 4;
-                    js_printf(jp, "\t} while (%s);\n", POP_STR());
+                    js_printf(jp, "\t} while (%s);\n", POP_COND_STR());
                     pc += tail;
                     len = js_CodeSpec[*pc].length;
                     todo = -2;
@@ -2156,44 +2193,6 @@
                 }
                 break;
 
-              case JSOP_GROUP:
-                cs = &js_CodeSpec[lastop];
-                if ((cs->prec != 0 &&
-                     cs->prec <= js_CodeSpec[NEXT_OP(pc)].prec) ||
-                    pc[JSOP_GROUP_LENGTH] == JSOP_NULL ||
-                    pc[JSOP_GROUP_LENGTH] == JSOP_NULLTHIS ||
-                    pc[JSOP_GROUP_LENGTH] == JSOP_DUP ||
-                    pc[JSOP_GROUP_LENGTH] == JSOP_IFEQ ||
-                    pc[JSOP_GROUP_LENGTH] == JSOP_IFNE) {
-                    /*
-                     * Force parens if this JSOP_GROUP forced re-association
-                     * against precedence, or if this is a call or constructor
-                     * expression, or if it is destructured (JSOP_DUP), or if
-                     * it is an if or loop condition test.
-                     *
-                     * This is necessary to handle the operator new grammar,
-                     * by which new x(y).z means (new x(y))).z.  For example
-                     * new (x(y).z) must decompile with the constructor
-                     * parenthesized, but normal precedence has JSOP_GETPROP
-                     * (for the final .z) higher than JSOP_NEW.  In general,
-                     * if the call or constructor expression is parenthesized,
-                     * we preserve parens.
-                     */
-                    op = JSOP_NAME;
-                    rval = POP_STR();
-                    todo = SprintCString(&ss->sprinter, rval);
-                } else {
-                    /*
-                     * Don't explicitly parenthesize -- just fix the top
-                     * opcode so that the auto-parens magic in PopOff can do
-                     * its thing.
-                     */
-                    LOCAL_ASSERT(ss->top != 0);
-                    ss->opcodes[ss->top-1] = saveop = lastop;
-                    todo = -2;
-                }
-                break;
-
               case JSOP_PUSH:
 #if JS_HAS_DESTRUCTURING
                 sn = js_GetSrcNote(jp->script, pc);
@@ -2254,7 +2253,7 @@
 
               case JSOP_POPN:
               {
-                uintN newtop, oldtop, i;
+                uintN newtop, oldtop;
 
                 /*
                  * The compiler models operand stack depth and fixes the stack
@@ -2276,7 +2275,7 @@
                                   VarPrefix(sn));
                     if (todo < 0)
                         return NULL;
-                    for (i = newtop; i < oldtop; i++) {
+                    for (uintN i = newtop; i < oldtop; i++) {
                         rval = OFF2STR(&ss->sprinter, ss->offsets[i]);
                         if (Sprint(&ss->sprinter, ss_format,
                                    (i == newtop) ? "" : ", ",
@@ -2819,6 +2818,8 @@
                 LOCAL_ASSERT(jp->fun);
                 fun = jp->fun;
                 if (fun->flags & JSFUN_EXPR_CLOSURE) {
+                    /* Turn on parens around comma-expression here. */
+                    op = JSOP_SETNAME;
                     rval = POP_STR();
                     js_printf(jp, (*rval == '{') ? "(%s)%s" : ss_format,
                               rval,
@@ -2875,34 +2876,37 @@
                 rval = POP_STR();
 
                 /*
-                 * Skip down over iterables left stacked by JSOP_FOR* until
-                 * we hit a block-local or the new Array initialiser (empty
-                 * destructuring patterns yield zero-count blocks).
+                 * Skip the for loop head stacked by JSOP_FORLOCAL until we hit
+                 * a block local slot (note empty destructuring patterns result
+                 * in unit-count blocks).
                  */
                 pos = ss->top;
-                while ((op = (JSOp) ss->opcodes[--pos]) != JSOP_ENTERBLOCK &&
-                       op != JSOP_NEWINIT) {
-                    if (pos == 0)
-                        break;
-                }
-
-                /*
-                 * Make forpos index the space before the left-most |for| in
-                 * the single string of accumulated |for| heads and optional
+                while (pos != 0) {
+                    op = (JSOp) ss->opcodes[--pos];
+                    if (op != JSOP_FORLOCAL)
+                        break;
+                }
+                JS_ASSERT(op == JSOP_ENTERBLOCK);
+
+                /*
+                 * Here, forpos must index the space before the left-most |for|
+                 * in the single string of accumulated |for| heads and optional
                  * final |if (condition)|.
                  */
-                forpos = pos + (op == JSOP_ENTERBLOCK || op == JSOP_NEWINIT);
+                forpos = pos + 1;
                 LOCAL_ASSERT(forpos < ss->top);
 
                 /*
-                 * Now skip down over the block's local slots, if any. There
-                 * may be no locals for an empty destructuring pattern.
+                 * Now move pos downward over the block's local slots. Even an
+                 * empty destructuring pattern has one (dummy) local.
                  */
                 while (ss->opcodes[pos] == JSOP_ENTERBLOCK) {
                     if (pos == 0)
                         break;
                     --pos;
                 }
+                JS_ASSERT_IF(saveop == JSOP_ARRAYPUSH,
+                             jp->script->nfixed + pos == GET_UINT16(pc));
 
 #if JS_HAS_GENERATOR_EXPRS
                 if (saveop == JSOP_YIELD) {
@@ -2939,8 +2943,7 @@
                 lval = OFF2STR(&ss->sprinter, start);
                 RETRACT(&ss->sprinter, lval);
 
-                todo = Sprint(&ss->sprinter, "%s%s%.*s",
-                              lval, rval, rval - xval, xval);
+                todo = Sprint(&ss->sprinter, sss_format, lval, rval, xval);
                 if (todo < 0)
                     return NULL;
                 ss->offsets[pos] = todo;
@@ -2966,12 +2969,70 @@
               case JSOP_GOTOX:
                 sn = js_GetSrcNote(jp->script, pc);
                 switch (sn ? SN_TYPE(sn) : SRC_NULL) {
+                  case SRC_FOR_IN:
+                    /*
+                     * The loop back-edge carries +1 stack balance, for the
+                     * flag processed by JSOP_IFNE. We do not decompile the
+                     * JSOP_IFNE, and instead pass the left-hand side of 'in'
+                     * along the loop edge in this pushed stack slot.
+                     */
+                    cond = GetJumpOffset(pc, pc);
+                    next = js_GetSrcNoteOffset(sn, 0);
+                    tail = js_GetSrcNoteOffset(sn, 1);
+                    DECOMPILE_CODE(pc + cond, tail - cond);
+                    DECOMPILE_CODE(pc + oplen, next - oplen);
+                    if (ss->inArrayInit || ss->inGenExp) {
+                        lval = POP_STR();
+                        rval = POP_STR();
+                        if (ss->opcodes[ss->top - 1] == JSOP_FORLOCAL) {
+                            ss->sprinter.offset -= PAREN_SLOP;
+                            if (Sprint(&ss->sprinter, " %s (%s in %s)",
+                                       foreach ? js_for_each_str : js_for_str,
+                                       lval, rval) < 0) {
+                                return NULL;
+                            }
+                            
+                            /*
+                             * Do not AddParentSlop here, as we will push the
+                             * top-most offset again, which will add paren slop
+                             * for us. We must push to balance the stack budget
+                             * when nesting for heads in a comprehension.
+                             */
+                            todo = ss->offsets[ss->top - 1];
+                        } else {
+                            LOCAL_ASSERT(ss->opcodes[ss->top - 1] == JSOP_ENTERBLOCK);
+                            todo = Sprint(&ss->sprinter, " %s (%s in %s)",
+                                          foreach ? js_for_each_str : js_for_str,
+                                          lval, rval);
+                        }
+                        if (todo < 0 || !PushOff(ss, todo, JSOP_FORLOCAL))
+                            return NULL;
+                        DECOMPILE_CODE(pc + next, cond - next);
+                    } else {
+                        /*
+                         * As above, rval or an extension of it must remain
+                         * stacked during loop body decompilation.
+                         */
+                        lval = POP_STR();
+                        rval = GetStr(ss, ss->top - 1);
+                        js_printf(jp, "\t%s (%s in %s) {\n",
+                                  foreach ? js_for_each_str : js_for_str,
+                                  lval, rval);
+                        jp->indent += 4;
+                        DECOMPILE_CODE(pc + next, cond - next);
+                        jp->indent -= 4;
+                        js_printf(jp, "\t}\n");
+                    }
+                    pc += tail;
+                    LOCAL_ASSERT(*pc == JSOP_IFNE || *pc == JSOP_IFNEX);
+                    len = js_CodeSpec[*pc].length;
+                    break;
+
                   case SRC_WHILE:
                     cond = GetJumpOffset(pc, pc);
                     tail = js_GetSrcNoteOffset(sn, 0);
                     DECOMPILE_CODE(pc + cond, tail - cond);
-                    rval = POP_STR();
-                    js_printf(jp, "\twhile (%s) {\n", rval);
+                    js_printf(jp, "\twhile (%s) {\n", POP_COND_STR());
                     jp->indent += 4;
                     DECOMPILE_CODE(pc + oplen, cond - oplen);
                     jp->indent -= 4;
@@ -3026,8 +3087,7 @@
                 switch (sn ? SN_TYPE(sn) : SRC_NULL) {
                   case SRC_IF:
                   case SRC_IF_ELSE:
-                    op = JSOP_NOP;              /* turn off parens */
-                    rval = POP_STR();
+                    rval = POP_COND_STR();
                     if (ss->inArrayInit || ss->inGenExp) {
                         LOCAL_ASSERT(SN_TYPE(sn) == SRC_IF);
                         ss->sprinter.offset -= PAREN_SLOP;
@@ -3158,31 +3218,34 @@
                 goto do_logical_connective;
 
               case JSOP_FORARG:
-                atom = GetArgOrVarAtom(jp, GET_ARGNO(pc));
-                LOCAL_ASSERT(atom);
-                goto do_fornameinloop;
+                sn = NULL;
+                i = GET_ARGNO(pc);
+                goto do_forvarslot;
 
               case JSOP_FORCONST:
               case JSOP_FORLOCAL:
-                if (IsVarSlot(jp, pc, &i)) {
-                    atom = GetArgOrVarAtom(jp, i);
-                    LOCAL_ASSERT(atom);
-                    goto do_fornameinloop;
-                }
-                JS_ASSERT(op == JSOP_FORLOCAL);
-                lval = GetStr(ss, i);
-                atom = NULL;
-                goto do_forlvalinloop;
+                sn = js_GetSrcNote(jp->script, pc);
+                if (!IsVarSlot(jp, pc, &i)) {
+                    JS_ASSERT(op == JSOP_FORLOCAL);
+                    todo = Sprint(&ss->sprinter, ss_format, VarPrefix(sn), GetStr(ss, i));
+                    break;
+                }
+
+              do_forvarslot:
+                atom = GetArgOrVarAtom(jp, i);
+                LOCAL_ASSERT(atom);
+                todo = SprintCString(&ss->sprinter, VarPrefix(sn));
+                if (todo < 0 || !QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0))
+                    return NULL;
+                break;
 
               case JSOP_FORNAME:
                 LOAD_ATOM(0);
-
-              do_fornameinloop:
-                lval = "";
-              do_forlvalinloop:
-                sn = js_GetSrcNote(jp->script, pc);
-                xval = NULL;
-                goto do_forinloop;
+                sn = js_GetSrcNote(jp->script, pc);
+                todo = SprintCString(&ss->sprinter, VarPrefix(sn));
+                if (todo < 0 || !QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0))
+                    return NULL;
+                break;
 
               case JSOP_FORPROP:
                 xval = NULL;
@@ -3192,124 +3255,22 @@
                                        (jschar)'\'');
                     if (!xval)
                         return NULL;
-                    atom = NULL;
-                }
-                lval = POP_STR();
-                sn = NULL;
-
-              do_forinloop:
-                pc += oplen;
-                LOCAL_ASSERT(*pc == JSOP_IFEQ || *pc == JSOP_IFEQX);
-                oplen = js_CodeSpec[*pc].length;
-                len = GetJumpOffset(pc, pc);
-                sn2 = js_GetSrcNote(jp->script, pc);
-                tail = js_GetSrcNoteOffset(sn2, 0);
-
-              do_forinhead:
-                if (!atom && xval) {
-                    /*
-                     * If xval is not a dummy empty string, we have to strdup
-                     * it to save it from being clobbered by the first Sprint
-                     * below.  Standard dumb decompiler operating procedure!
-                     */
-                    if (*xval == '\0') {
-                        xval = NULL;
-                    } else {
-                        xval = JS_strdup(cx, xval);
-                        if (!xval)
-                            return NULL;
-                    }
-                }
-
-#if JS_HAS_XML_SUPPORT
-                if (foreach) {
-                    foreach = JS_FALSE;
-                    todo = Sprint(&ss->sprinter, "for %s (%s%s",
-                                  js_each_str, VarPrefix(sn), lval);
-                } else
-#endif
-                {
-                    todo = Sprint(&ss->sprinter, "for (%s%s",
-                                  VarPrefix(sn), lval);
-                }
-                if (atom) {
-                    if (*lval && SprintPut(&ss->sprinter, ".", 1) < 0)
-                        return NULL;
-                    xval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0);
-                    if (!xval)
-                        return NULL;
-                } else if (xval) {
-                    LOCAL_ASSERT(*xval != '\0');
-                    ok = (Sprint(&ss->sprinter,
-                                 (JOF_OPMODE(lastop) == JOF_XMLNAME)
-                                 ? ".%s"
-                                 : "[%s]",
-                                 xval)
-                          >= 0);
-                    JS_free(cx, (char *)xval);
-                    if (!ok)
-                        return NULL;
-                }
-                if (todo < 0)
-                    return NULL;
-
-                lval = OFF2STR(&ss->sprinter, todo);
-                rval = GetStr(ss, ss->top-1);
-                RETRACT(&ss->sprinter, rval);
-                if (ss->inArrayInit || ss->inGenExp) {
-                    if (ss->top > 1 &&
-                        (js_CodeSpec[ss->opcodes[ss->top-2]].format &
-                         JOF_FOR)) {
-                        ss->sprinter.offset -= PAREN_SLOP;
-                    }
-                    todo = Sprint(&ss->sprinter, " %s in %s)", lval, rval);
+                }
+                lval = POP_STR();
+                if (xval) {
+                    JS_ASSERT(*lval);
+                    todo = Sprint(&ss->sprinter, index_format, lval, xval);
+                } else {
+                    todo = Sprint(&ss->sprinter, ss_format, lval, *lval ? "." : "");
                     if (todo < 0)
                         return NULL;
-                    ss->offsets[ss->top-1] = todo;
-                    ss->opcodes[ss->top-1] = op;
-                    AddParenSlop(ss);
-                    DECOMPILE_CODE(pc + oplen, tail - oplen);
-                } else {
-                    js_printf(jp, "\t%s in %s) {\n", lval, rval);
-                    jp->indent += 4;
-                    DECOMPILE_CODE(pc + oplen, tail - oplen);
-                    jp->indent -= 4;
-                    js_printf(jp, "\t}\n");
-                }
-                todo = -2;
+                    if (!QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0))
+                        return NULL;
+                }
                 break;
 
               case JSOP_FORELEM:
-                pc++;
-                LOCAL_ASSERT(*pc == JSOP_IFEQ || *pc == JSOP_IFEQX);
-                len = js_CodeSpec[*pc].length;
-
-                /*
-                 * Arrange for the JSOP_ENUMELEM case to set tail for use by
-                 * do_forinhead: code that uses on it to find the loop-closing
-                 * jump (whatever its format, normal or extended), in order to
-                 * bound the recursively decompiled loop body.
-                 */
-                sn = js_GetSrcNote(jp->script, pc);
-                LOCAL_ASSERT(!forelem_tail);
-                forelem_tail = pc + js_GetSrcNoteOffset(sn, 0);
-
-                /*
-                 * This gets a little wacky.  Only the length of the for loop
-                 * body PLUS the element-indexing expression is known here, so
-                 * we pass the after-loop pc to the JSOP_ENUMELEM case, which
-                 * is immediately below, to decompile that helper bytecode via
-                 * the 'forelem_done' local.
-                 *
-                 * Since a for..in loop can't nest in the head of another for
-                 * loop, we can use forelem_{tail,done} singletons to remember
-                 * state from JSOP_FORELEM to JSOP_ENUMELEM, thence (via goto)
-                 * to label do_forinhead.
-                 */
-                LOCAL_ASSERT(!forelem_done);
-                forelem_done = pc + GetJumpOffset(pc, pc);
-
-                /* Our net stack balance after forelem;ifeq is +1. */
+                LOCAL_ASSERT(pc[1] == JSOP_IFNE || pc[1] == JSOP_IFNEX);
                 todo = SprintCString(&ss->sprinter, forelem_cookie);
                 break;
 
@@ -3330,13 +3291,16 @@
                 op = saveop;
                 rval = POP_STR();
                 LOCAL_ASSERT(strcmp(rval, forelem_cookie) == 0);
-                LOCAL_ASSERT(forelem_tail > pc);
-                tail = forelem_tail - pc;
-                forelem_tail = NULL;
-                LOCAL_ASSERT(forelem_done > pc);
-                len = forelem_done - pc;
-                forelem_done = NULL;
-                goto do_forinhead;
+                if (*xval == '\0') {
+                    todo = SprintCString(&ss->sprinter, lval);
+                } else {
+                    todo = Sprint(&ss->sprinter,
+                                  (JOF_OPMODE(lastop) == JOF_XMLNAME)
+                                  ? dot_format
+                                  : index_format,
+                                  lval, xval);
+                }
+                break;
 
 #if JS_HAS_GETTER_SETTER
               case JSOP_GETTER:
@@ -3368,27 +3332,16 @@
                     rval = POP_STR();
 
                     if (strcmp(rval, forelem_cookie) == 0) {
-                        LOCAL_ASSERT(forelem_tail > pc);
-                        tail = forelem_tail - pc;
-                        forelem_tail = NULL;
-                        LOCAL_ASSERT(forelem_done > pc);
-                        len = forelem_done - pc;
-                        forelem_done = NULL;
-                        xval = NULL;
-                        atom = NULL;
-
-                        /*
-                         * Null sn if this is a 'for (var [k, v] = i in o)'
-                         * loop, because 'var [k, v = i;' has already been
-                         * hoisted.
-                         */
-                        if (js_GetSrcNoteOffset(sn, 0) == SRC_DECL_VAR)
-                            sn = NULL;
-                        goto do_forinhead;
-                    }
-
-                    todo = Sprint(&ss->sprinter, "%s%s = %s",
-                                  VarPrefix(sn), lval, rval);
+                        todo = Sprint(&ss->sprinter, ss_format,
+                                      VarPrefix(sn), lval);
+
+                        // Skip POP so the SRC_FOR_IN code can pop for itself.
+                        if (*pc == JSOP_POP)
+                            len = JSOP_POP_LENGTH;
+                    } else {
+                        todo = Sprint(&ss->sprinter, "%s%s = %s",
+                                      VarPrefix(sn), lval, rval);
+                    }
                     break;
                 }
 #endif
@@ -3470,6 +3423,7 @@
                 /*
                  * Special case: new (x(y)(z)) must be parenthesized like so.
                  * Same for new (x(y).z) -- contrast with new x(y).z.
+                 * See PROPAGATE_CALLNESS.
                  */
                 op = (JSOp) ss->opcodes[ss->top-1];
                 lval = PopStr(ss,
@@ -3522,8 +3476,6 @@
                     todo = Sprint(&ss->sprinter, "");
                 }
 #endif
-                LOCAL_ASSERT(pc[len] == JSOP_RESUME);
-                len += JSOP_RESUME_LENGTH;
                 break;
 
               case JSOP_DELNAME:
@@ -3538,6 +3490,7 @@
 
               case JSOP_DELPROP:
                 GET_ATOM_QUOTE_AND_FMT("%s %s[%s]", "%s %s.%s", rval);
+                op = JSOP_GETPROP;
                 lval = POP_STR();
                 todo = Sprint(&ss->sprinter, fmt, js_delete_str, lval, rval);
                 break;
@@ -3545,7 +3498,7 @@
               case JSOP_DELELEM:
                 op = JSOP_NOP;          /* turn off parens */
                 xval = POP_STR();
-                op = saveop;
+                op = JSOP_GETPROP;
                 lval = POP_STR();
                 if (*xval == '\0')
                     goto do_delete_lval;
@@ -3559,6 +3512,7 @@
 #if JS_HAS_XML_SUPPORT
               case JSOP_DELDESC:
                 xval = POP_STR();
+                op = JSOP_GETPROP;
                 lval = POP_STR();
                 todo = Sprint(&ss->sprinter, "%s %s..%s",
                               js_delete_str, lval, xval);
@@ -3703,6 +3657,7 @@
               do_getprop:
                 GET_QUOTE_AND_FMT(index_format, dot_format, rval);
               do_getprop_lval:
+                PROPAGATE_CALLNESS();
                 lval = POP_STR();
                 todo = Sprint(&ss->sprinter, fmt, lval, rval);
                 break;
@@ -3776,6 +3731,7 @@
                 op = JSOP_NOP;          /* turn off parens */
                 xval = POP_STR();
                 op = saveop;
+                PROPAGATE_CALLNESS();
                 lval = POP_STR();
                 if (*xval == '\0') {
                     todo = Sprint(&ss->sprinter, "%s", lval);
@@ -3855,7 +3811,7 @@
                 if (!rval)
                     return NULL;
                 RETRACT(&ss->sprinter, rval);
-                todo = Sprint(&ss->sprinter, "%s%s%s",
+                todo = Sprint(&ss->sprinter, sss_format,
                               VarPrefix(sn), lval, rval);
                 break;
 
@@ -3925,8 +3881,7 @@
                     outer = jp->script;
                     LOCAL_ASSERT(JS_UPTRDIFF(pc, outer->code) <= outer->length);
                     jp->script = inner;
-                    if (!Decompile(&ss2, inner->code, inner->length,
-                                   JSOP_NOP)) {
+                    if (!Decompile(&ss2, inner->code, inner->length, JSOP_NOP)) {
                         JS_ARENA_RELEASE(&cx->tempPool, mark);
                         return NULL;
                     }
@@ -3942,10 +3897,6 @@
                     LOCAL_ASSERT(*pc == JSOP_CALL);
                     LOCAL_ASSERT(GET_ARGC(pc) == 0);
                     len = JSOP_CALL_LENGTH;
-
-                    /* Skip over the waiting JSOP_RESUME. */
-                    LOCAL_ASSERT(pc[len] == JSOP_RESUME);
-                    len += JSOP_RESUME_LENGTH;
 
                     /*
                      * Arrange to parenthesize this genexp unless:
@@ -4246,14 +4197,6 @@
                 break;
               }
 
-              case JSOP_STRICTEQ:
-              case JSOP_STRICTNE:
-                rval = POP_STR();
-                lval = POP_STR();
-                todo = Sprint(&ss->sprinter, "%s %c== %s",
-                              lval, (op == JSOP_STRICTEQ) ? '=' : '!', rval);
-                break;
-
               case JSOP_DEFFUN:
                 LOAD_FUNCTION(0);
                 todo = -2;
@@ -4398,7 +4341,7 @@
                     goto do_initprop;
                 }
                 maybeComma = isFirst ? "" : ", ";
-                todo = Sprint(&ss->sprinter, "%s%s%s",
+                todo = Sprint(&ss->sprinter, sss_format,
                               lval,
                               maybeComma,
                               rval);
@@ -4610,12 +4553,14 @@
 
               case JSOP_ENDFILTER:
                 rval = POP_STR();
+                PROPAGATE_CALLNESS();
                 lval = POP_STR();
                 todo = Sprint(&ss->sprinter, "%s.(%s)", lval, rval);
                 break;
 
               case JSOP_DESCENDANTS:
                 rval = POP_STR();
+                PROPAGATE_CALLNESS();
                 lval = POP_STR();
                 todo = Sprint(&ss->sprinter, "%s..%s", lval, rval);
                 break;
diff -r 17e9560465b0 js/src/jsopcode.h
--- a/js/src/jsopcode.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/jsopcode.h	Thu Oct 30 05:41:45 2008 -0400
@@ -117,6 +117,8 @@
                                      besides the slots opcode uses */
 #define JOF_TMPSLOT_SHIFT 22
 #define JOF_TMPSLOT_MASK  (JS_BITMASK(2) << JOF_TMPSLOT_SHIFT)
+
+#define JOF_RETVAL       (1U<<24) /* op leaves jsval return value on stack */
 
 /* Shorthands for type from format and type from opcode. */
 #define JOF_TYPE(fmt)   ((fmt) & JOF_TYPEMASK)
diff -r 17e9560465b0 js/src/jsopcode.tbl
--- a/js/src/jsopcode.tbl	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/jsopcode.tbl	Thu Oct 30 05:41:45 2008 -0400
@@ -66,7 +66,7 @@
  * Precedence   Operators               Opcodes
  *  1           let (x = y) z, yield w  JSOP_LEAVEBLOCKEXPR, JSOP_YIELD
  *  2           ,                       JSOP_POP with SRC_PCDELTA, JSOP_RETURN
- *  3           =, +=, etc.             JSOP_SETNAME, etc. (all JOF_ASSIGNING)
+ *  3           =, +=, etc.             JSOP_SETNAME, etc. (all JOF_SET)
  *  4           ?:                      JSOP_IFEQ, JSOP_IFEQX
  *  5           ||                      JSOP_OR, JSOP_ORX
  *  6           &&                      JSOP_AND, JSOP_ANDX
@@ -78,9 +78,9 @@
  * 12           <<, >>, >>>             JSOP_LSH, JSOP_RSH, JSOP_URSH
  * 13           +, -, etc.              JSOP_ADD, JSOP_SUB, etc.
  * 14           *, /, %                 JSOP_MUL, JSOP_DIV, JSOP_MOD
- * 15           !, ~, etc.              JSOP_NOT, JSOP_BITNOT, etc.
+ * 15           !, ~, delete, etc.      JSOP_NOT, JSOP_BITNOT, JSOP_DEL*, etc.
  * 16           3.14, 0, etc.           JSOP_DOUBLE, JSOP_ZERO, etc.
- * 17           delete, new             JSOP_DEL*, JSOP_NEW
+ * 17           new                     JSOP_NEW
  * 18           x.y, f(), etc.          JSOP_GETPROP, JSOP_CALL, etc.
  * 19           x, null, etc.           JSOP_NAME, JSOP_NULL, etc.
  *
@@ -139,9 +139,9 @@
 OPDEF(JSOP_BITNOT,    33, "bitnot",     "~",          1,  1,  1, 15,  JOF_BYTE)
 OPDEF(JSOP_NEG,       34, "neg",        "- ",         1,  1,  1, 15,  JOF_BYTE)
 OPDEF(JSOP_NEW,       35, js_new_str,   NULL,         3, -1,  1, 17,  JOF_UINT16|JOF_INVOKE)
-OPDEF(JSOP_DELNAME,   36, "delname",    NULL,         3,  0,  1, 17,  JOF_ATOM|JOF_NAME|JOF_DEL)
-OPDEF(JSOP_DELPROP,   37, "delprop",    NULL,         3,  1,  1, 17,  JOF_ATOM|JOF_PROP|JOF_DEL)
-OPDEF(JSOP_DELELEM,   38, "delelem",    NULL,         1,  2,  1, 17,  JOF_BYTE |JOF_ELEM|JOF_DEL)
+OPDEF(JSOP_DELNAME,   36, "delname",    NULL,         3,  0,  1, 15,  JOF_ATOM|JOF_NAME|JOF_DEL)
+OPDEF(JSOP_DELPROP,   37, "delprop",    NULL,         3,  1,  1, 15,  JOF_ATOM|JOF_PROP|JOF_DEL)
+OPDEF(JSOP_DELELEM,   38, "delelem",    NULL,         1,  2,  1, 15,  JOF_BYTE |JOF_ELEM|JOF_DEL)
 OPDEF(JSOP_TYPEOF,    39, js_typeof_str,NULL,         1,  1,  1, 15,  JOF_BYTE|JOF_DETECTING)
 OPDEF(JSOP_VOID,      40, js_void_str,  NULL,         1,  1,  1, 15,  JOF_BYTE)
 
@@ -163,7 +163,7 @@
 OPDEF(JSOP_GETELEM,   55, "getelem",    NULL,         1,  2,  1, 18,  JOF_BYTE |JOF_ELEM|JOF_LEFTASSOC)
 OPDEF(JSOP_SETELEM,   56, "setelem",    NULL,         1,  3,  1,  3,  JOF_BYTE |JOF_ELEM|JOF_SET|JOF_DETECTING)
 OPDEF(JSOP_CALLNAME,  57, "callname",   NULL,         3,  0,  2, 19,  JOF_ATOM|JOF_NAME|JOF_CALLOP)
-OPDEF(JSOP_CALL,      58, "call",       NULL,         3, -1,  1, 18,  JOF_UINT16|JOF_INVOKE)
+OPDEF(JSOP_CALL,      58, "call",       NULL,         3, -1,  1, 18,  JOF_UINT16|JOF_INVOKE|JOF_RETVAL)
 OPDEF(JSOP_NAME,      59, "name",       NULL,         3,  0,  1, 19,  JOF_ATOM|JOF_NAME)
 OPDEF(JSOP_DOUBLE,    60, "double",     NULL,         3,  0,  1, 16,  JOF_ATOM)
 OPDEF(JSOP_STRING,    61, "string",     NULL,         3,  0,  1, 19,  JOF_ATOM)
@@ -181,11 +181,10 @@
 OPDEF(JSOP_LOOKUPSWITCH, 71, "lookupswitch", NULL,   -1,  1,  0,  0,  JOF_LOOKUPSWITCH|JOF_DETECTING|JOF_PARENHEAD)
 
 /* New, infallible/transitive identity ops. */
-OPDEF(JSOP_STRICTEQ,  72, "stricteq",   NULL,         1,  2,  1,  10,  JOF_BYTE|JOF_DETECTING)
-OPDEF(JSOP_STRICTNE,  73, "strictne",   NULL,         1,  2,  1,  10,  JOF_BYTE|JOF_DETECTING)
+OPDEF(JSOP_STRICTEQ,  72, "stricteq",   "===",        1,  2,  1, 10,  JOF_BYTE|JOF_DETECTING|JOF_LEFTASSOC)
+OPDEF(JSOP_STRICTNE,  73, "strictne",   "!==",        1,  2,  1, 10,  JOF_BYTE|JOF_DETECTING|JOF_LEFTASSOC)
 
-/* Resume instruction (emitted for the JIT for instructions that can't be restarted). */
-OPDEF(JSOP_RESUME,    74, "resume",     NULL,         1,  0,  0,  0,  JOF_BYTE)
+OPDEF(JSOP_UNUSED74,  74, "unused74",   NULL,         1,  0,  0,  0,  JOF_BYTE)
 
 /* Variant of JSOP_NULL for default (global) |this| parameter pushing. */
 OPDEF(JSOP_NULLTHIS,  75, js_null_str,  js_null_str,  1,  0,  1, 19,  JOF_BYTE)
@@ -318,7 +317,7 @@
 OPDEF(JSOP_SETLOCALPOP, 130, "setlocalpop", NULL,     3,  1,  0,  3,  JOF_LOCAL|JOF_NAME|JOF_SET)
 
 /* Parenthesization opcode to help the decompiler. */
-OPDEF(JSOP_GROUP,       131, "group",       NULL,     1,  0,  0, 19,  JOF_BYTE)
+OPDEF(JSOP_UNUSED131,   131, "unused131",   NULL,     1,  0,  0,  0,  JOF_BYTE)
 
 /*
  * Host object extension: given 'o.item(i) = j', the left-hand side compiles
@@ -419,7 +418,7 @@
  */
 OPDEF(JSOP_GETUPVAR,      186,"getupvar",   NULL,     3,  0,  1, 19,  JOF_UINT16|JOF_NAME)
 
-OPDEF(JSOP_DELDESC,       187,"deldesc",    NULL,     1,  2,  1, 17,  JOF_BYTE |JOF_ELEM|JOF_DEL)
+OPDEF(JSOP_DELDESC,       187,"deldesc",    NULL,     1,  2,  1, 15,  JOF_BYTE|JOF_ELEM|JOF_DEL)
 
 /*
  * Opcode to hold 24-bit immediate integer operands.
diff -r 17e9560465b0 js/src/jsparse.cpp
--- a/js/src/jsparse.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/jsparse.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -1663,45 +1663,6 @@
     return JS_TRUE;
 }
 
-#if JS_HAS_DESTRUCTURING
-
-static JSBool
-BindDestructuringVar(JSContext *cx, BindData *data, JSParseNode *pn,
-                     JSTreeContext *tc)
-{
-    JSAtom *atom;
-
-    /*
-     * Destructuring is a form of assignment, so just as for an initialized
-     * simple variable, we must check for assignment to 'arguments' and flag
-     * the enclosing function (if any) as heavyweight.
-     */
-    JS_ASSERT(pn->pn_type == TOK_NAME);
-    atom = pn->pn_atom;
-    if (atom == cx->runtime->atomState.argumentsAtom)
-        tc->flags |= TCF_FUN_HEAVYWEIGHT;
-
-    data->pn = pn;
-    if (!data->binder(cx, data, atom, tc))
-        return JS_FALSE;
-    data->pn = NULL;
-
-    /*
-     * Select the appropriate name-setting opcode, which may be specialized
-     * further for local variable and argument slot optimizations.  At this
-     * point, we can't select the optimal final opcode, yet we must preserve
-     * the CONST bit and convey "set", not "get".
-     */
-    if (data->op == JSOP_DEFCONST) {
-        pn->pn_op = JSOP_SETCONST;
-        pn->pn_const = JS_TRUE;
-    } else {
-        pn->pn_op = JSOP_SETNAME;
-        pn->pn_const = JS_FALSE;
-    }
-    return JS_TRUE;
-}
-
 static JSBool
 MakeSetCall(JSContext *cx, JSParseNode *pn, JSTreeContext *tc, uintN msg)
 {
@@ -1716,6 +1677,45 @@
         return JS_FALSE;
     }
     pn->pn_op = JSOP_SETCALL;
+    return JS_TRUE;
+}
+
+#if JS_HAS_DESTRUCTURING
+
+static JSBool
+BindDestructuringVar(JSContext *cx, BindData *data, JSParseNode *pn,
+                     JSTreeContext *tc)
+{
+    JSAtom *atom;
+
+    /*
+     * Destructuring is a form of assignment, so just as for an initialized
+     * simple variable, we must check for assignment to 'arguments' and flag
+     * the enclosing function (if any) as heavyweight.
+     */
+    JS_ASSERT(pn->pn_type == TOK_NAME);
+    atom = pn->pn_atom;
+    if (atom == cx->runtime->atomState.argumentsAtom)
+        tc->flags |= TCF_FUN_HEAVYWEIGHT;
+
+    data->pn = pn;
+    if (!data->binder(cx, data, atom, tc))
+        return JS_FALSE;
+    data->pn = NULL;
+
+    /*
+     * Select the appropriate name-setting opcode, which may be specialized
+     * further for local variable and argument slot optimizations.  At this
+     * point, we can't select the optimal final opcode, yet we must preserve
+     * the CONST bit and convey "set", not "get".
+     */
+    if (data->op == JSOP_DEFCONST) {
+        pn->pn_op = JSOP_SETCONST;
+        pn->pn_const = JS_TRUE;
+    } else {
+        pn->pn_op = JSOP_SETNAME;
+        pn->pn_const = JS_FALSE;
+    }
     return JS_TRUE;
 }
 
@@ -2885,22 +2885,6 @@
                 pn2 = Expr(cx, ts, tc);
                 if (!pn2)
                     return NULL;
-
-                if (pn2->pn_type == TOK_LP &&
-                    pn2->pn_head->pn_type == TOK_FUNCTION &&
-                    (pn2->pn_head->pn_flags & TCF_GENEXP_LAMBDA)) {
-                    /*
-                     * A generator expression as loop condition is useless.
-                     * It won't be called, and as an object it evaluates to
-                     * true in boolean contexts without any conversion hook
-                     * being called.
-                     *
-                     * This useless condition elimination is mandatory, to
-                     * help the decompiler. See bug 442342.
-                     */
-                    RecycleTree(pn2, tc);
-                    pn2 = NULL;
-                }
             }
 
             /* Parse the update expression or null into pn3. */
@@ -2916,11 +2900,11 @@
                     return NULL;
             }
 
-            /* Build the RESERVED node to use as the left kid of pn. */
+            /* Build the FORHEAD node to use as the left kid of pn. */
             pn4 = NewParseNode(cx, ts, PN_TERNARY, tc);
             if (!pn4)
                 return NULL;
-            pn4->pn_type = TOK_RESERVED;
+            pn4->pn_type = TOK_FORHEAD;
             pn4->pn_op = JSOP_NOP;
             pn4->pn_kid1 = pn1;
             pn4->pn_kid2 = pn2;
@@ -4532,7 +4516,7 @@
                 } else if (tt == TOK_RP) {
                     JSParseNode *group = pn3;
 
-                    /* Recycle the useless TOK_RP/JSOP_GROUP node. */
+                    /* Recycle the useless TOK_RP node. */
                     pn3 = group->pn_kid;
                     group->pn_kid = NULL;
                     RecycleTree(group, tc);
@@ -4619,6 +4603,7 @@
                         break;
                     }
                     pn3->pn_type = TOK_NUMBER;
+                    pn3->pn_op = JSOP_DOUBLE;
                     pn3->pn_dval = index;
                 }
                 pn2->pn_op = JSOP_GETELEM;
@@ -5393,6 +5378,7 @@
         if (!pn)
             return NULL;
         pn->pn_type = TOK_RB;
+        pn->pn_op = JSOP_NEWINIT;
 
 #if JS_HAS_SHARP_VARS
         if (defsharp) {
@@ -5526,6 +5512,7 @@
         if (!pn)
             return NULL;
         pn->pn_type = TOK_RC;
+        pn->pn_op = JSOP_NEWINIT;
 
 #if JS_HAS_SHARP_VARS
         if (defsharp) {
@@ -5855,6 +5842,7 @@
         pn = NewParseNode(cx, ts, PN_NULLARY, tc);
         if (!pn)
             return NULL;
+        pn->pn_op = JSOP_DOUBLE;
         pn->pn_dval = CURRENT_TOKEN(ts).t_dval;
 #if JS_HAS_SHARP_VARS
         notsharp = JS_TRUE;
@@ -6286,8 +6274,53 @@
 #undef TAIL_RECURSE
 }
 
+static int
+Boolish(JSParseNode *pn)
+{
+    switch (pn->pn_op) {
+      case JSOP_DOUBLE:
+        return pn->pn_dval != 0 && !JSDOUBLE_IS_NaN(pn->pn_dval);
+
+      case JSOP_STRING:
+        return JSSTRING_LENGTH(ATOM_TO_STRING(pn->pn_atom)) != 0;
+
+#if JS_HAS_GENERATOR_EXPRS
+      case JSOP_CALL:
+      {
+        /*
+         * A generator expression as an if or loop condition has no effects, it
+         * simply results in a truthy object reference. This condition folding
+         * is needed for the decompiler. See bug 442342 and bug 443074.
+         */
+        if (pn->pn_count != 1)
+            break;
+        JSParseNode *pn2 = pn->pn_head;
+        if (pn2->pn_type != TOK_FUNCTION)
+            break;
+        if (!(pn2->pn_flags & TCF_GENEXP_LAMBDA))
+            break;
+        /* FALL THROUGH */
+      }
+#endif
+
+      case JSOP_DEFFUN:
+      case JSOP_NAMEDFUNOBJ:
+      case JSOP_ANONFUNOBJ:
+      case JSOP_THIS:
+      case JSOP_TRUE:
+        return 1;
+
+      case JSOP_NULL:
+      case JSOP_FALSE:
+        return 0;
+
+      default:;
+    }
+    return -1;
+}
+
 JSBool
-js_FoldConstants(JSContext *cx, JSParseNode *pn, JSTreeContext *tc)
+js_FoldConstants(JSContext *cx, JSParseNode *pn, JSTreeContext *tc, bool inCond)
 {
     JSParseNode *pn1 = NULL, *pn2 = NULL, *pn3 = NULL;
 
@@ -6306,50 +6339,6 @@
       }
 
       case PN_LIST:
-#if 0 /* JS_HAS_XML_SUPPORT */
-        switch (pn->pn_type) {
-          case TOK_XMLELEM:
-          case TOK_XMLLIST:
-          case TOK_XMLPTAGC:
-            /*
-             * Try to fold this XML parse tree once, from the top down, into
-             * a JSXML tree with just one object wrapping the tree root.
-             *
-             * Certain subtrees could be folded similarly, but we'd have to
-             * ensure that none used namespace prefixes declared elsewhere in
-             * its super-tree, and we would have to convert each XML object
-             * created at runtime for such sub-trees back into a string, and
-             * concatenate and re-parse anyway.
-             */
-            if ((pn->pn_extra & (PNX_XMLROOT | PNX_CANTFOLD)) == PNX_XMLROOT &&
-                !(tc->flags & TCF_HAS_DEFXMLNS)) {
-                JSObject *obj;
-                JSParsedObjectBox *xmlpob;
-
-                obj = js_ParseNodeToXMLObject(cx, pn);
-                if (!obj)
-                    return JS_FALSE;
-                xmlpob = js_NewParsedObjectBox(cx, ts, obj);
-                if (!xmlpob)
-                    return JS_FALSE;
-                pn->pn_op = JSOP_XMLOBJECT;
-                pn->pn_arity = PN_NULLARY;
-                pn->pn_pob = xmlpob;
-                return JS_TRUE;
-            }
-
-            /*
-             * Can't fold from parse node to XML tree -- try folding strings
-             * as much as possible, and folding XML sub-trees bottom up to
-             * minimize string concatenation and ToXML/ToXMLList operations
-             * at runtime.
-             */
-            break;
-
-          default:;
-        }
-#endif
-
         /* Save the list head in pn1 for later use. */
         for (pn1 = pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
             if (!js_FoldConstants(cx, pn2, tc))
@@ -6362,29 +6351,49 @@
         pn1 = pn->pn_kid1;
         pn2 = pn->pn_kid2;
         pn3 = pn->pn_kid3;
-        if (pn1 && !js_FoldConstants(cx, pn1, tc))
-            return JS_FALSE;
-        if (pn2 && !js_FoldConstants(cx, pn2, tc))
-            return JS_FALSE;
+        if (pn1 && !js_FoldConstants(cx, pn1, tc, pn->pn_type == TOK_IF))
+            return JS_FALSE;
+        if (pn2) {
+            if (!js_FoldConstants(cx, pn2, tc, pn->pn_type == TOK_FORHEAD))
+                return JS_FALSE;
+            if (pn->pn_type == TOK_FORHEAD && pn2->pn_op == JSOP_TRUE) {
+                RecycleTree(pn2, tc);
+                pn->pn_kid2 = NULL;
+            }
+        }
         if (pn3 && !js_FoldConstants(cx, pn3, tc))
             return JS_FALSE;
         break;
 
       case PN_BINARY:
-        /* First kid may be null (for default case in switch). */
         pn1 = pn->pn_left;
         pn2 = pn->pn_right;
-        if (pn1 && !js_FoldConstants(cx, pn1, tc))
-            return JS_FALSE;
-        if (!js_FoldConstants(cx, pn2, tc))
+
+        /* Propagate inCond through logical connectives. */
+        if (pn->pn_type == TOK_OR || pn->pn_type == TOK_AND) {
+            if (!js_FoldConstants(cx, pn1, tc, inCond))
+                return JS_FALSE;
+            if (!js_FoldConstants(cx, pn2, tc, inCond))
+                return JS_FALSE;
+            break;
+        }
+
+        /* First kid may be null (for default case in switch). */
+        if (pn1 && !js_FoldConstants(cx, pn1, tc, pn->pn_type == TOK_WHILE))
+            return JS_FALSE;
+        if (!js_FoldConstants(cx, pn2, tc, pn->pn_type == TOK_DO))
             return JS_FALSE;
         break;
 
       case PN_UNARY:
         /* Our kid may be null (e.g. return; vs. return e;). */
         pn1 = pn->pn_kid;
-        if (pn1 && !js_FoldConstants(cx, pn1, tc))
-            return JS_FALSE;
+        if (pn1 &&
+            !js_FoldConstants(cx, pn1, tc,
+                              (inCond && pn->pn_type == TOK_RP) ||
+                              pn->pn_op == JSOP_NOT)) {
+            return JS_FALSE;
+        }
         break;
 
       case PN_NAME:
@@ -6475,6 +6484,62 @@
         RecycleTree(pn2, tc);
         if (pn3 && pn3 != pn2)
             RecycleTree(pn3, tc);
+        break;
+
+      case TOK_OR:
+      case TOK_AND:
+        if (inCond) {
+            if (pn->pn_arity == PN_LIST) {
+                JSParseNode **pnp = &pn->pn_head;
+                JS_ASSERT(*pnp == pn1);
+                do {
+                    int cond = Boolish(pn1);
+                    if (cond == (pn->pn_type == TOK_OR)) {
+                        for (pn2 = pn1->pn_next; pn2; pn2 = pn3) {
+                            pn3 = pn2->pn_next;
+                            RecycleTree(pn2, tc);
+                            --pn->pn_count;
+                        }
+                        pn1->pn_next = NULL;
+                        break;
+                    }
+                    if (cond != -1) {
+                        JS_ASSERT(cond == (pn->pn_type == TOK_AND));
+                        if (pn->pn_count == 1)
+                            break;
+                        *pnp = pn1->pn_next;
+                        RecycleTree(pn1, tc);
+                        --pn->pn_count;
+                    } else {
+                        pnp = &pn1->pn_next;
+                    }
+                } while ((pn1 = *pnp) != NULL);
+
+                // We may have to change arity from LIST to BINARY.
+                pn1 = pn->pn_head;
+                if (pn->pn_count == 2) {
+                    pn2 = pn1->pn_next;
+                    pn1->pn_next = NULL;
+                    JS_ASSERT(!pn2->pn_next);
+                    pn->pn_arity = PN_BINARY;
+                    pn->pn_left = pn1;
+                    pn->pn_right = pn2;
+                } else if (pn->pn_count == 1) {
+                    PN_MOVE_NODE(pn, pn1);
+                    RecycleTree(pn1, tc);
+                }
+            } else {
+                int cond = Boolish(pn1);
+                if (cond == (pn->pn_type == TOK_OR)) {
+                    RecycleTree(pn2, tc);
+                    PN_MOVE_NODE(pn, pn1);
+                } else if (cond != -1) {
+                    JS_ASSERT(cond == (pn->pn_type == TOK_AND));
+                    RecycleTree(pn1, tc);
+                    PN_MOVE_NODE(pn, pn2);
+                }
+            }
+        }
         break;
 
       case TOK_ASSIGN:
@@ -6663,6 +6728,14 @@
             pn->pn_arity = PN_NULLARY;
             pn->pn_dval = d;
             RecycleTree(pn1, tc);
+        } else if (pn1->pn_type == TOK_PRIMARY) {
+            if (pn->pn_op == JSOP_NOT &&
+                (pn1->pn_op == JSOP_TRUE ||
+                 pn1->pn_op == JSOP_FALSE)) {
+                PN_MOVE_NODE(pn, pn1);
+                pn->pn_op = (pn->pn_op == JSOP_TRUE) ? JSOP_FALSE : JSOP_TRUE;
+                RecycleTree(pn1, tc);
+            }
         }
         break;
 
@@ -6707,5 +6780,21 @@
       default:;
     }
 
-    return JS_TRUE;
-}
+    if (inCond) {
+        int cond = Boolish(pn);
+        if (cond >= 0) {
+            if (pn->pn_arity == PN_LIST) {
+                pn2 = pn->pn_head;
+                do {
+                    pn3 = pn2->pn_next;
+                    RecycleTree(pn2, tc);
+                } while ((pn2 = pn3) != NULL);
+            }
+            pn->pn_type = TOK_PRIMARY;
+            pn->pn_op = cond ? JSOP_TRUE : JSOP_FALSE;
+            pn->pn_arity = PN_NULLARY;
+        }
+    }
+
+    return JS_TRUE;
+}
diff -r 17e9560465b0 js/src/jsparse.h
--- a/js/src/jsparse.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/jsparse.h	Thu Oct 30 05:41:45 2008 -0400
@@ -464,7 +464,8 @@
                        const char *filename, uintN lineno);
 
 extern JSBool
-js_FoldConstants(JSContext *cx, JSParseNode *pn, JSTreeContext *tc);
+js_FoldConstants(JSContext *cx, JSParseNode *pn, JSTreeContext *tc,
+                 bool inCond = false);
 
 #if JS_HAS_XML_SUPPORT
 JS_FRIEND_API(JSParseNode *)
diff -r 17e9560465b0 js/src/jsregexp.cpp
--- a/js/src/jsregexp.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/jsregexp.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -51,6 +51,7 @@
 #include "jsapi.h"
 #include "jsarray.h"
 #include "jsatom.h"
+#include "jsbuiltins.h"
 #include "jscntxt.h"
 #include "jsversion.h"
 #include "jsfun.h"
@@ -4273,6 +4274,21 @@
     return JS_TRUE;
 }
 
+#ifdef JS_TRACER
+static jsint FASTCALL
+Regexp_p_test(JSContext* cx, JSObject* regexp, JSString* str)
+{
+    jsval vp[3] = { JSVAL_NULL, OBJECT_TO_JSVAL(regexp), STRING_TO_JSVAL(str) };
+    if (!regexp_exec_sub(cx, regexp, 1, vp + 2, JS_TRUE, vp))
+        return JSVAL_TO_BOOLEAN(JSVAL_VOID);
+    return *vp == JSVAL_TRUE;
+}
+
+JS_DEFINE_TRCINFO_1(regexp_test,
+    (3, (static, BOOL_FAIL, Regexp_p_test, CONTEXT, THIS, STRING,  1, 1)))
+
+#endif
+
 static JSFunctionSpec regexp_methods[] = {
 #if JS_HAS_TOSOURCE
     JS_FN(js_toSource_str,  regexp_toString,    0,0),
@@ -4280,7 +4296,7 @@
     JS_FN(js_toString_str,  regexp_toString,    0,0),
     JS_FN("compile",        regexp_compile,     2,0),
     JS_FN("exec",           regexp_exec,        1,0),
-    JS_FN("test",           regexp_test,        1,0),
+    JS_TN("test",           regexp_test,        1,0, regexp_test_trcinfo),
     JS_FS_END
 };
 
diff -r 17e9560465b0 js/src/jsscan.h
--- a/js/src/jsscan.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/jsscan.h	Thu Oct 30 05:41:45 2008 -0400
@@ -136,6 +136,7 @@
     TOK_LET = 81,                       /* let keyword */
     TOK_SEQ = 82,                       /* synthetic sequence of statements,
                                            not a block */
+    TOK_FORHEAD = 83,                   /* head of for(;;)-style loop */
     TOK_RESERVED,                       /* reserved keywords */
     TOK_LIMIT                           /* domain size */
 } JSTokenType;
diff -r 17e9560465b0 js/src/jsstr.cpp
--- a/js/src/jsstr.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/jsstr.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -1,5 +1,5 @@
 /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- * vim: set ts=8 sw=4 et tw=80:
+ * vim: set ts=8 sw=4 et tw=99:
  *
  * ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
@@ -733,6 +733,29 @@
 /*
  * Java-like string native methods.
  */
+
+static JSString *
+SubstringTail(JSContext *cx, JSString *str, jsdouble length, jsdouble begin, jsdouble end)
+{
+    if (begin < 0)
+        begin = 0;
+    else if (begin > length)
+        begin = length;
+
+    if (end < 0)
+        end = 0;
+    else if (end > length)
+        end = length;
+    if (end < begin) {
+        /* ECMA emulates old JDK1.0 java.lang.String.substring. */
+        jsdouble tmp = begin;
+        begin = end;
+        end = tmp;
+    }
+
+    return js_NewDependentString(cx, str, (size_t)begin, (size_t)(end - begin));
+}
+
 static JSBool
 str_substring(JSContext *cx, uintN argc, jsval *vp)
 {
@@ -747,11 +770,6 @@
             return JS_FALSE;
         length = JSSTRING_LENGTH(str);
         begin = js_DoubleToInteger(d);
-        if (begin < 0)
-            begin = 0;
-        else if (begin > length)
-            begin = length;
-
         if (argc == 1) {
             end = length;
         } else {
@@ -759,43 +777,33 @@
             if (JSVAL_IS_NULL(vp[3]))
                 return JS_FALSE;
             end = js_DoubleToInteger(d);
-            if (end < 0)
-                end = 0;
-            else if (end > length)
-                end = length;
-            if (end < begin) {
-                /* ECMA emulates old JDK1.0 java.lang.String.substring. */
-                jsdouble tmp = begin;
-                begin = end;
-                end = tmp;
-            }
-        }
-
-        str = js_NewDependentString(cx, str, (size_t)begin,
-                                    (size_t)(end - begin));
-        if (!str)
-            return JS_FALSE;
-    }
-    *vp = STRING_TO_JSVAL(str);
-    return JS_TRUE;
-}
-
-#ifdef JS_TRACER
-JSString* FASTCALL
-js_String_p_substring(JSContext* cx, JSString* str, int32 begin, int32 end)
-{
-    JS_ASSERT(end >= begin);
+        }
+
+        str = SubstringTail(cx, str, length, begin, end);
+        if (!str)
+            return JS_FALSE;
+    }
+    *vp = STRING_TO_JSVAL(str);
+    return JS_TRUE;
+}
+
+#ifdef JS_TRACER
+static JSString* FASTCALL
+String_p_substring(JSContext* cx, JSString* str, int32 begin, int32 end)
+{
     JS_ASSERT(JS_ON_TRACE(cx));
-    return js_NewDependentString(cx, str, (size_t)begin, (size_t)(end - begin));
-}
-
-JSString* FASTCALL
-js_String_p_substring_1(JSContext* cx, JSString* str, int32 begin)
-{
-    int32 end = JSSTRING_LENGTH(str);
-    JS_ASSERT(end >= begin);
+
+    size_t length = JSSTRING_LENGTH(str);
+    return SubstringTail(cx, str, length, begin, end);
+}
+
+static JSString* FASTCALL
+String_p_substring_1(JSContext* cx, JSString* str, int32 begin)
+{
     JS_ASSERT(JS_ON_TRACE(cx));
-    return js_NewDependentString(cx, str, (size_t)begin, (size_t)(end - begin));
+
+    size_t length = JSSTRING_LENGTH(str);
+    return SubstringTail(cx, str, length, begin, length);
 }
 #endif
 
@@ -1430,8 +1438,8 @@
 }
 
 #ifdef JS_TRACER
-JSObject* FASTCALL
-js_String_p_match(JSContext* cx, JSString* str, jsbytecode *pc, JSObject* regexp)
+static JSObject* FASTCALL
+String_p_match(JSContext* cx, JSString* str, jsbytecode *pc, JSObject* regexp)
 {
     jsval vp[3] = { JSVAL_NULL, STRING_TO_JSVAL(str), OBJECT_TO_JSVAL(regexp) };
     if (!js_StringMatchHelper(cx, 1, vp, pc))
@@ -1441,8 +1449,8 @@
     return JSVAL_TO_OBJECT(vp[0]);
 }
 
-JSObject* FASTCALL
-js_String_p_match_obj(JSContext* cx, JSObject* str, jsbytecode *pc, JSObject* regexp)
+static JSObject* FASTCALL
+String_p_match_obj(JSContext* cx, JSObject* str, jsbytecode *pc, JSObject* regexp)
 {
     jsval vp[3] = { JSVAL_NULL, OBJECT_TO_JSVAL(str), OBJECT_TO_JSVAL(regexp) };
     if (!js_StringMatchHelper(cx, 1, vp, pc))
@@ -1754,8 +1762,8 @@
 }
 
 #ifdef JS_TRACER
-JSString* FASTCALL
-js_String_p_replace_str(JSContext* cx, JSString* str, JSObject* regexp, JSString* repstr)
+static JSString* FASTCALL
+String_p_replace_str(JSContext* cx, JSString* str, JSObject* regexp, JSString* repstr)
 {
     jsval vp[4] = {
         JSVAL_NULL, STRING_TO_JSVAL(str), OBJECT_TO_JSVAL(regexp), STRING_TO_JSVAL(repstr)
@@ -1766,8 +1774,8 @@
     return JSVAL_TO_STRING(vp[0]);
 }
 
-JSString* FASTCALL
-js_String_p_replace_str2(JSContext* cx, JSString* str, JSString* patstr, JSString* repstr)
+static JSString* FASTCALL
+String_p_replace_str2(JSContext* cx, JSString* str, JSString* patstr, JSString* repstr)
 {
     jsval vp[4] = {
         JSVAL_NULL, STRING_TO_JSVAL(str), STRING_TO_JSVAL(patstr), STRING_TO_JSVAL(repstr)
@@ -1778,9 +1786,9 @@
     return JSVAL_TO_STRING(vp[0]);
 }
 
-JSString* FASTCALL
-js_String_p_replace_str3(JSContext* cx, JSString* str, JSString* patstr, JSString* repstr,
-                         JSString* flagstr)
+static JSString* FASTCALL
+String_p_replace_str3(JSContext* cx, JSString* str, JSString* patstr, JSString* repstr,
+                      JSString* flagstr)
 {
     jsval vp[5] = {
         JSVAL_NULL, STRING_TO_JSVAL(str), STRING_TO_JSVAL(patstr), STRING_TO_JSVAL(repstr),
@@ -2095,8 +2103,8 @@
 }
 
 #ifdef JS_TRACER
-JSObject* FASTCALL
-js_String_p_split(JSContext* cx, JSString* str, JSString* sepstr)
+static JSObject* FASTCALL
+String_p_split(JSContext* cx, JSString* str, JSString* sepstr)
 {
     // FIXME: Avoid building and then parsing this array.
     jsval vp[4] = { JSVAL_NULL, STRING_TO_JSVAL(str), STRING_TO_JSVAL(sepstr), JSVAL_VOID };
@@ -2183,8 +2191,8 @@
 }
 
 #ifdef JS_TRACER
-JSString* FASTCALL
-js_String_p_concat_1int(JSContext* cx, JSString* str, int32 i)
+static JSString* FASTCALL
+String_p_concat_1int(JSContext* cx, JSString* str, int32 i)
 {
     // FIXME: should be able to use stack buffer and avoid istr...
     JSString* istr = js_NumberToString(cx, i);
@@ -2193,8 +2201,8 @@
     return js_ConcatStrings(cx, str, istr);
 }
 
-JSString* FASTCALL
-js_String_p_concat_2str(JSContext* cx, JSString* str, JSString* a, JSString* b)
+static JSString* FASTCALL
+String_p_concat_2str(JSContext* cx, JSString* str, JSString* a, JSString* b)
 {
     str = js_ConcatStrings(cx, str, a);
     if (str)
@@ -2202,8 +2210,8 @@
     return NULL;
 }
 
-JSString* FASTCALL
-js_String_p_concat_3str(JSContext* cx, JSString* str, JSString* a, JSString* b, JSString* c)
+static JSString* FASTCALL
+String_p_concat_3str(JSContext* cx, JSString* str, JSString* a, JSString* b, JSString* c)
 {
     str = js_ConcatStrings(cx, str, a);
     if (str) {
@@ -2451,7 +2459,6 @@
 #endif /* JS_HAS_STR_HTML_HELPERS */
 
 #ifdef JS_TRACER
-
 JSString* FASTCALL
 js_String_getelem(JSContext* cx, JSString* str, int32 i)
 {
@@ -2459,63 +2466,36 @@
         return NULL;
     return js_GetUnitString(cx, str, (size_t)i);
 }
-
-JS_DEFINE_CALLINFO_2(BOOL,      EqualStrings, STRING, STRING,                               1, 1)
-JS_DEFINE_CALLINFO_2(INT32,     CompareStrings, STRING, STRING,                             1, 1)
-
-JS_DEFINE_CALLINFO_4(STRING,    String_p_substring, CONTEXT, STRING, INT32, INT32,          1, 1)
-JS_DEFINE_CALLINFO_3(STRING,    String_p_substring_1, CONTEXT, STRING, INT32,               1, 1)
-JS_DEFINE_CALLINFO_3(STRING,    String_getelem, CONTEXT, STRING, INT32,                     1, 1)
-JS_DEFINE_CALLINFO_2(INT32,     String_p_charCodeAt, STRING, INT32,                         1, 1)
-JS_DEFINE_CALLINFO_3(STRING,    ConcatStrings, CONTEXT, STRING, STRING,                     1, 1)
-JS_DEFINE_CALLINFO_3(STRING,    String_p_concat_1int, CONTEXT, STRING, INT32,               1, 1)
-JS_DEFINE_CALLINFO_4(STRING,    String_p_concat_2str, CONTEXT, STRING, STRING, STRING,      1, 1)
-JS_DEFINE_CALLINFO_5(STRING,    String_p_concat_3str, CONTEXT, STRING, STRING, STRING, STRING, 1, 1)
-JS_DEFINE_CALLINFO_4(OBJECT,    String_p_match, CONTEXT, STRING, PC, OBJECT,                1, 1)
-JS_DEFINE_CALLINFO_4(OBJECT,    String_p_match_obj, CONTEXT, OBJECT, PC, OBJECT,            1, 1)
-JS_DEFINE_CALLINFO_4(STRING,    String_p_replace_str, CONTEXT, STRING, OBJECT, STRING,      1, 1)
-JS_DEFINE_CALLINFO_4(STRING,    String_p_replace_str2, CONTEXT, STRING, STRING, STRING,     1, 1)
-JS_DEFINE_CALLINFO_5(STRING,    String_p_replace_str3, CONTEXT, STRING, STRING, STRING, STRING, 1, 1)
-JS_DEFINE_CALLINFO_3(OBJECT,    String_p_split, CONTEXT, STRING, STRING,                    0, 0)
-JS_DEFINE_CALLINFO_2(STRING,    toLowerCase, CONTEXT, STRING,                               1, 1)
-JS_DEFINE_CALLINFO_2(STRING,    toUpperCase, CONTEXT, STRING,                               1, 1)
-
-static const JSTraceableNative str_substring_trcinfo[] = {
-    { str_substring,         &ci_String_p_substring,   "SC",  "ii",   FAIL_NULL | JSTN_MORE},
-    { str_substring,         &ci_String_p_substring_1, "SC",  "i",    FAIL_NULL }
-};
-static const JSTraceableNative str_charAt_trcinfo[] = {
-    { str_charAt,            &ci_String_getelem,       "SC",  "i",    FAIL_NULL }
-};
-static const JSTraceableNative str_charCodeAt_trcinfo[] = {
-    { str_charCodeAt,        &ci_String_p_charCodeAt,  "S",   "i",    FAIL_NEG }
-};
-static const JSTraceableNative str_concat_trcinfo[] = {
-    { str_concat,            &ci_String_p_concat_1int, "SC",  "i",    FAIL_NULL | JSTN_MORE },
-    { str_concat,            &ci_ConcatStrings,        "SC",  "s",    FAIL_NULL | JSTN_MORE },
-    { str_concat,            &ci_String_p_concat_2str, "SC",  "ss",   FAIL_NULL | JSTN_MORE },
-    { str_concat,            &ci_String_p_concat_3str, "SC",  "sss",  FAIL_NULL }
-};
-static const JSTraceableNative str_match_trcinfo[] = {
-    { str_match,             &ci_String_p_match,       "PSC", "r",    FAIL_VOID | JSTN_MORE },
-    { str_match,             &ci_String_p_match_obj,   "PTC", "r",    FAIL_VOID }
-};
-static const JSTraceableNative str_replace_trcinfo[] = {
-    { str_replace,           &ci_String_p_replace_str, "SC",  "sr",   FAIL_NULL | JSTN_MORE },
-    { str_replace,           &ci_String_p_replace_str2,"SC",  "ss",   FAIL_NULL | JSTN_MORE },
-    { str_replace,           &ci_String_p_replace_str3,"SC",  "sss",  FAIL_NULL }
-};
-static const JSTraceableNative str_split_trcinfo[] = {
-    { str_split,             &ci_String_p_split,       "SC",  "s",    FAIL_NULL }
-};
-static const JSTraceableNative str_toLowerCase_trcinfo[] = {
-    { str_toLowerCase,       &ci_toLowerCase,          "SC",   "",    FAIL_NULL }
-};
-static const JSTraceableNative str_toUpperCase_trcinfo[] = {
-    { str_toUpperCase,       &ci_toUpperCase,          "SC",   "",    FAIL_NULL }
-};
-
-#endif /* JS_TRACER */
+#endif
+
+JS_DEFINE_CALLINFO_2(extern, BOOL,   js_EqualStrings, STRING, STRING,                       1, 1)
+JS_DEFINE_CALLINFO_2(extern, INT32,  js_CompareStrings, STRING, STRING,                     1, 1)
+
+JS_DEFINE_TRCINFO_2(str_substring,
+    (4, (static, STRING_FAIL,      String_p_substring, CONTEXT, THIS_STRING, INT32, INT32,   1, 1)),
+    (3, (static, STRING_FAIL,      String_p_substring_1, CONTEXT, THIS_STRING, INT32,        1, 1)))
+JS_DEFINE_TRCINFO_1(str_charAt,
+    (3, (extern, STRING_FAIL,      js_String_getelem, CONTEXT, THIS_STRING, INT32,           1, 1)))
+JS_DEFINE_TRCINFO_1(str_charCodeAt,
+    (2, (extern, INT32_FAIL,       js_String_p_charCodeAt, THIS_STRING, INT32,               1, 1)))
+JS_DEFINE_TRCINFO_4(str_concat,
+    (3, (static, STRING_FAIL,      String_p_concat_1int, CONTEXT, THIS_STRING, INT32,        1, 1)),
+    (3, (extern, STRING_FAIL,      js_ConcatStrings, CONTEXT, THIS_STRING, STRING,           1, 1)),
+    (4, (static, STRING_FAIL,      String_p_concat_2str, CONTEXT, THIS_STRING, STRING, STRING, 1, 1)),
+    (5, (static, STRING_FAIL,      String_p_concat_3str, CONTEXT, THIS_STRING, STRING, STRING, STRING, 1, 1)))
+JS_DEFINE_TRCINFO_2(str_match,
+    (4, (static, OBJECT_FAIL_VOID, String_p_match, CONTEXT, THIS_STRING, PC, REGEXP,         1, 1)),
+    (4, (static, OBJECT_FAIL_VOID, String_p_match_obj, CONTEXT, THIS, PC, REGEXP,            1, 1)))
+JS_DEFINE_TRCINFO_3(str_replace,
+    (4, (static, STRING_FAIL,      String_p_replace_str, CONTEXT, THIS_STRING, REGEXP, STRING, 1, 1)),
+    (4, (static, STRING_FAIL,      String_p_replace_str2, CONTEXT, THIS_STRING, STRING, STRING, 1, 1)),
+    (5, (static, STRING_FAIL,      String_p_replace_str3, CONTEXT, THIS_STRING, STRING, STRING, STRING, 1, 1)))
+JS_DEFINE_TRCINFO_1(str_split,
+    (3, (static, OBJECT_FAIL_NULL, String_p_split, CONTEXT, THIS_STRING, STRING,             0, 0)))
+JS_DEFINE_TRCINFO_1(str_toLowerCase,
+    (2, (extern, STRING_FAIL,      js_toLowerCase, CONTEXT, THIS_STRING,                     1, 1)))
+JS_DEFINE_TRCINFO_1(str_toUpperCase,
+    (2, (extern, STRING_FAIL,      js_toUpperCase, CONTEXT, THIS_STRING,                     1, 1)))
 
 #define GENERIC           JSFUN_GENERIC_NATIVE
 #define PRIMITIVE         JSFUN_THISP_PRIMITIVE
@@ -2640,9 +2620,8 @@
 }
 
 #ifdef JS_TRACER
-
-JSString* FASTCALL
-js_String_fromCharCode(JSContext* cx, int32 i)
+static JSString* FASTCALL
+String_fromCharCode(JSContext* cx, int32 i)
 {
     JS_ASSERT(JS_ON_TRACE(cx));
     jschar c = (jschar)i;
@@ -2650,13 +2629,10 @@
         return js_GetUnitStringForChar(cx, c);
     return js_NewStringCopyN(cx, &c, 1);
 }
-
-JS_DEFINE_CALLINFO_2(STRING, String_fromCharCode, CONTEXT, INT32, 1, 1)
-
-static const JSTraceableNative str_fromCharCode_trcinfo[] = {
-    { str_fromCharCode, &ci_String_fromCharCode, "C", "i", FAIL_NULL }};
-
-#endif /* JS_TRACER */
+#endif
+
+JS_DEFINE_TRCINFO_1(str_fromCharCode,
+    (2, (static, STRING_FAIL, String_fromCharCode, CONTEXT, INT32, 1, 1)))
 
 static JSFunctionSpec string_static_methods[] = {
     JS_TN("fromCharCode", str_fromCharCode, 1, 0, str_fromCharCode_trcinfo),
diff -r 17e9560465b0 js/src/jstracer.cpp
--- a/js/src/jstracer.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/jstracer.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -51,7 +51,7 @@
 #include <alloca.h>
 #endif
 
-#include "nanojit.h"
+#include "nanojit/nanojit.h"
 #include "jsarray.h"            // higher-level library and API headers
 #include "jsbool.h"
 #include "jscntxt.h"
@@ -66,6 +66,7 @@
 #include "jsscope.h"
 #include "jsscript.h"
 #include "jsdate.h"
+#include "jsstaticcheck.h"
 #include "jstracer.h"
 
 #include "jsautooplen.h"        // generated headers last
@@ -374,8 +375,8 @@
 }
 
 #if defined(NJ_SOFTFLOAT)
-JS_DECLARE_CALLINFO(i2f)
-JS_DECLARE_CALLINFO(u2f)
+JS_DEFINE_CALLINFO_1(static, DOUBLE,    i2f, INT32,                 1, 1)
+JS_DEFINE_CALLINFO_1(static, DOUBLE,    u2f, UINT32,                1, 1)
 #endif
 
 static bool isi2f(LInsp i)
@@ -388,7 +389,7 @@
         i->oprnd1()->isop(LIR_call) &&
         i->oprnd2()->isop(LIR_callh))
     {
-        if (i->oprnd1()->callInfo() == &ci_i2f)
+        if (i->oprnd1()->callInfo() == &i2f_ci)
             return true;
     }
 #endif
@@ -406,7 +407,7 @@
         i->oprnd1()->isop(LIR_call) &&
         i->oprnd2()->isop(LIR_callh))
     {
-        if (i->oprnd1()->callInfo() == &ci_u2f)
+        if (i->oprnd1()->callInfo() == &u2f_ci)
             return true;
     }
 #endif
@@ -475,90 +476,88 @@
 #if defined(NJ_SOFTFLOAT)
 /* soft float */
 
+JS_DEFINE_CALLINFO_1(static, DOUBLE,    fneg, DOUBLE,               1, 1)
+JS_DEFINE_CALLINFO_2(static, INT32,     fcmpeq, DOUBLE, DOUBLE,     1, 1)
+JS_DEFINE_CALLINFO_2(static, INT32,     fcmplt, DOUBLE, DOUBLE,     1, 1)
+JS_DEFINE_CALLINFO_2(static, INT32,     fcmple, DOUBLE, DOUBLE,     1, 1)
+JS_DEFINE_CALLINFO_2(static, INT32,     fcmpgt, DOUBLE, DOUBLE,     1, 1)
+JS_DEFINE_CALLINFO_2(static, INT32,     fcmpge, DOUBLE, DOUBLE,     1, 1)
+JS_DEFINE_CALLINFO_2(static, DOUBLE,    fmul, DOUBLE, DOUBLE,       1, 1)
+JS_DEFINE_CALLINFO_2(static, DOUBLE,    fadd, DOUBLE, DOUBLE,       1, 1)
+JS_DEFINE_CALLINFO_2(static, DOUBLE,    fdiv, DOUBLE, DOUBLE,       1, 1)
+JS_DEFINE_CALLINFO_2(static, DOUBLE,    fsub, DOUBLE, DOUBLE,       1, 1)
+
 jsdouble FASTCALL
-js_fneg(jsdouble x)
+fneg(jsdouble x)
 {
     return -x;
 }
 
 jsdouble FASTCALL
-js_i2f(int32 i)
+i2f(int32 i)
 {
     return i;
 }
 
 jsdouble FASTCALL
-js_u2f(jsuint u)
+u2f(jsuint u)
 {
     return u;
 }
 
 int32 FASTCALL
-js_fcmpeq(jsdouble x, jsdouble y)
+fcmpeq(jsdouble x, jsdouble y)
 {
     return x==y;
 }
 
 int32 FASTCALL
-js_fcmplt(jsdouble x, jsdouble y)
+fcmplt(jsdouble x, jsdouble y)
 {
     return x < y;
 }
 
 int32 FASTCALL
-js_fcmple(jsdouble x, jsdouble y)
+fcmple(jsdouble x, jsdouble y)
 {
     return x <= y;
 }
 
 int32 FASTCALL
-js_fcmpgt(jsdouble x, jsdouble y)
+fcmpgt(jsdouble x, jsdouble y)
 {
     return x > y;
 }
 
 int32 FASTCALL
-js_fcmpge(jsdouble x, jsdouble y)
+fcmpge(jsdouble x, jsdouble y)
 {
     return x >= y;
 }
 
 jsdouble FASTCALL
-js_fmul(jsdouble x, jsdouble y)
+fmul(jsdouble x, jsdouble y)
 {
     return x * y;
 }
 
 jsdouble FASTCALL
-js_fadd(jsdouble x, jsdouble y)
+fadd(jsdouble x, jsdouble y)
 {
     return x + y;
 }
 
 jsdouble FASTCALL
-js_fdiv(jsdouble x, jsdouble y)
+fdiv(jsdouble x, jsdouble y)
 {
     return x / y;
 }
 
 jsdouble FASTCALL
-js_fsub(jsdouble x, jsdouble y)
+fsub(jsdouble x, jsdouble y)
 {
     return x - y;
 }
-
-JS_DEFINE_CALLINFO_1(DOUBLE,    fneg, DOUBLE,               1, 1)
-JS_DEFINE_CALLINFO_1(DOUBLE,    i2f, INT32,                 1, 1)
-JS_DEFINE_CALLINFO_1(DOUBLE,    u2f, UINT32,                1, 1)
-JS_DEFINE_CALLINFO_2(INT32,     fcmpeq, DOUBLE, DOUBLE,     1, 1)
-JS_DEFINE_CALLINFO_2(INT32,     fcmplt, DOUBLE, DOUBLE,     1, 1)
-JS_DEFINE_CALLINFO_2(INT32,     fcmple, DOUBLE, DOUBLE,     1, 1)
-JS_DEFINE_CALLINFO_2(INT32,     fcmpgt, DOUBLE, DOUBLE,     1, 1)
-JS_DEFINE_CALLINFO_2(INT32,     fcmpge, DOUBLE, DOUBLE,     1, 1)
-JS_DEFINE_CALLINFO_2(DOUBLE,    fmul, DOUBLE, DOUBLE,       1, 1)
-JS_DEFINE_CALLINFO_2(DOUBLE,    fadd, DOUBLE, DOUBLE,       1, 1)
-JS_DEFINE_CALLINFO_2(DOUBLE,    fdiv, DOUBLE, DOUBLE,       1, 1)
-JS_DEFINE_CALLINFO_2(DOUBLE,    fsub, DOUBLE, DOUBLE,       1, 1)
 
 class SoftFloatFilter: public LirWriter
 {
@@ -579,13 +578,13 @@
     LInsp ins1(LOpcode v, LInsp s0)
     {
         if (v == LIR_fneg)
-            return quadCall(&ci_fneg, &s0);
+            return quadCall(&fneg_ci, &s0);
 
         if (v == LIR_i2f)
-            return quadCall(&ci_i2f, &s0);
+            return quadCall(&i2f_ci, &s0);
 
         if (v == LIR_u2f)
-            return quadCall(&ci_u2f, &s0);
+            return quadCall(&u2f_ci, &s0);
 
         return out->ins1(v, s0);
     }
@@ -597,7 +596,7 @@
 
         // change the numeric value and order of these LIR opcodes and die
         if (LIR_fadd <= v && v <= LIR_fdiv) {
-            static const CallInfo *fmap[] = { &ci_fadd, &ci_fsub, &ci_fmul, &ci_fdiv };
+            static const CallInfo *fmap[] = { &fadd_ci, &fsub_ci, &fmul_ci, &fdiv_ci };
 
             args[0] = s1;
             args[1] = s0;
@@ -606,7 +605,7 @@
         }
 
         if (LIR_feq <= v && v <= LIR_fge) {
-            static const CallInfo *fmap[] = { &ci_fcmpeq, &ci_fcmplt, &ci_fcmpgt, &ci_fcmple, &ci_fcmpge };
+            static const CallInfo *fmap[] = { &fcmpeq_ci, &fcmplt_ci, &fcmpgt_ci, &fcmple_ci, &fcmpge_ci };
 
             args[0] = s1;
             args[1] = s0;
@@ -728,12 +727,12 @@
     LInsp insCall(const CallInfo *ci, LInsp args[])
     {
         LInsp s0 = args[0];
-        if (ci == &ci_DoubleToUint32) {
+        if (ci == &js_DoubleToUint32_ci) {
             if (s0->isconstq())
                 return out->insImm(js_DoubleToECMAUint32(s0->constvalf()));
             if (isi2f(s0) || isu2f(s0))
                 return iu2fArg(s0);
-        } else if (ci == &ci_DoubleToInt32) {
+        } else if (ci == &js_DoubleToInt32_ci) {
             if (s0->isconstq())
                 return out->insImm(js_DoubleToECMAInt32(s0->constvalf()));
             if (s0->isop(LIR_fadd) || s0->isop(LIR_fsub) || s0->isop(LIR_fmul)) {
@@ -747,23 +746,23 @@
             if (isi2f(s0) || isu2f(s0))
                 return iu2fArg(s0);
             // XXX ARM -- check for qjoin(call(UnboxDouble),call(UnboxDouble))
-            if (s0->isCall() && s0->callInfo() == &ci_UnboxDouble) {
+            if (s0->isCall() && s0->callInfo() == &js_UnboxDouble_ci) {
                 LIns* args2[] = { callArgN(s0, 0) };
-                return out->insCall(&ci_UnboxInt32, args2);
-            }
-            if (s0->isCall() && s0->callInfo() == &ci_StringToNumber) {
+                return out->insCall(&js_UnboxInt32_ci, args2);
+            }
+            if (s0->isCall() && s0->callInfo() == &js_StringToNumber_ci) {
                 // callArgN's ordering is that as seen by the builtin, not as stored in args here.
                 // True story!
                 LIns* args2[] = { callArgN(s0, 1), callArgN(s0, 0) };
-                return out->insCall(&ci_StringToInt32, args2);
-            }
-        } else if (ci == &ci_BoxDouble) {
+                return out->insCall(&js_StringToInt32_ci, args2);
+            }
+        } else if (ci == &js_BoxDouble_ci) {
             JS_ASSERT(s0->isQuad());
             if (s0->isop(LIR_i2f)) {
                 LIns* args2[] = { s0->oprnd1(), args[1] };
-                return out->insCall(&ci_BoxInt32, args2);
-            }
-            if (s0->isCall() && s0->callInfo() == &ci_UnboxDouble)
+                return out->insCall(&js_BoxInt32_ci, args2);
+            }
+            if (s0->isCall() && s0->callInfo() == &js_UnboxDouble_ci)
                 return callArgN(s0, 0);
         }
         return out->insCall(ci, args);
@@ -961,9 +960,9 @@
 static void
 js_TrashTree(JSContext* cx, Fragment* f);
 
-TraceRecorder::TraceRecorder(JSContext* cx, GuardRecord* _anchor, Fragment* _fragment,
+TraceRecorder::TraceRecorder(JSContext* cx, SideExit* _anchor, Fragment* _fragment,
         TreeInfo* ti, unsigned ngslots, uint8* globalTypeMap, uint8* stackTypeMap,
-        GuardRecord* innermostNestedGuard)
+        SideExit* innermostNestedGuard)
 {
     JS_ASSERT(!_fragment->vmprivate && ti);
 
@@ -983,6 +982,7 @@
     this->whichTreeToTrash = _fragment->root;
     this->global_dslots = this->globalObj->dslots;
     this->terminate = false;
+    this->isRootFragment = _fragment == _fragment->root;
 
     debug_only_v(printf("recording starting from %s:%u@%u\n", cx->fp->script->filename,
                         js_PCToLineNumber(cx, cx->fp->script, cx->fp->regs->pc),
@@ -1000,12 +1000,11 @@
     lir = cse_filter = new (&gc) CseFilter(lir, &gc);
     lir = expr_filter = new (&gc) ExprFilter(lir);
     lir = func_filter = new (&gc) FuncFilter(lir, *this);
-    lir->ins0(LIR_trace);
-
-    if (!nanojit::AvmCore::config.tree_opt || fragment->root == fragment) {
-        lirbuf->state = addName(lir->insParam(0), "state");
-        lirbuf->param1 = addName(lir->insParam(1), "param1");
-    }
+    lir->ins0(LIR_start);
+
+    if (!nanojit::AvmCore::config.tree_opt || fragment->root == fragment) 
+        lirbuf->state = addName(lir->insParam(0, 0), "state");
+
     lirbuf->sp = addName(lir->insLoad(LIR_ldp, lirbuf->state, (int)offsetof(InterpState, sp)), "sp");
     lirbuf->rp = addName(lir->insLoad(LIR_ldp, lirbuf->state, offsetof(InterpState, rp)), "rp");
     cx_ins = addName(lir->insLoad(LIR_ldp, lirbuf->state, offsetof(InterpState, cx)), "cx");
@@ -1018,7 +1017,7 @@
 
     /* If we are attached to a tree call guard, make sure the guard the inner tree exited from
        is what we expect it to be. */
-    if (_anchor && _anchor->exit->exitType == NESTED_EXIT) {
+    if (_anchor && _anchor->exitType == NESTED_EXIT) {
         LIns* nested_ins = addName(lir->insLoad(LIR_ldp, lirbuf->state, 
                                                 offsetof(InterpState, lastTreeExitGuard)), 
                                                 "lastTreeExitGuard");
@@ -1029,12 +1028,16 @@
 TraceRecorder::~TraceRecorder()
 {
     JS_ASSERT(treeInfo);
-    if (fragment->root == fragment && !fragment->root->code()) {
-        JS_ASSERT(!fragment->root->vmprivate);
+    if (fragment) {
+        if (isRootFragment && !fragment->root->code()) {
+            JS_ASSERT(!fragment->root->vmprivate);
+            delete treeInfo;
+        }
+        if (trashTree)
+            js_TrashTree(cx, whichTreeToTrash);
+    } else if (isRootFragment) {
         delete treeInfo;
     }
-    if (trashTree)
-        js_TrashTree(cx, whichTreeToTrash);
 #ifdef DEBUG
     delete verbose_filter;
 #endif
@@ -1045,6 +1048,12 @@
     delete float_filter;
 #endif
     delete lir_buf_writer;
+}
+
+void
+TraceRecorder::safeCleanup()
+{
+    fragment = NULL;
 }
 
 /* Add debug information to a LIR instruction as we emit it. */
@@ -1727,7 +1736,7 @@
             lir->insStorei(get(vp), lirbuf->sp, 
                            -treeInfo->nativeStackBase + nativeStackOffset(vp));
         else if (!isPromote && *m == JSVAL_INT) {
-            oracle.markStackSlotUndemotable(script, (jsbytecode*)f->ip, unsigned(m - map));
+            oracle.markStackSlotUndemotable(script, (jsbytecode*)f->root->ip, unsigned(m - map));
             ok = false;
         }
         ++m;
@@ -1759,64 +1768,138 @@
     return m;
 }
 
-SideExit*
+LIns*
 TraceRecorder::snapshot(ExitType exitType)
 {
     JSStackFrame* fp = cx->fp;
-    if (exitType == BRANCH_EXIT && js_IsLoopExit(cx->fp->regs->pc, (jsbytecode*)fragment->root->ip))
+    JSFrameRegs* regs = fp->regs;
+    jsbytecode* pc = regs->pc;
+    if (exitType == BRANCH_EXIT && js_IsLoopExit(pc, (jsbytecode*)fragment->root->ip))
         exitType = LOOP_EXIT;
-    /* Generate the entry map and stash it in the trace. */
+
+    /* Check for a return-value opcode that needs to restart at the next instruction. */
+    const JSCodeSpec& cs = js_CodeSpec[*pc];
+
+    /* WARNING: don't return before restoring the original pc if (resumeAfter). */
+    bool resumeAfter = (pendingTraceableNative &&
+                        JSTN_ERRTYPE(pendingTraceableNative) == FAIL_JSVAL);
+    if (resumeAfter) {
+        JS_ASSERT(cs.format & JOF_RETVAL);
+        pc += cs.length;
+        regs->pc = pc;
+        MUST_FLOW_THROUGH(restore_pc);
+    }
+
+    /* Generate the entry map for the (possibly advanced) pc and stash it in the trace. */
     unsigned stackSlots = js_NativeStackSlots(cx, callDepth);
+
     /* It's sufficient to track the native stack use here since all stores above the
        stack watermark defined by guards are killed. */
     trackNativeStackUse(stackSlots + 1);
-    /* reserve space for the type map */
+
+    /* Capture the type map into a temporary location. */
     unsigned ngslots = traceMonitor->globalSlots->length();
-    LIns* data = lir_buf_writer->skip((stackSlots + ngslots) * sizeof(uint8));
-    /* setup side exit structure */
-    memset(&exit, 0, sizeof(exit));
-    exit.from = fragment;
-    exit.calldepth = callDepth;
-    exit.numGlobalSlots = ngslots;
-    exit.numStackSlots = stackSlots;
-    exit.numStackSlotsBelowCurrentFrame = cx->fp->callee
-        ? nativeStackOffset(&cx->fp->argv[-2])/sizeof(double)
-        : 0;
-    exit.exitType = exitType;
-    /* If we take a snapshot on a goto, advance to the target address. This avoids inner
-       trees returning on a break goto, which the outer recorder then would confuse with
-       a break in the outer tree. */
-    jsbytecode* pc = fp->regs->pc;
-    if (*pc == JSOP_GOTO) 
-        pc += GET_JUMP_OFFSET(pc);
-    else if (*pc == JSOP_GOTOX)
-        pc += GET_JUMPX_OFFSET(pc);
-    exit.ip_adj = pc - (jsbytecode*)fragment->root->ip;
-    exit.sp_adj = (stackSlots * sizeof(double)) - treeInfo->nativeStackBase;
-    exit.rp_adj = exit.calldepth * sizeof(FrameInfo);
-    uint8* m = exit.typeMap = (uint8 *)data->payload();
+    unsigned typemap_size = (stackSlots + ngslots) * sizeof(uint8);
+    uint8* typemap = (uint8*)alloca(typemap_size);
+    uint8* m = typemap;
+
     /* Determine the type of a store by looking at the current type of the actual value the
        interpreter is using. For numbers we have to check what kind of store we used last
        (integer or double) to figure out what the side exit show reflect in its typemap. */
     FORALL_SLOTS(cx, ngslots, traceMonitor->globalSlots->data(), callDepth,
         *m++ = determineSlotType(vp);
     );
-    JS_ASSERT(unsigned(m - exit.typeMap) == ngslots + stackSlots);
-
-    /* If we are capturing the stack state on a JSOP_RESUME instruction, the value on top of
+    JS_ASSERT(unsigned(m - typemap) == ngslots + stackSlots);
+
+    /* If we are capturing the stack state on a JOF_RETVAL instruction, the value on top of
        the stack is a boxed value. */
-    if (*cx->fp->regs->pc == JSOP_RESUME) 
+    if (resumeAfter) {
         m[-1] = JSVAL_BOXED;
-    return &exit;
-}
-
-/* Emit a guard for condition (cond), expecting to evaluate to boolean result (expected). */
+
+        /* Now restore the the original pc (after which early returns are ok). */
+        MUST_FLOW_LABEL(restore_pc);
+        regs->pc = pc - cs.length;
+    } else {
+        /* If we take a snapshot on a goto, advance to the target address. This avoids inner
+           trees returning on a break goto, which the outer recorder then would confuse with
+           a break in the outer tree. */
+        if (*pc == JSOP_GOTO) 
+            pc += GET_JUMP_OFFSET(pc);
+        else if (*pc == JSOP_GOTOX)
+            pc += GET_JUMPX_OFFSET(pc);
+    }
+    int ip_adj = pc - (jsbytecode*)fragment->root->ip;
+
+    /* Check if we already have a matching side exit. If so use that side exit structure,
+       otherwise we have to create our own. */
+    SideExit** exits = treeInfo->sideExits.data();
+    unsigned nexits = treeInfo->sideExits.length();
+    if (exitType == LOOP_EXIT) {
+        for (unsigned n = 0; n < nexits; ++n) {
+            SideExit* e = exits[n];
+            if (e->ip_adj == ip_adj && 
+                !memcmp(getTypeMap(exits[n]), typemap, typemap_size)) {
+                LIns* data = lir_buf_writer->skip(sizeof(GuardRecord));
+                GuardRecord* rec = (GuardRecord*)data->payload();
+                /* setup guard record structure with shared side exit */
+                memset(rec, 0, sizeof(GuardRecord));
+                SideExit* exit = exits[n];
+                rec->exit = exit;
+                exit->addGuard(rec);
+                AUDIT(mergedLoopExits);
+                return data;
+            }
+        }
+    }
+
+    /* We couldn't find a matching side exit, so create our own side exit structure. */
+    LIns* data = lir_buf_writer->skip(sizeof(GuardRecord) +
+                                      sizeof(SideExit) + 
+                                      (stackSlots + ngslots) * sizeof(uint8));
+    GuardRecord* rec = (GuardRecord*)data->payload();
+    SideExit* exit = (SideExit*)(rec + 1);
+    /* setup guard record structure */
+    memset(rec, 0, sizeof(GuardRecord));
+    rec->exit = exit;
+    /* setup side exit structure */
+    memset(exit, 0, sizeof(SideExit));
+    exit->from = fragment;
+    exit->calldepth = callDepth;
+    exit->numGlobalSlots = ngslots;
+    exit->numStackSlots = stackSlots;
+    exit->numStackSlotsBelowCurrentFrame = cx->fp->callee
+        ? nativeStackOffset(&cx->fp->argv[-2])/sizeof(double)
+        : 0;
+    exit->exitType = exitType;
+    exit->addGuard(rec);
+    exit->ip_adj = ip_adj;
+    exit->sp_adj = (stackSlots * sizeof(double)) - treeInfo->nativeStackBase;
+    exit->rp_adj = exit->calldepth * sizeof(FrameInfo);
+    memcpy(getTypeMap(exit), typemap, typemap_size);
+
+    /* BIG FAT WARNING: If compilation fails, we currently don't reset the lirbuf so its safe
+       to keep references to the side exits here. If we ever start rewinding those lirbufs,
+       we have to make sure we purge the side exits that then no longer will be in valid
+       memory. */
+    if (exitType == LOOP_EXIT)
+        treeInfo->sideExits.add(exit);
+    return data;
+}
+
+/* Emit a guard for condition (cond), expecting to evaluate to boolean result (expected)
+   and using the supplied side exit if the conditon doesn't hold. */
+LIns*
+TraceRecorder::guard(bool expected, nanojit::LIns* cond, nanojit::LIns* exit)
+{
+    return lir->insGuard(expected ? LIR_xf : LIR_xt, cond, exit);
+}
+
+/* Emit a guard for condition (cond), expecting to evaluate to boolean result (expected)
+   and generate a side exit with type exitType to jump to if the condition does not hold. */
 LIns*
 TraceRecorder::guard(bool expected, LIns* cond, ExitType exitType)
 {
-    return lir->insGuard(expected ? LIR_xf : LIR_xt,
-                         cond,
-                         snapshot(exitType));
+    return guard(expected, cond, snapshot(exitType));
 }
 
 /* Try to match the type of a slot to type t. checkType is used to verify that the type of
@@ -1828,7 +1911,7 @@
         if (!isNumber(v))
             return false; /* not a number? type mismatch */
         LIns* i = get(&v);
-        if (!isi2f(i)) {
+        if (!isPromoteInt(i)) {
             debug_only_v(printf("int slot is !isInt32, slot #%d, triggering re-compilation\n",
                                 !isGlobal(&v)
                                 ? nativeStackOffset(&v)
@@ -1837,12 +1920,10 @@
             unstable = true;
             return true; /* keep checking types, but request re-compilation */
         }
-        /* Looks good, slot is an int32, the last instruction should be i2f. */
-        JS_ASSERT(isInt32(v) && (i->isop(LIR_i2f) || i->isop(LIR_qjoin)));
-        /* We got the final LIR_i2f as we expected. Overwrite the value in that
-           slot with the argument of i2f since we want the integer store to flow along
-           the loop edge, not the casted value. */
-        set(&v, iu2fArg(i));
+        /* Looks good, slot is an int32, the last instruction should be promotable. */
+        JS_ASSERT(isInt32(v) && isPromoteInt(i));
+        /* Overwrite the value in this slot with the argument promoted back to an integer. */
+        set(&v, f2i(i));
         return true;
     }
     if (t == JSVAL_DOUBLE) {
@@ -1893,7 +1974,7 @@
         if (!checkType(*vp, *m, demote))
             return false;
         if (demote) {
-            oracle.markStackSlotUndemotable(cx->fp->script, (jsbytecode*)fragment->ip,
+            oracle.markStackSlotUndemotable(cx->fp->script, (jsbytecode*)fragment->root->ip,
                     unsigned(m - typemap));
             recompile = true;
         }
@@ -1922,10 +2003,8 @@
     }
     ++treeInfo->branchCount;
     ::compile(fragmento->assm(), fragment);
-    if (anchor) {
-        fragment->addLink(anchor);
+    if (anchor) 
         fragmento->assm()->patch(anchor);
-    }
     JS_ASSERT(fragment->code());
     JS_ASSERT(!fragment->vmprivate);
     if (fragment == fragment->root)
@@ -1952,13 +2031,9 @@
             fragment->blacklist();
         return;
     }
-    SideExit *exit = snapshot(LOOP_EXIT);
-    exit->target = fragment->root;
-    if (fragment == fragment->root) {
-        fragment->lastIns = lir->insGuard(LIR_loop, lir->insImm(1), exit);
-    } else {
-        fragment->lastIns = lir->insGuard(LIR_x, lir->insImm(1), exit);
-    }
+    LIns* skip = snapshot(LOOP_EXIT);
+    ((GuardRecord*)skip->payload())->exit->target = fragment->root;
+    fragment->lastIns = lir->insGuard(LIR_loop, lir->insImm(1), skip);
     compile(fragmento);
 
     debug_only_v(printf("recording completed at %s:%u@%u via closeLoop\n", cx->fp->script->filename,
@@ -1970,8 +2045,7 @@
 void
 TraceRecorder::endLoop(Fragmento* fragmento)
 {
-    SideExit *exit = snapshot(LOOP_EXIT);
-    fragment->lastIns = lir->insGuard(LIR_x, lir->insImm(1), exit);
+    fragment->lastIns = lir->insGuard(LIR_x, lir->insImm(1), snapshot(LOOP_EXIT));
     compile(fragmento);
 
     debug_only_v(printf("recording completed at %s:%u@%u via endLoop\n", cx->fp->script->filename,
@@ -2021,16 +2095,15 @@
 
 /* Record a call to an inner tree. */
 void
-TraceRecorder::emitTreeCall(Fragment* inner, GuardRecord* lr)
+TraceRecorder::emitTreeCall(Fragment* inner, SideExit* exit)
 {
     TreeInfo* ti = (TreeInfo*)inner->vmprivate;
     /* Invoke the inner tree. */
     LIns* args[] = { INS_CONSTPTR(inner), lirbuf->state }; /* reverse order */
-    LIns* ret = lir->insCall(&ci_CallTree, args);
+    LIns* ret = lir->insCall(&js_CallTree_ci, args);
     /* Read back all registers, in case the called tree changed any of them. */
-    SideExit* exit = lr->exit;
     import(ti, inner_sp_ins, exit->numGlobalSlots, exit->calldepth,
-           exit->typeMap, exit->typeMap + exit->numGlobalSlots);
+           getTypeMap(exit), getTypeMap(exit) + exit->numGlobalSlots);
     /* Restore sp and rp to their original values (we still have them in a register). */
     if (callDepth > 0) {
         lir->insStorei(lirbuf->sp, lirbuf->state, offsetof(InterpState, sp));
@@ -2038,7 +2111,7 @@
     }
     /* Guard that we come out of the inner tree along the same side exit we came out when
        we called the inner tree at recording time. */
-    guard(true, lir->ins2(LIR_eq, ret, INS_CONSTPTR(lr)), NESTED_EXIT);
+    guard(true, lir->ins2(LIR_eq, ret, INS_CONSTPTR(exit)), NESTED_EXIT);
     /* Register us as a dependent tree of the inner tree. */
     ((TreeInfo*)inner->vmprivate)->dependentTrees.addUnique(fragment->root);
 }
@@ -2107,10 +2180,10 @@
 int
 nanojit::StackFilter::getTop(LInsp guard)
 {
-    if (sp == frag->lirbuf->sp)
-        return guard->exit()->sp_adj;
-    JS_ASSERT(sp == frag->lirbuf->rp);
-    return guard->exit()->rp_adj;
+    if (sp == lirbuf->sp)
+        return guard->record()->exit->sp_adj;
+    JS_ASSERT(sp == lirbuf->rp);
+    return guard->record()->exit->rp_adj;
 }
 
 #if defined NJ_VERBOSE
@@ -2120,7 +2193,7 @@
     uint32_t ip;
     SideExit *x;
 
-    x = (SideExit *)i->exit();
+    x = (SideExit *)i->record()->exit;
     ip = intptr_t(x->from->ip) + x->ip_adj;
     sprintf(out,
         "%s: %s %s -> %s sp%+ld rp%+ld",
@@ -2135,24 +2208,6 @@
 #endif
 
 void
-nanojit::Assembler::initGuardRecord(LIns *guard, GuardRecord *rec)
-{
-    SideExit *exit;
-
-    exit = guard->exit();
-    rec->guard = guard;
-    rec->calldepth = exit->calldepth;
-    rec->exit = exit;
-    verbose_only(rec->sid = exit->sid);
-}
-
-void
-nanojit::Assembler::asm_bailout(LIns *guard, Register state)
-{
-    /* we adjust ip/sp/rp when exiting from the tree in the recovery code */
-}
-
-void
 nanojit::Fragment::onDestroy()
 {
     if (root == this) {
@@ -2176,9 +2231,9 @@
 }
 
 static bool
-js_StartRecorder(JSContext* cx, GuardRecord* anchor, Fragment* f, TreeInfo* ti,
+js_StartRecorder(JSContext* cx, SideExit* anchor, Fragment* f, TreeInfo* ti,
         unsigned ngslots, uint8* globalTypeMap, uint8* stackTypeMap, 
-        GuardRecord* expectedInnerExit)
+        SideExit* expectedInnerExit)
 {
     JSTraceMonitor* tm = &JS_TRACE_MONITOR(cx);
 
@@ -2387,7 +2442,7 @@
     while (f->code() && f->peer)
         f = f->peer;
     if (f->code())
-        f = JS_TRACE_MONITOR(cx).fragmento->newLoop(f->ip);
+        f = JS_TRACE_MONITOR(cx).fragmento->getAnchor(f->ip);
 
     f->calldepth = 0;
     f->root = f;
@@ -2423,7 +2478,7 @@
 }
 
 static bool
-js_AttemptToExtendTree(JSContext* cx, GuardRecord* anchor, GuardRecord* exitedFrom)
+js_AttemptToExtendTree(JSContext* cx, SideExit* anchor, SideExit* exitedFrom)
 {
     Fragment* f = anchor->from->root;
     JS_ASSERT(f->vmprivate);
@@ -2437,10 +2492,9 @@
 
     Fragment* c;
     if (!(c = anchor->target)) {
-        c = JS_TRACE_MONITOR(cx).fragmento->createBranch(anchor, anchor->exit);
-        c->spawnedFrom = anchor->guard;
+        c = JS_TRACE_MONITOR(cx).fragmento->createBranch(anchor, cx->fp->regs->pc);
+        c->spawnedFrom = anchor;
         c->parent = f;
-        anchor->exit->target = c;
         anchor->target = c;
         c->root = f;
     }
@@ -2455,21 +2509,20 @@
         if (exitedFrom == NULL) {
             /* If we are coming straight from a simple side exit, just use that exit's type map
                as starting point. */
-            SideExit* e = anchor->exit;
-            ngslots = e->numGlobalSlots;
-            globalTypeMap = e->typeMap;
+            ngslots = anchor->numGlobalSlots;
+            globalTypeMap = getTypeMap(anchor);
             stackTypeMap = globalTypeMap + ngslots;
         } else {
             /* If we side-exited on a loop exit and continue on a nesting guard, the nesting
                guard (anchor) has the type information for everything below the current scope, 
                and the actual guard we exited from has the types for everything in the current
                scope (and whatever it inlined). We have to merge those maps here. */
-            SideExit* e1 = anchor->exit;
-            SideExit* e2 = exitedFrom->exit;
-            fullMap.add(e1->typeMap + e1->numGlobalSlots, e1->numStackSlotsBelowCurrentFrame);
-            fullMap.add(e2->typeMap + e2->numGlobalSlots, e2->numStackSlots);
+            SideExit* e1 = anchor;
+            SideExit* e2 = exitedFrom;
+            fullMap.add(getTypeMap(e1) + e1->numGlobalSlots, e1->numStackSlotsBelowCurrentFrame);
+            fullMap.add(getTypeMap(e2) + e2->numGlobalSlots, e2->numStackSlots);
             ngslots = e2->numGlobalSlots;
-            globalTypeMap = e2->typeMap;
+            globalTypeMap = getTypeMap(e2);
             stackTypeMap = fullMap.data();
         } 
         return js_StartRecorder(cx, anchor, c, (TreeInfo*)f->vmprivate,
@@ -2478,9 +2531,9 @@
     return false;
 }
 
-static GuardRecord*
+static SideExit*
 js_ExecuteTree(JSContext* cx, Fragment** treep, uintN& inlineCallCount, 
-               GuardRecord** innermostNestedGuardp);
+               SideExit** innermostNestedGuardp);
 
 static void
 js_CloseLoop(JSContext* cx)
@@ -2523,15 +2576,15 @@
         r->selectCallablePeerFragment(&f) && /* is there a potentially matching peer fragment? */
         r->adjustCallerTypes(f)) { /* make sure we can make our arguments fit */
         r->prepareTreeCall(f);
-        GuardRecord* innermostNestedGuard = NULL;
-        GuardRecord* lr = js_ExecuteTree(cx, &f, inlineCallCount, &innermostNestedGuard);
+        SideExit* innermostNestedGuard = NULL;
+        SideExit* lr = js_ExecuteTree(cx, &f, inlineCallCount, &innermostNestedGuard);
         if (!lr) {
             /* js_ExecuteTree might have flushed the cache and aborted us already. */
             if (JS_TRACE_MONITOR(cx).recorder)
                 js_AbortRecording(cx, "Couldn't call inner tree");
             return false;
         }
-        switch (lr->exit->exitType) {
+        switch (lr->exitType) {
         case LOOP_EXIT:
             /* If the inner tree exited on an unknown loop exit, grow the tree around it. */
             if (innermostNestedGuard) {
@@ -2546,7 +2599,7 @@
             js_AbortRecording(cx, "Inner tree is trying to grow, abort outer recording");
             return js_AttemptToExtendTree(cx, lr, NULL);
         default:
-            debug_only_v(printf("exit_type=%d\n", lr->exit->exitType);)
+            debug_only_v(printf("exit_type=%d\n", lr->exitType);)
             js_AbortRecording(cx, "Inner tree not suitable for calling");
             return false;
         }
@@ -2560,9 +2613,9 @@
     return false;
 }
 
-static inline GuardRecord*
+static inline SideExit*
 js_ExecuteTree(JSContext* cx, Fragment** treep, uintN& inlineCallCount, 
-               GuardRecord** innermostNestedGuardp)
+               SideExit** innermostNestedGuardp)
 {
     Fragment* f = *treep;
 
@@ -2604,7 +2657,7 @@
                             OBJ_SHAPE(globalObj), tm->globalShape);)
         const void* ip = f->ip;
         js_FlushJITCache(cx);
-        *treep = tm->fragmento->newLoop(ip);
+        *treep = tm->fragmento->getAnchor(ip);
         return NULL;
     }
 
@@ -2624,7 +2677,7 @@
         bool didGC;
         const void* ip = f->ip;
         if (!ReplenishReservePool(cx, tm, didGC) || didGC) {
-            *treep = tm->fragmento->newLoop(ip);
+            *treep = tm->fragmento->getAnchor(ip);
             return NULL;
         }
     }
@@ -2661,22 +2714,25 @@
     bool onTrace = tm->onTrace;
     if (!onTrace)
         tm->onTrace = true;
-    GuardRecord* lr;
-    
+    SideExit* lr;
+    
+    debug_only(fflush(NULL);)
+    GuardRecord* rec;
 #if defined(JS_NO_FASTCALL) && defined(NANOJIT_IA32)
-    SIMULATE_FASTCALL(lr, &state, NULL, u.func);
-#else
-    lr = u.func(&state, NULL);
-#endif
-
-    JS_ASSERT(lr->exit->exitType != LOOP_EXIT || !lr->calldepth);
+    SIMULATE_FASTCALL(rec, &state, NULL, u.func);
+#else
+    rec = u.func(&state, NULL);
+#endif
+    lr = rec->exit;
+
+    JS_ASSERT(lr->exitType != LOOP_EXIT || !lr->calldepth);
 
     if (!onTrace)
         tm->onTrace = false;
 
     /* Except if we find that this is a nested bailout, the guard the call returned is the
        one we have to use to adjust pc and sp. */
-    GuardRecord* innermost = lr;
+    SideExit* innermost = lr;
 
     /* While executing a tree we do not update state.sp and state.rp even if they grow. Instead,
        guards tell us by how much sp and rp should be incremented in case of a side exit. When
@@ -2687,8 +2743,8 @@
        stack (rp) is empty, we can process the final frames (which again are not directly
        visible and only the guard we exited on will tells us about). */
     FrameInfo* rp = (FrameInfo*)state.rp;
-    if (lr->exit->exitType == NESTED_EXIT) {
-        GuardRecord* nested = state.lastTreeCallGuard;
+    if (lr->exitType == NESTED_EXIT) {
+        SideExit* nested = state.lastTreeCallGuard;
         if (!nested) {
             /* If lastTreeCallGuard is not set in state, we only have a single level of
                nesting in this exit, so lr itself is the innermost and outermost nested
@@ -2708,9 +2764,9 @@
         if (innermostNestedGuardp)
             *innermostNestedGuardp = nested;
         JS_ASSERT(nested);
-        JS_ASSERT(nested->exit->exitType == NESTED_EXIT);
+        JS_ASSERT(nested->exitType == NESTED_EXIT);
         JS_ASSERT(state.lastTreeExitGuard);
-        JS_ASSERT(state.lastTreeExitGuard->exit->exitType != NESTED_EXIT);
+        JS_ASSERT(state.lastTreeExitGuard->exitType != NESTED_EXIT);
     }
     while (callstack < rp) {
         /* Synthesize a stack frame and write out the values in it using the type map pointer
@@ -2755,13 +2811,12 @@
     /* Adjust sp and pc relative to the tree we exited from (not the tree we entered
        into). These are our final values for sp and pc since js_SynthesizeFrame has
        already taken care of all frames in between. */
-    SideExit* e = innermost->exit;
     JSStackFrame* fp = cx->fp;
 
     /* If we are not exiting from an inlined frame the state->sp is spbase, otherwise spbase
        is whatever slots frames around us consume. */
-    fp->regs->pc = (jsbytecode*)innermost->from->root->ip + e->ip_adj;
-    fp->regs->sp = StackBase(fp) + (e->sp_adj / sizeof(double)) - calldepth_slots;
+    fp->regs->pc = (jsbytecode*)innermost->from->root->ip + innermost->ip_adj;
+    fp->regs->sp = StackBase(fp) + (innermost->sp_adj / sizeof(double)) - calldepth_slots;
     JS_ASSERT(fp->slots + fp->script->nfixed +
               js_ReconstructStackDepth(cx, fp->script, fp->regs->pc) == fp->regs->sp);
 
@@ -2771,14 +2826,14 @@
     uint64 cycles = 0;
 #endif
 
-    debug_only_v(printf("leaving trace at %s:%u@%u, op=%s, lr=%p, exitType=%d, sp=%d, ip=%p, "
+    debug_only_v(printf("leaving trace at %s:%u@%u, op=%s, lr=%p, exitType=%d, sp=%d, "
                         "calldepth=%d, cycles=%llu\n",
                         fp->script->filename, js_PCToLineNumber(cx, fp->script, fp->regs->pc),
                         fp->regs->pc - fp->script->code,
                         js_CodeName[*fp->regs->pc],
                         lr,
-                        lr->exit->exitType,
-                        fp->regs->sp - StackBase(fp), lr->jmp,
+                        lr->exitType,
+                        fp->regs->sp - StackBase(fp), 
                         calldepth,
                         cycles));
 
@@ -2786,10 +2841,10 @@
        with we don't have any type information available in the side exit. We merge in this
        information from the entry type-map. See also comment in the constructor of TraceRecorder
        why this is always safe to do. */
-    unsigned exit_gslots = e->numGlobalSlots;
+    unsigned exit_gslots = innermost->numGlobalSlots;
     JS_ASSERT(ngslots == tm->globalTypeMap->length());
     JS_ASSERT(ngslots >= exit_gslots);
-    uint8* globalTypeMap = e->typeMap;
+    uint8* globalTypeMap = getTypeMap(innermost);
     if (exit_gslots < ngslots)
         mergeTypeMaps(&globalTypeMap, &exit_gslots, tm->globalTypeMap->data(), ngslots,
                       (uint8*)alloca(sizeof(uint8) * ngslots));
@@ -2803,10 +2858,11 @@
     JS_ASSERT(*(uint64*)&global[globalFrameSize] == 0xdeadbeefdeadbeefLL);
 
     /* write back native stack frame */
-    slots = FlushNativeStackFrame(cx, e->calldepth, e->typeMap + e->numGlobalSlots, stack, NULL);
+    slots = FlushNativeStackFrame(cx, innermost->calldepth, getTypeMap(innermost) + 
+                                                            innermost->numGlobalSlots, stack, NULL);
     if (slots < 0)
         return NULL;
-    JS_ASSERT(unsigned(slots) == e->numStackSlots);
+    JS_ASSERT(unsigned(slots) == innermost->numStackSlots);
 
 #ifdef DEBUG
     // Verify that our state restoration worked
@@ -2854,15 +2910,15 @@
     } else {
         f = tm->fragmento->getLoop(pc);
         if (!f)
-            f = tm->fragmento->newLoop(pc);
+            f = tm->fragmento->getAnchor(pc);
         cacheEntry->pc = pc;
         cacheEntry->fragment = f;
     }
 
     /* If there is a chance that js_ExecuteTree will actually succeed, invoke it (either the
        first fragment must contain some code, or at least it must have a peer fragment). */
-    GuardRecord* lr = NULL;
-    GuardRecord* innermostNestedGuard = NULL;
+    SideExit* lr = NULL;
+    SideExit* innermostNestedGuard = NULL;
     if (f->code() || f->peer)
         lr = js_ExecuteTree(cx, &f, inlineCallCount, &innermostNestedGuard);
     if (!lr) {
@@ -2876,8 +2932,7 @@
     /* If we exit on a branch, or on a tree call guard, try to grow the inner tree (in case
        of a branch exit), or the tree nested around the tree we exited from (in case of the
        tree call guard). */
-    SideExit* exit = lr->exit;
-    switch (exit->exitType) {
+    switch (lr->exitType) {
     case BRANCH_EXIT:
         return js_AttemptToExtendTree(cx, lr, NULL);
     case LOOP_EXIT:
@@ -2900,8 +2955,10 @@
         return false;
     }
     
-    // Clear one-shot flag used to communicate between record_JSOP_CALL and record_EnterFrame.
+    // Clear one-shot state used to communicate between record_JSOP_CALL and mid- and post-
+    // opcode-case-guts record hooks (record_EnterFrame, record_FastNativeCallComplete).
     tr->applyingArguments = false;
+    tr->pendingTraceableNative = NULL;
 
     // In the future, handle dslots realloc by computing an offset from dslots instead.
     if (tr->global_dslots != tr->globalObj->dslots) {
@@ -2946,15 +3003,19 @@
 {
     JSTraceMonitor* tm = &JS_TRACE_MONITOR(cx);
     JS_ASSERT(tm->recorder != NULL);
-    Fragment* f = tm->recorder->getFragment();
-    JS_ASSERT(!f->vmprivate);
+    AUDIT(recorderAborted);
     /* Abort the trace and blacklist its starting point. */
-    AUDIT(recorderAborted);
     if (cx->fp) {
         debug_only_v(printf("Abort recording (line %d, pc %d): %s.\n",
                             js_PCToLineNumber(cx, cx->fp->script, cx->fp->regs->pc),
                             cx->fp->regs->pc - cx->fp->script->code, reason);)
     }
+    Fragment* f = tm->recorder->getFragment();
+    if (!f) {
+        js_DeleteRecorder(cx);
+        return;
+    }
+    JS_ASSERT(!f->vmprivate);
     f->blacklist();
     js_DeleteRecorder(cx);
     /* If this is the primary trace and we didn't succeed compiling, trash the TreeInfo object. */
@@ -3084,6 +3145,7 @@
         tm->globalSlots->clear();
         tm->globalTypeMap->clear();
     }
+    tm->jitCacheGen++;
 }
 
 jsval&
@@ -3216,7 +3278,7 @@
 
 LIns* TraceRecorder::f2i(LIns* f)
 {
-    return lir->insCall(&ci_DoubleToInt32, &f);
+    return lir->insCall(&js_DoubleToInt32_ci, &f);
 }
 
 LIns* TraceRecorder::makeNumberInt32(LIns* f)
@@ -3297,7 +3359,7 @@
     } else if (JSVAL_IS_STRING(v)) {
         LIns* args[] = { v_ins, INS_CONSTPTR(JSVAL_TO_STRING(v)) };
         guard(true,
-              addName(lir->ins_eq0(lir->ins_eq0(lir->insCall(&ci_EqualStrings, args))),
+              addName(lir->ins_eq0(lir->ins_eq0(lir->insCall(&js_EqualStrings_ci, args))),
                       "guard(switch on string)"),
               BRANCH_EXIT);
     } else if (JSVAL_TAG(v) == JSVAL_BOOLEAN) {
@@ -3382,6 +3444,8 @@
     LIns* v_ins;
     LIns* addr_ins;
     if (!elem(l, r, vp, v_ins, addr_ins))
+        return false;
+    if (!addr_ins) // if we read a hole, abort
         return false;
     if (!inc(*vp, v_ins, incr, pre))
         return false;
@@ -3465,9 +3529,9 @@
         } else {
             LIns* args[] = { r_ins, l_ins };
             if (op == LIR_feq)
-                l_ins = lir->ins_eq0(lir->insCall(&ci_EqualStrings, args));
+                l_ins = lir->ins_eq0(lir->insCall(&js_EqualStrings_ci, args));
             else
-                l_ins = lir->insCall(&ci_CompareStrings, args);
+                l_ins = lir->insCall(&js_CompareStrings_ci, args);
             r_ins = lir->insImm(0);
             cond = evalCmp(op, JSVAL_TO_STRING(l), JSVAL_TO_STRING(r));
         }
@@ -3486,7 +3550,7 @@
             u.d = js_NaN;
             l_ins = lir->insImmq(u.u64);
         } else if (JSVAL_IS_STRING(l)) {
-            l_ins = lir->insCall(&ci_StringToNumber, args);
+            l_ins = lir->insCall(&js_StringToNumber_ci, args);
         } else if (JSVAL_TAG(l) == JSVAL_BOOLEAN) {
             /*
              * What I really want here is for undefined to be type-specialized
@@ -3495,7 +3559,7 @@
              * branched.  Failing that, I want to be able to ins_choose on quads
              * without cmov.  Failing that, eat flaming builtin!
              */
-            l_ins = lir->insCall(&ci_BooleanToNumber, args);
+            l_ins = lir->insCall(&js_BooleanToNumber_ci, args);
         } else if (!isNumber(l)) {
             ABORT_TRACE("unsupported LHS type for cmp vs number");
         }
@@ -3508,10 +3572,10 @@
             u.d = js_NaN;
             r_ins = lir->insImmq(u.u64);
         } else if (JSVAL_IS_STRING(r)) {
-            r_ins = lir->insCall(&ci_StringToNumber, args);
+            r_ins = lir->insCall(&js_StringToNumber_ci, args);
         } else if (JSVAL_TAG(r) == JSVAL_BOOLEAN) {
             // See above for the sob story.
-            r_ins = lir->insCall(&ci_BooleanToNumber, args);
+            r_ins = lir->insCall(&js_BooleanToNumber_ci, args);
         } else if (!isNumber(r)) {
             ABORT_TRACE("unsupported RHS type for cmp vs number");
         }
@@ -3622,20 +3686,28 @@
         if (JSVAL_IS_STRING(l)) {
             args[0] = a;
             args[1] = cx_ins;
-            a = lir->insCall(&ci_StringToNumber, args);
+            a = lir->insCall(&js_StringToNumber_ci, args);
             leftNumber = true;
         }
         if (JSVAL_IS_STRING(r)) {
             args[0] = b;
             args[1] = cx_ins;
-            b = lir->insCall(&ci_StringToNumber, args);
+            b = lir->insCall(&js_StringToNumber_ci, args);
             rightNumber = true;
         }
+    }
+    if (l == JSVAL_VOID) {
+        a = lir->insImmq(0);
+        leftNumber = true;
+    }
+    if (r == JSVAL_VOID) {
+        b = lir->insImmq(0);
+        rightNumber = true;
     }
     if (leftNumber && rightNumber) {
         if (intop) {
             LIns *args[] = { a };
-            a = lir->insCall(op == LIR_ush ? &ci_DoubleToUint32 : &ci_DoubleToInt32, args);
+            a = lir->insCall(op == LIR_ush ? &js_DoubleToUint32_ci : &js_DoubleToInt32_ci, args);
             b = f2i(b);
         }
         a = lir->ins2(op, a, b);
@@ -3795,7 +3867,14 @@
         uint32 vshape = PCVCAP_SHAPE(vcap);
         JS_ASSERT(OBJ_SHAPE(obj2) == vshape);
 
-        LIns* obj2_ins = INS_CONSTPTR(obj2);
+        LIns* obj2_ins;
+        if (PCVCAP_TAG(entry->vcap) == 1) {
+            // Duplicate the special case in PROPERTY_CACHE_TEST.
+            obj2_ins = stobj_get_fslot(obj_ins, JSSLOT_PROTO);
+            guard(false, lir->ins_eq0(obj2_ins), MISMATCH_EXIT);
+        } else {
+            obj2_ins = INS_CONSTPTR(obj2);
+        }
         map_ins = lir->insLoad(LIR_ldp, obj2_ins, (int)offsetof(JSObject, map));
         if (!map_is_native(obj2->map, map_ins, ops_ins))
             return false;
@@ -3920,7 +3999,7 @@
 {
     if (isNumber(v)) {
         LIns* args[] = { v_ins, cx_ins };
-        v_ins = lir->insCall(&ci_BoxDouble, args);
+        v_ins = lir->insCall(&js_BoxDouble_ci, args);
         guard(false, lir->ins2(LIR_eq, v_ins, INS_CONST(JSVAL_ERROR_COOKIE)),
               OOM_EXIT);
         return true;
@@ -3952,7 +4031,7 @@
                                                 JSVAL_DOUBLE))),
               MISMATCH_EXIT);
         LIns* args[] = { v_ins };
-        v_ins = lir->insCall(&ci_UnboxDouble, args);
+        v_ins = lir->insCall(&js_UnboxDouble_ci, args);
         return true;
     }
     switch (JSVAL_TAG(v)) {
@@ -4000,17 +4079,16 @@
 bool
 TraceRecorder::guardClass(JSObject* obj, LIns* obj_ins, JSClass* clasp)
 {
-    if (STOBJ_GET_CLASS(obj) != clasp)
-        return false;
+    bool cond = STOBJ_GET_CLASS(obj) == clasp;
 
     LIns* class_ins = lir->insLoad(LIR_ldp, obj_ins, offsetof(JSObject, classword));
     class_ins = lir->ins2(LIR_piand, class_ins, lir->insImm(~3));
 
     char namebuf[32];
     JS_snprintf(namebuf, sizeof namebuf, "guard(class is %s)", clasp->name);
-    guard(true, addName(lir->ins2(LIR_eq, class_ins, INS_CONSTPTR(clasp)), namebuf),
+    guard(cond, addName(lir->ins2(LIR_eq, class_ins, INS_CONSTPTR(clasp)), namebuf),
           MISMATCH_EXIT);
-    return true;
+    return cond;
 }
 
 bool
@@ -4021,25 +4099,48 @@
 
 bool
 TraceRecorder::guardDenseArrayIndex(JSObject* obj, jsint idx, LIns* obj_ins,
-                                    LIns* dslots_ins, LIns* idx_ins)
+                                    LIns* dslots_ins, LIns* idx_ins, ExitType exitType)
 {
     jsuint length = ARRAY_DENSE_LENGTH(obj);
-    if (!((jsuint)idx < length && idx < obj->fslots[JSSLOT_ARRAY_LENGTH]))
-        return false;
-
-    LIns* length_ins = stobj_get_fslot(obj_ins, JSSLOT_ARRAY_LENGTH);
-
-    // guard(0 <= index && index < length)
-    guard(true, lir->ins2(LIR_ult, idx_ins, length_ins), MISMATCH_EXIT);
-
-    // At this point, the guard above => 0 < length <=> obj->dslots != null.
-    JS_ASSERT(obj->dslots);
-
-    // guard(index < capacity)
-    guard(true,
-          lir->ins2(LIR_lt, idx_ins, lir->insLoad(LIR_ldp, dslots_ins, 0 - (int)sizeof(jsval))),
-          MISMATCH_EXIT);
-    return true;
+
+    bool cond = (jsuint(idx) < jsuint(obj->fslots[JSSLOT_ARRAY_LENGTH]) && jsuint(idx) < length);
+    if (cond) {
+        /* Guard array length */
+        LIns* exit = guard(true,
+                           lir->ins2(LIR_ult, idx_ins, stobj_get_fslot(obj_ins, JSSLOT_ARRAY_LENGTH)),
+                           exitType)->oprnd2();
+        /* dslots must not be NULL */
+        guard(false,
+              lir->ins_eq0(dslots_ins),
+              exit);
+        /* Guard array capacity */
+        guard(true,
+              lir->ins2(LIR_ult,
+                        idx_ins,
+                        lir->insLoad(LIR_ldp, dslots_ins, 0 - (int)sizeof(jsval))),
+              exit);
+    } else {
+        /* If not idx < length, stay on trace (and read value as undefined). */ 
+        LIns* br1 = lir->insBranch(LIR_jf, 
+                                   lir->ins2(LIR_ult, 
+                                             idx_ins, 
+                                             stobj_get_fslot(obj_ins, JSSLOT_ARRAY_LENGTH)),
+                                   NULL);
+        /* If dslots is NULL, stay on trace (and read value as undefined). */
+        LIns* br2 = lir->insBranch(LIR_jt, lir->ins_eq0(dslots_ins), NULL);
+        /* If not idx < capacity, stay on trace (and read value as undefined). */
+        LIns* br3 = lir->insBranch(LIR_jf,
+                                   lir->ins2(LIR_ult,
+                                             idx_ins,
+                                             lir->insLoad(LIR_ldp, dslots_ins, 0 - (int)sizeof(jsval))),
+                                   NULL);
+        lir->insGuard(LIR_x, lir->insImm(1), snapshot(exitType));
+        LIns* label = lir->ins0(LIR_label);
+        br1->target(label);
+        br2->target(label);
+        br3->target(label);
+    }
+    return cond;    
 }
 
 /*
@@ -4130,7 +4231,9 @@
 
     if (++callDepth >= MAX_CALLDEPTH)
         ABORT_TRACE("exceeded maximum call depth");
-    if (fp->script == fp->down->script)
+    // FIXME: Allow and attempt to inline a single level of recursion until we compile 
+    //        recursive calls as independent trees (459301).
+    if (fp->script == fp->down->script && fp->down->down && fp->down->down->script == fp->script)
         ABORT_TRACE("recursive call");
     
     debug_only_v(printf("EnterFrame %s, callDepth=%d\n",
@@ -4197,8 +4300,17 @@
 bool
 TraceRecorder::record_JSOP_POPV()
 {
-    // We should not have to implement JSOP_POPV or JSOP_STOP's rval setting.
-    return false;
+    jsval& rval = stackval(-1);
+    LIns *rval_ins = get(&rval);
+    if (!box_jsval(rval, rval_ins))
+        return false;
+
+    // Store it in cx->fp->rval. NB: Tricky dependencies. cx->fp is the right
+    // frame because POPV appears only in global and eval code and we don't
+    // trace JSOP_EVAL or leaving the frame where tracing started.
+    LIns *fp_ins = lir->insLoad(LIR_ldp, cx_ins, offsetof(JSContext, fp));
+    lir->insStorei(rval_ins, fp_ins, offsetof(JSStackFrame, rval));
+    return true;
 }
 
 bool TraceRecorder::record_JSOP_ENTERWITH()
@@ -4252,7 +4364,7 @@
     ABORT_TRACE("can't trace arguments yet");
 #else
     LIns* args[] = { cx_ins };
-    LIns* a_ins = lir->insCall(&ci_Arguments, args);
+    LIns* a_ins = lir->insCall(&js_Arguments_ci, args);
     guard(false, lir->ins_eq0(a_ins), OOM_EXIT);
     stack(0, a_ins);
     return true;
@@ -4364,19 +4476,21 @@
         } else {
             LIns* args2[] = { get(&r), cx_ins };
             if (JSVAL_IS_NUMBER(r)) {
-                args[0] = lir->insCall(&ci_NumberToString, args2);
+                args[0] = lir->insCall(&js_NumberToString_ci, args2);
             } else if (JSVAL_IS_OBJECT(r)) {
-                args[0] = lir->insCall(&ci_ObjectToString, args2);
+                args[0] = lir->insCall(&js_ObjectToString_ci, args2);
             } else {
                 ABORT_TRACE("untraceable right operand to string-JSOP_ADD");
             }
             guard(false, lir->ins_eq0(args[0]), OOM_EXIT);
         }
-        LIns* concat = lir->insCall(&ci_ConcatStrings, args);
+        LIns* concat = lir->insCall(&js_ConcatStrings_ci, args);
         guard(false, lir->ins_eq0(concat), OOM_EXIT);
         set(&l, concat);
         return true;
     }
+    if (JSVAL_IS_STRING(r))
+        ABORT_TRACE("right hand side string not supported in JSOP_ADD");
     return binary(LIR_fadd);
 }
 
@@ -4410,12 +4524,12 @@
         /* We can't demote this in a filter since we need the actual values of l and r. */
         if (isPromote(l_ins) && isPromote(r_ins) && asNumber(l) >= 0 && asNumber(r) > 0) {
             LIns* args[] = { ::demote(lir, r_ins), ::demote(lir, l_ins) };
-            x = lir->insCall(&ci_imod, args);
+            x = lir->insCall(&js_imod_ci, args);
             guard(false, lir->ins2(LIR_eq, x, lir->insImm(-1)), BRANCH_EXIT);
             x = lir->ins1(LIR_i2f, x);
         } else {
             LIns* args[] = { r_ins, l_ins };
-            x = lir->insCall(&ci_dmod, args);
+            x = lir->insCall(&js_dmod_ci, args);
         }
         set(&l, x);
         return true;
@@ -4524,7 +4638,7 @@
     if (FUN_INTERPRETED(fun)) {
         if (constructing) {
             LIns* args[] = { get(&fval), cx_ins };
-            LIns* tv_ins = lir->insCall(&ci_FastNewObject, args);
+            LIns* tv_ins = lir->insCall(&js_FastNewObject_ci, args);
             guard(false, lir->ins_eq0(tv_ins), OOM_EXIT);
             set(&tval, tv_ins);
         }
@@ -4556,7 +4670,7 @@
         if (!aval_ins->isCall())
             ABORT_TRACE("can't trace Function.prototype.apply on non-builtin-call 2nd arg");
 
-        if (aval_ins->callInfo() == &ci_Arguments) {
+        if (aval_ins->callInfo() == &js_Arguments_ci) {
             JS_ASSERT(OBJ_GET_CLASS(cx, aobj) == &js_ArgumentsClass);
             JS_ASSERT(OBJ_GET_PRIVATE(cx, aobj) == fp);
             if (!FUN_INTERPRETED(tfun))
@@ -4591,7 +4705,7 @@
             return interpretedFunctionCall(tval, tfun, argc, false);
         }
 
-        if (aval_ins->callInfo() != &ci_Array_1str)
+        if (aval_ins->callInfo() != &js_Array_1str_ci)
             ABORT_TRACE("can't trace Function.prototype.apply on other than [str] 2nd arg");
 
         JS_ASSERT(OBJ_IS_ARRAY(cx, aobj));
@@ -4616,12 +4730,12 @@
         ABORT_TRACE("untraceable native");
 
     static JSTraceableNative knownNatives[] = {
-        { (JSFastNative)js_Array,  &ci_FastNewArray,  "pC", "",    FAIL_NULL | JSTN_MORE },
-        { (JSFastNative)js_Array,  &ci_Array_1int,    "pC", "i",   FAIL_NULL | JSTN_MORE },
-        { (JSFastNative)js_Array,  &ci_Array_2obj,    "pC", "oo",  FAIL_NULL | JSTN_MORE },
-        { (JSFastNative)js_Array,  &ci_Array_3num,    "pC", "ddd", FAIL_NULL | JSTN_MORE },
-        { (JSFastNative)js_Object, &ci_FastNewObject, "fC", "",    FAIL_NULL | JSTN_MORE },
-        { (JSFastNative)js_Date,   &ci_FastNewDate,   "pC", "",    FAIL_NULL },
+        { (JSFastNative)js_Array,  &js_FastNewArray_ci,   "pC", "",    FAIL_NULL | JSTN_MORE },
+        { (JSFastNative)js_Array,  &js_Array_1int_ci,     "pC", "i",   FAIL_NULL | JSTN_MORE },
+        { (JSFastNative)js_Array,  &js_Array_2obj_ci,     "pC", "oo",  FAIL_NULL | JSTN_MORE },
+        { (JSFastNative)js_Array,  &js_Array_3num_ci,     "pC", "ddd", FAIL_NULL | JSTN_MORE },
+        { (JSFastNative)js_Object, &js_FastNewObject_ci,  "fC", "",    FAIL_NULL | JSTN_MORE },
+        { (JSFastNative)js_Date,   &js_FastNewDate_ci,    "pC", "",    FAIL_NULL },
     };
 
     LIns* args[5];
@@ -4719,7 +4833,7 @@
          * If we got this far, and we have a charCodeAt, check that charCodeAt
          * isn't going to return a NaN.
          */
-        if (!constructing && known->builtin == &ci_String_p_charCodeAt) {
+        if (!constructing && known->builtin == &js_String_p_charCodeAt_ci) {
             JSString* str = JSVAL_TO_STRING(thisval);
             jsval& arg = arg1_ins ? arg1 : stackval(-1);
 
@@ -4824,10 +4938,10 @@
             // We specialize identically for boolean and undefined. We must not have a hole here.
             // Pass the unboxed type here, since TypeOfBoolean knows how to handle it.
             JS_ASSERT(JSVAL_TO_BOOLEAN(r) <= 2);
-            type = lir->insCall(&ci_TypeOfBoolean, args);
+            type = lir->insCall(&js_TypeOfBoolean_ci, args);
         } else {
             JS_ASSERT(JSVAL_IS_OBJECT(r));
-            type = lir->insCall(&ci_TypeOfObject, args);
+            type = lir->insCall(&js_TypeOfObject_ci, args);
         }
     }
     set(&r, type);
@@ -4987,7 +5101,7 @@
 
     if (entry->kshape != PCVCAP_SHAPE(entry->vcap)) {
         LIns* args[] = { INS_CONSTPTR(sprop), obj_ins, cx_ins };
-        LIns* ok_ins = lir->insCall(&ci_AddProperty, args);
+        LIns* ok_ins = lir->insCall(&js_AddProperty_ci, args);
         guard(false, lir->ins_eq0(ok_ins), OOM_EXIT);
     }
 
@@ -5039,7 +5153,7 @@
             ABORT_TRACE("Invalid string index in JSOP_GETELEM");
         idx_ins = makeNumberInt32(idx_ins);
         LIns* args[] = { idx_ins, obj_ins, cx_ins };
-        LIns* unitstr_ins = lir->insCall(&ci_String_getelem, args);
+        LIns* unitstr_ins = lir->insCall(&js_String_getelem_ci, args);
         guard(false, lir->ins_eq0(unitstr_ins), MISMATCH_EXIT);
         set(&lval, unitstr_ins);
         return true;
@@ -5069,7 +5183,7 @@
                 return false;
         }
         LIns* args[] = { idx_ins, obj_ins, cx_ins };
-        v_ins = lir->insCall(&ci_Any_getprop, args);
+        v_ins = lir->insCall(&js_Any_getprop_ci, args);
         guard(false, lir->ins2(LIR_eq, v_ins, INS_CONST(JSVAL_ERROR_COOKIE)), MISMATCH_EXIT);
         if (!unbox_jsval(v, v_ins))
             ABORT_TRACE("JSOP_GETELEM");
@@ -5092,7 +5206,7 @@
         idx = ID_TO_VALUE(id);
         if (!guardElemOp(obj, obj_ins, id, offsetof(JSObjectOps, getProperty), &v))
             return false;
-        LIns* v_ins = lir->insCall(&ci_Any_getelem, args);
+        LIns* v_ins = lir->insCall(&js_Any_getelem_ci, args);
         guard(false, lir->ins2(LIR_eq, v_ins, INS_CONST(JSVAL_ERROR_COOKIE)), MISMATCH_EXIT);
         if (!unbox_jsval(v, v_ins))
             ABORT_TRACE("JSOP_GETELEM");
@@ -5137,7 +5251,7 @@
         if (!guardElemOp(obj, obj_ins, id, offsetof(JSObjectOps, setProperty), NULL))
             return false;
         LIns* args[] = { boxed_v_ins, idx_ins, obj_ins, cx_ins };
-        LIns* ok_ins = lir->insCall(&ci_Any_setprop, args);
+        LIns* ok_ins = lir->insCall(&js_Any_setprop_ci, args);
         guard(false, lir->ins_eq0(ok_ins), MISMATCH_EXIT);    
     } else if (JSVAL_IS_INT(idx)) {
         if (JSVAL_TO_INT(idx) < 0)
@@ -5146,14 +5260,14 @@
         LIns* args[] = { boxed_v_ins, idx_ins, obj_ins, cx_ins };
         LIns* res_ins;
         if (guardDenseArray(obj, obj_ins)) {
-            res_ins = lir->insCall(&ci_Array_dense_setelem, args);
+            res_ins = lir->insCall(&js_Array_dense_setelem_ci, args);
         } else {
             if (!js_IndexToId(cx, JSVAL_TO_INT(idx), &id))
                 return false;
             idx = ID_TO_VALUE(id);
             if (!guardElemOp(obj, obj_ins, id, offsetof(JSObjectOps, setProperty), NULL))
                 return false;
-            res_ins = lir->insCall(&ci_Any_setelem, args);
+            res_ins = lir->insCall(&js_Any_setelem_ci, args);
         }
         guard(false, lir->ins_eq0(res_ins), MISMATCH_EXIT);
     } else {
@@ -5287,36 +5401,41 @@
     /* At this point the generated code has already called the native function
        and we can no longer fail back to the original pc location (JSOP_CALL)
        because that would cause the interpreter to re-execute the native 
-       function, which might have side effects. Instead we advance pc to
-       the JSOP_RESUME opcode that follows JSOP_CALL. snapshot() which is
-       invoked from unbox_jsval() will see that we are currently parked on
-       a JSOP_RESUME instruction and it will indicate in the type map that
-       the element on top of the stack is a boxed value which doesn't need
-       to be boxed if the type guard generated by unbox_jsval() fails. */
-    JSFrameRegs* regs = cx->fp->regs;
-    regs->pc += JSOP_CALL_LENGTH;
-    JS_ASSERT(*regs->pc == JSOP_RESUME);
+       function, which might have side effects.
+
+       Instead, snapshot(), which is invoked from unbox_jsval(), will see that
+       we are currently parked on a JOF_RETVAL instruction, and it will advance
+       the pc to restore by the length of the current opcode, and indicate in
+       the type map that the element on top of the stack is a boxed value which
+       doesn't need to be boxed if the type guard generated by unbox_jsval()
+       fails. */
+    JS_ASSERT(js_CodeSpec[*cx->fp->regs->pc].format & JOF_RETVAL);
 
     jsval& v = stackval(-1);
     LIns* v_ins = get(&v);
     
     bool ok = true;
-    if (JSTN_ERRTYPE(pendingTraceableNative) == FAIL_JSVAL) {
+    switch (JSTN_ERRTYPE(pendingTraceableNative)) {
+    case FAIL_JSVAL:
         ok = unbox_jsval(v, v_ins);
         if (ok)
             set(&v, v_ins);
-    }
-
-    /* Restore the original pc location. The interpreter will advance pc to
-       step over JSOP_RESUME. */
-    regs->pc -= JSOP_CALL_LENGTH;
+        break;
+    case FAIL_NEG:
+        /* Already added i2f in functionCall. */
+        JS_ASSERT(JSVAL_IS_NUMBER(v));
+        break;
+    default:
+        /* Convert the result to double if the builtin returns int32. */
+        if (JSVAL_IS_NUMBER(v) &&
+            (pendingTraceableNative->builtin->_argtypes & 3) == nanojit::ARGSIZE_LO) {
+            set(&v, lir->ins1(LIR_i2f, v_ins));
+        }
+    }
+
+    // We'll null pendingTraceableNative in js_MonitorRecording, on the next op cycle.
+    // There must be a next op since the stack is non-empty.
     return ok;
-}
-
-bool
-TraceRecorder::record_JSOP_RESUME()
-{
-    return true;
 }
 
 bool
@@ -5404,7 +5523,7 @@
                 if (sprop->shortid == REGEXP_LAST_INDEX)
                     ABORT_TRACE("can't trace regexp.lastIndex yet");
                 LIns* args[] = { INS_CONSTPTR(sprop), obj_ins, cx_ins };
-                v_ins = lir->insCall(&ci_CallGetter, args);
+                v_ins = lir->insCall(&js_CallGetter_ci, args);
                 guard(false, lir->ins2(LIR_eq, v_ins, INS_CONST(JSVAL_ERROR_COOKIE)), OOM_EXIT);
                 if (!unbox_jsval((sprop->shortid == REGEXP_SOURCE) ? JSVAL_STRING : JSVAL_BOOLEAN,
                                  v_ins)) {
@@ -5450,8 +5569,17 @@
     LIns* idx_ins = makeNumberInt32(get(&idx));
 
     LIns* dslots_ins = lir->insLoad(LIR_ldp, obj_ins, offsetof(JSObject, dslots));
-    if (!guardDenseArrayIndex(obj, i, obj_ins, dslots_ins, idx_ins))
-        return false;
+    if (!guardDenseArrayIndex(obj, i, obj_ins, dslots_ins, idx_ins, BRANCH_EXIT)) {
+        LIns* rt_ins = lir->insLoad(LIR_ldp, cx_ins, offsetof(JSContext, runtime));
+        guard(true, 
+              lir->ins_eq0(lir->insLoad(LIR_ldp, rt_ins,
+                                        offsetof(JSRuntime, anyArrayProtoHasElement))),
+              MISMATCH_EXIT);
+        // Return undefined and indicate that we didn't actually read this (addr_ins).
+        v_ins = lir->insImm(JSVAL_TO_BOOLEAN(JSVAL_VOID));
+        addr_ins = NULL; 
+        return true;
+    }
 
     // We can't "see through" a hole to a possible Array.prototype property, so
     // we abort here and guard below (after unboxing).
@@ -5473,7 +5601,7 @@
         guard(false, lir->ins2(LIR_eq, v_ins, INS_CONST(JSVAL_TO_BOOLEAN(JSVAL_HOLE))),
               MISMATCH_EXIT);
     }
-    return v_ins;
+    return true;
 }
 
 bool
@@ -5691,7 +5819,7 @@
     if (key == JSProto_Array) {
         if (!js_GetClassPrototype(cx, globalObj, INT_TO_JSID(key), &obj))
             return false;
-        ci = &ci_FastNewArray;
+        ci = &js_FastNewArray_ci;
     } else {
         jsval v_obj;
         if (!js_FindClassObject(cx, globalObj, INT_TO_JSID(key), &v_obj))
@@ -5699,7 +5827,7 @@
         if (JSVAL_IS_PRIMITIVE(v_obj))
             ABORT_TRACE("primitive Object value");
         obj = JSVAL_TO_OBJECT(v_obj);
-        ci = &ci_FastNewObject;
+        ci = &js_FastNewObject_ci;
     }
     LIns* args[] = { INS_CONSTPTR(obj), cx_ins };
     LIns* v_ins = lir->insCall(ci, args);
@@ -5719,9 +5847,9 @@
         if (obj->fslots[JSSLOT_ARRAY_LENGTH] == 1 &&
             obj->dslots && JSVAL_IS_STRING(obj->dslots[0])) {
             LIns* v_ins = get(&v);
-            JS_ASSERT(v_ins->isCall() && v_ins->callInfo() == &ci_FastNewArray);
+            JS_ASSERT(v_ins->isCall() && v_ins->callInfo() == &js_FastNewArray_ci);
             LIns* args[] = { stack(1), callArgN(v_ins, 1), cx_ins };
-            v_ins = lir->insCall(&ci_Array_1str, args);
+            v_ins = lir->insCall(&js_Array_1str_ci, args);
             set(&v, v_ins);
         }
     }
@@ -5808,7 +5936,7 @@
     if (!JSVAL_IS_PRIMITIVE(v)) {
         jsuint flags = cx->fp->regs->pc[1];
         LIns* args[] = { get(&v), INS_CONST(flags), cx_ins };
-        LIns* v_ins = lir->insCall(&ci_FastValueToIterator, args);
+        LIns* v_ins = lir->insCall(&js_FastValueToIterator_ci, args);
         guard(false, lir->ins_eq0(v_ins), MISMATCH_EXIT);
         set(&v, v_ins);
         return true;
@@ -5823,7 +5951,7 @@
     jsval& iterobj_val = stackval(-1);
     if (!JSVAL_IS_PRIMITIVE(iterobj_val)) {
         LIns* args[] = { get(&iterobj_val), cx_ins };
-        LIns* v_ins = lir->insCall(&ci_FastCallIteratorNext, args);
+        LIns* v_ins = lir->insCall(&js_FastCallIteratorNext_ci, args);
         guard(false, lir->ins2(LIR_eq, v_ins, INS_CONST(JSVAL_ERROR_COOKIE)), OOM_EXIT);
 
         LIns* flag_ins = lir->ins_eq0(lir->ins2(LIR_eq, v_ins, INS_CONST(JSVAL_HOLE)));
@@ -5846,7 +5974,7 @@
 TraceRecorder::record_JSOP_ENDITER()
 {
     LIns* args[] = { stack(-1), cx_ins };
-    LIns* ok_ins = lir->insCall(&ci_CloseIterator, args);
+    LIns* ok_ins = lir->insCall(&js_CloseIterator_ci, args);
     guard(false, lir->ins_eq0(ok_ins), MISMATCH_EXIT);
     return true;
 }
@@ -5972,7 +6100,7 @@
                 jsint idx = JSVAL_TO_INT(lval);
                 LIns* idx_ins = f2i(get(&lval));
                 LIns* dslots_ins = lir->insLoad(LIR_ldp, obj_ins, offsetof(JSObject, dslots));
-                if (!guardDenseArrayIndex(obj, idx, obj_ins, dslots_ins, idx_ins))
+                if (!guardDenseArrayIndex(obj, idx, obj_ins, dslots_ins, idx_ins, MISMATCH_EXIT))
                     ABORT_TRACE("dense array index out of bounds");
 
                 // We can't "see through" a hole to a possible Array.prototype
@@ -6010,7 +6138,7 @@
             OBJ_DROP_PROPERTY(cx, obj2, prop);
 
         LIns* args[] = { get(&lval), obj_ins, cx_ins };
-        x = lir->insCall(&ci_HasNamedProperty, args);
+        x = lir->insCall(&js_HasNamedProperty_ci, args);
         guard(false, lir->ins2i(LIR_eq, x, JSVAL_TO_BOOLEAN(JSVAL_VOID)), OOM_EXIT);
         x = lir->ins2i(LIR_eq, x, 1);
     } while (0);
@@ -6161,12 +6289,6 @@
 {
     var(GET_SLOTNO(cx->fp->regs->pc), stack(-1));
     return true;
-}
-
-bool
-TraceRecorder::record_JSOP_GROUP()
-{
-    return true; // no-op
 }
 
 bool
@@ -6935,18 +7057,20 @@
     return true;
 }
 
-#define UNUSED(op) bool TraceRecorder::record_##op() { return false; }
-
-UNUSED(JSOP_UNUSED76)
-UNUSED(JSOP_UNUSED77)
-UNUSED(JSOP_UNUSED78)
-UNUSED(JSOP_UNUSED79)
-UNUSED(JSOP_UNUSED201)
-UNUSED(JSOP_UNUSED202)
-UNUSED(JSOP_UNUSED203)
-UNUSED(JSOP_UNUSED204)
-UNUSED(JSOP_UNUSED205)
-UNUSED(JSOP_UNUSED206)
-UNUSED(JSOP_UNUSED207)
-UNUSED(JSOP_UNUSED219)
-UNUSED(JSOP_UNUSED226)
+#define UNUSED(n) bool TraceRecorder::record_JSOP_UNUSED##n() { return false; }
+
+UNUSED(74)
+UNUSED(76)
+UNUSED(77)
+UNUSED(78)
+UNUSED(79)
+UNUSED(131)
+UNUSED(201)
+UNUSED(202)
+UNUSED(203)
+UNUSED(204)
+UNUSED(205)
+UNUSED(206)
+UNUSED(207)
+UNUSED(219)
+UNUSED(226)
diff -r 17e9560465b0 js/src/jstracer.h
--- a/js/src/jstracer.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/jstracer.h	Thu Oct 30 05:41:45 2008 -0400
@@ -179,6 +179,7 @@
     unsigned                mismatchCount;
     Queue<nanojit::Fragment*> dependentTrees;
     unsigned                branchCount;
+    Queue<nanojit::SideExit*> sideExits;
 
     TreeInfo(nanojit::Fragment* _fragment) { 
         fragment = _fragment;
@@ -207,7 +208,7 @@
     char*                   entryTypeMap;
     unsigned                callDepth;
     JSAtom**                atoms;
-    nanojit::GuardRecord*   anchor;
+    nanojit::SideExit*      anchor;
     nanojit::Fragment*      fragment;
     TreeInfo*               treeInfo;
     nanojit::LirBuffer*     lirbuf;
@@ -226,7 +227,6 @@
     nanojit::LIns*          eor_ins;
     nanojit::LIns*          rval_ins;
     nanojit::LIns*          inner_sp_ins;
-    nanojit::SideExit       exit;
     bool                    deepAborted;
     bool                    applyingArguments;
     bool                    trashTree;
@@ -235,6 +235,7 @@
     jsval*                  global_dslots;
     JSTraceableNative*      pendingTraceableNative;
     bool                    terminate;
+    bool                    isRootFragment;
 
     bool isGlobal(jsval* p) const;
     ptrdiff_t nativeGlobalOffset(jsval* p) const;
@@ -248,6 +249,7 @@
     bool lazilyImportGlobalSlot(unsigned slot);
 
     nanojit::LIns* guard(bool expected, nanojit::LIns* cond, nanojit::ExitType exitType);
+    nanojit::LIns* guard(bool expected, nanojit::LIns* cond, nanojit::LIns* exit);
     nanojit::LIns* addName(nanojit::LIns* ins, const char* name);
 
     nanojit::LIns* get(jsval* p) const;
@@ -321,7 +323,8 @@
     bool guardClass(JSObject* obj, nanojit::LIns* obj_ins, JSClass* clasp);
     bool guardDenseArray(JSObject* obj, nanojit::LIns* obj_ins);
     bool guardDenseArrayIndex(JSObject* obj, jsint idx, nanojit::LIns* obj_ins,
-                              nanojit::LIns* dslots_ins, nanojit::LIns* idx_ins);
+                              nanojit::LIns* dslots_ins, nanojit::LIns* idx_ins, 
+                              nanojit::ExitType exitType);
     bool guardElemOp(JSObject* obj, nanojit::LIns* obj_ins, jsid id, size_t op_offset, jsval* vp);
     void clearFrameSlotsFromCache();
     bool guardShapelessCallee(jsval& callee);
@@ -336,13 +339,13 @@
 public:
     friend bool js_MonitorRecording(TraceRecorder* tr);
 
-    TraceRecorder(JSContext* cx, nanojit::GuardRecord*, nanojit::Fragment*, TreeInfo*,
+    TraceRecorder(JSContext* cx, nanojit::SideExit*, nanojit::Fragment*, TreeInfo*,
             unsigned ngslots, uint8* globalTypeMap, uint8* stackTypeMap, 
-            nanojit::GuardRecord* expectedInnerExit);
+            nanojit::SideExit* expectedInnerExit);
     ~TraceRecorder();
 
     uint8 determineSlotType(jsval* vp) const;
-    nanojit::SideExit* snapshot(nanojit::ExitType exitType);
+    nanojit::LIns* snapshot(nanojit::ExitType exitType);
     nanojit::Fragment* getFragment() const { return fragment; }
     bool isLoopHeader(JSContext* cx) const;
     void compile(nanojit::Fragmento* fragmento);
@@ -352,8 +355,9 @@
     bool adjustCallerTypes(nanojit::Fragment* f);
     bool selectCallablePeerFragment(nanojit::Fragment** first);
     void prepareTreeCall(nanojit::Fragment* inner);
-    void emitTreeCall(nanojit::Fragment* inner, nanojit::GuardRecord* lr);
+    void emitTreeCall(nanojit::Fragment* inner, nanojit::SideExit* exit);
     unsigned getCallDepth() const;
+    void safeCleanup();
     
     bool record_EnterFrame();
     bool record_LeaveFrame();
diff -r 17e9560465b0 js/src/jsxdrapi.h
--- a/js/src/jsxdrapi.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/jsxdrapi.h	Thu Oct 30 05:41:45 2008 -0400
@@ -204,7 +204,7 @@
  * before deserialization of bytecode.  If the saved version does not match
  * the current version, abort deserialization and invalidate the file.
  */
-#define JSXDR_BYTECODE_VERSION      (0xb973c0de - 32)
+#define JSXDR_BYTECODE_VERSION      (0xb973c0de - 35)
 
 /*
  * Library-private functions.
diff -r 17e9560465b0 js/src/nanojit/Assembler.cpp
--- a/js/src/nanojit/Assembler.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/nanojit/Assembler.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -38,31 +38,46 @@
 
 #include "nanojit.h"
 
+#ifdef FEATURE_NANOJIT
+
 #ifdef AVMPLUS_PORTING_API
 #include "portapi_nanojit.h"
 #endif
 
-#if defined(AVMPLUS_LINUX) && defined(AVMPLUS_ARM)
+#if defined(AVMPLUS_UNIX) && defined(AVMPLUS_ARM)
 #include <asm/unistd.h>
 extern "C" void __clear_cache(char *BEG, char *END);
 #endif
 
 namespace nanojit
 {
-	#ifdef FEATURE_NANOJIT
 
 
 	class DeadCodeFilter: public LirFilter
 	{
-		Assembler *assm;
-	public:
-		DeadCodeFilter(LirFilter *in, Assembler *a) : LirFilter(in), assm(a) {}
+		const CallInfo *functions;
+
+	    bool ignoreInstruction(LInsp ins)
+	    {
+            LOpcode op = ins->opcode();
+            if (ins->isStore() ||
+                op == LIR_loop ||
+                op == LIR_label ||
+                op == LIR_live ||
+                isRet(op)) {
+                return false;
+            }
+	        return ins->resv() == 0;
+	    }
+
+	public:		
+		DeadCodeFilter(LirFilter *in, const CallInfo *f) : LirFilter(in), functions(f) {}
 		LInsp read() {
 			for (;;) {
 				LInsp i = in->read();
-				if (!i || i->isGuard() 
-					|| i->isCall() && !i->callInfo()->_cse
-					|| !assm->ignoreInstruction(i))
+				if (!i || i->isGuard() || i->isBranch()
+					|| i->isCall() && !i->isCse(functions)
+					|| !ignoreInstruction(i))
 					return i;
 			}
 		}
@@ -74,18 +89,31 @@
 		Assembler *assm;
 		LirNameMap *names;
 		avmplus::List<LInsp, avmplus::LIST_NonGCObjects> block;
+        bool flushnext;
 	public:
 		VerboseBlockReader(LirFilter *in, Assembler *a, LirNameMap *n) 
-			: LirFilter(in), assm(a), names(n), block(a->_gc) {}
+			: LirFilter(in), assm(a), names(n), block(a->_gc), flushnext(false)
+        {}
 
 		void flush() {
-			assm->outputf("        %p:", assm->_nIns);
-			assm->output("");
-			for (int j=0,n=block.size(); j < n; j++)
-				assm->outputf("    %s", names->formatIns(block[j]));
-			assm->output("");
-			block.clear();
+            flushnext = false;
+            if (!block.isEmpty()) {
+			    for (int j=0,n=block.size(); j < n; j++) {
+					LIns *i = block[j];
+				    assm->outputf("    %s", names->formatIns(block[j]));
+					if (i->isop(LIR_label)) {
+						assm->outputf("        %p:", assm->_nIns);
+						assm->output("");
+					}
+				}
+			    block.clear();
+            }
 		}
+
+        void flush_add(LInsp i) {
+            flush();
+            block.add(i);
+        }
 
 		LInsp read() {
 			LInsp i = in->read();
@@ -93,14 +121,20 @@
 				flush();
 				return i;
 			}
-			if (i->isGuard()) {
-				flush();
-				block.add(i);
+            if (i->isGuard()) {
+				flush_add(i);
 				if (i->oprnd1())
 					block.add(i->oprnd1());
-			}
+            }
+            else if (isRet(i->opcode()) || i->isBranch()) {
+                flush_add(i);
+            }
 			else {
-				block.add(i);
+                if (flushnext)
+                    flush();
+				flush_add(i);//block.add(i);
+                if (i->isop(LIR_label))
+                    flushnext = true;
 			}
 			return i;
 		}
@@ -113,8 +147,12 @@
 	 *	- merging paths ( build a graph? ), possibly use external rep to drive codegen
 	 */
     Assembler::Assembler(Fragmento* frago)
-        : _frago(frago)
+        : hasLoop(0)
+		, _frago(frago)
         , _gc(frago->core()->gc)
+        , _labels(_gc)
+        , _patches(_gc)
+        , pending_lives(_gc)
 	{
         AvmCore *core = frago->core();
 		nInit(core);
@@ -133,8 +171,6 @@
 
 		for(uint32_t i=0; i<NJ_MAX_STACK_ENTRY; i++)
 			_activation.entry[i] = 0;
-		for(uint32_t i=0; i<NJ_MAX_PARAMETERS; i++)
-			_activation.parameter[i] = 0;
 	}
 
  	void Assembler::registerResetAll()
@@ -178,7 +214,7 @@
 
 		// nothing free, steal one 
 		// LSRA says pick the one with the furthest use
-		LIns* vic = findVictim(regs,allow,prefer);
+		LIns* vic = findVictim(regs, allow);
 		NanoAssert(vic != NULL);
 
 	    Reservation* resv = getresv(vic);
@@ -196,10 +232,20 @@
 	{
 		_resvTable[0].arIndex = 0;
 		int i;
-		for(i=1; i<NJ_MAX_STACK_ENTRY; i++)
+        for(i=1; i<NJ_MAX_STACK_ENTRY; i++) {
 			_resvTable[i].arIndex = i-1;
+            _resvTable[i].used = 0;
+        }
 		_resvFree= i-1;
 	}
+
+    /**
+     * these instructions don't have to be saved & reloaded to spill,
+     * they can just be recalculated w/out any inputs.
+     */
+    bool Assembler::canRemat(LIns *i) {
+        return i->isconst() || i->isconstq() || i->isop(LIR_alloc);
+    }
 
 	Reservation* Assembler::reserveAlloc(LInsp i)
 	{
@@ -208,16 +254,9 @@
 		_resvFree = r->arIndex;
 		r->reg = UnknownReg;
 		r->arIndex = 0;
+        r->used = 1;
 		if (!item) 
 			setError(ResvFull); 
-
-        if (i->isconst() || i->isconstq())
-            r->cost = 0;
-        else if (i == _thisfrag->lirbuf->sp || i == _thisfrag->lirbuf->rp)
-            r->cost = 2;
-        else
-            r->cost = 1;
-
         i->setresv(item);
 		return r;
 	}
@@ -227,6 +266,7 @@
         Reservation *rs = getresv(i);
         NanoAssert(rs == &_resvTable[i->resv()]);
 		rs->arIndex = _resvFree;
+        rs->used = 0;
 		_resvFree = i->resv();
         i->setresv(0);
 	}
@@ -237,6 +277,7 @@
 		registerResetAll();
 		reserveReset();
 		arReset();
+        pending_lives.clear();
 	}
 
 	NIns* Assembler::pageAlloc(bool exitPage)
@@ -248,6 +289,7 @@
 			page->next = list;
 			list = page;
 			nMarkExecute(page);
+			_stats.pages++;
 		}
 		else
 		{
@@ -265,6 +307,7 @@
 		
 		_nIns = 0;
 		_nExitIns = 0;
+		_stats.pages = 0;
 
 		nativePageReset();
 	}
@@ -279,6 +322,45 @@
 		}
 	}
 
+	#define bytesFromTop(x)		( (size_t)(x) - (size_t)pageTop(x) )
+	#define bytesToBottom(x)	( (size_t)pageBottom(x) - (size_t)(x) )
+	#define bytesBetween(x,y)	( (size_t)(x) - (size_t)(y) )
+	
+	int32_t Assembler::codeBytes()
+	{
+		// start and end on same page?
+		size_t exit = 0;
+		int32_t pages = _stats.pages;
+		if (_nExitIns-1 == _stats.codeExitStart)
+			;
+		else if (samepage(_nExitIns,_stats.codeExitStart))
+			exit = bytesBetween(_stats.codeExitStart, _nExitIns);
+		else
+		{
+			pages--;
+			exit = ((intptr_t)_stats.codeExitStart & (NJ_PAGE_SIZE-1)) ? bytesFromTop(_stats.codeExitStart)+1 : 0;
+			exit += bytesToBottom(_nExitIns)+1;
+		}
+
+		size_t main = 0;
+		if (_nIns-1 == _stats.codeStart)
+			;
+		else if (samepage(_nIns,_stats.codeStart))
+			main = bytesBetween(_stats.codeStart, _nIns);
+		else
+		{
+			pages--;
+			main = ((intptr_t)_stats.codeStart & (NJ_PAGE_SIZE-1)) ? bytesFromTop(_stats.codeStart)+1 : 0;
+			main += bytesToBottom(_nIns)+1;
+		}
+		//fprintf(stderr,"size %d, exit is %d, main is %d, page count %d, sizeof %d\n", (int)((pages) * NJ_PAGE_SIZE + main + exit),(int)exit, (int)main, (int)_stats.pages, (int)sizeof(Page));
+		return (pages) * NJ_PAGE_SIZE + main + exit;		
+	}
+
+	#undef bytesFromTop
+	#undef bytesToBottom
+	#undef byteBetween
+	
 	Page* Assembler::handoverPages(bool exitPages)
 	{
 		Page*& list = (exitPages) ? _nativeExitPages : _nativePages;
@@ -288,7 +370,7 @@
 		ins = 0;
 		return start;
 	}
-	
+
 	#ifdef _DEBUG
 	bool Assembler::onPage(NIns* where, bool exitPages)
 	{
@@ -323,56 +405,59 @@
             !_allocator.active[FST0] && _fpuStkDepth == 0);
 #endif
 		
-		// for tracking resv usage
-		LIns* resv[NJ_MAX_STACK_ENTRY];
-		for(int i=0; i<NJ_MAX_STACK_ENTRY; i++)
-			resv[i]=0;
-			
+        AR &ar = _activation;
 		// check AR entries
-		NanoAssert(_activation.highwatermark < NJ_MAX_STACK_ENTRY);
+		NanoAssert(ar.highwatermark < NJ_MAX_STACK_ENTRY);
 		LIns* ins = 0;
 		RegAlloc* regs = &_allocator;
-		for(uint32_t i=_activation.lowwatermark; i<_activation.tos; i++)
+		for(uint32_t i = ar.lowwatermark; i < ar.tos; i++)
 		{
-			ins = _activation.entry[i];
+			ins = ar.entry[i];
 			if ( !ins )
 				continue;
 			Reservation *r = getresv(ins);
+            NanoAssert(r != 0);
 			int32_t idx = r - _resvTable;
-			resv[idx]=ins;
 			NanoAssertMsg(idx, "MUST have a resource for the instruction for it to have a stack location assigned to it");
-			NanoAssertMsg( r->arIndex==0 || r->arIndex==i || (ins->isQuad()&&r->arIndex==i-(stack_direction(1))), "Stack record index mismatch");
+            if (r->arIndex) {
+                if (ins->isop(LIR_alloc)) {
+                    int j=i+1;
+                    for (int n = i + (ins->size()>>2); j < n; j++) {
+                        NanoAssert(ar.entry[j]==ins);
+                    }
+		        	NanoAssert(r->arIndex == (uint32_t)j-1);
+                    i = j-1;
+                }
+                else if (ins->isQuad()) {
+                    NanoAssert(ar.entry[i - stack_direction(1)]==ins);
+                    i += 1; // skip high word
+                }
+                else {
+        			NanoAssertMsg(r->arIndex == i, "Stack record index mismatch");
+                }
+            }
 			NanoAssertMsg( r->reg==UnknownReg || regs->isConsistent(r->reg,ins), "Register record mismatch");
 		}
 	
-		registerConsistencyCheck(resv);
+		registerConsistencyCheck();
 				
 		// check resv table
 		int32_t inuseCount = 0;
 		int32_t notInuseCount = 0;
-		for(uint32_t i=1; i<NJ_MAX_STACK_ENTRY; i++)
-		{
-			if (resv[i]==0)
-			{
-				notInuseCount++;
-			}
-			else
-			{
-				inuseCount++;
-			}
-		}
+        for(uint32_t i=1; i < sizeof(_resvTable)/sizeof(_resvTable[0]); i++) {
+            _resvTable[i].used ? inuseCount++ : notInuseCount++;
+        }
 
 		int32_t freeCount = 0;
 		uint32_t free = _resvFree;
-		while(free)
-		{
+        while(free) {
 			free = _resvTable[free].arIndex;
 			freeCount++;
 		}
 		NanoAssert( ( freeCount==notInuseCount && inuseCount+notInuseCount==(NJ_MAX_STACK_ENTRY-1) ) );
 	}
 
-	void Assembler::registerConsistencyCheck(LIns** resv)
+	void Assembler::registerConsistencyCheck()
 	{	
 		// check registers
 		RegAlloc *regs = &_allocator;
@@ -391,12 +476,10 @@
 					LIns* ins = regs->getActive(r);
 					// @todo we should be able to check across RegAlloc's somehow (to include savedGP...)
 					Reservation *v = getresv(ins);
-					NanoAssert(v);
+					NanoAssert(v != 0);
 					int32_t idx = v - _resvTable;
 					NanoAssert(idx >= 0 && idx < NJ_MAX_STACK_ENTRY);
-					resv[idx]=ins;
 					NanoAssertMsg(idx, "MUST have a resource for the instruction for it to have a register assigned to it");
-					NanoAssertMsg( v->arIndex==0 || ins==_activation.entry[v->arIndex], "Stack record index mismatch");
 					NanoAssertMsg( regs->getActive(v->reg)==ins, "Register record mismatch");
 				}			
 			}
@@ -418,18 +501,25 @@
 		else
 		{
 			Register rb = UnknownReg;
-			resvb = getresv(ib);
-			if (resvb && (rb = resvb->reg) != UnknownReg)
-				allow &= ~rmask(rb);
-			Register ra = findRegFor(ia, allow);
-			resva = getresv(ia);
-			NanoAssert(error() || (resva != 0 && ra != UnknownReg));
-			if (rb == UnknownReg)
-			{
-				allow &= ~rmask(ra);
-				findRegFor(ib, allow);
-				resvb = getresv(ib);
-			}
+            resvb = getresv(ib);
+            if (resvb && (rb = resvb->reg) != UnknownReg) {
+                if (allow & rmask(rb)) {
+                    // ib already assigned to an allowable reg, keep that one
+                    allow &= ~rmask(rb);
+                } else {
+                    // ib assigned to unusable reg, pick a different one below.
+                    rb = UnknownReg;
+                }
+            }
+            Register ra = findRegFor(ia, allow);
+            resva = getresv(ia);
+            NanoAssert(error() || (resva != 0 && ra != UnknownReg));
+            if (rb == UnknownReg)
+            {
+                allow &= ~rmask(ra);
+                findRegFor(ib, allow);
+                resvb = getresv(ib);
+            }
 		}
 	}
 
@@ -437,16 +527,32 @@
 	{
 		return findRegFor(i, rmask(w));
 	}
+
+    Register Assembler::getBaseReg(LIns *i, int &d, RegisterMask allow)
+    {
+        if (i->isop(LIR_alloc)) {
+            d += findMemFor(i);
+            return FP;
+        } else {
+            return findRegFor(i, allow);
+        }
+    }
 			
 	Register Assembler::findRegFor(LIns* i, RegisterMask allow)
 	{
-		Reservation* resv = getresv(i);
+        if (i->isop(LIR_alloc)) {
+            // never allocate a reg for this w/out stack space too
+            findMemFor(i);
+        }
+
+        Reservation* resv = getresv(i);
 		Register r;
 
 		// if we have an existing reservation and it has a non-unknown
 		// register allocated, and that register is in our allowed mask,
 		// return it.
         if (resv && (r=resv->reg) != UnknownReg && (rmask(r) & allow)) {
+            _allocator.useActive(r);
 			return r;
         }
 
@@ -454,37 +560,42 @@
 		RegisterMask prefer = hint(i, allow);
 
 		// if we didn't have a reservation, allocate one now
-		if (!resv) 	
+        if (!resv)
 			resv = reserveAlloc(i);
 
-		// if the reservation doesn't have a register assigned to it...
-        if ((r=resv->reg) == UnknownReg)
+        r = resv->reg;
+
+#ifdef AVMPLUS_IA32
+        if (r != UnknownReg && 
+            ((rmask(r)&XmmRegs) && !(allow&XmmRegs) ||
+                 (rmask(r)&x87Regs) && !(allow&x87Regs)))
+        {
+            // x87 <-> xmm copy required
+            //_nvprof("fpu-evict",1);
+            evict(r);
+            r = UnknownReg;
+        }
+#endif
+
+        if (r == UnknownReg)
 		{
-			// .. if the cost is 2 and the allowed mask includes
-			// the saved regs, then prefer just those.
-            if (resv->cost == 2 && (allow&SavedRegs))
-                prefer = allow&SavedRegs;
-			// grab one.
 			r = resv->reg = registerAlloc(prefer);
 			_allocator.addActive(r, i);
 			return r;
 		}
-		else 
+		else
 		{
 			// the already-allocated register isn't in the allowed mask;
 			// we need to grab a new one and then copy over the old
 			// contents to the new.
 			resv->reg = UnknownReg;
 			_allocator.retire(r);
-            if (resv->cost == 2 && (allow&SavedRegs))
-                prefer = allow&SavedRegs;
 			Register s = resv->reg = registerAlloc(prefer);
 			_allocator.addActive(s, i);
             if ((rmask(r) & GpRegs) && (rmask(s) & GpRegs)) {
     			MR(r, s);
             } 
-			else
-			{
+            else {
 				asm_nongp_copy(r, s);
 			}
 			return s;
@@ -496,8 +607,10 @@
 		Reservation* resv = getresv(i);
 		if (!resv)
 			resv = reserveAlloc(i);
-		if (!resv->arIndex)
+        if (!resv->arIndex) {
 			resv->arIndex = arReserve(i);
+            NanoAssert(resv->arIndex <= _activation.highwatermark);
+        }
 		return disp(resv);
 	}
 
@@ -510,6 +623,20 @@
 		return rr;
 	}
 
+	void Assembler::asm_spilli(LInsp i, Reservation *resv, bool pop)
+	{
+		int d = disp(resv);
+		Register rr = resv->reg;
+		bool quad = i->opcode() == LIR_param || i->isQuad();
+		asm_spill(rr, d, pop, quad);
+		if (d) 
+		{
+			verbose_only(if (_verbose) {
+				outputf("        spill %s",_thisfrag->lirbuf->names->formatRef(i));
+			})
+		}
+	}
+
 	void Assembler::freeRsrcOf(LIns *i, bool pop)
 	{
 		Reservation* resv = getresv(i);
@@ -518,10 +645,11 @@
 
 		if (rr != UnknownReg)
 		{
-			asm_spill(i, resv, pop);
+			asm_spilli(i, resv, pop);
 			_allocator.retire(rr);	// free any register associated with entry
 		}
-		arFree(index);			// free any stack stack space associated with entry
+		if (index)
+            arFree(index);			// free any stack stack space associated with entry
 		reserveFree(i);		// clear fields of entry and add it to free list
 	}
 
@@ -531,83 +659,28 @@
 		_allocator.addFree(r);
 	}
 
-	void Assembler::asm_cmp(LIns *cond)
-	{
-        LOpcode condop = cond->opcode();
-        
-        // LIR_ov and LIR_cs recycle the flags set by arithmetic ops
-        if ((condop == LIR_ov) || (condop == LIR_cs))
-            return;
-        
-        LInsp lhs = cond->oprnd1();
-		LInsp rhs = cond->oprnd2();
-		Reservation *rA, *rB;
-
-		// Not supported yet.
-#if !defined NANOJIT_64BIT
-		NanoAssert(!lhs->isQuad() && !rhs->isQuad());
-#endif
-
-		// ready to issue the compare
-		if (rhs->isconst())
-		{
-			int c = rhs->constval();
-			Register r = findRegFor(lhs, GpRegs);
-			if (c == 0 && cond->isop(LIR_eq)) {
-				if (rhs->isQuad() || lhs->isQuad()) {
-#if defined NANOJIT_64BIT
-					TESTQ(r, r);
-#endif
-				} else {
-					TEST(r,r);
-				}
-#if defined NANOJIT_64BIT
-			} else if (rhs->isQuad() || lhs->isQuad()) {
-                findRegFor2(GpRegs, lhs, rA, rhs, rB);
-                Register ra = rA->reg;
-                Register rb = rB->reg;
-                CMPQ(ra,rb);
-#endif
-            } else {
-				CMPi(r, c);
-            }
-		}
-		else
-		{
-			findRegFor2(GpRegs, lhs, rA, rhs, rB);
-			Register ra = rA->reg;
-			Register rb = rB->reg;
-			if (rhs->isQuad() || lhs->isQuad()) {
-#if defined NANOJIT_64BIT
-				CMPQ(ra, rb);
-#endif
-			} else {
-				CMP(ra, rb);
-			}
-		}
-	}
-
     void Assembler::patch(GuardRecord *lr)
     {
-        Fragment *frag = lr->target;
-		NanoAssert(frag->fragEntry);
+        Fragment *frag = lr->exit->target;
+		NanoAssert(frag->fragEntry != 0);
 		NIns* was = asm_adjustBranch((NIns*)lr->jmp, frag->fragEntry);
-		if (!lr->origTarget) lr->origTarget = was;
 		verbose_only(verbose_outputf("patching jump at %p to target %p (was %p)\n",
 			lr->jmp, frag->fragEntry, was);)
     }
 
-    void Assembler::unpatch(GuardRecord *lr)
+    void Assembler::patch(SideExit *exit)
     {
-		NIns* was = asm_adjustBranch((NIns*)lr->jmp, (NIns*)lr->origTarget);
-		(void)was;
-		verbose_only(verbose_outputf("unpatching jump at %p to original target %p (was %p)\n",
-			lr->jmp, lr->origTarget, was);)
+        GuardRecord *rec = exit->guards;
+        AvmAssert(rec);
+        while (rec) {
+            patch(rec);
+            rec = rec->next;
+        }
     }
-
+    
     NIns* Assembler::asm_exit(LInsp guard)
     {
-		SideExit *exit = guard->exit();
+		SideExit *exit = guard->record()->exit;
 		NIns* at = 0;
 		if (!_branchStateMap->get(exit))
 		{
@@ -616,14 +689,14 @@
 		else
 		{
 			RegAlloc* captured = _branchStateMap->get(exit);
-			mergeRegisterState(*captured);
+			intersectRegisterState(*captured);
 			verbose_only(
 				verbose_outputf("        merging trunk with %s",
 					_frago->labels->format(exit->target));
 				verbose_outputf("        %p:",_nIns);
 			)			
 			at = exit->target->fragEntry;
-			NanoAssert(at);
+			NanoAssert(at != 0);
 			_branchStateMap->remove(exit);
 		}
 		return at;
@@ -634,13 +707,13 @@
         verbose_only(bool priorVerbose = _verbose; )
 		verbose_only( _verbose = verbose_enabled() && _frago->core()->config.verbose_exits; )
         verbose_only( int32_t nativeSave = _stats.native );
-		verbose_only(verbose_outputf("--------------------------------------- end exit block SID %d", guard->exit()->sid);)
+		verbose_only(verbose_outputf("--------------------------------------- end exit block %p", guard);)
 
 		RegAlloc capture = _allocator;
 
         // this point is unreachable.  so free all the registers.
 		// if an instruction has a stack entry we will leave it alone,
-		// otherwise we free it entirely.  mergeRegisterState will restore.
+		// otherwise we free it entirely.  intersectRegisterState will restore.
 		releaseRegisters();
 		
 		swapptrs();
@@ -651,13 +724,14 @@
 
 		nFragExit(guard);
 
-		// if/when we patch this exit to jump over to another fragment,
-		// that fragment will need its parameters set up just like ours.
-        LInsp stateins = _thisfrag->lirbuf->state;
-		Register state = findSpecificRegFor(stateins, Register(stateins->imm8()));
-		asm_bailout(guard, state);
+		// restore the callee-saved register (aka saved params)
+		assignSavedParams();
 
-		mergeRegisterState(capture);
+        // restore first parameter, the only one we use
+        LInsp state = _thisfrag->lirbuf->state;
+        findSpecificRegFor(state, argRegs[state->imm8()]); 
+
+		intersectRegisterState(capture);
 
 		// this can be useful for breaking whenever an exit is taken
 		//INT3();
@@ -685,20 +759,12 @@
         return jmpTarget;
     }
 	
-	bool Assembler::ignoreInstruction(LInsp ins)
+	void Assembler::beginAssembly(Fragment *frag, RegAllocMap* branchStateMap)
 	{
-        LOpcode op = ins->opcode();
-        if (ins->isStore() || op == LIR_loop)
-            return false;
-	    return getresv(ins) == 0;
-	}
-
-	void Assembler::beginAssembly(Fragment* frag, RegAllocMap* branchStateMap)
-	{
+        _thisfrag = frag;
 		_activation.lowwatermark = 1;
 		_activation.tos = _activation.lowwatermark;
 		_activation.highwatermark = _activation.tos;
-        _thisfrag = frag;
 		
 		counter_reset(native);
 		counter_reset(exitnative);
@@ -719,9 +785,18 @@
 		// make sure we got memory at least one page
 		if (error()) return;
 			
-        _epilogue = genEpilogue(SavedRegs);
+#ifdef PERFM
+		_stats.pages = 0;
+		_stats.codeStart = _nIns-1;
+		_stats.codeExitStart = _nExitIns-1;		
+		//fprintf(stderr,"pageReset %d start %x exit start %x\n", _stats.pages, (int)_stats.codeStart, (int)_stats.codeExitStart);
+#endif /* PERFM */
+
+        _epilogue = genEpilogue();
 		_branchStateMap = branchStateMap;
-		
+        _labels.clear();
+        _patches.clear();
+
 		verbose_only( verbose_outputf("        %p:",_nIns) );
 		verbose_only( verbose_output("        epilogue:") );
 	}
@@ -730,14 +805,14 @@
 	{
 		if (error()) return;	
 		AvmCore *core = _frago->core();
-		GC *gc = core->gc;
         _thisfrag = frag;
 
 		// set up backwards pipeline: assembler -> StackFilter -> LirReader
 		LirReader bufreader(frag->lastIns);
-		StackFilter storefilter1(&bufreader, gc, frag, frag->lirbuf->sp);
-		StackFilter storefilter2(&storefilter1, gc, frag, frag->lirbuf->rp);
-		DeadCodeFilter deadfilter(&storefilter2, this);
+		GC *gc = core->gc;
+		StackFilter storefilter1(&bufreader, gc, frag->lirbuf, frag->lirbuf->sp);
+		StackFilter storefilter2(&storefilter1, gc, frag->lirbuf, frag->lirbuf->rp);
+		DeadCodeFilter deadfilter(&storefilter2, frag->lirbuf->_functions);
 		LirFilter* rdr = &deadfilter;
 		verbose_only(
 			VerboseBlockReader vbr(rdr, this, frag->lirbuf->names);
@@ -748,26 +823,52 @@
 		verbose_only(_thisfrag->compileNbr++; )
 		verbose_only(_frago->_stats.compiles++; )
 		verbose_only(_frago->_stats.totalCompiles++; )
-		_latestGuard = 0;
-		_inExit = false;		
-		gen(rdr, loopJumps);
+		_inExit = false;	
+        gen(rdr, loopJumps);
 		frag->fragEntry = _nIns;
-		frag->outbound = core->config.tree_opt? _latestGuard : 0;
+		//frag->outbound = core->config.tree_opt? _latestGuard : 0;
 		//fprintf(stderr, "assemble frag %X entry %X\n", (int)frag, (int)frag->fragEntry);
+
+        if (!error()) {
+		    // patch all branches
+		    while(!_patches.isEmpty())
+		    {
+			    NIns* where = _patches.lastKey();
+			    LInsp targ = _patches.removeLast();
+                LabelState *label = _labels.get(targ);
+			    NIns* ntarg = label->addr;
+                if (ntarg) {
+				    nPatchBranch(where,ntarg);
+			    }
+                else {
+				    _err = UnknownBranch;
+				    break;
+			    }
+		    }
+        }
 	}
 
 	void Assembler::endAssembly(Fragment* frag, NInsList& loopJumps)
 	{
+	    NIns* SOT = 0;
+	    if (frag->isRoot()) {
+	        SOT = _nIns;
+            verbose_only( verbose_outputf("        %p:",_nIns); )
+	    } else {
+	        SOT = frag->root->fragEntry;
+	    }
+        AvmAssert(SOT);
 		while(!loopJumps.isEmpty())
 		{
 			NIns* loopJump = (NIns*)loopJumps.removeLast();
-			nPatchBranch(loopJump, _nIns);
+            verbose_only( verbose_outputf("patching %p to %p", loopJump, SOT); )
+			nPatchBranch(loopJump, SOT);
 		}
 
 		NIns* patchEntry = 0;
 		if (!error())
 		{
-			patchEntry = genPrologue(SavedRegs);
+			patchEntry = genPrologue();
 			verbose_only( verbose_outputf("        %p:",_nIns); )
 			verbose_only( verbose_output("        prologue"); )
 		}
@@ -784,15 +885,16 @@
 
             frag->fragEntry = patchEntry;
 			NIns* code = _nIns;
-			
+#ifdef PERFM
+			_nvprof("code", codeBytes());  // requires that all pages are released between begin/endAssembly()otherwise we double count
+#endif
 			// let the fragment manage the pages if we're using trees and there are branches
-			Page* manage = (_frago->core()->config.tree_opt) ? handoverPages() : 0;
+			Page* manage = (_frago->core()->config.tree_opt) ? handoverPages() : 0;			
 			frag->setCode(code, manage); // root of tree should manage all pages
-			NanoAssert(!_frago->core()->config.tree_opt || frag == frag->anchor || frag->kind == MergeTrace);			
 			//fprintf(stderr, "endAssembly frag %X entry %X\n", (int)frag, (int)frag->fragEntry);
 		}
 		
-		AvmAssertMsg(error() || _fpuStkDepth == 0, ("_fpuStkDepth %d\n",_fpuStkDepth));
+		NanoAssertMsgf(error() || _fpuStkDepth == 0,"_fpuStkDepth %d\n",_fpuStkDepth);
 
 		internalReset();  // clear the reservation tables and regalloc
 		NanoAssert(_branchStateMap->isEmpty());
@@ -803,7 +905,7 @@
 		// to execute junk
 # if defined(UNDER_CE)
 		FlushInstructionCache(GetCurrentProcess(), NULL, NULL);
-# elif defined(AVMPLUS_LINUX)
+# elif defined(AVMPLUS_UNIX)
 		for (int i = 0; i < 2; i++) {
 			Page *p = (i == 0) ? _nativePages : _nativeExitPages;
 
@@ -851,7 +953,61 @@
 			}
 		}
 	}
-	
+
+#ifdef PERFM
+#define countlir_live() _nvprof("lir-live",1)
+#define countlir_ret() _nvprof("lir-ret",1)
+#define countlir_alloc() _nvprof("lir-alloc",1)
+#define countlir_var() _nvprof("lir-var",1)
+#define countlir_use() _nvprof("lir-use",1)
+#define countlir_def() _nvprof("lir-def",1)
+#define countlir_imm() _nvprof("lir-imm",1)
+#define countlir_param() _nvprof("lir-param",1)
+#define countlir_cmov() _nvprof("lir-cmov",1)
+#define countlir_ld() _nvprof("lir-ld",1)
+#define countlir_ldq() _nvprof("lir-ldq",1)
+#define countlir_alu() _nvprof("lir-alu",1)
+#define countlir_qjoin() _nvprof("lir-qjoin",1)
+#define countlir_qlo() _nvprof("lir-qlo",1)
+#define countlir_qhi() _nvprof("lir-qhi",1)
+#define countlir_fpu() _nvprof("lir-fpu",1)
+#define countlir_st() _nvprof("lir-st",1)
+#define countlir_stq() _nvprof("lir-stq",1)
+#define countlir_jmp() _nvprof("lir-jmp",1)
+#define countlir_jcc() _nvprof("lir-jcc",1)
+#define countlir_label() _nvprof("lir-label",1)
+#define countlir_xcc() _nvprof("lir-xcc",1)
+#define countlir_x() _nvprof("lir-x",1)
+#define countlir_loop() _nvprof("lir-loop",1)
+#define countlir_call() _nvprof("lir-call",1)
+#else
+#define countlir_live()
+#define countlir_ret()
+#define countlir_alloc()
+#define countlir_var()
+#define countlir_use()
+#define countlir_def()
+#define countlir_imm()
+#define countlir_param()
+#define countlir_cmov()
+#define countlir_ld()
+#define countlir_ldq()
+#define countlir_alu()
+#define countlir_qjoin()
+#define countlir_qlo()
+#define countlir_qhi()
+#define countlir_fpu()
+#define countlir_st()
+#define countlir_stq()
+#define countlir_jmp()
+#define countlir_jcc()
+#define countlir_label()
+#define countlir_xcc()
+#define countlir_x()
+#define countlir_loop()
+#define countlir_call()
+#endif
+
 	void Assembler::gen(LirFilter* reader,  NInsList& loopJumps)
 	{
 		// trace must start with LIR_x or LIR_loop
@@ -859,7 +1015,6 @@
 		 
 		for (LInsp ins = reader->read(); ins != 0 && !error(); ins = reader->read())
 		{
-    		Reservation *rR = getresv(ins);
 			LOpcode op = ins->opcode();			
 			switch(op)
 			{
@@ -867,23 +1022,73 @@
 					NanoAssertMsgf(false, "unsupported LIR instruction: %d (~0x40: %d)\n", op, op&~LIR64);
 					break;
 					
+                case LIR_live: {
+                    countlir_live();
+                    pending_lives.add(ins->oprnd1());
+                    break;
+                }
+
+                case LIR_ret:  {
+                    countlir_ret();
+                    if (_nIns != _epilogue) {
+                        JMP(_epilogue);
+                    }
+                    assignSavedParams();
+#ifdef NANOJIT_ARM
+                    // the epilogue moves R2 to R0; we may want to do this
+                    // after assignSavedParams
+                    findSpecificRegFor(ins->oprnd1(), R2);
+#else
+                    findSpecificRegFor(ins->oprnd1(), retRegs[0]);
+#endif
+                    break;
+                }
+
+                case LIR_fret: {
+                    countlir_ret();
+                    if (_nIns != _epilogue) {
+                        JMP(_epilogue);
+                    }
+                    assignSavedParams();
+#ifdef NANOJIT_IA32
+                    findSpecificRegFor(ins->oprnd1(), FST0);
+#else
+                    NanoAssert(false);
+#endif
+                    fpu_pop();
+                    break;
+                }
+
+                // allocate some stack space.  the value of this instruction
+                // is the address of the stack space.
+                case LIR_alloc: {
+                    countlir_alloc();
+                    Reservation *resv = getresv(ins);
+                    NanoAssert(resv->arIndex != 0);
+                    Register r = resv->reg;
+                    if (r != UnknownReg) {
+    			        _allocator.retire(r);
+                        resv->reg = UnknownReg;
+                        asm_restore(ins, resv, r);
+                    }
+                    freeRsrcOf(ins, 0);
+                    break;
+                }
 				case LIR_short:
+				{
+                    countlir_imm();
+					asm_short(ins);
+					break;
+				}
 				case LIR_int:
 				{
-					Register rr = prepResultReg(ins, GpRegs);
-					int32_t val;
-					if (op == LIR_int)
-						val = ins->imm32();
-					else
-						val = ins->imm16();
-					if (val == 0)
-						XOR(rr,rr);
-					else
-						LDi(rr, val);
+                    countlir_imm();
+					asm_int(ins);
 					break;
 				}
 				case LIR_quad:
 				{
+                    countlir_imm();
 					asm_quad(ins);
 					break;
 				}
@@ -899,143 +1104,54 @@
 #endif
 				case LIR_param:
 				{
-					Register w = Register(ins->imm8());
-                    NanoAssert(w != UnknownReg);
-					// incoming arg in register
-					prepResultReg(ins, rmask(w));
+                    countlir_param();
+					asm_param(ins);
 					break;
 				}
 				case LIR_qlo:
                 {
-					LIns *q = ins->oprnd1();
-
-					if (!asm_qlo(ins, q))
-					{
-    					Register rr = prepResultReg(ins, GpRegs);
-				        int d = findMemFor(q);
-				        LD(rr, d, FP);
-                    }
+                    countlir_qlo();
+					asm_qlo(ins);
 					break;
-                }
+				}
 				case LIR_qhi:
 				{
-					Register rr = prepResultReg(ins, GpRegs);
-					LIns *q = ins->oprnd1();
-					int d = findMemFor(q);
-				    LD(rr, d+4, FP);
+                    countlir_qhi();
+					asm_qhi(ins);
 					break;
 				}
-
 				case LIR_qcmov:
 				case LIR_cmov:
 				{
-					LIns* condval = ins->oprnd1();
-					NanoAssert(condval->isCmp());
-
-					LIns* values = ins->oprnd2();
-
-					NanoAssert(values->opcode() == LIR_2);
-					LIns* iftrue = values->oprnd1();
-					LIns* iffalse = values->oprnd2();
-
-					NanoAssert(op == LIR_qcmov || (!iftrue->isQuad() && !iffalse->isQuad()));
-					
-					const Register rr = prepResultReg(ins, GpRegs);
-
-					// this code assumes that neither LD nor MR nor MRcc set any of the condition flags.
-					// (This is true on Intel, is it true on all architectures?)
-					const Register iffalsereg = findRegFor(iffalse, GpRegs & ~rmask(rr));
-					if (op == LIR_cmov) {
-						switch (condval->opcode())
-						{
-							// note that these are all opposites...
-							case LIR_eq:	MRNE(rr, iffalsereg);	break;
-							case LIR_ov:    MRNO(rr, iffalsereg);   break;
-							case LIR_cs:    MRNC(rr, iffalsereg);   break;
-							case LIR_lt:	MRGE(rr, iffalsereg);	break;
-							case LIR_le:	MRG(rr, iffalsereg);	break;
-							case LIR_gt:	MRLE(rr, iffalsereg);	break;
-							case LIR_ge:	MRL(rr, iffalsereg);	break;
-							case LIR_ult:	MRAE(rr, iffalsereg);	break;
-							case LIR_ule:	MRA(rr, iffalsereg);	break;
-							case LIR_ugt:	MRBE(rr, iffalsereg);	break;
-							case LIR_uge:	MRB(rr, iffalsereg);	break;
-							debug_only( default: NanoAssert(0); break; )
-						}
-					} else if (op == LIR_qcmov) {
-#if !defined NANOJIT_64BIT
-						NanoAssert(0);
-#else
-						switch (condval->opcode())
-						{
-							// note that these are all opposites...
-							case LIR_eq:	MRQNE(rr, iffalsereg);	break;
-							case LIR_ov:    MRQNO(rr, iffalsereg);   break;
-							case LIR_cs:    MRQNC(rr, iffalsereg);   break;
-							case LIR_lt:	MRQGE(rr, iffalsereg);	break;
-							case LIR_le:	MRQG(rr, iffalsereg);	break;
-							case LIR_gt:	MRQLE(rr, iffalsereg);	break;
-							case LIR_ge:	MRQL(rr, iffalsereg);	break;
-							case LIR_ult:	MRQAE(rr, iffalsereg);	break;
-							case LIR_ule:	MRQA(rr, iffalsereg);	break;
-							case LIR_ugt:	MRQBE(rr, iffalsereg);	break;
-							case LIR_uge:	MRQB(rr, iffalsereg);	break;
-							debug_only( default: NanoAssert(0); break; )
-						}
-#endif
-					}
-					/*const Register iftruereg =*/ findSpecificRegFor(iftrue, rr);
-					asm_cmp(condval);
+                    countlir_cmov();
+					asm_cmov(ins);
 					break;
-				}
-
+				}				
 				case LIR_ld:
 				case LIR_ldc:
 				case LIR_ldcb:
 				{
-					LIns* base = ins->oprnd1();
-					LIns* disp = ins->oprnd2();
-					Register rr = prepResultReg(ins, GpRegs);
-					Register ra = findRegFor(base, GpRegs);
-					int d = disp->constval();
-					if (op == LIR_ldcb)
-						LD8Z(rr, d, ra);
-					else
-						LD(rr, d, ra); 
+                    countlir_ld();
+					asm_ld(ins);
 					break;
 				}
-
 				case LIR_ldq:
+				case LIR_ldqc:
 				{
+                    countlir_ldq();
 					asm_load64(ins);
 					break;
 				}
-
 				case LIR_neg:
 				case LIR_not:
 				{
-					Register rr = prepResultReg(ins, GpRegs);
-
-					LIns* lhs = ins->oprnd1();
-					Reservation *rA = getresv(lhs);
-					// if this is last use of lhs in reg, we can re-use result reg
-					Register ra;
-					if (rA == 0 || (ra=rA->reg) == UnknownReg)
-						ra = findSpecificRegFor(lhs, rr);
-					// else, rA already has a register assigned.
-
-					if (op == LIR_not)
-						NOT(rr); 
-					else
-						NEG(rr); 
-
-					if ( rr != ra ) 
-						MR(rr,ra); 
+                    countlir_alu();
+					asm_neg_not(ins);
 					break;
 				}
-				
 				case LIR_qjoin:
 				{
+                    countlir_qjoin();
                     asm_qjoin(ins);
 					break;
 				}
@@ -1052,6 +1168,7 @@
 #endif
 
 				case LIR_add:
+				case LIR_addp:
 				case LIR_sub:
 				case LIR_mul:
 				case LIR_and:
@@ -1061,112 +1178,14 @@
 				case LIR_rsh:
 				case LIR_ush:
 				{
-                    LInsp lhs = ins->oprnd1();
-                    LInsp rhs = ins->oprnd2();
-
-					Register rb = UnknownReg;
-					RegisterMask allow = GpRegs;
-					bool forceReg = (op == LIR_mul || !rhs->isconst());
-
-#ifdef NANOJIT_ARM
-					// Arm can't do an immediate op with immediates
-					// outside of +/-255 (for AND) r outside of
-					// 0..255 for others.
-					if (!forceReg)
-					{
-						if (rhs->isconst() && !isU8(rhs->constval()))
-							forceReg = true;
-					}
-#endif
-
-					if (lhs != rhs && forceReg)
-					{
-						if ((rb = asm_binop_rhs_reg(ins)) == UnknownReg) {
-							rb = findRegFor(rhs, allow);
-						}
-						allow &= ~rmask(rb);
-					}
-
-					Register rr = prepResultReg(ins, allow);
-					Reservation* rA = getresv(lhs);
-					Register ra;
-					// if this is last use of lhs in reg, we can re-use result reg
-					if (rA == 0 || (ra = rA->reg) == UnknownReg)
-						ra = findSpecificRegFor(lhs, rr);
-					// else, rA already has a register assigned.
-
-					if (forceReg)
-					{
-						if (lhs == rhs)
-							rb = ra;
-
-						if (op == LIR_add)
-							ADD(rr, rb);
-						else if (op == LIR_sub)
-							SUB(rr, rb);
-						else if (op == LIR_mul)
-							MUL(rr, rb);
-						else if (op == LIR_and)
-							AND(rr, rb);
-						else if (op == LIR_or)
-							OR(rr, rb);
-						else if (op == LIR_xor)
-							XOR(rr, rb);
-						else if (op == LIR_lsh)
-							SHL(rr, rb);
-						else if (op == LIR_rsh)
-							SAR(rr, rb);
-						else if (op == LIR_ush)
-							SHR(rr, rb);
-						else
-							NanoAssertMsg(0, "Unsupported");
-					}
-					else
-					{
-						int c = rhs->constval();
-						if (op == LIR_add) {
-#ifdef NANOJIT_IA32
-							if (ra != rr) {
-								LEA(rr, c, ra);
-								ra = rr; // suppress mov
-							} else
-#endif
-							{
-								ADDi(rr, c); 
-							}
-						} else if (op == LIR_sub) {
-#ifdef NANOJIT_IA32
-							if (ra != rr) {
-								LEA(rr, -c, ra);
-								ra = rr;
-							} else
-#endif
-							{
-								SUBi(rr, c); 
-							}
-						} else if (op == LIR_and)
-							ANDi(rr, c);
-						else if (op == LIR_or)
-							ORi(rr, c);
-						else if (op == LIR_xor)
-							XORi(rr, c);
-						else if (op == LIR_lsh)
-							SHLi(rr, c);
-						else if (op == LIR_rsh)
-							SARi(rr, c);
-						else if (op == LIR_ush)
-							SHRi(rr, c);
-						else
-							NanoAssertMsg(0, "Unsupported");
-					}
-
-					if ( rr != ra ) 
-						MR(rr,ra);
+                    countlir_alu();
+					asm_arith(ins);
 					break;
 				}
 #ifndef NJ_SOFTFLOAT
 				case LIR_fneg:
 				{
+                    countlir_fpu();
 					asm_fneg(ins);
 					break;
 				}
@@ -1175,16 +1194,19 @@
 				case LIR_fmul:
 				case LIR_fdiv:
 				{
+                    countlir_fpu();
 					asm_fop(ins);
                     break;
 				}
 				case LIR_i2f:
 				{
+                    countlir_fpu();
 					asm_i2f(ins);
 					break;
 				}
 				case LIR_u2f:
 				{
+                    countlir_fpu();
 					asm_u2f(ins);
 					break;
 				}
@@ -1192,108 +1214,138 @@
 				case LIR_st:
 				case LIR_sti:
 				{
+                    countlir_st();
                     asm_store32(ins->oprnd1(), ins->immdisp(), ins->oprnd2());
                     break;
 				}
 				case LIR_stq:
 				case LIR_stqi:
 				{
+                    countlir_stq();
 					LIns* value = ins->oprnd1();
 					LIns* base = ins->oprnd2();
 					int dr = ins->immdisp();
-					if (value->isop(LIR_qjoin)) {
+					if (value->isop(LIR_qjoin)) 
+					{
 						// this is correct for little-endian only
 						asm_store32(value->oprnd1(), dr, base);
 						asm_store32(value->oprnd2(), dr+4, base);
 					}
-					else {
+					else 
+					{
 						asm_store64(value, dr, base);
 					}
                     break;
 				}
-				case LIR_xt:
+
+				case LIR_j:
+				{
+                    countlir_jmp();
+					LInsp to = ins->getTarget();
+                    LabelState *label = _labels.get(to);
+                    // the jump is always taken so whatever register state we
+                    // have from downstream code, is irrelevant to code before
+                    // this jump.  so clear it out.  we will pick up register
+                    // state from the jump target, if we have seen that label.
+                    releaseRegisters();
+                    if (label && label->addr) {
+                        // forward jump - pick up register state from target.
+                        unionRegisterState(label->regs);
+                        JMP(label->addr);
+                    }
+                    else {
+                        // backwards jump
+                        hasLoop = true;
+                        handleLoopCarriedExprs();
+                        if (!label) {
+                            // save empty register state at loop header
+                            _labels.add(to, 0, _allocator);
+                        }
+                        else {
+                            intersectRegisterState(label->regs);
+                        }
+                        JMP(0);
+    					_patches.put(_nIns, to);
+                        verbose_only(
+                            verbose_outputf("        Loop %s -> %s", 
+                                lirNames[ins->opcode()], 
+                                _thisfrag->lirbuf->names->formatRef(to));
+                        )
+                    }
+					break;
+				}
+
+				case LIR_jt:
+				case LIR_jf:
+				{
+                    countlir_jcc();
+					LInsp to = ins->getTarget();
+					LIns* cond = ins->oprnd1();
+                    LabelState *label = _labels.get(to);
+                    if (label && label->addr) {
+                        // forward jump to known label.  need to merge with label's register state.
+                        unionRegisterState(label->regs);
+    					asm_branch(op == LIR_jf, cond, label->addr);
+                    }
+                    else {
+                        // back edge.
+                        hasLoop = true;
+                        handleLoopCarriedExprs();
+                        if (!label) {
+                            // evict all registers, most conservative approach.
+                            evictRegs(~_allocator.free);
+                            _labels.add(to, 0, _allocator);
+                        } 
+                        else {
+                            // evict all registers, most conservative approach.
+                            intersectRegisterState(label->regs);
+                        }
+                        NIns *branch = asm_branch(op == LIR_jf, cond, 0);
+			            _patches.put(branch,to);
+                        verbose_only(
+                            verbose_outputf("Loop %s -> %s", 
+                                lirNames[ins->opcode()], 
+                                _thisfrag->lirbuf->names->formatRef(to));
+                        )
+                    }
+					break;
+				}					
+				case LIR_label:
+				{
+                    countlir_label();
+                    LabelState *label = _labels.get(ins);
+                    if (!label) {
+                        // label seen first, normal target of forward jump, save addr & allocator
+    					_labels.add(ins, _nIns, _allocator);
+                    }
+                    else {
+                        // we're at the top of a loop
+                        hasLoop = true;
+                        NanoAssert(label->addr == 0 && label->regs.isValid());
+                        //evictRegs(~_allocator.free);
+                        intersectRegisterState(label->regs);
+                        //asm_align_code();
+                        label->addr = _nIns;
+                        verbose_only(
+                            verbose_outputf("Loop %s", _thisfrag->lirbuf->names->formatRef(ins));
+                        )
+                    }
+					break;
+				}
+
+                case LIR_xt:
 				case LIR_xf:
 				{
-                    NIns* exit = asm_exit(ins);
-	
+                    countlir_xcc();
 					// we only support cmp with guard right now, also assume it is 'close' and only emit the branch
+                    NIns* exit = asm_exit(ins); // does intersectRegisterState()
 					LIns* cond = ins->oprnd1();
-					LOpcode condop = cond->opcode();
-					NanoAssert(cond->isCond());
-#if !defined(NJ_SOFTFLOAT)
-                    if (condop >= LIR_feq && condop <= LIR_fge)
-					{
-#if defined(NJ_ARM_VFP)
-						if (op == LIR_xf)
-							JNE(exit);
-						else
-							JE(exit);
-#else
-						if (op == LIR_xf)
-							JP(exit);
-						else
-							JNP(exit);
-#endif
-						asm_fcmp(cond);
-                        break;
-					}
-#endif
-					// produce the branch
-					if (op == LIR_xf)
-					{
-						if (condop == LIR_eq)
-							JNE(exit);
-                        else if (condop == LIR_ov)
-                            JNO(exit);
-                        else if (condop == LIR_cs)
-                            JNC(exit);
-						else if (condop == LIR_lt)
-							JNL(exit);
-						else if (condop == LIR_le)
-							JNLE(exit);
-						else if (condop == LIR_gt)
-							JNG(exit);
-						else if (condop == LIR_ge)
-							JNGE(exit);
-						else if (condop == LIR_ult)
-							JNB(exit);
-						else if (condop == LIR_ule)
-							JNBE(exit);
-						else if (condop == LIR_ugt)
-							JNA(exit);
-						else //if (condop == LIR_uge)
-							JNAE(exit);
-					}
-					else // op == LIR_xt
-					{
-						if (condop == LIR_eq)
-							JE(exit);
-                        else if (condop == LIR_ov)
-                            JO(exit);
-                        else if (condop == LIR_cs)
-                            JC(exit);
-						else if (condop == LIR_lt)
-							JL(exit);
-						else if (condop == LIR_le)
-							JLE(exit);
-						else if (condop == LIR_gt)
-							JG(exit);
-						else if (condop == LIR_ge)
-							JGE(exit);
-						else if (condop == LIR_ult)
-							JB(exit);
-						else if (condop == LIR_ule)
-							JBE(exit);
-						else if (condop == LIR_ugt)
-							JA(exit);
-						else //if (condop == LIR_uge)
-							JAE(exit);
-					}
-					asm_cmp(cond);
+					asm_branch(op == LIR_xf, cond, exit);
 					break;
 				}
 				case LIR_x:
 				{
+                    countlir_x();
 		            verbose_only(verbose_output(""));
 					// generate the side exit branch on the main trace.
                     NIns *exit = asm_exit(ins);
@@ -1302,27 +1354,11 @@
 				}
 				case LIR_loop:
 				{
-					JMP_long_placeholder(); // jump to SOT	
-					verbose_only( if (_verbose && _outputCache) { _outputCache->removeLast(); outputf("         jmp   SOT"); } );
-					
-					loopJumps.add(_nIns);
-
-                    #ifdef NJ_VERBOSE
-                    // branching from this frag to ourself.
-                    if (_frago->core()->config.show_stats)
-					#if defined NANOJIT_64BIT
-                        LDQi(argRegs[1], intptr_t((Fragment*)_thisfrag));
-					#else
-                        LDi(argRegs[1], int((Fragment*)_thisfrag));
-                    #endif
-                    #endif
-
-					// restore first parameter, the only one we use
-                    LInsp state = _thisfrag->lirbuf->state;
-                    Register a0 = Register(state->imm8());
-					findSpecificRegFor(state, a0); 
+                    countlir_loop();
+					asm_loop(ins, loopJumps);
 					break;
 				}
+
 #ifndef NJ_SOFTFLOAT
 				case LIR_feq:
 				case LIR_fle:
@@ -1330,16 +1366,8 @@
 				case LIR_fgt:
 				case LIR_fge:
 				{
-					// only want certain regs 
-					Register r = prepResultReg(ins, AllowableFlagRegs);
-#ifdef NJ_ARM_VFP
-					SETE(r);
-#else
-					// SETcc only sets low 8 bits, so extend 
-					MOVZX8(r,r);
-					SETNP(r);
-#endif
-					asm_fcmp(ins);
+                    countlir_fpu();
+					asm_fcond(ins);
 					break;
 				}
 #endif
@@ -1355,61 +1383,41 @@
 				case LIR_ugt:
 				case LIR_uge:
 				{
-					// only want certain regs 
-					Register r = prepResultReg(ins, AllowableFlagRegs);
-					// SETcc only sets low 8 bits, so extend 
-					MOVZX8(r,r);
-					if (op == LIR_eq)
-						SETE(r);
-                    else if (op == LIR_ov)
-                        SETO(r);
-                    else if (op == LIR_cs)
-                        SETC(r);
-					else if (op == LIR_lt)
-						SETL(r);
-					else if (op == LIR_le)
-						SETLE(r);
-					else if (op == LIR_gt)
-						SETG(r);
-					else if (op == LIR_ge)
-						SETGE(r);
-					else if (op == LIR_ult)
-						SETB(r);
-					else if (op == LIR_ule)
-						SETBE(r);
-					else if (op == LIR_ugt)
-						SETA(r);
-					else // if (op == LIR_uge)
-						SETAE(r);
-					asm_cmp(ins);
+                    countlir_alu();
+					asm_cond(ins);
 					break;
 				}
-
+				
 #ifndef NJ_SOFTFLOAT
 				case LIR_fcall:
+				case LIR_fcalli:
 #endif
 #if defined NANOJIT_64BIT
 				case LIR_callh:
 #endif
 				case LIR_call:
+				case LIR_calli:
 				{
+                    countlir_call();
                     Register rr = UnknownReg;
 #ifndef NJ_SOFTFLOAT
-                    if (op == LIR_fcall)
+                    if ((op&LIR64))
                     {
+                        // fcall or fcalli
+						Reservation* rR = getresv(ins);
 						rr = asm_prep_fcall(rR, ins);
                     }
                     else
 #endif
                     {
-						(void)rR;
                         rr = retRegs[0];
 						prepResultReg(ins, rmask(rr));
                     }
 
 					// do this after we've handled the call result, so we dont
 					// force the call result to be spilled unnecessarily.
-					restoreCallerSaved();
+
+					evictScratchRegs();
 
 					asm_call(ins);
 				}
@@ -1421,54 +1429,46 @@
 		}
 	}
 
-    void Assembler::asm_arg(ArgSize sz, LInsp p, Register r)
+    void Assembler::assignSavedParams()
     {
-        if (sz == ARGSIZE_Q) 
-        {
-			// ref arg - use lea
-			if (r != UnknownReg)
-			{
-				// arg in specific reg
-				int da = findMemFor(p);
-				LEA(r, da, FP);
-			}
-			else
-			{
-				NanoAssert(0); // not supported
-			}
-		}
-        else if (sz == ARGSIZE_LO)
-		{
-			if (r != UnknownReg)
-			{
-				// arg goes in specific register
-				if (p->isconst())
-					LDi(r, p->constval());
-				else
-					findSpecificRegFor(p, r);
-			}
-			else
-			{
-				asm_pusharg(p);
-			}
-		}
-        else
-		{
-			asm_farg(p);
-		}
+        // restore saved regs
+		releaseRegisters();
+        LirBuffer *b = _thisfrag->lirbuf;
+        for (int i=0, n = NumSavedRegs; i < n; i++) {
+            LIns *p = b->savedParams[i];
+            if (p)
+                findSpecificRegFor(p, savedRegs[p->imm8()]);
+        }
     }
 
-	uint32_t Assembler::arFree(uint32_t idx)
+    void Assembler::reserveSavedParams()
+    {
+        LirBuffer *b = _thisfrag->lirbuf;
+        for (int i=0, n = NumSavedRegs; i < n; i++) {
+            LIns *p = b->savedParams[i];
+            if (p)
+                findMemFor(p);
+        }
+    }
+
+    void Assembler::handleLoopCarriedExprs()
+    {
+        // ensure that exprs spanning the loop are marked live at the end of the loop
+        reserveSavedParams();
+        for (int i=0, n=pending_lives.size(); i < n; i++) {
+            findMemFor(pending_lives[i]);
+        }
+    }
+
+	void Assembler::arFree(uint32_t idx)
 	{
-		// nothing to free
-		if (idx == 0)
-			return 0;
-
-		if (idx > 0 && _activation.entry[idx] == _activation.entry[idx+stack_direction(1)])
-			_activation.entry[idx+stack_direction(1)] = 0;  // clear 2 slots for doubles 
-
-		_activation.entry[idx] = 0;
-		return 0;
+        AR &ar = _activation;
+        LIns *i = ar.entry[idx];
+        NanoAssert(i != 0);
+        do {
+            ar.entry[idx] = 0;
+            idx--;
+        } while (ar.entry[idx] == i);
 	}
 
 #ifdef NJ_VERBOSE
@@ -1479,6 +1479,7 @@
 			return;
 			
 #ifdef NANOJIT_ARM
+		// @todo Why is there here?!?  This routine should be indep. of platform
 		verbose_only(
 			if (_verbose) {
 				char* s = &outline[0];
@@ -1518,60 +1519,147 @@
 #endif
 	}
 #endif
+
+    bool canfit(int32_t size, int32_t loc, AR &ar) {
+        for (int i=0; i < size; i++) {
+            if (ar.entry[loc+stack_direction(i)])
+                return false;
+        }
+        return true;
+    }
 	
 	uint32_t Assembler::arReserve(LIns* l)
 	{
 		NanoAssert(!l->isTramp());
 
 		//verbose_only(printActivationState());
-		const bool quad = l->isQuad();
-		const int32_t n = _activation.tos;
-		int32_t start = _activation.lowwatermark;
+        int32_t size = l->isop(LIR_alloc) ? (l->size()>>2) : l->isQuad() ? 2 : sizeof(intptr_t)>>2;
+        AR &ar = _activation;
+		const int32_t tos = ar.tos;
+		int32_t start = ar.lowwatermark;
 		int32_t i = 0;
 		NanoAssert(start>0);
-		if (n >= NJ_MAX_STACK_ENTRY-2)
-		{	
-			setError(StackFull);
-			return start;
-		}
-		else if (quad)
-		{
-			if ( (start&1)==1 ) start++;  // even 
-			for(i=start; i <= n; i+=2)
-			{
-				if ( (_activation.entry[i+stack_direction(1)] == 0) && (i==n || (_activation.entry[i] == 0)) )
-					break;   //  for fp we need 2 adjacent aligned slots
+
+        if (size == 1) {
+            // easy most common case -- find a hole, or make the frame bigger
+            for (i=start; i < NJ_MAX_STACK_ENTRY; i++) {
+                if (ar.entry[i] == 0) {
+                    // found a hole
+                    ar.entry[i] = l;
+                    break;
+                }
+            }
+        }
+        else if (size == 2) {
+			if ( (start&1)==1 ) start++;  // even 8 boundary
+			for (i=start; i < NJ_MAX_STACK_ENTRY; i+=2) {
+                if ( (ar.entry[i+stack_direction(1)] == 0) && (i==tos || (ar.entry[i] == 0)) ) {
+                    // found 2 adjacent aligned slots
+                    NanoAssert(_activation.entry[i] == 0);
+                    NanoAssert(_activation.entry[i+stack_direction(1)] == 0);
+                    ar.entry[i] = l;
+                    ar.entry[i+stack_direction(1)] = l;
+                    break;   
+                }
 			}
 		}
-		else
-		{
-			for(i=start; i < n; i++)
-			{
-				if (_activation.entry[i] == 0)
-					break;   // not being used
-			}
+        else {
+            // alloc larger block on 8byte boundary.
+            if (start < size) start = size;
+            if ((start&1)==1) start++;
+            for (i=start; i < NJ_MAX_STACK_ENTRY; i+=2) {
+                if (canfit(size, i, ar)) {
+		            // place the entry in the table and mark the instruction with it
+                    for (int32_t j=0; j < size; j++) {
+                        NanoAssert(_activation.entry[i+stack_direction(j)] == 0);
+                        _activation.entry[i+stack_direction(j)] = l;
+                    }
+                    break;
+                }
+            }
 		}
-
-		int32_t inc = ((i-n+1) < 0) ? 0 : (i-n+1);
-		if (quad && stack_direction(1)>0) inc++;
-		_activation.tos += inc;
-		_activation.highwatermark += inc;
-
-		// place the entry in the table and mark the instruction with it
-		_activation.entry[i] = l;
-		if (quad) _activation.entry[i+stack_direction(1)] = l;
-		return i;
+        if (i >= (int32_t)ar.tos) {
+            ar.tos = ar.highwatermark = i+1;
+        }
+		if (tos+size >= NJ_MAX_STACK_ENTRY) {	
+			setError(StackFull);
+		}
+        return i;
 	}
 
-	void Assembler::restoreCallerSaved()
+    /**
+     * move regs around so the SavedRegs contains the highest priority regs.
+     */
+    void Assembler::evictScratchRegs()
+    {
+		// find the top GpRegs that are candidates to put in SavedRegs
+
+        // tosave is a binary heap stored in an array.  the root is tosave[0],
+        // left child is at i+1, right child is at i+2.  
+
+        Register tosave[LastReg-FirstReg+1];
+        int len=0;
+        RegAlloc *regs = &_allocator;
+        for (Register r = FirstReg; r <= LastReg; r = nextreg(r)) {
+			if (rmask(r) & GpRegs) {
+				LIns *i = regs->getActive(r);
+				if (i) {
+					if (canRemat(i)) {
+						evict(r);
+					}
+					else {
+						int32_t pri = regs->getPriority(r);
+                        // add to heap by adding to end and bubbling up
+                        int j = len++;
+                        while (j > 0 && pri > regs->getPriority(tosave[j/2])) {
+                            tosave[j] = tosave[j/2];
+                            j /= 2;
+                        }
+                        NanoAssert(size_t(j) < sizeof(tosave)/sizeof(tosave[0]));
+                        tosave[j] = r;
+					}
+				}
+            }
+        }
+
+        // now primap has the live exprs in priority order.  
+		// allocate each of the top priority exprs to a SavedReg
+
+        RegisterMask allow = SavedRegs;
+        while (allow && len > 0) {
+            // get the highest priority var
+            Register hi = tosave[0];
+            LIns *i = regs->getActive(hi);
+            Register r = findRegFor(i, allow);
+			allow &= ~rmask(r);
+
+            // remove from heap by replacing root with end element and bubbling down.
+            if (allow && --len > 0) {
+                Register last = tosave[len];
+                int j = 0;
+                while (j+1 < len) {
+                    int child = j+1;
+                    if (j+2 < len && regs->getPriority(tosave[j+2]) > regs->getPriority(tosave[j+1]))
+                        child++;
+                    if (regs->getPriority(last) > regs->getPriority(tosave[child]))
+                        break;
+                    tosave[j] = tosave[child];
+                    j = child;
+                }
+                tosave[j] = last;
+            }
+        }
+
+		// now evict everything else.
+		evictRegs(~SavedRegs);
+    }
+
+	void Assembler::evictRegs(RegisterMask regs)
 	{
 		// generate code to restore callee saved registers 
 		// @todo speed this up
-		RegisterMask scratch = ~SavedRegs;
-		for (Register r = FirstReg; r <= LastReg; r = nextreg(r))
-		{
-			if ((rmask(r) & scratch) && _allocator.getActive(r))
-            {
+        for (Register r = FirstReg; r <= LastReg; r = nextreg(r)) {
+            if ((rmask(r) & regs) && _allocator.getActive(r)) {
 				evict(r);
             }
 		}
@@ -1579,8 +1667,12 @@
 	
 	/**
 	 * Merge the current state of the registers with a previously stored version
+     * current == saved    skip
+     * current & saved     evict current, keep saved
+     * current & !saved    evict current  (unionRegisterState would keep)
+     * !current & saved    keep saved
 	 */
-	void Assembler::mergeRegisterState(RegAlloc& saved)
+	void Assembler::intersectRegisterState(RegAlloc& saved)
 	{
 		// evictions and pops first
 		RegisterMask skip = 0;
@@ -1590,14 +1682,15 @@
 			LIns * savedins = saved.getActive(r);
 			if (curins == savedins)
 			{
-				verbose_only( if (curins) 
-					verbose_outputf("        skip %s", regNames[r]); )
+				verbose_only( if (curins) verbose_outputf("        skip %s", regNames[r]); )
 				skip |= rmask(r);
 			}
 			else 
 			{
-				if (curins)
+                if (curins) {
+                    //_nvprof("intersect-evict",1);
 					evict(r);
+                }
 				
     			#ifdef NANOJIT_IA32
 				if (savedins && (rmask(r) & x87Regs))
@@ -1605,7 +1698,56 @@
 				#endif
 			}
 		}
+        assignSaved(saved, skip);
+	}
 
+	/**
+	 * Merge the current state of the registers with a previously stored version.
+     * 
+     * current == saved    skip
+     * current & saved     evict current, keep saved
+     * current & !saved    keep current (intersectRegisterState would evict)
+     * !current & saved    keep saved
+	 */
+	void Assembler::unionRegisterState(RegAlloc& saved)
+	{
+		// evictions and pops first
+		RegisterMask skip = 0;
+		for (Register r=FirstReg; r <= LastReg; r = nextreg(r))
+		{
+			LIns * curins = _allocator.getActive(r);
+			LIns * savedins = saved.getActive(r);
+			if (curins == savedins)
+			{
+				verbose_only( if (curins) verbose_outputf("        skip %s", regNames[r]); )
+				skip |= rmask(r);
+			}
+			else 
+			{
+                if (curins && savedins) {
+                    //_nvprof("union-evict",1);
+					evict(r);
+                }
+				
+    			#ifdef NANOJIT_IA32
+				if (rmask(r) & x87Regs) {
+					if (savedins) {
+						FSTP(r);
+					}
+					else {
+						// saved state did not have fpu reg allocated,
+						// so we must evict here to keep x87 stack balanced.
+						evict(r);
+					}
+				}
+				#endif
+			}
+		}
+        assignSaved(saved, skip);
+    }
+
+    void Assembler::assignSaved(RegAlloc &saved, RegisterMask skip)
+    {
 		// now reassign mainline registers
 		for (Register r=FirstReg; r <= LastReg; r = nextreg(r))
 		{
@@ -1616,49 +1758,6 @@
 		debug_only(saved.used = 0);  // marker that we are no longer in exit path
 	}
 	
-	/**																 
-	 * Guard records are laid out in the exit block buffer (_nInsExit),
-	 * intersperced with the code.   Preceding the record are the native
-	 * instructions associated with the record (i.e. the exit code).
-	 * 
-	 * The layout is as follows:
-	 * 
-	 * [ native code ] [ GuardRecord1 ]
-	 * ...
-	 * [ native code ] [ GuardRecordN ]
-	 * 
-	 * The guard record 'code' field should be used to locate 
-	 * the start of the native code associated with the
-	 * exit block. N.B the code may lie in a different page 
-	 * than the guard record  
-	 * 
-	 * The last guard record is used for the unconditional jump
-	 * at the end of the trace. 
-	 * 
-	 * NOTE:  It is also not guaranteed that the native code 
-	 *        is contained on a single page.
-	 */
-	GuardRecord* Assembler::placeGuardRecord(LInsp guard)
-	{
-		// we align the guards to 4Byte boundary
-		size_t size = GuardRecordSize(guard);
-		SideExit *exit = guard->exit();
-		NIns* ptr = (NIns*)alignTo(_nIns-size, 4);
-		underrunProtect( (intptr_t)_nIns-(intptr_t)ptr );  // either got us a new page or there is enough space for us
-		GuardRecord* rec = (GuardRecord*) alignTo(_nIns-size,4);
-		rec->outgoing = _latestGuard;
-		_latestGuard = rec;
-		_nIns = (NIns*)rec;
-		rec->next = 0;
-		rec->origTarget = 0;		
-		rec->target = exit->target;
-		rec->from = _thisfrag;
-		initGuardRecord(guard,rec);
-		if (exit->target) 
-			exit->target->addLink(rec);
-		return rec;
-	}
-
 	void Assembler::setCallTable(const CallInfo* functions)
 	{
 		_functions = functions;
@@ -1715,8 +1814,7 @@
 	{
 		uint32_t argc = 0;
 		uint32_t argt = _argtypes;
-		for (int i = 0; i < 5; ++i)
-		{
+		for (uint32_t i = 0; i < MAXARGS; ++i) {
 			argt >>= 2;
 			argc += (argt & mask) != 0;
 		}
@@ -1727,7 +1825,7 @@
     {
 		uint32_t argt = _argtypes;
 		uint32_t argc = 0;
-		for (int32_t i = 0; i < 5; i++) {
+		for (uint32_t i = 0; i < MAXARGS; i++) {
 			argt >>= 2;
 			ArgSize a = ArgSize(argt&3);
 #ifdef NJ_SOFTFLOAT
@@ -1741,7 +1839,20 @@
                 sizes[argc++] = a;
             }
 		}
+        if (isIndirect()) {
+            // add one more arg for indirect call address
+            argc++;
+        }
         return argc;
     }
-#endif
+
+    void LabelStateMap::add(LIns *label, NIns *addr, RegAlloc &regs) {
+        LabelState *st = new (gc) LabelState(addr, regs);
+        labels.put(label, st);
+    }
+
+    LabelState* LabelStateMap::get(LIns *label) {
+        return labels.get(label);
+    }
 }
+#endif // FEATURE_NANOJIT
diff -r 17e9560465b0 js/src/nanojit/Assembler.h
--- a/js/src/nanojit/Assembler.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/nanojit/Assembler.h	Thu Oct 30 05:41:45 2008 -0400
@@ -73,8 +73,8 @@
     struct Reservation
 	{
 		uint32_t arIndex:16;	/* index into stack frame.  displ is -4*arIndex */
-		Register reg:8;			/* register UnkownReg implies not in register */
-        int cost:8;
+		Register reg:15;			/* register UnkownReg implies not in register */
+        uint32_t used:1;
 	};
 
 	struct AR
@@ -83,32 +83,6 @@
 		uint32_t		tos;							/* current top of stack entry */
 		uint32_t		highwatermark;					/* max tos hit */
 		uint32_t		lowwatermark;					/* we pre-allocate entries from 0 upto this index-1; so dynamic entries are added above this index */
-		LIns*			parameter[ NJ_MAX_PARAMETERS ]; /* incoming parameters */
-	};
-
-    enum ArgSize {
-	    ARGSIZE_NONE = 0,
-	    ARGSIZE_F = 1,
-	    ARGSIZE_LO = 2,
-	    ARGSIZE_Q = 3,
-	    _ARGSIZE_MASK_INT = 2, 
-        _ARGSIZE_MASK_ANY = 3
-    };
-
-	struct CallInfo
-	{
-		intptr_t	_address;
-		uint16_t	_argtypes;		// 6 2-bit fields indicating arg type, by ARGSIZE above (including ret type): a1 a2 a3 a4 a5 ret
-		uint8_t		_cse;			// true if no side effects
-		uint8_t		_fold;			// true if no side effects
-		verbose_only ( const char* _name; )
-		
-		uint32_t FASTCALL _count_args(uint32_t mask) const;
-        uint32_t get_sizes(ArgSize*) const;
-
-		inline uint32_t FASTCALL count_args() const { return _count_args(_ARGSIZE_MASK_ANY); }
-		inline uint32_t FASTCALL count_iargs() const { return _count_args(_ARGSIZE_MASK_INT); }
-		// fargs = args - iargs
 	};
 
 	#ifdef AVMPLUS_WIN32
@@ -124,6 +98,10 @@
 		counter_define(spills;)
 		counter_define(native;)
         counter_define(exitnative;)
+		
+		int32_t pages;
+		NIns* codeStart;
+		NIns* codeExitStart;
 
 		DECLARE_PLATFORM_STATS()
 #ifdef __GNUC__
@@ -146,10 +124,34 @@
         ,MaxExit
         ,MaxXJump
         ,UnknownPrim
+        ,UnknownBranch
 	};
 
 	typedef avmplus::List<NIns*, avmplus::LIST_NonGCObjects> NInsList;
+	typedef avmplus::SortedMap<LIns*,NIns*,avmplus::LIST_NonGCObjects> InsMap;
+	typedef avmplus::SortedMap<NIns*,LIns*,avmplus::LIST_NonGCObjects> NInsMap;
 
+    class LabelState MMGC_SUBCLASS_DECL
+    {
+    public:
+        RegAlloc regs;
+        NIns *addr;
+        LabelState(NIns *a, RegAlloc &r) : regs(r), addr(a)
+        {}
+    };
+
+    class LabelStateMap
+    {
+        GC *gc;
+        avmplus::SortedMap<LIns*, LabelState*, avmplus::LIST_GCObjects> labels;
+    public:
+        LabelStateMap(GC *gc) : gc(gc), labels(gc)
+        {}
+
+        void clear() { labels.clear(); }
+        void add(LIns *label, NIns *addr, RegAlloc &regs);
+        LabelState *get(LIns *);
+    };
     /**
  	 * Information about the activation record for the method is built up 
  	 * as we generate machine code.  As part of the prologue, we issue
@@ -185,11 +187,12 @@
 			void		copyRegisters(RegAlloc* copyTo);
 			void		releaseRegisters();
             void        patch(GuardRecord *lr);
-			void		unpatch(GuardRecord *lr);
+            void        patch(SideExit *exit);
 			AssmError   error()	{ return _err; }
 			void		setError(AssmError e) { _err = e; }
 			void		setCallTable(const CallInfo *functions);
 			void		pageReset();
+			int32_t		codeBytes();
 			Page*		handoverPages(bool exitPages=false);
 
 			debug_only ( void		pageValidate(); )
@@ -197,32 +200,32 @@
 			
 			// support calling out from a fragment ; used to debug the jit
 			debug_only( void		resourceConsistencyCheck(); )
-			debug_only( void		registerConsistencyCheck(LIns** resv); )
+			debug_only( void		registerConsistencyCheck(); )
 			
 			Stats		_stats;		
+            int hasLoop;
 
 		private:
 			
 			void		gen(LirFilter* toCompile, NInsList& loopJumps);
-			NIns*		genPrologue(RegisterMask);
-			NIns*		genEpilogue(RegisterMask);
-
-			bool		ignoreInstruction(LInsp ins);
-
-			GuardRecord* placeGuardRecord(LInsp guard);
-			void		initGuardRecord(LInsp guard, GuardRecord*);
+			NIns*		genPrologue();
+			NIns*		genEpilogue();
 
 			uint32_t	arReserve(LIns* l);
-			uint32_t	arFree(uint32_t idx);
+			void    	arFree(uint32_t idx);
 			void		arReset();
 
 			Register	registerAlloc(RegisterMask allow);
 			void		registerResetAll();
-			void		restoreCallerSaved();
-			void		mergeRegisterState(RegAlloc& saved);
-	        LInsp       findVictim(RegAlloc& regs, RegisterMask allow, RegisterMask prefer);
-		
-			int			findMemFor(LIns* i);
+			void		evictRegs(RegisterMask regs);
+            void        evictScratchRegs();
+			void		intersectRegisterState(RegAlloc& saved);
+			void		unionRegisterState(RegAlloc& saved);
+            void        assignSaved(RegAlloc &saved, RegisterMask skip);
+	        LInsp       findVictim(RegAlloc& regs, RegisterMask allow);
+
+            Register    getBaseReg(LIns *i, int &d, RegisterMask allow);
+            int			findMemFor(LIns* i);
 			Register	findRegFor(LIns* i, RegisterMask allow);
 			void		findRegFor2(RegisterMask allow, LIns* ia, Reservation* &ra, LIns *ib, Reservation* &rb);
 			Register	findSpecificRegFor(LIns* i, Register w);
@@ -234,18 +237,21 @@
 			NIns*		pageAlloc(bool exitPage=false);
 			void		pagesFree(Page*& list);
 			void		internalReset();
+            bool        canRemat(LIns*);
 
 			Reservation* reserveAlloc(LInsp i);
 			void		reserveFree(LInsp i);
 			void		reserveReset();
 
-			Reservation* getresv(LIns *x) { return x->resv() ? &_resvTable[x->resv()] : 0; }
+			Reservation* getresv(LIns *x) {
+                uint32_t resv_index = x->resv();
+                return resv_index ? &_resvTable[resv_index] : 0;
+            }
 
 			DWB(Fragmento*)		_frago;
             GC*					_gc;
             DWB(Fragment*)		_thisfrag;
 			RegAllocMap*		_branchStateMap;
-			GuardRecord*		_latestGuard;
 		
 			const CallInfo	*_functions;
 			
@@ -259,14 +265,17 @@
 			AR			_activation;
 			RegAlloc	_allocator;
 
+			LabelStateMap	_labels; 
+			NInsMap		_patches;
 			Reservation _resvTable[ NJ_MAX_STACK_ENTRY ]; // table where we house stack and register information
 			uint32_t	_resvFree;
-			bool		_inExit,vpad2[3];
+			bool		_inExit, vpad2[3];
+            avmplus::List<LIns*, avmplus::LIST_GCObjects> pending_lives;
 
 			void		asm_cmp(LIns *cond);
-#ifndef NJ_SOFTFLOAT
 			void		asm_fcmp(LIns *cond);
-#endif
+            void        asm_setcc(Register res, LIns *cond);
+            NIns *      asm_jmpcc(bool brOnFalse, LIns *cond, NIns *target);
 			void		asm_mmq(Register rd, int dd, Register rs, int ds);
             NIns*       asm_exit(LInsp guard);
 			NIns*		asm_leave_trace(LInsp guard);
@@ -274,22 +283,38 @@
             void        asm_store32(LIns *val, int d, LIns *base);
             void        asm_store64(LIns *val, int d, LIns *base);
 			void		asm_restore(LInsp, Reservation*, Register);
-			void		asm_spill(LInsp i, Reservation *resv, bool pop);
+			void		asm_load(int d, Register r);
+			void		asm_spilli(LInsp i, Reservation *resv, bool pop);
+			void		asm_spill(Register rr, int d, bool pop, bool quad);
 			void		asm_load64(LInsp i);
 			void		asm_pusharg(LInsp p);
 			NIns*		asm_adjustBranch(NIns* at, NIns* target);
 			void		asm_quad(LInsp i);
-			bool		asm_qlo(LInsp ins, LInsp q);
+			void		asm_loop(LInsp i, NInsList& loopJumps);
+			void		asm_fcond(LInsp i);
+			void		asm_cond(LInsp i);
+			void		asm_arith(LInsp i);
+			void		asm_neg_not(LInsp i);
+			void		asm_ld(LInsp i);
+			void		asm_cmov(LInsp i);
+			void		asm_param(LInsp i);
+			void		asm_int(LInsp i);
+			void		asm_short(LInsp i);
+			void		asm_qlo(LInsp i);
+			void		asm_qhi(LInsp i);
 			void		asm_fneg(LInsp ins);
 			void		asm_fop(LInsp ins);
 			void		asm_i2f(LInsp ins);
 			void		asm_u2f(LInsp ins);
 			Register	asm_prep_fcall(Reservation *rR, LInsp ins);
 			void		asm_nongp_copy(Register r, Register s);
-			void		asm_bailout(LInsp guard, Register state);
 			void		asm_call(LInsp);
             void        asm_arg(ArgSize, LInsp, Register);
 			Register	asm_binop_rhs_reg(LInsp ins);
+			NIns*		asm_branch(bool branchOnFalse, LInsp cond, NIns* targ);
+            void        assignSavedParams();
+            void        reserveSavedParams();
+            void        handleLoopCarriedExprs();
 
 			// platform specific implementation (see NativeXXX.cpp file)
 			void		nInit(uint32_t flags);
@@ -303,6 +328,7 @@
 
 			// platform specific methods
         public:
+			const static Register savedRegs[NumSavedRegs];
 			DECLARE_PLATFORM_ASSEMBLER()
 
 		private:
diff -r 17e9560465b0 js/src/nanojit/Fragmento.cpp
--- a/js/src/nanojit/Fragmento.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/nanojit/Fragmento.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -39,6 +39,7 @@
  * ***** END LICENSE BLOCK ***** */
 
 #include "nanojit.h"
+#undef MEMORY_INFO
 
 namespace nanojit
 {	
@@ -58,16 +59,17 @@
 	 */
 	Fragmento::Fragmento(AvmCore* core, uint32_t cacheSizeLog2) 
 		: _allocList(core->GetGC()),
-			_max_pages(1 << (calcSaneCacheSize(cacheSizeLog2) - NJ_LOG2_PAGE_SIZE))
+			_max_pages(1 << (calcSaneCacheSize(cacheSizeLog2) - NJ_LOG2_PAGE_SIZE)),
+			_pagesGrowth(1)
 	{
 #ifdef MEMORY_INFO
 		_allocList.set_meminfo_name("Fragmento._allocList");
 #endif
+		NanoAssert(_max_pages > _pagesGrowth); // shrink growth if needed 
 		_core = core;
 		GC *gc = core->GetGC();
 		_frags = new (gc) FragmentMap(gc, 128);
 		_assm = new (gc) nanojit::Assembler(this);
-        _pageGrowth = 1;
 		verbose_only( enterCounts = new (gc) BlockHist(gc); )
 		verbose_only( mergeCounts = new (gc) BlockHist(gc); )
 	}
@@ -109,10 +111,10 @@
 	{
         NanoAssert(sizeof(Page) == NJ_PAGE_SIZE);
 		if (!_pageList) {
-			pagesGrow(_pageGrowth);	// try to get more mem
-            if ((_pageGrowth << 1) < _max_pages)
-                _pageGrowth <<= 1;
-        }
+			pagesGrow(_pagesGrowth);	// try to get more mem
+			            if ((_pagesGrowth << 1) < _max_pages)
+							_pagesGrowth <<= 1;						
+		}
 		Page *page = _pageList;
 		if (page)
 		{
@@ -221,7 +223,7 @@
 		return _core;
 	}
 
-	Fragment* Fragmento::newLoop(const void* ip)
+    Fragment* Fragmento::getAnchor(const void* ip)
 	{
         Fragment *f = newFrag(ip);
         Fragment *p = _frags->get(ip);
@@ -260,7 +262,7 @@
 
 	Fragment *Fragmento::getMerge(GuardRecord *lr, const void* ip)
     {
-		Fragment *anchor = lr->from->anchor;
+		Fragment *anchor = lr->exit->from->anchor;
 		for (Fragment *f = anchor->branches; f != 0; f = f->nextbranch) {
 			if (f->kind == MergeTrace && f->ip == ip /*&& f->calldepth == lr->calldepth*/) {
 				// found existing shared branch on anchor
@@ -271,7 +273,7 @@
 		Fragment *f = newBranch(anchor, ip);
 		f->root = f;
 		f->kind = MergeTrace;
-		f->calldepth = lr->calldepth;
+		f->calldepth = lr->exit->calldepth;
 		verbose_only(
 			int mergeid = 1;
 			for (Fragment *g = anchor->branches; g != 0; g = g->nextbranch)
@@ -282,12 +284,11 @@
         return f;
     }
 
-	Fragment *Fragmento::createBranch(GuardRecord *lr, const void* ip)
+	Fragment *Fragmento::createBranch(SideExit* exit, const void* ip)
     {
-		Fragment *from = lr->from;
-        Fragment *f = newBranch(from, ip);
+        Fragment *f = newBranch(exit->from, ip);
 		f->kind = BranchTrace;
-		f->calldepth = lr->calldepth;
+		f->calldepth = exit->calldepth;
 		f->treeBranches = f->root->treeBranches;
 		f->root->treeBranches = f;
         return f;
@@ -480,7 +481,7 @@
 	{
 		int c = hist->count(ip);
 		if (_assm->_verbose)
-			_assm->outputf("++ %s %d", core()->interp.labels->format(ip), c);
+			_assm->outputf("++ %s %d", labels->format(ip), c);
 	}
 
 	void Fragmento::countIL(uint32_t il, uint32_t abc)
@@ -509,139 +510,7 @@
         onDestroy();
 		NanoAssert(_pages == 0);
     }
-	
-	void Fragment::addLink(GuardRecord* lnk)
-	{
-		//fprintf(stderr,"addLink %x from %X target %X\n",(int)lnk,(int)lnk->from,(int)lnk->target);
-		lnk->next = _links;
-		_links = lnk;
-	}
 
-	void Fragment::removeLink(GuardRecord* lnk)
-	{
-		GuardRecord*  lr = _links;
-		GuardRecord** lrp = &_links;
-		while(lr)
-		{
-			if (lr == lnk)
-			{
-				*lrp = lr->next;
-				lnk->next = 0;
-				break;
-			}
-			lrp = &(lr->next);
-			lr = lr->next;
-		}
-	}
-	
-	void Fragment::link(Assembler* assm)
-	{
-		// patch all jumps into this fragment
-		GuardRecord* lr = _links;
-		while (lr)
-		{
-			GuardRecord* next = lr->next;
-			Fragment* from = lr->target;
-			if (from && from->fragEntry) assm->patch(lr);
-			lr = next;
-		}
-
-		// and then patch all jumps leading out
-		lr = outbound;
-		while(lr)
-		{
-			GuardRecord* next = lr->outgoing;
-			Fragment* targ = lr->target;
-			if (targ && targ->fragEntry) assm->patch(lr);
-			lr = next;
-		}
-	}
-
-	void Fragment::unlink(Assembler* assm)
-	{
-		// remove our guards from others' in-bound list, so they don't patch to us 
-		GuardRecord* lr = outbound;
-		while (lr)
-		{
-			GuardRecord* next = lr->outgoing;
-			Fragment* targ = lr->target;
-			if (targ) targ->removeLink(lr);
-			lr = next;
-		}	
-
-		// then unpatch all jumps into this fragment
-		lr = _links;
-		while (lr)
-		{
-			GuardRecord* next = lr->next;
-			Fragment* from = lr->target;
-			if (from && from->fragEntry) assm->unpatch(lr);
-			lr = next;
-		}
-	}
-
-#ifdef _DEBUG
-	bool Fragment::hasOnlyTreeLinks()
-	{
-		// check that all incoming links are on the same tree
-		bool isIt = true;
-		GuardRecord *lr = _links;
-		while (lr)
-		{
-			GuardRecord *next = lr->next;
-			NanoAssert(lr->target == this);  // def'n of GuardRecord
-			if (lr->from->root != root)
-			{
-				isIt = false;
-				break;
-			}
-			lr = next;
-		}	
-		return isIt;		
-	}
-#endif
-
-	void Fragment::removeIntraLinks()
-	{
-		// should only be called on root of tree
-		NanoAssert(isRoot());
-		GuardRecord *lr = _links;
-		while (lr)
-		{
-			GuardRecord *next = lr->next;
-			NanoAssert(lr->target == this);  // def'n of GuardRecord
-			if (lr->from->root == root)
-				removeLink(lr);
-			lr = next;
-		}	
-	}
-	
-	void Fragment::unlinkBranches(Assembler* /*assm*/)
-	{
-		// should only be called on root of tree
-		NanoAssert(isRoot());
-		Fragment* frag = treeBranches;
-		while(frag)
-		{
-			NanoAssert(frag->kind == BranchTrace && frag->hasOnlyTreeLinks());
-			frag->_links = 0;
-			frag->fragEntry = 0;
-			frag = frag->treeBranches;
-		}
-	}
-
-	void Fragment::linkBranches(Assembler* assm)
-	{
-		// should only be called on root of tree
-		NanoAssert(isRoot());
-		Fragment* frag = treeBranches;
-		while(frag)
-		{
-			if (frag->fragEntry) frag->link(assm);
-			frag = frag->treeBranches;
-		}
-	}
-	
     void Fragment::blacklist()
     {
         blacklistLevel++;
diff -r 17e9560465b0 js/src/nanojit/Fragmento.h
--- a/js/src/nanojit/Fragmento.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/nanojit/Fragmento.h	Thu Oct 30 05:41:45 2008 -0400
@@ -54,7 +54,6 @@
     struct PageHeader
     {
         struct Page *next;
-        verbose_only (int seq;) // sequence # of page
     };
     struct Page: public PageHeader
     {
@@ -101,11 +100,11 @@
 			Page*		pageAlloc();
 			void		pageFree(Page* page);
 			
-			Fragment*   newLoop(const void* ip);
             Fragment*   getLoop(const void* ip);
+            Fragment*   getAnchor(const void* ip);
 			void        clearFrags();	// clear all fragments from the cache
             Fragment*   getMerge(GuardRecord *lr, const void* ip);
-            Fragment*   createBranch(GuardRecord *lr, const void* ip);
+            Fragment*   createBranch(SideExit *exit, const void* ip);
             Fragment*   newFrag(const void* ip);
             Fragment*   newBranch(Fragment *from, const void* ip);
 
@@ -145,13 +144,13 @@
 			DWB(Assembler*)		_assm;
 			DWB(FragmentMap*)	_frags;		/* map from ip -> Fragment ptr  */
 			Page*			_pageList;
-            uint32_t        _pageGrowth;
 
 			/* unmanaged mem */
 			AllocList	_allocList;
 			GCHeap*		_gcHeap;
 
 			const uint32_t _max_pages;
+			uint32_t _pagesGrowth;
 	};
 
 	enum TraceKind {
@@ -179,15 +178,7 @@
 			int32_t&		hits()							{ return _hits; }
             void            blacklist();
 			bool			isBlacklisted()		{ return _hits < 0; }
-			void			resetLinks();
-			void			addLink(GuardRecord* lnk);
-			void			removeLink(GuardRecord* lnk);
-			void			link(Assembler* assm);
-			void			linkBranches(Assembler* assm);
-			void			unlink(Assembler* assm);
-			void			unlinkBranches(Assembler* assm);
 			debug_only( bool hasOnlyTreeLinks(); )
-			void			removeIntraLinks();
 			void			releaseLirBuffer();
 			void			releaseCode(Fragmento* frago);
 			void			releaseTreeMem(Fragmento* frago);
@@ -218,8 +209,7 @@
 			DWB(BlockHist*) mergeCounts;
             DWB(LirBuffer*) lirbuf;
 			LIns*			lastIns;
-			LIns*		spawnedFrom;
-			GuardRecord*	outbound;
+			SideExit*       spawnedFrom;
 			
 			TraceKind kind;
 			const void* ip;
@@ -236,18 +226,5 @@
 			int32_t			_hits;
 			Page*			_pages;		// native code pages 
 	};
-	
-#ifdef NJ_VERBOSE
-	inline int nbr(LInsp x) 
-	{
-        Page *p = x->page();
-        return (p->seq * NJ_PAGE_SIZE + (intptr_t(x)-intptr_t(p))) / sizeof(LIns);
-	}
-#else
-    inline int nbr(LInsp x)
-    {
-        return (int)(intptr_t(x) & intptr_t(NJ_PAGE_SIZE-1));
-    }
-#endif
 }
 #endif // __nanojit_Fragmento__
diff -r 17e9560465b0 js/src/nanojit/LIR.cpp
--- a/js/src/nanojit/LIR.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/nanojit/LIR.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -38,6 +38,11 @@
 
 #include "nanojit.h"
 #include <stdio.h>
+#include <ctype.h>
+
+#ifdef PERFM
+#include "../vprof/vprof.h"
+#endif /* PERFM */
 
 namespace nanojit
 {
@@ -45,9 +50,9 @@
 	#ifdef FEATURE_NANOJIT
 
 	const uint8_t operandCount[] = {
-	/* 0 */		2, 2, /*trace*/0, /*nearskip*/0, /*skip*/0, /*neartramp*/0, /*tramp*/0, 2, 2, 2,
-	/* 10 */	/*param*/0, 2, 2, 2, 2, 2, 2, 2, /*call*/0, /*loop*/0,
-	/* 20 */	/*x*/0, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	/* 0 */		/*trace*/0, /*nearskip*/0, /*skip*/0, /*neartramp*/0, /*tramp*/0, 2, 2, 2, 2, /*addp*/2, 
+	/* 10 */	/*param*/0, 2, 2, /*alloc*/0, 2, /*ret*/1, /*live*/1, /*calli*/0, /*call*/0, /*loop*/0,
+	/* 20 */	/*x*/0, 0, 1, 1, /*label*/0, 2, 2, 2, 2, 2,
 	/* 30 */	2, 2, /*short*/0, /*int*/0, 2, 2, /*neg*/1, 2, 2, 2,
 #if defined NANOJIT_64BIT
 	/* 40 */	/*callh*/0, 2, 2, 2, /*not*/1, 2, 2, 2, /*xt*/1, /*xf*/1,
@@ -55,9 +60,9 @@
 	/* 40 */	/*callh*/1, 2, 2, 2, /*not*/1, 2, 2, 2, /*xt*/1, /*xf*/1,
 #endif
 	/* 50 */	/*qlo*/1, /*qhi*/1, 2, /*ov*/1, /*cs*/1, 2, 2, 2, 2, 2,
-	/* 60 */	2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-	/* 70 */	2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-	/* 80 */	2, 2, /*fcall*/0, 2, 2, 2, 2, 2, 2, 2,
+	/* 60 */	2, 2, 2, 2, 2, /*file*/1, /*line*/1, 2, 2, 2,
+	/* 70 */	2, 2, 2, 2, 2, 2, 2, 2, 2, /*fret*/1,
+	/* 80 */	2, /*fcalli*/0, /*fcall*/0, 2, 2, 2, 2, 2, 2, 2,
 	/* 90 */	2, 2, 2, 2, 2, 2, 2, /*quad*/0, 2, 2,
 	/* 100 */	/*fneg*/1, 2, 2, 2, 2, 2, /*i2f*/1, /*u2f*/1, 2, 2,
 	/* 110 */	2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
@@ -68,17 +73,17 @@
 	#ifdef NJ_VERBOSE
 
 	const char* lirNames[] = {
-	/* 0-9 */	"0","1","trace","nearskip","skip","neartramp","tramp","7","8","9",
-	/* 10-19 */	"param","st","ld","13","sti","15","16","17","call","loop",
-	/* 20-29 */ "x","21","22","23","24","25","feq","flt","fgt","fle",
+	/* 0-9 */	"start","nearskip","skip","neartramp","tramp","5","6","7","8","addp",
+	/* 10-19 */	"param","st","ld","alloc","sti","ret","live","calli","call","loop",
+	/* 20-29 */ "x","j","jt","jf","label","25","feq","flt","fgt","fle",
 	/* 30-39 */ "fge","cmov","short","int","ldc","","neg","add","sub","mul",
 	/* 40-49 */ "callh","and","or","xor","not","lsh","rsh","ush","xt","xf",
 	/* 50-59 */ "qlo","qhi","ldcb","ov","cs","eq","lt","gt","le","ge",
 	/* 60-63 */ "ult","ugt","ule","uge",
-	/* 64-69 */ "LIR64","65","66","67","68","69",
-	/* 70-79 */ "70","71","72","73","74","stq","ldq","77","stqi","79",
-	/* 80-89 */ "80","81","fcall","83","84","85","86","87","qiand","qiadd",
-	/* 90-99 */ "90","91","92","93","qcmov","95","96","quad","98","99",
+	/* 64-69 */ "LIR64","file","line","67","68","69",
+	/* 70-79 */ "70","71","72","73","74","stq","ldq","77","stqi","fret",
+	/* 80-89 */ "80","fcalli","fcall","83","84","85","86","87","88","89",
+	/* 90-99 */ "90","91","92","93","94","95","96","quad","ldqc","99",
 	/* 100-109 */ "fneg","fadd","fsub","fmul","fdiv","qjoin","i2f","u2f","qior","qilsh",
 	/* 110-119 */ "110","111","112","113","114","115","116","117","118","119",
 	/* 120-127 */ "120","121","122","123","124","125","126","127"
@@ -98,16 +103,12 @@
 	
 	// LCompressedBuffer
 	LirBuffer::LirBuffer(Fragmento* frago, const CallInfo* functions)
-		: _frago(frago), _functions(functions)
+		: _frago(frago), _functions(functions), abi(ABI_FASTCALL), _start(0)
 	{
-		_start = 0;
 		clear();
 		_start = pageAlloc();
 		if (_start)
-		{
-			verbose_only(_start->seq = 0;)
 			_unused = &_start->lir[0];
-		}
 		//buffer_count++;
 		//fprintf(stderr, "LirBuffer %x start %x\n", (int)this, (int)_start);
 	}
@@ -138,6 +139,9 @@
 		_unused = 0;
 		_stats.lir = 0;
 		_noMem = 0;
+		for (int i = 0; i < NumSavedRegs; ++i)
+			savedParams[i] = NULL;
+		explicitSavedParams = false;
 	}
 
 	#ifdef _DEBUG
@@ -158,15 +162,16 @@
 	}
 	#endif 
 
-#ifdef NJ_VERBOSE
-	int LirBuffer::insCount() {
+	int32_t LirBuffer::insCount() 
+	{
+		// doesn't include embedded constants nor LIR_skip payload
 		return _stats.lir;
 	}
-	int LirBuffer::byteCount() {
-		return (_stats.pages-1) * (sizeof(Page)-sizeof(PageHeader)) +
-			(_unused - &_unused->page()->lir[0]) * sizeof(LIns);
+	int32_t LirBuffer::byteCount() 
+	{
+		return ((_stats.pages-1) * sizeof(Page)) +
+			((int32_t)_unused - (int32_t)pageTop(_unused));
 	}
-#endif
 
 	Page* LirBuffer::pageAlloc()
 	{
@@ -199,7 +204,6 @@
 		{
 			lastPage->next = page;  // forward link to next page 
 			_unused = &page->lir[0];
-            verbose_only(page->seq = lastPage->seq+1;)
 			//fprintf(stderr, "Fragmento::ensureRoom stamping %x with %x; start %x unused %x\n", (int)pageBottom(last), (int)page, (int)_start, (int)_unused);
 			debug_only( validate(); )
 			return true;
@@ -218,8 +222,8 @@
 		if (!samepage(last,last+2*count)
 			&& _buf->addPage()) 
 		{
-			// link LIR stream back to prior instruction (careful insFar relies on _unused...)
-			insFar(LIR_skip, last-1);
+			// link LIR stream back to prior instruction (careful insLink relies on _unused...)
+			insLink(LIR_skip, last-1);
 		}
 		return !_buf->outOmem();
 	}
@@ -241,14 +245,15 @@
     LIns* LIns::deref(int32_t off) const
     {
 		LInsp i = (LInsp) this-1 - off;
-        while (i->isTramp())
+        while (i && i->isTramp()) {
             i = i->ref();
+        }
 		return i;
     }
 
 	LInsp LirBufWriter::ensureReferenceable(LInsp i, int32_t addedDistance)
 	{
-		NanoAssert(!i->isTramp());
+		NanoAssert(i != 0 /* && !i->isTramp()*/);
 		LInsp next = _buf->next();
 		LInsp from = next + 2*addedDistance;
 		if (canReference(from,i))
@@ -259,7 +264,7 @@
             return rpref;
 
 		// need a trampoline to get to i
-		LInsp tramp = insFar(LIR_tramp, i);
+		LInsp tramp = insLink(LIR_tramp, i);
 		NanoAssert( tramp->ref() == i );
 
         if (i == _buf->sp)
@@ -311,10 +316,11 @@
 	LInsp LirBufWriter::ins0(LOpcode op)
 	{
 		ensureRoom(1);
-		LInsp l = _buf->next();
+        LirBuffer *b = this->_buf;
+		LInsp l = b->next();
 		l->initOpcode(op);
-		_buf->commit(1);
-		_buf->_stats.lir++;
+		b->commit(1);
+		b->_stats.lir++;
 		return l;
 	}
 	
@@ -325,8 +331,7 @@
 
 		LInsp l = _buf->next();
 		l->initOpcode(op);
-		if (r1)
-			l->setOprnd1(r1);
+		l->setOprnd1(r1);
 
 		_buf->commit(1);
 		_buf->_stats.lir++;
@@ -337,14 +342,12 @@
 	{
 		ensureRoom(3);
 		LInsp r1 = ensureReferenceable(o1,2);
-		LInsp r2 = ensureReferenceable(o2,1);
+        LInsp r2 = o2==o1 ? r1 : ensureReferenceable(o2,1);
 
 		LInsp l = _buf->next();
 		l->initOpcode(op);
-		if (r1)
-			l->setOprnd1(r1);
-		if (r2)
-			l->setOprnd2(r2);
+		l->setOprnd1(r1);
+		l->setOprnd2(r2);
 
 		_buf->commit(1);
 		_buf->_stats.lir++;
@@ -356,52 +359,85 @@
 		return ins2(op,base,d);
 	}
 
-	LInsp LirBufWriter::insGuard(LOpcode op, LInsp c, SideExit *x)
+	LInsp LirBufWriter::insGuard(LOpcode op, LInsp c, LInsp data)
 	{
-		LInsp data = skip(SideExitSize(x));
-		*((SideExit*)data->payload()) = *x;
 		return ins2(op, c, data);
 	}
 
-    LInsp LirBufWriter::insParam(int32_t arg)
+	LInsp LirBufWriter::insBranch(LOpcode op, LInsp condition, LInsp toLabel)
+	{
+		if (!toLabel)
+			toLabel = insFar(LIR_tramp,0); //empty tramp
+        if (!condition) {
+            // unconditional, just point to something
+            condition = toLabel;
+        }
+	    return ins2(op,condition,toLabel);
+	}
+
+    LInsp LirBufWriter::insAlloc(int32_t size)
+    {
+        size = (size+3)>>2; // # of required 32bit words
+        NanoAssert(isU16(size));
+		ensureRoom(1);
+		LInsp l = _buf->next();
+		l->initOpcode(LIR_alloc);
+		l->i.imm16 = uint16_t(size);
+		_buf->commit(1);
+		_buf->_stats.lir++;
+		return l;
+    }
+
+    LInsp LirBufWriter::insParam(int32_t arg, int32_t kind)
     {
 		ensureRoom(1);
-		LInsp l = _buf->next();
+        LirBuffer *b = this->_buf;
+		LInsp l = b->next();
 		l->initOpcode(LIR_param);
-		l->c.imm8a = Assembler::argRegs[arg];
-
-		_buf->commit(1);
-		_buf->_stats.lir++;
+        NanoAssert(isU8(arg) && isU8(kind));
+		l->c.imm8a = arg;
+        l->c.imm8b = kind;
+        if (kind) {
+            NanoAssert(arg < NumSavedRegs);
+            b->savedParams[arg] = l;
+            b->explicitSavedParams = true;
+        }
+		b->commit(1);
+		b->_stats.lir++;
 		return l;
     }
 	
 	LInsp LirBufWriter::insFar(LOpcode op, LInsp target)
 	{
+		ensureRoom(2);
+        LInsp l = _buf->next();
+
+		// write the pointer and operation
+		l = _buf->next()+1;
+		*((LInsp*)(l-1)) = target;
+		l->initOpcode(op);
+		_buf->commit(2);
+		_buf->_stats.lir++;
+		return l;
+	}
+	
+	LInsp LirBufWriter::insLink(LOpcode op, LInsp target)
+	{
         NanoAssert(op == LIR_skip || op == LIR_tramp);
+		ensureRoom(2);  // must be before _buf->next() 		
         LInsp l = _buf->next();
-        int d = target-l;
-        if (isS24(d)) {
-    		ensureRoom(1);
+        if (can24bReach(l,target))
+		{
             l->initOpcode(LOpcode(op-1)); // nearskip or neartramp
-            l->t.imm24 = d;
+            l->t.imm24 = target-l;
             _buf->commit(1);
-            return l;
+			_buf->_stats.lir++;
         }
-        else {
-            #if defined NANOJIT_64BIT
-            const unsigned int extra = 1;
-            #else
-            const unsigned int extra = 0;
-            #endif
-
-            ensureRoom(2 + extra);
-            // write the pointer and instruction
-            l = _buf->next()+1+extra;
-            *((LInsp*)(l-1-extra)) = target;
-            l->initOpcode(op);
-            _buf->commit(2+extra);
-		    return l;
-        }
+        else
+		{
+			l = insFar(op,target);
+		}
+		return l;
 	}
 	
 	LInsp LirBufWriter::insImm(int32_t imm)
@@ -439,7 +475,7 @@
 		ensureRoom(n+2);
 		LInsp last = _buf->next()-1;
 		_buf->commit(n);
-		return insFar(LIR_skip, last);
+		return insLink(LIR_skip, last);
 	}
 
 	LInsp LirReader::read()	
@@ -462,6 +498,8 @@
 #endif
 				case LIR_call:
 				case LIR_fcall:
+                case LIR_calli:
+                case LIR_fcalli:
 					i -= i->callInsWords();
 					break;
 
@@ -491,7 +529,7 @@
 					i -= 3;
 					break;
 
-				case LIR_trace:
+				case LIR_start:
 					_i = 0;  // start of trace
 					return cur;
 			}
@@ -509,6 +547,23 @@
 	bool FASTCALL isCond(LOpcode c) {
 		return (c == LIR_ov) || (c == LIR_cs) || isCmp(c);
 	}
+
+    bool FASTCALL isFloat(LOpcode c) {
+        switch (c) {
+            default:
+                return false;
+            case LIR_fadd:
+            case LIR_fsub:
+            case LIR_fmul:
+            case LIR_fdiv:
+            case LIR_fneg:
+            case LIR_fcall:
+            case LIR_fcalli:
+            case LIR_i2f:
+            case LIR_u2f:
+                return true;
+        }
+    }
     
 	bool LIns::isCmp() const {
 		return nanojit::isCmp(u.code);
@@ -522,33 +577,6 @@
 		return ((u.code & LIR64) != 0 || u.code == LIR_callh);
 	}
     
-	bool LIns::isCall() const
-	{
-		return ((u.code&~LIR64) == LIR_call
-				|| (u.code == LIR_callh));
-	}
-
-	bool LIns::isGuard() const
-	{
-		return u.code==LIR_x || u.code==LIR_xf || u.code==LIR_xt || u.code==LIR_loop;
-	}
-
-    bool LIns::isStore() const
-    {
-		int c = u.code & ~LIR64;
-        return c == LIR_st || c == LIR_sti;
-    }
-
-    bool LIns::isLoad() const
-    {
-        return u.code == LIR_ldq || u.code == LIR_ld || u.code == LIR_ldc;
-    }
-
-	bool LIns::isconst() const
-	{
-		return (opcode()&~1) == LIR_short;
-	}
-
 	bool LIns::isconstval(int32_t val) const
 	{
 		return isconst() && constval()==val;
@@ -584,6 +612,12 @@
 		i.imm16 = int16_t(x);
 	}
 
+	void LIns::setimm24(int32_t x)
+	{
+		NanoAssert(isS24(x));
+		t.imm24 = x;
+	}
+
 	void LIns::setresv(uint32_t resv)
 	{
 		NanoAssert(isU8(resv));
@@ -616,6 +650,28 @@
     {
         sti.disp = d;
     }
+
+    LIns **LIns::targetAddr() {
+		NanoAssert(isBranch());
+		LInsp i = (LInsp) this-1 - u.oprnd_2;
+        NanoAssert(i->isTramp());
+        LInsp ref;
+        while ((ref=i->ref()) != 0 && ref->isTramp())
+            i = ref;
+		NanoAssert(i->isop(LIR_tramp));
+		return (LIns**)(i-1);
+    }
+
+    void LIns::target(LInsp label) {
+        NanoAssert(label && label->isop(LIR_label));
+        *(targetAddr()) = label;
+	}
+
+	LInsp LIns::getTarget()
+	{
+        NanoAssert(isBranch());
+        return oprnd2();
+	}
 
 	LInsp	LIns::oprnd1() const	
 	{
@@ -673,9 +729,26 @@
 			if (i->isop(LIR_qjoin))
 				return i->oprnd2();
 		}
+		else if (i->isconst()) {
+			int32_t c = i->constval();
+			if (v == LIR_neg)
+				return insImm(-c);
+			if (v == LIR_not)
+				return insImm(~c);
+		}
 		else if (v == i->opcode() && (v == LIR_not || v == LIR_neg || v == LIR_fneg)) {
+            // not(not(x)) = x;  neg(neg(x)) = x;  fneg(fneg(x)) = x;
 			return i->oprnd1();
 		}
+        /* [ed 8.27.08] this causes a big slowdown in gameoflife.as.  why?
+        else if (i->isconst()) {
+            if (v == LIR_i2f) {
+                return insImmf(i->constval());
+            }
+            else if (v == LIR_u2f) {
+                return insImmf((uint32_t)i->constval());
+            }
+        }*/
 
 		// todo
 		// -(a-b) = b-a
@@ -754,7 +827,7 @@
 		else if (oprnd1->isconstq() && oprnd2->isconstq())
 		{
 			double c1 = oprnd1->constvalf();
-			double c2 = oprnd1->constvalf();
+			double c2 = oprnd2->constvalf();
 			if (v == LIR_feq)
 				return insImm(c1 == c2);
 			if (v == LIR_flt)
@@ -768,7 +841,7 @@
 		}
 		else if (oprnd1->isconst() && !oprnd2->isconst())
 		{
-			if (v == LIR_add || v == LIR_mul ||
+			if (v == LIR_add || v == LIR_addp || v == LIR_mul ||
 				v == LIR_fadd || v == LIR_fmul ||
 				v == LIR_xor || v == LIR_or || v == LIR_and ||
 				v == LIR_eq) {
@@ -824,7 +897,7 @@
 
 			if (c == 0)
 			{
-				if (v == LIR_add || v == LIR_or || v == LIR_xor ||
+				if (v == LIR_add || v == LIR_addp || v == LIR_or || v == LIR_xor ||
 					v == LIR_sub || v == LIR_lsh || v == LIR_rsh || v == LIR_ush)
 					return oprnd1;
 				else if (v == LIR_and || v == LIR_mul)
@@ -858,7 +931,7 @@
 		return out->ins2(v, oprnd1, oprnd2);
 	}
 
-	LIns* ExprFilter::insGuard(LOpcode v, LInsp c, SideExit *x)
+	LIns* ExprFilter::insGuard(LOpcode v, LInsp c, LInsp x)
 	{
 		if (v == LIR_xt || v == LIR_xf) {
 			if (c->isconst()) {
@@ -885,6 +958,18 @@
 		return out->insGuard(v, c, x);
 	}
 
+    LIns* ExprFilter::insBranch(LOpcode v, LIns *c, LIns *t)
+    {
+        if (v == LIR_jt || v == LIR_jf) {
+            while (c->isop(LIR_eq) && c->oprnd1()->isCmp() && c->oprnd2()->isconstval(0)) {
+                // jt(eq(cmp,0)) => jf(cmp)   or   jf(eq(cmp,0)) => jt(cmp)
+                v = LOpcode(v ^ 1);
+                c = c->oprnd1();
+            }
+        }
+        return out->insBranch(v, c, t);
+    }
+
     LIns* LirWriter::insLoadi(LIns *base, int disp) 
     { 
         return insLoad(LIR_ld,base,disp);
@@ -895,10 +980,26 @@
 		return insLoad(op, base, insImm(disp));
 	}
 
+    LIns* LirWriter::store(LInsp value, LInsp base, int32_t d)
+    {
+		return isS8(d) ? insStorei(value, base, d)
+			: insStore(value, base, insImm(d));
+    }
+
 	LIns* LirWriter::ins_eq0(LIns* oprnd1)
 	{
 		return ins2i(LIR_eq, oprnd1, 0);
 	}
+
+    LIns* LirWriter::insImmf(double f)
+    {
+        union {
+            double f;
+            uint64_t q;
+        } u;
+        u.f = f;
+        return insImmq(u.q);
+    }
 
 	LIns* LirWriter::qjoin(LInsp lo, LInsp hi)
 	{
@@ -937,43 +1038,46 @@
     LIns* LirBufWriter::insCall(const CallInfo *ci, LInsp args[])
 	{
 		static const LOpcode k_callmap[] = { LIR_call, LIR_fcall, LIR_call, LIR_callh };
+		static const LOpcode k_callimap[] = { LIR_calli, LIR_fcalli, LIR_calli, LIR_skip };
 
 		uint32_t argt = ci->_argtypes;
-		LOpcode op = k_callmap[argt & 3];
+        LOpcode op = (ci->isIndirect() ? k_callimap : k_callmap)[argt & 3];
+        NanoAssert(op != LIR_skip); // LIR_skip here is just an error condition
 
-        ArgSize sizes[10];
-        uint32_t argc = ci->get_sizes(sizes);
+        ArgSize sizes[2*MAXARGS];
+        int32_t argc = ci->get_sizes(sizes);
 
 #ifdef NJ_SOFTFLOAT
 		if (op == LIR_fcall)
 			op = LIR_callh;
-		LInsp args2[5*2]; // arm could require 2 args per double
+		LInsp args2[MAXARGS*2]; // arm could require 2 args per double
 		int32_t j = 0;
-		for (int32_t i = 0; i < 5; i++) {
+		int32_t i = 0;
+		while (j < argc) {
 			argt >>= 2;
 			ArgSize a = ArgSize(argt&3);
 			if (a == ARGSIZE_F) {
-				LInsp q = args[i];
+				LInsp q = args[i++];
 				args2[j++] = ins1(LIR_qhi, q);
 				args2[j++] = ins1(LIR_qlo, q);
-			} else if (a != ARGSIZE_NONE) {
-				args2[j++] = args[i];
+			} else {
+				args2[j++] = args[i++];
 			}
 		}
 		args = args2;
         NanoAssert(j == argc);
 #endif
 
-		NanoAssert(argc < 8);
+		NanoAssert(argc <= (int)MAXARGS);
 		uint32_t words = argwords(argc);
 		ensureRoom(words+LIns::callInfoWords+1+argc);  // ins size + possible tramps
-		for (uint32_t i=0; i < argc; i++)
+		for (int32_t i=0; i < argc; i++)
 			args[i] = ensureReferenceable(args[i], argc-i);
 		uint8_t* offs = (uint8_t*)_buf->next();
 		LIns *l = _buf->next() + words;
 		*(const CallInfo **)l = ci;
 		l += LIns::callInfoWords;
-		for (uint32_t i=0; i < argc; i++)
+		for (int32_t i=0; i < argc; i++)
 			offs[i] = (uint8_t) l->reference(args[i]);
 #if defined NANOJIT_64BIT
 		l->initOpcode(op);
@@ -989,8 +1093,8 @@
 
     using namespace avmplus;
 
-	StackFilter::StackFilter(LirFilter *in, GC *gc, Fragment *frag, LInsp sp) 
-		: LirFilter(in), gc(gc), frag(frag), sp(sp), top(0)
+	StackFilter::StackFilter(LirFilter *in, GC *gc, LirBuffer *lirbuf, LInsp sp) 
+		: LirFilter(in), gc(gc), lirbuf(lirbuf), sp(sp), top(0)
 	{}
 
 	LInsp StackFilter::read() 
@@ -1030,6 +1134,11 @@
 					}
 				}
 			}
+			/* 
+			 * NB: If there is a backward branch other than the loop-restart branch, this is
+			 * going to be wrong. Unfortunately there doesn't seem to be an easy way to detect
+			 * such branches. Just do not create any.
+			 */
 			else if (i->isGuard())
 			{
 				stk.reset();
@@ -1086,13 +1195,19 @@
 	}
 
 	LInsHashSet::LInsHashSet(GC* gc) : 
-			m_list(gc, kInitialCap), m_used(0), m_gc(gc)
+			m_used(0), m_cap(kInitialCap), m_gc(gc)
 	{
 #ifdef MEMORY_INFO
-		m_list.set_meminfo_name("LInsHashSet.list");
+//		m_list.set_meminfo_name("LInsHashSet.list");
 #endif
-		m_list.set(kInitialCap-1, 0);
+        LInsp *list = (LInsp*) gc->Alloc(sizeof(LInsp)*m_cap);
+        WB(gc, this, &m_list, list);
 	}
+
+    void LInsHashSet::clear() {
+        memset(m_list, 0, sizeof(LInsp)*m_cap);
+        m_used = 0;
+    }
 	
 	/*static*/ uint32_t FASTCALL LInsHashSet::hashcode(LInsp i)
 	{
@@ -1173,30 +1288,31 @@
 
 	void FASTCALL LInsHashSet::grow()
 	{
-		const uint32_t newcap = m_list.size() << 1;
-		InsList newlist(m_gc, newcap);
+		const uint32_t newcap = m_cap << 1;
+        LInsp *newlist = (LInsp*) m_gc->Alloc(newcap * sizeof(LInsp));
+        LInsp *list = m_list;
 #ifdef MEMORY_INFO
-		newlist.set_meminfo_name("LInsHashSet.list");
+//		newlist.set_meminfo_name("LInsHashSet.list");
 #endif
-		newlist.set(newcap-1, 0);
-		for (uint32_t i=0, n=m_list.size(); i < n; i++)
-		{
-			LInsp name = m_list.get(i);
+		for (uint32_t i=0, n=m_cap; i < n; i++) {
+			LInsp name = list[i];
 			if (!name) continue;
 			uint32_t j = find(name, hashcode(name), newlist, newcap);
-			newlist.set(j, name);
+            newlist[j] = name;
 		}
-		m_list.become(newlist);
+        m_cap = newcap;
+        m_gc->Free(list);
+        WB(m_gc, this, &m_list, newlist);
 	}
 
-	uint32_t FASTCALL LInsHashSet::find(LInsp name, uint32_t hash, const InsList& list, uint32_t cap)
+	uint32_t FASTCALL LInsHashSet::find(LInsp name, uint32_t hash, const LInsp *list, uint32_t cap)
 	{
 		const uint32_t bitmask = (cap - 1) & ~0x1;
 
 		uint32_t n = 7 << 1;
 		hash &= bitmask;  
 		LInsp k;
-		while ((k = list.get(hash)) != NULL &&
+		while ((k = list[hash]) != NULL &&
 			(!LIns::sameop(k,name) || !equals(k, name)))
 		{
 			hash = (hash + (n += 2)) & bitmask;		// quadratic probe
@@ -1208,23 +1324,23 @@
 	{
 		// this is relatively short-lived so let's try a more aggressive load factor
 		// in the interest of improving performance
-		if (((m_used+1)<<1) >= m_list.size()) // 0.50
+		if (((m_used+1)<<1) >= m_cap) // 0.50
 		{
 			grow();
-			k = find(name, hashcode(name), m_list, m_list.size());
+			k = find(name, hashcode(name), m_list, m_cap);
 		}
-		NanoAssert(!m_list.get(k));
+		NanoAssert(!m_list[k]);
 		m_used++;
-		m_list.set(k, name);
-		return name;
+        return m_list[k] = name;
 	}
 
 	void LInsHashSet::replace(LInsp i)
 	{
-		uint32_t k = find(i, hashcode(i), m_list, m_list.size());
-		if (m_list.get(k)) {
+        LInsp *list = m_list;
+		uint32_t k = find(i, hashcode(i), list, m_cap);
+		if (list[k]) {
 			// already there, so replace it
-			m_list.set(k, i);
+			list[k] = i;
 		} else {
 			add(i, k);
 		}
@@ -1259,13 +1375,13 @@
 
 	LInsp LInsHashSet::find32(int32_t a, uint32_t &i)
 	{
-		uint32_t cap = m_list.size();
-		const InsList& list = m_list;
+		uint32_t cap = m_cap;
+		const LInsp *list = m_list;
 		const uint32_t bitmask = (cap - 1) & ~0x1;
 		uint32_t hash = hashimm(a) & bitmask;
 		uint32_t n = 7 << 1;
 		LInsp k;
-		while ((k = list.get(hash)) != NULL && 
+		while ((k = list[hash]) != NULL && 
 			(!k->isconst() || k->constval() != a))
 		{
 			hash = (hash + (n += 2)) & bitmask;		// quadratic probe
@@ -1276,13 +1392,13 @@
 
 	LInsp LInsHashSet::find64(uint64_t a, uint32_t &i)
 	{
-		uint32_t cap = m_list.size();
-		const InsList& list = m_list;
+		uint32_t cap = m_cap;
+		const LInsp *list = m_list;
 		const uint32_t bitmask = (cap - 1) & ~0x1;
 		uint32_t hash = hashimmq(a) & bitmask;  
 		uint32_t n = 7 << 1;
 		LInsp k;
-		while ((k = list.get(hash)) != NULL && 
+		while ((k = list[hash]) != NULL && 
 			(!k->isconstq() || k->constvalq() != a))
 		{
 			hash = (hash + (n += 2)) & bitmask;		// quadratic probe
@@ -1293,13 +1409,13 @@
 
 	LInsp LInsHashSet::find1(LOpcode op, LInsp a, uint32_t &i)
 	{
-		uint32_t cap = m_list.size();
-		const InsList& list = m_list;
+		uint32_t cap = m_cap;
+		const LInsp *list = m_list;
 		const uint32_t bitmask = (cap - 1) & ~0x1;
 		uint32_t hash = hash1(op,a) & bitmask;  
 		uint32_t n = 7 << 1;
 		LInsp k;
-		while ((k = list.get(hash)) != NULL && 
+		while ((k = list[hash]) != NULL && 
 			(k->opcode() != op || k->oprnd1() != a))
 		{
 			hash = (hash + (n += 2)) & bitmask;		// quadratic probe
@@ -1310,13 +1426,13 @@
 
 	LInsp LInsHashSet::find2(LOpcode op, LInsp a, LInsp b, uint32_t &i)
 	{
-		uint32_t cap = m_list.size();
-		const InsList& list = m_list;
+		uint32_t cap = m_cap;
+		const LInsp *list = m_list;
 		const uint32_t bitmask = (cap - 1) & ~0x1;
 		uint32_t hash = hash2(op,a,b) & bitmask;  
 		uint32_t n = 7 << 1;
 		LInsp k;
-		while ((k = list.get(hash)) != NULL && 
+		while ((k = list[hash]) != NULL && 
 			(k->opcode() != op || k->oprnd1() != a || k->oprnd2() != b))
 		{
 			hash = (hash + (n += 2)) & bitmask;		// quadratic probe
@@ -1335,13 +1451,13 @@
 
 	LInsp LInsHashSet::findcall(const CallInfo *ci, uint32_t argc, LInsp args[], uint32_t &i)
 	{
-		uint32_t cap = m_list.size();
-		const InsList& list = m_list;
+		uint32_t cap = m_cap;
+		const LInsp *list = m_list;
 		const uint32_t bitmask = (cap - 1) & ~0x1;
 		uint32_t hash = hashcall(ci, argc, args) & bitmask;  
 		uint32_t n = 7 << 1;
 		LInsp k;
-		while ((k = list.get(hash)) != NULL &&
+		while ((k = list[hash]) != NULL &&
 			(!k->isCall() || k->callInfo() != ci || !argsmatch(k, argc, args)))
 		{
 			hash = (hash + (n += 2)) & bitmask;		// quadratic probe
@@ -1350,10 +1466,10 @@
 		return k;
 	}
 
-    SideExit *LIns::exit()
+    GuardRecord *LIns::record()
     {
         NanoAssert(isGuard());
-        return (SideExit*)oprnd2()->payload();
+        return (GuardRecord*)oprnd2()->payload();
     }
 
 #ifdef NJ_VERBOSE
@@ -1380,7 +1496,7 @@
         }
 		void add(LInsp i, LInsp use) {
             if (!i->isconst() && !i->isconstq() && !live.containsKey(i)) {
-                NanoAssert(i->opcode() < sizeof(lirNames) / sizeof(lirNames[0]));
+                NanoAssert(unsigned(i->opcode()) < sizeof(lirNames) / sizeof(lirNames[0]));
                 live.put(i,use);
             }
 		}
@@ -1404,26 +1520,24 @@
 		}
 	};
 
-    void live(GC *gc, Assembler *assm, Fragment *frag)
+    void live(GC *gc, LirBuffer *lirbuf)
 	{
 		// traverse backwards to find live exprs and a few other stats.
 
-		LInsp sp = frag->lirbuf->sp;
-		LInsp rp = frag->lirbuf->rp;
 		LiveTable live(gc);
 		uint32_t exits = 0;
-		LirBuffer *lirbuf = frag->lirbuf;
         LirReader br(lirbuf);
-		StackFilter sf(&br, gc, frag, sp);
-		StackFilter r(&sf, gc, frag, rp);
-        int total = 0;
-        live.add(frag->lirbuf->state, r.pos());
+		StackFilter sf(&br, gc, lirbuf, lirbuf->sp);
+		StackFilter r(&sf, gc, lirbuf, lirbuf->rp);
+		int total = 0;
+        if (lirbuf->state)
+            live.add(lirbuf->state, r.pos());
 		for (LInsp i = r.read(); i != 0; i = r.read())
 		{
             total++;
 
             // first handle side-effect instructions
-			if (i->isStore() || i->isGuard() || i->isCall() && !i->callInfo()->_cse)
+			if (!i->isCse(lirbuf->_functions))
 			{
 				live.add(i,0);
                 if (i->isGuard())
@@ -1434,7 +1548,7 @@
 			if (live.contains(i))
 			{
 				live.retire(i,gc);
-                NanoAssert(i->opcode() < sizeof(operandCount) / sizeof(operandCount[0]));
+                NanoAssert(unsigned(i->opcode()) < sizeof(operandCount) / sizeof(operandCount[0]));
 				if (i->isStore()) {
 					live.add(i->oprnd2(),i); // base
 					live.add(i->oprnd1(),i); // val
@@ -1458,17 +1572,22 @@
 			}
 		}
  
-		assm->outputf("live instruction count %ld, total %ld, max pressure %d",
+		printf("live instruction count %d, total %u, max pressure %d\n",
 			live.retired.size(), total, live.maxlive);
-        assm->outputf("side exits %ld", exits);
+        printf("side exits %u\n", exits);
 
 		// print live exprs, going forwards
-		LirNameMap *names = frag->lirbuf->names;
+		LirNameMap *names = lirbuf->names;
+        bool newblock = true;
 		for (int j=live.retired.size()-1; j >= 0; j--) 
         {
             RetiredEntry *e = live.retired[j];
-            char livebuf[1000], *s=livebuf;
+            char livebuf[4000], *s=livebuf;
             *s = 0;
+            if (!newblock && e->i->isop(LIR_label)) {
+                printf("\n");
+            }
+            newblock = false;
             for (int k=0,n=e->live.size(); k < n; k++) {
 				strcpy(s, names->formatRef(e->live[k]));
 				s += strlen(s);
@@ -1476,8 +1595,10 @@
 				NanoAssert(s < livebuf+sizeof(livebuf));
             }
 			printf("%-60s %s\n", livebuf, names->formatIns(e->i));
-			if (e->i->isGuard())
+            if (e->i->isGuard() || e->i->isBranch() || isRet(e->i->opcode())) {
 				printf("\n");
+                newblock = true;
+            }
 		}
 	}
 
@@ -1516,7 +1637,12 @@
 
 	void LirNameMap::copyName(LInsp i, const char *s, int suffix) {
 		char s2[200];
-		sprintf(s2,"%s%d", s,suffix);
+		if (isdigit(s[strlen(s)-1])) {
+			// if s ends with a digit, add '_' to clarify the suffix
+			sprintf(s2,"%s_%d", s, suffix);
+		} else {
+			sprintf(s2,"%s%d", s, suffix);
+		}
 		addName(i, labels->core->newString(s2));
 	}
 
@@ -1562,7 +1688,7 @@
 				}
 #endif
 			} else {
-                NanoAssert(ref->opcode() < sizeof(lirNames) / sizeof(lirNames[0]));
+                NanoAssert(unsigned(ref->opcode()) < sizeof(lirNames) / sizeof(lirNames[0]));
 				copyName(ref, lirNames[ref->opcode()], lircounts.add(ref->opcode()));
 			}
 			StringNullTerminatedUTF8 cname(gc, names.get(ref)->name);
@@ -1575,11 +1701,6 @@
 	{
 		char sbuf[200];
 		char *s = sbuf;
-		if (!i->isStore() && !i->isGuard() && !i->isop(LIR_trace)) {
-			sprintf(s, "%s = ", formatRef(i));
-			s += strlen(s);
-		}
-
 		LOpcode op = i->opcode();
 		switch(op)
 		{
@@ -1590,15 +1711,20 @@
 				break;
 			}
 
+            case LIR_alloc: {
+                sprintf(s, "%s = %s %d", formatRef(i), lirNames[op], i->size());
+                break;
+            }
+
 			case LIR_quad:
 			{
 				int32_t *p = (int32_t*) (i-2);
-				sprintf(s, "#%X:%X", p[1], p[0]);
+				sprintf(s, "#%X:%X /* %g */", p[1], p[0], i->constvalf());
 				break;
 			}
 
 			case LIR_loop:
-			case LIR_trace:
+			case LIR_start:
 				sprintf(s, "%s", lirNames[op]);
 				break;
 
@@ -1607,7 +1733,7 @@
 #endif
 			case LIR_fcall:
 			case LIR_call: {
-				sprintf(s, "%s ( ", i->callInfo()->_name);
+				sprintf(s, "%s = %s ( ", formatRef(i), i->callInfo()->_name);
 				for (int32_t j=i->argc()-1; j >= 0; j--) {
 					s += strlen(s);
 					sprintf(s, "%s ",formatRef(i->arg(j)));
@@ -1616,11 +1742,59 @@
 				sprintf(s, ")");
 				break;
 			}
+			case LIR_fcalli:
+			case LIR_calli: {
+                int32_t argc = i->argc();
+				sprintf(s, "%s = [%s] ( ", formatRef(i), formatRef(i->arg(argc-1)));
+                s += strlen(s);
+                argc--;
+				for (int32_t j=argc-1; j >= 0; j--) {
+					s += strlen(s);
+					sprintf(s, "%s ",formatRef(i->arg(j)));
+				}
+				s += strlen(s);
+				sprintf(s, ")");
+				break;
+			}
 
-			case LIR_param:
-                sprintf(s, "%s %s", lirNames[op], gpn(i->imm8()));
+			case LIR_param: { 
+				uint32_t arg = i->imm8();
+				if (!i->imm8b()) {
+					if (arg < sizeof(Assembler::argRegs)/sizeof(Assembler::argRegs[0])) {
+						sprintf(s, "%s = %s %d %s", formatRef(i), lirNames[op],
+							arg, gpn(Assembler::argRegs[arg]));
+					} else {
+						sprintf(s, "%s = %s %d", formatRef(i), lirNames[op], arg);
+					}
+				} else {
+					sprintf(s, "%s = %s %d %s", formatRef(i), lirNames[op],
+						arg, gpn(Assembler::savedRegs[arg]));
+				}
+				break;
+			}
+
+			case LIR_label:
+                sprintf(s, "%s:", formatRef(i));
 				break;
 
+			case LIR_jt:
+			case LIR_jf:
+                sprintf(s, "%s %s -> %s", lirNames[op], formatRef(i->oprnd1()), 
+                    i->oprnd2() ? formatRef(i->oprnd2()) : "unpatched");
+				break;
+
+			case LIR_j:
+                sprintf(s, "%s -> %s", lirNames[op], 
+                    i->oprnd2() ? formatRef(i->oprnd2()) : "unpatched");
+				break;
+
+            case LIR_live:
+			case LIR_ret:
+            case LIR_fret:
+                sprintf(s, "%s %s", lirNames[op], formatRef(i->oprnd1()));
+				break;
+				
+            case LIR_callh:
 			case LIR_neg:
 			case LIR_fneg:
 			case LIR_i2f:
@@ -1630,7 +1804,7 @@
             case LIR_ov:
             case LIR_cs:
 			case LIR_not: 
-				sprintf(s, "%s %s", lirNames[op], formatRef(i->oprnd1()));
+				sprintf(s, "%s = %s %s", formatRef(i), lirNames[op], formatRef(i->oprnd1()));
 				break;
 
 			case LIR_x:
@@ -1640,6 +1814,7 @@
 				break;
 
 			case LIR_add:
+			case LIR_addp:
 			case LIR_sub: 
 		 	case LIR_mul: 
 			case LIR_fadd:
@@ -1670,7 +1845,7 @@
             case LIR_qiand:
             case LIR_qilsh:
             case LIR_qior:
-				sprintf(s, "%s %s, %s", lirNames[op],
+				sprintf(s, "%s = %s %s, %s", formatRef(i), lirNames[op],
 					formatRef(i->oprnd1()), 
 					formatRef(i->oprnd2()));
 				break;
@@ -1683,7 +1858,7 @@
 
 			case LIR_qcmov:
 			case LIR_cmov:
-                sprintf(s, "%s ? %s : %s", 
+                sprintf(s, "%s = %s %s ? %s : %s", formatRef(i), lirNames[op],
 					formatRef(i->oprnd1()), 
 					formatRef(i->oprnd2()->oprnd1()), 
 					formatRef(i->oprnd2()->oprnd2()));
@@ -1692,8 +1867,9 @@
 			case LIR_ld: 
 			case LIR_ldc: 
 			case LIR_ldq: 
+			case LIR_ldqc: 
 			case LIR_ldcb: 
-				sprintf(s, "%s %s[%s]", lirNames[op],
+				sprintf(s, "%s = %s %s[%s]", formatRef(i), lirNames[op],
 					formatRef(i->oprnd1()), 
 					formatRef(i->oprnd2()));
 				break;
@@ -1702,7 +1878,7 @@
             case LIR_sti:
 			case LIR_stq: 
             case LIR_stqi:
-				sprintf(s, "%s[%d] = %s", 
+				sprintf(s, "%s %s[%d] = %s", lirNames[op],
 					formatRef(i->oprnd2()), 
 					i->immdisp(), 
 					formatRef(i->oprnd1()));
@@ -1777,7 +1953,7 @@
 		return out->insLoad(v,base,disp);
 	}
 
-	LInsp CseFilter::insGuard(LOpcode v, LInsp c, SideExit *x)
+	LInsp CseFilter::insGuard(LOpcode v, LInsp c, LInsp x)
 	{
 		if (isCse(v)) {
 			// conditional guard
@@ -1833,13 +2009,13 @@
 		verbose_only( assm->_outputCache = &asmOutput; )
 
 		verbose_only(if (assm->_verbose && core->config.verbose_live)
-			live(gc, assm, triggerFrag);)
+			live(gc, triggerFrag->lirbuf);)
 
 		bool treeCompile = core->config.tree_opt && (triggerFrag->kind == BranchTrace);
 		RegAllocMap regMap(gc);
 		NInsList loopJumps(gc);
 #ifdef MEMORY_INFO
-		loopJumps.set_meminfo_name("LIR loopjumps");
+//		loopJumps.set_meminfo_name("LIR loopjumps");
 #endif
 		assm->beginAssembly(triggerFrag, &regMap);
 
@@ -1849,9 +2025,6 @@
 		{
 			// recompile the entire tree
 			root = triggerFrag->root;
-			root->removeIntraLinks();
-			root->unlink(assm);			// unlink all incoming jumps ; since the compile() can fail
-			root->unlinkBranches(assm); // no one jumps into a branch (except from within the tree) so safe to clear the links table
 			root->fragEntry = 0;
 			root->releaseCode(frago);
 			
@@ -1872,7 +2045,7 @@
 					RegAlloc* regs = new (gc) RegAlloc();
 					assm->copyRegisters(regs);
 					assm->releaseRegisters();
-					SideExit* exit = frag->spawnedFrom->exit();
+					SideExit* exit = frag->spawnedFrom;
 					regMap.put(exit, regs);
 				}
 				frag = frag->treeBranches;
@@ -1884,27 +2057,60 @@
 		verbose_only(if (assm->_verbose) 
 			assm->outputf("compiling trunk %s",
 				frago->labels->format(root));)
+		NanoAssert(!frago->core()->config.tree_opt || root == root->anchor || root->kind == MergeTrace);			
 		assm->endAssembly(root, loopJumps);
 			
 		// reverse output so that assembly is displayed low-to-high
 		verbose_only( assm->_outputCache = 0; )
 		verbose_only(for(int i=asmOutput.size()-1; i>=0; --i) { assm->outputf("%s",asmOutput.get(i)); } );
 
-		if (assm->error())
-		{
+		if (assm->error()) {
 			root->fragEntry = 0;
 		}
-		else
-		{
-			root->link(assm);
-			if (treeCompile) root->linkBranches(assm);
-		}
+    }
 
-#if defined(NJ_VERBOSE)
-        for (size_t i = 0; i < asmOutput.size(); i++) {
-            gc->Free(asmOutput.get(i));
+    LInsp LoadFilter::insLoad(LOpcode v, LInsp base, LInsp disp)
+    {
+        if (base != sp && base != rp && (v == LIR_ld || v == LIR_ldq)) {
+            uint32_t k;
+            LInsp found = exprs.find2(v, base, disp, k);
+            if (found)
+                return found;
+            return exprs.add(out->insLoad(v,base,disp), k);
         }
-#endif
+        return out->insLoad(v, base, disp);
+    }
+
+    void LoadFilter::clear(LInsp p)
+    {
+        if (p != sp && p != rp)
+            exprs.clear();
+    }
+
+    LInsp LoadFilter::insStore(LInsp v, LInsp b, LInsp d)
+    {
+        clear(b);
+        return out->insStore(v, b, d);
+    }
+
+    LInsp LoadFilter::insStorei(LInsp v, LInsp b, int32_t d)
+    {
+        clear(b);
+        return out->insStorei(v, b, d);
+    }
+
+    LInsp LoadFilter::insCall(const CallInfo *call, LInsp args[])
+    {
+        if (!call->_cse)
+            exprs.clear();
+        return out->insCall(call, args);
+    }
+
+    LInsp LoadFilter::ins0(LOpcode op)
+    {
+        if (op == LIR_label)
+            exprs.clear();
+        return out->ins0(op);
     }
 
 	#endif /* FEATURE_NANOJIT */
@@ -1957,7 +2163,7 @@
 				return dup(b);
 			}
 			else if (p > start && p < end) {
-				int d = (intptr_t(p)-intptr_t(start)) >> e->align;
+				int32_t d = int32_t(intptr_t(p)-intptr_t(start)) >> e->align;
 				if (addrs)
 					sprintf(b, "%p %s+%d", p, name, d);
 				else
@@ -1981,7 +2187,7 @@
 
 	const char *LabelMap::dup(const char *b)
 	{
-		int need = strlen(b)+1;
+		size_t need = strlen(b)+1;
 		char *s = end;
 		end += need;
 		if (end > buf+sizeof(buf)) {
diff -r 17e9560465b0 js/src/nanojit/LIR.h
--- a/js/src/nanojit/LIR.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/nanojit/LIR.h	Thu Oct 30 05:41:45 2008 -0400
@@ -39,8 +39,6 @@
 #ifndef __nanojit_LIR__
 #define __nanojit_LIR__
 
-namespace avmplus { class RegionTracker; }
-
 /**
  * Fundamentally, the arguments to the various operands can be grouped along
  * two dimensions.  One dimension is size: can the arguments fit into a 32-bit
@@ -63,23 +61,34 @@
 		LIR64	= 0x40,			// result is double or quad
 		
 		// special operations (must be 0..N)
-		LIR_trace = 2,	
-		LIR_nearskip = 3, // must be LIR_skip-1 and lsb=1
-		LIR_skip = 4,
-        LIR_neartramp = 5, // must be LIR_tramp-1 and lsb=1
-        LIR_tramp = 6,
+		LIR_start = 0,	
+		LIR_nearskip = 1, // must be LIR_skip-1 and lsb=1
+		LIR_skip = 2,
+        LIR_neartramp = 3, // must be LIR_tramp-1 and lsb=1
+        LIR_tramp = 4,
 
 		// non-pure operations
+		LIR_addp    = 9,
 		LIR_param	= 10,
 		LIR_st		= 11, // 32-bit store
 		LIR_ld		= 12, // 32-bit load
+		LIR_alloc   = 13, // alloca some stack space
         LIR_sti     = 14,
-		LIR_call	= 18, // subrouting call returning a 32-bit value
+		LIR_ret     = 15,
+		LIR_live    = 16, // extend live range of reference
+		LIR_calli   = 17, // indirect call	
+		LIR_call	= 18, // subroutine call returning a 32-bit value
 			
 		// guards
 		LIR_loop    = 19, // loop fragment
 		LIR_x		= 20, // exit always
 
+		// branches
+		LIR_j		= 21, // jump always
+		LIR_jt		= 22, // jump true
+		LIR_jf		= 23, // jump false
+		LIR_label	= 24, // a jump target
+		LIR_ji      = 25, // jump indirect
 		// operators
 
 		// LIR_feq though LIR_fge must only be used on float arguments.  They
@@ -137,18 +146,25 @@
 		LIR_ule		= 62, // 0x3E 0011 1110
 		LIR_uge		= 63, // 0x3F 0011 1111
 
+		// non-64bit ops, but we're out of code space below 64
+		LIR_file    = 1 | LIR64,
+		LIR_line    = 2 | LIR64,
+
 		/**
 		 * 64bit operations
 		 */
 		LIR_stq		= LIR_st | LIR64, // quad store
 		LIR_stqi	= LIR_sti | LIR64,
+		LIR_fret    = LIR_ret | LIR64,
 		LIR_quad    = LIR_int | LIR64, // quad constant value
 		LIR_ldq		= LIR_ld    | LIR64, // quad load
+		LIR_ldqc    = LIR_ldc   | LIR64,
         LIR_qiand   = 24 | LIR64,
         LIR_qiadd   = 25 | LIR64,
         LIR_qilsh   = LIR_lsh | LIR64,
 
 		LIR_fcall   = LIR_call  | LIR64, // subroutine call returning quad
+		LIR_fcalli  = LIR_calli | LIR64,
 		LIR_fneg	= LIR_neg  | LIR64, // floating-point numeric negation
 		LIR_fadd	= LIR_add  | LIR64, // floating-point addition
 		LIR_fsub	= LIR_sub  | LIR64, // floating-point subtraction
@@ -164,6 +180,7 @@
 
 	#if defined NANOJIT_64BIT
 	#define LIR_ldp     LIR_ldq
+	#define LIR_stp     LIR_stq
     #define LIR_piadd   LIR_qiadd
     #define LIR_piand   LIR_qiand
     #define LIR_pilsh   LIR_qilsh
@@ -171,6 +188,7 @@
     #define LIR_pior    LIR_qior
 	#else
 	#define LIR_ldp     LIR_ld
+	#define LIR_stp     LIR_st
     #define LIR_piadd   LIR_add
     #define LIR_piand   LIR_and
     #define LIR_pilsh   LIR_lsh
@@ -182,9 +200,74 @@
 		return (argc+3)>>2;
 	}
 
+	struct GuardRecord;
     struct SideExit;
     struct Page;
-    struct CallInfo;
+
+    enum AbiKind {
+        ABI_FASTCALL,
+        ABI_THISCALL,
+		ABI_STDCALL,
+        ABI_CDECL
+    };
+
+    enum ArgSize {
+	    ARGSIZE_NONE = 0,
+	    ARGSIZE_F = 1,
+	    ARGSIZE_LO = 2,
+	    ARGSIZE_Q = 3,
+	    _ARGSIZE_MASK_INT = 2, 
+        _ARGSIZE_MASK_ANY = 3
+    };
+
+    struct CallInfo
+	{
+		uintptr_t	_address;
+        uint32_t	_argtypes:18;	// 9 2-bit fields indicating arg type, by ARGSIZE above (including ret type): a1 a2 a3 a4 a5 ret
+        uint8_t		_cse:1;			// true if no side effects
+        uint8_t		_fold:1;		// true if no side effects
+        AbiKind     _abi:3;
+		verbose_only ( const char* _name; )
+		
+		uint32_t FASTCALL _count_args(uint32_t mask) const;
+        uint32_t get_sizes(ArgSize*) const;
+
+        inline bool isInterface() const {
+            return _address == 2 || _address == 3; /* hack! */
+        }
+        inline bool isIndirect() const {
+            return _address < 256;
+        }
+		inline uint32_t FASTCALL count_args() const {
+            return _count_args(_ARGSIZE_MASK_ANY) + isIndirect();
+        }
+		inline uint32_t FASTCALL count_iargs() const {
+            return _count_args(_ARGSIZE_MASK_INT);
+        }
+		// fargs = args - iargs
+	};
+
+    inline bool isGuard(LOpcode op) {
+        return op==LIR_x || op==LIR_xf || op==LIR_xt || op==LIR_loop;
+    }
+
+    inline bool isCall(LOpcode op) {
+        op = LOpcode(op & ~LIR64);
+        return op == LIR_call || op == LIR_calli;
+    }
+
+    inline bool isStore(LOpcode op) {
+        op = LOpcode(op & ~LIR64);
+        return op == LIR_st || op == LIR_sti;
+    }
+
+    inline bool isConst(LOpcode op) {
+        return (op & ~1) == LIR_short;
+    }
+
+    inline bool isLoad(LOpcode op) {
+        return op == LIR_ldq || op == LIR_ld || op == LIR_ldc || op == LIR_ldqc;
+    }
 
 	// Low-level Instruction 4B
 	// had to lay it our as a union with duplicate code fields since msvc couldn't figure out how to compact it otherwise.
@@ -290,7 +373,9 @@
 
 		inline LOpcode	opcode() const	{ return u.code; }
 		inline uint8_t	imm8()	 const	{ return c.imm8a; }
+		inline uint8_t	imm8b()	 const	{ return c.imm8b; }
 		inline int16_t	imm16()	 const	{ return i.imm16; }
+		inline int32_t	imm24()	 const	{ return t.imm24; }
 		inline LIns*	ref()	 const	{ 
 #if defined NANOJIT_64BIT
             return (t.code & 1) ? (LIns*)this+t.imm24 : *(LIns**)(this-2);
@@ -302,6 +387,14 @@
 		inline uint8_t	resv()	 const  { return g.resv; }
         void*	payload() const;
         inline Page*	page()			{ return (Page*) alignTo(this,NJ_PAGE_SIZE); }
+        inline int32_t  size() const {
+            NanoAssert(isop(LIR_alloc));
+            return i.imm16<<2;
+        }
+        inline void setSize(int32_t bytes) {
+            NanoAssert(isop(LIR_alloc) && (bytes&3)==0 && isU16(bytes>>2));
+            i.imm16 = bytes>>2;
+        }
 
 		// index args in r-l order.  arg(0) is rightmost arg
 		inline LIns* arg(uint32_t i) {
@@ -375,12 +468,12 @@
 		bool isQuad() const;
 		bool isCond() const;
 		bool isCmp() const;
-		bool isCall() const;
-        bool isStore() const;
-        bool isLoad() const;
-		bool isGuard() const;
+		bool isCall() const { return nanojit::isCall(u.code); }
+        bool isStore() const { return nanojit::isStore(u.code); }
+        bool isLoad() const { return nanojit::isLoad(u.code); }
+		bool isGuard() const { return nanojit::isGuard(u.code); }
 		// True if the instruction is a 32-bit or smaller constant integer.
-		bool isconst() const;
+		bool isconst() const { return nanojit::isConst(u.code); }
 		// True if the instruction is a 32-bit or smaller constant integer and
 		// has the value val when treated as a 32-bit signed integer.
 		bool isconstval(int32_t val) const;
@@ -391,10 +484,13 @@
         bool isTramp() {
             return isop(LIR_neartramp) || isop(LIR_tramp);
         }
-
+		bool isBranch() const {
+			return isop(LIR_jt) || isop(LIR_jf) || isop(LIR_j);
+		}
 		// Set the imm16 member.  Should only be used on instructions that use
 		// that.  If you're not sure, you shouldn't be calling it.
 		void setimm16(int32_t i);
+		void setimm24(int32_t x);
 		// Set the resv member.  Should only be used on instructions that use
 		// that.  If you're not sure, you shouldn't be calling it.
 		void setresv(uint32_t resv);
@@ -405,8 +501,11 @@
 		void setOprnd2(LIns*);
 		void setOprnd3(LIns*);
         void setDisp(int8_t d);
+		void target(LIns* t);
+        LIns **targetAddr();
+		LIns* getTarget();
 
-        SideExit *exit();
+        GuardRecord *record();
 
 		inline uint32_t argc() const {
 			NanoAssert(isCall());
@@ -424,19 +523,21 @@
 	bool FASTCALL isCse(LOpcode v);
 	bool FASTCALL isCmp(LOpcode v);
 	bool FASTCALL isCond(LOpcode v);
+    inline bool isRet(LOpcode c) {
+        return (c & ~LIR64) == LIR_ret;
+    }
+    bool FASTCALL isFloat(LOpcode v);
 	LIns* FASTCALL callArgN(LInsp i, uint32_t n);
 	extern const uint8_t operandCount[];
 
 	class Fragmento;	// @todo remove this ; needed for minbuild for some reason?!?  Should not be compiling this code at all
 	class LirFilter;
-	struct CallInfo;
 
 	// make it a GCObject so we can explicitly delete it early
 	class LirWriter : public GCObject
 	{
 	public:
 		LirWriter *out;
-	public:
         const CallInfo *_functions;
 
 		virtual ~LirWriter() {}
@@ -452,11 +553,16 @@
 		virtual LInsp ins2(LOpcode v, LIns* a, LIns* b) {
 			return out->ins2(v, a, b);
 		}
-		virtual LInsp insGuard(LOpcode v, LIns *c, SideExit *x) {
+		virtual LInsp insGuard(LOpcode v, LIns *c, LIns *x) {
 			return out->insGuard(v, c, x);
 		}
-		virtual LInsp insParam(int32_t i) {
-			return out->insParam(i);
+		virtual LInsp insBranch(LOpcode v, LInsp condition, LInsp to) {
+			return out->insBranch(v, condition, to);
+		}
+        // arg: 0=first, 1=second, ...
+        // kind: 0=arg 1=saved-reg
+		virtual LInsp insParam(int32_t arg, int32_t kind) {
+			return out->insParam(arg, kind);
 		}
 		virtual LInsp insImm(int32_t imm) {
 			return out->insImm(imm);
@@ -477,10 +583,14 @@
 		virtual LInsp insCall(const CallInfo *call, LInsp args[]) {
 			return out->insCall(call, args);
 		}
+		virtual LInsp insAlloc(int32_t size) {
+			return out->insAlloc(size);
+		}
 
 		// convenience
 	    LIns*		insLoadi(LIns *base, int disp);
 	    LIns*		insLoad(LOpcode op, LIns *base, int disp);
+	    LIns*		store(LIns* value, LIns* base, int32_t d);
 		// Inserts a conditional to execute and branches to execute if
 		// the condition is true and false respectively.
 	    LIns*		ins_choose(LIns* cond, LIns* iftrue, LIns* iffalse);
@@ -491,6 +601,7 @@
         LIns*       ins2i(LOpcode op, LIns *oprnd1, int32_t);
 		LIns*		qjoin(LInsp lo, LInsp hi);
 		LIns*		insImmPtr(const void *ptr);
+		LIns*		insImmf(double f);
 	};
 
 #ifdef NJ_VERBOSE
@@ -516,8 +627,8 @@
 		char buf[1000], *end;
         void formatAddr(const void *p, char *buf);
     public:
-		AvmCore *core;
-        LabelMap(AvmCore *, LabelMap* parent);
+        avmplus::AvmCore *core;
+        LabelMap(avmplus::AvmCore *, LabelMap* parent);
         ~LabelMap();
         void add(const void *p, size_t size, size_t align, const char *name);
 		void add(const void *p, size_t size, size_t align, avmplus::String*);
@@ -579,50 +690,63 @@
 	class VerboseWriter : public LirWriter
 	{
 		avmplus::List<LInsp, avmplus::LIST_NonGCObjects> code;
-		LirNameMap *names;
+		DWB(LirNameMap*) names;
     public:
 		VerboseWriter(GC *gc, LirWriter *out, LirNameMap* names) 
 			: LirWriter(out), code(gc), names(names) 
 		{}
 
 		LInsp add(LInsp i) {
-			code.add(i);
+			if (i)
+				code.add(i);
 			return i;
 		}
 
+        LInsp add_flush(LInsp i) {
+            if ((i = add(i)) != 0) 
+                flush();
+            return i;
+        }
+
 		void flush()
 		{
-			for (int j=0, n=code.size(); j < n; j++)
-				printf("    %s\n",names->formatIns(code[j]));
-			code.clear();
-			printf("\n");
+            int n = code.size();
+            if (n) {
+			    for (int i=0; i < n; i++)
+				    printf("    %s\n",names->formatIns(code[i]));
+			    code.clear();
+                if (n > 1)
+        			printf("\n");
+            }
 		}
 
-		LIns* insGuard(LOpcode op, LInsp cond, SideExit *x) {
-			LInsp i = add(out->insGuard(op,cond,x));
-			if (i)
-				flush();
-			return i;
+		LIns* insGuard(LOpcode op, LInsp cond, LIns *x) {
+			return add_flush(out->insGuard(op,cond,x));
 		}
 
+		LIns* insBranch(LOpcode v, LInsp condition, LInsp to) {
+			return add_flush(out->insBranch(v, condition, to));
+		}
+
+
 		LIns* ins0(LOpcode v) {
-			LInsp i = add(out->ins0(v));
-			if (i)
-				flush();
-			return i;
+            if (v == LIR_label || v == LIR_start) {
+                flush();
+            }
+			return add(out->ins0(v));
 		}
 
 		LIns* ins1(LOpcode v, LInsp a) {
-			return add(out->ins1(v, a));
+			return isRet(v) ? add_flush(out->ins1(v, a)) : add(out->ins1(v, a));
 		}
 		LIns* ins2(LOpcode v, LInsp a, LInsp b) {
 			return v == LIR_2 ? out->ins2(v,a,b) : add(out->ins2(v, a, b));
 		}
 		LIns* insCall(const CallInfo *call, LInsp args[]) {
-			return add(out->insCall(call, args));
+			return add_flush(out->insCall(call, args));
 		}
-		LIns* insParam(int32_t i) {
-			return add(out->insParam(i));
+		LIns* insParam(int32_t i, int32_t kind) {
+			return add(out->insParam(i, kind));
 		}
 		LIns* insLoad(LOpcode v, LInsp base, LInsp disp) {
 			return add(out->insLoad(v, base, disp));
@@ -633,6 +757,9 @@
 		LIns* insStorei(LInsp v, LInsp b, int32_t d) {
 			return add(out->insStorei(v, b, d));
 		}
+        LIns* insAlloc(int32_t size) {
+            return add(out->insAlloc(size));
+        }
     };
 
 #endif
@@ -643,7 +770,8 @@
 		ExprFilter(LirWriter *out) : LirWriter(out) {}
 		LIns* ins1(LOpcode v, LIns* a);
 	    LIns* ins2(LOpcode v, LIns* a, LIns* b);
-		LIns* insGuard(LOpcode v, LIns *c, SideExit *x);
+		LIns* insGuard(LOpcode, LIns *cond, LIns *);
+        LIns* insBranch(LOpcode, LIns *cond, LIns *target);
 	};
 
 	// @todo, this could be replaced by a generic HashMap or HashSet, if we had one
@@ -652,14 +780,14 @@
 		// must be a power of 2. 
 		// don't start too small, or we'll waste time growing and rehashing.
 		// don't start too large, will waste memory. 
-		static const uint32_t kInitialCap = 2048;	
+		static const uint32_t kInitialCap = 64;	
 
-		InsList m_list;
-		uint32_t m_used;
+		LInsp *m_list; // explicit WB's are used, no DWB needed.
+		uint32_t m_used, m_cap;
 		GC* m_gc;
 
 		static uint32_t FASTCALL hashcode(LInsp i);
-		uint32_t FASTCALL find(LInsp name, uint32_t hash, const InsList& list, uint32_t cap);
+		uint32_t FASTCALL find(LInsp name, uint32_t hash, const LInsp *list, uint32_t cap);
 		static bool FASTCALL equals(LInsp a, LInsp b);
 		void FASTCALL grow();
 
@@ -673,6 +801,7 @@
 		LInsp findcall(const CallInfo *call, uint32_t argc, LInsp args[], uint32_t &i);
 		LInsp add(LInsp i, uint32_t k);
 		void replace(LInsp i);
+        void clear();
 
 		static uint32_t FASTCALL hashimm(int32_t);
 		static uint32_t FASTCALL hashimmq(uint64_t);
@@ -692,10 +821,9 @@
 		LIns* ins2(LOpcode v, LInsp, LInsp);
 		LIns* insLoad(LOpcode v, LInsp b, LInsp d);
 		LIns* insCall(const CallInfo *call, LInsp args[]);
-		LIns* insGuard(LOpcode op, LInsp cond, SideExit *x);
+		LIns* insGuard(LOpcode op, LInsp cond, LIns *x);
 	};
 
-	struct Page;
 	class LirBuffer : public GCFinalizedObject
 	{
 		public:
@@ -704,13 +832,13 @@
 			virtual ~LirBuffer();
 			void        clear();
 			LInsp		next();
-			LInsp		commit(uint32_t count);
-			bool		addPage();
 			bool		outOmem() { return _noMem != 0; }
-			debug_only (void		validate() const;)
+			
+			debug_only (void validate() const;)
 			verbose_only(DWB(LirNameMap*) names;)
-			verbose_only(int insCount();)
-			verbose_only(int byteCount();)
+			
+			int32_t insCount();
+			int32_t byteCount();
 
 			// stats
 			struct 
@@ -721,14 +849,21 @@
 			_stats;
 
 			const CallInfo* _functions;
+            AbiKind abi;
             LInsp state,param1,sp,rp;
+            LInsp savedParams[NumSavedRegs];
+            bool explicitSavedParams;
 			
-		private:
+		protected:
+			friend class LirBufWriter;
+
+			LInsp		commit(uint32_t count);
+			bool		addPage();
 			Page*		pageAlloc();
 
-			Page*				_start;		// first page
-			LInsp				_unused;	// next unused instruction slot
-			int					_noMem;		// set if ran out of memory when writing to buffer
+			Page*		_start;		// first page
+			LInsp		_unused;	// next unused instruction slot
+			int			_noMem;		// set if ran out of memory when writing to buffer
 	};	
 
 	class LirBufWriter : public LirWriter
@@ -749,17 +884,24 @@
 			LInsp	ins0(LOpcode op);
 			LInsp	ins1(LOpcode op, LInsp o1);
 			LInsp	ins2(LOpcode op, LInsp o1, LInsp o2);
-			LInsp	insParam(int32_t i);
+			LInsp	insParam(int32_t i, int32_t kind);
 			LInsp	insImm(int32_t imm);
 			LInsp	insImmq(uint64_t imm);
 		    LInsp	insCall(const CallInfo *call, LInsp args[]);
-			LInsp	insGuard(LOpcode op, LInsp cond, SideExit *x);
+			LInsp	insGuard(LOpcode op, LInsp cond, LIns *x);
+			LInsp	insBranch(LOpcode v, LInsp condition, LInsp to);
+			LInsp   insAlloc(int32_t size);
 
 			// buffer mgmt
 			LInsp	skip(size_t);
+
+		protected:
 			LInsp	insFar(LOpcode op, LInsp target);
+			LInsp	insLink(LOpcode op, LInsp target);
 			LInsp	ensureReferenceable(LInsp i, int32_t addedDistance);
 			bool	ensureRoom(uint32_t count);
+			bool	can8bReach(LInsp from, LInsp to) { return isU8(from-to-1); }
+			bool	can24bReach(LInsp from, LInsp to){ return isS24(from-to); }
 			bool	canReference(LInsp from, LInsp to) {
 				return isU8(from-to-1);
 			}
@@ -795,24 +937,26 @@
 		LInsp pos() {
 			return _i;
 		}
+        void setpos(LIns *i) {
+            _i = i;
+        }
 	};
 
     class Assembler;
 
     void compile(Assembler *assm, Fragment *frag);
-    verbose_only( void printTracker(const char* s, avmplus::RegionTracker& trk, Assembler* assm); )
-	verbose_only(void live(GC *gc, Assembler *assm, Fragment *frag);)
+	verbose_only(void live(GC *gc, LirBuffer *lirbuf);)
 
 	class StackFilter: public LirFilter
 	{
 		GC *gc;
-		Fragment *frag;
+		LirBuffer *lirbuf;
 		LInsp sp;
 		avmplus::BitSet stk;
         int top;
-		int getTop(LInsp guard);
+		int getTop(LInsp br);
 	public:
-		StackFilter(LirFilter *in, GC *gc, Fragment *frag, LInsp sp); 
+		StackFilter(LirFilter *in, GC *gc, LirBuffer *lirbuf, LInsp sp); 
 		virtual ~StackFilter() {}
 		LInsp read();
 	};
@@ -825,5 +969,23 @@
 		CseReader(LirFilter *in, LInsHashSet *exprs, const CallInfo*);
 		LInsp read();
 	};
+
+    // eliminate redundant loads by watching for stores & mutator calls
+    class LoadFilter: public LirWriter
+    {
+    public:
+        LInsp sp, rp;
+        LInsHashSet exprs;
+        void clear(LInsp p);
+    public:
+        LoadFilter(LirWriter *out, GC *gc)
+            : LirWriter(out), exprs(gc) { }
+
+        LInsp ins0(LOpcode);
+        LInsp insLoad(LOpcode, LInsp base, LInsp disp);
+        LInsp insStore(LInsp v, LInsp b, LInsp d);
+        LInsp insStorei(LInsp v, LInsp b, int32_t d);
+        LInsp insCall(const CallInfo *call, LInsp args[]);
+    };
 }
 #endif // __nanojit_LIR__
diff -r 17e9560465b0 js/src/nanojit/NativeAMD64.h
--- a/js/src/nanojit/NativeAMD64.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/nanojit/NativeAMD64.h	Thu Oct 30 05:41:45 2008 -0400
@@ -109,6 +109,7 @@
 	typedef int RegisterMask;
 
 	/* RBX, R13-R15 */
+	static const int NumSavedRegs = 3;
 	static const RegisterMask SavedRegs = /*(1<<RBX) |*/ /*(1<<R12) |*/ (1<<R13) | (1<<R14) | (1<<R15);
 	/* RAX, RCX, RDX, RDI, RSI, R8-R11 */
 	static const RegisterMask TempRegs = (1<<RAX) | (1<<RCX) | (1<<RDX) | (1<<R8) | (1<<R9) | (1<<R10) | (1<<R11) | (1<<RDI) | (1<<RSI);
diff -r 17e9560465b0 js/src/nanojit/NativeARM.cpp
--- a/js/src/nanojit/NativeARM.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/nanojit/NativeARM.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -64,16 +64,15 @@
 
 const Register Assembler::argRegs[] = { R0, R1, R2, R3 };
 const Register Assembler::retRegs[] = { R0, R1 };
+const Register Assembler::savedRegs[] = { R4, R5, R6, R7, R8, R9, R10 };
 
 void
 Assembler::nInit(AvmCore*)
 {
-    // all ARMs have conditional move
-    avmplus::AvmCore::cmov_available = true;
 }
 
 NIns*
-Assembler::genPrologue(RegisterMask needSaving)
+Assembler::genPrologue()
 {
     /**
      * Prologue
@@ -81,36 +80,39 @@
 
     // NJ_RESV_OFFSET is space at the top of the stack for us
     // to use for parameter passing (8 bytes at the moment)
-    uint32_t stackNeeded = 4 * _activation.highwatermark + NJ_STACK_OFFSET;
-    uint32_t savingCount = 0;
+    uint32_t stackNeeded = STACK_GRANULARITY * _activation.highwatermark + NJ_STACK_OFFSET;
 
-    uint32_t savingMask = 0;
-    savingCount = 9; //R4-R10,R11,LR
-    savingMask = SavedRegs | rmask(FRAME_PTR);
-    (void)needSaving;
+    uint32_t savingMask = rmask(FP) | rmask(LR);
+    uint32_t savingCount = 2;
 
-    // so for alignment purposes we've pushed  return addr, fp, and savingCount registers
-    uint32_t stackPushed = 4 * (2+savingCount);
+    if (!_thisfrag->lirbuf->explicitSavedParams) {
+        for (int i = 0; i < NumSavedRegs; ++i)
+            savingMask |= rmask(savedRegs[i]);
+        savingCount += NumSavedRegs;
+    }
+
+    // so for alignment purposes we've pushed return addr and fp
+    uint32_t stackPushed = STACK_GRANULARITY * savingCount;
     uint32_t aligned = alignUp(stackNeeded + stackPushed, NJ_ALIGN_STACK);
     int32_t amt = aligned - stackPushed;
 
     // Make room on stack for what we are doing
     if (amt)
-        SUBi(SP, amt); 
+        SUBi(SP, amt);
 
     verbose_only( verbose_outputf("         %p:",_nIns); )
     verbose_only( verbose_output("         patch entry"); )
     NIns *patchEntry = _nIns;
 
-    MR(FRAME_PTR, SP);
-    PUSH_mask(savingMask|rmask(LR));
+    MR(FP, SP);
+    PUSH_mask(savingMask);
     return patchEntry;
 }
 
 void
 Assembler::nFragExit(LInsp guard)
 {
-    SideExit* exit = guard->exit();
+    SideExit* exit = guard->record()->exit;
     Fragment *frag = exit->target;
     GuardRecord *lr;
 
@@ -119,18 +121,18 @@
         lr = 0;
     } else {
         // target doesn't exit yet.  emit jump to epilog, and set up to patch later.
-        lr = placeGuardRecord(guard);
+        lr = guard->record();
 
         // we need to know that there's an extra immediate value available
         // for us; always force a far jump here.
-        BL_far(_epilogue);
+        JMP_far(_epilogue);
 
         // stick the jmp pointer to the start of the sequence
         lr->jmp = _nIns;
     }
 
     // pop the stack frame first
-    MR(SP, FRAME_PTR);
+    MR(SP, FP);
 
 #ifdef NJ_VERBOSE
     if (_frago->core()->config.show_stats) {
@@ -141,20 +143,32 @@
     }
 #endif
 
-    // return value is GuardRecord*
+    // return value is GuardRecord*; note that this goes into
+    // R2, not R0 -- genEpilogue will move it into R0.  Otherwise
+    // we want R0 to have the original value that it had at the
+    // start of trace.
     LDi(R2, int(lr));
 }
 
 NIns*
-Assembler::genEpilogue(RegisterMask restore)
+Assembler::genEpilogue()
 {
     BX(LR); // return
+
+    RegisterMask savingMask = rmask(FP) | rmask(LR);
+
+    if (!_thisfrag->lirbuf->explicitSavedParams)
+        for (int i = 0; i < NumSavedRegs; ++i)
+            savingMask |= rmask(savedRegs[i]);
+
+    POP_mask(savingMask); // regs
+
+    // this is needed if we jump here from nFragExit
     MR(R0,R2); // return LinkRecord*
-    RegisterMask savingMask = restore | rmask(FRAME_PTR) | rmask(LR);
-    POP_mask(savingMask); // regs
+
     return _nIns;
 }
-    
+
 void
 Assembler::asm_call(LInsp ins)
 {
@@ -208,7 +222,7 @@
     }
 #endif
 
-    CALL(call);
+    BL((NIns*)(call->_address));
 
     ArgSize sizes[10];
     uint32_t argc = call->get_sizes(sizes);
@@ -252,7 +266,7 @@
             roffset = 1;
     }
 }
-    
+
 void
 Assembler::nMarkExecute(Page* page, int32_t count, bool enable)
 {
@@ -267,7 +281,7 @@
     (void)count;
     (void)enable;
 }
-            
+
 Register
 Assembler::nRegisterAllocFromSet(int set)
 {
@@ -300,7 +314,14 @@
     // add scratch registers to our free list for the allocator
     a.clear();
     a.used = 0;
-    a.free = rmask(R0) | rmask(R1) | rmask(R2) | rmask(R3) | rmask(R4) | rmask(R5) | FpRegs;
+    a.free =
+        rmask(R0) | rmask(R1) | rmask(R2) | rmask(R3) | rmask(R4) |
+        rmask(R5) | rmask(R6) | rmask(R7) | rmask(R8) | rmask(R9) |
+        rmask(R10);
+#ifdef NJ_ARM_VFP
+    a.free |= FpRegs;
+#endif
+
     debug_only(a.managed = a.free);
 }
 
@@ -354,7 +375,7 @@
     AvmAssert(d);
     LIns* lo = ins->oprnd1();
     LIns* hi = ins->oprnd2();
-                            
+
     Register r = findRegFor(hi, GpRegs);
     STR(r, FP, d+4);
 
@@ -399,15 +420,11 @@
 }
 
 void
-Assembler::asm_spill(LInsp i, Reservation *resv, bool pop)
+Assembler::asm_spill(Register rr, int d, bool pop, bool quad)
 {
-    (void)i;
-    (void)pop;
-    //fprintf (stderr, "resv->arIndex: %d\n", resv->arIndex);
-    if (resv->arIndex) {
-        int d = disp(resv);
-        // save to spill location
-        Register rr = resv->reg;
+    (void) pop;
+    (void) quad;
+    if (d) {
         if (IsFpReg(rr)) {
             if (isS8(d >> 2)) {
                 FSTD(rr, FP, d);
@@ -418,11 +435,6 @@
         } else {
             STR(rr, FP, d);
         }
-
-        verbose_only(if (_verbose){
-                outputf("        spill %s",_thisfrag->lirbuf->names->formatRef(i));
-            }
-        )
     }
 }
 
@@ -599,13 +611,6 @@
     //asm_output("<<< asm_quad");
 }
 
-bool
-Assembler::asm_qlo(LInsp ins, LInsp q)
-{
-    (void)ins; (void)q;
-    return false;
-}
-
 void
 Assembler::asm_nongp_copy(Register r, Register s)
 {
@@ -623,7 +628,7 @@
 }
 
 Register
-Assembler::asm_binop_rhs_reg(LInsp ins)
+Assembler::asm_binop_rhs_reg(LInsp)
 {
     return UnknownReg;
 }
@@ -696,7 +701,7 @@
     if (!_nIns)      _nIns     = pageAlloc();
     if (!_nExitIns)  _nExitIns = pageAlloc(true);
     //fprintf(stderr, "assemble onto %x exits into %x\n", (int)_nIns, (int)_nExitIns);
-    
+
     if (!_nSlot)
     {
         // This needs to be done or the samepage macro gets confused; pageAlloc
@@ -713,27 +718,27 @@
 NIns*
 Assembler::asm_adjustBranch(NIns* at, NIns* target)
 {
-    // This always got emitted as a BL_far sequence; at points
-    // to the first of 4 instructions.  Ensure that we're where
+    // This always got emitted as a JMP_far sequence; at points
+    // to the first of 3 instructions.  Ensure that we're where
     // we think we were..
-    NanoAssert(at[1] == (NIns)( COND_AL | OP_IMM | (1<<23) | (PC<<16) | (LR<<12) | (4) ));
-    NanoAssert(at[2] == (NIns)( COND_AL | (0x9<<21) | (0xFFF<<8) | (1<<4) | (IP) ));
+    NanoAssert(at[0] == (NIns)( COND_AL | (0x59<<20) | (PC<<16) | (IP<<12) | (0) ));
+    NanoAssert(at[1] == (NIns)( COND_AL | (0x9<<21) | (0xFFF<<8) | (1<<4) | (IP) ));
 
-    NIns* was = (NIns*) at[3];
+    NIns* was = (NIns*) at[2];
 
     //fprintf (stderr, "Adjusting branch @ 0x%8x: 0x%x -> 0x%x\n", at+3, at[3], target);
 
-    at[3] = (NIns)target;
+    at[2] = (NIns)target;
 
 #if defined(UNDER_CE)
     // we changed the code, so we need to do this (sadly)
     FlushInstructionCache(GetCurrentProcess(), NULL, NULL);
 #elif defined(AVMPLUS_LINUX)
-    __clear_cache((char*)at, (char*)(at+4));
+    __clear_cache((char*)at, (char*)(at+3));
 #endif
 
 #ifdef AVMPLUS_PORTING_API
-    NanoJIT_PortAPI_FlushInstructionCache(at, at+4);
+    NanoJIT_PortAPI_FlushInstructionCache(at, at+3);
 #endif
 
     return was;
@@ -764,7 +769,7 @@
         _nSlot = pageDataStart(_nIns);
 
         // If samepage() is used on _nIns and _nSlot, it'll fail, since _nIns
-        // points to one past the end of the page right now.  Assume that 
+        // points to one past the end of the page right now.  Assume that
         // JMP_nochk won't ever try to write to _nSlot, and so won't ever
         // check samepage().  See B_cond_chk macro.
         JMP_nochk(target);
@@ -772,6 +777,27 @@
         // make sure that there's always a slot pointer
         _nSlot = pageDataStart(_nIns);
     }
+}
+
+void
+Assembler::JMP_far(NIns* addr)
+{
+    // we have to stick an immediate into the stream
+    underrunProtect(12);
+
+    // TODO use a slot in const pool for address, but emit single insn
+    // for branch if offset fits
+
+    // the address
+    *(--_nIns) = (NIns)((addr));
+    // bx ip             // branch to the address we loaded earlier
+    *(--_nIns) = (NIns)( COND_AL | (0x9<<21) | (0xFFF<<8) | (1<<4) | (IP) );
+    // ldr ip, [pc + #0] // load the address into ip, reading it from [pc]
+    *(--_nIns) = (NIns)( COND_AL | (0x59<<20) | (PC<<16) | (IP<<12) | (0));
+
+    //fprintf (stderr, "JMP_far sequence @ 0x%08x\n", _nIns);
+
+    asm_output1("b %p (32-bit)", addr);
 }
 
 void
@@ -822,15 +848,6 @@
 }
 
 void
-Assembler::CALL(const CallInfo *ci)
-{
-    intptr_t addr = ci->_address;
-
-    BL((NIns*)addr);
-    asm_output1("   (call %s)", ci->_name);
-}
-
-void
 Assembler::LD32_nochk(Register r, int32_t imm)
 {
     if (imm == 0) {
@@ -871,7 +888,7 @@
 void
 Assembler::B_cond_chk(ConditionCode _c, NIns* _t, bool _chk)
 {
-    int32 offs = PC_OFFSET_FROM(_t,_nIns-1);
+    int32_t offs = PC_OFFSET_FROM(_t,_nIns-1);
     //fprintf(stderr, "B_cond_chk target: 0x%08x offset: %d @0x%08x\n", _t, offs, _nIns-1);
     if (isS24(offs)) {
         if (_chk) underrunProtect(4);
@@ -946,8 +963,6 @@
 /*
  * VFP
  */
-
-#ifdef NJ_ARM_VFP
 
 void
 Assembler::asm_i2f(LInsp ins)
@@ -1052,7 +1067,7 @@
     // ends up having overlaps with a few other tests.  So, test for
     // the explicit mask.
     uint8_t mask = 0x0;
-    
+
     // NZCV
     // for a valid ordered result, V is always 0 from VFP
     if (op == LIR_feq)
@@ -1080,7 +1095,7 @@
     // would reset the status bits if V (NaN flag) is set, but that
     // doesn't work for NE.  For NE could teqvs rX, #1.  rX needs to
     // be any register that has lsb == 0, such as sp/fp/pc.
-    
+
     // Test explicily with the full mask; if V is set, test will fail.
     // Assumption is that this will be followed up by a BEQ/BNE
     CMPi(Scratch, mask);
@@ -1094,13 +1109,538 @@
 }
 
 Register
-Assembler::asm_prep_fcall(Reservation* rR, LInsp ins)
+Assembler::asm_prep_fcall(Reservation*, LInsp)
 {
     // We have nothing to do here; we do it all in asm_call.
     return UnknownReg;
 }
 
-#endif /* NJ_ARM_VFP */
+NIns*
+Assembler::asm_branch(bool branchOnFalse, LInsp cond, NIns* targ)
+{
+    NIns* at = 0;
+    LOpcode condop = cond->opcode();
+    NanoAssert(cond->isCond());
+
+    if (condop >= LIR_feq && condop <= LIR_fge)
+    {
+        if (branchOnFalse)
+            JNE(targ);
+        else
+            JE(targ);
+
+        NIns *at = _nIns;
+        asm_fcmp(cond);
+        return at;
+    }
+
+    // produce the branch
+    if (branchOnFalse) {
+        if (condop == LIR_eq)
+            JNE(targ);
+        else if (condop == LIR_ov)
+            JNO(targ);
+        else if (condop == LIR_cs)
+            JNC(targ);
+        else if (condop == LIR_lt)
+            JNL(targ);
+        else if (condop == LIR_le)
+            JNLE(targ);
+        else if (condop == LIR_gt)
+            JNG(targ);
+        else if (condop == LIR_ge)
+            JNGE(targ);
+        else if (condop == LIR_ult)
+            JNB(targ);
+        else if (condop == LIR_ule)
+            JNBE(targ);
+        else if (condop == LIR_ugt)
+            JNA(targ);
+        else //if (condop == LIR_uge)
+            JNAE(targ);
+    } else // op == LIR_xt
+    {
+        if (condop == LIR_eq)
+            JE(targ);
+        else if (condop == LIR_ov)
+            JO(targ);
+        else if (condop == LIR_cs)
+            JC(targ);
+        else if (condop == LIR_lt)
+            JL(targ);
+        else if (condop == LIR_le)
+            JLE(targ);
+        else if (condop == LIR_gt)
+            JG(targ);
+        else if (condop == LIR_ge)
+            JGE(targ);
+        else if (condop == LIR_ult)
+            JB(targ);
+        else if (condop == LIR_ule)
+            JBE(targ);
+        else if (condop == LIR_ugt)
+            JA(targ);
+        else //if (condop == LIR_uge)
+            JAE(targ);
+    }
+    at = _nIns;
+    asm_cmp(cond);
+    return at;
+}
+
+void
+Assembler::asm_cmp(LIns *cond)
+{
+    LOpcode condop = cond->opcode();
+
+    // LIR_ov and LIR_cs recycle the flags set by arithmetic ops
+    if ((condop == LIR_ov) || (condop == LIR_cs))
+        return;
+
+    LInsp lhs = cond->oprnd1();
+    LInsp rhs = cond->oprnd2();
+    Reservation *rA, *rB;
+
+    // Not supported yet.
+    NanoAssert(!lhs->isQuad() && !rhs->isQuad());
+
+    // ready to issue the compare
+    if (rhs->isconst()) {
+        int c = rhs->constval();
+        if (c == 0 && cond->isop(LIR_eq)) {
+            Register r = findRegFor(lhs, GpRegs);
+            TEST(r,r);
+			// No 64-bit immediates so fall-back to below
+        }
+        else if (!rhs->isQuad()) {
+            Register r = getBaseReg(lhs, c, GpRegs);
+            CMPi(r, c);
+        }
+    } else {
+        findRegFor2(GpRegs, lhs, rA, rhs, rB);
+        Register ra = rA->reg;
+        Register rb = rB->reg;
+        CMP(ra, rb);
+    }
+}
+
+void
+Assembler::asm_loop(LInsp ins, NInsList& loopJumps)
+{
+    (void)ins;
+    JMP_long_placeholder(); // jump to SOT	
+    verbose_only( if (_verbose && _outputCache) { _outputCache->removeLast(); outputf("         jmp   SOT"); } );
+		
+    loopJumps.add(_nIns);
+
+#ifdef NJ_VERBOSE
+    // branching from this frag to ourself.
+    if (_frago->core()->config.show_stats)
+        LDi(argRegs[1], int((Fragment*)_thisfrag));
+#endif
+
+    assignSavedParams();
+
+    // restore first parameter, the only one we use
+    LInsp state = _thisfrag->lirbuf->state;
+    findSpecificRegFor(state, argRegs[state->imm8()]);
+}
+
+void
+Assembler::asm_fcond(LInsp ins)
+{
+    // only want certain regs
+    Register r = prepResultReg(ins, AllowableFlagRegs);
+
+    SETE(r);
+    asm_fcmp(ins);
+}
+				
+void
+Assembler::asm_cond(LInsp ins)
+{
+    // only want certain regs
+    LOpcode op = ins->opcode();			
+    Register r = prepResultReg(ins, AllowableFlagRegs);
+    // SETcc only sets low 8 bits, so extend
+    MOVZX8(r,r);
+    if (op == LIR_eq)
+        SETE(r);
+    else if (op == LIR_ov)
+        SETO(r);
+    else if (op == LIR_cs)
+        SETC(r);
+    else if (op == LIR_lt)
+        SETL(r);
+    else if (op == LIR_le)
+        SETLE(r);
+    else if (op == LIR_gt)
+        SETG(r);
+    else if (op == LIR_ge)
+        SETGE(r);
+    else if (op == LIR_ult)
+        SETB(r);
+    else if (op == LIR_ule)
+        SETBE(r);
+    else if (op == LIR_ugt)
+        SETA(r);
+    else // if (op == LIR_uge)
+        SETAE(r);
+    asm_cmp(ins);
+}
+	
+void
+Assembler::asm_arith(LInsp ins)
+{
+    LOpcode op = ins->opcode();			
+    LInsp lhs = ins->oprnd1();
+    LInsp rhs = ins->oprnd2();
+
+    Register rb = UnknownReg;
+    RegisterMask allow = GpRegs;
+    bool forceReg = (op == LIR_mul || !rhs->isconst());
+
+    // Arm can't do an immediate op with immediates
+    // outside of +/-255 (for AND) r outside of
+    // 0..255 for others.
+    if (!forceReg) {
+        if (rhs->isconst() && !isU8(rhs->constval()))
+            forceReg = true;
+    }
+
+    if (lhs != rhs && forceReg) {
+        if ((rb = asm_binop_rhs_reg(ins)) == UnknownReg) {
+            rb = findRegFor(rhs, allow);
+        }
+        allow &= ~rmask(rb);
+    } else if ((op == LIR_add||op == LIR_addp) && lhs->isop(LIR_alloc) && rhs->isconst()) {
+        // add alloc+const, use lea
+        Register rr = prepResultReg(ins, allow);
+        int d = findMemFor(lhs) + rhs->constval();
+        LEA(rr, d, FP);
+    }
+
+    Register rr = prepResultReg(ins, allow);
+    Reservation* rA = getresv(lhs);
+    Register ra;
+    // if this is last use of lhs in reg, we can re-use result reg
+    if (rA == 0 || (ra = rA->reg) == UnknownReg)
+        ra = findSpecificRegFor(lhs, rr);
+    // else, rA already has a register assigned.
+
+    if (forceReg) {
+        if (lhs == rhs)
+            rb = ra;
+
+        if (op == LIR_add || op == LIR_addp)
+            ADD(rr, rb);
+        else if (op == LIR_sub)
+            SUB(rr, rb);
+        else if (op == LIR_mul)
+            MUL(rr, rb);
+        else if (op == LIR_and)
+            AND(rr, rb);
+        else if (op == LIR_or)
+            OR(rr, rb);
+        else if (op == LIR_xor)
+            XOR(rr, rb);
+        else if (op == LIR_lsh)
+            SHL(rr, rb);
+        else if (op == LIR_rsh)
+            SAR(rr, rb);
+        else if (op == LIR_ush)
+            SHR(rr, rb);
+        else
+            NanoAssertMsg(0, "Unsupported");
+    } else {
+        int c = rhs->constval();
+        if (op == LIR_add || op == LIR_addp)
+            ADDi(rr, c);
+        else if (op == LIR_sub)
+					SUBi(rr, c);
+        else if (op == LIR_and)
+            ANDi(rr, c);
+        else if (op == LIR_or)
+            ORi(rr, c);
+        else if (op == LIR_xor)
+            XORi(rr, c);
+        else if (op == LIR_lsh)
+            SHLi(rr, c);
+        else if (op == LIR_rsh)
+            SARi(rr, c);
+        else if (op == LIR_ush)
+            SHRi(rr, c);
+        else
+            NanoAssertMsg(0, "Unsupported");
+    }
+
+    if (rr != ra)
+        MR(rr,ra);
+}
+	
+void
+Assembler::asm_neg_not(LInsp ins)
+{
+    LOpcode op = ins->opcode();			
+    Register rr = prepResultReg(ins, GpRegs);
+
+    LIns* lhs = ins->oprnd1();
+    Reservation *rA = getresv(lhs);
+    // if this is last use of lhs in reg, we can re-use result reg
+    Register ra;
+    if (rA == 0 || (ra=rA->reg) == UnknownReg)
+        ra = findSpecificRegFor(lhs, rr);
+    // else, rA already has a register assigned.
+
+    if (op == LIR_not)
+        NOT(rr);
+    else
+        NEG(rr);
+
+    if ( rr != ra )
+        MR(rr,ra);
+}
+				
+void
+Assembler::asm_ld(LInsp ins)
+{
+    LOpcode op = ins->opcode();			
+    LIns* base = ins->oprnd1();
+    LIns* disp = ins->oprnd2();
+    Register rr = prepResultReg(ins, GpRegs);
+    int d = disp->constval();
+    Register ra = getBaseReg(base, d, GpRegs);
+    if (op == LIR_ldcb)
+        LD8Z(rr, d, ra);
+    else
+        LD(rr, d, ra);
+}
+
+void
+Assembler::asm_cmov(LInsp ins)
+{
+    LOpcode op = ins->opcode();			
+    LIns* condval = ins->oprnd1();
+    NanoAssert(condval->isCmp());
+
+    LIns* values = ins->oprnd2();
+
+    NanoAssert(values->opcode() == LIR_2);
+    LIns* iftrue = values->oprnd1();
+    LIns* iffalse = values->oprnd2();
+
+    NanoAssert(op == LIR_qcmov || (!iftrue->isQuad() && !iffalse->isQuad()));
+		
+    const Register rr = prepResultReg(ins, GpRegs);
+
+    // this code assumes that neither LD nor MR nor MRcc set any of the condition flags.
+    // (This is true on Intel, is it true on all architectures?)
+    const Register iffalsereg = findRegFor(iffalse, GpRegs & ~rmask(rr));
+    if (op == LIR_cmov) {
+        switch (condval->opcode()) {
+            // note that these are all opposites...
+            case LIR_eq:	MRNE(rr, iffalsereg);	break;
+            case LIR_ov:    MRNO(rr, iffalsereg);   break;
+            case LIR_cs:    MRNC(rr, iffalsereg);   break;
+            case LIR_lt:	MRGE(rr, iffalsereg);	break;
+            case LIR_le:	MRG(rr, iffalsereg);	break;
+            case LIR_gt:	MRLE(rr, iffalsereg);	break;
+            case LIR_ge:	MRL(rr, iffalsereg);	break;
+            case LIR_ult:	MRAE(rr, iffalsereg);	break;
+            case LIR_ule:	MRA(rr, iffalsereg);	break;
+            case LIR_ugt:	MRBE(rr, iffalsereg);	break;
+            case LIR_uge:	MRB(rr, iffalsereg);	break;
+				debug_only( default: NanoAssert(0); break; )
+        }
+    } else if (op == LIR_qcmov) {
+        NanoAssert(0);
+    }
+    /*const Register iftruereg =*/ findSpecificRegFor(iftrue, rr);
+    asm_cmp(condval);
+}
+				
+void
+Assembler::asm_qhi(LInsp ins)
+{
+    Register rr = prepResultReg(ins, GpRegs);
+    LIns *q = ins->oprnd1();
+    int d = findMemFor(q);
+    LD(rr, d+4, FP);
+}
+
+void
+Assembler::asm_qlo(LInsp ins)
+{
+    Register rr = prepResultReg(ins, GpRegs);
+    LIns *q = ins->oprnd1();
+    int d = findMemFor(q);
+    LD(rr, d, FP);
+
+#if 0
+    LIns *q = ins->oprnd1();
+
+    Reservation *resv = getresv(ins);
+    Register rr = resv->reg;
+    if (rr == UnknownReg) {
+        // store quad in spill loc
+        int d = disp(resv);
+        freeRsrcOf(ins, false);
+        Register qr = findRegFor(q, XmmRegs);
+        SSE_MOVDm(d, FP, qr);
+    } else {
+        freeRsrcOf(ins, false);
+        Register qr = findRegFor(q, XmmRegs);
+        SSE_MOVD(rr,qr);
+    }
+#endif
+}
+
+
+void
+Assembler::asm_param(LInsp ins)
+{
+    uint32_t a = ins->imm8();
+    uint32_t kind = ins->imm8b();
+    if (kind == 0) {
+        // ordinary param
+        AbiKind abi = _thisfrag->lirbuf->abi;
+        uint32_t abi_regcount = abi == ABI_FASTCALL ? 2 : abi == ABI_THISCALL ? 1 : 0;
+        if (a < abi_regcount) {
+            // incoming arg in register
+            prepResultReg(ins, rmask(argRegs[a]));
+        } else {
+            // incoming arg is on stack, and EBP points nearby (see genPrologue)
+            Register r = prepResultReg(ins, GpRegs);
+            int d = (a - abi_regcount) * sizeof(intptr_t) + 8;
+            LD(r, d, FP);
+        }
+    } else {
+        // saved param
+        prepResultReg(ins, rmask(savedRegs[a]));
+    }
+}
+
+void
+Assembler::asm_short(LInsp ins)
+{
+    Register rr = prepResultReg(ins, GpRegs);
+    int32_t val = ins->imm16();
+    if (val == 0)
+        XOR(rr,rr);
+    else
+        LDi(rr, val);
+}
+
+void
+Assembler::asm_int(LInsp ins)
+{
+    Register rr = prepResultReg(ins, GpRegs);
+    int32_t val = ins->imm32();
+    if (val == 0)
+        XOR(rr,rr);
+    else
+        LDi(rr, val);
+}
+
+#if 0
+void
+Assembler::asm_quad(LInsp ins)
+{
+    Reservation *rR = getresv(ins);
+    Register rr = rR->reg;
+    if (rr != UnknownReg)
+    {
+        // @todo -- add special-cases for 0 and 1
+        _allocator.retire(rr);
+        rR->reg = UnknownReg;
+        NanoAssert((rmask(rr) & FpRegs) != 0);
+
+        const double d = ins->constvalf();
+        const uint64_t q = ins->constvalq();
+        if (rmask(rr) & XmmRegs) {
+            if (q == 0.0) {
+                // test (int64)0 since -0.0 == 0.0
+                SSE_XORPDr(rr, rr);
+				} else if (d == 1.0) {
+                // 1.0 is extremely frequent and worth special-casing!
+                static const double k_ONE = 1.0;
+                LDSDm(rr, &k_ONE);
+            } else {
+                findMemFor(ins);
+                const int d = disp(rR);
+                SSE_LDQ(rr, d, FP);
+            }
+        } else {
+            if (q == 0.0) {
+                // test (int64)0 since -0.0 == 0.0
+                FLDZ();
+            } else if (d == 1.0) {
+                FLD1();
+            } else {
+                findMemFor(ins);
+                int d = disp(rR);
+                FLDQ(d,FP);
+            }
+        }
+    }
+
+    // @todo, if we used xor, ldsd, fldz, etc above, we don't need mem here
+    int d = disp(rR);
+    freeRsrcOf(ins, false);
+    if (d) {
+        const int32_t* p = (const int32_t*) (ins-2);
+        STi(FP,d+4,p[1]);
+        STi(FP,d,p[0]);
+    }
+}
+#endif
+
+void
+Assembler::asm_arg(ArgSize sz, LInsp p, Register r)
+{
+    if (sz == ARGSIZE_Q) {
+        // ref arg - use lea
+        if (r != UnknownReg) {
+            // arg in specific reg
+            int da = findMemFor(p);
+            LEA(r, da, FP);
+        } else {
+            NanoAssert(0); // not supported
+        }
+    } else if (sz == ARGSIZE_LO) {
+        if (r != UnknownReg) {
+            // arg goes in specific register
+            if (p->isconst()) {
+                LDi(r, p->constval());
+            } else {
+                Reservation* rA = getresv(p);
+                if (rA) {
+                    if (rA->reg == UnknownReg) {
+                        // load it into the arg reg
+                        int d = findMemFor(p);
+                        if (p->isop(LIR_alloc)) {
+                            LEA(r, d, FP);
+                        } else {
+                            LD(r, d, FP);
+                        }
+                    } else {
+                        // it must be in a saved reg
+                        MR(r, rA->reg);
+                    }
+                } else {
+                    // this is the last use, so fine to assign it
+                    // to the scratch reg, it's dead after this point.
+                    findSpecificRegFor(p, r);
+                }
+            }
+        } else {
+            asm_pusharg(p);
+        }
+    } else {
+        NanoAssert(sz == ARGSIZE_F);
+        asm_farg(p);
+    }
+}
 
 }
 #endif /* FEATURE_NANOJIT */
diff -r 17e9560465b0 js/src/nanojit/NativeARM.h
--- a/js/src/nanojit/NativeARM.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/nanojit/NativeARM.h	Thu Oct 30 05:41:45 2008 -0400
@@ -41,6 +41,17 @@
 #ifndef __nanojit_NativeArm__
 #define __nanojit_NativeArm__
 
+
+#ifdef PERFM
+#include "../vprof/vprof.h"
+#define count_instr() _nvprof("arm",1)
+#define count_prolog() _nvprof("arm-prolog",1); count_instr();
+#define count_imt() _nvprof("arm-imt",1) count_instr()
+#else
+#define count_instr()
+#define count_prolog()
+#define count_imt()
+#endif
 
 namespace nanojit
 {
@@ -107,10 +118,6 @@
 
     FirstFloatReg = 16,
     LastFloatReg = 22,
-
-    // helpers
-    FRAME_PTR = 11,
-    ESP = SP,
         
     FirstReg = 0,
 #ifdef NJ_ARM_VFP
@@ -152,12 +159,12 @@
     NIns*           epilogue;
 } FragInfo;
 
-#ifdef ARM_VFP
-static const RegisterMask SavedFpRegs = 1<<D0 | 1<<D1 | 1<<D2 | 1<<D3 | 1<<D4 | 1<<D5 | 1<<D6 | 1<<D7;
-#else
+// D0-D6 are not saved; D7-D15 are, but we don't use those,
+// so we don't have to worry about saving/restoring them
 static const RegisterMask SavedFpRegs = 0;
-#endif
-static const RegisterMask SavedRegs = 1<<R4 | 1<<R5 | 1<<R6 | 1<<R7 | 1<<R8 | 1<<R9 | 1<<R10 | SavedFpRegs;
+static const RegisterMask SavedRegs = 1<<R4 | 1<<R5 | 1<<R6 | 1<<R7 | 1<<R8 | 1<<R9 | 1<<R10;
+static const int NumSavedRegs = 7;
+
 static const RegisterMask FpRegs = 1<<D0 | 1<<D1 | 1<<D2 | 1<<D3 | 1<<D4 | 1<<D5 | 1<<D6; // no D7; S14-S15 are used for i2f/u2f.
 static const RegisterMask GpRegs = 0x07FF;
 static const RegisterMask AllowableFlagRegs = 1<<R0 | 1<<R1 | 1<<R2 | 1<<R3 | 1<<R4 | 1<<R5 | 1<<R6 | 1<<R7 | 1<<R8 | 1<<R9 | 1<<R10;
@@ -192,7 +199,7 @@
     void LD32_nochk(Register r, int32_t imm);                           \
     void BL(NIns*);                                                     \
     void BL_far(NIns*);                                                 \
-    void CALL(const CallInfo*);                                         \
+    void JMP_far(NIns*);                                                \
     void B_cond_chk(ConditionCode, NIns*, bool);                        \
     void underrunProtect(int bytes);                                    \
     void nativePageReset();                                             \
@@ -216,8 +223,6 @@
 
 
 #define IMM32(imm)  *(--_nIns) = (NIns)((imm));
-
-#define FUNCADDR(addr) ( ((int)addr) )  
 
 #define OP_IMM  (1<<25)
 #define OP_STAT (1<<20)
@@ -506,8 +511,8 @@
         asm_output3("ldr %s, [%s, #%d]",gpn(_d),gpn(_b),(_off));        \
     } while(0)
 
-#define LDR(_d,_b,_off)        LDR_chk(_d,_b,_off,0)
-#define LDR_nochk(_d,_b,_off)  LDR_chk(_d,_b,_off,1)
+#define LDR(_d,_b,_off)        LDR_chk(_d,_b,_off,1)
+#define LDR_nochk(_d,_b,_off)  LDR_chk(_d,_b,_off,0)
 
 // i386 compat, for Assembler.cpp
 #define LD(reg,offset,base)    LDR_chk(reg,base,offset,1)
diff -r 17e9560465b0 js/src/nanojit/NativeThumb.cpp
--- a/js/src/nanojit/NativeThumb.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/nanojit/NativeThumb.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -60,6 +60,7 @@
 #endif
     const Register Assembler::argRegs[] = { R0, R1, R2, R3 };
     const Register Assembler::retRegs[] = { R0, R1 };
+	const Register Assembler::savedRegs[] = { R4, R5, R6, R7 };
 
 	void Assembler::nInit(AvmCore*)
 	{
@@ -269,7 +270,7 @@
 		else if (op == LIR_callh)
 			prefer = rmask(R1);
 		else if (op == LIR_param)
-			prefer = rmask(imm2register(i->imm8()));
+			prefer = rmask(imm2register(argRegs[i->imm8()]));
 
 		if (_allocator.free & allow & prefer)
 			allow &= prefer;
@@ -349,6 +350,7 @@
 	    asm_mmq(rb, dr, FP, da);
 	}
 
+
 	void Assembler::asm_quad(LInsp ins)
 	{
 		Reservation *rR = getresv(ins);
@@ -362,10 +364,477 @@
 		}
 	}
 
-	bool Assembler::asm_qlo(LInsp ins, LInsp q)
+	NIns* Assembler::asm_branch(bool branchOnFalse, LInsp cond, NIns* targ)
 	{
-		(void)ins; (void)q;
-		return false;
+		NIns* at = 0;
+		LOpcode condop = cond->opcode();
+		NanoAssert(cond->isCond());
+#ifndef NJ_SOFTFLOAT
+		if (condop >= LIR_feq && condop <= LIR_fge)
+		{
+			return asm_jmpcc(branchOnFalse, cond, targ);
+		}
+#endif
+		// produce the branch
+		if (branchOnFalse)
+		{
+			if (condop == LIR_eq)
+				JNE(targ);
+			else if (condop == LIR_ov)
+				JNO(targ);
+			else if (condop == LIR_cs)
+				JNC(targ);
+			else if (condop == LIR_lt)
+				JNL(targ);
+			else if (condop == LIR_le)
+				JNLE(targ);
+			else if (condop == LIR_gt)
+				JNG(targ);
+			else if (condop == LIR_ge)
+				JNGE(targ);
+			else if (condop == LIR_ult)
+				JNB(targ);
+			else if (condop == LIR_ule)
+				JNBE(targ);
+			else if (condop == LIR_ugt)
+				JNA(targ);
+			else //if (condop == LIR_uge)
+				JNAE(targ);
+		}
+		else // op == LIR_xt
+		{
+			if (condop == LIR_eq)
+				JE(targ);
+			else if (condop == LIR_ov)
+				JO(targ);
+			else if (condop == LIR_cs)
+				JC(targ);
+			else if (condop == LIR_lt)
+				JL(targ);
+			else if (condop == LIR_le)
+				JLE(targ);
+			else if (condop == LIR_gt)
+				JG(targ);
+			else if (condop == LIR_ge)
+				JGE(targ);
+			else if (condop == LIR_ult)
+				JB(targ);
+			else if (condop == LIR_ule)
+				JBE(targ);
+			else if (condop == LIR_ugt)
+				JA(targ);
+			else //if (condop == LIR_uge)
+				JAE(targ);
+		}
+		at = _nIns;
+		asm_cmp(cond);
+		return at;
+	}
+
+	void Assembler::asm_cmp(LIns *cond)
+	{
+        LOpcode condop = cond->opcode();
+        
+        // LIR_ov and LIR_cs recycle the flags set by arithmetic ops
+        if ((condop == LIR_ov) || (condop == LIR_cs))
+            return;
+        
+        LInsp lhs = cond->oprnd1();
+		LInsp rhs = cond->oprnd2();
+		Reservation *rA, *rB;
+
+		// Not supported yet.
+		NanoAssert(!lhs->isQuad() && !rhs->isQuad());
+
+		// ready to issue the compare
+		if (rhs->isconst())
+		{
+			int c = rhs->constval();
+			if (c == 0 && cond->isop(LIR_eq)) {
+				Register r = findRegFor(lhs, GpRegs);
+				TEST(r,r);
+			// No 64-bit immediates so fall-back to below
+			}
+			else if (!rhs->isQuad()) {
+				Register r = getBaseReg(lhs, c, GpRegs);
+				CMPi(r, c);
+			}
+		}
+		else
+		{
+			findRegFor2(GpRegs, lhs, rA, rhs, rB);
+			Register ra = rA->reg;
+			Register rb = rB->reg;
+			CMP(ra, rb);
+		}
+	}
+
+	void Assembler::asm_loop(LInsp ins, NInsList& loopJumps)
+	{
+		(void)ins;
+		JMP_long_placeholder(); // jump to SOT	
+		verbose_only( if (_verbose && _outputCache) { _outputCache->removeLast(); outputf("         jmp   SOT"); } );
+		
+		loopJumps.add(_nIns);
+
+		#ifdef NJ_VERBOSE
+		// branching from this frag to ourself.
+		if (_frago->core()->config.show_stats)
+		LDi(argRegs[1], int((Fragment*)_thisfrag));
+		#endif
+
+		assignSavedParams();
+
+		// restore first parameter, the only one we use
+		LInsp state = _thisfrag->lirbuf->state;
+		findSpecificRegFor(state, argRegs[state->imm8()]); 
+	}	
+
+	void Assembler::asm_fcond(LInsp ins)
+	{
+		// only want certain regs 
+		Register r = prepResultReg(ins, AllowableFlagRegs);
+		asm_setcc(r, ins);
+#ifdef NJ_ARM_VFP
+		SETE(r);
+#else
+		// SETcc only sets low 8 bits, so extend 
+		MOVZX8(r,r);
+		SETNP(r);
+#endif
+		asm_fcmp(ins);
+	}
+				
+	void Assembler::asm_cond(LInsp ins)
+	{
+		// only want certain regs 
+		LOpcode op = ins->opcode();			
+		Register r = prepResultReg(ins, AllowableFlagRegs);
+		// SETcc only sets low 8 bits, so extend 
+		MOVZX8(r,r);
+		if (op == LIR_eq)
+			SETE(r);
+		else if (op == LIR_ov)
+			SETO(r);
+		else if (op == LIR_cs)
+			SETC(r);
+		else if (op == LIR_lt)
+			SETL(r);
+		else if (op == LIR_le)
+			SETLE(r);
+		else if (op == LIR_gt)
+			SETG(r);
+		else if (op == LIR_ge)
+			SETGE(r);
+		else if (op == LIR_ult)
+			SETB(r);
+		else if (op == LIR_ule)
+			SETBE(r);
+		else if (op == LIR_ugt)
+			SETA(r);
+		else // if (op == LIR_uge)
+			SETAE(r);
+		asm_cmp(ins);
+	}
+	
+	void Assembler::asm_arith(LInsp ins)
+	{
+		LOpcode op = ins->opcode();			
+		LInsp lhs = ins->oprnd1();
+		LInsp rhs = ins->oprnd2();
+
+		Register rb = UnknownReg;
+		RegisterMask allow = GpRegs;
+		bool forceReg = (op == LIR_mul || !rhs->isconst());
+
+#ifdef NANOJIT_ARM
+		// Arm can't do an immediate op with immediates
+		// outside of +/-255 (for AND) r outside of
+		// 0..255 for others.
+		if (!forceReg)
+		{
+			if (rhs->isconst() && !isU8(rhs->constval()))
+				forceReg = true;
+		}
+#endif
+
+		if (lhs != rhs && forceReg)
+		{
+			if ((rb = asm_binop_rhs_reg(ins)) == UnknownReg) {
+				rb = findRegFor(rhs, allow);
+			}
+			allow &= ~rmask(rb);
+		}
+		else if ((op == LIR_add||op == LIR_addp) && lhs->isop(LIR_alloc) && rhs->isconst()) {
+			// add alloc+const, use lea
+			Register rr = prepResultReg(ins, allow);
+			int d = findMemFor(lhs) + rhs->constval();
+			LEA(rr, d, FP);
+		}
+
+		Register rr = prepResultReg(ins, allow);
+		Reservation* rA = getresv(lhs);
+		Register ra;
+		// if this is last use of lhs in reg, we can re-use result reg
+		if (rA == 0 || (ra = rA->reg) == UnknownReg)
+			ra = findSpecificRegFor(lhs, rr);
+		// else, rA already has a register assigned.
+
+		if (forceReg)
+		{
+			if (lhs == rhs)
+				rb = ra;
+
+			if (op == LIR_add || op == LIR_addp)
+				ADD(rr, rb);
+			else if (op == LIR_sub)
+				SUB(rr, rb);
+			else if (op == LIR_mul)
+				MUL(rr, rb);
+			else if (op == LIR_and)
+				AND(rr, rb);
+			else if (op == LIR_or)
+				OR(rr, rb);
+			else if (op == LIR_xor)
+				XOR(rr, rb);
+			else if (op == LIR_lsh)
+				SHL(rr, rb);
+			else if (op == LIR_rsh)
+				SAR(rr, rb);
+			else if (op == LIR_ush)
+				SHR(rr, rb);
+			else
+				NanoAssertMsg(0, "Unsupported");
+		}
+		else
+		{
+			int c = rhs->constval();
+			if (op == LIR_add || op == LIR_addp) {
+				{
+					ADDi(rr, c); 
+				}
+			} else if (op == LIR_sub) {
+				{
+					SUBi(rr, c); 
+				}
+			} else if (op == LIR_and)
+				ANDi(rr, c);
+			else if (op == LIR_or)
+				ORi(rr, c);
+			else if (op == LIR_xor)
+				XORi(rr, c);
+			else if (op == LIR_lsh)
+				SHLi(rr, c);
+			else if (op == LIR_rsh)
+				SARi(rr, c);
+			else if (op == LIR_ush)
+				SHRi(rr, c);
+			else
+				NanoAssertMsg(0, "Unsupported");
+		}
+
+		if ( rr != ra ) 
+			MR(rr,ra);
+	}
+	
+	void Assembler::asm_neg_not(LInsp ins)
+	{
+		LOpcode op = ins->opcode();			
+		Register rr = prepResultReg(ins, GpRegs);
+
+		LIns* lhs = ins->oprnd1();
+		Reservation *rA = getresv(lhs);
+		// if this is last use of lhs in reg, we can re-use result reg
+		Register ra;
+		if (rA == 0 || (ra=rA->reg) == UnknownReg)
+			ra = findSpecificRegFor(lhs, rr);
+		// else, rA already has a register assigned.
+
+		if (op == LIR_not)
+			NOT(rr); 
+		else
+			NEG(rr); 
+
+		if ( rr != ra ) 
+			MR(rr,ra); 
+	}
+				
+	void Assembler::asm_ld(LInsp ins)
+	{
+		LOpcode op = ins->opcode();			
+		LIns* base = ins->oprnd1();
+		LIns* disp = ins->oprnd2();
+		Register rr = prepResultReg(ins, GpRegs);
+		int d = disp->constval();
+		Register ra = getBaseReg(base, d, GpRegs);
+		if (op == LIR_ldcb)
+			LD8Z(rr, d, ra);
+		else
+			LD(rr, d, ra); 
+	}
+
+	void Assembler::asm_cmov(LInsp ins)
+	{
+		LOpcode op = ins->opcode();			
+		LIns* condval = ins->oprnd1();
+		NanoAssert(condval->isCmp());
+
+		LIns* values = ins->oprnd2();
+
+		NanoAssert(values->opcode() == LIR_2);
+		LIns* iftrue = values->oprnd1();
+		LIns* iffalse = values->oprnd2();
+
+		NanoAssert(op == LIR_qcmov || (!iftrue->isQuad() && !iffalse->isQuad()));
+		
+		const Register rr = prepResultReg(ins, GpRegs);
+
+		// this code assumes that neither LD nor MR nor MRcc set any of the condition flags.
+		// (This is true on Intel, is it true on all architectures?)
+		const Register iffalsereg = findRegFor(iffalse, GpRegs & ~rmask(rr));
+		if (op == LIR_cmov) {
+			switch (condval->opcode())
+			{
+				// note that these are all opposites...
+				case LIR_eq:	MRNE(rr, iffalsereg);	break;
+				case LIR_ov:    MRNO(rr, iffalsereg);   break;
+				case LIR_cs:    MRNC(rr, iffalsereg);   break;
+				case LIR_lt:	MRGE(rr, iffalsereg);	break;
+				case LIR_le:	MRG(rr, iffalsereg);	break;
+				case LIR_gt:	MRLE(rr, iffalsereg);	break;
+				case LIR_ge:	MRL(rr, iffalsereg);	break;
+				case LIR_ult:	MRAE(rr, iffalsereg);	break;
+				case LIR_ule:	MRA(rr, iffalsereg);	break;
+				case LIR_ugt:	MRBE(rr, iffalsereg);	break;
+				case LIR_uge:	MRB(rr, iffalsereg);	break;
+				debug_only( default: NanoAssert(0); break; )
+			}
+		} else if (op == LIR_qcmov) {
+			NanoAssert(0);
+		}
+		/*const Register iftruereg =*/ findSpecificRegFor(iftrue, rr);
+		asm_cmp(condval);
+	}
+				
+	void Assembler::asm_qhi(LInsp ins)
+	{
+		Register rr = prepResultReg(ins, GpRegs);
+		LIns *q = ins->oprnd1();
+		int d = findMemFor(q);
+		LD(rr, d+4, FP);
+	}
+
+	void Assembler::asm_param(LInsp ins)
+	{
+		uint32_t a = ins->imm8();
+		uint32_t kind = ins->imm8b();
+		if (kind == 0) {
+			// ordinary param
+			AbiKind abi = _thisfrag->lirbuf->abi;
+			uint32_t abi_regcount = abi == ABI_FASTCALL ? 2 : abi == ABI_THISCALL ? 1 : 0;
+			if (a < abi_regcount) {
+				// incoming arg in register
+				prepResultReg(ins, rmask(argRegs[a]));
+			} else {
+				// incoming arg is on stack, and EBP points nearby (see genPrologue)
+				Register r = prepResultReg(ins, GpRegs);
+				int d = (a - abi_regcount) * sizeof(intptr_t) + 8;
+				LD(r, d, FP); 
+			}
+		}
+		else {
+			// saved param
+			prepResultReg(ins, rmask(savedRegs[a]));
+		}
+	}
+
+	void Assembler::asm_short(LInsp ins)
+	{
+		Register rr = prepResultReg(ins, GpRegs);
+		int32_t val = ins->imm16();
+		if (val == 0)
+			XOR(rr,rr);
+		else
+			LDi(rr, val);
+	}
+
+	void Assembler::asm_int(LInsp ins)
+	{
+		Register rr = prepResultReg(ins, GpRegs);
+		int32_t val = ins->imm32();
+		if (val == 0)
+			XOR(rr,rr);
+		else
+			LDi(rr, val);
+	}
+
+	void Assembler::asm_quad(LInsp ins)
+	{
+    	Reservation *rR = getresv(ins);
+		Register rr = rR->reg;
+		if (rr != UnknownReg)
+		{
+			// @todo -- add special-cases for 0 and 1
+			_allocator.retire(rr);
+			rR->reg = UnknownReg;
+			NanoAssert((rmask(rr) & FpRegs) != 0);
+
+			const double d = ins->constvalf();
+            const uint64_t q = ins->constvalq();
+			if (rmask(rr) & XmmRegs) {
+				if (q == 0.0) {
+                    // test (int64)0 since -0.0 == 0.0
+					SSE_XORPDr(rr, rr);
+				} else if (d == 1.0) {
+					// 1.0 is extremely frequent and worth special-casing!
+					static const double k_ONE = 1.0;
+					LDSDm(rr, &k_ONE);
+				} else {
+					findMemFor(ins);
+					const int d = disp(rR);
+					SSE_LDQ(rr, d, FP);
+				}
+			} else {
+				if (q == 0.0) {
+                    // test (int64)0 since -0.0 == 0.0
+					FLDZ();
+				} else if (d == 1.0) {
+					FLD1();
+				} else {
+					findMemFor(ins);
+					int d = disp(rR);
+					FLDQ(d,FP);
+				}
+			}
+		}
+
+		// @todo, if we used xor, ldsd, fldz, etc above, we don't need mem here
+		int d = disp(rR);
+		freeRsrcOf(ins, false);
+		if (d)
+		{
+			const int32_t* p = (const int32_t*) (ins-2);
+			STi(FP,d+4,p[1]);
+			STi(FP,d,p[0]);
+		}
+	}
+	
+	void Assembler::asm_qlo(LInsp ins)
+	{
+		LIns *q = ins->oprnd1();
+		Reservation *resv = getresv(ins);
+		Register rr = resv->reg;
+		if (rr == UnknownReg) {
+			// store quad in spill loc
+			int d = disp(resv);
+			freeRsrcOf(ins, false);
+			Register qr = findRegFor(q, XmmRegs);
+			SSE_MOVDm(d, FP, qr);
+		} else {
+			freeRsrcOf(ins, false);
+			Register qr = findRegFor(q, XmmRegs);
+			SSE_MOVD(rr,qr);
+		}
 	}
 
 	void Assembler::asm_nongp_copy(Register r, Register s)
diff -r 17e9560465b0 js/src/nanojit/NativeThumb.h
--- a/js/src/nanojit/NativeThumb.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/nanojit/NativeThumb.h	Thu Oct 30 05:41:45 2008 -0400
@@ -64,27 +64,22 @@
 	/* ARM registers */
 	typedef enum 
 	{
-		R0  = 0,
-		R1  = 1,
-		R2  = 2,
-		R3  = 3,
-		R4  = 4,
-		R5  = 5,
-		R6  = 6,
-		R7  = 7,
-		R8  = 8,
-		//R9  = 9,
-		//R10 = 10,
-		//R11  = 11,
-		IP  = 12,
-		SP  = 13,
-		LR  = 14,
-		PC  = 15,
-
-		FP = SP,
-		
-		// helpers
-		FRAME_PTR = R7,
+		R0  = 0,  // 32bit return value, aka A1
+		R1  = 1,  // msw of 64bit return value, A2
+		R2  = 2,  // A3
+		R3  = 3,  // A4
+		R4  = 4,  // V1
+		R5  = 5,  // V2
+		R6  = 6,  // V3
+		R7  = 7,  // V4
+		R8  = 8,  // V5
+		R9  = 9,   // V6, SB (stack base)
+		R10 = 10,  // V7, SL
+		FP  = 11,  // V8, frame pointer 
+		IP  = 12,  // intra-procedure call scratch register
+		SP  = 13,  // stack pointer
+		LR  = 14,  // link register (BL sets LR = return address)
+		PC  = 15,  // program counter
 		
 		FirstReg = 0,
 		LastReg = 5,
@@ -101,6 +96,7 @@
 	} 
 	FragInfo;
 
+	static const int NumSavedRegs = 4;
 	static const RegisterMask SavedRegs = 1<<R4 | 1<<R5 | 1<<R6 | 1<<R7;
 	static const RegisterMask FpRegs = 0x0000; // FST0-FST7
 	static const RegisterMask GpRegs = 0x003F;
diff -r 17e9560465b0 js/src/nanojit/Nativei386.cpp
--- a/js/src/nanojit/Nativei386.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/nanojit/Nativei386.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -71,6 +71,7 @@
 #if defined NANOJIT_IA32
     const Register Assembler::argRegs[] = { ECX, EDX };
     const Register Assembler::retRegs[] = { EAX, EDX };
+    const Register Assembler::savedRegs[] = { EBX, ESI, EDI };
 #elif defined NANOJIT_AMD64
 #if defined WIN64
 	const Register Assembler::argRegs[] = { R8, R9, RCX, RDX };
@@ -78,7 +79,16 @@
 	const Register Assembler::argRegs[] = { RDI, RSI, RDX, RCX, R8, R9 };
 #endif
 	const Register Assembler::retRegs[] = { RAX, RDX };
+	const Register Assembler::savedRegs[] = { R13, R14, R15 };
 #endif
+
+    const static uint8_t max_abi_regs[] = {
+        2, /* ABI_FASTCALL */
+        1, /* ABI_THISCALL */
+        0, /* ABI_STDCALL */
+        0  /* ABI_CDECL */
+    };
+
 
 	void Assembler::nInit(AvmCore* core)
 	{
@@ -89,21 +99,20 @@
 #endif
 	}
 
-	NIns* Assembler::genPrologue(RegisterMask needSaving)
+	NIns* Assembler::genPrologue()
 	{
 		/**
 		 * Prologue
 		 */
 		uint32_t stackNeeded = STACK_GRANULARITY * _activation.highwatermark;
-		uint32_t savingCount = 0;
 
-		for(Register i=FirstReg; i <= LastReg; i = nextreg(i))
-			if (needSaving&rmask(i)) 
-				savingCount++;
-
-		// After forcing alignment, we've pushed the pre-alignment SP
-		// and savingCount registers.
-		uint32_t stackPushed = STACK_GRANULARITY * (1+savingCount);
+		uint32_t stackPushed =
+            STACK_GRANULARITY + // returnaddr
+            STACK_GRANULARITY; // ebp
+		
+		if (!_thisfrag->lirbuf->explicitSavedParams)
+			stackPushed += NumSavedRegs * STACK_GRANULARITY;
+		
 		uint32_t aligned = alignUp(stackNeeded + stackPushed, NJ_ALIGN_STACK);
 		uint32_t amt = aligned - stackPushed;
 
@@ -122,40 +131,44 @@
 		verbose_only( verbose_output("        patch entry:"); )
         NIns *patchEntry = _nIns;
 		MR(FP, SP); // Establish our own FP.
+        PUSHr(FP); // Save caller's FP.
 
-		// Save pre-alignment SP value here, where the FP will point,
-		// to preserve the illusion of a valid frame chain for
-		// functions like MMgc::GetStackTrace.  The 'return address'
-		// of this 'frame' will be the last-saved register, but that's
-		// fine, because the next-older frame will be legit.
-		PUSHr(FP);
+		if (!_thisfrag->lirbuf->explicitSavedParams) 
+			for (int i = 0; i < NumSavedRegs; ++i)
+				PUSHr(savedRegs[i]);
 
-		for(Register i=FirstReg; i <= LastReg; i = nextreg(i))
-			if (needSaving&rmask(i))
-				PUSHr(i);
-
-		// We'd like to be able to use SSE instructions like MOVDQA on
-		// stack slots; it requires 16B alignment.  Darwin requires a
-		// 16B stack alignment, and Linux GCC seems to intend to
-		// establish and preserve the same, but we're told that GCC
-		// has not always done this right.  To avoid doubt, do it on
-		// all platforms.  The prologue runs only when we enter
-		// fragments from the interpreter, so forcing 16B alignment
-		// here is cheap.
-#if defined NANOJIT_IA32
-		ANDi(SP, -NJ_ALIGN_STACK);
-#elif defined NANOJIT_AMD64
-		ANDQi(SP, -NJ_ALIGN_STACK);
-#endif
-		MR(FP,SP);
-		PUSHr(FP); // Save caller's FP.
+        // align the entry point
+        asm_align_code();
 
 		return patchEntry;
 	}
 
+    void Assembler::asm_align_code() {
+        static char nop[][9] = {
+                {0x90},
+                {0x66,0x90},
+                {0x0f,0x1f,0x00},
+                {0x0f,0x1f,0x40,0x00},
+                {0x0f,0x1f,0x44,0x00,0x00},
+                {0x66,0x0f,0x1f,0x44,0x00,0x00},
+                {0x0f,0x1f,0x80,0x00,0x00,0x00,0x00},
+                {0x0f,0x1f,0x84,0x00,0x00,0x00,0x00,0x00},
+                {0x66,0x0f,0x1f,0x84,0x00,0x00,0x00,0x00,0x00},
+        };
+        unsigned n;
+        while((n = uintptr_t(_nIns) & 15) != 0) {
+            if (n > 9)
+                n = 9;
+            underrunProtect(n);
+            _nIns -= n;
+            memcpy(_nIns, nop[n-1], n);
+            asm_output1("nop%d", n);
+        }
+    }
+
 	void Assembler::nFragExit(LInsp guard)
 	{
-		SideExit *exit = guard->exit();
+		SideExit *exit = guard->record()->exit;
 		bool trees = _frago->core()->config.tree_opt;
         Fragment *frag = exit->target;
         GuardRecord *lr = 0;
@@ -169,7 +182,7 @@
 		else
 		{
 			// target doesn't exit yet.  emit jump to epilog, and set up to patch later.
-			lr = placeGuardRecord(guard);
+			lr = guard->record();
 #if defined NANOJIT_AMD64
             /* 8 bytes for address, 4 for imm32, 2 for jmp */
             underrunProtect(14);
@@ -181,16 +194,9 @@
             JMP_long(_epilogue);
 			lr->jmp = _nIns;
 #endif
-#if 0			
-			// @todo optimization ; is it worth it? It means we can remove the loop over outbound in Fragment.link() 
-			// for trees we need the patch entry on the incoming fragment so we can unhook it later if needed
-			if (tress && destKnown)
-				patch(lr);
-#endif
 		}
 		// first restore ESP from EBP, undoing SUBi(SP,amt) from genPrologue
         MR(SP,FP);
-
 
         #ifdef NJ_VERBOSE
         if (_frago->core()->config.show_stats) {
@@ -213,17 +219,16 @@
 	#endif
 	}
 
-    NIns *Assembler::genEpilogue(RegisterMask restore)
+    NIns *Assembler::genEpilogue()
     {
         RET();
+
+		if (!_thisfrag->lirbuf->explicitSavedParams) 
+			for (int i = NumSavedRegs - 1; i >= 0; --i)
+				POPr(savedRegs[i]);
+
         POPr(FP); // Restore caller's FP.
-        MR(SP,FP); // Undo forced alignment.
-
-		// Restore saved registers.
-		for (Register i=UnknownReg; i >= FirstReg; i = prevreg(i))
-			if (restore&rmask(i)) { POPr(i); } 
-		
-		POPr(FP); // Pop the pre-alignment SP.
+        MR(SP,FP); // pop the stack frame
         return  _nIns;
     }
 	
@@ -232,75 +237,92 @@
 	{
         const CallInfo* call = ins->callInfo();
 		// must be signed, not unsigned
-		const uint32_t iargs = call->count_iargs();
-		int32_t fstack = call->count_args() - iargs;
+		uint32_t iargs = call->count_iargs();
+		int32_t fargs = call->count_args() - iargs - call->isIndirect();
 
+        bool imt = call->isInterface();
+        if (imt)
+            iargs --;
+
+        uint32_t max_regs = max_abi_regs[call->_abi];
+        if (max_regs > iargs)
+            max_regs = iargs;
+
+        int32_t istack = iargs-max_regs;  // first 2 4B args are in registers
         int32_t extra = 0;
+		const int32_t pushsize = 4*istack + 8*fargs; // actual stack space used
 
-#if defined NJ_NO_FASTCALL
-        int32_t istack = iargs;
+#if _MSC_VER
+        // msc is slack, and MIR doesn't do anything extra, so lets use this
+        // call-site alignment to at least have code size parity with MIR.
+        uint32_t align = 4;//NJ_ALIGN_STACK;
 #else
-		int32_t istack = iargs-2;  // first 2 4B args are in registers
-		if (istack <= 0)
-		{
-			istack = 0;
-		}
+        uint32_t align = NJ_ALIGN_STACK;
 #endif
 
-		const int32_t size = 4*istack + 8*fstack; // actual stack space used
-        if (size) {
+        if (pushsize) {
 		    // stack re-alignment 
 		    // only pop our adjustment amount since callee pops args in FASTCALL mode
-		    extra = alignUp(size, NJ_ALIGN_STACK) - (size); 
-#ifndef NJ_NO_FASTCALL
-		    if (extra > 0)
-			{
+		    extra = alignUp(pushsize, align) - pushsize;
+            if (call->_abi == ABI_CDECL) {
+				// with CDECL only, caller pops args
+                ADDi(SP, extra+pushsize);
+            } else if (extra > 0) {
 				ADDi(SP, extra);
-			}
-#endif
+            }
         }
 
-#ifdef NJ_NO_FASTCALL
-        // In C calling conventions, callee doesn't pop args.
-        ADDi(SP, 4*iargs + 8*fstack + extra);
-#endif
-
-		CALL(call);
-
-#ifdef NJ_NO_FASTCALL
-        if (iargs >= 1) {
-            PUSHr(ECX);
-            if (iargs >= 2) {
-                PUSHr(EDX);
-            }
+        bool indirect = false;
+        if (ins->isop(LIR_call) || ins->isop(LIR_fcall)) {
+            verbose_only(if (_verbose)
+                outputf("        %p:", _nIns);
+            )
+    		CALL(call);
         }
-#endif
+        else {
+            // indirect call.  x86 Calling conventions don't use EAX as an
+            // argument, and do use EAX as a return value.  We need a register
+            // for the address to call, so we use EAX since it will always be
+            // available
+            NanoAssert(ins->isop(LIR_calli) || ins->isop(LIR_fcalli));
+            CALLr(call, EAX);
+            indirect = true;
+        }
 
 		// make sure fpu stack is empty before call (restoreCallerSaved)
 		NanoAssert(_allocator.isFree(FST0));
 		// note: this code requires that ref arguments (ARGSIZE_Q)
         // be one of the first two arguments
-		// pre-assign registers to the first 2 4B args
-		const int max_regs = (iargs < 2) ? iargs : 2;
-		int n = 0;
+		// pre-assign registers to the first N 4B args based on the calling convention
+		uint32_t n = 0;
 
-        ArgSize sizes[10];
+        ArgSize sizes[2*MAXARGS];
         uint32_t argc = call->get_sizes(sizes);
+        if (indirect) {
+            argc--;
+            asm_arg(ARGSIZE_LO, ins->arg(argc), EAX);
+        }
+
+        if (imt) {
+            // interface thunk calling convention: put iid in EDX
+            NanoAssert(call->_abi == ABI_CDECL);
+            argc--;
+            asm_arg(ARGSIZE_LO, ins->arg(argc), EDX);
+        }
 
 		for(uint32_t i=0; i < argc; i++)
 		{
 			uint32_t j = argc-i-1;
             ArgSize sz = sizes[j];
             Register r = UnknownReg;
-            if (n < max_regs && sz != ARGSIZE_F) 
-			    r = argRegs[n++]; // tell asm_arg what reg to use
+            if (n < max_regs && sz != ARGSIZE_F) { 
+		        r = argRegs[n++]; // tell asm_arg what reg to use
+            }
             asm_arg(sz, ins->arg(j), r);
 		}
 
 		if (extra > 0)
-		{
 			SUBi(SP, extra);
-		}
 	}
 
 #elif defined NANOJIT_AMD64
@@ -310,7 +332,7 @@
 		Register fpu_reg = XMM0;
         const CallInfo* call = ins->callInfo();
 		int n = 0;
-        
+
 		CALL(call);
 
         ArgSize sizes[10];
@@ -345,7 +367,8 @@
 			#else
 			if (mprotect((void *)addr, count*NJ_PAGE_SIZE, PROT_READ|PROT_WRITE|PROT_EXEC) == -1) {
 			#endif
-                AvmDebugLog(("FATAL ERROR: mprotect(PROT_EXEC) failed\n"));
+				// todo: we can't abort or assert here, we have to fail gracefully.
+				NanoAssertMsg(false, "FATAL ERROR: mprotect(PROT_EXEC) failed\n");
                 abort();
             }
 		#endif
@@ -417,25 +440,26 @@
 	{
 		uint32_t op = i->opcode();
 		int prefer = allow;
-		if (op == LIR_call)
-#if defined NANOJIT_IA32
-			prefer &= rmask(EAX);
-#elif defined NANOJIT_AMD64
-			prefer &= rmask(RAX);
-#endif
-		else if (op == LIR_param)
-			prefer &= rmask(Register(i->imm8()));
-#if defined NANOJIT_IA32
-        else if (op == LIR_callh || op == LIR_rsh && i->oprnd1()->opcode()==LIR_callh)
-            prefer &= rmask(EDX);
-#else
-		else if (op == LIR_callh)
-			prefer &= rmask(RAX);
-#endif
-		else if (i->isCmp())
+        if (op == LIR_call || op == LIR_calli) {
+			prefer &= rmask(retRegs[0]);
+        }
+        else if (op == LIR_fcall || op == LIR_fcalli) {
+            prefer &= rmask(FST0);
+        }
+        else if (op == LIR_param) {
+            uint32_t max_regs = max_abi_regs[_thisfrag->lirbuf->abi];
+            if (i->imm8() < max_regs)
+    			prefer &= rmask(Register(i->imm8()));
+        }
+        else if (op == LIR_callh || op == LIR_rsh && i->oprnd1()->opcode()==LIR_callh) {
+            prefer &= rmask(retRegs[1]);
+        }
+        else if (i->isCmp()) {
 			prefer &= AllowableFlagRegs;
-        else if (i->isconst())
+        }
+        else if (i->isconst()) {
             prefer &= ScratchRegs;
+        }
 		return (_allocator.free & prefer) ? prefer : allow;
 	}
 
@@ -476,38 +500,49 @@
         freeRsrcOf(ins, false);	// if we had a reg in use, emit a ST to flush it to mem
     }
 
+	void Assembler::asm_load(int d, Register r)
+	{
+		if (rmask(r) & FpRegs)
+		{
+#if defined NANOJIT_IA32
+			if (rmask(r) & XmmRegs) {
+#endif
+				SSE_LDQ(r, d, FP);
+#if defined NANOJIT_IA32
+			} else {
+				FLDQ(d, FP); 
+			}
+#endif
+		}
+#if defined NANOJIT_AMD64
+		else if (i->opcode() == LIR_param)
+		{
+			LDQ(r, d, FP);
+		}
+#endif
+		else
+		{
+			LD(r, d, FP);
+		}
+	}
+	
 	void Assembler::asm_restore(LInsp i, Reservation *resv, Register r)
 	{
-        if (i->isconst())
-        {
+        if (i->isop(LIR_alloc)) {
+            LEA(r, disp(resv), FP);
+            verbose_only(if (_verbose) {
+                outputf("        remat %s size %d", _thisfrag->lirbuf->names->formatRef(i), i->size());
+            })
+        }
+        else if (i->isconst()) {
             if (!resv->arIndex) {
                 reserveFree(i);
             }
             LDi(r, i->constval());
         }
-        else
-        {
+        else {
             int d = findMemFor(i);
-            if (rmask(r) & FpRegs)
-		    {
-#if defined NANOJIT_IA32
-                if (rmask(r) & XmmRegs) {
-#endif
-                    SSE_LDQ(r, d, FP);
-#if defined NANOJIT_IA32
-                } else {
-			        FLDQ(d, FP); 
-                }
-#endif
-            }
-            else
-		    {
-#if defined NANOJIT_AMD64
-                LDQ(r, d, FP);
-#else
-			    LD(r, d, FP);
-#endif
-		    }
+			asm_load(d,r);
 			verbose_only(if (_verbose) {
 				outputf("        restore %s", _thisfrag->lirbuf->names->formatRef(i));
 			})
@@ -518,7 +553,7 @@
     {
         if (value->isconst())
         {
-			Register rb = findRegFor(base, GpRegs);
+			Register rb = getBaseReg(base, dr, GpRegs);
             int c = value->constval();
 			STi(rb, dr, c);
         }
@@ -526,18 +561,28 @@
         {
 		    // make sure what is in a register
 		    Reservation *rA, *rB;
-		    findRegFor2(GpRegs, value, rA, base, rB);
-		    Register ra = rA->reg;
-		    Register rb = rB->reg;
+            Register ra, rb;
+            if (base->isop(LIR_alloc)) {
+                rb = FP;
+                dr += findMemFor(base);
+                ra = findRegFor(value, GpRegs);
+            } else if (base->isconst()) {
+                // absolute address
+                dr += base->constval();
+                ra = findRegFor(value, GpRegs);
+                rb = UnknownReg;
+            } else {
+    		    findRegFor2(GpRegs, value, rA, base, rB);
+		        ra = rA->reg;
+		        rb = rB->reg;
+            }
 		    ST(rb, dr, ra);
         }
     }
 
-	void Assembler::asm_spill(LInsp i, Reservation *resv, bool pop)
+	void Assembler::asm_spill(Register rr, int d, bool pop, bool quad)
 	{
-		(void)i;
-		int d = disp(resv);
-		Register rr = resv->reg;
+		(void)quad;
 		if (d)
 		{
 			// save to spill location
@@ -553,17 +598,16 @@
                 }
 #endif
 			}
+#if defined NANOJIT_AMD64
+			else if (quad)
+			{
+				STQ(FP, d, rr);
+			}
+#endif
 			else
 			{
-#if defined NANOJIT_AMD64
-				STQ(FP, d, rr);
-#else
 				ST(FP, d, rr);
-#endif
 			}
-			verbose_only(if (_verbose) {
-				outputf("        spill %s",_thisfrag->lirbuf->names->formatRef(i));
-			})
 		}
 #if defined NANOJIT_IA32
 		else if (pop && (rmask(rr) & x87Regs))
@@ -571,7 +615,7 @@
 			// pop the fpu result since it isn't used
 			FSTP(FST0);
 		}
-#endif
+#endif	
 	}
 
 	void Assembler::asm_load64(LInsp ins)
@@ -584,7 +628,7 @@
 		if (rr != UnknownReg && rmask(rr) & XmmRegs)
 		{
 			freeRsrcOf(ins, false);
-			Register rb = findRegFor(base, GpRegs);
+			Register rb = getBaseReg(base, db, GpRegs);
 			SSE_LDQ(rr, db, rb);
 		}
 #if defined NANOJIT_AMD64
@@ -614,7 +658,13 @@
 		else
 		{
 			int dr = disp(resv);
-			Register rb = findRegFor(base, GpRegs);
+			Register rb;
+            if (base->isop(LIR_alloc)) {
+                rb = FP;
+                db += findMemFor(base);
+            } else {
+                rb = findRegFor(base, GpRegs);
+            }
 			resv->reg = UnknownReg;
 
 			// don't use an fpu reg to simply load & store the value.
@@ -639,7 +689,13 @@
 		{
 			// if a constant 64-bit value just store it now rather than
 			// generating a pointless store/load/store sequence
-			Register rb = findRegFor(base, GpRegs);
+			Register rb;
+            if (base->isop(LIR_alloc)) {
+                rb = FP;
+                dr += findMemFor(base);
+            } else {
+                rb = findRegFor(base, GpRegs);
+            }
 			const int32_t* p = (const int32_t*) (value-2);
 			STi(rb, dr+4, p[1]);
 			STi(rb, dr, p[0]);
@@ -647,7 +703,7 @@
 		}
 
 #if defined NANOJIT_IA32
-        if (value->isop(LIR_ldq) || value->isop(LIR_qjoin))
+        if (value->isop(LIR_ldq) || value->isop(LIR_ldqc) || value->isop(LIR_qjoin))
 		{
 			// value is 64bit struct or int64_t, or maybe a double.
 			// it may be live in an FPU reg.  Either way, don't
@@ -660,21 +716,47 @@
 
 			if (avmplus::AvmCore::use_sse2()) {
                 Register rv = findRegFor(value, XmmRegs);
-                Register rb = findRegFor(base, GpRegs);
+		Register rb;
+		if (base->isop(LIR_alloc)) {
+		    rb = FP;
+		    dr += findMemFor(base);
+		} else {
+		    rb = findRegFor(base, GpRegs);
+		}
                 SSE_STQ(dr, rb, rv);
 				return;
             }
 
 			int da = findMemFor(value);
-		    Register rb = findRegFor(base, GpRegs);
+		    Register rb;
+		    if (base->isop(LIR_alloc)) {
+					rb = FP;
+					dr += findMemFor(base);
+		    } else {
+					rb = findRegFor(base, GpRegs);
+		    }
 		    asm_mmq(rb, dr, FP, da);
             return;
 		}
 
+		Register rb;
+		if (base->isop(LIR_alloc)) {
+		    rb = FP;
+		    dr += findMemFor(base);
+		} else {
+		    rb = findRegFor(base, GpRegs);
+		}
+
+		// if value already in a reg, use that, otherwise
+		// try to get it into XMM regs before FPU regs.
 		Reservation* rA = getresv(value);
+		Register rv;
 		int pop = !rA || rA->reg==UnknownReg;
- 		Register rv = findRegFor(value, avmplus::AvmCore::use_sse2() ? XmmRegs : FpRegs);
-		Register rb = findRegFor(base, GpRegs);
+		if (pop) {
+		    rv = findRegFor(value, avmplus::AvmCore::use_sse2() ? XmmRegs : FpRegs);
+		} else {
+		    rv = rA->reg;
+		}
 
 		if (rmask(rv) & XmmRegs) {
             SSE_STQ(dr, rb, rv);
@@ -750,6 +832,466 @@
 #endif
     }
 
+	NIns* Assembler::asm_branch(bool branchOnFalse, LInsp cond, NIns* targ)
+	{
+		NIns* at = 0;
+		LOpcode condop = cond->opcode();
+		NanoAssert(cond->isCond());
+#ifndef NJ_SOFTFLOAT
+		if (condop >= LIR_feq && condop <= LIR_fge)
+		{
+			return asm_jmpcc(branchOnFalse, cond, targ);
+		}
+#endif
+		// produce the branch
+		if (branchOnFalse)
+		{
+			if (condop == LIR_eq)
+				JNE(targ);
+			else if (condop == LIR_ov)
+				JNO(targ);
+			else if (condop == LIR_cs)
+				JNC(targ);
+			else if (condop == LIR_lt)
+				JNL(targ);
+			else if (condop == LIR_le)
+				JNLE(targ);
+			else if (condop == LIR_gt)
+				JNG(targ);
+			else if (condop == LIR_ge)
+				JNGE(targ);
+			else if (condop == LIR_ult)
+				JNB(targ);
+			else if (condop == LIR_ule)
+				JNBE(targ);
+			else if (condop == LIR_ugt)
+				JNA(targ);
+			else //if (condop == LIR_uge)
+				JNAE(targ);
+		}
+		else // op == LIR_xt
+		{
+			if (condop == LIR_eq)
+				JE(targ);
+			else if (condop == LIR_ov)
+				JO(targ);
+			else if (condop == LIR_cs)
+				JC(targ);
+			else if (condop == LIR_lt)
+				JL(targ);
+			else if (condop == LIR_le)
+				JLE(targ);
+			else if (condop == LIR_gt)
+				JG(targ);
+			else if (condop == LIR_ge)
+				JGE(targ);
+			else if (condop == LIR_ult)
+				JB(targ);
+			else if (condop == LIR_ule)
+				JBE(targ);
+			else if (condop == LIR_ugt)
+				JA(targ);
+			else //if (condop == LIR_uge)
+				JAE(targ);
+		}
+		at = _nIns;
+		asm_cmp(cond);
+		return at;
+	}
+
+	void Assembler::asm_cmp(LIns *cond)
+	{
+        LOpcode condop = cond->opcode();
+        
+        // LIR_ov and LIR_cs recycle the flags set by arithmetic ops
+        if ((condop == LIR_ov) || (condop == LIR_cs))
+            return;
+        
+        LInsp lhs = cond->oprnd1();
+		LInsp rhs = cond->oprnd2();
+		Reservation *rA, *rB;
+
+		NanoAssert((!lhs->isQuad() && !rhs->isQuad()) || (lhs->isQuad() && rhs->isQuad()));
+
+		// Not supported yet.
+#if !defined NANOJIT_64BIT
+		NanoAssert(!lhs->isQuad() && !rhs->isQuad());
+#endif
+
+		// ready to issue the compare
+		if (rhs->isconst())
+		{
+			int c = rhs->constval();
+			if (c == 0 && cond->isop(LIR_eq)) {
+				Register r = findRegFor(lhs, GpRegs);
+				if (rhs->isQuad()) {
+#if defined NANOJIT_64BIT
+					TESTQ(r, r);
+#endif
+				} else {
+					TEST(r,r);
+				}
+			// No 64-bit immediates so fall-back to below
+			}
+			else if (!rhs->isQuad()) {
+				Register r = getBaseReg(lhs, c, GpRegs);
+				CMPi(r, c);
+			}
+		}
+		else
+		{
+			findRegFor2(GpRegs, lhs, rA, rhs, rB);
+			Register ra = rA->reg;
+			Register rb = rB->reg;
+			if (rhs->isQuad()) {
+#if defined NANOJIT_64BIT
+				CMPQ(ra, rb);
+#endif
+			} else {
+				CMP(ra, rb);
+			}
+		}
+	}
+
+	void Assembler::asm_loop(LInsp ins, NInsList& loopJumps)
+	{
+		JMP_long(0);
+
+        loopJumps.add(_nIns);
+
+		// If the target we are looping to is in a different fragment, we have to restore
+		// SP since we will target fragEntry and not SOT.
+		Fragment* target = ins->record()->exit->target;
+		if (target != _thisfrag)
+	        MR(SP,FP);
+		
+		#ifdef NJ_VERBOSE
+		// branching from this frag to ourself.
+		if (_frago->core()->config.show_stats)
+		#if defined NANOJIT_AMD64
+			LDQi(argRegs[1], intptr_t((Fragment*)_thisfrag));
+		#else
+			LDi(argRegs[1], int((Fragment*)_thisfrag));
+		#endif
+		#endif
+
+		assignSavedParams();
+
+		// restore first parameter, the only one we use
+		LInsp state = _thisfrag->lirbuf->state;
+		findSpecificRegFor(state, argRegs[state->imm8()]); 
+	}	
+
+	void Assembler::asm_fcond(LInsp ins)
+	{
+		// only want certain regs 
+		Register r = prepResultReg(ins, AllowableFlagRegs);
+		asm_setcc(r, ins);
+#ifdef NJ_ARM_VFP
+		SETE(r);
+#else
+		// SETcc only sets low 8 bits, so extend 
+		MOVZX8(r,r);
+		SETNP(r);
+#endif
+		asm_fcmp(ins);
+	}
+				
+	void Assembler::asm_cond(LInsp ins)
+	{
+		// only want certain regs 
+		LOpcode op = ins->opcode();			
+		Register r = prepResultReg(ins, AllowableFlagRegs);
+		// SETcc only sets low 8 bits, so extend 
+		MOVZX8(r,r);
+		if (op == LIR_eq)
+			SETE(r);
+		else if (op == LIR_ov)
+			SETO(r);
+		else if (op == LIR_cs)
+			SETC(r);
+		else if (op == LIR_lt)
+			SETL(r);
+		else if (op == LIR_le)
+			SETLE(r);
+		else if (op == LIR_gt)
+			SETG(r);
+		else if (op == LIR_ge)
+			SETGE(r);
+		else if (op == LIR_ult)
+			SETB(r);
+		else if (op == LIR_ule)
+			SETBE(r);
+		else if (op == LIR_ugt)
+			SETA(r);
+		else // if (op == LIR_uge)
+			SETAE(r);
+		asm_cmp(ins);
+	}
+	
+	void Assembler::asm_arith(LInsp ins)
+	{
+		LOpcode op = ins->opcode();			
+		LInsp lhs = ins->oprnd1();
+		LInsp rhs = ins->oprnd2();
+
+		Register rb = UnknownReg;
+		RegisterMask allow = GpRegs;
+		bool forceReg = (op == LIR_mul || !rhs->isconst());
+
+#ifdef NANOJIT_ARM
+		// Arm can't do an immediate op with immediates
+		// outside of +/-255 (for AND) r outside of
+		// 0..255 for others.
+		if (!forceReg)
+		{
+			if (rhs->isconst() && !isU8(rhs->constval()))
+				forceReg = true;
+		}
+#endif
+
+		if (lhs != rhs && forceReg)
+		{
+			if ((rb = asm_binop_rhs_reg(ins)) == UnknownReg) {
+				rb = findRegFor(rhs, allow);
+			}
+			allow &= ~rmask(rb);
+		}
+		else if ((op == LIR_add||op == LIR_addp) && lhs->isop(LIR_alloc) && rhs->isconst()) {
+			// add alloc+const, use lea
+			Register rr = prepResultReg(ins, allow);
+			int d = findMemFor(lhs) + rhs->constval();
+			LEA(rr, d, FP);
+		}
+
+		Register rr = prepResultReg(ins, allow);
+		Reservation* rA = getresv(lhs);
+		Register ra;
+		// if this is last use of lhs in reg, we can re-use result reg
+		if (rA == 0 || (ra = rA->reg) == UnknownReg)
+			ra = findSpecificRegFor(lhs, rr);
+		// else, rA already has a register assigned.
+
+		if (forceReg)
+		{
+			if (lhs == rhs)
+				rb = ra;
+
+			if (op == LIR_add || op == LIR_addp)
+				ADD(rr, rb);
+			else if (op == LIR_sub)
+				SUB(rr, rb);
+			else if (op == LIR_mul)
+				MUL(rr, rb);
+			else if (op == LIR_and)
+				AND(rr, rb);
+			else if (op == LIR_or)
+				OR(rr, rb);
+			else if (op == LIR_xor)
+				XOR(rr, rb);
+			else if (op == LIR_lsh)
+				SHL(rr, rb);
+			else if (op == LIR_rsh)
+				SAR(rr, rb);
+			else if (op == LIR_ush)
+				SHR(rr, rb);
+			else
+				NanoAssertMsg(0, "Unsupported");
+		}
+		else
+		{
+			int c = rhs->constval();
+			if (op == LIR_add || op == LIR_addp) {
+#ifdef NANOJIT_IA32_TODO
+				if (ra != rr) {
+					// this doesn't set cc's, only use it when cc's not required.
+					LEA(rr, c, ra);
+					ra = rr; // suppress mov
+				} else
+#endif
+				{
+					ADDi(rr, c); 
+				}
+			} else if (op == LIR_sub) {
+#ifdef NANOJIT_IA32
+				if (ra != rr) {
+					LEA(rr, -c, ra);
+					ra = rr;
+				} else
+#endif
+				{
+					SUBi(rr, c); 
+				}
+			} else if (op == LIR_and)
+				ANDi(rr, c);
+			else if (op == LIR_or)
+				ORi(rr, c);
+			else if (op == LIR_xor)
+				XORi(rr, c);
+			else if (op == LIR_lsh)
+				SHLi(rr, c);
+			else if (op == LIR_rsh)
+				SARi(rr, c);
+			else if (op == LIR_ush)
+				SHRi(rr, c);
+			else
+				NanoAssertMsg(0, "Unsupported");
+		}
+
+		if ( rr != ra ) 
+			MR(rr,ra);
+	}
+	
+	void Assembler::asm_neg_not(LInsp ins)
+	{
+		LOpcode op = ins->opcode();			
+		Register rr = prepResultReg(ins, GpRegs);
+
+		LIns* lhs = ins->oprnd1();
+		Reservation *rA = getresv(lhs);
+		// if this is last use of lhs in reg, we can re-use result reg
+		Register ra;
+		if (rA == 0 || (ra=rA->reg) == UnknownReg)
+			ra = findSpecificRegFor(lhs, rr);
+		// else, rA already has a register assigned.
+
+		if (op == LIR_not)
+			NOT(rr); 
+		else
+			NEG(rr); 
+
+		if ( rr != ra ) 
+			MR(rr,ra); 
+	}
+				
+	void Assembler::asm_ld(LInsp ins)
+	{
+		LOpcode op = ins->opcode();			
+		LIns* base = ins->oprnd1();
+		LIns* disp = ins->oprnd2();
+		Register rr = prepResultReg(ins, GpRegs);
+		int d = disp->constval();
+		Register ra = getBaseReg(base, d, GpRegs);
+		if (op == LIR_ldcb)
+			LD8Z(rr, d, ra);
+		else
+			LD(rr, d, ra); 
+	}
+
+	void Assembler::asm_cmov(LInsp ins)
+	{
+		LOpcode op = ins->opcode();			
+		LIns* condval = ins->oprnd1();
+		NanoAssert(condval->isCmp());
+
+		LIns* values = ins->oprnd2();
+
+		NanoAssert(values->opcode() == LIR_2);
+		LIns* iftrue = values->oprnd1();
+		LIns* iffalse = values->oprnd2();
+
+		NanoAssert(op == LIR_qcmov || (!iftrue->isQuad() && !iffalse->isQuad()));
+		
+		const Register rr = prepResultReg(ins, GpRegs);
+
+		// this code assumes that neither LD nor MR nor MRcc set any of the condition flags.
+		// (This is true on Intel, is it true on all architectures?)
+		const Register iffalsereg = findRegFor(iffalse, GpRegs & ~rmask(rr));
+		if (op == LIR_cmov) {
+			switch (condval->opcode())
+			{
+				// note that these are all opposites...
+				case LIR_eq:	MRNE(rr, iffalsereg);	break;
+				case LIR_ov:    MRNO(rr, iffalsereg);   break;
+				case LIR_cs:    MRNC(rr, iffalsereg);   break;
+				case LIR_lt:	MRGE(rr, iffalsereg);	break;
+				case LIR_le:	MRG(rr, iffalsereg);	break;
+				case LIR_gt:	MRLE(rr, iffalsereg);	break;
+				case LIR_ge:	MRL(rr, iffalsereg);	break;
+				case LIR_ult:	MRAE(rr, iffalsereg);	break;
+				case LIR_ule:	MRA(rr, iffalsereg);	break;
+				case LIR_ugt:	MRBE(rr, iffalsereg);	break;
+				case LIR_uge:	MRB(rr, iffalsereg);	break;
+				debug_only( default: NanoAssert(0); break; )
+			}
+		} else if (op == LIR_qcmov) {
+#if !defined NANOJIT_64BIT
+			NanoAssert(0);
+#else
+			switch (condval->opcode())
+			{
+				// note that these are all opposites...
+				case LIR_eq:	MRQNE(rr, iffalsereg);	break;
+				case LIR_ov:    MRQNO(rr, iffalsereg);   break;
+				case LIR_cs:    MRQNC(rr, iffalsereg);   break;
+				case LIR_lt:	MRQGE(rr, iffalsereg);	break;
+				case LIR_le:	MRQG(rr, iffalsereg);	break;
+				case LIR_gt:	MRQLE(rr, iffalsereg);	break;
+				case LIR_ge:	MRQL(rr, iffalsereg);	break;
+				case LIR_ult:	MRQAE(rr, iffalsereg);	break;
+				case LIR_ule:	MRQA(rr, iffalsereg);	break;
+				case LIR_ugt:	MRQBE(rr, iffalsereg);	break;
+				case LIR_uge:	MRQB(rr, iffalsereg);	break;
+				debug_only( default: NanoAssert(0); break; )
+			}
+#endif
+		}
+		/*const Register iftruereg =*/ findSpecificRegFor(iftrue, rr);
+		asm_cmp(condval);
+	}
+				
+	void Assembler::asm_qhi(LInsp ins)
+	{
+		Register rr = prepResultReg(ins, GpRegs);
+		LIns *q = ins->oprnd1();
+		int d = findMemFor(q);
+		LD(rr, d+4, FP);
+	}
+
+	void Assembler::asm_param(LInsp ins)
+	{
+		uint32_t a = ins->imm8();
+		uint32_t kind = ins->imm8b();
+		if (kind == 0) {
+			// ordinary param
+			AbiKind abi = _thisfrag->lirbuf->abi;
+			uint32_t abi_regcount = max_abi_regs[abi];
+			if (a < abi_regcount) {
+				// incoming arg in register
+				prepResultReg(ins, rmask(argRegs[a]));
+			} else {
+				// incoming arg is on stack, and EBP points nearby (see genPrologue)
+				Register r = prepResultReg(ins, GpRegs);
+				int d = (a - abi_regcount) * sizeof(intptr_t) + 8;
+				LD(r, d, FP); 
+			}
+		}
+		else {
+			// saved param
+			prepResultReg(ins, rmask(savedRegs[a]));
+		}
+	}
+
+	void Assembler::asm_short(LInsp ins)
+	{
+		Register rr = prepResultReg(ins, GpRegs);
+		int32_t val = ins->imm16();
+		if (val == 0)
+			XOR(rr,rr);
+		else
+			LDi(rr, val);
+	}
+
+	void Assembler::asm_int(LInsp ins)
+	{
+		Register rr = prepResultReg(ins, GpRegs);
+		int32_t val = ins->imm32();
+		if (val == 0)
+			XOR(rr,rr);
+		else
+			LDi(rr, val);
+	}
+
 	void Assembler::asm_quad(LInsp ins)
 	{
 #if defined NANOJIT_IA32
@@ -763,8 +1305,10 @@
 			NanoAssert((rmask(rr) & FpRegs) != 0);
 
 			const double d = ins->constvalf();
+            const uint64_t q = ins->constvalq();
 			if (rmask(rr) & XmmRegs) {
-				if (d == 0.0) {
+				if (q == 0.0) {
+                    // test (int64)0 since -0.0 == 0.0
 					SSE_XORPDr(rr, rr);
 				} else if (d == 1.0) {
 					// 1.0 is extremely frequent and worth special-casing!
@@ -776,7 +1320,8 @@
 					SSE_LDQ(rr, d, FP);
 				}
 			} else {
-				if (d == 0.0) {
+				if (q == 0.0) {
+                    // test (int64)0 since -0.0 == 0.0
 					FLDZ();
 				} else if (d == 1.0) {
 					FLD1();
@@ -803,24 +1348,23 @@
 
 		if (rR->reg != UnknownReg)
 		{
-            Register rr = rR->reg;
-		    freeRsrcOf(ins, false);
-			if (rmask(rr) & GpRegs)
+			if (rmask(rR->reg) & GpRegs)
 			{
-				LDQi(rr, val);
+				LDQi(rR->reg, val);
 			}
-			else if (rmask(rr) & XmmRegs)
+			else if (rmask(rR->reg) & XmmRegs)
 			{
 				if (ins->constvalf() == 0.0)
 				{
-					SSE_XORPDr(rr, rr);
+					SSE_XORPDr(rR->reg, rR->reg);
 				}
 				else
 				{
 					/* Get a short-lived register, not associated with instruction */
+					Register rd = rR->reg;
 					Register rs = registerAlloc(GpRegs);
-
-					SSE_MOVD(rr, rs);
+	
+					SSE_MOVD(rd, rs);
 					LDQi(rs, val);
 
 					_allocator.addFree(rs);
@@ -831,37 +1375,42 @@
 		{
 			const int32_t* p = (const int32_t*) (ins-2);
 			int dr = disp(rR);
-		    freeRsrcOf(ins, false);
 			STi(FP, dr+4, p[1]);
 			STi(FP, dr, p[0]);
 		}
+
+		freeRsrcOf(ins, false);
 #endif
 	}
 	
-	bool Assembler::asm_qlo(LInsp ins, LInsp q)
+	void Assembler::asm_qlo(LInsp ins)
 	{
+		LIns *q = ins->oprnd1();
+
 #if defined NANOJIT_IA32
 		if (!avmplus::AvmCore::use_sse2())
 		{
-			return false;
+			Register rr = prepResultReg(ins, GpRegs);
+			int d = findMemFor(q);
+			LD(rr, d, FP);
 		}
+		else
 #endif
-
-		Reservation *resv = getresv(ins);
-		Register rr = resv->reg;
-		if (rr == UnknownReg) {
-			// store quad in spill loc
-			int d = disp(resv);
-			freeRsrcOf(ins, false);
-			Register qr = findRegFor(q, XmmRegs);
-			SSE_MOVDm(d, FP, qr);
-		} else {
-			freeRsrcOf(ins, false);
-			Register qr = findRegFor(q, XmmRegs);
-			SSE_MOVD(rr,qr);
+		{
+			Reservation *resv = getresv(ins);
+			Register rr = resv->reg;
+			if (rr == UnknownReg) {
+				// store quad in spill loc
+				int d = disp(resv);
+				freeRsrcOf(ins, false);
+				Register qr = findRegFor(q, XmmRegs);
+				SSE_MOVDm(d, FP, qr);
+			} else {
+				freeRsrcOf(ins, false);
+				Register qr = findRegFor(q, XmmRegs);
+				SSE_MOVD(rr,qr);
+			}
 		}
-
-		return true;
 	}
 
 	void Assembler::asm_fneg(LInsp ins)
@@ -925,22 +1474,75 @@
 #endif
 	}
 
+    void Assembler::asm_arg(ArgSize sz, LInsp p, Register r)
+    {
+        if (sz == ARGSIZE_Q) 
+        {
+			// ref arg - use lea
+			if (r != UnknownReg)
+			{
+				// arg in specific reg
+				int da = findMemFor(p);
+				LEA(r, da, FP);
+			}
+			else
+			{
+				NanoAssert(0); // not supported
+			}
+		}
+        else if (sz == ARGSIZE_LO)
+		{
+			if (r != UnknownReg) {
+				// arg goes in specific register
+                if (p->isconst()) {
+					LDi(r, p->constval());
+                } else {
+            		Reservation* rA = getresv(p);
+                    if (rA) {
+                        if (rA->reg == UnknownReg) {
+                            // load it into the arg reg
+                            int d = findMemFor(p);
+                            if (p->isop(LIR_alloc)) {
+                                LEA(r, d, FP);
+                            } else {
+                                LD(r, d, FP);
+                            }
+                        } else {
+                            // it must be in a saved reg
+                            MR(r, rA->reg);
+                        }
+                    } 
+                    else {
+                        // this is the last use, so fine to assign it
+                        // to the scratch reg, it's dead after this point.
+    					findSpecificRegFor(p, r);
+                    }
+                }
+			}
+            else {
+				asm_pusharg(p);
+			}
+		}
+        else
+		{
+            NanoAssert(sz == ARGSIZE_F);
+			asm_farg(p);
+		}
+    }
+
 	void Assembler::asm_pusharg(LInsp p)
 	{
 		// arg goes on stack
 		Reservation* rA = getresv(p);
-		if (rA == 0)
+		if (rA == 0 && p->isconst())
 		{
-			if (p->isconst())
-			{
-				// small const we push directly
-				PUSHi(p->constval());
-			}
-			else
-			{
-				Register ra = findRegFor(p, GpRegs);
-				PUSHr(ra);
-			}
+			// small const we push directly
+			PUSHi(p->constval());
+		}
+		else if (rA == 0 || p->isop(LIR_alloc))
+		{
+			Register ra = findRegFor(p, GpRegs);
+			PUSHr(ra);
 		}
 		else if (rA->reg == UnknownReg)
 		{
@@ -955,14 +1557,16 @@
 	void Assembler::asm_farg(LInsp p)
 	{
 #if defined NANOJIT_IA32
+        NanoAssert(p->isQuad());
 		Register r = findRegFor(p, FpRegs);
 		if (rmask(r) & XmmRegs) {
 			SSE_STQ(0, SP, r); 
 		} else {
 			FSTPQ(0, SP);
 		}
-		PUSHr(ECX); // 2*pushr is smaller than sub
-		PUSHr(ECX);
+        SUBi(ESP,8);
+		//PUSHr(ECX); // 2*pushr is smaller than sub
+		//PUSHr(ECX);
 #endif
 	}
 
@@ -997,7 +1601,10 @@
 				 */
 				ra = findRegFor(lhs, XmmRegs);
 			}
-			// else, rA already has a register assigned.
+            else {
+    			// rA already has a register assigned but maybe not from the allow set
+                ra = findRegFor(lhs, allow);
+            }
 
 			if (lhs == rhs)
 				rb = ra;
@@ -1190,6 +1797,75 @@
 		}
 	}
 
+    NIns * Assembler::asm_jmpcc(bool branchOnFalse, LIns *cond, NIns *targ)
+    {
+        LOpcode c = cond->opcode();
+        if (avmplus::AvmCore::use_sse2() && c != LIR_feq) {
+            LIns *lhs = cond->oprnd1();
+            LIns *rhs = cond->oprnd2();
+            if (c == LIR_flt) {
+                LIns *t = lhs; lhs = rhs; rhs = t;
+                c = LIR_fgt;
+            }
+            else if (c == LIR_fle) {
+                LIns *t = lhs; lhs = rhs; rhs = t;
+                c = LIR_fge;
+            }
+
+            if (c == LIR_fgt) {
+                if (branchOnFalse) { JNA(targ); } else { JA(targ); }
+            }
+            else { // if (c == LIR_fge)
+                if (branchOnFalse) { JNAE(targ); } else { JAE(targ); }
+            }
+            NIns *at = _nIns;
+            Reservation *rA, *rB;
+            findRegFor2(XmmRegs, lhs, rA, rhs, rB);
+            SSE_UCOMISD(rA->reg, rB->reg);
+            return at;
+        }
+
+    	if (branchOnFalse)
+			JP(targ);
+		else
+			JNP(targ);
+		NIns *at = _nIns;
+		asm_fcmp(cond);
+        return at;
+    }
+
+    void Assembler::asm_setcc(Register r, LIns *cond)
+    {
+        LOpcode c = cond->opcode();
+        if (avmplus::AvmCore::use_sse2() && c != LIR_feq) {
+    		MOVZX8(r,r);
+            LIns *lhs = cond->oprnd1();
+            LIns *rhs = cond->oprnd2();
+            if (c == LIR_flt) {
+                LIns *t = lhs; lhs = rhs; rhs = t;
+                SETA(r);
+            }
+            else if (c == LIR_fle) {
+                LIns *t = lhs; lhs = rhs; rhs = t;
+                SETAE(r);
+            }
+            else if (c == LIR_fgt) {
+                SETA(r);
+            }
+            else { // if (c == LIR_fge)
+                SETAE(r);
+            }
+            Reservation *rA, *rB;
+            findRegFor2(XmmRegs, lhs, rA, rhs, rB);
+            SSE_UCOMISD(rA->reg, rB->reg);
+            return;
+        }
+		// SETcc only sets low 8 bits, so extend 
+		MOVZX8(r,r);
+		SETNP(r);
+        asm_fcmp(cond);
+    }
+
 	void Assembler::asm_fcmp(LIns *cond)
 	{
 		LOpcode condop = cond->opcode();
@@ -1206,10 +1882,12 @@
 		    mask = 0x05;
         else if (condop == LIR_fge) {
             // swap, use le
+            condop = LIR_fle;
             LIns* t = lhs; lhs = rhs; rhs = t;
             mask = 0x41;
         } else { // if (condop == LIR_fgt)
             // swap, use lt
+            condop = LIR_flt;
             LIns* t = lhs; lhs = rhs; rhs = t;
 		    mask = 0x05;
         }
@@ -1227,7 +1905,8 @@
                 // nan check
                 Register r = findRegFor(lhs, XmmRegs);
                 SSE_UCOMISD(r, r);
-            } else {
+            } 
+            else {
 #if defined NANOJIT_IA32
                 evict(EAX);
                 TEST_AH(mask);
@@ -1384,5 +2063,18 @@
 		if (!_nIns)		 _nIns	   = pageAlloc();
 		if (!_nExitIns)  _nExitIns = pageAlloc(true);
 	}
+	
+	// enough room for n bytes
+    void Assembler::underrunProtect(int n)
+    {
+        NIns *eip = this->_nIns;
+        Page *p = (Page*)pageTop(eip-1);
+        NIns *top = (NIns*) &p->code[0];
+        if (eip - n < top) {
+			_nIns = pageAlloc(_inExit);
+            JMP(eip);
+        }
+    }
+	
 	#endif /* FEATURE_NANOJIT */
 }
diff -r 17e9560465b0 js/src/nanojit/Nativei386.h
--- a/js/src/nanojit/Nativei386.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/nanojit/Nativei386.h	Thu Oct 30 05:41:45 2008 -0400
@@ -101,6 +101,7 @@
 
 	typedef int RegisterMask;
 
+	static const int NumSavedRegs = 3;
 	static const RegisterMask SavedRegs = 1<<EBX | 1<<EDI | 1<<ESI;
 	static const RegisterMask GpRegs = SavedRegs | 1<<EAX | 1<<ECX | 1<<EDX;
     static const RegisterMask XmmRegs = 1<<XMM0|1<<XMM1|1<<XMM2|1<<XMM3|1<<XMM4|1<<XMM5|1<<XMM6|1<<XMM7;
@@ -132,23 +133,12 @@
 		bool pad[3];\
 		void nativePageReset();\
 		void nativePageSetup();\
-        void asm_farg(LInsp);
+        void underrunProtect(int);\
+        void asm_farg(LInsp);\
+        void asm_align_code();
 		
 	#define swapptrs()  { NIns* _tins = _nIns; _nIns=_nExitIns; _nExitIns=_tins; }
 		
-	// enough room for n bytes
-	#define underrunProtect(n)									\
-		{														\
-			intptr_t u = n + sizeof(PageHeader)/sizeof(NIns) + 5; \
-			if ( !samepage(_nIns-u,_nIns-1) )					\
-			{													\
-				NIns *tt = _nIns; \
-				_nIns = pageAlloc(_inExit);						\
-				int d = tt-_nIns; \
-				JMP_long_nochk_offset(d);			\
-			}													\
-		}														\
-
 #define IMM32(i)	\
 	_nIns -= 4;		\
 	*((int32_t*)_nIns) = (int32_t)(i)
@@ -171,8 +161,11 @@
  		}
 
 #define MODRMm(r,d,b) \
-		NanoAssert(unsigned(r)<8 && unsigned(b)<8); \
- 		if ((b) == ESP) { \
+		NanoAssert(unsigned(r)<8 && ((b)==UnknownReg || unsigned(b)<8)); \
+        if ((b) == UnknownReg) {\
+            IMM32(d);\
+            *(--_nIns) = (uint8_t) (0<<6 | (r)<<3 | 5);\
+        } else if ((b) == ESP) { \
  			MODRMs(r, d, b, 0, (Register)4); \
  		} \
 		else if ( (d) == 0 && (b) != EBP) { \
@@ -344,7 +337,7 @@
 
 #define ST(base,disp,reg) do {  \
 	ALUm(0x89,reg,disp,base);	\
-	asm_output3("mov %d(%s),%s",disp,gpn(base),gpn(reg)); } while(0)
+    asm_output3("mov %d(%s),%s",disp,base==UnknownReg?"0":gpn(base),gpn(reg)); } while(0)
 
 #define STi(base,disp,imm)	do { \
 	underrunProtect(12);	\
@@ -409,6 +402,7 @@
 	underrunProtect(5);	\
 	intptr_t tt = (intptr_t)t - (intptr_t)_nIns;	\
 	JMP_long_nochk_offset(tt);	\
+    verbose_only( verbose_outputf("        %p:",_nIns); ) \
 	} while(0)
 
 #define JMP(t)		do { 	\
@@ -426,10 +420,6 @@
 
 #define JMPc 0xe9
 		
-#define JMP_long_placeholder()	do {\
-	underrunProtect(5);				\
-	JMP_long_nochk_offset(0xffffffff); } while(0)
-	
 // this should only be used when you can guarantee there is enough room on the page
 #define JMP_long_nochk_offset(o) do {\
 		verbose_only( NIns* next = _nIns; (void)next; ) \
@@ -497,7 +487,7 @@
     *(--_nIns) = 0x10;\
     *(--_nIns) = 0x0f;\
     *(--_nIns) = 0xf2;\
-    asm_output3("movsd %s,%p // =%f",gpn(r),daddr,*daddr); \
+    asm_output3("movsd %s,(#%p) // =%f",gpn(r),(void*)daddr,*daddr); \
     } while(0)
 
 #define STSD(d,b,r)do {     \
@@ -539,61 +529,70 @@
     } while(0)
 
 #define SSE_MOVSD(rd,rs) do{ \
+    NanoAssert(_is_xmm_reg_(rd) && _is_xmm_reg_(rs));\
     SSE(0xf20f10, (rd)&7, (rs)&7); \
     asm_output2("movsd %s,%s",gpn(rd),gpn(rs)); \
     } while(0)
 
 #define SSE_MOVDm(d,b,xrs) do {\
+    NanoAssert(_is_xmm_reg_(xrs) && _is_gp_reg_(b));\
     SSEm(0x660f7e, (xrs)&7, d, b);\
     asm_output3("movd %d(%s),%s", d, gpn(b), gpn(xrs));\
     } while(0)
 
 #define SSE_ADDSD(rd,rs) do{ \
+    NanoAssert(_is_xmm_reg_(rd) && _is_xmm_reg_(rs));\
     SSE(0xf20f58, (rd)&7, (rs)&7); \
     asm_output2("addsd %s,%s",gpn(rd),gpn(rs)); \
     } while(0)
 
 #define SSE_ADDSDm(r,addr)do {     \
     underrunProtect(8); \
+    NanoAssert(_is_xmm_reg_(r));\
 	const double* daddr = addr; \
     IMM32(int32_t(daddr));\
     *(--_nIns) = uint8_t(((r)&7)<<3|5); \
     *(--_nIns) = 0x58;\
     *(--_nIns) = 0x0f;\
     *(--_nIns) = 0xf2;\
-    asm_output3("addsd %s,%p // =%f",gpn(r),daddr,*daddr); \
+    asm_output3("addsd %s,%p // =%f",gpn(r),(void*)daddr,*daddr); \
     } while(0)
 
 #define SSE_SUBSD(rd,rs) do{ \
+    NanoAssert(_is_xmm_reg_(rd) && _is_xmm_reg_(rs));\
     SSE(0xf20f5c, (rd)&7, (rs)&7); \
     asm_output2("subsd %s,%s",gpn(rd),gpn(rs)); \
     } while(0)
 #define SSE_MULSD(rd,rs) do{ \
+    NanoAssert(_is_xmm_reg_(rd) && _is_xmm_reg_(rs));\
     SSE(0xf20f59, (rd)&7, (rs)&7); \
     asm_output2("mulsd %s,%s",gpn(rd),gpn(rs)); \
     } while(0)
 #define SSE_DIVSD(rd,rs) do{ \
+    NanoAssert(_is_xmm_reg_(rd) && _is_xmm_reg_(rs));\
     SSE(0xf20f5e, (rd)&7, (rs)&7); \
     asm_output2("divsd %s,%s",gpn(rd),gpn(rs)); \
     } while(0)
 #define SSE_UCOMISD(rl,rr) do{ \
+    NanoAssert(_is_xmm_reg_(rl) && _is_xmm_reg_(rr));\
     SSE(0x660f2e, (rl)&7, (rr)&7); \
     asm_output2("ucomisd %s,%s",gpn(rl),gpn(rr)); \
     } while(0)
 
 #define CVTSI2SDm(xr,d,b) do{ \
+    NanoAssert(_is_xmm_reg_(xr) && _is_gp_reg_(b));\
     SSEm(0xf20f2a, (xr)&7, (d), (b)); \
     asm_output3("cvtsi2sd %s,%d(%s)",gpn(xr),(d),gpn(b)); \
     } while(0)
 
 #define SSE_XORPD(r, maskaddr) do {\
-    underrunProtect(8); \
+	underrunProtect(8); \
     IMM32(maskaddr);\
     *(--_nIns) = uint8_t(((r)&7)<<3|5); \
     *(--_nIns) = 0x57;\
     *(--_nIns) = 0x0f;\
     *(--_nIns) = 0x66;\
-    asm_output2("xorpd %s,[0x%p]",gpn(r),(maskaddr));\
+    asm_output2("xorpd %s,[0x%p]",gpn(r),(void*)(maskaddr));\
     } while(0)
 
 #define SSE_XORPDr(rd,rs) do{ \
@@ -657,6 +656,7 @@
 #define FLDr(r)		do { FPU(0xd9c0,r);				asm_output1("fld %s",fpn(r)); fpu_push(); } while(0)
 #define EMMS()		do { FPUc(0x0f77);				asm_output("emms"); } while (0)
 
+// standard direct call
 #define CALL(c)	do { \
   underrunProtect(5);					\
   int offset = (c->_address) - ((int)_nIns); \
@@ -666,5 +666,14 @@
   debug_only(if ((c->_argtypes&3)==ARGSIZE_F) fpu_push();)\
 } while (0)
 
+// indirect call thru register
+#define CALLr(c,r)	do { \
+  underrunProtect(2);\
+  ALU(0xff, 2, (r));\
+  verbose_only(asm_output1("call %s",gpn(r));) \
+  debug_only(if ((c->_argtypes&3)==ARGSIZE_F) fpu_push();)\
+} while (0)
+
+
 }
 #endif // __nanojit_Nativei386__
diff -r 17e9560465b0 js/src/nanojit/RegAlloc.cpp
--- a/js/src/nanojit/RegAlloc.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/nanojit/RegAlloc.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -49,7 +49,7 @@
 	{
 		free = 0;
 		used = 0;
-		memset(active, 0, NJ_MAX_REGISTERS * sizeof(LIns*));
+		memset(active, 0, (LastReg+1) * sizeof(LIns*));
 	}
 
 	bool RegAlloc::isFree(Register r) 
@@ -72,10 +72,17 @@
 
 	void RegAlloc::addActive(Register r, LIns* v)
 	{
-		//addActiveCount++;
+		//  Count++;
 		NanoAssert(v && r != UnknownReg && active[r] == NULL );
 		active[r] = v;
+        useActive(r);
 	}
+
+    void RegAlloc::useActive(Register r)
+    {
+        NanoAssert(r != UnknownReg && active[r] != NULL);
+        usepri[r] = priority++;
+    }
 
 	void RegAlloc::removeActive(Register r)
 	{
@@ -87,12 +94,6 @@
 		active[r] = NULL;
 	}
 
-	LIns* RegAlloc::getActive(Register r)
-	{
-		NanoAssert(r != UnknownReg);
-		return active[r];
-	}
-
 	void RegAlloc::retire(Register r)
 	{
 		NanoAssert(r != UnknownReg);
@@ -101,30 +102,27 @@
 		free |= rmask(r);
 	}
 
-	// scan table for instruction with longest span
-	LIns* Assembler::findVictim(RegAlloc &regs, RegisterMask allow, RegisterMask prefer)
+	// scan table for instruction with the lowest priority, meaning it is used
+    // furthest in the future.
+	LIns* Assembler::findVictim(RegAlloc &regs, RegisterMask allow)
 	{
-		NanoAssert(allow != 0 && (allow&prefer)==prefer);
-		LIns *i, *a=0, *p = 0;
-        int acost=10, pcost=10;
+		NanoAssert(allow != 0);
+		LIns *i, *a=0;
+        int allow_pri = 0x7fffffff;
 		for (Register r=FirstReg; r <= LastReg; r = nextreg(r))
 		{
             if ((allow & rmask(r)) && (i = regs.getActive(r)) != 0)
             {
-                int cost = getresv(i)->cost;
-                if (!a || cost < acost || cost == acost && nbr(i) < nbr(a)) {
+                int pri = canRemat(i) ? 0 : regs.getPriority(r);
+                if (!a || pri < allow_pri) {
                     a = i;
-                    acost = cost;
-                }
-                if (prefer & rmask(r)) {
-                    if (!p || cost < pcost || cost == pcost && nbr(i) < nbr(p)) {
-                        p = i;
-                        pcost = cost;
-                    }
+                    allow_pri = pri;
                 }
 			}
 		}
-        return acost < pcost ? a : p;
+
+        NanoAssert(a != 0);
+        return a;
 	}
 
 	#ifdef  NJ_VERBOSE
@@ -133,7 +131,7 @@
 		if (!frag || !frag->lirbuf)
 			return;
 		LirNameMap *names = frag->lirbuf->names;
-		for(int i=0; i<NJ_MAX_REGISTERS; i++)
+		for(int i=0; i<(LastReg+1); i++)
 		{
 			LIns* ins = regs.active[i];
 			Register r = (Register)i;
diff -r 17e9560465b0 js/src/nanojit/RegAlloc.h
--- a/js/src/nanojit/RegAlloc.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/nanojit/RegAlloc.h	Thu Oct 30 05:41:45 2008 -0400
@@ -51,15 +51,28 @@
 	class RegAlloc MMGC_SUBCLASS_DECL
 	{
 		public:
-			RegAlloc() {}
+            RegAlloc() : free(0), used(0), priority(0) {}
 			void	clear();
 			bool	isFree(Register r); 
 			void	addFree(Register r);
 			void	removeFree(Register r);
 			void	addActive(Register r, LIns* ins);
+            void    useActive(Register r);
 			void	removeActive(Register r);
-			LIns*	getActive(Register r); 
 			void	retire(Register r);
+            bool    isValid() {
+                return (free|used) != 0;
+            }
+
+            int32_t getPriority(Register r) {
+                NanoAssert(r != UnknownReg && active[r]);
+                return usepri[r];
+            }
+
+	        LIns* getActive(Register r) {
+		        NanoAssert(r != UnknownReg);
+		        return active[r];
+	        }
 
 			debug_only( uint32_t	countFree(); )
 			debug_only( uint32_t	countActive(); )
@@ -68,11 +81,11 @@
 			debug_only( uint32_t	count; )
 			debug_only( RegisterMask managed; )    // bitfield of 0..NJ_MAX_REGISTERS denoting which are under our management                     
 
-			// RegisterMask is a 32-bit value, so we can never have more than 32 active.
-			// hardcode 32 here in case we have non-contiguous register numbers
-			LIns*	active[32];  // active[r] = OP that defines r
+			LIns*	active[LastReg + 1];  // active[r] = OP that defines r
+			int32_t usepri[LastReg + 1]; // used priority. lower = more likely to spill.
 			RegisterMask	free;
 			RegisterMask	used;
+            int32_t         priority;
 
 			verbose_only( static void formatRegisters(RegAlloc& regs, char* s, Fragment*); )
 
diff -r 17e9560465b0 js/src/nanojit/avmplus.h
--- a/js/src/nanojit/avmplus.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/nanojit/avmplus.h	Thu Oct 30 05:41:45 2008 -0400
@@ -175,45 +175,39 @@
 	    OVERFLOW_EXIT
 	};
 	
-	struct SideExit
-	{
+    class LIns;
+
+    struct SideExit;
+    
+    typedef struct GuardRecord 
+    {
+        void *jmp;
+        GuardRecord* next;
+        SideExit* exit;
+    };
+    
+    typedef struct SideExit
+    {
+        GuardRecord* guards;
+        Fragment *from;
+        Fragment *target;
         intptr_t ip_adj;
         intptr_t sp_adj;
         intptr_t rp_adj;
-        Fragment *target;
-        Fragment *from;
         int32_t calldepth;
         uint32 numGlobalSlots;
         uint32 numStackSlots;
         uint32 numStackSlotsBelowCurrentFrame;
-        uint8 *typeMap;
         ExitType exitType;
-#if defined NJ_VERBOSE
-		uint32_t sid;
-#endif
+        
+        void addGuard(GuardRecord* lr) 
+        {
+            lr->next = guards;
+            guards = lr;
+        }
 	};
-
-	class LIns;
-
-	struct GuardRecord
-	{
-		Fragment *target;
-		Fragment *from;
-		void *jmp;
-		void *origTarget;
-		SideExit *exit;
-		GuardRecord *outgoing;
-		GuardRecord *next;
-		LIns *guard;
-		int32_t calldepth;
-#if defined NJ_VERBOSE
-		uint32_t compileNbr;
-		uint32_t sid;
-#endif
-	};
-
-	#define GuardRecordSize(g) sizeof(GuardRecord)
-    #define SideExitSize(e) sizeof(SideExit)
+    
+    static inline uint8* getTypeMap(SideExit* exit) { return (uint8*)(exit + 1); }
 }
 
 class GC;
@@ -326,6 +320,8 @@
 
 #define DWB(x) x
 #define DRCWB(x) x
+#define WB(gc, container, addr, value) do { *(addr) = (value); } while(0)
+#define WBRC(gc, container, addr, value) do { *(addr) = (value); } while(0)
 
 #define MMGC_MEM_TYPE(x)
 
@@ -341,9 +337,9 @@
         JSContext *cx; /* current VM context handle */
         void* eos; /* first unusable word after the native stack */
         void* eor; /* first unusable word after the call stack */
-        nanojit::GuardRecord* lastTreeExitGuard; /* guard we exited on during a tree call */
-        nanojit::GuardRecord* lastTreeCallGuard; /* guard we want to grow from if the tree
-                                                    call exit guard mismatched */
+        nanojit::SideExit* lastTreeExitGuard; /* guard we exited on during a tree call */
+        nanojit::SideExit* lastTreeCallGuard; /* guard we want to grow from if the tree
+                                                 call exit guard mismatched */
         void* rpAtLastTreeCall; /* value of rp at innermost tree call guard */
     };
 
diff -r 17e9560465b0 js/src/nanojit/nanojit.h
--- a/js/src/nanojit/nanojit.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/nanojit/nanojit.h	Thu Oct 30 05:41:45 2008 -0400
@@ -42,6 +42,8 @@
 #include <stddef.h>
 #include "avmplus.h"
 
+#ifdef FEATURE_NANOJIT
+
 #ifdef AVMPLUS_IA32
 #define NANOJIT_IA32
 #elif AVMPLUS_ARM
@@ -72,6 +74,8 @@
 	typedef avmplus::SortedMap<SideExit*,RegAlloc*,avmplus::LIST_GCObjects> RegAllocMap;
 	typedef avmplus::List<LIns*,avmplus::LIST_NonGCObjects>	InsList;
 	typedef avmplus::List<char*, avmplus::LIST_GCObjects> StringList;
+
+    const uint32_t MAXARGS = 8;
 
 	#if defined(_MSC_VER) && _MSC_VER < 1400
 		static void NanoAssertMsgf(bool a,const char *f,...) {}
@@ -113,12 +117,12 @@
 	#define verbose_output						if (verbose_enabled()) Assembler::output
 	#define verbose_outputf						if (verbose_enabled()) Assembler::outputf
 	#define verbose_enabled()					(_verbose)
-	#define verbose_only(x)						x
+	#define verbose_only(...)					__VA_ARGS__
 #else
 	#define verbose_output
 	#define verbose_outputf
 	#define verbose_enabled()
-	#define verbose_only(x)
+	#define verbose_only(...)
 #endif /*NJ_VERBOSE*/
 
 #ifdef _DEBUG
@@ -172,4 +176,5 @@
 #include "Assembler.h"
 #include "TraceTreeDrawer.h"
 
+#endif // FEATURE_NANOJIT
 #endif // __nanojit_h__
diff -r 17e9560465b0 js/src/rules.mk
--- a/js/src/rules.mk	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,206 +0,0 @@
-# -*- Mode: makefile -*-
-# 
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-# 
-# The Original Code is Mozilla Communicator client code, released
-# March 31, 1998.
-# 
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998-1999
-# the Initial Developer. All Rights Reserved.
-# 
-# Contributor(s):
-#   Michael Ang <mang@subcarrier.org>
-# 
-# Alternatively, the contents of this file may be used under the terms of
-# either of the GNU General Public License Version 2 or later (the "GPL"),
-# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-# 
-# ***** END LICENSE BLOCK *****
-
-#
-# JSRef GNUmake makefile rules
-#
-
-ifdef USE_MSVC
-LIB_OBJS  = $(addprefix $(OBJDIR)/, $(LIB_CPPFILES:.cpp=.obj))
-PROG_OBJS = $(addprefix $(OBJDIR)/, $(PROG_CPPFILES:.cpp=.obj))
-else
-LIB_OBJS  = $(addprefix $(OBJDIR)/, $(LIB_CPPFILES:.cpp=.o))
-LIB_OBJS  += $(addprefix $(OBJDIR)/, $(LIB_ASFILES:.s=.o))
-PROG_OBJS = $(addprefix $(OBJDIR)/, $(PROG_CPPFILES:.cpp=.o))
-endif
-
-CPPFILES = $(LIB_CPPFILES) $(PROG_CPPFILES)
-OBJS   = $(LIB_OBJS) $(PROG_OBJS)
-
-ifdef USE_MSVC
-# TARGETS = $(LIBRARY)   # $(PROGRAM) not supported for MSVC yet
-TARGETS += $(SHARED_LIBRARY) $(PROGRAM)  # it is now
-else
-TARGETS += $(LIBRARY) $(SHARED_LIBRARY) $(PROGRAM) 
-endif
-
-all:
-	+$(LOOP_OVER_PREDIRS) 
-ifneq "$(strip $(TARGETS))" ""
-	$(MAKE) -f Makefile.ref $(TARGETS)
-endif
-	+$(LOOP_OVER_DIRS)
-
-$(OBJDIR)/%: %.cpp
-	@$(MAKE_OBJDIR)
-	$(CXX) -o $@ $(CFLAGS) $*.cpp $(LDFLAGS)
-
-# This rule must come before the rule with no dep on header
-$(OBJDIR)/%.o: %.cpp %.h
-	@$(MAKE_OBJDIR)
-	$(CXX) -o $@ -c $(CFLAGS) $*.cpp
-
-$(OBJDIR)/jsinterp.o: jsinterp.cpp jsinterp.h
-	@$(MAKE_OBJDIR)
-	$(CXX) -o $@ -c $(INTERP_CFLAGS) jsinterp.cpp
-
-$(OBJDIR)/jsbuiltins.o: jsbuiltins.cpp jsinterp.h
-	@$(MAKE_OBJDIR)
-	$(CXX) -o $@ -c $(BUILTINS_CFLAGS) jsbuiltins.cpp
-
-$(OBJDIR)/%.o: %.cpp
-	@$(MAKE_OBJDIR)
-	$(CXX) -o $@ -c $(CFLAGS) $*.cpp
-
-$(OBJDIR)/%.o: %.s
-	@$(MAKE_OBJDIR)
-	$(AS) -o $@ $(ASFLAGS) $*.s
-
-# This rule must come before rule with no dep on header
-$(OBJDIR)/%.obj: %.cpp %.h
-	@$(MAKE_OBJDIR)
-	$(CXX) -Fo$(OBJDIR)/ -c $(CFLAGS) $(JSDLL_CFLAGS) $*.cpp
-
-$(OBJDIR)/jsinterp.obj: jsinterp.cpp jsinterp.h
-	@$(MAKE_OBJDIR)
-	$(CXX) -Fo$(OBJDIR)/ -c $(INTERP_CFLAGS) $(JSDLL_CFLAGS) jsinterp.cpp
-
-$(OBJDIR)/jsbuiltins.obj: jsbuiltins.cpp jsinterp.h
-	@$(MAKE_OBJDIR)
-	$(CXX) -Fo$(OBJDIR)/ -c $(BUILTINS_CFLAGS) $(JSDLL_CFLAGS) jsbuiltins.c
-
-$(OBJDIR)/%.obj: %.cpp
-	@$(MAKE_OBJDIR)
-	$(CXX) -Fo$(OBJDIR)/ -c $(CFLAGS) $(JSDLL_CFLAGS) $*.cpp
-
-$(OBJDIR)/js.obj: js.cpp
-	@$(MAKE_OBJDIR)
-	$(CXX) -Fo$(OBJDIR)/ -c $(CFLAGS) $<
-
-ifeq ($(OS_ARCH),OS2)
-$(LIBRARY): $(LIB_OBJS)
-	$(AR) $@ $? $(AR_OS2_SUFFIX)
-	$(RANLIB) $@
-else
-ifdef USE_MSVC
-$(SHARED_LIBRARY): $(LIB_OBJS)
-	link.exe $(LIB_LINK_FLAGS) /base:0x61000000 $(OTHER_LIBS) \
-	    /out:"$@" /pdb:none\
-	    /implib:"$(OBJDIR)/$(@F:.dll=.lib)" $^
-else
-$(LIBRARY): $(LIB_OBJS)
-	$(AR) rv $@ $?
-	$(RANLIB) $@
-
-$(SHARED_LIBRARY): $(LIB_OBJS)
-	$(MKSHLIB) -o $@ $(LIB_OBJS) $(LDFLAGS) $(OTHER_LIBS)
-endif
-endif
-
-# Java stuff
-$(CLASSDIR)/$(OBJDIR)/$(JARPATH)/%.class: %.java
-	mkdir -p $(@D)
-	$(JAVAC) $(JAVAC_FLAGS) $<
-
-define MAKE_OBJDIR
-if test ! -d $(@D); then rm -rf $(@D); mkdir -p $(@D); fi
-endef
-
-ifdef DIRS
-LOOP_OVER_DIRS		=					\
-	@for d in $(DIRS); do					\
-		if test -d $$d; then				\
-			set -e;			\
-			echo "cd $$d; $(MAKE) -f Makefile.ref $@"; 		\
-			cd $$d; $(MAKE) -f Makefile.ref $@; cd ..;	\
-			set +e;					\
-		else						\
-			echo "Skipping non-directory $$d...";	\
-		fi;						\
-	done
-endif
-
-ifdef PREDIRS
-LOOP_OVER_PREDIRS	=					\
-	@for d in $(PREDIRS); do				\
-		if test -d $$d; then				\
-			set -e;			\
-			echo "cd $$d; $(MAKE) -f Makefile.ref $@"; 		\
-			cd $$d; $(MAKE) -f Makefile.ref $@; cd ..;	\
-			set +e;					\
-		else						\
-			echo "Skipping non-directory $$d...";	\
-		fi;						\
-	done
-endif
-
-export:
-	+$(LOOP_OVER_PREDIRS)	
-	mkdir -p $(DIST)/include $(DIST)/$(LIBDIR) $(DIST)/bin
-ifneq "$(strip $(HFILES))" ""
-	$(CP) $(HFILES) $(DIST)/include
-endif
-ifneq "$(strip $(LIBRARY))" ""
-	$(CP) $(LIBRARY) $(DIST)/$(LIBDIR)
-endif
-ifneq "$(strip $(JARS))" ""
-	$(CP) $(JARS) $(DIST)/$(LIBDIR)
-endif
-ifneq "$(strip $(SHARED_LIBRARY))" ""
-	$(CP) $(SHARED_LIBRARY) $(DIST)/$(LIBDIR)
-endif
-ifneq "$(strip $(PROGRAM))" ""
-	$(CP) $(PROGRAM) $(DIST)/bin
-endif
-	+$(LOOP_OVER_DIRS)
-
-clean:
-	+$(LOOP_OVER_PREDIRS)
-	rm -rf $(OBJS) $(GARBAGE)
-
-clobber:
-	+$(LOOP_OVER_PREDIRS)
-	rm -rf $(OBJS) $(TARGETS) $(DEPENDENCIES) $(GARBAGE)
-	if test -d $(OBJDIR); then rmdir $(OBJDIR); fi
-
-tar:
-	tar cvf $(TARNAME) $(TARFILES)
-	gzip $(TARNAME)
-
diff -r 17e9560465b0 js/src/trace-test.js
--- a/js/src/trace-test.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/trace-test.js	Thu Oct 30 05:41:45 2008 -0400
@@ -1,3 +1,4 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 /**
  * A number of the tests in this file depend on the setting of
  * HOTLOOP.  Define some constants up front, so they're easy to grep
@@ -1547,9 +1548,9 @@
 }
 testNestedExitStackOuter.expected = 81;
 testNestedExitStackOuter.jitstats = {
-    recorderStarted: 4,
+    recorderStarted: 3,
     recorderAborted: 0,
-    traceTriggered: 8
+    traceTriggered: 7
 };
 test(testNestedExitStackOuter);
 
@@ -2126,6 +2127,78 @@
 testReallyDeepNestedExit.expected = 198;
 test(testReallyDeepNestedExit);
 
+function testRegExpTest() {
+    var r = /abc/;
+    var flag = false;
+    for (var i = 0; i < 10; ++i)
+	flag = r.test("abc");
+    return flag;
+}
+testRegExpTest.expected = true;
+test(testRegExpTest);
+
+function testNumToString() {
+    var r = [];
+    var d = 123456789;
+    for (var i = 0; i < 10; ++i) {
+	r = [
+	     d.toString(),
+	     (-d).toString(),
+	     d.toString(10),
+	     (-d).toString(10),
+	     d.toString(16),
+	     (-d).toString(16),
+	     d.toString(36),
+	     (-d).toString(36)
+        ];
+    }
+    return r.join(",");
+}
+testNumToString.expected = "123456789,-123456789,123456789,-123456789,75bcd15,-75bcd15,21i3v9,-21i3v9";
+test(testNumToString);
+
+function testSubstring() {
+    for (var i = 0; i < 5; ++i) {
+        actual = "".substring(5);
+    }
+    return actual;
+}
+testSubstring.expected = "";
+test(testSubstring);
+
+function testForInLoopChangeIteratorType() {
+    for(y in [0,1,2]) y = NaN;
+    (function(){ [].__proto__.u = void 0; for (let y in [5,6,7,8]) y = NaN; })()
+    return "ok";
+}
+testForInLoopChangeIteratorType.expected = "ok";
+test(testForInLoopChangeIteratorType);
+
+function testGrowDenseArray() {
+    var a = new Array();
+    for (var i = 0; i < 10; ++i)
+	a[i] |= 5;
+    return a.join(",");
+}
+testGrowDenseArray.expected = "5,5,5,5,5,5,5,5,5,5";
+test(testGrowDenseArray);
+
+function testCallProtoMethod() {
+    function X() { this.x = 1; }
+    X.prototype.getName = function () { return "X"; }
+
+    function Y() { this.x = 2; }
+    Y.prototype.getName = function() "Y";
+
+    var a = [new X, new X, new X, new X, new Y];
+    var s = '';
+    for (var i = 0; i < a.length; i++)
+        s += a[i].getName();
+    return s;
+}
+testCallProtoMethod.expected = 'XXXXY';
+test(testCallProtoMethod);
+
 /* Keep these at the end so that we can see the summary after the trace-debug spew. */
 print("\npassed:", passes.length && passes.join(","));
 print("\nFAILED:", fails.length && fails.join(","));
diff -r 17e9560465b0 js/src/xpconnect/loader/JSON.jsm
--- a/js/src/xpconnect/loader/JSON.jsm	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/xpconnect/loader/JSON.jsm	Thu Oct 30 05:41:45 2008 -0400
@@ -173,22 +173,6 @@
     const maybeHarmful = /[^,:{}\[\]0-9.\-+Eaeflnr-u \n\r\t]/;
     const jsonStrings = /"(\\.|[^"\\\n\r])*"/g;
     
-    const openEndedString = /"(\\.|[^"\\\n\r])*$/;
-    const maxStringLength = 1 << 16;
-    
-    // process the string in several slices when it's too big in order
-    // to prevent script stack space quote exhaustion (cf. bug 450633)
-    while (aString.length > maxStringLength) {
-      let slice = aString.substr(0, maxStringLength).replace(jsonStrings, "");
-      aString = aString.substr(maxStringLength);
-      if (openEndedString.test(slice)) {
-        slice = slice.replace(openEndedString, "");
-        aString = '"' + aString;
-      }
-      if (maybeHarmful.test(slice))
-        return false;
-    }
-    
     return !maybeHarmful.test(aString.replace(jsonStrings, ""));
   }
 };
diff -r 17e9560465b0 js/src/xpconnect/src/nsXPConnect.cpp
--- a/js/src/xpconnect/src/nsXPConnect.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/xpconnect/src/nsXPConnect.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -1067,7 +1067,7 @@
 }
 
 static JSClass xpcTempGlobalClass = {
-    "xpcTempGlobalClass", 0,
+    "xpcTempGlobalClass", JSCLASS_GLOBAL_FLAGS,
     JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,
     JS_EnumerateStub, TempGlobalResolve, JS_ConvertStub,   JS_FinalizeStub,
     JSCLASS_NO_OPTIONAL_MEMBERS
diff -r 17e9560465b0 js/src/xpconnect/tests/unit/test_json.js
--- a/js/src/xpconnect/tests/unit/test_json.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/js/src/xpconnect/tests/unit/test_json.js	Thu Oct 30 05:41:45 2008 -0400
@@ -128,11 +128,4 @@
   
   do_check_false(JSONModule.isMostlyHarmless('(function() { alert("P0wn3d!"); })()'));
   do_check_false(JSONModule.isMostlyHarmless('{ get a() { return "P0wn3d!"; } }'));
-  
-  // this string shouldn't cause a "script stack space quota is exhausted" error
-  let bigString = " ";
-  while (bigString.length < (1 << 22))
-    bigString += bigString;
-  
-  do_check_eq(JSONModule.fromString(toJSONString(bigString)), bigString);
 }
diff -r 17e9560465b0 layout/base/Makefile.in
--- a/layout/base/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/base/Makefile.in	Thu Oct 30 05:41:45 2008 -0400
@@ -129,7 +129,7 @@
 		nsFrameManager.cpp \
 		nsFrameTraversal.cpp \
 		nsGenConList.cpp \
-		nsImageLoadNotifier.cpp \
+		nsImageLoader.cpp \
 		nsLayoutDebugger.cpp \
 		nsLayoutHistoryState.cpp \
 		nsLayoutUtils.cpp \
@@ -172,6 +172,7 @@
 		-I$(srcdir)/../tables \
 		-I$(srcdir)/../printing \
 		-I$(srcdir)/../xul/base/src \
+		-I$(srcdir)/../xul/base/src/tree/src \
 		-I$(srcdir)/../../content/base/src \
 		-I$(srcdir)/../../content/events/src \
 		-I$(srcdir)/../../content/xbl/src \
@@ -191,6 +192,11 @@
         -I$(srcdir)/../svg/base/src
 endif
 
+ifdef MOZ_MEDIA
+LOCAL_INCLUDES += \
+        -I$(srcdir)/../../content/html/content/src
+endif
+
 CXXFLAGS += $(MOZ_CAIRO_CFLAGS)
 
 DEFINES += -D_IMPL_NS_LAYOUT
diff -r 17e9560465b0 layout/base/nsCSSColorUtils.cpp
--- a/layout/base/nsCSSColorUtils.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/base/nsCSSColorUtils.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -68,54 +68,10 @@
 
 #define MAX_BRIGHTNESS  254
 #define MAX_DARKNESS     0
- 
-void NS_Get3DColors(nscolor aResult[2], nscolor aBackgroundColor)
-{
-  int rb = NS_GET_R(aBackgroundColor);
-  int gb = NS_GET_G(aBackgroundColor);
-  int bb = NS_GET_B(aBackgroundColor);
-  
-  int brightness = NS_GetBrightness(rb,gb,bb);
-
-  int f0, f1;
-  if (brightness < COLOR_DARK_THRESHOLD) {
-    f0 = COLOR_DARK_BS_FACTOR;
-    f1 = COLOR_DARK_TS_FACTOR;
-  } else if (brightness > COLOR_LIGHT_THRESHOLD) {
-    f0 = COLOR_LITE_BS_FACTOR;
-    f1 = COLOR_LITE_TS_FACTOR;
-  } else {
-    f0 = COLOR_DARK_BS_FACTOR +
-      (brightness *
-       (COLOR_LITE_BS_FACTOR - COLOR_DARK_BS_FACTOR) / MAX_COLOR);
-    f1 = COLOR_DARK_TS_FACTOR +
-      (brightness *
-       (COLOR_LITE_TS_FACTOR - COLOR_DARK_TS_FACTOR) / MAX_COLOR);
-  }
-
-  int r = rb - (f0 * rb / 100);
-  int g = gb - (f0 * gb / 100);
-  int b = bb - (f0 * bb / 100);
-  aResult[0] = NS_RGB(r, g, b);
-  if ((r == rb) && (g == gb) && (b == bb)) {
-    aResult[0] = (aBackgroundColor == BLACK) ? DARK_GRAY : BLACK;
-  }
-
-  r = rb + (f1 * (MAX_COLOR - rb) / 100);
-  if (r > 255) r = 255;
-  g = gb + (f1 * (MAX_COLOR - gb) / 100);
-  if (g > 255) g = 255;
-  b = bb + (f1 * (MAX_COLOR - bb) / 100);
-  if (b > 255) b = 255;
-  aResult[1] = NS_RGB(r, g, b);
-  if ((r == rb) && (g == gb) && (b == bb)) {
-    aResult[1] = (aBackgroundColor == WHITE) ? LIGHT_GRAY : WHITE;
-  }
-}
 
 void NS_GetSpecial3DColors(nscolor aResult[2],
-											   nscolor aBackgroundColor,
-											   nscolor aBorderColor)
+                           nscolor aBackgroundColor,
+                           nscolor aBorderColor)
 {
 
   PRUint8 f0, f1;
@@ -124,6 +80,8 @@
   PRUint8 rb = NS_GET_R(aBorderColor);
   PRUint8 gb = NS_GET_G(aBorderColor);
   PRUint8 bb = NS_GET_B(aBorderColor);
+
+  PRUint8 a = NS_GET_A(aBorderColor);
 
   // This needs to be optimized.
   // Calculating background brightness again and again is 
@@ -169,12 +127,12 @@
   r = rb - (f0 * rb / 100);
   g = gb - (f0 * gb / 100);
   b = bb - (f0 * bb / 100);
-  aResult[0] = NS_RGB(r, g, b);
+  aResult[0] = NS_RGBA(r, g, b, a);
 
   r = rb + (f1 * (MAX_COLOR - rb) / 100);
   g = gb + (f1 * (MAX_COLOR - gb) / 100);
   b = bb + (f1 * (MAX_COLOR - bb) / 100);
-  aResult[1] = NS_RGB(r, g, b);
+  aResult[1] = NS_RGBA(r, g, b, a);
 }
 
 int NS_GetBrightness(PRUint8 aRed, PRUint8 aGreen, PRUint8 aBlue)
@@ -203,14 +161,14 @@
 
 // Function to convert RGB color space into the HSV colorspace
 // Hue is the primary color defined from 0 to 359 degrees
-// Saturation is defined from 0 to 255.  The higher the number.. the deeper the color
-// Value is the brightness of the color. 0 is black, 255 is white.  
-void
-NS_RGB2HSV(nscolor aColor,PRUint16 &aHue,PRUint16 &aSat,PRUint16 &aValue)
+// Saturation is defined from 0 to 255.  The higher the number.. the deeper
+// the color Value is the brightness of the color. 0 is black, 255 is white.
+void NS_RGB2HSV(nscolor aColor, PRUint16 &aHue, PRUint16 &aSat,
+                PRUint16 &aValue, PRUint8 &aAlpha)
 {
-PRUint8  r,g,b;
-PRInt16  delta,min,max,r1,b1,g1;
-float    hue;
+  PRUint8 r, g, b;
+  PRInt16 delta, min, max, r1, b1, g1;
+  float   hue;
 
   r = NS_GET_R(aColor);
   g = NS_GET_G(aColor);
@@ -261,18 +219,20 @@
   }
 
   aHue = (PRUint16)hue;
+
+  aAlpha = NS_GET_A(aColor);
 }
 
 // Function to convert HSV color space into the RGB colorspace
 // Hue is the primary color defined from 0 to 359 degrees
-// Saturation is defined from 0 to 255.  The higher the number.. the deeper the color
-// Value is the brightness of the color. 0 is black, 255 is white.  
-void
-NS_HSV2RGB(nscolor &aColor,PRUint16 aHue,PRUint16 aSat,PRUint16 aValue)
+// Saturation is defined from 0 to 255.  The higher the number.. the deeper
+// the color Value is the brightness of the color. 0 is black, 255 is white.
+void NS_HSV2RGB(nscolor &aColor, PRUint16 aHue, PRUint16 aSat, PRUint16 aValue,
+                PRUint8 aAlpha)
 {
-PRUint16  r=0,g=0,b=0;
-PRUint16  i,p,q,t;
-double    h,f,percent;
+  PRUint16  r = 0, g = 0, b = 0;
+  PRUint16  i, p, q, t;
+  double    h, f, percent;
 
   if ( aSat == 0 ){
     // achromatic color, no hue is defined
@@ -308,5 +268,5 @@
       case 5: r = aValue; g = p; b = q;break;
     }
   }
-  aColor = NS_RGB(r,g,b);
+  aColor = NS_RGBA(r, g, b, aAlpha);
 }
diff -r 17e9560465b0 layout/base/nsCSSColorUtils.h
--- a/layout/base/nsCSSColorUtils.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/base/nsCSSColorUtils.h	Thu Oct 30 05:41:45 2008 -0400
@@ -49,11 +49,6 @@
 #define NS_LUMINOSITY_DIFFERENCE(a, b) \
           PR_ABS(NS_GetLuminosity(a) - NS_GetLuminosity(b))
 
-// Weird color computing code stolen from winfe which was stolen
-// from the xfe which was written originally by Eric Bina. So there.
-// To determin colors based on the background brightness
-void NS_Get3DColors(nscolor aResult[2], nscolor aBackgroundColor);
-
 // To determine colors based on the background brightness and border color
 void NS_GetSpecial3DColors(nscolor aResult[2],
                            nscolor aBackgroundColor,
@@ -66,9 +61,12 @@
 // The range of return value is 0 to 255000.
 PRInt32 NS_GetLuminosity(nscolor aColor);
 
-// function to convert from RGB color space to HSV color space 
-void NS_RGB2HSV(nscolor aColor,PRUint16 &aHue,PRUint16 &aSat,PRUint16 &aValue);
-// function to convert from HSV color space to RGB color space 
-void NS_HSV2RGB(nscolor &aColor,PRUint16 aHue,PRUint16 aSat,PRUint16 aValue);
+// function to convert from RGBA color space to HSVA color space 
+void NS_RGB2HSV(nscolor aColor, PRUint16 &aHue, PRUint16 &aSat,
+                PRUint16 &aValue, PRUint8 &aAlpha);
+
+// function to convert from HSVA color space to RGBA color space 
+void NS_HSV2RGB(nscolor &aColor, PRUint16 aHue, PRUint16 aSat, PRUint16 aValue,
+                PRUint8 aAlpha);
 
 #endif
diff -r 17e9560465b0 layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/base/nsCSSFrameConstructor.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -3287,7 +3287,11 @@
       aTag == nsGkAtoms::spacer ||
       aTag == nsGkAtoms::button ||
       aTag == nsGkAtoms::isindex ||
-      aTag == nsGkAtoms::canvas;
+      aTag == nsGkAtoms::canvas ||
+#if defined(MOZ_MEDIA)
+      aTag == nsGkAtoms::video ||
+#endif
+      PR_FALSE;
   }
 
 
@@ -8686,9 +8690,8 @@
     xulElement->GetBoxObject(getter_AddRefs(boxObject));
     nsCOMPtr<nsPIListBoxObject> listBoxObject = do_QueryInterface(boxObject);
     if (listBoxObject) {
-      nsIListBoxObject* listboxBody = listBoxObject->GetListBoxBody(PR_FALSE);
-      if (listboxBody) {
-        nsListBoxBodyFrame *listBoxBodyFrame = static_cast<nsListBoxBodyFrame*>(listboxBody);
+      nsListBoxBodyFrame* listBoxBodyFrame = listBoxObject->GetListBoxBody(PR_FALSE);
+      if (listBoxBodyFrame) {
         if (aOperation == CONTENT_REMOVED) {
           // Except if we have an aChildFrame and its parent is not the right
           // thing, then we don't do this.  Pseudo frames are so much fun....
diff -r 17e9560465b0 layout/base/nsCSSRendering.cpp
--- a/layout/base/nsCSSRendering.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/base/nsCSSRendering.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -364,31 +364,6 @@
     break;
   }
   return theColor;
-}
-
-nscolor
-nsCSSRendering::TransformColor(nscolor  aMapColor,PRBool aNoBackGround)
-{
-PRUint16  hue,sat,value;
-nscolor   newcolor;
-
-  newcolor = aMapColor;
-  if (PR_TRUE == aNoBackGround){
-    // convert the RBG to HSV so we can get the lightness (which is the v)
-    NS_RGB2HSV(newcolor,hue,sat,value);
-    // The goal here is to send white to black while letting colored
-    // stuff stay colored... So we adopt the following approach.
-    // Something with sat = 0 should end up with value = 0.  Something
-    // with a high sat can end up with a high value and it's ok.... At
-    // the same time, we don't want to make things lighter.  Do
-    // something simple, since it seems to work.
-    if (value > sat) {
-      value = sat;
-      // convert this color back into the RGB color space.
-      NS_HSV2RGB(newcolor,hue,sat,value);
-    }
-  }
-  return newcolor;
 }
 
 //----------------------------------------------------------------------
@@ -1376,9 +1351,22 @@
   if (aBorder.GetBorderStyle(aSide) != NS_STYLE_BORDER_STYLE_SOLID)
     return PR_FALSE;
 
+  // If we're using a border image, assume it's not fully opaque,
+  // because we may not even have the image loaded at this point, and
+  // even if we did, checking whether the relevant tile is fully
+  // opaque would be too much work.
+  if (aBorder.GetBorderImage())
+    return PR_FALSE;
+
   nscolor color;
   PRBool isForeground;
   aBorder.GetBorderColor(aSide, color, isForeground);
+
+  // We don't know the foreground color here, so if it's being used
+  // we must assume it might be transparent.
+  if (isForeground)
+    return PR_FALSE;
+
   return NS_GET_A(color) == 255;
 }
 
@@ -1477,7 +1465,8 @@
   // We have a background image
 
   // Lookup the image
-  imgIRequest *req = aColor.mBackgroundImage;
+  imgIRequest *req = aPresContext->LoadImage(aColor.mBackgroundImage,
+                                             aForFrame);
 
   PRUint32 status = imgIRequest::STATUS_ERROR;
   if (req)
@@ -1915,7 +1904,7 @@
     borderImageSplit[NS_SIDE_BOTTOM] = aBorderStyle.mBorderImageSplit.GetBottom();
     borderImageSplit[NS_SIDE_LEFT] = aBorderStyle.mBorderImageSplit.GetLeft();
 
-    imgIRequest *req = aBorderStyle.GetBorderImage();
+    imgIRequest *req = aPresContext->LoadBorderImage(aBorderStyle.GetBorderImage(), aForFrame);
 
     nsCOMPtr<imgIContainer> image;
     req->GetImage(getter_AddRefs(image));
diff -r 17e9560465b0 layout/base/nsCSSRendering.h
--- a/layout/base/nsCSSRendering.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/base/nsCSSRendering.h	Thu Oct 30 05:41:45 2008 -0400
@@ -181,13 +181,6 @@
                                      nscoord              aStartBevelOffset = 0,
                                      PRUint8              aEndBevelSide = 0,
                                      nscoord              aEndBevelOffset = 0);
-  /**
-   * transform a color to a color that will show up on a printer if needed
-   * aMapColor - color to evaluate
-   * aIsPrinter - Is this a printing device
-   * return - the transformed color
-   */
-  static nscolor TransformColor(nscolor  aMapColor,PRBool aNoBackGround);
 
   /**
    * Function for painting the decoration lines for the text.
diff -r 17e9560465b0 layout/base/nsFrameManager.cpp
--- a/layout/base/nsFrameManager.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/base/nsFrameManager.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -1072,6 +1072,24 @@
   return aMinChange;
 }
 
+static PRBool
+ShouldStopImage(imgIRequest *aOldImage, imgIRequest *aNewImage)
+{
+  if (!aOldImage)
+    return PR_FALSE;
+
+  PRBool stopImages = !aNewImage;
+  if (!stopImages) {
+    nsCOMPtr<nsIURI> oldURI, newURI;
+    aOldImage->GetURI(getter_AddRefs(oldURI));
+    aNewImage->GetURI(getter_AddRefs(newURI));
+    PRBool equal;
+    stopImages =
+      NS_FAILED(oldURI->Equals(newURI, &equal)) || !equal;
+  }
+  return stopImages;
+}
+
 nsChangeHint
 nsFrameManager::ReResolveStyleContext(nsPresContext    *aPresContext,
                                       nsIFrame          *aFrame,
@@ -1202,6 +1220,33 @@
         if (!(aMinChange & nsChangeHint_ReconstructFrame)) {
           // if frame gets regenerated, let it keep old context
           aFrame->SetStyleContext(newContext);
+        }
+        // if old context had image and new context does not have the same image, 
+        // stop the image load for the frame
+        if (ShouldStopImage(
+              oldContext->GetStyleBackground()->mBackgroundImage,
+              newContext->GetStyleBackground()->mBackgroundImage)) {
+          // stop the image loading for the frame, the image has changed
+          aPresContext->StopBackgroundImageFor(aFrame);
+        }
+
+        imgIRequest *newBorderImage =
+          newContext->GetStyleBorder()->GetBorderImage();
+        if (ShouldStopImage(oldContext->GetStyleBorder()->GetBorderImage(),
+                            newBorderImage)) {
+          // stop the image loading for the frame, the image has changed
+          aPresContext->StopBorderImageFor(aFrame);
+        }
+
+        // Since the CalcDifference call depended on the result of
+        // GetActualBorder() and that result depends on whether the
+        // image has loaded, start the image load now so that we'll get
+        // notified when it completes loading and can do a restyle.
+        // Otherwise, the image might finish loading from the network
+        // before we start listening to its notifications, and then
+        // we'll never know that it's finished loading.
+        if (newBorderImage) {
+          aPresContext->LoadBorderImage(newBorderImage, aFrame);
         }
       }
       oldContext->Release();
diff -r 17e9560465b0 layout/base/nsFrameTraversal.cpp
--- a/layout/base/nsFrameTraversal.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/base/nsFrameTraversal.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -42,22 +42,18 @@
 #include "nsPlaceholderFrame.h"
 
 
-class nsFrameIterator: public nsIBidirectionalEnumerator
+class nsFrameIterator : public nsIFrameEnumerator
 {
 public:
   NS_DECL_ISUPPORTS
 
-  NS_IMETHOD First();
+  virtual void First();
+  virtual void Next();
+  virtual nsIFrame* CurrentItem();
+  virtual PRBool IsDone();
 
-  NS_IMETHOD Last();
-  
-  NS_IMETHOD Next();
-
-  NS_IMETHOD Prev();
-
-  NS_IMETHOD CurrentItem(nsISupports **aItem);
-
-  NS_IMETHOD IsDone();//what does this mean??off edge? yes
+  virtual void Last();
+  virtual void Prev();
 
   nsFrameIterator(nsPresContext* aPresContext, nsIFrame *aStart,
                   nsIteratorType aType, PRBool aLockScroll, PRBool aFollowOOFs);
@@ -165,7 +161,7 @@
 }
 
 nsresult
-NS_NewFrameTraversal(nsIBidirectionalEnumerator **aEnumerator,
+NS_NewFrameTraversal(nsIFrameEnumerator **aEnumerator,
                      nsPresContext* aPresContext,
                      nsIFrame *aStart,
                      nsIteratorType aType,
@@ -175,7 +171,7 @@
 {
   if (!aEnumerator || !aStart)
     return NS_ERROR_NULL_POINTER;
-  nsFrameIterator *trav;
+  nsCOMPtr<nsIFrameEnumerator> trav;
   if (aVisual) {
     trav = new nsVisualIterator(aPresContext, aStart, aType,
                                 aLockInScrollView, aFollowOOFs);
@@ -185,7 +181,7 @@
   }
   if (!trav)
     return NS_ERROR_OUT_OF_MEMORY;
-  *aEnumerator = static_cast<nsIBidirectionalEnumerator*>(trav);
+  *aEnumerator = trav;
   NS_ADDREF(trav);
   return NS_OK;
 }
@@ -202,7 +198,7 @@
 NS_IMPL_ISUPPORTS1(nsFrameTraversal,nsIFrameTraversal)
 
 NS_IMETHODIMP 
- nsFrameTraversal::NewFrameTraversal(nsIBidirectionalEnumerator **aEnumerator,
+ nsFrameTraversal::NewFrameTraversal(nsIFrameEnumerator **aEnumerator,
                                      nsPresContext* aPresContext,
                                      nsIFrame *aStart,
                                      PRInt32 aType,
@@ -217,7 +213,7 @@
 
 // nsFrameIterator implementation
 
-NS_IMPL_ISUPPORTS2(nsFrameIterator, nsIEnumerator, nsIBidirectionalEnumerator)
+NS_IMPL_ISUPPORTS1(nsFrameIterator, nsIFrameEnumerator)
 
 nsFrameIterator::nsFrameIterator(nsPresContext* aPresContext, nsIFrame *aStart,
                                  nsIteratorType aType, PRBool aLockInScrollView,
@@ -237,34 +233,27 @@
 
 
 
-NS_IMETHODIMP
-nsFrameIterator::CurrentItem(nsISupports **aItem)
+nsIFrame*
+nsFrameIterator::CurrentItem()
 {
-  if (!aItem)
-    return NS_ERROR_NULL_POINTER;
-  *aItem = mCurrent;
   if (mOffEdge)
-    return NS_ENUMERATOR_FALSE;
-  return NS_OK;
+    return nsnull;
+
+  return mCurrent;
 }
 
 
 
-NS_IMETHODIMP
-nsFrameIterator::IsDone()//what does this mean??off edge? yes
+PRBool
+nsFrameIterator::IsDone()
 {
-  if (mOffEdge != 0)
-    return NS_OK;
-  return NS_ENUMERATOR_FALSE;
+  return mOffEdge != 0;
 }
 
-
-
-NS_IMETHODIMP
+void
 nsFrameIterator::First()
 {
   mCurrent = mStart;
-  return NS_OK;
 }
 
 static PRBool
@@ -275,7 +264,7 @@
          (atom == nsGkAtoms::rootFrame);
 }
 
-NS_IMETHODIMP
+void
 nsFrameIterator::Last()
 {
   nsIFrame* result;
@@ -294,10 +283,9 @@
   setCurrent(parent);
   if (!parent)
     setOffEdge(1);
-  return NS_OK;
 }
 
-NS_IMETHODIMP
+void
 nsFrameIterator::Next()
 {
   // recursive-oid method to get next frame
@@ -351,10 +339,9 @@
     setOffEdge(1);
     setLast(parent);
   }
-  return NS_OK;
 }
 
-NS_IMETHODIMP
+void
 nsFrameIterator::Prev()
 {
   // recursive-oid method to get prev frame
@@ -407,7 +394,6 @@
     setOffEdge(-1);
     setLast(parent);
   }
-  return NS_OK;
 }
 
 nsIFrame*
diff -r 17e9560465b0 layout/base/nsFrameTraversal.h
--- a/layout/base/nsFrameTraversal.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/base/nsFrameTraversal.h	Thu Oct 30 05:41:45 2008 -0400
@@ -37,11 +37,10 @@
 #ifndef NSFRAMETRAVERSAL_H
 #define NSFRAMETRAVERSAL_H
 
-#include "nsIEnumerator.h"
 #include "nsIFrame.h"
 #include "nsIFrameTraversal.h"
 
-nsresult NS_NewFrameTraversal(nsIBidirectionalEnumerator **aEnumerator,
+nsresult NS_NewFrameTraversal(nsIFrameEnumerator **aEnumerator,
                               nsPresContext* aPresContext,
                               nsIFrame *aStart,
                               nsIteratorType aType,
@@ -59,7 +58,7 @@
 
   NS_DECL_ISUPPORTS
 
-  NS_IMETHOD NewFrameTraversal(nsIBidirectionalEnumerator **aEnumerator,
+  NS_IMETHOD NewFrameTraversal(nsIFrameEnumerator **aEnumerator,
                                nsPresContext* aPresContext,
                                nsIFrame *aStart,
                                PRInt32 aType,
diff -r 17e9560465b0 layout/base/nsIFrameTraversal.h
--- a/layout/base/nsIFrameTraversal.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/base/nsIFrameTraversal.h	Thu Oct 30 05:41:45 2008 -0400
@@ -38,8 +38,27 @@
 #define NSIFRAMETRAVERSAL_H
 
 #include "nsISupports.h"
-#include "nsIEnumerator.h"
 #include "nsIFrame.h"
+
+#define NS_IFRAMEENUMERATOR_IID \
+{ 0x7c633f5d, 0x91eb, 0x494e, \
+  { 0xa1, 0x40, 0x17, 0x46, 0x17, 0x4c, 0x23, 0xd3 } }
+
+class nsIFrameEnumerator : public nsISupports
+{
+public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_IFRAMEENUMERATOR_IID)
+
+  virtual void First() = 0;
+  virtual void Next() = 0;
+  virtual nsIFrame* CurrentItem() = 0;
+  virtual PRBool IsDone() = 0;
+
+  virtual void Last() = 0;
+  virtual void Prev() = 0;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsIFrameEnumerator, NS_IFRAMEENUMERATOR_IID)
 
 enum nsIteratorType {
   eLeaf,
@@ -71,7 +90,7 @@
    *        the real frame. Going back up will go on past the placeholder,
    *        so the placeholders are logically part of the frame tree.
    */
-  NS_IMETHOD NewFrameTraversal(nsIBidirectionalEnumerator **aEnumerator,
+  NS_IMETHOD NewFrameTraversal(nsIFrameEnumerator **aEnumerator,
                                nsPresContext* aPresContext,
                                nsIFrame *aStart,
                                PRInt32 aType,
diff -r 17e9560465b0 layout/base/nsImageLoadNotifier.cpp
--- a/layout/base/nsImageLoadNotifier.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,265 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- *
- * ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 2001
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Stuart Parmenter <pavlov@netscape.com>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either of the GNU General Public License Version 2 or later (the "GPL"),
- * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-/* class to notify frames of background image loads */
-
-#include "nsImageLoadNotifier.h"
-
-#include "imgILoader.h"
-
-#include "nsIURI.h"
-#include "nsILoadGroup.h"
-#include "nsNetUtil.h"
-
-#include "nsPresContext.h"
-#include "nsIPresShell.h"
-#include "nsIFrame.h"
-#include "nsIContent.h"
-#include "nsIDocument.h"
-
-#include "imgIContainer.h"
-
-#include "nsStyleContext.h"
-#include "nsGkAtoms.h"
-
-// Paint forcing
-#include "prenv.h"
-
-NS_IMPL_ISUPPORTS2(nsImageLoadNotifier, imgIDecoderObserver, imgIContainerObserver)
-
-nsImageLoadNotifier::nsImageLoadNotifier(nsIFrame *aFrame,
-                                         PRBool aReflowOnLoad, 
-                                         nsImageLoadNotifier *aNextLoader)
-  : mFrame(aFrame),
-    mReflowOnLoad(aReflowOnLoad),
-    mNextLoader(aNextLoader)
-{
-}
-
-nsImageLoadNotifier::~nsImageLoadNotifier()
-{
-  mFrame = nsnull;
-
-  if (mRequest) {
-    mRequest->Cancel(NS_ERROR_FAILURE);
-  }
-}
-
-/* static */ already_AddRefed<nsImageLoadNotifier>
-nsImageLoadNotifier::Create(nsIFrame *aFrame, imgIRequest *aRequest, 
-                            PRBool aReflowOnLoad,
-                            nsImageLoadNotifier *aNextLoader)
-{
-  nsRefPtr<nsImageLoadNotifier> loader =
-    new nsImageLoadNotifier(aFrame, aReflowOnLoad, aNextLoader);
-
-  loader->Load(aRequest);
-
-  return loader.forget();
-}
-
-void
-nsImageLoadNotifier::Destroy()
-{
-  // Destroy the chain with only one level of recursion.
-  nsRefPtr<nsImageLoadNotifier> list = mNextLoader;
-  mNextLoader = nsnull;
-  while (list) {
-    nsRefPtr<nsImageLoadNotifier> todestroy = list;
-    list = todestroy->mNextLoader;
-    todestroy->mNextLoader = nsnull;
-    todestroy->Destroy();
-  }
-
-  mFrame = nsnull;
-
-  if (mRequest) {
-    mRequest->Cancel(NS_ERROR_FAILURE);
-  }
-
-  mRequest = nsnull;
-}
-
-nsresult
-nsImageLoadNotifier::Load(imgIRequest *aImage)
-{
-  NS_ASSERTION(!mRequest, "can't reuse image loaders");
-
-  if (!mFrame)
-    return NS_ERROR_NOT_INITIALIZED;
-
-  if (!aImage)
-    return NS_ERROR_FAILURE;
-
-  // Make sure to clone into a temporary, then set mRequest, since
-  // cloning may notify and we don't want to trigger paints from this
-  // code.
-  nsCOMPtr<imgIRequest> newRequest;
-  nsresult rv = aImage->Clone(this, getter_AddRefs(newRequest));
-  mRequest.swap(newRequest);
-  return rv;
-}
-
-                    
-
-NS_IMETHODIMP nsImageLoadNotifier::OnStartContainer(imgIRequest *aRequest,
-                                                    imgIContainer *aImage)
-{
-  if (aImage)
-  {
-    /* Get requested animation policy from the pres context:
-     *   normal = 0
-     *   one frame = 1
-     *   one loop = 2
-     */
-    aImage->SetAnimationMode(mFrame->PresContext()->ImageAnimationMode());
-    // Ensure the animation (if any) is started.
-    aImage->StartAnimation();
-  }
-  return NS_OK;
-}
-
-NS_IMETHODIMP nsImageLoadNotifier::OnStopFrame(imgIRequest *aRequest,
-                                               gfxIImageFrame *aFrame)
-{
-  if (!mFrame)
-    return NS_ERROR_FAILURE;
-  
-#ifdef NS_DEBUG
-// Make sure the image request status's STATUS_FRAME_COMPLETE flag has been set to ensure
-// the image will be painted when invalidated
-  if (aRequest) {
-   PRUint32 status = imgIRequest::STATUS_ERROR;
-   nsresult rv = aRequest->GetImageStatus(&status);
-   if (NS_SUCCEEDED(rv)) {
-     NS_ASSERTION((status & imgIRequest::STATUS_FRAME_COMPLETE), "imgIRequest::STATUS_FRAME_COMPLETE not set");
-   }
-  }
-#endif
-
-  if (!mRequest) {
-    // We're in the middle of a paint anyway
-    return NS_OK;
-  }
-  
-  // Draw the background image
-  RedrawDirtyFrame(nsnull);
-  return NS_OK;
-}
-
-NS_IMETHODIMP nsImageLoadNotifier::FrameChanged(imgIContainer *aContainer,
-                                                gfxIImageFrame *newframe,
-                                                nsRect * dirtyRect)
-{
-  if (!mFrame)
-    return NS_ERROR_FAILURE;
-
-  if (!mRequest) {
-    // We're in the middle of a paint anyway
-    return NS_OK;
-  }
-  
-  nsRect r(*dirtyRect);
-
-  r.x = nsPresContext::CSSPixelsToAppUnits(r.x);
-  r.y = nsPresContext::CSSPixelsToAppUnits(r.y);
-  r.width = nsPresContext::CSSPixelsToAppUnits(r.width);
-  r.height = nsPresContext::CSSPixelsToAppUnits(r.height);
-
-  RedrawDirtyFrame(&r);
-
-  return NS_OK;
-}
-
-
-void
-nsImageLoadNotifier::RedrawDirtyFrame(const nsRect* aDamageRect)
-{
-  if (mReflowOnLoad) {
-    nsIPresShell *shell = mFrame->PresContext()->GetPresShell();
-#ifdef DEBUG
-    nsresult rv = 
-#endif
-      shell->FrameNeedsReflow(mFrame, nsIPresShell::eStyleChange, NS_FRAME_IS_DIRTY);
-    NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "Could not reflow after loading border-image");
-    // The reflow might not do all the invalidation we need, so continue
-    // on with the invalidation codepath.
-  }
-  // NOTE: It is not sufficient to invalidate only the size of the image:
-  //       the image may be tiled! 
-  //       The best option is to call into the frame, however lacking this
-  //       we have to at least invalidate the frame's bounds, hence
-  //       as long as we have a frame we'll use its size.
-  //
-
-  // Invalidate the entire frame
-  // XXX We really only need to invalidate the client area of the frame...    
-
-  nsRect bounds(nsPoint(0, 0), mFrame->GetSize());
-
-  if (mFrame->GetType() == nsGkAtoms::canvasFrame) {
-    // The canvas's background covers the whole viewport.
-    bounds = mFrame->GetOverflowRect();
-  }
-
-  // XXX this should be ok, but there is some crappy ass bug causing it not to work
-  // XXX seems related to the "body fixup rule" dealing with the canvas and body frames...
-#if 0
-  // Invalidate the entire frame only if the frame has a tiled background
-  // image, otherwise just invalidate the intersection of the frame's bounds
-  // with the damaged rect.
-  nsStyleContext* styleContext;
-  mFrame->GetStyleContext(&styleContext);
-  const nsStyleBackground* bg = styleContext->GetStyleBackground();
-
-  if ((bg->mBackgroundFlags & NS_STYLE_BG_IMAGE_NONE) ||
-      (bg->mBackgroundRepeat == NS_STYLE_BG_REPEAT_OFF)) {
-    // The frame does not have a background image so we are free
-    // to invalidate only the intersection of the damage rect and
-    // the frame's bounds.
-
-    if (aDamageRect) {
-      bounds.IntersectRect(*aDamageRect, bounds);
-    }
-  }
-
-#endif
-
-  mFrame->Invalidate(bounds);
-}
diff -r 17e9560465b0 layout/base/nsImageLoadNotifier.h
--- a/layout/base/nsImageLoadNotifier.h	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,98 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- *
- * ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 2001
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Stuart Parmenter <pavlov@netscape.com>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either of the GNU General Public License Version 2 or later (the "GPL"),
- * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-/* class to notify frames of background and border image loads */
-
-#include "nsStubImageDecoderObserver.h"
-
-class nsIFrame;
-class nsIURI;
-
-#include "imgIRequest.h"
-#include "nsCOMPtr.h"
-#include "nsAutoPtr.h"
-
-/**
- * Image loaders pass notifications for background and border image
- * loading and animation on to the frames.
- *
- * Each frame's image loaders form a linked list.
- */
-class nsImageLoadNotifier : public nsStubImageDecoderObserver
-{
-private:
-  nsImageLoadNotifier(nsIFrame *aFrame, PRBool aReflowOnLoad,
-                      nsImageLoadNotifier *aNextLoader);
-  virtual ~nsImageLoadNotifier();
-
-public:
-  static already_AddRefed<nsImageLoadNotifier>
-    Create(nsIFrame *aFrame, imgIRequest *aRequest,
-           PRBool aReflowOnLoad, nsImageLoadNotifier *aNextLoader);
-
-  NS_DECL_ISUPPORTS
-
-  // imgIDecoderObserver (override nsStubImageDecoderObserver)
-  NS_IMETHOD OnStartContainer(imgIRequest *aRequest, imgIContainer *aImage);
-  NS_IMETHOD OnStopFrame(imgIRequest *aRequest, gfxIImageFrame *aFrame);
-  // Do not override OnDataAvailable since background images are not
-  // displayed incrementally; they are displayed after the entire image
-  // has been loaded.
-  // Note: Images referenced by the <img> element are displayed
-  // incrementally in nsImageFrame.cpp.
-
-  // imgIContainerObserver (override nsStubImageDecoderObserver)
-  NS_IMETHOD FrameChanged(imgIContainer *aContainer, gfxIImageFrame *newframe,
-                          nsRect * dirtyRect);
-
-
-  void Destroy();
-
-  imgIRequest *GetRequest() { return mRequest; }
-  nsImageLoadNotifier *GetNextLoader() { return mNextLoader; }
-
-private:
-  nsresult Load(imgIRequest *aImage);
-  void RedrawDirtyFrame(const nsRect* aDamageRect);
-
-  nsIFrame *mFrame;
-  nsCOMPtr<imgIRequest> mRequest;
-  PRBool mReflowOnLoad;
-  nsRefPtr<nsImageLoadNotifier> mNextLoader;
-};
diff -r 17e9560465b0 layout/base/nsImageLoader.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/base/nsImageLoader.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,264 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2001
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Stuart Parmenter <pavlov@netscape.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/* class to notify frames of background image loads */
+
+#include "nsImageLoader.h"
+
+#include "imgILoader.h"
+
+#include "nsIURI.h"
+#include "nsILoadGroup.h"
+#include "nsNetUtil.h"
+
+#include "nsPresContext.h"
+#include "nsIPresShell.h"
+#include "nsIFrame.h"
+#include "nsIContent.h"
+#include "nsIDocument.h"
+
+#include "imgIContainer.h"
+
+#include "nsStyleContext.h"
+#include "nsGkAtoms.h"
+
+// Paint forcing
+#include "prenv.h"
+
+NS_IMPL_ISUPPORTS2(nsImageLoader, imgIDecoderObserver, imgIContainerObserver)
+
+nsImageLoader::nsImageLoader() :
+  mFrame(nsnull), mPresContext(nsnull)
+{
+}
+
+nsImageLoader::~nsImageLoader()
+{
+  mFrame = nsnull;
+  mPresContext = nsnull;
+
+  if (mRequest) {
+    mRequest->Cancel(NS_ERROR_FAILURE);
+  }
+}
+
+
+void
+nsImageLoader::Init(nsIFrame *aFrame, nsPresContext *aPresContext,
+                    PRBool aReflowOnLoad)
+{
+  mFrame = aFrame;
+  mPresContext = aPresContext;
+  mReflowOnLoad = aReflowOnLoad;
+}
+
+void
+nsImageLoader::Destroy()
+{
+  mFrame = nsnull;
+  mPresContext = nsnull;
+
+  if (mRequest) {
+    mRequest->Cancel(NS_ERROR_FAILURE);
+  }
+
+  mRequest = nsnull;
+}
+
+nsresult
+nsImageLoader::Load(imgIRequest *aImage)
+{
+  if (!mFrame)
+    return NS_ERROR_NOT_INITIALIZED;
+
+  if (!aImage)
+    return NS_ERROR_FAILURE;
+
+  if (mRequest) {
+    nsCOMPtr<nsIURI> oldURI;
+    mRequest->GetURI(getter_AddRefs(oldURI));
+    nsCOMPtr<nsIURI> newURI;
+    aImage->GetURI(getter_AddRefs(newURI));
+    PRBool eq = PR_FALSE;
+    nsresult rv = newURI->Equals(oldURI, &eq);
+    if (NS_SUCCEEDED(rv) && eq) {
+      return NS_OK;
+    }
+
+    // Now cancel the old request so it won't hold a stale ref to us.
+    mRequest->Cancel(NS_ERROR_FAILURE);
+    mRequest = nsnull;
+  }
+
+  // Make sure to clone into a temporary, then set mRequest, since
+  // cloning may notify and we don't want to trigger paints from this
+  // code.
+  nsCOMPtr<imgIRequest> newRequest;
+  nsresult rv = aImage->Clone(this, getter_AddRefs(newRequest));
+  mRequest.swap(newRequest);
+  return rv;
+}
+
+                    
+
+NS_IMETHODIMP nsImageLoader::OnStartContainer(imgIRequest *aRequest,
+                                              imgIContainer *aImage)
+{
+  if (aImage)
+  {
+    /* Get requested animation policy from the pres context:
+     *   normal = 0
+     *   one frame = 1
+     *   one loop = 2
+     */
+    aImage->SetAnimationMode(mPresContext->ImageAnimationMode());
+    // Ensure the animation (if any) is started.
+    aImage->StartAnimation();
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsImageLoader::OnStopFrame(imgIRequest *aRequest,
+                                         gfxIImageFrame *aFrame)
+{
+  if (!mFrame)
+    return NS_ERROR_FAILURE;
+  
+#ifdef NS_DEBUG
+// Make sure the image request status's STATUS_FRAME_COMPLETE flag has been set to ensure
+// the image will be painted when invalidated
+  if (aRequest) {
+   PRUint32 status = imgIRequest::STATUS_ERROR;
+   nsresult rv = aRequest->GetImageStatus(&status);
+   if (NS_SUCCEEDED(rv)) {
+     NS_ASSERTION((status & imgIRequest::STATUS_FRAME_COMPLETE), "imgIRequest::STATUS_FRAME_COMPLETE not set");
+   }
+  }
+#endif
+
+  if (!mRequest) {
+    // We're in the middle of a paint anyway
+    return NS_OK;
+  }
+  
+  // Draw the background image
+  RedrawDirtyFrame(nsnull);
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsImageLoader::FrameChanged(imgIContainer *aContainer,
+                                          gfxIImageFrame *newframe,
+                                          nsRect * dirtyRect)
+{
+  if (!mFrame)
+    return NS_ERROR_FAILURE;
+
+  if (!mRequest) {
+    // We're in the middle of a paint anyway
+    return NS_OK;
+  }
+  
+  nsRect r(*dirtyRect);
+
+  r.x = nsPresContext::CSSPixelsToAppUnits(r.x);
+  r.y = nsPresContext::CSSPixelsToAppUnits(r.y);
+  r.width = nsPresContext::CSSPixelsToAppUnits(r.width);
+  r.height = nsPresContext::CSSPixelsToAppUnits(r.height);
+
+  RedrawDirtyFrame(&r);
+
+  return NS_OK;
+}
+
+
+void
+nsImageLoader::RedrawDirtyFrame(const nsRect* aDamageRect)
+{
+  if (mReflowOnLoad) {
+    nsIPresShell *shell = mPresContext->GetPresShell();
+#ifdef DEBUG
+    nsresult rv = 
+#endif
+      shell->FrameNeedsReflow(mFrame, nsIPresShell::eStyleChange, NS_FRAME_IS_DIRTY);
+    NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "Could not reflow after loading border-image");
+    // The reflow might not do all the invalidation we need, so continue
+    // on with the invalidation codepath.
+  }
+  // NOTE: It is not sufficient to invalidate only the size of the image:
+  //       the image may be tiled! 
+  //       The best option is to call into the frame, however lacking this
+  //       we have to at least invalidate the frame's bounds, hence
+  //       as long as we have a frame we'll use its size.
+  //
+
+  // Invalidate the entire frame
+  // XXX We really only need to invalidate the client area of the frame...    
+
+  nsRect bounds(nsPoint(0, 0), mFrame->GetSize());
+
+  if (mFrame->GetType() == nsGkAtoms::canvasFrame) {
+    // The canvas's background covers the whole viewport.
+    bounds = mFrame->GetOverflowRect();
+  }
+
+  // XXX this should be ok, but there is some crappy ass bug causing it not to work
+  // XXX seems related to the "body fixup rule" dealing with the canvas and body frames...
+#if 0
+  // Invalidate the entire frame only if the frame has a tiled background
+  // image, otherwise just invalidate the intersection of the frame's bounds
+  // with the damaged rect.
+  nsStyleContext* styleContext;
+  mFrame->GetStyleContext(&styleContext);
+  const nsStyleBackground* bg = styleContext->GetStyleBackground();
+
+  if ((bg->mBackgroundFlags & NS_STYLE_BG_IMAGE_NONE) ||
+      (bg->mBackgroundRepeat == NS_STYLE_BG_REPEAT_OFF)) {
+    // The frame does not have a background image so we are free
+    // to invalidate only the intersection of the damage rect and
+    // the frame's bounds.
+
+    if (aDamageRect) {
+      bounds.IntersectRect(*aDamageRect, bounds);
+    }
+  }
+
+#endif
+
+  mFrame->Invalidate(bounds);
+}
diff -r 17e9560465b0 layout/base/nsImageLoader.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/base/nsImageLoader.h	Thu Oct 30 05:41:45 2008 -0400
@@ -0,0 +1,89 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2001
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Stuart Parmenter <pavlov@netscape.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/* class to notify frames of background image loads */
+
+#include "nsStubImageDecoderObserver.h"
+
+class nsPresContext;
+class nsIFrame;
+class nsIURI;
+
+#include "imgIRequest.h"
+#include "nsCOMPtr.h"
+
+class nsImageLoader : public nsStubImageDecoderObserver
+{
+public:
+  nsImageLoader();
+  virtual ~nsImageLoader();
+
+  NS_DECL_ISUPPORTS
+
+  // imgIDecoderObserver (override nsStubImageDecoderObserver)
+  NS_IMETHOD OnStartContainer(imgIRequest *aRequest, imgIContainer *aImage);
+  NS_IMETHOD OnStopFrame(imgIRequest *aRequest, gfxIImageFrame *aFrame);
+  // Do not override OnDataAvailable since background images are not
+  // displayed incrementally; they are displayed after the entire image
+  // has been loaded.
+  // Note: Images referenced by the <img> element are displayed
+  // incrementally in nsImageFrame.cpp.
+
+  // imgIContainerObserver (override nsStubImageDecoderObserver)
+  NS_IMETHOD FrameChanged(imgIContainer *aContainer, gfxIImageFrame *newframe,
+                          nsRect * dirtyRect);
+
+  void Init(nsIFrame *aFrame, nsPresContext *aPresContext,
+            PRBool aReflowOnLoad);
+  nsresult Load(imgIRequest *aImage);
+
+  void Destroy();
+
+  nsIFrame *GetFrame() { return mFrame; }
+  imgIRequest *GetRequest() { return mRequest; }
+
+private:
+  void RedrawDirtyFrame(const nsRect* aDamageRect);
+
+private:
+  nsIFrame *mFrame;
+  nsPresContext *mPresContext;
+  nsCOMPtr<imgIRequest> mRequest;
+  PRBool mReflowOnLoad;
+};
diff -r 17e9560465b0 layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/base/nsLayoutUtils.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -906,7 +906,8 @@
 
 nsIFrame*
 nsLayoutUtils::GetFrameForPoint(nsIFrame* aFrame, nsPoint aPt,
-                                PRBool aShouldIgnoreSuppression)
+                                PRBool aShouldIgnoreSuppression,
+                                PRBool aIgnoreScrollFrame)
 {
   nsDisplayListBuilder builder(aFrame, PR_TRUE, PR_FALSE);
   nsDisplayList list;
@@ -914,6 +915,15 @@
 
   if (aShouldIgnoreSuppression)
     builder.IgnorePaintSuppression();
+
+  if (aIgnoreScrollFrame) {
+    nsIFrame* rootScrollFrame =
+      aFrame->PresContext()->PresShell()->GetRootScrollFrame();
+    if (rootScrollFrame) {
+      builder.SetIgnoreScrollFrame(rootScrollFrame);
+    }
+  }
+
   builder.EnterPresShell(aFrame, target);
 
   nsresult rv =
diff -r 17e9560465b0 layout/base/nsLayoutUtils.h
--- a/layout/base/nsLayoutUtils.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/base/nsLayoutUtils.h	Thu Oct 30 05:41:45 2008 -0400
@@ -409,7 +409,8 @@
    * list builder should ignore paint suppression or not
    */
   static nsIFrame* GetFrameForPoint(nsIFrame* aFrame, nsPoint aPt,
-                                    PRBool aShouldIgnoreSuppression = PR_FALSE);
+                                    PRBool aShouldIgnoreSuppression = PR_FALSE,
+                                    PRBool aIgnoreScrollFrame = PR_FALSE);
 
   /**
    * Given a point in the global coordinate space, returns that point expressed
diff -r 17e9560465b0 layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/base/nsPresContext.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -49,7 +49,7 @@
 #include "nsPIDOMWindow.h"
 #include "nsIFocusController.h"
 #include "nsStyleSet.h"
-#include "nsImageLoadNotifier.h"
+#include "nsImageLoader.h"
 #include "nsIContent.h"
 #include "nsIFrame.h"
 #include "nsIRenderingContext.h"
@@ -151,7 +151,7 @@
 
 
 static PLDHashOperator
-destroy_notifiers(const void * aKey, nsRefPtr<nsImageLoadNotifier>& aData, void* closure)
+destroy_loads(const void * aKey, nsCOMPtr<nsImageLoader>& aData, void* closure)
 {
   aData->Destroy();
   return PL_DHASH_NEXT;
@@ -232,7 +232,8 @@
 
 nsPresContext::~nsPresContext()
 {
-  mImageNotifiers.Enumerate(destroy_notifiers, nsnull);
+  mImageLoaders.Enumerate(destroy_loads, nsnull);
+  mBorderImageLoaders.Enumerate(destroy_loads, nsnull);
 
   NS_PRECONDITION(!mShell, "Presshell forgot to clear our mShell pointer");
   SetShell(nsnull);
@@ -300,7 +301,7 @@
 NS_IMPL_CYCLE_COLLECTING_RELEASE(nsPresContext)
 
 static PLDHashOperator
-TraverseImageNotifier(const void * aKey, nsRefPtr<nsImageLoadNotifier>& aData,
+TraverseImageLoader(const void * aKey, nsCOMPtr<nsImageLoader>& aData,
                     void* aClosure)
 {
   nsCycleCollectionTraversalCallback *cb =
@@ -318,7 +319,8 @@
   // NS_IMPL_CYCLE_COLLECTION_TRAVERSE_RAWPTR(mLookAndFeel); // a service
   // NS_IMPL_CYCLE_COLLECTION_TRAVERSE_RAWPTR(mLangGroup); // an atom
 
-  tmp->mImageNotifiers.Enumerate(TraverseImageNotifier, &cb);
+  tmp->mImageLoaders.Enumerate(TraverseImageLoader, &cb);
+  tmp->mBorderImageLoaders.Enumerate(TraverseImageLoader, &cb);
 
   // NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mTheme); // a service
   // NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mLangService); // a service
@@ -340,8 +342,10 @@
   // NS_RELEASE(tmp->mLookAndFeel); // a service
   // NS_RELEASE(tmp->mLangGroup); // an atom
 
-  tmp->mImageNotifiers.Enumerate(destroy_notifiers, nsnull);
-  tmp->mImageNotifiers.Clear();
+  tmp->mImageLoaders.Enumerate(destroy_loads, nsnull);
+  tmp->mImageLoaders.Clear();
+  tmp->mBorderImageLoaders.Enumerate(destroy_loads, nsnull);
+  tmp->mBorderImageLoaders.Clear();
 
   // NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mTheme); // a service
   // NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mLangService); // a service
@@ -814,7 +818,10 @@
     mDeviceContext->FlushFontCache();
   mCurAppUnitsPerDevPixel = AppUnitsPerDevPixel();
 
-  if (!mImageNotifiers.Init())
+  if (!mImageLoaders.Init())
+    return NS_ERROR_OUT_OF_MEMORY;
+  
+  if (!mBorderImageLoaders.Init())
     return NS_ERROR_OUT_OF_MEMORY;
   
   // Get the look and feel service here; default colors will be initialized
@@ -1026,13 +1033,10 @@
 
  // Enumeration call back for HashTable
 static PLDHashOperator
-set_animation_mode(const void * aKey, nsRefPtr<nsImageLoadNotifier>& aData, void* closure)
+set_animation_mode(const void * aKey, nsCOMPtr<nsImageLoader>& aData, void* closure)
 {
-  for (nsImageLoadNotifier *loader = aData; loader;
-       loader = loader->GetNextLoader()) {
-    imgIRequest* imgReq = loader->GetRequest();
-    SetImgAnimModeOnImgReq(imgReq, (PRUint16)NS_PTR_TO_INT32(closure));
-  }
+  imgIRequest* imgReq = aData->GetRequest();
+  SetImgAnimModeOnImgReq(imgReq, (PRUint16)NS_PTR_TO_INT32(closure));
   return PL_DHASH_NEXT;
 }
 
@@ -1068,12 +1072,12 @@
   if (!IsDynamic())
     return;
 
-  // This hash table contains a list of background images
-  // so iterate over it and set the mode
-  mImageNotifiers.Enumerate(set_animation_mode, NS_INT32_TO_PTR(aMode));
+  // Set the mode on the image loaders.
+  mImageLoaders.Enumerate(set_animation_mode, NS_INT32_TO_PTR(aMode));
+  mBorderImageLoaders.Enumerate(set_animation_mode, NS_INT32_TO_PTR(aMode));
 
   // Now walk the content tree and set the animation mode 
-  // on all the images
+  // on all the images.
   if (mShell != nsnull) {
     nsIDocument *doc = mShell->GetDocument();
     if (doc) {
@@ -1167,29 +1171,66 @@
   mCurAppUnitsPerDevPixel = AppUnitsPerDevPixel();
 }
 
-void
-nsPresContext::SetImageNotifiers(nsIFrame* aTargetFrame,
-                                 nsImageLoadNotifier* aImageNotifiers)
+imgIRequest*
+nsPresContext::DoLoadImage(nsPresContext::ImageLoaderTable& aTable,
+                           imgIRequest* aImage,
+                           nsIFrame* aTargetFrame,
+                           PRBool aReflowOnLoad)
 {
-  nsRefPtr<nsImageLoadNotifier> oldNotifiers;
-  mImageNotifiers.Get(aTargetFrame, getter_AddRefs(oldNotifiers));
+  // look and see if we have a loader for the target frame.
+  nsCOMPtr<nsImageLoader> loader;
+  aTable.Get(aTargetFrame, getter_AddRefs(loader));
 
-  if (aImageNotifiers) {
-    mImageNotifiers.Put(aTargetFrame, aImageNotifiers);
-  } else if (oldNotifiers) {
-    mImageNotifiers.Remove(aTargetFrame);
+  if (!loader) {
+    loader = new nsImageLoader();
+    if (!loader)
+      return nsnull;
+
+    loader->Init(aTargetFrame, this, aReflowOnLoad);
+    aTable.Put(aTargetFrame, loader);
   }
 
-  if (oldNotifiers)
-    oldNotifiers->Destroy();
+  loader->Load(aImage);
+
+  imgIRequest *request = loader->GetRequest();
+
+  return request;
+}
+
+imgIRequest*
+nsPresContext::LoadImage(imgIRequest* aImage, nsIFrame* aTargetFrame)
+{
+  return DoLoadImage(mImageLoaders, aImage, aTargetFrame, PR_FALSE);
+}
+
+imgIRequest*
+nsPresContext::LoadBorderImage(imgIRequest* aImage, nsIFrame* aTargetFrame)
+{
+  return DoLoadImage(mBorderImageLoaders, aImage, aTargetFrame,
+                     aTargetFrame->GetStyleBorder()->ImageBorderDiffers());
 }
 
 void
 nsPresContext::StopImagesFor(nsIFrame* aTargetFrame)
 {
-  SetImageNotifiers(aTargetFrame, nsnull);
+  StopBackgroundImageFor(aTargetFrame);
+  StopBorderImageFor(aTargetFrame);
 }
 
+void
+nsPresContext::DoStopImageFor(nsPresContext::ImageLoaderTable& aTable,
+                              nsIFrame* aTargetFrame)
+{
+  nsCOMPtr<nsImageLoader> loader;
+  aTable.Get(aTargetFrame, getter_AddRefs(loader));
+
+  if (loader) {
+    loader->Destroy();
+
+    aTable.Remove(aTargetFrame);
+  }
+}
+  
 void
 nsPresContext::SetContainer(nsISupports* aHandler)
 {
diff -r 17e9560465b0 layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/base/nsPresContext.h	Thu Oct 30 05:41:45 2008 -0400
@@ -60,14 +60,14 @@
 #include "nsPropertyTable.h"
 #include "nsGkAtoms.h"
 #include "nsIDocument.h"
-#include "nsRefPtrHashtable.h"
+#include "nsInterfaceHashtable.h"
 #include "nsCycleCollectionParticipant.h"
 #include "nsChangeHint.h"
 // This also pulls in gfxTypes.h, which we cannot include directly.
 #include "gfxRect.h"
 #include "nsRegion.h"
 
-class nsImageLoadNotifier;
+class nsImageLoader;
 #ifdef IBMBIDI
 class nsBidiPresUtils;
 #endif // IBMBIDI
@@ -364,12 +364,35 @@
    * aImage loads, where aImage is its background image.  Only a single
    * image will be tracked per frame.
    */
-  NS_HIDDEN_(void) SetImageNotifiers(nsIFrame* aTargetFrame,
-                                     nsImageLoadNotifier* aImageNotifiers);
+  NS_HIDDEN_(imgIRequest*) LoadImage(imgIRequest* aImage,
+                                     nsIFrame* aTargetFrame);
+  /**
+   * Set up observers so that aTargetFrame will be invalidated or
+   * reflowed (as appropriate) when aImage loads, where aImage is its
+   * *border* image.  Only a single image will be tracked per frame.
+   */
+  NS_HIDDEN_(imgIRequest*) LoadBorderImage(imgIRequest* aImage,
+                                           nsIFrame* aTargetFrame);
 
+private:
+  typedef nsInterfaceHashtable<nsVoidPtrHashKey, nsImageLoader> ImageLoaderTable;
+
+  NS_HIDDEN_(imgIRequest*) DoLoadImage(ImageLoaderTable& aTable,
+                                       imgIRequest* aImage,
+                                       nsIFrame* aTargetFrame,
+                                       PRBool aReflowOnLoad);
+
+  NS_HIDDEN_(void) DoStopImageFor(ImageLoaderTable& aTable,
+                                  nsIFrame* aTargetFrame);
+public:
+
+  NS_HIDDEN_(void) StopBackgroundImageFor(nsIFrame* aTargetFrame)
+  { DoStopImageFor(mImageLoaders, aTargetFrame); }
+  NS_HIDDEN_(void) StopBorderImageFor(nsIFrame* aTargetFrame)
+  { DoStopImageFor(mBorderImageLoaders, aTargetFrame); }
   /**
    * This method is called when a frame is being destroyed to
-   * ensure that the image loads get disassociated from the prescontext
+   * ensure that the image load gets disassociated from the prescontext
    */
   NS_HIDDEN_(void) StopImagesFor(nsIFrame* aTargetFrame);
 
@@ -764,8 +787,8 @@
   nsILinkHandler*       mLinkHandler;   // [WEAK]
   nsIAtom*              mLangGroup;     // [STRONG]
 
-  nsRefPtrHashtable<nsVoidPtrHashKey, nsImageLoadNotifier> mImageNotifiers;
-
+  ImageLoaderTable      mImageLoaders;
+  ImageLoaderTable      mBorderImageLoaders;
   nsWeakPtr             mContainer;
 
   float                 mTextZoom;      // Text zoom, defaults to 1.0
diff -r 17e9560465b0 layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/base/nsPresShell.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -164,7 +164,7 @@
 #include "gfxImageSurface.h"
 #include "gfxContext.h"
 #ifdef MOZ_MEDIA
-#include "nsVideoFrame.h"
+#include "nsHTMLMediaElement.h"
 #endif
 
 // Drag & Drop, Clipboard
@@ -193,7 +193,7 @@
 #include "nsCSSFrameConstructor.h"
 #ifdef MOZ_XUL
 #include "nsMenuFrame.h"
-#include "nsITreeBoxObject.h"
+#include "nsTreeBodyFrame.h"
 #endif
 #include "nsIMenuParent.h"
 #include "nsPlaceholderFrame.h"
@@ -2100,7 +2100,7 @@
       strRule.AppendLiteral(":focus {outline: ");     // For example 3px dotted WindowText (maximum 4)
       strRule.AppendInt(focusRingWidth);
       if (focusRingStyle == 0) // solid
-        strRule.AppendLiteral("px solid -moz-mac-focusring !important; -moz-outline-radius: 3px;  -moz-outline-offset: 1px; } ");
+        strRule.AppendLiteral("px solid -moz-mac-focusring !important; -moz-outline-radius: 3px; outline-offset: 1px; } ");
       else // dotted
         strRule.AppendLiteral("px dotted WindowText !important; } ");
       // insert the rules
@@ -3801,11 +3801,9 @@
         f &&
         frameType == nsGkAtoms::blockFrame) {
       // find the line containing aFrame and increase the top of |offset|.
-      nsCOMPtr<nsILineIterator> lines(do_QueryInterface(f));
-
+      nsAutoLineIterator lines = f->GetLineIterator();
       if (lines) {
-        PRInt32 index = -1;
-        lines->FindLineContaining(prevFrame, &index);
+        PRInt32 index = lines->FindLineContaining(prevFrame);
         if (index >= 0) {
           nsIFrame *trash1;
           PRInt32 trash2;
@@ -5653,7 +5651,12 @@
     nsIFrame* targetFrame;
     {
       nsAutoDisableGetUsedXAssertions disableAssert;
-      targetFrame = nsLayoutUtils::GetFrameForPoint(frame, eventPoint);
+      PRBool ignoreScrollFrame = PR_FALSE;
+      if (aEvent->eventStructType == NS_MOUSE_EVENT) {
+        ignoreScrollFrame = static_cast<nsMouseEvent*>(aEvent)->ignoreScrollFrame;
+      }
+      targetFrame = nsLayoutUtils::GetFrameForPoint(frame, eventPoint,
+                                                    PR_FALSE, ignoreScrollFrame);
     }
 
     if (targetFrame) {
@@ -6064,19 +6067,14 @@
   objectFrame->StopPlugin();
 }
 
-static void
-StopVideoInstance(PresShell *aShell, nsIContent *aContent)
-{
 #ifdef MOZ_MEDIA
-  nsVideoFrame *frame = static_cast<nsVideoFrame*>(aShell->FrameManager()->GetPrimaryFrameFor(aContent, -1));
-  if (frame) {
-    nsIAtom* frameType = frame->GetType();
-    if (frameType == nsGkAtoms::HTMLVideoFrame) {
-      frame->Freeze();
-    }
-  }
-#endif
-}
+static void
+StopMediaInstance(PresShell *aShell, nsIContent *aContent)
+{
+  nsHTMLMediaElement* element = static_cast<nsHTMLMediaElement*>(aContent);
+  element->Freeze();
+}
+#endif
 
 static PRBool
 FreezeSubDocument(nsIDocument *aDocument, void *aData)
@@ -6096,7 +6094,10 @@
     EnumeratePlugins(domDoc, NS_LITERAL_STRING("object"), StopPluginInstance);
     EnumeratePlugins(domDoc, NS_LITERAL_STRING("applet"), StopPluginInstance);
     EnumeratePlugins(domDoc, NS_LITERAL_STRING("embed"), StopPluginInstance);
-    EnumeratePlugins(domDoc, NS_LITERAL_STRING("video"), StopVideoInstance);
+#ifdef MOZ_MEDIA
+    EnumeratePlugins(domDoc, NS_LITERAL_STRING("video"), StopMediaInstance);
+    EnumeratePlugins(domDoc, NS_LITERAL_STRING("audio"), StopMediaInstance);
+#endif
   }
 
   if (mCaret)
@@ -6119,19 +6120,14 @@
   objlc->EnsureInstantiation(getter_AddRefs(inst));
 }
 
-static void
-StartVideoInstance(PresShell *aShell, nsIContent *aContent)
-{
 #ifdef MOZ_MEDIA
-  nsVideoFrame *frame = static_cast<nsVideoFrame*>(aShell->FrameManager()->GetPrimaryFrameFor(aContent, -1));
-  if (frame) {
-    nsIAtom* frameType = frame->GetType();
-    if (frameType == nsGkAtoms::HTMLVideoFrame) {
-      frame->Thaw();
-    }
-  }
-#endif
-}
+static void
+StartMediaInstance(PresShell *aShell, nsIContent *aContent)
+{
+ nsHTMLMediaElement* element = static_cast<nsHTMLMediaElement*>(aContent);
+ element->Thaw();
+}
+#endif
 
 static PRBool
 ThawSubDocument(nsIDocument *aDocument, void *aData)
@@ -6151,7 +6147,10 @@
     EnumeratePlugins(domDoc, NS_LITERAL_STRING("object"), StartPluginInstance);
     EnumeratePlugins(domDoc, NS_LITERAL_STRING("applet"), StartPluginInstance);
     EnumeratePlugins(domDoc, NS_LITERAL_STRING("embed"), StartPluginInstance);
-    EnumeratePlugins(domDoc, NS_LITERAL_STRING("video"), StartVideoInstance);
+#ifdef MOZ_MEDIA
+    EnumeratePlugins(domDoc, NS_LITERAL_STRING("video"), StartMediaInstance);
+    EnumeratePlugins(domDoc, NS_LITERAL_STRING("audio"), StartMediaInstance);
+#endif
   }
 
   if (mDocument)
@@ -6499,9 +6498,10 @@
 {
   // Trees have a special style cache that needs to be flushed when
   // the theme changes.
-  nsCOMPtr<nsITreeBoxObject> treeBox(do_QueryInterface(aFrame));
-  if (treeBox)
-    treeBox->ClearStyleAndImageCaches();
+  nsTreeBodyFrame *treeBody = nsnull;
+  CallQueryInterface(aFrame, &treeBody);
+  if (treeBody)
+    treeBody->ClearStyleAndImageCaches();
 
   // We deliberately don't re-resolve style on a menu's popup
   // sub-content, since doing so slows menus to a crawl.  That means we
diff -r 17e9560465b0 layout/build/Makefile.in
--- a/layout/build/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/build/Makefile.in	Thu Oct 30 05:41:45 2008 -0400
@@ -160,6 +160,7 @@
 	$(DEPTH)/media/libtheora/lib/$(LIB_PREFIX)theora.$(LIB_SUFFIX) \
 	$(DEPTH)/media/libvorbis/lib/$(LIB_PREFIX)vorbis.$(LIB_SUFFIX) \
 	$(NULL)
+LOCAL_INCLUDES += -I$(DEPTH)/content/html/content/src
 endif
 
 ifdef NS_PRINTING
diff -r 17e9560465b0 layout/build/nsContentDLF.cpp
--- a/layout/build/nsContentDLF.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/build/nsContentDLF.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -56,6 +56,9 @@
 #include "nsICSSLoader.h"
 #include "nsCRT.h"
 #include "nsIViewSourceChannel.h"
+#ifdef MOZ_MEDIA
+#include "nsHTMLMediaElement.h"
+#endif
 
 #include "imgILoader.h"
 #include "nsIParser.h"
@@ -77,6 +80,9 @@
 static NS_DEFINE_IID(kXMLDocumentCID, NS_XMLDOCUMENT_CID);
 #ifdef MOZ_SVG
 static NS_DEFINE_IID(kSVGDocumentCID, NS_SVGDOCUMENT_CID);
+#endif
+#ifdef MOZ_MEDIA
+static NS_DEFINE_IID(kVideoDocumentCID, NS_VIDEODOCUMENT_CID);
 #endif
 static NS_DEFINE_IID(kImageDocumentCID, NS_IMAGEDOCUMENT_CID);
 static NS_DEFINE_IID(kXULDocumentCID, NS_XULDOCUMENT_CID);
@@ -267,6 +273,15 @@
     }
   }
 
+#ifdef MOZ_MEDIA
+  if (nsHTMLMediaElement::CanHandleMediaType(aContentType)) {
+    return CreateDocument(aCommand, 
+                          aChannel, aLoadGroup,
+                          aContainer, kVideoDocumentCID,
+                          aDocListener, aDocViewer);
+  }  
+#endif
+
   // Try image types
   nsCOMPtr<imgILoader> loader(do_GetService("@mozilla.org/image/loader;1"));
   PRBool isReg = PR_FALSE;
@@ -285,7 +300,6 @@
                           aContainer, kPluginDocumentCID,
                           aDocListener, aDocViewer);
   }
-
 
   // If we get here, then we weren't able to create anything. Sorry!
   return NS_ERROR_FAILURE;
diff -r 17e9560465b0 layout/build/nsLayoutModule.cpp
--- a/layout/build/nsLayoutModule.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/build/nsLayoutModule.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -530,6 +530,9 @@
 NS_GENERIC_FACTORY_CONSTRUCTOR(nsNoDataProtocolContentPolicy)
 NS_GENERIC_FACTORY_CONSTRUCTOR(nsSyncLoadService)
 MAKE_CTOR(CreatePluginDocument,           nsIDocument,                 NS_NewPluginDocument)
+#ifdef MOZ_MEDIA
+MAKE_CTOR(CreateVideoDocument,            nsIDocument,                 NS_NewVideoDocument)
+#endif
 
 #ifdef MOZ_ENABLE_CANVAS
 MAKE_CTOR(CreateCanvasRenderingContext2D, nsIDOMCanvasRenderingContext2D, NS_NewCanvasRenderingContext2D)
@@ -1282,6 +1285,13 @@
     nsnull,
     CreatePluginDocument },
 
+#ifdef MOZ_MEDIA
+  { "Video Document",
+    NS_VIDEODOCUMENT_CID,
+    nsnull,
+    CreateVideoDocument },
+#endif
+
   { "Style sheet service",
     NS_STYLESHEETSERVICE_CID,
     NS_STYLESHEETSERVICE_CONTRACTID,
diff -r 17e9560465b0 layout/build/nsLayoutStatics.cpp
--- a/layout/build/nsLayoutStatics.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/build/nsLayoutStatics.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -112,6 +112,7 @@
 
 #ifdef MOZ_MEDIA
 #include "nsMediaDecoder.h"
+#include "nsHTMLMediaElement.h"
 #endif
 
 #ifdef MOZ_OGG
@@ -253,14 +254,11 @@
     return rv;
   }
   
+  nsHTMLMediaElement::InitMediaTypes();
 #endif
 
 #ifdef MOZ_OGG
-  rv = nsAudioStream::InitLibrary();
-  if (NS_FAILED(rv)) {
-    NS_ERROR("Could not initialize nsAudioStream");
-    return rv;
-  }
+  nsAudioStream::InitLibrary();
 #endif
 
   return NS_OK;
@@ -343,6 +341,9 @@
 
   NS_ShutdownFocusSuppressor();
 
+#ifdef MOZ_MEDIA
+  nsHTMLMediaElement::ShutdownMediaTypes();
+#endif
 #ifdef MOZ_OGG
   nsAudioStream::ShutdownLibrary();
 #endif
diff -r 17e9560465b0 layout/forms/nsITextControlFrame.h
--- a/layout/forms/nsITextControlFrame.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/forms/nsITextControlFrame.h	Thu Oct 30 05:41:45 2008 -0400
@@ -90,6 +90,8 @@
 
   virtual nsISelectionController* GetOwnedSelectionController() = 0;
   virtual nsFrameSelection* GetOwnedFrameSelection() = 0;
+
+  virtual nsresult GetPhonetic(nsAString& aPhonetic) = 0;
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(nsITextControlFrame,
diff -r 17e9560465b0 layout/forms/nsTextControlFrame.cpp
--- a/layout/forms/nsTextControlFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/forms/nsTextControlFrame.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -1027,10 +1027,6 @@
   }
   if (aIID.Equals(NS_GET_IID(nsIScrollableViewProvider)) && IsScrollable()) {
     *aInstancePtr = static_cast<nsIScrollableViewProvider*>(this);
-    return NS_OK;
-  }
-  if (aIID.Equals(NS_GET_IID(nsIPhonetic))) {
-    *aInstancePtr = static_cast<nsIPhonetic*>(this);
     return NS_OK;
   }
 
@@ -2500,7 +2496,7 @@
 }
 
 
-NS_IMETHODIMP
+nsresult
 nsTextControlFrame::GetPhonetic(nsAString& aPhonetic)
 {
   aPhonetic.Truncate(0); 
diff -r 17e9560465b0 layout/forms/nsTextControlFrame.h
--- a/layout/forms/nsTextControlFrame.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/forms/nsTextControlFrame.h	Thu Oct 30 05:41:45 2008 -0400
@@ -48,7 +48,6 @@
 #include "nsIFontMetrics.h"
 #include "nsWeakReference.h" //for service and presshell pointers
 #include "nsIScrollableViewProvider.h"
-#include "nsIPhonetic.h"
 #include "nsContentUtils.h"
 #include "nsDisplayList.h"
 
@@ -66,8 +65,7 @@
 class nsTextControlFrame : public nsStackFrame,
                            public nsIAnonymousContentCreator,
                            public nsITextControlFrame,
-                           public nsIScrollableViewProvider,
-                           public nsIPhonetic
+                           public nsIScrollableViewProvider
 
 {
 public:
@@ -157,8 +155,7 @@
   virtual nsFrameSelection* GetOwnedFrameSelection()
     { return mFrameSel; }
 
-  // nsIPhonetic
-  NS_DECL_NSIPHONETIC
+  nsresult GetPhonetic(nsAString& aPhonetic);
 
 //==== END NSIGFXTEXTCONTROLFRAME2
 //==== OVERLOAD of nsIFrame
diff -r 17e9560465b0 layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/generic/nsBlockFrame.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -315,6 +315,22 @@
   nsBlockFrameSuper::Destroy();
 }
 
+/* virtual */ nsILineIterator*
+nsBlockFrame::GetLineIterator()
+{
+  nsLineIterator* it = new nsLineIterator;
+  if (!it)
+    return nsnull;
+
+  const nsStyleVisibility* visibility = GetStyleVisibility();
+  nsresult rv = it->Init(mLines, visibility->mDirection == NS_STYLE_DIRECTION_RTL);
+  if (NS_FAILED(rv)) {
+    delete it;
+    return nsnull;
+  }
+  return it;
+}
+
 NS_IMETHODIMP
 nsBlockFrame::QueryInterface(const nsIID& aIID, void** aInstancePtr)
 {
@@ -324,26 +340,6 @@
     *aInstancePtr = static_cast<void*>(static_cast<nsBlockFrame*>(this));
     return NS_OK;
   }
-  if (aIID.Equals(NS_GET_IID(nsILineIterator)) ||
-      aIID.Equals(NS_GET_IID(nsILineIteratorNavigator))) {
-    nsLineIterator* it = new nsLineIterator;
-    if (!it) {
-      *aInstancePtr = nsnull;
-      return NS_ERROR_OUT_OF_MEMORY;
-    }
-    NS_ADDREF(it); // reference passed to caller
-    const nsStyleVisibility* visibility = GetStyleVisibility();
-    nsresult rv = it->Init(mLines,
-                           visibility->mDirection == NS_STYLE_DIRECTION_RTL);
-    if (NS_FAILED(rv)) {
-      *aInstancePtr = nsnull;
-      NS_RELEASE(it);
-      return rv;
-    }
-    *aInstancePtr = static_cast<nsILineIteratorNavigator*>(it);
-    return NS_OK;
-  }
-
   return nsBlockFrameSuper::QueryInterface(aIID, aInstancePtr);
 }
 
diff -r 17e9560465b0 layout/generic/nsBlockFrame.h
--- a/layout/generic/nsBlockFrame.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/generic/nsBlockFrame.h	Thu Oct 30 05:41:45 2008 -0400
@@ -74,7 +74,6 @@
 class nsBulletFrame;
 class nsLineBox;
 class nsFirstLineFrame;
-class nsILineIterator;
 class nsIntervalSet;
 /**
  * Child list name indices
@@ -598,6 +597,8 @@
 
   //----------------------------------------
 
+  virtual nsILineIterator* GetLineIterator();
+
 public:
   nsLineList* GetOverflowLines() const;
 protected:
diff -r 17e9560465b0 layout/generic/nsBulletFrame.cpp
--- a/layout/generic/nsBulletFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/generic/nsBulletFrame.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -133,9 +133,9 @@
 }
 
 /* virtual */ void
-nsBulletFrame::DidSetStyleContext()
+nsBulletFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
 {
-  nsFrame::DidSetStyleContext();
+  nsFrame::DidSetStyleContext(aOldStyleContext);
 
   imgIRequest *newRequest = GetStyleList()->mListStyleImage;
 
diff -r 17e9560465b0 layout/generic/nsBulletFrame.h
--- a/layout/generic/nsBulletFrame.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/generic/nsBulletFrame.h	Thu Oct 30 05:41:45 2008 -0400
@@ -62,7 +62,7 @@
                               const nsRect&           aDirtyRect,
                               const nsDisplayListSet& aLists);
   virtual nsIAtom* GetType() const;
-  virtual void DidSetStyleContext();
+  virtual void DidSetStyleContext(nsStyleContext* aOldStyleContext);
 #ifdef NS_DEBUG
   NS_IMETHOD GetFrameName(nsAString& aResult) const;
 #endif
diff -r 17e9560465b0 layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/generic/nsFrame.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -99,7 +99,6 @@
 #include "nsITextControlFrame.h"
 #include "nsINameSpaceManager.h"
 #include "nsIPercentHeightObserver.h"
-#include "nsStyleStructInlines.h"
 
 #ifdef IBMBIDI
 #include "nsBidiPresUtils.h"
@@ -120,7 +119,6 @@
 #include "nsBoxLayoutState.h"
 #include "nsBlockFrame.h"
 #include "nsDisplayList.h"
-#include "nsImageLoadNotifier.h"
 
 #ifdef MOZ_SVG
 #include "nsSVGIntegrationUtils.h"
@@ -449,7 +447,7 @@
     mState |= NS_FRAME_MAY_BE_TRANSFORMED_OR_HAVE_RENDERING_OBSERVERS;
   }
   
-  DidSetStyleContext();
+  DidSetStyleContext(nsnull);
 
   if (IsBoxWrapped())
     InitBoxMetrics(PR_FALSE);
@@ -553,28 +551,8 @@
 
 // Subclass hook for style post processing
 /* virtual */ void
-nsFrame::DidSetStyleContext()
-{
-  // Ensure that this frame gets invalidates (and, in the case of some
-  // 'border-image's, reflows) when images that affect it load.
-  nsRefPtr<nsImageLoadNotifier> notifierChain;
-
-  const nsStyleBackground *background = GetStyleBackground();
-  imgIRequest *newBackgroundImage = background->mBackgroundImage;
-  if (newBackgroundImage) {
-    notifierChain = nsImageLoadNotifier::Create(this, newBackgroundImage,
-                                                PR_FALSE, notifierChain);
-  }
-
-  const nsStyleBorder *border = GetStyleBorder();
-  imgIRequest *newBorderImage = border->GetBorderImage();
-  if (newBorderImage) {
-    notifierChain = nsImageLoadNotifier::Create(this, newBorderImage,
-                                                border->ImageBorderDiffers(),
-                                                notifierChain);
-  }
-
-  PresContext()->SetImageNotifiers(this, notifierChain);
+nsFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
+{
 }
 
 /* virtual */ nsMargin
@@ -4566,14 +4544,11 @@
   aPos->mResultContent = nsnull;
   aPos->mAttachForward = (aPos->mDirection == eDirNext);
 
-   nsresult result;
-  nsCOMPtr<nsILineIteratorNavigator> it; 
-  result = aBlockFrame->QueryInterface(NS_GET_IID(nsILineIteratorNavigator),getter_AddRefs(it));
-  if (NS_FAILED(result) || !it)
-    return result;
+  nsAutoLineIterator it = aBlockFrame->GetLineIterator();
+  if (!it)
+    return NS_ERROR_FAILURE;
   PRInt32 searchingLine = aLineStart;
-  PRInt32 countLines;
-  result = it->GetNumLines(&countLines);
+  PRInt32 countLines = it->GetNumLines();
   if (aOutSideLimit > 0) //start at end
     searchingLine = countLines;
   else if (aOutSideLimit <0)//start at beginning
@@ -4593,6 +4568,8 @@
   nsRect  rect;
   PRBool isBeforeFirstFrame, isAfterLastFrame;
   PRBool found = PR_FALSE;
+
+  nsresult result = NS_OK;
   while (!found)
   {
     if (aPos->mDirection == eDirPrevious)
@@ -4641,17 +4618,17 @@
 
     if (NS_SUCCEEDED(result) && resultFrame)
     {
-      nsCOMPtr<nsILineIteratorNavigator> newIt; 
       //check to see if this is ANOTHER blockframe inside the other one if so then call into its lines
-      result = resultFrame->QueryInterface(NS_GET_IID(nsILineIteratorNavigator),getter_AddRefs(newIt));
-      if (NS_SUCCEEDED(result) && newIt)
+      nsAutoLineIterator newIt = resultFrame->GetLineIterator();
+      if (newIt)
       {
         aPos->mResultFrame = resultFrame;
         return NS_OK;
       }
       //resultFrame is not a block frame
-
-      nsCOMPtr<nsIBidirectionalEnumerator> frameTraversal;
+      result = NS_ERROR_FAILURE;
+
+      nsCOMPtr<nsIFrameEnumerator> frameTraversal;
       result = NS_NewFrameTraversal(getter_AddRefs(frameTraversal),
                                     aPresContext, resultFrame,
                                     ePostOrder,
@@ -4661,7 +4638,6 @@
                                     );
       if (NS_FAILED(result))
         return result;
-      nsISupports *isupports = nsnull;
       nsIFrame *storeOldResultFrame = resultFrame;
       while ( !found ){
         nsPoint point;
@@ -4739,14 +4715,10 @@
         if (aPos->mDirection == eDirNext && (resultFrame == nearStoppingFrame))
           break;
         //always try previous on THAT line if that fails go the other way
-        result = frameTraversal->Prev();
-        if (NS_FAILED(result))
-          break;
-        result = frameTraversal->CurrentItem(&isupports);
-        if (NS_FAILED(result) || !isupports)
-          return result;
-        //we must CAST here to an nsIFrame. nsIFrame doesnt really follow the rules
-        resultFrame = (nsIFrame *)isupports;
+        frameTraversal->Prev();
+        resultFrame = frameTraversal->CurrentItem();
+        if (!resultFrame)
+          return NS_ERROR_FAILURE;
       }
 
       if (!found){
@@ -4788,14 +4760,11 @@
         if (aPos->mDirection == eDirNext && (resultFrame == farStoppingFrame))
           break;
         //previous didnt work now we try "next"
-        result = frameTraversal->Next();
-        if (NS_FAILED(result))
-          break;
-        result = frameTraversal->CurrentItem(&isupports);
-        if (NS_FAILED(result) || !isupports)
-          break;
-        //we must CAST here to an nsIFrame. nsIFrame doesnt really follow the rules
-        resultFrame = (nsIFrame *)isupports;
+        frameTraversal->Next();
+        nsIFrame *tempFrame = frameTraversal->CurrentItem();
+        if (!tempFrame)
+          break;
+        resultFrame = tempFrame;
       }
       aPos->mResultFrame = resultFrame;
     }
@@ -5095,15 +5064,16 @@
     }
     case eSelectLine :
     {
-      nsCOMPtr<nsILineIteratorNavigator> iter; 
+      nsAutoLineIterator iter;
       nsIFrame *blockFrame = this;
 
       while (NS_FAILED(result)){
         PRInt32 thisLine = nsFrame::GetLineNumber(blockFrame, aPos->mScrollViewStop, &blockFrame);
         if (thisLine < 0) 
           return  NS_ERROR_FAILURE;
-        result = blockFrame->QueryInterface(NS_GET_IID(nsILineIteratorNavigator),getter_AddRefs(iter));
-        NS_ASSERTION(NS_SUCCEEDED(result) && iter, "GetLineNumber() succeeded but no block frame?");
+        iter = blockFrame->GetLineIterator();
+        NS_ASSERTION(iter, "GetLineNumber() succeeded but no block frame?");
+        result = NS_OK;
 
         int edgeCase = 0;//no edge case. this should look at thisLine
         
@@ -5147,20 +5117,23 @@
               //got the table frame now
               while(frame) //ok time to drill down to find iterator
               {
-                result = frame->QueryInterface(NS_GET_IID(nsILineIteratorNavigator),
-                                                          getter_AddRefs(iter));
-                if (NS_SUCCEEDED(result))
+                iter = frame->GetLineIterator();
+                if (iter)
                 {
                   aPos->mResultFrame = frame;
                   searchTableBool = PR_TRUE;
+                  result = NS_OK;
                   break; //while(frame)
                 }
+                result = NS_ERROR_FAILURE;
                 frame = frame->GetFirstChild(nsnull);
               }
             }
-            if (!searchTableBool)
-              result = aPos->mResultFrame->QueryInterface(NS_GET_IID(nsILineIteratorNavigator),
-                                                        getter_AddRefs(iter));
+
+            if (!searchTableBool) {
+              iter = aPos->mResultFrame->GetLineIterator();
+              result = iter ? NS_OK : NS_ERROR_FAILURE;
+            }
             if (NS_SUCCEEDED(result) && iter)//we've struck another block element!
             {
               doneLooping = PR_FALSE;
@@ -5190,14 +5163,13 @@
     case eSelectBeginLine:
     case eSelectEndLine:
     {
-      nsCOMPtr<nsILineIteratorNavigator> it;
       // Adjusted so that the caret can't get confused when content changes
       nsIFrame* blockFrame = AdjustFrameForSelectionStyles(this);
       PRInt32 thisLine = nsFrame::GetLineNumber(blockFrame, aPos->mScrollViewStop, &blockFrame);
       if (thisLine < 0)
         return NS_ERROR_FAILURE;
-      result = blockFrame->QueryInterface(NS_GET_IID(nsILineIteratorNavigator),getter_AddRefs(it));
-      NS_ASSERTION(NS_SUCCEEDED(result) && it, "GetLineNumber() succeeded but no block frame?");
+      nsAutoLineIterator it = blockFrame->GetLineIterator();
+      NS_ASSERTION(it, "GetLineNumber() succeeded but no block frame?");
 
       PRInt32 lineFrameCount;
       nsIFrame *firstFrame;
@@ -5208,8 +5180,7 @@
       
 #ifdef IBMBIDI
       if (aPos->mVisual && PresContext()->BidiEnabled()) {
-        PRBool lineIsRTL;
-        it->GetDirection(&lineIsRTL);
+        PRBool lineIsRTL = it->GetDirection();
         PRBool isReordered;
         nsIFrame *lastFrame;
         result = it->CheckLineOrder(thisLine, &isReordered, &firstFrame, &lastFrame);
@@ -5365,7 +5336,7 @@
   nsIFrame *blockFrame = aFrame;
   nsIFrame *thisBlock;
   PRInt32   thisLine;
-  nsCOMPtr<nsILineIteratorNavigator> it; 
+  nsAutoLineIterator it;
   nsresult result = NS_ERROR_FAILURE;
   while (NS_FAILED(result) && blockFrame)
   {
@@ -5386,7 +5357,9 @@
     if (blockFrame) {
       if (aLockScroll && blockFrame->GetType() == nsGkAtoms::scrollFrame)
         return -1;
-      result = blockFrame->QueryInterface(NS_GET_IID(nsILineIteratorNavigator),getter_AddRefs(it));
+      it = blockFrame->GetLineIterator();
+      if (!it)
+        result = NS_ERROR_FAILURE;
     }
   }
   if (!blockFrame || !it)
@@ -5394,17 +5367,16 @@
 
   if (aContainingBlock)
     *aContainingBlock = blockFrame;
-  result = it->FindLineContaining(thisBlock, &thisLine);
-  if (NS_FAILED(result))
-    return -1;
-  return thisLine;
+  return it->FindLineContaining(thisBlock);
 }
 
 nsresult
 nsIFrame::GetFrameFromDirection(nsDirection aDirection, PRBool aVisual,
                                 PRBool aJumpLines, PRBool aScrollViewStop, 
                                 nsIFrame** aOutFrame, PRInt32* aOutOffset, PRBool* aOutJumpedLine)
-{  
+{
+  nsresult result;
+
   if (!aOutFrame || !aOutOffset || !aOutJumpedLine)
     return NS_ERROR_NULL_POINTER;
   
@@ -5418,21 +5390,20 @@
   nsIFrame *traversedFrame = this;
   while (!selectable) {
     nsIFrame *blockFrame;
-    nsCOMPtr<nsILineIteratorNavigator> it; 
     
     PRInt32 thisLine = nsFrame::GetLineNumber(traversedFrame, aScrollViewStop, &blockFrame);
     if (thisLine < 0)
       return NS_ERROR_FAILURE;
-    nsresult result = blockFrame->QueryInterface(NS_GET_IID(nsILineIteratorNavigator),getter_AddRefs(it));
-    NS_ASSERTION(NS_SUCCEEDED(result) && it, "GetLineNumber() succeeded but no block frame?");
+
+    nsAutoLineIterator it = blockFrame->GetLineIterator();
+    NS_ASSERTION(it, "GetLineNumber() succeeded but no block frame?");
 
     PRBool atLineEdge;
     nsIFrame *firstFrame;
     nsIFrame *lastFrame;
 #ifdef IBMBIDI
     if (aVisual && presContext->BidiEnabled()) {
-      PRBool lineIsRTL;                                                             
-      it->GetDirection(&lineIsRTL);
+      PRBool lineIsRTL = it->GetDirection();
       PRBool isReordered;
       result = it->CheckLineOrder(thisLine, &isReordered, &firstFrame, &lastFrame);
       nsIFrame** framePtr = aDirection == eDirPrevious ? &firstFrame : &lastFrame;
@@ -5482,7 +5453,7 @@
         return NS_ERROR_FAILURE; //we are done. cannot jump lines
     }
 
-    nsCOMPtr<nsIBidirectionalEnumerator> frameTraversal;
+    nsCOMPtr<nsIFrameEnumerator> frameTraversal;
     result = NS_NewFrameTraversal(getter_AddRefs(frameTraversal),
                                   presContext, traversedFrame,
                                   eLeaf,
@@ -5494,21 +5465,13 @@
       return result;
 
     if (aDirection == eDirNext)
-      result = frameTraversal->Next();
+      frameTraversal->Next();
     else
-      result = frameTraversal->Prev();
-    if (NS_FAILED(result))
-      return result;
-
-    nsISupports *isupports = nsnull;
-    result = frameTraversal->CurrentItem(&isupports);
-    if (NS_FAILED(result))
-      return result;
-    if (!isupports)
-      return NS_ERROR_NULL_POINTER;
-    //we must CAST here to an nsIFrame. nsIFrame doesn't really follow the rules
-    //for speed reasons
-    traversedFrame = (nsIFrame *)isupports;
+      frameTraversal->Prev();
+
+    traversedFrame = frameTraversal->CurrentItem();
+    if (!traversedFrame)
+      return NS_ERROR_FAILURE;
     traversedFrame->IsSelectable(&selectable, nsnull);
   } // while (!selectable)
 
@@ -6228,7 +6191,7 @@
     metrics->mBlockMinSize.height = 0;
     // ok we need the max ascent of the items on the line. So to do this
     // ask the block for its line iterator. Get the max ascent.
-    nsCOMPtr<nsILineIterator> lines = do_QueryInterface(static_cast<nsIFrame*>(this));
+    nsAutoLineIterator lines = GetLineIterator();
     if (lines) 
     {
       metrics->mBlockMinSize.height = 0;
@@ -6269,6 +6232,12 @@
   }
 
   return rv;
+}
+
+/* virtual */ nsILineIterator*
+nsFrame::GetLineIterator()
+{
+  return nsnull;
 }
 
 nsSize
diff -r 17e9560465b0 layout/generic/nsFrame.h
--- a/layout/generic/nsFrame.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/generic/nsFrame.h	Thu Oct 30 05:41:45 2008 -0400
@@ -557,7 +557,7 @@
   PRInt16 DisplaySelection(nsPresContext* aPresContext, PRBool isOkToTurnOn = PR_FALSE);
   
   // Style post processing hook
-  virtual void DidSetStyleContext();
+  virtual void DidSetStyleContext(nsStyleContext* aOldStyleContext);
 
 public:
   //given a frame five me the first/last leaf available
@@ -620,6 +620,8 @@
                      PRBool aMoveFrame = PR_TRUE);
 
   NS_IMETHODIMP RefreshSizeCache(nsBoxLayoutState& aState);
+
+  virtual nsILineIterator* GetLineIterator();
 
 protected:
   NS_IMETHOD_(nsrefcnt) AddRef(void);
diff -r 17e9560465b0 layout/generic/nsFrameList.cpp
--- a/layout/generic/nsFrameList.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/generic/nsFrameList.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -427,8 +427,6 @@
 nsIFrame*
 nsFrameList::GetPrevVisualFor(nsIFrame* aFrame) const
 {
-  nsCOMPtr<nsILineIterator> iter;
-
   if (!mFirstChild)
     return nsnull;
   
@@ -439,8 +437,8 @@
   nsBidiLevel baseLevel = nsBidiPresUtils::GetFrameBaseLevel(mFirstChild);  
   nsBidiPresUtils* bidiUtils = mFirstChild->PresContext()->GetBidiUtils();
 
-  nsresult result = parent->QueryInterface(NS_GET_IID(nsILineIterator), getter_AddRefs(iter));
-  if (NS_FAILED(result) || !iter) { 
+  nsAutoLineIterator iter = parent->GetLineIterator();
+  if (!iter) { 
     // Parent is not a block Frame
     if (parent->GetType() == nsGkAtoms::lineFrame) {
       // Line frames are not bidi-splittable, so need to consider bidi reordering
@@ -465,11 +463,11 @@
 
   PRInt32 thisLine;
   if (aFrame) {
-    result = iter->FindLineContaining(aFrame, &thisLine);
-    if (NS_FAILED(result) || thisLine < 0)
+    thisLine = iter->FindLineContaining(aFrame);
+    if (thisLine < 0)
       return nsnull;
   } else {
-    iter->GetNumLines(&thisLine);
+    thisLine = iter->GetNumLines();
   }
 
   nsIFrame* frame = nsnull;
@@ -504,8 +502,6 @@
 nsIFrame*
 nsFrameList::GetNextVisualFor(nsIFrame* aFrame) const
 {
-  nsCOMPtr<nsILineIterator> iter;
-
   if (!mFirstChild)
     return nsnull;
   
@@ -516,8 +512,8 @@
   nsBidiLevel baseLevel = nsBidiPresUtils::GetFrameBaseLevel(mFirstChild);
   nsBidiPresUtils* bidiUtils = mFirstChild->PresContext()->GetBidiUtils();
   
-  nsresult result = parent->QueryInterface(NS_GET_IID(nsILineIterator), getter_AddRefs(iter));
-  if (NS_FAILED(result) || !iter) { 
+  nsAutoLineIterator iter = parent->GetLineIterator();
+  if (!iter) { 
     // Parent is not a block Frame
     if (parent->GetType() == nsGkAtoms::lineFrame) {
       // Line frames are not bidi-splittable, so need to consider bidi reordering
@@ -542,8 +538,8 @@
   
   PRInt32 thisLine;
   if (aFrame) {
-    result = iter->FindLineContaining(aFrame, &thisLine);
-    if (NS_FAILED(result) || thisLine < 0)
+    thisLine = iter->FindLineContaining(aFrame);
+    if (thisLine < 0)
       return nsnull;
   } else {
     thisLine = -1;
@@ -565,8 +561,7 @@
     }
   }
   
-  PRInt32 numLines;
-  iter->GetNumLines(&numLines);
+  PRInt32 numLines = iter->GetNumLines();
   if (!frame && thisLine < numLines - 1) {
     // Get the first frame of the next line
     iter->GetLine(thisLine + 1, &firstFrameOnLine, &numFramesOnLine, lineBounds, &lineFlags);
diff -r 17e9560465b0 layout/generic/nsFrameSetFrame.cpp
--- a/layout/generic/nsFrameSetFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/generic/nsFrameSetFrame.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -162,6 +162,7 @@
   nsHTMLFramesetBorderFrame(nsStyleContext* aContext, PRInt32 aWidth, PRBool aVertical, PRBool aVisible);
   virtual ~nsHTMLFramesetBorderFrame();
   virtual nscoord GetIntrinsicWidth();
+  virtual nscoord GetIntrinsicHeight();
 
   PRInt32 mWidth;
   PRPackedBool mVertical;
@@ -198,6 +199,7 @@
   nsHTMLFramesetBlankFrame(nsStyleContext* aContext) : nsLeafFrame(aContext) {}
   virtual ~nsHTMLFramesetBlankFrame();
   virtual nscoord GetIntrinsicWidth();
+  virtual nscoord GetIntrinsicHeight();
 
   friend class nsHTMLFramesetFrame;
   friend class nsHTMLFrameset;
@@ -1628,6 +1630,12 @@
   return 0;
 }
 
+nscoord nsHTMLFramesetBorderFrame::GetIntrinsicHeight()
+{
+  // No intrinsic height
+  return 0;
+}
+
 void nsHTMLFramesetBorderFrame::SetVisibility(PRBool aVisibility)
 { 
   mVisibility = aVisibility; 
@@ -1839,6 +1847,12 @@
   return 0;
 }
 
+nscoord nsHTMLFramesetBlankFrame::GetIntrinsicHeight()
+{
+  // No intrinsic height
+  return 0;
+}
+
 NS_IMETHODIMP
 nsHTMLFramesetBlankFrame::Reflow(nsPresContext*          aPresContext,
                                  nsHTMLReflowMetrics&     aDesiredSize,
diff -r 17e9560465b0 layout/generic/nsHTMLReflowState.cpp
--- a/layout/generic/nsHTMLReflowState.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/generic/nsHTMLReflowState.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -288,6 +288,17 @@
   InitConstraints(aPresContext, aContainingBlockWidth, aContainingBlockHeight, aBorder, aPadding);
 
   InitResizeFlags(aPresContext);
+
+  // We have to start loading the border image now, because the
+  // border-image's width overrides only apply once the image is loaded.
+  // Starting the load of the image means we'll get a reflow when the
+  // image loads.  (If we didn't do it now, and the image loaded between
+  // reflow and paint, we'd never get the notification, and our size
+  // would be wrong.)
+  imgIRequest *borderImage = mStyleBorder->GetBorderImage();
+  if (borderImage) {
+    aPresContext->LoadBorderImage(borderImage, frame);
+  }
 
   NS_ASSERTION((mFrameType == NS_CSS_FRAME_TYPE_INLINE &&
                 !frame->IsFrameOfType(nsIFrame::eReplaced)) ||
diff -r 17e9560465b0 layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/generic/nsIFrame.h	Thu Oct 30 05:41:45 2008 -0400
@@ -85,6 +85,7 @@
 class nsISelectionController;
 class nsBoxLayoutState;
 class nsIBoxLayout;
+class nsILineIterator;
 #ifdef ACCESSIBILITY
 class nsIAccessible;
 #endif
@@ -105,10 +106,10 @@
 typedef class nsIFrame nsIBox;
 
 // IID for the nsIFrame interface
-// 3459e7bb-2b22-4eb3-b60d-27d9f851b919
+// 7b437d20-a34e-11dd-ad8b-0800200c9a66
 #define NS_IFRAME_IID \
-  { 0x3459e7bb, 0x2b22, 0x4eb3, \
-    { 0xb6, 0x0d, 0x27, 0xd9, 0xf8, 0x51, 0xb9, 0x19 } }
+  { 0x7b437d20, 0xa34e, 0x11dd, \
+    { 0xad, 0x8b, 0x08, 0x00, 0x20, 0x0c, 0x9a, 0x66 } }
 
 /**
  * Indication of how the frame can be split. This is used when doing runaround
@@ -610,13 +611,14 @@
   void SetStyleContext(nsStyleContext* aContext)
   { 
     if (aContext != mStyleContext) {
-      if (mStyleContext)
-        mStyleContext->Release();
+      nsStyleContext* oldStyleContext = mStyleContext;
       mStyleContext = aContext;
       if (aContext) {
         aContext->AddRef();
-        DidSetStyleContext();
+        DidSetStyleContext(oldStyleContext);
       }
+      if (oldStyleContext)
+        oldStyleContext->Release();
     }
   }
   
@@ -633,7 +635,10 @@
   }
 
   // Style post processing hook
-  virtual void DidSetStyleContext() = 0;
+  // Attention: the old style context is the one we're forgetting,
+  // and hence possibly completely bogus for GetStyle* purposes.
+  // Use PeekStyleData instead.
+  virtual void DidSetStyleContext(nsStyleContext* aOldStyleContext) = 0;
 
   /**
    * Get the style data associated with this frame.  This returns a
@@ -2220,6 +2225,14 @@
                                  const nsRect& aOldOverflowRect,
                                  const nsSize& aNewDesiredSize);
 
+  /**
+   * Get a line iterator for this frame, if supported.
+   *
+   * @return nsnull if no line iterator is supported.
+   * @note dispose the line iterator using nsILineIterator::DisposeLineIterator
+   */
+  virtual nsILineIterator* GetLineIterator() = 0;
+
 protected:
   // Members
   nsRect           mRect;
diff -r 17e9560465b0 layout/generic/nsILineIterator.h
--- a/layout/generic/nsILineIterator.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/generic/nsILineIterator.h	Thu Oct 30 05:41:45 2008 -0400
@@ -37,26 +37,11 @@
 #ifndef nsILineIterator_h___
 #define nsILineIterator_h___
 
-#include "nsISupports.h"
+#include "nscore.h"
+#include "nsCoord.h"
 
-/* a6cf90ff-15b3-11d2-932e-00805f8add32 */
-#define NS_ILINE_ITERATOR_IID \
- { 0xa6cf90ff, 0x15b3, 0x11d2,{0x93, 0x2e, 0x00, 0x80, 0x5f, 0x8a, 0xdd, 0x32}}
-
-/* {80AA3D7A-E0BF-4e18-8A82-2110397D7BC4}*/
-#define NS_ILINE_ITERATOR_NAV_IID \
- { 0x80aa3d7a, 0xe0bf, 0x4e18,{0x8a, 0x82, 0x21, 0x10, 0x39, 0x7d, 0x7b, 0xc4}}
-
-// Line iterator API.
-//
-// Lines are numbered from 0 to N, where 0 is the top line and N is
-// the bottom line.
-//
-// NOTE: while you can get this interface by doing a slezy hacky
-// QueryInterface on block frames, it isn't like a normal com
-// interface: it's not reflexive (you can't query back to the block
-// frame) and unlike other frames, it *IS* reference counted so don't
-// forget to NS_RELEASE it when you are done with it!
+class nsIFrame;
+struct nsRect;
 
 // Line Flags (see GetLine below)
 
@@ -67,17 +52,36 @@
 // This bit is set when the line ends in some sort of break.
 #define NS_LINE_FLAG_ENDS_IN_BREAK      0x4
 
-class nsILineIterator : public nsISupports {
+/**
+ * Line iterator API.
+ *
+ * Lines are numbered from 0 to N, where 0 is the top line and N is
+ * the bottom line.
+ *
+ * Obtain this interface from frames via nsIFrame::GetLineIterator.
+ * When you are finished using the iterator, call DisposeLineIterator()
+ * to destroy the iterator if appropriate.
+ */
+class nsILineIterator
+{
+protected:
+  ~nsILineIterator() { }
+
 public:
-  NS_DECLARE_STATIC_IID_ACCESSOR(NS_ILINE_ITERATOR_IID)
+  virtual void DisposeLineIterator() = 0;
 
-  // Return the number of lines in the block.
-  NS_IMETHOD GetNumLines(PRInt32* aResult) = 0;
+  /**
+   * The number of lines in the block
+   */
+  virtual PRInt32 GetNumLines() = 0;
 
-  // Return the prevailing direction for the line. aIsRightToLeft will
-  // be set to PR_TRUE if the CSS direction property for the block is
-  // "rtl", otherwise aIsRightToLeft will be set to PR_FALSE.
-  NS_IMETHOD GetDirection(PRBool* aIsRightToLeft) = 0;
+  /**
+   * The prevailing direction of lines.
+   *
+   * @return PR_TRUE if the CSS direction property for the block is
+   *         "rtl", otherwise PR_FALSE
+   */
+  virtual PRBool GetDirection() = 0;
 
   // Return structural information about a line. aFirstFrameOnLine is
   // the first frame on the line and aNumFramesOnLine is the number of
@@ -98,19 +102,20 @@
                      nsRect& aLineBounds,
                      PRUint32* aLineFlags) = 0;
 
-  // Given a frame that's a child of the block, find which line its on
-  // and return that line index into aIndexResult. aIndexResult will
-  // be set to -1 if the frame cannot be found.
-  NS_IMETHOD FindLineContaining(nsIFrame* aFrame,
-                                PRInt32* aLineNumberResult) = 0;
+  /**
+   * Given a frame that's a child of the block, find which line its on
+   * and return that line index. Returns -1 if the frame cannot be found.
+   */
+  virtual PRInt32 FindLineContaining(nsIFrame* aFrame) = 0;
 
-  // Given a Y coordinate relative to the block that provided this
-  // line iterator, find the line that contains the Y
-  // coordinate. Returns -1 in aLineNumberResult if the Y coordinate
-  // is above the first line. Returns N (where N is the number of
-  // lines) if the Y coordinate is below the last line.
-  NS_IMETHOD FindLineAt(nscoord aY,
-                        PRInt32* aLineNumberResult) = 0;
+  /**
+   * Given a Y coordinate relative to the block that provided this
+   * line iterator, return the line that contains the Y
+   * coordinate. Returns -1 in aLineNumberResult if the Y coordinate
+   * is above the first line. Returns N (where N is the number of
+   * lines) if the Y coordinate is below the last line.
+   */
+  virtual PRInt32 FindLineAt(nscoord aY) = 0;
 
   // Given a line number and an X coordinate, find the frame on the
   // line that is nearest to the X coordinate. The
@@ -136,15 +141,33 @@
 #endif
 };
 
-NS_DEFINE_STATIC_IID_ACCESSOR(nsILineIterator, NS_ILINE_ITERATOR_IID)
+class nsAutoLineIterator
+{
+public:
+  nsAutoLineIterator() : mRawPtr(nsnull) { }
+  nsAutoLineIterator(nsILineIterator *i) : mRawPtr(i) { }
 
-//special line iterator for keyboard navigation
-class nsILineIteratorNavigator : public nsILineIterator {
-public:
-  NS_DECLARE_STATIC_IID_ACCESSOR(NS_ILINE_ITERATOR_NAV_IID)
+  ~nsAutoLineIterator() {
+    if (mRawPtr)
+      mRawPtr->DisposeLineIterator();
+  }
+
+  operator nsILineIterator*() { return mRawPtr; }
+  nsILineIterator* operator->() { return mRawPtr; }
+
+  nsILineIterator* operator=(nsILineIterator* i) {
+    if (i == mRawPtr)
+      return i;
+
+    if (mRawPtr)
+      mRawPtr->DisposeLineIterator();
+
+    mRawPtr = i;
+    return i;
+  }
+
+private:
+  nsILineIterator* mRawPtr;
 };
 
-NS_DEFINE_STATIC_IID_ACCESSOR(nsILineIteratorNavigator,
-                              NS_ILINE_ITERATOR_NAV_IID)
-
 #endif /* nsILineIterator_h___ */
diff -r 17e9560465b0 layout/generic/nsLineBox.cpp
--- a/layout/generic/nsLineBox.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/generic/nsLineBox.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -543,7 +543,11 @@
   }
 }
 
-NS_IMPL_ISUPPORTS2(nsLineIterator, nsILineIterator, nsILineIteratorNavigator)
+/* virtual */ void
+nsLineIterator::DisposeLineIterator()
+{
+  delete this;
+}
 
 nsresult
 nsLineIterator::Init(nsLineList& aLines, PRBool aRightToLeft)
@@ -578,26 +582,16 @@
   return NS_OK;
 }
 
-NS_IMETHODIMP
-nsLineIterator::GetNumLines(PRInt32* aResult)
+PRInt32
+nsLineIterator::GetNumLines()
 {
-  NS_PRECONDITION(aResult, "null OUT ptr");
-  if (!aResult) {
-    return NS_ERROR_NULL_POINTER;
-  }
-  *aResult = mNumLines;
-  return NS_OK;
+  return mNumLines;
 }
 
-NS_IMETHODIMP
-nsLineIterator::GetDirection(PRBool* aIsRightToLeft)
+PRBool
+nsLineIterator::GetDirection()
 {
-  NS_PRECONDITION(aIsRightToLeft, "null OUT ptr");
-  if (!aIsRightToLeft) {
-    return NS_ERROR_NULL_POINTER;
-  }
-  *aIsRightToLeft = mRightToLeft;
-  return NS_OK;
+  return mRightToLeft;
 }
 
 NS_IMETHODIMP
@@ -635,42 +629,35 @@
   return NS_OK;
 }
 
-NS_IMETHODIMP
-nsLineIterator::FindLineContaining(nsIFrame* aFrame,
-                                   PRInt32* aLineNumberResult)
+PRInt32
+nsLineIterator::FindLineContaining(nsIFrame* aFrame)
 {
   nsLineBox* line = mLines[0];
   PRInt32 lineNumber = 0;
   while (lineNumber != mNumLines) {
     if (line->Contains(aFrame)) {
-      *aLineNumberResult = lineNumber;
-      return NS_OK;
+      return lineNumber;
     }
     line = mLines[++lineNumber];
   }
-  *aLineNumberResult = -1;
-  return NS_OK;
+  return -1;
 }
 
-NS_IMETHODIMP
-nsLineIterator::FindLineAt(nscoord aY,
-                           PRInt32* aLineNumberResult)
+/* virtual */ PRInt32
+nsLineIterator::FindLineAt(nscoord aY)
 {
   nsLineBox* line = mLines[0];
   if (!line || (aY < line->mBounds.y)) {
-    *aLineNumberResult = -1;
-    return NS_OK;
+    return -1;
   }
   PRInt32 lineNumber = 0;
   while (lineNumber != mNumLines) {
     if ((aY >= line->mBounds.y) && (aY < line->mBounds.YMost())) {
-      *aLineNumberResult = lineNumber;
-      return NS_OK;
+      return lineNumber;
     }
     line = mLines[++lineNumber];
   }
-  *aLineNumberResult = mNumLines;
-  return NS_OK;
+  return mNumLines;
 }
 
 #ifdef IBMBIDI
diff -r 17e9560465b0 layout/generic/nsLineBox.h
--- a/layout/generic/nsLineBox.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/generic/nsLineBox.h	Thu Oct 30 05:41:45 2008 -0400
@@ -1508,24 +1508,23 @@
 
 //----------------------------------------------------------------------
 
-class nsLineIterator : public nsILineIteratorNavigator {
+class NS_FINAL_CLASS nsLineIterator : public nsILineIterator
+{
 public:
   nsLineIterator();
-  virtual ~nsLineIterator();
+  ~nsLineIterator();
 
-  NS_DECL_ISUPPORTS
+  virtual void DisposeLineIterator();
 
-  NS_IMETHOD GetNumLines(PRInt32* aResult);
-  NS_IMETHOD GetDirection(PRBool* aIsRightToLeft);
+  virtual PRInt32 GetNumLines();
+  virtual PRBool GetDirection();
   NS_IMETHOD GetLine(PRInt32 aLineNumber,
                      nsIFrame** aFirstFrameOnLine,
                      PRInt32* aNumFramesOnLine,
                      nsRect& aLineBounds,
                      PRUint32* aLineFlags);
-  NS_IMETHOD FindLineContaining(nsIFrame* aFrame,
-                                PRInt32* aLineNumberResult);
-  NS_IMETHOD FindLineAt(nscoord aY,
-                        PRInt32* aLineNumberResult);
+  virtual PRInt32 FindLineContaining(nsIFrame* aFrame);
+  virtual PRInt32 FindLineAt(nscoord aY);
   NS_IMETHOD FindFrameAt(PRInt32 aLineNumber,
                          nscoord aX,
                          nsIFrame** aFrameFound,
@@ -1541,15 +1540,7 @@
 #endif
   nsresult Init(nsLineList& aLines, PRBool aRightToLeft);
 
-protected:
-  PRInt32 NumLines() const {
-    return mNumLines;
-  }
-
-  nsLineBox* CurrentLine() {
-    return mLines[mIndex];
-  }
-
+private:
   nsLineBox* PrevLine() {
     if (0 == mIndex) {
       return nsnull;
diff -r 17e9560465b0 layout/generic/nsObjectFrame.cpp
--- a/layout/generic/nsObjectFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/generic/nsObjectFrame.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -136,6 +136,7 @@
 
 #ifdef XP_WIN
 #include "gfxWindowsNativeDrawing.h"
+#include "gfxWindowsSurface.h"
 #endif
 
 // accessibility support
@@ -356,7 +357,7 @@
   nsEventStatus ProcessEvent(const nsGUIEvent & anEvent);
   
 #ifdef XP_WIN
-  void Paint(const nsRect& aDirtyRect, HDC ndc);
+  void Paint(const RECT& aDirty, HDC aDC);
 #elif defined(XP_MACOSX)
   void Paint(const nsRect& aDirtyRect);  
 #elif defined(MOZ_X11) || defined(MOZ_DFB)
@@ -392,7 +393,24 @@
   NPDrawingModel GetDrawingModel();
   WindowRef FixUpPluginWindow(PRInt32 inPaintState);
   void GUItoMacEvent(const nsGUIEvent& anEvent, EventRecord* origEvent, EventRecord& aMacEvent);
-  void SetCGContextChanged(PRBool aState) { mCGContextChanged = aState; }
+  // Set a flag that (if true) indicates the plugin port info has changed and
+  // SetWindow() needs to be called.
+  void SetPluginPortChanged(PRBool aState) { mPluginPortChanged = aState; }
+  // Return a pointer to the internal nsPluginPort structure that's used to
+  // store a copy of plugin port info and to detect when it's been changed.
+  nsPluginPort* GetPluginPortCopy() { return &mPluginPortCopy; }
+  // Set plugin port info in the plugin (in the 'window' member of the
+  // nsPluginWindow structure passed to the plugin by SetWindow()) and set a
+  // flag (mPluginPortChanged) to indicate whether or not this info has
+  // changed, and SetWindow() needs to be called again.
+  nsPluginPort* SetPluginPortAndDetectChange();
+  // Flag when we've set up a Thebes (and CoreGraphics) context in
+  // nsObjectFrame::PaintPlugin().  We need to know this in
+  // FixUpPluginWindow() (i.e. we need to know when FixUpPluginWindow() has
+  // been called from nsObjectFrame::PaintPlugin() when we're using the
+  // CoreGraphics drawing model).
+  void BeginCGPaint();
+  void EndCGPaint();
 #endif
 
   void SetOwner(nsObjectFrame *aOwner)
@@ -453,13 +471,18 @@
   nsCOMPtr<nsITimer>          mPluginTimer;
   nsCOMPtr<nsIPluginHost>     mPluginHost;
 
+#ifdef XP_MACOSX
+  nsPluginPort                mPluginPortCopy;
+  PRInt32                     mInCGPaintLevel;
+#endif
+
   // Initially, the event loop nesting level we were created on, it's updated
   // if we detect the appshell is on a lower level as long as we're not stopped.
   // We delay DoStopPlugin() until the appshell reaches this level or lower.
   PRUint32                    mLastEventloopNestingLevel;
   PRPackedBool                mContentFocused;
   PRPackedBool                mWidgetVisible;    // used on Mac to store our widget's visible state
-  PRPackedBool                mCGContextChanged;
+  PRPackedBool                mPluginPortChanged;
 
   // If true, destroy the widget on destruction. Used when plugin stop
   // is being delayed to a safer point in time.
@@ -625,7 +648,7 @@
 }
 
 /* virtual */ void
-nsObjectFrame::DidSetStyleContext()
+nsObjectFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
 {
   if (HasView()) {
     nsIView* view = GetView();
@@ -637,7 +660,7 @@
     }
   }
 
-  nsObjectFrameSuper::DidSetStyleContext();
+  nsObjectFrameSuper::DidSetStyleContext(aOldStyleContext);
 }
 
 nsIAtom*
@@ -1269,27 +1292,17 @@
 
   /* Make sure plugins don't do any damage outside of where they're supposed to */
   ctx->NewPath();
-  ctx->Rectangle(gfxRect(window.x, window.y,
-                         window.width, window.height));
+  gfxRect r(window.x, window.y, window.width, window.height);
+  ctx->Rectangle(r);
   ctx->Clip();
 
-  /* If we're windowless, we need to do COLOR_ALPHA, and do alpha recovery.
-   * XXX - we could have some sort of flag here that would indicate whether
-   * the plugin knows how to render to an ARGB DIB
-   */
-  if (windowless)
-    ctx->PushGroup(gfxASurface::CONTENT_COLOR_ALPHA);
-  else
-    ctx->PushGroup(gfxASurface::CONTENT_COLOR);
-
-  gfxWindowsNativeDrawing nativeDraw(ctx,
-                                     gfxRect(window.x, window.y,
-                                             window.width, window.height));
+  gfxWindowsNativeDrawing nativeDraw(ctx, r);
   do {
     HDC dc = nativeDraw.BeginNativeDrawing();
     if (!dc)
       return;
 
+    // XXX don't we need to call nativeDraw.TransformToNativeRect here?
     npprint.print.embedPrint.platformPrint = dc;
     npprint.print.embedPrint.window = window;
     // send off print info to plugin
@@ -1298,9 +1311,6 @@
     nativeDraw.EndNativeDrawing();
   } while (nativeDraw.ShouldRenderAgain());
   nativeDraw.PaintToContext();
-
-  ctx->PopGroupToSource();
-  ctx->Paint();
 
   ctx->Restore();
 
@@ -1365,30 +1375,47 @@
         return;
       }
 
-      // If gfxQuartzNativeDrawing hands out a CGContext other than the last
-      // one we passed to the plugin, we need to pass the new one to the
-      // plugin via SetWindow.  This will happen in nsPluginInstanceOwner::
-      // FixUpPluginWindow(), called from nsPluginInstanceOwner::Paint().
-      nsPluginPort* pluginPort = mInstanceOwner->GetPluginPort();
       nsCOMPtr<nsIPluginInstance> inst;
       GetPluginInstance(*getter_AddRefs(inst));
       if (!inst) {
         NS_WARNING("null plugin instance during PaintPlugin");
+        nativeDrawing.EndNativeDrawing();
         return;
       }
       nsPluginWindow* window;
       mInstanceOwner->GetWindow(window);
       if (!window) {
         NS_WARNING("null plugin window during PaintPlugin");
-        return;
-      }
+        nativeDrawing.EndNativeDrawing();
+        return;
+      }
+      nsPluginPort* pluginPortCopy = mInstanceOwner->GetPluginPortCopy();
+      if (!pluginPortCopy) {
+        NS_WARNING("null plugin port copy during PaintPlugin");
+        nativeDrawing.EndNativeDrawing();
+        return;
+      }
+      if (!mInstanceOwner->SetPluginPortAndDetectChange()) {
+        NS_WARNING("null plugin port during PaintPlugin");
+        nativeDrawing.EndNativeDrawing();
+        return;
+      }
+      // If gfxQuartzNativeDrawing hands out a CGContext different from the
+      // one set by SetPluginPortAndDetectChange(), we need to pass it to the
+      // plugin via SetWindow().  This will happen in nsPluginInstanceOwner::
+      // FixUpPluginWindow(), called from nsPluginInstanceOwner::Paint().
+      // (If SetPluginPortAndDetectChange() made any changes itself, this has
+      // already been detected in that method, and will likewise result in a
+      // call to SetWindow() from FixUpPluginWindow().)
       if (window->window->cgPort.context != cgContext) {
-        pluginPort->cgPort.context = cgContext;
-        window->window = pluginPort;
-        mInstanceOwner->SetCGContextChanged(PR_TRUE);
-      }
-
+        window->window->cgPort.context = cgContext;
+        pluginPortCopy->cgPort.context = cgContext;
+        mInstanceOwner->SetPluginPortChanged(PR_TRUE);
+      }
+
+      mInstanceOwner->BeginCGPaint();
       mInstanceOwner->Paint(aDirtyRect);
+      mInstanceOwner->EndCGPaint();
 
       nativeDrawing.EndNativeDrawing();
     } else {
@@ -1396,22 +1423,154 @@
     }
   }
 #elif defined(MOZ_X11) || defined(MOZ_DFB)
-  if (mInstanceOwner)
-    {
-      nsPluginWindow * window;
-      mInstanceOwner->GetWindow(window);
-
-      if (window->type == nsPluginWindowType_Drawable) {
-        gfxRect frameGfxRect =
-          PresContext()->AppUnitsToGfxUnits(nsRect(aFramePt, GetSize()));
-        gfxRect dirtyGfxRect =
-          PresContext()->AppUnitsToGfxUnits(aDirtyRect);
-        gfxContext* ctx = aRenderingContext.ThebesContext();
-
-        mInstanceOwner->Paint(ctx, frameGfxRect, dirtyGfxRect);
-      }
-    }
-#elif defined (XP_WIN) || defined(XP_OS2)
+  if (mInstanceOwner) {
+    nsPluginWindow * window;
+    mInstanceOwner->GetWindow(window);
+
+    if (window->type == nsPluginWindowType_Drawable) {
+      gfxRect frameGfxRect =
+        PresContext()->AppUnitsToGfxUnits(nsRect(aFramePt, GetSize()));
+      gfxRect dirtyGfxRect =
+        PresContext()->AppUnitsToGfxUnits(aDirtyRect);
+      gfxContext* ctx = aRenderingContext.ThebesContext();
+
+      mInstanceOwner->Paint(ctx, frameGfxRect, dirtyGfxRect);
+    }
+  }
+#elif defined(XP_WIN)
+  nsCOMPtr<nsIPluginInstance> inst;
+  GetPluginInstance(*getter_AddRefs(inst));
+  if (inst) {
+    gfxRect frameGfxRect =
+      PresContext()->AppUnitsToGfxUnits(nsRect(aFramePt, GetSize()));
+    gfxRect dirtyGfxRect =
+      PresContext()->AppUnitsToGfxUnits(aDirtyRect);
+    gfxContext *ctx = aRenderingContext.ThebesContext();
+    gfxMatrix currentMatrix = ctx->CurrentMatrix();
+
+    if (ctx->UserToDevicePixelSnapped(frameGfxRect, PR_FALSE)) {
+      dirtyGfxRect = ctx->UserToDevice(dirtyGfxRect);
+      ctx->IdentityMatrix();
+    }
+    dirtyGfxRect.RoundOut();
+
+    // Look if it's windowless
+    nsPluginWindow * window;
+    mInstanceOwner->GetWindow(window);
+
+    if (window->type == nsPluginWindowType_Drawable) {
+      // check if we need to call SetWindow with updated parameters
+      PRBool doupdatewindow = PR_FALSE;
+      // the offset of the DC
+      nsPoint origin;
+      
+      gfxWindowsNativeDrawing nativeDraw(ctx, frameGfxRect);
+      do {
+        HDC hdc = nativeDraw.BeginNativeDrawing();
+        if (!hdc)
+          return;
+
+        RECT dest;
+        nativeDraw.TransformToNativeRect(frameGfxRect, dest);
+        RECT dirty;
+        nativeDraw.TransformToNativeRect(dirtyGfxRect, dirty);
+
+        // XXX how can we be sure that window->window doesn't point to
+        // a dead DC and hdc has been reallocated at the same address?
+        if (reinterpret_cast<HDC>(window->window) != hdc ||
+            window->x != dest.left || window->y != dest.top) {
+          window->window = reinterpret_cast<nsPluginPort*>(hdc);
+          window->x = dest.left;
+          window->y = dest.top;
+
+          // Windowless plugins on windows need a special event to update their location, see bug 135737
+          // bug 271442: note, the rectangle we send is now purely the bounds of the plugin
+          // relative to the window it is contained in, which is useful for the plugin to correctly translate mouse coordinates
+          //
+          // this does not mesh with the comments for bug 135737 which imply that the rectangle
+          // must be clipped in some way to prevent the plugin attempting to paint over areas it shouldn't;
+          //
+          // since the two uses of the rectangle are mutually exclusive in some cases,
+          // and since I don't see any incorrect painting (at least with Flash and ViewPoint - the originator of 135737),
+          // it seems that windowless plugins are not relying on information here for clipping their drawing,
+          // and we can safely use this message to tell the plugin exactly where it is in all cases.
+
+          nsIntPoint origin = GetWindowOriginInPixels(PR_TRUE);
+          nsRect winlessRect = nsRect(origin, nsSize(window->width, window->height));
+          // XXX I don't think we can be certain that the location wrt to
+          // the window only changes when the location wrt to the drawable
+          // changes, but the hdc probably changes on every paint so
+          // doupdatewindow is rarely false, and there is not likely to be
+          // a problem.
+          if (mWindowlessRect != winlessRect) {
+            mWindowlessRect = winlessRect;
+
+            WINDOWPOS winpos;
+            memset(&winpos, 0, sizeof(winpos));
+            winpos.x = mWindowlessRect.x;
+            winpos.y = mWindowlessRect.y;
+            winpos.cx = mWindowlessRect.width;
+            winpos.cy = mWindowlessRect.height;
+
+            // finally, update the plugin by sending it a WM_WINDOWPOSCHANGED event
+            nsPluginEvent pluginEvent;
+            pluginEvent.event = WM_WINDOWPOSCHANGED;
+            pluginEvent.wParam = 0;
+            pluginEvent.lParam = (uint32)&winpos;
+            PRBool eventHandled = PR_FALSE;
+
+            inst->HandleEvent(&pluginEvent, &eventHandled);
+          }
+
+          inst->SetWindow(window);        
+        }
+
+        mInstanceOwner->Paint(dirty, hdc);
+        nativeDraw.EndNativeDrawing();
+      } while (nativeDraw.ShouldRenderAgain());
+
+      nativeDraw.PaintToContext();
+    } else if (!(ctx->GetFlags() & gfxContext::FLAG_DESTINED_FOR_SCREEN)) {
+      // Get PrintWindow dynamically since it's not present on Win2K,
+      // which we still support
+      typedef BOOL (WINAPI * PrintWindowPtr)
+          (HWND hwnd, HDC hdcBlt, UINT nFlags);
+      PrintWindowPtr printProc = nsnull;
+      HMODULE module = ::GetModuleHandleW(L"user32.dll");
+      if (module) {
+        printProc = reinterpret_cast<PrintWindowPtr>
+          (::GetProcAddress(module, "PrintWindow"));
+      }
+      if (printProc) {
+        HWND hwnd = reinterpret_cast<HWND>(window->window);
+        RECT rc;
+        GetWindowRect(hwnd, &rc);
+        nsRefPtr<gfxWindowsSurface> surface =
+          new gfxWindowsSurface(gfxIntSize(rc.right - rc.left, rc.bottom - rc.top));
+
+        if (surface && printProc) {
+          // CAUTION: EVIL AHEAD
+          // We have to temporarily make hwnd a top-level window so that
+          // PrintWindow won't clip it
+          HWND parent = ::GetParent(hwnd);
+          ::SetParent(hwnd, NULL);
+          printProc(hwnd, surface->GetDC(), 0);
+          ::SetParent(hwnd, parent);
+          // END EVIL
+        
+          ctx->Translate(frameGfxRect.pos);
+          ctx->SetSource(surface);
+          gfxRect r = frameGfxRect.Intersect(dirtyGfxRect) - frameGfxRect.pos;
+          ctx->NewPath();
+          ctx->Rectangle(r);
+          ctx->Fill();
+        }
+      }
+    }
+
+    ctx->SetMatrix(currentMatrix);
+  }
+#elif defined(XP_OS2)
   nsCOMPtr<nsIPluginInstance> inst;
   GetPluginInstance(*getter_AddRefs(inst));
   if (inst) {
@@ -1438,6 +1597,7 @@
        * |HandleEvent| to tell the plugin when its window moved
        */
       gfxContext *ctx = aRenderingContext.ThebesContext();
+
       gfxMatrix ctxMatrix = ctx->CurrentMatrix();
       if (ctxMatrix.HasNonTranslation()) {
         // soo; in the future, we should be able to render
@@ -1466,21 +1626,6 @@
         return;
       }
 
-#ifdef XP_WIN
-      // check if we need to update hdc
-      HDC hdc = (HDC)aRenderingContext.GetNativeGraphicData(nsIRenderingContext::NATIVE_WINDOWS_DC);
-
-      if (reinterpret_cast<HDC>(window->window) != hdc) {
-        window->window = reinterpret_cast<nsPluginPort*>(hdc);
-        doupdatewindow = PR_TRUE;
-      }
-
-      SaveDC(hdc);
-
-      POINT origViewportOrigin;
-      GetViewportOrgEx(hdc, &origViewportOrigin);
-      SetViewportOrgEx(hdc, origViewportOrigin.x + (int) xoff, origViewportOrigin.y + (int) yoff, NULL);
-#else // do something similar on OS/2
       // check if we need to update the PS
       HPS hps = (HPS)aRenderingContext.GetNativeGraphicData(nsIRenderingContext::NATIVE_OS2_PS);
       if (reinterpret_cast<HPS>(window->window) != hps) {
@@ -1498,7 +1643,6 @@
           GpiSetPageViewport(hps, &rclViewport);
         }
       }
-#endif
 
       if ((window->x != origin.x) || (window->y != origin.y)) {
         window->x = origin.x;
@@ -1508,63 +1652,13 @@
 
       // if our location or visible area has changed, we need to tell the plugin
       if (doupdatewindow) {
-#ifdef XP_WIN    // Windowless plugins on windows need a special event to update their location, see bug 135737
-           // bug 271442: note, the rectangle we send is now purely the bounds of the plugin
-           // relative to the window it is contained in, which is useful for the plugin to correctly translate mouse coordinates
-           //
-           // this does not mesh with the comments for bug 135737 which imply that the rectangle
-           // must be clipped in some way to prevent the plugin attempting to paint over areas it shouldn't;
-           //
-           // since the two uses of the rectangle are mutually exclusive in some cases,
-           // and since I don't see any incorrect painting (at least with Flash and ViewPoint - the originator of 135737),
-           // it seems that windowless plugins are not relying on information here for clipping their drawing,
-           // and we can safely use this message to tell the plugin exactly where it is in all cases.
-
-              origin = GetWindowOriginInPixels(PR_TRUE);
-              nsRect winlessRect = nsRect(origin, nsSize(window->width, window->height));
-              // XXX I don't think we can be certain that the location wrt to
-              // the window only changes when the location wrt to the drawable
-              // changes, but the hdc probably changes on every paint so
-              // doupdatewindow is rarely false, and there is not likely to be
-              // a problem.
-              if (mWindowlessRect != winlessRect) {
-                mWindowlessRect = winlessRect;
-
-                WINDOWPOS winpos;
-                memset(&winpos, 0, sizeof(winpos));
-                winpos.x = mWindowlessRect.x;
-                winpos.y = mWindowlessRect.y;
-                winpos.cx = mWindowlessRect.width;
-                winpos.cy = mWindowlessRect.height;
-
-                // finally, update the plugin by sending it a WM_WINDOWPOSCHANGED event
-                nsPluginEvent pluginEvent;
-                pluginEvent.event = WM_WINDOWPOSCHANGED;
-                pluginEvent.wParam = 0;
-                pluginEvent.lParam = (uint32)&winpos;
-                PRBool eventHandled = PR_FALSE;
-
-                inst->HandleEvent(&pluginEvent, &eventHandled);
-              }
-#endif
-
         inst->SetWindow(window);        
       }
 
-#ifdef XP_WIN
-      // FIXME - Bug 385435:
-      // This expects a dirty rect relative to the plugin's rect
-      // XXX I wonder if this breaks if we give the frame a border so the
-      // frame origin and plugin origin are not the same
-      mInstanceOwner->Paint(aDirtyRect, hdc);
-
-      RestoreDC(hdc, -1);
-#else // do something similar on OS/2
       mInstanceOwner->Paint(aDirtyRect, hps);
       if (lPSid >= 1) {
         GpiRestorePS(hps, lPSid);
       }
-#endif
       surf->MarkDirty();
     }
   }
@@ -2143,9 +2237,13 @@
 
   mOwner = nsnull;
   mTagText = nsnull;
+#ifdef XP_MACOSX
+  memset(&mPluginPortCopy, 0, sizeof(nsPluginPort));
+  mInCGPaintLevel = 0;
+#endif
   mContentFocused = PR_FALSE;
   mWidgetVisible = PR_TRUE;
-  mCGContextChanged = PR_FALSE;
+  mPluginPortChanged = PR_FALSE;
   mNumCachedAttrs = 0;
   mNumCachedParams = 0;
   mCachedAttrParamNames = nsnull;
@@ -3196,6 +3294,60 @@
   }
 }
 
+// Currently (on OS X in Cocoa widgets) any changes made as a result of
+// calling GetPluginPort() are immediately reflected in the nsPluginWindow
+// structure that has been passed to the plugin via SetWindow().  This is
+// because calls to nsChildView::GetNativeData(NS_NATIVE_PLUGIN_PORT_CG)
+// always return a pointer to the same internal (private) object, but may
+// make changes inside that object.  All calls to GetPluginPort() made while
+// the plugin is active (i.e. excluding those made at our initialization)
+// need to take this into account.  The easiest way to do so is to replace
+// them with calls to SetPluginPortAndDetectChange().  This method keeps track
+// of when calls to GetPluginPort() result in changes, and sets a flag to make
+// sure SetWindow() gets called the next time through FixUpPluginWindow(), so
+// that the plugin is notified of these changes.
+nsPluginPort* nsPluginInstanceOwner::SetPluginPortAndDetectChange()
+{
+  if (!mPluginWindow)
+    return nsnull;
+  nsPluginPort* pluginPort = GetPluginPort();
+  if (!pluginPort)
+    return nsnull;
+  mPluginWindow->window = pluginPort;
+
+  NPDrawingModel drawingModel = GetDrawingModel();
+
+#ifndef NP_NO_QUICKDRAW
+  if (drawingModel == NPDrawingModelQuickDraw) {
+    if (mPluginWindow->window->qdPort.port != mPluginPortCopy.qdPort.port) {
+      mPluginPortCopy.qdPort.port = mPluginWindow->window->qdPort.port;
+      mPluginPortChanged = PR_TRUE;
+    }
+  } else if (drawingModel == NPDrawingModelCoreGraphics)
+#endif
+  {
+    if ((mPluginWindow->window->cgPort.context != mPluginPortCopy.cgPort.context) ||
+        (mPluginWindow->window->cgPort.window != mPluginPortCopy.cgPort.window)) {
+      mPluginPortCopy.cgPort.context = mPluginWindow->window->cgPort.context;
+      mPluginPortCopy.cgPort.window = mPluginWindow->window->cgPort.window;
+      mPluginPortChanged = PR_TRUE;
+    }
+  }
+
+  return mPluginWindow->window;
+}
+
+void nsPluginInstanceOwner::BeginCGPaint()
+{
+  ++mInCGPaintLevel;
+}
+
+void nsPluginInstanceOwner::EndCGPaint()
+{
+  --mInCGPaintLevel;
+  NS_ASSERTION(mInCGPaintLevel >= 0, "Mismatched call to nsPluginInstanceOwner::EndCGPlugin()!");
+}
+
 #endif
 
 nsresult nsPluginInstanceOwner::ScrollPositionWillChange(nsIScrollableView* aScrollable, nscoord aX, nscoord aY)
@@ -3943,30 +4095,15 @@
 #endif
 
 #ifdef XP_WIN
-void nsPluginInstanceOwner::Paint(const nsRect& aDirtyRect, HDC ndc)
+void nsPluginInstanceOwner::Paint(const RECT& aDirty, HDC aDC)
 {
   if (!mInstance || !mOwner)
     return;
 
-  nsPluginWindow * window;
-  GetWindow(window);
-  nsRect relDirtyRect = nsRect(aDirtyRect.x, aDirtyRect.y, aDirtyRect.width, aDirtyRect.height);
-  nsIntRect relDirtyRectInPixels;
-  ConvertAppUnitsToPixels(*mOwner->PresContext(), relDirtyRect,
-                          relDirtyRectInPixels);
-
-  // we got dirty rectangle in relative window coordinates, but we
-  // need it in absolute units and in the (left, top, right, bottom) form
-  RECT drc;
-  drc.left   = relDirtyRectInPixels.x + window->x;
-  drc.top    = relDirtyRectInPixels.y + window->y;
-  drc.right  = drc.left + relDirtyRectInPixels.width;
-  drc.bottom = drc.top + relDirtyRectInPixels.height;
-
   nsPluginEvent pluginEvent;
   pluginEvent.event = WM_PAINT;
-  pluginEvent.wParam = (uint32)ndc;
-  pluginEvent.lParam = (uint32)&drc;
+  pluginEvent.wParam = WPARAM(aDC);
+  pluginEvent.lParam = LPARAM(&aDirty);
   PRBool eventHandled = PR_FALSE;
   mInstance->HandleEvent(&pluginEvent, &eventHandled);
 }
@@ -4534,12 +4671,19 @@
   if (!mWidget || !mPluginWindow || !mInstance || !mOwner)
     return nsnull;
 
-  nsPluginPort* pluginPort = GetPluginPort(); 
+  NPDrawingModel drawingModel = GetDrawingModel();
+
+  // If we've already set up a CGContext in nsObjectFrame::PaintPlugin(), we
+  // don't want calls to SetPluginPortAndDetectChange() to step on our work.
+  nsPluginPort* pluginPort = nsnull;
+  if (mInCGPaintLevel > 0) {
+    pluginPort = mPluginWindow->window;
+  } else {
+    pluginPort = SetPluginPortAndDetectChange();
+  }
 
   if (!pluginPort)
     return nsnull;
-
-  NPDrawingModel drawingModel = GetDrawingModel();
 
   // first, check our view for CSS visibility style
   PRBool isVisible =
@@ -4616,7 +4760,7 @@
       mPluginWindow->clipRect.bottom  != oldClipRect.bottom)
   {
     mInstance->SetWindow(mPluginWindow);
-    mCGContextChanged = PR_FALSE;
+    mPluginPortChanged = PR_FALSE;
     // if the clipRect is of size 0, make the null timer fire less often
     CancelTimer();
     if (mPluginWindow->clipRect.left == mPluginWindow->clipRect.right ||
@@ -4626,9 +4770,9 @@
     else {
       StartTimer(NORMAL_PLUGIN_DELAY);
     }
-  } else if (mCGContextChanged) {
+  } else if (mPluginPortChanged) {
     mInstance->SetWindow(mPluginWindow);
-    mCGContextChanged = PR_FALSE;
+    mPluginPortChanged = PR_FALSE;
   }
 
 #ifndef NP_NO_QUICKDRAW
diff -r 17e9560465b0 layout/generic/nsObjectFrame.h
--- a/layout/generic/nsObjectFrame.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/generic/nsObjectFrame.h	Thu Oct 30 05:41:45 2008 -0400
@@ -102,7 +102,7 @@
 
   virtual void Destroy();
 
-  virtual void DidSetStyleContext();
+  virtual void DidSetStyleContext(nsStyleContext* aOldStyleContext);
 
   NS_IMETHOD GetPluginInstance(nsIPluginInstance*& aPluginInstance);
   virtual nsresult Instantiate(nsIChannel* aChannel, nsIStreamListener** aStreamListener);
diff -r 17e9560465b0 layout/generic/nsSelection.cpp
--- a/layout/generic/nsSelection.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/generic/nsSelection.cpp	Thu Oct 30 05:41:45 2008 -0400
@@ -1583,7 +1583,7 @@
   PRUint8 foundLevel = 0;
   nsIFrame *foundFrame = aFrameIn;
 
-  nsCOMPtr<nsIBidirectionalEnumerator> frameTraversal;
+  nsCOMPtr<nsIFrameEnumerator> frameTraversal;
   nsresult result;
   nsCOMPtr<nsIFrameTraversal> trav(do_CreateInstance(kFrameTraversalCID,&result));
   if (NS_FAILED(result))
@@ -1598,25 +1598,17 @@
                                    );
   if (NS_FAILED(result))
     return result;
-  nsISupports *isupports = nsnull;
 
   do {
     *aFrameOut = foundFrame;
     if (aDirection == eDirNext)
-      result = frameTraversal->Next();
+      frameTraversal->Next();
     else 
-      result = frameTraversal->Prev();
-
-    if (NS_FAILED(result))
-      return result;
-    result = frameTraversal->CurrentItem(&isupports);
-    if (NS_FAILED(result))
-      return result;
-    if (!isupports)
-      return NS_ERROR_NULL_POINTER;
-    //we must CAST here to an nsIFrame. nsIFrame doesn't really follow the rules
-    //for speed reasons
-    foundFrame = (nsIFrame *)isupports;
+      frameTraversal->Prev();
+
+    foundFrame = frameTraversal->CurrentItem();
+    if (!foundFrame)
+      return NS_ERROR_FAILURE;
     foundLevel = NS_GET_EMBEDDING_LEVEL(foundFrame);
 
   } while (foundLevel > aBidiLevel);
diff -r 17e9560465b0 layout/generic/nsTextFrame.h
--- a/layout/generic/nsTextFrame.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/generic/nsTextFrame.h	Thu Oct 30 05:41:45 2008 -0400
@@ -90,7 +90,7 @@
                                   nsIContent*     aChild,
                                   PRBool          aAppend);
                                   
-  virtual void DidSetStyleContext();
+  virtual void DidSetStyleContext(nsStyleContext* aOldStyleContext);
   
   virtual nsIFrame* GetNextContinuation() const {
     return mNextContinuation;
diff -r 17e9560465b0 layout/generic/nsTextFrameThebes.cpp
--- a/layout/generic/nsTextFrameThebes.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/generic/nsTextFrameThebes.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -2809,14 +2809,14 @@
 
 //-----------------------------------------------------------------------------
 
-// TODO delete nsCSSRendering::TransformColor because we're moving it here
 static nscolor
 DarkenColor(nscolor aColor)
 {
-  PRUint16  hue,sat,value;
+  PRUint16  hue, sat, value;
+  PRUint8 alpha;
 
   // convert the RBG to HSV so we can get the lightness (which is the v)
-  NS_RGB2HSV(aColor,hue,sat,value);
+  NS_RGB2HSV(aColor, hue, sat, value, alpha);
 
   // The goal here is to send white to black while letting colored
   // stuff stay colored... So we adopt the following approach.
@@ -2827,7 +2827,7 @@
   if (value > sat) {
     value = sat;
     // convert this color back into the RGB color space.
-    NS_HSV2RGB(aColor,hue,sat,value);
+    NS_HSV2RGB(aColor, hue, sat, value, alpha);
   }
   return aColor;
 }
@@ -3625,9 +3625,9 @@
 }
 
 /* virtual */ void
-nsTextFrame::DidSetStyleContext()
-{
-  nsFrame::DidSetStyleContext();
+nsTextFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
+{
+  nsFrame::DidSetStyleContext(aOldStyleContext);
   ClearTextRun();
 } 
 
diff -r 17e9560465b0 layout/generic/nsVideoFrame.cpp
--- a/layout/generic/nsVideoFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/generic/nsVideoFrame.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -330,18 +330,3 @@
   return nsSize(nsPresContext::CSSPixelsToAppUnits(size.width), 
                 nsPresContext::CSSPixelsToAppUnits(size.height));
 }
-
-NS_IMETHODIMP nsVideoFrame::Freeze()
-{
-  nsHTMLVideoElement* element = static_cast<nsHTMLVideoElement*>(GetContent());
-  element->Pause();
-  return NS_OK;
-}
-
-NS_IMETHODIMP nsVideoFrame::Thaw()
-{
-  nsHTMLVideoElement* element = static_cast<nsHTMLVideoElement*>(GetContent());
-  element->Play();
-  return NS_OK;
-}
-
diff -r 17e9560465b0 layout/generic/nsVideoFrame.h
--- a/layout/generic/nsVideoFrame.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/generic/nsVideoFrame.h	Thu Oct 30 05:41:46 2008 -0400
@@ -83,9 +83,6 @@
                     const nsHTMLReflowState& aReflowState,
                     nsReflowStatus&          aStatus);
 
-  NS_IMETHOD Freeze();
-  NS_IMETHOD Thaw();
-
 #ifdef ACCESSIBILITY
   NS_IMETHOD GetAccessible(nsIAccessible** aAccessible);
 #endif
diff -r 17e9560465b0 layout/generic/nsViewportFrame.cpp
--- a/layout/generic/nsViewportFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/generic/nsViewportFrame.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -216,7 +216,7 @@
 }
 
 nsPoint
- ViewportFrame::AdjustReflowStateForScrollbars(nsHTMLReflowState* aReflowState) const
+ViewportFrame::AdjustReflowStateForScrollbars(nsHTMLReflowState* aReflowState) const
 {
   // Calculate how much room is available for fixed frames. That means
   // determining if the viewport is scrollable and whether the vertical and/or
@@ -240,7 +240,7 @@
 }
 
 NS_IMETHODIMP
-ViewportFrame::Reflow(nsPresContext*          aPresContext,
+ViewportFrame::Reflow(nsPresContext*           aPresContext,
                       nsHTMLReflowMetrics&     aDesiredSize,
                       const nsHTMLReflowState& aReflowState,
                       nsReflowStatus&          aStatus)
diff -r 17e9560465b0 layout/mathml/base/src/nsMathMLmfracFrame.cpp
--- a/layout/mathml/base/src/nsMathMLmfracFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/mathml/base/src/nsMathMLmfracFrame.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -294,7 +294,6 @@
     frameDen = frameNum->GetNextSibling();
   if (!frameNum || !frameDen || frameDen->GetNextSibling()) {
     // report an error, encourage people to get their markups in order
-    NS_WARNING("invalid markup");
     return ReflowError(aRenderingContext, aDesiredSize);
   }
   GetReflowAndBoundingMetricsFor(frameNum, sizeNum, bmNum);
diff -r 17e9560465b0 layout/mathml/base/src/nsMathMLmmultiscriptsFrame.cpp
--- a/layout/mathml/base/src/nsMathMLmmultiscriptsFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/mathml/base/src/nsMathMLmmultiscriptsFrame.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -268,7 +268,6 @@
       if (mprescriptsFrame) {
         // duplicate <mprescripts/> found
         // report an error, encourage people to get their markups in order
-        NS_WARNING("invalid markup");
         return ReflowError(aRenderingContext, aDesiredSize);
       }
       mprescriptsFrame = childFrame;
@@ -377,7 +376,6 @@
   // note: width=0 if all sup-sub pairs match correctly
   if ((0 != width) || !baseFrame || !subScriptFrame || !supScriptFrame) {
     // report an error, encourage people to get their markups in order
-    NS_WARNING("invalid markup");
     return ReflowError(aRenderingContext, aDesiredSize);
   }
 
diff -r 17e9560465b0 layout/mathml/base/src/nsMathMLmoverFrame.cpp
--- a/layout/mathml/base/src/nsMathMLmoverFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/mathml/base/src/nsMathMLmoverFrame.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -270,7 +270,6 @@
     overFrame = baseFrame->GetNextSibling();
   if (!baseFrame || !overFrame || overFrame->GetNextSibling()) {
     // report an error, encourage people to get their markups in order
-    NS_WARNING("invalid markup");
     return ReflowError(aRenderingContext, aDesiredSize);
   }
   GetReflowAndBoundingMetricsFor(baseFrame, baseSize, bmBase);
diff -r 17e9560465b0 layout/mathml/base/src/nsMathMLmrootFrame.cpp
--- a/layout/mathml/base/src/nsMathMLmrootFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/mathml/base/src/nsMathMLmrootFrame.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -246,10 +246,11 @@
   }
   if (2 != count) {
     // report an error, encourage people to get their markups in order
-    NS_WARNING("invalid markup");
     rv = ReflowError(renderingContext, aDesiredSize);
     aStatus = NS_FRAME_COMPLETE;
     NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aDesiredSize);
+    // Call DidReflow() for the child frames we successfully did reflow.
+    DidReflowChildren(mFrames.FirstChild(), childFrame);
     return rv;
   }
 
diff -r 17e9560465b0 layout/mathml/base/src/nsMathMLmsubFrame.cpp
--- a/layout/mathml/base/src/nsMathMLmsubFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/mathml/base/src/nsMathMLmsubFrame.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -136,9 +136,7 @@
     subScriptFrame = baseFrame->GetNextSibling();
   if (!baseFrame || !subScriptFrame || subScriptFrame->GetNextSibling()) {
     // report an error, encourage people to get their markups in order
-    NS_WARNING("invalid markup");
-    return static_cast<nsMathMLContainerFrame*>(aFrame)->ReflowError(aRenderingContext, 
-                                               aDesiredSize);
+    return aFrame->ReflowError(aRenderingContext, aDesiredSize);
   }
   GetReflowAndBoundingMetricsFor(baseFrame, baseSize, bmBase);
   GetReflowAndBoundingMetricsFor(subScriptFrame, subScriptSize, bmSubScript);
diff -r 17e9560465b0 layout/mathml/base/src/nsMathMLmsubsupFrame.cpp
--- a/layout/mathml/base/src/nsMathMLmsubsupFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/mathml/base/src/nsMathMLmsubsupFrame.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -159,10 +159,7 @@
   if (!baseFrame || !subScriptFrame || !supScriptFrame ||
       supScriptFrame->GetNextSibling()) {
     // report an error, encourage people to get their markups in order
-    NS_WARNING("invalid markup");
-    return static_cast<nsMathMLContainerFrame*>
-                      (aFrame)->ReflowError(aRenderingContext,
-                                               aDesiredSize);
+    return aFrame->ReflowError(aRenderingContext, aDesiredSize);
   }
   GetReflowAndBoundingMetricsFor(baseFrame, baseSize, bmBase);
   GetReflowAndBoundingMetricsFor(subScriptFrame, subScriptSize, bmSubScript);
diff -r 17e9560465b0 layout/mathml/base/src/nsMathMLmsupFrame.cpp
--- a/layout/mathml/base/src/nsMathMLmsupFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/mathml/base/src/nsMathMLmsupFrame.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -137,9 +137,7 @@
     supScriptFrame = baseFrame->GetNextSibling();
   if (!baseFrame || !supScriptFrame || supScriptFrame->GetNextSibling()) {
     // report an error, encourage people to get their markups in order
-    NS_WARNING("invalid markup");
-    return static_cast<nsMathMLContainerFrame*>(aFrame)->ReflowError(aRenderingContext, 
-                                               aDesiredSize);
+    return aFrame->ReflowError(aRenderingContext, aDesiredSize);
   }
   GetReflowAndBoundingMetricsFor(baseFrame, baseSize, bmBase);
   GetReflowAndBoundingMetricsFor(supScriptFrame, supScriptSize, bmSupScript);
diff -r 17e9560465b0 layout/mathml/base/src/nsMathMLmunderFrame.cpp
--- a/layout/mathml/base/src/nsMathMLmunderFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/mathml/base/src/nsMathMLmunderFrame.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -267,7 +267,6 @@
     underFrame = baseFrame->GetNextSibling();
   if (!baseFrame || !underFrame || underFrame->GetNextSibling()) {
     // report an error, encourage people to get their markups in order
-    NS_WARNING("invalid markup");
     return ReflowError(aRenderingContext, aDesiredSize);
   }
   GetReflowAndBoundingMetricsFor(baseFrame, baseSize, bmBase);
diff -r 17e9560465b0 layout/mathml/base/src/nsMathMLmunderoverFrame.cpp
--- a/layout/mathml/base/src/nsMathMLmunderoverFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/mathml/base/src/nsMathMLmunderoverFrame.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -307,7 +307,6 @@
     overFrame = underFrame->GetNextSibling();
   if (!baseFrame || !underFrame || !overFrame || overFrame->GetNextSibling()) {
     // report an error, encourage people to get their markups in order
-    NS_WARNING("invalid markup");
     return ReflowError(aRenderingContext, aDesiredSize);
   }
   GetReflowAndBoundingMetricsFor(baseFrame, baseSize, bmBase);
diff -r 17e9560465b0 layout/mathml/crashtests/416907-1.xhtml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/mathml/crashtests/416907-1.xhtml	Thu Oct 30 05:41:46 2008 -0400
@@ -0,0 +1,5 @@
+<html xmlns="http://www.w3.org/1999/xhtml" xmlns:mathml="http://www.w3.org/1998/Math/MathML">
+<mathml:mroot>
+<frameset/>
+</mathml:mroot>
+</html>
diff -r 17e9560465b0 layout/mathml/crashtests/crashtests.list
--- a/layout/mathml/crashtests/crashtests.list	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/mathml/crashtests/crashtests.list	Thu Oct 30 05:41:46 2008 -0400
@@ -37,5 +37,6 @@
 load 405271-1.xml
 load 412237-1.xml
 load 413063-1.xhtml
+load 416907-1.xhtml
 load 420420-1.xhtml
 load 443089-1.xhtml
diff -r 17e9560465b0 layout/reftests/bugs/455105-1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/455105-1.html	Thu Oct 30 05:41:46 2008 -0400
@@ -0,0 +1,28 @@
+<!doctype html>
+<html><head><title>455105-1</title>
+<style>
+div#below {
+  position: absolute;
+  top: 10px; left: 10px;
+  width: 40px;
+  height: 40px;
+  border: 10px solid red;
+  background-color: red;
+}
+div#above {
+  position: absolute;
+  top: 10px; left: 10px;
+  width: 40px;
+  height: 40px;
+  border-width: 10px;
+  border-style: solid;
+  border-color: -moz-initial;
+  color: rgba(0,0,0,0);
+  background-image: url("data:image/gif;base64,\
+R0lGODlhAQABAPAAAACAAAAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==");
+}
+</style>
+</head><body>
+<div id="below"></div>
+<div id="above"></div>
+</body></html>
diff -r 17e9560465b0 layout/reftests/bugs/455105-2.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/455105-2.html	Thu Oct 30 05:41:46 2008 -0400
@@ -0,0 +1,31 @@
+<!doctype html>
+<html><head><title>455105-2</title>
+<style>
+div#below {
+  position: absolute;
+  top: 10px; left: 10px;
+  width: 40px;
+  height: 40px;
+  border: 10px solid red;
+  background-color: red;
+}
+div#above {
+  position: absolute;
+  top: 10px; left: 10px;
+  width: 40px;
+  height: 40px;
+  border-width: 10px;
+  border-style: solid;
+  border-color: green;
+  /* one pixel green */
+  background-image: url("data:image/gif;base64,\
+R0lGODlhAQABAPAAAACAAAAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==");
+  /* three by three pixel transparent - drawn *instead of* regular border */
+  -moz-border-image: url("data:image/gif;base64,\
+R0lGODlhAwADAPAAAAAAAAAAACH5BAEAAAAALAAAAAADAAMAAAIDhH8FADs=") 1 1;
+}
+</style>
+</head><body>
+<div id="below"></div>
+<div id="above"></div>
+</body></html>
diff -r 17e9560465b0 layout/reftests/bugs/455105-ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/455105-ref.html	Thu Oct 30 05:41:46 2008 -0400
@@ -0,0 +1,17 @@
+<!doctype html>
+<html><head><title>455105 ref</title>
+<style>
+div {
+  position: absolute;
+  top: 10px; left: 10px;
+  width: 40px;
+  height: 40px;
+  border-width: 10px;
+  border-style: solid;
+  border-color: green;
+  background-color: green;
+}
+</style>
+</head><body>
+<div></div>
+</body></html>
diff -r 17e9560465b0 layout/reftests/bugs/461512-1-ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/461512-1-ref.html	Thu Oct 30 05:41:46 2008 -0400
@@ -0,0 +1,18 @@
+<html>
+  <head>
+    <style type="text/css">
+      body { background-color: white; opacity: 0.5; }
+      p { border: 10px solid rgb(10%, 20%, 30%);
+    </style>
+  </head>
+  <body>
+    <p style="border-style: solid;">&nbsp;</p>
+    <p style="border-style: dashed;">&nbsp;</p>
+    <!-- <p style="border-style: dotted;">&nbsp;</p> -->
+    <p style="border-style: double;">&nbsp;</p>
+    <p style="border-style: ridge;">&nbsp;</p>
+    <p style="border-style: groove;">&nbsp;</p>
+    <p style="border-style: inset;">&nbsp;</p>
+    <p style="border-style: outset;">&nbsp;</p>
+  </body>
+</html>
diff -r 17e9560465b0 layout/reftests/bugs/461512-1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/461512-1.html	Thu Oct 30 05:41:46 2008 -0400
@@ -0,0 +1,18 @@
+<html>
+  <head>
+    <style type="text/css">
+      body { background-color: white; }
+      p { border: 10px solid rgba(10%, 20%, 30%, 0.5);
+    </style>
+  </head>
+  <body>
+    <p style="border-style: solid;">&nbsp;</p>
+    <p style="border-style: dashed;">&nbsp;</p>
+    <!-- <p style="border-style: dotted;">&nbsp;</p> -->
+    <p style="border-style: double;">&nbsp;</p>
+    <p style="border-style: ridge;">&nbsp;</p>
+    <p style="border-style: groove;">&nbsp;</p>
+    <p style="border-style: inset;">&nbsp;</p>
+    <p style="border-style: outset;">&nbsp;</p>
+  </body>
+</html>
diff -r 17e9560465b0 layout/reftests/bugs/reftest.list
--- a/layout/reftests/bugs/reftest.list	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/reftests/bugs/reftest.list	Thu Oct 30 05:41:46 2008 -0400
@@ -926,6 +926,9 @@
 == 451168-1.html 451168-1-ref.html
 == 452964-1.html 452964-1-ref.html
 == 454361.html about:blank
+== 455105-1.html 455105-ref.html
+== 455105-2.html 455105-ref.html
 == 455280-1.xhtml 455280-1-ref.xhtml
 fails-if(MOZ_WIDGET_TOOLKIT=="cocoa") == 456147.xul 456147-ref.html # bug 456147, but not caused by it
 == 456484-1.html 456484-1-ref.html
+fails == 461512-1.html 461512-1-ref.html # Bug 461512
diff -r 17e9560465b0 layout/reftests/text/fallback-01-ref.xhtml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/text/fallback-01-ref.xhtml	Thu Oct 30 05:41:46 2008 -0400
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="utf-8" ?>
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
+          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
+	  [<!ENTITY first "!"><!ENTITY fallback "&#x00e6;">]>
+<html xmlns="http://www.w3.org/1999/xhtml">
+<!-- U+00E6 is expected to be found in Arial and DejaVu Sans, but not
+     Devanagari MT, FrankRuehl, nor Standard Symbols L.
+     "!" is chosen as it is expected to be found in the first font found.  -->
+  <head>
+    <style>
+      p { font-size: 16.6px;
+          font-family: Devanagari MT, FrankRuehl, Standard Symbols L, Arial, DejaVu Sans; serif }
+      .fallback { font-family: Arial, DejaVu Sans, serif; }
+    </style>
+  </head>
+  <body>
+    <p><span class="fallback">&fallback;&fallback;</span>&first;<span class="fallback">&fallback;</span>&first;<span class="fallback">&fallback;</span>&first;<span class="fallback">&fallback;</span></p>
+  </body>
+</html>
diff -r 17e9560465b0 layout/reftests/text/fallback-01.xhtml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/text/fallback-01.xhtml	Thu Oct 30 05:41:46 2008 -0400
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="utf-8" ?>
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
+          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
+	  [<!ENTITY first "!"><!ENTITY fallback "&#x00e6;">]>
+<html xmlns="http://www.w3.org/1999/xhtml">
+<!-- U+00E6 is expected to be found in Arial and DejaVu Sans, but not
+     Devanagari MT, FrankRuehl, nor Standard Symbols L.
+     "!" is chosen as it is expected to be found in the first font found.  -->
+  <head>
+    <style>
+      p { font-size: 16.6px;
+          font-family: Devanagari MT, FrankRuehl, Standard Symbols L, Arial, DejaVu Sans; serif }
+      .fallback { font-family: Arial, DejaVu Sans, serif; }
+    </style>
+  </head>
+  <body>
+    <p>&fallback;&fallback;&first;&fallback;&first;&fallback;&first;<span class="fallback">&fallback;</span></p>
+  </body>
+</html>
diff -r 17e9560465b0 layout/reftests/text/reftest.list
--- a/layout/reftests/text/reftest.list	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/reftests/text/reftest.list	Thu Oct 30 05:41:46 2008 -0400
@@ -1,3 +1,4 @@
+== fallback-01.xhtml fallback-01-ref.xhtml
 == justification-1.html justification-1-ref.html
 == justification-2a.html justification-2-ref.html
 == justification-2b.html justification-2-ref.html
diff -r 17e9560465b0 layout/style/nsCSSDeclaration.cpp
--- a/layout/style/nsCSSDeclaration.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/style/nsCSSDeclaration.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -237,13 +237,8 @@
           AppendCSSValueToString(aProperty, val->mValue, aResult);
           val = val->mNext;
           if (val) {
-            if (aProperty == eCSSProperty_cursor
-                || aProperty == eCSSProperty_text_shadow
-                || aProperty == eCSSProperty_box_shadow
-#ifdef MOZ_SVG
-                || aProperty == eCSSProperty_stroke_dasharray
-#endif
-               )
+            if (nsCSSProps::PropHasFlags(aProperty,
+                                         CSS_PROPERTY_VALUE_LIST_USES_COMMAS))
               aResult.Append(PRUnichar(','));
             aResult.Append(PRUnichar(' '));
           }
@@ -552,7 +547,7 @@
            initialCount = 0, inheritCount = 0;
   CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES(p, aProperty) {
     if (*p == eCSSProperty__x_system_font ||
-         nsCSSProps::kFlagsTable[*p] & CSS_PROPERTY_DIRECTIONAL_SOURCE) {
+         nsCSSProps::PropHasFlags(*p, CSS_PROPERTY_DIRECTIONAL_SOURCE)) {
       // The system-font subproperty and the *-source properties don't count.
       continue;
     }
diff -r 17e9560465b0 layout/style/nsCSSPropList.h
--- a/layout/style/nsCSSPropList.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/style/nsCSSPropList.h	Thu Oct 30 05:41:46 2008 -0400
@@ -369,7 +369,7 @@
 CSS_PROP_BORDER(border-top-width, border_top_width, BorderTopWidth, 0, Margin, mBorderWidth.mTop, eCSSType_Value, kBorderWidthKTable)
 CSS_PROP_SHORTHAND(border-width, border_width, BorderWidth, 0)
 CSS_PROP_POSITION(bottom, bottom, Bottom, 0, Position, mOffset.mBottom, eCSSType_Value, nsnull)
-CSS_PROP_BORDER(-moz-box-shadow, box_shadow, MozBoxShadow, 0, Margin, mBoxShadow, eCSSType_ValueList, nsnull)
+CSS_PROP_BORDER(-moz-box-shadow, box_shadow, MozBoxShadow, CSS_PROPERTY_VALUE_LIST_USES_COMMAS, Margin, mBoxShadow, eCSSType_ValueList, nsnull)
 CSS_PROP_POSITION(-moz-box-sizing, box_sizing, MozBoxSizing, 0, Position, mBoxSizing, eCSSType_Value, kBoxSizingKTable) // XXX bug 3935
 CSS_PROP_TABLEBORDER(caption-side, caption_side, CaptionSide, 0, Table, mCaptionSide, eCSSType_Value, kCaptionSideKTable)
 CSS_PROP_DISPLAY(clear, clear, Clear, 0, Display, mClear, eCSSType_Value, kClearKTable)
@@ -388,7 +388,7 @@
 CSS_PROP_SHORTHAND(cue, cue, Cue, 0)
 CSS_PROP_BACKENDONLY(cue-after, cue_after, CueAfter, 0, Aural, mCueAfter, eCSSType_Value, nsnull)
 CSS_PROP_BACKENDONLY(cue-before, cue_before, CueBefore, 0, Aural, mCueBefore, eCSSType_Value, nsnull)
-CSS_PROP_USERINTERFACE(cursor, cursor, Cursor, 0, UserInterface, mCursor, eCSSType_ValueList, kCursorKTable)
+CSS_PROP_USERINTERFACE(cursor, cursor, Cursor, CSS_PROPERTY_VALUE_LIST_USES_COMMAS, UserInterface, mCursor, eCSSType_ValueList, kCursorKTable)
 CSS_PROP_VISIBILITY(direction, direction, Direction, 0, Display, mDirection, eCSSType_Value, kDirectionKTable)
 CSS_PROP_DISPLAY(display, display, Display, 0, Display, mDisplay, eCSSType_Value, kDisplayKTable)
 CSS_PROP_BACKENDONLY(elevation, elevation, Elevation, 0, Aural, mElevation, eCSSType_Value, kElevationKTable)
@@ -500,7 +500,7 @@
 CSS_PROP_TEXT(text-align, text_align, TextAlign, 0, Text, mTextAlign, eCSSType_Value, kTextAlignKTable)
 CSS_PROP_TEXTRESET(text-decoration, text_decoration, TextDecoration, 0, Text, mDecoration, eCSSType_Value, kTextDecorationKTable)
 CSS_PROP_TEXT(text-indent, text_indent, TextIndent, 0, Text, mTextIndent, eCSSType_Value, nsnull)
-CSS_PROP_TEXT(text-shadow, text_shadow, TextShadow, 0, Text, mTextShadow, eCSSType_ValueList, nsnull)
+CSS_PROP_TEXT(text-shadow, text_shadow, TextShadow, CSS_PROPERTY_VALUE_LIST_USES_COMMAS, Text, mTextShadow, eCSSType_ValueList, nsnull)
 CSS_PROP_TEXT(text-transform, text_transform, TextTransform, 0, Text, mTextTransform, eCSSType_Value, kTextTransformKTable)
 CSS_PROP_DISPLAY(-moz-transform, _moz_transform, MozTransform, 0, Display, mTransform, eCSSType_ValueList, kDisplayKTable)
 CSS_PROP_DISPLAY(-moz-transform-origin, _moz_transform_origin, MozTransformOrigin, 0, Display, mTransformOrigin, eCSSType_ValuePair, kBackgroundPositionKTable)
@@ -564,7 +564,7 @@
 CSS_PROP_SVGRESET(stop-color, stop_color, StopColor, 0, SVG, mStopColor, eCSSType_Value, nsnull)
 CSS_PROP_SVGRESET(stop-opacity, stop_opacity, StopOpacity, 0, SVG, mStopOpacity, eCSSType_Value, nsnull)
 CSS_PROP_SVG(stroke, stroke, Stroke, 0, SVG, mStroke, eCSSType_ValuePair, nsnull)
-CSS_PROP_SVG(stroke-dasharray, stroke_dasharray, StrokeDasharray, 0, SVG, mStrokeDasharray, eCSSType_ValueList, nsnull)
+CSS_PROP_SVG(stroke-dasharray, stroke_dasharray, StrokeDasharray, CSS_PROPERTY_VALUE_LIST_USES_COMMAS, SVG, mStrokeDasharray, eCSSType_ValueList, nsnull)
 CSS_PROP_SVG(stroke-dashoffset, stroke_dashoffset, StrokeDashoffset, 0, SVG, mStrokeDashoffset, eCSSType_Value, nsnull)
 CSS_PROP_SVG(stroke-linecap, stroke_linecap, StrokeLinecap, 0, SVG, mStrokeLinecap, eCSSType_Value, kStrokeLinecapKTable)
 CSS_PROP_SVG(stroke-linejoin, stroke_linejoin, StrokeLinejoin, 0, SVG, mStrokeLinejoin, eCSSType_Value, kStrokeLinejoinKTable)
diff -r 17e9560465b0 layout/style/nsCSSProps.h
--- a/layout/style/nsCSSProps.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/style/nsCSSProps.h	Thu Oct 30 05:41:46 2008 -0400
@@ -55,6 +55,7 @@
 // A property that is a *-ltr-source or *-rtl-source property for one of
 // the directional pseudo-shorthand properties.
 #define CSS_PROPERTY_DIRECTIONAL_SOURCE (1<<0)
+#define CSS_PROPERTY_VALUE_LIST_USES_COMMAS (1<<1) /* otherwise spaces */
 
 class nsCSSProps {
 public:
@@ -100,11 +101,11 @@
   static const nsCSSType       kTypeTable[eCSSProperty_COUNT_no_shorthands];
   static const nsStyleStructID kSIDTable[eCSSProperty_COUNT_no_shorthands];
   static const PRInt32* const  kKeywordTableTable[eCSSProperty_COUNT_no_shorthands];
+private:
   static const PRUint32        kFlagsTable[eCSSProperty_COUNT];
 
   // A table for shorthand properties.  The appropriate index is the
   // property ID minus eCSSProperty_COUNT_no_shorthands.
-private:
   static const nsCSSProperty *const
     kSubpropertyTable[eCSSProperty_COUNT - eCSSProperty_COUNT_no_shorthands];
 
@@ -116,6 +117,11 @@
                  "out of range");
     return nsCSSProps::kSubpropertyTable[aProperty -
                                          eCSSProperty_COUNT_no_shorthands];
+  }
+
+  static inline PRBool PropHasFlags(nsCSSProperty aProperty, PRUint32 aFlags)
+  {
+    return (nsCSSProps::kFlagsTable[aProperty] & aFlags) == aFlags;
   }
 
 #define CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES(iter_, prop_)                    \
diff -r 17e9560465b0 layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/style/nsCSSRuleProcessor.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -1047,7 +1047,7 @@
   nsIContent * const * stopPtr;
   if (aIsFromEnd) {
     stopPtr = curChildPtr - 1;
-    curChildPtr += childCount - 1;
+    curChildPtr = stopPtr + childCount;
     increment = -1;
   } else {
     increment = 1;
diff -r 17e9560465b0 layout/style/nsFontFaceLoader.cpp
--- a/layout/style/nsFontFaceLoader.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/style/nsFontFaceLoader.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -110,69 +110,14 @@
 
 }
 
-NS_IMPL_ISUPPORTS1(nsFontFaceLoader, nsIDownloadObserver)
-
-static nsresult
-MakeTempFileName(nsIFile** tempFile)
-{
-  nsresult rv;
-
-  rv = NS_GetSpecialDirectory(NS_OS_TEMP_DIR, tempFile);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  // xxx - need something a little less lame here...
-  static PRUint16 count = 0;
-  PRTime now = PR_Now();
-  PRUint32 current = (PRUint32) now;
-
-  ++count;
-  char buf[256];
-  sprintf(buf, "mozfont_%8.8x%4.4x.ttf", current, count);
-
-  rv = (*tempFile)->AppendNative(nsDependentCString(buf));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  return (*tempFile)->CreateUnique(nsIFile::NORMAL_FILE_TYPE, 0600);
-}
-
-// initiate the load
-nsresult 
-nsFontFaceLoader::Init()
-{
-#ifdef PR_LOGGING
-  if (LOG_ENABLED()) {
-    nsCAutoString fontURI;
-    mFontURI->GetSpec(fontURI);
-    LOG(("fontdownloader (%p) download start - font uri: (%s)\n", 
-         this, fontURI.get()));
-  }
-#endif  
-
-  nsresult rv;
-
-  nsCOMPtr<nsIFile> tempFile;
-  rv = MakeTempFileName(getter_AddRefs(tempFile));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  rv = NS_NewDownloader(getter_AddRefs(mDownloader), this, tempFile);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  nsCOMPtr<nsIInterfaceRequestor> sameOriginChecker 
-                                       = nsContentUtils::GetSameOriginChecker();
-
-  rv = NS_OpenURI(mDownloader, nsnull, mFontURI, nsnull, nsnull, 
-                  sameOriginChecker);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  return NS_OK;
-}
+NS_IMPL_ISUPPORTS1(nsFontFaceLoader, nsIStreamLoaderObserver)
 
 NS_IMETHODIMP
-nsFontFaceLoader::OnDownloadComplete(nsIDownloader *aDownloader,
-                                     nsIRequest   *aRequest,
-                                     nsISupports  *aContext,
-                                     nsresult     aStatus,
-                                     nsIFile      *aFile)
+nsFontFaceLoader::OnStreamComplete(nsIStreamLoader* aLoader,
+                                   nsISupports* aContext,
+                                   nsresult aStatus,
+                                   PRUint32 aStringLen,
+                                   const PRUint8* aString)
 {
 
 #ifdef PR_LOGGING
@@ -191,16 +136,9 @@
 
   PRBool fontUpdate;
 
-  if (NS_SUCCEEDED(aStatus) && aFile) {
-    // font data download succeeded, try to load the font
-    mFaceData.mFormatFlags = 0;
-    mFaceData.mFontFile = aFile;
-    mFaceData.mDownloader = aDownloader;
-  }
-
   // whether an error occurred or not, notify the user font set of the completion
   fontUpdate = mLoaderContext->mUserFontSet->OnLoadComplete(mFontEntry, 
-                                                            mFaceData, 
+                                                            aString, aStringLen,
                                                             aStatus);
 
   // when new font loaded, need to reflow
@@ -216,7 +154,7 @@
     }
   }
 
-  return NS_OK;
+  return aStatus;
 }
 
 PRBool
@@ -234,12 +172,30 @@
   if (!CheckMayLoad(ps->GetDocument(), aFontURI))
     return PR_FALSE;
 
-  nsRefPtr<nsFontFaceLoader> loader = new nsFontFaceLoader(aFontToLoad, 
-                                                           aFontURI, 
-                                                           aContext);
-  if (!loader)
+  nsRefPtr<nsFontFaceLoader> fontLoader = new nsFontFaceLoader(aFontToLoad, 
+                                                               aFontURI, 
+                                                               aContext);
+  if (!fontLoader)
     return PR_FALSE;
 
-  nsresult rv = loader->Init();
+#ifdef PR_LOGGING
+  if (LOG_ENABLED()) {
+    nsCAutoString fontURI;
+    aFontURI->GetSpec(fontURI);
+    LOG(("fontdownloader (%p) download start - font uri: (%s)\n", 
+         fontLoader.get(), fontURI.get()));
+  }
+#endif  
+
+  nsCOMPtr<nsIStreamLoader> streamLoader;
+  nsCOMPtr<nsILoadGroup> loadGroup(ps->GetDocument()->GetDocumentLoadGroup());
+  nsCOMPtr<nsIInterfaceRequestor> sameOriginChecker 
+                                       = nsContentUtils::GetSameOriginChecker();
+
+  nsresult rv = NS_NewStreamLoader(getter_AddRefs(streamLoader), aFontURI, 
+                                   fontLoader, nsnull, loadGroup, 
+                                   sameOriginChecker);
+
   return NS_SUCCEEDED(rv);
 }
+
diff -r 17e9560465b0 layout/style/nsFontFaceLoader.h
--- a/layout/style/nsFontFaceLoader.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/style/nsFontFaceLoader.h	Thu Oct 30 05:41:46 2008 -0400
@@ -42,7 +42,7 @@
 #ifndef nsFontFaceLoader_h_
 #define nsFontFaceLoader_h_
 
-#include "nsIDownloader.h"
+#include "nsIStreamLoader.h"
 #include "nsIURI.h"
 #include "gfxUserFontSet.h"
 
@@ -50,7 +50,7 @@
 class nsISupports;
 class nsPresContext;
 
-class nsFontFaceLoader : public nsIDownloadObserver
+class nsFontFaceLoader : public nsIStreamLoaderObserver
 {
 public:
 
@@ -59,7 +59,7 @@
   virtual ~nsFontFaceLoader();
 
   NS_DECL_ISUPPORTS
-  NS_DECL_NSIDOWNLOADOBSERVER 
+  NS_DECL_NSISTREAMLOADEROBSERVER 
 
   // initiate the load
   nsresult Init();  
@@ -72,8 +72,6 @@
   nsRefPtr<gfxFontEntry>              mFontEntry;
   nsCOMPtr<nsIURI>                    mFontURI;
   gfxUserFontSet::LoaderContext*      mLoaderContext;
-  gfxDownloadedFontData               mFaceData;
-  nsCOMPtr<nsIStreamListener>         mDownloader;
 };
 
 class nsFontFaceLoaderContext : public gfxUserFontSet::LoaderContext {
diff -r 17e9560465b0 layout/svg/base/src/nsSVGEffects.cpp
--- a/layout/svg/base/src/nsSVGEffects.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/svg/base/src/nsSVGEffects.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -198,19 +198,15 @@
   if (!mFrame)
     return;
 
-  if (mFrame->IsFrameOfType(nsIFrame::eSVG)) {
-    nsSVGOuterSVGFrame *outerSVGFrame = nsSVGUtils::GetOuterSVGFrame(mFrame);
-    if (outerSVGFrame) {
-      mFramePresShell->FrameConstructor()->PostRestyleEvent(
-        mFrame->GetContent(), nsReStyleHint(0),
-        nsChangeHint(nsChangeHint_RepaintFrame | nsChangeHint_UpdateEffects));
-    }
-  } else {
-    InvalidateAllContinuations(mFrame);
-    // Reflow so that changes in the filter overflow area get picked up
-    mFramePresShell->FrameNeedsReflow(
-         mFrame, nsIPresShell::eResize, NS_FRAME_IS_DIRTY);
+  // Repaint asynchronously in case the filter frame is being torn down
+  nsChangeHint changeHint =
+    nsChangeHint(nsChangeHint_RepaintFrame | nsChangeHint_UpdateEffects);
+
+  if (!mFrame->IsFrameOfType(nsIFrame::eSVG)) {
+    NS_UpdateHint(changeHint, nsChangeHint_ReflowFrame);
   }
+  mFramePresShell->FrameConstructor()->PostRestyleEvent(
+    mFrame->GetContent(), nsReStyleHint(0), changeHint);
 }
 
 void
@@ -368,7 +364,7 @@
   aFrame->DeleteProperty(nsGkAtoms::stroke);
   aFrame->DeleteProperty(nsGkAtoms::fill);
 
-  // Ensure that the filter's covered area is recalculated correctly
+  // Ensure that the filter is repainted correctly
   // We can't do that in DoUpdate as the referenced frame may not be valid
   const nsStyleSVGReset *style = aFrame->GetStyleSVGReset();
   if (style->mFilter) {
diff -r 17e9560465b0 layout/svg/base/src/nsSVGForeignObjectFrame.cpp
--- a/layout/svg/base/src/nsSVGForeignObjectFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/svg/base/src/nsSVGForeignObjectFrame.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -97,7 +97,8 @@
                               nsIFrame*   aPrevInFlow)
 {
   nsresult rv = nsSVGForeignObjectFrameBase::Init(aContent, aParent, aPrevInFlow);
-  AddStateBits(NS_STATE_SVG_PROPAGATE_TRANSFORM);
+  AddStateBits(NS_STATE_SVG_PROPAGATE_TRANSFORM | 
+               (aParent->GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD));
   if (NS_SUCCEEDED(rv)) {
     nsSVGUtils::GetOuterSVGFrame(this)->RegisterForeignObject(this);
   }
@@ -174,7 +175,7 @@
                                             nsIFrame* aForChild,
                                             PRUint32 aFlags)
 {
-  if (mParent->GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD)
+  if (GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD)
     return;
 
   nsRegion* region = (aFlags & INVALIDATE_CROSS_DOC)
@@ -291,7 +292,7 @@
 nsSVGForeignObjectFrame::TransformPointFromOuterPx(const nsPoint &aIn,
                                                    nsPoint* aOut)
 {
-  if (mParent->GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD)
+  if (GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD)
     return NS_ERROR_FAILURE;
 
   nsCOMPtr<nsIDOMSVGMatrix> tm = GetTMIncludingOffset();
@@ -355,7 +356,7 @@
 NS_IMETHODIMP
 nsSVGForeignObjectFrame::UpdateCoveredRegion()
 {
-  if (mParent->GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD)
+  if (GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD)
     return NS_ERROR_FAILURE;
 
   nsCOMPtr<nsIDOMSVGMatrix> ctm = GetCanvasTM();
@@ -452,7 +453,7 @@
 NS_IMETHODIMP
 nsSVGForeignObjectFrame::NotifyRedrawUnsuspended()
 {
-  if (!(mParent->GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD)) {
+  if (!(GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD)) {
     if (GetStateBits() & NS_STATE_SVG_DIRTY) {
       UpdateGraphic();
     } else {
@@ -484,7 +485,7 @@
 {
   *_retval = nsnull;
 
-  if (mParent->GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD)
+  if (GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD)
     return NS_ERROR_FAILURE;
 
   nsCOMPtr<nsIDOMSVGMatrix> ctm = GetCanvasTM();
@@ -612,7 +613,7 @@
   if (IsDisabled())
     return;
 
-  if (mParent->GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD)
+  if (GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD)
     return;
 
   nsPresContext *presContext = PresContext();
diff -r 17e9560465b0 layout/svg/base/src/nsSVGGlyphFrame.cpp
--- a/layout/svg/base/src/nsSVGGlyphFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/svg/base/src/nsSVGGlyphFrame.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -226,9 +226,9 @@
 #define PRECISE_SIZE   200
 
 /* virtual */ void
-nsSVGGlyphFrame::DidSetStyleContext()
+nsSVGGlyphFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
 {
-  nsSVGGlyphFrameBase::DidSetStyleContext();
+  nsSVGGlyphFrameBase::DidSetStyleContext(aOldStyleContext);
 
   if (!(GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
     ClearTextRun();
diff -r 17e9560465b0 layout/svg/base/src/nsSVGGlyphFrame.h
--- a/layout/svg/base/src/nsSVGGlyphFrame.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/svg/base/src/nsSVGGlyphFrame.h	Thu Oct 30 05:41:46 2008 -0400
@@ -81,7 +81,7 @@
                                    nsIContent*     aChild,
                                    PRBool          aAppend);
 
-  virtual void DidSetStyleContext();
+  virtual void DidSetStyleContext(nsStyleContext* aOldStyleContext);
 
   NS_IMETHOD  SetSelected(nsPresContext* aPresContext,
                           nsIDOMRange*    aRange,
diff -r 17e9560465b0 layout/svg/base/src/nsSVGGradientFrame.cpp
--- a/layout/svg/base/src/nsSVGGradientFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/svg/base/src/nsSVGGradientFrame.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -64,10 +64,10 @@
 // nsIFrame methods:
 
 /* virtual */ void
-nsSVGGradientFrame::DidSetStyleContext()
+nsSVGGradientFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
 {
   nsSVGEffects::InvalidateRenderingObservers(this);
-  nsSVGGradientFrameBase::DidSetStyleContext();
+  nsSVGGradientFrameBase::DidSetStyleContext(aOldStyleContext);
 }
 
 NS_IMETHODIMP
diff -r 17e9560465b0 layout/svg/base/src/nsSVGGradientFrame.h
--- a/layout/svg/base/src/nsSVGGradientFrame.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/svg/base/src/nsSVGGradientFrame.h	Thu Oct 30 05:41:46 2008 -0400
@@ -65,7 +65,7 @@
                                   float aGraphicOpacity);
 
   // nsIFrame interface:
-  virtual void DidSetStyleContext();
+  virtual void DidSetStyleContext(nsStyleContext* aOldStyleContext);
 
   NS_IMETHOD AttributeChanged(PRInt32         aNameSpaceID,
                               nsIAtom*        aAttribute,
diff -r 17e9560465b0 layout/svg/base/src/nsSVGLeafFrame.cpp
--- a/layout/svg/base/src/nsSVGLeafFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/svg/base/src/nsSVGLeafFrame.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -57,7 +57,7 @@
   }
 #endif
 
-  virtual void DidSetStyleContext();
+  virtual void DidSetStyleContext(nsStyleContext* aOldStyleContext);
 };
 
 nsIFrame*
@@ -67,8 +67,8 @@
 }
 
 /* virtual */ void
-nsSVGLeafFrame::DidSetStyleContext()
+nsSVGLeafFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
 {
-  nsFrame::DidSetStyleContext();
+  nsFrame::DidSetStyleContext(aOldStyleContext);
   nsSVGEffects::InvalidateRenderingObservers(this);
 }
diff -r 17e9560465b0 layout/svg/base/src/nsSVGOuterSVGFrame.cpp
--- a/layout/svg/base/src/nsSVGOuterSVGFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/svg/base/src/nsSVGOuterSVGFrame.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -831,7 +831,8 @@
 }
 
 void
-nsSVGOuterSVGFrame::UnregisterForeignObject(nsSVGForeignObjectFrame* aFrame) {
+nsSVGOuterSVGFrame::UnregisterForeignObject(nsSVGForeignObjectFrame* aFrame)
+{
   NS_ASSERTION(aFrame, "Who on earth is calling us?!");
   NS_ASSERTION(mForeignObjectHash.GetEntry(aFrame),
                "nsSVGForeignObjectFrame not in registry!");
diff -r 17e9560465b0 layout/svg/base/src/nsSVGPathGeometryFrame.cpp
--- a/layout/svg/base/src/nsSVGPathGeometryFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/svg/base/src/nsSVGPathGeometryFrame.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -84,9 +84,9 @@
 }
 
 /* virtual */ void
-nsSVGPathGeometryFrame::DidSetStyleContext()
+nsSVGPathGeometryFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
 {
-  nsSVGPathGeometryFrameBase::DidSetStyleContext();
+  nsSVGPathGeometryFrameBase::DidSetStyleContext(aOldStyleContext);
 
   nsSVGOuterSVGFrame *outerSVGFrame = nsSVGUtils::GetOuterSVGFrame(this);
   if (outerSVGFrame) {
diff -r 17e9560465b0 layout/svg/base/src/nsSVGPathGeometryFrame.h
--- a/layout/svg/base/src/nsSVGPathGeometryFrame.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/svg/base/src/nsSVGPathGeometryFrame.h	Thu Oct 30 05:41:46 2008 -0400
@@ -80,7 +80,7 @@
                                nsIAtom*        aAttribute,
                                PRInt32         aModType);
 
-  virtual void DidSetStyleContext();
+  virtual void DidSetStyleContext(nsStyleContext* aOldStyleContext);
 
   /**
    * Get the "type" of the frame
diff -r 17e9560465b0 layout/svg/base/src/nsSVGPatternFrame.cpp
--- a/layout/svg/base/src/nsSVGPatternFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/svg/base/src/nsSVGPatternFrame.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -77,10 +77,10 @@
 // nsIFrame methods:
 
 /* virtual */ void
-nsSVGPatternFrame::DidSetStyleContext()
+nsSVGPatternFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
 {
   nsSVGEffects::InvalidateRenderingObservers(this);
-  nsSVGPatternFrameBase::DidSetStyleContext();
+  nsSVGPatternFrameBase::DidSetStyleContext(aOldStyleContext);
 }
 
 NS_IMETHODIMP
diff -r 17e9560465b0 layout/svg/base/src/nsSVGPatternFrame.h
--- a/layout/svg/base/src/nsSVGPatternFrame.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/svg/base/src/nsSVGPatternFrame.h	Thu Oct 30 05:41:46 2008 -0400
@@ -80,7 +80,7 @@
   virtual already_AddRefed<nsIDOMSVGMatrix> GetCanvasTM();
 
   // nsIFrame interface:
-  virtual void DidSetStyleContext();
+  virtual void DidSetStyleContext(nsStyleContext* aOldStyleContext);
 
   NS_IMETHOD AttributeChanged(PRInt32         aNameSpaceID,
                               nsIAtom*        aAttribute,
diff -r 17e9560465b0 layout/svg/base/src/nsSVGStopFrame.cpp
--- a/layout/svg/base/src/nsSVGStopFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/svg/base/src/nsSVGStopFrame.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -58,7 +58,7 @@
 
 public:
   // nsIFrame interface:
-  virtual void DidSetStyleContext();
+  virtual void DidSetStyleContext(nsStyleContext* aOldStyleContext);
 
   NS_IMETHOD AttributeChanged(PRInt32         aNameSpaceID,
                               nsIAtom*        aAttribute,
@@ -92,9 +92,9 @@
 // nsIFrame methods:
 
 /* virtual */ void
-nsSVGStopFrame::DidSetStyleContext()
+nsSVGStopFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
 {
-  nsSVGStopFrameBase::DidSetStyleContext();
+  nsSVGStopFrameBase::DidSetStyleContext(aOldStyleContext);
   nsSVGEffects::InvalidateRenderingObservers(this);
 }
 
diff -r 17e9560465b0 layout/tables/Makefile.in
--- a/layout/tables/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/tables/Makefile.in	Thu Oct 30 05:41:46 2008 -0400
@@ -100,6 +100,7 @@
 LOCAL_INCLUDES	= \
 		-I$(srcdir)/../base \
 		-I$(srcdir)/../generic \
+		-I$(srcdir)/../style \
 		-I$(srcdir)/../xul/base/src \
 		-I$(srcdir)/../../content/html/content/src \
 		-I$(srcdir)/../../content/base/src \
diff -r 17e9560465b0 layout/tables/nsTableCellFrame.cpp
--- a/layout/tables/nsTableCellFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/tables/nsTableCellFrame.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -237,6 +237,25 @@
   return NS_OK;
 }
 
+/* virtual */ void
+nsTableCellFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
+{
+  if (!aOldStyleContext) //avoid this on init
+    return;
+     
+  nsTableFrame* tableFrame = nsTableFrame::GetTableFrame(this);
+    
+  if (tableFrame->IsBorderCollapse() &&
+      tableFrame->BCRecalcNeeded(aOldStyleContext, GetStyleContext())) {
+    PRInt32 colIndex, rowIndex;
+    GetColIndex(colIndex);
+    GetRowIndex(rowIndex);
+    nsRect damageArea(colIndex, rowIndex, GetColSpan(), GetRowSpan());
+    tableFrame->SetBCDamageArea(damageArea);
+  }
+}
+
+     
 NS_IMETHODIMP
 nsTableCellFrame::AppendFrames(nsIAtom*        aListName,
                                nsIFrame*       aFrameList)
diff -r 17e9560465b0 layout/tables/nsTableCellFrame.h
--- a/layout/tables/nsTableCellFrame.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/tables/nsTableCellFrame.h	Thu Oct 30 05:41:46 2008 -0400
@@ -92,6 +92,9 @@
                                nsIAtom*        aAttribute,
                                PRInt32         aModType);
 
+  /** @see nsIFrame::DidSetStyleContext */
+  virtual void DidSetStyleContext(nsStyleContext* aOldStyleContext);
+  
   // table cells contain an area frame which does most of the work, and
   // so these functions should never be called. They assert and return
   // NS_ERROR_NOT_IMPLEMENTED
diff -r 17e9560465b0 layout/tables/nsTableColFrame.cpp
--- a/layout/tables/nsTableColFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/tables/nsTableColFrame.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -81,6 +81,22 @@
                "spanned content cols must be continuations");
   PRUint32 type = aType - eColContent;
   mState |= (type << COL_TYPE_OFFSET);
+}
+
+/* virtual */ void
+nsTableColFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
+{
+  if (!aOldStyleContext) //avoid this on init
+    return;
+     
+  nsTableFrame* tableFrame = nsTableFrame::GetTableFrame(this);
+    
+  if (tableFrame->IsBorderCollapse() &&
+      tableFrame->BCRecalcNeeded(aOldStyleContext, GetStyleContext())) {
+    nsRect damageArea = nsRect(GetColIndex(), 0, 1, tableFrame->GetRowCount());
+    tableFrame->SetBCDamageArea(damageArea);
+  }
+  return;
 }
 
 void nsTableColFrame::SetContinuousBCBorderWidth(PRUint8     aForSide,
diff -r 17e9560465b0 layout/tables/nsTableColFrame.h
--- a/layout/tables/nsTableColFrame.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/tables/nsTableColFrame.h	Thu Oct 30 05:41:46 2008 -0400
@@ -69,7 +69,9 @@
     */
   friend nsTableColFrame* NS_NewTableColFrame(nsIPresShell* aPresShell,
                                               nsStyleContext*  aContext);
-
+  /** @see nsIFrame::DidSetStyleContext */
+  virtual void DidSetStyleContext(nsStyleContext* aOldStyleContext);
+  
   PRInt32 GetColIndex() const;
   
   void SetColIndex (PRInt32 aColIndex);
diff -r 17e9560465b0 layout/tables/nsTableColGroupFrame.cpp
--- a/layout/tables/nsTableColGroupFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/tables/nsTableColGroupFrame.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -203,6 +203,23 @@
 
   mFrames.AppendFrames(this, aChildList);
   return NS_OK;
+}
+
+/* virtual */ void
+nsTableColGroupFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
+{
+  if (!aOldStyleContext) //avoid this on init
+    return;
+     
+  nsTableFrame* tableFrame = nsTableFrame::GetTableFrame(this);
+    
+  if (tableFrame->IsBorderCollapse() &&
+      tableFrame->BCRecalcNeeded(aOldStyleContext, GetStyleContext())) {
+    nsRect damageArea(GetFirstColumn()->GetColIndex(), 0, GetColCount(),
+                      tableFrame->GetRowCount());
+    tableFrame->SetBCDamageArea(damageArea);
+  }
+  return;
 }
 
 NS_IMETHODIMP
diff -r 17e9560465b0 layout/tables/nsTableColGroupFrame.h
--- a/layout/tables/nsTableColGroupFrame.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/tables/nsTableColGroupFrame.h	Thu Oct 30 05:41:46 2008 -0400
@@ -108,6 +108,9 @@
     */
   static PRBool GetLastRealColGroup(nsTableFrame* aTableFrame, 
                                     nsIFrame**    aLastColGroup);
+
+  /** @see nsIFrame::DidSetStyleContext */
+  virtual void DidSetStyleContext(nsStyleContext* aOldStyleContext);
 
   /** @see nsIFrame::AppendFrames, InsertFrames, RemoveFrame
     */
diff -r 17e9560465b0 layout/tables/nsTableFrame.cpp
--- a/layout/tables/nsTableFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/tables/nsTableFrame.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -274,6 +274,7 @@
   mColGroups.DestroyFrames();
   nsHTMLContainerFrame::Destroy();
 }
+
 
 // Make sure any views are positioned properly
 void
@@ -2226,9 +2227,19 @@
   return width;
 }
 
-/* virtual */ void
-nsTableFrame::DidSetStyleContext()
-{
+
+   /* virtual */ void
+nsTableFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
+{
+   if (!aOldStyleContext) //avoid this on init
+     return;
+   
+   if (IsBorderCollapse() &&
+       BCRecalcNeeded(aOldStyleContext, GetStyleContext())) {
+     nsRect damageArea(0, 0, GetColCount(), GetRowCount());
+     SetBCDamageArea(damageArea);
+   }
+
    //avoid this on init or nextinflow
    if (!mTableLayoutStrategy || GetPrevInFlow())
      return;
@@ -2360,8 +2371,11 @@
         nsIFrame* kidFrame;
         PRBool isColGroup = (NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP ==
                              display->mDisplay);
+        nsTableColGroupFrame* lastColGroup;
         if (isColGroup) {
           kidFrame = mColGroups.FirstChild();
+          nsTableColGroupFrame::GetLastRealColGroup(this,
+                                                   (nsIFrame**) &lastColGroup);
         }
         else {
           kidFrame = mFrames.FirstChild();
@@ -2370,10 +2384,9 @@
         PRInt32 lastIndex = -1;
         while (kidFrame) {
           if (isColGroup) {
-            nsTableColGroupType groupType =
-              ((nsTableColGroupFrame *)kidFrame)->GetColType();
-            if (eColGroupAnonymousCell == groupType) {
-              continue;
+            if (kidFrame == lastColGroup) {
+              aPrevFrame = kidFrame; // there is no real colgroup after this one
+              break;
             }
           }
           pseudoFrame = kidFrame;
@@ -4676,8 +4689,35 @@
   width = styleData->GetActualBorderWidth(aSide);
   aWidth = nsPresContext::AppUnitsToIntCSSPixels(width);
 }
- 
- 
+
+class nsDelayedCalcBCBorders : public nsRunnable {
+public:
+  nsDelayedCalcBCBorders(nsIFrame* aFrame) :
+    mFrame(aFrame) {}
+
+  NS_IMETHOD Run() {
+    if (mFrame) {
+      nsTableFrame* tableFrame = static_cast <nsTableFrame*>(mFrame.GetFrame());
+      if (tableFrame) {
+        if (tableFrame->NeedToCalcBCBorders()) {
+          tableFrame->CalcBCBorders();
+        }
+      }
+    }
+    return NS_OK;
+  }
+private:
+  nsWeakFrame mFrame;
+};
+  
+PRBool
+nsTableFrame::BCRecalcNeeded(nsStyleContext* aOldStyleContext,
+                             nsStyleContext* aNewStyleContext)
+{
+  // XXX bernd temp disabled till I figure out the mac failure
+  return PR_FALSE;
+}
+
 /* BCCellBorder represents a border segment which can be either a horizontal
  * or a vertical segment. For each segment we need to know the color, width,
  * style, who owns it and how long it is in cellmap coordinates.
diff -r 17e9560465b0 layout/tables/nsTableFrame.h
--- a/layout/tables/nsTableFrame.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/tables/nsTableFrame.h	Thu Oct 30 05:41:46 2008 -0400
@@ -198,7 +198,7 @@
   virtual void Destroy();
   
   /** @see nsIFrame::DidSetStyleContext */
-  virtual void DidSetStyleContext();
+  virtual void DidSetStyleContext(nsStyleContext* aOldStyleContext);
 
   NS_IMETHOD AppendFrames(nsIAtom*        aListName,
                           nsIFrame*       aFrameList);
@@ -307,9 +307,11 @@
    *  @param aGetInner - get only inner half of border width
    */
   nscoord GetContinuousLeftBCBorderWidth() const;
-
+  friend class nsDelayedCalcBCBorders;
+  
   void SetBCDamageArea(const nsRect& aValue);
-
+  PRBool BCRecalcNeeded(nsStyleContext* aOldStyleContext,
+                        nsStyleContext* aNewStyleContext);
   void PaintBCBorders(nsIRenderingContext& aRenderingContext,
                       const nsRect&        aDirtyRect);
 
diff -r 17e9560465b0 layout/tables/nsTableOuterFrame.cpp
--- a/layout/tables/nsTableOuterFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/tables/nsTableOuterFrame.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -1047,21 +1047,6 @@
   return NS_OK;
 }
 
-// helper method for determining if this is a nested table or not
-PRBool 
-nsTableOuterFrame::IsNested(const nsHTMLReflowState& aReflowState) const
-{
-  // Walk up the reflow state chain until we find a cell or the root
-  const nsHTMLReflowState* rs = aReflowState.parentReflowState;
-  while (rs) {
-    if (nsGkAtoms::tableFrame == rs->frame->GetType()) {
-      return PR_TRUE;
-    }
-    rs = rs->parentReflowState;
-  }
-  return PR_FALSE;
-}
-
 void
 nsTableOuterFrame::OuterBeginReflowChild(nsPresContext*           aPresContext,
                                          nsIFrame*                aChildFrame,
diff -r 17e9560465b0 layout/tables/nsTableOuterFrame.h
--- a/layout/tables/nsTableOuterFrame.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/tables/nsTableOuterFrame.h	Thu Oct 30 05:41:46 2008 -0400
@@ -198,8 +198,6 @@
   NS_IMETHOD GetIndexByRowAndColumn(PRInt32 aRow, PRInt32 aColumn, PRInt32 *aIndex);
   NS_IMETHOD GetRowAndColumnByIndex(PRInt32 aIndex, PRInt32 *aRow, PRInt32 *aColumn);
 
-  PRBool IsNested(const nsHTMLReflowState& aReflowState) const;
-
 protected:
 
 
diff -r 17e9560465b0 layout/tables/nsTableRowFrame.cpp
--- a/layout/tables/nsTableRowFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/tables/nsTableRowFrame.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -177,6 +177,21 @@
   return rv;
 }
 
+/* virtual */ void
+nsTableRowFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
+{
+  if (!aOldStyleContext) //avoid this on init
+    return;
+     
+  nsTableFrame* tableFrame = nsTableFrame::GetTableFrame(this);
+    
+  if (tableFrame->IsBorderCollapse() &&
+      tableFrame->BCRecalcNeeded(aOldStyleContext, GetStyleContext())) {
+    nsRect damageArea(0, GetRowIndex(), tableFrame->GetColCount(), 1);
+    tableFrame->SetBCDamageArea(damageArea);
+  }
+  return;
+}
 
 NS_IMETHODIMP
 nsTableRowFrame::AppendFrames(nsIAtom*        aListName,
diff -r 17e9560465b0 layout/tables/nsTableRowFrame.h
--- a/layout/tables/nsTableRowFrame.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/tables/nsTableRowFrame.h	Thu Oct 30 05:41:46 2008 -0400
@@ -72,7 +72,9 @@
   NS_IMETHOD Init(nsIContent*      aContent,
                   nsIFrame*        aParent,
                   nsIFrame*        aPrevInFlow);
-
+  /** @see nsIFrame::DidSetStyleContext */
+  virtual void DidSetStyleContext(nsStyleContext* aOldStyleContext);
+  
   NS_IMETHOD AppendFrames(nsIAtom*        aListName,
                           nsIFrame*       aFrameList);
   NS_IMETHOD InsertFrames(nsIAtom*        aListName,
diff -r 17e9560465b0 layout/tables/nsTableRowGroupFrame.cpp
--- a/layout/tables/nsTableRowGroupFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/tables/nsTableRowGroupFrame.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -64,17 +64,6 @@
 {
 }
 
-/* ----------- nsTableRowGroupFrame ---------- */
-nsrefcnt nsTableRowGroupFrame::AddRef(void)
-{
-  return 1;//implementation of nsLineIterator
-}
-
-nsrefcnt nsTableRowGroupFrame::Release(void)
-{
-  return 1;//implementation of nsLineIterator
-}
-
 NS_IMETHODIMP
 nsTableRowGroupFrame::QueryInterface(const nsIID& aIID, void** aInstancePtr)
 {
@@ -83,14 +72,6 @@
   static NS_DEFINE_IID(kITableRowGroupIID, NS_ITABLEROWGROUPFRAME_IID);
   if (aIID.Equals(kITableRowGroupIID)) {
     *aInstancePtr = (void*)this;
-    return NS_OK;
-  }
-  if (aIID.Equals(NS_GET_IID(nsILineIteratorNavigator))) {
-    *aInstancePtr = static_cast<nsILineIteratorNavigator*>(this);
-    return NS_OK;
-  }
-  if (aIID.Equals(NS_GET_IID(nsILineIterator))) {
-    *aInstancePtr = static_cast<nsILineIterator*>(this);
     return NS_OK;
   }
 
@@ -1395,6 +1376,23 @@
   return rv;
 }
 
+/* virtual */ void
+nsTableRowGroupFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
+{
+  if (!aOldStyleContext) //avoid this on init
+    return;
+     
+  nsTableFrame* tableFrame = nsTableFrame::GetTableFrame(this);
+    
+  if (tableFrame->IsBorderCollapse() &&
+      tableFrame->BCRecalcNeeded(aOldStyleContext, GetStyleContext())) {
+    nsRect damageArea(0, GetStartRowIndex(), tableFrame->GetColCount(),
+                      GetRowCount());
+    tableFrame->SetBCDamageArea(damageArea);
+  }
+  return;
+}
+
 NS_IMETHODIMP
 nsTableRowGroupFrame::AppendFrames(nsIAtom*        aListName,
                                    nsIFrame*       aFrameList)
@@ -1636,23 +1634,18 @@
 }
 
 //nsILineIterator methods
-NS_IMETHODIMP
-nsTableRowGroupFrame::GetNumLines(PRInt32* aResult)
+PRInt32
+nsTableRowGroupFrame::GetNumLines()
 {
-  NS_ENSURE_ARG_POINTER(aResult);
-  *aResult = GetRowCount();
-  return NS_OK;
+  return GetRowCount();
 }
 
-NS_IMETHODIMP
-nsTableRowGroupFrame::GetDirection(PRBool* aIsRightToLeft)
+PRBool
+nsTableRowGroupFrame::GetDirection()
 {
-  NS_ENSURE_ARG_POINTER(aIsRightToLeft);
-  // rtl is table wide @see nsTableIterator
   nsTableFrame* table = nsTableFrame::GetTableFrame(this);
-  *aIsRightToLeft = (NS_STYLE_DIRECTION_RTL ==
-                     table->GetStyleVisibility()->mDirection);
-  return NS_OK;
+  return (NS_STYLE_DIRECTION_RTL ==
+          table->GetStyleVisibility()->mDirection);
 }
   
 NS_IMETHODIMP
@@ -1697,28 +1690,25 @@
   return NS_ERROR_FAILURE;
 }
   
-NS_IMETHODIMP
-nsTableRowGroupFrame::FindLineContaining(nsIFrame* aFrame, 
-                                         PRInt32*  aLineNumberResult)
+PRInt32
+nsTableRowGroupFrame::FindLineContaining(nsIFrame* aFrame)
 {
   NS_ENSURE_ARG_POINTER(aFrame);
-  NS_ENSURE_ARG_POINTER(aLineNumberResult);
   
   NS_ASSERTION((aFrame->GetType() == nsGkAtoms::tableRowFrame),
                "RowGroup contains a frame that is not a row");
 
   nsTableRowFrame* rowFrame = (nsTableRowFrame*)aFrame;
-  *aLineNumberResult = rowFrame->GetRowIndex() - GetStartRowIndex();
-
-  return NS_OK;
+  return rowFrame->GetRowIndex() - GetStartRowIndex();
 }
 
-NS_IMETHODIMP
-nsTableRowGroupFrame::FindLineAt(nscoord  aY, 
-                                 PRInt32* aLineNumberResult)
+PRInt32
+nsTableRowGroupFrame::FindLineAt(nscoord  aY)
 {
+  NS_NOTREACHED("Not implemented");
   return NS_ERROR_NOT_IMPLEMENTED;
 }
+
 #ifdef IBMBIDI
 NS_IMETHODIMP
 nsTableRowGroupFrame::CheckLineOrder(PRInt32                  aLine,
diff -r 17e9560465b0 layout/tables/nsTableRowGroupFrame.h
--- a/layout/tables/nsTableRowGroupFrame.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/tables/nsTableRowGroupFrame.h	Thu Oct 30 05:41:46 2008 -0400
@@ -96,11 +96,12 @@
  * @see nsTableFrame
  * @see nsTableRowFrame
  */
-class nsTableRowGroupFrame : public nsHTMLContainerFrame, public nsILineIteratorNavigator
+class nsTableRowGroupFrame
+  : public nsHTMLContainerFrame
+  , public nsILineIterator
 {
 public:
-  // nsISupports
-  NS_DECL_ISUPPORTS_INHERITED
+  NS_IMETHOD QueryInterface(const nsIID &aIID, void **aInstancePtr);
 
   /** instantiate a new instance of nsTableRowFrame.
     * @param aPresShell the pres shell for this frame
@@ -109,7 +110,9 @@
     */
   friend nsIFrame* NS_NewTableRowGroupFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   virtual ~nsTableRowGroupFrame();
-
+  /** @see nsIFrame::DidSetStyleContext */
+  virtual void DidSetStyleContext(nsStyleContext* aOldStyleContext);
+  
   NS_IMETHOD AppendFrames(nsIAtom*        aListName,
                           nsIFrame*       aFrameList);
   
@@ -225,6 +228,8 @@
 
 // nsILineIterator methods
 public:
+  virtual void DisposeLineIterator() { }
+
   // The table row is the equivalent to a line in block layout. 
   // The nsILineIterator assumes that a line resides in a block, this role is
   // fullfilled by the row group. Rows in table are counted relative to the
@@ -233,14 +238,14 @@
   // row index of the first row in the row group.
    
   /** Get the number of rows in a row group
-    * @param aResult - pointer that holds the number of lines in a row group
+    * @return the number of lines in a row group
     */
-  NS_IMETHOD GetNumLines(PRInt32* aResult);
+  virtual PRInt32 GetNumLines();
 
   /** @see nsILineIterator.h GetDirection
-    * @param aIsRightToLeft - true if the table is rtl
+    * @return true if the table is rtl
     */
-  NS_IMETHOD GetDirection(PRBool* aIsRightToLeft);
+  virtual PRBool GetDirection();
   
   /** Return structural information about a line. 
     * @param aLineNumber       - the index of the row relative to the row group
@@ -262,16 +267,15 @@
   
   /** Given a frame that's a child of the rowgroup, find which line its on.
     * @param aFrame       - frame, should be a row
-    * @param aIndexResult - row index relative to the row group if this a row
-    *                       frame. aIndexResult will be set to -1 if the frame
-    *                       cannot be found.
+    * @return               row index relative to the row group if this a row
+    *                       frame. -1 if the frame cannot be found.
     */
-  NS_IMETHOD FindLineContaining(nsIFrame* aFrame, PRInt32* aLineNumberResult);
+  virtual PRInt32 FindLineContaining(nsIFrame* aFrame);
   
   /** not implemented
     * the function is also not called in our tree
     */
-  NS_IMETHOD FindLineAt(nscoord aY, PRInt32* aLineNumberResult);
+  virtual PRInt32 FindLineAt(nscoord aY);
 
   /** Find the orginating cell frame on a row that is the nearest to the
     * coordinate X.
@@ -371,6 +375,8 @@
            GetStyleDisplay()->mOverflowY == NS_STYLE_OVERFLOW_CLIP;
   }
 
+  virtual nsILineIterator* GetLineIterator() { return this; }
+
 protected:
   nsTableRowGroupFrame(nsStyleContext* aContext);
 
diff -r 17e9560465b0 layout/xul/base/src/nsBoxFrame.cpp
--- a/layout/xul/base/src/nsBoxFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/xul/base/src/nsBoxFrame.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -180,9 +180,9 @@
 }
 
 /* virtual */ void
-nsBoxFrame::DidSetStyleContext()
+nsBoxFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
 {
-  nsContainerFrame::DidSetStyleContext();
+  nsContainerFrame::DidSetStyleContext(aOldStyleContext);
 
   // The values that CacheAttributes() computes depend on our style,
   // so we need to recompute them here...
diff -r 17e9560465b0 layout/xul/base/src/nsBoxFrame.h
--- a/layout/xul/base/src/nsBoxFrame.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/xul/base/src/nsBoxFrame.h	Thu Oct 30 05:41:46 2008 -0400
@@ -139,7 +139,7 @@
   NS_IMETHOD  SetInitialChildList(nsIAtom*        aListName,
                                   nsIFrame*       aChildList);
 
-  virtual void DidSetStyleContext();
+  virtual void DidSetStyleContext(nsStyleContext* aOldStyleContext);
 
   virtual nsIAtom* GetType() const;
 
diff -r 17e9560465b0 layout/xul/base/src/nsImageBoxFrame.cpp
--- a/layout/xul/base/src/nsImageBoxFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/xul/base/src/nsImageBoxFrame.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -390,9 +390,9 @@
 // When the style context changes, make sure that all of our image is up to date.
 //
 /* virtual */ void
-nsImageBoxFrame::DidSetStyleContext()
+nsImageBoxFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
 {
-  nsLeafBoxFrame::DidSetStyleContext();
+  nsLeafBoxFrame::DidSetStyleContext(aOldStyleContext);
 
   // Fetch our subrect.
   const nsStyleList* myList = GetStyleList();
diff -r 17e9560465b0 layout/xul/base/src/nsImageBoxFrame.h
--- a/layout/xul/base/src/nsImageBoxFrame.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/xul/base/src/nsImageBoxFrame.h	Thu Oct 30 05:41:46 2008 -0400
@@ -90,7 +90,7 @@
                               nsIAtom* aAttribute,
                               PRInt32 aModType);
 
-  virtual void DidSetStyleContext();
+  virtual void DidSetStyleContext(nsStyleContext* aOldStyleContext);
 
   virtual void Destroy();
 
diff -r 17e9560465b0 layout/xul/base/src/nsListBoxBodyFrame.cpp
--- a/layout/xul/base/src/nsListBoxBodyFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/xul/base/src/nsListBoxBodyFrame.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -224,8 +224,12 @@
 // QueryInterface
 //
 NS_INTERFACE_MAP_BEGIN(nsListBoxBodyFrame)
-  NS_INTERFACE_MAP_ENTRY(nsIListBoxObject)
   NS_INTERFACE_MAP_ENTRY(nsIScrollbarMediator)
+  if (aIID.Equals(NS_GET_IID(nsListBoxBodyFrame))) {
+    *aInstancePtr = this;
+    return NS_OK;
+  }
+  else
 NS_INTERFACE_MAP_END_INHERITING(nsBoxFrame)
 
 
@@ -500,28 +504,28 @@
 
 ///////// nsIListBoxObject ///////////////
 
-NS_IMETHODIMP
+nsresult
 nsListBoxBodyFrame::GetRowCount(PRInt32* aResult)
 {
   *aResult = GetRowCount();
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 nsListBoxBodyFrame::GetNumberOfVisibleRows(PRInt32 *aResult)
 {
   *aResult= mRowHeight ? GetAvailableHeight() / mRowHeight : 0;
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 nsListBoxBodyFrame::GetIndexOfFirstVisibleRow(PRInt32 *aResult)
 {
   *aResult = mCurrentIndex;
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 nsListBoxBodyFrame::EnsureIndexIsVisible(PRInt32 aRowIndex)
 {
   NS_ASSERTION(aRowIndex >= 0, "Ensure row is visible called with a negative number!");
@@ -559,7 +563,7 @@
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 nsListBoxBodyFrame::ScrollByLines(PRInt32 aNumLines)
 {
   PRInt32 scrollIndex, visibleRows;
@@ -592,7 +596,7 @@
 }
 
 // walks the DOM to get the zero-based row index of the content
-NS_IMETHODIMP
+nsresult
 nsListBoxBodyFrame::GetIndexOfItem(nsIDOMElement* aItem, PRInt32* _retval)
 {
   if (aItem) {
@@ -622,7 +626,7 @@
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 nsListBoxBodyFrame::GetItemAtIndex(PRInt32 aIndex, nsIDOMElement** aItem)
 {
   *aItem = nsnull;
@@ -816,7 +820,7 @@
 
 ////////// scrolling
 
-NS_IMETHODIMP
+nsresult
 nsListBoxBodyFrame::ScrollToIndex(PRInt32 aRowIndex)
 {
   if (( aRowIndex < 0 ) || (mRowHeight == 0))
diff -r 17e9560465b0 layout/xul/base/src/nsListBoxBodyFrame.h
--- a/layout/xul/base/src/nsListBoxBodyFrame.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/xul/base/src/nsListBoxBodyFrame.h	Thu Oct 30 05:41:46 2008 -0400
@@ -51,6 +51,10 @@
 #include "nsThreadUtils.h"
 #include "nsPIBoxObject.h"
 
+#define NS_LISTBOXBODYFRAME_IID \
+{ 0x6e0acf13, 0x0b07, 0x481d, \
+  { 0xa3, 0x39, 0x4c, 0xb6, 0x44, 0xbc, 0x1b, 0xd8 } }
+
 class nsListScrollSmoother;
 nsIFrame* NS_NewListBoxBodyFrame(nsIPresShell* aPresShell,
                                  nsStyleContext* aContext,
@@ -58,7 +62,6 @@
                                  nsIBoxLayout* aLayoutManager = nsnull);
 
 class nsListBoxBodyFrame : public nsBoxFrame,
-                           public nsIListBoxObject,
                            public nsIScrollbarMediator,
                            public nsIReflowCallback
 {
@@ -66,8 +69,19 @@
   virtual ~nsListBoxBodyFrame();
 
 public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_LISTBOXBODYFRAME_IID)
+
   NS_DECL_ISUPPORTS
-  NS_DECL_NSILISTBOXOBJECT
+
+  // non-virtual nsIListBoxObject
+  nsresult GetRowCount(PRInt32 *aResult);
+  nsresult GetNumberOfVisibleRows(PRInt32 *aResult);
+  nsresult GetIndexOfFirstVisibleRow(PRInt32 *aResult);
+  nsresult EnsureIndexIsVisible(PRInt32 aRowIndex);
+  nsresult ScrollToIndex(PRInt32 aRowIndex);
+  nsresult ScrollByLines(PRInt32 aNumLines);
+  nsresult GetItemAtIndex(PRInt32 aIndex, nsIDOMElement **aResult);
+  nsresult GetIndexOfItem(nsIDOMElement *aItem, PRInt32 *aResult);
 
   friend nsIFrame* NS_NewListBoxBodyFrame(nsIPresShell* aPresShell,
                                           nsStyleContext* aContext,
@@ -209,4 +223,6 @@
   nsCOMPtr<nsPIBoxObject> mBoxObject;
 }; 
 
+NS_DEFINE_STATIC_IID_ACCESSOR(nsListBoxBodyFrame, NS_LISTBOXBODYFRAME_IID)
+
 #endif // nsListBoxBodyFrame_h
diff -r 17e9560465b0 layout/xul/base/src/nsListBoxObject.cpp
--- a/layout/xul/base/src/nsListBoxObject.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/xul/base/src/nsListBoxObject.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -56,7 +56,7 @@
   NS_DECL_NSILISTBOXOBJECT
 
   // nsPIListBoxObject
-  virtual nsIListBoxObject* GetListBoxBody(PRBool aFlush);
+  virtual nsListBoxBodyFrame* GetListBoxBody(PRBool aFlush);
 
   nsListBoxObject();
 
@@ -65,7 +65,7 @@
   virtual void ClearCachedValues();
   
 protected:
-  nsIListBoxObject* mListBoxBody;
+  nsListBoxBodyFrame *mListBoxBody;
 };
 
 NS_IMPL_ISUPPORTS_INHERITED2(nsListBoxObject, nsBoxObject, nsIListBoxObject,
@@ -82,7 +82,7 @@
 NS_IMETHODIMP
 nsListBoxObject::GetRowCount(PRInt32 *aResult)
 {
-  nsIListBoxObject* body = GetListBoxBody(PR_TRUE);
+  nsListBoxBodyFrame* body = GetListBoxBody(PR_TRUE);
   if (body)
     return body->GetRowCount(aResult);
   return NS_OK;
@@ -91,7 +91,7 @@
 NS_IMETHODIMP
 nsListBoxObject::GetNumberOfVisibleRows(PRInt32 *aResult)
 {
-  nsIListBoxObject* body = GetListBoxBody(PR_TRUE);
+  nsListBoxBodyFrame* body = GetListBoxBody(PR_TRUE);
   if (body)
     return body->GetNumberOfVisibleRows(aResult);
   return NS_OK;
@@ -100,7 +100,7 @@
 NS_IMETHODIMP
 nsListBoxObject::GetIndexOfFirstVisibleRow(PRInt32 *aResult)
 {
-  nsIListBoxObject* body = GetListBoxBody(PR_TRUE);
+  nsListBoxBodyFrame* body = GetListBoxBody(PR_TRUE);
   if (body)
     return body->GetIndexOfFirstVisibleRow(aResult);
   return NS_OK;
@@ -108,7 +108,7 @@
 
 NS_IMETHODIMP nsListBoxObject::EnsureIndexIsVisible(PRInt32 aRowIndex)
 {
-  nsIListBoxObject* body = GetListBoxBody(PR_TRUE);
+  nsListBoxBodyFrame* body = GetListBoxBody(PR_TRUE);
   if (body)
     return body->EnsureIndexIsVisible(aRowIndex);
   return NS_OK;
@@ -117,7 +117,7 @@
 NS_IMETHODIMP
 nsListBoxObject::ScrollToIndex(PRInt32 aRowIndex)
 {
-  nsIListBoxObject* body = GetListBoxBody(PR_TRUE);
+  nsListBoxBodyFrame* body = GetListBoxBody(PR_TRUE);
   if (body)
     return body->ScrollToIndex(aRowIndex);
   return NS_OK;
@@ -126,7 +126,7 @@
 NS_IMETHODIMP
 nsListBoxObject::ScrollByLines(PRInt32 aNumLines)
 {
-  nsIListBoxObject* body = GetListBoxBody(PR_TRUE);
+  nsListBoxBodyFrame* body = GetListBoxBody(PR_TRUE);
   if (body)
     return body->ScrollByLines(aNumLines);
   return NS_OK;
@@ -135,7 +135,7 @@
 NS_IMETHODIMP
 nsListBoxObject::GetItemAtIndex(PRInt32 index, nsIDOMElement **_retval)
 {
-  nsIListBoxObject* body = GetListBoxBody(PR_TRUE);
+  nsListBoxBodyFrame* body = GetListBoxBody(PR_TRUE);
   if (body)
     return body->GetItemAtIndex(index, _retval);
   return NS_OK;
@@ -146,7 +146,7 @@
 {
   *aResult = 0;
 
-  nsIListBoxObject* body = GetListBoxBody(PR_TRUE);
+  nsListBoxBodyFrame* body = GetListBoxBody(PR_TRUE);
   if (body)
     return body->GetIndexOfItem(aElement, aResult);
   return NS_OK;
@@ -180,7 +180,7 @@
   }
 }
 
-nsIListBoxObject*
+nsListBoxBodyFrame*
 nsListBoxObject::GetListBoxBody(PRBool aFlush)
 {
   if (mListBoxBody) {
@@ -217,10 +217,10 @@
      return nsnull;
 
   // It's a frame. Refcounts are irrelevant.
-  nsIListBoxObject* listBoxBody = nsnull;
+  nsListBoxBodyFrame* listBoxBody = nsnull;
   CallQueryInterface(yeahBaby, &listBoxBody);
   NS_ENSURE_TRUE(listBoxBody &&
-                 static_cast<nsListBoxBodyFrame*>(listBoxBody)->SetBoxObject(this),
+                 listBoxBody->SetBoxObject(this),
                  nsnull);
   mListBoxBody = listBoxBody;
   return mListBoxBody;
diff -r 17e9560465b0 layout/xul/base/src/nsPIListBoxObject.h
--- a/layout/xul/base/src/nsPIListBoxObject.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/xul/base/src/nsPIListBoxObject.h	Thu Oct 30 05:41:46 2008 -0400
@@ -38,6 +38,8 @@
 #ifndef nsPIListBoxObject_h__
 #define nsPIListBoxObject_h__
 
+class nsListBoxBodyFrame;
+
 // fa9549f7-ee09-48fc-89f7-30cceee21c15
 #define NS_PILISTBOXOBJECT_IID \
 { 0xfa9549f7, 0xee09, 0x48fc, \
@@ -52,7 +54,7 @@
    * Get the list box body.  This will search for it as needed.
    * If aFlush is PR_FALSE we don't Flush_Frames though.
    */
-  virtual nsIListBoxObject* GetListBoxBody(PRBool aFlush) = 0;
+  virtual nsListBoxBodyFrame* GetListBoxBody(PRBool aFlush) = 0;
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(nsPIListBoxObject, NS_PILISTBOXOBJECT_IID)
diff -r 17e9560465b0 layout/xul/base/src/nsProgressMeterFrame.cpp
--- a/layout/xul/base/src/nsProgressMeterFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/xul/base/src/nsProgressMeterFrame.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -129,15 +129,27 @@
     nsCOMPtr<nsIContent> remainderContent = remainderChild->GetContent();
     if (!remainderContent) return NS_OK;
 
-    nsAutoString value;
+    nsAutoString value, maxValue;
     mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::value, value);
+    mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::max, maxValue);
 
     PRInt32 error;
     PRInt32 flex = value.ToInteger(&error);
-    if (flex < 0) flex = 0;
-    if (flex > 100) flex = 100;
+    PRInt32 maxFlex = maxValue.ToInteger(&error);
+    if (NS_FAILED(error) || maxValue.IsEmpty()) {
+      maxFlex = 100;
+    }
+    if (maxFlex < 1) {
+      maxFlex = 1;
+    }
+    if (flex < 0) {
+      flex = 0;
+    }
+    if (flex > maxFlex) {
+      flex = maxFlex;
+    }
 
-    PRInt32 remainder = 100 - flex;
+    PRInt32 remainder = maxFlex - flex;
 
     nsAutoString leftFlex, rightFlex;
     leftFlex.AppendInt(flex);
diff -r 17e9560465b0 layout/xul/base/src/tree/src/nsTreeBodyFrame.cpp
--- a/layout/xul/base/src/tree/src/nsTreeBodyFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/xul/base/src/tree/src/nsTreeBodyFrame.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -137,13 +137,16 @@
 //
 // QueryInterface
 //
+
 NS_INTERFACE_MAP_BEGIN(nsTreeBodyFrame)
-  NS_INTERFACE_MAP_ENTRY(nsITreeBoxObject)
   NS_INTERFACE_MAP_ENTRY(nsICSSPseudoComparator)
   NS_INTERFACE_MAP_ENTRY(nsIScrollbarMediator)
+  if (aIID.Equals(NS_GET_IID(nsTreeBodyFrame))) {
+    *aInstancePtr = this;
+    return NS_OK;
+  }
+  else
 NS_INTERFACE_MAP_END_INHERITING(nsLeafBoxFrame)
-
-
 
 // Constructor
 nsTreeBodyFrame::nsTreeBodyFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
@@ -377,11 +380,10 @@
       if (pBox) {
         nsCOMPtr<nsITreeBoxObject> realTreeBoxObject = do_QueryInterface(pBox);
         if (realTreeBoxObject) {
-          nsITreeBoxObject* innerTreeBoxObject =
+          nsTreeBodyFrame* innerTreeBoxObject =
             static_cast<nsTreeBoxObject*>(realTreeBoxObject.get())
               ->GetCachedTreeBody();
-          ENSURE_TRUE(!innerTreeBoxObject || innerTreeBoxObject ==
-                      static_cast<nsITreeBoxObject*>(this));
+          ENSURE_TRUE(!innerTreeBoxObject || innerTreeBoxObject == this);
           mTreeBoxObject = realTreeBoxObject;
           mColumns->SetTree(mTreeBoxObject);
         }
@@ -494,7 +496,8 @@
   mReflowCallbackPosted = PR_FALSE;
 }
 
-NS_IMETHODIMP nsTreeBodyFrame::GetView(nsITreeView * *aView)
+nsresult
+nsTreeBodyFrame::GetView(nsITreeView * *aView)
 {
   *aView = nsnull;
   nsWeakFrame weakFrame(this);
@@ -504,7 +507,8 @@
   return NS_OK;
 }
 
-NS_IMETHODIMP nsTreeBodyFrame::SetView(nsITreeView * aView)
+nsresult
+nsTreeBodyFrame::SetView(nsITreeView * aView)
 {
   // First clear out the old view.
   if (mView) {
@@ -563,14 +567,14 @@
   return NS_OK;
 }
 
-NS_IMETHODIMP 
+nsresult
 nsTreeBodyFrame::GetFocused(PRBool* aFocused)
 {
   *aFocused = mFocused;
   return NS_OK;
 }
 
-NS_IMETHODIMP 
+nsresult
 nsTreeBodyFrame::SetFocused(PRBool aFocused)
 {
   if (mFocused != aFocused) {
@@ -585,7 +589,7 @@
   return NS_OK;
 }
 
-NS_IMETHODIMP 
+nsresult
 nsTreeBodyFrame::GetTreeBody(nsIDOMElement** aElement)
 {
   //NS_ASSERTION(mContent, "no content, see bug #104878");
@@ -595,56 +599,56 @@
   return mContent->QueryInterface(NS_GET_IID(nsIDOMElement), (void**)aElement);
 }
 
-NS_IMETHODIMP 
+nsresult
 nsTreeBodyFrame::GetColumns(nsITreeColumns** aColumns)
 {
   NS_IF_ADDREF(*aColumns = mColumns);
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 nsTreeBodyFrame::GetRowHeight(PRInt32* _retval)
 {
   *_retval = nsPresContext::AppUnitsToIntCSSPixels(mRowHeight);
   return NS_OK;
 }
 
-NS_IMETHODIMP 
+nsresult
 nsTreeBodyFrame::GetRowWidth(PRInt32 *aRowWidth)
 {
   *aRowWidth = nsPresContext::AppUnitsToIntCSSPixels(CalcHorzWidth(GetScrollParts()));
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 nsTreeBodyFrame::GetFirstVisibleRow(PRInt32 *_retval)
 {
   *_retval = mTopRowIndex;
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 nsTreeBodyFrame::GetLastVisibleRow(PRInt32 *_retval)
 {
   *_retval = GetLastVisibleRow();
   return NS_OK;
 }
 
-NS_IMETHODIMP 
+nsresult
 nsTreeBodyFrame::GetHorizontalPosition(PRInt32 *aHorizontalPosition)
 {
   *aHorizontalPosition = nsPresContext::AppUnitsToIntCSSPixels(mHorzPosition); 
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 nsTreeBodyFrame::GetPageLength(PRInt32 *_retval)
 {
   *_retval = mPageLength;
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 nsTreeBodyFrame::GetSelectionRegion(nsIScriptableRegion **aRegion)
 {
   *aRegion = nsnull;
@@ -686,7 +690,7 @@
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 nsTreeBodyFrame::Invalidate()
 {
   if (mUpdateBatchNest)
@@ -697,7 +701,7 @@
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 nsTreeBodyFrame::InvalidateColumn(nsITreeColumn* aCol)
 {
   if (mUpdateBatchNest)
@@ -724,7 +728,7 @@
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 nsTreeBodyFrame::InvalidateRow(PRInt32 aIndex)
 {
   if (mUpdateBatchNest)
@@ -746,7 +750,7 @@
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 nsTreeBodyFrame::InvalidateCell(PRInt32 aIndex, nsITreeColumn* aCol)
 {
   if (mUpdateBatchNest)
@@ -777,7 +781,7 @@
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 nsTreeBodyFrame::InvalidateRange(PRInt32 aStart, PRInt32 aEnd)
 {
   if (mUpdateBatchNest)
@@ -811,7 +815,7 @@
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 nsTreeBodyFrame::InvalidateColumnRange(PRInt32 aStart, PRInt32 aEnd, nsITreeColumn* aCol)
 {
   if (mUpdateBatchNest)
@@ -1071,7 +1075,7 @@
   *aResultY = point.y;
 } // AdjustClientCoordsToBoxCoordSpace
 
-NS_IMETHODIMP
+nsresult
 nsTreeBodyFrame::GetRowAt(PRInt32 aX, PRInt32 aY, PRInt32* _retval)
 {
   if (!mView)
@@ -1092,7 +1096,7 @@
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 nsTreeBodyFrame::GetCellAt(PRInt32 aX, PRInt32 aY, PRInt32* aRow, nsITreeColumn** aCol,
                            nsACString& aChildElt)
 {
@@ -1150,7 +1154,7 @@
 // (3) GetImageSize() does not include margins (but it does include border/padding).  
 // You need to make sure to add in the image's margins as well.
 //
-NS_IMETHODIMP
+nsresult
 nsTreeBodyFrame::GetCoordsForCellItem(PRInt32 aRow, nsITreeColumn* aCol, const nsACString& aElement, 
                                       PRInt32 *aX, PRInt32 *aY, PRInt32 *aWidth, PRInt32 *aHeight)
 {
@@ -1801,7 +1805,7 @@
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 nsTreeBodyFrame::IsCellCropped(PRInt32 aRow, nsITreeColumn* aCol, PRBool *_retval)
 {  
   nscoord currentSize, desiredSize;
@@ -1866,7 +1870,8 @@
   return NS_OK;
 }
 
-NS_IMETHODIMP nsTreeBodyFrame::RowCountChanged(PRInt32 aIndex, PRInt32 aCount)
+nsresult
+nsTreeBodyFrame::RowCountChanged(PRInt32 aIndex, PRInt32 aCount)
 {
   if (aCount == 0 || !mView)
     return NS_OK; // Nothing to do.
@@ -1937,14 +1942,16 @@
   return NS_OK;
 }
 
-NS_IMETHODIMP nsTreeBodyFrame::BeginUpdateBatch()
+nsresult
+nsTreeBodyFrame::BeginUpdateBatch()
 {
   ++mUpdateBatchNest;
 
   return NS_OK;
 }
 
-NS_IMETHODIMP nsTreeBodyFrame::EndUpdateBatch()
+nsresult
+nsTreeBodyFrame::EndUpdateBatch()
 {
   NS_ASSERTION(mUpdateBatchNest > 0, "badly nested update batch");
 
@@ -3857,7 +3864,8 @@
 }
 
 // Scrolling
-NS_IMETHODIMP nsTreeBodyFrame::EnsureRowIsVisible(PRInt32 aRow)
+nsresult
+nsTreeBodyFrame::EnsureRowIsVisible(PRInt32 aRow)
 {
   ScrollParts parts = GetScrollParts();
   nsresult rv = EnsureRowIsVisibleInternal(parts, aRow);
@@ -3885,7 +3893,8 @@
   return NS_OK;
 }
 
-NS_IMETHODIMP nsTreeBodyFrame::EnsureCellIsVisible(PRInt32 aRow, nsITreeColumn* aCol)
+nsresult
+nsTreeBodyFrame::EnsureCellIsVisible(PRInt32 aRow, nsITreeColumn* aCol)
 {
   nsRefPtr<nsTreeColumn> col = GetColumnImpl(aCol);
   if (!col)
@@ -3924,7 +3933,8 @@
   return rv;
 }
 
-NS_IMETHODIMP nsTreeBodyFrame::ScrollToCell(PRInt32 aRow, nsITreeColumn* aCol)
+nsresult
+nsTreeBodyFrame::ScrollToCell(PRInt32 aRow, nsITreeColumn* aCol)
 {
   ScrollParts parts = GetScrollParts();
   nsresult rv = ScrollToRowInternal(parts, aRow);
@@ -3937,7 +3947,8 @@
   return rv;
 }
 
-NS_IMETHODIMP nsTreeBodyFrame::ScrollToColumn(nsITreeColumn* aCol)
+nsresult
+nsTreeBodyFrame::ScrollToColumn(nsITreeColumn* aCol)
 {
   ScrollParts parts = GetScrollParts();
   nsresult rv = ScrollToColumnInternal(parts, aCol);
@@ -3961,7 +3972,8 @@
   return ScrollHorzInternal(aParts, x);
 }
 
-NS_IMETHODIMP nsTreeBodyFrame::ScrollToHorizontalPosition(PRInt32 aHorizontalPosition)
+nsresult
+nsTreeBodyFrame::ScrollToHorizontalPosition(PRInt32 aHorizontalPosition)
 {
   ScrollParts parts = GetScrollParts();
   PRInt32 position = nsPresContext::CSSPixelsToAppUnits(aHorizontalPosition);
@@ -3971,7 +3983,8 @@
   return rv;
 }
 
-NS_IMETHODIMP nsTreeBodyFrame::ScrollToRow(PRInt32 aRow)
+nsresult
+nsTreeBodyFrame::ScrollToRow(PRInt32 aRow)
 {
   ScrollParts parts = GetScrollParts();
   nsresult rv = ScrollToRowInternal(parts, aRow);
@@ -3987,7 +4000,8 @@
   return NS_OK;
 }
 
-NS_IMETHODIMP nsTreeBodyFrame::ScrollByLines(PRInt32 aNumLines)
+nsresult
+nsTreeBodyFrame::ScrollByLines(PRInt32 aNumLines)
 {
   if (!mView)
     return NS_OK;
@@ -4005,7 +4019,8 @@
   return NS_OK;
 }
 
-NS_IMETHODIMP nsTreeBodyFrame::ScrollByPages(PRInt32 aNumPages)
+nsresult
+nsTreeBodyFrame::ScrollByPages(PRInt32 aNumPages)
 {
   if (!mView)
     return NS_OK;
@@ -4209,7 +4224,7 @@
   return nsnull;
 }
 
-NS_IMETHODIMP
+nsresult
 nsTreeBodyFrame::ClearStyleAndImageCaches()
 {
   mStyleCache.Clear();
@@ -4219,9 +4234,9 @@
 }
 
 /* virtual */ void
-nsTreeBodyFrame::DidSetStyleContext()
-{
-  nsLeafBoxFrame::DidSetStyleContext();
+nsTreeBodyFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
+{
+  nsLeafBoxFrame::DidSetStyleContext(aOldStyleContext);
 
   // Clear the style cache; the pointers are no longer even valid
   mStyleCache.Clear();
diff -r 17e9560465b0 layout/xul/base/src/tree/src/nsTreeBodyFrame.h
--- a/layout/xul/base/src/tree/src/nsTreeBodyFrame.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/xul/base/src/tree/src/nsTreeBodyFrame.h	Thu Oct 30 05:41:46 2008 -0400
@@ -41,6 +41,9 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
+#ifndef nsTreeBodyFrame_h
+#define nsTreeBodyFrame_h
+
 #include "nsLeafBoxFrame.h"
 #include "nsITreeView.h"
 #include "nsICSSPseudoComparator.h"
@@ -71,21 +74,66 @@
   nsCOMPtr<imgIDecoderObserver> listener;
 };
 
-static NS_DEFINE_CID(kTreeColumnImplCID, NS_TREECOLUMN_IMPL_CID);
+#define NS_TREEBODYFRAME_IID \
+{ 0xe35eb017, 0xa679, 0x4d4d, \
+  { 0x83, 0xda, 0xce, 0xd6, 0x20, 0xae, 0x9e, 0x66 } }
 
 // The actual frame that paints the cells and rows.
-class nsTreeBodyFrame : public nsLeafBoxFrame,
-                        public nsITreeBoxObject,
-                        public nsICSSPseudoComparator,
-                        public nsIScrollbarMediator,
-                        public nsIReflowCallback
+class NS_FINAL_CLASS nsTreeBodyFrame
+  : public nsLeafBoxFrame
+  , public nsICSSPseudoComparator
+  , public nsIScrollbarMediator
+  , public nsIReflowCallback
 {
 public:
   nsTreeBodyFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
-  virtual ~nsTreeBodyFrame();
+  ~nsTreeBodyFrame();
+
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_TREEBODYFRAME_IID)
 
   NS_DECL_ISUPPORTS
-  NS_DECL_NSITREEBOXOBJECT
+
+  // non-virtual signatures like nsITreeBodyFrame
+  nsresult GetColumns(nsITreeColumns **aColumns);
+  nsresult GetView(nsITreeView **aView);
+  nsresult SetView(nsITreeView *aView);
+  nsresult GetFocused(PRBool *aFocused);
+  nsresult SetFocused(PRBool aFocused);
+  nsresult GetTreeBody(nsIDOMElement **aElement);
+  nsresult GetRowHeight(PRInt32 *aValue);
+  nsresult GetRowWidth(PRInt32 *aValue);
+  nsresult GetHorizontalPosition(PRInt32 *aValue);
+  nsresult GetSelectionRegion(nsIScriptableRegion **aRegion);
+  nsresult GetFirstVisibleRow(PRInt32 *aValue);
+  nsresult GetLastVisibleRow(PRInt32 *aValue);
+  nsresult GetPageLength(PRInt32 *aValue);
+  nsresult EnsureRowIsVisible(PRInt32 aRow);
+  nsresult EnsureCellIsVisible(PRInt32 aRow, nsITreeColumn *aCol);
+  nsresult ScrollToRow(PRInt32 aRow);
+  nsresult ScrollByLines(PRInt32 aNumLines);
+  nsresult ScrollByPages(PRInt32 aNumPages);
+  nsresult ScrollToCell(PRInt32 aRow, nsITreeColumn *aCol);
+  nsresult ScrollToColumn(nsITreeColumn *aCol);
+  nsresult ScrollToHorizontalPosition(PRInt32 aValue);
+  nsresult Invalidate();
+  nsresult InvalidateColumn(nsITreeColumn *aCol);
+  nsresult InvalidateRow(PRInt32 aRow);
+  nsresult InvalidateCell(PRInt32 aRow, nsITreeColumn *aCol);
+  nsresult InvalidateRange(PRInt32 aStart, PRInt32 aEnd);
+  nsresult InvalidateColumnRange(PRInt32 aStart, PRInt32 aEnd,
+                                 nsITreeColumn *aCol);
+  nsresult GetRowAt(PRInt32 aX, PRInt32 aY, PRInt32 *aValue);
+  nsresult GetCellAt(PRInt32 aX, PRInt32 aY, PRInt32 *aRow,
+                     nsITreeColumn **aCol, nsACString &aChildElt);
+  nsresult GetCoordsForCellItem(PRInt32 aRow, nsITreeColumn *aCol,
+                                const nsACString &aElt,
+                                PRInt32 *aX, PRInt32 *aY,
+                                PRInt32 *aWidth, PRInt32 *aHeight);
+  nsresult IsCellCropped(PRInt32 aRow, nsITreeColumn *aCol, PRBool *aResult);
+  nsresult RowCountChanged(PRInt32 aIndex, PRInt32 aCount);
+  nsresult BeginUpdateBatch();
+  nsresult EndUpdateBatch();
+  nsresult ClearStyleAndImageCaches();
 
   // nsIBox
   virtual nsSize GetMinSize(nsBoxLayoutState& aBoxLayoutState);
@@ -121,7 +169,7 @@
                               const nsRect&           aDirtyRect,
                               const nsDisplayListSet& aLists);
 
-  virtual void DidSetStyleContext();
+  virtual void DidSetStyleContext(nsStyleContext* aOldStyleContext);
 
   friend nsIFrame* NS_NewTreeBodyFrame(nsIPresShell* aPresShell);
   friend class nsTreeColumn;
@@ -381,7 +429,7 @@
       return nsnull;
 
     nsTreeColumn* col;
-    aUnknownCol->QueryInterface(kTreeColumnImplCID, (void**)&col);
+    aUnknownCol->QueryInterface(NS_GET_IID(nsTreeColumn), (void**)&col);
     return col;
   }
 
@@ -550,3 +598,7 @@
 
   nsRevocableEventPtr<ScrollEvent> mScrollEvent;
 }; // class nsTreeBodyFrame
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsTreeBodyFrame, NS_TREEBODYFRAME_IID)
+
+#endif
diff -r 17e9560465b0 layout/xul/base/src/tree/src/nsTreeBoxObject.cpp
--- a/layout/xul/base/src/tree/src/nsTreeBoxObject.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/xul/base/src/tree/src/nsTreeBoxObject.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -106,7 +106,7 @@
   }
 }
 
-nsITreeBoxObject*
+nsTreeBodyFrame*
 nsTreeBoxObject::GetTreeBody()
 {
   if (mTreeBody) {
@@ -130,16 +130,12 @@
   if (!frame)
      return nsnull;
 
-  // It's a frame. Refcounts are irrelevant.
-  // Make sure that the treebodyframe, which implements nsITreeBoxObject,
-  // has a pointer to |this|.
-  nsITreeBoxObject* innerTreeBoxObject = nsnull;
-  CallQueryInterface(frame, &innerTreeBoxObject);
-  NS_ENSURE_TRUE(innerTreeBoxObject &&
-    static_cast<nsTreeBodyFrame*>(innerTreeBoxObject)->GetTreeBoxObject() ==
-    static_cast<nsITreeBoxObject*>(this), nsnull);
+  // Make sure that the treebodyframe has a pointer to |this|.
+  nsTreeBodyFrame *treeBody = nsnull;
+  CallQueryInterface(frame, &treeBody);
+  NS_ENSURE_TRUE(treeBody && treeBody->GetTreeBoxObject() == this, nsnull);
 
-  mTreeBody = innerTreeBoxObject;
+  mTreeBody = treeBody;
   return mTreeBody;
 }
 
@@ -198,7 +194,7 @@
     return NS_ERROR_DOM_SECURITY_ERR;
   
   mView = aView;
-  nsITreeBoxObject* body = GetTreeBody();
+  nsTreeBodyFrame* body = GetTreeBody();
   if (body)
     body->SetView(aView);
 
@@ -208,7 +204,7 @@
 NS_IMETHODIMP nsTreeBoxObject::GetFocused(PRBool* aFocused)
 {
   *aFocused = PR_FALSE;
-  nsITreeBoxObject* body = GetTreeBody();
+  nsTreeBodyFrame* body = GetTreeBody();
   if (body)
     return body->GetFocused(aFocused);
   return NS_OK;
@@ -216,7 +212,7 @@
 
 NS_IMETHODIMP nsTreeBoxObject::SetFocused(PRBool aFocused)
 {
-  nsITreeBoxObject* body = GetTreeBody();
+  nsTreeBodyFrame* body = GetTreeBody();
   if (body)
     return body->SetFocused(aFocused);
   return NS_OK;
@@ -225,7 +221,7 @@
 NS_IMETHODIMP nsTreeBoxObject::GetTreeBody(nsIDOMElement** aElement)
 {
   *aElement = nsnull;
-  nsITreeBoxObject* body = GetTreeBody();
+  nsTreeBodyFrame* body = GetTreeBody();
   if (body) 
     return body->GetTreeBody(aElement);
   return NS_OK;
@@ -234,7 +230,7 @@
 NS_IMETHODIMP nsTreeBoxObject::GetColumns(nsITreeColumns** aColumns)
 {
   *aColumns = nsnull;
-  nsITreeBoxObject* body = GetTreeBody();
+  nsTreeBodyFrame* body = GetTreeBody();
   if (body) 
     return body->GetColumns(aColumns);
   return NS_OK;
@@ -243,7 +239,7 @@
 NS_IMETHODIMP nsTreeBoxObject::GetRowHeight(PRInt32* aRowHeight)
 {
   *aRowHeight = 0;
-  nsITreeBoxObject* body = GetTreeBody();
+  nsTreeBodyFrame* body = GetTreeBody();
   if (body) 
     return body->GetRowHeight(aRowHeight);
   return NS_OK;
@@ -252,7 +248,7 @@
 NS_IMETHODIMP nsTreeBoxObject::GetRowWidth(PRInt32 *aRowWidth)
 {
   *aRowWidth = 0;
-  nsITreeBoxObject* body = GetTreeBody();
+  nsTreeBodyFrame* body = GetTreeBody();
   if (body) 
     return body->GetRowWidth(aRowWidth);
   return NS_OK;
@@ -261,7 +257,7 @@
 NS_IMETHODIMP nsTreeBoxObject::GetFirstVisibleRow(PRInt32 *aFirstVisibleRow)
 {
   *aFirstVisibleRow = 0;
-  nsITreeBoxObject* body = GetTreeBody();
+  nsTreeBodyFrame* body = GetTreeBody();
   if (body)
     return body->GetFirstVisibleRow(aFirstVisibleRow);
   return NS_OK;
@@ -270,7 +266,7 @@
 NS_IMETHODIMP nsTreeBoxObject::GetLastVisibleRow(PRInt32 *aLastVisibleRow)
 {
   *aLastVisibleRow = 0;
-  nsITreeBoxObject* body = GetTreeBody();
+  nsTreeBodyFrame* body = GetTreeBody();
   if (body)
     return body->GetLastVisibleRow(aLastVisibleRow);
   return NS_OK;
@@ -279,7 +275,7 @@
 NS_IMETHODIMP nsTreeBoxObject::GetHorizontalPosition(PRInt32 *aHorizontalPosition)
 {
   *aHorizontalPosition = 0;
-  nsITreeBoxObject* body = GetTreeBody();
+  nsTreeBodyFrame* body = GetTreeBody();
   if (body)
     return body->GetHorizontalPosition(aHorizontalPosition);
   return NS_OK;
@@ -288,7 +284,7 @@
 NS_IMETHODIMP nsTreeBoxObject::GetPageLength(PRInt32 *aPageLength)
 {
   *aPageLength = 0;
-  nsITreeBoxObject* body = GetTreeBody();
+  nsTreeBodyFrame* body = GetTreeBody();
   if (body)
     return body->GetPageLength(aPageLength);
   return NS_OK;
@@ -297,7 +293,7 @@
 NS_IMETHODIMP nsTreeBoxObject::GetSelectionRegion(nsIScriptableRegion **aRegion)
 {
  *aRegion = nsnull;
-  nsITreeBoxObject* body = GetTreeBody();
+  nsTreeBodyFrame* body = GetTreeBody();
   if (body)
     return body->GetSelectionRegion(aRegion);
   return NS_OK;
@@ -306,7 +302,7 @@
 NS_IMETHODIMP
 nsTreeBoxObject::EnsureRowIsVisible(PRInt32 aRow)
 {
-  nsITreeBoxObject* body = GetTreeBody();
+  nsTreeBodyFrame* body = GetTreeBody();
   if (body)
     return body->EnsureRowIsVisible(aRow);
   return NS_OK;
@@ -315,7 +311,7 @@
 NS_IMETHODIMP 
 nsTreeBoxObject::EnsureCellIsVisible(PRInt32 aRow, nsITreeColumn* aCol)
 {
-  nsITreeBoxObject* body = GetTreeBody();
+  nsTreeBodyFrame* body = GetTreeBody();
   if (body)
     return body->EnsureCellIsVisible(aRow, aCol);
   return NS_OK;
@@ -325,7 +321,7 @@
 NS_IMETHODIMP
 nsTreeBoxObject::ScrollToRow(PRInt32 aRow)
 {
-  nsITreeBoxObject* body = GetTreeBody();
+  nsTreeBodyFrame* body = GetTreeBody();
   if (body)
     return body->ScrollToRow(aRow);
   return NS_OK;
@@ -334,7 +330,7 @@
 NS_IMETHODIMP
 nsTreeBoxObject::ScrollByLines(PRInt32 aNumLines)
 {
-  nsITreeBoxObject* body = GetTreeBody();
+  nsTreeBodyFrame* body = GetTreeBody();
   if (body)
     return body->ScrollByLines(aNumLines);
   return NS_OK;
@@ -343,7 +339,7 @@
 NS_IMETHODIMP
 nsTreeBoxObject::ScrollByPages(PRInt32 aNumPages)
 {
-  nsITreeBoxObject* body = GetTreeBody();
+  nsTreeBodyFrame* body = GetTreeBody();
   if (body)
     return body->ScrollByPages(aNumPages);
   return NS_OK;
@@ -352,7 +348,7 @@
 NS_IMETHODIMP 
 nsTreeBoxObject::ScrollToCell(PRInt32 aRow, nsITreeColumn* aCol)
 {
-  nsITreeBoxObject* body = GetTreeBody();
+  nsTreeBodyFrame* body = GetTreeBody();
   if (body)
     return body->ScrollToCell(aRow, aCol);
   return NS_OK;
@@ -361,7 +357,7 @@
 NS_IMETHODIMP 
 nsTreeBoxObject::ScrollToColumn(nsITreeColumn* aCol)
 {
-  nsITreeBoxObject* body = GetTreeBody();
+  nsTreeBodyFrame* body = GetTreeBody();
   if (body)
     return body->ScrollToColumn(aCol);
   return NS_OK;
@@ -370,7 +366,7 @@
 NS_IMETHODIMP 
 nsTreeBoxObject::ScrollToHorizontalPosition(PRInt32 aHorizontalPosition)
 {
-  nsITreeBoxObject* body = GetTreeBody();
+  nsTreeBodyFrame* body = GetTreeBody();
   if (body)
     return body->ScrollToHorizontalPosition(aHorizontalPosition);
   return NS_OK;
@@ -378,7 +374,7 @@
 
 NS_IMETHODIMP nsTreeBoxObject::Invalidate()
 {
-  nsITreeBoxObject* body = GetTreeBody();
+  nsTreeBodyFrame* body = GetTreeBody();
   if (body)
     return body->Invalidate();
   return NS_OK;
@@ -386,7 +382,7 @@
 
 NS_IMETHODIMP nsTreeBoxObject::InvalidateColumn(nsITreeColumn* aCol)
 {
-  nsITreeBoxObject* body = GetTreeBody();
+  nsTreeBodyFrame* body = GetTreeBody();
   if (body)
     return body->InvalidateColumn(aCol);
   return NS_OK;
@@ -394,7 +390,7 @@
 
 NS_IMETHODIMP nsTreeBoxObject::InvalidateRow(PRInt32 aIndex)
 {
-  nsITreeBoxObject* body = GetTreeBody();
+  nsTreeBodyFrame* body = GetTreeBody();
   if (body)
     return body->InvalidateRow(aIndex);
   return NS_OK;
@@ -402,7 +398,7 @@
 
 NS_IMETHODIMP nsTreeBoxObject::InvalidateCell(PRInt32 aRow, nsITreeColumn* aCol)
 {
-  nsITreeBoxObject* body = GetTreeBody();
+  nsTreeBodyFrame* body = GetTreeBody();
   if (body)
     return body->InvalidateCell(aRow, aCol);
   return NS_OK;
@@ -410,7 +406,7 @@
 
 NS_IMETHODIMP nsTreeBoxObject::InvalidateRange(PRInt32 aStart, PRInt32 aEnd)
 {
-  nsITreeBoxObject* body = GetTreeBody();
+  nsTreeBodyFrame* body = GetTreeBody();
   if (body)
     return body->InvalidateRange(aStart, aEnd);
   return NS_OK;
@@ -418,7 +414,7 @@
 
 NS_IMETHODIMP nsTreeBoxObject::InvalidateColumnRange(PRInt32 aStart, PRInt32 aEnd, nsITreeColumn* aCol)
 {
-  nsITreeBoxObject* body = GetTreeBody();
+  nsTreeBodyFrame* body = GetTreeBody();
   if (body)
     return body->InvalidateColumnRange(aStart, aEnd, aCol);
   return NS_OK;
@@ -427,7 +423,7 @@
 NS_IMETHODIMP nsTreeBoxObject::GetRowAt(PRInt32 x, PRInt32 y, PRInt32 *aRow)
 {
   *aRow = 0;
-  nsITreeBoxObject* body = GetTreeBody();
+  nsTreeBodyFrame* body = GetTreeBody();
   if (body)
     return body->GetRowAt(x, y, aRow);
   return NS_OK;
@@ -438,7 +434,7 @@
 {
   *aRow = 0;
   *aCol = nsnull;
-  nsITreeBoxObject* body = GetTreeBody();
+  nsTreeBodyFrame* body = GetTreeBody();
   if (body)
     return body->GetCellAt(aX, aY, aRow, aCol, aChildElt);
   return NS_OK;
@@ -449,7 +445,7 @@
                                       PRInt32 *aX, PRInt32 *aY, PRInt32 *aWidth, PRInt32 *aHeight)
 {
   *aX = *aY = *aWidth = *aHeight = 0;
-  nsITreeBoxObject* body = GetTreeBody();
+  nsTreeBodyFrame* body = GetTreeBody();
   if (body)
     return body->GetCoordsForCellItem(aRow, aCol, aElement, aX, aY, aWidth, aHeight);
   return NS_OK;
@@ -459,7 +455,7 @@
 nsTreeBoxObject::IsCellCropped(PRInt32 aRow, nsITreeColumn* aCol, PRBool *aIsCropped)
 {  
   *aIsCropped = PR_FALSE;
-  nsITreeBoxObject* body = GetTreeBody();
+  nsTreeBodyFrame* body = GetTreeBody();
   if (body)
     return body->IsCellCropped(aRow, aCol, aIsCropped);
   return NS_OK;
@@ -467,7 +463,7 @@
 
 NS_IMETHODIMP nsTreeBoxObject::RowCountChanged(PRInt32 aIndex, PRInt32 aDelta)
 {
-  nsITreeBoxObject* body = GetTreeBody();
+  nsTreeBodyFrame* body = GetTreeBody();
   if (body)
     return body->RowCountChanged(aIndex, aDelta);
   return NS_OK;
@@ -475,7 +471,7 @@
 
 NS_IMETHODIMP nsTreeBoxObject::BeginUpdateBatch()
 {
-  nsITreeBoxObject* body = GetTreeBody();
+  nsTreeBodyFrame* body = GetTreeBody();
   if (body)
     return body->BeginUpdateBatch();
   return NS_OK;
@@ -483,7 +479,7 @@
 
 NS_IMETHODIMP nsTreeBoxObject::EndUpdateBatch()
 {
-  nsITreeBoxObject* body = GetTreeBody();
+  nsTreeBodyFrame* body = GetTreeBody();
   if (body)
     return body->EndUpdateBatch();
   return NS_OK;
@@ -491,7 +487,7 @@
 
 NS_IMETHODIMP nsTreeBoxObject::ClearStyleAndImageCaches()
 {
-  nsITreeBoxObject* body = GetTreeBody();
+  nsTreeBodyFrame* body = GetTreeBody();
   if (body)
     return body->ClearStyleAndImageCaches();
   return NS_OK;
diff -r 17e9560465b0 layout/xul/base/src/tree/src/nsTreeBoxObject.h
--- a/layout/xul/base/src/tree/src/nsTreeBoxObject.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/xul/base/src/tree/src/nsTreeBoxObject.h	Thu Oct 30 05:41:46 2008 -0400
@@ -45,6 +45,8 @@
 #include "nsITreeView.h"
 #include "nsITreeBoxObject.h"
 
+class nsTreeBodyFrame;
+
 class nsTreeBoxObject : public nsITreeBoxObject, public nsBoxObject
 {
 public:
@@ -54,15 +56,15 @@
   nsTreeBoxObject();
   ~nsTreeBoxObject();
 
-  nsITreeBoxObject* GetTreeBody();
-  nsITreeBoxObject* GetCachedTreeBody() { return mTreeBody; }
+  nsTreeBodyFrame* GetTreeBody();
+  nsTreeBodyFrame* GetCachedTreeBody() { return mTreeBody; }
 
   //NS_PIBOXOBJECT interfaces
   virtual void Clear();
   virtual void ClearCachedValues();
 
 protected:
-  nsITreeBoxObject* mTreeBody;
+  nsTreeBodyFrame* mTreeBody;
   nsCOMPtr<nsITreeView> mView;
 };
 
diff -r 17e9560465b0 layout/xul/base/src/tree/src/nsTreeColFrame.cpp
--- a/layout/xul/base/src/tree/src/nsTreeColFrame.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/xul/base/src/tree/src/nsTreeColFrame.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -51,6 +51,7 @@
 #include "nsITreeColumns.h"
 #include "nsIDOMXULTreeElement.h"
 #include "nsDisplayList.h"
+#include "nsTreeBodyFrame.h"
 
 //
 // NS_NewTreeColFrame
@@ -231,8 +232,7 @@
     if (aCanWalkFrameTree) {
       treeBoxObject->GetColumns(getter_AddRefs(columns));
     } else {
-      nsITreeBoxObject* body =
-        static_cast<nsTreeBoxObject*>(treeBoxObject)->GetCachedTreeBody();
+      nsTreeBodyFrame* body = static_cast<nsTreeBoxObject*>(treeBoxObject)->GetCachedTreeBody();
       if (body) {
         body->GetColumns(getter_AddRefs(columns));
       }
diff -r 17e9560465b0 layout/xul/base/src/tree/src/nsTreeColumns.cpp
--- a/layout/xul/base/src/tree/src/nsTreeColumns.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/xul/base/src/tree/src/nsTreeColumns.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -78,8 +78,11 @@
   NS_INTERFACE_MAP_ENTRY(nsITreeColumn)
   NS_INTERFACE_MAP_ENTRY(nsISupports)
   NS_INTERFACE_MAP_ENTRY_DOM_CLASSINFO(TreeColumn)
-  if (aIID.Equals(kTreeColumnImplCID))
-    foundInterface = static_cast<nsITreeColumn*>(this);
+  if (aIID.Equals(NS_GET_IID(nsTreeColumn))) {
+    AddRef();
+    *aInstancePtr = this;
+    return NS_OK;
+  }
   else
 NS_INTERFACE_MAP_END
                                                                                 
diff -r 17e9560465b0 layout/xul/base/src/tree/src/nsTreeColumns.h
--- a/layout/xul/base/src/tree/src/nsTreeColumns.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/layout/xul/base/src/tree/src/nsTreeColumns.h	Thu Oct 30 05:41:46 2008 -0400
@@ -48,12 +48,22 @@
 class nsTreeBodyFrame;
 class nsTreeColumns;
 
+#define NS_TREECOLUMN_IMPL_CID                       \
+{ /* 02cd1963-4b5d-4a6c-9223-814d3ade93a3 */         \
+    0x02cd1963,                                      \
+    0x4b5d,                                          \
+    0x4a6c,                                          \
+    {0x92, 0x23, 0x81, 0x4d, 0x3a, 0xde, 0x93, 0xa3} \
+}
+
 // This class is our column info.  We use it to iterate our columns and to obtain
 // information about each column.
 class nsTreeColumn : public nsITreeColumn {
 public:
   nsTreeColumn(nsTreeColumns* aColumns, nsIContent* aContent);
   ~nsTreeColumn();
+
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_TREECOLUMN_IMPL_CID)
 
   NS_DECL_ISUPPORTS
   NS_DECL_NSITREECOLUMN
@@ -128,13 +138,7 @@
   nsTreeColumn* mPrevious;
 };
 
-#define NS_TREECOLUMN_IMPL_CID                       \
-{ /* 02cd1963-4b5d-4a6c-9223-814d3ade93a3 */         \
-    0x02cd1963,                                      \
-    0x4b5d,                                          \
-    0x4a6c,                                          \
-    {0x92, 0x23, 0x81, 0x4d, 0x3a, 0xde, 0x93, 0xa3} \
-}
+NS_DEFINE_STATIC_IID_ACCESSOR(nsTreeColumn, NS_TREECOLUMN_IMPL_CID)
 
 class nsTreeColumns : public nsITreeColumns {
 public:
diff -r 17e9560465b0 media/liboggplay/README_MOZILLA
--- a/media/liboggplay/README_MOZILLA	Thu Oct 23 09:51:35 2008 -0700
+++ b/media/liboggplay/README_MOZILLA	Thu Oct 30 05:41:46 2008 -0400
@@ -6,3 +6,6 @@
 http://svn.annodex.net/liboggplay/trunk/
 
 The svn revision number used was r3729.
+
+The patch from Annodex trac ticket 421 is applied to fix bug 459938:
+  http://trac.annodex.net/ticket/421
diff -r 17e9560465b0 media/liboggplay/src/liboggplay/oggplay_yuv2rgb.c
--- a/media/liboggplay/src/liboggplay/oggplay_yuv2rgb.c	Thu Oct 23 09:51:35 2008 -0700
+++ b/media/liboggplay/src/liboggplay/oggplay_yuv2rgb.c	Thu Oct 30 05:41:46 2008 -0400
@@ -357,29 +357,27 @@
     ptro2 = ptro;
     for (j = 0; j < yuv->y_width; j += 2) {
 
-      short pr, pg, pb;
+      short pr, pg, pb, y;
       short r, g, b;
 
-    //pr = ((128 + (ptrv[j/2] - 128) * 292) >> 8) - 16; /* 1.14 * 256 */
-      pr = (-41344 + ptrv[j/2] * 292) >> 8;
-    //pg = ((128 - (ptru[j/2] - 128) * 101 - (ptrv[j/2] - 128) * 149) >> 8)-16;
-    //                                /* 0.395 & 0.581 */
-      pg = (28032 - ptru[j/2] * 101 - ptrv[j/2] * 149) >> 8;
-    //pb = ((128 + (ptru[j/2] - 128) * 520) >> 8) - 16; /* 2.032 */
-      pb = (-70528 + ptru[j/2] * 520) >> 8;
+      pr = (-56992 + ptrv[j/2] * 409) >> 8;
+      pg = (34784 - ptru[j/2] * 100 - ptrv[j/2] * 208) >> 8;
+      pb = (-70688 + ptru[j/2] * 516) >> 8;
 
-      r = ptry[j] + pr;
-      g = ptry[j] + pg;
-      b = ptry[j] + pb;
+      y = 298*ptry[j] >> 8;
+      r = y + pr;
+      g = y + pg;
+      b = y + pb;
 
       *ptro2++ = CLAMP(r);
       *ptro2++ = CLAMP(g);
       *ptro2++ = CLAMP(b);
       *ptro2++ = 255;
 
-      r = ptry[j + 1] + pr;
-      g = ptry[j + 1] + pg;
-      b = ptry[j + 1] + pb;
+      y = 298*ptry[j + 1] >> 8;
+      r = y + pr;
+      g = y + pg;
+      b = y + pb;
 
       *ptro2++ = CLAMP(r);
       *ptro2++ = CLAMP(g);
@@ -409,29 +407,27 @@
     ptro2 = ptro;
     for (j = 0; j < yuv->y_width; j += 2) {
 
-      short pr, pg, pb;
+      short pr, pg, pb, y;
       short r, g, b;
 
-    //pr = ((128 + (ptrv[j/2] - 128) * 292) >> 8) - 16; /* 1.14 * 256 */
-      pr = (-41344 + ptrv[j/2] * 292) >> 8;
-    //pg = ((128 - (ptru[j/2] - 128) * 101 - (ptrv[j/2] - 128) * 149) >> 8)-16;
-    //                                /* 0.395 & 0.581 */
-      pg = (28032 - ptru[j/2] * 101 - ptrv[j/2] * 149) >> 8;
-    //pb = ((128 + (ptru[j/2] - 128) * 520) >> 8) - 16; /* 2.032 */
-      pb = (-70528 + ptru[j/2] * 520) >> 8;
+      pr = (-56992 + ptrv[j/2] * 409) >> 8;
+      pg = (34784 - ptru[j/2] * 100 - ptrv[j/2] * 208) >> 8;
+      pb = (-70688 + ptru[j/2] * 516) >> 8;
 
-      r = ptry[j] + pr;
-      g = ptry[j] + pg;
-      b = ptry[j] + pb;
+      y = 298*ptry[j] >> 8;
+      r = y + pr;
+      g = y + pg;
+      b = y + pb;
 
       *ptro2++ = CLAMP(b);
       *ptro2++ = CLAMP(g);
       *ptro2++ = CLAMP(r);
       *ptro2++ = 255;
 
-      r = ptry[j + 1] + pr;
-      g = ptry[j + 1] + pg;
-      b = ptry[j + 1] + pb;
+      y = 298*ptry[j + 1] >> 8;
+      r = y + pr;
+      g = y + pg;
+      b = y + pb;
 
       *ptro2++ = CLAMP(b);
       *ptro2++ = CLAMP(g);
diff -r 17e9560465b0 media/liboggplay/update.sh
--- a/media/liboggplay/update.sh	Thu Oct 23 09:51:35 2008 -0700
+++ b/media/liboggplay/update.sh	Thu Oct 30 05:41:46 2008 -0400
@@ -34,3 +34,6 @@
 sed s/\#include\ \<config.h\>/\#ifdef\ WIN32\\n\#include\ \"config_win32.h\"\\n\#else\\n\#include\ \<config.h\>\\n\#endif/g ./src/liboggplay/oggplay_private.h1 >./src/liboggplay/oggplay_private.h
 rm ./src/liboggplay/oggplay_private.h1
 sed s/\#ifdef\ HAVE_INTTYPES_H/\#if\ HAVE_INTTYPES_H/g $1/src/liboggplay/oggplay_data.c >./src/liboggplay/oggplay_data.c
+cd ./src/liboggplay
+patch <../../yuv2rgb-vanilla-fix.patch
+cd ../..
diff -r 17e9560465b0 media/liboggplay/yuv2rgb-vanilla-fix.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/media/liboggplay/yuv2rgb-vanilla-fix.patch	Thu Oct 30 05:41:46 2008 -0400
@@ -0,0 +1,88 @@
+Index: oggplay_yuv2rgb.c
+===================================================================
+--- oggplay_yuv2rgb.c	(revision 3733)
++++ oggplay_yuv2rgb.c	(working copy)
+@@ -357,29 +357,27 @@
+     ptro2 = ptro;
+     for (j = 0; j < yuv->y_width; j += 2) {
+ 
+-      short pr, pg, pb;
++      short pr, pg, pb, y;
+       short r, g, b;
+ 
+-    //pr = ((128 + (ptrv[j/2] - 128) * 292) >> 8) - 16; /* 1.14 * 256 */
+-      pr = (-41344 + ptrv[j/2] * 292) >> 8;
+-    //pg = ((128 - (ptru[j/2] - 128) * 101 - (ptrv[j/2] - 128) * 149) >> 8)-16;
+-    //                                /* 0.395 & 0.581 */
+-      pg = (28032 - ptru[j/2] * 101 - ptrv[j/2] * 149) >> 8;
+-    //pb = ((128 + (ptru[j/2] - 128) * 520) >> 8) - 16; /* 2.032 */
+-      pb = (-70528 + ptru[j/2] * 520) >> 8;
++      pr = (-56992 + ptrv[j/2] * 409) >> 8;
++      pg = (34784 - ptru[j/2] * 100 - ptrv[j/2] * 208) >> 8;
++      pb = (-70688 + ptru[j/2] * 516) >> 8;
+ 
+-      r = ptry[j] + pr;
+-      g = ptry[j] + pg;
+-      b = ptry[j] + pb;
++      y = 298*ptry[j] >> 8;
++      r = y + pr;
++      g = y + pg;
++      b = y + pb;
+ 
+       *ptro2++ = CLAMP(r);
+       *ptro2++ = CLAMP(g);
+       *ptro2++ = CLAMP(b);
+       *ptro2++ = 255;
+ 
+-      r = ptry[j + 1] + pr;
+-      g = ptry[j + 1] + pg;
+-      b = ptry[j + 1] + pb;
++      y = 298*ptry[j + 1] >> 8;
++      r = y + pr;
++      g = y + pg;
++      b = y + pb;
+ 
+       *ptro2++ = CLAMP(r);
+       *ptro2++ = CLAMP(g);
+@@ -409,29 +407,27 @@
+     ptro2 = ptro;
+     for (j = 0; j < yuv->y_width; j += 2) {
+ 
+-      short pr, pg, pb;
++      short pr, pg, pb, y;
+       short r, g, b;
+ 
+-    //pr = ((128 + (ptrv[j/2] - 128) * 292) >> 8) - 16; /* 1.14 * 256 */
+-      pr = (-41344 + ptrv[j/2] * 292) >> 8;
+-    //pg = ((128 - (ptru[j/2] - 128) * 101 - (ptrv[j/2] - 128) * 149) >> 8)-16;
+-    //                                /* 0.395 & 0.581 */
+-      pg = (28032 - ptru[j/2] * 101 - ptrv[j/2] * 149) >> 8;
+-    //pb = ((128 + (ptru[j/2] - 128) * 520) >> 8) - 16; /* 2.032 */
+-      pb = (-70528 + ptru[j/2] * 520) >> 8;
++      pr = (-56992 + ptrv[j/2] * 409) >> 8;
++      pg = (34784 - ptru[j/2] * 100 - ptrv[j/2] * 208) >> 8;
++      pb = (-70688 + ptru[j/2] * 516) >> 8;
+ 
+-      r = ptry[j] + pr;
+-      g = ptry[j] + pg;
+-      b = ptry[j] + pb;
++      y = 298*ptry[j] >> 8;
++      r = y + pr;
++      g = y + pg;
++      b = y + pb;
+ 
+       *ptro2++ = CLAMP(b);
+       *ptro2++ = CLAMP(g);
+       *ptro2++ = CLAMP(r);
+       *ptro2++ = 255;
+ 
+-      r = ptry[j + 1] + pr;
+-      g = ptry[j + 1] + pg;
+-      b = ptry[j + 1] + pb;
++      y = 298*ptry[j + 1] >> 8;
++      r = y + pr;
++      g = y + pg;
++      b = y + pb;
+ 
+       *ptro2++ = CLAMP(b);
+       *ptro2++ = CLAMP(g);
diff -r 17e9560465b0 media/liboggz/README_MOZILLA
--- a/media/liboggz/README_MOZILLA	Thu Oct 23 09:51:35 2008 -0700
+++ b/media/liboggz/README_MOZILLA	Thu Oct 30 05:41:46 2008 -0400
@@ -7,3 +7,8 @@
 The seek.patch address a bug in liboggz when a seek call returns an
 error. It also addresses an issue where the guess for the seek
 position can exceed the file size. These will be upstreamed to liboggz.
+
+The warning.patch addresses a printf in liboggz that is not wrapped
+in a DEBUG #ifdef. See Mozilla bug 450891 and Annodex ticket 431:
+
+http://trac.annodex.net/ticket/431
diff -r 17e9560465b0 media/liboggz/src/liboggz/oggz_auto.c
--- a/media/liboggz/src/liboggz/oggz_auto.c	Thu Oct 23 09:51:35 2008 -0700
+++ b/media/liboggz/src/liboggz/oggz_auto.c	Thu Oct 30 05:41:46 2008 -0400
@@ -809,10 +809,12 @@
       }
       
       size_check += 1;
+#ifdef DEBUG
       if (size_check != size)
       {
         printf("WARNING: size parsing failed for VORBIS mode packets\n");
       }
+#endif
 
       /*
        * store mode size information in our info struct
diff -r 17e9560465b0 media/liboggz/update.sh
--- a/media/liboggz/update.sh	Thu Oct 23 09:51:35 2008 -0700
+++ b/media/liboggz/update.sh	Thu Oct 30 05:41:46 2008 -0400
@@ -41,4 +41,5 @@
 cp $1/src/liboggz/oggz_dlist.h ./src/liboggz/oggz_dlist.h
 sed s/\#include\ \"config.h\"/\#ifdef\ WIN32\\n\#include\ \"config_win32.h\"\\n\#else\\n\#include\ \"config.h\"\\n\#endif/g $1/src/liboggz/metric_internal.c >./src/liboggz/metric_internal.c
 cp $1/AUTHORS ./AUTHORS
-patch -p4 <seek.patch
\ No newline at end of file
+patch -p4 <seek.patch
+patch -p4 <warning.patch
diff -r 17e9560465b0 media/liboggz/warning.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/media/liboggz/warning.patch	Thu Oct 30 05:41:46 2008 -0400
@@ -0,0 +1,17 @@
+diff --git a/media/liboggz/src/liboggz/oggz_auto.c b/media/liboggz/src/liboggz/oggz_auto.c
+index 6d83fa9..95ffe6c 100644
+--- a/media/liboggz/src/liboggz/oggz_auto.c
++++ b/media/liboggz/src/liboggz/oggz_auto.c
+@@ -809,10 +809,12 @@ auto_calc_vorbis(ogg_int64_t now, oggz_stream_t *stream, ogg_packet *op) {
+       }
+       
+       size_check += 1;
++#ifdef DEBUG
+       if (size_check != size)
+       {
+         printf("WARNING: size parsing failed for VORBIS mode packets\n");
+       }
++#endif
+ 
+       /*
+        * store mode size information in our info struct
diff -r 17e9560465b0 media/libsydneyaudio/README_MOZILLA
--- a/media/libsydneyaudio/README_MOZILLA	Thu Oct 23 09:51:35 2008 -0700
+++ b/media/libsydneyaudio/README_MOZILLA	Thu Oct 30 05:41:46 2008 -0400
@@ -5,4 +5,4 @@
 
 http://svn.annodex.net/libsydneyaudio/trunk
 
-The svn revision number used was r3731. 
+The svn revision number used was r3733.
diff -r 17e9560465b0 media/libsydneyaudio/src/sydney_audio_alsa.c
--- a/media/libsydneyaudio/src/sydney_audio_alsa.c	Thu Oct 23 09:51:35 2008 -0700
+++ b/media/libsydneyaudio/src/sydney_audio_alsa.c	Thu Oct 30 05:41:46 2008 -0400
@@ -54,6 +54,21 @@
   unsigned int      buffer_bytes;
   unsigned int      period_bytes;
 };
+
+/*
+ * -----------------------------------------------------------------------------
+ *  Error Handler to prevent output to stderr
+ *  ----------------------------------------------------------------------------
+ */
+static void
+quiet_error_handler(const char* file,
+                    int         line,
+                    const char* function,
+                    int         err,
+                    const char* format,
+                    ...)
+{
+}
 
 /*
  * -----------------------------------------------------------------------------
@@ -115,6 +130,9 @@
   if (s->output_unit != NULL) {
     return SA_ERROR_INVALID;
   }
+
+  /* Turn off debug output to stderr */
+  snd_lib_error_set_handler(quiet_error_handler);
 
   if (snd_pcm_open(&s->output_unit, 
                    "default", 
diff -r 17e9560465b0 modules/libpref/src/init/all.js
--- a/modules/libpref/src/init/all.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/modules/libpref/src/init/all.js	Thu Oct 30 05:41:46 2008 -0400
@@ -512,7 +512,7 @@
 pref("javascript.allow.mailnews",           false);
 pref("javascript.options.strict",           false);
 pref("javascript.options.relimit",          false);
-pref("javascript.options.jit.content",      false);
+pref("javascript.options.jit.content",      true);
 pref("javascript.options.jit.chrome",       false);
 
 // advanced prefs
@@ -661,6 +661,7 @@
 
 // ccTLDs
 pref("network.IDN.whitelist.ac", true);
+pref("network.IDN.whitelist.ar", true);
 pref("network.IDN.whitelist.at", true);
 pref("network.IDN.whitelist.br", true);
 pref("network.IDN.whitelist.ch", true);
diff -r 17e9560465b0 modules/plugin/base/public/npfunctions.h
--- a/modules/plugin/base/public/npfunctions.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/modules/plugin/base/public/npfunctions.h	Thu Oct 30 05:41:46 2008 -0400
@@ -62,11 +62,11 @@
 typedef void         (*NPP_PrintProcPtr)(NPP instance, NPPrint* platformPrint);
 typedef int16_t      (*NPP_HandleEventProcPtr)(NPP instance, void* event);
 typedef void         (*NPP_URLNotifyProcPtr)(NPP instance, const char* url, NPReason reason, void* notifyData);
-typedef NPError      (*NPP_GetValueProcPtr)(NPP instance, NPPVariable variable, void *ret_alue);
-typedef NPError      (*NPP_SetValueProcPtr)(NPP instance, NPNVariable variable, void *ret_alue);
+typedef NPError      (*NPP_GetValueProcPtr)(NPP instance, NPPVariable variable, void *ret_value);
+typedef NPError      (*NPP_SetValueProcPtr)(NPP instance, NPNVariable variable, void *ret_value);
 
-typedef NPError      (*NPN_GetValueProcPtr)(NPP instance, NPNVariable variable, void *ret_alue);
-typedef NPError      (*NPN_SetValueProcPtr)(NPP instance, NPPVariable variable, void *ret_alue);
+typedef NPError      (*NPN_GetValueProcPtr)(NPP instance, NPNVariable variable, void *ret_value);
+typedef NPError      (*NPN_SetValueProcPtr)(NPP instance, NPPVariable variable, void *ret_value);
 typedef NPError      (*NPN_GetURLNotifyProcPtr)(NPP instance, const char* url, const char* window, void* notifyData);
 typedef NPError      (*NPN_PostURLNotifyProcPtr)(NPP instance, const char* url, const char* window, uint32_t len, const char* buf, NPBool file, void* notifyData);
 typedef NPError      (*NPN_GetURLProcPtr)(NPP instance, const char* url, const char* window);
diff -r 17e9560465b0 modules/plugin/base/src/nsPluginsDirDarwin.cpp
--- a/modules/plugin/base/src/nsPluginsDirDarwin.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/modules/plugin/base/src/nsPluginsDirDarwin.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -79,7 +79,7 @@
     CFStringRef pathRef = CFStringCreateWithCString(NULL, path, kCFStringEncodingUTF8);
     if (pathRef) {
         CFURLRef bundleURL = CFURLCreateWithFileSystemPath(NULL, pathRef, kCFURLPOSIXPathStyle, true);
-        if (bundleURL != NULL) {
+        if (bundleURL) {
             bundle = CFBundleCreate(NULL, bundleURL);
             CFRelease(bundleURL);
         }
@@ -204,7 +204,7 @@
 {
   int bufferLength = ::CFStringGetLength(cfString) + 1;
   char* newBuffer = static_cast<char*>(NS_Alloc(bufferLength));
-  if (!::CFStringGetCString(cfString, newBuffer, bufferLength, kCFStringEncodingUTF8)) {
+  if (newBuffer && !::CFStringGetCString(cfString, newBuffer, bufferLength, kCFStringEncodingUTF8)) {
     NS_Free(newBuffer);
     newBuffer = nsnull;
   }
@@ -314,8 +314,8 @@
 static char* p2cstrdup(StringPtr pstr)
 {
     int len = pstr[0];
-    char* cstr = new char[len + 1];
-    if (cstr != NULL) {
+    char* cstr = static_cast<char*>(NS_Alloc(len + 1));
+    if (cstr) {
         ::BlockMoveData(pstr + 1, cstr, len);
         cstr[len] = '\0';
     }
@@ -504,14 +504,24 @@
     }
   }
 
+  //XXX FIXME: past this point some (unlikely) error cases will leak memory
+  // (leak is bug 462023)
+
   // Fill in the info struct based on the data in the BPSupportedMIMETypes struct
   int variantCount = info.fVariantCount;
-  info.fMimeTypeArray = new char*[variantCount];
-  info.fExtensionArray = new char*[variantCount];
-  if (mi.infoStrings)
-    info.fMimeDescriptionArray = new char*[variantCount];
-
-  short mimeIndex = 2, descriptionIndex = 2;
+  info.fMimeTypeArray = static_cast<char**>(NS_Alloc(variantCount * sizeof(char*)));
+  if (!info.fMimeTypeArray)
+    return NS_ERROR_OUT_OF_MEMORY;
+  info.fExtensionArray = static_cast<char**>(NS_Alloc(variantCount * sizeof(char*)));
+  if (!info.fExtensionArray)
+    return NS_ERROR_OUT_OF_MEMORY;
+  if (mi.infoStrings) {
+    info.fMimeDescriptionArray = static_cast<char**>(NS_Alloc(variantCount * sizeof(char*)));
+    if (!info.fMimeDescriptionArray)
+      return NS_ERROR_OUT_OF_MEMORY;
+  }
+  short mimeIndex = 2;
+  short descriptionIndex = 2;
   for (int i = 0; i < variantCount; i++) {
     info.fMimeTypeArray[i] = GetNextPluginStringFromHandle(mi.typeStrings, &mimeIndex);
     info.fExtensionArray[i] = GetNextPluginStringFromHandle(mi.typeStrings, &mimeIndex);
@@ -532,20 +542,20 @@
 nsresult nsPluginFile::FreePluginInfo(nsPluginInfo& info)
 {
   if (info.fPluginInfoSize <= sizeof(nsPluginInfo)) {
-    delete[] info.fName;
-    delete[] info.fDescription;
+    NS_Free(info.fName);
+    NS_Free(info.fDescription);
     int variantCount = info.fVariantCount;
     for (int i = 0; i < variantCount; i++) {
-      delete[] info.fMimeTypeArray[i];
-      delete[] info.fExtensionArray[i];
-      delete[] info.fMimeDescriptionArray[i];
+      NS_Free(info.fMimeTypeArray[i]);
+      NS_Free(info.fExtensionArray[i]);
+      NS_Free(info.fMimeDescriptionArray[i]);
     }
-    delete[] info.fMimeTypeArray;
-    delete[] info.fMimeDescriptionArray;
-    delete[] info.fExtensionArray;
-    delete[] info.fFileName;
-    delete[] info.fFullPath;
-    delete[] info.fVersion;
+    NS_Free(info.fMimeTypeArray);
+    NS_Free(info.fMimeDescriptionArray);
+    NS_Free(info.fExtensionArray);
+    NS_Free(info.fFileName);
+    NS_Free(info.fFullPath);
+    NS_Free(info.fVersion);
   }
 
   return NS_OK;
diff -r 17e9560465b0 modules/plugin/default/mac/DefaultPlugin.mm
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/modules/plugin/default/mac/DefaultPlugin.mm	Thu Oct 30 05:41:46 2008 -0400
@@ -0,0 +1,252 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Josh Aas <josh@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "npapi.h"
+#include "npfunctions.h"
+
+#include <Carbon/Carbon.h>
+#include <CoreFoundation/CoreFoundation.h>
+
+#pragma GCC visibility push(default)
+extern "C"
+{
+NPError NP_Initialize(NPNetscapeFuncs *browserFuncs);
+NPError NP_GetEntryPoints(NPPluginFuncs *pluginFuncs);
+void    NP_Shutdown(void);
+
+NPError NPP_New(NPMIMEType pluginType, NPP instance, uint16_t mode, int16_t argc, char* argn[], char* argv[], NPSavedData* saved);
+NPError NPP_Destroy(NPP instance, NPSavedData** save);
+NPError NPP_SetWindow(NPP instance, NPWindow* window);
+NPError NPP_NewStream(NPP instance, NPMIMEType type, NPStream* stream, NPBool seekable, uint16_t* stype);
+NPError NPP_DestroyStream(NPP instance, NPStream* stream, NPReason reason);
+int32_t NPP_WriteReady(NPP instance, NPStream* stream);
+int32_t NPP_Write(NPP instance, NPStream* stream, int32_t offset, int32_t len, void* buffer);
+void    NPP_StreamAsFile(NPP instance, NPStream* stream, const char* fname);
+void    NPP_Print(NPP instance, NPPrint* platformPrint);
+int16_t NPP_HandleEvent(NPP instance, void* event);
+void    NPP_URLNotify(NPP instance, const char* URL, NPReason reason, void* notifyData);
+NPError NPP_GetValue(NPP instance, NPPVariable variable, void *value);
+NPError NPP_SetValue(NPP instance, NPNVariable variable, void *value);
+}
+#pragma GCC visibility pop
+
+// structure containing pointers to functions implemented by the browser
+static NPNetscapeFuncs* browser;
+
+// data for each instance of this plugin
+typedef struct PluginInstance {
+  NPP npp;
+  NPWindow window;
+} PluginInstance;
+
+void drawPlugin(NPP instance);
+
+// Symbol called once by the browser to initialize the plugin
+NPError NP_Initialize(NPNetscapeFuncs* browserFuncs)
+{
+  // save away browser functions
+  browser = browserFuncs;
+
+  return NPERR_NO_ERROR;
+}
+
+// Symbol called by the browser to get the plugin's function list
+NPError NP_GetEntryPoints(NPPluginFuncs* pluginFuncs)
+{
+  pluginFuncs->version = 11;
+  pluginFuncs->size = sizeof(pluginFuncs);
+  pluginFuncs->newp = NPP_New;
+  pluginFuncs->destroy = NPP_Destroy;
+  pluginFuncs->setwindow = NPP_SetWindow;
+  pluginFuncs->newstream = NPP_NewStream;
+  pluginFuncs->destroystream = NPP_DestroyStream;
+  pluginFuncs->asfile = NPP_StreamAsFile;
+  pluginFuncs->writeready = NPP_WriteReady;
+  pluginFuncs->write = (NPP_WriteProcPtr)NPP_Write;
+  pluginFuncs->print = NPP_Print;
+  pluginFuncs->event = NPP_HandleEvent;
+  pluginFuncs->urlnotify = NPP_URLNotify;
+  pluginFuncs->getvalue = NPP_GetValue;
+  pluginFuncs->setvalue = NPP_SetValue;
+
+  return NPERR_NO_ERROR;
+}
+
+// Symbol called once by the browser to shut down the plugin
+void NP_Shutdown(void)
+{
+  
+}
+
+// Called to create a new instance of the plugin
+NPError NPP_New(NPMIMEType pluginType, NPP instance, uint16_t mode, int16_t argc, char* argn[], char* argv[], NPSavedData* saved)
+{
+  PluginInstance *newInstance = (PluginInstance*)malloc(sizeof(PluginInstance));
+  bzero(newInstance, sizeof(PluginInstance));
+  
+  newInstance->npp = instance;
+  instance->pdata = newInstance;
+  
+  NPBool supportsCoreGraphics;
+  if (browser->getvalue(instance, NPNVsupportsCoreGraphicsBool, &supportsCoreGraphics) != NPERR_NO_ERROR)
+    supportsCoreGraphics = FALSE;
+  
+  if (!supportsCoreGraphics)
+    return NPERR_INCOMPATIBLE_VERSION_ERROR;
+  
+  browser->setvalue(instance, NPPVpluginDrawingModel, (void *)NPDrawingModelCoreGraphics);
+  
+  return NPERR_NO_ERROR;
+}
+
+// Called to destroy an instance of the plugin
+NPError NPP_Destroy(NPP instance, NPSavedData** save)
+{
+  free(instance->pdata);
+  
+  return NPERR_NO_ERROR;
+}
+
+// Called to update a plugin instances's NPWindow
+NPError NPP_SetWindow(NPP instance, NPWindow* window)
+{
+  PluginInstance* currentInstance = (PluginInstance*)(instance->pdata);
+  
+  currentInstance->window = *window;
+  
+  return NPERR_NO_ERROR;
+}
+
+
+NPError NPP_NewStream(NPP instance, NPMIMEType type, NPStream* stream, NPBool seekable, uint16_t* stype)
+{
+  *stype = NP_ASFILEONLY;
+  return NPERR_NO_ERROR;
+}
+
+NPError NPP_DestroyStream(NPP instance, NPStream* stream, NPReason reason)
+{
+  return NPERR_NO_ERROR;
+}
+
+int32_t NPP_WriteReady(NPP instance, NPStream* stream)
+{
+  return 0;
+}
+
+int32_t NPP_Write(NPP instance, NPStream* stream, int32_t offset, int32_t len, void* buffer)
+{
+  return 0;
+}
+
+void NPP_StreamAsFile(NPP instance, NPStream* stream, const char* fname)
+{
+  
+}
+
+void NPP_Print(NPP instance, NPPrint* platformPrint)
+{
+  
+}
+
+int16_t NPP_HandleEvent(NPP instance, void* event)
+{
+  EventRecord* carbonEvent = (EventRecord*)event;
+	if (carbonEvent && (carbonEvent->what == updateEvt))
+    drawPlugin(instance);
+  
+  return 0;
+}
+
+void NPP_URLNotify(NPP instance, const char* url, NPReason reason, void* notifyData)
+{
+  
+}
+
+NPError NPP_GetValue(NPP instance, NPPVariable variable, void *value)
+{
+  return NPERR_GENERIC_ERROR;
+}
+
+NPError NPP_SetValue(NPP instance, NPNVariable variable, void *value)
+{
+  return NPERR_GENERIC_ERROR;
+}
+
+void drawPlugin(NPP instance)
+{
+  PluginInstance* currentInstance = (PluginInstance*)(instance->pdata);
+  CGContextRef cgContext = ((NP_CGContext*)(currentInstance->window.window))->context;
+
+  float windowWidth = currentInstance->window.width;
+  float windowHeight = currentInstance->window.height;
+
+  // save the cgcontext gstate
+  CGContextSaveGState(cgContext);
+
+  // we get a flipped context
+  CGContextTranslateCTM(cgContext, 0.0, windowHeight);
+  CGContextScaleCTM(cgContext, 1.0, -1.0);
+
+  // draw a white background for the plugin
+  CGContextAddRect(cgContext, CGRectMake(0, 0, windowWidth, windowHeight));
+  CGContextSetGrayFillColor(cgContext, 1.0, 1.0);
+  CGContextDrawPath(cgContext, kCGPathFill);
+
+  // draw a blue frame around the plugin
+  CGContextAddRect(cgContext, CGRectMake(0, 0, windowWidth, windowHeight));
+  CGContextSetRGBStrokeColor(cgContext, 0.0, 0.0, 0.5, 1.0);
+  CGContextSetLineWidth(cgContext, 2.0);
+  CGContextStrokePath(cgContext);
+
+  // draw the broken plugin icon
+  CFBundleRef bundle = ::CFBundleGetBundleWithIdentifier(CFSTR("org.mozilla.DefaultPlugin"));
+  CFURLRef imageURL = ::CFBundleCopyResourceURL(bundle, CFSTR("plugin"), CFSTR("png"), NULL);
+  CGDataProviderRef dataProvider = ::CGDataProviderCreateWithURL(imageURL);
+  ::CFRelease(imageURL);
+  CGImageRef imageRef = ::CGImageCreateWithPNGDataProvider(dataProvider, NULL, TRUE, kCGRenderingIntentDefault);
+  ::CGDataProviderRelease(dataProvider);
+  float imageWidth = ::CGImageGetWidth(imageRef);
+  float imageHeight = ::CGImageGetHeight(imageRef);
+  CGRect drawRect = ::CGRectMake(windowWidth / 2 - imageWidth / 2, windowHeight / 2 - imageHeight / 2, imageWidth, imageHeight);
+  ::CGContextDrawImage(cgContext, drawRect, imageRef);
+  ::CGImageRelease(imageRef);
+
+  // restore the cgcontext gstate
+  CGContextRestoreGState(cgContext);
+}
diff -r 17e9560465b0 modules/plugin/default/mac/DefaultPlugin.xcodeproj/TemplateIcon.tiff
Binary file modules/plugin/default/mac/DefaultPlugin.xcodeproj/TemplateIcon.tiff has changed
diff -r 17e9560465b0 modules/plugin/default/mac/DefaultPlugin.xcodeproj/project.pbxproj
--- a/modules/plugin/default/mac/DefaultPlugin.xcodeproj/project.pbxproj	Thu Oct 23 09:51:35 2008 -0700
+++ b/modules/plugin/default/mac/DefaultPlugin.xcodeproj/project.pbxproj	Thu Oct 30 05:41:46 2008 -0400
@@ -3,73 +3,56 @@
 	archiveVersion = 1;
 	classes = {
 	};
-	objectVersion = 42;
+	objectVersion = 45;
 	objects = {
 
 /* Begin PBXBuildFile section */
-		4D1684A00830226300080847 /* DefaultPluginPrefix.h in Headers */ = {isa = PBXBuildFile; fileRef = 0F64AF2C0433C8A200A96652 /* DefaultPluginPrefix.h */; };
-		4D1684A20830226300080847 /* InfoPlist.strings in Resources */ = {isa = PBXBuildFile; fileRef = 089C167DFE841241C02AAC07 /* InfoPlist.strings */; };
-		4D1684A40830226300080847 /* NullPlugin.cpp in Sources */ = {isa = PBXBuildFile; fileRef = F5E0C34F036A130901A96660 /* NullPlugin.cpp */; };
-		4D1684A50830226300080847 /* npmac.cpp in Sources */ = {isa = PBXBuildFile; fileRef = F5E0C351036A130E01A96660 /* npmac.cpp */; };
-		4D1684A70830226300080847 /* Carbon.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 08EA7FFBFE8413EDC02AAC07 /* Carbon.framework */; };
-		4D1684A80830226300080847 /* CoreFoundation.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = F5A7D3AB036E359F01A96660 /* CoreFoundation.framework */; };
-		4D1684AA0830226300080847 /* NullPlugin.rsrc in Rez */ = {isa = PBXBuildFile; fileRef = F5E0C34D036A12DF01A96660 /* NullPlugin.rsrc */; };
+		032267660EAFA4C40059A1E6 /* DefaultPlugin.mm in Sources */ = {isa = PBXBuildFile; fileRef = 032267650EAFA4C40059A1E6 /* DefaultPlugin.mm */; };
+		032267840EAFA62E0059A1E6 /* Carbon.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 032267830EAFA62E0059A1E6 /* Carbon.framework */; };
+		032268110EAFB8720059A1E6 /* plugin.png in Resources */ = {isa = PBXBuildFile; fileRef = 032268100EAFB8720059A1E6 /* plugin.png */; };
+		8D576314048677EA00EA77CD /* CoreFoundation.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 0AA1909FFE8422F4C02AAC07 /* CoreFoundation.framework */; };
+		8D5B49A804867FD3000E48DA /* InfoPlist.strings in Resources */ = {isa = PBXBuildFile; fileRef = 8D5B49A704867FD3000E48DA /* InfoPlist.strings */; };
 /* End PBXBuildFile section */
 
-/* Begin PBXCopyFilesBuildPhase section */
-		4D1684AB0830226300080847 /* CopyFiles */ = {
-			isa = PBXCopyFilesBuildPhase;
-			buildActionMask = 2147483647;
-			dstPath = "";
-			dstSubfolderSpec = 6;
-			files = (
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-		};
-/* End PBXCopyFilesBuildPhase section */
-
 /* Begin PBXFileReference section */
+		032267650EAFA4C40059A1E6 /* DefaultPlugin.mm */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.objcpp; path = DefaultPlugin.mm; sourceTree = "<group>"; };
+		032267830EAFA62E0059A1E6 /* Carbon.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Carbon.framework; path = /System/Library/Frameworks/Carbon.framework; sourceTree = "<absolute>"; };
+		032268100EAFB8720059A1E6 /* plugin.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = plugin.png; sourceTree = "<group>"; };
 		089C167EFE841241C02AAC07 /* English */ = {isa = PBXFileReference; fileEncoding = 10; lastKnownFileType = text.plist.strings; name = English; path = English.lproj/InfoPlist.strings; sourceTree = "<group>"; };
-		08EA7FFBFE8413EDC02AAC07 /* Carbon.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Carbon.framework; path = /System/Library/Frameworks/Carbon.framework; sourceTree = "<absolute>"; };
-		0F64AF2C0433C8A200A96652 /* DefaultPluginPrefix.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DefaultPluginPrefix.h; sourceTree = "<group>"; };
-		4D1684AC0830226300080847 /* Info-DefaultPlugin.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = "Info-DefaultPlugin.plist"; sourceTree = "<group>"; };
-		4D1684AD0830226300080847 /* Default Plugin.plugin */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = "Default Plugin.plugin"; sourceTree = BUILT_PRODUCTS_DIR; };
-		F5A7D3AB036E359F01A96660 /* CoreFoundation.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreFoundation.framework; path = /System/Library/Frameworks/CoreFoundation.framework; sourceTree = "<absolute>"; };
-		F5E0C34D036A12DF01A96660 /* NullPlugin.rsrc */ = {isa = PBXFileReference; lastKnownFileType = archive.rsrc; path = NullPlugin.rsrc; sourceTree = SOURCE_ROOT; };
-		F5E0C34F036A130901A96660 /* NullPlugin.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; path = NullPlugin.cpp; sourceTree = SOURCE_ROOT; };
-		F5E0C351036A130E01A96660 /* npmac.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; path = npmac.cpp; sourceTree = SOURCE_ROOT; };
+		0AA1909FFE8422F4C02AAC07 /* CoreFoundation.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreFoundation.framework; path = /System/Library/Frameworks/CoreFoundation.framework; sourceTree = "<absolute>"; };
+		8D576316048677EA00EA77CD /* DefaultPlugin.plugin */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = DefaultPlugin.plugin; sourceTree = BUILT_PRODUCTS_DIR; };
+		8D576317048677EA00EA77CD /* Info.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
 /* End PBXFileReference section */
 
 /* Begin PBXFrameworksBuildPhase section */
-		4D1684A60830226300080847 /* Frameworks */ = {
+		8D576313048677EA00EA77CD /* Frameworks */ = {
 			isa = PBXFrameworksBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
-				4D1684A70830226300080847 /* Carbon.framework in Frameworks */,
-				4D1684A80830226300080847 /* CoreFoundation.framework in Frameworks */,
+				8D576314048677EA00EA77CD /* CoreFoundation.framework in Frameworks */,
+				032267840EAFA62E0059A1E6 /* Carbon.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
 /* End PBXFrameworksBuildPhase section */
 
 /* Begin PBXGroup section */
-		089C166AFE841209C02AAC07 /* MRJPlugin */ = {
+		089C166AFE841209C02AAC07 /* DefaultPlugin */ = {
 			isa = PBXGroup;
 			children = (
-				08FB77ADFE841716C02AAC07 /* Source */,
+				08FB77AFFE84173DC02AAC07 /* Source */,
 				089C167CFE841241C02AAC07 /* Resources */,
 				089C1671FE841209C02AAC07 /* External Frameworks and Libraries */,
-				19C28FB4FE9D528D11CA2CBB /* Products */,
-				4D1684AC0830226300080847 /* Info-DefaultPlugin.plist */,
+				19C28FB6FE9D52B211CA2CBB /* Products */,
 			);
-			name = MRJPlugin;
+			name = DefaultPlugin;
 			sourceTree = "<group>";
 		};
 		089C1671FE841209C02AAC07 /* External Frameworks and Libraries */ = {
 			isa = PBXGroup;
 			children = (
-				F5A7D3AB036E359F01A96660 /* CoreFoundation.framework */,
-				08EA7FFBFE8413EDC02AAC07 /* Carbon.framework */,
+				032267830EAFA62E0059A1E6 /* Carbon.framework */,
+				0AA1909FFE8422F4C02AAC07 /* CoreFoundation.framework */,
 			);
 			name = "External Frameworks and Libraries";
 			sourceTree = "<group>";
@@ -77,62 +60,48 @@
 		089C167CFE841241C02AAC07 /* Resources */ = {
 			isa = PBXGroup;
 			children = (
-				089C167DFE841241C02AAC07 /* InfoPlist.strings */,
-				F5E0C34D036A12DF01A96660 /* NullPlugin.rsrc */,
+				032268100EAFB8720059A1E6 /* plugin.png */,
+				8D576317048677EA00EA77CD /* Info.plist */,
+				8D5B49A704867FD3000E48DA /* InfoPlist.strings */,
 			);
 			name = Resources;
 			sourceTree = "<group>";
 		};
-		08FB77ADFE841716C02AAC07 /* Source */ = {
+		08FB77AFFE84173DC02AAC07 /* Source */ = {
 			isa = PBXGroup;
 			children = (
-				0F64AF2C0433C8A200A96652 /* DefaultPluginPrefix.h */,
-				F5E0C34F036A130901A96660 /* NullPlugin.cpp */,
-				F5E0C351036A130E01A96660 /* npmac.cpp */,
+				032267650EAFA4C40059A1E6 /* DefaultPlugin.mm */,
 			);
 			name = Source;
 			sourceTree = "<group>";
 		};
-		19C28FB4FE9D528D11CA2CBB /* Products */ = {
+		19C28FB6FE9D52B211CA2CBB /* Products */ = {
 			isa = PBXGroup;
 			children = (
-				4D1684AD0830226300080847 /* Default Plugin.plugin */,
+				8D576316048677EA00EA77CD /* DefaultPlugin.plugin */,
 			);
 			name = Products;
 			sourceTree = "<group>";
 		};
 /* End PBXGroup section */
 
-/* Begin PBXHeadersBuildPhase section */
-		4D16849F0830226300080847 /* Headers */ = {
-			isa = PBXHeadersBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-				4D1684A00830226300080847 /* DefaultPluginPrefix.h in Headers */,
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-		};
-/* End PBXHeadersBuildPhase section */
-
 /* Begin PBXNativeTarget section */
-		4D16849D0830226300080847 /* Default Plugin */ = {
+		8D57630D048677EA00EA77CD /* DefaultPlugin */ = {
 			isa = PBXNativeTarget;
-			buildConfigurationList = 0335A32F0CDD0E2C00E37285 /* Build configuration list for PBXNativeTarget "Default Plugin" */;
+			buildConfigurationList = 1DEB911A08733D790010E9CD /* Build configuration list for PBXNativeTarget "DefaultPlugin" */;
 			buildPhases = (
-				4D16849F0830226300080847 /* Headers */,
-				4D1684A10830226300080847 /* Resources */,
-				4D1684A30830226300080847 /* Sources */,
-				4D1684A60830226300080847 /* Frameworks */,
-				4D1684A90830226300080847 /* Rez */,
-				4D1684AB0830226300080847 /* CopyFiles */,
+				8D57630F048677EA00EA77CD /* Resources */,
+				8D576311048677EA00EA77CD /* Sources */,
+				8D576313048677EA00EA77CD /* Frameworks */,
 			);
 			buildRules = (
 			);
 			dependencies = (
 			);
-			name = "Default Plugin";
-			productName = MRJPlugin;
-			productReference = 4D1684AD0830226300080847 /* Default Plugin.plugin */;
+			name = DefaultPlugin;
+			productInstallPath = "$(HOME)/Library/Bundles";
+			productName = DefaultPlugin;
+			productReference = 8D576316048677EA00EA77CD /* DefaultPlugin.plugin */;
 			productType = "com.apple.product-type.bundle";
 		};
 /* End PBXNativeTarget section */
@@ -140,186 +109,138 @@
 /* Begin PBXProject section */
 		089C1669FE841209C02AAC07 /* Project object */ = {
 			isa = PBXProject;
-			buildConfigurationList = 0335A3340CDD0E2C00E37285 /* Build configuration list for PBXProject "DefaultPlugin" */;
-			compatibilityVersion = "Xcode 2.4";
+			buildConfigurationList = 1DEB911E08733D790010E9CD /* Build configuration list for PBXProject "DefaultPlugin" */;
+			compatibilityVersion = "Xcode 3.1";
 			hasScannedForEncodings = 1;
-			mainGroup = 089C166AFE841209C02AAC07 /* MRJPlugin */;
+			mainGroup = 089C166AFE841209C02AAC07 /* DefaultPlugin */;
 			projectDirPath = "";
 			projectRoot = "";
 			targets = (
-				4D16849D0830226300080847 /* Default Plugin */,
+				8D57630D048677EA00EA77CD /* DefaultPlugin */,
 			);
 		};
 /* End PBXProject section */
 
 /* Begin PBXResourcesBuildPhase section */
-		4D1684A10830226300080847 /* Resources */ = {
+		8D57630F048677EA00EA77CD /* Resources */ = {
 			isa = PBXResourcesBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
-				4D1684A20830226300080847 /* InfoPlist.strings in Resources */,
+				8D5B49A804867FD3000E48DA /* InfoPlist.strings in Resources */,
+				032268110EAFB8720059A1E6 /* plugin.png in Resources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
 /* End PBXResourcesBuildPhase section */
 
-/* Begin PBXRezBuildPhase section */
-		4D1684A90830226300080847 /* Rez */ = {
-			isa = PBXRezBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-				4D1684AA0830226300080847 /* NullPlugin.rsrc in Rez */,
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-		};
-/* End PBXRezBuildPhase section */
-
 /* Begin PBXSourcesBuildPhase section */
-		4D1684A30830226300080847 /* Sources */ = {
+		8D576311048677EA00EA77CD /* Sources */ = {
 			isa = PBXSourcesBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
-				4D1684A40830226300080847 /* NullPlugin.cpp in Sources */,
-				4D1684A50830226300080847 /* npmac.cpp in Sources */,
+				032267660EAFA4C40059A1E6 /* DefaultPlugin.mm in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
 /* End PBXSourcesBuildPhase section */
 
 /* Begin PBXVariantGroup section */
-		089C167DFE841241C02AAC07 /* InfoPlist.strings */ = {
+		8D5B49A704867FD3000E48DA /* InfoPlist.strings */ = {
 			isa = PBXVariantGroup;
 			children = (
 				089C167EFE841241C02AAC07 /* English */,
 			);
 			name = InfoPlist.strings;
-			sourceTree = SOURCE_ROOT;
+			sourceTree = "<group>";
 		};
 /* End PBXVariantGroup section */
 
 /* Begin XCBuildConfiguration section */
-		0335A3300CDD0E2C00E37285 /* Development */ = {
+		1DEB911B08733D790010E9CD /* Debug */ = {
 			isa = XCBuildConfiguration;
 			buildSettings = {
+				ALWAYS_SEARCH_USER_PATHS = NO;
 				COPY_PHASE_STRIP = NO;
-				FRAMEWORK_SEARCH_PATHS = "\"$(SYSTEM_LIBRARY_DIR)/Frameworks/CoreFoundation.framework\"";
 				GCC_DYNAMIC_NO_PIC = NO;
 				GCC_ENABLE_FIX_AND_CONTINUE = YES;
-				GCC_GENERATE_DEBUGGING_SYMBOLS = YES;
+				GCC_MODEL_TUNING = G5;
 				GCC_OPTIMIZATION_LEVEL = 0;
-				GCC_PREFIX_HEADER = DefaultPluginPrefix.h;
-				GCC_PREPROCESSOR_DEFINITIONS = (
-					"XP_MACOSX=1",
-					"NO_X11=1",
-					"USE_SYSTEM_CONSOLE=1",
-				);
-				HEADER_SEARCH_PATHS = (
-					../../../../dist/sdk/xpcom/include,
-					../../../../dist/include/caps,
-					../../../../dist/include/java,
-					../../../../dist/include/js,
-					../../../../dist/include/nspr,
-					../../../../dist/include/nspr/obsolete,
-					../../../../dist/include/oji,
-					../../../../dist/include/plugin,
-					../../../../dist/include/xpcom,
-					../../../../dist/include/xpconnect,
-					../../../../dist/include,
-					/Developer/Headers/FlatCarbon,
-				);
-				INFOPLIST_FILE = "Info-DefaultPlugin.plist";
-				LIBRARY_SEARCH_PATHS = /usr/lib;
-				OTHER_CFLAGS = "";
-				OTHER_LDFLAGS = "";
-				OTHER_REZFLAGS = "";
-				PRODUCT_NAME = "Default Plugin";
-				SECTORDER_FLAGS = "";
-				WARNING_CFLAGS = (
-					"-Wmost",
-					"-Wno-four-char-constants",
-					"-Wno-unknown-pragmas",
-				);
+				HEADER_SEARCH_PATHS = ../../../../dist/include/plugin;
+				INFOPLIST_FILE = Info.plist;
+				INSTALL_PATH = "$(HOME)/Library/Bundles";
+				PRODUCT_NAME = DefaultPlugin;
 				WRAPPER_EXTENSION = plugin;
-				ZERO_LINK = YES;
 			};
-			name = Development;
+			name = Debug;
 		};
-		0335A3310CDD0E2C00E37285 /* Deployment */ = {
+		1DEB911C08733D790010E9CD /* Release */ = {
 			isa = XCBuildConfiguration;
 			buildSettings = {
-				COPY_PHASE_STRIP = YES;
-				FRAMEWORK_SEARCH_PATHS = "\"$(SYSTEM_LIBRARY_DIR)/Frameworks/CoreFoundation.framework\"";
-				GCC_ENABLE_FIX_AND_CONTINUE = NO;
-				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
-				GCC_PREFIX_HEADER = DefaultPluginPrefix.h;
-				GCC_PREPROCESSOR_DEFINITIONS = (
-					"XP_MACOSX=1",
-					"NO_X11=1",
-					"USE_SYSTEM_CONSOLE=1",
-				);
-				HEADER_SEARCH_PATHS = (
-					../../../../dist/sdk/xpcom/include,
-					../../../../dist/include/caps,
-					../../../../dist/include/java,
-					../../../../dist/include/js,
-					../../../../dist/include/nspr,
-					../../../../dist/include/nspr/obsolete,
-					../../../../dist/include/oji,
-					../../../../dist/include/plugin,
-					../../../../dist/include/xpcom,
-					../../../../dist/include/xpconnect,
-					../../../../dist/include,
-					/Developer/Headers/FlatCarbon,
-				);
-				INFOPLIST_FILE = "Info-DefaultPlugin.plist";
-				LIBRARY_SEARCH_PATHS = /usr/lib;
-				OTHER_CFLAGS = "";
-				OTHER_LDFLAGS = "";
-				OTHER_REZFLAGS = "";
-				PRODUCT_NAME = "Default Plugin";
-				SECTORDER_FLAGS = "";
-				WARNING_CFLAGS = (
-					"-Wmost",
-					"-Wno-four-char-constants",
-					"-Wno-unknown-pragmas",
-				);
+				ALWAYS_SEARCH_USER_PATHS = NO;
+				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
+				GCC_MODEL_TUNING = G5;
+				HEADER_SEARCH_PATHS = ../../../../dist/include/plugin;
+				INFOPLIST_FILE = Info.plist;
+				INSTALL_PATH = "$(HOME)/Library/Bundles";
+				PRODUCT_NAME = DefaultPlugin;
 				WRAPPER_EXTENSION = plugin;
-				ZERO_LINK = NO;
 			};
-			name = Deployment;
+			name = Release;
 		};
-		0335A3350CDD0E2C00E37285 /* Development */ = {
+		1DEB911F08733D790010E9CD /* Debug */ = {
 			isa = XCBuildConfiguration;
 			buildSettings = {
+				ARCHS = "$(ARCHS_STANDARD_32_BIT)";
+				GCC_C_LANGUAGE_STANDARD = c99;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PREPROCESSOR_DEFINITIONS = "XP_MACOSX=1";
+				GCC_WARN_ABOUT_RETURN_TYPE = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				HEADER_SEARCH_PATHS = ../../../../dist/include/plugin;
+				ONLY_ACTIVE_ARCH = YES;
+				PREBINDING = NO;
+				SDKROOT = "";
+				WRAPPER_EXTENSION = plugin;
 			};
-			name = Development;
+			name = Debug;
 		};
-		0335A3360CDD0E2C00E37285 /* Deployment */ = {
+		1DEB912008733D790010E9CD /* Release */ = {
 			isa = XCBuildConfiguration;
 			buildSettings = {
+				ARCHS = "$(ARCHS_STANDARD_32_BIT)";
+				GCC_C_LANGUAGE_STANDARD = c99;
+				GCC_PREPROCESSOR_DEFINITIONS = "XP_MACOSX=1";
+				GCC_WARN_ABOUT_RETURN_TYPE = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				HEADER_SEARCH_PATHS = ../../../../dist/include/plugin;
+				PREBINDING = NO;
+				SDKROOT = "";
+				SEPARATE_SYMBOL_EDIT = NO;
+				STRIP_INSTALLED_PRODUCT = YES;
+				WRAPPER_EXTENSION = plugin;
 			};
-			name = Deployment;
+			name = Release;
 		};
 /* End XCBuildConfiguration section */
 
 /* Begin XCConfigurationList section */
-		0335A32F0CDD0E2C00E37285 /* Build configuration list for PBXNativeTarget "Default Plugin" */ = {
+		1DEB911A08733D790010E9CD /* Build configuration list for PBXNativeTarget "DefaultPlugin" */ = {
 			isa = XCConfigurationList;
 			buildConfigurations = (
-				0335A3300CDD0E2C00E37285 /* Development */,
-				0335A3310CDD0E2C00E37285 /* Deployment */,
+				1DEB911B08733D790010E9CD /* Debug */,
+				1DEB911C08733D790010E9CD /* Release */,
 			);
 			defaultConfigurationIsVisible = 0;
-			defaultConfigurationName = Development;
+			defaultConfigurationName = Release;
 		};
-		0335A3340CDD0E2C00E37285 /* Build configuration list for PBXProject "DefaultPlugin" */ = {
+		1DEB911E08733D790010E9CD /* Build configuration list for PBXProject "DefaultPlugin" */ = {
 			isa = XCConfigurationList;
 			buildConfigurations = (
-				0335A3350CDD0E2C00E37285 /* Development */,
-				0335A3360CDD0E2C00E37285 /* Deployment */,
+				1DEB911F08733D790010E9CD /* Debug */,
+				1DEB912008733D790010E9CD /* Release */,
 			);
 			defaultConfigurationIsVisible = 0;
-			defaultConfigurationName = Development;
+			defaultConfigurationName = Release;
 		};
 /* End XCConfigurationList section */
 	};
diff -r 17e9560465b0 modules/plugin/default/mac/DefaultPluginPrefix.h
--- a/modules/plugin/default/mac/DefaultPluginPrefix.h	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,1 +0,0 @@
-#include "mozilla-config.h"
diff -r 17e9560465b0 modules/plugin/default/mac/English.lproj/InfoPlist.strings
Binary file modules/plugin/default/mac/English.lproj/InfoPlist.strings has changed
diff -r 17e9560465b0 modules/plugin/default/mac/Info-DefaultPlugin.plist
--- a/modules/plugin/default/mac/Info-DefaultPlugin.plist	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,22 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
-<plist version="1.0">
-<dict>
-	<key>CFBundleDevelopmentRegion</key>
-	<string>English</string>
-	<key>CFBundleExecutable</key>
-	<string>Default Plugin</string>
-	<key>CFBundleIconFile</key>
-	<string></string>
-	<key>CFBundleIdentifier</key>
-	<string>org.mozilla.DefaultPlugin</string>
-	<key>CFBundleInfoDictionaryVersion</key>
-	<string>6.0</string>
-	<key>CFBundlePackageType</key>
-	<string>NSPL</string>
-	<key>CFBundleVersion</key>
-	<string>1.0.0.15</string>
-	<key>CSResourcesFileMapped</key>
-	<true/>
-</dict>
-</plist>
diff -r 17e9560465b0 modules/plugin/default/mac/Info.plist
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/modules/plugin/default/mac/Info.plist	Thu Oct 30 05:41:46 2008 -0400
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+	<key>WebPluginMIMETypes</key>
+	<dict>
+		<key>*</key>
+		<dict>
+			<key>WebPluginExtensions</key>
+			<array>
+				<string>*</string>
+			</array>
+			<key>WebPluginTypeDescription</key>
+			<string>All types</string>
+		</dict>
+	</dict>
+	<key>WebPluginDescription</key>
+	<string>Gecko default plugin</string>
+	<key>WebPluginName</key>
+	<string>Default Plugin</string>
+	<key>CFBundleDevelopmentRegion</key>
+	<string>English</string>
+	<key>CFBundleExecutable</key>
+	<string>${EXECUTABLE_NAME}</string>
+	<key>CFBundleIdentifier</key>
+	<string>org.mozilla.DefaultPlugin</string>
+	<key>CFBundleInfoDictionaryVersion</key>
+	<string>6.0</string>
+	<key>CFBundlePackageType</key>
+	<string>NSPL</string>
+	<key>CFBundleVersion</key>
+	<string>2.0</string>
+</dict>
+</plist>
diff -r 17e9560465b0 modules/plugin/default/mac/Makefile.in
--- a/modules/plugin/default/mac/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/modules/plugin/default/mac/Makefile.in	Thu Oct 30 05:41:46 2008 -0400
@@ -46,18 +46,16 @@
 MODULE      = plugin
 
 ifdef MOZ_DEBUG
-BUILDSTYLE	= Development
+BUILDSTYLE	= Debug
 else
-BUILDSTYLE	= Deployment
+BUILDSTYLE	= Release
 endif
 
 PROJECT=DefaultPlugin.xcodeproj
 PROJECT_ARG=-project $(PROJECT)
 PBBUILD_ARG=$(PBBUILD_SETTINGS)
 
-TARGET		= "Default Plugin"
-
-PACKAGE_FILE = npnul.pkg
+TARGET		= "DefaultPlugin"
 
 unexport CC CXX
 
@@ -67,20 +65,16 @@
 export::
 	rsync -a --exclude .DS_Store --exclude "CVS/" $(srcdir)/$(PROJECT) .
 	ln -fs $(srcdir)/English.lproj
-	ln -fs $(srcdir)/DefaultPluginPrefix.h
-	ln -fs $(srcdir)/NullPlugin.cpp
-	ln -fs $(srcdir)/npmac.cpp
-	ln -fs $(srcdir)/Info-*.plist .
-	ln -fs $(srcdir)/NullPlugin.rsrc
+	ln -fs $(srcdir)/DefaultPlugin.mm
+	ln -fs $(srcdir)/Info.plist
+	ln -fs $(srcdir)/plugin.png
 
 GARBAGE_DIRS += $(PROJECT)
 GARBAGE += \
 	English.lproj \
-	DefaultPluginPrefix.h \
-	NullPlugin.cpp \
-	npmac.cpp \
-	Info-*.plist \
-	NullPlugin.rsrc \
+	DefaultPlugin.mm \
+	Info.plist \
+	plugin.png \
 	$(NULL)
 endif
 
@@ -89,7 +83,7 @@
 libs install:: install-plugin
 
 install-plugin: build-plugin
-	$(INSTALL) "$(XCODE_PRODUCT_DIR)/Default Plugin.plugin" $(DIST)/bin/plugins
+	$(INSTALL) "$(XCODE_PRODUCT_DIR)/DefaultPlugin.plugin" $(DIST)/bin/plugins
 
 build-plugin:
-	$(PBBUILD) $(PROJECT_ARG) -target $(TARGET) -buildstyle $(BUILDSTYLE) $(PBBUILD_ARG)
+	$(PBBUILD) $(PROJECT_ARG) -target $(TARGET) -configuration $(BUILDSTYLE) $(PBBUILD_ARG)
diff -r 17e9560465b0 modules/plugin/default/mac/NullPlugin.cpp
--- a/modules/plugin/default/mac/NullPlugin.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,933 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 1998
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *  Josh Aas <josh@mozilla.com>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-
-#include "npapi.h"
-
-#include <Carbon/Carbon.h>
-#include <CoreFoundation/CoreFoundation.h>
-
-#include <string.h>
-#include <ctype.h>
-#include <stdio.h>
-
-#define PLUGINFINDER_COMMAND_BEGINNING "javascript:window.open(\""
-#define PLUGINFINDER_COMMAND_END "\",\"plugin\",\"toolbar=no,status=no,resizable=no,scrollbars=no,height=252,width=626\");"
-#define PLUGINFINDER_COMMAND_END2 "\",\"plugin\",\"toolbar=no,status=no,resizable=yes,scrollbars=yes,height=252,width=626\");"
-
-
-// Instance state information about the plugin.
-class CPlugin
-{
-public:
-  enum HiliteState { kUnhilited = 0, kHilited = 1 };  
-
-  static NPError Initialize();
-  static void Shutdown();
-
-  // no ctor because CPlugin is allocated and constructed by hand.
-  // ideally, this should use placement |new|.
-
-  void Constructor(NPP instance, NPMIMEType type, uint16_t mode, int16_t argc, char* argn[], char* argv[]);
-  void Destructor();
-
-  void SetWindow(NPWindow* window);
-  void Print(NPPrint* printInfo);
-  Boolean HandleEvent(EventRecord*);
-
-protected:
-  void Draw(HiliteState hilite);
-  void DrawString(const unsigned char* text, short width, short height, short centerX, Rect drawRect);
-  void MouseDown();
-
-  Boolean FocusDraw();
-  void RestoreDraw();
-      
-  void DetermineURL(int16_t argc, char* argn[], char* argv[]);
-  char* MakeDefaultURL(void);
-  void AddMimeTypeToList(StringPtr cTypeString);
-  Boolean CheckMimeTypes();
-  void AskAndLoadURL();
-  void RefreshPluginPage();
-      
-  Ptr New(UInt32 size);
-  void Delete(Ptr ptr);
-
-  Boolean IsPluginHidden(int16_t argc, char* argn[], char* argv[]);
-
-private:
-  static CIconHandle sIconHandle;
-  static CursHandle sHandCursor;
-  static char* sAltText;
-  static char* sInstallCommand;
-  static char* sDefaultPage;
-  static char* sRefreshText;
-  static char* sJavaScriptPage;
-
-  NPP fInstance;
-  NPWindow* fWindow;
-  uint16_t fMode;
-  NPMIMEType fType;
-  char* fPageURL;
-  char* fFileURL;
-  NPBool m_bOffline;
-  NPBool m_bJavaScript;
-
-  GrafPtr fSavePort;
-  RgnHandle fSaveClip;
-  Rect fRevealedRect;
-  short fSavePortTop;
-  short fSavePortLeft;
-  Boolean fUserInstalledPlugin;
-  Boolean fHiddenPlugin;
-  Boolean fAskedLoadURL;
-};
-
-CIconHandle CPlugin::sIconHandle = NULL;
-CursHandle CPlugin::sHandCursor = NULL;
-char* CPlugin::sAltText = NULL;
-char* CPlugin::sInstallCommand = NULL; 
-char* CPlugin::sDefaultPage = NULL;
-char* CPlugin::sRefreshText = NULL;
-char* CPlugin::sJavaScriptPage = NULL;
-
-extern short gResFile;
-
-// 'cicn'
-const short rBrokenPluginIcon = 326;
-
-// 'CURS'
-const short rHandCursor = 128;
-
-// 'STR '
-const short rDefaultPluginURL = 128;
-const short rAltTextString = 129;
-const short rJavaScriptInstallCommand = 130;
-const short rRefreshTextString = 131;
-const short rJavaScriptPageURL = 132;
-
-// 'STR#'
-const short rTypeListStrings = 129;
-
-static const char szPluginFinderCommandBeginning[] = PLUGINFINDER_COMMAND_BEGINNING;
-static const char szPluginFinderCommandEnd[] = PLUGINFINDER_COMMAND_END;
-
-
-NPError NPP_Initialize(void)
-{
-  return CPlugin::Initialize();
-}
-
-
-void NPP_Shutdown(void)
-{
-  CPlugin::Shutdown();
-}
-
-
-NPError NPP_New(NPMIMEType type, NPP instance, uint16_t mode, int16_t argc, char* argn[], char* argv[], NPSavedData*)
-{
-  if (!instance)
-    return NPERR_INVALID_INSTANCE_ERROR;
-    
-  CPlugin* This = (CPlugin*) (char*)NPN_MemAlloc(sizeof(CPlugin));
-  instance->pdata = This;
-  if (This) {
-    This->Constructor(instance, type, mode, argc, argn, argv);
-    return NPERR_NO_ERROR;
-  }
-  else {
-    return NPERR_OUT_OF_MEMORY_ERROR;
-  }
-}
-
-
-NPError NP_LOADDS
-NPP_Destroy(NPP instance, NPSavedData** /*save*/)
-{
-  if (!instance)
-    return NPERR_INVALID_INSTANCE_ERROR;
-
-  CPlugin* This = (CPlugin*) instance->pdata;
-  if (This) {
-    This->Destructor();
-    NPN_MemFree(This);
-    instance->pdata = NULL;
-  }
-
-  return NPERR_NO_ERROR;
-}
-
-
-NPError NPP_SetWindow(NPP instance, NPWindow* window)
-{
-  if (!instance)
-    return NPERR_INVALID_INSTANCE_ERROR;
-
-  CPlugin* This = (CPlugin*) instance->pdata;
-  if (This)
-    This->SetWindow(window);
-
-  return NPERR_NO_ERROR;
-}
-
-
-NPError NP_LOADDS
-NPP_NewStream(NPP instance,
-              NPMIMEType /*type*/,
-              NPStream* /*stream*/, 
-              NPBool /*seekable*/,
-              uint16_t* /*stype*/)
-{
-  if (!instance)
-    return NPERR_INVALID_INSTANCE_ERROR;
-
-  return NPERR_NO_ERROR;
-}
-
-
-int32_t STREAMBUFSIZE = 0X0FFFFFFF;   // If we are reading from a file in NPAsFile
-                                    // mode so we can take any size stream in our
-                                    // write call (since we ignore it)
-
-
-int32_t NP_LOADDS
-NPP_WriteReady(NPP /*instance*/, NPStream* /*stream*/)
-{
-  return STREAMBUFSIZE; // Number of bytes ready to accept in NPP_Write()
-}
-
-
-int32_t NP_LOADDS
-NPP_Write(NPP /*instance*/, NPStream* /*stream*/, int32_t /*offset*/, int32_t len, void* /*buffer*/)
-{
-  return len; // The number of bytes accepted
-}
-
-
-NPError NP_LOADDS
-NPP_DestroyStream(NPP instance, NPStream* /*stream*/, NPError /*reason*/)
-{
-  if (!instance)
-    return NPERR_INVALID_INSTANCE_ERROR;
-
-  return NPERR_NO_ERROR;
-}
-
-
-void NP_LOADDS
-NPP_StreamAsFile(NPP /*instance*/, NPStream */*stream*/, const char* /*fname*/)
-{
-}
-
-
-void NP_LOADDS
-NPP_Print(NPP instance, NPPrint* printInfo)
-{
-  if (!printInfo)
-    return;
-
-  if (instance) {
-    if (printInfo->mode == NP_FULL) {
-      printInfo->print.fullPrint.pluginPrinted = FALSE; // Do the default
-    }
-    else { // If not fullscreen, we must be embedded
-      CPlugin* This = (CPlugin*)instance->pdata;
-      if (This)
-        This->Print(printInfo);
-    }
-  }
-}
-
-
-// Mac-only
-int16_t NPP_HandleEvent(NPP instance, void* event)
-{
-  if (instance) {
-    CPlugin* This = (CPlugin*) instance->pdata;
-    if (This && event)
-      return This->HandleEvent((EventRecord*) event);
-  }
-
-  return FALSE;
-}
-
-
-void NPP_URLNotify(NPP /*instance*/, const char* /*url*/, NPReason /*reason*/, void* /*notifyData*/)
-{
-}
-
-
-NPError CPlugin::Initialize()
-{
-  Handle string;
-  short saveResFile = CurResFile();
-
-  UseResFile(gResFile);
-
-  // Get Resources
-  CPlugin::sIconHandle = GetCIcon(rBrokenPluginIcon);
-  CPlugin::sHandCursor = GetCursor(rHandCursor);
-
-  // Get "alt text" string
-  string = Get1Resource('STR ', rAltTextString);
-  if (string && *string) {
-    short stringLen = (*string)[0];
-    CPlugin::sAltText = (char*)NPN_MemAlloc(stringLen +1);
-    if (CPlugin::sAltText) {
-      short src = 1;
-      short dest = 0;
-      while (src <= stringLen)
-        CPlugin::sAltText[dest++] = (*string)[src++];
-      CPlugin::sAltText[dest++] = 0;
-    }
-  }
-  ReleaseResource(string);
-
-  // Get "refresh text" string
-  string = Get1Resource('STR ', rRefreshTextString);
-  if (string && *string) {
-    short stringLen = (*string)[0];
-    CPlugin::sRefreshText = (char*)NPN_MemAlloc(stringLen + 1);
-    if (CPlugin::sRefreshText) {
-      short src = 1;
-      short dest = 0;
-      while (src <= stringLen)
-        CPlugin::sRefreshText[dest++] = (*string)[src++];
-      CPlugin::sRefreshText[dest++] = 0;
-    }
-  }
-  ReleaseResource(string);
-
-  // Get JavaScript install command string
-  string = Get1Resource('STR ', rJavaScriptInstallCommand);
-  if (string && *string) {
-    short stringLen = (*string)[0];
-    CPlugin::sInstallCommand = (char*)NPN_MemAlloc(stringLen + 1);
-    if (CPlugin::sInstallCommand) {
-      short src = 1;
-      short dest = 0;
-      while (src <= stringLen)
-        CPlugin::sInstallCommand[dest++] = (*string)[src++];
-      CPlugin::sInstallCommand[dest++] = 0;
-    }
-  }
-  ReleaseResource(string);
-
-  // Get default plug-in page URL
-  string = Get1Resource('STR ', rDefaultPluginURL);
-  if (string && *string) {
-    short stringLen = (*string)[0];
-    CPlugin::sDefaultPage = (char*)NPN_MemAlloc(stringLen + 1);
-    if (CPlugin::sDefaultPage) {
-      short src = 1;
-      short dest = 0;
-      while (src <= stringLen)
-        CPlugin::sDefaultPage[dest++] = (*string)[src++];
-      CPlugin::sDefaultPage[dest++] = 0;
-    }
-  }
-  ReleaseResource(string);
-
-  // Get javascript plug-in page URL
-  string = Get1Resource('STR ', rJavaScriptPageURL);
-  if (string && *string) {
-    short stringLen = (*string)[0];
-    CPlugin::sJavaScriptPage = (char*)NPN_MemAlloc(stringLen + 1);
-    if (CPlugin::sJavaScriptPage) {
-      short src = 1;
-      short dest = 0;
-      while (src <= stringLen)
-        CPlugin::sJavaScriptPage[dest++] = (*string)[src++];
-      CPlugin::sJavaScriptPage[dest++] = 0;
-    }
-  }
-  ReleaseResource(string);
-
-  UseResFile(saveResFile);
-
-  return NPERR_NO_ERROR;
-}
-
-
-void CPlugin::Shutdown()
-{
-  if (CPlugin::sIconHandle)
-    ::ReleaseResource((Handle) CPlugin::sIconHandle);
-  if (CPlugin::sHandCursor)
-    ::ReleaseResource((Handle) CPlugin::sHandCursor);
-
-  if (CPlugin::sAltText)
-    NPN_MemFree(CPlugin::sAltText);
-  if (CPlugin::sInstallCommand)
-    NPN_MemFree(CPlugin::sInstallCommand);
-  if (CPlugin::sDefaultPage)
-    NPN_MemFree(CPlugin::sDefaultPage);
-  if (CPlugin::sRefreshText)
-    NPN_MemFree(CPlugin::sRefreshText);
-}
-
-
-void CPlugin::Constructor(NPP instance, NPMIMEType type, uint16_t mode, int16_t argc, char* argn[], char* argv[])
-{
-  fWindow = NULL;
-  fPageURL = NULL;
-  fFileURL = NULL;
-  fInstance = instance;
-  fMode = mode; // Mode is NP_EMBED, NP_FULL, or NP_BACKGROUND (see npapi.h)
-  fAskedLoadURL = false;
-  fUserInstalledPlugin = false;
-  
-  // Save a copy of our mime type string
-  short typeLength = strlen(type);
-  fType = (char*)NPN_MemAlloc(typeLength+1);
-  if (fType)
-    strcpy(fType, type);
-  
-  // Make a handy region for use in FocusDraw
-  fSaveClip = NewRgn();
-
-  // determine if the plugin is specified as HIDDEN
-  fHiddenPlugin = IsPluginHidden(argc, argn, argv);
-
-  // Get some information about our environment
-  NPN_GetValue(fInstance, NPNVisOfflineBool, (void *)&m_bOffline);
-  NPN_GetValue(fInstance, NPNVjavascriptEnabledBool, (void *)&m_bJavaScript);
-
-  // Figure out what URL we will go to
-  DetermineURL(argc, argn, argv);
-}
-
-
-void CPlugin::Destructor()
-{
-  if (fSaveClip)
-    DisposeRgn(fSaveClip);
-  
-  if (fType)
-    NPN_MemFree(fType);
-  if (fFileURL)
-    NPN_MemFree(fFileURL);
-  if (fPageURL)
-    NPN_MemFree(fPageURL);
-}    
-
-
-void CPlugin::SetWindow(NPWindow* window)
-{
-  fWindow = window;
-}
-
-
-// To print, we need to retrieve the printing window from the printInfo,
-// temporarily make it our window, draw into it, and restore the window.
-void CPlugin::Print(NPPrint* printInfo)
-{
-  NPWindow* printWindow = &(printInfo->print.embedPrint.window);
-
-  NPWindow* oldWindow = fWindow;
-  fWindow = printWindow;
-
-  if (FocusDraw()) {
-    Draw(kUnhilited);
-    RestoreDraw();
-  }
-
-  fWindow = oldWindow;
-}
-
-
-Boolean CPlugin::HandleEvent(EventRecord* ev)
-{
-  Boolean eventHandled = false;
-  
-  switch (ev->what)
-  {
-    case mouseDown:
-      MouseDown();
-      eventHandled = true;
-      break;
-
-    case updateEvt:
-      if (FocusDraw()) {
-        Draw(kUnhilited);
-        RestoreDraw();
-      }
-      eventHandled = true;
-      break;
-
-    case NPEventType_AdjustCursorEvent:
-      if (CPlugin::sHandCursor)
-        SetCursor(*CPlugin::sHandCursor);
-      if (fUserInstalledPlugin) {
-        if (CPlugin::sRefreshText)
-          NPN_Status(fInstance, CPlugin::sRefreshText);        
-      }
-      else {
-        if (CPlugin::sAltText)
-          NPN_Status(fInstance, CPlugin::sAltText);
-      }
-      eventHandled = true;
-      break;
-
-    case nullEvent:
-      // NOTE: We have to wait until idle time
-      // to ask the user if they want to visit
-      // the URL to avoid reentering XP code.
-      if (!fAskedLoadURL) {
-        if (CheckMimeTypes())
-          AskAndLoadURL();
-        fAskedLoadURL = true;
-      }
-      break;
-    default:
-      break;
-  }
-
-  return eventHandled;
-}
-
-
-void CPlugin::Draw(HiliteState hilite)
-{
-  UInt8 *pTheText;
-  SInt32 height = fWindow->height;
-  SInt32 width = fWindow->width;
-  SInt32 centerX = (width) >> 1;
-  SInt32 centerY = (height) >> 1;
-  Rect drawRect;
-  RGBColor black = { 0x0000, 0x0000, 0x0000 };
-  RGBColor white = { 0xFFFF, 0xFFFF, 0xFFFF };
-  RGBColor hiliteColor = { 0x0000, 0x0000, 0x0000 };
-  short transform;
-
-  drawRect.top = 0;
-  drawRect.left = 0;
-  drawRect.bottom = height;
-  drawRect.right = width;
-
-  if (height < 4 && width < 4)
-    return;
-
-  PenNormal();
-  RGBForeColor(&black);
-  RGBBackColor(&white);
-
-  Pattern qdWhite;
-  FillRect(&drawRect, GetQDGlobalsWhite(&qdWhite));
-
-  if (hilite == kHilited) {
-    hiliteColor.red = 0xFFFF;
-    transform = ttSelected;
-  }
-  else {
-    hiliteColor.blue = 0xFFFF;
-    transform = ttNone;
-  }
-
-  RGBForeColor(&hiliteColor);
-  FrameRect(&drawRect);
-
-  if (height > 32 && width > 32 && CPlugin::sIconHandle) {
-    drawRect.top = centerY - 16;
-    drawRect.bottom = centerY + 16;
-    drawRect.left = centerX - 16;
-    drawRect.right = centerX + 16;
-    PlotCIconHandle(&drawRect, atAbsoluteCenter, transform, CPlugin::sIconHandle);
-  }
-
-  if (fUserInstalledPlugin) {
-    pTheText = (unsigned char*)CPlugin::sRefreshText;
-  }
-  else {
-    pTheText = (unsigned char*)CPlugin::sAltText;
-  }
-  DrawString(pTheText, width, height, centerX, drawRect);
-}
-
-
-// Track the click in our plugin by drawing the icon enabled or disabled
-// as the user moves the mouse in and out with the button held down.  If
-// they let up the mouse while still inside, get the URL.
-void  CPlugin::MouseDown()
-{
-  if (FocusDraw()) {
-    Draw(kHilited);
-    Boolean inside = true;
-  
-    // evil CPU-hogging loop on Mac OS X!
-    while (StillDown()) {
-      Point localMouse;
-      GetMouse(&localMouse);
-      Boolean insideNow = ::PtInRect(localMouse, &fRevealedRect);
-
-      if (insideNow != inside) {
-        Draw(insideNow ? kHilited : kUnhilited);
-        inside = insideNow;
-      }
-    }
-    
-    if (inside) {
-      Draw(kUnhilited);
-      if (!fUserInstalledPlugin)
-        AskAndLoadURL();
-      else
-        RefreshPluginPage();
-    }
-
-    RestoreDraw();
-  }
-}
-
-
-Boolean CPlugin::FocusDraw()
-{
-  if (!fWindow)
-    return false;
-    
-  NP_Port* npport = (NP_Port*) fWindow->window;
-  CGrafPtr ourPort = npport->port;
-  
-  if (fWindow->clipRect.left < fWindow->clipRect.right) {
-    GetPort(&fSavePort);
-    SetPort((GrafPtr) ourPort);
-    Rect portRect;
-    GetPortBounds(ourPort, &portRect);
-    fSavePortTop = portRect.top;
-    fSavePortLeft = portRect.left;
-    GetClip(fSaveClip);
-    
-    fRevealedRect.top = fWindow->clipRect.top + npport->porty;
-    fRevealedRect.left = fWindow->clipRect.left + npport->portx;
-    fRevealedRect.bottom = fWindow->clipRect.bottom + npport->porty;
-    fRevealedRect.right = fWindow->clipRect.right + npport->portx;
-    SetOrigin(npport->portx, npport->porty);
-    ClipRect(&fRevealedRect);
-
-    return true;
-  }
-  else {
-    return false;
-  }
-}
-
-
-void CPlugin::RestoreDraw()
-{
-  SetOrigin(fSavePortLeft, fSavePortTop);
-  SetClip(fSaveClip);
-  SetPort(fSavePort);
-}
-
-
-// Get a URL from either the parameters passed from the EMBED.
-// Append "?" and our mime type and save for later use.
-void CPlugin::DetermineURL(int16_t argc, char* argn[], char* argv[])
-{
-  char* url;
-  SInt32 additionalLength = 0;
-  SInt32 i;
-
-  // Appended to the URL will be a "?" and the mime type of this instance.  This lets the server
-  // do something intelligent with a CGI script.
-
-  if (fType)
-    additionalLength += (strlen(fType) + 1); // Add 1 for '?'
-
-  // The page designer can specify a URL where the plugin for this type can be downloaded.  Here
-  // we scan the arguments for this attribute and save it away if we
-  // find it for later use by LoadPluginURL().
-  for (i = 0; i < argc; i++) {
-    if ((strcasecmp(argn[i], "PLUGINSPAGE") == 0) || (strcasecmp(argn[i], "CODEBASE") == 0)) {
-      url = argv[i];
-      fPageURL = (char*)NPN_MemAlloc(strlen(url) + 1 + additionalLength);  // Add 1 for '\0'
-      if (fPageURL) {
-        if (additionalLength > 0) {
-          sprintf(fPageURL, "%s?%s", url, fType);
-        }
-        else {
-          strcpy(fPageURL, url);  
-        }
-      }
-      break;
-    } else if ((strcasecmp(argn[i], "PLUGINURL") == 0) || (strcasecmp(argn[i], "CLASSID") == 0)) {
-      url = argv[i];
-      if (CPlugin::sInstallCommand) {
-        // Allocate a new string
-        fFileURL = (char*)NPN_MemAlloc(strlen(CPlugin::sInstallCommand) + 1 + strlen(url));  
-        if (fFileURL)
-          sprintf(fFileURL, CPlugin::sInstallCommand, url);
-      }
-      break;
-    }
-  }
-}
-
-
-
-// Get a URL from our resources.  Append "?" and our mime type and save for later use.
-char *CPlugin::MakeDefaultURL(void)
-{
-  char *pDefURL = NULL;
-  SInt32 additionalLength = 0;
-
-  // Appended to the URL will be a "?" and the mime type of this instance.  This lets the server
-  // do something intelligent with a CGI script.
-
-  if (fType)
-    additionalLength += (strlen(fType) + 1);    // Add 1 for '?'
-
-  if (!m_bJavaScript) {
-    if (CPlugin::sDefaultPage) {
-      pDefURL = (char*)NPN_MemAlloc(strlen(CPlugin::sDefaultPage) + 1 + additionalLength);
-      if (pDefURL) {
-        if (additionalLength > 0) {
-          sprintf(pDefURL, "%s?%s", CPlugin::sDefaultPage, fType);
-        }
-        else {
-          strcpy(pDefURL, CPlugin::sDefaultPage);  
-        }
-      }
-    }
-  }
-  else {
-    if (CPlugin::sJavaScriptPage) {
-      pDefURL = (char*)NPN_MemAlloc(strlen(szPluginFinderCommandBeginning) +
-            strlen(CPlugin::sJavaScriptPage) +
-            additionalLength + strlen(szPluginFinderCommandEnd) + 1);
-      if (pDefURL) {
-        sprintf(pDefURL, "%s%s%s%s", szPluginFinderCommandBeginning,
-            CPlugin::sJavaScriptPage, fType, szPluginFinderCommandEnd);
-      }
-    }
-  }
-  return(pDefURL);
-}
-
-
-
-// Check the mime type of this instance against our list
-// of types weve seen before.  If we find our type in the
-// list, return false; otherwise, return true.
-//
-// type 'STR#' {
-//      integer = $$Countof(StringArray);
-//      array StringArray {
-//              pstring;
-//      };
-void CPlugin::AddMimeTypeToList(StringPtr cTypeString)
-{
-  CFStringRef pluginKey = CFSTR("DefaultPluginSeenTypes"); // don't release this
-  CFStringRef mimeType = ::CFStringCreateWithPascalString(kCFAllocatorDefault, cTypeString, kCFStringEncodingASCII);
-  CFArrayRef prefsList = (CFArrayRef)::CFPreferencesCopyAppValue(pluginKey, kCFPreferencesCurrentApplication);
-  Boolean foundType = false;
-
-  if (!prefsList) {
-    CFStringRef stringArray[1];
-    stringArray[0] = mimeType;
-
-    prefsList = ::CFArrayCreate(kCFAllocatorDefault, (const void **)stringArray, 1, &kCFTypeArrayCallBacks);
-    if (prefsList) {
-      ::CFPreferencesSetAppValue(pluginKey, prefsList, kCFPreferencesCurrentApplication);
-      ::CFRelease(prefsList);
-    }
-  }
-  else {
-    if (::CFGetTypeID(prefsList) == ::CFArrayGetTypeID()) {
-      // first make sure it's not in the list
-      CFIndex count = ::CFArrayGetCount(prefsList);
-      for (CFIndex i = 0; i < count; i ++) {
-        CFStringRef item = (CFStringRef)::CFArrayGetValueAtIndex(prefsList, i); // does not retain
-        if (item && (::CFGetTypeID(item) == ::CFStringGetTypeID()) &&
-            (::CFStringCompareWithOptions(item, mimeType,
-                                          CFRangeMake(0, ::CFStringGetLength(item)), kCFCompareCaseInsensitive) == kCFCompareEqualTo)) {
-          foundType = true;
-          break;
-        }
-      }
-
-      if (!foundType && !fHiddenPlugin) {
-        CFMutableArrayRef typesArray = ::CFArrayCreateMutableCopy(kCFAllocatorDefault, 0, (CFArrayRef)prefsList);
-        if (typesArray) {
-          ::CFArrayAppendValue(typesArray, mimeType);
-          ::CFPreferencesSetAppValue(pluginKey, typesArray, kCFPreferencesCurrentApplication);
-        }
-      }
-    }
-    ::CFRelease(prefsList);
-  }
-  ::CFRelease(mimeType);
-}
-
-
-// Check the mime type of this instance against our list
-// of types weve seen before.  If we find our type in the
-// list, return false; otherwise, return true.
-//
-// type 'STR#' {
-//      integer = $$Countof(StringArray);
-//      array StringArray {
-//              pstring;
-//      };
-Boolean CPlugin::CheckMimeTypes()
-{
-  Boolean failedToFind = true;
-
-  CFStringRef pluginKey = CFSTR("DefaultPluginSeenTypes"); // don't release this
-  CFStringRef mimeType  = ::CFStringCreateWithCString(kCFAllocatorDefault, fType, kCFStringEncodingASCII);
-  CFArrayRef prefsList = (CFArrayRef)::CFPreferencesCopyAppValue(pluginKey, kCFPreferencesCurrentApplication);
-  if (prefsList) {
-    if (::CFGetTypeID(prefsList) == ::CFArrayGetTypeID()) {
-      CFIndex count = ::CFArrayGetCount(prefsList);
-      for (CFIndex i = 0; i < count; i ++) {
-        CFStringRef item = (CFStringRef)::CFArrayGetValueAtIndex(prefsList, i); // does not retain
-        if (item &&
-            (::CFGetTypeID(item) == ::CFStringGetTypeID()) &&
-            (::CFStringCompareWithOptions(item, mimeType,
-                                          CFRangeMake(0, ::CFStringGetLength(item)), kCFCompareCaseInsensitive) == kCFCompareEqualTo)) {
-          failedToFind = false;
-          break;
-        }
-      }
-    }
-    ::CFRelease(prefsList);
-  }
-  ::CFRelease(mimeType);
-  return failedToFind;
-}
-
-
-void CPlugin::AskAndLoadURL()
-{
-  char *pTheURL;
-  SInt32 dwLen;
-  Str255 ourType;
-
-  if (!m_bOffline) {
-    // Convert the mime-type C string to a Pascal string.
-    dwLen = strlen(fType);
-    if (dwLen > 255) {    // don't blow out the Str255
-      dwLen = 255;
-    }
-    BlockMoveData(fType, &ourType[1], dwLen);
-    ourType[0] = dwLen;
-
-    // NOTE: We need to set the cursor because almost always we will have set it to the
-    // hand cursor before we get here.
-    Cursor qdArrow;
-    SetCursor(GetQDGlobalsArrow(&qdArrow));
-
-    // Now that weve queried the user about this mime type,
-    // add it to our list so we wont bug them again.
-    AddMimeTypeToList(ourType);
-    
-    // If the user clicked "Get the Plug-in", either execute the
-    // JavaScript file-installation URL, or ask Netscape to open
-    // a new window with the page URL.  The title of the window
-    // is arbitrary since it has nothing to do with the actual
-    // window title shown to the user (its only used internally).
-    NPN_PushPopupsEnabledState(fInstance, true);
-
-    if (fFileURL) {
-      (void) NPN_GetURL(fInstance, fFileURL, "_current");
-    }
-    else if (fPageURL) {
-      NPN_GetURL(fInstance, fPageURL, "_blank");
-    }
-    else {
-      pTheURL = MakeDefaultURL();
-      if (!m_bJavaScript)
-        NPN_GetURL(fInstance, pTheURL, "_blank");
-      else
-        NPN_GetURL(fInstance, pTheURL, NULL);
-      NPN_MemFree(pTheURL);
-    }
-
-    NPN_PopPopupsEnabledState(fInstance);
-
-    fUserInstalledPlugin = true;
-    if (FocusDraw()) {
-      Draw(kUnhilited);
-      RestoreDraw();
-    }
-  }
-}
-
-
-void CPlugin::RefreshPluginPage()
-{
-  (void)NPN_GetURL(fInstance, "javascript:navigator.plugins.refresh(true);", "_self");
-}
-
-
-void CPlugin::DrawString(const unsigned char* text, short width, short height, short centerX, Rect drawRect)
-{
-  short length, textHeight, textWidth;
-
-  if (!text)
-    return;
-
-  length = strlen((char*)text);
-  TextFont(20);
-  TextFace(underline);
-  TextMode(srcCopy);
-  TextSize(10);
-
-  FontInfo fontInfo;
-  GetFontInfo(&fontInfo);
-
-  textHeight = fontInfo.ascent + fontInfo.descent + fontInfo.leading;
-  textWidth = TextWidth(text, 0, length);
-
-  if (width > textWidth && height > textHeight + 32) {
-    MoveTo(centerX - (textWidth >> 1), drawRect.bottom + textHeight);
-    DrawText(text, 0, length);
-  }    
-}
-
-
-Boolean CPlugin::IsPluginHidden(int16_t argc, char* argn[], char* argv[])
-{
-  for (int i = 0; i < argc; i++) {
-    if (!strcasecmp(argn[i], "HIDDEN")) {
-      if (!strcasecmp(argv[i], "TRUE"))
-        return true;
-    }
-  }
-  return false;
-}
diff -r 17e9560465b0 modules/plugin/default/mac/NullPlugin.rsrc
Binary file modules/plugin/default/mac/NullPlugin.rsrc has changed
diff -r 17e9560465b0 modules/plugin/default/mac/npmac.cpp
--- a/modules/plugin/default/mac/npmac.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,524 +0,0 @@
-//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
-//
-// npmac.cpp
-//
-//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
-
-#include <string.h>
-
-#include <Carbon/Carbon.h>
-
-#include "npapi.h"
-#include "npfunctions.h"
-
-//
-// Define PLUGIN_TRACE to 1 to have the wrapper functions emit
-// DebugStr messages whenever they are called.
-//
-//#define PLUGIN_TRACE 1
-
-#if PLUGIN_TRACE
-#define PLUGINDEBUGSTR(msg)		::DebugStr(msg)
-#else
-#define PLUGINDEBUGSTR(msg)    ((void) 0)
-#endif
-
-
-#ifdef __ppc__
-
-// glue for mapping outgoing Macho function pointers to TVectors
-struct TFPtoTVGlue{
-    void* glue[2];
-};
-
-struct pluginFuncsGlueTable {
-    TFPtoTVGlue     newp;
-    TFPtoTVGlue     destroy;
-    TFPtoTVGlue     setwindow;
-    TFPtoTVGlue     newstream;
-    TFPtoTVGlue     destroystream;
-    TFPtoTVGlue     asfile;
-    TFPtoTVGlue     writeready;
-    TFPtoTVGlue     write;
-    TFPtoTVGlue     print;
-    TFPtoTVGlue     event;
-    TFPtoTVGlue     urlnotify;
-    TFPtoTVGlue     getvalue;
-    TFPtoTVGlue     setvalue;
-
-    TFPtoTVGlue     shutdown;
-} gPluginFuncsGlueTable;
-
-static inline void* SetupFPtoTVGlue(TFPtoTVGlue* functionGlue, void* fp)
-{
-    functionGlue->glue[0] = fp;
-    functionGlue->glue[1] = 0;
-    return functionGlue;
-}
-
-#define PLUGIN_TO_HOST_GLUE(name, fp) (SetupFPtoTVGlue(&gPluginFuncsGlueTable.name, (void*)fp))
-
-// glue for mapping netscape TVectors to Macho function pointers
-struct TTVtoFPGlue {
-    uint32_t glue[6];
-};
-
-struct netscapeFuncsGlueTable {
-    TTVtoFPGlue             geturl;
-    TTVtoFPGlue             posturl;
-    TTVtoFPGlue             requestread;
-    TTVtoFPGlue             newstream;
-    TTVtoFPGlue             write;
-    TTVtoFPGlue             destroystream;
-    TTVtoFPGlue             status;
-    TTVtoFPGlue             uagent;
-    TTVtoFPGlue             memalloc;
-    TTVtoFPGlue             memfree;
-    TTVtoFPGlue             memflush;
-    TTVtoFPGlue             reloadplugins;
-    TTVtoFPGlue             getJavaEnv;
-    TTVtoFPGlue             getJavaPeer;
-    TTVtoFPGlue             geturlnotify;
-    TTVtoFPGlue             posturlnotify;
-    TTVtoFPGlue             getvalue;
-    TTVtoFPGlue             setvalue;
-    TTVtoFPGlue             invalidaterect;
-    TTVtoFPGlue             invalidateregion;
-    TTVtoFPGlue             forceredraw;
-    TTVtoFPGlue             pushpopupsenabledstate;
-    TTVtoFPGlue             poppopupsenabledstate;
-} gNetscapeFuncsGlueTable;
-
-static void* SetupTVtoFPGlue(TTVtoFPGlue* functionGlue, void* tvp)
-{
-    static const TTVtoFPGlue glueTemplate = { 0x3D800000, 0x618C0000, 0x800C0000, 0x804C0004, 0x7C0903A6, 0x4E800420 };
-
-    memcpy(functionGlue, &glueTemplate, sizeof(TTVtoFPGlue));
-    functionGlue->glue[0] |= ((UInt32)tvp >> 16);
-    functionGlue->glue[1] |= ((UInt32)tvp & 0xFFFF);
-    ::MakeDataExecutable(functionGlue, sizeof(TTVtoFPGlue));
-    return functionGlue;
-}
-
-#define HOST_TO_PLUGIN_GLUE(name, fp) (SetupTVtoFPGlue(&gNetscapeFuncsGlueTable.name, (void*)fp))
-
-#else
-
-#define PLUGIN_TO_HOST_GLUE(name, fp) (fp)
-#define HOST_TO_PLUGIN_GLUE(name, fp) (fp)
-
-#endif /* __ppc__ */
-
-
-#pragma mark -
-
-
-//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
-//
-// Globals
-//
-//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
-
-short			gResFile;			// Refnum of the plugins resource file
-NPNetscapeFuncs	gNetscapeFuncs;		// Function table for procs in Netscape called by plugin
-
-//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
-//
-// Wrapper functions for all calls from the plugin to Netscape.
-// These functions let the plugin developer just call the APIs
-// as documented and defined in npapi.h.
-//
-//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
-
-
-void NPN_Version(int* plugin_major, int* plugin_minor, int* netscape_major, int* netscape_minor)
-{
-	*plugin_major = NP_VERSION_MAJOR;
-	*plugin_minor = NP_VERSION_MINOR;
-	*netscape_major = gNetscapeFuncs.version >> 8;		// Major version is in high byte
-	*netscape_minor = gNetscapeFuncs.version & 0xFF;	// Minor version is in low byte
-}
-
-NPError NPN_GetURLNotify(NPP instance, const char* url, const char* window, void* notifyData)
-{
-	int navMinorVers = gNetscapeFuncs.version & 0xFF;
-	NPError err;
-	
-	if( navMinorVers >= NPVERS_HAS_NOTIFICATION )
-	{
-		err = (*gNetscapeFuncs.geturlnotify)(instance, url, window, notifyData);
-	}
-	else
-	{
-		err = NPERR_INCOMPATIBLE_VERSION_ERROR;
-	}
-	return err;
-}
-
-NPError NPN_GetURL(NPP instance, const char* url, const char* window)
-{
-	return (*gNetscapeFuncs.geturl)(instance, url, window);
-}
-
-NPError NPN_PostURLNotify(NPP instance, const char* url, const char* window, uint32_t len, const char* buf, NPBool file, void* notifyData)
-{
-	int navMinorVers = gNetscapeFuncs.version & 0xFF;
-	NPError err;
-	
-	if( navMinorVers >= NPVERS_HAS_NOTIFICATION )
-	{
-		err = (*gNetscapeFuncs.posturlnotify)(instance, url, window, len, buf, file, notifyData);
-	}
-	else
-	{
-		err = NPERR_INCOMPATIBLE_VERSION_ERROR;
-	}
-	return err;
-}
-
-NPError NPN_PostURL(NPP instance, const char* url, const char* window, uint32_t len, const char* buf, NPBool file)
-{
-	return (*gNetscapeFuncs.posturl)(instance, url, window, len, buf, file);
-}
-
-NPError NPN_RequestRead(NPStream* stream, NPByteRange* rangeList)
-{
-	return (*gNetscapeFuncs.requestread)(stream, rangeList);
-}
-
-NPError NPN_NewStream(NPP instance, NPMIMEType type, const char* window, NPStream** stream)
-{
-	int navMinorVers = gNetscapeFuncs.version & 0xFF;
-	NPError err;
-	
-	if( navMinorVers >= NPVERS_HAS_STREAMOUTPUT )
-	{
-		err = (*gNetscapeFuncs.newstream)(instance, type, window, stream);
-	}
-	else
-	{
-		err = NPERR_INCOMPATIBLE_VERSION_ERROR;
-	}
-	return err;
-}
-
-int32_t NPN_Write(NPP instance, NPStream* stream, int32_t len, void* buffer)
-{
-	int navMinorVers = gNetscapeFuncs.version & 0xFF;
-	NPError err;
-	
-	if( navMinorVers >= NPVERS_HAS_STREAMOUTPUT )
-	{
-		err = (*gNetscapeFuncs.write)(instance, stream, len, buffer);
-	}
-	else
-	{
-		err = NPERR_INCOMPATIBLE_VERSION_ERROR;
-	}
-	return err;
-}
-
-NPError	NPN_DestroyStream(NPP instance, NPStream* stream, NPError reason)
-{
-	int navMinorVers = gNetscapeFuncs.version & 0xFF;
-	NPError err;
-	
-	if( navMinorVers >= NPVERS_HAS_STREAMOUTPUT )
-	{
-		err = (*gNetscapeFuncs.destroystream)(instance, stream, reason);
-	}
-	else
-	{
-		err = NPERR_INCOMPATIBLE_VERSION_ERROR;
-	}
-	return err;
-}
-
-void NPN_Status(NPP instance, const char* message)
-{
-	(*gNetscapeFuncs.status)(instance, message);
-}
-
-const char* NPN_UserAgent(NPP instance)
-{
-	return (*gNetscapeFuncs.uagent)(instance);
-}
-
-void* NPN_MemAlloc(uint32_t size)
-{
-	return (*gNetscapeFuncs.memalloc)(size);
-}
-
-void NPN_MemFree(void* ptr)
-{
-	(*gNetscapeFuncs.memfree)(ptr);
-}
-
-uint32_t NPN_MemFlush(uint32_t size)
-{
-	return (*gNetscapeFuncs.memflush)(size);
-}
-
-void NPN_ReloadPlugins(NPBool reloadPages)
-{
-	(*gNetscapeFuncs.reloadplugins)(reloadPages);
-}
-
-NPError NPN_GetValue(NPP instance, NPNVariable variable, void *value)
-{
-	return (*gNetscapeFuncs.getvalue)(instance, variable, value);
-}
-
-NPError NPN_SetValue(NPP instance, NPPVariable variable, void *value)
-{
-	return (*gNetscapeFuncs.setvalue)(instance, variable, value);
-}
-
-void NPN_InvalidateRect(NPP instance, NPRect *rect)
-{
-	(*gNetscapeFuncs.invalidaterect)(instance, rect);
-}
-
-void NPN_InvalidateRegion(NPP instance, NPRegion region)
-{
-	(*gNetscapeFuncs.invalidateregion)(instance, region);
-}
-
-void NPN_ForceRedraw(NPP instance)
-{
-	(*gNetscapeFuncs.forceredraw)(instance);
-}
-
-void NPN_PushPopupsEnabledState(NPP instance, NPBool enabled)
-{
-	(*gNetscapeFuncs.pushpopupsenabledstate)(instance, enabled);
-}
-
-void NPN_PopPopupsEnabledState(NPP instance)
-{
-	(*gNetscapeFuncs.poppopupsenabledstate)(instance);
-}
-
-#pragma mark -
-
-//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
-//
-// Wrapper functions for all calls from Netscape to the plugin.
-// These functions let the plugin developer just create the APIs
-// as documented and defined in npapi.h, without needing to 
-// install those functions in the function table or worry about
-// setting up globals for 68K plugins.
-//
-//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
-
-NPError 	Private_Initialize(void);
-void 		Private_Shutdown(void);
-NPError		Private_New(NPMIMEType pluginType, NPP instance, uint16_t mode, int16_t argc, char* argn[], char* argv[], NPSavedData* saved);
-NPError 	Private_Destroy(NPP instance, NPSavedData** save);
-NPError		Private_SetWindow(NPP instance, NPWindow* window);
-NPError		Private_NewStream(NPP instance, NPMIMEType type, NPStream* stream, NPBool seekable, uint16_t* stype);
-NPError		Private_DestroyStream(NPP instance, NPStream* stream, NPError reason);
-int32_t		Private_WriteReady(NPP instance, NPStream* stream);
-int32_t		Private_Write(NPP instance, NPStream* stream, int32_t offset, int32_t len, void* buffer);
-void		  Private_StreamAsFile(NPP instance, NPStream* stream, const char* fname);
-void	  	Private_Print(NPP instance, NPPrint* platformPrint);
-int16_t 	Private_HandleEvent(NPP instance, void* event);
-void      Private_URLNotify(NPP instance, const char* url, NPReason reason, void* notifyData);
-
-
-NPError Private_Initialize(void)
-{
-	PLUGINDEBUGSTR("\pInitialize;g;");
-	return NPP_Initialize();
-}
-
-void Private_Shutdown(void)
-{
-	PLUGINDEBUGSTR("\pShutdown;g;");
-	NPP_Shutdown();
-}
-
-
-NPError	Private_New(NPMIMEType pluginType, NPP instance, uint16_t mode, int16_t argc, char* argn[], char* argv[], NPSavedData* saved)
-{
-	PLUGINDEBUGSTR("\pNew;g;");
-	return NPP_New(pluginType, instance, mode, argc, argn, argv, saved);
-}
-
-NPError Private_Destroy(NPP instance, NPSavedData** save)
-{
-	PLUGINDEBUGSTR("\pDestroy;g;");
-	return NPP_Destroy(instance, save);
-}
-
-NPError Private_SetWindow(NPP instance, NPWindow* window)
-{
-	PLUGINDEBUGSTR("\pSetWindow;g;");
-	return NPP_SetWindow(instance, window);
-}
-
-NPError Private_NewStream(NPP instance, NPMIMEType type, NPStream* stream, NPBool seekable, uint16_t* stype)
-{
-	PLUGINDEBUGSTR("\pNewStream;g;");
-	return NPP_NewStream(instance, type, stream, seekable, stype);
-}
-
-int32_t Private_WriteReady(NPP instance, NPStream* stream)
-{
-	PLUGINDEBUGSTR("\pWriteReady;g;");
-	return NPP_WriteReady(instance, stream);
-}
-
-int32_t Private_Write(NPP instance, NPStream* stream, int32_t offset, int32_t len, void* buffer)
-{
-	PLUGINDEBUGSTR("\pWrite;g;");
-	return NPP_Write(instance, stream, offset, len, buffer);
-}
-
-void Private_StreamAsFile(NPP instance, NPStream* stream, const char* fname)
-{
-	PLUGINDEBUGSTR("\pStreamAsFile;g;");
-	NPP_StreamAsFile(instance, stream, fname);
-}
-
-
-NPError Private_DestroyStream(NPP instance, NPStream* stream, NPError reason)
-{
-	PLUGINDEBUGSTR("\pDestroyStream;g;");
-	return NPP_DestroyStream(instance, stream, reason);
-}
-
-int16_t Private_HandleEvent(NPP instance, void* event)
-{
-	PLUGINDEBUGSTR("\pHandleEvent;g;");
-	return NPP_HandleEvent(instance, event);
-}
-
-void Private_Print(NPP instance, NPPrint* platformPrint)
-{
-	PLUGINDEBUGSTR("\pPrint;g;");
-	NPP_Print(instance, platformPrint);
-}
-
-void Private_URLNotify(NPP instance, const char* url, NPReason reason, void* notifyData)
-{
-	PLUGINDEBUGSTR("\pURLNotify;g;");
-	NPP_URLNotify(instance, url, reason, notifyData);
-}
-
-void SetUpQD(void);
-void SetUpQD(void)
-{
-	//
-	// Memorize the plugins resource file 
-	// refnum for later use.
-	//
-	gResFile = CurResFile();
-}
-
-
-int main(NPNetscapeFuncs* nsTable, NPPluginFuncs* pluginFuncs, NPP_ShutdownProcPtr* unloadProcPtr);
-
-DEFINE_API_C(int) main(NPNetscapeFuncs* nsTable, NPPluginFuncs* pluginFuncs, NPP_ShutdownProcPtr* unloadProcPtr)
-{
-	PLUGINDEBUGSTR("\pmain");
-
-	NPError err = NPERR_NO_ERROR;
-	
-	//
-	// Ensure that everything Netscape passed us is valid!
-	//
-	if ((nsTable == NULL) || (pluginFuncs == NULL) || (unloadProcPtr == NULL))
-		err = NPERR_INVALID_FUNCTABLE_ERROR;
-	
-	//
-	// Check the major version passed in Netscapes function table.
-	// We wont load if the major version is newer than what we expect.
-	// Also check that the function tables passed in are big enough for
-	// all the functions we need (they could be bigger, if Netscape added
-	// new APIs, but thats OK with us -- well just ignore them).
-	//
-	if (err == NPERR_NO_ERROR)
-	{
-		if ((nsTable->version >> 8) > NP_VERSION_MAJOR)		// Major version is in high byte
-			err = NPERR_INCOMPATIBLE_VERSION_ERROR;
-	}
-		
-	
-	if (err == NPERR_NO_ERROR)
-	{
-		//
-		// Copy all the fields of Netscapes function table into our
-		// copy so we can call back into Netscape later.  Note that
-		// we need to copy the fields one by one, rather than assigning
-		// the whole structure, because the Netscape function table
-		// could actually be bigger than what we expect.
-		//
-		
-		int navMinorVers = nsTable->version & 0xFF;
-
-		gNetscapeFuncs.version          = nsTable->version;
-		gNetscapeFuncs.size             = nsTable->size;
-		gNetscapeFuncs.posturl          = (NPN_PostURLProcPtr)HOST_TO_PLUGIN_GLUE(posturl, nsTable->posturl);
-		gNetscapeFuncs.geturl           = (NPN_GetURLProcPtr)HOST_TO_PLUGIN_GLUE(geturl, nsTable->geturl);
-		gNetscapeFuncs.requestread      = (NPN_RequestReadProcPtr)HOST_TO_PLUGIN_GLUE(requestread, nsTable->requestread);
-		gNetscapeFuncs.newstream        = (NPN_NewStreamProcPtr)HOST_TO_PLUGIN_GLUE(newstream, nsTable->newstream);
-		gNetscapeFuncs.write            = (NPN_WriteProcPtr)HOST_TO_PLUGIN_GLUE(write, nsTable->write);
-		gNetscapeFuncs.destroystream    = (NPN_DestroyStreamProcPtr)HOST_TO_PLUGIN_GLUE(destroystream, nsTable->destroystream);
-		gNetscapeFuncs.status           = (NPN_StatusProcPtr)HOST_TO_PLUGIN_GLUE(status, nsTable->status);
-		gNetscapeFuncs.uagent           = (NPN_UserAgentProcPtr)HOST_TO_PLUGIN_GLUE(uagent, nsTable->uagent);
-		gNetscapeFuncs.memalloc         = (NPN_MemAllocProcPtr)HOST_TO_PLUGIN_GLUE(memalloc, nsTable->memalloc);
-		gNetscapeFuncs.memfree          = (NPN_MemFreeProcPtr)HOST_TO_PLUGIN_GLUE(memfree, nsTable->memfree);
-		gNetscapeFuncs.memflush         = (NPN_MemFlushProcPtr)HOST_TO_PLUGIN_GLUE(memflush, nsTable->memflush);
-		gNetscapeFuncs.reloadplugins    = (NPN_ReloadPluginsProcPtr)HOST_TO_PLUGIN_GLUE(reloadplugins, nsTable->reloadplugins);
-		if( navMinorVers >= NPVERS_HAS_LIVECONNECT )
-		{
-			gNetscapeFuncs.getJavaEnv     = NULL;
-			gNetscapeFuncs.getJavaPeer    = NULL;
-		}
-		if( navMinorVers >= NPVERS_HAS_NOTIFICATION )
-		{	
-			gNetscapeFuncs.geturlnotify 	= (NPN_GetURLNotifyProcPtr)HOST_TO_PLUGIN_GLUE(geturlnotify, nsTable->geturlnotify);
-			gNetscapeFuncs.posturlnotify 	= (NPN_PostURLNotifyProcPtr)HOST_TO_PLUGIN_GLUE(posturlnotify, nsTable->posturlnotify);
-		}
-		gNetscapeFuncs.getvalue         = (NPN_GetValueProcPtr)HOST_TO_PLUGIN_GLUE(getvalue, nsTable->getvalue);
-		gNetscapeFuncs.setvalue         = (NPN_SetValueProcPtr)HOST_TO_PLUGIN_GLUE(setvalue, nsTable->setvalue);
-		gNetscapeFuncs.invalidaterect   = (NPN_InvalidateRectProcPtr)HOST_TO_PLUGIN_GLUE(invalidaterect, nsTable->invalidaterect);
-		gNetscapeFuncs.invalidateregion = (NPN_InvalidateRegionProcPtr)HOST_TO_PLUGIN_GLUE(invalidateregion, nsTable->invalidateregion);
-		gNetscapeFuncs.forceredraw      = (NPN_ForceRedrawProcPtr)HOST_TO_PLUGIN_GLUE(forceredraw, nsTable->forceredraw);
-		gNetscapeFuncs.pushpopupsenabledstate = (NPN_PushPopupsEnabledStateProcPtr)HOST_TO_PLUGIN_GLUE(pushpopupsenabledstate, nsTable->pushpopupsenabledstate);
-		gNetscapeFuncs.poppopupsenabledstate  = (NPN_PopPopupsEnabledStateProcPtr)HOST_TO_PLUGIN_GLUE(poppopupsenabledstate, nsTable->poppopupsenabledstate);
-		
-		//
-		// Set up the plugin function table that Netscape will use to
-		// call us.  Netscape needs to know about our version and size
-		// and have a UniversalProcPointer for every function we implement.
-		//
-		pluginFuncs->version        = (NP_VERSION_MAJOR << 8) + NP_VERSION_MINOR;
-		pluginFuncs->size           = sizeof(NPPluginFuncs);
-		pluginFuncs->newp           = (NPP_NewProcPtr)(PLUGIN_TO_HOST_GLUE(newp, Private_New));
-		pluginFuncs->destroy        = (NPP_DestroyProcPtr)(PLUGIN_TO_HOST_GLUE(destroy, Private_Destroy));
-		pluginFuncs->setwindow      = (NPP_SetWindowProcPtr)(PLUGIN_TO_HOST_GLUE(setwindow, Private_SetWindow));
-		pluginFuncs->newstream      = (NPP_NewStreamProcPtr)(PLUGIN_TO_HOST_GLUE(newstream, Private_NewStream));
-		pluginFuncs->destroystream  = (NPP_DestroyStreamProcPtr)(PLUGIN_TO_HOST_GLUE(destroystream, Private_DestroyStream));
-		pluginFuncs->asfile         = (NPP_StreamAsFileProcPtr)(PLUGIN_TO_HOST_GLUE(asfile, Private_StreamAsFile));
-		pluginFuncs->writeready     = (NPP_WriteReadyProcPtr)(PLUGIN_TO_HOST_GLUE(writeready, Private_WriteReady));
-		pluginFuncs->write          = (NPP_WriteProcPtr)(PLUGIN_TO_HOST_GLUE(write, Private_Write));
-		pluginFuncs->print          = (NPP_PrintProcPtr)(PLUGIN_TO_HOST_GLUE(print, Private_Print));
-		pluginFuncs->event          = (NPP_HandleEventProcPtr)(PLUGIN_TO_HOST_GLUE(event, Private_HandleEvent));	
-		if( navMinorVers >= NPVERS_HAS_NOTIFICATION )
-		{	
-			pluginFuncs->urlnotify = (NPP_URLNotifyProcPtr)(PLUGIN_TO_HOST_GLUE(urlnotify, Private_URLNotify));			
-		}
-		if( navMinorVers >= NPVERS_HAS_LIVECONNECT )
-		{
-			pluginFuncs->javaClass	= NULL;
-		}
-		*unloadProcPtr = (NPP_ShutdownProcPtr)(PLUGIN_TO_HOST_GLUE(shutdown, Private_Shutdown));
-
-		SetUpQD();
-		err = Private_Initialize();
-	}
-	
-	return err;
-}
diff -r 17e9560465b0 modules/plugin/default/mac/npnul.pkg
--- a/modules/plugin/default/mac/npnul.pkg	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,4 +0,0 @@
-# the null plugin goes in gecko-support because we search for plugins
-# in the application, not the GRE
-[gecko-support]
-dist/bin/plugins/Default\ Plugin.plugin
diff -r 17e9560465b0 modules/plugin/default/mac/plugin.png
Binary file modules/plugin/default/mac/plugin.png has changed
diff -r 17e9560465b0 netwerk/cache/src/nsCacheService.cpp
--- a/netwerk/cache/src/nsCacheService.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/netwerk/cache/src/nsCacheService.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -23,6 +23,8 @@
  *
  * Contributor(s):
  *   Gordon Sheridan, 10-February-2001
+ *   Michael Ventnor <m.ventnor@gmail.com>
+ *   Ehsan Akhgari <ehsan.akhgari@gmail.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -66,6 +68,8 @@
 #include "nsProxyRelease.h"
 #include "nsVoidArray.h"
 #include "nsDeleteDir.h"
+#include "nsIPrivateBrowsingService.h"
+#include "nsNetCID.h"
 #include <math.h>  // for log()
 
 
@@ -94,7 +98,8 @@
 static const char * observerList[] = { 
     "profile-before-change",
     "profile-after-change",
-    NS_XPCOM_SHUTDOWN_OBSERVER_ID
+    NS_XPCOM_SHUTDOWN_OBSERVER_ID,
+    NS_PRIVATE_BROWSING_SWITCH_TOPIC
 };
 static const char * prefList[] = { 
 #ifdef NECKO_DISK_CACHE
@@ -125,6 +130,7 @@
         , mOfflineCacheCapacity(0)
         , mMemoryCacheEnabled(PR_TRUE)
         , mMemoryCacheCapacity(-1)
+        , mInPrivateBrowsing(PR_FALSE)
     {
     }
 
@@ -158,6 +164,8 @@
     
     PRBool                  mMemoryCacheEnabled;
     PRInt32                 mMemoryCacheCapacity;
+
+    PRBool                  mInPrivateBrowsing;
 };
 
 NS_IMPL_ISUPPORTS1(nsCacheProfilePrefObserver, nsIObserver)
@@ -179,7 +187,6 @@
             rv2 = rv;
     }
     
-    
     // install preferences observer
     nsCOMPtr<nsIPrefBranch2> branch = do_GetService(NS_PREFSERVICE_CONTRACTID);
     if (!branch) return NS_ERROR_FAILURE;
@@ -189,6 +196,12 @@
         if (NS_FAILED(rv))
             rv2 = rv;
     }
+
+    // determine the initial status of the private browsing mode
+    nsCOMPtr<nsIPrivateBrowsingService> pbs =
+      do_GetService(NS_PRIVATE_BROWSING_SERVICE_CONTRACTID);
+    if (pbs)
+      pbs->GetPrivateBrowsingEnabled(&mInPrivateBrowsing);
 
     // Determine if we have a profile already
     //     Install() is called *after* the profile-after-change notification
@@ -276,10 +289,12 @@
         // which preference changed?
         if (!strcmp(DISK_CACHE_ENABLE_PREF, data.get())) {
 
-            rv = branch->GetBoolPref(DISK_CACHE_ENABLE_PREF,
-                                     &mDiskCacheEnabled);
-            if (NS_FAILED(rv))  return rv;
-            nsCacheService::SetDiskCacheEnabled(DiskCacheEnabled());
+            if (!mInPrivateBrowsing) {
+                rv = branch->GetBoolPref(DISK_CACHE_ENABLE_PREF,
+                                         &mDiskCacheEnabled);
+                if (NS_FAILED(rv))  return rv;
+                nsCacheService::SetDiskCacheEnabled(DiskCacheEnabled());
+            }
 
         } else if (!strcmp(DISK_CACHE_CAPACITY_PREF, data.get())) {
 
@@ -302,10 +317,12 @@
         // which preference changed?
         if (!strcmp(OFFLINE_CACHE_ENABLE_PREF, data.get())) {
 
-            rv = branch->GetBoolPref(OFFLINE_CACHE_ENABLE_PREF,
-                                     &mOfflineCacheEnabled);
-            if (NS_FAILED(rv))  return rv;
-            nsCacheService::SetOfflineCacheEnabled(OfflineCacheEnabled());
+            if (!mInPrivateBrowsing) {
+                rv = branch->GetBoolPref(OFFLINE_CACHE_ENABLE_PREF,
+                                         &mOfflineCacheEnabled);
+                if (NS_FAILED(rv))  return rv;
+                nsCacheService::SetOfflineCacheEnabled(OfflineCacheEnabled());
+            }
 
         } else if (!strcmp(OFFLINE_CACHE_CAPACITY_PREF, data.get())) {
 
@@ -338,6 +355,45 @@
                                       &mMemoryCacheCapacity);
             nsCacheService::SetMemoryCache();
         }
+    } else if (!strcmp(NS_PRIVATE_BROWSING_SWITCH_TOPIC, topic)) {
+        if (!strcmp(NS_PRIVATE_BROWSING_ENTER, data.get())) {
+            mInPrivateBrowsing = PR_TRUE;
+
+            nsCacheService::OnEnterExitPrivateBrowsing();
+
+#ifdef NECKO_DISK_CACHE
+            mDiskCacheEnabled = PR_FALSE;
+            nsCacheService::SetDiskCacheEnabled(DiskCacheEnabled());
+#endif // !NECKO_DISK_CACHE
+
+#ifdef NECKO_OFFLINE_CACHE
+            mOfflineCacheEnabled = PR_FALSE;
+            nsCacheService::SetOfflineCacheEnabled(OfflineCacheEnabled());
+#endif // !NECKO_OFFLINE_CACHE
+        } else if (!strcmp(NS_PRIVATE_BROWSING_LEAVE, data.get())) {
+            mInPrivateBrowsing = PR_FALSE;
+
+            nsCacheService::OnEnterExitPrivateBrowsing();
+
+#if defined(NECKO_DISK_CACHE) || defined(NECKO_OFFLINE_CACHE)
+            nsCOMPtr<nsIPrefBranch> branch = do_GetService(NS_PREFSERVICE_CONTRACTID, &rv);
+            if (NS_FAILED(rv))  return rv;
+#endif // !NECKO_DISK_CACHE && !NECKO_OFFLINE_CACHE
+
+#ifdef NECKO_DISK_CACHE
+            mDiskCacheEnabled = PR_TRUE; // by default enabled
+            (void) branch->GetBoolPref(DISK_CACHE_ENABLE_PREF,
+                                       &mDiskCacheEnabled);
+            nsCacheService::SetDiskCacheEnabled(DiskCacheEnabled());
+#endif // !NECKO_DISK_CACHE
+
+#ifdef NECKO_OFFLINE_CACHE
+            mOfflineCacheEnabled = PR_TRUE; // by default enabled
+            (void) branch->GetBoolPref(OFFLINE_CACHE_ENABLE_PREF,
+                                       &mOfflineCacheEnabled);
+            nsCacheService::SetOfflineCacheEnabled(OfflineCacheEnabled());
+#endif // !NECKO_OFFLINE_CACHE
+        }
     }
     
     return NS_OK;
@@ -351,8 +407,10 @@
 
 #ifdef NECKO_DISK_CACHE
     // read disk cache device prefs
-    mDiskCacheEnabled = PR_TRUE;  // presume disk cache is enabled
-    (void) branch->GetBoolPref(DISK_CACHE_ENABLE_PREF, &mDiskCacheEnabled);
+    if (!mInPrivateBrowsing) {
+        mDiskCacheEnabled = PR_TRUE;  // presume disk cache is enabled
+        (void) branch->GetBoolPref(DISK_CACHE_ENABLE_PREF, &mDiskCacheEnabled);
+    }
 
     mDiskCacheCapacity = DISK_CACHE_CAPACITY;
     (void)branch->GetIntPref(DISK_CACHE_CAPACITY_PREF, &mDiskCacheCapacity);
@@ -405,9 +463,11 @@
 
 #ifdef NECKO_OFFLINE_CACHE
     // read offline cache device prefs
-    mOfflineCacheEnabled = PR_TRUE;  // presume offline cache is enabled
-    (void) branch->GetBoolPref(OFFLINE_CACHE_ENABLE_PREF,
-                               &mOfflineCacheEnabled);
+    if (!mInPrivateBrowsing) {
+        mOfflineCacheEnabled = PR_TRUE;  // presume offline cache is enabled
+        (void) branch->GetBoolPref(OFFLINE_CACHE_ENABLE_PREF,
+                                   &mOfflineCacheEnabled);
+    }
 
     mOfflineCacheCapacity = OFFLINE_CACHE_CAPACITY;
     (void)branch->GetIntPref(OFFLINE_CACHE_CAPACITY_PREF,
@@ -2013,3 +2073,18 @@
                       mDeactivatedUnboundEntries));
 }
 #endif
+
+
+void
+nsCacheService::OnEnterExitPrivateBrowsing()
+{
+    if (!gService)  return;
+    nsCacheServiceAutoLock lock;
+
+    gService->DoomActiveEntries();
+
+    if (gService->mMemoryDevice) {
+        // clear memory cache
+        gService->mMemoryDevice->EvictEntries(nsnull);
+    }
+}
diff -r 17e9560465b0 netwerk/cache/src/nsCacheService.h
--- a/netwerk/cache/src/nsCacheService.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/netwerk/cache/src/nsCacheService.h	Thu Oct 30 05:41:46 2008 -0400
@@ -25,6 +25,7 @@
  *   Gordon Sheridan  <gordon@netscape.com>
  *   Patrick C. Beard <beard@netscape.com>
  *   Darin Fisher     <darin@netscape.com>
+ *   Ehsan Akhgari    <ehsan.akhgari@gmail.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -155,6 +156,8 @@
     static void      SetOfflineCacheCapacity(PRInt32  capacity);
 
     static void      SetMemoryCache();
+
+    static void      OnEnterExitPrivateBrowsing();
 
     nsresult         Init();
     void             Shutdown();
diff -r 17e9560465b0 netwerk/cache/src/nsDiskCacheDeviceSQL.cpp
--- a/netwerk/cache/src/nsDiskCacheDeviceSQL.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/netwerk/cache/src/nsDiskCacheDeviceSQL.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -1104,7 +1104,7 @@
                                                      "  ON ns.ClientID = groups.ActiveClientID"
                                                      " WHERE ns.NameSpace <= ?1 AND ?1 GLOB ns.NameSpace || '*'"
                                                      " ORDER BY ns.NameSpace DESC, groups.ActivateTimeStamp DESC;"),
-    StatementSql ( mStatement_FindNamespaceEntry,    "SELECT ns.ClientID, ns.Data, ns.ItemType FROM "
+    StatementSql ( mStatement_FindNamespaceEntry,    "SELECT ns.NameSpace, ns.Data, ns.ItemType FROM "
                                                      "  moz_cache_namespaces AS ns JOIN moz_cache_groups AS groups"
                                                      "  ON ns.ClientID = groups.ActiveClientID"
                                                      " WHERE ClientID = ?1"
diff -r 17e9560465b0 netwerk/streamconv/converters/nsDirIndexParser.cpp
--- a/netwerk/streamconv/converters/nsDirIndexParser.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/netwerk/streamconv/converters/nsDirIndexParser.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -190,6 +190,10 @@
       ++pos;
     
     ++num;
+    // There are a maximum of six allowed header fields (doubled plus
+    // terminator, just in case) -- Bug 443299
+    if (num > (2 * NS_ARRAY_LENGTH(gFieldTable)))
+      return NS_ERROR_UNEXPECTED;
 
     if (! *pos)
       break;
@@ -200,6 +204,9 @@
   } while (*pos);
 
   mFormat = new int[num+1];
+  // Prevent NULL Deref - Bug 443299 
+  if (mFormat == nsnull)
+    return NS_ERROR_OUT_OF_MEMORY;
   mFormat[num] = -1;
   
   int formatNum=0;
diff -r 17e9560465b0 netwerk/test/unit/test_bug248970_cache.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/netwerk/test/unit/test_bug248970_cache.js	Thu Oct 30 05:41:46 2008 -0400
@@ -0,0 +1,289 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Private Browsing Tests.
+ *
+ * The Initial Developer of the Original Code is
+ * Ehsan Akhgari.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ehsan Akhgari <ehsan.akhgari@gmail.com> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+const Cc = Components.classes;
+const Ci = Components.interfaces;
+const Cr = Components.results;
+
+// names for cache devices
+const kDiskDevice = "disk";
+const kMemoryDevice = "memory";
+const kOfflineDevice = "offline";
+
+// the name for our cache session
+const kPrivateBrowsing = "PrivateBrowsing";
+
+var _PBSvc = null;
+function get_privatebrowsing_service() {
+  if (_PBSvc)
+    return _PBSvc;
+
+  try {
+    _PBSvc = Cc["@mozilla.org/privatebrowsing;1"].
+             getService(Ci.nsIPrivateBrowsingService);
+    if (_PBSvc) {
+      var observer = {
+        QueryInterface: function (iid) {
+          const interfaces = [Ci.nsIObserver,
+                              Ci.nsISupports];
+          if (!interfaces.some(function(v) iid.equals(v)))
+            throw Cr.NS_ERROR_NO_INTERFACE;
+          return this;
+        },
+        observe: function (subject, topic, data) {
+          subject.QueryInterface(Ci.nsISupportsPRUint32);
+          subject.data = 0;
+        }
+      };
+      var os = Cc["@mozilla.org/observer-service;1"].
+               getService(Ci.nsIObserverService);
+      os.addObserver(observer, "private-browsing-enter", false);
+    }
+    return _PBSvc;
+  } catch (e) {}
+  return null;
+}
+
+var _CSvc = null;
+function get_cache_service() {
+  if (_CSvc)
+    return _CSvc;
+
+  return _CSvc = Cc["@mozilla.org/network/cache-service;1"].
+                 getService(Ci.nsICacheService);
+}
+
+function setup_profile_dir() {
+  var dirSvc = Cc["@mozilla.org/file/directory_service;1"].
+               getService(Ci.nsIProperties);
+  var leafRandomName = "Cache" + Math.floor(Math.random() * 10000);
+  var dir = dirSvc.get("TmpD", Ci.nsILocalFile);
+  dir.append(leafRandomName);
+  dir.createUnique(Ci.nsIFile.DIRECTORY_TYPE, 0700);
+  var provider = {
+    getFile: function(prop, persistent) {
+      persistent.value = true;
+      if (prop == "ProfLD" ||
+          prop == "ProfD" ||
+          prop == "cachePDir")
+        return dir;
+      throw Cr.NS_ERROR_FAILURE;
+    },
+    QueryInterface: function(iid) {
+      if (iid.equals(Ci.nsIDirectoryProvider) ||
+          iid.equals(Ci.nsISupports)) {
+        return this;
+      }
+      throw Cr.NS_ERROR_NO_INTERFACE;
+    }
+  };
+  dirSvc.QueryInterface(Ci.nsIDirectoryService).registerProvider(provider);
+}
+
+function check_devices_available(devices) {
+  var cs = get_cache_service();
+  var found_devices = [];
+
+  var visitor = {
+    visitDevice: function (deviceID, deviceInfo) {
+      found_devices.push(deviceID);
+      return false;
+    },
+    visitEntry: function (deviceID, entryInfo) {
+      do_throw("nsICacheVisitor.visitEntry should not be called " +
+        "when checking the availability of devices");
+    }
+  };
+
+  // get the list of active devices
+  cs.visitEntries(visitor);
+
+  // see if any of the required devices was missing
+  if (devices.sort().toString() != found_devices.sort().toString()) {
+    do_throw("Expected to find these devices: \"" + devices.sort().toString() +
+      "\", but found these instead: \"" + found_devices.sort().toString() + "\"");
+  }
+
+  // see if any extra devices have been found
+  if (found_devices.length > devices.length) {
+    do_throw("Expected to find these devices: [" + devices.join(", ") +
+      "], but instead got: [" + found_devices.join(", ") + "]");
+  }
+}
+
+function get_device_entry_count(device) {
+  var cs = get_cache_service();
+  var entry_count = -1;
+
+  var visitor = {
+    visitDevice: function (deviceID, deviceInfo) {
+      if (device == deviceID)
+        entry_count = deviceInfo.entryCount;
+      return false;
+    },
+    visitEntry: function (deviceID, entryInfo) {
+      do_throw("nsICacheVisitor.visitEntry should not be called " +
+        "when checking the availability of devices");
+    }
+  };
+
+  // get the device entry count
+  cs.visitEntries(visitor);
+
+  return entry_count;
+}
+
+function store_in_cache(aKey, aContent, aWhere) {
+  var storageFlag, streaming = true;
+  if (aWhere == kDiskDevice)
+    storageFlag = Ci.nsICache.STORE_ON_DISK;
+  else if (aWhere == kOfflineDevice)
+    storageFlag = Ci.nsICache.STORE_OFFLINE;
+  else if (aWhere == kMemoryDevice)
+    storageFlag = Ci.nsICache.STORE_IN_MEMORY;
+
+  var cache = get_cache_service();
+  var session = cache.createSession(kPrivateBrowsing, storageFlag, streaming);
+  var cacheEntry = session.openCacheEntry(aKey, Ci.nsICache.ACCESS_WRITE, true);
+
+  var oStream = cacheEntry.openOutputStream(0);
+
+  var written = oStream.write(aContent, aContent.length);
+  if (written != aContent.length) {
+    do_throw("oStream.write has not written all data!\n" +
+             "  Expected: " + aContent.length  + "\n" +
+             "  Actual: " + written + "\n");
+  }
+  oStream.close();
+  cacheEntry.close();
+}
+
+function make_input_stream_scriptable(input) {
+  var wrapper = Cc["@mozilla.org/scriptableinputstream;1"].
+                createInstance(Ci.nsIScriptableInputStream);
+  wrapper.init(input);
+  return wrapper;
+}
+
+function retrieve_from_cache(aKey, aWhere) {
+  var storageFlag, streaming = true;
+  if (aWhere == kDiskDevice)
+    storageFlag = Ci.nsICache.STORE_ANYWHERE;
+  else if (aWhere == kOfflineDevice)
+    storageFlag = Ci.nsICache.STORE_OFFLINE;
+  else if (aWhere == kMemoryDevice)
+    storageFlag = Ci.nsICache.STORE_ANYWHERE;
+
+  var cache = get_cache_service();
+  var session = cache.createSession(kPrivateBrowsing, storageFlag, streaming);
+  try {
+    var cacheEntry = session.openCacheEntry(aKey, Ci.nsICache.ACCESS_READ, true);
+  } catch (e) {
+    if (e.result == Cr.NS_ERROR_CACHE_KEY_NOT_FOUND ||
+        e.result == Cr.NS_ERROR_FAILURE)
+      // a key not found error is expected here, so we will simply return null
+      // to let the caller know that no data was retrieved.  We also expect
+      // a generic failure error in case of the offline cache.
+      return null;
+    else
+      do_throw(e); // throw the textual error description
+  }
+
+  var iStream = make_input_stream_scriptable(cacheEntry.openInputStream(0));
+
+  var read = iStream.read(iStream.available());
+  iStream.close();
+  cacheEntry.close();
+
+  return read;
+}
+
+function run_test() {
+  var pb = get_privatebrowsing_service();
+  if (pb) { // Private Browsing might not be available
+    const kCacheA = "cache-A",
+          kCacheB = "cache-B",
+          kCacheC = "cache-C",
+          kTestContent = "test content";
+
+    // Simulate a profile dir for xpcshell
+    setup_profile_dir();
+
+    var cs = get_cache_service();
+
+    // Start off with an empty cache
+    cs.evictEntries(Ci.nsICache.STORE_ANYWHERE);
+
+    // Store cache-A, cache-B and cache-C
+    store_in_cache(kCacheA, kTestContent, kMemoryDevice);
+    store_in_cache(kCacheB, kTestContent, kDiskDevice);
+    store_in_cache(kCacheC, kTestContent, kOfflineDevice);
+
+    // Make sure all three cache devices are available initially
+    check_devices_available([kMemoryDevice, kDiskDevice, kOfflineDevice]);
+
+    // Check if cache-A, cache-B and cache-C are avilable
+    do_check_eq(retrieve_from_cache(kCacheA, kMemoryDevice), kTestContent);
+    do_check_eq(retrieve_from_cache(kCacheB, kDiskDevice), kTestContent);
+    do_check_eq(retrieve_from_cache(kCacheC, kOfflineDevice), kTestContent);
+
+    // Enter private browsing mode
+    pb.privateBrowsingEnabled = true;
+
+    // Make sure none of cache-A, cache-B and cache-C are available
+    do_check_eq(retrieve_from_cache(kCacheA, kMemoryDevice), null);
+    do_check_eq(retrieve_from_cache(kCacheB, kDiskDevice), null);
+    do_check_eq(retrieve_from_cache(kCacheC, kOfflineDevice), null);
+
+    // Make sure only the memory device is available
+    check_devices_available([kMemoryDevice]);
+
+    // Make sure the memory device is empty
+    do_check_eq(get_device_entry_count(kMemoryDevice), 0);
+
+    // Exit private browsing mode
+    pb.privateBrowsingEnabled = false;
+
+    // Make sure all three cache devices are available after leaving the private mode
+    check_devices_available([kMemoryDevice, kDiskDevice, kOfflineDevice]);
+
+    // Check if cache-A is gone, and cache-B and cache-C are still avilable
+    do_check_eq(retrieve_from_cache(kCacheA, kMemoryDevice), null);
+    do_check_eq(retrieve_from_cache(kCacheB, kDiskDevice), kTestContent);
+    do_check_eq(retrieve_from_cache(kCacheC, kOfflineDevice), kTestContent);
+  }
+}
diff -r 17e9560465b0 nsprpub/configure
--- a/nsprpub/configure	Thu Oct 23 09:51:35 2008 -0700
+++ b/nsprpub/configure	Thu Oct 30 05:41:46 2008 -0400
@@ -6016,7 +6016,7 @@
 s%\]%\\&%g
 s%\$%$$%g
 EOF
-DEFS=`sed -f conftest.defs confdefs.h | tr '\012' ' ' | tr '\015' ' '`
+DEFS=`sed -f conftest.defs confdefs.h | tr '\012' ' '`
 rm -f conftest.defs
 
 
diff -r 17e9560465b0 plugin/oji/JEP/JavaEmbeddingPlugin.bundle/Contents/Info.plist
--- a/plugin/oji/JEP/JavaEmbeddingPlugin.bundle/Contents/Info.plist	Thu Oct 23 09:51:35 2008 -0700
+++ b/plugin/oji/JEP/JavaEmbeddingPlugin.bundle/Contents/Info.plist	Thu Oct 30 05:41:46 2008 -0400
@@ -7,7 +7,7 @@
 	<key>CFBundleExecutable</key>
 	<string>JavaEmbeddingPlugin</string>
 	<key>CFBundleGetInfoString</key>
-	<string>Java Embedding Plugin 0.9.6.4 Copyright (c) 2008 Steven Michaud</string>
+	<string>Java Embedding Plugin 0.9.6.5 Copyright (c) 2008 Steven Michaud</string>
 	<key>CFBundleInfoDictionaryVersion</key>
 	<string>6.0</string>
 	<key>CFBundleName</key>
@@ -15,11 +15,11 @@
 	<key>CFBundlePackageType</key>
 	<string>BNDL</string>
 	<key>CFBundleShortVersionString</key>
-	<string>0.9.6.4</string>
+	<string>0.9.6.5</string>
 	<key>CFBundleSignature</key>
 	<string>????</string>
 	<key>CFBundleVersion</key>
-	<string>0.9.6.4</string>
+	<string>0.9.6.5</string>
 	<key>NSJavaNeeded</key>
 	<string>YES</string>
 	<key>NSJavaPath</key>
diff -r 17e9560465b0 plugin/oji/JEP/JavaEmbeddingPlugin.bundle/Contents/MacOS/JavaEmbeddingPlugin
Binary file plugin/oji/JEP/JavaEmbeddingPlugin.bundle/Contents/MacOS/JavaEmbeddingPlugin has changed
diff -r 17e9560465b0 plugin/oji/JEP/JavaEmbeddingPlugin.bundle/Contents/Resources/Java/JavaEmbeddingPlugin.jar
Binary file plugin/oji/JEP/JavaEmbeddingPlugin.bundle/Contents/Resources/Java/JavaEmbeddingPlugin.jar has changed
diff -r 17e9560465b0 plugin/oji/JEP/MRJPlugin.plugin/Contents/Info.plist
--- a/plugin/oji/JEP/MRJPlugin.plugin/Contents/Info.plist	Thu Oct 23 09:51:35 2008 -0700
+++ b/plugin/oji/JEP/MRJPlugin.plugin/Contents/Info.plist	Thu Oct 30 05:41:46 2008 -0400
@@ -7,7 +7,7 @@
 	<key>CFBundleExecutable</key>
 	<string>MRJPlugin</string>
 	<key>CFBundleGetInfoString</key>
-	<string>MRJ Plugin 1.0-JEP-0.9.6.4, Copyright (c) 2002 The Mozilla Organization</string>
+	<string>MRJ Plugin 1.0-JEP-0.9.6.5, Copyright (c) 2002 The Mozilla Organization</string>
 	<key>CFBundleIdentifier</key>
 	<string>com.netscape.MRJPlugin</string>
 	<key>CFBundleInfoDictionaryVersion</key>
@@ -17,11 +17,11 @@
 	<key>CFBundlePackageType</key>
 	<string>NSPL</string>
 	<key>CFBundleShortVersionString</key>
-	<string>1.0-JEP-0.9.6.4</string>
+	<string>1.0-JEP-0.9.6.5</string>
 	<key>CFBundleSignature</key>
 	<string>MOSS</string>
 	<key>CFBundleVersion</key>
-	<string>1.0-JEP-0.9.6.4</string>
+	<string>1.0-JEP-0.9.6.5</string>
 	<key>CSResourcesFileMapped</key>
 	<true/>
 </dict>
diff -r 17e9560465b0 plugin/oji/JEP/MRJPlugin.plugin/Contents/MacOS/MRJPlugin
Binary file plugin/oji/JEP/MRJPlugin.plugin/Contents/MacOS/MRJPlugin has changed
diff -r 17e9560465b0 plugin/oji/JEP/MRJPlugin.plugin/Contents/MacOS/MRJPlugin.jar
Binary file plugin/oji/JEP/MRJPlugin.plugin/Contents/MacOS/MRJPlugin.jar has changed
diff -r 17e9560465b0 plugin/oji/JEP/MRJPlugin.plugin/Contents/Resources/English.lproj/InfoPlist.strings
Binary file plugin/oji/JEP/MRJPlugin.plugin/Contents/Resources/English.lproj/InfoPlist.strings has changed
diff -r 17e9560465b0 plugin/oji/JEP/MRJPlugin.plugin/Contents/Resources/MRJPlugin.rsrc
Binary file plugin/oji/JEP/MRJPlugin.plugin/Contents/Resources/MRJPlugin.rsrc has changed
diff -r 17e9560465b0 security/manager/ssl/public/nsIX509Cert3.idl
--- a/security/manager/ssl/public/nsIX509Cert3.idl	Thu Oct 23 09:51:35 2008 -0700
+++ b/security/manager/ssl/public/nsIX509Cert3.idl	Thu Oct 30 05:41:46 2008 -0400
@@ -20,6 +20,7 @@
  *
  * Contributor(s):
  *   Kai Engert <kengert@redhat.com>
+ *   Jesper Kristensen <mail@jesperkristensen.dk>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -42,7 +43,7 @@
 /**
  * Extending nsIX509Cert
  */
-[scriptable, uuid(aa67eb02-ccc8-4f55-84da-bcafff9265ae)]
+[scriptable, uuid(399004d8-b8c7-4eb9-8362-d99f4c0161fd)]
 interface nsIX509Cert3 : nsIX509Cert2 {
 
   /**
@@ -74,6 +75,19 @@
                    [retval, array, size_is(length)] out octet data);
 
   readonly attribute boolean isSelfSigned;
+
+  /**
+   * Human readable names identifying all hardware or
+   * software tokens the certificate is stored on.
+   *
+   * @param On success, the number of entries in the returned array.
+   * @return On success, an array containing the names of all tokens 
+   *         the certificate is stored on (may be empty).
+   *         On failure the function throws/returns an error.
+   */
+  void getAllTokenNames(out unsigned long length,
+                       [retval, array, size_is(length)] out wstring
+                       tokenNames);
 };
 
 [scriptable, uuid(2fd0a785-9f2d-4327-8871-8c3e0783891d)]
diff -r 17e9560465b0 security/manager/ssl/src/nsNSSCertificate.cpp
--- a/security/manager/ssl/src/nsNSSCertificate.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/security/manager/ssl/src/nsNSSCertificate.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -23,6 +23,7 @@
  *   Ian McGreer <mcgreer@netscape.com>
  *   Javier Delgadillo <javi@netscape.com>
  *   Kai Engert <kengert@redhat.com>
+ *   Jesper Kristensen <mail@jesperkristensen.dk>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -101,6 +102,7 @@
 NSSCleanupAutoPtrClass(NSSCMSMessage, NSS_CMSMessage_Destroy)
 NSSCleanupAutoPtrClass_WithParam(PLArenaPool, PORT_FreeArena, FalseParam, PR_FALSE)
 NSSCleanupAutoPtrClass(NSSCMSSignedData, NSS_CMSSignedData_Destroy)
+NSSCleanupAutoPtrClass(PK11SlotList, PK11_FreeSlotList)
 
 // This is being stored in an PRUint32 that can otherwise
 // only take values from nsIX509Cert's list of cert types.
@@ -890,6 +892,58 @@
   if (nssChain)
     CERT_DestroyCertList(nssChain);
   return rv;
+}
+
+NS_IMETHODIMP
+nsNSSCertificate::GetAllTokenNames(PRUint32 *aLength, PRUnichar*** aTokenNames)
+{
+  nsNSSShutDownPreventionLock locker;
+  if (isAlreadyShutDown())
+    return NS_ERROR_NOT_AVAILABLE;
+
+  NS_ENSURE_ARG(aLength);
+  NS_ENSURE_ARG(aTokenNames);
+  *aLength = 0;
+  *aTokenNames = NULL;
+
+  /* Get the slots from NSS */
+  PK11SlotList *slots = NULL;
+  PK11SlotListCleaner slotCleaner(slots);
+  PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("Getting slots for \"%s\"\n", mCert->nickname));
+  slots = PK11_GetAllSlotsForCert(mCert, NULL);
+  if (!slots) {
+    if (PORT_GetError() == SEC_ERROR_NO_TOKEN)
+      return NS_OK; // List of slots is empty, return empty array
+    else
+      return NS_ERROR_FAILURE;
+  }
+
+  /* read the token names from slots */
+  PK11SlotListElement *le;
+
+  for (le = slots->head; le; le = le->next) {
+    ++(*aLength);
+  }
+
+  *aTokenNames = (PRUnichar **)nsMemory::Alloc(sizeof(PRUnichar *) * (*aLength));
+  if (!*aTokenNames) {
+    *aLength = 0;
+    return NS_ERROR_OUT_OF_MEMORY;
+  }
+
+  PRUint32 iToken;
+  for (le = slots->head, iToken = 0; le; le = le->next, ++iToken) {
+    char *token = PK11_GetTokenName(le->slot);
+    (*aTokenNames)[iToken] = ToNewUnicode(NS_ConvertUTF8toUTF16(token));
+    if (!(*aTokenNames)[iToken]) {
+      NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(iToken, *aTokenNames);
+      *aLength = 0;
+      *aTokenNames = NULL;
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+  }
+
+  return NS_OK;
 }
 
 NS_IMETHODIMP
diff -r 17e9560465b0 storage/public/mozIStoragePendingStatement.idl
--- a/storage/public/mozIStoragePendingStatement.idl	Thu Oct 23 09:51:35 2008 -0700
+++ b/storage/public/mozIStoragePendingStatement.idl	Thu Oct 30 05:41:46 2008 -0400
@@ -39,12 +39,17 @@
 
 #include "nsISupports.idl"
 
-[scriptable, uuid(5c458b3a-8648-45dd-a9a0-c321949cd864)]
+[scriptable, uuid(fc3c5fdc-9a87-4757-b01f-4ace2670a3a0)]
 interface mozIStoragePendingStatement : nsISupports {
 
   /**
-   * Cancels a pending statement.  This may fail because the statement has
-   * already completed.
+   * Cancels a pending statement, if possible.  This will only fail if you try
+   * cancel more than once.
+   *
+   * @note For read statements (such as SELECT), you will no longer receive any
+   *       notifications about results once cancel is called.
+   *
+   * @returns true if canceled successfully, false otherwise.
    */
-   void cancel();
+   boolean cancel();
 };
diff -r 17e9560465b0 storage/public/mozStorageHelper.h
--- a/storage/public/mozStorageHelper.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/storage/public/mozStorageHelper.h	Thu Oct 30 05:41:46 2008 -0400
@@ -69,13 +69,9 @@
       mCommitOnComplete(aCommitOnComplete),
       mCompleted(PR_FALSE)
   {
-    if (mConnection) {
-      PRBool transactionInProgress = PR_FALSE;
-      mConnection->GetTransactionInProgress(&transactionInProgress);
-      mHasTransaction = ! transactionInProgress;
-      if (mHasTransaction)
-        mConnection->BeginTransactionAs(aType);
-    }
+    // We won't try to get a transaction if one is already in progress.
+    if (mConnection)
+      mHasTransaction = NS_SUCCEEDED(mConnection->BeginTransactionAs(aType));
   }
   ~mozStorageTransaction()
   {
diff -r 17e9560465b0 storage/src/Makefile.in
--- a/storage/src/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/storage/src/Makefile.in	Thu Oct 30 05:41:46 2008 -0400
@@ -73,7 +73,6 @@
   mozStorageRow.cpp \
   mozStorageResultSet.cpp \
   mozStorageError.cpp \
-  mozStorageBackground.cpp \
   mozStorageEvents.cpp \
   mozStorageStatementJSHelper.cpp \
   $(NULL)
diff -r 17e9560465b0 storage/src/mozStorageBackground.cpp
--- a/storage/src/mozStorageBackground.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,122 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=2 sts=2 expandtab
- * ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code.
- *
- * The Initial Developer of the Original Code is
- * Mozilla Corporation.
- * Portions created by the Initial Developer are Copyright (C) 2008
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Shawn Wilsher <me@shawnwilsher.com> (Original Author)
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#include "nsIThreadPool.h"
-#include "nsXPCOMCIDInternal.h"
-#include "nsIObserver.h"
-#include "nsIObserverService.h"
-#include "nsServiceManagerUtils.h"
-
-#include "mozStorageCID.h"
-#include "mozStorageBackground.h"
-
-namespace {
-  class ThreadShutdownObserver : public nsIObserver
-  {
-  public:
-    NS_DECL_ISUPPORTS
-
-    ThreadShutdownObserver(nsIThreadPool *aThreadPool) :
-      mThreadPool(aThreadPool)
-    {
-    }
-
-    NS_IMETHOD Observe(nsISupports *, const char *aTopic, const PRUnichar *)
-    {
-      if (!strcmp(aTopic, "xpcom-shutdown-threads")) {
-        (void)mThreadPool->Shutdown();
-        mThreadPool = nsnull;
-      }
-      return NS_OK;
-    }
-  private:
-    ThreadShutdownObserver() { }
-    nsCOMPtr<nsIThreadPool> mThreadPool;
-  };
-  NS_IMPL_ISUPPORTS1(ThreadShutdownObserver, nsIObserver)
-}
-
-////////////////////////////////////////////////////////////////////////////////
-//// Public Methods
-
-mozStorageBackground *mozStorageBackground::mSingleton = nsnull;
-
-mozStorageBackground *
-mozStorageBackground::getService()
-{
-  return mozStorageBackground::mSingleton;
-}
-
-mozStorageBackground::mozStorageBackground()
-{
-  mozStorageBackground::mSingleton = this;
-}
-
-mozStorageBackground::~mozStorageBackground()
-{
-  (void)mThreadPool->Shutdown();
-  mozStorageBackground::mSingleton = nsnull;
-}
-
-nsIEventTarget *
-mozStorageBackground::target()
-{
-  return mThreadPool;
-}
-
-nsresult
-mozStorageBackground::initialize()
-{
-  // Create the thread pool
-  mThreadPool = do_CreateInstance(NS_THREADPOOL_CONTRACTID);
-  NS_ENSURE_TRUE(mThreadPool, NS_ERROR_OUT_OF_MEMORY);
-
-  // Create the observer, and register it with the observer service
-  mObserver = new ThreadShutdownObserver(mThreadPool);
-  NS_ENSURE_TRUE(mObserver, NS_ERROR_OUT_OF_MEMORY);
-
-  nsCOMPtr<nsIObserverService> os =
-    do_GetService("@mozilla.org/observer-service;1");
-  NS_ENSURE_TRUE(os, NS_ERROR_UNEXPECTED);
-
-  nsresult rv = os->AddObserver(mObserver, "xpcom-shutdown-threads", PR_FALSE);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  return NS_OK;
-}
diff -r 17e9560465b0 storage/src/mozStorageBackground.h
--- a/storage/src/mozStorageBackground.h	Thu Oct 23 09:51:35 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,88 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=2 sts=2 expandtab
- * ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code.
- *
- * The Initial Developer of the Original Code is
- * Mozilla Corporation.
- * Portions created by the Initial Developer are Copyright (C) 2008
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Shawn Wilsher <me@shawnwilsher.com> (Original Author)
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#ifndef _mozStorageBackground_h_
-#define _mozStorageBackground_h_
-
-#include "nsClassHashtable.h"
-class mozStorageConnection;
-class nsIThreadPool;
-class nsIEventTarget;
-class nsIObserver;
-
-/**
- * Provides an event target to dispatch background events to for storage.
- *
- * @note This class is threadsafe.
- */
-class mozStorageBackground
-{
-public:
-
-  /**
-   * @returns the background event target that all events to be ran on the
-   *          background should be dispatched to.
-   */
-  nsIEventTarget *target();
-
-  /**
-   * Initializes this object.  Creates the background thread pool.
-   */
-  nsresult initialize();
-
-  /**
-   * Obtains a singleton service of this class.
-   *
-   * @returns a mozStorageBackground object.
-   */
-  static mozStorageBackground *getService();
-
-  mozStorageBackground();
-  ~mozStorageBackground();
-
-private:
-
-  nsCOMPtr<nsIThreadPool> mThreadPool;
-
-  static mozStorageBackground *mSingleton;
-
-  nsCOMPtr<nsIObserver> mObserver;
-};
-
-#endif // _mozStorageBackground_h_
diff -r 17e9560465b0 storage/src/mozStorageConnection.cpp
--- a/storage/src/mozStorageConnection.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/storage/src/mozStorageConnection.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -50,6 +50,7 @@
 #include "nsIVariant.h"
 #include "nsIPrefService.h"
 #include "nsIPrefBranch.h"
+#include "nsThreadUtils.h"
 
 #include "mozIStorageAggregateFunction.h"
 #include "mozIStorageFunction.h"
@@ -75,6 +76,7 @@
 
 mozStorageConnection::mozStorageConnection(mozIStorageService* aService) :
     mDBConn(nsnull)
+,   mAsyncExecutionMutex(nsAutoLock::NewLock("AsyncExecutionMutex"))
 ,   mTransactionMutex(nsAutoLock::NewLock("TransactionMutex"))
 ,   mTransactionInProgress(PR_FALSE)
 ,   mFunctionsMutex(nsAutoLock::NewLock("FunctionsMutex"))
@@ -225,6 +227,16 @@
     PR_LOG(gStorageLog, PR_LOG_NOTICE, ("Opening connection to '%s'",
                                         leafName.get()));
 #endif
+
+    // The shutdown call runs any pending events to completion, so we want to
+    // do this before closing the connection.
+    {
+        nsAutoLock mutex(mAsyncExecutionMutex);
+        if (mAsyncExecutionThread) {
+            mAsyncExecutionThread->Shutdown();
+            mAsyncExecutionThread = nsnull;
+        }
+    }
 
     {
         nsAutoLock mutex(mProgressHandlerMutex);
@@ -919,6 +931,25 @@
 /**
  ** Other bits
  **/
+
+already_AddRefed<nsIEventTarget>
+mozStorageConnection::getAsyncExecutionTarget()
+{
+    nsAutoLock mutex(mAsyncExecutionMutex);
+
+    if (!mAsyncExecutionThread) {
+        nsresult rv = NS_NewThread(getter_AddRefs(mAsyncExecutionThread));
+        if (NS_FAILED(rv)) {
+            NS_WARNING("Failed to create async thread.");
+            return nsnull;
+        }
+    }
+
+    nsIEventTarget *eventTarget;
+    NS_ADDREF(eventTarget = mAsyncExecutionThread);
+    return eventTarget;
+}
+
 void
 mozStorageConnection::HandleSqliteError(const char *aSqlStatement)
 {
diff -r 17e9560465b0 storage/src/mozStorageConnection.h
--- a/storage/src/mozStorageConnection.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/storage/src/mozStorageConnection.h	Thu Oct 30 05:41:46 2008 -0400
@@ -53,6 +53,8 @@
 #include <sqlite3.h>
 
 class nsIFile;
+class nsIEventTarget;
+class nsIThread;
 class mozIStorageService;
 
 class mozStorageConnection : public mozIStorageConnection
@@ -69,6 +71,15 @@
 
     // fetch the native handle
     sqlite3 *GetNativeConnection() { return mDBConn; }
+
+    /**
+     * Lazily creates and returns a background execution thread.  In the future,
+     * the thread may be re-claimed if left idle, so you should call this
+     * method just before you dispatch and not save the reference.
+     * 
+     * @returns an event target suitable for asynchronous statement execution.
+     */
+    already_AddRefed<nsIEventTarget> getAsyncExecutionTarget();
 
 private:
     ~mozStorageConnection();
@@ -93,6 +104,18 @@
     sqlite3 *mDBConn;
     nsCOMPtr<nsIFile> mDatabaseFile;
 
+    /**
+     * Protects access to mAsyncExecutionThread.
+     */
+    PRLock *mAsyncExecutionMutex;
+
+    /**
+     * Lazily created thread for asynchronous statement execution.  Consumers
+     * should use getAsyncExecutionTarget rather than directly accessing this
+     * field.
+     */
+    nsCOMPtr<nsIThread> mAsyncExecutionThread;
+
     PRLock *mTransactionMutex;
     PRBool mTransactionInProgress;
 
diff -r 17e9560465b0 storage/src/mozStorageEvents.cpp
--- a/storage/src/mozStorageEvents.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/storage/src/mozStorageEvents.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -41,6 +41,7 @@
 #include "nsAutoPtr.h"
 #include "nsAutoLock.h"
 #include "nsCOMArray.h"
+#include "prtime.h"
 
 #include "sqlite3.h"
 
@@ -49,9 +50,23 @@
 #include "mozStorageHelper.h"
 #include "mozStorageResultSet.h"
 #include "mozStorageRow.h"
-#include "mozStorageBackground.h"
+#include "mozStorageConnection.h"
 #include "mozStorageError.h"
 #include "mozStorageEvents.h"
+
+/**
+ * The following constants help batch rows into result sets.
+ * MAX_MILLISECONDS_BETWEEN_RESULTS was chosen because any user-based task that
+ * takes less than 200 milliseconds is considered to feel instantaneous to end
+ * users.  MAX_ROWS_PER_RESULT was arbitrarily chosen to reduce the number of
+ * dispatches to calling thread, while also providing reasonably-sized sets of
+ * data for consumers.  Both of these constants are used because we assume that
+ * consumers are trying to avoid blocking their execution thread for long
+ * periods of time, and dispatching many small events to the calling thread will
+ * end up blocking it.
+ */
+#define MAX_MILLISECONDS_BETWEEN_RESULTS 100
+#define MAX_ROWS_PER_RESULT 15
 
 ////////////////////////////////////////////////////////////////////////////////
 //// Asynchronous Statement Execution
@@ -67,76 +82,47 @@
 };
 
 /**
- * Interface used to cancel pending events.
+ * Interface used to check if an event should run.
  */
-class iCancelable : public nsISupports
+class iEventStatus : public nsISupports
 {
 public:
-  /**
-   * Tells an event to cancel itself.
-   */
-  virtual void cancel() = 0;
-};
-
-/**
- * Interface used to notify of event completion.
- */
-class iCompletionNotifier : public nsISupports
-{
-public:
-  /**
-   * Called when an event is completed and no longer needs to be tracked.
-   *
-   * @param aEvent
-   *        The event that has finished.
-   */
-  virtual void completed(iCancelable *aEvent) = 0;
+  virtual PRBool runEvent() = 0;
 };
 
 /**
  * Notifies a callback with a result set.
  */
 class CallbackResultNotifier : public nsIRunnable
-                             , public iCancelable
 {
 public:
   NS_DECL_ISUPPORTS
 
   CallbackResultNotifier(mozIStorageStatementCallback *aCallback,
                          mozIStorageResultSet *aResults,
-                         iCompletionNotifier *aNotifier) :
+                         iEventStatus *aEventStatus) :
       mCallback(aCallback)
     , mResults(aResults)
-    , mCompletionNotifier(aNotifier)
-    , mCanceled(PR_FALSE)
+    , mEventStatus(aEventStatus)
   {
   }
 
   NS_IMETHOD Run()
   {
-    if (!mCanceled)
+    NS_ASSERTION(mCallback, "Trying to notify about results without a callback!");
+
+    if (mEventStatus->runEvent())
       (void)mCallback->HandleResult(mResults);
 
-    // Notify owner AsyncExecute that we have completed
-    mCompletionNotifier->completed(this);
-    // It is likely that the completion notifier holds a reference to us as
-    // well, so we release our reference to it here to avoid cycles.
-    mCompletionNotifier = nsnull;
     return NS_OK;
   }
 
-  virtual void cancel()
-  {
-    // Atomically set our status so we know to not run.
-    PR_AtomicSet(&mCanceled, PR_TRUE);
-  }
 private:
   CallbackResultNotifier() { }
 
   mozIStorageStatementCallback *mCallback;
   nsCOMPtr<mozIStorageResultSet> mResults;
-  nsRefPtr<iCompletionNotifier> mCompletionNotifier;
-  PRInt32 mCanceled;
+  nsRefPtr<iEventStatus> mEventStatus;
 };
 NS_IMPL_THREADSAFE_ISUPPORTS1(
   CallbackResultNotifier,
@@ -147,61 +133,33 @@
  * Notifies the calling thread that an error has occurred.
  */
 class ErrorNotifier : public nsIRunnable
-                    , public iCancelable
 {
 public:
   NS_DECL_ISUPPORTS
 
   ErrorNotifier(mozIStorageStatementCallback *aCallback,
                 mozIStorageError *aErrorObj,
-                iCompletionNotifier *aCompletionNotifier) :
+                iEventStatus *aEventStatus) :
       mCallback(aCallback)
     , mErrorObj(aErrorObj)
-    , mCanceled(PR_FALSE)
-    , mCompletionNotifier(aCompletionNotifier)
+    , mEventStatus(aEventStatus)
   {
   }
 
   NS_IMETHOD Run()
   {
-    if (!mCanceled && mCallback)
+    if (mEventStatus->runEvent() && mCallback)
       (void)mCallback->HandleError(mErrorObj);
 
-    mCompletionNotifier->completed(this);
-    // It is likely that the completion notifier holds a reference to us as
-    // well, so we release our reference to it here to avoid cycles.
-    mCompletionNotifier = nsnull;
     return NS_OK;
   }
 
-  virtual void cancel()
-  {
-    // Atomically set our status so we know to not run.
-    PR_AtomicSet(&mCanceled, PR_TRUE);
-  }
-
-  static inline iCancelable *Dispatch(nsIThread *aCallingThread,
-                                      mozIStorageStatementCallback *aCallback,
-                                      iCompletionNotifier *aCompletionNotifier,
-                                      int aResult,
-                                      const char *aMessage)
-  {
-    nsCOMPtr<mozIStorageError> errorObj(new mozStorageError(aResult, aMessage));
-    if (!errorObj)
-      return nsnull;
-
-    ErrorNotifier *notifier =
-      new ErrorNotifier(aCallback, errorObj, aCompletionNotifier);
-    (void)aCallingThread->Dispatch(notifier, NS_DISPATCH_NORMAL);
-    return notifier;
-  }
 private:
   ErrorNotifier() { }
 
   mozIStorageStatementCallback *mCallback;
   nsCOMPtr<mozIStorageError> mErrorObj;
-  PRInt32 mCanceled;
-  nsRefPtr<iCompletionNotifier> mCompletionNotifier;
+  nsRefPtr<iEventStatus> mEventStatus;
 };
 NS_IMPL_THREADSAFE_ISUPPORTS1(
   ErrorNotifier,
@@ -212,7 +170,6 @@
  * Notifies the calling thread that the statement has finished executing.
  */
 class CompletionNotifier : public nsIRunnable
-                         , public iCancelable
 {
 public:
   NS_DECL_ISUPPORTS
@@ -222,11 +179,9 @@
    * dispatched to (which should always be the calling thread).
    */
   CompletionNotifier(mozIStorageStatementCallback *aCallback,
-                     ExecutionState aReason,
-                     iCompletionNotifier *aCompletionNotifier) :
+                     ExecutionState aReason) :
       mCallback(aCallback)
     , mReason(aReason)
-    , mCompletionNotifier(aCompletionNotifier)
   {
   }
 
@@ -235,10 +190,6 @@
     (void)mCallback->HandleCompletion(mReason);
     NS_RELEASE(mCallback);
 
-    mCompletionNotifier->completed(this);
-    // It is likely that the completion notifier holds a reference to us as
-    // well, so we release our reference to it here to avoid cycles.
-    mCompletionNotifier = nsnull;
     return NS_OK;
   }
 
@@ -253,7 +204,6 @@
 
   mozIStorageStatementCallback *mCallback;
   ExecutionState mReason;
-  nsRefPtr<iCompletionNotifier> mCompletionNotifier;
 };
 NS_IMPL_THREADSAFE_ISUPPORTS1(
   CompletionNotifier,
@@ -265,7 +215,7 @@
  */
 class AsyncExecute : public nsIRunnable
                    , public mozIStoragePendingStatement
-                   , public iCompletionNotifier
+                   , public iEventStatus
 {
 public:
   NS_DECL_ISUPPORTS
@@ -280,9 +230,11 @@
     , mTransactionManager(nsnull)
     , mCallback(aCallback)
     , mCallingThread(do_GetCurrentThread())
+    , mMaxIntervalWait(PR_MicrosecondsToInterval(MAX_MILLISECONDS_BETWEEN_RESULTS))
+    , mIntervalStart(PR_IntervalNow())
     , mState(PENDING)
-    , mStateMutex(nsAutoLock::NewLock("AsyncExecute::mStateMutex"))
-    , mPendingEventsMutex(nsAutoLock::NewLock("AsyncExecute::mPendingEventsMutex"))
+    , mCancelRequested(PR_FALSE)
+    , mLock(nsAutoLock::NewLock("AsyncExecute::mLock"))
   {
     (void)mStatements.SwapElements(aStatements);
     NS_ASSERTION(mStatements.Length(), "We weren't given any statements!");
@@ -290,8 +242,7 @@
 
   nsresult initialize()
   {
-    NS_ENSURE_TRUE(mStateMutex, NS_ERROR_OUT_OF_MEMORY);
-    NS_ENSURE_TRUE(mPendingEventsMutex, NS_ERROR_OUT_OF_MEMORY);
+    NS_ENSURE_TRUE(mLock, NS_ERROR_OUT_OF_MEMORY);
     NS_IF_ADDREF(mCallback);
     return NS_OK;
   }
@@ -300,9 +251,12 @@
   {
     // do not run if we have been canceled
     {
-      nsAutoLock mutex(mStateMutex);
-      if (mState == CANCELED)
-        return Complete();
+      nsAutoLock mutex(mLock);
+      if (mCancelRequested) {
+        mState = CANCELED;
+        mutex.unlock();
+        return NotifyComplete();
+      }
     }
 
     // If there is more than one statement, run it in a transaction.  We assume
@@ -315,178 +269,228 @@
     }
 
     // Execute each statement, giving the callback results if it returns any.
+    for (PRUint32 i = 0; i < mStatements.Length(); i++) {
+      PRBool finished = (i == (mStatements.Length() - 1));
+      if (!ExecuteAndProcessStatement(mStatements[i], finished))
+        break;
+    }
+
+    // If we still have results that we haven't notified about, take care of
+    // them now.
+    if (mResultSet)
+      (void)NotifyResults();
+
+    // Notify about completion
+    return NotifyComplete();
+  }
+
+  NS_IMETHOD Cancel(PRBool *_successful)
+  {
+#ifdef DEBUG
+    PRBool onCallingThread = PR_FALSE;
+    (void)mCallingThread->IsOnCurrentThread(&onCallingThread);
+    NS_ASSERTION(onCallingThread, "Not canceling from the calling thread!");
+#endif
+
+    // If we have already canceled, we have an error, but always indicate that
+    // we are trying to cancel.
+    NS_ENSURE_FALSE(mCancelRequested, NS_ERROR_UNEXPECTED);
+
+    {
+      nsAutoLock mutex(mLock);
+
+      // We need to indicate that we want to try and cancel now.
+      mCancelRequested = PR_TRUE;
+
+      // Establish if we can cancel
+      *_successful = (mState == PENDING);
+    }
+
+    // Note, it is possible for us to return false here, and end up canceling
+    // events that have been dispatched to the calling thread.  This is OK,
+    // however, because only read statements (such as SELECT) are going to be
+    // posting events to the calling thread that actually check if they should
+    // run or not.
+
+    return NS_OK;
+  }
+
+  /**
+   * This is part of iEventStatus.  It indicates if an event should be ran based
+   * on if we are trying to cancel or not.
+   */
+  PRBool runEvent()
+  {
+#ifdef DEBUG
+    PRBool onCallingThread = PR_FALSE;
+    (void)mCallingThread->IsOnCurrentThread(&onCallingThread);
+    NS_ASSERTION(onCallingThread, "runEvent not running on the calling thread!");
+#endif
+
+    // We do not need to acquire mLock here because it can only ever be written
+    // to on the calling thread, and the only thread that can call us is the
+    // calling thread, so we know that our access is serialized.
+    return !mCancelRequested;
+  }
+
+private:
+  AsyncExecute() : mMaxIntervalWait(0) { }
+
+  ~AsyncExecute()
+  {
+    nsAutoLock::DestroyLock(mLock);
+  }
+
+  /**
+   * Executes a given statement until completion, an error occurs, or we are
+   * canceled.  If aFinished is true, we know that we are the last statement,
+   * and should set mState accordingly.
+   *
+   * @pre mLock is not held
+   *
+   * @param aStatement
+   *        The statement to execute and then process.
+   * @param aFinished
+   *        Indicates if this is the last statement or not.  If it is, we have
+   *        to set the proper state.
+   * @returns true if we should continue to process statements, false otherwise.
+   */
+  PRBool ExecuteAndProcessStatement(sqlite3_stmt *aStatement, PRBool aFinished)
+  {
+    // We need to hold a lock for statement execution so we can properly
+    // reflect state in case we are canceled.  We unlock in a few areas in
+    // order to allow for cancelation to occur.
+    nsAutoLock mutex(mLock);
+
     nsresult rv = NS_OK;
-    for (PRUint32 i = 0; i < mStatements.Length(); i++) {
-      while (PR_TRUE) {
-        int rc = sqlite3_step(mStatements[i]);
-        // Break out if we have no more results
-        if (rc == SQLITE_DONE)
-          break;
+    while (PR_TRUE) {
+      int rc = sqlite3_step(aStatement);
+      // Break out if we have no more results
+      if (rc == SQLITE_DONE)
+        break;
 
-        // Some errors are not fatal, and we can handle them and continue.
-        if (rc != SQLITE_OK && rc != SQLITE_ROW) {
-          if (rc == SQLITE_BUSY) {
-            // Yield, and try again
-            PR_Sleep(PR_INTERVAL_NO_WAIT);
-            continue;
-          }
+      // Some errors are not fatal, and we can handle them and continue.
+      if (rc != SQLITE_OK && rc != SQLITE_ROW) {
+        if (rc == SQLITE_BUSY) {
+          // We do not want to hold our lock while we yield.
+          nsAutoUnlock cancelationScope(mLock);
 
-          // Set error state
-          {
-            nsAutoLock mutex(mStateMutex);
-            mState = ERROR;
-          }
-
-          // Notify
-          sqlite3 *db = sqlite3_db_handle(mStatements[i]);
-          iCancelable *cancelable = ErrorNotifier::Dispatch(
-            mCallingThread, mCallback, this, rc, sqlite3_errmsg(db)
-          );
-          if (cancelable) {
-            nsAutoLock mutex(mPendingEventsMutex);
-            (void)mPendingEvents.AppendObject(cancelable);
-          }
-
-          // And complete
-          return Complete();
+          // Yield, and try again
+          PR_Sleep(PR_INTERVAL_NO_WAIT);
+          continue;
         }
 
-        // Check to see if we have been canceled
-        {
-          nsAutoLock mutex(mStateMutex);
-          if (mState == CANCELED)
-            return Complete();
-        }
+        // Set error state
+        mState = ERROR;
 
-        // If we do not have a callback, there's no point in executing this
-        // statement anymore.
-        if (!mCallback)
-          break;
+        // Drop our mutex - NotifyError doesn't want it held
+        mutex.unlock();
 
-        // Build result object
-        // XXX bug 454740 chunk these results better
-        nsRefPtr<mozStorageResultSet> results(new mozStorageResultSet());
-        if (!results) {
-          rv = NS_ERROR_OUT_OF_MEMORY;
-          break;
-        }
+        // Notify
+        sqlite3 *db = sqlite3_db_handle(aStatement);
+        (void)NotifyError(rc, sqlite3_errmsg(db));
 
-        nsRefPtr<mozStorageRow> row(new mozStorageRow());
-        if (!row) {
-          rv = NS_ERROR_OUT_OF_MEMORY;
-          break;
-        }
-
-        rv = row->initialize(mStatements[i]);
-        if (NS_FAILED(rv)) {
-          rv = NS_ERROR_OUT_OF_MEMORY;
-          break;
-        }
-
-        rv = results->add(row);
-        if (NS_FAILED(rv))
-          break;
-
-        // Notify caller
-        nsRefPtr<CallbackResultNotifier> notifier =
-          new CallbackResultNotifier(mCallback, results, this);
-        if (!notifier) {
-          rv = NS_ERROR_OUT_OF_MEMORY;
-          break;
-        }
-
-        nsresult status = mCallingThread->Dispatch(notifier, NS_DISPATCH_NORMAL);
-        if (NS_SUCCEEDED(status)) {
-          nsAutoLock mutex(mPendingEventsMutex);
-          (void)mPendingEvents.AppendObject(notifier);
-        }
+        // And stop processing statements
+        return PR_FALSE;
       }
 
-      // If we have an error, we need to break out now.
+      // If we do not have a callback, there's no point in executing this
+      // statement anymore, but we wish to continue to execute statements.  We
+      // also need to update our state if we are finished, so break out of the
+      // while loop.
+      if (!mCallback)
+        break;
+
+      // If we have been canceled, there is no point in going on...
+      if (mCancelRequested) {
+        mState = CANCELED;
+        return PR_FALSE;
+      }
+
+      // Build our results and notify if it's time.
+      rv = BuildAndNotifyResults(aStatement);
       if (NS_FAILED(rv))
         break;
     }
 
-    // We have broken out of the loop because of an error or because we are
-    // completed.  Handle accordingly.
+    // If we have an error that we have not already notified about, set our
+    // state accordingly, and notify.
     if (NS_FAILED(rv)) {
-      // This is a fatal error :(
+      mState = ERROR;
 
-      // Update state
-      {
-        nsAutoLock mutex(mStateMutex);
-        mState = ERROR;
-      }
+      // Drop our mutex - NotifyError doesn't want it held
+      mutex.unlock();
 
-      // Notify
-      iCancelable *cancelable = ErrorNotifier::Dispatch(
-        mCallingThread, mCallback, this, mozIStorageError::ERROR, ""
-      );
-      if (cancelable) {
-        nsAutoLock mutex(mPendingEventsMutex);
-        (void)mPendingEvents.AppendObject(cancelable);
-      }
+      // Notify, and stop processing statements.
+      (void)NotifyError(mozIStorageError::ERROR, "");
+      return PR_FALSE;
     }
 
-    // No more results, so update state if needed
-    {
-      nsAutoLock mutex(mStateMutex);
-      if (mState == PENDING)
-        mState = COMPLETED;
+    // If we are done, we need to set our state accordingly while we still
+    // hold our lock.  We would have already returned if we were canceled or had
+    // an error at this point.
+    if (aFinished)
+      mState = COMPLETED;
 
-      // Notify about completion
-      return Complete();
-    }
-  }
-
-  static PRBool cancelEnumerator(iCancelable *aCancelable, void *)
-  {
-    (void)aCancelable->cancel();
     return PR_TRUE;
   }
 
-  NS_IMETHOD Cancel()
+  /**
+   * Builds a result set up with a row from a given statement.  If we meet the
+   * right criteria, go ahead and notify about this results too.
+   *
+   * @pre mLock is held
+   *
+   * @param aStatement
+   *        The statement to get the row data from.
+   */
+  nsresult BuildAndNotifyResults(sqlite3_stmt *aStatement)
   {
-    // Check and update our state
-    {
-      nsAutoLock mutex(mStateMutex);
-      NS_ENSURE_TRUE(mState == PENDING || mState == COMPLETED,
-                     NS_ERROR_UNEXPECTED);
-      mState = CANCELED;
-    }
+    NS_ASSERTION(mCallback, "Trying to dispatch results without a callback!");
 
-    // Cancel all our pending events on the calling thread
-    {
-      nsAutoLock mutex(mPendingEventsMutex);
-      (void)mPendingEvents.EnumerateForwards(&AsyncExecute::cancelEnumerator,
-                                             nsnull);
-      mPendingEvents.Clear();
+    // At this point, it is safe to not hold the lock and allow for cancelation.
+    // We may add an event to the calling thread, but that thread will not end
+    // up running when it checks back with us to see if it should run.
+    nsAutoUnlock cancelationScope(mLock);
+
+    // Build result object if we need it.
+    if (!mResultSet)
+      mResultSet = new mozStorageResultSet();
+    NS_ENSURE_TRUE(mResultSet, NS_ERROR_OUT_OF_MEMORY);
+
+    nsRefPtr<mozStorageRow> row(new mozStorageRow());
+    NS_ENSURE_TRUE(row, NS_ERROR_OUT_OF_MEMORY);
+
+    nsresult rv = row->initialize(aStatement);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    rv = mResultSet->add(row);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    // If we have hit our maximum number of allowed results, or if we have hit
+    // the maximum amount of time we want to wait for results, notify the
+    // calling thread about it.
+    PRIntervalTime now = PR_IntervalNow();
+    PRIntervalTime delta = now - mIntervalStart;
+    if (mResultSet->rows() >= MAX_ROWS_PER_RESULT || delta > mMaxIntervalWait) {
+      // Notify the caller
+      rv = NotifyResults();
+      if (NS_FAILED(rv))
+        return NS_OK; // we'll try again with the next result
+
+      // Reset our start time
+      mIntervalStart = now;
     }
 
     return NS_OK;
   }
 
-  virtual void completed(iCancelable *aCancelable)
-  {
-    nsAutoLock mutex(mPendingEventsMutex);
-    (void)mPendingEvents.RemoveObject(aCancelable);
-  }
-
-private:
-  AsyncExecute() { }
-
-  ~AsyncExecute()
-  {
-    NS_ASSERTION(mPendingEvents.Count() == 0, "Still pending events!");
-    nsAutoLock::DestroyLock(mStateMutex);
-    nsAutoLock::DestroyLock(mPendingEventsMutex);
-  }
-
   /**
    * Notifies callback about completion, and does any necessary cleanup.
-   * @note: When calling this function, mStateMutex must be held.
+   *
+   * @pre mLock is not held
    */
-  nsresult Complete()
+  nsresult NotifyComplete()
   {
     NS_ASSERTION(mState != PENDING,
                  "Still in a pending state when calling Complete!");
@@ -496,14 +500,9 @@
       if (mState == COMPLETED) {
         nsresult rv = mTransactionManager->Commit();
         if (NS_FAILED(rv)) {
-          iCancelable *cancelable = ErrorNotifier::Dispatch(
-            mCallingThread, mCallback, this, mozIStorageError::ERROR,
-            "Transaction failed to commit"
-          );
-          if (cancelable) {
-            nsAutoLock mutex(mPendingEventsMutex);
-            (void)mPendingEvents.AppendObject(cancelable);
-          }
+          mState = ERROR;
+          (void)NotifyError(mozIStorageError::ERROR,
+                            "Transaction failed to commit");
         }
       }
       else {
@@ -522,25 +521,80 @@
     // Notify about completion iff we have a callback.
     if (mCallback) {
       nsRefPtr<CompletionNotifier> completionEvent =
-        new CompletionNotifier(mCallback, mState, this);
-      nsresult rv = mCallingThread->Dispatch(completionEvent, NS_DISPATCH_NORMAL);
-      if (NS_SUCCEEDED(rv)) {
-        nsAutoLock mutex(mPendingEventsMutex);
-        (void)mPendingEvents.AppendObject(completionEvent);
-      }
+        new CompletionNotifier(mCallback, mState);
+      NS_ENSURE_TRUE(completionEvent, NS_ERROR_OUT_OF_MEMORY);
 
       // We no longer own mCallback (the CompletionNotifier takes ownership).
       mCallback = nsnull;
+
+      (void)mCallingThread->Dispatch(completionEvent, NS_DISPATCH_NORMAL);
     }
 
     return NS_OK;
   }
+
+  /**
+   * Notifies callback about an error.
+   *
+   * @pre mLock is not held
+   *
+   * @param aErrorCode
+   *        The error code defined in mozIStorageError for the error.
+   * @param aMessage
+   *        The error string, if any.
+   */
+  nsresult NotifyError(PRInt32 aErrorCode, const char *aMessage)
+  {
+    if (!mCallback)
+      return NS_OK;
+
+    nsCOMPtr<mozIStorageError> errorObj =
+      new mozStorageError(aErrorCode, aMessage);
+    NS_ENSURE_TRUE(errorObj, NS_ERROR_OUT_OF_MEMORY);
+
+    nsRefPtr<ErrorNotifier> notifier =
+      new ErrorNotifier(mCallback, errorObj, this);
+    NS_ENSURE_TRUE(notifier, NS_ERROR_OUT_OF_MEMORY);
+
+    return mCallingThread->Dispatch(notifier, NS_DISPATCH_NORMAL);
+  }
+
+  /**
+   * Notifies the callback about a result set.
+   *
+   * @pre mLock is not held
+   */
+  nsresult NotifyResults()
+  {
+    NS_ASSERTION(mCallback, "NotifyResults called without a callback!");
+
+    nsRefPtr<CallbackResultNotifier> notifier =
+      new CallbackResultNotifier(mCallback, mResultSet, this);
+    NS_ENSURE_TRUE(notifier, NS_ERROR_OUT_OF_MEMORY);
+
+    nsresult rv = mCallingThread->Dispatch(notifier, NS_DISPATCH_NORMAL);
+    if (NS_SUCCEEDED(rv))
+      mResultSet = nsnull; // we no longer own it on success
+    return rv;
+  };
 
   nsTArray<sqlite3_stmt *> mStatements;
   mozIStorageConnection *mConnection;
   mozStorageTransaction *mTransactionManager;
   mozIStorageStatementCallback *mCallback;
   nsCOMPtr<nsIThread> mCallingThread;
+  nsRefPtr<mozStorageResultSet> mResultSet;
+
+  /**
+   * The maximum amount of time we want to wait between results.  Defined by
+   * MAX_MILLISECONDS_BETWEEN_RESULTS and set at construction.
+   */
+  const PRIntervalTime mMaxIntervalWait;
+
+  /**
+   * The start time since our last set of results.
+   */
+  PRIntervalTime mIntervalStart;
 
   /**
    * Indicates the state the object is currently in.
@@ -548,20 +602,19 @@
   ExecutionState mState;
 
   /**
-   * Mutex to protect mState.
+   * Indicates if we should try to cancel at a cancelation point or not.
    */
-  PRLock *mStateMutex;
+  PRBool mCancelRequested;
 
   /**
-   * Stores a list of pending events that have not yet completed on the
-   * calling thread.
+   * This is the lock that protects our state from changing.  This includes the
+   * following variables:
+   *   -mState
+   *   -mCancelRequested is only set on the calling thread while the lock is
+   *    held.  It is always read from within the lock on the background thread,
+   *    but not on the calling thread (see runEvent for why).
    */
-  nsCOMArray<iCancelable> mPendingEvents;
-
-  /**
-   * Mutex to protect mPendingEvents.
-   */
-  PRLock *mPendingEventsMutex;
+  PRLock *mLock;
 };
 NS_IMPL_THREADSAFE_ISUPPORTS2(
   AsyncExecute,
@@ -571,7 +624,7 @@
 
 nsresult
 NS_executeAsync(nsTArray<sqlite3_stmt *> &aStatements,
-                mozIStorageConnection *aConnection,
+                mozStorageConnection *aConnection,
                 mozIStorageStatementCallback *aCallback,
                 mozIStoragePendingStatement **_stmt)
 {
@@ -583,7 +636,8 @@
   NS_ENSURE_SUCCESS(rv, rv);
 
   // Dispatch it to the background
-  nsIEventTarget *target = mozStorageBackground::getService()->target();
+  nsCOMPtr<nsIEventTarget> target(aConnection->getAsyncExecutionTarget());
+  NS_ENSURE_TRUE(target, NS_ERROR_NOT_AVAILABLE);
   rv = target->Dispatch(event, NS_DISPATCH_NORMAL);
   NS_ENSURE_SUCCESS(rv, rv);
 
diff -r 17e9560465b0 storage/src/mozStorageEvents.h
--- a/storage/src/mozStorageEvents.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/storage/src/mozStorageEvents.h	Thu Oct 30 05:41:46 2008 -0400
@@ -42,8 +42,8 @@
 
 #include "nscore.h"
 #include "nsTArray.h"
-#include "mozStorageBackground.h"
 struct sqlite3_stmt;
+class mozStorageConnection;
 class mozIStorageStatementCallback;
 class mozIStoragePendingStatement;
 
@@ -62,7 +62,7 @@
  */
 nsresult NS_executeAsync(
   nsTArray<sqlite3_stmt *> &aStatements,
-  mozIStorageConnection *aConnection,
+  mozStorageConnection *aConnection,
   mozIStorageStatementCallback *aCallback,
   mozIStoragePendingStatement **_stmt
 );
diff -r 17e9560465b0 storage/src/mozStorageResultSet.h
--- a/storage/src/mozStorageResultSet.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/storage/src/mozStorageResultSet.h	Thu Oct 30 05:41:46 2008 -0400
@@ -58,6 +58,11 @@
    */
   nsresult add(mozIStorageRow *aTuple);
 
+  /**
+   * @returns the number of rows this result set holds.
+   */
+  PRInt32 rows() const { return mData.Count(); }
+
 private:
   /**
    * Stores the current index of the active result set.
diff -r 17e9560465b0 storage/src/mozStorageService.cpp
--- a/storage/src/mozStorageService.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/storage/src/mozStorageService.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -84,9 +84,6 @@
     mLock = PR_NewLock();
     if (!mLock)
         return NS_ERROR_OUT_OF_MEMORY;
-
-    nsresult rv = mBackground.initialize();
-    NS_ENSURE_SUCCESS(rv, rv);
 
     // This makes multiple connections to the same database share the same pager
     // cache.  We do not need to lock here with mLock because this function is
diff -r 17e9560465b0 storage/src/mozStorageService.h
--- a/storage/src/mozStorageService.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/storage/src/mozStorageService.h	Thu Oct 30 05:41:46 2008 -0400
@@ -49,7 +49,6 @@
 #include "prlock.h"
 
 #include "mozIStorageService.h"
-#include "mozStorageBackground.h"
 
 class mozStorageConnection;
 
@@ -77,11 +76,6 @@
      * can ensure that the state of sqlite3_enable_shared_cache is sane.
      */
     PRLock *mLock;
-
-    /**
-     * The background service needs to stay around just as long as this does.
-     */
-    mozStorageBackground mBackground;
 protected:
     nsCOMPtr<nsIFile> mProfileStorageFile;
 
diff -r 17e9560465b0 storage/test/unit/test_storage_statement_executeAsync.js
--- a/storage/test/unit/test_storage_statement_executeAsync.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/storage/test/unit/test_storage_statement_executeAsync.js	Thu Oct 30 05:41:46 2008 -0400
@@ -372,6 +372,7 @@
     "DELETE FROM test WHERE id = ?"
   );
   stmt.bindInt32Parameter(0, 0);
+  let reason = Ci.mozIStorageStatementCallback.REASON_CANCELED;
   var pendingStatement = stmt.executeAsync({
     handleResult: function(aResultSet)
     {
@@ -386,14 +387,17 @@
     handleCompletion: function(aReason)
     {
       dump("handleCompletion("+aReason+");\n");
-      do_check_eq(Ci.mozIStorageStatementCallback.REASON_CANCELED, aReason);
+      do_check_eq(reason, aReason);
       do_test_finished();
     }
   });
   do_test_pending();
 
   // Cancel immediately
-  pendingStatement.cancel();
+  if (!pendingStatement.cancel()) {
+    // It is possible that we finished before we canceled
+    reason = Ci.mozIStorageStatementCallback.REASON_FINISHED;
+  }
 
   stmt.finalize();
 }
@@ -406,6 +410,7 @@
     "DELETE FROM test WHERE id = ?"
   );
   stmt.bindInt32Parameter(0, 0);
+  let reason = Ci.mozIStorageStatementCallback.REASON_CANCELED;
   var pendingStatement = stmt.executeAsync({
     handleResult: function(aResultSet)
     {
@@ -420,14 +425,17 @@
     handleCompletion: function(aReason)
     {
       dump("handleCompletion("+aReason+");\n");
-      do_check_eq(Ci.mozIStorageStatementCallback.REASON_CANCELED, aReason);
+      do_check_eq(reason, aReason);
       do_test_finished();
     }
   });
   do_test_pending();
 
   // Cancel immediately
-  pendingStatement.cancel();
+  if (!pendingStatement.cancel()) {
+    // It is possible that we finished before we canceled
+    reason = Ci.mozIStorageStatementCallback.REASON_FINISHED;
+  }
 
   // And cancel again - expect an exception
   try {
diff -r 17e9560465b0 testing/mochitest/browser-harness.xul
--- a/testing/mochitest/browser-harness.xul	Thu Oct 23 09:51:35 2008 -0700
+++ b/testing/mochitest/browser-harness.xul	Thu Oct 30 05:41:46 2008 -0400
@@ -44,6 +44,38 @@
         title="Browser chrome tests">
   <script src="chrome://mochikit/content/tests/SimpleTest/MozillaFileLogger.js"/>
   <script src="chrome://mochikit/content/tests/SimpleTest/quit.js"/>
+  <style xmlns="http://www.w3.org/1999/xhtml"><![CDATA[
+    #results {
+      margin: 5px;
+      background-color: window;
+      -moz-user-select: text;
+    }
+
+    #summary {
+      border: 2px solid black;
+    }
+
+    #summary.success {
+      background-color: green;
+    }
+
+    #summary.failure {
+      background-color: red;
+    }
+
+    .failed {
+      color: red;
+      font-weight: bold;
+    }
+
+    .testHeader {
+      margin-top: 1em;
+    }
+
+    p {
+      margin: 0.1em;
+    }
+  ]]></style>
   <script type="application/javascript;version=1.7"><![CDATA[
     var gConfig;
     function TestStart() {
@@ -127,6 +159,15 @@
         return this.tests.map(function (t) {
                                   return t.result + " | " + path + " | " + t.msg;
                               }).join("\n");
+      },
+      get htmlLog() {
+        var path = this.path;
+        return this.tests.map(function (t) {
+                                  var result = "<p class=\"result ";
+                                  result += t.pass ? "passed" : "failed";
+                                  result += "\">" + t.result + " | " + path + " | " + t.msg + "</p>";
+                                  return result;
+                              }).join("\n");
       }
     };
 
@@ -178,6 +219,24 @@
       Tester.start();
     }
 
+    function getHTMLLogFromTests(aTests) {
+      var log = "";
+
+      function sum(a, b){ return a + b; }
+      var passCount = aTests.map(function (f) f.passCount).reduce(sum);
+      var failCount = aTests.map(function (f) f.failCount).reduce(sum);
+      var todoCount = aTests.map(function (f) f.todoCount).reduce(sum);
+      log += "<div id=\"summary\" class=\"";
+      log += failCount == 0 ? "success" : "failure";
+      log += "\">\n<p>Passed: " + passCount + "</p>\n" +
+             "<p>Failed: " + failCount + "</p>\n" +
+             "<p>Todo: " + todoCount + "</p>\n</div>\n<div id=\"log\">\n";
+
+      return log + aTests.map(function (f) {
+                                return "<p class=\"testHeader\">" + f.path + "</p>\n" + f.htmlLog;
+                              }).join("\n") + "</div>";
+    }
+
     function getLogFromTests(aTests) {
       if (!aTests.length)
         return "TEST-PASS | | No tests to run";
@@ -222,11 +281,13 @@
       }
 
       // UI
-      document.getElementById("results").value = output;
+      document.getElementById("results").innerHTML = getHTMLLogFromTests(aTests);
       setStatus("Done.");
     }
   ]]></script>
   <button id="runTestsButton" onclick="runAllTests();" label="Run All Tests"/>
   <label id="status"/>
-  <textbox flex="1" multiline="true" id="results"/>
+  <scrollbox flex="1" style="overflow: auto" align="stretch">
+    <div id="results" xmlns="http://www.w3.org/1999/xhtml"/>
+  </scrollbox>
 </window>
diff -r 17e9560465b0 testing/mochitest/browser-test.js
--- a/testing/mochitest/browser-test.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/testing/mochitest/browser-test.js	Thu Oct 30 05:41:46 2008 -0400
@@ -136,6 +136,16 @@
     self.todo(a != b, name, "Didn't expect " + a + ", but got it");
   };
 
+  this.executeSoon = function test_executeSoon(func) {
+    let tm = Cc["@mozilla.org/thread-manager;1"].getService(Ci.nsIThreadManager);
+
+    tm.mainThread.dispatch({
+      run: function() {
+        func();
+      }
+    }, Ci.nsIThread.DISPATCH_NORMAL);
+  };
+
   this.waitForExplicitFinish = function test_WFEF() {
     self.done = false;
   };
diff -r 17e9560465b0 testing/mochitest/tests/SimpleTest/SimpleTest.js
--- a/testing/mochitest/tests/SimpleTest/SimpleTest.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/testing/mochitest/tests/SimpleTest/SimpleTest.js	Thu Oct 30 05:41:46 2008 -0400
@@ -200,6 +200,21 @@
 SimpleTest.waitForExplicitFinish = function () {
     SimpleTest._stopOnLoad = false;
 };
+
+/**
+ * Executes a function shortly after the call, but lets the caller continue
+ * working (or finish).
+ */
+SimpleTest.executeSoon = function(aFunc) {
+    var tm = Components.classes["@mozilla.org/thread-manager;1"]
+                       .getService(Components.interfaces.nsIThreadManager);
+
+    tm.mainThread.dispatch({
+        run: function() {
+            aFunc();
+        }
+    }, Components.interfaces.nsIThread.DISPATCH_NORMAL);
+}
 
 /**
  * Talks to the TestRunner if being ran on a iframe and the parent has a
diff -r 17e9560465b0 toolkit/components/downloads/src/nsDownloadManager.cpp
--- a/toolkit/components/downloads/src/nsDownloadManager.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/components/downloads/src/nsDownloadManager.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -101,12 +101,15 @@
 #define PREF_BDM_SCANWHENDONE "browser.download.manager.scanWhenDone"
 #define PREF_BDM_RESUMEONWAKEDELAY "browser.download.manager.resumeOnWakeDelay"
 #define PREF_BH_DELETETEMPFILEONEXIT "browser.helperApps.deleteTempFileOnExit"
+#define PREF_BDM_ALERTONEXEOPEN "browser.download.manager.alertOnEXEOpen"
 
 static const PRInt64 gUpdateInterval = 400 * PR_USEC_PER_MSEC;
 
 #define DM_SCHEMA_VERSION      8
 #define DM_DB_NAME             NS_LITERAL_STRING("downloads.sqlite")
 #define DM_DB_CORRUPT_FILENAME NS_LITERAL_STRING("downloads.sqlite.corrupt")
+
+#define NS_SYSTEMINFO_CONTRACTID "@mozilla.org/system-info;1"
 
 ////////////////////////////////////////////////////////////////////////////////
 //// nsDownloadManager
@@ -1267,7 +1270,6 @@
   NS_ENSURE_SUCCESS(rv, rv);
 
   // Check the os version
-  #define NS_SYSTEMINFO_CONTRACTID "@mozilla.org/system-info;1"
   nsCOMPtr<nsIPropertyBag2> infoService =
      do_GetService(NS_SYSTEMINFO_CONTRACTID, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
@@ -1474,17 +1476,6 @@
   }
 
   DownloadState startState = nsIDownloadManager::DOWNLOAD_QUEUED;
-#ifdef DOWNLOAD_SCANNER
-  if (mScanner) {
-    AVCheckPolicyState res = mScanner->CheckPolicy(aSource, aTarget);
-    if (res == AVPOLICY_BLOCKED) {
-      // This download will get deleted during a call to IAE's Save,
-      // so go ahead and mark it as blocked and avoid the download.
-      (void)dl->Cancel();
-      startState = nsIDownloadManager::DOWNLOAD_BLOCKED_POLICY;
-    }
-  }
-#endif
 
   PRInt64 id = AddDownloadToDB(dl->mDisplayName, source, target, tempPath,
                                dl->mStartTime, dl->mLastUpdate,
@@ -1496,6 +1487,18 @@
   rv = AddToCurrentDownloads(dl);
   (void)dl->SetState(startState);
   NS_ENSURE_SUCCESS(rv, rv);
+
+#ifdef DOWNLOAD_SCANNER
+  if (mScanner) {
+    AVCheckPolicyState res = mScanner->CheckPolicy(aSource, aTarget);
+    if (res == AVPOLICY_BLOCKED) {
+      // This download will get deleted during a call to IAE's Save,
+      // so go ahead and mark it as blocked and avoid the download.
+      (void)CancelDownload(id);
+      startState = nsIDownloadManager::DOWNLOAD_BLOCKED_POLICY;
+    }
+  }
+#endif
 
   // Check with parental controls to see if file downloads
   // are allowed for this user. If not allowed, cancel the
@@ -2205,23 +2208,24 @@
         }
       }
 #if defined(XP_WIN) && !defined(WINCE)
-      // Default is to add the download to the system's "recent documents"
-      // list, with a pref to disable.
-      PRBool addToRecentDocs = PR_TRUE;
-      if (pref)
-        pref->GetBoolPref(PREF_BDM_ADDTORECENTDOCS, &addToRecentDocs);
+      nsCOMPtr<nsIFileURL> fileURL = do_QueryInterface(mTarget);
+      nsCOMPtr<nsIFile> file;
+      nsAutoString path;
+      
+      if (fileURL &&
+          NS_SUCCEEDED(fileURL->GetFile(getter_AddRefs(file))) &&
+          file &&
+          NS_SUCCEEDED(file->GetPath(path))) {
 
-      if (addToRecentDocs) {
-        LPSHELLFOLDER lpShellFolder = NULL;
+        // On windows, add the download to the system's "recent documents"
+        // list, with a pref to disable.
+        {
+          PRBool addToRecentDocs = PR_TRUE;
+          if (pref)
+            pref->GetBoolPref(PREF_BDM_ADDTORECENTDOCS, &addToRecentDocs);
 
-        if (SUCCEEDED(::SHGetDesktopFolder(&lpShellFolder))) {
-          nsCOMPtr<nsIFileURL> fileURL = do_QueryInterface(mTarget);
-          nsCOMPtr<nsIFile> file;
-          nsAutoString path;
-          if (fileURL &&
-              NS_SUCCEEDED(fileURL->GetFile(getter_AddRefs(file))) &&
-              file &&
-              NS_SUCCEEDED(file->GetPath(path))) {
+          LPSHELLFOLDER lpShellFolder = NULL;
+          if (addToRecentDocs && SUCCEEDED(::SHGetDesktopFolder(&lpShellFolder))) {
             PRUnichar *filePath = ToNewUnicode(path);
             LPITEMIDLIST lpItemIDList = NULL;
             if (SUCCEEDED(lpShellFolder->ParseDisplayName(NULL, NULL, filePath,
@@ -2231,8 +2235,41 @@
               ::CoTaskMemFree(lpItemIDList);
             }
             nsMemory::Free(filePath);
+            lpShellFolder->Release();
           }
-          lpShellFolder->Release();
+        }
+
+        // On Vista and up, we rely on native security prompting when users
+        // open executable content. If the option is set, add meta data to the
+        // 'Zone.Identifier' resource fork of the file which indicates this
+        // content came from the internet.
+        {
+          nsCOMPtr<nsIPrefBranch> pref =
+            do_GetService(NS_PREFSERVICE_CONTRACTID);
+          PRBool alert = PR_TRUE;
+          if (pref)
+            (void)pref->GetBoolPref(PREF_BDM_ALERTONEXEOPEN, &alert);
+          nsAutoString forkPath = path;
+          forkPath.AppendLiteral(":Zone.Identifier");
+
+          if (alert) {
+            HANDLE hFile = CreateFileW(forkPath.get(), GENERIC_WRITE,
+                                       FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
+                                       NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
+            if (hFile != INVALID_HANDLE_VALUE) {
+              nsAutoString metaData;
+              metaData.AppendLiteral("[ZoneTransfer]\nZoneId=3");
+              DWORD writeLen = 0;
+              (void)WriteFile(hFile, metaData.get(), metaData.Length()*2, &writeLen,
+                              NULL);
+              CloseHandle(hFile);
+            }
+          }
+          else {
+            // Virus scanning will often add the resource fork to the file, but since
+            // the user doesn't want to be prompted, delete it.
+            DeleteFileW(forkPath.get());
+          }
         }
       }
 #endif
diff -r 17e9560465b0 toolkit/components/downloads/src/nsDownloadScanner.cpp
--- a/toolkit/components/downloads/src/nsDownloadScanner.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/components/downloads/src/nsDownloadScanner.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -135,7 +135,6 @@
  *  * Get antivirus scanner status via WMI/registry
  */
 
-#define PREF_BDA_DONTCLEAN "browser.download.antivirus.dontclean"
 #define PREF_BDM_SKIPWINPOLICYCHECKS "browser.download.manager.skipWinSecurityPolicyChecks"
 
 // IAttachementExecute supports user definable settings for certain
@@ -173,7 +172,7 @@
   HANDLE mQuitEvent;
 };
 
-NS_IMPL_ISUPPORTS1(
+NS_IMPL_ISUPPORTS1(
   nsDownloadScanner
   , nsIObserver
   )
@@ -456,14 +455,6 @@
 
   nsresult rv = NS_OK;
 
-  // Default is to try to clean downloads
-  mIsReadOnlyRequest = PR_FALSE;
-
-  nsCOMPtr<nsIPrefBranch> pref =
-    do_GetService(NS_PREFSERVICE_CONTRACTID);
-  if (pref)
-    rv = pref->GetBoolPref(PREF_BDA_DONTCLEAN, &mIsReadOnlyRequest);
-
   // Get the path to the file on disk
   nsCOMPtr<nsILocalFile> file;
   rv = mDownload->GetTargetFile(getter_AddRefs(file));
@@ -636,7 +627,7 @@
   info.cbsize = sizeof(MSOAVINFO);
   info.fPath = TRUE;
   info.fInstalled = FALSE;
-  info.fReadOnlyRequest = mIsReadOnlyRequest;
+  info.fReadOnlyRequest = FALSE;
   info.fHttpDownload = mIsHttpDownload;
   info.hwnd = NULL;
 
diff -r 17e9560465b0 toolkit/components/downloads/src/nsDownloadScanner.h
--- a/toolkit/components/downloads/src/nsDownloadScanner.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/components/downloads/src/nsDownloadScanner.h	Thu Oct 30 05:41:46 2008 -0400
@@ -103,7 +103,6 @@
     // Also true if it is an ftp download
     PRBool mIsHttpDownload;
     PRBool mSkipSource;
-    PRBool mIsReadOnlyRequest;
 
     /* @summary Sets the Scan's state to newState if the current state is
                 expectedState
diff -r 17e9560465b0 toolkit/components/exthelper/extApplication.js
--- a/toolkit/components/exthelper/extApplication.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/components/exthelper/extApplication.js	Thu Oct 30 05:41:46 2008 -0400
@@ -616,7 +616,6 @@
   // for nsIObserver
   observe: function app_observe(aSubject, aTopic, aData) {
     if (aTopic == "app-startup") {
-      this._extensions = new Extensions();
       this.events.dispatch("load", "application");
     }
     else if (aTopic == "final-ui-startup") {
@@ -675,6 +674,9 @@
   },
 
   get extensions() {
+    if (this._extensions == null)
+      this._extensions = new Extensions();
+
     return this._extensions;
   },
 
diff -r 17e9560465b0 toolkit/components/help/content/help.xul
--- a/toolkit/components/help/content/help.xul	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/components/help/content/help.xul	Thu Oct 30 05:41:46 2008 -0400
@@ -182,9 +182,8 @@
         <toolbarspring flex="1"/>
         <toolbaritem id="search-box"
                      align="center" pack="center">
-          <label value="&searchtab.label;" accesskey="&searchtab.accesskey;" 
-                 control="findText"/>
-          <textbox id="findText" type="search" oncommand="doFind();"/>
+          <textbox id="findText" type="search" emptytext="&search.emptytext;"
+                   oncommand="doFind();"/>
         </toolbaritem>
       </toolbar>
     </toolbox>
@@ -234,10 +233,8 @@
         </vbox>
         <vbox id="help-search-sidebar" hidden="true" flex="1">
           <sidebarheader align="center">
-            <label id="help-search-sidebar-header" flex="1" crop="end" value="&searchtab.label;"/>
-            <toolbarbutton id="search-sidebar-closebutton"
-                           tooltiptext="&searchClose.tooltip;"
-                           oncommand="hideSearchSidebar();"/>
+            <label id="help-search-sidebar-header" flex="1" crop="end"
+                   value="&searchHeader.label;"/>
           </sidebarheader>
           <tree id="help-search-tree" class="focusring"
                 flex="1" hidecolumnpicker="true"
diff -r 17e9560465b0 toolkit/components/passwordmgr/src/storage-Legacy.js
--- a/toolkit/components/passwordmgr/src/storage-Legacy.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/components/passwordmgr/src/storage-Legacy.js	Thu Oct 30 05:41:46 2008 -0400
@@ -784,6 +784,9 @@
         // encrypted username field (which contains an encrypted empty value)
         // (Don't do this if it's a form login, though.)
         if (username && !isFormLogin) {
+            if (isMailNews.test(aLogin.hostname))
+                username = decodeURIComponent(username);
+
             var [encUsername, userCanceled] = this._encrypt(username);
             if (!userCanceled)
                 aLogin.wrappedJSObject.encryptedUsername = encUsername;
diff -r 17e9560465b0 toolkit/components/passwordmgr/test/test_privbrowsing.html
--- a/toolkit/components/passwordmgr/test/test_privbrowsing.html	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/components/passwordmgr/test/test_privbrowsing.html	Thu Oct 30 05:41:46 2008 -0400
@@ -20,6 +20,11 @@
 /** Test for Bug 248970 **/
 // based on test_notifications.html
 
+netscape.security.PrivilegeManager.enablePrivilege('UniversalXPConnect');
+const Ci = Components.interfaces;
+const Cc = Components.classes;
+const Cr = Components.results;
+
 var testpath = document.location.pathname + "/../";
 var prefix = "http://test2.example.com" + testpath;
 var subtests = [
@@ -34,34 +39,6 @@
                    "subtst_privbrowsing_4.html", // 9
                    "subtst_privbrowsing_3.html" // 10
                ];
-
-
-var ignoreLoad = false;
-function handleLoad(aEvent) {
-  netscape.security.PrivilegeManager.enablePrivilege('UniversalXPConnect');
-
-  // ignore every other load event ... We get one for loading the subtest (which
-  // we want to ignore), and another when the subtest's form submits itself
-  // (which we want to handle, to start the next test).
-  ignoreLoad = !ignoreLoad;
-  if (ignoreLoad) {
-    ok(true, "Ignoring load of subtest #" + testNum);
-    return;
-  }
-  ok(true, "Processing submission of subtest #" + testNum);
-
-  checkTest();
-
-  // Remove any notification bar that might be lingering from a failed test.
-  notifyBox.removeAllNotifications(true);
-
-  if (testNum <= subtests.length) {
-    loadNextTest();
-  } else {
-    ok(true, "private browsing notification tests finished.");
-    SimpleTest.finish();
-  }
-}
 
 
 var testNum = 0;
@@ -212,6 +189,34 @@
 }
 
 
+// This observer prevents a prompt from showing up asking if the current
+// session should be kept or closed upon entering the private browsing mode.
+// It instructs the private browsing service to keep the current session open.
+var observer = {
+  QueryInterface: function (iid) {
+    const interfaces = [Ci.nsIObserver,
+                        Ci.nsISupports];
+    if (!interfaces.some(function(v) iid.equals(v)))
+      throw Cr.NS_ERROR_NO_INTERFACE;
+    return this;
+  },
+  observe: function (subject, topic, data) {
+    netscape.security.PrivilegeManager.enablePrivilege('UniversalXPConnect');
+    subject.QueryInterface(Ci.nsISupportsPRUint32);
+    subject.data = 0;
+  },
+  register: function () {
+    var os = Cc["@mozilla.org/observer-service;1"].
+             getService(Ci.nsIObserverService);
+    os.addObserver(this, "private-browsing-enter", false);
+  },
+  unregister: function () {
+    var os = Cc["@mozilla.org/observer-service;1"].
+             getService(Ci.nsIObserverService);
+    os.removeObserver(this, "private-browsing-enter");
+  }
+};
+
 var _PBSvc = null;
 function get_PBSvc() {
   if (_PBSvc)
@@ -219,26 +224,10 @@
 
   netscape.security.PrivilegeManager.enablePrivilege('UniversalXPConnect');
   try {
-    _PBSvc = Components.classes["@mozilla.org/privatebrowsing;1"].
-             getService(Components.interfaces.nsIPrivateBrowsingService);
+    _PBSvc = Cc["@mozilla.org/privatebrowsing;1"].
+             getService(Ci.nsIPrivateBrowsingService);
     if (_PBSvc) {
-      var observer = {
-        QueryInterface: function (iid) {
-          const interfaces = [Components.interfaces.nsIObserver,
-                              Components.interfaces.nsISupports];
-          if (!interfaces.some(function(v) iid.equals(v)))
-            throw Components.results.NS_ERROR_NO_INTERFACE;
-          return this;
-        },
-        observe: function (subject, topic, data) {
-          netscape.security.PrivilegeManager.enablePrivilege('UniversalXPConnect');
-          subject.QueryInterface(Components.interfaces.nsISupportsPRUint32);
-          subject.data = 0;
-        }
-      };
-      var os = Components.classes["@mozilla.org/observer-service;1"].
-               getService(Components.interfaces.nsIObserverService);
-      os.addObserver(observer, "private-browsing-enter", false);
+      observer.register();
     }
     return _PBSvc;
   } catch (e) {}
@@ -268,7 +257,8 @@
   if (testNum < subtests.length) {
     loadNextTest();
   } else {
-    ok(true, "notification tests finished.");
+    ok(true, "private browsing notification tests finished.");
+    observer.unregister();
     SimpleTest.finish();
   }
 }
@@ -281,8 +271,6 @@
 } else {
   netscape.security.PrivilegeManager.enablePrivilege('UniversalXPConnect');
 
-  const Ci = Components.interfaces;
-  const Cc = Components.classes;
   ok(Ci != null, "Access Ci");
   ok(Cc != null, "Access Cc");
 
diff -r 17e9560465b0 toolkit/components/passwordmgr/test/unit/data/signons-403790.txt
--- a/toolkit/components/passwordmgr/test/unit/data/signons-403790.txt	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/components/passwordmgr/test/unit/data/signons-403790.txt	Thu Oct 30 05:41:46 2008 -0400
@@ -12,3 +12,9 @@
 *\=password=\
 ~dGVzdHBhc3My
 .
+mailbox://test%2Bpop3@localhost
+\=username=\
+~
+*\=password=\
+~cG9wM3Rlc3Q=
+.
diff -r 17e9560465b0 toolkit/components/passwordmgr/test/unit/test_storage_legacy_4.js
--- a/toolkit/components/passwordmgr/test/unit/test_storage_legacy_4.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/components/passwordmgr/test/unit/test_storage_legacy_4.js	Thu Oct 30 05:41:46 2008 -0400
@@ -93,6 +93,8 @@
                  createInstance(Ci.nsILoginInfo);
 var dummyuser3 = Cc["@mozilla.org/login-manager/loginInfo;1"].
                  createInstance(Ci.nsILoginInfo);
+var dummyuser4 = Cc["@mozilla.org/login-manager/loginInfo;1"].
+                 createInstance(Ci.nsILoginInfo);
 
 
 dummyuser1.init("mailbox://localhost", null, "mailbox://localhost",
@@ -102,7 +104,10 @@
     "ldap://localhost1/dc=test",
     "", "testpass2", "", "");
 
-dummyuser3.init("http://dummyhost.mozilla.org", "", null,
+dummyuser3.init("mailbox://localhost", null, "mailbox://localhost",
+    "test+pop3", "pop3test", "", "");
+
+dummyuser4.init("http://dummyhost.mozilla.org", "", null,
     "testuser1", "testpass1", "put_user_here", "put_pw_here");
 
 /*
@@ -116,14 +121,16 @@
 testdesc = "checking reading of mailnews-like old logins";
 storage = LoginTest.initStorage(INDIR, "signons-403790.txt",
                                OUTDIR, "output-403790.txt");
-LoginTest.checkStorageData(storage, [], [dummyuser1, dummyuser2]);
+LoginTest.checkStorageData(storage, [], [dummyuser1, dummyuser2, dummyuser3]);
 
-storage.addLogin(dummyuser3); // trigger a write
-LoginTest.checkStorageData(storage, [], [dummyuser1, dummyuser2, dummyuser3]);
+storage.addLogin(dummyuser4); // trigger a write
+LoginTest.checkStorageData(storage, [],
+                           [dummyuser1, dummyuser2, dummyuser3, dummyuser4]);
 
 testdesc = "[flush and reload for verification]";
 storage = LoginTest.reloadStorage(OUTDIR, "output-403790.txt");
-LoginTest.checkStorageData(storage, [], [dummyuser1, dummyuser2, dummyuser3]);
+LoginTest.checkStorageData(storage, [],
+                           [dummyuser1, dummyuser2, dummyuser3, dummyuser4]);
 
 /* ========== end ========== */
 } catch (e) {
diff -r 17e9560465b0 toolkit/components/passwordmgr/test/unit/test_storage_mozStorage_4.js
--- a/toolkit/components/passwordmgr/test/unit/test_storage_mozStorage_4.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/components/passwordmgr/test/unit/test_storage_mozStorage_4.js	Thu Oct 30 05:41:46 2008 -0400
@@ -87,6 +87,8 @@
                  createInstance(Ci.nsILoginInfo);
 var dummyuser3 = Cc["@mozilla.org/login-manager/loginInfo;1"].
                  createInstance(Ci.nsILoginInfo);
+var dummyuser4 = Cc["@mozilla.org/login-manager/loginInfo;1"].
+                 createInstance(Ci.nsILoginInfo);
 
 
 dummyuser1.init("mailbox://localhost", null, "mailbox://localhost",
@@ -96,7 +98,10 @@
     "ldap://localhost1/dc=test",
     "", "testpass2", "", "");
 
-dummyuser3.init("http://dummyhost.mozilla.org", "", null,
+dummyuser3.init("mailbox://localhost", null, "mailbox://localhost",
+    "test+pop3", "pop3test", "", "");
+
+dummyuser4.init("http://dummyhost.mozilla.org", "", null,
     "testuser1", "testpass1", "put_user_here", "put_pw_here");
 
 LoginTest.deleteFile(OUTDIR, "signons.sqlite");
@@ -112,14 +117,16 @@
 testdesc = "checking reading of mailnews-like old logins";
 storage = LoginTest.initStorage(INDIR, "signons-403790.txt",
                       OUTDIR, "output-403790.sqlite");
-LoginTest.checkStorageData(storage, [], [dummyuser1, dummyuser2]);
+ LoginTest.checkStorageData(storage, [], [dummyuser1, dummyuser2, dummyuser3]);
 
-storage.addLogin(dummyuser3); // trigger a write
-LoginTest.checkStorageData(storage, [], [dummyuser1, dummyuser2, dummyuser3]);
+storage.addLogin(dummyuser4); // trigger a write
+LoginTest.checkStorageData(storage, [],
+                           [dummyuser1, dummyuser2, dummyuser3, dummyuser4]);
 
 testdesc = "[flush and reload for verification]";
 storage = LoginTest.reloadStorage(OUTDIR, "output-403790.sqlite");
-LoginTest.checkStorageData(storage, [], [dummyuser1, dummyuser2, dummyuser3]);
+LoginTest.checkStorageData(storage, [],
+                           [dummyuser1, dummyuser2, dummyuser3, dummyuser4]);
 
 LoginTest.deleteFile(OUTDIR, "output-403790.sqlite");
 
diff -r 17e9560465b0 toolkit/components/places/src/Makefile.in
--- a/toolkit/components/places/src/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/components/places/src/Makefile.in	Thu Oct 30 05:41:46 2008 -0400
@@ -105,6 +105,7 @@
 
 EXTRA_PP_COMPONENTS = nsLivemarkService.js \
                       nsTaggingService.js \
+                      nsPlacesDBFlush.js \
                       $(NULL)
 
 EXTRA_JS_MODULES = \
diff -r 17e9560465b0 toolkit/components/places/src/PlacesBackground.jsm
--- a/toolkit/components/places/src/PlacesBackground.jsm	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/components/places/src/PlacesBackground.jsm	Thu Oct 30 05:41:46 2008 -0400
@@ -49,6 +49,7 @@
 const Cr = Components.results;
 
 const kQuitApplication = "quit-application";
+const kPlacesBackgroundShutdown = "places-background-shutdown";
 
 ////////////////////////////////////////////////////////////////////////////////
 //// nsPlacesBackgound class
@@ -84,6 +85,12 @@
   observe: function PlacesBackground_observe(aSubject, aTopic, aData)
   {
     if (aTopic == kQuitApplication) {
+      // Notify consumers that we are shutting down.
+      let os = Cc["@mozilla.org/observer-service;1"].
+               getService(Ci.nsIObserverService);
+      os.notifyObservers(null, kPlacesBackgroundShutdown, null);
+
+      // Now shut the thread down.
       this._thread.shutdown();
       this._thread = null;
     }
diff -r 17e9560465b0 toolkit/components/places/src/nsAnnotationService.cpp
--- a/toolkit/components/places/src/nsAnnotationService.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/components/places/src/nsAnnotationService.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -110,7 +110,8 @@
   // mDBSetAnnotation
   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
       "UPDATE moz_annos "
-      "SET mime_type = ?4, content = ?5, flags = ?6, expiration = ?7, type = ?8, lastModified = ?10 "
+      "SET mime_type = ?4, content = ?5, flags = ?6, expiration = ?7, "
+        "type = ?8, lastModified = ?10 "
       "WHERE id = ?1"),
     getter_AddRefs(mDBSetAnnotation));
   NS_ENSURE_SUCCESS(rv, rv);
@@ -118,7 +119,8 @@
   // mDBSetItemAnnotation
   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
       "UPDATE moz_items_annos "
-      "SET mime_type = ?4, content = ?5, flags = ?6, expiration = ?7, type = ?8, lastModified = ?10 "
+      "SET mime_type = ?4, content = ?5, flags = ?6, expiration = ?7, "
+        "type = ?8, lastModified = ?10 "
       "WHERE id = ?1"),
     getter_AddRefs(mDBSetItemAnnotation));
   NS_ENSURE_SUCCESS(rv, rv);
@@ -128,7 +130,7 @@
       "SELECT * "
       "FROM moz_annos "
       "WHERE place_id = ?1 AND anno_attribute_id = "
-      "(SELECT id FROM moz_anno_attributes WHERE name = ?2)"),
+        "(SELECT id FROM moz_anno_attributes WHERE name = ?2)"),
     getter_AddRefs(mDBGetAnnotation));
   NS_ENSURE_SUCCESS(rv, rv);
 
@@ -137,14 +139,15 @@
       "SELECT * "
       "FROM moz_items_annos "
       "WHERE item_id = ?1 AND anno_attribute_id = "
-      "(SELECT id FROM moz_anno_attributes WHERE name = ?2)"),
+        "(SELECT id FROM moz_anno_attributes WHERE name = ?2)"),
     getter_AddRefs(mDBGetItemAnnotation));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // mDBGetAnnotationNames
   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
       "SELECT n.name "
-      "FROM moz_annos a LEFT JOIN moz_anno_attributes n ON a.anno_attribute_id = n.id "
+      "FROM moz_annos a "
+      "JOIN moz_anno_attributes n ON a.anno_attribute_id = n.id "
       "WHERE a.place_id = ?1"),
     getter_AddRefs(mDBGetAnnotationNames));
   NS_ENSURE_SUCCESS(rv, rv);
@@ -152,18 +155,29 @@
   // mDBGetItemAnnotationNames
   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
       "SELECT n.name "
-      "FROM moz_items_annos a LEFT JOIN moz_anno_attributes n ON a.anno_attribute_id = n.id "
+      "FROM moz_items_annos a "
+      "JOIN moz_anno_attributes n ON a.anno_attribute_id = n.id "
       "WHERE a.item_id = ?1"),
     getter_AddRefs(mDBGetItemAnnotationNames));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // mDBGetAnnotationFromURI
+  // We are not checking for duplicated ids into the unified table
+  // for perf reasons, LIMIT 1 will discard duplicates faster since we
+  // can only have one anno with a certain name for every place_id.
   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
       "SELECT a.id, a.place_id, ?2, a.mime_type, a.content, a.flags, "
         "a.expiration, a.type "
-      "FROM moz_places h JOIN moz_annos a ON h.id = a.place_id "
-      "WHERE h.url = ?1 AND a.anno_attribute_id = "
-      "(SELECT id FROM moz_anno_attributes WHERE name = ?2)"),
+      "FROM ( "
+        "SELECT id FROM moz_places_temp "
+        "WHERE url = ?1 "
+        "UNION ALL "
+        "SELECT id FROM moz_places "
+        "WHERE url = ?1 "
+      ") AS h JOIN moz_annos a ON h.id = a.place_id "
+      "WHERE a.anno_attribute_id = "
+        "(SELECT id FROM moz_anno_attributes WHERE name = ?2) "
+      "LIMIT 1"),
     getter_AddRefs(mDBGetAnnotationFromURI));
   NS_ENSURE_SUCCESS(rv, rv);
 
@@ -173,7 +187,7 @@
         "a.expiration, a.type "
       "FROM moz_items_annos a "
       "WHERE a.item_id = ?1 AND a.anno_attribute_id = "
-      "(SELECT id FROM moz_anno_attributes WHERE name = ?2)"),
+        "(SELECT id FROM moz_anno_attributes WHERE name = ?2)"),
     getter_AddRefs(mDBGetAnnotationFromItemId));
   NS_ENSURE_SUCCESS(rv, rv);
 
@@ -193,7 +207,8 @@
   //   Note: kAnnoIndex_Name here is a name ID and not a string like the getters
   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
       "INSERT INTO moz_annos "
-      "(place_id, anno_attribute_id, mime_type, content, flags, expiration, type, dateAdded) "
+        "(place_id, anno_attribute_id, mime_type, content, flags, expiration, "
+         "type, dateAdded) "
       "VALUES (?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)"),
     getter_AddRefs(mDBAddAnnotation));
   NS_ENSURE_SUCCESS(rv, rv);
@@ -202,7 +217,8 @@
   //   Note: kAnnoIndex_Name here is a name ID and not a string like the getters
   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
       "INSERT INTO moz_items_annos "
-      "(item_id, anno_attribute_id, mime_type, content, flags, expiration, type, dateAdded) "
+        "(item_id, anno_attribute_id, mime_type, content, flags, expiration, "
+         "type, dateAdded) "
       "VALUES (?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)"),
     getter_AddRefs(mDBAddItemAnnotation));
   NS_ENSURE_SUCCESS(rv, rv);
@@ -210,21 +226,21 @@
   // mDBRemoveAnnotation
   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
       "DELETE FROM moz_annos WHERE place_id = ?1 AND anno_attribute_id = "
-      "(SELECT id FROM moz_anno_attributes WHERE name = ?2)"),
+        "(SELECT id FROM moz_anno_attributes WHERE name = ?2)"),
     getter_AddRefs(mDBRemoveAnnotation));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // mDBRemoveItemAnnotation
   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
       "DELETE FROM moz_items_annos WHERE item_id = ?1 AND anno_attribute_id = "
-      "(SELECT id FROM moz_anno_attributes WHERE name = ?2)"),
+        "(SELECT id FROM moz_anno_attributes WHERE name = ?2)"),
     getter_AddRefs(mDBRemoveItemAnnotation));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // mDBGetItemsWithAnnotation
   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
     "SELECT a.item_id FROM moz_anno_attributes n "
-    "INNER JOIN moz_items_annos a ON n.id = a.anno_attribute_id "
+    "JOIN moz_items_annos a ON n.id = a.anno_attribute_id "
     "WHERE n.name = ?1"),
     getter_AddRefs(mDBGetItemsWithAnnotation));
   NS_ENSURE_SUCCESS(rv, rv);
@@ -254,7 +270,8 @@
     NS_ENSURE_SUCCESS(rv, rv);
 
     rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
-        "CREATE UNIQUE INDEX moz_annos_placeattributeindex ON moz_annos (place_id, anno_attribute_id)"));
+        "CREATE UNIQUE INDEX moz_annos_placeattributeindex "
+        "ON moz_annos (place_id, anno_attribute_id)"));
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
@@ -271,7 +288,8 @@
     rv = aDBConn->ExecuteSimpleSQL(CREATE_MOZ_ITEMS_ANNOS);
     NS_ENSURE_SUCCESS(rv, rv);
     rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
-        "CREATE UNIQUE INDEX moz_items_annos_itemattributeindex ON moz_items_annos (item_id, anno_attribute_id)"));
+        "CREATE UNIQUE INDEX moz_items_annos_itemattributeindex "
+          "ON moz_items_annos (item_id, anno_attribute_id)"));
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
@@ -1226,10 +1244,18 @@
   // statement. Perhaps this should change.
   nsCOMPtr<mozIStorageStatement> statement;
   nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
-    "SELECT h.url FROM moz_anno_attributes n "
-    "INNER JOIN moz_annos a ON n.id = a.anno_attribute_id "
-    "INNER JOIN moz_places h ON a.place_id = h.id "
-    "WHERE n.name = ?1"),
+      "SELECT h.url "
+      "FROM moz_places_temp h "
+      "JOIN moz_annos a ON h.id = a.place_id "
+      "JOIN moz_anno_attributes n ON n.id = a.anno_attribute_id "
+      "WHERE n.name = ?1 "
+      "UNION ALL "
+      "SELECT h.url "
+      "FROM moz_places h "
+      "JOIN moz_annos a ON h.id = a.place_id "
+      "JOIN moz_anno_attributes n ON n.id = a.anno_attribute_id "
+      "WHERE n.name = ?1 "
+        "AND h.id NOT IN (SELECT id FROM moz_places_temp)"),
     getter_AddRefs(statement));
   NS_ENSURE_SUCCESS(rv, rv);
 
@@ -1647,10 +1673,12 @@
   // source with the same values of the annotation on dest.
   nsCOMPtr<mozIStorageStatement> statement;
   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
-      "INSERT INTO moz_annos (place_id, anno_attribute_id, mime_type, content, flags, expiration) "
+      "INSERT INTO moz_annos "
+      "(place_id, anno_attribute_id, mime_type, content, flags, expiration) "
       "SELECT ?1, anno_attribute_id, mime_type, content, flags, expiration "
-      "FROM moz_annos WHERE place_id = ?2 AND anno_attribute_id = "
-      "(SELECT id FROM moz_anno_attributes WHERE name = ?3)"),
+      "FROM moz_annos "
+      "WHERE place_id = ?2 AND anno_attribute_id = "
+        "(SELECT id FROM moz_anno_attributes WHERE name = ?3)"),
     getter_AddRefs(statement));
   NS_ENSURE_SUCCESS(rv, rv);
 
diff -r 17e9560465b0 toolkit/components/places/src/nsFaviconService.cpp
--- a/toolkit/components/places/src/nsFaviconService.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/components/places/src/nsFaviconService.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -154,10 +154,19 @@
     getter_AddRefs(mDBGetIconInfo));
   NS_ENSURE_SUCCESS(rv, rv);
 
+  // We can avoid checking for duplicates in the unified table since an uri
+  // can only have one favicon associated. LIMIT 1 will ensure that we get
+  // only one result.
   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
       "SELECT f.id, f.url, length(f.data), f.expiration "
-      "FROM moz_places h JOIN moz_favicons f ON h.favicon_id = f.id "
-      "WHERE h.url = ?1"),
+      "FROM ( "
+        "SELECT * FROM moz_places_temp "
+        "WHERE url = ?1 "
+        "UNION ALL "
+        "SELECT * FROM moz_places "
+        "WHERE url = ?1 "
+      ") AS h JOIN moz_favicons f ON h.favicon_id = f.id "
+      "LIMIT 1"),
     getter_AddRefs(mDBGetURL));
   NS_ENSURE_SUCCESS(rv, rv);
 
@@ -179,7 +188,7 @@
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
-      "UPDATE moz_places SET favicon_id = ?2 WHERE id = ?1"),
+      "UPDATE moz_places_view SET favicon_id = ?2 WHERE id = ?1"),
     getter_AddRefs(mDBSetPageFavicon));
   NS_ENSURE_SUCCESS(rv, rv);
 
@@ -1102,6 +1111,7 @@
   PRTime expiration = PR_Now() +
                       (PRInt64)(24 * 60 * 60) * (PRInt64)PR_USEC_PER_SEC;
 
+  mozStorageTransaction transaction(mFaviconService->mDBConn, PR_FALSE);
   // save the favicon data
   // This could fail if the favicon is bigger than defined limit, in such a
   // case data will not be saved to the db but we will still continue.
@@ -1115,8 +1125,12 @@
                                                      &hasData, &expiration);
   NS_ENSURE_SUCCESS(rv, rv);
 
+  mFaviconService->UpdateBookmarkRedirectFavicon(mPageURI, mFaviconURI);
+
+  rv = transaction.Commit();
+  NS_ENSURE_SUCCESS(rv, rv);
+
   mFaviconService->SendFaviconNotifications(mPageURI, mFaviconURI);
-  mFaviconService->UpdateBookmarkRedirectFavicon(mPageURI, mFaviconURI);
   return NS_OK;
 }
 
diff -r 17e9560465b0 toolkit/components/places/src/nsNavBookmarks.cpp
--- a/toolkit/components/places/src/nsNavBookmarks.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/components/places/src/nsNavBookmarks.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -106,189 +106,15 @@
 nsNavBookmarks::Init()
 {
   nsNavHistory *history = History();
-  NS_ENSURE_TRUE(history, NS_ERROR_UNEXPECTED);
-  mozIStorageConnection *dbConn = DBConn();
-  mozStorageTransaction transaction(dbConn, PR_FALSE);
-  nsresult rv;
+  NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
+  mDBConn = history->GetStorageConnection();
+  mozStorageTransaction transaction(mDBConn, PR_FALSE);
 
-  {
-    nsCOMPtr<mozIStorageStatement> statement;
-    rv = dbConn->CreateStatement(NS_LITERAL_CSTRING("SELECT id FROM moz_bookmarks WHERE type = ?1 AND parent IS NULL"),
-                                 getter_AddRefs(statement));
-    NS_ENSURE_SUCCESS(rv, rv);
-    rv = statement->BindInt32Parameter(0, TYPE_FOLDER);
-    NS_ENSURE_SUCCESS(rv, rv);
-
-    PRBool results;
-    rv = statement->ExecuteStep(&results);
-    NS_ENSURE_SUCCESS(rv, rv);
-    if (results) {
-      mRoot = statement->AsInt64(0);
-    }
-  }
-
-  nsCAutoString buffer;
-
-  nsCOMPtr<nsIStringBundleService> bundleService =
-    do_GetService(NS_STRINGBUNDLE_CONTRACTID, &rv);
-  NS_ENSURE_SUCCESS(rv, rv);
-  rv = bundleService->CreateBundle(
-      "chrome://places/locale/places.properties",
-      getter_AddRefs(mBundle));
+  nsresult rv = InitStatements();
   NS_ENSURE_SUCCESS(rv, rv);
 
-  // mDBFindURIBookmarks
-  // NOTE: Do not modify the ORDER BY segment of the query, as certain
-  // features depend on it. See bug 398914 for an example.
-  rv = dbConn->CreateStatement(NS_LITERAL_CSTRING(
-      "SELECT a.id "
-      "FROM moz_bookmarks a, moz_places h "
-      "WHERE h.url = ?1 AND a.fk = h.id and a.type = ?2 "
-      "ORDER BY MAX(COALESCE(a.lastModified, 0), a.dateAdded) DESC, a.id DESC"),
-    getter_AddRefs(mDBFindURIBookmarks));
+  rv = FillBookmarksHash();
   NS_ENSURE_SUCCESS(rv, rv);
-
-  // Construct a result where the first columns exactly match those returned by
-  // mDBGetURLPageInfo, and additionally contains columns for position,
-  // item_child, and folder_child from moz_bookmarks.
-  // Results are kGetInfoIndex_*
-
-  // mDBGetChildren: select all children of a given folder, sorted by position
-  // This is a LEFT OUTER JOIN with moz_places since folders does not have
-  // a reference into that table.
-  rv = dbConn->CreateStatement(NS_LITERAL_CSTRING(
-      "SELECT h.id, h.url, COALESCE(b.title, h.title), "
-      "h.rev_host, h.visit_count, "
-      SQL_STR_FRAGMENT_MAX_VISIT_DATE( "h.id" )
-      ", f.url, null, b.id, "
-      "b.dateAdded, b.lastModified, "
-      "b.position, b.type, b.fk "
-      "FROM moz_bookmarks b "
-      "LEFT OUTER JOIN moz_places h ON b.fk = h.id "
-      "LEFT OUTER JOIN moz_favicons f ON h.favicon_id = f.id "
-      "WHERE b.parent = ?1 "
-      "ORDER BY b.position"),
-    getter_AddRefs(mDBGetChildren));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  // mDBFolderCount: count all of the children of a given folder
-  rv = dbConn->CreateStatement(NS_LITERAL_CSTRING("SELECT COUNT(*) FROM moz_bookmarks WHERE parent = ?1"),
-                               getter_AddRefs(mDBFolderCount));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  rv = dbConn->CreateStatement(NS_LITERAL_CSTRING("SELECT position FROM moz_bookmarks WHERE id = ?1"),
-                               getter_AddRefs(mDBGetItemIndex));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  rv = dbConn->CreateStatement(NS_LITERAL_CSTRING("SELECT id, fk, type FROM moz_bookmarks WHERE parent = ?1 AND position = ?2"),
-                               getter_AddRefs(mDBGetChildAt));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  // get bookmark/folder/separator properties 
-  rv = dbConn->CreateStatement(NS_LITERAL_CSTRING(
-      "SELECT b.id, (SELECT url from moz_places WHERE id = b.fk), b.title, b.position, b.fk, b.parent, b.type, b.folder_type, b.dateAdded, b.lastModified "
-      "FROM moz_bookmarks b "
-      "WHERE b.id = ?1"),
-    getter_AddRefs(mDBGetItemProperties));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  rv = dbConn->CreateStatement(NS_LITERAL_CSTRING(
-      "SELECT item_id FROM moz_items_annos "
-      "WHERE content = ?1 "
-      "LIMIT 1"),
-    getter_AddRefs(mDBGetItemIdForGUID));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  // mDBGetRedirectDestinations
-  // input = page ID, time threshold; output = unique ID input has redirected to
-  rv = dbConn->CreateStatement(NS_LITERAL_CSTRING(
-      "SELECT dest_v.place_id "
-      "FROM moz_historyvisits source_v "
-      "LEFT JOIN moz_historyvisits dest_v ON dest_v.from_visit = source_v.id "
-      "WHERE source_v.place_id = ?1 "
-      "AND source_v.visit_date >= ?2 "
-      "AND (dest_v.visit_type = 5 OR dest_v.visit_type = 6) "
-      "GROUP BY dest_v.place_id"),
-    getter_AddRefs(mDBGetRedirectDestinations));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  // mDBInsertBookmark
-  rv = dbConn->CreateStatement(NS_LITERAL_CSTRING("INSERT INTO moz_bookmarks "
-                               "(fk, type, parent, position, title, dateAdded) "
-                               "VALUES (?1, ?2, ?3, ?4, ?5, ?6)"),
-                               getter_AddRefs(mDBInsertBookmark));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  // mDBIsBookmarkedInDatabase
-  // Just select position since it's just an int32 and may be faster.
-  // We don't actually care about the data, just whether there is any.
-  rv = DBConn()->CreateStatement(NS_LITERAL_CSTRING(
-      "SELECT position FROM moz_bookmarks WHERE fk = ?1 AND type = ?2"),
-    getter_AddRefs(mDBIsBookmarkedInDatabase));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  // mDBGetLastBookmarkID
-  rv = DBConn()->CreateStatement(NS_LITERAL_CSTRING(
-      "SELECT id "
-      "FROM moz_bookmarks "
-      "ORDER BY ROWID DESC "
-      "LIMIT 1"),
-    getter_AddRefs(mDBGetLastBookmarkID));
-
-  // mDBSetItemDateAdded
-  rv = dbConn->CreateStatement(NS_LITERAL_CSTRING("UPDATE moz_bookmarks SET dateAdded = ?1 WHERE id = ?2"),
-    getter_AddRefs(mDBSetItemDateAdded));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  // mDBSetItemLastModified
-  rv = dbConn->CreateStatement(NS_LITERAL_CSTRING("UPDATE moz_bookmarks SET lastModified = ?1 WHERE id = ?2"),
-                               getter_AddRefs(mDBSetItemLastModified));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  // mDBSetItemIndex
-  rv = DBConn()->CreateStatement(NS_LITERAL_CSTRING("UPDATE moz_bookmarks SET position = ?2 WHERE id = ?1"),
-                               getter_AddRefs(mDBSetItemIndex));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  FillBookmarksHash();
-
-  // must be last: This may cause bookmarks to be imported, which will exercise
-  // most of the bookmark system
-
-  // get keyword text for bookmark id
-  rv = dbConn->CreateStatement(NS_LITERAL_CSTRING(
-      "SELECT k.keyword FROM moz_bookmarks b "
-      "JOIN moz_keywords k ON k.id = b.keyword_id "
-      "WHERE b.id = ?1"),
-    getter_AddRefs(mDBGetKeywordForBookmark));
-  NS_ENSURE_SUCCESS(rv, rv);
-  // get keyword text for URI (must be a bookmarked URI)
-  rv = dbConn->CreateStatement(NS_LITERAL_CSTRING(
-      "SELECT k.keyword " 
-      "FROM moz_places p "
-      "JOIN moz_bookmarks b ON b.fk = p.id "
-      "JOIN moz_keywords k ON k.id = b.keyword_id "
-      "WHERE p.url = ?1"),
-    getter_AddRefs(mDBGetKeywordForURI));
-  NS_ENSURE_SUCCESS(rv, rv);
-  // get URI for keyword
-  rv = dbConn->CreateStatement(NS_LITERAL_CSTRING(
-      "SELECT p.url FROM moz_keywords k "
-      "JOIN moz_bookmarks b ON b.keyword_id = k.id "
-      "JOIN moz_places p ON b.fk = p.id "
-      "WHERE k.keyword = ?1"),
-    getter_AddRefs(mDBGetURIForKeyword));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  // generate a new GUID base for this session
-  nsCOMPtr<nsIUUIDGenerator> uuidgen = do_GetService("@mozilla.org/uuid-generator;1", &rv);
-  NS_ENSURE_SUCCESS(rv, rv);
-  nsID GUID;
-  rv = uuidgen->GenerateUUIDInPlace(&GUID);
-  NS_ENSURE_SUCCESS(rv, rv);
-  char GUIDChars[NSID_LENGTH];
-  GUID.ToProvidedString(GUIDChars);
-  CopyASCIItoUTF16(GUIDChars, mGUIDBase);
 
   rv = InitRoots();
   NS_ENSURE_SUCCESS(rv, rv);
@@ -296,27 +122,15 @@
   rv = transaction.Commit();
   NS_ENSURE_SUCCESS(rv, rv);
 
-  // Temporary migration code for bug 396300
-  nsCOMPtr<mozIStorageStatement> moveUnfiledBookmarks;
-  rv = dbConn->CreateStatement(NS_LITERAL_CSTRING("UPDATE moz_bookmarks SET parent = ?1 WHERE type = ?2 AND parent=?3"),
-                               getter_AddRefs(moveUnfiledBookmarks));
-  rv = moveUnfiledBookmarks->BindInt64Parameter(0, mUnfiledRoot);
-  NS_ENSURE_SUCCESS(rv, rv);
-  rv = moveUnfiledBookmarks->BindInt32Parameter(1, TYPE_BOOKMARK);
-  NS_ENSURE_SUCCESS(rv, rv);
-  rv = moveUnfiledBookmarks->BindInt64Parameter(2, mRoot);
-  NS_ENSURE_SUCCESS(rv, rv);
-  rv = moveUnfiledBookmarks->Execute();
-  NS_ENSURE_SUCCESS(rv, rv);
-
+  // Add observers
   nsAnnotationService* annosvc = nsAnnotationService::GetAnnotationService();
   NS_ENSURE_TRUE(annosvc, NS_ERROR_OUT_OF_MEMORY);
+  annosvc->AddObserver(this);
 
   // allows us to notify on title changes. MUST BE LAST so it is impossible
   // to fail after this call, or the history service will have a reference to
   // us and we won't go away.
   history->AddObserver(this, PR_FALSE);
-  annosvc->AddObserver(this);
 
   // DO NOT PUT STUFF HERE that can fail. See observer comment above.
 
@@ -385,6 +199,239 @@
 }
 
 
+// nsNavBookmarks::InitStatements
+//
+//    Create common statements to query the database
+nsresult
+nsNavBookmarks::InitStatements()
+{
+  // mDBFindURIBookmarks
+  // NOTE: Do not modify the ORDER BY segment of the query, as certain
+  // features depend on it. See bug 398914 for an example.
+  nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "SELECT b.id "
+      "FROM moz_bookmarks b "
+      "JOIN ( "
+        "SELECT id FROM moz_places_temp "
+        "WHERE url = ?1 "
+        "UNION ALL "
+        "SELECT id FROM moz_places "
+        "WHERE url = ?1 "
+        "AND +id NOT IN (SELECT id FROM moz_places_temp) "
+      ") AS h ON b.fk = h.id "
+      "WHERE b.type = ?2 "
+      "ORDER BY MAX(IFNULL(b.lastModified, 0), b.dateAdded) DESC, b.id DESC"),
+    getter_AddRefs(mDBFindURIBookmarks));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // Construct a result where the first columns exactly match those returned by
+  // mDBGetURLPageInfo, and additionally contains columns for position,
+  // item_child, and folder_child from moz_bookmarks.
+  // Results are kGetInfoIndex_*
+
+  // mDBGetChildren: select all children of a given folder, sorted by position
+  // This is a LEFT OUTER JOIN with moz_places since folders does not have
+  // a reference into that table.
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "SELECT * FROM ( "
+        "SELECT h.id, h.url, COALESCE(b.title, h.title), "
+        "h.rev_host, h.visit_count, "
+          SQL_STR_FRAGMENT_MAX_VISIT_DATE( "h.id" )
+          ", f.url, null, b.id, b.dateAdded, b.lastModified, "
+          "b.position, b.type, b.fk "
+        "FROM moz_bookmarks b "
+        "JOIN moz_places_temp h ON b.fk = h.id "
+        "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
+        "WHERE b.parent = ?1 "
+        "UNION ALL "
+        "SELECT h.id, h.url, COALESCE(b.title, h.title), "
+        "h.rev_host, h.visit_count, "
+          SQL_STR_FRAGMENT_MAX_VISIT_DATE( "h.id" )
+          ", f.url, null, b.id, b.dateAdded, b.lastModified, "
+          "b.position, b.type, b.fk "
+        "FROM moz_bookmarks b "
+        "LEFT JOIN moz_places h ON b.fk = h.id "
+        "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
+        "WHERE b.parent = ?1 "
+        "AND (b.fk ISNULL OR b.fk NOT IN (select id FROM moz_places_temp)) "
+      ") "
+      "ORDER BY 12 ASC"), /* position */
+    getter_AddRefs(mDBGetChildren));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // mDBFolderCount: count all of the children of a given folder
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "SELECT COUNT(*) FROM moz_bookmarks WHERE parent = ?1"),
+    getter_AddRefs(mDBFolderCount));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "SELECT position FROM moz_bookmarks WHERE id = ?1"),
+    getter_AddRefs(mDBGetItemIndex));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "SELECT id, fk, type FROM moz_bookmarks WHERE parent = ?1 AND position = ?2"),
+    getter_AddRefs(mDBGetChildAt));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // get bookmark/folder/separator properties
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "SELECT b.id, "
+        "IFNULL( "
+          "(SELECT url FROM moz_places_temp "
+          "WHERE id = (SELECT fk FROM moz_bookmarks WHERE id = ?1)) "
+          ", "
+          "(SELECT url FROM moz_places "
+          "WHERE id = (SELECT fk FROM moz_bookmarks WHERE id = ?1)) "
+        "), b.title, b.position, b.fk, b.parent, b.type, b.folder_type, "
+        "b.dateAdded, b.lastModified "
+      "FROM moz_bookmarks b "
+      "WHERE b.id = ?1"),
+    getter_AddRefs(mDBGetItemProperties));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "SELECT item_id FROM moz_items_annos "
+      "WHERE content = ?1 "
+      "LIMIT 1"),
+    getter_AddRefs(mDBGetItemIdForGUID));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // mDBGetRedirectDestinations
+  // input = page ID, time threshold; output = unique ID input has redirected to
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "SELECT DISTINCT dest_v.place_id "
+      "FROM moz_historyvisits_temp source_v "
+      "JOIN moz_historyvisits_temp dest_v ON dest_v.from_visit = source_v.id "
+      "WHERE source_v.place_id = ?1 "
+        "AND source_v.visit_date >= ?2 "
+        "AND dest_v.visit_type IN (") +
+        nsPrintfCString("%d,%d",
+                        nsINavHistoryService::TRANSITION_REDIRECT_PERMANENT,
+                        nsINavHistoryService::TRANSITION_REDIRECT_TEMPORARY) +
+        NS_LITERAL_CSTRING(") "
+      "UNION "
+      "SELECT DISTINCT dest_v.place_id "
+      "FROM moz_historyvisits_temp source_v "
+      "JOIN moz_historyvisits dest_v ON dest_v.from_visit = source_v.id "
+      "WHERE source_v.place_id = ?1 "
+        "AND source_v.visit_date >= ?2 "
+        "AND dest_v.visit_type IN (") +
+        nsPrintfCString("%d,%d",
+                        nsINavHistoryService::TRANSITION_REDIRECT_PERMANENT,
+                        nsINavHistoryService::TRANSITION_REDIRECT_TEMPORARY) +
+        NS_LITERAL_CSTRING(") "
+      "UNION "
+      "SELECT DISTINCT dest_v.place_id "
+      "FROM moz_historyvisits source_v "
+      "JOIN moz_historyvisits_temp dest_v ON dest_v.from_visit = source_v.id "
+      "WHERE source_v.place_id = ?1 "
+        "AND source_v.visit_date >= ?2 "
+        "AND dest_v.visit_type IN (") +
+        nsPrintfCString("%d,%d",
+                        nsINavHistoryService::TRANSITION_REDIRECT_PERMANENT,
+                        nsINavHistoryService::TRANSITION_REDIRECT_TEMPORARY) +
+        NS_LITERAL_CSTRING(") "
+      "UNION "      
+      "SELECT DISTINCT dest_v.place_id "
+      "FROM moz_historyvisits source_v "
+      "JOIN moz_historyvisits dest_v ON dest_v.from_visit = source_v.id "
+      "WHERE source_v.place_id = ?1 "
+        "AND source_v.visit_date >= ?2 "
+        "AND dest_v.visit_type IN (") +
+        nsPrintfCString("%d,%d",
+                        nsINavHistoryService::TRANSITION_REDIRECT_PERMANENT,
+                        nsINavHistoryService::TRANSITION_REDIRECT_TEMPORARY) +
+        NS_LITERAL_CSTRING(") "),
+    getter_AddRefs(mDBGetRedirectDestinations));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // mDBInsertBookmark
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "INSERT INTO moz_bookmarks "
+        "(fk, type, parent, position, title, dateAdded) "
+      "VALUES (?1, ?2, ?3, ?4, ?5, ?6)"),
+    getter_AddRefs(mDBInsertBookmark));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // mDBIsBookmarkedInDatabase
+  // Just select position since it's just an int32 and may be faster.
+  // We don't actually care about the data, just whether there is any.
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "SELECT position FROM moz_bookmarks WHERE fk = ?1 AND type = ?2"),
+    getter_AddRefs(mDBIsBookmarkedInDatabase));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // mDBGetLastBookmarkID
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "SELECT id "
+      "FROM moz_bookmarks "
+      "ORDER BY ROWID DESC "
+      "LIMIT 1"),
+    getter_AddRefs(mDBGetLastBookmarkID));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // mDBSetItemDateAdded
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "UPDATE moz_bookmarks SET dateAdded = ?1 WHERE id = ?2"),
+    getter_AddRefs(mDBSetItemDateAdded));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // mDBSetItemLastModified
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "UPDATE moz_bookmarks SET lastModified = ?1 WHERE id = ?2"),
+    getter_AddRefs(mDBSetItemLastModified));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // mDBSetItemIndex
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "UPDATE moz_bookmarks SET position = ?2 WHERE id = ?1"),
+    getter_AddRefs(mDBSetItemIndex));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // get keyword text for bookmark id
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "SELECT k.keyword FROM moz_bookmarks b "
+      "JOIN moz_keywords k ON k.id = b.keyword_id "
+      "WHERE b.id = ?1"),
+    getter_AddRefs(mDBGetKeywordForBookmark));
+  NS_ENSURE_SUCCESS(rv, rv);
+  // get keyword text for URI (must be a bookmarked URI)
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "SELECT k.keyword "
+      "FROM ( "
+        "SELECT id FROM moz_places_temp "
+        "WHERE url = ?1 "
+        "UNION ALL "
+        "SELECT id FROM moz_places "
+        "WHERE +id NOT IN (SELECT id FROM moz_places_temp) "
+          "AND url = ?1 "
+      ") AS h "
+      "JOIN moz_bookmarks b ON b.fk = h.id "
+      "JOIN moz_keywords k ON k.id = b.keyword_id"),
+    getter_AddRefs(mDBGetKeywordForURI));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // get URI for keyword
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "SELECT url FROM moz_keywords k "
+      "JOIN moz_bookmarks b ON b.keyword_id = k.id "
+      "JOIN moz_places_temp h ON b.fk = h.id "
+      "WHERE k.keyword = ?1 "
+      "UNION ALL "
+      "SELECT url FROM moz_keywords k "
+      "JOIN moz_bookmarks b ON b.keyword_id = k.id "
+      "JOIN moz_places h ON b.fk = h.id "
+      "WHERE k.keyword = ?1 "
+        "AND h.id NOT IN (SELECT id FROM moz_places_temp)"),
+    getter_AddRefs(mDBGetURIForKeyword));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  return NS_OK;
+}
+
+
 // nsNavBookmarks::InitRoots
 //
 //    This locates and creates if necessary the root items in the bookmarks
@@ -410,8 +457,9 @@
 nsNavBookmarks::InitRoots()
 {
   nsCOMPtr<mozIStorageStatement> getRootStatement;
-  nsresult rv = DBConn()->CreateStatement(NS_LITERAL_CSTRING("SELECT folder_id FROM moz_bookmarks_roots WHERE root_name = ?1"),
-                                 getter_AddRefs(getRootStatement));
+  nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "SELECT folder_id FROM moz_bookmarks_roots WHERE root_name = ?1"),
+    getter_AddRefs(getRootStatement));
   NS_ENSURE_SUCCESS(rv, rv);
 
   PRBool createdPlacesRoot = PR_FALSE;
@@ -438,8 +486,9 @@
                                           &folders);
     if (folders.Length() > 0) {
       nsCOMPtr<mozIStorageStatement> moveItems;
-      rv = DBConn()->CreateStatement(NS_LITERAL_CSTRING("UPDATE moz_bookmarks SET parent = ?1 WHERE parent=?2"),
-                                     getter_AddRefs(moveItems));
+      rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+          "UPDATE moz_bookmarks SET parent = ?1 WHERE parent=?2"),
+        getter_AddRefs(moveItems));
       rv = moveItems->BindInt64Parameter(0, mToolbarFolder);
       NS_ENSURE_SUCCESS(rv, rv);
       rv = moveItems->BindInt64Parameter(1, folders[0]);
@@ -489,34 +538,37 @@
 nsresult
 nsNavBookmarks::InitDefaults()
 {
+  nsIStringBundle *bundle = History()->GetBundle();
+  NS_ENSURE_TRUE(bundle, NS_ERROR_OUT_OF_MEMORY);
+
   // Bookmarks Menu
   nsXPIDLString bookmarksTitle;
-  nsresult rv = mBundle->GetStringFromName(NS_LITERAL_STRING("BookmarksMenuFolderTitle").get(),
-                                           getter_Copies(bookmarksTitle));
+  nsresult rv = bundle->GetStringFromName(NS_LITERAL_STRING("BookmarksMenuFolderTitle").get(),
+                                          getter_Copies(bookmarksTitle));
   NS_ENSURE_SUCCESS(rv, rv);
   rv = SetItemTitle(mBookmarksRoot, NS_ConvertUTF16toUTF8(bookmarksTitle));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // Bookmarks Toolbar
   nsXPIDLString toolbarTitle;
-  rv = mBundle->GetStringFromName(NS_LITERAL_STRING("BookmarksToolbarFolderTitle").get(),
-                                  getter_Copies(toolbarTitle));
+  rv = bundle->GetStringFromName(NS_LITERAL_STRING("BookmarksToolbarFolderTitle").get(),
+                                 getter_Copies(toolbarTitle));
   NS_ENSURE_SUCCESS(rv, rv);
   rv = SetItemTitle(mToolbarFolder, NS_ConvertUTF16toUTF8(toolbarTitle));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // Unsorted Bookmarks
   nsXPIDLString unfiledTitle;
-  rv = mBundle->GetStringFromName(NS_LITERAL_STRING("UnsortedBookmarksFolderTitle").get(),
-                                  getter_Copies(unfiledTitle));
+  rv = bundle->GetStringFromName(NS_LITERAL_STRING("UnsortedBookmarksFolderTitle").get(),
+                                 getter_Copies(unfiledTitle));
   NS_ENSURE_SUCCESS(rv, rv);
   rv = SetItemTitle(mUnfiledRoot, NS_ConvertUTF16toUTF8(unfiledTitle));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // Tags
   nsXPIDLString tagsTitle;
-  rv = mBundle->GetStringFromName(NS_LITERAL_STRING("TagsFolderTitle").get(),
-                                  getter_Copies(tagsTitle));
+  rv = bundle->GetStringFromName(NS_LITERAL_STRING("TagsFolderTitle").get(),
+                                 getter_Copies(tagsTitle));
   NS_ENSURE_SUCCESS(rv, rv);
   rv = SetItemTitle(mTagRoot, NS_ConvertUTF16toUTF8(tagsTitle));
   NS_ENSURE_SUCCESS(rv, rv);
@@ -560,8 +612,9 @@
   NS_ENSURE_SUCCESS(rv, rv);
 
   // save root ID
-  rv = DBConn()->CreateStatement(NS_LITERAL_CSTRING("INSERT INTO moz_bookmarks_roots (root_name, folder_id) VALUES (?1, ?2)"),
-                                 getter_AddRefs(insertStatement));
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "INSERT INTO moz_bookmarks_roots (root_name, folder_id) VALUES (?1, ?2)"),
+    getter_AddRefs(insertStatement));
   NS_ENSURE_SUCCESS(rv, rv);
   rv = insertStatement->BindUTF8StringParameter(0, name);
   NS_ENSURE_SUCCESS(rv, rv);
@@ -593,7 +646,7 @@
 
   // first populate the table with all bookmarks
   nsCOMPtr<mozIStorageStatement> statement;
-  nsresult rv = DBConn()->CreateStatement(NS_LITERAL_CSTRING(
+  nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
       "SELECT h.id "
       "FROM moz_bookmarks b "
       "LEFT JOIN moz_places h ON b.fk = h.id where b.type = ?1"),
@@ -614,14 +667,50 @@
   //                 visit (v1) -> destination visit (v2)
   // This should catch most redirects, which are only one level. More levels of
   // redirection will be handled separately.
-  rv = DBConn()->CreateStatement(NS_LITERAL_CSTRING(
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
       "SELECT v1.place_id, v2.place_id "
-      "FROM moz_bookmarks b "
-      "LEFT JOIN moz_historyvisits v1 on b.fk = v1.place_id "
-      "LEFT JOIN moz_historyvisits v2 on v2.from_visit = v1.id "
-      "WHERE b.fk IS NOT NULL AND b.type = ?1 "
-      "AND v2.visit_type = 5 OR v2.visit_type = 6 " // perm. or temp. RDRs
-      "GROUP BY v2.place_id"),
+        "FROM moz_bookmarks b "
+        "LEFT JOIN moz_historyvisits_temp v1 on b.fk = v1.place_id "
+        "LEFT JOIN moz_historyvisits v2 on v2.from_visit = v1.id "
+        "WHERE b.fk IS NOT NULL AND b.type = ?1 "
+        "AND v2.visit_type IN (") +
+        nsPrintfCString("%d,%d",
+                        nsINavHistoryService::TRANSITION_REDIRECT_PERMANENT,
+                        nsINavHistoryService::TRANSITION_REDIRECT_TEMPORARY) +
+        NS_LITERAL_CSTRING(") GROUP BY v2.place_id "
+      "UNION "
+      "SELECT v1.place_id, v2.place_id "
+        "FROM moz_bookmarks b "
+        "LEFT JOIN moz_historyvisits v1 on b.fk = v1.place_id "
+        "LEFT JOIN moz_historyvisits_temp v2 on v2.from_visit = v1.id "
+        "WHERE b.fk IS NOT NULL AND b.type = ?1 "
+        "AND v2.visit_type IN (") +
+        nsPrintfCString("%d,%d",
+                        nsINavHistoryService::TRANSITION_REDIRECT_PERMANENT,
+                        nsINavHistoryService::TRANSITION_REDIRECT_TEMPORARY) +
+        NS_LITERAL_CSTRING(") GROUP BY v2.place_id "
+      "UNION "
+      "SELECT v1.place_id, v2.place_id "
+        "FROM moz_bookmarks b "
+        "LEFT JOIN moz_historyvisits v1 on b.fk = v1.place_id "
+        "LEFT JOIN moz_historyvisits v2 on v2.from_visit = v1.id "
+        "WHERE b.fk IS NOT NULL AND b.type = ?1 "
+        "AND v2.visit_type IN (") +
+        nsPrintfCString("%d,%d",
+                        nsINavHistoryService::TRANSITION_REDIRECT_PERMANENT,
+                        nsINavHistoryService::TRANSITION_REDIRECT_TEMPORARY) +
+        NS_LITERAL_CSTRING(") GROUP BY v2.place_id "
+      "UNION "
+        "SELECT v1.place_id, v2.place_id "
+        "FROM moz_bookmarks b "
+        "LEFT JOIN moz_historyvisits_temp v1 on b.fk = v1.place_id "
+        "LEFT JOIN moz_historyvisits_temp v2 on v2.from_visit = v1.id "
+        "WHERE b.fk IS NOT NULL AND b.type = ?1 "
+        "AND v2.visit_type IN (") +
+        nsPrintfCString("%d,%d",
+                        nsINavHistoryService::TRANSITION_REDIRECT_PERMANENT,
+                        nsINavHistoryService::TRANSITION_REDIRECT_TEMPORARY) +
+        NS_LITERAL_CSTRING(") GROUP BY v2.place_id "),
     getter_AddRefs(statement));
   NS_ENSURE_SUCCESS(rv, rv);
   rv = statement->BindInt64Parameter(0, TYPE_BOOKMARK);
@@ -811,7 +900,7 @@
     buffer.AppendInt(aEndIndex);
   }
 
-  nsresult rv = DBConn()->ExecuteSimpleSQL(buffer);
+  nsresult rv = mDBConn->ExecuteSimpleSQL(buffer);
   NS_ENSURE_SUCCESS(rv, rv);
  
   return NS_OK;
@@ -862,8 +951,7 @@
     return NS_ERROR_INVALID_ARG;
   NS_ENSURE_ARG_POINTER(aNewBookmarkId);
 
-  mozIStorageConnection *dbConn = DBConn();
-  mozStorageTransaction transaction(dbConn, PR_FALSE);
+  mozStorageTransaction transaction(mDBConn, PR_FALSE);
 
   // This is really a place ID
   PRInt64 childID;
@@ -1024,8 +1112,7 @@
     return NS_OK;
   }
 
-  mozIStorageConnection *dbConn = DBConn();
-  mozStorageTransaction transaction(dbConn, PR_FALSE);
+  mozStorageTransaction transaction(mDBConn, PR_FALSE);
 
   // First, remove item annotations
   nsAnnotationService* annosvc = nsAnnotationService::GetAnnotationService();
@@ -1036,7 +1123,7 @@
   buffer.AssignLiteral("DELETE FROM moz_bookmarks WHERE id = ");
   buffer.AppendInt(aItemId);
 
-  rv = dbConn->ExecuteSimpleSQL(buffer);
+  rv = mDBConn->ExecuteSimpleSQL(buffer);
   NS_ENSURE_SUCCESS(rv, rv);
 
   if (childIndex != -1) {
@@ -1161,8 +1248,7 @@
   if (*aIndex < -1)
     return NS_ERROR_INVALID_ARG;
 
-  mozIStorageConnection *dbConn = DBConn();
-  mozStorageTransaction transaction(dbConn, PR_FALSE);
+  mozStorageTransaction transaction(mDBConn, PR_FALSE);
 
   PRInt32 index;
   nsresult rv;
@@ -1176,13 +1262,19 @@
 
   nsCOMPtr<mozIStorageStatement> statement;
   if (aItemId == -1) {
-    rv = dbConn->CreateStatement(NS_LITERAL_CSTRING("INSERT INTO moz_bookmarks (title, type, parent, position, folder_type, dateAdded) VALUES (?1, ?2, ?3, ?4, ?5, ?6)"),
-                                 getter_AddRefs(statement));
+    rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+        "INSERT INTO moz_bookmarks "
+          "(title, type, parent, position, folder_type, dateAdded) "
+        "VALUES (?1, ?2, ?3, ?4, ?5, ?6)"),
+      getter_AddRefs(statement));
     NS_ENSURE_SUCCESS(rv, rv);
   }
   else {
-    rv = dbConn->CreateStatement(NS_LITERAL_CSTRING("INSERT INTO moz_bookmarks (id, title, type, parent, position, folder_type, dateAdded) VALUES (?7, ?1, ?2, ?3, ?4, ?5, ?6)"),
-                                 getter_AddRefs(statement));
+    rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+        "INSERT INTO moz_bookmarks "
+          "(id, title, type, parent, position, folder_type, dateAdded) "
+        "VALUES (?7, ?1, ?2, ?3, ?4, ?5, ?6)"),
+      getter_AddRefs(statement));
     NS_ENSURE_SUCCESS(rv, rv);
 
     rv = statement->BindInt64Parameter(6, aItemId);
@@ -1246,8 +1338,7 @@
   if (aIndex < -1)
     return NS_ERROR_INVALID_ARG;
 
-  mozIStorageConnection *dbConn = DBConn();
-  mozStorageTransaction transaction(dbConn, PR_FALSE);
+  mozStorageTransaction transaction(mDBConn, PR_FALSE);
 
   PRInt32 index;
   nsresult rv;
@@ -1260,9 +1351,10 @@
   }
 
   nsCOMPtr<mozIStorageStatement> statement;
-  rv = dbConn->CreateStatement(NS_LITERAL_CSTRING("INSERT INTO moz_bookmarks "
-                                          "(type, parent, position, dateAdded) VALUES (?1, ?2, ?3, ?4)"),
-                               getter_AddRefs(statement));
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "INSERT INTO moz_bookmarks "
+        "(type, parent, position, dateAdded) VALUES (?1, ?2, ?3, ?4)"),
+    getter_AddRefs(statement));
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = statement->BindInt64Parameter(0, TYPE_SEPARATOR);
@@ -1303,10 +1395,8 @@
 nsresult
 nsNavBookmarks::GetLastChildId(PRInt64 aFolder, PRInt64* aItemId)
 {
-  mozIStorageConnection *dbConn = DBConn();
-
   nsCOMPtr<mozIStorageStatement> statement;
-  nsresult rv = dbConn->CreateStatement(NS_LITERAL_CSTRING(
+  nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
       "SELECT id FROM moz_bookmarks WHERE parent = ?1 "
       "ORDER BY position DESC LIMIT 1"), getter_AddRefs(statement));
   NS_ENSURE_SUCCESS(rv, rv);
@@ -1360,8 +1450,7 @@
 NS_IMETHODIMP
 nsNavBookmarks::RemoveChildAt(PRInt64 aParent, PRInt32 aIndex)
 {
-  mozIStorageConnection *dbConn = DBConn();
-  mozStorageTransaction transaction(dbConn, PR_FALSE);
+  mozStorageTransaction transaction(mDBConn, PR_FALSE);
   nsresult rv;
   PRInt64 id;
   PRInt32 type;
@@ -1411,7 +1500,7 @@
   buffer.AppendInt(aFolder);
 
   nsCOMPtr<mozIStorageStatement> statement;
-  nsresult rv = DBConn()->CreateStatement(buffer, getter_AddRefs(statement));
+  nsresult rv = mDBConn->CreateStatement(buffer, getter_AddRefs(statement));
   NS_ENSURE_SUCCESS(rv, rv);
 
   PRBool results;
@@ -1430,8 +1519,7 @@
 NS_IMETHODIMP
 nsNavBookmarks::RemoveFolder(PRInt64 aFolderId)
 {
-  mozIStorageConnection *dbConn = DBConn();
-  mozStorageTransaction transaction(dbConn, PR_FALSE);
+  mozStorageTransaction transaction(mDBConn, PR_FALSE);
 
   nsresult rv;
 
@@ -1486,7 +1574,7 @@
   nsCAutoString buffer;
   buffer.AssignLiteral("DELETE FROM moz_bookmarks WHERE id = ");
   buffer.AppendInt(aFolderId);
-  rv = dbConn->ExecuteSimpleSQL(buffer);
+  rv = mDBConn->ExecuteSimpleSQL(buffer);
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = AdjustIndices(parent, index + 1, PR_INT32_MAX, -1);
@@ -1528,7 +1616,7 @@
 NS_IMETHODIMP
 nsNavBookmarks::RemoveFolderChildren(PRInt64 aFolder)
 {
-  mozStorageTransaction transaction(DBConn(), PR_FALSE);
+  mozStorageTransaction transaction(mDBConn, PR_FALSE);
 
   nsTArray<PRInt64> folderChildren;
   nsTArray<PRInt64> itemChildren; // bookmarks / separators
@@ -1581,8 +1669,7 @@
   if (aItemId == aNewParent)
     return NS_ERROR_INVALID_ARG;
 
-  mozIStorageConnection *dbConn = DBConn();
-  mozStorageTransaction transaction(dbConn, PR_FALSE);
+  mozStorageTransaction transaction(mDBConn, PR_FALSE);
 
   // get item properties
   nsresult rv;
@@ -1700,7 +1787,7 @@
   }
   buffer.AppendLiteral(" WHERE id = ");
   buffer.AppendInt(aItemId);
-  rv = dbConn->ExecuteSimpleSQL(buffer);
+  rv = mDBConn->ExecuteSimpleSQL(buffer);
   NS_ENSURE_SUCCESS(rv, rv);
 
   PRTime now = PR_Now();
@@ -1746,7 +1833,7 @@
     nsPrintfCString("%d", TYPE_FOLDER) +
     NS_LITERAL_CSTRING(" AND title = ?2");
   nsCOMPtr<mozIStorageStatement> statement;
-  rv = DBConn()->CreateStatement(getChildFolderQuery, getter_AddRefs(statement));
+  rv = mDBConn->CreateStatement(getChildFolderQuery, getter_AddRefs(statement));
   NS_ENSURE_SUCCESS(rv, rv);
   statement->BindInt64Parameter(0, aFolder);
   statement->BindStringParameter(1, aSubFolder);
@@ -1844,6 +1931,28 @@
   return mDBGetItemProperties->GetInt64(kGetItemPropertiesIndex_LastModified, aLastModified);
 }
 
+nsresult
+nsNavBookmarks::GetGUIDBase(nsAString &aGUIDBase)
+{
+  if (!mGUIDBase.IsEmpty()) {
+    aGUIDBase = mGUIDBase;
+    return NS_OK;
+  }
+
+  // generate a new GUID base for this session
+  nsCOMPtr<nsIUUIDGenerator> uuidgen =
+    do_GetService("@mozilla.org/uuid-generator;1");
+  NS_ENSURE_TRUE(uuidgen, NS_ERROR_OUT_OF_MEMORY);
+  nsID GUID;
+  nsresult rv = uuidgen->GenerateUUIDInPlace(&GUID);
+  NS_ENSURE_SUCCESS(rv, rv);
+  char GUIDChars[NSID_LENGTH];
+  GUID.ToProvidedString(GUIDChars);
+  CopyASCIItoUTF16(GUIDChars, mGUIDBase);
+  aGUIDBase = mGUIDBase;
+  return NS_OK;
+}
+
 NS_IMETHODIMP
 nsNavBookmarks::GetItemGUID(PRInt64 aItemId, nsAString &aGUID)
 {
@@ -1857,7 +1966,10 @@
   nsAutoString tmp;
   tmp.AppendInt(mItemCount++);
   aGUID.SetCapacity(NSID_LENGTH - 1 + tmp.Length());
-  aGUID.Assign(mGUIDBase);
+  nsString GUIDBase;
+  rv = GetGUIDBase(GUIDBase);
+  NS_ENSURE_SUCCESS(rv, rv);
+  aGUID.Assign(GUIDBase);
   aGUID.Append(tmp);
 
   return SetItemGUID(aItemId, aGUID);
@@ -1898,10 +2010,8 @@
 NS_IMETHODIMP
 nsNavBookmarks::SetItemTitle(PRInt64 aItemId, const nsACString &aTitle)
 {
-  mozIStorageConnection *dbConn = DBConn();
-
   nsCOMPtr<mozIStorageStatement> statement;
-  nsresult rv = dbConn->CreateStatement(NS_LITERAL_CSTRING(
+  nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
       "UPDATE moz_bookmarks SET title = ?1, lastModified = ?2 WHERE id = ?3"),
     getter_AddRefs(statement));
   NS_ENSURE_SUCCESS(rv, rv);
@@ -2231,8 +2341,7 @@
 {
   NS_ENSURE_ARG(aNewURI);
 
-  mozIStorageConnection *dbConn = DBConn();
-  mozStorageTransaction transaction(dbConn, PR_FALSE);
+  mozStorageTransaction transaction(mDBConn, PR_FALSE);
 
   PRInt64 placeId;
   nsresult rv = History()->GetUrlIdFor(aNewURI, &placeId, PR_TRUE);
@@ -2241,8 +2350,9 @@
     return NS_ERROR_INVALID_ARG;
 
   nsCOMPtr<mozIStorageStatement> statement;
-  rv = dbConn->CreateStatement(NS_LITERAL_CSTRING("UPDATE moz_bookmarks SET fk = ?1 WHERE id = ?2"),
-                               getter_AddRefs(statement));
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "UPDATE moz_bookmarks SET fk = ?1 WHERE id = ?2"),
+    getter_AddRefs(statement));
   statement->BindInt64Parameter(0, placeId);
   statement->BindInt64Parameter(1, aBookmarkId);
 
@@ -2416,7 +2526,7 @@
   nsAutoString kwd(aKeyword);
   ToLowerCase(kwd);
 
-  mozStorageTransaction transaction(DBConn(), PR_FALSE);
+  mozStorageTransaction transaction(mDBConn, PR_FALSE);
   nsresult rv;
   PRBool results;
   PRInt64 keywordId = 0;
@@ -2424,8 +2534,8 @@
   if (!kwd.IsEmpty()) {
     //  Attempt to find pre-existing keyword record
     nsCOMPtr<mozIStorageStatement> getKeywordStmnt;
-    rv = DBConn()->CreateStatement(NS_LITERAL_CSTRING(
-         "SELECT id from moz_keywords WHERE keyword = ?1"),
+    rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+        "SELECT id from moz_keywords WHERE keyword = ?1"),
       getter_AddRefs(getKeywordStmnt));
     NS_ENSURE_SUCCESS(rv, rv);
     rv = getKeywordStmnt->BindStringParameter(0, kwd);
@@ -2441,7 +2551,7 @@
     else {
       // If not already in the db, create new keyword record
       nsCOMPtr<mozIStorageStatement> addKeywordStmnt;
-      rv = DBConn()->CreateStatement(NS_LITERAL_CSTRING(
+      rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
           "INSERT INTO moz_keywords (keyword) VALUES (?1)"),
         getter_AddRefs(addKeywordStmnt));
       NS_ENSURE_SUCCESS(rv, rv);
@@ -2451,7 +2561,7 @@
       NS_ENSURE_SUCCESS(rv, rv);
 
       nsCOMPtr<mozIStorageStatement> idStmt;
-      rv = DBConn()->CreateStatement(NS_LITERAL_CSTRING(
+      rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
           "SELECT id "
           "FROM moz_keywords "
           "ORDER BY ROWID DESC "
@@ -2469,7 +2579,7 @@
 
   // Update bookmark record w/ the keyword's id, or null
   nsCOMPtr<mozIStorageStatement> updateKeywordStmnt;
-  rv = DBConn()->CreateStatement(NS_LITERAL_CSTRING(
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
       "UPDATE moz_bookmarks SET keyword_id = ?1 WHERE id = ?2"),
     getter_AddRefs(updateKeywordStmnt));
   NS_ENSURE_SUCCESS(rv, rv);
@@ -2565,7 +2675,7 @@
 nsNavBookmarks::BeginUpdateBatch()
 {
   if (mBatchLevel++ == 0) {
-    mozIStorageConnection* conn = DBConn();
+    mozIStorageConnection* conn = mDBConn;
     PRBool transactionInProgress = PR_TRUE; // default to no transaction on err
     conn->GetTransactionInProgress(&transactionInProgress);
     mBatchHasTransaction = ! transactionInProgress;
@@ -2583,7 +2693,7 @@
 {
   if (--mBatchLevel == 0) {
     if (mBatchHasTransaction)
-      DBConn()->CommitTransaction();
+      mDBConn->CommitTransaction();
     mBatchHasTransaction = PR_FALSE;
     ENUMERATE_WEAKARRAY(mObservers, nsINavBookmarkObserver,
                         OnEndUpdateBatch())
diff -r 17e9560465b0 toolkit/components/places/src/nsNavBookmarks.h
--- a/toolkit/components/places/src/nsNavBookmarks.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/components/places/src/nsNavBookmarks.h	Thu Oct 30 05:41:46 2008 -0400
@@ -41,7 +41,6 @@
 
 #include "nsINavBookmarksService.h"
 #include "nsIAnnotationService.h"
-#include "nsIStringBundle.h"
 #include "nsITransaction.h"
 #include "nsNavHistory.h"
 #include "nsNavHistoryResult.h" // need for Int64 hashtable
@@ -112,6 +111,7 @@
 
   nsresult InitRoots();
   nsresult InitDefaults();
+  nsresult InitStatements();
   nsresult CreateRoot(mozIStorageStatement* aGetRootStatement,
                       const nsCString& name, PRInt64* aID,
                       PRInt64 aParentID, PRBool* aWasCreated);
@@ -127,12 +127,11 @@
   // remove me when there is better query initialization
   nsNavHistory* History() { return nsNavHistory::GetHistoryService(); }
 
-  mozIStorageStatement* DBGetURLPageInfo()
-  { return History()->DBGetURLPageInfo(); }
-
-  mozIStorageConnection* DBConn() { return History()->GetStorageConnection(); }
+  nsCOMPtr<mozIStorageConnection> mDBConn;
 
   nsString mGUIDBase;
+  nsresult GetGUIDBase(nsAString& aGUIDBase);
+
   PRInt32 mItemCount;
 
   nsMaybeWeakPtrArray<nsINavBookmarkObserver> mObservers;
@@ -213,8 +212,6 @@
   nsCOMPtr<mozIStorageStatement> mDBGetKeywordForBookmark;
   nsCOMPtr<mozIStorageStatement> mDBGetURIForKeyword;
 
-  nsCOMPtr<nsIStringBundle> mBundle;
-
   class RemoveFolderTransaction : public nsITransaction {
   public:
     RemoveFolderTransaction(PRInt64 aID) : mID(aID) {}
diff -r 17e9560465b0 toolkit/components/places/src/nsNavHistory.cpp
--- a/toolkit/components/places/src/nsNavHistory.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/components/places/src/nsNavHistory.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -436,6 +436,8 @@
   // session of the last visited page because we do have indices over dates.
   // We still do MAX(session) in case there are duplicate sessions for the same
   // date, but there will generally be very few (1) of these.
+  // This is long before we use our temporary tables, so we do not have to join
+  // on moz_historyvisits_temp to get the right result here.
   {
     nsCOMPtr<mozIStorageStatement> selectSession;
     rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
@@ -450,32 +452,6 @@
     else
       mLastSessionID = 1;
   }
-
-  // string bundle for localization
-  nsCOMPtr<nsIStringBundleService> bundleService =
-    do_GetService(NS_STRINGBUNDLE_CONTRACTID, &rv);
-  NS_ENSURE_SUCCESS(rv, rv);
-  rv = bundleService->CreateBundle(
-      "chrome://places/locale/places.properties",
-      getter_AddRefs(mBundle));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  // locale
-  nsCOMPtr<nsILocaleService> ls = do_GetService(NS_LOCALESERVICE_CONTRACTID, &rv);
-  NS_ENSURE_SUCCESS(rv, rv);
-  rv = ls->GetApplicationLocale(getter_AddRefs(mLocale));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  // collation
-  nsCOMPtr<nsICollationFactory> cfact = do_CreateInstance(
-     NS_COLLATIONFACTORY_CONTRACTID, &rv);
-  NS_ENSURE_SUCCESS(rv, rv);
-  rv = cfact->CreateCollation(mLocale, getter_AddRefs(mCollation));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  // date formatter
-  mDateFormatter = do_CreateInstance(NS_DATETIMEFORMAT_CONTRACTID, &rv);
-  NS_ENSURE_SUCCESS(rv, rv);
 
   // initialize idle timer
   InitializeIdleTimer();
@@ -648,7 +624,7 @@
 //
 
 
-#define PLACES_SCHEMA_VERSION 7
+#define PLACES_SCHEMA_VERSION 8
 
 nsresult
 nsNavHistory::InitDB(PRInt16 *aMadeChanges)
@@ -740,7 +716,13 @@
         NS_ENSURE_SUCCESS(rv, rv);
       }
 
-      // XXX Upgrades >V7 must add migration code here.
+      // Migrate historyvisits up to V8
+      if (DBSchemaVersion < 8) {
+        rv = MigrateV8Up(mDBConn);
+        NS_ENSURE_SUCCESS(rv, rv);
+      }
+
+      // XXX Upgrades >V8 must add migration code here.
 
     } else {
       // Downgrading
@@ -858,12 +840,6 @@
     rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
         "CREATE INDEX moz_historyvisits_dateindex ON moz_historyvisits (visit_date)"));
     NS_ENSURE_SUCCESS(rv, rv);
-
-    // Create our triggers for this table
-    rv = mDBConn->ExecuteSimpleSQL(CREATE_VISIT_COUNT_INSERT_TRIGGER);
-    NS_ENSURE_SUCCESS(rv, rv);
-    rv = mDBConn->ExecuteSimpleSQL(CREATE_VISIT_COUNT_DELETE_TRIGGER);
-    NS_ENSURE_SUCCESS(rv, rv);
   }
 
   // moz_inputhistory
@@ -887,6 +863,10 @@
 
   // DO NOT PUT ANY SCHEMA-MODIFYING THINGS HERE
 
+  rv = InitTempTables();
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = InitViews();
+  NS_ENSURE_SUCCESS(rv, rv);
   rv = InitFunctions();
   NS_ENSURE_SUCCESS(rv, rv);
   rv = InitStatements();
@@ -966,6 +946,94 @@
 }
 
 nsresult
+nsNavHistory::InitTempTables()
+{
+  nsresult rv;
+
+  // moz_places_temp
+  rv = mDBConn->ExecuteSimpleSQL(CREATE_MOZ_PLACES_TEMP);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+    "CREATE UNIQUE INDEX moz_places_temp_url_uniqueindex ON moz_places_temp (url)"));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+    "CREATE INDEX moz_places_temp_faviconindex ON moz_places_temp (favicon_id)"));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+    "CREATE INDEX moz_places_temp_hostindex ON moz_places_temp (rev_host)"));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+    "CREATE INDEX moz_places_temp_visitcount ON moz_places_temp (visit_count)"));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+    "CREATE INDEX moz_places_temp_frecencyindex ON moz_places_temp (frecency)"));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = mDBConn->ExecuteSimpleSQL(CREATE_MOZ_PLACES_SYNC_TRIGGER);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+
+  // moz_historyvisits_temp
+  rv = mDBConn->ExecuteSimpleSQL(CREATE_MOZ_HISTORYVISITS_TEMP);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+    "CREATE INDEX moz_historyvisits_temp_placedateindex "
+    "ON moz_historyvisits_temp (place_id, visit_date)"));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+    "CREATE INDEX moz_historyvisits_temp_fromindex "
+    "ON moz_historyvisits_temp (from_visit)"));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+    "CREATE INDEX moz_historyvisits_temp_dateindex "
+    "ON moz_historyvisits_temp (visit_date)"));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = mDBConn->ExecuteSimpleSQL(CREATE_MOZ_HISTORYVISITS_SYNC_TRIGGER);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  return NS_OK;
+}
+
+nsresult
+nsNavHistory::InitViews()
+{
+  nsresult rv;
+
+  // moz_places_view
+  rv = mDBConn->ExecuteSimpleSQL(CREATE_MOZ_PLACES_VIEW);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = mDBConn->ExecuteSimpleSQL(CREATE_PLACES_VIEW_INSERT_TRIGGER);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = mDBConn->ExecuteSimpleSQL(CREATE_PLACES_VIEW_DELETE_TRIGGER);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = mDBConn->ExecuteSimpleSQL(CREATE_PLACES_VIEW_UPDATE_TRIGGER);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // moz_historyvisits_view
+  rv = mDBConn->ExecuteSimpleSQL(CREATE_MOZ_HISTORYVISITS_VIEW);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = mDBConn->ExecuteSimpleSQL(CREATE_HISTORYVISITS_VIEW_INSERT_TRIGGER);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = mDBConn->ExecuteSimpleSQL(CREATE_HISTORYVISITS_VIEW_DELETE_TRIGGER);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = mDBConn->ExecuteSimpleSQL(CREATE_HISTORYVISITS_VIEW_UPDATE_TRIGGER);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  return NS_OK;
+}
+
+nsresult
 nsNavHistory::InitFunctions()
 {
   nsresult rv;
@@ -988,62 +1056,124 @@
   nsresult rv;
 
   // mDBGetURLPageInfo
-  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
-      "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count "
-      "FROM moz_places h "
-      "WHERE h.url = ?1"),
+  // We are not checking for duplicated ids into the unified table
+  // for perf reasons, LIMIT 1 will discard duplicates faster since we
+  // have unique urls.
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT id, url, title, rev_host, visit_count "
+    "FROM moz_places_temp "
+    "WHERE url = ?1 "
+    "UNION ALL "
+    "SELECT id, url, title, rev_host, visit_count "
+    "FROM moz_places "
+    "WHERE url = ?1 "
+    "LIMIT 1"),
     getter_AddRefs(mDBGetURLPageInfo));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // mDBGetIdPageInfo
-  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
-      "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count "
-      "FROM moz_places h WHERE h.id = ?1"),
+  // We are not checking for duplicated ids into the unified table
+  // for perf reasons, LIMIT 1 will discard duplicates faster since we
+  // have unique place ids.
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "SELECT id, url, title, rev_host, visit_count "
+      "FROM moz_places_temp "
+      "WHERE id = ?1 "
+      "UNION ALL "
+      "SELECT id, url, title, rev_host, visit_count "
+      "FROM moz_places "
+      "WHERE id = ?1 "
+      "LIMIT 1"),
     getter_AddRefs(mDBGetIdPageInfo));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // mDBRecentVisitOfURL
-  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
-      "SELECT v.id, v.session "
-      "FROM moz_places h JOIN moz_historyvisits v ON h.id = v.place_id "
-      "WHERE h.url = ?1 "
-      "ORDER BY v.visit_date DESC "
+  // We are not checking for duplicated ids into the unified table
+  // for perf reasons, LIMIT 1 will discard duplicates faster since we
+  // expect visits in temp table being the most recent.
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "SELECT * FROM ( "
+        "SELECT v.id, v.session "
+        "FROM moz_historyvisits_temp v "
+        "WHERE v.place_id = IFNULL((SELECT id FROM moz_places_temp WHERE url = ?1), "
+                                  "(SELECT id FROM moz_places WHERE url = ?1)) "
+        "ORDER BY v.visit_date DESC LIMIT 1 "
+      ") "
+      "UNION ALL "
+      "SELECT * FROM ( "
+        "SELECT v.id, v.session "
+        "FROM moz_historyvisits v "
+        "WHERE v.place_id = IFNULL((SELECT id FROM moz_places_temp WHERE url = ?1), "
+                                  "(SELECT id FROM moz_places WHERE url = ?1)) "
+        "ORDER BY v.visit_date DESC LIMIT 1 "
+      ") "
       "LIMIT 1"),
     getter_AddRefs(mDBRecentVisitOfURL));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // mDBRecentVisitOfPlace
-  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
-      "SELECT id "
-      "FROM moz_historyvisits "
+  // We are not checking for duplicated ids into the unified table
+  // for perf reasons, LIMIT 1 will discard duplicates faster since we
+  // expect visits in temp table being the most recent.  
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "SELECT id FROM moz_historyvisits_temp "
       "WHERE place_id = ?1 "
-      "AND visit_date = ?2 "
-      "AND session = ?3 "
+        "AND visit_date = ?2 "
+        "AND session = ?3 "
+      "UNION ALL "
+      "SELECT id FROM moz_historyvisits "
+      "WHERE place_id = ?1 "
+        "AND visit_date = ?2 "
+        "AND session = ?3 "
       "LIMIT 1"),
     getter_AddRefs(mDBRecentVisitOfPlace));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // mDBInsertVisit
   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
-      "INSERT INTO moz_historyvisits "
-      "(from_visit, place_id, visit_date, visit_type, session) "
+      "INSERT INTO moz_historyvisits_view "
+        "(from_visit, place_id, visit_date, visit_type, session) "
       "VALUES (?1, ?2, ?3, ?4, ?5)"),
     getter_AddRefs(mDBInsertVisit));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // mDBGetPageVisitStats (see InternalAdd)
-  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+  // We are not checking for duplicated ids into the unified table
+  // for perf reasons, LIMIT 1 will discard duplicates faster since we
+  // have unique place ids.
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "SELECT id, visit_count, typed, hidden "
+      "FROM moz_places_temp "
+      "WHERE url = ?1 "
+      "UNION ALL "
       "SELECT id, visit_count, typed, hidden "
       "FROM moz_places "
-      "WHERE url = ?1"),
+      "WHERE url = ?1 "
+      "LIMIT 1"),
     getter_AddRefs(mDBGetPageVisitStats));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // mDBIsPageVisited
-  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
-      "SELECT h.id FROM moz_places h WHERE h.url = ?1 " 
-      "AND EXISTS "
-      "(SELECT id FROM moz_historyvisits WHERE place_id = h.id LIMIT 1)"),
+  // We are not checking for duplicated ids into the unified table
+  // for perf reasons, LIMIT 1 will discard duplicates faster since we
+  // only need to know if a visit exists.
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "SELECT h.id "
+      "FROM moz_places_temp h "
+      "WHERE url = ?1 " 
+        "AND ( "
+          "EXISTS(SELECT id FROM moz_historyvisits_temp WHERE place_id = h.id LIMIT 1) "
+          "OR EXISTS(SELECT id FROM moz_historyvisits WHERE place_id = h.id LIMIT 1) "
+        ") "
+      "UNION ALL "
+      "SELECT h.id "
+      "FROM moz_places h "
+      "WHERE url = ?1 "
+      "AND ( "
+        "EXISTS(SELECT id FROM moz_historyvisits_temp WHERE place_id = h.id LIMIT 1) "
+        "OR EXISTS(SELECT id FROM moz_historyvisits WHERE place_id = h.id LIMIT 1) "
+      ") "
+      "LIMIT 1"), 
     getter_AddRefs(mDBIsPageVisited));
   NS_ENSURE_SUCCESS(rv, rv);
 
@@ -1051,7 +1181,7 @@
   // we don't need to update visit_count since it's maintained
   // in sync by triggers, and we must NEVER touch it
   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
-      "UPDATE moz_places "
+      "UPDATE moz_places_view "
       "SET hidden = ?2, typed = ?3 "
       "WHERE id = ?1"),
     getter_AddRefs(mDBUpdatePageVisitStats));
@@ -1059,78 +1189,42 @@
 
   // mDBAddNewPage (see InternalAddNewPage)
   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
-      "INSERT OR REPLACE INTO moz_places "
-      "(url, title, rev_host, hidden, typed, frecency) "
+      "INSERT OR REPLACE INTO moz_places_view "
+        "(url, title, rev_host, hidden, typed, frecency) "
       "VALUES (?1, ?2, ?3, ?4, ?5, ?6)"),
     getter_AddRefs(mDBAddNewPage));
   NS_ENSURE_SUCCESS(rv, rv);
 
-  // mDBVisitToURLResult, should match kGetInfoIndex_* (see GetQueryResults)
-  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
-      "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, "
-        SQL_STR_FRAGMENT_MAX_VISIT_DATE( "h.id" )
-        ", f.url, null, null "
-      "FROM moz_places h "
-      "JOIN moz_historyvisits v ON h.id = v.place_id "
-      "LEFT OUTER JOIN moz_favicons f ON h.favicon_id = f.id "
-      "WHERE v.id = ?1"),
-    getter_AddRefs(mDBVisitToURLResult));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  // mDBVisitToVisitResult, should match kGetInfoIndex_* (see GetQueryResults)
-  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
-      "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, "
-             "v.visit_date, f.url, v.session, null "
-      "FROM moz_places h "
-      "JOIN moz_historyvisits v ON h.id = v.place_id "
-      "LEFT OUTER JOIN moz_favicons f ON h.favicon_id = f.id "
-      "WHERE v.id = ?1"),
-    getter_AddRefs(mDBVisitToVisitResult));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  // mDBUrlToURLResult, should match kGetInfoIndex_*
-  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
-      "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, "
-        SQL_STR_FRAGMENT_MAX_VISIT_DATE( "h.id" )
-        ", f.url, null, null "
-      "FROM moz_places h "
-      "LEFT OUTER JOIN moz_favicons f ON h.favicon_id = f.id "
-      "WHERE h.url = ?1"),
-    getter_AddRefs(mDBUrlToUrlResult));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  // mDBBookmarkToUrlResult, should match kGetInfoIndex_*
-  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
-      "SELECT b.fk, h.url, COALESCE(b.title, h.title), "
-        "h.rev_host, h.visit_count, "
-        SQL_STR_FRAGMENT_MAX_VISIT_DATE( "b.fk" )
-        ", f.url, null, b.id, b.dateAdded, b.lastModified "
+  // mDBGetTags
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "SELECT GROUP_CONCAT(t.title, ' ') "
       "FROM moz_bookmarks b "
-      "JOIN moz_places h ON b.fk = h.id "
-      "LEFT OUTER JOIN moz_favicons f ON h.favicon_id = f.id "
-      "WHERE b.id = ?1"),
-    getter_AddRefs(mDBBookmarkToUrlResult));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  // mDBGetTags
-  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
-      "SELECT GROUP_CONCAT(t.title, ' ') "
-      "FROM moz_places h "
-      "JOIN moz_bookmarks b ON b.type = ") +
-        nsPrintfCString("%d", nsINavBookmarksService::TYPE_BOOKMARK) +
-        NS_LITERAL_CSTRING(" AND b.fk = h.id "
-      "JOIN moz_bookmarks t ON t.parent = ?1 AND t.id = b.parent "
-      "WHERE h.url = ?2"),
+      "JOIN moz_bookmarks t ON t.id = b.parent "
+      "WHERE b.fk = IFNULL((SELECT id FROM moz_places_temp WHERE url = ?2), "
+                          "(SELECT id FROM moz_places WHERE url = ?2)) "
+        "AND b.type = ") +
+          nsPrintfCString("%d", nsINavBookmarksService::TYPE_BOOKMARK) +
+        NS_LITERAL_CSTRING(" AND t.parent = ?1 "),
     getter_AddRefs(mDBGetTags));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // mFoldersWithAnnotationQuery
   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
-    "SELECT annos.item_id, annos.content FROM moz_anno_attributes attrs " 
-    "JOIN moz_items_annos annos ON attrs.id = annos.anno_attribute_id "
-    "WHERE attrs.name = ?1"), 
+    "SELECT a.item_id, a.content "
+    "FROM moz_anno_attributes n "
+    "JOIN moz_items_annos a ON n.id = a.anno_attribute_id "
+    "WHERE n.name = ?1"), 
     getter_AddRefs(mFoldersWithAnnotationQuery));
   NS_ENSURE_SUCCESS(rv, rv);
+
+  // mDBSetPlaceTitle
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "UPDATE moz_places_view "
+      "SET title = ?1 "
+      "WHERE url = ?2"),
+    getter_AddRefs(mDBSetPlaceTitle));
+  NS_ENSURE_SUCCESS(rv, rv);
+
 
   // mDBVisitsForFrecency
   // NOTE: we are not limiting to visits with "visit_type NOT IN (0,4,7)"
@@ -1141,82 +1235,64 @@
   // for a place with only embedded visits, instead of a frecency of 0. If we
   // have a temporary or permanent redirect, calculate the frecency as if it
   // was the original page visited.
-  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
-    "SELECT IFNULL(r.visit_date, v.visit_date) date, IFNULL(r.visit_type, v.visit_type) "
-    "FROM moz_historyvisits v "
-    "LEFT OUTER JOIN moz_historyvisits r "
-      "ON r.id = v.from_visit AND v.visit_type IN ") +
-      nsPrintfCString("(%d,%d) ", TRANSITION_REDIRECT_PERMANENT,
-      TRANSITION_REDIRECT_TEMPORARY) + NS_LITERAL_CSTRING(
-    "WHERE v.place_id = ?1 ORDER BY date DESC LIMIT ") +
-     nsPrintfCString("%d", mNumVisitsForFrecency),
+
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "SELECT COALESCE(r_t.visit_date, r.visit_date, v.visit_date) date, "
+        "COALESCE(r_t.visit_type, r.visit_type, v.visit_type) "
+      "FROM ( "
+        "SELECT visit_date, visit_type, from_visit FROM moz_historyvisits_temp "
+        "WHERE place_id = ?1 "
+        "UNION ALL "
+        "SELECT visit_date, visit_type, from_visit FROM moz_historyvisits "
+        "WHERE id NOT IN (SELECT id FROM moz_historyvisits_temp) "
+        "AND place_id = ?1 "
+      ") AS v "
+      "LEFT JOIN moz_historyvisits r ON r.id = v.from_visit "
+        "AND v.visit_type IN ") +
+          nsPrintfCString("(%d,%d) ", TRANSITION_REDIRECT_PERMANENT,
+            TRANSITION_REDIRECT_TEMPORARY) + NS_LITERAL_CSTRING(
+      "LEFT JOIN moz_historyvisits_temp r_t ON r_t.id = v.from_visit "
+        "AND v.visit_type IN ") +
+          nsPrintfCString("(%d,%d) ", TRANSITION_REDIRECT_PERMANENT,
+            TRANSITION_REDIRECT_TEMPORARY) + NS_LITERAL_CSTRING(
+      "ORDER BY date DESC LIMIT ") +
+        nsPrintfCString("%d", mNumVisitsForFrecency),
     getter_AddRefs(mDBVisitsForFrecency));
   NS_ENSURE_SUCCESS(rv, rv);
 
-  // find places with invalid frecencies (frecency < 0)
-  // invalid frecencies can happen in these scenarios:
-  // 1) we've done "clear private data"
-  // 2) we've expired or deleted visits
-  // 3) we've migrated from an older version, before global frecency
-  //
-  // from older versions, unmigrated bookmarks might be hidden,
-  // so we can't exclude hidden places (by doing "WHERE hidden <> 1")
-  // from our query, as we want to calculate the frecency for those
-  // places and unhide them (if they are not livemark items and not
-  // place: queries.)
-  //
-  // Note, we are not limiting ourselves to places with visits
-  // because we may not have any if the place is a bookmark and
-  // we expired or deleted all the visits. 
-  // We get two sets of places that are 1) most visited and 2) random so that
-  // we don't get stuck recalculating frecencies that end up being -1 every
-  // time
-  // Notice that frecency is invalidated as frecency = -visit_count
-  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
-    "SELECT * FROM "
-      "(SELECT id, visit_count, hidden, typed, frecency, url "
-      "FROM moz_places WHERE frecency < 0 "
-      "ORDER BY frecency ASC LIMIT ROUND(?1 / 2)) "
-    "UNION "
-    "SELECT * FROM "
-      "(SELECT id, visit_count, hidden, typed, frecency, url "
-      "FROM moz_places WHERE frecency < 0 "
-      "ORDER BY RANDOM() LIMIT ROUND(?1 / 2))"),
-    getter_AddRefs(mDBInvalidFrecencies));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  // This query finds random old places to update frecency because frequently
-  // visited places will have their frecencies updated when visited
-  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
-    "SELECT id, visit_count, hidden, typed, frecency, url "
-     "FROM moz_places "
-     "ORDER BY RANDOM() LIMIT ?1"),
-    getter_AddRefs(mDBOldFrecencies));
-  NS_ENSURE_SUCCESS(rv, rv);
-
   // mDBUpdateFrecencyAndHidden
   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
-      "UPDATE moz_places SET frecency = ?2, hidden = ?3 WHERE id = ?1"),
+      "UPDATE moz_places_view SET frecency = ?2, hidden = ?3 WHERE id = ?1"),
     getter_AddRefs(mDBUpdateFrecencyAndHidden));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // mDBGetPlaceVisitStats
-  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
-      "SELECT typed, hidden, frecency FROM moz_places WHERE id = ?1"),
+  // We are not checking for duplicated ids into the unified table
+  // for perf reasons, LIMIT 1 will discard duplicates faster since we
+  // have unique place ids.
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "SELECT typed, hidden, frecency "
+      "FROM moz_places_temp WHERE id = ?1 "
+      "UNION ALL "
+      "SELECT typed, hidden, frecency "
+      "FROM moz_places WHERE id = ?1 "
+      "LIMIT 1"),
     getter_AddRefs(mDBGetPlaceVisitStats));
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
-      "SELECT b.parent FROM moz_places h JOIN moz_bookmarks b "
-      " on b.fk = h.id WHERE b.type = 1 and h.id = ?1"),
+      "SELECT b.parent FROM moz_bookmarks b "
+      "WHERE b.type = 1 AND b.fk = ?1"),
     getter_AddRefs(mDBGetBookmarkParentsForPlace));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // when calculating frecency, we want the visit count to be 
   // all the visits.
-  rv = mDBConn->CreateStatement(
-    NS_LITERAL_CSTRING("SELECT COUNT(*) FROM moz_historyvisits " 
-      "WHERE place_id = ?1"),
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "SELECT "
+        "(SELECT COUNT(*) FROM moz_historyvisits WHERE place_id = ?1) + "
+        "(SELECT COUNT(*) FROM moz_historyvisits_temp WHERE place_id = ?1 "
+            "AND id NOT IN (SELECT id FROM moz_historyvisits))"),
     getter_AddRefs(mDBFullVisitCount));
   NS_ENSURE_SUCCESS(rv, rv);
 
@@ -1235,13 +1311,17 @@
 nsNavHistory::ForceMigrateBookmarksDB(mozIStorageConnection* aDBConn) 
 {
   // drop bookmarks tables
-  nsresult rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING("DROP TABLE IF EXISTS moz_bookmarks"));
-  NS_ENSURE_SUCCESS(rv, rv);
-  rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING("DROP TABLE IF EXISTS moz_bookmarks_folders"));
-  NS_ENSURE_SUCCESS(rv, rv);
-  rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING("DROP TABLE IF EXISTS moz_bookmarks_roots"));
-  NS_ENSURE_SUCCESS(rv, rv);
-  rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING("DROP TABLE IF EXISTS moz_keywords"));
+  nsresult rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "DROP TABLE IF EXISTS moz_bookmarks"));
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "DROP TABLE IF EXISTS moz_bookmarks_folders"));
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "DROP TABLE IF EXISTS moz_bookmarks_roots"));
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "DROP TABLE IF EXISTS moz_keywords"));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // initialize bookmarks tables
@@ -1263,17 +1343,19 @@
   // if type col is already there, then a partial update occurred.
   // return, making no changes, and allowing db version to be updated.
   nsCOMPtr<mozIStorageStatement> statement;
-  nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING("SELECT type from moz_annos"),
-                                         getter_AddRefs(statement));
+  nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "SELECT type from moz_annos"),
+    getter_AddRefs(statement));
   if (NS_SUCCEEDED(rv))
     return NS_OK;
 
   // add type column to moz_annos
   rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
-    "ALTER TABLE moz_annos ADD type INTEGER DEFAULT 0"));
+      "ALTER TABLE moz_annos ADD type INTEGER DEFAULT 0"));
   if (NS_FAILED(rv)) {
     // if the alteration failed, force-migrate
-    rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING("DROP TABLE IF EXISTS moz_annos"));
+    rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+        "DROP TABLE IF EXISTS moz_annos"));
     NS_ENSURE_SUCCESS(rv, rv);
     rv = nsAnnotationService::InitTables(mDBConn);
     NS_ENSURE_SUCCESS(rv, rv);
@@ -1292,30 +1374,30 @@
   // and so we should not attempt to add these cols.
   nsCOMPtr<mozIStorageStatement> statement;
   nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
-    "SELECT a.dateAdded, a.lastModified FROM moz_annos a"), 
+      "SELECT a.dateAdded, a.lastModified FROM moz_annos a"), 
     getter_AddRefs(statement));
   if (NS_FAILED(rv)) {
     // add dateAdded and lastModified columns to moz_annos
     rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
-      "ALTER TABLE moz_annos ADD dateAdded INTEGER DEFAULT 0"));
-    NS_ENSURE_SUCCESS(rv, rv);
-    rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
-      "ALTER TABLE moz_annos ADD lastModified INTEGER DEFAULT 0"));
+        "ALTER TABLE moz_annos ADD dateAdded INTEGER DEFAULT 0"));
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+        "ALTER TABLE moz_annos ADD lastModified INTEGER DEFAULT 0"));
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   // if dateAdded & lastModified cols are already there, then a partial update occurred,
   // and so we should not attempt to add these cols.  see bug #408443 for details.
   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
-    "SELECT b.dateAdded, b.lastModified FROM moz_items_annos b"), 
+      "SELECT b.dateAdded, b.lastModified FROM moz_items_annos b"), 
     getter_AddRefs(statement));
   if (NS_FAILED(rv)) {
     // add dateAdded and lastModified columns to moz_items_annos
     rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
-      "ALTER TABLE moz_items_annos ADD dateAdded INTEGER DEFAULT 0"));
-    NS_ENSURE_SUCCESS(rv, rv);
-    rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
-      "ALTER TABLE moz_items_annos ADD lastModified INTEGER DEFAULT 0"));
+        "ALTER TABLE moz_items_annos ADD dateAdded INTEGER DEFAULT 0"));
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+        "ALTER TABLE moz_items_annos ADD lastModified INTEGER DEFAULT 0"));
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
@@ -1323,11 +1405,11 @@
   // moz_anno_attributes.name, but those indexes are not needed
   // because those columns are UNIQUE, so remove them.
   // see bug #386303 for more details
-  rv = aDBConn->ExecuteSimpleSQL(
-    NS_LITERAL_CSTRING("DROP INDEX IF EXISTS moz_favicons_url"));
-  NS_ENSURE_SUCCESS(rv, rv);
-  rv = aDBConn->ExecuteSimpleSQL(
-    NS_LITERAL_CSTRING("DROP INDEX IF EXISTS moz_anno_attributes_nameindex"));
+  rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "DROP INDEX IF EXISTS moz_favicons_url"));
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "DROP INDEX IF EXISTS moz_anno_attributes_nameindex"));
   NS_ENSURE_SUCCESS(rv, rv);
 
   return transaction.Commit();
@@ -1338,15 +1420,35 @@
 nsNavHistory::MigrateV7Up(mozIStorageConnection* aDBConn) 
 {
   mozStorageTransaction transaction(aDBConn, PR_FALSE);
+
+  // Temporary migration code for bug 396300
+  nsNavBookmarks* bookmarks = nsNavBookmarks::GetBookmarksService();
+  NS_ENSURE_TRUE(bookmarks, NS_ERROR_OUT_OF_MEMORY);
+  PRInt64 unfiledFolder, rootFolder;
+  bookmarks->GetUnfiledBookmarksFolder(&unfiledFolder);
+  bookmarks->GetPlacesRoot(&rootFolder);
+
+  nsCOMPtr<mozIStorageStatement> moveUnfiledBookmarks;
+  nsresult rv = aDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "UPDATE moz_bookmarks SET parent = ?1 WHERE type = ?2 AND parent=?3"),
+    getter_AddRefs(moveUnfiledBookmarks));
+  rv = moveUnfiledBookmarks->BindInt64Parameter(0, unfiledFolder);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = moveUnfiledBookmarks->BindInt32Parameter(1, nsINavBookmarksService::TYPE_BOOKMARK);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = moveUnfiledBookmarks->BindInt64Parameter(2, rootFolder);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = moveUnfiledBookmarks->Execute();
+  NS_ENSURE_SUCCESS(rv, rv);
 
   // Create a statement to test for trigger creation
   nsCOMPtr<mozIStorageStatement> triggerDetection;
-  nsresult rv = aDBConn->CreateStatement(NS_LITERAL_CSTRING(
-    "SELECT name "
-    "FROM sqlite_master "
-    "WHERE type = 'trigger' "
-    "AND name = ?"
-  ), getter_AddRefs(triggerDetection));
+  rv = aDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "SELECT name "
+      "FROM sqlite_master "
+      "WHERE type = 'trigger' "
+      "AND name = ?"),
+    getter_AddRefs(triggerDetection));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // Check for existence
@@ -1367,18 +1469,19 @@
   if (!triggerExists) {
     // First, we do a one-time reset of all the moz_places.visit_count values.
     rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
-      "UPDATE moz_places SET visit_count = "
-        "(SELECT count(*) FROM moz_historyvisits "
-         "WHERE place_id = moz_places.id "
-         "AND visit_type NOT IN (0, 4, 7))") /* invalid, EMBED, DOWNLOAD */
-    );
-    NS_ENSURE_SUCCESS(rv, rv);
-
-    // Now we create our two triggers
-    rv = aDBConn->ExecuteSimpleSQL(CREATE_VISIT_COUNT_INSERT_TRIGGER);
-    NS_ENSURE_SUCCESS(rv, rv);
-    rv = aDBConn->ExecuteSimpleSQL(CREATE_VISIT_COUNT_DELETE_TRIGGER);
-    NS_ENSURE_SUCCESS(rv, rv);
+        "UPDATE moz_places SET visit_count = "
+          "(SELECT count(*) FROM moz_historyvisits "
+           "WHERE place_id = moz_places.id "
+            "AND visit_type NOT IN ") +
+              nsPrintfCString("(0,%d,%d) ",
+                              nsINavHistoryService::TRANSITION_EMBED,
+                              nsINavHistoryService::TRANSITION_DOWNLOAD) +
+          NS_LITERAL_CSTRING(")"));
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    // We used to create two triggers here, but we no longer need that with
+    // schema version eight and greater.  We've removed their creation here as
+    // a result.
   }
 
   // Check for existence
@@ -1396,15 +1499,14 @@
   if (!triggerExists) {
     // First, remove any existing dangling keywords
     rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
-      "DELETE FROM moz_keywords "
-      "WHERE id IN ("
-        "SELECT k.id "
-        "FROM moz_keywords k "
-        "LEFT OUTER JOIN moz_bookmarks b "
-        "ON b.keyword_id = k.id "
-        "WHERE b.id IS NULL"
-      ")")
-    );
+        "DELETE FROM moz_keywords "
+        "WHERE id IN ("
+          "SELECT k.id "
+          "FROM moz_keywords k "
+          "LEFT OUTER JOIN moz_bookmarks b "
+          "ON b.keyword_id = k.id "
+          "WHERE b.id IS NULL"
+        ")"));
     NS_ENSURE_SUCCESS(rv, rv);
 
     // Now we create our trigger
@@ -1412,6 +1514,22 @@
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
+  return transaction.Commit();
+}
+
+nsresult
+nsNavHistory::MigrateV8Up(mozIStorageConnection *aDBConn)
+{
+  mozStorageTransaction transaction(aDBConn, PR_FALSE);
+
+  nsresult rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "DROP TRIGGER IF EXISTS moz_historyvisits_afterinsert_v1_trigger"));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "DROP TRIGGER IF EXISTS moz_historyvisits_afterdelete_v1_trigger"));
+  NS_ENSURE_SUCCESS(rv, rv);
+  
   return transaction.Commit();
 }
 
@@ -1464,7 +1582,8 @@
   // for existing profiles, we may not have a frecency column
   nsCOMPtr<mozIStorageStatement> statement;
   rv = aDBConn->CreateStatement(NS_LITERAL_CSTRING(
-    "SELECT frecency FROM moz_places"), getter_AddRefs(statement));
+      "SELECT frecency FROM moz_places"),
+    getter_AddRefs(statement));
 
   if (NS_FAILED(rv)) {
     *aDidMigrate = PR_TRUE;
@@ -1475,14 +1594,14 @@
     // so that all the frecencies are invalid and we'll
     // recalculate them on idle.
     rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
-      "ALTER TABLE moz_places ADD frecency INTEGER DEFAULT -1 NOT NULL"));
+        "ALTER TABLE moz_places ADD frecency INTEGER DEFAULT -1 NOT NULL"));
     NS_ENSURE_SUCCESS(rv, rv);
 
     // create index for the frecency column
     // XXX multi column index with typed, and visit_count?
     rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
-      "CREATE INDEX IF NOT EXISTS "
-      "moz_places_frecencyindex ON moz_places (frecency)"));
+        "CREATE INDEX IF NOT EXISTS moz_places_frecencyindex "
+          "ON moz_places (frecency)"));
     NS_ENSURE_SUCCESS(rv, rv);
 
     // XXX todo
@@ -1508,29 +1627,30 @@
   // test for moz_places.user_title
   nsCOMPtr<mozIStorageStatement> statement2;
   nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
-    "SELECT user_title FROM moz_places"), getter_AddRefs(statement2));
+      "SELECT user_title FROM moz_places"),
+    getter_AddRefs(statement2));
   if (NS_SUCCEEDED(rv)) {
     mozStorageTransaction transaction(mDBConn, PR_FALSE);
     // 1. Indexes are moved along with the renamed table. Since we're dropping
     // that table, we're also dropping its indexes, and later re-creating them
     // for the new table.
-    rv = mDBConn->ExecuteSimpleSQL(
-        NS_LITERAL_CSTRING("DROP INDEX IF EXISTS moz_places_urlindex"));
-    NS_ENSURE_SUCCESS(rv, rv);
-    rv = mDBConn->ExecuteSimpleSQL(
-        NS_LITERAL_CSTRING("DROP INDEX IF EXISTS moz_places_titleindex"));
-    NS_ENSURE_SUCCESS(rv, rv);
-    rv = mDBConn->ExecuteSimpleSQL(
-        NS_LITERAL_CSTRING("DROP INDEX IF EXISTS moz_places_faviconindex"));
-    NS_ENSURE_SUCCESS(rv, rv);
-    rv = mDBConn->ExecuteSimpleSQL(
-        NS_LITERAL_CSTRING("DROP INDEX IF EXISTS moz_places_hostindex"));
-    NS_ENSURE_SUCCESS(rv, rv);
-    rv = mDBConn->ExecuteSimpleSQL(
-        NS_LITERAL_CSTRING("DROP INDEX IF EXISTS moz_places_visitcount"));
-    NS_ENSURE_SUCCESS(rv, rv);
-    rv = mDBConn->ExecuteSimpleSQL(
-        NS_LITERAL_CSTRING("DROP INDEX IF EXISTS moz_places_frecencyindex"));
+    rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+        "DROP INDEX IF EXISTS moz_places_urlindex"));
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+        "DROP INDEX IF EXISTS moz_places_titleindex"));
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+        "DROP INDEX IF EXISTS moz_places_faviconindex"));
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+        "DROP INDEX IF EXISTS moz_places_hostindex"));
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+        "DROP INDEX IF EXISTS moz_places_visitcount"));
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+        "DROP INDEX IF EXISTS moz_places_frecencyindex"));
     NS_ENSURE_SUCCESS(rv, rv);
 
     // 2. remove any duplicate URIs
@@ -1538,90 +1658,95 @@
     NS_ENSURE_SUCCESS(rv, rv);
 
     // 3. rename moz_places to moz_places_backup
-    rv = mDBConn->ExecuteSimpleSQL(
-      NS_LITERAL_CSTRING("ALTER TABLE moz_places RENAME TO moz_places_backup"));
+    rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+        "ALTER TABLE moz_places RENAME TO moz_places_backup"));
     NS_ENSURE_SUCCESS(rv, rv);
 
     // 4. create moz_places w/o user_title
-    rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING("CREATE TABLE moz_places ("
-        "id INTEGER PRIMARY KEY, "
-        "url LONGVARCHAR, "
-        "title LONGVARCHAR, "
-        "rev_host LONGVARCHAR, "
-        "visit_count INTEGER DEFAULT 0, "
-        "hidden INTEGER DEFAULT 0 NOT NULL, "
-        "typed INTEGER DEFAULT 0 NOT NULL, "
-        "favicon_id INTEGER, "
-        "frecency INTEGER DEFAULT -1 NOT NULL)"));
+    rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+        "CREATE TABLE moz_places ("
+          "id INTEGER PRIMARY KEY, "
+          "url LONGVARCHAR, "
+          "title LONGVARCHAR, "
+          "rev_host LONGVARCHAR, "
+          "visit_count INTEGER DEFAULT 0, "
+          "hidden INTEGER DEFAULT 0 NOT NULL, "
+          "typed INTEGER DEFAULT 0 NOT NULL, "
+          "favicon_id INTEGER, "
+          "frecency INTEGER DEFAULT -1 NOT NULL)"));
     NS_ENSURE_SUCCESS(rv, rv);
 
     // 5. recreate the indexes
     // NOTE: tests showed that it's faster to create the indexes prior to filling
     // the table than it is to add them afterwards.
-    rv = mDBConn->ExecuteSimpleSQL(
-        NS_LITERAL_CSTRING("CREATE UNIQUE INDEX moz_places_url_uniqueindex ON moz_places (url)"));
-    NS_ENSURE_SUCCESS(rv, rv);
-    rv = mDBConn->ExecuteSimpleSQL(
-        NS_LITERAL_CSTRING("CREATE INDEX moz_places_faviconindex ON moz_places (favicon_id)"));
-    NS_ENSURE_SUCCESS(rv, rv);
-    rv = mDBConn->ExecuteSimpleSQL(
-        NS_LITERAL_CSTRING("CREATE INDEX moz_places_hostindex ON moz_places (rev_host)"));
-    NS_ENSURE_SUCCESS(rv, rv);
-    rv = mDBConn->ExecuteSimpleSQL(
-        NS_LITERAL_CSTRING("CREATE INDEX moz_places_visitcount ON moz_places (visit_count)"));
-    NS_ENSURE_SUCCESS(rv, rv);
-    rv = mDBConn->ExecuteSimpleSQL(
-        NS_LITERAL_CSTRING("CREATE INDEX moz_places_frecencyindex ON moz_places (frecency)"));
+    rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+        "CREATE UNIQUE INDEX moz_places_url_uniqueindex ON moz_places (url)"));
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+        "CREATE INDEX moz_places_faviconindex ON moz_places (favicon_id)"));
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+        "CREATE INDEX moz_places_hostindex ON moz_places (rev_host)"));
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+        "CREATE INDEX moz_places_visitcount ON moz_places (visit_count)"));
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+        "CREATE INDEX moz_places_frecencyindex ON moz_places (frecency)"));
     NS_ENSURE_SUCCESS(rv, rv);
 
     // 6. copy all data into moz_places
     rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
-      "INSERT INTO moz_places "
-      "SELECT id, url, title, rev_host, visit_count, hidden, typed, favicon_id, frecency "
-      "FROM moz_places_backup"));
+        "INSERT INTO moz_places "
+        "SELECT id, url, title, rev_host, visit_count, hidden, typed, "
+          "favicon_id, frecency "
+        "FROM moz_places_backup"));
     NS_ENSURE_SUCCESS(rv, rv);
 
     // 7. drop moz_places_backup
     rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
-      "DROP TABLE moz_places_backup"));
+        "DROP TABLE moz_places_backup"));
     NS_ENSURE_SUCCESS(rv, rv);
     transaction.Commit();
   }
 
   // bug #381795 - remove unused indexes
   mozStorageTransaction idxTransaction(mDBConn, PR_FALSE);
-  rv = mDBConn->ExecuteSimpleSQL(
-    NS_LITERAL_CSTRING("DROP INDEX IF EXISTS moz_places_titleindex"));
-  rv = mDBConn->ExecuteSimpleSQL(
-    NS_LITERAL_CSTRING("DROP INDEX IF EXISTS moz_annos_item_idindex"));
+  rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "DROP INDEX IF EXISTS moz_places_titleindex"));
+  rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "DROP INDEX IF EXISTS moz_annos_item_idindex"));
   idxTransaction.Commit();
 
   // Do a one-time re-creation of the moz_annos indexes (bug 415201)
   PRBool oldIndexExists = PR_FALSE;
-  rv = mDBConn->IndexExists(NS_LITERAL_CSTRING("moz_annos_attributesindex"), &oldIndexExists);
+  rv = mDBConn->IndexExists(NS_LITERAL_CSTRING("moz_annos_attributesindex"),
+                            &oldIndexExists);
   NS_ENSURE_SUCCESS(rv, rv);
   if (oldIndexExists) {
     // wrap in a transaction for safety and performance
     mozStorageTransaction annoIndexTransaction(mDBConn, PR_FALSE);
 
     // drop old uri annos index
-    rv = mDBConn->ExecuteSimpleSQL(
-        NS_LITERAL_CSTRING("DROP INDEX moz_annos_attributesindex"));
+    rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+        "DROP INDEX moz_annos_attributesindex"));
     NS_ENSURE_SUCCESS(rv, rv);
 
     // create new uri annos index
-    rv = mDBConn->ExecuteSimpleSQL(
-      NS_LITERAL_CSTRING("CREATE UNIQUE INDEX moz_annos_placeattributeindex ON moz_annos (place_id, anno_attribute_id)"));
+    rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+        "CREATE UNIQUE INDEX moz_annos_placeattributeindex "
+          "ON moz_annos (place_id, anno_attribute_id)"));
     NS_ENSURE_SUCCESS(rv, rv);
 
     // drop old item annos index
-    rv = mDBConn->ExecuteSimpleSQL(
-        NS_LITERAL_CSTRING("DROP INDEX IF EXISTS moz_items_annos_attributesindex"));
+    rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+        "DROP INDEX IF EXISTS moz_items_annos_attributesindex"));
     NS_ENSURE_SUCCESS(rv, rv);
 
     // create new item annos index
-    rv = mDBConn->ExecuteSimpleSQL(
-      NS_LITERAL_CSTRING("CREATE UNIQUE INDEX moz_items_annos_itemattributeindex ON moz_items_annos (item_id, anno_attribute_id)"));
+    rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "CREATE UNIQUE INDEX moz_items_annos_itemattributeindex "
+        "ON moz_items_annos (item_id, anno_attribute_id)"));
     NS_ENSURE_SUCCESS(rv, rv);
 
     rv = annoIndexTransaction.Commit();
@@ -1807,6 +1932,7 @@
 
     *visitID = mDBRecentVisitOfPlace->AsInt64(0);
   }
+
   return NS_OK;
 }
 
@@ -2338,9 +2464,11 @@
   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
 
   nsCOMPtr<mozIStorageStatement> dbSelectStatement;
-  nsresult rv = mDBConn->CreateStatement(
-      NS_LITERAL_CSTRING("SELECT id FROM moz_historyvisits LIMIT 1"),
-      getter_AddRefs(dbSelectStatement));
+  nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "SELECT 1 "
+      "WHERE EXISTS (SELECT id FROM moz_historyvisits_temp LIMIT 1) "
+        "OR EXISTS (SELECT id FROM moz_historyvisits LIMIT 1)"),
+    getter_AddRefs(dbSelectStatement));
   NS_ENSURE_SUCCESS(rv, rv);
   return dbSelectStatement->ExecuteStep(aHasEntries);
 }
@@ -2353,18 +2481,25 @@
   // set frecency to 0 so that it is excluded from url bar autocomplete.
   nsCOMPtr<mozIStorageStatement> dbUpdateStatement;
   nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
-    "UPDATE moz_places "
-    "SET frecency = 0 WHERE id IN ("
-      "SELECT h.id FROM moz_places h "
-      "LEFT OUTER JOIN moz_bookmarks b ON h.id = b.fk "
-      "WHERE frecency < 0 AND "
-        // place is an unvisited child of a livemark feed
-        "(b.parent IN ("
-            "SELECT annos.item_id FROM moz_anno_attributes attrs "
-            "JOIN moz_items_annos annos ON attrs.id = annos.anno_attribute_id "
-            "WHERE attrs.name = ?1) "
-          "AND visit_count = 0) "
-        "OR SUBSTR(h.url,0,6) = 'place:')"),
+      "UPDATE moz_places_view "
+      "SET frecency = 0 WHERE id IN ("
+        "SELECT h.id FROM moz_places h "
+        "WHERE h.url >= 'place:' AND h.url < 'place;' "
+        "UNION "
+        "SELECT h.id FROM moz_places_temp h "
+        "WHERE  h.url >= 'place:' AND h.url < 'place;' "
+        "UNION "
+        // Unvisited child of a livemark        
+        "SELECT b.fk FROM moz_bookmarks b "
+        "JOIN moz_items_annos a ON a.item_id = b.id "
+        "JOIN moz_anno_attributes n ON n.id = a.anno_attribute_id "
+        "WHERE n.name = ?1 "
+        "AND fk IN( "
+          "SELECT id FROM moz_places WHERE visit_count = 0 AND frecency < 0 "
+          "UNION ALL "
+          "SELECT id FROM moz_places_temp WHERE visit_count = 0 AND frecency < 0 "
+        ") "
+      ")"),
     getter_AddRefs(dbUpdateStatement));
   NS_ENSURE_SUCCESS(rv, rv);
 
@@ -2982,19 +3117,160 @@
   switch (mQueryType)
   {
     case nsINavHistoryQueryOptions::QUERY_TYPE_HISTORY:
-      mQueryString = NS_LITERAL_CSTRING(
-        "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, "
-          "MAX(visit_date), f.url, null, null "
-        "FROM moz_places h "
-             "LEFT OUTER JOIN moz_historyvisits v ON h.id = v.place_id "
-             "LEFT OUTER JOIN moz_favicons f ON h.favicon_id = f.id ");
-
-      if (!mIncludeHidden)
-        mQueryString += NS_LITERAL_CSTRING(
-          " WHERE h.hidden <> 1 AND v.visit_type NOT IN (0,4)"
-            " {ADDITIONAL_CONDITIONS} ");
-
-      mGroupBy = NS_LITERAL_CSTRING(" GROUP BY h.id");
+      if (!mIncludeHidden) {
+        mQueryString = NS_LITERAL_CSTRING(
+          "SELECT id, url, title, rev_host, visit_count, MAX(visit_date), "
+            "favicon_url, session, empty "
+          "FROM ( "
+            "SELECT id, url, title, rev_host, visit_count, visit_date, "
+              "favicon_url, session, empty "
+            "FROM ("
+              "SELECT h.id AS id, h.url AS url, h.title AS title, "
+                "h.rev_host AS rev_host, h.visit_count AS visit_count, "
+                "MAX(v.visit_date) AS visit_date, f.url AS favicon_url, "
+                "v.session AS session, null AS empty "
+              "FROM moz_places h "
+              "JOIN moz_historyvisits v ON h.id = v.place_id "
+              "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
+              "WHERE h.hidden <> 1 AND v.visit_type NOT IN ") +
+                nsPrintfCString("(0,%d,%d) ",
+                                nsINavHistoryService::TRANSITION_EMBED,
+                                nsINavHistoryService::TRANSITION_DOWNLOAD) +
+                NS_LITERAL_CSTRING("AND h.visit_count > 0 "
+                "{ADDITIONAL_CONDITIONS} "
+              "GROUP BY h.id "
+            ") "
+            "UNION ALL "
+            "SELECT id, url, title, rev_host, visit_count, visit_date, "
+              "favicon_url, session, empty "
+            "FROM ( "
+              "SELECT h.id AS id, h.url AS url, h.title AS title, "
+                "h.rev_host AS rev_host, h.visit_count AS visit_count, "
+                "MAX(v.visit_date) AS visit_date, f.url AS favicon_url, "
+                "v.session AS session, null AS empty "
+              "FROM moz_places_temp h "
+              "JOIN moz_historyvisits v ON h.id = v.place_id "
+              "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
+              "WHERE h.hidden <> 1 AND v.visit_type NOT IN ") +
+                nsPrintfCString("(0,%d,%d) ",
+                                nsINavHistoryService::TRANSITION_EMBED,
+                                nsINavHistoryService::TRANSITION_DOWNLOAD) +
+                NS_LITERAL_CSTRING("AND h.visit_count > 0 "
+                "AND h.id NOT IN (SELECT id FROM moz_places_temp) "
+                "{ADDITIONAL_CONDITIONS} "
+              "GROUP BY h.id "
+            ") "
+            "UNION ALL "
+            "SELECT id, url, title, rev_host, visit_count, visit_date, "
+              "favicon_url, session, empty "
+            "FROM ( "
+              "SELECT h.id AS id, h.url AS url, h.title AS title, "
+                "h.rev_host AS rev_host, h.visit_count AS visit_count, "
+                "MAX(v.visit_date) AS visit_date, f.url AS favicon_url, "
+                "v.session AS session, null AS empty "
+              "FROM moz_places h "
+              "JOIN moz_historyvisits_temp v ON h.id = v.place_id "
+              "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
+              "WHERE h.hidden <> 1 AND v.visit_type NOT IN ") +
+                nsPrintfCString("(0,%d,%d) ",
+                                nsINavHistoryService::TRANSITION_EMBED,
+                                nsINavHistoryService::TRANSITION_DOWNLOAD) +
+                NS_LITERAL_CSTRING("AND h.visit_count > 0 "
+                "AND h.id NOT IN (SELECT id FROM moz_places_temp) "
+                "{ADDITIONAL_CONDITIONS} "
+              "GROUP BY h.id "
+            ") "
+            "UNION ALL "
+            "SELECT id, url, title, rev_host, visit_count, visit_date, "
+              "favicon_url, session, empty "
+            "FROM ( "
+              "SELECT h.id AS id, h.url AS url, h.title AS title, "
+                "h.rev_host AS rev_host, h.visit_count AS visit_count, "
+                "MAX(v.visit_date) AS visit_date, f.url AS favicon_url, "
+                "v.session AS session, null AS empty "
+              "FROM moz_places_temp h "
+              "JOIN moz_historyvisits_temp v ON h.id = v.place_id "
+              "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
+              "WHERE h.hidden <> 1 AND v.visit_type NOT IN ") +
+                nsPrintfCString("(0,%d,%d) ",
+                                nsINavHistoryService::TRANSITION_EMBED,
+                                nsINavHistoryService::TRANSITION_DOWNLOAD) +
+                NS_LITERAL_CSTRING("AND h.visit_count > 0 "
+                "{ADDITIONAL_CONDITIONS} "
+              "GROUP BY h.id "
+            ") "
+          ") "
+          "GROUP BY id ");
+      }
+      else {
+        mQueryString = NS_LITERAL_CSTRING(
+          "SELECT id, url, title, rev_host, visit_count, MAX(visit_date), "
+            "favicon_url, session, empty "
+          "FROM ( "
+            "SELECT id, url, title, rev_host, visit_count, visit_date, "
+              "favicon_url, session, empty "
+            "FROM ("
+              "SELECT h.id AS id, h.url AS url, h.title AS title, "
+                "h.rev_host AS rev_host, h.visit_count AS visit_count, "
+                "MAX(v.visit_date) AS visit_date, f.url AS favicon_url, "
+                "v.session AS session, null AS empty "
+              "FROM moz_places h "
+              "JOIN moz_historyvisits v ON h.id = v.place_id "
+              "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
+              // no-op since {ADDITIONAL_CONDITIONS} will start with AND
+              "WHERE 1=1 "
+                "{ADDITIONAL_CONDITIONS} "
+              "GROUP BY h.id "
+            ") "
+            "UNION ALL "
+            "SELECT id, url, title, rev_host, visit_count, visit_date, "
+              "favicon_url, session, empty "
+            "FROM ( "
+              "SELECT h.id AS id, h.url AS url, h.title AS title, "
+                "h.rev_host AS rev_host, h.visit_count AS visit_count, "
+                "MAX(v.visit_date) AS visit_date, f.url AS favicon_url, "
+                "v.session AS session, null AS empty "
+              "FROM moz_places_temp h "
+              "JOIN moz_historyvisits v ON h.id = v.place_id "
+              "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
+              "WHERE h.id NOT IN (SELECT id FROM moz_places_temp) "
+                "{ADDITIONAL_CONDITIONS} "
+              "GROUP BY h.id "
+            ") "
+            "UNION ALL "
+            "SELECT id, url, title, rev_host, visit_count, visit_date, "
+              "favicon_url, session, empty "
+            "FROM ( "
+              "SELECT h.id AS id, h.url AS url, h.title AS title, "
+                "h.rev_host AS rev_host, h.visit_count AS visit_count, "
+                "MAX(v.visit_date) AS visit_date, f.url AS favicon_url, "
+                "v.session AS session, null AS empty "
+              "FROM moz_places h "
+              "JOIN moz_historyvisits_temp v ON h.id = v.place_id "
+              "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
+              "WHERE h.id NOT IN (SELECT id FROM moz_places_temp) "
+                "{ADDITIONAL_CONDITIONS} "
+              "GROUP BY h.id "
+            ") "
+            "UNION ALL "
+            "SELECT id, url, title, rev_host, visit_count, visit_date, "
+              "favicon_url, session, empty "
+            "FROM ( "
+              "SELECT h.id AS id, h.url AS url, h.title AS title, "
+                "h.rev_host AS rev_host, h.visit_count AS visit_count, "
+                "MAX(v.visit_date) AS visit_date, f.url AS favicon_url, "
+                "v.session AS session, null AS empty "
+              "FROM moz_places_temp h "
+              "JOIN moz_historyvisits_temp v ON h.id = v.place_id "
+              "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
+              // no-op since {ADDITIONAL_CONDITIONS} will start with AND
+              "WHERE 1=1 "
+                "{ADDITIONAL_CONDITIONS} "
+              "GROUP BY h.id "
+            ") "
+          ") "
+          "GROUP BY id ");    
+      }
       break;
 
     case nsINavHistoryQueryOptions::QUERY_TYPE_BOOKMARKS:
@@ -3018,16 +3294,36 @@
             SQL_STR_FRAGMENT_MAX_VISIT_DATE( "b2.fk" )
             ", f.url, null, b2.id, b2.dateAdded, b2.lastModified "
           "FROM moz_bookmarks b2 "
-            "JOIN moz_places h ON b2.fk = h.id AND b2.type = 1 "
-            "LEFT OUTER JOIN moz_favicons f ON h.favicon_id = f.id "
-            "WHERE b2.id IN ("
-              "SELECT b1.id FROM moz_bookmarks b1 "
-              "WHERE b1.fk IN "
-                "(SELECT b.fk FROM moz_bookmarks b WHERE b.type = 1 {ADDITIONAL_CONDITIONS}) "
-              "AND NOT EXISTS "
-                "(SELECT id FROM moz_bookmarks WHERE id = b1.parent AND parent = ") +
+          "JOIN moz_places_temp h ON b2.fk = h.id AND b2.type = 1 "
+          "LEFT OUTER JOIN moz_favicons f ON h.favicon_id = f.id "
+          "WHERE b2.id IN ( "
+            "SELECT b1.id FROM moz_bookmarks b1 "
+            "WHERE b1.fk IN "
+              "(SELECT b.fk FROM moz_bookmarks b WHERE b.type = 1 {ADDITIONAL_CONDITIONS}) "
+            "AND NOT EXISTS ( "
+              "SELECT id FROM moz_bookmarks WHERE id = b1.parent AND parent = ") +
                 nsPrintfCString("%lld", history->GetTagsFolder()) +
-              NS_LITERAL_CSTRING(")) ORDER BY b2.fk DESC, b2.lastModified DESC");
+              NS_LITERAL_CSTRING(") "
+          ") "
+          "UNION ALL "
+          "SELECT b2.fk, h.url, COALESCE(b2.title, h.title), h.rev_host, "
+            "h.visit_count, "
+            SQL_STR_FRAGMENT_MAX_VISIT_DATE( "b2.fk" )
+            ", f.url, null, b2.id, b2.dateAdded, b2.lastModified "
+          "FROM moz_bookmarks b2 "
+          "JOIN moz_places h ON b2.fk = h.id AND b2.type = 1 "
+          "LEFT OUTER JOIN moz_favicons f ON h.favicon_id = f.id "
+          "WHERE b2.id IN ( "
+            "SELECT b1.id FROM moz_bookmarks b1 "
+            "WHERE h.id NOT IN (SELECT id FROM moz_places_temp) "
+            "AND b1.fk IN "
+              "(SELECT b.fk FROM moz_bookmarks b WHERE b.type = 1 {ADDITIONAL_CONDITIONS}) "
+            "AND NOT EXISTS ( "
+              "SELECT id FROM moz_bookmarks WHERE id = b1.parent AND parent = ") +
+                nsPrintfCString("%lld", history->GetTagsFolder()) +
+              NS_LITERAL_CSTRING(") "
+          ") "          
+          "ORDER BY b2.fk DESC, b2.lastModified DESC");
       }
       else {
         mQueryString = NS_LITERAL_CSTRING(
@@ -3036,12 +3332,29 @@
             SQL_STR_FRAGMENT_MAX_VISIT_DATE( "b.fk" )
             ", f.url, null, b.id, b.dateAdded, b.lastModified "
           "FROM moz_bookmarks b "
+          "JOIN moz_places_temp h ON b.fk = h.id AND b.type = 1 "
+          "LEFT OUTER JOIN moz_favicons f ON h.favicon_id = f.id "
+          "WHERE NOT EXISTS "
+            "(SELECT id FROM moz_bookmarks "
+              "WHERE id = b.parent AND parent = ") +
+                nsPrintfCString("%lld", history->GetTagsFolder()) +
+            NS_LITERAL_CSTRING(") "
+            "{ADDITIONAL_CONDITIONS}"
+          "UNION ALL "
+          "SELECT b.fk, h.url, COALESCE(b.title, h.title), h.rev_host, "
+            "h.visit_count,"
+            SQL_STR_FRAGMENT_MAX_VISIT_DATE( "b.fk" )
+            ", f.url, null, b.id, b.dateAdded, b.lastModified "
+          "FROM moz_bookmarks b "
           "JOIN moz_places h ON b.fk = h.id AND b.type = 1 "
           "LEFT OUTER JOIN moz_favicons f ON h.favicon_id = f.id "
-          "WHERE NOT EXISTS "
-            "(SELECT id FROM moz_bookmarks WHERE id = b.parent AND parent = ") +
-            nsPrintfCString("%lld", history->GetTagsFolder()) +
-            NS_LITERAL_CSTRING(") {ADDITIONAL_CONDITIONS}");
+          "WHERE h.id NOT IN (SELECT id FROM moz_places_temp) "
+            "AND NOT EXISTS "
+              "(SELECT id FROM moz_bookmarks "
+                "WHERE id = b.parent AND parent = ") +
+                  nsPrintfCString("%lld", history->GetTagsFolder()) +
+              NS_LITERAL_CSTRING(") "
+            "{ADDITIONAL_CONDITIONS}");
       }
       break;
 
@@ -3054,17 +3367,94 @@
 nsresult
 PlacesSQLQueryBuilder::SelectAsVisit()
 {
-  mQueryString = NS_LITERAL_CSTRING(
-    "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, "
-      "v.visit_date, f.url, v.session, null "
-    "FROM moz_places h "
-         "LEFT OUTER JOIN moz_historyvisits v ON h.id = v.place_id "
-         "LEFT OUTER JOIN moz_favicons f ON h.favicon_id = f.id ");
-
-  if (!mIncludeHidden)
-    mQueryString += NS_LITERAL_CSTRING(
-      " WHERE h.hidden <> 1 AND v.visit_type NOT IN (0,4)"
-        " {ADDITIONAL_CONDITIONS} ");
+  if (!mIncludeHidden) {
+    mQueryString = NS_LITERAL_CSTRING(
+      "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, "
+        "v.visit_date, f.url, v.session, null "
+      "FROM moz_places h "
+      "JOIN moz_historyvisits v ON h.id = v.place_id "
+      "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
+      "WHERE h.visit_count > 0 "
+        "AND h.hidden <> 1 AND v.visit_type NOT IN ") +
+          nsPrintfCString("(0,%d,%d) ",
+                          nsINavHistoryService::TRANSITION_EMBED,
+                          nsINavHistoryService::TRANSITION_DOWNLOAD) +
+        NS_LITERAL_CSTRING("AND h.id NOT IN (SELECT id FROM moz_places_temp) "
+        "{ADDITIONAL_CONDITIONS} "
+      "UNION ALL "
+      "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, "
+        "v.visit_date, f.url, v.session, null "
+      "FROM moz_places_temp h "
+      "JOIN moz_historyvisits v ON h.id = v.place_id "
+      "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
+      "WHERE h.visit_count > 0 "
+        "AND h.hidden <> 1 AND v.visit_type NOT IN ") +
+          nsPrintfCString("(0,%d,%d) ",
+                          nsINavHistoryService::TRANSITION_EMBED,
+                          nsINavHistoryService::TRANSITION_DOWNLOAD) +
+        NS_LITERAL_CSTRING("{ADDITIONAL_CONDITIONS} "
+      "UNION ALL "
+      "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, "
+        "v.visit_date, f.url, v.session, null "
+      "FROM moz_places h "
+      "JOIN moz_historyvisits_temp v ON h.id = v.place_id "
+      "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
+      "WHERE h.visit_count > 0 "
+        "AND h.id NOT IN (SELECT id FROM moz_places_temp) "
+        "AND h.hidden <> 1 AND v.visit_type NOT IN ") +
+          nsPrintfCString("(0,%d,%d) ", 
+                          nsINavHistoryService::TRANSITION_EMBED,
+                          nsINavHistoryService::TRANSITION_DOWNLOAD) +
+        NS_LITERAL_CSTRING("{ADDITIONAL_CONDITIONS} "
+      "UNION ALL "
+      "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, "
+        "v.visit_date, f.url, v.session, null "
+      "FROM moz_places_temp h "
+      "JOIN moz_historyvisits_temp v ON h.id = v.place_id "
+      "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
+      "WHERE h.visit_count > 0 "
+        "AND h.hidden <> 1 AND v.visit_type NOT IN ") +
+          nsPrintfCString("(0,%d,%d) ",
+                          nsINavHistoryService::TRANSITION_EMBED,
+                          nsINavHistoryService::TRANSITION_DOWNLOAD) +
+        NS_LITERAL_CSTRING("{ADDITIONAL_CONDITIONS} ");
+  }
+  else {
+    mQueryString = NS_LITERAL_CSTRING(
+      "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, "
+        "v.visit_date, f.url, v.session, null "
+      "FROM moz_places h "
+      "JOIN moz_historyvisits v ON h.id = v.place_id "
+      "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
+      "WHERE h.id NOT IN (SELECT id FROM moz_places_temp) "
+        "{ADDITIONAL_CONDITIONS} "
+      "UNION ALL "
+      "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, "
+        "v.visit_date, f.url, v.session, null "
+      "FROM moz_places_temp h "
+      "JOIN moz_historyvisits v ON h.id = v.place_id "
+      "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
+      // no-op since {ADDITIONAL_CONDITIONS} will start with AND
+      "WHERE 1=1 "
+        "{ADDITIONAL_CONDITIONS} "
+      "UNION ALL "
+      "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, "
+        "v.visit_date, f.url, v.session, null "
+      "FROM moz_places h "
+      "JOIN moz_historyvisits_temp v ON h.id = v.place_id "
+      "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
+      "WHERE h.id NOT IN (SELECT id FROM moz_places_temp) "
+        "{ADDITIONAL_CONDITIONS} "
+      "UNION ALL "
+      "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, "
+        "v.visit_date, f.url, v.session, null "
+      "FROM moz_places_temp h "
+      "JOIN moz_historyvisits_temp v ON h.id = v.place_id "
+      "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
+      // no-op since {ADDITIONAL_CONDITIONS} will start with AND
+      "WHERE 1=1 "
+      "{ADDITIONAL_CONDITIONS} ");
+  }
 
   return NS_OK;
 }
@@ -3131,20 +3521,34 @@
 
     nsPrintfCString dayRange(1024,
       "SELECT * "
-      "FROM (SELECT %d dayOrder, "
-                  "'%d' dayRange, "
-                  "%s dayTitle, " // This will be bound
-                  "%llu beginTime, "
-                  "%llu endTime "
-      "FROM  moz_historyvisits "
-      "WHERE visit_date >= %llu AND visit_date < %llu "
-      "  AND visit_type NOT IN (0,4) "
+      "FROM ( "
+        "SELECT %d dayOrder, "
+               "'%d' dayRange, "
+               "%s dayTitle, " // This will be bound
+               "%llu beginTime, "
+               "%llu endTime "
+        "WHERE EXISTS ( "
+          "SELECT id FROM moz_historyvisits_temp "
+          "WHERE visit_date >= %llu "
+            "AND visit_date < %llu "
+            "AND visit_type NOT IN (0, 4) "
+          "LIMIT 1 "
+        ") "
+        "OR EXISTS ( "
+          "SELECT * FROM moz_historyvisits "
+          "WHERE visit_date >= %llu "
+            "AND visit_date < %llu "
+            "AND visit_type NOT IN (0, 4) "
+          "LIMIT 1 "
+        ") "
       "LIMIT 1) TUNION%d UNION ", 
       i, i, dateParam.get(), 
       midnight.Get(fromDayAgo),
       midnight.Get(toDayAgo), 
       midnight.Get(fromDayAgo),
       midnight.Get(toDayAgo),
+      midnight.Get(fromDayAgo),
+      midnight.Get(toDayAgo),
       i);
 
     mQueryString.Append( dayRange );
@@ -3158,21 +3562,32 @@
 
   mQueryString.Append(nsPrintfCString(1024,
     "SELECT * "
-    "FROM (SELECT %d dayOrder, "
-                 "'%d+' dayRange, "
-                 "%s dayTitle, " // This will be bound
-                 "1 beginTime, "
-                 "%llu endTime "
-          "FROM  moz_historyvisits "
-          "WHERE visit_date < %llu "
-          "  AND visit_type NOT IN (0,4) "
-          "LIMIT 1) TUNIONLAST "
+    "FROM ("
+      "SELECT %d dayOrder, "
+            "'%d+' dayRange, "
+            "%s dayTitle, " // This will be bound
+            "1 beginTime, "
+            "%llu endTime "
+      "WHERE EXISTS ( "
+        "SELECT id FROM moz_historyvisits_temp "
+        "WHERE visit_date < %llu "
+          "AND visit_type NOT IN (0, 4) "
+        "LIMIT 1 "
+      ") "
+      "OR EXISTS ( "
+        "SELECT id FROM moz_historyvisits "
+        "WHERE visit_date < %llu "
+          "AND visit_type NOT IN (0, 4) "
+        "LIMIT 1 "
+      ") "
+      "LIMIT 1) TUNIONLAST "
     ") TOUTER " // TOUTER END
     "ORDER BY dayOrder ASC",
     MAX_HISTORY_DAYS+1,
     MAX_HISTORY_DAYS+1,
     dateParam.get(),
     midnight.Get(-MAX_HISTORY_DAYS),
+    midnight.Get(-MAX_HISTORY_DAYS),
     midnight.Get(-MAX_HISTORY_DAYS)
     ));
 
@@ -3192,26 +3607,43 @@
 
   // We want just sites, but from whole database.
   if (mConditions.IsEmpty()) {
-
     mQueryString = nsPrintfCString(2048,
       "SELECT DISTINCT null, "
              "'place:type=%ld&sort=%ld&domain=&domainIsHost=true', "
              ":localhost, :localhost, null, null, null, null, null "
-      "WHERE EXISTS(SELECT '*' "
-                   "FROM moz_places "
-                   "WHERE hidden <> 1 AND rev_host = '.' "
-                     "AND visit_count > 0 "
-                     "AND url BETWEEN 'file://' AND 'file:/~') "
+      "WHERE EXISTS ( "
+        "SELECT id FROM moz_places_temp "
+        "WHERE hidden <> 1 "
+          "AND rev_host = '.' "
+          "AND visit_count > 0 "
+          "AND url BETWEEN 'file://' AND 'file:/~' "
+        "UNION ALL "
+        "SELECT id FROM moz_places "
+        "WHERE id NOT IN (SELECT id FROM moz_places_temp) "
+          "AND hidden <> 1 "
+          "AND rev_host = '.' "
+          "AND visit_count > 0 "
+          "AND url BETWEEN 'file://' AND 'file:/~' "
+      ") "
       "UNION ALL "
       "SELECT DISTINCT null, "
              "'place:type=%ld&sort=%ld&domain='||host||'&domainIsHost=true', "
              "host, host, null, null, null, null, null "
-      "FROM (SELECT get_unreversed_host(rev_host) host "
-            "FROM (SELECT DISTINCT rev_host "
-                  "FROM moz_places "
-                  "WHERE hidden <> 1 AND rev_host <> '.' "
-                    "AND visit_count > 0 ) inner0 "
-            "ORDER BY 1 ASC) inner1",
+      "FROM ( "
+        "SELECT get_unreversed_host(rev_host) host "
+        "FROM ( "
+          "SELECT DISTINCT rev_host FROM moz_places_temp "
+          "WHERE hidden <> 1 "
+            "AND rev_host <> '.' "
+            "AND visit_count > 0 "
+          "UNION ALL "
+          "SELECT DISTINCT rev_host FROM moz_places "
+          "WHERE id NOT IN (SELECT id FROM moz_places_temp) "
+            "AND hidden <> 1 "
+            "AND rev_host <> '.' "
+            "AND visit_count > 0 "
+        ") "
+      "ORDER BY 1 ASC)",
       nsINavHistoryQueryOptions::RESULTS_AS_URI,
       nsINavHistoryQueryOptions::SORT_BY_TITLE_ASCENDING,
       nsINavHistoryQueryOptions::RESULTS_AS_URI,
@@ -3224,27 +3656,74 @@
              "'place:type=%ld&sort=%ld&domain=&domainIsHost=true"
                "&beginTime='||:begin_time||'&endTime='||:end_time, "
              ":localhost, :localhost, null, null, null, null, null "
-      "WHERE EXISTS(SELECT '*' "
-                   "FROM moz_places h  "
-                        "JOIN moz_historyvisits v ON h.id = v.place_id "
-                   "WHERE h.hidden <> 1 AND h.rev_host = '.' "
-                     "AND h.visit_count > 0 "
-                     "AND h.url BETWEEN 'file://' AND 'file:/~' "
-                     "AND v.visit_type NOT IN (0,4) {ADDITIONAL_CONDITIONS} ) "
+      "WHERE EXISTS( "
+        "SELECT h.id "
+        "FROM moz_places h "
+        "JOIN moz_historyvisits v ON v.place_id = h.id "
+        "WHERE h.hidden <> 1 AND h.rev_host = '.' "
+          "AND h.visit_count > 0 "
+          "AND h.url BETWEEN 'file://' AND 'file:/~' "
+          "{ADDITIONAL_CONDITIONS} "
+        "UNION "
+        "SELECT h.id "
+        "FROM moz_places_temp h "
+        "JOIN moz_historyvisits v ON v.place_id = h.id "
+        "WHERE h.hidden <> 1 AND h.rev_host = '.' "
+          "AND h.visit_count > 0 "
+          "AND h.url BETWEEN 'file://' AND 'file:/~' "
+          "{ADDITIONAL_CONDITIONS} "
+        "UNION "
+        "SELECT h.id "
+        "FROM moz_places h "
+        "JOIN moz_historyvisits_temp v ON v.place_id = h.id "
+        "WHERE h.hidden <> 1 AND h.rev_host = '.' "
+          "AND h.visit_count > 0 "
+          "AND h.url BETWEEN 'file://' AND 'file:/~' "
+          "{ADDITIONAL_CONDITIONS} "
+        "UNION "
+        "SELECT h.id "
+        "FROM moz_places_temp h "
+        "JOIN moz_historyvisits_temp v ON v.place_id = h.id "
+        "WHERE h.hidden <> 1 AND h.rev_host = '.' "
+          "AND h.visit_count > 0 "
+          "AND h.url BETWEEN 'file://' AND 'file:/~' "
+          "{ADDITIONAL_CONDITIONS} "        
+      ") "
       "UNION ALL "
       "SELECT DISTINCT null, "
              "'place:type=%ld&sort=%ld&domain='||host||'&domainIsHost=true"
                "&beginTime='||:begin_time||'&endTime='||:end_time, "
              "host, host, null, null, null, null, null "
-      "FROM (SELECT get_unreversed_host(rev_host) host "
-            "FROM (SELECT DISTINCT rev_host "
-                  "FROM moz_places h "
-                       "JOIN moz_historyvisits v ON h.id = v.place_id "
-                  "WHERE h.hidden <> 1 AND h.rev_host <> '.' "
-                    "AND h.visit_count > 0 "
-                    "AND v.visit_type NOT IN (0,4) "
-                    "{ADDITIONAL_CONDITIONS} ) inner0 "
-            "ORDER BY 1 ASC) inner1",
+      "FROM ( "
+        "SELECT DISTINCT get_unreversed_host(rev_host) AS host "
+        "FROM moz_places h "
+        "JOIN moz_historyvisits v ON v.place_id = h.id "
+        "WHERE h.hidden <> 1 AND h.rev_host <> '.' "
+          "AND h.visit_count > 0 "
+          "{ADDITIONAL_CONDITIONS} "
+        "UNION "
+        "SELECT DISTINCT get_unreversed_host(rev_host) AS host "
+        "FROM moz_places_temp h "
+        "JOIN moz_historyvisits v ON v.place_id = h.id "
+        "WHERE h.hidden <> 1 AND h.rev_host <> '.' "
+          "AND h.visit_count > 0 "
+          "{ADDITIONAL_CONDITIONS} "
+        "UNION "
+        "SELECT DISTINCT get_unreversed_host(rev_host) AS host "
+        "FROM moz_places h "
+        "JOIN moz_historyvisits_temp v ON v.place_id = h.id "
+        "WHERE h.hidden <> 1 AND h.rev_host <> '.' "
+          "AND h.visit_count > 0 "
+          "{ADDITIONAL_CONDITIONS} "
+        "UNION "
+        "SELECT DISTINCT get_unreversed_host(rev_host) AS host "
+        "FROM moz_places_temp h "
+        "JOIN moz_historyvisits_temp v ON v.place_id = h.id "        
+        "WHERE h.hidden <> 1 AND h.rev_host <> '.' "
+          "AND h.visit_count > 0 "
+          "{ADDITIONAL_CONDITIONS} "        
+        "ORDER BY 1 ASC "
+      ")",
       nsINavHistoryQueryOptions::RESULTS_AS_URI,
       nsINavHistoryQueryOptions::SORT_BY_TITLE_ASCENDING,
       nsINavHistoryQueryOptions::RESULTS_AS_URI,
@@ -3431,21 +3910,44 @@
   if (IsHistoryMenuQuery(aQueries, aOptions, 
         nsINavHistoryQueryOptions::SORT_BY_DATE_DESCENDING)) {
 
+    nsCString sqlFragment = NS_LITERAL_CSTRING(
+      "SELECT * FROM ( "
+        "SELECT DISTINCT place_id "
+        "FROM moz_historyvisits "
+        "WHERE visit_type NOT IN (0,4) "
+          "AND NOT EXISTS (SELECT id FROM moz_places h WHERE h.id = place_id AND hidden = 1) "
+          "AND NOT EXISTS (SELECT id FROM moz_places_temp h WHERE h.id = place_id AND hidden = 1) "
+        "ORDER by visit_date DESC LIMIT ") +
+        nsPrintfCString("%d ", aOptions->MaxResults()) +
+      NS_LITERAL_CSTRING(") "
+      "UNION ALL "
+      "SELECT * FROM ( "
+        "SELECT DISTINCT place_id "
+        "FROM moz_historyvisits_temp "
+        "WHERE visit_type NOT IN (0,4) "
+        "AND NOT EXISTS (SELECT id FROM moz_places h WHERE h.id = place_id AND hidden = 1) "
+        "AND NOT EXISTS (SELECT id FROM moz_places_temp h WHERE h.id = place_id AND hidden = 1) "
+        "ORDER by visit_date DESC LIMIT ") +
+        nsPrintfCString("%d ", aOptions->MaxResults()) +
+      NS_LITERAL_CSTRING(")");
+
     queryString = NS_LITERAL_CSTRING(
       "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, "
-        SQL_STR_FRAGMENT_MAX_VISIT_DATE( "h.id" )
-        ", f.url, null, null "
-      "FROM moz_places h "
-      "LEFT OUTER JOIN moz_favicons f ON h.favicon_id = f.id "
-      "WHERE h.id IN ( "
-        "SELECT DISTINCT p.id "
-        "FROM moz_places p "
-        "JOIN moz_historyvisits v ON v.place_id = p.id "
-        "WHERE p.hidden <> 1 AND v.visit_type NOT IN (0,4) "
-        "ORDER BY v.visit_date DESC "
+          SQL_STR_FRAGMENT_MAX_VISIT_DATE( "h.id" )
+          ", f.url, null, null "
+        "FROM moz_places_temp h "
+        "LEFT OUTER JOIN moz_favicons f ON h.favicon_id = f.id "
+        "WHERE h.id IN ( ") + sqlFragment + NS_LITERAL_CSTRING(") "
+      "UNION "
+      "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, "
+          SQL_STR_FRAGMENT_MAX_VISIT_DATE( "h.id" )
+          ", f.url, null, null "
+        "FROM moz_places h "
+        "LEFT OUTER JOIN moz_favicons f ON h.favicon_id = f.id "
+        "WHERE h.id IN ( ") + sqlFragment + NS_LITERAL_CSTRING(") "
+        "ORDER BY 6 DESC " // last visit date
         "LIMIT ");
     queryString.AppendInt(aOptions->MaxResults());
-    queryString += NS_LITERAL_CSTRING(") ORDER BY 6 DESC"); // v.visit_date
     return NS_OK;
   }
 
@@ -3454,17 +3956,30 @@
   if (IsHistoryMenuQuery(aQueries, aOptions, 
         nsINavHistoryQueryOptions::SORT_BY_VISITCOUNT_DESCENDING)) {
     queryString = NS_LITERAL_CSTRING(
-      "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, "
-        SQL_STR_FRAGMENT_MAX_VISIT_DATE( "h.id" )
-        ", f.url, null, null "
-      "FROM moz_places h "
-      "LEFT OUTER JOIN moz_favicons f ON h.favicon_id = f.id "
-      "WHERE h.id IN ("
-        "SELECT p.id FROM moz_places p "
-        "WHERE p.hidden <> 1 AND visit_count > 0 "
-        "ORDER BY p.visit_count DESC LIMIT ");
+      "SELECT * FROM ( "
+        "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, "
+          SQL_STR_FRAGMENT_MAX_VISIT_DATE( "h.id" )
+          ", f.url, null, null "
+        "FROM moz_places_temp h "
+        "LEFT OUTER JOIN moz_favicons f ON h.favicon_id = f.id "
+        "WHERE h.hidden <> 1 AND visit_count > 0 "
+        "ORDER BY h.visit_count DESC LIMIT ") +
+        nsPrintfCString("%d ", aOptions->MaxResults()) +
+      NS_LITERAL_CSTRING(") "
+      "UNION "
+      "SELECT * FROM ( "
+        "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, "
+          SQL_STR_FRAGMENT_MAX_VISIT_DATE( "h.id" )
+          ", f.url, null, null "
+        "FROM moz_places h "
+        "LEFT OUTER JOIN moz_favicons f ON h.favicon_id = f.id "
+        "WHERE h.hidden <> 1 AND visit_count > 0 "
+        "ORDER BY h.visit_count DESC LIMIT ") +
+        nsPrintfCString("%d ", aOptions->MaxResults()) +
+      NS_LITERAL_CSTRING(") "
+      "ORDER BY 5 DESC LIMIT "); // visit_count
     queryString.AppendInt(aOptions->MaxResults());
-    queryString += NS_LITERAL_CSTRING(") ORDER BY h.visit_count DESC");
+
     return NS_OK;
   }  
 
@@ -3549,7 +4064,7 @@
                                      paramsPresent, addParams);
   NS_ENSURE_SUCCESS(rv,rv);
 
-#ifdef DEBUG_thunder
+#ifdef DEBUG_FRECENCY
   printf("Constructed the query: %s\n", PromiseFlatCString(queryString).get());
 #endif
 
@@ -3701,13 +4216,38 @@
   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
 
   nsCOMPtr<mozIStorageStatement> statement;
-  nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
-      "SELECT h.url "
-      "FROM moz_places h LEFT OUTER JOIN moz_historyvisits v ON h.id = v.place_id "
-      "WHERE v.visit_date IN "
-      "(SELECT MAX(visit_date) "
-       "FROM moz_historyvisits v2 LEFT JOIN moz_places h2 ON v2.place_id = h2.id "
-        "WHERE h2.hidden != 1)"),
+  // We are not checking for duplicated ids into the unified table
+  // for perf reasons, LIMIT 1 will discard duplicates faster since we
+  // expect newest visits being in temp table.
+  nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "SELECT * FROM ( "
+        "SELECT url, visit_date FROM moz_historyvisits_temp v "
+        "JOIN moz_places_temp h ON v.place_id = h.id "
+        "WHERE h.hidden <> 1 "
+        "ORDER BY visit_date DESC LIMIT 1 "
+      ") "
+      "UNION ALL "
+      "SELECT * FROM ( "
+        "SELECT url, visit_date FROM moz_historyvisits_temp v "
+        "JOIN moz_places h ON v.place_id = h.id "
+        "WHERE h.hidden <> 1 "
+        "ORDER BY visit_date DESC LIMIT 1 "
+      ") "
+      "UNION ALL "
+      "SELECT * FROM ( "
+        "SELECT url, visit_date FROM moz_historyvisits v "
+        "JOIN moz_places h ON v.place_id = h.id "
+        "WHERE h.hidden <> 1 "
+        "ORDER BY visit_date DESC LIMIT 1 "
+      ") "
+      "UNION ALL "
+      "SELECT * FROM ( "
+        "SELECT url, visit_date FROM moz_historyvisits v "
+        "JOIN moz_places_temp h ON v.place_id = h.id "
+        "WHERE h.hidden <> 1 "
+        "ORDER BY visit_date DESC LIMIT 1 "
+      ") "
+      "ORDER BY 2 DESC LIMIT 1"), /* visit date */
     getter_AddRefs(statement));
   NS_ENSURE_SUCCESS(rv, rv);
 
@@ -3765,19 +4305,31 @@
   // to figure out which places to recalculate frecency first.
   // Pay attention to not set frecency = 0 if visit_count = 0
   nsresult rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
-      "UPDATE moz_places "
+      "UPDATE moz_places_view "
       "SET frecency = -MAX(visit_count, 1) "
-      "WHERE id IN(") +
-        aPlaceIdsQueryString +
-        NS_LITERAL_CSTRING(") AND ("
-          "EXISTS (SELECT b.id FROM moz_bookmarks b WHERE b.fk = moz_places.id) "
-          "OR EXISTS "
-            "(SELECT a.id FROM moz_annos a WHERE a.place_id = moz_places.id))"));
+      "WHERE id IN ( "
+        "SELECT h.id " 
+        "FROM moz_places_temp h "
+        "WHERE h.id IN ( ") + aPlaceIdsQueryString + NS_LITERAL_CSTRING(") "
+          "AND ( "
+            "EXISTS (SELECT b.id FROM moz_bookmarks b WHERE b.fk =h.id) "
+            "OR EXISTS (SELECT a.id FROM moz_annos a WHERE a.place_id = h.id) "
+          ") "
+        "UNION ALL "
+        "SELECT h.id " 
+        "FROM moz_places h "
+        "WHERE h.id IN ( ") + aPlaceIdsQueryString + NS_LITERAL_CSTRING(") "
+          "AND h.id NOT IN (SELECT id FROM moz_places_temp) "
+          "AND ( "
+            "EXISTS (SELECT b.id FROM moz_bookmarks b WHERE b.fk =h.id) "
+            "OR EXISTS (SELECT a.id FROM moz_annos a WHERE a.place_id = h.id) "
+          ") "        
+      ")"));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // delete all visits
   rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
-      "DELETE FROM moz_historyvisits WHERE place_id IN (") +
+      "DELETE FROM moz_historyvisits_view WHERE place_id IN (") +
         aPlaceIdsQueryString +
         NS_LITERAL_CSTRING(")"));
   NS_ENSURE_SUCCESS(rv, rv);
@@ -3791,12 +4343,20 @@
   // Note that we do NOT delete favicons. Any unreferenced favicons will be
   // deleted next time the browser is shut down.
   rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
-      "DELETE FROM moz_places WHERE id IN ("
-        "SELECT h.id FROM moz_places h WHERE h.id IN (") +
-        aPlaceIdsQueryString +
-        NS_LITERAL_CSTRING(") AND "
-        "NOT EXISTS (SELECT b.id FROM moz_bookmarks b WHERE b.fk = h.id LIMIT 1) "
-        "AND SUBSTR(h.url,0,6) <> 'place:')"));
+      "DELETE FROM moz_places_view WHERE id IN ("
+        "SELECT h.id FROM moz_places_temp h "
+        "WHERE h.id IN ( ") + aPlaceIdsQueryString + NS_LITERAL_CSTRING(") "
+          "AND SUBSTR(h.url, 0, 6) <> 'place:' "
+          "AND NOT EXISTS "
+            "(SELECT b.id FROM moz_bookmarks b WHERE b.fk = h.id LIMIT 1) "
+        "UNION ALL "
+        "SELECT h.id FROM moz_places h "
+        "WHERE h.id NOT IN (SELECT id FROM moz_places_temp) "
+          "AND h.id IN ( ") + aPlaceIdsQueryString + NS_LITERAL_CSTRING(") "
+          "AND SUBSTR(h.url, 0, 6) <> 'place:' "
+          "AND NOT EXISTS "
+            "(SELECT b.id FROM moz_bookmarks b WHERE b.fk = h.id LIMIT 1) "
+    ")"));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // placeId could have a livemark item, so setting the frecency to -1
@@ -3920,16 +4480,21 @@
   // build condition string based on host selection type
   nsCAutoString conditionString;
   if (aEntireDomain)
-    conditionString.AssignLiteral("h.rev_host >= ?1 AND h.rev_host < ?2 ");
-  else
-    conditionString.AssignLiteral("h.rev_host = ?1 ");
+    conditionString.AssignLiteral("rev_host >= ?1 AND rev_host < ?2 ");
+  else
+    conditionString.AssignLiteral("rev_host = ?1 ");
 
   nsCOMPtr<mozIStorageStatement> statement;
 
   // create statement depending on delete type
   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
-      "SELECT h.id FROM moz_places h WHERE ") +
-      conditionString, getter_AddRefs(statement));
+      "SELECT id FROM moz_places_temp "
+      "WHERE ") + conditionString + NS_LITERAL_CSTRING(
+      "UNION ALL "
+      "SELECT id FROM moz_places "
+      "WHERE id NOT IN (SELECT id FROM moz_places_temp) "
+        "AND ") + conditionString,
+    getter_AddRefs(statement));
   NS_ENSURE_SUCCESS(rv, rv);
   rv = statement->BindStringParameter(0, revHostDot);
   NS_ENSURE_SUCCESS(rv, rv);
@@ -3980,9 +4545,21 @@
   // this query is faster than actually selecting in moz_historyvisits
   nsCOMPtr<mozIStorageStatement> selectByTime;
   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "SELECT h.id FROM moz_places_temp h WHERE "
+        "EXISTS "
+          "(SELECT id FROM moz_historyvisits v WHERE v.place_id = h.id "
+            "AND v.visit_date >= ?1 AND v.visit_date <= ?2 LIMIT 1)"
+        "OR EXISTS "
+          "(SELECT id FROM moz_historyvisits_temp v WHERE v.place_id = h.id "
+            "AND v.visit_date >= ?1 AND v.visit_date <= ?2 LIMIT 1) "
+      "UNION "
       "SELECT h.id FROM moz_places h WHERE "
-      "EXISTS (SELECT id FROM moz_historyvisits v WHERE v.place_id = h.id "
-      " AND v.visit_date >= ?1 AND v.visit_date <= ?2 LIMIT 1)"),
+        "EXISTS "
+          "(SELECT id FROM moz_historyvisits v WHERE v.place_id = h.id "
+            "AND v.visit_date >= ?1 AND v.visit_date <= ?2 LIMIT 1)"
+        "OR EXISTS "
+          "(SELECT id FROM moz_historyvisits_temp v WHERE v.place_id = h.id "
+            "AND v.visit_date >= ?1 AND v.visit_date <= ?2 LIMIT 1)"),
     getter_AddRefs(selectByTime));
   NS_ENSURE_SUCCESS(rv, rv);
   rv = selectByTime->BindInt64Parameter(0, aBeginTime);
@@ -5020,8 +5597,8 @@
       "EXISTS "
         "(SELECT h.id "
          "FROM moz_annos anno "
-              "JOIN moz_anno_attributes annoname "
-                "ON anno.anno_attribute_id = annoname.id "
+         "JOIN moz_anno_attributes annoname "
+           "ON anno.anno_attribute_id = annoname.id "
          "WHERE anno.place_id = h.id "
            "AND annoname.name = ").Param(":anno").Str(")");
     // annotation-based queries don't get the common conditions, so you get
@@ -5766,12 +6343,12 @@
     case nsNavHistoryQueryOptions::RESULTS_AS_VISIT:
     case nsNavHistoryQueryOptions::RESULTS_AS_FULL_VISIT:
       // visit query - want exact visit time
-      statement = mDBVisitToVisitResult;
+      statement = GetDBVisitToVisitResult();
       break;
 
     case nsNavHistoryQueryOptions::RESULTS_AS_URI:
       // URL results - want last visit time
-      statement = mDBVisitToURLResult;
+      statement = GetDBVisitToURLResult();
       break;
 
     default:
@@ -5779,6 +6356,7 @@
       // by registering their own observers when they are expanded.
       return NS_OK;
   }
+  NS_ENSURE_TRUE(statement, NS_ERROR_UNEXPECTED);
 
   mozStorageStatementScoper scoper(statement);
   nsresult rv = statement->BindInt64Parameter(0, visitId);
@@ -5799,19 +6377,21 @@
 nsNavHistory::BookmarkIdToResultNode(PRInt64 aBookmarkId, nsNavHistoryQueryOptions* aOptions,
                                      nsNavHistoryResultNode** aResult)
 {
-  mozStorageStatementScoper scoper(mDBBookmarkToUrlResult);
-  nsresult rv = mDBBookmarkToUrlResult->BindInt64Parameter(0, aBookmarkId);
+  mozIStorageStatement *stmt = GetDBBookmarkToUrlResult();
+  NS_ENSURE_TRUE(stmt, NS_ERROR_UNEXPECTED);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindInt64Parameter(0, aBookmarkId);
   NS_ENSURE_SUCCESS(rv, rv);
 
   PRBool hasMore = PR_FALSE;
-  rv = mDBBookmarkToUrlResult->ExecuteStep(&hasMore);
+  rv = stmt->ExecuteStep(&hasMore);
   NS_ENSURE_SUCCESS(rv, rv);
   if (!hasMore) {
     NS_NOTREACHED("Trying to get a result node for an invalid bookmark identifier");
     return NS_ERROR_INVALID_ARG;
   }
 
-  return RowToResult(mDBBookmarkToUrlResult, aOptions, aResult);
+  return RowToResult(stmt, aOptions, aResult);
 }
 
 // nsNavHistory::TitleForDomain
@@ -5835,12 +6415,16 @@
 void
 nsNavHistory::GetAgeInDaysString(PRInt32 aInt, const PRUnichar *aName, nsACString& aResult)
 {
+  nsIStringBundle *bundle = GetBundle();
+  if (!bundle)
+    aResult.Truncate(0);
+
   nsAutoString intString;
   intString.AppendInt(aInt);
   const PRUnichar* strings[1] = { intString.get() };
   nsXPIDLString value;
-  nsresult rv = mBundle->FormatStringFromName(aName, strings, 
-                                              1, getter_Copies(value));
+  nsresult rv = bundle->FormatStringFromName(aName, strings,
+                                             1, getter_Copies(value));
   if (NS_SUCCEEDED(rv))
     CopyUTF16toUTF8(value, aResult);
   else
@@ -5850,8 +6434,12 @@
 void
 nsNavHistory::GetStringFromName(const PRUnichar *aName, nsACString& aResult)
 {
+  nsIStringBundle *bundle = GetBundle();
+  if (!bundle)
+    aResult.Truncate(0);
+
   nsXPIDLString value;
-  nsresult rv = mBundle->GetStringFromName(aName, getter_Copies(value));
+  nsresult rv = bundle->GetStringFromName(aName, getter_Copies(value));
   if (NS_SUCCEEDED(rv))
     CopyUTF16toUTF8(value, aResult);
   else
@@ -5871,8 +6459,6 @@
 nsNavHistory::SetPageTitleInternal(nsIURI* aURI, const nsAString& aTitle)
 {
   nsresult rv;
-
-  mozStorageTransaction transaction(mDBConn, PR_TRUE);
 
   // first, make sure the page exists, and fetch the old title (we need the one
   // that isn't changing to send notifications)
@@ -5901,32 +6487,24 @@
   if ((aTitle.IsVoid() && title.IsVoid()) || aTitle == title)
     return NS_OK;
 
-  nsCOMPtr<mozIStorageStatement> dbModStatement;
-  title = aTitle;
-  rv = mDBConn->CreateStatement(
-      NS_LITERAL_CSTRING("UPDATE moz_places SET title = ?1 WHERE url = ?2"),
-      getter_AddRefs(dbModStatement));
-  NS_ENSURE_SUCCESS(rv, rv);
-
+  mozStorageStatementScoper scoper(mDBSetPlaceTitle);
   // title
   if (aTitle.IsVoid())
-    dbModStatement->BindNullParameter(0);
-  else
-    dbModStatement->BindStringParameter(0, StringHead(aTitle, HISTORY_TITLE_LENGTH_MAX));
+    rv = mDBSetPlaceTitle->BindNullParameter(0);
+  else
+    rv = mDBSetPlaceTitle->BindStringParameter(0, StringHead(aTitle, HISTORY_TITLE_LENGTH_MAX));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // url
-  rv = BindStatementURI(dbModStatement, 1, aURI);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  rv = dbModStatement->Execute();
-  NS_ENSURE_SUCCESS(rv, rv);
-  rv = transaction.Commit();
+  rv = BindStatementURI(mDBSetPlaceTitle, 1, aURI);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = mDBSetPlaceTitle->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
 
   // observers (have to check first if it's bookmarked)
   ENUMERATE_WEAKARRAY(mObservers, nsINavHistoryObserver,
-                      OnTitleChanged(aURI, title))
+                      OnTitleChanged(aURI, aTitle))
 
   return NS_OK;
 
@@ -5973,57 +6551,58 @@
   // this id will be retained while duplicates will be discarded
   // total_visit_count is the sum of all duplicate uris visit_count
   nsCOMPtr<mozIStorageStatement> selectStatement;
-  nsresult rv = mDBConn->CreateStatement(
-      NS_LITERAL_CSTRING("SELECT "
-        "(SELECT h.id FROM moz_places h WHERE h.url=url ORDER BY h.visit_count DESC LIMIT 1), "
+  nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "SELECT "
+        "(SELECT h.id FROM moz_places_view h WHERE h.url = url "
+         "ORDER BY h.visit_count DESC LIMIT 1), "
         "url, SUM(visit_count) "
-        "FROM moz_places "
-        "GROUP BY url HAVING( COUNT(url) > 1)"),
-      getter_AddRefs(selectStatement));
+      "FROM moz_places_view "
+      "GROUP BY url HAVING( COUNT(url) > 1)"),
+    getter_AddRefs(selectStatement));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // this query remaps history visits to the retained place_id
   nsCOMPtr<mozIStorageStatement> updateStatement;
-  rv = mDBConn->CreateStatement(
-      NS_LITERAL_CSTRING(
-        "UPDATE moz_historyvisits "
-        "SET place_id = ?1 "
-        "WHERE place_id IN (SELECT id FROM moz_places WHERE id <> ?1 AND url = ?2)"),
-      getter_AddRefs(updateStatement));
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "UPDATE moz_historyvisits_view "
+      "SET place_id = ?1 "
+      "WHERE place_id IN "
+        "(SELECT id FROM moz_places_view WHERE id <> ?1 AND url = ?2)"),
+    getter_AddRefs(updateStatement));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // this query remaps bookmarks to the retained place_id
   nsCOMPtr<mozIStorageStatement> bookmarkStatement;
-  rv = mDBConn->CreateStatement(
-      NS_LITERAL_CSTRING(
-        "UPDATE moz_bookmarks "
-        "SET fk = ?1 "
-        "WHERE fk IN (SELECT id FROM moz_places WHERE id <> ?1 AND url = ?2)"),
-      getter_AddRefs(bookmarkStatement));
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "UPDATE moz_bookmarks "
+      "SET fk = ?1 "
+      "WHERE fk IN "
+        "(SELECT id FROM moz_places_view WHERE id <> ?1 AND url = ?2)"),
+    getter_AddRefs(bookmarkStatement));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // this query remaps annotations to the retained place_id
   nsCOMPtr<mozIStorageStatement> annoStatement;
-  rv = mDBConn->CreateStatement(
-      NS_LITERAL_CSTRING(
-        "UPDATE moz_annos "
-        "SET place_id = ?1 "
-        "WHERE place_id IN (SELECT id FROM moz_places WHERE id <> ?1 AND url = ?2)"),
-      getter_AddRefs(annoStatement));
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "UPDATE moz_annos "
+      "SET place_id = ?1 "
+      "WHERE place_id IN "
+        "(SELECT id FROM moz_places_view WHERE id <> ?1 AND url = ?2)"),
+    getter_AddRefs(annoStatement));
   NS_ENSURE_SUCCESS(rv, rv);
   
   // this query deletes all duplicate uris except the choosen id
   nsCOMPtr<mozIStorageStatement> deleteStatement;
-  rv = mDBConn->CreateStatement(
-      NS_LITERAL_CSTRING("DELETE FROM moz_places WHERE url = ?1 AND id <> ?2"),
-      getter_AddRefs(deleteStatement));
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "DELETE FROM moz_places_view WHERE url = ?1 AND id <> ?2"),
+    getter_AddRefs(deleteStatement));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // this query updates visit_count to the sum of all visits
   nsCOMPtr<mozIStorageStatement> countStatement;
-  rv = mDBConn->CreateStatement(
-      NS_LITERAL_CSTRING("UPDATE moz_places SET visit_count = ?1 WHERE id = ?2"),
-      getter_AddRefs(countStatement));
+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "UPDATE moz_places_view SET visit_count = ?1 WHERE id = ?2"),
+    getter_AddRefs(countStatement));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // for each duplicate uri we update historyvisit and visit_count
@@ -6563,11 +7142,11 @@
 {
   mozStorageTransaction transaction(mDBConn, PR_TRUE);
 
-  nsresult rv = RecalculateFrecenciesInternal(mDBInvalidFrecencies, aCount);
+  nsresult rv = RecalculateFrecenciesInternal(GetDBInvalidFrecencies(), aCount);
   NS_ENSURE_SUCCESS(rv, rv);
 
   if (aRecalcOld) {
-    rv = RecalculateFrecenciesInternal(mDBOldFrecencies, aCount);
+    rv = RecalculateFrecenciesInternal(GetDBOldFrecencies(), aCount);
     NS_ENSURE_SUCCESS(rv, rv);
   }
   return NS_OK;
@@ -6630,6 +7209,228 @@
   return NS_OK;
 }
 
+
+nsICollation *
+nsNavHistory::GetCollation()
+{
+  if (mCollation)
+    return mCollation;
+
+  // locale
+  nsCOMPtr<nsILocale> locale;
+  nsCOMPtr<nsILocaleService> ls(do_GetService(NS_LOCALESERVICE_CONTRACTID));
+  NS_ENSURE_TRUE(ls, nsnull);
+  nsresult rv = ls->GetApplicationLocale(getter_AddRefs(locale));
+  NS_ENSURE_SUCCESS(rv, nsnull);
+
+  // collation
+  nsCOMPtr<nsICollationFactory> cfact =
+    do_CreateInstance(NS_COLLATIONFACTORY_CONTRACTID);
+  NS_ENSURE_TRUE(cfact, nsnull);
+  rv = cfact->CreateCollation(locale, getter_AddRefs(mCollation));
+  NS_ENSURE_SUCCESS(rv, nsnull);
+
+  return mCollation;
+}
+
+nsIStringBundle *
+nsNavHistory::GetBundle()
+{
+  if (mBundle)
+    return mBundle;
+
+  nsCOMPtr<nsIStringBundleService> bundleService =
+    do_GetService(NS_STRINGBUNDLE_CONTRACTID);
+  NS_ENSURE_TRUE(bundleService, nsnull);
+  nsresult rv = bundleService->CreateBundle(
+      "chrome://places/locale/places.properties",
+      getter_AddRefs(mBundle));
+  NS_ENSURE_SUCCESS(rv, nsnull);
+
+  return mBundle;
+}
+
+mozIStorageStatement *
+nsNavHistory::GetDBVisitToVisitResult()
+{
+  if (mDBVisitToVisitResult)
+    return mDBVisitToVisitResult;
+
+  // mDBVisitToVisitResult, should match kGetInfoIndex_* (see GetQueryResults)
+  // We are not checking for duplicated ids into the unified table
+  // for perf reasons, LIMIT 1 will discard duplicates faster since we
+  // have unique visit ids.
+  nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, "
+          "v.visit_date, f.url, v.session, null "
+        "FROM moz_places_temp h "
+        "LEFT JOIN moz_historyvisits_temp v_t ON h.id = v_t.place_id "
+        "LEFT JOIN moz_historyvisits v ON h.id = v.place_id "
+        "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
+        "WHERE v.id = ?1 OR v_t.id = ?1 "
+      "UNION ALL "
+      "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, "
+          "v.visit_date, f.url, v.session, null "
+        "FROM moz_places h "
+        "LEFT JOIN moz_historyvisits_temp v_t ON h.id = v_t.place_id "
+        "LEFT JOIN moz_historyvisits v ON h.id = v.place_id "
+        "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
+        "WHERE v.id = ?1 OR v_t.id = ?1 "
+      "LIMIT 1"),
+    getter_AddRefs(mDBVisitToVisitResult));
+  NS_ENSURE_SUCCESS(rv, nsnull);
+
+  return mDBVisitToVisitResult;
+}
+
+mozIStorageStatement *
+nsNavHistory::GetDBVisitToURLResult()
+{
+  if (mDBVisitToURLResult)
+    return mDBVisitToURLResult;
+
+  // mDBVisitToURLResult, should match kGetInfoIndex_* (see GetQueryResults)
+  // We are not checking for duplicated ids into the unified table
+  // for perf reasons, LIMIT 1 will discard duplicates faster since we
+  // have unique visit ids.
+  nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, "
+          SQL_STR_FRAGMENT_MAX_VISIT_DATE( "h.id" )
+          ", f.url, null, null "
+        "FROM moz_places_temp h "
+        "LEFT JOIN moz_historyvisits_temp v_t ON h.id = v_t.place_id "
+        "LEFT JOIN moz_historyvisits v ON h.id = v.place_id "
+        "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
+        "WHERE v.id = ?1 OR v_t.id = ?1 "
+      "UNION ALL "
+      "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, "
+          SQL_STR_FRAGMENT_MAX_VISIT_DATE( "h.id" )
+          ", f.url, null, null "
+        "FROM moz_places h "
+        "LEFT JOIN moz_historyvisits_temp v_t ON h.id = v_t.place_id "
+        "LEFT JOIN moz_historyvisits v ON h.id = v.place_id "
+        "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
+        "WHERE v.id = ?1 OR v_t.id = ?1 "
+      "LIMIT 1"),
+    getter_AddRefs(mDBVisitToURLResult));
+  NS_ENSURE_SUCCESS(rv, nsnull);
+
+  return mDBVisitToURLResult;
+}
+
+mozIStorageStatement *
+nsNavHistory::GetDBBookmarkToUrlResult()
+{
+  if (mDBBookmarkToUrlResult)
+    return mDBBookmarkToUrlResult;
+
+  // mDBBookmarkToUrlResult, should match kGetInfoIndex_*
+  // We are not checking for duplicated ids into the unified table
+  // for perf reasons, LIMIT 1 will discard duplicates faster since we
+  // have unique place ids.
+  nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "SELECT b.fk, h.url, COALESCE(b.title, h.title), "
+        "h.rev_host, h.visit_count, "
+        SQL_STR_FRAGMENT_MAX_VISIT_DATE( "b.fk" )
+        ", f.url, null, b.id, b.dateAdded, b.lastModified "
+      "FROM moz_bookmarks b "
+      "JOIN moz_places_temp h ON b.fk = h.id "
+      "LEFT OUTER JOIN moz_favicons f ON h.favicon_id = f.id "
+      "WHERE b.id = ?1 "
+      "UNION ALL "
+      "SELECT b.fk, h.url, COALESCE(b.title, h.title), "
+        "h.rev_host, h.visit_count, "
+        SQL_STR_FRAGMENT_MAX_VISIT_DATE( "b.fk" )
+        ", f.url, null, b.id, b.dateAdded, b.lastModified "
+      "FROM moz_bookmarks b "
+      "JOIN moz_places h ON b.fk = h.id "
+      "LEFT OUTER JOIN moz_favicons f ON h.favicon_id = f.id "
+      "WHERE b.id = ?1 "
+      "LIMIT 1"),
+    getter_AddRefs(mDBBookmarkToUrlResult));
+  NS_ENSURE_SUCCESS(rv, nsnull);
+
+  return mDBBookmarkToUrlResult;
+}
+
+mozIStorageStatement *
+nsNavHistory::GetDBInvalidFrecencies()
+{
+  if (mDBInvalidFrecencies)
+    return mDBInvalidFrecencies;
+
+  // find places with invalid frecencies (frecency < 0)
+  // invalid frecencies can happen in these scenarios:
+  // 1) we've done "clear private data"
+  // 2) we've expired or deleted visits
+  // 3) we've migrated from an older version, before global frecency
+  //
+  // from older versions, unmigrated bookmarks might be hidden,
+  // so we can't exclude hidden places (by doing "WHERE hidden <> 1")
+  // from our query, as we want to calculate the frecency for those
+  // places and unhide them (if they are not livemark items and not
+  // place: queries.)
+  //
+  // Note, we are not limiting ourselves to places with visits
+  // because we may not have any if the place is a bookmark and
+  // we expired or deleted all the visits. 
+  // We get two sets of places that are 1) most visited and 2) random so that
+  // we don't get stuck recalculating frecencies that end up being -1 every
+  // time
+  // Since we don't need real random results and ORDER BY RANDOM() is slow
+  // we will jump at a random rowid in the table and we will get random results
+  // only from moz_places since temp will be synched there sometimes.  
+  // Notice that frecency is invalidated as frecency = -visit_count
+  nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+      "SELECT * FROM ( "
+        "SELECT id, visit_count, hidden, typed, frecency, url "
+        "FROM ( "
+          "SELECT * FROM moz_places_temp "
+          "WHERE frecency < 0 "
+          "UNION ALL "
+          "SELECT * FROM ( "
+            "SELECT * FROM moz_places "
+            "WHERE +id NOT IN (SELECT id FROM moz_places_temp) "
+            "AND frecency < 0 "
+            "ORDER BY frecency ASC LIMIT ROUND(?1 / 2) "
+          ") "
+        ") ORDER BY frecency ASC LIMIT ROUND(?1 / 2)) "
+      "UNION "
+      "SELECT * FROM ( "
+        "SELECT id, visit_count, hidden, typed, frecency, url "
+        "FROM moz_places "
+        "WHERE frecency < 0 "
+        "AND ROWID >= ABS(RANDOM() % (SELECT MAX(ROWID) FROM moz_places)) "
+        "LIMIT ROUND(?1 / 2))"),
+    getter_AddRefs(mDBInvalidFrecencies));
+  NS_ENSURE_SUCCESS(rv, nsnull);
+
+  return mDBInvalidFrecencies;
+}
+
+mozIStorageStatement *
+nsNavHistory::GetDBOldFrecencies()
+{
+  if (mDBOldFrecencies)
+    return mDBOldFrecencies;
+
+  // This query finds random old places to update frecency because frequently
+  // visited places will have their frecencies updated when visited.
+  // We can limit the selection to moz_places since results in temp tables
+  // have been most likely visited recently.
+  // Since we don't need real random results and ORDER BY RANDOM() is slow
+  // we will jump at a random rowid in the table.
+  nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT id, visit_count, hidden, typed, frecency, url "
+     "FROM moz_places "
+     "WHERE ROWID >= ABS(RANDOM() % (SELECT MAX(ROWID) FROM moz_places)) "
+     "LIMIT ?1"),
+    getter_AddRefs(mDBOldFrecencies));
+  NS_ENSURE_SUCCESS(rv, nsnull);
+
+  return mDBOldFrecencies;
+}
+
 // nsICharsetResolver **********************************************************
 
 NS_IMETHODIMP
diff -r 17e9560465b0 toolkit/components/places/src/nsNavHistory.h
--- a/toolkit/components/places/src/nsNavHistory.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/components/places/src/nsNavHistory.h	Thu Oct 30 05:41:46 2008 -0400
@@ -108,9 +108,14 @@
 // this is a work-around for a problem with the optimizer of sqlite
 // A sub-select on MAX(visit_date) is slower than this query with our indexes
 // see Bug #392399 for more details
-#define SQL_STR_FRAGMENT_MAX_VISIT_DATE( place_relation ) \
-  "(SELECT visit_date FROM moz_historyvisits WHERE place_id = " place_relation \
+#define SQL_STR_FRAGMENT_MAX_VISIT_DATE_BASE( __place_relation, __table_name ) \
+  "(SELECT visit_date FROM " __table_name \
+  " WHERE place_id = " __place_relation \
   " AND visit_type NOT IN (0,4,7) ORDER BY visit_date DESC LIMIT 1)"
+
+#define SQL_STR_FRAGMENT_MAX_VISIT_DATE( __place_relation ) \
+  "IFNULL( " SQL_STR_FRAGMENT_MAX_VISIT_DATE_BASE( __place_relation, "moz_historyvisits_temp") \
+          ", " SQL_STR_FRAGMENT_MAX_VISIT_DATE_BASE( __place_relation, "moz_historyvisits") ")"
 
 // This magic number specified an uninitialized value for the
 // mInPrivateBrowsing member
@@ -240,17 +245,13 @@
 
   /**
    * These functions return non-owning references to the locale-specific
-   * objects for places components. Guaranteed to return non-NULL.
+   * objects for places components.
    */
-  nsIStringBundle* GetBundle()
-    { return mBundle; }
-  nsILocale* GetLocale()
-    { return mLocale; }
-  nsICollation* GetCollation()
-    { return mCollation; }
-  nsIDateTimeFormat* GetDateFormatter()
-    { return mDateFormatter; }
+  nsIStringBundle* GetBundle();
+  nsICollation* GetCollation();
   void GetStringFromName(const PRUnichar* aName, nsACString& aResult);
+  void GetAgeInDaysString(PRInt32 aInt, const PRUnichar *aName,
+                          nsACString& aResult);
 
   // returns true if history has been disabled
   PRBool IsHistoryDisabled() { return mExpireDaysMax == 0 || InPrivateBrowsingMode(); }
@@ -427,11 +428,15 @@
   nsCOMPtr<mozIStorageStatement> mDBAddNewPage; // used by InternalAddNewPage
   nsCOMPtr<mozIStorageStatement> mDBGetTags; // used by FilterResultSet
   nsCOMPtr<mozIStorageStatement> mFoldersWithAnnotationQuery;  // used by StartSearch and FilterResultSet
+  nsCOMPtr<mozIStorageStatement> mDBSetPlaceTitle; // used by SetPageTitleInternal
 
   // these are used by VisitIdToResultNode for making new result nodes from IDs
+  // Consumers need to use the getters since these statements are lazily created
+  mozIStorageStatement *GetDBVisitToURLResult();
   nsCOMPtr<mozIStorageStatement> mDBVisitToURLResult; // kGetInfoIndex_* results
+  mozIStorageStatement *GetDBVisitToVisitResult();
   nsCOMPtr<mozIStorageStatement> mDBVisitToVisitResult; // kGetInfoIndex_* results
-  nsCOMPtr<mozIStorageStatement> mDBUrlToUrlResult; // kGetInfoIndex_* results
+  mozIStorageStatement *GetDBBookmarkToUrlResult();
   nsCOMPtr<mozIStorageStatement> mDBBookmarkToUrlResult; // kGetInfoIndex_* results
 
   // nsICharsetResolver
@@ -452,12 +457,14 @@
   nsresult CalculateFrecency(PRInt64 aPageID, PRInt32 aTyped, PRInt32 aVisitCount, nsCAutoString &aURL, PRInt32 *aFrecency);
   nsresult CalculateFrecencyInternal(PRInt64 aPageID, PRInt32 aTyped, PRInt32 aVisitCount, PRBool aIsBookmarked, PRInt32 *aFrecency);
   nsCOMPtr<mozIStorageStatement> mDBVisitsForFrecency;
-  nsCOMPtr<mozIStorageStatement> mDBInvalidFrecencies;
-  nsCOMPtr<mozIStorageStatement> mDBOldFrecencies;
   nsCOMPtr<mozIStorageStatement> mDBUpdateFrecencyAndHidden;
   nsCOMPtr<mozIStorageStatement> mDBGetPlaceVisitStats;
   nsCOMPtr<mozIStorageStatement> mDBGetBookmarkParentsForPlace;
   nsCOMPtr<mozIStorageStatement> mDBFullVisitCount;
+  mozIStorageStatement *GetDBInvalidFrecencies();
+  nsCOMPtr<mozIStorageStatement> mDBInvalidFrecencies;
+  mozIStorageStatement *GetDBOldFrecencies();
+  nsCOMPtr<mozIStorageStatement> mDBOldFrecencies;
 
   /**
    * Initializes the database file.  If the database does not exist, was
@@ -486,12 +493,15 @@
    *          The database was migrated to a new version.
    */
   nsresult InitDB(PRInt16 *aMadeChanges);
+  nsresult InitTempTables();
+  nsresult InitViews();
   nsresult InitFunctions();
   nsresult InitStatements();
   nsresult ForceMigrateBookmarksDB(mozIStorageConnection *aDBConn);
   nsresult MigrateV3Up(mozIStorageConnection *aDBConn);
   nsresult MigrateV6Up(mozIStorageConnection *aDBConn);
   nsresult MigrateV7Up(mozIStorageConnection *aDBConn);
+  nsresult MigrateV8Up(mozIStorageConnection *aDBConn);
   nsresult EnsureCurrentSchema(mozIStorageConnection* aDBConn, PRBool *aMadeChanges);
   nsresult CleanUpOnQuit();
 
@@ -605,9 +615,6 @@
                          nsNavHistoryQueryOptions* aOptions,
                          nsCOMArray<nsNavHistoryResultNode>* aResults);
 
-  void GetAgeInDaysString(PRInt32 aInt, const PRUnichar *aName, 
-                          nsACString& aResult);
-
   void TitleForDomain(const nsCString& domain, nsACString& aTitle);
 
   nsresult SetPageTitleInternal(nsIURI* aURI, const nsAString& aTitle);
@@ -627,9 +634,7 @@
 
   // localization
   nsCOMPtr<nsIStringBundle> mBundle;
-  nsCOMPtr<nsILocale> mLocale;
   nsCOMPtr<nsICollation> mCollation;
-  nsCOMPtr<nsIDateTimeFormat> mDateFormatter;
 
   // annotation service : MAY BE NULL!
   //nsCOMPtr<mozIAnnotationService> mAnnotationService;
@@ -672,12 +677,16 @@
   static const PRInt32 kAutoCompleteIndex_VisitCount;
   nsCOMPtr<mozIStorageStatement> mDBCurrentQuery; //  kAutoCompleteIndex_* results
   nsCOMPtr<mozIStorageStatement> mDBAutoCompleteQuery; //  kAutoCompleteIndex_* results
+  mozIStorageStatement* GetDBAutoCompleteHistoryQuery();
   nsCOMPtr<mozIStorageStatement> mDBAutoCompleteHistoryQuery; //  kAutoCompleteIndex_* results
+  mozIStorageStatement* GetDBAutoCompleteStarQuery();
   nsCOMPtr<mozIStorageStatement> mDBAutoCompleteStarQuery; //  kAutoCompleteIndex_* results
+  mozIStorageStatement* GetDBAutoCompleteTagsQuery();
   nsCOMPtr<mozIStorageStatement> mDBAutoCompleteTagsQuery; //  kAutoCompleteIndex_* results
   nsCOMPtr<mozIStorageStatement> mDBPreviousQuery; //  kAutoCompleteIndex_* results
   nsCOMPtr<mozIStorageStatement> mDBAdaptiveQuery; //  kAutoCompleteIndex_* results
   nsCOMPtr<mozIStorageStatement> mDBKeywordQuery; //  kAutoCompleteIndex_* results
+  mozIStorageStatement* GetDBFeedbackIncrease();
   nsCOMPtr<mozIStorageStatement> mDBFeedbackIncrease;
 
   /**
diff -r 17e9560465b0 toolkit/components/places/src/nsNavHistoryAutoComplete.cpp
--- a/toolkit/components/places/src/nsNavHistoryAutoComplete.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/components/places/src/nsNavHistoryAutoComplete.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -27,6 +27,7 @@
  *   Dietrich Ayala <dietrich@mozilla.com>
  *   Edward Lee <edward.lee@engineering.uiuc.edu>
  *   Ehsan Akhgari <ehsan.akhgari@gmail.com>
+ *   Marco Bonardo <mak77@bonardo.net>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -93,7 +94,7 @@
     NS_LITERAL_CSTRING(" AND b.fk = h.id") + \
   (getMostRecent ? NS_LITERAL_CSTRING(" " \
     "ORDER BY b.lastModified DESC LIMIT 1") : EmptyCString()) + \
-  NS_LITERAL_CSTRING(") " name)
+  NS_LITERAL_CSTRING(") AS " name)
 
 // Get three named columns from the bookmarks and tags table
 #define BOOK_TAG_SQL (\
@@ -107,6 +108,49 @@
 // Use a Unichar array to avoid problems with 2-byte char strings: " \u2013 "
 const PRUnichar kTitleTagsSeparatorChars[] = { ' ', 0x2013, ' ', 0 };
 #define TITLE_TAGS_SEPARATOR nsAutoString(kTitleTagsSeparatorChars)
+
+// This fragment is used to get best favicon for a rev_host
+#define BEST_FAVICON_FOR_REVHOST( __table_name ) \
+  "(SELECT f.url FROM " __table_name " " \
+   "JOIN moz_favicons f ON f.id = favicon_id " \
+   "WHERE rev_host = IFNULL( " \
+     "(SELECT rev_host FROM moz_places_temp WHERE id = b.fk), " \
+     "(SELECT rev_host FROM moz_places WHERE id = b.fk)) " \
+   "ORDER BY frecency DESC LIMIT 1) "
+
+void GetAutoCompleteBaseQuery(nsACString& aQuery) {
+// Define common pieces of various queries
+// XXX bug 412736
+// in the case of a frecency tie, break it with h.typed and h.visit_count
+// which is better than nothing.  but this is slow, so not doing it yet.
+
+// Try to reduce size of compound table since with partitioning this became
+// slower. Limiting moz_places with OFFSET+LIMIT will mostly help speed
+// of first chunks, that are usually most wanted.
+// Can do this only if there aren't additional conditions on final resultset.
+
+// Note: h.frecency is selected because we need it for ordering, but will
+// not be read later and we don't have an associated kAutoCompleteIndex_
+  aQuery = NS_LITERAL_CSTRING(
+      "SELECT h.url, h.title, f.url") + BOOK_TAG_SQL + NS_LITERAL_CSTRING(", "
+        "h.visit_count, h.frecency "
+      "FROM moz_places_temp h "
+      "LEFT OUTER JOIN moz_favicons f ON f.id = h.favicon_id "
+      "WHERE h.frecency <> 0 "
+      "{ADDITIONAL_CONDITIONS} "
+      "UNION ALL "
+      "SELECT * FROM ( "
+        "SELECT h.url, h.title, f.url") + BOOK_TAG_SQL + NS_LITERAL_CSTRING(", "
+          "h.visit_count, h.frecency "
+        "FROM moz_places h "
+        "LEFT OUTER JOIN moz_favicons f ON f.id = h.favicon_id "
+        "WHERE h.id NOT IN (SELECT id FROM moz_places_temp) "
+        "AND h.frecency <> 0 "
+        "{ADDITIONAL_CONDITIONS} "
+        "ORDER BY h.frecency DESC LIMIT (?2 + ?3) "
+      ") "
+      "ORDER BY 8 DESC LIMIT ?2 OFFSET ?3");
+}
 
 ////////////////////////////////////////////////////////////////////////////////
 //// nsNavHistoryAutoComplete Helper Functions
@@ -254,92 +298,157 @@
   return NS_OK;
 }
 
+// nsNavHistory::GetDBAutoCompleteHistoryQuery()
+//
+//    Returns the auto complete statement used when autocomplete results are
+//    restricted to history entries.
+mozIStorageStatement*
+nsNavHistory::GetDBAutoCompleteHistoryQuery()
+{
+  if (mDBAutoCompleteHistoryQuery)
+    return mDBAutoCompleteHistoryQuery;
+
+  nsCString AutoCompleteHistoryQuery;
+  GetAutoCompleteBaseQuery(AutoCompleteHistoryQuery);
+  AutoCompleteHistoryQuery.ReplaceSubstring("{ADDITIONAL_CONDITIONS}",
+                                            "AND h.visit_count > 0");
+  nsresult rv = mDBConn->CreateStatement(AutoCompleteHistoryQuery,
+    getter_AddRefs(mDBAutoCompleteHistoryQuery));
+  NS_ENSURE_SUCCESS(rv, nsnull);
+
+  return mDBAutoCompleteHistoryQuery;
+}
+
+// nsNavHistory::GetDBAutoCompleteStarQuery()
+//
+//    Returns the auto complete statement used when autocomplete results are
+//    restricted to bookmarked entries.
+mozIStorageStatement*
+nsNavHistory::GetDBAutoCompleteStarQuery()
+{
+  if (mDBAutoCompleteStarQuery)
+    return mDBAutoCompleteStarQuery;
+
+  nsCString AutoCompleteStarQuery;
+  GetAutoCompleteBaseQuery(AutoCompleteStarQuery);
+  AutoCompleteStarQuery.ReplaceSubstring("{ADDITIONAL_CONDITIONS}",
+                                         "AND bookmark IS NOT NULL");
+  nsresult rv = mDBConn->CreateStatement(AutoCompleteStarQuery,
+    getter_AddRefs(mDBAutoCompleteStarQuery));
+  NS_ENSURE_SUCCESS(rv, nsnull);
+
+  return mDBAutoCompleteStarQuery;
+}
+
+// nsNavHistory::GetDBAutoCompleteTagsQuery()
+//
+//    Returns the auto complete statement used when autocomplete results are
+//    restricted to tagged entries.
+mozIStorageStatement*
+nsNavHistory::GetDBAutoCompleteTagsQuery()
+{
+  if (mDBAutoCompleteTagsQuery)
+    return mDBAutoCompleteTagsQuery;
+
+  nsCString AutoCompleteTagsQuery;
+  GetAutoCompleteBaseQuery(AutoCompleteTagsQuery);
+  AutoCompleteTagsQuery.ReplaceSubstring("{ADDITIONAL_CONDITIONS}",
+                                         "AND tags IS NOT NULL");
+  nsresult rv = mDBConn->CreateStatement(AutoCompleteTagsQuery,
+    getter_AddRefs(mDBAutoCompleteTagsQuery));
+  NS_ENSURE_SUCCESS(rv, nsnull);
+
+  return mDBAutoCompleteTagsQuery;
+}
+
+// nsNavHistory::GetDBFeedbackIncrease()
+//
+//    Returns the statement to update the input history that keeps track of
+//    selections in the locationbar.  Input history is used for adaptive query.
+mozIStorageStatement*
+nsNavHistory::GetDBFeedbackIncrease()
+{
+  if (mDBFeedbackIncrease)
+    return mDBFeedbackIncrease;
+
+  nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+    // Leverage the PRIMARY KEY (place_id, input) to insert/update entries
+    "INSERT OR REPLACE INTO moz_inputhistory "
+      // use_count will asymptotically approach the max of 10
+      "SELECT h.id, IFNULL(i.input, ?1), IFNULL(i.use_count, 0) * .9 + 1 "
+      "FROM moz_places_temp h "
+      "LEFT JOIN moz_inputhistory i ON i.place_id = h.id AND i.input = ?1 "
+      "WHERE url = ?2 "
+      "UNION ALL "
+      "SELECT h.id, IFNULL(i.input, ?1), IFNULL(i.use_count, 0) * .9 + 1 "
+      "FROM moz_places h "
+      "LEFT JOIN moz_inputhistory i ON i.place_id = h.id AND i.input = ?1 "
+      "WHERE url = ?2 "
+        "AND h.id NOT IN (SELECT id FROM moz_places_temp)"),
+    getter_AddRefs(mDBFeedbackIncrease));
+  NS_ENSURE_SUCCESS(rv, nsnull);
+
+  return mDBFeedbackIncrease;
+}
 
 // nsNavHistory::CreateAutoCompleteQueries
 //
 //    The auto complete queries we use depend on options, so we have them in
 //    a separate function so it can be re-created when the option changes.
-
+//    We are not lazy creating these queries because they will be most likely
+//    used on first search, and we don't want to lag on first autocomplete use.
 nsresult
 nsNavHistory::CreateAutoCompleteQueries()
 {
-  // Define common pieces of various queries
-  nsCString sqlHead = NS_LITERAL_CSTRING(
-    "SELECT h.url, h.title, f.url") + BOOK_TAG_SQL + NS_LITERAL_CSTRING(", "
-      "h.visit_count "
-    "FROM moz_places h "
-    "LEFT OUTER JOIN moz_favicons f ON f.id = h.favicon_id "
-    "WHERE h.frecency <> 0 ");
-  // NOTE:
-  // after migration or clear all private data, we might end up with
-  // a lot of places with frecency < 0 (until idle)
-  //
-  // XXX bug 412736
-  // in the case of a frecency tie, break it with h.typed and h.visit_count
-  // which is better than nothing.  but this is slow, so not doing it yet.
-  nsCString sqlTail = NS_LITERAL_CSTRING(
-    "ORDER BY h.frecency DESC LIMIT ?2 OFFSET ?3");
-
-  nsresult rv = mDBConn->CreateStatement(sqlHead + (mAutoCompleteOnlyTyped ?
-      NS_LITERAL_CSTRING("AND h.typed = 1 ") : EmptyCString()) + sqlTail,
-    getter_AddRefs(mDBAutoCompleteQuery));
+  nsCString AutoCompleteQuery;
+  GetAutoCompleteBaseQuery(AutoCompleteQuery);
+  AutoCompleteQuery.ReplaceSubstring("{ADDITIONAL_CONDITIONS}",
+                                     (mAutoCompleteOnlyTyped ?
+                                        "AND h.typed = 1" : ""));
+  nsresult rv = mDBConn->CreateStatement(AutoCompleteQuery,
+                                getter_AddRefs(mDBAutoCompleteQuery));
   NS_ENSURE_SUCCESS(rv, rv);
 
-  rv = mDBConn->CreateStatement(sqlHead +
-      NS_LITERAL_CSTRING("AND h.visit_count > 0 ") + sqlTail,
-    getter_AddRefs(mDBAutoCompleteHistoryQuery));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  rv = mDBConn->CreateStatement(sqlHead +
-      NS_LITERAL_CSTRING("AND bookmark IS NOT NULL ") + sqlTail,
-    getter_AddRefs(mDBAutoCompleteStarQuery));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  rv = mDBConn->CreateStatement(sqlHead +
-      NS_LITERAL_CSTRING("AND tags IS NOT NULL ") + sqlTail,
-    getter_AddRefs(mDBAutoCompleteTagsQuery));
-  NS_ENSURE_SUCCESS(rv, rv);
-
+  // In this query we are taking BOOK_TAG_SQL only for h.id because it
+  // uses data from moz_bookmarks table and we sync tables on bookmark insert.
+  // So, most likely, h.id will always be populated when we have any bookmark.
+  // We still need to join on moz_places_temp for other data (eg. title).
   nsCString sql = NS_LITERAL_CSTRING(
-    "SELECT h.url, h.title, f.url") + BOOK_TAG_SQL + NS_LITERAL_CSTRING(", "
-      "h.visit_count, "
-      "ROUND(MAX(((i.input = ?2) + (SUBSTR(i.input, 1, LENGTH(?2)) = ?2)) * "
-                "i.use_count), 1) rank "
-    "FROM moz_inputhistory i "
-    "JOIN moz_places h ON h.id = i.place_id "
-    "LEFT OUTER JOIN moz_favicons f ON f.id = h.favicon_id "
-    "GROUP BY i.place_id HAVING rank > 0 "
-    "ORDER BY rank DESC, h.frecency DESC");
+    "SELECT IFNULL(h_t.url, h.url), IFNULL(h_t.title, h.title), f.url ") +
+      BOOK_TAG_SQL + NS_LITERAL_CSTRING(", "
+      "IFNULL(h_t.visit_count, h.visit_count), rank "
+    "FROM ( "
+      "SELECT ROUND(MAX(((i.input = ?2) + (SUBSTR(i.input, 1, LENGTH(?2)) = ?2)) * "
+        "i.use_count), 1) AS rank, place_id "
+      "FROM moz_inputhistory i "
+      "GROUP BY i.place_id HAVING rank > 0 "
+      ") AS i "
+    "LEFT JOIN moz_places h ON h.id = i.place_id "
+    "LEFT JOIN moz_places_temp h_t ON h_t.id = i.place_id "
+    "LEFT JOIN moz_favicons f ON f.id = IFNULL(h_t.favicon_id, h.favicon_id) "
+    "WHERE IFNULL(h_t.url, h.url) NOTNULL "
+    "ORDER BY rank DESC, IFNULL(h_t.frecency, h.frecency) DESC");
   rv = mDBConn->CreateStatement(sql, getter_AddRefs(mDBAdaptiveQuery));
   NS_ENSURE_SUCCESS(rv, rv);
 
   sql = NS_LITERAL_CSTRING(
-    "SELECT REPLACE(s.url, '%s', ?2) search_url, h.title, IFNULL(f.url, "
-      "(SELECT f.url "
-       "FROM moz_places r "
-       "JOIN moz_favicons f ON f.id = r.favicon_id "
-       "WHERE r.rev_host = s.rev_host "
-       "ORDER BY r.frecency DESC LIMIT 1)), "
-      "b.parent, b.title, NULL, h.visit_count "
+    "SELECT IFNULL( "
+        "(SELECT REPLACE(url, '%s', ?2) FROM moz_places_temp WHERE id = b.fk), "
+        "(SELECT REPLACE(url, '%s', ?2) FROM moz_places WHERE id = b.fk) "
+      ") AS search_url, IFNULL(h_t.title, h.title), "
+      "COALESCE(f.url, "
+        BEST_FAVICON_FOR_REVHOST("moz_places_temp") ", "
+        BEST_FAVICON_FOR_REVHOST("moz_places")
+      "), "
+      "b.parent, b.title, NULL, IFNULL(h_t.visit_count, h.visit_count) "
     "FROM moz_keywords k "
     "JOIN moz_bookmarks b ON b.keyword_id = k.id "
-    "JOIN moz_places s ON s.id = b.fk "
-    "LEFT OUTER JOIN moz_places h ON h.url = search_url "
-    "LEFT OUTER JOIN moz_favicons f ON f.id = h.favicon_id "
+    "LEFT JOIN moz_places AS h ON h.url = search_url "
+    "LEFT JOIN moz_places_temp AS h_t ON h_t.url = search_url "
+    "LEFT JOIN moz_favicons f ON f.id = IFNULL(h_t.favicon_id, h.favicon_id) "
     "WHERE LOWER(k.keyword) = LOWER(?1) "
-    "ORDER BY h.frecency DESC");
+    "ORDER BY IFNULL(h_t.frecency, h.frecency) DESC");
   rv = mDBConn->CreateStatement(sql, getter_AddRefs(mDBKeywordQuery));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  sql = NS_LITERAL_CSTRING(
-    // Leverage the PRIMARY KEY (place_id, input) to insert/update entries
-    "INSERT OR REPLACE INTO moz_inputhistory "
-    // use_count will asymptotically approach the max of 10
-    "SELECT h.id, IFNULL(i.input, ?1), IFNULL(i.use_count, 0) * .9 + 1 "
-    "FROM moz_places h "
-    "LEFT OUTER JOIN moz_inputhistory i ON i.place_id = h.id AND i.input = ?1 "
-    "WHERE h.url = ?2");
-  rv = mDBConn->CreateStatement(sql, getter_AddRefs(mDBFeedbackIncrease));
   NS_ENSURE_SUCCESS(rv, rv);
 
   return NS_OK;
@@ -538,23 +647,30 @@
       // has more than 0 results. We can continue from where the previous
       // search left off, but first we want to create an optimized query that
       // only searches through the urls that were previously found
+
+      // We have to do the bindings for both tables, so we build a temporary
+      // string
+      nsCString bindings;
+      for (PRUint32 i = 0; i < prevMatchCount; i++) {
+        if (i)
+          bindings += NS_LITERAL_CSTRING(",");
+
+        // +2 to skip over the ?1 for the tag root parameter
+        bindings += nsPrintfCString("?%d", i + 2);
+      }
+
       nsCString sql = NS_LITERAL_CSTRING(
         "SELECT h.url, h.title, f.url") + BOOK_TAG_SQL + NS_LITERAL_CSTRING(", "
           "h.visit_count "
-        "FROM moz_places h "
+        "FROM ( "
+          "SELECT * FROM moz_places_temp "
+          "WHERE url IN (") + bindings + NS_LITERAL_CSTRING(") "
+          "UNION ALL "
+          "SELECT * FROM moz_places "
+          "WHERE id NOT IN (SELECT id FROM moz_places_temp) "
+          "AND url IN (") + bindings + NS_LITERAL_CSTRING(") "
+        ") AS h "
         "LEFT OUTER JOIN moz_favicons f ON f.id = h.favicon_id "
-        "WHERE h.url IN (");
-
-      // Put in bind spots for the urls
-      for (PRUint32 i = 0; i < prevMatchCount; i++) {
-        if (i)
-          sql += NS_LITERAL_CSTRING(",");
-
-        // +2 to skip over the ?1 for the tag root parameter
-        sql += nsPrintfCString("?%d", i + 2);
-      }
-
-      sql += NS_LITERAL_CSTRING(") "
         "ORDER BY h.frecency DESC");
 
       rv = mDBConn->CreateStatement(sql, getter_AddRefs(mDBPreviousQuery));
@@ -704,10 +820,10 @@
 
   // We can use optimized queries for restricts, so check for the most
   // restrictive query first
-  mDBCurrentQuery = mRestrictTag ? mDBAutoCompleteTagsQuery :
-    mRestrictBookmark ? mDBAutoCompleteStarQuery :
-    mRestrictHistory ? mDBAutoCompleteHistoryQuery :
-    mDBAutoCompleteQuery;
+  mDBCurrentQuery = mRestrictTag ? GetDBAutoCompleteTagsQuery() :
+    mRestrictBookmark ? GetDBAutoCompleteStarQuery() :
+    mRestrictHistory ? GetDBAutoCompleteHistoryQuery() :
+    static_cast<mozIStorageStatement *>(mDBAutoCompleteQuery);
 }
 
 nsresult
@@ -1014,21 +1130,22 @@
   if (InPrivateBrowsingMode())
     return NS_OK;
 
-  mozStorageStatementScoper scope(mDBFeedbackIncrease);
+  mozIStorageStatement *stmt = GetDBFeedbackIncrease();
+  mozStorageStatementScoper scope(stmt);
 
   nsAutoString input;
   nsresult rv = aController->GetSearchString(input);
   NS_ENSURE_SUCCESS(rv, rv);
-  rv = mDBFeedbackIncrease->BindStringParameter(0, input);
+  rv = stmt->BindStringParameter(0, input);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsAutoString url;
   rv = aController->GetValueAt(aIndex, url);
   NS_ENSURE_SUCCESS(rv, rv);
-  rv = mDBFeedbackIncrease->BindStringParameter(1, url);
+  rv = stmt->BindStringParameter(1, url);
   NS_ENSURE_SUCCESS(rv, rv);
 
-  rv = mDBFeedbackIncrease->Execute();
+  rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
 
   return NS_OK;
diff -r 17e9560465b0 toolkit/components/places/src/nsNavHistoryExpire.cpp
--- a/toolkit/components/places/src/nsNavHistoryExpire.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/components/places/src/nsNavHistoryExpire.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -252,20 +252,29 @@
   // idle query to figure out which places to recalcuate frecency first.
   // We must do this before deleting visits
   nsresult rv = connection->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
-    "UPDATE moz_places SET frecency = -MAX(visit_count, 1) "
+    "UPDATE moz_places_view SET frecency = -MAX(visit_count, 1) "
     "WHERE id IN("
-      "SELECT h.id FROM moz_places h WHERE "
+      "SELECT h.id FROM moz_places_temp h "
+      "WHERE "
         "EXISTS (SELECT id FROM moz_bookmarks WHERE fk = h.id) "
         "OR EXISTS "
-        "(SELECT id FROM moz_annos WHERE place_id = h.id AND expiration = ") +
-      nsPrintfCString("%d", nsIAnnotationService::EXPIRE_NEVER) +
-      NS_LITERAL_CSTRING(")"));
-  if (NS_FAILED(rv))
-    NS_WARNING("failed to recent frecency");
+          "(SELECT id FROM moz_annos WHERE place_id = h.id AND expiration = ") +
+          nsPrintfCString("%d", nsIAnnotationService::EXPIRE_NEVER) +
+          NS_LITERAL_CSTRING(") "
+      "UNION ALL "
+      "SELECT h.id FROM moz_places h "
+      "WHERE "
+        "EXISTS (SELECT id FROM moz_bookmarks WHERE fk = h.id) "
+        "OR EXISTS "
+          "(SELECT id FROM moz_annos WHERE place_id = h.id AND expiration = ") +
+          nsPrintfCString("%d", nsIAnnotationService::EXPIRE_NEVER) +
+          NS_LITERAL_CSTRING(") "
+    ")"));
+  NS_ENSURE_SUCCESS(rv, rv);
 
   // expire visits, then let the paranoid functions do the cleanup for us
   rv = connection->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
-      "DELETE FROM moz_historyvisits"));
+      "DELETE FROM moz_historyvisits_view"));
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = ExpireHistoryParanoid(connection, -1);
@@ -471,11 +480,38 @@
   // Select a limited number of visits older than a time
   nsCOMPtr<mozIStorageStatement> selectStatement;
   nsresult rv = aConnection->CreateStatement(NS_LITERAL_CSTRING(
-      "SELECT v.id, v.place_id, v.visit_date, h.url, h.favicon_id, h.hidden, "
-        "(SELECT fk FROM moz_bookmarks WHERE fk = h.id) "
-      "FROM moz_places h JOIN moz_historyvisits v ON h.id = v.place_id "
-      "WHERE v.visit_date < ?1 "
-      "ORDER BY v.visit_date ASC LIMIT ?2"),
+      "SELECT * FROM ( "
+        "SELECT v.id, v.place_id, v.visit_date, h.url, h.favicon_id, h.hidden, "
+          "(SELECT fk FROM moz_bookmarks WHERE fk = h.id) "
+        "FROM moz_places h "
+        "JOIN moz_historyvisits AS v ON h.id = v.place_id "
+        "WHERE visit_date < ?1 "      
+        "ORDER BY v.visit_date ASC LIMIT ?2 "
+      ") UNION ALL "
+        "SELECT * FROM ( "
+        "SELECT v.id, v.place_id, v.visit_date, h.url, h.favicon_id, h.hidden, "
+          "(SELECT fk FROM moz_bookmarks WHERE fk = h.id)"
+        "FROM moz_places_temp h "
+        "JOIN moz_historyvisits AS v ON h.id = v.place_id "
+        "WHERE visit_date < ?1 "
+        "ORDER BY v.visit_date ASC LIMIT ?2 "
+      ") UNION ALL "
+      "SELECT * FROM ( "
+        "SELECT v.id, v.place_id, v.visit_date, h.url, h.favicon_id, h.hidden, "
+          "(SELECT fk FROM moz_bookmarks WHERE fk = h.id) "
+        "FROM moz_places h "
+        "JOIN moz_historyvisits_temp AS v ON h.id = v.place_id "
+        "WHERE visit_date < ?1 "
+        "ORDER BY v.visit_date ASC LIMIT ?2 "
+      ") UNION ALL "
+      "SELECT * FROM ( "
+        "SELECT v.id, v.place_id, v.visit_date, h.url, h.favicon_id, h.hidden, "
+          "(SELECT fk FROM moz_bookmarks WHERE fk = h.id) "
+        "FROM moz_places_temp h "
+        "JOIN moz_historyvisits_temp AS v ON h.id = v.place_id "
+        "WHERE visit_date < ?1 "
+        "ORDER BY v.visit_date ASC LIMIT ?2 "
+      ") GROUP BY 1 ORDER BY 3 ASC LIMIT ?2"),
     getter_AddRefs(selectStatement));
     NS_ENSURE_SUCCESS(rv, rv);
 
@@ -501,7 +537,10 @@
     // check the number of visited unique urls in the db.
     nsCOMPtr<mozIStorageStatement> countStatement;
     rv = aConnection->CreateStatement(NS_LITERAL_CSTRING(
-        "SELECT count(*) FROM moz_places WHERE visit_count > 0"),
+        "SELECT "
+          "(SELECT count(*) FROM moz_places_temp WHERE visit_count > 0) + "
+          "(SELECT count(*) FROM moz_places WHERE visit_count > 0 AND "
+            "id NOT IN (SELECT id FROM moz_places_temp))"),
       getter_AddRefs(countStatement));
     NS_ENSURE_SUCCESS(rv, rv);
 
@@ -576,23 +615,44 @@
   // keep the old frecencies when possible as an estimate for the new frecency
   // unless we know it has to be invalidated.
   // We must do this before deleting visits
-  nsresult rv = aConnection->ExecuteSimpleSQL(
-    NS_LITERAL_CSTRING(
-      "UPDATE moz_places "
-      "SET frecency = -MAX(visit_count, 1) "
-      "WHERE id IN ("
-        "SELECT h.id FROM moz_places h "
-        "WHERE NOT EXISTS (SELECT b.id FROM moz_bookmarks b WHERE b.fk = h.id) "
-          "AND NOT EXISTS "
-            "(SELECT v.id FROM moz_historyvisits v WHERE v.place_id = h.id AND "
-              "v.id NOT IN (") + deletedVisitIds +
-              NS_LITERAL_CSTRING(")) AND "
-              "h.id IN (") + placeIds +
-    NS_LITERAL_CSTRING("))"));
+  nsresult rv = aConnection->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+    "UPDATE moz_places_view "
+    "SET frecency = -MAX(visit_count, 1) "
+    "WHERE id IN ( "
+      "SELECT h.id FROM moz_places_temp h "
+      "WHERE "
+        "NOT EXISTS (SELECT id FROM moz_bookmarks WHERE fk = h.id) AND "
+        "NOT EXISTS ( "
+          "SELECT v.id FROM moz_historyvisits_temp v "
+          "WHERE v.place_id = h.id "
+          "AND v.id NOT IN (") + deletedVisitIds + NS_LITERAL_CSTRING(") "
+        ") AND "
+        "NOT EXISTS ( "
+          "SELECT v.id FROM moz_historyvisits v "
+          "WHERE v.place_id = h.id "
+          "AND v.id NOT IN (") + deletedVisitIds + NS_LITERAL_CSTRING(") "
+        ") AND "
+        "h.id IN (") + placeIds + NS_LITERAL_CSTRING(") "
+      "UNION ALL "
+      "SELECT h.id FROM moz_places h "
+      "WHERE "
+        "NOT EXISTS (SELECT id FROM moz_bookmarks WHERE fk = h.id) AND "
+        "NOT EXISTS ( "
+          "SELECT v.id FROM moz_historyvisits_temp v "
+          "WHERE v.place_id = h.id "
+          "AND v.id NOT IN (") + deletedVisitIds + NS_LITERAL_CSTRING(") "
+        ") AND "
+        "NOT EXISTS ( "
+          "SELECT v.id FROM moz_historyvisits v "
+          "WHERE v.place_id = h.id "
+          "AND v.id NOT IN (") + deletedVisitIds + NS_LITERAL_CSTRING(") "
+        ") AND "
+        "h.id IN (") + placeIds + NS_LITERAL_CSTRING(") "
+    ")"));
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = aConnection->ExecuteSimpleSQL(
-    NS_LITERAL_CSTRING("DELETE FROM moz_historyvisits WHERE id IN (") +
+    NS_LITERAL_CSTRING("DELETE FROM moz_historyvisits_view WHERE id IN (") +
     deletedVisitIds +
     NS_LITERAL_CSTRING(")"));
   NS_ENSURE_SUCCESS(rv, rv);
@@ -636,17 +696,33 @@
   if (deletedPlaceIds.IsEmpty())
     return NS_OK;
 
-  return aConnection->ExecuteSimpleSQL(
-    NS_LITERAL_CSTRING("DELETE FROM moz_places WHERE id IN( "
-      "SELECT h.id "
-      "FROM moz_places h "
-      "WHERE h.id IN(") +
-        deletedPlaceIds +
-        NS_LITERAL_CSTRING(") AND NOT EXISTS "
-          "(SELECT id FROM moz_historyvisits WHERE place_id = h.id LIMIT 1) "
+  nsresult rv = aConnection->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "DELETE FROM moz_places_view WHERE id IN( "
+        "SELECT h.id "
+        "FROM moz_places h "
+        "WHERE h.id IN(") + deletedPlaceIds + NS_LITERAL_CSTRING(") "
           "AND NOT EXISTS "
-          "(SELECT id FROM moz_bookmarks WHERE fk = h.id LIMIT 1) "
-          "AND SUBSTR(h.url,0,6) <> 'place:')"));
+            "(SELECT id FROM moz_historyvisits WHERE place_id = h.id LIMIT 1) "
+          "AND NOT EXISTS "
+            "(SELECT id FROM moz_historyvisits_temp WHERE place_id = h.id LIMIT 1) "
+          "AND NOT EXISTS "
+            "(SELECT id FROM moz_bookmarks WHERE fk = h.id LIMIT 1) "
+          "AND SUBSTR(h.url,0,6) <> 'place:' "
+        "UNION ALL "
+        "SELECT h.id "
+        "FROM moz_places_temp h "
+        "WHERE h.id IN(") + deletedPlaceIds + NS_LITERAL_CSTRING(") "
+          "AND NOT EXISTS "
+            "(SELECT id FROM moz_historyvisits WHERE place_id = h.id LIMIT 1) "
+          "AND NOT EXISTS "
+            "(SELECT id FROM moz_historyvisits_temp WHERE place_id = h.id LIMIT 1) "
+          "AND NOT EXISTS "
+            "(SELECT id FROM moz_bookmarks WHERE fk = h.id LIMIT 1) "
+          "AND SUBSTR(h.url,0,6) <> 'place:' "
+      ")"));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  return NS_OK;
 }
 
 
@@ -676,13 +752,19 @@
   if (deletedFaviconIds.IsEmpty())
     return NS_OK;
 
-  // delete only if id is not referenced in moz_places
-  return aConnection->ExecuteSimpleSQL(
-    NS_LITERAL_CSTRING("DELETE FROM moz_favicons WHERE id IN ( "
-      "SELECT f.id FROM moz_favicons f "
-      "LEFT OUTER JOIN moz_places h ON f.id = h.favicon_id "
-      "WHERE f.id IN (") + deletedFaviconIds +
-      NS_LITERAL_CSTRING(") AND h.favicon_id IS NULL)"));
+  // delete only if favicon id is not referenced
+  nsresult rv = aConnection->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "DELETE FROM moz_favicons WHERE id IN ( "
+        "SELECT f.id FROM moz_favicons f "
+        "LEFT JOIN moz_places h ON f.id = h.favicon_id "
+        "LEFT JOIN moz_places_temp h_t ON f.id = h_t.favicon_id "
+        "WHERE f.id IN (") + deletedFaviconIds + NS_LITERAL_CSTRING(") "
+        "AND h.favicon_id IS NULL "
+        "AND h_t.favicon_id IS NULL "
+      ")"));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  return NS_OK;
 }
 
 
@@ -735,12 +817,16 @@
   PRTime now = PR_Now();
   nsCOMPtr<mozIStorageStatement> expirePagesStatement;
   nsresult rv = aConnection->CreateStatement(NS_LITERAL_CSTRING(
-      "DELETE FROM moz_annos WHERE expiration = ?1 AND (?2 > MAX(COALESCE(lastModified, 0), dateAdded))"),
+      "DELETE FROM moz_annos "
+      "WHERE expiration = ?1 AND "
+        "(?2 > MAX(COALESCE(lastModified, 0), dateAdded))"),
     getter_AddRefs(expirePagesStatement));
   NS_ENSURE_SUCCESS(rv, rv);
   nsCOMPtr<mozIStorageStatement> expireItemsStatement;
   rv = aConnection->CreateStatement(NS_LITERAL_CSTRING(
-      "DELETE FROM moz_items_annos WHERE expiration = ?1 AND (?2 > MAX(COALESCE(lastModified, 0), dateAdded))"),
+      "DELETE FROM moz_items_annos "
+      "WHERE expiration = ?1 AND "
+        "(?2 > MAX(COALESCE(lastModified, 0), dateAdded))"),
     getter_AddRefs(expireItemsStatement));
   NS_ENSURE_SUCCESS(rv, rv);
 
@@ -797,6 +883,9 @@
       "DELETE FROM moz_annos WHERE expiration = ") +
         nsPrintfCString("%d", nsIAnnotationService::EXPIRE_WITH_HISTORY) +
         NS_LITERAL_CSTRING(" AND NOT EXISTS "
+          "(SELECT id FROM moz_historyvisits_temp "
+          "WHERE place_id = moz_annos.place_id LIMIT 1) "
+        "AND NOT EXISTS "
           "(SELECT id FROM moz_historyvisits "
           "WHERE place_id = moz_annos.place_id LIMIT 1)"));
   NS_ENSURE_SUCCESS(rv, rv);
@@ -817,16 +906,31 @@
   nsCOMPtr<mozIStorageStatement> expireEmbeddedLinksStatement;
   // Note: This query also removes visit_type = 0 entries, for bug #375777.
   nsresult rv = aConnection->CreateStatement(NS_LITERAL_CSTRING(
-    "DELETE FROM moz_historyvisits WHERE id IN ("
-      "SELECT id FROM moz_historyvisits WHERE visit_date < ?1 "
-      "AND (visit_type = ?2 OR visit_type = 0) LIMIT ?3)"),
+      "DELETE FROM moz_historyvisits_view WHERE id IN ("
+        "SELECT * FROM ( "
+          "SELECT id FROM moz_historyvisits_temp "
+          "WHERE visit_date < ?1 "
+          "AND visit_type IN (") +
+            nsPrintfCString("%d", nsINavHistoryService::TRANSITION_EMBED) +
+            NS_LITERAL_CSTRING(", 0) "
+          "LIMIT ?2 "
+        ") "
+        "UNION ALL "
+        "SELECT * FROM ( "
+          "SELECT id FROM moz_historyvisits "
+          "WHERE visit_date < ?1 "
+          "AND visit_type IN (") +
+            nsPrintfCString("%d", nsINavHistoryService::TRANSITION_EMBED) +
+            NS_LITERAL_CSTRING(", 0) "
+          "LIMIT ?2 "
+        ") "
+        "LIMIT ?2 "
+      ")"),
     getter_AddRefs(expireEmbeddedLinksStatement));
   NS_ENSURE_SUCCESS(rv, rv);
   rv = expireEmbeddedLinksStatement->BindInt64Parameter(0, maxEmbeddedAge);
   NS_ENSURE_SUCCESS(rv, rv);
-  rv = expireEmbeddedLinksStatement->BindInt32Parameter(1, nsINavHistoryService::TRANSITION_EMBED);
-  NS_ENSURE_SUCCESS(rv, rv);
-  rv = expireEmbeddedLinksStatement->BindInt32Parameter(2, EXPIRATION_CAP_EMBEDDED);
+  rv = expireEmbeddedLinksStatement->BindInt32Parameter(1, EXPIRATION_CAP_EMBEDDED);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = expireEmbeddedLinksStatement->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
@@ -847,11 +951,24 @@
                                           PRInt32 aMaxRecords)
 {
   nsCAutoString query(
-    "DELETE FROM moz_places WHERE id IN ("
+    "DELETE FROM moz_places_view WHERE id IN ("
       "SELECT h.id FROM moz_places h "
-        "LEFT OUTER JOIN moz_historyvisits v ON h.id = v.place_id "
-        "LEFT OUTER JOIN moz_bookmarks b ON h.id = b.fk "
-      "WHERE v.id IS NULL AND b.id IS NULL AND SUBSTR(h.url,0,6) <> 'place:'");
+      "LEFT JOIN moz_historyvisits v ON h.id = v.place_id "
+      "LEFT JOIN moz_historyvisits_temp v_t ON h.id = v_t.place_id "
+      "LEFT JOIN moz_bookmarks b ON h.id = b.fk "
+      "WHERE v.id IS NULL "
+        "AND v_t.id IS NULL "
+        "AND b.id IS NULL "
+        "AND SUBSTR(h.url,0,6) <> 'place:' "
+      "UNION ALL "
+      "SELECT h.id FROM moz_places_temp h "
+      "LEFT JOIN moz_historyvisits v ON h.id = v.place_id "
+      "LEFT JOIN moz_historyvisits_temp v_t ON h.id = v_t.place_id "
+      "LEFT JOIN moz_bookmarks b ON h.id = b.fk "
+      "WHERE v.id IS NULL "
+        "AND v_t.id IS NULL "
+        "AND b.id IS NULL "
+        "AND SUBSTR(h.url,0,6) <> 'place:'");
   if (aMaxRecords != -1) {
     query.AppendLiteral(" LIMIT ");
     query.AppendInt(aMaxRecords);
@@ -871,10 +988,13 @@
 nsNavHistoryExpire::ExpireFaviconsParanoid(mozIStorageConnection* aConnection)
 {
   nsresult rv = aConnection->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
-    "DELETE FROM moz_favicons WHERE id IN "
-    "(SELECT f.id FROM moz_favicons f "
-     "LEFT OUTER JOIN moz_places h ON f.id = h.favicon_id "
-     "WHERE h.favicon_id IS NULL)"));
+      "DELETE FROM moz_favicons WHERE id IN ("
+        "SELECT f.id FROM moz_favicons f "
+        "LEFT JOIN moz_places h ON f.id = h.favicon_id "
+        "LEFT JOIN moz_places_temp h_t ON f.id = h_t.favicon_id "
+        "WHERE h.favicon_id IS NULL "
+          "AND h_t.favicon_id IS NULL "
+      ")"));
   NS_ENSURE_SUCCESS(rv, rv);
   return rv;
 }
@@ -898,14 +1018,17 @@
   // delete all uri annos w/o a corresponding place id
   // or without any visits *and* not EXPIRE_NEVER.
   rv = aConnection->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
-    "DELETE FROM moz_annos WHERE id IN "
-      "(SELECT a.id FROM moz_annos a "
-      "LEFT OUTER JOIN moz_places p ON a.place_id = p.id "
-      "LEFT OUTER JOIN moz_historyvisits v ON a.place_id = v.place_id "
-      "WHERE p.id IS NULL "
-      "OR (v.id IS NULL AND a.expiration != ") +
-      nsPrintfCString("%d", nsIAnnotationService::EXPIRE_NEVER) +
-      NS_LITERAL_CSTRING("))"));
+      "DELETE FROM moz_annos WHERE id IN ("
+        "SELECT a.id FROM moz_annos a "
+        "LEFT JOIN moz_places h ON a.place_id = h.id "
+        "LEFT JOIN moz_places_temp h_t ON a.place_id = h_t.id "
+        "LEFT JOIN moz_historyvisits v ON a.place_id = v.place_id "
+        "LEFT JOIN moz_historyvisits_temp v_t ON a.place_id = v_t.place_id "
+        "WHERE (h.id IS NULL AND h_t.id IS NULL) "
+          "OR (v.id IS NULL AND v_t.id IS NULL AND a.expiration != ") +
+            nsPrintfCString("%d", nsIAnnotationService::EXPIRE_NEVER) +
+          NS_LITERAL_CSTRING(")"
+      ")"));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // delete item annos w/o a corresponding item id
@@ -916,16 +1039,15 @@
       "WHERE b.id IS NULL)"));
   NS_ENSURE_SUCCESS(rv, rv);
 
-  // delete all anno names w/o a corresponding uri or item entry
+  // delete all anno names w/o a corresponding anno
   rv = aConnection->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
-    "DELETE FROM moz_anno_attributes WHERE " 
-    "id NOT IN (SELECT DISTINCT a.id FROM moz_anno_attributes a "
-      "JOIN moz_annos b ON b.anno_attribute_id = a.id "
-      "JOIN moz_places p ON b.place_id = p.id) "
-    "AND "
-    "id NOT IN (SELECT DISTINCT a.id FROM moz_anno_attributes a "
-      "JOIN moz_items_annos c ON c.anno_attribute_id = a.id "
-      "JOIN moz_bookmarks p ON c.item_id = p.id)"));
+      "DELETE FROM moz_anno_attributes WHERE id IN (" 
+        "SELECT n.id FROM moz_anno_attributes n "
+        "LEFT JOIN moz_annos a ON n.id = a.anno_attribute_id "
+        "LEFT JOIN moz_items_annos t ON n.id = t.anno_attribute_id "
+        "WHERE a.anno_attribute_id IS NULL "
+          "AND t.anno_attribute_id IS NULL "
+      ")"));
   NS_ENSURE_SUCCESS(rv, rv);
   return NS_OK;
 }
@@ -940,17 +1062,20 @@
 {
   // Delete dangling input history that have no associated pages
   nsresult rv = aConnection->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
-    "DELETE FROM moz_inputhistory WHERE place_id IN "
-    "(SELECT i.place_id FROM moz_inputhistory i "
-      "LEFT OUTER JOIN moz_places h ON i.place_id = h.id "
-      "WHERE h.id IS NULL)"));
+      "DELETE FROM moz_inputhistory WHERE place_id IN ( "
+        "SELECT place_id FROM moz_inputhistory "
+        "LEFT JOIN moz_places h ON h.id = place_id "
+        "LEFT JOIN moz_places_temp h_t ON h_t.id = place_id "
+        "WHERE h.id IS NULL "
+          "AND h_t.id IS NULL "
+      ")"));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // Decay potentially unused entries (e.g. those that are at 1) to allow
   // better chances for new entries that will start at 1
   rv = aConnection->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
-    "UPDATE moz_inputhistory "
-    "SET use_count = use_count * .9"));
+      "UPDATE moz_inputhistory "
+      "SET use_count = use_count * .9"));
   NS_ENSURE_SUCCESS(rv, rv);
 
   return NS_OK;
diff -r 17e9560465b0 toolkit/components/places/src/nsPlacesDBFlush.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/components/places/src/nsPlacesDBFlush.js	Thu Oct 30 05:41:46 2008 -0400
@@ -0,0 +1,274 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * vim: sw=2 ts=2 sts=2 expandtab
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Shawn Wilsher <me@shawnwilsher.com> (Original Author)
+ *   Marco Bonardo <mak77@bonardo.net>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");
+
+////////////////////////////////////////////////////////////////////////////////
+//// Constants
+
+const Cc = Components.classes;
+const Ci = Components.interfaces;
+const Cr = Components.results;
+
+const kQuitApplication = "quit-application";
+const kSyncFinished = "places-sync-finished";
+
+const kSyncPrefName = "syncDBTableIntervalInSecs";
+const kDefaultSyncInterval = 120;
+
+////////////////////////////////////////////////////////////////////////////////
+//// nsPlacesDBFlush class
+
+function nsPlacesDBFlush()
+{
+  this._prefs = Cc["@mozilla.org/preferences-service;1"].
+              getService(Ci.nsIPrefService).
+              getBranch("places.");
+
+  // Get our sync interval
+  try {
+    // We want to silently fail if the preference does not exist, and use a
+    // default to fallback to.
+    this._syncInterval = this._prefs.getIntPref(kSyncPrefName);
+    if (this._syncInterval <= 0)
+      this._syncInterval = kDefaultSyncInterval;
+  }
+  catch (e) {
+    // The preference did not exist, so default to two minutes.
+    this._syncInterval = kDefaultSyncInterval;
+  }
+
+  // Register observers
+  this._bs = Cc["@mozilla.org/browser/nav-bookmarks-service;1"].
+             getService(Ci.nsINavBookmarksService);
+  this._bs.addObserver(this, false);
+
+  this._os = Cc["@mozilla.org/observer-service;1"].
+             getService(Ci.nsIObserverService);
+  this._os.addObserver(this, kQuitApplication, false);
+
+  this._prefs.QueryInterface(Ci.nsIPrefBranch2)
+             .addObserver("", this, false);
+
+  // Create our timer to update everything
+  this._timer = this._newTimer();
+}
+
+nsPlacesDBFlush.prototype = {
+  //////////////////////////////////////////////////////////////////////////////
+  //// nsIObserver
+
+  observe: function DBFlush_observe(aSubject, aTopic, aData)
+  {
+    if (aTopic == kQuitApplication) {
+      this._bs.removeObserver(this);
+      this._os.removeObserver(this, kQuitApplication);
+      this._prefs.QueryInterface(Ci.nsIPrefBranch2).removeObserver("", this);
+      this._timer.cancel();
+      this._timer = null;
+      this._syncTables(["places", "historyvisits"]);
+    }
+    else if (aTopic == "nsPref:changed" && aData == kSyncPrefName) {
+      // Get the new pref value, and then update our timer
+      this._syncInterval = aSubject.getIntPref(kSyncPrefName);
+      if (this._syncInterval <= 0)
+        this._syncInterval = kDefaultSyncInterval;
+
+      // We may have canceled the timer already for batch updates, so we want to
+      // exit early.
+      if (!this._timer)
+        return;
+
+      this._timer.cancel();
+      this._timer = this._newTimer();
+    }
+  },
+
+  //////////////////////////////////////////////////////////////////////////////
+  //// nsINavBookmarkObserver
+
+  onBeginUpdateBatch: function DBFlush_onBeginUpdateBatch()
+  {
+    this._inBatchMode = true;
+
+    // We do not want to sync while we are doing batch work.
+    this._timer.cancel();
+    this._timer = null;
+  },
+
+  onEndUpdateBatch: function DBFlush_onEndUpdateBatch()
+  {
+    this._inBatchMode = false;
+
+    // Restore our timer
+    this._timer = this._newTimer();
+
+    // We need to sync now
+    this._syncTables(["places", "historyvisits"]);
+  },
+
+  onItemAdded: function() this._syncTables(["places"]),
+
+  onItemChanged: function DBFlush_onItemChanged(aItemId, aProperty,
+                                                         aIsAnnotationProperty,
+                                                         aValue)
+  {
+    if (aProperty == "uri")
+      this._syncTables(["places"]);
+  },
+
+  onItemRemoved: function() { },
+  onItemVisited: function() { },
+  onItemMoved: function() { },
+
+  //////////////////////////////////////////////////////////////////////////////
+  //// nsITimerCallback
+
+  notify: function() this._syncTables(["places", "historyvisits"]),
+
+  //////////////////////////////////////////////////////////////////////////////
+  //// mozIStorageStatementCallback
+
+  handleError: function DBFlush_handleError(aError)
+  {
+    Components.utils.reportError("Async statement execution returned with '" +
+                                 aError.result + "', '" + aError.message + "'");
+  },
+
+  handleCompletion: function DBFlush_handleCompletion(aReason)
+  {
+    if (aReason == Ci.mozIStorageStatementCallback.REASON_FINISHED) {
+      // Dispatch a notification that sync has finished.
+      this._os.notifyObservers(null, kSyncFinished, null);
+    }
+  },
+
+  //////////////////////////////////////////////////////////////////////////////
+  //// nsPlacesDBFlush
+  _syncInterval: kDefaultSyncInterval,
+
+  /**
+   * Execute async statements to sync temporary places table.
+   * @param aTableNames
+   *        array of table names that should be synced, as moz_{TableName}_temp.
+   */
+  _syncTables: function DBFlush_syncTables(aTableNames)
+  {
+    // No need to do extra work if we are in batch mode
+    if (this._inBatchMode)
+      return;
+
+    let statements = [];
+    for (let i = 0; i < aTableNames.length; i++)
+      statements.push(this._getSyncTableStatement(aTableNames[i]));
+
+    // Execute sync statements async in a transaction
+    this._db.executeAsync(statements, statements.length, this);
+
+    // Finalize statements, otherwise we could get in trouble
+    statements.forEach(function(stmt) stmt.finalize());
+  },
+
+  /**
+   * Generate the statement to synchronizes the moz_{aTableName} and
+   * moz_{aTableName}_temp by copying all the data from the temporary table
+   * into the permanent one.
+   * Most of the work is done through triggers defined in nsPlacesTriggers.h,
+   * they sync back to disk, then delete the data in the temporary table.
+   * @param aTableName
+   *        name of the table to build statement for, as moz_{TableName}_temp.
+   */
+  _getSyncTableStatement: function DBFlush_getSyncTableStatement(aTableName)
+  {
+    // Delete all the data in the temp table.
+    // We have triggers setup that ensure that the data is transferred over
+    // upon deletion.
+    return this._db.createStatement("DELETE FROM moz_" + aTableName + "_temp");
+  },
+
+  /**
+   * Creates a new timer based on this._syncInterval.
+   *
+   * @returns a REPEATING_SLACK nsITimer that runs every this._syncInterval.
+   */
+  _newTimer: function DBFlush_newTimer()
+  {
+    let timer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
+    timer.initWithCallback(this, this._syncInterval * 1000,
+                           Ci.nsITimer.TYPE_REPEATING_SLACK);
+    return timer;
+  },
+
+  //////////////////////////////////////////////////////////////////////////////
+  //// nsISupports
+
+  classDescription: "Used to synchronize the temporary and permanent tables of Places",
+  classID: Components.ID("c1751cfc-e8f1-4ade-b0bb-f74edfb8ef6a"),
+  contractID: "@mozilla.org/places/sync;1",
+  _xpcom_categories: [{
+    category: "profile-after-change",
+  }],
+
+  QueryInterface: XPCOMUtils.generateQI([
+    Ci.nsIObserver,
+    Ci.nsINavBookmarkObserver,
+    Ci.nsITimerCallback,
+    Ci.mozIStorageStatementCallback,
+  ])
+};
+
+//////////////////////////////////////////////////////////////////////////////
+//// Smart Getters
+
+nsPlacesDBFlush.prototype.__defineGetter__("_db", function() {
+  delete nsPlacesDBFlush._db;
+  return nsPlacesDBFlush._db = Cc["@mozilla.org/browser/nav-history-service;1"].
+                               getService(Ci.nsPIPlacesDatabase).
+                               DBConnection;
+});
+
+////////////////////////////////////////////////////////////////////////////////
+//// Module Registration
+
+let components = [nsPlacesDBFlush];
+function NSGetModule(compMgr, fileSpec)
+{
+  return XPCOMUtils.generateModule(components);
+}
diff -r 17e9560465b0 toolkit/components/places/src/nsPlacesTables.h
--- a/toolkit/components/places/src/nsPlacesTables.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/components/places/src/nsPlacesTables.h	Thu Oct 30 05:41:46 2008 -0400
@@ -39,8 +39,8 @@
 #ifndef __nsPlacesTables_h__
 #define __nsPlacesTables_h__
 
-#define CREATE_MOZ_PLACES NS_LITERAL_CSTRING( \
-  "CREATE TABLE moz_places ( " \
+#define CREATE_MOZ_PLACES_BASE(__name, __temporary) NS_LITERAL_CSTRING( \
+  "CREATE " __temporary " TABLE " __name " ( " \
     "  id INTEGER PRIMARY KEY" \
     ", url LONGVARCHAR" \
     ", title LONGVARCHAR" \
@@ -52,9 +52,18 @@
     ", frecency INTEGER DEFAULT -1 NOT NULL" \
   ")" \
 )
+#define CREATE_MOZ_PLACES CREATE_MOZ_PLACES_BASE("moz_places", "")
+#define CREATE_MOZ_PLACES_TEMP CREATE_MOZ_PLACES_BASE("moz_places_temp", "TEMP")
+#define CREATE_MOZ_PLACES_VIEW NS_LITERAL_CSTRING( \
+  "CREATE TEMPORARY VIEW moz_places_view AS " \
+  "SELECT * FROM moz_places_temp " \
+  "UNION ALL " \
+  "SELECT * FROM moz_places " \
+  "WHERE id NOT IN (SELECT id FROM moz_places_temp) " \
+)
 
-#define CREATE_MOZ_HISTORYVISITS NS_LITERAL_CSTRING( \
-  "CREATE TABLE moz_historyvisits (" \
+#define CREATE_MOZ_HISTORYVISITS_BASE(__name, __temporary) NS_LITERAL_CSTRING( \
+  "CREATE " __temporary " TABLE " __name " (" \
     "  id INTEGER PRIMARY KEY" \
     ", from_visit INTEGER" \
     ", place_id INTEGER" \
@@ -62,6 +71,17 @@
     ", visit_type INTEGER" \
     ", session INTEGER" \
   ")" \
+)
+#define CREATE_MOZ_HISTORYVISITS \
+  CREATE_MOZ_HISTORYVISITS_BASE("moz_historyvisits", "")
+#define CREATE_MOZ_HISTORYVISITS_TEMP \
+  CREATE_MOZ_HISTORYVISITS_BASE("moz_historyvisits_temp", "TEMP")
+#define CREATE_MOZ_HISTORYVISITS_VIEW NS_LITERAL_CSTRING( \
+  "CREATE TEMPORARY VIEW moz_historyvisits_view AS " \
+  "SELECT * FROM moz_historyvisits_temp " \
+  "UNION ALL " \
+  "SELECT * FROM moz_historyvisits " \
+  "WHERE id NOT IN (SELECT id FROM moz_historyvisits_temp) " \
 )
 
 #define CREATE_MOZ_INPUTHISTORY NS_LITERAL_CSTRING( \
diff -r 17e9560465b0 toolkit/components/places/src/nsPlacesTriggers.h
--- a/toolkit/components/places/src/nsPlacesTriggers.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/components/places/src/nsPlacesTriggers.h	Thu Oct 30 05:41:46 2008 -0400
@@ -40,38 +40,6 @@
 #define __nsPlacesTriggers_h__
 
 /**
- * Trigger increments the visit count by one for each inserted visit that isn't
- * an invalid transition, embedded transition, or a download transition.
- */
-#define CREATE_VISIT_COUNT_INSERT_TRIGGER NS_LITERAL_CSTRING( \
-  "CREATE TRIGGER moz_historyvisits_afterinsert_v1_trigger " \
-  "AFTER INSERT ON moz_historyvisits FOR EACH ROW " \
-  "WHEN NEW.visit_type NOT IN (0, 4, 7) " /* invalid, EMBED, DOWNLOAD */ \
-  "BEGIN " \
-    "UPDATE moz_places " \
-    "SET visit_count = visit_count + 1 " \
-    "WHERE moz_places.id = NEW.place_id; " \
-  "END" \
-)
-
-/**
- * Trigger decrements the visit count by one for each removed visit that isn't
- * an invalid transition, embeded transition, or a download transition.  To be
- * safe, we ensure that the visit count will not fall below zero.
- */
-#define CREATE_VISIT_COUNT_DELETE_TRIGGER NS_LITERAL_CSTRING( \
-  "CREATE TRIGGER moz_historyvisits_afterdelete_v1_trigger " \
-  "AFTER DELETE ON moz_historyvisits FOR EACH ROW " \
-  "WHEN OLD.visit_type NOT IN (0, 4, 7) " /* invalid, EMBED, DOWNLOAD */ \
-  "BEGIN " \
-    "UPDATE moz_places " \
-    "SET visit_count = visit_count - 1 " \
-    "WHERE moz_places.id = OLD.place_id " \
-    "AND visit_count > 0; " \
-  "END" \
-)
-
-/**
  * Trigger checks to ensure that at least one bookmark is still using a keyword
  * when any bookmark is deleted.  If there are no more bookmarks using it, the
  * keyword is deleted.
@@ -93,4 +61,183 @@
   "END" \
 )
 
+/**
+ * This trigger allows for an insertion into moz_places_view.  It enters the new
+ * data into the temporary table, ensuring that the new id is one greater than
+ * the largest id value found.
+ */
+#define CREATE_PLACES_VIEW_INSERT_TRIGGER NS_LITERAL_CSTRING( \
+  "CREATE TEMPORARY TRIGGER moz_places_view_insert_trigger " \
+  "INSTEAD OF INSERT " \
+  "ON moz_places_view " \
+  "BEGIN " \
+    "INSERT INTO moz_places_temp ( " \
+      "id, url, title, rev_host, visit_count, hidden, typed, favicon_id, " \
+      "frecency " \
+    ") " \
+    "VALUES (MAX((SELECT IFNULL(MAX(id), 0) FROM moz_places_temp), " \
+                "(SELECT IFNULL(MAX(id), 0) FROM moz_places)) + 1, " \
+            "NEW.url, NEW.title, NEW.rev_host, " \
+            "IFNULL(NEW.visit_count, 0), " /* enforce having a value */ \
+            "NEW.hidden, NEW.typed, NEW.favicon_id, NEW.frecency);" \
+  "END" \
+)
+
+/**
+ * This trigger allows for the deletion of a record in moz_places_view.  It
+ * removes any entry in the temporary table, and any entry in the permanent
+ * table as well.
+ */
+#define CREATE_PLACES_VIEW_DELETE_TRIGGER NS_LITERAL_CSTRING( \
+  "CREATE TEMPORARY TRIGGER moz_places_view_delete_trigger " \
+  "INSTEAD OF DELETE " \
+  "ON moz_places_view " \
+  "BEGIN " \
+    "DELETE FROM moz_places_temp " \
+    "WHERE id = OLD.id; " \
+    "DELETE FROM moz_places " \
+    "WHERE id = OLD.id; " \
+  "END" \
+)
+
+/**
+ * This trigger allows for updates to a record in moz_places_view.  It first
+ * copies the row from the permanent table over to the temp table if it does not
+ * exist in the temporary table.  Then, it will update the temporary table with
+ * the new data.
+ * We use INSERT OR IGNORE to avoid looking if the place already exists in the
+ * temp table.
+ */
+#define CREATE_PLACES_VIEW_UPDATE_TRIGGER NS_LITERAL_CSTRING( \
+  "CREATE TEMPORARY TRIGGER moz_places_view_update_trigger " \
+  "INSTEAD OF UPDATE " \
+  "ON moz_places_view " \
+  "BEGIN " \
+    "INSERT OR IGNORE INTO moz_places_temp " \
+    "SELECT * " \
+    "FROM moz_places " \
+    "WHERE id = OLD.id; " \
+    "UPDATE moz_places_temp " \
+    "SET url = IFNULL(NEW.url, OLD.url), " \
+        "title = IFNULL(NEW.title, OLD.title), " \
+        "rev_host = IFNULL(NEW.rev_host, OLD.rev_host), " \
+        "visit_count = IFNULL(NEW.visit_count, OLD.visit_count), " \
+        "hidden = IFNULL(NEW.hidden, OLD.hidden), " \
+        "typed = IFNULL(NEW.typed, OLD.typed), " \
+        "favicon_id = IFNULL(NEW.favicon_id, OLD.favicon_id), " \
+        "frecency = IFNULL(NEW.frecency, OLD.frecency) " \
+    "WHERE id = OLD.id; " \
+  "END" \
+)
+
+/**
+ * This trigger allows for an insertion into  moz_historyvisits_view.  It enters
+ * the new data into the temporary table, ensuring that the new id is one
+ * greater than the largest id value found.  It then updates moz_places_view
+ * with the new visit count.
+ * We use INSERT OR IGNORE to avoid looking if the place already exists in the
+ * temp table. 
+ */
+#define CREATE_HISTORYVISITS_VIEW_INSERT_TRIGGER NS_LITERAL_CSTRING( \
+  "CREATE TEMPORARY TRIGGER moz_historyvisits_view_insert_trigger " \
+  "INSTEAD OF INSERT " \
+  "ON moz_historyvisits_view " \
+  "BEGIN " \
+    "INSERT INTO moz_historyvisits_temp ( " \
+      "id, from_visit, place_id, visit_date, visit_type, session " \
+    ") " \
+    "VALUES (MAX((SELECT IFNULL(MAX(id), 0) FROM moz_historyvisits_temp), " \
+                "(SELECT IFNULL(MAX(id), 0) FROM moz_historyvisits)) + 1, " \
+            "NEW.from_visit, NEW.place_id, NEW.visit_date, NEW.visit_type, " \
+            "NEW.session); " \
+    "INSERT OR IGNORE INTO moz_places_temp " \
+    "SELECT * " \
+    "FROM moz_places " \
+    "WHERE id = NEW.place_id " \
+    "AND NEW.visit_type NOT IN (0, 4, 7); " \
+    "UPDATE moz_places_temp " \
+    "SET visit_count = visit_count + 1 " \
+    "WHERE id = NEW.place_id " \
+    "AND NEW.visit_type NOT IN (0, 4, 7); " /* invalid, EMBED, DOWNLOAD */ \
+  "END" \
+)
+
+/**
+ * This trigger allows for the deletion of a record in moz_historyvisits_view.
+ * It removes any entry in the temporary table, and removes any entry in the
+ * permanent table as well.  It then updates moz_places_view with the new visit
+ * count.
+ * We use INSERT OR IGNORE to avoid looking if the place already exists in the
+ * temp table.
+ */
+#define CREATE_HISTORYVISITS_VIEW_DELETE_TRIGGER NS_LITERAL_CSTRING( \
+  "CREATE TEMPORARY TRIGGER moz_historyvisits_view_delete_trigger " \
+  "INSTEAD OF DELETE " \
+  "ON moz_historyvisits_view " \
+  "BEGIN " \
+    "DELETE FROM moz_historyvisits_temp " \
+    "WHERE id = OLD.id; " \
+    "DELETE FROM moz_historyvisits " \
+    "WHERE id = OLD.id; " \
+    "INSERT OR IGNORE INTO moz_places_temp " \
+    "SELECT * " \
+    "FROM moz_places " \
+    "WHERE id = OLD.place_id " \
+    "AND OLD.visit_type NOT IN (0, 4, 7); " \
+    "UPDATE moz_places_temp " \
+    "SET visit_count = visit_count - 1 " \
+    "WHERE id = OLD.place_id " \
+    "AND OLD.visit_type NOT IN (0, 4, 7); " /* invalid, EMBED, DOWNLOAD */ \
+  "END" \
+)
+
+/**
+ * This trigger allows for updates to a record in moz_historyvisits_view.  It
+ * first copies the row from the permanent table over to the temp table if it
+ * does not exist in the temporary table.  Then it will update the temporary
+ * table with the new data.
+ * We use INSERT OR IGNORE to avoid looking if the visit already exists in the
+ * temp table.
+ */
+#define CREATE_HISTORYVISITS_VIEW_UPDATE_TRIGGER NS_LITERAL_CSTRING( \
+  "CREATE TEMPORARY TRIGGER moz_historyvisits_view_update_trigger " \
+  "INSTEAD OF UPDATE " \
+  "ON moz_historyvisits_view " \
+  "BEGIN " \
+    "INSERT OR IGNORE INTO moz_historyvisits_temp " \
+    "SELECT * " \
+    "FROM moz_historyvisits " \
+    "WHERE id = OLD.id; " \
+    "UPDATE moz_historyvisits_temp " \
+    "SET from_visit = IFNULL(NEW.from_visit, OLD.from_visit), " \
+        "place_id = IFNULL(NEW.place_id, OLD.place_id), " \
+        "visit_date = IFNULL(NEW.visit_date, OLD.visit_date), " \
+        "visit_type = IFNULL(NEW.visit_type, OLD.visit_type), " \
+        "session = IFNULL(NEW.session, OLD.session) " \
+    "WHERE id = OLD.id; " \
+  "END" \
+)
+
+/**
+ * This trigger moves the data out of a temporary table into the permanent one
+ * before deleting from the temporary table.
+ *
+ * Note - it's OK to use an INSERT OR REPLACE here because the only conflict
+ * that will happen is the primary key.  As a result, the row will be deleted,
+ * and the replacement will be inserted with the same id.
+ */
+#define CREATE_TEMP_SYNC_TRIGGER_BASE(__table) NS_LITERAL_CSTRING( \
+  "CREATE TEMPORARY TRIGGER " __table "_beforedelete_trigger " \
+  "BEFORE DELETE ON " __table "_temp FOR EACH ROW " \
+  "BEGIN " \
+    "INSERT OR REPLACE INTO " __table " " \
+    "SELECT * FROM " __table "_temp " \
+    "WHERE id = OLD.id;" \
+  "END" \
+)
+#define CREATE_MOZ_PLACES_SYNC_TRIGGER \
+  CREATE_TEMP_SYNC_TRIGGER_BASE("moz_places")
+#define CREATE_MOZ_HISTORYVISITS_SYNC_TRIGGER \
+  CREATE_TEMP_SYNC_TRIGGER_BASE("moz_historyvisits")
+
 #endif // __nsPlacesTriggers_h__
diff -r 17e9560465b0 toolkit/components/places/tests/Makefile.in
--- a/toolkit/components/places/tests/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/components/places/tests/Makefile.in	Thu Oct 30 05:41:46 2008 -0400
@@ -49,6 +49,7 @@
 XPCSHELL_TESTS = \
                  autocomplete \
                  background \
+                 sync \
                  bookmarks \
                  queries \
                  unit \
diff -r 17e9560465b0 toolkit/components/places/tests/background/head_background.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/components/places/tests/background/head_background.js	Thu Oct 30 05:41:46 2008 -0400
@@ -0,0 +1,102 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Places.
+ *
+ * The Initial Developer of the Original Code is
+ * Google Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Brian Ryner <bryner@brianryner.com>
+ *  Dietrich Ayala <dietrich@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+const NS_APP_USER_PROFILE_50_DIR = "ProfD";
+const NS_APP_HISTORY_50_FILE = "UHist";
+
+const Ci = Components.interfaces;
+const Cc = Components.classes;
+const Cr = Components.results;
+
+function LOG(aMsg) {
+  aMsg = ("*** PLACES TESTS: " + aMsg);
+  Cc["@mozilla.org/consoleservice;1"].getService(Ci.nsIConsoleService).
+                                      logStringMessage(aMsg);
+  print(aMsg);
+}
+
+// If there's no location registered for the profile direcotry, register one now.
+var dirSvc = Cc["@mozilla.org/file/directory_service;1"].getService(Ci.nsIProperties);
+var profileDir = null;
+try {
+  profileDir = dirSvc.get(NS_APP_USER_PROFILE_50_DIR, Ci.nsIFile);
+} catch (e) {}
+if (!profileDir) {
+  // Register our own provider for the profile directory.
+  // It will simply return the current directory.
+  var provider = {
+    getFile: function(prop, persistent) {
+      persistent.value = true;
+      if (prop == NS_APP_USER_PROFILE_50_DIR) {
+        return dirSvc.get("CurProcD", Ci.nsIFile);
+      }
+      if (prop == NS_APP_HISTORY_50_FILE) {
+        var histFile = dirSvc.get("CurProcD", Ci.nsIFile);
+        histFile.append("history.dat");
+        return histFile;
+      }
+      throw Cr.NS_ERROR_FAILURE;
+    },
+    QueryInterface: function(iid) {
+      if (iid.equals(Ci.nsIDirectoryServiceProvider) ||
+          iid.equals(Ci.nsISupports)) {
+        return this;
+      }
+      throw Cr.NS_ERROR_NO_INTERFACE;
+    }
+  };
+  dirSvc.QueryInterface(Ci.nsIDirectoryService).registerProvider(provider);
+}
+
+var iosvc = Cc["@mozilla.org/network/io-service;1"].getService(Ci.nsIIOService);
+
+function uri(spec) {
+  return iosvc.newURI(spec, null, null);
+}
+
+// Delete a previously created sqlite file
+function clearDB() {
+  try {
+    var file = dirSvc.get('ProfD', Ci.nsIFile);
+    file.append("places.sqlite");
+    if (file.exists())
+      file.remove(false);
+  } catch(ex) { dump("Exception: " + ex); }
+}
+clearDB();
diff -r 17e9560465b0 toolkit/components/places/tests/background/test_background.js
--- a/toolkit/components/places/tests/background/test_background.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/components/places/tests/background/test_background.js	Thu Oct 30 05:41:46 2008 -0400
@@ -38,10 +38,6 @@
  * ***** END LICENSE BLOCK ***** */
 
 Components.utils.import("resource://gre/modules/PlacesBackground.jsm");
-
-const Cc = Components.classes;
-const Ci = Components.interfaces;
-const Cr = Components.results;
 
 function test_service_exists()
 {
@@ -87,10 +83,32 @@
   do_check_eq(event.thread1, event.thread2);
 }
 
+function test_places_background_shutdown_topic()
+{
+  // Ensures that the places shutdown topic is dispatched before the thread is
+  // shutdown.
+  let os = Cc["@mozilla.org/observer-service;1"].
+           getService(Ci.nsIObserverService);
+  os.addObserver({
+    observe: function(aSubject, aTopic, aData)
+    {
+      // We should still be able to dispatch an event without throwing now!
+      PlacesBackground.dispatch({
+        run: function()
+        {
+          do_test_finished();
+        }
+      }, Ci.nsIEventTarget.DISPATCH_NORMAL);
+    }
+  }, "places-background-shutdown", false);
+  do_test_pending();
+}
+
 let tests = [
   test_service_exists,
   test_isOnCurrentThread,
   test_two_events_same_thread,
+  test_places_background_shutdown_topic,
 ];
 
 function run_test()
diff -r 17e9560465b0 toolkit/components/places/tests/mochitest/bug_411966/redirect.js
--- a/toolkit/components/places/tests/mochitest/bug_411966/redirect.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/components/places/tests/mochitest/bug_411966/redirect.js	Thu Oct 30 05:41:46 2008 -0400
@@ -164,11 +164,11 @@
   netscape.security.PrivilegeManager.enablePrivilege('UniversalXPConnect');
 
   // Get all pages visited from the original typed one
-  var sql = "SELECT url FROM moz_historyvisits " +
-            "JOIN moz_places h ON h.id = place_id " +
+  var sql = "SELECT url FROM moz_historyvisits_view " +
+            "JOIN moz_places_view h ON h.id = place_id " +
             "WHERE from_visit IN " +
-              "(SELECT v.id FROM moz_historyvisits v " +
-              "JOIN moz_places p ON p.id = v.place_id " +
+              "(SELECT v.id FROM moz_historyvisits_view v " +
+              "JOIN moz_places_view p ON p.id = v.place_id " +
               "WHERE p.url = ?1)";
   var stmt = mDBConn.createStatement(sql);
   stmt.bindUTF8StringParameter(0, typedURI.spec);
diff -r 17e9560465b0 toolkit/components/places/tests/sync/head_sync.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/components/places/tests/sync/head_sync.js	Thu Oct 30 05:41:46 2008 -0400
@@ -0,0 +1,258 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Places.
+ *
+ * The Initial Developer of the Original Code is
+ * Google Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Brian Ryner <bryner@brianryner.com>
+ *  Dietrich Ayala <dietrich@mozilla.com>
+ *  Shawn Wilsher <me@shawnwilsher.com>
+ *  Marco Bonardo <mak77@bonardo.net>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+const NS_APP_USER_PROFILE_50_DIR = "ProfD";
+const NS_APP_HISTORY_50_FILE = "UHist";
+
+const Ci = Components.interfaces;
+const Cc = Components.classes;
+const Cr = Components.results;
+
+function LOG(aMsg) {
+  aMsg = ("*** PLACES TESTS: " + aMsg);
+  Cc["@mozilla.org/consoleservice;1"].getService(Ci.nsIConsoleService).
+                                      logStringMessage(aMsg);
+  print(aMsg);
+}
+
+// If there's no location registered for the profile direcotry, register one now.
+var dirSvc = Cc["@mozilla.org/file/directory_service;1"].getService(Ci.nsIProperties);
+var profileDir = null;
+try {
+  profileDir = dirSvc.get(NS_APP_USER_PROFILE_50_DIR, Ci.nsIFile);
+} catch (e) {}
+if (!profileDir) {
+  // Register our own provider for the profile directory.
+  // It will simply return the current directory.
+  var provider = {
+    getFile: function(prop, persistent) {
+      persistent.value = true;
+      if (prop == NS_APP_USER_PROFILE_50_DIR) {
+        return dirSvc.get("CurProcD", Ci.nsIFile);
+      }
+      if (prop == NS_APP_HISTORY_50_FILE) {
+        var histFile = dirSvc.get("CurProcD", Ci.nsIFile);
+        histFile.append("history.dat");
+        return histFile;
+      }
+      throw Cr.NS_ERROR_FAILURE;
+    },
+    QueryInterface: function(iid) {
+      if (iid.equals(Ci.nsIDirectoryServiceProvider) ||
+          iid.equals(Ci.nsISupports)) {
+        return this;
+      }
+      throw Cr.NS_ERROR_NO_INTERFACE;
+    }
+  };
+  dirSvc.QueryInterface(Ci.nsIDirectoryService).registerProvider(provider);
+}
+
+var iosvc = Cc["@mozilla.org/network/io-service;1"].getService(Ci.nsIIOService);
+
+function uri(spec) {
+  return iosvc.newURI(spec, null, null);
+}
+
+// Delete a previously created sqlite file
+function clearDB() {
+  try {
+    var file = dirSvc.get('ProfD', Ci.nsIFile);
+    file.append("places.sqlite");
+    if (file.exists())
+      file.remove(false);
+  } catch(ex) { dump("Exception: " + ex); }
+}
+clearDB();
+
+/**
+ * Dumps the rows of a table out to the console.
+ *
+ * @param aName
+ *        The name of the table or view to output.
+ */
+function dump_table(aName)
+{
+  let db = Cc["@mozilla.org/browser/nav-history-service;1"].
+           getService(Ci.nsPIPlacesDatabase).
+           DBConnection;
+  let stmt = db.createStatement("SELECT * FROM " + aName);
+
+  dump("\n*** Printing data from " + aName + ":\n");
+  let count = 0;
+  while (stmt.executeStep()) {
+    let columns = stmt.numEntries;
+
+    if (count == 0) {
+      // print the column names
+      for (let i = 0; i < columns; i++)
+        dump(stmt.getColumnName(i) + "\t");
+      dump("\n");
+    }
+
+    // print the row
+    for (let i = 0; i < columns; i++) {
+      switch (stmt.getTypeOfIndex(i)) {
+        case Ci.mozIStorageValueArray.VALUE_TYPE_NULL:
+          dump("NULL\t");
+          break;
+        case Ci.mozIStorageValueArray.VALUE_TYPE_INTEGER:
+          dump(stmt.getInt64(i) + "\t");
+          break;
+        case Ci.mozIStorageValueArray.VALUE_TYPE_FLOAT:
+          dump(stmt.getDouble(i) + "\t");
+          break;
+        case Ci.mozIStorageValueArray.VALUE_TYPE_TEXT:
+          dump(stmt.getString(i) + "\t");
+          break;
+      }
+    }
+    dump("\n");
+
+    count++;
+  }
+  dump("*** There were a total of " + count + " rows of data.\n\n");
+
+  stmt.reset();
+  stmt.finalize();
+  stmt = null;
+}
+
+/**
+ * This dispatches the observer topic "quit-application" to clean up the sync
+ * component.
+ */
+function finish_test()
+{
+  // xpcshell doesn't dispatch shutdown-application
+  let os = Cc["@mozilla.org/observer-service;1"].
+           getService(Ci.nsIObserverService);
+  os.notifyObservers(null, "quit-application", null);
+  do_test_finished();
+}
+
+/**
+ * Function tests to see if the place associated with the bookmark with id
+ * aBookmarkId has the uri aExpectedURI.  The event will call finish_test() if
+ * aFinish is true.
+ *
+ * @param aBookmarkId
+ *        The bookmark to check against.
+ * @param aExpectedURI
+ *        The URI we expect to be in moz_places.
+ * @param aExpected
+ *        Indicates if we expect to get a result or not.
+ * @param [optional] aFinish
+ *        Indicates if the test should be completed or not.
+ */
+function new_test_bookmark_uri_event(aBookmarkId, aExpectedURI, aExpected, aFinish)
+{
+  let db = Cc["@mozilla.org/browser/nav-history-service;1"].
+           getService(Ci.nsPIPlacesDatabase).
+           DBConnection;
+  let stmt = db.createStatement(
+    "SELECT moz_places.url " +
+    "FROM moz_bookmarks INNER JOIN moz_places " +
+    "ON moz_bookmarks.fk = moz_places.id " +
+    "WHERE moz_bookmarks.id = ?1"
+  );
+  stmt.bindInt64Parameter(0, aBookmarkId);
+
+  if (aExpected) {
+    do_check_true(stmt.executeStep());
+    do_check_eq(stmt.getUTF8String(0), aExpectedURI);
+  }
+  else {
+    do_check_false(stmt.executeStep());
+  }
+  stmt.reset();
+  stmt.finalize();
+  stmt = null;
+
+  if (aFinish)
+    finish_test();
+}
+
+/**
+ * Function tests to see if the place associated with the visit with id aVisitId
+ * has the uri aExpectedURI.  The event will call finish_test() if aFinish is
+ * true.
+ *
+ * @param aVisitId
+ *        The visit to check against.
+ * @param aExpectedURI
+ *        The URI we expect to be in moz_places.
+ * @param aExpected
+ *        Indicates if we expect to get a result or not.
+ * @param [optional] aFinish
+ *        Indicates if the test should be completed or not.
+ */
+function new_test_visit_uri_event(aVisitId, aExpectedURI, aExpected, aFinish)
+{
+  let db = Cc["@mozilla.org/browser/nav-history-service;1"].
+           getService(Ci.nsPIPlacesDatabase).
+           DBConnection;
+  let stmt = db.createStatement(
+    "SELECT moz_places.url " +
+    "FROM moz_historyvisits INNER JOIN moz_places " +
+    "ON moz_historyvisits.place_id = moz_places.id " +
+    "WHERE moz_historyvisits.id = ?1"
+  );
+  stmt.bindInt64Parameter(0, aVisitId);
+
+  if (aExpected) {
+    do_check_true(stmt.executeStep());
+    do_check_eq(stmt.getUTF8String(0), aExpectedURI);
+  }
+  else {
+    do_check_false(stmt.executeStep());
+  }
+  stmt.reset();
+  stmt.finalize();
+  stmt = null;
+
+  if (aFinish)
+    finish_test();
+}
+
+// profile-after-change doesn't create components in xpcshell, so we have to do
+// it ourselves
+Cc["@mozilla.org/places/sync;1"].getService(Ci.nsISupports);
diff -r 17e9560465b0 toolkit/components/places/tests/sync/test_database_sync_after_addBookmark.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/components/places/tests/sync/test_database_sync_after_addBookmark.js	Thu Oct 30 05:41:46 2008 -0400
@@ -0,0 +1,89 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * vim: sw=2 ts=2 sts=2 expandtab
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Shawn Wilsher <me@shawnwilsher.com> (Original Author)
+ *   Marco Bonardo <mak77@bonardo.net>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+var bs = Cc["@mozilla.org/browser/nav-bookmarks-service;1"].
+         getService(Ci.nsINavBookmarksService);
+var os = Cc["@mozilla.org/observer-service;1"].
+         getService(Ci.nsIObserverService);
+var prefs = Cc["@mozilla.org/preferences-service;1"].
+            getService(Ci.nsIPrefService).
+            getBranch("places.");
+
+const TEST_URI = "http://test.com/";
+
+const SYNC_INTERVAL = 600; // ten minutes
+const kSyncPrefName = "syncDBTableIntervalInSecs";
+const kSyncFinished = "places-sync-finished";
+
+// Used to update observer itemId
+var bookmarksObserver = {
+  onItemAdded: function(aItemId, aNewParent, aNewIndex) {
+    observer.itemId = aItemId;
+  }
+}
+bs.addObserver(bookmarksObserver, false);
+
+var observer = {
+  itemId: -1,
+  observe: function(aSubject, aTopic, aData) {
+    if (aTopic == kSyncFinished) {
+      do_check_neq(this.itemId, -1);
+      // remove the observer, we don't need to observe sync on quit
+      os.removeObserver(this, kSyncFinished);
+      bs.removeObserver(bookmarksObserver);
+      // Check that moz_places table has been correctly synced
+      new_test_bookmark_uri_event(this.itemId, TEST_URI, true, true);
+    }
+  }
+}
+os.addObserver(observer, kSyncFinished, false);
+
+function run_test()
+{
+  // First set the preference for the timer to a really large value so it won't
+  // run before the test finishes.
+  prefs.setIntPref(kSyncPrefName, SYNC_INTERVAL);
+
+  // Insert a new bookmark
+  bs.insertBookmark(bs.unfiledBookmarksFolder, uri(TEST_URI),
+                    bs.DEFAULT_INDEX, "test");
+
+  do_test_pending();
+}
diff -r 17e9560465b0 toolkit/components/places/tests/sync/test_database_sync_after_addBookmark_batched.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/components/places/tests/sync/test_database_sync_after_addBookmark_batched.js	Thu Oct 30 05:41:46 2008 -0400
@@ -0,0 +1,110 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * vim: sw=2 ts=2 sts=2 expandtab
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Shawn Wilsher <me@shawnwilsher.com> (Original Author)
+ *   Marco Bonardo <mak77@bonardo.net>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+var bs = Cc["@mozilla.org/browser/nav-bookmarks-service;1"].
+         getService(Ci.nsINavBookmarksService);
+var os = Cc["@mozilla.org/observer-service;1"].
+         getService(Ci.nsIObserverService);
+var prefs = Cc["@mozilla.org/preferences-service;1"].
+            getService(Ci.nsIPrefService).
+            getBranch("places.");
+
+const TEST_URI = "http://test.com/";
+
+const SYNC_INTERVAL = 600; // ten minutes
+const kSyncPrefName = "syncDBTableIntervalInSecs";
+const kSyncFinished = "places-sync-finished";
+
+// Used to check if we are batching and to update observer itemId
+var bookmarksObserver = {
+  _batching: false,
+  onBeginUpdateBatch: function() {
+    this._batching = true;
+  },
+  onEndUpdateBatch: function() {
+    this._batching = false;
+  },
+  onItemAdded: function(aItemId, aNewParent, aNewIndex) {
+    observer.itemId = aItemId;
+  }
+}
+bs.addObserver(bookmarksObserver, false);
+
+var observer = {
+  itemId: -1,
+  observe: function(aSubject, aTopic, aData) {
+    if (aTopic == kSyncFinished) {
+      dump(this.itemId);
+      // item id must be valid
+      do_check_neq(this.itemId, -1);
+      // Check that we are not in a batch
+      do_check_false(bookmarksObserver._batching);
+      // remove the observer, we don't need to observe sync on quit
+      os.removeObserver(this, kSyncFinished);
+      bs.removeObserver(bookmarksObserver);
+      // Check that tables have been correctly synced
+      new_test_bookmark_uri_event(this.itemId, TEST_URI, true, true);
+    }
+  }
+}
+os.addObserver(observer, kSyncFinished, false);
+
+function run_test()
+{
+  // Set the preference for the timer to a really large value, so it won't
+  // run before the test finishes.
+  prefs.setIntPref(kSyncPrefName, SYNC_INTERVAL);
+
+  // Add a bookmark in batch mode
+  let id = -1;
+  bs.runInBatchMode({
+    runBatched: function(aUserData)
+    {
+      id = bs.insertBookmark(bs.unfiledBookmarksFolder, uri(TEST_URI),
+                             bs.DEFAULT_INDEX, "test");
+      // We should not sync during a batch
+      new_test_bookmark_uri_event(id, TEST_URI, false);
+    }
+  }, null);
+  // Ensure the bookmark has been added
+  do_check_neq(id, -1);
+
+  do_test_pending();
+}
diff -r 17e9560465b0 toolkit/components/places/tests/sync/test_database_sync_after_addVisit.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/components/places/tests/sync/test_database_sync_after_addVisit.js	Thu Oct 30 05:41:46 2008 -0400
@@ -0,0 +1,73 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * vim: sw=2 ts=2 sts=2 expandtab
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Shawn Wilsher <me@shawnwilsher.com> (Original Author)
+ *   Marco Bonardo <mak77@bonardo.net>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+var hs = Cc["@mozilla.org/browser/nav-history-service;1"].
+         getService(Ci.nsINavHistoryService);
+var bs = Cc["@mozilla.org/browser/nav-bookmarks-service;1"].
+         getService(Ci.nsINavBookmarksService);
+var prefs = Cc["@mozilla.org/preferences-service;1"].
+            getService(Ci.nsIPrefService).
+            getBranch("places.");
+
+const TEST_URI = "http://test.com/";
+
+const kSyncPrefName = "syncDBTableIntervalInSecs";
+const SYNC_INTERVAL = 1;
+
+function run_test()
+{
+  // First set the preference for the timer to a small value
+  prefs.setIntPref(kSyncPrefName, SYNC_INTERVAL);
+
+  // Now add the visit
+  let id = hs.addVisit(uri(TEST_URI), Date.now() * 1000, null,
+                       hs.TRANSITION_TYPED, false, 0);
+
+  // Check the visit, but after enough time has passed for the DB flush service
+  // to have fired it's timer.
+  let timer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
+  timer.initWithCallback({
+    notify: function(aTimer)
+    {
+      new_test_visit_uri_event(id, TEST_URI, true, true);
+    }
+  }, (SYNC_INTERVAL * 1000) * 2, Ci.nsITimer.TYPE_ONE_SHOT);
+  do_test_pending();
+}
diff -r 17e9560465b0 toolkit/components/places/tests/sync/test_database_sync_after_addVisit_batched.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/components/places/tests/sync/test_database_sync_after_addVisit_batched.js	Thu Oct 30 05:41:46 2008 -0400
@@ -0,0 +1,109 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * vim: sw=2 ts=2 sts=2 expandtab
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Shawn Wilsher <me@shawnwilsher.com> (Original Author)
+ *   Marco Bonardo <mak77@bonardo.net>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+  var bs = Cc["@mozilla.org/browser/nav-bookmarks-service;1"].
+           getService(Ci.nsINavBookmarksService);
+  var hs = Cc["@mozilla.org/browser/nav-history-service;1"].
+           getService(Ci.nsINavHistoryService);
+  var os = Cc["@mozilla.org/observer-service;1"].
+           getService(Ci.nsIObserverService);
+
+const TEST_URI = "http://test.com/";
+
+const kSyncFinished = "places-sync-finished";
+
+// Used to check if we are batching
+var bookmarksObserver = {
+  _batching: false,
+  onBeginUpdateBatch: function() {
+    this._batching = true;
+  },
+  onEndUpdateBatch: function() {
+    this._batching = false;
+  }
+}
+bs.addObserver(bookmarksObserver, false);
+
+// Used to update observer visitId
+var historyObserver = {
+  onVisit: function(aURI, aVisitId, aTime, aSessionId, aReferringId,
+                    aTransitionType, aAdded) {
+    observer.visitId = aVisitId;
+  }
+}
+hs.addObserver(historyObserver, false);
+
+var observer = {
+  visitId: -1,
+  observe: function(aSubject, aTopic, aData) {
+    if (aTopic == kSyncFinished) {
+      // visit id must be valid
+      do_check_neq(this.visitId, -1);
+      // Check that we are not in a batch
+      do_check_false(bookmarksObserver._batching);
+      // remove the observer, we don't need to observe sync on quit
+      os.removeObserver(this, kSyncFinished);
+      bs.removeObserver(bookmarksObserver);
+      hs.removeObserver(historyObserver);
+      // Check that tables have been correctly synced
+      new_test_visit_uri_event(this.visitId, TEST_URI, true, true);
+    }
+  }
+}
+os.addObserver(observer, kSyncFinished, false);
+
+function run_test()
+{
+  // Add a visit in batch mode
+  let id = -1;
+  bs.runInBatchMode({
+    runBatched: function(aUserData)
+    {
+      id = hs.addVisit(uri(TEST_URI), Date.now() * 1000, null,
+                       hs.TRANSITION_TYPED, false, 0);
+      // We should not sync during a batch
+      new_test_visit_uri_event(id, TEST_URI, false);
+    }
+  }, null);
+  // Ensure the visit has been added
+  do_check_neq(id, -1);
+
+  do_test_pending();
+}
diff -r 17e9560465b0 toolkit/components/places/tests/sync/test_database_sync_after_modifyBookmark.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/components/places/tests/sync/test_database_sync_after_modifyBookmark.js	Thu Oct 30 05:41:46 2008 -0400
@@ -0,0 +1,108 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * vim: sw=2 ts=2 sts=2 expandtab
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Shawn Wilsher <me@shawnwilsher.com> (Original Author)
+ *   Marco Bonardo <mak77@bonardo.net>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+var bs = Cc["@mozilla.org/browser/nav-bookmarks-service;1"].
+         getService(Ci.nsINavBookmarksService);
+var os = Cc["@mozilla.org/observer-service;1"].
+         getService(Ci.nsIObserverService);
+var prefs = Cc["@mozilla.org/preferences-service;1"].
+            getService(Ci.nsIPrefService).
+            getBranch("places.");
+
+const TEST_URI = "http://test.com/";
+const MODIFIED_URI = "http://test.com/index.html";
+
+const SYNC_INTERVAL = 600; // ten minutes
+const kSyncPrefName = "syncDBTableIntervalInSecs";
+const kSyncFinished = "places-sync-finished";
+
+// Used to update observer itemId
+var bookmarksObserver = {
+  onItemAdded: function(aItemId, aNewParent, aNewIndex) {
+    observer.itemId = aItemId;
+  },
+  onItemChanged: function(aItemId, aProperty, aValue) {
+    if (aProperty == "uri")
+      do_check_eq(observer.itemId, aItemId);
+  }
+}
+bs.addObserver(bookmarksObserver, false);
+
+var observer = {
+  itemId: -1,
+  _runCount: 0,
+  observe: function(aSubject, aTopic, aData) {
+    if (aTopic == kSyncFinished) {
+      // item id must be valid
+      do_check_neq(this.itemId, -1);
+      if (++this._runCount == 1) {
+        // First sync is fired by adding the bookmark
+        // Check that tables have been synced after insertBookmark
+        new_test_bookmark_uri_event(this.itemId, TEST_URI, true);
+        // Now modify the bookmark
+        bs.changeBookmarkURI(this.itemId, uri(MODIFIED_URI));
+      }
+      else if (this._runCount == 2) {
+        // Second sync is fired by changing the bookmark's uri
+        // remove the observer, we don't need to observe sync on quit
+        os.removeObserver(this, kSyncFinished);
+        bs.removeObserver(bookmarksObserver);
+        // Check that tables have been synced after changeBookmarkURI
+        new_test_bookmark_uri_event(this.itemId, MODIFIED_URI, true, true);
+      }
+      else
+        do_throw("Too many places sync calls");
+    }
+  }
+}
+os.addObserver(observer, kSyncFinished, false);
+
+function run_test()
+{
+  // Set the preference for the timer to a really large value, so it won't
+  // run before the test finishes.
+  prefs.setIntPref(kSyncPrefName, SYNC_INTERVAL);
+
+  // Insert a new bookmark
+  bs.insertBookmark(bs.unfiledBookmarksFolder, uri(TEST_URI),
+                    bs.DEFAULT_INDEX, "test");
+
+  do_test_pending();
+}
diff -r 17e9560465b0 toolkit/components/places/tests/sync/test_database_sync_after_quit_application.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/components/places/tests/sync/test_database_sync_after_quit_application.js	Thu Oct 30 05:41:46 2008 -0400
@@ -0,0 +1,93 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * vim: sw=2 ts=2 sts=2 expandtab
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Shawn Wilsher <me@shawnwilsher.com> (Original Author)
+ *   Marco Bonardo <mak77@bonardo.net>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+var os = Cc["@mozilla.org/observer-service;1"].
+         getService(Ci.nsIObserverService);
+var prefs = Cc["@mozilla.org/preferences-service;1"].
+            getService(Ci.nsIPrefService).
+            getBranch("places.");
+var hs = Cc["@mozilla.org/browser/nav-history-service;1"].
+         getService(Ci.nsINavHistoryService);
+
+const TEST_URI = "http://test.com/";
+
+const kSyncPrefName = "syncDBTableIntervalInSecs";
+const SYNC_INTERVAL = 600; // ten minutes
+const kSyncFinished = "places-sync-finished";
+
+var historyObserver = {
+  onVisit: function(aURI, aVisitId, aTime, aSessionId, aReferringId,
+                    aTransitionType, aAdded) {
+    observer.visitId = aVisitId;
+  }
+}
+hs.addObserver(historyObserver, false);
+
+var observer = {
+  visitId: -1,
+  observe: function(aSubject, aTopic, aData) {
+    if (aTopic == kSyncFinished) {
+      // visit id must be valid
+      do_check_neq(this.visitId, -1);
+      // remove the observer, we don't need to observe sync on quit
+      os.removeObserver(this, kSyncFinished);
+      hs.removeObserver(historyObserver);
+      // Check that tables have been correctly synced
+      new_test_visit_uri_event(this.visitId, TEST_URI, true, true);
+    }
+  }
+}
+os.addObserver(observer, kSyncFinished, false);
+
+function run_test()
+{
+  // Set the preference for the timer to a really large value, so it won't
+  // run before the test finishes.
+  prefs.setIntPref(kSyncPrefName, SYNC_INTERVAL);
+
+  // Now add a visit
+  hs.addVisit(uri(TEST_URI), Date.now() * 1000, null,
+              hs.TRANSITION_TYPED, false, 0);
+
+  // Notify that we are quitting the app - we should sync!
+  os.notifyObservers(null, "quit-application", null);
+
+  do_test_pending();
+}
diff -r 17e9560465b0 toolkit/components/places/tests/sync/test_multiple_bookmarks_around_sync.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/components/places/tests/sync/test_multiple_bookmarks_around_sync.js	Thu Oct 30 05:41:46 2008 -0400
@@ -0,0 +1,150 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * vim: sw=2 ts=2 sts=2 expandtab
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Shawn Wilsher <me@shawnwilsher.com> (Original Author)
+ *   Marco Bonardo <mak77@bonardo.net>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/**
+ * This test ensures that adding a bookmark (which has an implicit sync), then
+ * adding another one that has the same place, we end up with only one entry in
+ * moz_places.
+ */
+
+var bs = Cc["@mozilla.org/browser/nav-bookmarks-service;1"].
+         getService(Ci.nsINavBookmarksService);
+var hs = Cc["@mozilla.org/browser/nav-history-service;1"].
+         getService(Ci.nsINavHistoryService);
+var db = Cc["@mozilla.org/browser/nav-history-service;1"].
+         getService(Ci.nsPIPlacesDatabase).
+         DBConnection;
+var os = Cc["@mozilla.org/observer-service;1"].
+         getService(Ci.nsIObserverService);
+var prefs = Cc["@mozilla.org/preferences-service;1"].
+            getService(Ci.nsIPrefService).
+            getBranch("places.");
+
+const TEST_URI = "http://test.com/";
+
+const SYNC_INTERVAL = 600; // ten minutes
+const kSyncPrefName = "syncDBTableIntervalInSecs";
+const kSyncFinished = "places-sync-finished";
+
+// Used to update observer itemId
+var bookmarksObserver = {
+  onItemAdded: function(aItemId, aNewParent, aNewIndex) {
+    observer.itemIds.push(aItemId);
+  }
+}
+bs.addObserver(bookmarksObserver, false);
+
+var observer = {
+  itemIds: [],
+  _placeId: -1,
+  _runCount: 0,
+  observe: function(aSubject, aTopic, aData) {
+    if (aTopic == kSyncFinished) {
+      if (++this._runCount == 1) {
+        let itemId = this.itemIds[this._runCount - 1];
+        // item id must be valid
+        do_check_neq(itemId, null);
+        // Ensure tables have been synced
+        new_test_bookmark_uri_event(itemId, TEST_URI, true);
+
+        // Get the place_id
+        let stmt = db.createStatement(
+          "SELECT fk " +
+          "FROM moz_bookmarks " +
+          "WHERE id = ?"
+        );
+        stmt.bindInt64Parameter(0, itemId);
+        do_check_true(stmt.executeStep());
+        this._placeId = stmt.getInt64(0);
+        stmt.finalize();
+        stmt = null;
+        // place id must be valid
+        do_check_true(this._placeId > 0);
+      }
+      else if (this._runCount == 2) {
+        let itemId = this.itemIds[this._runCount - 1];
+        // item id must be valid
+        do_check_neq(itemId, null);
+        // Ensure it was added
+        new_test_bookmark_uri_event(itemId, TEST_URI, true);
+
+        // Check to make sure we have the same place_id
+        stmt = db.createStatement(
+          "SELECT * " +
+          "FROM moz_bookmarks " +
+          "WHERE id = ?1 " +
+          "AND fk = ?2"
+        );
+        stmt.bindInt64Parameter(0, itemId);
+        stmt.bindInt64Parameter(1, this._placeId);
+        do_check_true(stmt.executeStep());
+        stmt.finalize();
+        stmt = null;
+
+        // remove the observer, we don't need to observe sync on quit
+        os.removeObserver(this, kSyncFinished);
+        bs.removeObserver(bookmarksObserver);
+        // test ends here
+        finish_test();
+      }
+      else
+        do_throw("Too many places sync calls");
+    }
+  }
+}
+os.addObserver(observer, kSyncFinished, false);
+
+function run_test()
+{
+  // Set the preference for the timer to a really large value, so it won't
+  // run before the test finishes.
+  prefs.setIntPref(kSyncPrefName, SYNC_INTERVAL);
+
+  // Add the first bookmark
+  let id1 = bs.insertBookmark(bs.unfiledBookmarksFolder, uri(TEST_URI),
+                              bs.DEFAULT_INDEX, "test");
+
+  // Now we add another bookmark to a different folder
+  let id2 = bs.insertBookmark(bs.toolbarFolder, uri(TEST_URI),
+                              bs.DEFAULT_INDEX, "test");
+  do_check_neq(id1, id2);
+
+  do_test_pending();
+}
diff -r 17e9560465b0 toolkit/components/places/tests/sync/test_multiple_visits_around_sync.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/components/places/tests/sync/test_multiple_visits_around_sync.js	Thu Oct 30 05:41:46 2008 -0400
@@ -0,0 +1,127 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * vim: sw=2 ts=2 sts=2 expandtab
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Shawn Wilsher <me@shawnwilsher.com> (Original Author)
+ *  Marco Bonardo <mak77@bonardo.net>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/**
+ * This test ensures that when adding a visit, then syncing, and adding another
+ * visit to the same url creates two visits and that we only end up with one
+ * entry in moz_places.
+ */
+
+var hs = Cc["@mozilla.org/browser/nav-history-service;1"].
+         getService(Ci.nsINavHistoryService);
+var db = Cc["@mozilla.org/browser/nav-history-service;1"].
+         getService(Ci.nsPIPlacesDatabase).
+         DBConnection;
+var prefs = Cc["@mozilla.org/preferences-service;1"].
+            getService(Ci.nsIPrefService).
+            getBranch("places.");
+
+const TEST_URI = "http://test.com/";
+
+const kSyncPrefName = "syncDBTableIntervalInSecs";
+const SYNC_INTERVAL = 1;
+
+function run_test()
+{
+  // First set the preference for the timer to a small value
+  prefs.setIntPref(kSyncPrefName, SYNC_INTERVAL);
+
+  // Now add the first visit
+  let id = hs.addVisit(uri(TEST_URI), Date.now() * 1000, null,
+                       hs.TRANSITION_TYPED, false, 0);
+
+  // Check the visit, but after enough time has passed for the DB flush service
+  // to have fired it's timer.
+  let timer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
+  timer.initWithCallback({
+    notify: function(aTimer)
+    {
+      new_test_visit_uri_event(id, TEST_URI, true);
+
+      // Get the place_id and pass it on
+      let db = hs.QueryInterface(Ci.nsPIPlacesDatabase).DBConnection;
+      let stmt = db.createStatement(
+        "SELECT place_id " +
+        "FROM moz_historyvisits " +
+        "WHERE id = ?"
+      );
+      stmt.bindInt64Parameter(0, id);
+      do_check_true(stmt.executeStep());
+      continue_test(id, stmt.getInt64(0));
+      stmt.finalize();
+      stmt = null;
+    }
+  }, (SYNC_INTERVAL * 1000) * 2, Ci.nsITimer.TYPE_ONE_SHOT);
+  do_test_pending();
+}
+
+function continue_test(aLastVisitId, aPlaceId)
+{
+  // Now we add another visit
+  let id = hs.addVisit(uri(TEST_URI), Date.now() * 1000, null,
+                       hs.TRANSITION_TYPED, false, 0);
+  do_check_neq(aLastVisitId, id);
+
+  // Check the visit, but after enough time has passed for the DB flush service
+  // to have fired it's timer.
+  let timer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
+  timer.initWithCallback({
+    notify: function(aTimer)
+    {
+      new_test_visit_uri_event(id, TEST_URI, true);
+
+      // Check to make sure we have the same place_id
+      let db = hs.QueryInterface(Ci.nsPIPlacesDatabase).DBConnection;
+      let stmt = db.createStatement(
+        "SELECT * " +
+        "FROM moz_historyvisits " +
+        "WHERE id = ?1 " +
+        "AND place_id = ?2"
+      );
+      stmt.bindInt64Parameter(0, id);
+      stmt.bindInt64Parameter(1, aPlaceId);
+      do_check_true(stmt.executeStep());
+      stmt.finalize();
+      stmt = null;
+
+      finish_test();
+    }
+  }, (SYNC_INTERVAL * 1000) * 2, Ci.nsITimer.TYPE_ONE_SHOT);
+}
diff -r 17e9560465b0 toolkit/components/places/tests/unit/head_bookmarks.js
--- a/toolkit/components/places/tests/unit/head_bookmarks.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/components/places/tests/unit/head_bookmarks.js	Thu Oct 30 05:41:46 2008 -0400
@@ -100,3 +100,76 @@
   } catch(ex) { dump("Exception: " + ex); }
 }
 clearDB();
+
+/**
+ * Dumps the rows of a table out to the console.
+ *
+ * @param aName
+ *        The name of the table or view to output.
+ */
+function dump_table(aName)
+{
+  let db = Cc["@mozilla.org/browser/nav-history-service;1"].
+           getService(Ci.nsPIPlacesDatabase).
+           DBConnection;
+  let stmt = db.createStatement("SELECT * FROM " + aName);
+
+  dump("\n*** Printing data from " + aName + ":\n");
+  let count = 0;
+  while (stmt.executeStep()) {
+    let columns = stmt.numEntries;
+
+    if (count == 0) {
+      // print the column names
+      for (let i = 0; i < columns; i++)
+        dump(stmt.getColumnName(i) + "\t");
+      dump("\n");
+    }
+
+    // print the row
+    for (let i = 0; i < columns; i++) {
+      switch (stmt.getTypeOfIndex(i)) {
+        case Ci.mozIStorageValueArray.VALUE_TYPE_NULL:
+          dump("NULL\t");
+          break;
+        case Ci.mozIStorageValueArray.VALUE_TYPE_INTEGER:
+          dump(stmt.getInt64(i) + "\t");
+          break;
+        case Ci.mozIStorageValueArray.VALUE_TYPE_FLOAT:
+          dump(stmt.getDouble(i) + "\t");
+          break;
+        case Ci.mozIStorageValueArray.VALUE_TYPE_TEXT:
+          dump(stmt.getString(i) + "\t");
+          break;
+      }
+    }
+    dump("\n");
+
+    count++;
+  }
+  dump("*** There were a total of " + count + " rows of data.\n\n");
+
+  stmt.reset();
+  stmt.finalize();
+  stmt = null;
+}
+
+var syncSvc = null;
+function start_sync() {
+// profile-after-change doesn't create components in xpcshell, so we have to do
+// it ourselves
+  syncSvc = Cc["@mozilla.org/places/sync;1"].getService(Ci.nsISupports);
+}
+
+/**
+ * This dispatches the observer topic "quit-application" to clean up the sync
+ * component.
+ */
+function finish_test()
+{
+  // xpcshell doesn't dispatch shutdown-application
+  let os = Cc["@mozilla.org/observer-service;1"].
+           getService(Ci.nsIObserverService);
+  os.notifyObservers(null, "quit-application", null);
+  do_test_finished();
+}
diff -r 17e9560465b0 toolkit/components/places/tests/unit/test_expiration.js
--- a/toolkit/components/places/tests/unit/test_expiration.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/components/places/tests/unit/test_expiration.js	Thu Oct 30 05:41:46 2008 -0400
@@ -39,40 +39,21 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
-// Get history services
-try {
-  var histsvc = Cc["@mozilla.org/browser/nav-history-service;1"].
-                getService(Ci.nsINavHistoryService);
-  var bhist = histsvc.QueryInterface(Ci.nsIBrowserHistory);
-  var ghist = Cc["@mozilla.org/browser/global-history;2"].
-              getService(Ci.nsIGlobalHistory2);
-} catch(ex) {
-  do_throw("Could not get history services\n");
-}
+// execute this test while syncing, this will potentially show possible problems
+start_sync();
 
-// Get annotation service
-try {
-  var annosvc = Cc["@mozilla.org/browser/annotation-service;1"].
-                getService(Ci.nsIAnnotationService);
-} catch(ex) {
-  do_throw("Could not get annotation service\n");
-}
-
-// Get bookmark service
-try {
-  var bmsvc = Cc["@mozilla.org/browser/nav-bookmarks-service;1"].
-              getService(Ci.nsINavBookmarksService);
-} catch(ex) {
-  do_throw("Could not get nav-bookmarks-service\n");
-}
-
-// Get prefs service
-try {
-  var prefs = Cc["@mozilla.org/preferences-service;1"].
-              getService(Ci.nsIPrefBranch);
-} catch(ex) {
-  do_throw("Could not get prefs service\n");
-}
+// Get services
+var histsvc = Cc["@mozilla.org/browser/nav-history-service;1"].
+              getService(Ci.nsINavHistoryService);
+var bhist = histsvc.QueryInterface(Ci.nsIBrowserHistory);
+var ghist = Cc["@mozilla.org/browser/global-history;2"].
+            getService(Ci.nsIGlobalHistory2);
+var annosvc = Cc["@mozilla.org/browser/annotation-service;1"].
+              getService(Ci.nsIAnnotationService);
+var bmsvc = Cc["@mozilla.org/browser/nav-bookmarks-service;1"].
+            getService(Ci.nsINavBookmarksService);
+var prefs = Cc["@mozilla.org/preferences-service;1"].
+            getService(Ci.nsIPrefBranch);
 
 // create and add history observer
 var observer = {
@@ -646,7 +627,9 @@
   histsvc.removeAllPages();
   observer.expiredURI = null;
   dump("starting expiration test 3: both criteria met\n");
-
+  // force a sync, this will ensure that later we will have the same place in
+  // both temp and disk table, and that the expire site cap count is correct.
+  bmsvc.changeBookmarkURI(bookmark, testURI);
   // add visits
   // 2 days old, in microseconds
   var age = (Date.now() - (86400 * 2 * 1000)) * 1000;
@@ -832,5 +815,5 @@
     do_throw(ex);
   }
   dump("done incremental expiration test 6\n");
-  do_test_finished();
+  finish_test();
 }
diff -r 17e9560465b0 toolkit/components/places/tests/unit/test_history.js
--- a/toolkit/components/places/tests/unit/test_history.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/components/places/tests/unit/test_history.js	Thu Oct 30 05:41:46 2008 -0400
@@ -41,6 +41,8 @@
 // Get history service
 try {
   var histsvc = Cc["@mozilla.org/browser/nav-history-service;1"].getService(Ci.nsINavHistoryService);
+  var gh = Cc["@mozilla.org/browser/global-history;2"].
+           getService(Ci.nsIGlobalHistory2);
 } catch(ex) {
   do_throw("Could not get history service\n");
 } 
@@ -61,7 +63,9 @@
                                  histsvc.TRANSITION_TYPED, // user typed in URL bar
                                  false, // not redirect
                                  0);
+  dump("### Added visit with id of " + placeID + "\n");
   do_check_true(placeID > 0);
+  do_check_true(gh.isVisited(aURI));
   return placeID;
 }
 
diff -r 17e9560465b0 toolkit/components/typeaheadfind/src/nsTypeAheadFind.cpp
--- a/toolkit/components/typeaheadfind/src/nsTypeAheadFind.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/components/typeaheadfind/src/nsTypeAheadFind.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -1175,7 +1175,7 @@
   // We know that the target range isn't usable because it's not in the
   // view port. Move range forward to first visible point,
   // this speeds us up a lot in long documents
-  nsCOMPtr<nsIBidirectionalEnumerator> frameTraversal;
+  nsCOMPtr<nsIFrameEnumerator> frameTraversal;
   nsCOMPtr<nsIFrameTraversal> trav(do_CreateInstance(kFrameTraversalCID));
   if (trav)
     trav->NewFrameTraversal(getter_AddRefs(frameTraversal),
@@ -1191,9 +1191,7 @@
 
   while (rectVisibility == nsRectVisibility_kAboveViewport || rectVisibility == nsRectVisibility_kZeroAreaRect) {
     frameTraversal->Next();
-    nsISupports* currentItem;
-    frameTraversal->CurrentItem(&currentItem);
-    frame = static_cast<nsIFrame*>(currentItem);
+    frame = frameTraversal->CurrentItem();
     if (!frame)
       return PR_FALSE;
 
diff -r 17e9560465b0 toolkit/content/tests/reftests/bug-442419-progressmeter-max-ref.xul
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/content/tests/reftests/bug-442419-progressmeter-max-ref.xul	Thu Oct 30 05:41:46 2008 -0400
@@ -0,0 +1,7 @@
+<?xml version="1.0"?>
+<?xml-stylesheet href="chrome://global/skin/global.css" type="text/css"?>
+
+<window xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
+  <progressmeter value="50"/> <!-- default is max = 100 -->
+</window>
+
diff -r 17e9560465b0 toolkit/content/tests/reftests/bug-442419-progressmeter-max.xul
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/content/tests/reftests/bug-442419-progressmeter-max.xul	Thu Oct 30 05:41:46 2008 -0400
@@ -0,0 +1,7 @@
+<?xml version="1.0"?>
+<?xml-stylesheet href="chrome://global/skin/global.css" type="text/css"?>
+
+<window xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
+  <progressmeter  max="198" value="99"/> <!-- 50% -->
+</window>
+
diff -r 17e9560465b0 toolkit/content/tests/reftests/reftest.list
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/content/tests/reftests/reftest.list	Thu Oct 30 05:41:46 2008 -0400
@@ -0,0 +1,1 @@
+== bug-442419-progressmeter-max.xul bug-442419-progressmeter-max-ref.xul
diff -r 17e9560465b0 toolkit/content/tests/widgets/test_colorpicker_popup.xul
--- a/toolkit/content/tests/widgets/test_colorpicker_popup.xul	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/content/tests/widgets/test_colorpicker_popup.xul	Thu Oct 30 05:41:46 2008 -0400
@@ -24,12 +24,18 @@
 
 SimpleTest.waitForExplicitFinish();
 
+function preventDefault(event) {
+  event.preventDefault();
+}
+
 function runTests()
 {
   gCp = document.getElementById("colorpicker-popup");
   is(gCp.color, "#FF0000", "popup color is initialized");
   is(gCp.tabIndex, 1, "button tabindex is initialized");
   is(gCp.disabled, false, "button is not disabled");
+  
+  document.addEventListener("keypress", preventDefault, false);
 
   goNext();
 }
@@ -97,6 +103,7 @@
 {
   gTestPhase++;
   if (gTestPhase >= phases.length) {
+    document.removeEventListener("keypress", preventDefault, false);
     SimpleTest.finish();
     return;
   }
diff -r 17e9560465b0 toolkit/content/tests/widgets/test_mousescroll.xul
--- a/toolkit/content/tests/widgets/test_mousescroll.xul	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/content/tests/widgets/test_mousescroll.xul	Thu Oct 30 05:41:46 2008 -0400
@@ -122,37 +122,49 @@
   });
 }
 
-function testRichListbox(id)
+function testRichListbox(id, andThen)
 {
   var listbox = document.getElementById(id);
-  
-  function helper(aStart, aDelta, aExpected, aKind)
+  var tests = [];
+
+  function helper()
   {
+    var [aStart, aDelta, aExpected, aKind] = tests[0];
+    tests.shift();
     listbox.scrollToIndex(aStart);
     synthesizeMouseScroll(listbox, 10, 10,
                           {axis:"vertical", delta:aDelta, type:aKind.eventType,
                            hasPixels:aKind.hasPixels});
-    is(listbox.getIndexOfFirstVisibleRow(), aKind.shouldScrollNative ? aExpected : aStart,
-       "mouse-scroll of '" + id + "' vertical starting " + aStart + " delta " + aDelta
-       + " eventType " + aKind.eventType + " hasPixels " + aKind.hasPixels);
-
-    // Check that horizontal scrolling has no effect
-    listbox.scrollToIndex(aStart);
-    synthesizeMouseScroll(listbox, 10, 10,
-                          {axis:"horizontal", delta:aDelta, type:aKind.eventType,
-                           hasPixels:aKind.hasPixels});  
-    is(listbox.getIndexOfFirstVisibleRow(), aStart,
-       "mouse-scroll of '" + id + "' horizontal starting " + aStart + " delta " + aDelta
-       + " eventType " + aKind.eventType + " hasPixels " + aKind.hasPixels);
+    setTimeout(function() {
+      is(listbox.getIndexOfFirstVisibleRow(), aKind.shouldScrollNative ? aExpected : aStart,
+         "mouse-scroll of '" + id + "' vertical starting " + aStart + " delta " + aDelta
+         + " eventType " + aKind.eventType + " hasPixels " + aKind.hasPixels);
+  
+      // Check that horizontal scrolling has no effect
+      listbox.scrollToIndex(aStart);
+      synthesizeMouseScroll(listbox, 10, 10,
+                            {axis:"horizontal", delta:aDelta, type:aKind.eventType,
+                             hasPixels:aKind.hasPixels});
+      setTimeout(function() {
+        is(listbox.getIndexOfFirstVisibleRow(), aStart,
+           "mouse-scroll of '" + id + "' horizontal starting " + aStart + " delta " + aDelta
+           + " eventType " + aKind.eventType + " hasPixels " + aKind.hasPixels);
+        if (tests.length)
+          helper();
+        else
+          andThen();
+      }, 0);
+    }, 0);
   }
   
   // richlistbox currently uses native XUL scrolling, so the "line"
   // amounts don't necessarily correspond 1-to-1 with listbox items. So
   // we just check that scrolling up/down a lot hits the first/last items
   kinds.forEach(function(aKind) {
-    helper(2, -100, 0, aKind);
-    helper(2, 100, listbox.getRowCount() - listbox.getNumberOfVisibleRows(), aKind);
+    tests.push([2, -100, 0, aKind]);
+    tests.push([2, 100, listbox.getRowCount() - listbox.getNumberOfVisibleRows(), aKind]);
   });
+  helper();
 }
 
 function testArrowScrollbox(id)
@@ -207,11 +219,12 @@
 
 function runTests()
 {
-  testRichListbox("richlistbox");
-  testListbox("listbox");
-  testArrowScrollbox("hscrollbox");
-  testArrowScrollbox("vscrollbox");
-  SimpleTest.finish();
+  testRichListbox("richlistbox", function() {
+    testListbox("listbox");
+    testArrowScrollbox("hscrollbox");
+    testArrowScrollbox("vscrollbox");
+    SimpleTest.finish();
+  });
 }
 
 window.onload = function() { setTimeout(runTests, 0); };
diff -r 17e9560465b0 toolkit/content/widgets/progressmeter.xml
--- a/toolkit/content/widgets/progressmeter.xml	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/content/widgets/progressmeter.xml	Thu Oct 30 05:41:46 2008 -0400
@@ -22,16 +22,17 @@
       <property name="value" onget="return this.getAttribute('value') || '0';">
         <setter><![CDATA[
           var p = Math.round(val);
+          var max = Math.round(this.max);
           if (p < 0)
             p = 0;
-          else if (p > 100)
-            p = 100;
+          else if (p > max)
+            p = max;
           var c = this.value; 
           if (p != c) {
             var delta = p - c;
             if (delta < 0)
               delta = -delta;
-            if (delta > 3 || p == 0 || p == 100) {
+            if (delta > 3 || p == 0 || p == max) {
               this.setAttribute("value", p);
               // Fire DOM event so that accessible value change events occur
               var event = document.createEvent('Events');
@@ -43,6 +44,11 @@
           return val;
         ]]></setter>
       </property>
+      <property name="max"
+                onget="return this.getAttribute('max') || '100';"
+                onset="this.setAttribute('max', isNaN(val) ? 100 : Math.max(val, 1));
+                       this.value = this.value;
+                       return val;" />
 
       <property name="accessibleType" readonly="true">
         <getter>
diff -r 17e9560465b0 toolkit/content/widgets/tabbox.xml
--- a/toolkit/content/widgets/tabbox.xml	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/content/widgets/tabbox.xml	Thu Oct 30 05:41:46 2008 -0400
@@ -258,16 +258,13 @@
         if (this.lastChild)
           this.lastChild.setAttribute("last-tab", "true");
 
-        var o = this.getAttribute("orient");
-        if (!o)
+        if (!this.hasAttribute("orient"))
           this.setAttribute("orient", "horizontal");
 
-        for (var parent = this.parentNode; parent; parent = parent.parentNode) {
-          if (parent.localName == "tabbox" && parent.hasAttribute("selectedIndex")) {
-            var selectedIndex = parseInt(parent.getAttribute("selectedIndex"));
-            this.selectedIndex = selectedIndex > 0 ? selectedIndex : 0;
-            return;
-          }
+        if (this._tabbox && this._tabbox.hasAttribute("selectedIndex")) {
+          let selectedIndex = parseInt(this._tabbox.getAttribute("selectedIndex"));
+          this.selectedIndex = selectedIndex > 0 ? selectedIndex : 0;
+          return;
         }
 
         var children = this.childNodes;
@@ -314,6 +311,16 @@
         </setter>
       </property>
 
+      <field name="_tabbox"><![CDATA[
+        var parent = this.parentNode;
+        while (parent) {
+          if (parent.localName == "tabbox")
+            break;
+          parent = parent.parentNode;
+        }
+        parent;
+      ]]></field>
+
       <property name="selectedIndex">
         <getter>
         <![CDATA[
@@ -340,21 +347,18 @@
 
             this.setAttribute("value", tab.value);
 
-            for (var parent = this.parentNode; parent; parent = parent.parentNode) {
-              if (parent.localName == 'tabbox') {
-                parent.setAttribute("selectedIndex", val);
-                var tabpanels = parent.tabpanels;
-                // This will cause an onselect event to fire for the tabpanel element.
-                if (tabpanels) {
-                  // find an id 
-                  var linkedPanelId = tab.linkedPanel;
-                  var linkedPanel = linkedPanelId ? document.getElementById(linkedPanelId) : null;
-                  if (linkedPanel)
-                    tabpanels.selectedPanel = linkedPanel;
-                  else
-                    tabpanels.selectedIndex = val;
-                }
-                break;
+            if (this._tabbox) {
+              this._tabbox.setAttribute("selectedIndex", val);
+              var tabpanels = this._tabbox.tabpanels;
+              // This will cause an onselect event to fire for the tabpanel element.
+              if (tabpanels) {
+                // find an id
+                let linkedPanelId = tab.linkedPanel;
+                let linkedPanel = linkedPanelId ? document.getElementById(linkedPanelId) : null;
+                if (linkedPanel)
+                  tabpanels.selectedPanel = linkedPanel;
+                else
+                  tabpanels.selectedIndex = val;
               }
             }
 
@@ -440,17 +444,14 @@
             document.commandDispatcher.advanceFocusIntoSubtree(aNewTab);
             
             // Make sure that the focus doesn't move outside the tabbox
-            for (var parent = this.parentNode; parent; parent = parent.parentNode) {
-              if (parent.localName == "tabbox") {
-                try {
-                  var el = document.commandDispatcher.focusedElement;
-                  while (el && el != parent)
-                    el = el.parentNode;
-                  if (el != parent)
-                    aNewTab.focus();
-                } catch(e) {
-                }
-                break;
+            if (this._tabbox) {
+              try {
+                let el = document.commandDispatcher.focusedElement;
+                while (el && el != this._tabbox)
+                  el = el.parentNode;
+                if (el != this._tabbox)
+                  aNewTab.focus();
+              } catch(e) {
               }
             }
           }
diff -r 17e9560465b0 toolkit/content/widgets/tree.xml
--- a/toolkit/content/widgets/tree.xml	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/content/widgets/tree.xml	Thu Oct 30 05:41:46 2008 -0400
@@ -209,11 +209,12 @@
           var col = this.columns.getFirstColumn();
           var lastCol = null;
           var currentX = this.boxObject.x;
+          var adjustedX = aX + this.treeBoxObject.horizontalPosition;
           while (col) {
             var cw = col.element.boxObject.width;
             if (cw > 0) {
               currentX += cw;
-              if (currentX - (cw * aThresh) > aX)
+              if (currentX - (cw * aThresh) > adjustedX)
                 return col.element;
             }
             lastCol = col;
diff -r 17e9560465b0 toolkit/content/widgets/videocontrols.xml
--- a/toolkit/content/widgets/videocontrols.xml	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/content/widgets/videocontrols.xml	Thu Oct 30 05:41:46 2008 -0400
@@ -14,15 +14,13 @@
 
     <xbl:content xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
         <spacer flex="1"/>
-        <stack xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
-            <hbox id="controlsBackground">
-                <image id="playButton"
-                       onclick="this.parentNode.parentNode.parentNode.Utils.togglePause();"/>
-                <box id="controlsMiddle" flex="1"/>
-                <image id="muteButton"
-                       onclick="this.parentNode.parentNode.parentNode.Utils.toggleMute();"/>
-            </hbox>
-        </stack>
+        <hbox id="controlsBackground">
+            <image id="playButton"
+                   onclick="if (event.button == 0) this.parentNode.parentNode.Utils.togglePause();"/>
+            <box id="controlsMiddle" flex="1"/>
+            <image id="muteButton"
+                   onclick="if (event.button == 0) this.parentNode.parentNode.Utils.toggleMute();"/>
+        </hbox>
     </xbl:content>
 
     <implementation implements="nsISecurityCheckedComponent">
@@ -88,7 +86,7 @@
                 animationDirection : 1,
                 animationTimer : null,
 
-                onMediaEvent : function (aEvent) {
+                handleEvent : function (aEvent) {
                     this.log("Got " + aEvent.type + " media event");
                     switch (aEvent.type) {
                         case "play":
@@ -103,8 +101,6 @@
                         default:
                             this.log("!!! event " + aEvent.type + " not handled!");
                     }
-
-                    return false;
                 },
 
                 fadeControls : function (self) {
@@ -163,27 +159,22 @@
         <method name="init">
             <body>
             <![CDATA[
-            var self = this;
             var video = this.parentNode;
             this.Utils.video = video;
-            this.Utils.controls = self;
+            this.Utils.controls = this;
 
-            this.Utils.playButton = document.getAnonymousElementByAttribute(self, "id", "playButton");
-            this.Utils.muteButton = document.getAnonymousElementByAttribute(self, "id", "muteButton");
+            this.Utils.playButton = document.getAnonymousElementByAttribute(this, "id", "playButton");
+            this.Utils.muteButton = document.getAnonymousElementByAttribute(this, "id", "muteButton");
 
             // Set initial state of play/pause button.
-            // XXX (force to a bool, due to bug 457964)
-            this.Utils.playButton.setAttribute("paused", video.paused ? true : false);
-
-            function eventBouncer(aEvent) {
-                self.Utils.onMediaEvent(aEvent);
-            }
+            this.Utils.playButton.setAttribute("paused", video.paused);
 
             this.style.opacity = 0;
 
-            video.addEventListener("play",         eventBouncer, false);
-            video.addEventListener("pause",        eventBouncer, false);
-            video.addEventListener("volumechange", eventBouncer, false);
+            // Use Utils.handleEvent() callback for all media events.
+            video.addEventListener("play",         this.Utils, false);
+            video.addEventListener("pause",        this.Utils, false);
+            video.addEventListener("volumechange", this.Utils, false);
 
             this.Utils.log("--- videocontrols initialized ---");
             ]]>
diff -r 17e9560465b0 toolkit/locales/en-US/chrome/mozapps/help/help.dtd
--- a/toolkit/locales/en-US/chrome/mozapps/help/help.dtd	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/locales/en-US/chrome/mozapps/help/help.dtd	Thu Oct 30 05:41:46 2008 -0400
@@ -22,9 +22,8 @@
 <!ENTITY printButton.tooltip            "Print this page">
 <!ENTITY closeWindow.commandkey         "W">
 
-<!ENTITY searchtab.label                "Search">
-<!ENTITY searchtab.accesskey            "S">
-<!ENTITY searchClose.tooltip            "Close search results">
+<!ENTITY search.emptytext               "Search">
+<!ENTITY searchHeader.label             "Search results">
 <!ENTITY toctab.label                   "Contents">
 <!ENTITY toctab.accesskey               "C">
 
diff -r 17e9560465b0 toolkit/mozapps/downloads/content/downloads.js
--- a/toolkit/mozapps/downloads/content/downloads.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/mozapps/downloads/content/downloads.js	Thu Oct 30 05:41:46 2008 -0400
@@ -298,6 +298,17 @@
     try {
       dontAsk = !pref.getBoolPref(PREF_BDM_ALERTONEXEOPEN);
     } catch (e) { }
+
+#ifdef XP_WIN
+    // On Vista and above, we rely on native security prompting for
+    // downloaded content.
+    try {
+        var sysInfo = Cc["@mozilla.org/system-info;1"].
+                      getService(Ci.nsIPropertyBag2);
+        if (parseFloat(sysInfo.getProperty("version")) >= 6)
+          dontAsk = true;
+    } catch (ex) { }
+#endif
 
     if (!dontAsk) {
       var strings = document.getElementById("downloadStrings");
diff -r 17e9560465b0 toolkit/mozapps/downloads/tests/chrome/test_retention_is_0_closes.xul
--- a/toolkit/mozapps/downloads/tests/chrome/test_retention_is_0_closes.xul	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/mozapps/downloads/tests/chrome/test_retention_is_0_closes.xul	Thu Oct 30 05:41:46 2008 -0400
@@ -99,7 +99,7 @@
       ww.unregisterNotification(this);
 
       // Let the UI finish doing whatever it needs to do
-      executeSoon(function() {
+      SimpleTest.executeSoon(function() {
         setPref(false);
 
         let dmui = Cc["@mozilla.org/download-manager-ui;1"].
diff -r 17e9560465b0 toolkit/mozapps/downloads/tests/chrome/test_unkownContentType_dialog_layout.xul
--- a/toolkit/mozapps/downloads/tests/chrome/test_unkownContentType_dialog_layout.xul	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/mozapps/downloads/tests/chrome/test_unkownContentType_dialog_layout.xul	Thu Oct 30 05:41:46 2008 -0400
@@ -92,7 +92,7 @@
         return;
 
       // Let the dialog initialize
-      executeSoon(function() {
+      SimpleTest.executeSoon(function() {
         checkWindow(win);
         testIndex++;
         if (!tests[testIndex]) {
diff -r 17e9560465b0 toolkit/mozapps/downloads/tests/chrome/utils.js
--- a/toolkit/mozapps/downloads/tests/chrome/utils.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/mozapps/downloads/tests/chrome/utils.js	Thu Oct 30 05:41:46 2008 -0400
@@ -43,22 +43,6 @@
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cr = Components.results;
-
-/**
- * Executes a function shortly after the call, but lets the caller continue
- * working (or finish).
- */
-function executeSoon(aFunc)
-{
-  let tm = Cc["@mozilla.org/thread-manager;1"].getService(Ci.nsIThreadManager);
-
-  tm.mainThread.dispatch({
-    run: function()
-    {
-      aFunc();
-    }
-  }, Ci.nsIThread.DISPATCH_NORMAL);
-}
 
 /**
  * Adds a live download to the download manager.
diff -r 17e9560465b0 toolkit/mozapps/installer/package-name.mk
--- a/toolkit/mozapps/installer/package-name.mk	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/mozapps/installer/package-name.mk	Thu Oct 30 05:41:46 2008 -0400
@@ -110,16 +110,25 @@
 endif
 MOZ_PKG_APPNAME_LC = $(shell echo $(MOZ_PKG_APPNAME) | tr '[A-Z]' '[a-z]')
 
+
 ifndef MOZ_PKG_LONGVERSION
-MOZ_PKG_LONGVERSION = $(MOZ_PKG_VERSION)
+MOZ_PKG_LONGVERSION = $(shell echo $(MOZ_PKG_VERSION) |\
+                       sed -e 's/a\([0-9][0-9]*\)$/ Alpha \1/' |\
+                       sed -e 's/b\([0-9][0-9]*\)$/ Beta \1/' |\
+                       sed -e 's/rc\([0-9][0-9]*\)$/ RC \1/')
 endif
 
-ifeq (,$(filter-out Darwin OS2 WINNT, $(OS_ARCH)))
+ifeq (,$(filter-out Darwin OS2, $(OS_ARCH))) # Mac and OS2
 PKG_BASENAME = $(MOZ_PKG_APPNAME) $(MOZ_PKG_LONGVERSION)
+PKG_INST_BASENAME = $(MOZ_PKG_APPNAME) Setup $(MOZ_PKG_LONGVERSION)
+else
+ifeq (,$(filter-out WINNT, $(OS_ARCH))) # Windows
+PKG_BASENAME = $(MOZ_PKG_APPNAME_LC)-$(MOZ_PKG_VERSION)
 PKG_INST_BASENAME = $(MOZ_PKG_APPNAME) Setup $(MOZ_PKG_LONGVERSION)
 else # unix (actually, not Windows, Mac or OS/2)
 PKG_BASENAME = $(MOZ_PKG_APPNAME_LC)-$(MOZ_PKG_VERSION)
 PKG_INST_BASENAME = $(MOZ_PKG_APPNAME_LC)-setup-$(MOZ_PKG_VERSION)
+endif
 endif
 PKG_PATH = $(MOZ_PKG_PLATFORM)/$(AB_CD)/
 PKG_INST_PATH = $(PKG_PATH)
diff -r 17e9560465b0 toolkit/mozapps/installer/packager.mk
--- a/toolkit/mozapps/installer/packager.mk	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/mozapps/installer/packager.mk	Thu Oct 30 05:41:46 2008 -0400
@@ -225,6 +225,7 @@
 	core \
 	bsdecho \
 	gtscc \
+	js-config \
 	jscpucfg \
 	nsinstall \
 	viewer \
@@ -287,7 +288,7 @@
 ifeq ($(OS_ARCH),OS2)
 STRIP		= $(MOZILLA_DIR)/toolkit/mozapps/installer/os2/strip.cmd
 STRIP_FLAGS	=
-PLATFORM_EXCLUDE_LIST = ! -name "*.ico"
+PLATFORM_EXCLUDE_LIST = ! -name "*.ico" ! -name "$(MOZ_PKG_APPNAME).exe"
 endif
 
 ifneq (,$(filter WINNT OS2,$(OS_ARCH)))
diff -r 17e9560465b0 toolkit/mozapps/installer/windows/nsis/makensis.mk
--- a/toolkit/mozapps/installer/windows/nsis/makensis.mk	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/mozapps/installer/windows/nsis/makensis.mk	Thu Oct 30 05:41:46 2008 -0400
@@ -72,8 +72,8 @@
 	cd $(DEPTH)/installer-stage && $(CYGWIN_WRAPPER) 7z a -r -t7z $(ABS_CONFIG_DIR)/app.7z -mx -m0=BCJ2 -m1=LZMA:d24 -m2=LZMA:d19 -m3=LZMA:d19  -mb0:1 -mb0s1:2 -mb0s2:3
 	$(MAKE) $(CONFIG_DIR)/7zSD.sfx
 	$(NSINSTALL) -D $(DIST)/$(PKG_INST_PATH)
-	cat $(CONFIG_DIR)/7zSD.sfx $(CONFIG_DIR)/app.tag $(CONFIG_DIR)/app.7z > $(DIST)/$(PKG_INST_PATH)$(PKG_INST_BASENAME).exe
-	chmod 0755 $(DIST)/$(PKG_INST_PATH)$(PKG_INST_BASENAME).exe
+	cat $(CONFIG_DIR)/7zSD.sfx $(CONFIG_DIR)/app.tag $(CONFIG_DIR)/app.7z > "$(DIST)/$(PKG_INST_PATH)$(PKG_INST_BASENAME).exe"
+	chmod 0755 "$(DIST)/$(PKG_INST_PATH)$(PKG_INST_BASENAME).exe"
 
 # For building the uninstaller during the application build so it can be
 # included for mar file generation.
diff -r 17e9560465b0 toolkit/mozapps/shared/src/badCertHandler.js
--- a/toolkit/mozapps/shared/src/badCertHandler.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/mozapps/shared/src/badCertHandler.js	Thu Oct 30 05:41:46 2008 -0400
@@ -22,6 +22,7 @@
  * Contributor(s):
  *  Darin Fisher <darin@meer.net>
  *  Daniel Veditz <dveditz@mozilla.com>
+ *  Jesper Kristensen <mail@jesperkristensen.dk>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -56,8 +57,19 @@
     issuer = cert.issuer;
   }
 
-  if (!issuer || issuer.tokenName != "Builtin Object Token")
-    throw "cert issuer is not built-in";
+  var errorstring = "cert issuer is not built-in";
+  if (!issuer)
+    throw errorstring;
+
+  issuer = issuer.QueryInterface(Ci.nsIX509Cert3);
+  var tokenNames = issuer.getAllTokenNames({});
+
+  if (!tokenNames.some(isBuiltinToken))
+    throw errorstring;
+}
+
+function isBuiltinToken(tokenName) {
+  return tokenName == "Builtin Object Token";
 }
 
 /**
diff -r 17e9560465b0 toolkit/themes/gnomestripe/help/help.css
--- a/toolkit/themes/gnomestripe/help/help.css	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/themes/gnomestripe/help/help.css	Thu Oct 30 05:41:46 2008 -0400
@@ -107,10 +107,6 @@
 /* Set the minimum sidebar width so the help contents aren't squeezed together.*/
 #help-sidebar { min-width: 15em; width: 20em; max-width: 25em; }
 
-#search-sidebar-closebutton {
-  list-style-image: url("moz-icon://stock/gtk-close?size=menu");
-}
-
 #context-copy[disabled="true"] {
   display: none;
 }
diff -r 17e9560465b0 toolkit/themes/pinstripe/global/checkbox/cbox-check-dis.gif
Binary file toolkit/themes/pinstripe/global/checkbox/cbox-check-dis.gif has changed
diff -r 17e9560465b0 toolkit/themes/pinstripe/global/checkbox/cbox-check.gif
Binary file toolkit/themes/pinstripe/global/checkbox/cbox-check.gif has changed
diff -r 17e9560465b0 toolkit/themes/pinstripe/global/jar.mn
--- a/toolkit/themes/pinstripe/global/jar.mn	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/themes/pinstripe/global/jar.mn	Thu Oct 30 05:41:46 2008 -0400
@@ -77,6 +77,8 @@
 +  skin/classic/global/arrow/arrow-up-sharp.gif                       (arrow/arrow-up-sharp.gif)
 +  skin/classic/global/arrow/arrow-up.gif                             (arrow/arrow-up.gif)
 +  skin/classic/global/arrow/arrow-up.png                             (arrow/arrow-up.png)
++  skin/classic/global/checkbox/cbox-check.gif                        (checkbox/cbox-check.gif)
++  skin/classic/global/checkbox/cbox-check-dis.gif                    (checkbox/cbox-check-dis.gif)
 +  skin/classic/global/console/console-toolbar.png                    (console/console-toolbar.png)
 +  skin/classic/global/console/console-bullets.png                    (console/console-bullets.png)
 +  skin/classic/global/console/console-error-caret.gif                (console/console-error-caret.gif)
diff -r 17e9560465b0 toolkit/themes/pinstripe/global/tabbox.css
--- a/toolkit/themes/pinstripe/global/tabbox.css	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/themes/pinstripe/global/tabbox.css	Thu Oct 30 05:41:46 2008 -0400
@@ -107,9 +107,3 @@
   background-color		: #EEEEEE;
   margin-bottom: 10px;
 }
-
-tabstrip-box {
-	-moz-appearance: tabpanels;
-        margin-top: -1px;
-}
-
diff -r 17e9560465b0 toolkit/themes/pinstripe/help/help.css
--- a/toolkit/themes/pinstripe/help/help.css	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/themes/pinstripe/help/help.css	Thu Oct 30 05:41:46 2008 -0400
@@ -59,7 +59,6 @@
   border: 0px !important;
 }
 
-
 /* Hide labels for the toolbar because we really don't need them what with the
    tooltips */
 #HelpToolbar .toolbarbutton-text {
@@ -68,22 +67,6 @@
 
 /* Set the minimum sidebar width so the help contents aren't squeezed together.*/
 #help-sidebar { min-width: 15em; width: 20em; max-width: 25em; }
-
-#search-sidebar-closebutton {
-  -moz-binding: url(chrome://global/content/bindings/toolbarbutton.xml#toolbarbutton-image);
-  list-style-image: url("chrome://global/skin/icons/closetab.png");
-  padding-right: 4px;
-  margin: 0;
-  border: 0;
-}
-
-#search-sidebar-closebutton:hover {
-  list-style-image: url("chrome://global/skin/icons/closetab-hover.png");
-}
-
-#search-sidebar-closebutton:hover:active {
-  list-style-image: url("chrome://global/skin/icons/closetab-active.png");
-}
 
 #help-back-button { -moz-image-region: rect(0px 24px 24px 0px); }
 #help-back-button:not([disabled="true"]):hover { -moz-image-region: rect(24px 24px 48px 0px); }
@@ -150,28 +133,6 @@
   -moz-image-region: rect(72px, 14px, 96px, 0px);
 }
 
-
 #helpsidebar-splitter {
   border-right: 1px solid #bebebe;
 }
-
-#helpsidebar-box toolbarbutton {
-  background-image: url("chrome://global/skin/icons/white-gray-gradient.gif");
-  background-repeat: repeat-x;
-  background-position: bottom right;
-  background-color: rgb(246, 246, 246);
-  border-bottom: 1px solid #b3b3b3;
-  border-right: 1px solid #bebebe;
-  margin: 0px;
-  text-align: left;
-  color: #505050;
-}
-
-#helpsidebar-box toolbarbutton[selected="true"] {
-  color: #000;
-}
-
-#helpsidebar-box tree {
-  margin: 0px !important;
-  padding: 0px !important;
-}
diff -r 17e9560465b0 toolkit/themes/pmstripe/global/popup.css
--- a/toolkit/themes/pmstripe/global/popup.css	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/themes/pmstripe/global/popup.css	Thu Oct 30 05:41:46 2008 -0400
@@ -83,10 +83,6 @@
   font: message-box;
 }
 
-.tooltip-label {
-  margin: 0px !important;
-}
-
 tooltip[titletip="true"] {
  /* See bug 32157 comment 128
   * margin: -2px 0px 0px -3px;
diff -r 17e9560465b0 toolkit/themes/winstripe/global/global.css
--- a/toolkit/themes/winstripe/global/global.css	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/themes/winstripe/global/global.css	Thu Oct 30 05:41:46 2008 -0400
@@ -162,9 +162,11 @@
   cursor: se-resize;
 }
 
+%ifdef XP_WIN
 window:not([active="true"]) menubar > menu {
   color: ThreeDShadow;
 }
+%endif
 
 /* XXXBlake yeah, shoot me -- these don't belong here.  I'll move them later. */
 
diff -r 17e9560465b0 toolkit/themes/winstripe/global/xulscrollbars.css
--- a/toolkit/themes/winstripe/global/xulscrollbars.css	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/themes/winstripe/global/xulscrollbars.css	Thu Oct 30 05:41:46 2008 -0400
@@ -84,7 +84,7 @@
 /* ::::: scrollbar button ::::: */
 
 scrollbarbutton {
-  background: -moz-Dialog no-repeat 0px 1px;
+  background: -moz-Dialog no-repeat 50% 50%;
   min-width: 16px;
   min-height: 16px;
 }
@@ -94,7 +94,7 @@
   -moz-border-right-colors: ThreeDShadow -moz-Dialog;
   -moz-border-bottom-colors: ThreeDShadow -moz-Dialog;
   -moz-border-left-colors: ThreeDShadow -moz-Dialog;
-  background-position: 1px 2px;
+  background-position: 60% 60%;
 }
 
 /* ::::: square at the corner of two scrollbars ::::: */
@@ -192,7 +192,7 @@
   /* ::::: scrollbar button ::::: */
 
   html|div scrollbarbutton {
-    background: -moz-Dialog no-repeat 0px 1px;
+    background: -moz-Dialog no-repeat 50% 50%;
     min-width: 16px;
     min-height: 16px;
   }
@@ -202,7 +202,7 @@
     -moz-border-right-colors: ThreeDShadow -moz-Dialog;
     -moz-border-bottom-colors: ThreeDShadow -moz-Dialog;
     -moz-border-left-colors: ThreeDShadow -moz-Dialog;
-    background-position: 1px 2px;
+    background-position: 60% 60%;
   }
 
   /* ..... increment .... */
diff -r 17e9560465b0 toolkit/themes/winstripe/help/help.css
--- a/toolkit/themes/winstripe/help/help.css	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/themes/winstripe/help/help.css	Thu Oct 30 05:41:46 2008 -0400
@@ -63,22 +63,6 @@
 
 /* Set the minimum sidebar width so the help contents aren't squeezed together.*/
 #help-sidebar { min-width: 15em; width: 20em; max-width: 25em; }
-
-#search-sidebar-closebutton {
-  border: 1px solid transparent;
-  padding: 3px 2px 4px 2px !important;
-  list-style-image: url("chrome://global/skin/icons/close.png");
-  -moz-appearance: none;
-  -moz-image-region: rect(0px, 14px, 14px, 0px);
-}
-
-#search-sidebar-closebutton:hover {
-  -moz-image-region: rect(0px, 28px, 14px, 14px);
-}
-
-#search-sidebar-closebutton:hover:active {
-  -moz-image-region: rect(0px, 42px, 14px, 28px);
-}
 
 /* ----- BACK BUTTON ----- */
 
diff -r 17e9560465b0 toolkit/toolkit-makefiles.sh
--- a/toolkit/toolkit-makefiles.sh	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/toolkit-makefiles.sh	Thu Oct 30 05:41:46 2008 -0400
@@ -164,10 +164,6 @@
   intl/strres/public/Makefile
   intl/strres/src/Makefile
   intl/strres/tests/Makefile
-"
-
-MAKEFILES_js="
-  js/src/Makefile
 "
 
 MAKEFILES_liveconnect="
@@ -774,7 +770,6 @@
   $MAKEFILES_gfx
   $MAKEFILES_htmlparser
   $MAKEFILES_intl
-  $MAKEFILES_js
   $MAKEFILES_liveconnect
   $MAKEFILES_xpconnect
   $MAKEFILES_jsdebugger
diff -r 17e9560465b0 toolkit/toolkit-tiers.mk
--- a/toolkit/toolkit-tiers.mk	Thu Oct 23 09:51:35 2008 -0700
+++ b/toolkit/toolkit-tiers.mk	Thu Oct 30 05:41:46 2008 -0400
@@ -40,7 +40,7 @@
 endif
 
 include $(topsrcdir)/config/nspr/build.mk
-include $(topsrcdir)/js/src/build.mk
+include $(topsrcdir)/config/js/build.mk
 include $(topsrcdir)/xpcom/build.mk
 include $(topsrcdir)/netwerk/build.mk
 
diff -r 17e9560465b0 uriloader/exthandler/nsExternalHelperAppService.cpp
--- a/uriloader/exthandler/nsExternalHelperAppService.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/uriloader/exthandler/nsExternalHelperAppService.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -535,6 +535,9 @@
   { TEXT_XUL, "xul", "XML-Based User Interface Language", MAC_TYPE('TEXT'), MAC_TYPE('ttxt') },
   { TEXT_XML, "xml,xsl,xbl", "Extensible Markup Language", MAC_TYPE('TEXT'), MAC_TYPE('ttxt') },
   { TEXT_CSS, "css", "Style Sheet", MAC_TYPE('TEXT'), MAC_TYPE('ttxt') },
+  { "audio/ogg", "oga", "Ogg Audio", 0, 0 },
+  { "video/ogg", "ogv", "Ogg Video", 0, 0 },
+  { "audio/ogg", "ogg", "Ogg Audio", 0, 0 }
 };
 
 #undef MAC_TYPE
diff -r 17e9560465b0 uriloader/exthandler/win/nsMIMEInfoWin.cpp
--- a/uriloader/exthandler/win/nsMIMEInfoWin.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/uriloader/exthandler/win/nsMIMEInfoWin.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -123,11 +123,11 @@
         if (!GetDllLaunchInfo(executable, locFile, args, PR_FALSE))
           return NS_ERROR_INVALID_ARG;
 
-        PRUint32 result = (PRUint32)
+        int result = (int)
           ::ShellExecuteW(NULL, NULL, L"rundll32.exe", args.get(),
                           NULL, SW_SHOWNORMAL);
         // Returns a value greater than 32 if successful. See msdn.
-        if (result >= 32)
+        if (result > 32)
           return NS_OK;
 
         switch (result) {
diff -r 17e9560465b0 uriloader/prefetch/nsOfflineCacheUpdate.cpp
--- a/uriloader/prefetch/nsOfflineCacheUpdate.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/uriloader/prefetch/nsOfflineCacheUpdate.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -541,9 +541,7 @@
         do_CreateInstance(NS_APPLICATIONCACHENAMESPACE_CONTRACTID, &rv);
     NS_ENSURE_SUCCESS(rv, rv);
 
-    rv = ns->Init(nsIApplicationCacheNamespace::NAMESPACE_FALLBACK |
-                  nsIApplicationCacheNamespace::NAMESPACE_OPPORTUNISTIC,
-                  namespaceSpec, data);
+    rv = ns->Init(namespaceType, namespaceSpec, data);
     NS_ENSURE_SUCCESS(rv, rv);
 
     rv = mNamespaces->AppendElement(ns, PR_FALSE);
diff -r 17e9560465b0 view/src/nsViewManager.cpp
--- a/view/src/nsViewManager.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/view/src/nsViewManager.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -1284,7 +1284,9 @@
           if ((aEvent->message == NS_MOUSE_MOVE &&
                static_cast<nsMouseEvent*>(aEvent)->reason ==
                  nsMouseEvent::eReal) ||
-              aEvent->message == NS_MOUSE_ENTER) {
+              aEvent->message == NS_MOUSE_ENTER ||
+              aEvent->message == NS_MOUSE_BUTTON_DOWN ||
+              aEvent->message == NS_MOUSE_BUTTON_UP) {
             // aEvent->point is relative to the widget, i.e. the view top-left,
             // so we need to add the offset to the view origin
             nsPoint rootOffset = baseView->GetDimensions().TopLeft();
diff -r 17e9560465b0 widget/public/nsEvent.h
--- a/widget/public/nsEvent.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/widget/public/nsEvent.h	Thu Oct 30 05:41:46 2008 -0400
@@ -76,6 +76,7 @@
 class nsReconversionEvent;
 class nsTooltipEvent;
 class nsMenuEvent;
+class nsSimpleGestureEvent;
 
 struct nsTextEventReply;
 
diff -r 17e9560465b0 widget/public/nsGUIEvent.h
--- a/widget/public/nsGUIEvent.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/widget/public/nsGUIEvent.h	Thu Oct 30 05:41:46 2008 -0400
@@ -22,6 +22,7 @@
  * Contributor(s):
  *   Makoto Kato  <m_kato@ga2.so-net.ne.jp>
  *   Dean Tessman <dean_tessman@hotmail.com>
+ *   Thomas K. Dyas <tdyas@zecador.org> (simple gestures support)
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -103,6 +104,7 @@
 #endif // MOZ_MEDIA
 #define NS_DRAG_EVENT                     35
 #define NS_NOTIFYPAINT_EVENT              36
+#define NS_SIMPLE_GESTURE_EVENT           37
 
 // These flags are sort of a mess. They're sort of shared between event
 // listener flags and event flags, but only some of them. You've been
@@ -382,6 +384,16 @@
 #define NS_NOTIFYPAINT_START    3400
 #define NS_AFTERPAINT           (NS_NOTIFYPAINT_START)
 
+// Simple gesture events
+#define NS_SIMPLE_GESTURE_EVENT_START    3500
+#define NS_SIMPLE_GESTURE_SWIPE          (NS_SIMPLE_GESTURE_EVENT_START)
+#define NS_SIMPLE_GESTURE_MAGNIFY_START  (NS_SIMPLE_GESTURE_EVENT_START+1)
+#define NS_SIMPLE_GESTURE_MAGNIFY_UPDATE (NS_SIMPLE_GESTURE_EVENT_START+2)
+#define NS_SIMPLE_GESTURE_MAGNIFY        (NS_SIMPLE_GESTURE_EVENT_START+3)
+#define NS_SIMPLE_GESTURE_ROTATE_START   (NS_SIMPLE_GESTURE_EVENT_START+4)
+#define NS_SIMPLE_GESTURE_ROTATE_UPDATE  (NS_SIMPLE_GESTURE_EVENT_START+5)
+#define NS_SIMPLE_GESTURE_ROTATE         (NS_SIMPLE_GESTURE_EVENT_START+6)
+
 /**
  * Return status for event processors, nsEventStatus, is defined in
  * nsEvent.h.
@@ -483,9 +495,10 @@
   }
 
   /// Originator of the event
-  nsCOMPtr<nsIWidget> widget;           
+  nsCOMPtr<nsIWidget> widget;
+
   /// Internal platform specific message.
-  void* nativeMsg;        
+  void* nativeMsg;
 };
 
 /**
@@ -686,8 +699,8 @@
   nsMouseEvent(PRBool isTrusted, PRUint32 msg, nsIWidget *w,
                PRUint8 structType, reasonType aReason)
     : nsMouseEvent_base(isTrusted, msg, w, structType),
-      acceptActivation(PR_FALSE), reason(aReason), context(eNormal),
-      exit(eChild), clickCount(0)
+      acceptActivation(PR_FALSE), ignoreScrollFrame(PR_FALSE),
+      reason(aReason), context(eNormal), exit(eChild), clickCount(0)
   {
     if (msg == NS_MOUSE_MOVE) {
       flags |= NS_EVENT_FLAG_CANT_CANCEL;
@@ -699,8 +712,8 @@
   nsMouseEvent(PRBool isTrusted, PRUint32 msg, nsIWidget *w,
                reasonType aReason, contextType aContext = eNormal)
     : nsMouseEvent_base(isTrusted, msg, w, NS_MOUSE_EVENT),
-      acceptActivation(PR_FALSE), reason(aReason), context(aContext),
-      exit(eChild), clickCount(0)
+      acceptActivation(PR_FALSE), ignoreScrollFrame(PR_FALSE),
+      reason(aReason), context(aContext), exit(eChild), clickCount(0)
   {
     if (msg == NS_MOUSE_MOVE) {
       flags |= NS_EVENT_FLAG_CANT_CANCEL;
@@ -720,6 +733,10 @@
   /// Special return code for MOUSE_ACTIVATE to signal
   /// if the target accepts activation (1), or denies it (0)
   PRPackedBool acceptActivation;
+  // Whether the event should ignore scroll frame bounds
+  // during dispatch.
+  PRPackedBool ignoreScrollFrame;
+
   reasonType   reason : 4;
   contextType  context : 4;
   exitType     exit;
@@ -1121,6 +1138,23 @@
 };
 
 /**
+ * Simple gesture event
+ */
+class nsSimpleGestureEvent : public nsInputEvent
+{
+public:
+  nsSimpleGestureEvent(PRBool isTrusted, PRUint32 msg, nsIWidget* w,
+                         PRUint32 directionArg, PRFloat64 deltaArg)
+    : nsInputEvent(isTrusted, msg, w, NS_SIMPLE_GESTURE_EVENT),
+      direction(directionArg), delta(deltaArg)
+  {
+  }
+
+  PRUint32 direction;   // See nsIDOMSimpleGestureEvent for values
+  PRFloat64 delta;      // Delta for magnify and rotate events
+};
+
+/**
  * Event status for D&D Event
  */
 enum nsDragDropEventStatus {  
diff -r 17e9560465b0 widget/public/nsIWidget.h
--- a/widget/public/nsIWidget.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/widget/public/nsIWidget.h	Thu Oct 30 05:41:46 2008 -0400
@@ -93,10 +93,10 @@
 #define NS_NATIVE_PLUGIN_PORT_CG    101
 #endif
 
-// 8c91457a-ef86-4da1-b4f9-36022dcc6c7e
+// 7E01D11D-DAFC-4A5E-8C0A-7442A2E17252
 #define NS_IWIDGET_IID \
-{ 0x8c91457a, 0xef86, 0x4da1, \
-  { 0xb4, 0xf9, 0x36, 0x02, 0x2d, 0xcc, 0x6c, 0x7e } }
+{ 0x7E01D11D, 0xDAFC, 0x4A5E, \
+  { 0x8C, 0x0A, 0x74, 0x42, 0xA2, 0xE1, 0x72, 0x52 } }
 
 // Hide the native window systems real window type so as to avoid
 // including native window system types and APIs. This is necessary
@@ -1134,7 +1134,7 @@
      * Activates a native menu item at the position specified by the index
      * string. The index string is a string of positive integers separated
      * by the "|" (pipe) character. The last integer in the string represents
-     * the item index in a submenu located using the integers prior to it.
+     * the item index in a submenu located using the integers preceeding it.
      *
      * Example: 1|0|4
      * In this string, the first integer represents the top-level submenu
@@ -1143,6 +1143,24 @@
      * submenu, and we want to activate the 5th item within that submenu.
      */
     virtual nsresult ActivateNativeMenuItemAt(const nsAString& indexString) = 0;
+
+    /**
+     * This is used for native menu system testing.
+     *
+     * Updates a native menu at the position specified by the index string.
+     * The index string is a string of positive integers separated by the "|" 
+     * (pipe) character.
+     *
+     * Example: 1|0|4
+     * In this string, the first integer represents the top-level submenu
+     * in the native menu bar. Since the integer is 1, it is the second submeu
+     * in the native menu bar. Within that, the first item (index 0) is a
+     * submenu, and we want to update submenu at index 4 within that submenu.
+     *
+     * If this is called with an empty string it forces a full reload of the
+     * menu system.
+     */
+    virtual nsresult ForceUpdateNativeMenuAt(const nsAString& indexString) = 0;
 
     /*
      * Force Input Method Editor to commit the uncommited input
@@ -1222,14 +1240,6 @@
      */
     NS_IMETHOD GetToggledKeyState(PRUint32 aKeyCode, PRBool* aLEDState) = 0;
 
-    /**
-     * This is used for native menu system testing. Calling this forces a full
-     * reload of the menu system, reloading all native menus and their items.
-     * This is important for testing because changes to the DOM can affect the
-     * native menu system lazily.
-     */
-    virtual nsresult ForceNativeMenuReload() = 0;
-
 protected:
     // keep the list of children.  We also keep track of our siblings.
     // The ownership model is as follows: parent holds a strong ref to
diff -r 17e9560465b0 widget/src/cocoa/nsChildView.h
--- a/widget/src/cocoa/nsChildView.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/widget/src/cocoa/nsChildView.h	Thu Oct 30 05:41:46 2008 -0400
@@ -20,6 +20,7 @@
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
+ *   Thomas K. Dyas <tdyas@zecador.org> (simple gestures support)
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -182,6 +183,29 @@
   // Cocoa TSM documents (those created and managed by the NSTSMInputContext
   // class) -- for some reason TSMProcessRawKeyEvent() doesn't work with them.
   TSMDocumentID mPluginTSMDoc;
+
+  // Simple gestures support
+  //
+  // mGestureState is used to detect when Cocoa has called both
+  // magnifyWithEvent and rotateWithEvent within the same
+  // beginGestureWithEvent and endGestureWithEvent sequence. We
+  // discard the spurious gesture event so as not to confuse Gecko.
+  //
+  // mCumulativeMagnification keeps track of the total amount of
+  // magnification peformed during a magnify gesture so that we can
+  // send that value with the final MozMagnifyGesture event.
+  //
+  // mCumulativeRotation keeps track of the total amount of rotation
+  // performed during a rotate gesture so we can send that value with
+  // the final MozRotateGesture event.
+  enum {
+    eGestureState_None,
+    eGestureState_StartGesture,
+    eGestureState_MagnifyGesture,
+    eGestureState_RotateGesture
+  } mGestureState;
+  float mCumulativeMagnification;
+  float mCumulativeRotation;
 }
 
 // these are sent to the first responder when the window key status changes
@@ -196,6 +220,22 @@
 - (void)sendFocusEvent:(PRUint32)eventType;
 
 - (void) processPluginKeyEvent:(EventRef)aKeyEvent;
+
+// Simple gestures support
+//
+// XXX - The swipeWithEvent, beginGestureWithEvent, magnifyWithEvent,
+// rotateWithEvent, and endGestureWithEvent methods are part of a
+// PRIVATE interface exported by nsResponder and reverse-engineering
+// was necessary to obtain the methods' prototypes. Thus, Apple may
+// change the interface in the future without notice.
+//
+// The prototypes were obtained from the following link:
+// http://cocoadex.com/2008/02/nsevent-modifications-swipe-ro.html
+- (void)swipeWithEvent:(NSEvent *)anEvent;
+- (void)beginGestureWithEvent:(NSEvent *)anEvent;
+- (void)magnifyWithEvent:(NSEvent *)anEvent;
+- (void)rotateWithEvent:(NSEvent *)anEvent;
+- (void)endGestureWithEvent:(NSEvent *)anEvent;
 @end
 
 
@@ -292,6 +332,7 @@
   NS_IMETHOD              Show(PRBool aState);
   NS_IMETHOD              IsVisible(PRBool& outState);
 
+  NS_IMETHOD              SetParent(nsIWidget* aNewParent);
   virtual nsIWidget*      GetParent(void);
 
   NS_IMETHOD              ModalEventFilter(PRBool aRealEvent, void *aEvent,
@@ -349,7 +390,7 @@
   NS_IMETHOD        GetAttention(PRInt32 aCycleCount);
 
   NS_IMETHOD        ActivateNativeMenuItemAt(const nsAString& indexString);
-  NS_IMETHOD        ForceNativeMenuReload();
+  NS_IMETHOD        ForceUpdateNativeMenuAt(const nsAString& indexString);
 
   NS_IMETHOD        ResetInputState();
   NS_IMETHOD        SetIMEOpenState(PRBool aState);
diff -r 17e9560465b0 widget/src/cocoa/nsChildView.mm
--- a/widget/src/cocoa/nsChildView.mm	Thu Oct 23 09:51:35 2008 -0700
+++ b/widget/src/cocoa/nsChildView.mm	Thu Oct 30 05:41:46 2008 -0400
@@ -25,6 +25,7 @@
  *   Hkan Waara <hwaara@gmail.com>
  *   Stuart Morgan <stuart.morgan@alumni.case.edu>
  *   Mats Palmgren <mats.palmgren@bredband.net>
+ *   Thomas K. Dyas <tdyas@zecador.org> (simple gestures support)
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or 
@@ -70,7 +71,10 @@
 #include "nsCursorManager.h"
 #include "nsWindowMap.h"
 #include "nsCocoaUtils.h"
+#include "nsMenuUtilsX.h"
 #include "nsMenuBarX.h"
+
+#include "nsIDOMSimpleGestureEvent.h"
 
 #include "gfxContext.h"
 #include "gfxQuartzSurface.h"
@@ -971,6 +975,38 @@
   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 }
 
+// Reset the parent of this widget
+NS_IMETHODIMP
+nsChildView::SetParent(nsIWidget* aNewParent)
+{
+  NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
+
+  NS_ENSURE_ARG(aNewParent);
+  NSView<mozView>* newParentView =
+   (NSView*)aNewParent->GetNativeData(NS_NATIVE_WIDGET); 
+  NS_ENSURE_TRUE(newParentView, NS_ERROR_FAILURE);
+
+  if (mOnDestroyCalled)
+    return NS_OK;
+
+  // make sure we stay alive
+  nsCOMPtr<nsIWidget> kungFuDeathGrip(this);
+  
+  // remove us from our existing parent
+  if (mParentWidget)
+    mParentWidget->RemoveChild(this);
+  // we hold a ref to mView, so this is safe
+  [mView removeFromSuperview];
+  
+  // add us to the new parent
+  aNewParent->AddChild(this);
+  mParentWidget = aNewParent;
+  mParentView   = newParentView;
+  [mParentView addSubview:mView];
+  return NS_OK;
+  
+  NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
+}
 
 nsIWidget*
 nsChildView::GetParent(void)
@@ -1514,20 +1550,18 @@
   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 }
 
-// Used for testing native menu system structure and event handling.
-NS_IMETHODIMP nsChildView::ActivateNativeMenuItemAt(const nsAString& indexString)
-{
-  NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
-
-  NSString* title = [NSString stringWithCharacters:indexString.BeginReading() length:indexString.Length()];
-  NSArray* indexes = [title componentsSeparatedByString:@"|"];
+
+// First argument has to be an NSMenu representing the application's top-level
+// menu bar. The returned item is *not* retained.
+static NSMenuItem* NativeMenuItemWithLocation(NSMenu* menubar, NSString* locationString)
+{
+  NSArray* indexes = [locationString componentsSeparatedByString:@"|"];
   unsigned int indexCount = [indexes count];
   if (indexCount == 0)
-    return NS_OK;
-  
+    return nil;
+
   NSMenu* currentSubmenu = [NSApp mainMenu];
-  for (unsigned int i = 0; i < (indexCount - 1); i++) {
-    NSMenu* newSubmenu = nil;
+  for (unsigned int i = 0; i < indexCount; i++) {
     int targetIndex;
     // We remove the application menu from consideration for the top-level menu
     if (i == 0)
@@ -1537,49 +1571,66 @@
     int itemCount = [currentSubmenu numberOfItems];
     if (targetIndex < itemCount) {
       NSMenuItem* menuItem = [currentSubmenu itemAtIndex:targetIndex];
+      // if this is the last index just return the menu item
+      if (i == (indexCount - 1))
+        return menuItem;
+      // if this is not the last index find the submenu and keep going
       if ([menuItem hasSubmenu])
-        newSubmenu = [menuItem submenu];
-    }
-    
-    if (newSubmenu)
-      currentSubmenu = newSubmenu;
-    else
-      return NS_ERROR_FAILURE;
-  }
-
-  int itemCount = [currentSubmenu numberOfItems];
-  int targetIndex = [[indexes objectAtIndex:(indexCount - 1)] intValue];
+        currentSubmenu = [menuItem submenu];
+      else
+        return nil;
+    }
+  }
+
+  return nil;
+}
+
+
+// Used for testing native menu system structure and event handling.
+NS_IMETHODIMP nsChildView::ActivateNativeMenuItemAt(const nsAString& indexString)
+{
+  NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
+
+  NSString* locationString = [NSString stringWithCharacters:indexString.BeginReading() length:indexString.Length()];
+  NSMenuItem* item = NativeMenuItemWithLocation([NSApp mainMenu], locationString);
   // We can't perform an action on an item with a submenu, that will raise
   // an obj-c exception.
-  if (targetIndex < itemCount && ![[currentSubmenu itemAtIndex:targetIndex] hasSubmenu]) {
+  if (item && ![item hasSubmenu]) {
+    NSMenu* parent = [item menu];
+    if (parent) {
       // NSLog(@"Performing action for native menu item titled: %@\n",
       //       [[currentSubmenu itemAtIndex:targetIndex] title]);
-      [currentSubmenu performActionForItemAtIndex:targetIndex];      
-  }
-  else {
-    return NS_ERROR_FAILURE;
-  }
-
-  return NS_OK;
-
-  NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
-}
-
-
-NS_IMETHODIMP nsChildView::ForceNativeMenuReload()
-{
+      [parent performActionForItemAtIndex:[parent indexOfItem:item]];
+      return NS_OK;
+    }
+  }
+  return NS_ERROR_FAILURE;
+
+  NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
+}
+
+
+// Used for testing native menu system structure and event handling.
+NS_IMETHODIMP nsChildView::ForceUpdateNativeMenuAt(const nsAString& indexString)
+{
+  NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
+
   id windowDelegate = [[mView nativeWindow] delegate];
   if (windowDelegate && [windowDelegate isKindOfClass:[WindowDelegate class]]) {
     nsCocoaWindow *widget = [(WindowDelegate *)windowDelegate geckoWidget];
     if (widget) {
       nsMenuBarX* mb = widget->GetMenuBar();
       if (mb) {
-        mb->ForceNativeMenuReload();
-      }
-    }
-  }
-
-  return NS_OK;
+        if (indexString.IsEmpty())
+          mb->ForceNativeMenuReload();
+        else
+          mb->ForceUpdateNativeMenuAt(indexString);
+      }
+    }
+  }
+  return NS_OK;
+
+  NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 }
 
 
@@ -2358,6 +2409,10 @@
     mDragService = nsnull;
 
     mPluginTSMDoc = nil;
+
+    mGestureState = eGestureState_None;
+    mCumulativeMagnification = 0.0;
+    mCumulativeRotation = 0.0;
   }
   
   // register for things we'll take from other applications
@@ -3235,6 +3290,214 @@
 }
 
 
+/*
+ * XXX - The swipeWithEvent, beginGestureWithEvent, magnifyWithEvent,
+ * rotateWithEvent, and endGestureWithEvent methods are part of a
+ * PRIVATE interface exported by nsResponder and reverse-engineering
+ * was necessary to obtain the methods' prototypes. Thus, Apple may
+ * change the interface in the future without notice.
+ *
+ * The prototypes were obtained from the following link:
+ * http://cocoadex.com/2008/02/nsevent-modifications-swipe-ro.html
+ */
+
+- (void)swipeWithEvent:(NSEvent *)anEvent
+{
+  NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
+
+  if (!anEvent || !mGeckoChild)
+    return;
+
+  nsAutoRetainCocoaObject kungFuDeathGrip(self);
+
+  float deltaX = [anEvent deltaX];  // left=1.0, right=-1.0
+  float deltaY = [anEvent deltaY];  // up=1.0, down=-1.0
+
+  // Setup the "swipe" event.
+  nsSimpleGestureEvent geckoEvent(PR_TRUE, NS_SIMPLE_GESTURE_SWIPE, mGeckoChild, 0, 0.0);
+  [self convertGenericCocoaEvent:anEvent toGeckoEvent:&geckoEvent];
+
+  // Record the left/right direction.
+  if (deltaX > 0.0)
+    geckoEvent.direction |= nsIDOMSimpleGestureEvent::DIRECTION_LEFT;
+  else if (deltaX < 0.0)
+    geckoEvent.direction |= nsIDOMSimpleGestureEvent::DIRECTION_RIGHT;
+
+  // Record the up/down direction.
+  if (deltaY > 0.0)
+    geckoEvent.direction |= nsIDOMSimpleGestureEvent::DIRECTION_UP;
+  else if (deltaY < 0.0)
+    geckoEvent.direction |= nsIDOMSimpleGestureEvent::DIRECTION_DOWN;
+
+  // Send the event.
+  mGeckoChild->DispatchWindowEvent(geckoEvent);
+
+  NS_OBJC_END_TRY_ABORT_BLOCK;
+}
+
+
+- (void)beginGestureWithEvent:(NSEvent *)anEvent
+{
+  NS_ASSERTION(mGestureState == eGestureState_None, "mGestureState should be eGestureState_None");
+
+  if (!anEvent)
+    return;
+
+  mGestureState = eGestureState_StartGesture;
+  mCumulativeMagnification = 0;
+  mCumulativeRotation = 0.0;
+}
+
+
+- (void)magnifyWithEvent:(NSEvent *)anEvent
+{
+  NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
+
+  if (!anEvent || !mGeckoChild)
+    return;
+
+  nsAutoRetainCocoaObject kungFuDeathGrip(self);
+
+  float deltaZ = [anEvent deltaZ];
+
+  PRUint32 msg;
+  switch (mGestureState) {
+  case eGestureState_StartGesture:
+    msg = NS_SIMPLE_GESTURE_MAGNIFY_START;
+    mGestureState = eGestureState_MagnifyGesture;
+    break;
+
+  case eGestureState_MagnifyGesture:
+    msg = NS_SIMPLE_GESTURE_MAGNIFY_UPDATE;
+    break;
+
+  case eGestureState_None:
+  case eGestureState_RotateGesture:
+  default:
+    return;
+  }
+
+  // Setup the event.
+  nsSimpleGestureEvent geckoEvent(PR_TRUE, msg, mGeckoChild, 0, deltaZ);
+  [self convertGenericCocoaEvent:anEvent toGeckoEvent:&geckoEvent];
+
+  // Send the event.
+  mGeckoChild->DispatchWindowEvent(geckoEvent);
+
+  // Keep track of the cumulative magnification for the final "magnify" event.
+  mCumulativeMagnification += deltaZ;
+  
+  NS_OBJC_END_TRY_ABORT_BLOCK;
+}
+
+
+- (void)rotateWithEvent:(NSEvent *)anEvent
+{
+  NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
+
+  if (!anEvent || !mGeckoChild)
+    return;
+
+  nsAutoRetainCocoaObject kungFuDeathGrip(self);
+
+  float rotation = [anEvent rotation];
+
+  PRUint32 msg;
+  switch (mGestureState) {
+  case eGestureState_StartGesture:
+    msg = NS_SIMPLE_GESTURE_ROTATE_START;
+    mGestureState = eGestureState_RotateGesture;
+    break;
+
+  case eGestureState_RotateGesture:
+    msg = NS_SIMPLE_GESTURE_ROTATE_UPDATE;
+    break;
+
+  case eGestureState_None:
+  case eGestureState_MagnifyGesture:
+  default:
+    return;
+  }
+
+  // Setup the event.
+  nsSimpleGestureEvent geckoEvent(PR_TRUE, msg, mGeckoChild, 0, 0.0);
+  [self convertGenericCocoaEvent:anEvent toGeckoEvent:&geckoEvent];
+  geckoEvent.delta = -rotation;
+  if (rotation > 0.0) {
+    geckoEvent.direction = nsIDOMSimpleGestureEvent::DIRECTION_LEFT;
+  } else {
+    geckoEvent.direction = nsIDOMSimpleGestureEvent::DIRECTION_RIGHT;
+  }
+
+  // Send the event.
+  mGeckoChild->DispatchWindowEvent(geckoEvent);
+
+  // Keep track of the cumulative rotation for the final "rotate" event.
+  mCumulativeRotation += rotation;
+
+  NS_OBJC_END_TRY_ABORT_BLOCK;
+}
+
+
+- (void)endGestureWithEvent:(NSEvent *)anEvent
+{
+  NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
+
+  if (!anEvent || !mGeckoChild) {
+    // Clear the gestures state if we cannot send an event.
+    mGestureState = eGestureState_None;
+    mCumulativeMagnification = 0.0;
+    mCumulativeRotation = 0.0;
+    return;
+  }
+
+  nsAutoRetainCocoaObject kungFuDeathGrip(self);
+
+  switch (mGestureState) {
+  case eGestureState_MagnifyGesture:
+    {
+      // Setup the "magnify" event.
+      nsSimpleGestureEvent geckoEvent(PR_TRUE, NS_SIMPLE_GESTURE_MAGNIFY,
+                                      mGeckoChild, 0, mCumulativeMagnification);
+      [self convertGenericCocoaEvent:anEvent toGeckoEvent:&geckoEvent];
+
+      // Send the event.
+      mGeckoChild->DispatchWindowEvent(geckoEvent);
+    }
+    break;
+
+  case eGestureState_RotateGesture:
+    {
+      // Setup the "rotate" event.
+      nsSimpleGestureEvent geckoEvent(PR_TRUE, NS_SIMPLE_GESTURE_ROTATE, mGeckoChild, 0, 0.0);
+      [self convertGenericCocoaEvent:anEvent toGeckoEvent:&geckoEvent];
+      geckoEvent.delta = -mCumulativeRotation;
+      if (mCumulativeRotation > 0.0) {
+        geckoEvent.direction = nsIDOMSimpleGestureEvent::DIRECTION_LEFT;
+      } else {
+        geckoEvent.direction = nsIDOMSimpleGestureEvent::DIRECTION_RIGHT;
+      }
+
+      // Send the event.
+      mGeckoChild->DispatchWindowEvent(geckoEvent);
+    }
+    break;
+
+  case eGestureState_None:
+  case eGestureState_StartGesture:
+  default:
+    break;
+  }
+
+  // Clear the gestures state.
+  mGestureState = eGestureState_None;
+  mCumulativeMagnification = 0.0;
+  mCumulativeRotation = 0.0;
+
+  NS_OBJC_END_TRY_ABORT_BLOCK;
+}
+
+
 - (void)mouseDown:(NSEvent*)theEvent
 {
   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
@@ -3767,12 +4030,12 @@
     // dispatch scroll wheel carbon event for plugins
     {
       EventRef theEvent;
-      OSStatus err = ::MacCreateEvent(NULL,
-                                      kEventClassMouse,
-                                      kEventMouseWheelMoved,
-                                      TicksToEventTime(TickCount()),
-                                      kEventAttributeUserEvent,
-                                      &theEvent);
+      OSStatus err = ::CreateEvent(NULL,
+                                   kEventClassMouse,
+                                   kEventMouseWheelMoved,
+                                   TicksToEventTime(TickCount()),
+                                   kEventAttributeUserEvent,
+                                   &theEvent);
       if (err == noErr) {
         EventMouseWheelAxis axis;
         if (inAxis & nsMouseScrollEvent::kIsVertical)
diff -r 17e9560465b0 widget/src/cocoa/nsDragService.mm
--- a/widget/src/cocoa/nsDragService.mm	Thu Oct 23 09:51:35 2008 -0700
+++ b/widget/src/cocoa/nsDragService.mm	Thu Oct 30 05:41:46 2008 -0400
@@ -312,6 +312,9 @@
                       source:mNativeDragView
                    slideBack:YES];
 
+  if (mDoingDrag)
+    nsBaseDragService::EndDragSession(PR_FALSE);
+  
   return NS_OK;
 
   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
diff -r 17e9560465b0 widget/src/cocoa/nsMenuBarX.h
--- a/widget/src/cocoa/nsMenuBarX.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/widget/src/cocoa/nsMenuBarX.h	Thu Oct 30 05:41:46 2008 -0400
@@ -46,6 +46,8 @@
 #include "nsHashtable.h"
 #include "nsINativeMenuService.h"
 #include "nsAutoPtr.h"
+#include "nsString.h"
+
 
 class nsMenuX;
 class nsMenuItemX;
@@ -121,6 +123,7 @@
   nsMenuX*          GetMenuAt(PRUint32 aIndex);
   nsMenuItemX*      GetMenuItemForCommandID(PRUint32 inCommandID);
   nsresult          Paint();
+  void              ForceUpdateNativeMenuAt(const nsAString& indexString);
   void              ForceNativeMenuReload(); // used for testing
 
 protected:
diff -r 17e9560465b0 widget/src/cocoa/nsMenuBarX.mm
--- a/widget/src/cocoa/nsMenuBarX.mm	Thu Oct 23 09:51:35 2008 -0700
+++ b/widget/src/cocoa/nsMenuBarX.mm	Thu Oct 30 05:41:46 2008 -0400
@@ -259,6 +259,67 @@
   mMenuArray.RemoveElementAt(aIndex);
 
   NS_OBJC_END_TRY_ABORT_BLOCK;
+}
+
+
+void nsMenuBarX::ForceUpdateNativeMenuAt(const nsAString& indexString)
+{
+  NSString* locationString = [NSString stringWithCharacters:indexString.BeginReading() length:indexString.Length()];
+  NSArray* indexes = [locationString componentsSeparatedByString:@"|"];
+  unsigned int indexCount = [indexes count];
+  if (indexCount == 0)
+    return;
+
+  nsMenuX* currentMenu = NULL;
+  int targetIndex = [[indexes objectAtIndex:0] intValue];
+  int visible = 0;
+  PRUint32 length = mMenuArray.Length();
+  // first find a menu in the menu bar
+  for (unsigned int i = 0; i < length; i++) {
+    nsMenuX* menu = mMenuArray[i];
+    if (!nsMenuUtilsX::NodeIsHiddenOrCollapsed(menu->Content())) {
+      visible++;
+      if (visible == (targetIndex + 1)) {
+        currentMenu = menu;
+        break;
+      }
+    }
+  }
+
+  if (!currentMenu)
+    return;
+
+  // fake open/close to cause lazy update to happen so submenus populate
+  nsMenuEvent menuEvent(PR_TRUE, NS_MENU_SELECTED, nsnull);
+  menuEvent.time = PR_IntervalNow();
+  menuEvent.mCommand = (PRUint32)_NSGetCarbonMenu(static_cast<NSMenu*>(currentMenu->NativeData()));
+  currentMenu->MenuOpened(menuEvent);
+  currentMenu->MenuClosed(menuEvent);
+
+  // now find the correct submenu
+  for (unsigned int i = 1; currentMenu && i < indexCount; i++) {
+    targetIndex = [[indexes objectAtIndex:i] intValue];
+    visible = 0;
+    length = currentMenu->GetItemCount();
+    for (unsigned int j = 0; j < length; j++) {
+      nsMenuObjectX* targetMenu = currentMenu->GetItemAt(j);
+      if (!targetMenu)
+        return;
+      if (!nsMenuUtilsX::NodeIsHiddenOrCollapsed(targetMenu->Content())) {
+        visible++;
+        if (targetMenu->MenuObjectType() == eSubmenuObjectType && visible == (targetIndex + 1)) {
+          currentMenu = static_cast<nsMenuX*>(targetMenu);
+          // fake open/close to cause lazy update to happen
+          nsMenuEvent menuEvent(PR_TRUE, NS_MENU_SELECTED, nsnull);
+          menuEvent.time = PR_IntervalNow();
+          menuEvent.mCommand = (PRUint32)_NSGetCarbonMenu(static_cast<NSMenu*>(currentMenu->NativeData()));
+          currentMenu->MenuOpened(menuEvent);
+          currentMenu->MenuClosed(menuEvent);
+          break;
+        }
+      }
+    }
+  }
 }
 
 
diff -r 17e9560465b0 widget/src/cocoa/nsMenuUtilsX.h
--- a/widget/src/cocoa/nsMenuUtilsX.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/widget/src/cocoa/nsMenuUtilsX.h	Thu Oct 30 05:41:46 2008 -0400
@@ -44,10 +44,13 @@
 #include "nsMenuBaseX.h"
 
 #import <Cocoa/Cocoa.h>
+#import <Carbon/Carbon.h>
 
 class nsIContent;
 class nsString;
 class nsMenuBarX;
+
+extern "C" MenuRef _NSGetCarbonMenu(NSMenu* aMenu);
 
 // Namespace containing utility functions used in our native menu implementation.
 namespace nsMenuUtilsX
diff -r 17e9560465b0 widget/src/cocoa/nsMenuX.mm
--- a/widget/src/cocoa/nsMenuX.mm	Thu Oct 23 09:51:35 2008 -0700
+++ b/widget/src/cocoa/nsMenuX.mm	Thu Oct 30 05:41:46 2008 -0400
@@ -73,8 +73,6 @@
 // externs defined in nsChildView.mm
 extern nsIRollupListener * gRollupListener;
 extern nsIWidget         * gRollupWidget;
-
-extern "C" MenuRef _NSGetCarbonMenu(NSMenu* aMenu);
 
 static PRBool gConstructingMenu = PR_FALSE;
 static PRBool gMenuMethodsSwizzled = PR_FALSE;
diff -r 17e9560465b0 widget/src/cocoa/nsNativeThemeCocoa.h
--- a/widget/src/cocoa/nsNativeThemeCocoa.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/widget/src/cocoa/nsNativeThemeCocoa.h	Thu Oct 30 05:41:46 2008 -0400
@@ -100,7 +100,7 @@
                  PRInt32 inState);
   void DrawProgress(CGContextRef context, const HIRect& inBoxRect,
                     PRBool inIsIndeterminate, PRBool inIsHorizontal,
-                    PRInt32 inValue, nsIFrame* aFrame);
+                    PRInt32 inValue, PRInt32 inMaxValue, nsIFrame* aFrame);
   void DrawTab(CGContextRef context, const HIRect& inBoxRect,
                PRBool inIsDisabled, PRBool inIsFrontmost, 
                PRBool inIsHorizontal, PRBool inTabBottom,
diff -r 17e9560465b0 widget/src/cocoa/nsNativeThemeCocoa.mm
--- a/widget/src/cocoa/nsNativeThemeCocoa.mm	Thu Oct 23 09:51:35 2008 -0700
+++ b/widget/src/cocoa/nsNativeThemeCocoa.mm	Thu Oct 30 05:41:46 2008 -0400
@@ -850,7 +850,8 @@
 void
 nsNativeThemeCocoa::DrawProgress(CGContextRef cgContext, const HIRect& inBoxRect,
                                  PRBool inIsIndeterminate, PRBool inIsHorizontal,
-                                 PRInt32 inValue, nsIFrame* aFrame)
+                                 PRInt32 inValue, PRInt32 inMaxValue,
+                                 nsIFrame* aFrame)
 {
   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 
@@ -863,7 +864,7 @@
   tdi.kind = inIsIndeterminate ? kThemeMediumIndeterminateBar: kThemeMediumProgressBar;
   tdi.bounds = inBoxRect;
   tdi.min = 0;
-  tdi.max = 100;
+  tdi.max = inMaxValue;
   tdi.value = inValue;
   tdi.attributes = inIsHorizontal ? kThemeTrackHorizontal : 0;
   tdi.enableState = FrameIsInActiveWindow(aFrame) ? kThemeTrackActive : kThemeTrackInactive;
@@ -1431,12 +1432,14 @@
       
     case NS_THEME_PROGRESSBAR:
       DrawProgress(cgContext, macRect, IsIndeterminateProgress(aFrame),
-                   PR_TRUE, GetProgressValue(aFrame), aFrame);
+                   PR_TRUE, GetProgressValue(aFrame),
+                   GetProgressMaxValue(aFrame), aFrame);
       break;
 
     case NS_THEME_PROGRESSBAR_VERTICAL:
       DrawProgress(cgContext, macRect, IsIndeterminateProgress(aFrame),
-                   PR_FALSE, GetProgressValue(aFrame), aFrame);
+                   PR_FALSE, GetProgressValue(aFrame),
+                   GetProgressMaxValue(aFrame), aFrame);
       break;
 
     case NS_THEME_PROGRESSBAR_CHUNK:
diff -r 17e9560465b0 widget/src/os2/nsDragService.cpp
--- a/widget/src/os2/nsDragService.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/widget/src/os2/nsDragService.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -94,6 +94,7 @@
 int      UnicodeToCodepage( const nsAString& inString, char **outText);
 int      CodepageToUnicode( const nsACString& inString, PRUnichar **outText);
 void     RemoveCarriageReturns(char * pszText);
+MRESULT EXPENTRY nsDragWindowProc(HWND hWnd, ULONG msg, MPARAM mp1, MPARAM mp2);
 
 // --------------------------------------------------------------------------
 // Global data
diff -r 17e9560465b0 widget/src/support/nsWidgetSupport.cpp
--- a/widget/src/support/nsWidgetSupport.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/widget/src/support/nsWidgetSupport.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -39,15 +39,7 @@
 #include "nsRect.h"
 #include "nsIWidget.h"
 
-#ifdef XP_MAC
-#define WIDGET_SUPPORT_EXPORT(returnType) \
-        PR_PUBLIC_API(returnType)
-#else
-#define WIDGET_SUPPORT_EXPORT(returnType) \
-        returnType
-#endif
-
-WIDGET_SUPPORT_EXPORT(nsresult)
+nsresult
 NS_ShowWidget(nsISupports* aWidget, PRBool aShow)
 {
   nsCOMPtr<nsIWidget> widget = do_QueryInterface(aWidget);
@@ -58,7 +50,7 @@
   return NS_OK;
 }
 
-WIDGET_SUPPORT_EXPORT(nsresult)
+nsresult
 NS_MoveWidget(nsISupports* aWidget, PRUint32 aX, PRUint32 aY)
 {
   nsCOMPtr<nsIWidget> widget = do_QueryInterface(aWidget);
@@ -69,7 +61,7 @@
   return NS_OK;
 }
 
-WIDGET_SUPPORT_EXPORT(nsresult)
+nsresult
 NS_EnableWidget(nsISupports* aWidget, PRBool aEnable)
 {
   nsCOMPtr<nsIWidget> widget = do_QueryInterface(aWidget);
@@ -80,7 +72,7 @@
   return NS_OK;
 }
 
-WIDGET_SUPPORT_EXPORT(nsresult)
+nsresult
 NS_SetFocusToWidget(nsISupports* aWidget)
 {
   nsCOMPtr<nsIWidget> widget = do_QueryInterface(aWidget);
@@ -91,7 +83,7 @@
   return NS_OK;
 }
 
-WIDGET_SUPPORT_EXPORT(nsresult)
+nsresult
 NS_GetWidgetNativeData(nsISupports* aWidget, void** aNativeData)
 {
   void *result = nsnull;
diff -r 17e9560465b0 widget/src/support/nsWidgetSupport.h
--- a/widget/src/support/nsWidgetSupport.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/widget/src/support/nsWidgetSupport.h	Thu Oct 30 05:41:46 2008 -0400
@@ -51,16 +51,6 @@
 class nsIWidget;
 class nsITooltipWidget;
 
-#if (defined(XP_MAC) || defined(XP_MACOSX)) && !defined(MOZ_WIDGET_COCOA)
-// A top-level widget stores a reference to itself as a window property
-// with the following creator and tag. These constants are used by embedding
-// code in addition to widget code.
-enum {
-  kTopLevelWidgetPropertyCreator = 'MOSS',
-  kTopLevelWidgetRefPropertyTag  = 'GEKO'
-};
-#endif
-
 extern nsresult 
 NS_ShowWidget(nsISupports* aWidget, PRBool aShow);
 
diff -r 17e9560465b0 widget/src/windows/nsPrintSettingsWin.cpp
--- a/widget/src/windows/nsPrintSettingsWin.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/widget/src/windows/nsPrintSettingsWin.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -83,13 +83,13 @@
   if (mDeviceName) {
     nsMemory::Free(mDeviceName);
   }
-  mDeviceName = aDeviceName?nsCRT::strdup(aDeviceName):nsnull;
+  mDeviceName = aDeviceName?wcsdup(aDeviceName):nsnull;
   return NS_OK;
 }
 NS_IMETHODIMP nsPrintSettingsWin::GetDeviceName(PRUnichar **aDeviceName)
 {
   NS_ENSURE_ARG_POINTER(aDeviceName);
-  *aDeviceName = mDeviceName?nsCRT::strdup(mDeviceName):nsnull;
+  *aDeviceName = mDeviceName?wcsdup(mDeviceName):nsnull;
   return NS_OK;
 }
 
@@ -99,13 +99,13 @@
   if (mDriverName) {
     nsMemory::Free(mDriverName);
   }
-  mDriverName = aDriverName?nsCRT::strdup(aDriverName):nsnull;
+  mDriverName = aDriverName?wcsdup(aDriverName):nsnull;
   return NS_OK;
 }
 NS_IMETHODIMP nsPrintSettingsWin::GetDriverName(PRUnichar **aDriverName)
 {
   NS_ENSURE_ARG_POINTER(aDriverName);
-  *aDriverName = mDriverName?nsCRT::strdup(mDriverName):nsnull;
+  *aDriverName = mDriverName?wcsdup(mDriverName):nsnull;
   return NS_OK;
 }
 
@@ -176,8 +176,8 @@
     ::HeapFree(::GetProcessHeap(), 0, mDevMode);
   }
 
-  mDeviceName = rhs.mDeviceName?nsCRT::strdup(rhs.mDeviceName):nsnull;
-  mDriverName = rhs.mDriverName?nsCRT::strdup(rhs.mDriverName):nsnull;
+  mDeviceName = rhs.mDeviceName?wcsdup(rhs.mDeviceName):nsnull;
+  mDriverName = rhs.mDriverName?wcsdup(rhs.mDriverName):nsnull;
 
   if (rhs.mDevMode) {
     CopyDevMode(rhs.mDevMode, mDevMode);
diff -r 17e9560465b0 widget/src/windows/nsWindow.cpp
--- a/widget/src/windows/nsWindow.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/widget/src/windows/nsWindow.cpp	Thu Oct 30 05:41:46 2008 -0400
@@ -4800,7 +4800,7 @@
       }
       {
         // Get current input context
-        HIMC hC = ImmGetContext(mWnd);		
+        HIMC hC = ImmGetContext(mWnd);
         // Open the IME 
         ImmSetOpenStatus(hC, TRUE);
         // Set "multi-press" input mode
@@ -5450,7 +5450,7 @@
   // XXX: The class name used here must be kept in sync with
   //      the classname used in WindowClassW();
 #ifdef UNICODE
-	return classNameW;
+  return classNameW;
 #else
   if (classNameW == kWClassNameHidden) {
     return kClassNameHidden;
@@ -5878,6 +5878,7 @@
 #endif
 
       nsRefPtr<gfxContext> thebesContext = new gfxContext(targetSurface);
+      thebesContext->SetFlag(gfxContext::FLAG_DESTINED_FOR_SCREEN);
 
 #ifdef MOZ_XUL
       if (eTransparencyGlass == mTransparencyMode && nsUXThemeData::sHaveCompositor) {
@@ -6464,7 +6465,7 @@
 PRBool gPinYinIMECaretCreated = PR_FALSE;
 
 void
-nsWindow::HandleTextEvent(HIMC hIMEContext,PRBool aCheckAttr)
+nsWindow::HandleTextEvent(HIMC hIMEContext, PRBool aCheckAttr)
 {
   NS_ASSERTION(sIMECompUnicode, "sIMECompUnicode is null");
   NS_ASSERTION(sIMEIsComposing, "conflict state");
@@ -6616,7 +6617,7 @@
   }
 
   if (!sIMECompUnicode)
-    sIMECompUnicode = new nsAutoString();
+    sIMECompUnicode = new nsString();
   sIMEIsComposing = PR_TRUE;
 
   return PR_TRUE;
@@ -6676,7 +6677,7 @@
 
   long maxlen = sIMECompUnicode->Length();
   long cursor = sIMECursorPosition;
-  NS_ASSERTION(cursor <= maxlen, "wrong cursor positoin");
+  NS_ASSERTION(cursor <= maxlen, "wrong cursor position");
   if (cursor > maxlen)
     cursor = maxlen;
 
@@ -6687,7 +6688,7 @@
     *textRangeListLengthResult = 2;
     *textRangeListResult = new nsTextRange[2];
     (*textRangeListResult)[0].mStartOffset = 0;
-    (*textRangeListResult)[0].mEndOffset = sIMECompUnicode->Length();
+    (*textRangeListResult)[0].mEndOffset = maxlen;
     (*textRangeListResult)[0].mRangeType = NS_TEXTRANGE_RAWINPUT;
     (*textRangeListResult)[1].mStartOffset = cursor;
     (*textRangeListResult)[1].mEndOffset = cursor;
@@ -6794,17 +6795,19 @@
 // This function is used when aIndex is GCS_COMPSTR, GCS_COMPREADSTR,
 // GCS_RESULTSTR, and GCS_RESULTREADSTR.
 // Otherwise use ::ImmGetCompositionStringW.
-void nsWindow::GetCompositionString(HIMC aHIMC, DWORD aIndex, nsString* aStrUnicode)
-{
-  long lRtn;
-  lRtn = ::ImmGetCompositionStringW(aHIMC, aIndex, NULL, 0);
-  if (!EnsureStringLength(*aStrUnicode, (lRtn / sizeof(WCHAR)) + 1))
-    return; // out of memory
-
-  long buflen = lRtn + sizeof(WCHAR);
-  lRtn = ::ImmGetCompositionStringW(aHIMC, aIndex, (LPVOID)aStrUnicode->BeginWriting(), buflen);
-  lRtn = lRtn / sizeof(WCHAR);
-  aStrUnicode->SetLength(lRtn);
+void nsWindow::GetCompositionString(HIMC aHIMC, DWORD aIndex)
+{
+  // Retrieve the size of the required output buffer.
+  long lRtn = ::ImmGetCompositionStringW(aHIMC, aIndex, NULL, 0);
+  if (lRtn < 0 ||
+      !EnsureStringLength(*sIMECompUnicode, (lRtn / sizeof(WCHAR)) + 1))
+    return; // Error or out of memory.
+
+  // Actually retrieve the composition string information.
+  lRtn = ::ImmGetCompositionStringW(aHIMC, aIndex,
+                                    (LPVOID)sIMECompUnicode->BeginWriting(),
+                                    lRtn + sizeof(WCHAR));
+  sIMECompUnicode->SetLength(lRtn / sizeof(WCHAR));
 }
 
 //==========================================================================
@@ -6816,12 +6819,13 @@
   // for bug #60050
   // MS-IME 95/97/98/2000 may send WM_IME_COMPOSITION with non-conversion
   // mode before it send WM_IME_STARTCOMPOSITION.
-  if (!sIMECompUnicode)
-    sIMECompUnicode = new nsAutoString();
-
-  NS_ASSERTION(sIMECompUnicode, "sIMECompUnicode is null");
-  if (!sIMECompUnicode)
-    return PR_TRUE;
+  if (!sIMECompUnicode) {
+    sIMECompUnicode = new nsString();
+    if (NS_UNLIKELY(!sIMECompUnicode)) {
+      NS_ASSERTION(sIMECompUnicode, "sIMECompUnicode is null");
+      return PR_TRUE;
+    }
+  }
 
   HIMC hIMEContext = ::ImmGetContext(mWnd);
   if (hIMEContext==NULL) 
@@ -6842,7 +6846,7 @@
     if (!sIMEIsComposing) 
       HandleStartComposition(hIMEContext);
 
-    GetCompositionString(hIMEContext, GCS_RESULTSTR, sIMECompUnicode);
+    GetCompositionString(hIMEContext, GCS_RESULTSTR);
 #ifdef DEBUG_IME
     printf("GCS_RESULTSTR compStrLen = %d\n", sIMECompUnicode->Length());
 #endif
@@ -6867,7 +6871,7 @@
     //--------------------------------------------------------
     // 1. Get GCS_COMPSTR
     //--------------------------------------------------------
-    GetCompositionString(hIMEContext, GCS_COMPSTR, sIMECompUnicode);
+    GetCompositionString(hIMEContext, GCS_COMPSTR);
 
     // See https://bugzilla.mozilla.org/show_bug.cgi?id=296339
     if (sIMECompUnicode->IsEmpty() &&
@@ -6957,7 +6961,7 @@
   }
   if (!result) {
 #ifdef DEBUG_IME
-    fprintf(stderr,"Haandle 0 length TextEvent. \n");
+    fprintf(stderr, "Handle 0 length TextEvent.\n");
 #endif
     if (!sIMEIsComposing) 
       HandleStartComposition(hIMEContext);
@@ -7000,7 +7004,7 @@
     // first when we hit space in composition mode
     // we need to clear out the current composition string
     // in that case.
-    sIMECompUnicode->Truncate(0);
+    sIMECompUnicode->Truncate();
 
     HandleTextEvent(hIMEContext, PR_FALSE);
 
@@ -7423,8 +7427,9 @@
 
       // Note: hitText has been done, so no check of sIMECompCharPos
       // and composing char maximum limit is necessary.
+      PRUint32 len = sIMECompUnicode->Length();
       PRUint32 i = 0;
-      for (i = 0; i < sIMECompUnicode->Length(); i++) {
+      for (i = 0; i < len; ++i) {
         if (PT_IN_RECT(*ptPos, sIMECompCharPos[i]))
           break;
       }
diff -r 17e9560465b0 widget/src/windows/nsWindow.h
--- a/widget/src/windows/nsWindow.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/widget/src/windows/nsWindow.h	Thu Oct 30 05:41:46 2008 -0400
@@ -337,7 +337,7 @@
   BOOL                    OnIMEReconvert(LPARAM aData, LRESULT *oResult);
   BOOL                    OnIMEQueryCharPosition(LPARAM aData, LRESULT *oResult);
 
-  void                    GetCompositionString(HIMC aHIMC, DWORD aIndex, nsString* aStrUnicode);
+  void                    GetCompositionString(HIMC aHIMC, DWORD aIndex);
 
   /**
    *  ResolveIMECaretPos
@@ -380,7 +380,7 @@
   void RelayMouseEvent(UINT aMsg, WPARAM wParam, LPARAM lParam);
 
   void GetNonClientBounds(nsRect &aRect);
-  void HandleTextEvent(HIMC hIMEContext, PRBool aCheckAttr=PR_TRUE);
+  void HandleTextEvent(HIMC hIMEContext, PRBool aCheckAttr = PR_TRUE);
   BOOL HandleStartComposition(HIMC hIMEContext);
   void HandleEndComposition(void);
   void GetTextRangeList(PRUint32* textRangeListLengthResult, nsTextRangeArray* textRangeListResult);
diff -r 17e9560465b0 widget/src/xpwidgets/nsBaseWidget.h
--- a/widget/src/xpwidgets/nsBaseWidget.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/widget/src/xpwidgets/nsBaseWidget.h	Thu Oct 30 05:41:46 2008 -0400
@@ -138,7 +138,7 @@
   virtual void            FreeNativeData(void * data, PRUint32 aDataType) {}
   NS_IMETHOD              BeginResizeDrag(nsGUIEvent* aEvent, PRInt32 aHorizontal, PRInt32 aVertical);
   virtual nsresult        ActivateNativeMenuItemAt(const nsAString& indexString) { return NS_ERROR_NOT_IMPLEMENTED; }
-  virtual nsresult        ForceNativeMenuReload() { return NS_ERROR_NOT_IMPLEMENTED; }
+  virtual nsresult        ForceUpdateNativeMenuAt(const nsAString& indexString) { return NS_ERROR_NOT_IMPLEMENTED; }
   NS_IMETHOD              ResetInputState() { return NS_ERROR_NOT_IMPLEMENTED; }
   NS_IMETHOD              SetIMEOpenState(PRBool aState) { return NS_ERROR_NOT_IMPLEMENTED; }
   NS_IMETHOD              GetIMEOpenState(PRBool* aState) { return NS_ERROR_NOT_IMPLEMENTED; }
diff -r 17e9560465b0 widget/src/xpwidgets/nsNativeTheme.h
--- a/widget/src/xpwidgets/nsNativeTheme.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/widget/src/xpwidgets/nsNativeTheme.h	Thu Oct 30 05:41:46 2008 -0400
@@ -133,6 +133,10 @@
   PRInt32 GetProgressValue(nsIFrame* aFrame) {
     return CheckIntAttr(aFrame, nsWidgetAtoms::value, 0);
   }
+  
+  PRInt32 GetProgressMaxValue(nsIFrame* aFrame) {
+    return PR_MAX(CheckIntAttr(aFrame, nsWidgetAtoms::max, 100), 1);
+  }
 
   // textfield:
   PRBool IsReadOnly(nsIFrame* aFrame) {
diff -r 17e9560465b0 widget/src/xpwidgets/nsWidgetAtomList.h
--- a/widget/src/xpwidgets/nsWidgetAtomList.h	Thu Oct 23 09:51:35 2008 -0700
+++ b/widget/src/xpwidgets/nsWidgetAtomList.h	Thu Oct 30 05:41:46 2008 -0400
@@ -85,6 +85,7 @@
 WIDGET_ATOM(key, "key") // The key element / attribute
 WIDGET_ATOM(label, "label")
 WIDGET_ATOM(lasttab, "last-tab")
+WIDGET_ATOM(max, "max")
 WIDGET_ATOM(maxpos, "maxpos")
 WIDGET_ATOM(menu, "menu") // Represents an XP menu
 WIDGET_ATOM(menuitem, "menuitem") // Represents an XP menu item
diff -r 17e9560465b0 widget/tests/native_menus_window.xul
--- a/widget/tests/native_menus_window.xul	Thu Oct 23 09:51:35 2008 -0700
+++ b/widget/tests/native_menus_window.xul	Thu Oct 30 05:41:46 2008 -0400
@@ -88,14 +88,14 @@
       window.opener.wrappedJSObject.SimpleTest.finish();
     }
 
-    // We need to force a native menu reload before testing any dom changes
-    // because dom changes can affect the native menu system lazily.
-    function forceNativeMenuReload() {
+    // Force a menu to update itself. All of the menus parents will be updated
+    // as well. An empty string will force a complete menu system reload.
+    function forceUpdateNativeMenuAt(location) {
       netscape.security.PrivilegeManager.enablePrivilege('UniversalXPConnect');
       var utils = window.QueryInterface(Components.interfaces.nsIInterfaceRequestor).
                                           getInterface(Components.interfaces.nsIDOMWindowUtils);
       try {
-        utils.forceNativeMenuReload();
+        utils.forceUpdateNativeMenuAt(location);
       }
       catch (e) {
         dump(e + "\n");
@@ -144,6 +144,7 @@
     }
 
     function runBaseMenuTests() {
+      forceUpdateNativeMenuAt("0|3");
       return testItem("0|0", "cmd_FooItem0") &&
              testItem("0|1", "cmd_FooItem1") &&
              testItem("0|3|0", "cmd_BarItem0") &&
@@ -185,7 +186,6 @@
         //                      ****************
         //                      * NewMenuItem5 *
         //                      ****************
-        menubarNode.appendChild(newMenu0);
         newMenu0.appendChild(newMenuPopup0);
         newMenuPopup0.appendChild(newMenuItem0);
         newMenuPopup0.appendChild(newMenuItem1);
@@ -195,14 +195,18 @@
         newMenuPopup1.appendChild(newMenuItem3);
         newMenuPopup1.appendChild(newMenuItem4);
         newMenuPopup1.appendChild(newMenuItem5);
+        //XXX - we have to append the menu to the top-level of the menu bar
+        // only after constructing it. If we append before construction, it is
+        // invalid because it has no children and we don't validate it if we add
+        // children later.
+        menubarNode.appendChild(newMenu0);
+        forceUpdateNativeMenuAt("1|3");
+        // Run basic tests again.
+        ok(runBaseMenuTests());
 
         // Error strings.
         var sa = "Command handler(s) should have activated";
         var sna = "Command handler(s) should not have activated";
-
-        // Run basic tests again.
-        forceNativeMenuReload();
-        ok(runBaseMenuTests());
 
         // Test middle items.
         ok(testItem("1|1", "cmd_NewItem1"), sa);
@@ -210,7 +214,6 @@
 
         // Hide newMenu0.
         newMenu0.setAttribute("hidden", "true");
-        forceNativeMenuReload();
         ok(runBaseMenuTests(), sa); // the base menu should still be unhidden
         ok(!testItem("1|0", ""), sna);
         ok(!testItem("1|1", ""), sna);
@@ -221,7 +224,7 @@
 
         // Show newMenu0.
         newMenu0.setAttribute("hidden", "false");
-        forceNativeMenuReload();
+        forceUpdateNativeMenuAt("1|3");
         ok(runBaseMenuTests(), sa);
         ok(testItem("1|0", "cmd_NewItem0"), sa);
         ok(testItem("1|1", "cmd_NewItem1"), sa);
@@ -233,7 +236,7 @@
         // Hide items.
         newMenuItem1.setAttribute("hidden", "true");
         newMenuItem4.setAttribute("hidden", "true");
-        forceNativeMenuReload();
+        forceUpdateNativeMenuAt("1|2");
         ok(runBaseMenuTests(), sa);
         ok(testItem("1|0", "cmd_NewItem0"), sa);
         ok(testItem("1|1", "cmd_NewItem2"), sa);
@@ -245,7 +248,7 @@
         // Show items.
         newMenuItem1.setAttribute("hidden", "false");
         newMenuItem4.setAttribute("hidden", "false");
-        forceNativeMenuReload();
+        forceUpdateNativeMenuAt("1|3");
         ok(runBaseMenuTests(), sa);
         ok(testItem("1|0", "cmd_NewItem0"), sa);
         ok(testItem("1|1", "cmd_NewItem1"), sa);
@@ -259,7 +262,6 @@
 
         // Remove menu.
         menubarNode.removeChild(newMenu0);
-        forceNativeMenuReload();
         ok(runBaseMenuTests(), sa);
         ok(!testItem("1|0", ""), sna);
         ok(!testItem("1|1", ""), sna);
@@ -278,7 +280,7 @@
         menubarNode.removeChild(newMenu0);
         menubarNode.appendChild(tmpMenu0);
         menubarNode.appendChild(newMenu0);
-        forceNativeMenuReload();
+        forceUpdateNativeMenuAt("1|3");
         ok(runBaseMenuTests());
         ok(testItem("1|0", "cmd_NewItem0"), sa);
         ok(testItem("1|1", "cmd_NewItem1"), sa);
@@ -288,6 +290,7 @@
         ok(testItem("1|3|2", "cmd_NewItem5"), sa);
         // return state to original diagramed state
         menubarNode.removeChild(tmpMenu0);
+        delete tmpMenu0;
 
         onTestsFinished();
       }
diff -r 17e9560465b0 xpcom/Makefile.in
--- a/xpcom/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/xpcom/Makefile.in	Thu Oct 30 05:41:46 2008 -0400
@@ -94,5 +94,9 @@
 # xpcom-config.h is generated by configure
 SDK_HEADERS	= xpcom-config.h
 
+ifdef DEHYDRA_PATH
+DIRS += analysis
+endif
+
 include $(topsrcdir)/config/rules.mk
 
diff -r 17e9560465b0 xpcom/analysis/MDC-attach.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/xpcom/analysis/MDC-attach.py	Thu Oct 30 05:41:47 2008 -0400
@@ -0,0 +1,19 @@
+#!/usr/bin/env python
+
+"""
+Upload a file attachment to MDC
+
+Usage: python MDC-attach.py <file> <parent page name> <MIME type> <description>
+Please set MDC_USER and MDC_PASSWORD in the environment
+"""
+
+import os, sys, deki
+
+wikiuser = os.environ['MDC_USER']
+wikipw = os.environ['MDC_PASSWORD']
+
+file, pageid, mimetype, description = sys.argv[1:]
+
+wiki = deki.Deki("http://developer.mozilla.org/@api/deki/", wikiuser, wikipw)
+wiki.create_file(pageid, os.path.basename(file), open(file).read(), mimetype,
+                 description)
diff -r 17e9560465b0 xpcom/analysis/MDC-upload.py
--- a/xpcom/analysis/MDC-upload.py	Thu Oct 23 09:51:35 2008 -0700
+++ b/xpcom/analysis/MDC-upload.py	Thu Oct 30 05:41:47 2008 -0400
@@ -1,13 +1,13 @@
 #!/usr/bin/env python
 
 """
-Upload a file to MDC
+Upload a page to MDC
 
 Usage: python MDC-upload.py <file> <MDC-path>
 Please set MDC_USER and MDC_PASSWORD in the environment
 """
 
-import os, sys, urllib, urllib2, deki
+import os, sys, deki
 
 wikiuser = os.environ['MDC_USER']
 wikipw = os.environ['MDC_PASSWORD']
diff -r 17e9560465b0 xpcom/analysis/Makefile.in
--- a/xpcom/analysis/Makefile.in	Thu Oct 23 09:51:35 2008 -0700
+++ b/xpcom/analysis/Makefile.in	Thu Oct 30 05:41:47 2008 -0400
@@ -17,12 +17,6 @@
 DUMP_CLASSES = \
   nsAString_internal \
   nsACString_internal \
-  nsString \
-  nsCString \
-  nsAutoString \
-  nsCAutoString \
-  nsXPIDLString \
-  nsXPIDLCString \
   $(NULL)
 
 SPACE = $(NULL) $(NULL)
@@ -33,14 +27,28 @@
 classapi: DEHYDRA_MODULES = $(srcdir)/type-printer.js
 classapi: TREEHYDRA_MODULES =
 classapi: DEHYDRA_ARGS += --dump-types=$(subst $(SPACE),$(COMMA),$(strip $(DUMP_CLASSES))) --rev=$(HGREV)
-classapi:
-	$(CCC) $(OUTOPTION)/dev/null -c $(COMPILE_CXXFLAGS) $(srcdir)/type-printer.cpp
+classapi: $(MDDEPDIR)
+	$(CCC) $(OUTOPTION)/dev/null -c $(COMPILE_CXXFLAGS) $(srcdir)/type-printer.cpp >classapi.out 2>&1
+	perl -e 'while (<>) {if (/DUMP-TYPE\((.*)\)/) {print "$$1 ";}}' <classapi.out >dumptypes.list
+	perl -e 'while (<>) {if (/GRAPH-TYPE\((.*)\)/) {print "$$1 ";}}' <classapi.out >graphtypes.list
 	$(EXIT_ON_ERROR) \
-	for class in $(DUMP_CLASSES); do \
+	for class in `cat graphtypes.list`; do \
+	  dot -Tpng -o$${class}-graph.png -Tcmapx -o$${class}-graph.map $${class}-graph.gv; \
+	done
+	$(EXIT_ON_ERROR) \
+	for class in `cat dumptypes.list`; do \
 	  $(PYTHON) $(srcdir)/fix-srcrefs.py $(topsrcdir) < $${class}.html > $${class}-fixed.html; \
 	done
 
 upload_classapi:
-	for class in $(DUMP_CLASSES); do \
+	$(EXIT_ON_ERROR) \
+	for class in `cat dumptypes.list`; do \
 	  $(PYTHON) $(srcdir)/MDC-upload.py $${class}-fixed.html en/$${class}; \
 	done
+	$(EXIT_ON_ERROR) \
+	for class in `cat graphtypes.list`; do \
+	  $(PYTHON) $(srcdir)/MDC-attach.py $${class}-graph.png en/$${class} "image/png" "Class inheritance graph"; \
+	done
+
+GARBAGE += $(wildcard *.html) $(wildcard *.png) $(wildcard *.map) \
+  $(wildcard *.gv) classapi.out graphtypes.list dumptypes.list
diff -r 17e9560465b0 xpcom/analysis/deki.py
--- a/xpcom/analysis/deki.py	Thu Oct 23 09:51:35 2008 -0700
+++ b/xpcom/analysis/deki.py	Thu Oct 30 05:41:47 2008 -0400
@@ -20,7 +20,7 @@
 """
 
 import sys
-import urllib2, cookielib
+import urllib2, cookielib, httplib
 import xml.dom.minidom as dom
 from urllib import quote as _urllib_quote
 from urllib import urlencode as _urlencode
@@ -46,6 +46,10 @@
     if params:
         url += '?' + _urlencode(params)
     return url
+
+class PutRequest(urllib2.Request):
+    def get_method(self):
+        return "PUT"
 
 # === Dream framework client code
 
@@ -96,9 +100,8 @@
     def open(self, url):
         return self._opener.open(self.base + url)
 
-    def post(self, url, data, type):
-        #print "DEBUG- posting to:", self.base + url
-        req = urllib2.Request(self.base + url, data, {'Content-Type': type})
+    def _handleResponse(self, req):
+        """Helper method shared between post() and put()"""
         resp = self._opener.open(req)
         try:
             ct = resp.headers.get('Content-Type', '(none)')
@@ -111,6 +114,17 @@
                 return None
         finally:
             resp.close()
+
+
+    def post(self, url, data, type):
+        #print "DEBUG- posting to:", self.base + url
+        req = urllib2.Request(self.base + url, data, {'Content-Type': type})
+        return self._handleResponse(req)
+
+    def put(self, url, data, type):
+        #print "DEBUG- putting to:", self.base + url
+        req = PutRequest(self.base + url, data, {'Content-Type': type})
+        return self._handleResponse(req)
 
     def get_xml(self, url):
         resp = self.open(url)
@@ -202,6 +216,27 @@
         _check(doc.documentElement.tagName == 'body')
         p = Page(self)
         p._create(path, title, doc, overwrite)
+
+    def attach_file(self, page, name, data, mimetype, description=None):
+        """Create or update a file attachment.
+
+        Parameters:
+          page - str - the page ID this file is related to
+          name - str - the name of the file
+          data - str - the file data
+          mimetype - str - the MIME type of the file
+          description - str - a description of the file
+        """
+
+        p = {}
+        if description is not None:
+            p['description'] = description
+
+        url = _make_url('pages', _format_page_id(page),
+                        'files', _format_page_id(name), **p)
+
+        r = self.put(url, data, mimetype)
+        _check(r.documentElement.nodeName == u'file')
 
     def get_subpages(self, page_id):
         """ Return the ids of all subpages of the given page. """
diff -r 17e9560465b0 xpcom/analysis/fix-srcrefs.py
--- a/xpcom/analysis/fix-srcrefs.py	Thu Oct 23 09:51:35 2008 -0700
+++ b/xpcom/analysis/fix-srcrefs.py	Thu Oct 30 05:41:47 2008 -0400
@@ -3,6 +3,8 @@
 """
 Fix references to source files of the form [LOCpath]
 so that they are relative to a given source directory.
+
+Substitute the DOT-generated image map into the document.
 """
 
 import os, sys, re
@@ -21,7 +23,15 @@
     file = file[len(srcdir) + 1:]
     return file
 
+s = re.compile(r'\[MAP(.*?)\]')
+
+def mapreplace(m):
+    file = m.group(1)
+    c = open(file).read()
+    return c
+
 for line in sys.stdin:
     line = f.sub(replacer, line)
+    line = s.sub(mapreplace, line)
+
     sys.stdout.write(line)
-
diff -r 17e9560465b0 xpcom/analysis/string-format.js
--- a/xpcom/analysis/string-format.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/xpcom/analysis/string-format.js	Thu Oct 30 05:41:47 2008 -0400
@@ -13,6 +13,9 @@
     d = arguments[0];
 
   function r(s, key, type) {
+    if (type == '%')
+      return '%';
+    
     let v;
     if (key == "") {
       if (curindex == -1)
@@ -50,8 +53,6 @@
       return parseInt(v);
     case "f":
       return Number(v);
-    case "%":
-      return "%";
     default:
       throw Error("Unexpected format character '%s'.".format(type));
     }
diff -r 17e9560465b0 xpcom/analysis/type-printer.js
--- a/xpcom/analysis/type-printer.js	Thu Oct 23 09:51:35 2008 -0700
+++ b/xpcom/analysis/type-printer.js	Thu Oct 30 05:41:47 2008 -0400
@@ -1,7 +1,27 @@
 let dumpTypes = options['dump-types'].split(',');
-function interestingType(name) dumpTypes.some(function(n) n == name);
 
+let interestingList = {};
 let typelist = {};
+
+function interestingType(t)
+{
+  let name = t.name;
+  
+  if (dumpTypes.some(function(n) n == name)) {
+    interestingList[name] = t;
+    typelist[name] = t;
+    return true;
+  }
+  
+  for each (let base in t.bases) {
+    if (base.access == 'public' && interestingType(base.type)) {
+      typelist[name] = t;
+      return true;
+    }
+  }
+  
+  return false;
+}
 
 function addSubtype(t, subt)
 {
@@ -17,13 +37,10 @@
 
 function process_type(t)
 {
-  let name = t.name;
+  interestingType(t);
   
-  if (interestingType(t.name))
-    typelist[t.name] = t;
-  
-  if (t.memberOf)
-    addSubtype(t.memberOf, t);
+  for each (let base in t.bases)
+    addSubtype(base.type, t);
 }
 
 function process_decl(d)
@@ -223,6 +240,8 @@
 
 function dumpType(t)
 {
+  print("DUMP-TYPE(%s)".format(t.name));
+
   let methodOverview = <tbody />;
   let methodList = <div/>;
   let memberList = <></>;
@@ -322,6 +341,13 @@
       <p>{getLocLink(t.loc, "Class Declaration")}</p>
   
       {getDocComment(t.loc)}
+
+      {dumpTypes.some(function(n) n == t.name) ?
+         <>
+           [MAP{t.name}-graph.map]
+           <img src={"/@api/deki/pages/=en%%252F%s/files/=%s-graph.png".format(t.name, t.name)} usemap="#classes" />
+         </> : <></>
+      }
   
       {methodOverview.*.length() > 0 ?
          <>
@@ -352,8 +378,36 @@
   write_file(t.name + ".html", r.toXMLString());
 }
 
+function graphType(t)
+{
+  print("GRAPH-TYPE(%s)".format(t.name));
+
+  let contents = "digraph classes {\n"
+               + "  node [shape=rectangle fontsize=11]\n"
+               + "  %s;\n".format(t.name);
+
+  function graphClass(c)
+  {
+    contents += '%s [URL="http://developer.mozilla.org/en/%s"]\n'.format(c.name, c.name);
+    
+    for each (let st in c.subtypes) {
+      contents += "  %s -> %s;\n".format(c.name, st.name);
+      graphClass(st);
+    }
+  }
+
+  graphClass(t);
+  
+  contents += "}\n";
+  
+  write_file(t.name + "-graph.gv", contents);
+}
+  
 function input_end()
 {
   for (let p in typelist)
     dumpType(typelist[p]);
+
+  for (let n in interestingList)
+    graphType(interestingList[n]);
 }
diff -r 17e9560465b0 xpcom/idl-parser/xpidl.py
--- a/xpcom/idl-parser/xpidl.py	Thu Oct 23 09:51:35 2008 -0700
+++ b/xpcom/idl-parser/xpidl.py	Thu Oct 30 05:41:47 2008 -0400
@@ -537,6 +537,7 @@
     scriptable = False
     function = False
     deprecated = False
+    noscript = False
 
     def setuuid(self, value):
         self.uuid = value.lower()
@@ -617,10 +618,15 @@
     def getValue(self):
         return self.value(self.iface)
 
+    def __str__(self):
+        return "\tconst %s %s = %s\n" % (self.type, self.name, self.getValue())
+
 class Attribute(object):
     kind = 'attribute'
     noscript = False
     notxpcom = False
+    readonly = False
+    binaryname = None
 
     def __init__(self, type, name, attlist, readonly, location, doccomments):
         self.type = type
@@ -628,7 +634,6 @@
         self.attlist = attlist
         self.readonly = readonly
         self.location = location
-        self.binaryname = None
         self.doccomments = doccomments
 
         for name, value, aloc in attlist:
@@ -1125,7 +1130,7 @@
                          name=p[5],
                          attlist=p[1]['attlist'],
                          readonly=p[2] is not None,
-                         location=self.getLocation(p, 1),
+                         location=self.getLocation(p, 3),
                          doccomments=doccomments)
 
     def p_member_method(self, p):
@@ -1139,7 +1144,7 @@
                       name=p[3],
                       attlist=p[1]['attlist'],
                       paramlist=p[5],
-                      location=self.getLocation(p, 1),
+                      location=self.getLocation(p, 3),
                       doccomments=doccomments,
                       raises=p[7])
 
diff -r 17e9560465b0 xpcom/io/nsEscape.cpp
--- a/xpcom/io/nsEscape.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/xpcom/io/nsEscape.cpp	Thu Oct 30 05:41:47 2008 -0400
@@ -222,62 +222,67 @@
 NS_COM char *
 nsEscapeHTML(const char * string)
 {
-	/* XXX Hardcoded max entity len. The +1 is for the trailing null. */
-	char *rv = (char *) nsMemory::Alloc(strlen(string) * 6 + 1);
-	char *ptr = rv;
+    char *rv = nsnull;
+    /* XXX Hardcoded max entity len. The +1 is for the trailing null. */
+    PRUint32 len = PL_strlen(string);
+    if (len >= (PR_UINT32_MAX / 6))
+      return nsnull;
 
-	if(rv)
-	  {
-		for(; *string != '\0'; string++)
-		  {
-			if(*string == '<')
-			  {
-				*ptr++ = '&';
-				*ptr++ = 'l';
-				*ptr++ = 't';
-				*ptr++ = ';';
-			  }
-			else if(*string == '>')
-			  {
-				*ptr++ = '&';
-				*ptr++ = 'g';
-				*ptr++ = 't';
-				*ptr++ = ';';
-			  }
-			else if(*string == '&')
-			  {
-				*ptr++ = '&';
-				*ptr++ = 'a';
-				*ptr++ = 'm';
-				*ptr++ = 'p';
-				*ptr++ = ';';
-			  }
-			else if (*string == '"')
-			  {
-				*ptr++ = '&';
-				*ptr++ = 'q';
-				*ptr++ = 'u';
-				*ptr++ = 'o';
-				*ptr++ = 't';
-				*ptr++ = ';';
-			  }			
-			else if (*string == '\'')
-			  {
-				*ptr++ = '&';
-				*ptr++ = '#';
-				*ptr++ = '3';
-				*ptr++ = '9';
-				*ptr++ = ';';
-			  }
-			else
-			  {
-				*ptr++ = *string;
-			  }
-		  }
-		*ptr = '\0';
-	  }
+    rv = (char *)NS_Alloc( (6 * len) + 1 );
+    char *ptr = rv;
 
-	return(rv);
+    if(rv)
+      {
+        for(; *string != '\0'; string++)
+          {
+            if(*string == '<')
+              {
+                *ptr++ = '&';
+                *ptr++ = 'l';
+                *ptr++ = 't';
+                *ptr++ = ';';
+              }
+            else if(*string == '>')
+              {
+                *ptr++ = '&';
+                *ptr++ = 'g';
+                *ptr++ = 't';
+                *ptr++ = ';';
+              }
+            else if(*string == '&')
+              {
+                *ptr++ = '&';
+                *ptr++ = 'a';
+                *ptr++ = 'm';
+                *ptr++ = 'p';
+                *ptr++ = ';';
+              }
+            else if (*string == '"')
+              {
+                *ptr++ = '&';
+                *ptr++ = 'q';
+                *ptr++ = 'u';
+                *ptr++ = 'o';
+                *ptr++ = 't';
+                *ptr++ = ';';
+              }
+            else if (*string == '\'')
+              {
+                *ptr++ = '&';
+                *ptr++ = '#';
+                *ptr++ = '3';
+                *ptr++ = '9';
+                *ptr++ = ';';
+              }
+            else
+              {
+                *ptr++ = *string;
+              }
+          }
+        *ptr = '\0';
+      }
+
+    return(rv);
 }
 
 NS_COM PRUnichar *
@@ -289,6 +294,10 @@
   }
 
   /* XXX Hardcoded max entity len. */
+  if (aSourceBufferLen >=
+      ((PR_UINT32_MAX / (6 * sizeof(PRUnichar))) + sizeof(PRUnichar)))
+    return nsnull;
+
   PRUnichar *resultBuffer = (PRUnichar *)nsMemory::Alloc(aSourceBufferLen *
                             6 * sizeof(PRUnichar) + sizeof(PRUnichar('\0')));
   PRUnichar *ptr = resultBuffer;
diff -r 17e9560465b0 xpcom/reflect/xptcall/src/md/unix/xptcinvoke_gcc_x86_unix.cpp
--- a/xpcom/reflect/xptcall/src/md/unix/xptcinvoke_gcc_x86_unix.cpp	Thu Oct 23 09:51:35 2008 -0700
+++ b/xpcom/reflect/xptcall/src/md/unix/xptcinvoke_gcc_x86_unix.cpp	Thu Oct 30 05:41:47 2008 -0400
@@ -156,11 +156,13 @@
 	"leal  0(,%eax,8),%edx\n\t"
 	"movl  %esp, %ecx\n\t"
 	"subl  %edx, %ecx\n\t"
-/* Since there may be 64-bit data, it occurs to me that aligning this
-   space might be a performance gain. However, I don't think the rest
-   of mozilla worries about such things. In any event, do it here.
-	"andl  $0xfffffff8, %ecx\n\t"
+/* Align to maximum x86 data size: 128 bits == 16 bytes == XMM register size.
+ * This is to avoid protection faults where SSE+ alignment of stack pointer
+ * is assumed and required, e.g. by GCC4's -ftree-vectorize option.
  */
+	"andl  $0xfffffff0, %ecx\n\t"   /* drop(?) stack ptr to 128-bit align */
+	"subl  $8, %ecx\n\t"	        /* lower again; push/call below will re-align */
+	
 	"movl  %ecx, %esp\n\t"          /* make stack space */
 	"movl  0x14(%ebp), %edx\n\t"
 	"call  " SYMBOL_UNDERSCORE "invoke_copy_to_stack\n\t"
diff -r 17e9560465b0 xpinstall/packager/Packager.pm
--- a/xpinstall/packager/Packager.pm	Thu Oct 23 09:51:35 2008 -0700
+++ b/xpinstall/packager/Packager.pm	Thu Oct 30 05:41:47 2008 -0400
@@ -147,7 +147,7 @@
 
     # if we hit this, it's either a file in the package file that is
     # not in the src directory, or it is not a valid entry.
-    warn "Warning: package error or possible missing or unnecessary file: $line ($package, $lineno).\n";
+    print "Warning: package error or possible missing or unnecessary file: $line ($package, $lineno).\n";
 
   } # LINE
 
