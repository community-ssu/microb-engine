diff -r b7bcdd009540 accessible/src/html/nsHTMLTextAccessible.cpp
--- a/accessible/src/html/nsHTMLTextAccessible.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/accessible/src/html/nsHTMLTextAccessible.cpp	Thu Sep 11 15:19:24 2008 +0300
@@ -99,17 +99,17 @@ nsHTMLTextAccessible::GetAttributesInter
   if (!mDOMNode) {
     return NS_ERROR_FAILURE;  // Node already shut down
   }
 
   PRUint32 role;
   GetRole(&role);
   if (role == nsIAccessibleRole::ROLE_STATICTEXT) {
     nsAutoString oldValueUnused;
-    aAttributes->SetStringProperty(NS_LITERAL_CSTRING("static"),
+    aAttributes->SetStringProperty(NS_LITERAL_CSTRING("auto-generated"),
                                   NS_LITERAL_STRING("true"), oldValueUnused);
   }
 
   return NS_OK;
 }
 
 nsHTMLHRAccessible::nsHTMLHRAccessible(nsIDOMNode* aDomNode, nsIWeakReference* aShell):
 nsLeafAccessible(aDomNode, aShell)
diff -r b7bcdd009540 accessible/tests/Makefile.in
--- a/accessible/tests/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/accessible/tests/Makefile.in	Thu Sep 11 15:19:24 2008 +0300
@@ -40,14 +40,14 @@ topsrcdir = @top_srcdir@
 topsrcdir = @top_srcdir@
 srcdir    = @srcdir@
 VPATH   = @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 MODULE	= test_accessibility
 
-ifdef MOZ_MOCHITEST
+ifdef ENABLE_TESTS
 DIRS		+= mochitest
 endif
 
 include $(topsrcdir)/config/rules.mk
 
diff -r b7bcdd009540 browser/app/Makefile.in
--- a/browser/app/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/browser/app/Makefile.in	Thu Sep 11 15:19:24 2008 +0300
@@ -112,28 +112,21 @@ EXTRA_DSO_LIBS += xul
 EXTRA_DSO_LIBS += xul
 endif
 endif
 
 ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
 TK_LIBS := $(TK_LIBS)
 endif
 
-ifdef MOZ_ENABLE_LIBXUL
-APP_XPCOM_LIBS = $(XPCOM_GLUE_LDOPTS)
-else
-MOZILLA_INTERNAL_API = 1
-APP_XPCOM_LIBS = $(XPCOM_LIBS)
-endif
-
 LIBS += \
 	$(STATIC_COMPONENTS_LINKER_PATH) \
 	$(EXTRA_DSO_LIBS) \
 	$(MOZ_JS_LIBS) \
-	$(APP_XPCOM_LIBS) \
+	$(XPCOM_GLUE_LDOPTS) \
 	$(NSPR_LIBS) \
 	$(TK_LIBS) \
 	$(NULL)
 
 # Add explicit X11 dependency when building against X11 toolkits
 ifneq (,$(filter gtk2,$(MOZ_WIDGET_TOOLKIT)))
 LIBS += $(XLDFLAGS) $(XLIBS) $(ZLIB_LIBS)
 endif
diff -r b7bcdd009540 browser/app/profile/firefox.js
--- a/browser/app/profile/firefox.js	Mon Sep 08 00:36:19 2008 -0700
+++ b/browser/app/profile/firefox.js	Thu Sep 11 15:19:24 2008 +0300
@@ -530,19 +530,16 @@ pref("browser.backspace_action", 0);
 
 // this will automatically enable inline spellchecking (if it is available) for
 // editable elements in HTML
 // 0 = spellcheck nothing
 // 1 = check multi-line controls [default]
 // 2 = check multi/single line controls
 pref("layout.spellcheckDefault", 1);
 
-pref("view_source.editor.path", "");
-pref("view_source.editor.external", false);
-
 pref("browser.send_pings", false);
 
 /* initial web feed readers list */
 pref("browser.contentHandlers.types.0.title", "chrome://browser-region/locale/region.properties");
 pref("browser.contentHandlers.types.0.uri", "chrome://browser-region/locale/region.properties");
 pref("browser.contentHandlers.types.0.type", "application/vnd.mozilla.maybe.feed");
 pref("browser.contentHandlers.types.1.title", "chrome://browser-region/locale/region.properties");
 pref("browser.contentHandlers.types.1.uri", "chrome://browser-region/locale/region.properties");
diff -r b7bcdd009540 browser/base/Makefile.in
--- a/browser/base/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/browser/base/Makefile.in	Thu Sep 11 15:19:24 2008 +0300
@@ -43,17 +43,17 @@ include $(DEPTH)/config/autoconf.mk
 include $(DEPTH)/config/autoconf.mk
 
 include $(topsrcdir)/config/config.mk
 
 abs_srcdir = $(shell cd $(srcdir) && pwd)
 
 CHROME_DEPS += $(abs_srcdir)/content/overrides/app-license.html
 
-ifdef MOZ_MOCHITEST
+ifdef ENABLE_TESTS
 DIRS += content/test
 endif
 
 include $(topsrcdir)/config/rules.mk
 
 DEFINES += \
 	-DMOZ_APP_VERSION=$(MOZ_APP_VERSION) \
 	-DAPP_EULA_BLOCK=$(abs_srcdir)/content/overrides/app-license.html \
diff -r b7bcdd009540 browser/base/content/aboutDialog.js
--- a/browser/base/content/aboutDialog.js	Mon Sep 08 00:36:19 2008 -0700
+++ b/browser/base/content/aboutDialog.js	Thu Sep 11 15:19:24 2008 +0300
@@ -68,17 +68,22 @@ function init(aEvent)
   var userAgentField = document.getElementById("userAgent");
   userAgentField.value = navigator.userAgent;
 
   var button = document.documentElement.getButton("extra2");
   button.setAttribute("label", document.documentElement.getAttribute("creditslabel"));
   button.setAttribute("accesskey", document.documentElement.getAttribute("creditsaccesskey"));
   button.addEventListener("command", switchPage, false);
 
-  document.documentElement.getButton("accept").focus();
+  var acceptButton = document.documentElement.getButton("accept");
+#ifdef XP_UNIX
+  acceptButton.setAttribute("icon", "close");
+#endif
+  acceptButton.focus();
+
 #ifdef XP_MACOSX
   // it may not be sized at this point, and we need its width to calculate its position
   window.sizeToContent();
   window.moveTo((screen.availWidth / 2) - (window.outerWidth / 2), screen.availHeight / 5);
 #endif
 }
 
 function uninit(aEvent)
diff -r b7bcdd009540 browser/base/content/aboutDialog.xul
--- a/browser/base/content/aboutDialog.xul	Mon Sep 08 00:36:19 2008 -0700
+++ b/browser/base/content/aboutDialog.xul	Thu Sep 11 15:19:24 2008 +0300
@@ -57,19 +57,27 @@
         windowtype="Browser:About"
         onload="init(event);" onunload="uninit(event);"
 #ifdef XP_MACOSX
         buttons="extra2"
         align="end"
 #else
         title="&aboutDialog.title;"
         buttons="accept,extra2"
+#ifdef XP_UNIX
+        buttonlabelaccept="&closeCmdGNOME.label;"
+        buttonaccesskeyaccept="&closeCmdGNOME.accesskey;"
+#endif
 #endif
         creditslabel="&copyright;"
+#ifdef XP_UNIX
+        creditsaccesskey="&copyrightGNOME.accesskey;"
+#else
         creditsaccesskey="&copyright.accesskey;"
+#endif
         aboutlabel="&aboutLink;"
         aboutaccesskey="&aboutLink.accesskey;">
     
   <script type="application/x-javascript" src="chrome://browser/content/aboutDialog.js"/>
 
   <deck id="modes" flex="1">
     <vbox flex="1" id="clientBox">
 #expand <label id="version" value="&aboutVersion; __MOZ_APP_VERSION__"/>
diff -r b7bcdd009540 browser/base/content/browser.js
--- a/browser/base/content/browser.js	Mon Sep 08 00:36:19 2008 -0700
+++ b/browser/base/content/browser.js	Thu Sep 11 15:19:24 2008 +0300
@@ -1891,28 +1891,17 @@ function BrowserViewSourceOfDocument(aDo
   try{
     var PageLoader = webNav.QueryInterface(Components.interfaces.nsIWebPageDescriptor);
 
     pageCookie = PageLoader.currentDescriptor;
   } catch(err) {
     // If no page descriptor is available, just use the view-source URL...
   }
 
-  ViewSourceOfURL(webNav.currentURI.spec, pageCookie, aDocument);
-}
-
-function ViewSourceOfURL(aURL, aPageDescriptor, aDocument)
-{
-  var utils = window.top.gViewSourceUtils;
-  if (getBoolPref("view_source.editor.external", false)) {
-    utils.openInExternalEditor(aURL, aPageDescriptor, aDocument);
-  }
-  else {
-    utils.openInInternalViewer(aURL, aPageDescriptor, aDocument);
-  }
+  top.gViewSourceUtils.viewSource(webNav.currentURI.spec, pageCookie, aDocument);
 }
 
 // doc - document to use for source, or null for this window's document
 // initialTab - name of the initial tab to display, or null for the first tab
 function BrowserPageInfo(doc, initialTab)
 {
   var args = {doc: doc, initialTab: initialTab};
   toOpenDialogByTypeAndUrl("Browser:page-info",
@@ -3907,23 +3896,21 @@ var XULBrowserWindow = {
         if (aRequest instanceof nsIChannel || "URI" in aRequest) {
           let location = aRequest.URI;
 
           // For keyword URIs clear the user typed value since they will be changed into real URIs
           if (location.scheme == "keyword" && aWebProgress.DOMWindow == content)
             gBrowser.userTypedValue = null;
 
           if (location.spec != "about:blank") {
-            const kErrorBindingAborted = 0x804B0002;
-            const kErrorNetTimeout = 0x804B000E;
             switch (aStatus) {
-              case kErrorBindingAborted:
+              case Components.results.NS_BINDING_ABORTED:
                 msg = gNavigatorBundle.getString("nv_stopped");
                 break;
-              case kErrorNetTimeout:
+              case Components.results.NS_ERROR_NET_TIMEOUT:
                 msg = gNavigatorBundle.getString("nv_timeout");
                 break;
             }
           }
         }
         // If msg is false then we did not have an error (channel may have
         // been null, in the case of a stray image load).
         if (!msg && (!location || location.spec != "about:blank"))
diff -r b7bcdd009540 browser/base/content/browser.xul
--- a/browser/base/content/browser.xul	Mon Sep 08 00:36:19 2008 -0700
+++ b/browser/base/content/browser.xul	Thu Sep 11 15:19:24 2008 +0300
@@ -94,29 +94,25 @@
     <menupopup id="backForwardMenu"
                chromedir="&locale.dir;"
                onpopupshowing="return FillHistoryMenu(event.target);"
                oncommand="gotoHistoryIndex(event);"
                onclick="checkForMiddleClick(this, event);"/>
     <tooltip id="aHTMLTooltip" onpopupshowing="return FillInHTMLTooltip(document.tooltipNode);"/>
 
     <!-- for search and content formfill/pw manager -->
-    <panel type="autocomplete" chromedir="&locale.dir;" id="PopupAutoComplete" noautofocus="true" hidden="true"/>
+    <panel type="autocomplete" chromedir="&locale.dir;" id="PopupAutoComplete" noautofocus="true" hidden="true" level="top"/>
 
     <!-- for url bar autocomplete -->
-    <panel type="autocomplete-richlistbox" chromedir="&locale.dir;" id="PopupAutoCompleteRichResult" noautofocus="true" hidden="true"/>
+    <panel type="autocomplete-richlistbox" chromedir="&locale.dir;" id="PopupAutoCompleteRichResult" noautofocus="true" hidden="true" level="top"/>
 
-    <!-- XXX panel element that has one or more text fields should not be
-             top-most panel, for IME users. See bug 433340 comment 100. -->
     <panel id="editBookmarkPanel"
            orient="vertical"
            ignorekeys="true"
            hidden="true"
-           noautohide="true"
-           onpopupshowing="this.removeAttribute('noautohide');"
            onpopupshown="StarUI.panelShown(event);"
            aria-labelledby="editBookmarkPanelTitle">
       <hbox flex="1" align="top">
         <image id="editBookmarkPanelStarIcon"/>
         <vbox flex="1">
           <label id="editBookmarkPanelTitle" flex="1"/>
           <description id="editBookmarkPanelDescription" flex="1"/>
           <hbox>
@@ -192,17 +188,17 @@
 #include browser-context.inc
     </popup>
 
     <popup id="placesContext"/>
 
     <!-- Popup for site identity information -->
     <panel id="identity-popup" position="after_start" hidden="true" noautofocus="true"
            onpopupshown="document.getElementById('identity-popup-more-info-button').focus();"
-           onpopuphidden="focusAndSelectUrlBar();" norestorefocus="true"
+           onpopuphidden="focusAndSelectUrlBar();" norestorefocus="true" level="top"
            chromedir="&locale.dir;">
       <hbox id="identity-popup-container" align="top">
         <image id="identity-popup-icon"/>
         <vbox id="identity-popup-content-box">
           <label id="identity-popup-connectedToLabel" value="&identity.connectedTo;"/>
           <label id="identity-popup-connectedToLabel2"
                  value="&identity.unverifiedsite2;"/>
           <description id="identity-popup-content-host"/>
@@ -229,17 +225,17 @@
         </vbox>
       </hbox>
     </panel>
 
     <tooltip id="urlTooltip">
       <label crop="center" flex="1"/>
     </tooltip>
 
-    <panel id="ctrlTab-panel" class="KUI-panel" hidden="true" noautofocus="true">
+    <panel id="ctrlTab-panel" class="KUI-panel" hidden="true" noautofocus="true" level="top">
       <label id="ctrlTab-label" flex="1"/>
       <svg:svg id="ctrlTab-svgRoot">
         <svg:defs>
           <svg:linearGradient id="ctrlTab-fadeGradient" x1="1" y1="1" x2="1" y2="0">
             <svg:stop id="ctrlTab-fadeGradientBottom" offset="0"/>
             <svg:stop id="ctrlTab-fadeGradientTop" offset="1"/>
           </svg:linearGradient>
           <svg:filter id="ctrlTab-iconShadow">
diff -r b7bcdd009540 browser/components/feeds/Makefile.in
--- a/browser/components/feeds/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/browser/components/feeds/Makefile.in	Thu Sep 11 15:19:24 2008 +0300
@@ -38,13 +38,13 @@ topsrcdir	= @top_srcdir@
 topsrcdir	= @top_srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 DIRS = public src
 
-ifdef MOZ_MOCHITEST
+ifdef ENABLE_TESTS
 DIRS += test
 endif
 
 include $(topsrcdir)/config/rules.mk
diff -r b7bcdd009540 browser/components/nsBrowserContentHandler.js
--- a/browser/components/nsBrowserContentHandler.js	Mon Sep 08 00:36:19 2008 -0700
+++ b/browser/components/nsBrowserContentHandler.js	Thu Sep 11 15:19:24 2008 +0300
@@ -59,17 +59,17 @@ const nsIWebNavigation       = Component
 const nsIWebNavigation       = Components.interfaces.nsIWebNavigation;
 const nsIWindowMediator      = Components.interfaces.nsIWindowMediator;
 const nsIWindowWatcher       = Components.interfaces.nsIWindowWatcher;
 const nsICategoryManager     = Components.interfaces.nsICategoryManager;
 const nsIWebNavigationInfo   = Components.interfaces.nsIWebNavigationInfo;
 const nsIBrowserSearchService = Components.interfaces.nsIBrowserSearchService;
 const nsICommandLineValidator = Components.interfaces.nsICommandLineValidator;
 
-const NS_BINDING_ABORTED = 0x804b0002;
+const NS_BINDING_ABORTED = Components.results.NS_BINDING_ABORTED;
 const NS_ERROR_WONT_HANDLE_CONTENT = 0x805d0001;
 const NS_ERROR_ABORT = Components.results.NS_ERROR_ABORT;
 
 const URI_INHERITS_SECURITY_CONTEXT = nsIHttpProtocolHandler
                                         .URI_INHERITS_SECURITY_CONTEXT;
 
 function shouldLoadURI(aURI) {
   if (aURI && !aURI.schemeIs("chrome"))
diff -r b7bcdd009540 browser/components/places/content/bookmarkProperties.js
--- a/browser/components/places/content/bookmarkProperties.js	Mon Sep 08 00:36:19 2008 -0700
+++ b/browser/components/places/content/bookmarkProperties.js	Thu Sep 11 15:19:24 2008 +0300
@@ -1082,17 +1082,17 @@ var BookmarkPropertiesPanel = {
     // 2 special folders + separator + folder-items-count limit
     if (menupopup.childNodes.length == 3 + MAX_FOLDER_ITEM_IN_MENU_LIST)
       menupopup.removeChild(menupopup.lastChild);
 
     return this._appendFolderItemToMenupopup(menupopup, aFolderId);
   },
 
   onMenuListFolderSelect: function BPP_onMenuListFolderSelect(aEvent) {
-    if (this._folderTree.hidden)
+    if (this._folderTree.collapsed)
       return;
 
     this._folderTree.selectItems([this._getFolderIdFromMenuList()]);
   },
 
   onFolderTreeSelect: function BPP_onFolderTreeSelect() {
     var selectedNode = this._folderTree.selectedNode;
     if (!selectedNode)
diff -r b7bcdd009540 browser/components/places/content/places.js
--- a/browser/components/places/content/places.js	Mon Sep 08 00:36:19 2008 -0700
+++ b/browser/components/places/content/places.js	Thu Sep 11 15:19:24 2008 +0300
@@ -301,17 +301,17 @@ var PlacesOrganizer = {
     var selectedNode = currentView.selectedNode;
     if (selectedNode && aEvent.button == 1) {
       if (PlacesUtils.nodeIsURI(selectedNode))
         PlacesUIUtils.openNodeWithEvent(selectedNode, aEvent);
       else if (PlacesUtils.nodeIsContainer(selectedNode)) {
         // The command execution function will take care of seeing the
         // selection is a folder/container and loading its contents in
         // tabs for us.
-        PlacesUIUtils.openContainerNodeInTabs(selectedNode);
+        PlacesUIUtils.openContainerNodeInTabs(selectedNode, aEvent);
       }
     }
   },
 
   /**
    * Handle focus changes on the trees.
    * When moving focus between panes we should update the details pane contents.
    * @param   aEvent
diff -r b7bcdd009540 browser/components/places/tests/Makefile.in
--- a/browser/components/places/tests/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/browser/components/places/tests/Makefile.in	Thu Sep 11 15:19:24 2008 +0300
@@ -42,14 +42,11 @@ VPATH		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 MODULE		= test_browser_places
 
 XPCSHELL_TESTS = unit
 
-ifdef MOZ_MOCHITEST
-	DIRS += browser
-	DIRS += perf
-endif
+DIRS = browser perf
 
 include $(topsrcdir)/config/rules.mk
diff -r b7bcdd009540 browser/components/places/tests/perf/Makefile.in
--- a/browser/components/places/tests/perf/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/browser/components/places/tests/perf/Makefile.in	Thu Sep 11 15:19:24 2008 +0300
@@ -43,10 +43,22 @@ relativesrcdir = browser/components/plac
 
 include $(DEPTH)/config/autoconf.mk
 include $(topsrcdir)/config/rules.mk
 
 _CHROME_FILES = \
   perf_large_delete.xul \
   $(NULL)
 
+_BROWSER_TEST_FILES = \
+  browser_ui_000_data.js\
+  browser_ui_bookmarks_sidebar.js\
+  browser_ui_history_sidebar.js\
+  $(NULL)
+# XXX disabled tests, not working properly yet
+#  browser_ui_history_menu.js\
+#  browser_ui_locationbar.js\
+
 libs:: $(_CHROME_FILES)
 	$(INSTALL) $(foreach f,$^,"$f") $(DEPTH)/_tests/testing/mochitest/chrome/$(relativesrcdir)
+
+libs:: $(_BROWSER_TEST_FILES)
+	$(INSTALL) $(foreach f,$^,"$f") $(DEPTH)/_tests/testing/mochitest/browser/$(relativesrcdir)
diff -r b7bcdd009540 browser/components/places/tests/perf/browser_ui_000_data.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/components/places/tests/perf/browser_ui_000_data.js	Thu Sep 11 15:19:24 2008 +0300
@@ -0,0 +1,163 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Dietrich Ayala <dietrich@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/*
+
+Sets up the database for subsequent performance
+tests, and test the speed of adding to history
+and bookmarks.
+
+- add XXX visits distributed over XXX days
+- add XXX bookmarks distributed over XXX days
+
+*/
+
+/*********************** begin header **********************/
+waitForExplicitFinish();
+
+const TEST_IDENTIFIER = "ui-perf-test";
+const TEST_SUITE = "places";
+
+const Cc = Components.classes;
+const Ci = Components.interfaces;
+const Cr = Components.results;
+
+var wm = Cc["@mozilla.org/appshell/window-mediator;1"].
+         getService(Ci.nsIWindowMediator);
+var win = wm.getMostRecentWindow("navigator:browser");
+
+var ios = Cc["@mozilla.org/network/io-service;1"].
+          getService(Ci.nsIIOService);
+var hs = Cc["@mozilla.org/browser/nav-history-service;1"].
+         getService(Ci.nsINavHistoryService);
+var bs = Cc["@mozilla.org/browser/nav-bookmarks-service;1"].
+         getService(Ci.nsINavBookmarksService);
+
+function add_visit(aURI, aDate) {
+  var placeID = hs.addVisit(aURI,
+                            aDate,
+                            null, // no referrer
+                            hs.TRANSITION_TYPED, // user typed in URL bar
+                            false, // not redirect
+                            0);
+  return placeID;
+}
+
+function add_bookmark(aURI) {
+  var bId = bs.insertBookmark(bs.unfiledBookmarksFolder, aURI,
+                              bs.DEFAULT_INDEX, "bookmark/" + aURI.spec);
+  return bId;
+}
+
+function make_test_report(testName, result, units) {
+  return [TEST_IDENTIFIER, TEST_SUITE, testName, result, units||"ms"].join(":");
+}
+
+// Each test is an obj w/ a name property and run method
+var ptests = [];
+
+/*********************** end header **********************/
+
+// add visits and bookmarks
+ptests.push({
+  run: function() {
+    bs.runInBatchMode({
+      runBatched: function(aUserData) {
+        // timespan - same as default history pref for now
+        var days = 90;
+
+        // add visits, distributed across the timespan
+        var total_visits = 300;
+        var visits_per_day = total_visits/days;
+
+        var visit_date_microsec = Date.now() * 1000;
+        var day_counter = 0;
+        
+        var start = Date.now();
+        for (var i = 0; i < days; i++) {
+          visit_date_microsec -= 86400 * 1000 * 1000; // remove a day
+          var spec = "http://example.com/" + visit_date_microsec;
+          for (var j = 0; j < visits_per_day; j++) {
+            var uri = ios.newURI(spec + j, null, null);
+            add_visit(uri, visit_date_microsec);
+          }
+        }
+        var duration = Date.now() - start;
+        var report = make_test_report("add_visits", duration);
+        ok(true, report);
+
+        // add bookmarks
+        var bookmarks_total = total_visits/10; // bookmark a tenth of the URLs in history
+        var bookmarks_per_day = bookmarks_total/days;
+
+        // reset visit date counter
+        visit_date_microsec = Date.now() * 1000;
+        var bookmark_counter = 0;
+        start = Date.now();
+        for (var i = 0; i < days; i++) {
+          visit_date_microsec -= 86400 * 1000 * 1000; // remove a day
+          var spec = "http://example.com/" + visit_date_microsec;
+          for (var j = 0; j < visits_per_day; j++) {
+            var uri = ios.newURI(spec + j, null, null);
+            if (bookmark_counter < bookmarks_per_day) {
+              add_bookmark(uri);
+              bookmark_counter++;
+            }
+            else
+              bookmark_counter = 0;
+          }
+        }
+        duration = Date.now() - start;
+        report = make_test_report("add_bookmarks", duration);
+        ok(true, report);
+        runNextTest();
+      }
+    }, null);
+  }
+});
+
+function test() {
+  // kick off tests
+  runNextTest();
+}
+
+function runNextTest() {
+  if (ptests.length > 0)
+    ptests.shift().run();
+  else
+    finish();
+}
diff -r b7bcdd009540 browser/components/places/tests/perf/browser_ui_bookmarks_sidebar.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/components/places/tests/perf/browser_ui_bookmarks_sidebar.js	Thu Sep 11 15:19:24 2008 +0300
@@ -0,0 +1,133 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Dietrich Ayala <dietrich@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/*
+Tests the performance of opening the bookmarks sidebar
+
+*/
+
+/*********************** begin header **********************/
+waitForExplicitFinish();
+
+const TEST_IDENTIFIER = "ui-perf-test";
+const TEST_SUITE = "places";
+
+const Cc = Components.classes;
+const Ci = Components.interfaces;
+const Cr = Components.results;
+
+var wm = Cc["@mozilla.org/appshell/window-mediator;1"].
+         getService(Ci.nsIWindowMediator);
+var win = wm.getMostRecentWindow("navigator:browser");
+
+var ios = Cc["@mozilla.org/network/io-service;1"].
+          getService(Ci.nsIIOService);
+var hs = Cc["@mozilla.org/browser/nav-history-service;1"].
+         getService(Ci.nsINavHistoryService);
+var bs = Cc["@mozilla.org/browser/nav-bookmarks-service;1"].
+         getService(Ci.nsINavBookmarksService);
+
+function add_visit(aURI, aDate) {
+  var placeID = hs.addVisit(aURI,
+                            aDate,
+                            null, // no referrer
+                            hs.TRANSITION_TYPED, // user typed in URL bar
+                            false, // not redirect
+                            0);
+  return placeID;
+}
+
+function add_bookmark(aURI) {
+  var bId = bs.insertBookmark(bs.unfiledBookmarksFolder, aURI,
+                              bs.DEFAULT_INDEX, "bookmark/" + aURI.spec);
+  return bId;
+}
+
+function make_test_report(testName, result, units) {
+  return [TEST_IDENTIFIER, TEST_SUITE, testName, result, units||"ms"].join(":");
+}
+
+// Each test is an obj w/ a name property and run method
+var ptests = [];
+
+/*********************** end header **********************/
+
+const TEST_REPEAT_COUNT = 10;
+
+// test duration of bookmarks sidebar opening
+ptests.push({
+  name: "open_bookmarks_sidebar",
+  times: [],
+  run: function() {
+    var self = this;
+    var start = Date.now();
+    var sb = document.getElementById("sidebar");
+    sb.addEventListener("load", function() {
+      var duration = Date.now() - start;
+      sb.removeEventListener("load", arguments.callee, true);
+      toggleSidebar("viewBookmarksSidebar", false);
+      self.times.push(duration);
+      if (self.times.length == TEST_REPEAT_COUNT)
+        self.finish();
+      else
+        self.run();
+    }, true);
+    toggleSidebar("viewBookmarksSidebar", true);
+  },
+  finish: function() {
+    this.times.sort();  // sort the scores
+    this.times.pop();   // remove worst
+    this.times.shift(); // remove best
+    var totalDuration = this.times.reduce(function(time, total){ return time + total; });
+    var avgDuration = totalDuration/this.times.length;
+    var report = make_test_report("open_bookmarks_sidebar", avgDuration);
+    ok(true, report);
+    runNextTest();
+  }
+});
+
+function test() {
+  // kick off tests
+  runNextTest();
+}
+
+function runNextTest() {
+  if (ptests.length > 0)
+    ptests.shift().run();
+  else
+    finish();
+}
diff -r b7bcdd009540 browser/components/places/tests/perf/browser_ui_history_menu.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/components/places/tests/perf/browser_ui_history_menu.js	Thu Sep 11 15:19:24 2008 +0300
@@ -0,0 +1,127 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Dietrich Ayala <dietrich@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/*
+Tests the performance of opening the history menu.
+*/
+
+/*********************** begin header **********************/
+waitForExplicitFinish();
+
+const TEST_IDENTIFIER = "ui-perf-test";
+const TEST_SUITE = "places";
+
+const Cc = Components.classes;
+const Ci = Components.interfaces;
+const Cr = Components.results;
+
+var wm = Cc["@mozilla.org/appshell/window-mediator;1"].
+         getService(Ci.nsIWindowMediator);
+var win = wm.getMostRecentWindow("navigator:browser");
+
+var ios = Cc["@mozilla.org/network/io-service;1"].
+          getService(Ci.nsIIOService);
+var hs = Cc["@mozilla.org/browser/nav-history-service;1"].
+         getService(Ci.nsINavHistoryService);
+var bs = Cc["@mozilla.org/browser/nav-bookmarks-service;1"].
+         getService(Ci.nsINavBookmarksService);
+
+function add_visit(aURI, aDate) {
+  var placeID = hs.addVisit(aURI,
+                            aDate,
+                            null, // no referrer
+                            hs.TRANSITION_TYPED, // user typed in URL bar
+                            false, // not redirect
+                            0);
+  return placeID;
+}
+
+function add_bookmark(aURI) {
+  var bId = bs.insertBookmark(bs.unfiledBookmarksFolder, aURI,
+                              bs.DEFAULT_INDEX, "bookmark/" + aURI.spec);
+  return bId;
+}
+
+function make_test_report(testName, result, units) {
+  return [TEST_IDENTIFIER, TEST_SUITE, testName, result, units||"ms"].join(":");
+}
+
+// Each test is an obj w/ a name property and run method
+var ptests = [];
+
+/*********************** end header **********************/
+
+// test duration of history menu opening
+ptests.push({
+  name: "open_history_menu",
+  run: function() {
+    var menu = document.getElementById("history-menu");
+    ok(menu, "history menu should exist!");
+    var start = Date.now();
+
+    var popup = document.getElementById("goPopup");
+    popup.addEventListener("popupshown", function() {
+      var duration = Date.now() - start;
+      var report = make_test_report("open_history_menu", duration);
+      ok(true, report);
+
+      // clean up
+      popup.removeEventListener("popupshown", arguments.callee, false);
+      menu.open = false;
+
+      runNextTest();
+    }, false);
+    
+    // XXX does not work, is still open=false immediately after setting it to true
+    //menu.open = true;
+
+    // XXX does nada
+    //EventUtils.sendMouseEvent({type:"click"}, "history-menu");
+  }
+});
+
+function test() {
+  // kick off tests
+  runNextTest();
+}
+
+function runNextTest() {
+  if (ptests.length > 0)
+    ptests.shift().run();
+  else
+    finish();
+}
diff -r b7bcdd009540 browser/components/places/tests/perf/browser_ui_history_sidebar.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/components/places/tests/perf/browser_ui_history_sidebar.js	Thu Sep 11 15:19:24 2008 +0300
@@ -0,0 +1,246 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Dietrich Ayala <dietrich@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/*
+Tests the performance of opening the History
+sidebar in all the available views.
+*/
+
+/*********************** begin header **********************/
+waitForExplicitFinish();
+
+const TEST_IDENTIFIER = "ui-perf-test";
+const TEST_SUITE = "places";
+
+const Cc = Components.classes;
+const Ci = Components.interfaces;
+const Cr = Components.results;
+
+var wm = Cc["@mozilla.org/appshell/window-mediator;1"].
+         getService(Ci.nsIWindowMediator);
+var win = wm.getMostRecentWindow("navigator:browser");
+
+var ios = Cc["@mozilla.org/network/io-service;1"].
+          getService(Ci.nsIIOService);
+var hs = Cc["@mozilla.org/browser/nav-history-service;1"].
+         getService(Ci.nsINavHistoryService);
+var bs = Cc["@mozilla.org/browser/nav-bookmarks-service;1"].
+         getService(Ci.nsINavBookmarksService);
+
+function add_visit(aURI, aDate) {
+  var placeID = hs.addVisit(aURI,
+                            aDate,
+                            null, // no referrer
+                            hs.TRANSITION_TYPED, // user typed in URL bar
+                            false, // not redirect
+                            0);
+  return placeID;
+}
+
+function add_bookmark(aURI) {
+  var bId = bs.insertBookmark(bs.unfiledBookmarksFolder, aURI,
+                              bs.DEFAULT_INDEX, "bookmark/" + aURI.spec);
+  return bId;
+}
+
+function make_test_report(testName, result, units) {
+  return [TEST_IDENTIFIER, TEST_SUITE, testName, result, units||"ms"].join(":");
+}
+
+// Each test is an obj w/ a name property and run method
+var ptests = [];
+
+/*********************** end header **********************/
+
+const TEST_REPEAT_COUNT = 10;
+
+// test duration of history sidebar opening
+// default: bydayandsite
+ptests.push({
+  name: "open_history_sidebar_bydayandsite",
+  times: [],
+  run: function() {
+    var self = this;
+    var start = Date.now();
+    var sb = document.getElementById("sidebar");
+    sb.addEventListener("load", function(aEvent) {
+      sb.removeEventListener("load", arguments.callee, true);
+      var duration = Date.now() - start;
+      toggleSidebar("viewHistorySidebar", false);
+      self.times.push(duration);
+      if (self.times.length == TEST_REPEAT_COUNT)
+        self.finish();
+      else
+        self.run();
+    }, true);
+    toggleSidebar("viewHistorySidebar", true);
+  },
+  finish: function() {
+    processTestResult(this);
+    runNextTest();
+  }
+});
+
+// bysite
+ptests.push({
+  name: "history_sidebar_bysite",
+  times: [],
+  run: function() {
+    var self = this;
+    var start = Date.now();
+    var sb = document.getElementById("sidebar");
+    sb.addEventListener("load", function() {
+      var duration = Date.now() - start;
+      sb.removeEventListener("load", arguments.callee, true);
+      sb.contentDocument.getElementById("bysite").doCommand();
+      toggleSidebar("viewHistorySidebar", false);
+      self.times.push(duration);
+      if (self.times.length == TEST_REPEAT_COUNT)
+        self.finish();
+      else
+        self.run();
+    }, true);
+    toggleSidebar("viewHistorySidebar", true);
+  },
+  finish: function() {
+    processTestResult(this);
+    runNextTest();
+  }
+});
+
+// byday
+ptests.push({
+  name: "history_sidebar_byday",
+  times: [],
+  run: function() {
+    var self = this;
+    var start = Date.now();
+    var sb = document.getElementById("sidebar");
+    sb.addEventListener("load", function() {
+      var duration = Date.now() - start;
+      sb.removeEventListener("load", arguments.callee, true);
+      sb.contentDocument.getElementById("byday").doCommand();
+      toggleSidebar("viewHistorySidebar", false);
+      self.times.push(duration);
+      if (self.times.length == TEST_REPEAT_COUNT)
+        self.finish();
+      else
+        self.run();
+    }, true);
+    toggleSidebar("viewHistorySidebar", true);
+  },
+  finish: function() {
+    processTestResult(this);
+    runNextTest();
+  }
+});
+
+// byvisited
+ptests.push({
+  name: "history_sidebar_byvisited",
+  times: [],
+  run: function() {
+    var self = this;
+    var start = Date.now();
+    var sb = document.getElementById("sidebar");
+    sb.addEventListener("load", function() {
+      var duration = Date.now() - start;
+      sb.removeEventListener("load", arguments.callee, true);
+      sb.contentDocument.getElementById("byvisited").doCommand();
+      toggleSidebar("viewHistorySidebar", false);
+      self.times.push(duration);
+      if (self.times.length == TEST_REPEAT_COUNT)
+        self.finish();
+      else
+        self.run();
+    }, true);
+    toggleSidebar("viewHistorySidebar", true);
+  },
+  finish: function() {
+    processTestResult(this);
+    runNextTest();
+  }
+});
+
+// bylastvisited
+ptests.push({
+  name: "history_sidebar_bylastvisited",
+  times: [],
+  run: function() {
+    var self = this;
+    var start = Date.now();
+    var sb = document.getElementById("sidebar");
+    sb.addEventListener("load", function() {
+      var duration = Date.now() - start;
+      sb.removeEventListener("load", arguments.callee, true);
+      sb.contentDocument.getElementById("bylastvisited").doCommand();
+      toggleSidebar("viewHistorySidebar", false);
+      self.times.push(duration);
+      if (self.times.length == TEST_REPEAT_COUNT)
+        self.finish();
+      else
+        self.run();
+    }, true);
+    toggleSidebar("viewHistorySidebar", true);
+  },
+  finish: function() {
+    processTestResult(this);
+    runNextTest();
+  }
+});
+
+function processTestResult(aTest) {
+  aTest.times.sort();  // sort the scores
+  aTest.times.pop();   // remove worst
+  aTest.times.shift(); // remove best
+  var totalDuration = aTest.times.reduce(function(time, total){ return time + total; });
+  var avgDuration = totalDuration/aTest.times.length;
+  var report = make_test_report(aTest.name, avgDuration);
+  ok(true, report);
+}
+
+function test() {
+  // kick off tests
+  runNextTest();
+}
+
+function runNextTest() {
+  if (ptests.length > 0)
+    ptests.shift().run();
+  else
+    finish();
+}
diff -r b7bcdd009540 browser/components/places/tests/perf/browser_ui_locationbar.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/components/places/tests/perf/browser_ui_locationbar.js	Thu Sep 11 15:19:24 2008 +0300
@@ -0,0 +1,114 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Dietrich Ayala <dietrich@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/*
+Tests the performance of opening the location bar dropdown.
+*/
+
+/*********************** begin header **********************/
+waitForExplicitFinish();
+
+const TEST_IDENTIFIER = "ui-perf-test";
+const TEST_SUITE = "places";
+
+const Cc = Components.classes;
+const Ci = Components.interfaces;
+const Cr = Components.results;
+
+var wm = Cc["@mozilla.org/appshell/window-mediator;1"].
+         getService(Ci.nsIWindowMediator);
+var win = wm.getMostRecentWindow("navigator:browser");
+
+var ios = Cc["@mozilla.org/network/io-service;1"].
+          getService(Ci.nsIIOService);
+var hs = Cc["@mozilla.org/browser/nav-history-service;1"].
+         getService(Ci.nsINavHistoryService);
+var bs = Cc["@mozilla.org/browser/nav-bookmarks-service;1"].
+         getService(Ci.nsINavBookmarksService);
+
+function add_visit(aURI, aDate) {
+  var placeID = hs.addVisit(aURI,
+                            aDate,
+                            null, // no referrer
+                            hs.TRANSITION_TYPED, // user typed in URL bar
+                            false, // not redirect
+                            0);
+  return placeID;
+}
+
+function add_bookmark(aURI) {
+  var bId = bs.insertBookmark(bs.unfiledBookmarksFolder, aURI,
+                              bs.DEFAULT_INDEX, "bookmark/" + aURI.spec);
+  return bId;
+}
+
+function make_test_report(testName, result, units) {
+  return [TEST_IDENTIFIER, TEST_SUITE, testName, result, units||"ms"].join(":");
+}
+
+// Each test is an obj w/ a name property and run method
+var ptests = [];
+
+/*********************** end header **********************/
+
+// test duration of history menu opening
+ptests.push({
+  name: "open_locationbar_default",
+  run: function() {
+    var urlbar = document.getElementById("urlbar");
+    urlbar.addEventListener("onsearchcomplete", function() {
+      urlbar.removeEventListener("onsearchcomplete", arguments.callee, false);
+      runNextTest();
+    }, false);
+
+    urlbar.value = "example";
+    urlbar.select();
+    EventUtils.synthesizeKey("VK_RETURN", {});
+  }
+});
+
+function test() {
+  // kick off tests
+  runNextTest();
+}
+
+function runNextTest() {
+  if (ptests.length > 0)
+    ptests.shift().run();
+  else
+    finish();
+}
diff -r b7bcdd009540 browser/components/preferences/Makefile.in
--- a/browser/components/preferences/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/browser/components/preferences/Makefile.in	Thu Sep 11 15:19:24 2008 +0300
@@ -38,17 +38,17 @@
 
 DEPTH		= ../../..
 topsrcdir	= @top_srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
-ifdef MOZ_MOCHITEST
+ifdef ENABLE_TESTS
 DIRS += tests
 endif
 
 include $(topsrcdir)/config/rules.mk
 
 DEFINES += \
 	-DMOZ_APP_NAME=$(MOZ_APP_NAME) \
 	-DMOZ_APP_DISPLAYNAME=$(MOZ_APP_DISPLAYNAME) \
diff -r b7bcdd009540 browser/components/safebrowsing/Makefile.in
--- a/browser/components/safebrowsing/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/browser/components/safebrowsing/Makefile.in	Thu Sep 11 15:19:24 2008 +0300
@@ -40,17 +40,17 @@ topsrcdir = @top_srcdir@
 topsrcdir = @top_srcdir@
 srcdir    = @srcdir@
 VPATH     = @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 DIRS      = src
 
-ifdef MOZ_MOCHITEST
+ifdef ENABLE_TESTS
 DIRS += content/test
 endif
 
 ifneq (,$(BUILD_OFFICIAL)$(MOZILLA_OFFICIAL))
 DEFINES += -DOFFICIAL_BUILD=1
 endif
 
 # EXTRA_COMPONENTS installs components written in JS to dist/bin/components
diff -r b7bcdd009540 browser/components/search/Makefile.in
--- a/browser/components/search/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/browser/components/search/Makefile.in	Thu Sep 11 15:19:24 2008 +0300
@@ -38,17 +38,17 @@
 
 DEPTH     = ../../..
 topsrcdir = @top_srcdir@
 srcdir    = @srcdir@
 VPATH     = @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
-ifdef MOZ_MOCHITEST
+ifdef ENABLE_TESTS
 DIRS = test
 endif
 
 MODULE = browsersearch
 XPIDL_MODULE = browsersearch
 
 XPIDLSRCS = nsIBrowserSearchService.idl
 
diff -r b7bcdd009540 browser/components/search/nsSearchService.js
--- a/browser/components/search/nsSearchService.js	Mon Sep 08 00:36:19 2008 -0700
+++ b/browser/components/search/nsSearchService.js	Thu Sep 11 15:19:24 2008 +0300
@@ -1549,23 +1549,16 @@ Engine.prototype = {
   },
 
   /**
    * Extract search engine information from the collected data to initialize
    * the engine object.
    */
   _parseAsSherlock: function SRCH_ENG_parseAsSherlock() {
     /**
-     * Trims leading and trailing whitespace from aStr.
-     */
-    function sTrim(aStr) {
-      return aStr.replace(/^\s+/g, "").replace(/\s+$/g, "");
-    }
-
-    /**
      * Extracts one Sherlock "section" from aSource. A section is essentially
      * an HTML element with attributes, but each attribute must be on a new
      * line, by definition.
      *
      * @param aLines
      *        An array of lines from the sherlock file.
      * @param aSection
      *        The name of the section (e.g. "search" or "browser"). This value
@@ -1611,30 +1604,30 @@ Engine.prototype = {
       LOG("_parseAsSherlock::getSection: Start index: " + startLine +
           "\nNumber of lines: " + numberOfLines);
       lines = lines.splice(startLine, numberOfLines);
       LOG("_parseAsSherlock::getSection: Section lines:\n" +
           lines.join("\n"));
 
       var section = {};
       for (var i = 0; i < lines.length; i++) {
-        var line = sTrim(lines[i]);
+        var line = lines[i].trim();
 
         var els = line.split("=");
-        var name = sTrim(els.shift().toLowerCase());
-        var value = sTrim(els.join("="));
+        var name = els.shift().trim().toLowerCase();
+        var value = els.join("=").trim();
 
         if (!name || !value)
           continue;
 
         // Strip leading and trailing whitespace, remove quotes from the
         // value, and remove any trailing slashes or ">" characters
         value = value.replace(/^["']/, "")
                      .replace(/["']\s*[\\\/]?>?\s*$/, "") || "";
-        value = sTrim(value);
+        value = value.trim();
 
         // Don't clobber existing attributes
         if (!(name in section))
           section[name] = value;
       }
       return section;
     }
 
@@ -1742,17 +1735,17 @@ Engine.prototype = {
       lines = aLines.filter(function (line) {
         return /^\s*<input/i.test(line);
       });
       LOG("_parseAsSherlock::getInputs: Filtered lines:\n" + lines);
 
       lines.forEach(function (line) {
         // Strip leading/trailing whitespace and remove the surrounding markup
         // ("<input" and ">")
-        line = sTrim(line).replace(/^<input/i, "").replace(/>$/, "");
+        line = line.trim().replace(/^<input/i, "").replace(/>$/, "");
 
         // If this is one of the "directional" inputs (<inputnext>/<inputprev>)
         const directionalInput = /^(prev|next)/i;
         if (directionalInput.test(line)) {
 
           // Make it look like a normal input by removing "prev" or "next"
           line = line.replace(directionalInput, "");
 
@@ -1880,17 +1873,17 @@ Engine.prototype = {
       docElem.appendChild(doc.createTextNode("\n"));
       return node;
     }
 
     var parser = Cc["@mozilla.org/xmlextras/domparser;1"].
                  createInstance(Ci.nsIDOMParser);
 
     var doc = parser.parseFromString(EMPTY_DOC, "text/xml");
-    docElem = doc.documentElement;
+    var docElem = doc.documentElement;
 
     docElem.appendChild(doc.createTextNode("\n"));
 
     appendTextNode(OPENSEARCH_NS_11, "ShortName", this.name);
     appendTextNode(OPENSEARCH_NS_11, "Description", this._description);
     appendTextNode(OPENSEARCH_NS_11, "InputEncoding", this._queryCharset);
 
     if (this._iconURI) {
@@ -1948,17 +1941,17 @@ Engine.prototype = {
     ENSURE_WARN(file && file.exists(), "Can't serialize: file doesn't exist!",
                 Cr.NS_ERROR_UNEXPECTED);
 
     var fos = Cc["@mozilla.org/network/safe-file-output-stream;1"].
               createInstance(Ci.nsIFileOutputStream);
 
     // Serialize the engine first - we don't want to overwrite a good file
     // if this somehow fails.
-    doc = this._serializeToElement();
+    var doc = this._serializeToElement();
 
     fos.init(file, (MODE_WRONLY | MODE_TRUNCATE), PERMS_FILE, 0);
 
     try {
       var serializer = Cc["@mozilla.org/xmlextras/xmlserializer;1"].
                        createInstance(Ci.nsIDOMSerializer);
       serializer.serializeToStream(doc.documentElement, fos, null);
     } catch (e) {
diff -r b7bcdd009540 browser/components/sessionstore/Makefile.in
--- a/browser/components/sessionstore/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/browser/components/sessionstore/Makefile.in	Thu Sep 11 15:19:24 2008 +0300
@@ -45,13 +45,13 @@ XPIDL_MODULE = sessionstore
 
 XPIDLSRCS = \
 	nsISessionStartup.idl \
 	nsISessionStore.idl \
   $(NULL)
 
 DIRS = src
 
-ifdef MOZ_MOCHITEST
+ifdef ENABLE_TESTS
 DIRS += test
 endif
 
 include $(topsrcdir)/config/rules.mk
diff -r b7bcdd009540 browser/components/sessionstore/src/nsSessionStore.js
--- a/browser/components/sessionstore/src/nsSessionStore.js	Mon Sep 08 00:36:19 2008 -0700
+++ b/browser/components/sessionstore/src/nsSessionStore.js	Thu Sep 11 15:19:24 2008 +0300
@@ -288,32 +288,37 @@ SessionStoreService.prototype = {
       break;
     case "quit-application":
       if (aData == "restart")
         this._prefBranch.setBoolPref("sessionstore.resume_session_once", true);
       this._loadState = STATE_QUITTING; // just to be sure
       this._uninit();
       break;
     case "browser:purge-session-history": // catch sanitization 
+      let openWindows = {};
       this._forEachBrowserWindow(function(aWindow) {
         Array.forEach(aWindow.getBrowser().browsers, function(aBrowser) {
           delete aBrowser.parentNode.__SS_data;
         });
+        openWindows[aWindow.__SSi] = true;
       });
+      // also clear all data about closed tabs and windows
+      for (ix in this._windows) {
+        if (ix in openWindows)
+          this._windows[ix]._closedTabs = [];
+        else
+          delete this._windows[ix];
+      }
       this._lastClosedWindows = null;
       this._clearDisk();
-      // also clear all data about closed tabs
-      for (ix in this._windows) {
-        this._windows[ix]._closedTabs = [];
-      }
       // give the tabbrowsers a chance to clear their histories first
       var win = this._getMostRecentBrowserWindow();
       if (win)
         win.setTimeout(function() { _this.saveState(true); }, 0);
-      else
+      else if (this._loadState == STATE_RUNNING)
         this.saveState(true);
       break;
     case "nsPref:changed": // catch pref changes
       switch (aData) {
       // if the user decreases the max number of closed tabs they want
       // preserved update our internal states to match that max
       case "sessionstore.max_tabs_undo":
         var ix;
@@ -586,19 +591,27 @@ SessionStoreService.prototype = {
     this._updateTextAndScrollDataForTab(aWindow, aTab.linkedBrowser, tabState);
 
     // reset the _tab property to avoid keeping the tab's XUL element alive
     // longer than we need it
     delete tabState._tab;
     
     // store closed-tab data for undo
     if (tabState.entries.length > 0) {
+      let tabTitle = aTab.label;
+      let tabbrowser = aWindow.gBrowser;
+      // replace "Loading..." with the document title (with minimal side-effects)
+      if (tabTitle == tabbrowser.mStringBundle.getString("tabs.loading")) {
+        tabbrowser.setTabTitle(aTab);
+        [tabTitle, aTab.label] = [aTab.label, tabTitle];
+      }
+      
       this._windows[aWindow.__SSi]._closedTabs.unshift({
         state: tabState,
-        title: aTab.getAttribute("label"),
+        title: tabTitle,
         image: aTab.getAttribute("image"),
         pos: aTab._tPos
       });
       var length = this._windows[aWindow.__SSi]._closedTabs.length;
       if (length > maxTabsUndo)
         this._windows[aWindow.__SSi]._closedTabs.splice(maxTabsUndo, length - maxTabsUndo);
     }
   },
diff -r b7bcdd009540 browser/components/shell/Makefile.in
--- a/browser/components/shell/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/browser/components/shell/Makefile.in	Thu Sep 11 15:19:24 2008 +0300
@@ -39,13 +39,13 @@ topsrcdir	= @top_srcdir@
 topsrcdir	= @top_srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 DIRS = public src
 
-ifdef MOZ_MOCHITEST
+ifdef ENABLE_TESTS
 DIRS += test
 endif
 
 include $(topsrcdir)/config/rules.mk
diff -r b7bcdd009540 browser/components/shell/src/nsGNOMEShellService.cpp
--- a/browser/components/shell/src/nsGNOMEShellService.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/browser/components/shell/src/nsGNOMEShellService.cpp	Thu Sep 11 15:19:24 2008 +0300
@@ -58,16 +58,18 @@
 #include "nsIImage.h"
 #include "prprf.h"
 #ifdef MOZ_WIDGET_GTK2
 #include "nsIImageToPixbuf.h"
 #endif
 
 #include <glib.h>
 #include <glib-object.h>
+#include <gtk/gtkversion.h>
+#include <gdk/gdk.h>
 #include <gdk-pixbuf/gdk-pixbuf.h>
 #include <limits.h>
 #include <stdlib.h>
 
 struct ProtocolAssociation
 {
   const char *name;
   PRBool essential;
@@ -441,115 +443,78 @@ nsGNOMEShellService::SetDesktopBackgroun
                    EmptyCString());
 
   gconf->SetString(NS_LITERAL_CSTRING(kDesktopImageKey), filePath);
   gconf->SetBool(NS_LITERAL_CSTRING(kDesktopDrawBGKey), PR_TRUE);
 
   return rv;
 }
 
-// In: pointer to two characters CC
-// Out: parsed color number
-static PRUint8
-HexToNum(char ch)
-{
-  if ('0' <= ch && '9' >= ch)
-    return ch - '0';
-
-  if ('A' <= ch && 'F' >= ch)
-    return ch - 'A';
-
-  if ('a' <= ch && 'f' >= ch)
-    return ch - 'a';
-
-  return 0;
-}
-  
-
-// In: 3 or 6-character RRGGBB hex string
-// Out: component colors
-static PRBool
-HexToRGB(const nsCString& aColorSpec,
-         PRUint8 &aRed,
-         PRUint8 &aGreen,
-         PRUint8 &aBlue)
-{
-  const char *buf = aColorSpec.get();
-
-  if (aColorSpec.Length() == 6) {
-    aRed =    HexToNum(buf[0]) >> 4 |
-              HexToNum(buf[1]);
-    aGreen =  HexToNum(buf[2]) >> 4 |
-              HexToNum(buf[3]);
-    aBlue =   HexToNum(buf[4]) >> 4 |
-              HexToNum(buf[5]);
-    return PR_TRUE;
-  }
-
-  if (aColorSpec.Length() == 3) {
-    aRed = HexToNum(buf[0]);
-    aGreen = HexToNum(buf[1]);
-    aBlue = HexToNum(buf[2]);
-
-    aRed |= aRed >> 4;
-    aGreen |= aGreen >> 4;
-    aBlue |= aBlue >> 4;
-
-    return PR_TRUE;
-  }
-
-  return PR_FALSE;
-}
+#define COLOR_16_TO_8_BIT(_c) ((_c) >> 8)
+#define COLOR_8_TO_16_BIT(_c) ((_c) << 8)
 
 NS_IMETHODIMP
 nsGNOMEShellService::GetDesktopBackgroundColor(PRUint32 *aColor)
 {
   nsCOMPtr<nsIGConfService> gconf = do_GetService(NS_GCONFSERVICE_CONTRACTID);
 
   nsCAutoString background;
   gconf->GetString(NS_LITERAL_CSTRING(kDesktopColorKey), background);
 
   if (background.IsEmpty()) {
     *aColor = 0;
     return NS_OK;
   }
 
-  // Chop off the leading '#' character
-  background.Cut(0, 1);
+  GdkColor color;
+  gboolean success = gdk_color_parse(background.get(), &color);
 
-  PRUint8 red, green, blue;
-  if (!HexToRGB(background, red, green, blue))
-      return NS_ERROR_FAILURE;
+  NS_ENSURE_TRUE(success, NS_ERROR_FAILURE);
 
-  // The result must be in RGB order with the high 8 bits zero.
-  *aColor = (red << 16 | green << 8  | blue);
+  *aColor = COLOR_16_TO_8_BIT(color.red) << 16 |
+            COLOR_16_TO_8_BIT(color.green) << 8 |
+            COLOR_16_TO_8_BIT(color.blue);
   return NS_OK;
 }
 
 static void
-ColorToHex(PRUint32 aColor, nsCString& aResult)
+ColorToCString(PRUint32 aColor, nsCString& aResult)
 {
-  char *buf = aResult.BeginWriting(7);
+#if GTK_CHECK_VERSION(2,12,0)
+  GdkColor color;
+  color.red = COLOR_8_TO_16_BIT(aColor >> 16);
+  color.green = COLOR_8_TO_16_BIT((aColor >> 8) & 0xff);
+  color.blue = COLOR_8_TO_16_BIT(aColor & 0xff);
+
+  gchar *colorString = gdk_color_to_string(&color);
+  aResult.Assign(colorString);
+  g_free(colorString);
+
+#else // GTK 2.12.0
+
+  // The #rrrrggggbbbb format is used to match gdk_color_to_string()
+  char *buf = aResult.BeginWriting(13);
   if (!buf)
     return;
 
   PRUint8 red = (aColor >> 16);
   PRUint8 green = (aColor >> 8) & 0xff;
   PRUint8 blue = aColor & 0xff;
 
-  PR_snprintf(buf, 8, "#%02x%02x%02x", red, green, blue);
+  PR_snprintf(buf, 14, "#%02x00%02x00%02x00", red, green, blue);
+#endif // GTK 2.12.0
 }
 
 NS_IMETHODIMP
 nsGNOMEShellService::SetDesktopBackgroundColor(PRUint32 aColor)
 {
   nsCOMPtr<nsIGConfService> gconf = do_GetService(NS_GCONFSERVICE_CONTRACTID);
 
   nsCString colorString;
-  ColorToHex(aColor, colorString);
+  ColorToCString(aColor, colorString);
 
   gconf->SetString(NS_LITERAL_CSTRING(kDesktopColorKey), colorString);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsGNOMEShellService::OpenApplication(PRInt32 aApplication)
diff -r b7bcdd009540 browser/components/shell/test/Makefile.in
--- a/browser/components/shell/test/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/browser/components/shell/test/Makefile.in	Thu Sep 11 15:19:24 2008 +0300
@@ -37,15 +37,18 @@ DEPTH		= ../../../..
 DEPTH		= ../../../..
 topsrcdir	= @top_srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 relativesrcdir  = browser/components/shell/test
 
 include $(DEPTH)/config/autoconf.mk
 
+MODULE		= test_browser_shell
+XPCSHELL_TESTS	= unit
+
 include $(topsrcdir)/config/rules.mk
 
 _BROWSER_TEST_FILES = browser_420786.js \
 	$(NULL)
 
 libs:: $(_BROWSER_TEST_FILES)
 	$(INSTALL) $(foreach f,$^,"$f") $(DEPTH)/_tests/testing/mochitest/browser/$(relativesrcdir)
diff -r b7bcdd009540 browser/components/shell/test/unit/test_421977.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/components/shell/test/unit/test_421977.js	Thu Sep 11 15:19:24 2008 +0300
@@ -0,0 +1,114 @@
+const Cc = Components.classes;
+const Ci = Components.interfaces;
+const Cr = Components.results;
+
+const GCONF_BG_COLOR_KEY = "/desktop/gnome/background/primary_color";
+
+var gShell;
+var gGConf;
+
+/**
+ * Converts from a rgb numerical color valule (r << 16 | g << 8 | b)
+ * into a hex string in #RRGGBB format.
+ */
+function colorToHex(aColor) {
+  const rMask = 4294901760;
+  const gMask = 65280;
+  const bMask = 255;
+
+  var r = (aColor & rMask) >> 16;
+  var g = (aColor & gMask) >> 8;
+  var b = (aColor & bMask);
+
+  return "#" + [r, g, b].map(function(aInt)
+                              aInt.toString(16).replace(/^(.)$/, "0$1"))
+                             .join("").toUpperCase();
+}
+
+/**
+ * Converts a color string in #RRGGBB format to a rgb numerical color value
+ *  (r << 16 | g << 8 | b).
+ */
+function hexToColor(aString) {
+  return parseInt(aString.substring(1,3), 16) << 16 |
+         parseInt(aString.substring(3,5), 16) << 8 |
+         parseInt(aString.substring(5,7), 16);
+}
+
+/**
+ * Checks that setting the GConf background key to aGConfColor will
+ * result in the Shell component returning a background color equals
+ * to aExpectedShellColor in #RRGGBB format.
+ */
+function checkGConfToShellColor(aGConfColor, aExpectedShellColor) {
+
+  gGConf.setString(GCONF_BG_COLOR_KEY, aGConfColor);
+  var shellColor = colorToHex(gShell.desktopBackgroundColor);
+
+  do_check_eq(shellColor, aExpectedShellColor);
+}
+
+/**
+ * Checks that setting the background color (in #RRGGBB format) using the Shell
+ * component will result in having a GConf key for the background color set to
+ * aExpectedGConfColor.
+ */
+function checkShellToGConfColor(aShellColor, aExpectedGConfColor) {
+
+  gShell.desktopBackgroundColor = hexToColor(aShellColor);
+  var gconfColor = gGConf.getString(GCONF_BG_COLOR_KEY);
+
+  do_check_eq(gconfColor, aExpectedGConfColor);
+}
+
+function run_test() {
+
+  // This test is Linux specific for now
+  if (!("@mozilla.org/gnome-gconf-service;1" in Cc))
+    return;
+
+  gGConf = Cc["@mozilla.org/gnome-gconf-service;1"].
+           getService(Ci.nsIGConfService);
+
+  gShell = Cc["@mozilla.org/browser/shell-service;1"].
+           getService(Ci.nsIShellService);
+
+  // Save the original background color so that we can restore it
+  // after the test.
+  var origGConfColor = gGConf.getString(GCONF_BG_COLOR_KEY);
+
+  try {
+
+    checkGConfToShellColor("#000", "#000000");
+    checkGConfToShellColor("#00f", "#0000FF");
+    checkGConfToShellColor("#b2f", "#BB22FF");
+    checkGConfToShellColor("#fff", "#FFFFFF");
+
+    checkGConfToShellColor("#000000", "#000000");
+    checkGConfToShellColor("#0000ff", "#0000FF");
+    checkGConfToShellColor("#b002f0", "#B002F0");
+    checkGConfToShellColor("#ffffff", "#FFFFFF");
+
+    checkGConfToShellColor("#000000000", "#000000");
+    checkGConfToShellColor("#00f00f00f", "#000000");
+    checkGConfToShellColor("#aaabbbccc", "#AABBCC");
+    checkGConfToShellColor("#fffffffff", "#FFFFFF");
+
+    checkGConfToShellColor("#000000000000", "#000000");
+    checkGConfToShellColor("#000f000f000f", "#000000");
+    checkGConfToShellColor("#00ff00ff00ff", "#000000");
+    checkGConfToShellColor("#aaaabbbbcccc", "#AABBCC");
+    checkGConfToShellColor("#111122223333", "#112233");
+    checkGConfToShellColor("#ffffffffffff", "#FFFFFF");
+
+    checkShellToGConfColor("#000000", "#000000000000");
+    checkShellToGConfColor("#0000FF", "#00000000ff00");
+    checkShellToGConfColor("#FFFFFF", "#ff00ff00ff00");
+    checkShellToGConfColor("#0A0B0C", "#0a000b000c00");
+    checkShellToGConfColor("#A0B0C0", "#a000b000c000");
+    checkShellToGConfColor("#AABBCC", "#aa00bb00cc00");
+
+  } finally {
+    gGConf.setString(GCONF_BG_COLOR_KEY, origGConfColor);
+  }
+}
diff -r b7bcdd009540 browser/confvars.sh
--- a/browser/confvars.sh	Mon Sep 08 00:36:19 2008 -0700
+++ b/browser/confvars.sh	Thu Sep 11 15:19:24 2008 +0300
@@ -36,16 +36,17 @@
 #
 # ***** END LICENSE BLOCK *****
 
 MOZ_APP_NAME=firefox
 MOZ_UPDATER=1
 MOZ_PHOENIX=1
 
 MOZ_ENABLE_LIBXUL=1
+MOZ_STATIC_BUILD_UNSUPPORTED=1
 MOZ_PLACES=1
 # always enabled for form history
 MOZ_MORKREADER=1
 MOZ_SAFE_BROWSING=1
 MOZ_APP_VERSION=$FIREFOX_VERSION
 MOZ_NO_XPCOM_OBSOLETE=1
 MOZ_EXTENSIONS_DEFAULT=" gnomevfs reporter"
 # MOZ_APP_DISPLAYNAME will be set by branding/configure.sh
diff -r b7bcdd009540 browser/fuel/Makefile.in
--- a/browser/fuel/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/browser/fuel/Makefile.in	Thu Sep 11 15:19:24 2008 +0300
@@ -39,14 +39,14 @@ topsrcdir = @top_srcdir@
 topsrcdir = @top_srcdir@
 srcdir    = @srcdir@
 VPATH     = @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 DIRS = public src
 
-ifdef MOZ_MOCHITEST
+ifdef ENABLE_TESTS
 DIRS += test
 endif
 
 include $(topsrcdir)/config/rules.mk
 
diff -r b7bcdd009540 browser/installer/windows/nsis/installer.nsi
--- a/browser/installer/windows/nsis/installer.nsi	Mon Sep 08 00:36:19 2008 -0700
+++ b/browser/installer/windows/nsis/installer.nsi	Thu Sep 11 15:19:24 2008 +0300
@@ -667,17 +667,76 @@ FunctionEnd
 
 Function leaveStartMenu
   ${If} $InstallType == ${INSTALLTYPE_CUSTOM}
     Call CheckExistingInstall
   ${EndIf}
 FunctionEnd
 
 Function preSummary
-  !insertmacro createSummaryINI
+  ; Setup the summary.ini file for the Custom Summary Page
+  WriteINIStr "$PLUGINSDIR\summary.ini" "Settings" NumFields "3"
+
+  WriteINIStr "$PLUGINSDIR\summary.ini" "Field 1" Type   "label"
+  WriteINIStr "$PLUGINSDIR\summary.ini" "Field 1" Text   "$(SUMMARY_INSTALLED_TO)"
+  WriteINIStr "$PLUGINSDIR\summary.ini" "Field 1" Left   "0"
+  WriteINIStr "$PLUGINSDIR\summary.ini" "Field 1" Right  "-1"
+  WriteINIStr "$PLUGINSDIR\summary.ini" "Field 1" Top    "5"
+  WriteINIStr "$PLUGINSDIR\summary.ini" "Field 1" Bottom "15"
+
+  WriteINIStr "$PLUGINSDIR\summary.ini" "Field 2" Type   "text"
+  ; The contents of this control must be set as follows in the pre function
+  ; ${MUI_INSTALLOPTIONS_READ} $1 "summary.ini" "Field 2" "HWND"
+  ; SendMessage $1 ${WM_SETTEXT} 0 "STR:$INSTDIR"
+  WriteINIStr "$PLUGINSDIR\summary.ini" "Field 2" state  ""
+  WriteINIStr "$PLUGINSDIR\summary.ini" "Field 2" Left   "0"
+  WriteINIStr "$PLUGINSDIR\summary.ini" "Field 2" Right  "-1"
+  WriteINIStr "$PLUGINSDIR\summary.ini" "Field 2" Top    "17"
+  WriteINIStr "$PLUGINSDIR\summary.ini" "Field 2" Bottom "30"
+  WriteINIStr "$PLUGINSDIR\summary.ini" "Field 2" flags  "READONLY"
+
+  WriteINIStr "$PLUGINSDIR\summary.ini" "Field 3" Type   "label"
+  WriteINIStr "$PLUGINSDIR\summary.ini" "Field 3" Text   "$(SUMMARY_CLICK)"
+  WriteINIStr "$PLUGINSDIR\summary.ini" "Field 3" Left   "0"
+  WriteINIStr "$PLUGINSDIR\summary.ini" "Field 3" Right  "-1"
+  WriteINIStr "$PLUGINSDIR\summary.ini" "Field 3" Top    "130"
+  WriteINIStr "$PLUGINSDIR\summary.ini" "Field 3" Bottom "150"
+
+  ${If} "$TmpVal" == "true"
+    WriteINIStr "$PLUGINSDIR\summary.ini" "Field 4" Type   "label"
+    WriteINIStr "$PLUGINSDIR\summary.ini" "Field 4" Text   "$(SUMMARY_REBOOT_REQUIRED_INSTALL)"
+    WriteINIStr "$PLUGINSDIR\summary.ini" "Field 4" Left   "0"
+    WriteINIStr "$PLUGINSDIR\summary.ini" "Field 4" Right  "-1"
+    WriteINIStr "$PLUGINSDIR\summary.ini" "Field 4" Top    "35"
+    WriteINIStr "$PLUGINSDIR\summary.ini" "Field 4" Bottom "45"
+
+    WriteINIStr "$PLUGINSDIR\summary.ini" "Settings" NumFields "4"
+  ${EndIf}
+
+  ReadINIStr $0 "$PLUGINSDIR\options.ini" "Field 6" "State"
+  ${If} "$0" == "1"
+    ${If} "$TmpVal" == "true"
+      ; To insert this control reset Top / Bottom for controls below this one
+      WriteINIStr "$PLUGINSDIR\summary.ini" "Field 4" Top    "50"
+      WriteINIStr "$PLUGINSDIR\summary.ini" "Field 4" Bottom "60"
+      StrCpy $0 "5"
+    ${Else}
+      StrCpy $0 "4"
+    ${EndIf}
+
+    WriteINIStr "$PLUGINSDIR\summary.ini" "Field $0" Type   "label"
+    WriteINIStr "$PLUGINSDIR\summary.ini" "Field $0" Text   "$(SUMMARY_MAKE_DEFAULT)"
+    WriteINIStr "$PLUGINSDIR\summary.ini" "Field $0" Left   "0"
+    WriteINIStr "$PLUGINSDIR\summary.ini" "Field $0" Right  "-1"
+    WriteINIStr "$PLUGINSDIR\summary.ini" "Field $0" Top    "35"
+    WriteINIStr "$PLUGINSDIR\summary.ini" "Field $0" Bottom "45"
+
+    WriteINIStr "$PLUGINSDIR\summary.ini" "Settings" NumFields "$0"
+  ${EndIf}
+
   !insertmacro MUI_HEADER_TEXT "$(SUMMARY_PAGE_TITLE)" "$(SUMMARY_PAGE_SUBTITLE)"
 
   ; The Summary custom page has a textbox that will automatically receive
   ; focus. This sets the focus to the Install button instead.
   !insertmacro MUI_INSTALLOPTIONS_INITDIALOG "summary.ini"
   GetDlgItem $0 $HWNDPARENT 1
   System::Call "user32::SetFocus(i r0, i 0x0007, i,i)i"
   ${MUI_INSTALLOPTIONS_READ} $1 "summary.ini" "Field 2" "HWND"
@@ -712,18 +771,100 @@ Function .onInit
   StrCpy $LANGUAGE 0
   ${SetBrandNameVars} "$EXEDIR\localized\distribution\setup.ini"
 
   ${InstallOnInitCommon} "$(WARN_UNSUPPORTED_MSG)"
 
   !insertmacro MUI_INSTALLOPTIONS_EXTRACT "options.ini"
   !insertmacro MUI_INSTALLOPTIONS_EXTRACT "shortcuts.ini"
   !insertmacro MUI_INSTALLOPTIONS_EXTRACT "summary.ini"
-  !insertmacro createBasicCustomSetAsDefaultOptionsINI
-  !insertmacro createShortcutsINI
+
+  ; Setup the options.ini file for the Custom Options Page
+  WriteINIStr "$PLUGINSDIR\options.ini" "Settings" NumFields "6"
+
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 1" Type   "label"
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 1" Text   "$(OPTIONS_SUMMARY)"
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 1" Left   "0"
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 1" Right  "-1"
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 1" Top    "0"
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 1" Bottom "10"
+
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 2" Type   "RadioButton"
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 2" Text   "$(OPTION_STANDARD_RADIO)"
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 2" Left   "15"
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 2" Right  "-1"
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 2" Top    "25"
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 2" Bottom "35"
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 2" State  "1"
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 2" Flags  "GROUP"
+
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 3" Type   "RadioButton"
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 3" Text   "$(OPTION_CUSTOM_RADIO)"
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 3" Left   "15"
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 3" Right  "-1"
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 3" Top    "55"
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 3" Bottom "65"
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 3" State  "0"
+
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 4" Type   "label"
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 4" Text   "$(OPTION_STANDARD_DESC)"
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 4" Left   "30"
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 4" Right  "-1"
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 4" Top    "37"
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 4" Bottom "57"
+
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 5" Type   "label"
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 5" Text   "$(OPTION_CUSTOM_DESC)"
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 5" Left   "30"
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 5" Right  "-1"
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 5" Top    "67"
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 5" Bottom "87"
+
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 6" Type   "checkbox"
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 6" Text   "$(OPTIONS_MAKE_DEFAULT)"
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 6" Left   "0"
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 6" Right  "-1"
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 6" Top    "124"
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 6" Bottom "145"
+  WriteINIStr "$PLUGINSDIR\options.ini" "Field 6" State  "1"
+
+  ; Setup the shortcuts.ini file for the Custom Shortcuts Page
+  WriteINIStr "$PLUGINSDIR\shortcuts.ini" "Settings" NumFields "4"
+
+  WriteINIStr "$PLUGINSDIR\shortcuts.ini" "Field 1" Type   "label"
+  WriteINIStr "$PLUGINSDIR\shortcuts.ini" "Field 1" Text   "$(CREATE_ICONS_DESC)"
+  WriteINIStr "$PLUGINSDIR\shortcuts.ini" "Field 1" Left   "0"
+  WriteINIStr "$PLUGINSDIR\shortcuts.ini" "Field 1" Right  "-1"
+  WriteINIStr "$PLUGINSDIR\shortcuts.ini" "Field 1" Top    "5"
+  WriteINIStr "$PLUGINSDIR\shortcuts.ini" "Field 1" Bottom "15"
+
+  WriteINIStr "$PLUGINSDIR\shortcuts.ini" "Field 2" Type   "checkbox"
+  WriteINIStr "$PLUGINSDIR\shortcuts.ini" "Field 2" Text   "$(ICONS_DESKTOP)"
+  WriteINIStr "$PLUGINSDIR\shortcuts.ini" "Field 2" Left   "15"
+  WriteINIStr "$PLUGINSDIR\shortcuts.ini" "Field 2" Right  "-1"
+  WriteINIStr "$PLUGINSDIR\shortcuts.ini" "Field 2" Top    "20"
+  WriteINIStr "$PLUGINSDIR\shortcuts.ini" "Field 2" Bottom "30"
+  WriteINIStr "$PLUGINSDIR\shortcuts.ini" "Field 2" State  "1"
+  WriteINIStr "$PLUGINSDIR\shortcuts.ini" "Field 2" Flags  "GROUP"
+
+  WriteINIStr "$PLUGINSDIR\shortcuts.ini" "Field 3" Type   "checkbox"
+  WriteINIStr "$PLUGINSDIR\shortcuts.ini" "Field 3" Text   "$(ICONS_STARTMENU)"
+  WriteINIStr "$PLUGINSDIR\shortcuts.ini" "Field 3" Left   "15"
+  WriteINIStr "$PLUGINSDIR\shortcuts.ini" "Field 3" Right  "-1"
+  WriteINIStr "$PLUGINSDIR\shortcuts.ini" "Field 3" Top    "40"
+  WriteINIStr "$PLUGINSDIR\shortcuts.ini" "Field 3" Bottom "50"
+  WriteINIStr "$PLUGINSDIR\shortcuts.ini" "Field 3" State  "1"
+
+  WriteINIStr "$PLUGINSDIR\shortcuts.ini" "Field 4" Type   "checkbox"
+  WriteINIStr "$PLUGINSDIR\shortcuts.ini" "Field 4" Text   "$(ICONS_QUICKLAUNCH)"
+  WriteINIStr "$PLUGINSDIR\shortcuts.ini" "Field 4" Left   "15"
+  WriteINIStr "$PLUGINSDIR\shortcuts.ini" "Field 4" Right  "-1"
+  WriteINIStr "$PLUGINSDIR\shortcuts.ini" "Field 4" Top    "60"
+  WriteINIStr "$PLUGINSDIR\shortcuts.ini" "Field 4" Bottom "70"
+  WriteINIStr "$PLUGINSDIR\shortcuts.ini" "Field 4" State  "1"
 
   ; There must always be nonlocalized and localized directories.
   ${GetSize} "$EXEDIR\nonlocalized\" "/S=0K" $R5 $R7 $R8
   ${GetSize} "$EXEDIR\localized\" "/S=0K" $R6 $R7 $R8
   IntOp $R8 $R5 + $R6
   SectionSetSize ${APP_IDX} $R8
 
   ; Initialize $hHeaderBitmap to prevent redundant changing of the bitmap if
diff -r b7bcdd009540 browser/installer/windows/nsis/uninstaller.nsi
--- a/browser/installer/windows/nsis/uninstaller.nsi	Mon Sep 08 00:36:19 2008 -0700
+++ b/browser/installer/windows/nsis/uninstaller.nsi	Thu Sep 11 15:19:24 2008 +0300
@@ -152,17 +152,17 @@ ShowUnInstDetails nevershow
 /**
  * Uninstall Pages
  */
 ; Welcome Page
 !define MUI_PAGE_CUSTOMFUNCTION_PRE un.preWelcome
 !define MUI_PAGE_CUSTOMFUNCTION_LEAVE un.leaveWelcome
 !insertmacro MUI_UNPAGE_WELCOME
 
-; Uninstall Confirm Page
+; Custom Uninstall Confirm Page
 UninstPage custom un.preConfirm un.leaveConfirm
 
 ; Remove Files Page
 !insertmacro MUI_UNPAGE_INSTFILES
 
 ; Finish Page
 
 ; Don't setup the survey controls, functions, etc. when the application has
@@ -404,17 +404,77 @@ Function un.preConfirm
 Function un.preConfirm
   ${If} ${FileExists} "$INSTDIR\distribution\modern-header.bmp"
   ${AndIf} $hHeaderBitmap == ""
     Delete "$PLUGINSDIR\modern-header.bmp"
     CopyFiles /SILENT "$INSTDIR\distribution\modern-header.bmp" "$PLUGINSDIR\modern-header.bmp"
     ${un.ChangeMUIHeaderImage} "$PLUGINSDIR\modern-header.bmp"
   ${EndIf}
 
-  !insertmacro un.createUnConfirmINI
+  ; Setup the unconfirm.ini file for the Custom Uninstall Confirm Page
+  WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Settings" NumFields "5"
+
+  WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 1" Type   "label"
+  WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 1" Text   "$(UN_CONFIRM_UNINSTALLED_FROM)"
+  WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 1" Left   "0"
+  WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 1" Right  "-1"
+  WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 1" Top    "5"
+  WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 1" Bottom "15"
+
+  WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 2" Type   "text"
+  ; The contents of this control must be set as follows in the pre function
+  ; ${MUI_INSTALLOPTIONS_READ} $1 "unconfirm.ini" "Field 2" "HWND"
+  ; SendMessage $1 ${WM_SETTEXT} 0 "STR:$INSTDIR"
+  WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 2" State  ""
+  WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 2" Left   "0"
+  WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 2" Right  "-1"
+  WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 2" Top    "17"
+  WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 2" Bottom "30"
+  WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 2" flags  "READONLY"
+
+  WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 3" Type   "checkbox"
+  WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 3" Text   "$(UN_REMOVE_PROFILES)"
+  WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 3" Left   "0"
+  WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 3" Right  "-1"
+  WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 3" Top    "40"
+  WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 3" Bottom "50"
+  WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 3" State  "0"
+  WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 3" flags  "NOTIFY"
+
+  WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 4" Type   "text"
+  WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 4" State   "$(UN_REMOVE_PROFILES_DESC)"
+  WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 4" Left   "0"
+  WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 4" Right  "-1"
+  WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 4" Top    "52"
+  WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 4" Bottom "120"
+  WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 4" flags  "MULTILINE|READONLY"
+
+  WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 5" Type   "label"
+  WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 5" Text   "$(UN_CONFIRM_CLICK)"
+  WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 5" Left   "0"
+  WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 5" Right  "-1"
+  WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 5" Top    "130"
+  WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 5" Bottom "150"
+
+  ${If} "$TmpVal" == "true"
+    WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 6" Type   "label"
+    WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 6" Text   "$(SUMMARY_REBOOT_REQUIRED_UNINSTALL)"
+    WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 6" Left   "0"
+    WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 6" Right  "-1"
+    WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 6" Top    "35"
+    WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 6" Bottom "45"
+
+    WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Settings" NumFields "6"
+
+    ; To insert this control reset Top / Bottom for controls below this one
+    WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 3" Top    "55"
+    WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 3" Bottom "65"
+    WriteINIStr "$PLUGINSDIR\unconfirm.ini" "Field 4" Top    "67"
+  ${EndIf}
+
   !insertmacro MUI_HEADER_TEXT "$(UN_CONFIRM_PAGE_TITLE)" "$(UN_CONFIRM_PAGE_SUBTITLE)"
   ; The Summary custom page has a textbox that will automatically receive
   ; focus. This sets the focus to the Install button instead.
   !insertmacro MUI_INSTALLOPTIONS_INITDIALOG "unconfirm.ini"
   GetDlgItem $0 $HWNDPARENT 1
   ${MUI_INSTALLOPTIONS_READ} $1 "unconfirm.ini" "Field 4" "HWND"
   SetCtlColors $1 0x000000 0xFFFFEE
   ShowWindow $1 ${SW_HIDE}
diff -r b7bcdd009540 browser/locales/en-US/chrome/browser/aboutDialog.dtd
--- a/browser/locales/en-US/chrome/browser/aboutDialog.dtd	Mon Sep 08 00:36:19 2008 -0700
+++ b/browser/locales/en-US/chrome/browser/aboutDialog.dtd	Thu Sep 11 15:19:24 2008 +0300
@@ -1,9 +1,12 @@
-<!ENTITY aboutDialog.title      "About &brandFullName;">
-<!ENTITY copyright              "Credits">
-<!ENTITY copyright.accesskey    "C">
-<!ENTITY aboutLink              "&lt; About &brandFullName;">
-<!ENTITY aboutLink.accesskey    "A">
-<!ENTITY aboutVersion           "version">
-<!ENTITY copyrightInfo          "&#169;1998-2008 Contributors. All Rights Reserved. Firefox and the 
-                                 Firefox logos are trademarks of the Mozilla Foundation.  All rights 
-                                 reserved.">
+<!ENTITY aboutDialog.title          "About &brandFullName;">
+<!ENTITY copyright                  "Credits">
+<!ENTITY copyright.accesskey        "C">
+<!ENTITY copyrightGNOME.accesskey   "r">
+<!ENTITY aboutLink                  "&lt; About &brandFullName;">
+<!ENTITY aboutLink.accesskey        "A">
+<!ENTITY aboutVersion               "version">
+<!ENTITY closeCmdGNOME.label        "Close">  
+<!ENTITY closeCmdGNOME.accesskey    "C">
+<!ENTITY copyrightInfo              "&#169;1998-2008 Contributors. All Rights Reserved. Firefox and the 
+                                     Firefox logos are trademarks of the Mozilla Foundation.  All rights 
+                                     reserved.">
diff -r b7bcdd009540 browser/locales/en-US/installer/custom.properties
--- a/browser/locales/en-US/installer/custom.properties	Mon Sep 08 00:36:19 2008 -0700
+++ b/browser/locales/en-US/installer/custom.properties	Thu Sep 11 15:19:24 2008 +0300
@@ -63,17 +63,16 @@ SUMMARY_PAGE_SUBTITLE=Ready to start ins
 SUMMARY_PAGE_SUBTITLE=Ready to start installing $BrandShortName
 SUMMARY_INSTALLED_TO=$BrandShortName will be installed to the following location:
 SUMMARY_REBOOT_REQUIRED_INSTALL=A restart of your computer may be required to complete the installation.
 SUMMARY_REBOOT_REQUIRED_UNINSTALL=A restart of your computer may be required to complete the uninstall.
 SUMMARY_MAKE_DEFAULT=$BrandShortName will be set as your default web browser.
 SUMMARY_CLICK=Click Install to continue.
 SURVEY_TEXT=&Tell us what you thought of $BrandShortName
 LAUNCH_TEXT=&Launch $BrandShortName now
-WARN_APP_RUNNING_INSTALL=$BrandShortName must be closed to proceed with the installation.\n\nClick "OK" to exit $BrandShortName automatically and continue.
 CREATE_ICONS_DESC=Create icons for $BrandShortName:
 ICONS_DESKTOP=On my &Desktop
 ICONS_STARTMENU=In my &Start Menu Programs folder
 ICONS_QUICKLAUNCH=In my &Quick Launch bar
 WARN_MANUALLY_CLOSE_APP_INSTALL=$BrandShortName must be closed to proceed with the installation.\n\nPlease close $BrandShortName to continue.
 WARN_MANUALLY_CLOSE_APP_UNINSTALL=$BrandShortName must be closed to proceed with the uninstall.\n\nPlease close $BrandShortName to continue.
 WARN_MANUALLY_CLOSE_APP_LAUNCH=$BrandShortName is already running.\n\nPlease close $BrandShortName prior to launching the version you have just installed.
 WARN_WRITE_ACCESS=You don't have access to write to the installation directory.\n\nClick OK to select a different directory.
@@ -90,24 +89,20 @@ UN_CONFIRM_CLICK=Click Uninstall to cont
 UN_CONFIRM_CLICK=Click Uninstall to continue.
 UN_REMOVE_PROFILES=&Remove my $BrandShortName personal data and customizations
 UN_REMOVE_PROFILES_DESC=This will permanently remove your bookmarks, saved passwords, cookies and customizations. You may wish to keep this information if you plan on installing another version of $BrandShortName in the future.
 
 BANNER_CHECK_EXISTING=Checking existing installation
 
 STATUS_INSTALL_APP=Installing $BrandShortName
 STATUS_INSTALL_LANG=Installing Language Files (${AB_CD})
-STATUS_INSTALL_OPTIONAL=Installing Optional Components
 STATUS_UNINSTALL_MAIN=Uninstalling $BrandShortName
 STATUS_CLEANUP=A Little Housekeeping
 
 # _DESC strings support approximately 65 characters per line.
 # One line
 OPTIONS_SUMMARY=Choose the type of setup you prefer, then click Next.
 # One line
 OPTION_STANDARD_DESC=$BrandShortName will be installed with the most common options.
 OPTION_STANDARD_RADIO=&Standard
-# One line
-OPTION_COMPLETE_DESC=$BrandShortName will be installed with all available options.
-OPTION_COMPLETE_RADIO=C&omplete
 # Two lines
 OPTION_CUSTOM_DESC=You may choose individual options to be installed. Recommended for experienced users.
 OPTION_CUSTOM_RADIO=&Custom
diff -r b7bcdd009540 browser/locales/generic/chrome/inspector/contents.rdf
--- a/browser/locales/generic/chrome/inspector/contents.rdf	Mon Sep 08 00:36:19 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,27 +0,0 @@
-<?xml version="1.0"?>
-
-#filter substitution
-
-<RDF:RDF xmlns:RDF="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-         xmlns:chrome="http://www.mozilla.org/rdf/chrome#">
-
-  <!-- list all the locales being supplied by this package -->
-  <RDF:Seq about="urn:mozilla:locale:root">
-    <RDF:li resource="urn:mozilla:locale:@AB_CD@"/>
-  </RDF:Seq>
-
-  <!-- locale information -->
-  <RDF:Description about="urn:mozilla:locale:@AB_CD@">
-    <chrome:packages>
-      <RDF:Seq about="urn:mozilla:locale:@AB_CD@:packages">
-        <RDF:li resource="urn:mozilla:locale:@AB_CD@:inspector"/>
-      </RDF:Seq>
-    </chrome:packages>
-  </RDF:Description>
-
-  <!-- Version Information.  State that we work only with major version of this
-       package. -->
-  <RDF:Description about="urn:mozilla:locale:@AB_CD@:inspector"
-                   chrome:localeVersion="@MOZILLA_LOCALE_VERSION@" />
-
-</RDF:RDF>
diff -r b7bcdd009540 build/pgo/automation.py.in
--- a/build/pgo/automation.py.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/build/pgo/automation.py.in	Thu Sep 11 15:19:24 2008 +0300
@@ -302,16 +302,17 @@ user_pref("browser.shell.checkDefaultBro
 user_pref("browser.shell.checkDefaultBrowser", false);
 user_pref("shell.checkDefaultClient", false);
 user_pref("browser.warnOnQuit", false);
 user_pref("accessibility.typeaheadfind.autostart", false);
 user_pref("javascript.options.showInConsole", true);
 user_pref("layout.debug.enable_data_xbl", true);
 user_pref("browser.EULA.override", true);
 user_pref("javascript.options.jit.content", false);
+user_pref("gfx.color_management.force_srgb", true);
 
 user_pref("camino.warn_when_closing", false); // Camino-only, harmless to others
 """
   prefs.append(part)
 
   locations = readLocations()
 
   # Grant God-power to all the privileged servers on which tests run.
diff -r b7bcdd009540 config/autoconf.mk.in
--- a/config/autoconf.mk.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/config/autoconf.mk.in	Thu Sep 11 15:19:24 2008 +0300
@@ -156,17 +156,16 @@ MOZ_MORK = @MOZ_MORK@
 MOZ_MORK = @MOZ_MORK@
 MOZ_MORKREADER = @MOZ_MORKREADER@
 MOZ_NO_XPCOM_OBSOLETE = @MOZ_NO_XPCOM_OBSOLETE@
 MOZ_NO_FAST_LOAD = @MOZ_NO_FAST_LOAD@
 MOZ_OGG = @MOZ_OGG@
 MOZ_MEDIA = @MOZ_MEDIA@
 NS_PRINTING = @NS_PRINTING@
 MOZ_CRASHREPORTER = @MOZ_CRASHREPORTER@
-MOZ_MOCHITEST = @MOZ_MOCHITEST@
 MOZ_HELP_VIEWER = @MOZ_HELP_VIEWER@
 MOC= @MOC@
 
 MOZ_JAVAXPCOM = @MOZ_JAVAXPCOM@
 JAVA_INCLUDE_PATH="@JAVA_INCLUDE_PATH@"
 JAVA="@JAVA@"
 JAVAC="@JAVAC@"
 JAR="@JAR@"
@@ -612,19 +611,23 @@ MOZ_MAPINFO	= @MOZ_MAPINFO@
 
 MOZ_PHOENIX	= @MOZ_PHOENIX@
 MOZ_XULRUNNER	= @MOZ_XULRUNNER@
 MOZ_XUL_APP	= @MOZ_XUL_APP@
 WINCE		= @WINCE@
 
 MOZ_DISTRIBUTION_ID = @MOZ_DISTRIBUTION_ID@
 
-NS_HILDON	= @NS_HILDON@
 NS_OSSO 	= @NS_OSSO@
+MOZ_PLATFORM_HILDON = @MOZ_PLATFORM_HILDON@
 
+LIBHILDONMIME_CFLAGS	= @LIBHILDONMIME_CFLAGS@
+LIBHILDONMIME_LIBS	= @LIBHILDONMIME_LIBS@
+LIBOSSO_CFLAGS 	= @LIBOSSO_CFLAGS@
+LIBOSSO_LIBS 	= @LIBOSSO_LIBS@
 
 MACOS_SDK_DIR	= @MACOS_SDK_DIR@
 NEXT_ROOT	= @NEXT_ROOT@
 GCC_VERSION	= @GCC_VERSION@
 XCODEBUILD_VERSION= @XCODEBUILD_VERSION@
 HAS_XCODE_2_1	= @HAS_XCODE_2_1@
 UNIVERSAL_BINARY= @UNIVERSAL_BINARY@
 HAVE_DTRACE= @HAVE_DTRACE@
diff -r b7bcdd009540 config/chrome-versions.sh
--- a/config/chrome-versions.sh	Mon Sep 08 00:36:19 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,6 +0,0 @@
-# This is a shell script, sourced by configure.
-
-MOZILLA_LOCALE_VERSION=1.9a1
-MOZILLA_REGION_VERSION=1.9a1
-
-MOZILLA_SKIN_VERSION=1.8
diff -r b7bcdd009540 config/config.mk
--- a/config/config.mk	Mon Sep 08 00:36:19 2008 -0700
+++ b/config/config.mk	Thu Sep 11 15:19:24 2008 +0300
@@ -506,16 +506,17 @@ DEHYDRA_SCRIPT = $(topsrcdir)/xpcom/anal
 
 DEHYDRA_MODULES = \
   $(topsrcdir)/xpcom/analysis/final.js \
   $(NULL)
 
 TREEHYDRA_MODULES = \
   $(topsrcdir)/xpcom/analysis/outparams.js \
   $(topsrcdir)/xpcom/analysis/stack.js \
+  $(topsrcdir)/xpcom/analysis/flow.js \
   $(NULL)
 
 DEHYDRA_ARGS = \
   --topsrcdir=$(topsrcdir) \
   --objdir=$(DEPTH) \
   --dehydra-modules=$(subst $(NULL) ,$(COMMA),$(strip $(DEHYDRA_MODULES))) \
   --treehydra-modules=$(subst $(NULL) ,$(COMMA),$(strip $(TREEHYDRA_MODULES))) \
   $(NULL)
diff -r b7bcdd009540 configure.in
--- a/configure.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/configure.in	Thu Sep 11 15:19:24 2008 +0300
@@ -4352,17 +4352,16 @@ MOZ_IMG_ENCODERS_DEFAULT="png jpeg"
 MOZ_IMG_ENCODERS_DEFAULT="png jpeg"
 MOZ_IPCD=
 MOZ_JAVAXPCOM=
 MOZ_JSDEBUGGER=1
 MOZ_JSLOADER=1
 MOZ_LIBART_CFLAGS=
 MOZ_LIBART_LIBS=
 MOZ_MATHML=1
-MOZ_MOCHITEST=1
 MOZ_MORK=1
 MOZ_MORKREADER=
 MOZ_AUTH_EXTENSION=1
 MOZ_NO_ACTIVEX_SUPPORT=1
 MOZ_NO_INSPECTOR_APIS=
 MOZ_NO_XPCOM_OBSOLETE=
 MOZ_NO_FAST_LOAD=
 MOZ_OGG=1
@@ -5524,25 +5523,16 @@ MOZ_ARG_WITH_STRING(crashreporter-enable
 [ val=`echo $withval | sed 's/[^0-9]//g'`
     MOZ_CRASHREPORTER_ENABLE_PERCENT="$val"])
 
 if test -z "$MOZ_CRASHREPORTER_ENABLE_PERCENT"; then
    MOZ_CRASHREPORTER_ENABLE_PERCENT=100
 fi
 AC_DEFINE_UNQUOTED(MOZ_CRASHREPORTER_ENABLE_PERCENT, $MOZ_CRASHREPORTER_ENABLE_PERCENT)
 
-
-dnl ========================================================
-dnl = Build mochitest JS/DOM tests (on by default)
-dnl ========================================================
-MOZ_ARG_DISABLE_BOOL(mochitest,
-[  --disable-mochitest        Disable mochitest harness],
-    MOZ_MOCHITEST=,
-    MOZ_MOCHITEST=1 )
-
 dnl ========================================================
 dnl = Enable compilation of specific extension modules
 dnl ========================================================
 
 MOZ_ARG_ENABLE_STRING(extensions,
 [  --enable-extensions     Enable extensions],
 [ for option in `echo $enableval | sed 's/,/ /g'`; do
     if test "$option" = "yes" || test "$option" = "all"; then
@@ -6081,33 +6071,37 @@ if test `echo "$target_os" | grep -c \^s
     "$OS_TEST" != "sun4u"; then
     JS_ULTRASPARC_OPTS=
 fi
 AC_SUBST(JS_ULTRASPARC_OPTS)
 
 dnl ========================================================
 dnl = Hildon and OSSO checks
 dnl ========================================================
-PKG_CHECK_MODULES(LIBHILONMIME,libhildonmime,
-                  NS_HILDON=1,
-                  NS_HILDON=)
-if test $NS_HILDON; then
-   AC_DEFINE(NS_HILDON)
-fi
+PKG_CHECK_MODULES(LIBHILDONMIME,libhildonmime,
+                  MOZ_PLATFORM_HILDON=1,
+                  MOZ_PLATFORM_HILDON=)
+if test $MOZ_PLATFORM_HILDON; then
+   AC_DEFINE(MOZ_PLATFORM_HILDON)
+fi
+AC_SUBST(LIBHILDONMIME_CFLAGS)
+AC_SUBST(LIBHILDONMIME_LIBS)
 
 PKG_CHECK_MODULES(LIBOSSO,libosso,
                   NS_OSSO=1,
                   NS_OSSO=)
 
 if test $NS_OSSO; then
     if test -z "$MOZ_ENABLE_DBUS"; then
         AC_MSG_ERROR([DBus is required when building for OSSO])
     fi
     AC_DEFINE(NS_OSSO)     
 fi
+AC_SUBST(LIBOSSO_CFLAGS)
+AC_SUBST(LIBOSSO_LIBS)
 
 dnl ========================================================
 dnl =
 dnl = Feature options that require extra sources to be pulled
 dnl =
 dnl ========================================================
 dnl MOZ_ARG_HEADER(Features that require extra sources)
 
@@ -7155,16 +7149,20 @@ if test -n "$MOZ_DEBUG" -a "$MOZ_BUILD_A
 if test -n "$MOZ_DEBUG" -a "$MOZ_BUILD_APP" != "xulrunner"; then
    MOZ_ENABLE_LIBXUL=
 fi
 
 MOZ_ARG_ENABLE_BOOL(libxul,
 [  --enable-libxul         Enable building of libxul],
     MOZ_ENABLE_LIBXUL=1,
     MOZ_ENABLE_LIBXUL=)
+
+if test -n "$MOZ_STATIC_BUILD_UNSUPPORTED" -a -n "$BUILD_STATIC_LIBS"; then
+	AC_MSG_ERROR([--enable-static is not supported for building $MOZ_APP_NAME. You probably want --enable-libxul.])
+fi
 
 if test -n "$MOZ_ENABLE_LIBXUL" -a -n "$BUILD_STATIC_LIBS"; then
 	AC_MSG_ERROR([--enable-libxul is not compatible with --enable-static])
 fi
 
 if test -n "$MOZ_ENABLE_LIBXUL" -a -z "$MOZ_XUL_APP"; then
 	AC_MSG_ERROR([--enable-libxul is only compatible with toolkit XUL applications.])
 fi
@@ -7824,17 +7822,17 @@ AC_SUBST(IMPLIB)
 AC_SUBST(IMPLIB)
 AC_SUBST(FILTER)
 AC_SUBST(BIN_FLAGS)
 AC_SUBST(NS_USE_NATIVE)
 AC_SUBST(MOZ_WIDGET_TOOLKIT)
 AC_SUBST(MOZ_GFX_TOOLKIT)
 AC_SUBST(MOZ_UPDATE_XTERM)
 AC_SUBST(MINIMO)
-AC_SUBST(NS_HILDON)
+AC_SUBST(MOZ_PLATFORM_HILDON)
 AC_SUBST(NS_OSSO)
 AC_SUBST(MOZ_AUTH_EXTENSION)
 AC_SUBST(MOZ_MATHML)
 AC_SUBST(MOZ_PERMISSIONS)
 AC_SUBST(MOZ_XTF)
 AC_SUBST(MOZ_NO_INSPECTOR_APIS)
 AC_SUBST(MOZ_PREF_EXTENSIONS)
 AC_SUBST(MOZ_SVG)
@@ -7906,17 +7904,16 @@ AC_SUBST(MOZ_UNIVERSALCHARDET)
 AC_SUBST(MOZ_UNIVERSALCHARDET)
 AC_SUBST(ACCESSIBILITY)
 AC_SUBST(MOZ_XPINSTALL)
 AC_SUBST(MOZ_VIEW_SOURCE)
 AC_SUBST(MOZ_SPELLCHECK)
 AC_SUBST(MOZ_XPFE_COMPONENTS)
 AC_SUBST(MOZ_USER_DIR)
 AC_SUBST(MOZ_CRASHREPORTER)
-AC_SUBST(MOZ_MOCHITEST)
 
 AC_SUBST(ENABLE_STRIP)
 AC_SUBST(PKG_SKIP_STRIP)
 AC_SUBST(USE_ELF_DYNSTR_GC)
 AC_SUBST(USE_PREBINDING)
 AC_SUBST(INCREMENTAL_LINKER)
 AC_SUBST(MOZ_COMPONENTS_VERSION_SCRIPT_LDFLAGS)
 AC_SUBST(MOZ_COMPONENT_NSPR_LIBS)
@@ -8185,21 +8182,16 @@ cygwin*|msvc*|mks*)
     WIN_TOP_SRC=`cygpath -a -w $srcdir | sed -e 's|\\\\|/|g'`
     ;;
 esac
 
 AC_SUBST(CYGDRIVE_MOUNT)
 AC_SUBST(WIN_TOP_SRC)
 
 AC_SUBST(MOZILLA_VERSION)
-
-. ${srcdir}/config/chrome-versions.sh
-AC_DEFINE_UNQUOTED(MOZILLA_LOCALE_VERSION,"$MOZILLA_LOCALE_VERSION")
-AC_DEFINE_UNQUOTED(MOZILLA_REGION_VERSION,"$MOZILLA_REGION_VERSION")
-AC_DEFINE_UNQUOTED(MOZILLA_SKIN_VERSION,"$MOZILLA_SKIN_VERSION")
 
 AC_SUBST(ac_configure_args)
 
 dnl Spit out some output
 dnl ========================================================
 
 dnl The following defines are used by xpcom
 _NON_GLOBAL_ACDEFINES="$_NON_GLOBAL_ACDEFINES
diff -r b7bcdd009540 content/base/public/Makefile.in
--- a/content/base/public/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/base/public/Makefile.in	Thu Sep 11 15:19:24 2008 +0300
@@ -54,16 +54,17 @@ nsContentPolicyUtils.h \
 nsContentPolicyUtils.h \
 nsContentUtils.h \
 nsIDocument.h \
 nsIDocumentObserver.h \
 nsIMutationObserver.h \
 nsINameSpaceManager.h \
 nsINode.h \
 nsINodeInfo.h \
+nsINodeList.h \
 nsIRange.h \
 nsIRangeUtils.h \
 nsIScriptElement.h \
 nsIStyleSheetLinkingElement.h \
 nsIPrivateDOMImplementation.h \
 nsIContentSerializer.h \
 nsIHTMLToTextSink.h \
 nsIXPathEvaluatorInternal.h \
diff -r b7bcdd009540 content/base/public/nsContentUtils.h
--- a/content/base/public/nsContentUtils.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/base/public/nsContentUtils.h	Thu Sep 11 15:19:24 2008 +0300
@@ -660,19 +660,17 @@ public:
   static already_AddRefed<nsIImage> GetImageFromContent(nsIImageLoadingContent* aContent, imgIRequest **aRequest = nsnull);
 
   /**
    * Method that decides whether a content node is draggable
    *
    * @param aContent The content node to test.
    * @return whether it's draggable
    */
-  static PRBool ContentIsDraggable(nsIContent* aContent) {
-    return IsDraggableImage(aContent) || IsDraggableLink(aContent);
-  }
+  static PRBool ContentIsDraggable(nsIContent* aContent);
 
   /**
    * Method that decides whether a content node is a draggable image
    *
    * @param aContent The content node to test.
    * @return whether it's a draggable image
    */
   static PRBool IsDraggableImage(nsIContent* aContent);
diff -r b7bcdd009540 content/base/public/nsIContent.h
--- a/content/base/public/nsIContent.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/base/public/nsIContent.h	Thu Sep 11 15:19:24 2008 +0300
@@ -57,18 +57,18 @@ class nsRuleWalker;
 class nsRuleWalker;
 class nsAttrValue;
 class nsAttrName;
 class nsTextFragment;
 class nsIDocShell;
 
 // IID for the nsIContent interface
 #define NS_ICONTENT_IID       \
-{ 0x0acd0482, 0x09a2, 0x42fd, \
-  { 0xb6, 0x1b, 0x95, 0xa2, 0x01, 0x6a, 0x55, 0xd3 } }
+{ 0x2813b1d9, 0x7fe1, 0x496f, \
+ { 0x85, 0x52, 0xa2, 0xc1, 0xc5, 0x6b, 0x15, 0x40 } }
 
 /**
  * A node of content in a document's content model. This interface
  * is supported by all content objects.
  */
 class nsIContent : public nsINode {
 public:
 #ifdef MOZILLA_INTERNAL_API
@@ -779,20 +779,25 @@ public:
    * value of the null-namespace attribute whose name is given by
    * GetIDAttributeName().  This may be null if there is no ID.
    */
   virtual nsIAtom* GetID() const = 0;
 
   /**
    * Get the class list of this content node (this corresponds to the
    * value of the null-namespace attribute whose name is given by
-   * GetClassAttributeName().  This may be null if there are no
+   * GetClassAttributeName()).  This may be null if there are no
    * classes, but that's not guaranteed.
    */
-  virtual const nsAttrValue* GetClasses() const = 0;
+  const nsAttrValue* GetClasses() const {
+    if (HasFlag(NODE_MAY_HAVE_CLASS)) {
+      return DoGetClasses();
+    }
+    return nsnull;
+  }
 
   /**
    * Walk aRuleWalker over the content style rules (presentational
    * hint rules) for this content node.
    */
   NS_IMETHOD WalkContentStyleRules(nsRuleWalker* aRuleWalker) = 0;
 
   /**
@@ -844,16 +849,24 @@ public:
    */
   virtual void DestroyContent() = 0;
 
   /**
    * Saves the form state of this node and its children.
    */
   virtual void SaveSubtreeState() = 0;
 
+private:
+  /**
+   * Hook for implementing GetClasses.  This is guaranteed to only be
+   * called if the NODE_MAY_HAVE_CLASS flag is set.
+   */
+  virtual const nsAttrValue* DoGetClasses() const = 0;
+
+public:
 #ifdef DEBUG
   /**
    * List the content (and anything it contains) out to the given
    * file stream. Use aIndent as the base indent during formatting.
    */
   virtual void List(FILE* out = stdout, PRInt32 aIndent = 0) const = 0;
 
   /**
diff -r b7bcdd009540 content/base/public/nsINode.h
--- a/content/base/public/nsINode.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/base/public/nsINode.h	Thu Sep 11 15:19:24 2008 +0300
@@ -90,16 +90,18 @@ enum {
   // Whether a binding manager may have a pointer to this
   NODE_MAY_BE_IN_BINDING_MNGR =  0x00000080U,
 
   NODE_IS_EDITABLE =             0x00000100U,
 
   // Optimizations to quickly check whether element may have ID, class or style
   // attributes. Not all element implementations may use these!
   NODE_MAY_HAVE_ID =             0x00000200U,
+  // For all Element nodes, NODE_MAY_HAVE_CLASS is guaranteed to be set if the
+  // node in fact has a class, but may be set even if it doesn't.
   NODE_MAY_HAVE_CLASS =          0x00000400U,
   NODE_MAY_HAVE_STYLE =          0x00000800U,
 
   NODE_IS_INSERTION_PARENT =     0x00001000U,
 
   // Node has an :empty or :-moz-only-whitespace selector
   NODE_HAS_EMPTY_SELECTOR =      0x00002000U,
 
diff -r b7bcdd009540 content/base/public/nsINodeList.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/base/public/nsINodeList.h	Thu Sep 11 15:19:24 2008 +0300
@@ -0,0 +1,64 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is Mozilla.com.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *         Boris Zbarsky <bzbarsky@mit.edu> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsINodeList_h___
+#define nsINodeList_h___
+
+class nsINode;
+
+// IID for the nsINodeList interface
+#define NS_INODELIST_IID \
+{ 0x06a6639a, 0x2d47, 0x4551, \
+ { 0x94, 0xef, 0x93, 0xb8, 0xe1, 0x09, 0x3a, 0xb3 } }
+
+
+/**
+ * An internal interface that allows QI-less getting of nodes from node lists
+ */
+class nsINodeList : public nsISupports {
+public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_INODELIST_IID)
+
+  /**
+   * Get the node at the index.  Returns null if the index is out of bounds
+   */
+  virtual nsINode* GetNodeAt(PRUint32 aIndex) = 0;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsINodeList, NS_INODELIST_IID)
+
+#endif /* nsINodeList_h___ */
diff -r b7bcdd009540 content/base/src/nsContentAreaDragDrop.cpp
--- a/content/base/src/nsContentAreaDragDrop.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/base/src/nsContentAreaDragDrop.cpp	Thu Sep 11 15:19:24 2008 +0300
@@ -889,17 +889,20 @@ nsTransferableFactory::Produce(nsDOMData
 
   // check if the node is inside a form control. If so, dragging will be
   // handled in editor code (nsPlaintextDataTransfer::DoDrag). Don't set
   // aCanDrag to false however, as we still want to allow the drag.
   nsCOMPtr<nsIContent> findFormNode = mSelectionTargetNode;
   nsIContent* findFormParent = findFormNode->GetParent();
   while (findFormParent) {
     nsCOMPtr<nsIFormControl> form(do_QueryInterface(findFormParent));
-    if (form && form->GetType() != NS_FORM_OBJECT)
+    if (form && form->GetType() != NS_FORM_OBJECT &&
+                form->GetType() != NS_FORM_FIELDSET &&
+                form->GetType() != NS_FORM_LEGEND &&
+                form->GetType() != NS_FORM_LABEL)
       return NS_OK;
     findFormParent = findFormParent->GetParent();
   }
     
   // if set, serialize the content under this node
   nsCOMPtr<nsIContent> nodeToSerialize;
   *aDragSelection = PR_FALSE;
 
diff -r b7bcdd009540 content/base/src/nsContentList.cpp
--- a/content/base/src/nsContentList.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/base/src/nsContentList.cpp	Thu Sep 11 15:19:24 2008 +0300
@@ -83,16 +83,17 @@ NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(ns
   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMARRAY(mElements)
 NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsBaseContentList)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mElements)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 // QueryInterface implementation for nsBaseContentList
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsBaseContentList)
+  NS_INTERFACE_MAP_ENTRY(nsINodeList)
   NS_INTERFACE_MAP_ENTRY(nsIDOMNodeList)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMNodeList)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(NodeList)
 NS_INTERFACE_MAP_END
 
 
 NS_IMPL_CYCLE_COLLECTING_ADDREF(nsBaseContentList)
 NS_IMPL_CYCLE_COLLECTING_RELEASE(nsBaseContentList)
@@ -104,25 +105,31 @@ nsBaseContentList::GetLength(PRUint32* a
   *aLength = mElements.Count();
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsBaseContentList::Item(PRUint32 aIndex, nsIDOMNode** aReturn)
 {
-  nsISupports *tmp = mElements.SafeObjectAt(aIndex);
+  nsISupports *tmp = GetNodeAt(aIndex);
 
   if (!tmp) {
     *aReturn = nsnull;
 
     return NS_OK;
   }
 
   return CallQueryInterface(tmp, aReturn);
+}
+
+nsINode*
+nsBaseContentList::GetNodeAt(PRUint32 aIndex)
+{
+  return mElements.SafeObjectAt(aIndex);
 }
 
 void
 nsBaseContentList::AppendElement(nsIContent *aContent)
 {
   mElements.AppendObject(aContent);
 }
 
@@ -462,20 +469,20 @@ nsContentList::GetLength(PRUint32* aLeng
   *aLength = Length(PR_TRUE);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsContentList::Item(PRUint32 aIndex, nsIDOMNode** aReturn)
 {
-  nsIContent *content = Item(aIndex, PR_TRUE);
+  nsINode* node = GetNodeAt(aIndex);
 
-  if (content) {
-    return CallQueryInterface(content, aReturn);
+  if (node) {
+    return CallQueryInterface(node, aReturn);
   }
 
   *aReturn = nsnull;
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
@@ -485,16 +492,22 @@ nsContentList::NamedItem(const nsAString
 
   if (content) {
     return CallQueryInterface(content, aReturn);
   }
 
   *aReturn = nsnull;
 
   return NS_OK;
+}
+
+nsINode*
+nsContentList::GetNodeAt(PRUint32 aIndex)
+{
+  return Item(aIndex, PR_TRUE);
 }
 
 void
 nsContentList::AttributeChanged(nsIDocument *aDocument, nsIContent* aContent,
                                 PRInt32 aNameSpaceID, nsIAtom* aAttribute,
                                 PRInt32 aModType, PRUint32 aStateMask)
 {
   NS_PRECONDITION(aContent, "Must have a content node to work with");
diff -r b7bcdd009540 content/base/src/nsContentList.h
--- a/content/base/src/nsContentList.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/base/src/nsContentList.h	Thu Sep 11 15:19:24 2008 +0300
@@ -44,16 +44,17 @@
 #ifndef nsContentList_h___
 #define nsContentList_h___
 
 #include "nsISupports.h"
 #include "nsCOMArray.h"
 #include "nsString.h"
 #include "nsIDOMHTMLCollection.h"
 #include "nsIDOMNodeList.h"
+#include "nsINodeList.h"
 #include "nsStubMutationObserver.h"
 #include "nsIAtom.h"
 #include "nsINameSpaceManager.h"
 #include "nsCycleCollectionParticipant.h"
 
 // Magic namespace id that means "match all namespaces".  This is
 // negative so it won't collide with actual namespace constants.
 #define kNameSpaceID_Wildcard PR_INT32_MIN
@@ -68,27 +69,32 @@ typedef PRBool (*nsContentListMatchFunc)
                                          void* aData);
 
 typedef void (*nsContentListDestroyFunc)(void* aData);
 
 class nsIDocument;
 class nsIDOMHTMLFormElement;
 
 
-class nsBaseContentList : public nsIDOMNodeList
+class nsBaseContentList : public nsIDOMNodeList,
+                          public nsINodeList
 {
 public:
   nsBaseContentList();
   virtual ~nsBaseContentList();
 
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
 
   // nsIDOMNodeList
   NS_DECL_NSIDOMNODELIST
-  NS_DECL_CYCLE_COLLECTION_CLASS(nsBaseContentList)
+
+  // nsINodeList
+  virtual nsINode* GetNodeAt(PRUint32 aIndex);
+  
+  NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsBaseContentList, nsIDOMNodeList)
 
   void AppendElement(nsIContent *aContent);
   void RemoveElement(nsIContent *aContent);
   virtual PRInt32 IndexOf(nsIContent *aContent, PRBool aDoFlush);
   void Reset();
 
   static void Shutdown();
 
@@ -227,16 +233,18 @@ public:
                 PRBool aFuncMayDependOnAttr = PR_TRUE);
   virtual ~nsContentList();
 
   // nsIDOMHTMLCollection
   NS_DECL_NSIDOMHTMLCOLLECTION
 
   // nsBaseContentList overrides
   virtual PRInt32 IndexOf(nsIContent *aContent, PRBool aDoFlush);
+  virtual nsINode* GetNodeAt(PRUint32 aIndex);
+  
 
   // nsContentList public methods
   NS_HIDDEN_(nsISupports*) GetParentObject();
   NS_HIDDEN_(PRUint32) Length(PRBool aDoFlush);
   NS_HIDDEN_(nsIContent*) Item(PRUint32 aIndex, PRBool aDoFlush);
   NS_HIDDEN_(nsIContent*) NamedItem(const nsAString& aName, PRBool aDoFlush);
 
   nsContentListKey* GetKey() {
diff -r b7bcdd009540 content/base/src/nsContentUtils.cpp
--- a/content/base/src/nsContentUtils.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/base/src/nsContentUtils.cpp	Thu Sep 11 15:19:24 2008 +0300
@@ -84,16 +84,17 @@
 #include "nsIParserService.h"
 #include "nsIServiceManager.h"
 #include "nsIAttribute.h"
 #include "nsContentList.h"
 #include "nsIHTMLDocument.h"
 #include "nsIDOMHTMLDocument.h"
 #include "nsIDOMHTMLCollection.h"
 #include "nsIDOMHTMLFormElement.h"
+#include "nsIDOMNSHTMLElement.h"
 #include "nsIForm.h"
 #include "nsIFormControl.h"
 #include "nsGkAtoms.h"
 #include "nsISupportsPrimitives.h"
 #include "imgIDecoderObserver.h"
 #include "imgIRequest.h"
 #include "imgIContainer.h"
 #include "imgILoader.h"
@@ -2450,16 +2451,36 @@ nsContentUtils::GetImageFromContent(nsII
 
   nsIImage* image = nsnull;
   CallGetInterface(ir.get(), &image);
   return image;
 }
 
 // static
 PRBool
+nsContentUtils::ContentIsDraggable(nsIContent* aContent)
+{
+  nsCOMPtr<nsIDOMNSHTMLElement> htmlElement = do_QueryInterface(aContent);
+  if (htmlElement) {
+    PRBool draggable = PR_FALSE;
+    htmlElement->GetDraggable(&draggable);
+    if (draggable)
+      return PR_TRUE;
+
+    if (aContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::draggable,
+                              nsGkAtoms::_false, eIgnoreCase))
+      return PR_FALSE;
+  }
+
+  // special handling for content area image and link dragging
+  return IsDraggableImage(aContent) || IsDraggableLink(aContent);
+}
+
+// static
+PRBool
 nsContentUtils::IsDraggableImage(nsIContent* aContent)
 {
   NS_PRECONDITION(aContent, "Must have content node to test");
 
   nsCOMPtr<nsIImageLoadingContent> imageContent(do_QueryInterface(aContent));
   if (!imageContent) {
     return PR_FALSE;
   }
diff -r b7bcdd009540 content/base/src/nsDocument.cpp
--- a/content/base/src/nsDocument.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/base/src/nsDocument.cpp	Thu Sep 11 15:19:24 2008 +0300
@@ -296,19 +296,23 @@ nsIdentifierMapEntry::~nsIdentifierMapEn
   if (mNameContentList && mNameContentList != NAME_NOT_VALID) {
     NS_RELEASE(mNameContentList);
   }
 }
 
 void
 nsIdentifierMapEntry::Traverse(nsCycleCollectionTraversalCallback* aCallback)
 {
-  if (mNameContentList != NAME_NOT_VALID)
-    aCallback->NoteXPCOMChild(mNameContentList);
-
+  if (mNameContentList != NAME_NOT_VALID) {
+    NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*aCallback,
+                                       "mIdentifierMap mNameContentList");
+    aCallback->NoteXPCOMChild(static_cast<nsIDOMNodeList*>(mNameContentList));
+  }
+
+  NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*aCallback, "mIdentifierMap mDocAllList");
   aCallback->NoteXPCOMChild(static_cast<nsIDOMNodeList*>(mDocAllList));
 }
 
 void
 nsIdentifierMapEntry::SetInvalidName()
 {
   mNameContentList = NAME_NOT_VALID;
 }
@@ -1222,26 +1226,26 @@ BoxObjectTraverser(const void* key, nsPI
 }
 
 class LinkMapTraversalVisitor : public nsUint32ToContentHashEntry::Visitor
 {
 public:
   nsCycleCollectionTraversalCallback *mCb;
   virtual void Visit(nsIContent* aContent)
   {
+    NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*mCb, "mLinkMap entry");
     mCb->NoteXPCOMChild(aContent);
   }
 };
 
 PR_STATIC_CALLBACK(PLDHashOperator)
 LinkMapTraverser(nsUint32ToContentHashEntry* aEntry, void* userArg)
 {
   LinkMapTraversalVisitor visitor;
   visitor.mCb = static_cast<nsCycleCollectionTraversalCallback*>(userArg);
-  NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*visitor.mCb, "mLinkMap entry");
   aEntry->VisitContent(&visitor);
   return PL_DHASH_NEXT;
 }
 
 PR_STATIC_CALLBACK(PLDHashOperator)
 IdentifierMapEntryTraverse(nsIdentifierMapEntry *aEntry, void *aArg)
 {
   nsCycleCollectionTraversalCallback *cb =
diff -r b7bcdd009540 content/base/src/nsGenericDOMDataNode.cpp
--- a/content/base/src/nsGenericDOMDataNode.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/base/src/nsGenericDOMDataNode.cpp	Thu Sep 11 15:19:24 2008 +0300
@@ -1212,18 +1212,19 @@ nsGenericDOMDataNode::GetCurrentValueAto
 
 nsIAtom*
 nsGenericDOMDataNode::GetID() const
 {
   return nsnull;
 }
 
 const nsAttrValue*
-nsGenericDOMDataNode::GetClasses() const
+nsGenericDOMDataNode::DoGetClasses() const
 {
+  NS_NOTREACHED("Shouldn't ever be called");
   return nsnull;
 }
 
 NS_IMETHODIMP
 nsGenericDOMDataNode::WalkContentStyleRules(nsRuleWalker* aRuleWalker)
 {
   return NS_OK;
 }
diff -r b7bcdd009540 content/base/src/nsGenericDOMDataNode.h
--- a/content/base/src/nsGenericDOMDataNode.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/base/src/nsGenericDOMDataNode.h	Thu Sep 11 15:19:24 2008 +0300
@@ -243,17 +243,17 @@ public:
   virtual PRBool IsNodeOfType(PRUint32 aFlags) const;
 
   virtual already_AddRefed<nsIURI> GetBaseURI() const;
   virtual PRBool IsLink(nsIURI** aURI) const;
 
   virtual PRBool MayHaveFrame() const;
 
   virtual nsIAtom* GetID() const;
-  virtual const nsAttrValue* GetClasses() const;
+  virtual const nsAttrValue* DoGetClasses() const;
   NS_IMETHOD WalkContentStyleRules(nsRuleWalker* aRuleWalker);
   virtual nsICSSStyleRule* GetInlineStyleRule();
   NS_IMETHOD SetInlineStyleRule(nsICSSStyleRule* aStyleRule, PRBool aNotify);
   NS_IMETHOD_(PRBool) IsAttributeMapped(const nsIAtom* aAttribute) const;
   virtual nsChangeHint GetAttributeChangeHint(const nsIAtom* aAttribute,
                                               PRInt32 aModType) const;
   virtual nsIAtom *GetClassAttributeName() const;
 
diff -r b7bcdd009540 content/base/src/nsGenericDOMNodeList.cpp
--- a/content/base/src/nsGenericDOMNodeList.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/base/src/nsGenericDOMNodeList.cpp	Thu Sep 11 15:19:24 2008 +0300
@@ -53,14 +53,25 @@ nsGenericDOMNodeList::~nsGenericDOMNodeL
 
 
 NS_IMPL_ADDREF(nsGenericDOMNodeList)
 NS_IMPL_RELEASE(nsGenericDOMNodeList)
 
 
 // QueryInterface implementation for nsGenericDOMNodeList
 NS_INTERFACE_MAP_BEGIN(nsGenericDOMNodeList)
+  NS_INTERFACE_MAP_ENTRY(nsINodeList)
   NS_INTERFACE_MAP_ENTRY(nsIDOMNodeList)
-  NS_INTERFACE_MAP_ENTRY(nsISupports)
+  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMNodeList)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(NodeList)
 NS_INTERFACE_MAP_END
 
+NS_IMETHODIMP
+nsGenericDOMNodeList::Item(PRUint32 aIndex, nsIDOMNode** aReturn)
+{
+  nsINode* node = GetNodeAt(aIndex);
+  if (!node) {
+    *aReturn = nsnull;
+    return NS_OK;
+  }
 
+  return CallQueryInterface(node, aReturn);
+}
diff -r b7bcdd009540 content/base/src/nsGenericDOMNodeList.h
--- a/content/base/src/nsGenericDOMNodeList.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/base/src/nsGenericDOMNodeList.h	Thu Sep 11 15:19:24 2008 +0300
@@ -31,33 +31,42 @@
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 /*
- * A base class for simple DOM NodeLists which implements nsISupports
- * and expects subclasess to implement GetLength() and Item()
+ * A base class for simple DOM NodeLists which implements nsISupports and Item()
+ * and expects subclasess to implement GetLength() and GetNodeAt()
  */
+
+// XXXbz we don't use this for much... should we be using it more, or
+// just nix it?
 
 #ifndef nsGenericDOMNodeList_h__
 #define nsGenericDOMNodeList_h__
 
 #include "nsISupports.h"
 #include "nsIDOMNodeList.h"
+#include "nsINodeList.h"
 
-class nsGenericDOMNodeList : public nsIDOMNodeList 
+class nsGenericDOMNodeList : public nsIDOMNodeList,
+                             public nsINodeList
 {
 public:
   nsGenericDOMNodeList();
   virtual ~nsGenericDOMNodeList();
 
   NS_DECL_ISUPPORTS
 
+  NS_IMETHOD    Item(PRUint32 aIndex, nsIDOMNode** aReturn);
+
   // The following need to be defined in the subclass
   // nsIDOMNodeList interface
   NS_IMETHOD    GetLength(PRUint32* aLength)=0;
-  NS_IMETHOD    Item(PRUint32 aIndex, nsIDOMNode** aReturn)=0;
+
+  // nsINodeList interface
+  virtual nsINode* GetNodeAt(PRUint32 aIndex) = 0;
 };
 
 #endif // nsGenericDOMNodeList_h__
diff -r b7bcdd009540 content/base/src/nsGenericElement.cpp
--- a/content/base/src/nsGenericElement.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/base/src/nsGenericElement.cpp	Thu Sep 11 15:19:24 2008 +0300
@@ -464,29 +464,24 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsChildContentList::GetLength(PRUint32* aLength)
 {
   *aLength = mNode ? mNode->GetChildCount() : 0;
 
   return NS_OK;
 }
 
-NS_IMETHODIMP
-nsChildContentList::Item(PRUint32 aIndex, nsIDOMNode** aReturn)
+nsINode*
+nsChildContentList::GetNodeAt(PRUint32 aIndex)
 {
   if (mNode) {
-    nsIContent *content = mNode->GetChildAt(aIndex);
-    if (content) {
-      return CallQueryInterface(content, aReturn);
-    }
-  }
-
-  *aReturn = nsnull;
-
-  return NS_OK;
+    return mNode->GetChildAt(aIndex);
+  }
+
+  return nsnull;
 }
 
 //----------------------------------------------------------------------
 
 NS_IMPL_CYCLE_COLLECTION_1(nsNode3Tearoff, mContent)
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsNode3Tearoff)
   NS_INTERFACE_MAP_ENTRY(nsIDOM3Node)
@@ -1657,53 +1652,16 @@ nsNodeSelectorTearoff::QuerySelector(con
   return nsGenericElement::doQuerySelector(mContent, aSelector, aReturn);
 }
 
 NS_IMETHODIMP
 nsNodeSelectorTearoff::QuerySelectorAll(const nsAString& aSelector,
                                         nsIDOMNodeList **aReturn)
 {
   return nsGenericElement::doQuerySelectorAll(mContent, aSelector, aReturn);
-}
-
-//----------------------------------------------------------------------
-
-NS_IMPL_CYCLE_COLLECTION_CLASS(nsStaticContentList)
-NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsStaticContentList)
-NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mList)
-NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
-NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsStaticContentList)
-NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMARRAY(mList)
-NS_IMPL_CYCLE_COLLECTION_UNLINK_END
-
-NS_IMPL_CYCLE_COLLECTING_ADDREF(nsStaticContentList)
-NS_IMPL_CYCLE_COLLECTING_RELEASE(nsStaticContentList)
-NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsStaticContentList)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNodeList)
-  NS_INTERFACE_MAP_ENTRY(nsISupports)
-  NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(NodeList)
-NS_INTERFACE_MAP_END
-
-NS_IMETHODIMP
-nsStaticContentList::GetLength(PRUint32* aLength)
-{
-  *aLength = mList.Count();
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-nsStaticContentList::Item(PRUint32 aIndex, nsIDOMNode** aReturn)
-{
-  nsIContent* c = mList.SafeObjectAt(aIndex);
-  if (!c) {
-    *aReturn = nsnull;
-    return NS_OK;
-  }
-
-  return CallQueryInterface(c, aReturn);
 }
 
 //----------------------------------------------------------------------
 nsGenericElement::nsDOMSlots::nsDOMSlots(PtrBits aFlags)
   : nsINode::nsSlots(aFlags),
     mBindingParent(nsnull)
 {
 }
@@ -2953,18 +2911,19 @@ nsGenericElement::GetID() const
         return attrVal->GetAtomValue();
       }
     }
   }
   return nsnull;
 }
 
 const nsAttrValue*
-nsGenericElement::GetClasses() const
-{
+nsGenericElement::DoGetClasses() const
+{
+  NS_NOTREACHED("Shouldn't ever be called");
   return nsnull;
 }
 
 NS_IMETHODIMP
 nsGenericElement::WalkContentStyleRules(nsRuleWalker* aRuleWalker)
 {
   return NS_OK;
 }
@@ -5269,29 +5228,29 @@ nsGenericElement::doQuerySelector(nsINod
   return NS_OK;
 }
 
 PR_STATIC_CALLBACK(PRBool)
 AppendAllMatchingElements(nsIContent* aMatchingElement,
                           void* aClosure)
 {
   NS_PRECONDITION(aMatchingElement && aClosure, "How did that happen?");
-  static_cast<nsStaticContentList*>(aClosure)->AppendContent(aMatchingElement);
+  static_cast<nsBaseContentList*>(aClosure)->AppendElement(aMatchingElement);
   return PR_TRUE;
 }
 
 /* static */
 nsresult
 nsGenericElement::doQuerySelectorAll(nsINode* aRoot,
                                      const nsAString& aSelector,
                                      nsIDOMNodeList **aReturn)
 {
   NS_PRECONDITION(aReturn, "Null out param?");
 
-  nsStaticContentList* contentList = new nsStaticContentList();
+  nsBaseContentList* contentList = new nsBaseContentList();
   NS_ENSURE_TRUE(contentList, NS_ERROR_OUT_OF_MEMORY);
   NS_ADDREF(*aReturn = contentList);
   
   nsAutoPtr<nsCSSSelectorList> selectorList;
   nsPresContext* presContext;
   nsresult rv = ParseSelectorList(aRoot, aSelector,
                                   getter_Transfers(selectorList),
                                   &presContext);
diff -r b7bcdd009540 content/base/src/nsGenericElement.h
--- a/content/base/src/nsGenericElement.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/base/src/nsGenericElement.h	Thu Sep 11 15:19:24 2008 +0300
@@ -96,17 +96,20 @@ public:
   nsChildContentList(nsINode* aNode)
     : mNode(aNode)
   {
     MOZ_COUNT_CTOR(nsChildContentList);
   }
   virtual ~nsChildContentList();
 
   // nsIDOMNodeList interface
-  NS_DECL_NSIDOMNODELIST
+  NS_IMETHOD GetLength(PRUint32* aLength);
+
+  // nsINodeList interface
+  virtual nsINode* GetNodeAt(PRUint32 aIndex);  
   
   void DropReference()
   {
     mNode = nsnull;
   }
 
 private:
   // The node whose children make up the list (weak reference)
@@ -290,38 +293,16 @@ public:
 
 private:
   ~nsNodeSelectorTearoff() {}
 
 private:
   nsCOMPtr<nsIContent> mContent;
 };
 
-/**
- * A static NodeList class, which just holds a COMArray of nodes
- */
-class nsStaticContentList : public nsIDOMNodeList {
-public:
-  nsStaticContentList() {}
-
-  NS_DECL_CYCLE_COLLECTING_ISUPPORTS
-  NS_DECL_NSIDOMNODELIST
-
-  NS_DECL_CYCLE_COLLECTION_CLASS(nsStaticContentList)
-
-  PRBool AppendContent(nsIContent* aContent) {
-    return mList.AppendObject(aContent);
-  }
-
-private:
-  ~nsStaticContentList() {}
-  
-  nsCOMArray<nsIContent> mList;
-};
-
 // Forward declare to allow being a friend
 class nsNSElementTearoff;
 
 /**
  * A generic base class for DOM elements, implementing many nsIContent,
  * nsIDOMNode and nsIDOMElement methods.
  */
 class nsGenericElement : public nsIContent
@@ -431,17 +412,17 @@ public:
     List(out, aIndent, EmptyCString());
   }
   virtual void DumpContent(FILE* out, PRInt32 aIndent, PRBool aDumpAll) const;
   void List(FILE* out, PRInt32 aIndent, const nsCString& aPrefix) const;
   void ListAttributes(FILE* out) const;
 #endif
 
   virtual nsIAtom* GetID() const;
-  virtual const nsAttrValue* GetClasses() const;
+  virtual const nsAttrValue* DoGetClasses() const;
   NS_IMETHOD WalkContentStyleRules(nsRuleWalker* aRuleWalker);
   virtual nsICSSStyleRule* GetInlineStyleRule();
   NS_IMETHOD SetInlineStyleRule(nsICSSStyleRule* aStyleRule, PRBool aNotify);
   NS_IMETHOD_(PRBool)
     IsAttributeMapped(const nsIAtom* aAttribute) const;
   virtual nsChangeHint GetAttributeChangeHint(const nsIAtom* aAttribute, 
                                               PRInt32 aModType) const;
   /*
diff -r b7bcdd009540 content/base/src/nsGkAtomList.h
--- a/content/base/src/nsGkAtomList.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/base/src/nsGkAtomList.h	Thu Sep 11 15:19:24 2008 +0300
@@ -1601,24 +1601,26 @@ GK_ATOM(generatedContent, "GeneratedCont
 #ifdef MOZ_MATHML
 GK_ATOM(HTMLReflowMetricsProperty, "HTMLReflowMetricsProperty") // nsHTMLReflowMetrics*
 #endif
 GK_ATOM(IBSplitSpecialPrevSibling, "IBSplitSpecialPrevSibling")// nsIFrame*
 GK_ATOM(IBSplitSpecialSibling, "IBSplitSpecialSibling")    // nsIFrame*
 GK_ATOM(lineCursorProperty, "LineCursorProperty") // nsLineBox*
 GK_ATOM(rowCursorProperty, "RowCursorProperty") // nsTableRowGroupFrame::FrameCursorData*
 GK_ATOM(maxElementWidthProperty, "MaxElementWidthProperty")  // nscoord*
+GK_ATOM(outlineInnerRectProperty, "OutlineInnerRectProperty") // nsRect*
 GK_ATOM(outOfFlowDirtyRectProperty, "OutOfFlowDirtyRectProperty") // nsRect*
 GK_ATOM(overflowAreaProperty, "OverflowArea")              // nsRect*
 GK_ATOM(overflowProperty, "OverflowProperty")              // list of nsIFrame*
 GK_ATOM(overflowContainersProperty, "OverflowContainersProperty")             // nsFrameList*
 GK_ATOM(excessOverflowContainersProperty, "ExcessOverflowContainersProperty") // nsFrameList*
 GK_ATOM(overflowLinesProperty, "OverflowLinesProperty")    // list of nsLineBox*
 GK_ATOM(overflowOutOfFlowsProperty, "OverflowOutOfFlowsProperty")      // nsFrameList*
 GK_ATOM(overflowPlaceholdersProperty, "OverflowPlaceholdersProperty")  // nsFrameList*
+GK_ATOM(preEffectsBBoxProperty, "PreEffectsBBoxProperty") // nsRect*
 GK_ATOM(rowUnpaginatedHeightProperty, "RowUnpaginatedHeightProperty")  // nscoord*
 GK_ATOM(spaceManagerProperty, "SpaceManagerProperty")      // the space manager for a block
 GK_ATOM(tabWidthProperty, "TabWidthProperty")              // nsTArray<TabSetting>* array of tab widths
 GK_ATOM(tableBCProperty, "TableBCProperty")                // table border collapsing info (e.g. damage area, table border widths)
 GK_ATOM(usedMarginProperty, "UsedMarginProperty") // nsMargin*
 GK_ATOM(usedPaddingProperty, "UsedPaddingProperty") // nsMargin*
 GK_ATOM(viewProperty, "ViewProperty")                      
 
diff -r b7bcdd009540 content/base/src/nsObjectLoadingContent.cpp
--- a/content/base/src/nsObjectLoadingContent.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/base/src/nsObjectLoadingContent.cpp	Thu Sep 11 15:19:24 2008 +0300
@@ -158,41 +158,49 @@ nsAsyncInstantiateEvent::Run()
 }
 
 /**
  * A task for firing PluginNotFound and PluginBlocklisted DOM Events.
  */
 class nsPluginErrorEvent : public nsRunnable {
 public:
   nsCOMPtr<nsIContent> mContent;
-  PRBool mBlocklisted;
+  PluginSupportState mState;
 
-  nsPluginErrorEvent(nsIContent* aContent, PRBool aBlocklisted)
+  nsPluginErrorEvent(nsIContent* aContent, PluginSupportState aState)
     : mContent(aContent),
-      mBlocklisted(aBlocklisted)
+      mState(aState)
   {}
 
   ~nsPluginErrorEvent() {}
 
   NS_IMETHOD Run();
 };
 
 NS_IMETHODIMP
 nsPluginErrorEvent::Run()
 {
   LOG(("OBJLC []: Firing plugin not found event for content %p\n",
        mContent.get()));
-  if (mBlocklisted)
-    nsContentUtils::DispatchTrustedEvent(mContent->GetDocument(), mContent,
-                                         NS_LITERAL_STRING("PluginBlocklisted"),
-                                         PR_TRUE, PR_TRUE);
-  else
-    nsContentUtils::DispatchTrustedEvent(mContent->GetDocument(), mContent,
-                                         NS_LITERAL_STRING("PluginNotFound"),
-                                         PR_TRUE, PR_TRUE);
+  nsString type;
+  switch (mState) {
+    case ePluginUnsupported:
+      type = NS_LITERAL_STRING("PluginNotFound");
+      break;
+    case ePluginDisabled:
+      type = NS_LITERAL_STRING("PluginDisabled");
+      break;
+    case ePluginBlocklisted:
+      type = NS_LITERAL_STRING("PluginBlocklisted");
+      break;
+    default:
+      return NS_OK;
+  }
+  nsContentUtils::DispatchTrustedEvent(mContent->GetDocument(), mContent,
+                                       type, PR_TRUE, PR_TRUE);
 
   return NS_OK;
 }
 
 class AutoNotifier {
   public:
     AutoNotifier(nsObjectLoadingContent* aContent, PRBool aNotify) :
       mContent(aContent), mNotify(aNotify) {
@@ -227,38 +235,39 @@ class AutoNotifier {
 
 /**
  * A class that will automatically fall back if a |rv| variable has a failure
  * code when this class is destroyed. It does not notify.
  */
 class AutoFallback {
   public:
     AutoFallback(nsObjectLoadingContent* aContent, const nsresult* rv)
-      : mContent(aContent), mResult(rv), mTypeUnsupported(PR_FALSE) {}
+      : mContent(aContent), mResult(rv), mPluginState(ePluginOtherState) {}
     ~AutoFallback() {
       if (NS_FAILED(*mResult)) {
         LOG(("OBJLC [%p]: rv=%08x, falling back\n", mContent, *mResult));
         mContent->Fallback(PR_FALSE);
-        if (mTypeUnsupported) {
-          mContent->mTypeUnsupported = PR_TRUE;
+        if (mPluginState != ePluginOtherState) {
+          mContent->mPluginState = mPluginState;
         }
       }
     }
 
     /**
-     * This function can be called to indicate that, after falling back,
-     * mTypeUnsupported should be set to true.
+     * This should be set to something other than ePluginOtherState to indicate
+     * a specific failure that should be passed on.
      */
-    void TypeUnsupported() {
-      mTypeUnsupported = PR_TRUE;
-    }
+     void SetPluginState(PluginSupportState aState) {
+       NS_ASSERTION(aState != ePluginOtherState, "Should not be setting ePluginOtherState");
+       mPluginState = aState;
+     }
   private:
     nsObjectLoadingContent* mContent;
     const nsresult* mResult;
-    PRBool mTypeUnsupported;
+    PluginSupportState mPluginState;
 };
 
 /**
  * A class that automatically sets mInstantiating to false when it goes
  * out of scope.
  */
 class AutoSetInstantiatingToFalse {
   public:
@@ -335,17 +344,17 @@ IsPluginEnabledByExtension(nsIURI* uri, 
 
 nsObjectLoadingContent::nsObjectLoadingContent()
   : mPendingInstantiateEvent(nsnull)
   , mChannel(nsnull)
   , mType(eType_Loading)
   , mInstantiating(PR_FALSE)
   , mUserDisabled(PR_FALSE)
   , mSuppressed(PR_FALSE)
-  , mTypeUnsupported(PR_FALSE)
+  , mPluginState(ePluginOtherState)
 {
 }
 
 nsObjectLoadingContent::~nsObjectLoadingContent()
 {
   DestroyImageLoadingContent();
   if (mFrameLoader) {
     mFrameLoader->Destroy();
@@ -568,30 +577,26 @@ nsObjectLoadingContent::OnStartRequest(n
       }
 
       break;
     case eType_Loading:
       NS_NOTREACHED("Should not have a loading type here!");
     case eType_Null:
       LOG(("OBJLC [%p]: Unsupported type, falling back\n", this));
       // Need to fallback here (instead of using the case below), so that we can
-      // set mTypeUnsupported without it being overwritten. This is also why we
+      // set mPluginState without it being overwritten. This is also why we
       // return early.
       Fallback(PR_FALSE);
 
       PluginSupportState pluginState = GetPluginSupportState(thisContent,
                                                              mContentType);
       // Do nothing, but fire the plugin not found event if needed
-      if (pluginState == ePluginUnsupported ||
-          pluginState == ePluginBlocklisted) {
-        FirePluginError(thisContent, pluginState == ePluginBlocklisted);
-      }
-      if (pluginState != ePluginDisabled &&
-          pluginState != ePluginBlocklisted) {
-        mTypeUnsupported = PR_TRUE;
+      if (pluginState != ePluginOtherState) {
+        FirePluginError(thisContent, pluginState);
+        mPluginState = pluginState;
       }
       return NS_BINDING_ABORTED;
   }
 
   if (mFinalListener) {
     mType = newType;
     rv = mFinalListener->OnStartRequest(aRequest, aContext);
     if (NS_FAILED(rv)) {
@@ -887,18 +892,26 @@ nsObjectLoadingContent::ObjectState() co
     case eType_Null:
       if (mSuppressed)
         return NS_EVENT_STATE_SUPPRESSED;
       if (mUserDisabled)
         return NS_EVENT_STATE_USERDISABLED;
 
       // Otherwise, broken
       PRInt32 state = NS_EVENT_STATE_BROKEN;
-      if (mTypeUnsupported) {
-        state |= NS_EVENT_STATE_TYPE_UNSUPPORTED;
+      switch (mPluginState) {
+        case ePluginDisabled:
+          state |= NS_EVENT_STATE_HANDLER_DISABLED;
+          break;
+        case ePluginBlocklisted:
+          state |= NS_EVENT_STATE_HANDLER_BLOCKED;
+          break;
+        case ePluginUnsupported:
+          state |= NS_EVENT_STATE_TYPE_UNSUPPORTED;
+          break;
       }
       return state;
   };
   NS_NOTREACHED("unknown type?");
   // this return statement only exists to avoid a compile warning
   return 0;
 }
 
@@ -956,26 +969,21 @@ IsAboutBlank(nsIURI* aURI)
   return str.EqualsLiteral("about:blank");  
 }
 
 void
 nsObjectLoadingContent::UpdateFallbackState(nsIContent* aContent,
                                             AutoFallback& fallback,
                                             const nsCString& aTypeHint)
 {
-  PluginSupportState pluginState = GetPluginDisabledState(aTypeHint);
-  if (pluginState == ePluginUnsupported) {
-    // For unknown plugins notify the UI and allow the unknown plugin binding
-    // to attach.
-    FirePluginError(aContent, PR_FALSE);
-    fallback.TypeUnsupported();
-  }
-  else if (pluginState == ePluginBlocklisted) {
-    // For blocklisted plugins just send a notification to the UI.
-    FirePluginError(aContent, PR_TRUE);
+  // Notify the UI and update the fallback state
+  PluginSupportState state = GetPluginSupportState(aContent, aTypeHint);
+  if (state != ePluginOtherState) {
+    fallback.SetPluginState(state);
+    FirePluginError(aContent, state);
   }
 }
 
 nsresult
 nsObjectLoadingContent::LoadObject(nsIURI* aURI,
                                    PRBool aNotify,
                                    const nsCString& aTypeHint,
                                    PRBool aForceLoad)
@@ -1443,17 +1451,18 @@ nsObjectLoadingContent::UnloadContent()
 {
   // Don't notify in CancelImageRequests. We do it ourselves.
   CancelImageRequests(PR_FALSE);
   if (mFrameLoader) {
     mFrameLoader->Destroy();
     mFrameLoader = nsnull;
   }
   mType = eType_Null;
-  mUserDisabled = mSuppressed = mTypeUnsupported = PR_FALSE;
+  mUserDisabled = mSuppressed = PR_FALSE;
+  mPluginState = ePluginOtherState;
 }
 
 void
 nsObjectLoadingContent::NotifyStateChanged(ObjectType aOldType,
                                           PRInt32 aOldState,
                                           PRBool aSync)
 {
   LOG(("OBJLC [%p]: Notifying about state change: (%u, %x) -> (%u, %x) (sync=%i)\n",
@@ -1493,22 +1502,22 @@ nsObjectLoadingContent::NotifyStateChang
     while ((shell = iter.GetNextShell())) {
       shell->RecreateFramesFor(thisContent);
     }
   }
 }
 
 /* static */ void
 nsObjectLoadingContent::FirePluginError(nsIContent* thisContent,
-                                        PRBool blocklisted)
+                                        PluginSupportState state)
 {
   LOG(("OBJLC []: Dispatching nsPluginErrorEvent for content %p\n",
        thisContent));
 
-  nsCOMPtr<nsIRunnable> ev = new nsPluginErrorEvent(thisContent, blocklisted);
+  nsCOMPtr<nsIRunnable> ev = new nsPluginErrorEvent(thisContent, state);
   nsresult rv = NS_DispatchToCurrentThread(ev);
   if (NS_FAILED(rv)) {
     NS_WARNING("failed to dispatch nsPluginErrorEvent");
   }
 }
 
 nsObjectLoadingContent::ObjectType
 nsObjectLoadingContent::GetTypeOfContent(const nsCString& aMIMEType)
@@ -1761,17 +1770,17 @@ nsObjectLoadingContent::ShouldShowDefaul
 {
   if (nsContentUtils::GetBoolPref("plugin.default_plugin_disabled", PR_FALSE)) {
     return PR_FALSE;
   }
 
   return GetPluginSupportState(aContent, aContentType) == ePluginUnsupported;
 }
 
-/* static */ nsObjectLoadingContent::PluginSupportState
+/* static */ PluginSupportState
 nsObjectLoadingContent::GetPluginSupportState(nsIContent* aContent,
                                               const nsCString& aContentType)
 {
   if (!aContent->IsNodeOfType(nsINode::eHTML)) {
     return ePluginOtherState;
   }
 
   if (aContent->Tag() == nsGkAtoms::embed ||
@@ -1798,17 +1807,17 @@ nsObjectLoadingContent::GetPluginSupport
         nsStyleUtil::IsSignificantChild(child, PR_TRUE, PR_FALSE);
     }
   }
 
   return hasAlternateContent ? ePluginOtherState :
     GetPluginDisabledState(aContentType);
 }
 
-/* static */ nsObjectLoadingContent::PluginSupportState
+/* static */ PluginSupportState
 nsObjectLoadingContent::GetPluginDisabledState(const nsCString& aContentType)
 {
   nsCOMPtr<nsIPluginHost> host(do_GetService("@mozilla.org/plugin/host;1"));
   if (!host) {
     return ePluginUnsupported;
   }
   nsresult rv = host->IsPluginEnabledForType(aContentType.get());
   if (rv == NS_ERROR_PLUGIN_DISABLED)
diff -r b7bcdd009540 content/base/src/nsObjectLoadingContent.h
--- a/content/base/src/nsObjectLoadingContent.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/base/src/nsObjectLoadingContent.h	Thu Sep 11 15:19:24 2008 +0300
@@ -53,16 +53,25 @@
 #include "nsIObjectLoadingContent.h"
 #include "nsIRunnable.h"
 #include "nsIChannelClassifier.h"
 
 class nsAsyncInstantiateEvent;
 class AutoNotifier;
 class AutoFallback;
 class AutoSetInstantiatingToFalse;
+
+enum PluginSupportState {
+  ePluginUnsupported,  // The plugin is not supported (not installed, say)
+  ePluginDisabled,     // The plugin has been explicitly disabled by the
+                       // user.
+  ePluginBlocklisted,  // The plugin is blocklisted and disabled
+  ePluginOtherState    // Something else (e.g. not a plugin at all as far
+                       // as we can tell).
+};
 
 /**
  * INVARIANTS OF THIS CLASS
  * - mChannel is non-null between asyncOpen and onStopRequest (NOTE: Only needs
  *   to be valid until onStopRequest is called on mFinalListener, not
  *   necessarily until the channel calls onStopRequest on us)
  * - mChannel corresponds to the channel that gets passed to the
  *   nsIRequestObserver/nsIStreamListener methods
@@ -247,17 +256,17 @@ class nsObjectLoadingContent : public ns
      */
     void NotifyStateChanged(ObjectType aOldType, PRInt32 aOldState,
                             PRBool aSync);
 
     /**
      * Fires the "Plugin not found" event. This function doesn't do any checks
      * whether it should be fired, the caller should do that.
      */
-    static void FirePluginError(nsIContent* thisContent, PRBool blocklisted);
+    static void FirePluginError(nsIContent* thisContent, PluginSupportState state);
 
     ObjectType GetTypeOfContent(const nsCString& aMIMEType);
 
     /**
      * For a classid, returns the MIME type that can be used to instantiate
      * a plugin for this ID.
      *
      * @return NS_ERROR_NOT_AVAILABLE Unsupported class ID.
@@ -326,25 +335,16 @@ class nsObjectLoadingContent : public ns
 
     /**
      * Whether to treat this content as a plugin, even though we can't handle
      * the type. This function impl should match the checks in the plugin host.
      * aContentType is the MIME type we ended up with.
      */
     static PRBool ShouldShowDefaultPlugin(nsIContent* aContent,
                                           const nsCString& aContentType);
-
-    enum PluginSupportState {
-      ePluginUnsupported,  // The plugin is not supported (not installed, say)
-      ePluginDisabled,     // The plugin has been explicitly disabled by the
-                           // user.
-      ePluginBlocklisted,  // The plugin is blocklisted and disabled
-      ePluginOtherState    // Something else (e.g. not a plugin at all as far
-                           // as we can tell).
-    };
 
     /**
      * Get the plugin support state for the given content node and MIME type.
      * This is used for purposes of determining whether to fire PluginNotFound
      * events etc.  aContentType is the MIME type we ended up with.
      *
      * This should only be called if the type of this content is eType_Null.
      */
@@ -413,16 +413,16 @@ class nsObjectLoadingContent : public ns
     /**
      * Whether we are about to call instantiate on our frame. If we aren't,
      * SetFrame needs to asynchronously call Instantiate.
      */
     PRBool                      mInstantiating : 1;
     // Blocking status from content policy
     PRBool                      mUserDisabled  : 1;
     PRBool                      mSuppressed    : 1;
-    // Whether we fell back because of an unsupported type
-    PRBool                      mTypeUnsupported:1;
+    // A specific state that caused us to fallback
+    PluginSupportState          mPluginState;
 
     friend class nsAsyncInstantiateEvent;
 };
 
 
 #endif
diff -r b7bcdd009540 content/base/src/nsRange.cpp
--- a/content/base/src/nsRange.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/base/src/nsRange.cpp	Thu Sep 11 15:19:24 2008 +0300
@@ -1152,16 +1152,20 @@ static nsresult SplitDataNode(nsIDOMChar
   rv = dataNode->SplitData(aStartIndex, getter_AddRefs(newData),
                            aCloneAfterOriginal);
   NS_ENSURE_SUCCESS(rv, rv);
   return CallQueryInterface(newData, aMiddleNode);
 }
 
 nsresult nsRange::CutContents(nsIDOMDocumentFragment** aFragment)
 { 
+  if (aFragment) {
+    *aFragment = nsnull;
+  }
+
   if (IsDetached())
     return NS_ERROR_DOM_INVALID_STATE_ERR;
 
   nsresult rv;
 
   nsCOMPtr<nsIDocument> doc =
     do_QueryInterface(mStartParent->GetOwnerDoc());
   if (!doc) return NS_ERROR_UNEXPECTED;
@@ -1191,17 +1195,21 @@ nsresult nsRange::CutContents(nsIDOMDocu
   RangeSubtreeIterator iter;
 
   rv = iter.Init(this);
   if (NS_FAILED(rv)) return rv;
 
   if (iter.IsDone())
   {
     // There's nothing for us to delete.
-    return CollapseRangeAfterDelete(this);
+    rv = CollapseRangeAfterDelete(this);
+    if (NS_SUCCEEDED(rv) && aFragment) {
+      NS_ADDREF(*aFragment = retval);
+    }
+    return rv;
   }
 
   // We delete backwards to avoid iterator problems!
 
   iter.Last();
   nsCOMPtr<nsIDOMNode> lastFragmentNode = nsnull;
 
   PRBool handled = PR_FALSE;
@@ -1350,21 +1358,21 @@ nsresult nsRange::CutContents(nsIDOMDocu
   // XXX_kin: and to use Normalize() to do the merging, but
   // XXX_kin: calling Normalize() on the common parent to accomplish
   // XXX_kin: this might also normalize nodes that are outside the
   // XXX_kin: range but under the common parent. Need to verify
   // XXX_kin: with the range commitee members that this was the
   // XXX_kin: desired behavior. For now we don't merge anything!
   // XXX ajvincent Filed as https://bugzilla.mozilla.org/show_bug.cgi?id=401276
 
-  if (aFragment) {
+  rv = CollapseRangeAfterDelete(this);
+  if (NS_SUCCEEDED(rv) && aFragment) {
     NS_ADDREF(*aFragment = retval);
   }
-
-  return CollapseRangeAfterDelete(this);
+  return rv;
 }
 
 nsresult nsRange::DeleteContents()
 {
   return CutContents(nsnull);
 }
 
 nsresult nsRange::ExtractContents(nsIDOMDocumentFragment** aReturn)
diff -r b7bcdd009540 content/base/src/nsScriptLoader.cpp
--- a/content/base/src/nsScriptLoader.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/base/src/nsScriptLoader.cpp	Thu Sep 11 15:19:24 2008 +0300
@@ -859,18 +859,16 @@ nsScriptLoader::PrepareLoadedRequest(nsS
   nsCOMPtr<nsIChannel> channel = do_QueryInterface(req);
   if (aStringLen) {
     // Check the charset attribute to determine script charset.
     nsAutoString hintCharset;
     aRequest->mElement->GetScriptCharset(hintCharset);
     rv = ConvertToUTF16(channel, aString, aStringLen, hintCharset, mDocument,
                         aRequest->mScriptText);
 
-    NS_ASSERTION(NS_SUCCEEDED(rv),
-                 "Could not convert external JavaScript to Unicode!");
     NS_ENSURE_SUCCESS(rv, rv);
 
     if (!ShouldExecuteScript(mDocument, channel)) {
       return NS_ERROR_NOT_AVAILABLE;
     }
   }
 
   // This assertion could fire errorously if we ran out of memory when
diff -r b7bcdd009540 content/base/src/nsStyledElement.cpp
--- a/content/base/src/nsStyledElement.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/base/src/nsStyledElement.cpp	Thu Sep 11 15:19:24 2008 +0300
@@ -66,21 +66,19 @@ nsStyledElement::GetClassAttributeName()
 
 nsIAtom*
 nsStyledElement::GetIDAttributeName() const
 {
   return nsGkAtoms::id;
 }
 
 const nsAttrValue*
-nsStyledElement::GetClasses() const
+nsStyledElement::DoGetClasses() const
 {
-  if (!HasFlag(NODE_MAY_HAVE_CLASS)) {
-    return nsnull;
-  }
+  NS_ASSERTION(HasFlag(NODE_MAY_HAVE_CLASS), "Unexpected call");
   return mAttrsAndChildren.GetAttr(nsGkAtoms::_class);
 }
 
 PRBool
 nsStyledElement::ParseAttribute(PRInt32 aNamespaceID, nsIAtom* aAttribute,
                                 const nsAString& aValue, nsAttrValue& aResult)
 {
   if (aNamespaceID == kNameSpaceID_None) {
diff -r b7bcdd009540 content/base/src/nsStyledElement.h
--- a/content/base/src/nsStyledElement.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/base/src/nsStyledElement.h	Thu Sep 11 15:19:24 2008 +0300
@@ -62,17 +62,17 @@ protected:
     : nsStyledElementBase(aNodeInfo)
   {}
 
 public:
 
   // nsIContent interface methods for styling
   virtual nsIAtom* GetClassAttributeName() const;
   virtual nsIAtom* GetIDAttributeName() const;
-  virtual const nsAttrValue* GetClasses() const;
+  virtual const nsAttrValue* DoGetClasses() const;
 
   virtual nsICSSStyleRule* GetInlineStyleRule();
   NS_IMETHOD SetInlineStyleRule(nsICSSStyleRule* aStyleRule, PRBool aNotify);
 
   virtual nsresult BindToTree(nsIDocument* aDocument, nsIContent* aParent,
                               nsIContent* aBindingParent,
                               PRBool aCompileEventHandlers);
 
diff -r b7bcdd009540 content/base/src/nsTextFragment.cpp
--- a/content/base/src/nsTextFragment.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/base/src/nsTextFragment.cpp	Thu Sep 11 15:19:24 2008 +0300
@@ -43,16 +43,17 @@
 
 #include "nsTextFragment.h"
 #include "nsString.h"
 #include "nsCRT.h"
 #include "nsReadableUtils.h"
 #include "nsMemory.h"
 #include "nsBidiUtils.h"
 #include "nsUnicharUtils.h"
+#include "nsUTF8Utils.h"
 
 #define TEXTFRAG_WHITE_AFTER_NEWLINE 50
 #define TEXTFRAG_MAX_NEWLINES 7
 
 // Static buffer used for common fragments
 static char* sSpaceSharedString[TEXTFRAG_MAX_NEWLINES + 1];
 static char* sTabSharedString[TEXTFRAG_MAX_NEWLINES + 1];
 static char sSingleCharSharedString[256];
@@ -221,19 +222,20 @@ nsTextFragment::SetTo(const PRUnichar* a
   } else {
     // Use 1 byte storage because we can
     char* buff = (char *)nsMemory::Alloc(aLength * sizeof(char));
     if (!buff) {
       return;
     }
 
     // Copy data
-    for (PRUint32 i = 0; i < (PRUint32)aLength; ++i) {
-      buff[i] = (char)aBuffer[i];
-    }
+    // Use the same copying code we use elsewhere; it's likely to be
+    // carefully tuned.
+    LossyConvertEncoding<PRUnichar, char> converter(buff);
+    copy_string(aBuffer, aBuffer+aLength, converter);
     m1b = buff;
   }
 
   // Setup our fields
   mState.mInHeap = PR_TRUE;
   mState.mIs2b = need2;
   mState.mLength = aLength;
 }
diff -r b7bcdd009540 content/base/src/nsXMLHttpRequest.cpp
--- a/content/base/src/nsXMLHttpRequest.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/base/src/nsXMLHttpRequest.cpp	Thu Sep 11 15:19:24 2008 +0300
@@ -116,16 +116,19 @@
 #define XML_HTTP_REQUEST_PARSEBODY      (1 << 9)  // Internal
 #define XML_HTTP_REQUEST_XSITEENABLED   (1 << 10) // Internal, Is any cross-site request allowed?
                                                   //           Even if this is false the
                                                   //           access-control spec is supported
 #define XML_HTTP_REQUEST_SYNCLOOPING    (1 << 11) // Internal
 #define XML_HTTP_REQUEST_MULTIPART      (1 << 12) // Internal
 #define XML_HTTP_REQUEST_GOT_FINAL_STOP (1 << 13) // Internal
 #define XML_HTTP_REQUEST_BACKGROUND     (1 << 14) // Internal
+// This is set when we've got the headers for a multipart XMLHttpRequest,
+// but haven't yet started to process the first part.
+#define XML_HTTP_REQUEST_MPART_HEADERS  (1 << 15) // Internal
 
 #define XML_HTTP_REQUEST_LOADSTATES         \
   (XML_HTTP_REQUEST_UNINITIALIZED |         \
    XML_HTTP_REQUEST_OPENED |                \
    XML_HTTP_REQUEST_LOADED |                \
    XML_HTTP_REQUEST_INTERACTIVE |           \
    XML_HTTP_REQUEST_COMPLETED |             \
    XML_HTTP_REQUEST_SENT |                  \
@@ -222,31 +225,38 @@ nsMultipartProxyListener::OnStartRequest
   if (!contentType.EqualsLiteral("multipart/x-mixed-replace")) {
     return NS_ERROR_INVALID_ARG;
   }
 
   // If multipart/x-mixed-replace content, we'll insert a MIME
   // decoder in the pipeline to handle the content and pass it along
   // to our original listener.
 
+  nsCOMPtr<nsIXMLHttpRequest> xhr = do_QueryInterface(mDestListener);
+
   nsCOMPtr<nsIStreamConverterService> convServ =
     do_GetService("@mozilla.org/streamConverters;1", &rv);
   if (NS_SUCCEEDED(rv)) {
     nsCOMPtr<nsIStreamListener> toListener(mDestListener);
     nsCOMPtr<nsIStreamListener> fromListener;
 
     rv = convServ->AsyncConvertData("multipart/x-mixed-replace",
                                     "*/*",
                                     toListener,
                                     nsnull,
                                     getter_AddRefs(fromListener));
     NS_ENSURE_TRUE(NS_SUCCEEDED(rv) && fromListener, NS_ERROR_UNEXPECTED);
 
     mDestListener = fromListener;
   }
+
+  if (xhr) {
+    static_cast<nsXMLHttpRequest*>(xhr.get())->mState |=
+      XML_HTTP_REQUEST_MPART_HEADERS;
+   }
 
   return mDestListener->OnStartRequest(aRequest, ctxt);
 }
 
 NS_IMETHODIMP
 nsMultipartProxyListener::OnStopRequest(nsIRequest *aRequest,
                                         nsISupports *ctxt,
                                         nsresult status)
@@ -1310,16 +1320,18 @@ nsXMLHttpRequest::OpenRequest(const nsAC
   }
 
   if (async) {
     mState |= XML_HTTP_REQUEST_ASYNC;
   } else {
     mState &= ~XML_HTTP_REQUEST_ASYNC;
   }
 
+  mState &= ~XML_HTTP_REQUEST_MPART_HEADERS;
+
   rv = NS_NewURI(getter_AddRefs(uri), url, nsnull, GetBaseURI());
   if (NS_FAILED(rv)) return rv;
 
   // mScriptContext should be initialized because of GetBaseURI() above.
   // Still need to consider the case that doc is nsnull however.
   rv = CheckInnerWindowCorrectness();
   NS_ENSURE_SUCCESS(rv, rv);
   nsCOMPtr<nsIDocument> doc = GetDocumentFromScriptContext(mScriptContext);
@@ -1581,16 +1593,17 @@ nsXMLHttpRequest::OnStartRequest(nsIRequ
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   channel->SetOwner(documentPrincipal);
 
   mReadRequest = request;
   mContext = ctxt;
   mState |= XML_HTTP_REQUEST_PARSEBODY;
+  mState &= ~XML_HTTP_REQUEST_MPART_HEADERS;
   ChangeState(XML_HTTP_REQUEST_LOADED);
 
   nsIURI* uri = GetBaseURI();
 
   // Create an empty document from it.  Here we have to cheat a little bit...
   // Setting the base URI to |uri| won't work if the document has a null
   // principal, so use mPrincipal when creating the document, then reset the
   // principal.
@@ -2436,16 +2449,23 @@ nsXMLHttpRequest::OnChannelRedirect(nsIC
 
 /////////////////////////////////////////////////////
 // nsIProgressEventSink methods:
 //
 
 NS_IMETHODIMP
 nsXMLHttpRequest::OnProgress(nsIRequest *aRequest, nsISupports *aContext, PRUint64 aProgress, PRUint64 aProgressMax)
 {
+  // We're in middle of processing multipart headers and we don't want to report
+  // any progress because upload's 'load' is dispatched when we start to load
+  // the first response.
+  if (XML_HTTP_REQUEST_MPART_HEADERS & mState) {
+    return NS_OK;
+  }
+
   // We're uploading if our state is XML_HTTP_REQUEST_OPENED or
   // XML_HTTP_REQUEST_SENT
   PRBool upload = !!((XML_HTTP_REQUEST_OPENED | XML_HTTP_REQUEST_SENT) & mState);
   PRUint64 loaded = aProgress;
   PRUint64 total = aProgressMax;
   // When uploading, OnProgress reports also headers in aProgress and aProgressMax.
   // So, try to remove the headers, if possible.
   PRBool lengthComputable = (aProgressMax != LL_MAXUINT);
diff -r b7bcdd009540 content/base/src/nsXMLHttpRequest.h
--- a/content/base/src/nsXMLHttpRequest.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/base/src/nsXMLHttpRequest.h	Thu Sep 11 15:19:24 2008 +0300
@@ -249,16 +249,18 @@ public:
 
   // This is called by the factory constructor.
   nsresult Init();
 
   NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(nsXMLHttpRequest,
                                            nsXHREventTarget)
 
 protected:
+  friend class nsMultipartProxyListener;
+
   nsresult DetectCharset(nsACString& aCharset);
   nsresult ConvertBodyToText(nsAString& aOutBuffer);
   static NS_METHOD StreamReaderFunc(nsIInputStream* in,
                 void* closure,
                 const char* fromRawSegment,
                 PRUint32 toOffset,
                 PRUint32 count,
                 PRUint32 *writeCount);
diff -r b7bcdd009540 content/base/test/Makefile.in
--- a/content/base/test/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/base/test/Makefile.in	Thu Sep 11 15:19:24 2008 +0300
@@ -181,33 +181,39 @@ _TEST_FILES = 	test_bug5141.html \
 		file_XHR_fail1.txt \
 		file_XHR_fail1.txt^headers^ \
 		test_bug428847.html \
 		file_bug428847-1.xhtml \
 		file_bug428847-2.xhtml \
 		test_bug425201.html \
 		test_bug431701.html \
 		test_bug431833.html \
-# bug 451664
-#		test_bug435425.html \
-#		bug435425.sjs \
-#		bug435425_redirect.sjs \
+		test_bug435425.html \
+		bug435425.sjs \
+		bug435425_redirect.sjs \
 		test_bug438519.html \
 		test_bug444722.html \
 		test_bug451376.html \
 		test_text_replaceWholeText.html \
 		test_text_wholeText.html \
 		wholeTexty-helper.xml \
 		test_bug444030.xhtml \
 		test_NodeIterator_basics_filters.xhtml \
 		test_NodeIterator_mutations_1.xhtml \
 		test_NodeIterator_mutations_2.html \
 		test_bug28293.html \
 		file_bug28293.sjs \
+		test_bug445225.html \
+		file_bug445225_multipart.txt \
+		file_bug445225_multipart.txt^headers^ \
 		test_title.html \
+		test_bug453521.html \
+		test_bug391728.html \
+		file_bug391728.html \
+		file_bug391728_2.html \
 		$(NULL)
 
 libs:: $(_TEST_FILES)
 	$(INSTALL) $(foreach f,$^,"$f") $(DEPTH)/_tests/testing/mochitest/tests/$(relativesrcdir)
 
 check::
 	@$(EXIT_ON_ERROR) \
 	for f in $(subst .cpp,,$(CPP_UNIT_TESTS)); do \
diff -r b7bcdd009540 content/base/test/bug435425.sjs
--- a/content/base/test/bug435425.sjs	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/base/test/bug435425.sjs	Thu Sep 11 15:19:24 2008 +0300
@@ -1,6 +1,12 @@ function handleRequest(request, response
 function handleRequest(request, response)
 {
   response.setHeader("Content-Type", "text/plain", false);
-  response.write(request.queryString);
+  if (request.method == "GET") {
+    response.write(request.queryString);
+  } else {
+    var rawdata = request.body.purge();
+    var data = String.fromCharCode.apply(null, rawdata);
+    response.write(data);
+  }
 }
 
diff -r b7bcdd009540 content/base/test/file_bug391728.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/base/test/file_bug391728.html	Thu Sep 11 15:19:24 2008 +0300
@@ -0,0 +1,100 @@
+<html>
+<head>
+<style type="text/css">
+embed,object {
+  border: 1px solid black;
+}
+
+embed:-moz-handler-disabled,
+object:-moz-handler-disabled {
+  border-style: dotted !important;
+}
+
+embed:-moz-handler-blocked,
+object:-moz-handler-blocked {
+  border-style: dashed !important;
+}
+
+embed:-moz-type-unsupported,
+object:-moz-type-unsupported {
+  border-style: none !important;
+}
+</style>
+<script type="text/javascript">
+function unknown_plugin_detected(event) {
+  window.parent.unknown_plugin_detected(event);
+}
+
+function blocked_plugin_detected(event) {
+  window.parent.blocked_plugin_detected(event);
+}
+
+function disabled_plugin_detected(event) {
+  window.parent.disabled_plugin_detected(event);
+}
+
+document.addEventListener("PluginNotFound", unknown_plugin_detected, true);
+document.addEventListener("PluginDisabled", disabled_plugin_detected, true);
+document.addEventListener("PluginBlocklisted", blocked_plugin_detected, true);
+</script>
+</head>
+<body>
+<!-- Embeds always fire events and have the pseudo class attached -->
+<div><embed id="plugin1" style="width: 100px; height: 100px" type="application/x-test"></div>
+<div><embed id="plugin2" style="width: 100px; height: 100px" src="data:application/x-test,test"></div>
+
+<!-- So do objects with no content and no pluginurl -->
+<div><object id="plugin3" style="width: 100px; height: 100px" type="application/x-test"></object></div>
+<div><object id="plugin4" style="width: 100px; height: 100px" data="data:application/x-test,test"></object></div>
+
+<!-- The mimetype of the actual data is supposed to be used in preference -->
+<div><embed id="plugin5" style="width: 100px; height: 100px" type="application/x-unknown" src="data:application/x-test,test"></div>
+<div><object id="plugin6" style="width: 100px; height: 100px" type="application/x-unknown" data="data:application/x-test,test"></object></div>
+
+<!-- Params are not considered content -->
+<div><object id="plugin7" style="width: 100px; height: 100px" type="application/x-test">
+  <param name="foo" value="bar">
+</object></div>
+<div><object id="plugin8" style="width: 100px; height: 100px" data="data:application/x-test,test">
+  <param name="foo" value="bar">
+</object></div>
+
+<!-- Nor is whitespace -->
+<div><object id="plugin9" style="width: 100px; height: 100px" type="application/x-test">
+
+  
+</object></div>
+<div><object id="plugin10" style="width: 100px; height: 100px" data="data:application/x-test,test">
+
+  
+</object></div>
+
+<!-- Pluginurl forces the psuedo class and error event regardless of content -->
+<div><object id="plugin11" style="width: 100px; height: 100px" type="application/x-test">
+  <param name="pluginurl" value="http://foo">
+  <p>Fallback content</p>
+</object></div>
+<div><object id="plugin12" style="width: 100px; height: 100px" data="data:application/x-test,test">
+  <param name="pluginurl" value="http://foo">
+  <p>Fallback content</p>
+</object></div>
+
+<!-- No errors or psuedo classes for objects with fallback content -->
+<div><object id="fallback1" style="width: 100px; height: 100px" type="application/x-test">
+  <p>Fallback content</p>
+</object></div>
+<div><object id="fallback2" style="width: 100px; height: 100px" data="data:application/x-test,test">
+  <p>Fallback content</p>
+</object></div>
+
+<!-- Even other plugins are considered content so no errors dispatched from these
+     objects, but the inner embeds do get processed -->
+<div><object id="fallback3" style="width: 100px; height: 100px" type="application/x-test">
+  <embed id="plugin13" style="width: 100px; height: 100px" type="application/x-test">
+</object></div>
+<div><object id="fallback4" style="width: 100px; height: 100px" data="data:application/x-test,test">
+  <embed id="plugin14" style="width: 100px; height: 100px" type="application/x-test">
+</object></div>
+
+</body>
+</html>
diff -r b7bcdd009540 content/base/test/file_bug391728_2.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/base/test/file_bug391728_2.html	Thu Sep 11 15:19:24 2008 +0300
@@ -0,0 +1,99 @@
+<html>
+<head>
+<style type="text/css">
+embed,object {
+  border: 1px solid black;
+}
+
+embed:-moz-handler-disabled,
+object:-moz-handler-disabled {
+  border-style: dotted !important;
+}
+
+embed:-moz-handler-blocked,
+object:-moz-handler-blocked {
+  border-style: dashed !important;
+}
+
+embed:-moz-type-unsupported,
+object:-moz-type-unsupported {
+  border-style: none !important;
+}
+</style>
+<script type="text/javascript">
+function unknown_plugin_detected(event) {
+  window.parent.unknown_plugin_detected(event);
+}
+
+function blocked_plugin_detected(event) {
+  window.parent.blocked_plugin_detected(event);
+}
+
+function disabled_plugin_detected(event) {
+  window.parent.disabled_plugin_detected(event);
+}
+
+document.addEventListener("PluginNotFound", unknown_plugin_detected, true);
+document.addEventListener("PluginDisabled", disabled_plugin_detected, true);
+document.addEventListener("PluginBlocklisted", blocked_plugin_detected, true);
+</script>
+</head>
+<body>
+<!-- Embeds always fire events and have the pseudo class attached -->
+<div><embed id="plugin1" style="width: 100px; height: 100px" type="application/x-unknown"></div>
+<div><embed id="plugin2" style="width: 100px; height: 100px" src="data:application/x-unknown,test"></div>
+
+<!-- So do objects with no content and no pluginurl -->
+<div><object id="plugin3" style="width: 100px; height: 100px" type="application/x-unknown"></object></div>
+<div><object id="plugin4" style="width: 100px; height: 100px" data="data:application/x-unknown,test"></object></div>
+
+<!-- The mimetype of the actual data is supposed to be used in preference -->
+<div><embed id="plugin5" style="width: 100px; height: 100px" type="application/x-test" src="data:application/x-unknown,test"></div>
+<div><object id="plugin6" style="width: 100px; height: 100px" type="application/x-test" data="data:application/x-unknown,test"></object></div>
+
+<!-- Params are not considered content -->
+<div><object id="plugin7" style="width: 100px; height: 100px" type="application/x-unknown">
+  <param name="foo" value="bar">
+</object></div>
+<div><object id="plugin8" style="width: 100px; height: 100px" data="data:application/x-unknown,test">
+  <param name="foo" value="bar">
+</object></div>
+
+<!-- Nor is whitespace -->
+<div><object id="plugin9" style="width: 100px; height: 100px" type="application/x-unknown">
+
+  
+</object></div>
+<div><object id="plugin10" style="width: 100px; height: 100px" data="data:application/x-unknown,test">
+
+  
+</object></div>
+
+<!-- Pluginurl forces the psuedo class and error event regardless of content -->
+<div><object id="plugin11" style="width: 100px; height: 100px" type="application/x-unknown">
+  <param name="pluginurl" value="http://foo">
+  <p>Fallback content</p>
+</object></div>
+<div><object id="plugin12" style="width: 100px; height: 100px" data="data:application/x-unknown,test">
+  <param name="pluginurl" value="http://foo">
+  <p>Fallback content</p>
+</object></div>
+
+<!-- No errors or psuedo classes for objects with fallback content -->
+<div><object id="fallback1" style="width: 100px; height: 100px" type="application/x-unknown">
+  <p>Fallback content</p>
+</object></div>
+<div><object id="fallback2" style="width: 100px; height: 100px" data="data:application/x-unknown,test">
+  <p>Fallback content</p>
+</object></div>
+
+<!-- Even other plugins are considered content so no errors dispatched from these
+     objects, but the inner embeds do get processed -->
+<div><object id="fallback3" style="width: 100px; height: 100px" type="application/x-unknown">
+  <embed id="plugin13" style="width: 100px; height: 100px" type="application/x-unknown">
+</object></div>
+<div><object id="fallback4" style="width: 100px; height: 100px" data="data:application/x-unknown,test">
+  <embed id="plugin14" style="width: 100px; height: 100px" type="application/x-unknown">
+</object></div>
+</body>
+</html>
diff -r b7bcdd009540 content/base/test/file_bug445225_multipart.txt
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/base/test/file_bug445225_multipart.txt	Thu Sep 11 15:19:24 2008 +0300
@@ -0,0 +1,7 @@
+--boundary
+Content-Type: text/xml
+
+<?xml version="1.0"?>
+<data>data1</data>
+
+--boundary--
diff -r b7bcdd009540 content/base/test/file_bug445225_multipart.txt^headers^
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/base/test/file_bug445225_multipart.txt^headers^	Thu Sep 11 15:19:24 2008 +0300
@@ -0,0 +1,2 @@
+HTTP 200 OK
+Content-Type: multipart/x-mixed-replace;boundary="--boundary"
diff -r b7bcdd009540 content/base/test/test_bug391728.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/base/test/test_bug391728.html	Thu Sep 11 15:19:24 2008 +0300
@@ -0,0 +1,176 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=391728
+-->
+<head>
+  <title>Test for Bug 391728</title>
+  <script type="text/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=391728">Mozilla Bug 391728</a>
+<p id="display"></p>
+<div id="content">
+  <iframe id="testframe" width="150" height="250" src="about:blank"></iframe>
+</div>
+<pre id="test">
+<script class="testbody" type="text/javascript">
+/** Test for Bug 391728 **/
+// Plugins that should dispatch error events and have the pseudo classes set
+const PLUGIN_COUNT = 14;
+// Plugins that should neither dispatch error events or have the pseudo classes set
+const FALLBACK_COUNT = 4;
+
+var gNextTest = null;
+var gUnknown = [];
+var gBlocked = [];
+var gDisabled = [];
+
+function get_test_plugin() {
+  var ph = Components.classes["@mozilla.org/plugin/host;1"]
+                     .getService(Components.interfaces.nsIPluginHost);
+  var tags = ph.getPluginTags({});
+  
+  // Find the test plugin
+  for (var i = 0; i < tags.length; i++) {
+    if (tags[i].name == "Test Plug-in")
+      return tags[i];
+  }
+}
+
+function disabled_plugin_detected(event) {
+  gDisabled.push(event.target.id);
+}
+
+function blocked_plugin_detected(event) {
+  gBlocked.push(event.target.id);
+}
+
+function unknown_plugin_detected(event) {
+  gUnknown.push(event.target.id);
+}
+
+function init_test() {
+  netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
+  // Make sure the blocklist is off for the duration of this test
+  var prefs = Components.classes["@mozilla.org/preferences-service;1"]
+                        .getService(Components.interfaces.nsIPrefBranch);
+  prefs.setBoolPref("extensions.blocklist.enabled", false);
+
+  var plugin = get_test_plugin();
+  ok(plugin, "Test plugin was not found");
+  
+  is(plugin.description, "Plug-in for testing purposes.", "Test plugin had an incorrect description");
+  is(plugin.version, "1.0.0.0", "Test plugin had an incorrect version");
+  ok(!plugin.disabled, "Test plugin should not be disabled");
+  ok(!plugin.blocklisted, "Test plugin should not be blocklisted");
+  
+  var frame = document.getElementById("testframe");
+  frame.addEventListener("load", frame_loaded, true);
+  load_frame(test_normal, "file_bug391728");
+}
+
+function finish_test() {
+  var plugin = get_test_plugin();
+  plugin.disabled = false;
+  plugin.blocklisted = false;
+  var prefs = Components.classes["@mozilla.org/preferences-service;1"]
+                        .getService(Components.interfaces.nsIPrefBranch);
+  prefs.clearUserPref("extensions.blocklist.enabled");
+  SimpleTest.finish();
+}
+
+function load_frame(nextTest, file) {
+  gNextTest = nextTest;
+  gDisabled = [];
+  gUnknown = [];
+  gBlocked = [];
+  var frame = document.getElementById("testframe");
+  frame.src = file + ".html?" + Math.random();
+}
+
+function frame_loaded() {
+  // We must delay to wait for the plugin sources to be loaded :(
+  setTimeout(gNextTest, 500);
+}
+
+function test_style(expected) {
+  var frame = document.getElementById("testframe");
+  for (var i = 1; i <= PLUGIN_COUNT; i++) {
+    var tag = frame.contentDocument.getElementById("plugin" + i);
+    ok(tag, "Plugin " + i + " did not exist");
+    var style = frame.contentWindow.getComputedStyle(tag, null);
+    is(style.borderTopStyle, expected, "Plugin " + i + " had an incorrect border style");
+  }
+  for (i = 1; i <= FALLBACK_COUNT; i++) {
+    var tag = frame.contentDocument.getElementById("fallback" + i);
+    ok(tag, "Fallback plugin " + i + " did not exist");
+    var style = frame.contentWindow.getComputedStyle(tag, null);
+    is(style.borderTopStyle, "solid", "Fallback plugin " + i + " had an incorrect border style");
+  }
+}
+
+function test_list(list) {
+  for (var i = 1; i <= PLUGIN_COUNT; i++) {
+    ok(list.indexOf("plugin" + i) >= 0, "Plugin " + i + " did not send the event");
+  }
+  for (i = 1; i <= FALLBACK_COUNT; i++) {
+    ok(list.indexOf("fallback" + i) < 0, "Fallback plugin " + i + " should not have sent the event");
+  }
+}
+
+function test_normal() {
+  netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
+  is(gUnknown.length, 0, "Should not have been any unknown plugins");
+  is(gDisabled.length, 0, "Should not have been any disabled plugins");
+  is(gBlocked.length, 0, "Should not have been any blocked plugins");
+  test_style("solid");
+  var plugin = get_test_plugin();
+  plugin.disabled = true;
+  load_frame(test_disabled, "file_bug391728");
+}
+
+function test_disabled() {
+  netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
+  is(gUnknown.length, 0, "Should not have been any unknown plugins");
+  is(gDisabled.length, PLUGIN_COUNT, "Should have been disabled plugins");
+  test_list(gDisabled);
+  is(gBlocked.length, 0, "Should not have been any blocked plugins");
+  test_style("dotted");
+  var plugin = get_test_plugin();
+  ok(plugin.disabled, "Plugin lost its disabled status");
+  plugin.disabled = false;
+  plugin.blocklisted = true;
+  load_frame(test_blocked, "file_bug391728");
+}
+
+function test_blocked() {
+  netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
+  is(gUnknown.length, 0, "Should not have been any unknown plugins");
+  is(gDisabled.length, 0, "Should not have been any disabled plugins");
+  is(gBlocked.length, PLUGIN_COUNT, "Should have been blocked plugins");
+  test_list(gBlocked);
+  test_style("dashed");
+  var plugin = get_test_plugin();
+  ok(plugin.blocklisted, "Plugin lost its blocklist status");
+  load_frame(test_unknown, "file_bug391728_2");
+}
+
+function test_unknown() {
+  netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
+  is(gUnknown.length, PLUGIN_COUNT, "Should have been unknown plugins");
+  test_list(gUnknown);
+  is(gDisabled.length, 0, "Should not have been any disabled plugins");
+  is(gBlocked.length, 0, "Should not have been any blocked plugins");
+  test_style("none");
+  finish_test();
+}
+
+SimpleTest.waitForExplicitFinish();
+window.addEventListener("load", init_test, false);
+</script>
+</pre>
+</body>
+</html>
diff -r b7bcdd009540 content/base/test/test_bug425013.html
--- a/content/base/test/test_bug425013.html	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/base/test/test_bug425013.html	Thu Sep 11 15:19:24 2008 +0300
@@ -51,28 +51,22 @@ document.addEventListener("PluginNotFoun
 <p>Alternate content</p>
 </object>
 
 <embed type="a/b" id="embed2"></embed>
 
 <script class="testbody" type="text/javascript">
 function runtests()
 {
-  is(missingPlugins[0], document.getElementById("obj1"),
-     "Wrong missing plugin element 1");
-  is(missingPlugins[1], document.getElementById("embed1"),
-     "Wrong missing plugin element 2");
-  is(missingPlugins[2], document.getElementById("obj2"),
-     "Wrong missing plugin element 3");
-  is(missingPlugins[3], document.getElementById("embed2"),
-     "Wrong missing plugin element 4");
-  is(missingPlugins[4], document.getElementById("obj3"),
-     "Wrong missing plugin element 5");
+  ok(missingPlugins.indexOf(document.getElementById("obj1")) >= 0, "Missing plugin element obj1");
+  ok(missingPlugins.indexOf(document.getElementById("embed1")) >= 0, "Missing plugin element embed1");
+  ok(missingPlugins.indexOf(document.getElementById("embed2")) >= 0, "Missing plugin element embed2");
+  ok(missingPlugins.indexOf(document.getElementById("obj3")) >= 0, "Missing plugin element obj3");
 
-  is(missingPlugins.length, 5, "Wrong number of missing plugins");
+  is(missingPlugins.length, 4, "Wrong number of missing plugins");
 
   SimpleTest.finish();
 }
 
 SimpleTest.waitForExplicitFinish();
 </script>
 </pre>
 </body>
diff -r b7bcdd009540 content/base/test/test_bug435425.html
--- a/content/base/test/test_bug435425.html	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/base/test/test_bug435425.html	Thu Sep 11 15:19:24 2008 +0300
@@ -115,31 +115,32 @@ function start(obj) {
       }
     xhr.upload.onabort =
       function (evt) {
         logEvent(evt);
       }
   }
 
   try {
+    var methodIsGet = (obj.method == "GET");
     var url;
     var privileged = false;
     if (obj.testRedirectError) {
       url = "bug435425_redirect.sjs";
     } else if (obj.testNetworkError) {
       url = "http://nosuchdomain.localhost";
       privileged = true;
     } else {
       url = "bug435425.sjs";
-      if (obj.withUpload) {
+      if (obj.withUpload && methodIsGet) {
         url += "?" + obj.withUpload;
       }
     }
     openXHR(xhr, obj.method, url, privileged);
-    xhr.send(obj.withUpload);
+    xhr.send(!methodIsGet ? obj.withUpload : null);
     if (obj.testAbort) {
       xhr.abort();
     }
   } catch (ex) {
     ok(false, ex);
   }
 }
 
diff -r b7bcdd009540 content/base/test/test_bug445225.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/base/test/test_bug445225.html	Thu Sep 11 15:19:24 2008 +0300
@@ -0,0 +1,69 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=445225
+-->
+<head>
+  <title>Test for Bug 445225</title>
+  <script type="text/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=445225">Mozilla Bug 445225</a>
+<p id="display"></p>
+<div id="content" style="display: none">
+  
+</div>
+<pre id="test">
+<script class="testbody" type="text/javascript">
+
+/** Test for Bug 445225 **/
+
+var xhr = null;
+
+function runTest() {
+  xhr = new XMLHttpRequest();
+  xhr.multipart = true;
+  xhr.upload.onprogress =
+    function(evt) {
+      ok(false, ".upload shouldn't get any progress events!");
+    }
+  xhr.onload = function(evt) { setTimeout(runTest2, 0); }
+  xhr.open("GET", "file_bug445225_multipart.txt");
+  xhr.send();
+}
+
+var uploadGotLoad = false;
+
+function runTest2() {
+  xhr = new XMLHttpRequest();
+  xhr.multipart = true;
+  xhr.upload.onload =
+    function(evt) {
+      uploadGotLoad = true;
+    }
+  xhr.onprogress =
+    function(evt) {
+      ok(uploadGotLoad,
+         "XHR shouldn't get any progress events before load event is dispatched to .upload");
+    }
+  xhr.onload =
+    function(evt) {
+      ok(uploadGotLoad, ".upload should have got load event.");
+      SimpleTest.finish();
+    }
+  xhr.open("POST", "file_bug445225_multipart.txt");
+  // Send some huge string.
+  xhr.send(new Array(100).join('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'));
+}
+
+SimpleTest.waitForExplicitFinish();
+addLoadEvent(runTest);
+
+
+</script>
+</pre>
+</body>
+</html>
+
diff -r b7bcdd009540 content/base/test/test_bug453521.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/base/test/test_bug453521.html	Thu Sep 11 15:19:24 2008 +0300
@@ -0,0 +1,37 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=453521
+-->
+<head>
+  <title>Test for Bug 453521</title>
+  <script type="text/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=453521">Mozilla Bug 453521</a>
+<p id="display"></p>
+<div id="content" style="display: none">
+  
+</div>
+<pre id="test">
+<script class="testbody" type="text/javascript">
+
+/** Test for Bug 453521 **/
+
+
+var r = document.createRange();
+r.setStart(document.documentElement, 0);
+r.setEnd(document.documentElement, 0);
+ok(r.extractContents() != null,
+   "range.extractContents() shouldn't return null.");
+is(r.extractContents().nodeType, Node.DOCUMENT_FRAGMENT_NODE,
+   "range.extractContents() should return a document fragment.");
+
+
+</script>
+</pre>
+</body>
+</html>
+
diff -r b7bcdd009540 content/canvas/Makefile.in
--- a/content/canvas/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/canvas/Makefile.in	Thu Sep 11 15:19:24 2008 +0300
@@ -40,14 +40,14 @@ topsrcdir	= @top_srcdir@
 topsrcdir	= @top_srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 DIRS		= public src
 
-ifdef MOZ_MOCHITEST
+ifdef ENABLE_TESTS
 DIRS		+= test
 endif
 
 include $(topsrcdir)/config/rules.mk
 
diff -r b7bcdd009540 content/events/Makefile.in
--- a/content/events/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/events/Makefile.in	Thu Sep 11 15:19:24 2008 +0300
@@ -39,14 +39,14 @@ topsrcdir	= @top_srcdir@
 topsrcdir	= @top_srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 DIRS		= public src
 
-ifdef MOZ_MOCHITEST
+ifdef ENABLE_TESTS
 DIRS		+= test
 endif
 
 include $(topsrcdir)/config/rules.mk
 
diff -r b7bcdd009540 content/events/public/nsIEventStateManager.h
--- a/content/events/public/nsIEventStateManager.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/events/public/nsIEventStateManager.h	Thu Sep 11 15:19:24 2008 +0300
@@ -213,10 +213,16 @@ NS_DEFINE_STATIC_IID_ACCESSOR(nsIEventSt
 // user (eg an image which hasn't started coming in yet)
 #define NS_EVENT_STATE_LOADING       0x00200000
 // Content is of a type that gecko can't handle
 #define NS_EVENT_STATE_TYPE_UNSUPPORTED \
                                      0x00400000
 #ifdef MOZ_MATHML
 #define NS_EVENT_STATE_INCREMENT_SCRIPT_LEVEL 0x00800000
 #endif
+// Handler for the content has been blocked
+#define NS_EVENT_STATE_HANDLER_BLOCKED \
+                                     0x01000000
+// Handler for the content has been disabled
+#define NS_EVENT_STATE_HANDLER_DISABLED \
+                                     0x02000000
 
 #endif // nsIEventStateManager_h__
diff -r b7bcdd009540 content/events/src/nsDOMEvent.cpp
--- a/content/events/src/nsDOMEvent.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/events/src/nsDOMEvent.cpp	Thu Sep 11 15:19:24 2008 +0300
@@ -187,34 +187,38 @@ NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(ns
   }
   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mPresContext);
   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mTmpRealOriginalTarget)
   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mExplicitOriginalTarget)
 NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsDOMEvent)
   if (tmp->mEventIsInternal) {
-    cb.NoteXPCOMChild(tmp->mEvent->target);
-    cb.NoteXPCOMChild(tmp->mEvent->currentTarget);
-    cb.NoteXPCOMChild(tmp->mEvent->originalTarget);
+    NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mEvent->target)
+    NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mEvent->currentTarget)
+    NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mEvent->originalTarget)
     switch (tmp->mEvent->eventStructType) {
       case NS_MOUSE_EVENT:
       case NS_MOUSE_SCROLL_EVENT:
+        NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mEvent->relatedTarget");
         cb.NoteXPCOMChild(
           static_cast<nsMouseEvent_base*>(tmp->mEvent)->relatedTarget);
         break;
       case NS_DRAG_EVENT:
+        NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mEvent->dataTransfer");
         cb.NoteXPCOMChild(
           static_cast<nsDragEvent*>(tmp->mEvent)->dataTransfer);
         break;
       case NS_XUL_COMMAND_EVENT:
+        NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mEvent->sourceEvent");
         cb.NoteXPCOMChild(
           static_cast<nsXULCommandEvent*>(tmp->mEvent)->sourceEvent);
         break;
       case NS_MUTATION_EVENT:
+        NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mEvent->mRelatedNode");
         cb.NoteXPCOMChild(
           static_cast<nsMutationEvent*>(tmp->mEvent)->mRelatedNode);
         break;
       default:
         break;
     }
   }
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mPresContext)
diff -r b7bcdd009540 content/events/src/nsEventListenerManager.cpp
--- a/content/events/src/nsEventListenerManager.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/events/src/nsEventListenerManager.cpp	Thu Sep 11 15:19:24 2008 +0300
@@ -386,16 +386,17 @@ NS_INTERFACE_MAP_END
 NS_INTERFACE_MAP_END
 
 NS_IMPL_CYCLE_COLLECTING_ADDREF_AMBIGUOUS(nsEventListenerManager, nsIEventListenerManager)
 NS_IMPL_CYCLE_COLLECTING_RELEASE_AMBIGUOUS(nsEventListenerManager, nsIEventListenerManager)
 
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsEventListenerManager)
   PRUint32 count = tmp->mListeners.Length();
   for (PRUint32 i = 0; i < count; i++) {
+    NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mListeners[i] mListener");
     cb.NoteXPCOMChild(tmp->mListeners.ElementAt(i).mListener.get());
   }  
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsEventListenerManager)
   tmp->Disconnect();
 NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 
diff -r b7bcdd009540 content/events/src/nsEventStateManager.cpp
--- a/content/events/src/nsEventStateManager.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/events/src/nsEventStateManager.cpp	Thu Sep 11 15:19:24 2008 +0300
@@ -2138,24 +2138,19 @@ nsEventStateManager::DetermineDragTarget
         }
         // otherwise, it's not an HTML or XUL element, so just keep looking
       }
       dragContent = dragContent->GetParent();
     }
   }
 
   // if no node in the hierarchy was found to drag, but the GetDragData method
-  // returned a node, use that returned node. Otherwise, just use the original
-  // node that was clicked.
-  if (!dragContent) {
-    if (dragDataNode)
-      dragContent = originalDragContent;
-    else
-      dragContent = mGestureDownContent;
-  }
+  // returned a node, use that returned node. Otherwise, nothing is draggable.
+  if (!dragContent && dragDataNode)
+    dragContent = dragDataNode;
 
   if (dragContent) {
     // if an ancestor node was used instead, clear the drag data
     // XXXndeakin rework this a bit. Find a way to just not call GetDragData if we don't need to.
     if (dragContent != originalDragContent)
       aDataTransfer->ClearAll();
     *aTargetNode = dragContent;
     NS_ADDREF(*aTargetNode);
diff -r b7bcdd009540 content/events/test/test_dragstart.html
--- a/content/events/test/test_dragstart.html	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/events/test/test_dragstart.html	Thu Sep 11 15:19:24 2008 +0300
@@ -77,16 +77,20 @@ function afterDragTests()
   gDragInfo = { target: $("dragtrue"), testid: "draggable true node" };
   sendMouseEventsForDrag("dragtrue");
   gDragInfo = { target: $("dragtrue"), testid: "draggable true child" };
   sendMouseEventsForDrag("spantrue");
   gDragInfo = { target: $("dragfalse").firstChild, testid: "draggable false node" };
   sendMouseEventsForDrag("dragfalse");
   gDragInfo = { target: $("spanfalse").firstChild, testid: "draggable false child" };
   sendMouseEventsForDrag("spanfalse");
+
+  synthesizeMouse(draggable, 12, 12, { type: "mouseup" });
+  if (gExtraDragTests == 4)
+    SimpleTest.finish();
 }
 
 function sendMouseEventsForDrag(nodeid)
 {
   var draggable = $(nodeid);
   synthesizeMouse(draggable, 3, 3, { type: "mousedown" });
   synthesizeMouse(draggable, 10, 10, { type: "mousemove" });
   synthesizeMouse(draggable, 12, 12, { type: "mousemove" });
@@ -457,18 +461,16 @@ return;
 }
 
 function onDragStartDraggable(event)
 {
   var dt = event.dataTransfer;
   ok(dt.mozItemCount == 0 && dt.types.length == 0 && event.originalTarget == gDragInfo.target, gDragInfo.testid);
 
   gExtraDragTests++;
-  if (gExtraDragTests == 6)
-    SimpleTest.finish();
 }
 
 function checkOneDataItem(dt, expectedtypes, expecteddata, index, testid)
 {
   checkTypes(dt, expectedtypes, index, testid);
   for (var f = 0; f < expectedtypes.length; f++) {
     if (index == 0)
       is(dt.getData(expectedtypes[f]), expecteddata[f], testid + " getData " + expectedtypes[f]);
@@ -516,24 +518,28 @@ function expectError(fn, eid, testid)
 </script>
 
 </head>
 
 <body style="height: 300px; overflow: auto;" onload="setTimeout(runTests, 0)">
 
 <div id="draggable" ondragstart="doDragStartSelection(event)">This is a <em>draggable</em> bit of text.</div>
 
+<fieldset>
 <a id="link" href="http://www.mozilla.org/" ondragstart="doDragStartLink(event)">mozilla.org</a>
+</fieldset>
 
+<label>
 <img id="image" src="data:image/png,%89PNG%0D%0A%1A%0A%00%00%00%0DIHDR%00%00%00%18%00%00%00%18%02%03%00%00%00%9D%19%D5k%00%00%00%04gAMA%00%00%B1%8F%0B%FCa%05%00%00%00%0CPLTE%FF%FF%FF%FF%FF%FF%F7%DC%13%00%00%00%03%80%01X%00%00%00%01tRNS%08N%3DPT%00%00%00%01bKGD%00%88%05%1DH%00%00%00%09pHYs%00%00%0B%11%00%00%0B%11%01%7Fd_%91%00%00%00%07tIME%07%D2%05%0C%14%0C%0D%D8%3F%1FQ%00%00%00%5CIDATx%9C%7D%8E%CB%09%C0%20%10D%07r%B7%20%2F%E9wV0%15h%EA%D9%12D4%BB%C1x%CC%5C%1E%0C%CC%07%C0%9C0%9Dd7()%C0A%D3%8D%E0%B8%10%1DiCHM%D0%AC%D2d%C3M%F1%B4%E7%FF%10%0BY%AC%25%93%CD%CBF%B5%B2%C0%3Alh%CD%AE%13%DF%A5%F7%E0%03byW%09A%B4%F3%E2%00%00%00%00IEND%AEB%60%82"
      ondragstart="doDragStartImage(event)">
+</label>
 
 <input id="input" value="Text in a box" ondragstart="doDragStartInput(event)">
 
-<div style="-moz-user-select: none;" ondragstart="onDragStartDraggable(event)">
+<div ondragstart="onDragStartDraggable(event)">
   <div id="dragtrue" draggable="true">
     This is a <span id="spantrue">draggable</span> area.
   </div>
   <div id="dragfalse" draggable="false">
     This is a <span id="spanfalse">non-draggable</span> area.
   </div>
 </div>
 
diff -r b7bcdd009540 content/html/content/Makefile.in
--- a/content/html/content/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/html/content/Makefile.in	Thu Sep 11 15:19:24 2008 +0300
@@ -39,14 +39,14 @@ topsrcdir	= @top_srcdir@
 topsrcdir	= @top_srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 DIRS		= public src
 
-ifdef MOZ_MOCHITEST
+ifdef ENABLE_TESTS
 DIRS		+= test
 endif
 
 include $(topsrcdir)/config/rules.mk
 
diff -r b7bcdd009540 content/html/content/crashtests/453406-1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/html/content/crashtests/453406-1.html	Thu Sep 11 15:19:24 2008 +0300
@@ -0,0 +1,36 @@
+<html>
+<head>
+<script type="text/javascript">
+function boom()
+{
+  var r = document.documentElement;
+  while (r.firstChild)
+    r.removeChild(r.firstChild);
+
+  var b    = document.createElement("BODY");
+  var s    = document.createElement("SCRIPT");
+  var f1   = document.createElement("FORM");
+  var i    = document.createElement("INPUT");
+  var br   = document.createElement("BR");
+  var f2   = document.createElement("FORM");
+  var span = document.createElement("SPAN");
+  f1.appendChild(i);
+  f1.appendChild(br);
+  s.appendChild(f1);
+  b.appendChild(s);
+  f2.appendChild(span);
+  b.appendChild(f2)
+  document.documentElement.appendChild(b);
+  dump('aaa');
+  b.contentEditable = "true";
+  document.execCommand("indent", false, null);
+  b.contentEditable = "false";
+  dump('bbb');
+  span.appendChild(i);
+  i.parentNode.removeChild(i);
+}
+</script>
+</head>
+<body onload="boom();">
+</body>
+</html>
diff -r b7bcdd009540 content/html/content/crashtests/crashtests.list
--- a/content/html/content/crashtests/crashtests.list	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/html/content/crashtests/crashtests.list	Thu Sep 11 15:19:24 2008 +0300
@@ -1,7 +1,8 @@ load 307616-1.html
 load 307616-1.html
 load 324918-1.xhtml
 load 338649-1.xhtml
 load 339501-1.xhtml
 load 339501-2.xhtml
 load 423371-1.html
 load 451123-1.html
+load 453406-1.html
diff -r b7bcdd009540 content/html/content/public/nsIFormControl.h
--- a/content/html/content/public/nsIFormControl.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/html/content/public/nsIFormControl.h	Thu Sep 11 15:19:24 2008 +0300
@@ -64,19 +64,18 @@ class nsIFormSubmission;
 #define NS_FORM_OPTION         16
 #define NS_FORM_OPTGROUP       17
 #define NS_FORM_LEGEND         18
 #define NS_FORM_SELECT         19
 #define NS_FORM_TEXTAREA       20
 #define NS_FORM_OBJECT         21
 
 #define NS_IFORMCONTROL_IID   \
-{ 0x119c5ce8, 0xf4b0, 0x456c, \
-  {0x83, 0x4d, 0xb1, 0x90, 0x3d, 0x99, 0x9f, 0xb3} }
-
+{ 0x52dc1f0d, 0x1683, 0x4dd7, \
+ { 0xae, 0x0a, 0xc4, 0x76, 0x10, 0x64, 0x2f, 0xa8 } }
 
 /**
  * Interface which all form controls (e.g. buttons, checkboxes, text,
  * radio buttons, select, etc) implement in addition to their dom specific
  * interface.
  */
 class nsIFormControl : public nsISupports
 {
@@ -87,29 +86,33 @@ public:
   /**
    * Get the form for this form control.
    * @param aForm the form [OUT]
    */
   NS_IMETHOD GetForm(nsIDOMHTMLFormElement** aForm) = 0;
 
   /**
    * Set the form for this form control.
-   * @param aForm the form
+   * @param aForm the form.  This must not be null.
+   *
+   * @note that when setting the form the control is not added to the
+   * form.  It adds itself when it gets bound to the tree thereafter,
+   * so that it can be properly sorted with the other controls in the
+   * form.
+   */
+  virtual void SetForm(nsIDOMHTMLFormElement* aForm) = 0;
+
+  /**
+   * Tell the control to forget about its form.
+   *
    * @param aRemoveFromForm set false if you do not want this element removed
    *        from the form.  (Used by nsFormControlList::Clear())
-   * @param aNofify If true, send nsIDocumentObserver notifications as needed.
-   *
-   * @param note that when setting a new form aNotify is ignored and the
-   * control is not added to the form itself.  It adds itself when it gets
-   * bound to the tree thereafter, so that it can be properly sorted with the
-   * other controls in the form.
+   * @param aNotify If true, send nsIDocumentObserver notifications as needed.
    */
-  NS_IMETHOD SetForm(nsIDOMHTMLFormElement* aForm,
-                     PRBool aRemoveFromForm,
-                     PRBool aNotify) = 0;
+  virtual void ClearForm(PRBool aRemoveFromForm, PRBool aNotify) = 0;
 
   /**
    * Get the type of this control as an int (see NS_FORM_* above)
    * @return the type of this control
    */
   NS_IMETHOD_(PRInt32) GetType() const = 0 ;
 
   /**
diff -r b7bcdd009540 content/html/content/src/nsGenericHTMLElement.cpp
--- a/content/html/content/src/nsGenericHTMLElement.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/html/content/src/nsGenericHTMLElement.cpp	Thu Sep 11 15:19:24 2008 +0300
@@ -2281,17 +2281,17 @@ nsGenericHTMLFormElement::~nsGenericHTML
 {
   // Check that this element is still not the default content
   // of its parent form.
   NS_ASSERTION(!mForm || mForm->GetDefaultSubmitElement() != this,
                "Content being destroyed is the default content");
 
   // Clean up.  Set the form to nsnull so it knows we went away.
   // Do not notify as the content is being destroyed.
-  SetForm(nsnull, PR_TRUE, PR_FALSE);
+  ClearForm(PR_TRUE, PR_FALSE);
 }
 
 NS_IMPL_QUERY_INTERFACE_INHERITED1(nsGenericHTMLFormElement,
                                    nsGenericHTMLElement,
                                    nsIFormControl)
 
 PRBool
 nsGenericHTMLFormElement::IsNodeOfType(PRUint32 aFlags) const
@@ -2302,51 +2302,57 @@ void
 void
 nsGenericHTMLFormElement::SaveSubtreeState()
 {
   SaveState();
 
   nsGenericHTMLElement::SaveSubtreeState();
 }
 
-NS_IMETHODIMP
-nsGenericHTMLFormElement::SetForm(nsIDOMHTMLFormElement* aForm,
-                                  PRBool aRemoveFromForm,
-                                  PRBool aNotify)
+void
+nsGenericHTMLFormElement::SetForm(nsIDOMHTMLFormElement* aForm)
 {
-  NS_ASSERTION(!mForm || HasFlag(ADDED_TO_FORM),
-               "Form control should have had flag set.");
+  NS_PRECONDITION(aForm, "Don't pass null here");
+  NS_ASSERTION(!mForm,
+               "We don't support switching from one non-null form to another.");
 
-  if (mForm && aRemoveFromForm) {
+  // keep a *weak* ref to the form here
+  CallQueryInterface(aForm, &mForm);
+  mForm->Release();
+}
+
+void
+nsGenericHTMLFormElement::ClearForm(PRBool aRemoveFromForm,
+                                    PRBool aNotify)
+{
+  NS_ASSERTION((mForm != nsnull) == HasFlag(ADDED_TO_FORM),
+               "Form control should have had flag set correctly");
+
+  if (!mForm) {
+    return;
+  }
+  
+  if (aRemoveFromForm) {
     nsAutoString nameVal, idVal;
     GetAttr(kNameSpaceID_None, nsGkAtoms::name, nameVal);
     GetAttr(kNameSpaceID_None, nsGkAtoms::id, idVal);
 
     mForm->RemoveElement(this, aNotify);
 
     if (!nameVal.IsEmpty()) {
       mForm->RemoveElementFromTable(this, nameVal);
     }
 
     if (!idVal.IsEmpty()) {
       mForm->RemoveElementFromTable(this, idVal);
     }
-
-    UnsetFlags(ADDED_TO_FORM);
   }
 
-  if (aForm) {
-    // keep a *weak* ref to the form here
-    CallQueryInterface(aForm, &mForm);
-    mForm->Release();
-  } else {
-    mForm = nsnull;
-  }
-
-  return NS_OK;
+  UnsetFlags(ADDED_TO_FORM);
+  mForm = nsnull;
 }
 
 NS_IMETHODIMP
 nsGenericHTMLFormElement::GetForm(nsIDOMHTMLFormElement** aForm)
 {
   NS_ENSURE_ARG_POINTER(aForm);
   *aForm = nsnull;
 
@@ -2438,17 +2444,17 @@ nsGenericHTMLFormElement::BindToTree(nsI
     // We now have a parent, so we may have picked up an ancestor form.  Search
     // for it.  Note that if mForm is already set we don't want to do this,
     // because that means someone (probably the content sink) has already set
     // it to the right value.  Also note that even if being bound here didn't
     // change our parent, we still need to search, since our parent chain
     // probably changed _somewhere_.
     nsCOMPtr<nsIDOMHTMLFormElement> form = FindForm();
     if (form) {
-      SetForm(form, PR_FALSE, PR_FALSE);
+      SetForm(form);
     }
   }
 
   if (mForm && !HasFlag(ADDED_TO_FORM)) {
     // Now we need to add ourselves to the form
     nsAutoString nameVal, idVal;
     GetAttr(kNameSpaceID_None, nsGkAtoms::name, nameVal);
     GetAttr(kNameSpaceID_None, nsGkAtoms::id, idVal);
@@ -2475,22 +2481,22 @@ nsGenericHTMLFormElement::UnbindFromTree
 {
   // Save state before doing anything
   SaveState();
 
   if (mForm) {
     // Might need to unset mForm
     if (aNullParent) {
       // No more parent means no more form
-      SetForm(nsnull, PR_TRUE, PR_TRUE);
+      ClearForm(PR_TRUE, PR_TRUE);
     } else {
       // Recheck whether we should still have an mForm.
       nsCOMPtr<nsIDOMHTMLFormElement> form = FindForm(mForm);
       if (!form) {
-        SetForm(nsnull, PR_TRUE, PR_TRUE);
+        ClearForm(PR_TRUE, PR_TRUE);
       } else {
         UnsetFlags(MAYBE_ORPHAN_FORM_ELEMENT);
       }
     }
   }
 
   nsGenericHTMLElement::UnbindFromTree(aDeep, aNullParent);
 }
diff -r b7bcdd009540 content/html/content/src/nsGenericHTMLElement.h
--- a/content/html/content/src/nsGenericHTMLElement.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/html/content/src/nsGenericHTMLElement.h	Thu Sep 11 15:19:24 2008 +0300
@@ -819,19 +819,18 @@ public:
 
   NS_IMETHOD QueryInterface(REFNSIID aIID, void** aInstancePtr);
 
   virtual PRBool IsNodeOfType(PRUint32 aFlags) const;
   virtual void SaveSubtreeState();
 
   // nsIFormControl
   NS_IMETHOD GetForm(nsIDOMHTMLFormElement** aForm);
-  NS_IMETHOD SetForm(nsIDOMHTMLFormElement* aForm,
-                     PRBool aRemoveFromForm,
-                     PRBool aNotify);
+  virtual void SetForm(nsIDOMHTMLFormElement* aForm);
+  virtual void ClearForm(PRBool aRemoveFromForm, PRBool aNotify);
 
   NS_IMETHOD SaveState()
   {
     return NS_OK;
   }
   
   virtual PRBool RestoreState(nsPresState* aState)
   {
diff -r b7bcdd009540 content/html/content/src/nsHTMLAnchorElement.cpp
--- a/content/html/content/src/nsHTMLAnchorElement.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/html/content/src/nsHTMLAnchorElement.cpp	Thu Sep 11 15:19:24 2008 +0300
@@ -659,16 +659,20 @@ nsHTMLAnchorElement::SetAttr(PRInt32 aNa
   return rv;
 }
 
 nsresult
 nsHTMLAnchorElement::UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aAttribute,
                                PRBool aNotify)
 {
   if (aAttribute == nsGkAtoms::href && kNameSpaceID_None == aNameSpaceID) {
+    nsIDocument* doc = GetCurrentDoc();
+    if (doc) {
+      doc->ForgetLink(this);
+    }
     SetLinkState(eLinkState_Unknown);
   }
 
   if (aAttribute == nsGkAtoms::accesskey &&
       kNameSpaceID_None == aNameSpaceID) {
     RegUnRegAccessKey(PR_FALSE);
   }
 
diff -r b7bcdd009540 content/html/content/src/nsHTMLAreaElement.cpp
--- a/content/html/content/src/nsHTMLAreaElement.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/html/content/src/nsHTMLAreaElement.cpp	Thu Sep 11 15:19:24 2008 +0300
@@ -274,16 +274,24 @@ nsHTMLAreaElement::SetAttr(PRInt32 aName
 
   return rv;
 }
 
 nsresult
 nsHTMLAreaElement::UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aAttribute,
                              PRBool aNotify)
 {
+  if (aAttribute == nsGkAtoms::href && kNameSpaceID_None == aNameSpaceID) {
+    nsIDocument* doc = GetCurrentDoc();
+    if (doc) {
+      doc->ForgetLink(this);
+    }
+    SetLinkState(eLinkState_Unknown);
+  }
+
   if (aAttribute == nsGkAtoms::accesskey &&
       aNameSpaceID == kNameSpaceID_None) {
     RegUnRegAccessKey(PR_FALSE);
   }
 
   return nsGenericHTMLElement::UnsetAttr(aNameSpaceID, aAttribute, aNotify);
 }
 
diff -r b7bcdd009540 content/html/content/src/nsHTMLFormElement.cpp
--- a/content/html/content/src/nsHTMLFormElement.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/html/content/src/nsHTMLFormElement.cpp	Thu Sep 11 15:19:24 2008 +0300
@@ -745,17 +745,17 @@ CollectOrphans(nsINode* aRemovalRoot, ns
     // descendant of aRemovalRoot.  If it is, we leave it in the form.  See
     // also the code in nsGenericHTMLFormElement::FindForm.
 #ifdef DEBUG
     PRBool removed = PR_FALSE;
 #endif
     if (node->HasFlag(MAYBE_ORPHAN_FORM_ELEMENT)) {
       node->UnsetFlags(MAYBE_ORPHAN_FORM_ELEMENT);
       if (!nsContentUtils::ContentIsDescendantOf(node, aRemovalRoot)) {
-        control->SetForm(nsnull, PR_TRUE, PR_TRUE);
+        control->ClearForm(PR_TRUE, PR_TRUE);
 #ifdef DEBUG
         removed = PR_TRUE;
 #endif
       }
     }
 
 #ifdef DEBUG
     if (!removed) {
@@ -2066,22 +2066,22 @@ nsFormControlList::DropFormReference()
 }
 
 void
 nsFormControlList::Clear()
 {
   // Null out childrens' pointer to me.  No refcounting here
   PRInt32 i;
   for (i = mElements.Length()-1; i >= 0; i--) {
-    mElements[i]->SetForm(nsnull, PR_FALSE, PR_TRUE);
+    mElements[i]->ClearForm(PR_FALSE, PR_TRUE);
   }
   mElements.Clear();
 
   for (i = mNotInElements.Length()-1; i >= 0; i--) {
-    mNotInElements[i]->SetForm(nsnull, PR_FALSE, PR_TRUE);
+    mNotInElements[i]->ClearForm(PR_FALSE, PR_TRUE);
   }
   mNotInElements.Clear();
 
   mNameLookupTable.Clear();
 }
 
 void
 nsFormControlList::FlushPendingNotifications()
@@ -2241,17 +2241,18 @@ nsFormControlList::AddElementToTable(nsI
       nsBaseContentList *list = new nsBaseContentList();
       NS_ENSURE_TRUE(list, NS_ERROR_OUT_OF_MEMORY);
 
       list->AppendElement(content);
 
       // Add the new child too
       list->AppendElement(newChild);
 
-      nsCOMPtr<nsISupports> listSupports = do_QueryInterface(list);
+      nsCOMPtr<nsISupports> listSupports =
+        do_QueryInterface(static_cast<nsIDOMNodeList*>(list));
 
       // Replace the element with the list.
       NS_ENSURE_TRUE(mNameLookupTable.Put(aName, listSupports),
                      NS_ERROR_FAILURE);
     } else {
       // There's already a list in the hash, add the child to the list
       nsCOMPtr<nsIDOMNodeList> nodeList(do_QueryInterface(supports));
       NS_ENSURE_TRUE(nodeList, NS_ERROR_FAILURE);
diff -r b7bcdd009540 content/html/content/src/nsHTMLLinkElement.cpp
--- a/content/html/content/src/nsHTMLLinkElement.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/html/content/src/nsHTMLLinkElement.cpp	Thu Sep 11 15:19:24 2008 +0300
@@ -317,16 +317,24 @@ nsHTMLLinkElement::SetAttr(PRInt32 aName
 
   return rv;
 }
 
 nsresult
 nsHTMLLinkElement::UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aAttribute,
                              PRBool aNotify)
 {
+  if (aAttribute == nsGkAtoms::href && kNameSpaceID_None == aNameSpaceID) {
+    nsIDocument* doc = GetCurrentDoc();
+    if (doc) {
+      doc->ForgetLink(this);
+    }
+    SetLinkState(eLinkState_Unknown);
+  }
+
   nsresult rv = nsGenericHTMLElement::UnsetAttr(aNameSpaceID, aAttribute,
                                                 aNotify);
   if (NS_SUCCEEDED(rv)) {
     UpdateStyleSheetInternal(nsnull,
                              aNameSpaceID == kNameSpaceID_None &&
                              (aAttribute == nsGkAtoms::rel ||
                               aAttribute == nsGkAtoms::title ||
                               aAttribute == nsGkAtoms::media ||
diff -r b7bcdd009540 content/html/content/src/nsHTMLMapElement.cpp
--- a/content/html/content/src/nsHTMLMapElement.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/html/content/src/nsHTMLMapElement.cpp	Thu Sep 11 15:19:24 2008 +0300
@@ -89,17 +89,17 @@ nsHTMLMapElement::nsHTMLMapElement(nsINo
   : nsGenericHTMLElement(aNodeInfo)
 {
 }
 
 NS_IMPL_CYCLE_COLLECTION_CLASS(nsHTMLMapElement)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsHTMLMapElement,
                                                   nsGenericHTMLElement)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mAreas,
-                                                       nsBaseContentList)
+                                                       nsIDOMNodeList)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLMapElement, nsGenericElement) 
 NS_IMPL_RELEASE_INHERITED(nsHTMLMapElement, nsGenericElement) 
 
 
 // QueryInterface implementation for nsHTMLMapElement
 NS_HTML_CONTENT_CC_INTERFACE_TABLE_HEAD(nsHTMLMapElement,
diff -r b7bcdd009540 content/html/content/src/nsHTMLTableElement.cpp
--- a/content/html/content/src/nsHTMLTableElement.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/html/content/src/nsHTMLTableElement.cpp	Thu Sep 11 15:19:24 2008 +0300
@@ -139,17 +139,17 @@ TableRowsCollection::~TableRowsCollectio
   // instantiator who provided mParent is responsible for managing our
   // reference for us.
 }
 
 NS_IMPL_CYCLE_COLLECTION_CLASS(TableRowsCollection)
 NS_IMPL_CYCLE_COLLECTION_UNLINK_0(TableRowsCollection)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(TableRowsCollection)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mOrphanRows,
-                                                       nsBaseContentList)
+                                                       nsIDOMNodeList)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_CYCLE_COLLECTING_ADDREF(TableRowsCollection)
 NS_IMPL_CYCLE_COLLECTING_RELEASE(TableRowsCollection)
 
 NS_INTERFACE_TABLE_HEAD(TableRowsCollection)
   NS_INTERFACE_TABLE1(TableRowsCollection, nsIDOMHTMLCollection)
   NS_INTERFACE_TABLE_TO_MAP_SEGUE_CYCLE_COLLECTION(TableRowsCollection)
@@ -349,17 +349,17 @@ nsHTMLTableElement::~nsHTMLTableElement(
   }
 }
 
 
 NS_IMPL_CYCLE_COLLECTION_CLASS(nsHTMLTableElement)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsHTMLTableElement,
                                                   nsGenericHTMLElement)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mTBodies,
-                                                       nsBaseContentList)
+                                                       nsIDOMNodeList)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mRows)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLTableElement, nsGenericElement) 
 NS_IMPL_RELEASE_INHERITED(nsHTMLTableElement, nsGenericElement) 
 
 
 // QueryInterface implementation for nsHTMLTableElement
diff -r b7bcdd009540 content/html/content/src/nsHTMLTableRowElement.cpp
--- a/content/html/content/src/nsHTMLTableRowElement.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/html/content/src/nsHTMLTableRowElement.cpp	Thu Sep 11 15:19:24 2008 +0300
@@ -96,17 +96,17 @@ nsHTMLTableRowElement::nsHTMLTableRowEle
   : nsGenericHTMLElement(aNodeInfo)
 {
 }
 
 NS_IMPL_CYCLE_COLLECTION_CLASS(nsHTMLTableRowElement)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsHTMLTableRowElement,
                                                   nsGenericHTMLElement)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mCells,
-                                                       nsBaseContentList)
+                                                       nsIDOMNodeList)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLTableRowElement, nsGenericElement) 
 NS_IMPL_RELEASE_INHERITED(nsHTMLTableRowElement, nsGenericElement) 
 
 
 // QueryInterface implementation for nsHTMLTableRowElement
 NS_HTML_CONTENT_CC_INTERFACE_TABLE_HEAD(nsHTMLTableRowElement,
diff -r b7bcdd009540 content/html/content/src/nsHTMLTableSectionElement.cpp
--- a/content/html/content/src/nsHTMLTableSectionElement.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/html/content/src/nsHTMLTableSectionElement.cpp	Thu Sep 11 15:19:24 2008 +0300
@@ -94,17 +94,17 @@ nsHTMLTableSectionElement::nsHTMLTableSe
   : nsGenericHTMLElement(aNodeInfo)
 {
 }
 
 NS_IMPL_CYCLE_COLLECTION_CLASS(nsHTMLTableSectionElement)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsHTMLTableSectionElement,
                                                   nsGenericHTMLElement)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mRows,
-                                                       nsBaseContentList)
+                                                       nsIDOMNodeList)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLTableSectionElement, nsGenericElement) 
 NS_IMPL_RELEASE_INHERITED(nsHTMLTableSectionElement, nsGenericElement) 
 
 
 // QueryInterface implementation for nsHTMLTableSectionElement
 NS_HTML_CONTENT_CC_INTERFACE_TABLE_HEAD(nsHTMLTableSectionElement,
diff -r b7bcdd009540 content/html/document/Makefile.in
--- a/content/html/document/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/html/document/Makefile.in	Thu Sep 11 15:19:24 2008 +0300
@@ -39,14 +39,14 @@ topsrcdir	= @top_srcdir@
 topsrcdir	= @top_srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 DIRS		= public src
 
-ifdef MOZ_MOCHITEST
+ifdef ENABLE_TESTS
 DIRS		+= test
 endif
 
 include $(topsrcdir)/config/rules.mk
 
diff -r b7bcdd009540 content/html/document/src/nsHTMLContentSink.cpp
--- a/content/html/document/src/nsHTMLContentSink.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/html/document/src/nsHTMLContentSink.cpp	Thu Sep 11 15:19:24 2008 +0300
@@ -518,20 +518,20 @@ MaybeSetForm(nsGenericHTMLElement* aCont
     default:
       return;
   }
   
   nsCOMPtr<nsIFormControl> formControl(do_QueryInterface(aContent));
   NS_ASSERTION(formControl,
                "nsGenericHTMLElement didn't implement nsIFormControl");
   nsCOMPtr<nsIDOMHTMLFormElement> formElement(do_QueryInterface(form));
-  NS_ASSERTION(!form || formElement,
+  NS_ASSERTION(formElement,
                "nsGenericHTMLElement didn't implement nsIDOMHTMLFormElement");
 
-  formControl->SetForm(formElement, PR_TRUE, PR_FALSE);
+  formControl->SetForm(formElement);
 }
 
 /**
  * Factory subroutine to create all of the html content objects.
  */
 already_AddRefed<nsGenericHTMLElement>
 HTMLContentSink::CreateContentObject(const nsIParserNode& aNode,
                                      nsHTMLTag aNodeType)
diff -r b7bcdd009540 content/media/video/Makefile.in
--- a/content/media/video/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/media/video/Makefile.in	Thu Sep 11 15:19:24 2008 +0300
@@ -41,14 +41,14 @@ VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 DIRS		= \
 		public \
 		src \
 		$(NULL)
 
-ifdef MOZ_MOCHITEST
+ifdef ENABLE_TESTS
 DIRS            += test
 endif
 
 include $(topsrcdir)/config/rules.mk
 
diff -r b7bcdd009540 content/svg/content/Makefile.in
--- a/content/svg/content/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/svg/content/Makefile.in	Thu Sep 11 15:19:24 2008 +0300
@@ -40,14 +40,14 @@ topsrcdir	= @top_srcdir@
 topsrcdir	= @top_srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 DIRS		= src
 
-ifdef MOZ_MOCHITEST
+ifdef ENABLE_TESTS
 DIRS += test
 endif
 
 include $(topsrcdir)/config/rules.mk
 
diff -r b7bcdd009540 content/svg/content/src/nsSVGFilterElement.h
--- a/content/svg/content/src/nsSVGFilterElement.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/svg/content/src/nsSVGFilterElement.h	Thu Sep 11 15:19:24 2008 +0300
@@ -49,16 +49,17 @@ typedef nsSVGGraphicElement nsSVGFilterE
 typedef nsSVGGraphicElement nsSVGFilterElementBase;
 
 class nsSVGFilterElement : public nsSVGFilterElementBase,
                            public nsIDOMSVGFilterElement,
                            public nsIDOMSVGURIReference,
                            public nsIDOMSVGUnitTypes
 {
   friend class nsSVGFilterFrame;
+  friend class nsAutoFilterInstance;
 
 protected:
   friend nsresult NS_NewSVGFilterElement(nsIContent **aResult,
                                          nsINodeInfo *aNodeInfo);
   nsSVGFilterElement(nsINodeInfo* aNodeInfo);
 
   // nsISVGValue interface:
   NS_IMETHOD SetValueString(const nsAString &aValue) { return NS_OK; }
diff -r b7bcdd009540 content/svg/content/src/nsSVGFilters.h
--- a/content/svg/content/src/nsSVGFilters.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/svg/content/src/nsSVGFilters.h	Thu Sep 11 15:19:24 2008 +0300
@@ -37,16 +37,17 @@
 #ifndef __NS_SVGFILTERSELEMENT_H__
 #define __NS_SVGFILTERSELEMENT_H__
 
 #include "nsSVGStylableElement.h"
 #include "nsSVGLength2.h"
 #include "nsIFrame.h"
 #include "gfxRect.h"
 #include "gfxImageSurface.h"
+#include "nsIDOMSVGFilters.h"
 
 class nsSVGFilterResource;
 class nsSVGString;
 class nsSVGFilterInstance;
 
 typedef nsSVGStylableElement nsSVGFEBase;
 
 #define NS_SVG_FE_CID \
diff -r b7bcdd009540 content/svg/content/src/nsSVGLength2.cpp
--- a/content/svg/content/src/nsSVGLength2.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/svg/content/src/nsSVGLength2.cpp	Thu Sep 11 15:19:24 2008 +0300
@@ -35,16 +35,18 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsSVGLength2.h"
 #include "prdtoa.h"
 #include "nsTextFormatter.h"
 #include "nsSVGSVGElement.h"
+#include "nsIFrame.h"
+#include "nsSVGIntegrationUtils.h"
 
 NS_IMPL_ADDREF(nsSVGLength2::DOMBaseVal)
 NS_IMPL_RELEASE(nsSVGLength2::DOMBaseVal)
 
 NS_IMPL_ADDREF(nsSVGLength2::DOMAnimVal)
 NS_IMPL_RELEASE(nsSVGLength2::DOMAnimVal)
 
 NS_IMPL_ADDREF(nsSVGLength2::DOMAnimatedLength)
@@ -175,29 +177,60 @@ nsSVGLength2::GetMMPerPixel(nsSVGSVGElem
     NS_ASSERTION(mmPerPx != 0.0f, "invalid mm/pixels");
     mmPerPx = 1e-4f; // some small value
   }
 
   return mmPerPx;
 }
 
 float
+nsSVGLength2::GetMMPerPixel(nsIFrame *aNonSVGFrame) const
+{
+  nsPresContext* presContext = aNonSVGFrame->PresContext();
+  float pixelsPerInch =
+    presContext->AppUnitsToFloatCSSPixels(presContext->AppUnitsPerInch());
+  return 25.4f/pixelsPerInch;
+}
+
+static float
+FixAxisLength(float aLength)
+{
+  if (aLength == 0.0f) {
+    NS_WARNING("zero axis length");
+    return 1e-20f;
+  }
+  return aLength;
+}
+
+float
 nsSVGLength2::GetAxisLength(nsSVGSVGElement *aCtx) const
 {
   if (!aCtx)
     return 1;
 
-  float d = aCtx->GetLength(mCtxType);
+  return FixAxisLength(aCtx->GetLength(mCtxType));
+}
 
-  if (d == 0.0f) {
-    NS_WARNING("zero axis length");
-    d = 1e-20f;
+float
+nsSVGLength2::GetAxisLength(nsIFrame *aNonSVGFrame) const
+{
+  gfxRect rect = nsSVGIntegrationUtils::GetSVGRectForNonSVGFrame(aNonSVGFrame);
+  float length;
+  switch (mCtxType) {
+  case nsSVGUtils::X: length = rect.Width(); break;
+  case nsSVGUtils::Y: length = rect.Height(); break;
+  case nsSVGUtils::XY:
+    length = nsSVGUtils::ComputeNormalizedHypotenuse(rect.Width(), rect.Height());
+    break;
+  default:
+    NS_NOTREACHED("Unknown axis type");
+    length = 1;
+    break;
   }
-
-  return d;
+  return FixAxisLength(length);
 }
 
 float
 nsSVGLength2::GetUnitScaleFactor(nsSVGElement *aSVGElement) const
 {
   switch (mSpecifiedUnitType) {
   case nsIDOMSVGLength::SVG_LENGTHTYPE_NUMBER:
   case nsIDOMSVGLength::SVG_LENGTHTYPE_PX:
@@ -229,16 +262,49 @@ nsSVGLength2::GetUnitScaleFactor(nsSVGSV
   case nsIDOMSVGLength::SVG_LENGTHTYPE_PC:
     return GetMMPerPixel(aCtx) * POINTS_PER_INCH_FLOAT / 24.4f / 12.0f;
   case nsIDOMSVGLength::SVG_LENGTHTYPE_PERCENTAGE:
     return 100.0f / GetAxisLength(aCtx);
   case nsIDOMSVGLength::SVG_LENGTHTYPE_EMS:
     return 1 / GetEmLength(aCtx);
   case nsIDOMSVGLength::SVG_LENGTHTYPE_EXS:
     return 1 / GetExLength(aCtx);
+  default:
+    NS_NOTREACHED("Unknown unit type");
+    return 0;
+  }
+}
+
+float
+nsSVGLength2::GetUnitScaleFactor(nsIFrame *aFrame) const
+{
+  nsIContent* content = aFrame->GetContent();
+  if (content->IsNodeOfType(nsINode::eSVG))
+    return GetUnitScaleFactor(static_cast<nsSVGElement*>(content));
+
+  switch (mSpecifiedUnitType) {
+  case nsIDOMSVGLength::SVG_LENGTHTYPE_NUMBER:
+  case nsIDOMSVGLength::SVG_LENGTHTYPE_PX:
+    return 1;
+  case nsIDOMSVGLength::SVG_LENGTHTYPE_MM:
+    return GetMMPerPixel(aFrame);
+  case nsIDOMSVGLength::SVG_LENGTHTYPE_CM:
+    return GetMMPerPixel(aFrame) / 10.0f;
+  case nsIDOMSVGLength::SVG_LENGTHTYPE_IN:
+    return GetMMPerPixel(aFrame) / 25.4f;
+  case nsIDOMSVGLength::SVG_LENGTHTYPE_PT:
+    return GetMMPerPixel(aFrame) * POINTS_PER_INCH_FLOAT / 25.4f;
+  case nsIDOMSVGLength::SVG_LENGTHTYPE_PC:
+    return GetMMPerPixel(aFrame) * POINTS_PER_INCH_FLOAT / 24.4f / 12.0f;
+  case nsIDOMSVGLength::SVG_LENGTHTYPE_PERCENTAGE:
+    return 100.0f / GetAxisLength(aFrame);
+  case nsIDOMSVGLength::SVG_LENGTHTYPE_EMS:
+    return 1 / GetEmLength(aFrame);
+  case nsIDOMSVGLength::SVG_LENGTHTYPE_EXS:
+    return 1 / GetExLength(aFrame);
   default:
     NS_NOTREACHED("Unknown unit type");
     return 0;
   }
 }
 
 void
 nsSVGLength2::SetBaseValueInSpecifiedUnits(float aValue,
diff -r b7bcdd009540 content/svg/content/src/nsSVGLength2.h
--- a/content/svg/content/src/nsSVGLength2.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/svg/content/src/nsSVGLength2.h	Thu Sep 11 15:19:24 2008 +0300
@@ -38,16 +38,18 @@
 #define __NS_SVGLENGTH2_H__
 
 #include "nsIDOMSVGLength.h"
 #include "nsIDOMSVGAnimatedLength.h"
 #include "nsSVGUtils.h"
 #include "nsSVGElement.h"
 #include "nsDOMError.h"
 
+class nsIFrame;
+
 class nsSVGLength2
 {
 
 public:
   void Init(PRUint8 aCtxType = nsSVGUtils::XY,
             PRUint8 aAttrEnum = 0xff,
             float aValue = 0,
             PRUint8 aUnitType = nsIDOMSVGLength::SVG_LENGTHTYPE_NUMBER) {
@@ -59,45 +61,55 @@ public:
   }
 
   nsresult SetBaseValueString(const nsAString& aValue,
                               nsSVGElement *aSVGElement,
                               PRBool aDoSetAttr);
   void GetBaseValueString(nsAString& aValue);
   void GetAnimValueString(nsAString& aValue);
 
-  float GetBaseValue(nsSVGElement* aSVGElement)
+  float GetBaseValue(nsSVGElement* aSVGElement) const
     { return mBaseVal / GetUnitScaleFactor(aSVGElement); }
-  float GetAnimValue(nsSVGElement* aSVGElement)
+  float GetAnimValue(nsSVGElement* aSVGElement) const
     { return mAnimVal / GetUnitScaleFactor(aSVGElement); }
+  float GetAnimValue(nsIFrame* aFrame) const
+    { return mAnimVal / GetUnitScaleFactor(aFrame); }
 
   PRUint8 GetCtxType() const { return mCtxType; }
   PRUint8 GetSpecifiedUnitType() const { return mSpecifiedUnitType; }
   PRBool IsPercentage() const
     { return mSpecifiedUnitType == nsIDOMSVGLength::SVG_LENGTHTYPE_PERCENTAGE; }
   float GetAnimValInSpecifiedUnits() const { return mAnimVal; }
   float GetBaseValInSpecifiedUnits() const { return mBaseVal; }
 
-  float GetBaseValue(nsSVGSVGElement* aCtx)
+  float GetBaseValue(nsSVGSVGElement* aCtx) const
     { return mBaseVal / GetUnitScaleFactor(aCtx); }
-  float GetAnimValue(nsSVGSVGElement* aCtx)
+  float GetAnimValue(nsSVGSVGElement* aCtx) const
     { return mAnimVal / GetUnitScaleFactor(aCtx); }
   
   nsresult ToDOMAnimatedLength(nsIDOMSVGAnimatedLength **aResult,
                                nsSVGElement* aSVGElement);
 
 private:
   
   float mAnimVal;
   float mBaseVal;
   PRUint8 mSpecifiedUnitType;
   PRUint8 mAttrEnum; // element specified tracking for attribute
   PRUint8 mCtxType; // X, Y or Unspecified
   PRPackedBool mIsAnimated;
   
+  float GetMMPerPixel(nsIFrame *aNonSVGFrame) const;
+  float GetAxisLength(nsIFrame *aNonSVGFrame) const;
+  float GetEmLength(nsIFrame *aFrame) const
+    { return nsSVGUtils::GetFontSize(aFrame); }
+  float GetExLength(nsIFrame *aFrame) const
+    { return nsSVGUtils::GetFontXHeight(aFrame); }
+  float GetUnitScaleFactor(nsIFrame *aFrame) const;
+
   float GetMMPerPixel(nsSVGSVGElement *aCtx) const;
   float GetAxisLength(nsSVGSVGElement *aCtx) const;
   float GetEmLength(nsSVGElement *aSVGElement) const
     { return nsSVGUtils::GetFontSize(aSVGElement); }
   float GetExLength(nsSVGElement *aSVGElement) const
     { return nsSVGUtils::GetFontXHeight(aSVGElement); }
   float GetUnitScaleFactor(nsSVGElement *aSVGElement) const;
   float GetUnitScaleFactor(nsSVGSVGElement *aCtx) const;
diff -r b7bcdd009540 content/svg/content/src/nsSVGStylableElement.cpp
--- a/content/svg/content/src/nsSVGStylableElement.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/svg/content/src/nsSVGStylableElement.cpp	Thu Sep 11 15:19:24 2008 +0300
@@ -55,17 +55,18 @@ NS_INTERFACE_MAP_END_INHERITING(nsSVGSty
 NS_INTERFACE_MAP_END_INHERITING(nsSVGStylableElementBase)
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsSVGStylableElement::nsSVGStylableElement(nsINodeInfo *aNodeInfo)
   : nsSVGStylableElementBase(aNodeInfo)
 {
-
+  // We never know when we might have a class
+  SetFlags(NODE_MAY_HAVE_CLASS);
 }
 
 nsresult
 nsSVGStylableElement::Init()
 {
   nsresult rv = nsSVGStylableElementBase::Init();
   NS_ENSURE_SUCCESS(rv, rv);
 
@@ -83,17 +84,17 @@ nsSVGStylableElement::Init()
 
   return rv;
 }
 
 //----------------------------------------------------------------------
 // nsIContent methods
 
 const nsAttrValue*
-nsSVGStylableElement::GetClasses() const
+nsSVGStylableElement::DoGetClasses() const
 {
   return mClassName->GetAttrValue();
 }
 
 //----------------------------------------------------------------------
 // nsIDOMSVGStylable methods
 
 /* readonly attribute nsIDOMSVGAnimatedString className; */
diff -r b7bcdd009540 content/svg/content/src/nsSVGStylableElement.h
--- a/content/svg/content/src/nsSVGStylableElement.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/svg/content/src/nsSVGStylableElement.h	Thu Sep 11 15:19:24 2008 +0300
@@ -55,16 +55,16 @@ protected:
   nsresult Init();
 
 public:
   // interfaces:
   NS_DECL_ISUPPORTS_INHERITED
   NS_DECL_NSIDOMSVGSTYLABLE
 
   // nsIContent
-  virtual const nsAttrValue* GetClasses() const;
+  virtual const nsAttrValue* DoGetClasses() const;
 
 protected:
   nsRefPtr<nsSVGClassValue> mClassName;
 };
 
 
 #endif // __NS_SVGSTYLABLEELEMENT_H__
diff -r b7bcdd009540 content/xbl/Makefile.in
--- a/content/xbl/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/xbl/Makefile.in	Thu Sep 11 15:19:24 2008 +0300
@@ -39,13 +39,13 @@ topsrcdir	= @top_srcdir@
 topsrcdir	= @top_srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 DIRS		= public src builtin
 
-ifdef MOZ_MOCHITEST
+ifdef ENABLE_TESTS
 DIRS		+= test
 endif
 
 include $(topsrcdir)/config/rules.mk
diff -r b7bcdd009540 content/xbl/src/nsBindingManager.cpp
--- a/content/xbl/src/nsBindingManager.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/xbl/src/nsBindingManager.cpp	Thu Sep 11 15:19:24 2008 +0300
@@ -87,26 +87,30 @@
 // ==================================================================
 // = nsAnonymousContentList 
 // ==================================================================
 
 #define NS_ANONYMOUS_CONTENT_LIST_IID \
   { 0xa29df1f8, 0xaeca, 0x4356, \
     { 0xa8, 0xc2, 0xa7, 0x24, 0xa2, 0x11, 0x73, 0xac } }
 
-class nsAnonymousContentList : public nsIDOMNodeList
+class nsAnonymousContentList : public nsIDOMNodeList,
+                               public nsINodeList
 {
 public:
   nsAnonymousContentList(nsInsertionPointList* aElements);
   virtual ~nsAnonymousContentList();
 
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
-  NS_DECL_CYCLE_COLLECTION_CLASS(nsAnonymousContentList)
+  NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsAnonymousContentList, nsIDOMNodeList)
   // nsIDOMNodeList interface
   NS_DECL_NSIDOMNODELIST
+
+  // nsINodeList interface
+  virtual nsINode* GetNodeAt(PRUint32 aIndex);
 
   PRInt32 GetInsertionPointCount() { return mElements->Length(); }
 
   nsXBLInsertionPoint* GetInsertionPointAt(PRInt32 i) { return static_cast<nsXBLInsertionPoint*>(mElements->ElementAt(i)); }
   void RemoveInsertionPointAt(PRInt32 i) { mElements->RemoveElementAt(i); }
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_ANONYMOUS_CONTENT_LIST_IID)
 private:
   nsInsertionPointList* mElements;
@@ -131,19 +135,22 @@ nsAnonymousContentList::~nsAnonymousCont
 }
 
 NS_IMPL_CYCLE_COLLECTION_CLASS(nsAnonymousContentList)
 
 NS_IMPL_CYCLE_COLLECTING_ADDREF(nsAnonymousContentList)
 NS_IMPL_CYCLE_COLLECTING_RELEASE(nsAnonymousContentList)
 
 NS_INTERFACE_MAP_BEGIN(nsAnonymousContentList)
+  NS_INTERFACE_MAP_ENTRY(nsINodeList)
   NS_INTERFACE_MAP_ENTRY(nsIDOMNodeList)
-  NS_INTERFACE_MAP_ENTRY(nsAnonymousContentList)
-  NS_INTERFACE_MAP_ENTRY(nsISupports)
+  if (aIID.Equals(NS_GET_IID(nsAnonymousContentList)))
+    foundInterface = static_cast<nsIDOMNodeList*>(this);
+  else
+  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMNodeList)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(NodeList)
   NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION(nsAnonymousContentList)
 NS_INTERFACE_MAP_END
 
 NS_IMPL_CYCLE_COLLECTION_UNLINK_0(nsAnonymousContentList)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsAnonymousContentList)
   {
     PRInt32 i, count = tmp->mElements->Length();
@@ -168,34 +175,41 @@ nsAnonymousContentList::GetLength(PRUint
     *aLength += static_cast<nsXBLInsertionPoint*>(mElements->ElementAt(i))->ChildCount();
 
   return NS_OK;
 }
 
 NS_IMETHODIMP    
 nsAnonymousContentList::Item(PRUint32 aIndex, nsIDOMNode** aReturn)
 {
+  nsINode* item = GetNodeAt(aIndex);
+  if (!item)
+    return NS_ERROR_FAILURE;
+
+  return CallQueryInterface(item, aReturn);    
+}
+
+nsINode*
+nsAnonymousContentList::GetNodeAt(PRUint32 aIndex)
+{
   PRInt32 cnt = mElements->Length();
   PRUint32 pointCount = 0;
 
   for (PRInt32 i = 0; i < cnt; i++) {
     aIndex -= pointCount;
     
     nsXBLInsertionPoint* point = static_cast<nsXBLInsertionPoint*>(mElements->ElementAt(i));
     pointCount = point->ChildCount();
 
     if (aIndex < pointCount) {
-      nsCOMPtr<nsIContent> result = point->ChildAt(aIndex);
-      if (result)
-        return CallQueryInterface(result, aReturn);
-      return NS_ERROR_FAILURE;
+      return point->ChildAt(aIndex);
     }
   }
 
-  return NS_ERROR_FAILURE;
+  return nsnull;
 }
 
 //
 // Generic pldhash table stuff for mapping one nsISupports to another
 //
 // These values are never null - a null value implies that this
 // whole key should be removed (See SetOrRemoveObject)
 class ObjectEntry : public PLDHashEntryHdr
@@ -439,28 +453,32 @@ PR_CALLBACK RemoveInsertionParentCB(PLDH
 {
   return (static_cast<ObjectEntry*>(aEntry)->GetValue() ==
           static_cast<nsISupports*>(aArg)) ? PL_DHASH_REMOVE : PL_DHASH_NEXT;
 }
 
 static void
 RemoveInsertionParentForNodeList(nsIDOMNodeList* aList, nsIContent* aParent)
 {
-  nsCOMPtr<nsAnonymousContentList> list = do_QueryInterface(aList);
+  nsAnonymousContentList* list = nsnull;
+  if (aList) {
+    CallQueryInterface(aList, &list);
+  }
   if (list) {
     PRInt32 count = list->GetInsertionPointCount();
     for (PRInt32 i = 0; i < count; ++i) {
       nsRefPtr<nsXBLInsertionPoint> currPoint = list->GetInsertionPointAt(i);
       currPoint->UnbindDefaultContent();
 #ifdef DEBUG
       nsCOMPtr<nsIContent> parent = currPoint->GetInsertionParent();
       NS_ASSERTION(!parent || parent == aParent, "Wrong insertion parent!");
 #endif
       currPoint->ClearInsertionParent();
     }
+    NS_RELEASE(list);
   }
 }
 
 void
 nsBindingManager::RemoveInsertionParent(nsIContent* aParent)
 {
   nsCOMPtr<nsIDOMNodeList> contentlist;
   GetContentListFor(aParent, getter_AddRefs(contentlist));
@@ -1504,18 +1522,19 @@ nsBindingManager::ContentRemoved(nsIDocu
       }
     }
 
     // Whether the child has a nested insertion point or not, aContainer might
     // have insertion points under it.  If that's the case, we need to remove
     // aChild from the pseudo insertion point it's in.
     if (mContentListTable.ops) {
       nsAnonymousContentList* insertionPointList =
-        static_cast<nsAnonymousContentList*>(LookupObject(mContentListTable,
-                                                          aContainer));
+        static_cast<nsAnonymousContentList*>(
+          static_cast<nsIDOMNodeList*>(LookupObject(mContentListTable,
+                                                    aContainer)));
       if (insertionPointList) {
         RemoveChildFromInsertionPoint(insertionPointList, aChild, PR_TRUE);
       }
     }
   }
 }
 
 void
diff -r b7bcdd009540 content/xbl/src/nsXBLInsertionPoint.cpp
--- a/content/xbl/src/nsXBLInsertionPoint.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/xbl/src/nsXBLInsertionPoint.cpp	Thu Sep 11 15:19:24 2008 +0300
@@ -74,45 +74,38 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_BEGIN(nsXBLInsertionPoint)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mElements)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDefaultContentTemplate)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDefaultContent)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE(nsXBLInsertionPoint, AddRef)
 NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE(nsXBLInsertionPoint, Release)
 
-already_AddRefed<nsIContent>
+nsIContent*
 nsXBLInsertionPoint::GetInsertionParent()
 {
-  NS_IF_ADDREF(mParentElement);
   return mParentElement;
 }
 
-already_AddRefed<nsIContent>
+nsIContent*
 nsXBLInsertionPoint::GetDefaultContent()
 {
-  nsIContent* defaultContent = mDefaultContent;
-  NS_IF_ADDREF(defaultContent);
-  return defaultContent;
+  return mDefaultContent;
 }
 
-already_AddRefed<nsIContent>
+nsIContent*
 nsXBLInsertionPoint::GetDefaultContentTemplate()
 {
-  nsIContent* defaultContent = mDefaultContentTemplate;
-  NS_IF_ADDREF(defaultContent);
-  return defaultContent;
+  return mDefaultContentTemplate;
 }
 
-already_AddRefed<nsIContent>
+nsIContent*
 nsXBLInsertionPoint::ChildAt(PRUint32 aIndex)
 {
-  nsIContent* result = mElements.ObjectAt(aIndex);
-  NS_IF_ADDREF(result);
-  return result;
+  return mElements.ObjectAt(aIndex);
 }
 
 PRBool
 nsXBLInsertionPoint::Matches(nsIContent* aContent, PRUint32 aIndex)
 {
   return (aContent == mParentElement && mIndex != -1 && ((PRInt32)aIndex) == mIndex);
 }
 
diff -r b7bcdd009540 content/xbl/src/nsXBLInsertionPoint.h
--- a/content/xbl/src/nsXBLInsertionPoint.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/xbl/src/nsXBLInsertionPoint.h	Thu Sep 11 15:19:24 2008 +0300
@@ -57,34 +57,34 @@ public:
                   sizeof(nsXBLInsertionPoint));
     return mRefCnt;
   }
 
   nsrefcnt Release();
 
   NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS(nsXBLInsertionPoint)
 
-  already_AddRefed<nsIContent> GetInsertionParent();
+  nsIContent* GetInsertionParent();
   void ClearInsertionParent() { mParentElement = nsnull; }
 
   PRInt32 GetInsertionIndex() { return mIndex; }
 
   void SetDefaultContent(nsIContent* aDefaultContent) { mDefaultContent = aDefaultContent; }
-  already_AddRefed<nsIContent> GetDefaultContent();
+  nsIContent* GetDefaultContent();
 
   void SetDefaultContentTemplate(nsIContent* aDefaultContent) { mDefaultContentTemplate = aDefaultContent; }
-  already_AddRefed<nsIContent> GetDefaultContentTemplate();
+  nsIContent* GetDefaultContentTemplate();
 
   void AddChild(nsIContent* aChildElement) { mElements.AppendObject(aChildElement); }
   void InsertChildAt(PRInt32 aIndex, nsIContent* aChildElement) { mElements.InsertObjectAt(aChildElement, aIndex); }
   void RemoveChild(nsIContent* aChildElement) { mElements.RemoveObject(aChildElement); }
   
   PRInt32 ChildCount() { return mElements.Count(); }
 
-  already_AddRefed<nsIContent> ChildAt(PRUint32 aIndex);
+  nsIContent* ChildAt(PRUint32 aIndex);
 
   PRBool Matches(nsIContent* aContent, PRUint32 aIndex);
 
   // Unbind all the default content in this insertion point.  Used
   // when the insertion parent is going away.
   void UnbindDefaultContent();
 
 protected:
diff -r b7bcdd009540 content/xml/document/Makefile.in
--- a/content/xml/document/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/xml/document/Makefile.in	Thu Sep 11 15:19:24 2008 +0300
@@ -39,14 +39,14 @@ topsrcdir	= @top_srcdir@
 topsrcdir	= @top_srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 DIRS		= public resources src
 
-ifdef MOZ_MOCHITEST
+ifdef ENABLE_TESTS
 DIRS            += test
 endif
 
 include $(topsrcdir)/config/rules.mk
 
diff -r b7bcdd009540 content/xslt/Makefile.in
--- a/content/xslt/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/xslt/Makefile.in	Thu Sep 11 15:19:24 2008 +0300
@@ -40,16 +40,13 @@ srcdir		= @srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 DIRS = public src
 
 ifdef ENABLE_TESTS
-DIRS += tests/buster
-endif
-
-ifdef MOZ_MOCHITEST
-DIRS += tests/mochitest
+DIRS += tests/buster \
+	tests/mochitest
 endif
 
 include $(topsrcdir)/config/rules.mk
diff -r b7bcdd009540 content/xslt/src/xslt/txMozillaXMLOutput.cpp
--- a/content/xslt/src/xslt/txMozillaXMLOutput.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/xslt/src/xslt/txMozillaXMLOutput.cpp	Thu Sep 11 15:19:24 2008 +0300
@@ -255,23 +255,22 @@ txMozillaXMLOutput::endDocument(nsresult
         if (mNotifier) {
             mNotifier->OnTransformEnd(rv);
         }
         
         return rv;
     }
 
     if (!mRefreshString.IsEmpty()) {
-        nsCOMPtr<nsIDocument> doc = do_QueryInterface(mDocument);
-        nsPIDOMWindow *win = doc->GetWindow();
+        nsPIDOMWindow *win = mDocument->GetWindow();
         if (win) {
             nsCOMPtr<nsIRefreshURI> refURI =
                 do_QueryInterface(win->GetDocShell());
             if (refURI) {
-                refURI->SetupRefreshURIFromHeader(doc->GetBaseURI(),
+                refURI->SetupRefreshURIFromHeader(mDocument->GetBaseURI(),
                                                   mRefreshString);
             }
         }
     }
 
     if (mNotifier) {
         mNotifier->OnTransformEnd();
     }
@@ -669,16 +668,19 @@ txMozillaXMLOutput::createTxWrapper()
             NS_ENSURE_SUCCESS(rv, rv);
 
             rv = wrapper->AppendChildTo(childContent, PR_TRUE);
             NS_ENSURE_SUCCESS(rv, rv);
             break;
         }
     }
 
+    if (!mCurrentNodeStack.AppendObject(wrapper)) {
+        return NS_ERROR_OUT_OF_MEMORY;
+    }
     mCurrentNode = wrapper;
     mRootContentCreated = PR_TRUE;
     NS_ASSERTION(rootLocation == mDocument->GetChildCount(),
                  "Incorrect root location");
     return mDocument->AppendChildTo(wrapper, PR_TRUE);
 }
 
 nsresult
@@ -769,28 +771,26 @@ txMozillaXMLOutput::endHTMLElement(nsICo
 
         return NS_OK;
     }
     else if (mCreatingNewDocument && atom == txHTMLAtoms::base &&
              !mHaveBaseElement) {
         // The first base wins
         mHaveBaseElement = PR_TRUE;
 
-        nsCOMPtr<nsIDocument> doc = do_QueryInterface(mDocument);
-        NS_ASSERTION(doc, "document doesn't implement nsIDocument");
         nsAutoString value;
         aElement->GetAttr(kNameSpaceID_None, txHTMLAtoms::target, value);
-        doc->SetBaseTarget(value);
+        mDocument->SetBaseTarget(value);
 
         aElement->GetAttr(kNameSpaceID_None, txHTMLAtoms::href, value);
         nsCOMPtr<nsIURI> baseURI;
         NS_NewURI(getter_AddRefs(baseURI), value, nsnull);
 
         if (baseURI) {
-            doc->SetBaseURI(baseURI); // The document checks if it is legal to set this base
+            mDocument->SetBaseURI(baseURI); // The document checks if it is legal to set this base
         }
     }
     else if (mCreatingNewDocument && atom == txHTMLAtoms::meta) {
         // handle HTTP-EQUIV data
         nsAutoString httpEquiv;
         aElement->GetAttr(kNameSpaceID_None, txHTMLAtoms::httpEquiv, httpEquiv);
         if (!httpEquiv.IsEmpty()) {
             nsAutoString value;
@@ -1087,22 +1087,21 @@ txTransformNotifier::SignalTransformEnd(
     // CSSLoader.
     mPendingStylesheetCount = 0;
     mScriptElements.Clear();
 
     // Make sure that we don't get deleted while this function is executed and
     // we remove ourselfs from the scriptloader
     nsCOMPtr<nsIScriptLoaderObserver> kungFuDeathGrip(this);
 
-    nsCOMPtr<nsIDocument> doc = do_QueryInterface(mDocument);
-    if (doc) {
-        doc->ScriptLoader()->RemoveObserver(this);
+    if (mDocument) {
+        mDocument->ScriptLoader()->RemoveObserver(this);
         // XXX Maybe we want to cancel script loads if NS_FAILED(rv)?
 
         if (NS_FAILED(aResult)) {
-            doc->CSSLoader()->Stop();
+            mDocument->CSSLoader()->Stop();
         }
     }
 
     if (NS_SUCCEEDED(aResult)) {
         mObserver->OnTransformDone(aResult, mDocument);
     }
 }
diff -r b7bcdd009540 content/xslt/tests/mochitest/Makefile.in
--- a/content/xslt/tests/mochitest/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/xslt/tests/mochitest/Makefile.in	Thu Sep 11 15:19:24 2008 +0300
@@ -40,12 +40,13 @@ srcdir		= @srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 relativesrcdir  = content/xslt/tests/mochitest
 
 include $(DEPTH)/config/autoconf.mk
 include $(topsrcdir)/config/rules.mk
 
 _TEST_FILES = 	test_bug319374.xhtml \
+		test_bug440974.html \
 		$(NULL)
 
 libs:: $(_TEST_FILES)
 	$(INSTALL) $(foreach f,$^,"$f") $(DEPTH)/_tests/testing/mochitest/tests/$(relativesrcdir)
diff -r b7bcdd009540 content/xslt/tests/mochitest/test_bug440974.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/xslt/tests/mochitest/test_bug440974.html	Thu Sep 11 15:19:24 2008 +0300
@@ -0,0 +1,50 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=440974
+-->
+<head>
+  <title>Test for Bug 440974</title>
+  <script type="text/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=440974">Mozilla Bug 440974</a>
+<p id="display"></p>
+<div id="content" style="display: none">
+  
+</div>
+<pre id="test">
+<script class="testbody" type="text/javascript">
+
+/** Test for Bug 440974 **/
+
+function isTxResult(node)
+{
+  return node.namespaceURI == "http://www.mozilla.org/TransforMiix" &&
+         node.localName == "result";
+}
+
+var xmldoc, xsltdoc;
+[ xmldoc, xsltdoc ] = [ new DOMParser().parseFromString(String(xml), "text/xml") for each (xml in [ 
+
+    <items><item><id>1</id></item><item><id>2</id></item><item><id>3</id></item></items> ,
+
+    <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
+        <xsl:output method="xml" />
+        <xsl:template match="item"><foo id="{id}"/></xsl:template>
+    </xsl:stylesheet>
+
+]) ];
+var processor = new XSLTProcessor;
+processor.importStylesheet(xsltdoc);
+var result = processor.transformToDocument(xmldoc);
+var resultElements = Array.prototype.filter.call(result.getElementsByTagName('*'), isTxResult);
+is(resultElements.length, 1, "there should be only one 'transformiix:result' element"); 
+is(resultElements[0], result.documentElement, "the 'transformiix:result' element should be the document element"); 
+
+</script>
+</pre>
+</body>
+</html>
diff -r b7bcdd009540 content/xtf/src/nsXTFElementWrapper.cpp
--- a/content/xtf/src/nsXTFElementWrapper.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/xtf/src/nsXTFElementWrapper.cpp	Thu Sep 11 15:19:24 2008 +0300
@@ -68,16 +68,18 @@ nsXTFElementWrapper::nsXTFElementWrapper
                                          nsIXTFElement* aXTFElement)
     : nsXTFElementWrapperBase(aNodeInfo),
       mXTFElement(aXTFElement),
       mNotificationMask(0),
       mIntrinsicState(0),
       mTmpAttrName(nsGkAtoms::_asterix) // XXX this is a hack, but names
                                             // have to have a value
 {
+  // We never know when we might have a class
+  SetFlags(NODE_MAY_HAVE_CLASS);
 }
 
 nsXTFElementWrapper::~nsXTFElementWrapper()
 {
   mXTFElement->OnDestroyed();
   mXTFElement = nsnull;
 }
 
@@ -926,17 +928,17 @@ nsXTFElementWrapper::SetIntrinsicState(P
 
 nsIAtom *
 nsXTFElementWrapper::GetClassAttributeName() const
 {
   return mClassAttributeName;
 }
 
 const nsAttrValue*
-nsXTFElementWrapper::GetClasses() const
+nsXTFElementWrapper::DoGetClasses() const
 {
   const nsAttrValue* val = nsnull;
   nsIAtom* clazzAttr = GetClassAttributeName();
   if (clazzAttr) {
     val = mAttrsAndChildren.GetAttr(clazzAttr);
     // This is possibly the first time we need any classes.
     if (val && val->Type() == nsAttrValue::eString) {
       nsAutoString value;
diff -r b7bcdd009540 content/xtf/src/nsXTFElementWrapper.h
--- a/content/xtf/src/nsXTFElementWrapper.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/xtf/src/nsXTFElementWrapper.h	Thu Sep 11 15:19:24 2008 +0300
@@ -104,17 +104,17 @@ public:
   virtual already_AddRefed<nsINodeInfo> GetExistingAttrNameFromQName(const nsAString& aStr) const;
 
   virtual PRInt32 IntrinsicState() const;
 
   virtual void BeginAddingChildren();
   virtual nsresult DoneAddingChildren(PRBool aHaveNotified);
 
   virtual nsIAtom *GetClassAttributeName() const;
-  virtual const nsAttrValue* GetClasses() const;
+  virtual const nsAttrValue* DoGetClasses() const;
 
   virtual void PerformAccesskey(PRBool aKeyCausesActivation,
                                 PRBool aIsTrustedEvent);
 
   // nsIDOMElement specializations:
   NS_IMETHOD GetAttribute(const nsAString& aName,
                           nsAString& aReturn);
   NS_IMETHOD RemoveAttribute(const nsAString& aName);
diff -r b7bcdd009540 content/xul/content/src/nsXULElement.cpp
--- a/content/xul/content/src/nsXULElement.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/xul/content/src/nsXULElement.cpp	Thu Sep 11 15:19:24 2008 +0300
@@ -1825,21 +1825,19 @@ nsXULElement::GetID() const
 
     if (attrVal && attrVal->Type() == nsAttrValue::eAtom) {
         return attrVal->GetAtomValue();
     }
     return nsnull;
 }
 
 const nsAttrValue*
-nsXULElement::GetClasses() const
+nsXULElement::DoGetClasses() const
 {
-    if (!HasFlag(NODE_MAY_HAVE_CLASS)) {
-        return nsnull;
-    }
+    NS_ASSERTION(HasFlag(NODE_MAY_HAVE_CLASS), "Unexpected call");
     return FindLocalOrProtoAttr(kNameSpaceID_None, nsGkAtoms::_class);
 }
 
 NS_IMETHODIMP
 nsXULElement::WalkContentStyleRules(nsRuleWalker* aRuleWalker)
 {
     return NS_OK;
 }
diff -r b7bcdd009540 content/xul/content/src/nsXULElement.h
--- a/content/xul/content/src/nsXULElement.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/xul/content/src/nsXULElement.h	Thu Sep 11 15:19:24 2008 +0300
@@ -587,17 +587,17 @@ public:
     virtual void RemoveFocus(nsPresContext* aPresContext);
     virtual void PerformAccesskey(PRBool aKeyCausesActivation,
                                   PRBool aIsTrustedEvent);
 
     virtual nsIContent *GetBindingParent() const;
     virtual PRBool IsNodeOfType(PRUint32 aFlags) const;
     virtual PRBool IsFocusable(PRInt32 *aTabIndex = nsnull);
     virtual nsIAtom* GetID() const;
-    virtual const nsAttrValue* GetClasses() const;
+    virtual const nsAttrValue* DoGetClasses() const;
 
     NS_IMETHOD WalkContentStyleRules(nsRuleWalker* aRuleWalker);
     virtual nsICSSStyleRule* GetInlineStyleRule();
     NS_IMETHOD SetInlineStyleRule(nsICSSStyleRule* aStyleRule, PRBool aNotify);
     virtual nsChangeHint GetAttributeChangeHint(const nsIAtom* aAttribute,
                                                 PRInt32 aModType) const;
     NS_IMETHOD_(PRBool) IsAttributeMapped(const nsIAtom* aAttribute) const;
 
diff -r b7bcdd009540 content/xul/document/Makefile.in
--- a/content/xul/document/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/xul/document/Makefile.in	Thu Sep 11 15:19:24 2008 +0300
@@ -40,14 +40,14 @@ srcdir		= @srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 MODULE		= xuldoc
 DIRS		= public src
 
-ifdef MOZ_MOCHITEST
+ifdef ENABLE_TESTS
 DIRS		+= test
 endif
 
 include $(topsrcdir)/config/rules.mk
 
diff -r b7bcdd009540 content/xul/document/crashtests/428951-1.xul
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/xul/document/crashtests/428951-1.xul	Thu Sep 11 15:19:24 2008 +0300
@@ -0,0 +1,21 @@
+<window xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul" xmlns:mathml="http://www.w3.org/1998/Math/MathML">
+<box>
+  <box style="background: -moz-initial;" id="f">
+    <box style="margin-top: -9999999px;"/>
+  </box>
+  <mathml:divergence>
+    <box/>
+  </mathml:divergence>
+  <mathml:moment command="f"/>
+</box>
+
+<script id="script" xmlns="http://www.w3.org/1999/xhtml"><![CDATA[
+function init() {
+    var f = document.getElementsByTagName('mathml:divergence')[0];
+    window.addEventListener('DOMAttrModified',function() { f.parentNode.removeChild(f);}, true);
+    var x=document.getElementsByTagName('mathml:moment')[0];
+    x.parentNode.removeChild(x);
+}
+window.addEventListener("load", init, false);
+]]></script>
+</window>
diff -r b7bcdd009540 content/xul/document/crashtests/crashtests.list
--- a/content/xul/document/crashtests/crashtests.list	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/xul/document/crashtests/crashtests.list	Thu Sep 11 15:19:24 2008 +0300
@@ -1,2 +1,3 @@ load 326204-1.xul
 load 326204-1.xul
 load 344215-1.xul
+load 428951-1.xul
diff -r b7bcdd009540 content/xul/document/src/nsXULDocument.cpp
--- a/content/xul/document/src/nsXULDocument.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/content/xul/document/src/nsXULDocument.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -307,28 +307,31 @@ NS_IMPL_CYCLE_COLLECTION_CLASS(nsXULDocu
 
 static PLDHashOperator PR_CALLBACK
 TraverseTemplateBuilders(nsISupports* aKey, nsIXULTemplateBuilder* aData,
                          void* aContext)
 {
     nsCycleCollectionTraversalCallback *cb =
         static_cast<nsCycleCollectionTraversalCallback*>(aContext);
 
+    NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb, "mTemplateBuilderTable key");
     cb->NoteXPCOMChild(aKey);
+    NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb, "mTemplateBuilderTable value");
     cb->NoteXPCOMChild(aData);
 
     return PL_DHASH_NEXT;
 }
 
 static PLDHashOperator PR_CALLBACK
 TraverseObservers(nsIURI* aKey, nsIObserver* aData, void* aContext)
 {
     nsCycleCollectionTraversalCallback *cb =
         static_cast<nsCycleCollectionTraversalCallback*>(aContext);
 
+    NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb, "mOverlayLoadObservers/mPendingOverlayLoadNotifications value");
     cb->NoteXPCOMChild(aData);
 
     return PL_DHASH_NEXT;
 }
 
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsXULDocument, nsXMLDocument)
     // XXX tmp->mForwardReferences?
     // XXX tmp->mContextStack?
@@ -342,16 +345,17 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_
                                                      nsIScriptGlobalObjectOwner)
     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mMasterPrototype,
                                                      nsIScriptGlobalObjectOwner)
     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mCommandDispatcher,
                                                      nsIDOMXULCommandDispatcher)
 
     PRUint32 i, count = tmp->mPrototypes.Length();
     for (i = 0; i < count; ++i) {
+        NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mPrototypes[i]");
         cb.NoteXPCOMChild(static_cast<nsIScriptGlobalObjectOwner*>(tmp->mPrototypes[i]));
     }
 
     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mTooltipNode)
     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mLocalStore)
 
     if (tmp->mOverlayLoadObservers.IsInitialized())
         tmp->mOverlayLoadObservers.EnumerateRead(TraverseObservers, &cb);
@@ -845,18 +849,16 @@ nsXULDocument::RemoveBroadcastListenerFo
 
             if ((blListener == aListener) && (bl->mAttribute == attr)) {
                 entry->mListeners.RemoveElementAt(i);
                 delete bl;
 
                 if (entry->mListeners.Count() == 0)
                     PL_DHashTableOperate(mBroadcasterMap, aBroadcaster,
                                          PL_DHASH_REMOVE);
-
-                SynchronizeBroadcastListener(aBroadcaster, aListener, aAttr);
 
                 break;
             }
         }
     }
 
     return NS_OK;
 }
diff -r b7bcdd009540 docshell/Makefile.in
--- a/docshell/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/docshell/Makefile.in	Thu Sep 11 15:19:25 2008 +0300
@@ -46,13 +46,13 @@ MODULE = docshell
 MODULE = docshell
 DIRS = \
 	base \
 	shistory \
 	build \
 	resources \
 	$(NULL)
 
-ifdef MOZ_MOCHITEST
+ifdef ENABLE_TESTS
 DIRS		+= test
 endif
 
 include $(topsrcdir)/config/rules.mk
diff -r b7bcdd009540 docshell/base/crashtests/436900-1-inner.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/docshell/base/crashtests/436900-1-inner.html	Thu Sep 11 15:19:25 2008 +0300
@@ -0,0 +1,21 @@
+<!DOCTYPE html>
+<html>
+<head>
+
+<meta http-equiv="refresh" content="0">
+
+<script language="javascript">
+
+location.hash += "+++";
+
+function done()
+{
+  parent.document.documentElement.removeAttribute("class");    
+}
+
+</script>
+</head>
+<body onload="setTimeout(done, 10)">
+
+</body>
+</html>
diff -r b7bcdd009540 docshell/base/crashtests/436900-1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/docshell/base/crashtests/436900-1.html	Thu Sep 11 15:19:25 2008 +0300
@@ -0,0 +1,8 @@
+<!DOCTYPE html>
+<html class="reftest-wait">
+<head>
+</head>
+<body>
+<iframe src="436900-1-inner.html#foo"></iframe>
+</body>
+</html>
diff -r b7bcdd009540 docshell/base/crashtests/crashtests.list
--- a/docshell/base/crashtests/crashtests.list	Mon Sep 08 00:36:19 2008 -0700
+++ b/docshell/base/crashtests/crashtests.list	Thu Sep 11 15:19:25 2008 +0300
@@ -1,2 +1,3 @@ load 369126-1.html
 load 369126-1.html
 load 403574-1.xhtml
+load 436900-1.html
diff -r b7bcdd009540 docshell/base/nsDocShell.cpp
--- a/docshell/base/nsDocShell.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/docshell/base/nsDocShell.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -302,18 +302,16 @@ nsDocShell::nsDocShell():
     mSavingOldViewer(PR_FALSE),
     mAppType(nsIDocShell::APP_TYPE_UNKNOWN),
     mChildOffset(0),
     mBusyFlags(BUSY_FLAGS_NONE),
     mMarginWidth(0),
     mMarginHeight(0),
     mItemType(typeContent),
     mDefaultScrollbarPref(Scrollbar_Auto, Scrollbar_Auto),
-    mPreviousTransIndex(-1),
-    mLoadedTransIndex(-1),
     mTreeOwner(nsnull),
     mChromeEventHandler(nsnull)
 #ifdef DEBUG
     , mInEnsureScriptEnv(PR_FALSE)
 #endif
 {
     if (gDocShellCount++ == 0) {
         NS_ASSERTION(sURIFixup == nsnull,
@@ -1628,52 +1626,16 @@ nsDocShell::SetUseErrorPages(PRBool aUse
             mObserveErrorPages = PR_FALSE;
         }
     }
     mUseErrorPages = aUseErrorPages;
     return NS_OK;
 }
 
 NS_IMETHODIMP
-nsDocShell::GetPreviousTransIndex(PRInt32 *aPreviousTransIndex)
-{
-    *aPreviousTransIndex = mPreviousTransIndex;
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsDocShell::GetLoadedTransIndex(PRInt32 *aLoadedTransIndex)
-{
-    *aLoadedTransIndex = mLoadedTransIndex;
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsDocShell::HistoryPurged(PRInt32 aNumEntries)
-{
-    // These indices are used for fastback cache eviction, to determine
-    // which session history entries are candidates for content viewer
-    // eviction.  We need to adjust by the number of entries that we
-    // just purged from history, so that we look at the right session history
-    // entries during eviction.
-    mPreviousTransIndex = PR_MAX(-1, mPreviousTransIndex - aNumEntries);
-    mLoadedTransIndex = PR_MAX(0, mLoadedTransIndex - aNumEntries);
-
-    PRInt32 count = mChildList.Count();
-    for (PRInt32 i = 0; i < count; ++i) {
-        nsCOMPtr<nsIDocShell> shell = do_QueryInterface(ChildAt(i));
-        if (shell) {
-            shell->HistoryPurged(aNumEntries);
-        }
-    }
-
-    return NS_OK;
-}
-
-NS_IMETHODIMP
 nsDocShell::GetSessionStorageForURI(nsIURI* aURI,
                                     nsIDOMStorage** aStorage)
 {
     NS_ENSURE_ARG_POINTER(aStorage);
 
     *aStorage = nsnull;
 
     nsCOMPtr<nsIDocShellTreeItem> topItem;
@@ -2708,38 +2670,21 @@ nsDocShell::DoAddChildSHEntry(nsISHEntry
 {
     /* You will get here when you are in a subframe and
      * a new url has been loaded on you. 
      * The mOSHE in this subframe will be the previous url's
      * mOSHE. This mOSHE will be used as the identification
      * for this subframe in the  CloneAndReplace function.
      */
 
-    // In this case, we will end up calling AddEntry, which increases the
-    // current index by 1
-    nsCOMPtr<nsISHistory> rootSH;
-    GetRootSessionHistory(getter_AddRefs(rootSH));
-    if (rootSH) {
-        rootSH->GetIndex(&mPreviousTransIndex);
-    }
-
     nsresult rv;
     nsCOMPtr<nsIDocShellHistory> parent =
         do_QueryInterface(GetAsSupports(mParent), &rv);
     if (parent) {
         rv = parent->AddChildSHEntry(mOSHE, aNewEntry, aChildOffset);
-    }
-
-
-    if (rootSH) {
-        rootSH->GetIndex(&mLoadedTransIndex);
-#ifdef DEBUG_PAGE_CACHE
-        printf("Previous index: %d, Loaded index: %d\n\n", mPreviousTransIndex,
-               mLoadedTransIndex);
-#endif
     }
 
     return rv;
 }
 
 NS_IMETHODIMP
 nsDocShell::SetUseGlobalHistory(PRBool aUseGlobalHistory)
 {
@@ -4428,16 +4373,41 @@ nsDocShell::RefreshURI(nsIURI * aURI, PR
         // timer and fire it right away.
         nsCOMPtr<nsITimer> timer = do_CreateInstance("@mozilla.org/timer;1");
         NS_ENSURE_TRUE(timer, NS_ERROR_FAILURE);
 
         mRefreshURIList->AppendElement(timer);      // owning timer ref
         timer->InitWithCallback(refreshTimer, aDelay, nsITimer::TYPE_ONE_SHOT);
     }
     return NS_OK;
+}
+
+nsresult
+nsDocShell::ForceRefreshURIFromTimer(nsIURI * aURI,
+                                     PRInt32 aDelay, 
+                                     PRBool aMetaRefresh,
+                                     nsITimer* aTimer)
+{
+    NS_PRECONDITION(aTimer, "Must have a timer here");
+
+    // Remove aTimer from mRefreshURIList if needed
+    if (mRefreshURIList) {
+        PRUint32 n = 0;
+        mRefreshURIList->Count(&n);
+
+        for (PRUint32 i = 0;  i < n; ++i) {
+            nsCOMPtr<nsITimer> timer = do_QueryElementAt(mRefreshURIList, i);
+            if (timer == aTimer) {
+                mRefreshURIList->RemoveElementAt(i);
+                break;
+            }
+        }
+    }
+
+    return ForceRefreshURI(aURI, aDelay, aMetaRefresh);
 }
 
 NS_IMETHODIMP
 nsDocShell::ForceRefreshURI(nsIURI * aURI,
                             PRInt32 aDelay, 
                             PRBool aMetaRefresh)
 {
     NS_ENSURE_ARG(aURI);
@@ -5411,22 +5381,27 @@ nsresult
 nsresult
 nsDocShell::CaptureState()
 {
     if (!mOSHE || mOSHE == mLSHE) {
         // No entry to save into, or we're replacing the existing entry.
         return NS_ERROR_FAILURE;
     }
 
+    PRBool shouldSaveContentViewer = PR_FALSE;
+    nsresult rv = mOSHE->GetSaveContentViewerFlag(&shouldSaveContentViewer);
+    if (NS_FAILED(rv) || !shouldSaveContentViewer)
+        return NS_ERROR_FAILURE;
+
     nsCOMPtr<nsPIDOMWindow> privWin = do_QueryInterface(mScriptGlobal);
     if (!privWin)
         return NS_ERROR_FAILURE;
 
     nsCOMPtr<nsISupports> windowState;
-    nsresult rv = privWin->SaveWindowState(getter_AddRefs(windowState));
+    rv = privWin->SaveWindowState(getter_AddRefs(windowState));
     NS_ENSURE_SUCCESS(rv, rv);
 
 #ifdef DEBUG_PAGE_CACHE
     nsCOMPtr<nsIURI> uri;
     mOSHE->GetURI(getter_AddRefs(uri));
     nsCAutoString spec;
     if (uri)
         uri->GetSpec(spec);
@@ -5727,23 +5702,17 @@ nsDocShell::RestoreFromHistory()
     // *new* document will fire.
     mFiredUnloadEvent = PR_FALSE;
 
     mURIResultedInDocument = PR_TRUE;
     nsCOMPtr<nsISHistory> rootSH;
     GetRootSessionHistory(getter_AddRefs(rootSH));
     if (rootSH) {
         nsCOMPtr<nsISHistoryInternal> hist = do_QueryInterface(rootSH);
-        rootSH->GetIndex(&mPreviousTransIndex);
         hist->UpdateIndex();
-        rootSH->GetIndex(&mLoadedTransIndex);
-#ifdef DEBUG_PAGE_CACHE
-        printf("Previous index: %d, Loaded index: %d\n\n", mPreviousTransIndex,
-                   mLoadedTransIndex);
-#endif
     }
 
     // Rather than call Embed(), we will retrieve the viewer from the session
     // history entry and swap it in.
     // XXX can we refactor this so that we can just call Embed()?
     PersistLayoutHistoryState();
     nsresult rv;
     if (mContentViewer) {
@@ -8051,23 +8020,17 @@ nsDocShell::OnNewURI(nsIURI * aURI, nsIC
         }
     }
 
     // If this was a history load, update the index in 
     // SH. 
     if (rootSH && (mLoadType & LOAD_CMD_HISTORY)) {
         nsCOMPtr<nsISHistoryInternal> shInternal(do_QueryInterface(rootSH));
         if (shInternal) {
-            rootSH->GetIndex(&mPreviousTransIndex);
             shInternal->UpdateIndex();
-            rootSH->GetIndex(&mLoadedTransIndex);
-#ifdef DEBUG_PAGE_CACHE
-            printf("Previous index: %d, Loaded index: %d\n\n",
-                   mPreviousTransIndex, mLoadedTransIndex);
-#endif
         }
     }
     PRBool onLocationChangeNeeded = SetCurrentURI(aURI, aChannel,
                                                   aFireOnLocationChange);
     // Make sure to store the referrer from the channel, if any
     SetupReferrerFromChannel(aChannel);
     return onLocationChangeNeeded;
 }
@@ -8264,23 +8227,17 @@ nsDocShell::AddToSessionHistory(nsIURI *
             if (shPrivate)
                 rv = shPrivate->ReplaceEntry(index, entry);          
         }
         else {
             // Add to session history
             nsCOMPtr<nsISHistoryInternal>
                 shPrivate(do_QueryInterface(mSessionHistory));
             NS_ENSURE_TRUE(shPrivate, NS_ERROR_FAILURE);
-            mSessionHistory->GetIndex(&mPreviousTransIndex);
             rv = shPrivate->AddEntry(entry, shouldPersist);
-            mSessionHistory->GetIndex(&mLoadedTransIndex);
-#ifdef DEBUG_PAGE_CACHE
-            printf("Previous index: %d, Loaded index: %d\n\n",
-                   mPreviousTransIndex, mLoadedTransIndex);
-#endif
         }
     }
     else {  
         // This is a subframe.
         if (!mOSHE || !LOAD_TYPE_HAS_FLAGS(mLoadType,
                                            LOAD_FLAGS_REPLACE_HISTORY))
             rv = DoAddChildSHEntry(entry, mChildOffset);
     }
@@ -9298,19 +9255,17 @@ nsRefreshTimer::Notify(nsITimer * aTimer
 nsRefreshTimer::Notify(nsITimer * aTimer)
 {
     NS_ASSERTION(mDocShell, "DocShell is somehow null");
 
     if (mDocShell && aTimer) {
         // Get the delay count to determine load type
         PRUint32 delay = 0;
         aTimer->GetDelay(&delay);
-        nsCOMPtr<nsIRefreshURI> refreshURI = do_QueryInterface(mDocShell);
-        if (refreshURI)
-            refreshURI->ForceRefreshURI(mURI, delay, mMetaRefresh);
+        mDocShell->ForceRefreshURIFromTimer(mURI, delay, mMetaRefresh, aTimer);
     }
     return NS_OK;
 }
 
 //*****************************************************************************
 //***    nsDocShellFocusController: Object Management
 //*****************************************************************************
 void 
diff -r b7bcdd009540 docshell/base/nsDocShell.h
--- a/docshell/base/nsDocShell.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/docshell/base/nsDocShell.h	Thu Sep 11 15:19:25 2008 +0300
@@ -104,16 +104,17 @@
 #include "nsISecureBrowserUI.h"
 #include "nsIObserver.h"
 #include "nsDocShellLoadTypes.h"
 #include "nsPIDOMEventTarget.h"
 #include "nsIURIClassifier.h"
 #include "nsIChannelClassifier.h"
 
 class nsIScrollableView;
+class nsDocShell;
 
 /* load commands were moved to nsIDocShell.h */
 /* load types were moved to nsDocShellLoadTypes.h */
 
 /* internally used ViewMode types */
 enum ViewMode {
     viewNormal = 0x0,
     viewSource = 0x1
@@ -128,17 +129,17 @@ public:
 public:
     nsRefreshTimer();
 
     NS_DECL_ISUPPORTS
     NS_DECL_NSITIMERCALLBACK
 
     PRInt32 GetDelay() { return mDelay ;}
 
-    nsCOMPtr<nsIDocShell> mDocShell;
+    nsRefPtr<nsDocShell>  mDocShell;
     nsCOMPtr<nsIURI>      mURI;
     PRInt32               mDelay;
     PRPackedBool          mRepeat;
     PRPackedBool          mMetaRefresh;
     
 protected:
     virtual ~nsRefreshTimer();
 };
@@ -229,16 +230,23 @@ public:
 
     // nsIScriptGlobalObjectOwner methods
     virtual nsIScriptGlobalObject* GetScriptGlobalObject();
 
     // Restores a cached presentation from history (mLSHE).
     // This method swaps out the content viewer and simulates loads for
     // subframes.  It then simulates the completion of the toplevel load.
     nsresult RestoreFromHistory();
+
+    // Perform a URI load from a refresh timer.  This is just like the
+    // ForceRefreshURI method on nsIRefreshURI, but makes sure to take
+    // the timer involved out of mRefreshURIList if it's there.
+    // aTimer must not be null.
+    nsresult ForceRefreshURIFromTimer(nsIURI * aURI, PRInt32 aDelay,
+                                      PRBool aMetaRefresh, nsITimer* aTimer);
 
 protected:
     // Object Management
     virtual ~nsDocShell();
     virtual void DestroyChildren();
 
     // Content Viewer Management
     NS_IMETHOD EnsureContentViewer();
@@ -635,21 +643,16 @@ protected:
     // Holds a weak pointer to a RestorePresentationEvent object if any that
     // holds a weak pointer back to us.  We use this pointer to possibly revoke
     // the event whenever necessary.
     nsRevocableEventPtr<RestorePresentationEvent> mRestorePresentationEvent;
 
     // hash of session storages, keyed by domain
     nsInterfaceHashtable<nsCStringHashKey, nsIDOMStorage> mStorages;
 
-    // Index into the SHTransaction list, indicating the previous and current
-    // transaction at the time that this DocShell begins to load
-    PRInt32                    mPreviousTransIndex;
-    PRInt32                    mLoadedTransIndex;
-
     // Editor data, if this document is designMode or contentEditable.
     nsAutoPtr<nsDocShellEditorData> mEditorData;
 
     // Transferable hooks/callbacks
     nsCOMPtr<nsIClipboardDragDropHookList>  mTransferableHookData;
 
     // Secure browser UI object
     nsCOMPtr<nsISecureBrowserUI> mSecurityUI;
diff -r b7bcdd009540 docshell/base/nsIDocShell.idl
--- a/docshell/base/nsIDocShell.idl	Mon Sep 08 00:36:19 2008 -0700
+++ b/docshell/base/nsIDocShell.idl	Thu Sep 11 15:19:25 2008 +0300
@@ -63,17 +63,17 @@ interface nsISimpleEnumerator;
 interface nsISimpleEnumerator;
 interface nsIInputStream;
 interface nsIRequest;
 interface nsISHEntry;
 interface nsILayoutHistoryState;
 interface nsISecureBrowserUI;
 interface nsIDOMStorage;
 
-[scriptable, uuid(7d1cf6b9-daa3-476d-8f9f-9eb2a971a95c)]
+[scriptable, uuid(cf974f45-d2f1-4bd5-aecd-568a1c4da454)]
 interface nsIDocShell : nsISupports
 {
   /**
    * Loads a given URI.  This will give priority to loading the requested URI
    * in the object implementing	this interface.  If it can't be loaded here
    * however, the URL dispatcher will go through its normal process of content
    * loading.
    *
@@ -395,32 +395,16 @@ interface nsIDocShell : nsISupports
   void finishRestore();
 
   /* Track whether we're currently restoring a document presentation. */
   readonly attribute boolean restoringDocument;
 
   /* attribute to access whether error pages are enabled */
   attribute boolean useErrorPages;
 
-  /**
-   * Keeps track of the previous SHTransaction index and the current
-   * SHTransaction index at the time that the doc shell begins to load.
-   * Used for ContentViewer eviction.
-   */
-  readonly attribute long previousTransIndex;
-  readonly attribute long loadedTransIndex;
-
-  /**
-   * Notification that entries have been removed from the beginning of a
-   * nsSHistory which has this as its rootDocShell.
-   *
-   * @param numEntries - The number of entries removed
-   */
-  void historyPurged(in long numEntries);
-
   /*
    * Retrieves the WebApps session storage object for the supplied domain.
    * If it doesn't already exist, a new one will be created.
    *
    * @param domain the domain of the storage object to retrieve
    */
   nsIDOMStorage getSessionStorageForURI(in nsIURI uri);
 
diff -r b7bcdd009540 docshell/base/nsWebShell.cpp
--- a/docshell/base/nsWebShell.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/docshell/base/nsWebShell.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -1234,23 +1234,17 @@ nsresult nsWebShell::EndPageLoad(nsIWebP
             rootAsWebnav->GetSessionHistory(getter_AddRefs(rootSH));
             }
           }
         }  // mSessionHistory
 
         if (rootSH && (mLoadType & LOAD_CMD_HISTORY)) {
           nsCOMPtr<nsISHistoryInternal> shInternal(do_QueryInterface(rootSH));
           if (shInternal) {
-            rootSH->GetIndex(&mPreviousTransIndex);
             shInternal->UpdateIndex();
-            rootSH->GetIndex(&mLoadedTransIndex);
-#ifdef DEBUG_PAGE_CACHE
-            printf("Previous index: %d, Loaded index: %d\n\n",
-                  mPreviousTransIndex, mLoadedTransIndex);
-#endif
           }
         }
 
         // Make it look like we really did honestly finish loading the
         // history page we were loading, since the "reload" load we're
         // about to kick off will reload our current history entry.  This
         // is a bit of a hack, and if the force-load fails I think we'll
         // end up being confused about what page we're on... but we would
diff -r b7bcdd009540 docshell/shistory/public/nsISHEntry.idl
--- a/docshell/shistory/public/nsISHEntry.idl	Mon Sep 08 00:36:19 2008 -0700
+++ b/docshell/shistory/public/nsISHEntry.idl	Thu Sep 11 15:19:25 2008 +0300
@@ -53,17 +53,17 @@ interface nsISupportsArray;
 %{C++
 struct nsRect;
 class nsDocShellEditorData;
 %}
 [ref] native nsRect(nsRect);
 [ptr] native nsDocShellEditorDataPtr(nsDocShellEditorData);
 
 
-[scriptable, uuid(c16fde76-3108-450e-8c8c-ae8286f286ed)]
+[scriptable, uuid(622412da-be41-407e-b57e-9aba2a282b00)]
 interface nsISHEntry : nsIHistoryEntry
 {
     /** URI for the document */
     void setURI(in nsIURI aURI);
 
     /** Referrer URI */
     attribute nsIURI referrerURI;
 
@@ -147,16 +147,19 @@ interface nsISHEntry : nsIHistoryEntry
      * entries are separated by an anchor traversal or a subframe navigation in
      * some other frame).
      */
     attribute unsigned long pageIdentifier;
 
     /** attribute to set and get the cache key for the entry */
     attribute nsISupports cacheKey;
 
+    /** attribute to indicate whether the contentViewer should be saved */
+    attribute boolean saveContentViewerFlag;
+
     /** attribute to indicate whether layoutHistoryState should be saved */
     attribute boolean saveLayoutStateFlag;
 
     /** attribute to indicate whether the page is already expired in cache */
     attribute boolean expirationStatus;
 
     /**
      * attribute to indicate the content-type of the document that this
diff -r b7bcdd009540 docshell/shistory/public/nsISHistoryInternal.idl
--- a/docshell/shistory/public/nsISHistoryInternal.idl	Mon Sep 08 00:36:19 2008 -0700
+++ b/docshell/shistory/public/nsISHistoryInternal.idl	Thu Sep 11 15:19:25 2008 +0300
@@ -47,17 +47,17 @@ interface nsIDocShell;
 %{C++
 #define NS_SHISTORY_INTERNAL_CID \
 { 0x9c47c121, 0x1c6e, 0x4d8f, \
   { 0xb9, 0x04, 0x3a, 0xc9, 0x68, 0x11, 0x6e, 0x88 } }
 
 #define NS_SHISTORY_INTERNAL_CONTRACTID "@mozilla.org/browser/shistory-internal;1"
 %}
 
-[scriptable, uuid(9c47c121-1c6e-4d8f-b904-3ac968116e88)]
+[scriptable, uuid(0e91697a-4ba0-4ede-b08a-0bae9ee1a701)]
 interface nsISHistoryInternal: nsISupports
 {
   /**
    * Add a new Entry to the History List
    * @param aEntry - The entry to add
    * @param aPersist - If true this specifies that the entry should persist
    * in the list.  If false, this means that when new entries are added
    * this element will not appear in the session history list.
@@ -87,22 +87,20 @@ interface nsISHistoryInternal: nsISuppor
    void replaceEntry(in long aIndex, in nsISHEntry aReplaceEntry);
 
   /** 
    * Get handle to the history listener
    */
    readonly attribute nsISHistoryListener listener;
 
   /**
-   * Evict content viewers until the number of content viewers per tab
-   * is no more than gHistoryMaxViewers.  Also, count
-   * total number of content viewers globally and evict one if we are over
-   * our total max.  This is always called in Show(), after we destroy
-   * the previous viewer.
+   * Count total number of content viewers globally and evict one if we are over
+   * our total max.  This is always called in Show(), after we destroy the
+   * previous viewer.
    */
-   void evictContentViewers(in long previousIndex, in long index);
+   void evictContentViewers();
    
    /**
     * Evict the content viewer associated with a session history entry
     * that has timed out.
     */
    void evictExpiredContentViewerForEntry(in nsISHEntry aEntry);
 };
diff -r b7bcdd009540 docshell/shistory/src/nsSHEntry.cpp
--- a/docshell/shistory/src/nsSHEntry.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/docshell/shistory/src/nsSHEntry.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -101,16 +101,17 @@ static void StopTrackingEntry(nsSHEntry 
 
 
 nsSHEntry::nsSHEntry() 
   : mLoadType(0)
   , mID(gEntryID++)
   , mPageIdentifier(mID)
   , mScrollPositionX(0)
   , mScrollPositionY(0)
+  , mSaveContentViewer(PR_TRUE)
   , mIsFrameNavigation(PR_FALSE)
   , mSaveLayoutState(PR_TRUE)
   , mExpired(PR_FALSE)
   , mSticky(PR_TRUE)
   , mParent(nsnull)
   , mViewerBounds(0, 0, 0, 0)
 {
 }
@@ -122,16 +123,17 @@ nsSHEntry::nsSHEntry(const nsSHEntry &ot
   , mTitle(other.mTitle)
   , mPostData(other.mPostData)
   , mLayoutHistoryState(other.mLayoutHistoryState)
   , mLoadType(0)         // XXX why not copy?
   , mID(other.mID)
   , mPageIdentifier(other.mPageIdentifier)
   , mScrollPositionX(0)  // XXX why not copy?
   , mScrollPositionY(0)  // XXX why not copy?
+  , mSaveContentViewer(other.mSaveContentViewer)
   , mIsFrameNavigation(other.mIsFrameNavigation)
   , mSaveLayoutState(other.mSaveLayoutState)
   , mExpired(other.mExpired)
   , mSticky(PR_TRUE)
   // XXX why not copy mContentType?
   , mCacheKey(other.mCacheKey)
   , mParent(other.mParent)
   , mViewerBounds(0, 0, 0, 0)
@@ -408,16 +410,28 @@ NS_IMETHODIMP nsSHEntry::GetCacheKey(nsI
   *aResult = mCacheKey;
   NS_IF_ADDREF(*aResult);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsSHEntry::SetCacheKey(nsISupports* aCacheKey)
 {
   mCacheKey = aCacheKey;
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsSHEntry::GetSaveContentViewerFlag(PRBool * aFlag)
+{
+  *aFlag = mSaveContentViewer;
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsSHEntry::SetSaveContentViewerFlag(PRBool  aFlag)
+{
+  mSaveContentViewer = aFlag;
   return NS_OK;
 }
 
 NS_IMETHODIMP nsSHEntry::GetSaveLayoutStateFlag(PRBool * aFlag)
 {
   *aFlag = mSaveLayoutState;
   return NS_OK;
 }
diff -r b7bcdd009540 docshell/shistory/src/nsSHEntry.h
--- a/docshell/shistory/src/nsSHEntry.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/docshell/shistory/src/nsSHEntry.h	Thu Sep 11 15:19:25 2008 +0300
@@ -97,16 +97,17 @@ private:
   nsCOMPtr<nsIInputStream>        mPostData;
   nsCOMPtr<nsILayoutHistoryState> mLayoutHistoryState;
   nsCOMArray<nsISHEntry>          mChildren;
   PRUint32                        mLoadType;  
   PRUint32                        mID;
   PRUint32                        mPageIdentifier;
   PRInt32                         mScrollPositionX;
   PRInt32                         mScrollPositionY;
+  PRPackedBool                    mSaveContentViewer;
   PRPackedBool                    mIsFrameNavigation;
   PRPackedBool                    mSaveLayoutState;
   PRPackedBool                    mExpired;
   PRPackedBool                    mSticky;
   nsCString                       mContentType;
   nsCOMPtr<nsISupports>           mCacheKey;
   nsISHEntry *                    mParent;  // weak reference
   nsCOMPtr<nsISupports>           mWindowState;
diff -r b7bcdd009540 docshell/shistory/src/nsSHistory.cpp
--- a/docshell/shistory/src/nsSHistory.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/docshell/shistory/src/nsSHistory.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -325,26 +325,29 @@ nsSHistory::AddEntry(nsISHEntry * aSHEnt
   // Set the ShEntry and parent for the transaction. setting the 
   // parent will properly set the parent child relationship
   txn->SetPersist(aPersist);
   NS_ENSURE_SUCCESS(txn->Create(aSHEntry, currentTxn), NS_ERROR_FAILURE);
    
   // A little tricky math here...  Basically when adding an object regardless of
   // what the length was before, it should always be set back to the current and
   // lop off the forward.
+  PRInt32 oldIndex = mIndex;
   mLength = (++mIndex + 1);
 
   // If this is the very first transaction, initialize the list
   if(!mListRoot)
     mListRoot = txn;
 
   // Purge History list if it is too long
   if ((gHistoryMaxSize >= 0) && (mLength > gHistoryMaxSize))
     PurgeHistory(mLength-gHistoryMaxSize);
   
+  // Evict a content viewer if we might have too many behind us
+  EvictWindowContentViewers(oldIndex, mIndex);
   return NS_OK;
 }
 
 /* Get size of the history list */
 NS_IMETHODIMP
 nsSHistory::GetCount(PRInt32 * aResult)
 {
   NS_ENSURE_ARG_POINTER(aResult);
@@ -578,19 +581,16 @@ nsSHistory::PurgeHistory(PRInt32 aEntrie
   mIndex -= cnt;
 
   // Now if we were not at the end of the history, mIndex could have
   // become far too negative.  If so, just set it to -1.
   if (mIndex < -1) {
     mIndex = -1;
   }
 
-  if (mRootDocShell)
-    mRootDocShell->HistoryPurged(cnt);
-
   return NS_OK;
 }
 
 
 NS_IMETHODIMP
 nsSHistory::AddSHistoryListener(nsISHistoryListener * aListener)
 {
   NS_ENSURE_ARG_POINTER(aListener);
@@ -650,20 +650,18 @@ nsSHistory::GetListener(nsISHistoryListe
   NS_ENSURE_ARG_POINTER(aListener);
   if (mListener) 
     CallQueryReferent(mListener.get(),  aListener);
   // Don't addref aListener. It is a weak pointer.
   return NS_OK;
 }
 
 NS_IMETHODIMP
-nsSHistory::EvictContentViewers(PRInt32 aPreviousIndex, PRInt32 aIndex)
+nsSHistory::EvictContentViewers()
 {
-  // Check our per SHistory object limit in the currently navigated SHistory
-  EvictWindowContentViewers(aPreviousIndex, aIndex);
   // Check our total limit across all SHistory objects
   EvictGlobalContentViewer();
   return NS_OK;
 }
 
 //*****************************************************************************
 //    nsSHistory: nsIWebNavigation
 //*****************************************************************************
@@ -1121,16 +1119,25 @@ nsSHistory::LoadURI(const PRUnichar* aUR
                     nsIInputStream* aExtraHeaderStream)
 {
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsSHistory::GotoIndex(PRInt32 aIndex)
 {
+ 
+  if (mIndex > -1 && PR_ABS(aIndex - mIndex) > gHistoryMaxViewers) {
+    // The current entry is too far from the new index, so mark it so its
+    // content viewer doesn't get saved.
+    nsCOMPtr<nsISHEntry> currentEntry;
+    nsresult rv = GetEntryAtIndex(mIndex, PR_FALSE, getter_AddRefs(currentEntry));
+    if (NS_SUCCEEDED(rv) && currentEntry)
+      currentEntry->SetSaveContentViewerFlag(PR_FALSE);
+  }
   return LoadEntry(aIndex, nsIDocShellLoadInfo::loadHistory, HIST_CMD_GOTOINDEX);
 }
 
 NS_IMETHODIMP
 nsSHistory::LoadEntry(PRInt32 aIndex, long aLoadType, PRUint32 aHistCmd)
 {
   nsCOMPtr<nsIDocShell> docShell;
   nsCOMPtr<nsISHEntry> shEntry;
@@ -1216,17 +1223,27 @@ nsSHistory::LoadEntry(PRInt32 aIndex, lo
   if (!docShell) {
     // we did not successfully go to the proper index.
     // return error.
     mRequestedIndex = -1;
     return NS_ERROR_FAILURE;
   }
 
   // Start the load on the appropriate docshell
-  return InitiateLoad(nextEntry, docShell, aLoadType);
+  nsresult rv = InitiateLoad(nextEntry, docShell, aLoadType);
+
+  if (NS_SUCCEEDED(rv)) {
+    // mark the entry as being able to save its content viewer
+    nextEntry->SetSaveContentViewerFlag(PR_TRUE);
+    // evict any content viewers that are now gHistoryMaxViewers
+    // or more away from the new index
+    EvictWindowContentViewers(mIndex, mRequestedIndex);
+  }
+
+  return rv;
 }
 
 
 
 nsresult
 nsSHistory::CompareFrames(nsISHEntry * aPrevEntry, nsISHEntry * aNextEntry, nsIDocShell * aParent, long aLoadType, PRBool * aIsFrameFound)
 {
   if (!aPrevEntry || !aNextEntry || !aParent)
diff -r b7bcdd009540 docshell/test/browser/browser_bug441169.js
--- a/docshell/test/browser/browser_bug441169.js	Mon Sep 08 00:36:19 2008 -0700
+++ b/docshell/test/browser/browser_bug441169.js	Thu Sep 11 15:19:25 2008 +0300
@@ -13,14 +13,15 @@ function test() {
   gBrowser.selectedTab = newTab;
   newBrowser = gBrowser.getBrowserForTab(newTab);
   
   window.addEventListener("DOMContentLoaded", checkPage, false);
   newBrowser.contentWindow.location = chromeURL;
 }
 
 function checkPage() {
+  window.removeEventListener("DOMContentLoaded", checkPage, false);
   
   is(newBrowser.contentDocument.getElementById("test_span"), null, "Error message should not be parsed as HTML, and hence shouldn't include the 'test_span' element.");
   
   gBrowser.removeCurrentTab();
   finish();
 }
diff -r b7bcdd009540 dom/public/idl/base/nsIDOMJSWindow.idl
--- a/dom/public/idl/base/nsIDOMJSWindow.idl	Mon Sep 08 00:36:19 2008 -0700
+++ b/dom/public/idl/base/nsIDOMJSWindow.idl	Thu Sep 11 15:19:25 2008 +0300
@@ -33,17 +33,17 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "domstubs.idl"
 
-[scriptable, uuid(8fcfcc79-054f-437b-965d-807d9b602d0f)]
+[scriptable, uuid(14efb76c-5bd6-449e-b36f-0cbd22981f20)]
 interface nsIDOMJSWindow : nsISupports
 {
   void                      dump(in DOMString str);
 
   /**
    * These methods take typeless arguments and optional arguments, the
    * first argument is either a function or a string, the second
    * argument must be a number (ms) and the rest of the arguments (2
@@ -72,27 +72,38 @@ interface nsIDOMJSWindow : nsISupports
    */
   void                      captureEvents(in long eventFlags);
   void                      releaseEvents(in long eventFlags);
   void                      routeEvent(in nsIDOMEvent evt);
   void                      enableExternalCapture();
   void                      disableExternalCapture();
 
   /**
-   * These are the scriptable versions of nsIDOMWindowInternal::open() and
-   * nsIDOMWindowInternal::openDialog() that take 3 optional arguments.  Unlike
-   * the nsIDOMWindowInternal methods, these methods assume that they are
-   * called from JavaScript and hence will look on the JS context stack to
-   * determine the caller and hence correct security context for doing their
-   * search for an existing named window.  Also, these methods will set the
-   * default charset on the newly opened window based on the current document
-   * charset in the caller.
+   * This is the scriptable version of nsIDOMWindowInternal::open()
+   * that takes 3 optional arguments. Its binary name is OpenJS to
+   * avoid colliding with nsIDOMWindowInternal::open(), which has the
+   * same signature. The reason we can't have that collision is that
+   * the implementation needs to know whether it was called from JS or
+   * not.
+   *
+   * IOW, DO NOT CALL THIS FROM C++
    */
-  nsIDOMWindow              open();
-  nsIDOMWindow              openDialog();
+  [binaryname(OpenJS)] nsIDOMWindow open([optional] in DOMString url,
+                                         [optional] in DOMString name,
+                                         [optional] in DOMString options);
+
+  /**
+   * This is the scriptable version of
+   * nsIDOMWindowInternal::openDialog() that takes 3 optional
+   * arguments, plus any additional arguments are passed on as
+   * arguments on the dialog's window object (window.arguments).
+   */
+  nsIDOMWindow              openDialog([optional] in DOMString url,
+                                       [optional] in DOMString name,
+                                       [optional] in DOMString options);
 
   /**
    * window.frames in Netscape 4.x and IE is just a reference to the
    * window itself (i.e. window.frames === window), but this doesn't
    * make sense from a generic API point of view so that's why this is
    * JS specific.
    *
    * This property is "replaceable" in JavaScript.
diff -r b7bcdd009540 dom/public/idl/base/nsIDOMWindowInternal.idl
--- a/dom/public/idl/base/nsIDOMWindowInternal.idl	Mon Sep 08 00:36:19 2008 -0700
+++ b/dom/public/idl/base/nsIDOMWindowInternal.idl	Thu Sep 11 15:19:25 2008 +0300
@@ -155,22 +155,25 @@ interface nsIDOMWindowInternal : nsIDOMW
    * Open a new window with this one as the parent.  This method will
    * NOT examine the JS stack for purposes of determining a caller.
    * This window will be used for security checks during the search by
    * name and the default character set on the newly opened window
    * will just be the default character set of this window.
    */
   [noscript] nsIDOMWindow   open(in DOMString url, in DOMString name,
                                  in DOMString options);
-  // This method works like open except that aExtraArgument gets
-  // converted into the array window.arguments in JS, if
-  // aExtraArgument is a nsISupportsArray then the individual items in
-  // the array are inserted into window.arguments, and primitive
-  // nsISupports (nsISupportsPrimitives) types are converted to native
-  // JS types when possible.
+
+  /**
+   * This method works like open except that aExtraArgument gets
+   * converted into the array window.arguments in JS, if
+   * aExtraArgument is a nsISupportsArray then the individual items in
+   * the array are inserted into window.arguments, and primitive
+   * nsISupports (nsISupportsPrimitives) types are converted to native
+   * JS types when possible.
+   */
   [noscript] nsIDOMWindow   openDialog(in DOMString url, in DOMString name,
                                        in DOMString options,
                                        in nsISupports aExtraArgument);
   void                      close();
 
   // XXX Should this be in nsIDOMChromeWindow?
   void                      updateCommands(in DOMString action);
 
diff -r b7bcdd009540 dom/public/idl/threads/nsIDOMThreads.idl
--- a/dom/public/idl/threads/nsIDOMThreads.idl	Mon Sep 08 00:36:19 2008 -0700
+++ b/dom/public/idl/threads/nsIDOMThreads.idl	Thu Sep 11 15:19:25 2008 +0300
@@ -117,16 +117,25 @@ interface nsIDOMWorkerPool : nsISupports
   /**
    * Create a new worker object by evaluating the given script.
    *
    * @param aSourceScript (in DOMString)
    *        The script to compile. See below for details on the scope in which
    *        the script will run.
    */
   nsIDOMWorkerThread createWorker(in DOMString aSourceScript);
+
+  /**
+   * Create a new worker object by evaluating the given script.
+   *
+   * @param aSourceURL (in AString)
+   *        The script url to load and compile. See below for details on the
+   *        scope in which the script will run.
+   */
+  nsIDOMWorkerThread createWorkerFromURL(in AString aSourceURL);
 };
 
 [scriptable, uuid(0f2a52ea-afc9-49e6-86dd-2d0cb65b5dd5)]
 interface nsIDOMThreadService : nsISupports
 {
   /**
    * Creates a new DOM worker pool.
    */
diff -r b7bcdd009540 dom/src/base/nsDOMClassInfo.cpp
--- a/dom/src/base/nsDOMClassInfo.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/dom/src/base/nsDOMClassInfo.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -2120,16 +2120,17 @@ nsDOMClassInfo::Init()
 
   DOM_CLASSINFO_MAP_BEGIN(MouseEvent, nsIDOMMouseEvent)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMMouseEvent)
     DOM_CLASSINFO_UI_EVENT_MAP_ENTRIES
   DOM_CLASSINFO_MAP_END
 
   DOM_CLASSINFO_MAP_BEGIN(MouseScrollEvent, nsIDOMMouseScrollEvent)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMMouseScrollEvent)
+    DOM_CLASSINFO_MAP_ENTRY(nsIDOMMouseEvent)
     DOM_CLASSINFO_UI_EVENT_MAP_ENTRIES
   DOM_CLASSINFO_MAP_END
 
   DOM_CLASSINFO_MAP_BEGIN(DragEvent, nsIDOMDragEvent)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMDragEvent)
     DOM_CLASSINFO_UI_EVENT_MAP_ENTRIES
   DOM_CLASSINFO_MAP_END
 
@@ -7565,25 +7566,22 @@ nsGenericArraySH::Enumerate(nsIXPConnect
 }
 
 // NodeList scriptable helper
 
 nsresult
 nsArraySH::GetItemAt(nsISupports *aNative, PRUint32 aIndex,
                      nsISupports **aResult)
 {
-  nsCOMPtr<nsIDOMNodeList> list(do_QueryInterface(aNative));
+  nsCOMPtr<nsINodeList> list(do_QueryInterface(aNative));
   NS_ENSURE_TRUE(list, NS_ERROR_UNEXPECTED);
 
-  nsIDOMNode *node = nsnull; // Weak, transfer the ownership over to aResult
-  nsresult rv = list->Item(aIndex, &node);
-
-  *aResult = node;
-
-  return rv;
+  NS_IF_ADDREF(*aResult = list->GetNodeAt(aIndex));
+
+  return NS_OK;
 }
 
 NS_IMETHODIMP
 nsArraySH::GetProperty(nsIXPConnectWrappedNative *wrapper, JSContext *cx,
                        JSObject *obj, jsval id, jsval *vp, PRBool *_retval)
 {
   PRBool is_number = PR_FALSE;
   PRInt32 n = GetArrayIndexFromId(cx, id, &is_number);
@@ -7691,21 +7689,27 @@ nsNamedNodeMapSH::GetNamedItem(nsISuppor
 
 
 // HTMLCollection helper
 
 nsresult
 nsHTMLCollectionSH::GetItemAt(nsISupports *aNative, PRUint32 aIndex,
                               nsISupports **aResult)
 {
+  // Common case is that we're also an nsINodeList
+  nsresult rv = nsArraySH::GetItemAt(aNative, aIndex, aResult);
+  if (NS_SUCCEEDED(rv)) {
+    return rv;
+  }
+  
   nsCOMPtr<nsIDOMHTMLCollection> collection(do_QueryInterface(aNative));
   NS_ENSURE_TRUE(collection, NS_ERROR_UNEXPECTED);
 
   nsIDOMNode *node = nsnull; // Weak, transfer the ownership over to aResult
-  nsresult rv = collection->Item(aIndex, &node);
+  rv = collection->Item(aIndex, &node);
 
   *aResult = node;
 
   return rv;
 }
 
 nsresult
 nsHTMLCollectionSH::GetNamedItem(nsISupports *aNative,
diff -r b7bcdd009540 dom/src/base/nsGlobalWindow.cpp
--- a/dom/src/base/nsGlobalWindow.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/dom/src/base/nsGlobalWindow.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -4944,64 +4944,27 @@ nsGlobalWindow::Open(const nsAString& aU
                       PR_FALSE,          // aDoJSFixups
                       nsnull, nsnull,    // No args
                       GetPrincipal(),    // aCalleePrincipal
                       nsnull,            // aJSCallerContext
                       _retval);
 }
 
 NS_IMETHODIMP
-nsGlobalWindow::Open(nsIDOMWindow **_retval)
-{
-  *_retval = nsnull;
-
-  nsAXPCNativeCallContext *ncc = nsnull;
-
-  nsresult rv = nsContentUtils::XPConnect()->
-    GetCurrentNativeCallContext(&ncc);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  if (!ncc)
-    return NS_ERROR_NOT_AVAILABLE;
-
-  JSContext *cx = nsnull;
-
-  rv = ncc->GetJSContext(&cx);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  nsAutoString url, name, options;
-
-  PRUint32 argc;
-  jsval *argv = nsnull;
-
-  ncc->GetArgc(&argc);
-  ncc->GetArgvPtr(&argv);
-
-  if (argc > 0) {
-    JSAutoRequest ar(cx);
-    switch (argc) {
-      default:
-      case 3:
-        nsJSUtils::ConvertJSValToString(options, cx, argv[2]);
-      case 2:
-        nsJSUtils::ConvertJSValToString(name, cx, argv[1]);
-      case 1:
-        nsJSUtils::ConvertJSValToString(url, cx, argv[0]);
-        break;
-    }
-  }
-
-  return OpenInternal(url, name, options,
+nsGlobalWindow::OpenJS(const nsAString& aUrl, const nsAString& aName,
+                       const nsAString& aOptions, nsIDOMWindow **_retval)
+{
+  return OpenInternal(aUrl, aName, aOptions,
                       PR_FALSE,          // aDialog
                       PR_FALSE,          // aContentModal
                       PR_FALSE,          // aCalledNoScript
                       PR_TRUE,           // aDoJSFixups
                       nsnull, nsnull,    // No args
                       GetPrincipal(),    // aCalleePrincipal
-                      cx,                // aJSCallerContext
+                      nsContentUtils::GetCurrentJSContext(), // aJSCallerContext
                       _retval);
 }
 
 // like Open, but attaches to the new window any extra parameters past
 // [features] as a JS property named "arguments"
 NS_IMETHODIMP
 nsGlobalWindow::OpenDialog(const nsAString& aUrl, const nsAString& aName,
                            const nsAString& aOptions,
@@ -5014,17 +4977,18 @@ nsGlobalWindow::OpenDialog(const nsAStri
                       PR_FALSE,                   // aDoJSFixups
                       nsnull, aExtraArgument,     // Arguments
                       GetPrincipal(),             // aCalleePrincipal
                       nsnull,                     // aJSCallerContext
                       _retval);
 }
 
 NS_IMETHODIMP
-nsGlobalWindow::OpenDialog(nsIDOMWindow** _retval)
+nsGlobalWindow::OpenDialog(const nsAString& aUrl, const nsAString& aName,
+                           const nsAString& aOptions, nsIDOMWindow** _retval)
 {
   if (!nsContentUtils::IsCallerTrustedForWrite()) {
     return NS_ERROR_DOM_SECURITY_ERR;
   }
 
   nsAXPCNativeCallContext *ncc = nsnull;
   nsresult rv = nsContentUtils::XPConnect()->
     GetCurrentNativeCallContext(&ncc);
@@ -5033,46 +4997,31 @@ nsGlobalWindow::OpenDialog(nsIDOMWindow*
   if (!ncc)
     return NS_ERROR_NOT_AVAILABLE;
 
   JSContext *cx = nsnull;
 
   rv = ncc->GetJSContext(&cx);
   NS_ENSURE_SUCCESS(rv, rv);
 
-  nsAutoString url, name, options;
-
   PRUint32 argc;
   jsval *argv = nsnull;
 
   // XXX - need to get this as nsISupports?
   ncc->GetArgc(&argc);
   ncc->GetArgvPtr(&argv);
 
-  if (argc > 0) {
-    JSAutoRequest ar(cx);
-    switch (argc) {
-      default:
-      case 3:
-        nsJSUtils::ConvertJSValToString(options, cx, argv[2]);
-      case 2:
-        nsJSUtils::ConvertJSValToString(name, cx, argv[1]);
-      case 1:
-        nsJSUtils::ConvertJSValToString(url, cx, argv[0]);
-        break;
-    }
-  }
-
   // Strip the url, name and options from the args seen by scripts.
   PRUint32 argOffset = argc < 3 ? argc : 3;
   nsCOMPtr<nsIArray> argvArray;
-  rv = NS_CreateJSArgv(cx, argc-argOffset, argv+argOffset, getter_AddRefs(argvArray));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  return OpenInternal(url, name, options,
+  rv = NS_CreateJSArgv(cx, argc - argOffset, argv + argOffset,
+                       getter_AddRefs(argvArray));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  return OpenInternal(aUrl, aName, aOptions,
                       PR_TRUE,             // aDialog
                       PR_FALSE,            // aContentModal
                       PR_FALSE,            // aCalledNoScript
                       PR_FALSE,            // aDoJSFixups
                       argvArray, nsnull,   // Arguments
                       GetPrincipal(),      // aCalleePrincipal
                       cx,                  // aJSCallerContext
                       _retval);
diff -r b7bcdd009540 dom/src/base/nsJSUtils.cpp
--- a/dom/src/base/nsJSUtils.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/dom/src/base/nsJSUtils.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -113,59 +113,16 @@ nsJSUtils::GetCallingLocation(JSContext*
       *aLineno = lineno;
       return JS_TRUE;
     }
   }
 
   return JS_FALSE;
 }
 
-jsval
-nsJSUtils::ConvertStringToJSVal(const nsString& aProp, JSContext* aContext)
-{
-  JSString *jsstring =
-    ::JS_NewUCStringCopyN(aContext, reinterpret_cast<const jschar*>
-                                                    (aProp.get()),
-                          aProp.Length());
-
-  // set the return value
-  return STRING_TO_JSVAL(jsstring);
-}
-
-void
-nsJSUtils::ConvertJSValToString(nsAString& aString, JSContext* aContext,
-                                jsval aValue)
-{
-  JSString *jsstring;
-  if ((jsstring = ::JS_ValueToString(aContext, aValue)) != nsnull) {
-    aString.Assign(reinterpret_cast<const PRUnichar*>
-                                   (::JS_GetStringChars(jsstring)),
-                   ::JS_GetStringLength(jsstring));
-  }
-  else {
-    aString.Truncate();
-  }
-}
-
-PRBool
-nsJSUtils::ConvertJSValToUint32(PRUint32* aProp, JSContext* aContext,
-                                jsval aValue)
-{
-  uint32 temp;
-  if (::JS_ValueToECMAUint32(aContext, aValue, &temp)) {
-    *aProp = (PRUint32)temp;
-  }
-  else {
-    ::JS_ReportError(aContext, "Parameter must be an integer");
-    return JS_FALSE;
-  }
-
-  return JS_TRUE;
-}
-
 nsIScriptGlobalObject *
 nsJSUtils::GetStaticScriptGlobal(JSContext* aContext, JSObject* aObj)
 {
   nsISupports* supports;
   JSClass* clazz;
   JSObject* parent;
   JSObject* glob = aObj; // starting point for search
 
diff -r b7bcdd009540 dom/src/base/nsJSUtils.h
--- a/dom/src/base/nsJSUtils.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/dom/src/base/nsJSUtils.h	Thu Sep 11 15:19:25 2008 +0300
@@ -55,25 +55,16 @@ class nsIPrincipal;
 class nsIPrincipal;
 
 class nsJSUtils
 {
 public:
   static JSBool GetCallingLocation(JSContext* aContext, const char* *aFilename,
                                    PRUint32* aLineno, nsIPrincipal* aPrincipal);
 
-  static jsval ConvertStringToJSVal(const nsString& aProp,
-                                    JSContext* aContext);
-
-  static void ConvertJSValToString(nsAString& aString,
-                                   JSContext* aContext, jsval aValue);
-
-  static PRBool ConvertJSValToUint32(PRUint32* aProp, JSContext* aContext,
-                                     jsval aValue);
-
   static nsIScriptGlobalObject *GetStaticScriptGlobal(JSContext* aContext,
                                                       JSObject* aObj);
 
   static nsIScriptContext *GetStaticScriptContext(JSContext* aContext,
                                                   JSObject* aObj);
 
   static nsIScriptGlobalObject *GetDynamicScriptGlobal(JSContext *aContext);
 
diff -r b7bcdd009540 dom/src/base/nsScriptNameSpaceManager.cpp
--- a/dom/src/base/nsScriptNameSpaceManager.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/dom/src/base/nsScriptNameSpaceManager.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -130,24 +130,26 @@ GlobalNameHashInitEntry(PLDHashTable *ta
   // nsGlobalNameStruct::eTypeNotInitialized
   memset(&e->mGlobalName, 0, sizeof(nsGlobalNameStruct));
   return PR_TRUE;
 }
 
 nsScriptNameSpaceManager::nsScriptNameSpaceManager()
   : mIsInitialized(PR_FALSE)
 {
+  MOZ_COUNT_CTOR(nsScriptNameSpaceManager);
 }
 
 nsScriptNameSpaceManager::~nsScriptNameSpaceManager()
 {
   if (mIsInitialized) {
     // Destroy the hash
     PL_DHashTableFinish(&mGlobalNames);
   }
+  MOZ_COUNT_DTOR(nsScriptNameSpaceManager);
 }
 
 nsGlobalNameStruct *
 nsScriptNameSpaceManager::AddToHash(const char *aKey)
 {
   NS_ConvertASCIItoUTF16 key(aKey);
   GlobalNameMapEntry *entry =
     static_cast<GlobalNameMapEntry *>
diff -r b7bcdd009540 dom/src/geolocation/nsGeolocation.cpp
--- a/dom/src/geolocation/nsGeolocation.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/dom/src/geolocation/nsGeolocation.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -43,16 +43,17 @@
 #include "nsServiceManagerUtils.h"
 #include "nsContentUtils.h"
 #include "nsIURI.h"
 #include "nsIPermissionManager.h"
 #include "nsIObserverService.h"
 #include "nsIPrefService.h"
 #include "nsIPrefBranch2.h"
 #include "nsIProxyObjectManager.h"
+#include "nsIJSContextStack.h"
 
 #include <math.h>
 
 #ifdef NS_OSSO
 #include "MaemoLocationProvider.h"
 #endif
 
 #include "nsIDOMDocument.h"
@@ -175,17 +176,28 @@ nsGeolocationRequest::Allow()
 
     nsCOMPtr<nsIProxyObjectManager> proxyObjMgr = do_GetService("@mozilla.org/xpcomproxy;1");
     proxyObjMgr->GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
                                    NS_GET_IID(nsIDOMGeoPositionErrorCallback),
                                    mErrorCallback,
                                    NS_PROXY_ASYNC | NS_PROXY_ALWAYS,
                                    getter_AddRefs(callbackProxy));
 
+
+    // Ensure that the proper context is on the stack (bug 452762)
+    nsCOMPtr<nsIJSContextStack> stack(do_GetService("@mozilla.org/js/xpc/ContextStack;1"));
+    if (!stack || NS_FAILED(stack->Push(nsnull)))
+      return NS_OK; // silently fail
+
     callbackProxy->HandleEvent(positionError);
+
+    // remove the stack
+    JSContext* cx;
+    stack->Pop(&cx);
+
     return rv;
   }
 
   mAllowed = PR_TRUE;
   return NS_OK;
 }
 
 NS_IMETHODIMP
@@ -202,16 +214,21 @@ nsGeolocationRequest::MarkCleared()
 }
 
 void
 nsGeolocationRequest::SendLocation(nsIDOMGeoPosition* position)
 {
   if (mCleared || !mAllowed)
     return;
 
+  // Ensure that the proper context is on the stack (bug 452762)
+  nsCOMPtr<nsIJSContextStack> stack(do_GetService("@mozilla.org/js/xpc/ContextStack;1"));
+  if (!stack || NS_FAILED(stack->Push(nsnull)))
+    return; // silently fail
+  
   //TODO mFuzzLocation.  Needs to be defined what we do here.
   if (mFuzzLocation)
   {
     // need to make a copy because nsIDOMGeoPosition is
     // readonly, and we are not sure of its implementation.
 
     double lat, lon, alt, herror, verror, heading, velocity;
     DOMTimeStamp time;
@@ -241,20 +258,25 @@ nsGeolocationRequest::SendLocation(nsIDO
                                                           lon,
                                                           alt,
                                                           herror,
                                                           verror,
                                                           heading,
                                                           velocity,
                                                           time);
     mCallback->HandleEvent(somewhere);
-    return;
   }
-  
-  mCallback->HandleEvent(position);
+  else
+  {
+    mCallback->HandleEvent(position);
+  }
+
+  // remove the stack
+  JSContext* cx;
+  stack->Pop(&cx);
 }
 
 void
 nsGeolocationRequest::Shutdown()
 {
   mCleared = PR_TRUE;
   mCallback = nsnull;
   mErrorCallback = nsnull;
diff -r b7bcdd009540 dom/src/jsurl/Makefile.in
--- a/dom/src/jsurl/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/dom/src/jsurl/Makefile.in	Thu Sep 11 15:19:25 2008 +0300
@@ -82,14 +82,14 @@ EXTRA_DSO_LDOPTS = \
 		$(MOZ_JS_LIBS) \
 		$(NULL)
 
 ifdef BUILD_DEBUG_GC
 DEFINES		+= -DDEBUG_GC
 endif
 
 DIRS            = $(NULL)
-ifdef MOZ_MOCHITEST
+ifdef ENABLE_TESTS
 DIRS            += test
 endif
 
 include $(topsrcdir)/config/rules.mk
 
diff -r b7bcdd009540 dom/src/threads/Makefile.in
--- a/dom/src/threads/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/dom/src/threads/Makefile.in	Thu Sep 11 15:19:25 2008 +0300
@@ -48,33 +48,35 @@ LIBXUL_LIBRARY   = 1
 LIBXUL_LIBRARY   = 1
 FORCE_STATIC_LIB = 1
 
 REQUIRES = \
   caps \
   content \
   js \
   layout \
+  necko \
   pref \
   string \
   widget \
   xpcom \
   xpconnect \
   $(NULL)
 
 CPPSRCS = \
   nsDOMThreadService.cpp \
   nsDOMWorkerBase.cpp \
   nsDOMWorkerPool.cpp \
+  nsDOMWorkerScriptLoader.cpp \
   nsDOMWorkerSecurityManager.cpp \
   nsDOMWorkerThread.cpp \
   nsDOMWorkerTimeout.cpp \
   $(NULL)
 
 LOCAL_INCLUDES = \
   -I$(topsrcdir)/dom/src/base \
   $(NULL)
 
-ifdef MOZ_MOCHITEST
+ifdef ENABLE_TESTS
 DIRS += test
 endif
 
 include $(topsrcdir)/config/rules.mk
diff -r b7bcdd009540 dom/src/threads/nsAutoJSObjectHolder.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/src/threads/nsAutoJSObjectHolder.h	Thu Sep 11 15:19:25 2008 +0300
@@ -0,0 +1,160 @@
+/* -*- Mode: c++; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is worker threads.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Turner <bent.mozilla@gmail.com> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NSAUTOJSOBJECTHOLDER_H__
+#define __NSAUTOJSOBJECTHOLDER_H__
+
+#include "jsapi.h"
+
+/**
+ * Simple class that looks and acts like a JSObject* except that it unroots
+ * itself automatically if Root() is ever called. Designed to be rooted on the
+ * context or runtime (but not both!). Also automatically nulls its JSObject*
+ * on Unroot and asserts that Root has been called prior to assigning an object.
+ */
+class nsAutoJSObjectHolder
+{
+public:
+  /**
+   * Default constructor, no holding.
+   */
+  nsAutoJSObjectHolder()
+  : mRt(NULL), mObj(NULL), mHeld(PR_FALSE) { }
+
+  /**
+   * Hold by rooting on the context's runtime in the constructor, passing the
+   * result out.
+   */
+  nsAutoJSObjectHolder(JSContext* aCx, JSBool* aRv = NULL,
+                       JSObject* aObj = NULL)
+  : mRt(NULL), mObj(aObj), mHeld(JS_FALSE) {
+    JSBool rv = Hold(aCx);
+    if (aRv) {
+      *aRv = rv;
+    }
+  }
+
+  /**
+   * Hold by rooting on the runtime in the constructor, passing the result out.
+   */
+  nsAutoJSObjectHolder(JSRuntime* aRt, JSBool* aRv = NULL,
+                       JSObject* aObj = NULL)
+  : mRt(aRt), mObj(aObj), mHeld(JS_FALSE) {
+    JSBool rv = Hold(aRt);
+    if (aRv) {
+      *aRv = rv;
+    }
+  }
+
+  /**
+   * Always release on destruction.
+   */
+  ~nsAutoJSObjectHolder() {
+    Release();
+  }
+
+  /**
+   * Hold by rooting on the context's runtime.
+   */
+  JSBool Hold(JSContext* aCx) {
+    return Hold(JS_GetRuntime(aCx));
+  }
+
+  /**
+   * Hold by rooting on the runtime.
+   */
+  JSBool Hold(JSRuntime* aRt) {
+    if (!mHeld) {
+      mHeld = JS_AddNamedRootRT(aRt, &mObj, "nsAutoRootedJSObject");
+      if (mHeld) {
+        mRt = aRt;
+      }
+    }
+    return mHeld;
+  }
+
+  /**
+   * Manually release.
+   */
+  void Release() {
+    NS_ASSERTION(!mHeld || mRt, "Bad!");
+    if (mHeld) {
+      mHeld = !JS_RemoveRootRT(mRt, &mObj);
+      if (!mHeld) {
+        mRt = NULL;
+      }
+      mObj = NULL;
+    }
+  }
+
+  /**
+   * Determine if Hold has been called.
+   */
+  JSBool IsHeld() {
+    return mHeld;
+  }
+
+  /**
+   * Pretend to be a JSObject*.
+   */
+  JSObject* get() const {
+    return mObj;
+  }
+
+  /**
+   * Pretend to be a JSObject*.
+   */
+  operator JSObject*() const {
+    return get();
+  }
+
+  /**
+   * Pretend to be a JSObject*. Assert if not held.
+   */
+  JSObject* operator=(JSObject* aOther) {
+    NS_ASSERTION(mHeld, "Not rooted!");
+    return mObj = aOther;
+  }
+
+private:
+  JSRuntime* mRt;
+  JSObject* mObj;
+  JSBool mHeld;
+};
+
+#endif /* __NSAUTOJSOBJECTHOLDER_H__ */
diff -r b7bcdd009540 dom/src/threads/nsDOMThreadService.cpp
--- a/dom/src/threads/nsDOMThreadService.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/dom/src/threads/nsDOMThreadService.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -37,16 +37,18 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsDOMThreadService.h"
 
 // Interfaces
 #include "nsIComponentManager.h"
 #include "nsIConsoleService.h"
+#include "nsIDocument.h"
+#include "nsIDOMDocument.h"
 #include "nsIEventTarget.h"
 #include "nsIGenericFactory.h"
 #include "nsIJSContextStack.h"
 #include "nsIJSRuntimeService.h"
 #include "nsIObserverService.h"
 #include "nsIScriptError.h"
 #include "nsIScriptGlobalObject.h"
 #include "nsIServiceManager.h"
@@ -82,16 +84,24 @@ PRLogModuleInfo *gDOMThreadsLog = nsnull
 #define THREADPOOL_MAX_THREADS 3
 
 PR_STATIC_ASSERT(THREADPOOL_MAX_THREADS >= 1);
 
 // The maximum number of idle threads in the internal thread pool
 #define THREADPOOL_IDLE_THREADS 3
 
 PR_STATIC_ASSERT(THREADPOOL_MAX_THREADS >= THREADPOOL_IDLE_THREADS);
+
+// As we suspend threads for various reasons (navigating away from the page,
+// loading scripts, etc.) we open another slot in the thread pool for another
+// worker to use. We can't do this forever so we set an absolute cap on the
+// number of threads we'll allow to prevent DOS attacks.
+#define THREADPOOL_THREAD_CAP 20
+
+PR_STATIC_ASSERT(THREADPOOL_THREAD_CAP >= THREADPOOL_MAX_THREADS);
 
 // The number of times our JS operation callback will be called before yielding
 // the thread
 #define CALLBACK_YIELD_THRESHOLD 100
 
 // A "bad" value for the NSPR TLS functions.
 #define BAD_TLS_INDEX (PRUintn)-1
 
@@ -381,37 +391,42 @@ DOMWorkerOperationCallback(JSContext* aC
 {
   nsDOMWorkerThread* worker = (nsDOMWorkerThread*)JS_GetContextPrivate(aCx);
 
   // Want a strong ref here to make sure that the monitor we wait on won't go
   // away.
   nsRefPtr<nsDOMWorkerPool> pool;
 
   PRBool wasSuspended = PR_FALSE;
+  PRBool extraThreadAllowed = PR_FALSE;
   jsrefcount suspendDepth = 0;
 
   while (1) {
     // Kill execution if we're canceled.
     if (worker->IsCanceled()) {
       LOG(("Forcefully killing JS for worker [0x%p]",
            static_cast<void*>(worker)));
 
       if (wasSuspended) {
-        gDOMThreadService->ChangeThreadPoolMaxThreads(-1);
+        if (extraThreadAllowed) {
+          gDOMThreadService->ChangeThreadPoolMaxThreads(-1);
+        }
         JS_ResumeRequest(aCx, suspendDepth);
       }
 
       // Kill exectuion of the currently running JS.
       return PR_FALSE;
     }
 
     // Break out if we're not suspended.
     if (!worker->IsSuspended()) {
       if (wasSuspended) {
-        gDOMThreadService->ChangeThreadPoolMaxThreads(-1);
+        if (extraThreadAllowed) {
+          gDOMThreadService->ChangeThreadPoolMaxThreads(-1);
+        }
         JS_ResumeRequest(aCx, suspendDepth);
       }
       break;
     }
 
     if (!wasSuspended) {
       // Make sure we can get the monitor we need to wait on. It's possible that
       // the worker was canceled since we checked above.
@@ -422,18 +437,20 @@ DOMWorkerOperationCallback(JSContext* aC
 
       pool = worker->Pool();
 
       // Make sure to suspend our request while we block like this, otherwise we
       // prevent GC for everyone.
       suspendDepth = JS_SuspendRequest(aCx);
 
       // Since we're going to block this thread we should open up a new thread
-      // in the thread pool for other workers.
-      gDOMThreadService->ChangeThreadPoolMaxThreads(1);
+      // in the thread pool for other workers. Must check the return value to
+      // make sure we don't decrement when we failed.
+      extraThreadAllowed =
+        NS_SUCCEEDED(gDOMThreadService->ChangeThreadPoolMaxThreads(1));
 
       // Only do all this setup once.
       wasSuspended = PR_TRUE;
     }
 
     nsAutoMonitor mon(pool->Monitor());
     mon.Wait();
   }
@@ -760,16 +777,24 @@ nsDOMThreadService::CreateJSContext()
   JSAutoContextDestroyer cx(JS_NewContext(rt, 8192));
   NS_ENSURE_TRUE(cx, nsnull);
 
   JS_SetErrorReporter(cx, DOMWorkerErrorReporter);
 
   JS_SetOperationCallback(cx, DOMWorkerOperationCallback,
                           100 * JS_OPERATION_WEIGHT_BASE);
 
+  static JSSecurityCallbacks securityCallbacks = {
+    nsDOMWorkerSecurityManager::JSCheckAccess,
+    nsDOMWorkerSecurityManager::JSTranscodePrincipals,
+    nsDOMWorkerSecurityManager::JSFindPrincipal
+  };
+
+  JS_SetContextSecurityCallbacks(cx, &securityCallbacks);
+
   nsresult rv = nsContentUtils::XPConnect()->
     SetSecurityManagerForJSContext(cx, gWorkerSecurityManager, 0);
   NS_ENSURE_SUCCESS(rv, nsnull);
 
   return cx.forget();
 }
 
 #define LOOP_OVER_POOLS(_func, _args)                     \
@@ -827,16 +852,21 @@ nsDOMThreadService::ChangeThreadPoolMaxT
 
   PRUint32 currentThreadCount;
   nsresult rv = mThreadPool->GetThreadLimit(&currentThreadCount);
   NS_ENSURE_SUCCESS(rv, rv);
 
   PRInt32 newThreadCount = (PRInt32)currentThreadCount + (PRInt32)aDelta;
   NS_ASSERTION(newThreadCount >= THREADPOOL_MAX_THREADS,
                "Can't go below initial thread count!");
+
+  if (newThreadCount > THREADPOOL_THREAD_CAP) {
+    NS_WARNING("Thread pool cap reached!");
+    return NS_ERROR_FAILURE;
+  }
 
   rv = mThreadPool->SetThreadLimit((PRUint32)newThreadCount);
   NS_ENSURE_SUCCESS(rv, rv);
 
   return NS_OK;
 }
 
 nsIJSRuntimeService*
@@ -973,17 +1003,23 @@ nsDOMThreadService::OnThreadShuttingDown
  */
 NS_IMETHODIMP
 nsDOMThreadService::CreatePool(nsIDOMWorkerPool** _retval)
 {
   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
 
   NS_ENSURE_TRUE(mThreadPool, NS_ERROR_ILLEGAL_DURING_SHUTDOWN);
 
-  nsRefPtr<nsDOMWorkerPool> pool(new nsDOMWorkerPool());
+  nsIDOMDocument* domDocument = nsContentUtils::GetDocumentFromCaller();
+  NS_ENSURE_TRUE(domDocument, NS_ERROR_UNEXPECTED);
+
+  nsCOMPtr<nsIDocument> callingDocument(do_QueryInterface(domDocument));
+  NS_ENSURE_TRUE(callingDocument, NS_ERROR_NO_INTERFACE);
+
+  nsRefPtr<nsDOMWorkerPool> pool(new nsDOMWorkerPool(callingDocument));
   NS_ENSURE_TRUE(pool, NS_ERROR_OUT_OF_MEMORY);
 
   nsresult rv = pool->Init();
   NS_ENSURE_SUCCESS(rv, rv);
 
   NS_ASSERTION(!mPools.Contains(pool), "Um?!");
   mPools.AppendElement(pool);
 
diff -r b7bcdd009540 dom/src/threads/nsDOMWorkerPool.cpp
--- a/dom/src/threads/nsDOMWorkerPool.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/dom/src/threads/nsDOMWorkerPool.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -64,20 +64,22 @@
 #define LOOP_OVER_WORKERS(_func, _args)                   \
   PR_BEGIN_MACRO                                          \
     PRUint32 workerCount = mWorkers.Length();             \
     for (PRUint32 i = 0; i < workerCount; i++) {          \
       mWorkers[i]-> _func _args ;                         \
     }                                                     \
   PR_END_MACRO
 
-nsDOMWorkerPool::nsDOMWorkerPool()
-: mParentGlobal(nsnull)
+nsDOMWorkerPool::nsDOMWorkerPool(nsIDocument* aDocument)
+: mParentGlobal(nsnull),
+  mParentDocument(aDocument)
 {
   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
+  NS_ASSERTION(aDocument, "Must have a document!");
 }
 
 nsDOMWorkerPool::~nsDOMWorkerPool()
 {
   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
 
   LOOP_OVER_WORKERS(Cancel, ());
 
@@ -229,16 +231,24 @@ nsDOMWorkerPool::ResumeWorkersForGlobal(
     LOOP_OVER_WORKERS(Resume, ());
     Resume();
 
     nsAutoMonitor mon(mMonitor);
     mon.NotifyAll();
   }
 }
 
+nsIDocument*
+nsDOMWorkerPool::GetParentDocument()
+{
+  NS_ASSERTION(NS_IsMainThread(),
+               "Don't touch the non-threadsafe document off the main thread!");
+  return mParentDocument;
+}
+
 NS_IMETHODIMP
 nsDOMWorkerPool::PostMessage(const nsAString& aMessage)
 {
   nsresult rv = PostMessageInternal(aMessage);
   NS_ENSURE_SUCCESS(rv, rv);
   return NS_OK;
 }
 
@@ -271,28 +281,52 @@ nsDOMWorkerPool::GetErrorListener(nsIDOM
 nsDOMWorkerPool::GetErrorListener(nsIDOMWorkerErrorListener** aListener)
 {
   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
   NS_IF_ADDREF(*aListener = mErrorListener);
   return NS_OK;
 }
 
 NS_IMETHODIMP
-nsDOMWorkerPool::CreateWorker(const nsAString& fullScript,
+nsDOMWorkerPool::CreateWorker(const nsAString& aFullScript,
                               nsIDOMWorkerThread** _retval)
 {
   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
 
-  NS_ENSURE_ARG(!fullScript.IsEmpty());
+  NS_ENSURE_ARG(!aFullScript.IsEmpty());
   NS_ENSURE_ARG_POINTER(_retval);
 
-  nsRefPtr<nsDOMWorkerThread> worker(new nsDOMWorkerThread(this, fullScript));
+  nsRefPtr<nsDOMWorkerThread> worker =
+    new nsDOMWorkerThread(this, aFullScript, PR_FALSE);
   NS_ENSURE_TRUE(worker, NS_ERROR_OUT_OF_MEMORY);
 
   nsresult rv = worker->Init();
   NS_ENSURE_SUCCESS(rv, rv);
 
   NS_ASSERTION(!mWorkers.Contains(worker), "Um?!");
   mWorkers.AppendElement(worker);
 
   NS_ADDREF(*_retval = worker);
   return NS_OK;
 }
+
+NS_IMETHODIMP
+nsDOMWorkerPool::CreateWorkerFromURL(const nsAString& aScriptURL,
+                                     nsIDOMWorkerThread** _retval)
+{
+  NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
+
+  NS_ENSURE_ARG(!aScriptURL.IsEmpty());
+  NS_ENSURE_ARG_POINTER(_retval);
+
+  nsRefPtr<nsDOMWorkerThread> worker =
+    new nsDOMWorkerThread(this, aScriptURL, PR_TRUE);
+  NS_ENSURE_TRUE(worker, NS_ERROR_OUT_OF_MEMORY);
+
+  nsresult rv = worker->Init();
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  NS_ASSERTION(!mWorkers.Contains(worker), "Um?!");
+  mWorkers.AppendElement(worker);
+
+  NS_ADDREF(*_retval = worker);
+  return NS_OK;
+}
diff -r b7bcdd009540 dom/src/threads/nsDOMWorkerPool.h
--- a/dom/src/threads/nsDOMWorkerPool.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/dom/src/threads/nsDOMWorkerPool.h	Thu Sep 11 15:19:25 2008 +0300
@@ -47,39 +47,42 @@
 
 // Other includes
 #include "jsapi.h"
 #include "nsStringGlue.h"
 #include "nsTPtrArray.h"
 #include "prmon.h"
 
 class nsDOMWorkerThread;
+class nsIDocument;
 class nsIScriptError;
 class nsIScriptGlobalObject;
 
 /**
  * The pool is almost always touched only on the main thread.
  */
 class nsDOMWorkerPool : public nsDOMWorkerBase,
                         public nsIDOMWorkerPool,
                         public nsIClassInfo
 {
   friend class nsDOMThreadService;
   friend class nsDOMWorkerFunctions;
   friend class nsDOMWorkerPoolWeakRef;
+  friend class nsDOMWorkerScriptLoader;
+  friend class nsDOMWorkerStreamObserver;
   friend class nsDOMWorkerThread;
   friend class nsReportErrorRunnable;
   friend JSBool DOMWorkerOperationCallback(JSContext* aCx);
 
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSIDOMWORKERPOOL
   NS_DECL_NSICLASSINFO
 
-  nsDOMWorkerPool();
+  nsDOMWorkerPool(nsIDocument* aDocument);
 
   // For nsDOMWorkerBase
   virtual nsDOMWorkerPool* Pool() {
     return this;
   }
 
 private:
   virtual ~nsDOMWorkerPool();
@@ -101,18 +104,23 @@ private:
   void CancelWorkersForGlobal(nsIScriptGlobalObject* aGlobalObject);
   void SuspendWorkersForGlobal(nsIScriptGlobalObject* aGlobalObject);
   void ResumeWorkersForGlobal(nsIScriptGlobalObject* aGlobalObject);
 
   PRMonitor* Monitor() {
     return mMonitor;
   }
 
+  nsIDocument* GetParentDocument();
+
   // Weak reference to the window that created and owns this pool.
   nsISupports* mParentGlobal;
+
+  // Weak reference to the document that created this pool.
+  nsIDocument* mParentDocument;
 
   // Weak array of workers. The idea is that workers can be garbage collected
   // independently of the owning pool and other workers.
   nsTPtrArray<nsDOMWorkerThread> mWorkers;
 
   // An error handler function, may be null.
   nsCOMPtr<nsIDOMWorkerErrorListener> mErrorListener;
 
diff -r b7bcdd009540 dom/src/threads/nsDOMWorkerScriptLoader.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/src/threads/nsDOMWorkerScriptLoader.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -0,0 +1,795 @@
+/* -*- Mode: c++; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is worker threads.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Turner <bent.mozilla@gmail.com> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsDOMWorkerScriptLoader.h"
+
+// Interfaces
+#include "nsIContentPolicy.h"
+#include "nsIIOService.h"
+#include "nsIRequest.h"
+#include "nsIScriptSecurityManager.h"
+#include "nsIStreamLoader.h"
+
+// Other includes
+#include "nsAutoLock.h"
+#include "nsContentErrors.h"
+#include "nsContentPolicyUtils.h"
+#include "nsContentUtils.h"
+#include "nsISupportsPrimitives.h"
+#include "nsNetError.h"
+#include "nsNetUtil.h"
+#include "nsScriptLoader.h"
+#include "nsThreadUtils.h"
+#include "pratom.h"
+
+// DOMWorker includes
+#include "nsDOMWorkerPool.h"
+#include "nsDOMWorkerSecurityManager.h"
+#include "nsDOMThreadService.h"
+#include "nsDOMWorkerTimeout.h"
+
+#define LOG(_args) PR_LOG(gDOMThreadsLog, PR_LOG_DEBUG, _args)
+
+nsDOMWorkerScriptLoader::nsDOMWorkerScriptLoader()
+: mWorker(nsnull),
+  mTarget(nsnull),
+  mCx(NULL),
+  mScriptCount(0),
+  mCanceled(PR_FALSE),
+  mTrackedByWorker(PR_FALSE)
+{
+  // Created on worker thread.
+  NS_ASSERTION(!NS_IsMainThread(), "Wrong thread!");
+}
+
+nsDOMWorkerScriptLoader::~nsDOMWorkerScriptLoader()
+{
+  // Can't touch mWorker's lock
+  if (!mCanceled) {
+    // Destroyed on worker thread, unless canceled (and then who knows!).
+    NS_ASSERTION(!NS_IsMainThread(), "Wrong thread!");
+
+    if (mTrackedByWorker) {
+      jsrefcount suspendDepth = 0;
+      if (mCx) {
+        suspendDepth = JS_SuspendRequest(mCx);
+      }
+
+      nsAutoLock lock(mWorker->Lock());
+  #ifdef DEBUG
+      PRBool removed =
+  #endif
+      mWorker->mScriptLoaders.RemoveElement(this);
+      NS_ASSERTION(removed, "Something is wrong here!");
+
+      if (mCx) {
+        JS_ResumeRequest(mCx, suspendDepth);
+      }
+    }
+  }
+}
+
+NS_IMPL_ISUPPORTS_INHERITED1(nsDOMWorkerScriptLoader, nsRunnable,
+                                                      nsIStreamLoaderObserver)
+
+nsresult
+nsDOMWorkerScriptLoader::LoadScripts(nsDOMWorkerThread* aWorker,
+                                     JSContext* aCx,
+                                     const nsTArray<nsString>& aURLs)
+{
+  NS_ASSERTION(!NS_IsMainThread(), "Wrong thread!");
+  NS_ASSERTION(aWorker, "Null worker!");
+  NS_ASSERTION(aCx, "Null context!");
+
+  NS_ASSERTION(!mWorker, "Not designed to be used more than once!");
+
+  mWorker = aWorker;
+  mCx = aCx;
+
+  mTarget = NS_GetCurrentThread();
+  NS_ASSERTION(mTarget, "This should never be null!");
+
+  {
+    JSAutoSuspendRequest asr(aCx);
+    nsAutoLock lock(mWorker->Lock());
+    mTrackedByWorker = nsnull != mWorker->mScriptLoaders.AppendElement(this);
+    NS_ASSERTION(mTrackedByWorker, "Failed to add loader to worker's array!");
+  }
+
+  if (mCanceled) {
+    return NS_ERROR_ABORT;
+  }
+
+  mScriptCount = aURLs.Length();
+  if (!mScriptCount) {
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  // Do all the memory work for these arrays now rather than checking for
+  // failures all along the way.
+  PRBool success = mLoadInfos.SetCapacity(mScriptCount);
+  NS_ENSURE_TRUE(success, NS_ERROR_OUT_OF_MEMORY);
+
+  // Need one runnable per script and then an extra for the finished
+  // notification.
+  success = mPendingRunnables.SetCapacity(mScriptCount + 1);
+  NS_ENSURE_TRUE(success, NS_ERROR_OUT_OF_MEMORY);
+
+  for (PRUint32 index = 0; index < mScriptCount; index++) {
+    ScriptLoadInfo* newInfo = mLoadInfos.AppendElement();
+    NS_ASSERTION(newInfo, "Shouldn't fail if SetCapacity succeeded above!");
+
+    newInfo->url.Assign(aURLs[index]);
+    if (newInfo->url.IsEmpty()) {
+      return NS_ERROR_INVALID_ARG;
+    }
+
+    success = newInfo->scriptObj.Hold(aCx);
+    NS_ENSURE_TRUE(success, NS_ERROR_FAILURE);
+  }
+
+  // Don't want timeouts, etc., from queuing up while we're waiting on the
+  // network or compiling.
+  AutoSuspendWorkerEvents aswe(this);
+
+  nsresult rv = DoRunLoop();
+
+  {
+    JSAutoSuspendRequest asr(aCx);
+    nsAutoLock lock(mWorker->Lock());
+#ifdef DEBUG
+    PRBool removed =
+#endif
+    mWorker->mScriptLoaders.RemoveElement(this);
+    NS_ASSERTION(removed, "Something is wrong here!");
+    mTrackedByWorker = PR_FALSE;
+   }
+
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  // Verify that all scripts downloaded and compiled.
+  rv = VerifyScripts();
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  rv = ExecuteScripts();
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  return NS_OK;
+}
+
+nsresult
+nsDOMWorkerScriptLoader::LoadScript(nsDOMWorkerThread* aWorker,
+                                    JSContext* aCx,
+                                    const nsString& aURL)
+{
+  nsAutoTArray<nsString, 1> url;
+  url.AppendElement(aURL);
+
+  return LoadScripts(aWorker, aCx, url);
+}
+
+nsresult
+nsDOMWorkerScriptLoader::DoRunLoop()
+{
+  NS_ASSERTION(!NS_IsMainThread(), "Wrong thread!");
+
+  volatile PRBool done = PR_FALSE;
+  mDoneRunnable = new ScriptLoaderDone(this, &done);
+  NS_ENSURE_TRUE(mDoneRunnable, NS_ERROR_OUT_OF_MEMORY);
+
+  nsresult rv = NS_DispatchToMainThread(this);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  if (!(done || mCanceled)) {
+    // Since we're going to lock up this thread we might as well allow the
+    // thread service to schedule another worker on a new thread.
+    nsDOMThreadService* threadService = nsDOMThreadService::get();
+    PRBool changed = NS_SUCCEEDED(threadService->ChangeThreadPoolMaxThreads(1));
+
+    while (!(done || mCanceled)) {
+      JSAutoSuspendRequest asr(mCx);
+      NS_ProcessNextEvent(mTarget);
+    }
+
+    if (changed) {
+      threadService->ChangeThreadPoolMaxThreads(-1);
+    }
+  }
+
+  return mCanceled ? NS_ERROR_ABORT : NS_OK;
+}
+
+nsresult
+nsDOMWorkerScriptLoader::VerifyScripts()
+{
+  nsresult rv = NS_OK;
+
+  for (PRUint32 index = 0; index < mScriptCount; index++) {
+    ScriptLoadInfo& loadInfo = mLoadInfos[index];
+    NS_ASSERTION(loadInfo.done, "Inconsistent state!");
+
+    if (NS_SUCCEEDED(loadInfo.result) && loadInfo.scriptObj) {
+      continue;
+    }
+
+    NS_ASSERTION(!loadInfo.scriptObj, "Inconsistent state!");
+
+    // Flag failure before worrying about whether or not to report an error.
+    rv = NS_FAILED(loadInfo.result) ? loadInfo.result : NS_ERROR_FAILURE;
+
+    // If loadInfo.result is a success code then the compiler probably reported
+    // an error already. Also we don't really care about NS_BINDING_ABORTED
+    // since that's the code we set when some other script had a problem and the
+    // rest were canceled.
+    if (NS_SUCCEEDED(loadInfo.result) || loadInfo.result == NS_BINDING_ABORTED) {
+      continue;
+    }
+
+    // Ok, this is the script that caused us to fail.
+
+    // Only throw an error there is no other pending exception.
+    if (!JS_IsExceptionPending(mCx)) {
+      NS_ConvertUTF16toUTF8 url(loadInfo.url);
+      JS_ReportError(mCx, "Failed to compile script: %s", url.get());
+    }
+    break;
+  }
+
+  return rv;
+}
+
+nsresult
+nsDOMWorkerScriptLoader::ExecuteScripts()
+{
+  // Now execute all the scripts.
+  for (PRUint32 index = 0; index < mScriptCount; index++) {
+    ScriptLoadInfo& loadInfo = mLoadInfos[index];
+
+    JSScript* script =
+      static_cast<JSScript*>(JS_GetPrivate(mCx, loadInfo.scriptObj));
+    NS_ASSERTION(script, "This shouldn't ever be null!");
+
+    JSObject* global = mWorker->mGlobal ?
+                       mWorker->mGlobal :
+                       JS_GetGlobalObject(mCx);
+    NS_ENSURE_STATE(global);
+
+    // Because we may have nested calls to this function we don't want the
+    // execution to automatically report errors. We let them propagate instead.
+    uint32 oldOpts =
+      JS_SetOptions(mCx, JS_GetOptions(mCx) | JSOPTION_DONT_REPORT_UNCAUGHT);
+
+    jsval val;
+    PRBool success = JS_ExecuteScript(mCx, global, script, &val);
+
+    JS_SetOptions(mCx, oldOpts);
+
+    if (!success) {
+      return NS_ERROR_FAILURE;
+    }
+  }
+  return NS_OK;
+}
+
+void
+nsDOMWorkerScriptLoader::Cancel()
+{
+  NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
+
+  NS_ASSERTION(!mCanceled, "Cancel called more than once!");
+  mCanceled = PR_TRUE;
+
+  for (PRUint32 index = 0; index < mScriptCount; index++) {
+    ScriptLoadInfo& loadInfo = mLoadInfos[index];
+
+    nsIRequest* request =
+      static_cast<nsIRequest*>(loadInfo.channel.get());
+    if (request) {
+#ifdef DEBUG
+      nsresult rv =
+#endif
+      request->Cancel(NS_BINDING_ABORTED);
+      NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "Failed to cancel channel!");
+    }
+  }
+
+  nsAutoTArray<ScriptLoaderRunnable*, 10> runnables;
+  {
+    nsAutoLock lock(mWorker->Lock());
+    runnables.AppendElements(mPendingRunnables);
+    mPendingRunnables.Clear();
+  }
+
+  PRUint32 runnableCount = runnables.Length();
+  for (PRUint32 index = 0; index < runnableCount; index++) {
+    runnables[index]->Revoke();
+  }
+
+  // We're about to post a revoked event to the worker thread, which seems
+  // silly, but we have to do this because the worker thread may be sleeping
+  // waiting on its event queue.
+  NotifyDone();
+}
+
+NS_IMETHODIMP
+nsDOMWorkerScriptLoader::Run()
+{
+  NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
+
+  // We may have been canceled already.
+  if (mCanceled) {
+    return NS_BINDING_ABORTED;
+  }
+
+  nsresult rv = RunInternal();
+  if (NS_SUCCEEDED(rv)) {
+    return rv;
+  }
+
+  // Ok, something failed beyond a normal cancel.
+
+  // If necko is holding a ref to us then we'll end up notifying in the
+  // OnStreamComplete method, not here.
+  PRBool needsNotify = PR_TRUE;
+
+  // Cancel any async channels that were already opened.
+  for (PRUint32 index = 0; index < mScriptCount; index++) {
+    ScriptLoadInfo& loadInfo = mLoadInfos[index];
+
+    nsIRequest* request = static_cast<nsIRequest*>(loadInfo.channel.get());
+    if (request) {
+#ifdef DEBUG
+      nsresult rvInner =
+#endif
+      request->Cancel(NS_BINDING_ABORTED);
+      NS_WARN_IF_FALSE(NS_SUCCEEDED(rvInner), "Failed to cancel channel!");
+
+      // Necko is holding a ref to us so make sure that the OnStreamComplete
+      // code sends the done event.
+      needsNotify = PR_FALSE;
+    }
+    else {
+      // Make sure to set this so that the OnStreamComplete code will dispatch
+      // the done event.
+      loadInfo.done = PR_TRUE;
+    }
+  }
+
+  if (needsNotify) {
+    NotifyDone();
+  }
+
+  return rv;
+}
+
+NS_IMETHODIMP
+nsDOMWorkerScriptLoader::OnStreamComplete(nsIStreamLoader* aLoader,
+                                          nsISupports* aContext,
+                                          nsresult aStatus,
+                                          PRUint32 aStringLen,
+                                          const PRUint8* aString)
+{
+  NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
+
+  // We may have been canceled already.
+  if (mCanceled) {
+    return NS_BINDING_ABORTED;
+  }
+
+  nsresult rv = OnStreamCompleteInternal(aLoader, aContext, aStatus, aStringLen,
+                                         aString);
+
+  // Dispatch the done event if we've received all the data.
+  for (PRUint32 index = 0; index < mScriptCount; index++) {
+    if (!mLoadInfos[index].done) {
+      // Some async load is still outstanding, don't notify yet.
+      break;
+    }
+
+    if (index == mScriptCount - 1) {
+      // All loads complete, signal the thread.
+      NotifyDone();
+    }
+  }
+
+  return rv;
+}
+
+nsresult
+nsDOMWorkerScriptLoader::RunInternal()
+{
+  NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
+
+  // Things we need to make all this work...
+  nsIDocument* parentDoc = mWorker->Pool()->GetParentDocument();
+  NS_ASSERTION(parentDoc, "Null parent document?!");
+
+  // All of these can potentially be null, but that should be ok. We'll either
+  // succeed without them or fail below.
+  nsIURI* parentBaseURI = parentDoc->GetBaseURI();
+  nsCOMPtr<nsILoadGroup> loadGroup(parentDoc->GetDocumentLoadGroup());
+  nsCOMPtr<nsIIOService> ios(do_GetIOService());
+
+  for (PRUint32 index = 0; index < mScriptCount; index++) {
+    ScriptLoadInfo& loadInfo = mLoadInfos[index];
+    nsresult& rv = loadInfo.result;
+
+    nsCOMPtr<nsIURI>& uri = loadInfo.finalURI;
+    rv = nsContentUtils::NewURIWithDocumentCharset(getter_AddRefs(uri),
+                                                   loadInfo.url, parentDoc,
+                                                   parentBaseURI);
+    if (NS_FAILED(rv)) {
+      return rv;
+    }
+
+    nsIScriptSecurityManager* secMan = nsContentUtils::GetSecurityManager();
+    NS_ENSURE_TRUE(secMan, NS_ERROR_FAILURE);
+
+    rv =
+      secMan->CheckLoadURIWithPrincipal(parentDoc->NodePrincipal(), uri,
+                                        nsIScriptSecurityManager::ALLOW_CHROME);
+    if (NS_FAILED(rv)) {
+      return rv;
+    }
+
+    PRInt16 shouldLoad = nsIContentPolicy::ACCEPT;
+    rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_SCRIPT,
+                                   uri,
+                                   parentDoc->NodePrincipal(),
+                                   parentDoc,
+                                   NS_LITERAL_CSTRING("text/javascript"),
+                                   nsnull,
+                                   &shouldLoad,
+                                   nsContentUtils::GetContentPolicy(),
+                                   secMan);
+    if (NS_FAILED(rv) || NS_CP_REJECTED(shouldLoad)) {
+      if (NS_FAILED(rv) || shouldLoad != nsIContentPolicy::REJECT_TYPE) {
+        return NS_ERROR_CONTENT_BLOCKED;
+      }
+      return NS_ERROR_CONTENT_BLOCKED_SHOW_ALT;
+    }
+
+    // We need to know which index we're on in OnStreamComplete so we know where
+    // to put the result.
+    nsCOMPtr<nsISupportsPRUint32> indexSupports =
+      do_CreateInstance(NS_SUPPORTS_PRUINT32_CONTRACTID, &rv);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    rv = indexSupports->SetData(index);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    // We don't care about progress so just use the simple stream loader for
+    // OnStreamComplete notification only.
+    nsCOMPtr<nsIStreamLoader> loader;
+    rv = NS_NewStreamLoader(getter_AddRefs(loader), this);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    rv = NS_NewChannel(getter_AddRefs(loadInfo.channel), uri, ios, loadGroup);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    rv = loadInfo.channel->AsyncOpen(loader, indexSupports);
+    if (NS_FAILED(rv)) {
+      // Null this out so we don't try to cancel it later.
+      loadInfo.channel = nsnull;
+      return rv;
+    }
+  }
+
+  return NS_OK;
+}
+
+nsresult
+nsDOMWorkerScriptLoader::OnStreamCompleteInternal(nsIStreamLoader* aLoader,
+                                                  nsISupports* aContext,
+                                                  nsresult aStatus,
+                                                  PRUint32 aStringLen,
+                                                  const PRUint8* aString)
+{
+  NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
+
+  nsCOMPtr<nsISupportsPRUint32> indexSupports(do_QueryInterface(aContext));
+  NS_ENSURE_TRUE(indexSupports, NS_ERROR_NO_INTERFACE);
+
+  PRUint32 index = PR_UINT32_MAX;
+  indexSupports->GetData(&index);
+
+  if (index >= mScriptCount) {
+    NS_NOTREACHED("This really can't fail or we'll hang!");
+    return NS_ERROR_FAILURE;
+  }
+
+  ScriptLoadInfo& loadInfo = mLoadInfos[index];
+
+  NS_ASSERTION(!loadInfo.done, "Got complete on the same load twice!");
+  loadInfo.done = PR_TRUE;
+
+#ifdef DEBUG
+  // Make sure we're seeing the channel that we expect.
+  nsCOMPtr<nsIRequest> request;
+  nsresult rvDebug = aLoader->GetRequest(getter_AddRefs(request));
+
+  // When we cancel sometimes we get null here. That should be ok, but only if
+  // we're canceled.
+  NS_ASSERTION(NS_SUCCEEDED(rvDebug) || mCanceled, "GetRequest failed!");
+
+  if (NS_SUCCEEDED(rvDebug)) {
+    nsCOMPtr<nsIChannel> channel(do_QueryInterface(request));
+    NS_ASSERTION(channel, "QI failed!");
+
+    nsCOMPtr<nsISupports> thisChannel(do_QueryInterface(channel));
+    NS_ASSERTION(thisChannel, "QI failed!");
+
+    nsCOMPtr<nsISupports> ourChannel(do_QueryInterface(loadInfo.channel));
+    NS_ASSERTION(ourChannel, "QI failed!");
+
+    NS_ASSERTION(thisChannel == ourChannel, "Wrong channel!");
+  }
+#endif
+
+  // Use an alias to keep rv and loadInfo.result in sync.
+  nsresult& rv = loadInfo.result = aStatus;
+
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  if (!(aStringLen && aString)) {
+    return rv = NS_ERROR_UNEXPECTED;
+  }
+
+  nsIDocument* parentDoc = mWorker->Pool()->GetParentDocument();
+  NS_ASSERTION(parentDoc, "Null parent document?!");
+
+  // Use the regular nsScriptLoader for this grunt work! Should be just fine
+  // because we're running on the main thread.
+  rv = nsScriptLoader::ConvertToUTF16(loadInfo.channel, aString, aStringLen,
+                                      EmptyString(), parentDoc,
+                                      loadInfo.scriptText);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  if (loadInfo.scriptText.IsEmpty()) {
+    return rv = NS_ERROR_FAILURE;
+  }
+
+  nsCString filename;
+  loadInfo.finalURI->GetSpec(filename);
+
+  if (filename.IsEmpty()) {
+    filename.Assign(NS_LossyConvertUTF16toASCII(loadInfo.url));
+  }
+  else {
+    // This will help callers figure out what their script url resolved to in
+    // case of errors.
+    loadInfo.url.Assign(NS_ConvertUTF8toUTF16(filename));
+  }
+
+  nsRefPtr<ScriptCompiler> compiler =
+    new ScriptCompiler(this, mCx, loadInfo.scriptText, filename,
+                       loadInfo.scriptObj);
+  NS_ASSERTION(compiler, "Out of memory!");
+  if (!compiler) {
+    return rv = NS_ERROR_OUT_OF_MEMORY;
+  }
+
+  rv = mTarget->Dispatch(compiler, NS_DISPATCH_NORMAL);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  return rv;
+}
+
+void
+nsDOMWorkerScriptLoader::NotifyDone()
+{
+  NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
+
+  if (!mDoneRunnable) {
+    // We've already completed, no need to cancel anything.
+    return;
+  }
+
+  for (PRUint32 index = 0; index < mScriptCount; index++) {
+    ScriptLoadInfo& loadInfo = mLoadInfos[index];
+    // Null both of these out because they aren't threadsafe and must be
+    // destroyed on this thread.
+    loadInfo.channel = nsnull;
+    loadInfo.finalURI = nsnull;
+
+    if (mCanceled) {
+      // Simulate a complete, yet failed, load.
+      loadInfo.done = PR_TRUE;
+      loadInfo.result = NS_BINDING_ABORTED;
+    }
+  }
+
+#ifdef DEBUG
+  nsresult rv =
+#endif
+  mTarget->Dispatch(mDoneRunnable, NS_DISPATCH_NORMAL);
+  NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "Couldn't dispatch done event!");
+
+  mDoneRunnable = nsnull;
+}
+
+void
+nsDOMWorkerScriptLoader::SuspendWorkerEvents()
+{
+  NS_ASSERTION(mWorker, "No worker yet!");
+  mWorker->SuspendTimeouts();
+}
+
+void
+nsDOMWorkerScriptLoader::ResumeWorkerEvents()
+{
+  NS_ASSERTION(mWorker, "No worker yet!");
+  mWorker->ResumeTimeouts();
+}
+
+nsDOMWorkerScriptLoader::
+ScriptLoaderRunnable::ScriptLoaderRunnable(nsDOMWorkerScriptLoader* aLoader)
+: mRevoked(PR_FALSE),
+  mLoader(aLoader)
+{
+  nsAutoLock lock(aLoader->Lock());
+#ifdef DEBUG
+  nsDOMWorkerScriptLoader::ScriptLoaderRunnable** added =
+#endif
+  aLoader->mPendingRunnables.AppendElement(this);
+  NS_ASSERTION(added, "This shouldn't fail because we SetCapacity earlier!");
+}
+
+nsDOMWorkerScriptLoader::
+ScriptLoaderRunnable::~ScriptLoaderRunnable()
+{
+  if (!mRevoked) {
+    nsAutoLock lock(mLoader->Lock());
+#ifdef DEBUG
+    PRBool removed =
+#endif
+    mLoader->mPendingRunnables.RemoveElement(this);
+    NS_ASSERTION(removed, "Someone has changed the array!");
+  }
+}
+
+void
+nsDOMWorkerScriptLoader::ScriptLoaderRunnable::Revoke()
+{
+  mRevoked = PR_TRUE;
+}
+
+nsDOMWorkerScriptLoader::
+ScriptCompiler::ScriptCompiler(nsDOMWorkerScriptLoader* aLoader,
+                               JSContext* aCx,
+                               const nsString& aScriptText,
+                               const nsCString& aFilename,
+                               nsAutoJSObjectHolder& aScriptObj)
+: ScriptLoaderRunnable(aLoader),
+  mCx(aCx),
+  mScriptText(aScriptText),
+  mFilename(aFilename),
+  mScriptObj(aScriptObj)
+{
+  NS_ASSERTION(aCx, "Null context!");
+  NS_ASSERTION(!aScriptText.IsEmpty(), "No script to compile!");
+  NS_ASSERTION(aScriptObj.IsHeld(), "Should be held!");
+}
+
+NS_IMETHODIMP
+nsDOMWorkerScriptLoader::ScriptCompiler::Run()
+{
+  NS_ASSERTION(!NS_IsMainThread(), "Wrong thread!");
+
+  if (mRevoked) {
+    return NS_OK;
+  }
+
+  NS_ASSERTION(!mScriptObj, "Already have a script object?!");
+  NS_ASSERTION(mScriptObj.IsHeld(), "Not held?!");
+  NS_ASSERTION(!mScriptText.IsEmpty(), "Shouldn't have empty source here!");
+
+  JSAutoRequest ar(mCx);
+
+  JSObject* global = JS_GetGlobalObject(mCx);
+  NS_ENSURE_STATE(global);
+
+  // Because we may have nested calls to this function we don't want the
+  // execution to automatically report errors. We let them propagate instead.
+  uint32 oldOpts =
+    JS_SetOptions(mCx, JS_GetOptions(mCx) | JSOPTION_DONT_REPORT_UNCAUGHT);
+
+  JSPrincipals* principal = nsDOMWorkerSecurityManager::WorkerPrincipal();
+
+  JSScript* script =
+    JS_CompileUCScriptForPrincipals(mCx, global, principal,
+                                    mScriptText.BeginReading(),
+                                    mScriptText.Length(), mFilename.get(), 1);
+
+  JS_SetOptions(mCx, oldOpts);
+
+  if (!script) {
+    return NS_ERROR_FAILURE;
+  }
+
+  mScriptObj = JS_NewScriptObject(mCx, script);
+  NS_ENSURE_STATE(mScriptObj);
+
+  return NS_OK;
+}
+
+nsDOMWorkerScriptLoader::
+ScriptLoaderDone::ScriptLoaderDone(nsDOMWorkerScriptLoader* aLoader,
+                                   volatile PRBool* aDoneFlag)
+: ScriptLoaderRunnable(aLoader),
+  mDoneFlag(aDoneFlag)
+{
+  NS_ASSERTION(aDoneFlag && !*aDoneFlag, "Bad setup!");
+}
+
+NS_IMETHODIMP
+nsDOMWorkerScriptLoader::ScriptLoaderDone::Run()
+{
+  NS_ASSERTION(!NS_IsMainThread(), "Wrong thread!");
+
+  if (mRevoked) {
+    return NS_OK;
+  }
+
+  *mDoneFlag = PR_TRUE;
+  return NS_OK;
+}
+
+nsDOMWorkerScriptLoader::
+AutoSuspendWorkerEvents::AutoSuspendWorkerEvents(nsDOMWorkerScriptLoader* aLoader)
+: mLoader(aLoader)
+{
+  NS_ASSERTION(aLoader, "Don't hand me null!");
+  aLoader->SuspendWorkerEvents();
+}
+
+nsDOMWorkerScriptLoader::
+AutoSuspendWorkerEvents::~AutoSuspendWorkerEvents()
+{
+  mLoader->ResumeWorkerEvents();
+}
diff -r b7bcdd009540 dom/src/threads/nsDOMWorkerScriptLoader.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/src/threads/nsDOMWorkerScriptLoader.h	Thu Sep 11 15:19:25 2008 +0300
@@ -0,0 +1,224 @@
+/* -*- Mode: c++; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is worker threads.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Turner <bent.mozilla@gmail.com> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NSDOMWORKERSCRIPTLOADER_H__
+#define __NSDOMWORKERSCRIPTLOADER_H__
+
+// Bases
+#include "nsThreadUtils.h"
+#include "nsIStreamLoader.h"
+
+// Interfaces
+#include "nsIChannel.h"
+#include "nsIURI.h"
+
+// Other includes
+#include "jsapi.h"
+#include "nsAutoPtr.h"
+#include "nsAutoJSObjectHolder.h"
+#include "nsCOMPtr.h"
+#include "nsStringGlue.h"
+#include "nsTArray.h"
+#include "prlock.h"
+
+// DOMWorker includes
+#include "nsDOMWorkerThread.h"
+
+/**
+ * This class takes a list of script URLs, downloads the scripts, compiles the
+ * scripts, and then finally executes them. Due to platform limitations all
+ * network operations must happen on the main thread so this object sends events
+ * back and forth from the worker thread to the main thread. The flow goes like
+ * this:
+ *
+ *  1. (Worker thread) nsDOMWorkerScriptLoader created.
+ *  2. (Worker thread) LoadScript(s) called. Some simple argument validation is
+ *                     performed (currently limited to ensuring that all
+ *                     arguments are strings). nsDOMWorkerScriptLoader is then
+ *                     dispatched to the main thread.
+ *  3. (Main thread)   Arguments validated as URIs, security checks performed,
+ *                     content policy consulted. Network loads begin.
+ *  4. (Necko thread)  Necko stuff!
+ *  5. (Main thread)   Completed downloads are packaged in a ScriptCompiler
+ *                     runnable and sent to the worker thread.
+ *  6. (Worker thread) ScriptCompiler runnables are processed (i.e. their
+ *                     scripts are compiled) in the order in which the necko
+ *                     downloads completed.
+ *  7. (Worker thread) After all loads complete and all compilation succeeds
+ *                     the scripts are executed in the order that the URLs were
+ *                     given to LoadScript(s).
+ *
+ * Currently if *anything* after 2 fails then we cancel any pending loads and
+ * bail out entirely.
+ */
+class nsDOMWorkerScriptLoader : public nsRunnable,
+                                public nsIStreamLoaderObserver
+{
+  friend class AutoSuspendWorkerEvents;
+  friend class nsDOMWorkerFunctions;
+  friend class nsDOMWorkerThread;
+  friend class ScriptLoaderRunnable;
+
+public:
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_NSIRUNNABLE
+  NS_DECL_NSISTREAMLOADEROBSERVER
+
+  nsDOMWorkerScriptLoader();
+
+  nsresult LoadScripts(nsDOMWorkerThread* aWorker,
+                       JSContext* aCx,
+                       const nsTArray<nsString>& aURLs);
+
+  nsresult LoadScript(nsDOMWorkerThread* aWorker,
+                       JSContext* aCx,
+                       const nsString& aURL);
+
+  void Cancel();
+
+private:
+  ~nsDOMWorkerScriptLoader();
+
+  nsresult DoRunLoop();
+  nsresult VerifyScripts();
+  nsresult ExecuteScripts();
+
+  nsresult RunInternal();
+
+  nsresult OnStreamCompleteInternal(nsIStreamLoader* aLoader,
+                                    nsISupports* aContext,
+                                    nsresult aStatus,
+                                    PRUint32 aStringLen,
+                                    const PRUint8* aString);
+
+  void NotifyDone();
+
+  void SuspendWorkerEvents();
+  void ResumeWorkerEvents();
+
+  PRLock* Lock() {
+    return mWorker->Lock();
+  }
+
+  class ScriptLoaderRunnable : public nsRunnable
+  {
+  protected:
+    // Meant to be inherited.
+    ScriptLoaderRunnable(nsDOMWorkerScriptLoader* aLoader);
+    virtual ~ScriptLoaderRunnable();
+
+  public:
+    void Revoke();
+
+  protected:
+    PRBool mRevoked;
+
+  private:
+    nsDOMWorkerScriptLoader* mLoader;
+  };
+
+  class ScriptCompiler : public ScriptLoaderRunnable
+  {
+  public:
+    NS_DECL_NSIRUNNABLE
+
+    ScriptCompiler(nsDOMWorkerScriptLoader* aLoader,
+                   JSContext* aCx,
+                   const nsString& aScriptText,
+                   const nsCString& aFilename,
+                   nsAutoJSObjectHolder& aScriptObj);
+
+  private:
+    JSContext* mCx;
+    nsString mScriptText;
+    nsCString mFilename;
+    nsAutoJSObjectHolder& mScriptObj;
+  };
+
+  class ScriptLoaderDone : public ScriptLoaderRunnable
+  {
+  public:
+    NS_DECL_NSIRUNNABLE
+
+    ScriptLoaderDone(nsDOMWorkerScriptLoader* aLoader,
+                     volatile PRBool* aDoneFlag);
+
+  private:
+    volatile PRBool* mDoneFlag;
+  };
+
+  class AutoSuspendWorkerEvents
+  {
+  public:
+    AutoSuspendWorkerEvents(nsDOMWorkerScriptLoader* aLoader);
+    ~AutoSuspendWorkerEvents();
+
+  private:
+    nsDOMWorkerScriptLoader* mLoader;
+  };
+
+  struct ScriptLoadInfo
+  {
+    ScriptLoadInfo() : done(PR_FALSE), result(NS_ERROR_NOT_INITIALIZED) { }
+
+    nsString url;
+    nsString scriptText;
+    PRBool done;
+    nsresult result;
+    nsCOMPtr<nsIURI> finalURI;
+    nsCOMPtr<nsIChannel> channel;
+    nsAutoJSObjectHolder scriptObj;
+  };
+
+  nsDOMWorkerThread* mWorker;
+  nsIThread* mTarget;
+  JSContext* mCx;
+
+  nsRefPtr<ScriptLoaderDone> mDoneRunnable;
+
+  PRUint32 mScriptCount;
+  nsTArray<ScriptLoadInfo> mLoadInfos;
+
+  PRPackedBool mCanceled;
+  PRPackedBool mTrackedByWorker;
+
+  // Protected by mWorker's lock!
+  nsTArray<ScriptLoaderRunnable*> mPendingRunnables;
+};
+
+#endif /* __NSDOMWORKERSCRIPTLOADER_H__ */
diff -r b7bcdd009540 dom/src/threads/nsDOMWorkerSecurityManager.cpp
--- a/dom/src/threads/nsDOMWorkerSecurityManager.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/dom/src/threads/nsDOMWorkerSecurityManager.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -44,16 +44,39 @@
 // Other includes
 #include "jsapi.h"
 
 // DOMWorker includes
 #include "nsDOMThreadService.h"
 
 #define LOG(_args) PR_LOG(gDOMThreadsLog, PR_LOG_DEBUG, _args)
 
+class nsDOMWorkerPrincipal : public JSPrincipals
+{
+public:
+  nsDOMWorkerPrincipal() {
+    codebase = "domworkerthread";
+    getPrincipalArray = NULL;
+    globalPrivilegesEnabled = NULL;
+    refcount = 1;
+    destroy = nsDOMWorkerPrincipal::Destroy;
+    subsume = nsDOMWorkerPrincipal::Subsume;
+  }
+
+  static void Destroy(JSContext*, JSPrincipals*) {
+    // nothing
+  }
+
+  static JSBool Subsume(JSPrincipals*, JSPrincipals*) {
+    return JS_TRUE;
+  }
+};
+
+static nsDOMWorkerPrincipal gWorkerPrincipal;
+
 NS_IMPL_THREADSAFE_ISUPPORTS1(nsDOMWorkerSecurityManager,
                               nsIXPCSecurityManager)
 
 NS_IMETHODIMP
 nsDOMWorkerSecurityManager::CanCreateWrapper(JSContext* aJSContext,
                                              const nsIID& aIID,
                                              nsISupports* aObj,
                                              nsIClassInfo* aClassInfo,
@@ -83,8 +106,38 @@ nsDOMWorkerSecurityManager::CanAccess(PR
                                       JSObject* aJSObject,
                                       nsISupports* aObj,
                                       nsIClassInfo* aClassInfo,
                                       jsval aName,
                                       void** aPolicy)
 {
   return NS_OK;
 }
+
+JSPrincipals*
+nsDOMWorkerSecurityManager::WorkerPrincipal()
+{
+  return &gWorkerPrincipal;
+}
+
+JSBool
+nsDOMWorkerSecurityManager::JSCheckAccess(JSContext* aCx,
+                                          JSObject* aObj,
+                                          jsval aId,
+                                          JSAccessMode aMode,
+                                          jsval* aVp)
+{
+  return JS_TRUE;
+}
+
+JSPrincipals*
+nsDOMWorkerSecurityManager::JSFindPrincipal(JSContext* aCx, JSObject* aObj)
+{
+  return WorkerPrincipal();
+}
+
+JSBool
+nsDOMWorkerSecurityManager::JSTranscodePrincipals(JSXDRState* aXdr,
+                                                 JSPrincipals** aJsprinp)
+{
+  NS_NOTREACHED("Shouldn't ever call this!");
+  return JS_FALSE;
+}
diff -r b7bcdd009540 dom/src/threads/nsDOMWorkerSecurityManager.h
--- a/dom/src/threads/nsDOMWorkerSecurityManager.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/dom/src/threads/nsDOMWorkerSecurityManager.h	Thu Sep 11 15:19:25 2008 +0300
@@ -35,17 +35,28 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef __NSDOMWORKERSECURITYMANAGER_H__
 #define __NSDOMWORKERSECURITYMANAGER_H__
 
 #include "nsIXPCSecurityManager.h"
+#include "jsapi.h"
 
 class nsDOMWorkerSecurityManager : public nsIXPCSecurityManager
 {
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSIXPCSECURITYMANAGER
+
+  static JSPrincipals* WorkerPrincipal();
+
+  static JSBool JSCheckAccess(JSContext* aCx, JSObject* aObj, jsval aId,
+                              JSAccessMode aMode, jsval* aVp);
+
+  static JSPrincipals* JSFindPrincipal(JSContext* aCx, JSObject* aObj);
+
+  static JSBool JSTranscodePrincipals(JSXDRState* aXdr,
+                                      JSPrincipals** aJsprinp);
 };
 
 #endif /* __NSDOMWORKERSECURITYMANAGER_H__ */
diff -r b7bcdd009540 dom/src/threads/nsDOMWorkerThread.cpp
--- a/dom/src/threads/nsDOMWorkerThread.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/dom/src/threads/nsDOMWorkerThread.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -49,19 +49,22 @@
 // Other includes
 #ifdef MOZ_SHARK
 #include "jsdbgapi.h"
 #endif
 #include "nsAutoLock.h"
 #include "nsContentUtils.h"
 #include "nsJSUtils.h"
 #include "nsJSEnvironment.h"
+#include "nsThreadUtils.h"
 
 // DOMWorker includes
 #include "nsDOMWorkerPool.h"
+#include "nsDOMWorkerScriptLoader.h"
+#include "nsDOMWorkerSecurityManager.h"
 #include "nsDOMThreadService.h"
 #include "nsDOMWorkerTimeout.h"
 
 #define LOG(_args) PR_LOG(gDOMThreadsLog, PR_LOG_DEBUG, _args)
 
 // XXX Could make these functions of nsDOMWorkerThread instead.
 class nsDOMWorkerFunctions
 {
@@ -87,16 +90,19 @@ public:
   // Same as window.setInterval().
   static JSBool SetInterval(JSContext* aCx, JSObject* aObj, uintN aArgc,
                             jsval* aArgv, jsval* aRval) {
     return MakeTimeout(aCx, aObj, aArgc, aArgv, aRval, PR_TRUE);
   }
 
   // Used for both clearTimeout() and clearInterval().
   static JSBool KillTimeout(JSContext* aCx, JSObject* aObj, uintN aArgc,
+                            jsval* aArgv, jsval* aRval);
+
+  static JSBool LoadScripts(JSContext* aCx, JSObject* aObj, uintN aArgc,
                             jsval* aArgv, jsval* aRval);
 
 private:
   // Internal helper for SetTimeout and SetInterval.
   static JSBool MakeTimeout(JSContext* aCx, JSObject* aObj, uintN aArgc,
                             jsval* aArgv, jsval* aRval, PRBool aIsInterval);
 };
 
@@ -154,17 +160,21 @@ nsDOMWorkerFunctions::PostMessage(JSCont
 
   JSString* str;
   if (aArgc && (str = JS_ValueToString(aCx, aArgv[0])) && str) {
     rv = pool->PostMessageInternal(nsDependentJSString(str), worker);
   }
   else {
     rv = pool->PostMessageInternal(EmptyString(), worker);
   }
-  NS_ENSURE_SUCCESS(rv, JS_FALSE);
+
+  if (NS_FAILED(rv)) {
+    JS_ReportError(aCx, "Failed to post message!");
+    return JS_FALSE;
+  }
 
   return JS_TRUE;
 }
 
 JSBool
 nsDOMWorkerFunctions::MakeTimeout(JSContext* aCx,
                                   JSObject* /* aObj */,
                                   uintN aArgc,
@@ -179,20 +189,26 @@ nsDOMWorkerFunctions::MakeTimeout(JSCont
   if (worker->IsCanceled()) {
     return JS_FALSE;
   }
 
   PRUint32 id = ++worker->mNextTimeoutId;
 
   nsAutoPtr<nsDOMWorkerTimeout>
     timeout(new nsDOMWorkerTimeout(worker, id));
-  NS_ENSURE_TRUE(timeout, JS_FALSE);
+  if (!timeout) {
+    JS_ReportOutOfMemory(aCx);
+    return JS_FALSE;
+  }
 
   nsresult rv = timeout->Init(aCx, aArgc, aArgv, aIsInterval);
-  NS_ENSURE_SUCCESS(rv, JS_FALSE);
+  if (NS_FAILED(rv)) {
+    JS_ReportError(aCx, "Failed to initialize timeout!");
+    return JS_FALSE;
+  }
 
   timeout.forget();
 
   *aRval = INT_TO_JSVAL(id);
   return JS_TRUE;
 }
 
 JSBool
@@ -221,24 +237,86 @@ nsDOMWorkerFunctions::KillTimeout(JSCont
     JS_ReportError(aCx, "First argument must be a timeout id");
     return JS_FALSE;
   }
 
   worker->CancelTimeout(PRUint32(id));
   return JS_TRUE;
 }
 
+JSBool
+nsDOMWorkerFunctions::LoadScripts(JSContext* aCx,
+                                  JSObject* /* aObj */,
+                                  uintN aArgc,
+                                  jsval* aArgv,
+                                  jsval* /* aRval */)
+{
+  nsDOMWorkerThread* worker =
+    static_cast<nsDOMWorkerThread*>(JS_GetContextPrivate(aCx));
+  NS_ASSERTION(worker, "This should be set by the DOM thread service!");
+
+  if (worker->IsCanceled()) {
+    return JS_FALSE;
+  }
+
+  if (!aArgc) {
+    JS_ReportError(aCx, "Function must have at least one argument!");
+    return JS_FALSE;
+  }
+
+  nsAutoTArray<nsString, 5> urls;
+
+  if (!urls.SetCapacity((PRUint32)aArgc)) {
+    JS_ReportOutOfMemory(aCx);
+    return JS_FALSE;
+  }
+
+  for (uintN index = 0; index < aArgc; index++) {
+    jsval val = aArgv[index];
+
+    if (!JSVAL_IS_STRING(val)) {
+      JS_ReportError(aCx, "Argument %d must be a string", index);
+      return JS_FALSE;
+    }
+
+    JSString* str = JS_ValueToString(aCx, val);
+    if (!str) {
+      JS_ReportError(aCx, "Couldn't convert argument %d to a string", index);
+      return JS_FALSE;
+    }
+
+    nsString* newURL = urls.AppendElement();
+    NS_ASSERTION(newURL, "Shouldn't fail if SetCapacity succeeded above!");
+
+    newURL->Assign(nsDependentJSString(str));
+  }
+
+  nsRefPtr<nsDOMWorkerScriptLoader> loader = new nsDOMWorkerScriptLoader();
+  if (!loader) {
+    JS_ReportOutOfMemory(aCx);
+    return JS_FALSE;
+  }
+
+  nsresult rv = loader->LoadScripts(worker, aCx, urls);
+  if (NS_FAILED(rv)) {
+    return JS_FALSE;
+  }
+
+  return JS_TRUE;
+}
+
 JSFunctionSpec gDOMWorkerFunctions[] = {
   { "dump",                  nsDOMWorkerFunctions::Dump,              1, 0, 0 },
   { "debug",                 nsDOMWorkerFunctions::DebugDump,         1, 0, 0 },
   { "postMessageToPool",     nsDOMWorkerFunctions::PostMessage,       1, 0, 0 },
   { "setTimeout",            nsDOMWorkerFunctions::SetTimeout,        1, 0, 0 },
   { "clearTimeout",          nsDOMWorkerFunctions::KillTimeout,       1, 0, 0 },
   { "setInterval",           nsDOMWorkerFunctions::SetInterval,       1, 0, 0 },
   { "clearInterval",         nsDOMWorkerFunctions::KillTimeout,       1, 0, 0 },
+  { "loadScripts",           nsDOMWorkerFunctions::LoadScripts,       1, 0, 0 },
 #ifdef MOZ_SHARK
   { "startShark",            js_StartShark,                           0, 0, 0 },
   { "stopShark",             js_StopShark,                            0, 0, 0 },
   { "connectShark",          js_ConnectShark,                         0, 0, 0 },
   { "disconnectShark",       js_DisconnectShark,                      0, 0, 0 },
 #endif
   { nsnull,                  nsnull,                                  0, 0, 0 }
 };
@@ -301,52 +379,48 @@ nsDOMWorkerThreadContext::GetThisThread(
     NS_ENSURE_TRUE(mWeakRef, NS_ERROR_OUT_OF_MEMORY);
   }
 
   NS_ADDREF(*aThisThread = mWeakRef);
   return NS_OK;
 }
 
 nsDOMWorkerThread::nsDOMWorkerThread(nsDOMWorkerPool* aPool,
-                                     const nsAString& aSource)
+                                     const nsAString& aSource,
+                                     PRBool aSourceIsURL)
 : mPool(aPool),
-  mSource(aSource),
-  mGlobal(nsnull),
   mCompiled(PR_FALSE),
   mCallbackCount(0),
   mNextTimeoutId(0),
   mLock(nsnull)
 {
   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
-  NS_ASSERTION(!aSource.IsEmpty(), "Empty source string!");
+
+  if (aSourceIsURL) {
+    mSourceURL.Assign(aSource);
+    NS_ASSERTION(!mSourceURL.IsEmpty(), "Empty source url!");
+  }
+  else {
+    mSource.Assign(aSource);
+    NS_ASSERTION(!mSource.IsEmpty(), "Empty source string!");
+  }
 
   PR_INIT_CLIST(&mTimeouts);
 }
 
 nsDOMWorkerThread::~nsDOMWorkerThread()
 {
   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
 
   if (!IsCanceled()) {
     nsRefPtr<nsDOMWorkerPool> pool = Pool();
     pool->NoteDyingWorker(this);
   }
 
   ClearTimeouts();
-
-  // Only clean up if we created a global object
-  if (mGlobal) {
-    JSRuntime* rt;
-    if (NS_SUCCEEDED(nsDOMThreadService::JSRuntimeService()->GetRuntime(&rt))) {
-      JS_RemoveRootRT(rt, &mGlobal);
-    }
-    else {
-      NS_ERROR("This shouldn't fail!");
-    }
-  }
 
   if (mLock) {
     nsAutoLock::DestroyLock(mLock);
   }
 }
 
 NS_IMPL_THREADSAFE_ISUPPORTS2(nsDOMWorkerThread, nsIDOMWorkerThread,
                                                  nsIClassInfo)
@@ -357,23 +431,30 @@ nsresult
 nsresult
 nsDOMWorkerThread::Init()
 {
   mLock = nsAutoLock::NewLock("nsDOMWorkerThread::mLock");
   NS_ENSURE_TRUE(mLock, NS_ERROR_OUT_OF_MEMORY);
 
   NS_ASSERTION(!mGlobal, "Already got a global?!");
 
+  JSRuntime* rt;
+  nsresult rv = nsDOMThreadService::JSRuntimeService()->GetRuntime(&rt);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  PRBool success = mGlobal.Hold(rt);
+  NS_ENSURE_TRUE(success, NS_ERROR_FAILURE);
+
   // This is pretty cool - all we have to do to get our script executed is to
   // pass a no-op runnable to the thread service and it will make sure we have
   // a context and global object.
   nsCOMPtr<nsIRunnable> runnable(new nsRunnable());
   NS_ENSURE_TRUE(runnable, NS_ERROR_OUT_OF_MEMORY);
 
-  nsresult rv = nsDOMThreadService::get()->Dispatch(this, runnable);
+  rv = nsDOMThreadService::get()->Dispatch(this, runnable);
   NS_ENSURE_SUCCESS(rv, rv);
 
   return NS_OK;
 }
 
 // From nsDOMWorkerBase
 nsresult
 nsDOMWorkerThread::HandleMessage(const nsAString& aMessage,
@@ -440,24 +521,20 @@ nsDOMWorkerThread::HandleMessage(const n
   JSObject* listener;
   rv = wrappedListener->GetJSObject(&listener);
   NS_ENSURE_SUCCESS(rv, rv);
 
   // And call it.
   jsval rval;
   PRBool success = JS_CallFunctionValue(cx, mGlobal, OBJECT_TO_JSVAL(listener),
                                         2, argv, &rval);
-  if (!success) {
+  if (!success && JS_IsExceptionPending(cx)) {
     // Make sure any pending exceptions are converted to errors for the pool.
     JS_ReportPendingException(cx);
   }
-
-  // We shouldn't leave any pending exceptions - our error reporter should
-  // clear any exception it reports.
-  NS_ASSERTION(!JS_IsExceptionPending(cx), "Huh?!");
 
   return NS_OK;
 }
 
 // From nsDOMWorkerBase
 nsresult
 nsDOMWorkerThread::DispatchMessage(nsIRunnable* aRunnable)
 {
@@ -466,16 +543,19 @@ nsDOMWorkerThread::DispatchMessage(nsIRu
 
   return NS_OK;
 }
 
 void
 nsDOMWorkerThread::Cancel()
 {
   nsDOMWorkerBase::Cancel();
+
+  // Do this before waiting on the thread service below!
+  CancelScriptLoaders();
 
   // If we're suspended there's a good chance that we're already paused waiting
   // on the pool's monitor. Waiting on the thread service's lock will deadlock.
   if (!IsSuspended()) {
     nsDOMThreadService::get()->WaitForCanceledWorker(this);
   }
 
   ClearTimeouts();
@@ -494,17 +574,19 @@ nsDOMWorkerThread::Resume()
   nsDOMWorkerBase::Resume();
   ResumeTimeouts();
 }
 
 PRBool
 nsDOMWorkerThread::SetGlobalForContext(JSContext* aCx)
 {
   PRBool success = CompileGlobalObject(aCx);
-  NS_ENSURE_TRUE(success, PR_FALSE);
+  if (!success) {
+    return PR_FALSE;
+  }
 
   JS_SetGlobalObject(aCx, mGlobal);
   return PR_TRUE;
 }
 
 PRBool
 nsDOMWorkerThread::CompileGlobalObject(JSContext* aCx)
 {
@@ -558,42 +640,52 @@ nsDOMWorkerThread::CompileGlobalObject(J
   NS_ENSURE_SUCCESS(rv, PR_FALSE);
 
   // Set up a name for our worker object
   success = JS_DefineProperty(aCx, global, "threadContext",
                               OBJECT_TO_JSVAL(contextObj), nsnull, nsnull,
                               JSPROP_ENUMERATE);
   NS_ENSURE_TRUE(success, PR_FALSE);
 
-  JSScript* script = JS_CompileUCScript(aCx, global,
-                                        reinterpret_cast<const jschar*>
-                                            (mSource.BeginReading()),
-                                        mSource.Length(), nsnull, 1);
-  NS_ENSURE_TRUE(script, PR_FALSE);
+  jsval val;
 
-  JSRuntime* rt;
-  rv = nsDOMThreadService::JSRuntimeService()->GetRuntime(&rt);
-  NS_ENSURE_SUCCESS(rv, PR_FALSE);
+  // From here on out we have to remember to null mGlobal if something fails!
+  mGlobal = global;
 
-  mGlobal = global;
-  success = JS_AddNamedRootRT(rt, &mGlobal, "nsDOMWorkerThread Global Object");
-  if (!success) {
-    NS_WARNING("Failed to root global object for worker thread!");
-    mGlobal = nsnull;
-    return PR_FALSE;
+  if (mSource.IsEmpty()) {
+    NS_ASSERTION(!mSourceURL.IsEmpty(), "Must have a url here!");
+
+    nsRefPtr<nsDOMWorkerScriptLoader> loader = new nsDOMWorkerScriptLoader();
+    NS_ASSERTION(loader, "Out of memory!");
+    if (!loader) {
+      mGlobal = NULL;
+      return PR_FALSE;
+    }
+
+    rv = loader->LoadScript(this, aCx, mSourceURL);
+    JS_ReportPendingException(aCx);
+    if (NS_FAILED(rv)) {
+      mGlobal = NULL;
+      return PR_FALSE;
+    }
   }
+  else {
+    NS_ASSERTION(!mSource.IsEmpty(), "No source text!");
 
-  // Execute the script
-  jsval val;
-  success = JS_ExecuteScript(aCx, global, script, &val);
-  if (!success) {
-    NS_WARNING("Failed to evaluate script for worker thread!");
-    JS_RemoveRootRT(rt, &mGlobal);
-    mGlobal = nsnull;
-    return PR_FALSE;
+    JSPrincipals* principal = nsDOMWorkerSecurityManager::WorkerPrincipal();
+
+    // Evaluate and execute the script
+    success = JS_EvaluateUCScriptForPrincipals(aCx, global, principal,
+                                               mSource.get(), mSource.Length(),
+                                               "DOMWorker inline script", 1,
+                                               &val);
+    if (!success) {
+      mGlobal = NULL;
+      return PR_FALSE;
+    }
   }
 
   // See if the message listener function was defined.
   nsCOMPtr<nsIDOMWorkerMessageListener> listener;
   if (JS_LookupProperty(aCx, global, "messageListener", &val) &&
       JSVAL_IS_OBJECT(val) &&
       NS_SUCCEEDED(xpc->WrapJS(aCx, JSVAL_TO_OBJECT(val),
                                NS_GET_IID(nsIDOMWorkerMessageListener),
@@ -740,15 +832,35 @@ nsDOMWorkerThread::ResumeTimeouts()
   PRTime now = PR_Now();
 
   PRUint32 count = timeouts.Length();
   for (PRUint32 i = 0; i < count; i++) {
     timeouts[i]->Resume(now);
   }
 }
 
+void
+nsDOMWorkerThread::CancelScriptLoaders()
+{
+  nsAutoTArray<nsDOMWorkerScriptLoader*, 20> loaders;
+
+  // Must call cancel on the loaders outside the lock!
+  {
+    nsAutoLock lock(mLock);
+    loaders.AppendElements(mScriptLoaders);
+
+    // Don't clear mScriptLoaders, they'll remove themselves as they get
+    // destroyed.
+  }
+
+  PRUint32 loaderCount = loaders.Length();
+  for (PRUint32 index = 0; index < loaderCount; index++) {
+    loaders[index]->Cancel();
+  }
+}
+
 NS_IMETHODIMP
 nsDOMWorkerThread::PostMessage(const nsAString& aMessage)
 {
   nsresult rv = PostMessageInternal(aMessage);
   NS_ENSURE_SUCCESS(rv, rv);
   return NS_OK;
 }
diff -r b7bcdd009540 dom/src/threads/nsDOMWorkerThread.h
--- a/dom/src/threads/nsDOMWorkerThread.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/dom/src/threads/nsDOMWorkerThread.h	Thu Sep 11 15:19:25 2008 +0300
@@ -42,18 +42,20 @@
 
 // Bases
 #include "nsDOMWorkerBase.h"
 #include "nsIClassInfo.h"
 #include "nsIDOMThreads.h"
 
 // Other includes
 #include "jsapi.h"
+#include "nsAutoJSObjectHolder.h"
 #include "nsCOMPtr.h"
 #include "nsStringGlue.h"
+#include "nsTArray.h"
 #include "nsThreadUtils.h"
 #include "prclist.h"
 #include "prlock.h"
 
 // DOMWorker includes
 #include "nsDOMThreadService.h"
 
 // Macro to generate nsIClassInfo methods for these threadsafe DOM classes 
@@ -108,37 +110,40 @@ _class::GetFlags(PRUint32* _flags)      
                                                                               \
 NS_IMETHODIMP                                                                 \
 _class::GetClassIDNoAlloc(nsCID* _classIDNoAlloc)                             \
 {                                                                             \
   return NS_ERROR_NOT_AVAILABLE;                                              \
 }
 
 class nsDOMWorkerPool;
+class nsDOMWorkerScriptLoader;
 class nsDOMWorkerTimeout;
 
 class nsDOMWorkerThread : public nsDOMWorkerBase,
                           public nsIDOMWorkerThread,
                           public nsIClassInfo
 {
   friend class nsDOMCreateJSContextRunnable;
   friend class nsDOMWorkerFunctions;
   friend class nsDOMWorkerPool;
   friend class nsDOMWorkerRunnable;
+  friend class nsDOMWorkerScriptLoader;
   friend class nsDOMWorkerTimeout;
 
   friend JSBool DOMWorkerOperationCallback(JSContext* aCx);
 
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSIDOMWORKERTHREAD
   NS_DECL_NSICLASSINFO
 
   nsDOMWorkerThread(nsDOMWorkerPool* aPool,
-                    const nsAString& aSource);
+                    const nsAString& aSource,
+                    PRBool aSourceIsURL);
 
   virtual nsDOMWorkerPool* Pool() {
     NS_ASSERTION(!IsCanceled(), "Don't touch Pool after we've been canceled!");
     return mPool;
   }
 
 private:
   virtual ~nsDOMWorkerThread();
@@ -164,23 +169,32 @@ private:
 
   void AddTimeout(nsDOMWorkerTimeout* aTimeout);
   void RemoveTimeout(nsDOMWorkerTimeout* aTimeout);
   void ClearTimeouts();
   void CancelTimeout(PRUint32 aId);
   void SuspendTimeouts();
   void ResumeTimeouts();
 
+  void CancelScriptLoaders();
+
+  PRLock* Lock() {
+    return mLock;
+  }
+
   nsDOMWorkerPool* mPool;
   nsString mSource;
+  nsString mSourceURL;
 
-  JSObject* mGlobal;
+  nsAutoJSObjectHolder mGlobal;
   PRBool mCompiled;
 
   PRUint32 mCallbackCount;
 
   PRUint32 mNextTimeoutId;
 
   PRLock* mLock;
   PRCList mTimeouts;
+
+  nsTArray<nsDOMWorkerScriptLoader*> mScriptLoaders;
 };
 
 #endif /* __NSDOMWORKERTHREAD_H__ */
diff -r b7bcdd009540 dom/src/threads/test/Makefile.in
--- a/dom/src/threads/test/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/dom/src/threads/test/Makefile.in	Thu Sep 11 15:19:25 2008 +0300
@@ -42,16 +42,22 @@ VPATH            = @srcdir@
 VPATH            = @srcdir@
 
 relativesrcdir   = dom/src/threads/tests
 
 include $(DEPTH)/config/autoconf.mk
 include $(topsrcdir)/config/rules.mk
 
 _TEST_FILES = \
+  importScripts_worker.js \
+  importScripts_worker_imported1.js \
+  importScripts_worker_imported2.js \
+  importScripts_worker_imported3.js \
+  importScripts_worker_imported4.js \
+  test_importScripts.html \
   test_simpleThread.html \
   test_threadErrors.html \
   test_threadTimeouts.html \
   test_longThread.html \
   $(NULL)
 
 libs:: $(_TEST_FILES)
 	$(INSTALL) $(foreach f,$^,"$f") $(DEPTH)/_tests/testing/mochitest/tests/$(relativesrcdir)
diff -r b7bcdd009540 dom/src/threads/test/importScripts_worker.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/src/threads/test/importScripts_worker.js	Thu Sep 11 15:19:25 2008 +0300
@@ -0,0 +1,54 @@
+function messageListener(message, source) {
+  switch (message) {
+    case 'start':
+      loadScripts("importScripts_worker_imported2.js");
+      importedScriptFunction2();
+      tryBadScripts();
+      source.postMessage('started');
+      break;
+    case 'stop':
+      tryBadScripts();
+      postMessageToPool('stopped');
+      break;
+    default:
+      throw new Error("Bad message: " + message);
+      break;
+  }
+}
+
+// This caused security exceptions in the past, make sure it doesn't!
+var constructor = {}.constructor;
+
+loadScripts("importScripts_worker_imported1.js");
+
+// Try to call a function defined in the imported script.
+importedScriptFunction();
+
+function tryBadScripts() {
+  var badScripts = [
+    // Has a syntax error
+    "importScripts_worker_imported3.js",
+    // Throws an exception
+    "importScripts_worker_imported4.js",
+    // Shouldn't exist!
+    "http://flippety.com/floppety/foo.js",
+    // Not a valid url
+    "http://flippety::foo_js ftw"
+  ];
+
+  for (var i = 0; i < badScripts.length; i++) {
+    var caughtException = false;
+    var url = badScripts[i];
+    try {
+      loadScripts(url);
+    }
+    catch (e) {
+      caughtException = true;
+    }
+    if (!caughtException) {
+      throw "Bad script didn't throw exception: " + url;
+    }
+  }
+}
+
+tryBadScripts();
diff -r b7bcdd009540 dom/src/threads/test/importScripts_worker_imported1.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/src/threads/test/importScripts_worker_imported1.js	Thu Sep 11 15:19:25 2008 +0300
@@ -0,0 +1,7 @@
+// This caused security exceptions in the past, make sure it doesn't!
+var myConstructor = {}.constructor;
+
+// Try to call a function defined in the imported script.
+function importedScriptFunction() {
+  dump("running importedScriptFunction\n");
+}
diff -r b7bcdd009540 dom/src/threads/test/importScripts_worker_imported2.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/src/threads/test/importScripts_worker_imported2.js	Thu Sep 11 15:19:25 2008 +0300
@@ -0,0 +1,7 @@
+// This caused security exceptions in the past, make sure it doesn't!
+var myConstructor2 = {}.constructor;
+
+// Try to call a function defined in the imported script.
+function importedScriptFunction2() {
+  dump("running importedScriptFunction2\n");
+}
diff -r b7bcdd009540 dom/src/threads/test/importScripts_worker_imported3.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/src/threads/test/importScripts_worker_imported3.js	Thu Sep 11 15:19:25 2008 +0300
@@ -0,0 +1,2 @@
+// Deliberate syntax error, should generate a worker exception!
+for (var index = 0; index < 100) {}
diff -r b7bcdd009540 dom/src/threads/test/importScripts_worker_imported4.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/src/threads/test/importScripts_worker_imported4.js	Thu Sep 11 15:19:25 2008 +0300
@@ -0,0 +1,2 @@
+// Deliberate throw, should generate a worker exception!
+throw new Error("Bah!");
diff -r b7bcdd009540 dom/src/threads/test/test_importScripts.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/src/threads/test/test_importScripts.html	Thu Sep 11 15:19:25 2008 +0300
@@ -0,0 +1,49 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+Tests of DOM Worker Threads (Bug 437152)
+-->
+<head>
+  <title>Test for DOM Worker Threads (Bug 437152)</title>
+  <script type="text/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=437152">DOM Worker Threads Bug 437152</a>
+<p id="display"></p>
+<div id="content" style="display: none">
+  
+</div>
+<pre id="test">
+<script class="testbody" type="text/javascript">
+
+  var pool = navigator.newWorkerPool();
+  pool.messageListener = function(message, source) {
+    switch (message) {
+      case "started":
+        source.postMessage("stop");
+        break;
+      case "stopped":
+        SimpleTest.finish();
+        break;
+      default:
+        ok(false, "Unexpected message:" + message);
+        SimpleTest.finish();
+    }
+  };
+
+  pool.errorListener = function(error, source) {
+    ok(false, "Worker had an error:" + error);
+    SimpleTest.finish();
+  }
+
+  var worker = pool.createWorkerFromURL("importScripts_worker.js");
+  worker.postMessage("start");
+
+  SimpleTest.waitForExplicitFinish();
+</script>
+</pre>
+</body>
+</html>
+
diff -r b7bcdd009540 dom/tests/Makefile.in
--- a/dom/tests/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/dom/tests/Makefile.in	Thu Sep 11 15:19:25 2008 +0300
@@ -39,18 +39,15 @@ topsrcdir	= @top_srcdir@
 topsrcdir	= @top_srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 MODULE = test_dom
 
-ifdef MOZ_MOCHITEST
+ifdef ENABLE_TESTS
 DIRS		+= mochitest
-endif
-
-ifdef ENABLE_TESTS
 XPCSHELL_TESTS = unit
 endif
 
 include $(topsrcdir)/config/rules.mk
 
diff -r b7bcdd009540 editor/composer/Makefile.in
--- a/editor/composer/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/editor/composer/Makefile.in	Thu Sep 11 15:19:25 2008 +0300
@@ -43,17 +43,17 @@ include $(DEPTH)/config/autoconf.mk
 include $(DEPTH)/config/autoconf.mk
 
 DIRS		= public
 
 ifndef MOZ_PLAINTEXT_EDITOR_ONLY
 DIRS		+= src
 endif
 
-ifdef MOZ_MOCHITEST
+ifdef ENABLE_TESTS
 DIRS		+= test
 endif
 
 # Enable Editor API Logging!
 ENABLE_EDITOR_API_LOG=1
 
 ifdef ENABLE_EDITOR_API_LOG
 DEFINES += -DENABLE_EDITOR_API_LOG
diff -r b7bcdd009540 embedding/Makefile.in
--- a/embedding/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/embedding/Makefile.in	Thu Sep 11 15:19:25 2008 +0300
@@ -45,15 +45,12 @@ include $(DEPTH)/config/autoconf.mk
 
 MODULE       = embed
 PACKAGE_FILE = embed.pkg
 
 DIRS = base components browser
 
 ifdef ENABLE_TESTS
 XPCSHELL_TESTS = tests/unit
-endif
-
-ifdef MOZ_MOCHITEST
 DIRS += test
 endif
 
 include $(topsrcdir)/config/rules.mk
diff -r b7bcdd009540 embedding/browser/activex/src/plugin/LegacyPlugin.cpp
--- a/embedding/browser/activex/src/plugin/LegacyPlugin.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/embedding/browser/activex/src/plugin/LegacyPlugin.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -769,33 +769,33 @@ CreateControl(const CLSID &clsid, Plugin
     pData->pControlSite = pSite;
 
     return NPERR_NO_ERROR;
 }
 
 static NPError
 NewControl(const char *pluginType,
            PluginInstanceData *pData,
-           uint16 mode,
-           int16 argc,
+           uint16_t mode,
+           int16_t argc,
            char *argn[],
            char *argv[])
 {
     // Read the parameters
     CLSID clsid = CLSID_NULL;
     CComBSTR codebase;
     PropertyList pl;
 
     if (strcmp(pluginType, MIME_OLEOBJECT1) != 0 &&
         strcmp(pluginType, MIME_OLEOBJECT2) != 0)
     {
         clsid = MozAxPlugin::GetCLSIDForType(pluginType);
     }
 
-    for (int16 i = 0; i < argc; i++)
+    for (int16_t i = 0; i < argc; i++)
     {
         if (stricmp(argn[i], "CLSID") == 0 ||
             stricmp(argn[i], "CLASSID") == 0)
         {
             // Accept CLSIDs specified in various ways
             // e.g:
             //   "CLSID:C16DF970-D1BA-11d2-A252-000000000000"
             //   "C16DF970-D1BA-11d2-A252-000000000000"
@@ -918,18 +918,18 @@ NewControl(const char *pluginType,
 
 // NPP_New
 //
 //    create a new plugin instance 
 //    handle any instance specific code initialization here
 //
 NPError NP_LOADDS NPP_New(NPMIMEType pluginType,
                 NPP instance,
-                uint16 mode,
-                int16 argc,
+                uint16_t mode,
+                int16_t argc,
                 char* argn[],
                 char* argv[],
                 NPSavedData* saved)
 {
     ATLTRACE(_T("NPP_New()\n"));
 
     // trap duff args
     if (instance == NULL)
@@ -1123,17 +1123,17 @@ NPP_SetWindow(NPP instance, NPWindow* wi
 //  NPNormal  (e.g. *streamtype = NPNormal)...the NPE_StreamAsFile function will
 //  never be called in this case
 //
 NPError NP_LOADDS
 NPP_NewStream(NPP instance,
               NPMIMEType type,
               NPStream *stream, 
               NPBool seekable,
-              uint16 *stype)
+              uint16_t *stype)
 {
     ATLTRACE(_T("NPP_NewStream()\n"));
 
     if(!instance)
     {
         return NPERR_INVALID_INSTANCE_ERROR;
     }
 
@@ -1167,39 +1167,39 @@ NPP_StreamAsFile(NPP instance, NPStream 
 //        For a NPAsFile stream, they are still called but can safely 
 //        be ignored.
 //
 //        In a streaming plugin, all data handling would take place here...
 //
 ////\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//.
 //\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\.
 
-int32 STREAMBUFSIZE = 0X0FFFFFFF;   // we are reading from a file in NPAsFile mode
-                                    // so we can take any size stream in our write
-                                    // call (since we ignore it)
+int32_t STREAMBUFSIZE = 0X0FFFFFFF;   // we are reading from a file in NPAsFile mode
+                                      // so we can take any size stream in our write
+                                      // call (since we ignore it)
                                 
 
 // NPP_WriteReady
 //
 //    The number of bytes that a plug-in is willing to accept in a subsequent
 //    NPO_Write call.
 //
-int32 NP_LOADDS
+int32_t NP_LOADDS
 NPP_WriteReady(NPP instance, NPStream *stream)
 {
     return STREAMBUFSIZE;  
 }
 
 
 // NPP_Write
 //
 //    Provides len bytes of data.
 //
-int32 NP_LOADDS
-NPP_Write(NPP instance, NPStream *stream, int32 offset, int32 len, void *buffer)
+int32_t NP_LOADDS
+NPP_Write(NPP instance, NPStream *stream, int32_t offset, int32_t len, void *buffer)
 {   
     return len;
 }
 
 
 // NPP_DestroyStream
 //
 //    Closes a stream object.  
diff -r b7bcdd009540 embedding/browser/activex/src/plugin/npwin.cpp
--- a/embedding/browser/activex/src/plugin/npwin.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/embedding/browser/activex/src/plugin/npwin.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -163,31 +163,31 @@ NPError NPN_GetURLNotify(NPP instance, c
 }
 
 
 NPError NPN_GetURL(NPP instance, const char *url, const char *target)
 {
     return g_pNavigatorFuncs->geturl(instance, url, target);
 }
 
-NPError NPN_PostURLNotify(NPP instance, const char* url, const char* window, uint32 len, const char* buf, NPBool file, void* notifyData)
+NPError NPN_PostURLNotify(NPP instance, const char* url, const char* window, uint32_t len, const char* buf, NPBool file, void* notifyData)
 {
 	int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
 	NPError err;
 	if( navMinorVers >= NPVERS_HAS_NOTIFICATION ) {
 		err = g_pNavigatorFuncs->posturlnotify(instance, url, window, len, buf, file, notifyData);
 	}
 	else {
 		err = NPERR_INCOMPATIBLE_VERSION_ERROR;
 	}
 	return err;
 }
 
 
-NPError NPN_PostURL(NPP instance, const char* url, const char* window, uint32 len, const char* buf, NPBool file)
+NPError NPN_PostURL(NPP instance, const char* url, const char* window, uint32_t len, const char* buf, NPBool file)
 {
     return g_pNavigatorFuncs->posturl(instance, url, window, len, buf, file);
 }
 
 /* Requests that a number of bytes be provided on a stream.  Typically
    this would be used if a stream was in "pull" mode.  An optional
    position can be provided for streams which are seekable.
 */
@@ -211,21 +211,21 @@ NPError NPN_NewStream(NPP instance, NPMI
 	else {
 		err = NPERR_INCOMPATIBLE_VERSION_ERROR;
 	}
 	return err;
 }
 
 /* Provides len bytes of data.
 */
-int32 NPN_Write(NPP instance, NPStream *stream,
-                int32 len, void *buffer)
+int32_t NPN_Write(NPP instance, NPStream *stream,
+                  int32_t len, void *buffer)
 {
 	int navMinorVersion = g_pNavigatorFuncs->version & 0xFF;
-	int32 result;
+	int32_t result;
 
 	if( navMinorVersion >= NPVERS_HAS_STREAMOUTPUT ) {
 		result = g_pNavigatorFuncs->write(instance, stream, len, buffer);
 	}
 	else {
 		result = -1;
 	}
 	return result;
@@ -262,17 +262,17 @@ const char* NPN_UserAgent(NPP instance)
     return g_pNavigatorFuncs->uagent(instance);
 }
 
 /* allocates memory from the Navigator's memory space.  Necessary so that
    saved instance data may be freed by Navigator when exiting.
 */
 
 
-void* NPN_MemAlloc(uint32 size)
+void* NPN_MemAlloc(uint32_t size)
 {
     return g_pNavigatorFuncs->memalloc(size);
 }
 
 /* reciprocal of MemAlloc() above
 */
 void NPN_MemFree(void* ptr)
 {
diff -r b7bcdd009540 extensions/reporter/locales/l10n.ini
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/extensions/reporter/locales/l10n.ini	Thu Sep 11 15:19:25 2008 +0300
@@ -0,0 +1,5 @@
+[general]
+depth = ../../..
+
+[compare]
+dirs = extensions/reporter
diff -r b7bcdd009540 extensions/universalchardet/tests/Makefile.in
--- a/extensions/universalchardet/tests/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/extensions/universalchardet/tests/Makefile.in	Thu Sep 11 15:19:25 2008 +0300
@@ -62,17 +62,16 @@ LIBS		+= \
 LIBS		+= \
 		$(LIBS_DIR) \
 		../src/base/$(LIB_PREFIX)universalchardet_s.$(LIB_SUFFIX) \
 		$(NSPR_LIBS) \
 		$(NULL)
 
 include $(topsrcdir)/config/rules.mk
 
-ifdef MOZ_MOCHITEST
 relativesrcdir = extensions/universalchardet/tests
 
 _TEST_FILES =	\
 		CharsetDetectionTests.js \
 		bug9357_text.html \
 		test_bug9357.html \
 		bug171813_text.html \
 		test_bug171813.html \
@@ -83,10 +82,8 @@ _TEST_FILES =	\
 		bug426271_text-euc-jp.html \
 		test_bug426271-euc-jp.html \
 		bug426271_text-utf-8.html \
 		test_bug426271-utf-8.html \
 		$(NULL)
 
 libs:: $(_TEST_FILES)
 	$(INSTALL) $(foreach f,$^,"$f") $(DEPTH)/_tests/testing/mochitest/tests/$(relativesrcdir)
-
-endif # MOZ_MOCHITEST
diff -r b7bcdd009540 gfx/public/nsIImage.h
--- a/gfx/public/nsIImage.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/gfx/public/nsIImage.h	Thu Sep 11 15:19:25 2008 +0300
@@ -154,21 +154,22 @@ public:
    * Get the number of bytes per scanline for the alpha mask
    * @update - dwc 2/1/99
    * @return The number of bytes in each scanline
    */
   virtual PRInt32 GetAlphaLineStride() = 0;
 
   /**
    * Update the nsIImage color table
-   * @update - dwc 2/1/99
+   * @update - dougt 9/9/08
    * @param aFlags Used to pass in parameters for the update
    * @param aUpdateRect The rectangle to update
+   * @return success code. failure means stop decoding
    */
-  virtual void ImageUpdated(nsIDeviceContext *aContext, PRUint8 aFlags, nsIntRect *aUpdateRect) = 0;
+  virtual nsresult ImageUpdated(nsIDeviceContext *aContext, PRUint8 aFlags, nsIntRect *aUpdateRect) = 0;
   
   /**
    * Get whether this image's region is completely filled with data.
    * @return PR_TRUE if image is complete, PR_FALSE if image is not yet 
    *         complete or broken
    */
   virtual PRBool GetIsImageComplete() = 0;
 
diff -r b7bcdd009540 gfx/src/thebes/nsThebesImage.cpp
--- a/gfx/src/thebes/nsThebesImage.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/gfx/src/thebes/nsThebesImage.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -214,24 +214,36 @@ nsThebesImage::GetAlphaBits()
 }
 
 PRInt32
 nsThebesImage::GetAlphaLineStride()
 {
     return (mAlphaDepth > 0) ? mStride : 0;
 }
 
-void
+nsresult
 nsThebesImage::ImageUpdated(nsIDeviceContext *aContext, PRUint8 aFlags, nsRect *aUpdateRect)
 {
+    // Check to see if we are running OOM
+    nsCOMPtr<nsIMemory> mem;
+    NS_GetMemoryManager(getter_AddRefs(mem));
+    if (!mem)
+        return NS_ERROR_UNEXPECTED;
+
+    PRBool lowMemory;
+    mem->IsLowMemory(&lowMemory);
+    if (lowMemory)
+        return NS_ERROR_OUT_OF_MEMORY;
+
     mDecoded.UnionRect(mDecoded, *aUpdateRect);
 #ifdef XP_MACOSX
     if (mQuartzSurface)
         mQuartzSurface->Flush();
 #endif
+    return NS_OK;
 }
 
 PRBool
 nsThebesImage::GetIsImageComplete()
 {
     if (!mImageComplete)
         mImageComplete = (mDecoded == nsRect(0, 0, mWidth, mHeight));
     return mImageComplete;
diff -r b7bcdd009540 gfx/src/thebes/nsThebesImage.h
--- a/gfx/src/thebes/nsThebesImage.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/gfx/src/thebes/nsThebesImage.h	Thu Sep 11 15:19:25 2008 +0300
@@ -66,17 +66,17 @@ public:
     virtual PRInt32 GetWidth();
     virtual PRInt32 GetHeight();
     virtual PRUint8 *GetBits();
     virtual PRInt32 GetLineStride();
     virtual PRBool GetHasAlphaMask();
     virtual PRUint8 *GetAlphaBits();
     virtual PRInt32 GetAlphaLineStride();
     virtual PRBool GetIsImageComplete();
-    virtual void ImageUpdated(nsIDeviceContext *aContext, PRUint8 aFlags, nsRect *aUpdateRect);
+    virtual nsresult ImageUpdated(nsIDeviceContext *aContext, PRUint8 aFlags, nsRect *aUpdateRect);
     virtual nsresult Optimize(nsIDeviceContext* aContext);
     virtual nsColorMap *GetColorMap();
 
     NS_IMETHOD Draw(nsIRenderingContext &aContext,
                     const gfxRect &aSourceRect,
                     const gfxRect &aSubimageRect,
                     const gfxRect &aDestRect);
 
diff -r b7bcdd009540 gfx/thebes/public/gfxPlatform.h
--- a/gfx/thebes/public/gfxPlatform.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/gfx/thebes/public/gfxPlatform.h	Thu Sep 11 15:19:25 2008 +0300
@@ -37,18 +37,21 @@
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef GFX_PLATFORM_H
 #define GFX_PLATFORM_H
 
 #include "prtypes.h"
 #include "nsVoidArray.h"
 
+#include "nsIObserver.h"
+
 #include "gfxTypes.h"
 #include "gfxASurface.h"
+#include "gfxColor.h"
 
 #ifdef XP_OS2
 #undef OS2EMX_PLAIN_CHAR
 #endif
 
 typedef void* cmsHPROFILE;
 typedef void* cmsHTRANSFORM;
 
@@ -231,16 +234,23 @@ public:
      * value is returned. Otherwise, -1 is returned and the embedded intent
      * should be used.
      *
      * See bug 444014 for details.
      */
     static int GetRenderingIntent();
 
     /**
+     * Convert a pixel using a cms transform in an endian-aware manner.
+     *
+     * Sets 'out' to 'in' if transform is NULL.
+     */
+    static void TransformPixel(const gfxRGBA& in, gfxRGBA& out, cmsHTRANSFORM transform);
+
+    /**
      * Return the output device ICC profile.
      */
     static cmsHPROFILE GetCMSOutputProfile();
 
     /**
      * Return the sRGB ICC profile.
      */
     static cmsHPROFILE GetCMSsRGBProfile();
@@ -261,11 +271,13 @@ public:
     static cmsHTRANSFORM GetCMSRGBATransform();
 
 protected:
     gfxPlatform() { }
     virtual ~gfxPlatform();
 
 private:
     virtual cmsHPROFILE GetPlatformCMSOutputProfile();
+
+    nsCOMPtr<nsIObserver> overrideObserver;
 };
 
 #endif /* GFX_PLATFORM_H */
diff -r b7bcdd009540 gfx/thebes/src/gfxContext.cpp
--- a/gfx/thebes/src/gfxContext.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/gfx/thebes/src/gfxContext.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -617,37 +617,26 @@ gfxContext::GetClipExtents()
 }
 
 // rendering sources
 
 void
 gfxContext::SetColor(const gfxRGBA& c)
 {
     if (gfxPlatform::GetCMSMode() == eCMSMode_All) {
-        cmsHTRANSFORM transform = gfxPlatform::GetCMSRGBTransform();
-        if (transform) {
-#ifdef IS_LITTLE_ENDIAN
-            PRUint32 packed = c.Packed(gfxRGBA::PACKED_ABGR);
-            cmsDoTransform(transform,
-                           (PRUint8 *)&packed, (PRUint8 *)&packed,
-                           1);
-            gfxRGBA cms(packed, gfxRGBA::PACKED_ABGR);
-#else
-            PRUint32 packed = c.Packed(gfxRGBA::PACKED_ARGB);
-            cmsDoTransform(transform,
-                           (PRUint8 *)&packed + 1, (PRUint8 *)&packed + 1,
-                           1);
-            gfxRGBA cms(packed, gfxRGBA::PACKED_ARGB);
-#endif
-            cairo_set_source_rgba(mCairo, cms.r, cms.g, cms.b, cms.a);
-            return;
-        }
+
+        gfxRGBA cms;
+        gfxPlatform::TransformPixel(c, cms, gfxPlatform::GetCMSRGBTransform());
+
+        // Use the original alpha to avoid unnecessary float->byte->float
+        // conversion errors
+        cairo_set_source_rgba(mCairo, cms.r, cms.g, cms.b, c.a);
     }
-
-    cairo_set_source_rgba(mCairo, c.r, c.g, c.b, c.a);
+    else
+        cairo_set_source_rgba(mCairo, c.r, c.g, c.b, c.a);
 }
 
 void
 gfxContext::SetDeviceColor(const gfxRGBA& c)
 {
     cairo_set_source_rgba(mCairo, c.r, c.g, c.b, c.a);
 }
 
diff -r b7bcdd009540 gfx/thebes/src/gfxPattern.cpp
--- a/gfx/thebes/src/gfxPattern.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/gfx/thebes/src/gfxPattern.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -83,37 +83,26 @@ gfxPattern::CairoPattern()
 {
     return mPattern;
 }
 
 void
 gfxPattern::AddColorStop(gfxFloat offset, const gfxRGBA& c)
 {
     if (gfxPlatform::GetCMSMode() == eCMSMode_All) {
-        cmsHTRANSFORM transform = gfxPlatform::GetCMSRGBTransform();
-        if (transform) {
-#ifdef IS_LITTLE_ENDIAN
-            PRUint32 packed = c.Packed(gfxRGBA::PACKED_ABGR);
-            cmsDoTransform(transform,
-                           (PRUint8 *)&packed, (PRUint8 *)&packed,
-                           1);
-            gfxRGBA cms(packed, gfxRGBA::PACKED_ABGR);
-#else
-            PRUint32 packed = c.Packed(gfxRGBA::PACKED_ARGB);
-            cmsDoTransform(transform,
-                           (PRUint8 *)&packed + 1, (PRUint8 *)&packed + 1,
-                           1);
-            gfxRGBA cms(packed, gfxRGBA::PACKED_ARGB);
-#endif
-            cairo_pattern_add_color_stop_rgba(mPattern, offset,
-                                              cms.r, cms.g, cms.b, cms.a);
-            return;
-        }
+        gfxRGBA cms;
+        gfxPlatform::TransformPixel(c, cms, gfxPlatform::GetCMSRGBTransform());
+
+        // Use the original alpha to avoid unnecessary float->byte->float
+        // conversion errors
+        cairo_pattern_add_color_stop_rgba(mPattern, offset,
+                                          cms.r, cms.g, cms.b, c.a);
     }
-    cairo_pattern_add_color_stop_rgba(mPattern, offset, c.r, c.g, c.b, c.a);
+    else
+        cairo_pattern_add_color_stop_rgba(mPattern, offset, c.r, c.g, c.b, c.a);
 }
 
 void
 gfxPattern::SetMatrix(const gfxMatrix& matrix)
 {
     cairo_matrix_t mat = *reinterpret_cast<const cairo_matrix_t*>(&matrix);
     cairo_pattern_set_matrix(mPattern, &mat);
 }
diff -r b7bcdd009540 gfx/thebes/src/gfxPlatform.cpp
--- a/gfx/thebes/src/gfxPlatform.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/gfx/thebes/src/gfxPlatform.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -55,42 +55,78 @@
 #include "gfxContext.h"
 #include "gfxImageSurface.h"
 #include "gfxTextRunCache.h"
 #include "gfxTextRunWordCache.h"
 
 #include "nsIPref.h"
 #include "nsServiceManagerUtils.h"
 
+#include "nsWeakReference.h"
+
 #ifdef MOZ_ENABLE_GLITZ
 #include <stdlib.h>
 #endif
 
 #include "cairo.h"
 #include "lcms.h"
 
 #include "plstr.h"
 #include "nsIPrefService.h"
 #include "nsIPrefBranch.h"
+#include "nsIPrefBranch2.h"
 
 gfxPlatform *gPlatform = nsnull;
 int gGlitzState = -1;
 
 // These two may point to the same profile
 static cmsHPROFILE gCMSOutputProfile = nsnull;
 static cmsHPROFILE gCMSsRGBProfile = nsnull;
 
 static cmsHTRANSFORM gCMSRGBTransform = nsnull;
 static cmsHTRANSFORM gCMSInverseRGBTransform = nsnull;
 static cmsHTRANSFORM gCMSRGBATransform = nsnull;
 
+static PRBool gCMSInitialized = PR_FALSE;
+static eCMSMode gCMSMode = eCMSMode_Off;
+static int gCMSIntent = -2;
+
 static const char *CMPrefName = "gfx.color_management.mode";
 static const char *CMPrefNameOld = "gfx.color_management.enabled";
 static const char *CMIntentPrefName = "gfx.color_management.rendering_intent";
+static const char *CMProfilePrefName = "gfx.color_management.display_profile";
+static const char *CMForceSRGBPrefName = "gfx.color_management.force_srgb";
+
+static void ShutdownCMS();
 static void MigratePrefs();
+
+/* Class to listen for pref changes so that chrome code can dynamically
+   force sRGB as an output profile. See Bug #452125. */
+class SRGBOverrideObserver : public nsIObserver,
+                             public nsSupportsWeakReference
+{
+public:
+    NS_DECL_ISUPPORTS
+    NS_DECL_NSIOBSERVER
+};
+
+NS_IMPL_ISUPPORTS2(SRGBOverrideObserver, nsIObserver, nsISupportsWeakReference)
+
+NS_IMETHODIMP
+SRGBOverrideObserver::Observe(nsISupports *aSubject,
+                              const char *aTopic,
+                              const PRUnichar *someData)
+{
+    NS_ASSERTION(NS_strcmp(someData,
+                   NS_LITERAL_STRING("gfx.color_mangement.force_srgb").get()),
+                 "Restarting CMS on wrong pref!");
+    ShutdownCMS();
+    return NS_OK;
+}
+
 
 // this needs to match the list of pref font.default.xx entries listed in all.js!
 // the order *must* match the order in eFontPrefLang
 static const char *gPrefLangNames[] = {
     "x-western",
     "x-central-euro",
     "ja",
     "zh-TW",
@@ -180,56 +216,44 @@ gfxPlatform::Init()
         NS_ERROR("Could not initialize gfxTextRunCache");
         Shutdown();
         return rv;
     }
 
     /* Pref migration hook. */
     MigratePrefs();
 
+    /* Create and register our CMS Override observer. */
+    gPlatform->overrideObserver = new SRGBOverrideObserver();
+    nsCOMPtr<nsIPrefBranch2> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
+    if (prefs)
+        prefs->AddObserver(CMForceSRGBPrefName, gPlatform->overrideObserver, PR_TRUE);
+
     return NS_OK;
 }
 
 void
 gfxPlatform::Shutdown()
 {
     // These may be called before the corresponding subsystems have actually
     // started up. That's OK, they can handle it.
     gfxTextRunCache::Shutdown();
     gfxTextRunWordCache::Shutdown();
     gfxFontCache::Shutdown();
 #if defined(XP_MACOSX)
     gfxQuartzFontCache::Shutdown();
 #endif
 
     // Free the various non-null transforms and loaded profiles
-    if (gCMSRGBTransform) {
-        cmsDeleteTransform(gCMSRGBTransform);
-        gCMSRGBTransform = nsnull;
-    }
-    if (gCMSInverseRGBTransform) {
-        cmsDeleteTransform(gCMSInverseRGBTransform);
-        gCMSInverseRGBTransform = nsnull;
-    }
-    if (gCMSRGBATransform) {
-        cmsDeleteTransform(gCMSRGBATransform);
-        gCMSRGBATransform = nsnull;
-    }
-    if (gCMSOutputProfile) {
-        cmsCloseProfile(gCMSOutputProfile);
+    ShutdownCMS();
 
-        // handle the aliased case
-        if (gCMSsRGBProfile == gCMSOutputProfile)
-            gCMSsRGBProfile = nsnull;
-        gCMSOutputProfile = nsnull;
-    }
-    if (gCMSsRGBProfile) {
-        cmsCloseProfile(gCMSsRGBProfile);
-        gCMSsRGBProfile = nsnull;
-    }
+    /* Unregister our CMS Override callback. */
+    nsCOMPtr<nsIPrefBranch2> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
+    if (prefs)
+        prefs->RemoveObserver(CMForceSRGBPrefName, gPlatform->overrideObserver);
     
     delete gPlatform;
     gPlatform = nsnull;
 }
 
 gfxPlatform::~gfxPlatform()
 {
     // The cairo folks think we should only clean up in debug builds,
@@ -460,71 +484,90 @@ gfxPlatform::AppendPrefLang(eFontPrefLan
         aPrefLangs[aLen] = aAddLang;
         aLen++;
     }
 }
 
 eCMSMode
 gfxPlatform::GetCMSMode()
 {
-    static eCMSMode sMode = eCMSMode_Off;
-    static PRBool initialized = PR_FALSE;
-
-    if (initialized == PR_FALSE) {
-        initialized = PR_TRUE;
+    if (gCMSInitialized == PR_FALSE) {
+        gCMSInitialized = PR_TRUE;
         nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
         if (prefs) {
             PRInt32 mode;
             nsresult rv =
                 prefs->GetIntPref(CMPrefName, &mode);
             if (NS_SUCCEEDED(rv) && (mode >= 0) && (mode < eCMSMode_AllCount)) {
-                sMode = static_cast<eCMSMode>(mode);
+                gCMSMode = static_cast<eCMSMode>(mode);
             }
         }
     }
-    return sMode;
+    return gCMSMode;
 }
 
 /* Chris Murphy (CM consultant) suggests this as a default in the event that we
 cannot reproduce relative + Black Point Compensation.  BPC brings an
 unacceptable performance overhead, so we go with perceptual. */
 #define INTENT_DEFAULT INTENT_PERCEPTUAL
 
 PRBool
 gfxPlatform::GetRenderingIntent()
 {
-    /* -2 means that we haven't tried querying the pref service yet. */
-    static int sIntent = -2;
-
-    if (sIntent == -2) {
+    if (gCMSIntent == -2) {
 
         /* Try to query the pref system for a rendering intent. */
         nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
         if (prefs) {
             PRInt32 pIntent;
             nsresult rv = prefs->GetIntPref(CMIntentPrefName, &pIntent);
             if (NS_SUCCEEDED(rv)) {
               
                 /* If the pref is within range, use it as an override. */
                 if ((pIntent >= INTENT_MIN) && (pIntent <= INTENT_MAX))
-                    sIntent = pIntent;
+                    gCMSIntent = pIntent;
 
                 /* If the pref is out of range, use embedded profile. */
                 else
-                    sIntent = -1;
+                    gCMSIntent = -1;
             }
         }
 
         /* If we didn't get a valid intent from prefs, use the default. */
-        if (sIntent == -2) 
-            sIntent = INTENT_DEFAULT;
+        if (gCMSIntent == -2) 
+            gCMSIntent = INTENT_DEFAULT;
     }
-    return sIntent;
+    return gCMSIntent;
 }
 
+void 
+gfxPlatform::TransformPixel(const gfxRGBA& in, gfxRGBA& out, cmsHTRANSFORM transform)
+{
+
+    if (transform) {
+#ifdef IS_LITTLE_ENDIAN
+        PRUint32 packed = in.Packed(gfxRGBA::PACKED_ABGR);
+        cmsDoTransform(transform,
+                       (PRUint8 *)&packed, (PRUint8 *)&packed,
+                       1);
+        out.~gfxRGBA();
+        new (&out) gfxRGBA(packed, gfxRGBA::PACKED_ABGR);
+#else
+        PRUint32 packed = in.Packed(gfxRGBA::PACKED_ARGB);
+        cmsDoTransform(transform,
+                       (PRUint8 *)&packed + 1, (PRUint8 *)&packed + 1,
+                       1);
+        out.~gfxRGBA();
+        new (&out) gfxRGBA(packed, gfxRGBA::PACKED_ARGB);
+#endif
+    }
+
+    else if (&out != &in)
+        out = in;
+}
 
 cmsHPROFILE
 gfxPlatform::GetPlatformCMSOutputProfile()
 {
     return nsnull;
 }
 
 cmsHPROFILE
@@ -535,28 +578,41 @@ gfxPlatform::GetCMSOutputProfile()
 #ifdef DEBUG_tor
         cmsErrorAction(LCMS_ERROR_SHOW);
 #else
         cmsErrorAction(LCMS_ERROR_IGNORE);
 #endif
 
         nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
         if (prefs) {
-            nsXPIDLCString fname;
-            nsresult rv =
-                prefs->GetCharPref("gfx.color_management.display_profile",
-                                   getter_Copies(fname));
-            if (NS_SUCCEEDED(rv) && !fname.IsEmpty()) {
-                gCMSOutputProfile = cmsOpenProfileFromFile(fname, "r");
-#ifdef DEBUG_tor
-                if (gCMSOutputProfile)
-                    fprintf(stderr,
-                            "ICM profile read from %s successfully\n",
-                            fname.get());
-#endif
+
+            nsresult rv;
+
+            /* Determine if we're using the internal override to force sRGB as
+               an output profile for reftests. See Bug 452125. */
+            PRBool hasSRGBOverride, doSRGBOverride;
+            rv = prefs->PrefHasUserValue(CMForceSRGBPrefName, &hasSRGBOverride);
+            if (NS_SUCCEEDED(rv) && hasSRGBOverride) {
+                rv = prefs->GetBoolPref(CMForceSRGBPrefName, &doSRGBOverride);
+                if (NS_SUCCEEDED(rv) && doSRGBOverride)
+                    gCMSOutputProfile = GetCMSsRGBProfile();
+            }
+
+            if (!gCMSOutputProfile) {
+
+                nsXPIDLCString fname;
+                rv = prefs->GetCharPref(CMProfilePrefName,
+                                        getter_Copies(fname));
+                if (NS_SUCCEEDED(rv) && !fname.IsEmpty()) {
+                    gCMSOutputProfile = cmsOpenProfileFromFile(fname, "r");
+                    if (gCMSOutputProfile)
+                        fprintf(stderr,
+                                "ICM profile read from %s successfully\n",
+                                fname.get());
+                }
             }
         }
 
         if (!gCMSOutputProfile) {
             gCMSOutputProfile =
                 gfxPlatform::GetPlatform()->GetPlatformCMSOutputProfile();
         }
 
@@ -639,16 +695,51 @@ gfxPlatform::GetCMSRGBATransform()
         gCMSRGBATransform = cmsCreateTransform(inProfile, TYPE_RGBA_8,
                                                outProfile, TYPE_RGBA_8,
                                                INTENT_PERCEPTUAL, cmsFLAGS_FLOATSHAPER);
     }
 
     return gCMSRGBATransform;
 }
 
+/* Shuts down various transforms and profiles for CMS. */
+static void ShutdownCMS()
+{
+
+    if (gCMSRGBTransform) {
+        cmsDeleteTransform(gCMSRGBTransform);
+        gCMSRGBTransform = nsnull;
+    }
+    if (gCMSInverseRGBTransform) {
+        cmsDeleteTransform(gCMSInverseRGBTransform);
+        gCMSInverseRGBTransform = nsnull;
+    }
+    if (gCMSRGBATransform) {
+        cmsDeleteTransform(gCMSRGBATransform);
+        gCMSRGBATransform = nsnull;
+    }
+    if (gCMSOutputProfile) {
+        cmsCloseProfile(gCMSOutputProfile);
+
+        // handle the aliased case
+        if (gCMSsRGBProfile == gCMSOutputProfile)
+            gCMSsRGBProfile = nsnull;
+        gCMSOutputProfile = nsnull;
+    }
+    if (gCMSsRGBProfile) {
+        cmsCloseProfile(gCMSsRGBProfile);
+        gCMSsRGBProfile = nsnull;
+    }
+
+    // Reset the state variables
+    gCMSIntent = -2;
+    gCMSMode = eCMSMode_Off;
+    gCMSInitialized = PR_FALSE;
+}
+
 static void MigratePrefs()
 {
 
     /* Load the pref service. If we don't get it die quietly since this isn't
        critical code. */
     nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
     if (!prefs)
         return;
diff -r b7bcdd009540 intl/uconv/tests/Makefile.in
--- a/intl/uconv/tests/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/intl/uconv/tests/Makefile.in	Thu Sep 11 15:19:25 2008 +0300
@@ -64,26 +64,23 @@ ifeq ($(OS_ARCH),WINNT)
 ifeq ($(OS_ARCH),WINNT)
 CPPSRCS		+= convperf.cpp
 endif
 
 SIMPLE_PROGRAMS	= $(CPPSRCS:.cpp=$(BIN_SUFFIX))
 
 endif # MOZ_ENABLE_LIBXUL
 
-ifdef MOZ_MOCHITEST
 relativesrcdir	= intl/uconv/tests
 
 _TEST_FILES =	\
 		test_bug335816.html \
 		$(NULL)
 libs:: $(_TEST_FILES)
 	$(INSTALL) $(foreach f,$^,"$f") $(DEPTH)/_tests/testing/mochitest/tests/$(relativesrcdir)
-
-endif # MOZ_MOCHITEST
 
 include $(topsrcdir)/config/rules.mk
 
 ifndef MOZ_ENABLE_LIBXUL
 INCLUDES	+= \
 		-I$(srcdir)/../ucvlatin \
 		-I$(srcdir)/../ucvja \
 		-I$(srcdir)/../util \
diff -r b7bcdd009540 js/jsd/jsd_xpc.cpp
--- a/js/jsd/jsd_xpc.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/jsd/jsd_xpc.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -412,41 +412,41 @@ jsds_FilterHook (JSDContext *jsdc, JSDTh
                 (!currentFilter->startLine || 
                  currentFilter->startLine <= currentLine) &&
                 /* and there is no end line, or the end line is after
                  * or equal to the current */
                 (!currentFilter->endLine ||
                  currentFilter->endLine >= currentLine)) {
                 /* then we're going to have to compare the url. */
                 if (currentFilter->patternType == ptIgnore)
-                    return flags & jsdIFilter::FLAG_PASS;
+                    return !!(flags & jsdIFilter::FLAG_PASS);
 
                 if (!len)
                     len = PL_strlen(url);
                 
                 if (len >= currentFilter->patternLength) {
                     switch (currentFilter->patternType) {
                         case ptEquals:
                             if (!PL_strcmp(currentFilter->urlPattern, url))
-                                return flags & jsdIFilter::FLAG_PASS;
+                                return !!(flags & jsdIFilter::FLAG_PASS);
                             break;
                         case ptStartsWith:
                             if (!PL_strncmp(currentFilter->urlPattern, url, 
                                            currentFilter->patternLength))
-                                return flags & jsdIFilter::FLAG_PASS;
+                                return !!(flags & jsdIFilter::FLAG_PASS);
                             break;
                         case ptEndsWith:
                             if (!PL_strcmp(currentFilter->urlPattern,
                                            &url[len - 
                                                currentFilter->patternLength]))
-                                return flags & jsdIFilter::FLAG_PASS;
+                                return !!(flags & jsdIFilter::FLAG_PASS);
                             break;
                         case ptContains:
                             if (PL_strstr(url, currentFilter->urlPattern))
-                                return flags & jsdIFilter::FLAG_PASS;
+                                return !!(flags & jsdIFilter::FLAG_PASS);
                             break;
                         default:
                             NS_ASSERTION(0, "Invalid pattern type");
                     }
                 }                
             }
         }
         currentFilter = reinterpret_cast<FilterRecord *>
diff -r b7bcdd009540 js/src/Makefile.in
--- a/js/src/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/Makefile.in	Thu Sep 11 15:19:25 2008 +0300
@@ -90,18 +90,28 @@ ifeq (64,$(findstring 64,$(OS_TEST)))
 ifeq (64,$(findstring 64,$(OS_TEST)))
 else
 DEFINES += -DAVMPLUS_IA32
 NANOJIT_ARCH = i386
 ENABLE_JIT = 1
 endif
 endif
 
+ifeq (arm,$(findstring arm,$(OS_TEST)))
+DEFINES += -DAVMPLUS_ARM
+NANOJIT_ARCH = ARM
+ENABLE_JIT = 1
+endif
+
+ifneq (,$(filter Linux Darwin SunOS FreeBSD,$(OS_ARCH)))
+DEFINES += -DAVMPLUS_UNIX
+endif
+
 ifeq ($(OS_ARCH),Linux)
-DEFINES += -DAVMPLUS_LINUX -DLINUX
+DEFINES += -DAVMPLUS_LINUX
 endif
 
 ifeq ($(OS_ARCH),WINNT)
 DEFINES += -DAVMPLUS_WIN32
 endif
 
 VPATH		= $(srcdir)
 
@@ -422,16 +432,28 @@ endif
 endif
 
 ifdef MOZ_MEMORY
 ifeq ($(OS_ARCH),Darwin)
 LDFLAGS += -ljemalloc
 endif
 endif
 
+# Sun Studio x86 has an optimization bug with LIR.cpp, use -xO2 instead.
+ifeq ($(OS_ARCH),SunOS)
+ifeq (86,$(findstring 86,$(OS_TEST)))
+ifndef GNU_CC
+LIR.o: LIR.cpp Makefile.in
+	$(REPORT_BUILD)
+	@$(MAKE_DEPS_AUTO_CXX)
+	$(CXX) -o $@ -c $(patsubst -xO%,-xO2,$(COMPILE_CFLAGS)) $<
+endif
+endif
+endif
+
 # Allow building jsinterp.c with special optimization flags
 ifdef INTERP_OPTIMIZER
 jsinterp.$(OBJ_SUFFIX): MODULE_OPTIMIZE_FLAGS=$(INTERP_OPTIMIZER)
 endif
 
 ifeq ($(OS_ARCH),IRIX)
 ifndef GNU_CC
 _COMPILE_CFLAGS  = $(patsubst -O%,-O1,$(COMPILE_CFLAGS))
diff -r b7bcdd009540 js/src/builtins.tbl
--- a/js/src/builtins.tbl	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/builtins.tbl	Thu Sep 11 15:19:25 2008 +0300
@@ -49,16 +49,18 @@ BUILTIN1(DoubleToInt32,         F,      
 BUILTIN1(DoubleToInt32,         F,      LO,     int32,     jsdouble, 1, 1)
 BUILTIN1(DoubleToUint32,        F,      LO,     int32,     jsdouble, 1, 1)
 BUILTIN1(Math_sin,              F,      F,      jsdouble,  jsdouble, 1, 1)
 BUILTIN1(Math_cos,              F,      F,      jsdouble,  jsdouble, 1, 1)
 BUILTIN2(Math_pow,              F,  F,  F,      jsdouble,  jsdouble, jsdouble, 1, 1)
 BUILTIN1(Math_sqrt,             F,      F,      jsdouble,  jsdouble, 1, 1)
 BUILTIN1(Math_floor,            F,      F,      jsdouble,  jsdouble, 1, 1)
 BUILTIN1(Math_ceil,             F,      F,      jsdouble,  jsdouble, 1, 1)
+BUILTIN1(Math_log,              F,      F,      jsdouble,  jsdouble, 1, 1)
+BUILTIN2(Math_max,              F,  F,  F,      jsdouble,  jsdouble, jsdouble, 1, 1)
 BUILTIN4(Array_dense_setelem,   LO, LO, LO, LO, LO, bool,  JSContext*, JSObject*, jsint, jsval, 0, 0)
 BUILTIN3(Array_p_join,          LO, LO, LO, P,  JSString*, JSContext*, JSObject*, JSString*, 0, 0)
 BUILTIN4(String_p_substring,    LO, LO, LO, LO, P,  JSString*, JSContext*, JSString*, jsint, jsint, 1, 1)
 BUILTIN3(String_p_substring_1,  LO, LO, LO, P,  JSString*, JSContext*, JSString*, jsint, 1, 1)
 BUILTIN3(ConcatStrings,         LO, LO, LO, P,  JSString*, JSContext*, JSString*, JSString*, 1, 1)
 BUILTIN3(String_getelem,        LO, LO, LO, P,  JSString*, JSContext*, JSString*, jsint, 1, 1)
 BUILTIN2(String_fromCharCode,   LO, LO, P,      JSString*, JSContext*, jsint, 1, 1)
 BUILTIN2(String_p_charCodeAt,   LO,     LO, LO, jsint,     JSString*, jsint, 1, 1)
@@ -71,16 +73,17 @@ BUILTIN2(toLowerCase,           LO, LO, 
 BUILTIN2(toLowerCase,           LO, LO, P,      JSString*, JSContext*, JSString*, 1, 1) 
 BUILTIN2(toUpperCase,           LO, LO, P,      JSString*, JSContext*, JSString*, 1, 1) 
 BUILTIN1(Math_random,           LO,     F,      jsdouble,  JSRuntime*, 0, 0)
 BUILTIN2(EqualStrings,          LO,     LO, LO, bool,      JSString*, JSString*, 1, 1)
 BUILTIN2(CompareStrings,        LO,     LO, LO, bool,      JSString*, JSString*, 1, 1)
 BUILTIN2(StringToNumber,        LO,     LO, F,  jsdouble,  JSContext*, JSString*, 1, 1)
 BUILTIN2(StringToInt32,         LO,     LO, LO, jsint,     JSContext*, JSString*, 1, 1)
 BUILTIN2(ParseInt,              LO,     LO, F,  jsdouble,  JSContext*, JSString*, 1, 1)
+BUILTIN1(ParseIntDouble,        F,          F,  jsdouble,  jsdouble, 1, 1)
 BUILTIN2(ParseFloat,            LO,     LO, F,  jsdouble,  JSContext*, JSString*, 1, 1)
 BUILTIN3(Any_getelem,           LO, LO, LO, P,  jsval,     JSContext*, JSObject*, JSString*, 0, 0)
 BUILTIN4(Any_setelem,           LO, LO, LO, LO, LO, bool,  JSContext*, JSObject*, JSString*, jsval, 0, 0)
 BUILTIN3(FastValueToIterator,   LO, LO, LO, P,  JSObject*, JSContext*, jsuint, jsval, 0, 0)
 BUILTIN2(FastCallIteratorNext,  LO,     LO, P,  JSObject*, JSContext*, JSObject*, 0, 0)
 BUILTIN2(CloseIterator,         LO,     LO, LO, bool,      JSContext*, jsval, 0, 0)
 BUILTIN2(CallTree,              LO, LO, P,      nanojit::GuardRecord*, avmplus::InterpState*, nanojit::Fragment*, 0, 0)
 BUILTIN2(FastNewArray,          LO,     LO, P,  JSObject*, JSContext*, JSObject*, 0, 0)
@@ -93,25 +96,26 @@ BUILTIN2(NumberToString,        LO,     
 BUILTIN2(NumberToString,        LO,     F,  P,  JSString*, JSContext*, jsdouble, 1, 1)
 BUILTIN3(Object_p_hasOwnProperty,
                                 LO, LO, LO, LO, jsint,     JSContext*, JSObject*, JSString*, 0, 0)
 BUILTIN3(Object_p_propertyIsEnumerable,
                                 LO, LO, LO, LO, jsint,     JSContext*, JSObject*, JSString*, 0, 0)
 BUILTIN2(BooleanToNumber,       LO, LO, F,      jsdouble,  JSContext*, jsint, 1, 1)
 BUILTIN2(ObjectToString,        LO,     LO, P,  JSString*, JSContext*, JSObject*, 0, 0)
 BUILTIN3(Array_1int,            LO, LO, LO, P,  JSObject*, JSContext*, JSObject*, jsint, 0, 0)
+BUILTIN3(Array_1str,            LO, LO, LO, P,  JSObject*, JSContext*, JSObject*, JSString*, 0, 0)
+BUILTIN4(Array_2obj,            LO, LO, LO, LO, P, JSObject*, JSContext*, JSObject*, JSObject*, JSObject**, 0, 0)
+BUILTIN5(Array_3num,            LO, LO, F, F, F, P, JSObject*, JSContext*, JSObject*, jsdouble, jsdouble, jsdouble, 0, 0)
+BUILTIN1(Arguments,             LO,     P,      JSObject*, JSContext*, 0, 0)
 
 // soft float
 BUILTIN1(fneg,   F,       F,  jsdouble, jsdouble, 1, 1)
 BUILTIN1(i2f,    LO,      F,  jsdouble, jsint,    1, 1)
 BUILTIN1(u2f,    LO,      F,  jsdouble, jsuint,   1, 1)
 BUILTIN2(fcmpeq, F,   F,  LO, jsint,    jsdouble, jsdouble, 1, 1)
 BUILTIN2(fcmplt, F,   F,  LO, jsint,    jsdouble, jsdouble, 1, 1)
 BUILTIN2(fcmple, F,   F,  LO, jsint,    jsdouble, jsdouble, 1, 1)
 BUILTIN2(fcmpgt, F,   F,  LO, jsint,    jsdouble, jsdouble, 1, 1)
 BUILTIN2(fcmpge, F,   F,  LO, jsint,    jsdouble, jsdouble, 1, 1)
 BUILTIN2(fmul,   F,   F,  F,  jsdouble, jsdouble, jsdouble, 1, 1)
 BUILTIN2(fadd,   F,   F,  F,  jsdouble, jsdouble, jsdouble, 1, 1)
 BUILTIN2(fdiv,   F,   F,  F,  jsdouble, jsdouble, jsdouble, 1, 1)
 BUILTIN2(fsub,   F,   F,  F,  jsdouble, jsdouble, jsdouble, 1, 1)
-BUILTIN3(Array_1str,            LO, LO, LO, P,  JSObject*, JSContext*, JSObject*, JSString*, 0, 0)
-BUILTIN4(Array_2obj,            LO, LO, LO, LO, P, JSObject*, JSContext*, JSObject*, JSObject*, JSObject**, 0, 0)
-BUILTIN5(Array_3num,            LO, LO, F, F, F, P, JSObject*, JSContext*, JSObject*, jsdouble, jsdouble, jsdouble, 0, 0)
diff -r b7bcdd009540 js/src/config/Darwin.mk
--- a/js/src/config/Darwin.mk	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/config/Darwin.mk	Thu Sep 11 15:19:25 2008 +0300
@@ -55,17 +55,17 @@ SO_SUFFIX = dylib
 
 #.c.o:
 #      $(CC) -c -MD $*.d $(CFLAGS) $<
 
 CPU_ARCH = $(shell uname -m)
 ifeq (86,$(findstring 86,$(CPU_ARCH)))
 CPU_ARCH = x86
 OS_CFLAGS+= -DX86_LINUX
-OS_CFLAGS += -DAVMPLUS_IA32
+OS_CFLAGS += -DAVMPLUS_IA32 -DAVMPLUS_UNIX
 NANOJIT_ARCH = i386
 endif
 GFX_ARCH = x
 
 OS_LIBS = -lc -framework System
 
 ASFLAGS += -x assembler-with-cpp
 
diff -r b7bcdd009540 js/src/config/Linux_All.mk
--- a/js/src/config/Linux_All.mk	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/config/Linux_All.mk	Thu Sep 11 15:19:25 2008 +0300
@@ -52,39 +52,39 @@ MKSHLIB = $(LD) -shared $(XMKSHLIBOPTS)
 #.c.o:
 #      $(CC) -c -MD $*.d $(CFLAGS) $<
 
 CPU_ARCH = $(shell uname -m)
 # don't filter in x86-64 architecture
 ifneq (x86_64,$(CPU_ARCH))
 ifeq (86,$(findstring 86,$(CPU_ARCH)))
 CPU_ARCH = x86
-OS_CFLAGS += -DX86_LINUX -DAVMPLUS_IA32 -DAVMPLUS_LINUX
+OS_CFLAGS += -DX86_LINUX -DAVMPLUS_IA32 -DAVMPLUS_UNIX -DAVMPLUS_LINUX
 NANOJIT_ARCH = i386
 
 ifeq (gcc, $(CC))
 # if using gcc on x86, check version for opt bug 
 # (http://bugzilla.mozilla.org/show_bug.cgi?id=24892)
 GCC_VERSION := $(shell gcc -v 2>&1 | grep version | awk '{ print $$3 }')
 GCC_LIST:=$(sort 2.91.66 $(GCC_VERSION) )
 
 ifeq (2.91.66, $(firstword $(GCC_LIST)))
 CFLAGS+= -DGCC_OPT_BUG
 endif # gcc 2.91.66
 endif # gcc
 endif # 86
 endif # !x86_64
 
 ifeq ($(CPU_ARCH),x86_64)
-OS_CFLAGS += -DAVMPLUS_AMD64 -DAVMPLUS_64BIT -DAVMPLUS_LINUX
+OS_CFLAGS += -DAVMPLUS_AMD64 -DAVMPLUS_64BIT -DAVMPLUS_UNIX -DAVMPLUS_LINUX
 NANOJIT_ARCH = i386
 endif
 
 ifeq ($(CPU_ARCH),arm)
-OS_CFLAGS += -DAVMPLUS_ARM -DAVMPLUS_LINUX
+OS_CFLAGS += -DAVMPLUS_ARM -DAVMPLUS_UNIX -DAVMPLUS_LINUX
 NANOJIT_ARCH = ARM
 endif
 
 GFX_ARCH = x
 
 OS_LIBS = -lm -lc
 
 ASFLAGS += -x assembler-with-cpp
diff -r b7bcdd009540 js/src/correct.sh
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/correct.sh	Thu Sep 11 15:19:25 2008 +0300
@@ -0,0 +1,23 @@
+#!/bin/bash
+FAILURES="FAILED"
+for i in correct/*.js; do 
+    echo $i;
+    echo -n interp:' '
+    INTERP=`Darwin_OPT.OBJ/js -f $i`
+    echo $INTERP' '
+    echo -n jit:' '
+    JIT=`Darwin_OPT.OBJ/js -j -f $i`
+    echo $JIT' '
+    if [ $INTERP != "true" -o $JIT != "true" ]
+    then
+        FAILURES=${FAILURES}" "${i}
+    fi
+done
+
+echo
+if [[ "FAILED" != "${FAILURES}" ]]
+then
+    echo ${FAILURES}
+else
+    echo "PASSED"
+fi
\ No newline at end of file
diff -r b7bcdd009540 js/src/correct/check-3d-morph.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/correct/check-3d-morph.js	Thu Sep 11 15:19:25 2008 +0300
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2007 Apple Inc.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
+ */
+
+var loops = 15
+var nx = 120
+var nz = 120
+
+function morph(a, f) {
+    var PI2nx = Math.PI * 8/nx
+    var sin = Math.sin
+    var f30 = -(50 * sin(f*Math.PI*2))
+    
+    for (var i = 0; i < nz; ++i) {
+        for (var j = 0; j < nx; ++j) {
+            a[3*(i*nx+j)+1]    = sin((j-1) * PI2nx ) * -f30
+        }
+    }
+}
+
+    
+var a = Array()
+for (var i=0; i < nx*nz*3; ++i) 
+    a[i] = 0
+
+for (var i = 0; i < loops; ++i) {
+    morph(a, i/loops)
+}
+
+testOutput = 0;
+for (var i = 0; i < nx; i++)
+    testOutput += a[3*(i*nx+i)+1];
+a = null;
+print(testOutput == 6.394884621840902e-14)
diff -r b7bcdd009540 js/src/correct/check-3d-raytrace.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/correct/check-3d-raytrace.js	Thu Sep 11 15:19:25 2008 +0300
@@ -0,0 +1,445 @@
+/*
+ * Copyright (C) 2007 Apple Inc.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
+ */
+
+function createVector(x,y,z) {
+    return new Array(x,y,z);
+}
+
+function sqrLengthVector(self) {
+    return self[0] * self[0] + self[1] * self[1] + self[2] * self[2];
+}
+
+function lengthVector(self) {
+    return Math.sqrt(self[0] * self[0] + self[1] * self[1] + self[2] * self[2]);
+}
+
+function addVector(self, v) {
+    self[0] += v[0];
+    self[1] += v[1];
+    self[2] += v[2];
+    return self;
+}
+
+function subVector(self, v) {
+    self[0] -= v[0];
+    self[1] -= v[1];
+    self[2] -= v[2];
+    return self;
+}
+
+function scaleVector(self, scale) {
+    self[0] *= scale;
+    self[1] *= scale;
+    self[2] *= scale;
+    return self;
+}
+
+function normaliseVector(self) {
+    var len = Math.sqrt(self[0] * self[0] + self[1] * self[1] + self[2] * self[2]);
+    self[0] /= len;
+    self[1] /= len;
+    self[2] /= len;
+    return self;
+}
+
+function add(v1, v2) {
+    return new Array(v1[0] + v2[0], v1[1] + v2[1], v1[2] + v2[2]);
+}
+
+function sub(v1, v2) {
+    return new Array(v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2]);
+}
+
+function scalev(v1, v2) {
+    return new Array(v1[0] * v2[0], v1[1] * v2[1], v1[2] * v2[2]);
+}
+
+function dot(v1, v2) {
+    return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
+}
+
+function scale(v, scale) {
+    return [v[0] * scale, v[1] * scale, v[2] * scale];
+}
+
+function cross(v1, v2) {
+    return [v1[1] * v2[2] - v1[2] * v2[1], 
+            v1[2] * v2[0] - v1[0] * v2[2],
+            v1[0] * v2[1] - v1[1] * v2[0]];
+
+}
+
+function normalise(v) {
+    var len = lengthVector(v);
+    return [v[0] / len, v[1] / len, v[2] / len];
+}
+
+function transformMatrix(self, v) {
+    var vals = self;
+    var x  = vals[0] * v[0] + vals[1] * v[1] + vals[2] * v[2] + vals[3];
+    var y  = vals[4] * v[0] + vals[5] * v[1] + vals[6] * v[2] + vals[7];
+    var z  = vals[8] * v[0] + vals[9] * v[1] + vals[10] * v[2] + vals[11];
+    return [x, y, z];
+}
+
+function invertMatrix(self) {
+    var temp = new Array(16);
+    var tx = -self[3];
+    var ty = -self[7];
+    var tz = -self[11];
+    for (h = 0; h < 3; h++) 
+        for (v = 0; v < 3; v++) 
+            temp[h + v * 4] = self[v + h * 4];
+    for (i = 0; i < 11; i++)
+        self[i] = temp[i];
+    self[3] = tx * self[0] + ty * self[1] + tz * self[2];
+    self[7] = tx * self[4] + ty * self[5] + tz * self[6];
+    self[11] = tx * self[8] + ty * self[9] + tz * self[10];
+    return self;
+}
+
+
+// Triangle intersection using barycentric coord method
+function Triangle(p1, p2, p3) {
+    var edge1 = sub(p3, p1);
+    var edge2 = sub(p2, p1);
+    var normal = cross(edge1, edge2);
+    if (Math.abs(normal[0]) > Math.abs(normal[1]))
+        if (Math.abs(normal[0]) > Math.abs(normal[2]))
+            this.axis = 0; 
+        else 
+            this.axis = 2;
+    else
+        if (Math.abs(normal[1]) > Math.abs(normal[2])) 
+            this.axis = 1;
+        else 
+            this.axis = 2;
+    var u = (this.axis + 1) % 3;
+    var v = (this.axis + 2) % 3;
+    var u1 = edge1[u];
+    var v1 = edge1[v];
+    
+    var u2 = edge2[u];
+    var v2 = edge2[v];
+    this.normal = normalise(normal);
+    this.nu = normal[u] / normal[this.axis];
+    this.nv = normal[v] / normal[this.axis];
+    this.nd = dot(normal, p1) / normal[this.axis];
+    var det = u1 * v2 - v1 * u2;
+    this.eu = p1[u];
+    this.ev = p1[v]; 
+    this.nu1 = u1 / det;
+    this.nv1 = -v1 / det;
+    this.nu2 = v2 / det;
+    this.nv2 = -u2 / det; 
+    this.material = [0.7, 0.7, 0.7];
+}
+
+Triangle.prototype.intersect = function(orig, dir, near, far) {
+    var u = (this.axis + 1) % 3;
+    var v = (this.axis + 2) % 3;
+    var d = dir[this.axis] + this.nu * dir[u] + this.nv * dir[v];
+    var t = (this.nd - orig[this.axis] - this.nu * orig[u] - this.nv * orig[v]) / d;
+    if (t < near || t > far)
+        return null;
+    var Pu = orig[u] + t * dir[u] - this.eu;
+    var Pv = orig[v] + t * dir[v] - this.ev;
+    var a2 = Pv * this.nu1 + Pu * this.nv1;
+    if (a2 < 0) 
+        return null;
+    var a3 = Pu * this.nu2 + Pv * this.nv2;
+    if (a3 < 0) 
+        return null;
+
+    if ((a2 + a3) > 1) 
+        return null;
+    return t;
+}
+
+function Scene(a_triangles) {
+    this.triangles = a_triangles;
+    this.lights = [];
+    this.ambient = [0,0,0];
+    this.background = [0.8,0.8,1];
+}
+var zero = new Array(0,0,0);
+
+Scene.prototype.intersect = function(origin, dir, near, far) {
+    var closest = null;
+    for (i = 0; i < this.triangles.length; i++) {
+        var triangle = this.triangles[i];   
+        var d = triangle.intersect(origin, dir, near, far);
+        if (d == null || d > far || d < near)
+            continue;
+        far = d;
+        closest = triangle;
+    }
+    
+    if (!closest)
+        return [this.background[0],this.background[1],this.background[2]];
+        
+    var normal = closest.normal;
+    var hit = add(origin, scale(dir, far)); 
+    if (dot(dir, normal) > 0)
+        normal = [-normal[0], -normal[1], -normal[2]];
+    
+    var colour = null;
+    if (closest.shader) {
+        colour = closest.shader(closest, hit, dir);
+    } else {
+        colour = closest.material;
+    }
+    
+    // do reflection
+    var reflected = null;
+    if (colour.reflection > 0.001) {
+        var reflection = addVector(scale(normal, -2*dot(dir, normal)), dir);
+        reflected = this.intersect(hit, reflection, 0.0001, 1000000);
+        if (colour.reflection >= 0.999999)
+            return reflected;
+    }
+    
+    var l = [this.ambient[0], this.ambient[1], this.ambient[2]];
+    for (var i = 0; i < this.lights.length; i++) {
+        var light = this.lights[i];
+        var toLight = sub(light, hit);
+        var distance = lengthVector(toLight);
+        scaleVector(toLight, 1.0/distance);
+        distance -= 0.0001;
+        if (this.blocked(hit, toLight, distance))
+            continue;
+        var nl = dot(normal, toLight);
+        if (nl > 0)
+            addVector(l, scale(light.colour, nl));
+    }
+    l = scalev(l, colour);
+    if (reflected) {
+        l = addVector(scaleVector(l, 1 - colour.reflection), scaleVector(reflected, colour.reflection));
+    }
+    return l;
+}
+
+Scene.prototype.blocked = function(O, D, far) {
+    var near = 0.0001;
+    var closest = null;
+    for (i = 0; i < this.triangles.length; i++) {
+        var triangle = this.triangles[i];   
+        var d = triangle.intersect(O, D, near, far);
+        if (d == null || d > far || d < near)
+            continue;
+        return true;
+    }
+    
+    return false;
+}
+
+
+// this camera code is from notes i made ages ago, it is from *somewhere* -- i cannot remember where
+// that somewhere is
+function Camera(origin, lookat, up) {
+    var zaxis = normaliseVector(subVector(lookat, origin));
+    var xaxis = normaliseVector(cross(up, zaxis));
+    var yaxis = normaliseVector(cross(xaxis, subVector([0,0,0], zaxis)));
+    var m = new Array(16);
+    m[0] = xaxis[0]; m[1] = xaxis[1]; m[2] = xaxis[2];
+    m[4] = yaxis[0]; m[5] = yaxis[1]; m[6] = yaxis[2];
+    m[8] = zaxis[0]; m[9] = zaxis[1]; m[10] = zaxis[2];
+    invertMatrix(m);
+    m[3] = 0; m[7] = 0; m[11] = 0;
+    this.origin = origin;
+    this.directions = new Array(4);
+    this.directions[0] = normalise([-0.7,  0.7, 1]);
+    this.directions[1] = normalise([ 0.7,  0.7, 1]);
+    this.directions[2] = normalise([ 0.7, -0.7, 1]);
+    this.directions[3] = normalise([-0.7, -0.7, 1]);
+    this.directions[0] = transformMatrix(m, this.directions[0]);
+    this.directions[1] = transformMatrix(m, this.directions[1]);
+    this.directions[2] = transformMatrix(m, this.directions[2]);
+    this.directions[3] = transformMatrix(m, this.directions[3]);
+}
+
+Camera.prototype.generateRayPair = function(y) {
+    rays = new Array(new Object(), new Object());
+    rays[0].origin = this.origin;
+    rays[1].origin = this.origin;
+    rays[0].dir = addVector(scale(this.directions[0], y), scale(this.directions[3], 1 - y));
+    rays[1].dir = addVector(scale(this.directions[1], y), scale(this.directions[2], 1 - y));
+    return rays;
+}
+
+function renderRows(camera, scene, pixels, width, height, starty, stopy) {
+    for (var y = starty; y < stopy; y++) {
+        var rays = camera.generateRayPair(y / height);
+        for (var x = 0; x < width; x++) {
+            var xp = x / width;
+            var origin = addVector(scale(rays[0].origin, xp), scale(rays[1].origin, 1 - xp));
+            var dir = normaliseVector(addVector(scale(rays[0].dir, xp), scale(rays[1].dir, 1 - xp)));
+            var l = scene.intersect(origin, dir);
+            pixels[y][x] = l;
+        }
+    }
+}
+
+Camera.prototype.render = function(scene, pixels, width, height) {
+    var cam = this;
+    var row = 0;
+    renderRows(cam, scene, pixels, width, height, 0, height);
+}
+
+
+
+function raytraceScene()
+{
+    var startDate = new Date().getTime();
+    var numTriangles = 2 * 6;
+    var triangles = new Array();//numTriangles);
+    var tfl = createVector(-10,  10, -10);
+    var tfr = createVector( 10,  10, -10);
+    var tbl = createVector(-10,  10,  10);
+    var tbr = createVector( 10,  10,  10);
+    var bfl = createVector(-10, -10, -10);
+    var bfr = createVector( 10, -10, -10);
+    var bbl = createVector(-10, -10,  10);
+    var bbr = createVector( 10, -10,  10);
+    
+    // cube!!!
+    // front
+    var i = 0;
+    
+    triangles[i++] = new Triangle(tfl, tfr, bfr);
+    triangles[i++] = new Triangle(tfl, bfr, bfl);
+    // back
+    triangles[i++] = new Triangle(tbl, tbr, bbr);
+    triangles[i++] = new Triangle(tbl, bbr, bbl);
+    //        triangles[i-1].material = [0.7,0.2,0.2];
+    //            triangles[i-1].material.reflection = 0.8;
+    // left
+    triangles[i++] = new Triangle(tbl, tfl, bbl);
+    //            triangles[i-1].reflection = 0.6;
+    triangles[i++] = new Triangle(tfl, bfl, bbl);
+    //            triangles[i-1].reflection = 0.6;
+    // right
+    triangles[i++] = new Triangle(tbr, tfr, bbr);
+    triangles[i++] = new Triangle(tfr, bfr, bbr);
+    // top
+    triangles[i++] = new Triangle(tbl, tbr, tfr);
+    triangles[i++] = new Triangle(tbl, tfr, tfl);
+    // bottom
+    triangles[i++] = new Triangle(bbl, bbr, bfr);
+    triangles[i++] = new Triangle(bbl, bfr, bfl);
+    
+    //Floor!!!!
+    var green = createVector(0.0, 0.4, 0.0);
+    var grey = createVector(0.4, 0.4, 0.4);
+    grey.reflection = 1.0;
+    var floorShader = function(tri, pos, view) {
+        var x = ((pos[0]/32) % 2 + 2) % 2;
+        var z = ((pos[2]/32 + 0.3) % 2 + 2) % 2;
+        if (x < 1 != z < 1) {
+            //in the real world we use the fresnel term...
+            //    var angle = 1-dot(view, tri.normal);
+            //   angle *= angle;
+            //  angle *= angle;
+            // angle *= angle;
+            //grey.reflection = angle;
+            return grey;
+        } else 
+            return green;
+    }
+    var ffl = createVector(-1000, -30, -1000);
+    var ffr = createVector( 1000, -30, -1000);
+    var fbl = createVector(-1000, -30,  1000);
+    var fbr = createVector( 1000, -30,  1000);
+    triangles[i++] = new Triangle(fbl, fbr, ffr);
+    triangles[i-1].shader = floorShader;
+    triangles[i++] = new Triangle(fbl, ffr, ffl);
+    triangles[i-1].shader = floorShader;
+    
+    var _scene = new Scene(triangles);
+    _scene.lights[0] = createVector(20, 38, -22);
+    _scene.lights[0].colour = createVector(0.7, 0.3, 0.3);
+    _scene.lights[1] = createVector(-23, 40, 17);
+    _scene.lights[1].colour = createVector(0.7, 0.3, 0.3);
+    _scene.lights[2] = createVector(23, 20, 17);
+    _scene.lights[2].colour = createVector(0.7, 0.7, 0.7);
+    _scene.ambient = createVector(0.1, 0.1, 0.1);
+    //  _scene.background = createVector(0.7, 0.7, 1.0);
+    
+    var size = 30;
+    var pixels = new Array();
+    for (var y = 0; y < size; y++) {
+        pixels[y] = new Array();
+        for (var x = 0; x < size; x++) {
+            pixels[y][x] = 0;
+        }
+    }
+
+    var _camera = new Camera(createVector(-40, 40, 40), createVector(0, 0, 0), createVector(0, 1, 0));
+    _camera.render(_scene, pixels, size, size);
+
+    return pixels;
+}
+
+function arrayToCanvasCommands(pixels)
+{
+    var s = '<canvas id="renderCanvas" width="30px" height="30px"></canvas><scr' + 'ipt>\nvar pixels = [';
+    var size = 30;
+    for (var y = 0; y < size; y++) {
+        s += "[";
+        for (var x = 0; x < size; x++) {
+            s += "[" + pixels[y][x] + "],";
+        }
+        s+= "],";
+    }
+    s += '];\n    var canvas = document.getElementById("renderCanvas").getContext("2d");\n\
+\n\
+\n\
+    var size = 30;\n\
+    canvas.fillStyle = "red";\n\
+    canvas.fillRect(0, 0, size, size);\n\
+    canvas.scale(1, -1);\n\
+    canvas.translate(0, -size);\n\
+\n\
+    if (!canvas.setFillColor)\n\
+        canvas.setFillColor = function(r, g, b, a) {\n\
+            this.fillStyle = "rgb("+[Math.floor(r * 255), Math.floor(g * 255), Math.floor(b * 255)]+")";\n\
+    }\n\
+\n\
+for (var y = 0; y < size; y++) {\n\
+  for (var x = 0; x < size; x++) {\n\
+    var l = pixels[y][x];\n\
+    canvas.setFillColor(l[0], l[1], l[2], 1);\n\
+    canvas.fillRect(x, y, 1, 1);\n\
+  }\n\
+}</scr' + 'ipt>';
+
+    return s;
+}
+
+testOutput = arrayToCanvasCommands(raytraceScene());
+expected = '<canvas id="renderCanvas" width="30px" height="30px"></canvas><script>\nvar pixels = [[[0,0.22646733835486615,0],[0,0.22917348499592718,0],[0,0.23178836719862694,0],[0,0.23429286876882874,0],[0,0.23666708243914814,0],[0,0.2388906159889881,0],[0,0.3260187640505792,0],[0,0.33121005205394954,0],[0,0.3363076586511704,0],[0,0.3412818000213254,0],[0,0.34610095331648705,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.369829536245317,0],[0,0.3725822614817006,0],[0,0.37489560357280544,0],[0,0.37673658797290227,0],[0,0.3780753374916205,0],[0,0.378886188721004,0],[0,0.3791488586269958,0],[0,0.3788495731470844,0],[0,0.3779820527845238,0],[0,0.37654824729910663,0],[0,0.4585834760044105,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],],[[0.8,0.8,1],[0,0.22925665044954321,0],[0,0.2320573979410493,0],[0,0.23474822091583247,0],[0,0.2373069549209832,0],[0,0.2397107002896524,0],[0,0.15436982463108695,0],[0,0.15568628300351414,0],[0,0.33780762567168454,0],[0,0.3431766295062631,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.24744701364085558,0.14604872013179526,0.14604872013179526],[0,0.3743786742105677,0],[0,0.37742123153478285,0],[0,0.3799794006700716,0],[0,0.38201209682126785,0],[0,0.38348180518082586,0],[0,0.384356168843629,0],[0,0.3846096564538848,0],[0,0.3842251672467923,0],[0,0.3831954061706588,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],],[[0.8,0.8,1],[0.8,0.8,1],[0,0.23215413887706876,0],[0,0.2350440502458203,0],[0,0.23780113739316563,0],[0,0.24039973450409946,0],[0,0.24281359296637,0],[0,0.15528082901621987,0],[0,0.15653052853852803,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.24335890550700673,0.1442966737887172,0.1442966737887172],[0.21191595684264103,0.13082112436113186,0.13082112436113186],[0.27664813175852776,0.2248217713585563,0.2248217713585563],[0,0.3823836235518836,0],[0,0.3852234408034573,0],[0,0.38747642030616,0],[0,0.3890951276817348,0],[0,0.39003853152190077,0],[0,0.39027440447223904,0],[0,0.3897816153712006,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],],[[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.23811367607569112,0],[0,0.240922314629212,0],[0,0.2435404294800615,0],[0,0.24593811382698388,0],[0,0.1559883317159253,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.233189785862315,0.13993847965527784,0.13993847965527784],[0.2095470195339134,0.1298058655145343,0.1298058655145343],[0.06999999999999999,0.06999999999999999,0.06999999999999999],[0.2414541261336147,0.19927150247084813,0.19927150247084813],[0.30463716829842996,0.25698429422662805,0.25698429422662805],[0,0.39057010876231657,0],[0,0.39307456071571556,0],[0,0.394860705064173,0],[0,0.3958762994996104,0],[0,0.3960806578453934,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],],[[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.24123643784061885,0],[0,0.24407545031211067,0],[0,0.24668523203085055,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.20428988349740462,0.1275528072131734,0.1275528072131734],[0.06999999999999999,0.06999999999999999,0.06999999999999999],[0.06999999999999999,0.06999999999999999,0.06999999999999999],[0.06999999999999999,0.06999999999999999,0.06999999999999999],[0.2553534506258493,0.21540752629099336,0.21540752629099336],[0.8,0.8,1],[0,0.39871352471166227,0],[0,0.40068391900131317,0],[0,0.4017699848209471,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],],[[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.06999999999999999,0.06999999999999999,0.06999999999999999],[0.06999999999999999,0.06999999999999999,0.06999999999999999],[0.06999999999999999,0.06999999999999999,0.06999999999999999],[0.06999999999999999,0.06999999999999999,0.06999999999999999],[0.06999999999999999,0.06999999999999999,0.06999999999999999],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],],[[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.24436322334505386,0],[0,0.24745253188899904,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.06999999999999999,0.06999999999999999,0.06999999999999999],[0.06999999999999999,0.06999999999999999,0.06999999999999999],[0.06999999999999999,0.06999999999999999,0.06999999999999999],[0.06999999999999999,0.06999999999999999,0.06999999999999999],[0.06999999999999999,0.06999999999999999,0.06999999999999999],[0.06999999999999999,0.06999999999999999,0.06999999999999999],[0.06999999999999999,0.06999999999999999,0.06999999999999999],[0,0.40943101981787544,0],[0,0.41179341435345673,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],],[[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.24398601063610253,0],[0,0.24734388131046534,0],[0,0.2504039497369661,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.06999999999999999,0.06999999999999999,0.06999999999999999],[0.06999999999999999,0.06999999999999999,0.06999999999999999],[0.06999999999999999,0.06999999999999999,0.06999999999999999],[0.8,0.8,1],[0,0.41015054936419404,0],[0,0.4139256751539831,0],[0,0.5176011801301246,0],[0,0.5175400296826781,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],],[[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.23925831942915582,0],[0,0.2431514340750372,0],[0,0.24679679895694717,0],[0,0.25013656179204347,0],[0,0.25311244537612027,0],[0,0.2556680399787405,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.06999999999999999,0.06999999999999999,0.06999999999999999],[0.8,0.8,1],[0,0.4078259849771481,0],[0,0.4131357292874544,0],[0,0.5218814714518779,0],[0,0.5233124012306586,0],[0,0.522962771547786,0],[0,0.5207522057325761,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.47311372545546515,0],[0,0.4614041416827006,0],],[[0,0.21490764011046362,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.2331842261176049,0],[0,0.23755980367223836,0],[0,0.24175353358196602,0],[0,0.24570333061205787,0],[0,0.24934343472275186,0],[0,0.252606535195386,0],[0,0.25542647135913205,0],[0,0.25774138056580276,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.04000000000000001,0],[0,0.2913399551219817,0],[0,0.40821549181429595,0],[0,0.5226526471916983,0],[0,0.5257809891986108,0],[0,0.5270304637173788,0],[0,0.5262436797403963,0],[0,0.5233412343635394,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.48095949311801045,0],[0,0.46869626187306984,0],[0,0.4558873544509206,0],],[[0,0.21129537920439745,0],[0,0.2160838834157171,0],[0,0.22090682198375836,0],[0.8,0.8,1],[0,0.23049540839949767,0],[0,0.23516114626695328,0],[0,0.23966144813312718,0],[0,0.24392754707957162,0],[0,0.24788516106908107,0],[0,0.25145680804980497,0],[0,0.2545649373510444,0],[0,0.2571357591990073,0],[0,0.2591035093142245,0],[0,0.15255606913369724,0],[0,0.15301134862115395,0],[0.19736821241316202,0.12458637674849803,0.12458637674849803],[0,0.40504494009802183,0],[0,0.4123372862951718,0],[0,0.4183003766375901,0],[0,0.5268338036458257,0],[0,0.5277169309488912,0],[0,0.5263102439245335,0],[0,0.5225497158196737,0],[0,0.5164937589802646,0],[0.8,0.8,1],[0,0.49832248210805585,0],[0,0.4868414893043067,0],[0,0.47425805574715646,0],[0,0.46093994347307254,0],[0,0.4472184699099014,0],],[[0,0.20695133260602822,0],[0,0.21189973891969208,0],[0,0.21691233850171843,0],[0.8,0.8,1],[0.8,0.8,1],[0,0.23191357418198488,0],[0,0.23671451069678634,0],[0,0.24129830018648707,0],[0,0.24558190818576656,0],[0,0.24947677854650704,0],[0,0.2528923625850763,0],[0,0.1528305739035691,0],[0,0.1542326299051252,0],[0.8,0.8,1],[0.19785925315493239,0.12479682278068532,0.12479682278068532],[0.2081375194488818,0.12920179404952076,0.12920179404952076],[0.2240887656214228,0.18514359742568504,0.18514359742568504],[0,0.4135020430625767,0],[0,0.4192949763868133,0],[0,0.42324582463394744,0],[0,0.524175088930771,0],[0,0.5219574826556216,0],[0,0.5172050501700545,0],[0.8,0.8,1],[0.8,0.8,1],[0,0.4895533585416516,0],[0,0.4770140400123619,0],[0,0.4635030619052592,0],[0,0.44941365075166806,0],[0,0.43508467272477774,0],],[[0,0.20179362237895174,0],[0,0.20685458951965674,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.23760464753632676,0],[0,0.24220528986272394,0],[0,0.2464227921634767,0],[0,0.2501524694953926,0],[0,0.15461153696054686,0],[0.18550977568907606,0.11950418958103261,0.11950418958103261],[0.1973204644052136,0.12456591331652012,0.12456591331652012],[0.2088287796802108,0.12949804843437607,0.12949804843437607],[0.21976471724250635,0.134184878818217,0.134184878818217],[0.23568458491329167,0.19345433251780333,0.19345433251780333],[0.23236149715622312,0.19397984285078584,0.19397984285078584],[0.22707008733584053,0.19247800386744748,0.19247800386744748],[0,0.41921793505330557,0],[0,0.42018199893505187,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.4624620672233052,0],[0,0.4484080186022647,0],[0,0.43394937018864516,0],[0,0.4194117002954933,0],],[[0,0.195751560483372,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.4179362030887152,0],[0.8,0.8,1],[0.18284994643317204,0.11836426275707375,0.11836426275707375],[0.19559717882822145,0.12382736235495205,0.12382736235495205],[0.20829587479733996,0.1292696606274314,0.1292696606274314],[0.22064479825066774,0.13456205639314334,0.13456205639314334],[0.2323223325492669,0.13956671394968584,0.13956671394968584],[0.24724443467900797,0.20148878770701636,0.20148878770701636],[0.24548491352821342,0.20390487818440434,0.20390487818440434],[0.24239083545814452,0.20490715724849212,0.20490715724849212],[0.23580267356471662,0.2022853173521094,0.2022853173521094],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.42907468966717865,0],[0,0.4147140942539032,0],[0.8,0.8,1],],[[0.8,0.8,1],[0,0.19385093619429258,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.40369350610660937,0],[0,0.4158360873491173,0],[0.19261301561109398,0.12254843526189743,0.12254843526189743],[0.20636000368544563,0.1284400015794767,0.1284400015794767],[0.22006309132254379,0.13431275342394736,0.13431275342394736],[0.23336548922639505,0.14001378109702645,0.14001378109702645],[0.24588206119264946,0.1453780262254212,0.1453780262254212],[0.2585904923823373,0.20905557193769056,0.20905557193769056],[0.2583880059856603,0.21340384806404408,0.21340384806404408],[0.2579257731612357,0.21738553706566144,0.21738553706566144],[0.25469196497831764,0.21843261169087974,0.21843261169087974],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.4196956387047621,0],[0,0.40600233966188104,0],[0.8,0.8,1],[0.8,0.8,1],],[[0,0.18086678377768206,0],[0,0.29820732165845826,0],[0,0.3078671511008362,0],[0,0.31797632104786633,0],[0,0.3285185113204014,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.3740646417282967,0],[0,0.38583856211873363,0],[0,0.39747405235976174,0],[0.2029477686069114,0.12697761511724776,0.12697761511724776],[0.21781735307317274,0.1333502941742169,0.1333502941742169],[0.2326566051026994,0.13970997361544257,0.13970997361544257],[0.2470420370437997,0.145875158733057,0.145875158733057],[0.9125534455486627,0.5106731929990184,0.5106731929990184],[0.26957187383368114,0.21599310805975738,0.21599310805975738],[0.2707166126603939,0.2221190287629908,0.2221190287629908],[0.2730659500911373,0.22930539474084957,0.22930539474084957],[0.27432898752113144,0.23520013372187343,0.23520013372187343],[0,0.370913970040732,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.41728826192115065,0],[0,0.4053708259838642,0],[0,0.39282677897301016,0],[0,0.37998757881530154,0],[0,0.3671261088322657,0],[0.8,0.8,1],],[[0,0.2734507658091365,0],[0,0.28211354268150884,0],[0,0.29120495530846624,0],[0,0.3007197072254542,0],[0,0.31064069882287787,0],[0,0.32093517914620384,0],[0,0.3315502317284035,0],[0,0.34240777559380986,0],[0,0.35339949423457706,0],[0,0.3643824114196257,0],[0,0.3751761555363945,0],[0.21384735597314658,0.13164886684563426,0.13164886684563426],[0.2299739346154931,0.1385602576923542,0.1385602576923542],[0.24609657496992726,0.1454699607013974,0.1454699607013974],[0.9085781768104235,0.508698320758555,0.508698320758555],[0.9154549906081679,0.5170357163338555,0.5170357163338555],[0.9205088622142807,0.5252164494222175,0.5252164494222175],[0.28215745535360465,0.22973861951523428,0.22973861951523428],[0.2871003088909314,0.23996159648606105,0.23996159648606105],[0.29363706106359355,0.2515193872815144,0.2515193872815144],[0,0.41902122210815307,0],[0,0.41310298499553366,0],[0,0.40544274823125576,0],[0,0.396335311262737,0],[0,0.3861118369914827,0],[0,0.37510764377615097,0],[0,0.3636351145776063,0],[0,0.35196551120236436,0],[0,0.3403202703614798,0],[0,0.32887008288221503,0],],[[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.28175542273932297,0],[0,0.29085225965171946,0],[0,0.3002718747152153,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.3493460616221397,0],[0.22528651843925174,0.1365513650453936,0.1365513650453936],[0.884020287542635,0.49068080880618953,0.49068080880618953],[0.8974534722142382,0.5016001274737849,0.5016001274737849],[0.9089511260291274,0.5124192313516149,0.5124192313516149],[0.918724776273931,0.5233733004162796,0.5233733004162796],[0.9271769325614658,0.5348099989058438,0.5348099989058438],[0.9348913571357613,0.5471866228466732,0.5471866228466732],[0.9425953513779031,0.5610467455399599,0.5610467455399599],[0.31111289810529186,0.2659003418574735,0.2659003418574735],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.36238100335464446,0],[0,0.353165370752559,0],[0,0.3433460721377995,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],],[[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.269553510147819,0],[0,0.2779247384646558,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.862863795871991,0.4769708653359615,0.4769708653359615],[0.8809280461363547,0.48977541774660666,0.48977541774660666],[0.8970168973464191,0.5025218831442017,0.5025218831442017],[0.911183718592768,0.5154210174684783,0.5154210174684783],[0.923749369873305,0.5288572912288372,0.5288572912288372],[0.9353543113230034,0.5434323975814477,0.5434323975814477],[0.9469976115499875,0.5600089248350288,0.5600089248350288],[0.9600573266066551,0.5797476044207045,0.5797476044207045],[0.976264515309917,0.6041064704498702,0.6041064704498702],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.31964250752889856,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],],[[0,0.22050019052313752,0],[0,0.22681553981028935,0],[0,0.23339203717763343,0],[0,0.240214496679792,0],[0,0.24725746972595297,0],[0,0.25448250911433834,0],[0,0.26183515020613984,0],[0,0.26924183890499,0],[0,0.27660721846944913,0],[0,0.2838124066288337,0],[0,0.290715098224911,0],[0,0.2971524154784058,0],[0,0.3029472623689724,0],[0,0.3079184123129743,0],[0.9166547694971252,0.5166323224598249,0.5166323224598249],[0.9306991201883348,0.5311982918579957,0.5311982918579957],[0.942986803591991,0.5467760342781277,0.5467760342781277],[0,0.3165578521241011,0],[0,0.31548839579667104,0],[0,0.3131368632708015,0],[0.8,0.8,1],[0,0.30500137342777356,0],[0,0.29951030523776406,0],[0,0.29329773299429385,0],[0,0.28653936257609475,0],[0,0.27940222592749825,0],[0.8,0.8,1],[0,0.26457440761040923,0],[0,0.2571216942588568,0],[0,0.24976474642245705,0],],[[0.8,0.8,1],[0,0.20714814874471174,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.23670584867979186,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.2653456430194066,0],[0,0.2698801253354915,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.2797697633705014,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.2652596644585568,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.23044738434960232,0],[0.8,0.8,1],],[[0.8,0.8,1],[0,0.1874620478256095,0],[0,0.19215316230371715,0],[0,0.19696169224108015,0],[0,0.20186087426658073,0],[0,0.20681514030842463,0],[0,0.2117788084075138,0],[0,0.21669500719585458,0],[0,0.22149508562026893,0],[0,0.22609882383824634,0],[0,0.23041578943560334,0],[0,0.23434813805418903,0],[0,0.23779500435424242,0],[0,0.240658357082728,0],[0.8,0.8,1],[0,0.24429776275232565,0],[0,0.24495325891611666,0],[0,0.24479455500778916,0],[0,0.24382873003864916,0],[0.8,0.8,1],[0,0.23963973129383997,0],[0,0.23655408649128906,0],[0,0.23292473874860314,0],[0,0.2288489260033022,0],[0.8,0.8,1],[0,0.21974417921637143,0],[0,0.21489400490094954,0],[0,0.20994923454342304,0],[0,0.20497430079270745,0],[0.8,0.8,1],],[[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.1797204574749079,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.19516287408734248,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.2074862652007326,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.20573701126457444,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.19259287153244908,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.17697513874785395,0],],[[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.1614935034375082,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.17936757268974335,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.17026872079690972,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],],[[0,0.12879641411423945,0],[0.8,0.8,1],[0.8,0.8,1],[0,0.1358377385211167,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.1546643297719027,0],[0.8,0.8,1],[0.8,0.8,1],[0,0.1559650385862031,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.14211514071040432,0],[0.8,0.8,1],[0.8,0.8,1],[0,0.13513052327523242,0],],[[0,0.11212384156112787,0],[0.8,0.8,1],[0,0.11564325792725064,0],[0,0.1174011949544484,0],[0.8,0.8,1],[0,0.12084571295779206,0],[0,0.12249918688067803,0],[0,0.1240816293005488,0],[0,0.12557222890553357,0],[0.8,0.8,1],[0,0.12819024296879525,0],[0,0.12927368617900967,0],[0.8,0.8,1],[0,0.13088813449481448,0],[0,0.13138603838942955,0],[0.8,0.8,1],[0,0.13170953912018962,0],[0.8,0.8,1],[0,0.13112114069722186,0],[0,0.13049815823500216,0],[0.8,0.8,1],[0,0.12866048872503766,0],[0,0.1274822855623644,0],[0.8,0.8,1],[0,0.1247126669400825,0],[0,0.12316534788101306,0],[0,0.12153830315457151,0],[0,0.11985151859147432,0],[0.8,0.8,1],[0,0.11637011656642021,0],],[[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.104782462250846,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.1094376687357348,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],],[[0.8,0.8,1],[0.8,0.8,1],[0,0.0830756783895465,0],[0.8,0.8,1],[0,0.08474229354589341,0],[0.8,0.8,1],[0.8,0.8,1],[0,0.08702004690763979,0],[0.8,0.8,1],[0,0.08829471061229066,0],[0.8,0.8,1],[0.8,0.8,1],[0,0.0896722795161435,0],[0.8,0.8,1],[0,0.0901512080809384,0],[0.8,0.8,1],[0.8,0.8,1],[0,0.09012955842093213,0],[0.8,0.8,1],[0,0.08962319641070081,0],[0.8,0.8,1],[0.8,0.8,1],[0,0.08821080590025861,0],[0.8,0.8,1],[0,0.08691857775431859,0],[0.8,0.8,1],[0.8,0.8,1],[0,0.08462346811430875,0],[0.8,0.8,1],[0,0.08295071578903558,0],],[[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.06935458357760912,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.07223735845162484,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0,0.07191875490542338,0],[0,0.07163456254931609,0],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],],[[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],[0.8,0.8,1],],];\n    var canvas = document.getElementById("renderCanvas").getContext("2d");\n\n\n    var size = 30;\n    canvas.fillStyle = "red";\n    canvas.fillRect(0, 0, size, size);\n    canvas.scale(1, -1);\n    canvas.translate(0, -size);\n\n    if (!canvas.setFillColor)\n        canvas.setFillColor = function(r, g, b, a) {\n            this.fillStyle = "rgb("+[Math.floor(r * 255), Math.floor(g * 255), Math.floor(b * 255)]+")";\n    }\n\nfor (var y = 0; y < size; y++) {\n  for (var x = 0; x < size; x++) {\n    var l = pixels[y][x];\n    canvas.setFillColor(l[0], l[1], l[2], 1);\n    canvas.fillRect(x, y, 1, 1);\n  }\n}</script>';
+print(testOutput == expected)
+//print(testOutput)
+//print(expected)
\ No newline at end of file
diff -r b7bcdd009540 js/src/correct/check-access-binary-trees.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/correct/check-access-binary-trees.js	Thu Sep 11 15:19:25 2008 +0300
@@ -0,0 +1,52 @@
+/* The Great Computer Language Shootout
+   http://shootout.alioth.debian.org/
+   contributed by Isaac Gouy */
+
+function TreeNode(left,right,item){
+   this.left = left;
+   this.right = right;
+   this.item = item;
+}
+
+TreeNode.prototype.itemCheck = function(){
+   if (this.left==null) return this.item;
+   else return this.item + this.left.itemCheck() - this.right.itemCheck();
+}
+
+function bottomUpTree(item,depth){
+   if (depth>0){
+      return new TreeNode(
+          bottomUpTree(2*item-1, depth-1)
+         ,bottomUpTree(2*item, depth-1)
+         ,item
+      );
+   }
+   else {
+      return new TreeNode(null,null,item);
+   }
+}
+
+var ret;
+
+for ( var n = 4; n <= 7; n += 1 ) {
+    var minDepth = 4;
+    var maxDepth = Math.max(minDepth + 2, n);
+    var stretchDepth = maxDepth + 1;
+    
+    var check = bottomUpTree(0,stretchDepth).itemCheck();
+    
+    var longLivedTree = bottomUpTree(0,maxDepth);
+    for (var depth=minDepth; depth<=maxDepth; depth+=2){
+        var iterations = 1 << (maxDepth - depth + minDepth);
+
+        check = 0;
+        for (var i=1; i<=iterations; i++){
+            check += bottomUpTree(i,depth).itemCheck();
+            check += bottomUpTree(-i,depth).itemCheck();
+        }
+    }
+
+    ret = longLivedTree.itemCheck();
+}
+
+print(ret == -1)
diff -r b7bcdd009540 js/src/correct/check-access-fannkuch.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/correct/check-access-fannkuch.js	Thu Sep 11 15:19:25 2008 +0300
@@ -0,0 +1,66 @@
+/* The Great Computer Language Shootout
+   http://shootout.alioth.debian.org/
+   contributed by Isaac Gouy */
+
+function fannkuch(n) {
+   var check = 0;
+   var perm = Array(n);
+   var perm1 = Array(n);
+   var count = Array(n);
+   var maxPerm = Array(n);
+   var maxFlipsCount = 0;
+   var m = n - 1;
+
+   for (var i = 0; i < n; i++) perm1[i] = i;
+   var r = n;
+
+   while (true) {
+      // write-out the first 30 permutations
+      if (check < 30){
+         var s = "";
+         for(var i=0; i<n; i++) s += (perm1[i]+1).toString();
+         check++;
+      }
+
+      while (r != 1) { count[r - 1] = r; r--; }
+      if (!(perm1[0] == 0 || perm1[m] == m)) {
+         for (var i = 0; i < n; i++) perm[i] = perm1[i];
+
+         var flipsCount = 0;
+         var k;
+
+         while (!((k = perm[0]) == 0)) {
+            var k2 = (k + 1) >> 1;
+            for (var i = 0; i < k2; i++) {
+               var temp = perm[i]; perm[i] = perm[k - i]; perm[k - i] = temp;
+            }
+            flipsCount++;
+         }
+
+         if (flipsCount > maxFlipsCount) {
+            maxFlipsCount = flipsCount;
+            for (var i = 0; i < n; i++) maxPerm[i] = perm1[i];
+         }
+      }
+
+      while (true) {
+         if (r == n) return maxFlipsCount;
+         var perm0 = perm1[0];
+         var i = 0;
+         while (i < r) {
+            var j = i + 1;
+            perm1[i] = perm1[j];
+            i = j;
+         }
+         perm1[r] = perm0;
+
+         count[r] = count[r] - 1;
+         if (count[r] > 0) break;
+         r++;
+      }
+   }
+}
+
+var n = 8;
+var ret = fannkuch(n);
+print(ret == 22)
diff -r b7bcdd009540 js/src/correct/check-access-nbody.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/correct/check-access-nbody.js	Thu Sep 11 15:19:25 2008 +0300
@@ -0,0 +1,171 @@
+/* The Great Computer Language Shootout
+   http://shootout.alioth.debian.org/
+   contributed by Isaac Gouy */
+
+var PI = 3.141592653589793;
+var SOLAR_MASS = 4 * PI * PI;
+var DAYS_PER_YEAR = 365.24;
+
+function Body(x,y,z,vx,vy,vz,mass){
+   this.x = x;
+   this.y = y;
+   this.z = z;
+   this.vx = vx;
+   this.vy = vy;
+   this.vz = vz;
+   this.mass = mass;
+}
+
+Body.prototype.offsetMomentum = function(px,py,pz) {
+   this.vx = -px / SOLAR_MASS;
+   this.vy = -py / SOLAR_MASS;
+   this.vz = -pz / SOLAR_MASS;
+   return this;
+}
+
+function Jupiter(){
+   return new Body(
+      4.84143144246472090e+00,
+      -1.16032004402742839e+00,
+      -1.03622044471123109e-01,
+      1.66007664274403694e-03 * DAYS_PER_YEAR,
+      7.69901118419740425e-03 * DAYS_PER_YEAR,
+      -6.90460016972063023e-05 * DAYS_PER_YEAR,
+      9.54791938424326609e-04 * SOLAR_MASS
+   );
+}
+
+function Saturn(){
+   return new Body(
+      8.34336671824457987e+00,
+      4.12479856412430479e+00,
+      -4.03523417114321381e-01,
+      -2.76742510726862411e-03 * DAYS_PER_YEAR,
+      4.99852801234917238e-03 * DAYS_PER_YEAR,
+      2.30417297573763929e-05 * DAYS_PER_YEAR,
+      2.85885980666130812e-04 * SOLAR_MASS
+   );
+}
+
+function Uranus(){
+   return new Body(
+      1.28943695621391310e+01,
+      -1.51111514016986312e+01,
+      -2.23307578892655734e-01,
+      2.96460137564761618e-03 * DAYS_PER_YEAR,
+      2.37847173959480950e-03 * DAYS_PER_YEAR,
+      -2.96589568540237556e-05 * DAYS_PER_YEAR,
+      4.36624404335156298e-05 * SOLAR_MASS
+   );
+}
+
+function Neptune(){
+   return new Body(
+      1.53796971148509165e+01,
+      -2.59193146099879641e+01,
+      1.79258772950371181e-01,
+      2.68067772490389322e-03 * DAYS_PER_YEAR,
+      1.62824170038242295e-03 * DAYS_PER_YEAR,
+      -9.51592254519715870e-05 * DAYS_PER_YEAR,
+      5.15138902046611451e-05 * SOLAR_MASS
+   );
+}
+
+function Sun(){
+   return new Body(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, SOLAR_MASS);
+}
+
+
+function NBodySystem(bodies){
+   this.bodies = bodies;
+   var px = 0.0;
+   var py = 0.0;
+   var pz = 0.0;
+   var size = this.bodies.length;
+   for (var i=0; i<size; i++){
+      var b = this.bodies[i];
+      var m = b.mass;
+      px += b.vx * m;
+      py += b.vy * m;
+      pz += b.vz * m;
+   }
+   this.bodies[0].offsetMomentum(px,py,pz);
+}
+
+NBodySystem.prototype.advance = function(dt){
+   var dx, dy, dz, distance, mag;
+   var size = this.bodies.length;
+
+   for (var i=0; i<size; i++) {
+      var bodyi = this.bodies[i];
+      for (var j=i+1; j<size; j++) {
+         var bodyj = this.bodies[j];
+         dx = bodyi.x - bodyj.x;
+         dy = bodyi.y - bodyj.y;
+         dz = bodyi.z - bodyj.z;
+
+         distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
+         mag = dt / (distance * distance * distance);
+
+         bodyi.vx -= dx * bodyj.mass * mag;
+         bodyi.vy -= dy * bodyj.mass * mag;
+         bodyi.vz -= dz * bodyj.mass * mag;
+
+         bodyj.vx += dx * bodyi.mass * mag;
+         bodyj.vy += dy * bodyi.mass * mag;
+         bodyj.vz += dz * bodyi.mass * mag;
+      }
+   }
+
+   for (var i=0; i<size; i++) {
+      var body = this.bodies[i];
+      body.x += dt * body.vx;
+      body.y += dt * body.vy;
+      body.z += dt * body.vz;
+   }
+}
+
+NBodySystem.prototype.energy = function(){
+   var dx, dy, dz, distance;
+   var e = 0.0;
+   var size = this.bodies.length;
+
+   for (var i=0; i<size; i++) {
+      var bodyi = this.bodies[i];
+
+      e += 0.5 * bodyi.mass *
+         ( bodyi.vx * bodyi.vx
+         + bodyi.vy * bodyi.vy
+         + bodyi.vz * bodyi.vz );
+
+      for (var j=i+1; j<size; j++) {
+         var bodyj = this.bodies[j];
+         dx = bodyi.x - bodyj.x;
+         dy = bodyi.y - bodyj.y;
+         dz = bodyi.z - bodyj.z;
+
+         distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
+         e -= (bodyi.mass * bodyj.mass) / distance;
+      }
+   }
+   return e;
+}
+
+var ret;
+
+for ( var n = 3; n <= 24; n *= 2 ) {
+    (function(){
+        var bodies = new NBodySystem( Array(
+           Sun(),Jupiter(),Saturn(),Uranus(),Neptune()
+        ));
+        var max = n * 100;
+        
+        ret = bodies.energy();
+        for (var i=0; i<max; i++){
+            bodies.advance(0.01);
+        }
+        ret = bodies.energy();
+    })();
+}
+
+print(ret == -0.16906933525822856)
diff -r b7bcdd009540 js/src/correct/check-access-nsieve.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/correct/check-access-nsieve.js	Thu Sep 11 15:19:25 2008 +0300
@@ -0,0 +1,40 @@
+// The Great Computer Language Shootout
+// http://shootout.alioth.debian.org/
+//
+// modified by Isaac Gouy
+
+function pad(number,width){
+   var s = number.toString();
+   var prefixWidth = width - s.length;
+   if (prefixWidth>0){
+      for (var i=1; i<=prefixWidth; i++) s = " " + s;
+   }
+   return s;
+}
+
+function nsieve(m, isPrime){
+   var i, k, count;
+
+   for (i=2; i<=m; i++) { isPrime[i] = true; }
+   count = 0;
+
+   for (i=2; i<=m; i++){
+      if (isPrime[i]) {
+         for (k=i+i; k<=m; k+=i) isPrime[k] = false;
+         count++;
+      }
+   }
+   return count;
+}
+
+var ret = 0;
+function sieve() {
+    for (var i = 1; i <= 3; i++ ) {
+        var m = (1<<i)*10000;
+        var flags = Array(m+1);
+        ret += nsieve(m, flags);
+    }
+}
+
+sieve();
+print(ret == 14302)
\ No newline at end of file
diff -r b7bcdd009540 js/src/correct/check-bitops-3bit-bits-in-byte.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/correct/check-bitops-3bit-bits-in-byte.js	Thu Sep 11 15:19:25 2008 +0300
@@ -0,0 +1,35 @@
+// Copyright (c) 2004 by Arthur Langereis (arthur_ext at domain xfinitegames, tld com
+
+// 1 op = 6 ANDs, 3 SHRs, 3 SHLs, 4 assigns, 2 ADDs
+// O(1)
+function fast3bitlookup(b) {
+var c, bi3b = 0xE994; // 0b1110 1001 1001 0100; // 3 2 2 1  2 1 1 0
+c  = 3 & (bi3b >> ((b << 1) & 14));
+c += 3 & (bi3b >> ((b >> 2) & 14));
+c += 3 & (bi3b >> ((b >> 5) & 6));
+return c;
+
+/*
+lir4,0xE994; 9 instructions, no memory access, minimal register dependence, 6 shifts, 2 adds, 1 inline assign
+rlwinmr5,r3,1,28,30
+rlwinmr6,r3,30,28,30
+rlwinmr7,r3,27,29,30
+rlwnmr8,r4,r5,30,31
+rlwnmr9,r4,r6,30,31
+rlwnmr10,r4,r7,30,31
+addr3,r8,r9
+addr3,r3,r10
+*/
+}
+
+var ret = 0;
+function TimeFunc(func) {
+  var x, y, t;
+  for(var x=0; x<500; x++)
+  for(var y=0; y<256; y++) {
+    ret += func(y);
+  }
+}
+
+TimeFunc(fast3bitlookup);
+print(ret == 512000)
\ No newline at end of file
diff -r b7bcdd009540 js/src/correct/check-bitops-bits-in-byte.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/correct/check-bitops-bits-in-byte.js	Thu Sep 11 15:19:25 2008 +0300
@@ -0,0 +1,24 @@
+// Copyright (c) 2004 by Arthur Langereis (arthur_ext at domain xfinitegames, tld com)
+
+
+// 1 op = 2 assigns, 16 compare/branches, 8 ANDs, (0-8) ADDs, 8 SHLs
+// O(n)
+function bitsinbyte(b) {
+var m = 1, c = 0;
+while(m<0x100) {
+if(b & m) c++;
+m <<= 1;
+}
+return c;
+}
+
+var ret = 0;
+function TimeFunc(func) {
+var x, y, t;
+for(var x=0; x<350; x++)
+for(var y=0; y<256; y++) 
+  ret += func(y);
+}
+
+TimeFunc(bitsinbyte);
+print(ret == 358400)
\ No newline at end of file
diff -r b7bcdd009540 js/src/correct/check-bitops-bitwise-and.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/correct/check-bitops-bitwise-and.js	Thu Sep 11 15:19:25 2008 +0300
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2007 Apple Inc.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
+ */
+
+bitwiseAndValue = 4294967296;
+for (var i = 0; i < 60; i++)
+    bitwiseAndValue = bitwiseAndValue & i;
+print(bitwiseAndValue == 0)
\ No newline at end of file
diff -r b7bcdd009540 js/src/correct/check-bitops-nsieve-bits.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/correct/check-bitops-nsieve-bits.js	Thu Sep 11 15:19:25 2008 +0300
@@ -0,0 +1,40 @@
+// The Great Computer Language Shootout
+//  http://shootout.alioth.debian.org
+//
+//  Contributed by Ian Osgood
+
+var result = [];
+
+function pad(n,width) {
+  var s = n.toString();
+  while (s.length < width) s = ' ' + s;
+  return s;
+}
+
+function primes(isPrime, n) {
+  var i, count = 0, m = 10000<<n, size = m+31>>5;
+
+  for (i=0; i<size; i++) isPrime[i] = 0xffffffff;
+
+  for (i=2; i<m; i++)
+    if (isPrime[i>>5] & 1<<(i&31)) {
+      for (var j=i+i; j<m; j+=i)
+        result.push(isPrime[j>>5] &= ~(1<<(j&31)));
+      count++;
+    }
+}
+
+function sieve() {
+    for (var i = 4; i <= 4; i++) {
+        var isPrime = new Array((10000<<i)+31>>5);
+        primes(isPrime, i);
+    }
+}
+
+sieve();
+
+var ret = 0;
+for (var i = 0; i < result.length; ++i)
+  ret += result[i];
+
+print(ret == -211235557404919)
\ No newline at end of file
diff -r b7bcdd009540 js/src/correct/check-controlflow-recursive.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/correct/check-controlflow-recursive.js	Thu Sep 11 15:19:25 2008 +0300
@@ -0,0 +1,27 @@
+// The Computer Language Shootout
+// http://shootout.alioth.debian.org/
+// contributed by Isaac Gouy
+
+function ack(m,n){
+   if (m==0) { return n+1; }
+   if (n==0) { return ack(m-1,1); }
+   return ack(m-1, ack(m,n-1) );
+}
+
+function fib(n) {
+    if (n < 2){ return 1; }
+    return fib(n-2) + fib(n-1);
+}
+
+function tak(x,y,z) {
+    if (y >= x) return z;
+    return tak(tak(x-1,y,z), tak(y-1,z,x), tak(z-1,x,y));
+}
+
+var ret = 0;
+for ( var i = 3; i <= 5; i++ ) {
+    ret += ack(3,i);
+    ret += fib(17.0+i);
+    ret += tak(3*i+3,2*i+2,i+1);
+}
+print(ret == 57775);
diff -r b7bcdd009540 js/src/correct/check-date-format-tofte.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/correct/check-date-format-tofte.js	Thu Sep 11 15:19:25 2008 +0300
@@ -0,0 +1,302 @@
+function arrayExists(array, x) {
+    for (var i = 0; i < array.length; i++) {
+        if (array[i] == x) return true;
+    }
+    return false;
+}
+
+Date.prototype.formatDate = function (input,time) {
+    // formatDate :
+    // a PHP date like function, for formatting date strings
+    // See: http://www.php.net/date
+    //
+    // input : format string
+    // time : epoch time (seconds, and optional)
+    //
+    // if time is not passed, formatting is based on 
+    // the current "this" date object's set time.
+    //
+    // supported:
+    // a, A, B, d, D, F, g, G, h, H, i, j, l (lowercase L), L, 
+    // m, M, n, O, r, s, S, t, U, w, W, y, Y, z
+    //
+    // unsupported:
+    // I (capital i), T, Z    
+
+    var switches =    ["a", "A", "B", "d", "D", "F", "g", "G", "h", "H", 
+                       "i", "j", "l", "L", "m", "M", "n", "O", "r", "s", 
+                       "S", "t", "U", "w", "W", "y", "Y", "z"];
+    var daysLong =    ["Sunday", "Monday", "Tuesday", "Wednesday", 
+                       "Thursday", "Friday", "Saturday"];
+    var daysShort =   ["Sun", "Mon", "Tue", "Wed", 
+                       "Thu", "Fri", "Sat"];
+    var monthsShort = ["Jan", "Feb", "Mar", "Apr",
+                       "May", "Jun", "Jul", "Aug", "Sep",
+                       "Oct", "Nov", "Dec"];
+    var monthsLong =  ["January", "February", "March", "April",
+                       "May", "June", "July", "August", "September",
+                       "October", "November", "December"];
+    var daysSuffix = ["st", "nd", "rd", "th", "th", "th", "th", // 1st - 7th
+                      "th", "th", "th", "th", "th", "th", "th", // 8th - 14th
+                      "th", "th", "th", "th", "th", "th", "st", // 15th - 21st
+                      "nd", "rd", "th", "th", "th", "th", "th", // 22nd - 28th
+                      "th", "th", "st"];                        // 29th - 31st
+
+    function a() {
+        // Lowercase Ante meridiem and Post meridiem
+        return self.getHours() > 11? "pm" : "am";
+    }
+    function A() {
+        // Uppercase Ante meridiem and Post meridiem
+        return self.getHours() > 11? "PM" : "AM";
+    }
+
+    function B(){
+        // Swatch internet time. code simply grabbed from ppk,
+        // since I was feeling lazy:
+        // http://www.xs4all.nl/~ppk/js/beat.html
+        var off = (self.getTimezoneOffset() + 60)*60;
+        var theSeconds = (self.getHours() * 3600) + 
+                         (self.getMinutes() * 60) + 
+                          self.getSeconds() + off;
+        var beat = Math.floor(theSeconds/86.4);
+        if (beat > 1000) beat -= 1000;
+        if (beat < 0) beat += 1000;
+        if ((""+beat).length == 1) beat = "00"+beat;
+        if ((""+beat).length == 2) beat = "0"+beat;
+        return beat;
+    }
+    
+    function d() {
+        // Day of the month, 2 digits with leading zeros
+        return new String(self.getDate()).length == 1?
+        "0"+self.getDate() : self.getDate();
+    }
+    function D() {
+        // A textual representation of a day, three letters
+        return daysShort[self.getDay()];
+    }
+    function F() {
+        // A full textual representation of a month
+        return monthsLong[self.getMonth()];
+    }
+    function g() {
+        // 12-hour format of an hour without leading zeros
+        return self.getHours() > 12? self.getHours()-12 : self.getHours();
+    }
+    function G() {
+        // 24-hour format of an hour without leading zeros
+        return self.getHours();
+    }
+    function h() {
+        // 12-hour format of an hour with leading zeros
+        if (self.getHours() > 12) {
+          var s = new String(self.getHours()-12);
+          return s.length == 1?
+          "0"+ (self.getHours()-12) : self.getHours()-12;
+        } else { 
+          var s = new String(self.getHours());
+          return s.length == 1?
+          "0"+self.getHours() : self.getHours();
+        }  
+    }
+    function H() {
+        // 24-hour format of an hour with leading zeros
+        return new String(self.getHours()).length == 1?
+        "0"+self.getHours() : self.getHours();
+    }
+    function i() {
+        // Minutes with leading zeros
+        return new String(self.getMinutes()).length == 1? 
+        "0"+self.getMinutes() : self.getMinutes(); 
+    }
+    function j() {
+        // Day of the month without leading zeros
+        return self.getDate();
+    }    
+    function l() {
+        // A full textual representation of the day of the week
+        return daysLong[self.getDay()];
+    }
+    function L() {
+        // leap year or not. 1 if leap year, 0 if not.
+        // the logic should match iso's 8601 standard.
+        var y_ = Y();
+        if (         
+            (y_ % 4 == 0 && y_ % 100 != 0) ||
+            (y_ % 4 == 0 && y_ % 100 == 0 && y_ % 400 == 0)
+            ) {
+            return 1;
+        } else {
+            return 0;
+        }
+    }
+    function m() {
+        // Numeric representation of a month, with leading zeros
+        return self.getMonth() < 9?
+        "0"+(self.getMonth()+1) : 
+        self.getMonth()+1;
+    }
+    function M() {
+        // A short textual representation of a month, three letters
+        return monthsShort[self.getMonth()];
+    }
+    function n() {
+        // Numeric representation of a month, without leading zeros
+        return self.getMonth()+1;
+    }
+    function O() {
+        // Difference to Greenwich time (GMT) in hours
+        var os = Math.abs(self.getTimezoneOffset());
+        var h = ""+Math.floor(os/60);
+        var m = ""+(os%60);
+        h.length == 1? h = "0"+h:1;
+        m.length == 1? m = "0"+m:1;
+        return self.getTimezoneOffset() < 0 ? "+"+h+m : "-"+h+m;
+    }
+    function r() {
+        // RFC 822 formatted date
+        var r; // result
+        //  Thu    ,     21          Dec         2000
+        r = D() + ", " + j() + " " + M() + " " + Y() +
+        //        16     :    01     :    07          +0200
+            " " + H() + ":" + i() + ":" + s() + " " + O();
+        return r;
+    }
+    function S() {
+        // English ordinal suffix for the day of the month, 2 characters
+        return daysSuffix[self.getDate()-1];
+    }
+    function s() {
+        // Seconds, with leading zeros
+        return new String(self.getSeconds()).length == 1?
+        "0"+self.getSeconds() : self.getSeconds();
+    }
+    function t() {
+
+        // thanks to Matt Bannon for some much needed code-fixes here!
+        var daysinmonths = [null,31,28,31,30,31,30,31,31,30,31,30,31];
+        if (L()==1 && n()==2) return 29; // leap day
+        return daysinmonths[n()];
+    }
+    function U() {
+        // Seconds since the Unix Epoch (January 1 1970 00:00:00 GMT)
+        return Math.round(self.getTime()/1000);
+    }
+    function W() {
+        // Weeknumber, as per ISO specification:
+        // http://www.cl.cam.ac.uk/~mgk25/iso-time.html
+        
+        // if the day is three days before newyears eve,
+        // there's a chance it's "week 1" of next year.
+        // here we check for that.
+        var beforeNY = 364+L() - z();
+        var afterNY  = z();
+        var weekday = w()!=0?w()-1:6; // makes sunday (0), into 6.
+        if (beforeNY <= 2 && weekday <= 2-beforeNY) {
+            return 1;
+        }
+        // similarly, if the day is within threedays of newyears
+        // there's a chance it belongs in the old year.
+        var ny = new Date("January 1 " + Y() + " 00:00:00");
+        var nyDay = ny.getDay()!=0?ny.getDay()-1:6;
+        if (
+            (afterNY <= 2) && 
+            (nyDay >=4)  && 
+            (afterNY >= (6-nyDay))
+            ) {
+            // Since I'm not sure we can just always return 53,
+            // i call the function here again, using the last day
+            // of the previous year, as the date, and then just
+            // return that week.
+            var prevNY = new Date("December 31 " + (Y()-1) + " 00:00:00");
+            return prevNY.formatDate("W");
+        }
+        
+        // week 1, is the week that has the first thursday in it.
+        // note that this value is not zero index.
+        if (nyDay <= 3) {
+            // first day of the year fell on a thursday, or earlier.
+            return 1 + Math.floor( ( z() + nyDay ) / 7 );
+        } else {
+            // first day of the year fell on a friday, or later.
+            return 1 + Math.floor( ( z() - ( 7 - nyDay ) ) / 7 );
+        }
+    }
+    function w() {
+        // Numeric representation of the day of the week
+        return self.getDay();
+    }
+    
+    function Y() {
+        // A full numeric representation of a year, 4 digits
+
+        // we first check, if getFullYear is supported. if it
+        // is, we just use that. ppks code is nice, but wont
+        // work with dates outside 1900-2038, or something like that
+        if (self.getFullYear) {
+            var newDate = new Date("January 1 2001 00:00:00 +0000");
+            var x = newDate .getFullYear();
+            if (x == 2001) {              
+                // i trust the method now
+                return self.getFullYear();
+            }
+        }
+        // else, do this:
+        // codes thanks to ppk:
+        // http://www.xs4all.nl/~ppk/js/introdate.html
+        var x = self.getYear();
+        var y = x % 100;
+        y += (y < 38) ? 2000 : 1900;
+        return y;
+    }
+    function y() {
+        // A two-digit representation of a year
+        var y = Y()+"";
+        return y.substring(y.length-2,y.length);
+    }
+    function z() {
+        // The day of the year, zero indexed! 0 through 366
+        var t = new Date("January 1 " + Y() + " 00:00:00");
+        var diff = self.getTime() - t.getTime();
+        return Math.floor(diff/1000/60/60/24);
+    }
+        
+    var self = this;
+    if (time) {
+        // save time
+        var prevTime = self.getTime();
+        self.setTime(time);
+    }
+    
+    var ia = input.split("");
+    var ij = 0;
+    while (ia[ij]) {
+        if (ia[ij] == "\\") {
+            // this is our way of allowing users to escape stuff
+            ia.splice(ij,1);
+        } else {
+            if (arrayExists(switches,ia[ij])) {
+                ia[ij] = eval(ia[ij] + "()");
+            }
+        }
+        ij++;
+    }
+    // reset time, back to what it was
+    if (prevTime) {
+        self.setTime(prevTime);
+    }
+    return ia.join("");
+}
+
+var date = new Date("1/1/2007 1:11:11");
+
+var ret = "";
+for (i = 0; i < 500; ++i) {
+    var shortFormat = date.formatDate("Y-m-d");
+    var longFormat = date.formatDate("l, F d, Y g:i:s A");
+    ret += shortFormat + longFormat;
+    date.setTime(date.getTime() + 84266956);
+}
+var expected = "2007-01-01Monday, January 01, 2007 1:11:11 AM2007-01-02Tuesday, January 02, 2007 0:35:37 AM2007-01-03Wednesday, January 03, 2007 0:00:04 AM2007-01-03Wednesday, January 03, 2007 11:24:31 PM2007-01-04Thursday, January 04, 2007 10:48:58 PM2007-01-05Friday, January 05, 2007 10:13:25 PM2007-01-06Saturday, January 06, 2007 9:37:52 PM2007-01-07Sunday, January 07, 2007 9:02:19 PM2007-01-08Monday, January 08, 2007 8:26:46 PM2007-01-09Tuesday, January 09, 2007 7:51:13 PM2007-01-10Wednesday, January 10, 2007 7:15:40 PM2007-01-11Thursday, January 11, 2007 6:40:07 PM2007-01-12Friday, January 12, 2007 6:04:34 PM2007-01-13Saturday, January 13, 2007 5:29:01 PM2007-01-14Sunday, January 14, 2007 4:53:28 PM2007-01-15Monday, January 15, 2007 4:17:55 PM2007-01-16Tuesday, January 16, 2007 3:42:22 PM2007-01-17Wednesday, January 17, 2007 3:06:49 PM2007-01-18Thursday, January 18, 2007 2:31:16 PM2007-01-19Friday, January 19, 2007 1:55:43 PM2007-01-20Saturday, January 20, 2007 1:20:10 PM2007-01-21Sunday, January 21, 2007 12:44:37 PM2007-01-22Monday, January 22, 2007 12:09:04 PM2007-01-23Tuesday, January 23, 2007 11:33:30 AM2007-01-24Wednesday, January 24, 2007 10:57:57 AM2007-01-25Thursday, January 25, 2007 10:22:24 AM2007-01-26Friday, January 26, 2007 9:46:51 AM2007-01-27Saturday, January 27, 2007 9:11:18 AM2007-01-28Sunday, January 28, 2007 8:35:45 AM2007-01-29Monday, January 29, 2007 8:00:12 AM2007-01-30Tuesday, January 30, 2007 7:24:39 AM2007-01-31Wednesday, January 31, 2007 6:49:06 AM2007-02-01Thursday, February 01, 2007 6:13:33 AM2007-02-02Friday, February 02, 2007 5:38:00 AM2007-02-03Saturday, February 03, 2007 5:02:27 AM2007-02-04Sunday, February 04, 2007 4:26:54 AM2007-02-05Monday, February 05, 2007 3:51:21 AM2007-02-06Tuesday, February 06, 2007 3:15:48 AM2007-02-07Wednesday, February 07, 2007 2:40:15 AM2007-02-08Thursday, February 08, 2007 2:04:42 AM2007-02-09Friday, February 09, 2007 1:29:09 AM2007-02-10Saturday, February 10, 2007 0:53:36 AM2007-02-11Sunday, February 11, 2007 0:18:03 AM2007-02-11Sunday, February 11, 2007 11:42:30 PM2007-02-12Monday, February 12, 2007 11:06:57 PM2007-02-13Tuesday, February 13, 2007 10:31:24 PM2007-02-14Wednesday, February 14, 2007 9:55:50 PM2007-02-15Thursday, February 15, 2007 9:20:17 PM2007-02-16Friday, February 16, 2007 8:44:44 PM2007-02-17Saturday, February 17, 2007 8:09:11 PM2007-02-18Sunday, February 18, 2007 7:33:38 PM2007-02-19Monday, February 19, 2007 6:58:05 PM2007-02-20Tuesday, February 20, 2007 6:22:32 PM2007-02-21Wednesday, February 21, 2007 5:46:59 PM2007-02-22Thursday, February 22, 2007 5:11:26 PM2007-02-23Friday, February 23, 2007 4:35:53 PM2007-02-24Saturday, February 24, 2007 4:00:20 PM2007-02-25Sunday, February 25, 2007 3:24:47 PM2007-02-26Monday, February 26, 2007 2:49:14 PM2007-02-27Tuesday, February 27, 2007 2:13:41 PM2007-02-28Wednesday, February 28, 2007 1:38:08 PM2007-03-01Thursday, March 01, 2007 1:02:35 PM2007-03-02Friday, March 02, 2007 12:27:02 PM2007-03-03Saturday, March 03, 2007 11:51:29 AM2007-03-04Sunday, March 04, 2007 11:15:56 AM2007-03-05Monday, March 05, 2007 10:40:23 AM2007-03-06Tuesday, March 06, 2007 10:04:50 AM2007-03-07Wednesday, March 07, 2007 9:29:17 AM2007-03-08Thursday, March 08, 2007 8:53:44 AM2007-03-09Friday, March 09, 2007 8:18:10 AM2007-03-10Saturday, March 10, 2007 7:42:37 AM2007-03-11Sunday, March 11, 2007 8:07:04 AM2007-03-12Monday, March 12, 2007 7:31:31 AM2007-03-13Tuesday, March 13, 2007 6:55:58 AM2007-03-14Wednesday, March 14, 2007 6:20:25 AM2007-03-15Thursday, March 15, 2007 5:44:52 AM2007-03-16Friday, March 16, 2007 5:09:19 AM2007-03-17Saturday, March 17, 2007 4:33:46 AM2007-03-18Sunday, March 18, 2007 3:58:13 AM2007-03-19Monday, March 19, 2007 3:22:40 AM2007-03-20Tuesday, March 20, 2007 2:47:07 AM2007-03-21Wednesday, March 21, 2007 2:11:34 AM2007-03-22Thursday, March 22, 2007 1:36:01 AM2007-03-23Friday, March 23, 2007 1:00:28 AM2007-03-24Saturday, March 24, 2007 0:24:55 AM2007-03-24Saturday, March 24, 2007 11:49:22 PM2007-03-25Sunday, March 25, 2007 11:13:49 PM2007-03-26Monday, March 26, 2007 10:38:16 PM2007-03-27Tuesday, March 27, 2007 10:02:43 PM2007-03-28Wednesday, March 28, 2007 9:27:10 PM2007-03-29Thursday, March 29, 2007 8:51:37 PM2007-03-30Friday, March 30, 2007 8:16:03 PM2007-03-31Saturday, March 31, 2007 7:40:30 PM2007-04-01Sunday, April 01, 2007 7:04:57 PM2007-04-02Monday, April 02, 2007 6:29:24 PM2007-04-03Tuesday, April 03, 2007 5:53:51 PM2007-04-04Wednesday, April 04, 2007 5:18:18 PM2007-04-05Thursday, April 05, 2007 4:42:45 PM2007-04-06Friday, April 06, 2007 4:07:12 PM2007-04-07Saturday, April 07, 2007 3:31:39 PM2007-04-08Sunday, April 08, 2007 2:56:06 PM2007-04-09Monday, April 09, 2007 2:20:33 PM2007-04-10Tuesday, April 10, 2007 1:45:00 PM2007-04-11Wednesday, April 11, 2007 1:09:27 PM2007-04-12Thursday, April 12, 2007 12:33:54 PM2007-04-13Friday, April 13, 2007 11:58:21 AM2007-04-14Saturday, April 14, 2007 11:22:48 AM2007-04-15Sunday, April 15, 2007 10:47:15 AM2007-04-16Monday, April 16, 2007 10:11:42 AM2007-04-17Tuesday, April 17, 2007 9:36:09 AM2007-04-18Wednesday, April 18, 2007 9:00:36 AM2007-04-19Thursday, April 19, 2007 8:25:03 AM2007-04-20Friday, April 20, 2007 7:49:30 AM2007-04-21Saturday, April 21, 2007 7:13:57 AM2007-04-22Sunday, April 22, 2007 6:38:23 AM2007-04-23Monday, April 23, 2007 6:02:50 AM2007-04-24Tuesday, April 24, 2007 5:27:17 AM2007-04-25Wednesday, April 25, 2007 4:51:44 AM2007-04-26Thursday, April 26, 2007 4:16:11 AM2007-04-27Friday, April 27, 2007 3:40:38 AM2007-04-28Saturday, April 28, 2007 3:05:05 AM2007-04-29Sunday, April 29, 2007 2:29:32 AM2007-04-30Monday, April 30, 2007 1:53:59 AM2007-05-01Tuesday, May 01, 2007 1:18:26 AM2007-05-02Wednesday, May 02, 2007 0:42:53 AM2007-05-03Thursday, May 03, 2007 0:07:20 AM2007-05-03Thursday, May 03, 2007 11:31:47 PM2007-05-04Friday, May 04, 2007 10:56:14 PM2007-05-05Saturday, May 05, 2007 10:20:41 PM2007-05-06Sunday, May 06, 2007 9:45:08 PM2007-05-07Monday, May 07, 2007 9:09:35 PM2007-05-08Tuesday, May 08, 2007 8:34:02 PM2007-05-09Wednesday, May 09, 2007 7:58:29 PM2007-05-10Thursday, May 10, 2007 7:22:56 PM2007-05-11Friday, May 11, 2007 6:47:23 PM2007-05-12Saturday, May 12, 2007 6:11:50 PM2007-05-13Sunday, May 13, 2007 5:36:17 PM2007-05-14Monday, May 14, 2007 5:00:43 PM2007-05-15Tuesday, May 15, 2007 4:25:10 PM2007-05-16Wednesday, May 16, 2007 3:49:37 PM2007-05-17Thursday, May 17, 2007 3:14:04 PM2007-05-18Friday, May 18, 2007 2:38:31 PM2007-05-19Saturday, May 19, 2007 2:02:58 PM2007-05-20Sunday, May 20, 2007 1:27:25 PM2007-05-21Monday, May 21, 2007 12:51:52 PM2007-05-22Tuesday, May 22, 2007 12:16:19 PM2007-05-23Wednesday, May 23, 2007 11:40:46 AM2007-05-24Thursday, May 24, 2007 11:05:13 AM2007-05-25Friday, May 25, 2007 10:29:40 AM2007-05-26Saturday, May 26, 2007 9:54:07 AM2007-05-27Sunday, May 27, 2007 9:18:34 AM2007-05-28Monday, May 28, 2007 8:43:01 AM2007-05-29Tuesday, May 29, 2007 8:07:28 AM2007-05-30Wednesday, May 30, 2007 7:31:55 AM2007-05-31Thursday, May 31, 2007 6:56:22 AM2007-06-01Friday, June 01, 2007 6:20:49 AM2007-06-02Saturday, June 02, 2007 5:45:16 AM2007-06-03Sunday, June 03, 2007 5:09:43 AM2007-06-04Monday, June 04, 2007 4:34:10 AM2007-06-05Tuesday, June 05, 2007 3:58:37 AM2007-06-06Wednesday, June 06, 2007 3:23:03 AM2007-06-07Thursday, June 07, 2007 2:47:30 AM2007-06-08Friday, June 08, 2007 2:11:57 AM2007-06-09Saturday, June 09, 2007 1:36:24 AM2007-06-10Sunday, June 10, 2007 1:00:51 AM2007-06-11Monday, June 11, 2007 0:25:18 AM2007-06-11Monday, June 11, 2007 11:49:45 PM2007-06-12Tuesday, June 12, 2007 11:14:12 PM2007-06-13Wednesday, June 13, 2007 10:38:39 PM2007-06-14Thursday, June 14, 2007 10:03:06 PM2007-06-15Friday, June 15, 2007 9:27:33 PM2007-06-16Saturday, June 16, 2007 8:52:00 PM2007-06-17Sunday, June 17, 2007 8:16:27 PM2007-06-18Monday, June 18, 2007 7:40:54 PM2007-06-19Tuesday, June 19, 2007 7:05:21 PM2007-06-20Wednesday, June 20, 2007 6:29:48 PM2007-06-21Thursday, June 21, 2007 5:54:15 PM2007-06-22Friday, June 22, 2007 5:18:42 PM2007-06-23Saturday, June 23, 2007 4:43:09 PM2007-06-24Sunday, June 24, 2007 4:07:36 PM2007-06-25Monday, June 25, 2007 3:32:03 PM2007-06-26Tuesday, June 26, 2007 2:56:30 PM2007-06-27Wednesday, June 27, 2007 2:20:56 PM2007-06-28Thursday, June 28, 2007 1:45:23 PM2007-06-29Friday, June 29, 2007 1:09:50 PM2007-06-30Saturday, June 30, 2007 12:34:17 PM2007-07-01Sunday, July 01, 2007 11:58:44 AM2007-07-02Monday, July 02, 2007 11:23:11 AM2007-07-03Tuesday, July 03, 2007 10:47:38 AM2007-07-04Wednesday, July 04, 2007 10:12:05 AM2007-07-05Thursday, July 05, 2007 9:36:32 AM2007-07-06Friday, July 06, 2007 9:00:59 AM2007-07-07Saturday, July 07, 2007 8:25:26 AM2007-07-08Sunday, July 08, 2007 7:49:53 AM2007-07-09Monday, July 09, 2007 7:14:20 AM2007-07-10Tuesday, July 10, 2007 6:38:47 AM2007-07-11Wednesday, July 11, 2007 6:03:14 AM2007-07-12Thursday, July 12, 2007 5:27:41 AM2007-07-13Friday, July 13, 2007 4:52:08 AM2007-07-14Saturday, July 14, 2007 4:16:35 AM2007-07-15Sunday, July 15, 2007 3:41:02 AM2007-07-16Monday, July 16, 2007 3:05:29 AM2007-07-17Tuesday, July 17, 2007 2:29:56 AM2007-07-18Wednesday, July 18, 2007 1:54:23 AM2007-07-19Thursday, July 19, 2007 1:18:50 AM2007-07-20Friday, July 20, 2007 0:43:16 AM2007-07-21Saturday, July 21, 2007 0:07:43 AM2007-07-21Saturday, July 21, 2007 11:32:10 PM2007-07-22Sunday, July 22, 2007 10:56:37 PM2007-07-23Monday, July 23, 2007 10:21:04 PM2007-07-24Tuesday, July 24, 2007 9:45:31 PM2007-07-25Wednesday, July 25, 2007 9:09:58 PM2007-07-26Thursday, July 26, 2007 8:34:25 PM2007-07-27Friday, July 27, 2007 7:58:52 PM2007-07-28Saturday, July 28, 2007 7:23:19 PM2007-07-29Sunday, July 29, 2007 6:47:46 PM2007-07-30Monday, July 30, 2007 6:12:13 PM2007-07-31Tuesday, July 31, 2007 5:36:40 PM2007-08-01Wednesday, August 01, 2007 5:01:07 PM2007-08-02Thursday, August 02, 2007 4:25:34 PM2007-08-03Friday, August 03, 2007 3:50:01 PM2007-08-04Saturday, August 04, 2007 3:14:28 PM2007-08-05Sunday, August 05, 2007 2:38:55 PM2007-08-06Monday, August 06, 2007 2:03:22 PM2007-08-07Tuesday, August 07, 2007 1:27:49 PM2007-08-08Wednesday, August 08, 2007 12:52:16 PM2007-08-09Thursday, August 09, 2007 12:16:43 PM2007-08-10Friday, August 10, 2007 11:41:10 AM2007-08-11Saturday, August 11, 2007 11:05:36 AM2007-08-12Sunday, August 12, 2007 10:30:03 AM2007-08-13Monday, August 13, 2007 9:54:30 AM2007-08-14Tuesday, August 14, 2007 9:18:57 AM2007-08-15Wednesday, August 15, 2007 8:43:24 AM2007-08-16Thursday, August 16, 2007 8:07:51 AM2007-08-17Friday, August 17, 2007 7:32:18 AM2007-08-18Saturday, August 18, 2007 6:56:45 AM2007-08-19Sunday, August 19, 2007 6:21:12 AM2007-08-20Monday, August 20, 2007 5:45:39 AM2007-08-21Tuesday, August 21, 2007 5:10:06 AM2007-08-22Wednesday, August 22, 2007 4:34:33 AM2007-08-23Thursday, August 23, 2007 3:59:00 AM2007-08-24Friday, August 24, 2007 3:23:27 AM2007-08-25Saturday, August 25, 2007 2:47:54 AM2007-08-26Sunday, August 26, 2007 2:12:21 AM2007-08-27Monday, August 27, 2007 1:36:48 AM2007-08-28Tuesday, August 28, 2007 1:01:15 AM2007-08-29Wednesday, August 29, 2007 0:25:42 AM2007-08-29Wednesday, August 29, 2007 11:50:09 PM2007-08-30Thursday, August 30, 2007 11:14:36 PM2007-08-31Friday, August 31, 2007 10:39:03 PM2007-09-01Saturday, September 01, 2007 10:03:30 PM2007-09-02Sunday, September 02, 2007 9:27:56 PM2007-09-03Monday, September 03, 2007 8:52:23 PM2007-09-04Tuesday, September 04, 2007 8:16:50 PM2007-09-05Wednesday, September 05, 2007 7:41:17 PM2007-09-06Thursday, September 06, 2007 7:05:44 PM2007-09-07Friday, September 07, 2007 6:30:11 PM2007-09-08Saturday, September 08, 2007 5:54:38 PM2007-09-09Sunday, September 09, 2007 5:19:05 PM2007-09-10Monday, September 10, 2007 4:43:32 PM2007-09-11Tuesday, September 11, 2007 4:07:59 PM2007-09-12Wednesday, September 12, 2007 3:32:26 PM2007-09-13Thursday, September 13, 2007 2:56:53 PM2007-09-14Friday, September 14, 2007 2:21:20 PM2007-09-15Saturday, September 15, 2007 1:45:47 PM2007-09-16Sunday, September 16, 2007 1:10:14 PM2007-09-17Monday, September 17, 2007 12:34:41 PM2007-09-18Tuesday, September 18, 2007 11:59:08 AM2007-09-19Wednesday, September 19, 2007 11:23:35 AM2007-09-20Thursday, September 20, 2007 10:48:02 AM2007-09-21Friday, September 21, 2007 10:12:29 AM2007-09-22Saturday, September 22, 2007 9:36:56 AM2007-09-23Sunday, September 23, 2007 9:01:23 AM2007-09-24Monday, September 24, 2007 8:25:49 AM2007-09-25Tuesday, September 25, 2007 7:50:16 AM2007-09-26Wednesday, September 26, 2007 7:14:43 AM2007-09-27Thursday, September 27, 2007 6:39:10 AM2007-09-28Friday, September 28, 2007 6:03:37 AM2007-09-29Saturday, September 29, 2007 5:28:04 AM2007-09-30Sunday, September 30, 2007 4:52:31 AM2007-10-01Monday, October 01, 2007 4:16:58 AM2007-10-02Tuesday, October 02, 2007 3:41:25 AM2007-10-03Wednesday, October 03, 2007 3:05:52 AM2007-10-04Thursday, October 04, 2007 2:30:19 AM2007-10-05Friday, October 05, 2007 1:54:46 AM2007-10-06Saturday, October 06, 2007 1:19:13 AM2007-10-07Sunday, October 07, 2007 0:43:40 AM2007-10-08Monday, October 08, 2007 0:08:07 AM2007-10-08Monday, October 08, 2007 11:32:34 PM2007-10-09Tuesday, October 09, 2007 10:57:01 PM2007-10-10Wednesday, October 10, 2007 10:21:28 PM2007-10-11Thursday, October 11, 2007 9:45:55 PM2007-10-12Friday, October 12, 2007 9:10:22 PM2007-10-13Saturday, October 13, 2007 8:34:49 PM2007-10-14Sunday, October 14, 2007 7:59:16 PM2007-10-15Monday, October 15, 2007 7:23:43 PM2007-10-16Tuesday, October 16, 2007 6:48:09 PM2007-10-17Wednesday, October 17, 2007 6:12:36 PM2007-10-18Thursday, October 18, 2007 5:37:03 PM2007-10-19Friday, October 19, 2007 5:01:30 PM2007-10-20Saturday, October 20, 2007 4:25:57 PM2007-10-21Sunday, October 21, 2007 3:50:24 PM2007-10-22Monday, October 22, 2007 3:14:51 PM2007-10-23Tuesday, October 23, 2007 2:39:18 PM2007-10-24Wednesday, October 24, 2007 2:03:45 PM2007-10-25Thursday, October 25, 2007 1:28:12 PM2007-10-26Friday, October 26, 2007 12:52:39 PM2007-10-27Saturday, October 27, 2007 12:17:06 PM2007-10-28Sunday, October 28, 2007 11:41:33 AM2007-10-29Monday, October 29, 2007 11:06:00 AM2007-10-30Tuesday, October 30, 2007 10:30:27 AM2007-10-31Wednesday, October 31, 2007 9:54:54 AM2007-11-01Thursday, November 01, 2007 9:19:21 AM2007-11-02Friday, November 02, 2007 8:43:48 AM2007-11-03Saturday, November 03, 2007 8:08:15 AM2007-11-04Sunday, November 04, 2007 6:32:42 AM2007-11-05Monday, November 05, 2007 5:57:09 AM2007-11-06Tuesday, November 06, 2007 5:21:36 AM2007-11-07Wednesday, November 07, 2007 4:46:03 AM2007-11-08Thursday, November 08, 2007 4:10:29 AM2007-11-09Friday, November 09, 2007 3:34:56 AM2007-11-10Saturday, November 10, 2007 2:59:23 AM2007-11-11Sunday, November 11, 2007 2:23:50 AM2007-11-12Monday, November 12, 2007 1:48:17 AM2007-11-13Tuesday, November 13, 2007 1:12:44 AM2007-11-14Wednesday, November 14, 2007 0:37:11 AM2007-11-15Thursday, November 15, 2007 0:01:38 AM2007-11-15Thursday, November 15, 2007 11:26:05 PM2007-11-16Friday, November 16, 2007 10:50:32 PM2007-11-17Saturday, November 17, 2007 10:14:59 PM2007-11-18Sunday, November 18, 2007 9:39:26 PM2007-11-19Monday, November 19, 2007 9:03:53 PM2007-11-20Tuesday, November 20, 2007 8:28:20 PM2007-11-21Wednesday, November 21, 2007 7:52:47 PM2007-11-22Thursday, November 22, 2007 7:17:14 PM2007-11-23Friday, November 23, 2007 6:41:41 PM2007-11-24Saturday, November 24, 2007 6:06:08 PM2007-11-25Sunday, November 25, 2007 5:30:35 PM2007-11-26Monday, November 26, 2007 4:55:02 PM2007-11-27Tuesday, November 27, 2007 4:19:29 PM2007-11-28Wednesday, November 28, 2007 3:43:56 PM2007-11-29Thursday, November 29, 2007 3:08:22 PM2007-11-30Friday, November 30, 2007 2:32:49 PM2007-12-01Saturday, December 01, 2007 1:57:16 PM2007-12-02Sunday, December 02, 2007 1:21:43 PM2007-12-03Monday, December 03, 2007 12:46:10 PM2007-12-04Tuesday, December 04, 2007 12:10:37 PM2007-12-05Wednesday, December 05, 2007 11:35:04 AM2007-12-06Thursday, December 06, 2007 10:59:31 AM2007-12-07Friday, December 07, 2007 10:23:58 AM2007-12-08Saturday, December 08, 2007 9:48:25 AM2007-12-09Sunday, December 09, 2007 9:12:52 AM2007-12-10Monday, December 10, 2007 8:37:19 AM2007-12-11Tuesday, December 11, 2007 8:01:46 AM2007-12-12Wednesday, December 12, 2007 7:26:13 AM2007-12-13Thursday, December 13, 2007 6:50:40 AM2007-12-14Friday, December 14, 2007 6:15:07 AM2007-12-15Saturday, December 15, 2007 5:39:34 AM2007-12-16Sunday, December 16, 2007 5:04:01 AM2007-12-17Monday, December 17, 2007 4:28:28 AM2007-12-18Tuesday, December 18, 2007 3:52:55 AM2007-12-19Wednesday, December 19, 2007 3:17:22 AM2007-12-20Thursday, December 20, 2007 2:41:49 AM2007-12-21Friday, December 21, 2007 2:06:16 AM2007-12-22Saturday, December 22, 2007 1:30:42 AM2007-12-23Sunday, December 23, 2007 0:55:09 AM2007-12-24Monday, December 24, 2007 0:19:36 AM2007-12-24Monday, December 24, 2007 11:44:03 PM2007-12-25Tuesday, December 25, 2007 11:08:30 PM2007-12-26Wednesday, December 26, 2007 10:32:57 PM2007-12-27Thursday, December 27, 2007 9:57:24 PM2007-12-28Friday, December 28, 2007 9:21:51 PM2007-12-29Saturday, December 29, 2007 8:46:18 PM2007-12-30Sunday, December 30, 2007 8:10:45 PM2007-12-31Monday, December 31, 2007 7:35:12 PM2008-01-01Tuesday, January 01, 2008 6:59:39 PM2008-01-02Wednesday, January 02, 2008 6:24:06 PM2008-01-03Thursday, January 03, 2008 5:48:33 PM2008-01-04Friday, January 04, 2008 5:13:00 PM2008-01-05Saturday, January 05, 2008 4:37:27 PM2008-01-06Sunday, January 06, 2008 4:01:54 PM2008-01-07Monday, January 07, 2008 3:26:21 PM2008-01-08Tuesday, January 08, 2008 2:50:48 PM2008-01-09Wednesday, January 09, 2008 2:15:15 PM2008-01-10Thursday, January 10, 2008 1:39:42 PM2008-01-11Friday, January 11, 2008 1:04:09 PM2008-01-12Saturday, January 12, 2008 12:28:36 PM2008-01-13Sunday, January 13, 2008 11:53:02 AM2008-01-14Monday, January 14, 2008 11:17:29 AM2008-01-15Tuesday, January 15, 2008 10:41:56 AM2008-01-16Wednesday, January 16, 2008 10:06:23 AM2008-01-17Thursday, January 17, 2008 9:30:50 AM2008-01-18Friday, January 18, 2008 8:55:17 AM2008-01-19Saturday, January 19, 2008 8:19:44 AM2008-01-20Sunday, January 20, 2008 7:44:11 AM2008-01-21Monday, January 21, 2008 7:08:38 AM2008-01-22Tuesday, January 22, 2008 6:33:05 AM2008-01-23Wednesday, January 23, 2008 5:57:32 AM2008-01-24Thursday, January 24, 2008 5:21:59 AM2008-01-25Friday, January 25, 2008 4:46:26 AM2008-01-26Saturday, January 26, 2008 4:10:53 AM2008-01-27Sunday, January 27, 2008 3:35:20 AM2008-01-28Monday, January 28, 2008 2:59:47 AM2008-01-29Tuesday, January 29, 2008 2:24:14 AM2008-01-30Wednesday, January 30, 2008 1:48:41 AM2008-01-31Thursday, January 31, 2008 1:13:08 AM2008-02-01Friday, February 01, 2008 0:37:35 AM2008-02-02Saturday, February 02, 2008 0:02:02 AM2008-02-02Saturday, February 02, 2008 11:26:29 PM2008-02-03Sunday, February 03, 2008 10:50:56 PM2008-02-04Monday, February 04, 2008 10:15:22 PM2008-02-05Tuesday, February 05, 2008 9:39:49 PM2008-02-06Wednesday, February 06, 2008 9:04:16 PM2008-02-07Thursday, February 07, 2008 8:28:43 PM2008-02-08Friday, February 08, 2008 7:53:10 PM2008-02-09Saturday, February 09, 2008 7:17:37 PM2008-02-10Sunday, February 10, 2008 6:42:04 PM2008-02-11Monday, February 11, 2008 6:06:31 PM2008-02-12Tuesday, February 12, 2008 5:30:58 PM2008-02-13Wednesday, February 13, 2008 4:55:25 PM2008-02-14Thursday, February 14, 2008 4:19:52 PM2008-02-15Friday, February 15, 2008 3:44:19 PM2008-02-16Saturday, February 16, 2008 3:08:46 PM2008-02-17Sunday, February 17, 2008 2:33:13 PM2008-02-18Monday, February 18, 2008 1:57:40 PM2008-02-19Tuesday, February 19, 2008 1:22:07 PM2008-02-20Wednesday, February 20, 2008 12:46:34 PM2008-02-21Thursday, February 21, 2008 12:11:01 PM2008-02-22Friday, February 22, 2008 11:35:28 AM2008-02-23Saturday, February 23, 2008 10:59:55 AM2008-02-24Sunday, February 24, 2008 10:24:22 AM2008-02-25Monday, February 25, 2008 9:48:49 AM2008-02-26Tuesday, February 26, 2008 9:13:15 AM2008-02-27Wednesday, February 27, 2008 8:37:42 AM2008-02-28Thursday, February 28, 2008 8:02:09 AM2008-02-29Friday, February 29, 2008 7:26:36 AM2008-03-01Saturday, March 01, 2008 6:51:03 AM2008-03-02Sunday, March 02, 2008 6:15:30 AM2008-03-03Monday, March 03, 2008 5:39:57 AM2008-03-04Tuesday, March 04, 2008 5:04:24 AM2008-03-05Wednesday, March 05, 2008 4:28:51 AM2008-03-06Thursday, March 06, 2008 3:53:18 AM2008-03-07Friday, March 07, 2008 3:17:45 AM2008-03-08Saturday, March 08, 2008 2:42:12 AM2008-03-09Sunday, March 09, 2008 3:06:39 AM2008-03-10Monday, March 10, 2008 2:31:06 AM2008-03-11Tuesday, March 11, 2008 1:55:33 AM2008-03-12Wednesday, March 12, 2008 1:20:00 AM2008-03-13Thursday, March 13, 2008 0:44:27 AM2008-03-14Friday, March 14, 2008 0:08:54 AM2008-03-14Friday, March 14, 2008 11:33:21 PM2008-03-15Saturday, March 15, 2008 10:57:48 PM2008-03-16Sunday, March 16, 2008 10:22:15 PM2008-03-17Monday, March 17, 2008 9:46:42 PM2008-03-18Tuesday, March 18, 2008 9:11:09 PM2008-03-19Wednesday, March 19, 2008 8:35:35 PM2008-03-20Thursday, March 20, 2008 8:00:02 PM2008-03-21Friday, March 21, 2008 7:24:29 PM2008-03-22Saturday, March 22, 2008 6:48:56 PM2008-03-23Sunday, March 23, 2008 6:13:23 PM2008-03-24Monday, March 24, 2008 5:37:50 PM2008-03-25Tuesday, March 25, 2008 5:02:17 PM2008-03-26Wednesday, March 26, 2008 4:26:44 PM2008-03-27Thursday, March 27, 2008 3:51:11 PM2008-03-28Friday, March 28, 2008 3:15:38 PM2008-03-29Saturday, March 29, 2008 2:40:05 PM2008-03-30Sunday, March 30, 2008 2:04:32 PM2008-03-31Monday, March 31, 2008 1:28:59 PM2008-04-01Tuesday, April 01, 2008 12:53:26 PM2008-04-02Wednesday, April 02, 2008 12:17:53 PM2008-04-03Thursday, April 03, 2008 11:42:20 AM2008-04-04Friday, April 04, 2008 11:06:47 AM2008-04-05Saturday, April 05, 2008 10:31:14 AM2008-04-06Sunday, April 06, 2008 9:55:41 AM2008-04-07Monday, April 07, 2008 9:20:08 AM2008-04-08Tuesday, April 08, 2008 8:44:35 AM2008-04-09Wednesday, April 09, 2008 8:09:02 AM2008-04-10Thursday, April 10, 2008 7:33:29 AM2008-04-11Friday, April 11, 2008 6:57:55 AM2008-04-12Saturday, April 12, 2008 6:22:22 AM2008-04-13Sunday, April 13, 2008 5:46:49 AM2008-04-14Monday, April 14, 2008 5:11:16 AM2008-04-15Tuesday, April 15, 2008 4:35:43 AM2008-04-16Wednesday, April 16, 2008 4:00:10 AM2008-04-17Thursday, April 17, 2008 3:24:37 AM2008-04-18Friday, April 18, 2008 2:49:04 AM2008-04-19Saturday, April 19, 2008 2:13:31 AM2008-04-20Sunday, April 20, 2008 1:37:58 AM2008-04-21Monday, April 21, 2008 1:02:25 AM2008-04-22Tuesday, April 22, 2008 0:26:52 AM2008-04-22Tuesday, April 22, 2008 11:51:19 PM2008-04-23Wednesday, April 23, 2008 11:15:46 PM2008-04-24Thursday, April 24, 2008 10:40:13 PM2008-04-25Friday, April 25, 2008 10:04:40 PM2008-04-26Saturday, April 26, 2008 9:29:07 PM2008-04-27Sunday, April 27, 2008 8:53:34 PM2008-04-28Monday, April 28, 2008 8:18:01 PM2008-04-29Tuesday, April 29, 2008 7:42:28 PM2008-04-30Wednesday, April 30, 2008 7:06:55 PM2008-05-01Thursday, May 01, 2008 6:31:22 PM"
+print(ret == expected);
\ No newline at end of file
diff -r b7bcdd009540 js/src/correct/check-date-format-xparb.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/correct/check-date-format-xparb.js	Thu Sep 11 15:19:25 2008 +0300
@@ -0,0 +1,421 @@
+/*
+ * Copyright (C) 2004 Baron Schwartz <baron at sequent dot org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation, version 2.1.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
+ * details.
+ */
+
+Date.parseFunctions = {count:0};
+Date.parseRegexes = [];
+Date.formatFunctions = {count:0};
+
+Date.prototype.dateFormat = function(format) {
+    if (Date.formatFunctions[format] == null) {
+        Date.createNewFormat(format);
+    }
+    var func = Date.formatFunctions[format];
+    return this[func]();
+}
+
+Date.createNewFormat = function(format) {
+    var funcName = "format" + Date.formatFunctions.count++;
+    Date.formatFunctions[format] = funcName;
+    var code = "Date.prototype." + funcName + " = function(){return ";
+    var special = false;
+    var ch = '';
+    for (var i = 0; i < format.length; ++i) {
+        ch = format.charAt(i);
+        if (!special && ch == "\\") {
+            special = true;
+        }
+        else if (special) {
+            special = false;
+            code += "'" + String.escape(ch) + "' + ";
+        }
+        else {
+            code += Date.getFormatCode(ch);
+        }
+    }
+    eval(code.substring(0, code.length - 3) + ";}");
+}
+
+Date.getFormatCode = function(character) {
+    switch (character) {
+    case "d":
+        return "String.leftPad(this.getDate(), 2, '0') + ";
+    case "D":
+        return "Date.dayNames[this.getDay()].substring(0, 3) + ";
+    case "j":
+        return "this.getDate() + ";
+    case "l":
+        return "Date.dayNames[this.getDay()] + ";
+    case "S":
+        return "this.getSuffix() + ";
+    case "w":
+        return "this.getDay() + ";
+    case "z":
+        return "this.getDayOfYear() + ";
+    case "W":
+        return "this.getWeekOfYear() + ";
+    case "F":
+        return "Date.monthNames[this.getMonth()] + ";
+    case "m":
+        return "String.leftPad(this.getMonth() + 1, 2, '0') + ";
+    case "M":
+        return "Date.monthNames[this.getMonth()].substring(0, 3) + ";
+    case "n":
+        return "(this.getMonth() + 1) + ";
+    case "t":
+        return "this.getDaysInMonth() + ";
+    case "L":
+        return "(this.isLeapYear() ? 1 : 0) + ";
+    case "Y":
+        return "this.getFullYear() + ";
+    case "y":
+        return "('' + this.getFullYear()).substring(2, 4) + ";
+    case "a":
+        return "(this.getHours() < 12 ? 'am' : 'pm') + ";
+    case "A":
+        return "(this.getHours() < 12 ? 'AM' : 'PM') + ";
+    case "g":
+        return "((this.getHours() %12) ? this.getHours() % 12 : 12) + ";
+    case "G":
+        return "this.getHours() + ";
+    case "h":
+        return "String.leftPad((this.getHours() %12) ? this.getHours() % 12 : 12, 2, '0') + ";
+    case "H":
+        return "String.leftPad(this.getHours(), 2, '0') + ";
+    case "i":
+        return "String.leftPad(this.getMinutes(), 2, '0') + ";
+    case "s":
+        return "String.leftPad(this.getSeconds(), 2, '0') + ";
+    case "O":
+        return "this.getGMTOffset() + ";
+    case "T":
+        return "this.getTimezone() + ";
+    case "Z":
+        return "(this.getTimezoneOffset() * -60) + ";
+    default:
+        return "'" + String.escape(character) + "' + ";
+    }
+}
+
+Date.parseDate = function(input, format) {
+    if (Date.parseFunctions[format] == null) {
+        Date.createParser(format);
+    }
+    var func = Date.parseFunctions[format];
+    return Date[func](input);
+}
+
+Date.createParser = function(format) {
+    var funcName = "parse" + Date.parseFunctions.count++;
+    var regexNum = Date.parseRegexes.length;
+    var currentGroup = 1;
+    Date.parseFunctions[format] = funcName;
+
+    var code = "Date." + funcName + " = function(input){\n"
+        + "var y = -1, m = -1, d = -1, h = -1, i = -1, s = -1;\n"
+        + "var d = new Date();\n"
+        + "y = d.getFullYear();\n"
+        + "m = d.getMonth();\n"
+        + "d = d.getDate();\n"
+        + "var results = input.match(Date.parseRegexes[" + regexNum + "]);\n"
+        + "if (results && results.length > 0) {"
+    var regex = "";
+
+    var special = false;
+    var ch = '';
+    for (var i = 0; i < format.length; ++i) {
+        ch = format.charAt(i);
+        if (!special && ch == "\\") {
+            special = true;
+        }
+        else if (special) {
+            special = false;
+            regex += String.escape(ch);
+        }
+        else {
+            obj = Date.formatCodeToRegex(ch, currentGroup);
+            currentGroup += obj.g;
+            regex += obj.s;
+            if (obj.g && obj.c) {
+                code += obj.c;
+            }
+        }
+    }
+
+    code += "if (y > 0 && m >= 0 && d > 0 && h >= 0 && i >= 0 && s >= 0)\n"
+        + "{return new Date(y, m, d, h, i, s);}\n"
+        + "else if (y > 0 && m >= 0 && d > 0 && h >= 0 && i >= 0)\n"
+        + "{return new Date(y, m, d, h, i);}\n"
+        + "else if (y > 0 && m >= 0 && d > 0 && h >= 0)\n"
+        + "{return new Date(y, m, d, h);}\n"
+        + "else if (y > 0 && m >= 0 && d > 0)\n"
+        + "{return new Date(y, m, d);}\n"
+        + "else if (y > 0 && m >= 0)\n"
+        + "{return new Date(y, m);}\n"
+        + "else if (y > 0)\n"
+        + "{return new Date(y);}\n"
+        + "}return null;}";
+
+    Date.parseRegexes[regexNum] = new RegExp("^" + regex + "$");
+    eval(code);
+}
+
+Date.formatCodeToRegex = function(character, currentGroup) {
+    switch (character) {
+    case "D":
+        return {g:0,
+        c:null,
+        s:"(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)"};
+    case "j":
+    case "d":
+        return {g:1,
+            c:"d = parseInt(results[" + currentGroup + "], 10);\n",
+            s:"(\\d{1,2})"};
+    case "l":
+        return {g:0,
+            c:null,
+            s:"(?:" + Date.dayNames.join("|") + ")"};
+    case "S":
+        return {g:0,
+            c:null,
+            s:"(?:st|nd|rd|th)"};
+    case "w":
+        return {g:0,
+            c:null,
+            s:"\\d"};
+    case "z":
+        return {g:0,
+            c:null,
+            s:"(?:\\d{1,3})"};
+    case "W":
+        return {g:0,
+            c:null,
+            s:"(?:\\d{2})"};
+    case "F":
+        return {g:1,
+            c:"m = parseInt(Date.monthNumbers[results[" + currentGroup + "].substring(0, 3)], 10);\n",
+            s:"(" + Date.monthNames.join("|") + ")"};
+    case "M":
+        return {g:1,
+            c:"m = parseInt(Date.monthNumbers[results[" + currentGroup + "]], 10);\n",
+            s:"(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)"};
+    case "n":
+    case "m":
+        return {g:1,
+            c:"m = parseInt(results[" + currentGroup + "], 10) - 1;\n",
+            s:"(\\d{1,2})"};
+    case "t":
+        return {g:0,
+            c:null,
+            s:"\\d{1,2}"};
+    case "L":
+        return {g:0,
+            c:null,
+            s:"(?:1|0)"};
+    case "Y":
+        return {g:1,
+            c:"y = parseInt(results[" + currentGroup + "], 10);\n",
+            s:"(\\d{4})"};
+    case "y":
+        return {g:1,
+            c:"var ty = parseInt(results[" + currentGroup + "], 10);\n"
+                + "y = ty > Date.y2kYear ? 1900 + ty : 2000 + ty;\n",
+            s:"(\\d{1,2})"};
+    case "a":
+        return {g:1,
+            c:"if (results[" + currentGroup + "] == 'am') {\n"
+                + "if (h == 12) { h = 0; }\n"
+                + "} else { if (h < 12) { h += 12; }}",
+            s:"(am|pm)"};
+    case "A":
+        return {g:1,
+            c:"if (results[" + currentGroup + "] == 'AM') {\n"
+                + "if (h == 12) { h = 0; }\n"
+                + "} else { if (h < 12) { h += 12; }}",
+            s:"(AM|PM)"};
+    case "g":
+    case "G":
+    case "h":
+    case "H":
+        return {g:1,
+            c:"h = parseInt(results[" + currentGroup + "], 10);\n",
+            s:"(\\d{1,2})"};
+    case "i":
+        return {g:1,
+            c:"i = parseInt(results[" + currentGroup + "], 10);\n",
+            s:"(\\d{2})"};
+    case "s":
+        return {g:1,
+            c:"s = parseInt(results[" + currentGroup + "], 10);\n",
+            s:"(\\d{2})"};
+    case "O":
+        return {g:0,
+            c:null,
+            s:"[+-]\\d{4}"};
+    case "T":
+        return {g:0,
+            c:null,
+            s:"[A-Z]{3}"};
+    case "Z":
+        return {g:0,
+            c:null,
+            s:"[+-]\\d{1,5}"};
+    default:
+        return {g:0,
+            c:null,
+            s:String.escape(character)};
+    }
+}
+
+Date.prototype.getTimezone = function() {
+    return this.toString().replace(
+        /^.*? ([A-Z]{3}) [0-9]{4}.*$/, "$1").replace(
+        /^.*?\(([A-Z])[a-z]+ ([A-Z])[a-z]+ ([A-Z])[a-z]+\)$/, "$1$2$3");
+}
+
+Date.prototype.getGMTOffset = function() {
+    return (this.getTimezoneOffset() > 0 ? "-" : "+")
+        + String.leftPad(Math.floor(this.getTimezoneOffset() / 60), 2, "0")
+        + String.leftPad(this.getTimezoneOffset() % 60, 2, "0");
+}
+
+Date.prototype.getDayOfYear = function() {
+    var num = 0;
+    Date.daysInMonth[1] = this.isLeapYear() ? 29 : 28;
+    for (var i = 0; i < this.getMonth(); ++i) {
+        num += Date.daysInMonth[i];
+    }
+    return num + this.getDate() - 1;
+}
+
+Date.prototype.getWeekOfYear = function() {
+    // Skip to Thursday of this week
+    var now = this.getDayOfYear() + (4 - this.getDay());
+    // Find the first Thursday of the year
+    var jan1 = new Date(this.getFullYear(), 0, 1);
+    var then = (7 - jan1.getDay() + 4);
+    document.write(then);
+    return String.leftPad(((now - then) / 7) + 1, 2, "0");
+}
+
+Date.prototype.isLeapYear = function() {
+    var year = this.getFullYear();
+    return ((year & 3) == 0 && (year % 100 || (year % 400 == 0 && year)));
+}
+
+Date.prototype.getFirstDayOfMonth = function() {
+    var day = (this.getDay() - (this.getDate() - 1)) % 7;
+    return (day < 0) ? (day + 7) : day;
+}
+
+Date.prototype.getLastDayOfMonth = function() {
+    var day = (this.getDay() + (Date.daysInMonth[this.getMonth()] - this.getDate())) % 7;
+    return (day < 0) ? (day + 7) : day;
+}
+
+Date.prototype.getDaysInMonth = function() {
+    Date.daysInMonth[1] = this.isLeapYear() ? 29 : 28;
+    return Date.daysInMonth[this.getMonth()];
+}
+
+Date.prototype.getSuffix = function() {
+    switch (this.getDate()) {
+        case 1:
+        case 21:
+        case 31:
+            return "st";
+        case 2:
+        case 22:
+            return "nd";
+        case 3:
+        case 23:
+            return "rd";
+        default:
+            return "th";
+    }
+}
+
+String.escape = function(string) {
+    return string.replace(/('|\\)/g, "\\$1");
+}
+
+String.leftPad = function (val, size, ch) {
+    var result = new String(val);
+    if (ch == null) {
+        ch = " ";
+    }
+    while (result.length < size) {
+        result = ch + result;
+    }
+    return result;
+}
+
+Date.daysInMonth = [31,28,31,30,31,30,31,31,30,31,30,31];
+Date.monthNames =
+   ["January",
+    "February",
+    "March",
+    "April",
+    "May",
+    "June",
+    "July",
+    "August",
+    "September",
+    "October",
+    "November",
+    "December"];
+Date.dayNames =
+   ["Sunday",
+    "Monday",
+    "Tuesday",
+    "Wednesday",
+    "Thursday",
+    "Friday",
+    "Saturday"];
+Date.y2kYear = 50;
+Date.monthNumbers = {
+    Jan:0,
+    Feb:1,
+    Mar:2,
+    Apr:3,
+    May:4,
+    Jun:5,
+    Jul:6,
+    Aug:7,
+    Sep:8,
+    Oct:9,
+    Nov:10,
+    Dec:11};
+Date.patterns = {
+    ISO8601LongPattern:"Y-m-d H:i:s",
+    ISO8601ShortPattern:"Y-m-d",
+    ShortDatePattern: "n/j/Y",
+    LongDatePattern: "l, F d, Y",
+    FullDateTimePattern: "l, F d, Y g:i:s A",
+    MonthDayPattern: "F d",
+    ShortTimePattern: "g:i A",
+    LongTimePattern: "g:i:s A",
+    SortableDateTimePattern: "Y-m-d\\TH:i:s",
+    UniversalSortableDateTimePattern: "Y-m-d H:i:sO",
+    YearMonthPattern: "F, Y"};
+
+var date = new Date("1/1/2007 1:11:11");
+
+var ret = "";
+for (i = 0; i < 4000; ++i) {
+    var shortFormat = date.dateFormat("Y-m-d");
+    var longFormat = date.dateFormat("l, F d, Y g:i:s A");
+    ret += shortFormat + longFormat;
+    date.setTime(date.getTime() + 84266956);
+}
+var expected = "2007-01-01Monday, January 01, 2007 1:11:11 AM2007-01-02Tuesday, January 02, 2007 12:35:37 AM2007-01-03Wednesday, January 03, 2007 12:00:04 AM2007-01-03Wednesday, January 03, 2007 11:24:31 PM2007-01-04Thursday, January 04, 2007 10:48:58 PM2007-01-05Friday, January 05, 2007 10:13:25 PM2007-01-06Saturday, January 06, 2007 9:37:52 PM2007-01-07Sunday, January 07, 2007 9:02:19 PM2007-01-08Monday, January 08, 2007 8:26:46 PM2007-01-09Tuesday, January 09, 2007 7:51:13 PM2007-01-10Wednesday, January 10, 2007 7:15:40 PM2007-01-11Thursday, January 11, 2007 6:40:07 PM2007-01-12Friday, January 12, 2007 6:04:34 PM2007-01-13Saturday, January 13, 2007 5:29:01 PM2007-01-14Sunday, January 14, 2007 4:53:28 PM2007-01-15Monday, January 15, 2007 4:17:55 PM2007-01-16Tuesday, January 16, 2007 3:42:22 PM2007-01-17Wednesday, January 17, 2007 3:06:49 PM2007-01-18Thursday, January 18, 2007 2:31:16 PM2007-01-19Friday, January 19, 2007 1:55:43 PM2007-01-20Saturday, January 20, 2007 1:20:10 PM2007-01-21Sunday, January 21, 2007 12:44:37 PM2007-01-22Monday, January 22, 2007 12:09:04 PM2007-01-23Tuesday, January 23, 2007 11:33:30 AM2007-01-24Wednesday, January 24, 2007 10:57:57 AM2007-01-25Thursday, January 25, 2007 10:22:24 AM2007-01-26Friday, January 26, 2007 9:46:51 AM2007-01-27Saturday, January 27, 2007 9:11:18 AM2007-01-28Sunday, January 28, 2007 8:35:45 AM2007-01-29Monday, January 29, 2007 8:00:12 AM2007-01-30Tuesday, January 30, 2007 7:24:39 AM2007-01-31Wednesday, January 31, 2007 6:49:06 AM2007-02-01Thursday, February 01, 2007 6:13:33 AM2007-02-02Friday, February 02, 2007 5:38:00 AM2007-02-03Saturday, February 03, 2007 5:02:27 AM2007-02-04Sunday, February 04, 2007 4:26:54 AM2007-02-05Monday, February 05, 2007 3:51:21 AM2007-02-06Tuesday, February 06, 2007 3:15:48 AM2007-02-07Wednesday, February 07, 2007 2:40:15 AM2007-02-08Thursday, February 08, 2007 2:04:42 AM2007-02-09Friday, February 09, 2007 1:29:09 AM2007-02-10Saturday, February 10, 2007 12:53:36 AM2007-02-11Sunday, February 11, 2007 12:18:03 AM2007-02-11Sunday, February 11, 2007 11:42:30 PM2007-02-12Monday, February 12, 2007 11:06:57 PM2007-02-13Tuesday, February 13, 2007 10:31:24 PM2007-02-14Wednesday, February 14, 2007 9:55:50 PM2007-02-15Thursday, February 15, 2007 9:20:17 PM2007-02-16Friday, February 16, 2007 8:44:44 PM2007-02-17Saturday, February 17, 2007 8:09:11 PM2007-02-18Sunday, February 18, 2007 7:33:38 PM2007-02-19Monday, February 19, 2007 6:58:05 PM2007-02-20Tuesday, February 20, 2007 6:22:32 PM2007-02-21Wednesday, February 21, 2007 5:46:59 PM2007-02-22Thursday, February 22, 2007 5:11:26 PM2007-02-23Friday, February 23, 2007 4:35:53 PM2007-02-24Saturday, February 24, 2007 4:00:20 PM2007-02-25Sunday, February 25, 2007 3:24:47 PM2007-02-26Monday, February 26, 2007 2:49:14 PM2007-02-27Tuesday, February 27, 2007 2:13:41 PM2007-02-28Wednesday, February 28, 2007 1:38:08 PM2007-03-01Thursday, March 01, 2007 1:02:35 PM2007-03-02Friday, March 02, 2007 12:27:02 PM2007-03-03Saturday, March 03, 2007 11:51:29 AM2007-03-04Sunday, March 04, 2007 11:15:56 AM2007-03-05Monday, March 05, 2007 10:40:23 AM2007-03-06Tuesday, March 06, 2007 10:04:50 AM2007-03-07Wednesday, March 07, 2007 9:29:17 AM2007-03-08Thursday, March 08, 2007 8:53:44 AM2007-03-09Friday, March 09, 2007 8:18:10 AM2007-03-10Saturday, March 10, 2007 7:42:37 AM2007-03-11Sunday, March 11, 2007 8:07:04 AM2007-03-12Monday, March 12, 2007 7:31:31 AM2007-03-13Tuesday, March 13, 2007 6:55:58 AM2007-03-14Wednesday, March 14, 2007 6:20:25 AM2007-03-15Thursday, March 15, 2007 5:44:52 AM2007-03-16Friday, March 16, 2007 5:09:19 AM2007-03-17Saturday, March 17, 2007 4:33:46 AM2007-03-18Sunday, March 18, 2007 3:58:13 AM2007-03-19Monday, March 19, 2007 3:22:40 AM2007-03-20Tuesday, March 20, 2007 2:47:07 AM2007-03-21Wednesday, March 21, 2007 2:11:34 AM2007-03-22Thursday, March 22, 2007 1:36:01 AM2007-03-23Friday, March 23, 2007 1:00:28 AM2007-03-24Saturday, March 24, 2007 12:24:55 AM2007-03-24Saturday, March 24, 2007 11:49:22 PM2007-03-25Sunday, March 25, 2007 11:13:49 PM2007-03-26Monday, March 26, 2007 10:38:16 PM2007-03-27Tuesday, March 27, 2007 10:02:43 PM2007-03-28Wednesday, March 28, 2007 9:27:10 PM2007-03-29Thursday, March 29, 2007 8:51:37 PM2007-03-30Friday, March 30, 2007 8:16:03 PM2007-03-31Saturday, March 31, 2007 7:40:30 PM2007-04-01Sunday, April 01, 2007 7:04:57 PM2007-04-02Monday, April 02, 2007 6:29:24 PM2007-04-03Tuesday, April 03, 2007 5:53:51 PM2007-04-04Wednesday, April 04, 2007 5:18:18 PM2007-04-05Thursday, April 05, 2007 4:42:45 PM2007-04-06Friday, April 06, 2007 4:07:12 PM2007-04-07Saturday, April 07, 2007 3:31:39 PM2007-04-08Sunday, April 08, 2007 2:56:06 PM2007-04-09Monday, April 09, 2007 2:20:33 PM2007-04-10Tuesday, April 10, 2007 1:45:00 PM2007-04-11Wednesday, April 11, 2007 1:09:27 PM2007-04-12Thursday, April 12, 2007 12:33:54 PM2007-04-13Friday, April 13, 2007 11:58:21 AM2007-04-14Saturday, April 14, 2007 11:22:48 AM2007-04-15Sunday, April 15, 2007 10:47:15 AM2007-04-16Monday, April 16, 2007 10:11:42 AM2007-04-17Tuesday, April 17, 2007 9:36:09 AM2007-04-18Wednesday, April 18, 2007 9:00:36 AM2007-04-19Thursday, April 19, 2007 8:25:03 AM2007-04-20Friday, April 20, 2007 7:49:30 AM2007-04-21Saturday, April 21, 2007 7:13:57 AM2007-04-22Sunday, April 22, 2007 6:38:23 AM2007-04-23Monday, April 23, 2007 6:02:50 AM2007-04-24Tuesday, April 24, 2007 5:27:17 AM2007-04-25Wednesday, April 25, 2007 4:51:44 AM2007-04-26Thursday, April 26, 2007 4:16:11 AM2007-04-27Friday, April 27, 2007 3:40:38 AM2007-04-28Saturday, April 28, 2007 3:05:05 AM2007-04-29Sunday, April 29, 2007 2:29:32 AM2007-04-30Monday, April 30, 2007 1:53:59 AM2007-05-01Tuesday, May 01, 2007 1:18:26 AM2007-05-02Wednesday, May 02, 2007 12:42:53 AM2007-05-03Thursday, May 03, 2007 12:07:20 AM2007-05-03Thursday, May 03, 2007 11:31:47 PM2007-05-04Friday, May 04, 2007 10:56:14 PM2007-05-05Saturday, May 05, 2007 10:20:41 PM2007-05-06Sunday, May 06, 2007 9:45:08 PM2007-05-07Monday, May 07, 2007 9:09:35 PM2007-05-08Tuesday, May 08, 2007 8:34:02 PM2007-05-09Wednesday, May 09, 2007 7:58:29 PM2007-05-10Thursday, May 10, 2007 7:22:56 PM2007-05-11Friday, May 11, 2007 6:47:23 PM2007-05-12Saturday, May 12, 2007 6:11:50 PM2007-05-13Sunday, May 13, 2007 5:36:17 PM2007-05-14Monday, May 14, 2007 5:00:43 PM2007-05-15Tuesday, May 15, 2007 4:25:10 PM2007-05-16Wednesday, May 16, 2007 3:49:37 PM2007-05-17Thursday, May 17, 2007 3:14:04 PM2007-05-18Friday, May 18, 2007 2:38:31 PM2007-05-19Saturday, May 19, 2007 2:02:58 PM2007-05-20Sunday, May 20, 2007 1:27:25 PM2007-05-21Monday, May 21, 2007 12:51:52 PM2007-05-22Tuesday, May 22, 2007 12:16:19 PM2007-05-23Wednesday, May 23, 2007 11:40:46 AM2007-05-24Thursday, May 24, 2007 11:05:13 AM2007-05-25Friday, May 25, 2007 10:29:40 AM2007-05-26Saturday, May 26, 2007 9:54:07 AM2007-05-27Sunday, May 27, 2007 9:18:34 AM2007-05-28Monday, May 28, 2007 8:43:01 AM2007-05-29Tuesday, May 29, 2007 8:07:28 AM2007-05-30Wednesday, May 30, 2007 7:31:55 AM2007-05-31Thursday, May 31, 2007 6:56:22 AM2007-06-01Friday, June 01, 2007 6:20:49 AM2007-06-02Saturday, June 02, 2007 5:45:16 AM2007-06-03Sunday, June 03, 2007 5:09:43 AM2007-06-04Monday, June 04, 2007 4:34:10 AM2007-06-05Tuesday, June 05, 2007 3:58:37 AM2007-06-06Wednesday, June 06, 2007 3:23:03 AM2007-06-07Thursday, June 07, 2007 2:47:30 AM2007-06-08Friday, June 08, 2007 2:11:57 AM2007-06-09Saturday, June 09, 2007 1:36:24 AM2007-06-10Sunday, June 10, 2007 1:00:51 AM2007-06-11Monday, June 11, 2007 12:25:18 AM2007-06-11Monday, June 11, 2007 11:49:45 PM2007-06-12Tuesday, June 12, 2007 11:14:12 PM2007-06-13Wednesday, June 13, 2007 10:38:39 PM2007-06-14Thursday, June 14, 2007 10:03:06 PM2007-06-15Friday, June 15, 2007 9:27:33 PM2007-06-16Saturday, June 16, 2007 8:52:00 PM2007-06-17Sunday, June 17, 2007 8:16:27 PM2007-06-18Monday, June 18, 2007 7:40:54 PM2007-06-19Tuesday, June 19, 2007 7:05:21 PM2007-06-20Wednesday, June 20, 2007 6:29:48 PM2007-06-21Thursday, June 21, 2007 5:54:15 PM2007-06-22Friday, June 22, 2007 5:18:42 PM2007-06-23Saturday, June 23, 2007 4:43:09 PM2007-06-24Sunday, June 24, 2007 4:07:36 PM2007-06-25Monday, June 25, 2007 3:32:03 PM2007-06-26Tuesday, June 26, 2007 2:56:30 PM2007-06-27Wednesday, June 27, 2007 2:20:56 PM2007-06-28Thursday, June 28, 2007 1:45:23 PM2007-06-29Friday, June 29, 2007 1:09:50 PM2007-06-30Saturday, June 30, 2007 12:34:17 PM2007-07-01Sunday, July 01, 2007 11:58:44 AM2007-07-02Monday, July 02, 2007 11:23:11 AM2007-07-03Tuesday, July 03, 2007 10:47:38 AM2007-07-04Wednesday, July 04, 2007 10:12:05 AM2007-07-05Thursday, July 05, 2007 9:36:32 AM2007-07-06Friday, July 06, 2007 9:00:59 AM2007-07-07Saturday, July 07, 2007 8:25:26 AM2007-07-08Sunday, July 08, 2007 7:49:53 AM2007-07-09Monday, July 09, 2007 7:14:20 AM2007-07-10Tuesday, July 10, 2007 6:38:47 AM2007-07-11Wednesday, July 11, 2007 6:03:14 AM2007-07-12Thursday, July 12, 2007 5:27:41 AM2007-07-13Friday, July 13, 2007 4:52:08 AM2007-07-14Saturday, July 14, 2007 4:16:35 AM2007-07-15Sunday, July 15, 2007 3:41:02 AM2007-07-16Monday, July 16, 2007 3:05:29 AM2007-07-17Tuesday, July 17, 2007 2:29:56 AM2007-07-18Wednesday, July 18, 2007 1:54:23 AM2007-07-19Thursday, July 19, 2007 1:18:50 AM2007-07-20Friday, July 20, 2007 12:43:16 AM2007-07-21Saturday, July 21, 2007 12:07:43 AM2007-07-21Saturday, July 21, 2007 11:32:10 PM2007-07-22Sunday, July 22, 2007 10:56:37 PM2007-07-23Monday, July 23, 2007 10:21:04 PM2007-07-24Tuesday, July 24, 2007 9:45:31 PM2007-07-25Wednesday, July 25, 2007 9:09:58 PM2007-07-26Thursday, July 26, 2007 8:34:25 PM2007-07-27Friday, July 27, 2007 7:58:52 PM2007-07-28Saturday, July 28, 2007 7:23:19 PM2007-07-29Sunday, July 29, 2007 6:47:46 PM2007-07-30Monday, July 30, 2007 6:12:13 PM2007-07-31Tuesday, July 31, 2007 5:36:40 PM2007-08-01Wednesday, August 01, 2007 5:01:07 PM2007-08-02Thursday, August 02, 2007 4:25:34 PM2007-08-03Friday, August 03, 2007 3:50:01 PM2007-08-04Saturday, August 04, 2007 3:14:28 PM2007-08-05Sunday, August 05, 2007 2:38:55 PM2007-08-06Monday, August 06, 2007 2:03:22 PM2007-08-07Tuesday, August 07, 2007 1:27:49 PM2007-08-08Wednesday, August 08, 2007 12:52:16 PM2007-08-09Thursday, August 09, 2007 12:16:43 PM2007-08-10Friday, August 10, 2007 11:41:10 AM2007-08-11Saturday, August 11, 2007 11:05:36 AM2007-08-12Sunday, August 12, 2007 10:30:03 AM2007-08-13Monday, August 13, 2007 9:54:30 AM2007-08-14Tuesday, August 14, 2007 9:18:57 AM2007-08-15Wednesday, August 15, 2007 8:43:24 AM2007-08-16Thursday, August 16, 2007 8:07:51 AM2007-08-17Friday, August 17, 2007 7:32:18 AM2007-08-18Saturday, August 18, 2007 6:56:45 AM2007-08-19Sunday, August 19, 2007 6:21:12 AM2007-08-20Monday, August 20, 2007 5:45:39 AM2007-08-21Tuesday, August 21, 2007 5:10:06 AM2007-08-22Wednesday, August 22, 2007 4:34:33 AM2007-08-23Thursday, August 23, 2007 3:59:00 AM2007-08-24Friday, August 24, 2007 3:23:27 AM2007-08-25Saturday, August 25, 2007 2:47:54 AM2007-08-26Sunday, August 26, 2007 2:12:21 AM2007-08-27Monday, August 27, 2007 1:36:48 AM2007-08-28Tuesday, August 28, 2007 1:01:15 AM2007-08-29Wednesday, August 29, 2007 12:25:42 AM2007-08-29Wednesday, August 29, 2007 11:50:09 PM2007-08-30Thursday, August 30, 2007 11:14:36 PM2007-08-31Friday, August 31, 2007 10:39:03 PM2007-09-01Saturday, September 01, 2007 10:03:30 PM2007-09-02Sunday, September 02, 2007 9:27:56 PM2007-09-03Monday, September 03, 2007 8:52:23 PM2007-09-04Tuesday, September 04, 2007 8:16:50 PM2007-09-05Wednesday, September 05, 2007 7:41:17 PM2007-09-06Thursday, September 06, 2007 7:05:44 PM2007-09-07Friday, September 07, 2007 6:30:11 PM2007-09-08Saturday, September 08, 2007 5:54:38 PM2007-09-09Sunday, September 09, 2007 5:19:05 PM2007-09-10Monday, September 10, 2007 4:43:32 PM2007-09-11Tuesday, September 11, 2007 4:07:59 PM2007-09-12Wednesday, September 12, 2007 3:32:26 PM2007-09-13Thursday, September 13, 2007 2:56:53 PM2007-09-14Friday, September 14, 2007 2:21:20 PM2007-09-15Saturday, September 15, 2007 1:45:47 PM2007-09-16Sunday, September 16, 2007 1:10:14 PM2007-09-17Monday, September 17, 2007 12:34:41 PM2007-09-18Tuesday, September 18, 2007 11:59:08 AM2007-09-19Wednesday, September 19, 2007 11:23:35 AM2007-09-20Thursday, September 20, 2007 10:48:02 AM2007-09-21Friday, September 21, 2007 10:12:29 AM2007-09-22Saturday, September 22, 2007 9:36:56 AM2007-09-23Sunday, September 23, 2007 9:01:23 AM2007-09-24Monday, September 24, 2007 8:25:49 AM2007-09-25Tuesday, September 25, 2007 7:50:16 AM2007-09-26Wednesday, September 26, 2007 7:14:43 AM2007-09-27Thursday, September 27, 2007 6:39:10 AM2007-09-28Friday, September 28, 2007 6:03:37 AM2007-09-29Saturday, September 29, 2007 5:28:04 AM2007-09-30Sunday, September 30, 2007 4:52:31 AM2007-10-01Monday, October 01, 2007 4:16:58 AM2007-10-02Tuesday, October 02, 2007 3:41:25 AM2007-10-03Wednesday, October 03, 2007 3:05:52 AM2007-10-04Thursday, October 04, 2007 2:30:19 AM2007-10-05Friday, October 05, 2007 1:54:46 AM2007-10-06Saturday, October 06, 2007 1:19:13 AM2007-10-07Sunday, October 07, 2007 12:43:40 AM2007-10-08Monday, October 08, 2007 12:08:07 AM2007-10-08Monday, October 08, 2007 11:32:34 PM2007-10-09Tuesday, October 09, 2007 10:57:01 PM2007-10-10Wednesday, October 10, 2007 10:21:28 PM2007-10-11Thursday, October 11, 2007 9:45:55 PM2007-10-12Friday, October 12, 2007 9:10:22 PM2007-10-13Saturday, October 13, 2007 8:34:49 PM2007-10-14Sunday, October 14, 2007 7:59:16 PM2007-10-15Monday, October 15, 2007 7:23:43 PM2007-10-16Tuesday, October 16, 2007 6:48:09 PM2007-10-17Wednesday, October 17, 2007 6:12:36 PM2007-10-18Thursday, October 18, 2007 5:37:03 PM2007-10-19Friday, October 19, 2007 5:01:30 PM2007-10-20Saturday, October 20, 2007 4:25:57 PM2007-10-21Sunday, October 21, 2007 3:50:24 PM2007-10-22Monday, October 22, 2007 3:14:51 PM2007-10-23Tuesday, October 23, 2007 2:39:18 PM2007-10-24Wednesday, October 24, 2007 2:03:45 PM2007-10-25Thursday, October 25, 2007 1:28:12 PM2007-10-26Friday, October 26, 2007 12:52:39 PM2007-10-27Saturday, October 27, 2007 12:17:06 PM2007-10-28Sunday, October 28, 2007 11:41:33 AM2007-10-29Monday, October 29, 2007 11:06:00 AM2007-10-30Tuesday, October 30, 2007 10:30:27 AM2007-10-31Wednesday, October 31, 2007 9:54:54 AM2007-11-01Thursday, November 01, 2007 9:19:21 AM2007-11-02Friday, November 02, 2007 8:43:48 AM2007-11-03Saturday, November 03, 2007 8:08:15 AM2007-11-04Sunday, November 04, 2007 6:32:42 AM2007-11-05Monday, November 05, 2007 5:57:09 AM2007-11-06Tuesday, November 06, 2007 5:21:36 AM2007-11-07Wednesday, November 07, 2007 4:46:03 AM2007-11-08Thursday, November 08, 2007 4:10:29 AM2007-11-09Friday, November 09, 2007 3:34:56 AM2007-11-10Saturday, November 10, 2007 2:59:23 AM2007-11-11Sunday, November 11, 2007 2:23:50 AM2007-11-12Monday, November 12, 2007 1:48:17 AM2007-11-13Tuesday, November 13, 2007 1:12:44 AM2007-11-14Wednesday, November 14, 2007 12:37:11 AM2007-11-15Thursday, November 15, 2007 12:01:38 AM2007-11-15Thursday, November 15, 2007 11:26:05 PM2007-11-16Friday, November 16, 2007 10:50:32 PM2007-11-17Saturday, November 17, 2007 10:14:59 PM2007-11-18Sunday, November 18, 2007 9:39:26 PM2007-11-19Monday, November 19, 2007 9:03:53 PM2007-11-20Tuesday, November 20, 2007 8:28:20 PM2007-11-21Wednesday, November 21, 2007 7:52:47 PM2007-11-22Thursday, November 22, 2007 7:17:14 PM2007-11-23Friday, November 23, 2007 6:41:41 PM2007-11-24Saturday, November 24, 2007 6:06:08 PM2007-11-25Sunday, November 25, 2007 5:30:35 PM2007-11-26Monday, November 26, 2007 4:55:02 PM2007-11-27Tuesday, November 27, 2007 4:19:29 PM2007-11-28Wednesday, November 28, 2007 3:43:56 PM2007-11-29Thursday, November 29, 2007 3:08:22 PM2007-11-30Friday, November 30, 2007 2:32:49 PM2007-12-01Saturday, December 01, 2007 1:57:16 PM2007-12-02Sunday, December 02, 2007 1:21:43 PM2007-12-03Monday, December 03, 2007 12:46:10 PM2007-12-04Tuesday, December 04, 2007 12:10:37 PM2007-12-05Wednesday, December 05, 2007 11:35:04 AM2007-12-06Thursday, December 06, 2007 10:59:31 AM2007-12-07Friday, December 07, 2007 10:23:58 AM2007-12-08Saturday, December 08, 2007 9:48:25 AM2007-12-09Sunday, December 09, 2007 9:12:52 AM2007-12-10Monday, December 10, 2007 8:37:19 AM2007-12-11Tuesday, December 11, 2007 8:01:46 AM2007-12-12Wednesday, December 12, 2007 7:26:13 AM2007-12-13Thursday, December 13, 2007 6:50:40 AM2007-12-14Friday, December 14, 2007 6:15:07 AM2007-12-15Saturday, December 15, 2007 5:39:34 AM2007-12-16Sunday, December 16, 2007 5:04:01 AM2007-12-17Monday, December 17, 2007 4:28:28 AM2007-12-18Tuesday, December 18, 2007 3:52:55 AM2007-12-19Wednesday, December 19, 2007 3:17:22 AM2007-12-20Thursday, December 20, 2007 2:41:49 AM2007-12-21Friday, December 21, 2007 2:06:16 AM2007-12-22Saturday, December 22, 2007 1:30:42 AM2007-12-23Sunday, December 23, 2007 12:55:09 AM2007-12-24Monday, December 24, 2007 12:19:36 AM2007-12-24Monday, December 24, 2007 11:44:03 PM2007-12-25Tuesday, December 25, 2007 11:08:30 PM2007-12-26Wednesday, December 26, 2007 10:32:57 PM2007-12-27Thursday, December 27, 2007 9:57:24 PM2007-12-28Friday, December 28, 2007 9:21:51 PM2007-12-29Saturday, December 29, 2007 8:46:18 PM2007-12-30Sunday, December 30, 2007 8:10:45 PM2007-12-31Monday, December 31, 2007 7:35:12 PM2008-01-01Tuesday, January 01, 2008 6:59:39 PM2008-01-02Wednesday, January 02, 2008 6:24:06 PM2008-01-03Thursday, January 03, 2008 5:48:33 PM2008-01-04Friday, January 04, 2008 5:13:00 PM2008-01-05Saturday, January 05, 2008 4:37:27 PM2008-01-06Sunday, January 06, 2008 4:01:54 PM2008-01-07Monday, January 07, 2008 3:26:21 PM2008-01-08Tuesday, January 08, 2008 2:50:48 PM2008-01-09Wednesday, January 09, 2008 2:15:15 PM2008-01-10Thursday, January 10, 2008 1:39:42 PM2008-01-11Friday, January 11, 2008 1:04:09 PM2008-01-12Saturday, January 12, 2008 12:28:36 PM2008-01-13Sunday, January 13, 2008 11:53:02 AM2008-01-14Monday, January 14, 2008 11:17:29 AM2008-01-15Tuesday, January 15, 2008 10:41:56 AM2008-01-16Wednesday, January 16, 2008 10:06:23 AM2008-01-17Thursday, January 17, 2008 9:30:50 AM2008-01-18Friday, January 18, 2008 8:55:17 AM2008-01-19Saturday, January 19, 2008 8:19:44 AM2008-01-20Sunday, January 20, 2008 7:44:11 AM2008-01-21Monday, January 21, 2008 7:08:38 AM2008-01-22Tuesday, January 22, 2008 6:33:05 AM2008-01-23Wednesday, January 23, 2008 5:57:32 AM2008-01-24Thursday, January 24, 2008 5:21:59 AM2008-01-25Friday, January 25, 2008 4:46:26 AM2008-01-26Saturday, January 26, 2008 4:10:53 AM2008-01-27Sunday, January 27, 2008 3:35:20 AM2008-01-28Monday, January 28, 2008 2:59:47 AM2008-01-29Tuesday, January 29, 2008 2:24:14 AM2008-01-30Wednesday, January 30, 2008 1:48:41 AM2008-01-31Thursday, January 31, 2008 1:13:08 AM2008-02-01Friday, February 01, 2008 12:37:35 AM2008-02-02Saturday, February 02, 2008 12:02:02 AM2008-02-02Saturday, February 02, 2008 11:26:29 PM2008-02-03Sunday, February 03, 2008 10:50:56 PM2008-02-04Monday, February 04, 2008 10:15:22 PM2008-02-05Tuesday, February 05, 2008 9:39:49 PM2008-02-06Wednesday, February 06, 2008 9:04:16 PM2008-02-07Thursday, February 07, 2008 8:28:43 PM2008-02-08Friday, February 08, 2008 7:53:10 PM2008-02-09Saturday, February 09, 2008 7:17:37 PM2008-02-10Sunday, February 10, 2008 6:42:04 PM2008-02-11Monday, February 11, 2008 6:06:31 PM2008-02-12Tuesday, February 12, 2008 5:30:58 PM2008-02-13Wednesday, February 13, 2008 4:55:25 PM2008-02-14Thursday, February 14, 2008 4:19:52 PM2008-02-15Friday, February 15, 2008 3:44:19 PM2008-02-16Saturday, February 16, 2008 3:08:46 PM2008-02-17Sunday, February 17, 2008 2:33:13 PM2008-02-18Monday, February 18, 2008 1:57:40 PM2008-02-19Tuesday, February 19, 2008 1:22:07 PM2008-02-20Wednesday, February 20, 2008 12:46:34 PM2008-02-21Thursday, February 21, 2008 12:11:01 PM2008-02-22Friday, February 22, 2008 11:35:28 AM2008-02-23Saturday, February 23, 2008 10:59:55 AM2008-02-24Sunday, February 24, 2008 10:24:22 AM2008-02-25Monday, February 25, 2008 9:48:49 AM2008-02-26Tuesday, February 26, 2008 9:13:15 AM2008-02-27Wednesday, February 27, 2008 8:37:42 AM2008-02-28Thursday, February 28, 2008 8:02:09 AM2008-02-29Friday, February 29, 2008 7:26:36 AM2008-03-01Saturday, March 01, 2008 6:51:03 AM2008-03-02Sunday, March 02, 2008 6:15:30 AM2008-03-03Monday, March 03, 2008 5:39:57 AM2008-03-04Tuesday, March 04, 2008 5:04:24 AM2008-03-05Wednesday, March 05, 2008 4:28:51 AM2008-03-06Thursday, March 06, 2008 3:53:18 AM2008-03-07Friday, March 07, 2008 3:17:45 AM2008-03-08Saturday, March 08, 2008 2:42:12 AM2008-03-09Sunday, March 09, 2008 3:06:39 AM2008-03-10Monday, March 10, 2008 2:31:06 AM2008-03-11Tuesday, March 11, 2008 1:55:33 AM2008-03-12Wednesday, March 12, 2008 1:20:00 AM2008-03-13Thursday, March 13, 2008 12:44:27 AM2008-03-14Friday, March 14, 2008 12:08:54 AM2008-03-14Friday, March 14, 2008 11:33:21 PM2008-03-15Saturday, March 15, 2008 10:57:48 PM2008-03-16Sunday, March 16, 2008 10:22:15 PM2008-03-17Monday, March 17, 2008 9:46:42 PM2008-03-18Tuesday, March 18, 2008 9:11:09 PM2008-03-19Wednesday, March 19, 2008 8:35:35 PM2008-03-20Thursday, March 20, 2008 8:00:02 PM2008-03-21Friday, March 21, 2008 7:24:29 PM2008-03-22Saturday, March 22, 2008 6:48:56 PM2008-03-23Sunday, March 23, 2008 6:13:23 PM2008-03-24Monday, March 24, 2008 5:37:50 PM2008-03-25Tuesday, March 25, 2008 5:02:17 PM2008-03-26Wednesday, March 26, 2008 4:26:44 PM2008-03-27Thursday, March 27, 2008 3:51:11 PM2008-03-28Friday, March 28, 2008 3:15:38 PM2008-03-29Saturday, March 29, 2008 2:40:05 PM2008-03-30Sunday, March 30, 2008 2:04:32 PM2008-03-31Monday, March 31, 2008 1:28:59 PM2008-04-01Tuesday, April 01, 2008 12:53:26 PM2008-04-02Wednesday, April 02, 2008 12:17:53 PM2008-04-03Thursday, April 03, 2008 11:42:20 AM2008-04-04Friday, April 04, 2008 11:06:47 AM2008-04-05Saturday, April 05, 2008 10:31:14 AM2008-04-06Sunday, April 06, 2008 9:55:41 AM2008-04-07Monday, April 07, 2008 9:20:08 AM2008-04-08Tuesday, April 08, 2008 8:44:35 AM2008-04-09Wednesday, April 09, 2008 8:09:02 AM2008-04-10Thursday, April 10, 2008 7:33:29 AM2008-04-11Friday, April 11, 2008 6:57:55 AM2008-04-12Saturday, April 12, 2008 6:22:22 AM2008-04-13Sunday, April 13, 2008 5:46:49 AM2008-04-14Monday, April 14, 2008 5:11:16 AM2008-04-15Tuesday, April 15, 2008 4:35:43 AM2008-04-16Wednesday, April 16, 2008 4:00:10 AM2008-04-17Thursday, April 17, 2008 3:24:37 AM2008-04-18Friday, April 18, 2008 2:49:04 AM2008-04-19Saturday, April 19, 2008 2:13:31 AM2008-04-20Sunday, April 20, 2008 1:37:58 AM2008-04-21Monday, April 21, 2008 1:02:25 AM2008-04-22Tuesday, April 22, 2008 12:26:52 AM2008-04-22Tuesday, April 22, 2008 11:51:19 PM2008-04-23Wednesday, April 23, 2008 11:15:46 PM2008-04-24Thursday, April 24, 2008 10:40:13 PM2008-04-25Friday, April 25, 2008 10:04:40 PM2008-04-26Saturday, April 26, 2008 9:29:07 PM2008-04-27Sunday, April 27, 2008 8:53:34 PM2008-04-28Monday, April 28, 2008 8:18:01 PM2008-04-29Tuesday, April 29, 2008 7:42:28 PM2008-04-30Wednesday, April 30, 2008 7:06:55 PM2008-05-01Thursday, May 01, 2008 6:31:22 PM2008-05-02Friday, May 02, 2008 5:55:49 PM2008-05-03Saturday, May 03, 2008 5:20:15 PM2008-05-04Sunday, May 04, 2008 4:44:42 PM2008-05-05Monday, May 05, 2008 4:09:09 PM2008-05-06Tuesday, May 06, 2008 3:33:36 PM2008-05-07Wednesday, May 07, 2008 2:58:03 PM2008-05-08Thursday, May 08, 2008 2:22:30 PM2008-05-09Friday, May 09, 2008 1:46:57 PM2008-05-10Saturday, May 10, 2008 1:11:24 PM2008-05-11Sunday, May 11, 2008 12:35:51 PM2008-05-12Monday, May 12, 2008 12:00:18 PM2008-05-13Tuesday, May 13, 2008 11:24:45 AM2008-05-14Wednesday, May 14, 2008 10:49:12 AM2008-05-15Thursday, May 15, 2008 10:13:39 AM2008-05-16Friday, May 16, 2008 9:38:06 AM2008-05-17Saturday, May 17, 2008 9:02:33 AM2008-05-18Sunday, May 18, 2008 8:27:00 AM2008-05-19Monday, May 19, 2008 7:51:27 AM2008-05-20Tuesday, May 20, 2008 7:15:54 AM2008-05-21Wednesday, May 21, 2008 6:40:21 AM2008-05-22Thursday, May 22, 2008 6:04:48 AM2008-05-23Friday, May 23, 2008 5:29:15 AM2008-05-24Saturday, May 24, 2008 4:53:42 AM2008-05-25Sunday, May 25, 2008 4:18:08 AM2008-05-26Monday, May 26, 2008 3:42:35 AM2008-05-27Tuesday, May 27, 2008 3:07:02 AM2008-05-28Wednesday, May 28, 2008 2:31:29 AM2008-05-29Thursday, May 29, 2008 1:55:56 AM2008-05-30Friday, May 30, 2008 1:20:23 AM2008-05-31Saturday, May 31, 2008 12:44:50 AM2008-06-01Sunday, June 01, 2008 12:09:17 AM2008-06-01Sunday, June 01, 2008 11:33:44 PM2008-06-02Monday, June 02, 2008 10:58:11 PM2008-06-03Tuesday, June 03, 2008 10:22:38 PM2008-06-04Wednesday, June 04, 2008 9:47:05 PM2008-06-05Thursday, June 05, 2008 9:11:32 PM2008-06-06Friday, June 06, 2008 8:35:59 PM2008-06-07Saturday, June 07, 2008 8:00:26 PM2008-06-08Sunday, June 08, 2008 7:24:53 PM2008-06-09Monday, June 09, 2008 6:49:20 PM2008-06-10Tuesday, June 10, 2008 6:13:47 PM2008-06-11Wednesday, June 11, 2008 5:38:14 PM2008-06-12Thursday, June 12, 2008 5:02:41 PM2008-06-13Friday, June 13, 2008 4:27:08 PM2008-06-14Saturday, June 14, 2008 3:51:35 PM2008-06-15Sunday, June 15, 2008 3:16:02 PM2008-06-16Monday, June 16, 2008 2:40:28 PM2008-06-17Tuesday, June 17, 2008 2:04:55 PM2008-06-18Wednesday, June 18, 2008 1:29:22 PM2008-06-19Thursday, June 19, 2008 12:53:49 PM2008-06-20Friday, June 20, 2008 12:18:16 PM2008-06-21Saturday, June 21, 2008 11:42:43 AM2008-06-22Sunday, June 22, 2008 11:07:10 AM2008-06-23Monday, June 23, 2008 10:31:37 AM2008-06-24Tuesday, June 24, 2008 9:56:04 AM2008-06-25Wednesday, June 25, 2008 9:20:31 AM2008-06-26Thursday, June 26, 2008 8:44:58 AM2008-06-27Friday, June 27, 2008 8:09:25 AM2008-06-28Saturday, June 28, 2008 7:33:52 AM2008-06-29Sunday, June 29, 2008 6:58:19 AM2008-06-30Monday, June 30, 2008 6:22:46 AM2008-07-01Tuesday, July 01, 2008 5:47:13 AM2008-07-02Wednesday, July 02, 2008 5:11:40 AM2008-07-03Thursday, July 03, 2008 4:36:07 AM2008-07-04Friday, July 04, 2008 4:00:34 AM2008-07-05Saturday, July 05, 2008 3:25:01 AM2008-07-06Sunday, July 06, 2008 2:49:28 AM2008-07-07Monday, July 07, 2008 2:13:55 AM2008-07-08Tuesday, July 08, 2008 1:38:22 AM2008-07-09Wednesday, July 09, 2008 1:02:48 AM2008-07-10Thursday, July 10, 2008 12:27:15 AM2008-07-10Thursday, July 10, 2008 11:51:42 PM2008-07-11Friday, July 11, 2008 11:16:09 PM2008-07-12Saturday, July 12, 2008 10:40:36 PM2008-07-13Sunday, July 13, 2008 10:05:03 PM2008-07-14Monday, July 14, 2008 9:29:30 PM2008-07-15Tuesday, July 15, 2008 8:53:57 PM2008-07-16Wednesday, July 16, 2008 8:18:24 PM2008-07-17Thursday, July 17, 2008 7:42:51 PM2008-07-18Friday, July 18, 2008 7:07:18 PM2008-07-19Saturday, July 19, 2008 6:31:45 PM2008-07-20Sunday, July 20, 2008 5:56:12 PM2008-07-21Monday, July 21, 2008 5:20:39 PM2008-07-22Tuesday, July 22, 2008 4:45:06 PM2008-07-23Wednesday, July 23, 2008 4:09:33 PM2008-07-24Thursday, July 24, 2008 3:34:00 PM2008-07-25Friday, July 25, 2008 2:58:27 PM2008-07-26Saturday, July 26, 2008 2:22:54 PM2008-07-27Sunday, July 27, 2008 1:47:21 PM2008-07-28Monday, July 28, 2008 1:11:48 PM2008-07-29Tuesday, July 29, 2008 12:36:15 PM2008-07-30Wednesday, July 30, 2008 12:00:41 PM2008-07-31Thursday, July 31, 2008 11:25:08 AM2008-08-01Friday, August 01, 2008 10:49:35 AM2008-08-02Saturday, August 02, 2008 10:14:02 AM2008-08-03Sunday, August 03, 2008 9:38:29 AM2008-08-04Monday, August 04, 2008 9:02:56 AM2008-08-05Tuesday, August 05, 2008 8:27:23 AM2008-08-06Wednesday, August 06, 2008 7:51:50 AM2008-08-07Thursday, August 07, 2008 7:16:17 AM2008-08-08Friday, August 08, 2008 6:40:44 AM2008-08-09Saturday, August 09, 2008 6:05:11 AM2008-08-10Sunday, August 10, 2008 5:29:38 AM2008-08-11Monday, August 11, 2008 4:54:05 AM2008-08-12Tuesday, August 12, 2008 4:18:32 AM2008-08-13Wednesday, August 13, 2008 3:42:59 AM2008-08-14Thursday, August 14, 2008 3:07:26 AM2008-08-15Friday, August 15, 2008 2:31:53 AM2008-08-16Saturday, August 16, 2008 1:56:20 AM2008-08-17Sunday, August 17, 2008 1:20:47 AM2008-08-18Monday, August 18, 2008 12:45:14 AM2008-08-19Tuesday, August 19, 2008 12:09:41 AM2008-08-19Tuesday, August 19, 2008 11:34:08 PM2008-08-20Wednesday, August 20, 2008 10:58:35 PM2008-08-21Thursday, August 21, 2008 10:23:01 PM2008-08-22Friday, August 22, 2008 9:47:28 PM2008-08-23Saturday, August 23, 2008 9:11:55 PM2008-08-24Sunday, August 24, 2008 8:36:22 PM2008-08-25Monday, August 25, 2008 8:00:49 PM2008-08-26Tuesday, August 26, 2008 7:25:16 PM2008-08-27Wednesday, August 27, 2008 6:49:43 PM2008-08-28Thursday, August 28, 2008 6:14:10 PM2008-08-29Friday, August 29, 2008 5:38:37 PM2008-08-30Saturday, August 30, 2008 5:03:04 PM2008-08-31Sunday, August 31, 2008 4:27:31 PM2008-09-01Monday, September 01, 2008 3:51:58 PM2008-09-02Tuesday, September 02, 2008 3:16:25 PM2008-09-03Wednesday, September 03, 2008 2:40:52 PM2008-09-04Thursday, September 04, 2008 2:05:19 PM2008-09-05Friday, September 05, 2008 1:29:46 PM2008-09-06Saturday, September 06, 2008 12:54:13 PM2008-09-07Sunday, September 07, 2008 12:18:40 PM2008-09-08Monday, September 08, 2008 11:43:07 AM2008-09-09Tuesday, September 09, 2008 11:07:34 AM2008-09-10Wednesday, September 10, 2008 10:32:01 AM2008-09-11Thursday, September 11, 2008 9:56:28 AM2008-09-12Friday, September 12, 2008 9:20:55 AM2008-09-13Saturday, September 13, 2008 8:45:21 AM2008-09-14Sunday, September 14, 2008 8:09:48 AM2008-09-15Monday, September 15, 2008 7:34:15 AM2008-09-16Tuesday, September 16, 2008 6:58:42 AM2008-09-17Wednesday, September 17, 2008 6:23:09 AM2008-09-18Thursday, September 18, 2008 5:47:36 AM2008-09-19Friday, September 19, 2008 5:12:03 AM2008-09-20Saturday, September 20, 2008 4:36:30 AM2008-09-21Sunday, September 21, 2008 4:00:57 AM2008-09-22Monday, September 22, 2008 3:25:24 AM2008-09-23Tuesday, September 23, 2008 2:49:51 AM2008-09-24Wednesday, September 24, 2008 2:14:18 AM2008-09-25Thursday, September 25, 2008 1:38:45 AM2008-09-26Friday, September 26, 2008 1:03:12 AM2008-09-27Saturday, September 27, 2008 12:27:39 AM2008-09-27Saturday, September 27, 2008 11:52:06 PM2008-09-28Sunday, September 28, 2008 11:16:33 PM2008-09-29Monday, September 29, 2008 10:41:00 PM2008-09-30Tuesday, September 30, 2008 10:05:27 PM2008-10-01Wednesday, October 01, 2008 9:29:54 PM2008-10-02Thursday, October 02, 2008 8:54:21 PM2008-10-03Friday, October 03, 2008 8:18:48 PM2008-10-04Saturday, October 04, 2008 7:43:15 PM2008-10-05Sunday, October 05, 2008 7:07:41 PM2008-10-06Monday, October 06, 2008 6:32:08 PM2008-10-07Tuesday, October 07, 2008 5:56:35 PM2008-10-08Wednesday, October 08, 2008 5:21:02 PM2008-10-09Thursday, October 09, 2008 4:45:29 PM2008-10-10Friday, October 10, 2008 4:09:56 PM2008-10-11Saturday, October 11, 2008 3:34:23 PM2008-10-12Sunday, October 12, 2008 2:58:50 PM2008-10-13Monday, October 13, 2008 2:23:17 PM2008-10-14Tuesday, October 14, 2008 1:47:44 PM2008-10-15Wednesday, October 15, 2008 1:12:11 PM2008-10-16Thursday, October 16, 2008 12:36:38 PM2008-10-17Friday, October 17, 2008 12:01:05 PM2008-10-18Saturday, October 18, 2008 11:25:32 AM2008-10-19Sunday, October 19, 2008 10:49:59 AM2008-10-20Monday, October 20, 2008 10:14:26 AM2008-10-21Tuesday, October 21, 2008 9:38:53 AM2008-10-22Wednesday, October 22, 2008 9:03:20 AM2008-10-23Thursday, October 23, 2008 8:27:47 AM2008-10-24Friday, October 24, 2008 7:52:14 AM2008-10-25Saturday, October 25, 2008 7:16:41 AM2008-10-26Sunday, October 26, 2008 6:41:08 AM2008-10-27Monday, October 27, 2008 6:05:34 AM2008-10-28Tuesday, October 28, 2008 5:30:01 AM2008-10-29Wednesday, October 29, 2008 4:54:28 AM2008-10-30Thursday, October 30, 2008 4:18:55 AM2008-10-31Friday, October 31, 2008 3:43:22 AM2008-11-01Saturday, November 01, 2008 3:07:49 AM2008-11-02Sunday, November 02, 2008 1:32:16 AM2008-11-03Monday, November 03, 2008 12:56:43 AM2008-11-04Tuesday, November 04, 2008 12:21:10 AM2008-11-04Tuesday, November 04, 2008 11:45:37 PM2008-11-05Wednesday, November 05, 2008 11:10:04 PM2008-11-06Thursday, November 06, 2008 10:34:31 PM2008-11-07Friday, November 07, 2008 9:58:58 PM2008-11-08Saturday, November 08, 2008 9:23:25 PM2008-11-09Sunday, November 09, 2008 8:47:52 PM2008-11-10Monday, November 10, 2008 8:12:19 PM2008-11-11Tuesday, November 11, 2008 7:36:46 PM2008-11-12Wednesday, November 12, 2008 7:01:13 PM2008-11-13Thursday, November 13, 2008 6:25:40 PM2008-11-14Friday, November 14, 2008 5:50:07 PM2008-11-15Saturday, November 15, 2008 5:14:34 PM2008-11-16Sunday, November 16, 2008 4:39:01 PM2008-11-17Monday, November 17, 2008 4:03:28 PM2008-11-18Tuesday, November 18, 2008 3:27:54 PM2008-11-19Wednesday, November 19, 2008 2:52:21 PM2008-11-20Thursday, November 20, 2008 2:16:48 PM2008-11-21Friday, November 21, 2008 1:41:15 PM2008-11-22Saturday, November 22, 2008 1:05:42 PM2008-11-23Sunday, November 23, 2008 12:30:09 PM2008-11-24Monday, November 24, 2008 11:54:36 AM2008-11-25Tuesday, November 25, 2008 11:19:03 AM2008-11-26Wednesday, November 26, 2008 10:43:30 AM2008-11-27Thursday, November 27, 2008 10:07:57 AM2008-11-28Friday, November 28, 2008 9:32:24 AM2008-11-29Saturday, November 29, 2008 8:56:51 AM2008-11-30Sunday, November 30, 2008 8:21:18 AM2008-12-01Monday, December 01, 2008 7:45:45 AM2008-12-02Tuesday, December 02, 2008 7:10:12 AM2008-12-03Wednesday, December 03, 2008 6:34:39 AM2008-12-04Thursday, December 04, 2008 5:59:06 AM2008-12-05Friday, December 05, 2008 5:23:33 AM2008-12-06Saturday, December 06, 2008 4:48:00 AM2008-12-07Sunday, December 07, 2008 4:12:27 AM2008-12-08Monday, December 08, 2008 3:36:54 AM2008-12-09Tuesday, December 09, 2008 3:01:21 AM2008-12-10Wednesday, December 10, 2008 2:25:48 AM2008-12-11Thursday, December 11, 2008 1:50:14 AM2008-12-12Friday, December 12, 2008 1:14:41 AM2008-12-13Saturday, December 13, 2008 12:39:08 AM2008-12-14Sunday, December 14, 2008 12:03:35 AM2008-12-14Sunday, December 14, 2008 11:28:02 PM2008-12-15Monday, December 15, 2008 10:52:29 PM2008-12-16Tuesday, December 16, 2008 10:16:56 PM2008-12-17Wednesday, December 17, 2008 9:41:23 PM2008-12-18Thursday, December 18, 2008 9:05:50 PM2008-12-19Friday, December 19, 2008 8:30:17 PM2008-12-20Saturday, December 20, 2008 7:54:44 PM2008-12-21Sunday, December 21, 2008 7:19:11 PM2008-12-22Monday, December 22, 2008 6:43:38 PM2008-12-23Tuesday, December 23, 2008 6:08:05 PM2008-12-24Wednesday, December 24, 2008 5:32:32 PM2008-12-25Thursday, December 25, 2008 4:56:59 PM2008-12-26Friday, December 26, 2008 4:21:26 PM2008-12-27Saturday, December 27, 2008 3:45:53 PM2008-12-28Sunday, December 28, 2008 3:10:20 PM2008-12-29Monday, December 29, 2008 2:34:47 PM2008-12-30Tuesday, December 30, 2008 1:59:14 PM2008-12-31Wednesday, December 31, 2008 1:23:41 PM2009-01-01Thursday, January 01, 2009 12:48:08 PM2009-01-02Friday, January 02, 2009 12:12:34 PM2009-01-03Saturday, January 03, 2009 11:37:01 AM2009-01-04Sunday, January 04, 2009 11:01:28 AM2009-01-05Monday, January 05, 2009 10:25:55 AM2009-01-06Tuesday, January 06, 2009 9:50:22 AM2009-01-07Wednesday, January 07, 2009 9:14:49 AM2009-01-08Thursday, January 08, 2009 8:39:16 AM2009-01-09Friday, January 09, 2009 8:03:43 AM2009-01-10Saturday, January 10, 2009 7:28:10 AM2009-01-11Sunday, January 11, 2009 6:52:37 AM2009-01-12Monday, January 12, 2009 6:17:04 AM2009-01-13Tuesday, January 13, 2009 5:41:31 AM2009-01-14Wednesday, January 14, 2009 5:05:58 AM2009-01-15Thursday, January 15, 2009 4:30:25 AM2009-01-16Friday, January 16, 2009 3:54:52 AM2009-01-17Saturday, January 17, 2009 3:19:19 AM2009-01-18Sunday, January 18, 2009 2:43:46 AM2009-01-19Monday, January 19, 2009 2:08:13 AM2009-01-20Tuesday, January 20, 2009 1:32:40 AM2009-01-21Wednesday, January 21, 2009 12:57:07 AM2009-01-22Thursday, January 22, 2009 12:21:34 AM2009-01-22Thursday, January 22, 2009 11:46:01 PM2009-01-23Friday, January 23, 2009 11:10:27 PM2009-01-24Saturday, January 24, 2009 10:34:54 PM2009-01-25Sunday, January 25, 2009 9:59:21 PM2009-01-26Monday, January 26, 2009 9:23:48 PM2009-01-27Tuesday, January 27, 2009 8:48:15 PM2009-01-28Wednesday, January 28, 2009 8:12:42 PM2009-01-29Thursday, January 29, 2009 7:37:09 PM2009-01-30Friday, January 30, 2009 7:01:36 PM2009-01-31Saturday, January 31, 2009 6:26:03 PM2009-02-01Sunday, February 01, 2009 5:50:30 PM2009-02-02Monday, February 02, 2009 5:14:57 PM2009-02-03Tuesday, February 03, 2009 4:39:24 PM2009-02-04Wednesday, February 04, 2009 4:03:51 PM2009-02-05Thursday, February 05, 2009 3:28:18 PM2009-02-06Friday, February 06, 2009 2:52:45 PM2009-02-07Saturday, February 07, 2009 2:17:12 PM2009-02-08Sunday, February 08, 2009 1:41:39 PM2009-02-09Monday, February 09, 2009 1:06:06 PM2009-02-10Tuesday, February 10, 2009 12:30:33 PM2009-02-11Wednesday, February 11, 2009 11:55:00 AM2009-02-12Thursday, February 12, 2009 11:19:27 AM2009-02-13Friday, February 13, 2009 10:43:54 AM2009-02-14Saturday, February 14, 2009 10:08:21 AM2009-02-15Sunday, February 15, 2009 9:32:47 AM2009-02-16Monday, February 16, 2009 8:57:14 AM2009-02-17Tuesday, February 17, 2009 8:21:41 AM2009-02-18Wednesday, February 18, 2009 7:46:08 AM2009-02-19Thursday, February 19, 2009 7:10:35 AM2009-02-20Friday, February 20, 2009 6:35:02 AM2009-02-21Saturday, February 21, 2009 5:59:29 AM2009-02-22Sunday, February 22, 2009 5:23:56 AM2009-02-23Monday, February 23, 2009 4:48:23 AM2009-02-24Tuesday, February 24, 2009 4:12:50 AM2009-02-25Wednesday, February 25, 2009 3:37:17 AM2009-02-26Thursday, February 26, 2009 3:01:44 AM2009-02-27Friday, February 27, 2009 2:26:11 AM2009-02-28Saturday, February 28, 2009 1:50:38 AM2009-03-01Sunday, March 01, 2009 1:15:05 AM2009-03-02Monday, March 02, 2009 12:39:32 AM2009-03-03Tuesday, March 03, 2009 12:03:59 AM2009-03-03Tuesday, March 03, 2009 11:28:26 PM2009-03-04Wednesday, March 04, 2009 10:52:53 PM2009-03-05Thursday, March 05, 2009 10:17:20 PM2009-03-06Friday, March 06, 2009 9:41:47 PM2009-03-07Saturday, March 07, 2009 9:06:14 PM2009-03-08Sunday, March 08, 2009 9:30:41 PM2009-03-09Monday, March 09, 2009 8:55:07 PM2009-03-10Tuesday, March 10, 2009 8:19:34 PM2009-03-11Wednesday, March 11, 2009 7:44:01 PM2009-03-12Thursday, March 12, 2009 7:08:28 PM2009-03-13Friday, March 13, 2009 6:32:55 PM2009-03-14Saturday, March 14, 2009 5:57:22 PM2009-03-15Sunday, March 15, 2009 5:21:49 PM2009-03-16Monday, March 16, 2009 4:46:16 PM2009-03-17Tuesday, March 17, 2009 4:10:43 PM2009-03-18Wednesday, March 18, 2009 3:35:10 PM2009-03-19Thursday, March 19, 2009 2:59:37 PM2009-03-20Friday, March 20, 2009 2:24:04 PM2009-03-21Saturday, March 21, 2009 1:48:31 PM2009-03-22Sunday, March 22, 2009 1:12:58 PM2009-03-23Monday, March 23, 2009 12:37:25 PM2009-03-24Tuesday, March 24, 2009 12:01:52 PM2009-03-25Wednesday, March 25, 2009 11:26:19 AM2009-03-26Thursday, March 26, 2009 10:50:46 AM2009-03-27Friday, March 27, 2009 10:15:13 AM2009-03-28Saturday, March 28, 2009 9:39:40 AM2009-03-29Sunday, March 29, 2009 9:04:07 AM2009-03-30Monday, March 30, 2009 8:28:34 AM2009-03-31Tuesday, March 31, 2009 7:53:00 AM2009-04-01Wednesday, April 01, 2009 7:17:27 AM2009-04-02Thursday, April 02, 2009 6:41:54 AM2009-04-03Friday, April 03, 2009 6:06:21 AM2009-04-04Saturday, April 04, 2009 5:30:48 AM2009-04-05Sunday, April 05, 2009 4:55:15 AM2009-04-06Monday, April 06, 2009 4:19:42 AM2009-04-07Tuesday, April 07, 2009 3:44:09 AM2009-04-08Wednesday, April 08, 2009 3:08:36 AM2009-04-09Thursday, April 09, 2009 2:33:03 AM2009-04-10Friday, April 10, 2009 1:57:30 AM2009-04-11Saturday, April 11, 2009 1:21:57 AM2009-04-12Sunday, April 12, 2009 12:46:24 AM2009-04-13Monday, April 13, 2009 12:10:51 AM2009-04-13Monday, April 13, 2009 11:35:18 PM2009-04-14Tuesday, April 14, 2009 10:59:45 PM2009-04-15Wednesday, April 15, 2009 10:24:12 PM2009-04-16Thursday, April 16, 2009 9:48:39 PM2009-04-17Friday, April 17, 2009 9:13:06 PM2009-04-18Saturday, April 18, 2009 8:37:33 PM2009-04-19Sunday, April 19, 2009 8:02:00 PM2009-04-20Monday, April 20, 2009 7:26:27 PM2009-04-21Tuesday, April 21, 2009 6:50:54 PM2009-04-22Wednesday, April 22, 2009 6:15:20 PM2009-04-23Thursday, April 23, 2009 5:39:47 PM2009-04-24Friday, April 24, 2009 5:04:14 PM2009-04-25Saturday, April 25, 2009 4:28:41 PM2009-04-26Sunday, April 26, 2009 3:53:08 PM2009-04-27Monday, April 27, 2009 3:17:35 PM2009-04-28Tuesday, April 28, 2009 2:42:02 PM2009-04-29Wednesday, April 29, 2009 2:06:29 PM2009-04-30Thursday, April 30, 2009 1:30:56 PM2009-05-01Friday, May 01, 2009 12:55:23 PM2009-05-02Saturday, May 02, 2009 12:19:50 PM2009-05-03Sunday, May 03, 2009 11:44:17 AM2009-05-04Monday, May 04, 2009 11:08:44 AM2009-05-05Tuesday, May 05, 2009 10:33:11 AM2009-05-06Wednesday, May 06, 2009 9:57:38 AM2009-05-07Thursday, May 07, 2009 9:22:05 AM2009-05-08Friday, May 08, 2009 8:46:32 AM2009-05-09Saturday, May 09, 2009 8:10:59 AM2009-05-10Sunday, May 10, 2009 7:35:26 AM2009-05-11Monday, May 11, 2009 6:59:53 AM2009-05-12Tuesday, May 12, 2009 6:24:20 AM2009-05-13Wednesday, May 13, 2009 5:48:47 AM2009-05-14Thursday, May 14, 2009 5:13:14 AM2009-05-15Friday, May 15, 2009 4:37:40 AM2009-05-16Saturday, May 16, 2009 4:02:07 AM2009-05-17Sunday, May 17, 2009 3:26:34 AM2009-05-18Monday, May 18, 2009 2:51:01 AM2009-05-19Tuesday, May 19, 2009 2:15:28 AM2009-05-20Wednesday, May 20, 2009 1:39:55 AM2009-05-21Thursday, May 21, 2009 1:04:22 AM2009-05-22Friday, May 22, 2009 12:28:49 AM2009-05-22Friday, May 22, 2009 11:53:16 PM2009-05-23Saturday, May 23, 2009 11:17:43 PM2009-05-24Sunday, May 24, 2009 10:42:10 PM2009-05-25Monday, May 25, 2009 10:06:37 PM2009-05-26Tuesday, May 26, 2009 9:31:04 PM2009-05-27Wednesday, May 27, 2009 8:55:31 PM2009-05-28Thursday, May 28, 2009 8:19:58 PM2009-05-29Friday, May 29, 2009 7:44:25 PM2009-05-30Saturday, May 30, 2009 7:08:52 PM2009-05-31Sunday, May 31, 2009 6:33:19 PM2009-06-01Monday, June 01, 2009 5:57:46 PM2009-06-02Tuesday, June 02, 2009 5:22:13 PM2009-06-03Wednesday, June 03, 2009 4:46:40 PM2009-06-04Thursday, June 04, 2009 4:11:07 PM2009-06-05Friday, June 05, 2009 3:35:34 PM2009-06-06Saturday, June 06, 2009 3:00:00 PM2009-06-07Sunday, June 07, 2009 2:24:27 PM2009-06-08Monday, June 08, 2009 1:48:54 PM2009-06-09Tuesday, June 09, 2009 1:13:21 PM2009-06-10Wednesday, June 10, 2009 12:37:48 PM2009-06-11Thursday, June 11, 2009 12:02:15 PM2009-06-12Friday, June 12, 2009 11:26:42 AM2009-06-13Saturday, June 13, 2009 10:51:09 AM2009-06-14Sunday, June 14, 2009 10:15:36 AM2009-06-15Monday, June 15, 2009 9:40:03 AM2009-06-16Tuesday, June 16, 2009 9:04:30 AM2009-06-17Wednesday, June 17, 2009 8:28:57 AM2009-06-18Thursday, June 18, 2009 7:53:24 AM2009-06-19Friday, June 19, 2009 7:17:51 AM2009-06-20Saturday, June 20, 2009 6:42:18 AM2009-06-21Sunday, June 21, 2009 6:06:45 AM2009-06-22Monday, June 22, 2009 5:31:12 AM2009-06-23Tuesday, June 23, 2009 4:55:39 AM2009-06-24Wednesday, June 24, 2009 4:20:06 AM2009-06-25Thursday, June 25, 2009 3:44:33 AM2009-06-26Friday, June 26, 2009 3:09:00 AM2009-06-27Saturday, June 27, 2009 2:33:27 AM2009-06-28Sunday, June 28, 2009 1:57:53 AM2009-06-29Monday, June 29, 2009 1:22:20 AM2009-06-30Tuesday, June 30, 2009 12:46:47 AM2009-07-01Wednesday, July 01, 2009 12:11:14 AM2009-07-01Wednesday, July 01, 2009 11:35:41 PM2009-07-02Thursday, July 02, 2009 11:00:08 PM2009-07-03Friday, July 03, 2009 10:24:35 PM2009-07-04Saturday, July 04, 2009 9:49:02 PM2009-07-05Sunday, July 05, 2009 9:13:29 PM2009-07-06Monday, July 06, 2009 8:37:56 PM2009-07-07Tuesday, July 07, 2009 8:02:23 PM2009-07-08Wednesday, July 08, 2009 7:26:50 PM2009-07-09Thursday, July 09, 2009 6:51:17 PM2009-07-10Friday, July 10, 2009 6:15:44 PM2009-07-11Saturday, July 11, 2009 5:40:11 PM2009-07-12Sunday, July 12, 2009 5:04:38 PM2009-07-13Monday, July 13, 2009 4:29:05 PM2009-07-14Tuesday, July 14, 2009 3:53:32 PM2009-07-15Wednesday, July 15, 2009 3:17:59 PM2009-07-16Thursday, July 16, 2009 2:42:26 PM2009-07-17Friday, July 17, 2009 2:06:53 PM2009-07-18Saturday, July 18, 2009 1:31:20 PM2009-07-19Sunday, July 19, 2009 12:55:47 PM2009-07-20Monday, July 20, 2009 12:20:13 PM2009-07-21Tuesday, July 21, 2009 11:44:40 AM2009-07-22Wednesday, July 22, 2009 11:09:07 AM2009-07-23Thursday, July 23, 2009 10:33:34 AM2009-07-24Friday, July 24, 2009 9:58:01 AM2009-07-25Saturday, July 25, 2009 9:22:28 AM2009-07-26Sunday, July 26, 2009 8:46:55 AM2009-07-27Monday, July 27, 2009 8:11:22 AM2009-07-28Tuesday, July 28, 2009 7:35:49 AM2009-07-29Wednesday, July 29, 2009 7:00:16 AM2009-07-30Thursday, July 30, 2009 6:24:43 AM2009-07-31Friday, July 31, 2009 5:49:10 AM2009-08-01Saturday, August 01, 2009 5:13:37 AM2009-08-02Sunday, August 02, 2009 4:38:04 AM2009-08-03Monday, August 03, 2009 4:02:31 AM2009-08-04Tuesday, August 04, 2009 3:26:58 AM2009-08-05Wednesday, August 05, 2009 2:51:25 AM2009-08-06Thursday, August 06, 2009 2:15:52 AM2009-08-07Friday, August 07, 2009 1:40:19 AM2009-08-08Saturday, August 08, 2009 1:04:46 AM2009-08-09Sunday, August 09, 2009 12:29:13 AM2009-08-09Sunday, August 09, 2009 11:53:40 PM2009-08-10Monday, August 10, 2009 11:18:07 PM2009-08-11Tuesday, August 11, 2009 10:42:33 PM2009-08-12Wednesday, August 12, 2009 10:07:00 PM2009-08-13Thursday, August 13, 2009 9:31:27 PM2009-08-14Friday, August 14, 2009 8:55:54 PM2009-08-15Saturday, August 15, 2009 8:20:21 PM2009-08-16Sunday, August 16, 2009 7:44:48 PM2009-08-17Monday, August 17, 2009 7:09:15 PM2009-08-18Tuesday, August 18, 2009 6:33:42 PM2009-08-19Wednesday, August 19, 2009 5:58:09 PM2009-08-20Thursday, August 20, 2009 5:22:36 PM2009-08-21Friday, August 21, 2009 4:47:03 PM2009-08-22Saturday, August 22, 2009 4:11:30 PM2009-08-23Sunday, August 23, 2009 3:35:57 PM2009-08-24Monday, August 24, 2009 3:00:24 PM2009-08-25Tuesday, August 25, 2009 2:24:51 PM2009-08-26Wednesday, August 26, 2009 1:49:18 PM2009-08-27Thursday, August 27, 2009 1:13:45 PM2009-08-28Friday, August 28, 2009 12:38:12 PM2009-08-29Saturday, August 29, 2009 12:02:39 PM2009-08-30Sunday, August 30, 2009 11:27:06 AM2009-08-31Monday, August 31, 2009 10:51:33 AM2009-09-01Tuesday, September 01, 2009 10:16:00 AM2009-09-02Wednesday, September 02, 2009 9:40:27 AM2009-09-03Thursday, September 03, 2009 9:04:53 AM2009-09-04Friday, September 04, 2009 8:29:20 AM2009-09-05Saturday, September 05, 2009 7:53:47 AM2009-09-06Sunday, September 06, 2009 7:18:14 AM2009-09-07Monday, September 07, 2009 6:42:41 AM2009-09-08Tuesday, September 08, 2009 6:07:08 AM2009-09-09Wednesday, September 09, 2009 5:31:35 AM2009-09-10Thursday, September 10, 2009 4:56:02 AM2009-09-11Friday, September 11, 2009 4:20:29 AM2009-09-12Saturday, September 12, 2009 3:44:56 AM2009-09-13Sunday, September 13, 2009 3:09:23 AM2009-09-14Monday, September 14, 2009 2:33:50 AM2009-09-15Tuesday, September 15, 2009 1:58:17 AM2009-09-16Wednesday, September 16, 2009 1:22:44 AM2009-09-17Thursday, September 17, 2009 12:47:11 AM2009-09-18Friday, September 18, 2009 12:11:38 AM2009-09-18Friday, September 18, 2009 11:36:05 PM2009-09-19Saturday, September 19, 2009 11:00:32 PM2009-09-20Sunday, September 20, 2009 10:24:59 PM2009-09-21Monday, September 21, 2009 9:49:26 PM2009-09-22Tuesday, September 22, 2009 9:13:53 PM2009-09-23Wednesday, September 23, 2009 8:38:20 PM2009-09-24Thursday, September 24, 2009 8:02:46 PM2009-09-25Friday, September 25, 2009 7:27:13 PM2009-09-26Saturday, September 26, 2009 6:51:40 PM2009-09-27Sunday, September 27, 2009 6:16:07 PM2009-09-28Monday, September 28, 2009 5:40:34 PM2009-09-29Tuesday, September 29, 2009 5:05:01 PM2009-09-30Wednesday, September 30, 2009 4:29:28 PM2009-10-01Thursday, October 01, 2009 3:53:55 PM2009-10-02Friday, October 02, 2009 3:18:22 PM2009-10-03Saturday, October 03, 2009 2:42:49 PM2009-10-04Sunday, October 04, 2009 2:07:16 PM2009-10-05Monday, October 05, 2009 1:31:43 PM2009-10-06Tuesday, October 06, 2009 12:56:10 PM2009-10-07Wednesday, October 07, 2009 12:20:37 PM2009-10-08Thursday, October 08, 2009 11:45:04 AM2009-10-09Friday, October 09, 2009 11:09:31 AM2009-10-10Saturday, October 10, 2009 10:33:58 AM2009-10-11Sunday, October 11, 2009 9:58:25 AM2009-10-12Monday, October 12, 2009 9:22:52 AM2009-10-13Tuesday, October 13, 2009 8:47:19 AM2009-10-14Wednesday, October 14, 2009 8:11:46 AM2009-10-15Thursday, October 15, 2009 7:36:13 AM2009-10-16Friday, October 16, 2009 7:00:40 AM2009-10-17Saturday, October 17, 2009 6:25:06 AM2009-10-18Sunday, October 18, 2009 5:49:33 AM2009-10-19Monday, October 19, 2009 5:14:00 AM2009-10-20Tuesday, October 20, 2009 4:38:27 AM2009-10-21Wednesday, October 21, 2009 4:02:54 AM2009-10-22Thursday, October 22, 2009 3:27:21 AM2009-10-23Friday, October 23, 2009 2:51:48 AM2009-10-24Saturday, October 24, 2009 2:16:15 AM2009-10-25Sunday, October 25, 2009 1:40:42 AM2009-10-26Monday, October 26, 2009 1:05:09 AM2009-10-27Tuesday, October 27, 2009 12:29:36 AM2009-10-27Tuesday, October 27, 2009 11:54:03 PM2009-10-28Wednesday, October 28, 2009 11:18:30 PM2009-10-29Thursday, October 29, 2009 10:42:57 PM2009-10-30Friday, October 30, 2009 10:07:24 PM2009-10-31Saturday, October 31, 2009 9:31:51 PM2009-11-01Sunday, November 01, 2009 7:56:18 PM2009-11-02Monday, November 02, 2009 7:20:45 PM2009-11-03Tuesday, November 03, 2009 6:45:12 PM2009-11-04Wednesday, November 04, 2009 6:09:39 PM2009-11-05Thursday, November 05, 2009 5:34:06 PM2009-11-06Friday, November 06, 2009 4:58:33 PM2009-11-07Saturday, November 07, 2009 4:23:00 PM2009-11-08Sunday, November 08, 2009 3:47:26 PM2009-11-09Monday, November 09, 2009 3:11:53 PM2009-11-10Tuesday, November 10, 2009 2:36:20 PM2009-11-11Wednesday, November 11, 2009 2:00:47 PM2009-11-12Thursday, November 12, 2009 1:25:14 PM2009-11-13Friday, November 13, 2009 12:49:41 PM2009-11-14Saturday, November 14, 2009 12:14:08 PM2009-11-15Sunday, November 15, 2009 11:38:35 AM2009-11-16Monday, November 16, 2009 11:03:02 AM2009-11-17Tuesday, November 17, 2009 10:27:29 AM2009-11-18Wednesday, November 18, 2009 9:51:56 AM2009-11-19Thursday, November 19, 2009 9:16:23 AM2009-11-20Friday, November 20, 2009 8:40:50 AM2009-11-21Saturday, November 21, 2009 8:05:17 AM2009-11-22Sunday, November 22, 2009 7:29:44 AM2009-11-23Monday, November 23, 2009 6:54:11 AM2009-11-24Tuesday, November 24, 2009 6:18:38 AM2009-11-25Wednesday, November 25, 2009 5:43:05 AM2009-11-26Thursday, November 26, 2009 5:07:32 AM2009-11-27Friday, November 27, 2009 4:31:59 AM2009-11-28Saturday, November 28, 2009 3:56:26 AM2009-11-29Sunday, November 29, 2009 3:20:53 AM2009-11-30Monday, November 30, 2009 2:45:19 AM2009-12-01Tuesday, December 01, 2009 2:09:46 AM2009-12-02Wednesday, December 02, 2009 1:34:13 AM2009-12-03Thursday, December 03, 2009 12:58:40 AM2009-12-04Friday, December 04, 2009 12:23:07 AM2009-12-04Friday, December 04, 2009 11:47:34 PM2009-12-05Saturday, December 05, 2009 11:12:01 PM2009-12-06Sunday, December 06, 2009 10:36:28 PM2009-12-07Monday, December 07, 2009 10:00:55 PM2009-12-08Tuesday, December 08, 2009 9:25:22 PM2009-12-09Wednesday, December 09, 2009 8:49:49 PM2009-12-10Thursday, December 10, 2009 8:14:16 PM2009-12-11Friday, December 11, 2009 7:38:43 PM2009-12-12Saturday, December 12, 2009 7:03:10 PM2009-12-13Sunday, December 13, 2009 6:27:37 PM2009-12-14Monday, December 14, 2009 5:52:04 PM2009-12-15Tuesday, December 15, 2009 5:16:31 PM2009-12-16Wednesday, December 16, 2009 4:40:58 PM2009-12-17Thursday, December 17, 2009 4:05:25 PM2009-12-18Friday, December 18, 2009 3:29:52 PM2009-12-19Saturday, December 19, 2009 2:54:19 PM2009-12-20Sunday, December 20, 2009 2:18:46 PM2009-12-21Monday, December 21, 2009 1:43:13 PM2009-12-22Tuesday, December 22, 2009 1:07:39 PM2009-12-23Wednesday, December 23, 2009 12:32:06 PM2009-12-24Thursday, December 24, 2009 11:56:33 AM2009-12-25Friday, December 25, 2009 11:21:00 AM2009-12-26Saturday, December 26, 2009 10:45:27 AM2009-12-27Sunday, December 27, 2009 10:09:54 AM2009-12-28Monday, December 28, 2009 9:34:21 AM2009-12-29Tuesday, December 29, 2009 8:58:48 AM2009-12-30Wednesday, December 30, 2009 8:23:15 AM2009-12-31Thursday, December 31, 2009 7:47:42 AM2010-01-01Friday, January 01, 2010 7:12:09 AM2010-01-02Saturday, January 02, 2010 6:36:36 AM2010-01-03Sunday, January 03, 2010 6:01:03 AM2010-01-04Monday, January 04, 2010 5:25:30 AM2010-01-05Tuesday, January 05, 2010 4:49:57 AM2010-01-06Wednesday, January 06, 2010 4:14:24 AM2010-01-07Thursday, January 07, 2010 3:38:51 AM2010-01-08Friday, January 08, 2010 3:03:18 AM2010-01-09Saturday, January 09, 2010 2:27:45 AM2010-01-10Sunday, January 10, 2010 1:52:12 AM2010-01-11Monday, January 11, 2010 1:16:39 AM2010-01-12Tuesday, January 12, 2010 12:41:06 AM2010-01-13Wednesday, January 13, 2010 12:05:33 AM2010-01-13Wednesday, January 13, 2010 11:29:59 PM2010-01-14Thursday, January 14, 2010 10:54:26 PM2010-01-15Friday, January 15, 2010 10:18:53 PM2010-01-16Saturday, January 16, 2010 9:43:20 PM2010-01-17Sunday, January 17, 2010 9:07:47 PM2010-01-18Monday, January 18, 2010 8:32:14 PM2010-01-19Tuesday, January 19, 2010 7:56:41 PM2010-01-20Wednesday, January 20, 2010 7:21:08 PM2010-01-21Thursday, January 21, 2010 6:45:35 PM2010-01-22Friday, January 22, 2010 6:10:02 PM2010-01-23Saturday, January 23, 2010 5:34:29 PM2010-01-24Sunday, January 24, 2010 4:58:56 PM2010-01-25Monday, January 25, 2010 4:23:23 PM2010-01-26Tuesday, January 26, 2010 3:47:50 PM2010-01-27Wednesday, January 27, 2010 3:12:17 PM2010-01-28Thursday, January 28, 2010 2:36:44 PM2010-01-29Friday, January 29, 2010 2:01:11 PM2010-01-30Saturday, January 30, 2010 1:25:38 PM2010-01-31Sunday, January 31, 2010 12:50:05 PM2010-02-01Monday, February 01, 2010 12:14:32 PM2010-02-02Tuesday, February 02, 2010 11:38:59 AM2010-02-03Wednesday, February 03, 2010 11:03:26 AM2010-02-04Thursday, February 04, 2010 10:27:53 AM2010-02-05Friday, February 05, 2010 9:52:19 AM2010-02-06Saturday, February 06, 2010 9:16:46 AM2010-02-07Sunday, February 07, 2010 8:41:13 AM2010-02-08Monday, February 08, 2010 8:05:40 AM2010-02-09Tuesday, February 09, 2010 7:30:07 AM2010-02-10Wednesday, February 10, 2010 6:54:34 AM2010-02-11Thursday, February 11, 2010 6:19:01 AM2010-02-12Friday, February 12, 2010 5:43:28 AM2010-02-13Saturday, February 13, 2010 5:07:55 AM2010-02-14Sunday, February 14, 2010 4:32:22 AM2010-02-15Monday, February 15, 2010 3:56:49 AM2010-02-16Tuesday, February 16, 2010 3:21:16 AM2010-02-17Wednesday, February 17, 2010 2:45:43 AM2010-02-18Thursday, February 18, 2010 2:10:10 AM2010-02-19Friday, February 19, 2010 1:34:37 AM2010-02-20Saturday, February 20, 2010 12:59:04 AM2010-02-21Sunday, February 21, 2010 12:23:31 AM2010-02-21Sunday, February 21, 2010 11:47:58 PM2010-02-22Monday, February 22, 2010 11:12:25 PM2010-02-23Tuesday, February 23, 2010 10:36:52 PM2010-02-24Wednesday, February 24, 2010 10:01:19 PM2010-02-25Thursday, February 25, 2010 9:25:46 PM2010-02-26Friday, February 26, 2010 8:50:12 PM2010-02-27Saturday, February 27, 2010 8:14:39 PM2010-02-28Sunday, February 28, 2010 7:39:06 PM2010-03-01Monday, March 01, 2010 7:03:33 PM2010-03-02Tuesday, March 02, 2010 6:28:00 PM2010-03-03Wednesday, March 03, 2010 5:52:27 PM2010-03-04Thursday, March 04, 2010 5:16:54 PM2010-03-05Friday, March 05, 2010 4:41:21 PM2010-03-06Saturday, March 06, 2010 4:05:48 PM2010-03-07Sunday, March 07, 2010 3:30:15 PM2010-03-08Monday, March 08, 2010 2:54:42 PM2010-03-09Tuesday, March 09, 2010 2:19:09 PM2010-03-10Wednesday, March 10, 2010 1:43:36 PM2010-03-11Thursday, March 11, 2010 1:08:03 PM2010-03-12Friday, March 12, 2010 12:32:30 PM2010-03-13Saturday, March 13, 2010 11:56:57 AM2010-03-14Sunday, March 14, 2010 12:21:24 PM2010-03-15Monday, March 15, 2010 11:45:51 AM2010-03-16Tuesday, March 16, 2010 11:10:18 AM2010-03-17Wednesday, March 17, 2010 10:34:45 AM2010-03-18Thursday, March 18, 2010 9:59:12 AM2010-03-19Friday, March 19, 2010 9:23:39 AM2010-03-20Saturday, March 20, 2010 8:48:06 AM2010-03-21Sunday, March 21, 2010 8:12:32 AM2010-03-22Monday, March 22, 2010 7:36:59 AM2010-03-23Tuesday, March 23, 2010 7:01:26 AM2010-03-24Wednesday, March 24, 2010 6:25:53 AM2010-03-25Thursday, March 25, 2010 5:50:20 AM2010-03-26Friday, March 26, 2010 5:14:47 AM2010-03-27Saturday, March 27, 2010 4:39:14 AM2010-03-28Sunday, March 28, 2010 4:03:41 AM2010-03-29Monday, March 29, 2010 3:28:08 AM2010-03-30Tuesday, March 30, 2010 2:52:35 AM2010-03-31Wednesday, March 31, 2010 2:17:02 AM2010-04-01Thursday, April 01, 2010 1:41:29 AM2010-04-02Friday, April 02, 2010 1:05:56 AM2010-04-03Saturday, April 03, 2010 12:30:23 AM2010-04-03Saturday, April 03, 2010 11:54:50 PM2010-04-04Sunday, April 04, 2010 11:19:17 PM2010-04-05Monday, April 05, 2010 10:43:44 PM2010-04-06Tuesday, April 06, 2010 10:08:11 PM2010-04-07Wednesday, April 07, 2010 9:32:38 PM2010-04-08Thursday, April 08, 2010 8:57:05 PM2010-04-09Friday, April 09, 2010 8:21:32 PM2010-04-10Saturday, April 10, 2010 7:45:59 PM2010-04-11Sunday, April 11, 2010 7:10:26 PM2010-04-12Monday, April 12, 2010 6:34:52 PM2010-04-13Tuesday, April 13, 2010 5:59:19 PM2010-04-14Wednesday, April 14, 2010 5:23:46 PM2010-04-15Thursday, April 15, 2010 4:48:13 PM2010-04-16Friday, April 16, 2010 4:12:40 PM2010-04-17Saturday, April 17, 2010 3:37:07 PM2010-04-18Sunday, April 18, 2010 3:01:34 PM2010-04-19Monday, April 19, 2010 2:26:01 PM2010-04-20Tuesday, April 20, 2010 1:50:28 PM2010-04-21Wednesday, April 21, 2010 1:14:55 PM2010-04-22Thursday, April 22, 2010 12:39:22 PM2010-04-23Friday, April 23, 2010 12:03:49 PM2010-04-24Saturday, April 24, 2010 11:28:16 AM2010-04-25Sunday, April 25, 2010 10:52:43 AM2010-04-26Monday, April 26, 2010 10:17:10 AM2010-04-27Tuesday, April 27, 2010 9:41:37 AM2010-04-28Wednesday, April 28, 2010 9:06:04 AM2010-04-29Thursday, April 29, 2010 8:30:31 AM2010-04-30Friday, April 30, 2010 7:54:58 AM2010-05-01Saturday, May 01, 2010 7:19:25 AM2010-05-02Sunday, May 02, 2010 6:43:52 AM2010-05-03Monday, May 03, 2010 6:08:19 AM2010-05-04Tuesday, May 04, 2010 5:32:46 AM2010-05-05Wednesday, May 05, 2010 4:57:12 AM2010-05-06Thursday, May 06, 2010 4:21:39 AM2010-05-07Friday, May 07, 2010 3:46:06 AM2010-05-08Saturday, May 08, 2010 3:10:33 AM2010-05-09Sunday, May 09, 2010 2:35:00 AM2010-05-10Monday, May 10, 2010 1:59:27 AM2010-05-11Tuesday, May 11, 2010 1:23:54 AM2010-05-12Wednesday, May 12, 2010 12:48:21 AM2010-05-13Thursday, May 13, 2010 12:12:48 AM2010-05-13Thursday, May 13, 2010 11:37:15 PM2010-05-14Friday, May 14, 2010 11:01:42 PM2010-05-15Saturday, May 15, 2010 10:26:09 PM2010-05-16Sunday, May 16, 2010 9:50:36 PM2010-05-17Monday, May 17, 2010 9:15:03 PM2010-05-18Tuesday, May 18, 2010 8:39:30 PM2010-05-19Wednesday, May 19, 2010 8:03:57 PM2010-05-20Thursday, May 20, 2010 7:28:24 PM2010-05-21Friday, May 21, 2010 6:52:51 PM2010-05-22Saturday, May 22, 2010 6:17:18 PM2010-05-23Sunday, May 23, 2010 5:41:45 PM2010-05-24Monday, May 24, 2010 5:06:12 PM2010-05-25Tuesday, May 25, 2010 4:30:39 PM2010-05-26Wednesday, May 26, 2010 3:55:05 PM2010-05-27Thursday, May 27, 2010 3:19:32 PM2010-05-28Friday, May 28, 2010 2:43:59 PM2010-05-29Saturday, May 29, 2010 2:08:26 PM2010-05-30Sunday, May 30, 2010 1:32:53 PM2010-05-31Monday, May 31, 2010 12:57:20 PM2010-06-01Tuesday, June 01, 2010 12:21:47 PM2010-06-02Wednesday, June 02, 2010 11:46:14 AM2010-06-03Thursday, June 03, 2010 11:10:41 AM2010-06-04Friday, June 04, 2010 10:35:08 AM2010-06-05Saturday, June 05, 2010 9:59:35 AM2010-06-06Sunday, June 06, 2010 9:24:02 AM2010-06-07Monday, June 07, 2010 8:48:29 AM2010-06-08Tuesday, June 08, 2010 8:12:56 AM2010-06-09Wednesday, June 09, 2010 7:37:23 AM2010-06-10Thursday, June 10, 2010 7:01:50 AM2010-06-11Friday, June 11, 2010 6:26:17 AM2010-06-12Saturday, June 12, 2010 5:50:44 AM2010-06-13Sunday, June 13, 2010 5:15:11 AM2010-06-14Monday, June 14, 2010 4:39:38 AM2010-06-15Tuesday, June 15, 2010 4:04:05 AM2010-06-16Wednesday, June 16, 2010 3:28:32 AM2010-06-17Thursday, June 17, 2010 2:52:59 AM2010-06-18Friday, June 18, 2010 2:17:25 AM2010-06-19Saturday, June 19, 2010 1:41:52 AM2010-06-20Sunday, June 20, 2010 1:06:19 AM2010-06-21Monday, June 21, 2010 12:30:46 AM2010-06-21Monday, June 21, 2010 11:55:13 PM2010-06-22Tuesday, June 22, 2010 11:19:40 PM2010-06-23Wednesday, June 23, 2010 10:44:07 PM2010-06-24Thursday, June 24, 2010 10:08:34 PM2010-06-25Friday, June 25, 2010 9:33:01 PM2010-06-26Saturday, June 26, 2010 8:57:28 PM2010-06-27Sunday, June 27, 2010 8:21:55 PM2010-06-28Monday, June 28, 2010 7:46:22 PM2010-06-29Tuesday, June 29, 2010 7:10:49 PM2010-06-30Wednesday, June 30, 2010 6:35:16 PM2010-07-01Thursday, July 01, 2010 5:59:43 PM2010-07-02Friday, July 02, 2010 5:24:10 PM2010-07-03Saturday, July 03, 2010 4:48:37 PM2010-07-04Sunday, July 04, 2010 4:13:04 PM2010-07-05Monday, July 05, 2010 3:37:31 PM2010-07-06Tuesday, July 06, 2010 3:01:58 PM2010-07-07Wednesday, July 07, 2010 2:26:25 PM2010-07-08Thursday, July 08, 2010 1:50:52 PM2010-07-09Friday, July 09, 2010 1:15:19 PM2010-07-10Saturday, July 10, 2010 12:39:45 PM2010-07-11Sunday, July 11, 2010 12:04:12 PM2010-07-12Monday, July 12, 2010 11:28:39 AM2010-07-13Tuesday, July 13, 2010 10:53:06 AM2010-07-14Wednesday, July 14, 2010 10:17:33 AM2010-07-15Thursday, July 15, 2010 9:42:00 AM2010-07-16Friday, July 16, 2010 9:06:27 AM2010-07-17Saturday, July 17, 2010 8:30:54 AM2010-07-18Sunday, July 18, 2010 7:55:21 AM2010-07-19Monday, July 19, 2010 7:19:48 AM2010-07-20Tuesday, July 20, 2010 6:44:15 AM2010-07-21Wednesday, July 21, 2010 6:08:42 AM2010-07-22Thursday, July 22, 2010 5:33:09 AM2010-07-23Friday, July 23, 2010 4:57:36 AM2010-07-24Saturday, July 24, 2010 4:22:03 AM2010-07-25Sunday, July 25, 2010 3:46:30 AM2010-07-26Monday, July 26, 2010 3:10:57 AM2010-07-27Tuesday, July 27, 2010 2:35:24 AM2010-07-28Wednesday, July 28, 2010 1:59:51 AM2010-07-29Thursday, July 29, 2010 1:24:18 AM2010-07-30Friday, July 30, 2010 12:48:45 AM2010-07-31Saturday, July 31, 2010 12:13:12 AM2010-07-31Saturday, July 31, 2010 11:37:38 PM2010-08-01Sunday, August 01, 2010 11:02:05 PM2010-08-02Monday, August 02, 2010 10:26:32 PM2010-08-03Tuesday, August 03, 2010 9:50:59 PM2010-08-04Wednesday, August 04, 2010 9:15:26 PM2010-08-05Thursday, August 05, 2010 8:39:53 PM2010-08-06Friday, August 06, 2010 8:04:20 PM2010-08-07Saturday, August 07, 2010 7:28:47 PM2010-08-08Sunday, August 08, 2010 6:53:14 PM2010-08-09Monday, August 09, 2010 6:17:41 PM2010-08-10Tuesday, August 10, 2010 5:42:08 PM2010-08-11Wednesday, August 11, 2010 5:06:35 PM2010-08-12Thursday, August 12, 2010 4:31:02 PM2010-08-13Friday, August 13, 2010 3:55:29 PM2010-08-14Saturday, August 14, 2010 3:19:56 PM2010-08-15Sunday, August 15, 2010 2:44:23 PM2010-08-16Monday, August 16, 2010 2:08:50 PM2010-08-17Tuesday, August 17, 2010 1:33:17 PM2010-08-18Wednesday, August 18, 2010 12:57:44 PM2010-08-19Thursday, August 19, 2010 12:22:11 PM2010-08-20Friday, August 20, 2010 11:46:38 AM2010-08-21Saturday, August 21, 2010 11:11:05 AM2010-08-22Sunday, August 22, 2010 10:35:32 AM2010-08-23Monday, August 23, 2010 9:59:58 AM2010-08-24Tuesday, August 24, 2010 9:24:25 AM2010-08-25Wednesday, August 25, 2010 8:48:52 AM2010-08-26Thursday, August 26, 2010 8:13:19 AM2010-08-27Friday, August 27, 2010 7:37:46 AM2010-08-28Saturday, August 28, 2010 7:02:13 AM2010-08-29Sunday, August 29, 2010 6:26:40 AM2010-08-30Monday, August 30, 2010 5:51:07 AM2010-08-31Tuesday, August 31, 2010 5:15:34 AM2010-09-01Wednesday, September 01, 2010 4:40:01 AM2010-09-02Thursday, September 02, 2010 4:04:28 AM2010-09-03Friday, September 03, 2010 3:28:55 AM2010-09-04Saturday, September 04, 2010 2:53:22 AM2010-09-05Sunday, September 05, 2010 2:17:49 AM2010-09-06Monday, September 06, 2010 1:42:16 AM2010-09-07Tuesday, September 07, 2010 1:06:43 AM2010-09-08Wednesday, September 08, 2010 12:31:10 AM2010-09-08Wednesday, September 08, 2010 11:55:37 PM2010-09-09Thursday, September 09, 2010 11:20:04 PM2010-09-10Friday, September 10, 2010 10:44:31 PM2010-09-11Saturday, September 11, 2010 10:08:58 PM2010-09-12Sunday, September 12, 2010 9:33:25 PM2010-09-13Monday, September 13, 2010 8:57:52 PM2010-09-14Tuesday, September 14, 2010 8:22:18 PM2010-09-15Wednesday, September 15, 2010 7:46:45 PM2010-09-16Thursday, September 16, 2010 7:11:12 PM2010-09-17Friday, September 17, 2010 6:35:39 PM2010-09-18Saturday, September 18, 2010 6:00:06 PM2010-09-19Sunday, September 19, 2010 5:24:33 PM2010-09-20Monday, September 20, 2010 4:49:00 PM2010-09-21Tuesday, September 21, 2010 4:13:27 PM2010-09-22Wednesday, September 22, 2010 3:37:54 PM2010-09-23Thursday, September 23, 2010 3:02:21 PM2010-09-24Friday, September 24, 2010 2:26:48 PM2010-09-25Saturday, September 25, 2010 1:51:15 PM2010-09-26Sunday, September 26, 2010 1:15:42 PM2010-09-27Monday, September 27, 2010 12:40:09 PM2010-09-28Tuesday, September 28, 2010 12:04:36 PM2010-09-29Wednesday, September 29, 2010 11:29:03 AM2010-09-30Thursday, September 30, 2010 10:53:30 AM2010-10-01Friday, October 01, 2010 10:17:57 AM2010-10-02Saturday, October 02, 2010 9:42:24 AM2010-10-03Sunday, October 03, 2010 9:06:51 AM2010-10-04Monday, October 04, 2010 8:31:18 AM2010-10-05Tuesday, October 05, 2010 7:55:45 AM2010-10-06Wednesday, October 06, 2010 7:20:12 AM2010-10-07Thursday, October 07, 2010 6:44:38 AM2010-10-08Friday, October 08, 2010 6:09:05 AM2010-10-09Saturday, October 09, 2010 5:33:32 AM2010-10-10Sunday, October 10, 2010 4:57:59 AM2010-10-11Monday, October 11, 2010 4:22:26 AM2010-10-12Tuesday, October 12, 2010 3:46:53 AM2010-10-13Wednesday, October 13, 2010 3:11:20 AM2010-10-14Thursday, October 14, 2010 2:35:47 AM2010-10-15Friday, October 15, 2010 2:00:14 AM2010-10-16Saturday, October 16, 2010 1:24:41 AM2010-10-17Sunday, October 17, 2010 12:49:08 AM2010-10-18Monday, October 18, 2010 12:13:35 AM2010-10-18Monday, October 18, 2010 11:38:02 PM2010-10-19Tuesday, October 19, 2010 11:02:29 PM2010-10-20Wednesday, October 20, 2010 10:26:56 PM2010-10-21Thursday, October 21, 2010 9:51:23 PM2010-10-22Friday, October 22, 2010 9:15:50 PM2010-10-23Saturday, October 23, 2010 8:40:17 PM2010-10-24Sunday, October 24, 2010 8:04:44 PM2010-10-25Monday, October 25, 2010 7:29:11 PM2010-10-26Tuesday, October 26, 2010 6:53:38 PM2010-10-27Wednesday, October 27, 2010 6:18:05 PM2010-10-28Thursday, October 28, 2010 5:42:31 PM2010-10-29Friday, October 29, 2010 5:06:58 PM2010-10-30Saturday, October 30, 2010 4:31:25 PM2010-10-31Sunday, October 31, 2010 3:55:52 PM2010-11-01Monday, November 01, 2010 3:20:19 PM2010-11-02Tuesday, November 02, 2010 2:44:46 PM2010-11-03Wednesday, November 03, 2010 2:09:13 PM2010-11-04Thursday, November 04, 2010 1:33:40 PM2010-11-05Friday, November 05, 2010 12:58:07 PM2010-11-06Saturday, November 06, 2010 12:22:34 PM2010-11-07Sunday, November 07, 2010 10:47:01 AM2010-11-08Monday, November 08, 2010 10:11:28 AM2010-11-09Tuesday, November 09, 2010 9:35:55 AM2010-11-10Wednesday, November 10, 2010 9:00:22 AM2010-11-11Thursday, November 11, 2010 8:24:49 AM2010-11-12Friday, November 12, 2010 7:49:16 AM2010-11-13Saturday, November 13, 2010 7:13:43 AM2010-11-14Sunday, November 14, 2010 6:38:10 AM2010-11-15Monday, November 15, 2010 6:02:37 AM2010-11-16Tuesday, November 16, 2010 5:27:04 AM2010-11-17Wednesday, November 17, 2010 4:51:31 AM2010-11-18Thursday, November 18, 2010 4:15:58 AM2010-11-19Friday, November 19, 2010 3:40:25 AM2010-11-20Saturday, November 20, 2010 3:04:51 AM2010-11-21Sunday, November 21, 2010 2:29:18 AM2010-11-22Monday, November 22, 2010 1:53:45 AM2010-11-23Tuesday, November 23, 2010 1:18:12 AM2010-11-24Wednesday, November 24, 2010 12:42:39 AM2010-11-25Thursday, November 25, 2010 12:07:06 AM2010-11-25Thursday, November 25, 2010 11:31:33 PM2010-11-26Friday, November 26, 2010 10:56:00 PM2010-11-27Saturday, November 27, 2010 10:20:27 PM2010-11-28Sunday, November 28, 2010 9:44:54 PM2010-11-29Monday, November 29, 2010 9:09:21 PM2010-11-30Tuesday, November 30, 2010 8:33:48 PM2010-12-01Wednesday, December 01, 2010 7:58:15 PM2010-12-02Thursday, December 02, 2010 7:22:42 PM2010-12-03Friday, December 03, 2010 6:47:09 PM2010-12-04Saturday, December 04, 2010 6:11:36 PM2010-12-05Sunday, December 05, 2010 5:36:03 PM2010-12-06Monday, December 06, 2010 5:00:30 PM2010-12-07Tuesday, December 07, 2010 4:24:57 PM2010-12-08Wednesday, December 08, 2010 3:49:24 PM2010-12-09Thursday, December 09, 2010 3:13:51 PM2010-12-10Friday, December 10, 2010 2:38:18 PM2010-12-11Saturday, December 11, 2010 2:02:45 PM2010-12-12Sunday, December 12, 2010 1:27:11 PM2010-12-13Monday, December 13, 2010 12:51:38 PM2010-12-14Tuesday, December 14, 2010 12:16:05 PM2010-12-15Wednesday, December 15, 2010 11:40:32 AM2010-12-16Thursday, December 16, 2010 11:04:59 AM2010-12-17Friday, December 17, 2010 10:29:26 AM2010-12-18Saturday, December 18, 2010 9:53:53 AM2010-12-19Sunday, December 19, 2010 9:18:20 AM2010-12-20Monday, December 20, 2010 8:42:47 AM2010-12-21Tuesday, December 21, 2010 8:07:14 AM2010-12-22Wednesday, December 22, 2010 7:31:41 AM2010-12-23Thursday, December 23, 2010 6:56:08 AM2010-12-24Friday, December 24, 2010 6:20:35 AM2010-12-25Saturday, December 25, 2010 5:45:02 AM2010-12-26Sunday, December 26, 2010 5:09:29 AM2010-12-27Monday, December 27, 2010 4:33:56 AM2010-12-28Tuesday, December 28, 2010 3:58:23 AM2010-12-29Wednesday, December 29, 2010 3:22:50 AM2010-12-30Thursday, December 30, 2010 2:47:17 AM2010-12-31Friday, December 31, 2010 2:11:44 AM2011-01-01Saturday, January 01, 2011 1:36:11 AM2011-01-02Sunday, January 02, 2011 1:00:38 AM2011-01-03Monday, January 03, 2011 12:25:05 AM2011-01-03Monday, January 03, 2011 11:49:31 PM2011-01-04Tuesday, January 04, 2011 11:13:58 PM2011-01-05Wednesday, January 05, 2011 10:38:25 PM2011-01-06Thursday, January 06, 2011 10:02:52 PM2011-01-07Friday, January 07, 2011 9:27:19 PM2011-01-08Saturday, January 08, 2011 8:51:46 PM2011-01-09Sunday, January 09, 2011 8:16:13 PM2011-01-10Monday, January 10, 2011 7:40:40 PM2011-01-11Tuesday, January 11, 2011 7:05:07 PM2011-01-12Wednesday, January 12, 2011 6:29:34 PM2011-01-13Thursday, January 13, 2011 5:54:01 PM2011-01-14Friday, January 14, 2011 5:18:28 PM2011-01-15Saturday, January 15, 2011 4:42:55 PM2011-01-16Sunday, January 16, 2011 4:07:22 PM2011-01-17Monday, January 17, 2011 3:31:49 PM2011-01-18Tuesday, January 18, 2011 2:56:16 PM2011-01-19Wednesday, January 19, 2011 2:20:43 PM2011-01-20Thursday, January 20, 2011 1:45:10 PM2011-01-21Friday, January 21, 2011 1:09:37 PM2011-01-22Saturday, January 22, 2011 12:34:04 PM2011-01-23Sunday, January 23, 2011 11:58:31 AM2011-01-24Monday, January 24, 2011 11:22:58 AM2011-01-25Tuesday, January 25, 2011 10:47:24 AM2011-01-26Wednesday, January 26, 2011 10:11:51 AM2011-01-27Thursday, January 27, 2011 9:36:18 AM2011-01-28Friday, January 28, 2011 9:00:45 AM2011-01-29Saturday, January 29, 2011 8:25:12 AM2011-01-30Sunday, January 30, 2011 7:49:39 AM2011-01-31Monday, January 31, 2011 7:14:06 AM2011-02-01Tuesday, February 01, 2011 6:38:33 AM2011-02-02Wednesday, February 02, 2011 6:03:00 AM2011-02-03Thursday, February 03, 2011 5:27:27 AM2011-02-04Friday, February 04, 2011 4:51:54 AM2011-02-05Saturday, February 05, 2011 4:16:21 AM2011-02-06Sunday, February 06, 2011 3:40:48 AM2011-02-07Monday, February 07, 2011 3:05:15 AM2011-02-08Tuesday, February 08, 2011 2:29:42 AM2011-02-09Wednesday, February 09, 2011 1:54:09 AM2011-02-10Thursday, February 10, 2011 1:18:36 AM2011-02-11Friday, February 11, 2011 12:43:03 AM2011-02-12Saturday, February 12, 2011 12:07:30 AM2011-02-12Saturday, February 12, 2011 11:31:57 PM2011-02-13Sunday, February 13, 2011 10:56:24 PM2011-02-14Monday, February 14, 2011 10:20:51 PM2011-02-15Tuesday, February 15, 2011 9:45:18 PM2011-02-16Wednesday, February 16, 2011 9:09:44 PM2011-02-17Thursday, February 17, 2011 8:34:11 PM2011-02-18Friday, February 18, 2011 7:58:38 PM2011-02-19Saturday, February 19, 2011 7:23:05 PM2011-02-20Sunday, February 20, 2011 6:47:32 PM2011-02-21Monday, February 21, 2011 6:11:59 PM2011-02-22Tuesday, February 22, 2011 5:36:26 PM2011-02-23Wednesday, February 23, 2011 5:00:53 PM2011-02-24Thursday, February 24, 2011 4:25:20 PM2011-02-25Friday, February 25, 2011 3:49:47 PM2011-02-26Saturday, February 26, 2011 3:14:14 PM2011-02-27Sunday, February 27, 2011 2:38:41 PM2011-02-28Monday, February 28, 2011 2:03:08 PM2011-03-01Tuesday, March 01, 2011 1:27:35 PM2011-03-02Wednesday, March 02, 2011 12:52:02 PM2011-03-03Thursday, March 03, 2011 12:16:29 PM2011-03-04Friday, March 04, 2011 11:40:56 AM2011-03-05Saturday, March 05, 2011 11:05:23 AM2011-03-06Sunday, March 06, 2011 10:29:50 AM2011-03-07Monday, March 07, 2011 9:54:17 AM2011-03-08Tuesday, March 08, 2011 9:18:44 AM2011-03-09Wednesday, March 09, 2011 8:43:11 AM2011-03-10Thursday, March 10, 2011 8:07:38 AM2011-03-11Friday, March 11, 2011 7:32:04 AM2011-03-12Saturday, March 12, 2011 6:56:31 AM2011-03-13Sunday, March 13, 2011 7:20:58 AM2011-03-14Monday, March 14, 2011 6:45:25 AM2011-03-15Tuesday, March 15, 2011 6:09:52 AM2011-03-16Wednesday, March 16, 2011 5:34:19 AM2011-03-17Thursday, March 17, 2011 4:58:46 AM2011-03-18Friday, March 18, 2011 4:23:13 AM2011-03-19Saturday, March 19, 2011 3:47:40 AM2011-03-20Sunday, March 20, 2011 3:12:07 AM2011-03-21Monday, March 21, 2011 2:36:34 AM2011-03-22Tuesday, March 22, 2011 2:01:01 AM2011-03-23Wednesday, March 23, 2011 1:25:28 AM2011-03-24Thursday, March 24, 2011 12:49:55 AM2011-03-25Friday, March 25, 2011 12:14:22 AM2011-03-25Friday, March 25, 2011 11:38:49 PM2011-03-26Saturday, March 26, 2011 11:03:16 PM2011-03-27Sunday, March 27, 2011 10:27:43 PM2011-03-28Monday, March 28, 2011 9:52:10 PM2011-03-29Tuesday, March 29, 2011 9:16:37 PM2011-03-30Wednesday, March 30, 2011 8:41:04 PM2011-03-31Thursday, March 31, 2011 8:05:31 PM2011-04-01Friday, April 01, 2011 7:29:57 PM2011-04-02Saturday, April 02, 2011 6:54:24 PM2011-04-03Sunday, April 03, 2011 6:18:51 PM2011-04-04Monday, April 04, 2011 5:43:18 PM2011-04-05Tuesday, April 05, 2011 5:07:45 PM2011-04-06Wednesday, April 06, 2011 4:32:12 PM2011-04-07Thursday, April 07, 2011 3:56:39 PM2011-04-08Friday, April 08, 2011 3:21:06 PM2011-04-09Saturday, April 09, 2011 2:45:33 PM2011-04-10Sunday, April 10, 2011 2:10:00 PM2011-04-11Monday, April 11, 2011 1:34:27 PM2011-04-12Tuesday, April 12, 2011 12:58:54 PM2011-04-13Wednesday, April 13, 2011 12:23:21 PM2011-04-14Thursday, April 14, 2011 11:47:48 AM2011-04-15Friday, April 15, 2011 11:12:15 AM2011-04-16Saturday, April 16, 2011 10:36:42 AM2011-04-17Sunday, April 17, 2011 10:01:09 AM2011-04-18Monday, April 18, 2011 9:25:36 AM2011-04-19Tuesday, April 19, 2011 8:50:03 AM2011-04-20Wednesday, April 20, 2011 8:14:30 AM2011-04-21Thursday, April 21, 2011 7:38:57 AM2011-04-22Friday, April 22, 2011 7:03:24 AM2011-04-23Saturday, April 23, 2011 6:27:51 AM2011-04-24Sunday, April 24, 2011 5:52:17 AM2011-04-25Monday, April 25, 2011 5:16:44 AM2011-04-26Tuesday, April 26, 2011 4:41:11 AM2011-04-27Wednesday, April 27, 2011 4:05:38 AM2011-04-28Thursday, April 28, 2011 3:30:05 AM2011-04-29Friday, April 29, 2011 2:54:32 AM2011-04-30Saturday, April 30, 2011 2:18:59 AM2011-05-01Sunday, May 01, 2011 1:43:26 AM2011-05-02Monday, May 02, 2011 1:07:53 AM2011-05-03Tuesday, May 03, 2011 12:32:20 AM2011-05-03Tuesday, May 03, 2011 11:56:47 PM2011-05-04Wednesday, May 04, 2011 11:21:14 PM2011-05-05Thursday, May 05, 2011 10:45:41 PM2011-05-06Friday, May 06, 2011 10:10:08 PM2011-05-07Saturday, May 07, 2011 9:34:35 PM2011-05-08Sunday, May 08, 2011 8:59:02 PM2011-05-09Monday, May 09, 2011 8:23:29 PM2011-05-10Tuesday, May 10, 2011 7:47:56 PM2011-05-11Wednesday, May 11, 2011 7:12:23 PM2011-05-12Thursday, May 12, 2011 6:36:50 PM2011-05-13Friday, May 13, 2011 6:01:17 PM2011-05-14Saturday, May 14, 2011 5:25:44 PM2011-05-15Sunday, May 15, 2011 4:50:11 PM2011-05-16Monday, May 16, 2011 4:14:37 PM2011-05-17Tuesday, May 17, 2011 3:39:04 PM2011-05-18Wednesday, May 18, 2011 3:03:31 PM2011-05-19Thursday, May 19, 2011 2:27:58 PM2011-05-20Friday, May 20, 2011 1:52:25 PM2011-05-21Saturday, May 21, 2011 1:16:52 PM2011-05-22Sunday, May 22, 2011 12:41:19 PM2011-05-23Monday, May 23, 2011 12:05:46 PM2011-05-24Tuesday, May 24, 2011 11:30:13 AM2011-05-25Wednesday, May 25, 2011 10:54:40 AM2011-05-26Thursday, May 26, 2011 10:19:07 AM2011-05-27Friday, May 27, 2011 9:43:34 AM2011-05-28Saturday, May 28, 2011 9:08:01 AM2011-05-29Sunday, May 29, 2011 8:32:28 AM2011-05-30Monday, May 30, 2011 7:56:55 AM2011-05-31Tuesday, May 31, 2011 7:21:22 AM2011-06-01Wednesday, June 01, 2011 6:45:49 AM2011-06-02Thursday, June 02, 2011 6:10:16 AM2011-06-03Friday, June 03, 2011 5:34:43 AM2011-06-04Saturday, June 04, 2011 4:59:10 AM2011-06-05Sunday, June 05, 2011 4:23:37 AM2011-06-06Monday, June 06, 2011 3:48:04 AM2011-06-07Tuesday, June 07, 2011 3:12:31 AM2011-06-08Wednesday, June 08, 2011 2:36:57 AM2011-06-09Thursday, June 09, 2011 2:01:24 AM2011-06-10Friday, June 10, 2011 1:25:51 AM2011-06-11Saturday, June 11, 2011 12:50:18 AM2011-06-12Sunday, June 12, 2011 12:14:45 AM2011-06-12Sunday, June 12, 2011 11:39:12 PM2011-06-13Monday, June 13, 2011 11:03:39 PM2011-06-14Tuesday, June 14, 2011 10:28:06 PM2011-06-15Wednesday, June 15, 2011 9:52:33 PM2011-06-16Thursday, June 16, 2011 9:17:00 PM2011-06-17Friday, June 17, 2011 8:41:27 PM2011-06-18Saturday, June 18, 2011 8:05:54 PM2011-06-19Sunday, June 19, 2011 7:30:21 PM2011-06-20Monday, June 20, 2011 6:54:48 PM2011-06-21Tuesday, June 21, 2011 6:19:15 PM2011-06-22Wednesday, June 22, 2011 5:43:42 PM2011-06-23Thursday, June 23, 2011 5:08:09 PM2011-06-24Friday, June 24, 2011 4:32:36 PM2011-06-25Saturday, June 25, 2011 3:57:03 PM2011-06-26Sunday, June 26, 2011 3:21:30 PM2011-06-27Monday, June 27, 2011 2:45:57 PM2011-06-28Tuesday, June 28, 2011 2:10:24 PM2011-06-29Wednesday, June 29, 2011 1:34:50 PM2011-06-30Thursday, June 30, 2011 12:59:17 PM2011-07-01Friday, July 01, 2011 12:23:44 PM2011-07-02Saturday, July 02, 2011 11:48:11 AM2011-07-03Sunday, July 03, 2011 11:12:38 AM2011-07-04Monday, July 04, 2011 10:37:05 AM2011-07-05Tuesday, July 05, 2011 10:01:32 AM2011-07-06Wednesday, July 06, 2011 9:25:59 AM2011-07-07Thursday, July 07, 2011 8:50:26 AM2011-07-08Friday, July 08, 2011 8:14:53 AM2011-07-09Saturday, July 09, 2011 7:39:20 AM2011-07-10Sunday, July 10, 2011 7:03:47 AM2011-07-11Monday, July 11, 2011 6:28:14 AM2011-07-12Tuesday, July 12, 2011 5:52:41 AM2011-07-13Wednesday, July 13, 2011 5:17:08 AM2011-07-14Thursday, July 14, 2011 4:41:35 AM2011-07-15Friday, July 15, 2011 4:06:02 AM2011-07-16Saturday, July 16, 2011 3:30:29 AM2011-07-17Sunday, July 17, 2011 2:54:56 AM2011-07-18Monday, July 18, 2011 2:19:23 AM2011-07-19Tuesday, July 19, 2011 1:43:50 AM2011-07-20Wednesday, July 20, 2011 1:08:17 AM2011-07-21Thursday, July 21, 2011 12:32:44 AM2011-07-21Thursday, July 21, 2011 11:57:10 PM2011-07-22Friday, July 22, 2011 11:21:37 PM2011-07-23Saturday, July 23, 2011 10:46:04 PM2011-07-24Sunday, July 24, 2011 10:10:31 PM2011-07-25Monday, July 25, 2011 9:34:58 PM2011-07-26Tuesday, July 26, 2011 8:59:25 PM2011-07-27Wednesday, July 27, 2011 8:23:52 PM2011-07-28Thursday, July 28, 2011 7:48:19 PM2011-07-29Friday, July 29, 2011 7:12:46 PM2011-07-30Saturday, July 30, 2011 6:37:13 PM2011-07-31Sunday, July 31, 2011 6:01:40 PM2011-08-01Monday, August 01, 2011 5:26:07 PM2011-08-02Tuesday, August 02, 2011 4:50:34 PM2011-08-03Wednesday, August 03, 2011 4:15:01 PM2011-08-04Thursday, August 04, 2011 3:39:28 PM2011-08-05Friday, August 05, 2011 3:03:55 PM2011-08-06Saturday, August 06, 2011 2:28:22 PM2011-08-07Sunday, August 07, 2011 1:52:49 PM2011-08-08Monday, August 08, 2011 1:17:16 PM2011-08-09Tuesday, August 09, 2011 12:41:43 PM2011-08-10Wednesday, August 10, 2011 12:06:10 PM2011-08-11Thursday, August 11, 2011 11:30:37 AM2011-08-12Friday, August 12, 2011 10:55:04 AM2011-08-13Saturday, August 13, 2011 10:19:30 AM2011-08-14Sunday, August 14, 2011 9:43:57 AM2011-08-15Monday, August 15, 2011 9:08:24 AM2011-08-16Tuesday, August 16, 2011 8:32:51 AM2011-08-17Wednesday, August 17, 2011 7:57:18 AM2011-08-18Thursday, August 18, 2011 7:21:45 AM2011-08-19Friday, August 19, 2011 6:46:12 AM2011-08-20Saturday, August 20, 2011 6:10:39 AM2011-08-21Sunday, August 21, 2011 5:35:06 AM2011-08-22Monday, August 22, 2011 4:59:33 AM2011-08-23Tuesday, August 23, 2011 4:24:00 AM2011-08-24Wednesday, August 24, 2011 3:48:27 AM2011-08-25Thursday, August 25, 2011 3:12:54 AM2011-08-26Friday, August 26, 2011 2:37:21 AM2011-08-27Saturday, August 27, 2011 2:01:48 AM2011-08-28Sunday, August 28, 2011 1:26:15 AM2011-08-29Monday, August 29, 2011 12:50:42 AM2011-08-30Tuesday, August 30, 2011 12:15:09 AM2011-08-30Tuesday, August 30, 2011 11:39:36 PM2011-08-31Wednesday, August 31, 2011 11:04:03 PM2011-09-01Thursday, September 01, 2011 10:28:30 PM2011-09-02Friday, September 02, 2011 9:52:57 PM2011-09-03Saturday, September 03, 2011 9:17:24 PM2011-09-04Sunday, September 04, 2011 8:41:50 PM2011-09-05Monday, September 05, 2011 8:06:17 PM2011-09-06Tuesday, September 06, 2011 7:30:44 PM2011-09-07Wednesday, September 07, 2011 6:55:11 PM2011-09-08Thursday, September 08, 2011 6:19:38 PM2011-09-09Friday, September 09, 2011 5:44:05 PM2011-09-10Saturday, September 10, 2011 5:08:32 PM2011-09-11Sunday, September 11, 2011 4:32:59 PM2011-09-12Monday, September 12, 2011 3:57:26 PM2011-09-13Tuesday, September 13, 2011 3:21:53 PM2011-09-14Wednesday, September 14, 2011 2:46:20 PM2011-09-15Thursday, September 15, 2011 2:10:47 PM2011-09-16Friday, September 16, 2011 1:35:14 PM2011-09-17Saturday, September 17, 2011 12:59:41 PM2011-09-18Sunday, September 18, 2011 12:24:08 PM2011-09-19Monday, September 19, 2011 11:48:35 AM2011-09-20Tuesday, September 20, 2011 11:13:02 AM2011-09-21Wednesday, September 21, 2011 10:37:29 AM2011-09-22Thursday, September 22, 2011 10:01:56 AM2011-09-23Friday, September 23, 2011 9:26:23 AM2011-09-24Saturday, September 24, 2011 8:50:50 AM2011-09-25Sunday, September 25, 2011 8:15:17 AM2011-09-26Monday, September 26, 2011 7:39:43 AM2011-09-27Tuesday, September 27, 2011 7:04:10 AM2011-09-28Wednesday, September 28, 2011 6:28:37 AM2011-09-29Thursday, September 29, 2011 5:53:04 AM2011-09-30Friday, September 30, 2011 5:17:31 AM2011-10-01Saturday, October 01, 2011 4:41:58 AM2011-10-02Sunday, October 02, 2011 4:06:25 AM2011-10-03Monday, October 03, 2011 3:30:52 AM2011-10-04Tuesday, October 04, 2011 2:55:19 AM2011-10-05Wednesday, October 05, 2011 2:19:46 AM2011-10-06Thursday, October 06, 2011 1:44:13 AM2011-10-07Friday, October 07, 2011 1:08:40 AM2011-10-08Saturday, October 08, 2011 12:33:07 AM2011-10-08Saturday, October 08, 2011 11:57:34 PM2011-10-09Sunday, October 09, 2011 11:22:01 PM2011-10-10Monday, October 10, 2011 10:46:28 PM2011-10-11Tuesday, October 11, 2011 10:10:55 PM2011-10-12Wednesday, October 12, 2011 9:35:22 PM2011-10-13Thursday, October 13, 2011 8:59:49 PM2011-10-14Friday, October 14, 2011 8:24:16 PM2011-10-15Saturday, October 15, 2011 7:48:43 PM2011-10-16Sunday, October 16, 2011 7:13:10 PM2011-10-17Monday, October 17, 2011 6:37:37 PM2011-10-18Tuesday, October 18, 2011 6:02:03 PM2011-10-19Wednesday, October 19, 2011 5:26:30 PM2011-10-20Thursday, October 20, 2011 4:50:57 PM2011-10-21Friday, October 21, 2011 4:15:24 PM2011-10-22Saturday, October 22, 2011 3:39:51 PM2011-10-23Sunday, October 23, 2011 3:04:18 PM2011-10-24Monday, October 24, 2011 2:28:45 PM2011-10-25Tuesday, October 25, 2011 1:53:12 PM2011-10-26Wednesday, October 26, 2011 1:17:39 PM2011-10-27Thursday, October 27, 2011 12:42:06 PM2011-10-28Friday, October 28, 2011 12:06:33 PM2011-10-29Saturday, October 29, 2011 11:31:00 AM2011-10-30Sunday, October 30, 2011 10:55:27 AM2011-10-31Monday, October 31, 2011 10:19:54 AM2011-11-01Tuesday, November 01, 2011 9:44:21 AM2011-11-02Wednesday, November 02, 2011 9:08:48 AM2011-11-03Thursday, November 03, 2011 8:33:15 AM2011-11-04Friday, November 04, 2011 7:57:42 AM2011-11-05Saturday, November 05, 2011 7:22:09 AM2011-11-06Sunday, November 06, 2011 5:46:36 AM2011-11-07Monday, November 07, 2011 5:11:03 AM2011-11-08Tuesday, November 08, 2011 4:35:30 AM2011-11-09Wednesday, November 09, 2011 3:59:57 AM2011-11-10Thursday, November 10, 2011 3:24:23 AM2011-11-11Friday, November 11, 2011 2:48:50 AM2011-11-12Saturday, November 12, 2011 2:13:17 AM2011-11-13Sunday, November 13, 2011 1:37:44 AM2011-11-14Monday, November 14, 2011 1:02:11 AM2011-11-15Tuesday, November 15, 2011 12:26:38 AM2011-11-15Tuesday, November 15, 2011 11:51:05 PM2011-11-16Wednesday, November 16, 2011 11:15:32 PM2011-11-17Thursday, November 17, 2011 10:39:59 PM2011-11-18Friday, November 18, 2011 10:04:26 PM2011-11-19Saturday, November 19, 2011 9:28:53 PM2011-11-20Sunday, November 20, 2011 8:53:20 PM2011-11-21Monday, November 21, 2011 8:17:47 PM2011-11-22Tuesday, November 22, 2011 7:42:14 PM2011-11-23Wednesday, November 23, 2011 7:06:41 PM2011-11-24Thursday, November 24, 2011 6:31:08 PM2011-11-25Friday, November 25, 2011 5:55:35 PM2011-11-26Saturday, November 26, 2011 5:20:02 PM2011-11-27Sunday, November 27, 2011 4:44:29 PM2011-11-28Monday, November 28, 2011 4:08:56 PM2011-11-29Tuesday, November 29, 2011 3:33:23 PM2011-11-30Wednesday, November 30, 2011 2:57:50 PM2011-12-01Thursday, December 01, 2011 2:22:16 PM2011-12-02Friday, December 02, 2011 1:46:43 PM2011-12-03Saturday, December 03, 2011 1:11:10 PM2011-12-04Sunday, December 04, 2011 12:35:37 PM2011-12-05Monday, December 05, 2011 12:00:04 PM2011-12-06Tuesday, December 06, 2011 11:24:31 AM2011-12-07Wednesday, December 07, 2011 10:48:58 AM2011-12-08Thursday, December 08, 2011 10:13:25 AM2011-12-09Friday, December 09, 2011 9:37:52 AM2011-12-10Saturday, December 10, 2011 9:02:19 AM2011-12-11Sunday, December 11, 2011 8:26:46 AM2011-12-12Monday, December 12, 2011 7:51:13 AM2011-12-13Tuesday, December 13, 2011 7:15:40 AM2011-12-14Wednesday, December 14, 2011 6:40:07 AM2011-12-15Thursday, December 15, 2011 6:04:34 AM2011-12-16Friday, December 16, 2011 5:29:01 AM2011-12-17Saturday, December 17, 2011 4:53:28 AM2011-12-18Sunday, December 18, 2011 4:17:55 AM2011-12-19Monday, December 19, 2011 3:42:22 AM2011-12-20Tuesday, December 20, 2011 3:06:49 AM2011-12-21Wednesday, December 21, 2011 2:31:16 AM2011-12-22Thursday, December 22, 2011 1:55:43 AM2011-12-23Friday, December 23, 2011 1:20:10 AM2011-12-24Saturday, December 24, 2011 12:44:36 AM2011-12-25Sunday, December 25, 2011 12:09:03 AM2011-12-25Sunday, December 25, 2011 11:33:30 PM2011-12-26Monday, December 26, 2011 10:57:57 PM2011-12-27Tuesday, December 27, 2011 10:22:24 PM2011-12-28Wednesday, December 28, 2011 9:46:51 PM2011-12-29Thursday, December 29, 2011 9:11:18 PM2011-12-30Friday, December 30, 2011 8:35:45 PM2011-12-31Saturday, December 31, 2011 8:00:12 PM2012-01-01Sunday, January 01, 2012 7:24:39 PM2012-01-02Monday, January 02, 2012 6:49:06 PM2012-01-03Tuesday, January 03, 2012 6:13:33 PM2012-01-04Wednesday, January 04, 2012 5:38:00 PM2012-01-05Thursday, January 05, 2012 5:02:27 PM2012-01-06Friday, January 06, 2012 4:26:54 PM2012-01-07Saturday, January 07, 2012 3:51:21 PM2012-01-08Sunday, January 08, 2012 3:15:48 PM2012-01-09Monday, January 09, 2012 2:40:15 PM2012-01-10Tuesday, January 10, 2012 2:04:42 PM2012-01-11Wednesday, January 11, 2012 1:29:09 PM2012-01-12Thursday, January 12, 2012 12:53:36 PM2012-01-13Friday, January 13, 2012 12:18:03 PM2012-01-14Saturday, January 14, 2012 11:42:30 AM2012-01-15Sunday, January 15, 2012 11:06:56 AM2012-01-16Monday, January 16, 2012 10:31:23 AM2012-01-17Tuesday, January 17, 2012 9:55:50 AM2012-01-18Wednesday, January 18, 2012 9:20:17 AM2012-01-19Thursday, January 19, 2012 8:44:44 AM2012-01-20Friday, January 20, 2012 8:09:11 AM2012-01-21Saturday, January 21, 2012 7:33:38 AM2012-01-22Sunday, January 22, 2012 6:58:05 AM2012-01-23Monday, January 23, 2012 6:22:32 AM2012-01-24Tuesday, January 24, 2012 5:46:59 AM2012-01-25Wednesday, January 25, 2012 5:11:26 AM2012-01-26Thursday, January 26, 2012 4:35:53 AM2012-01-27Friday, January 27, 2012 4:00:20 AM2012-01-28Saturday, January 28, 2012 3:24:47 AM2012-01-29Sunday, January 29, 2012 2:49:14 AM2012-01-30Monday, January 30, 2012 2:13:41 AM2012-01-31Tuesday, January 31, 2012 1:38:08 AM2012-02-01Wednesday, February 01, 2012 1:02:35 AM2012-02-02Thursday, February 02, 2012 12:27:02 AM2012-02-02Thursday, February 02, 2012 11:51:29 PM2012-02-03Friday, February 03, 2012 11:15:56 PM2012-02-04Saturday, February 04, 2012 10:40:23 PM2012-02-05Sunday, February 05, 2012 10:04:50 PM2012-02-06Monday, February 06, 2012 9:29:16 PM2012-02-07Tuesday, February 07, 2012 8:53:43 PM2012-02-08Wednesday, February 08, 2012 8:18:10 PM2012-02-09Thursday, February 09, 2012 7:42:37 PM2012-02-10Friday, February 10, 2012 7:07:04 PM2012-02-11Saturday, February 11, 2012 6:31:31 PM2012-02-12Sunday, February 12, 2012 5:55:58 PM2012-02-13Monday, February 13, 2012 5:20:25 PM2012-02-14Tuesday, February 14, 2012 4:44:52 PM2012-02-15Wednesday, February 15, 2012 4:09:19 PM2012-02-16Thursday, February 16, 2012 3:33:46 PM2012-02-17Friday, February 17, 2012 2:58:13 PM2012-02-18Saturday, February 18, 2012 2:22:40 PM2012-02-19Sunday, February 19, 2012 1:47:07 PM2012-02-20Monday, February 20, 2012 1:11:34 PM2012-02-21Tuesday, February 21, 2012 12:36:01 PM2012-02-22Wednesday, February 22, 2012 12:00:28 PM2012-02-23Thursday, February 23, 2012 11:24:55 AM2012-02-24Friday, February 24, 2012 10:49:22 AM2012-02-25Saturday, February 25, 2012 10:13:49 AM2012-02-26Sunday, February 26, 2012 9:38:16 AM2012-02-27Monday, February 27, 2012 9:02:43 AM2012-02-28Tuesday, February 28, 2012 8:27:09 AM2012-02-29Wednesday, February 29, 2012 7:51:36 AM2012-03-01Thursday, March 01, 2012 7:16:03 AM2012-03-02Friday, March 02, 2012 6:40:30 AM2012-03-03Saturday, March 03, 2012 6:04:57 AM2012-03-04Sunday, March 04, 2012 5:29:24 AM2012-03-05Monday, March 05, 2012 4:53:51 AM2012-03-06Tuesday, March 06, 2012 4:18:18 AM2012-03-07Wednesday, March 07, 2012 3:42:45 AM2012-03-08Thursday, March 08, 2012 3:07:12 AM2012-03-09Friday, March 09, 2012 2:31:39 AM2012-03-10Saturday, March 10, 2012 1:56:06 AM2012-03-11Sunday, March 11, 2012 1:20:33 AM2012-03-12Monday, March 12, 2012 1:45:00 AM2012-03-13Tuesday, March 13, 2012 1:09:27 AM2012-03-14Wednesday, March 14, 2012 12:33:54 AM2012-03-14Wednesday, March 14, 2012 11:58:21 PM2012-03-15Thursday, March 15, 2012 11:22:48 PM2012-03-16Friday, March 16, 2012 10:47:15 PM2012-03-17Saturday, March 17, 2012 10:11:42 PM2012-03-18Sunday, March 18, 2012 9:36:09 PM2012-03-19Monday, March 19, 2012 9:00:36 PM2012-03-20Tuesday, March 20, 2012 8:25:03 PM2012-03-21Wednesday, March 21, 2012 7:49:29 PM2012-03-22Thursday, March 22, 2012 7:13:56 PM2012-03-23Friday, March 23, 2012 6:38:23 PM2012-03-24Saturday, March 24, 2012 6:02:50 PM2012-03-25Sunday, March 25, 2012 5:27:17 PM2012-03-26Monday, March 26, 2012 4:51:44 PM2012-03-27Tuesday, March 27, 2012 4:16:11 PM2012-03-28Wednesday, March 28, 2012 3:40:38 PM2012-03-29Thursday, March 29, 2012 3:05:05 PM2012-03-30Friday, March 30, 2012 2:29:32 PM2012-03-31Saturday, March 31, 2012 1:53:59 PM2012-04-01Sunday, April 01, 2012 1:18:26 PM2012-04-02Monday, April 02, 2012 12:42:53 PM2012-04-03Tuesday, April 03, 2012 12:07:20 PM2012-04-04Wednesday, April 04, 2012 11:31:47 AM2012-04-05Thursday, April 05, 2012 10:56:14 AM2012-04-06Friday, April 06, 2012 10:20:41 AM2012-04-07Saturday, April 07, 2012 9:45:08 AM2012-04-08Sunday, April 08, 2012 9:09:35 AM2012-04-09Monday, April 09, 2012 8:34:02 AM2012-04-10Tuesday, April 10, 2012 7:58:29 AM2012-04-11Wednesday, April 11, 2012 7:22:56 AM2012-04-12Thursday, April 12, 2012 6:47:23 AM2012-04-13Friday, April 13, 2012 6:11:49 AM2012-04-14Saturday, April 14, 2012 5:36:16 AM2012-04-15Sunday, April 15, 2012 5:00:43 AM2012-04-16Monday, April 16, 2012 4:25:10 AM2012-04-17Tuesday, April 17, 2012 3:49:37 AM2012-04-18Wednesday, April 18, 2012 3:14:04 AM2012-04-19Thursday, April 19, 2012 2:38:31 AM2012-04-20Friday, April 20, 2012 2:02:58 AM2012-04-21Saturday, April 21, 2012 1:27:25 AM2012-04-22Sunday, April 22, 2012 12:51:52 AM2012-04-23Monday, April 23, 2012 12:16:19 AM2012-04-23Monday, April 23, 2012 11:40:46 PM2012-04-24Tuesday, April 24, 2012 11:05:13 PM2012-04-25Wednesday, April 25, 2012 10:29:40 PM2012-04-26Thursday, April 26, 2012 9:54:07 PM2012-04-27Friday, April 27, 2012 9:18:34 PM2012-04-28Saturday, April 28, 2012 8:43:01 PM2012-04-29Sunday, April 29, 2012 8:07:28 PM2012-04-30Monday, April 30, 2012 7:31:55 PM2012-05-01Tuesday, May 01, 2012 6:56:22 PM2012-05-02Wednesday, May 02, 2012 6:20:49 PM2012-05-03Thursday, May 03, 2012 5:45:16 PM2012-05-04Friday, May 04, 2012 5:09:43 PM2012-05-05Saturday, May 05, 2012 4:34:09 PM2012-05-06Sunday, May 06, 2012 3:58:36 PM2012-05-07Monday, May 07, 2012 3:23:03 PM2012-05-08Tuesday, May 08, 2012 2:47:30 PM2012-05-09Wednesday, May 09, 2012 2:11:57 PM2012-05-10Thursday, May 10, 2012 1:36:24 PM2012-05-11Friday, May 11, 2012 1:00:51 PM2012-05-12Saturday, May 12, 2012 12:25:18 PM2012-05-13Sunday, May 13, 2012 11:49:45 AM2012-05-14Monday, May 14, 2012 11:14:12 AM2012-05-15Tuesday, May 15, 2012 10:38:39 AM2012-05-16Wednesday, May 16, 2012 10:03:06 AM2012-05-17Thursday, May 17, 2012 9:27:33 AM2012-05-18Friday, May 18, 2012 8:52:00 AM2012-05-19Saturday, May 19, 2012 8:16:27 AM2012-05-20Sunday, May 20, 2012 7:40:54 AM2012-05-21Monday, May 21, 2012 7:05:21 AM2012-05-22Tuesday, May 22, 2012 6:29:48 AM2012-05-23Wednesday, May 23, 2012 5:54:15 AM2012-05-24Thursday, May 24, 2012 5:18:42 AM2012-05-25Friday, May 25, 2012 4:43:09 AM2012-05-26Saturday, May 26, 2012 4:07:36 AM2012-05-27Sunday, May 27, 2012 3:32:02 AM2012-05-28Monday, May 28, 2012 2:56:29 AM2012-05-29Tuesday, May 29, 2012 2:20:56 AM2012-05-30Wednesday, May 30, 2012 1:45:23 AM2012-05-31Thursday, May 31, 2012 1:09:50 AM2012-06-01Friday, June 01, 2012 12:34:17 AM2012-06-01Friday, June 01, 2012 11:58:44 PM2012-06-02Saturday, June 02, 2012 11:23:11 PM2012-06-03Sunday, June 03, 2012 10:47:38 PM2012-06-04Monday, June 04, 2012 10:12:05 PM2012-06-05Tuesday, June 05, 2012 9:36:32 PM2012-06-06Wednesday, June 06, 2012 9:00:59 PM2012-06-07Thursday, June 07, 2012 8:25:26 PM2012-06-08Friday, June 08, 2012 7:49:53 PM2012-06-09Saturday, June 09, 2012 7:14:20 PM2012-06-10Sunday, June 10, 2012 6:38:47 PM2012-06-11Monday, June 11, 2012 6:03:14 PM2012-06-12Tuesday, June 12, 2012 5:27:41 PM2012-06-13Wednesday, June 13, 2012 4:52:08 PM2012-06-14Thursday, June 14, 2012 4:16:35 PM2012-06-15Friday, June 15, 2012 3:41:02 PM2012-06-16Saturday, June 16, 2012 3:05:29 PM2012-06-17Sunday, June 17, 2012 2:29:56 PM2012-06-18Monday, June 18, 2012 1:54:22 PM2012-06-19Tuesday, June 19, 2012 1:18:49 PM2012-06-20Wednesday, June 20, 2012 12:43:16 PM2012-06-21Thursday, June 21, 2012 12:07:43 PM2012-06-22Friday, June 22, 2012 11:32:10 AM2012-06-23Saturday, June 23, 2012 10:56:37 AM2012-06-24Sunday, June 24, 2012 10:21:04 AM2012-06-25Monday, June 25, 2012 9:45:31 AM2012-06-26Tuesday, June 26, 2012 9:09:58 AM2012-06-27Wednesday, June 27, 2012 8:34:25 AM2012-06-28Thursday, June 28, 2012 7:58:52 AM2012-06-29Friday, June 29, 2012 7:23:19 AM2012-06-30Saturday, June 30, 2012 6:47:46 AM2012-07-01Sunday, July 01, 2012 6:12:13 AM2012-07-02Monday, July 02, 2012 5:36:40 AM2012-07-03Tuesday, July 03, 2012 5:01:07 AM2012-07-04Wednesday, July 04, 2012 4:25:34 AM2012-07-05Thursday, July 05, 2012 3:50:01 AM2012-07-06Friday, July 06, 2012 3:14:28 AM2012-07-07Saturday, July 07, 2012 2:38:55 AM2012-07-08Sunday, July 08, 2012 2:03:22 AM2012-07-09Monday, July 09, 2012 1:27:49 AM2012-07-10Tuesday, July 10, 2012 12:52:16 AM2012-07-11Wednesday, July 11, 2012 12:16:42 AM2012-07-11Wednesday, July 11, 2012 11:41:09 PM2012-07-12Thursday, July 12, 2012 11:05:36 PM2012-07-13Friday, July 13, 2012 10:30:03 PM2012-07-14Saturday, July 14, 2012 9:54:30 PM2012-07-15Sunday, July 15, 2012 9:18:57 PM2012-07-16Monday, July 16, 2012 8:43:24 PM2012-07-17Tuesday, July 17, 2012 8:07:51 PM2012-07-18Wednesday, July 18, 2012 7:32:18 PM2012-07-19Thursday, July 19, 2012 6:56:45 PM2012-07-20Friday, July 20, 2012 6:21:12 PM2012-07-21Saturday, July 21, 2012 5:45:39 PM2012-07-22Sunday, July 22, 2012 5:10:06 PM2012-07-23Monday, July 23, 2012 4:34:33 PM2012-07-24Tuesday, July 24, 2012 3:59:00 PM2012-07-25Wednesday, July 25, 2012 3:23:27 PM2012-07-26Thursday, July 26, 2012 2:47:54 PM2012-07-27Friday, July 27, 2012 2:12:21 PM2012-07-28Saturday, July 28, 2012 1:36:48 PM2012-07-29Sunday, July 29, 2012 1:01:15 PM2012-07-30Monday, July 30, 2012 12:25:42 PM2012-07-31Tuesday, July 31, 2012 11:50:09 AM2012-08-01Wednesday, August 01, 2012 11:14:35 AM2012-08-02Thursday, August 02, 2012 10:39:02 AM2012-08-03Friday, August 03, 2012 10:03:29 AM2012-08-04Saturday, August 04, 2012 9:27:56 AM2012-08-05Sunday, August 05, 2012 8:52:23 AM2012-08-06Monday, August 06, 2012 8:16:50 AM2012-08-07Tuesday, August 07, 2012 7:41:17 AM2012-08-08Wednesday, August 08, 2012 7:05:44 AM2012-08-09Thursday, August 09, 2012 6:30:11 AM2012-08-10Friday, August 10, 2012 5:54:38 AM2012-08-11Saturday, August 11, 2012 5:19:05 AM2012-08-12Sunday, August 12, 2012 4:43:32 AM2012-08-13Monday, August 13, 2012 4:07:59 AM2012-08-14Tuesday, August 14, 2012 3:32:26 AM2012-08-15Wednesday, August 15, 2012 2:56:53 AM2012-08-16Thursday, August 16, 2012 2:21:20 AM2012-08-17Friday, August 17, 2012 1:45:47 AM2012-08-18Saturday, August 18, 2012 1:10:14 AM2012-08-19Sunday, August 19, 2012 12:34:41 AM2012-08-19Sunday, August 19, 2012 11:59:08 PM2012-08-20Monday, August 20, 2012 11:23:35 PM2012-08-21Tuesday, August 21, 2012 10:48:02 PM2012-08-22Wednesday, August 22, 2012 10:12:29 PM2012-08-23Thursday, August 23, 2012 9:36:55 PM2012-08-24Friday, August 24, 2012 9:01:22 PM2012-08-25Saturday, August 25, 2012 8:25:49 PM2012-08-26Sunday, August 26, 2012 7:50:16 PM2012-08-27Monday, August 27, 2012 7:14:43 PM2012-08-28Tuesday, August 28, 2012 6:39:10 PM2012-08-29Wednesday, August 29, 2012 6:03:37 PM2012-08-30Thursday, August 30, 2012 5:28:04 PM2012-08-31Friday, August 31, 2012 4:52:31 PM2012-09-01Saturday, September 01, 2012 4:16:58 PM2012-09-02Sunday, September 02, 2012 3:41:25 PM2012-09-03Monday, September 03, 2012 3:05:52 PM2012-09-04Tuesday, September 04, 2012 2:30:19 PM2012-09-05Wednesday, September 05, 2012 1:54:46 PM2012-09-06Thursday, September 06, 2012 1:19:13 PM2012-09-07Friday, September 07, 2012 12:43:40 PM2012-09-08Saturday, September 08, 2012 12:08:07 PM2012-09-09Sunday, September 09, 2012 11:32:34 AM2012-09-10Monday, September 10, 2012 10:57:01 AM2012-09-11Tuesday, September 11, 2012 10:21:28 AM2012-09-12Wednesday, September 12, 2012 9:45:55 AM2012-09-13Thursday, September 13, 2012 9:10:22 AM2012-09-14Friday, September 14, 2012 8:34:49 AM2012-09-15Saturday, September 15, 2012 7:59:15 AM2012-09-16Sunday, September 16, 2012 7:23:42 AM2012-09-17Monday, September 17, 2012 6:48:09 AM2012-09-18Tuesday, September 18, 2012 6:12:36 AM2012-09-19Wednesday, September 19, 2012 5:37:03 AM2012-09-20Thursday, September 20, 2012 5:01:30 AM2012-09-21Friday, September 21, 2012 4:25:57 AM2012-09-22Saturday, September 22, 2012 3:50:24 AM2012-09-23Sunday, September 23, 2012 3:14:51 AM2012-09-24Monday, September 24, 2012 2:39:18 AM2012-09-25Tuesday, September 25, 2012 2:03:45 AM2012-09-26Wednesday, September 26, 2012 1:28:12 AM2012-09-27Thursday, September 27, 2012 12:52:39 AM2012-09-28Friday, September 28, 2012 12:17:06 AM2012-09-28Friday, September 28, 2012 11:41:33 PM2012-09-29Saturday, September 29, 2012 11:06:00 PM2012-09-30Sunday, September 30, 2012 10:30:27 PM2012-10-01Monday, October 01, 2012 9:54:54 PM2012-10-02Tuesday, October 02, 2012 9:19:21 PM2012-10-03Wednesday, October 03, 2012 8:43:48 PM2012-10-04Thursday, October 04, 2012 8:08:15 PM2012-10-05Friday, October 05, 2012 7:32:42 PM2012-10-06Saturday, October 06, 2012 6:57:09 PM2012-10-07Sunday, October 07, 2012 6:21:35 PM2012-10-08Monday, October 08, 2012 5:46:02 PM2012-10-09Tuesday, October 09, 2012 5:10:29 PM2012-10-10Wednesday, October 10, 2012 4:34:56 PM2012-10-11Thursday, October 11, 2012 3:59:23 PM2012-10-12Friday, October 12, 2012 3:23:50 PM2012-10-13Saturday, October 13, 2012 2:48:17 PM2012-10-14Sunday, October 14, 2012 2:12:44 PM2012-10-15Monday, October 15, 2012 1:37:11 PM2012-10-16Tuesday, October 16, 2012 1:01:38 PM2012-10-17Wednesday, October 17, 2012 12:26:05 PM2012-10-18Thursday, October 18, 2012 11:50:32 AM2012-10-19Friday, October 19, 2012 11:14:59 AM2012-10-20Saturday, October 20, 2012 10:39:26 AM2012-10-21Sunday, October 21, 2012 10:03:53 AM2012-10-22Monday, October 22, 2012 9:28:20 AM2012-10-23Tuesday, October 23, 2012 8:52:47 AM2012-10-24Wednesday, October 24, 2012 8:17:14 AM2012-10-25Thursday, October 25, 2012 7:41:41 AM2012-10-26Friday, October 26, 2012 7:06:08 AM2012-10-27Saturday, October 27, 2012 6:30:35 AM2012-10-28Sunday, October 28, 2012 5:55:02 AM2012-10-29Monday, October 29, 2012 5:19:28 AM2012-10-30Tuesday, October 30, 2012 4:43:55 AM2012-10-31Wednesday, October 31, 2012 4:08:22 AM2012-11-01Thursday, November 01, 2012 3:32:49 AM2012-11-02Friday, November 02, 2012 2:57:16 AM2012-11-03Saturday, November 03, 2012 2:21:43 AM2012-11-04Sunday, November 04, 2012 1:46:10 AM2012-11-05Monday, November 05, 2012 12:10:37 AM2012-11-05Monday, November 05, 2012 11:35:04 PM2012-11-06Tuesday, November 06, 2012 10:59:31 PM2012-11-07Wednesday, November 07, 2012 10:23:58 PM2012-11-08Thursday, November 08, 2012 9:48:25 PM2012-11-09Friday, November 09, 2012 9:12:52 PM2012-11-10Saturday, November 10, 2012 8:37:19 PM2012-11-11Sunday, November 11, 2012 8:01:46 PM2012-11-12Monday, November 12, 2012 7:26:13 PM2012-11-13Tuesday, November 13, 2012 6:50:40 PM2012-11-14Wednesday, November 14, 2012 6:15:07 PM2012-11-15Thursday, November 15, 2012 5:39:34 PM2012-11-16Friday, November 16, 2012 5:04:01 PM2012-11-17Saturday, November 17, 2012 4:28:28 PM2012-11-18Sunday, November 18, 2012 3:52:55 PM2012-11-19Monday, November 19, 2012 3:17:22 PM2012-11-20Tuesday, November 20, 2012 2:41:48 PM2012-11-21Wednesday, November 21, 2012 2:06:15 PM2012-11-22Thursday, November 22, 2012 1:30:42 PM2012-11-23Friday, November 23, 2012 12:55:09 PM2012-11-24Saturday, November 24, 2012 12:19:36 PM2012-11-25Sunday, November 25, 2012 11:44:03 AM2012-11-26Monday, November 26, 2012 11:08:30 AM2012-11-27Tuesday, November 27, 2012 10:32:57 AM2012-11-28Wednesday, November 28, 2012 9:57:24 AM2012-11-29Thursday, November 29, 2012 9:21:51 AM2012-11-30Friday, November 30, 2012 8:46:18 AM2012-12-01Saturday, December 01, 2012 8:10:45 AM2012-12-02Sunday, December 02, 2012 7:35:12 AM2012-12-03Monday, December 03, 2012 6:59:39 AM2012-12-04Tuesday, December 04, 2012 6:24:06 AM2012-12-05Wednesday, December 05, 2012 5:48:33 AM2012-12-06Thursday, December 06, 2012 5:13:00 AM2012-12-07Friday, December 07, 2012 4:37:27 AM2012-12-08Saturday, December 08, 2012 4:01:54 AM2012-12-09Sunday, December 09, 2012 3:26:21 AM2012-12-10Monday, December 10, 2012 2:50:48 AM2012-12-11Tuesday, December 11, 2012 2:15:15 AM2012-12-12Wednesday, December 12, 2012 1:39:42 AM2012-12-13Thursday, December 13, 2012 1:04:08 AM2012-12-14Friday, December 14, 2012 12:28:35 AM2012-12-14Friday, December 14, 2012 11:53:02 PM2012-12-15Saturday, December 15, 2012 11:17:29 PM2012-12-16Sunday, December 16, 2012 10:41:56 PM2012-12-17Monday, December 17, 2012 10:06:23 PM2012-12-18Tuesday, December 18, 2012 9:30:50 PM2012-12-19Wednesday, December 19, 2012 8:55:17 PM2012-12-20Thursday, December 20, 2012 8:19:44 PM2012-12-21Friday, December 21, 2012 7:44:11 PM2012-12-22Saturday, December 22, 2012 7:08:38 PM2012-12-23Sunday, December 23, 2012 6:33:05 PM2012-12-24Monday, December 24, 2012 5:57:32 PM2012-12-25Tuesday, December 25, 2012 5:21:59 PM2012-12-26Wednesday, December 26, 2012 4:46:26 PM2012-12-27Thursday, December 27, 2012 4:10:53 PM2012-12-28Friday, December 28, 2012 3:35:20 PM2012-12-29Saturday, December 29, 2012 2:59:47 PM2012-12-30Sunday, December 30, 2012 2:24:14 PM2012-12-31Monday, December 31, 2012 1:48:41 PM2013-01-01Tuesday, January 01, 2013 1:13:08 PM2013-01-02Wednesday, January 02, 2013 12:37:35 PM2013-01-03Thursday, January 03, 2013 12:02:02 PM2013-01-04Friday, January 04, 2013 11:26:28 AM2013-01-05Saturday, January 05, 2013 10:50:55 AM2013-01-06Sunday, January 06, 2013 10:15:22 AM2013-01-07Monday, January 07, 2013 9:39:49 AM2013-01-08Tuesday, January 08, 2013 9:04:16 AM2013-01-09Wednesday, January 09, 2013 8:28:43 AM2013-01-10Thursday, January 10, 2013 7:53:10 AM2013-01-11Friday, January 11, 2013 7:17:37 AM2013-01-12Saturday, January 12, 2013 6:42:04 AM2013-01-13Sunday, January 13, 2013 6:06:31 AM2013-01-14Monday, January 14, 2013 5:30:58 AM2013-01-15Tuesday, January 15, 2013 4:55:25 AM2013-01-16Wednesday, January 16, 2013 4:19:52 AM2013-01-17Thursday, January 17, 2013 3:44:19 AM2013-01-18Friday, January 18, 2013 3:08:46 AM2013-01-19Saturday, January 19, 2013 2:33:13 AM2013-01-20Sunday, January 20, 2013 1:57:40 AM2013-01-21Monday, January 21, 2013 1:22:07 AM2013-01-22Tuesday, January 22, 2013 12:46:34 AM2013-01-23Wednesday, January 23, 2013 12:11:01 AM2013-01-23Wednesday, January 23, 2013 11:35:28 PM2013-01-24Thursday, January 24, 2013 10:59:55 PM2013-01-25Friday, January 25, 2013 10:24:21 PM2013-01-26Saturday, January 26, 2013 9:48:48 PM2013-01-27Sunday, January 27, 2013 9:13:15 PM2013-01-28Monday, January 28, 2013 8:37:42 PM2013-01-29Tuesday, January 29, 2013 8:02:09 PM2013-01-30Wednesday, January 30, 2013 7:26:36 PM2013-01-31Thursday, January 31, 2013 6:51:03 PM2013-02-01Friday, February 01, 2013 6:15:30 PM2013-02-02Saturday, February 02, 2013 5:39:57 PM2013-02-03Sunday, February 03, 2013 5:04:24 PM2013-02-04Monday, February 04, 2013 4:28:51 PM2013-02-05Tuesday, February 05, 2013 3:53:18 PM2013-02-06Wednesday, February 06, 2013 3:17:45 PM2013-02-07Thursday, February 07, 2013 2:42:12 PM2013-02-08Friday, February 08, 2013 2:06:39 PM2013-02-09Saturday, February 09, 2013 1:31:06 PM2013-02-10Sunday, February 10, 2013 12:55:33 PM2013-02-11Monday, February 11, 2013 12:20:00 PM2013-02-12Tuesday, February 12, 2013 11:44:27 AM2013-02-13Wednesday, February 13, 2013 11:08:54 AM2013-02-14Thursday, February 14, 2013 10:33:21 AM2013-02-15Friday, February 15, 2013 9:57:48 AM2013-02-16Saturday, February 16, 2013 9:22:15 AM2013-02-17Sunday, February 17, 2013 8:46:41 AM2013-02-18Monday, February 18, 2013 8:11:08 AM2013-02-19Tuesday, February 19, 2013 7:35:35 AM2013-02-20Wednesday, February 20, 2013 7:00:02 AM2013-02-21Thursday, February 21, 2013 6:24:29 AM2013-02-22Friday, February 22, 2013 5:48:56 AM2013-02-23Saturday, February 23, 2013 5:13:23 AM2013-02-24Sunday, February 24, 2013 4:37:50 AM2013-02-25Monday, February 25, 2013 4:02:17 AM2013-02-26Tuesday, February 26, 2013 3:26:44 AM2013-02-27Wednesday, February 27, 2013 2:51:11 AM2013-02-28Thursday, February 28, 2013 2:15:38 AM2013-03-01Friday, March 01, 2013 1:40:05 AM2013-03-02Saturday, March 02, 2013 1:04:32 AM2013-03-03Sunday, March 03, 2013 12:28:59 AM2013-03-03Sunday, March 03, 2013 11:53:26 PM2013-03-04Monday, March 04, 2013 11:17:53 PM2013-03-05Tuesday, March 05, 2013 10:42:20 PM2013-03-06Wednesday, March 06, 2013 10:06:47 PM2013-03-07Thursday, March 07, 2013 9:31:14 PM2013-03-08Friday, March 08, 2013 8:55:41 PM2013-03-09Saturday, March 09, 2013 8:20:08 PM2013-03-10Sunday, March 10, 2013 8:44:35 PM2013-03-11Monday, March 11, 2013 8:09:01 PM2013-03-12Tuesday, March 12, 2013 7:33:28 PM2013-03-13Wednesday, March 13, 2013 6:57:55 PM2013-03-14Thursday, March 14, 2013 6:22:22 PM2013-03-15Friday, March 15, 2013 5:46:49 PM2013-03-16Saturday, March 16, 2013 5:11:16 PM2013-03-17Sunday, March 17, 2013 4:35:43 PM2013-03-18Monday, March 18, 2013 4:00:10 PM2013-03-19Tuesday, March 19, 2013 3:24:37 PM2013-03-20Wednesday, March 20, 2013 2:49:04 PM2013-03-21Thursday, March 21, 2013 2:13:31 PM2013-03-22Friday, March 22, 2013 1:37:58 PM2013-03-23Saturday, March 23, 2013 1:02:25 PM2013-03-24Sunday, March 24, 2013 12:26:52 PM2013-03-25Monday, March 25, 2013 11:51:19 AM2013-03-26Tuesday, March 26, 2013 11:15:46 AM2013-03-27Wednesday, March 27, 2013 10:40:13 AM2013-03-28Thursday, March 28, 2013 10:04:40 AM2013-03-29Friday, March 29, 2013 9:29:07 AM2013-03-30Saturday, March 30, 2013 8:53:34 AM2013-03-31Sunday, March 31, 2013 8:18:01 AM2013-04-01Monday, April 01, 2013 7:42:28 AM2013-04-02Tuesday, April 02, 2013 7:06:54 AM2013-04-03Wednesday, April 03, 2013 6:31:21 AM2013-04-04Thursday, April 04, 2013 5:55:48 AM2013-04-05Friday, April 05, 2013 5:20:15 AM2013-04-06Saturday, April 06, 2013 4:44:42 AM2013-04-07Sunday, April 07, 2013 4:09:09 AM2013-04-08Monday, April 08, 2013 3:33:36 AM2013-04-09Tuesday, April 09, 2013 2:58:03 AM2013-04-10Wednesday, April 10, 2013 2:22:30 AM2013-04-11Thursday, April 11, 2013 1:46:57 AM2013-04-12Friday, April 12, 2013 1:11:24 AM2013-04-13Saturday, April 13, 2013 12:35:51 AM2013-04-14Sunday, April 14, 2013 12:00:18 AM2013-04-14Sunday, April 14, 2013 11:24:45 PM2013-04-15Monday, April 15, 2013 10:49:12 PM2013-04-16Tuesday, April 16, 2013 10:13:39 PM2013-04-17Wednesday, April 17, 2013 9:38:06 PM2013-04-18Thursday, April 18, 2013 9:02:33 PM2013-04-19Friday, April 19, 2013 8:27:00 PM2013-04-20Saturday, April 20, 2013 7:51:27 PM2013-04-21Sunday, April 21, 2013 7:15:54 PM2013-04-22Monday, April 22, 2013 6:40:21 PM2013-04-23Tuesday, April 23, 2013 6:04:48 PM2013-04-24Wednesday, April 24, 2013 5:29:14 PM2013-04-25Thursday, April 25, 2013 4:53:41 PM2013-04-26Friday, April 26, 2013 4:18:08 PM2013-04-27Saturday, April 27, 2013 3:42:35 PM2013-04-28Sunday, April 28, 2013 3:07:02 PM2013-04-29Monday, April 29, 2013 2:31:29 PM2013-04-30Tuesday, April 30, 2013 1:55:56 PM2013-05-01Wednesday, May 01, 2013 1:20:23 PM2013-05-02Thursday, May 02, 2013 12:44:50 PM2013-05-03Friday, May 03, 2013 12:09:17 PM2013-05-04Saturday, May 04, 2013 11:33:44 AM2013-05-05Sunday, May 05, 2013 10:58:11 AM2013-05-06Monday, May 06, 2013 10:22:38 AM2013-05-07Tuesday, May 07, 2013 9:47:05 AM2013-05-08Wednesday, May 08, 2013 9:11:32 AM2013-05-09Thursday, May 09, 2013 8:35:59 AM2013-05-10Friday, May 10, 2013 8:00:26 AM2013-05-11Saturday, May 11, 2013 7:24:53 AM2013-05-12Sunday, May 12, 2013 6:49:20 AM2013-05-13Monday, May 13, 2013 6:13:47 AM2013-05-14Tuesday, May 14, 2013 5:38:14 AM2013-05-15Wednesday, May 15, 2013 5:02:41 AM2013-05-16Thursday, May 16, 2013 4:27:08 AM2013-05-17Friday, May 17, 2013 3:51:34 AM2013-05-18Saturday, May 18, 2013 3:16:01 AM2013-05-19Sunday, May 19, 2013 2:40:28 AM2013-05-20Monday, May 20, 2013 2:04:55 AM2013-05-21Tuesday, May 21, 2013 1:29:22 AM2013-05-22Wednesday, May 22, 2013 12:53:49 AM2013-05-23Thursday, May 23, 2013 12:18:16 AM2013-05-23Thursday, May 23, 2013 11:42:43 PM2013-05-24Friday, May 24, 2013 11:07:10 PM2013-05-25Saturday, May 25, 2013 10:31:37 PM2013-05-26Sunday, May 26, 2013 9:56:04 PM2013-05-27Monday, May 27, 2013 9:20:31 PM2013-05-28Tuesday, May 28, 2013 8:44:58 PM2013-05-29Wednesday, May 29, 2013 8:09:25 PM2013-05-30Thursday, May 30, 2013 7:33:52 PM2013-05-31Friday, May 31, 2013 6:58:19 PM2013-06-01Saturday, June 01, 2013 6:22:46 PM2013-06-02Sunday, June 02, 2013 5:47:13 PM2013-06-03Monday, June 03, 2013 5:11:40 PM2013-06-04Tuesday, June 04, 2013 4:36:07 PM2013-06-05Wednesday, June 05, 2013 4:00:34 PM2013-06-06Thursday, June 06, 2013 3:25:01 PM2013-06-07Friday, June 07, 2013 2:49:28 PM2013-06-08Saturday, June 08, 2013 2:13:54 PM2013-06-09Sunday, June 09, 2013 1:38:21 PM2013-06-10Monday, June 10, 2013 1:02:48 PM2013-06-11Tuesday, June 11, 2013 12:27:15 PM2013-06-12Wednesday, June 12, 2013 11:51:42 AM2013-06-13Thursday, June 13, 2013 11:16:09 AM2013-06-14Friday, June 14, 2013 10:40:36 AM2013-06-15Saturday, June 15, 2013 10:05:03 AM2013-06-16Sunday, June 16, 2013 9:29:30 AM2013-06-17Monday, June 17, 2013 8:53:57 AM2013-06-18Tuesday, June 18, 2013 8:18:24 AM2013-06-19Wednesday, June 19, 2013 7:42:51 AM2013-06-20Thursday, June 20, 2013 7:07:18 AM2013-06-21Friday, June 21, 2013 6:31:45 AM2013-06-22Saturday, June 22, 2013 5:56:12 AM2013-06-23Sunday, June 23, 2013 5:20:39 AM2013-06-24Monday, June 24, 2013 4:45:06 AM2013-06-25Tuesday, June 25, 2013 4:09:33 AM2013-06-26Wednesday, June 26, 2013 3:34:00 AM2013-06-27Thursday, June 27, 2013 2:58:27 AM2013-06-28Friday, June 28, 2013 2:22:54 AM2013-06-29Saturday, June 29, 2013 1:47:21 AM2013-06-30Sunday, June 30, 2013 1:11:47 AM2013-07-01Monday, July 01, 2013 12:36:14 AM2013-07-02Tuesday, July 02, 2013 12:00:41 AM2013-07-02Tuesday, July 02, 2013 11:25:08 PM2013-07-03Wednesday, July 03, 2013 10:49:35 PM2013-07-04Thursday, July 04, 2013 10:14:02 PM2013-07-05Friday, July 05, 2013 9:38:29 PM2013-07-06Saturday, July 06, 2013 9:02:56 PM2013-07-07Sunday, July 07, 2013 8:27:23 PM2013-07-08Monday, July 08, 2013 7:51:50 PM2013-07-09Tuesday, July 09, 2013 7:16:17 PM2013-07-10Wednesday, July 10, 2013 6:40:44 PM2013-07-11Thursday, July 11, 2013 6:05:11 PM2013-07-12Friday, July 12, 2013 5:29:38 PM2013-07-13Saturday, July 13, 2013 4:54:05 PM2013-07-14Sunday, July 14, 2013 4:18:32 PM2013-07-15Monday, July 15, 2013 3:42:59 PM2013-07-16Tuesday, July 16, 2013 3:07:26 PM2013-07-17Wednesday, July 17, 2013 2:31:53 PM2013-07-18Thursday, July 18, 2013 1:56:20 PM2013-07-19Friday, July 19, 2013 1:20:47 PM2013-07-20Saturday, July 20, 2013 12:45:14 PM2013-07-21Sunday, July 21, 2013 12:09:41 PM2013-07-22Monday, July 22, 2013 11:34:07 AM2013-07-23Tuesday, July 23, 2013 10:58:34 AM2013-07-24Wednesday, July 24, 2013 10:23:01 AM2013-07-25Thursday, July 25, 2013 9:47:28 AM2013-07-26Friday, July 26, 2013 9:11:55 AM2013-07-27Saturday, July 27, 2013 8:36:22 AM2013-07-28Sunday, July 28, 2013 8:00:49 AM2013-07-29Monday, July 29, 2013 7:25:16 AM2013-07-30Tuesday, July 30, 2013 6:49:43 AM2013-07-31Wednesday, July 31, 2013 6:14:10 AM2013-08-01Thursday, August 01, 2013 5:38:37 AM2013-08-02Friday, August 02, 2013 5:03:04 AM2013-08-03Saturday, August 03, 2013 4:27:31 AM2013-08-04Sunday, August 04, 2013 3:51:58 AM2013-08-05Monday, August 05, 2013 3:16:25 AM2013-08-06Tuesday, August 06, 2013 2:40:52 AM2013-08-07Wednesday, August 07, 2013 2:05:19 AM2013-08-08Thursday, August 08, 2013 1:29:46 AM2013-08-09Friday, August 09, 2013 12:54:13 AM2013-08-10Saturday, August 10, 2013 12:18:40 AM2013-08-10Saturday, August 10, 2013 11:43:07 PM2013-08-11Sunday, August 11, 2013 11:07:34 PM2013-08-12Monday, August 12, 2013 10:32:01 PM2013-08-13Tuesday, August 13, 2013 9:56:27 PM2013-08-14Wednesday, August 14, 2013 9:20:54 PM2013-08-15Thursday, August 15, 2013 8:45:21 PM2013-08-16Friday, August 16, 2013 8:09:48 PM2013-08-17Saturday, August 17, 2013 7:34:15 PM2013-08-18Sunday, August 18, 2013 6:58:42 PM2013-08-19Monday, August 19, 2013 6:23:09 PM2013-08-20Tuesday, August 20, 2013 5:47:36 PM2013-08-21Wednesday, August 21, 2013 5:12:03 PM2013-08-22Thursday, August 22, 2013 4:36:30 PM2013-08-23Friday, August 23, 2013 4:00:57 PM2013-08-24Saturday, August 24, 2013 3:25:24 PM2013-08-25Sunday, August 25, 2013 2:49:51 PM2013-08-26Monday, August 26, 2013 2:14:18 PM2013-08-27Tuesday, August 27, 2013 1:38:45 PM2013-08-28Wednesday, August 28, 2013 1:03:12 PM2013-08-29Thursday, August 29, 2013 12:27:39 PM2013-08-30Friday, August 30, 2013 11:52:06 AM2013-08-31Saturday, August 31, 2013 11:16:33 AM2013-09-01Sunday, September 01, 2013 10:41:00 AM2013-09-02Monday, September 02, 2013 10:05:27 AM2013-09-03Tuesday, September 03, 2013 9:29:54 AM2013-09-04Wednesday, September 04, 2013 8:54:21 AM2013-09-05Thursday, September 05, 2013 8:18:47 AM2013-09-06Friday, September 06, 2013 7:43:14 AM2013-09-07Saturday, September 07, 2013 7:07:41 AM2013-09-08Sunday, September 08, 2013 6:32:08 AM2013-09-09Monday, September 09, 2013 5:56:35 AM2013-09-10Tuesday, September 10, 2013 5:21:02 AM2013-09-11Wednesday, September 11, 2013 4:45:29 AM2013-09-12Thursday, September 12, 2013 4:09:56 AM2013-09-13Friday, September 13, 2013 3:34:23 AM2013-09-14Saturday, September 14, 2013 2:58:50 AM2013-09-15Sunday, September 15, 2013 2:23:17 AM2013-09-16Monday, September 16, 2013 1:47:44 AM2013-09-17Tuesday, September 17, 2013 1:12:11 AM2013-09-18Wednesday, September 18, 2013 12:36:38 AM2013-09-19Thursday, September 19, 2013 12:01:05 AM2013-09-19Thursday, September 19, 2013 11:25:32 PM2013-09-20Friday, September 20, 2013 10:49:59 PM2013-09-21Saturday, September 21, 2013 10:14:26 PM2013-09-22Sunday, September 22, 2013 9:38:53 PM2013-09-23Monday, September 23, 2013 9:03:20 PM2013-09-24Tuesday, September 24, 2013 8:27:47 PM2013-09-25Wednesday, September 25, 2013 7:52:14 PM2013-09-26Thursday, September 26, 2013 7:16:40 PM2013-09-27Friday, September 27, 2013 6:41:07 PM2013-09-28Saturday, September 28, 2013 6:05:34 PM2013-09-29Sunday, September 29, 2013 5:30:01 PM2013-09-30Monday, September 30, 2013 4:54:28 PM2013-10-01Tuesday, October 01, 2013 4:18:55 PM2013-10-02Wednesday, October 02, 2013 3:43:22 PM2013-10-03Thursday, October 03, 2013 3:07:49 PM2013-10-04Friday, October 04, 2013 2:32:16 PM2013-10-05Saturday, October 05, 2013 1:56:43 PM2013-10-06Sunday, October 06, 2013 1:21:10 PM2013-10-07Monday, October 07, 2013 12:45:37 PM2013-10-08Tuesday, October 08, 2013 12:10:04 PM2013-10-09Wednesday, October 09, 2013 11:34:31 AM2013-10-10Thursday, October 10, 2013 10:58:58 AM2013-10-11Friday, October 11, 2013 10:23:25 AM2013-10-12Saturday, October 12, 2013 9:47:52 AM2013-10-13Sunday, October 13, 2013 9:12:19 AM2013-10-14Monday, October 14, 2013 8:36:46 AM2013-10-15Tuesday, October 15, 2013 8:01:13 AM2013-10-16Wednesday, October 16, 2013 7:25:40 AM2013-10-17Thursday, October 17, 2013 6:50:07 AM2013-10-18Friday, October 18, 2013 6:14:34 AM2013-10-19Saturday, October 19, 2013 5:39:00 AM2013-10-20Sunday, October 20, 2013 5:03:27 AM2013-10-21Monday, October 21, 2013 4:27:54 AM2013-10-22Tuesday, October 22, 2013 3:52:21 AM2013-10-23Wednesday, October 23, 2013 3:16:48 AM2013-10-24Thursday, October 24, 2013 2:41:15 AM2013-10-25Friday, October 25, 2013 2:05:42 AM2013-10-26Saturday, October 26, 2013 1:30:09 AM2013-10-27Sunday, October 27, 2013 12:54:36 AM2013-10-28Monday, October 28, 2013 12:19:03 AM2013-10-28Monday, October 28, 2013 11:43:30 PM2013-10-29Tuesday, October 29, 2013 11:07:57 PM2013-10-30Wednesday, October 30, 2013 10:32:24 PM2013-10-31Thursday, October 31, 2013 9:56:51 PM2013-11-01Friday, November 01, 2013 9:21:18 PM2013-11-02Saturday, November 02, 2013 8:45:45 PM2013-11-03Sunday, November 03, 2013 7:10:12 PM2013-11-04Monday, November 04, 2013 6:34:39 PM2013-11-05Tuesday, November 05, 2013 5:59:06 PM2013-11-06Wednesday, November 06, 2013 5:23:33 PM2013-11-07Thursday, November 07, 2013 4:48:00 PM2013-11-08Friday, November 08, 2013 4:12:27 PM2013-11-09Saturday, November 09, 2013 3:36:54 PM2013-11-10Sunday, November 10, 2013 3:01:20 PM2013-11-11Monday, November 11, 2013 2:25:47 PM2013-11-12Tuesday, November 12, 2013 1:50:14 PM2013-11-13Wednesday, November 13, 2013 1:14:41 PM2013-11-14Thursday, November 14, 2013 12:39:08 PM2013-11-15Friday, November 15, 2013 12:03:35 PM2013-11-16Saturday, November 16, 2013 11:28:02 AM2013-11-17Sunday, November 17, 2013 10:52:29 AM2013-11-18Monday, November 18, 2013 10:16:56 AM2013-11-19Tuesday, November 19, 2013 9:41:23 AM2013-11-20Wednesday, November 20, 2013 9:05:50 AM2013-11-21Thursday, November 21, 2013 8:30:17 AM2013-11-22Friday, November 22, 2013 7:54:44 AM2013-11-23Saturday, November 23, 2013 7:19:11 AM2013-11-24Sunday, November 24, 2013 6:43:38 AM2013-11-25Monday, November 25, 2013 6:08:05 AM2013-11-26Tuesday, November 26, 2013 5:32:32 AM2013-11-27Wednesday, November 27, 2013 4:56:59 AM2013-11-28Thursday, November 28, 2013 4:21:26 AM2013-11-29Friday, November 29, 2013 3:45:53 AM2013-11-30Saturday, November 30, 2013 3:10:20 AM2013-12-01Sunday, December 01, 2013 2:34:47 AM2013-12-02Monday, December 02, 2013 1:59:13 AM2013-12-03Tuesday, December 03, 2013 1:23:40 AM2013-12-04Wednesday, December 04, 2013 12:48:07 AM2013-12-05Thursday, December 05, 2013 12:12:34 AM2013-12-05Thursday, December 05, 2013 11:37:01 PM2013-12-06Friday, December 06, 2013 11:01:28 PM2013-12-07Saturday, December 07, 2013 10:25:55 PM2013-12-08Sunday, December 08, 2013 9:50:22 PM2013-12-09Monday, December 09, 2013 9:14:49 PM2013-12-10Tuesday, December 10, 2013 8:39:16 PM2013-12-11Wednesday, December 11, 2013 8:03:43 PM2013-12-12Thursday, December 12, 2013 7:28:10 PM2013-12-13Friday, December 13, 2013 6:52:37 PM2013-12-14Saturday, December 14, 2013 6:17:04 PM2013-12-15Sunday, December 15, 2013 5:41:31 PM2013-12-16Monday, December 16, 2013 5:05:58 PM2013-12-17Tuesday, December 17, 2013 4:30:25 PM2013-12-18Wednesday, December 18, 2013 3:54:52 PM2013-12-19Thursday, December 19, 2013 3:19:19 PM2013-12-20Friday, December 20, 2013 2:43:46 PM2013-12-21Saturday, December 21, 2013 2:08:13 PM2013-12-22Sunday, December 22, 2013 1:32:40 PM2013-12-23Monday, December 23, 2013 12:57:07 PM2013-12-24Tuesday, December 24, 2013 12:21:33 PM2013-12-25Wednesday, December 25, 2013 11:46:00 AM2013-12-26Thursday, December 26, 2013 11:10:27 AM2013-12-27Friday, December 27, 2013 10:34:54 AM2013-12-28Saturday, December 28, 2013 9:59:21 AM2013-12-29Sunday, December 29, 2013 9:23:48 AM2013-12-30Monday, December 30, 2013 8:48:15 AM2013-12-31Tuesday, December 31, 2013 8:12:42 AM2014-01-01Wednesday, January 01, 2014 7:37:09 AM2014-01-02Thursday, January 02, 2014 7:01:36 AM2014-01-03Friday, January 03, 2014 6:26:03 AM2014-01-04Saturday, January 04, 2014 5:50:30 AM2014-01-05Sunday, January 05, 2014 5:14:57 AM2014-01-06Monday, January 06, 2014 4:39:24 AM2014-01-07Tuesday, January 07, 2014 4:03:51 AM2014-01-08Wednesday, January 08, 2014 3:28:18 AM2014-01-09Thursday, January 09, 2014 2:52:45 AM2014-01-10Friday, January 10, 2014 2:17:12 AM2014-01-11Saturday, January 11, 2014 1:41:39 AM2014-01-12Sunday, January 12, 2014 1:06:06 AM2014-01-13Monday, January 13, 2014 12:30:33 AM2014-01-13Monday, January 13, 2014 11:55:00 PM2014-01-14Tuesday, January 14, 2014 11:19:27 PM2014-01-15Wednesday, January 15, 2014 10:43:53 PM2014-01-16Thursday, January 16, 2014 10:08:20 PM2014-01-17Friday, January 17, 2014 9:32:47 PM2014-01-18Saturday, January 18, 2014 8:57:14 PM2014-01-19Sunday, January 19, 2014 8:21:41 PM2014-01-20Monday, January 20, 2014 7:46:08 PM2014-01-21Tuesday, January 21, 2014 7:10:35 PM2014-01-22Wednesday, January 22, 2014 6:35:02 PM2014-01-23Thursday, January 23, 2014 5:59:29 PM2014-01-24Friday, January 24, 2014 5:23:56 PM2014-01-25Saturday, January 25, 2014 4:48:23 PM2014-01-26Sunday, January 26, 2014 4:12:50 PM2014-01-27Monday, January 27, 2014 3:37:17 PM2014-01-28Tuesday, January 28, 2014 3:01:44 PM2014-01-29Wednesday, January 29, 2014 2:26:11 PM2014-01-30Thursday, January 30, 2014 1:50:38 PM2014-01-31Friday, January 31, 2014 1:15:05 PM2014-02-01Saturday, February 01, 2014 12:39:32 PM2014-02-02Sunday, February 02, 2014 12:03:59 PM2014-02-03Monday, February 03, 2014 11:28:26 AM2014-02-04Tuesday, February 04, 2014 10:52:53 AM2014-02-05Wednesday, February 05, 2014 10:17:20 AM2014-02-06Thursday, February 06, 2014 9:41:47 AM2014-02-07Friday, February 07, 2014 9:06:13 AM2014-02-08Saturday, February 08, 2014 8:30:40 AM2014-02-09Sunday, February 09, 2014 7:55:07 AM2014-02-10Monday, February 10, 2014 7:19:34 AM2014-02-11Tuesday, February 11, 2014 6:44:01 AM2014-02-12Wednesday, February 12, 2014 6:08:28 AM2014-02-13Thursday, February 13, 2014 5:32:55 AM2014-02-14Friday, February 14, 2014 4:57:22 AM2014-02-15Saturday, February 15, 2014 4:21:49 AM2014-02-16Sunday, February 16, 2014 3:46:16 AM2014-02-17Monday, February 17, 2014 3:10:43 AM2014-02-18Tuesday, February 18, 2014 2:35:10 AM2014-02-19Wednesday, February 19, 2014 1:59:37 AM2014-02-20Thursday, February 20, 2014 1:24:04 AM2014-02-21Friday, February 21, 2014 12:48:31 AM2014-02-22Saturday, February 22, 2014 12:12:58 AM2014-02-22Saturday, February 22, 2014 11:37:25 PM2014-02-23Sunday, February 23, 2014 11:01:52 PM2014-02-24Monday, February 24, 2014 10:26:19 PM2014-02-25Tuesday, February 25, 2014 9:50:46 PM2014-02-26Wednesday, February 26, 2014 9:15:13 PM2014-02-27Thursday, February 27, 2014 8:39:40 PM2014-02-28Friday, February 28, 2014 8:04:06 PM2014-03-01Saturday, March 01, 2014 7:28:33 PM2014-03-02Sunday, March 02, 2014 6:53:00 PM2014-03-03Monday, March 03, 2014 6:17:27 PM2014-03-04Tuesday, March 04, 2014 5:41:54 PM2014-03-05Wednesday, March 05, 2014 5:06:21 PM2014-03-06Thursday, March 06, 2014 4:30:48 PM2014-03-07Friday, March 07, 2014 3:55:15 PM2014-03-08Saturday, March 08, 2014 3:19:42 PM2014-03-09Sunday, March 09, 2014 3:44:09 PM2014-03-10Monday, March 10, 2014 3:08:36 PM2014-03-11Tuesday, March 11, 2014 2:33:03 PM2014-03-12Wednesday, March 12, 2014 1:57:30 PM2014-03-13Thursday, March 13, 2014 1:21:57 PM2014-03-14Friday, March 14, 2014 12:46:24 PM2014-03-15Saturday, March 15, 2014 12:10:51 PM2014-03-16Sunday, March 16, 2014 11:35:18 AM2014-03-17Monday, March 17, 2014 10:59:45 AM2014-03-18Tuesday, March 18, 2014 10:24:12 AM2014-03-19Wednesday, March 19, 2014 9:48:39 AM2014-03-20Thursday, March 20, 2014 9:13:06 AM2014-03-21Friday, March 21, 2014 8:37:33 AM2014-03-22Saturday, March 22, 2014 8:02:00 AM2014-03-23Sunday, March 23, 2014 7:26:26 AM2014-03-24Monday, March 24, 2014 6:50:53 AM2014-03-25Tuesday, March 25, 2014 6:15:20 AM2014-03-26Wednesday, March 26, 2014 5:39:47 AM2014-03-27Thursday, March 27, 2014 5:04:14 AM2014-03-28Friday, March 28, 2014 4:28:41 AM2014-03-29Saturday, March 29, 2014 3:53:08 AM2014-03-30Sunday, March 30, 2014 3:17:35 AM2014-03-31Monday, March 31, 2014 2:42:02 AM2014-04-01Tuesday, April 01, 2014 2:06:29 AM2014-04-02Wednesday, April 02, 2014 1:30:56 AM2014-04-03Thursday, April 03, 2014 12:55:23 AM2014-04-04Friday, April 04, 2014 12:19:50 AM2014-04-04Friday, April 04, 2014 11:44:17 PM2014-04-05Saturday, April 05, 2014 11:08:44 PM2014-04-06Sunday, April 06, 2014 10:33:11 PM2014-04-07Monday, April 07, 2014 9:57:38 PM2014-04-08Tuesday, April 08, 2014 9:22:05 PM2014-04-09Wednesday, April 09, 2014 8:46:32 PM2014-04-10Thursday, April 10, 2014 8:10:59 PM2014-04-11Friday, April 11, 2014 7:35:26 PM2014-04-12Saturday, April 12, 2014 6:59:53 PM2014-04-13Sunday, April 13, 2014 6:24:20 PM2014-04-14Monday, April 14, 2014 5:48:46 PM2014-04-15Tuesday, April 15, 2014 5:13:13 PM2014-04-16Wednesday, April 16, 2014 4:37:40 PM2014-04-17Thursday, April 17, 2014 4:02:07 PM2014-04-18Friday, April 18, 2014 3:26:34 PM2014-04-19Saturday, April 19, 2014 2:51:01 PM2014-04-20Sunday, April 20, 2014 2:15:28 PM2014-04-21Monday, April 21, 2014 1:39:55 PM2014-04-22Tuesday, April 22, 2014 1:04:22 PM2014-04-23Wednesday, April 23, 2014 12:28:49 PM2014-04-24Thursday, April 24, 2014 11:53:16 AM2014-04-25Friday, April 25, 2014 11:17:43 AM2014-04-26Saturday, April 26, 2014 10:42:10 AM2014-04-27Sunday, April 27, 2014 10:06:37 AM2014-04-28Monday, April 28, 2014 9:31:04 AM2014-04-29Tuesday, April 29, 2014 8:55:31 AM2014-04-30Wednesday, April 30, 2014 8:19:58 AM2014-05-01Thursday, May 01, 2014 7:44:25 AM2014-05-02Friday, May 02, 2014 7:08:52 AM2014-05-03Saturday, May 03, 2014 6:33:19 AM2014-05-04Sunday, May 04, 2014 5:57:46 AM2014-05-05Monday, May 05, 2014 5:22:13 AM2014-05-06Tuesday, May 06, 2014 4:46:40 AM2014-05-07Wednesday, May 07, 2014 4:11:06 AM2014-05-08Thursday, May 08, 2014 3:35:33 AM2014-05-09Friday, May 09, 2014 3:00:00 AM2014-05-10Saturday, May 10, 2014 2:24:27 AM2014-05-11Sunday, May 11, 2014 1:48:54 AM2014-05-12Monday, May 12, 2014 1:13:21 AM2014-05-13Tuesday, May 13, 2014 12:37:48 AM2014-05-14Wednesday, May 14, 2014 12:02:15 AM2014-05-14Wednesday, May 14, 2014 11:26:42 PM2014-05-15Thursday, May 15, 2014 10:51:09 PM2014-05-16Friday, May 16, 2014 10:15:36 PM2014-05-17Saturday, May 17, 2014 9:40:03 PM2014-05-18Sunday, May 18, 2014 9:04:30 PM2014-05-19Monday, May 19, 2014 8:28:57 PM2014-05-20Tuesday, May 20, 2014 7:53:24 PM2014-05-21Wednesday, May 21, 2014 7:17:51 PM2014-05-22Thursday, May 22, 2014 6:42:18 PM2014-05-23Friday, May 23, 2014 6:06:45 PM2014-05-24Saturday, May 24, 2014 5:31:12 PM2014-05-25Sunday, May 25, 2014 4:55:39 PM2014-05-26Monday, May 26, 2014 4:20:06 PM2014-05-27Tuesday, May 27, 2014 3:44:33 PM2014-05-28Wednesday, May 28, 2014 3:08:59 PM2014-05-29Thursday, May 29, 2014 2:33:26 PM2014-05-30Friday, May 30, 2014 1:57:53 PM2014-05-31Saturday, May 31, 2014 1:22:20 PM2014-06-01Sunday, June 01, 2014 12:46:47 PM2014-06-02Monday, June 02, 2014 12:11:14 PM2014-06-03Tuesday, June 03, 2014 11:35:41 AM2014-06-04Wednesday, June 04, 2014 11:00:08 AM2014-06-05Thursday, June 05, 2014 10:24:35 AM2014-06-06Friday, June 06, 2014 9:49:02 AM2014-06-07Saturday, June 07, 2014 9:13:29 AM2014-06-08Sunday, June 08, 2014 8:37:56 AM2014-06-09Monday, June 09, 2014 8:02:23 AM2014-06-10Tuesday, June 10, 2014 7:26:50 AM2014-06-11Wednesday, June 11, 2014 6:51:17 AM2014-06-12Thursday, June 12, 2014 6:15:44 AM2014-06-13Friday, June 13, 2014 5:40:11 AM2014-06-14Saturday, June 14, 2014 5:04:38 AM2014-06-15Sunday, June 15, 2014 4:29:05 AM2014-06-16Monday, June 16, 2014 3:53:32 AM2014-06-17Tuesday, June 17, 2014 3:17:59 AM2014-06-18Wednesday, June 18, 2014 2:42:26 AM2014-06-19Thursday, June 19, 2014 2:06:53 AM2014-06-20Friday, June 20, 2014 1:31:19 AM2014-06-21Saturday, June 21, 2014 12:55:46 AM2014-06-22Sunday, June 22, 2014 12:20:13 AM2014-06-22Sunday, June 22, 2014 11:44:40 PM2014-06-23Monday, June 23, 2014 11:09:07 PM2014-06-24Tuesday, June 24, 2014 10:33:34 PM2014-06-25Wednesday, June 25, 2014 9:58:01 PM2014-06-26Thursday, June 26, 2014 9:22:28 PM2014-06-27Friday, June 27, 2014 8:46:55 PM2014-06-28Saturday, June 28, 2014 8:11:22 PM2014-06-29Sunday, June 29, 2014 7:35:49 PM2014-06-30Monday, June 30, 2014 7:00:16 PM2014-07-01Tuesday, July 01, 2014 6:24:43 PM2014-07-02Wednesday, July 02, 2014 5:49:10 PM2014-07-03Thursday, July 03, 2014 5:13:37 PM2014-07-04Friday, July 04, 2014 4:38:04 PM2014-07-05Saturday, July 05, 2014 4:02:31 PM2014-07-06Sunday, July 06, 2014 3:26:58 PM2014-07-07Monday, July 07, 2014 2:51:25 PM2014-07-08Tuesday, July 08, 2014 2:15:52 PM2014-07-09Wednesday, July 09, 2014 1:40:19 PM2014-07-10Thursday, July 10, 2014 1:04:46 PM2014-07-11Friday, July 11, 2014 12:29:13 PM2014-07-12Saturday, July 12, 2014 11:53:39 AM2014-07-13Sunday, July 13, 2014 11:18:06 AM2014-07-14Monday, July 14, 2014 10:42:33 AM2014-07-15Tuesday, July 15, 2014 10:07:00 AM2014-07-16Wednesday, July 16, 2014 9:31:27 AM2014-07-17Thursday, July 17, 2014 8:55:54 AM2014-07-18Friday, July 18, 2014 8:20:21 AM2014-07-19Saturday, July 19, 2014 7:44:48 AM2014-07-20Sunday, July 20, 2014 7:09:15 AM2014-07-21Monday, July 21, 2014 6:33:42 AM2014-07-22Tuesday, July 22, 2014 5:58:09 AM2014-07-23Wednesday, July 23, 2014 5:22:36 AM2014-07-24Thursday, July 24, 2014 4:47:03 AM2014-07-25Friday, July 25, 2014 4:11:30 AM2014-07-26Saturday, July 26, 2014 3:35:57 AM2014-07-27Sunday, July 27, 2014 3:00:24 AM2014-07-28Monday, July 28, 2014 2:24:51 AM2014-07-29Tuesday, July 29, 2014 1:49:18 AM2014-07-30Wednesday, July 30, 2014 1:13:45 AM2014-07-31Thursday, July 31, 2014 12:38:12 AM2014-08-01Friday, August 01, 2014 12:02:39 AM2014-08-01Friday, August 01, 2014 11:27:06 PM2014-08-02Saturday, August 02, 2014 10:51:32 PM2014-08-03Sunday, August 03, 2014 10:15:59 PM2014-08-04Monday, August 04, 2014 9:40:26 PM2014-08-05Tuesday, August 05, 2014 9:04:53 PM2014-08-06Wednesday, August 06, 2014 8:29:20 PM2014-08-07Thursday, August 07, 2014 7:53:47 PM2014-08-08Friday, August 08, 2014 7:18:14 PM2014-08-09Saturday, August 09, 2014 6:42:41 PM2014-08-10Sunday, August 10, 2014 6:07:08 PM2014-08-11Monday, August 11, 2014 5:31:35 PM2014-08-12Tuesday, August 12, 2014 4:56:02 PM2014-08-13Wednesday, August 13, 2014 4:20:29 PM2014-08-14Thursday, August 14, 2014 3:44:56 PM2014-08-15Friday, August 15, 2014 3:09:23 PM2014-08-16Saturday, August 16, 2014 2:33:50 PM2014-08-17Sunday, August 17, 2014 1:58:17 PM2014-08-18Monday, August 18, 2014 1:22:44 PM2014-08-19Tuesday, August 19, 2014 12:47:11 PM2014-08-20Wednesday, August 20, 2014 12:11:38 PM2014-08-21Thursday, August 21, 2014 11:36:05 AM2014-08-22Friday, August 22, 2014 11:00:32 AM2014-08-23Saturday, August 23, 2014 10:24:59 AM2014-08-24Sunday, August 24, 2014 9:49:26 AM2014-08-25Monday, August 25, 2014 9:13:52 AM2014-08-26Tuesday, August 26, 2014 8:38:19 AM2014-08-27Wednesday, August 27, 2014 8:02:46 AM2014-08-28Thursday, August 28, 2014 7:27:13 AM2014-08-29Friday, August 29, 2014 6:51:40 AM2014-08-30Saturday, August 30, 2014 6:16:07 AM2014-08-31Sunday, August 31, 2014 5:40:34 AM2014-09-01Monday, September 01, 2014 5:05:01 AM2014-09-02Tuesday, September 02, 2014 4:29:28 AM2014-09-03Wednesday, September 03, 2014 3:53:55 AM2014-09-04Thursday, September 04, 2014 3:18:22 AM2014-09-05Friday, September 05, 2014 2:42:49 AM2014-09-06Saturday, September 06, 2014 2:07:16 AM2014-09-07Sunday, September 07, 2014 1:31:43 AM2014-09-08Monday, September 08, 2014 12:56:10 AM2014-09-09Tuesday, September 09, 2014 12:20:37 AM2014-09-09Tuesday, September 09, 2014 11:45:04 PM2014-09-10Wednesday, September 10, 2014 11:09:31 PM2014-09-11Thursday, September 11, 2014 10:33:58 PM2014-09-12Friday, September 12, 2014 9:58:25 PM2014-09-13Saturday, September 13, 2014 9:22:52 PM2014-09-14Sunday, September 14, 2014 8:47:19 PM2014-09-15Monday, September 15, 2014 8:11:46 PM2014-09-16Tuesday, September 16, 2014 7:36:12 PM2014-09-17Wednesday, September 17, 2014 7:00:39 PM2014-09-18Thursday, September 18, 2014 6:25:06 PM2014-09-19Friday, September 19, 2014 5:49:33 PM2014-09-20Saturday, September 20, 2014 5:14:00 PM2014-09-21Sunday, September 21, 2014 4:38:27 PM2014-09-22Monday, September 22, 2014 4:02:54 PM2014-09-23Tuesday, September 23, 2014 3:27:21 PM2014-09-24Wednesday, September 24, 2014 2:51:48 PM2014-09-25Thursday, September 25, 2014 2:16:15 PM2014-09-26Friday, September 26, 2014 1:40:42 PM2014-09-27Saturday, September 27, 2014 1:05:09 PM2014-09-28Sunday, September 28, 2014 12:29:36 PM2014-09-29Monday, September 29, 2014 11:54:03 AM2014-09-30Tuesday, September 30, 2014 11:18:30 AM2014-10-01Wednesday, October 01, 2014 10:42:57 AM2014-10-02Thursday, October 02, 2014 10:07:24 AM2014-10-03Friday, October 03, 2014 9:31:51 AM2014-10-04Saturday, October 04, 2014 8:56:18 AM2014-10-05Sunday, October 05, 2014 8:20:45 AM2014-10-06Monday, October 06, 2014 7:45:12 AM2014-10-07Tuesday, October 07, 2014 7:09:39 AM2014-10-08Wednesday, October 08, 2014 6:34:06 AM2014-10-09Thursday, October 09, 2014 5:58:32 AM2014-10-10Friday, October 10, 2014 5:22:59 AM2014-10-11Saturday, October 11, 2014 4:47:26 AM2014-10-12Sunday, October 12, 2014 4:11:53 AM2014-10-13Monday, October 13, 2014 3:36:20 AM2014-10-14Tuesday, October 14, 2014 3:00:47 AM2014-10-15Wednesday, October 15, 2014 2:25:14 AM2014-10-16Thursday, October 16, 2014 1:49:41 AM2014-10-17Friday, October 17, 2014 1:14:08 AM2014-10-18Saturday, October 18, 2014 12:38:35 AM2014-10-19Sunday, October 19, 2014 12:03:02 AM2014-10-19Sunday, October 19, 2014 11:27:29 PM2014-10-20Monday, October 20, 2014 10:51:56 PM2014-10-21Tuesday, October 21, 2014 10:16:23 PM2014-10-22Wednesday, October 22, 2014 9:40:50 PM2014-10-23Thursday, October 23, 2014 9:05:17 PM2014-10-24Friday, October 24, 2014 8:29:44 PM2014-10-25Saturday, October 25, 2014 7:54:11 PM2014-10-26Sunday, October 26, 2014 7:18:38 PM2014-10-27Monday, October 27, 2014 6:43:05 PM2014-10-28Tuesday, October 28, 2014 6:07:32 PM2014-10-29Wednesday, October 29, 2014 5:31:59 PM2014-10-30Thursday, October 30, 2014 4:56:25 PM2014-10-31Friday, October 31, 2014 4:20:52 PM2014-11-01Saturday, November 01, 2014 3:45:19 PM2014-11-02Sunday, November 02, 2014 2:09:46 PM2014-11-03Monday, November 03, 2014 1:34:13 PM2014-11-04Tuesday, November 04, 2014 12:58:40 PM2014-11-05Wednesday, November 05, 2014 12:23:07 PM2014-11-06Thursday, November 06, 2014 11:47:34 AM2014-11-07Friday, November 07, 2014 11:12:01 AM2014-11-08Saturday, November 08, 2014 10:36:28 AM2014-11-09Sunday, November 09, 2014 10:00:55 AM2014-11-10Monday, November 10, 2014 9:25:22 AM2014-11-11Tuesday, November 11, 2014 8:49:49 AM2014-11-12Wednesday, November 12, 2014 8:14:16 AM2014-11-13Thursday, November 13, 2014 7:38:43 AM2014-11-14Friday, November 14, 2014 7:03:10 AM2014-11-15Saturday, November 15, 2014 6:27:37 AM2014-11-16Sunday, November 16, 2014 5:52:04 AM2014-11-17Monday, November 17, 2014 5:16:31 AM2014-11-18Tuesday, November 18, 2014 4:40:58 AM2014-11-19Wednesday, November 19, 2014 4:05:25 AM2014-11-20Thursday, November 20, 2014 3:29:52 AM2014-11-21Friday, November 21, 2014 2:54:19 AM2014-11-22Saturday, November 22, 2014 2:18:45 AM2014-11-23Sunday, November 23, 2014 1:43:12 AM2014-11-24Monday, November 24, 2014 1:07:39 AM2014-11-25Tuesday, November 25, 2014 12:32:06 AM2014-11-25Tuesday, November 25, 2014 11:56:33 PM2014-11-26Wednesday, November 26, 2014 11:21:00 PM2014-11-27Thursday, November 27, 2014 10:45:27 PM2014-11-28Friday, November 28, 2014 10:09:54 PM2014-11-29Saturday, November 29, 2014 9:34:21 PM2014-11-30Sunday, November 30, 2014 8:58:48 PM2014-12-01Monday, December 01, 2014 8:23:15 PM2014-12-02Tuesday, December 02, 2014 7:47:42 PM2014-12-03Wednesday, December 03, 2014 7:12:09 PM2014-12-04Thursday, December 04, 2014 6:36:36 PM2014-12-05Friday, December 05, 2014 6:01:03 PM2014-12-06Saturday, December 06, 2014 5:25:30 PM2014-12-07Sunday, December 07, 2014 4:49:57 PM2014-12-08Monday, December 08, 2014 4:14:24 PM2014-12-09Tuesday, December 09, 2014 3:38:51 PM2014-12-10Wednesday, December 10, 2014 3:03:18 PM2014-12-11Thursday, December 11, 2014 2:27:45 PM2014-12-12Friday, December 12, 2014 1:52:12 PM2014-12-13Saturday, December 13, 2014 1:16:39 PM2014-12-14Sunday, December 14, 2014 12:41:05 PM2014-12-15Monday, December 15, 2014 12:05:32 PM2014-12-16Tuesday, December 16, 2014 11:29:59 AM2014-12-17Wednesday, December 17, 2014 10:54:26 AM2014-12-18Thursday, December 18, 2014 10:18:53 AM2014-12-19Friday, December 19, 2014 9:43:20 AM2014-12-20Saturday, December 20, 2014 9:07:47 AM2014-12-21Sunday, December 21, 2014 8:32:14 AM2014-12-22Monday, December 22, 2014 7:56:41 AM2014-12-23Tuesday, December 23, 2014 7:21:08 AM2014-12-24Wednesday, December 24, 2014 6:45:35 AM2014-12-25Thursday, December 25, 2014 6:10:02 AM2014-12-26Friday, December 26, 2014 5:34:29 AM2014-12-27Saturday, December 27, 2014 4:58:56 AM2014-12-28Sunday, December 28, 2014 4:23:23 AM2014-12-29Monday, December 29, 2014 3:47:50 AM2014-12-30Tuesday, December 30, 2014 3:12:17 AM2014-12-31Wednesday, December 31, 2014 2:36:44 AM2015-01-01Thursday, January 01, 2015 2:01:11 AM2015-01-02Friday, January 02, 2015 1:25:38 AM2015-01-03Saturday, January 03, 2015 12:50:05 AM2015-01-04Sunday, January 04, 2015 12:14:32 AM2015-01-04Sunday, January 04, 2015 11:38:59 PM2015-01-05Monday, January 05, 2015 11:03:25 PM2015-01-06Tuesday, January 06, 2015 10:27:52 PM2015-01-07Wednesday, January 07, 2015 9:52:19 PM2015-01-08Thursday, January 08, 2015 9:16:46 PM2015-01-09Friday, January 09, 2015 8:41:13 PM2015-01-10Saturday, January 10, 2015 8:05:40 PM2015-01-11Sunday, January 11, 2015 7:30:07 PM2015-01-12Monday, January 12, 2015 6:54:34 PM2015-01-13Tuesday, January 13, 2015 6:19:01 PM2015-01-14Wednesday, January 14, 2015 5:43:28 PM2015-01-15Thursday, January 15, 2015 5:07:55 PM2015-01-16Friday, January 16, 2015 4:32:22 PM2015-01-17Saturday, January 17, 2015 3:56:49 PM2015-01-18Sunday, January 18, 2015 3:21:16 PM2015-01-19Monday, January 19, 2015 2:45:43 PM2015-01-20Tuesday, January 20, 2015 2:10:10 PM2015-01-21Wednesday, January 21, 2015 1:34:37 PM2015-01-22Thursday, January 22, 2015 12:59:04 PM2015-01-23Friday, January 23, 2015 12:23:31 PM2015-01-24Saturday, January 24, 2015 11:47:58 AM2015-01-25Sunday, January 25, 2015 11:12:25 AM2015-01-26Monday, January 26, 2015 10:36:52 AM2015-01-27Tuesday, January 27, 2015 10:01:18 AM2015-01-28Wednesday, January 28, 2015 9:25:45 AM2015-01-29Thursday, January 29, 2015 8:50:12 AM2015-01-30Friday, January 30, 2015 8:14:39 AM2015-01-31Saturday, January 31, 2015 7:39:06 AM2015-02-01Sunday, February 01, 2015 7:03:33 AM2015-02-02Monday, February 02, 2015 6:28:00 AM2015-02-03Tuesday, February 03, 2015 5:52:27 AM2015-02-04Wednesday, February 04, 2015 5:16:54 AM2015-02-05Thursday, February 05, 2015 4:41:21 AM2015-02-06Friday, February 06, 2015 4:05:48 AM2015-02-07Saturday, February 07, 2015 3:30:15 AM2015-02-08Sunday, February 08, 2015 2:54:42 AM2015-02-09Monday, February 09, 2015 2:19:09 AM2015-02-10Tuesday, February 10, 2015 1:43:36 AM2015-02-11Wednesday, February 11, 2015 1:08:03 AM2015-02-12Thursday, February 12, 2015 12:32:30 AM2015-02-12Thursday, February 12, 2015 11:56:57 PM2015-02-13Friday, February 13, 2015 11:21:24 PM2015-02-14Saturday, February 14, 2015 10:45:51 PM2015-02-15Sunday, February 15, 2015 10:10:18 PM2015-02-16Monday, February 16, 2015 9:34:45 PM2015-02-17Tuesday, February 17, 2015 8:59:12 PM2015-02-18Wednesday, February 18, 2015 8:23:38 PM2015-02-19Thursday, February 19, 2015 7:48:05 PM2015-02-20Friday, February 20, 2015 7:12:32 PM2015-02-21Saturday, February 21, 2015 6:36:59 PM2015-02-22Sunday, February 22, 2015 6:01:26 PM2015-02-23Monday, February 23, 2015 5:25:53 PM2015-02-24Tuesday, February 24, 2015 4:50:20 PM2015-02-25Wednesday, February 25, 2015 4:14:47 PM2015-02-26Thursday, February 26, 2015 3:39:14 PM2015-02-27Friday, February 27, 2015 3:03:41 PM2015-02-28Saturday, February 28, 2015 2:28:08 PM2015-03-01Sunday, March 01, 2015 1:52:35 PM2015-03-02Monday, March 02, 2015 1:17:02 PM2015-03-03Tuesday, March 03, 2015 12:41:29 PM2015-03-04Wednesday, March 04, 2015 12:05:56 PM2015-03-05Thursday, March 05, 2015 11:30:23 AM2015-03-06Friday, March 06, 2015 10:54:50 AM2015-03-07Saturday, March 07, 2015 10:19:17 AM2015-03-08Sunday, March 08, 2015 10:43:44 AM2015-03-09Monday, March 09, 2015 10:08:11 AM2015-03-10Tuesday, March 10, 2015 9:32:38 AM2015-03-11Wednesday, March 11, 2015 8:57:05 AM2015-03-12Thursday, March 12, 2015 8:21:32 AM2015-03-13Friday, March 13, 2015 7:45:58 AM2015-03-14Saturday, March 14, 2015 7:10:25 AM2015-03-15Sunday, March 15, 2015 6:34:52 AM2015-03-16Monday, March 16, 2015 5:59:19 AM2015-03-17Tuesday, March 17, 2015 5:23:46 AM2015-03-18Wednesday, March 18, 2015 4:48:13 AM2015-03-19Thursday, March 19, 2015 4:12:40 AM2015-03-20Friday, March 20, 2015 3:37:07 AM2015-03-21Saturday, March 21, 2015 3:01:34 AM2015-03-22Sunday, March 22, 2015 2:26:01 AM2015-03-23Monday, March 23, 2015 1:50:28 AM2015-03-24Tuesday, March 24, 2015 1:14:55 AM2015-03-25Wednesday, March 25, 2015 12:39:22 AM2015-03-26Thursday, March 26, 2015 12:03:49 AM2015-03-26Thursday, March 26, 2015 11:28:16 PM2015-03-27Friday, March 27, 2015 10:52:43 PM2015-03-28Saturday, March 28, 2015 10:17:10 PM2015-03-29Sunday, March 29, 2015 9:41:37 PM2015-03-30Monday, March 30, 2015 9:06:04 PM2015-03-31Tuesday, March 31, 2015 8:30:31 PM2015-04-01Wednesday, April 01, 2015 7:54:58 PM2015-04-02Thursday, April 02, 2015 7:19:25 PM2015-04-03Friday, April 03, 2015 6:43:51 PM2015-04-04Saturday, April 04, 2015 6:08:18 PM2015-04-05Sunday, April 05, 2015 5:32:45 PM2015-04-06Monday, April 06, 2015 4:57:12 PM2015-04-07Tuesday, April 07, 2015 4:21:39 PM2015-04-08Wednesday, April 08, 2015 3:46:06 PM2015-04-09Thursday, April 09, 2015 3:10:33 PM2015-04-10Friday, April 10, 2015 2:35:00 PM2015-04-11Saturday, April 11, 2015 1:59:27 PM2015-04-12Sunday, April 12, 2015 1:23:54 PM2015-04-13Monday, April 13, 2015 12:48:21 PM2015-04-14Tuesday, April 14, 2015 12:12:48 PM2015-04-15Wednesday, April 15, 2015 11:37:15 AM2015-04-16Thursday, April 16, 2015 11:01:42 AM2015-04-17Friday, April 17, 2015 10:26:09 AM2015-04-18Saturday, April 18, 2015 9:50:36 AM2015-04-19Sunday, April 19, 2015 9:15:03 AM2015-04-20Monday, April 20, 2015 8:39:30 AM2015-04-21Tuesday, April 21, 2015 8:03:57 AM2015-04-22Wednesday, April 22, 2015 7:28:24 AM2015-04-23Thursday, April 23, 2015 6:52:51 AM2015-04-24Friday, April 24, 2015 6:17:18 AM2015-04-25Saturday, April 25, 2015 5:41:45 AM2015-04-26Sunday, April 26, 2015 5:06:11 AM2015-04-27Monday, April 27, 2015 4:30:38 AM2015-04-28Tuesday, April 28, 2015 3:55:05 AM2015-04-29Wednesday, April 29, 2015 3:19:32 AM2015-04-30Thursday, April 30, 2015 2:43:59 AM2015-05-01Friday, May 01, 2015 2:08:26 AM2015-05-02Saturday, May 02, 2015 1:32:53 AM2015-05-03Sunday, May 03, 2015 12:57:20 AM2015-05-04Monday, May 04, 2015 12:21:47 AM2015-05-04Monday, May 04, 2015 11:46:14 PM2015-05-05Tuesday, May 05, 2015 11:10:41 PM2015-05-06Wednesday, May 06, 2015 10:35:08 PM2015-05-07Thursday, May 07, 2015 9:59:35 PM2015-05-08Friday, May 08, 2015 9:24:02 PM2015-05-09Saturday, May 09, 2015 8:48:29 PM2015-05-10Sunday, May 10, 2015 8:12:56 PM2015-05-11Monday, May 11, 2015 7:37:23 PM2015-05-12Tuesday, May 12, 2015 7:01:50 PM2015-05-13Wednesday, May 13, 2015 6:26:17 PM2015-05-14Thursday, May 14, 2015 5:50:44 PM2015-05-15Friday, May 15, 2015 5:15:11 PM2015-05-16Saturday, May 16, 2015 4:39:38 PM2015-05-17Sunday, May 17, 2015 4:04:05 PM2015-05-18Monday, May 18, 2015 3:28:31 PM2015-05-19Tuesday, May 19, 2015 2:52:58 PM2015-05-20Wednesday, May 20, 2015 2:17:25 PM2015-05-21Thursday, May 21, 2015 1:41:52 PM2015-05-22Friday, May 22, 2015 1:06:19 PM2015-05-23Saturday, May 23, 2015 12:30:46 PM2015-05-24Sunday, May 24, 2015 11:55:13 AM2015-05-25Monday, May 25, 2015 11:19:40 AM2015-05-26Tuesday, May 26, 2015 10:44:07 AM2015-05-27Wednesday, May 27, 2015 10:08:34 AM2015-05-28Thursday, May 28, 2015 9:33:01 AM2015-05-29Friday, May 29, 2015 8:57:28 AM2015-05-30Saturday, May 30, 2015 8:21:55 AM2015-05-31Sunday, May 31, 2015 7:46:22 AM2015-06-01Monday, June 01, 2015 7:10:49 AM2015-06-02Tuesday, June 02, 2015 6:35:16 AM2015-06-03Wednesday, June 03, 2015 5:59:43 AM2015-06-04Thursday, June 04, 2015 5:24:10 AM2015-06-05Friday, June 05, 2015 4:48:37 AM2015-06-06Saturday, June 06, 2015 4:13:04 AM2015-06-07Sunday, June 07, 2015 3:37:31 AM2015-06-08Monday, June 08, 2015 3:01:58 AM2015-06-09Tuesday, June 09, 2015 2:26:25 AM2015-06-10Wednesday, June 10, 2015 1:50:51 AM2015-06-11Thursday, June 11, 2015 1:15:18 AM2015-06-12Friday, June 12, 2015 12:39:45 AM2015-06-13Saturday, June 13, 2015 12:04:12 AM2015-06-13Saturday, June 13, 2015 11:28:39 PM2015-06-14Sunday, June 14, 2015 10:53:06 PM2015-06-15Monday, June 15, 2015 10:17:33 PM2015-06-16Tuesday, June 16, 2015 9:42:00 PM2015-06-17Wednesday, June 17, 2015 9:06:27 PM2015-06-18Thursday, June 18, 2015 8:30:54 PM2015-06-19Friday, June 19, 2015 7:55:21 PM2015-06-20Saturday, June 20, 2015 7:19:48 PM2015-06-21Sunday, June 21, 2015 6:44:15 PM2015-06-22Monday, June 22, 2015 6:08:42 PM2015-06-23Tuesday, June 23, 2015 5:33:09 PM2015-06-24Wednesday, June 24, 2015 4:57:36 PM2015-06-25Thursday, June 25, 2015 4:22:03 PM2015-06-26Friday, June 26, 2015 3:46:30 PM2015-06-27Saturday, June 27, 2015 3:10:57 PM2015-06-28Sunday, June 28, 2015 2:35:24 PM2015-06-29Monday, June 29, 2015 1:59:51 PM2015-06-30Tuesday, June 30, 2015 1:24:18 PM2015-07-01Wednesday, July 01, 2015 12:48:44 PM2015-07-02Thursday, July 02, 2015 12:13:11 PM2015-07-03Friday, July 03, 2015 11:37:38 AM2015-07-04Saturday, July 04, 2015 11:02:05 AM2015-07-05Sunday, July 05, 2015 10:26:32 AM2015-07-06Monday, July 06, 2015 9:50:59 AM2015-07-07Tuesday, July 07, 2015 9:15:26 AM2015-07-08Wednesday, July 08, 2015 8:39:53 AM2015-07-09Thursday, July 09, 2015 8:04:20 AM2015-07-10Friday, July 10, 2015 7:28:47 AM2015-07-11Saturday, July 11, 2015 6:53:14 AM2015-07-12Sunday, July 12, 2015 6:17:41 AM2015-07-13Monday, July 13, 2015 5:42:08 AM2015-07-14Tuesday, July 14, 2015 5:06:35 AM2015-07-15Wednesday, July 15, 2015 4:31:02 AM2015-07-16Thursday, July 16, 2015 3:55:29 AM2015-07-17Friday, July 17, 2015 3:19:56 AM2015-07-18Saturday, July 18, 2015 2:44:23 AM2015-07-19Sunday, July 19, 2015 2:08:50 AM2015-07-20Monday, July 20, 2015 1:33:17 AM2015-07-21Tuesday, July 21, 2015 12:57:44 AM2015-07-22Wednesday, July 22, 2015 12:22:11 AM2015-07-22Wednesday, July 22, 2015 11:46:38 PM2015-07-23Thursday, July 23, 2015 11:11:04 PM2015-07-24Friday, July 24, 2015 10:35:31 PM2015-07-25Saturday, July 25, 2015 9:59:58 PM2015-07-26Sunday, July 26, 2015 9:24:25 PM2015-07-27Monday, July 27, 2015 8:48:52 PM2015-07-28Tuesday, July 28, 2015 8:13:19 PM2015-07-29Wednesday, July 29, 2015 7:37:46 PM2015-07-30Thursday, July 30, 2015 7:02:13 PM2015-07-31Friday, July 31, 2015 6:26:40 PM2015-08-01Saturday, August 01, 2015 5:51:07 PM2015-08-02Sunday, August 02, 2015 5:15:34 PM2015-08-03Monday, August 03, 2015 4:40:01 PM2015-08-04Tuesday, August 04, 2015 4:04:28 PM2015-08-05Wednesday, August 05, 2015 3:28:55 PM2015-08-06Thursday, August 06, 2015 2:53:22 PM2015-08-07Friday, August 07, 2015 2:17:49 PM2015-08-08Saturday, August 08, 2015 1:42:16 PM2015-08-09Sunday, August 09, 2015 1:06:43 PM2015-08-10Monday, August 10, 2015 12:31:10 PM2015-08-11Tuesday, August 11, 2015 11:55:37 AM2015-08-12Wednesday, August 12, 2015 11:20:04 AM2015-08-13Thursday, August 13, 2015 10:44:31 AM2015-08-14Friday, August 14, 2015 10:08:58 AM2015-08-15Saturday, August 15, 2015 9:33:24 AM2015-08-16Sunday, August 16, 2015 8:57:51 AM2015-08-17Monday, August 17, 2015 8:22:18 AM2015-08-18Tuesday, August 18, 2015 7:46:45 AM2015-08-19Wednesday, August 19, 2015 7:11:12 AM2015-08-20Thursday, August 20, 2015 6:35:39 AM2015-08-21Friday, August 21, 2015 6:00:06 AM2015-08-22Saturday, August 22, 2015 5:24:33 AM2015-08-23Sunday, August 23, 2015 4:49:00 AM2015-08-24Monday, August 24, 2015 4:13:27 AM2015-08-25Tuesday, August 25, 2015 3:37:54 AM2015-08-26Wednesday, August 26, 2015 3:02:21 AM2015-08-27Thursday, August 27, 2015 2:26:48 AM2015-08-28Friday, August 28, 2015 1:51:15 AM2015-08-29Saturday, August 29, 2015 1:15:42 AM2015-08-30Sunday, August 30, 2015 12:40:09 AM2015-08-31Monday, August 31, 2015 12:04:36 AM2015-08-31Monday, August 31, 2015 11:29:03 PM2015-09-01Tuesday, September 01, 2015 10:53:30 PM2015-09-02Wednesday, September 02, 2015 10:17:57 PM2015-09-03Thursday, September 03, 2015 9:42:24 PM2015-09-04Friday, September 04, 2015 9:06:51 PM2015-09-05Saturday, September 05, 2015 8:31:18 PM2015-09-06Sunday, September 06, 2015 7:55:44 PM2015-09-07Monday, September 07, 2015 7:20:11 PM2015-09-08Tuesday, September 08, 2015 6:44:38 PM2015-09-09Wednesday, September 09, 2015 6:09:05 PM2015-09-10Thursday, September 10, 2015 5:33:32 PM2015-09-11Friday, September 11, 2015 4:57:59 PM2015-09-12Saturday, September 12, 2015 4:22:26 PM2015-09-13Sunday, September 13, 2015 3:46:53 PM2015-09-14Monday, September 14, 2015 3:11:20 PM2015-09-15Tuesday, September 15, 2015 2:35:47 PM2015-09-16Wednesday, September 16, 2015 2:00:14 PM2015-09-17Thursday, September 17, 2015 1:24:41 PM2015-09-18Friday, September 18, 2015 12:49:08 PM2015-09-19Saturday, September 19, 2015 12:13:35 PM2015-09-20Sunday, September 20, 2015 11:38:02 AM2015-09-21Monday, September 21, 2015 11:02:29 AM2015-09-22Tuesday, September 22, 2015 10:26:56 AM2015-09-23Wednesday, September 23, 2015 9:51:23 AM2015-09-24Thursday, September 24, 2015 9:15:50 AM2015-09-25Friday, September 25, 2015 8:40:17 AM2015-09-26Saturday, September 26, 2015 8:04:44 AM2015-09-27Sunday, September 27, 2015 7:29:11 AM2015-09-28Monday, September 28, 2015 6:53:37 AM2015-09-29Tuesday, September 29, 2015 6:18:04 AM2015-09-30Wednesday, September 30, 2015 5:42:31 AM2015-10-01Thursday, October 01, 2015 5:06:58 AM2015-10-02Friday, October 02, 2015 4:31:25 AM2015-10-03Saturday, October 03, 2015 3:55:52 AM2015-10-04Sunday, October 04, 2015 3:20:19 AM2015-10-05Monday, October 05, 2015 2:44:46 AM2015-10-06Tuesday, October 06, 2015 2:09:13 AM2015-10-07Wednesday, October 07, 2015 1:33:40 AM2015-10-08Thursday, October 08, 2015 12:58:07 AM2015-10-09Friday, October 09, 2015 12:22:34 AM2015-10-09Friday, October 09, 2015 11:47:01 PM2015-10-10Saturday, October 10, 2015 11:11:28 PM2015-10-11Sunday, October 11, 2015 10:35:55 PM2015-10-12Monday, October 12, 2015 10:00:22 PM2015-10-13Tuesday, October 13, 2015 9:24:49 PM2015-10-14Wednesday, October 14, 2015 8:49:16 PM2015-10-15Thursday, October 15, 2015 8:13:43 PM2015-10-16Friday, October 16, 2015 7:38:10 PM2015-10-17Saturday, October 17, 2015 7:02:37 PM2015-10-18Sunday, October 18, 2015 6:27:04 PM2015-10-19Monday, October 19, 2015 5:51:31 PM2015-10-20Tuesday, October 20, 2015 5:15:57 PM2015-10-21Wednesday, October 21, 2015 4:40:24 PM2015-10-22Thursday, October 22, 2015 4:04:51 PM2015-10-23Friday, October 23, 2015 3:29:18 PM2015-10-24Saturday, October 24, 2015 2:53:45 PM2015-10-25Sunday, October 25, 2015 2:18:12 PM2015-10-26Monday, October 26, 2015 1:42:39 PM2015-10-27Tuesday, October 27, 2015 1:07:06 PM2015-10-28Wednesday, October 28, 2015 12:31:33 PM2015-10-29Thursday, October 29, 2015 11:56:00 AM2015-10-30Friday, October 30, 2015 11:20:27 AM2015-10-31Saturday, October 31, 2015 10:44:54 AM2015-11-01Sunday, November 01, 2015 9:09:21 AM2015-11-02Monday, November 02, 2015 8:33:48 AM2015-11-03Tuesday, November 03, 2015 7:58:15 AM2015-11-04Wednesday, November 04, 2015 7:22:42 AM2015-11-05Thursday, November 05, 2015 6:47:09 AM2015-11-06Friday, November 06, 2015 6:11:36 AM2015-11-07Saturday, November 07, 2015 5:36:03 AM2015-11-08Sunday, November 08, 2015 5:00:30 AM2015-11-09Monday, November 09, 2015 4:24:57 AM2015-11-10Tuesday, November 10, 2015 3:49:24 AM2015-11-11Wednesday, November 11, 2015 3:13:51 AM2015-11-12Thursday, November 12, 2015 2:38:17 AM2015-11-13Friday, November 13, 2015 2:02:44 AM2015-11-14Saturday, November 14, 2015 1:27:11 AM2015-11-15Sunday, November 15, 2015 12:51:38 AM2015-11-16Monday, November 16, 2015 12:16:05 AM2015-11-16Monday, November 16, 2015 11:40:32 PM2015-11-17Tuesday, November 17, 2015 11:04:59 PM2015-11-18Wednesday, November 18, 2015 10:29:26 PM2015-11-19Thursday, November 19, 2015 9:53:53 PM2015-11-20Friday, November 20, 2015 9:18:20 PM2015-11-21Saturday, November 21, 2015 8:42:47 PM2015-11-22Sunday, November 22, 2015 8:07:14 PM2015-11-23Monday, November 23, 2015 7:31:41 PM2015-11-24Tuesday, November 24, 2015 6:56:08 PM2015-11-25Wednesday, November 25, 2015 6:20:35 PM2015-11-26Thursday, November 26, 2015 5:45:02 PM2015-11-27Friday, November 27, 2015 5:09:29 PM2015-11-28Saturday, November 28, 2015 4:33:56 PM2015-11-29Sunday, November 29, 2015 3:58:23 PM2015-11-30Monday, November 30, 2015 3:22:50 PM2015-12-01Tuesday, December 01, 2015 2:47:17 PM2015-12-02Wednesday, December 02, 2015 2:11:44 PM2015-12-03Thursday, December 03, 2015 1:36:10 PM2015-12-04Friday, December 04, 2015 1:00:37 PM2015-12-05Saturday, December 05, 2015 12:25:04 PM2015-12-06Sunday, December 06, 2015 11:49:31 AM2015-12-07Monday, December 07, 2015 11:13:58 AM2015-12-08Tuesday, December 08, 2015 10:38:25 AM2015-12-09Wednesday, December 09, 2015 10:02:52 AM2015-12-10Thursday, December 10, 2015 9:27:19 AM2015-12-11Friday, December 11, 2015 8:51:46 AM2015-12-12Saturday, December 12, 2015 8:16:13 AM2015-12-13Sunday, December 13, 2015 7:40:40 AM2015-12-14Monday, December 14, 2015 7:05:07 AM2015-12-15Tuesday, December 15, 2015 6:29:34 AM2015-12-16Wednesday, December 16, 2015 5:54:01 AM2015-12-17Thursday, December 17, 2015 5:18:28 AM2015-12-18Friday, December 18, 2015 4:42:55 AM2015-12-19Saturday, December 19, 2015 4:07:22 AM2015-12-20Sunday, December 20, 2015 3:31:49 AM2015-12-21Monday, December 21, 2015 2:56:16 AM2015-12-22Tuesday, December 22, 2015 2:20:43 AM2015-12-23Wednesday, December 23, 2015 1:45:10 AM2015-12-24Thursday, December 24, 2015 1:09:37 AM2015-12-25Friday, December 25, 2015 12:34:04 AM2015-12-25Friday, December 25, 2015 11:58:30 PM2015-12-26Saturday, December 26, 2015 11:22:57 PM2015-12-27Sunday, December 27, 2015 10:47:24 PM2015-12-28Monday, December 28, 2015 10:11:51 PM2015-12-29Tuesday, December 29, 2015 9:36:18 PM2015-12-30Wednesday, December 30, 2015 9:00:45 PM2015-12-31Thursday, December 31, 2015 8:25:12 PM2016-01-01Friday, January 01, 2016 7:49:39 PM2016-01-02Saturday, January 02, 2016 7:14:06 PM2016-01-03Sunday, January 03, 2016 6:38:33 PM2016-01-04Monday, January 04, 2016 6:03:00 PM2016-01-05Tuesday, January 05, 2016 5:27:27 PM2016-01-06Wednesday, January 06, 2016 4:51:54 PM2016-01-07Thursday, January 07, 2016 4:16:21 PM2016-01-08Friday, January 08, 2016 3:40:48 PM2016-01-09Saturday, January 09, 2016 3:05:15 PM2016-01-10Sunday, January 10, 2016 2:29:42 PM2016-01-11Monday, January 11, 2016 1:54:09 PM2016-01-12Tuesday, January 12, 2016 1:18:36 PM2016-01-13Wednesday, January 13, 2016 12:43:03 PM2016-01-14Thursday, January 14, 2016 12:07:30 PM2016-01-15Friday, January 15, 2016 11:31:57 AM2016-01-16Saturday, January 16, 2016 10:56:24 AM2016-01-17Sunday, January 17, 2016 10:20:50 AM2016-01-18Monday, January 18, 2016 9:45:17 AM2016-01-19Tuesday, January 19, 2016 9:09:44 AM2016-01-20Wednesday, January 20, 2016 8:34:11 AM2016-01-21Thursday, January 21, 2016 7:58:38 AM2016-01-22Friday, January 22, 2016 7:23:05 AM2016-01-23Saturday, January 23, 2016 6:47:32 AM2016-01-24Sunday, January 24, 2016 6:11:59 AM2016-01-25Monday, January 25, 2016 5:36:26 AM2016-01-26Tuesday, January 26, 2016 5:00:53 AM2016-01-27Wednesday, January 27, 2016 4:25:20 AM2016-01-28Thursday, January 28, 2016 3:49:47 AM2016-01-29Friday, January 29, 2016 3:14:14 AM2016-01-30Saturday, January 30, 2016 2:38:41 AM2016-01-31Sunday, January 31, 2016 2:03:08 AM2016-02-01Monday, February 01, 2016 1:27:35 AM2016-02-02Tuesday, February 02, 2016 12:52:02 AM2016-02-03Wednesday, February 03, 2016 12:16:29 AM2016-02-03Wednesday, February 03, 2016 11:40:56 PM2016-02-04Thursday, February 04, 2016 11:05:23 PM2016-02-05Friday, February 05, 2016 10:29:50 PM2016-02-06Saturday, February 06, 2016 9:54:17 PM2016-02-07Sunday, February 07, 2016 9:18:44 PM2016-02-08Monday, February 08, 2016 8:43:10 PM2016-02-09Tuesday, February 09, 2016 8:07:37 PM2016-02-10Wednesday, February 10, 2016 7:32:04 PM2016-02-11Thursday, February 11, 2016 6:56:31 PM2016-02-12Friday, February 12, 2016 6:20:58 PM2016-02-13Saturday, February 13, 2016 5:45:25 PM2016-02-14Sunday, February 14, 2016 5:09:52 PM2016-02-15Monday, February 15, 2016 4:34:19 PM2016-02-16Tuesday, February 16, 2016 3:58:46 PM2016-02-17Wednesday, February 17, 2016 3:23:13 PM2016-02-18Thursday, February 18, 2016 2:47:40 PM2016-02-19Friday, February 19, 2016 2:12:07 PM2016-02-20Saturday, February 20, 2016 1:36:34 PM2016-02-21Sunday, February 21, 2016 1:01:01 PM2016-02-22Monday, February 22, 2016 12:25:28 PM2016-02-23Tuesday, February 23, 2016 11:49:55 AM2016-02-24Wednesday, February 24, 2016 11:14:22 AM2016-02-25Thursday, February 25, 2016 10:38:49 AM2016-02-26Friday, February 26, 2016 10:03:16 AM2016-02-27Saturday, February 27, 2016 9:27:43 AM2016-02-28Sunday, February 28, 2016 8:52:10 AM2016-02-29Monday, February 29, 2016 8:16:37 AM2016-03-01Tuesday, March 01, 2016 7:41:03 AM2016-03-02Wednesday, March 02, 2016 7:05:30 AM2016-03-03Thursday, March 03, 2016 6:29:57 AM2016-03-04Friday, March 04, 2016 5:54:24 AM2016-03-05Saturday, March 05, 2016 5:18:51 AM2016-03-06Sunday, March 06, 2016 4:43:18 AM2016-03-07Monday, March 07, 2016 4:07:45 AM2016-03-08Tuesday, March 08, 2016 3:32:12 AM2016-03-09Wednesday, March 09, 2016 2:56:39 AM2016-03-10Thursday, March 10, 2016 2:21:06 AM2016-03-11Friday, March 11, 2016 1:45:33 AM2016-03-12Saturday, March 12, 2016 1:10:00 AM2016-03-13Sunday, March 13, 2016 12:34:27 AM2016-03-14Monday, March 14, 2016 12:58:54 AM2016-03-15Tuesday, March 15, 2016 12:23:21 AM2016-03-15Tuesday, March 15, 2016 11:47:48 PM2016-03-16Wednesday, March 16, 2016 11:12:15 PM2016-03-17Thursday, March 17, 2016 10:36:42 PM2016-03-18Friday, March 18, 2016 10:01:09 PM2016-03-19Saturday, March 19, 2016 9:25:36 PM2016-03-20Sunday, March 20, 2016 8:50:03 PM2016-03-21Monday, March 21, 2016 8:14:30 PM2016-03-22Tuesday, March 22, 2016 7:38:57 PM2016-03-23Wednesday, March 23, 2016 7:03:23 PM2016-03-24Thursday, March 24, 2016 6:27:50 PM2016-03-25Friday, March 25, 2016 5:52:17 PM2016-03-26Saturday, March 26, 2016 5:16:44 PM2016-03-27Sunday, March 27, 2016 4:41:11 PM2016-03-28Monday, March 28, 2016 4:05:38 PM2016-03-29Tuesday, March 29, 2016 3:30:05 PM2016-03-30Wednesday, March 30, 2016 2:54:32 PM2016-03-31Thursday, March 31, 2016 2:18:59 PM2016-04-01Friday, April 01, 2016 1:43:26 PM2016-04-02Saturday, April 02, 2016 1:07:53 PM2016-04-03Sunday, April 03, 2016 12:32:20 PM2016-04-04Monday, April 04, 2016 11:56:47 AM2016-04-05Tuesday, April 05, 2016 11:21:14 AM2016-04-06Wednesday, April 06, 2016 10:45:41 AM2016-04-07Thursday, April 07, 2016 10:10:08 AM2016-04-08Friday, April 08, 2016 9:34:35 AM2016-04-09Saturday, April 09, 2016 8:59:02 AM2016-04-10Sunday, April 10, 2016 8:23:29 AM2016-04-11Monday, April 11, 2016 7:47:56 AM2016-04-12Tuesday, April 12, 2016 7:12:23 AM2016-04-13Wednesday, April 13, 2016 6:36:50 AM2016-04-14Thursday, April 14, 2016 6:01:17 AM2016-04-15Friday, April 15, 2016 5:25:43 AM2016-04-16Saturday, April 16, 2016 4:50:10 AM2016-04-17Sunday, April 17, 2016 4:14:37 AM2016-04-18Monday, April 18, 2016 3:39:04 AM2016-04-19Tuesday, April 19, 2016 3:03:31 AM2016-04-20Wednesday, April 20, 2016 2:27:58 AM2016-04-21Thursday, April 21, 2016 1:52:25 AM2016-04-22Friday, April 22, 2016 1:16:52 AM2016-04-23Saturday, April 23, 2016 12:41:19 AM2016-04-24Sunday, April 24, 2016 12:05:46 AM2016-04-24Sunday, April 24, 2016 11:30:13 PM2016-04-25Monday, April 25, 2016 10:54:40 PM2016-04-26Tuesday, April 26, 2016 10:19:07 PM2016-04-27Wednesday, April 27, 2016 9:43:34 PM2016-04-28Thursday, April 28, 2016 9:08:01 PM2016-04-29Friday, April 29, 2016 8:32:28 PM2016-04-30Saturday, April 30, 2016 7:56:55 PM2016-05-01Sunday, May 01, 2016 7:21:22 PM2016-05-02Monday, May 02, 2016 6:45:49 PM2016-05-03Tuesday, May 03, 2016 6:10:16 PM2016-05-04Wednesday, May 04, 2016 5:34:43 PM2016-05-05Thursday, May 05, 2016 4:59:10 PM2016-05-06Friday, May 06, 2016 4:23:37 PM2016-05-07Saturday, May 07, 2016 3:48:03 PM2016-05-08Sunday, May 08, 2016 3:12:30 PM2016-05-09Monday, May 09, 2016 2:36:57 PM2016-05-10Tuesday, May 10, 2016 2:01:24 PM2016-05-11Wednesday, May 11, 2016 1:25:51 PM2016-05-12Thursday, May 12, 2016 12:50:18 PM2016-05-13Friday, May 13, 2016 12:14:45 PM2016-05-14Saturday, May 14, 2016 11:39:12 AM2016-05-15Sunday, May 15, 2016 11:03:39 AM2016-05-16Monday, May 16, 2016 10:28:06 AM2016-05-17Tuesday, May 17, 2016 9:52:33 AM2016-05-18Wednesday, May 18, 2016 9:17:00 AM2016-05-19Thursday, May 19, 2016 8:41:27 AM2016-05-20Friday, May 20, 2016 8:05:54 AM2016-05-21Saturday, May 21, 2016 7:30:21 AM2016-05-22Sunday, May 22, 2016 6:54:48 AM2016-05-23Monday, May 23, 2016 6:19:15 AM2016-05-24Tuesday, May 24, 2016 5:43:42 AM2016-05-25Wednesday, May 25, 2016 5:08:09 AM2016-05-26Thursday, May 26, 2016 4:32:36 AM2016-05-27Friday, May 27, 2016 3:57:03 AM2016-05-28Saturday, May 28, 2016 3:21:30 AM2016-05-29Sunday, May 29, 2016 2:45:56 AM2016-05-30Monday, May 30, 2016 2:10:23 AM2016-05-31Tuesday, May 31, 2016 1:34:50 AM2016-06-01Wednesday, June 01, 2016 12:59:17 AM2016-06-02Thursday, June 02, 2016 12:23:44 AM2016-06-02Thursday, June 02, 2016 11:48:11 PM2016-06-03Friday, June 03, 2016 11:12:38 PM2016-06-04Saturday, June 04, 2016 10:37:05 PM2016-06-05Sunday, June 05, 2016 10:01:32 PM2016-06-06Monday, June 06, 2016 9:25:59 PM2016-06-07Tuesday, June 07, 2016 8:50:26 PM2016-06-08Wednesday, June 08, 2016 8:14:53 PM2016-06-09Thursday, June 09, 2016 7:39:20 PM2016-06-10Friday, June 10, 2016 7:03:47 PM2016-06-11Saturday, June 11, 2016 6:28:14 PM2016-06-12Sunday, June 12, 2016 5:52:41 PM2016-06-13Monday, June 13, 2016 5:17:08 PM2016-06-14Tuesday, June 14, 2016 4:41:35 PM2016-06-15Wednesday, June 15, 2016 4:06:02 PM2016-06-16Thursday, June 16, 2016 3:30:29 PM2016-06-17Friday, June 17, 2016 2:54:56 PM2016-06-18Saturday, June 18, 2016 2:19:23 PM2016-06-19Sunday, June 19, 2016 1:43:50 PM2016-06-20Monday, June 20, 2016 1:08:16 PM2016-06-21Tuesday, June 21, 2016 12:32:43 PM2016-06-22Wednesday, June 22, 2016 11:57:10 AM2016-06-23Thursday, June 23, 2016 11:21:37 AM2016-06-24Friday, June 24, 2016 10:46:04 AM2016-06-25Saturday, June 25, 2016 10:10:31 AM2016-06-26Sunday, June 26, 2016 9:34:58 AM2016-06-27Monday, June 27, 2016 8:59:25 AM2016-06-28Tuesday, June 28, 2016 8:23:52 AM2016-06-29Wednesday, June 29, 2016 7:48:19 AM2016-06-30Thursday, June 30, 2016 7:12:46 AM2016-07-01Friday, July 01, 2016 6:37:13 AM2016-07-02Saturday, July 02, 2016 6:01:40 AM2016-07-03Sunday, July 03, 2016 5:26:07 AM2016-07-04Monday, July 04, 2016 4:50:34 AM2016-07-05Tuesday, July 05, 2016 4:15:01 AM2016-07-06Wednesday, July 06, 2016 3:39:28 AM2016-07-07Thursday, July 07, 2016 3:03:55 AM2016-07-08Friday, July 08, 2016 2:28:22 AM2016-07-09Saturday, July 09, 2016 1:52:49 AM2016-07-10Sunday, July 10, 2016 1:17:16 AM2016-07-11Monday, July 11, 2016 12:41:43 AM2016-07-12Tuesday, July 12, 2016 12:06:10 AM2016-07-12Tuesday, July 12, 2016 11:30:36 PM2016-07-13Wednesday, July 13, 2016 10:55:03 PM2016-07-14Thursday, July 14, 2016 10:19:30 PM2016-07-15Friday, July 15, 2016 9:43:57 PM2016-07-16Saturday, July 16, 2016 9:08:24 PM2016-07-17Sunday, July 17, 2016 8:32:51 PM2016-07-18Monday, July 18, 2016 7:57:18 PM2016-07-19Tuesday, July 19, 2016 7:21:45 PM2016-07-20Wednesday, July 20, 2016 6:46:12 PM2016-07-21Thursday, July 21, 2016 6:10:39 PM2016-07-22Friday, July 22, 2016 5:35:06 PM2016-07-23Saturday, July 23, 2016 4:59:33 PM2016-07-24Sunday, July 24, 2016 4:24:00 PM2016-07-25Monday, July 25, 2016 3:48:27 PM2016-07-26Tuesday, July 26, 2016 3:12:54 PM2016-07-27Wednesday, July 27, 2016 2:37:21 PM2016-07-28Thursday, July 28, 2016 2:01:48 PM2016-07-29Friday, July 29, 2016 1:26:15 PM2016-07-30Saturday, July 30, 2016 12:50:42 PM2016-07-31Sunday, July 31, 2016 12:15:09 PM2016-08-01Monday, August 01, 2016 11:39:36 AM2016-08-02Tuesday, August 02, 2016 11:04:03 AM2016-08-03Wednesday, August 03, 2016 10:28:29 AM2016-08-04Thursday, August 04, 2016 9:52:56 AM2016-08-05Friday, August 05, 2016 9:17:23 AM2016-08-06Saturday, August 06, 2016 8:41:50 AM2016-08-07Sunday, August 07, 2016 8:06:17 AM2016-08-08Monday, August 08, 2016 7:30:44 AM2016-08-09Tuesday, August 09, 2016 6:55:11 AM2016-08-10Wednesday, August 10, 2016 6:19:38 AM2016-08-11Thursday, August 11, 2016 5:44:05 AM2016-08-12Friday, August 12, 2016 5:08:32 AM2016-08-13Saturday, August 13, 2016 4:32:59 AM2016-08-14Sunday, August 14, 2016 3:57:26 AM2016-08-15Monday, August 15, 2016 3:21:53 AM2016-08-16Tuesday, August 16, 2016 2:46:20 AM2016-08-17Wednesday, August 17, 2016 2:10:47 AM2016-08-18Thursday, August 18, 2016 1:35:14 AM2016-08-19Friday, August 19, 2016 12:59:41 AM2016-08-20Saturday, August 20, 2016 12:24:08 AM2016-08-20Saturday, August 20, 2016 11:48:35 PM2016-08-21Sunday, August 21, 2016 11:13:02 PM2016-08-22Monday, August 22, 2016 10:37:29 PM2016-08-23Tuesday, August 23, 2016 10:01:56 PM2016-08-24Wednesday, August 24, 2016 9:26:23 PM2016-08-25Thursday, August 25, 2016 8:50:49 PM2016-08-26Friday, August 26, 2016 8:15:16 PM2016-08-27Saturday, August 27, 2016 7:39:43 PM2016-08-28Sunday, August 28, 2016 7:04:10 PM2016-08-29Monday, August 29, 2016 6:28:37 PM2016-08-30Tuesday, August 30, 2016 5:53:04 PM2016-08-31Wednesday, August 31, 2016 5:17:31 PM2016-09-01Thursday, September 01, 2016 4:41:58 PM2016-09-02Friday, September 02, 2016 4:06:25 PM2016-09-03Saturday, September 03, 2016 3:30:52 PM2016-09-04Sunday, September 04, 2016 2:55:19 PM2016-09-05Monday, September 05, 2016 2:19:46 PM2016-09-06Tuesday, September 06, 2016 1:44:13 PM2016-09-07Wednesday, September 07, 2016 1:08:40 PM2016-09-08Thursday, September 08, 2016 12:33:07 PM2016-09-09Friday, September 09, 2016 11:57:34 AM2016-09-10Saturday, September 10, 2016 11:22:01 AM2016-09-11Sunday, September 11, 2016 10:46:28 AM2016-09-12Monday, September 12, 2016 10:10:55 AM2016-09-13Tuesday, September 13, 2016 9:35:22 AM2016-09-14Wednesday, September 14, 2016 8:59:49 AM2016-09-15Thursday, September 15, 2016 8:24:16 AM2016-09-16Friday, September 16, 2016 7:48:43 AM2016-09-17Saturday, September 17, 2016 7:13:09 AM2016-09-18Sunday, September 18, 2016 6:37:36 AM2016-09-19Monday, September 19, 2016 6:02:03 AM2016-09-20Tuesday, September 20, 2016 5:26:30 AM2016-09-21Wednesday, September 21, 2016 4:50:57 AM2016-09-22Thursday, September 22, 2016 4:15:24 AM2016-09-23Friday, September 23, 2016 3:39:51 AM2016-09-24Saturday, September 24, 2016 3:04:18 AM2016-09-25Sunday, September 25, 2016 2:28:45 AM2016-09-26Monday, September 26, 2016 1:53:12 AM2016-09-27Tuesday, September 27, 2016 1:17:39 AM2016-09-28Wednesday, September 28, 2016 12:42:06 AM2016-09-29Thursday, September 29, 2016 12:06:33 AM2016-09-29Thursday, September 29, 2016 11:31:00 PM2016-09-30Friday, September 30, 2016 10:55:27 PM2016-10-01Saturday, October 01, 2016 10:19:54 PM2016-10-02Sunday, October 02, 2016 9:44:21 PM2016-10-03Monday, October 03, 2016 9:08:48 PM2016-10-04Tuesday, October 04, 2016 8:33:15 PM2016-10-05Wednesday, October 05, 2016 7:57:42 PM2016-10-06Thursday, October 06, 2016 7:22:09 PM2016-10-07Friday, October 07, 2016 6:46:36 PM2016-10-08Saturday, October 08, 2016 6:11:03 PM2016-10-09Sunday, October 09, 2016 5:35:29 PM2016-10-10Monday, October 10, 2016 4:59:56 PM2016-10-11Tuesday, October 11, 2016 4:24:23 PM2016-10-12Wednesday, October 12, 2016 3:48:50 PM2016-10-13Thursday, October 13, 2016 3:13:17 PM2016-10-14Friday, October 14, 2016 2:37:44 PM2016-10-15Saturday, October 15, 2016 2:02:11 PM2016-10-16Sunday, October 16, 2016 1:26:38 PM2016-10-17Monday, October 17, 2016 12:51:05 PM2016-10-18Tuesday, October 18, 2016 12:15:32 PM2016-10-19Wednesday, October 19, 2016 11:39:59 AM2016-10-20Thursday, October 20, 2016 11:04:26 AM2016-10-21Friday, October 21, 2016 10:28:53 AM2016-10-22Saturday, October 22, 2016 9:53:20 AM2016-10-23Sunday, October 23, 2016 9:17:47 AM2016-10-24Monday, October 24, 2016 8:42:14 AM2016-10-25Tuesday, October 25, 2016 8:06:41 AM2016-10-26Wednesday, October 26, 2016 7:31:08 AM2016-10-27Thursday, October 27, 2016 6:55:35 AM2016-10-28Friday, October 28, 2016 6:20:02 AM2016-10-29Saturday, October 29, 2016 5:44:29 AM2016-10-30Sunday, October 30, 2016 5:08:56 AM2016-10-31Monday, October 31, 2016 4:33:22 AM2016-11-01Tuesday, November 01, 2016 3:57:49 AM2016-11-02Wednesday, November 02, 2016 3:22:16 AM2016-11-03Thursday, November 03, 2016 2:46:43 AM2016-11-04Friday, November 04, 2016 2:11:10 AM2016-11-05Saturday, November 05, 2016 1:35:37 AM2016-11-06Sunday, November 06, 2016 1:00:04 AM2016-11-06Sunday, November 06, 2016 11:24:31 PM2016-11-07Monday, November 07, 2016 10:48:58 PM2016-11-08Tuesday, November 08, 2016 10:13:25 PM2016-11-09Wednesday, November 09, 2016 9:37:52 PM2016-11-10Thursday, November 10, 2016 9:02:19 PM2016-11-11Friday, November 11, 2016 8:26:46 PM2016-11-12Saturday, November 12, 2016 7:51:13 PM2016-11-13Sunday, November 13, 2016 7:15:40 PM2016-11-14Monday, November 14, 2016 6:40:07 PM2016-11-15Tuesday, November 15, 2016 6:04:34 PM2016-11-16Wednesday, November 16, 2016 5:29:01 PM2016-11-17Thursday, November 17, 2016 4:53:28 PM2016-11-18Friday, November 18, 2016 4:17:55 PM2016-11-19Saturday, November 19, 2016 3:42:22 PM2016-11-20Sunday, November 20, 2016 3:06:49 PM2016-11-21Monday, November 21, 2016 2:31:16 PM2016-11-22Tuesday, November 22, 2016 1:55:42 PM2016-11-23Wednesday, November 23, 2016 1:20:09 PM2016-11-24Thursday, November 24, 2016 12:44:36 PM2016-11-25Friday, November 25, 2016 12:09:03 PM2016-11-26Saturday, November 26, 2016 11:33:30 AM2016-11-27Sunday, November 27, 2016 10:57:57 AM2016-11-28Monday, November 28, 2016 10:22:24 AM2016-11-29Tuesday, November 29, 2016 9:46:51 AM2016-11-30Wednesday, November 30, 2016 9:11:18 AM2016-12-01Thursday, December 01, 2016 8:35:45 AM2016-12-02Friday, December 02, 2016 8:00:12 AM2016-12-03Saturday, December 03, 2016 7:24:39 AM2016-12-04Sunday, December 04, 2016 6:49:06 AM2016-12-05Monday, December 05, 2016 6:13:33 AM2016-12-06Tuesday, December 06, 2016 5:38:00 AM2016-12-07Wednesday, December 07, 2016 5:02:27 AM2016-12-08Thursday, December 08, 2016 4:26:54 AM2016-12-09Friday, December 09, 2016 3:51:21 AM2016-12-10Saturday, December 10, 2016 3:15:48 AM2016-12-11Sunday, December 11, 2016 2:40:15 AM2016-12-12Monday, December 12, 2016 2:04:42 AM2016-12-13Tuesday, December 13, 2016 1:29:09 AM2016-12-14Wednesday, December 14, 2016 12:53:36 AM2016-12-15Thursday, December 15, 2016 12:18:02 AM2016-12-15Thursday, December 15, 2016 11:42:29 PM2016-12-16Friday, December 16, 2016 11:06:56 PM2016-12-17Saturday, December 17, 2016 10:31:23 PM2016-12-18Sunday, December 18, 2016 9:55:50 PM2016-12-19Monday, December 19, 2016 9:20:17 PM2016-12-20Tuesday, December 20, 2016 8:44:44 PM2016-12-21Wednesday, December 21, 2016 8:09:11 PM2016-12-22Thursday, December 22, 2016 7:33:38 PM2016-12-23Friday, December 23, 2016 6:58:05 PM2016-12-24Saturday, December 24, 2016 6:22:32 PM2016-12-25Sunday, December 25, 2016 5:46:59 PM2016-12-26Monday, December 26, 2016 5:11:26 PM2016-12-27Tuesday, December 27, 2016 4:35:53 PM2016-12-28Wednesday, December 28, 2016 4:00:20 PM2016-12-29Thursday, December 29, 2016 3:24:47 PM2016-12-30Friday, December 30, 2016 2:49:14 PM2016-12-31Saturday, December 31, 2016 2:13:41 PM2017-01-01Sunday, January 01, 2017 1:38:08 PM2017-01-02Monday, January 02, 2017 1:02:35 PM2017-01-03Tuesday, January 03, 2017 12:27:02 PM2017-01-04Wednesday, January 04, 2017 11:51:29 AM2017-01-05Thursday, January 05, 2017 11:15:56 AM2017-01-06Friday, January 06, 2017 10:40:22 AM2017-01-07Saturday, January 07, 2017 10:04:49 AM2017-01-08Sunday, January 08, 2017 9:29:16 AM2017-01-09Monday, January 09, 2017 8:53:43 AM2017-01-10Tuesday, January 10, 2017 8:18:10 AM2017-01-11Wednesday, January 11, 2017 7:42:37 AM2017-01-12Thursday, January 12, 2017 7:07:04 AM2017-01-13Friday, January 13, 2017 6:31:31 AM2017-01-14Saturday, January 14, 2017 5:55:58 AM2017-01-15Sunday, January 15, 2017 5:20:25 AM2017-01-16Monday, January 16, 2017 4:44:52 AM2017-01-17Tuesday, January 17, 2017 4:09:19 AM2017-01-18Wednesday, January 18, 2017 3:33:46 AM2017-01-19Thursday, January 19, 2017 2:58:13 AM2017-01-20Friday, January 20, 2017 2:22:40 AM2017-01-21Saturday, January 21, 2017 1:47:07 AM2017-01-22Sunday, January 22, 2017 1:11:34 AM2017-01-23Monday, January 23, 2017 12:36:01 AM2017-01-24Tuesday, January 24, 2017 12:00:28 AM2017-01-24Tuesday, January 24, 2017 11:24:55 PM2017-01-25Wednesday, January 25, 2017 10:49:22 PM2017-01-26Thursday, January 26, 2017 10:13:49 PM2017-01-27Friday, January 27, 2017 9:38:15 PM2017-01-28Saturday, January 28, 2017 9:02:42 PM2017-01-29Sunday, January 29, 2017 8:27:09 PM2017-01-30Monday, January 30, 2017 7:51:36 PM2017-01-31Tuesday, January 31, 2017 7:16:03 PM2017-02-01Wednesday, February 01, 2017 6:40:30 PM2017-02-02Thursday, February 02, 2017 6:04:57 PM2017-02-03Friday, February 03, 2017 5:29:24 PM2017-02-04Saturday, February 04, 2017 4:53:51 PM2017-02-05Sunday, February 05, 2017 4:18:18 PM2017-02-06Monday, February 06, 2017 3:42:45 PM2017-02-07Tuesday, February 07, 2017 3:07:12 PM2017-02-08Wednesday, February 08, 2017 2:31:39 PM2017-02-09Thursday, February 09, 2017 1:56:06 PM2017-02-10Friday, February 10, 2017 1:20:33 PM2017-02-11Saturday, February 11, 2017 12:45:00 PM2017-02-12Sunday, February 12, 2017 12:09:27 PM2017-02-13Monday, February 13, 2017 11:33:54 AM2017-02-14Tuesday, February 14, 2017 10:58:21 AM2017-02-15Wednesday, February 15, 2017 10:22:48 AM2017-02-16Thursday, February 16, 2017 9:47:15 AM2017-02-17Friday, February 17, 2017 9:11:42 AM2017-02-18Saturday, February 18, 2017 8:36:09 AM2017-02-19Sunday, February 19, 2017 8:00:35 AM2017-02-20Monday, February 20, 2017 7:25:02 AM2017-02-21Tuesday, February 21, 2017 6:49:29 AM2017-02-22Wednesday, February 22, 2017 6:13:56 AM2017-02-23Thursday, February 23, 2017 5:38:23 AM2017-02-24Friday, February 24, 2017 5:02:50 AM2017-02-25Saturday, February 25, 2017 4:27:17 AM2017-02-26Sunday, February 26, 2017 3:51:44 AM2017-02-27Monday, February 27, 2017 3:16:11 AM2017-02-28Tuesday, February 28, 2017 2:40:38 AM2017-03-01Wednesday, March 01, 2017 2:05:05 AM2017-03-02Thursday, March 02, 2017 1:29:32 AM2017-03-03Friday, March 03, 2017 12:53:59 AM2017-03-04Saturday, March 04, 2017 12:18:26 AM2017-03-04Saturday, March 04, 2017 11:42:53 PM2017-03-05Sunday, March 05, 2017 11:07:20 PM2017-03-06Monday, March 06, 2017 10:31:47 PM2017-03-07Tuesday, March 07, 2017 9:56:14 PM2017-03-08Wednesday, March 08, 2017 9:20:41 PM2017-03-09Thursday, March 09, 2017 8:45:08 PM2017-03-10Friday, March 10, 2017 8:09:35 PM2017-03-11Saturday, March 11, 2017 7:34:02 PM2017-03-12Sunday, March 12, 2017 7:58:29 PM2017-03-13Monday, March 13, 2017 7:22:55 PM2017-03-14Tuesday, March 14, 2017 6:47:22 PM2017-03-15Wednesday, March 15, 2017 6:11:49 PM2017-03-16Thursday, March 16, 2017 5:36:16 PM2017-03-17Friday, March 17, 2017 5:00:43 PM2017-03-18Saturday, March 18, 2017 4:25:10 PM2017-03-19Sunday, March 19, 2017 3:49:37 PM2017-03-20Monday, March 20, 2017 3:14:04 PM2017-03-21Tuesday, March 21, 2017 2:38:31 PM2017-03-22Wednesday, March 22, 2017 2:02:58 PM2017-03-23Thursday, March 23, 2017 1:27:25 PM2017-03-24Friday, March 24, 2017 12:51:52 PM2017-03-25Saturday, March 25, 2017 12:16:19 PM2017-03-26Sunday, March 26, 2017 11:40:46 AM2017-03-27Monday, March 27, 2017 11:05:13 AM2017-03-28Tuesday, March 28, 2017 10:29:40 AM2017-03-29Wednesday, March 29, 2017 9:54:07 AM2017-03-30Thursday, March 30, 2017 9:18:34 AM2017-03-31Friday, March 31, 2017 8:43:01 AM2017-04-01Saturday, April 01, 2017 8:07:28 AM2017-04-02Sunday, April 02, 2017 7:31:55 AM2017-04-03Monday, April 03, 2017 6:56:22 AM2017-04-04Tuesday, April 04, 2017 6:20:48 AM2017-04-05Wednesday, April 05, 2017 5:45:15 AM2017-04-06Thursday, April 06, 2017 5:09:42 AM2017-04-07Friday, April 07, 2017 4:34:09 AM2017-04-08Saturday, April 08, 2017 3:58:36 AM2017-04-09Sunday, April 09, 2017 3:23:03 AM2017-04-10Monday, April 10, 2017 2:47:30 AM2017-04-11Tuesday, April 11, 2017 2:11:57 AM2017-04-12Wednesday, April 12, 2017 1:36:24 AM2017-04-13Thursday, April 13, 2017 1:00:51 AM2017-04-14Friday, April 14, 2017 12:25:18 AM2017-04-14Friday, April 14, 2017 11:49:45 PM2017-04-15Saturday, April 15, 2017 11:14:12 PM2017-04-16Sunday, April 16, 2017 10:38:39 PM2017-04-17Monday, April 17, 2017 10:03:06 PM2017-04-18Tuesday, April 18, 2017 9:27:33 PM2017-04-19Wednesday, April 19, 2017 8:52:00 PM2017-04-20Thursday, April 20, 2017 8:16:27 PM2017-04-21Friday, April 21, 2017 7:40:54 PM2017-04-22Saturday, April 22, 2017 7:05:21 PM2017-04-23Sunday, April 23, 2017 6:29:48 PM2017-04-24Monday, April 24, 2017 5:54:15 PM2017-04-25Tuesday, April 25, 2017 5:18:42 PM2017-04-26Wednesday, April 26, 2017 4:43:08 PM2017-04-27Thursday, April 27, 2017 4:07:35 PM2017-04-28Friday, April 28, 2017 3:32:02 PM2017-04-29Saturday, April 29, 2017 2:56:29 PM2017-04-30Sunday, April 30, 2017 2:20:56 PM2017-05-01Monday, May 01, 2017 1:45:23 PM2017-05-02Tuesday, May 02, 2017 1:09:50 PM2017-05-03Wednesday, May 03, 2017 12:34:17 PM2017-05-04Thursday, May 04, 2017 11:58:44 AM2017-05-05Friday, May 05, 2017 11:23:11 AM2017-05-06Saturday, May 06, 2017 10:47:38 AM2017-05-07Sunday, May 07, 2017 10:12:05 AM2017-05-08Monday, May 08, 2017 9:36:32 AM2017-05-09Tuesday, May 09, 2017 9:00:59 AM2017-05-10Wednesday, May 10, 2017 8:25:26 AM2017-05-11Thursday, May 11, 2017 7:49:53 AM2017-05-12Friday, May 12, 2017 7:14:20 AM2017-05-13Saturday, May 13, 2017 6:38:47 AM2017-05-14Sunday, May 14, 2017 6:03:14 AM2017-05-15Monday, May 15, 2017 5:27:41 AM2017-05-16Tuesday, May 16, 2017 4:52:08 AM2017-05-17Wednesday, May 17, 2017 4:16:35 AM2017-05-18Thursday, May 18, 2017 3:41:02 AM2017-05-19Friday, May 19, 2017 3:05:28 AM2017-05-20Saturday, May 20, 2017 2:29:55 AM2017-05-21Sunday, May 21, 2017 1:54:22 AM2017-05-22Monday, May 22, 2017 1:18:49 AM2017-05-23Tuesday, May 23, 2017 12:43:16 AM2017-05-24Wednesday, May 24, 2017 12:07:43 AM2017-05-24Wednesday, May 24, 2017 11:32:10 PM2017-05-25Thursday, May 25, 2017 10:56:37 PM2017-05-26Friday, May 26, 2017 10:21:04 PM2017-05-27Saturday, May 27, 2017 9:45:31 PM2017-05-28Sunday, May 28, 2017 9:09:58 PM2017-05-29Monday, May 29, 2017 8:34:25 PM2017-05-30Tuesday, May 30, 2017 7:58:52 PM2017-05-31Wednesday, May 31, 2017 7:23:19 PM2017-06-01Thursday, June 01, 2017 6:47:46 PM2017-06-02Friday, June 02, 2017 6:12:13 PM2017-06-03Saturday, June 03, 2017 5:36:40 PM2017-06-04Sunday, June 04, 2017 5:01:07 PM2017-06-05Monday, June 05, 2017 4:25:34 PM2017-06-06Tuesday, June 06, 2017 3:50:01 PM2017-06-07Wednesday, June 07, 2017 3:14:28 PM2017-06-08Thursday, June 08, 2017 2:38:55 PM2017-06-09Friday, June 09, 2017 2:03:22 PM2017-06-10Saturday, June 10, 2017 1:27:48 PM2017-06-11Sunday, June 11, 2017 12:52:15 PM2017-06-12Monday, June 12, 2017 12:16:42 PM2017-06-13Tuesday, June 13, 2017 11:41:09 AM2017-06-14Wednesday, June 14, 2017 11:05:36 AM2017-06-15Thursday, June 15, 2017 10:30:03 AM2017-06-16Friday, June 16, 2017 9:54:30 AM2017-06-17Saturday, June 17, 2017 9:18:57 AM2017-06-18Sunday, June 18, 2017 8:43:24 AM2017-06-19Monday, June 19, 2017 8:07:51 AM2017-06-20Tuesday, June 20, 2017 7:32:18 AM2017-06-21Wednesday, June 21, 2017 6:56:45 AM2017-06-22Thursday, June 22, 2017 6:21:12 AM2017-06-23Friday, June 23, 2017 5:45:39 AM2017-06-24Saturday, June 24, 2017 5:10:06 AM2017-06-25Sunday, June 25, 2017 4:34:33 AM2017-06-26Monday, June 26, 2017 3:59:00 AM2017-06-27Tuesday, June 27, 2017 3:23:27 AM2017-06-28Wednesday, June 28, 2017 2:47:54 AM2017-06-29Thursday, June 29, 2017 2:12:21 AM2017-06-30Friday, June 30, 2017 1:36:48 AM2017-07-01Saturday, July 01, 2017 1:01:15 AM2017-07-02Sunday, July 02, 2017 12:25:41 AM2017-07-02Sunday, July 02, 2017 11:50:08 PM2017-07-03Monday, July 03, 2017 11:14:35 PM2017-07-04Tuesday, July 04, 2017 10:39:02 PM2017-07-05Wednesday, July 05, 2017 10:03:29 PM2017-07-06Thursday, July 06, 2017 9:27:56 PM2017-07-07Friday, July 07, 2017 8:52:23 PM2017-07-08Saturday, July 08, 2017 8:16:50 PM2017-07-09Sunday, July 09, 2017 7:41:17 PM2017-07-10Monday, July 10, 2017 7:05:44 PM2017-07-11Tuesday, July 11, 2017 6:30:11 PM2017-07-12Wednesday, July 12, 2017 5:54:38 PM2017-07-13Thursday, July 13, 2017 5:19:05 PM2017-07-14Friday, July 14, 2017 4:43:32 PM2017-07-15Saturday, July 15, 2017 4:07:59 PM2017-07-16Sunday, July 16, 2017 3:32:26 PM2017-07-17Monday, July 17, 2017 2:56:53 PM2017-07-18Tuesday, July 18, 2017 2:21:20 PM2017-07-19Wednesday, July 19, 2017 1:45:47 PM2017-07-20Thursday, July 20, 2017 1:10:14 PM2017-07-21Friday, July 21, 2017 12:34:41 PM2017-07-22Saturday, July 22, 2017 11:59:08 AM2017-07-23Sunday, July 23, 2017 11:23:35 AM2017-07-24Monday, July 24, 2017 10:48:01 AM2017-07-25Tuesday, July 25, 2017 10:12:28 AM2017-07-26Wednesday, July 26, 2017 9:36:55 AM2017-07-27Thursday, July 27, 2017 9:01:22 AM2017-07-28Friday, July 28, 2017 8:25:49 AM2017-07-29Saturday, July 29, 2017 7:50:16 AM2017-07-30Sunday, July 30, 2017 7:14:43 AM2017-07-31Monday, July 31, 2017 6:39:10 AM2017-08-01Tuesday, August 01, 2017 6:03:37 AM2017-08-02Wednesday, August 02, 2017 5:28:04 AM2017-08-03Thursday, August 03, 2017 4:52:31 AM2017-08-04Friday, August 04, 2017 4:16:58 AM2017-08-05Saturday, August 05, 2017 3:41:25 AM2017-08-06Sunday, August 06, 2017 3:05:52 AM2017-08-07Monday, August 07, 2017 2:30:19 AM2017-08-08Tuesday, August 08, 2017 1:54:46 AM2017-08-09Wednesday, August 09, 2017 1:19:13 AM2017-08-10Thursday, August 10, 2017 12:43:40 AM2017-08-11Friday, August 11, 2017 12:08:07 AM2017-08-11Friday, August 11, 2017 11:32:34 PM2017-08-12Saturday, August 12, 2017 10:57:01 PM2017-08-13Sunday, August 13, 2017 10:21:28 PM2017-08-14Monday, August 14, 2017 9:45:55 PM2017-08-15Tuesday, August 15, 2017 9:10:21 PM2017-08-16Wednesday, August 16, 2017 8:34:48 PM2017-08-17Thursday, August 17, 2017 7:59:15 PM2017-08-18Friday, August 18, 2017 7:23:42 PM2017-08-19Saturday, August 19, 2017 6:48:09 PM2017-08-20Sunday, August 20, 2017 6:12:36 PM2017-08-21Monday, August 21, 2017 5:37:03 PM2017-08-22Tuesday, August 22, 2017 5:01:30 PM2017-08-23Wednesday, August 23, 2017 4:25:57 PM2017-08-24Thursday, August 24, 2017 3:50:24 PM2017-08-25Friday, August 25, 2017 3:14:51 PM2017-08-26Saturday, August 26, 2017 2:39:18 PM2017-08-27Sunday, August 27, 2017 2:03:45 PM2017-08-28Monday, August 28, 2017 1:28:12 PM2017-08-29Tuesday, August 29, 2017 12:52:39 PM2017-08-30Wednesday, August 30, 2017 12:17:06 PM2017-08-31Thursday, August 31, 2017 11:41:33 AM2017-09-01Friday, September 01, 2017 11:06:00 AM2017-09-02Saturday, September 02, 2017 10:30:27 AM2017-09-03Sunday, September 03, 2017 9:54:54 AM2017-09-04Monday, September 04, 2017 9:19:21 AM2017-09-05Tuesday, September 05, 2017 8:43:48 AM";
+print(ret == expected)
\ No newline at end of file
diff -r b7bcdd009540 js/src/editline/editline.c
--- a/js/src/editline/editline.c	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/editline/editline.c	Thu Sep 11 15:19:25 2008 +0300
@@ -59,16 +59,17 @@
 
 
 /*
 **  Main editing routines for editline library.
 */
 #include "editline.h"
 #include <signal.h>
 #include <ctype.h>
+#include <unistd.h>
 
 /*
 **  Manifest constants.
 */
 #define SCREEN_WIDTH	80
 #define SCREEN_ROWS	24
 #define NO_ARG		(-1)
 #define DEL		127
@@ -149,22 +150,20 @@ STATIC int		TTYrows;
 
 /* Display print 8-bit chars as `M-x' or as the actual 8-bit char? */
 int		rl_meta_chars = 0;
 
 /*
 **  Declarations.
 */
 STATIC CHAR	*editinput();
-extern int	read();
-extern int	write();
 #if	defined(USE_TERMCAP)
-extern char	*getenv();
-extern char	*tgetstr();
-extern int	tgetent();
+#include <stdlib.h>
+#include <curses.h>
+#include <term.h>
 #endif	/* defined(USE_TERMCAP) */
 
 /*
 **  TTY input/output functions.
 */
 
 STATIC void
 TTYflush()
diff -r b7bcdd009540 js/src/jsapi.cpp
--- a/js/src/jsapi.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/jsapi.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -73,16 +73,17 @@
 #include "jsopcode.h"
 #include "jsparse.h"
 #include "jsregexp.h"
 #include "jsscan.h"
 #include "jsscope.h"
 #include "jsscript.h"
 #include "jsstr.h"
 #include "prmjtime.h"
+#include "jsstaticcheck.h"
 
 #ifdef JS_TRACER
 #include "jstracer.h"
 #endif
 
 #if JS_HAS_FILE_OBJECT
 #include "jsfile.h"
 #endif
@@ -4571,17 +4572,17 @@ JS_CompileUCScriptForPrincipals(JSContex
                                 const jschar *chars, size_t length,
                                 const char *filename, uintN lineno)
 {
     uint32 tcflags;
     JSScript *script;
 
     CHECK_REQUEST(cx);
     tcflags = JS_OPTIONS_TO_TCFLAGS(cx);
-    script = js_CompileScript(cx, obj, principals, tcflags,
+    script = js_CompileScript(cx, obj, NULL, principals, tcflags,
                               chars, length, NULL, filename, lineno);
     LAST_FRAME_CHECKS(cx, script);
     return script;
 }
 
 JS_PUBLIC_API(JSBool)
 JS_BufferIsCompilableUnit(JSContext *cx, JSObject *obj,
                           const char *bytes, size_t length)
@@ -4598,17 +4599,18 @@ JS_BufferIsCompilableUnit(JSContext *cx,
         return JS_TRUE;
 
     /*
      * Return true on any out-of-memory error, so our caller doesn't try to
      * collect more buffered source.
      */
     result = JS_TRUE;
     exnState = JS_SaveExceptionState(cx);
-    if (js_InitParseContext(cx, &pc, NULL, chars, length, NULL, NULL, 1)) {
+    if (js_InitParseContext(cx, &pc, NULL, NULL, chars, length, NULL, NULL,
+                            1)) {
         older = JS_SetErrorReporter(cx, NULL);
         if (!js_ParseScript(cx, obj, &pc) &&
             (pc.tokenStream.flags & TSF_UNEXPECTED_EOF)) {
             /*
              * We ran into an error.  If it was because we ran out of source,
              * we return false, so our caller will know to try to collect more
              * buffered source.
              */
@@ -4637,17 +4639,17 @@ JS_CompileFile(JSContext *cx, JSObject *
         if (!fp) {
             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CANT_OPEN,
                                  filename, "No such file or directory");
             return NULL;
         }
     }
 
     tcflags = JS_OPTIONS_TO_TCFLAGS(cx);
-    script = js_CompileScript(cx, obj, NULL, tcflags,
+    script = js_CompileScript(cx, obj, NULL, NULL, tcflags,
                               NULL, 0, fp, filename, 1);
     if (fp != stdin)
         fclose(fp);
     LAST_FRAME_CHECKS(cx, script);
     return script;
 }
 
 JS_PUBLIC_API(JSScript *)
@@ -4662,17 +4664,17 @@ JS_CompileFileHandleForPrincipals(JSCont
                                   const char *filename, FILE *file,
                                   JSPrincipals *principals)
 {
     uint32 tcflags;
     JSScript *script;
 
     CHECK_REQUEST(cx);
     tcflags = JS_OPTIONS_TO_TCFLAGS(cx);
-    script = js_CompileScript(cx, obj, principals, tcflags,
+    script = js_CompileScript(cx, obj, NULL, principals, tcflags,
                               NULL, 0, file, filename, 1);
     LAST_FRAME_CHECKS(cx, script);
     return script;
 }
 
 JS_PUBLIC_API(JSObject *)
 JS_NewScriptObject(JSContext *cx, JSScript *script)
 {
@@ -4785,17 +4787,17 @@ JS_CompileUCFunctionForPrincipals(JSCont
             fun = NULL;
             goto out2;
         }
     }
     fun = js_NewFunction(cx, NULL, NULL, 0, JSFUN_INTERPRETED, obj, funAtom);
     if (!fun)
         goto out2;
 
-    /* From this point the control must flow through the label out. */
+    MUST_FLOW_THROUGH("out");
     JS_PUSH_TEMP_ROOT_OBJECT(cx, FUN_OBJECT(fun), &tvr);
     for (i = 0; i < nargs; i++) {
         argAtom = js_Atomize(cx, argnames[i], strlen(argnames[i]), 0);
         if (!argAtom) {
             fun = NULL;
             goto out;
         }
         if (!js_AddLocal(cx, fun, argAtom, JSLOCAL_ARG)) {
@@ -5000,17 +5002,17 @@ JS_EvaluateUCScriptForPrincipals(JSConte
                                  const jschar *chars, uintN length,
                                  const char *filename, uintN lineno,
                                  jsval *rval)
 {
     JSScript *script;
     JSBool ok;
 
     CHECK_REQUEST(cx);
-    script = js_CompileScript(cx, obj, principals,
+    script = js_CompileScript(cx, obj, NULL, principals,
                               !rval
                               ? TCF_COMPILE_N_GO | TCF_NO_SCRIPT_RVAL
                               : TCF_COMPILE_N_GO,
                               chars, length, NULL, filename, lineno);
     if (!script) {
         LAST_FRAME_CHECKS(cx, script);
         return JS_FALSE;
     }
@@ -5772,17 +5774,17 @@ JS_ErrorFromException(JSContext *cx, jsv
     CHECK_REQUEST(cx);
     return js_ErrorFromException(cx, v);
 }
 
 JS_PUBLIC_API(JSBool)
 JS_ThrowReportedError(JSContext *cx, const char *message,
                       JSErrorReport *reportp)
 {
-    return js_ErrorToException(cx, message, reportp);
+    return cx->fp && js_ErrorToException(cx, message, reportp);
 }
 
 JS_PUBLIC_API(JSBool)
 JS_ThrowStopIteration(JSContext *cx)
 {
     return js_ThrowStopIteration(cx);
 }
 
diff -r b7bcdd009540 js/src/jsapi.h
--- a/js/src/jsapi.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/jsapi.h	Thu Sep 11 15:19:25 2008 +0300
@@ -450,17 +450,17 @@ class JSAutoRequest {
   private:
     static void *operator new(size_t) CPP_THROW_NEW { return 0; };
     static void operator delete(void *, size_t) { };
 #endif
 };
 
 class JSAutoSuspendRequest {
   public:
-    JSAutoSuspendRequest(JSContext *cx) : mContext(cx) {
+    JSAutoSuspendRequest(JSContext *cx) : mContext(cx), mSaveDepth(0) {
         if (mContext) {
             mSaveDepth = JS_SuspendRequest(mContext);
         }
     }
     ~JSAutoSuspendRequest() {
         resume();
     }
 
diff -r b7bcdd009540 js/src/jsarray.cpp
--- a/js/src/jsarray.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/jsarray.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -92,16 +92,17 @@
 #include "jsfun.h"
 #include "jsgc.h"
 #include "jsinterp.h"
 #include "jslock.h"
 #include "jsnum.h"
 #include "jsobj.h"
 #include "jsscope.h"
 #include "jsstr.h"
+#include "jsstaticcheck.h"
 
 /* 2^32 - 1 as a number and a string */
 #define MAXINDEX 4294967295u
 #define MAXSTR   "4294967295"
 
 /* Small arrays are dense, no matter what. */
 #define MIN_SPARSE_INDEX 32
 
@@ -1165,19 +1166,19 @@ js_MakeArraySlow(JSContext *cx, JSObject
      * we can tell when only named properties have been added to a dense array
      * to make it slow-but-not-sparse.
      */
     length = obj->fslots[JSSLOT_ARRAY_LENGTH];
     obj->fslots[JSSLOT_ARRAY_COUNT] = INT_FITS_IN_JSVAL(length)
                                       ? INT_TO_JSVAL(length)
                                       : JSVAL_VOID;
 
-    /* Make sure we preserve any flags borrowing bits in JSSLOT_CLASS. */
-    obj->fslots[JSSLOT_CLASS] ^= (jsval) &js_ArrayClass;
-    obj->fslots[JSSLOT_CLASS] |= (jsval) &js_SlowArrayClass;
+    /* Make sure we preserve any flags borrowing bits in classword. */
+    obj->classword ^= (jsuword) &js_ArrayClass;
+    obj->classword |= (jsuword) &js_SlowArrayClass;
 
     /* Swap in our new map. */
     oldmap = obj->map;
     obj->map = map;
     array_destroyObjectMap(cx, oldmap);
 
     return JS_TRUE;
 
@@ -1776,17 +1777,18 @@ static JSBool
 static JSBool
 array_sort(JSContext *cx, uintN argc, jsval *vp)
 {
     jsval *argv, fval, *vec, *mergesort_tmp, v;
     JSObject *obj;
     CompareArgs ca;
     jsuint len, newlen, i, undefs;
     JSTempValueRooter tvr;
-    JSBool hole, ok;
+    JSBool hole;
+    bool ok;
     size_t elemsize;
     JSString *str;
 
     /*
      * Optimize the default compare function case if all of obj's elements
      * have values of type string.
      */
     JSBool all_strings;
@@ -2273,17 +2275,17 @@ array_splice(JSContext *cx, uintN argc, 
         else if (d > delta)
             d = delta;
         count = (jsuint)d;
         end = begin + count;
         argc--;
         argv++;
     }
 
-    /* After this, control must flow through label out: to exit. */
+    MUST_FLOW_THROUGH("out");
     JS_PUSH_SINGLE_TEMP_ROOT(cx, JSVAL_NULL, &tvr);
 
     /* If there are elements to remove, put them into the return value. */
     if (count > 0) {
         for (last = begin; last < end; last++) {
             ok = JS_CHECK_OPERATION_LIMIT(cx, JSOW_JUMP) &&
                  GetArrayElement(cx, obj, last, &hole, &tvr.u.value);
             if (!ok)
@@ -2386,17 +2388,17 @@ array_concat(JSContext *cx, uintN argc, 
     } else {
         nobj = js_NewArrayObject(cx, 0, NULL);
         if (!nobj)
             return JS_FALSE;
         *vp = OBJECT_TO_JSVAL(nobj);
         length = 0;
     }
 
-    /* After this, control must flow through label out: to exit. */
+    MUST_FLOW_THROUGH("out");
     JS_PUSH_SINGLE_TEMP_ROOT(cx, JSVAL_NULL, &tvr);
 
     /* Loop over [0, argc] to concat args into nobj, expanding all Arrays. */
     for (i = 0; i <= argc; i++) {
         ok = JS_CHECK_OPERATION_LIMIT(cx, JSOW_JUMP);
         if (!ok)
             goto out;
         v = argv[i];
@@ -2514,17 +2516,17 @@ array_slice(JSContext *cx, uintN argc, j
     }
 
     /* Create a new Array object and root it using *vp. */
     nobj = js_NewArrayObject(cx, 0, NULL);
     if (!nobj)
         return JS_FALSE;
     *vp = OBJECT_TO_JSVAL(nobj);
 
-    /* After this, control must flow through label out: to exit. */
+    MUST_FLOW_THROUGH("out");
     JS_PUSH_SINGLE_TEMP_ROOT(cx, JSVAL_NULL, &tvr);
 
     for (slot = begin; slot < end; slot++) {
         ok = JS_CHECK_OPERATION_LIMIT(cx, JSOW_JUMP) &&
              GetArrayElement(cx, obj, slot, &hole, &tvr.u.value);
         if (!ok)
             goto out;
         if (!hole) {
@@ -2734,17 +2736,17 @@ array_extra(JSContext *cx, ArrayExtraMod
      * For all but REDUCE, we call with 3 args (value, index, array). REDUCE
      * requires 4 args (accum, value, index, array).
      */
     argc = 3 + REDUCE_MODE(mode);
     elemroot = js_AllocStack(cx, 1 + 2 + argc, &mark);
     if (!elemroot)
         return JS_FALSE;
 
-    /* From this point the control must flow through out:. */
+    MUST_FLOW_THROUGH("out");
     ok = JS_TRUE;
     invokevp = elemroot + 1;
 
     for (i = start; i != end; i += step) {
         ok = JS_CHECK_OPERATION_LIMIT(cx, JSOW_JUMP) &&
              GetArrayElement(cx, obj, i, &hole, elemroot);
         if (!ok)
             goto out;
diff -r b7bcdd009540 js/src/jsbuiltins.cpp
--- a/js/src/jsbuiltins.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/jsbuiltins.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -43,16 +43,17 @@
 #include <math.h>
 
 #include "jsapi.h"
 #include "jsarray.h"
 #include "jsbool.h"
 #include "jscntxt.h"
 #include "jsgc.h"
 #include "jsiter.h"
+#include "jslibmath.h"
 #include "jsmath.h"
 #include "jsnum.h"
 #include "jsscope.h"
 #include "jsstr.h"
 #include "jstracer.h"
 
 #include "nanojit/avmplus.h"
 #include "nanojit/nanojit.h"
@@ -162,33 +163,53 @@ js_Math_floor(jsdouble d)
 }
 
 jsdouble FASTCALL
 js_Math_ceil(jsdouble d)
 {
     return ceil(d);
 }
 
+extern jsdouble js_NaN;
+
 jsdouble FASTCALL
 js_Math_pow(jsdouble d, jsdouble p)
 {
-#ifdef NOTYET
-    /* XXX Need to get a NaN here without parameterizing on context all the time. */
     if (!JSDOUBLE_IS_FINITE(p) && (d == 1.0 || d == -1.0))
-        return NaN;
-#endif
+        return js_NaN;
     if (p == 0)
         return 1.0;
     return pow(d, p);
 }
 
 jsdouble FASTCALL
 js_Math_sqrt(jsdouble d)
 {
     return sqrt(d);
+}
+
+jsdouble FASTCALL
+js_Math_log(jsdouble d)
+{
+#if !JS_USE_FDLIBM_MATH && defined(SOLARIS) && defined(__GNUC__)
+    if (d < 0)
+        return js_NaN;
+#endif
+    return log(d);
+}
+
+jsdouble FASTCALL
+js_Math_max(jsdouble d, jsdouble p)
+{
+    if (JSDOUBLE_IS_NaN(d) || JSDOUBLE_IS_NaN(p))
+        return js_NaN;
+
+    if (p == 0 && p == d && fd_copysign(1.0, d) == -1)
+        return p;
+    return (d > p) ? d : p;
 }
 
 JSBool FASTCALL
 js_Array_dense_setelem(JSContext* cx, JSObject* obj, jsint i, jsval v)
 {
     JS_ASSERT(OBJ_IS_DENSE_ARRAY(cx, obj));
 
     jsuint length = ARRAY_DENSE_LENGTH(obj);
@@ -345,17 +366,17 @@ js_StringToNumber(JSContext* cx, JSStrin
     const jschar* ep;
     jsdouble d;
 
     JSSTRING_CHARS_AND_END(str, bp, end);
     if ((!js_strtod(cx, bp, end, &ep, &d) ||
          js_SkipWhiteSpace(ep, end) != end) &&
         (!js_strtointeger(cx, bp, end, &ep, 0, &d) ||
          js_SkipWhiteSpace(ep, end) != end)) {
-        return *cx->runtime->jsNaN;
+        return js_NaN;
     }
     return d;
 }
 
 jsint FASTCALL
 js_StringToInt32(JSContext* cx, JSString* str)
 {
     const jschar* bp;
@@ -374,32 +395,40 @@ js_ParseFloat(JSContext* cx, JSString* s
 {
     const jschar* bp;
     const jschar* end;
     const jschar* ep;
     jsdouble d;
 
     JSSTRING_CHARS_AND_END(str, bp, end);
     if (!js_strtod(cx, bp, end, &ep, &d) || ep == bp)
-        return *cx->runtime->jsNaN;
+        return js_NaN;
     return d;
 }
 
 jsdouble FASTCALL
 js_ParseInt(JSContext* cx, JSString* str)
 {
     const jschar* bp;
     const jschar* end;
     const jschar* ep;
     jsdouble d;
 
     JSSTRING_CHARS_AND_END(str, bp, end);
     if (!js_strtointeger(cx, bp, end, &ep, 0, &d) || ep == bp)
-        return *cx->runtime->jsNaN;
+        return js_NaN;
     return d;
+}
+
+jsdouble FASTCALL
+js_ParseIntDouble(jsdouble d)
+{
+    if (!JSDOUBLE_IS_FINITE(d))
+        return js_NaN;
+    return floor(d);
 }
 
 jsval FASTCALL
 js_Any_getelem(JSContext* cx, JSObject* obj, JSString* idstr)
 {
     jsval v;
     jsid id;
 
@@ -464,21 +493,21 @@ js_FastNewArray(JSContext* cx, JSObject*
 {
     JS_ASSERT(OBJ_IS_ARRAY(cx, proto));
 
     JS_ASSERT(JS_ON_TRACE(cx));
     JSObject* obj = (JSObject*) js_NewGCThing(cx, GCX_OBJECT, sizeof(JSObject));
     if (!obj)
         return NULL;
 
+    JSClass* clasp = &js_ArrayClass;
+    obj->classword = jsuword(clasp);
+
     obj->fslots[JSSLOT_PROTO] = OBJECT_TO_JSVAL(proto);
     obj->fslots[JSSLOT_PARENT] = proto->fslots[JSSLOT_PARENT];
-
-    JSClass* clasp = &js_ArrayClass;
-    obj->fslots[JSSLOT_CLASS] = PRIVATE_TO_JSVAL(clasp);
 
     obj->fslots[JSSLOT_ARRAY_LENGTH] = 0;
     obj->fslots[JSSLOT_ARRAY_COUNT] = 0;
     for (unsigned i = JSSLOT_ARRAY_COUNT + 1; i != JS_INITIAL_NSLOTS; ++i)
         obj->fslots[i] = JSVAL_VOID;
 
     JSObjectOps* ops = clasp->getObjectOps(cx, clasp);
     obj->map = ops->newObjectMap(cx, 1, ops, clasp, obj);
@@ -509,19 +538,19 @@ js_FastNewObject(JSContext* cx, JSObject
     JSScopeProperty *sprop = SCOPE_GET_PROPERTY(scope, ATOM_TO_JSID(atom));
     JS_ASSERT(SPROP_HAS_VALID_SLOT(sprop, scope));
     jsval v = LOCKED_OBJ_GET_SLOT(ctor, sprop->slot);
     JS_UNLOCK_SCOPE(cx, scope);
 
     JS_ASSERT(!JSVAL_IS_PRIMITIVE(v));
     JSObject* proto = JSVAL_TO_OBJECT(v);
 
+    obj->classword = jsuword(clasp);
     obj->fslots[JSSLOT_PROTO] = OBJECT_TO_JSVAL(proto);
     obj->fslots[JSSLOT_PARENT] = ctor->fslots[JSSLOT_PARENT];
-    obj->fslots[JSSLOT_CLASS] = PRIVATE_TO_JSVAL(clasp);
     for (unsigned i = JSSLOT_PRIVATE; i != JS_INITIAL_NSLOTS; ++i)
         obj->fslots[i] = JSVAL_VOID;
 
     obj->map = js_HoldObjectMap(cx, proto->map);
     obj->dslots = NULL;
     return obj;
 }
 
@@ -644,17 +673,17 @@ js_Object_p_propertyIsEnumerable(JSConte
     JS_ASSERT(JSVAL_IS_BOOLEAN(v));
     return JSVAL_TO_BOOLEAN(v);
 }
 
 jsdouble FASTCALL
 js_BooleanToNumber(JSContext* cx, jsint unboxed)
 {
     if (unboxed == JSVAL_TO_BOOLEAN(JSVAL_VOID))
-        return *cx->runtime->jsNaN;
+        return js_NaN;
     return unboxed;
 }
 
 JSString* FASTCALL
 js_ObjectToString(JSContext* cx, JSObject* obj)
 {
     if (!obj)
         return ATOM_TO_STRING(cx->runtime->atomState.nullAtom);
@@ -712,16 +741,22 @@ js_Array_3num(JSContext* cx, JSObject* p
 {
     ARRAY_CTOR_GUTS(3,
         if (!js_NewDoubleInRootedValue(cx, n1, ++newslots))
             return NULL;
         if (!js_NewDoubleInRootedValue(cx, n2, ++newslots))
             return NULL;
         if (!js_NewDoubleInRootedValue(cx, n3, ++newslots))
             return NULL;)
+}
+
+JSObject* FASTCALL
+js_Arguments(JSContext* cx)
+{
+    return NULL;
 }
 
 /* soft float */
 
 jsdouble FASTCALL
 js_fneg(jsdouble x)
 {
     return -x;
diff -r b7bcdd009540 js/src/jscntxt.cpp
--- a/js/src/jscntxt.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/jscntxt.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -863,17 +863,17 @@ ReportError(JSContext *cx, const char *m
     /*
      * Call the error reporter only if an exception wasn't raised.
      *
      * If an exception was raised, then we call the debugErrorHook
      * (if present) to give it a chance to see the error before it
      * propagates out of scope.  This is needed for compatability
      * with the old scheme.
      */
-    if (!js_ErrorToException(cx, message, reportp)) {
+    if (!cx->fp || !js_ErrorToException(cx, message, reportp)) {
         js_ReportErrorAgain(cx, message, reportp);
     } else if (cx->debugHooks->debugErrorHook && cx->errorReporter) {
         JSDebugErrorHook hook = cx->debugHooks->debugErrorHook;
         /* test local in case debugErrorHook changed on another thread */
         if (hook)
             hook(cx, message, reportp, cx->debugHooks->debugErrorHookData);
     }
 }
diff -r b7bcdd009540 js/src/jsdbgapi.cpp
--- a/js/src/jsdbgapi.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/jsdbgapi.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -1151,29 +1151,22 @@ JS_GetFrameFunction(JSContext *cx, JSSta
 JS_GetFrameFunction(JSContext *cx, JSStackFrame *fp)
 {
     return fp->fun;
 }
 
 JS_PUBLIC_API(JSObject *)
 JS_GetFrameFunctionObject(JSContext *cx, JSStackFrame *fp)
 {
-    /*
-     * Test both fp->fun and fp->argv to defend against any control flow from
-     * the compiler reaching this API entry point, where fp is a frame pushed
-     * by the compiler that has non-null fun but null argv.
-     */
-    if (fp->fun && fp->argv) {
-        JSObject *obj = fp->callee;
+    if (!fp->fun)
+        return NULL;
 
-        JS_ASSERT(OBJ_GET_CLASS(cx, obj) == &js_FunctionClass);
-        JS_ASSERT(OBJ_GET_PRIVATE(cx, obj) == fp->fun);
-        return obj;
-    }
-    return NULL;
+    JS_ASSERT(OBJ_GET_CLASS(cx, fp->callee) == &js_FunctionClass);
+    JS_ASSERT(OBJ_GET_PRIVATE(cx, fp->callee) == fp->fun);
+    return fp->callee;
 }
 
 JS_PUBLIC_API(JSBool)
 JS_IsConstructorFrame(JSContext *cx, JSStackFrame *fp)
 {
     return (fp->flags & JSFRAME_CONSTRUCTING) != 0;
 }
 
@@ -1248,36 +1241,28 @@ JS_SetDestroyScriptHook(JSRuntime *rt, J
 
 JS_PUBLIC_API(JSBool)
 JS_EvaluateUCInStackFrame(JSContext *cx, JSStackFrame *fp,
                           const jschar *chars, uintN length,
                           const char *filename, uintN lineno,
                           jsval *rval)
 {
     JSObject *scobj;
-    uint32 flags;
     JSScript *script;
     JSBool ok;
 
     scobj = JS_GetFrameScopeChain(cx, fp);
     if (!scobj)
         return JS_FALSE;
 
-    /*
-     * XXX Hack around ancient compiler API to propagate the JSFRAME_SPECIAL
-     * flags to the code generator.
-     */
-    flags = fp->flags;
-    fp->flags |= JSFRAME_DEBUGGER | JSFRAME_EVAL;
-    script = js_CompileScript(cx, scobj, JS_StackFramePrincipals(cx, fp),
+    script = js_CompileScript(cx, scobj, fp, JS_StackFramePrincipals(cx, fp),
                               TCF_COMPILE_N_GO |
                               TCF_PUT_STATIC_DEPTH(fp->script->staticDepth + 1),
                               chars, length, NULL,
                               filename, lineno);
-    fp->flags = flags;
     if (!script)
         return JS_FALSE;
 
     ok = js_Execute(cx, scobj, script, fp, JSFRAME_DEBUGGER | JSFRAME_EVAL,
                     rval);
     js_DestroyScript(cx, script);
     return ok;
 }
diff -r b7bcdd009540 js/src/jsemit.cpp
--- a/js/src/jsemit.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/jsemit.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -60,18 +60,18 @@
 #include "jsfun.h"
 #include "jsnum.h"
 #include "jsopcode.h"
 #include "jsparse.h"
 #include "jsregexp.h"
 #include "jsscan.h"
 #include "jsscope.h"
 #include "jsscript.h"
-
 #include "jsautooplen.h"
+#include "jsstaticcheck.h"
 
 /* Allocation chunk counts, must be powers of two in general. */
 #define BYTECODE_CHUNK  256     /* code allocation increment */
 #define SRCNOTE_CHUNK   64      /* initial srcnote allocation increment */
 #define TRYNOTE_CHUNK   64      /* trynote allocation increment */
 
 /* Macros to compute byte sizes from typed element counts. */
 #define BYTECODE_SIZE(n)        ((n) * sizeof(jsbytecode))
@@ -1161,32 +1161,32 @@ OptimizeSpanDeps(JSContext *cx, JSCodeGe
     cg->spanDeps = NULL;
     FreeJumpTargets(cg, cg->jumpTargets);
     cg->jumpTargets = NULL;
     cg->numSpanDeps = cg->numJumpTargets = 0;
     cg->spanDepTodo = CG_OFFSET(cg);
     return JS_TRUE;
 }
 
-static JSBool
+static ptrdiff_t
 EmitJump(JSContext *cx, JSCodeGenerator *cg, JSOp op, ptrdiff_t off)
 {
     JSBool extend;
     ptrdiff_t jmp;
     jsbytecode *pc;
 
     extend = off < JUMP_OFFSET_MIN || JUMP_OFFSET_MAX < off;
     if (extend && !cg->spanDeps && !BuildSpanDepTable(cx, cg))
-        return JS_FALSE;
+        return -1;
 
     jmp = js_Emit3(cx, cg, op, JUMP_OFFSET_HI(off), JUMP_OFFSET_LO(off));
     if (jmp >= 0 && (extend || cg->spanDeps)) {
         pc = CG_CODE(cg, jmp);
         if (!AddSpanDep(cx, cg, pc, pc, off))
-            return JS_FALSE;
+            return -1;
     }
     return jmp;
 }
 
 static ptrdiff_t
 GetJumpOffset(JSCodeGenerator *cg, jsbytecode *pc)
 {
     JSSpanDep *sd;
@@ -1563,18 +1563,17 @@ LookupCompileTimeConstant(JSContext *cx,
 
     /*
      * Chase down the cg stack, but only until we reach the outermost cg.
      * This enables propagating consts from top-level into switch cases in a
      * function compiled along with the top-level script.
      */
     *vp = JSVAL_HOLE;
     do {
-        if ((cg->treeContext.flags & TCF_IN_FUNCTION) ||
-            cx->fp->varobj == cx->fp->scopeChain) {
+        if (cg->treeContext.flags & (TCF_IN_FUNCTION | TCF_COMPILE_N_GO)) {
             /* XXX this will need revising when 'let const' is added. */
             stmt = js_LexicalLookup(&cg->treeContext, atom, NULL);
             if (stmt)
                 return JS_TRUE;
 
             ATOM_LIST_SEARCH(ale, &cg->constList, atom);
             if (ale) {
                 JS_ASSERT(ALE_VALUE(ale) != JSVAL_HOLE);
@@ -1585,22 +1584,23 @@ LookupCompileTimeConstant(JSContext *cx,
             /*
              * Try looking in the variable object for a direct property that
              * is readonly and permanent.  We know such a property can't be
              * shadowed by another property on obj's prototype chain, or a
              * with object or catch variable; nor can prop's value be changed,
              * nor can prop be deleted.
              */
             if (cg->treeContext.flags & TCF_IN_FUNCTION) {
-                if (js_LookupLocal(cx, cg->treeContext.fun, atom, NULL) !=
+                if (js_LookupLocal(cx, cg->treeContext.u.fun, atom, NULL) !=
                     JSLOCAL_NONE) {
                     break;
                 }
-            } else if (cg->treeContext.flags & TCF_COMPILE_N_GO) {
-                obj = cx->fp->varobj;
+            } else {
+                JS_ASSERT(cg->treeContext.flags & TCF_COMPILE_N_GO);
+                obj = cg->treeContext.u.scopeChain;
                 ok = OBJ_LOOKUP_PROPERTY(cx, obj, ATOM_TO_JSID(atom), &pobj,
                                          &prop);
                 if (!ok)
                     return JS_FALSE;
                 if (pobj == obj) {
                     /*
                      * We're compiling code that will be executed immediately,
                      * not re-executed against a different scope chain and/or
@@ -1768,17 +1768,17 @@ EmitSlotIndexOp(JSContext *cx, JSOp op, 
  *
  * The function returns -1 on failures.
  */
 static jsint
 AdjustBlockSlot(JSContext *cx, JSCodeGenerator *cg, jsint slot)
 {
     JS_ASSERT((jsuint) slot < cg->maxStackDepth);
     if (cg->treeContext.flags & TCF_IN_FUNCTION) {
-        slot += cg->treeContext.fun->u.i.nvars;
+        slot += cg->treeContext.u.fun->u.i.nvars;
         if ((uintN) slot >= SLOTNO_LIMIT) {
             js_ReportCompileErrorNumber(cx, CG_TS(cg), NULL,
                                         JSREPORT_ERROR,
                                         JSMSG_TOO_MANY_LOCALS);
             slot = -1;
         }
     }
     return slot;
@@ -1805,17 +1805,16 @@ static JSBool
 static JSBool
 BindNameToSlot(JSContext *cx, JSCodeGenerator *cg, JSParseNode *pn)
 {
     JSTreeContext *tc;
     JSAtom *atom;
     JSStmtInfo *stmt;
     jsint slot;
     JSOp op;
-    JSStackFrame *fp;
     JSLocalKind localKind;
     uintN index;
     JSAtomListElement *ale;
     JSBool constOp;
 
     JS_ASSERT(pn->pn_type == TOK_NAME);
     if (pn->pn_slot >= 0 || pn->pn_op == JSOP_ARGUMENTS)
         return JS_TRUE;
@@ -1865,89 +1864,74 @@ BindNameToSlot(JSContext *cx, JSCodeGene
      * We can't optimize if var and closure (a local function not in a larger
      * expression and not at top-level within another's body) collide.
      * XXX suboptimal: keep track of colliding names and deoptimize only those
      */
     if (tc->flags & TCF_FUN_CLOSURE_VS_VAR)
         return JS_TRUE;
 
     if (!(tc->flags & TCF_IN_FUNCTION)) {
-        if ((cx->fp->flags & JSFRAME_SPECIAL) && cx->fp->fun) {
-            if (cg->staticDepth > JS_DISPLAY_SIZE)
-                goto out;
-
-            localKind = js_LookupLocal(cx, cx->fp->fun, atom, &index);
-            if (localKind != JSLOCAL_NONE) {
-                if (PN_OP(pn) == JSOP_NAME) {
-                    ATOM_LIST_SEARCH(ale, &cg->upvarList, atom);
-                    if (!ale) {
-                        uint32 cookie, length, *vector;
-
-                        ale = js_IndexAtom(cx, atom, &cg->upvarList);
-                        if (!ale)
-                            return JS_FALSE;
-                        JS_ASSERT(ALE_INDEX(ale) == cg->upvarList.count - 1);
-
-                        length = cg->upvarMap.length;
-                        JS_ASSERT(ALE_INDEX(ale) <= length);
-                        if (ALE_INDEX(ale) == length) {
-                            length = 2 * JS_MAX(2, length);
-                            vector = (uint32 *)
-                                     JS_realloc(cx, cg->upvarMap.vector,
-                                                length * sizeof *vector);
-                            if (!vector)
-                                return JS_FALSE;
-                            cg->upvarMap.vector = vector;
-                            cg->upvarMap.length = length;
-                        }
-
-                        if (localKind != JSLOCAL_ARG)
-                            index += cx->fp->fun->nargs;
-                        if (index >= JS_BIT(16)) {
-                            cg->treeContext.flags |= TCF_FUN_USES_NONLOCALS;
-                            return JS_TRUE;
-                        }
-
-                        cookie = MAKE_UPVAR_COOKIE(1, index);
-                        cg->upvarMap.vector[ALE_INDEX(ale)] = cookie;
-                    }
-
-                    pn->pn_op = JSOP_GETUPVAR;
-                    pn->pn_slot = ALE_INDEX(ale);
+        JSStackFrame *caller;
+
+        caller = tc->parseContext->callerFrame;
+        if (caller) {
+            JS_ASSERT(tc->flags & TCF_COMPILE_N_GO);
+            JS_ASSERT(caller->script);
+            if (!caller->fun || caller->varobj != tc->u.scopeChain)
+                return JS_TRUE;
+
+            /*
+             * We are compiling eval or debug script inside a function frame
+             * and the scope chain matches function's variable object.
+             * Optimize access to function's arguments and variable and the
+             * arguments object.
+             */
+            if (PN_OP(pn) != JSOP_NAME || cg->staticDepth > JS_DISPLAY_SIZE)
+                goto arguments_check;
+            localKind = js_LookupLocal(cx, caller->fun, atom, &index);
+            if (localKind == JSLOCAL_NONE)
+                goto arguments_check;
+
+            ATOM_LIST_SEARCH(ale, &cg->upvarList, atom);
+            if (!ale) {
+                uint32 cookie, length, *vector;
+
+                ale = js_IndexAtom(cx, atom, &cg->upvarList);
+                if (!ale)
+                    return JS_FALSE;
+                JS_ASSERT(ALE_INDEX(ale) == cg->upvarList.count - 1);
+
+                length = cg->upvarMap.length;
+                JS_ASSERT(ALE_INDEX(ale) <= length);
+                if (ALE_INDEX(ale) == length) {
+                    length = 2 * JS_MAX(2, length);
+                    vector = (uint32 *)
+                             JS_realloc(cx, cg->upvarMap.vector,
+                                        length * sizeof *vector);
+                    if (!vector)
+                        return JS_FALSE;
+                    cg->upvarMap.vector = vector;
+                    cg->upvarMap.length = length;
+                }
+
+                if (localKind != JSLOCAL_ARG)
+                    index += caller->fun->nargs;
+                if (index >= JS_BIT(16)) {
+                    cg->treeContext.flags |= TCF_FUN_USES_NONLOCALS;
                     return JS_TRUE;
                 }
-            }
-            goto out;
-        }
-
-        /*
-         * We are compiling a script or eval, and eval is not inside a function
-         * activation.
-         */
-        fp = cx->fp;
-        if (fp->scopeChain != fp->varobj)
-            return JS_TRUE;
-
-        /*
-         * A Script object can be used to split an eval into a compile step
-         * done at construction time, and an execute step done separately,
-         * possibly in a different scope altogether.  We therefore cannot do
-         * any name-to-slot optimizations, but must lookup names at runtime.
-         * Note that script_exec ensures that its caller's frame has a Call
-         * object, so arg and var name lookups will succeed.
-         */
-        if (fp->flags & JSFRAME_SCRIPT_OBJECT)
-            return JS_TRUE;
-
-        /*
-         * We cannot optimize the name access when compiling with an eval or
-         * debugger frame.
-         */
-        if (fp->flags & JSFRAME_SPECIAL)
-            return JS_TRUE;
+
+                cookie = MAKE_UPVAR_COOKIE(1, index);
+                cg->upvarMap.vector[ALE_INDEX(ale)] = cookie;
+            }
+
+            pn->pn_op = JSOP_GETUPVAR;
+            pn->pn_slot = ALE_INDEX(ale);
+            return JS_TRUE;
+        }
 
         /*
          * We are optimizing global variables and there may be no pre-existing
          * global property named atom.  If atom was declared via const or var,
          * optimize pn to access fp->vars using the appropriate JSOP_*GVAR op.
          */
         ATOM_LIST_SEARCH(ale, &tc->decls, atom);
         if (!ale) {
@@ -1991,17 +1975,17 @@ BindNameToSlot(JSContext *cx, JSCodeGene
     }
 
     if (tc->flags & TCF_IN_FUNCTION) {
         /*
          * We are compiling a function body and may be able to optimize name
          * to stack slot. Look for an argument or variable in the function and
          * rewrite pn_op and update pn accordingly.
          */
-        localKind = js_LookupLocal(cx, tc->fun, atom, &index);
+        localKind = js_LookupLocal(cx, tc->u.fun, atom, &index);
         if (localKind != JSLOCAL_NONE) {
             op = PN_OP(pn);
             if (localKind == JSLOCAL_ARG) {
                 switch (op) {
                   case JSOP_NAME:     op = JSOP_GETARG; break;
                   case JSOP_SETNAME:  op = JSOP_SETARG; break;
                   case JSOP_INCNAME:  op = JSOP_INCARG; break;
                   case JSOP_NAMEINC:  op = JSOP_ARGINC; break;
@@ -2031,27 +2015,27 @@ BindNameToSlot(JSContext *cx, JSCodeGene
             }
             pn->pn_op = op;
             pn->pn_slot = index;
             return JS_TRUE;
         }
         tc->flags |= TCF_FUN_USES_NONLOCALS;
     }
 
-out:
-    /*
-     * Here we either compiling a function body or an eval script inside a
-     * function and couldn't optimize pn, so it's not a global or local slot
-     * name.
-     *
-     * Now we must check for the predefined arguments variable.  It may be
-     * overridden by assignment, in which case the function is heavyweight
-     * and the interpreter will look up 'arguments' in the function's call
-     * object.
-     */
+  arguments_check:
+    /*
+     * Here we either compiling a function body or an eval or debug script
+     * inside a function and couldn't optimize pn, so it's not a global or
+     * local slot name. We are also outside of any with blocks. Check if we
+     * can optimize the predefined arguments variable.
+     */
+    JS_ASSERT((tc->flags & TCF_IN_FUNCTION) ||
+              (tc->parseContext->callerFrame &&
+               tc->parseContext->callerFrame->fun &&
+               tc->parseContext->callerFrame->varobj == tc->u.scopeChain));
     if (pn->pn_op == JSOP_NAME &&
         atom == cx->runtime->atomState.argumentsAtom) {
         pn->pn_op = JSOP_ARGUMENTS;
         return JS_TRUE;
     }
     return JS_TRUE;
 }
 
@@ -2989,16 +2973,17 @@ EmitSwitch(JSContext *cx, JSCodeGenerato
             pc += INDEX_LEN;
         }
 
         /*
          * After this point, all control flow involving JSOP_TABLESWITCH
          * must set ok and goto out to exit this function.  To keep things
          * simple, all switchOp cases exit that way.
          */
+        MUST_FLOW_THROUGH("out");
         if (cg->spanDeps) {
             /*
              * We have already generated at least one big jump so we must
              * explicitly add span dependencies for the switch jumps. When
              * called below, js_SetJumpOffset can only do it when patching
              * the first big jump or when cg->spanDeps is null.
              */
             if (!AddSwitchSpanDeps(cx, cg, CG_CODE(cg, top)))
@@ -3156,21 +3141,16 @@ js_EmitFunctionScript(JSContext *cx, JSC
 {
     if (cg->treeContext.flags & TCF_FUN_IS_GENERATOR) {
         /* JSOP_GENERATOR must be the first instruction. */
         CG_SWITCH_TO_PROLOG(cg);
         JS_ASSERT(CG_NEXT(cg) == CG_BASE(cg));
         if (js_Emit1(cx, cg, JSOP_GENERATOR) < 0)
             return JS_FALSE;
         CG_SWITCH_TO_MAIN(cg);
-    }
-
-    if (!(cg->treeContext.flags & TCF_FUN_HEAVYWEIGHT) &&
-        (cg->treeContext.flags & TCF_COMPILE_N_GO)) {
-        STOBJ_SET_PARENT(FUN_OBJECT(cg->treeContext.fun), cx->fp->scopeChain);
     }
 
     return js_EmitTree(cx, cg, body) &&
            js_Emit1(cx, cg, JSOP_STOP) >= 0 &&
            js_NewScriptFromCG(cx, cg);
 }
 
 /* A macro for inlining at the top of js_EmitTree (whence it came). */
@@ -3987,17 +3967,17 @@ js_EmitTree(JSContext *cx, JSCodeGenerat
         if (!cg2) {
             js_ReportOutOfScriptQuota(cx);
             return JS_FALSE;
         }
         js_InitCodeGenerator(cx, cg2, cg->treeContext.parseContext,
                              cg->codePool, cg->notePool,
                              pn->pn_pos.begin.lineno);
         cg2->treeContext.flags = (uint16) (pn->pn_flags | TCF_IN_FUNCTION);
-        cg2->treeContext.fun = fun;
+        cg2->treeContext.u.fun = fun;
         cg2->staticDepth = cg->staticDepth + 1;
         cg2->parent = cg;
 
         /* We metered the max scope depth when parsed the function. */ 
         JS_SCOPE_DEPTH_METERING(cg2->treeContext.maxScopeDepth = (uintN) -1);
         if (!js_EmitFunctionScript(cx, cg2, pn->pn_body)) {
             pn = NULL;
         } else {
@@ -4035,35 +4015,29 @@ js_EmitTree(JSContext *cx, JSCodeGenerat
          * top-level functions should go in the prolog to predefine their
          * names in the variable object before the already-generated main code
          * is executed. This extra work for top-level scripts is not necessary
          * when we emit the code for a function. It is fully parsed prior to
          * invocation of the emitter and calls to js_EmitTree for function
          * definitions can be scheduled before generating the rest of code.
          */
         if (!(cg->treeContext.flags & TCF_IN_FUNCTION)) {
+            JS_ASSERT(!cg->treeContext.topStmt);
             CG_SWITCH_TO_PROLOG(cg);
-
-            /*
-             * Emit JSOP_CLOSURE for eval code to do fewer checks when
-             * instantiating top-level functions in the non-eval case.
-             */
-            JS_ASSERT(!cg->treeContext.topStmt);
-            op = (cx->fp->flags & JSFRAME_EVAL) ? JSOP_CLOSURE : JSOP_DEFFUN;
-            EMIT_INDEX_OP(op, index);
+            EMIT_INDEX_OP(JSOP_DEFFUN, index);
             CG_SWITCH_TO_MAIN(cg);
 
             /* Emit NOP for the decompiler. */
             if (!EmitFunctionDefNop(cx, cg, index))
                 return JS_FALSE;
         } else {
 #ifdef DEBUG
             JSLocalKind localKind =
 #endif
-                js_LookupLocal(cx, cg->treeContext.fun, fun->atom, &slot);
+                js_LookupLocal(cx, cg->treeContext.u.fun, fun->atom, &slot);
             JS_ASSERT(localKind == JSLOCAL_VAR || localKind == JSLOCAL_CONST);
             JS_ASSERT(pn->pn_index == (uint32) -1);
             pn->pn_index = index;
             if (!EmitSlotIndexOp(cx, JSOP_DEFLOCALFUN, slot, index, cg))
                 return JS_FALSE;
         }
         break;
       }
@@ -5130,22 +5104,22 @@ js_EmitTree(JSContext *cx, JSCodeGenerat
             JS_ASSERT(cg->treeContext.flags & TCF_IN_FUNCTION);
             for (pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
                 if (pn2->pn_type == TOK_FUNCTION) {
                     if (pn2->pn_op == JSOP_NOP) {
                         if (!js_EmitTree(cx, cg, pn2))
                             return JS_FALSE;
                     } else {
                         /*
-                         * A closure in a top-level block with function
+                         * JSOP_DEFFUN in a top-level block with function
                          * definitions appears, for example, when "if (true)"
                          * is optimized away from "if (true) function x() {}".
                          * See bug 428424.
                          */
-                        JS_ASSERT(pn2->pn_op == JSOP_CLOSURE);
+                        JS_ASSERT(pn2->pn_op == JSOP_DEFFUN);
                     }
                 }
             }
         }
         for (pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
             if (!js_EmitTree(cx, cg, pn2))
                 return JS_FALSE;
         }
diff -r b7bcdd009540 js/src/jsemit.h
--- a/js/src/jsemit.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/jsemit.h	Thu Sep 11 15:19:25 2008 +0300
@@ -166,18 +166,24 @@ struct JSTreeContext {              /* t
     JSStmtInfo      *topScopeStmt;  /* top lexical scope statement */
     JSObject        *blockChain;    /* compile time block scope chain (NB: one
                                        deeper than the topScopeStmt/downScope
                                        chain when in head of let block/expr) */
     JSParseNode     *blockNode;     /* parse node for a lexical scope.
                                        XXX combine with blockChain? */
     JSAtomList      decls;          /* function, const, and var declarations */
     JSParseContext  *parseContext;
-    JSFunction      *fun;           /* function to store argument and variable
+
+    union {
+
+        JSFunction  *fun;           /* function to store argument and variable
                                        names when flags & TCF_IN_FUNCTION */
+        JSObject    *scopeChain;    /* scope chain object for the script */
+    } u;
+
 #ifdef JS_SCOPE_DEPTH_METER
     uint16          scopeDepth;     /* current lexical scope chain depth */
     uint16          maxScopeDepth;  /* maximum lexical scope chain depth */
 #endif
 };
 
 #define TCF_IN_FUNCTION        0x01 /* parsing inside function body */
 #define TCF_RETURN_EXPR        0x02 /* function has 'return expr;' */
@@ -190,17 +196,16 @@ struct JSTreeContext {              /* t
 #define TCF_HAS_DEFXMLNS      0x100 /* default xml namespace = ...; parsed */
 #define TCF_HAS_FUNCTION_STMT 0x200 /* block contains a function statement */
 #define TCF_GENEXP_LAMBDA     0x400 /* flag lambda from generator expression */
 #define TCF_COMPILE_N_GO      0x800 /* compiler-and-go mode of script, can
                                        optimize name references based on scope
                                        chain */
 #define TCF_NO_SCRIPT_RVAL   0x1000 /* API caller does not want result value
                                        from global script */
-
 /*
  * Flags to propagate out of the blocks.
  */
 #define TCF_RETURN_FLAGS        (TCF_RETURN_EXPR | TCF_RETURN_VOID)
 
 /*
  * Flags to propagate from FunctionBody.
  */
@@ -225,17 +230,17 @@ struct JSTreeContext {              /* t
 
 #define TREE_CONTEXT_INIT(tc, pc)                                             \
     ((tc)->flags = (tc)->ngvars = 0,                                          \
      (tc)->topStmt = (tc)->topScopeStmt = NULL,                               \
      (tc)->blockChain = NULL,                                                 \
      ATOM_LIST_INIT(&(tc)->decls),                                            \
      (tc)->blockNode = NULL,                                                  \
      (tc)->parseContext = (pc),                                               \
-     (tc)->fun = NULL,                                                        \
+     (tc)->u.scopeChain = NULL,                                               \
      JS_SCOPE_DEPTH_METERING((tc)->scopeDepth = (tc)->maxScopeDepth = 0))
 
 /*
  * For functions TREE_CONTEXT_FINISH is called the second time to finish the
  * extra tc created during code generation. We skip stats update in such
  * cases.
  */
 #define TREE_CONTEXT_FINISH(cx, tc)                                           \
diff -r b7bcdd009540 js/src/jsexn.cpp
--- a/js/src/jsexn.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/jsexn.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -56,16 +56,17 @@
 #include "jsexn.h"
 #include "jsfun.h"
 #include "jsinterp.h"
 #include "jsnum.h"
 #include "jsobj.h"
 #include "jsopcode.h"
 #include "jsscope.h"
 #include "jsscript.h"
+#include "jsstaticcheck.h"
 
 /* Forward declarations for js_ErrorClass's initializer. */
 static JSBool
 Exception(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 
 static void
 exn_finalize(JSContext *cx, JSObject *obj);
 
@@ -896,17 +897,17 @@ exn_toSource(JSContext *cx, uintN argc, 
                           vp)) {
         return JS_FALSE;
     }
     name = js_ValueToString(cx, *vp);
     if (!name)
         return JS_FALSE;
     *vp = STRING_TO_JSVAL(name);
 
-    /* After this, control must flow through label out: to exit. */
+    MUST_FLOW_THROUGH("out");
     JS_PUSH_TEMP_ROOT(cx, 3, localroots, &tvr);
 
 #ifdef __GNUC__
     message = filename = NULL;
 #endif
     ok = JS_GetProperty(cx, obj, js_message_str, &localroots[0]) &&
          (message = js_ValueToSource(cx, localroots[0]));
     if (!ok)
@@ -1167,21 +1168,20 @@ js_ErrorToException(JSContext *cx, const
     JSExnType exn;
     jsval tv[4];
     JSTempValueRooter tvr;
     JSBool ok;
     JSObject *errProto, *errObject;
     JSString *messageStr, *filenameStr;
 
     /*
-     * Tell our caller to report immediately if cx has no active frames, or if
-     * this report is just a warning.
+     * Tell our caller to report immediately if this report is just a warning.
      */
     JS_ASSERT(reportp);
-    if (!cx->fp || JSREPORT_IS_WARNING(reportp->flags))
+    if (JSREPORT_IS_WARNING(reportp->flags))
         return JS_FALSE;
 
     /* Find the exception index associated with this error. */
     errorNumber = (JSErrNum) reportp->errorNumber;
     errorString = js_GetLocalizedErrorMessage(cx, NULL, NULL, errorNumber);
     exn = errorString ? (JSExnType) errorString->exnType : JSEXN_NONE;
     JS_ASSERT(exn < JSEXN_LIMIT);
 
@@ -1203,17 +1203,17 @@ js_ErrorToException(JSContext *cx, const
      * Prevent runaway recursion, via cx->generatingError.  If an out-of-memory
      * error occurs, no exception object will be created, but we don't assume
      * that OOM is the only kind of error that subroutines of this function
      * called below might raise.
      */
     if (cx->generatingError)
         return JS_FALSE;
 
-    /* After this point the control must flow through the label out. */
+    MUST_FLOW_THROUGH("out");
     cx->generatingError = JS_TRUE;
 
     /* Protect the newly-created strings below from nesting GCs. */
     memset(tv, 0, sizeof tv);
     JS_PUSH_TEMP_ROOT(cx, JS_ARRAY_LENGTH(tv), tv, &tvr);
 
     /*
      * Try to get an appropriate prototype by looking up the corresponding
diff -r b7bcdd009540 js/src/jsexn.h
--- a/js/src/jsexn.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/jsexn.h	Thu Sep 11 15:19:25 2008 +0300
@@ -55,17 +55,17 @@ js_InitExceptionClasses(JSContext *cx, J
 js_InitExceptionClasses(JSContext *cx, JSObject *obj);
 
 /*
  * Given a JSErrorReport, check to see if there is an exception associated with
  * the error number.  If there is, then create an appropriate exception object,
  * set it as the pending exception, and set the JSREPORT_EXCEPTION flag on the
  * error report.  Exception-aware host error reporters should probably ignore
  * error reports so flagged.  Returns JS_TRUE if an associated exception is
- * found and set, JS_FALSE otherwise..
+ * found and set, JS_FALSE otherwise.
  */
 extern JSBool
 js_ErrorToException(JSContext *cx, const char *message, JSErrorReport *reportp);
 
 /*
  * Called if a JS API call to js_Execute or js_InternalCall fails; calls the
  * error reporter with the error report associated with any uncaught exception
  * that has been raised.  Returns true if there was an exception pending, and
diff -r b7bcdd009540 js/src/jsfun.cpp
--- a/js/src/jsfun.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/jsfun.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -60,16 +60,17 @@
 #include "jsobj.h"
 #include "jsopcode.h"
 #include "jsparse.h"
 #include "jsscan.h"
 #include "jsscope.h"
 #include "jsscript.h"
 #include "jsstr.h"
 #include "jsexn.h"
+#include "jsstaticcheck.h"
 
 #if JS_HAS_GENERATORS
 # include "jsiter.h"
 #endif
 
 #if JS_HAS_XDR
 # include "jsxdrapi.h"
 #endif
@@ -712,17 +713,17 @@ call_enumerate(JSContext *cx, JSObject *
 
     fun = js_GetCallObjectFunction(obj);
     n = JS_GET_LOCAL_NAME_COUNT(fun);
     if (n == 0)
         return JS_TRUE;
 
     mark = JS_ARENA_MARK(&cx->tempPool);
 
-    /* From this point the control must flow through the label out. */
+    MUST_FLOW_THROUGH("out");
     names = js_GetLocalNameArray(cx, fun, &cx->tempPool);
     if (!names) {
         ok = JS_FALSE;
         goto out;
     }
 
     for (i = 0; i != n; ++i) {
         name = JS_LOCAL_NAME_TO_ATOM(names[i]);
@@ -786,17 +787,17 @@ CallPropertyOp(JSContext *cx, JSObject *
                 if (!argsobj)
                     return JS_FALSE;
                 *vp = OBJECT_TO_JSVAL(argsobj);
             } else {
                 *vp = STOBJ_GET_SLOT(obj, JSSLOT_CALL_ARGUMENTS);
             }
         }
         return JS_TRUE;
-  }
+    }
 
     JS_ASSERT((int16) JSVAL_TO_INT(id) == JSVAL_TO_INT(id));
     i = (uint16) JSVAL_TO_INT(id);
     JS_ASSERT_IF(kind == JSCPK_ARG, i < fun->nargs);
     JS_ASSERT_IF(kind == JSCPK_VAR, i < fun->u.i.nvars);
 
     if (!fp) {
         i += CALL_CLASS_FIXED_RESERVED_SLOTS;
diff -r b7bcdd009540 js/src/jsinterp.cpp
--- a/js/src/jsinterp.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/jsinterp.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -63,16 +63,17 @@
 #include "jslock.h"
 #include "jsnum.h"
 #include "jsobj.h"
 #include "jsopcode.h"
 #include "jsscan.h"
 #include "jsscope.h"
 #include "jsscript.h"
 #include "jsstr.h"
+#include "jsstaticcheck.h"
 #ifdef JS_TRACER
 #include "jstracer.h"
 #endif
 
 #ifdef INCLUDE_MOZILLA_DTRACE
 #include "jsdtracef.h"
 #endif
 
@@ -253,17 +254,17 @@ js_FillPropertyCache(JSContext *cx, JSOb
      * shape if op is overtly mutating, to bias for the case where the mutator
      * udpates shape predictably.
      *
      * Note that an apparently non-mutating op such as JSOP_NAME may still
      * mutate the base object via, e.g., lazy standard class initialization,
      * but that is a one-time event and we'll have to miss the old shape and
      * re-fill under the new one.
      */
-    if (!(cs->format & (JOF_SET | JOF_INCDEC)))
+    if (!(cs->format & (JOF_SET | JOF_INCDEC)) && obj == pobj)
         kshape = scope->shape;
 
     khash = PROPERTY_CACHE_HASH_PC(pc, kshape);
     if (obj == pobj) {
         JS_ASSERT(kshape != 0 || scope->shape != 0);
         JS_ASSERT(scopeIndex == 0 && protoIndex == 0);
         JS_ASSERT(OBJ_SCOPE(obj)->object == obj);
     } else {
@@ -326,31 +327,30 @@ js_FullTestPropertyCache(JSContext *cx, 
     entry = &JS_PROPERTY_CACHE(cx).table[PROPERTY_CACHE_HASH_ATOM(atom, obj, NULL)];
     *entryp = entry;
     vcap = entry->vcap;
 
     if (entry->kpc != (jsbytecode *) atom) {
         PCMETER(JS_PROPERTY_CACHE(cx).idmisses++);
 
 #ifdef DEBUG_notme
-        entry = &JS_PROPERTY_CACHE(cx)
-                 .table[PROPERTY_CACHE_HASH_PC(pc, OBJ_SCOPE(obj)->shape)];
+        entry = &JS_PROPERTY_CACHE(cx).table[PROPERTY_CACHE_HASH_PC(pc, OBJ_SHAPE(obj))];
         fprintf(stderr,
                 "id miss for %s from %s:%u"
                 " (pc %u, kpc %u, kshape %u, shape %u)\n",
                 js_AtomToPrintableString(cx, atom),
                 cx->fp->script->filename,
                 js_PCToLineNumber(cx, cx->fp->script, pc),
                 pc - cx->fp->script->code,
                 entry->kpc - cx->fp->script->code,
                 entry->kshape,
-                OBJ_SCOPE(obj)->shape);
+                OBJ_SHAPE(obj));
                 js_Disassemble1(cx, cx->fp->script, pc,
-                        PTRDIFF(pc, cx->fp->script->code, jsbytecode),
-                        JS_FALSE, stderr);
+                                PTRDIFF(pc, cx->fp->script->code, jsbytecode),
+                                JS_FALSE, stderr);
 #endif
 
         return atom;
     }
 
     if (entry->kshape != (jsuword) obj) {
         PCMETER(JS_PROPERTY_CACHE(cx).komisses++);
         return atom;
@@ -378,17 +378,17 @@ js_FullTestPropertyCache(JSContext *cx, 
         if (!tmp || !OBJ_IS_NATIVE(tmp))
             break;
         JS_UNLOCK_OBJ(cx, pobj);
         pobj = tmp;
         JS_LOCK_OBJ(cx, pobj);
         --vcap;
     }
 
-    if (PCVCAP_SHAPE(vcap) == OBJ_SCOPE(pobj)->shape) {
+    if (PCVCAP_SHAPE(vcap) == OBJ_SHAPE(pobj)) {
 #ifdef DEBUG
         jsid id = ATOM_TO_JSID(atom);
 
         CHECK_FOR_STRING_INDEX(id);
         JS_ASSERT(SCOPE_GET_PROPERTY(OBJ_SCOPE(pobj), id));
         JS_ASSERT(OBJ_SCOPE(pobj)->object == pobj);
 #endif
         *pobjp = pobj;
@@ -926,17 +926,17 @@ js_OnUnknownMethod(JSContext *cx, jsval 
     jsid id;
     JSTempValueRooter tvr;
     JSBool ok;
 
     JS_ASSERT(!JSVAL_IS_PRIMITIVE(vp[1]));
     obj = JSVAL_TO_OBJECT(vp[1]);
     JS_PUSH_SINGLE_TEMP_ROOT(cx, JSVAL_NULL, &tvr);
 
-    /* From here on, control must flow through label out:. */
+    MUST_FLOW_THROUGH("out");
     id = ATOM_TO_JSID(cx->runtime->atomState.noSuchMethodAtom);
 #if JS_HAS_XML_SUPPORT
     if (OBJECT_IS_XML(cx, obj)) {
         JSXMLObjectOps *ops;
 
         ops = (JSXMLObjectOps *) obj->map->ops;
         obj = ops->getMethod(cx, obj, id, &tvr.u.value);
         if (!obj) {
@@ -1265,17 +1265,17 @@ have_fun:
     frame.slots = NULL;
     frame.sharpDepth = 0;
     frame.sharpArray = NULL;
     frame.flags = flags | rootedArgsFlag;
     frame.dormantNext = NULL;
     frame.xmlNamespace = NULL;
     frame.blockChain = NULL;
 
-    /* From here on, control must flow through label out: to return. */
+    MUST_FLOW_THROUGH("out");
     cx->fp = &frame;
 
     /* Init these now in case we goto out before first hook call. */
     hook = cx->debugHooks->callHook;
     hookData = NULL;
 
     /* call the hook if present */
     if (hook && (native || script))
@@ -2419,19 +2419,16 @@ JS_STATIC_ASSERT(JSOP_XMLNAME_LENGTH == 
 JS_STATIC_ASSERT(JSOP_XMLNAME_LENGTH == JSOP_CALLXMLNAME_LENGTH);
 
 /*
  * Same for JSOP_SETNAME and JSOP_SETPROP, which differ only slightly but
  * remain distinct for the decompiler. Ditto for JSOP_NULL{,THIS}.
  */
 JS_STATIC_ASSERT(JSOP_SETNAME_LENGTH == JSOP_SETPROP_LENGTH);
 JS_STATIC_ASSERT(JSOP_NULL_LENGTH == JSOP_NULLTHIS_LENGTH);
-
-/* Ensure we can share deffun and closure code. */
-JS_STATIC_ASSERT(JSOP_DEFFUN_LENGTH == JSOP_CLOSURE_LENGTH);
 
 /* See TRY_BRANCH_AFTER_COND. */
 JS_STATIC_ASSERT(JSOP_IFNE_LENGTH == JSOP_IFEQ_LENGTH);
 JS_STATIC_ASSERT(JSOP_IFNE == JSOP_IFEQ + 1);
 
 /* For the fastest case inder JSOP_INCNAME, etc. */
 JS_STATIC_ASSERT(JSOP_INCNAME_LENGTH == JSOP_DECNAME_LENGTH);
 JS_STATIC_ASSERT(JSOP_INCNAME_LENGTH == JSOP_NAMEINC_LENGTH);
@@ -2509,17 +2506,17 @@ js_Interpret(JSContext *cx)
 # include "jsopcode.tbl"
 # undef OPDEF
     };
 
     METER_OP_INIT(op);      /* to nullify first METER_OP_PAIR */
 
 # ifdef JS_TRACER
 #  define CHECK_RECORDER()  JS_BEGIN_MACRO                                    \
-                                JS_ASSERT(!JS_TRACE_MONITOR(cx).recorder ^    \
+                                JS_ASSERT(!TRACE_RECORDER(cx) ^               \
                                           (jumpTable == recordingJumpTable)); \
                             JS_END_MACRO
 # else
 #  define CHECK_RECORDER()  ((void)0)
 # endif
 
 # define DO_OP()            JS_BEGIN_MACRO                                    \
                                 CHECK_RECORDER();                             \
@@ -2568,21 +2565,21 @@ js_Interpret(JSContext *cx)
 # define ADD_EMPTY_CASE(OP) BEGIN_CASE(OP)
 # define END_EMPTY_CASES    goto advance_pc_by_one;
 
 #endif /* !JS_THREADED_INTERP */
 
 #ifdef JS_TRACER
     /* We had better not be entering the interpreter from JIT-compiled code. */
     TraceRecorder *tr = NULL;
-    if (JS_TRACE_MONITOR(cx).onTrace) {
-        tr = JS_TRACE_MONITOR(cx).recorder;
-        JS_TRACE_MONITOR(cx).recorder = NULL;
-    }
-#endif    
+    if (JS_ON_TRACE(cx)) {
+        tr = TRACE_RECORDER(cx);
+        SET_TRACE_RECORDER(cx, NULL);
+    }
+#endif
 
     /* Check for too deep of a native thread stack. */
     JS_CHECK_RECURSION(cx, return JS_FALSE);
 
     rt = cx->runtime;
 
     /* Set registerized frame pointer and derived script pointer. */
     fp = cx->fp;
@@ -2656,17 +2653,17 @@ js_Interpret(JSContext *cx)
         if (n <= 0) {                                                         \
             CHECK_BRANCH();                                                   \
             MONITOR_BRANCH(regs.pc - n);                                      \
         }                                                                     \
         op = (JSOp) *regs.pc;                                                 \
         DO_OP();                                                              \
     JS_END_MACRO
 
-    /* From this point control must flow through the label exit. */
+    MUST_FLOW_THROUGH("exit");
     ++cx->interpLevel;
 
     /*
      * Optimized Get and SetVersion for proper script language versioning.
      *
      * If any native method or JSClass/JSObjectOps hook calls js_SetVersion
      * and changes cx->version, the effect will "stick" and we will stop
      * maintaining currentVersion.  This is relied upon by testsuites, for
@@ -2694,42 +2691,41 @@ js_Interpret(JSContext *cx)
      * not have to reload it each time through the interpreter loop -- we hope
      * the compiler can keep it in a register when it is non-null.
      */
 #if JS_THREADED_INTERP
 #ifdef JS_TRACER
 # define LOAD_INTERRUPT_HANDLER(cx)                                           \
     ((void) (jumpTable = (cx)->debugHooks->interruptHandler                   \
                          ? interruptJumpTable                                 \
-                         : JS_TRACE_MONITOR(cx).recorder                      \
+                         : TRACE_RECORDER(cx)                                 \
                          ? recordingJumpTable                                 \
                          : normalJumpTable))
 # define ENABLE_TRACER(flag)                                                  \
     JS_BEGIN_MACRO                                                            \
         bool flag_ = (flag);                                                  \
-        JS_ASSERT(flag_ == !!JS_TRACE_MONITOR(cx).recorder);                  \
+        JS_ASSERT(flag_ == !!TRACE_RECORDER(cx));                             \
         jumpTable = flag_ ? recordingJumpTable : normalJumpTable;             \
     JS_END_MACRO
 #else /* !JS_TRACER */
 # define LOAD_INTERRUPT_HANDLER(cx)                                           \
     ((void) (jumpTable = (cx)->debugHooks->interruptHandler                   \
                          ? interruptJumpTable                                 \
                          : normalJumpTable))
 # define ENABLE_TRACER(flag) ((void)0)
 #endif /* !JS_TRACER */
 #else /* !JS_THREADED_INTERP */
 #ifdef JS_TRACER
 # define LOAD_INTERRUPT_HANDLER(cx)                                           \
     ((void) (switchMask = ((cx)->debugHooks->interruptHandler ||              \
-                           JS_TRACE_MONITOR(cx).recorder)                     \
-                          ? 0 : 255))
+                           TRACE_RECORDER(cx)) ? 0 : 255))
 # define ENABLE_TRACER(flag)                                                  \
     JS_BEGIN_MACRO                                                            \
         bool flag_ = (flag);                                                  \
-        JS_ASSERT(flag_ == !!JS_TRACE_MONITOR(cx).recorder);                  \
+        JS_ASSERT(flag_ == !!TRACE_RECORDER(cx));                             \
         switchMask = flag_ ? 0 : 255;                                         \
     JS_END_MACRO
 #else /* !JS_TRACER */
 # define LOAD_INTERRUPT_HANDLER(cx)                                           \
     ((void) (switchMask = ((cx)->debugHooks->interruptHandler                 \
                            ? 0 : 255)))
 # define ENABLE_TRACER(flag) ((void)0)
 #endif /* !JS_TRACER */
@@ -3021,17 +3017,17 @@ js_Interpret(JSContext *cx)
                 /* Restore the calling script's interpreter registers. */
                 script = fp->script;
                 atoms = script->atomMap.vector;
 
                 /* Resume execution in the calling frame. */
                 inlineCallCount--;
                 if (JS_LIKELY(ok)) {
 #ifdef JS_TRACER
-                    if (JS_TRACE_MONITOR(cx).recorder)
+                    if (TRACE_RECORDER(cx))
                         RECORD(LeaveFrame);
 #endif
                     JS_ASSERT(js_CodeSpec[*regs.pc].length == JSOP_CALL_LENGTH);
                     len = JSOP_CALL_LENGTH;
                     DO_NEXT_OP(len);
                 }
                 goto error;
             }
@@ -3265,17 +3261,16 @@ js_Interpret(JSContext *cx)
               default:
                 JS_ASSERT(op == JSOP_FORNAME);
 
                 /*
                  * We find property here after the iterator call to ensure
                  * that we take into account side effects of the iterator
                  * call. See bug 372331.
                  */
-
                 if (!js_FindProperty(cx, id, &obj, &obj2, &prop))
                     goto error;
                 if (prop)
                     OBJ_DROP_PROPERTY(cx, obj2, prop);
 
               set_for_property:
                 /* Set the variable obj[id] to refer to rval. */
                 fp->flags |= JSFRAME_ASSIGNING;
@@ -4417,17 +4412,17 @@ js_Interpret(JSContext *cx)
 
             do {
                 JSPropCacheEntry *entry;
 
                 entry = NULL;
                 atom = NULL;
                 if (JS_LIKELY(obj->map->ops->setProperty == js_SetProperty)) {
                     JSPropertyCache *cache = &JS_PROPERTY_CACHE(cx);
-                    uint32 kshape = OBJ_SCOPE(obj)->shape;
+                    uint32 kshape = OBJ_SHAPE(obj);
 
                     /*
                      * Open-code JS_PROPERTY_CACHE_TEST, specializing for two
                      * important set-property cases. First:
                      *
                      *   function f(a, b, c) {
                      *     var o = {p:a, q:b, r:c};
                      *     return o;
@@ -4438,30 +4433,33 @@ js_Interpret(JSContext *cx)
                      * of property additions. And second:
                      *
                      *   o.p = x;
                      *
                      * in a frequently executed method or loop body, where p
                      * will (possibly after the first iteration) always exist
                      * in native object o.
                      */
-                    entry = &cache->table[PROPERTY_CACHE_HASH_PC(regs.pc,
-                                                                 kshape)];
+                    entry = &cache->table[PROPERTY_CACHE_HASH_PC(regs.pc, kshape)];
                     PCMETER(cache->tests++);
                     PCMETER(cache->settests++);
                     if (entry->kpc == regs.pc && entry->kshape == kshape) {
                         JSScope *scope;
 
                         JS_LOCK_OBJ(cx, obj);
                         scope = OBJ_SCOPE(obj);
                         if (scope->shape == kshape) {
                             JS_ASSERT(PCVAL_IS_SPROP(entry->vword));
                             sprop = PCVAL_TO_SPROP(entry->vword);
                             JS_ASSERT(!(sprop->attrs & JSPROP_READONLY));
                             JS_ASSERT(!SCOPE_IS_SEALED(OBJ_SCOPE(obj)));
+
+#ifdef JS_TRACER
+                            TRACE_2(SetPropHit, kshape, sprop);
+#endif
 
                             if (scope->object == obj) {
                                 /*
                                  * Fastest path: the cached sprop is already
                                  * in scope. Just NATIVE_SET and break to get
                                  * out of the do-while(0).
                                  */
                                 if (sprop == scope->lastProp ||
@@ -4594,20 +4592,26 @@ js_Interpret(JSContext *cx)
                         if (obj == obj2 && !PCVAL_IS_OBJECT(entry->vword))
                             break;
                     }
                 }
 
                 if (!atom)
                     LOAD_ATOM(0);
                 id = ATOM_TO_JSID(atom);
-                if (entry
-                    ? !js_SetPropertyHelper(cx, obj, id, &rval, &entry)
-                    : !OBJ_SET_PROPERTY(cx, obj, id, &rval)) {
-                    goto error;
+                if (entry) {
+                    if (!js_SetPropertyHelper(cx, obj, id, &rval, &entry))
+                        goto error;
+#ifdef JS_TRACER
+                    if (entry)
+                        TRACE_1(SetPropMiss, entry);
+#endif
+                } else {
+                    if (!OBJ_SET_PROPERTY(cx, obj, id, &rval))
+                        goto error;
                 }
             } while (0);
           END_SET_CASE_STORE_RVAL(JSOP_SETPROP, 2);
 
           BEGIN_CASE(JSOP_GETELEM)
             /* Open-coded ELEMENT_OP optimized for strings and dense arrays. */
             lval = FETCH_OPND(-2);
             rval = FETCH_OPND(-1);
@@ -4907,17 +4911,17 @@ js_Interpret(JSContext *cx)
                     newifp->callerRegs = regs;
                     fp->regs = &newifp->callerRegs;
                     regs.sp = newsp;
                     regs.pc = script->code;
                     newifp->frame.regs = &regs;
                     cx->fp = fp = &newifp->frame;
 
 #ifdef JS_TRACER
-                    if (JS_TRACE_MONITOR(cx).recorder)
+                    if (TRACE_RECORDER(cx))
                         RECORD(EnterFrame);
 #endif
 
                     inlineCallCount++;
                     JS_RUNTIME_METER(rt, inlineCalls);
 
 #ifdef INCLUDE_MOZILLA_DTRACE
                     /* DTrace function entry, inlines */
@@ -5651,78 +5655,65 @@ js_Interpret(JSContext *cx)
                     fp->slots[index] = INT_TO_JSVAL(sprop->slot);
                 }
             }
 
             OBJ_DROP_PROPERTY(cx, obj2, prop);
           END_CASE(JSOP_DEFVAR)
 
           BEGIN_CASE(JSOP_DEFFUN)
+            /*
+             * A top-level function defined in Global or Eval code (see
+             * ECMA-262 Ed. 3), or else a SpiderMonkey extension: a named
+             * function statement in a compound statement (not at the top
+             * statement level of global code, or at the top level of a
+             * function body).
+             */
             LOAD_FUNCTION(0);
 
-            /*
-             * We must be at top-level (either outermost block that forms a
-             * function's body, or a global) scope, not inside an expression
-             * (JSOP_{ANON,NAMED}FUNOBJ) or compound statement (JSOP_CLOSURE)
-             * in the same compilation unit (ECMA Program). We also not inside
-             * an eval script.
-             *
+            if (!fp->blockChain) {
+                obj2 = fp->scopeChain;
+            } else {
+                obj2 = js_GetScopeChain(cx, fp);
+                if (!obj2)
+                    goto error;
+            }
+
+            /*
              * If static link is not current scope, clone fun's object to link
-             * to the current scope via parent.  This clause exists to enable
+             * to the current scope via parent. This clause exists to enable
              * sharing of compiled functions among multiple equivalent scopes,
              * splitting the cost of compilation evenly among the scopes and
-             * amortizing it over a number of executions.  Examples include XUL
+             * amortizing it over a number of executions. Examples include XUL
              * scripts and event handlers shared among Mozilla chrome windows,
              * and server-side JS user-defined functions shared among requests.
-             *
-             * NB: The Script object exposes compile and exec in the language,
-             * such that this clause introduces an incompatible change from old
-             * JS versions that supported Script.  Such a JS version supported
-             * executing a script that defined and called functions scoped by
-             * the compile-time static link, not by the exec-time scope chain.
-             *
-             * We sacrifice compatibility, breaking such scripts, in order to
-             * promote compile-cost sharing and amortizing, and because Script
-             * is not and will not be standardized.
-             */
-            JS_ASSERT(!fp->blockChain);
-            JS_ASSERT((fp->flags & JSFRAME_EVAL) == 0);
-            JS_ASSERT(fp->scopeChain == fp->varobj);
-            obj2 = fp->scopeChain;
-
-            /*
-             * ECMA requires functions defined when entering Global code to be
-             * permanent.
-             */
-            attrs = JSPROP_ENUMERATE | JSPROP_PERMANENT;
-
-          do_deffun:
-            /*
-             * The common code for JSOP_DEFFUN and JSOP_CLOSURE.
-             *
-             * Clone the function object with the current scope chain as the
-             * clone's parent.  The original function object is the prototype
-             * of the clone.  Do this only if re-parenting; the compiler may
-             * have seen the right parent already and created a sufficiently
-             * well-scoped function object.
              */
             obj = FUN_OBJECT(fun);
             if (OBJ_GET_PARENT(cx, obj) != obj2) {
                 obj = js_CloneFunctionObject(cx, fun, obj2);
                 if (!obj)
                     goto error;
             }
 
             /*
              * Protect obj from any GC hiding below OBJ_DEFINE_PROPERTY.  All
              * paths from here must flow through the "Restore fp->scopeChain"
              * code below the OBJ_DEFINE_PROPERTY call.
              */
+            MUST_FLOW_THROUGH("restore");
             fp->scopeChain = obj;
             rval = OBJECT_TO_JSVAL(obj);
+
+            /*
+             * ECMA requires functions defined when entering Eval code to be
+             * impermanent.
+             */
+            attrs = (fp->flags & JSFRAME_EVAL)
+                    ? JSPROP_ENUMERATE
+                    : JSPROP_ENUMERATE | JSPROP_PERMANENT;
 
             /*
              * Load function flags that are also property attributes.  Getters
              * and setters do not need a slot, their value is stored elsewhere
              * in the property itself, not in obj slots.
              */
             flags = JSFUN_GSFLAG2ATTR(fun->flags);
             if (flags) {
@@ -5732,31 +5723,29 @@ js_Interpret(JSContext *cx)
 
             /*
              * We define the function as a property of the variable object and
              * not the current scope chain even for the case of function
              * expression statements and functions defined by eval inside let
              * or with blocks.
              */
             parent = fp->varobj;
-            if (!parent)
-                goto error;
+            JS_ASSERT(parent);
 
             /*
              * Check for a const property of the same name -- or any kind
              * of property if executing with the strict option.  We check
              * here at runtime as well as at compile-time, to handle eval
              * as well as multiple HTML script tags.
              */
             id = ATOM_TO_JSID(fun->atom);
             ok = js_CheckRedeclaration(cx, parent, id, attrs, NULL, NULL);
             if (ok) {
                 if (attrs == JSPROP_ENUMERATE) {
                     JS_ASSERT(fp->flags & JSFRAME_EVAL);
-                    JS_ASSERT(op == JSOP_CLOSURE);
                     ok = OBJ_SET_PROPERTY(cx, parent, id, &rval);
                 } else {
                     JS_ASSERT(attrs & JSPROP_PERMANENT);
 
                     ok = OBJ_DEFINE_PROPERTY(cx, parent, id, rval,
                                              (flags & JSPROP_GETTER)
                                              ? JS_EXTENSION (JSPropertyOp) obj
                                              : JS_PropertyStub,
@@ -5764,16 +5753,17 @@ js_Interpret(JSContext *cx)
                                              ? JS_EXTENSION (JSPropertyOp) obj
                                              : JS_PropertyStub,
                                              attrs,
                                              NULL);
                 }
             }
 
             /* Restore fp->scopeChain now that obj is defined in fp->varobj. */
+            MUST_FLOW_LABEL(restore)
             fp->scopeChain = obj2;
             if (!ok) {
                 cx->weakRoots.newborn[GCX_OBJECT] = NULL;
                 goto error;
             }
           END_CASE(JSOP_DEFFUN)
 
           BEGIN_CASE(JSOP_DEFLOCALFUN)
@@ -5852,16 +5842,17 @@ js_Interpret(JSContext *cx)
             if (!obj)
                 goto error;
 
             /*
              * Protect obj from any GC hiding below OBJ_DEFINE_PROPERTY.  All
              * paths from here must flow through the "Restore fp->scopeChain"
              * code below the OBJ_DEFINE_PROPERTY call.
              */
+            MUST_FLOW_THROUGH("restore2");
             fp->scopeChain = obj;
             rval = OBJECT_TO_JSVAL(obj);
 
             /*
              * 4. Create a property in the object Result(1).  The property's
              * name is [fun->atom, the identifier parsed by the compiler],
              * value is Result(3), and attributes are { DontDelete, ReadOnly }.
              */
@@ -5878,57 +5869,29 @@ js_Interpret(JSContext *cx)
                                      ? JS_EXTENSION (JSPropertyOp) obj
                                      : JS_PropertyStub,
                                      attrs |
                                      JSPROP_ENUMERATE | JSPROP_PERMANENT |
                                      JSPROP_READONLY,
                                      NULL);
 
             /* Restore fp->scopeChain now that obj is defined in parent. */
+            MUST_FLOW_LABEL(restore2)
             fp->scopeChain = obj2;
             if (!ok) {
                 cx->weakRoots.newborn[GCX_OBJECT] = NULL;
                 goto error;
             }
 
             /*
              * 5. Remove Result(1) from the front of the scope chain [no-op].
              * 6. Return Result(3).
              */
             PUSH_OPND(OBJECT_TO_JSVAL(obj));
           END_CASE(JSOP_NAMEDFUNOBJ)
-
-          BEGIN_CASE(JSOP_CLOSURE)
-            /*
-             * A top-level function inside eval or ECMA ed. 3 extension: a
-             * named function expression statement in a compound statement
-             * (not at the top statement level of global code, or at the top
-             * level of a function body).
-             */
-            LOAD_FUNCTION(0);
-
-            /*
-             * Clone the function object with the current scope chain as the
-             * clone's parent. Do this only if re-parenting; the compiler may
-             * have seen the right parent already and created a sufficiently
-             * well-scoped function object.
-             */
-            obj2 = js_GetScopeChain(cx, fp);
-            if (!obj2)
-                goto error;
-
-            /*
-             * ECMA requires that functions defined when entering Eval code to
-             * be impermanent.
-             */
-            attrs = JSPROP_ENUMERATE;
-            if (!(fp->flags & JSFRAME_EVAL))
-                attrs |= JSPROP_PERMANENT;
-
-            goto do_deffun;
 
 #if JS_HAS_GETTER_SETTER
           BEGIN_CASE(JSOP_GETTER)
           BEGIN_CASE(JSOP_SETTER)
           do_getter_setter:
             op2 = (JSOp) *++regs.pc;
             switch (op2) {
               case JSOP_INDEXBASE:
@@ -6120,16 +6083,20 @@ js_Interpret(JSContext *cx)
                     /*
                      * Detect a repeated property name and force a miss to
                      * share the strict warning code and cope with complexity
                      * managed by js_AddScopeProperty.
                      */
                     if (sprop->parent != scope->lastProp)
                         goto do_initprop_miss;
 
+#ifdef JS_TRACER
+                    TRACE_2(SetPropHit, kshape, sprop);
+#endif
+
                     /*
                      * Otherwise this entry must be for a direct property of
                      * obj, not a proto-property, and there cannot have been
                      * any deletions of prior properties.
                      */
                     JS_ASSERT(PCVCAP_MAKE(sprop->shape, 0, 0) == entry->vcap);
                     JS_ASSERT(!SCOPE_HAD_MIDDLE_DELETE(scope));
                     JS_ASSERT(!scope->table ||
@@ -6185,16 +6152,20 @@ js_Interpret(JSContext *cx)
 
                 /* Set the property named by obj[id] to rval. */
                 if (!js_CheckRedeclaration(cx, obj, id, JSPROP_INITIALIZER,
                                            NULL, NULL)) {
                     goto error;
                 }
                 if (!js_SetPropertyHelper(cx, obj, id, &rval, &entry))
                     goto error;
+#ifdef JS_TRACER
+                if (entry)
+                    TRACE_1(SetPropMiss, entry);
+#endif
             } while (0);
 
             /* Common tail for property cache hit and miss cases. */
             regs.sp--;
           END_CASE(JSOP_INITPROP);
 
           BEGIN_CASE(JSOP_INITELEM)
             /* Pop the element's value into rval. */
@@ -6806,16 +6777,17 @@ js_Interpret(JSContext *cx)
           L_JSOP_TOATTRNAME:
           L_JSOP_QNAME:
           L_JSOP_QNAMECONST:
           L_JSOP_QNAMEPART:
           L_JSOP_ANYNAME:
           L_JSOP_DEFXMLNS:
 # endif
 
+          L_JSOP_UNUSED74:
           L_JSOP_UNUSED76:
           L_JSOP_UNUSED77:
           L_JSOP_UNUSED78:
           L_JSOP_UNUSED79:
           L_JSOP_UNUSED201:
           L_JSOP_UNUSED202:
           L_JSOP_UNUSED203:
           L_JSOP_UNUSED204:
@@ -7025,17 +6997,17 @@ js_Interpret(JSContext *cx)
      *
      * We must not be in an inline frame. The check above ensures that for the
      * error case and for a normal return, the code jumps directly to parent's
      * frame pc.
      */
     JS_ASSERT(inlineCallCount == 0);
     JS_ASSERT(fp->regs == &regs);
 #ifdef JS_TRACER
-    if (JS_TRACE_MONITOR(cx).recorder)
+    if (TRACE_RECORDER(cx))
         js_AbortRecording(cx, regs.pc, "recording out of js_Interpret");
 #endif
     if (JS_UNLIKELY(fp->flags & JSFRAME_YIELDING)) {
         JSGenerator *gen;
 
         gen = FRAME_TO_GENERATOR(fp);
         gen->savedRegs = regs;
         gen->frame.regs = &gen->savedRegs;
@@ -7050,22 +7022,22 @@ js_Interpret(JSContext *cx)
     /* Undo the remaining effects committed on entry to js_Interpret. */
     if (script->staticDepth < JS_DISPLAY_SIZE)
         cx->display[script->staticDepth] = fp->displaySave;
     JS_ASSERT(JS_PROPERTY_CACHE(cx).disabled == fp->pcDisabledSave);
     if (cx->version == currentVersion && currentVersion != originalVersion)
         js_SetVersion(cx, originalVersion);
     --cx->interpLevel;
 
-#ifdef JS_TRACER    
+#ifdef JS_TRACER
     if (tr) {
-        JS_TRACE_MONITOR(cx).recorder = tr;
+        SET_TRACE_RECORDER(cx, tr);
         tr->deepAbort();
     }
-#endif    
+#endif
     return ok;
 
   atom_not_defined:
     {
         const char *printable;
 
         printable = js_AtomToPrintableString(cx, atom);
         if (printable)
diff -r b7bcdd009540 js/src/jsinterp.h
--- a/js/src/jsinterp.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/jsinterp.h	Thu Sep 11 15:19:25 2008 +0300
@@ -123,22 +123,21 @@ typedef struct JSInlineFrame {
 
 /* JS stack frame flags. */
 #define JSFRAME_CONSTRUCTING   0x01 /* frame is for a constructor invocation */
 #define JSFRAME_COMPUTED_THIS  0x02 /* frame.thisp was computed already */
 #define JSFRAME_ASSIGNING      0x04 /* a complex (not simplex JOF_ASSIGNING) op
                                        is currently assigning to a property */
 #define JSFRAME_DEBUGGER       0x08 /* frame for JS_EvaluateInStackFrame */
 #define JSFRAME_EVAL           0x10 /* frame for obj_eval */
-#define JSFRAME_SCRIPT_OBJECT  0x20 /* compiling source for a Script object */
+#define JSFRAME_ROOTED_ARGV    0x20 /* frame.argv is rooted by the caller */
 #define JSFRAME_YIELDING       0x40 /* js_Interpret dispatched JSOP_YIELD */
 #define JSFRAME_ITERATOR       0x80 /* trying to get an iterator for for-in */
 #define JSFRAME_POP_BLOCKS    0x100 /* scope chain contains blocks to pop */
 #define JSFRAME_GENERATOR     0x200 /* frame belongs to generator-iterator */
-#define JSFRAME_ROOTED_ARGV   0x400 /* frame.argv is rooted by the caller */
 
 #define JSFRAME_OVERRIDE_SHIFT 24   /* override bit-set params; see jsfun.c */
 #define JSFRAME_OVERRIDE_BITS  8
 
 #define JSFRAME_SPECIAL       (JSFRAME_DEBUGGER | JSFRAME_EVAL)
 
 /*
  * Property cache with structurally typed capabilities for invalidation, for
@@ -158,17 +157,17 @@ typedef struct JSInlineFrame {
 #define PROPERTY_CACHE_HASH(pc,kshape)                                        \
     (((((jsuword)(pc) >> PROPERTY_CACHE_LOG2) ^ (jsuword)(pc)) + (kshape)) &  \
      PROPERTY_CACHE_MASK)
 
 #define PROPERTY_CACHE_HASH_PC(pc,kshape)                                     \
     PROPERTY_CACHE_HASH(pc, kshape)
 
 #define PROPERTY_CACHE_HASH_ATOM(atom,obj,pobj)                               \
-    PROPERTY_CACHE_HASH((jsuword)(atom) >> 2, OBJ_SCOPE(obj)->shape)
+    PROPERTY_CACHE_HASH((jsuword)(atom) >> 2, OBJ_SHAPE(obj))
 
 /*
  * Property cache value capability macros.
  */
 #define PCVCAP_PROTOBITS        4
 #define PCVCAP_PROTOSIZE        JS_BIT(PCVCAP_PROTOBITS)
 #define PCVCAP_PROTOMASK        JS_BITMASK(PCVCAP_PROTOBITS)
 
@@ -272,18 +271,18 @@ typedef struct JSPropertyCache {
 #define SLOT_TO_PCVAL(i)        (((jsuword)(i) << 1) | PCVAL_SLOT)
 
 #define PCVAL_IS_SPROP(v)       (PCVAL_TAG(v) == PCVAL_SPROP)
 #define PCVAL_TO_SPROP(v)       ((JSScopeProperty *) PCVAL_CLRTAG(v))
 #define SPROP_TO_PCVAL(sprop)   PCVAL_SETTAG(sprop, PCVAL_SPROP)
 
 /*
  * Fill property cache entry for key cx->fp->pc, optimized value word computed
- * from obj and sprop, and entry capability forged from OBJ_SCOPE(obj)->shape,
- * scopeIndex, and protoIndex.
+ * from obj and sprop, and entry capability forged from 24-bit OBJ_SHAPE(obj),
+ * 4-bit scopeIndex, and 4-bit protoIndex.
  */
 extern void
 js_FillPropertyCache(JSContext *cx, JSObject *obj, jsuword kshape,
                      uintN scopeIndex, uintN protoIndex,
                      JSObject *pobj, JSScopeProperty *sprop,
                      JSPropCacheEntry **entryp);
 
 /*
@@ -300,34 +299,33 @@ js_FillPropertyCache(JSContext *cx, JSOb
  *
  * We must lock pobj on a hit in order to close races with threads that might
  * be deleting a property from its scope, or otherwise invalidating property
  * caches (on all threads) by re-generating scope->shape.
  */
 #define PROPERTY_CACHE_TEST(cx, pc, obj, pobj, entry, atom)                   \
     do {                                                                      \
         JSPropertyCache *cache_ = &JS_PROPERTY_CACHE(cx);                     \
-        uint32 kshape_ = (JS_ASSERT(OBJ_IS_NATIVE(obj)),                      \
-                          OBJ_SCOPE(obj)->shape);                             \
+        uint32 kshape_ = (JS_ASSERT(OBJ_IS_NATIVE(obj)), OBJ_SHAPE(obj));     \
         entry = &cache_->table[PROPERTY_CACHE_HASH_PC(pc, kshape_)];          \
         PCMETER(cache_->tests++);                                             \
         JS_ASSERT(&obj != &pobj);                                             \
         if (entry->kpc == pc && entry->kshape == kshape_) {                   \
             JSObject *tmp_;                                                   \
             pobj = obj;                                                       \
             JS_LOCK_OBJ(cx, pobj);                                            \
             JS_ASSERT(PCVCAP_TAG(entry->vcap) <= 1);                          \
             if (PCVCAP_TAG(entry->vcap) == 1 &&                               \
                 (tmp_ = LOCKED_OBJ_GET_PROTO(pobj)) != NULL &&                \
                 OBJ_IS_NATIVE(tmp_)) {                                        \
                 JS_UNLOCK_OBJ(cx, pobj);                                      \
                 pobj = tmp_;                                                  \
                 JS_LOCK_OBJ(cx, pobj);                                        \
             }                                                                 \
-            if (PCVCAP_SHAPE(entry->vcap) == OBJ_SCOPE(pobj)->shape) {        \
+            if (PCVCAP_SHAPE(entry->vcap) == OBJ_SHAPE(pobj)) {               \
                 PCMETER(cache_->pchits++);                                    \
                 PCMETER(!PCVCAP_TAG(entry->vcap) || cache_->protopchits++);   \
                 pobj = OBJ_SCOPE(pobj)->object;                               \
                 atom = NULL;                                                  \
                 break;                                                        \
             }                                                                 \
             JS_UNLOCK_OBJ(cx, pobj);                                          \
         }                                                                     \
diff -r b7bcdd009540 js/src/jslock.cpp
--- a/js/src/jslock.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/jslock.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -201,17 +201,17 @@ NativeCompareAndSwap(jsword *w, jsword o
 
 #endif /* arch-tests */
 
 #if JS_HAS_NATIVE_COMPARE_AND_SWAP
 
 JSBool
 js_CompareAndSwap(jsword *w, jsword ov, jsword nv)
 {
-    return NativeCompareAndSwap(w, ov, nv);
+    return !!NativeCompareAndSwap(w, ov, nv);
 }
 
 #elif defined(NSPR_LOCK)
 
 # ifdef __GNUC__
 # warning "js_CompareAndSwap is implemented using NSSP lock"
 # endif
 
diff -r b7bcdd009540 js/src/jsmath.cpp
--- a/js/src/jsmath.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/jsmath.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -294,18 +294,18 @@ js_math_floor(JSContext *cx, uintN argc,
     }
     x = js_ValueToNumber(cx, &vp[2]);
     if (JSVAL_IS_NULL(vp[2]))
         return JS_FALSE;
     z = fd_floor(x);
     return js_NewNumberInRootedValue(cx, z, vp);
 }
 
-static JSBool
-math_log(JSContext *cx, uintN argc, jsval *vp)
+JSBool
+js_math_log(JSContext *cx, uintN argc, jsval *vp)
 {
     jsdouble x, z;
 
     if (argc == 0) {
         *vp = DOUBLE_TO_JSVAL(cx->runtime->jsNaN);
         return JS_TRUE;
     }
     x = js_ValueToNumber(cx, &vp[2]);
@@ -316,18 +316,18 @@ math_log(JSContext *cx, uintN argc, jsva
         *vp = DOUBLE_TO_JSVAL(cx->runtime->jsNaN);
         return JS_TRUE;
     }
 #endif
     z = fd_log(x);
     return js_NewNumberInRootedValue(cx, z, vp);
 }
 
-static JSBool
-math_max(JSContext *cx, uintN argc, jsval *vp)
+JSBool
+js_math_max(JSContext *cx, uintN argc, jsval *vp)
 {
     jsdouble x, z = *cx->runtime->jsNegativeInfinity;
     jsval *argv;
     uintN i;
 
     if (argc == 0) {
         *vp = DOUBLE_TO_JSVAL(cx->runtime->jsNegativeInfinity);
         return JS_TRUE;
@@ -592,18 +592,18 @@ static JSFunctionSpec math_static_method
     JS_FN("acos",           math_acos,          1, 0),
     JS_FN("asin",           math_asin,          1, 0),
     JS_FN("atan",           math_atan,          1, 0),
     JS_FN("atan2",          math_atan2,         2, 0),
     JS_FN("ceil",           js_math_ceil,       1, 0),
     JS_FN("cos",            js_math_cos,        1, 0),
     JS_FN("exp",            math_exp,           1, 0),
     JS_FN("floor",          js_math_floor,      1, 0),
-    JS_FN("log",            math_log,           1, 0),
-    JS_FN("max",            math_max,           2, 0),
+    JS_FN("log",            js_math_log,        1, 0),
+    JS_FN("max",            js_math_max,        2, 0),
     JS_FN("min",            math_min,           2, 0),
     JS_FN("pow",            js_math_pow,        2, 0),
     JS_FN("random",         js_math_random,     0, 0),
     JS_FN("round",          math_round,         1, 0),
     JS_FN("sin",            js_math_sin,        1, 0),
     JS_FN("sqrt",           js_math_sqrt,       1, 0),
     JS_FN("tan",            math_tan,           1, 0),
     JS_FS_END
diff -r b7bcdd009540 js/src/jsobj.cpp
--- a/js/src/jsobj.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/jsobj.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -64,18 +64,18 @@
 #include "jslock.h"
 #include "jsnum.h"
 #include "jsobj.h"
 #include "jsopcode.h"
 #include "jsparse.h"
 #include "jsscope.h"
 #include "jsscript.h"
 #include "jsstr.h"
-
 #include "jsdbgapi.h"   /* whether or not JS_HAS_OBJ_WATCHPOINT */
+#include "jsstaticcheck.h"
 
 #if JS_HAS_GENERATORS
 #include "jsiter.h"
 #endif
 
 #if JS_HAS_XML_SUPPORT
 #include "jsxml.h"
 #endif
@@ -630,17 +630,17 @@ obj_toSource(JSContext *cx, uintN argc, 
     jsval localroot[4] = {JSVAL_NULL, JSVAL_NULL, JSVAL_NULL, JSVAL_NULL};
     JSTempValueRooter tvr;
     JSString *gsopold[2];
     JSString *gsop[2];
     JSString *idstr, *valstr, *str;
 
     JS_CHECK_RECURSION(cx, return JS_FALSE);
 
-    /* After this, control must flow through out: to exit. */
+    MUST_FLOW_THROUGH("out");
     JS_PUSH_TEMP_ROOT(cx, 4, localroot, &tvr);
 
     /* If outermost, we need parentheses to be an expression, not a block. */
     outermost = (cx->sharpObjectMap.depth == 0);
     obj = JS_THIS_OBJECT(cx, vp);
     if (!obj || !(he = js_EnterSharpObject(cx, obj, &ida, &chars))) {
         ok = JS_FALSE;
         goto out;
@@ -1174,16 +1174,17 @@ js_obj_eval(JSContext *cx, JSObject *obj
 {
     JSStackFrame *fp, *caller;
     JSBool indirectCall;
     JSObject *scopeobj;
     JSString *str;
     const char *file;
     uintN line;
     JSPrincipals *principals;
+    uint32 tcflags;
     JSScript *script;
     JSBool ok;
 #if JS_HAS_EVAL_THIS_SCOPE
     JSObject *callerScopeChain = NULL, *callerVarObj = NULL;
     JSObject *setCallerScopeChain = NULL;
     JSBool setCallerVarObj = JS_FALSE;
 #endif
 
@@ -1229,16 +1230,17 @@ js_obj_eval(JSContext *cx, JSObject *obj
     if (argc >= 2 &&
         !JS_ReportErrorFlagsAndNumber(cx, JSREPORT_WARNING | JSREPORT_STRICT,
                                       js_GetErrorMessage, NULL,
                                       JSMSG_EVAL_ARITY)) {
         return JS_FALSE;
     }
 
     /* From here on, control must exit through label out with ok set. */
+    MUST_FLOW_THROUGH("out");
     if (!scopeobj) {
 #if JS_HAS_EVAL_THIS_SCOPE
         /* If obj.eval(str), emulate 'with (obj) eval(str)' in the caller. */
         if (indirectCall) {
             callerScopeChain = js_GetScopeChain(cx, caller);
             if (!callerScopeChain) {
                 ok = JS_FALSE;
                 goto out;
@@ -1304,31 +1306,20 @@ js_obj_eval(JSContext *cx, JSObject *obj
         principals = JS_EvalFramePrincipals(cx, fp, caller);
         file = js_ComputeFilename(cx, caller, principals, &line);
     } else {
         file = NULL;
         line = 0;
         principals = NULL;
     }
 
-    /*
-     * Set JSFRAME_EVAL on fp and any frames (e.g., fun_call if eval.call was
-     * invoked) between fp and its scripted caller, to help the compiler easily
-     * find the same caller whose scope and var obj we've set.
-     *
-     * XXX this nonsense could, and perhaps should, go away with a better way
-     * to pass params to the compiler than via the top-most frame.
-     */
-    do {
-        fp->flags |= JSFRAME_EVAL;
-    } while ((fp = fp->down) != caller);
-
-    script = js_CompileScript(cx, scopeobj, principals,
-                              TCF_COMPILE_N_GO |
-                              TCF_PUT_STATIC_DEPTH(caller->script->staticDepth + 1),
+    tcflags = TCF_COMPILE_N_GO;
+    if (caller)
+        tcflags |= TCF_PUT_STATIC_DEPTH(caller->script->staticDepth + 1);
+    script = js_CompileScript(cx, scopeobj, caller, principals, tcflags,
                               JSSTRING_CHARS(str), JSSTRING_LENGTH(str),
                               NULL, file, line);
     if (!script) {
         ok = JS_FALSE;
         goto out;
     }
 
     if (argc < 2) {
@@ -2563,27 +2554,28 @@ js_NewObjectWithGivenProto(JSContext *cx
      */
     obj = (JSObject *) js_NewGCThing(cx, GCX_OBJECT, objectSize);
     if (!obj)
         goto earlybad;
 
     obj->map = NULL;
     obj->dslots = NULL;
 
+    /*
+     * Set the class slot with the initial value of the system and delegate
+     * flags set to false.
+     */
+    JS_ASSERT(((jsuword) clasp & 3) == 0);
+    obj->classword = jsuword(clasp);
+    JS_ASSERT(!STOBJ_IS_DELEGATE(obj));
+    JS_ASSERT(!STOBJ_IS_SYSTEM(obj));
+
     /* Set the proto and parent properties. */
     STOBJ_SET_PROTO(obj, proto);
     STOBJ_SET_PARENT(obj, parent);
-
-    /*
-     * Set the class slot with the initial value of the system flag set to
-     * false.
-     */
-    JS_ASSERT(((jsuword) clasp & 3) == 0);
-    STOBJ_SET_SLOT(obj, JSSLOT_CLASS, PRIVATE_TO_JSVAL(clasp));
-    JS_ASSERT(!STOBJ_IS_SYSTEM(obj));
 
     /* Initialize the remaining fixed slots. */
     for (i = JSSLOT_PRIVATE; i != JS_INITIAL_NSLOTS; ++i)
         obj->fslots[i] = JSVAL_VOID;
 
 #ifdef DEBUG
     memset((uint8 *) obj + sizeof(JSObject), JS_FREE_PATTERN,
            objectSize - sizeof(JSObject));
@@ -2844,16 +2836,17 @@ js_ConstructObject(JSContext *cx, JSClas
         return NULL;
     }
 
     /*
      * Protect cval in case a crazy getter for .prototype uproots it.  After
      * this point, all control flow must exit through label out with obj set.
      */
     JS_PUSH_SINGLE_TEMP_ROOT(cx, cval, &tvr);
+    MUST_FLOW_THROUGH("out");
 
     /*
      * If proto or parent are NULL, set them to Constructor.prototype and/or
      * Constructor.__parent__, just like JSOP_NEW does.
      */
     ctor = JSVAL_TO_OBJECT(cval);
     if (!parent)
         parent = OBJ_GET_PARENT(cx, ctor);
@@ -3029,16 +3022,19 @@ PurgeProtoChain(JSContext *cx, JSObject 
         JS_UNLOCK_SCOPE(cx, scope);
     }
     return JS_FALSE;
 }
 
 static void
 PurgeScopeChain(JSContext *cx, JSObject *obj, jsid id)
 {
+    if (!OBJ_IS_DELEGATE(cx, obj))
+        return;
+
     PurgeProtoChain(cx, OBJ_GET_PROTO(cx, obj), id);
     while ((obj = OBJ_GET_PARENT(cx, obj)) != NULL) {
         if (PurgeProtoChain(cx, obj, id))
             return;
     }
 }
 
 JSScopeProperty *
@@ -3494,38 +3490,38 @@ out:
 }
 
 int
 js_FindPropertyHelper(JSContext *cx, jsid id, JSObject **objp,
                       JSObject **pobjp, JSProperty **propp,
                       JSPropCacheEntry **entryp)
 {
     JSObject *obj, *pobj, *lastobj;
-    uint32 type;
+    uint32 shape;
     int scopeIndex, protoIndex;
     JSProperty *prop;
     JSScopeProperty *sprop;
 
     obj = cx->fp->scopeChain;
-    type = OBJ_SCOPE(obj)->shape;
+    shape = OBJ_SHAPE(obj);
     for (scopeIndex = 0; ; scopeIndex++) {
         if (obj->map->ops->lookupProperty == js_LookupProperty) {
             protoIndex =
                 js_LookupPropertyWithFlags(cx, obj, id, 0, &pobj, &prop);
         } else {
             if (!OBJ_LOOKUP_PROPERTY(cx, obj, id, &pobj, &prop))
                 return -1;
             protoIndex = -1;
         }
 
         if (prop) {
             if (entryp) {
                 if (protoIndex >= 0 && OBJ_IS_NATIVE(pobj)) {
                     sprop = (JSScopeProperty *) prop;
-                    js_FillPropertyCache(cx, cx->fp->scopeChain, type,
+                    js_FillPropertyCache(cx, cx->fp->scopeChain, shape,
                                          scopeIndex, protoIndex, pobj, sprop,
                                          entryp);
                 } else {
                     PCMETER(JS_PROPERTY_CACHE(cx).nofills++);
                     *entryp = NULL;
                 }
             }
             SCOPE_DEPTH_ACCUM(&rt->scopeSearchDepthStats, scopeIndex);
@@ -3641,17 +3637,17 @@ JSBool
 JSBool
 js_NativeSet(JSContext *cx, JSObject *obj, JSScopeProperty *sprop, jsval *vp)
 {
     JSScope *scope;
     uint32 slot;
     jsval pval;
     int32 sample;
     JSTempValueRooter tvr;
-    JSBool ok;
+    bool ok;
 
     JS_ASSERT(OBJ_IS_NATIVE(obj));
     JS_ASSERT(JS_IS_OBJ_LOCKED(cx, obj));
     scope = OBJ_SCOPE(obj);
     JS_ASSERT(scope->object == obj);
 
     slot = sprop->slot;
     if (slot != SPROP_INVALID_SLOT) {
@@ -3690,27 +3686,27 @@ js_NativeSet(JSContext *cx, JSObject *ob
 
     return JS_TRUE;
 }
 
 JSBool
 js_GetPropertyHelper(JSContext *cx, JSObject *obj, jsid id, jsval *vp,
                      JSPropCacheEntry **entryp)
 {
-    uint32 type;
+    uint32 shape;
     int protoIndex;
     JSObject *obj2;
     JSProperty *prop;
     JSScopeProperty *sprop;
 
     /* Convert string indices to integers if appropriate. */
     CHECK_FOR_STRING_INDEX(id);
     JS_COUNT_OPERATION(cx, JSOW_GET_PROPERTY);
 
-    type = OBJ_SCOPE(obj)->shape;
+    shape = OBJ_SHAPE(obj);
     protoIndex = js_LookupPropertyWithFlags(cx, obj, id, 0, &obj2, &prop);
     if (protoIndex < 0)
         return JS_FALSE;
     if (!prop) {
         jsbytecode *pc;
 
         *vp = JSVAL_VOID;
 
@@ -3770,50 +3766,48 @@ js_GetPropertyHelper(JSContext *cx, JSOb
         OBJ_DROP_PROPERTY(cx, obj2, prop);
         return OBJ_GET_PROPERTY(cx, obj2, id, vp);
     }
 
     sprop = (JSScopeProperty *) prop;
     if (!js_NativeGet(cx, obj, obj2, sprop, vp))
         return JS_FALSE;
 
-    if (entryp) {
-        js_FillPropertyCache(cx, obj, type, 0, protoIndex, obj2, sprop,
-                             entryp);
-    }
+    if (entryp)
+        js_FillPropertyCache(cx, obj, shape, 0, protoIndex, obj2, sprop, entryp);
     JS_UNLOCK_OBJ(cx, obj2);
     return JS_TRUE;
 }
 
 JSBool
 js_GetProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
 {
     return js_GetPropertyHelper(cx, obj, id, vp, NULL);
 }
 
 JSBool
 js_SetPropertyHelper(JSContext *cx, JSObject *obj, jsid id, jsval *vp,
                      JSPropCacheEntry **entryp)
 {
-    uint32 type;
+    uint32 shape;
     int protoIndex;
     JSObject *pobj;
     JSProperty *prop;
     JSScopeProperty *sprop;
     JSScope *scope;
     uintN attrs, flags;
     intN shortid;
     JSClass *clasp;
     JSPropertyOp getter, setter;
 
     /* Convert string indices to integers if appropriate. */
     CHECK_FOR_STRING_INDEX(id);
     JS_COUNT_OPERATION(cx, JSOW_SET_PROPERTY);
 
-    type = OBJ_SCOPE(obj)->shape;
+    shape = OBJ_SHAPE(obj);
     protoIndex = js_LookupPropertyWithFlags(cx, obj, id, 0, &pobj, &prop);
     if (protoIndex < 0)
         return JS_FALSE;
 
     if (prop && !OBJ_IS_NATIVE(pobj)) {
         OBJ_DROP_PROPERTY(cx, pobj, prop);
         prop = NULL;
     }
@@ -3871,26 +3865,17 @@ js_SetPropertyHelper(JSContext *cx, JSOb
 
         if (pobj != obj) {
             /*
              * We found id in a prototype object: prepare to share or shadow.
              *
              * NB: Thanks to the immutable, garbage-collected property tree
              * maintained by jsscope.c in cx->runtime, we needn't worry about
              * sprop going away behind our back after we've unlocked scope.
-             *
-             * But if we are shadowing (not sharing) the proto-property, then
-             * we need to regenerate the property cache shape id for scope, in
-             * case the cache contains the old type in an entry value that was
-             * filled by a get on obj that delegated up the prototype chain to
-             * pobj. Once we've shadowed the proto-property, that cache entry
-             * must not be hit.
-             */
-            if (!(attrs & JSPROP_SHARED))
-                SCOPE_MAKE_UNIQUE_SHAPE(cx, scope);
+             */
             JS_UNLOCK_SCOPE(cx, scope);
 
             /*
              * Don't clone a shared prototype property. Don't fill it in the
              * property cache either, since the JSOP_SETPROP/JSOP_SETNAME code
              * in js_Interpret does not handle shared or prototype properties.
              * Shared prototype properties require more hit qualification than
              * the fast-path code for those ops, which is targeted on direct,
@@ -3902,17 +3887,17 @@ js_SetPropertyHelper(JSContext *cx, JSOb
                     *entryp = NULL;
                 }
 
                 if (SPROP_HAS_STUB_SETTER(sprop) &&
                     !(sprop->attrs & JSPROP_GETTER)) {
                     return JS_TRUE;
                 }
 
-                return SPROP_SET(cx, sprop, obj, pobj, vp);
+                return !!SPROP_SET(cx, sprop, obj, pobj, vp);
             }
 
             /* Restore attrs to the ECMA default for new properties. */
             attrs = JSPROP_ENUMERATE;
 
             /*
              * Preserve the shortid, getter, and setter when shadowing any
              * property that has a shortid.  An old API convention requires
@@ -3982,17 +3967,17 @@ js_SetPropertyHelper(JSContext *cx, JSOb
                             return JS_FALSE);
     }
 
     if (!js_NativeSet(cx, obj, sprop, vp))
         return JS_FALSE;
 
     if (entryp) {
         if (!(attrs & JSPROP_SHARED))
-            js_FillPropertyCache(cx, obj, type, 0, 0, obj, sprop, entryp);
+            js_FillPropertyCache(cx, obj, shape, 0, 0, obj, sprop, entryp);
         else
             PCMETER(JS_PROPERTY_CACHE(cx).nofills++);
     }
     JS_UNLOCK_SCOPE(cx, scope);
     return JS_TRUE;
 
   read_only_error:
     return js_ReportValueErrorFlags(cx, flags, JSMSG_READ_ONLY,
diff -r b7bcdd009540 js/src/jsobj.h
--- a/js/src/jsobj.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/jsobj.h	Thu Sep 11 15:19:25 2008 +0300
@@ -115,35 +115,35 @@ struct JSObjectMap {
         JSClass *clasp_ = OBJ_GET_CLASS(cx, obj);                             \
         if (clasp_->flags & JSCLASS_IS_EXTENDED) {                            \
             JSExtendedClass *xclasp_ = (JSExtendedClass*)clasp_;              \
             if (xclasp_->outerObject)                                         \
                 obj = xclasp_->outerObject(cx, obj);                          \
         }                                                                     \
     JS_END_MACRO
 
-#define JS_INITIAL_NSLOTS   6
+#define JS_INITIAL_NSLOTS   5
 
 /*
  * When JSObject.dslots is not null, JSObject.dslots[-1] records the number of
  * available slots.
  */
 struct JSObject {
     JSObjectMap *map;
+    jsuword     classword;
     jsval       fslots[JS_INITIAL_NSLOTS];
     jsval       *dslots;        /* dynamically allocated slots */
 };
 
 #define JSSLOT_PROTO        0
 #define JSSLOT_PARENT       1
-#define JSSLOT_CLASS        2
-#define JSSLOT_PRIVATE      3
+#define JSSLOT_PRIVATE      2
 #define JSSLOT_START(clasp) (((clasp)->flags & JSCLASS_HAS_PRIVATE)           \
                              ? JSSLOT_PRIVATE + 1                             \
-                             : JSSLOT_CLASS + 1)
+                             : JSSLOT_PARENT + 1)
 
 #define JSSLOT_FREE(clasp)  (JSSLOT_START(clasp)                              \
                              + JSCLASS_RESERVED_SLOTS(clasp))
 
 /*
  * STOBJ prefix means Single Threaded Object. Use the following fast macros to
  * directly manipulate slots in obj when only one thread can access obj and
  * when obj->map->freeslot can be inconsistent with slots.
@@ -162,36 +162,41 @@ struct JSObject {
     ((slot) < JS_INITIAL_NSLOTS                                               \
      ? (obj)->fslots[(slot)] = (value)                                        \
      : (JS_ASSERT((slot) < (uint32)(obj)->dslots[-1]),                        \
         (obj)->dslots[(slot) - JS_INITIAL_NSLOTS] = (value)))
 
 #define STOBJ_GET_PROTO(obj)                                                  \
     JSVAL_TO_OBJECT((obj)->fslots[JSSLOT_PROTO])
 #define STOBJ_SET_PROTO(obj,proto)                                            \
-    ((obj)->fslots[JSSLOT_PROTO] = OBJECT_TO_JSVAL(proto))
+    (void)(STOBJ_NULLSAFE_SET_DELEGATE(proto),                                \
+           (obj)->fslots[JSSLOT_PROTO] = OBJECT_TO_JSVAL(proto))
 #define STOBJ_CLEAR_PROTO(obj)                                                \
     ((obj)->fslots[JSSLOT_PROTO] = JSVAL_NULL)
 
 #define STOBJ_GET_PARENT(obj)                                                 \
     JSVAL_TO_OBJECT((obj)->fslots[JSSLOT_PARENT])
 #define STOBJ_SET_PARENT(obj,parent)                                          \
-    ((obj)->fslots[JSSLOT_PARENT] = OBJECT_TO_JSVAL(parent))
+    (void)(STOBJ_NULLSAFE_SET_DELEGATE(parent),                               \
+           (obj)->fslots[JSSLOT_PARENT] = OBJECT_TO_JSVAL(parent))
 #define STOBJ_CLEAR_PARENT(obj)                                               \
     ((obj)->fslots[JSSLOT_PARENT] = JSVAL_NULL)
 
 /*
- * We use JSSLOT_CLASS to store both JSClass* and the system flag as an int-
- * tagged value (see jsapi.h for details) with the system flag stored in the
- * second lowest bit.
+ * We use JSObject.classword to store both JSClass* and the delegate and system
+ * flags in the two least significant bits. We do *not* synchronize updates of
+ * obj->classword -- API clients must take care.
  */
-#define STOBJ_GET_CLASS(obj)    ((JSClass *)((obj)->fslots[JSSLOT_CLASS] & ~3))
-#define STOBJ_IS_SYSTEM(obj)    (((obj)->fslots[JSSLOT_CLASS] & 2) != 0)
-
-#define STOBJ_SET_SYSTEM(obj)   ((void)((obj)->fslots[JSSLOT_CLASS] |= 2))
+#define STOBJ_GET_CLASS(obj)    ((JSClass *)((obj)->classword & ~3))
+#define STOBJ_IS_DELEGATE(obj)  (((obj)->classword & 1) != 0)
+#define STOBJ_SET_DELEGATE(obj) ((obj)->classword |= 1)
+#define STOBJ_NULLSAFE_SET_DELEGATE(obj)                                      \
+    (!(obj) || STOBJ_SET_DELEGATE((JSObject*)obj))
+#define STOBJ_IS_SYSTEM(obj)    (((obj)->classword & 2) != 0)
+#define STOBJ_SET_SYSTEM(obj)   ((obj)->classword |= 2)
 
 #define STOBJ_GET_PRIVATE(obj)                                                \
     (JS_ASSERT(JSVAL_IS_INT(STOBJ_GET_SLOT(obj, JSSLOT_PRIVATE))),            \
      JSVAL_TO_PRIVATE(STOBJ_GET_SLOT(obj, JSSLOT_PRIVATE)))
 
 #define OBJ_CHECK_SLOT(obj,slot)                                              \
     JS_ASSERT(slot < (obj)->map->freeslot)
 
@@ -222,17 +227,17 @@ struct JSObject {
     (OBJ_CHECK_SLOT(obj, JSSLOT_PROTO), STOBJ_SET_PROTO(obj, proto))
 
 #define LOCKED_OBJ_GET_PARENT(obj) \
     (OBJ_CHECK_SLOT(obj, JSSLOT_PARENT), STOBJ_GET_PARENT(obj))
 #define LOCKED_OBJ_SET_PARENT(obj,parent) \
     (OBJ_CHECK_SLOT(obj, JSSLOT_PARENT), STOBJ_SET_PARENT(obj, parent))
 
 #define LOCKED_OBJ_GET_CLASS(obj) \
-    (OBJ_CHECK_SLOT(obj, JSSLOT_CLASS), STOBJ_GET_CLASS(obj))
+    STOBJ_GET_CLASS(obj)
 
 #define LOCKED_OBJ_GET_PRIVATE(obj) \
     (OBJ_CHECK_SLOT(obj, JSSLOT_PRIVATE), STOBJ_GET_PRIVATE(obj))
 
 #ifdef JS_THREADSAFE
 
 /* Thread-safe functions and wrapper macros for accessing slots in obj. */
 #define OBJ_GET_SLOT(cx,obj,slot)                                             \
@@ -271,27 +276,30 @@ struct JSObject {
 #else   /* !JS_THREADSAFE */
 
 #define OBJ_GET_SLOT(cx,obj,slot)       LOCKED_OBJ_GET_SLOT(obj,slot)
 #define OBJ_SET_SLOT(cx,obj,slot,value) LOCKED_OBJ_WRITE_BARRIER(cx,obj,slot, \
                                                                  value)
 
 #endif /* !JS_THREADSAFE */
 
-/* Thread-safe proto, parent, and class access macros. */
+/* Thread-safe delegate, proto, parent, and class access macros. */
+#define OBJ_IS_DELEGATE(cx,obj)         STOBJ_IS_DELEGATE(obj)
+#define OBJ_SET_DELEGATE(cx,obj)        STOBJ_SET_DELEGATE(obj)
+
 #define OBJ_GET_PROTO(cx,obj)           STOBJ_GET_PROTO(obj)
 #define OBJ_SET_PROTO(cx,obj,proto)     STOBJ_SET_PROTO(obj, proto)
 #define OBJ_CLEAR_PROTO(cx,obj)         STOBJ_CLEAR_PROTO(obj)
 
 #define OBJ_GET_PARENT(cx,obj)          STOBJ_GET_PARENT(obj)
 #define OBJ_SET_PARENT(cx,obj,parent)   STOBJ_SET_PARENT(obj, parent)
 #define OBJ_CLEAR_PARENT(cx,obj)        STOBJ_CLEAR_PARENT(obj)
 
 /*
- * Class is invariant and comes from the fixed JSSLOT_CLASS. Thus no locking
+ * Class is invariant and comes from the fixed clasp member. Thus no locking
  * is necessary to read it. Same for the private slot.
  */
 #define OBJ_GET_CLASS(cx,obj)           STOBJ_GET_CLASS(obj)
 #define OBJ_GET_PRIVATE(cx,obj)         STOBJ_GET_PRIVATE(obj)
 
 /* Test whether a map or object is native. */
 #define MAP_IS_NATIVE(map)                                                    \
     JS_LIKELY((map)->ops == &js_ObjectOps ||                                  \
diff -r b7bcdd009540 js/src/jsopcode.cpp
--- a/js/src/jsopcode.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/jsopcode.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -65,16 +65,17 @@
 #include "jsiter.h"
 #include "jsobj.h"
 #include "jsopcode.h"
 #include "jsregexp.h"
 #include "jsscan.h"
 #include "jsscope.h"
 #include "jsscript.h"
 #include "jsstr.h"
+#include "jsstaticcheck.h"
 
 #if JS_HAS_DESTRUCTURING
 # include "jsnum.h"
 #endif
 
 #include "jsautooplen.h"
 
 /* Verify JSOP_XXX_LENGTH constant definitions. */
@@ -2539,17 +2540,17 @@ Decompile(SprintStack *ss, jsbytecode *p
                 if ((size_t)argc <= JS_ARRAY_LENGTH(smallv)) {
                     atomv = smallv;
                 } else {
                     atomv = (JSAtom **) JS_malloc(cx, argc * sizeof(JSAtom *));
                     if (!atomv)
                         return NULL;
                 }
 
-                /* From here on, control must flow through enterblock_out. */
+                MUST_FLOW_THROUGH("enterblock_out");
 #define LOCAL_ASSERT_OUT(expr) LOCAL_ASSERT_CUSTOM(expr, ok = JS_FALSE; \
                                                    goto enterblock_out)
                 for (sprop = OBJ_SCOPE(obj)->lastProp; sprop;
                      sprop = sprop->parent) {
                     if (!(sprop->flags & SPROP_HAS_SHORTID))
                         continue;
                     LOCAL_ASSERT_OUT(sprop->shortid < argc);
                     atomv[sprop->shortid] = JSID_TO_ATOM(sprop->id);
@@ -4234,17 +4235,17 @@ Decompile(SprintStack *ss, jsbytecode *p
               case JSOP_STRICTEQ:
               case JSOP_STRICTNE:
                 rval = POP_STR();
                 lval = POP_STR();
                 todo = Sprint(&ss->sprinter, "%s %c== %s",
                               lval, (op == JSOP_STRICTEQ) ? '=' : '!', rval);
                 break;
 
-              case JSOP_CLOSURE:
+              case JSOP_DEFFUN:
                 LOAD_FUNCTION(0);
                 todo = -2;
                 goto do_function;
                 break;
 
               case JSOP_TRAP:
                 saveop = op = JS_GetTrapOpcode(cx, jp->script, pc);
                 *pc = op;
@@ -5041,17 +5042,17 @@ DecompileExpression(JSContext *cx, JSScr
     char *name;
 
     JS_ASSERT(script->main <= pc && pc < script->code + script->length);
 
     pcstack = NULL;
     oldcode = script->code;
     oldmain = script->main;
 
-    /* From this point the control must flow through the label out. */
+    MUST_FLOW_THROUGH("out");
     code = js_UntrapScriptCode(cx, script);
     if (code != oldcode) {
         script->code = code;
         script->main = code + (oldmain - oldcode);
         pc = code + (pc - oldcode);
     }
 
     op = (JSOp) *pc;
@@ -5117,17 +5118,17 @@ DecompileExpression(JSContext *cx, JSScr
 
     pcstack = (jsbytecode **)
               JS_malloc(cx, StackDepth(script) * sizeof *pcstack);
     if (!pcstack) {
         name = NULL;
         goto out;
     }
 
-    /* From this point the control must flow through the label out. */
+    MUST_FLOW_THROUGH("out");
     pcdepth = ReconstructPCStack(cx, script, begin, pcstack);
     if (pcdepth < 0) {
          name = FAILED_EXPRESSION_DECOMPILER;
          goto out;
     }
 
     name = NULL;
     jp = JS_NEW_PRINTER(cx, "js_DecompileValueGenerator", fun, 0, JS_FALSE);
diff -r b7bcdd009540 js/src/jsopcode.tbl
--- a/js/src/jsopcode.tbl	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/jsopcode.tbl	Thu Sep 11 15:19:25 2008 +0300
@@ -180,17 +180,17 @@ OPDEF(JSOP_TABLESWITCH,  70, "tableswitc
 OPDEF(JSOP_TABLESWITCH,  70, "tableswitch",  NULL,   -1,  1,  0,  0,  JOF_TABLESWITCH|JOF_DETECTING|JOF_PARENHEAD)
 OPDEF(JSOP_LOOKUPSWITCH, 71, "lookupswitch", NULL,   -1,  1,  0,  0,  JOF_LOOKUPSWITCH|JOF_DETECTING|JOF_PARENHEAD)
 
 /* New, infallible/transitive identity ops. */
 OPDEF(JSOP_STRICTEQ,  72, "stricteq",   NULL,         1,  2,  1,  10,  JOF_BYTE|JOF_DETECTING)
 OPDEF(JSOP_STRICTNE,  73, "strictne",   NULL,         1,  2,  1,  10,  JOF_BYTE|JOF_DETECTING)
 
 /* Lexical closure constructor. */
-OPDEF(JSOP_CLOSURE,   74, "closure",    NULL,         3,  0,  0,  0,  JOF_OBJECT)
+OPDEF(JSOP_UNUSED74,  74, "unused74",   NULL,         1,  0,  0,  0,  JOF_BYTE)
 
 /* Variant of JSOP_NULL for default (global) |this| parameter pushing. */
 OPDEF(JSOP_NULLTHIS,  75, js_null_str,  js_null_str,  1,  0,  1, 19,  JOF_BYTE)
 
 OPDEF(JSOP_UNUSED76,  76, "unused76",   NULL,         1,  0,  0,  0,  JOF_BYTE)
 OPDEF(JSOP_UNUSED77,  77, "unused77",   NULL,         1,  0,  0,  0,  JOF_BYTE)
 OPDEF(JSOP_UNUSED78,  78, "unused78",   NULL,         1,  0,  0,  0,  JOF_BYTE)
 OPDEF(JSOP_UNUSED79,  79, "unused79",   NULL,         1,  0,  0,  0,  JOF_BYTE)
diff -r b7bcdd009540 js/src/jsparse.cpp
--- a/js/src/jsparse.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/jsparse.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -71,16 +71,17 @@
 #include "jsnum.h"
 #include "jsobj.h"
 #include "jsopcode.h"
 #include "jsparse.h"
 #include "jsscan.h"
 #include "jsscope.h"
 #include "jsscript.h"
 #include "jsstr.h"
+#include "jsstaticcheck.h"
 
 #if JS_HAS_XML_SUPPORT
 #include "jsxml.h"
 #endif
 
 #if JS_HAS_DESTRUCTURING
 #include "jsdhash.h"
 #endif
@@ -153,27 +154,31 @@ static JSParenParser   ParenExpr;
 #ifdef METER_PARSENODES
 static uint32 parsenodes = 0;
 static uint32 maxparsenodes = 0;
 static uint32 recyclednodes = 0;
 #endif
 
 JSBool
 js_InitParseContext(JSContext *cx, JSParseContext *pc, JSPrincipals *principals,
+                    JSStackFrame *callerFrame,
                     const jschar *base, size_t length,
                     FILE *fp, const char *filename, uintN lineno)
 {
+    JS_ASSERT_IF(callerFrame, callerFrame->script);
+
     pc->tempPoolMark = JS_ARENA_MARK(&cx->tempPool);
     if (!js_InitTokenStream(cx, TS(pc), base, length, fp, filename, lineno)) {
         JS_ARENA_RELEASE(&cx->tempPool, pc->tempPoolMark);
         return JS_FALSE;
     }
     if (principals)
         JSPRINCIPALS_HOLD(cx, principals);
     pc->principals = principals;
+    pc->callerFrame = callerFrame;
     pc->nodeList = NULL;
     pc->traceListHead = NULL;
 
     /* Root atoms and objects allocated for the parsed tree. */
     JS_KEEP_ATOMS(cx->runtime);
     JS_PUSH_TEMP_ROOT_PARSE_CONTEXT(cx, pc, &pc->tempRoot);
     return JS_TRUE;
 }
@@ -450,158 +455,100 @@ CheckGetterOrSetter(JSContext *cx, JSTok
                                          name)) {
             return TOK_ERROR;
         }
     }
     return tt;
 }
 #endif
 
-static void
-MaybeSetupFrame(JSContext *cx, JSObject *chain, JSStackFrame *oldfp,
-                JSStackFrame *newfp)
-{
-    /*
-     * Always push a new frame if the current frame is special, so that
-     * Variables gets the correct variables object: the one from the special
-     * frame's caller.
-     */
-    if (oldfp &&
-        oldfp->varobj &&
-        oldfp->scopeChain == chain &&
-        !(oldfp->flags & JSFRAME_SPECIAL)) {
-        return;
-    }
-
-    memset(newfp, 0, sizeof *newfp);
-
-    /* Default to sharing the same variables object and scope chain. */
-    newfp->varobj = newfp->scopeChain = chain;
-    if (cx->options & JSOPTION_VAROBJFIX) {
-        while ((chain = JS_GetParent(cx, chain)) != NULL)
-            newfp->varobj = chain;
-    }
-    newfp->down = oldfp;
-    if (oldfp) {
-        /*
-         * In the case of eval and debugger frames, we need to dig down and find
-         * the real variables objects and function that our new stack frame is
-         * going to use.
-         */
-        newfp->flags = oldfp->flags & (JSFRAME_SPECIAL | JSFRAME_SCRIPT_OBJECT);
-        while (oldfp->flags & JSFRAME_SPECIAL) {
-            oldfp = oldfp->down;
-            if (!oldfp)
-                break;
-        }
-        if (oldfp && (newfp->flags & JSFRAME_SPECIAL)) {
-            newfp->varobj = oldfp->varobj;
-            newfp->callee = oldfp->callee;
-            newfp->fun = oldfp->fun;
-        }
-    }
-    cx->fp = newfp;
-}
-
 /*
  * Parse a top-level JS script.
  */
 JSParseNode *
 js_ParseScript(JSContext *cx, JSObject *chain, JSParseContext *pc)
 {
-    JSStackFrame *fp, frame;
     JSTreeContext tc;
     JSParseNode *pn;
-
-    /*
-     * Push a compiler frame if we have no frames, or if the top frame is a
-     * lightweight function activation, or if its scope chain doesn't match
-     * the one passed to us.
-     */
-    fp = cx->fp;
-    MaybeSetupFrame(cx, chain, fp, &frame);
 
     /*
      * Protect atoms from being collected by a GC activation, which might
      * - nest on this thread due to out of memory (the so-called "last ditch"
      *   GC attempted within js_NewGCThing), or
      * - run for any reason on another thread if this thread is suspended on
      *   an object lock before it finishes generating bytecode into a script
      *   protected from the GC by a root or a stack frame reference.
      */
     TREE_CONTEXT_INIT(&tc, pc);
+    tc.u.scopeChain = chain;
     pn = Statements(cx, TS(pc), &tc);
     if (pn) {
         if (!js_MatchToken(cx, TS(pc), TOK_EOF)) {
             js_ReportCompileErrorNumber(cx, TS(pc), NULL, JSREPORT_ERROR,
                                         JSMSG_SYNTAX_ERROR);
             pn = NULL;
         } else {
             pn->pn_type = TOK_LC;
             if (!js_FoldConstants(cx, pn, &tc))
                 pn = NULL;
         }
     }
 
     TREE_CONTEXT_FINISH(cx, &tc);
-    cx->fp = fp;
     return pn;
 }
 
 /*
  * Compile a top-level script.
  */
-JSScript *
-js_CompileScript(JSContext *cx, JSObject *obj, JSPrincipals *principals,
-                 uint32 tcflags, const jschar *chars, size_t length,
+extern JSScript *
+js_CompileScript(JSContext *cx, JSObject *scopeChain, JSStackFrame *callerFrame,
+                 JSPrincipals *principals, uint32 tcflags,
+                 const jschar *chars, size_t length,
                  FILE *file, const char *filename, uintN lineno)
 {
     JSParseContext pc;
-    JSStackFrame *fp, frame;
     JSArenaPool codePool, notePool;
     JSCodeGenerator cg;
     JSTokenType tt;
     JSParseNode *pn;
     uint32 scriptGlobals;
     JSScript *script;
 #ifdef METER_PARSENODES
     void *sbrk(ptrdiff_t), *before = sbrk(0);
 #endif
 
-    JS_ASSERT(!(tcflags & ~(TCF_COMPILE_N_GO | TCF_NO_SCRIPT_RVAL | TCF_STATIC_DEPTH_MASK)));
-
-    if (!js_InitParseContext(cx, &pc, principals, chars, length, file,
-                             filename, lineno)) {
-        return NULL;
-    }
-
-    /*
-     * From this point the control must flow through the label out.
-     *
-     * Push a compiler frame if we have no frames, or if the top frame is a
-     * lightweight function activation, or if its scope chain doesn't match
-     * the one passed to us.
-     */
-    fp = cx->fp;
-    MaybeSetupFrame(cx, obj, fp, &frame);
+    JS_ASSERT(!(tcflags & ~(TCF_COMPILE_N_GO | TCF_NO_SCRIPT_RVAL |
+                            TCF_STATIC_DEPTH_MASK)));
+
+    /*
+     * The scripted callerFrame can only be given for compile-and-go scripts
+     * and non-zero static depth requires callerFrame.
+     */
+    JS_ASSERT_IF(callerFrame, tcflags & TCF_COMPILE_N_GO);
+    JS_ASSERT_IF(TCF_GET_STATIC_DEPTH(tcflags) != 0, callerFrame);
+
+    if (!js_InitParseContext(cx, &pc, principals, callerFrame, chars, length,
+                             file, filename, lineno)) {
+        return NULL;
+    }
 
     JS_INIT_ARENA_POOL(&codePool, "code", 1024, sizeof(jsbytecode),
                        &cx->scriptStackQuota);
     JS_INIT_ARENA_POOL(&notePool, "note", 1024, sizeof(jssrcnote),
                        &cx->scriptStackQuota);
     js_InitCodeGenerator(cx, &cg, &pc, &codePool, &notePool,
                          pc.tokenStream.lineno);
 
-    /* From this point the control must flow via the label out. */
+    MUST_FLOW_THROUGH("out");
     cg.treeContext.flags |= (uint16) tcflags;
+    cg.treeContext.u.scopeChain = scopeChain;
     cg.staticDepth = TCF_GET_STATIC_DEPTH(tcflags);
 
-    /*
-     * Inline Statements() to emit as we go to save space.
-     */
+    /* Inline Statements() to emit as we go to save space. */
     for (;;) {
         pc.tokenStream.flags |= TSF_OPERAND;
         tt = js_PeekToken(cx, &pc.tokenStream);
         pc.tokenStream.flags &= ~TSF_OPERAND;
         if (tt <= TOK_EOF) {
             if (tt == TOK_EOF)
                 break;
             JS_ASSERT(tt == TOK_ERROR);
@@ -609,17 +556,16 @@ js_CompileScript(JSContext *cx, JSObject
             goto out;
         }
 
         pn = Statement(cx, &pc.tokenStream, &cg.treeContext);
         if (!pn) {
             script = NULL;
             goto out;
         }
-
         JS_ASSERT(!cg.treeContext.blockNode);
 
         if (!js_FoldConstants(cx, pn, &cg.treeContext) ||
             !js_EmitTree(cx, &cg, pn)) {
             script = NULL;
             goto out;
         }
         RecycleTree(pn, &cg.treeContext);
@@ -687,29 +633,28 @@ js_CompileScript(JSContext *cx, JSObject
 #endif
 #ifdef JS_ARENAMETER
     JS_DumpArenaStats(stdout);
 #endif
     script = js_NewScriptFromCG(cx, &cg);
 
 #ifdef JS_SCOPE_DEPTH_METER
     if (script) {
-        JSObject *pobj = obj;
+        JSObject *obj = scopeChain;
         uintN depth = 1;
-        while ((pobj = OBJ_GET_PARENT(cx, pobj)) != NULL)
+        while ((obj = OBJ_GET_PARENT(cx, obj)) != NULL)
             ++depth;
         JS_BASIC_STATS_ACCUM(&cx->runtime->hostenvScopeDepthStats, depth);
     }
 #endif
 
   out:
     js_FinishCodeGenerator(cx, &cg);
     JS_FinishArenaPool(&codePool);
     JS_FinishArenaPool(&notePool);
-    cx->fp = fp;
     js_FinishParseContext(cx, &pc);
     return script;
 
   too_many_slots:
     js_ReportCompileErrorNumber(cx, &pc.tokenStream, NULL,
                                 JSREPORT_ERROR, JSMSG_TOO_MANY_LOCALS);
     script = NULL;
     goto out;
@@ -844,18 +789,18 @@ HasFinalReturn(JSParseNode *pn)
 
 static JSBool
 ReportBadReturn(JSContext *cx, JSTreeContext *tc, uintN flags, uintN errnum,
                 uintN anonerrnum)
 {
     const char *name;
 
     JS_ASSERT(tc->flags & TCF_IN_FUNCTION);
-    if (tc->fun->atom) {
-        name = js_AtomToPrintableString(cx, tc->fun->atom);
+    if (tc->u.fun->atom) {
+        name = js_AtomToPrintableString(cx, tc->u.fun->atom);
     } else {
         errnum = anonerrnum;
         name = NULL;
     }
     return js_ReportCompileErrorNumber(cx, TS(tc->parseContext), NULL, flags,
                                        errnum, name);
 }
 
@@ -939,30 +884,30 @@ js_CompileFunctionBody(JSContext *cx, JS
                        const jschar *chars, size_t length,
                        const char *filename, uintN lineno)
 {
     JSParseContext pc;
     JSArenaPool codePool, notePool;
     JSCodeGenerator funcg;
     JSParseNode *pn;
 
-    if (!js_InitParseContext(cx, &pc, principals, chars, length, NULL,
+    if (!js_InitParseContext(cx, &pc, principals, NULL, chars, length, NULL,
                              filename, lineno)) {
         return JS_FALSE;
     }
 
     /* No early return from this point until js_FinishParseContext call. */
     JS_INIT_ARENA_POOL(&codePool, "code", 1024, sizeof(jsbytecode),
                        &cx->scriptStackQuota);
     JS_INIT_ARENA_POOL(&notePool, "note", 1024, sizeof(jssrcnote),
                        &cx->scriptStackQuota);
     js_InitCodeGenerator(cx, &funcg, &pc, &codePool, &notePool,
                          pc.tokenStream.lineno);
     funcg.treeContext.flags |= TCF_IN_FUNCTION;
-    funcg.treeContext.fun = fun;
+    funcg.treeContext.u.fun = fun;
 
     /*
      * Farble the body so that it looks like a block statement to js_EmitTree,
      * which is called beneath FunctionBody; see Statements, further below in
      * this file.  FunctionBody pushes a STMT_BLOCK record around its call to
      * Statements, so Statements will not compile each statement as it loops
      * to save JSParseNode space -- it will not compile at all, only build a
      * JSParseNode tree.
@@ -1020,28 +965,28 @@ BindArg(JSContext *cx, JSAtom *atom, JST
 BindArg(JSContext *cx, JSAtom *atom, JSTreeContext *tc)
 {
     const char *name;
 
     /*
      * Check for a duplicate parameter name, a "feature" required by ECMA-262.
      */
     JS_ASSERT(tc->flags & TCF_IN_FUNCTION);
-    if (js_LookupLocal(cx, tc->fun, atom, NULL) != JSLOCAL_NONE) {
+    if (js_LookupLocal(cx, tc->u.fun, atom, NULL) != JSLOCAL_NONE) {
         name = js_AtomToPrintableString(cx, atom);
         if (!name ||
             !js_ReportCompileErrorNumber(cx, TS(tc->parseContext), NULL,
                                          JSREPORT_WARNING | JSREPORT_STRICT,
                                          JSMSG_DUPLICATE_FORMAL,
                                          name)) {
             return JS_FALSE;
         }
     }
 
-    return js_AddLocal(cx, tc->fun, atom, JSLOCAL_ARG);
+    return js_AddLocal(cx, tc->u.fun, atom, JSLOCAL_ARG);
 }
 
 static JSBool
 BindLocalVariable(JSContext *cx, JSFunction *fun, JSAtom *atom,
                   JSLocalKind localKind)
 {
     JS_ASSERT(localKind == JSLOCAL_VAR || localKind == JSLOCAL_CONST);
 
@@ -1076,42 +1021,44 @@ BindDestructuringArg(JSContext *cx, Bind
     ATOM_LIST_SEARCH(ale, &tc->decls, atom);
     if (!ale) {
         ale = js_IndexAtom(cx, atom, &tc->decls);
         if (!ale)
             return JS_FALSE;
         ALE_SET_JSOP(ale, data->op);
     }
 
-    if (js_LookupLocal(cx, tc->fun, atom, NULL) != JSLOCAL_NONE) {
+    if (js_LookupLocal(cx, tc->u.fun, atom, NULL) != JSLOCAL_NONE) {
         name = js_AtomToPrintableString(cx, atom);
         if (!name ||
             !js_ReportCompileErrorNumber(cx, TS(tc->parseContext), data->pn,
                                          JSREPORT_WARNING | JSREPORT_STRICT,
                                          JSMSG_DUPLICATE_FORMAL,
                                          name)) {
             return JS_FALSE;
         }
     } else {
-        if (!BindLocalVariable(cx, tc->fun, atom, JSLOCAL_VAR))
+        if (!BindLocalVariable(cx, tc->u.fun, atom, JSLOCAL_VAR))
             return JS_FALSE;
     }
     return JS_TRUE;
 }
 #endif /* JS_HAS_DESTRUCTURING */
 
 static JSFunction *
 NewCompilerFunction(JSContext *cx, JSTreeContext *tc, JSAtom *atom,
                     uintN lambda)
 {
     JSObject *parent;
     JSFunction *fun;
 
     JS_ASSERT((lambda & ~JSFUN_LAMBDA) == 0);
-    parent = (tc->flags & TCF_IN_FUNCTION) ? FUN_OBJECT(tc->fun) : cx->fp->varobj;
+    parent = (tc->flags & TCF_IN_FUNCTION)
+             ? FUN_OBJECT(tc->u.fun)
+             : tc->u.scopeChain;
     fun = js_NewFunction(cx, NULL, NULL, 0, JSFUN_INTERPRETED | lambda,
                          parent, atom);
     if (fun && !(tc->flags & TCF_COMPILE_N_GO)) {
         STOBJ_CLEAR_PARENT(FUN_OBJECT(fun));
         STOBJ_CLEAR_PROTO(FUN_OBJECT(fun));
     }
     return fun;
 }
@@ -1171,34 +1118,33 @@ FunctionDef(JSContext *cx, JSTokenStream
                 const char *name = js_AtomToPrintableString(cx, funAtom);
                 if (!name ||
                     !js_ReportCompileErrorNumber(cx, ts, NULL,
                                                  (prevop != JSOP_DEFCONST)
                                                  ? JSREPORT_WARNING |
                                                    JSREPORT_STRICT
                                                  : JSREPORT_ERROR,
                                                  JSMSG_REDECLARED_VAR,
-                                                 (prevop == JSOP_DEFFUN ||
-                                                  prevop == JSOP_CLOSURE)
+                                                 (prevop == JSOP_DEFFUN)
                                                  ? js_function_str
                                                  : (prevop == JSOP_DEFCONST)
                                                  ? js_const_str
                                                  : js_var_str,
                                                  name)) {
                     return NULL;
                 }
             }
             if (!AT_TOP_LEVEL(tc) && prevop == JSOP_DEFVAR)
                 tc->flags |= TCF_FUN_CLOSURE_VS_VAR;
         } else {
             ale = js_IndexAtom(cx, funAtom, &tc->decls);
             if (!ale)
                 return NULL;
         }
-        ALE_SET_JSOP(ale, AT_TOP_LEVEL(tc) ? JSOP_DEFFUN : JSOP_CLOSURE);
+        ALE_SET_JSOP(ale, JSOP_DEFFUN);
 
         /*
          * A function nested at top level inside another's body needs only a
          * local variable to bind its name to its value, and not an activation
          * object property (it might also need the activation property, if the
          * outer function contains with statements, e.g., but the stack slot
          * wins when jsemit.c's BindNameToSlot can optimize a JSOP_NAME into a
          * JSOP_GETLOCAL bytecode).
@@ -1208,19 +1154,19 @@ FunctionDef(JSContext *cx, JSTokenStream
 
             /*
              * Define a property on the outer function so that BindNameToSlot
              * can properly optimize accesses. Note that we need a variable,
              * not an argument, for the function statement. Thus we add a
              * variable even if the parameter with the given name already
              * exists.
              */
-            localKind = js_LookupLocal(cx, tc->fun, funAtom, NULL);
+            localKind = js_LookupLocal(cx, tc->u.fun, funAtom, NULL);
             if (localKind == JSLOCAL_NONE || localKind == JSLOCAL_ARG) {
-                if (!js_AddLocal(cx, tc->fun, funAtom, JSLOCAL_VAR))
+                if (!js_AddLocal(cx, tc->u.fun, funAtom, JSLOCAL_VAR))
                     return NULL;
             }
         }
     }
 
     fun = NewCompilerFunction(cx, tc, funAtom, lambda);
     if (!fun)
         return NULL;
@@ -1236,17 +1182,17 @@ FunctionDef(JSContext *cx, JSTokenStream
      */
     funpob = js_NewParsedObjectBox(cx, tc->parseContext, FUN_OBJECT(fun));
     if (!funpob)
         return NULL;
 
     /* Initialize early for possible flags mutation via DestructuringExpr. */
     TREE_CONTEXT_INIT(&funtc, tc->parseContext);
     funtc.flags |= TCF_IN_FUNCTION | (tc->flags & TCF_COMPILE_N_GO);
-    funtc.fun = fun;
+    funtc.u.fun = fun;
 
     /* Now parse formal argument list and compute fun->nargs. */
     MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_FORMAL);
     if (!js_MatchToken(cx, ts, TOK_RP)) {
         do {
             tt = js_GetToken(cx, ts);
             switch (tt) {
 #if JS_HAS_DESTRUCTURING
@@ -1393,17 +1339,17 @@ FunctionDef(JSContext *cx, JSTokenStream
      * per invocation).
      */
     if (funtc.flags & TCF_FUN_HEAVYWEIGHT) {
         fun->flags |= JSFUN_HEAVYWEIGHT;
         tc->flags |= TCF_FUN_HEAVYWEIGHT;
     } else {
         /*
          * If this function is a named statement function not at top-level
-         * (i.e. a JSOP_CLOSURE, not a function definiton or expression), then
+         * (i.e. not a top-level function definiton or expression), then
          * our enclosing function, if any, must be heavyweight.
          *
          * The TCF_FUN_USES_NONLOCALS flag is set only by the code generator,
          * so it won't be set here.  Assert that it's not.  We have to check
          * it later, in js_EmitTree, after js_EmitFunctionScript has traversed
          * the function's body.
          */
         JS_ASSERT(!(funtc.flags & TCF_FUN_USES_NONLOCALS));
@@ -1434,17 +1380,17 @@ FunctionDef(JSContext *cx, JSTokenStream
         op = JSOP_ANONFUNOBJ;
     } else if (!AT_TOP_LEVEL(tc)) {
         /*
          * ECMA ed. 3 extension: a function expression statement not at the
          * top level, e.g., in a compound statement such as the "then" part
          * of an "if" statement, binds a closure only if control reaches that
          * sub-statement.
          */
-        op = JSOP_CLOSURE;
+        op = JSOP_DEFFUN;
     } else {
         op = JSOP_NOP;
     }
 
     pn->pn_funpob = funpob;
     pn->pn_op = op;
     pn->pn_body = body;
     pn->pn_flags = funtc.flags & (TCF_FUN_FLAGS | TCF_HAS_DEFXMLNS | TCF_COMPILE_N_GO);
@@ -1647,27 +1593,26 @@ BindVarOrConst(JSContext *cx, BindData *
             if (!name ||
                 !js_ReportCompileErrorNumber(cx, TS(tc->parseContext), data->pn,
                                              (op != JSOP_DEFCONST &&
                                               prevop != JSOP_DEFCONST)
                                              ? JSREPORT_WARNING |
                                                JSREPORT_STRICT
                                              : JSREPORT_ERROR,
                                              JSMSG_REDECLARED_VAR,
-                                             (prevop == JSOP_DEFFUN ||
-                                              prevop == JSOP_CLOSURE)
+                                             (prevop == JSOP_DEFFUN)
                                              ? js_function_str
                                              : (prevop == JSOP_DEFCONST)
                                              ? js_const_str
                                              : js_var_str,
                                              name)) {
                 return JS_FALSE;
             }
         }
-        if (op == JSOP_DEFVAR && prevop == JSOP_CLOSURE)
+        if (op == JSOP_DEFVAR && prevop == JSOP_DEFFUN)
             tc->flags |= TCF_FUN_CLOSURE_VS_VAR;
     }
     if (!ale) {
         ale = js_IndexAtom(cx, atom, &tc->decls);
         if (!ale)
             return JS_FALSE;
     }
     ALE_SET_JSOP(ale, op);
@@ -1675,29 +1620,29 @@ BindVarOrConst(JSContext *cx, BindData *
     if (!(tc->flags & TCF_IN_FUNCTION)) {
         /*
          * Don't lookup global variables or variables in an active frame at
          * compile time.
          */
         return JS_TRUE;
     }
 
-    localKind = js_LookupLocal(cx, tc->fun, atom, NULL);
+    localKind = js_LookupLocal(cx, tc->u.fun, atom, NULL);
     if (localKind == JSLOCAL_NONE) {
         /*
          * Property not found in current variable scope: we have not seen this
          * variable before.  Define a new local variable by adding a property
          * to the function's scope, allocating one slot in the function's vars
          * frame. Any locals declared in with statement bodies are handled at
          * runtime, by script prolog JSOP_DEFVAR opcodes generated for
          * slot-less vars.
          */
         localKind = (data->op == JSOP_DEFCONST) ? JSLOCAL_CONST : JSLOCAL_VAR;
         if (!js_InWithStatement(tc) &&
-            !BindLocalVariable(cx, tc->fun, atom, localKind)) {
+            !BindLocalVariable(cx, tc->u.fun, atom, localKind)) {
             return JS_FALSE;
         }
     } else if (localKind == JSLOCAL_ARG) {
         name = js_AtomToPrintableString(cx, atom);
         if (!name)
             return JS_FALSE;
 
         if (op == JSOP_DEFCONST) {
@@ -1991,17 +1936,17 @@ CheckDestructuring(JSContext *cx, BindDa
 
     if (left->pn_type == TOK_ARRAYCOMP) {
         js_ReportCompileErrorNumber(cx, TS(tc->parseContext), left,
                                     JSREPORT_ERROR, JSMSG_ARRAY_COMP_LEFTSIDE);
         return JS_FALSE;
     }
 
 #if JS_HAS_DESTRUCTURING_SHORTHAND
-    if (right && (right->pn_extra & PNX_SHORTHAND)) {
+    if (right && right->pn_arity == PN_LIST && (right->pn_extra & PNX_SHORTHAND)) {
         js_ReportCompileErrorNumber(cx, TS(tc->parseContext), right,
                                     JSREPORT_ERROR, JSMSG_BAD_OBJECT_INIT);
         return JS_FALSE;
     }
 #endif
 
     fpvd.table.ops = NULL;
     lhs = left->pn_head;
@@ -3450,17 +3395,16 @@ static JSParseNode *
 static JSParseNode *
 Variables(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
 {
     JSTokenType tt;
     JSBool let;
     JSStmtInfo *scopeStmt;
     BindData data;
     JSParseNode *pn, *pn2;
-    JSStackFrame *fp;
     JSAtom *atom;
 
     /*
      * The three options here are:
      * - TOK_LET: We are parsing a let declaration.
      * - TOK_LP: We are parsing the head of a let block.
      * - Otherwise, we're parsing var declarations.
      */
@@ -3490,17 +3434,16 @@ Variables(JSContext *cx, JSTokenStream *
      * The tricky part of this code is to create special parsenode opcodes for
      * getting and setting variables (which will be stored as special slots in
      * the frame).  The most complicated case is an eval() inside a function.
      * If the evaluated string references variables in the enclosing function,
      * then we need to generate the special variable opcodes.  We determine
      * this by looking up the variable's id in the current variable object.
      * Fortunately, we can avoid doing this for let declared variables.
      */
-    fp = cx->fp;
     if (let) {
         JS_ASSERT(tc->blockChain == scopeStmt->u.blockObj);
         data.binder = BindLet;
         data.u.let.overflow = JSMSG_TOO_MANY_LOCALS;
     } else {
         data.binder = BindVarOrConst;
     }
 
@@ -5201,46 +5144,43 @@ XMLElementOrListRoot(JSContext *cx, JSTo
     JS_SetOptions(cx, oldopts);
     return pn;
 }
 
 JS_FRIEND_API(JSParseNode *)
 js_ParseXMLText(JSContext *cx, JSObject *chain, JSParseContext *pc,
                 JSBool allowList)
 {
-    JSStackFrame *fp, frame;
     JSParseNode *pn;
     JSTreeContext tc;
     JSTokenType tt;
 
     /*
      * Push a compiler frame if we have no frames, or if the top frame is a
      * lightweight function activation, or if its scope chain doesn't match
      * the one passed to us.
      */
-    fp = cx->fp;
-    MaybeSetupFrame(cx, chain, fp, &frame);
     TREE_CONTEXT_INIT(&tc, pc);
+    tc.u.scopeChain = chain;
 
     /* Set XML-only mode to turn off special treatment of {expr} in XML. */
     TS(pc)->flags |= TSF_OPERAND | TSF_XMLONLYMODE;
     tt = js_GetToken(cx, TS(pc));
     TS(pc)->flags &= ~TSF_OPERAND;
 
     if (tt != TOK_XMLSTAGO) {
         js_ReportCompileErrorNumber(cx, TS(pc), NULL, JSREPORT_ERROR,
                                     JSMSG_BAD_XML_MARKUP);
         pn = NULL;
     } else {
         pn = XMLElementOrListRoot(cx, TS(pc), &tc, allowList);
     }
 
     TS(pc)->flags &= ~TSF_XMLONLYMODE;
     TREE_CONTEXT_FINISH(cx, &tc);
-    cx->fp = fp;
     return pn;
 }
 
 #endif /* JS_HAS_XMLSUPPORT */
 
 static JSParseNode *
 PrimaryExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc,
             JSTokenType tt, JSBool afterDot)
diff -r b7bcdd009540 js/src/jsparse.h
--- a/js/src/jsparse.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/jsparse.h	Thu Sep 11 15:19:25 2008 +0300
@@ -427,16 +427,18 @@ struct JSParsedObjectBox {
     JSParsedObjectBox   *emitLink;
     JSObject            *object;
 };
 
 struct JSParseContext {
     JSTokenStream       tokenStream;
     void                *tempPoolMark;  /* initial JSContext.tempPool mark */
     JSPrincipals        *principals;    /* principals associated with source */
+    JSStackFrame        *callerFrame;   /* scripted caller frame for eval and
+                                           debug scripts */
     JSParseNode         *nodeList;      /* list of recyclable parse-node
                                            structs */
     JSParsedObjectBox   *traceListHead; /* list of parsed object for GC
                                            tracing */
     JSTempValueRooter   tempRoot;       /* root to trace traceListHead */
 };
 
 /*
@@ -446,18 +448,19 @@ struct JSParseContext {
 
 /*
  * Parse a top-level JS script.
  */
 extern JSParseNode *
 js_ParseScript(JSContext *cx, JSObject *chain, JSParseContext *pc);
 
 extern JSScript *
-js_CompileScript(JSContext *cx, JSObject *obj, JSPrincipals *principals,
-                 uint32 tcflags, const jschar *chars, size_t length,
+js_CompileScript(JSContext *cx, JSObject *scopeChain, JSStackFrame *callerFrame,
+                 JSPrincipals *principals, uint32 tcflags,
+                 const jschar *chars, size_t length,
                  FILE *file, const char *filename, uintN lineno);
 
 extern JSBool
 js_CompileFunctionBody(JSContext *cx, JSFunction *fun, JSPrincipals *principals,
                        const jschar *chars, size_t length,
                        const char *filename, uintN lineno);
 
 extern JSBool
@@ -474,16 +477,17 @@ js_ParseXMLText(JSContext *cx, JSObject 
  * js_InitTokenStream.
  *
  * The parse context owns the arena pool "tops-of-stack" space above the
  * current JSContext.tempPool mark. This means you cannot allocate from
  * tempPool and save the pointer beyond the next js_FinishParseContext.
  */
 extern JSBool
 js_InitParseContext(JSContext *cx, JSParseContext *pc, JSPrincipals *principals,
+                    JSStackFrame *callerFrame,
                     const jschar *base, size_t length, FILE *fp,
                     const char *filename, uintN lineno);
 
 extern void
 js_FinishParseContext(JSContext *cx, JSParseContext *pc);
 
 extern void
 js_InitCompilePrincipals(JSContext *cx, JSParseContext *pc,
diff -r b7bcdd009540 js/src/jsscan.cpp
--- a/js/src/jsscan.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/jsscan.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -64,16 +64,17 @@
 #include "jsemit.h"
 #include "jsexn.h"
 #include "jsnum.h"
 #include "jsopcode.h"
 #include "jsparse.h"
 #include "jsregexp.h"
 #include "jsscan.h"
 #include "jsscript.h"
+#include "jsstaticcheck.h"
 
 #if JS_HAS_XML_SUPPORT
 #include "jsxml.h"
 #endif
 
 #define JS_KEYWORD(keyword, type, op, version) \
     const char js_##keyword##_str[] = #keyword;
 #include "jskeyword.tbl"
@@ -530,17 +531,17 @@ js_ReportCompileErrorNumber(JSContext *c
 
     memset(&report, 0, sizeof report);
     report.flags = flags;
     report.errorNumber = errorNumber;
     message = NULL;
     linechars = NULL;
     linebytes = NULL;
 
-    /* From this point the control must flow through the label out.*/
+    MUST_FLOW_THROUGH("out");
     va_start(ap, errorNumber);
     ok = js_ExpandErrorArguments(cx, js_GetErrorMessage, NULL,
                                  errorNumber, &message, &report, &warning,
                                  !(flags & JSREPORT_UC), ap);
     va_end(ap);
     if (!ok) {
         warning = JS_FALSE;
         goto out;
diff -r b7bcdd009540 js/src/jsscope.h
--- a/js/src/jsscope.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/jsscope.h	Thu Sep 11 15:19:25 2008 +0300
@@ -213,16 +213,17 @@ struct JSScope {
 
 #ifdef JS_THREADSAFE
 JS_STATIC_ASSERT(offsetof(JSScope, title) == sizeof(JSObjectMap));
 #endif
 
 #define JS_IS_SCOPE_LOCKED(cx, scope)   JS_IS_TITLE_LOCKED(cx, &(scope)->title)
 
 #define OBJ_SCOPE(obj)                  ((JSScope *)(obj)->map)
+#define OBJ_SHAPE(obj)                  (OBJ_SCOPE(obj)->shape)
 
 #define SCOPE_MAKE_UNIQUE_SHAPE(cx,scope)                                     \
     ((scope)->shape = js_GenerateShape((cx), JS_FALSE))
 
 #define SCOPE_EXTEND_SHAPE(cx,scope,sprop)                                    \
     JS_BEGIN_MACRO                                                            \
         if (!(scope)->lastProp ||                                             \
             (scope)->shape == (scope)->lastProp->shape) {                     \
diff -r b7bcdd009540 js/src/jsscript.cpp
--- a/js/src/jsscript.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/jsscript.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -53,16 +53,17 @@
 #include "jsdbgapi.h"
 #include "jsemit.h"
 #include "jsfun.h"
 #include "jsinterp.h"
 #include "jslock.h"
 #include "jsnum.h"
 #include "jsopcode.h"
 #include "jsparse.h"
+#include "jsscope.h"
 #include "jsscript.h"
 #if JS_HAS_XDR
 #include "jsxdrapi.h"
 #endif
 
 #if JS_HAS_SCRIPT_OBJECT
 
 static const char js_script_exec_str[]    = "Script.prototype.exec";
@@ -195,17 +196,17 @@ static JSBool
 static JSBool
 script_compile_sub(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                    jsval *rval)
 {
     JSString *str;
     JSObject *scopeobj;
     jsval v;
     JSScript *script, *oldscript;
-    JSStackFrame *fp, *caller;
+    JSStackFrame *caller;
     const char *file;
     uintN line;
     JSPrincipals *principals;
     uint32 tcflags;
     jsint execDepth;
 
     /* Make sure obj is a Script object. */
     if (!JS_InstanceOf(cx, obj, &js_ScriptClass, argv))
@@ -224,52 +225,49 @@ script_compile_sub(JSContext *cx, JSObje
     scopeobj = NULL;
     if (argc >= 2) {
         if (!js_ValueToObject(cx, argv[1], &scopeobj))
             return JS_FALSE;
         argv[1] = OBJECT_TO_JSVAL(scopeobj);
     }
 
     /* Compile using the caller's scope chain, which js_Invoke passes to fp. */
-    fp = cx->fp;
-    caller = JS_GetScriptedCaller(cx, fp);
-    JS_ASSERT(!caller || fp->scopeChain == caller->scopeChain);
+    caller = JS_GetScriptedCaller(cx, cx->fp);
+    JS_ASSERT(!caller || cx->fp->scopeChain == caller->scopeChain);
 
     if (caller) {
         if (!scopeobj) {
             scopeobj = js_GetScopeChain(cx, caller);
             if (!scopeobj)
                 return JS_FALSE;
-            fp->scopeChain = scopeobj;  /* for the compiler's benefit */
         }
 
-        principals = JS_EvalFramePrincipals(cx, fp, caller);
+        principals = JS_EvalFramePrincipals(cx, cx->fp, caller);
         file = js_ComputeFilename(cx, caller, principals, &line);
     } else {
         file = NULL;
         line = 0;
         principals = NULL;
     }
 
     /* Ensure we compile this script with the right (inner) principals. */
     scopeobj = js_CheckScopeChainValidity(cx, scopeobj, js_script_compile_str);
     if (!scopeobj)
         return JS_FALSE;
 
     /*
      * Compile the new script using the caller's scope chain, a la eval().
      * Unlike jsobj.c:obj_eval, however, we do not pass TCF_COMPILE_N_GO in
-     * tcflags, because compilation is here separated from execution, and the
-     * run-time scope chain may not match the compile-time.  JSFRAME_EVAL is
-     * tested in jsemit.c and jsscan.c to optimize based on identity of run-
-     * and compile-time scope.
+     * tcflags and use NULL for the callerFrame argument, because compilation
+     * is here separated from execution, and the run-time scope chain may not
+     * match the compile-time. TCF_COMPILE_N_GO is tested in jsemit.c and
+     * jsparse.c to optimize based on identity of run- and compile-time scope.
      */
-    fp->flags |= JSFRAME_SCRIPT_OBJECT;
-    tcflags = caller ? TCF_PUT_STATIC_DEPTH(caller->staticDepth + 1) : 0;
-    script = js_CompileScript(cx, scopeobj, principals, tcflags,
+    tcflags = 0;
+    script = js_CompileScript(cx, scopeobj, NULL, principals, tcflags,
                               JSSTRING_CHARS(str), JSSTRING_LENGTH(str),
                               NULL, file, line);
     if (!script)
         return JS_FALSE;
 
     JS_LOCK_OBJ(cx, obj);
     execDepth = GetScriptExecDepth(cx, obj);
 
@@ -836,24 +834,24 @@ static const char js_thaw_str[] = "thaw"
 
 #endif /* JS_HAS_SCRIPT_OBJECT && JS_HAS_XDR_FREEZE_THAW */
 #endif /* JS_HAS_XDR */
 
 #if JS_HAS_SCRIPT_OBJECT
 
 static JSFunctionSpec script_methods[] = {
 #if JS_HAS_TOSOURCE
-    JS_FN(js_toSource_str,   script_toSource,   0,0,0),
+    JS_FN(js_toSource_str,   script_toSource,   0,0),
 #endif
-    JS_FN(js_toString_str,   script_toString,   0,0,0),
-    JS_FN("compile",         script_compile,    0,2,0),
-    JS_FN("exec",            script_exec,       0,1,0),
+    JS_FN(js_toString_str,   script_toString,   0,0),
+    JS_FN("compile",         script_compile,    2,0),
+    JS_FN("exec",            script_exec,       1,0),
 #if JS_HAS_XDR_FREEZE_THAW
-    JS_FN("freeze",          script_freeze,     0,0,0),
-    JS_FN(js_thaw_str,       script_thaw,       0,1,0),
+    JS_FN("freeze",          script_freeze,     0,0),
+    JS_FN(js_thaw_str,       script_thaw,       1,0),
 #endif /* JS_HAS_XDR_FREEZE_THAW */
     JS_FS_END
 };
 
 #endif /* JS_HAS_SCRIPT_OBJECT */
 
 static void
 script_finalize(JSContext *cx, JSObject *obj)
@@ -929,24 +927,24 @@ script_static_thaw(JSContext *cx, uintN 
 script_static_thaw(JSContext *cx, uintN argc, jsval *vp)
 {
     JSObject *obj;
 
     obj = js_NewObject(cx, &js_ScriptClass, NULL, NULL);
     if (!obj)
         return JS_FALSE;
     vp[1] = OBJECT_TO_JSVAL(obj);
-    if (!script_thaw(cx, vp))
+    if (!script_thaw(cx, argc, vp))
         return JS_FALSE;
     *vp = OBJECT_TO_JSVAL(obj);
     return JS_TRUE;
 }
 
 static JSFunctionSpec script_static_methods[] = {
-    JS_FN(js_thaw_str,       script_static_thaw,     1,1,0),
+    JS_FN(js_thaw_str,       script_static_thaw,     1,0),
     JS_FS_END
 };
 
 #else  /* !JS_HAS_SCRIPT_OBJECT || !JS_HAS_XDR_FREEZE_THAW */
 
 #define script_static_methods   NULL
 
 #endif /* !JS_HAS_SCRIPT_OBJECT || !JS_HAS_XDR_FREEZE_THAW */
@@ -1470,17 +1468,17 @@ js_NewScriptFromCG(JSContext *cx, JSCode
     if (!script)
         return NULL;
 
     /* Now that we have script, error control flow must go to label bad. */
     script->main += prologLength;
     memcpy(script->code, CG_PROLOG_BASE(cg), prologLength * sizeof(jsbytecode));
     memcpy(script->main, CG_BASE(cg), mainLength * sizeof(jsbytecode));
     nfixed = (cg->treeContext.flags & TCF_IN_FUNCTION)
-             ? cg->treeContext.fun->u.i.nvars
+             ? cg->treeContext.u.fun->u.i.nvars
              : cg->treeContext.ngvars + cg->regexpList.length;
     JS_ASSERT(nfixed < SLOTNO_LIMIT);
     script->nfixed = (uint16) nfixed;
     js_InitAtomMap(cx, &script->atomMap, &cg->atomList);
 
     filename = cg->treeContext.parseContext->tokenStream.filename;
     if (filename) {
         script->filename = js_SaveScriptFilename(cx, filename);
@@ -1520,17 +1518,17 @@ js_NewScriptFromCG(JSContext *cx, JSCode
     }
 
     /*
      * We initialize fun->u.script to be the script constructed above
      * so that the debugger has a valid FUN_SCRIPT(fun).
      */
     fun = NULL;
     if (cg->treeContext.flags & TCF_IN_FUNCTION) {
-        fun = cg->treeContext.fun;
+        fun = cg->treeContext.u.fun;
         JS_ASSERT(FUN_INTERPRETED(fun) && !FUN_SCRIPT(fun));
         JS_ASSERT_IF(script->upvarsOffset != 0,
                      JS_SCRIPT_UPVARS(script)->length == fun->u.i.nupvars);
 
         js_FreezeLocalNames(cx, fun);
         fun->u.i.script = script;
 #ifdef CHECK_SCRIPT_OWNER
         script->owner = NULL;
diff -r b7bcdd009540 js/src/jsstaticcheck.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/jsstaticcheck.h	Thu Sep 11 15:19:25 2008 +0300
@@ -0,0 +1,57 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released
+ * March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef jsstaticcheck_h___
+#define jsstaticcheck_h___
+
+#ifdef NS_STATIC_CHECKING
+/*
+ * Trigger a control flow check to make sure that code flows through label
+ */
+inline __attribute__ ((unused)) void MUST_FLOW_THROUGH(const char *label) {
+}
+
+/* avoid unused goto-label warnings */
+#define MUST_FLOW_LABEL(label) goto label; label:
+#else
+#define MUST_FLOW_THROUGH(label) ((void)0)
+#define MUST_FLOW_LABEL(label)
+#endif
+
+#endif /* jsstaticcheck_h___ */
diff -r b7bcdd009540 js/src/jstracer.cpp
--- a/js/src/jstracer.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/jstracer.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -41,16 +41,19 @@
 
 #include "jsstddef.h"           // always first
 #include "jsbit.h"              // low-level (NSPR-based) headers next
 #include "jsprf.h"
 #include <math.h>               // standard headers next
 #ifdef _MSC_VER
 #include <malloc.h>
 #define alloca _alloca
+#endif
+#ifdef SOLARIS
+#include <alloca.h>
 #endif
 
 #include "nanojit/avmplus.h"    // nanojit
 #include "nanojit/nanojit.h"
 #include "jsarray.h"            // higher-level library and API headers
 #include "jsbool.h"
 #include "jscntxt.h"
 #include "jsdbgapi.h"
@@ -69,17 +72,17 @@
 
 /* Number of iterations of a loop before we start tracing. */
 #define HOTLOOP 2
 
 /* Number of times we wait to exit on a side exit before we try to extend the tree. */
 #define HOTEXIT 1
 
 /* Max call depths for inlining. */
-#define MAX_CALLDEPTH 5
+#define MAX_CALLDEPTH 10
 
 /* Max number of type mismatchs before we trash the tree. */
 #define MAX_MISMATCH 5
 
 /* Max native stack size. */
 #define MAX_NATIVE_STACK_SLOTS 1024
 
 /* Max call stack size. */
@@ -95,17 +98,17 @@
 #endif
 
 #ifdef DEBUG
 static struct {
     uint64
         recorderStarted, recorderAborted, traceCompleted, sideExitIntoInterpreter,
         typeMapMismatchAtEntry, returnToDifferentLoopHeader, traceTriggered,
         globalShapeMismatchAtEntry, treesTrashed, slotPromoted,
-        unstableLoopVariable, breakLoopExits;
+        unstableLoopVariable, breakLoopExits, returnLoopExits;
 } stat = { 0LL, };
 #define AUDIT(x) (stat.x++)
 #else
 #define AUDIT(x) ((void)0)
 #endif
 
 #define INS_CONST(c)    addName(lir->insImm(c), #c)
 #define INS_CONSTPTR(p) addName(lir->insImmPtr((void*) (p)), #p)
@@ -115,17 +118,19 @@ using namespace nanojit;
 
 static GC gc = GC();
 static avmplus::AvmCore s_core = avmplus::AvmCore();
 static avmplus::AvmCore* core = &s_core;
 
 /* We really need a better way to configure the JIT. Shaver, where is my fancy JIT object? */
 static bool nesting_enabled = true;
 static bool oracle_enabled = true;
+#if defined(NANOJIT_IA32)
 static bool did_we_check_sse2 = false;
+#endif
 
 #if defined(DEBUG) || defined(INCLUDE_VERBOSE_OUTPUT)
 static bool verbose_debug = getenv("TRACEMONKEY") && strstr(getenv("TRACEMONKEY"), "verbose");
 #define debug_only_v(x) if (verbose_debug) { x; }
 #else
 #define debug_only_v(x)
 #endif
 
@@ -340,17 +345,17 @@ static LIns* demote(LirWriter *out, LIns
     int32_t ci = cf > 0x7fffffff ? uint32_t(cf) : int32_t(cf);
     return out->insImm(ci);
 }
 
 static bool isPromoteInt(LIns* i)
 {
     jsdouble d;
     return isi2f(i) || i->isconst() ||
-        (i->isconstq() && ((d = i->constvalf()) == (jsdouble)(jsint)d) && !JSDOUBLE_IS_NEGZERO(d));
+        (i->isconstq() && (d = i->constvalf()) == jsdouble(jsint(d)) && !JSDOUBLE_IS_NEGZERO(d));
 }
 
 static bool isPromoteUint(LIns* i)
 {
     jsdouble d;
     return isu2f(i) || i->isconst() ||
         (i->isconstq() && ((d = i->constvalf()) == (jsdouble)(jsuint)d));
 }
@@ -358,16 +363,21 @@ static bool isPromote(LIns* i)
 static bool isPromote(LIns* i)
 {
     return isPromoteInt(i) || isPromoteUint(i);
 }
 
 static bool isconst(LIns* i, int32_t c)
 {
     return i->isconst() && i->constval() == c;
+}
+
+static bool isAnyConst(LIns* i)
+{
+    return i->isconst() || i->isconstq(); 
 }
 
 static bool overflowSafe(LIns* i)
 {
     LIns* c;
     return (i->isop(LIR_and) && ((c = i->oprnd2())->isconst()) &&
             ((c->constval() & 0xc0000000) == 0)) ||
            (i->isop(LIR_rsh) && ((c = i->oprnd2())->isconst()) &&
@@ -791,18 +801,19 @@ TraceRecorder::TraceRecorder(JSContext* 
     this->globalObj = JS_GetGlobalForObject(cx, cx->fp->scopeChain);
     this->anchor = _anchor;
     this->fragment = _fragment;
     this->lirbuf = _fragment->lirbuf;
     this->treeInfo = ti;
     this->callDepth = _fragment->calldepth;
     JS_ASSERT(!_anchor || _anchor->calldepth == _fragment->calldepth);
     this->atoms = cx->fp->script->atomMap.vector;
+    this->deepAborted = false;
+    this->applyingArguments = false;
     this->trashTree = false;
-    this->deepAborted = false;
     this->whichTreeToTrash = _fragment->root;
 
     debug_only_v(printf("recording starting from %s:%u@%u\n", cx->fp->script->filename,
                         js_PCToLineNumber(cx, cx->fp->script, cx->fp->regs->pc),
                         cx->fp->regs->pc - cx->fp->script->code););
 
     lir = lir_buf_writer = new (&gc) LirBufWriter(lirbuf);
 #ifdef DEBUG
@@ -1164,35 +1175,70 @@ FlushNativeGlobalFrame(JSContext* cx, un
         if (!NativeToValue(cx, *vp, *mp, np + gslots[n]))
             return -1;
         ++mp;
     );
     debug_only_v(printf("\n");)
     return mp - mp_base;
 }
 
-/* Box the given native stack frame into the virtual machine stack. This only fails due to a
-   hard error (out of memory for example). */
+/**
+ * Box the given native stack frame into the virtual machine stack. This fails
+ * only due to a hard error (out of memory for example).
+ *
+ * @param callDepth the distance between the entry frame into our trace and
+ *                  cx->fp when we make this call.  If this is not called as a
+ *                  result of a nested exit, callDepth is 0.
+ * @param mp pointer to an array of type tags (JSVAL_INT, etc.) that indicate
+ *           what the types of the things on the stack are.
+ * @param np pointer to the native stack.  We want to copy values from here to
+ *           the JS stack as needed.
+ * @param stopFrame if non-null, this frame and everything above it should not
+ *                  be restored.
+ * @return the number of things we popped off of np.
+ */
 static int
-FlushNativeStackFrame(JSContext* cx, unsigned callDepth, uint8* mp, double* np, jsval* stopAt)
-{
+FlushNativeStackFrame(JSContext* cx, unsigned callDepth, uint8* mp, double* np,
+                      JSStackFrame* stopFrame)
+{
+    jsval* stopAt = stopFrame ? &stopFrame->argv[-2] : NULL;
     uint8* mp_base = mp;
     double* np_base = np;
     /* Root all string and object references first (we don't need to call the GC for this). */
     FORALL_SLOTS_IN_PENDING_FRAMES(cx, callDepth,
         if (vp == stopAt) goto skip1;
         if ((*mp == JSVAL_STRING || *mp == JSVAL_OBJECT) && !NativeToValue(cx, *vp, *mp, np))
             return -1;
         ++mp; ++np
     );
 skip1:
     // Restore thisp from the now-restored argv[-1] in each pending frame.
-    unsigned n = callDepth;
-    for (JSStackFrame* fp = cx->fp; n-- != 0; fp = fp->down)
-        fp->thisp = JSVAL_TO_OBJECT(fp->argv[-1]);
+    // Keep in mind that we didn't restore frames at stopFrame and above!
+    // Scope to keep |fp| from leaking into the macros we're using.
+    {
+        unsigned n = callDepth+1; // +1 to make sure we restore the entry frame
+        JSStackFrame* fp = cx->fp;
+        if (stopFrame) {
+            for (; fp != stopFrame; fp = fp->down) {
+                JS_ASSERT(n != 0);
+                --n;
+            }
+            // Skip over stopFrame itself.
+            JS_ASSERT(n != 0);
+            --n;
+            fp = fp->down;
+        }
+        for (; n != 0; fp = fp->down) {
+            --n;
+            if (fp->callee) { // might not have it if the entry frame is global
+                JS_ASSERT(JSVAL_IS_OBJECT(fp->argv[-1]));
+                fp->thisp = JSVAL_TO_OBJECT(fp->argv[-1]);
+            }
+        }
+    }
 
     /* Now do this again but this time for all values (properly quicker than actually checking
        the type and excluding strings and objects). The GC might kick in when we store doubles,
        but everything is rooted now (all strings/objects and all doubles we already boxed). */
     mp = mp_base;
     np = np_base;
     FORALL_SLOTS_IN_PENDING_FRAMES(cx, callDepth,
         if (vp == stopAt) goto skip2;
@@ -1309,17 +1355,17 @@ TraceRecorder::lazilyImportGlobalSlot(un
     if (slot != uint16(slot)) /* we use a table of 16-bit ints, bail out if that's not enough */
         return false;
     jsval* vp = &STOBJ_GET_SLOT(globalObj, slot);
     if (tracker.has(vp))
         return true; /* we already have it */
     unsigned index = traceMonitor->globalSlots->length();
     /* If this the first global we are adding, remember the shape of the global object. */
     if (index == 0)
-        traceMonitor->globalShape = OBJ_SCOPE(JS_GetGlobalForObject(cx, cx->fp->scopeChain))->shape;
+        traceMonitor->globalShape = OBJ_SHAPE(JS_GetGlobalForObject(cx, cx->fp->scopeChain));
     /* Add the slot to the list of interned global slots. */
     traceMonitor->globalSlots->add(slot);
     uint8 type = getCoercedType(*vp);
     if ((type == JSVAL_INT) && oracle->isGlobalSlotUndemotable(cx->fp->script, slot))
         type = JSVAL_DOUBLE;
     traceMonitor->globalTypeMap->add(type);
     import(gp_ins, slot*sizeof(double), vp, type, "global", index, NULL);
     return true;
@@ -1341,18 +1387,18 @@ void
 void
 TraceRecorder::set(jsval* p, LIns* i, bool initializing)
 {
     JS_ASSERT(initializing || tracker.has(p));
     tracker.set(p, i);
     /* If we are writing to this location for the first time, calculate the offset into the
        native frame manually, otherwise just look up the last load or store associated with
        the same source address (p) and use the same offset/base. */
-    LIns* x;
-    if ((x = nativeFrameTracker.get(p)) == NULL) {
+    LIns* x = nativeFrameTracker.get(p);
+    if (!x) {
         if (isGlobal(p))
             x = writeBack(i, gp_ins, nativeGlobalOffset(p));
         else
             x = writeBack(i, lirbuf->sp, -treeInfo->nativeStackBase + nativeStackOffset(p));
         nativeFrameTracker.set(p, x);
     } else {
 #define ASSERT_VALID_CACHE_HIT(base, offset)                                  \
     JS_ASSERT(base == lirbuf->sp || base == gp_ins);                          \
@@ -1368,17 +1414,17 @@ TraceRecorder::set(jsval* p, LIns* i, bo
             ASSERT_VALID_CACHE_HIT(x->oprnd2(), x->immdisp());
             writeBack(i, x->oprnd2(), x->immdisp());
         }
     }
 #undef ASSERT_VALID_CACHE_HIT
 }
 
 LIns*
-TraceRecorder::get(jsval* p)
+TraceRecorder::get(jsval* p) const
 {
     return tracker.get(p);
 }
 
 /* Determine whether a bytecode location (pc) terminates a loop or is a path within the loop. */
 static bool
 js_IsLoopExit(JSContext* cx, JSScript* script, jsbytecode* header, jsbytecode* pc)
 {
@@ -1425,16 +1471,17 @@ js_IsLoopExit(JSContext* cx, JSScript* s
       default:;
     }
     return false;
 }
 
 struct FrameInfo {
     JSObject*       callee;     // callee function object
     jsbytecode*     callpc;     // pc of JSOP_CALL in caller script
+    uint8*          typemap;    // typemap for the stack frame
     union {
         struct {
             uint16  spdist;     // distance from fp->slots to fp->regs->sp at JSOP_CALL
             uint16  argc;       // actual argument count, may be < fun->nargs
         } s;
         uint32      word;       // for spdist/argc LIR store in record_JSOP_CALL
     };
 };
@@ -1483,16 +1530,28 @@ TraceRecorder::adjustCallerTypes(Fragmen
     return ok;
 }
 
 /* Find a peer fragment that we can call, considering our current type distribution. */
 bool TraceRecorder::selectCallablePeerFragment(Fragment** first)
 {
     /* Until we have multiple trees per start point this is always the first fragment. */
     return (*first)->code();
+}
+
+uint8 
+TraceRecorder::determineSlotType(jsval* vp) const
+{
+    uint8 m;
+    LIns* i = get(vp);
+    m = isNumber(*vp)
+        ? (isPromoteInt(i) ? JSVAL_INT : JSVAL_DOUBLE)
+        : JSVAL_TAG(*vp);
+    JS_ASSERT((m != JSVAL_INT) || isInt32(*vp));
+    return m;
 }
 
 SideExit*
 TraceRecorder::snapshot(ExitType exitType)
 {
     JSStackFrame* fp = cx->fp;
     if (exitType == BRANCH_EXIT && 
         js_IsLoopExit(cx, fp->script, (jsbytecode*)fragment->root->ip, fp->regs->pc))
@@ -1526,22 +1585,17 @@ TraceRecorder::snapshot(ExitType exitTyp
     exit.ip_adj = pc - (jsbytecode*)fragment->root->ip;
     exit.sp_adj = (stackSlots * sizeof(double)) - treeInfo->nativeStackBase;
     exit.rp_adj = exit.calldepth * sizeof(FrameInfo);
     uint8* m = exit.typeMap = (uint8 *)data->payload();
     /* Determine the type of a store by looking at the current type of the actual value the
        interpreter is using. For numbers we have to check what kind of store we used last
        (integer or double) to figure out what the side exit show reflect in its typemap. */
     FORALL_SLOTS(cx, ngslots, traceMonitor->globalSlots->data(), callDepth,
-        LIns* i = get(vp);
-        *m = isNumber(*vp)
-               ? (isPromoteInt(i) ? JSVAL_INT : JSVAL_DOUBLE)
-               : JSVAL_TAG(*vp);
-        JS_ASSERT((*m != JSVAL_INT) || isInt32(*vp));
-        ++m;
+        *m++ = determineSlotType(vp);
     );
     JS_ASSERT(unsigned(m - exit.typeMap) == ngslots + stackSlots);
     return &exit;
 }
 
 /* Emit a guard for condition (cond), expecting to evaluate to boolean result (expected). */
 LIns*
 TraceRecorder::guard(bool expected, LIns* cond, ExitType exitType)
@@ -2003,17 +2057,17 @@ js_SynthesizeFrame(JSContext* cx, const 
            ((fun->nargs > cx->fp->argc) ? fun->nargs - cx->fp->argc : 0) +
            script->nfixed;
 }
 
 bool
 js_RecordTree(JSContext* cx, JSTraceMonitor* tm, Fragment* f)
 {
     /* Make sure the global type map didn't change on us. */
-    uint32 globalShape = OBJ_SCOPE(JS_GetGlobalForObject(cx, cx->fp->scopeChain))->shape;
+    uint32 globalShape = OBJ_SHAPE(JS_GetGlobalForObject(cx, cx->fp->scopeChain));
     if (tm->globalShape != globalShape) {
         debug_only_v(printf("Global shape mismatch (%u vs. %u) in RecordTree, flushing cache.\n",
                           globalShape, tm->globalShape);)
         js_FlushJITCache(cx);
         return false;
     }
     TypeMap current;
     current.captureGlobalTypes(cx, *tm->globalSlots);
@@ -2228,21 +2282,21 @@ js_ExecuteTree(JSContext* cx, Fragment**
     double* global = (double*)alloca((globalFrameSize+1) * sizeof(double));
     debug_only(*(uint64*)&global[globalFrameSize] = 0xdeadbeefdeadbeefLL;)
     double* stack = (double*)alloca(MAX_NATIVE_STACK_SLOTS * sizeof(double));
 
     /* If any of our trees uses globals, the shape of the global object must not change and
        the global type map must remain applicable at all times (we expect absolute type 
        stability for globals). */
     if (ngslots &&
-        (OBJ_SCOPE(globalObj)->shape != tm->globalShape || 
+        (OBJ_SHAPE(globalObj) != tm->globalShape || 
          !BuildNativeGlobalFrame(cx, ngslots, gslots, tm->globalTypeMap->data(), global))) {
         AUDIT(globalShapeMismatchAtEntry);
         debug_only_v(printf("Global shape mismatch (%u vs. %u), flushing cache.\n",
-                            OBJ_SCOPE(globalObj)->shape, tm->globalShape);)
+                            OBJ_SHAPE(globalObj), tm->globalShape);)
         const void* ip = f->ip;
         js_FlushJITCache(cx);
         *treep = tm->fragmento->newLoop(ip);
         return NULL;
     }
 
     if (!BuildNativeStackFrame(cx, 0/*callDepth*/, ti->stackTypeMap.data(), stack)) {
         AUDIT(typeMapMismatchAtEntry);
@@ -2269,17 +2323,17 @@ js_ExecuteTree(JSContext* cx, Fragment**
     state.cx = cx;
 #ifdef DEBUG
     state.nestedExit = NULL;
 #endif    
     union { NIns *code; GuardRecord* (FASTCALL *func)(InterpState*, Fragment*); } u;
     u.code = f->code();
 
 #ifdef DEBUG
-#if defined(NANOJIT_IA32)
+#if defined(NANOJIT_IA32) || (defined(NANOJIT_AMD64) && defined(__GNUC__))
     uint64 start = rdtsc();
 #endif
 #endif
 
     /*
      * We may be called from js_MonitorLoopEdge while not recording, or while
      * recording. Rather than over-generalize by using a counter instead of a
      * flag, we simply sample and update tm->onTrace if necessary.
@@ -2307,24 +2361,25 @@ js_ExecuteTree(JSContext* cx, Fragment**
            we restore below doesn't contain such frames. */
         do {
             if (innermostNestedGuardp)
                 *innermostNestedGuardp = lr;
             debug_only_v(printf("processing tree call guard %p, calldepth=%d\n",
                                 lr, lr->calldepth);)
             unsigned calldepth = lr->calldepth;
             if (calldepth > 0) {
-                /* We found a nesting guard that holds a frame, write it back. */
+                /* We found a nesting guard that holds one or more frames to
+                   reconstruct. */
                 for (unsigned i = 0; i < calldepth; ++i)
                     js_SynthesizeFrame(cx, callstack[i]);
                 /* Restore the native stack excluding the current frame, which the next tree
                    call guard or the innermost tree exit guard will restore. */
                 slots = FlushNativeStackFrame(cx, calldepth,
                                               lr->exit->typeMap + lr->exit->numGlobalSlots,
-                                              stack, &cx->fp->argv[-2]);
+                                              stack, cx->fp);
                 if (slots < 0)
                     return NULL;
                 callstack += calldepth;
                 inlineCallCount += calldepth;
                 stack += slots;
             }
             JS_ASSERT(lr->guard->oprnd1()->oprnd2()->isconstp());
             lr = (GuardRecord*)lr->guard->oprnd1()->oprnd2()->constvalp();
@@ -2354,20 +2409,20 @@ js_ExecuteTree(JSContext* cx, Fragment**
 
     /* If we are not exiting from an inlined frame the state->sp is spbase, otherwise spbase
        is whatever slots frames around us consume. */
     fp->regs->pc = (jsbytecode*)lr->from->root->ip + e->ip_adj;
     fp->regs->sp = StackBase(fp) + (e->sp_adj / sizeof(double)) - calldepth_slots;
     JS_ASSERT(fp->slots + fp->script->nfixed +
               js_ReconstructStackDepth(cx, fp->script, fp->regs->pc) == fp->regs->sp);
 
-#if defined(DEBUG) && defined(NANOJIT_IA32)
+#if defined(DEBUG) && (defined(NANOJIT_IA32) || (defined(NANOJIT_AMD64) && defined(__GNUC__)))
     uint64 cycles = rdtsc() - start;
-#else
-    debug_only_v(uint64 cycles = 0;)
+#elif defined(DEBUG)
+    uint64 cycles = 0;
 #endif
 
     debug_only_v(printf("leaving trace at %s:%u@%u, op=%s, lr=%p, exitType=%d, sp=%d, ip=%p, "
                         "cycles=%llu\n",
                         fp->script->filename, js_PCToLineNumber(cx, fp->script, fp->regs->pc),
                         fp->regs->pc - fp->script->code,
                         js_CodeName[*fp->regs->pc],
                         lr,
@@ -2466,37 +2521,52 @@ js_MonitorLoopEdge(JSContext* cx, jsbyte
         return false;
     default:
         /* No, this was an unusual exit (i.e. out of memory/GC), so just resume interpretation. */
         return false;
     }
 }
 
 bool
-js_MonitorRecording(JSContext* cx)
-{
-    TraceRecorder *tr = JS_TRACE_MONITOR(cx).recorder;
+js_MonitorRecording(TraceRecorder* tr)
+{
+    JSContext* cx = tr->cx;
+
+    // Clear one-shot flag used to communicate between record_JSOP_CALL and record_EnterFrame.
+    tr->applyingArguments = false;
+
+    // Process deepAbort() requests now.
     if (tr->wasDeepAborted()) {
         js_AbortRecording(cx, NULL, "deep abort requested");
         return false;
     }
 
     jsbytecode* pc = cx->fp->regs->pc;
+
     /* If we hit a break, end the loop and generate an always taken loop exit guard. For other
        downward gotos (like if/else) continue recording. */
-    if ((*pc == JSOP_GOTO) || (*pc == JSOP_GOTOX)) {
+    if (*pc == JSOP_GOTO || *pc == JSOP_GOTOX) {
         jssrcnote* sn = js_GetSrcNote(cx->fp->script, pc);
-        if ((sn != NULL) && (SN_TYPE(sn) == SRC_BREAK)) {
+        if (sn && SN_TYPE(sn) == SRC_BREAK) {
             AUDIT(breakLoopExits);
             tr->endLoop(JS_TRACE_MONITOR(cx).fragmento);
             js_DeleteRecorder(cx);
             return false; /* done recording */
         }
     }
-    /* If its not a break, continue recording and follow the trace. */
+
+    /* An explicit return from callDepth 0 should end the loop, not abort it. */
+    if (*pc == JSOP_RETURN && tr->callDepth == 0) {
+        AUDIT(returnLoopExits);
+        tr->endLoop(JS_TRACE_MONITOR(cx).fragmento);
+        js_DeleteRecorder(cx);
+        return false; /* done recording */
+    }
+
+    /* If it's not a break or a return from a loop, continue recording and follow the trace. */
     return true;
 }
 
 void
 js_AbortRecording(JSContext* cx, jsbytecode* abortpc, const char* reason)
 {
     JSTraceMonitor* tm = &JS_TRACE_MONITOR(cx);
     JS_ASSERT(tm->recorder != NULL);
@@ -2533,18 +2603,27 @@ js_CheckForSSE2()
     }
 #elif defined __GNUC__
     asm("pusha\n"
         "mov $0x01, %%eax\n"
         "cpuid\n"
         "mov %%edx, %0\n"
         "popa\n"
         : "=m" (features)
+        /* We have no inputs */
+        /* We don't clobber anything */
+       );
+#elif defined __SUNPRO_C || defined __SUNPRO_CC
+    asm("push %%ebx\n"
+        "mov $0x01, %%eax\n"
+        "cpuid\n"
+        "pop %%ebx\n"
+        : "=d" (features)
         : /* We have no inputs */
-        : /* We don't clobber anything */
+        : "%eax", "%ecx"
        );
 #endif
     return (features & (1<<26)) != 0;
 }
 #endif
 
 extern void
 js_InitJIT(JSTraceMonitor *tm)
@@ -2572,20 +2651,20 @@ js_InitJIT(JSTraceMonitor *tm)
 }
 
 extern void
 js_FinishJIT(JSTraceMonitor *tm)
 {
 #ifdef DEBUG
     printf("recorder: started(%llu), aborted(%llu), completed(%llu), different header(%llu), "
            "trees trashed(%llu), slot promoted(%llu), unstable loop variable(%llu), "
-           "breaks: (%llu)\n",
-           stat.recorderStarted, stat.recorderAborted,
-           stat.traceCompleted, stat.returnToDifferentLoopHeader, stat.treesTrashed,
-           stat.slotPromoted, stat.unstableLoopVariable, stat.breakLoopExits);
+           "breaks(%llu), returns(%llu)\n",
+           stat.recorderStarted, stat.recorderAborted, stat.traceCompleted,
+           stat.returnToDifferentLoopHeader, stat.treesTrashed, stat.slotPromoted,
+           stat.unstableLoopVariable, stat.breakLoopExits, stat.returnLoopExits);
     printf("monitor: triggered(%llu), exits(%llu), type mismatch(%llu), "
            "global mismatch(%llu)\n", stat.traceTriggered, stat.sideExitIntoInterpreter,
            stat.typeMapMismatchAtEntry, stat.globalShapeMismatchAtEntry);
 #endif
     if (tm->fragmento != NULL) {
         JS_ASSERT(tm->globalSlots && tm->globalTypeMap);
         verbose_only(delete tm->fragmento->labels;)
         delete tm->fragmento;
@@ -2621,17 +2700,17 @@ js_FlushJITCache(JSContext* cx)
 #ifdef DEBUG
         JS_ASSERT(fragmento->labels);
         delete fragmento->labels;
         fragmento->labels = new (&gc) LabelMap(core, NULL);
 #endif
     }
     memset(&tm->fcache, 0, sizeof(tm->fcache));
     if (cx->fp) {
-        tm->globalShape = OBJ_SCOPE(JS_GetGlobalForObject(cx, cx->fp->scopeChain))->shape;
+        tm->globalShape = OBJ_SHAPE(JS_GetGlobalForObject(cx, cx->fp->scopeChain));
         tm->globalSlots->clear();
         tm->globalTypeMap->clear();
     }
 }
 
 void
 js_ShutDownJIT()
 {
@@ -2783,19 +2862,27 @@ TraceRecorder::ifop()
               lir->ins_eq0(lir->ins2i(LIR_eq, get(&v), 1)),
               BRANCH_EXIT);
     } else if (JSVAL_IS_OBJECT(v)) {
         guard(JSVAL_IS_NULL(v), lir->ins_eq0(get(&v)), BRANCH_EXIT);
     } else if (isNumber(v)) {
         jsdouble d = asNumber(v);
         jsdpun u;
         u.d = 0;
-        guard(d == 0 || JSDOUBLE_IS_NaN(d),
-              lir->ins2(LIR_feq, get(&v), lir->insImmq(u.u64)),
-              BRANCH_EXIT);
+        LIns* v_ins = get(&v);
+
+        // Only insert the guard if the condition is not constant, since in 
+        // that case at runtime we would always take the same path as the
+        // interpreter is taking right now and hence there is no need for
+        // a guard.        
+        if (!v_ins->isconst() && !v_ins->isconstq()) {
+            guard(d == 0 || JSDOUBLE_IS_NaN(d),
+                  lir->ins2(LIR_feq, v_ins, lir->insImmq(u.u64)),
+                  BRANCH_EXIT);
+        }
     } else if (JSVAL_IS_STRING(v)) {
         guard(JSSTRING_LENGTH(JSVAL_TO_STRING(v)) == 0,
               lir->ins_eq0(lir->ins2(LIR_piand,
                                      lir->insLoad(LIR_ldp, 
                                                   get(&v), 
                                                   (int)offsetof(JSString, length)),
                                      INS_CONSTPTR(JSSTRING_LENGTH_MASK))),
               BRANCH_EXIT);
@@ -2917,19 +3004,22 @@ bool
 bool
 TraceRecorder::cmp(LOpcode op, int flags)
 {
     jsval& r = stackval(-1);
     jsval& l = stackval(-2);
     LIns* x;
     bool negate = !!(flags & CMP_NEGATE);
     bool cond;
+    LIns* l_ins = get(&l);
+    LIns* r_ins = get(&r);
+
     if (JSVAL_IS_STRING(l) && JSVAL_IS_STRING(r)) {
         JS_ASSERT(!negate);
-        LIns* args[] = { get(&r), get(&l) };
+        LIns* args[] = { r_ins, l_ins };
         x = lir->ins1(LIR_i2f, lir->insCall(F_CompareStrings, args));
         x = lir->ins2i(op, x, 0);
         jsint result = js_CompareStrings(JSVAL_TO_STRING(l), JSVAL_TO_STRING(r));
         switch (op) {
           case LIR_flt:
             cond = result < 0;
             break;
           case LIR_fgt:
@@ -2945,18 +3035,16 @@ TraceRecorder::cmp(LOpcode op, int flags
             JS_NOT_REACHED("unexpected comparison op for strings");
             return false;
         }
     } else if (isNumber(l) || isNumber(r)) {
         jsval tmp[2] = {l, r};
         JSAutoTempValueRooter tvr(cx, 2, tmp);
 
         // TODO: coerce non-numbers to numbers if it's not string-on-string above
-        LIns* l_ins = get(&l);
-        LIns* r_ins = get(&r);
         jsdouble lnum;
         jsdouble rnum;
         LIns* args[] = { l_ins, cx_ins };
         if (JSVAL_IS_STRING(l)) {
             l_ins = lir->insCall(F_StringToNumber, args);
         } else if (JSVAL_TAG(l) == JSVAL_BOOLEAN) {
             /*
              * What I really want here is for undefined to be type-specialized
@@ -2966,17 +3054,17 @@ TraceRecorder::cmp(LOpcode op, int flags
              * without cmov.  Failing that, eat flaming builtin!
              */
             l_ins = lir->insCall(F_BooleanToNumber, args);
         } else if (!isNumber(l)) {
             ABORT_TRACE("unsupported LHS type for cmp vs number");
         }
         lnum = js_ValueToNumber(cx, &tmp[0]);
 
-        args[0] = get(&r);
+        args[0] = r_ins;
         args[1] = cx_ins;
         if (JSVAL_IS_STRING(r)) {
             r_ins = lir->insCall(F_StringToNumber, args);
         } else if (JSVAL_TAG(r) == JSVAL_BOOLEAN) {
             // See above for the sob story.
             r_ins = lir->insCall(F_BooleanToNumber, args);
         } else if (!isNumber(r)) {
             ABORT_TRACE("unsupported RHS type for cmp vs number");
@@ -3030,25 +3118,31 @@ TraceRecorder::cmp(LOpcode op, int flags
             JS_ASSERT(op == LIR_feq);
             cond = (l == r) ^ negate;
             break;
         }
     } else {
         ABORT_TRACE("unsupported operand types for cmp");
     }
 
-    if (flags & CMP_CASE) {
-        guard(cond, x, BRANCH_EXIT);
-        return true;
-    }
-
-    /* The interpreter fuses comparisons and the following branch,
-       so we have to do that here as well. */
-    if (flags & CMP_TRY_BRANCH_AFTER_COND) 
-        fuseIf(cx->fp->regs->pc + 1, cond, x);
+    /* Don't guard if the same path is always taken. */
+    if (!(isAnyConst(r_ins) && isAnyConst(l_ins))) {
+        if (flags & CMP_CASE) {
+            guard(cond, x, BRANCH_EXIT);
+            return true;
+        }
+
+        /* The interpreter fuses comparisons and the following branch,
+           so we have to do that here as well. */
+        if (flags & CMP_TRY_BRANCH_AFTER_COND) {
+            fuseIf(cx->fp->regs->pc + 1, cond, x);
+        }
+    } else if (flags & CMP_CASE) {
+        return true;
+    }
 
     /* We update the stack after the guard. This is safe since
        the guard bails out at the comparison and the interpreter
        will therefore re-execute the comparison. This way the
        value of the condition doesn't have to be calculated and
        saved on the stack in most cases. */
     set(&l, x);
     return true;
@@ -3058,56 +3152,72 @@ TraceRecorder::cmp(LOpcode op, int flags
 // JSOP_NE we ever evolve to handle conversions then we must insist on like
 // "types" here (care required for 0 == -1, e.g.).
 bool
 TraceRecorder::equal(int flags)
 {
     jsval& r = stackval(-1);
     jsval& l = stackval(-2);
     bool negate = !!(flags & CMP_NEGATE);
+
+    LIns* r_ins = get(&r);
+    LIns* l_ins = get(&l);
+
     if (JSVAL_IS_STRING(l) && JSVAL_IS_STRING(r)) {
-        LIns* args[] = { get(&r), get(&l) };
+        LIns* args[] = { r_ins, l_ins };
         bool cond = js_EqualStrings(JSVAL_TO_STRING(l), JSVAL_TO_STRING(r)) ^ negate;
         LIns* x = lir->ins_eq0(lir->insCall(F_EqualStrings, args));
         if (!negate)
             x = lir->ins_eq0(x);
 
-        if (flags & CMP_CASE) {
-            guard(cond, x, BRANCH_EXIT);
-            return true;
-        }
-
-        /* The interpreter fuses comparisons and the following branch,
-           so we have to do that here as well. */
-        if (flags & CMP_TRY_BRANCH_AFTER_COND)
-            fuseIf(cx->fp->regs->pc + 1, cond, x);
+        /* Don't guard if the same path is always taken. */
+        if (!(isAnyConst(r_ins) && isAnyConst(l_ins))) {
+            if (flags & CMP_CASE) {
+                guard(cond, x, BRANCH_EXIT);
+                return true;
+            }
+
+            /* The interpreter fuses comparisons and the following branch,
+               so we have to do that here as well. */
+            if (flags & CMP_TRY_BRANCH_AFTER_COND) {
+                fuseIf(cx->fp->regs->pc + 1, cond, x);
+            }
+        } else if (flags & CMP_CASE) {
+            return true;
+        }
 
         /* We update the stack after the guard. This is safe since
            the guard bails out at the comparison and the interpreter
            will therefore re-execute the comparison. This way the
            value of the condition doesn't have to be calculated and
            saved on the stack in most cases. */
         set(&l, x);
         return true;
     }
     if (JSVAL_IS_OBJECT(l) && JSVAL_IS_OBJECT(r)) {
         bool cond = (l == r) ^ negate;
-        LIns* x = lir->ins2(LIR_eq, get(&l), get(&r));
+        LIns* x = lir->ins2(LIR_eq, l_ins, r_ins);
         if (negate)
             x = lir->ins_eq0(x);
 
-        if (flags & CMP_CASE) {
-            guard(cond, x, BRANCH_EXIT);
-            return true;
-        }
-
-        /* The interpreter fuses comparisons and the following branch,
-           so we have to do that here as well. */
-        if (flags & CMP_TRY_BRANCH_AFTER_COND)
-            fuseIf(cx->fp->regs->pc + 1, cond, x);
+        /* Don't guard if the same path is always taken. */
+        if (!(isAnyConst(r_ins) && isAnyConst(l_ins))) {
+            if (flags & CMP_CASE) {
+                guard(cond, x, BRANCH_EXIT);
+                return true;
+            }
+
+            /* The interpreter fuses comparisons and the following branch,
+               so we have to do that here as well. */
+            if (flags & CMP_TRY_BRANCH_AFTER_COND) {
+                fuseIf(cx->fp->regs->pc + 1, cond, x);
+            }
+        } else if (flags & CMP_CASE) {
+            return true;
+        }
 
         /* We update the stack after the guard. This is safe since
            the guard bails out at the comparison and the interpreter
            will therefore re-execute the comparison. This way the
            value of the condition doesn't have to be calculated and
            saved on the stack in most cases. */
         set(&l, x);
         return true;
@@ -3192,16 +3302,19 @@ TraceRecorder::map_is_native(JSObjectMap
 
 #undef OP
     ABORT_TRACE("non-native map");
 }
 
 bool
 TraceRecorder::test_property_cache(JSObject* obj, LIns* obj_ins, JSObject*& obj2, jsuword& pcval)
 {
+    jsbytecode* pc = cx->fp->regs->pc;
+    JS_ASSERT(*pc != JSOP_INITPROP && *pc != JSOP_SETNAME && *pc != JSOP_SETPROP);
+
     // Mimic the interpreter's special case for dense arrays by skipping up one
     // hop along the proto chain when accessing a named (not indexed) property,
     // typically to find Array.prototype methods.
     JSObject* aobj = obj;
     if (OBJ_IS_DENSE_ARRAY(cx, obj)) {
         aobj = OBJ_GET_PROTO(cx, obj);
         obj_ins = stobj_get_fslot(obj_ins, JSSLOT_PROTO);
     }
@@ -3213,72 +3326,66 @@ TraceRecorder::test_property_cache(JSObj
     // (newObjectMap == js_ObjectOps.newObjectMap) which is required to use
     // native objects (those whose maps are scopes), or even more narrow
     // conditions required because the cache miss case will call a particular
     // object-op (js_GetProperty, js_SetProperty).
     //
     // We parameterize using offsetof and guard on match against the hook at
     // the given offset in js_ObjectOps. TraceRecorder::record_JSOP_SETPROP
     // guards the js_SetProperty case.
-    uint32 format = js_CodeSpec[*cx->fp->regs->pc].format;
+    uint32 format = js_CodeSpec[*pc].format;
     uint32 mode = JOF_MODE(format);
-    size_t op_offset = 0;
-    if (mode == JOF_PROP || mode == JOF_VARPROP) {
-        JS_ASSERT(!(format & JOF_SET));
-        op_offset = offsetof(JSObjectOps, getProperty);
-    } else {
-        JS_ASSERT(mode == JOF_NAME);
-    }
-
-    if (!map_is_native(aobj->map, map_ins, ops_ins, op_offset))
-        return false;
+
+    // No need to guard native-ness of global object.
+    JS_ASSERT(OBJ_IS_NATIVE(globalObj));
+    if (aobj != globalObj) {
+        size_t op_offset = 0;
+        if (mode == JOF_PROP || mode == JOF_VARPROP) {
+            JS_ASSERT(!(format & JOF_SET));
+            op_offset = offsetof(JSObjectOps, getProperty);
+        } else {
+            JS_ASSERT(mode == JOF_NAME);
+        }
+
+        if (!map_is_native(aobj->map, map_ins, ops_ins, op_offset))
+            return false;
+    }
 
     JSAtom* atom;
     JSPropCacheEntry* entry;
-    PROPERTY_CACHE_TEST(cx, cx->fp->regs->pc, aobj, obj2, entry, atom);
+    PROPERTY_CACHE_TEST(cx, pc, aobj, obj2, entry, atom);
     if (atom) {
         // Miss: pre-fill the cache for the interpreter, as well as for our needs.
         // FIXME: 452357 - correctly propagate exceptions into the interpreter from
         // js_FindPropertyHelper, js_LookupPropertyWithFlags, and elsewhere.
         jsid id = ATOM_TO_JSID(atom);
         JSProperty* prop;
-        if (JOF_OPMODE(*cx->fp->regs->pc) == JOF_NAME) {
+        if (JOF_OPMODE(*pc) == JOF_NAME) {
             JS_ASSERT(aobj == obj);
             if (js_FindPropertyHelper(cx, id, &obj, &obj2, &prop, &entry) < 0)
                 ABORT_TRACE("failed to find name");
         } else {
             int protoIndex = js_LookupPropertyWithFlags(cx, aobj, id, 0, &obj2, &prop);
             if (protoIndex < 0)
                 ABORT_TRACE("failed to lookup property");
 
             if (prop) {
-                js_FillPropertyCache(cx, aobj, OBJ_SCOPE(aobj)->shape, 0, protoIndex, obj2,
+                js_FillPropertyCache(cx, aobj, OBJ_SHAPE(aobj), 0, protoIndex, obj2,
                                      (JSScopeProperty*) prop, &entry);
             }
         }
 
         if (!prop) {
             // Propagate obj from js_FindPropertyHelper to record_JSOP_BINDNAME
             // via our obj2 out-parameter. If we are recording JSOP_SETNAME and
             // the global it's assigning does not yet exist, create it.
             obj2 = obj;
-            if (JSOp(*cx->fp->regs->pc) == JSOP_SETNAME) {
-                jsval v = JSVAL_VOID;
-                if (!js_SetPropertyHelper(cx, obj, id, &v, &entry))
-                    return false;
-                if (!entry || !PCVAL_IS_SPROP(entry->vword))
-                    ABORT_TRACE("can't create cacheable global for JSOP_SETNAME");
-                JSScopeProperty* sprop = PCVAL_TO_SPROP(entry->vword);
-                if (!SPROP_HAS_VALID_SLOT(sprop, OBJ_SCOPE(obj)))
-                    ABORT_TRACE("can't create slot-ful global for JSOP_SETNAME");
-                pcval = SLOT_TO_PCVAL(sprop->slot);
-            } else {
-                // Use PCVAL_NULL to return "no such property" to our caller.
-                pcval = PCVAL_NULL;
-            }
+
+            // Use PCVAL_NULL to return "no such property" to our caller.
+            pcval = PCVAL_NULL;
             return true;
         }
 
         OBJ_DROP_PROPERTY(cx, obj2, prop);
         if (!entry)
             ABORT_TRACE("failed to fill property cache");
     }
 
@@ -3297,35 +3404,35 @@ TraceRecorder::test_property_cache(JSObj
         if (aobj != globalObj) {
             LIns* shape_ins = addName(lir->insLoad(LIR_ld, map_ins, offsetof(JSScope, shape)),
                                       "shape");
             guard(true, addName(lir->ins2i(LIR_eq, shape_ins, entry->kshape), "guard(kshape)"),
                   MISMATCH_EXIT);
         }
     } else {
 #ifdef DEBUG
-        JSOp op = JSOp(*cx->fp->regs->pc);
+        JSOp op = JSOp(*pc);
         ptrdiff_t pcoff = (op == JSOP_GETARGPROP) ? ARGNO_LEN :
                           (op == JSOP_GETLOCALPROP) ? SLOTNO_LEN : 0;
-        jsatomid index = js_GetIndexFromBytecode(cx, cx->fp->script, cx->fp->regs->pc, pcoff);
+        jsatomid index = js_GetIndexFromBytecode(cx, cx->fp->script, pc, pcoff);
         JS_ASSERT(entry->kpc == (jsbytecode*) atoms[index]);
         JS_ASSERT(entry->kshape == jsuword(aobj));
 #endif
         if (aobj != globalObj) {
             guard(true, addName(lir->ins2i(LIR_eq, obj_ins, entry->kshape), "guard(kobj)"),
                   MISMATCH_EXIT);
         }
     }
 
     // For any hit that goes up the scope and or proto chains, we will need to
     // guard on the shape of the object containing the property.
     if (PCVCAP_TAG(entry->vcap) >= 1) {
         jsuword vcap = entry->vcap;
         uint32 vshape = PCVCAP_SHAPE(vcap);
-        JS_ASSERT(OBJ_SCOPE(obj2)->shape == vshape);
+        JS_ASSERT(OBJ_SHAPE(obj2) == vshape);
 
         LIns* obj2_ins = INS_CONSTPTR(obj2);
         map_ins = lir->insLoad(LIR_ldp, obj2_ins, (int)offsetof(JSObject, map));
         if (!map_is_native(obj2->map, map_ins, ops_ins))
             return false;
 
         LIns* shape_ins = addName(lir->insLoad(LIR_ld, map_ins, offsetof(JSScope, shape)),
                                   "shape");
@@ -3352,17 +3459,17 @@ TraceRecorder::test_property_cache_direc
         return false;
 
     /* No such property means invalid slot, which callers must check for first. */
     if (PCVAL_IS_NULL(pcval)) {
         slot = SPROP_INVALID_SLOT;
         return true;
     }
 
-    /* Insist if setting on obj being the directly addressed object. */
+    /* If modifying the slot, insist on obj being the directly addressed object. */
     uint32 setflags = (js_CodeSpec[*cx->fp->regs->pc].format & (JOF_SET | JOF_INCDEC));
     if (setflags && obj2 != obj)
         ABORT_TRACE("JOF_SET opcode hit prototype chain");
 
     /* Don't trace getter or setter calls, our caller wants a direct slot. */
     if (PCVAL_IS_SPROP(pcval)) {
         JSScopeProperty* sprop = PCVAL_TO_SPROP(pcval);
 
@@ -3526,17 +3633,17 @@ TraceRecorder::getThis(LIns*& this_ins)
 }
 
 bool
 TraceRecorder::guardClass(JSObject* obj, LIns* obj_ins, JSClass* clasp)
 {
     if (STOBJ_GET_CLASS(obj) != clasp)
         return false;
 
-    LIns* class_ins = stobj_get_fslot(obj_ins, JSSLOT_CLASS);
+    LIns* class_ins = lir->insLoad(LIR_ldp, obj_ins, offsetof(JSObject, classword));
     class_ins = lir->ins2(LIR_piand, class_ins, lir->insImm(~3));
 
     char namebuf[32];
     JS_snprintf(namebuf, sizeof namebuf, "guard(class is %s)", clasp->name);
     guard(true, addName(lir->ins2(LIR_eq, class_ins, INS_CONSTPTR(clasp)), namebuf),
           MISMATCH_EXIT);
     return true;
 }
@@ -3561,17 +3668,17 @@ TraceRecorder::guardDenseArrayIndex(JSOb
     guard(true, lir->ins2i(LIR_ge, idx_ins, 0), MISMATCH_EXIT);
 
     // guard(index < length)
     guard(true, lir->ins2(LIR_lt, idx_ins, length_ins), MISMATCH_EXIT);
 
     // guard(index < capacity)
     guard(false, lir->ins_eq0(dslots_ins), MISMATCH_EXIT);
     guard(true,
-          lir->ins2(LIR_lt, idx_ins, lir->insLoad(LIR_ldp, dslots_ins, 0 - sizeof(jsval))),
+          lir->ins2(LIR_lt, idx_ins, lir->insLoad(LIR_ldp, dslots_ins, 0 - (int)sizeof(jsval))),
           MISMATCH_EXIT);
     return true;
 }
 
 void
 TraceRecorder::clearFrameSlotsFromCache()
 {
     /* Clear out all slots of this frame in the nativeFrameTracker. Different locations on the
@@ -3591,30 +3698,44 @@ TraceRecorder::clearFrameSlotsFromCache(
     vpstop = &fp->slots[fp->script->nslots];
     while (vp < vpstop)
         nativeFrameTracker.set(vp++, (LIns*)0);
 }
 
 bool
 TraceRecorder::record_EnterFrame()
 {
+    JSStackFrame* fp = cx->fp;
+
     if (++callDepth >= MAX_CALLDEPTH)
         ABORT_TRACE("exceeded maximum call depth");
+    if (fp->script == fp->down->script)
+        ABORT_TRACE("recursive call");
+    
     debug_only_v(printf("EnterFrame %s, callDepth=%d\n",
                         js_AtomToPrintableString(cx, cx->fp->fun->atom),
                         callDepth););
-    JSStackFrame* fp = cx->fp;
     LIns* void_ins = INS_CONST(JSVAL_TO_BOOLEAN(JSVAL_VOID));
 
     jsval* vp = &fp->argv[fp->argc];
     jsval* vpstop = vp + (fp->fun->nargs - fp->argc);
-    while (vp < vpstop) {
-        if (vp >= fp->down->regs->sp)
+    if (applyingArguments) {
+        applyingArguments = false;
+        while (vp < vpstop) {
+            JS_ASSERT(vp >= fp->down->regs->sp);
             nativeFrameTracker.set(vp, (LIns*)0);
-        set(vp++, void_ins, true);
+            LIns* arg_ins = get(&fp->down->argv[fp->argc + (vp - vpstop)]);
+            set(vp++, arg_ins, true);
+        }
+    } else {
+        while (vp < vpstop) {
+            if (vp >= fp->down->regs->sp)
+                nativeFrameTracker.set(vp, (LIns*)0);
+            set(vp++, void_ins, true);
+        }
     }
 
     vp = &fp->slots[0];
     vpstop = vp + fp->script->nfixed;
     while (vp < vpstop)
         set(vp++, void_ins, true);
     return true;
 }
@@ -3699,17 +3820,21 @@ TraceRecorder::record_JSOP_IFNE()
 TraceRecorder::record_JSOP_IFNE()
 {
     return ifop();
 }
 
 bool
 TraceRecorder::record_JSOP_ARGUMENTS()
 {
-    return false;
+    LIns* args[] = { cx_ins };
+    LIns* a_ins = lir->insCall(F_Arguments, args);
+    guard(false, lir->ins_eq0(a_ins), OOM_EXIT);
+    stack(0, a_ins);
+    return true;
 }
 
 bool
 TraceRecorder::record_JSOP_DUP()
 {
     stack(0, get(&stackval(-1)));
     return true;
 }
@@ -3858,18 +3983,25 @@ TraceRecorder::record_JSOP_MOD()
     }
     return false;
 }
 
 bool
 TraceRecorder::record_JSOP_NOT()
 {
     jsval& v = stackval(-1);
-    if (JSVAL_IS_BOOLEAN(v) || JSVAL_IS_OBJECT(v)) {
-        set(&v, lir->ins_eq0(get(&v)));
+    if (JSVAL_TAG(v) == JSVAL_BOOLEAN) {
+        set(&v, lir->ins_eq0(lir->ins2i(LIR_eq, get(&v), 1)));
+        return true;
+    }
+    if (JSVAL_IS_INT(v) || JSVAL_IS_OBJECT(v)) {
+        LIns* a = get(&v);
+        if (JSVAL_IS_INT(v) && isPromoteInt(a))
+            a = ::demote(lir, a);
+        set(&v, lir->ins_eq0(a));
         return true;
     }
     return false;
 }
 
 bool
 TraceRecorder::record_JSOP_BITNOT()
 {
@@ -4245,69 +4377,89 @@ TraceRecorder::record_JSOP_GETPROP()
 TraceRecorder::record_JSOP_GETPROP()
 {
     return getProp(stackval(-1));
 }
 
 bool
 TraceRecorder::record_JSOP_SETPROP()
 {
-    jsval& r = stackval(-1);
-    jsval& l = stackval(-2);
-
+    jsval& l = stackval(-2);
     if (JSVAL_IS_PRIMITIVE(l))
         ABORT_TRACE("primitive this for SETPROP");
 
     JSObject* obj = JSVAL_TO_OBJECT(l);
-
     if (obj->map->ops->setProperty != js_SetProperty)
         ABORT_TRACE("non-native JSObjectOps::setProperty");
-
+    return true;
+}
+
+bool
+TraceRecorder::record_SetPropHit(uint32 kshape, JSScopeProperty* sprop)
+{
+    jsbytecode* pc = cx->fp->regs->pc;
+    jsval& r = stackval(-1);
+    jsval& l = stackval(-2);
+
+    JS_ASSERT(!JSVAL_IS_PRIMITIVE(l));
+    JSObject* obj = JSVAL_TO_OBJECT(l);
     LIns* obj_ins = get(&l);
 
-    JSPropertyCache* cache = &JS_PROPERTY_CACHE(cx);
-    uint32 kshape = OBJ_SCOPE(obj)->shape;
-    jsbytecode* pc = cx->fp->regs->pc;
-
-    JSPropCacheEntry* entry = &cache->table[PROPERTY_CACHE_HASH_PC(pc, kshape)];
-    if (entry->kpc != pc || entry->kshape != kshape)
-        ABORT_TRACE("cache miss");
-    if (!PCVAL_IS_SPROP(entry->vword))
-        ABORT_TRACE("hit non-sprop cache value");
-
+    if (obj == globalObj) {
+        JS_ASSERT(SPROP_HAS_VALID_SLOT(sprop, OBJ_SCOPE(obj)));
+        uint32 slot = sprop->slot;
+        if (!lazilyImportGlobalSlot(slot))
+            ABORT_TRACE("lazy import of global slot failed");
+
+        LIns* r_ins = get(&r);
+        set(&STOBJ_GET_SLOT(obj, slot), r_ins);
+
+        JS_ASSERT(*pc != JSOP_INITPROP);
+        if (pc[JSOP_SETPROP_LENGTH] != JSOP_POP)
+            set(&l, r_ins);
+        return true;
+    }
+
+    // The global object's shape is guarded at trace entry, all others need a guard here.
     LIns* map_ins = lir->insLoad(LIR_ldp, obj_ins, (int)offsetof(JSObject, map));
     LIns* ops_ins;
     if (!map_is_native(obj->map, map_ins, ops_ins, offsetof(JSObjectOps, setProperty)))
         return false;
 
-    // The global object's shape is guarded at trace entry.
-    if (obj != globalObj) {
-        LIns* shape_ins = addName(lir->insLoad(LIR_ld, map_ins, offsetof(JSScope, shape)), "shape");
-        guard(true, addName(lir->ins2i(LIR_eq, shape_ins, kshape), "guard(shape)"),
-                MISMATCH_EXIT);
-    }
+    LIns* shape_ins = addName(lir->insLoad(LIR_ld, map_ins, offsetof(JSScope, shape)), "shape");
+    guard(true, addName(lir->ins2i(LIR_eq, shape_ins, kshape), "guard(shape)"), MISMATCH_EXIT);
 
     JSScope* scope = OBJ_SCOPE(obj);
-    JSScopeProperty* sprop = PCVAL_TO_SPROP(entry->vword);
     if (scope->object != obj || !SCOPE_HAS_PROPERTY(scope, sprop)) {
         LIns* args[] = { INS_CONSTPTR(sprop), obj_ins, cx_ins };
         LIns* ok_ins = lir->insCall(F_AddProperty, args);
         guard(false, lir->ins_eq0(ok_ins), MISMATCH_EXIT);
     }
 
     LIns* dslots_ins = NULL;
     LIns* v_ins = get(&r);
     LIns* boxed_ins = v_ins;
     if (!box_jsval(r, boxed_ins))
         return false;
     if (!native_set(obj_ins, sprop, dslots_ins, boxed_ins))
         return false;
-    if (*pc == JSOP_SETPROP && pc[JSOP_SETPROP_LENGTH] != JSOP_POP)
-        stack(-2, v_ins);
-    return true;
+
+    if (*pc != JSOP_INITPROP && pc[JSOP_SETPROP_LENGTH] != JSOP_POP)
+        set(&l, v_ins);
+    return true;
+}
+
+bool
+TraceRecorder::record_SetPropMiss(JSPropCacheEntry* entry)
+{
+    if (!entry->kpc)
+        ABORT_TRACE("can't trace uncacheable property set");
+
+    JS_ASSERT(PCVAL_IS_SPROP(entry->vword));
+    return record_SetPropHit(entry->kshape, PCVAL_TO_SPROP(entry->vword));
 }
 
 bool
 TraceRecorder::record_JSOP_GETELEM()
 {
     jsval& r = stackval(-1);
     jsval& l = stackval(-2);
 
@@ -4457,27 +4609,43 @@ TraceRecorder::guardShapelessCallee(jsva
                   "guard(shapeless callee)"),
           MISMATCH_EXIT);
     return true;
 }
 
 bool
 TraceRecorder::interpretedFunctionCall(jsval& fval, JSFunction* fun, uintN argc)
 {
+    if (JS_GetGlobalForObject(cx, JSVAL_TO_OBJECT(fval)) != globalObj)
+        ABORT_TRACE("JSOP_CALL or JSOP_NEW crosses global scopes");
+
     JSStackFrame* fp = cx->fp;
 
     // TODO: track the copying via the tracker...
     if (argc < fun->nargs &&
         jsuword(fp->regs->sp + (fun->nargs - argc)) > cx->stackPool.current->limit) {
         ABORT_TRACE("can't trace calls with too few args requiring argv move");
     }
 
+    // Generate a type map for the outgoing frame and stash it in the LIR
+    unsigned stackSlots = js_NativeStackSlots(cx, 0/*callDepth*/);
+    LIns* data = lir_buf_writer->skip(stackSlots * sizeof(uint8));
+    uint8* typemap = (uint8 *)data->payload();
+    uint8* m = typemap;
+    /* Determine the type of a store by looking at the current type of the actual value the
+       interpreter is using. For numbers we have to check what kind of store we used last
+       (integer or double) to figure out what the side exit show reflect in its typemap. */
+    FORALL_SLOTS_IN_PENDING_FRAMES(cx, 0/*callDepth*/,
+        *m++ = determineSlotType(vp);
+    );
+    
     FrameInfo fi = {
         JSVAL_TO_OBJECT(fval),
         fp->regs->pc,
+        typemap,
         { { fp->regs->sp - fp->slots, argc } }
     };
 
     unsigned callDepth = getCallDepth();
     if (callDepth >= treeInfo->maxCallDepth)
         treeInfo->maxCallDepth = callDepth + 1;
 
     lir->insStorei(INS_CONSTPTR(fi.callee), lirbuf->rp,
@@ -4492,34 +4660,37 @@ TraceRecorder::interpretedFunctionCall(j
 }
 
 #define KNOWN_NATIVE_DECL(name) JSBool name(JSContext* cx, uintN argc, jsval* vp);
 
 KNOWN_NATIVE_DECL(js_fun_apply)
 KNOWN_NATIVE_DECL(js_math_ceil)
 KNOWN_NATIVE_DECL(js_math_cos)
 KNOWN_NATIVE_DECL(js_math_floor)
+KNOWN_NATIVE_DECL(js_math_log)
+KNOWN_NATIVE_DECL(js_math_max)
 KNOWN_NATIVE_DECL(js_math_pow)
 KNOWN_NATIVE_DECL(js_math_random)
 KNOWN_NATIVE_DECL(js_math_sin)
 KNOWN_NATIVE_DECL(js_math_sqrt)
 KNOWN_NATIVE_DECL(js_num_toString)
 KNOWN_NATIVE_DECL(js_str_charAt)
 KNOWN_NATIVE_DECL(js_str_charCodeAt)
 KNOWN_NATIVE_DECL(js_str_concat)
 KNOWN_NATIVE_DECL(js_str_fromCharCode)
 KNOWN_NATIVE_DECL(js_str_substring)
 
 bool
 TraceRecorder::record_JSOP_CALL()
 {
-    jsbytecode *pc = cx->fp->regs->pc;
+    JSStackFrame* fp = cx->fp;
+    jsbytecode *pc = fp->regs->pc;
     uintN argc = GET_ARGC(pc);
     jsval& fval = stackval(0 - (argc + 2));
-    JS_ASSERT(&fval >= StackBase(cx->fp));
+    JS_ASSERT(&fval >= StackBase(fp));
 
     jsval& tval = stackval(0 - (argc + 1));
     LIns* this_ins = get(&tval);
     if (this_ins->isconstp() && !this_ins->constvalp() && !guardShapelessCallee(fval))
         return false;
 
     /*
      * Require that the callee be a function object, to avoid guarding on its
@@ -4545,17 +4716,20 @@ TraceRecorder::record_JSOP_CALL()
         { js_array_join,               F_Array_p_join,         "TC",  "s",    FAIL_NULL },
         { js_math_sin,                 F_Math_sin,             "",    "d",    INFALLIBLE },
         { js_math_cos,                 F_Math_cos,             "",    "d",    INFALLIBLE },
         { js_math_pow,                 F_Math_pow,             "",    "dd",   INFALLIBLE },
         { js_math_sqrt,                F_Math_sqrt,            "",    "d",    INFALLIBLE },
         { js_math_floor,               F_Math_floor,           "",    "d",    INFALLIBLE },
         { js_math_ceil,                F_Math_ceil,            "",    "d",    INFALLIBLE },
         { js_math_random,              F_Math_random,          "R",    "",    INFALLIBLE },
+        { js_math_log,                 F_Math_log,             "",    "d",    INFALLIBLE },
+        { js_math_max,                 F_Math_max,             "",    "dd",   INFALLIBLE },
         { js_num_parseInt,             F_ParseInt,             "C",   "s",    INFALLIBLE },
+        { js_num_parseInt,             F_ParseIntDouble,       "",    "d",    INFALLIBLE },
         { js_num_parseFloat,           F_ParseFloat,           "C",   "s",    INFALLIBLE },
         { js_num_toString,             F_NumberToString,       "TC",   "",    FAIL_NULL },
         { js_obj_hasOwnProperty,       F_Object_p_hasOwnProperty,
                                                                "TC",  "s",    FAIL_VOID },
         { js_obj_propertyIsEnumerable, F_Object_p_propertyIsEnumerable,
                                                                "TC",  "s",    FAIL_VOID },
         { js_str_charAt,               F_String_getelem,       "TC",  "i",    FAIL_NULL },
         { js_str_charCodeAt,           F_String_p_charCodeAt,  "T",   "i",    FAIL_NEG },
@@ -4575,39 +4749,76 @@ TraceRecorder::record_JSOP_CALL()
     uintN i = 0;
     LIns* arg1_ins = NULL;
     jsval arg1 = JSVAL_VOID;
 
     if ((JSFastNative)fun->u.n.native == js_fun_apply) {
         if (argc != 2)
             ABORT_TRACE("can't trace Function.prototype.apply with other than 2 args");
 
+        if (!guardShapelessCallee(tval))
+            return false;
+        JSObject* tfunobj = JSVAL_TO_OBJECT(tval);
+        JSFunction* tfun = GET_FUNCTION_PRIVATE(cx, tfunobj);
+
         jsval& oval = stackval(-2);
         if (JSVAL_IS_PRIMITIVE(oval))
             ABORT_TRACE("can't trace Function.prototype.apply with primitive 1st arg");
 
         jsval& aval = stackval(-1);
         if (JSVAL_IS_PRIMITIVE(aval))
             ABORT_TRACE("can't trace Function.prototype.apply with primitive 2nd arg");
+        JSObject* aobj = JSVAL_TO_OBJECT(aval);
 
         LIns* aval_ins = get(&aval);
-        if (!aval_ins->isCall() || aval_ins->fid() != F_Array_1str)
-            ABORT_TRACE("can't yet trace Function.prototype.apply on other than [str] 2nd arg");
-
-        JSObject* aobj = JSVAL_TO_OBJECT(aval);
+        if (!aval_ins->isCall())
+            ABORT_TRACE("can't trace Function.prototype.apply on non-builtin-call 2nd arg");
+
+        if (aval_ins->fid() == F_Arguments) {
+            JS_ASSERT(OBJ_GET_CLASS(cx, aobj) == &js_ArgumentsClass);
+            JS_ASSERT(OBJ_GET_PRIVATE(cx, aobj) == fp);
+            if (!FUN_INTERPRETED(tfun))
+                ABORT_TRACE("can't trace Function.prototype.apply(native_function, arguments)");
+
+            argc = fp->argc;
+            if (tfun->nargs != argc)
+                ABORT_TRACE("can't trace Function.prototype.apply(scripted_function, arguments)");
+
+            jsval* sp = fp->regs->sp - 4;
+            set(sp, get(&tval));
+            *sp++ = tval;
+            set(sp, get(&oval));
+            *sp++ = oval;
+            jsval* newsp = sp + argc;
+            if (newsp > fp->slots + fp->script->nslots) {
+                JSArena* a = cx->stackPool.current;
+                if (jsuword(newsp) > a->limit)
+                    ABORT_TRACE("can't grow stack for Function.prototype.apply");
+                if (jsuword(newsp) > a->avail)
+                    a->avail = jsuword(newsp);
+            }
+
+            jsval* argv = fp->argv;
+            for (uintN i = 0; i < JS_MIN(argc, 2); i++) {
+                set(&sp[i], get(&argv[i]));
+                sp[i] = argv[i];
+            }
+            applyingArguments = true;
+            return interpretedFunctionCall(tval, tfun, argc);
+        }
+
+        if (aval_ins->fid() != F_Array_1str)
+            ABORT_TRACE("can't trace Function.prototype.apply on other than [str] 2nd arg");
+
         JS_ASSERT(OBJ_IS_ARRAY(cx, aobj));
         JS_ASSERT(aobj->fslots[JSSLOT_ARRAY_LENGTH] == 1);
         JS_ASSERT(JSVAL_IS_STRING(aobj->dslots[0]));
 
-        if (!guardShapelessCallee(tval))
-            return false;
-        JSObject* tfunobj = JSVAL_TO_OBJECT(tval);
-        JSFunction* tfun = GET_FUNCTION_PRIVATE(cx, tfunobj);
         if (FUN_INTERPRETED(tfun))
-            ABORT_TRACE("can't yet trace Function.prototype.apply for scripted functions");
+            ABORT_TRACE("can't trace Function.prototype.apply for scripted functions");
 
         JSTraceableNative* known;
         for (;;) {
             known = &knownNatives[i];
             if (known->native == (JSFastNative)tfun->u.n.native)
                 break;
             if (++i == JS_ARRAY_LENGTH(knownNatives))
                 ABORT_TRACE("unknown native being Function.prototype.apply'ed");
@@ -4864,17 +5075,17 @@ TraceRecorder::prop(JSObject* obj, LIns*
         ABORT_TRACE("unboxing");
     return true;
 }
 
 bool
 TraceRecorder::elem(jsval& l, jsval& r, jsval*& vp, LIns*& v_ins, LIns*& addr_ins)
 {
     /* no guards for type checks, trace specialized this already */
-    if (!JSVAL_IS_INT(r) || JSVAL_IS_PRIMITIVE(l))
+    if (JSVAL_IS_PRIMITIVE(l) || !JSVAL_IS_INT(r))
         return false;
 
     /*
      * Can't specialize to assert obj != global, must guard to avoid aliasing
      * stale homes of stacked global variables.
      */
     JSObject* obj = JSVAL_TO_OBJECT(l);
     if (obj == globalObj)
@@ -4899,17 +5110,24 @@ TraceRecorder::elem(jsval& l, jsval& r, 
         return false;
     vp = &obj->dslots[idx];
 
     addr_ins = lir->ins2(LIR_piadd, dslots_ins,
                          lir->ins2i(LIR_pilsh, idx_ins, (sizeof(jsval) == 4) ? 2 : 3));
 
     /* load the value, check the type (need to check JSVAL_HOLE only for booleans) */
     v_ins = lir->insLoad(LIR_ldp, addr_ins, 0);
-    return unbox_jsval(*vp, v_ins);
+    if (!unbox_jsval(*vp, v_ins))
+        return false;
+    if (JSVAL_TAG(*vp) == JSVAL_BOOLEAN) {
+        // Check to make sure *vp isn't a hole.
+        LIns* cins = lir->ins2(LIR_eq, v_ins, lir->insImm(JSVAL_TO_BOOLEAN(JSVAL_HOLE)));
+        v_ins = lir->ins_choose(cins, lir->insImm(2), v_ins, true);
+    }
+    return v_ins;
 }
 
 bool
 TraceRecorder::getProp(JSObject* obj, LIns* obj_ins)
 {
     uint32 slot;
     LIns* v_ins;
     if (!prop(obj, obj_ins, slot, v_ins))
@@ -5037,22 +5255,16 @@ TraceRecorder::record_JSOP_STRICTEQ()
 {
     return equal();
 }
 
 bool
 TraceRecorder::record_JSOP_STRICTNE()
 {
     return equal(CMP_NEGATE);
-}
-
-bool
-TraceRecorder::record_JSOP_CLOSURE()
-{
-    return false;
 }
 
 bool
 TraceRecorder::record_JSOP_OBJECT()
 {
     JSStackFrame* fp = cx->fp;
     JSScript* script = fp->script;
     unsigned index = atoms - script->atomMap.vector + GET_INDEX(fp->regs->pc);
@@ -5159,18 +5371,18 @@ TraceRecorder::record_JSOP_ENDINIT()
         }
     }
     return true;
 }
 
 bool
 TraceRecorder::record_JSOP_INITPROP()
 {
-    // The common code avoids stacking the RHS if op is not JSOP_SETPROP.
-    return record_JSOP_SETPROP();
+    // All the action is in record_SetPropHit.
+    return true;
 }
 
 bool
 TraceRecorder::record_JSOP_INITELEM()
 {
     return record_JSOP_SETELEM();
 }
 
@@ -5248,30 +5460,29 @@ TraceRecorder::record_JSOP_ITER()
     }
 
     ABORT_TRACE("for-in on a primitive value");
 }
 
 bool
 TraceRecorder::forInLoop(jsval* vp)
 {
-    if (!JSVAL_IS_STRING(*vp))
-        ABORT_TRACE("for-in loop variable changed type from string");
     jsval& iterobj_val = stackval(-1);
     if (!JSVAL_IS_PRIMITIVE(iterobj_val)) {
         LIns* args[] = { get(&iterobj_val), cx_ins };
         LIns* v_ins = lir->insCall(F_FastCallIteratorNext, args);
         guard(false, lir->ins2(LIR_eq, v_ins, INS_CONST(JSVAL_ERROR_COOKIE)), OOM_EXIT);
 
         LIns* flag_ins = lir->ins_eq0(lir->ins2(LIR_eq, v_ins, INS_CONST(JSVAL_HOLE)));
         LIns* iter_ins = get(vp);
-        if (!box_jsval(JSVAL_STRING, iter_ins))
+        jsval expected = JSVAL_IS_VOID(*vp) ? JSVAL_STRING : JSVAL_TAG(*vp);
+        if (!box_jsval(expected, iter_ins))
             return false;
         iter_ins = lir->ins_choose(flag_ins, v_ins, iter_ins, true);
-        if (!unbox_jsval(JSVAL_STRING, iter_ins))
+        if (!unbox_jsval(expected, iter_ins))
             return false;
         set(vp, iter_ins);
         stack(0, flag_ins);
         return true;
     }
 
     ABORT_TRACE("for-in on a primitive value");
 }
@@ -5345,36 +5556,28 @@ TraceRecorder::record_JSOP_BINDNAME()
 
     stack(0, obj_ins);
     return true;
 }
 
 bool
 TraceRecorder::record_JSOP_SETNAME()
 {
-    jsval& r = stackval(-1);
     jsval& l = stackval(-2);
     JS_ASSERT(!JSVAL_IS_PRIMITIVE(l));
 
     /*
      * Trace cases that are global code or in lightweight functions scoped by
      * the global object only.
      */
     JSObject* obj = JSVAL_TO_OBJECT(l);
     if (obj != cx->fp->scopeChain || obj != globalObj)
-        return false;
-
-    jsval* vp;
-    if (!name(vp))
-        return false;
-    LIns* r_ins = get(&r);
-    set(vp, r_ins);
-
-    if (cx->fp->regs->pc[JSOP_SETNAME_LENGTH] != JSOP_POP)
-        stack(-2, r_ins);
+        ABORT_TRACE("JSOP_SETNAME left operand is not the global object");
+
+    // The rest of the work is in record_SetPropHit.
     return true;
 }
 
 bool
 TraceRecorder::record_JSOP_THROW()
 {
     return false;
 }
@@ -5622,23 +5825,37 @@ TraceRecorder::record_JSOP_NOP()
 TraceRecorder::record_JSOP_NOP()
 {
     return true;
 }
 
 bool
 TraceRecorder::record_JSOP_ARGSUB()
 {
-    return false;
+    JSStackFrame* fp = cx->fp;
+    if (!(fp->fun->flags & JSFUN_HEAVYWEIGHT)) {
+        uintN slot = GET_ARGNO(fp->regs->pc);
+        if (slot < fp->argc && !fp->argsobj) {
+            stack(0, get(&cx->fp->argv[slot]));
+            return true;
+        }
+    }
+    ABORT_TRACE("can't trace JSOP_ARGSUB hard case");
 }
 
 bool
 TraceRecorder::record_JSOP_ARGCNT()
 {
-    return false;
+    if (!(cx->fp->fun->flags & JSFUN_HEAVYWEIGHT)) {
+        jsdpun u;
+        u.d = cx->fp->argc;
+        stack(0, lir->insImmq(u.u64));
+        return true;
+    }
+    ABORT_TRACE("can't trace heavyweight JSOP_ARGCNT");
 }
 
 bool
 TraceRecorder::record_JSOP_DEFLOCALFUN()
 {
     JSFunction* fun;
     JSFrameRegs& regs = *cx->fp->regs;
     JSScript* script = cx->fp->script;
@@ -6036,16 +6253,22 @@ TraceRecorder::record_JSOP_CALLPROP()
     JSObject* obj2;
     jsuword pcval;
     if (!test_property_cache(obj, obj_ins, obj2, pcval))
         return false;
 
     if (PCVAL_IS_NULL(pcval) || !PCVAL_IS_OBJECT(pcval))
         ABORT_TRACE("callee is not an object");
     JS_ASSERT(HAS_FUNCTION_CLASS(PCVAL_TO_OBJECT(pcval)));
+
+    if (JSVAL_IS_PRIMITIVE(l)) {
+        JSFunction* fun = GET_FUNCTION_PRIVATE(cx, PCVAL_TO_OBJECT(pcval));
+        if (!PRIMITIVE_THIS_TEST(fun, l))
+            ABORT_TRACE("callee does not accept primitive |this|");
+    }
 
     stack(-1, INS_CONSTPTR(PCVAL_TO_OBJECT(pcval)));
     return true;
 }
 
 bool
 TraceRecorder::record_JSOP_DELDESC()
 {
@@ -6339,16 +6562,17 @@ TraceRecorder::record_JSOP_HOLE()
 TraceRecorder::record_JSOP_HOLE()
 {
     stack(0, INS_CONST(JSVAL_TO_BOOLEAN(JSVAL_HOLE)));
     return true;
 }
 
 #define UNUSED(op) bool TraceRecorder::record_##op() { return false; }
 
+UNUSED(JSOP_UNUSED74)
 UNUSED(JSOP_UNUSED76)
 UNUSED(JSOP_UNUSED77)
 UNUSED(JSOP_UNUSED78)
 UNUSED(JSOP_UNUSED79)
 UNUSED(JSOP_UNUSED201)
 UNUSED(JSOP_UNUSED202)
 UNUSED(JSOP_UNUSED203)
 UNUSED(JSOP_UNUSED204)
diff -r b7bcdd009540 js/src/jstracer.h
--- a/js/src/jstracer.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/jstracer.h	Thu Sep 11 15:19:25 2008 +0300
@@ -227,18 +227,19 @@ class TraceRecorder {
 #endif
     nanojit::LIns*          cx_ins;
     nanojit::LIns*          gp_ins;
     nanojit::LIns*          eos_ins;
     nanojit::LIns*          eor_ins;
     nanojit::LIns*          rval_ins;
     nanojit::LIns*          inner_sp_ins;
     nanojit::SideExit       exit;
+    bool                    deepAborted;
+    bool                    applyingArguments;
     bool                    trashTree;
-    bool                    deepAborted;
     nanojit::Fragment*      whichTreeToTrash;
     Queue<jsbytecode*>      inlinedLoopEdges;
     Queue<jsbytecode*>      cfgMerges;
 
     bool isGlobal(jsval* p) const;
     ptrdiff_t nativeGlobalOffset(jsval* p) const;
     ptrdiff_t nativeStackOffset(jsval* p) const;
     void import(nanojit::LIns* base, ptrdiff_t offset, jsval* p, uint8& t, 
@@ -247,17 +248,17 @@ class TraceRecorder {
                 uint8* globalTypeMap, uint8* stackTypeMap);
     void trackNativeStackUse(unsigned slots);
 
     bool lazilyImportGlobalSlot(unsigned slot);
 
     nanojit::LIns* guard(bool expected, nanojit::LIns* cond, nanojit::ExitType exitType);
     nanojit::LIns* addName(nanojit::LIns* ins, const char* name);
 
-    nanojit::LIns* get(jsval* p);
+    nanojit::LIns* get(jsval* p) const;
     nanojit::LIns* writeBack(nanojit::LIns* i, nanojit::LIns* base, ptrdiff_t offset);
     void set(jsval* p, nanojit::LIns* l, bool initializing = false);
 
     bool checkType(jsval& v, uint8 type, bool& recompile);
     bool verifyTypeStability();
 
     jsval& argval(unsigned n) const;
     jsval& varval(unsigned n) const;
@@ -326,67 +327,92 @@ class TraceRecorder {
                               nanojit::LIns* dslots_ins, nanojit::LIns* idx_ins);
     void clearFrameSlotsFromCache();
     bool guardShapelessCallee(jsval& callee);
     bool interpretedFunctionCall(jsval& fval, JSFunction* fun, uintN argc);
     bool forInLoop(jsval* vp);
 
     void trackCfgMerges(jsbytecode* pc);
     void fuseIf(jsbytecode* pc, bool cond, nanojit::LIns* x);
+
 public:
+    friend bool js_MonitorRecording(TraceRecorder* tr);
+
     TraceRecorder(JSContext* cx, nanojit::GuardRecord*, nanojit::Fragment*, TreeInfo*,
             unsigned ngslots, uint8* globalTypeMap, uint8* stackTypeMap, 
             nanojit::GuardRecord* expectedInnerExit);
     ~TraceRecorder();
 
+    uint8 determineSlotType(jsval* vp) const;
     nanojit::SideExit* snapshot(nanojit::ExitType exitType);
     nanojit::Fragment* getFragment() const { return fragment; }
     bool isLoopHeader(JSContext* cx) const;
     void compile(nanojit::Fragmento* fragmento);
     void closeLoop(nanojit::Fragmento* fragmento);
     void endLoop(nanojit::Fragmento* fragmento);
     void blacklist() { fragment->blacklist(); }
     bool adjustCallerTypes(nanojit::Fragment* f);
     bool selectCallablePeerFragment(nanojit::Fragment** first);
     void prepareTreeCall(nanojit::Fragment* inner);
     void emitTreeCall(nanojit::Fragment* inner, nanojit::GuardRecord* lr);
     unsigned getCallDepth() const;
     bool trackLoopEdges();
     
     bool record_EnterFrame();
     bool record_LeaveFrame();
+    bool record_SetPropHit(uint32 kshape, JSScopeProperty* sprop);
+    bool record_SetPropMiss(JSPropCacheEntry* entry);
 
     void deepAbort() { deepAborted = true; }
     bool wasDeepAborted() { return deepAborted; }
 
 #define OPDEF(op,val,name,token,length,nuses,ndefs,prec,format)               \
     bool record_##op();
 # include "jsopcode.tbl"
 #undef OPDEF
 };
 
 #define TRACING_ENABLED(cx)       JS_HAS_OPTION(cx, JSOPTION_JIT)
+#define TRACE_RECORDER(cx)        (JS_TRACE_MONITOR(cx).recorder)
+#define SET_TRACE_RECORDER(cx,tr) (JS_TRACE_MONITOR(cx).recorder = (tr))
 
-#define RECORD(x)                                                             \
+// See jsinterp.cpp for the ENABLE_TRACER definition.
+#define RECORD_ARGS(x,args)                                                   \
     JS_BEGIN_MACRO                                                            \
-        TraceRecorder* r = JS_TRACE_MONITOR(cx).recorder;                     \
-        if (!js_MonitorRecording(cx)) {                                       \
+        TraceRecorder* tr_ = TRACE_RECORDER(cx);                              \
+        if (!js_MonitorRecording(tr_))                                        \
             ENABLE_TRACER(0);                                                 \
-        } else                                                                \
-        if (!r->record_##x()) {                                               \
+        else                                                                  \
+            TRACE_ARGS_(tr_,x,args);                                          \
+    JS_END_MACRO
+
+#define TRACE_ARGS_(tr,x,args)                                                \
+    JS_BEGIN_MACRO                                                            \
+        if (!tr->record_##x args) {                                           \
             js_AbortRecording(cx, NULL, #x);                                  \
             ENABLE_TRACER(0);                                                 \
         }                                                                     \
     JS_END_MACRO
 
+#define TRACE_ARGS(x,args)                                                    \
+    JS_BEGIN_MACRO                                                            \
+        TraceRecorder* tr_ = TRACE_RECORDER(cx);                              \
+        if (tr_)                                                              \
+            TRACE_ARGS_(tr_, x, args);                                        \
+    JS_END_MACRO
+
+#define RECORD(x)               RECORD_ARGS(x, ())
+#define TRACE_1(x,a)            TRACE_ARGS(x, (a))
+#define TRACE_2(x,a,b)          TRACE_ARGS(x, (a, b))
+
 extern bool
 js_MonitorLoopEdge(JSContext* cx, jsbytecode* oldpc, uintN& inlineCallCount);
 
 extern bool
-js_MonitorRecording(JSContext* cx);
+js_MonitorRecording(TraceRecorder *tr);
 
 extern void
 js_AbortRecording(JSContext* cx, jsbytecode* abortpc, const char* reason);
 
 extern void
 js_InitJIT(JSTraceMonitor *tm);
 
 extern void
diff -r b7bcdd009540 js/src/jsxdrapi.cpp
--- a/js/src/jsxdrapi.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/jsxdrapi.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -565,17 +565,17 @@ XDRValueBody(JSXDRState *xdr, uint32 typ
       }
       case JSVAL_BOOLEAN: {
         uint32 b;
         if (xdr->mode == JSXDR_ENCODE)
             b = (uint32) JSVAL_TO_BOOLEAN(*vp);
         if (!JS_XDRUint32(xdr, &b))
             return JS_FALSE;
         if (xdr->mode == JSXDR_DECODE)
-            *vp = BOOLEAN_TO_JSVAL((JSBool) b);
+            *vp = BOOLEAN_TO_JSVAL(!!b);
         break;
       }
       default: {
         uint32 i;
 
         JS_ASSERT(type & JSVAL_INT);
         if (xdr->mode == JSXDR_ENCODE)
             i = (uint32) JSVAL_TO_INT(*vp);
diff -r b7bcdd009540 js/src/jsxdrapi.h
--- a/js/src/jsxdrapi.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/jsxdrapi.h	Thu Sep 11 15:19:25 2008 +0300
@@ -199,17 +199,17 @@ JS_XDRFindClassById(JSXDRState *xdr, uin
  * Bytecode version number. Increment the subtrahend whenever JS bytecode
  * changes incompatibly.
  *
  * This version number should be XDR'ed once near the front of any file or
  * larger storage unit containing XDR'ed bytecode and other data, and checked
  * before deserialization of bytecode.  If the saved version does not match
  * the current version, abort deserialization and invalidate the file.
  */
-#define JSXDR_BYTECODE_VERSION      (0xb973c0de - 30)
+#define JSXDR_BYTECODE_VERSION      (0xb973c0de - 31)
 
 /*
  * Library-private functions.
  */
 extern JSBool
 js_XDRAtom(JSXDRState *xdr, JSAtom **atomp);
 
 extern JSBool
diff -r b7bcdd009540 js/src/jsxml.cpp
--- a/js/src/jsxml.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/jsxml.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -62,16 +62,17 @@
 #include "jsobj.h"
 #include "jsopcode.h"
 #include "jsparse.h"
 #include "jsscan.h"
 #include "jsscope.h"
 #include "jsscript.h"
 #include "jsstr.h"
 #include "jsxml.h"
+#include "jsstaticcheck.h"
 
 #ifdef DEBUG
 #include <string.h>     /* for #ifdef DEBUG memset calls */
 #endif
 
 /*
  * NOTES
  * - in the js shell, you must use the -x command line option, or call
@@ -1882,17 +1883,17 @@ ParseXMLSource(JSContext *cx, JSString *
             lineno = js_PCToLineNumber(cx, fp->script, fp->regs->pc);
             for (endp = srcp + srclen; srcp < endp; srcp++) {
                 if (*srcp == '\n')
                     --lineno;
             }
         }
     }
 
-    if (!js_InitParseContext(cx, &pc, NULL, chars, length, NULL,
+    if (!js_InitParseContext(cx, &pc, NULL, NULL, chars, length, NULL,
                              filename, lineno))
         goto out;
     pn = js_ParseXMLText(cx, cx->fp->scopeChain, &pc, JS_FALSE);
     if (pn && XMLArrayInit(cx, &nsarray, 1)) {
         if (GetXMLSettingFlags(cx, &flags))
             xml = ParseNodeToXML(cx, &pc, pn, &nsarray, flags);
 
         XMLArrayFinish(cx, &nsarray);
@@ -4083,20 +4084,20 @@ PutProperty(JSContext *cx, JSObject *obj
     /* Precompute vxml for 9.2.1.2 2(c)(vii)(2-3) and 2(d) and 9.1.1.2 1. */
     vxml = NULL;
     if (!JSVAL_IS_PRIMITIVE(*vp)) {
         vobj = JSVAL_TO_OBJECT(*vp);
         if (OBJECT_IS_XML(cx, vobj))
             vxml = (JSXML *) JS_GetPrivate(cx, vobj);
     }
 
-    /* Control flow after here must exit via label out. */
     ok = js_EnterLocalRootScope(cx);
     if (!ok)
         return JS_FALSE;
+    MUST_FLOW_THROUGH("out");
     roots[OBJ_ROOT] = OBJECT_TO_JSVAL(obj);
     roots[ID_ROOT] = id;
     roots[VAL_ROOT] = *vp;
     JS_PUSH_TEMP_ROOT(cx, 3, roots, &tvr);
 
     if (js_IdIsIndex(id, &index)) {
         if (xml->xml_class != JSXML_CLASS_LIST) {
             /* See NOTE in spec: this variation is reserved for future use. */
@@ -6258,18 +6259,18 @@ xml_namespace(JSContext *cx, uintN argc,
         prefix = NULL;
     } else {
         prefix = js_ValueToString(cx, vp[2]);
         if (!prefix)
             return JS_FALSE;
         vp[2] = STRING_TO_JSVAL(prefix);      /* local root */
     }
 
-    /* After this point the control must flow through label out. */
     InitTempNSArray(cx, &inScopeNSes);
+    MUST_FLOW_THROUGH("out");
     ok = FindInScopeNamespaces(cx, xml, &inScopeNSes.array);
     if (!ok)
         goto out;
 
     if (!prefix) {
         ns = GetNamespace(cx, xml->name, &inScopeNSes.array);
         if (!ns) {
             ok = JS_FALSE;
@@ -7998,17 +7999,17 @@ js_GetXMLFunction(JSContext *cx, JSObjec
 {
     JSObject *target;
     JSXML *xml;
     JSTempValueRooter tvr;
     JSBool ok;
 
     JS_ASSERT(OBJECT_IS_XML(cx, obj));
 
-    /* After this point, control must flow through label out: to exit. */
+    MUST_FLOW_THROUGH("out");
     JS_PUSH_TEMP_ROOT_OBJECT(cx, NULL, &tvr);
 
     /*
      * See comments before xml_lookupProperty about the need for the proto
      * chain lookup.
      */
     target = obj;
     for (;;) {
diff -r b7bcdd009540 js/src/nanojit/LIR.cpp
--- a/js/src/nanojit/LIR.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/nanojit/LIR.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -1475,41 +1475,45 @@ namespace nanojit
 			printf("%-60s %s\n", livebuf, names->formatIns(e->i));
 			if (e->i->isGuard())
 				printf("\n");
 		}
 	}
 
     LabelMap::Entry::~Entry()
     {
-        delete name;
     }
 
     LirNameMap::Entry::~Entry()
     {
-        delete name;
     }
 
     LirNameMap::~LirNameMap()
     {
         Entry *e;
 
         while ((e = names.removeLast()) != NULL) {
+            labels->core->freeString(e->name);
             delete e;
         }
     }
 
-	void LirNameMap::addName(LInsp i, Stringp name) {
+	bool LirNameMap::addName(LInsp i, Stringp name) {
 		if (!names.containsKey(i)) { 
 			Entry *e = new (labels->core->gc) Entry(name);
 			names.put(i, e);
+            return true;
 		}
+        return false;
 	}
 	void LirNameMap::addName(LInsp i, const char *name) {
-		addName(i, labels->core->newString(name));
+        Stringp new_name = labels->core->newString(name);
+        if (!addName(i, new_name)) {
+            labels->core->freeString(new_name);
+        }
 	}
 
 	void LirNameMap::copyName(LInsp i, const char *s, int suffix) {
 		char s2[200];
 		sprintf(s2,"%s%d", s,suffix);
 		addName(i, labels->core->newString(s2));
 	}
 
@@ -1539,22 +1543,26 @@ namespace nanojit
 			formatImm(uint32_t(ref->constvalq()), buf);
 #endif
 		}
 		else if (ref->isconst()) {
 			formatImm(ref->constval(), buf);
 		}
 		else {
 			if (ref->isCall()) {
+#if !defined NANOJIT_64BIT
 				if (ref->isop(LIR_callh)) {
 					// we've presumably seen the other half already
 					ref = ref->oprnd1();
 				} else {
+#endif
 					copyName(ref, _functions[ref->fid()]._name, funccounts.add(ref->fid()));
+#if !defined NANOJIT_64BIT
 				}
+#endif
 			} else {
                 NanoAssert(ref->opcode() < sizeof(lirNames) / sizeof(lirNames[0]));
 				copyName(ref, lirNames[ref->opcode()], lircounts.add(ref->opcode()));
 			}
 			StringNullTerminatedUTF8 cname(gc, names.get(ref)->name);
 			strcat(buf, cname.c_str());
 		}
 		return labels->dup(buffer);
@@ -1904,16 +1912,17 @@ namespace nanojit
         : parent(parent), names(core->gc), addrs(core->config.verbose_addrs), end(buf), core(core)
 	{}
 
     LabelMap::~LabelMap()
     {
         Entry *e;
         
         while ((e = names.removeLast()) != NULL) {
+            core->freeString(e->name);
             delete e;
         } 
     }
 
     void LabelMap::add(const void *p, size_t size, size_t align, const char *name)
 	{
 		if (!this || names.containsKey(p))
 			return;
diff -r b7bcdd009540 js/src/nanojit/LIR.h
--- a/js/src/nanojit/LIR.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/nanojit/LIR.h	Thu Sep 11 15:19:25 2008 +0300
@@ -176,17 +176,21 @@ namespace nanojit
 			uint32_t		oprnd_3:8;	// only used for store, since this location gets clobbered during generation
 			uint32_t		oprnd_1:8;  // 256 ins window and since they only point backwards this is sufficient.
 			uint32_t		oprnd_2:8;  
 		};
 
         struct sti_type
         {
 			LOpcode			code:8;
+#if defined(__SUNPRO_C) || defined(__SUNPRO_CC)
+			signed int      disp:8;     // Sun Studio requires explicitly declaring signed int bit-field
+#else
 			int32_t	    	disp:8;
+#endif
 			uint32_t		oprnd_1:8;  // 256 ins window and since they only point backwards this is sufficient.
 			uint32_t		oprnd_2:8;  
         };
 
 		// imm8 form 
 		struct c_type
 		{
 			LOpcode			code:8;
@@ -194,25 +198,33 @@ namespace nanojit
 			uint32_t		imm8a:8;
 			uint32_t		imm8b:8;  
 		};
 
         // imm24 form for short tramp & skip
         struct t_type
         {
             LOpcode         code:8;
+#if defined(__SUNPRO_C) || defined(__SUNPRO_CC)
+            signed int      imm24:24;
+#else
             int32_t         imm24:24;
+#endif
         };
 
 		// imm16 form
 		struct i_type
 		{
 			LOpcode			code:8;
 			uint32_t		resv:8;  // cobberred during assembly
+#if defined(__SUNPRO_C) || defined(__SUNPRO_CC)
+			signed int		imm16:16;
+#else
 			int32_t			imm16:16;
+#endif
 		};
 
 		// overlay used during code generation ( note that last byte is reserved for allocation )
 		struct g_type
 		{
 			LOpcode			code:8;
 			uint32_t		resv:8;   // cobberred during assembly
 			uint32_t		unused:16;
@@ -499,17 +511,17 @@ namespace nanojit
 			funccounts(gc),
 			names(gc),
 			_functions(_functions),
 			labels(r)
 		{}
         ~LirNameMap();
 
 		void addName(LInsp i, const char *s);
-		void addName(LInsp i, avmplus::String *s);
+		bool addName(LInsp i, avmplus::String *s);
 		void copyName(LInsp i, const char *s, int suffix);
         const char *formatRef(LIns *ref);
 		const char *formatIns(LInsp i);
 		void formatGuard(LInsp i, char *buf);
 	};
 
 
 	class VerboseWriter : public LirWriter
diff -r b7bcdd009540 js/src/nanojit/NativeAMD64.h
--- a/js/src/nanojit/NativeAMD64.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/nanojit/NativeAMD64.h	Thu Sep 11 15:19:25 2008 +0300
@@ -754,18 +754,17 @@ namespace nanojit
 	} while(0)
 
 
 #define LDi(r,i) do { 											\
 	underrunProtect(6);											\
 	IMM32(i);													\
 	*(--_nIns) = AMD64_MODRM_REG(0, r);							\
 	*(--_nIns) = AMD64_MOV_RM_IMM;								\
-	if (AMD64_NEEDS_REX(r))										\
-		*(--_nIns) = AMD64_REX(0,0,r);							\
+	*(--_nIns) = AMD64_REX(1,0,r);							    \
 	asm_output2("mov %s,%d",gpn(r),i);							\
 	} while (0)
 
 
 #define LDQi(r,i) do {											\
 	underrunProtect(10);										\
 	IMM64(i);													\
 	*(--_nIns) = AMD64_MOV_REG_IMM(r);							\
@@ -1019,17 +1018,17 @@ namespace nanojit
 	asm_output3("movd %s,%d(%s)",gpn(r),(d),gpn(b));			\
 	} while (0)
 
 
 #define SSE_STQ(d,r,b) do {										\
 	underrunProtect(7);											\
 	AMD64_MODRM_DISP(b,r,d);									\
 	AMD64_OP3(AMD64_MOVD_RM_REG,1,b,r);							\
-	asm_output3("movd %s,%d(%s)",gpn(b),(d),gpn(r));			\
+	asm_output3("movd %d(%s),%s",(d),gpn(r),gpn(b));			\
 	} while (0)
 
 
 #define SSE_CVTSI2SD(xr,gr) do{ 								\
 	underrunProtect(5);											\
 	*(--_nIns) = AMD64_MODRM_REG(xr, gr);						\
 	AMD64_OP3(AMD64_CVTSI2SD,0,xr,gr);							\
     asm_output2("cvtsi2sd %s,%s",gpn(xr),gpn(gr)); 				\
diff -r b7bcdd009540 js/src/nanojit/NativeARM.cpp
--- a/js/src/nanojit/NativeARM.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/nanojit/NativeARM.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -197,19 +197,18 @@ Assembler::asm_call(LInsp ins)
         int d = disp(callRes);
         freeRsrcOf(ins, rr != UnknownReg);
 
         if (rr != UnknownReg) {
             NanoAssert(IsFpReg(rr));
             FMDRR(rr,R0,R1);
         } else {
             NanoAssert(d);
-            //fprintf (stderr, "call ins d: %d\n", d);
-            STMIA(Scratch, 1<<R0 | 1<<R1);
-            arm_ADDi(Scratch, FP, d);
+            STR(R0, FP, d+0);
+            STR(R1, FP, d+4);
         }
     }
 #endif
 
     CALL(call);
 
     ArgSize sizes[10];
     uint32_t argc = call->get_sizes(sizes);
@@ -444,20 +443,18 @@ Assembler::asm_load64(LInsp ins)
 #ifdef NJ_ARM_VFP
     Register rb = findRegFor(base, GpRegs);
 
     NanoAssert(rb != UnknownReg);
     NanoAssert(rr == UnknownReg || IsFpReg(rr));
 
     if (rr != UnknownReg) {
         if (!isS8(offset >> 2) || (offset&3) != 0) {
-            underrunProtect(LD32_size + 8);
             FLDD(rr,Scratch,0);
-            ADD(Scratch, rb);
-            LD32_nochk(Scratch, offset);
+            arm_ADDi(Scratch, rb, offset);
         } else {
             FLDD(rr,rb,offset);
         }
     } else {
         asm_mmq(FP, d, rb, offset);
     }
 
     // *(FP+dr) <- *(rb+db)
@@ -472,82 +469,87 @@ Assembler::asm_load64(LInsp ins)
 
 void
 Assembler::asm_store64(LInsp value, int dr, LInsp base)
 {
     //asm_output1("<<< store64 (dr: %d)", dr);
 
 #ifdef NJ_ARM_VFP
     Reservation *valResv = getresv(value);
+    Register rb = findRegFor(base, GpRegs);
 
-    Register rb = findRegFor(base, GpRegs);
+    if (value->isconstq()) {
+        const int32_t* p = (const int32_t*) (value-2);
+
+        STR(Scratch, rb, dr);
+        LD32_nochk(Scratch, p[0]);
+        STR(Scratch, rb, dr+4);
+        LD32_nochk(Scratch, p[1]);
+
+        return;
+    }
+
     Register rv = findRegFor(value, FpRegs);
 
     NanoAssert(rb != UnknownReg);
     NanoAssert(rv != UnknownReg);
 
     Register baseReg = rb;
     intptr_t baseOffset = dr;
 
     if (!isS8(dr)) {
         baseReg = Scratch;
         baseOffset = 0;
     }
 
     FSTD(rv, baseReg, baseOffset);
 
     if (!isS8(dr)) {
-        underrunProtect(4 + LD32_size);
-        ADD(Scratch, rb);
-        LD32_nochk(Scratch, dr);
+        arm_ADDi(Scratch, rb, dr);
     }
 
     // if it's a constant, make sure our baseReg/baseOffset location
     // has the right value
     if (value->isconstq()) {
         const int32_t* p = (const int32_t*) (value-2);
 
-        underrunProtect(12 + LD32_size);
+        underrunProtect(12);
 
         asm_quad_nochk(rv, p);
     }
 #else
     int da = findMemFor(value);
     Register rb = findRegFor(base, GpRegs);
     asm_mmq(rb, dr, FP, da);
 #endif
     //asm_output(">>> store64");
 }
 
 // stick a quad into register rr, where p points to the two
 // 32-bit parts of the quad, optinally also storing at FP+d
 void
 Assembler::asm_quad_nochk(Register rr, const int32_t* p)
 {
-    *(++_nSlot) = p[0];
-    *(++_nSlot) = p[1];
+    // We're not going to use a slot, because it might be too far
+    // away.  Instead, we're going to stick a branch in the stream to
+    // jump over the constants, and then load from a short PC relative
+    // offset.
 
-    intptr_t constAddr = (intptr_t) (_nSlot-1);
-    intptr_t realOffset = PC_OFFSET_FROM(constAddr, _nIns-1);
-    intptr_t offset = realOffset;
-    Register baseReg = PC;
+    // stream should look like:
+    //    branch A
+    //    p[0]
+    //    p[1]
+    // A: FLDD PC-16
 
-    //int32_t *q = (int32_t*) constAddr;
-    //fprintf (stderr, "asm_quad_nochk: rr = %d cAddr: 0x%x quad: %08x:%08x q: %f @0x%08x\n", rr, constAddr, p[0], p[1], *(double*)q, _nIns);
+    FLDD(rr, PC, -16);
 
-    // for FLDD, we only get a left-shifted 8-bit offset
-    if (!isS8(realOffset >> 2)) {
-        offset = 0;
-        baseReg = Scratch;
-    }
+    *(--_nIns) = (NIns) p[1];
+    *(--_nIns) = (NIns) p[0];
 
-    FLDD(rr, baseReg, offset);
-
-    if (!isS8(realOffset >> 2))
-        LD32_nochk(Scratch, constAddr);
+    JMP_nochk(_nIns+2);
 }
 
 void
 Assembler::asm_quad(LInsp ins)
 {
     //asm_output(">>> asm_quad");
 
     Reservation *res = getresv(ins);
@@ -556,31 +558,38 @@ Assembler::asm_quad(LInsp ins)
 
     NanoAssert(d || rr != UnknownReg);
 
     const int32_t* p = (const int32_t*) (ins-2);
 
 #ifdef NJ_ARM_VFP
     freeRsrcOf(ins, false);
 
-    // XXX We probably want nochk versions of FLDD/FSTD
-    underrunProtect(16 + LD32_size);
+    if (rr == UnknownReg) {
+        underrunProtect(12);
 
-    // grab a register to do the load into if we don't have one already;
-    // XXX -- maybe do a mmq in this case?  We're going to use our
-    // D7 register that's never allocated (since it's the one we use
-    // for int-to-double conversions), so we don't have to worry about
-    // spilling something in a fp reg.
-    if (rr == UnknownReg)
-        rr = D7;
+        // asm_mmq might spill a reg, so don't call it;
+        // instead do the equivalent directly.
+        //asm_mmq(FP, d, PC, -16);
 
-    if (d)
-        FSTD(rr, FP, d);
+        STR(Scratch, FP, d+4);
+        LDR(Scratch, PC, -20);
+        STR(Scratch, FP, d);
+        LDR(Scratch, PC, -16);
 
-    asm_quad_nochk(rr, p);
+        *(--_nIns) = (NIns) p[1];
+        *(--_nIns) = (NIns) p[0];
+        JMP_nochk(_nIns+2);
+    } else {
+        if (d)
+            FSTD(rr, FP, d);
+
+        underrunProtect(16);
+        asm_quad_nochk(rr, p);
+    }
 #else
     freeRsrcOf(ins, false);
     if (d) {
         underrunProtect(LD32_size * 2 + 8);
         STR(Scratch, FP, d+4);
         LD32_nochk(Scratch, p[1]);
         STR(Scratch, FP, d);
         LD32_nochk(Scratch, p[0]);
@@ -623,54 +632,60 @@ Assembler::asm_binop_rhs_reg(LInsp ins)
  * copy 64 bits: (rd+dd) <- (rs+ds)
  */
 void
 Assembler::asm_mmq(Register rd, int dd, Register rs, int ds)
 {
     // value is either a 64bit struct or maybe a float
     // that isn't live in an FPU reg.  Either way, don't
     // put it in an FPU reg just to load & store it.
-    // get a scratch reg
+
+    // Don't use this with PC-relative loads; the registerAlloc might
+    // end up spilling a reg (and this the offset could end up being
+    // bogus)!
+    NanoAssert(rs != PC);
+
+    // use both IP and a second scratch reg
     Register t = registerAlloc(GpRegs & ~(rmask(rd)|rmask(rs)));
     _allocator.addFree(t);
-    // XXX use LDM,STM
-    STR(t, rd, dd+4);
-    LDR(t, rs, ds+4);
+
+    // XXX maybe figure out if we can use LDRD/STRD -- hard to
+    // ensure right register allocation
+    STR(Scratch, rd, dd+4);
     STR(t, rd, dd);
+    LDR(Scratch, rs, ds+4);
     LDR(t, rs, ds);
 }
 
 void
 Assembler::asm_pusharg(LInsp arg)
 {
     Reservation* argRes = getresv(arg);
     bool quad = arg->isQuad();
-    intptr_t stack_growth = quad ? 8 : 4;
 
-    Register ra;
+    if (argRes && argRes->reg != UnknownReg) {
+        if (!quad) {
+            STR_preindex(argRes->reg, SP, -4);
+        } else {
+            FSTD(argRes->reg, SP, 0);
+            SUBi(SP, 8);
+        }
+    } else {
+        int d = findMemFor(arg);
 
-    if (argRes)
-        ra = argRes->reg;
-    else
-        ra = findRegFor(arg, quad ? FpRegs : GpRegs);
-
-    if (ra == UnknownReg) {
-        STR(Scratch, SP, 0);
-        LDR(Scratch, FP, disp(argRes));
-    } else {
         if (!quad) {
-            Register ra = findRegFor(arg, GpRegs);
-            STR(ra, SP, 0);
+            STR_preindex(Scratch, SP, -4);
+            LDR(Scratch, FP, d);
         } else {
-            Register ra = findRegFor(arg, FpRegs);
-            FSTD(ra, SP, 0);
+            STR_preindex(Scratch, SP, -4);
+            LDR(Scratch, FP, d+4);
+            STR_preindex(Scratch, SP, -4);
+            LDR(Scratch, FP, d);
         }
     }
-
-    SUBi(SP, stack_growth);
 }
 
 void
 Assembler::nativePageReset()
 {
     _nSlot = 0;
     _nExitSlot = 0;
 }
@@ -813,16 +828,21 @@ Assembler::CALL(const CallInfo *ci)
 
     BL((NIns*)addr);
     asm_output1("   (call %s)", ci->_name);
 }
 
 void
 Assembler::LD32_nochk(Register r, int32_t imm)
 {
+    if (imm == 0) {
+        XOR(r, r);
+        return;
+    }
+
     // We should always reach the const pool, since it's on the same page (<4096);
     // if we can't, someone didn't underrunProtect enough.
 
     *(++_nSlot) = (int)imm;
 
     //fprintf (stderr, "wrote slot(2) %p with %08x, jmp @ %p\n", _nSlot, (intptr_t)imm, _nIns-1);
 
     int offset = PC_OFFSET_FROM(_nSlot,_nIns-1);
@@ -873,16 +893,59 @@ Assembler::B_cond_chk(ConditionCode _c, 
     } else {
         if(_chk) underrunProtect(12);
         *(--_nIns) = (NIns)(_t);
         *(--_nIns) = (NIns)( COND_AL | (0xA<<24) | ((-4)>>2) & 0xFFFFFF );
         *(--_nIns) = (NIns)( ((_c)<<28) | (0x51<<20) | (PC<<16) | (PC<<12) | 0x0 );
     }
 
     asm_output2("%s %p", _c == AL ? "jmp" : "b(cnd)", (void*)(_t));
+}
+
+void
+Assembler::asm_add_imm(Register rd, Register rn, int32_t imm)
+{
+
+    int rot = 16;
+    uint32_t immval;
+    bool pos;
+
+    if (imm >= 0) {
+        immval = (uint32_t) imm;
+        pos = true;
+    } else {
+        immval = (uint32_t) (-imm);
+        pos = false;
+    }
+
+    while (immval && ((immval & 0x3) == 0)) {
+        immval >>= 2;
+        rot--;
+    }
+
+    rot &= 0xf;
+
+    if (immval < 256) {
+        underrunProtect(4);
+        if (pos)
+            *(--_nIns) = (NIns)( COND_AL | OP_IMM | OP_STAT | (1<<23) | (rn<<16) | (rd<<12) | (rot << 8) | immval );
+        else
+            *(--_nIns) = (NIns)( COND_AL | OP_IMM | OP_STAT | (1<<22) | (rn<<16) | (rd<<12) | (rot << 8) | immval );
+        asm_output3("add %s,%s,%d",gpn(rd),gpn(rn),imm);
+    } else {
+        // add scratch to rn, after loading the value into scratch.
+
+        // make sure someone isn't trying to use Scratch as an operand
+        NanoAssert(rn != Scratch);
+
+        *(--_nIns) = (NIns)( COND_AL | OP_STAT | (1<<23) | (rn<<16) | (rd<<12) | (Scratch));
+        asm_output3("add %s,%s,%s",gpn(rd),gpn(rn),gpn(Scratch));
+
+        LD32_nochk(Scratch, imm);
+    }
 }
 
 /*
  * VFP
  */
 
 #ifdef NJ_ARM_VFP
 
diff -r b7bcdd009540 js/src/nanojit/NativeARM.h
--- a/js/src/nanojit/NativeARM.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/nanojit/NativeARM.h	Thu Sep 11 15:19:25 2008 +0300
@@ -178,33 +178,33 @@ static Register nextreg(Register r) {
 // only good for normal regs
 #define imm2register(c) (Register)(c-1)
 
 verbose_only( extern const char* regNames[]; )
 
 // abstract to platform specific calls
 #define nExtractPlatformFlags(x)    0
 
-#define DECLARE_PLATFORM_STATS()                \
-    counter_define(x87Top);
+#define DECLARE_PLATFORM_STATS()
 
 #define DECLARE_PLATFORM_REGALLOC()
 
 #define DECLARE_PLATFORM_ASSEMBLER()                                    \
     const static Register argRegs[4], retRegs[2];                       \
     void LD32_nochk(Register r, int32_t imm);                           \
     void BL(NIns*);                                                     \
     void BL_far(NIns*);                                                 \
     void CALL(const CallInfo*);                                         \
     void B_cond_chk(ConditionCode, NIns*, bool);                        \
     void underrunProtect(int bytes);                                    \
     bool has_cmov;                                                      \
     void nativePageReset();                                             \
     void nativePageSetup();                                             \
     void asm_quad_nochk(Register, const int32_t*);                      \
+    void asm_add_imm(Register, Register, int32_t);                      \
     int* _nSlot;                                                        \
     int* _nExitSlot;
 
 
 #define asm_farg(i) NanoAssert(false)
 
 //printf("jmp_l_n count=%d, nins=%X, %X = %X\n", (_c), nins, _nIns, ((intptr_t)(nins+(_c))-(intptr_t)_nIns - 4) );
 
@@ -303,58 +303,19 @@ typedef enum {
 #define arm_ADD(_d,_n,_m) do {                                          \
         underrunProtect(4);                                             \
         *(--_nIns) = (NIns)( COND_AL | OP_STAT | (1<<23) | ((_n)<<16) | ((_d)<<12) | (_m)); \
         asm_output3("add %s,%s+%s",gpn(_d),gpn(_n),gpn(_m)); } while(0)
 
 // _l = _l + _r
 #define ADD(_l,_r)   arm_ADD(_l,_l,_r)
 
-// TODO: we can do better here, since we can rotate the 8-bit immediate left by
-// an even number of bits; should count zeros at the end.
-
 // Note that this sometimes converts negative immediate values to a to a sub.
 // _d = _r + _imm
-#define arm_ADDi(_d,_n,_imm)   do {                                     \
-        if ((_imm) > -256 && (_imm) < 256) {                            \
-            underrunProtect(4);                                         \
-            if ((_imm)>=0)                                              \
-                *(--_nIns) = (NIns)( COND_AL | OP_IMM | OP_STAT | (1<<23) | ((_n)<<16) | ((_d)<<12) | ((_imm)&0xFF) ); \
-            else                                                        \
-                *(--_nIns) = (NIns)( COND_AL | OP_IMM | OP_STAT | (1<<22) | ((_n)<<16) | ((_d)<<12) | ((-(_imm))&0xFF) ); \
-        } else {                                                        \
-            if ((_imm)>=0) {                                            \
-                if ((_imm)<=1020 && (((_imm)&3)==0) ) {                 \
-                    underrunProtect(4);                                 \
-                    *(--_nIns) = (NIns)( COND_AL | OP_IMM | OP_STAT | (1<<23) | ((_n)<<16) | ((_d)<<12) | (15<<8)| ((_imm)>>2) ); \
-                } else {                                                \
-                    underrunProtect(4+LD32_size);                       \
-                    *(--_nIns) = (NIns)( COND_AL | OP_STAT | (1<<23) | ((_n)<<16) | ((_d)<<12) | (Scratch)); \
-                    LD32_nochk(Scratch, _imm);                          \
-                }                                                       \
-            } else {                                                    \
-                underrunProtect(4+LD32_size);                           \
-                *(--_nIns) = (NIns)( COND_AL | OP_STAT | (1<<22) | ((_n)<<16) | ((_d)<<12) | (Scratch)); \
-                LD32_nochk(Scratch, -(_imm));                           \
-            }                                                           \
-        }                                                               \
-        asm_output3("add %s,%s,%d",gpn(_d),gpn(_n),(_imm));             \
-    } while(0)
-
-/*
- * There used to be a :
-                if ((_imm)>=-510) {                                     \
-                    underrunProtect(8);                                 \
-                    int rem = -(_imm) - 255;                            \
-                    *(--_nIns) = (NIns)( COND_AL | OP_IMM | (1<<22) | ((_n)<<16) | ((_d)<<12) | ((rem)&0xFF) ); \
-                    *(--_nIns) = (NIns)( COND_AL | OP_IMM | (1<<22) | ((_n)<<16) | ((_d)<<12) | (0xFF) ); \
-                } else {                                               
- * above, but if we do that we can't really update the status registers.  So don't do that.
- */
-
+#define arm_ADDi(_d,_n,_imm)   asm_add_imm(_d,_n,_imm)
 #define ADDi(_r,_imm)  arm_ADDi(_r,_r,_imm)
 
 // _l = _l - _r
 #define SUB(_l,_r)  do {                                                \
         underrunProtect(4);                                             \
         *(--_nIns) = (NIns)( COND_AL | (1<<22) | ((_l)<<16) | ((_l)<<12) | (_r)); \
         asm_output2("sub %s,%s",gpn(_l),gpn(_r)); } while(0)
 
@@ -538,36 +499,39 @@ typedef enum {
                 NanoAssert((_off)<4096);                                \
                 *(--_nIns) = (NIns)( COND_AL | (0x59<<20) | ((_b)<<16) | ((_d)<<12) | ((_off)&0xFFF) ); \
             } else {                                                    \
                 if (_chk) underrunProtect(4+LD32_size);                 \
                 *(--_nIns) = (NIns)( COND_AL | (0x79<<20) | ((_b)<<16) | ((_d)<<12) | Scratch ); \
                 LD32_nochk(Scratch, _off);                              \
             }                                                           \
         }                                                               \
-        asm_output3("ldr %s,%d(%s)",gpn((_d)),(_off),gpn((_b)));        \
+        asm_output3("ldr %s, [%s, #%d]",gpn(_d),gpn(_b),(_off));        \
     } while(0)
 
 #define LDR(_d,_b,_off)        LDR_chk(_d,_b,_off,0)
 #define LDR_nochk(_d,_b,_off)  LDR_chk(_d,_b,_off,1)
 
 // i386 compat, for Assembler.cpp
 #define LD(reg,offset,base)    LDR_chk(reg,base,offset,1)
 #define ST(base,offset,reg)    STR(reg,base,offset)
 
 #define LDi(_d,_imm) do {                                               \
-        if (isS8((_imm)) || isU8((_imm))) {                             \
+        if ((_imm) == 0) {                                              \
+            XOR(_d,_d);                                                 \
+        } else if (isS8((_imm)) || isU8((_imm))) {                      \
             underrunProtect(4);                                         \
             if ((_imm)<0)   *(--_nIns) = (NIns)( COND_AL | (0x3E<<20) | ((_d)<<12) | (((_imm)^0xFFFFFFFF)&0xFF) ); \
             else            *(--_nIns) = (NIns)( COND_AL | (0x3B<<20) | ((_d)<<12) | ((_imm)&0xFF) ); \
+            asm_output2("ld  %s,0x%x",gpn((_d)),(_imm));                \
         } else {                                                        \
             underrunProtect(LD32_size);                                 \
             LD32_nochk(_d, (_imm));                                     \
+            asm_output2("ld  %s,0x%x",gpn((_d)),(_imm));                \
         }                                                               \
-        asm_output2("ld  %s,0x%x",gpn((_d)),(_imm));                      \
     } while(0)
 
 
 // load 8-bit, zero extend (aka LDRB)
 // note, only 5-bit offsets (!) are supported for this, but that's all we need at the moment
 // (LDRB actually allows 12-bit offset in ARM mode but constraining to 5-bit gives us advantage for Thumb)
 // @todo, untested!
 #define LD8Z(_d,_off,_b) do {                                           \
@@ -577,17 +541,35 @@ typedef enum {
         asm_output3("ldrb %s,%d(%s)", gpn(_d),(_off),gpn(_b));          \
     } while(0)
 
 #define STR(_d,_n,_off) do {                                            \
         NanoAssert(!IsFpReg(_d) && isS12(_off));                        \
         underrunProtect(4);                                             \
         if ((_off)<0)   *(--_nIns) = (NIns)( COND_AL | (0x50<<20) | ((_n)<<16) | ((_d)<<12) | ((-(_off))&0xFFF) ); \
         else            *(--_nIns) = (NIns)( COND_AL | (0x58<<20) | ((_n)<<16) | ((_d)<<12) | ((_off)&0xFFF) ); \
-        asm_output3("str %s, %d(%s)",gpn(_d), (_off), gpn(_n));         \
+        asm_output3("str %s, [%s, #%d]", gpn(_d), gpn(_n), (_off)); \
+    } while(0)
+
+// Rd += _off; [Rd] = Rn
+#define STR_preindex(_d,_n,_off) do {                                   \
+        NanoAssert(!IsFpReg(_d) && isS12(_off));                        \
+        underrunProtect(4);                                             \
+        if ((_off)<0)   *(--_nIns) = (NIns)( COND_AL | (0x52<<20) | ((_n)<<16) | ((_d)<<12) | ((-(_off))&0xFFF) ); \
+        else            *(--_nIns) = (NIns)( COND_AL | (0x5A<<20) | ((_n)<<16) | ((_d)<<12) | ((_off)&0xFFF) ); \
+        asm_output3("str %s, [%s, #%d]", gpn(_d), gpn(_n), (_off));      \
+    } while(0)
+
+// [Rd] = Rn ; Rd += _off
+#define STR_postindex(_d,_n,_off) do {                                  \
+        NanoAssert(!IsFpReg(_d) && isS12(_off));                        \
+        underrunProtect(4);                                             \
+        if ((_off)<0)   *(--_nIns) = (NIns)( COND_AL | (0x40<<20) | ((_n)<<16) | ((_d)<<12) | ((-(_off))&0xFFF) ); \
+        else            *(--_nIns) = (NIns)( COND_AL | (0x48<<20) | ((_n)<<16) | ((_d)<<12) | ((_off)&0xFFF) ); \
+        asm_output3("str %s, [%s], %d", gpn(_d), gpn(_n), (_off));      \
     } while(0)
 
 
 #define LEA(_r,_d,_b) do {                                              \
         NanoAssert((_d)<=1020);                                         \
         NanoAssert(((_d)&3)==0);                                        \
         if (_b!=SP) NanoAssert(0);                                      \
         if ((_d)<256) {                                                 \
diff -r b7bcdd009540 js/src/nanojit/Nativei386.cpp
--- a/js/src/nanojit/Nativei386.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/nanojit/Nativei386.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -38,17 +38,17 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifdef _MAC
 // for MakeDataExecutable
 #include <CoreServices/CoreServices.h>
 #endif
 
-#if defined DARWIN || defined LINUX
+#if defined AVMPLUS_UNIX
 #include <sys/mman.h>
 #include <errno.h>
 #endif
 #include "nanojit.h"
 
 namespace nanojit
 {
 	#ifdef FEATURE_NANOJIT
@@ -339,20 +339,24 @@ namespace nanojit
 	}
 #endif
 	
 	void Assembler::nMarkExecute(Page* page, int32_t count, bool enable)
 	{
 		#if defined WIN32 || defined WIN64
 			DWORD dwIgnore;
 			VirtualProtect(&page->code, count*NJ_PAGE_SIZE, PAGE_EXECUTE_READWRITE, &dwIgnore);
-		#elif defined DARWIN || defined AVMPLUS_LINUX
+		#elif defined AVMPLUS_UNIX
 			intptr_t addr = (intptr_t)&page->code;
 			addr &= ~((uintptr_t)NJ_PAGE_SIZE - 1);
+			#if defined SOLARIS
+			if (mprotect((char *)addr, count*NJ_PAGE_SIZE, PROT_READ|PROT_WRITE|PROT_EXEC) == -1) {
+			#else
 			if (mprotect((void *)addr, count*NJ_PAGE_SIZE, PROT_READ|PROT_WRITE|PROT_EXEC) == -1) {
+			#endif
                 AvmDebugLog(("FATAL ERROR: mprotect(PROT_EXEC) failed\n"));
                 abort();
             }
 		#endif
 			(void)enable;
 	}
 			
 	Register Assembler::nRegisterAllocFromSet(int set)
@@ -703,16 +707,18 @@ namespace nanojit
             /* Try to catch some common patterns.
              * Note: this is a necessity, since in between things like
              * asm_fop() could see the reservation and try to use a non-SSE 
              * register for adding.  Same for asm_qbinop in theory.  
              * There should probably be asserts to catch more cases.
              */
             if (value->isop(LIR_u2f) 
                 || value->isop(LIR_i2f)
+                || (value->opcode() >= LIR_fneg && value->opcode() <= LIR_fmul)
+                || value->opcode() == LIR_fdiv
                 || value->opcode() == LIR_fcall) {
                 rv = findRegFor(value, XmmRegs);
                 SSE_STQ(dr, rb, rv);
             } else {
                 rv = findRegFor(value, GpRegs);
                 STQ(rb, dr, rv);
             }
         }
@@ -873,21 +879,35 @@ namespace nanojit
 #endif
 			LIns *lhs = ins->oprnd1();
 
 			Register rr = prepResultReg(ins, XmmRegs);
 			Reservation *rA = getresv(lhs);
 			Register ra;
 
 			// if this is last use of lhs in reg, we can re-use result reg
-			if (rA == 0 || (ra = rA->reg) == UnknownReg)
+			if (rA == 0 || (ra = rA->reg) == UnknownReg) {
 				ra = findSpecificRegFor(lhs, rr);
+			} else if ((rmask(ra) & XmmRegs) == 0) {
+				/* We need this case on AMD64, because it's possible that 
+				 * an earlier instruction has done a quadword load and reserved a 
+				 * GPR.  If so, ask for a new register.
+				 */
+				ra = findRegFor(lhs, XmmRegs);
+			}
 			// else, rA already has a register assigned.
 
+#if defined __SUNPRO_CC
+			// from Sun Studio C++ Readme: #pragma align inside namespace requires mangled names
+			static uint32_t temp[] = {0, 0, 0, 0, 0, 0, 0};
+			static uint32_t *negateMask = (uint32_t *)alignUp(temp, 16);
+			negateMask[1] = 0x80000000;
+#else
 			static const AVMPLUS_ALIGN16(uint32_t) negateMask[] = {0,0x80000000,0,0};
+#endif
 			SSE_XORPD(rr, negateMask);
 
 			if (rr != ra)
 				SSE_MOVSD(rr, ra);
 #if defined NANOJIT_IA32
 		}
 		else
 		{
@@ -970,18 +990,25 @@ namespace nanojit
 				allow &= ~rmask(rb);
 			}
 
 			Register rr = prepResultReg(ins, allow);
 			Reservation *rA = getresv(lhs);
 			Register ra;
 
 			// if this is last use of lhs in reg, we can re-use result reg
-			if (rA == 0 || (ra = rA->reg) == UnknownReg)
+			if (rA == 0 || (ra = rA->reg) == UnknownReg) {
 				ra = findSpecificRegFor(lhs, rr);
+			} else if ((rmask(ra) & XmmRegs) == 0) {
+				/* We need this case on AMD64, because it's possible that 
+				 * an earlier instruction has done a quadword load and reserved a 
+				 * GPR.  If so, ask for a new register.
+				 */
+				ra = findRegFor(lhs, XmmRegs);
+			}
 			// else, rA already has a register assigned.
 
 			if (lhs == rhs)
 				rb = ra;
 
 			if (op == LIR_fadd)
 				SSE_ADDSD(rr, rb);
 			else if (op == LIR_fsub)
diff -r b7bcdd009540 js/src/nanojit/avmplus.h
--- a/js/src/nanojit/avmplus.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/nanojit/avmplus.h	Thu Sep 11 15:19:25 2008 +0300
@@ -34,17 +34,17 @@
 #ifndef avm_h___
 #define avm_h___
 
 #include <assert.h>
 #include <string.h>
 #include <stdio.h>
 #include <stdlib.h>
 
-#if defined(AVMPLUS_LINUX) || defined(DARWIN) || defined(__FreeBSD__)
+#if defined(AVMPLUS_UNIX)
 #include <unistd.h>
 #include <sys/mman.h>
 #endif
 
 #include "jstypes.h"
 
 #define FASTCALL JS_FASTCALL
 
@@ -94,35 +94,42 @@ typedef JSUint32 uint32_t;
 typedef JSUint32 uint32_t;
 typedef JSInt32  int32_t;
 typedef JSUint64 uint64_t;
 typedef JSInt64  int64_t;
 #else
 #include <stdint.h>
 #endif
 
-#if defined(_MSC_VER) && defined(AVMPLUS_IA32)
+#if defined(AVMPLUS_IA32)
+#if defined(_MSC_VER)
 __declspec(naked) static inline __int64 rdtsc()
 {
     __asm
     {
         rdtsc;
         ret;
     }
 }
-#endif
-
-#if defined(__i386__)
-
+#elif defined(SOLARIS)
+static inline unsigned long long rdtsc(void)
+{
+    unsigned long long int x;
+    asm volatile (".byte 0x0f, 0x31" : "=A" (x));
+    return x;
+}
+#elif defined(__i386__)
 static __inline__ unsigned long long rdtsc(void)
 {
   unsigned long long int x;
      __asm__ volatile (".byte 0x0f, 0x31" : "=A" (x));
      return x;
 }
+#endif /* compilers */
+
 #elif defined(__x86_64__)
 
 static __inline__ uint64_t rdtsc(void)
 {
   unsigned hi, lo;
   __asm__ __volatile__ ("rdtsc" : "=a"(lo), "=d"(hi));
   return ( (uint64_t)lo)|( ((uint64_t)hi)<<32 );
 }
@@ -146,17 +153,17 @@ static __inline__ unsigned long long rdt
                 );
   result = upper;
   result = result<<32;
   result = result|lower;
 
   return(result);
 }
 
-#endif
+#endif /* architecture */
 
 struct JSContext;
 
 namespace nanojit
 {
 	class Fragment;
 
 	enum ExitType {
@@ -246,17 +253,17 @@ public:
     inline void*
     Alloc(uint32_t pages) 
     {
 #ifdef XP_WIN
         return VirtualAlloc(NULL, 
                             pages * kNativePageSize,
                             MEM_COMMIT | MEM_RESERVE, 
                             PAGE_EXECUTE_READWRITE);
-#elif defined AVMPLUS_LINUX || defined DARWIN
+#elif defined AVMPLUS_UNIX
         /**
          * Don't use normal heap with mprotect+PROT_EXEC for executable code.
          * SELinux and friends don't allow this.
          */
         return mmap(NULL, 
                     pages * kNativePageSize,
                     PROT_READ | PROT_WRITE | PROT_EXEC,
                     MAP_PRIVATE | MAP_ANON,
@@ -267,18 +274,22 @@ public:
 #endif
     }
     
     inline void
     Free(void* p, uint32_t pages)
     {
 #ifdef XP_WIN
         VirtualFree(p, 0, MEM_RELEASE);
-#elif defined AVMPLUS_LINUX || defined DARWIN
+#elif defined AVMPLUS_UNIX
+        #if defined SOLARIS
+        munmap((char*)p, pages * kNativePageSize); 
+        #else
         munmap(p, pages * kNativePageSize); 
+        #endif
 #else
         free(p);
 #endif
     }
     
 };
 
 class GC 
@@ -458,16 +469,20 @@ namespace avmplus
         static inline GC*
         GetGC() 
         {
             return gc;
         }
 
         static inline String* newString(const char* cstr) {
             return (String*)strdup(cstr);
+        }
+
+        static inline void freeString(String* str) {
+            return free((char*)str);
         }
     };
 
     class OSDep
     {
     public:
         static inline void
         getDate()
diff -r b7bcdd009540 js/src/nanojit/nanojit.h
--- a/js/src/nanojit/nanojit.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/nanojit/nanojit.h	Thu Sep 11 15:19:25 2008 +0300
@@ -68,17 +68,21 @@ namespace nanojit
 	class RegAlloc;
 	typedef avmplus::AvmCore AvmCore;
 	typedef avmplus::OSDep OSDep;
 	typedef avmplus::GCSortedMap<const void*,Fragment*,avmplus::LIST_GCObjects> FragmentMap;
 	typedef avmplus::SortedMap<SideExit*,RegAlloc*,avmplus::LIST_GCObjects> RegAllocMap;
 	typedef avmplus::List<LIns*,avmplus::LIST_NonGCObjects>	InsList;
 	typedef avmplus::List<char*, avmplus::LIST_GCObjects> StringList;
 
-	#if defined(_DEBUG)
+	#if defined(_MSC_VER) && _MSC_VER < 1400
+		static void NanoAssertMsgf(bool a,const char *f,...) {}
+		static void NanoAssertMsg(bool a,const char *m) {}
+		static void NanoAssert(bool a) {}
+	#elif defined(_DEBUG)
 		
 		#define __NanoAssertMsgf(a, file_, line_, f, ...)  \
 			if (!(a)) { \
 				fprintf(stderr, "Assertion failed: " f "%s (%s:%d)\n", __VA_ARGS__, #a, file_, line_); \
 				NanoAssertFail(); \
 			}
 			
 		#define _NanoAssertMsgf(a, file_, line_, f, ...)   __NanoAssertMsgf(a, file_, line_, f, __VA_ARGS__)
diff -r b7bcdd009540 js/src/trace-test.js
--- a/js/src/trace-test.js	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/trace-test.js	Thu Sep 11 15:19:25 2008 +0300
@@ -1173,18 +1173,134 @@ function testNegZero1Helper(z) {
 }
 
 var testNegZero1 = function() { return testNegZero1Helper(0); }
 testNegZero1.expected = true;
 testNegZero1.name = 'testNegZero1';
 testNegZero1Helper(1);
 test(testNegZero1);
 
-/* No test case, just make sure this doesn't assert. */
+// No test case, just make sure this doesn't assert. 
 function testNegZero2() {
     var z = 0;
     for (let j = 0; j < 5; ++j) { ({p: (-z)}); }
 }
 testNegZero2();
 
+function testConstSwitch() {
+    var x;
+    for (var j=0;j<5;++j) { switch(1.1) { case NaN: case 2: } x = 2; }
+    return x;
+}
+testConstSwitch.expected = 2;
+test(testConstSwitch);
+
+function testConstIf() {
+    var x;
+    for (var j=0;j<5;++j) { if (1.1 || 5) { } x = 2;}
+    return x;
+}
+testConstIf.expected = 2;
+test(testConstIf);
+
+function testTypeofHole() {
+  var a = new Array(6);
+  a[5] = 3;
+  for (var i = 0; i < 6; ++i)
+    a[i] = typeof a[i];
+  return a.join(",");
+}
+testTypeofHole.expected = "undefined,undefined,undefined,undefined,undefined,number"
+test(testTypeofHole);
+
+function testNativeLog() {
+  var a = new Array(5);
+  for (var i = 0; i < 5; i++) {
+    a[i] = Math.log(Math.pow(Math.E, 10));
+  }
+  return a.join(",");
+}
+testNativeLog.expected = "10,10,10,10,10";
+test(testNativeLog);
+
+function test_JSOP_ARGSUB() {
+    function f0() { return arguments[0]; }
+    function f1() { return arguments[1]; }
+    function f2() { return arguments[2]; }
+    function f3() { return arguments[3]; }
+    function f4() { return arguments[4]; }
+    function f5() { return arguments[5]; }
+    function f6() { return arguments[6]; }
+    function f7() { return arguments[7]; }
+    function f8() { return arguments[8]; }
+    function f9() { return arguments[9]; }
+    var a = [];
+    for (var i = 0; i < 10; i++) {
+        a[0] = f0('a');
+        a[1] = f1('a','b');
+        a[2] = f2('a','b','c');
+        a[3] = f3('a','b','c','d');
+        a[4] = f4('a','b','c','d','e');
+        a[5] = f5('a','b','c','d','e','f');
+        a[6] = f6('a','b','c','d','e','f','g');
+        a[7] = f7('a','b','c','d','e','f','g','h');
+        a[8] = f8('a','b','c','d','e','f','g','h','i');
+        a[9] = f9('a','b','c','d','e','f','g','h','i','j');
+    }
+    return a.join("");
+}
+test_JSOP_ARGSUB.expected = "abcdefghij";
+test(test_JSOP_ARGSUB);
+
+function test_JSOP_ARGCNT() {
+    function f0() { return arguments.length; }
+    function f1() { return arguments.length; }
+    function f2() { return arguments.length; }
+    function f3() { return arguments.length; }
+    function f4() { return arguments.length; }
+    function f5() { return arguments.length; }
+    function f6() { return arguments.length; }
+    function f7() { return arguments.length; }
+    function f8() { return arguments.length; }
+    function f9() { return arguments.length; }
+    var a = [];
+    for (var i = 0; i < 10; i++) {
+        a[0] = f0('a');
+        a[1] = f1('a','b');
+        a[2] = f2('a','b','c');
+        a[3] = f3('a','b','c','d');
+        a[4] = f4('a','b','c','d','e');
+        a[5] = f5('a','b','c','d','e','f');
+        a[6] = f6('a','b','c','d','e','f','g');
+        a[7] = f7('a','b','c','d','e','f','g','h');
+        a[8] = f8('a','b','c','d','e','f','g','h','i');
+        a[9] = f9('a','b','c','d','e','f','g','h','i','j');
+    }
+    return a.join(",");
+}
+test_JSOP_ARGCNT.expected = "1,2,3,4,5,6,7,8,9,10";
+test(test_JSOP_ARGCNT);
+
+function testNativeMax() {
+    var out = [], k;
+    for (var i = 0; i < 5; ++i) {
+        k = Math.max(k, i);
+    }
+    out.push(k);
+
+    k = 0;
+    for (var i = 0; i < 5; ++i) {
+        k = Math.max(k, i);
+    }
+    out.push(k);
+
+    for (var i = 0; i < 5; ++i) {
+        k = Math.max(0, -0);
+    }
+    out.push((1 / k) < 0);
+    return out.join(",");
+}
+testNativeMax.expected = "NaN,4,false";
+test(testNativeMax);
+
 /* Keep these at the end so that we can see the summary after the trace-debug spew. */
 print("\npassed:", passes.length && passes.join(","));
 print("\nFAILED:", fails.length && fails.join(","));
diff -r b7bcdd009540 js/src/xpconnect/src/nsXPConnect.cpp
--- a/js/src/xpconnect/src/nsXPConnect.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/xpconnect/src/nsXPConnect.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -937,34 +937,37 @@ nsXPConnect::Traverse(void *p, nsCycleCo
 
     if(clazz == &XPC_WN_Tearoff_JSClass)
     {
         // A tearoff holds a strong reference to its native object
         // (see XPCWrappedNative::FlatJSObjectFinalized). Its XPCWrappedNative
         // will be held alive through the parent of the JSObject of the tearoff.
         XPCWrappedNativeTearOff *to =
             (XPCWrappedNativeTearOff*) xpc_GetJSPrivate(obj);
+        NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "xpc_GetJSPrivate(obj)->mNative");
         cb.NoteXPCOMChild(to->GetNative());
     }
     // XXX XPCNativeWrapper seems to be the only class that doesn't hold a
     //     strong reference to its nsISupports private. This test does seem
     //     fragile though, we should probably whitelist classes that do hold
     //     a strong reference, but that might not be possible.
     else if(clazz->flags & JSCLASS_HAS_PRIVATE &&
             clazz->flags & JSCLASS_PRIVATE_IS_NSISUPPORTS &&
             !XPCNativeWrapper::IsNativeWrapperClass(clazz))
     {
+        NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "xpc_GetJSPrivate(obj)");
         cb.NoteXPCOMChild(static_cast<nsISupports*>(xpc_GetJSPrivate(obj)));
     }
 
 #ifndef XPCONNECT_STANDALONE
     if(clazz->flags & JSCLASS_IS_GLOBAL)
     {
         nsISupports *principal = nsnull;
         mScopes.Get(obj, &principal);
+        NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "scope prinicpal");
         cb.NoteXPCOMChild(principal);
     }
 #endif
 
     return NS_OK;
 }
 
 PRInt32
diff -r b7bcdd009540 js/src/xpconnect/src/xpcprivate.h
--- a/js/src/xpconnect/src/xpcprivate.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/xpconnect/src/xpcprivate.h	Thu Sep 11 15:19:25 2008 +0300
@@ -1891,17 +1891,17 @@ public:
     GetSecurityInfoAddr() {return &mSecurityInfo;}
 
     JSUint32
     GetClassInfoFlags() const {return mClassInfoFlags;}
 
 #ifdef GET_IT
 #undef GET_IT
 #endif
-#define GET_IT(f_) const {return (JSBool)(mClassInfoFlags & nsIClassInfo:: f_ );}
+#define GET_IT(f_) const {return !!(mClassInfoFlags & nsIClassInfo:: f_ );}
 
     JSBool ClassIsSingleton()           GET_IT(SINGLETON)
     JSBool ClassIsThreadSafe()          GET_IT(THREADSAFE)
     JSBool ClassIsMainThreadOnly()      GET_IT(MAIN_THREAD_ONLY)
     JSBool ClassIsDOMObject()           GET_IT(DOM_OBJECT)
     JSBool ClassIsPluginObject()        GET_IT(PLUGIN_OBJECT)
 
 #undef GET_IT
diff -r b7bcdd009540 js/src/xpconnect/src/xpcwrappednative.cpp
--- a/js/src/xpconnect/src/xpcwrappednative.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/xpconnect/src/xpcwrappednative.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -2887,17 +2887,17 @@ XPCWrappedNative::HandlePossibleNameCase
        nsCRT::IsUpper((char)oldStr[0]) &&
        nsnull != (newStr = nsCRT::strdup(oldStr)))
     {
         newStr[0] = (PRUnichar) nsCRT::ToLower((char)newStr[0]);
         newJSStr = JS_NewUCStringCopyZ(ccx, (const jschar*)newStr);
         nsCRT::free(newStr);
         if(newJSStr && (set ?
              set->FindMember(STRING_TO_JSVAL(newJSStr), &member, &localIface) :
-                        (JSBool)NS_PTR_TO_INT32(iface->FindMember(STRING_TO_JSVAL(newJSStr)))))
+                        NS_PTR_TO_INT32(iface->FindMember(STRING_TO_JSVAL(newJSStr)))))
         {
             // found it!
             const char* ifaceName = set ?
                     localIface->GetNameString() :
                     iface->GetNameString();
             const char* goodName = JS_GetStringBytes(newJSStr);
             const char* badName = JS_GetStringBytes(oldJSStr);
             char* locationStr = nsnull;
diff -r b7bcdd009540 js/src/xpconnect/tests/Makefile.in
--- a/js/src/xpconnect/tests/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/js/src/xpconnect/tests/Makefile.in	Thu Sep 11 15:19:25 2008 +0300
@@ -48,30 +48,23 @@ SIMPLE_PROGRAMS = TestXPC$(BIN_SUFFIX)
 
 REQUIRES	= xpconnect \
 		  xpcom \
 		  string \
 		  js \
 		  xpconnect_tests \
 		  $(NULL)
 
-DIRS		= idl
+DIRS		= idl mochitest
 
 ifndef MOZ_ENABLE_LIBXUL
 DIRS += components
 endif
 
-ifdef MOZ_MOCHITEST
-DIRS += mochitest \
-	$(NULL)
-endif
-
-ifdef ENABLE_TESTS
 XPCSHELL_TESTS = unit
-endif
 
 CPPSRCS		= TestXPC.cpp
 
 LIBS		= \
 		$(DIST)/lib/$(LIB_PREFIX)xpcomglue_s.$(LIB_SUFFIX) \
 		$(LIBS_DIR) \
 		$(MOZ_JS_LIBS) \
 		$(MOZ_COMPONENT_LIBS) \
diff -r b7bcdd009540 layout/base/Makefile.in
--- a/layout/base/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/base/Makefile.in	Thu Sep 11 15:19:25 2008 +0300
@@ -37,17 +37,17 @@
 
 DEPTH		= ../..
 topsrcdir	= @top_srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
-ifdef MOZ_MOCHITEST
+ifdef ENABLE_TESTS
 DIRS		+= tests
 endif
 
 MODULE		= layout
 XPIDL_MODULE	= layout_base
 GRE_MODULE	= 1
 LIBRARY_NAME	= gkbase_s
 LIBXUL_LIBRARY	= 1
diff -r b7bcdd009540 layout/base/crashtests/crashtests.list
--- a/layout/base/crashtests/crashtests.list	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/base/crashtests/crashtests.list	Thu Sep 11 15:19:25 2008 +0300
@@ -1,13 +1,14 @@ load 56746-1.html
 load 56746-1.html
 load 143862-1.html
 load 143862-2.html
 load 243159-1.html
 load 243159-2.xhtml
+load 243519-1.html
 load 306940-1.html
 load 310267-1.xml
 load 310638-1.svg
 load 310638-2.html
 load 313086-1.xml
 load 321058-1.xul
 load 321058-2.xul
 load 321077-1.xul
diff -r b7bcdd009540 layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/base/nsCSSFrameConstructor.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -484,17 +484,17 @@ static nsIFrame* GetSpecialSibling(nsIFr
   aFrame = aFrame->GetFirstContinuation();
 
   void* value = aFrame->GetProperty(nsGkAtoms::IBSplitSpecialSibling);
 
   return static_cast<nsIFrame*>(value);
 }
 
 static nsIFrame*
-GetIBSplitSpecialPrevSibling(nsIFrame* aFrame)
+GetIBSplitSpecialPrevSiblingForAnonymousBlock(nsIFrame* aFrame)
 {
   NS_PRECONDITION(IsFrameSpecial(aFrame) && !IsInlineFrame(aFrame),
                   "Shouldn't call this");
   
   // We only store the "special sibling" annotation with the first
   // frame in the continuation chain. Walk back to find that frame now.  
   return
     static_cast<nsIFrame*>
@@ -603,20 +603,17 @@ FindLastBlock(nsIFrame* aKid)
       lastBlock = aKid;
     }
     aKid = aKid->GetNextSibling();
   }
   return lastBlock;
 }
 
 /*
- * Unlike the special (next) sibling, the special previous sibling
- * property points only from the anonymous block to the original
- * inline that preceded it.  DO NOT CHANGE THAT -- the
- * GetParentStyleContextFrame code depends on it!  It is useful for
+ * The special-prev-sibling is useful for
  * finding the "special parent" of a frame (i.e., a frame from which a
  * good parent style context can be obtained), one looks at the
  * special previous sibling annotation of the real parent of the frame
  * (if the real parent has NS_FRAME_IS_SPECIAL).
  */
 inline void
 MarkIBSpecialPrevSibling(nsIFrame *aAnonymousFrame,
                          nsIFrame *aSpecialParent)
@@ -1801,19 +1798,19 @@ nsCSSFrameConstructor::nsCSSFrameConstru
   , mRootElementStyleFrame(nsnull)
   , mFixedContainingBlock(nsnull)
   , mDocElementContainingBlock(nsnull)
   , mGfxScrollFrame(nsnull)
   , mPageSequenceFrame(nsnull)
   , mUpdateCount(0)
   , mQuotesDirty(PR_FALSE)
   , mCountersDirty(PR_FALSE)
-  , mInitialContainingBlockIsAbsPosContainer(PR_FALSE)
   , mIsDestroyingFrameTree(PR_FALSE)
   , mRebuildAllStyleData(PR_FALSE)
+  , mHasRootAbsPosContainingBlock(PR_FALSE)
 {
   if (!gGotXBLFormPrefs) {
     gGotXBLFormPrefs = PR_TRUE;
 
     gUseXBLForms =
       nsContentUtils::GetBoolPref("nglayout.debug.enable_xbl_forms");
   }
 
@@ -3967,42 +3964,16 @@ nsCSSFrameConstructor::GetDisplay(nsIFra
   }
   return aFrame->GetStyleContext()->GetStyleDisplay();
 }
 
 /***********************************************
  * END TABLE SECTION
  ***********************************************/
 
-nsresult
-nsCSSFrameConstructor::ConstructDocElementTableFrame(nsIContent*     aDocElement,
-                                                     nsIFrame*       aParentFrame,
-                                                     nsIFrame**      aNewTableFrame,
-                                                     nsFrameConstructorState& aState)
-{
-  nsFrameItems    frameItems;
-
-  // XXXbz this is wrong.  We should at least be setting the fixed container in
-  // the framestate here.  Better yet, we should pass through aState
-  // unmodified.  Can't do that, though, because then a fixed or absolute
-  // positioned root table with auto offsets would look for a block to compute
-  // its hypothetical box and crash.  So we just disable fixed positioning
-  // altogether in documents where the root is a table.  Oh, well.
-  nsFrameConstructorState state(mPresShell, nsnull, nsnull, nsnull,
-                                aState.mFrameState);
-  ConstructFrame(state, aDocElement, aParentFrame, frameItems);
-  *aNewTableFrame = frameItems.childList;
-  if (!*aNewTableFrame) {
-    NS_WARNING("cannot get table contentFrame");
-    // XXXbz maybe better to return the error from ConstructFrame?
-    return NS_ERROR_FAILURE;
-  }
-  return NS_OK;
-}
-
 static PRBool CheckOverflow(nsPresContext* aPresContext,
                             const nsStyleDisplay* aDisplay)
 {
   if (aDisplay->mOverflowX == NS_STYLE_OVERFLOW_VISIBLE)
     return PR_FALSE;
 
   if (aDisplay->mOverflowX == NS_STYLE_OVERFLOW_CLIP)
     aPresContext->SetViewportOverflowOverride(NS_STYLE_OVERFLOW_HIDDEN,
@@ -4088,39 +4059,16 @@ nsCSSFrameConstructor::PropagateScrollTo
  * New one
  */
 nsresult
 nsCSSFrameConstructor::ConstructDocElementFrame(nsFrameConstructorState& aState,
                                                 nsIContent*              aDocElement,
                                                 nsIFrame*                aParentFrame,
                                                 nsIFrame**               aNewFrame)
 {
-    // how the root frame hierarchy should look
-
-    /*
-
----------------No Scrollbars------
-
-
-     AreaFrame or BoxFrame (InitialContainingBlock)
-  
-
-
----------------Gfx Scrollbars ------
-
-
-     ScrollFrame
-
-         ^
-         |
-         |
-     AreaFrame or BoxFrame (InitialContainingBlock)
-          
-*/    
-
   *aNewFrame = nsnull;
 
   if (!mTempFrameTreeState)
     aState.mPresShell->CaptureHistoryState(getter_AddRefs(mTempFrameTreeState));
 
   // ----- reattach gfx scrollbars ------
   // Gfx scrollframes were created in the root frame but the primary frame map may have been destroyed if a 
   // new style sheet was loaded so lets reattach the frames to their content.
@@ -4184,157 +4132,219 @@ nsCSSFrameConstructor::ConstructDocEleme
     PropagateScrollToViewport() == aDocElement;
 
   NS_ASSERTION(!display->IsScrollableOverflow() || 
                aState.mPresContext->IsPaginated() ||
                propagatedScrollToViewport,
                "Scrollbars should have been propagated to the viewport");
 #endif
 
-  nsIFrame* contentFrame = nsnull;
-  PRBool isBlockFrame = PR_FALSE;
+  nsFrameConstructorSaveState absoluteSaveState;
+  if (mHasRootAbsPosContainingBlock) {
+    // Push the absolute containing block now so we can absolutely position
+    // the root element
+    aState.PushAbsoluteContainingBlock(mDocElementContainingBlock, absoluteSaveState);
+  }
+
   nsresult rv;
 
   // The rules from CSS 2.1, section 9.2.4, have already been applied
   // by the style system, so we can assume that display->mDisplay is
   // either NONE, BLOCK, or TABLE.
 
   PRBool docElemIsTable = (display->mDisplay == NS_STYLE_DISPLAY_TABLE) &&
                           !IsSpecialContent(aDocElement, aDocElement->Tag(),
                                             aDocElement->GetNameSpaceID(),
                                             styleContext);
 
+  // contentFrame is the primary frame for the root element. *aNewFrame
+  // is the frame that will be the child of the initial containing block.
+  // These are usually the same frame but they can be different, in
+  // particular if the root frame is positioned, in which case
+  // contentFrame is the out-of-flow frame and *aNewFrame is the
+  // placeholder.
+  nsIFrame* contentFrame;
+  PRBool processChildren = PR_FALSE;
   if (docElemIsTable) {
+    nsIFrame* innerTableFrame;
+    nsFrameItems frameItems;
     // if the document is a table then just populate it.
-    rv = ConstructDocElementTableFrame(aDocElement, aParentFrame, &contentFrame,
-                                       aState);
-    if (NS_FAILED(rv)) {
-      return rv;
-    }
-    styleContext = contentFrame->GetStyleContext();
+    rv = ConstructTableFrame(aState, aDocElement,
+                             aParentFrame, styleContext,
+                             kNameSpaceID_None, PR_FALSE, frameItems, contentFrame,
+                             innerTableFrame);
+    if (NS_FAILED(rv))
+      return rv;
+    if (!contentFrame || !frameItems.childList)
+      return NS_ERROR_FAILURE;
+    *aNewFrame = frameItems.childList;
+    NS_ASSERTION(!frameItems.childList->GetNextSibling(),
+                 "multiple root element frames");
   } else {
     // otherwise build a box or a block
 #ifdef MOZ_XUL
     if (aDocElement->IsNodeOfType(nsINode::eXUL)) {
       contentFrame = NS_NewDocElementBoxFrame(mPresShell, styleContext);
+      if (NS_UNLIKELY(!contentFrame)) {
+        return NS_ERROR_OUT_OF_MEMORY;
+      }
+      InitAndRestoreFrame(aState, aDocElement, aParentFrame, nsnull, contentFrame);
+      *aNewFrame = contentFrame;
+      processChildren = PR_TRUE;
     }
     else
 #endif 
 #ifdef MOZ_SVG
     if (aDocElement->GetNameSpaceID() == kNameSpaceID_SVG) {
       if (aDocElement->Tag() == nsGkAtoms::svg && NS_SVGEnabled()) {
         contentFrame = NS_NewSVGOuterSVGFrame(mPresShell, aDocElement, styleContext);
+        if (NS_UNLIKELY(!contentFrame)) {
+          return NS_ERROR_OUT_OF_MEMORY;
+        }
+        InitAndRestoreFrame(aState, aDocElement,
+                            aState.GetGeometricParent(display, aParentFrame),
+                            nsnull, contentFrame);
+
+        // AddChild takes care of transforming the frame tree for fixed-pos
+        // or abs-pos situations
+        nsFrameItems frameItems;
+        rv = aState.AddChild(contentFrame, frameItems, aDocElement,
+                             styleContext, aParentFrame);
+        if (NS_FAILED(rv) || !frameItems.childList) {
+          return rv;
+        }
+        *aNewFrame = frameItems.childList;
+        processChildren = PR_TRUE;
+
+        // See if we need to create a view, e.g. the frame is absolutely positioned
+        nsHTMLContainerFrame::CreateViewForFrame(contentFrame, aParentFrame, PR_FALSE);
       } else {
         return NS_ERROR_FAILURE;
       }
     }
     else 
 #endif
     {
-      contentFrame = NS_NewDocumentElementFrame(mPresShell, styleContext);
-      isBlockFrame = PR_TRUE;
-    }
-    
-    if (NS_UNLIKELY(!contentFrame)) {
-      return NS_ERROR_OUT_OF_MEMORY;
-    }
-
-    // initialize the child
-    InitAndRestoreFrame(aState, aDocElement, aParentFrame, nsnull, contentFrame);
+      contentFrame = NS_NewBlockFrame(mPresShell, styleContext,
+        NS_BLOCK_SPACE_MGR|NS_BLOCK_MARGIN_ROOT);
+      if (!contentFrame)
+        return NS_ERROR_OUT_OF_MEMORY;
+      nsFrameItems frameItems;
+      rv = ConstructBlock(aState, display, aDocElement,
+                          aState.GetGeometricParent(display, aParentFrame),
+                          aParentFrame, styleContext, &contentFrame,
+                          frameItems, display->IsPositioned());
+      if (NS_FAILED(rv) || !frameItems.childList)
+        return rv;
+      *aNewFrame = frameItems.childList;
+      NS_ASSERTION(!frameItems.childList->GetNextSibling(),
+                   "multiple root element frames");
+    }
   }
 
   // set the primary frame
   aState.mFrameManager->SetPrimaryFrameFor(aDocElement, contentFrame);
 
-  *aNewFrame = contentFrame;
-
   mInitialContainingBlock = contentFrame;
-  mInitialContainingBlockIsAbsPosContainer = PR_FALSE;
 
   // Figure out which frame has the main style for the document element,
   // assigning it to mRootElementStyleFrame.
   // Backgrounds should be propagated from that frame to the viewport.
   PRBool isChild;
   contentFrame->GetParentStyleContextFrame(aState.mPresContext,
           &mRootElementStyleFrame, &isChild);
   if (!isChild) {
     mRootElementStyleFrame = mInitialContainingBlock;
   }
 
-  // if it was a table then we don't need to process our children.
-  if (!docElemIsTable) {
-    // Process the child content
-    nsFrameConstructorSaveState absoluteSaveState;
-    nsFrameConstructorSaveState floatSaveState;
-    nsFrameItems                childItems;
-
-    if (isBlockFrame) {
-      PRBool haveFirstLetterStyle, haveFirstLineStyle;
-      ShouldHaveSpecialBlockStyle(aDocElement, styleContext,
-                                  &haveFirstLetterStyle, &haveFirstLineStyle);
-      mInitialContainingBlockIsAbsPosContainer = PR_TRUE;
-      aState.PushAbsoluteContainingBlock(contentFrame, absoluteSaveState);
-      aState.PushFloatContainingBlock(contentFrame, floatSaveState,
-                                      haveFirstLetterStyle,
-                                      haveFirstLineStyle);
-    }
+  if (processChildren) {
+    // Still need to process the child content
+    nsFrameItems childItems;
 
     // Create any anonymous frames the doc element frame requires
     // This must happen before ProcessChildren to ensure that popups are
     // never constructed before the popupset.
     CreateAnonymousFrames(nsnull, aState, aDocElement, contentFrame,
                           PR_FALSE, childItems, PR_TRUE);
+    NS_ASSERTION(!nsLayoutUtils::GetAsBlock(contentFrame),
+                 "Only XUL and SVG frames should reach here");
     ProcessChildren(aState, aDocElement, contentFrame, PR_TRUE, childItems,
-                    isBlockFrame);
+                    PR_FALSE);
 
     // Set the initial child lists
     contentFrame->SetInitialChildList(nsnull, childItems.childList);
   }
 
   return NS_OK;
 }
 
 
 nsresult
 nsCSSFrameConstructor::ConstructRootFrame(nsIContent*     aDocElement,
                                           nsIFrame**      aNewFrame)
 {
   AUTO_LAYOUT_PHASE_ENTRY_POINT(mPresShell->GetPresContext(), FrameC);
   NS_PRECONDITION(aNewFrame, "null out param");
   
-  // how the root frame hierarchy should look
-
     /*
-
----------------No Scrollbars------
-
-
-
-     ViewPortFrame (FixedContainingBlock) <---- RootView
-
-         ^
-         |
-     RootFrame(DocElementContainingBlock)
-  
-
-
----------------Gfx Scrollbars ------
-
-
-     ViewPortFrame (FixedContainingBlock) <---- RootView
-
-         ^
-         |
-     ScrollFrame
-
-         ^
-         |
-     RootFrame(DocElementContainingBlock)
-          
-*/    
+       how the root frame hierarchy should look
+
+  Galley presentation, non-XUL, with scrolling (i.e. not a frameset):
+  
+      ViewportFrame [fixed-cb]
+        nsHTMLScrollFrame
+          CanvasFrame [abs-cb]
+            root element frame (nsBlockFrame, nsSVGOuterSVGFrame,
+                                nsTableOuterFrame, nsPlaceholderFrame)
+
+  Galley presentation, non-XUL, without scrolling (i.e. a frameset):
+  
+      ViewportFrame [fixed-cb]
+        CanvasFrame [abs-cb]
+          root element frame (nsBlockFrame)
+
+  Galley presentation, XUL
+  
+      ViewportFrame [fixed-cb]
+        nsRootBoxFrame
+          root element frame (nsDocElementBoxFrame)
+
+  Print presentation, non-XUL
+
+      ViewportFrame
+        nsSimplePageSequenceFrame
+          nsPageFrame [fixed-cb]
+            nsPageContentFrame
+              CanvasFrame [abs-cb]
+                root element frame (nsBlockFrame, nsSVGOuterSVGFrame,
+                                    nsTableOuterFrame, nsPlaceholderFrame)
+
+  Print-preview presentation, non-XUL
+
+      ViewportFrame
+        nsHTMLScrollFrame
+          nsSimplePageSequenceFrame
+            nsPageFrame [fixed-cb]
+              nsPageContentFrame
+                CanvasFrame [abs-cb]
+                  root element frame (nsBlockFrame, nsSVGOuterSVGFrame,
+                                      nsTableOuterFrame, nsPlaceholderFrame)
+
+  Print/print preview of XUL is not supported.
+  [fixed-cb]: the default containing block for fixed-pos content
+  [abs-cb]: the default containing block for abs-pos content
+ 
+  Meaning of nsCSSFrameConstructor fields:
+    mInitialContainingBlock is "root element frame".
+    mDocElementContainingBlock is the parent of mInitialContainingBlock
+      (i.e. CanvasFrame or nsRootBoxFrame)
+    mFixedContainingBlock is the [fixed-cb]
+    mGfxScrollFrame is the nsHTMLScrollFrame mentioned above, or null if there isn't one
+    mPageSequenceFrame is the nsSimplePageSequenceFrame, or null if there isn't one
+*/
 
   // Set up our style rule observer.
   {
     mPresShell->StyleSet()->SetBindingManager(mDocument->BindingManager());
   }
 
   // --------- BUILD VIEWPORT -----------
   nsIFrame*                 viewportFrame = nsnull;
@@ -4389,16 +4399,17 @@ nsCSSFrameConstructor::ConstructRootFram
     {
       // pass a temporary stylecontext, the correct one will be set later
       rootFrame = NS_NewRootBoxFrame(mPresShell, viewportPseudoStyle);
     } else
 #endif
     {
       // pass a temporary stylecontext, the correct one will be set later
       rootFrame = NS_NewCanvasFrame(mPresShell, viewportPseudoStyle);
+      mHasRootAbsPosContainingBlock = PR_TRUE;
     }
 
     rootPseudo = nsCSSAnonBoxes::canvas;
     mDocElementContainingBlock = rootFrame;
   } else {
     // Create a page sequence frame
     rootFrame = NS_NewSimplePageSequenceFrame(mPresShell, viewportPseudoStyle);
     mPageSequenceFrame = rootFrame;
@@ -4517,40 +4528,41 @@ nsCSSFrameConstructor::ConstructRootFram
   
   if (isScrollable) {
     FinishBuildingScrollFrame(parentFrame, rootFrame);
   }
   
   if (isPaginated) { // paginated
     // Create the first page
     // Set the initial child lists
-    nsIFrame *pageFrame, *pageContentFrame;
+    nsIFrame *pageFrame, *canvasFrame;
     ConstructPageFrame(mPresShell, presContext, rootFrame, nsnull,
-                       pageFrame, pageContentFrame);
+                       pageFrame, canvasFrame);
     rootFrame->SetInitialChildList(nsnull, pageFrame);
 
     // The eventual parent of the document element frame.
     // XXX should this be set for every new page (in ConstructPageFrame)?
-    mDocElementContainingBlock = pageContentFrame;
+    mDocElementContainingBlock = canvasFrame;
+    mHasRootAbsPosContainingBlock = PR_TRUE;
   }
 
   viewportFrame->SetInitialChildList(nsnull, newFrame);
   
   *aNewFrame = viewportFrame;
 
   return NS_OK;
 }
 
 nsresult
-nsCSSFrameConstructor::ConstructPageFrame(nsIPresShell*   aPresShell,
+nsCSSFrameConstructor::ConstructPageFrame(nsIPresShell*  aPresShell,
                                           nsPresContext* aPresContext,
-                                          nsIFrame*       aParentFrame,
-                                          nsIFrame*       aPrevPageFrame,
-                                          nsIFrame*&      aPageFrame,
-                                          nsIFrame*&      aPageContentFrame)
+                                          nsIFrame*      aParentFrame,
+                                          nsIFrame*      aPrevPageFrame,
+                                          nsIFrame*&     aPageFrame,
+                                          nsIFrame*&     aCanvasFrame)
 {
   nsStyleContext* parentStyleContext = aParentFrame->GetStyleContext();
   nsStyleSet *styleSet = aPresShell->StyleSet();
 
   nsRefPtr<nsStyleContext> pagePseudoStyle;
   pagePseudoStyle = styleSet->ResolvePseudoStyleFor(nsnull,
                                                     nsCSSAnonBoxes::page,
                                                     parentStyleContext);
@@ -4563,31 +4575,47 @@ nsCSSFrameConstructor::ConstructPageFram
   // the pages easier and faster.
   aPageFrame->Init(nsnull, aParentFrame, aPrevPageFrame);
 
   nsRefPtr<nsStyleContext> pageContentPseudoStyle;
   pageContentPseudoStyle = styleSet->ResolvePseudoStyleFor(nsnull,
                                                            nsCSSAnonBoxes::pageContent,
                                                            pagePseudoStyle);
 
-  aPageContentFrame = NS_NewPageContentFrame(aPresShell, pageContentPseudoStyle);
-  if (NS_UNLIKELY(!aPageContentFrame))
+  nsIFrame* pageContentFrame = NS_NewPageContentFrame(aPresShell, pageContentPseudoStyle);
+  if (NS_UNLIKELY(!pageContentFrame))
     return NS_ERROR_OUT_OF_MEMORY;
 
   // Initialize the page content frame and force it to have a view. Also make it the
   // containing block for fixed elements which are repeated on every page.
   nsIFrame* prevPageContentFrame = nsnull;
   if (aPrevPageFrame) {
     prevPageContentFrame = aPrevPageFrame->GetFirstChild(nsnull);
     NS_ASSERTION(prevPageContentFrame, "missing page content frame");
   }
-  aPageContentFrame->Init(nsnull, aPageFrame, prevPageContentFrame);
-  mFixedContainingBlock = aPageContentFrame;
-
-  aPageFrame->SetInitialChildList(nsnull, aPageContentFrame);
+  pageContentFrame->Init(nsnull, aPageFrame, prevPageContentFrame);
+  aPageFrame->SetInitialChildList(nsnull, pageContentFrame);
+  mFixedContainingBlock = pageContentFrame;
+
+  nsRefPtr<nsStyleContext> canvasPseudoStyle;
+  canvasPseudoStyle = styleSet->ResolvePseudoStyleFor(nsnull,
+                                                      nsCSSAnonBoxes::canvas,
+                                                      pageContentPseudoStyle);
+
+  aCanvasFrame = NS_NewCanvasFrame(aPresShell, canvasPseudoStyle);
+  if (NS_UNLIKELY(!aCanvasFrame))
+    return NS_ERROR_OUT_OF_MEMORY;
+
+  nsIFrame* prevCanvasFrame = nsnull;
+  if (prevPageContentFrame) {
+    prevCanvasFrame = prevPageContentFrame->GetFirstChild(nsnull);
+    NS_ASSERTION(prevCanvasFrame, "missing canvas frame");
+  }
+  aCanvasFrame->Init(nsnull, pageContentFrame, prevCanvasFrame);
+  pageContentFrame->SetInitialChildList(nsnull, aCanvasFrame);
 
   return NS_OK;
 }
 
 /* static */
 nsresult
 nsCSSFrameConstructor::CreatePlaceholderFrameFor(nsIPresShell*    aPresShell, 
                                                  nsIContent*      aContent,
@@ -6676,27 +6704,34 @@ nsCSSFrameConstructor::InitAndRestoreFra
 
   return rv;
 }
 
 already_AddRefed<nsStyleContext>
 nsCSSFrameConstructor::ResolveStyleContext(nsIFrame*         aParentFrame,
                                            nsIContent*       aContent)
 {
-  nsStyleContext* parentStyleContext;
+  nsStyleContext* parentStyleContext = nsnull;
   if (aContent->GetParent()) {
     aParentFrame = nsFrame::CorrectStyleParentFrame(aParentFrame, nsnull);
   
-    // Resolve the style context based on the content object and the parent
-    // style context
-    parentStyleContext = aParentFrame->GetStyleContext();
+    if (aParentFrame) {
+      // Resolve the style context based on the content object and the parent
+      // style context
+      parentStyleContext = aParentFrame->GetStyleContext();
+    } else {
+      // Perhaps aParentFrame is a canvasFrame and we're replicating
+      // fixed-pos frames.
+      // XXX should we create a way to tell ConstructFrame which style
+      // context to use, and pass it the style context for the
+      // previous page's fixed-pos frame?
+    }
   } else {
     // This has got to be a call from ConstructDocElementTableFrame.
-    // Not sure how best to asserrt that here.
-    parentStyleContext = nsnull;
+    // Not sure how best to assert that here.
   }
 
   nsStyleSet *styleSet = mPresShell->StyleSet();
 
   if (aContent->IsNodeOfType(nsINode::eELEMENT)) {
     return styleSet->ResolveStyleFor(aContent, parentStyleContext);
   } else {
 
@@ -7502,55 +7537,76 @@ nsCSSFrameConstructor::ReconstructDocEle
 
   nsresult rv = NS_OK;
 
   // XXXbz is that null-check needed?  Why?
   if (mDocument && mPresShell) {
     nsIContent *rootContent = mDocument->GetRootContent();
     
     if (rootContent) {
+      nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
+                                    nsnull, nsnull, mTempFrameTreeState);
+
       // Before removing the frames associated with the content object, ask them to save their
       // state onto a temporary state object.
-      CaptureStateForFramesOf(rootContent, mTempFrameTreeState);
-
-      nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
-                                    nsnull, nsnull, mTempFrameTreeState);
+      CaptureStateFor(state.mFrameManager->GetRootFrame(), mTempFrameTreeState);
 
       // Get the frame that corresponds to the document element
       nsIFrame* docElementFrame =
         state.mFrameManager->GetPrimaryFrameFor(rootContent, -1);
-        
+
+      if (docElementFrame) {
+        // Destroy out-of-flow frames that might not be in the frame subtree
+        // rooted at docElementFrame
+        ::DeletingFrameSubtree(state.mFrameManager, docElementFrame);
+      }
+
       // Remove any existing fixed items: they are always on the
       // FixedContainingBlock.  Note that this has to be done before we call
       // ClearPlaceholderFrameMap(), since RemoveFixedItems uses the
       // placeholder frame map.
-      rv = RemoveFixedItems(state);
+      rv = RemoveFixedItems(state, docElementFrame);
+
       if (NS_SUCCEEDED(rv)) {
+        nsPlaceholderFrame* placeholderFrame = nsnull;
+        if (docElementFrame &&
+            (docElementFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW)) {
+          // Get the placeholder frame now, before we tear down the
+          // placeholder frame map
+          placeholderFrame =
+            state.mFrameManager->GetPlaceholderFrameFor(docElementFrame);
+          NS_ASSERTION(placeholderFrame, "No placeholder for out-of-flow?");
+        }
+
         // Clear the hash tables that map from content to frame and out-of-flow
         // frame to placeholder frame
         state.mFrameManager->ClearPrimaryFrameMap();
         state.mFrameManager->ClearPlaceholderFrameMap();
         state.mFrameManager->ClearUndisplayedContentMap();
 
         if (docElementFrame) {
           // Take the docElementFrame, and remove it from its parent.
-        
           // XXXbz So why can't we reuse ContentRemoved?
-
-          NS_ASSERTION(docElementFrame->GetParent() == mDocElementContainingBlock,
-                       "Unexpected doc element parent frame");
 
           // Notify self that we will destroy the entire frame tree, this blocks
           // RemoveMappingsForFrameSubtree() which would otherwise lead to a
           // crash since we cleared the placeholder map above (bug 398982).
           PRBool wasDestroyingFrameTree = mIsDestroyingFrameTree;
           WillDestroyFrameTree();
-          // Remove the old document element hieararchy
-          rv = state.mFrameManager->RemoveFrame(mDocElementContainingBlock,
-                                                nsnull, docElementFrame);
+
+          rv = state.mFrameManager->RemoveFrame(docElementFrame->GetParent(),
+                    GetChildListNameFor(docElementFrame), docElementFrame);
+          
+          if (placeholderFrame) {
+            // Remove the placeholder frame first (XXX second for now) (so
+            // that it doesn't retain a dangling pointer to memory)
+            rv |= state.mFrameManager->RemoveFrame(placeholderFrame->GetParent(),
+                                            nsnull, placeholderFrame);
+          }
+
           mIsDestroyingFrameTree = wasDestroyingFrameTree;
           if (NS_FAILED(rv)) {
             return rv;
           }
         }
         
         mInitialContainingBlock = nsnull;
         mRootElementStyleFrame = nsnull;
@@ -7637,19 +7693,18 @@ nsCSSFrameConstructor::GetAbsoluteContai
     }
   }
 
   // If we found an absolutely positioned containing block, then use the
   // first-continuation.
   if (containingBlock)
     return AdjustAbsoluteContainingBlock(containingBlock);
 
-  // If we didn't find it, then use the initial containing block if it
-  // supports abs pos kids.
-  return mInitialContainingBlockIsAbsPosContainer ? mInitialContainingBlock : nsnull;
+  // If we didn't find it, then use the document element containing block
+  return mHasRootAbsPosContainingBlock ? mDocElementContainingBlock : nsnull;
 }
 
 nsIFrame*
 nsCSSFrameConstructor::GetFloatContainingBlock(nsIFrame* aFrame)
 {
   NS_PRECONDITION(mInitialContainingBlock, "no initial containing block");
   
   // Starting with aFrame, look for a frame that is a float containing block.
@@ -7774,17 +7829,18 @@ nsCSSFrameConstructor::AppendFrames(nsFr
     do {
       NS_ASSERTION(IsFrameSpecial(parentFrame) && !IsInlineFrame(parentFrame),
                    "Shouldn't be in this code");
       nsIFrame* inlineSibling = GetSpecialSibling(parentFrame);
       PRBool isPositioned = PR_FALSE;
       nsIContent* content = nsnull;
       nsStyleContext* styleContext = nsnull;
       if (!inlineSibling) {
-        nsIFrame* firstInline = GetIBSplitSpecialPrevSibling(parentFrame);
+        nsIFrame* firstInline =
+          GetIBSplitSpecialPrevSiblingForAnonymousBlock(parentFrame);
         NS_ASSERTION(firstInline, "How did that happen?");
 
         content = firstInline->GetContent();
         styleContext = firstInline->GetStyleContext();
         isPositioned = (styleContext->GetStyleDisplay()->mPosition ==
                         NS_STYLE_POSITION_RELATIVE);
       }
 
@@ -10224,19 +10280,19 @@ nsCSSFrameConstructor::CreateContinuingF
 
     if (newFrame) {
       newFrame->Init(content, aParentFrame, aFrame);
       // XXXbz should we be passing in a non-null aContentParentFrame?
       nsHTMLContainerFrame::CreateViewForFrame(newFrame, nsnull, PR_FALSE);
     }
 
   } else if (nsGkAtoms::pageFrame == frameType) {
-    nsIFrame* pageContentFrame;
+    nsIFrame* canvasFrame;
     rv = ConstructPageFrame(shell, aPresContext, aParentFrame, aFrame,
-                            newFrame, pageContentFrame);
+                            newFrame, canvasFrame);
   } else if (nsGkAtoms::tableOuterFrame == frameType) {
     rv = CreateContinuingOuterTableFrame(shell, aPresContext, aFrame, aParentFrame,
                                          content, styleContext, &newFrame);
 
   } else if (nsGkAtoms::tableFrame == frameType) {
     rv = CreateContinuingTableFrame(shell, aPresContext, aFrame, aParentFrame,
                                     content, styleContext, &newFrame);
 
@@ -10415,27 +10471,27 @@ nsCSSFrameConstructor::CreateContinuingF
     newFrame->SetNextContinuation(nextContinuation);
   }
   return NS_OK;
 }
 
 nsresult
 nsCSSFrameConstructor::ReplicateFixedFrames(nsPageContentFrame* aParentFrame)
 {
-  // Now deal with fixed-pos things....  They should appear on all pages, and
-  // the placeholders must be kids of a block, so we want to move over the
-  // placeholders when processing the child of the pageContentFrame.
+  // Now deal with fixed-pos things....  They should appear on all pages,
+  // so we want to move over the placeholders when processing the child
+  // of the pageContentFrame.
 
   nsIFrame* prevPageContentFrame = aParentFrame->GetPrevInFlow();
   if (!prevPageContentFrame) {
     return NS_OK;
   }
-  nsIFrame* docRootFrame = aParentFrame->GetFirstChild(nsnull);
-  nsIFrame* prevDocRootFrame = prevPageContentFrame->GetFirstChild(nsnull);
-  if (!docRootFrame || !prevDocRootFrame) {
+  nsIFrame* canvasFrame = aParentFrame->GetFirstChild(nsnull);
+  nsIFrame* prevCanvasFrame = prevPageContentFrame->GetFirstChild(nsnull);
+  if (!canvasFrame || !prevCanvasFrame) {
     // document's root element frame missing
     return NS_ERROR_UNEXPECTED;
   }
 
   nsFrameItems fixedPlaceholders;
   nsIFrame* firstFixed = prevPageContentFrame->GetFirstChild(nsGkAtoms::fixedList);
   if (!firstFixed) {
     return NS_OK;
@@ -10453,29 +10509,29 @@ nsCSSFrameConstructor::ReplicateFixedFra
   // Iterate across fixed frames and replicate each whose placeholder is a
   // descendant of aFrame. (We don't want to explicitly copy placeholders that
   // are within fixed frames, because that would cause duplicates on the new
   // page - bug 389619)
   for (nsIFrame* fixed = firstFixed; fixed; fixed = fixed->GetNextSibling()) {
     nsIFrame* prevPlaceholder = nsnull;
     mPresShell->GetPlaceholderFrameFor(fixed, &prevPlaceholder);
     if (prevPlaceholder &&
-        nsLayoutUtils::IsProperAncestorFrame(prevDocRootFrame, prevPlaceholder)) {
+        nsLayoutUtils::IsProperAncestorFrame(prevCanvasFrame, prevPlaceholder)) {
       nsresult rv = ConstructFrame(state, fixed->GetContent(),
-                                   docRootFrame, fixedPlaceholders);
+                                   canvasFrame, fixedPlaceholders);
       NS_ENSURE_SUCCESS(rv, rv);
     }
   }
 
   // Add the placeholders to our primary child list.
-  // XXXbz this is a little screwed up, since the fixed frames will have the
-  // wrong parent block and hence auto-positioning will be broken.  Oh, well.
-  NS_ASSERTION(!docRootFrame->GetFirstChild(nsnull),
+  // XXXbz this is a little screwed up, since the fixed frames will have 
+  // broken auto-positioning. Oh, well.
+  NS_ASSERTION(!canvasFrame->GetFirstChild(nsnull),
                "leaking frames; doc root continuation must be empty");
-  docRootFrame->SetInitialChildList(nsnull, fixedPlaceholders.childList);
+  canvasFrame->SetInitialChildList(nsnull, fixedPlaceholders.childList);
   return NS_OK;
 }
 
 static PRBool
 IsBindingAncestor(nsIContent* aContent, nsIContent* aBindingRoot)
 {
   while (PR_TRUE) {
     // Native-anonymous content doesn't contain insertion points, so
@@ -12392,18 +12448,21 @@ nsCSSFrameConstructor::ConstructInline(n
 
   // Mark the frames as special (note: marking for inlineFrame is handled by
   // MoveFramesToEndOfIBSplit). That way if any of the append/insert/remove
   // methods try to fiddle with the children, the containing block will be
   // reframed instead.
   SetFrameIsSpecial(aNewFrame, blockFrame);
   SetFrameIsSpecial(blockFrame, inlineFrame);
   MarkIBSpecialPrevSibling(blockFrame, aNewFrame);
-
-#ifdef DEBUG
+  if (inlineFrame) {
+    MarkIBSpecialPrevSibling(inlineFrame, blockFrame);
+  }
+
+  #ifdef DEBUG
   if (gNoisyInlineConstruction) {
     nsIFrameDebug*  frameDebug;
 
     printf("nsCSSFrameConstructor::ConstructInline:\n");
     if (NS_SUCCEEDED(CallQueryInterface(aNewFrame, &frameDebug))) {
       printf("  ==> leading inline frame:\n");
       frameDebug->List(stdout, 2);
     }
@@ -12662,18 +12721,18 @@ nsCSSFrameConstructor::WipeContainingBlo
         return PR_FALSE;
       }
 
       // Walk up until we get a float containing block that's not part of an
       // {ib} split, since otherwise we might have to ship floats out of it
       // too.
       nsIFrame* floatContainer = aFrame;
       do {
-        floatContainer =
-          GetFloatContainingBlock(GetIBSplitSpecialPrevSibling(floatContainer));
+        floatContainer = GetFloatContainingBlock(
+          GetIBSplitSpecialPrevSiblingForAnonymousBlock(floatContainer));
         if (!floatContainer) {
           break;
         }
         if (!IsFrameSpecial(floatContainer)) {
           return PR_FALSE;
         }
       } while (1);
     }
@@ -12796,24 +12855,32 @@ nsCSSFrameConstructor::ReframeContaining
       }
     }
   }
 
   // If we get here, we're screwed!
   return ReconstructDocElementHierarchyInternal();
 }
 
-nsresult nsCSSFrameConstructor::RemoveFixedItems(const nsFrameConstructorState& aState)
+nsresult
+nsCSSFrameConstructor::RemoveFixedItems(const nsFrameConstructorState& aState,
+                                        nsIFrame *aRootElementFrame)
 {
   nsresult rv=NS_OK;
 
   if (mFixedContainingBlock) {
     nsIFrame *fixedChild = nsnull;
     do {
       fixedChild = mFixedContainingBlock->GetFirstChild(nsGkAtoms::fixedList);
+      if (fixedChild && fixedChild == aRootElementFrame) {
+        // Skip the root element frame, if it happens to be fixed-positioned
+        // It will be explicitly removed later in
+        // ReconstructDocElementHierarchyInternal
+        fixedChild = fixedChild->GetNextSibling();
+      }
       if (fixedChild) {
         // Remove the placeholder so it doesn't end up sitting about pointing
         // to the removed fixed frame.
         nsPlaceholderFrame *placeholderFrame =
           aState.mFrameManager->GetPlaceholderFrameFor(fixedChild);
         NS_ASSERTION(placeholderFrame, "no placeholder for fixed-pos frame");
         NS_ASSERTION(placeholderFrame->GetType() ==
                      nsGkAtoms::placeholderFrame,
diff -r b7bcdd009540 layout/base/nsCSSFrameConstructor.h
--- a/layout/base/nsCSSFrameConstructor.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/base/nsCSSFrameConstructor.h	Thu Sep 11 15:19:25 2008 +0300
@@ -265,17 +265,17 @@ private:
   nsresult ReinsertContent(nsIContent*    aContainer,
                            nsIContent*    aChild);
 
   nsresult ConstructPageFrame(nsIPresShell*  aPresShell, 
                               nsPresContext* aPresContext,
                               nsIFrame*      aParentFrame,
                               nsIFrame*      aPrevPageFrame,
                               nsIFrame*&     aPageFrame,
-                              nsIFrame*&     aPageContentFrame);
+                              nsIFrame*&     aCanvasFrame);
 
   void DoContentStateChanged(nsIContent*     aContent,
                              PRInt32         aStateMask);
 
   /* aMinHint is the minimal change that should be made to the element */
   void RestyleElement(nsIContent*     aContent,
                       nsIFrame*       aPrimaryFrame,
                       nsChangeHint    aMinHint);
@@ -1044,17 +1044,18 @@ private:
 
   nsresult InsertFirstLineFrames(nsFrameConstructorState& aState,
                                  nsIContent*              aContent,
                                  nsIFrame*                aBlockFrame,
                                  nsIFrame**               aParentFrame,
                                  nsIFrame*                aPrevSibling,
                                  nsFrameItems&            aFrameItems);
 
-  nsresult RemoveFixedItems(const nsFrameConstructorState& aState);
+  nsresult RemoveFixedItems(const nsFrameConstructorState& aState,
+                            nsIFrame*                      aRootElementFrame);
 
   // Find the right frame to use for aContent when looking for sibling
   // frames for aTargetContent.  If aPrevSibling is true, this
   // will look for last continuations, etc, as necessary.  This calls
   // IsValidSibling as needed; if that returns false it returns null.
   //
   // @param aTargetContentDisplay the CSS display enum for aTargetContent if
   // already known, UNSET_DISPLAY otherwise.
@@ -1159,16 +1160,19 @@ private:
     nsCOMPtr<nsIPresShell> mPresShell;
     nsLazyFrameConstructionCallback* mCallback;
     void* mArg;
   };
 
   nsIDocument*        mDocument;  // Weak ref
   nsIPresShell*       mPresShell; // Weak ref
 
+  // See the comment at the start of ConstructRootFrame for more details
+  // about the following frames.
+  
   // This is not the real CSS 2.1 "initial containing block"! It is just
   // the outermost frame for the root element.
   nsIFrame*           mInitialContainingBlock;
   // This is the frame for the root element that has no pseudo-element style.
   nsIFrame*           mRootElementStyleFrame;
   // This is the containing block for fixed-pos frames --- the viewport
   nsIFrame*           mFixedContainingBlock;
   // This is the containing block that contains the root element ---
@@ -1176,19 +1180,20 @@ private:
   nsIFrame*           mDocElementContainingBlock;
   nsIFrame*           mGfxScrollFrame;
   nsIFrame*           mPageSequenceFrame;
   nsQuoteList         mQuoteList;
   nsCounterManager    mCounterManager;
   PRUint16            mUpdateCount;
   PRPackedBool        mQuotesDirty : 1;
   PRPackedBool        mCountersDirty : 1;
-  PRPackedBool        mInitialContainingBlockIsAbsPosContainer : 1;
   PRPackedBool        mIsDestroyingFrameTree : 1;
   PRPackedBool        mRebuildAllStyleData : 1;
+  // This is true if mDocElementContainingBlock supports absolute positioning
+  PRPackedBool        mHasRootAbsPosContainingBlock : 1;
 
   nsRevocableEventPtr<RestyleEvent> mRestyleEvent;
 
   nsCOMPtr<nsILayoutHistoryState> mTempFrameTreeState;
 
   nsDataHashtable<nsISupportsHashKey, RestyleData> mPendingRestyles;
 
   static nsIXBLService * gXBLService;
diff -r b7bcdd009540 layout/base/nsCSSRendering.cpp
--- a/layout/base/nsCSSRendering.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/base/nsCSSRendering.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -637,16 +637,26 @@ nsCSSRendering::PaintBorder(nsPresContex
                          bgColor->mBackgroundColor);
   br.DrawBorders();
 
   ctx->Restore();
 
   SN();
 }
 
+static nsRect
+GetOutlineInnerRect(nsIFrame* aFrame)
+{
+  nsRect* savedOutlineInnerRect = static_cast<nsRect*>
+    (aFrame->GetProperty(nsGkAtoms::outlineInnerRectProperty));
+  if (savedOutlineInnerRect)
+    return *savedOutlineInnerRect;
+  return aFrame->GetOverflowRect();
+}
+
 void
 nsCSSRendering::PaintOutline(nsPresContext* aPresContext,
                              nsIRenderingContext& aRenderingContext,
                              nsIFrame* aForFrame,
                              const nsRect& aDirtyRect,
                              const nsRect& aBorderArea,
                              const nsStyleBorder& aBorderStyle,
                              const nsStyleOutline& aOutlineStyle,
@@ -666,76 +676,61 @@ nsCSSRendering::PaintOutline(nsPresConte
   }
 
   const nsStyleBackground* bgColor = nsCSSRendering::FindNonTransparentBackground
     (aStyleContext, PR_FALSE);
 
   // get the radius for our outline
   GetBorderRadiusTwips(aOutlineStyle.mOutlineRadius, aBorderArea.width, twipsRadii);
 
-  nscoord offset;
-  aOutlineStyle.GetOutlineOffset(offset);
-
   // When the outline property is set on :-moz-anonymous-block or
   // :-moz-anonyomus-positioned-block pseudo-elements, it inherited that
   // outline from the inline that was broken because it contained a
   // block.  In that case, we don't want a really wide outline if the
   // block inside the inline is narrow, so union the actual contents of
   // the anonymous blocks.
   nsIFrame *frameForArea = aForFrame;
   do {
     nsIAtom *pseudoType = frameForArea->GetStyleContext()->GetPseudoType();
     if (pseudoType != nsCSSAnonBoxes::mozAnonymousBlock &&
         pseudoType != nsCSSAnonBoxes::mozAnonymousPositionedBlock)
       break;
     // If we're done, we really want it and all its later siblings.
     frameForArea = frameForArea->GetFirstChild(nsnull);
     NS_ASSERTION(frameForArea, "anonymous block with no children?");
   } while (frameForArea);
-  nsRect overflowArea;
+  nsRect innerRect; // relative to aBorderArea.TopLeft()
   if (frameForArea == aForFrame) {
-    overflowArea = aForFrame->GetOverflowRect();
+    innerRect = GetOutlineInnerRect(aForFrame);
   } else {
     for (; frameForArea; frameForArea = frameForArea->GetNextSibling()) {
       // The outline has already been included in aForFrame's overflow
       // area, but not in those of its descendants, so we have to
       // include it.  Otherwise we'll end up drawing the outline inside
       // the border.
-      nsRect r(frameForArea->GetOverflowRect() +
+      nsRect r(GetOutlineInnerRect(frameForArea) +
                frameForArea->GetOffsetTo(aForFrame));
-      nscoord delta = PR_MAX(offset + width, 0);
-      r.Inflate(delta, delta);
-      overflowArea.UnionRect(overflowArea, r);
+      innerRect.UnionRect(innerRect, r);
     }
   }
 
-  nsRect outerRect(overflowArea + aBorderArea.TopLeft());
-  nsRect innerRect(outerRect);
-  if (width + offset >= 0) {
-    // the overflow area is exactly the outside edge of the outline
-    innerRect.Deflate(width, width);
-  } else {
-    // the overflow area is exactly the rectangle containing the frame and its
-    // children; we can compute the outline directly
-    innerRect.Deflate(-offset, -offset);
-    if (innerRect.width < 0 || innerRect.height < 0) {
-      return; // Protect against negative outline sizes
-    }
-    outerRect = innerRect;
-    outerRect.Inflate(width, width);
-  }
-
+  innerRect += aBorderArea.TopLeft();
+  nscoord offset;
+  aOutlineStyle.GetOutlineOffset(offset);
+  innerRect.Inflate(offset, offset);
   // If the dirty rect is completely inside the border area (e.g., only the
   // content is being painted), then we can skip out now
   // XXX this isn't exactly true for rounded borders, where the inside curves may
   // encroach into the content area.  A safer calculation would be to
   // shorten insideRect by the radius one each side before performing this test.
-  if (innerRect.Contains(aDirtyRect)) {
+  if (innerRect.Contains(aDirtyRect))
     return;
-  }
+
+  nsRect outerRect = innerRect;
+  outerRect.Inflate(width, width);
 
   // Get our conversion values
   nscoord twipsPerPixel = aPresContext->DevPixelsToAppUnits(1);
 
   // get the outer rectangles
   gfxRect oRect(RectToGfxRect(outerRect, twipsPerPixel));
 
   // convert the radii
diff -r b7bcdd009540 layout/base/nsCaret.cpp
--- a/layout/base/nsCaret.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/base/nsCaret.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -1005,16 +1005,17 @@ PRBool nsCaret::MustDrawCaret(PRBool aIg
   if (IsMenuPopupHidingCaret())
     return PR_FALSE;
 
   return isCollapsed;
 }
 
 PRBool nsCaret::IsMenuPopupHidingCaret()
 {
+#ifdef MOZ_XUL
   // Check if there are open popups.
   nsXULPopupManager *popMgr = nsXULPopupManager::GetInstance();
   nsTArray<nsIFrame*> popups = popMgr->GetOpenPopups();
 
   if (popups.Length() == 0)
     return PR_FALSE; // No popups, so caret can't be hidden by them.
 
   // Get the selection focus content, that's where the caret would 
@@ -1044,16 +1045,17 @@ PRBool nsCaret::IsMenuPopupHidingCaret()
 
     if (popupFrame->PopupType() == ePopupTypeMenu && !popupFrame->IsContextMenu()) {
       // This is an open menu popup. It does not contain the caret (else we'd
       // have returned above). Even if the caret is in a subsequent popup,
       // or another document/frame, it should be hidden.
       return PR_TRUE;
     }
   }
+#endif
 
   // There are no open menu popups, no need to hide the caret.
   return PR_FALSE;
 }
 
 /*-----------------------------------------------------------------------------
 
   DrawCaret
diff -r b7bcdd009540 layout/base/nsDisplayList.cpp
--- a/layout/base/nsDisplayList.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/base/nsDisplayList.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -46,16 +46,19 @@
 
 #include "nsCSSRendering.h"
 #include "nsISelectionController.h"
 #include "nsIPresShell.h"
 #include "nsRegion.h"
 #include "nsFrameManager.h"
 #include "gfxContext.h"
 #include "nsStyleStructInlines.h"
+#ifdef MOZ_SVG
+#include "nsSVGIntegrationUtils.h"
+#endif
 
 nsDisplayListBuilder::nsDisplayListBuilder(nsIFrame* aReferenceFrame,
     PRBool aIsForEvents, PRBool aBuildCaret)
     : mReferenceFrame(aReferenceFrame),
       mMovingFrame(nsnull),
       mIgnoreScrollFrame(nsnull),
       mCurrentTableItem(nsnull),
       mBuildCaret(aBuildCaret),
@@ -260,16 +263,25 @@ nsDisplayList::FlattenTo(nsTArray<nsDisp
   while ((item = RemoveBottom()) != nsnull) {
     if (item->GetType() == nsDisplayItem::TYPE_WRAPLIST) {
       item->GetList()->FlattenTo(aElements);
       item->~nsDisplayItem();
     } else {
       aElements->AppendElement(item);
     }
   }
+}
+
+nsRect
+nsDisplayList::GetBounds(nsDisplayListBuilder* aBuilder) const {
+  nsRect bounds;
+  for (nsDisplayItem* i = GetBottom(); i != nsnull; i = i->GetAbove()) {
+    bounds.UnionRect(bounds, i->GetBounds(aBuilder));
+  }
+  return bounds;
 }
 
 void
 nsDisplayList::OptimizeVisibility(nsDisplayListBuilder* aBuilder,
                                   nsRegion* aVisibleRegion) {
   nsAutoTArray<nsDisplayItem*, 512> elements;
   FlattenTo(&elements);
 
@@ -666,21 +678,17 @@ nsIFrame*
 nsIFrame*
 nsDisplayWrapList::HitTest(nsDisplayListBuilder* aBuilder, nsPoint aPt,
                            HitTestState* aState) {
   return mList.HitTest(aBuilder, aPt, aState);
 }
 
 nsRect
 nsDisplayWrapList::GetBounds(nsDisplayListBuilder* aBuilder) {
-  nsRect bounds;
-  for (nsDisplayItem* i = mList.GetBottom(); i != nsnull; i = i->GetAbove()) {
-    bounds.UnionRect(bounds, i->GetBounds(aBuilder));
-  }
-  return bounds;
+  return mList.GetBounds(aBuilder);
 }
 
 PRBool
 nsDisplayWrapList::OptimizeVisibility(nsDisplayListBuilder* aBuilder,
                                       nsRegion* aVisibleRegion) {
   mList.OptimizeVisibility(aBuilder, aVisibleRegion);
   // If none of the items are visible, they will all have been deleted
   return mList.GetTop() != nsnull;
@@ -923,8 +931,77 @@ PRBool nsDisplayClip::TryMerge(nsDisplay
   return PR_TRUE;
 }
 
 nsDisplayWrapList* nsDisplayClip::WrapWithClone(nsDisplayListBuilder* aBuilder,
                                                 nsDisplayItem* aItem) {
   return new (aBuilder)
     nsDisplayClip(aItem->GetUnderlyingFrame(), mClippingFrame, aItem, mClip);
 }
+
+#ifdef MOZ_SVG
+nsDisplaySVGEffects::nsDisplaySVGEffects(nsIFrame* aFrame, nsDisplayList* aList)
+    : nsDisplayWrapList(aFrame, aList), mEffectsFrame(aFrame),
+      mBounds(aFrame->GetOverflowRect())
+{
+  MOZ_COUNT_CTOR(nsDisplaySVGEffects);
+}
+
+#ifdef NS_BUILD_REFCNT_LOGGING
+nsDisplaySVGEffects::~nsDisplaySVGEffects()
+{
+  MOZ_COUNT_DTOR(nsDisplaySVGEffects);
+}
+#endif
+
+PRBool nsDisplaySVGEffects::IsOpaque(nsDisplayListBuilder* aBuilder)
+{
+  return PR_FALSE;
+}
+
+nsIFrame*
+nsDisplaySVGEffects::HitTest(nsDisplayListBuilder* aBuilder, nsPoint aPt,
+                             HitTestState* aState)
+{
+  if (!nsSVGIntegrationUtils::HitTestFrameForEffects(mEffectsFrame,
+          aPt - aBuilder->ToReferenceFrame(mEffectsFrame)))
+    return nsnull;
+  return mList.HitTest(aBuilder, aPt, aState);
+}
+
+void nsDisplaySVGEffects::Paint(nsDisplayListBuilder* aBuilder,
+                                nsIRenderingContext* aCtx, const nsRect& aDirtyRect)
+{
+  nsSVGIntegrationUtils::PaintFramesWithEffects(aCtx,
+          mEffectsFrame, aDirtyRect, aBuilder, &mList);
+}
+
+PRBool nsDisplaySVGEffects::OptimizeVisibility(nsDisplayListBuilder* aBuilder,
+                                               nsRegion* aVisibleRegion) {
+  nsRegion vis;
+  vis.And(*aVisibleRegion, GetBounds(aBuilder));
+  nsPoint offset = aBuilder->ToReferenceFrame(mEffectsFrame);
+  nsRect dirtyRect = nsSVGIntegrationUtils::GetRequiredSourceForInvalidArea(mEffectsFrame,
+       vis.GetBounds() - offset) + offset;
+
+  // Our children may be translucent so we should not allow them to subtract
+  // area from aVisibleRegion.
+  nsRegion childrenVisibleRegion(dirtyRect);
+  nsDisplayWrapList::OptimizeVisibility(aBuilder, &childrenVisibleRegion);
+  return !vis.IsEmpty();
+}
+
+PRBool nsDisplaySVGEffects::TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem)
+{
+  if (aItem->GetType() != TYPE_SVG_EFFECTS)
+    return PR_FALSE;
+  // items for the same content element should be merged into a single
+  // compositing group
+  // aItem->GetUnderlyingFrame() returns non-null because it's nsDisplaySVGEffects
+  if (aItem->GetUnderlyingFrame()->GetContent() != mFrame->GetContent())
+    return PR_FALSE;
+  nsDisplaySVGEffects* other = static_cast<nsDisplaySVGEffects*>(aItem);
+  mList.AppendToBottom(&other->mList);
+  mBounds.UnionRect(mBounds,
+    other->mBounds + other->mEffectsFrame->GetOffsetTo(mEffectsFrame));
+  return PR_TRUE;
+}
+#endif
diff -r b7bcdd009540 layout/base/nsDisplayList.h
--- a/layout/base/nsDisplayList.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/base/nsDisplayList.h	Thu Sep 11 15:19:25 2008 +0300
@@ -387,16 +387,19 @@ public:
    * It's useful to be able to dynamically check the type of certain items.
    * For items whose type never gets checked, TYPE_GENERIC will suffice.
    */
   enum Type {
     TYPE_GENERIC,
     TYPE_OUTLINE,
     TYPE_CLIP,
     TYPE_OPACITY,
+#ifdef MOZ_SVG
+    TYPE_SVG_EFFECTS,
+#endif
     TYPE_WRAPLIST
   };
 
   struct HitTestState {
     ~HitTestState() {
       NS_ASSERTION(mItemBuffer.Length() == 0,
                    "mItemBuffer should have been cleared");
     }
@@ -689,16 +692,20 @@ public:
    * Paint the list to the rendering context. We assume that (0,0) in aCtx
    * corresponds to the origin of the reference frame. For best results,
    * aCtx's current transform should make (0,0) pixel-aligned. The
    * rectangle in aDirtyRect is painted, which *must* be contained in the
    * dirty rect used to construct the display list.
    */
   void Paint(nsDisplayListBuilder* aBuilder, nsIRenderingContext* aCtx,
              const nsRect& aDirtyRect) const;
+  /**
+   * Get the bounds. Takes the union of the bounds of all children.
+   */
+  nsRect GetBounds(nsDisplayListBuilder* aBuilder) const;
   /**
    * Find the topmost display item that returns a non-null frame, and return
    * the frame.
    */
   nsIFrame* HitTest(nsDisplayListBuilder* aBuilder, nsPoint aPt,
                     nsDisplayItem::HitTestState* aState) const;
 
 private:
@@ -1247,9 +1254,44 @@ private:
   // The frame that is responsible for the clipping. This may be different
   // from mFrame because mFrame represents the content that is being
   // clipped, and for example may be used to obtain the z-index of the
   // content.
   nsIFrame* mClippingFrame;
   nsRect    mClip;
 };
 
+#ifdef MOZ_SVG
+/**
+ * A display item to paint a stacking context with effects
+ * set by the stacking context root frame's style.
+ */
+class nsDisplaySVGEffects : public nsDisplayWrapList {
+public:
+  nsDisplaySVGEffects(nsIFrame* aFrame, nsDisplayList* aList);
+#ifdef NS_BUILD_REFCNT_LOGGING
+  virtual ~nsDisplaySVGEffects();
+#endif
+  
+  virtual Type GetType() { return TYPE_SVG_EFFECTS; }
+  virtual PRBool IsOpaque(nsDisplayListBuilder* aBuilder);
+  virtual nsIFrame* HitTest(nsDisplayListBuilder* aBuilder, nsPoint aPt,
+                            HitTestState* aState);
+  virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder) {
+    return mBounds + aBuilder->ToReferenceFrame(mEffectsFrame);
+  }
+  virtual void Paint(nsDisplayListBuilder* aBuilder, nsIRenderingContext* aCtx,
+     const nsRect& aDirtyRect);
+  virtual PRBool OptimizeVisibility(nsDisplayListBuilder* aBuilder,
+                                    nsRegion* aVisibleRegion);  
+  virtual PRBool TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem);
+  NS_DISPLAY_DECL_NAME("SVGEffects")
+
+  nsIFrame* GetEffectsFrame() { return mEffectsFrame; }
+
+private:
+  nsIFrame* mEffectsFrame;
+  // relative to mEffectsFrame
+  nsRect    mBounds;
+};
+#endif
+
 #endif /*NSDISPLAYLIST_H_*/
diff -r b7bcdd009540 layout/base/nsDocumentViewer.cpp
--- a/layout/base/nsDocumentViewer.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/base/nsDocumentViewer.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -1856,25 +1856,20 @@ DocumentViewerImpl::Show(void)
       // SHistory and we need the SHistory to evict content viewers
       nsCOMPtr<nsIDocShellTreeItem> root;
       treeItem->GetSameTypeRootTreeItem(getter_AddRefs(root));
       nsCOMPtr<nsIWebNavigation> webNav = do_QueryInterface(root);
       nsCOMPtr<nsISHistory> history;
       webNav->GetSessionHistory(getter_AddRefs(history));
       nsCOMPtr<nsISHistoryInternal> historyInt = do_QueryInterface(history);
       if (historyInt) {
-        PRInt32 prevIndex,loadedIndex;
-        nsCOMPtr<nsIDocShell> docShell = do_QueryInterface(treeItem);
-        docShell->GetPreviousTransIndex(&prevIndex);
-        docShell->GetLoadedTransIndex(&loadedIndex);
 #ifdef DEBUG_PAGE_CACHE
-        printf("About to evict content viewers: prev=%d, loaded=%d\n",
-               prevIndex, loadedIndex);
-#endif
-        historyInt->EvictContentViewers(prevIndex, loadedIndex);
+        printf("About to evict content viewers\n");
+#endif
+        historyInt->EvictContentViewers();
       }
     }
   }
 
   if (mWindow) {
     mWindow->Show(PR_TRUE);
   }
 
diff -r b7bcdd009540 layout/base/nsImageLoader.cpp
--- a/layout/base/nsImageLoader.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/base/nsImageLoader.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -207,20 +207,17 @@ NS_IMETHODIMP nsImageLoader::FrameChange
 }
 
 
 void
 nsImageLoader::RedrawDirtyFrame(const nsRect* aDamageRect)
 {
   if (mReflowOnLoad) {
     nsIPresShell *shell = mPresContext->GetPresShell();
-#ifdef DEBUG
-    nsresult rv = 
-#endif
-      shell->FrameNeedsReflow(mFrame, nsIPresShell::eStyleChange, NS_FRAME_IS_DIRTY);
+    nsresult rv = shell->FrameNeedsReflow(mFrame, nsIPresShell::eStyleChange, NS_FRAME_IS_DIRTY);
     NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "Could not reflow after loading border-image");
     // The reflow might not do all the invalidation we need, so continue
     // on with the invalidation codepath.
   }
   // NOTE: It is not sufficient to invalidate only the size of the image:
   //       the image may be tiled! 
   //       The best option is to call into the frame, however lacking this
   //       we have to at least invalidate the frame's bounds, hence
diff -r b7bcdd009540 layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/base/nsLayoutUtils.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -74,16 +74,17 @@
 #include "nsPIDOMWindow.h"
 #include "nsIBaseWindow.h"
 #include "nsIDocShell.h"
 #include "nsIDocShellTreeItem.h"
 #include "nsIWidget.h"
 
 #ifdef MOZ_SVG
 #include "nsSVGUtils.h"
+#include "nsSVGIntegrationUtils.h"
 #include "nsSVGForeignObjectFrame.h"
 #include "nsSVGOuterSVGFrame.h"
 #endif
 
 /**
  * A namespace class for static layout utilities.
  */
 
@@ -1032,17 +1033,29 @@ static void
 static void
 AddItemsToRegion(nsDisplayListBuilder* aBuilder, nsDisplayList* aList,
                  const nsRect& aRect, const nsRect& aClipRect, nsPoint aDelta,
                  nsRegion* aRegion)
 {
   for (nsDisplayItem* item = aList->GetBottom(); item; item = item->GetAbove()) {
     nsDisplayList* sublist = item->GetList();
     if (sublist) {
-      if (item->GetType() == nsDisplayItem::TYPE_CLIP) {
+      nsDisplayItem::Type type = item->GetType();
+#ifdef MOZ_SVG
+      if (type == nsDisplayItem::TYPE_SVG_EFFECTS) {
+        nsDisplaySVGEffects* effectsItem = static_cast<nsDisplaySVGEffects*>(item);
+        if (!aBuilder->IsMovingFrame(effectsItem->GetEffectsFrame())) {
+          // Invalidate the whole thing
+          nsRect r;
+          r.IntersectRect(aClipRect, effectsItem->GetBounds(aBuilder));
+          aRegion->Or(*aRegion, r);
+        }
+      } else
+#endif
+      if (type == nsDisplayItem::TYPE_CLIP) {
         nsDisplayClip* clipItem = static_cast<nsDisplayClip*>(item);
         nsRect clip = aClipRect;
         // If the clipping frame is moving, then it isn't clipping any
         // non-moving content (see ApplyAbsPosClipping), so we don't need
         // to do anything special, but we should not restrict aClipRect.
         if (!aBuilder->IsMovingFrame(clipItem->GetClippingFrame())) {
           clip.IntersectRect(clip, clipItem->GetClipRect());
 
@@ -1236,55 +1249,73 @@ nsLayoutUtils::BinarySearchForPosition(n
     if (BinarySearchForPosition(aRendContext, aText, aBaseWidth, aBaseInx, inx, aEndInx, aCursorPos, aIndex, aTextWidth)) {
       return PR_TRUE;
     }
   }
   return PR_FALSE;
 }
 
 static void
-AddRectsForFrame(nsIFrame* aFrame, nsIFrame* aRelativeTo,
-                 nsLayoutUtils::RectCallback* aCallback)
+AddBoxesForFrame(nsIFrame* aFrame,
+                 nsLayoutUtils::BoxCallback* aCallback)
 {
   nsIAtom* pseudoType = aFrame->GetStyleContext()->GetPseudoType();
 
   if (pseudoType == nsCSSAnonBoxes::tableOuter) {
-    AddRectsForFrame(aFrame->GetFirstChild(nsnull), aRelativeTo,
-                     aCallback);
+    AddBoxesForFrame(aFrame->GetFirstChild(nsnull), aCallback);
     nsIFrame* kid = aFrame->GetFirstChild(nsGkAtoms::captionList);
     if (kid) {
-      AddRectsForFrame(kid, aRelativeTo, aCallback);
+      AddBoxesForFrame(kid, aCallback);
     }
   } else if (pseudoType == nsCSSAnonBoxes::mozAnonymousBlock ||
              pseudoType == nsCSSAnonBoxes::mozAnonymousPositionedBlock ||
              pseudoType == nsCSSAnonBoxes::mozMathMLAnonymousBlock ||
              pseudoType == nsCSSAnonBoxes::mozXULAnonymousBlock) {
     for (nsIFrame* kid = aFrame->GetFirstChild(nsnull); kid; kid = kid->GetNextSibling()) {
-      AddRectsForFrame(kid, aRelativeTo, aCallback);
+      AddBoxesForFrame(kid, aCallback);
     }
   } else {
+    aCallback->AddBox(aFrame);
+  }
+}
+
+void
+nsLayoutUtils::GetAllInFlowBoxes(nsIFrame* aFrame, BoxCallback* aCallback)
+{
+  while (aFrame) {
+    AddBoxesForFrame(aFrame, aCallback);
+    aFrame = nsLayoutUtils::GetNextContinuationOrSpecialSibling(aFrame);
+  }
+}
+
+struct BoxToBorderRect : public nsLayoutUtils::BoxCallback {
+  nsIFrame*                    mRelativeTo;
+  nsLayoutUtils::RectCallback* mCallback;
+
+  BoxToBorderRect(nsIFrame* aRelativeTo, nsLayoutUtils::RectCallback* aCallback)
+    : mCallback(aCallback), mRelativeTo(aRelativeTo) {}
+
+  virtual void AddBox(nsIFrame* aFrame) {
 #ifdef MOZ_SVG
     nsRect r;
     nsIFrame* outer = nsSVGUtils::GetOuterSVGFrameAndCoveredRegion(aFrame, &r);
     if (outer) {
-      aCallback->AddRect(r + outer->GetOffsetTo(aRelativeTo));
+      mCallback->AddRect(r + outer->GetOffsetTo(mRelativeTo));
     } else
 #endif
-      aCallback->AddRect(nsRect(aFrame->GetOffsetTo(aRelativeTo), aFrame->GetSize()));
+      mCallback->AddRect(nsRect(aFrame->GetOffsetTo(mRelativeTo), aFrame->GetSize()));
   }
-}
+};
 
 void
 nsLayoutUtils::GetAllInFlowRects(nsIFrame* aFrame, nsIFrame* aRelativeTo,
                                  RectCallback* aCallback)
 {
-  while (aFrame) {
-    AddRectsForFrame(aFrame, aRelativeTo, aCallback);
-    aFrame = nsLayoutUtils::GetNextContinuationOrSpecialSibling(aFrame);
-  }
+  BoxToBorderRect converter(aRelativeTo, aCallback);
+  GetAllInFlowBoxes(aFrame, &converter);
 }
 
 struct RectAccumulator : public nsLayoutUtils::RectCallback {
   nsRect       mResultRect;
   nsRect       mFirstRect;
   PRPackedBool mSeenFirstRect;
 
   RectAccumulator() : mSeenFirstRect(PR_FALSE) {}
@@ -1468,16 +1499,33 @@ nsLayoutUtils::GetNextContinuationOrSpec
     // frame in the flow. Walk back to find that frame now.
     aFrame = aFrame->GetFirstInFlow();
 
     void* value = aFrame->GetProperty(nsGkAtoms::IBSplitSpecialSibling);
     return static_cast<nsIFrame*>(value);
   }
 
   return nsnull;
+}
+
+nsIFrame*
+nsLayoutUtils::GetFirstContinuationOrSpecialSibling(nsIFrame *aFrame)
+{
+  nsIFrame *result = aFrame->GetFirstContinuation();
+  if (result->GetStateBits() & NS_FRAME_IS_SPECIAL) {
+    while (PR_TRUE) {
+      nsIFrame *f = static_cast<nsIFrame*>
+        (result->GetProperty(nsGkAtoms::IBSplitSpecialPrevSibling));
+      if (!f)
+        break;
+      result = f;
+    }
+  }
+
+  return result;
 }
 
 PRBool
 nsLayoutUtils::IsViewportScrollbarFrame(nsIFrame* aFrame)
 {
   if (!aFrame)
     return PR_FALSE;
 
@@ -1848,16 +1896,17 @@ nsLayoutUtils::IntrinsicForContainer(nsI
 /* static */ nscoord
 nsLayoutUtils::ComputeWidthDependentValue(
                  nscoord              aContainingBlockWidth,
                  const nsStyleCoord&  aCoord)
 {
   NS_PRECONDITION(aContainingBlockWidth != NS_UNCONSTRAINEDSIZE,
                   "unconstrained widths no longer supported");
 
+  nscoord result;
   if (eStyleUnit_Coord == aCoord.GetUnit()) {
     return aCoord.GetCoordValue();
   }
   if (eStyleUnit_Percent == aCoord.GetUnit()) {
     return NSToCoordFloor(aContainingBlockWidth * aCoord.GetPercentValue());
   }
   NS_ASSERTION(aCoord.GetUnit() == eStyleUnit_None ||
                aCoord.GetUnit() == eStyleUnit_Auto,
@@ -1925,16 +1974,17 @@ nsLayoutUtils::ComputeWidthValue(
 }
 
 
 /* static */ nscoord
 nsLayoutUtils::ComputeHeightDependentValue(
                  nscoord              aContainingBlockHeight,
                  const nsStyleCoord&  aCoord)
 {
+  nscoord result;
   if (eStyleUnit_Coord == aCoord.GetUnit()) {
     return aCoord.GetCoordValue();
   }
   if (eStyleUnit_Percent == aCoord.GetUnit()) {
     // XXXldb Some callers explicitly check aContainingBlockHeight
     // against NS_AUTOHEIGHT *and* unit against eStyleUnit_Percent
     // before calling this function, so this assertion probably needs to
     // be inside the percentage case.  However, it would be much more
diff -r b7bcdd009540 layout/base/nsLayoutUtils.h
--- a/layout/base/nsLayoutUtils.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/base/nsLayoutUtils.h	Thu Sep 11 15:19:25 2008 +0300
@@ -481,16 +481,29 @@ public:
                           PRInt32    aBaseWidth,
                           PRInt32    aBaseInx,
                           PRInt32    aStartInx, 
                           PRInt32    aEndInx, 
                           PRInt32    aCursorPos, 
                           PRInt32&   aIndex,
                           PRInt32&   aTextWidth);
 
+  class BoxCallback {
+  public:
+    virtual void AddBox(nsIFrame* aFrame) = 0;
+  };
+  /**
+   * Collect all CSS boxes associated with aFrame and its
+   * continuations, "drilling down" through outer table frames and
+   * some anonymous blocks since they're not real CSS boxes.
+   * If aFrame is null, no boxes are returned.
+   * SVG frames return a single box, themselves.
+   */
+  static void GetAllInFlowBoxes(nsIFrame* aFrame, BoxCallback* aCallback);
+
   class RectCallback {
   public:
     virtual void AddRect(const nsRect& aRect) = 0;
   };
   /**
    * Collect all CSS border-boxes associated with aFrame and its
    * continuations, "drilling down" through outer table frames and
    * some anonymous blocks since they're not real CSS boxes.
@@ -574,16 +587,23 @@ public:
                                           nsIFrame* aKnownCommonAncestorHint);
 
   /**
    * Get a frame's next-in-flow, or, if it doesn't have one, its special sibling.
    */
   static nsIFrame*
   GetNextContinuationOrSpecialSibling(nsIFrame *aFrame);
 
+  /**
+   * Get the first frame in the continuation-plus-special-sibling chain
+   * containing aFrame.
+   */
+  static nsIFrame*
+  GetFirstContinuationOrSpecialSibling(nsIFrame *aFrame);
+  
   /**
    * Check whether aFrame is a part of the scrollbar or scrollcorner of
    * the root content.
    * @param aFrame the checking frame
    * @return if TRUE, the frame is a part of the scrollbar or scrollcorner of
    *         the root content.
    */
   static PRBool IsViewportScrollbarFrame(nsIFrame* aFrame);
diff -r b7bcdd009540 layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/base/nsPresShell.cpp	Thu Sep 11 15:19:25 2008 +0300
@@ -2695,17 +2695,18 @@ void PresShell::SetCaret(nsCaret *aNewCa
 
 void PresShell::RestoreCaret()
 {
   mCaret = mOriginalCaret;
 }
 
 NS_IMETHODIMP PresShell::SetCaretEnabled(PRBool aInEnable)
 {
-  PRBool oldEnabled = mCaretEnabled;
+  nsresult result = NS_OK;
+  PRBool   oldEnabled = mCaretEnabled;
 
   mCaretEnabled = aInEnable;
 
   if (mCaret && (mCaretEnabled != oldEnabled))
   {
 /*  Don't change the caret's selection here! This was an evil side-effect of SetCaretEnabled()
     nsCOMPtr<nsIDOMSelection> domSel;
     if (NS_SUCCEEDED(GetSelection(nsISelectionController::SELECTION_NORMAL, getter_AddRefs(domSel))) && domSel)
@@ -4575,16 +4576,17 @@ PresShell::DoFlushPendingNotifications(m
     }
 
     // There might be more pending constructors now, but we're not going to
     // worry about them.  They can't be triggered during reflow, so we should
     // be good.
     
     if (aType >= Flush_Layout && !mIsDestroying) {
       mFrameConstructor->RecalcQuotesAndCounters();
+      mViewManager->FlushDelayedResize();
       ProcessReflowCommands(aInterruptibleReflow);
     }
 
     PRUint32 updateFlags = NS_VMREFRESH_NO_SYNC;
     if (aType >= Flush_Display) {
       // Flushing paints, so perform the invalidates and drawing
       // immediately
       updateFlags = NS_VMREFRESH_IMMEDIATE;
diff -r b7bcdd009540 layout/base/tests/Makefile.in
--- a/layout/base/tests/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/base/tests/Makefile.in	Thu Sep 11 15:19:25 2008 +0300
@@ -73,18 +73,16 @@ LIBS		+= \
 		$(NULL)
 
 endif # false
 
 include $(topsrcdir)/config/rules.mk
 
 DEFINES += -D_IMPL_NS_LAYOUT
 
-ifdef MOZ_MOCHITEST
-
 _TEST_FILES =	\
 		test_bug66619.html \
 		test_bug386575.xhtml \
 		test_bug388019.html \
 		test_bug394057.html \
 		test_bug396024.html \
 		test_bug399284.html \
 		test_bug399951.html \
@@ -96,10 +94,8 @@ _TEST_FILES =	\
 		test_bug449781.html \
 		$(NULL)
 # test_bug396024.html is currently disabled because it interacts badly with
 # the "You can't print-preview while the page is loading" dialog.
 # (See bug 407080)
 
 libs:: $(_TEST_FILES)
 	$(INSTALL) $(foreach f,$^,"$f") $(DEPTH)/_tests/testing/mochitest/tests/$(relativesrcdir)
-
-endif # MOZ_MOCHITEST
diff -r b7bcdd009540 layout/forms/Makefile.in
--- a/layout/forms/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/forms/Makefile.in	Thu Sep 11 15:19:25 2008 +0300
@@ -39,17 +39,17 @@ topsrcdir	= @top_srcdir@
 topsrcdir	= @top_srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 DIRS = $(NULL)
 
-ifdef MOZ_MOCHITEST
+ifdef ENABLE_TESTS
 DIRS		+= test
 endif
 
 MODULE		= layout
 LIBRARY_NAME	= gkforms_s
 LIBXUL_LIBRARY	= 1
 
 REQUIRES	= xpcom \
diff -r b7bcdd009540 layout/forms/nsFileControlFrame.h
--- a/layout/forms/nsFileControlFrame.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/forms/nsFileControlFrame.h	Thu Sep 11 15:19:25 2008 +0300
@@ -177,17 +177,17 @@ private:
   /**
    * Copy an attribute from file content to text and button content.
    * @param aNameSpaceID namespace of attr
    * @param aAttribute attribute atom
    * @param aWhichControls which controls to apply to (SYNC_TEXT or SYNC_FILE
    *        or SYNC_BOTH)
    */
   void SyncAttr(PRInt32 aNameSpaceID, nsIAtom* aAttribute,
-                PRBool aWhichControls);
+                PRInt32 aWhichControls);
 
   NS_IMETHOD_(nsrefcnt) AddRef() { return 1; }
   NS_IMETHOD_(nsrefcnt) Release() { return 1; }
 };
 
 #endif
 
 
diff -r b7bcdd009540 layout/forms/nsListControlFrame.cpp
--- a/layout/forms/nsListControlFrame.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/forms/nsListControlFrame.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -666,19 +666,17 @@ nsListControlFrame::ReflowAsDropdown(nsP
                                      nsReflowStatus&          aStatus)
 {
   NS_PRECONDITION(aReflowState.ComputedHeight() == NS_UNCONSTRAINEDSIZE,
                   "We should not have a computed height here!");
   
   mMightNeedSecondPass = NS_SUBTREE_DIRTY(this) ||
     aReflowState.ShouldReflowAllKids();
 
-#ifdef DEBUG
   nscoord oldHeightOfARow = HeightOfARow();
-#endif
 
   nsHTMLReflowState state(aReflowState);
 
   nscoord oldVisibleHeight;
   if (!(GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
     // When not doing an initial reflow, and when the height is auto, start off
     // with our computed height set to what we'd expect our height to be.
     // Note: At this point, mLastDropdownComputedHeight can be
@@ -1542,26 +1540,23 @@ PRBool
 PRBool
 nsListControlFrame::SetOptionsSelectedFromFrame(PRInt32 aStartIndex,
                                                 PRInt32 aEndIndex,
                                                 PRBool aValue,
                                                 PRBool aClearAll)
 {
   nsCOMPtr<nsISelectElement> selectElement(do_QueryInterface(mContent));
   PRBool wasChanged = PR_FALSE;
-#ifdef DEBUG
-  nsresult rv = 
-#endif
-    selectElement->SetOptionsSelectedByIndex(aStartIndex,
-                                             aEndIndex,
-                                             aValue,
-                                             aClearAll,
-                                             PR_FALSE,
-                                             PR_TRUE,
-                                             &wasChanged);
+  nsresult rv = selectElement->SetOptionsSelectedByIndex(aStartIndex,
+                                                         aEndIndex,
+                                                         aValue,
+                                                         aClearAll,
+                                                         PR_FALSE,
+                                                         PR_TRUE,
+                                                         &wasChanged);
   NS_ASSERTION(NS_SUCCEEDED(rv), "SetSelected failed");
   return wasChanged;
 }
 
 PRBool
 nsListControlFrame::ToggleOptionSelectedFromFrame(PRInt32 aIndex)
 {
   nsCOMPtr<nsIDOMHTMLOptionsCollection> options = GetOptions(mContent);
diff -r b7bcdd009540 layout/forms/resources/content/contents.rdf
--- a/layout/forms/resources/content/contents.rdf	Mon Sep 08 00:36:19 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,53 +0,0 @@
-<?xml version="1.0"?>
-<!-- ***** BEGIN LICENSE BLOCK *****
-   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
-   -
-   - The contents of this file are subject to the Mozilla Public License Version
-   - 1.1 (the "License"); you may not use this file except in compliance with
-   - the License. You may obtain a copy of the License at
-   - http://www.mozilla.org/MPL/
-   -
-   - Software distributed under the License is distributed on an "AS IS" basis,
-   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-   - for the specific language governing rights and limitations under the
-   - License.
-   -
-   - The Original Code is mozilla.org code.
-   -
-   - The Initial Developer of the Original Code is
-   - Netscape Communications Corporation.
-   - Portions created by the Initial Developer are Copyright (C) 2001
-   - the Initial Developer. All Rights Reserved.
-   -
-   - Contributor(s):
-   -  Brian Ryner <bryner@brianryner.com>
-   -
-   - Alternatively, the contents of this file may be used under the terms of
-   - either the GNU General Public License Version 2 or later (the "GPL"), or
-   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-   - in which case the provisions of the GPL or the LGPL are applicable instead
-   - of those above. If you wish to allow use of your version of this file only
-   - under the terms of either the GPL or the LGPL, and not to allow others to
-   - use your version of this file under the terms of the MPL, indicate your
-   - decision by deleting the provisions above and replace them with the notice
-   - and other provisions required by the LGPL or the GPL. If you do not delete
-   - the provisions above, a recipient may use your version of this file under
-   - the terms of any one of the MPL, the GPL or the LGPL.
-   -
-   - ***** END LICENSE BLOCK ***** -->
-
-<RDF:RDF xmlns:RDF="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-         xmlns:chrome="http://www.mozilla.org/rdf/chrome#">
-
-<RDF:Seq about="urn:mozilla:package:root">
-<RDF:li resource="urn:mozilla:package:forms"/>
-</RDF:Seq>
-
-<RDF:Description about="urn:mozilla:package:forms"
-        chrome:displayName="Forms"
-        chrome:author="mozilla.org"
-        chrome:name="forms"
-#expand         chrome:skinVersion="__MOZILLA_SKIN_VERSION__">
-</RDF:Description>
-
-</RDF:RDF>
diff -r b7bcdd009540 layout/forms/resources/jar.mn
--- a/layout/forms/resources/jar.mn	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/forms/resources/jar.mn	Thu Sep 11 15:19:26 2008 +0300
@@ -1,26 +1,23 @@ forms.jar:
 forms.jar:
-*   content/forms/contents.rdf                (content/contents.rdf)
     content/forms/xbl-forms.css               (content/xbl-forms.css)
     content/forms/select.xml                  (content/select.xml)
     content/forms/checkbox.xml                (content/checkbox.xml)
     content/forms/button.xml                  (content/button.xml)
     content/forms/radio.xml                   (content/radio.xml)
     skin/classic/forms/button.css             (skin/button.css)
     skin/classic/forms/checkbox.css           (skin/checkbox.css)
-*   skin/classic/forms/contents.rdf           (skin/contents.rdf)
     skin/classic/forms/forms.css              (skin/forms.css)
     skin/classic/forms/radio.css              (skin/radio.css)
     skin/classic/forms/select.css             (skin/select.css)
     skin/classic/forms/select-dropdown.css    (skin/select-dropdown.css)
     skin/classic/forms/arrow-dn-dis.gif       (skin/arrow-dn-dis.gif)
     skin/classic/forms/arrow-dn.gif           (skin/arrow-dn.gif)
     skin/classic/forms/cbox-check-dis.gif     (skin/cbox-check-dis.gif)
     skin/classic/forms/cbox-check.gif         (skin/cbox-check.gif)
     skin/classic/forms/radio-check-dis.gif    (skin/radio-check-dis.gif)
     skin/classic/forms/radio-check.gif        (skin/radio-check.gif)
     skin/classic/forms/twisty-clsd.gif        (skin/twisty-clsd.gif)
     skin/classic/forms/twisty-open.gif        (skin/twisty-open.gif)
 
 en-US.jar:
-*   locale/en-US/forms/contents.rdf           (locale/en-US/contents.rdf)
     locale/en-US/forms/htmlforms.dtd          (locale/en-US/htmlforms.dtd)
diff -r b7bcdd009540 layout/forms/resources/locale/en-US/contents.rdf
--- a/layout/forms/resources/locale/en-US/contents.rdf	Mon Sep 08 00:36:19 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,61 +0,0 @@
-<?xml version="1.0"?>
-<!-- ***** BEGIN LICENSE BLOCK *****
-   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
-   -
-   - The contents of this file are subject to the Mozilla Public License Version
-   - 1.1 (the "License"); you may not use this file except in compliance with
-   - the License. You may obtain a copy of the License at
-   - http://www.mozilla.org/MPL/
-   -
-   - Software distributed under the License is distributed on an "AS IS" basis,
-   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-   - for the specific language governing rights and limitations under the
-   - License.
-   -
-   - The Original Code is mozilla.org code.
-   -
-   - The Initial Developer of the Original Code is
-   - Netscape Communications Corporation.
-   - Portions created by the Initial Developer are Copyright (C) 2001
-   - the Initial Developer. All Rights Reserved.
-   -
-   - Contributor(s):
-   -  Brian Ryner <bryner@brianryner.com>
-   -
-   - Alternatively, the contents of this file may be used under the terms of
-   - either the GNU General Public License Version 2 or later (the "GPL"), or
-   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-   - in which case the provisions of the GPL or the LGPL are applicable instead
-   - of those above. If you wish to allow use of your version of this file only
-   - under the terms of either the GPL or the LGPL, and not to allow others to
-   - use your version of this file under the terms of the MPL, indicate your
-   - decision by deleting the provisions above and replace them with the notice
-   - and other provisions required by the LGPL or the GPL. If you do not delete
-   - the provisions above, a recipient may use your version of this file under
-   - the terms of any one of the MPL, the GPL or the LGPL.
-   -
-   - ***** END LICENSE BLOCK ***** -->
-
-<RDF:RDF xmlns:RDF="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-         xmlns:chrome="http://www.mozilla.org/rdf/chrome#">
-
-<RDF:Seq about="urn:mozilla:locale:root">
-<RDF:li resource="urn:mozilla:locale:en-US"/>
-</RDF:Seq>
-
-<RDF:Description about="urn:mozilla:locale:en-US"
-        chrome:displayName="English(US)"
-        chrome:author="mozilla.org"
-        chrome:name="en-US">
-  <chrome:packages>
-    <RDF:Seq about="urn:mozilla:locale:en-US:packages">
-      <RDF:li resource="urn:mozilla:locale:en-US:forms"/>
-    </RDF:Seq>
-  </chrome:packages>
-</RDF:Description>
-
-  <!-- Version Information.  State that we work only with major version of this
-       package. -->
-  <RDF:Description about="urn:mozilla:locale:en-US:forms"
-#expand         chrome:localeVersion="__MOZILLA_LOCALE_VERSION__"/>
-</RDF:RDF>
diff -r b7bcdd009540 layout/forms/resources/skin/contents.rdf
--- a/layout/forms/resources/skin/contents.rdf	Mon Sep 08 00:36:19 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,60 +0,0 @@
-<?xml version="1.0"?>
-<!-- ***** BEGIN LICENSE BLOCK *****
-   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
-   -
-   - The contents of this file are subject to the Mozilla Public License Version
-   - 1.1 (the "License"); you may not use this file except in compliance with
-   - the License. You may obtain a copy of the License at
-   - http://www.mozilla.org/MPL/
-   -
-   - Software distributed under the License is distributed on an "AS IS" basis,
-   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-   - for the specific language governing rights and limitations under the
-   - License.
-   -
-   - The Original Code is mozilla.org code.
-   -
-   - The Initial Developer of the Original Code is
-   - Netscape Communications Corporation.
-   - Portions created by the Initial Developer are Copyright (C) 2001
-   - the Initial Developer. All Rights Reserved.
-   -
-   - Contributor(s):
-   -  Brian Ryner <bryner@brianryner.com>
-   -
-   - Alternatively, the contents of this file may be used under the terms of
-   - either the GNU General Public License Version 2 or later (the "GPL"), or
-   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-   - in which case the provisions of the GPL or the LGPL are applicable instead
-   - of those above. If you wish to allow use of your version of this file only
-   - under the terms of either the GPL or the LGPL, and not to allow others to
-   - use your version of this file under the terms of the MPL, indicate your
-   - decision by deleting the provisions above and replace them with the notice
-   - and other provisions required by the LGPL or the GPL. If you do not delete
-   - the provisions above, a recipient may use your version of this file under
-   - the terms of any one of the MPL, the GPL or the LGPL.
-   -
-   - ***** END LICENSE BLOCK ***** -->
-
-<RDF:RDF xmlns:RDF="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-         xmlns:chrome="http://www.mozilla.org/rdf/chrome#">
-
-  <!-- List all the skins being supplied by this theme -->
-  <RDF:Seq about="urn:mozilla:skin:root">
-    <RDF:li resource="urn:mozilla:skin:classic/1.0" />
-  </RDF:Seq>
-
-  <!-- classic Information -->
-  <RDF:Description about="urn:mozilla:skin:classic/1.0">
-    <chrome:packages>
-      <RDF:Seq about="urn:mozilla:skin:classic/1.0:packages">
-        <RDF:li resource="urn:mozilla:skin:classic/1.0:forms"/>
-      </RDF:Seq>
-    </chrome:packages>
-  </RDF:Description>
-
-  <!-- Version Information.  State that we work only with major version 1 of this
-       package. -->
-  <RDF:Description about="urn:mozilla:skin:classic/1.0:forms"
-#expand     chrome:skinVersion="__MOZILLA_SKIN_VERSION__"/>
-</RDF:RDF>
diff -r b7bcdd009540 layout/generic/Makefile.in
--- a/layout/generic/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/generic/Makefile.in	Thu Sep 11 15:19:26 2008 +0300
@@ -36,17 +36,17 @@
 
 DEPTH		= ../..
 topsrcdir	= @top_srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
-ifdef MOZ_MOCHITEST
+ifdef ENABLE_TESTS
 DIRS		+= test
 endif
 
 MODULE		= layout
 LIBRARY_NAME	= gkgeneric_s
 LIBXUL_LIBRARY	= 1
 
 REQUIRES	= xpcom \
diff -r b7bcdd009540 layout/generic/nsAbsoluteContainingBlock.cpp
--- a/layout/generic/nsAbsoluteContainingBlock.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/generic/nsAbsoluteContainingBlock.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -46,27 +46,16 @@
 #include "nsIPresShell.h"
 #include "nsHTMLContainerFrame.h"
 #include "nsHTMLParts.h"
 #include "nsPresContext.h"
 
 #ifdef DEBUG
 #include "nsBlockFrame.h"
 #endif
-
-
-nsresult
-nsAbsoluteContainingBlock::FirstChild(const nsIFrame* aDelegatingFrame,
-                                      nsIAtom*        aListName,
-                                      nsIFrame**      aFirstChild) const
-{
-  NS_PRECONDITION(GetChildListName() == aListName, "unexpected child list name");
-  *aFirstChild = mAbsoluteFrames.FirstChild();
-  return NS_OK;
-}
 
 nsresult
 nsAbsoluteContainingBlock::SetInitialChildList(nsIFrame*       aDelegatingFrame,
                                                nsIAtom*        aListName,
                                                nsIFrame*       aChildList)
 {
   NS_PRECONDITION(GetChildListName() == aListName, "unexpected child list name");
 #ifdef NS_DEBUG
diff -r b7bcdd009540 layout/generic/nsAbsoluteContainingBlock.h
--- a/layout/generic/nsAbsoluteContainingBlock.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/generic/nsAbsoluteContainingBlock.h	Thu Sep 11 15:19:26 2008 +0300
@@ -79,20 +79,17 @@ public:
                  mChildListName == nsGkAtoms::fixedList,
                  "should either represent position:fixed or absolute content");
   }
 
 #ifdef DEBUG
   nsIAtom* GetChildListName() const { return mChildListName; }
 #endif
 
-  nsresult FirstChild(const nsIFrame* aDelegatingFrame,
-                      nsIAtom*        aListName,
-                      nsIFrame**      aFirstChild) const;
-  nsIFrame* GetFirstChild() { return mAbsoluteFrames.FirstChild(); }
+  nsIFrame* GetFirstChild() const { return mAbsoluteFrames.FirstChild(); }
 
   nsresult SetInitialChildList(nsIFrame*       aDelegatingFrame,
                                nsIAtom*        aListName,
                                nsIFrame*       aChildList);
   nsresult AppendFrames(nsIFrame*      aDelegatingFrame,
                         nsIAtom*       aListName,
                         nsIFrame*      aFrameList);
   nsresult InsertFrames(nsIFrame*      aDelegatingFrame,
diff -r b7bcdd009540 layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/generic/nsBlockFrame.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -515,19 +515,17 @@ nsBlockFrame::GetBaseline() const
 
 /////////////////////////////////////////////////////////////////////////////
 // Child frame enumeration
 
 nsIFrame*
 nsBlockFrame::GetFirstChild(nsIAtom* aListName) const
 {
   if (nsGkAtoms::absoluteList == aListName) {
-    nsIFrame* result = nsnull;
-    mAbsoluteContainer.FirstChild(this, aListName, &result);
-    return result;
+    return mAbsoluteContainer.GetFirstChild();
   }
   else if (nsnull == aListName) {
     return (mLines.empty()) ? nsnull : mLines.front()->mFirstChild;
   }
   else if (aListName == nsGkAtoms::overflowList) {
     nsLineList* overflowLines = GetOverflowLines();
     return overflowLines ? overflowLines->front()->mFirstChild : nsnull;
   }
@@ -798,37 +796,35 @@ CalculateContainingBlockSizeForAbsolutes
 
   nsSize cbSize(aFrameSize);
     // Containing block is relative to the padding edge
   const nsMargin& border =
     aReflowState.mComputedBorderPadding - aReflowState.mComputedPadding;
   cbSize.width -= border.LeftRight();
   cbSize.height -= border.TopBottom();
 
-  if (frame->GetParent()->GetContent() == frame->GetContent()) {
-    // We are a wrapped frame for the content. Use the container's
-    // dimensions, if they have been precomputed.
+  if (frame->GetParent()->GetContent() == frame->GetContent() &&
+      frame->GetParent()->GetType() != nsGkAtoms::canvasFrame) {
+    // We are a wrapped frame for the content (and the wrapper is not the
+    // canvas frame, whose size is not meaningful here).
+    // Use the container's dimensions, if they have been precomputed.
     // XXX This is a hack! We really should be waiting until the outermost
     // frame is fully reflowed and using the resulting dimensions, even
     // if they're intrinsic.
     // In fact we should be attaching absolute children to the outermost
     // frame and not always sticking them in block frames.
 
     // First, find the reflow state for the outermost frame for this
     // content.
     const nsHTMLReflowState* aLastRS = &aReflowState;
     const nsHTMLReflowState* lastButOneRS = &aReflowState;
-    PRBool isCanvasBlock = PR_FALSE;
     while (aLastRS->parentReflowState &&
            aLastRS->parentReflowState->frame->GetContent() == frame->GetContent()) {
       lastButOneRS = aLastRS;
       aLastRS = aLastRS->parentReflowState;
-      if (aLastRS->frame->GetType() == nsGkAtoms::canvasFrame) {
-        isCanvasBlock = PR_TRUE;
-      }
     }
     if (aLastRS != &aReflowState) {
       // Scrollbars need to be specifically excluded, if present, because they are outside the
       // padding-edge. We need better APIs for getting the various boxes from a frame.
       nsIScrollableFrame* scrollFrame;
       CallQueryInterface(aLastRS->frame, &scrollFrame);
       nsMargin scrollbars(0,0,0,0);
       if (scrollFrame) {
@@ -839,33 +835,21 @@ CalculateContainingBlockSizeForAbsolutes
           scrollbars.top = scrollbars.bottom = 0;
         }
         if (!lastButOneRS->mFlags.mAssumingVScrollbar) {
           scrollbars.left = scrollbars.right = 0;
         }
       }
       // We found a reflow state for the outermost wrapping frame, so use
       // its computed metrics if available
-      // XXX grotesque hack for Firefox 2 compatibility until we can
-      // properly fix abs-pos containers! If this is the block for
-      // the root element, don't adjust the width here, just use the block's
-      // width. We have to do this because the abs-pos frame will be
-      // positioned relative to the block, not the canvas frame, and the
-      // block might have borders and margin which will throw things off
-      // if we use the canvas frame width.
-      // Positioning abs-pos frames relative to the canvas is bug 425432.
-      if (aLastRS->ComputedWidth() != NS_UNCONSTRAINEDSIZE && !isCanvasBlock) {
+      if (aLastRS->ComputedWidth() != NS_UNCONSTRAINEDSIZE) {
         cbSize.width = PR_MAX(0,
           aLastRS->ComputedWidth() + aLastRS->mComputedPadding.LeftRight() - scrollbars.LeftRight());
       }
       if (aLastRS->ComputedHeight() != NS_UNCONSTRAINEDSIZE) {
-        // XXX This can be terribly wrong if we're the root element's block,
-        // because our margin and borders will be included in the height
-        // here but the abs-pos element(s) are positioned relative to
-        // our content rect...
         cbSize.height = PR_MAX(0,
           aLastRS->ComputedHeight() + aLastRS->mComputedPadding.TopBottom() - scrollbars.TopBottom());
       }
     }
   }
 
   return cbSize;
 }
@@ -4272,19 +4256,17 @@ nsBlockFrame::HandleOverflowPlaceholders
  */
 PRBool
 nsBlockFrame::HandleOverflowPlaceholdersOnPulledLine(
   nsBlockReflowState& aState, nsLineBox* aLine)
 {
   // First, see if it's a line of continuation placeholders. If it
   // is, remove one and retry.
   if (aLine->mFirstChild && IsContinuationPlaceholder(aLine->mFirstChild)) {
-#ifdef DEBUG
     PRBool taken =
-#endif
       HandleOverflowPlaceholdersForPulledFrame(aState, aLine->mFirstChild);
     NS_ASSERTION(taken, "We must have removed that frame");
     return PR_TRUE;
   }
  
   // OK, it's a normal line. Scan it for floats with continuations that
   // need to be taken care of. We won't need to change the line.
   PRInt32 n = aLine->GetChildCount();
@@ -4626,20 +4608,18 @@ nsBlockFrame::GetOverflowOutOfFlows() co
 // This takes ownership of the frames
 void
 nsBlockFrame::SetOverflowOutOfFlows(const nsFrameList& aList)
 {
   if (aList.IsEmpty()) {
     if (!(GetStateBits() & NS_BLOCK_HAS_OVERFLOW_OUT_OF_FLOWS)) {
       return;
     }
-#ifdef DEBUG
     nsIFrame* result = static_cast<nsIFrame*>
-#endif
-      (UnsetProperty(nsGkAtoms::overflowOutOfFlowsProperty));
+                                  (UnsetProperty(nsGkAtoms::overflowOutOfFlowsProperty));
     NS_ASSERTION(result, "value should always be non-empty when state set");
     RemoveStateBits(NS_BLOCK_HAS_OVERFLOW_OUT_OF_FLOWS);
   } else {
     SetProperty(nsGkAtoms::overflowOutOfFlowsProperty,
                 aList.FirstChild(), nsnull);
     AddStateBits(NS_BLOCK_HAS_OVERFLOW_OUT_OF_FLOWS);
   }
 }
@@ -5606,17 +5586,18 @@ nsBlockFrame::StealFrame(nsPresContext* 
   }
   return NS_ERROR_UNEXPECTED;
 }
 
 void
 nsBlockFrame::DeleteNextInFlowChild(nsPresContext* aPresContext,
                                     nsIFrame*       aNextInFlow)
 {
-  NS_PRECONDITION(aNextInFlow->GetPrevInFlow(), "bad next-in-flow");
+  nsIFrame* prevInFlow = aNextInFlow->GetPrevInFlow();
+  NS_PRECONDITION(prevInFlow, "bad next-in-flow");
 
   if (NS_FRAME_IS_OVERFLOW_CONTAINER & aNextInFlow->GetStateBits()) {
     nsContainerFrame::DeleteNextInFlowChild(aPresContext, aNextInFlow);
   }
   else {
     DoRemoveFrame(aNextInFlow);
   }
 }
diff -r b7bcdd009540 layout/generic/nsContainerFrame.cpp
--- a/layout/generic/nsContainerFrame.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/generic/nsContainerFrame.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -218,20 +218,17 @@ nsContainerFrame::RemoveFrame(nsIAtom*  
       //XXXfr probably should use StealFrame here. I'm not sure if we need to
       //      check the overflow lists atm, but we'll need a prescontext lookup
       //      for overflow containers once we can split abspos elements with
       //      inline containing blocks.
       if (parent == this) {
         if (!parent->mFrames.DestroyFrame(aOldFrame)) {
           // Try to remove it from our overflow list, if we have one.
           // The simplest way is to reuse StealFrame.
-#ifdef DEBUG
-          nsresult rv =
-#endif
-            StealFrame(PresContext(), aOldFrame, PR_TRUE);
+          nsresult rv = StealFrame(PresContext(), aOldFrame, PR_TRUE);
           NS_ASSERTION(NS_SUCCEEDED(rv), "Could not find frame to remove!");
           aOldFrame->Destroy();
         }
       } else {
         // This recursive call takes care of all continuations after aOldFrame,
         // so we don't need to loop anymore.
         parent->RemoveFrame(nsnull, aOldFrame);
         break;
@@ -487,17 +484,18 @@ SyncFrameViewGeometryDependentProperties
                                          nsStyleContext*  aStyleContext,
                                          nsIView*         aView,
                                          PRUint32         aFlags)
 {
   nsIViewManager* vm = aView->GetViewManager();
 
   PRBool isCanvas;
   const nsStyleBackground* bg;
-  nsCSSRendering::FindBackground(aPresContext, aFrame, &bg, &isCanvas);
+  PRBool hasBG =
+    nsCSSRendering::FindBackground(aPresContext, aFrame, &bg, &isCanvas);
 
   if (isCanvas) {
     nsIView* rootView;
     vm->GetRootView(rootView);
 
     if (aView->HasWidget() && aView == rootView &&
         IsTopLevelWidget(aPresContext)) {
       // The issue here is that the CSS 'background' propagates from the root
@@ -1094,20 +1092,17 @@ nsContainerFrame::StealFrame(nsPresConte
 /**
  * Remove and delete aNextInFlow and its next-in-flows. Updates the sibling and flow
  * pointers
  */
 void
 nsContainerFrame::DeleteNextInFlowChild(nsPresContext* aPresContext,
                                         nsIFrame*      aNextInFlow)
 {
-#ifdef DEBUG
   nsIFrame* prevInFlow = aNextInFlow->GetPrevInFlow();
-#endif
-
   NS_PRECONDITION(prevInFlow, "bad prev-in-flow");
 
   // If the next-in-flow has a next-in-flow then delete it, too (and
   // delete it first).
   // Do this in a loop so we don't overflow the stack for frames
   // with very many next-in-flows
   nsIFrame* nextNextInFlow = aNextInFlow->GetNextInFlow();
   if (nextNextInFlow) {
@@ -1123,20 +1118,17 @@ nsContainerFrame::DeleteNextInFlowChild(
   }
 
   aNextInFlow->Invalidate(aNextInFlow->GetOverflowRect());
 
   // Disconnect the next-in-flow from the flow list
   nsSplittableFrame::BreakFromPrevFlow(aNextInFlow);
 
   // Take the next-in-flow out of the parent's child list
-#ifdef DEBUG
-  nsresult rv = 
-#endif
-    StealFrame(aPresContext, aNextInFlow);
+  nsresult rv = StealFrame(aPresContext, aNextInFlow);
   NS_ASSERTION(NS_SUCCEEDED(rv), "StealFrame failure");
 
   // Delete the next-in-flow frame and its descendants.
   aNextInFlow->Destroy();
 
   NS_POSTCONDITION(!prevInFlow->GetNextInFlow(), "non null next-in-flow");
 }
 
@@ -1587,16 +1579,19 @@ nsContainerFrame::List(FILE* out, PRInt3
             NS_LossyConvertUTF16toASCII(atomString).get());
   }
 
   // Output the children
   nsIAtom* listName = nsnull;
   PRInt32 listIndex = 0;
   PRBool outputOneList = PR_FALSE;
   do {
+    if (!outputOneList) {
+      fputs("\n", out);
+    }
     nsIFrame* kid = GetFirstChild(listName);
     if (nsnull != kid) {
       if (outputOneList) {
         IndentBy(out, aIndent);
       }
       outputOneList = PR_TRUE;
       nsAutoString tmp;
       if (nsnull != listName) {
diff -r b7bcdd009540 layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/generic/nsFrame.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -115,16 +115,20 @@
 #include "nsUnicharUtils.h"
 #include "nsLayoutErrors.h"
 #include "nsContentErrors.h"
 #include "nsHTMLContainerFrame.h"
 #include "nsBoxLayoutState.h"
 #include "nsBlockFrame.h"
 #include "nsDisplayList.h"
 
+#ifdef MOZ_SVG
+#include "nsSVGIntegrationUtils.h"
+#endif
+
 #include "gfxContext.h"
 
 static NS_DEFINE_CID(kLookAndFeelCID,  NS_LOOKANDFEEL_CID);
 static NS_DEFINE_CID(kWidgetCID, NS_CHILD_CID);
 
 // Struct containing cached metrics for box-wrapped frames.
 struct nsBoxLayoutMetrics
 {
@@ -1176,17 +1180,25 @@ nsIFrame::BuildDisplayListForStackingCon
   const nsStyleDisplay* disp = GetStyleDisplay();
   PRBool applyAbsPosClipping =
       ApplyAbsPosClipping(aBuilder, disp, this, &absPosClip);
   nsRect dirtyRect = aDirtyRect;
   if (applyAbsPosClipping) {
     dirtyRect.IntersectRect(dirtyRect,
                             absPosClip - aBuilder->ToReferenceFrame(this));
   }
-      
+
+#ifdef MOZ_SVG
+  PRBool usingSVGEffects = nsSVGIntegrationUtils::UsingEffectsForFrame(this);
+  if (usingSVGEffects) {
+    dirtyRect =
+      nsSVGIntegrationUtils::GetRequiredSourceForInvalidArea(this, dirtyRect);
+  }
+#endif
+
   nsDisplayListCollection set;
   nsresult rv;
   {    
     nsDisplayListBuilder::AutoIsRootSetter rootSetter(aBuilder, PR_TRUE);
     rv = BuildDisplayList(aBuilder, dirtyRect, set);
   }
   NS_ENSURE_SUCCESS(rv, rv);
     
@@ -1257,22 +1269,27 @@ nsIFrame::BuildDisplayListForStackingCon
     nsAbsPosClipWrapper wrapper(this, absPosClip);
     nsDisplayItem* item = wrapper.WrapList(aBuilder, this, &resultList);
     if (!item)
       return NS_ERROR_OUT_OF_MEMORY;
     // resultList was emptied
     resultList.AppendToTop(item);
   }
  
-  if (disp->mOpacity == 1.0f) {
+#ifdef MOZ_SVG
+  if (usingSVGEffects) {
+    rv = aList->AppendNewToTop(new (aBuilder) nsDisplaySVGEffects(this, &resultList));
+  } else
+#endif
+  if (disp->mOpacity < 1.0f) {
+    rv = aList->AppendNewToTop(new (aBuilder) nsDisplayOpacity(this, &resultList));
+  } else {
     aList->AppendToTop(&resultList);
-  } else {
-    rv = aList->AppendNewToTop(new (aBuilder) nsDisplayOpacity(this, &resultList));
-  }
-  
+  }
+
   return rv;
 }
 
 class nsDisplaySummary : public nsDisplayItem
 {
 public:
   nsDisplaySummary(nsIFrame* aFrame) : nsDisplayItem(aFrame) {
     MOZ_COUNT_CTOR(nsDisplaySummary);
@@ -1401,17 +1418,21 @@ nsIFrame::BuildDisplayListForChild(nsDis
   
   const nsStyleDisplay* ourDisp = GetStyleDisplay();
   // REVIEW: Taken from nsBoxFrame::Paint
   // Don't paint our children if the theme object is a leaf.
   if (IsThemed(ourDisp) &&
       !PresContext()->GetTheme()->WidgetIsContainer(ourDisp->mAppearance))
     return NS_OK;
 
-  PRBool isComposited = disp->mOpacity != 1.0f;
+  PRBool isComposited = disp->mOpacity != 1.0f
+#ifdef MOZ_SVG
+    || nsSVGIntegrationUtils::UsingEffectsForFrame(aChild)
+#endif
+    ;
   PRBool isPositioned = disp->IsPositioned();
   if (isComposited || isPositioned || (aFlags & DISPLAY_CHILD_FORCE_STACKING_CONTEXT)) {
     // If you change this, also change IsPseudoStackingContextFromStyle()
     pseudoStackingContext = PR_TRUE;
   }
   
   nsRect overflowClip;
   PRBool applyOverflowClip =
@@ -3586,16 +3607,25 @@ nsIFrame::Invalidate(const nsRect& aDama
   
   InvalidateInternal(aDamageRect, 0, 0, nsnull, aImmediate);
 }
 
 void
 nsIFrame::InvalidateInternal(const nsRect& aDamageRect, nscoord aX, nscoord aY,
                              nsIFrame* aForChild, PRBool aImmediate)
 {
+#ifdef MOZ_SVG
+  if (nsSVGIntegrationUtils::UsingEffectsForFrame(this)) {
+    nsRect r = nsSVGIntegrationUtils::GetInvalidAreaForChangedSource(this,
+            aDamageRect + nsPoint(aX, aY));
+    GetParent()->InvalidateInternal(r, mRect.x, mRect.y, this, aImmediate);
+    return;
+  }
+#endif
+
   GetParent()->
     InvalidateInternal(aDamageRect, aX + mRect.x, aY + mRect.y, this, aImmediate);
 }
 
 void
 nsIFrame::InvalidateRectDifference(const nsRect& aR1, const nsRect& aR2)
 {
   nsRect sizeHStrip, sizeVStrip;
@@ -3615,37 +3645,100 @@ nsIFrame::InvalidateRoot(const nsRect& a
                          nscoord aX, nscoord aY, PRBool aImmediate)
 {
   PRUint32 flags = aImmediate ? NS_VMREFRESH_IMMEDIATE : NS_VMREFRESH_NO_SYNC;
   nsIView* view = GetView();
   NS_ASSERTION(view, "This can only be called on frames with views");
   view->GetViewManager()->UpdateView(view, aDamageRect + nsPoint(aX, aY), flags);
 }
 
-static nsRect ComputeOutlineRect(const nsIFrame* aFrame, PRBool* aAnyOutline,
-                                 const nsRect& aOverflowRect) {
+static void
+DestroyRectFunc(void*    aFrame,
+                nsIAtom* aPropertyName,
+                void*    aPropertyValue,
+                void*    aDtorData)
+{
+  delete static_cast<nsRect*>(aPropertyValue);
+}
+
+static void
+SetRectProperty(nsIFrame* aFrame, nsIAtom* aProp, const nsRect& aRect)
+{
+  nsRect* r = new nsRect(aRect);
+  if (!r)
+    return;
+  aFrame->SetProperty(aProp, r, DestroyRectFunc);
+}
+
+static nsRect
+ComputeOutlineAndEffectsRect(nsIFrame* aFrame, PRBool* aAnyOutlineOrEffects,
+                             const nsRect& aOverflowRect,
+                             PRBool aStoreRectProperties) {
+  nsRect r = aOverflowRect;
+  *aAnyOutlineOrEffects = PR_FALSE;
+
+  // box-shadow
+  nsCSSShadowArray* boxShadows = aFrame->GetStyleBorder()->mBoxShadow;
+  if (boxShadows) {
+    nsRect shadows;
+    for (PRUint32 i = 0; i < boxShadows->Length(); ++i) {
+      nsRect tmpRect = r;
+      nsCSSShadowItem* shadow = boxShadows->ShadowAt(i);
+      nscoord xOffset = shadow->mXOffset.GetCoordValue();
+      nscoord yOffset = shadow->mYOffset.GetCoordValue();
+      nscoord outsetRadius = shadow->mRadius.GetCoordValue() +
+                             shadow->mSpread.GetCoordValue();
+
+      tmpRect.MoveBy(nsPoint(xOffset, yOffset));
+      tmpRect.Inflate(outsetRadius, outsetRadius);
+
+      shadows.UnionRect(shadows, tmpRect);
+    }
+    r.UnionRect(r, shadows);
+  }
+
   const nsStyleOutline* outline = aFrame->GetStyleOutline();
   PRUint8 outlineStyle = outline->GetOutlineStyle();
-  nsRect r = aOverflowRect;
-  *aAnyOutline = PR_FALSE;
   if (outlineStyle != NS_STYLE_BORDER_STYLE_NONE) {
     nscoord width;
 #ifdef DEBUG
     PRBool result = 
 #endif
       outline->GetOutlineWidth(width);
     NS_ASSERTION(result, "GetOutlineWidth had no cached outline width");
     if (width > 0) {
+      if (aStoreRectProperties) {
+        SetRectProperty(aFrame, nsGkAtoms::outlineInnerRectProperty, r);
+      }
+
       nscoord offset;
       outline->GetOutlineOffset(offset);
       nscoord inflateBy = PR_MAX(width + offset, 0);
       r.Inflate(inflateBy, inflateBy);
-      *aAnyOutline = PR_TRUE;
-    }
-  }
+      *aAnyOutlineOrEffects = PR_TRUE;
+    }
+  }
+  
+  // Note that we don't remove the outlineInnerRect if a frame loses outline
+  // style. That would require an extra property lookup for every frame,
+  // or a new frame state bit to track whether a property had been stored,
+  // or something like that. It's not worth doing that here. At most it's
+  // only one heap-allocated rect per frame and it will be cleaned up when
+  // the frame dies.
+
+#ifdef MOZ_SVG
+  if (nsSVGIntegrationUtils::UsingEffectsForFrame(aFrame)) {
+    *aAnyOutlineOrEffects = PR_TRUE;
+    if (aStoreRectProperties) {
+      SetRectProperty(aFrame, nsGkAtoms::preEffectsBBoxProperty, r);
+    }
+    r = nsSVGIntegrationUtils::ComputeFrameEffectsRect(aFrame, r);
+  }
+#endif
+
   return r;
 }
 
 nsPoint
 nsIFrame::GetRelativeOffset(const nsStyleDisplay* aDisplay) const
 {
   if (!aDisplay || NS_STYLE_POSITION_RELATIVE == aDisplay->mPosition) {
     nsPoint *offsets = static_cast<nsPoint*>
@@ -3694,20 +3787,20 @@ nsIFrame::CheckInvalidateSizeChange(cons
   // between the old and new areas needs to be painted. We are
   // assuming that the difference between the old and new areas will
   // be invalidated by some other means. That also means invalidating
   // the old frame area is the same as invalidating the new frame area
   // (since in either case the UNION of old and new areas will be
   // invalidated)
 
   // Invalidate the entire old frame+outline if the frame has an outline
-  PRBool anyOutline;
-  nsRect r = ComputeOutlineRect(this, &anyOutline,
-                                aNewDesiredSize.mOverflowArea);
-  if (anyOutline) {
+  PRBool anyOutlineOrEffects;
+  nsRect r = ComputeOutlineAndEffectsRect(this, &anyOutlineOrEffects,
+                                          aOldOverflowRect, PR_FALSE);
+  if (anyOutlineOrEffects) {
     r.UnionRect(aOldOverflowRect, r);
     Invalidate(r);
     return;
   }
 
   // Invalidate the old frame borders if the frame has borders. Those borders
   // may be moving.
   const nsStyleBorder* border = GetStyleBorder();
@@ -5256,26 +5349,16 @@ nsFrame::ChildIsDirty(nsIFrame* aChild)
 #ifdef ACCESSIBILITY
 NS_IMETHODIMP
 nsFrame::GetAccessible(nsIAccessible** aAccessible)
 {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 #endif
 
-// Destructor function for the overflow area property
-static void
-DestroyRectFunc(void*    aFrame,
-                nsIAtom* aPropertyName,
-                void*    aPropertyValue,
-                void*    aDtorData)
-{
-  delete static_cast<nsRect*>(aPropertyValue);
-}
-
 /** Create or retrieve the previously stored overflow area, if the frame does 
  * not overflow and no creation is required return nsnull.
  * @param aCreateIfNecessary  create a new nsRect for the overflow area
  * @return pointer to the overflow area rectangle 
  */
 nsRect*
 nsIFrame::GetOverflowAreaProperty(PRBool aCreateIfNecessary) 
 {
@@ -5309,39 +5392,21 @@ IsInlineFrame(nsIFrame *aFrame)
   return type == nsGkAtoms::inlineFrame ||
          type == nsGkAtoms::positionedInlineFrame;
 }
 
 nsRect
 nsIFrame::GetAdditionalOverflow(const nsRect& aOverflowArea,
                                 const nsSize& aNewSize)
 {
-  nsRect overflowRect;
-
   // outline
-  PRBool hasOutline;
-  overflowRect = ComputeOutlineRect(this, &hasOutline, aOverflowArea);
-
-  // box-shadow
-  nsCSSShadowArray* boxShadows = GetStyleBorder()->mBoxShadow;
-  if (boxShadows) {
-    for (PRUint32 i = 0; i < boxShadows->Length(); ++i) {
-      nsRect tmpRect(nsPoint(0, 0), aNewSize);
-      nsCSSShadowItem* shadow = boxShadows->ShadowAt(i);
-      nscoord xOffset = shadow->mXOffset.GetCoordValue();
-      nscoord yOffset = shadow->mYOffset.GetCoordValue();
-      nscoord outsetRadius = shadow->mRadius.GetCoordValue() +
-                             shadow->mSpread.GetCoordValue();
-
-      tmpRect.MoveBy(nsPoint(xOffset, yOffset));
-      tmpRect.Inflate(outsetRadius, outsetRadius);
-
-      overflowRect.UnionRect(overflowRect, tmpRect);
-    }
-  }
+  PRBool hasOutlineOrEffects;
+  nsRect overflowRect =
+    ComputeOutlineAndEffectsRect(this, &hasOutlineOrEffects,
+                                 aOverflowArea, PR_TRUE);
 
   // Absolute position clipping
   PRBool hasAbsPosClip;
   nsRect absPosClipRect;
   hasAbsPosClip = GetAbsPosClipRect(GetStyleDisplay(), &absPosClipRect, aNewSize);
   if (hasAbsPosClip) {
     overflowRect.IntersectRect(overflowRect, absPosClipRect);
   }
@@ -5432,28 +5497,35 @@ nsFrame::GetParentStyleContextFrame(nsPr
 
 
 /**
  * This function takes a "special" frame and _if_ that frame is the
  * anonymous block crated by an ib split it returns the split inline
  * as aSpecialSibling.  This is needed because the split inline's
  * style context is the parent of the anonymous block's srtyle context.
  *
- * If aFrame is not the anonymous block, aSpecialSibling is not
- * touched.
+ * If aFrame is not the anonymous block, aSpecialSibling is set to null.
  */
 static nsresult
-GetIBSpecialSibling(nsPresContext* aPresContext,
-                    nsIFrame* aFrame,
-                    nsIFrame** aSpecialSibling)
+GetIBSpecialSiblingForAnonymousBlock(nsPresContext* aPresContext,
+                                     nsIFrame* aFrame,
+                                     nsIFrame** aSpecialSibling)
 {
   NS_PRECONDITION(aFrame, "Must have a non-null frame!");
   NS_ASSERTION(aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL,
                "GetIBSpecialSibling should not be called on a non-special frame");
-  
+
+  nsIAtom* type = aFrame->GetStyleContext()->GetPseudoType();
+  if (type != nsCSSAnonBoxes::mozAnonymousBlock &&
+      type != nsCSSAnonBoxes::mozAnonymousPositionedBlock) {
+    // it's not the anonymous block
+    *aSpecialSibling = nsnull;
+    return NS_OK;
+  }
+
   // Find the first-in-flow of the frame.  (Ugh.  This ends up
   // being O(N^2) when it is called O(N) times.)
   aFrame = aFrame->GetFirstInFlow();
 
   /*
    * Now look up the nsGkAtoms::IBSplitSpecialPrevSibling
    * property, which is only set on the anonymous block frames we're
    * interested in.
@@ -5527,20 +5599,21 @@ nsFrame::CorrectStyleParentFrame(nsIFram
   // Otherwise, walk up out of all anon boxes.  For placeholder frames, walk out
   // of all pseudo-elements as well.  Otherwise ReParentStyleContext could cause
   // style data to be out of sync with the frame tree.
   nsIFrame* parent = aProspectiveParent;
   do {
     if (parent->GetStateBits() & NS_FRAME_IS_SPECIAL) {
       nsIFrame* sibling;
       nsresult rv =
-        GetIBSpecialSibling(parent->PresContext(), parent, &sibling);
+        GetIBSpecialSiblingForAnonymousBlock(parent->PresContext(), parent, &sibling);
       if (NS_FAILED(rv)) {
-        // If GetIBSpecialSibling fails, then what?  we used to return what is
-        // now |aProspectiveParent|, but maybe |parent| would make more sense?
+        // If GetIBSpecialSiblingForAnonymousBlock fails, then what?
+        // we used to return what is now |aProspectiveParent|, but maybe
+        // |parent| would make more sense?
         NS_NOTREACHED("Shouldn't get here");
         return aProspectiveParent;
       }
 
       if (sibling) {
         // |parent| was the block in an {ib} split; use the inline as
         // |the style parent.
         parent = sibling;
@@ -5556,22 +5629,29 @@ nsFrame::CorrectStyleParentFrame(nsIFram
          // ancestor.
          aChildPseudo != nsGkAtoms::placeholderFrame)) {
       return parent;
     }
 
     parent = parent->GetParent();
   } while (parent);
 
-  // We can get here if aProspectiveParent is the scrollframe for a viewport
-  // and the kids are the anonymous scrollbars.
-  NS_ASSERTION(aProspectiveParent->GetStyleContext()->GetPseudoType() ==
-                 nsCSSAnonBoxes::viewportScroll,
+  if (aProspectiveParent->GetStyleContext()->GetPseudoType() ==
+      nsCSSAnonBoxes::viewportScroll) {
+    // aProspectiveParent is the scrollframe for a viewport
+    // and the kids are the anonymous scrollbars
+    return aProspectiveParent;
+  }
+
+  // We can get here if the root element is absolutely positioned.
+  // We can't test for this very accurately, but it can only happen
+  // when the prospective parent is a canvas frame.
+  NS_ASSERTION(aProspectiveParent->GetType() == nsGkAtoms::canvasFrame,
                "Should have found a parent before this");
-  return aProspectiveParent;
+  return nsnull;
 }
 
 nsresult
 nsFrame::DoGetParentStyleContextFrame(nsPresContext* aPresContext,
                                       nsIFrame**      aProviderFrame,
                                       PRBool*         aIsChild)
 {
   *aIsChild = PR_FALSE;
@@ -5582,20 +5662,21 @@ nsFrame::DoGetParentStyleContextFrame(ns
     return NS_OK;
   }
   
   if (!(mState & NS_FRAME_OUT_OF_FLOW)) {
     /*
      * If this frame is the anonymous block created when an inline
      * with a block inside it got split, then the parent style context
      * is on the first of the three special frames.  We can get to it
-     * using GetIBSpecialSibling
+     * using GetIBSpecialSiblingForAnonymousBlock
      */
     if (mState & NS_FRAME_IS_SPECIAL) {
-      nsresult rv = GetIBSpecialSibling(aPresContext, this, aProviderFrame);
+      nsresult rv =
+        GetIBSpecialSiblingForAnonymousBlock(aPresContext, this, aProviderFrame);
       if (NS_FAILED(rv)) {
         NS_NOTREACHED("Shouldn't get here");
         *aProviderFrame = nsnull;
         return rv;
       }
 
       if (*aProviderFrame) {
         return NS_OK;
diff -r b7bcdd009540 layout/generic/nsHTMLFrame.cpp
--- a/layout/generic/nsHTMLFrame.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/generic/nsHTMLFrame.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -49,68 +49,82 @@
 #include "nsGUIEvent.h"
 #include "nsStyleConsts.h"
 #include "nsGkAtoms.h"
 #include "nsIEventStateManager.h"
 #include "nsIDeviceContext.h"
 #include "nsIPresShell.h"
 #include "nsIScrollPositionListener.h"
 #include "nsDisplayList.h"
+#include "nsAbsoluteContainingBlock.h"
 
 // for focus
 #include "nsIDOMWindowInternal.h"
 #include "nsIFocusController.h"
 #include "nsIScrollableFrame.h"
 #include "nsIScrollableView.h"
 #include "nsIDocShell.h"
 #include "nsICanvasFrame.h"
 
 #ifdef DEBUG_rods
 //#define DEBUG_CANVAS_FOCUS
 #endif
+
+#define CANVAS_ABS_POS_CHILD_LIST NS_CONTAINER_LIST_COUNT_INCL_OC
 
 // Interface IDs
 
 /**
  * Root frame class.
  *
  * The root frame is the parent frame for the document element's frame.
  * It only supports having a single child frame which must be an area
  * frame
  */
 class CanvasFrame : public nsHTMLContainerFrame, 
                     public nsIScrollPositionListener, 
                     public nsICanvasFrame {
 public:
   CanvasFrame(nsStyleContext* aContext)
-  : nsHTMLContainerFrame(aContext), mDoPaintFocus(PR_FALSE) {}
+  : nsHTMLContainerFrame(aContext), mDoPaintFocus(PR_FALSE),
+    mAbsoluteContainer(nsGkAtoms::absoluteList) {}
 
    // nsISupports
   NS_IMETHOD QueryInterface(const nsIID& aIID, void** aInstancePtr);
 
   NS_IMETHOD Init(nsIContent*      aContent,
                   nsIFrame*        aParent,
                   nsIFrame*        aPrevInFlow);
   virtual void Destroy();
 
+  NS_IMETHOD SetInitialChildList(nsIAtom*        aListName,
+                                 nsIFrame*       aChildList);
   NS_IMETHOD AppendFrames(nsIAtom*        aListName,
                           nsIFrame*       aFrameList);
   NS_IMETHOD InsertFrames(nsIAtom*        aListName,
                           nsIFrame*       aPrevFrame,
                           nsIFrame*       aFrameList);
   NS_IMETHOD RemoveFrame(nsIAtom*        aListName,
                          nsIFrame*       aOldFrame);
 
+  virtual nsIAtom* GetAdditionalChildListName(PRInt32 aIndex) const;
+  virtual nsIFrame* GetFirstChild(nsIAtom* aListName) const;
+
   virtual nscoord GetMinWidth(nsIRenderingContext *aRenderingContext);
   virtual nscoord GetPrefWidth(nsIRenderingContext *aRenderingContext);
   NS_IMETHOD Reflow(nsPresContext*          aPresContext,
                     nsHTMLReflowMetrics&     aDesiredSize,
                     const nsHTMLReflowState& aReflowState,
                     nsReflowStatus&          aStatus);
   virtual PRBool IsContainingBlock() const { return PR_TRUE; }
+  virtual PRBool IsFrameOfType(PRUint32 aFlags) const
+  {
+    return nsHTMLContainerFrame::IsFrameOfType(aFlags &
+             ~(nsIFrame::eCanContainOverflowContainers));
+  }
 
   NS_IMETHOD BuildDisplayList(nsDisplayListBuilder*   aBuilder,
                               const nsRect&           aDirtyRect,
                               const nsDisplayListSet& aLists);
 
   void PaintFocus(nsIRenderingContext& aRenderingContext, nsPoint aPt);
 
   // nsIScrollPositionListener
@@ -123,31 +137,47 @@ public:
 
   /**
    * Get the "type" of the frame
    *
    * @see nsGkAtoms::canvasFrame
    */
   virtual nsIAtom* GetType() const;
 
+  virtual nsresult StealFrame(nsPresContext* aPresContext,
+                              nsIFrame*      aChild,
+                              PRBool         aForceNormal)
+  {
+    NS_ASSERTION(!aForceNormal, "No-one should be passing this in here");
+
+    // CanvasFrame keeps overflow container continuations of its child
+    // frame in main child list
+    nsresult rv = nsContainerFrame::StealFrame(aPresContext, aChild, PR_TRUE);
+    if (NS_FAILED(rv)) {
+      rv = nsContainerFrame::StealFrame(aPresContext, aChild);
+    }
+    return rv;
+  }
+
 #ifdef DEBUG
   NS_IMETHOD GetFrameName(nsAString& aResult) const;
 #endif
   NS_IMETHOD GetContentForEvent(nsPresContext* aPresContext,
                                 nsEvent* aEvent,
                                 nsIContent** aContent);
 
   nsRect CanvasArea() const;
 
 protected:
   virtual PRIntn GetSkipSides() const;
 
   // Data members
-  PRPackedBool             mDoPaintFocus;
-  nsCOMPtr<nsIViewManager> mViewManager;
+  PRPackedBool              mDoPaintFocus;
+  nsCOMPtr<nsIViewManager>  mViewManager;
+  nsAbsoluteContainingBlock mAbsoluteContainer;
 
 private:
   NS_IMETHOD_(nsrefcnt) AddRef() { return NS_OK; }
   NS_IMETHOD_(nsrefcnt) Release() { return NS_OK; }
 };
 
 
 //----------------------------------------------------------------------
@@ -193,16 +223,18 @@ CanvasFrame::Init(nsIContent*      aCont
   }
 
   return rv;
 }
 
 void
 CanvasFrame::Destroy()
 {
+  mAbsoluteContainer.DestroyFrames(this);
+
   nsIScrollableView* scrollingView = nsnull;
   mViewManager->GetRootScrollableView(&scrollingView);
   if (scrollingView) {
     scrollingView->RemoveScrollPositionListener(this);
   }
 
   nsHTMLContainerFrame::Destroy();
 }
@@ -241,29 +273,41 @@ CanvasFrame::ScrollPositionDidChange(nsI
   return NS_OK;
 }
 
 NS_IMETHODIMP
 CanvasFrame::SetHasFocus(PRBool aHasFocus)
 {
   if (mDoPaintFocus != aHasFocus) {
     mDoPaintFocus = aHasFocus;
-    nsIViewManager* vm = PresContext()->PresShell()->GetViewManager();
-    if (vm) {
-      vm->UpdateAllViews(NS_VMREFRESH_NO_SYNC);
-    }
+    mViewManager->UpdateAllViews(NS_VMREFRESH_NO_SYNC);
   }
   return NS_OK;
+}
+
+NS_IMETHODIMP
+CanvasFrame::SetInitialChildList(nsIAtom*        aListName,
+                                 nsIFrame*       aChildList)
+{
+  if (nsGkAtoms::absoluteList == aListName)
+    return mAbsoluteContainer.SetInitialChildList(this, aListName, aChildList);
+
+  NS_ASSERTION(aListName || !aChildList || !aChildList->GetNextSibling(),
+               "Primary child list can have at most one frame in it");
+  return nsHTMLContainerFrame::SetInitialChildList(aListName, aChildList);
 }
 
 NS_IMETHODIMP
 CanvasFrame::AppendFrames(nsIAtom*        aListName,
                           nsIFrame*       aFrameList)
 {
   nsresult  rv;
+
+  if (nsGkAtoms::absoluteList == aListName)
+    return mAbsoluteContainer.AppendFrames(this, aListName, aFrameList);
 
   NS_ASSERTION(!aListName, "unexpected child list name");
   NS_PRECONDITION(mFrames.IsEmpty(), "already have a child frame");
   if (aListName) {
     // We only support unnamed principal child list
     rv = NS_ERROR_INVALID_ARG;
 
   } else if (!mFrames.IsEmpty()) {
@@ -287,16 +331,19 @@ CanvasFrame::AppendFrames(nsIAtom*      
 
 NS_IMETHODIMP
 CanvasFrame::InsertFrames(nsIAtom*        aListName,
                           nsIFrame*       aPrevFrame,
                           nsIFrame*       aFrameList)
 {
   nsresult  rv;
 
+  if (nsGkAtoms::absoluteList == aListName)
+    return mAbsoluteContainer.InsertFrames(this, aListName, aPrevFrame, aFrameList);
+
   // Because we only support a single child frame inserting is the same
   // as appending
   NS_PRECONDITION(!aPrevFrame, "unexpected previous sibling frame");
   if (aPrevFrame) {
     rv = NS_ERROR_UNEXPECTED;
   } else {
     rv = AppendFrames(aListName, aFrameList);
   }
@@ -304,16 +351,19 @@ CanvasFrame::InsertFrames(nsIAtom*      
   return rv;
 }
 
 NS_IMETHODIMP
 CanvasFrame::RemoveFrame(nsIAtom*        aListName,
                          nsIFrame*       aOldFrame)
 {
   nsresult  rv;
+
+  if (nsGkAtoms::absoluteList == aListName)
+    return mAbsoluteContainer.RemoveFrame(this, aListName, aOldFrame);
 
   NS_ASSERTION(!aListName, "unexpected child list name");
   if (aListName) {
     // We only support the unnamed principal child list
     rv = NS_ERROR_INVALID_ARG;
   
   } else if (aOldFrame == mFrames.FirstChild()) {
     // It's our one and only child frame
@@ -328,16 +378,34 @@ CanvasFrame::RemoveFrame(nsIAtom*       
     rv = PresContext()->PresShell()->
            FrameNeedsReflow(this, nsIPresShell::eTreeChange,
                             NS_FRAME_HAS_DIRTY_CHILDREN);
   } else {
     rv = NS_ERROR_FAILURE;
   }
 
   return rv;
+}
+
+nsIAtom*
+CanvasFrame::GetAdditionalChildListName(PRInt32 aIndex) const
+{
+  if (CANVAS_ABS_POS_CHILD_LIST == aIndex)
+    return nsGkAtoms::absoluteList;
+
+  return nsHTMLContainerFrame::GetAdditionalChildListName(aIndex);
+}
+
+nsIFrame*
+CanvasFrame::GetFirstChild(nsIAtom* aListName) const
+{
+  if (nsGkAtoms::absoluteList == aListName)
+    return mAbsoluteContainer.GetFirstChild();
+
+  return nsHTMLContainerFrame::GetFirstChild(aListName);
 }
 
 nsRect CanvasFrame::CanvasArea() const
 {
   nsRect result(GetOverflowRect());
 
   nsIScrollableFrame *scrollableFrame;
   CallQueryInterface(GetParent(), &scrollableFrame);
@@ -414,31 +482,38 @@ public:
 };
 
 NS_IMETHODIMP
 CanvasFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
                               const nsRect&           aDirtyRect,
                               const nsDisplayListSet& aLists)
 {
   nsresult rv;
+
+  if (GetPrevInFlow()) {
+    DisplayOverflowContainers(aBuilder, aDirtyRect, aLists);
+  }
+
+  aBuilder->MarkFramesForDisplayList(this, mAbsoluteContainer.GetFirstChild(), aDirtyRect);
+  
   // Force a background to be shown. We may have a background propagated to us,
   // in which case GetStyleBackground wouldn't have the right background
   // and the code in nsFrame::DisplayBorderBackgroundOutline might not give us
   // a background.
   // We don't have any border or outline, and our background draws over
   // the overflow area, so just add nsDisplayCanvasBackground instead of
   // calling DisplayBorderBackgroundOutline.
   if (IsVisibleForPainting(aBuilder)) { 
     rv = aLists.BorderBackground()->AppendNewToTop(new (aBuilder)
            nsDisplayCanvasBackground(this));
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
-  nsIFrame* kid = GetFirstChild(nsnull);
-  if (kid) {
+  nsIFrame* kid;
+  for (kid = GetFirstChild(nsnull); kid; kid = kid->GetNextSibling()) {
     // Put our child into its own pseudo-stack.
     rv = BuildDisplayListForChild(aBuilder, kid, aDirtyRect, aLists,
                                   DISPLAY_CHILD_FORCE_PSEUDO_STACKING_CONTEXT);
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
 #ifdef DEBUG_CANVAS_FOCUS
   nsCOMPtr<nsIContent> focusContent;
@@ -523,87 +598,149 @@ CanvasFrame::GetPrefWidth(nsIRenderingCo
   if (mFrames.IsEmpty())
     result = 0;
   else
     result = mFrames.FirstChild()->GetPrefWidth(aRenderingContext);
   return result;
 }
 
 NS_IMETHODIMP
-CanvasFrame::Reflow(nsPresContext*          aPresContext,
+CanvasFrame::Reflow(nsPresContext*           aPresContext,
                     nsHTMLReflowMetrics&     aDesiredSize,
                     const nsHTMLReflowState& aReflowState,
                     nsReflowStatus&          aStatus)
 {
   DO_GLOBAL_REFLOW_COUNT("CanvasFrame");
   DISPLAY_REFLOW(aPresContext, this, aReflowState, aDesiredSize, aStatus);
   NS_FRAME_TRACE_REFLOW_IN("CanvasFrame::Reflow");
 
   // Initialize OUT parameter
   aStatus = NS_FRAME_COMPLETE;
 
-  // Reflow our one and only child frame
+  CanvasFrame* prevCanvasFrame = static_cast<CanvasFrame*>
+                                               (GetPrevInFlow());
+  if (prevCanvasFrame) {
+    nsIFrame* overflow = prevCanvasFrame->GetOverflowFrames(aPresContext, PR_TRUE);
+    if (overflow) {
+      NS_ASSERTION(!overflow->GetNextSibling(),
+                   "must have doc root as canvas frame's only child");
+      nsHTMLContainerFrame::ReparentFrameView(aPresContext, overflow, prevCanvasFrame, this);
+      // Prepend overflow to the our child list. There may already be
+      // children placeholders for fixed-pos elements, which don't get
+      // reflowed but must not be lost until the canvas frame is destroyed.
+      mFrames.InsertFrames(this, nsnull, overflow);
+    }
+  }
+
+  // Reflow our one and only normal child frame. It's either the root
+  // element's frame or a placeholder for that frame, if the root element
+  // is abs-pos or fixed-pos. We may have additional children which
+  // are placeholders for continuations of fixed-pos content, but those
+  // don't need to be reflowed. The normal child is always comes before
+  // the fixed-pos placeholders, because we insert it at the start
+  // of the child list, above.
   nsHTMLReflowMetrics kidDesiredSize;
   if (mFrames.IsEmpty()) {
     // We have no child frame, so return an empty size
     aDesiredSize.width = aDesiredSize.height = 0;
   } else {
     nsIFrame* kidFrame = mFrames.FirstChild();
     PRBool kidDirty = (kidFrame->GetStateBits() & NS_FRAME_IS_DIRTY) != 0;
 
-    // We must specify an unconstrained available height, because constrained
-    // is only for when we're paginated...
     nsHTMLReflowState kidReflowState(aPresContext, aReflowState, kidFrame,
                                      nsSize(aReflowState.availableWidth,
-                                            NS_UNCONSTRAINEDSIZE));
+                                            aReflowState.availableHeight));
 
     if (aReflowState.mFlags.mVResize &&
         (kidFrame->GetStateBits() & NS_FRAME_CONTAINS_RELATIVE_HEIGHT)) {
       // Tell our kid it's being vertically resized too.  Bit of a
       // hack for framesets.
       kidReflowState.mFlags.mVResize = PR_TRUE;
     }
-    
+
+    nsPoint kidPt(kidReflowState.mComputedMargin.left,
+                  kidReflowState.mComputedMargin.top);
+    // Apply CSS relative positioning
+    const nsStyleDisplay* styleDisp = kidFrame->GetStyleDisplay();
+    if (NS_STYLE_POSITION_RELATIVE == styleDisp->mPosition) {
+      kidPt += nsPoint(kidReflowState.mComputedOffsets.left,
+                       kidReflowState.mComputedOffsets.top);
+    }
+
     // Reflow the frame
     ReflowChild(kidFrame, aPresContext, kidDesiredSize, kidReflowState,
-                kidReflowState.mComputedMargin.left, kidReflowState.mComputedMargin.top,
-                0, aStatus);
+                kidPt.x, kidPt.y, 0, aStatus);
 
     // Complete the reflow and position and size the child frame
     FinishReflowChild(kidFrame, aPresContext, &kidReflowState, kidDesiredSize,
-                      kidReflowState.mComputedMargin.left,
-                      kidReflowState.mComputedMargin.top, 0);
+                      kidPt.x, kidPt.y, 0);
+
+    if (!NS_FRAME_IS_FULLY_COMPLETE(aStatus)) {
+      nsIFrame* nextFrame = kidFrame->GetNextInFlow();
+      NS_ASSERTION(nextFrame || aStatus & NS_FRAME_REFLOW_NEXTINFLOW,
+        "If it's incomplete and has no nif yet, it must flag a nif reflow.");
+      if (!nextFrame) {
+        nsresult rv = nsHTMLContainerFrame::CreateNextInFlow(aPresContext,
+                                              this, kidFrame, nextFrame);
+        NS_ENSURE_SUCCESS(rv, rv);
+        kidFrame->SetNextSibling(nextFrame->GetNextSibling());
+        nextFrame->SetNextSibling(nsnull);
+        SetOverflowFrames(aPresContext, nextFrame);
+        // Root overflow containers will be normal children of
+        // the canvas frame, but that's ok because there
+        // aren't any other frames we need to isolate them from
+        // during reflow.
+      }
+      if (NS_FRAME_OVERFLOW_IS_INCOMPLETE(aStatus)) {
+        nextFrame->AddStateBits(NS_FRAME_IS_OVERFLOW_CONTAINER);
+      }
+    }
 
     // If the child frame was just inserted, then we're responsible for making sure
     // it repaints
     if (kidDirty) {
       // But we have a new child, which will affect our background, so
       // invalidate our whole rect.
       // Note: Even though we request to be sized to our child's size, our
       // scroll frame ensures that we are always the size of the viewport.
       // Also note: GetPosition() on a CanvasFrame is always going to return
       // (0, 0). We only want to invalidate GetRect() since GetOverflowRect()
       // could also include overflow to our top and left (out of the viewport)
       // which doesn't need to be painted.
       nsIFrame* viewport = PresContext()->GetPresShell()->GetRootFrame();
       viewport->Invalidate(nsRect(nsPoint(0, 0), viewport->GetSize()));
     }
-
+    
     // Return our desired size (which doesn't matter)
-    aDesiredSize.width = aReflowState.availableWidth;
-    aDesiredSize.height = kidDesiredSize.height +
-                          kidReflowState.mComputedMargin.TopBottom();
+    aDesiredSize.width = aReflowState.ComputedWidth();
+    aDesiredSize.height = aReflowState.ComputedHeight();
 
     aDesiredSize.mOverflowArea.UnionRect(
       nsRect(0, 0, aDesiredSize.width, aDesiredSize.height),
-      kidDesiredSize.mOverflowArea +
-        nsPoint(kidReflowState.mComputedMargin.left,
-                kidReflowState.mComputedMargin.top));
-    FinishAndStoreOverflow(&aDesiredSize);
+      kidDesiredSize.mOverflowArea + kidPt);
+
+    if (mAbsoluteContainer.HasAbsoluteFrames()) {
+      PRBool widthChanged = aDesiredSize.width != mRect.width;
+      PRBool heightChanged = aDesiredSize.height != mRect.height;
+      nsRect absPosBounds;
+      mAbsoluteContainer.Reflow(this, aPresContext, aReflowState, aStatus,
+                                aDesiredSize.width, aDesiredSize.height,
+                                PR_TRUE, widthChanged, heightChanged,
+                                &absPosBounds);
+      aDesiredSize.mOverflowArea.UnionRect(aDesiredSize.mOverflowArea, absPosBounds);
+    }
   }
+
+  if (prevCanvasFrame) {
+    ReflowOverflowContainerChildren(aPresContext, aReflowState,
+                                    aDesiredSize.mOverflowArea, 0,
+                                    aStatus);
+  }
+
+  FinishAndStoreOverflow(&aDesiredSize);
 
   NS_FRAME_TRACE_REFLOW_OUT("CanvasFrame::Reflow", aStatus);
   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aDesiredSize);
   return NS_OK;
 }
 
 PRIntn
 CanvasFrame::GetSkipSides() const
diff -r b7bcdd009540 layout/generic/nsHTMLParts.h
--- a/layout/generic/nsHTMLParts.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/generic/nsHTMLParts.h	Thu Sep 11 15:19:26 2008 +0300
@@ -108,41 +108,34 @@ NS_NewAreaFrame(nsIPresShell* aPresShell
 NS_NewAreaFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, PRUint32 aFlags);
 
 // These AreaFrame's shrink wrap around their contents
 inline nsIFrame*
 NS_NewTableCellInnerFrame(nsIPresShell* aPresShell, nsStyleContext* aContext) {
   return NS_NewBlockFrame(aPresShell, aContext);
 }
 
-// This type of AreaFrame is the document root, a margin root, and the
-// initial containing block for absolutely positioned elements
+// This type of BlockFrame is a margin root, but does not shrink wrap
 inline nsIFrame*
-NS_NewDocumentElementFrame(nsIPresShell* aPresShell, nsStyleContext* aContext) {
-  return NS_NewAreaFrame(aPresShell, aContext, NS_BLOCK_SPACE_MGR|NS_BLOCK_MARGIN_ROOT);
+NS_NewAbsoluteItemWrapperFrame(nsIPresShell* aPresShell, nsStyleContext* aContext) {
+  return NS_NewBlockFrame(aPresShell, aContext, NS_BLOCK_SPACE_MGR|NS_BLOCK_MARGIN_ROOT);
 }
 
-// This type of AreaFrame is a margin root, but does not shrink wrap
-inline nsIFrame*
-NS_NewAbsoluteItemWrapperFrame(nsIPresShell* aPresShell, nsStyleContext* aContext) {
-  return NS_NewAreaFrame(aPresShell, aContext, NS_BLOCK_SPACE_MGR|NS_BLOCK_MARGIN_ROOT);
-}
-
-// This type of AreaFrame shrink wraps
+// This type of BlockFrame shrink wraps
 inline nsIFrame*
 NS_NewFloatingItemWrapperFrame(nsIPresShell* aPresShell, nsStyleContext* aContext) {
-  return NS_NewAreaFrame(aPresShell, aContext,
+  return NS_NewBlockFrame(aPresShell, aContext,
     NS_BLOCK_SPACE_MGR|NS_BLOCK_MARGIN_ROOT);
 }
 
-// This type of AreaFrame doesn't use its own space manager and
+// This type of BlockFrame doesn't use its own space manager and
 // doesn't shrink wrap.
 inline nsIFrame*
 NS_NewRelativeItemWrapperFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, PRUint32 aFlags) {
-  return NS_NewAreaFrame(aPresShell, aContext, aFlags);
+  return NS_NewBlockFrame(aPresShell, aContext, aFlags);
 }
 
 nsIFrame*
 NS_NewBRFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
 
 nsIFrame*
 NS_NewCommentFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
 
diff -r b7bcdd009540 layout/generic/nsHTMLReflowState.cpp
--- a/layout/generic/nsHTMLReflowState.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/generic/nsHTMLReflowState.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -1526,35 +1526,17 @@ nsHTMLReflowState::ComputeContainingBloc
       aContainingBlockHeight = aContainingBlockRS->frame->GetRect().height -
         computedBorder.TopBottom();
       NS_ASSERTION(aContainingBlockHeight >= 0,
                    "Negative containing block height!");
     } else {
       // If the ancestor is block-level, the containing block is formed by the
       // padding edge of the ancestor
       aContainingBlockWidth += aContainingBlockRS->mComputedPadding.LeftRight();
-
-      // If the containing block is the initial containing block and it has a
-      // height that depends on its content, then use the viewport height instead.
-      // This gives us a reasonable value against which to compute percentage
-      // based heights and to do bottom relative positioning
-      if ((NS_AUTOHEIGHT == aContainingBlockHeight) &&
-          nsLayoutUtils::IsInitialContainingBlock(aContainingBlockRS->frame)) {
-
-        // Use the viewport height as the containing block height
-        const nsHTMLReflowState* rs = aContainingBlockRS->parentReflowState;
-        while (rs) {
-          aContainingBlockHeight = rs->mComputedHeight;
-          rs = rs->parentReflowState;
-        }
-
-      } else {
-        aContainingBlockHeight +=
-          aContainingBlockRS->mComputedPadding.TopBottom();
-      }
+      aContainingBlockHeight += aContainingBlockRS->mComputedPadding.TopBottom();
     }
   } else {
     // an element in quirks mode gets a containing block based on looking for a
     // parent with a non-auto height if the element has a percent height
     if (NS_AUTOHEIGHT == aContainingBlockHeight) {
       if (eCompatibility_NavQuirks == aPresContext->CompatibilityMode() &&
           mStylePosition->mHeight.GetUnit() == eStyleUnit_Percent) {
         aContainingBlockHeight = CalcQuirkContainingBlockHeight(aContainingBlockRS);
diff -r b7bcdd009540 layout/generic/nsInlineFrame.cpp
--- a/layout/generic/nsInlineFrame.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/generic/nsInlineFrame.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -1068,21 +1068,18 @@ nsPositionedInlineFrame::GetAdditionalCh
     return nsGkAtoms::absoluteList;
   }
   return nsnull;
 }
 
 nsIFrame*
 nsPositionedInlineFrame::GetFirstChild(nsIAtom* aListName) const
 {
-  if (nsGkAtoms::absoluteList == aListName) {
-    nsIFrame* result = nsnull;
-    mAbsoluteContainer.FirstChild(this, aListName, &result);
-    return result;
-  }
+  if (nsGkAtoms::absoluteList == aListName)
+    return mAbsoluteContainer.GetFirstChild();
 
   return nsInlineFrame::GetFirstChild(aListName);
 }
 
 nsIAtom*
 nsPositionedInlineFrame::GetType() const
 {
   return nsGkAtoms::positionedInlineFrame;
diff -r b7bcdd009540 layout/generic/nsObjectFrame.cpp
--- a/layout/generic/nsObjectFrame.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/generic/nsObjectFrame.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -1164,16 +1164,17 @@ nsObjectFrame::PrintPlugin(nsIRenderingC
     return;
 
   // finally we can get our plugin instance
   nsCOMPtr<nsIPluginInstance> pi;
   if (NS_FAILED(objectFrame->GetPluginInstance(*getter_AddRefs(pi))) || !pi)
     return;
 
   // now we need to setup the correct location for printing
+  nsresult rv;
   nsPluginWindow    window;
   window.window =   nsnull;
 
   // prepare embedded mode printing struct
   nsPluginPrint npprint;
   npprint.mode = nsPluginMode_Embedded;
 
   // we need to find out if we are windowless or not
@@ -1212,17 +1213,17 @@ nsObjectFrame::PrintPlugin(nsIRenderingC
   npPrintInfo.fp   = plugintmpfile;
   npprint.print.embedPrint.platformPrint = (void *)&npPrintInfo;
   /* aDirtyRect contains the right information for ps print */
   window.x =   aDirtyRect.x;
   window.y =   aDirtyRect.y;
   window.width =   aDirtyRect.width;
   window.height =   aDirtyRect.height;
   npprint.print.embedPrint.window        = window;
-  nsresult rv = pi->Print(&npprint);
+  rv = pi->Print(&npprint);
   if (NS_FAILED(rv)) {
     PR_LOG(nsObjectFrameLM, PR_LOG_DEBUG, ("error: plugin returned failure %lx\n", (long)rv));
     fclose(plugintmpfile);
     return;
   }
 
   /* Send data to printer */
   rv = aRenderingContext.RenderEPS(aDirtyRect, plugintmpfile);
@@ -1235,17 +1236,17 @@ nsObjectFrame::PrintPlugin(nsIRenderingC
 #elif defined(XP_OS2)
   void *hps = aRenderingContext.GetNativeGraphicData(nsIRenderingContext::NATIVE_OS2_PS);
   if (!hps)
     return;
 
   npprint.print.embedPrint.platformPrint = hps;
   npprint.print.embedPrint.window = window;
   // send off print info to plugin
-  pi->Print(&npprint);
+  rv = pi->Print(&npprint);
 #elif defined(XP_WIN)
 
   /* On Windows, we use the win32 printing surface to print.  This, in
    * turn, uses the Cairo paginated surface, which in turn uses the
    * meta surface to record all operations and then play them back.
    * This doesn't work too well for plugins, because if plugins render
    * directly into the DC, the meta surface won't have any knowledge
    * of them, and so at the end when it actually does the replay step,
@@ -1289,17 +1290,17 @@ nsObjectFrame::PrintPlugin(nsIRenderingC
   do {
     HDC dc = nativeDraw.BeginNativeDrawing();
     if (!dc)
       return;
 
     npprint.print.embedPrint.platformPrint = dc;
     npprint.print.embedPrint.window = window;
     // send off print info to plugin
-    pi->Print(&npprint);
+    rv = pi->Print(&npprint);
 
     nativeDraw.EndNativeDrawing();
   } while (nativeDraw.ShouldRenderAgain());
   nativeDraw.PaintToContext();
 
   ctx->PopGroupToSource();
   ctx->Paint();
 
@@ -1326,17 +1327,17 @@ nsObjectFrame::PrintPlugin(nsIRenderingC
   void* dc;
   dc = aRenderingContext.GetNativeGraphicData(nsIRenderingContext::NATIVE_WINDOWS_DC);
   if (!dc)
     return; // no dc implemented so quit
 
   npprint.print.embedPrint.platformPrint = dc;
   npprint.print.embedPrint.window = window;
   // send off print info to plugin
-  pi->Print(&npprint);
+    rv = pi->Print(&npprint);
 #endif
 
   // XXX Nav 4.x always sent a SetWindow call after print. Should we do the same?
   nsDidReflowStatus status = NS_FRAME_REFLOW_FINISHED; // should we use a special status?
   frame->DidReflow(presContext,
                    nsnull, status);  // DidReflow will take care of it
 }
 
diff -r b7bcdd009540 layout/generic/nsPageContentFrame.cpp
--- a/layout/generic/nsPageContentFrame.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/generic/nsPageContentFrame.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -64,136 +64,47 @@ nsPageContentFrame::ComputeSize(nsIRende
 {
   NS_ASSERTION(mPD, "Pages are supposed to have page data");
   nscoord height = (!mPD || mPD->mReflowSize.height == NS_UNCONSTRAINEDSIZE)
                    ? NS_UNCONSTRAINEDSIZE
                    : (mPD->mReflowSize.height - mPD->mReflowMargin.TopBottom());
   return nsSize(aAvailableWidth, height);
 }
 
-/**
- * Returns true if aFrame is a placeholder for one of our fixed frames.
- */
-inline PRBool
-nsPageContentFrame::IsFixedPlaceholder(nsIFrame* aFrame)
-{
-  if (!aFrame || nsGkAtoms::placeholderFrame != aFrame->GetType())
-    return PR_FALSE;
-
-  return static_cast<nsPlaceholderFrame*>(aFrame)->GetOutOfFlowFrame()
-           ->GetParent() == this;
-}
-
-/**
- * Steals replicated fixed placeholder frames from aDocRoot so they don't
- * get in the way of reflow.
- */
-inline nsFrameList
-nsPageContentFrame::StealFixedPlaceholders(nsIFrame* aDocRoot)
-{
-  nsPresContext* presContext = PresContext();
-  nsFrameList list;
-  if (GetPrevInFlow()) {
-    for (nsIFrame* f = aDocRoot->GetFirstChild(nsnull);
-        IsFixedPlaceholder(f); f = aDocRoot->GetFirstChild(nsnull)) {
-      nsresult rv = static_cast<nsContainerFrame*>(aDocRoot)
-                      ->StealFrame(presContext, f);
-      NS_ENSURE_SUCCESS(rv, list);
-      list.AppendFrame(nsnull, f);
-    }
-  }
-  return list;
-}
-
-/**
- * Restores stolen replicated fixed placeholder frames to aDocRoot.
- */
-static inline nsresult
-ReplaceFixedPlaceholders(nsIFrame*    aDocRoot,
-                         nsFrameList& aPlaceholderList)
-{
-  nsresult rv = NS_OK;
-  if (aPlaceholderList.NotEmpty()) {
-    rv = static_cast<nsContainerFrame*>(aDocRoot)
-           ->AddFrames(aPlaceholderList.FirstChild(), nsnull);
-  }
-  return rv;
-}
-
 NS_IMETHODIMP
 nsPageContentFrame::Reflow(nsPresContext*           aPresContext,
                            nsHTMLReflowMetrics&     aDesiredSize,
                            const nsHTMLReflowState& aReflowState,
                            nsReflowStatus&          aStatus)
 {
   DO_GLOBAL_REFLOW_COUNT("nsPageContentFrame");
   DISPLAY_REFLOW(aPresContext, this, aReflowState, aDesiredSize, aStatus);
   aStatus = NS_FRAME_COMPLETE;  // initialize out parameter
   nsresult rv = NS_OK;
 
-  // A PageContentFrame must always have one child: the doc root element's frame.
-  // We only need to get overflow frames if we don't already have that child;
-  // Also we need to avoid repeating the call to ReplicateFixedFrames.
-  nsPageContentFrame* prevPageContentFrame = static_cast<nsPageContentFrame*>
-                                               (GetPrevInFlow());
-  if (mFrames.IsEmpty() && prevPageContentFrame) {
-    // Pull the doc root frame's continuation and copy fixed frames.
-    nsIFrame* overflow = prevPageContentFrame->GetOverflowFrames(aPresContext, PR_TRUE);
-    NS_ASSERTION(overflow && !overflow->GetNextSibling(),
-                 "must have doc root as pageContentFrame's only child");
-    nsHTMLContainerFrame::ReparentFrameView(aPresContext, overflow, prevPageContentFrame, this);
-    // Prepend overflow to the page content frame. There may already be
-    // children placeholders which don't get reflowed but must not be
-    // lost until the page content frame is destroyed.
-    mFrames.InsertFrames(this, nsnull, overflow);
+  if (GetPrevInFlow() && (GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
     nsresult rv = aPresContext->PresShell()->FrameConstructor()
                     ->ReplicateFixedFrames(this);
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
+  // A PageContentFrame must always have one child: the canvas frame.
   // Resize our frame allowing it only to be as big as we are
   // XXX Pay attention to the page's border and padding...
   if (mFrames.NotEmpty()) {
     nsIFrame* frame = mFrames.FirstChild();
     nsSize  maxSize(aReflowState.availableWidth, aReflowState.availableHeight);
     nsHTMLReflowState kidReflowState(aPresContext, aReflowState, frame, maxSize);
+    kidReflowState.SetComputedHeight(aReflowState.availableHeight);
 
     mPD->mPageContentSize  = aReflowState.availableWidth;
-
-    // Get replicated fixed frames' placeholders out of the way
-    nsFrameList stolenPlaceholders = StealFixedPlaceholders(frame);
 
     // Reflow the page content area
     rv = ReflowChild(frame, aPresContext, aDesiredSize, kidReflowState, 0, 0, 0, aStatus);
     NS_ENSURE_SUCCESS(rv, rv);
-
-    // Put removed fixed placeholders back
-    rv = ReplaceFixedPlaceholders(frame, stolenPlaceholders);
-    NS_ENSURE_SUCCESS(rv, rv);
-
-    if (!NS_FRAME_IS_FULLY_COMPLETE(aStatus)) {
-      nsIFrame* nextFrame = frame->GetNextInFlow();
-      NS_ASSERTION(nextFrame || aStatus & NS_FRAME_REFLOW_NEXTINFLOW,
-        "If it's incomplete and has no nif yet, it must flag a nif reflow.");
-      if (!nextFrame) {
-        nsresult rv = nsHTMLContainerFrame::CreateNextInFlow(aPresContext,
-                                              this, frame, nextFrame);
-        NS_ENSURE_SUCCESS(rv, rv);
-        frame->SetNextSibling(nextFrame->GetNextSibling());
-        nextFrame->SetNextSibling(nsnull);
-        SetOverflowFrames(aPresContext, nextFrame);
-        // Root overflow containers will be normal children of
-        // the pageContentFrame, but that's ok because there
-        // aren't any other frames we need to isolate them from
-        // during reflow.
-      }
-      if (NS_FRAME_OVERFLOW_IS_INCOMPLETE(aStatus)) {
-        nextFrame->AddStateBits(NS_FRAME_IS_OVERFLOW_CONTAINER);
-      }
-    }
 
     // The document element's background should cover the entire canvas, so
     // take into account the combined area and any space taken up by
     // absolutely positioned elements
     nsMargin padding(0,0,0,0);
 
     // XXXbz this screws up percentage padding (sets padding to zero
     // in the percentage padding case)
diff -r b7bcdd009540 layout/generic/nsPageContentFrame.h
--- a/layout/generic/nsPageContentFrame.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/generic/nsPageContentFrame.h	Thu Sep 11 15:19:26 2008 +0300
@@ -78,16 +78,12 @@ public:
   // Debugging
   NS_IMETHOD  GetFrameName(nsAString& aResult) const;
 #endif
 
 protected:
   nsPageContentFrame(nsStyleContext* aContext) : ViewportFrame(aContext) {}
 
   nsSharedPageData*         mPD;
-
-private:
-  PRBool IsFixedPlaceholder(nsIFrame* aFrame);
-  nsFrameList StealFixedPlaceholders(nsIFrame* aDocRoot);
 };
 
 #endif /* nsPageContentFrame_h___ */
 
diff -r b7bcdd009540 layout/generic/nsViewportFrame.cpp
--- a/layout/generic/nsViewportFrame.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/generic/nsViewportFrame.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -174,21 +174,18 @@ ViewportFrame::GetAdditionalChildListNam
   }
 
   return nsnull;
 }
 
 nsIFrame*
 ViewportFrame::GetFirstChild(nsIAtom* aListName) const
 {
-  if (nsGkAtoms::fixedList == aListName) {
-    nsIFrame* result = nsnull;
-    mFixedContainer.FirstChild(this, aListName, &result);
-    return result;
-  }
+  if (nsGkAtoms::fixedList == aListName)
+    return mFixedContainer.GetFirstChild();
 
   return nsContainerFrame::GetFirstChild(aListName);
 }
 
 /* virtual */ nscoord
 ViewportFrame::GetMinWidth(nsIRenderingContext *aRenderingContext)
 {
   nscoord result;
@@ -304,18 +301,17 @@ ViewportFrame::Reflow(nsPresContext*    
                           : kidHeight;
 
   // Make a copy of the reflow state and change the computed width and height
   // to reflect the available space for the fixed items
   nsHTMLReflowState reflowState(aReflowState);
   nsPoint offset = AdjustReflowStateForScrollbars(&reflowState);
   
 #ifdef DEBUG
-  nsIFrame* f;
-  mFixedContainer.FirstChild(this, nsGkAtoms::fixedList, &f);
+  nsIFrame* f = mFixedContainer.GetFirstChild();
   NS_ASSERTION(!f || (offset.x == 0 && offset.y == 0),
                "We don't handle correct positioning of fixed frames with "
                "scrollbars in odd positions");
 #endif
 
   // Just reflow all the fixed-pos frames.
   rv = mFixedContainer.Reflow(this, aPresContext, reflowState, aStatus,
                               reflowState.ComputedWidth(),
diff -r b7bcdd009540 layout/printing/nsPrintEngine.cpp
--- a/layout/printing/nsPrintEngine.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/printing/nsPrintEngine.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -1188,17 +1188,22 @@ nsPrintEngine::MapContentToWebShells(nsP
                                      nsPrintObject* aPO)
 {
   NS_ASSERTION(aRootPO, "Pointer is null!");
   NS_ASSERTION(aPO, "Pointer is null!");
 
   // Recursively walk the content from the root item
   // XXX Would be faster to enumerate the subdocuments, although right now
   //     nsIDocument doesn't expose quite what would be needed.
-  MapContentForPO(aPO, aPO->mDocument->GetRootContent());
+  nsIContent *rootContent = aPO->mDocument->GetRootContent();
+  if (rootContent) {
+    MapContentForPO(aPO, rootContent);
+  } else {
+    NS_WARNING("Null root content on (sub)document.");
+  }
 
   // Continue recursively walking the chilren of this PO
   for (PRInt32 i=0;i<aPO->mKids.Count();i++) {
     MapContentToWebShells(aRootPO, (nsPrintObject*)aPO->mKids[i]);
   }
 
 }
 
diff -r b7bcdd009540 layout/reftests/bugs/243519-9f.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/243519-9f.html	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,5 @@
+<!DOCTYPE HTML>
+<html style="position:relative; height:50%;">
+<body style="position:absolute; width:50%; top:50px; left:50px; height:100%; margin:0; border:10px solid black;">
+</body>
+</html>
diff -r b7bcdd009540 layout/reftests/bugs/449171-1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/449171-1.html	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,16 @@
+<!DOCTYPE html>
+<html>
+  <head>
+    <style>
+      @import url("data:text/css,.import { color: green }");
+      div { color: red }
+      @media {
+        .media { color: green }
+      }
+    </style>
+  </head>
+  <body>
+    <div class="import">test</div>
+    <div class="media">test</div>
+  <body>
+</html>
diff -r b7bcdd009540 layout/reftests/bugs/449171-ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/449171-ref.html	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,12 @@
+<!DOCTYPE html>
+<html>
+  <head>
+    <style>
+      div { color: green }
+    </style>
+  </head>
+  <body>
+    <div>test</div>
+    <div>test</div>
+  <body>
+</html>
diff -r b7bcdd009540 layout/reftests/bugs/reftest.list
--- a/layout/reftests/bugs/reftest.list	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/reftests/bugs/reftest.list	Thu Sep 11 15:19:26 2008 +0300
@@ -120,16 +120,17 @@ fails == 25888-3r.html 25888-3r-ref.html
 == 163504-1b.html 163504-1-ref.html
 == 163504-2a.html 163504-2-ref.html
 == 163504-2b.html 163504-2-ref.html
 == 169749-1.html 169749-1-ref.html
 == 172073-1.html 172073-1-ref.html
 == 180085-1.html 180085-1-ref.html
 == 180085-2.html 180085-2-ref.html
 == 185388-1.html 185388-1-ref.html
+!= 200774-1.html about:blank # really a crashtest
 == 201215-1.html 201215-1-ref.html
 == 201293-1a.html 201293-1-ref.html
 == 201293-1b.html 201293-1-ref.html
 == 201293-1c.html 201293-1-ref.html
 == 201293-1d.html 201293-1-ref.html
 == 206516-1.html 206516-1-ref.html
 == 210094-1a.html 210094-1-ref.html
 == 210094-1b.html 210094-1-ref.html
@@ -161,16 +162,38 @@ fails == 25888-3r.html 25888-3r-ref.html
 == 234686-19.html 234686-ref.html
 == 234964-1.html 234964-1-ref.html
 == 234964-2.html 234964-2-ref.html
 == 235593-1.html 235593-1-ref.html
 == 236539-1.html 236539-1-ref.html
 == 240470-1.html 240470-1-ref.html
 == 243266-1.html 243266-1-ref.html
 == 243302-1.html 243302-1-ref.html
+== 243519-1.html 243519-1-ref.html
+== 243519-2.html 243519-2-ref.html
+== 243519-3.html 243519-3-ref.html
+== 243519-4a.html 243519-4-ref.html
+== 243519-4b.html 243519-4-ref.html
+== 243519-4c.html 243519-4-ref.html
+== 243519-4d.html 243519-4-ref.html
+== 243519-4e.html 243519-4-ref.html
+== 243519-4f.html 243519-4-ref.html
+== 243519-5a.html 243519-5-ref.html
+== 243519-5b.html 243519-5-ref.html
+== 243519-5c.html 243519-5-ref.html
+== 243519-5d.html 243519-5-ref.html
+== 243519-6.html 243519-6-ref.html
+== 243519-7.html 243519-7-ref.html
+== 243519-8.svg 243519-8-ref.svg
+== 243519-9a.html 243519-9-ref.html
+== 243519-9b.html 243519-9-ref.html
+== 243519-9c.html 243519-9-ref.html
+== 243519-9d.html 243519-9-ref.html
+== 243519-9e.html 243519-9-ref.html
+== 243519-9f.html 243519-9-ref.html
 == 244135-1.html 244135-1-ref.html
 == 244135-2.html 244135-2-ref.html
 == 244932-1.html 244932-1-ref.html
 == 249982-1.html 249982-1-ref.html
 == 253701-1.html 253701-1-ref.html
 == 255820-1.html 255820-1-ref.html
 == 262151-1.html 262151-1-ref.html
 #== 263683-1.html 263683-1-ref.html
@@ -877,12 +900,13 @@ random == 429849-1.html 429849-1-ref.htm
 == 438987-2c.html 438987-2-ref.html
 != about:blank 438987-2-ref.html # check that backgrounds work at all 
 == 439004-1.html 439004-1-ref.html
 == 439910.html 439910-ref.html
 == 441259-1.html 441259-1-ref.html
 fails == 441259-2.html 441259-2-ref.html # bug 441400
 == 444015-1.html 444015-1-ref.html
 # == 448987.html 448987-ref.html  # Disabled for now - it needs privileges
+== 449171-1.html 449171-ref.html
 == 449519-1.html 449519-1-ref.html
 # == 449653-1.html 449653-1-ref.html # Disabled for now - it needs privileges
 == 450670-1.html 450670-1-ref.html
 == 451168-1.html 451168-1-ref.html
diff -r b7bcdd009540 layout/reftests/css-import/290018-1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/css-import/290018-1.html	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,13 @@
+<!DOCTYPE html>
+<body>
+  <iframe></iframe>
+  <script>
+    var win = window.frames[0];
+    win.document.open();
+    win.document.write("<!DOCTYPE html><html><head></head><body></body></html>");
+    win.document.close();
+    win.document.body.innerHTML = "<link rel='stylesheet' type='text/css' href='outer-sheet.css' />";
+    win.document.body.innerHTML += "<p>test</p>";
+  </script>
+</body>
+                                              
diff -r b7bcdd009540 layout/reftests/css-import/290018-ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/css-import/290018-ref.html	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,11 @@
+<!DOCTYPE html>
+<body>
+  <iframe></iframe>
+  <script>
+    var win = window.frames[0];
+    win.document.open();
+    win.document.write("<!DOCTYPE html><html><head><link rel='stylesheet' type='text/css' href='outer-sheet.css' /></head><body><p>test</p></body></html>");
+    win.document.close();
+  </script>
+</body>
+                                              
diff -r b7bcdd009540 layout/reftests/css-import/436261-1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/css-import/436261-1.html	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,15 @@
+<!DOCTYPE html>
+<html>
+  <body>
+    <script type="text/javascript">
+      var el = document.createElement("link");
+      el.type = "text/css";
+      el.rel = "stylesheet";
+      el.href = "outer-sheet.css";
+      var h = document.getElementsByTagName("HEAD")[0];
+      h.appendChild(el);
+      el.title = "theme"; // comment this line to make the test work!
+    </script>
+    <p>test</p>
+  </body>
+</html>
diff -r b7bcdd009540 layout/reftests/css-import/436261-2.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/css-import/436261-2.html	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,12 @@
+<!DOCTYPE html>
+<html>
+  <head>
+    <link type="text/css" rel="stylesheet" media="print"
+          href="outer-sheet.css">
+    <link type="text/css" rel="stylesheet" media="screen"
+          href="outer-sheet.css">
+  </head>
+  <body>
+    <p>test</p>
+  </body>
+</html>
diff -r b7bcdd009540 layout/reftests/css-import/436261-3.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/css-import/436261-3.html	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,21 @@
+<html>
+  <body>
+    <script type="text/javascript">
+      var el = document.createElement("link");
+      el.type = "text/css";
+      el.rel = "stylesheet";
+      el.media = "print"
+      el.href = "outer-sheet.css";
+      var h = document.getElementsByTagName("HEAD")[0];
+      h.appendChild(el);
+
+      el = document.createElement("link");
+      el.type = "text/css";
+      el.rel = "stylesheet";
+      el.href = "outer-sheet.css";
+      var h = document.getElementsByTagName("HEAD")[0];
+      h.appendChild(el);
+    </script>
+    <p>test</p>
+  </body>
+</html>
diff -r b7bcdd009540 layout/reftests/css-import/436261-ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/css-import/436261-ref.html	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,6 @@
+<!DOCTYPE html>
+<html>
+  <body>
+    <p style="background-color: green; color: white">test</p>
+  </body>
+</html>
diff -r b7bcdd009540 layout/reftests/css-import/444723-1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/css-import/444723-1.html	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,20 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
+  "http://www.w3.org/TR/xhtml1/DTD/xhtml1.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
+
+<head>
+<link rel="stylesheet" media="screen" type="text/css"
+    href="outermost-sheet.css" title="A"/>
+<link rel="alternate stylesheet" media="screen" type="text/css"
+  href="outer-sheet.css" title="B"/>
+
+</head>
+
+<body>
+  <ul>
+    <li class="outermost">purple</li>
+    <li class="outer">blue</li>
+    <li class="inner">yellow</li>
+  </ul>
+</body>
+</html>
diff -r b7bcdd009540 layout/reftests/css-import/444723-2.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/css-import/444723-2.html	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,20 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
+  "http://www.w3.org/TR/xhtml1/DTD/xhtml1.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
+
+<head>
+<link rel="alternate stylesheet" media="screen" type="text/css"
+  href="outer-sheet.css" title="B"/>
+<link rel="stylesheet" media="screen" type="text/css"
+    href="outermost-sheet.css" title="A"/>
+
+</head>
+
+<body>
+  <ul>
+    <li class="outermost">purple</li>
+    <li class="outer">blue</li>
+    <li class="inner">yellow</li>
+  </ul>
+</body>
+</html>
diff -r b7bcdd009540 layout/reftests/css-import/444723-ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/css-import/444723-ref.html	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,12 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
+  "http://www.w3.org/TR/xhtml1/DTD/xhtml1.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
+
+<body>
+  <ul>
+    <li style="color: purple">purple</li>
+    <li style="color: blue">blue</li>
+    <li style="color: yellow">yellow</li>
+  </ul>
+</body>
+</html>
diff -r b7bcdd009540 layout/reftests/css-import/445415-1-ref.xhtml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/css-import/445415-1-ref.xhtml	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="iso-8859-1" ?>
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
+
+<html xmlns="http://www.w3.org/1999/xhtml">
+
+<body>
+<div style="color: purple">purple</div>
+<div style="color: blue">blue</div>
+<div style="color: yellow">yellow</div>
+</body>
+
+</html>
diff -r b7bcdd009540 layout/reftests/css-import/445415-1a.xhtml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/css-import/445415-1a.xhtml	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="iso-8859-1" ?>
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
+
+<html xmlns="http://www.w3.org/1999/xhtml">
+
+<head>
+    <link rel="stylesheet" type="text/css" href="other-outermost-sheet.css"
+          media="print" />
+    <link rel="stylesheet" type="text/css" href="outermost-sheet.css"
+          media="screen" />
+</head>
+
+<body>
+<div class="outermost">purple</div>
+<div class="outer">blue</div>
+<div class="inner">yellow</div>
+</body>
+
+</html>
diff -r b7bcdd009540 layout/reftests/css-import/445415-1b.xhtml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/css-import/445415-1b.xhtml	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="iso-8859-1" ?>
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
+
+<html xmlns="http://www.w3.org/1999/xhtml">
+
+<head>
+    <link rel="stylesheet" type="text/css" href="outermost-sheet.css"
+          media="screen" />
+    <link rel="stylesheet" type="text/css" href="other-outermost-sheet.css"
+          media="print" />
+</head>
+
+<body>
+<div class="outermost">purple</div>
+<div class="outer">blue</div>
+<div class="inner">yellow</div>
+</body>
+
+</html>
diff -r b7bcdd009540 layout/reftests/css-import/445415-2-ref.xhtml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/css-import/445415-2-ref.xhtml	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="iso-8859-1" ?>
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
+
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+
+<body>
+<div style="color: cyan">cyan</div>
+<div style="color: blue">blue</div>
+<div style="color: yellow">yellow</div>
+</body>
+
+</html>
diff -r b7bcdd009540 layout/reftests/css-import/445415-2a.xhtml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/css-import/445415-2a.xhtml	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="iso-8859-1" ?>
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
+
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+
+<head>
+    <link rel="stylesheet" type="text/css" href="other-outermost-sheet.css"
+          media="print" />
+    <link rel="stylesheet" type="text/css" href="outermost-sheet.css"
+          media="screen" />
+</head>
+
+<body>
+<div class="outermost">cyan</div>
+<div class="outer">blue</div>
+<div class="inner">yellow</div>
+</body>
+
+</html>
diff -r b7bcdd009540 layout/reftests/css-import/445415-2b.xhtml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/css-import/445415-2b.xhtml	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="iso-8859-1" ?>
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
+
+<html xmlns="http://www.w3.org/1999/xhtml" class="reftest-print">
+
+<head>
+    <link rel="stylesheet" type="text/css" href="outermost-sheet.css"
+          media="screen" />
+    <link rel="stylesheet" type="text/css" href="other-outermost-sheet.css"
+          media="print" />
+</head>
+
+<body>
+<div class="outermost">cyan</div>
+<div class="outer">blue</div>
+<div class="inner">yellow</div>
+</body>
+
+</html>
diff -r b7bcdd009540 layout/reftests/css-import/inner-sheet.css
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/css-import/inner-sheet.css	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,2 @@
+p { background-color: green; color: white }
+.inner { color: yellow; }
\ No newline at end of file
diff -r b7bcdd009540 layout/reftests/css-import/other-outermost-sheet.css
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/css-import/other-outermost-sheet.css	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,3 @@
+@import url("outer-sheet.css");
+
+.outermost { color: cyan; }
diff -r b7bcdd009540 layout/reftests/css-import/outer-sheet.css
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/css-import/outer-sheet.css	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,2 @@
+@import url("inner-sheet.css");
+.outer { color: blue; }
diff -r b7bcdd009540 layout/reftests/css-import/outermost-sheet.css
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/css-import/outermost-sheet.css	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,3 @@
+@import url("outer-sheet.css");
+
+.outermost { color: purple; }
diff -r b7bcdd009540 layout/reftests/css-import/reftest.list
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/css-import/reftest.list	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,10 @@
+== 290018-1.html 290018-ref.html
+== 436261-1.html 436261-ref.html
+== 436261-2.html 436261-ref.html
+== 436261-3.html 436261-ref.html
+== 444723-1.html 444723-ref.html
+== 444723-2.html 444723-ref.html
+== 445415-1a.xhtml 445415-1-ref.xhtml
+== 445415-1b.xhtml 445415-1-ref.xhtml
+== 445415-2a.xhtml 445415-2-ref.xhtml
+== 445415-2b.xhtml 445415-2-ref.xhtml
diff -r b7bcdd009540 layout/reftests/reftest.list
--- a/layout/reftests/reftest.list	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/reftests/reftest.list	Thu Sep 11 15:19:26 2008 +0300
@@ -23,16 +23,19 @@ include box-properties/reftest.list
 # box-shadow/
 include box-shadow/reftest.list
 
 # bugs/
 include bugs/reftest.list
 
 # canvas 2D
 include canvas/reftest.list
+
+# css @import tests
+include css-import/reftest.list
 
 # columns/
 include columns/reftest.list
 
 # content/
 include ../../content/test/reftest/reftest.list
 
 # counters/
@@ -76,16 +79,19 @@ include pixel-rounding/reftest.list
 
 # printing
 include printing/reftest.list
 include pagination/reftest.list
 
 # svg/
 include svg/reftest.list
 
+# svg-integration/
+include svg-integration/reftest.list
+
 # table-background/
 include table-background/reftest.list
 
 # table-dom/
 include table-dom/reftest.list
 
 # table-width/
 include table-width/reftest.list
diff -r b7bcdd009540 layout/reftests/svg-integration/clipPath-html-01-ref.svg
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/svg-integration/clipPath-html-01-ref.svg	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,8 @@
+<!--
+     Any copyright is dedicated to the Public Domain.
+     http://creativecommons.org/licenses/publicdomain/
+-->
+<svg xmlns="http://www.w3.org/2000/svg" version="1.1"
+     xmlns:xlink="http://www.w3.org/1999/xlink">
+ <rect x="250" y="0" width="250" height="500" fill="lime"/>
+</svg>
diff -r b7bcdd009540 layout/reftests/svg-integration/clipPath-html-01.xhtml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/svg-integration/clipPath-html-01.xhtml	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,17 @@
+<!--
+     Any copyright is dedicated to the Public Domain.
+     http://creativecommons.org/licenses/publicdomain/
+-->
+<html xmlns="http://www.w3.org/1999/xhtml"
+     xmlns:svg="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink">
+<body style="margin:0">
+  <div style="position:absolute; top:0; left:0; clip-path: url(#c1); width:500px; height:500px; background:lime;"></div>
+
+  <svg:svg height="0">
+    <svg:clipPath id="c1" clipPathUnits="objectBoundingBox">
+      <svg:rect x="0.5" y="0" width="0.5" height="1"/>
+    </svg:clipPath>
+  </svg:svg>
+</body>
+</html>
diff -r b7bcdd009540 layout/reftests/svg-integration/clipPath-html-02-ref.svg
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/svg-integration/clipPath-html-02-ref.svg	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,9 @@
+<!--
+     Any copyright is dedicated to the Public Domain.
+     http://creativecommons.org/licenses/publicdomain/
+-->
+<svg xmlns="http://www.w3.org/2000/svg" version="1.1"
+     xmlns:xlink="http://www.w3.org/1999/xlink">
+  <rect x="0" y="0" width="500" height="200" fill="lime"/>
+  <rect x="0" y="200" width="500" height="120" fill="blue"/>
+</svg>
diff -r b7bcdd009540 layout/reftests/svg-integration/clipPath-html-02.xhtml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/svg-integration/clipPath-html-02.xhtml	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,20 @@
+<!--
+     Any copyright is dedicated to the Public Domain.
+     http://creativecommons.org/licenses/publicdomain/
+-->
+<html xmlns="http://www.w3.org/1999/xhtml"
+     xmlns:svg="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink">
+<body style="margin:0">
+  <div style="clip-path: url(#c1); width:500px; height:200px; background:lime;">
+    <div style="height:200px;"/>
+    <div style="height:200px; background:blue;"/>
+  </div>
+
+  <svg:svg height="0">
+    <svg:clipPath id="c1" clipPathUnits="objectBoundingBox">
+      <svg:rect x="0" y="0" width="1" height="0.8"/>
+    </svg:clipPath>
+  </svg:svg>
+</body>
+</html>
diff -r b7bcdd009540 layout/reftests/svg-integration/clipPath-html-03-ref.svg
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/svg-integration/clipPath-html-03-ref.svg	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,10 @@
+<!--
+     Any copyright is dedicated to the Public Domain.
+     http://creativecommons.org/licenses/publicdomain/
+-->
+<svg xmlns="http://www.w3.org/2000/svg" version="1.1"
+     xmlns:xlink="http://www.w3.org/1999/xlink">
+  <rect x="0" y="0" width="100" height="150" fill="lime"/>
+  <rect x="100" y="0" width="100" height="200" fill="lime"/>
+  <rect x="100" y="200" width="100" height="100" fill="blue"/>
+</svg>
diff -r b7bcdd009540 layout/reftests/svg-integration/clipPath-html-03.xhtml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/svg-integration/clipPath-html-03.xhtml	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,21 @@
+<!--
+     Any copyright is dedicated to the Public Domain.
+     http://creativecommons.org/licenses/publicdomain/
+-->
+<html xmlns="http://www.w3.org/1999/xhtml"
+     xmlns:svg="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink">
+<body style="margin:0">
+  <div style="clip-path: url(#c1); width:500px; height:200px; background:lime;">
+    <div style="height:200px;"/>
+    <div style="height:200px; background:blue;"/>
+  </div>
+
+  <svg:svg height="0">
+    <svg:clipPath id="c1" clipPathUnits="userSpaceOnuse">
+      <svg:rect x="0" y="0" width="100" height="150"/>
+      <svg:rect x="100" y="0" width="100" height="300"/>
+    </svg:clipPath>
+  </svg:svg>
+</body>
+</html>
diff -r b7bcdd009540 layout/reftests/svg-integration/clipPath-html-04-ref.xhtml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/svg-integration/clipPath-html-04-ref.xhtml	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,14 @@
+<!--
+     Any copyright is dedicated to the Public Domain.
+     http://creativecommons.org/licenses/publicdomain/
+-->
+<html xmlns="http://www.w3.org/1999/xhtml"
+     xmlns:svg="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink">
+<body style="margin:0; line-height:100px;">
+  <span style="display:inline-block; width:200px;"
+  /><span style="background:lime;"><span style="display:inline-block; width:50px;"/></span><br/>
+  <span style="display:inline-block; width:50px;"
+  /><span style="background:lime;"><span style="display:inline-block; width:50px;"/></span>
+</body>
+</html>
diff -r b7bcdd009540 layout/reftests/svg-integration/clipPath-html-04.xhtml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/svg-integration/clipPath-html-04.xhtml	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,24 @@
+<!--
+     Any copyright is dedicated to the Public Domain.
+     http://creativecommons.org/licenses/publicdomain/
+-->
+<html xmlns="http://www.w3.org/1999/xhtml"
+     xmlns:svg="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink">
+<head>
+<style>
+.unit { display:inline-block; width:100px; height:1px; }
+</style>
+</head>
+<body style="margin:0; width:350px; line-height:100px;">
+  <span class="unit"/><span class="unit"
+  /><span style="clip-path:url(#c1); background:lime;"><span class="unit"/><span class="unit"
+  /></span>
+
+  <svg:svg height="0">
+    <svg:clipPath id="c1" clipPathUnits="userSpaceOnuse">
+      <svg:rect x="50" y="0" width="200" height="200"/>
+    </svg:clipPath>
+  </svg:svg>
+</body>
+</html>
diff -r b7bcdd009540 layout/reftests/svg-integration/clipPath-html-05-ref.xhtml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/svg-integration/clipPath-html-05-ref.xhtml	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,14 @@
+<!--
+     Any copyright is dedicated to the Public Domain.
+     http://creativecommons.org/licenses/publicdomain/
+-->
+<html xmlns="http://www.w3.org/1999/xhtml"
+     xmlns:svg="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink">
+<body style="margin:0; line-height:100px;">
+  <span style="display:inline-block; width:200px;"
+  /><span style="background:lime;"><span style="display:inline-block; width:70px;"/></span><br/>
+  <span style="display:inline-block; width:30px;"
+  /><span style="background:lime;"><span style="display:inline-block; width:70px;"/></span>
+</body>
+</html>
diff -r b7bcdd009540 layout/reftests/svg-integration/clipPath-html-05.xhtml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/svg-integration/clipPath-html-05.xhtml	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,24 @@
+<!--
+     Any copyright is dedicated to the Public Domain.
+     http://creativecommons.org/licenses/publicdomain/
+-->
+<html xmlns="http://www.w3.org/1999/xhtml"
+     xmlns:svg="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink">
+<head>
+<style>
+.unit { display:inline-block; width:100px; height:1px; }
+</style>
+</head>
+<body style="margin:0; width:350px; line-height:100px;">
+  <span class="unit"/><span class="unit"
+  /><span style="clip-path:url(#c1); background:lime;"><span class="unit"/><span class="unit"
+  /></span>
+
+  <svg:svg height="0">
+    <svg:clipPath id="c1" clipPathUnits="objectBoundingBox">
+      <svg:rect x="0.1" y="0" width="0.8" height="1"/>
+    </svg:clipPath>
+  </svg:svg>
+</body>
+</html>
diff -r b7bcdd009540 layout/reftests/svg-integration/clipPath-html-06-ref.xhtml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/svg-integration/clipPath-html-06-ref.xhtml	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,20 @@
+<!--
+     Any copyright is dedicated to the Public Domain.
+     http://creativecommons.org/licenses/publicdomain/
+-->
+<html xmlns="http://www.w3.org/1999/xhtml"
+     xmlns:svg="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink">
+<head>
+<style>
+.unit { display:inline-block; width:50px; height:10px; }
+</style>
+</head>
+<body style="margin:0">
+  <span>
+    <span class="unit"></span>
+    <div style="height:200px;"/>
+    <span class="unit" style="background:lime;"></span>
+  </span>
+</body>
+</html>
diff -r b7bcdd009540 layout/reftests/svg-integration/clipPath-html-06.xhtml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/svg-integration/clipPath-html-06.xhtml	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,26 @@
+<!--
+     Any copyright is dedicated to the Public Domain.
+     http://creativecommons.org/licenses/publicdomain/
+-->
+<html xmlns="http://www.w3.org/1999/xhtml"
+     xmlns:svg="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink">
+<head>
+<style>
+.unit { display:inline-block; width:100px; height:10px; }
+</style>
+</head>
+<body style="margin:0">
+  <span style="clip-path: url(#c1);">
+    <span class="unit" style="background:lime;"></span>
+    <div style="height:200px; width:100px;"/>
+    <span class="unit" style="background:lime;"></span>
+  </span>
+
+  <svg:svg height="0">
+    <svg:clipPath id="c1" clipPathUnits="objectBoundingBox">
+      <svg:rect x="0" y="0.5" width="0.5" height="0.5"/>
+    </svg:clipPath>
+  </svg:svg>
+</body>
+</html>
diff -r b7bcdd009540 layout/reftests/svg-integration/filter-html-01-ref.svg
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/svg-integration/filter-html-01-ref.svg	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,14 @@
+<!--
+     Any copyright is dedicated to the Public Domain.
+     http://creativecommons.org/licenses/publicdomain/
+-->
+<svg xmlns="http://www.w3.org/2000/svg" version="1.1"
+     xmlns:xlink="http://www.w3.org/1999/xlink">
+  <filter id="f1">
+    <feFlood flood-color="black" result="black"/>
+    <feGaussianBlur in="SourceAlpha" stdDeviation="10"/>
+    <feComposite in="black" operator="in"/>
+    <feComposite in="SourceGraphic"/>
+  </filter>
+  <rect x="50" y="50" width="200" height="200" fill="lime" filter="url(#f1)"/>
+</svg>
diff -r b7bcdd009540 layout/reftests/svg-integration/filter-html-01.xhtml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/svg-integration/filter-html-01.xhtml	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,20 @@
+<!--
+     Any copyright is dedicated to the Public Domain.
+     http://creativecommons.org/licenses/publicdomain/
+-->
+<html xmlns="http://www.w3.org/1999/xhtml"
+     xmlns:svg="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink">
+<body style="margin:0">
+  <div style="background:lime; width:200px; height:200px; margin:50px; filter:url(#f1)"/>
+
+  <svg:svg height="0">
+    <svg:filter id="f1">
+      <svg:feFlood flood-color="black" result="black"/>
+      <svg:feGaussianBlur in="SourceAlpha" stdDeviation="10"/>
+      <svg:feComposite in="black" operator="in"/>
+      <svg:feComposite in="SourceGraphic"/>
+    </svg:filter>
+  </svg:svg>
+</body>
+</html>
diff -r b7bcdd009540 layout/reftests/svg-integration/mask-html-01-ref.svg
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/svg-integration/mask-html-01-ref.svg	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,13 @@
+<!--
+     Any copyright is dedicated to the Public Domain.
+     http://creativecommons.org/licenses/publicdomain/
+-->
+<svg xmlns="http://www.w3.org/2000/svg" version="1.1"
+     xmlns:xlink="http://www.w3.org/1999/xlink">
+  <linearGradient id="g" gradientUnits="objectBoundingBox" x2="0" y2="1">
+    <stop stop-color="lime" offset="0"/>
+    <stop stop-color="lime" stop-opacity="0" offset="1"/>
+  </linearGradient>
+  <circle cx="125" cy="125" r="125" id="circle" fill="lime"/>
+  <rect x="250" y="0" width="250" height="500" fill="url(#g)"/>
+</svg>
diff -r b7bcdd009540 layout/reftests/svg-integration/mask-html-01.xhtml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/svg-integration/mask-html-01.xhtml	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,22 @@
+<!--
+     Any copyright is dedicated to the Public Domain.
+     http://creativecommons.org/licenses/publicdomain/
+-->
+<html xmlns="http://www.w3.org/1999/xhtml"
+     xmlns:svg="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink">
+<body style="margin:0">
+  <div style="mask: url(#m1); width:500px; height:500px; background:lime;"></div>
+
+  <svg:svg height="0">
+    <svg:mask id="m1" maskUnits="objectBoundingBox" maskContentUnits="objectBoundingBox">
+      <svg:linearGradient id="g" gradientUnits="objectBoundingBox" x2="0" y2="1">
+        <svg:stop stop-color="white" offset="0"/>
+        <svg:stop stop-color="white" stop-opacity="0" offset="1"/>
+      </svg:linearGradient>
+      <svg:circle cx="0.25" cy="0.25" r="0.25" id="circle" fill="white"/>
+      <svg:rect x="0.5" y="0" width="0.5" height="1" fill="url(#g)"/>
+    </svg:mask>
+  </svg:svg>
+</body>
+</html>
diff -r b7bcdd009540 layout/reftests/svg-integration/reftest.list
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/svg-integration/reftest.list	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,9 @@
+== clipPath-html-01.xhtml clipPath-html-01-ref.svg
+== clipPath-html-02.xhtml clipPath-html-02-ref.svg
+== clipPath-html-03.xhtml clipPath-html-03-ref.svg
+== clipPath-html-04.xhtml clipPath-html-04-ref.xhtml
+== clipPath-html-05.xhtml clipPath-html-05-ref.xhtml
+== clipPath-html-06.xhtml clipPath-html-06-ref.xhtml
+== filter-html-01.xhtml filter-html-01-ref.svg
+== mask-html-01.xhtml mask-html-01-ref.svg
+
diff -r b7bcdd009540 layout/style/Makefile.in
--- a/layout/style/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/style/Makefile.in	Thu Sep 11 15:19:26 2008 +0300
@@ -38,17 +38,17 @@ topsrcdir	= @top_srcdir@
 topsrcdir	= @top_srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 DIRS = xbl-marquee
 
-ifdef MOZ_MOCHITEST
+ifdef ENABLE_TESTS
 DIRS		+= test
 endif
 
 MODULE		= layout
 LIBRARY_NAME	= gkstyle_s
 LIBXUL_LIBRARY	= 1
 
 REQUIRES	= xpcom \
diff -r b7bcdd009540 layout/style/nsCSSDataBlock.cpp
--- a/layout/style/nsCSSDataBlock.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/style/nsCSSDataBlock.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -682,19 +682,17 @@ nsCSSExpandedDataBlock::ComputeSize()
             continue;
         for (PRInt32 iLow = 0; iLow < kPropertiesSetChunkSize; ++iLow) {
             if ((mPropertiesSet[iHigh] & (1 << iLow)) == 0)
                 continue;
             nsCSSProperty iProp =
                 nsCSSProperty(iHigh * kPropertiesSetChunkSize + iLow);
             NS_ASSERTION(0 <= iProp && iProp < eCSSProperty_COUNT_no_shorthands,
                          "out of range");
-#ifdef DEBUG
             void *prop = PropertyAt(iProp);
-#endif
             PRUint32 increment = 0;
             switch (nsCSSProps::kTypeTable[iProp]) {
                 case eCSSType_Value: {
 #ifdef DEBUG
                     nsCSSValue* val = static_cast<nsCSSValue*>(prop);
                     NS_ASSERTION(val->GetUnit() != eCSSUnit_Null,
                                  "null value while computing size");
 #endif
diff -r b7bcdd009540 layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/style/nsCSSParser.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -37,17 +37,17 @@
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 /* parsing of CSS stylesheets, based on a token stream from the CSS scanner */
- 
+
 #include "nsICSSParser.h"
 #include "nsCSSProps.h"
 #include "nsCSSKeywords.h"
 #include "nsCSSScanner.h"
 #include "nsICSSLoader.h"
 #include "nsICSSStyleRule.h"
 #include "nsICSSImportRule.h"
 #include "nsCSSRules.h"
@@ -91,17 +91,17 @@
 #define VARIANT_COLOR           0x000008  // C eCSSUnit_Color, eCSSUnit_String (e.g.  "red")
 #define VARIANT_URL             0x000010  // U
 #define VARIANT_NUMBER          0x000020  // N
 #define VARIANT_INTEGER         0x000040  // I
 #define VARIANT_ANGLE           0x000080  // G
 #define VARIANT_FREQUENCY       0x000100  // F
 #define VARIANT_TIME            0x000200  // T
 #define VARIANT_STRING          0x000400  // S
-#define VARIANT_COUNTER         0x000800  // 
+#define VARIANT_COUNTER         0x000800  //
 #define VARIANT_ATTR            0x001000  //
 #define VARIANT_IDENTIFIER      0x002000  // D
 #define VARIANT_AUTO            0x010000  // A
 #define VARIANT_INHERIT         0x020000  // H eCSSUnit_Initial, eCSSUnit_Inherit
 #define VARIANT_NONE            0x040000  // O
 #define VARIANT_NORMAL          0x080000  // M
 #define VARIANT_SYSFONT         0x100000  // eCSSUnit_System_Font
 
@@ -169,17 +169,17 @@ public:
                    PRUint32               aLineNumber,
                    PRBool                 aAllowUnsafeRules);
 
   NS_IMETHOD ParseStyleAttribute(const nsAString&  aAttributeValue,
                                  nsIURI*           aDocURL,
                                  nsIURI*           aBaseURL,
                                  nsIPrincipal*     aNodePrincipal,
                                  nsICSSStyleRule** aResult);
-  
+
   NS_IMETHOD ParseAndAppendDeclaration(const nsAString&  aBuffer,
                                        nsIURI*           aSheetURL,
                                        nsIURI*           aBaseURL,
                                        nsIPrincipal*     aSheetPrincipal,
                                        nsCSSDeclaration* aDeclaration,
                                        PRBool            aParseOnlyOneDecl,
                                        PRBool*           aChanged,
                                        PRBool            aClearOldDecl);
@@ -237,138 +237,128 @@ protected:
       ~nsAutoParseCompoundProperty()
       {
         mParser->SetParsingCompoundProperty(PR_FALSE);
       }
     private:
       CSSParserImpl* mParser;
   };
 
-  nsresult InitScanner(nsIUnicharInputStream* aInput, nsIURI* aSheetURI,
-                       PRUint32 aLineNumber, nsIURI* aBaseURI,
-                       nsIPrincipal* aSheetPrincipal);
+  void InitScanner(nsIUnicharInputStream* aInput, nsIURI* aSheetURI,
+                   PRUint32 aLineNumber, nsIURI* aBaseURI,
+                   nsIPrincipal* aSheetPrincipal);
   // the caller must hold on to aBuffer until parsing is done
-  nsresult InitScanner(const nsSubstring& aString, nsIURI* aSheetURI,
-                       PRUint32 aLineNumber, nsIURI* aBaseURI,
-                       nsIPrincipal* aSheetPrincipal);
-  nsresult ReleaseScanner(void);
+  void InitScanner(const nsSubstring& aString, nsIURI* aSheetURI,
+                   PRUint32 aLineNumber, nsIURI* aBaseURI,
+                   nsIPrincipal* aSheetPrincipal);
+  void ReleaseScanner(void);
 #ifdef MOZ_SVG
   PRBool IsSVGMode() const {
     return mScanner.IsSVGMode();
   }
 #endif
 
-  PRBool GetToken(nsresult& aErrorCode, PRBool aSkipWS);
-  PRBool GetURLToken(nsresult& aErrorCode);
+  PRBool GetToken(PRBool aSkipWS);
+  PRBool GetURLToken();
   void UngetToken();
 
   void AssertInitialState() {
     NS_PRECONDITION(!mHTMLMediaMode, "Bad initial state");
     NS_PRECONDITION(!mUnresolvablePrefixException, "Bad initial state");
     NS_PRECONDITION(!mParsingCompoundProperty, "Bad initial state");
   }
 
-  PRBool ExpectSymbol(nsresult& aErrorCode, PRUnichar aSymbol, PRBool aSkipWS);
-  PRBool ExpectEndProperty(nsresult& aErrorCode);
-  nsSubstring* NextIdent(nsresult& aErrorCode);
-  void SkipUntil(nsresult& aErrorCode, PRUnichar aStopSymbol);
-  void SkipRuleSet(nsresult& aErrorCode);
-  PRBool SkipAtRule(nsresult& aErrorCode);
-  PRBool SkipDeclaration(nsresult& aErrorCode, PRBool aCheckForBraces);
-  PRBool GetNonCloseParenToken(nsresult& aErrorCode, PRBool aSkipWS);
+  PRBool ExpectSymbol(PRUnichar aSymbol, PRBool aSkipWS);
+  PRBool ExpectEndProperty();
+  nsSubstring* NextIdent();
+  void SkipUntil(PRUnichar aStopSymbol);
+  void SkipRuleSet();
+  PRBool SkipAtRule();
+  PRBool SkipDeclaration(PRBool aCheckForBraces);
+  PRBool GetNonCloseParenToken(PRBool aSkipWS);
 
   PRBool PushGroup(nsICSSGroupRule* aRule);
   void PopGroup(void);
 
-  PRBool ParseRuleSet(nsresult& aErrorCode, RuleAppendFunc aAppendFunc, void* aProcessData);
-  PRBool ParseAtRule(nsresult& aErrorCode, RuleAppendFunc aAppendFunc, void* aProcessData);
-  PRBool ParseCharsetRule(nsresult& aErrorCode, RuleAppendFunc aAppendFunc, void* aProcessData);
-  PRBool ParseImportRule(nsresult& aErrorCode, RuleAppendFunc aAppendFunc, void* aProcessData);
-  PRBool GatherURL(nsresult& aErrorCode, nsString& aURL);
+  PRBool ParseRuleSet(RuleAppendFunc aAppendFunc, void* aProcessData);
+  PRBool ParseAtRule(RuleAppendFunc aAppendFunc, void* aProcessData);
+  PRBool ParseCharsetRule(RuleAppendFunc aAppendFunc, void* aProcessData);
+  PRBool ParseImportRule(RuleAppendFunc aAppendFunc, void* aProcessData);
+  PRBool GatherURL(nsString& aURL);
   // Callers must clear or throw out aMedia if GatherMedia returns false.
-  PRBool GatherMedia(nsresult& aErrorCode, nsMediaList* aMedia,
+  PRBool GatherMedia(nsMediaList* aMedia,
                      PRUnichar aStopSymbol);
-  PRBool ParseMediaQueryExpression(nsresult& aErrorCode, nsMediaQuery* aQuery);
-  PRBool ProcessImport(nsresult& aErrorCode,
-                       const nsString& aURLSpec,
+  PRBool ParseMediaQueryExpression(nsMediaQuery* aQuery);
+  PRBool ProcessImport(const nsString& aURLSpec,
                        nsMediaList* aMedia,
                        RuleAppendFunc aAppendFunc,
                        void* aProcessData);
-  PRBool ParseGroupRule(nsresult& aErrorCode, nsICSSGroupRule* aRule, RuleAppendFunc aAppendFunc, void* aProcessData);
-  PRBool ParseMediaRule(nsresult& aErrorCode, RuleAppendFunc aAppendFunc, void* aProcessData);
-  PRBool ParseMozDocumentRule(nsresult& aErrorCode, RuleAppendFunc aAppendFunc, void* aProcessData);
-  PRBool ParseNameSpaceRule(nsresult& aErrorCode, RuleAppendFunc aAppendFunc, void* aProcessData);
-  PRBool ProcessNameSpace(nsresult& aErrorCode, const nsString& aPrefix, 
+  PRBool ParseGroupRule(nsICSSGroupRule* aRule, RuleAppendFunc aAppendFunc,
+                        void* aProcessData);
+  PRBool ParseMediaRule(RuleAppendFunc aAppendFunc, void* aProcessData);
+  PRBool ParseMozDocumentRule(RuleAppendFunc aAppendFunc, void* aProcessData);
+  PRBool ParseNameSpaceRule(RuleAppendFunc aAppendFunc, void* aProcessData);
+  PRBool ProcessNameSpace(const nsString& aPrefix,
                           const nsString& aURLSpec, RuleAppendFunc aAppendFunc,
                           void* aProcessData);
 
-  PRBool ParseFontFaceRule(nsresult& aErrorCode, RuleAppendFunc aAppendFunc, void* aProcessData);
-  PRBool ParseFontDescriptor(nsresult& aErrorCode, nsCSSFontFaceRule* aRule);
-  PRBool ParseFontDescriptorValue(nsresult& aErrorCode, nsCSSFontDesc aDescID,
+  PRBool ParseFontFaceRule(RuleAppendFunc aAppendFunc, void* aProcessData);
+  PRBool ParseFontDescriptor(nsCSSFontFaceRule* aRule);
+  PRBool ParseFontDescriptorValue(nsCSSFontDesc aDescID,
                                   nsCSSValue& aValue);
 
-  PRBool ParsePageRule(nsresult& aErrorCode, RuleAppendFunc aAppendFunc, void* aProcessData);
+  PRBool ParsePageRule(RuleAppendFunc aAppendFunc, void* aProcessData);
 
   enum nsSelectorParsingStatus {
-    // we have parsed a selector and we saw a token that cannot be part of a selector:
+    // we have parsed a selector and we saw a token that cannot be
+    // part of a selector:
     eSelectorParsingStatus_Done,
     // we should continue parsing the selector:
     eSelectorParsingStatus_Continue,
     // same as "Done" but we did not find a selector:
     eSelectorParsingStatus_Empty,
     // we saw an unexpected token or token value,
     // or we saw end-of-file with an unfinished selector:
-    eSelectorParsingStatus_Error 
+    eSelectorParsingStatus_Error
   };
   nsSelectorParsingStatus ParseIDSelector(PRInt32&       aDataMask,
-                                          nsCSSSelector& aSelector,
-                                          nsresult&      aErrorCode);
+                                          nsCSSSelector& aSelector);
 
   nsSelectorParsingStatus ParseClassSelector(PRInt32&       aDataMask,
-                                             nsCSSSelector& aSelector,
-                                             nsresult&      aErrorCode);
+                                             nsCSSSelector& aSelector);
 
   nsSelectorParsingStatus ParsePseudoSelector(PRInt32&       aDataMask,
                                               nsCSSSelector& aSelector,
-                                              nsresult&      aErrorCode,
                                               PRBool         aIsNegated);
 
   nsSelectorParsingStatus ParseAttributeSelector(PRInt32&       aDataMask,
-                                                 nsCSSSelector& aSelector,
-                                                 nsresult&      aErrorCode);
+                                                 nsCSSSelector& aSelector);
 
   nsSelectorParsingStatus ParseTypeOrUniversalSelector(PRInt32&       aDataMask,
                                                        nsCSSSelector& aSelector,
-                                                       nsresult&      aErrorCode,
                                                        PRBool         aIsNegated);
 
   nsSelectorParsingStatus ParsePseudoClassWithIdentArg(nsCSSSelector& aSelector,
-                                                       nsIAtom*       aPseudo,
-                                                       nsresult&      aErrorCode);
+                                                       nsIAtom*       aPseudo);
 
   nsSelectorParsingStatus ParsePseudoClassWithNthPairArg(nsCSSSelector& aSelector,
-                                                         nsIAtom*       aPseudo,
-                                                         nsresult&      aErrorCode);
+                                                         nsIAtom*       aPseudo);
 
   nsSelectorParsingStatus ParseNegatedSimpleSelector(PRInt32&       aDataMask,
-                                                     nsCSSSelector& aSelector,
-                                                     nsresult&      aErrorCode);
-
-  nsSelectorParsingStatus ParseSelector(nsresult&      aErrorCode,
-                                        nsCSSSelector& aSelectorResult);
+                                                     nsCSSSelector& aSelector);
+
+  nsSelectorParsingStatus ParseSelector(nsCSSSelector& aSelectorResult);
 
   // If aTerminateAtBrace is true, the selector list is done when we
   // hit a '{'.  Otherwise, it's done when we hit EOF.
-  PRBool ParseSelectorList(nsresult& aErrorCode, nsCSSSelectorList*& aListHead,
+  PRBool ParseSelectorList(nsCSSSelectorList*& aListHead,
                            PRBool aTerminateAtBrace);
-  PRBool ParseSelectorGroup(nsresult& aErrorCode, nsCSSSelectorList*& aListHead);
-  nsCSSDeclaration* ParseDeclarationBlock(nsresult& aErrorCode,
-                                           PRBool aCheckForBraces);
-  PRBool ParseDeclaration(nsresult& aErrorCode,
-                          nsCSSDeclaration* aDeclaration,
+  PRBool ParseSelectorGroup(nsCSSSelectorList*& aListHead);
+  nsCSSDeclaration* ParseDeclarationBlock(PRBool aCheckForBraces);
+  PRBool ParseDeclaration(nsCSSDeclaration* aDeclaration,
                           PRBool aCheckForBraces,
                           PRBool aMustCallValueAppended,
                           PRBool* aChanged);
   // After a parse error parsing |aPropID|, clear the data in
   // |mTempData|.
   void ClearTempData(nsCSSProperty aPropID);
   // After a successful parse of |aPropID|, transfer data from
   // |mTempData| to |mData|.  Set |*aChanged| to true if something
@@ -378,137 +368,132 @@ protected:
   void TransferTempData(nsCSSDeclaration* aDeclaration,
                         nsCSSProperty aPropID, PRBool aIsImportant,
                         PRBool aMustCallValueAppended,
                         PRBool* aChanged);
   void DoTransferTempData(nsCSSDeclaration* aDeclaration,
                           nsCSSProperty aPropID, PRBool aIsImportant,
                           PRBool aMustCallValueAppended,
                           PRBool* aChanged);
-  PRBool ParseProperty(nsresult& aErrorCode, nsCSSProperty aPropID);
-  PRBool ParseSingleValueProperty(nsresult& aErrorCode, nsCSSValue& aValue, 
+  PRBool ParseProperty(nsCSSProperty aPropID);
+  PRBool ParseSingleValueProperty(nsCSSValue& aValue,
                                   nsCSSProperty aPropID);
 
 #ifdef MOZ_XUL
-  PRBool ParseTreePseudoElement(nsresult& aErrorCode, nsCSSSelector& aSelector);
+  PRBool ParseTreePseudoElement(nsCSSSelector& aSelector);
 #endif
 
   void InitBoxPropsAsPhysical(const nsCSSProperty *aSourceProperties);
 
   // Property specific parsing routines
-  PRBool ParseAzimuth(nsresult& aErrorCode, nsCSSValue& aValue);
-  PRBool ParseBackground(nsresult& aErrorCode);
-  PRBool ParseBackgroundPosition(nsresult& aErrorCode);
-  PRBool ParseBackgroundPositionValues(nsresult& aErrorCode);
-  PRBool ParseBorderColor(nsresult& aErrorCode);
-  PRBool ParseBorderColors(nsresult& aErrorCode,
-                           nsCSSValueList** aResult,
+  PRBool ParseAzimuth(nsCSSValue& aValue);
+  PRBool ParseBackground();
+  PRBool ParseBackgroundPosition();
+  PRBool ParseBackgroundPositionValues();
+  PRBool ParseBorderColor();
+  PRBool ParseBorderColors(nsCSSValueList** aResult,
                            nsCSSProperty aProperty);
-  PRBool ParseBorderImage(nsresult& aErrorCode);
-  PRBool ParseBorderSpacing(nsresult& aErrorCode);
-  PRBool ParseBorderSide(nsresult& aErrorCode,
-                         const nsCSSProperty aPropIDs[],
+  PRBool ParseBorderImage();
+  PRBool ParseBorderSpacing();
+  PRBool ParseBorderSide(const nsCSSProperty aPropIDs[],
                          PRBool aSetAllSides);
-  PRBool ParseDirectionalBorderSide(nsresult& aErrorCode,
-                                    const nsCSSProperty aPropIDs[],
+  PRBool ParseDirectionalBorderSide(const nsCSSProperty aPropIDs[],
                                     PRInt32 aSourceType);
-  PRBool ParseBorderStyle(nsresult& aErrorCode);
-  PRBool ParseBorderWidth(nsresult& aErrorCode);
-  PRBool ParseBorderRadius(nsresult& aErrorCode);
-  PRBool ParseOutlineRadius(nsresult& aErrorCode);
+  PRBool ParseBorderStyle();
+  PRBool ParseBorderWidth();
+  PRBool ParseBorderRadius();
+  PRBool ParseOutlineRadius();
   // for 'clip' and '-moz-image-region'
-  PRBool ParseRect(nsCSSRect& aRect, nsresult& aErrorCode,
+  PRBool ParseRect(nsCSSRect& aRect,
                    nsCSSProperty aPropID);
-  PRBool DoParseRect(nsCSSRect& aRect, nsresult& aErrorCode);
-  PRBool ParseContent(nsresult& aErrorCode);
-  PRBool ParseCounterData(nsresult& aErrorCode,
-                          nsCSSValuePairList** aResult,
+  PRBool DoParseRect(nsCSSRect& aRect);
+  PRBool ParseContent();
+  PRBool ParseCounterData(nsCSSValuePairList** aResult,
                           nsCSSProperty aPropID);
-  PRBool ParseCue(nsresult& aErrorCode);
-  PRBool ParseCursor(nsresult& aErrorCode);
-  PRBool ParseFont(nsresult& aErrorCode);
-  PRBool ParseFontWeight(nsresult& aErrorCode, nsCSSValue& aValue);
-  PRBool ParseOneFamily(nsresult& aErrorCode, nsAString& aValue);
-  PRBool ParseFamily(nsresult& aErrorCode, nsCSSValue& aValue);
-  PRBool ParseFontSrc(nsresult& aErrorCode, nsCSSValue& aValue);
-  PRBool ParseFontSrcFormat(nsresult& aErrorCode, nsTArray<nsCSSValue>& values);
-  PRBool ParseFontRanges(nsresult& aErrorCode, nsCSSValue& aValue);
-  PRBool ParseListStyle(nsresult& aErrorCode);
-  PRBool ParseMargin(nsresult& aErrorCode);
-  PRBool ParseMarks(nsresult& aErrorCode, nsCSSValue& aValue);
-  PRBool ParseOutline(nsresult& aErrorCode);
-  PRBool ParseOverflow(nsresult& aErrorCode);
-  PRBool ParsePadding(nsresult& aErrorCode);
-  PRBool ParsePause(nsresult& aErrorCode);
-  PRBool ParseQuotes(nsresult& aErrorCode);
-  PRBool ParseSize(nsresult& aErrorCode);
-  PRBool ParseTextDecoration(nsresult& aErrorCode, nsCSSValue& aValue);
-
-  nsCSSValueList* ParseCSSShadowList(nsresult& aErrorCode,
-                                     PRBool aUsesSpread);
-  PRBool ParseTextShadow(nsresult& aErrorCode);
-  PRBool ParseBoxShadow(nsresult& aErrorCode);
+  PRBool ParseCue();
+  PRBool ParseCursor();
+  PRBool ParseFont();
+  PRBool ParseFontWeight(nsCSSValue& aValue);
+  PRBool ParseOneFamily(nsAString& aValue);
+  PRBool ParseFamily(nsCSSValue& aValue);
+  PRBool ParseFontSrc(nsCSSValue& aValue);
+  PRBool ParseFontSrcFormat(nsTArray<nsCSSValue>& values);
+  PRBool ParseFontRanges(nsCSSValue& aValue);
+  PRBool ParseListStyle();
+  PRBool ParseMargin();
+  PRBool ParseMarks(nsCSSValue& aValue);
+  PRBool ParseOutline();
+  PRBool ParseOverflow();
+  PRBool ParsePadding();
+  PRBool ParsePause();
+  PRBool ParseQuotes();
+  PRBool ParseSize();
+  PRBool ParseTextDecoration(nsCSSValue& aValue);
+
+  nsCSSValueList* ParseCSSShadowList(PRBool aUsesSpread);
+  PRBool ParseTextShadow();
+  PRBool ParseBoxShadow();
 
 #ifdef MOZ_SVG
-  PRBool ParsePaint(nsresult& aErrorCode,
-                    nsCSSValuePair* aResult,
+  PRBool ParsePaint(nsCSSValuePair* aResult,
                     nsCSSProperty aPropID);
-  PRBool ParseDasharray(nsresult& aErrorCode);
-  PRBool ParseMarker(nsresult& aErrorCode);
+  PRBool ParseDasharray();
+  PRBool ParseMarker();
 #endif
 
   // Reused utility parsing routines
   void AppendValue(nsCSSProperty aPropID, const nsCSSValue& aValue);
-  PRBool ParseBoxProperties(nsresult& aErrorCode, nsCSSRect& aResult,
+  PRBool ParseBoxProperties(nsCSSRect& aResult,
                             const nsCSSProperty aPropIDs[]);
-  PRBool ParseDirectionalBoxProperty(nsresult& aErrorCode,
-                                     nsCSSProperty aProperty,
+  PRBool ParseDirectionalBoxProperty(nsCSSProperty aProperty,
                                      PRInt32 aSourceType);
-  PRInt32 ParseChoice(nsresult& aErrorCode, nsCSSValue aValues[],
+  PRInt32 ParseChoice(nsCSSValue aValues[],
                       const nsCSSProperty aPropIDs[], PRInt32 aNumIDs);
-  PRBool ParseColor(nsresult& aErrorCode, nsCSSValue& aValue);
-  PRBool ParseColorComponent(nsresult& aErrorCode, PRUint8& aComponent,
+  PRBool ParseColor(nsCSSValue& aValue);
+  PRBool ParseColorComponent(PRUint8& aComponent,
                              PRInt32& aType, char aStop);
-  // ParseHSLColor parses everything starting with the opening '(' up through
-  // and including the aStop char.
-  PRBool ParseHSLColor(nsresult& aErrorCode, nscolor& aColor, char aStop);
-  // ParseColorOpacity will enforce that the color ends with a ')' after the opacity
-  PRBool ParseColorOpacity(nsresult& aErrorCode, PRUint8& aOpacity);
-  PRBool ParseEnum(nsresult& aErrorCode, nsCSSValue& aValue, const PRInt32 aKeywordTable[]);
-  PRBool ParseVariant(nsresult& aErrorCode, nsCSSValue& aValue,
+  // ParseHSLColor parses everything starting with the opening '('
+  // up through and including the aStop char.
+  PRBool ParseHSLColor(nscolor& aColor, char aStop);
+  // ParseColorOpacity will enforce that the color ends with a ')'
+  // after the opacity
+  PRBool ParseColorOpacity(PRUint8& aOpacity);
+  PRBool ParseEnum(nsCSSValue& aValue, const PRInt32 aKeywordTable[]);
+  PRBool ParseVariant(nsCSSValue& aValue,
                       PRInt32 aVariantMask,
                       const PRInt32 aKeywordTable[]);
-  PRBool ParsePositiveVariant(nsresult& aErrorCode, nsCSSValue& aValue, 
-                              PRInt32 aVariantMask, 
-                              const PRInt32 aKeywordTable[]); 
-  PRBool ParseCounter(nsresult& aErrorCode, nsCSSValue& aValue);
-  PRBool ParseAttr(nsresult& aErrorCode, nsCSSValue& aValue);
-  PRBool ParseURL(nsresult& aErrorCode, nsCSSValue& aValue);
-  PRBool TranslateDimension(nsresult& aErrorCode, nsCSSValue& aValue, PRInt32 aVariantMask,
+  PRBool ParsePositiveVariant(nsCSSValue& aValue,
+                              PRInt32 aVariantMask,
+                              const PRInt32 aKeywordTable[]);
+  PRBool ParseCounter(nsCSSValue& aValue);
+  PRBool ParseAttr(nsCSSValue& aValue);
+  PRBool ParseURL(nsCSSValue& aValue);
+  PRBool TranslateDimension(nsCSSValue& aValue, PRInt32 aVariantMask,
                             float aNumber, const nsString& aUnit);
 
   void SetParsingCompoundProperty(PRBool aBool) {
     NS_ASSERTION(aBool == PR_TRUE || aBool == PR_FALSE, "bad PRBool value");
     mParsingCompoundProperty = aBool;
   }
   PRBool IsParsingCompoundProperty(void) const {
     return mParsingCompoundProperty;
   }
 
-  /* Find and return the correct namespace ID for the prefix aPrefix.  If the
-     prefix cannot be resolved to a namespace, this method will return false.
-     Otherwise it will return true.  When returning false, it may set
-     aErrorCode, depending on the value of mUnresolvablePrefixException.
-     
+  /* Find and return the correct namespace ID for the prefix aPrefix.
+     If the prefix cannot be resolved to a namespace, this method will
+     return false.  Otherwise it will return true.  When returning
+     false, it may set the low-level error code, depending on the
+     value of mUnresolvablePrefixException.
+
      This method never returns kNameSpaceID_Unknown or
      kNameSpaceID_None for aNameSpaceID while returning true.
-  */ 
-  PRBool GetNamespaceIdForPrefix(const nsString& aPrefix, PRInt32* aNameSpaceID,
-                                 nsresult& aErrorCode);
-  
+  */
+  PRBool GetNamespaceIdForPrefix(const nsString& aPrefix,
+                                 PRInt32* aNameSpaceID);
+
   /* Find the correct default namespace, and set it on aSelector. */
   void SetDefaultNamespaceOnSelector(nsCSSSelector& aSelector);
 
   // Current token. The value is valid after calling GetToken and invalidated
   // by UngetToken.
   nsCSSToken mToken;
 
   // Our scanner.
@@ -526,50 +511,51 @@ protected:
   // The sheet we're parsing into
   nsCOMPtr<nsICSSStyleSheet> mSheet;
 
   // Used for @import rules
   nsICSSLoader* mChildLoader; // not ref counted, it owns us
 
   // Sheet section we're in.  This is used to enforce correct ordering of the
   // various rule types (eg the fact that a @charset rule must come before
-  // anything else).
-  enum nsCSSSection { 
-    eCSSSection_Charset, 
-    eCSSSection_Import, 
+  // anything else).  Note that there are checks of similar things in various
+  // places in nsCSSStyleSheet.cpp (e.g in insertRule, RebuildChildList).
+  enum nsCSSSection {
+    eCSSSection_Charset,
+    eCSSSection_Import,
     eCSSSection_NameSpace,
-    eCSSSection_General 
+    eCSSSection_General
   };
   nsCSSSection  mSection;
 
   nsXMLNameSpaceMap *mNameSpaceMap;  // weak, mSheet owns it
 
   // After an UngetToken is done this flag is true. The next call to
   // GetToken clears the flag.
   PRPackedBool mHavePushBack : 1;
 
   // True if we are in quirks mode; false in standards or almost standards mode
   PRPackedBool  mNavQuirkMode : 1;
-  
+
   // True if unsafe rules should be allowed
   PRPackedBool mUnsafeRulesEnabled : 1;
 
   // True for parsing media lists for HTML attributes, where we have to
   // ignore CSS comments.
   PRPackedBool mHTMLMediaMode : 1;
 
   // True if tagnames and attributes are case-sensitive
   PRPackedBool  mCaseSensitive : 1;
 
   // This flag is set when parsing a non-box shorthand; it's used to not apply
   // some quirks during shorthand parsing
   PRPackedBool  mParsingCompoundProperty : 1;
 
   // If this flag is true, failure to resolve a namespace prefix
-  // should set aErrorCode to NS_ERROR_DOM_NAMESPACE_ERR
+  // should set the low-level error to NS_ERROR_DOM_NAMESPACE_ERR
   PRPackedBool  mUnresolvablePrefixException : 1;
 
   // Stack of rule groups; used for @media and such.
   nsCOMArray<nsICSSGroupRule> mGroupStack;
 
   // During the parsing of a property (which may be a shorthand), the data
   // are stored in |mTempData|.  (It is needed to ensure that parser
   // errors cause the data to be ignored, and to ensure that a
@@ -722,37 +708,35 @@ CSSParserImpl::SetSVGMode(PRBool aSVGMod
 
 NS_IMETHODIMP
 CSSParserImpl::SetChildLoader(nsICSSLoader* aChildLoader)
 {
   mChildLoader = aChildLoader;  // not ref counted, it owns us
   return NS_OK;
 }
 
-nsresult
+void
 CSSParserImpl::InitScanner(nsIUnicharInputStream* aInput, nsIURI* aSheetURI,
                            PRUint32 aLineNumber, nsIURI* aBaseURI,
                            nsIPrincipal* aSheetPrincipal)
 {
   NS_ASSERTION(! mScannerInited, "already have scanner");
 
   mScanner.Init(aInput, nsnull, 0, aSheetURI, aLineNumber);
 #ifdef DEBUG
   mScannerInited = PR_TRUE;
 #endif
   mBaseURL = aBaseURI;
   mSheetURL = aSheetURI;
   mSheetPrincipal = aSheetPrincipal;
 
   mHavePushBack = PR_FALSE;
-
-  return NS_OK;
-}
-
-nsresult
+}
+
+void
 CSSParserImpl::InitScanner(const nsSubstring& aString, nsIURI* aSheetURI,
                            PRUint32 aLineNumber, nsIURI* aBaseURI,
                            nsIPrincipal* aSheetPrincipal)
 {
   // Having it not own the string is OK since the caller will hold on to
   // the stream until we're done parsing.
   NS_ASSERTION(! mScannerInited, "already have scanner");
 
@@ -761,44 +745,41 @@ CSSParserImpl::InitScanner(const nsSubst
 #ifdef DEBUG
   mScannerInited = PR_TRUE;
 #endif
   mBaseURL = aBaseURI;
   mSheetURL = aSheetURI;
   mSheetPrincipal = aSheetPrincipal;
 
   mHavePushBack = PR_FALSE;
-
-  return NS_OK;
-}
-
-nsresult
+}
+
+void
 CSSParserImpl::ReleaseScanner(void)
 {
   mScanner.Close();
 #ifdef DEBUG
   mScannerInited = PR_FALSE;
 #endif
   mBaseURL = nsnull;
   mSheetURL = nsnull;
   mSheetPrincipal = nsnull;
-  return NS_OK;
 }
 
 
 NS_IMETHODIMP
 CSSParserImpl::Parse(nsIUnicharInputStream* aInput,
                      nsIURI*                aSheetURI,
                      nsIURI*                aBaseURI,
                      nsIPrincipal*          aSheetPrincipal,
                      PRUint32               aLineNumber,
                      PRBool                 aAllowUnsafeRules)
 {
   NS_PRECONDITION(aSheetPrincipal, "Must have principal here!");
-  
+
   NS_ASSERTION(nsnull != aBaseURI, "need base URL");
   NS_ASSERTION(nsnull != aSheetURI, "need sheet URL");
   AssertInitialState();
 
   NS_PRECONDITION(mSheet, "Must have sheet to parse into");
   NS_ENSURE_STATE(mSheet);
 
 #ifdef DEBUG
@@ -807,77 +788,72 @@ CSSParserImpl::Parse(nsIUnicharInputStre
   PRBool equal;
   NS_ASSERTION(NS_SUCCEEDED(aSheetURI->Equals(uri, &equal)) && equal,
                "Sheet URI does not match passed URI");
   NS_ASSERTION(NS_SUCCEEDED(mSheet->Principal()->Equals(aSheetPrincipal,
                                                         &equal)) &&
                equal,
                "Sheet principal does not match passed principal");
 #endif
-  
-  nsresult errorCode = NS_OK;
-
-  nsresult result = InitScanner(aInput, aSheetURI, aLineNumber, aBaseURI,
-                                aSheetPrincipal);
-  if (! NS_SUCCEEDED(result)) {
-    return result;
-  }
+
+  InitScanner(aInput, aSheetURI, aLineNumber, aBaseURI, aSheetPrincipal);
 
   PRInt32 ruleCount = 0;
   mSheet->StyleRuleCount(ruleCount);
   if (0 < ruleCount) {
     nsICSSRule* lastRule = nsnull;
     mSheet->GetStyleRuleAt(ruleCount - 1, lastRule);
     if (lastRule) {
       PRInt32 type;
       lastRule->GetType(type);
       switch (type) {
         case nsICSSRule::CHARSET_RULE:
-        case nsICSSRule::IMPORT_RULE:     
-          mSection = eCSSSection_Import;    
-          break;
-        case nsICSSRule::NAMESPACE_RULE:  
-          mSection = eCSSSection_NameSpace; 
-          break;
-        default:  
-          mSection = eCSSSection_General; 
+        case nsICSSRule::IMPORT_RULE:
+          mSection = eCSSSection_Import;
+          break;
+        case nsICSSRule::NAMESPACE_RULE:
+          mSection = eCSSSection_NameSpace;
+          break;
+        default:
+          mSection = eCSSSection_General;
           break;
       }
       NS_RELEASE(lastRule);
     }
   }
   else {
     mSection = eCSSSection_Charset; // sheet is empty, any rules are fair
   }
 
   mUnsafeRulesEnabled = aAllowUnsafeRules;
 
   nsCSSToken* tk = &mToken;
   for (;;) {
     // Get next non-whitespace token
-    if (!GetToken(errorCode, PR_TRUE)) {
+    if (!GetToken(PR_TRUE)) {
       OUTPUT_ERROR();
       break;
     }
     if (eCSSToken_HTMLComment == tk->mType) {
       continue; // legal here only
     }
     if (eCSSToken_AtKeyword == tk->mType) {
-      ParseAtRule(errorCode, AppendRuleToSheet, this);
+      ParseAtRule(AppendRuleToSheet, this);
       continue;
     }
     UngetToken();
-    if (ParseRuleSet(errorCode, AppendRuleToSheet, this)) {
+    if (ParseRuleSet(AppendRuleToSheet, this)) {
       mSection = eCSSSection_General;
     }
   }
   ReleaseScanner();
 
   mUnsafeRulesEnabled = PR_FALSE;
 
+  // XXX check for low level errors
   return NS_OK;
 }
 
 /**
  * Determines whether the identifier contained in the given string is a
  * vendor-specific identifier, as described in CSS 2.1 section 4.1.2.1.
  */
 static PRBool
@@ -893,108 +869,97 @@ CSSParserImpl::ParseStyleAttribute(const
 CSSParserImpl::ParseStyleAttribute(const nsAString& aAttributeValue,
                                    nsIURI*                  aDocURL,
                                    nsIURI*                  aBaseURL,
                                    nsIPrincipal*            aNodePrincipal,
                                    nsICSSStyleRule**        aResult)
 {
   NS_PRECONDITION(aNodePrincipal, "Must have principal here!");
   AssertInitialState();
-  
+
   NS_ASSERTION(nsnull != aBaseURL, "need base URL");
 
   // XXX line number?
-  nsresult rv = InitScanner(aAttributeValue, aDocURL, 0, aBaseURL, aNodePrincipal);
-  if (! NS_SUCCEEDED(rv)) {
-    return rv;
-  }
+  InitScanner(aAttributeValue, aDocURL, 0, aBaseURL, aNodePrincipal);
 
   mSection = eCSSSection_General;
-  nsresult errorCode = NS_OK;
 
   // In quirks mode, allow style declarations to have braces or not
   // (bug 99554).
   PRBool haveBraces;
-  if (mNavQuirkMode && GetToken(errorCode, PR_TRUE)) {
+  if (mNavQuirkMode && GetToken(PR_TRUE)) {
     haveBraces = eCSSToken_Symbol == mToken.mType &&
                  '{' == mToken.mSymbol;
     UngetToken();
   }
   else {
     haveBraces = PR_FALSE;
   }
 
-  nsCSSDeclaration* declaration = ParseDeclarationBlock(errorCode, haveBraces);
+  nsCSSDeclaration* declaration = ParseDeclarationBlock(haveBraces);
   if (declaration) {
     // Create a style rule for the declaration
     nsICSSStyleRule* rule = nsnull;
-    rv = NS_NewCSSStyleRule(&rule, nsnull, declaration);
+    nsresult rv = NS_NewCSSStyleRule(&rule, nsnull, declaration);
     if (NS_FAILED(rv)) {
       declaration->RuleAbort();
       ReleaseScanner();
       return rv;
     }
     *aResult = rule;
   }
   else {
     *aResult = nsnull;
   }
 
   ReleaseScanner();
 
+  // XXX check for low level errors
   return NS_OK;
 }
 
 NS_IMETHODIMP
 CSSParserImpl::ParseAndAppendDeclaration(const nsAString&  aBuffer,
                                          nsIURI*           aSheetURL,
                                          nsIURI*           aBaseURL,
                                          nsIPrincipal*     aSheetPrincipal,
                                          nsCSSDeclaration* aDeclaration,
                                          PRBool            aParseOnlyOneDecl,
                                          PRBool*           aChanged,
                                          PRBool            aClearOldDecl)
 {
   NS_PRECONDITION(aSheetPrincipal, "Must have principal here!");
   AssertInitialState();
-  
-//  NS_ASSERTION(nsnull != aBaseURL, "need base URL");
+
   *aChanged = PR_FALSE;
 
-  nsresult rv = InitScanner(aBuffer, aSheetURL, 0, aBaseURL, aSheetPrincipal);
-  if (! NS_SUCCEEDED(rv)) {
-    return rv;
-  }
+  InitScanner(aBuffer, aSheetURL, 0, aBaseURL, aSheetPrincipal);
 
   mSection = eCSSSection_General;
-  nsresult errorCode = NS_OK;
 
   if (aClearOldDecl) {
     mData.AssertInitialState();
     aDeclaration->ClearData();
     // We could check if it was already empty, but...
     *aChanged = PR_TRUE;
   } else {
     aDeclaration->ExpandTo(&mData);
   }
 
+  nsresult rv = NS_OK;
   do {
     // If we cleared the old decl, then we want to be calling
     // ValueAppended as we parse.
-    if (!ParseDeclaration(errorCode, aDeclaration, PR_FALSE,
-                          aClearOldDecl, aChanged)) {
-      NS_ASSERTION(errorCode != nsresult(-1), "-1 is no longer used for EOF");
-      rv = errorCode;
-
-      if (NS_FAILED(errorCode))
-        break;
-
-      if (!SkipDeclaration(errorCode, PR_FALSE)) {
-        NS_ASSERTION(errorCode != nsresult(-1), "-1 is no longer used for EOF");
-        rv = errorCode;
+    if (!ParseDeclaration(aDeclaration, PR_FALSE, aClearOldDecl, aChanged)) {
+      rv = mScanner.GetLowLevelError();
+      if (NS_FAILED(rv))
+        break;
+
+      if (!SkipDeclaration(PR_FALSE)) {
+        rv = mScanner.GetLowLevelError();
         break;
       }
     }
   } while (!aParseOnlyOneDecl);
   aDeclaration->CompressFrom(&mData);
 
   ReleaseScanner();
   return rv;
@@ -1004,127 +969,116 @@ CSSParserImpl::ParseRule(const nsAString
 CSSParserImpl::ParseRule(const nsAString&        aRule,
                          nsIURI*                 aSheetURL,
                          nsIURI*                 aBaseURL,
                          nsIPrincipal*           aSheetPrincipal,
                          nsCOMArray<nsICSSRule>& aResult)
 {
   NS_PRECONDITION(aSheetPrincipal, "Must have principal here!");
   AssertInitialState();
-  
+
   NS_ASSERTION(nsnull != aBaseURL, "need base URL");
 
-  nsresult rv = InitScanner(aRule, aSheetURL, 0, aBaseURL, aSheetPrincipal);
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
+  InitScanner(aRule, aSheetURL, 0, aBaseURL, aSheetPrincipal);
 
   mSection = eCSSSection_Charset; // callers are responsible for rejecting invalid rules.
-  nsresult errorCode = NS_OK;
 
   nsCSSToken* tk = &mToken;
   // Get first non-whitespace token
-  if (!GetToken(errorCode, PR_TRUE)) {
+  if (!GetToken(PR_TRUE)) {
     REPORT_UNEXPECTED(PEParseRuleWSOnly);
     OUTPUT_ERROR();
   } else if (eCSSToken_AtKeyword == tk->mType) {
-    ParseAtRule(errorCode, AppendRuleToArray, &aResult);
-  }
-  else {
-    UngetToken();
-    ParseRuleSet(errorCode, AppendRuleToArray, &aResult);
+    ParseAtRule(AppendRuleToArray, &aResult);
+  }
+  else {
+    UngetToken();
+    ParseRuleSet(AppendRuleToArray, &aResult);
   }
   OUTPUT_ERROR();
   ReleaseScanner();
+  // XXX check for low-level errors
   return NS_OK;
 }
 
 NS_IMETHODIMP
 CSSParserImpl::ParseProperty(const nsCSSProperty aPropID,
                              const nsAString& aPropValue,
                              nsIURI* aSheetURL,
                              nsIURI* aBaseURL,
                              nsIPrincipal* aSheetPrincipal,
                              nsCSSDeclaration* aDeclaration,
                              PRBool* aChanged)
 {
   NS_PRECONDITION(aSheetPrincipal, "Must have principal here!");
   AssertInitialState();
-  
+
   NS_ASSERTION(nsnull != aBaseURL, "need base URL");
   NS_ASSERTION(nsnull != aDeclaration, "Need declaration to parse into!");
   *aChanged = PR_FALSE;
 
-  nsresult rv = InitScanner(aPropValue, aSheetURL, 0, aBaseURL, aSheetPrincipal);
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
+  InitScanner(aPropValue, aSheetURL, 0, aBaseURL, aSheetPrincipal);
 
   mSection = eCSSSection_General;
-  nsresult errorCode = NS_OK;
 
   if (eCSSProperty_UNKNOWN == aPropID) { // unknown property
     NS_ConvertASCIItoUTF16 propName(nsCSSProps::GetStringValue(aPropID));
     const PRUnichar *params[] = {
       propName.get()
     };
     REPORT_UNEXPECTED_P(PEUnknownProperty, params);
     REPORT_UNEXPECTED(PEDeclDropped);
     OUTPUT_ERROR();
     ReleaseScanner();
     return NS_OK;
   }
-  
+
   mData.AssertInitialState();
   mTempData.AssertInitialState();
   aDeclaration->ExpandTo(&mData);
   nsresult result = NS_OK;
-  PRBool parsedOK = ParseProperty(errorCode, aPropID);
-  if (parsedOK && !GetToken(errorCode, PR_TRUE)) {
+  PRBool parsedOK = ParseProperty(aPropID);
+  if (parsedOK && !GetToken(PR_TRUE)) {
     TransferTempData(aDeclaration, aPropID, PR_FALSE, PR_FALSE, aChanged);
   } else {
     if (parsedOK) {
       // Junk at end of property value.
       REPORT_UNEXPECTED_TOKEN(PEExpectEndValue);
     }
     NS_ConvertASCIItoUTF16 propName(nsCSSProps::GetStringValue(aPropID));
     const PRUnichar *params[] = {
       propName.get()
     };
     REPORT_UNEXPECTED_P(PEValueParsingError, params);
     REPORT_UNEXPECTED(PEDeclDropped);
     OUTPUT_ERROR();
     ClearTempData(aPropID);
-    NS_ASSERTION(errorCode != nsresult(-1), "-1 is no longer used for EOF");
-    result = errorCode;
+    result = mScanner.GetLowLevelError();
   }
   CLEAR_ERROR();
-  
+
   aDeclaration->CompressFrom(&mData);
-  
+
   ReleaseScanner();
   return result;
 }
 
 NS_IMETHODIMP
 CSSParserImpl::ParseMediaList(const nsSubstring& aBuffer,
                               nsIURI* aURL, // for error reporting
                               PRUint32 aLineNumber, // for error reporting
                               nsMediaList* aMediaList,
                               PRBool aHTMLMode)
 {
   // XXX Are there cases where the caller wants to keep what it already
   // has in case of parser error?
   aMediaList->Clear();
 
   // fake base URL since media lists don't have URLs in them
-  nsresult rv = InitScanner(aBuffer, aURL, aLineNumber, aURL, nsnull);
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
+  InitScanner(aBuffer, aURL, aLineNumber, aURL, nsnull);
 
   AssertInitialState();
   NS_ASSERTION(aHTMLMode == PR_TRUE || aHTMLMode == PR_FALSE,
                "invalid PRBool");
   mHTMLMediaMode = aHTMLMode;
 
     // XXXldb We need to make the scanner not skip CSS comments!  (Or
     // should we?)
@@ -1133,49 +1087,48 @@ CSSParserImpl::ParseMediaList(const nsSu
   // http://www.w3.org/TR/1999/REC-html401-19991224/types.html#type-media-descriptors
   // which wouldn't work for media queries since they remove all but the
   // first word.  However, they're changed in
   // http://www.whatwg.org/specs/web-apps/current-work/multipage/section-document.html#media2
   // (as of 2008-05-29) which says that the media attribute just points
   // to a media query.  (The main substative difference is the relative
   // precedence of commas and paretheses.)
 
-  if (!GatherMedia(rv, aMediaList, PRUnichar(0))) {
+  if (!GatherMedia(aMediaList, PRUnichar(0))) {
     aMediaList->Clear();
     aMediaList->SetNonEmpty(); // don't match anything
     if (!mHTMLMediaMode) {
       OUTPUT_ERROR();
     }
   }
+  nsresult rv = mScanner.GetLowLevelError();
   CLEAR_ERROR();
   ReleaseScanner();
   mHTMLMediaMode = PR_FALSE;
 
   return rv;
 }
 
 NS_IMETHODIMP
 CSSParserImpl::ParseColorString(const nsSubstring& aBuffer,
                                 nsIURI* aURL, // for error reporting
                                 PRUint32 aLineNumber, // for error reporting
                                 nscolor* aColor)
 {
   AssertInitialState();
-  nsresult rv = InitScanner(aBuffer, aURL, aLineNumber, aURL, nsnull);
-  if (NS_FAILED(rv))
-    return rv;
+  InitScanner(aBuffer, aURL, aLineNumber, aURL, nsnull);
 
   nsCSSValue value;
-  PRBool colorParsed = ParseColor(rv, value);
-
+  PRBool colorParsed = ParseColor(value);
+  nsresult rv = mScanner.GetLowLevelError();
   OUTPUT_ERROR();
   ReleaseScanner();
 
   if (!colorParsed) {
-    return NS_ERROR_FAILURE;
+    return NS_FAILED(rv) ? rv : NS_ERROR_FAILURE;
   }
 
   if (value.GetUnit() == eCSSUnit_String) {
     nscolor rgba;
     if (NS_ColorNameToRGB(nsDependentString(value.GetStringBufferValue()), &rgba)) {
       (*aColor) = rgba;
       rv = NS_OK;
     }
@@ -1204,89 +1157,91 @@ CSSParserImpl::ParseColorString(const ns
 }
 
 NS_IMETHODIMP
 CSSParserImpl::ParseSelectorString(const nsSubstring& aSelectorString,
                                    nsIURI* aURL, // for error reporting
                                    PRUint32 aLineNumber, // for error reporting
                                    nsCSSSelectorList **aSelectorList)
 {
-  nsresult rv = InitScanner(aSelectorString, aURL, aLineNumber, aURL, nsnull);
-  if (NS_FAILED(rv))
-    return rv;
+  InitScanner(aSelectorString, aURL, aLineNumber, aURL, nsnull);
 
   AssertInitialState();
 
   mUnresolvablePrefixException = PR_TRUE;
 
-  PRBool success = ParseSelectorList(rv, *aSelectorList, PR_FALSE);
+  PRBool success = ParseSelectorList(*aSelectorList, PR_FALSE);
+  nsresult rv = mScanner.GetLowLevelError();
   OUTPUT_ERROR();
   ReleaseScanner();
 
   mUnresolvablePrefixException = PR_FALSE;
 
   if (success) {
     NS_ASSERTION(*aSelectorList, "Should have list!");
     return NS_OK;
   }
-  
+
   NS_ASSERTION(!*aSelectorList, "Shouldn't have list!");
   if (NS_SUCCEEDED(rv)) {
     rv = NS_ERROR_DOM_SYNTAX_ERR;
   }
   return rv;
 }
 
 //----------------------------------------------------------------------
 
-PRBool CSSParserImpl::GetToken(nsresult& aErrorCode, PRBool aSkipWS)
+PRBool
+CSSParserImpl::GetToken(PRBool aSkipWS)
 {
   for (;;) {
     if (!mHavePushBack) {
-      if (!mScanner.Next(aErrorCode, mToken)) {
+      if (!mScanner.Next(mToken)) {
         break;
       }
     }
     mHavePushBack = PR_FALSE;
     if (aSkipWS && (eCSSToken_WhiteSpace == mToken.mType)) {
       continue;
     }
     return PR_TRUE;
   }
   return PR_FALSE;
 }
 
-PRBool CSSParserImpl::GetURLToken(nsresult& aErrorCode)
+PRBool
+CSSParserImpl::GetURLToken()
 {
   for (;;) {
     // XXXldb This pushback code doesn't make sense.
     if (! mHavePushBack) {
-      if (! mScanner.NextURL(aErrorCode, mToken)) {
+      if (! mScanner.NextURL(mToken)) {
         break;
       }
     }
     mHavePushBack = PR_FALSE;
     if (eCSSToken_WhiteSpace != mToken.mType) {
       return PR_TRUE;
     }
   }
   return PR_FALSE;
 }
 
-void CSSParserImpl::UngetToken()
+void
+CSSParserImpl::UngetToken()
 {
   NS_PRECONDITION(mHavePushBack == PR_FALSE, "double pushback");
   mHavePushBack = PR_TRUE;
 }
 
-PRBool CSSParserImpl::ExpectSymbol(nsresult& aErrorCode,
-                                   PRUnichar aSymbol,
-                                   PRBool aSkipWS)
-{
-  if (!GetToken(aErrorCode, aSkipWS)) {
+PRBool
+CSSParserImpl::ExpectSymbol(PRUnichar aSymbol,
+                            PRBool aSkipWS)
+{
+  if (!GetToken(aSkipWS)) {
     // CSS2.1 specifies that all "open constructs" are to be closed at
     // EOF.  It simplifies higher layers if we claim to have found an
     // ), ], }, or ; if we encounter EOF while looking for one of them.
     // Do still issue a diagnostic, to aid debugging.
     if (aSymbol == ')' || aSymbol == ']' ||
         aSymbol == '}' || aSymbol == ';') {
       REPORT_UNEXPECTED_EOF_CHAR(aSymbol);
       return PR_TRUE;
@@ -1296,191 +1251,197 @@ PRBool CSSParserImpl::ExpectSymbol(nsres
   }
   if (mToken.IsSymbol(aSymbol)) {
     return PR_TRUE;
   }
   UngetToken();
   return PR_FALSE;
 }
 
-PRBool CSSParserImpl::ExpectEndProperty(nsresult& aErrorCode)
-{
-  if (!GetToken(aErrorCode, PR_TRUE)) {
+PRBool
+CSSParserImpl::ExpectEndProperty()
+{
+  if (!GetToken(PR_TRUE)) {
     return PR_TRUE; // properties may end with eof
   }
   if ((eCSSToken_Symbol == mToken.mType) &&
       ((';' == mToken.mSymbol) || ('!' == mToken.mSymbol) || ('}' == mToken.mSymbol))) {
     // XXX need to verify that ! is only followed by "important [;|}]
     // XXX this requires a multi-token pushback buffer
     UngetToken();
     return PR_TRUE;
   }
   REPORT_UNEXPECTED_TOKEN(PEExpectEndValue);
   UngetToken();
   return PR_FALSE;
 }
 
 
-nsSubstring* CSSParserImpl::NextIdent(nsresult& aErrorCode)
+nsSubstring*
+CSSParserImpl::NextIdent()
 {
   // XXX Error reporting?
-  if (!GetToken(aErrorCode, PR_TRUE)) {
+  if (!GetToken(PR_TRUE)) {
     return nsnull;
   }
   if (eCSSToken_Ident != mToken.mType) {
     UngetToken();
     return nsnull;
   }
   return &mToken.mIdent;
 }
 
-PRBool CSSParserImpl::SkipAtRule(nsresult& aErrorCode)
-{
-  for (;;) {
-    if (!GetToken(aErrorCode, PR_TRUE)) {
+PRBool
+CSSParserImpl::SkipAtRule()
+{
+  for (;;) {
+    if (!GetToken(PR_TRUE)) {
       REPORT_UNEXPECTED_EOF(PESkipAtRuleEOF);
       return PR_FALSE;
     }
     if (eCSSToken_Symbol == mToken.mType) {
       PRUnichar symbol = mToken.mSymbol;
       if (symbol == ';') {
         break;
       }
       if (symbol == '{') {
-        SkipUntil(aErrorCode, '}');
+        SkipUntil('}');
         break;
       } else if (symbol == '(') {
-        SkipUntil(aErrorCode, ')');
+        SkipUntil(')');
       } else if (symbol == '[') {
-        SkipUntil(aErrorCode, ']');
-      }
-    }
-  }
-  return PR_TRUE;
-}
-
-PRBool CSSParserImpl::ParseAtRule(nsresult& aErrorCode, RuleAppendFunc aAppendFunc,
-                                  void* aData)
-{
-  if ((mSection <= eCSSSection_Charset) && 
+        SkipUntil(']');
+      }
+    }
+  }
+  return PR_TRUE;
+}
+
+PRBool
+CSSParserImpl::ParseAtRule(RuleAppendFunc aAppendFunc,
+                           void* aData)
+{
+  if ((mSection <= eCSSSection_Charset) &&
       (mToken.mIdent.LowerCaseEqualsLiteral("charset"))) {
-    if (ParseCharsetRule(aErrorCode, aAppendFunc, aData)) {
+    if (ParseCharsetRule(aAppendFunc, aData)) {
       mSection = eCSSSection_Import;  // only one charset allowed
       return PR_TRUE;
     }
   }
-  if ((mSection <= eCSSSection_Import) && 
+  if ((mSection <= eCSSSection_Import) &&
       mToken.mIdent.LowerCaseEqualsLiteral("import")) {
-    if (ParseImportRule(aErrorCode, aAppendFunc, aData)) {
+    if (ParseImportRule(aAppendFunc, aData)) {
       mSection = eCSSSection_Import;
       return PR_TRUE;
     }
   }
-  if ((mSection <= eCSSSection_NameSpace) && 
+  if ((mSection <= eCSSSection_NameSpace) &&
       mToken.mIdent.LowerCaseEqualsLiteral("namespace")) {
-    if (ParseNameSpaceRule(aErrorCode, aAppendFunc, aData)) {
+    if (ParseNameSpaceRule(aAppendFunc, aData)) {
       mSection = eCSSSection_NameSpace;
       return PR_TRUE;
     }
   }
   if (mToken.mIdent.LowerCaseEqualsLiteral("media")) {
-    if (ParseMediaRule(aErrorCode, aAppendFunc, aData)) {
+    if (ParseMediaRule(aAppendFunc, aData)) {
       mSection = eCSSSection_General;
       return PR_TRUE;
     }
   }
   if (mToken.mIdent.LowerCaseEqualsLiteral("-moz-document")) {
-    if (ParseMozDocumentRule(aErrorCode, aAppendFunc, aData)) {
+    if (ParseMozDocumentRule(aAppendFunc, aData)) {
       mSection = eCSSSection_General;
       return PR_TRUE;
     }
   }
   if (mToken.mIdent.LowerCaseEqualsLiteral("font-face")) {
-    if (ParseFontFaceRule(aErrorCode, aAppendFunc, aData)) {
+    if (ParseFontFaceRule(aAppendFunc, aData)) {
       mSection = eCSSSection_General;
       return PR_TRUE;
     }
   }
   if (mToken.mIdent.LowerCaseEqualsLiteral("page")) {
-    if (ParsePageRule(aErrorCode, aAppendFunc, aData)) {
+    if (ParsePageRule(aAppendFunc, aData)) {
       mSection = eCSSSection_General;
       return PR_TRUE;
     }
   }
 
   if (!NonMozillaVendorIdentifier(mToken.mIdent)) {
     REPORT_UNEXPECTED_TOKEN(PEUnknownAtRule);
     OUTPUT_ERROR();
   }
 
   // Skip over unsupported at rule, don't advance section
-  return SkipAtRule(aErrorCode);
-}
-
-PRBool CSSParserImpl::ParseCharsetRule(nsresult& aErrorCode, RuleAppendFunc aAppendFunc,
-                                       void* aData)
-{
-  if (!GetToken(aErrorCode, PR_TRUE)) {
+  return SkipAtRule();
+}
+
+PRBool
+CSSParserImpl::ParseCharsetRule(RuleAppendFunc aAppendFunc,
+                                void* aData)
+{
+  if (!GetToken(PR_TRUE)) {
     REPORT_UNEXPECTED_EOF(PECharsetRuleEOF);
     return PR_FALSE;
   }
 
   if (eCSSToken_String != mToken.mType) {
     REPORT_UNEXPECTED_TOKEN(PECharsetRuleNotString);
     return PR_FALSE;
   }
 
   nsAutoString charset = mToken.mIdent;
-  
-  if (!ExpectSymbol(aErrorCode, ';', PR_TRUE)) {
+
+  if (!ExpectSymbol(';', PR_TRUE)) {
     return PR_FALSE;
   }
 
   nsCOMPtr<nsICSSRule> rule;
   NS_NewCSSCharsetRule(getter_AddRefs(rule), charset);
 
   if (rule) {
     (*aAppendFunc)(rule, aData);
   }
 
   return PR_TRUE;
 }
 
-PRBool CSSParserImpl::GatherURL(nsresult& aErrorCode, nsString& aURL)
-{
-  if (!GetToken(aErrorCode, PR_TRUE)) {
+PRBool
+CSSParserImpl::GatherURL(nsString& aURL)
+{
+  if (!GetToken(PR_TRUE)) {
     return PR_FALSE;
   }
   if (eCSSToken_String == mToken.mType) {
     aURL = mToken.mIdent;
     return PR_TRUE;
   }
-  else if (eCSSToken_Function == mToken.mType && 
+  else if (eCSSToken_Function == mToken.mType &&
            mToken.mIdent.LowerCaseEqualsLiteral("url") &&
-           ExpectSymbol(aErrorCode, '(', PR_FALSE) &&
-           GetURLToken(aErrorCode) &&
+           ExpectSymbol('(', PR_FALSE) &&
+           GetURLToken() &&
            (eCSSToken_String == mToken.mType ||
             eCSSToken_URL == mToken.mType)) {
     aURL = mToken.mIdent;
-    if (ExpectSymbol(aErrorCode, ')', PR_TRUE)) {
+    if (ExpectSymbol(')', PR_TRUE)) {
       return PR_TRUE;
     }
   }
   return PR_FALSE;
 }
 
 // Callers must clear or throw out aMedia if GatherMedia returns false.
-PRBool CSSParserImpl::GatherMedia(nsresult& aErrorCode,
-                                  nsMediaList* aMedia,
-                                  PRUnichar aStopSymbol)
+PRBool
+CSSParserImpl::GatherMedia(nsMediaList* aMedia,
+                           PRUnichar aStopSymbol)
 {
   // "If the comma-separated list is the empty list it is assumed to
   // specify the media query 'all'."  (css3-mediaqueries, section
   // "Media Queries")
-  if (!GetToken(aErrorCode, PR_TRUE)) {
+  if (!GetToken(PR_TRUE)) {
     // expected termination by EOF
     if (aStopSymbol == PRUnichar(0))
       return PR_TRUE;
 
     // unexpected termination by EOF; if we were looking for a
     // semicolon, return true anyway, for the same reason this is
     // done by ExpectSymbol().
     REPORT_UNEXPECTED_EOF(PEGatherMediaEOF);
@@ -1497,47 +1458,47 @@ PRBool CSSParserImpl::GatherMedia(nsresu
 
   for (;;) {
     // We want to still have |query| after we transfer ownership from
     // |queryHolder| to |aMedia|.
     nsMediaQuery *query;
     {
       nsAutoPtr<nsMediaQuery> queryHolder(new nsMediaQuery);
       if (!queryHolder) {
-        aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+        mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
         return PR_FALSE;
       }
       query = queryHolder;
 
       // In terms of error handling, it doesn't really matter when we
       // append this, since aMedia's contents get dropped entirely
       // whenever there is an error.
       nsresult rv = aMedia->AppendQuery(queryHolder);
       if (NS_FAILED(rv)) {
-        aErrorCode = rv;
+        mScanner.SetLowLevelError(rv);
         return PR_FALSE;
       }
       NS_ASSERTION(!queryHolder, "ownership should have been transferred");
     }
 
-    if (ExpectSymbol(aErrorCode, '(', PR_TRUE)) {
+    if (ExpectSymbol('(', PR_TRUE)) {
       // we got an expression without a media type
       UngetToken(); // so ParseMediaQueryExpression can handle it
       query->SetType(nsGkAtoms::all);
       query->SetTypeOmitted();
       // Just parse the first expression here.
-      if (!ParseMediaQueryExpression(aErrorCode, query)) {
+      if (!ParseMediaQueryExpression(query)) {
         OUTPUT_ERROR();
         query->SetHadUnknownExpression();
       }
     } else {
       nsCOMPtr<nsIAtom> mediaType;
       PRBool gotNotOrOnly = PR_FALSE;
       for (;;) {
-        if (!GetToken(aErrorCode, PR_TRUE)) {
+        if (!GetToken(PR_TRUE)) {
           REPORT_UNEXPECTED_EOF(PEGatherMediaEOF);
           return PR_FALSE;
         }
         if (eCSSToken_Ident != mToken.mType) {
           REPORT_UNEXPECTED_TOKEN(PEGatherMediaNotIdent);
           UngetToken();
           return PR_FALSE;
         }
@@ -1552,17 +1513,17 @@ PRBool CSSParserImpl::GatherMedia(nsresu
           query->SetNegated();
         else
           query->SetHasOnly();
       }
       query->SetType(mediaType);
     }
 
     for (;;) {
-      if (!GetToken(aErrorCode, PR_TRUE)) {
+      if (!GetToken(PR_TRUE)) {
         // expected termination by EOF
         if (aStopSymbol == PRUnichar(0))
           return PR_TRUE;
 
         // unexpected termination by EOF; if we were looking for a
         // semicolon, return true anyway, for the same reason this is
         // done by ExpectSymbol().
         REPORT_UNEXPECTED_EOF(PEGatherMediaEOF);
@@ -1579,46 +1540,47 @@ PRBool CSSParserImpl::GatherMedia(nsresu
         break;
       }
       if (eCSSToken_Ident != mToken.mType ||
           !mToken.mIdent.LowerCaseEqualsLiteral("and")) {
         REPORT_UNEXPECTED_TOKEN(PEGatherMediaNotComma);
         UngetToken();
         return PR_FALSE;
       }
-      if (!ParseMediaQueryExpression(aErrorCode, query)) {
+      if (!ParseMediaQueryExpression(query)) {
         OUTPUT_ERROR();
         query->SetHadUnknownExpression();
       }
     }
   }
   NS_NOTREACHED("unreachable code");
   return PR_FALSE; // keep the compiler happy
 }
 
-PRBool CSSParserImpl::ParseMediaQueryExpression(nsresult& aErrorCode, nsMediaQuery* aQuery)
-{
-  if (!ExpectSymbol(aErrorCode, '(', PR_TRUE)) {
+PRBool
+CSSParserImpl::ParseMediaQueryExpression(nsMediaQuery* aQuery)
+{
+  if (!ExpectSymbol('(', PR_TRUE)) {
     REPORT_UNEXPECTED_TOKEN(PEMQExpectedExpressionStart);
     return PR_FALSE;
   }
-  if (! GetToken(aErrorCode, PR_TRUE)) {
+  if (! GetToken(PR_TRUE)) {
     REPORT_UNEXPECTED_EOF(PEMQExpressionEOF);
     return PR_FALSE;
   }
   if (eCSSToken_Ident != mToken.mType) {
     REPORT_UNEXPECTED_TOKEN(PEMQExpectedFeatureName);
-    SkipUntil(aErrorCode, ')');
+    SkipUntil(')');
     return PR_FALSE;
   }
 
   nsMediaExpression *expr = aQuery->NewExpression();
   if (!expr) {
-    aErrorCode = NS_ERROR_OUT_OF_MEMORY;
-    SkipUntil(aErrorCode, ')');
+    mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+    SkipUntil(')');
     return PR_FALSE;
   }
 
   // case insensitive from CSS - must be lower cased
   ToLowerCase(mToken.mIdent);
   const PRUnichar *featureString;
   if (StringBeginsWith(mToken.mIdent, NS_LITERAL_STRING("min-"))) {
     expr->mRange = nsMediaExpression::eMin;
@@ -1637,29 +1599,29 @@ PRBool CSSParserImpl::ParseMediaQueryExp
     if (*(feature->mName) == mediaFeatureAtom) {
       break;
     }
   }
   if (!feature->mName ||
       (expr->mRange != nsMediaExpression::eEqual &&
        feature->mRangeType != nsMediaFeature::eMinMaxAllowed)) {
     REPORT_UNEXPECTED_TOKEN(PEMQExpectedFeatureName);
-    SkipUntil(aErrorCode, ')');
+    SkipUntil(')');
     return PR_FALSE;
   }
   expr->mFeature = feature;
 
-  if (! GetToken(aErrorCode, PR_TRUE)) {
+  if (! GetToken(PR_TRUE)) {
     REPORT_UNEXPECTED_EOF(PEMQExpressionEOF);
     return PR_FALSE;
   }
   if (eCSSToken_Symbol != mToken.mType ||
       (mToken.mSymbol != PRUnichar(':') && mToken.mSymbol != PRUnichar(')'))) {
     REPORT_UNEXPECTED_TOKEN(PEMQExpectedFeatureNameEnd);
-    SkipUntil(aErrorCode, ')');
+    SkipUntil(')');
     return PR_FALSE;
   }
 
   if (mToken.mSymbol == PRUnichar(')')) {
     // Query expressions for any feature can be given without a value.
     // However, min/max prefixes are not allowed.
     if (expr->mRange != nsMediaExpression::eEqual) {
       REPORT_UNEXPECTED(PEMQNoMinMaxWithoutValue);
@@ -1667,328 +1629,330 @@ PRBool CSSParserImpl::ParseMediaQueryExp
     }
     expr->mValue.Reset();
     return PR_TRUE;
   }
 
   PRBool rv;
   switch (feature->mValueType) {
     case nsMediaFeature::eLength:
-      rv = ParsePositiveVariant(aErrorCode, expr->mValue,
-                                VARIANT_LENGTH, nsnull);
+      rv = ParsePositiveVariant(expr->mValue, VARIANT_LENGTH, nsnull);
       break;
     case nsMediaFeature::eInteger:
     case nsMediaFeature::eBoolInteger:
-      rv = ParsePositiveVariant(aErrorCode, expr->mValue,
-                                VARIANT_INTEGER, nsnull);
+      rv = ParsePositiveVariant(expr->mValue, VARIANT_INTEGER, nsnull);
       // Enforce extra restrictions for eBoolInteger
       if (rv &&
           feature->mValueType == nsMediaFeature::eBoolInteger &&
           expr->mValue.GetIntValue() > 1)
         rv = PR_FALSE;
       break;
     case nsMediaFeature::eIntRatio:
       {
         // Two integers separated by '/', with optional whitespace on
         // either side of the '/'.
         nsRefPtr<nsCSSValue::Array> a = nsCSSValue::Array::Create(2);
         if (!a) {
-          aErrorCode = NS_ERROR_OUT_OF_MEMORY;
-          SkipUntil(aErrorCode, ')');
+          mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+          SkipUntil(')');
           return PR_FALSE;
         }
         expr->mValue.SetArrayValue(a, eCSSUnit_Array);
         // We don't bother with ParsePositiveVariant since we have to
         // check for != 0 as well; no need to worry about the UngetToken
         // since we're throwing out up to the next ')' anyway.
-        rv = ParseVariant(aErrorCode, a->Item(0), VARIANT_INTEGER, nsnull) &&
+        rv = ParseVariant(a->Item(0), VARIANT_INTEGER, nsnull) &&
              a->Item(0).GetIntValue() > 0 &&
-             ExpectSymbol(aErrorCode, '/', PR_TRUE) &&
-             ParseVariant(aErrorCode, a->Item(1), VARIANT_INTEGER, nsnull) &&
+             ExpectSymbol('/', PR_TRUE) &&
+             ParseVariant(a->Item(1), VARIANT_INTEGER, nsnull) &&
              a->Item(1).GetIntValue() > 0;
       }
       break;
     case nsMediaFeature::eResolution:
-      rv = GetToken(aErrorCode, PR_TRUE) && mToken.IsDimension() &&
+      rv = GetToken(PR_TRUE) && mToken.IsDimension() &&
            mToken.mIntegerValid && mToken.mNumber > 0.0f;
       if (rv) {
         // No worries about whether unitless zero is allowed, since the
         // value must be positive (and we checked that above).
         NS_ASSERTION(!mToken.mIdent.IsEmpty(), "IsDimension lied");
         if (mToken.mIdent.LowerCaseEqualsLiteral("dpi")) {
           expr->mValue.SetFloatValue(mToken.mNumber, eCSSUnit_Inch);
         } else if (mToken.mIdent.LowerCaseEqualsLiteral("dpcm")) {
           expr->mValue.SetFloatValue(mToken.mNumber, eCSSUnit_Centimeter);
         } else {
           rv = PR_FALSE;
         }
       }
       break;
     case nsMediaFeature::eEnumerated:
-      rv = ParseVariant(aErrorCode, expr->mValue, VARIANT_KEYWORD,
+      rv = ParseVariant(expr->mValue, VARIANT_KEYWORD,
                         feature->mKeywordTable);
       break;
   }
   if (!rv) {
     REPORT_UNEXPECTED(PEMQExpectedFeatureValue);
     return PR_FALSE;
   }
 
-  return ExpectSymbol(aErrorCode, ')', PR_TRUE);
+  return ExpectSymbol(')', PR_TRUE);
 }
 
 // Parse a CSS2 import rule: "@import STRING | URL [medium [, medium]]"
-PRBool CSSParserImpl::ParseImportRule(nsresult& aErrorCode, RuleAppendFunc aAppendFunc, void* aData)
+PRBool
+CSSParserImpl::ParseImportRule(RuleAppendFunc aAppendFunc, void* aData)
 {
   nsCOMPtr<nsMediaList> media = new nsMediaList();
   if (!media) {
-    aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+    mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
     return PR_FALSE;
   }
 
   nsAutoString url;
-  if (!GatherURL(aErrorCode, url)) {
+  if (!GatherURL(url)) {
     REPORT_UNEXPECTED_TOKEN(PEImportNotURI);
     return PR_FALSE;
   }
-  
-  if (!ExpectSymbol(aErrorCode, ';', PR_TRUE)) {
-    if (!GatherMedia(aErrorCode, media, ';') ||
-        !ExpectSymbol(aErrorCode, ';', PR_TRUE)) {
+
+  if (!ExpectSymbol(';', PR_TRUE)) {
+    if (!GatherMedia(media, ';') ||
+        !ExpectSymbol(';', PR_TRUE)) {
       REPORT_UNEXPECTED_TOKEN(PEImportUnexpected);
       // don't advance section, simply ignore invalid @import
       return PR_FALSE;
     }
+
+    // Safe to assert this, since we ensured that there is something
+    // other than the ';' coming after the @import's url() token.
     NS_ASSERTION(media->Count() != 0, "media list must be nonempty");
   }
 
-  ProcessImport(aErrorCode, url, media, aAppendFunc, aData);
-  return PR_TRUE;
-}
-
-
-PRBool CSSParserImpl::ProcessImport(nsresult& aErrorCode,
-                                    const nsString& aURLSpec,
-                                    nsMediaList* aMedia,
-                                    RuleAppendFunc aAppendFunc,
-                                    void* aData)
+  ProcessImport(url, media, aAppendFunc, aData);
+  return PR_TRUE;
+}
+
+
+PRBool
+CSSParserImpl::ProcessImport(const nsString& aURLSpec,
+                             nsMediaList* aMedia,
+                             RuleAppendFunc aAppendFunc,
+                             void* aData)
 {
   nsCOMPtr<nsICSSImportRule> rule;
-  aErrorCode = NS_NewCSSImportRule(getter_AddRefs(rule), aURLSpec, aMedia);
-  if (NS_FAILED(aErrorCode)) {
+  nsresult rv = NS_NewCSSImportRule(getter_AddRefs(rule), aURLSpec, aMedia);
+  if (NS_FAILED(rv)) {
+    mScanner.SetLowLevelError(rv);
     return PR_FALSE;
   }
   (*aAppendFunc)(rule, aData);
 
   if (mChildLoader) {
     nsCOMPtr<nsIURI> url;
     // XXX should pass a charset!
-    aErrorCode = NS_NewURI(getter_AddRefs(url), aURLSpec, nsnull, mBaseURL);
-
-    if (NS_FAILED(aErrorCode)) {
+    rv = NS_NewURI(getter_AddRefs(url), aURLSpec, nsnull, mBaseURL);
+
+    if (NS_FAILED(rv)) {
       // import url is bad
       // XXX log this somewhere for easier web page debugging
+      mScanner.SetLowLevelError(rv);
       return PR_FALSE;
     }
 
     mChildLoader->LoadChildSheet(mSheet, url, aMedia, rule);
   }
-  
+
   return PR_TRUE;
 }
 
 // Parse the {} part of an @media or @-moz-document rule.
-PRBool CSSParserImpl::ParseGroupRule(nsresult& aErrorCode,
-                                     nsICSSGroupRule* aRule,
-                                     RuleAppendFunc aAppendFunc,
-                                     void* aData)
+PRBool
+CSSParserImpl::ParseGroupRule(nsICSSGroupRule* aRule,
+                              RuleAppendFunc aAppendFunc,
+                              void* aData)
 {
   // XXXbz this could use better error reporting throughout the method
-  if (!ExpectSymbol(aErrorCode, '{', PR_TRUE)) {
+  if (!ExpectSymbol('{', PR_TRUE)) {
     return PR_FALSE;
   }
 
   // push rule on stack, loop over children
   if (!PushGroup(aRule)) {
-    aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+    mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
     return PR_FALSE;
   }
   nsCSSSection holdSection = mSection;
   mSection = eCSSSection_General;
 
   for (;;) {
     // Get next non-whitespace token
-    if (! GetToken(aErrorCode, PR_TRUE)) {
+    if (! GetToken(PR_TRUE)) {
       REPORT_UNEXPECTED_EOF(PEGroupRuleEOF);
       break;
     }
     if (mToken.IsSymbol('}')) { // done!
       UngetToken();
       break;
     }
     if (eCSSToken_AtKeyword == mToken.mType) {
-      SkipAtRule(aErrorCode); // group rules cannot contain @rules
+      SkipAtRule(); // group rules cannot contain @rules
       continue;
     }
     UngetToken();
-    ParseRuleSet(aErrorCode, AppendRuleToSheet, this);
+    ParseRuleSet(AppendRuleToSheet, this);
   }
   PopGroup();
 
-  if (!ExpectSymbol(aErrorCode, '}', PR_TRUE)) {
+  if (!ExpectSymbol('}', PR_TRUE)) {
     mSection = holdSection;
     return PR_FALSE;
   }
   (*aAppendFunc)(aRule, aData);
   return PR_TRUE;
 }
 
 // Parse a CSS2 media rule: "@media medium [, medium] { ... }"
-PRBool CSSParserImpl::ParseMediaRule(nsresult& aErrorCode,
-                                     RuleAppendFunc aAppendFunc,
-                                     void* aData)
+PRBool
+CSSParserImpl::ParseMediaRule(RuleAppendFunc aAppendFunc, void* aData)
 {
   nsCOMPtr<nsMediaList> media = new nsMediaList();
   if (!media) {
-    aErrorCode = NS_ERROR_OUT_OF_MEMORY;
-    return PR_FALSE;
-  }
-
-  if (GatherMedia(aErrorCode, media, '{')) {
-    NS_ASSERTION(media->Count() != 0, "media list must be nonempty");
+    mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+    return PR_FALSE;
+  }
+
+  if (GatherMedia(media, '{')) {
     // XXXbz this could use better error reporting throughout the method
     nsRefPtr<nsCSSMediaRule> rule(new nsCSSMediaRule());
     // Append first, so when we do SetMedia() the rule
     // knows what its stylesheet is.
-    if (rule && ParseGroupRule(aErrorCode, rule, aAppendFunc, aData)) {
+    if (rule && ParseGroupRule(rule, aAppendFunc, aData)) {
       rule->SetMedia(media);
       return PR_TRUE;
     }
   }
 
   return PR_FALSE;
 }
 
 // Parse a @-moz-document rule.  This is like an @media rule, but instead
 // of a medium it has a nonempty list of items where each item is either
 // url(), url-prefix(), or domain().
-PRBool CSSParserImpl::ParseMozDocumentRule(nsresult& aErrorCode,
-                                           RuleAppendFunc aAppendFunc,
-                                           void* aData)
+PRBool
+CSSParserImpl::ParseMozDocumentRule(RuleAppendFunc aAppendFunc, void* aData)
 {
   nsCSSDocumentRule::URL *urls = nsnull;
   nsCSSDocumentRule::URL **next = &urls;
   do {
-    if (!GetToken(aErrorCode, PR_TRUE) ||
+    if (!GetToken(PR_TRUE) ||
         eCSSToken_Function != mToken.mType ||
         !(mToken.mIdent.LowerCaseEqualsLiteral("url") ||
           mToken.mIdent.LowerCaseEqualsLiteral("url-prefix") ||
           mToken.mIdent.LowerCaseEqualsLiteral("domain"))) {
       REPORT_UNEXPECTED_TOKEN(PEMozDocRuleBadFunc);
       delete urls;
       return PR_FALSE;
     }
     nsCSSDocumentRule::URL *cur = *next = new nsCSSDocumentRule::URL;
     if (!cur) {
-      aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
       delete urls;
       return PR_FALSE;
     }
     next = &cur->next;
     if (mToken.mIdent.LowerCaseEqualsLiteral("url")) {
       cur->func = nsCSSDocumentRule::eURL;
     } else if (mToken.mIdent.LowerCaseEqualsLiteral("url-prefix")) {
       cur->func = nsCSSDocumentRule::eURLPrefix;
     } else if (mToken.mIdent.LowerCaseEqualsLiteral("domain")) {
       cur->func = nsCSSDocumentRule::eDomain;
     }
 
-    if (!ExpectSymbol(aErrorCode, '(', PR_FALSE) ||
-        !GetURLToken(aErrorCode) ||
+    if (!ExpectSymbol('(', PR_FALSE) ||
+        !GetURLToken() ||
         (eCSSToken_String != mToken.mType &&
          eCSSToken_URL != mToken.mType)) {
       REPORT_UNEXPECTED_TOKEN(PEMozDocRuleNotURI);
       delete urls;
       return PR_FALSE;
     }
-    if (!ExpectSymbol(aErrorCode, ')', PR_TRUE)) {
+    if (!ExpectSymbol(')', PR_TRUE)) {
       delete urls;
       return PR_FALSE;
     }
 
     // We could try to make the URL (as long as it's not domain())
     // canonical and absolute with NS_NewURI and GetSpec, but I'm
     // inclined to think we shouldn't.
     CopyUTF16toUTF8(mToken.mIdent, cur->url);
-  } while (ExpectSymbol(aErrorCode, ',', PR_TRUE));
+  } while (ExpectSymbol(',', PR_TRUE));
 
   nsRefPtr<nsCSSDocumentRule> rule(new nsCSSDocumentRule());
   if (!rule) {
-    aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+    mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
     delete urls;
     return PR_FALSE;
   }
   rule->SetURLs(urls);
 
-  return ParseGroupRule(aErrorCode, rule, aAppendFunc, aData);
+  return ParseGroupRule(rule, aAppendFunc, aData);
 }
 
 // Parse a CSS3 namespace rule: "@namespace [prefix] STRING | URL;"
-PRBool CSSParserImpl::ParseNameSpaceRule(nsresult& aErrorCode,
-                                         RuleAppendFunc aAppendFunc,
-                                         void* aData)
-{
-  if (!GetToken(aErrorCode, PR_TRUE)) {
+PRBool
+CSSParserImpl::ParseNameSpaceRule(RuleAppendFunc aAppendFunc, void* aData)
+{
+  if (!GetToken(PR_TRUE)) {
     REPORT_UNEXPECTED_EOF(PEAtNSPrefixEOF);
     return PR_FALSE;
   }
 
   nsAutoString  prefix;
   nsAutoString  url;
 
   if (eCSSToken_Ident == mToken.mType) {
     prefix = mToken.mIdent;
     // user-specified identifiers are case-sensitive (bug 416106)
-    if (! GetToken(aErrorCode, PR_TRUE)) {
+    if (! GetToken(PR_TRUE)) {
       REPORT_UNEXPECTED_EOF(PEAtNSURIEOF);
       return PR_FALSE;
     }
   }
 
   if (eCSSToken_String == mToken.mType) {
     url = mToken.mIdent;
-    if (ExpectSymbol(aErrorCode, ';', PR_TRUE)) {
-      ProcessNameSpace(aErrorCode, prefix, url, aAppendFunc, aData);
-      return PR_TRUE;
-    }
-  }
-  else if ((eCSSToken_Function == mToken.mType) && 
+    if (ExpectSymbol(';', PR_TRUE)) {
+      ProcessNameSpace(prefix, url, aAppendFunc, aData);
+      return PR_TRUE;
+    }
+  }
+  else if ((eCSSToken_Function == mToken.mType) &&
            (mToken.mIdent.LowerCaseEqualsLiteral("url"))) {
-    if (ExpectSymbol(aErrorCode, '(', PR_FALSE)) {
-      if (GetURLToken(aErrorCode)) {
+    if (ExpectSymbol('(', PR_FALSE)) {
+      if (GetURLToken()) {
         if ((eCSSToken_String == mToken.mType) || (eCSSToken_URL == mToken.mType)) {
           url = mToken.mIdent;
-          if (ExpectSymbol(aErrorCode, ')', PR_TRUE)) {
-            if (ExpectSymbol(aErrorCode, ';', PR_TRUE)) {
-              ProcessNameSpace(aErrorCode, prefix, url, aAppendFunc, aData);
+          if (ExpectSymbol(')', PR_TRUE)) {
+            if (ExpectSymbol(';', PR_TRUE)) {
+              ProcessNameSpace(prefix, url, aAppendFunc, aData);
               return PR_TRUE;
             }
           }
         }
       }
     }
   }
   REPORT_UNEXPECTED_TOKEN(PEAtNSUnexpected);
 
   return PR_FALSE;
 }
 
-PRBool CSSParserImpl::ProcessNameSpace(nsresult& aErrorCode, const nsString& aPrefix, 
-                                       const nsString& aURLSpec, RuleAppendFunc aAppendFunc,
-                                       void* aData)
+PRBool
+CSSParserImpl::ProcessNameSpace(const nsString& aPrefix,
+                                const nsString& aURLSpec,
+                                RuleAppendFunc aAppendFunc,
+                                void* aData)
 {
   PRBool result = PR_FALSE;
 
   nsCOMPtr<nsICSSNameSpaceRule> rule;
   nsCOMPtr<nsIAtom> prefix;
 
   if (!aPrefix.IsEmpty()) {
     prefix = do_GetAtom(aPrefix);
@@ -2006,50 +1970,49 @@ PRBool CSSParserImpl::ProcessNameSpace(n
   }
 
   return result;
 }
 
 // font-face-rule: '@font-face' '{' font-description '}'
 // font-description: font-descriptor+
 PRBool
-CSSParserImpl::ParseFontFaceRule(nsresult& aErrorCode,
-                                 RuleAppendFunc aAppendFunc, void* aData)
-{
-  if (!ExpectSymbol(aErrorCode, '{', PR_TRUE))
+CSSParserImpl::ParseFontFaceRule(RuleAppendFunc aAppendFunc, void* aData)
+{
+  if (!ExpectSymbol('{', PR_TRUE))
     return PR_FALSE;
 
   nsRefPtr<nsCSSFontFaceRule> rule(new nsCSSFontFaceRule());
   if (!rule) {
-    aErrorCode = NS_ERROR_OUT_OF_MEMORY;
-    return PR_FALSE;
-  }
-
-  for (;;) {
-    if (!GetToken(aErrorCode, PR_TRUE)) {
+    mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+    return PR_FALSE;
+  }
+
+  for (;;) {
+    if (!GetToken(PR_TRUE)) {
       REPORT_UNEXPECTED_EOF(PEFontFaceEOF);
       break;
     }
     if (mToken.IsSymbol('}')) { // done!
       UngetToken();
       break;
     }
 
     // ignore extra semicolons
     if (mToken.IsSymbol(';'))
       continue;
 
-    if (!ParseFontDescriptor(aErrorCode, rule)) {
+    if (!ParseFontDescriptor(rule)) {
       REPORT_UNEXPECTED(PEDeclSkipped);
       OUTPUT_ERROR();
-      if (!SkipDeclaration(aErrorCode, PR_TRUE))
-        break;
-    }
-  }
-  if (!ExpectSymbol(aErrorCode, '}', PR_TRUE))
+      if (!SkipDeclaration(PR_TRUE))
+        break;
+    }
+  }
+  if (!ExpectSymbol('}', PR_TRUE))
     return PR_FALSE;
   (*aAppendFunc)(rule, aData);
   return PR_TRUE;
 }
 
 // font-descriptor: font-family-desc
 //                | font-style-desc
 //                | font-weight-desc
@@ -2058,109 +2021,111 @@ CSSParserImpl::ParseFontFaceRule(nsresul
 //                | unicode-range-desc
 //
 // All font-*-desc productions follow the pattern
 //    IDENT ':' value ';'
 //
 // On entry to this function, mToken is the IDENT.
 
 PRBool
-CSSParserImpl::ParseFontDescriptor(nsresult& aErrorCode,
-                                   nsCSSFontFaceRule* aRule)
+CSSParserImpl::ParseFontDescriptor(nsCSSFontFaceRule* aRule)
 {
   if (eCSSToken_Ident != mToken.mType) {
     REPORT_UNEXPECTED_TOKEN(PEFontDescExpected);
     return PR_FALSE;
   }
 
   nsString descName = mToken.mIdent;
-  if (!ExpectSymbol(aErrorCode, ':', PR_TRUE)) {
+  if (!ExpectSymbol(':', PR_TRUE)) {
     REPORT_UNEXPECTED_TOKEN(PEParseDeclarationNoColon);
     OUTPUT_ERROR();
     return PR_FALSE;
   }
 
   nsCSSFontDesc descID = nsCSSProps::LookupFontDesc(descName);
   nsCSSValue value;
 
   if (descID == eCSSFontDesc_UNKNOWN) {
     if (NonMozillaVendorIdentifier(descName)) {
       // silently skip other vendors' extensions
-      SkipDeclaration(aErrorCode, PR_TRUE);
+      SkipDeclaration(PR_TRUE);
       return PR_TRUE;
     } else {
       const PRUnichar *params[] = {
         descName.get()
       };
       REPORT_UNEXPECTED_P(PEUnknownFontDesc, params);
       return PR_FALSE;
     }
   }
 
-  if (!ParseFontDescriptorValue(aErrorCode, descID, value)) {
+  if (!ParseFontDescriptorValue(descID, value)) {
     const PRUnichar *params[] = {
       descName.get()
     };
     REPORT_UNEXPECTED_P(PEValueParsingError, params);
     return PR_FALSE;
   }
-  
-  if (!ExpectEndProperty(aErrorCode))
+
+  if (!ExpectEndProperty())
     return PR_FALSE;
 
   aRule->SetDesc(descID, value);
   return PR_TRUE;
 }
 
 
-PRBool CSSParserImpl::ParsePageRule(nsresult& aErrorCode, RuleAppendFunc aAppendFunc, void* aData)
+PRBool
+CSSParserImpl::ParsePageRule(RuleAppendFunc aAppendFunc, void* aData)
 {
   // XXX not yet implemented
   return PR_FALSE;
 }
 
-void CSSParserImpl::SkipUntil(nsresult& aErrorCode, PRUnichar aStopSymbol)
-{
-  nsCSSToken* tk = &mToken;
-  for (;;) {
-    if (!GetToken(aErrorCode, PR_TRUE)) {
+void
+CSSParserImpl::SkipUntil(PRUnichar aStopSymbol)
+{
+  nsCSSToken* tk = &mToken;
+  for (;;) {
+    if (!GetToken(PR_TRUE)) {
       break;
     }
     if (eCSSToken_Symbol == tk->mType) {
       PRUnichar symbol = tk->mSymbol;
       if (symbol == aStopSymbol) {
         break;
       } else if ('{' == symbol) {
-        SkipUntil(aErrorCode, '}');
+        SkipUntil('}');
       } else if ('[' == symbol) {
-        SkipUntil(aErrorCode, ']');
+        SkipUntil(']');
       } else if ('(' == symbol) {
-        SkipUntil(aErrorCode, ')');
-      }
-    }
-  }
-}
-
-PRBool CSSParserImpl::GetNonCloseParenToken(nsresult& aErrorCode, PRBool aSkipWS)
-{
-  if (!GetToken(aErrorCode, aSkipWS))
+        SkipUntil(')');
+      }
+    }
+  }
+}
+
+PRBool
+CSSParserImpl::GetNonCloseParenToken(PRBool aSkipWS)
+{
+  if (!GetToken(aSkipWS))
     return PR_FALSE;
   if (mToken.mType == eCSSToken_Symbol && mToken.mSymbol == ')') {
     UngetToken();
     return PR_FALSE;
   }
   return PR_TRUE;
 }
 
 PRBool
-CSSParserImpl::SkipDeclaration(nsresult& aErrorCode, PRBool aCheckForBraces)
-{
-  nsCSSToken* tk = &mToken;
-  for (;;) {
-    if (!GetToken(aErrorCode, PR_TRUE)) {
+CSSParserImpl::SkipDeclaration(PRBool aCheckForBraces)
+{
+  nsCSSToken* tk = &mToken;
+  for (;;) {
+    if (!GetToken(PR_TRUE)) {
       if (aCheckForBraces) {
         REPORT_UNEXPECTED_EOF(PESkipDeclBraceEOF);
       }
       return PR_FALSE;
     }
     if (eCSSToken_Symbol == tk->mType) {
       PRUnichar symbol = tk->mSymbol;
       if (';' == symbol) {
@@ -2168,93 +2133,98 @@ CSSParserImpl::SkipDeclaration(nsresult&
       }
       if (aCheckForBraces) {
         if ('}' == symbol) {
           UngetToken();
           break;
         }
       }
       if ('{' == symbol) {
-        SkipUntil(aErrorCode, '}');
+        SkipUntil('}');
       } else if ('(' == symbol) {
-        SkipUntil(aErrorCode, ')');
+        SkipUntil(')');
       } else if ('[' == symbol) {
-        SkipUntil(aErrorCode, ']');
-      }
-    }
-  }
-  return PR_TRUE;
-}
-
-void CSSParserImpl::SkipRuleSet(nsresult& aErrorCode)
-{
-  nsCSSToken* tk = &mToken;
-  for (;;) {
-    if (!GetToken(aErrorCode, PR_TRUE)) {
+        SkipUntil(']');
+      }
+    }
+  }
+  return PR_TRUE;
+}
+
+void
+CSSParserImpl::SkipRuleSet()
+{
+  nsCSSToken* tk = &mToken;
+  for (;;) {
+    if (!GetToken(PR_TRUE)) {
       REPORT_UNEXPECTED_EOF(PESkipRSBraceEOF);
       break;
     }
     if (eCSSToken_Symbol == tk->mType) {
       PRUnichar symbol = tk->mSymbol;
       if ('{' == symbol) {
-        SkipUntil(aErrorCode, '}');
+        SkipUntil('}');
         break;
       }
       if ('(' == symbol) {
-        SkipUntil(aErrorCode, ')');
+        SkipUntil(')');
       } else if ('[' == symbol) {
-        SkipUntil(aErrorCode, ']');
-      }
-    }
-  }
-}
-
-PRBool CSSParserImpl::PushGroup(nsICSSGroupRule* aRule)
+        SkipUntil(']');
+      }
+    }
+  }
+}
+
+PRBool
+CSSParserImpl::PushGroup(nsICSSGroupRule* aRule)
 {
   if (mGroupStack.AppendObject(aRule))
     return PR_TRUE;
 
   return PR_FALSE;
 }
 
-void CSSParserImpl::PopGroup(void)
+void
+CSSParserImpl::PopGroup(void)
 {
   PRInt32 count = mGroupStack.Count();
   if (0 < count) {
     mGroupStack.RemoveObjectAt(count - 1);
   }
 }
 
-void CSSParserImpl::AppendRule(nsICSSRule* aRule)
+void
+CSSParserImpl::AppendRule(nsICSSRule* aRule)
 {
   PRInt32 count = mGroupStack.Count();
   if (0 < count) {
     mGroupStack[count - 1]->AppendStyleRule(aRule);
   }
   else {
     mSheet->AppendStyleRule(aRule);
   }
 }
 
-PRBool CSSParserImpl::ParseRuleSet(nsresult& aErrorCode, RuleAppendFunc aAppendFunc, void* aData)
+PRBool
+CSSParserImpl::ParseRuleSet(RuleAppendFunc aAppendFunc, void* aData)
 {
   // First get the list of selectors for the rule
   nsCSSSelectorList* slist = nsnull;
   PRUint32 linenum = mScanner.GetLineNumber();
-  if (! ParseSelectorList(aErrorCode, slist, PR_TRUE)) {
+  if (! ParseSelectorList(slist, PR_TRUE)) {
     REPORT_UNEXPECTED(PEBadSelectorRSIgnored);
     OUTPUT_ERROR();
-    SkipRuleSet(aErrorCode);
+    SkipRuleSet();
     return PR_FALSE;
   }
   NS_ASSERTION(nsnull != slist, "null selector list");
   CLEAR_ERROR();
 
   // Next parse the declaration block
-  nsCSSDeclaration* declaration = ParseDeclarationBlock(aErrorCode, PR_TRUE);
+  nsCSSDeclaration* declaration = ParseDeclarationBlock(PR_TRUE);
   if (nsnull == declaration) {
     // XXX skip something here
     delete slist;
     return PR_FALSE;
   }
 
 #if 0
   slist->Dump();
@@ -2263,57 +2233,57 @@ PRBool CSSParserImpl::ParseRuleSet(nsres
   fputs("}\n", stdout);
 #endif
 
   // Translate the selector list and declaration block into style data
 
   nsCOMPtr<nsICSSStyleRule> rule;
   NS_NewCSSStyleRule(getter_AddRefs(rule), slist, declaration);
   if (!rule) {
-    aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+    mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
     delete slist;
     return PR_FALSE;
   }
   rule->SetLineNumber(linenum);
   (*aAppendFunc)(rule, aData);
 
   return PR_TRUE;
 }
 
-PRBool CSSParserImpl::ParseSelectorList(nsresult& aErrorCode,
-                                        nsCSSSelectorList*& aListHead,
-                                        PRBool aTerminateAtBrace)
+PRBool
+CSSParserImpl::ParseSelectorList(nsCSSSelectorList*& aListHead,
+                                 PRBool aTerminateAtBrace)
 {
   nsCSSSelectorList* list = nsnull;
-  if (! ParseSelectorGroup(aErrorCode, list)) {
+  if (! ParseSelectorGroup(list)) {
     // must have at least one selector group
     aListHead = nsnull;
     return PR_FALSE;
   }
   NS_ASSERTION(nsnull != list, "no selector list");
   aListHead = list;
 
   // After that there must either be a "," or a "{" (the latter if
   // aTerminateAtBrace is true)
   nsCSSToken* tk = &mToken;
   for (;;) {
-    if (! GetToken(aErrorCode, PR_TRUE)) {
+    if (! GetToken(PR_TRUE)) {
       if (!aTerminateAtBrace) {
         return PR_TRUE;
       }
-      
+
       REPORT_UNEXPECTED_EOF(PESelectorListExtraEOF);
       break;
     }
 
     if (eCSSToken_Symbol == tk->mType) {
       if (',' == tk->mSymbol) {
         nsCSSSelectorList* newList = nsnull;
         // Another selector group must follow
-        if (! ParseSelectorGroup(aErrorCode, newList)) {
+        if (! ParseSelectorGroup(newList)) {
           break;
         }
         // add new list to the end of the selector list
         list->mNext = newList;
         list = newList;
         continue;
       } else if ('{' == tk->mSymbol && aTerminateAtBrace) {
         UngetToken();
@@ -2327,18 +2297,18 @@ PRBool CSSParserImpl::ParseSelectorList(
 
   delete aListHead;
   aListHead = nsnull;
   return PR_FALSE;
 }
 
 static PRBool IsSinglePseudoClass(const nsCSSSelector& aSelector)
 {
-  return PRBool((aSelector.mNameSpace == kNameSpaceID_Unknown) && 
-                (aSelector.mTag == nsnull) && 
+  return PRBool((aSelector.mNameSpace == kNameSpaceID_Unknown) &&
+                (aSelector.mTag == nsnull) &&
                 (aSelector.mIDList == nsnull) &&
                 (aSelector.mClassList == nsnull) &&
                 (aSelector.mAttrList == nsnull) &&
                 (aSelector.mNegations == nsnull) &&
                 (aSelector.mPseudoClassList != nsnull) &&
                 (aSelector.mPseudoClassList->mNext == nsnull));
 }
 
@@ -2347,46 +2317,46 @@ static PRBool IsTreePseudoElement(nsIAto
 {
   const char* str;
   aPseudo->GetUTF8String(&str);
   static const char moz_tree[] = ":-moz-tree-";
   return nsCRT::strncmp(str, moz_tree, PRInt32(sizeof(moz_tree)-1)) == 0;
 }
 #endif
 
-PRBool CSSParserImpl::ParseSelectorGroup(nsresult& aErrorCode,
-                                         nsCSSSelectorList*& aList)
+PRBool
+CSSParserImpl::ParseSelectorGroup(nsCSSSelectorList*& aList)
 {
   nsAutoPtr<nsCSSSelectorList> list;
   PRUnichar     combinator = PRUnichar(0);
   PRInt32       weight = 0;
   PRBool        havePseudoElement = PR_FALSE;
   PRBool        done = PR_FALSE;
   while (!done) {
     nsAutoPtr<nsCSSSelector> newSelector(new nsCSSSelector());
     if (!newSelector) {
-      aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
       return PR_FALSE;
     }
     nsSelectorParsingStatus parsingStatus =
-      ParseSelector(aErrorCode, *newSelector);
+      ParseSelector(*newSelector);
     if (parsingStatus == eSelectorParsingStatus_Empty) {
       if (!list) {
         REPORT_UNEXPECTED(PESelectorGroupNoSelector);
       }
       break;
     }
     if (parsingStatus == eSelectorParsingStatus_Error) {
       list = nsnull;
       break;
     }
     if (nsnull == list) {
       list = new nsCSSSelectorList();
       if (nsnull == list) {
-        aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+        mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
         return PR_FALSE;
       }
     }
     list->AddSelector(newSelector);
     nsCSSSelector* listSel = list->mSelectors;
 
     // pull out pseudo elements here
     nsPseudoClassList* prevList = nsnull;
@@ -2397,28 +2367,28 @@ PRBool CSSParserImpl::ParseSelectorGroup
         if (IsSinglePseudoClass(*listSel)) {  // convert to pseudo element selector
           nsIAtom* pseudoElement = pseudoClassList->mAtom;  // steal ref count
           pseudoClassList->mAtom = nsnull;
           listSel->Reset();
           if (listSel->mNext) {// more to the selector
             listSel->mOperator = PRUnichar('>');
             nsAutoPtr<nsCSSSelector> empty(new nsCSSSelector());
             if (!empty) {
-              aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+              mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
               return PR_FALSE;
             }
             list->AddSelector(empty); // leave a blank (universal) selector in the middle
             listSel = list->mSelectors; // use the new one for the pseudo
           }
           listSel->mTag = pseudoElement;
         }
         else {  // append new pseudo element selector
           nsAutoPtr<nsCSSSelector> pseudoTagSelector(new nsCSSSelector());
           if (!pseudoTagSelector) {
-            aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+            mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
             return PR_FALSE;
           }
           pseudoTagSelector->mTag = pseudoClassList->mAtom; // steal ref count
 #ifdef MOZ_XUL
           if (IsTreePseudoElement(pseudoTagSelector->mTag)) {
             // Take the remaining "pseudoclasses" that we parsed
             // inside the tree pseudoelement's ()-list, and
             // make our new selector have these pseudoclasses
@@ -2442,30 +2412,30 @@ PRBool CSSParserImpl::ParseSelectorGroup
         }
         break;  // only one pseudo element per selector
       }
       prevList = pseudoClassList;
       pseudoClassList = pseudoClassList->mNext;
     }
 
     combinator = PRUnichar(0);
-    if (!GetToken(aErrorCode, PR_FALSE)) {
+    if (!GetToken(PR_FALSE)) {
       break;
     }
 
     // Assume we are done unless we find a combinator here.
     done = PR_TRUE;
     if (eCSSToken_WhiteSpace == mToken.mType) {
-      if (!GetToken(aErrorCode, PR_TRUE)) {
+      if (!GetToken(PR_TRUE)) {
         break;
       }
       done = PR_FALSE;
     }
 
-    if (eCSSToken_Symbol == mToken.mType && 
+    if (eCSSToken_Symbol == mToken.mType &&
         ('+' == mToken.mSymbol ||
          '>' == mToken.mSymbol ||
          '~' == mToken.mSymbol)) {
       done = PR_FALSE;
       combinator = mToken.mSymbol;
       list->mSelectors->SetOperator(combinator);
     }
     else {
@@ -2507,35 +2477,33 @@ PRBool CSSParserImpl::ParseSelectorGroup
 #define SEL_MASK_PCLASS   0x20
 #define SEL_MASK_PELEM    0x40
 
 //
 // Parses an ID selector #name
 //
 CSSParserImpl::nsSelectorParsingStatus
 CSSParserImpl::ParseIDSelector(PRInt32&       aDataMask,
-                               nsCSSSelector& aSelector,
-                               nsresult&      aErrorCode)
+                               nsCSSSelector& aSelector)
 {
   NS_ASSERTION(!mToken.mIdent.IsEmpty(),
                "Empty mIdent in eCSSToken_ID token?");
   aDataMask |= SEL_MASK_ID;
   aSelector.AddID(mToken.mIdent);
   return eSelectorParsingStatus_Continue;
 }
 
 //
 // Parses a class selector .name
 //
 CSSParserImpl::nsSelectorParsingStatus
 CSSParserImpl::ParseClassSelector(PRInt32&       aDataMask,
-                                  nsCSSSelector& aSelector,
-                                  nsresult&      aErrorCode)
-{
-  if (! GetToken(aErrorCode, PR_FALSE)) { // get ident
+                                  nsCSSSelector& aSelector)
+{
+  if (! GetToken(PR_FALSE)) { // get ident
     REPORT_UNEXPECTED_EOF(PEClassSelEOF);
     return eSelectorParsingStatus_Error;
   }
   if (eCSSToken_Ident != mToken.mType) {  // malformed selector
     REPORT_UNEXPECTED_TOKEN(PEClassSelNotIdent);
     UngetToken();
     return eSelectorParsingStatus_Error;
   }
@@ -2548,26 +2516,25 @@ CSSParserImpl::ParseClassSelector(PRInt3
 
 //
 // Parse a type element selector or a universal selector
 // namespace|type or namespace|* or *|* or *
 //
 CSSParserImpl::nsSelectorParsingStatus
 CSSParserImpl::ParseTypeOrUniversalSelector(PRInt32&       aDataMask,
                                             nsCSSSelector& aSelector,
-                                            nsresult&      aErrorCode,
                                             PRBool         aIsNegated)
 {
   nsAutoString buffer;
   if (mToken.IsSymbol('*')) {  // universal element selector, or universal namespace
-    if (ExpectSymbol(aErrorCode, '|', PR_FALSE)) {  // was namespace
+    if (ExpectSymbol('|', PR_FALSE)) {  // was namespace
       aDataMask |= SEL_MASK_NSPACE;
       aSelector.SetNameSpace(kNameSpaceID_Unknown); // namespace wildcard
 
-      if (! GetToken(aErrorCode, PR_FALSE)) {
+      if (! GetToken(PR_FALSE)) {
         REPORT_UNEXPECTED_EOF(PETypeSelEOF);
         return eSelectorParsingStatus_Error;
       }
       if (eCSSToken_Ident == mToken.mType) {  // element name
         aDataMask |= SEL_MASK_ELEM;
         if (mCaseSensitive) {
           aSelector.SetTag(mToken.mIdent);
         }
@@ -2586,32 +2553,32 @@ CSSParserImpl::ParseTypeOrUniversalSelec
         return eSelectorParsingStatus_Error;
       }
     }
     else {  // was universal element selector
       SetDefaultNamespaceOnSelector(aSelector);
       aDataMask |= SEL_MASK_ELEM;
       // don't set any tag in the selector
     }
-    if (! GetToken(aErrorCode, PR_FALSE)) {   // premature eof is ok (here!)
+    if (! GetToken(PR_FALSE)) {   // premature eof is ok (here!)
       return eSelectorParsingStatus_Done;
     }
   }
   else if (eCSSToken_Ident == mToken.mType) {    // element name or namespace name
     buffer = mToken.mIdent; // hang on to ident
 
-    if (ExpectSymbol(aErrorCode, '|', PR_FALSE)) {  // was namespace
+    if (ExpectSymbol('|', PR_FALSE)) {  // was namespace
       aDataMask |= SEL_MASK_NSPACE;
       PRInt32 nameSpaceID;
-      if (!GetNamespaceIdForPrefix(buffer, &nameSpaceID, aErrorCode)) {
+      if (!GetNamespaceIdForPrefix(buffer, &nameSpaceID)) {
         return eSelectorParsingStatus_Error;
       }
       aSelector.SetNameSpace(nameSpaceID);
 
-      if (! GetToken(aErrorCode, PR_FALSE)) {
+      if (! GetToken(PR_FALSE)) {
         REPORT_UNEXPECTED_EOF(PETypeSelEOF);
         return eSelectorParsingStatus_Error;
       }
       if (eCSSToken_Ident == mToken.mType) {  // element name
         aDataMask |= SEL_MASK_ELEM;
         if (mCaseSensitive) {
           aSelector.SetTag(mToken.mIdent);
         }
@@ -2636,26 +2603,26 @@ CSSParserImpl::ParseTypeOrUniversalSelec
         aSelector.SetTag(buffer);
       }
       else {
         ToLowerCase(buffer);
         aSelector.SetTag(buffer);
       }
       aDataMask |= SEL_MASK_ELEM;
     }
-    if (! GetToken(aErrorCode, PR_FALSE)) {   // premature eof is ok (here!)
+    if (! GetToken(PR_FALSE)) {   // premature eof is ok (here!)
       return eSelectorParsingStatus_Done;
     }
   }
   else if (mToken.IsSymbol('|')) {  // No namespace
     aDataMask |= SEL_MASK_NSPACE;
     aSelector.SetNameSpace(kNameSpaceID_None);  // explicit NO namespace
 
     // get mandatory tag
-    if (! GetToken(aErrorCode, PR_FALSE)) {
+    if (! GetToken(PR_FALSE)) {
       REPORT_UNEXPECTED_EOF(PETypeSelEOF);
       return eSelectorParsingStatus_Error;
     }
     if (eCSSToken_Ident == mToken.mType) {  // element name
       aDataMask |= SEL_MASK_ELEM;
       if (mCaseSensitive) {
         aSelector.SetTag(mToken.mIdent);
       }
@@ -2668,17 +2635,17 @@ CSSParserImpl::ParseTypeOrUniversalSelec
       aDataMask |= SEL_MASK_ELEM;
       // don't set tag
     }
     else {
       REPORT_UNEXPECTED_TOKEN(PETypeSelNotType);
       UngetToken();
       return eSelectorParsingStatus_Error;
     }
-    if (! GetToken(aErrorCode, PR_FALSE)) {   // premature eof is ok (here!)
+    if (! GetToken(PR_FALSE)) {   // premature eof is ok (here!)
       return eSelectorParsingStatus_Done;
     }
   }
   else {
     SetDefaultNamespaceOnSelector(aSelector);
   }
 
   if (aIsNegated) {
@@ -2689,30 +2656,29 @@ CSSParserImpl::ParseTypeOrUniversalSelec
 }
 
 //
 // Parse attribute selectors [attr], [attr=value], [attr|=value],
 // [attr~=value], [attr^=value], [attr$=value] and [attr*=value]
 //
 CSSParserImpl::nsSelectorParsingStatus
 CSSParserImpl::ParseAttributeSelector(PRInt32&       aDataMask,
-                                      nsCSSSelector& aSelector,
-                                      nsresult&      aErrorCode)
-{
-  if (! GetToken(aErrorCode, PR_TRUE)) { // premature EOF
+                                      nsCSSSelector& aSelector)
+{
+  if (! GetToken(PR_TRUE)) { // premature EOF
     REPORT_UNEXPECTED_EOF(PEAttributeNameEOF);
     return eSelectorParsingStatus_Error;
   }
 
   PRInt32 nameSpaceID = kNameSpaceID_None;
   nsAutoString  attr;
   if (mToken.IsSymbol('*')) { // wildcard namespace
     nameSpaceID = kNameSpaceID_Unknown;
-    if (ExpectSymbol(aErrorCode, '|', PR_FALSE)) {
-      if (! GetToken(aErrorCode, PR_FALSE)) { // premature EOF
+    if (ExpectSymbol('|', PR_FALSE)) {
+      if (! GetToken(PR_FALSE)) { // premature EOF
         REPORT_UNEXPECTED_EOF(PEAttributeNameEOF);
         return eSelectorParsingStatus_Error;
       }
       if (eCSSToken_Ident == mToken.mType) { // attr name
         attr = mToken.mIdent;
       }
       else {
         REPORT_UNEXPECTED_TOKEN(PEAttributeNameExpected);
@@ -2721,36 +2687,36 @@ CSSParserImpl::ParseAttributeSelector(PR
        }
     }
     else {
       REPORT_UNEXPECTED_TOKEN(PEAttSelNoBar);
       return eSelectorParsingStatus_Error;
     }
   }
   else if (mToken.IsSymbol('|')) { // NO namespace
-    if (! GetToken(aErrorCode, PR_FALSE)) { // premature EOF
+    if (! GetToken(PR_FALSE)) { // premature EOF
       REPORT_UNEXPECTED_EOF(PEAttributeNameEOF);
       return eSelectorParsingStatus_Error;
     }
     if (eCSSToken_Ident == mToken.mType) { // attr name
       attr = mToken.mIdent;
     }
     else {
       REPORT_UNEXPECTED_TOKEN(PEAttributeNameExpected);
       UngetToken();
       return eSelectorParsingStatus_Error;
     }
   }
   else if (eCSSToken_Ident == mToken.mType) { // attr name or namespace
     attr = mToken.mIdent; // hang on to it
-    if (ExpectSymbol(aErrorCode, '|', PR_FALSE)) {  // was a namespace
-      if (!GetNamespaceIdForPrefix(attr, &nameSpaceID, aErrorCode)) {
-        return eSelectorParsingStatus_Error;
-      }
-      if (! GetToken(aErrorCode, PR_FALSE)) { // premature EOF
+    if (ExpectSymbol('|', PR_FALSE)) {  // was a namespace
+      if (!GetNamespaceIdForPrefix(attr, &nameSpaceID)) {
+        return eSelectorParsingStatus_Error;
+      }
+      if (! GetToken(PR_FALSE)) { // premature EOF
         REPORT_UNEXPECTED_EOF(PEAttributeNameEOF);
         return eSelectorParsingStatus_Error;
       }
       if (eCSSToken_Ident == mToken.mType) { // attr name
         attr = mToken.mIdent;
       }
       else {
         REPORT_UNEXPECTED_TOKEN(PEAttributeNameExpected);
@@ -2763,17 +2729,17 @@ CSSParserImpl::ParseAttributeSelector(PR
     REPORT_UNEXPECTED_TOKEN(PEAttributeNameOrNamespaceExpected);
     UngetToken();
     return eSelectorParsingStatus_Error;
   }
 
   if (! mCaseSensitive) {
     ToLowerCase(attr);
   }
-  if (! GetToken(aErrorCode, PR_TRUE)) { // premature EOF
+  if (! GetToken(PR_TRUE)) { // premature EOF
     REPORT_UNEXPECTED_EOF(PEAttSelInnerEOF);
     return eSelectorParsingStatus_Error;
   }
   if ((eCSSToken_Symbol == mToken.mType) ||
       (eCSSToken_Includes == mToken.mType) ||
       (eCSSToken_Dashmatch == mToken.mType) ||
       (eCSSToken_Beginsmatch == mToken.mType) ||
       (eCSSToken_Endsmatch == mToken.mType) ||
@@ -2803,80 +2769,80 @@ CSSParserImpl::ParseAttributeSelector(PR
       func = NS_ATTR_FUNC_EQUALS;
     }
     else {
       REPORT_UNEXPECTED_TOKEN(PEAttSelUnexpected);
       UngetToken(); // bad function
       return eSelectorParsingStatus_Error;
     }
     if (NS_ATTR_FUNC_SET != func) { // get value
-      if (! GetToken(aErrorCode, PR_TRUE)) { // premature EOF
+      if (! GetToken(PR_TRUE)) { // premature EOF
         REPORT_UNEXPECTED_EOF(PEAttSelValueEOF);
         return eSelectorParsingStatus_Error;
       }
       if ((eCSSToken_Ident == mToken.mType) || (eCSSToken_String == mToken.mType)) {
         nsAutoString  value(mToken.mIdent);
-        if (! GetToken(aErrorCode, PR_TRUE)) { // premature EOF
+        if (! GetToken(PR_TRUE)) { // premature EOF
           REPORT_UNEXPECTED_EOF(PEAttSelCloseEOF);
           return eSelectorParsingStatus_Error;
         }
         if (mToken.IsSymbol(']')) {
           PRBool isCaseSensitive = PR_TRUE;
 
           // If we're parsing a style sheet for an HTML document, and
           // the attribute selector is for a non-namespaced attribute,
           // then check to see if it's one of the known attributes whose
           // VALUE is case-insensitive.
           if (!mCaseSensitive && nameSpaceID == kNameSpaceID_None) {
             static const char* caseInsensitiveHTMLAttribute[] = {
               // list based on http://www.w3.org/TR/html4/
-              "lang", 
-              "dir", 
-              "http-equiv", 
-              "text", 
-              "link", 
-              "vlink", 
-              "alink", 
-              "compact", 
-              "align", 
-              "frame", 
+              "lang",
+              "dir",
+              "http-equiv",
+              "text",
+              "link",
+              "vlink",
+              "alink",
+              "compact",
+              "align",
+              "frame",
               "rules",
-              "valign", 
-              "scope", 
-              "axis", 
-              "nowrap", 
-              "hreflang", 
-              "rel", 
-              "rev", 
-              "charset", 
-              "codetype", 
+              "valign",
+              "scope",
+              "axis",
+              "nowrap",
+              "hreflang",
+              "rel",
+              "rev",
+              "charset",
+              "codetype",
               "declare",
-              "valuetype", 
-              "shape", 
-              "nohref", 
-              "media", 
-              "bgcolor", 
-              "clear", 
-              "color", 
-              "face", 
+              "valuetype",
+              "shape",
+              "nohref",
+              "media",
+              "bgcolor",
+              "clear",
+              "color",
+              "face",
               "noshade",
-              "noresize", 
-              "scrolling", 
-              "target", 
-              "method", 
-              "enctype", 
-              "accept-charset", 
-              "accept", 
+              "noresize",
+              "scrolling",
+              "target",
+              "method",
+              "enctype",
+              "accept-charset",
+              "accept",
               "checked",
-              "multiple", 
-              "selected", 
-              "disabled", 
-              "readonly", 
-              "language", 
-              "defer", 
+              "multiple",
+              "selected",
+              "disabled",
+              "readonly",
+              "language",
+              "defer",
               "type",
               // additional attributes not in HTML4
               "direction", // marquee
               nsnull
             };
             short i = 0;
             const char* htmlAttr;
             while ((htmlAttr = caseInsensitiveHTMLAttribute[i++])) {
@@ -2911,29 +2877,28 @@ CSSParserImpl::ParseAttributeSelector(PR
 }
 
 //
 // Parse pseudo-classes and pseudo-elements
 //
 CSSParserImpl::nsSelectorParsingStatus
 CSSParserImpl::ParsePseudoSelector(PRInt32&       aDataMask,
                                    nsCSSSelector& aSelector,
-                                   nsresult&      aErrorCode,
                                    PRBool         aIsNegated)
 {
-  if (! GetToken(aErrorCode, PR_FALSE)) { // premature eof
+  if (! GetToken(PR_FALSE)) { // premature eof
     REPORT_UNEXPECTED_EOF(PEPseudoSelEOF);
     return eSelectorParsingStatus_Error;
   }
 
   // First, find out whether we are parsing a CSS3 pseudo-element
   PRBool parsingPseudoElement = PR_FALSE;
   if (mToken.IsSymbol(':')) {
     parsingPseudoElement = PR_TRUE;
-    if (! GetToken(aErrorCode, PR_FALSE)) { // premature eof
+    if (! GetToken(PR_FALSE)) { // premature eof
       REPORT_UNEXPECTED_EOF(PEPseudoSelEOF);
       return eSelectorParsingStatus_Error;
     }
   }
 
   // Do some sanity-checking on the token
   if (eCSSToken_Ident != mToken.mType && eCSSToken_Function != mToken.mType) {
     // malformed selector
@@ -2987,17 +2952,17 @@ CSSParserImpl::ParsePseudoSelector(PRInt
        nsCSSPseudoClasses::notPseudo == pseudo ||
        nsCSSPseudoClasses::HasStringArg(pseudo) ||
        nsCSSPseudoClasses::HasNthPairArg(pseudo))) {
     // There are no other function pseudos
     REPORT_UNEXPECTED_TOKEN(PEPseudoSelNonFunc);
     UngetToken();
     return eSelectorParsingStatus_Error;
   }
-  
+
   // If it starts with "::", it better be a pseudo-element
   if (parsingPseudoElement &&
       !isPseudoElement &&
       !isAnonBox) {
     REPORT_UNEXPECTED_TOKEN(PEPseudoSelNotPE);
     UngetToken();
     return eSelectorParsingStatus_Error;
   }
@@ -3005,44 +2970,44 @@ CSSParserImpl::ParsePseudoSelector(PRInt
   if (!parsingPseudoElement && nsCSSPseudoClasses::notPseudo == pseudo) {
     if (aIsNegated) { // :not() can't be itself negated
       REPORT_UNEXPECTED_TOKEN(PEPseudoSelDoubleNot);
       UngetToken();
       return eSelectorParsingStatus_Error;
     }
     // CSS 3 Negation pseudo-class takes one simple selector as argument
     nsSelectorParsingStatus parsingStatus =
-      ParseNegatedSimpleSelector(aDataMask, aSelector, aErrorCode);
+      ParseNegatedSimpleSelector(aDataMask, aSelector);
     if (eSelectorParsingStatus_Continue != parsingStatus) {
       return parsingStatus;
     }
-  }    
+  }
   else if (!parsingPseudoElement && isPseudoClass) {
     aDataMask |= SEL_MASK_PCLASS;
     if (nsCSSPseudoClasses::HasStringArg(pseudo)) {
       nsSelectorParsingStatus parsingStatus =
-        ParsePseudoClassWithIdentArg(aSelector, pseudo, aErrorCode);
+        ParsePseudoClassWithIdentArg(aSelector, pseudo);
       if (eSelectorParsingStatus_Continue != parsingStatus) {
         return parsingStatus;
       }
     }
     else if (nsCSSPseudoClasses::HasNthPairArg(pseudo)) {
       nsSelectorParsingStatus parsingStatus =
-        ParsePseudoClassWithNthPairArg(aSelector, pseudo, aErrorCode);
+        ParsePseudoClassWithNthPairArg(aSelector, pseudo);
       if (eSelectorParsingStatus_Continue != parsingStatus) {
         return parsingStatus;
       }
     }
     else {
       aSelector.AddPseudoClass(pseudo);
     }
   }
   else if (isPseudoElement || isAnonBox) {
     // Pseudo-element.  Make some more sanity checks.
-    
+
     if (aIsNegated) { // pseudo-elements can't be negated
       REPORT_UNEXPECTED_TOKEN(PEPseudoSelPEInNot);
       UngetToken();
       return eSelectorParsingStatus_Error;
     }
     // CSS2 pseudo-elements and -moz-tree-* pseudo-elements are allowed
     // to have a single ':' on them.  Others (CSS3+ pseudo-elements and
     // various -moz-* pseudo-elements) must have |parsingPseudoElement|
@@ -3063,25 +3028,25 @@ CSSParserImpl::ParsePseudoSelector(PRInt
       aSelector.AddPseudoClass(pseudo); // store it here, it gets pulled later
 
 #ifdef MOZ_XUL
       if (isTree) {
         // We have encountered a pseudoelement of the form
         // -moz-tree-xxxx(a,b,c).  We parse (a,b,c) and add each
         // item in the list to the pseudoclass list.  They will be pulled
         // from the list later along with the pseudo-element.
-        if (!ParseTreePseudoElement(aErrorCode, aSelector)) {
+        if (!ParseTreePseudoElement(aSelector)) {
           return eSelectorParsingStatus_Error;
         }
       }
 #endif
 
       // ensure selector ends here, must be followed by EOF, space, '{' or ','
-      if (GetToken(aErrorCode, PR_FALSE)) { // premature eof is ok (here!)
-        if ((eCSSToken_WhiteSpace == mToken.mType) || 
+      if (GetToken(PR_FALSE)) { // premature eof is ok (here!)
+        if ((eCSSToken_WhiteSpace == mToken.mType) ||
             (mToken.IsSymbol('{') || mToken.IsSymbol(','))) {
           UngetToken();
           return eSelectorParsingStatus_Done;
         }
         REPORT_UNEXPECTED_TOKEN(PEPseudoSelTrailing);
         UngetToken();
         return eSelectorParsingStatus_Error;
       }
@@ -3107,134 +3072,131 @@ CSSParserImpl::ParsePseudoSelector(PRInt
   return eSelectorParsingStatus_Continue;
 }
 
 //
 // Parse the argument of a negation pseudo-class :not()
 //
 CSSParserImpl::nsSelectorParsingStatus
 CSSParserImpl::ParseNegatedSimpleSelector(PRInt32&       aDataMask,
-                                          nsCSSSelector& aSelector,
-                                          nsresult&      aErrorCode)
+                                          nsCSSSelector& aSelector)
 {
   // Check if we have the first parenthesis
-  if (!ExpectSymbol(aErrorCode, '(', PR_FALSE)) {
+  if (!ExpectSymbol('(', PR_FALSE)) {
     REPORT_UNEXPECTED_TOKEN(PENegationBadArg);
     return eSelectorParsingStatus_Error;
   }
 
-  if (! GetToken(aErrorCode, PR_TRUE)) { // premature eof
+  if (! GetToken(PR_TRUE)) { // premature eof
     REPORT_UNEXPECTED_EOF(PENegationEOF);
     return eSelectorParsingStatus_Error;
   }
 
   // Create a new nsCSSSelector and add it to the end of
   // aSelector.mNegations.
   // Given the current parsing rules, every selector in mNegations
   // contains only one simple selector (css3 definition) within it.
   // This could easily change in future versions of CSS, and the only
   // thing we need to change to support that is this parsing code.
   nsCSSSelector *newSel = new nsCSSSelector();
   if (!newSel) {
-    aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+    mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
     return eSelectorParsingStatus_Error;
   }
   nsCSSSelector* negations = &aSelector;
   while (negations->mNegations) {
     negations = negations->mNegations;
   }
   negations->mNegations = newSel;
 
   nsSelectorParsingStatus parsingStatus;
   if (eCSSToken_ID == mToken.mType) { // #id
-    parsingStatus = ParseIDSelector(aDataMask, *newSel, aErrorCode);
+    parsingStatus = ParseIDSelector(aDataMask, *newSel);
   }
   else if (mToken.IsSymbol('.')) {    // .class
-    parsingStatus = ParseClassSelector(aDataMask, *newSel, aErrorCode);
+    parsingStatus = ParseClassSelector(aDataMask, *newSel);
   }
   else if (mToken.IsSymbol(':')) {    // :pseudo
-    parsingStatus = ParsePseudoSelector(aDataMask, *newSel, aErrorCode, PR_TRUE);
+    parsingStatus = ParsePseudoSelector(aDataMask, *newSel, PR_TRUE);
   }
   else if (mToken.IsSymbol('[')) {    // [attribute
-    parsingStatus = ParseAttributeSelector(aDataMask, *newSel, aErrorCode);
+    parsingStatus = ParseAttributeSelector(aDataMask, *newSel);
   }
   else {
     // then it should be a type element or universal selector
-    parsingStatus = ParseTypeOrUniversalSelector(aDataMask, *newSel, aErrorCode, PR_TRUE);
+    parsingStatus = ParseTypeOrUniversalSelector(aDataMask, *newSel, PR_TRUE);
   }
   if (eSelectorParsingStatus_Error == parsingStatus) {
     REPORT_UNEXPECTED_TOKEN(PENegationBadInner);
     return parsingStatus;
   }
   // close the parenthesis
-  if (!ExpectSymbol(aErrorCode, ')', PR_TRUE)) {
+  if (!ExpectSymbol(')', PR_TRUE)) {
     REPORT_UNEXPECTED_TOKEN(PENegationNoClose);
     return eSelectorParsingStatus_Error;
   }
 
   return eSelectorParsingStatus_Continue;
 }
 
 //
 // Parse the argument of a pseudo-class that has an ident arg
 //
 CSSParserImpl::nsSelectorParsingStatus
 CSSParserImpl::ParsePseudoClassWithIdentArg(nsCSSSelector& aSelector,
-                                            nsIAtom*       aPseudo,
-                                            nsresult&      aErrorCode)
+                                            nsIAtom*       aPseudo)
 {
   // Check if we have the first parenthesis
-  if (!ExpectSymbol(aErrorCode, '(', PR_FALSE)) {
+  if (!ExpectSymbol('(', PR_FALSE)) {
     REPORT_UNEXPECTED_TOKEN(PEPseudoClassNoArg);
     return eSelectorParsingStatus_Error;
   }
 
-  if (! GetToken(aErrorCode, PR_TRUE)) { // premature eof
+  if (! GetToken(PR_TRUE)) { // premature eof
     REPORT_UNEXPECTED_EOF(PEPseudoClassArgEOF);
     return eSelectorParsingStatus_Error;
   }
   // We expect an identifier with a language abbreviation
   if (eCSSToken_Ident != mToken.mType) {
     REPORT_UNEXPECTED_TOKEN(PEPseudoClassArgNotIdent);
     UngetToken();
     // XXX Call SkipUntil to the next ")"?
     return eSelectorParsingStatus_Error;
   }
 
   // Add the pseudo with the language parameter
   aSelector.AddPseudoClass(aPseudo, mToken.mIdent.get());
 
   // close the parenthesis
-  if (!ExpectSymbol(aErrorCode, ')', PR_TRUE)) {
+  if (!ExpectSymbol(')', PR_TRUE)) {
     REPORT_UNEXPECTED_TOKEN(PEPseudoClassNoClose);
     // XXX Call SkipUntil to the next ")"?
     return eSelectorParsingStatus_Error;
   }
 
   return eSelectorParsingStatus_Continue;
 }
 
 CSSParserImpl::nsSelectorParsingStatus
 CSSParserImpl::ParsePseudoClassWithNthPairArg(nsCSSSelector& aSelector,
-                                              nsIAtom*       aPseudo,
-                                              nsresult&      aErrorCode)
+                                              nsIAtom*       aPseudo)
 {
   PRInt32 numbers[2] = { 0, 0 };
   PRBool lookForB = PR_TRUE;
-  
+
   // Check whether we have the first parenthesis
-  if (!ExpectSymbol(aErrorCode, '(', PR_FALSE)) {
+  if (!ExpectSymbol('(', PR_FALSE)) {
     REPORT_UNEXPECTED_TOKEN(PEPseudoClassNoArg);
     return eSelectorParsingStatus_Error;
   }
 
   // Follow the whitespace rules as proposed in
   // http://lists.w3.org/Archives/Public/www-style/2008Mar/0121.html
 
-  if (! GetToken(aErrorCode, PR_TRUE)) {
+  if (! GetToken(PR_TRUE)) {
     REPORT_UNEXPECTED_EOF(PEPseudoClassArgEOF);
     return eSelectorParsingStatus_Error;
   }
 
   if (eCSSToken_Ident == mToken.mType || eCSSToken_Dimension == mToken.mType) {
     // The CSS tokenization doesn't handle :nth-child() containing - well:
     //   2n-1 is a dimension
     //   n-1 is an identifier
@@ -3248,17 +3210,17 @@ CSSParserImpl::ParsePseudoClassWithNthPa
     }
     if (truncAt != 0) {
       for (PRUint32 i = mToken.mIdent.Length() - 1; i >= truncAt; --i) {
         mScanner.Pushback(mToken.mIdent[i]);
       }
       mToken.mIdent.Truncate(truncAt);
     }
   }
-  
+
   if (eCSSToken_Ident == mToken.mType) {
     if (mToken.mIdent.EqualsIgnoreCase("odd")) {
       numbers[0] = 2;
       numbers[1] = 1;
       lookForB = PR_FALSE;
     }
     else if (mToken.mIdent.EqualsIgnoreCase("even")) {
       numbers[0] = 2;
@@ -3296,44 +3258,44 @@ CSSParserImpl::ParsePseudoClassWithNthPa
   }
   // XXX If it's a ')', is that valid?  (as 0n+0)
   else {
     REPORT_UNEXPECTED_TOKEN(PEPseudoClassArgNotNth);
     // XXX Call SkipUntil to the next ")" (unless this is one already)?
     return eSelectorParsingStatus_Error;
   }
 
-  if (! GetToken(aErrorCode, PR_TRUE)) {
+  if (! GetToken(PR_TRUE)) {
     REPORT_UNEXPECTED_EOF(PEPseudoClassArgEOF);
     return eSelectorParsingStatus_Error;
   }
   if (lookForB && !mToken.IsSymbol(')')) {
     // The '+' or '-' sign can optionally be separated by whitespace.
     // If it is separated by whitespace from what follows it, it appears
     // as a separate token rather than part of the number token.
     PRBool haveSign = PR_FALSE;
     PRInt32 sign = 1;
     if (mToken.IsSymbol('+') || mToken.IsSymbol('-')) {
       haveSign = PR_TRUE;
       if (mToken.IsSymbol('-')) {
         sign = -1;
       }
-      if (! GetToken(aErrorCode, PR_TRUE)) {
+      if (! GetToken(PR_TRUE)) {
         REPORT_UNEXPECTED_EOF(PEPseudoClassArgEOF);
         return eSelectorParsingStatus_Error;
       }
     }
     if (eCSSToken_Number != mToken.mType ||
         !mToken.mIntegerValid || mToken.mHasSign == haveSign) {
       REPORT_UNEXPECTED_TOKEN(PEPseudoClassArgNotNth);
       // XXX Call SkipUntil to the next ")"?
       return eSelectorParsingStatus_Error;
     }
     numbers[1] = mToken.mInteger * sign;
-    if (! GetToken(aErrorCode, PR_TRUE)) {
+    if (! GetToken(PR_TRUE)) {
       REPORT_UNEXPECTED_EOF(PEPseudoClassArgEOF);
       return eSelectorParsingStatus_Error;
     }
   }
   if (!mToken.IsSymbol(')')) {
     REPORT_UNEXPECTED_TOKEN(PEPseudoClassNoClose);
     // XXX Call SkipUntil to the next ")"?
     return eSelectorParsingStatus_Error;
@@ -3343,83 +3305,82 @@ CSSParserImpl::ParsePseudoClassWithNthPa
 }
 
 
 /**
  * This is the format for selectors:
  * operator? [[namespace |]? element_name]? [ ID | class | attrib | pseudo ]*
  */
 CSSParserImpl::nsSelectorParsingStatus
-CSSParserImpl::ParseSelector(nsresult& aErrorCode, nsCSSSelector& aSelector)
-{
-  if (! GetToken(aErrorCode, PR_TRUE)) {
+CSSParserImpl::ParseSelector(nsCSSSelector& aSelector)
+{
+  if (! GetToken(PR_TRUE)) {
     REPORT_UNEXPECTED_EOF(PESelectorEOF);
     return eSelectorParsingStatus_Error;
   }
 
   PRInt32 dataMask = 0;
   nsSelectorParsingStatus parsingStatus =
-    ParseTypeOrUniversalSelector(dataMask, aSelector, aErrorCode, PR_FALSE);
+    ParseTypeOrUniversalSelector(dataMask, aSelector, PR_FALSE);
   if (parsingStatus != eSelectorParsingStatus_Continue) {
     return parsingStatus;
   }
 
   for (;;) {
     if (eCSSToken_ID == mToken.mType) { // #id
-      parsingStatus = ParseIDSelector(dataMask, aSelector, aErrorCode);
+      parsingStatus = ParseIDSelector(dataMask, aSelector);
     }
     else if (mToken.IsSymbol('.')) {    // .class
-      parsingStatus = ParseClassSelector(dataMask, aSelector, aErrorCode);
+      parsingStatus = ParseClassSelector(dataMask, aSelector);
     }
     else if (mToken.IsSymbol(':')) {    // :pseudo
-      parsingStatus = ParsePseudoSelector(dataMask, aSelector, aErrorCode, PR_FALSE);
+      parsingStatus = ParsePseudoSelector(dataMask, aSelector, PR_FALSE);
     }
     else if (mToken.IsSymbol('[')) {    // [attribute
-      parsingStatus = ParseAttributeSelector(dataMask, aSelector, aErrorCode);
+      parsingStatus = ParseAttributeSelector(dataMask, aSelector);
     }
     else {  // not a selector token, we're done
       parsingStatus = eSelectorParsingStatus_Done;
       break;
     }
 
     if (parsingStatus != eSelectorParsingStatus_Continue) {
       return parsingStatus;
     }
 
-    if (! GetToken(aErrorCode, PR_FALSE)) { // premature eof is ok (here!)
+    if (! GetToken(PR_FALSE)) { // premature eof is ok (here!)
       return eSelectorParsingStatus_Done;
     }
   }
   UngetToken();
   return dataMask ? parsingStatus : eSelectorParsingStatus_Empty;
 }
 
 nsCSSDeclaration*
-CSSParserImpl::ParseDeclarationBlock(nsresult& aErrorCode,
-                                     PRBool aCheckForBraces)
+CSSParserImpl::ParseDeclarationBlock(PRBool aCheckForBraces)
 {
   if (aCheckForBraces) {
-    if (!ExpectSymbol(aErrorCode, '{', PR_TRUE)) {
+    if (!ExpectSymbol('{', PR_TRUE)) {
       REPORT_UNEXPECTED_TOKEN(PEBadDeclBlockStart);
       OUTPUT_ERROR();
       return nsnull;
     }
   }
   nsCSSDeclaration* declaration = new nsCSSDeclaration();
   mData.AssertInitialState();
   if (declaration) {
     for (;;) {
       PRBool changed;
-      if (!ParseDeclaration(aErrorCode, declaration, aCheckForBraces,
+      if (!ParseDeclaration(declaration, aCheckForBraces,
                             PR_TRUE, &changed)) {
-        if (!SkipDeclaration(aErrorCode, aCheckForBraces)) {
+        if (!SkipDeclaration(aCheckForBraces)) {
           break;
         }
         if (aCheckForBraces) {
-          if (ExpectSymbol(aErrorCode, '}', PR_TRUE)) {
+          if (ExpectSymbol('}', PR_TRUE)) {
             break;
           }
         }
         // Since the skipped declaration didn't end the block we parse
         // the next declaration.
       }
     }
     declaration->CompressFrom(&mData);
@@ -3428,19 +3389,20 @@ CSSParserImpl::ParseDeclarationBlock(nsr
 }
 
 // The types to pass to ParseColorComponent.  These correspond to the
 // various datatypes that can go within rgb().
 #define COLOR_TYPE_UNKNOWN 0
 #define COLOR_TYPE_INTEGERS 1
 #define COLOR_TYPE_PERCENTAGES 2
 
-PRBool CSSParserImpl::ParseColor(nsresult& aErrorCode, nsCSSValue& aValue)
-{
-  if (!GetToken(aErrorCode, PR_TRUE)) {
+PRBool
+CSSParserImpl::ParseColor(nsCSSValue& aValue)
+{
+  if (!GetToken(PR_TRUE)) {
     REPORT_UNEXPECTED_EOF(PEColorEOF);
     return PR_FALSE;
   }
 
   nsCSSToken* tk = &mToken;
   nscolor rgba;
   switch (tk->mType) {
     case eCSSToken_ID:
@@ -3476,57 +3438,57 @@ PRBool CSSParserImpl::ParseColor(nsresul
         }
       }
       break;
     case eCSSToken_Function:
       if (mToken.mIdent.LowerCaseEqualsLiteral("rgb")) {
         // rgb ( component , component , component )
         PRUint8 r, g, b;
         PRInt32 type = COLOR_TYPE_UNKNOWN;
-        if (ExpectSymbol(aErrorCode, '(', PR_FALSE) && // this won't fail
-            ParseColorComponent(aErrorCode, r, type, ',') &&
-            ParseColorComponent(aErrorCode, g, type, ',') &&
-            ParseColorComponent(aErrorCode, b, type, ')')) {
+        if (ExpectSymbol('(', PR_FALSE) && // this won't fail
+            ParseColorComponent(r, type, ',') &&
+            ParseColorComponent(g, type, ',') &&
+            ParseColorComponent(b, type, ')')) {
           aValue.SetColorValue(NS_RGB(r,g,b));
           return PR_TRUE;
         }
         return PR_FALSE;  // already pushed back
       }
       else if (mToken.mIdent.LowerCaseEqualsLiteral("-moz-rgba") ||
                mToken.mIdent.LowerCaseEqualsLiteral("rgba")) {
         // rgba ( component , component , component , opacity )
         PRUint8 r, g, b, a;
         PRInt32 type = COLOR_TYPE_UNKNOWN;
-        if (ExpectSymbol(aErrorCode, '(', PR_FALSE) && // this won't fail
-            ParseColorComponent(aErrorCode, r, type, ',') &&
-            ParseColorComponent(aErrorCode, g, type, ',') &&
-            ParseColorComponent(aErrorCode, b, type, ',') &&
-            ParseColorOpacity(aErrorCode, a)) {
+        if (ExpectSymbol('(', PR_FALSE) && // this won't fail
+            ParseColorComponent(r, type, ',') &&
+            ParseColorComponent(g, type, ',') &&
+            ParseColorComponent(b, type, ',') &&
+            ParseColorOpacity(a)) {
           aValue.SetColorValue(NS_RGBA(r, g, b, a));
           return PR_TRUE;
         }
         return PR_FALSE;  // already pushed back
       }
       else if (mToken.mIdent.LowerCaseEqualsLiteral("hsl")) {
         // hsl ( hue , saturation , lightness )
         // "hue" is a number, "saturation" and "lightness" are percentages.
-        if (ParseHSLColor(aErrorCode, rgba, ')')) {
+        if (ParseHSLColor(rgba, ')')) {
           aValue.SetColorValue(rgba);
           return PR_TRUE;
         }
         return PR_FALSE;
       }
       else if (mToken.mIdent.LowerCaseEqualsLiteral("-moz-hsla") ||
                mToken.mIdent.LowerCaseEqualsLiteral("hsla")) {
         // hsla ( hue , saturation , lightness , opacity )
         // "hue" is a number, "saturation" and "lightness" are percentages,
         // "opacity" is a number.
         PRUint8 a;
-        if (ParseHSLColor(aErrorCode, rgba, ',') &&
-            ParseColorOpacity(aErrorCode, a)) {
+        if (ParseHSLColor(rgba, ',') &&
+            ParseColorOpacity(a)) {
           aValue.SetColorValue(NS_RGBA(NS_GET_R(rgba), NS_GET_G(rgba),
                                        NS_GET_B(rgba), a));
           return PR_TRUE;
         }
         return PR_FALSE;
       }
       break;
     default:
@@ -3585,22 +3547,22 @@ PRBool CSSParserImpl::ParseColor(nsresul
   // It's not a color
   REPORT_UNEXPECTED_TOKEN(PEColorNotColor);
   UngetToken();
   return PR_FALSE;
 }
 
 // aType will be set if we have already parsed other color components
 // in this color spec
-PRBool CSSParserImpl::ParseColorComponent(nsresult& aErrorCode,
-                                          PRUint8& aComponent,
-                                          PRInt32& aType,
-                                          char aStop)
-{
-  if (!GetToken(aErrorCode, PR_TRUE)) {
+PRBool
+CSSParserImpl::ParseColorComponent(PRUint8& aComponent,
+                                   PRInt32& aType,
+                                   char aStop)
+{
+  if (!GetToken(PR_TRUE)) {
     REPORT_UNEXPECTED_EOF(PEColorComponentEOF);
     return PR_FALSE;
   }
   float value;
   nsCSSToken* tk = &mToken;
   switch (tk->mType) {
   case eCSSToken_Number:
     switch (aType) {
@@ -3640,112 +3602,114 @@ PRBool CSSParserImpl::ParseColorComponen
     }
     value = tk->mNumber * 255.0f;
     break;
   default:
     REPORT_UNEXPECTED_TOKEN(PEColorBadRGBContents);
     UngetToken();
     return PR_FALSE;
   }
-  if (ExpectSymbol(aErrorCode, aStop, PR_TRUE)) {
+  if (ExpectSymbol(aStop, PR_TRUE)) {
     if (value < 0.0f) value = 0.0f;
     if (value > 255.0f) value = 255.0f;
     aComponent = NSToIntRound(value);
     return PR_TRUE;
   }
   const PRUnichar stopString[] = { PRUnichar(aStop), PRUnichar(0) };
   const PRUnichar *params[] = {
     nsnull,
     stopString
   };
   REPORT_UNEXPECTED_TOKEN_P(PEColorComponentBadTerm, params);
   return PR_FALSE;
 }
 
 
-PRBool CSSParserImpl::ParseHSLColor(nsresult& aErrorCode, nscolor& aColor,
-                                    char aStop)
+PRBool
+CSSParserImpl::ParseHSLColor(nscolor& aColor,
+                             char aStop)
 {
   float h, s, l;
-  if (!ExpectSymbol(aErrorCode, '(', PR_FALSE)) {
+  if (!ExpectSymbol('(', PR_FALSE)) {
     NS_ERROR("How did this get to be a function token?");
     return PR_FALSE;
   }
 
   // Get the hue
-  if (!GetToken(aErrorCode, PR_TRUE)) {
+  if (!GetToken(PR_TRUE)) {
     REPORT_UNEXPECTED_EOF(PEColorHueEOF);
     return PR_FALSE;
   }
   if (mToken.mType != eCSSToken_Number) {
     REPORT_UNEXPECTED_TOKEN(PEExpectedNumber);
     UngetToken();
     return PR_FALSE;
   }
   h = mToken.mNumber;
   h /= 360.0f;
   // hue values are wraparound
   h = h - floor(h);
-  
-  if (!ExpectSymbol(aErrorCode, ',', PR_TRUE)) {
+
+  if (!ExpectSymbol(',', PR_TRUE)) {
     REPORT_UNEXPECTED_TOKEN(PEExpectedComma);
     return PR_FALSE;
   }
-  
+
   // Get the saturation
-  if (!GetToken(aErrorCode, PR_TRUE)) {
+  if (!GetToken(PR_TRUE)) {
     REPORT_UNEXPECTED_EOF(PEColorSaturationEOF);
     return PR_FALSE;
   }
   if (mToken.mType != eCSSToken_Percentage) {
     REPORT_UNEXPECTED_TOKEN(PEExpectedPercent);
     UngetToken();
     return PR_FALSE;
   }
   s = mToken.mNumber;
   if (s < 0.0f) s = 0.0f;
   if (s > 1.0f) s = 1.0f;
-  
-  if (!ExpectSymbol(aErrorCode, ',', PR_TRUE)) {
+
+  if (!ExpectSymbol(',', PR_TRUE)) {
     REPORT_UNEXPECTED_TOKEN(PEExpectedComma);
     return PR_FALSE;
   }
 
   // Get the lightness
-  if (!GetToken(aErrorCode, PR_TRUE)) {
+  if (!GetToken(PR_TRUE)) {
     REPORT_UNEXPECTED_EOF(PEColorLightnessEOF);
     return PR_FALSE;
   }
   if (mToken.mType != eCSSToken_Percentage) {
     REPORT_UNEXPECTED_TOKEN(PEExpectedPercent);
     UngetToken();
     return PR_FALSE;
   }
   l = mToken.mNumber;
   if (l < 0.0f) l = 0.0f;
   if (l > 1.0f) l = 1.0f;
-        
-  if (ExpectSymbol(aErrorCode, aStop, PR_TRUE)) {
+
+  if (ExpectSymbol(aStop, PR_TRUE)) {
     aColor = NS_HSL2RGB(h, s, l);
     return PR_TRUE;
   }
-  
+
   const PRUnichar stopString[] = { PRUnichar(aStop), PRUnichar(0) };
   const PRUnichar *params[] = {
     nsnull,
     stopString
   };
   REPORT_UNEXPECTED_TOKEN_P(PEColorComponentBadTerm, params);
   return PR_FALSE;
 }
- 
- 
-PRBool CSSParserImpl::ParseColorOpacity(nsresult& aErrorCode, PRUint8& aOpacity)
-{
-  if (!GetToken(aErrorCode, PR_TRUE)) {
+
+
+PRBool
+CSSParserImpl::ParseColorOpacity(PRUint8& aOpacity)
+{
+  if (!GetToken(PR_TRUE)) {
     REPORT_UNEXPECTED_EOF(PEColorOpacityEOF);
     return PR_FALSE;
   }
 
   if (mToken.mType != eCSSToken_Number) {
     REPORT_UNEXPECTED_TOKEN(PEExpectedNumber);
     UngetToken();
     return PR_FALSE;
@@ -3756,76 +3720,75 @@ PRBool CSSParserImpl::ParseColorOpacity(
   } else if (mToken.mNumber > 1.0f) {
     mToken.mNumber = 1.0f;
   }
 
   PRUint8 value = nsStyleUtil::FloatToColorComponent(mToken.mNumber);
   NS_ASSERTION(fabs(mToken.mNumber - value/255.0f) <= 0.5f,
                "FloatToColorComponent did something weird");
 
-  if (!ExpectSymbol(aErrorCode, ')', PR_TRUE)) {
+  if (!ExpectSymbol(')', PR_TRUE)) {
     REPORT_UNEXPECTED_TOKEN(PEExpectedCloseParen);
     return PR_FALSE;
   }
-  
+
   aOpacity = value;
 
   return PR_TRUE;
 }
 
 #ifdef MOZ_XUL
-PRBool CSSParserImpl::ParseTreePseudoElement(nsresult& aErrorCode,
-                                                 nsCSSSelector& aSelector)
-{
-  if (ExpectSymbol(aErrorCode, '(', PR_FALSE)) {
-    while (!ExpectSymbol(aErrorCode, ')', PR_TRUE)) {
-      if (!GetToken(aErrorCode, PR_TRUE)) {
+PRBool
+CSSParserImpl::ParseTreePseudoElement(nsCSSSelector& aSelector)
+{
+  if (ExpectSymbol('(', PR_FALSE)) {
+    while (!ExpectSymbol(')', PR_TRUE)) {
+      if (!GetToken(PR_TRUE)) {
         return PR_FALSE;
       }
       else if (eCSSToken_Ident == mToken.mType) {
         nsCOMPtr<nsIAtom> pseudo = do_GetAtom(mToken.mIdent);
         aSelector.AddPseudoClass(pseudo);
       }
       else if (eCSSToken_Symbol == mToken.mType) {
         if (!mToken.IsSymbol(','))
           return PR_FALSE;
       }
       else return PR_FALSE;
     }
     return PR_TRUE;
   }
-  return PR_FALSE; 
+  return PR_FALSE;
 }
 #endif
 
 //----------------------------------------------------------------------
 
 PRBool
-CSSParserImpl::ParseDeclaration(nsresult& aErrorCode,
-                                nsCSSDeclaration* aDeclaration,
+CSSParserImpl::ParseDeclaration(nsCSSDeclaration* aDeclaration,
                                 PRBool aCheckForBraces,
                                 PRBool aMustCallValueAppended,
                                 PRBool* aChanged)
 {
   mTempData.AssertInitialState();
 
   // Get property name
   nsCSSToken* tk = &mToken;
   nsAutoString propertyName;
   for (;;) {
-    if (!GetToken(aErrorCode, PR_TRUE)) {
+    if (!GetToken(PR_TRUE)) {
       if (aCheckForBraces) {
         REPORT_UNEXPECTED_EOF(PEDeclEndEOF);
       }
       return PR_FALSE;
     }
     if (eCSSToken_Ident == tk->mType) {
       propertyName = tk->mIdent;
       // grab the ident before the ExpectSymbol trashes the token
-      if (!ExpectSymbol(aErrorCode, ':', PR_TRUE)) {
+      if (!ExpectSymbol(':', PR_TRUE)) {
         REPORT_UNEXPECTED_TOKEN(PEParseDeclarationNoColon);
         REPORT_UNEXPECTED(PEDeclDropped);
         OUTPUT_ERROR();
         return PR_FALSE;
       }
       break;
     }
     if (tk->IsSymbol(';')) {
@@ -3852,41 +3815,41 @@ CSSParserImpl::ParseDeclaration(nsresult
       };
       REPORT_UNEXPECTED_P(PEUnknownProperty, params);
       REPORT_UNEXPECTED(PEDeclDropped);
       OUTPUT_ERROR();
     }
 
     return PR_FALSE;
   }
-  if (! ParseProperty(aErrorCode, propID)) {
+  if (! ParseProperty(propID)) {
     // XXX Much better to put stuff in the value parsers instead...
     const PRUnichar *params[] = {
       propertyName.get()
     };
     REPORT_UNEXPECTED_P(PEValueParsingError, params);
     REPORT_UNEXPECTED(PEDeclDropped);
     OUTPUT_ERROR();
     ClearTempData(propID);
     return PR_FALSE;
   }
   CLEAR_ERROR();
 
   // See if the declaration is followed by a "!important" declaration
   PRBool isImportant = PR_FALSE;
-  if (!GetToken(aErrorCode, PR_TRUE)) {
+  if (!GetToken(PR_TRUE)) {
     // EOF is a perfectly good way to end a declaration and declaration block
     TransferTempData(aDeclaration, propID, isImportant,
                      aMustCallValueAppended, aChanged);
     return PR_TRUE;
   }
 
   if (eCSSToken_Symbol == tk->mType && '!' == tk->mSymbol) {
     // Look for important ident
-    if (!GetToken(aErrorCode, PR_TRUE)) {
+    if (!GetToken(PR_TRUE)) {
       // Premature eof is not ok
       REPORT_UNEXPECTED_EOF(PEImportantEOF);
       ClearTempData(propID);
       return PR_FALSE;
     }
     if ((eCSSToken_Ident != tk->mType) ||
         !tk->mIdent.LowerCaseEqualsLiteral("important")) {
       REPORT_UNEXPECTED_TOKEN(PEExpectedImportant);
@@ -3900,22 +3863,22 @@ CSSParserImpl::ParseDeclaration(nsresult
   else {
     // Not a !important declaration
     UngetToken();
   }
 
   // Make sure valid property declaration is terminated with either a
   // semicolon, EOF or a right-curly-brace (this last only when
   // aCheckForBraces is true).
-  if (!GetToken(aErrorCode, PR_TRUE)) {
+  if (!GetToken(PR_TRUE)) {
     // EOF is a perfectly good way to end a declaration and declaration block
     TransferTempData(aDeclaration, propID, isImportant,
                      aMustCallValueAppended, aChanged);
     return PR_TRUE;
-  } 
+  }
   if (eCSSToken_Symbol == tk->mType) {
     if (';' == tk->mSymbol) {
       TransferTempData(aDeclaration, propID, isImportant,
                        aMustCallValueAppended, aChanged);
       return PR_TRUE;
     }
     if (aCheckForBraces && '}' == tk->mSymbol) {
       // Unget the '}' so we'll be able to tell that this is the end
@@ -4100,20 +4063,21 @@ static const nsCSSProperty kBorderEndIDs
   eCSSProperty_border_end_color
 };
 static const nsCSSProperty kColumnRuleIDs[] = {
   eCSSProperty__moz_column_rule_width,
   eCSSProperty__moz_column_rule_style,
   eCSSProperty__moz_column_rule_color
 };
 
-PRBool CSSParserImpl::ParseEnum(nsresult& aErrorCode, nsCSSValue& aValue,
-                                const PRInt32 aKeywordTable[])
-{
-  nsSubstring* ident = NextIdent(aErrorCode);
+PRBool
+CSSParserImpl::ParseEnum(nsCSSValue& aValue,
+                         const PRInt32 aKeywordTable[])
+{
+  nsSubstring* ident = NextIdent();
   if (nsnull == ident) {
     return PR_FALSE;
   }
   nsCSSKeyword keyword = nsCSSKeywords::LookupKeyword(*ident);
   if (eCSSKeyword_UNKNOWN < keyword) {
     PRInt32 value;
     if (nsCSSProps::FindKeyword(keyword, aKeywordTable, value)) {
       aValue.SetIntValue(value, eCSSUnit_Enumerated);
@@ -4154,21 +4118,21 @@ const UnitInfo UnitData[] = {
   { STR_WITH_LEN("hz"), eCSSUnit_Hertz, VARIANT_FREQUENCY },
   { STR_WITH_LEN("khz"), eCSSUnit_Kilohertz, VARIANT_FREQUENCY },
   { STR_WITH_LEN("s"), eCSSUnit_Seconds, VARIANT_TIME },
   { STR_WITH_LEN("ms"), eCSSUnit_Milliseconds, VARIANT_TIME }
 };
 
 #undef STR_WITH_LEN
 
-PRBool CSSParserImpl::TranslateDimension(nsresult& aErrorCode,
-                                         nsCSSValue& aValue,
-                                         PRInt32 aVariantMask,
-                                         float aNumber,
-                                         const nsString& aUnit)
+PRBool
+CSSParserImpl::TranslateDimension(nsCSSValue& aValue,
+                                  PRInt32 aVariantMask,
+                                  float aNumber,
+                                  const nsString& aUnit)
 {
   nsCSSUnit units;
   PRInt32   type = 0;
   if (!aUnit.IsEmpty()) {
     PRUint32 i;
     for (i = 0; i < NS_ARRAY_LENGTH(UnitData); ++i) {
       if (aUnit.LowerCaseEqualsASCII(UnitData[i].name,
                                      UnitData[i].length)) {
@@ -4208,55 +4172,56 @@ PRBool CSSParserImpl::TranslateDimension
   }
   if ((type & aVariantMask) != 0) {
     aValue.SetFloatValue(aNumber, units);
     return PR_TRUE;
   }
   return PR_FALSE;
 }
 
-PRBool CSSParserImpl::ParsePositiveVariant(nsresult& aErrorCode, 
-                                           nsCSSValue& aValue, 
-                                           PRInt32 aVariantMask, 
-                                           const PRInt32 aKeywordTable[]) 
-{ 
-  if (ParseVariant(aErrorCode, aValue, aVariantMask, aKeywordTable)) { 
-    if (eCSSUnit_Number == aValue.GetUnit() || 
-        aValue.IsLengthUnit()){ 
-      if (aValue.GetFloatValue() < 0) { 
-        UngetToken();
-        return PR_FALSE; 
-      } 
-    } 
-    else if(aValue.GetUnit() == eCSSUnit_Percent) { 
-      if (aValue.GetPercentValue() < 0) { 
-        UngetToken();
-        return PR_FALSE; 
-      } 
+PRBool
+CSSParserImpl::ParsePositiveVariant(nsCSSValue& aValue,
+                                    PRInt32 aVariantMask,
+                                    const PRInt32 aKeywordTable[])
+{
+  if (ParseVariant(aValue, aVariantMask, aKeywordTable)) {
+    if (eCSSUnit_Number == aValue.GetUnit() ||
+        aValue.IsLengthUnit()){
+      if (aValue.GetFloatValue() < 0) {
+        UngetToken();
+        return PR_FALSE;
+      }
+    }
+    else if(aValue.GetUnit() == eCSSUnit_Percent) {
+      if (aValue.GetPercentValue() < 0) {
+        UngetToken();
+        return PR_FALSE;
+      }
     } else if (aValue.GetUnit() == eCSSUnit_Integer) {
-      if (aValue.GetIntValue() < 0) { 
-        UngetToken();
-        return PR_FALSE; 
-      } 
-    }
-    return PR_TRUE; 
-  } 
-  return PR_FALSE; 
-} 
+      if (aValue.GetIntValue() < 0) {
+        UngetToken();
+        return PR_FALSE;
+      }
+    }
+    return PR_TRUE;
+  }
+  return PR_FALSE;
+}
 
 // Assigns to aValue iff it returns PR_TRUE.
-PRBool CSSParserImpl::ParseVariant(nsresult& aErrorCode, nsCSSValue& aValue,
-                                   PRInt32 aVariantMask,
-                                   const PRInt32 aKeywordTable[])
-{
-  NS_ASSERTION(IsParsingCompoundProperty() || 
+PRBool
+CSSParserImpl::ParseVariant(nsCSSValue& aValue,
+                            PRInt32 aVariantMask,
+                            const PRInt32 aKeywordTable[])
+{
+  NS_ASSERTION(IsParsingCompoundProperty() ||
                ((~aVariantMask) & (VARIANT_LENGTH|VARIANT_COLOR)),
                "cannot distinguish lengths and colors in quirks mode");
 
-  if (!GetToken(aErrorCode, PR_TRUE)) {
+  if (!GetToken(PR_TRUE)) {
     return PR_FALSE;
   }
   nsCSSToken* tk = &mToken;
   if (((aVariantMask & (VARIANT_AHK | VARIANT_NORMAL | VARIANT_NONE)) != 0) &&
       (eCSSToken_Ident == tk->mType)) {
     nsCSSKeyword keyword = nsCSSKeywords::LookupKeyword(tk->mIdent);
     if (eCSSKeyword_UNKNOWN < keyword) { // known keyword
       if ((aVariantMask & VARIANT_AUTO) != 0) {
@@ -4301,19 +4266,19 @@ PRBool CSSParserImpl::ParseVariant(nsres
         PRInt32 value;
         if (nsCSSProps::FindKeyword(keyword, aKeywordTable, value)) {
           aValue.SetIntValue(value, eCSSUnit_Enumerated);
           return PR_TRUE;
         }
       }
     }
   }
-  if (((aVariantMask & (VARIANT_LENGTH | VARIANT_ANGLE | VARIANT_FREQUENCY | VARIANT_TIME)) != 0) && 
+  if (((aVariantMask & (VARIANT_LENGTH | VARIANT_ANGLE | VARIANT_FREQUENCY | VARIANT_TIME)) != 0) &&
       tk->IsDimension()) {
-    if (TranslateDimension(aErrorCode, aValue, aVariantMask, tk->mNumber, tk->mIdent)) {
+    if (TranslateDimension(aValue, aVariantMask, tk->mNumber, tk->mIdent)) {
       return PR_TRUE;
     }
     // Put the token back; we didn't parse it, so we shouldn't consume it
     UngetToken();
     return PR_FALSE;
   }
   if (((aVariantMask & VARIANT_PERCENT) != 0) &&
       (eCSSToken_Percentage == tk->mType)) {
@@ -4346,157 +4311,159 @@ PRBool CSSParserImpl::ParseVariant(nsres
         (eCSSToken_Number == tk->mType)) {
       aValue.SetFloatValue(tk->mNumber, eCSSUnit_Pixel);
       return PR_TRUE;
     }
   }
 #endif
 
   if (((aVariantMask & VARIANT_URL) != 0) &&
-      (eCSSToken_Function == tk->mType) && 
+      (eCSSToken_Function == tk->mType) &&
       tk->mIdent.LowerCaseEqualsLiteral("url")) {
-    if (ParseURL(aErrorCode, aValue)) {
+    if (ParseURL(aValue)) {
       return PR_TRUE;
     }
     return PR_FALSE;
   }
   if ((aVariantMask & VARIANT_COLOR) != 0) {
     if ((mNavQuirkMode && !IsParsingCompoundProperty()) || // NONSTANDARD: Nav interprets 'xxyyzz' values even without '#' prefix
-    		(eCSSToken_ID == tk->mType) || 
-    		(eCSSToken_Ref == tk->mType) || 
+        (eCSSToken_ID == tk->mType) ||
+        (eCSSToken_Ref == tk->mType) ||
         (eCSSToken_Ident == tk->mType) ||
-        ((eCSSToken_Function == tk->mType) && 
+        ((eCSSToken_Function == tk->mType) &&
          (tk->mIdent.LowerCaseEqualsLiteral("rgb") ||
           tk->mIdent.LowerCaseEqualsLiteral("hsl") ||
           tk->mIdent.LowerCaseEqualsLiteral("-moz-rgba") ||
           tk->mIdent.LowerCaseEqualsLiteral("-moz-hsla") ||
           tk->mIdent.LowerCaseEqualsLiteral("rgba") ||
           tk->mIdent.LowerCaseEqualsLiteral("hsla"))))
     {
       // Put token back so that parse color can get it
       UngetToken();
-      if (ParseColor(aErrorCode, aValue)) {
-        return PR_TRUE;
-      }
-      return PR_FALSE;
-    }
-  }
-  if (((aVariantMask & VARIANT_STRING) != 0) && 
+      if (ParseColor(aValue)) {
+        return PR_TRUE;
+      }
+      return PR_FALSE;
+    }
+  }
+  if (((aVariantMask & VARIANT_STRING) != 0) &&
       (eCSSToken_String == tk->mType)) {
     nsAutoString  buffer;
     buffer.Append(tk->mSymbol);
     buffer.Append(tk->mIdent);
     buffer.Append(tk->mSymbol);
     aValue.SetStringValue(buffer, eCSSUnit_String);
     return PR_TRUE;
   }
-  if (((aVariantMask & VARIANT_IDENTIFIER) != 0) && 
+  if (((aVariantMask & VARIANT_IDENTIFIER) != 0) &&
       (eCSSToken_Ident == tk->mType)) {
     aValue.SetStringValue(tk->mIdent, eCSSUnit_String);
     return PR_TRUE;
   }
   if (((aVariantMask & VARIANT_COUNTER) != 0) &&
       (eCSSToken_Function == tk->mType) &&
-      (tk->mIdent.LowerCaseEqualsLiteral("counter") || 
+      (tk->mIdent.LowerCaseEqualsLiteral("counter") ||
        tk->mIdent.LowerCaseEqualsLiteral("counters"))) {
-    return ParseCounter(aErrorCode, aValue);
+    return ParseCounter(aValue);
   }
   if (((aVariantMask & VARIANT_ATTR) != 0) &&
       (eCSSToken_Function == tk->mType) &&
       tk->mIdent.LowerCaseEqualsLiteral("attr")) {
-    return ParseAttr(aErrorCode, aValue);
-  }
-
-  UngetToken();
-  return PR_FALSE;
-}
-
-
-PRBool CSSParserImpl::ParseCounter(nsresult& aErrorCode, nsCSSValue& aValue)
-{
-  nsCSSUnit unit = (mToken.mIdent.LowerCaseEqualsLiteral("counter") ? 
+    return ParseAttr(aValue);
+  }
+
+  UngetToken();
+  return PR_FALSE;
+}
+
+
+PRBool
+CSSParserImpl::ParseCounter(nsCSSValue& aValue)
+{
+  nsCSSUnit unit = (mToken.mIdent.LowerCaseEqualsLiteral("counter") ?
                     eCSSUnit_Counter : eCSSUnit_Counters);
 
-  if (!ExpectSymbol(aErrorCode, '(', PR_FALSE))
-    return PR_FALSE;
-
-  if (!GetNonCloseParenToken(aErrorCode, PR_TRUE) ||
+  if (!ExpectSymbol('(', PR_FALSE))
+    return PR_FALSE;
+
+  if (!GetNonCloseParenToken(PR_TRUE) ||
       eCSSToken_Ident != mToken.mType) {
-    SkipUntil(aErrorCode, ')');
+    SkipUntil(')');
     return PR_FALSE;
   }
 
   nsRefPtr<nsCSSValue::Array> val =
     nsCSSValue::Array::Create(unit == eCSSUnit_Counter ? 2 : 3);
   if (!val) {
-    aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+    mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
     return PR_FALSE;
   }
 
   val->Item(0).SetStringValue(mToken.mIdent, eCSSUnit_String);
 
   if (eCSSUnit_Counters == unit) {
     // get mandatory separator string
-    if (!ExpectSymbol(aErrorCode, ',', PR_TRUE) ||
-        !(GetNonCloseParenToken(aErrorCode, PR_TRUE) &&
+    if (!ExpectSymbol(',', PR_TRUE) ||
+        !(GetNonCloseParenToken(PR_TRUE) &&
           eCSSToken_String == mToken.mType)) {
-      SkipUntil(aErrorCode, ')');
+      SkipUntil(')');
       return PR_FALSE;
     }
     val->Item(1).SetStringValue(mToken.mIdent, eCSSUnit_String);
   }
 
   // get optional type
   PRInt32 type = NS_STYLE_LIST_STYLE_DECIMAL;
-  if (ExpectSymbol(aErrorCode, ',', PR_TRUE)) {
+  if (ExpectSymbol(',', PR_TRUE)) {
     nsCSSKeyword keyword;
-    PRBool success = GetNonCloseParenToken(aErrorCode, PR_TRUE) &&
+    PRBool success = GetNonCloseParenToken(PR_TRUE) &&
                      eCSSToken_Ident == mToken.mType &&
                      (keyword = nsCSSKeywords::LookupKeyword(mToken.mIdent)) !=
                       eCSSKeyword_UNKNOWN;
     if (success) {
       if (keyword == eCSSKeyword_none) {
         type = NS_STYLE_LIST_STYLE_NONE;
       } else {
         success = nsCSSProps::FindKeyword(keyword,
                                           nsCSSProps::kListStyleKTable, type);
       }
     }
     if (!success) {
-      SkipUntil(aErrorCode, ')');
+      SkipUntil(')');
       return PR_FALSE;
     }
   }
   PRInt32 typeItem = eCSSUnit_Counters == unit ? 2 : 1;
   val->Item(typeItem).SetIntValue(type, eCSSUnit_Enumerated);
 
-  if (!ExpectSymbol(aErrorCode, ')', PR_TRUE)) {
-    SkipUntil(aErrorCode, ')');
+  if (!ExpectSymbol(')', PR_TRUE)) {
+    SkipUntil(')');
     return PR_FALSE;
   }
 
   aValue.SetArrayValue(val, unit);
   return PR_TRUE;
 }
 
-PRBool CSSParserImpl::ParseAttr(nsresult& aErrorCode, nsCSSValue& aValue)
-{
-  if (ExpectSymbol(aErrorCode, '(', PR_FALSE)) {
-    if (GetToken(aErrorCode, PR_TRUE)) {
+PRBool
+CSSParserImpl::ParseAttr(nsCSSValue& aValue)
+{
+  if (ExpectSymbol('(', PR_FALSE)) {
+    if (GetToken(PR_TRUE)) {
       nsAutoString attr;
       if (eCSSToken_Ident == mToken.mType) {  // attr name or namespace
         nsAutoString  holdIdent(mToken.mIdent);
-        if (ExpectSymbol(aErrorCode, '|', PR_FALSE)) {  // namespace
+        if (ExpectSymbol('|', PR_FALSE)) {  // namespace
           PRInt32 nameSpaceID;
-          if (!GetNamespaceIdForPrefix(holdIdent, &nameSpaceID, aErrorCode)) {
+          if (!GetNamespaceIdForPrefix(holdIdent, &nameSpaceID)) {
             return PR_FALSE;
           }
           attr.AppendInt(nameSpaceID, 10);
           attr.Append(PRUnichar('|'));
-          if (! GetToken(aErrorCode, PR_FALSE)) {
+          if (! GetToken(PR_FALSE)) {
             REPORT_UNEXPECTED_EOF(PEAttributeNameEOF);
             return PR_FALSE;
           }
           if (eCSSToken_Ident == mToken.mType) {
             if (mCaseSensitive) {
               attr.Append(mToken.mIdent);
             } else {
               nsAutoString buffer;
@@ -4521,17 +4488,17 @@ PRBool CSSParserImpl::ParseAttr(nsresult
       }
       else if (mToken.IsSymbol('*')) {  // namespace wildcard
         // Wildcard namespace makes no sense here and is not allowed
         REPORT_UNEXPECTED_TOKEN(PEAttributeNameExpected);
         UngetToken();
         return PR_FALSE;
       }
       else if (mToken.IsSymbol('|')) {  // explicit NO namespace
-        if (! GetToken(aErrorCode, PR_FALSE)) {
+        if (! GetToken(PR_FALSE)) {
           REPORT_UNEXPECTED_EOF(PEAttributeNameEOF);
           return PR_FALSE;
         }
         if (eCSSToken_Ident == mToken.mType) {
           if (mCaseSensitive) {
             attr.Append(mToken.mIdent);
           } else {
             nsAutoString buffer;
@@ -4545,84 +4512,85 @@ PRBool CSSParserImpl::ParseAttr(nsresult
           return PR_FALSE;
         }
       }
       else {
         REPORT_UNEXPECTED_TOKEN(PEAttributeNameOrNamespaceExpected);
         UngetToken();
         return PR_FALSE;
       }
-      if (ExpectSymbol(aErrorCode, ')', PR_TRUE)) {
+      if (ExpectSymbol(')', PR_TRUE)) {
         aValue.SetStringValue(attr, eCSSUnit_Attr);
         return PR_TRUE;
       }
     }
   }
   return PR_FALSE;
 }
 
 PRBool
-CSSParserImpl::ParseURL(nsresult& aErrorCode, nsCSSValue& aValue)
+CSSParserImpl::ParseURL(nsCSSValue& aValue)
 {
   if (!mSheetPrincipal) {
     NS_NOTREACHED("Codepaths that expect to parse URLs MUST pass in an "
                   "origin principal");
     return PR_FALSE;
   }
 
-  if (!ExpectSymbol(aErrorCode, '(', PR_FALSE))
-    return PR_FALSE;
-  if (!GetURLToken(aErrorCode))
+  if (!ExpectSymbol('(', PR_FALSE))
+    return PR_FALSE;
+  if (!GetURLToken())
     return PR_FALSE;
 
   nsCSSToken* tk = &mToken;
   if (eCSSToken_String != tk->mType && eCSSToken_URL != tk->mType)
     return PR_FALSE;
 
   nsString url = tk->mIdent;
-  if (!ExpectSymbol(aErrorCode, ')', PR_TRUE))
+  if (!ExpectSymbol(')', PR_TRUE))
     return PR_FALSE;
 
   // Translate url into an absolute url if the url is relative to the
   // style sheet.
   nsCOMPtr<nsIURI> uri;
   NS_NewURI(getter_AddRefs(uri), url, nsnull, mBaseURL);
 
   nsStringBuffer* buffer = nsCSSValue::BufferFromString(url);
   if (NS_UNLIKELY(!buffer)) {
-    aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+    mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
     return PR_FALSE;
   }
   nsCSSValue::URL *urlVal =
     new nsCSSValue::URL(uri, buffer, mSheetURL, mSheetPrincipal);
 
   buffer->Release();
   if (NS_UNLIKELY(!urlVal)) {
-    aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+    mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
     return PR_FALSE;
   }
   aValue.SetURLValue(urlVal);
   return PR_TRUE;
 }
 
-PRInt32 CSSParserImpl::ParseChoice(nsresult& aErrorCode, nsCSSValue aValues[],
-                                   const nsCSSProperty aPropIDs[], PRInt32 aNumIDs)
+PRInt32
+CSSParserImpl::ParseChoice(nsCSSValue aValues[],
+                           const nsCSSProperty aPropIDs[], PRInt32 aNumIDs)
 {
   PRInt32 found = 0;
   nsAutoParseCompoundProperty compound(this);
 
   PRInt32 loop;
   for (loop = 0; loop < aNumIDs; loop++) {
     // Try each property parser in order
     PRInt32 hadFound = found;
     PRInt32 index;
     for (index = 0; index < aNumIDs; index++) {
       PRInt32 bit = 1 << index;
       if ((found & bit) == 0) {
-        if (ParseSingleValueProperty(aErrorCode, aValues[index], aPropIDs[index])) {
+        if (ParseSingleValueProperty(aValues[index], aPropIDs[index])) {
           found |= bit;
         }
       }
     }
     if (found == hadFound) {  // found nothing new
       break;
     }
   }
@@ -4653,52 +4621,50 @@ PRInt32 CSSParserImpl::ParseChoice(nsres
         }
       }
     }
   }
   return found;
 }
 
 void
-CSSParserImpl::AppendValue(nsCSSProperty aPropID,
-                           const nsCSSValue& aValue)
+CSSParserImpl::AppendValue(nsCSSProperty aPropID, const nsCSSValue& aValue)
 {
   NS_ASSERTION(0 <= aPropID && aPropID < eCSSProperty_COUNT_no_shorthands,
                "property out of range");
   NS_ASSERTION(nsCSSProps::kTypeTable[aPropID] == eCSSType_Value,
                nsPrintfCString(64, "type error (property=\'%s\')",
                              nsCSSProps::GetStringValue(aPropID).get()).get());
   nsCSSValue& storage =
       *static_cast<nsCSSValue*>(mTempData.PropertyAt(aPropID));
   storage = aValue;
   mTempData.SetPropertyBit(aPropID);
 }
 
 /**
  * Parse a "box" property. Box properties have 1 to 4 values. When less
  * than 4 values are provided a standard mapping is used to replicate
- * existing values. 
+ * existing values.
  */
-PRBool CSSParserImpl::ParseBoxProperties(nsresult& aErrorCode,
-                                         nsCSSRect& aResult,
-                                         const nsCSSProperty aPropIDs[])
+PRBool
+CSSParserImpl::ParseBoxProperties(nsCSSRect& aResult,
+                                  const nsCSSProperty aPropIDs[])
 {
   // Get up to four values for the property
   PRInt32 count = 0;
   PRInt32 index;
   nsCSSRect result;
   for (index = 0; index < 4; index++) {
-    if (! ParseSingleValueProperty(aErrorCode,
-                                   result.*(nsCSSRect::sides[index]),
+    if (! ParseSingleValueProperty(result.*(nsCSSRect::sides[index]),
                                    aPropIDs[index])) {
       break;
     }
     count++;
   }
-  if ((count == 0) || (PR_FALSE == ExpectEndProperty(aErrorCode))) {
+  if ((count == 0) || (PR_FALSE == ExpectEndProperty())) {
     return PR_FALSE;
   }
 
   if (1 < count) { // verify no more than single inherit or initial
     for (index = 0; index < 4; index++) {
       nsCSSUnit unit = (result.*(nsCSSRect::sides[index])).GetUnit();
       if (eCSSUnit_Inherit == unit || eCSSUnit_Initial == unit) {
         return PR_FALSE;
@@ -4718,218 +4684,200 @@ PRBool CSSParserImpl::ParseBoxProperties
 
   for (index = 0; index < 4; index++) {
     mTempData.SetPropertyBit(aPropIDs[index]);
   }
   aResult = result;
   return PR_TRUE;
 }
 
-PRBool CSSParserImpl::ParseDirectionalBoxProperty(nsresult& aErrorCode,
-                                                  nsCSSProperty aProperty,
-                                                  PRInt32 aSourceType)
+PRBool
+CSSParserImpl::ParseDirectionalBoxProperty(nsCSSProperty aProperty,
+                                           PRInt32 aSourceType)
 {
   const nsCSSProperty* subprops = nsCSSProps::SubpropertyEntryFor(aProperty);
   NS_ASSERTION(subprops[3] == eCSSProperty_UNKNOWN,
                "not box property with physical vs. logical cascading");
   nsCSSValue value;
-  if (!ParseSingleValueProperty(aErrorCode, value, subprops[0]) ||
-      !ExpectEndProperty(aErrorCode))
+  if (!ParseSingleValueProperty(value, subprops[0]) ||
+      !ExpectEndProperty())
     return PR_FALSE;
 
   AppendValue(subprops[0], value);
   nsCSSValue typeVal(aSourceType, eCSSUnit_Enumerated);
   AppendValue(subprops[1], typeVal);
   AppendValue(subprops[2], typeVal);
-  aErrorCode = NS_OK;
-  return PR_TRUE;
-}
-
-PRBool CSSParserImpl::ParseProperty(nsresult& aErrorCode,
-                                    nsCSSProperty aPropID)
+  return PR_TRUE;
+}
+
+PRBool
+CSSParserImpl::ParseProperty(nsCSSProperty aPropID)
 {
   NS_ASSERTION(aPropID < eCSSProperty_COUNT, "index out of range");
 
   switch (aPropID) {  // handle shorthand or multiple properties
   case eCSSProperty_background:
-    return ParseBackground(aErrorCode);
+    return ParseBackground();
   case eCSSProperty_background_position:
-    return ParseBackgroundPosition(aErrorCode);
+    return ParseBackgroundPosition();
   case eCSSProperty_border:
-    return ParseBorderSide(aErrorCode, kBorderTopIDs, PR_TRUE);
+    return ParseBorderSide(kBorderTopIDs, PR_TRUE);
   case eCSSProperty_border_color:
-    return ParseBorderColor(aErrorCode);
+    return ParseBorderColor();
   case eCSSProperty_border_spacing:
-    return ParseBorderSpacing(aErrorCode);
+    return ParseBorderSpacing();
   case eCSSProperty_border_style:
-    return ParseBorderStyle(aErrorCode);
+    return ParseBorderStyle();
   case eCSSProperty_border_bottom:
-    return ParseBorderSide(aErrorCode, kBorderBottomIDs, PR_FALSE);
+    return ParseBorderSide(kBorderBottomIDs, PR_FALSE);
   case eCSSProperty_border_end:
-    return ParseDirectionalBorderSide(aErrorCode, kBorderEndIDs,
+    return ParseDirectionalBorderSide(kBorderEndIDs,
                                       NS_BOXPROP_SOURCE_LOGICAL);
   case eCSSProperty_border_left:
-    return ParseDirectionalBorderSide(aErrorCode, kBorderLeftIDs,
+    return ParseDirectionalBorderSide(kBorderLeftIDs,
                                       NS_BOXPROP_SOURCE_PHYSICAL);
   case eCSSProperty_border_right:
-    return ParseDirectionalBorderSide(aErrorCode, kBorderRightIDs,
+    return ParseDirectionalBorderSide(kBorderRightIDs,
                                       NS_BOXPROP_SOURCE_PHYSICAL);
   case eCSSProperty_border_start:
-    return ParseDirectionalBorderSide(aErrorCode, kBorderStartIDs,
+    return ParseDirectionalBorderSide(kBorderStartIDs,
                                       NS_BOXPROP_SOURCE_LOGICAL);
   case eCSSProperty_border_top:
-    return ParseBorderSide(aErrorCode, kBorderTopIDs, PR_FALSE);
+    return ParseBorderSide(kBorderTopIDs, PR_FALSE);
   case eCSSProperty_border_bottom_colors:
-    return ParseBorderColors(aErrorCode,
-                             &mTempData.mMargin.mBorderColors.mBottom,
+    return ParseBorderColors(&mTempData.mMargin.mBorderColors.mBottom,
                              aPropID);
   case eCSSProperty_border_left_colors:
-    return ParseBorderColors(aErrorCode,
-                             &mTempData.mMargin.mBorderColors.mLeft,
+    return ParseBorderColors(&mTempData.mMargin.mBorderColors.mLeft,
                              aPropID);
   case eCSSProperty_border_right_colors:
-    return ParseBorderColors(aErrorCode,
-                             &mTempData.mMargin.mBorderColors.mRight,
+    return ParseBorderColors(&mTempData.mMargin.mBorderColors.mRight,
                              aPropID);
   case eCSSProperty_border_top_colors:
-    return ParseBorderColors(aErrorCode,
-                             &mTempData.mMargin.mBorderColors.mTop,
+    return ParseBorderColors(&mTempData.mMargin.mBorderColors.mTop,
                              aPropID);
   case eCSSProperty_border_image:
-    return ParseBorderImage(aErrorCode);
+    return ParseBorderImage();
   case eCSSProperty_border_width:
-    return ParseBorderWidth(aErrorCode);
+    return ParseBorderWidth();
   case eCSSProperty_border_end_color:
-    return ParseDirectionalBoxProperty(aErrorCode, 
-                                       eCSSProperty_border_end_color,
+    return ParseDirectionalBoxProperty(eCSSProperty_border_end_color,
                                        NS_BOXPROP_SOURCE_LOGICAL);
   case eCSSProperty_border_left_color:
-    return ParseDirectionalBoxProperty(aErrorCode, 
-                                       eCSSProperty_border_left_color,
+    return ParseDirectionalBoxProperty(eCSSProperty_border_left_color,
                                        NS_BOXPROP_SOURCE_PHYSICAL);
   case eCSSProperty_border_right_color:
-    return ParseDirectionalBoxProperty(aErrorCode, 
-                                       eCSSProperty_border_right_color,
+    return ParseDirectionalBoxProperty(eCSSProperty_border_right_color,
                                        NS_BOXPROP_SOURCE_PHYSICAL);
   case eCSSProperty_border_start_color:
-    return ParseDirectionalBoxProperty(aErrorCode, 
-                                       eCSSProperty_border_start_color,
+    return ParseDirectionalBoxProperty(eCSSProperty_border_start_color,
                                        NS_BOXPROP_SOURCE_LOGICAL);
   case eCSSProperty_border_end_width:
-    return ParseDirectionalBoxProperty(aErrorCode, 
-                                       eCSSProperty_border_end_width,
+    return ParseDirectionalBoxProperty(eCSSProperty_border_end_width,
                                        NS_BOXPROP_SOURCE_LOGICAL);
   case eCSSProperty_border_left_width:
-    return ParseDirectionalBoxProperty(aErrorCode, 
-                                       eCSSProperty_border_left_width,
+    return ParseDirectionalBoxProperty(eCSSProperty_border_left_width,
                                        NS_BOXPROP_SOURCE_PHYSICAL);
   case eCSSProperty_border_right_width:
-    return ParseDirectionalBoxProperty(aErrorCode, 
-                                       eCSSProperty_border_right_width,
+    return ParseDirectionalBoxProperty(eCSSProperty_border_right_width,
                                        NS_BOXPROP_SOURCE_PHYSICAL);
   case eCSSProperty_border_start_width:
-    return ParseDirectionalBoxProperty(aErrorCode, 
-                                       eCSSProperty_border_start_width,
+    return ParseDirectionalBoxProperty(eCSSProperty_border_start_width,
                                        NS_BOXPROP_SOURCE_LOGICAL);
   case eCSSProperty_border_end_style:
-    return ParseDirectionalBoxProperty(aErrorCode, 
-                                       eCSSProperty_border_end_style,
+    return ParseDirectionalBoxProperty(eCSSProperty_border_end_style,
                                        NS_BOXPROP_SOURCE_LOGICAL);
   case eCSSProperty_border_left_style:
-    return ParseDirectionalBoxProperty(aErrorCode, 
-                                       eCSSProperty_border_left_style,
+    return ParseDirectionalBoxProperty(eCSSProperty_border_left_style,
                                        NS_BOXPROP_SOURCE_PHYSICAL);
   case eCSSProperty_border_right_style:
-    return ParseDirectionalBoxProperty(aErrorCode, 
-                                       eCSSProperty_border_right_style,
+    return ParseDirectionalBoxProperty(eCSSProperty_border_right_style,
                                        NS_BOXPROP_SOURCE_PHYSICAL);
   case eCSSProperty_border_start_style:
-    return ParseDirectionalBoxProperty(aErrorCode, 
-                                       eCSSProperty_border_start_style,
+    return ParseDirectionalBoxProperty(eCSSProperty_border_start_style,
                                        NS_BOXPROP_SOURCE_LOGICAL);
   case eCSSProperty__moz_border_radius:
-    return ParseBorderRadius(aErrorCode);
+    return ParseBorderRadius();
   case eCSSProperty__moz_outline_radius:
-    return ParseOutlineRadius(aErrorCode);
+    return ParseOutlineRadius();
   case eCSSProperty_clip:
-    return ParseRect(mTempData.mDisplay.mClip, aErrorCode,
-                     eCSSProperty_clip);
+    return ParseRect(mTempData.mDisplay.mClip, eCSSProperty_clip);
   case eCSSProperty__moz_column_rule:
-    return ParseBorderSide(aErrorCode, kColumnRuleIDs, PR_FALSE);
+    return ParseBorderSide(kColumnRuleIDs, PR_FALSE);
   case eCSSProperty_content:
-    return ParseContent(aErrorCode);
+    return ParseContent();
   case eCSSProperty_counter_increment:
-    return ParseCounterData(aErrorCode, &mTempData.mContent.mCounterIncrement,
+    return ParseCounterData(&mTempData.mContent.mCounterIncrement,
                             aPropID);
   case eCSSProperty_counter_reset:
-    return ParseCounterData(aErrorCode, &mTempData.mContent.mCounterReset,
+    return ParseCounterData(&mTempData.mContent.mCounterReset,
                             aPropID);
   case eCSSProperty_cue:
-    return ParseCue(aErrorCode);
+    return ParseCue();
   case eCSSProperty_cursor:
-    return ParseCursor(aErrorCode);
+    return ParseCursor();
   case eCSSProperty_font:
-    return ParseFont(aErrorCode);
+    return ParseFont();
   case eCSSProperty_image_region:
-    return ParseRect(mTempData.mList.mImageRegion, aErrorCode,
+    return ParseRect(mTempData.mList.mImageRegion,
                      eCSSProperty_image_region);
   case eCSSProperty_list_style:
-    return ParseListStyle(aErrorCode);
+    return ParseListStyle();
   case eCSSProperty_margin:
-    return ParseMargin(aErrorCode);
+    return ParseMargin();
   case eCSSProperty_margin_end:
-    return ParseDirectionalBoxProperty(aErrorCode, eCSSProperty_margin_end,
+    return ParseDirectionalBoxProperty(eCSSProperty_margin_end,
                                        NS_BOXPROP_SOURCE_LOGICAL);
   case eCSSProperty_margin_left:
-    return ParseDirectionalBoxProperty(aErrorCode, eCSSProperty_margin_left,
+    return ParseDirectionalBoxProperty(eCSSProperty_margin_left,
                                        NS_BOXPROP_SOURCE_PHYSICAL);
   case eCSSProperty_margin_right:
-    return ParseDirectionalBoxProperty(aErrorCode, eCSSProperty_margin_right,
+    return ParseDirectionalBoxProperty(eCSSProperty_margin_right,
                                        NS_BOXPROP_SOURCE_PHYSICAL);
   case eCSSProperty_margin_start:
-    return ParseDirectionalBoxProperty(aErrorCode, eCSSProperty_margin_start,
+    return ParseDirectionalBoxProperty(eCSSProperty_margin_start,
                                        NS_BOXPROP_SOURCE_LOGICAL);
   case eCSSProperty_outline:
-    return ParseOutline(aErrorCode);
+    return ParseOutline();
   case eCSSProperty_overflow:
-    return ParseOverflow(aErrorCode);
+    return ParseOverflow();
   case eCSSProperty_padding:
-    return ParsePadding(aErrorCode);
+    return ParsePadding();
   case eCSSProperty_padding_end:
-    return ParseDirectionalBoxProperty(aErrorCode, eCSSProperty_padding_end,
+    return ParseDirectionalBoxProperty(eCSSProperty_padding_end,
                                        NS_BOXPROP_SOURCE_LOGICAL);
   case eCSSProperty_padding_left:
-    return ParseDirectionalBoxProperty(aErrorCode, eCSSProperty_padding_left,
+    return ParseDirectionalBoxProperty(eCSSProperty_padding_left,
                                        NS_BOXPROP_SOURCE_PHYSICAL);
   case eCSSProperty_padding_right:
-    return ParseDirectionalBoxProperty(aErrorCode, eCSSProperty_padding_right,
+    return ParseDirectionalBoxProperty(eCSSProperty_padding_right,
                                        NS_BOXPROP_SOURCE_PHYSICAL);
   case eCSSProperty_padding_start:
-    return ParseDirectionalBoxProperty(aErrorCode, eCSSProperty_padding_start,
+    return ParseDirectionalBoxProperty(eCSSProperty_padding_start,
                                        NS_BOXPROP_SOURCE_LOGICAL);
   case eCSSProperty_pause:
-    return ParsePause(aErrorCode);
+    return ParsePause();
   case eCSSProperty_quotes:
-    return ParseQuotes(aErrorCode);
+    return ParseQuotes();
   case eCSSProperty_size:
-    return ParseSize(aErrorCode);
+    return ParseSize();
   case eCSSProperty_text_shadow:
-    return ParseTextShadow(aErrorCode);
+    return ParseTextShadow();
   case eCSSProperty_box_shadow:
-    return ParseBoxShadow(aErrorCode);
+    return ParseBoxShadow();
 
 #ifdef MOZ_SVG
   case eCSSProperty_fill:
-    return ParsePaint(aErrorCode, &mTempData.mSVG.mFill, eCSSProperty_fill);
+    return ParsePaint(&mTempData.mSVG.mFill, eCSSProperty_fill);
   case eCSSProperty_stroke:
-    return ParsePaint(aErrorCode, &mTempData.mSVG.mStroke, eCSSProperty_stroke);
+    return ParsePaint(&mTempData.mSVG.mStroke, eCSSProperty_stroke);
   case eCSSProperty_stroke_dasharray:
-    return ParseDasharray(aErrorCode);
+    return ParseDasharray();
   case eCSSProperty_marker:
-    return ParseMarker(aErrorCode);
+    return ParseMarker();
 #endif
 
   // Strip out properties we use internally.
   case eCSSProperty__x_system_font:
   case eCSSProperty_margin_end_value:
   case eCSSProperty_margin_left_value:
   case eCSSProperty_margin_right_value:
   case eCSSProperty_margin_start_value:
@@ -4971,20 +4919,19 @@ PRBool CSSParserImpl::ParseProperty(nsre
   case eCSSProperty_border_right_width_rtl_source:
     // The user can't use these
     REPORT_UNEXPECTED(PEInaccessibleProperty2);
     return PR_FALSE;
 
   default:  // must be single property
     {
       nsCSSValue value;
-      if (ParseSingleValueProperty(aErrorCode, value, aPropID)) {
-        if (ExpectEndProperty(aErrorCode)) {
+      if (ParseSingleValueProperty(value, aPropID)) {
+        if (ExpectEndProperty()) {
           AppendValue(aPropID, value);
-          aErrorCode = NS_OK;
           return PR_TRUE;
         }
         // XXX Report errors?
       }
       // XXX Report errors?
     }
   }
   return PR_FALSE;
@@ -4994,19 +4941,19 @@ PRBool CSSParserImpl::ParseProperty(nsre
 #define BG_CENTER  NS_STYLE_BG_POSITION_CENTER
 #define BG_TOP     NS_STYLE_BG_POSITION_TOP
 #define BG_BOTTOM  NS_STYLE_BG_POSITION_BOTTOM
 #define BG_LEFT    NS_STYLE_BG_POSITION_LEFT
 #define BG_RIGHT   NS_STYLE_BG_POSITION_RIGHT
 #define BG_CTB    (BG_CENTER | BG_TOP | BG_BOTTOM)
 #define BG_CLR    (BG_CENTER | BG_LEFT | BG_RIGHT)
 
-PRBool CSSParserImpl::ParseSingleValueProperty(nsresult& aErrorCode,
-                                               nsCSSValue& aValue,
-                                               nsCSSProperty aPropID)
+PRBool
+CSSParserImpl::ParseSingleValueProperty(nsCSSValue& aValue,
+                                        nsCSSProperty aPropID)
 {
   switch (aPropID) {
   case eCSSProperty_UNKNOWN:
   case eCSSProperty_background:
   case eCSSProperty_background_position:
   case eCSSProperty_border:
   case eCSSProperty_border_color:
   case eCSSProperty_border_bottom_colors:
@@ -5098,409 +5045,409 @@ PRBool CSSParserImpl::ParseSingleValuePr
 #ifdef MOZ_MATHML
   case eCSSProperty_script_size_multiplier:
   case eCSSProperty_script_min_size:
 #endif
     NS_ERROR("not currently parsed here");
     return PR_FALSE;
 
   case eCSSProperty_appearance:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HK,
+    return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kAppearanceKTable);
   case eCSSProperty_azimuth:
-    return ParseAzimuth(aErrorCode, aValue);
+    return ParseAzimuth(aValue);
   case eCSSProperty_background_attachment:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HK,
+    return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kBackgroundAttachmentKTable);
   case eCSSProperty__moz_background_clip:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HK,
+    return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kBackgroundClipKTable);
   case eCSSProperty_background_color:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HCK,
+    return ParseVariant(aValue, VARIANT_HCK,
                         nsCSSProps::kBackgroundColorKTable);
   case eCSSProperty_background_image:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HUO, nsnull);
+    return ParseVariant(aValue, VARIANT_HUO, nsnull);
   case eCSSProperty__moz_background_inline_policy:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HK,
+    return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kBackgroundInlinePolicyKTable);
   case eCSSProperty__moz_background_origin:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HK,
+    return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kBackgroundOriginKTable);
   case eCSSProperty_background_repeat:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HK,
+    return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kBackgroundRepeatKTable);
   case eCSSProperty_binding:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HUO, nsnull);
+    return ParseVariant(aValue, VARIANT_HUO, nsnull);
   case eCSSProperty_border_collapse:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HK,
+    return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kBorderCollapseKTable);
   case eCSSProperty_border_bottom_color:
   case eCSSProperty_border_end_color_value: // for internal use
   case eCSSProperty_border_left_color_value: // for internal use
   case eCSSProperty_border_right_color_value: // for internal use
   case eCSSProperty_border_start_color_value: // for internal use
   case eCSSProperty_border_top_color:
   case eCSSProperty__moz_column_rule_color:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HCK, 
+    return ParseVariant(aValue, VARIANT_HCK,
                         nsCSSProps::kBorderColorKTable);
   case eCSSProperty_border_bottom_style:
   case eCSSProperty_border_end_style_value: // for internal use
   case eCSSProperty_border_left_style_value: // for internal use
   case eCSSProperty_border_right_style_value: // for internal use
   case eCSSProperty_border_start_style_value: // for internal use
   case eCSSProperty_border_top_style:
   case eCSSProperty__moz_column_rule_style:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HOK,
+    return ParseVariant(aValue, VARIANT_HOK,
                         nsCSSProps::kBorderStyleKTable);
   case eCSSProperty_border_bottom_width:
   case eCSSProperty_border_end_width_value: // for internal use
   case eCSSProperty_border_left_width_value: // for internal use
   case eCSSProperty_border_right_width_value: // for internal use
   case eCSSProperty_border_start_width_value: // for internal use
   case eCSSProperty_border_top_width:
   case eCSSProperty__moz_column_rule_width:
-    return ParsePositiveVariant(aErrorCode, aValue, VARIANT_HKL,
+    return ParsePositiveVariant(aValue, VARIANT_HKL,
                                 nsCSSProps::kBorderWidthKTable);
   case eCSSProperty__moz_border_radius_topLeft:
   case eCSSProperty__moz_border_radius_topRight:
   case eCSSProperty__moz_border_radius_bottomRight:
   case eCSSProperty__moz_border_radius_bottomLeft:
-    return ParsePositiveVariant(aErrorCode, aValue, VARIANT_HLP, nsnull);
+    return ParsePositiveVariant(aValue, VARIANT_HLP, nsnull);
   case eCSSProperty__moz_column_count:
-    return ParsePositiveVariant(aErrorCode, aValue, VARIANT_AHI, nsnull);
+    return ParsePositiveVariant(aValue, VARIANT_AHI, nsnull);
   case eCSSProperty__moz_column_width:
-    return ParsePositiveVariant(aErrorCode, aValue, VARIANT_AHL, nsnull);
+    return ParsePositiveVariant(aValue, VARIANT_AHL, nsnull);
   case eCSSProperty__moz_column_gap:
-    return ParsePositiveVariant(aErrorCode, aValue, VARIANT_HL | VARIANT_NORMAL, nsnull);
+    return ParsePositiveVariant(aValue, VARIANT_HL | VARIANT_NORMAL, nsnull);
   case eCSSProperty__moz_outline_radius_topLeft:
   case eCSSProperty__moz_outline_radius_topRight:
   case eCSSProperty__moz_outline_radius_bottomRight:
   case eCSSProperty__moz_outline_radius_bottomLeft:
-    return ParsePositiveVariant(aErrorCode, aValue, VARIANT_HLP, nsnull);
+    return ParsePositiveVariant(aValue, VARIANT_HLP, nsnull);
   case eCSSProperty_bottom:
   case eCSSProperty_top:
   case eCSSProperty_left:
   case eCSSProperty_right:
-	  return ParseVariant(aErrorCode, aValue, VARIANT_AHLP, nsnull);
+    return ParseVariant(aValue, VARIANT_AHLP, nsnull);
   case eCSSProperty_box_align:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HK,
+    return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kBoxAlignKTable);
   case eCSSProperty_box_direction:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HK,
+    return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kBoxDirectionKTable);
   case eCSSProperty_box_flex:
-    return ParsePositiveVariant(aErrorCode, aValue, VARIANT_HN, nsnull);
+    return ParsePositiveVariant(aValue, VARIANT_HN, nsnull);
   case eCSSProperty_box_orient:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HK,
+    return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kBoxOrientKTable);
   case eCSSProperty_box_pack:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HK,
+    return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kBoxPackKTable);
   case eCSSProperty_box_ordinal_group:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HI, nsnull);
+    return ParseVariant(aValue, VARIANT_HI, nsnull);
 #ifdef MOZ_SVG
   case eCSSProperty_clip_path:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HUO, nsnull);
+    return ParseVariant(aValue, VARIANT_HUO, nsnull);
   case eCSSProperty_clip_rule:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HK,
+    return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kFillRuleKTable);
   case eCSSProperty_color_interpolation:
   case eCSSProperty_color_interpolation_filters:
-    return ParseVariant(aErrorCode, aValue, VARIANT_AHK,
+    return ParseVariant(aValue, VARIANT_AHK,
                         nsCSSProps::kColorInterpolationKTable);
   case eCSSProperty_dominant_baseline:
-    return ParseVariant(aErrorCode, aValue, VARIANT_AHK,
+    return ParseVariant(aValue, VARIANT_AHK,
                         nsCSSProps::kDominantBaselineKTable);
   case eCSSProperty_fill_opacity:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HN,
+    return ParseVariant(aValue, VARIANT_HN,
                         nsnull);
   case eCSSProperty_fill_rule:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HK,
+    return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kFillRuleKTable);
   case eCSSProperty_filter:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HUO, nsnull);
+    return ParseVariant(aValue, VARIANT_HUO, nsnull);
   case eCSSProperty_flood_color:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HC, nsnull);
+    return ParseVariant(aValue, VARIANT_HC, nsnull);
   case eCSSProperty_flood_opacity:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HN, nsnull);
+    return ParseVariant(aValue, VARIANT_HN, nsnull);
   case eCSSProperty_lighting_color:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HC, nsnull);
+    return ParseVariant(aValue, VARIANT_HC, nsnull);
   case eCSSProperty_marker_end:
   case eCSSProperty_marker_mid:
   case eCSSProperty_marker_start:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HUO, nsnull);
+    return ParseVariant(aValue, VARIANT_HUO, nsnull);
   case eCSSProperty_mask:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HUO, nsnull);
+    return ParseVariant(aValue, VARIANT_HUO, nsnull);
   case eCSSProperty_pointer_events:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HOK,
+    return ParseVariant(aValue, VARIANT_HOK,
                         nsCSSProps::kPointerEventsKTable);
   case eCSSProperty_shape_rendering:
-    return ParseVariant(aErrorCode, aValue, VARIANT_AHK,
+    return ParseVariant(aValue, VARIANT_AHK,
                         nsCSSProps::kShapeRenderingKTable);
   case eCSSProperty_stop_color:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HC,
+    return ParseVariant(aValue, VARIANT_HC,
                         nsnull);
   case eCSSProperty_stop_opacity:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HN,
+    return ParseVariant(aValue, VARIANT_HN,
                         nsnull);
   case eCSSProperty_stroke_dashoffset:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HLPN,
+    return ParseVariant(aValue, VARIANT_HLPN,
                         nsnull);
   case eCSSProperty_stroke_linecap:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HK,
+    return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kStrokeLinecapKTable);
   case eCSSProperty_stroke_linejoin:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HK,
+    return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kStrokeLinejoinKTable);
   case eCSSProperty_stroke_miterlimit:
-    return ParsePositiveVariant(aErrorCode, aValue, VARIANT_HN,
+    return ParsePositiveVariant(aValue, VARIANT_HN,
                                 nsnull);
   case eCSSProperty_stroke_opacity:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HN,
+    return ParseVariant(aValue, VARIANT_HN,
                         nsnull);
   case eCSSProperty_stroke_width:
-    return ParsePositiveVariant(aErrorCode, aValue, VARIANT_HLPN,
+    return ParsePositiveVariant(aValue, VARIANT_HLPN,
                         nsnull);
   case eCSSProperty_text_anchor:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HK,
+    return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kTextAnchorKTable);
   case eCSSProperty_text_rendering:
-    return ParseVariant(aErrorCode, aValue, VARIANT_AHK,
+    return ParseVariant(aValue, VARIANT_AHK,
                         nsCSSProps::kTextRenderingKTable);
 #endif
   case eCSSProperty_box_sizing:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HK,
+    return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kBoxSizingKTable);
   case eCSSProperty_height:
-    return ParsePositiveVariant(aErrorCode, aValue, VARIANT_AHLP, nsnull);
+    return ParsePositiveVariant(aValue, VARIANT_AHLP, nsnull);
   case eCSSProperty_width:
-    return ParsePositiveVariant(aErrorCode, aValue, VARIANT_AHKLP,
+    return ParsePositiveVariant(aValue, VARIANT_AHKLP,
                                 nsCSSProps::kWidthKTable);
   case eCSSProperty_force_broken_image_icon:
-    return ParsePositiveVariant(aErrorCode, aValue, VARIANT_HI, nsnull);
+    return ParsePositiveVariant(aValue, VARIANT_HI, nsnull);
   case eCSSProperty_caption_side:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HK, 
+    return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kCaptionSideKTable);
   case eCSSProperty_clear:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HOK,
+    return ParseVariant(aValue, VARIANT_HOK,
                         nsCSSProps::kClearKTable);
   case eCSSProperty_color:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HC, nsnull);
+    return ParseVariant(aValue, VARIANT_HC, nsnull);
   case eCSSProperty_cue_after:
   case eCSSProperty_cue_before:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HUO, nsnull);
+    return ParseVariant(aValue, VARIANT_HUO, nsnull);
   case eCSSProperty_direction:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HK,
+    return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kDirectionKTable);
   case eCSSProperty_display:
-    if (ParseVariant(aErrorCode, aValue, VARIANT_HOK, nsCSSProps::kDisplayKTable)) {
-			if (aValue.GetUnit() == eCSSUnit_Enumerated) {
-				switch (aValue.GetIntValue()) {
-					case NS_STYLE_DISPLAY_MARKER:        // bug 2055
-					case NS_STYLE_DISPLAY_RUN_IN:		 // bug 2056
-					case NS_STYLE_DISPLAY_COMPACT:       // bug 14983
-						return PR_FALSE;
-				}
-			}
-      return PR_TRUE;
-		}
+    if (ParseVariant(aValue, VARIANT_HOK, nsCSSProps::kDisplayKTable)) {
+      if (aValue.GetUnit() == eCSSUnit_Enumerated) {
+        switch (aValue.GetIntValue()) {
+          case NS_STYLE_DISPLAY_MARKER:        // bug 2055
+          case NS_STYLE_DISPLAY_RUN_IN:        // bug 2056
+          case NS_STYLE_DISPLAY_COMPACT:       // bug 14983
+            return PR_FALSE;
+        }
+      }
+      return PR_TRUE;
+    }
     return PR_FALSE;
   case eCSSProperty_elevation:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HK | VARIANT_ANGLE,
+    return ParseVariant(aValue, VARIANT_HK | VARIANT_ANGLE,
                         nsCSSProps::kElevationKTable);
   case eCSSProperty_empty_cells:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HK,
+    return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kEmptyCellsKTable);
   case eCSSProperty_float:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HOK,
+    return ParseVariant(aValue, VARIANT_HOK,
                         nsCSSProps::kFloatKTable);
   case eCSSProperty_float_edge:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HK,
+    return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kFloatEdgeKTable);
   case eCSSProperty_font_family:
-    return ParseFamily(aErrorCode, aValue);
-  case eCSSProperty_font_size: 
-    return ParsePositiveVariant(aErrorCode, aValue,
+    return ParseFamily(aValue);
+  case eCSSProperty_font_size:
+    return ParsePositiveVariant(aValue,
                                 VARIANT_HKLP | VARIANT_SYSFONT,
                                 nsCSSProps::kFontSizeKTable);
   case eCSSProperty_font_size_adjust:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HON | VARIANT_SYSFONT,
+    return ParseVariant(aValue, VARIANT_HON | VARIANT_SYSFONT,
                         nsnull);
   case eCSSProperty_font_stretch:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HMK | VARIANT_SYSFONT,
+    return ParseVariant(aValue, VARIANT_HMK | VARIANT_SYSFONT,
                         nsCSSProps::kFontStretchKTable);
   case eCSSProperty_font_style:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HMK | VARIANT_SYSFONT,
+    return ParseVariant(aValue, VARIANT_HMK | VARIANT_SYSFONT,
                         nsCSSProps::kFontStyleKTable);
   case eCSSProperty_font_variant:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HMK | VARIANT_SYSFONT,
+    return ParseVariant(aValue, VARIANT_HMK | VARIANT_SYSFONT,
                         nsCSSProps::kFontVariantKTable);
   case eCSSProperty_font_weight:
-    return ParseFontWeight(aErrorCode, aValue);
+    return ParseFontWeight(aValue);
   case eCSSProperty_ime_mode:
-    return ParseVariant(aErrorCode, aValue, VARIANT_AHK | VARIANT_NORMAL,
+    return ParseVariant(aValue, VARIANT_AHK | VARIANT_NORMAL,
                         nsCSSProps::kIMEModeKTable);
   case eCSSProperty_letter_spacing:
   case eCSSProperty_word_spacing:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HL | VARIANT_NORMAL, nsnull);
+    return ParseVariant(aValue, VARIANT_HL | VARIANT_NORMAL, nsnull);
   case eCSSProperty_line_height:
-    return ParsePositiveVariant(aErrorCode, aValue, VARIANT_HLPN | VARIANT_NORMAL | VARIANT_SYSFONT, nsnull);
+    return ParsePositiveVariant(aValue, VARIANT_HLPN | VARIANT_NORMAL | VARIANT_SYSFONT, nsnull);
   case eCSSProperty_list_style_image:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HUO, nsnull);
+    return ParseVariant(aValue, VARIANT_HUO, nsnull);
   case eCSSProperty_list_style_position:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HK, nsCSSProps::kListStylePositionKTable);
+    return ParseVariant(aValue, VARIANT_HK, nsCSSProps::kListStylePositionKTable);
   case eCSSProperty_list_style_type:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HOK, nsCSSProps::kListStyleKTable);
+    return ParseVariant(aValue, VARIANT_HOK, nsCSSProps::kListStyleKTable);
   case eCSSProperty_margin_bottom:
   case eCSSProperty_margin_end_value: // for internal use
   case eCSSProperty_margin_left_value: // for internal use
   case eCSSProperty_margin_right_value: // for internal use
   case eCSSProperty_margin_start_value: // for internal use
   case eCSSProperty_margin_top:
-    return ParseVariant(aErrorCode, aValue, VARIANT_AHLP, nsnull);
+    return ParseVariant(aValue, VARIANT_AHLP, nsnull);
   case eCSSProperty_marker_offset:
-    return ParseVariant(aErrorCode, aValue, VARIANT_AHL, nsnull);
+    return ParseVariant(aValue, VARIANT_AHL, nsnull);
   case eCSSProperty_marks:
-    return ParseMarks(aErrorCode, aValue);
+    return ParseMarks(aValue);
   case eCSSProperty_max_height:
-    return ParsePositiveVariant(aErrorCode, aValue, VARIANT_HLPO, nsnull);
+    return ParsePositiveVariant(aValue, VARIANT_HLPO, nsnull);
   case eCSSProperty_max_width:
-    return ParsePositiveVariant(aErrorCode, aValue, VARIANT_HKLPO,
+    return ParsePositiveVariant(aValue, VARIANT_HKLPO,
                                 nsCSSProps::kWidthKTable);
   case eCSSProperty_min_height:
-    return ParsePositiveVariant(aErrorCode, aValue, VARIANT_HLP, nsnull);
+    return ParsePositiveVariant(aValue, VARIANT_HLP, nsnull);
   case eCSSProperty_min_width:
-    return ParsePositiveVariant(aErrorCode, aValue, VARIANT_HKLP,
+    return ParsePositiveVariant(aValue, VARIANT_HKLP,
                                 nsCSSProps::kWidthKTable);
   case eCSSProperty_opacity:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HN, nsnull);
+    return ParseVariant(aValue, VARIANT_HN, nsnull);
   case eCSSProperty_orphans:
   case eCSSProperty_widows:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HI, nsnull);
+    return ParseVariant(aValue, VARIANT_HI, nsnull);
   case eCSSProperty_outline_color:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HCK, 
+    return ParseVariant(aValue, VARIANT_HCK,
                         nsCSSProps::kOutlineColorKTable);
   case eCSSProperty_outline_style:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HOK | VARIANT_AUTO, 
+    return ParseVariant(aValue, VARIANT_HOK | VARIANT_AUTO,
                         nsCSSProps::kOutlineStyleKTable);
   case eCSSProperty_outline_width:
-    return ParsePositiveVariant(aErrorCode, aValue, VARIANT_HKL,
+    return ParsePositiveVariant(aValue, VARIANT_HKL,
                                 nsCSSProps::kBorderWidthKTable);
   case eCSSProperty_outline_offset:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HL, nsnull);
+    return ParseVariant(aValue, VARIANT_HL, nsnull);
   case eCSSProperty_overflow_x:
   case eCSSProperty_overflow_y:
-    return ParseVariant(aErrorCode, aValue, VARIANT_AHK,
+    return ParseVariant(aValue, VARIANT_AHK,
                         nsCSSProps::kOverflowSubKTable);
   case eCSSProperty_padding_bottom:
   case eCSSProperty_padding_end_value: // for internal use
   case eCSSProperty_padding_left_value: // for internal use
   case eCSSProperty_padding_right_value: // for internal use
   case eCSSProperty_padding_start_value: // for internal use
   case eCSSProperty_padding_top:
-    return ParsePositiveVariant(aErrorCode, aValue, VARIANT_HLP, nsnull);
+    return ParsePositiveVariant(aValue, VARIANT_HLP, nsnull);
   case eCSSProperty_page:
-    return ParseVariant(aErrorCode, aValue, VARIANT_AUTO | VARIANT_IDENTIFIER, nsnull);
+    return ParseVariant(aValue, VARIANT_AUTO | VARIANT_IDENTIFIER, nsnull);
   case eCSSProperty_page_break_after:
   case eCSSProperty_page_break_before:
-    return ParseVariant(aErrorCode, aValue, VARIANT_AHK, 
+    return ParseVariant(aValue, VARIANT_AHK,
                         nsCSSProps::kPageBreakKTable);
   case eCSSProperty_page_break_inside:
-    return ParseVariant(aErrorCode, aValue, VARIANT_AHK, 
+    return ParseVariant(aValue, VARIANT_AHK,
                         nsCSSProps::kPageBreakInsideKTable);
   case eCSSProperty_pause_after:
   case eCSSProperty_pause_before:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HTP, nsnull);
+    return ParseVariant(aValue, VARIANT_HTP, nsnull);
   case eCSSProperty_pitch:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HKF, nsCSSProps::kPitchKTable);
+    return ParseVariant(aValue, VARIANT_HKF, nsCSSProps::kPitchKTable);
   case eCSSProperty_pitch_range:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HN, nsnull);
+    return ParseVariant(aValue, VARIANT_HN, nsnull);
   case eCSSProperty_position:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HK, nsCSSProps::kPositionKTable);
+    return ParseVariant(aValue, VARIANT_HK, nsCSSProps::kPositionKTable);
   case eCSSProperty_richness:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HN, nsnull);
+    return ParseVariant(aValue, VARIANT_HN, nsnull);
 #ifdef MOZ_MATHML
   // script-level can take Integer or Number values, but only Integer ("relative")
   // values can be specified in a style sheet. Also we only allow this property
   // when unsafe rules are enabled, because otherwise it could interfere
   // with rulenode optimizations if used in a non-MathML-enabled document.
   case eCSSProperty_script_level:
     if (!mUnsafeRulesEnabled)
       return PR_FALSE;
-    return ParseVariant(aErrorCode, aValue, VARIANT_HI, nsnull);
+    return ParseVariant(aValue, VARIANT_HI, nsnull);
 #endif
   case eCSSProperty_speak:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HMK | VARIANT_NONE,
+    return ParseVariant(aValue, VARIANT_HMK | VARIANT_NONE,
                         nsCSSProps::kSpeakKTable);
   case eCSSProperty_speak_header:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HK,
+    return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kSpeakHeaderKTable);
   case eCSSProperty_speak_numeral:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HK,
+    return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kSpeakNumeralKTable);
   case eCSSProperty_speak_punctuation:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HOK,
+    return ParseVariant(aValue, VARIANT_HOK,
                         nsCSSProps::kSpeakPunctuationKTable);
   case eCSSProperty_speech_rate:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HN | VARIANT_KEYWORD,
+    return ParseVariant(aValue, VARIANT_HN | VARIANT_KEYWORD,
                         nsCSSProps::kSpeechRateKTable);
   case eCSSProperty_stack_sizing:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HK,
+    return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kStackSizingKTable);
   case eCSSProperty_stress:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HN, nsnull);
+    return ParseVariant(aValue, VARIANT_HN, nsnull);
   case eCSSProperty_table_layout:
-    return ParseVariant(aErrorCode, aValue, VARIANT_AHK,
+    return ParseVariant(aValue, VARIANT_AHK,
                         nsCSSProps::kTableLayoutKTable);
   case eCSSProperty_text_align:
     // When we support aligning on a string, we can parse text-align
     // as a string....
-    return ParseVariant(aErrorCode, aValue, VARIANT_HK /* | VARIANT_STRING */,
+    return ParseVariant(aValue, VARIANT_HK /* | VARIANT_STRING */,
                         nsCSSProps::kTextAlignKTable);
   case eCSSProperty_text_decoration:
-    return ParseTextDecoration(aErrorCode, aValue);
+    return ParseTextDecoration(aValue);
   case eCSSProperty_text_indent:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HLP, nsnull);
+    return ParseVariant(aValue, VARIANT_HLP, nsnull);
   case eCSSProperty_text_transform:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HOK,
+    return ParseVariant(aValue, VARIANT_HOK,
                         nsCSSProps::kTextTransformKTable);
   case eCSSProperty_unicode_bidi:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HMK,
+    return ParseVariant(aValue, VARIANT_HMK,
                         nsCSSProps::kUnicodeBidiKTable);
   case eCSSProperty_user_focus:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HMK | VARIANT_NONE,
+    return ParseVariant(aValue, VARIANT_HMK | VARIANT_NONE,
                         nsCSSProps::kUserFocusKTable);
   case eCSSProperty_user_input:
-    return ParseVariant(aErrorCode, aValue, VARIANT_AHK | VARIANT_NONE,
+    return ParseVariant(aValue, VARIANT_AHK | VARIANT_NONE,
                         nsCSSProps::kUserInputKTable);
   case eCSSProperty_user_modify:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HK,
+    return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kUserModifyKTable);
   case eCSSProperty_user_select:
-    return ParseVariant(aErrorCode, aValue, VARIANT_AHK | VARIANT_NONE,
+    return ParseVariant(aValue, VARIANT_AHK | VARIANT_NONE,
                         nsCSSProps::kUserSelectKTable);
   case eCSSProperty_vertical_align:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HKLP,
+    return ParseVariant(aValue, VARIANT_HKLP,
                         nsCSSProps::kVerticalAlignKTable);
   case eCSSProperty_visibility:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HK, 
+    return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kVisibilityKTable);
   case eCSSProperty_voice_family:
-    return ParseFamily(aErrorCode, aValue);
+    return ParseFamily(aValue);
   case eCSSProperty_volume:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HPN | VARIANT_KEYWORD,
+    return ParseVariant(aValue, VARIANT_HPN | VARIANT_KEYWORD,
                         nsCSSProps::kVolumeKTable);
   case eCSSProperty_white_space:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HMK,
+    return ParseVariant(aValue, VARIANT_HMK,
                         nsCSSProps::kWhitespaceKTable);
   case eCSSProperty_word_wrap:
-    return ParseVariant(aErrorCode, aValue, VARIANT_HMK,
+    return ParseVariant(aValue, VARIANT_HMK,
                         nsCSSProps::kWordwrapKTable);
   case eCSSProperty_z_index:
-    return ParseVariant(aErrorCode, aValue, VARIANT_AHI, nsnull);
+    return ParseVariant(aValue, VARIANT_AHI, nsnull);
   }
   // explicitly do NOT have a default case to let the compiler
   // help find missing properties
   return PR_FALSE;
 }
 
 // nsFont::EnumerateFamilies callback for ParseFontDescriptorValue
 struct NS_STACK_CLASS ExtractFirstFamilyData {
@@ -5522,25 +5469,24 @@ ExtractFirstFamily(const nsString& aFami
   realData->mFamilyName.Assign(aFamily);
   realData->mGood = PR_TRUE;
   return PR_TRUE;
 }
 
 // font-descriptor: descriptor ':' value ';'
 // caller has advanced mToken to point at the descriptor
 PRBool
-CSSParserImpl::ParseFontDescriptorValue(nsresult& aErrorCode,
-                                        nsCSSFontDesc aDescID,
+CSSParserImpl::ParseFontDescriptorValue(nsCSSFontDesc aDescID,
                                         nsCSSValue& aValue)
 {
   switch (aDescID) {
     // These four are similar to the properties of the same name,
     // possibly with more restrictions on the values they can take.
   case eCSSFontDesc_Family: {
-    if (!ParseFamily(aErrorCode, aValue) ||
+    if (!ParseFamily(aValue) ||
         aValue.GetUnit() != eCSSUnit_String)
       return PR_FALSE;
 
     // the style parameters to the nsFont constructor are ignored,
     // because it's only being used to call EnumerateFamilies
     nsAutoString valueStr;
     aValue.GetStringValue(valueStr);
     nsFont font(valueStr, 0, 0, 0, 0, 0);
@@ -5551,41 +5497,41 @@ CSSParserImpl::ParseFontDescriptorValue(
       return PR_FALSE;
 
     aValue.SetStringValue(dat.mFamilyName, eCSSUnit_String);
     return PR_TRUE;
   }
 
   case eCSSFontDesc_Style:
     // property is VARIANT_HMK|VARIANT_SYSFONT
-    return ParseVariant(aErrorCode, aValue, VARIANT_KEYWORD | VARIANT_NORMAL,
+    return ParseVariant(aValue, VARIANT_KEYWORD | VARIANT_NORMAL,
                         nsCSSProps::kFontStyleKTable);
 
   case eCSSFontDesc_Weight:
-    return (ParseFontWeight(aErrorCode, aValue) &&
+    return (ParseFontWeight(aValue) &&
             aValue.GetUnit() != eCSSUnit_Inherit &&
             aValue.GetUnit() != eCSSUnit_Initial &&
             (aValue.GetUnit() != eCSSUnit_Enumerated ||
              (aValue.GetIntValue() != NS_STYLE_FONT_WEIGHT_BOLDER &&
               aValue.GetIntValue() != NS_STYLE_FONT_WEIGHT_LIGHTER)));
 
   case eCSSFontDesc_Stretch:
     // property is VARIANT_HMK|VARIANT_SYSFONT
-    return (ParseVariant(aErrorCode, aValue, VARIANT_KEYWORD | VARIANT_NORMAL,
+    return (ParseVariant(aValue, VARIANT_KEYWORD | VARIANT_NORMAL,
                          nsCSSProps::kFontStretchKTable) &&
             (aValue.GetUnit() != eCSSUnit_Enumerated ||
              (aValue.GetIntValue() != NS_STYLE_FONT_STRETCH_WIDER &&
               aValue.GetIntValue() != NS_STYLE_FONT_STRETCH_NARROWER)));
 
     // These two are unique to @font-face and have their own special grammar.
   case eCSSFontDesc_Src:
-    return ParseFontSrc(aErrorCode, aValue);
+    return ParseFontSrc(aValue);
 
   case eCSSFontDesc_UnicodeRange:
-    return ParseFontRanges(aErrorCode, aValue);
+    return ParseFontRanges(aValue);
 
   case eCSSFontDesc_UNKNOWN:
   case eCSSFontDesc_COUNT:
     NS_NOTREACHED("bad nsCSSFontDesc code");
   }
   // explicitly do NOT have a default case to let the compiler
   // help find missing descriptors
   return PR_FALSE;
@@ -5596,30 +5542,31 @@ CSSParserImpl::InitBoxPropsAsPhysical(co
 {
   nsCSSValue physical(NS_BOXPROP_SOURCE_PHYSICAL, eCSSUnit_Enumerated);
   for (const nsCSSProperty *prop = aSourceProperties;
        *prop != eCSSProperty_UNKNOWN; ++prop) {
     AppendValue(*prop, physical);
   }
 }
 
-PRBool CSSParserImpl::ParseAzimuth(nsresult& aErrorCode, nsCSSValue& aValue)
-{
-  if (ParseVariant(aErrorCode, aValue, VARIANT_HK | VARIANT_ANGLE, 
+PRBool
+CSSParserImpl::ParseAzimuth(nsCSSValue& aValue)
+{
+  if (ParseVariant(aValue, VARIANT_HK | VARIANT_ANGLE,
                    nsCSSProps::kAzimuthKTable)) {
     if (eCSSUnit_Enumerated == aValue.GetUnit()) {
       PRInt32 intValue = aValue.GetIntValue();
-      if ((NS_STYLE_AZIMUTH_LEFT_SIDE <= intValue) && 
+      if ((NS_STYLE_AZIMUTH_LEFT_SIDE <= intValue) &&
           (intValue <= NS_STYLE_AZIMUTH_BEHIND)) {  // look for optional modifier
         nsCSSValue  modifier;
-        if (ParseEnum(aErrorCode, modifier, nsCSSProps::kAzimuthKTable)) {
+        if (ParseEnum(modifier, nsCSSProps::kAzimuthKTable)) {
           PRInt32 enumValue = modifier.GetIntValue();
-          if (((intValue == NS_STYLE_AZIMUTH_BEHIND) && 
+          if (((intValue == NS_STYLE_AZIMUTH_BEHIND) &&
                (NS_STYLE_AZIMUTH_LEFT_SIDE <= enumValue) && (enumValue <= NS_STYLE_AZIMUTH_RIGHT_SIDE)) ||
-              ((enumValue == NS_STYLE_AZIMUTH_BEHIND) && 
+              ((enumValue == NS_STYLE_AZIMUTH_BEHIND) &&
                (NS_STYLE_AZIMUTH_LEFT_SIDE <= intValue) && (intValue <= NS_STYLE_AZIMUTH_RIGHT_SIDE))) {
             aValue.SetIntValue(intValue | enumValue, eCSSUnit_Enumerated);
             return PR_TRUE;
           }
           // Put the unknown identifier back and return
           UngetToken();
           return PR_FALSE;
         }
@@ -5649,17 +5596,18 @@ BackgroundPositionMaskToCSSValue(PRInt32
     else if (aMask & BG_BOTTOM) {
       val = NS_STYLE_BG_POSITION_BOTTOM;
     }
   }
 
   return nsCSSValue(val, eCSSUnit_Enumerated);
 }
 
-PRBool CSSParserImpl::ParseBackground(nsresult& aErrorCode)
+PRBool
+CSSParserImpl::ParseBackground()
 {
   nsAutoParseCompoundProperty compound(this);
 
   // Fill in the values that the shorthand will set if we don't find
   // other values.
   mTempData.mColor.mBackColor.SetIntValue(NS_STYLE_BG_COLOR_TRANSPARENT,
                                           eCSSUnit_Enumerated);
   mTempData.SetPropertyBit(eCSSProperty_background_color);
@@ -5687,17 +5635,17 @@ PRBool CSSParserImpl::ParseBackground(ns
   // ParseBackgroundPosition to it (as a special case) and switch back
   // to using ParseChoice here.
 
   PRBool haveColor = PR_FALSE,
          haveImage = PR_FALSE,
          haveRepeat = PR_FALSE,
          haveAttach = PR_FALSE,
          havePosition = PR_FALSE;
-  while (GetToken(aErrorCode, PR_TRUE)) {
+  while (GetToken(PR_TRUE)) {
     nsCSSTokenType tt = mToken.mType;
     UngetToken(); // ...but we'll still cheat and use mToken
     if (tt == eCSSToken_Symbol) {
       // ExpectEndProperty only looks for symbols, and nothing else will
       // show up as one.
       break;
     }
 
@@ -5705,17 +5653,17 @@ PRBool CSSParserImpl::ParseBackground(ns
       nsCSSKeyword keyword = nsCSSKeywords::LookupKeyword(mToken.mIdent);
       PRInt32 dummy;
       if (keyword == eCSSKeyword_inherit ||
           keyword == eCSSKeyword__moz_initial) {
         if (haveColor || haveImage || haveRepeat || haveAttach || havePosition)
           return PR_FALSE;
         haveColor = haveImage = haveRepeat = haveAttach = havePosition =
           PR_TRUE;
-        GetToken(aErrorCode, PR_TRUE); // undo the UngetToken above
+        GetToken(PR_TRUE); // undo the UngetToken above
         nsCSSValue val;
         if (keyword == eCSSKeyword_inherit) {
           val.SetInheritValue();
         } else {
           val.SetInitialValue();
         }
         mTempData.mColor.mBackColor = val;
         mTempData.mColor.mBackImage = val;
@@ -5729,118 +5677,119 @@ PRBool CSSParserImpl::ParseBackground(ns
         mTempData.mColor.mBackClip = val;
         mTempData.mColor.mBackOrigin = val;
         mTempData.mColor.mBackInlinePolicy = val;
         break;
       } else if (keyword == eCSSKeyword_none) {
         if (haveImage)
           return PR_FALSE;
         haveImage = PR_TRUE;
-        if (!ParseSingleValueProperty(aErrorCode, mTempData.mColor.mBackImage,
+        if (!ParseSingleValueProperty(mTempData.mColor.mBackImage,
                                       eCSSProperty_background_image)) {
           NS_NOTREACHED("should be able to parse");
           return PR_FALSE;
         }
       } else if (nsCSSProps::FindKeyword(keyword,
                    nsCSSProps::kBackgroundAttachmentKTable, dummy)) {
         if (haveAttach)
           return PR_FALSE;
         haveAttach = PR_TRUE;
-        if (!ParseSingleValueProperty(aErrorCode,
-                                      mTempData.mColor.mBackAttachment,
+        if (!ParseSingleValueProperty(mTempData.mColor.mBackAttachment,
                                       eCSSProperty_background_attachment)) {
           NS_NOTREACHED("should be able to parse");
           return PR_FALSE;
         }
       } else if (nsCSSProps::FindKeyword(keyword,
                    nsCSSProps::kBackgroundRepeatKTable, dummy)) {
         if (haveRepeat)
           return PR_FALSE;
         haveRepeat = PR_TRUE;
-        if (!ParseSingleValueProperty(aErrorCode, mTempData.mColor.mBackRepeat,
+        if (!ParseSingleValueProperty(mTempData.mColor.mBackRepeat,
                                       eCSSProperty_background_repeat)) {
           NS_NOTREACHED("should be able to parse");
           return PR_FALSE;
         }
       } else if (nsCSSProps::FindKeyword(keyword,
                    nsCSSProps::kBackgroundPositionKTable, dummy)) {
         if (havePosition)
           return PR_FALSE;
         havePosition = PR_TRUE;
-        if (!ParseBackgroundPositionValues(aErrorCode)) {
+        if (!ParseBackgroundPositionValues()) {
           return PR_FALSE;
         }
       } else {
         if (haveColor)
           return PR_FALSE;
         haveColor = PR_TRUE;
-        if (!ParseSingleValueProperty(aErrorCode, mTempData.mColor.mBackColor,
+        if (!ParseSingleValueProperty(mTempData.mColor.mBackColor,
                                       eCSSProperty_background_color)) {
           return PR_FALSE;
         }
       }
-    } else if (eCSSToken_Function == tt && 
+    } else if (eCSSToken_Function == tt &&
                mToken.mIdent.LowerCaseEqualsLiteral("url")) {
       if (haveImage)
         return PR_FALSE;
       haveImage = PR_TRUE;
-      if (!ParseSingleValueProperty(aErrorCode, mTempData.mColor.mBackImage,
+      if (!ParseSingleValueProperty(mTempData.mColor.mBackImage,
                                     eCSSProperty_background_image)) {
         return PR_FALSE;
       }
     } else if (mToken.IsDimension() || tt == eCSSToken_Percentage) {
       if (havePosition)
         return PR_FALSE;
       havePosition = PR_TRUE;
-      if (!ParseBackgroundPositionValues(aErrorCode)) {
+      if (!ParseBackgroundPositionValues()) {
         return PR_FALSE;
       }
     } else {
       if (haveColor)
         return PR_FALSE;
       haveColor = PR_TRUE;
-      if (!ParseSingleValueProperty(aErrorCode, mTempData.mColor.mBackColor,
+      if (!ParseSingleValueProperty(mTempData.mColor.mBackColor,
                                     eCSSProperty_background_color)) {
         return PR_FALSE;
       }
     }
   }
 
-  return ExpectEndProperty(aErrorCode) &&
+  return ExpectEndProperty() &&
          (haveColor || haveImage || haveRepeat || haveAttach || havePosition);
 }
 
-PRBool CSSParserImpl::ParseBackgroundPosition(nsresult& aErrorCode)
-{
-  if (!ParseBackgroundPositionValues(aErrorCode) ||
-      !ExpectEndProperty(aErrorCode)) 
+PRBool
+CSSParserImpl::ParseBackgroundPosition()
+{
+  if (!ParseBackgroundPositionValues() ||
+      !ExpectEndProperty())
     return PR_FALSE;
   mTempData.SetPropertyBit(eCSSProperty_background_position);
   return PR_TRUE;
 }
 
-PRBool CSSParserImpl::ParseBackgroundPositionValues(nsresult& aErrorCode)
+PRBool
+CSSParserImpl::ParseBackgroundPositionValues()
 {
   // First try a percentage or a length value
   nsCSSValue &xValue = mTempData.mColor.mBackPosition.mXValue,
              &yValue = mTempData.mColor.mBackPosition.mYValue;
-  if (ParseVariant(aErrorCode, xValue, VARIANT_HLP, nsnull)) {
+  if (ParseVariant(xValue, VARIANT_HLP, nsnull)) {
     if (eCSSUnit_Inherit == xValue.GetUnit() ||
         eCSSUnit_Initial == xValue.GetUnit()) {  // both are inherited or both are set to initial
       yValue = xValue;
       return PR_TRUE;
     }
     // We have one percentage/length. Get the optional second
     // percentage/length/keyword.
-    if (ParseVariant(aErrorCode, yValue, VARIANT_LP, nsnull)) {
+    if (ParseVariant(yValue, VARIANT_LP, nsnull)) {
       // We have two numbers
       return PR_TRUE;
     }
 
-    if (ParseEnum(aErrorCode, yValue, nsCSSProps::kBackgroundPositionKTable)) {
+    if (ParseEnum(yValue, nsCSSProps::kBackgroundPositionKTable)) {
       PRInt32 yVal = yValue.GetIntValue();
       if (!(yVal & BG_CTB)) {
         // The second keyword can only be 'center', 'top', or 'bottom'
         return PR_FALSE;
       }
       yValue = BackgroundPositionMaskToCSSValue(yVal, PR_FALSE);
       return PR_TRUE;
     }
@@ -5853,30 +5802,30 @@ PRBool CSSParserImpl::ParseBackgroundPos
 
   // Now try keywords. We do this manually to allow for the first
   // appearance of "center" to apply to the either the x or y
   // position (it's ambiguous so we have to disambiguate). Each
   // allowed keyword value is assigned it's own bit. We don't allow
   // any duplicate keywords other than center. We try to get two
   // keywords but it's okay if there is only one.
   PRInt32 mask = 0;
-  if (ParseEnum(aErrorCode, xValue, nsCSSProps::kBackgroundPositionKTable)) {
+  if (ParseEnum(xValue, nsCSSProps::kBackgroundPositionKTable)) {
     PRInt32 bit = xValue.GetIntValue();
     mask |= bit;
-    if (ParseEnum(aErrorCode, xValue, nsCSSProps::kBackgroundPositionKTable)) {
+    if (ParseEnum(xValue, nsCSSProps::kBackgroundPositionKTable)) {
       bit = xValue.GetIntValue();
       if (mask & (bit & ~BG_CENTER)) {
         // Only the 'center' keyword can be duplicated.
         return PR_FALSE;
       }
       mask |= bit;
     }
     else {
       // Only one keyword.  See if we have a length or percentage.
-      if (ParseVariant(aErrorCode, yValue, VARIANT_LP, nsnull)) {
+      if (ParseVariant(yValue, VARIANT_LP, nsnull)) {
         if (!(mask & BG_CLR)) {
           // The first keyword can only be 'center', 'left', or 'right'
           return PR_FALSE;
         }
 
         xValue = BackgroundPositionMaskToCSSValue(mask, PR_TRUE);
         return PR_TRUE;
       }
@@ -5923,158 +5872,157 @@ static const nsCSSProperty kBorderRadius
 };
 static const nsCSSProperty kOutlineRadiusIDs[] = {
   eCSSProperty__moz_outline_radius_topLeft,
   eCSSProperty__moz_outline_radius_topRight,
   eCSSProperty__moz_outline_radius_bottomRight,
   eCSSProperty__moz_outline_radius_bottomLeft
 };
 
-PRBool CSSParserImpl::ParseBorderColor(nsresult& aErrorCode)
+PRBool
+CSSParserImpl::ParseBorderColor()
 {
   static const nsCSSProperty kBorderColorSources[] = {
     eCSSProperty_border_left_color_ltr_source,
     eCSSProperty_border_left_color_rtl_source,
     eCSSProperty_border_right_color_ltr_source,
     eCSSProperty_border_right_color_rtl_source,
     eCSSProperty_UNKNOWN
   };
 
   // do this now, in case 4 values weren't specified
   InitBoxPropsAsPhysical(kBorderColorSources);
-  return ParseBoxProperties(aErrorCode, mTempData.mMargin.mBorderColor,
+  return ParseBoxProperties(mTempData.mMargin.mBorderColor,
                             kBorderColorIDs);
 }
 
-PRBool CSSParserImpl::ParseBorderImage(nsresult& aErrorCode)
-{
-  if (ParseVariant(aErrorCode, mTempData.mMargin.mBorderImage, 
+PRBool
+CSSParserImpl::ParseBorderImage()
+{
+  if (ParseVariant(mTempData.mMargin.mBorderImage,
                    VARIANT_INHERIT | VARIANT_NONE, nsnull)) {
     mTempData.SetPropertyBit(eCSSProperty_border_image);
     return PR_TRUE;
   }
-  
+
   // <uri> [<number> | <percentage>]{1,4} [ / <border-width>{1,4} ]? [stretch | repeat | round]{0,2}
   nsRefPtr<nsCSSValue::Array> arr = nsCSSValue::Array::Create(11);
   if (!arr) {
-    aErrorCode = NS_ERROR_OUT_OF_MEMORY;
-    return PR_FALSE;
-  }
-  
+    mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+    return PR_FALSE;
+  }
+
   nsCSSValue& url = arr->Item(0);
   nsCSSValue& splitTop = arr->Item(1);
   nsCSSValue& splitRight = arr->Item(2);
   nsCSSValue& splitBottom = arr->Item(3);
   nsCSSValue& splitLeft = arr->Item(4);
   nsCSSValue& borderWidthTop = arr->Item(5);
   nsCSSValue& borderWidthRight = arr->Item(6);
   nsCSSValue& borderWidthBottom = arr->Item(7);
   nsCSSValue& borderWidthLeft = arr->Item(8);
   nsCSSValue& horizontalKeyword = arr->Item(9);
   nsCSSValue& verticalKeyword = arr->Item(10);
-  
+
   // <uri>
-  if (!ParseVariant(aErrorCode, url, VARIANT_URL, nsnull)) {
-    return PR_FALSE;
-  }
-  
+  if (!ParseVariant(url, VARIANT_URL, nsnull)) {
+    return PR_FALSE;
+  }
+
   // [<number> | <percentage>]{1,4}
-  if (!ParsePositiveVariant(aErrorCode, splitTop,
+  if (!ParsePositiveVariant(splitTop,
                             VARIANT_NUMBER | VARIANT_PERCENT, nsnull)) {
     return PR_FALSE;
   }
-  if (!ParsePositiveVariant(aErrorCode, splitRight,
+  if (!ParsePositiveVariant(splitRight,
                             VARIANT_NUMBER | VARIANT_PERCENT, nsnull)) {
     splitRight = splitTop;
   }
-  if (!ParsePositiveVariant(aErrorCode, splitBottom,
+  if (!ParsePositiveVariant(splitBottom,
                             VARIANT_NUMBER | VARIANT_PERCENT, nsnull)) {
     splitBottom = splitTop;
   }
-  if (!ParsePositiveVariant(aErrorCode, splitLeft,
+  if (!ParsePositiveVariant(splitLeft,
                             VARIANT_NUMBER | VARIANT_PERCENT, nsnull)) {
     splitLeft = splitRight;
   }
-  
+
   // [ / <border-width>{1,4} ]?
-  if (ExpectSymbol(aErrorCode, '/', PR_TRUE)) {
+  if (ExpectSymbol('/', PR_TRUE)) {
     // if have '/', at least one value is required
-    if (!ParsePositiveVariant(aErrorCode, borderWidthTop,
-                              VARIANT_LENGTH, nsnull)) {
-      return PR_FALSE;
-    }
-    if (!ParsePositiveVariant(aErrorCode, borderWidthRight,
-                              VARIANT_LENGTH, nsnull)) {
+    if (!ParsePositiveVariant(borderWidthTop, VARIANT_LENGTH, nsnull)) {
+      return PR_FALSE;
+    }
+    if (!ParsePositiveVariant(borderWidthRight, VARIANT_LENGTH, nsnull)) {
       borderWidthRight = borderWidthTop;
     }
-    if (!ParsePositiveVariant(aErrorCode, borderWidthBottom,
-                              VARIANT_LENGTH, nsnull)) {
+    if (!ParsePositiveVariant(borderWidthBottom, VARIANT_LENGTH, nsnull)) {
       borderWidthBottom = borderWidthTop;
     }
-    if (!ParsePositiveVariant(aErrorCode, borderWidthLeft,
-                              VARIANT_LENGTH, nsnull)) {
+    if (!ParsePositiveVariant(borderWidthLeft, VARIANT_LENGTH, nsnull)) {
       borderWidthLeft = borderWidthRight;
     }
   }
-  
+
   // [stretch | repeat | round]{0,2}
   // missing keywords are handled in nsRuleNode::ComputeBorderData()
-  if (ParseEnum(aErrorCode, horizontalKeyword, nsCSSProps::kBorderImageKTable)) {
-    ParseEnum(aErrorCode, verticalKeyword, nsCSSProps::kBorderImageKTable);
-  }
-  
-  if (!ExpectEndProperty(aErrorCode)) {
-    return PR_FALSE;
-  }
-  
+  if (ParseEnum(horizontalKeyword, nsCSSProps::kBorderImageKTable)) {
+    ParseEnum(verticalKeyword, nsCSSProps::kBorderImageKTable);
+  }
+
+  if (!ExpectEndProperty()) {
+    return PR_FALSE;
+  }
+
   mTempData.mMargin.mBorderImage.SetArrayValue(arr, eCSSUnit_Array);
   mTempData.SetPropertyBit(eCSSProperty_border_image);
-  
-  return PR_TRUE;
-}
-
-PRBool CSSParserImpl::ParseBorderSpacing(nsresult& aErrorCode)
+
+  return PR_TRUE;
+}
+
+PRBool
+CSSParserImpl::ParseBorderSpacing()
 {
   nsCSSValue  xValue;
-  if (ParsePositiveVariant(aErrorCode, xValue, VARIANT_HL, nsnull)) {
+  if (ParsePositiveVariant(xValue, VARIANT_HL, nsnull)) {
     if (xValue.IsLengthUnit()) {
       // We have one length. Get the optional second length.
       nsCSSValue yValue;
-      if (ParsePositiveVariant(aErrorCode, yValue, VARIANT_LENGTH, nsnull)) {
+      if (ParsePositiveVariant(yValue, VARIANT_LENGTH, nsnull)) {
         // We have two numbers
-        if (ExpectEndProperty(aErrorCode)) {
+        if (ExpectEndProperty()) {
           mTempData.mTable.mBorderSpacing.mXValue = xValue;
           mTempData.mTable.mBorderSpacing.mYValue = yValue;
           mTempData.SetPropertyBit(eCSSProperty_border_spacing);
           return PR_TRUE;
         }
         return PR_FALSE;
       }
     }
 
     // We have one length which is the horizontal spacing. Create a value for
     // the vertical spacing which is equal
-    if (ExpectEndProperty(aErrorCode)) {
+    if (ExpectEndProperty()) {
       mTempData.mTable.mBorderSpacing.SetBothValuesTo(xValue);
       mTempData.SetPropertyBit(eCSSProperty_border_spacing);
       return PR_TRUE;
     }
   }
   return PR_FALSE;
 }
 
-PRBool CSSParserImpl::ParseBorderSide(nsresult& aErrorCode,
-                                      const nsCSSProperty aPropIDs[],
-                                      PRBool aSetAllSides)
+PRBool
+CSSParserImpl::ParseBorderSide(const nsCSSProperty aPropIDs[],
+                               PRBool aSetAllSides)
 {
   const PRInt32 numProps = 3;
   nsCSSValue  values[numProps];
 
-  PRInt32 found = ParseChoice(aErrorCode, values, aPropIDs, numProps);
-  if ((found < 1) || (PR_FALSE == ExpectEndProperty(aErrorCode))) {
+  PRInt32 found = ParseChoice(values, aPropIDs, numProps);
+  if ((found < 1) || (PR_FALSE == ExpectEndProperty())) {
     return PR_FALSE;
   }
 
   if ((found & 1) == 0) { // Provide default border-width
     values[0].SetIntValue(NS_STYLE_BORDER_WIDTH_MEDIUM, eCSSUnit_Enumerated);
   }
   if ((found & 2) == 0) { // Provide default border-style
     values[1].SetNoneValue();
@@ -6103,36 +6051,36 @@ PRBool CSSParserImpl::ParseBorderSide(ns
     InitBoxPropsAsPhysical(kBorderSources);
 
     // Parsing "border" shorthand; set all four sides to the same thing
     for (PRInt32 index = 0; index < 4; index++) {
       NS_ASSERTION(numProps == 3, "This code needs updating");
       AppendValue(kBorderWidthIDs[index], values[0]);
       AppendValue(kBorderStyleIDs[index], values[1]);
       AppendValue(kBorderColorIDs[index], values[2]);
-    }   
+    }
   }
   else {
     // Just set our one side
     for (PRInt32 index = 0; index < numProps; index++) {
       AppendValue(aPropIDs[index], values[index]);
     }
   }
   return PR_TRUE;
 }
 
-PRBool CSSParserImpl::ParseDirectionalBorderSide(nsresult& aErrorCode,
-                         const nsCSSProperty aPropIDs[],
-                         PRInt32 aSourceType)
+PRBool
+CSSParserImpl::ParseDirectionalBorderSide(const nsCSSProperty aPropIDs[],
+                                          PRInt32 aSourceType)
 {
   const PRInt32 numProps = 3;
   nsCSSValue  values[numProps];
 
-  PRInt32 found = ParseChoice(aErrorCode, values, aPropIDs, numProps);
-  if ((found < 1) || (PR_FALSE == ExpectEndProperty(aErrorCode))) {
+  PRInt32 found = ParseChoice(values, aPropIDs, numProps);
+  if ((found < 1) || (PR_FALSE == ExpectEndProperty())) {
     return PR_FALSE;
   }
 
   if ((found & 1) == 0) { // Provide default border-width
     values[0].SetIntValue(NS_STYLE_BORDER_WIDTH_MEDIUM, eCSSUnit_Enumerated);
   }
   if ((found & 2) == 0) { // Provide default border-style
     values[1].SetNoneValue();
@@ -6148,385 +6096,388 @@ PRBool CSSParserImpl::ParseDirectionalBo
     AppendValue(subprops[0], values[index]);
     nsCSSValue typeVal(aSourceType, eCSSUnit_Enumerated);
     AppendValue(subprops[1], typeVal);
     AppendValue(subprops[2], typeVal);
   }
   return PR_TRUE;
 }
 
-PRBool CSSParserImpl::ParseBorderStyle(nsresult& aErrorCode)
+PRBool
+CSSParserImpl::ParseBorderStyle()
 {
   static const nsCSSProperty kBorderStyleSources[] = {
     eCSSProperty_border_left_style_ltr_source,
     eCSSProperty_border_left_style_rtl_source,
     eCSSProperty_border_right_style_ltr_source,
     eCSSProperty_border_right_style_rtl_source,
     eCSSProperty_UNKNOWN
   };
 
   // do this now, in case 4 values weren't specified
   InitBoxPropsAsPhysical(kBorderStyleSources);
-  return ParseBoxProperties(aErrorCode, mTempData.mMargin.mBorderStyle,
+  return ParseBoxProperties(mTempData.mMargin.mBorderStyle,
                             kBorderStyleIDs);
 }
 
-PRBool CSSParserImpl::ParseBorderWidth(nsresult& aErrorCode)
+PRBool
+CSSParserImpl::ParseBorderWidth()
 {
   static const nsCSSProperty kBorderWidthSources[] = {
     eCSSProperty_border_left_width_ltr_source,
     eCSSProperty_border_left_width_rtl_source,
     eCSSProperty_border_right_width_ltr_source,
     eCSSProperty_border_right_width_rtl_source,
     eCSSProperty_UNKNOWN
   };
 
   // do this now, in case 4 values weren't specified
   InitBoxPropsAsPhysical(kBorderWidthSources);
-  return ParseBoxProperties(aErrorCode, mTempData.mMargin.mBorderWidth,
+  return ParseBoxProperties(mTempData.mMargin.mBorderWidth,
                             kBorderWidthIDs);
 }
 
-PRBool CSSParserImpl::ParseBorderRadius(nsresult& aErrorCode)
-{
-  return ParseBoxProperties(aErrorCode, mTempData.mMargin.mBorderRadius,
+PRBool
+CSSParserImpl::ParseBorderRadius()
+{
+  return ParseBoxProperties(mTempData.mMargin.mBorderRadius,
                             kBorderRadiusIDs);
 }
 
-PRBool CSSParserImpl::ParseOutlineRadius(nsresult& aErrorCode)
-{
-  return ParseBoxProperties(aErrorCode, mTempData.mMargin.mOutlineRadius,
+PRBool
+CSSParserImpl::ParseOutlineRadius()
+{
+  return ParseBoxProperties(mTempData.mMargin.mOutlineRadius,
                             kOutlineRadiusIDs);
 }
 
-PRBool CSSParserImpl::ParseBorderColors(nsresult& aErrorCode,
-                                        nsCSSValueList** aResult,
-                                        nsCSSProperty aProperty)
+PRBool
+CSSParserImpl::ParseBorderColors(nsCSSValueList** aResult,
+                                 nsCSSProperty aProperty)
 {
   nsCSSValue value;
-  if (ParseVariant(aErrorCode, value, VARIANT_HCK|VARIANT_NONE, nsCSSProps::kBorderColorKTable)) {
+  if (ParseVariant(value, VARIANT_HCK|VARIANT_NONE, nsCSSProps::kBorderColorKTable)) {
     nsCSSValueList* listHead = new nsCSSValueList();
     nsCSSValueList* list = listHead;
     if (!list) {
-      aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
       return PR_FALSE;
     }
     list->mValue = value;
 
     while (list) {
-      if (ExpectEndProperty(aErrorCode)) {
+      if (ExpectEndProperty()) {
         mTempData.SetPropertyBit(aProperty);
         *aResult = listHead;
-        aErrorCode = NS_OK;
         return PR_TRUE;
       }
       // FIXME Bug 389404: We should not accept inherit, -moz-initial,
       // or none as anything other than the first value.
-      if (ParseVariant(aErrorCode, value, VARIANT_HCK|VARIANT_NONE, nsCSSProps::kBorderColorKTable)) {
+      if (ParseVariant(value, VARIANT_HCK|VARIANT_NONE, nsCSSProps::kBorderColorKTable)) {
         list->mNext = new nsCSSValueList();
         list = list->mNext;
         if (list)
           list->mValue = value;
         else
-          aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+          mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
       }
       else
         break;
     }
     delete listHead;
   }
   return PR_FALSE;
 }
 
 PRBool
-CSSParserImpl::ParseRect(nsCSSRect& aRect, nsresult& aErrorCode,
-                         nsCSSProperty aPropID)
+CSSParserImpl::ParseRect(nsCSSRect& aRect, nsCSSProperty aPropID)
 {
   nsCSSRect rect;
   PRBool result;
-  if ((result = DoParseRect(rect, aErrorCode)) &&
+  if ((result = DoParseRect(rect)) &&
       rect != aRect) {
     aRect = rect;
     mTempData.SetPropertyBit(aPropID);
   }
   return result;
 }
 
 PRBool
-CSSParserImpl::DoParseRect(nsCSSRect& aRect, nsresult& aErrorCode)
-{
-  if (! GetToken(aErrorCode, PR_TRUE)) {
+CSSParserImpl::DoParseRect(nsCSSRect& aRect)
+{
+  if (! GetToken(PR_TRUE)) {
     return PR_FALSE;
   }
   if (eCSSToken_Ident == mToken.mType) {
     nsCSSKeyword keyword = nsCSSKeywords::LookupKeyword(mToken.mIdent);
     switch (keyword) {
       case eCSSKeyword_auto:
-        if (ExpectEndProperty(aErrorCode)) {
+        if (ExpectEndProperty()) {
           aRect.SetAllSidesTo(nsCSSValue(eCSSUnit_Auto));
           return PR_TRUE;
         }
         break;
       case eCSSKeyword_inherit:
-        if (ExpectEndProperty(aErrorCode)) {
+        if (ExpectEndProperty()) {
           aRect.SetAllSidesTo(nsCSSValue(eCSSUnit_Inherit));
           return PR_TRUE;
         }
         break;
       case eCSSKeyword__moz_initial:
-        if (ExpectEndProperty(aErrorCode)) {
+        if (ExpectEndProperty()) {
           aRect.SetAllSidesTo(nsCSSValue(eCSSUnit_Initial));
           return PR_TRUE;
         }
         break;
       default:
         UngetToken();
         break;
     }
-  } else if ((eCSSToken_Function == mToken.mType) && 
+  } else if ((eCSSToken_Function == mToken.mType) &&
              mToken.mIdent.LowerCaseEqualsLiteral("rect")) {
-    if (!ExpectSymbol(aErrorCode, '(', PR_TRUE)) {
+    if (!ExpectSymbol('(', PR_TRUE)) {
       return PR_FALSE;
     }
     NS_FOR_CSS_SIDES(side) {
-      if (! ParseVariant(aErrorCode, aRect.*(nsCSSRect::sides[side]),
+      if (! ParseVariant(aRect.*(nsCSSRect::sides[side]),
                          VARIANT_AL, nsnull)) {
         return PR_FALSE;
       }
       if (3 != side) {
         // skip optional commas between elements
-        ExpectSymbol(aErrorCode, ',', PR_TRUE);
-      }
-    }
-    if (!ExpectSymbol(aErrorCode, ')', PR_TRUE)) {
-      return PR_FALSE;
-    }
-    if (ExpectEndProperty(aErrorCode)) {
+        ExpectSymbol(',', PR_TRUE);
+      }
+    }
+    if (!ExpectSymbol(')', PR_TRUE)) {
+      return PR_FALSE;
+    }
+    if (ExpectEndProperty()) {
       return PR_TRUE;
     }
   } else {
     UngetToken();
   }
   return PR_FALSE;
 }
 
 #define VARIANT_CONTENT (VARIANT_STRING | VARIANT_URL | VARIANT_COUNTER | VARIANT_ATTR | \
                          VARIANT_KEYWORD)
-PRBool CSSParserImpl::ParseContent(nsresult& aErrorCode)
+PRBool
+CSSParserImpl::ParseContent()
 {
   // XXX Rewrite to make it look more like ParseCursor or ParseCounterData?
   nsCSSValue  value;
-  if (ParseVariant(aErrorCode, value,
+  if (ParseVariant(value,
                    VARIANT_CONTENT | VARIANT_INHERIT | VARIANT_NORMAL |
-                     VARIANT_NONE, 
+                     VARIANT_NONE,
                    nsCSSProps::kContentKTable)) {
     nsCSSValueList* listHead = new nsCSSValueList();
     nsCSSValueList* list = listHead;
     if (nsnull == list) {
-      aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
       return PR_FALSE;
     }
     list->mValue = value;
 
     while (nsnull != list) {
-      if (ExpectEndProperty(aErrorCode)) {
+      if (ExpectEndProperty()) {
         mTempData.SetPropertyBit(eCSSProperty_content);
         mTempData.mContent.mContent = listHead;
-        aErrorCode = NS_OK;
         return PR_TRUE;
       }
       if (eCSSUnit_Inherit == value.GetUnit() ||
           eCSSUnit_Initial == value.GetUnit() ||
           eCSSUnit_Normal == value.GetUnit() ||
           eCSSUnit_None == value.GetUnit() ||
           (eCSSUnit_Enumerated == value.GetUnit() &&
            NS_STYLE_CONTENT_ALT_CONTENT == value.GetIntValue())) {
         // This only matters the first time through the loop.
         delete listHead;
         return PR_FALSE;
       }
-      if (ParseVariant(aErrorCode, value, VARIANT_CONTENT, nsCSSProps::kContentKTable) &&
+      if (ParseVariant(value, VARIANT_CONTENT, nsCSSProps::kContentKTable) &&
           // Make sure we didn't end up with NS_STYLE_CONTENT_ALT_CONTENT here
           (value.GetUnit() != eCSSUnit_Enumerated ||
            value.GetIntValue() != NS_STYLE_CONTENT_ALT_CONTENT)) {
         list->mNext = new nsCSSValueList();
         list = list->mNext;
         if (nsnull != list) {
           list->mValue = value;
         }
         else {
-          aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+          mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
         }
       }
       else {
         break;
       }
     }
     delete listHead;
   }
   return PR_FALSE;
 }
 
 struct SingleCounterPropValue {
   char str[13];
   nsCSSUnit unit;
 };
 
-PRBool CSSParserImpl::ParseCounterData(nsresult& aErrorCode,
-                                       nsCSSValuePairList** aResult,
-                                       nsCSSProperty aPropID)
-{
-  nsSubstring* ident = NextIdent(aErrorCode);
+PRBool
+CSSParserImpl::ParseCounterData(nsCSSValuePairList** aResult,
+                                nsCSSProperty aPropID)
+{
+  nsSubstring* ident = NextIdent();
   if (nsnull == ident) {
     return PR_FALSE;
   }
   static const SingleCounterPropValue singleValues[] = {
     { "none", eCSSUnit_None },
     { "inherit", eCSSUnit_Inherit },
     { "-moz-initial", eCSSUnit_Initial }
   };
   for (const SingleCounterPropValue *sv = singleValues,
            *sv_end = singleValues + NS_ARRAY_LENGTH(singleValues);
        sv != sv_end; ++sv) {
     if (ident->LowerCaseEqualsASCII(sv->str)) {
-      if (ExpectEndProperty(aErrorCode)) {
+      if (ExpectEndProperty()) {
         nsCSSValuePairList* dataHead = new nsCSSValuePairList();
         if (!dataHead) {
-          aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+          mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
           return PR_FALSE;
         }
         dataHead->mXValue = nsCSSValue(sv->unit);
         *aResult = dataHead;
         mTempData.SetPropertyBit(aPropID);
         return PR_TRUE;
       }
       return PR_FALSE;
     }
   }
   UngetToken(); // undo NextIdent
 
   nsCSSValuePairList* dataHead = nsnull;
   nsCSSValuePairList **next = &dataHead;
   for (;;) {
-    if (!GetToken(aErrorCode, PR_TRUE) || mToken.mType != eCSSToken_Ident) {
+    if (!GetToken(PR_TRUE) || mToken.mType != eCSSToken_Ident) {
       break;
     }
     nsCSSValuePairList *data = *next = new nsCSSValuePairList();
     if (!data) {
-      aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
       break;
     }
     next = &data->mNext;
     data->mXValue.SetStringValue(mToken.mIdent, eCSSUnit_String);
-    if (GetToken(aErrorCode, PR_TRUE)) {
+    if (GetToken(PR_TRUE)) {
       if (eCSSToken_Number == mToken.mType && mToken.mIntegerValid) {
         data->mYValue.SetIntValue(mToken.mInteger, eCSSUnit_Integer);
       } else {
         UngetToken();
       }
     }
-    if (ExpectEndProperty(aErrorCode)) {
+    if (ExpectEndProperty()) {
       mTempData.SetPropertyBit(aPropID);
       *aResult = dataHead;
-      aErrorCode = NS_OK;
       return PR_TRUE;
     }
   }
   delete dataHead;
   return PR_FALSE;
 }
 
-PRBool CSSParserImpl::ParseCue(nsresult& aErrorCode)
+PRBool
+CSSParserImpl::ParseCue()
 {
   nsCSSValue before;
-  if (ParseSingleValueProperty(aErrorCode, before, eCSSProperty_cue_before)) {
+  if (ParseSingleValueProperty(before, eCSSProperty_cue_before)) {
     if (eCSSUnit_Inherit != before.GetUnit() &&
         eCSSUnit_Initial != before.GetUnit()) {
       nsCSSValue after;
-      if (ParseSingleValueProperty(aErrorCode, after, eCSSProperty_cue_after)) {
-        if (ExpectEndProperty(aErrorCode)) {
+      if (ParseSingleValueProperty(after, eCSSProperty_cue_after)) {
+        if (ExpectEndProperty()) {
           AppendValue(eCSSProperty_cue_before, before);
           AppendValue(eCSSProperty_cue_after, after);
           return PR_TRUE;
         }
         return PR_FALSE;
       }
     }
-    if (ExpectEndProperty(aErrorCode)) {
+    if (ExpectEndProperty()) {
       AppendValue(eCSSProperty_cue_before, before);
       AppendValue(eCSSProperty_cue_after, before);
       return PR_TRUE;
     }
   }
   return PR_FALSE;
 }
 
-PRBool CSSParserImpl::ParseCursor(nsresult& aErrorCode)
+PRBool
+CSSParserImpl::ParseCursor()
 {
   nsCSSValueList *list = nsnull;
   for (nsCSSValueList **curp = &list, *cur; ; curp = &cur->mNext) {
     cur = *curp = new nsCSSValueList();
     if (!cur) {
-      aErrorCode = NS_ERROR_OUT_OF_MEMORY;
-      break;
-    }
-    if (!ParseVariant(aErrorCode, cur->mValue,
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+      break;
+    }
+    if (!ParseVariant(cur->mValue,
                       (cur == list) ? VARIANT_AHUK : VARIANT_AUK,
                       nsCSSProps::kCursorKTable)) {
       break;
     }
     if (cur->mValue.GetUnit() != eCSSUnit_URL) {
-      if (!ExpectEndProperty(aErrorCode)) {
+      if (!ExpectEndProperty()) {
         break;
       }
       // Only success case here, since having the failure case at the
       // end allows more sharing of code.
       mTempData.SetPropertyBit(eCSSProperty_cursor);
       mTempData.mUserInterface.mCursor = list;
-      aErrorCode = NS_OK;
-      return PR_TRUE;
-    } 
+      return PR_TRUE;
+    }
     // We have a URL, so make a value array with three values.
     nsRefPtr<nsCSSValue::Array> val = nsCSSValue::Array::Create(3);
     if (!val) {
-      aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
       break;
     }
     val->Item(0) = cur->mValue;
     cur->mValue.SetArrayValue(val, eCSSUnit_Array);
 
     // Parse optional x and y position of cursor hotspot (css3-ui).
-    if (ParseVariant(aErrorCode, val->Item(1), VARIANT_NUMBER, nsnull)) {
+    if (ParseVariant(val->Item(1), VARIANT_NUMBER, nsnull)) {
       // If we have one number, we must have two.
-      if (!ParseVariant(aErrorCode, val->Item(2), VARIANT_NUMBER, nsnull)) {
-        break;
-      }
-    }
-
-    if (!ExpectSymbol(aErrorCode, ',', PR_TRUE)) {
+      if (!ParseVariant(val->Item(2), VARIANT_NUMBER, nsnull)) {
+        break;
+      }
+    }
+
+    if (!ExpectSymbol(',', PR_TRUE)) {
       break;
     }
   }
   // Have failure case at the end so we can |break| to get to it.
   delete list;
   return PR_FALSE;
 }
 
 
-PRBool CSSParserImpl::ParseFont(nsresult& aErrorCode)
+PRBool
+CSSParserImpl::ParseFont()
 {
   static const nsCSSProperty fontIDs[] = {
     eCSSProperty_font_style,
     eCSSProperty_font_variant,
     eCSSProperty_font_weight
   };
 
   nsCSSValue  family;
-  if (ParseVariant(aErrorCode, family, VARIANT_HK, nsCSSProps::kFontKTable)) {
-    if (ExpectEndProperty(aErrorCode)) {
+  if (ParseVariant(family, VARIANT_HK, nsCSSProps::kFontKTable)) {
+    if (ExpectEndProperty()) {
       if (eCSSUnit_Inherit == family.GetUnit() ||
           eCSSUnit_Initial == family.GetUnit()) {
         AppendValue(eCSSProperty__x_system_font, nsCSSValue(eCSSUnit_None));
         AppendValue(eCSSProperty_font_family, family);
         AppendValue(eCSSProperty_font_style, family);
         AppendValue(eCSSProperty_font_variant, family);
         AppendValue(eCSSProperty_font_weight, family);
         AppendValue(eCSSProperty_font_size, family);
@@ -6549,18 +6500,18 @@ PRBool CSSParserImpl::ParseFont(nsresult
       return PR_TRUE;
     }
     return PR_FALSE;
   }
 
   // Get optional font-style, font-variant and font-weight (in any order)
   const PRInt32 numProps = 3;
   nsCSSValue  values[numProps];
-  PRInt32 found = ParseChoice(aErrorCode, values, fontIDs, numProps);
-  if ((found < 0) || (eCSSUnit_Inherit == values[0].GetUnit()) || 
+  PRInt32 found = ParseChoice(values, fontIDs, numProps);
+  if ((found < 0) || (eCSSUnit_Inherit == values[0].GetUnit()) ||
       (eCSSUnit_Initial == values[0].GetUnit())) { // illegal data
     return PR_FALSE;
   }
   if ((found & 1) == 0) {
     // Provide default font-style
     values[0].SetNormalValue();
   }
   if ((found & 2) == 0) {
@@ -6569,91 +6520,93 @@ PRBool CSSParserImpl::ParseFont(nsresult
   }
   if ((found & 4) == 0) {
     // Provide default font-weight
     values[2].SetNormalValue();
   }
 
   // Get mandatory font-size
   nsCSSValue  size;
-  if (! ParseVariant(aErrorCode, size, VARIANT_KEYWORD | VARIANT_LP, nsCSSProps::kFontSizeKTable)) {
+  if (! ParseVariant(size, VARIANT_KEYWORD | VARIANT_LP, nsCSSProps::kFontSizeKTable)) {
     return PR_FALSE;
   }
 
   // Get optional "/" line-height
   nsCSSValue  lineHeight;
-  if (ExpectSymbol(aErrorCode, '/', PR_TRUE)) {
-    if (! ParsePositiveVariant(aErrorCode, lineHeight,
+  if (ExpectSymbol('/', PR_TRUE)) {
+    if (! ParsePositiveVariant(lineHeight,
                                VARIANT_NUMBER | VARIANT_LP | VARIANT_NORMAL,
                                nsnull)) {
       return PR_FALSE;
     }
   }
   else {
     lineHeight.SetNormalValue();
   }
 
   // Get final mandatory font-family
   nsAutoParseCompoundProperty compound(this);
-  if (ParseFamily(aErrorCode, family)) {
+  if (ParseFamily(family)) {
     if ((eCSSUnit_Inherit != family.GetUnit()) && (eCSSUnit_Initial != family.GetUnit()) &&
-        ExpectEndProperty(aErrorCode)) {
+        ExpectEndProperty()) {
       AppendValue(eCSSProperty__x_system_font, nsCSSValue(eCSSUnit_None));
       AppendValue(eCSSProperty_font_family, family);
       AppendValue(eCSSProperty_font_style, values[0]);
       AppendValue(eCSSProperty_font_variant, values[1]);
       AppendValue(eCSSProperty_font_weight, values[2]);
       AppendValue(eCSSProperty_font_size, size);
       AppendValue(eCSSProperty_line_height, lineHeight);
       AppendValue(eCSSProperty_font_stretch, nsCSSValue(eCSSUnit_Normal));
       AppendValue(eCSSProperty_font_size_adjust, nsCSSValue(eCSSUnit_None));
       return PR_TRUE;
     }
   }
   return PR_FALSE;
 }
 
-PRBool CSSParserImpl::ParseFontWeight(nsresult& aErrorCode, nsCSSValue& aValue)
-{
-  if (ParseVariant(aErrorCode, aValue, VARIANT_HMKI | VARIANT_SYSFONT, nsCSSProps::kFontWeightKTable)) {
+PRBool
+CSSParserImpl::ParseFontWeight(nsCSSValue& aValue)
+{
+  if (ParseVariant(aValue, VARIANT_HMKI | VARIANT_SYSFONT, nsCSSProps::kFontWeightKTable)) {
     if (eCSSUnit_Integer == aValue.GetUnit()) { // ensure unit value
       PRInt32 intValue = aValue.GetIntValue();
       if ((100 <= intValue) &&
           (intValue <= 900) &&
           (0 == (intValue % 100))) {
         return PR_TRUE;
       } else {
         UngetToken();
         return PR_FALSE;
       }
     }
     return PR_TRUE;
   }
   return PR_FALSE;
 }
 
-PRBool CSSParserImpl::ParseOneFamily(nsresult& aErrorCode, nsAString& aFamily)
-{
-  if (!GetToken(aErrorCode, PR_TRUE))
+PRBool
+CSSParserImpl::ParseOneFamily(nsAString& aFamily)
+{
+  if (!GetToken(PR_TRUE))
     return PR_FALSE;
 
   nsCSSToken* tk = &mToken;
 
   if (eCSSToken_Ident == tk->mType) {
     aFamily.Append(tk->mIdent);
     for (;;) {
-      if (!GetToken(aErrorCode, PR_FALSE))
+      if (!GetToken(PR_FALSE))
         break;
 
       if (eCSSToken_Ident == tk->mType) {
         aFamily.Append(tk->mIdent);
       } else if (eCSSToken_WhiteSpace == tk->mType) {
         // Lookahead one token and drop whitespace if we are ending the
         // font name.
-        if (!GetToken(aErrorCode, PR_TRUE))
+        if (!GetToken(PR_TRUE))
           break;
 
         UngetToken();
         if (eCSSToken_Ident == tk->mType)
           aFamily.Append(PRUnichar(' '));
         else
           break;
       } else {
@@ -6670,19 +6623,20 @@ PRBool CSSParserImpl::ParseOneFamily(nsr
     return PR_TRUE;
 
   } else {
     UngetToken();
     return PR_FALSE;
   }
 }
 
-PRBool CSSParserImpl::ParseFamily(nsresult& aErrorCode, nsCSSValue& aValue)
-{
-  if (!GetToken(aErrorCode, PR_TRUE))
+PRBool
+CSSParserImpl::ParseFamily(nsCSSValue& aValue)
+{
+  if (!GetToken(PR_TRUE))
     return PR_FALSE;
 
   if (eCSSToken_Ident == mToken.mType) {
     nsCSSKeyword keyword = nsCSSKeywords::LookupKeyword(mToken.mIdent);
     if (keyword == eCSSKeyword_inherit) {
       aValue.SetInheritValue();
       return PR_TRUE;
     }
@@ -6696,68 +6650,68 @@ PRBool CSSParserImpl::ParseFamily(nsresu
       return PR_TRUE;
     }
   }
 
   UngetToken();
 
   nsAutoString family;
   for (;;) {
-    if (!ParseOneFamily(aErrorCode, family))
-      return PR_FALSE;
-
-    if (!ExpectSymbol(aErrorCode, ',', PR_TRUE))
+    if (!ParseOneFamily(family))
+      return PR_FALSE;
+
+    if (!ExpectSymbol(',', PR_TRUE))
       break;
 
     family.Append(PRUnichar(','));
   }
-    
+
   if (family.IsEmpty()) {
     return PR_FALSE;
   }
   aValue.SetStringValue(family, eCSSUnit_String);
   return PR_TRUE;
 }
 
 // src: ( uri-src | local-src ) (',' ( uri-src | local-src ) )*
 // uri-src: uri [ 'format(' string ( ',' string )* ')' ]
 // local-src: 'local(' ( string | ident ) ')'
 
 PRBool
-CSSParserImpl::ParseFontSrc(nsresult& aErrorCode, nsCSSValue& aValue)
+CSSParserImpl::ParseFontSrc(nsCSSValue& aValue)
 {
   // could we maybe turn nsCSSValue::Array into nsTArray<nsCSSValue>?
   nsTArray<nsCSSValue> values;
   nsCSSValue cur;
   for (;;) {
-    if (!GetToken(aErrorCode, PR_TRUE))
+    if (!GetToken(PR_TRUE))
       break;
 
     if (mToken.mType == eCSSToken_Function &&
         mToken.mIdent.LowerCaseEqualsLiteral("url")) {
-      if (!ParseURL(aErrorCode, cur))
+      if (!ParseURL(cur))
         return PR_FALSE;
       values.AppendElement(cur);
-      if (!ParseFontSrcFormat(aErrorCode, values))
+      if (!ParseFontSrcFormat(values))
         return PR_FALSE;
 
     } else if (mToken.mType == eCSSToken_Function &&
                mToken.mIdent.LowerCaseEqualsLiteral("local")) {
       // css3-fonts does not specify a formal grammar for local().
       // The text permits both unquoted identifiers and quoted
       // strings.  We resolve this ambiguity in the spec by
       // assuming that the appropriate production is a single
       // <family-name>, possibly surrounded by whitespace.
 
       nsAutoString family;
-      if (!ExpectSymbol(aErrorCode, '(', PR_FALSE))
-        return PR_FALSE;
-      if (!ParseOneFamily(aErrorCode, family))
-        return PR_FALSE;
-      if (!ExpectSymbol(aErrorCode, ')', PR_TRUE))
+      if (!ExpectSymbol('(', PR_FALSE))
+        return PR_FALSE;
+      if (!ParseOneFamily(family))
+        return PR_FALSE;
+      if (!ExpectSymbol(')', PR_TRUE))
         return PR_FALSE;
 
       // the style parameters to the nsFont constructor are ignored,
       // because it's only being used to call EnumerateFamilies
       nsFont font(family, 0, 0, 0, 0, 0);
       ExtractFirstFamilyData dat;
 
       font.EnumerateFamilies(ExtractFirstFamily, (void*) &dat);
@@ -6765,81 +6719,81 @@ CSSParserImpl::ParseFontSrc(nsresult& aE
         return PR_FALSE;
 
       cur.SetStringValue(dat.mFamilyName, eCSSUnit_Local_Font);
       values.AppendElement(cur);
     } else {
       return PR_FALSE;
     }
 
-    if (!ExpectSymbol(aErrorCode, ',', PR_TRUE))
+    if (!ExpectSymbol(',', PR_TRUE))
       break;
   }
 
   nsRefPtr<nsCSSValue::Array> srcVals
     = nsCSSValue::Array::Create(values.Length());
   if (!srcVals)
     return PR_FALSE;
 
   PRUint32 i;
   for (i = 0; i < values.Length(); i++)
     srcVals->Item(i) = values[i];
   aValue.SetArrayValue(srcVals, eCSSUnit_Array);
   return PR_TRUE;
 }
 
 PRBool
-CSSParserImpl::ParseFontSrcFormat(nsresult& aErrorCode,
-                                  nsTArray<nsCSSValue> & values)
-{
-  if (!GetToken(aErrorCode, PR_TRUE))
+CSSParserImpl::ParseFontSrcFormat(nsTArray<nsCSSValue> & values)
+{
+  if (!GetToken(PR_TRUE))
     return PR_TRUE; // EOF harmless here
   if (mToken.mType != eCSSToken_Function ||
       !mToken.mIdent.LowerCaseEqualsLiteral("format")) {
     UngetToken();
     return PR_TRUE;
   }
-  if (!ExpectSymbol(aErrorCode, '(', PR_FALSE))
+  if (!ExpectSymbol('(', PR_FALSE))
     return PR_FALSE;
 
   do {
-    if (!GetToken(aErrorCode, PR_TRUE))
+    if (!GetToken(PR_TRUE))
       return PR_FALSE;
 
     if (mToken.mType != eCSSToken_String)
       return PR_FALSE;
 
     nsCSSValue cur(mToken.mIdent, eCSSUnit_Font_Format);
     values.AppendElement(cur);
-  } while (ExpectSymbol(aErrorCode, ',', PR_TRUE));
-
-  return ExpectSymbol(aErrorCode, ')', PR_TRUE);
+  } while (ExpectSymbol(',', PR_TRUE));
+
+  return ExpectSymbol(')', PR_TRUE);
 }
 
 // font-ranges: urange ( ',' urange )*
 PRBool
-CSSParserImpl::ParseFontRanges(nsresult& aErrorCode, nsCSSValue& aValue)
+CSSParserImpl::ParseFontRanges(nsCSSValue& aValue)
 {
   // not currently implemented (bug 443976)
   return PR_FALSE;
 }
 
-PRBool CSSParserImpl::ParseListStyle(nsresult& aErrorCode)
+PRBool
+CSSParserImpl::ParseListStyle()
 {
   const PRInt32 numProps = 3;
   static const nsCSSProperty listStyleIDs[] = {
     eCSSProperty_list_style_type,
     eCSSProperty_list_style_position,
     eCSSProperty_list_style_image
   };
 
   nsCSSValue  values[numProps];
   PRInt32 index;
-  PRInt32 found = ParseChoice(aErrorCode, values, listStyleIDs, numProps);
-  if ((found < 1) || (PR_FALSE == ExpectEndProperty(aErrorCode))) {
+  PRInt32 found = ParseChoice(values, listStyleIDs, numProps);
+  if ((found < 1) || (PR_FALSE == ExpectEndProperty())) {
     return PR_FALSE;
   }
 
   // Provide default values
   if ((found & 1) == 0) {
     values[0].SetIntValue(NS_STYLE_LIST_STYLE_DISC, eCSSUnit_Enumerated);
   }
   if ((found & 2) == 0) {
@@ -6850,17 +6804,18 @@ PRBool CSSParserImpl::ParseListStyle(nsr
   }
 
   for (index = 0; index < numProps; index++) {
     AppendValue(listStyleIDs[index], values[index]);
   }
   return PR_TRUE;
 }
 
-PRBool CSSParserImpl::ParseMargin(nsresult& aErrorCode)
+PRBool
+CSSParserImpl::ParseMargin()
 {
   static const nsCSSProperty kMarginSideIDs[] = {
     eCSSProperty_margin_top,
     eCSSProperty_margin_right_value,
     eCSSProperty_margin_bottom,
     eCSSProperty_margin_left_value
   };
   static const nsCSSProperty kMarginSources[] = {
@@ -6868,50 +6823,52 @@ PRBool CSSParserImpl::ParseMargin(nsresu
     eCSSProperty_margin_left_rtl_source,
     eCSSProperty_margin_right_ltr_source,
     eCSSProperty_margin_right_rtl_source,
     eCSSProperty_UNKNOWN
   };
 
   // do this now, in case 4 values weren't specified
   InitBoxPropsAsPhysical(kMarginSources);
-  return ParseBoxProperties(aErrorCode, mTempData.mMargin.mMargin,
+  return ParseBoxProperties(mTempData.mMargin.mMargin,
                             kMarginSideIDs);
 }
 
-PRBool CSSParserImpl::ParseMarks(nsresult& aErrorCode, nsCSSValue& aValue)
-{
-  if (ParseVariant(aErrorCode, aValue, VARIANT_HOK, nsCSSProps::kPageMarksKTable)) {
+PRBool
+CSSParserImpl::ParseMarks(nsCSSValue& aValue)
+{
+  if (ParseVariant(aValue, VARIANT_HOK, nsCSSProps::kPageMarksKTable)) {
     if (eCSSUnit_Enumerated == aValue.GetUnit()) {
-      if (PR_FALSE == ExpectEndProperty(aErrorCode)) {
+      if (PR_FALSE == ExpectEndProperty()) {
         nsCSSValue  second;
-        if (ParseEnum(aErrorCode, second, nsCSSProps::kPageMarksKTable)) {
+        if (ParseEnum(second, nsCSSProps::kPageMarksKTable)) {
           aValue.SetIntValue(aValue.GetIntValue() | second.GetIntValue(), eCSSUnit_Enumerated);
           return PR_TRUE;
         }
         return PR_FALSE;
       }
     }
     return PR_TRUE;
   }
   return PR_FALSE;
 }
 
-PRBool CSSParserImpl::ParseOutline(nsresult& aErrorCode)
+PRBool
+CSSParserImpl::ParseOutline()
 {
   const PRInt32 numProps = 3;
   static const nsCSSProperty kOutlineIDs[] = {
     eCSSProperty_outline_color,
     eCSSProperty_outline_style,
     eCSSProperty_outline_width
   };
 
   nsCSSValue  values[numProps];
-  PRInt32 found = ParseChoice(aErrorCode, values, kOutlineIDs, numProps);
-  if ((found < 1) || (PR_FALSE == ExpectEndProperty(aErrorCode))) {
+  PRInt32 found = ParseChoice(values, kOutlineIDs, numProps);
+  if ((found < 1) || (PR_FALSE == ExpectEndProperty())) {
     return PR_FALSE;
   }
 
   // Provide default values
   if ((found & 1) == 0) {
 #ifdef GFX_HAS_INVERT
     values[0].SetIntValue(NS_STYLE_COLOR_INVERT, eCSSUnit_Enumerated);
 #else
@@ -6927,22 +6884,23 @@ PRBool CSSParserImpl::ParseOutline(nsres
 
   PRInt32 index;
   for (index = 0; index < numProps; index++) {
     AppendValue(kOutlineIDs[index], values[index]);
   }
   return PR_TRUE;
 }
 
-PRBool CSSParserImpl::ParseOverflow(nsresult& aErrorCode)
+PRBool
+CSSParserImpl::ParseOverflow()
 {
   nsCSSValue overflow;
-  if (!ParseVariant(aErrorCode, overflow, VARIANT_AHK,
+  if (!ParseVariant(overflow, VARIANT_AHK,
                    nsCSSProps::kOverflowKTable) ||
-      !ExpectEndProperty(aErrorCode))
+      !ExpectEndProperty())
     return PR_FALSE;
 
   nsCSSValue overflowX(overflow);
   nsCSSValue overflowY(overflow);
   if (eCSSUnit_Enumerated == overflow.GetUnit())
     switch(overflow.GetIntValue()) {
       case NS_STYLE_OVERFLOW_SCROLLBARS_HORIZONTAL:
         overflowX.SetIntValue(NS_STYLE_OVERFLOW_SCROLL, eCSSUnit_Enumerated);
@@ -6950,21 +6908,21 @@ PRBool CSSParserImpl::ParseOverflow(nsre
         break;
       case NS_STYLE_OVERFLOW_SCROLLBARS_VERTICAL:
         overflowX.SetIntValue(NS_STYLE_OVERFLOW_HIDDEN, eCSSUnit_Enumerated);
         overflowY.SetIntValue(NS_STYLE_OVERFLOW_SCROLL, eCSSUnit_Enumerated);
         break;
     }
   AppendValue(eCSSProperty_overflow_x, overflowX);
   AppendValue(eCSSProperty_overflow_y, overflowY);
-  aErrorCode = NS_OK;
-  return PR_TRUE;
-}
-
-PRBool CSSParserImpl::ParsePadding(nsresult& aErrorCode)
+  return PR_TRUE;
+}
+
+PRBool
+CSSParserImpl::ParsePadding()
 {
   static const nsCSSProperty kPaddingSideIDs[] = {
     eCSSProperty_padding_top,
     eCSSProperty_padding_right_value,
     eCSSProperty_padding_bottom,
     eCSSProperty_padding_left_value
   };
   static const nsCSSProperty kPaddingSources[] = {
@@ -6972,142 +6930,145 @@ PRBool CSSParserImpl::ParsePadding(nsres
     eCSSProperty_padding_left_rtl_source,
     eCSSProperty_padding_right_ltr_source,
     eCSSProperty_padding_right_rtl_source,
     eCSSProperty_UNKNOWN
   };
 
   // do this now, in case 4 values weren't specified
   InitBoxPropsAsPhysical(kPaddingSources);
-  return ParseBoxProperties(aErrorCode, mTempData.mMargin.mPadding,
+  return ParseBoxProperties(mTempData.mMargin.mPadding,
                             kPaddingSideIDs);
 }
 
-PRBool CSSParserImpl::ParsePause(nsresult& aErrorCode)
+PRBool
+CSSParserImpl::ParsePause()
 {
   nsCSSValue  before;
-  if (ParseSingleValueProperty(aErrorCode, before, eCSSProperty_pause_before)) {
+  if (ParseSingleValueProperty(before, eCSSProperty_pause_before)) {
     if (eCSSUnit_Inherit != before.GetUnit() && eCSSUnit_Initial != before.GetUnit()) {
       nsCSSValue after;
-      if (ParseSingleValueProperty(aErrorCode, after, eCSSProperty_pause_after)) {
-        if (ExpectEndProperty(aErrorCode)) {
+      if (ParseSingleValueProperty(after, eCSSProperty_pause_after)) {
+        if (ExpectEndProperty()) {
           AppendValue(eCSSProperty_pause_before, before);
           AppendValue(eCSSProperty_pause_after, after);
           return PR_TRUE;
         }
         return PR_FALSE;
       }
     }
-    if (ExpectEndProperty(aErrorCode)) {
+    if (ExpectEndProperty()) {
       AppendValue(eCSSProperty_pause_before, before);
       AppendValue(eCSSProperty_pause_after, before);
       return PR_TRUE;
     }
   }
   return PR_FALSE;
 }
 
-PRBool CSSParserImpl::ParseQuotes(nsresult& aErrorCode)
+PRBool
+CSSParserImpl::ParseQuotes()
 {
   nsCSSValue  open;
-  if (ParseVariant(aErrorCode, open, VARIANT_HOS, nsnull)) {
+  if (ParseVariant(open, VARIANT_HOS, nsnull)) {
     if (eCSSUnit_String == open.GetUnit()) {
       nsCSSValuePairList* quotesHead = new nsCSSValuePairList();
       nsCSSValuePairList* quotes = quotesHead;
       if (nsnull == quotes) {
-        aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+        mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
         return PR_FALSE;
       }
       quotes->mXValue = open;
       while (nsnull != quotes) {
         // get mandatory close
-        if (ParseVariant(aErrorCode, quotes->mYValue, VARIANT_STRING,
+        if (ParseVariant(quotes->mYValue, VARIANT_STRING,
                          nsnull)) {
-          if (ExpectEndProperty(aErrorCode)) {
+          if (ExpectEndProperty()) {
             mTempData.SetPropertyBit(eCSSProperty_quotes);
             mTempData.mContent.mQuotes = quotesHead;
-            aErrorCode = NS_OK;
             return PR_TRUE;
           }
           // look for another open
-          if (ParseVariant(aErrorCode, open, VARIANT_STRING, nsnull)) {
+          if (ParseVariant(open, VARIANT_STRING, nsnull)) {
             quotes->mNext = new nsCSSValuePairList();
             quotes = quotes->mNext;
             if (nsnull != quotes) {
               quotes->mXValue = open;
               continue;
             }
-            aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+            mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
           }
         }
         break;
       }
       delete quotesHead;
       return PR_FALSE;
     }
-    if (ExpectEndProperty(aErrorCode)) {
+    if (ExpectEndProperty()) {
       nsCSSValuePairList* quotesHead = new nsCSSValuePairList();
       quotesHead->mXValue = open;
       mTempData.mContent.mQuotes = quotesHead;
       mTempData.SetPropertyBit(eCSSProperty_quotes);
       return PR_TRUE;
     }
   }
   return PR_FALSE;
 }
 
-PRBool CSSParserImpl::ParseSize(nsresult& aErrorCode)
+PRBool
+CSSParserImpl::ParseSize()
 {
   nsCSSValue width;
-  if (ParseVariant(aErrorCode, width, VARIANT_AHKL, nsCSSProps::kPageSizeKTable)) {
+  if (ParseVariant(width, VARIANT_AHKL, nsCSSProps::kPageSizeKTable)) {
     if (width.IsLengthUnit()) {
       nsCSSValue  height;
-      if (ParseVariant(aErrorCode, height, VARIANT_LENGTH, nsnull)) {
-        if (ExpectEndProperty(aErrorCode)) {
+      if (ParseVariant(height, VARIANT_LENGTH, nsnull)) {
+        if (ExpectEndProperty()) {
           mTempData.mPage.mSize.mXValue = width;
           mTempData.mPage.mSize.mYValue = height;
           mTempData.SetPropertyBit(eCSSProperty_size);
           return PR_TRUE;
         }
         return PR_FALSE;
       }
     }
-    if (ExpectEndProperty(aErrorCode)) {
+    if (ExpectEndProperty()) {
       mTempData.mPage.mSize.SetBothValuesTo(width);
       mTempData.SetPropertyBit(eCSSProperty_size);
       return PR_TRUE;
     }
   }
   return PR_FALSE;
 }
 
-PRBool CSSParserImpl::ParseTextDecoration(nsresult& aErrorCode, nsCSSValue& aValue)
-{
-  if (ParseVariant(aErrorCode, aValue, VARIANT_HOK, nsCSSProps::kTextDecorationKTable)) {
+PRBool
+CSSParserImpl::ParseTextDecoration(nsCSSValue& aValue)
+{
+  if (ParseVariant(aValue, VARIANT_HOK, nsCSSProps::kTextDecorationKTable)) {
     if (eCSSUnit_Enumerated == aValue.GetUnit()) {  // look for more keywords
       PRInt32 intValue = aValue.GetIntValue();
       nsCSSValue  keyword;
       PRInt32 index;
       for (index = 0; index < 3; index++) {
-        if (ParseEnum(aErrorCode, keyword, nsCSSProps::kTextDecorationKTable)) {
+        if (ParseEnum(keyword, nsCSSProps::kTextDecorationKTable)) {
           intValue |= keyword.GetIntValue();
         }
         else {
           break;
         }
       }
       aValue.SetIntValue(intValue, eCSSUnit_Enumerated);
     }
     return PR_TRUE;
   }
   return PR_FALSE;
 }
 
-nsCSSValueList* CSSParserImpl::ParseCSSShadowList(nsresult& aErrorCode,
-                                                  PRBool aUsesSpread)
+nsCSSValueList*
+CSSParserImpl::ParseCSSShadowList(PRBool aUsesSpread)
 {
   nsAutoParseCompoundProperty compound(this);
 
   // Parses x, y, radius, color (in two possible orders)
   // This parses the input into a list. Either it contains just a "none" or
   // "inherit" value, or a list of arrays.
   // The resulting arrays will always contain the above order, with color and
   // radius as null values as needed
@@ -7118,153 +7079,150 @@ nsCSSValueList* CSSParserImpl::ParseCSSS
     IndexSpread,
     IndexColor
   };
 
   nsCSSValueList *list = nsnull;
   for (nsCSSValueList **curp = &list, *cur; ; curp = &cur->mNext) {
     cur = *curp = new nsCSSValueList();
     if (!cur) {
-      aErrorCode = NS_ERROR_OUT_OF_MEMORY;
-      break;
-    }
-    if (!ParseVariant(aErrorCode, cur->mValue,
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+      break;
+    }
+    if (!ParseVariant(cur->mValue,
                       (cur == list) ? VARIANT_HC | VARIANT_LENGTH | VARIANT_NONE
                                     : VARIANT_COLOR | VARIANT_LENGTH,
                       nsnull)) {
       break;
     }
 
     nsCSSUnit unit = cur->mValue.GetUnit();
     if (unit != eCSSUnit_None && unit != eCSSUnit_Inherit &&
         unit != eCSSUnit_Initial) {
       nsRefPtr<nsCSSValue::Array> val = nsCSSValue::Array::Create(5);
       if (!val) {
-        aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+        mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
         break;
       }
       PRBool haveColor = PR_FALSE;
       if (cur->mValue.IsLengthUnit()) {
         val->Item(IndexX) = cur->mValue;
       } else {
         // Must be a color (as string or color value)
         NS_ASSERTION(unit == eCSSUnit_String || unit == eCSSUnit_Color ||
                      unit == eCSSUnit_EnumColor,
                      "Must be a color value (named color, numeric color, "
                      "or system color)");
         haveColor = PR_TRUE;
         val->Item(IndexColor) = cur->mValue;
 
         // Parse the X coordinate
-        if (!ParseVariant(aErrorCode, val->Item(IndexX), VARIANT_LENGTH,
+        if (!ParseVariant(val->Item(IndexX), VARIANT_LENGTH,
                           nsnull)) {
           break;
         }
       }
       cur->mValue.SetArrayValue(val, eCSSUnit_Array);
 
       // Y coordinate; this one is not optional
-      if (!ParseVariant(aErrorCode, val->Item(IndexY), VARIANT_LENGTH, nsnull)) {
+      if (!ParseVariant(val->Item(IndexY), VARIANT_LENGTH, nsnull)) {
         break;
       }
 
       // Optional radius. Ignore errors except if they pass a negative
       // value which we must reject. If we use ParsePositiveVariant we can't
       // tell the difference between an unspecified radius and a negative
       // radius, so that's why we don't use it.
-      if (ParseVariant(aErrorCode, val->Item(IndexRadius), VARIANT_LENGTH, nsnull) &&
+      if (ParseVariant(val->Item(IndexRadius), VARIANT_LENGTH, nsnull) &&
           val->Item(IndexRadius).GetFloatValue() < 0) {
         break;
       }
 
       if (aUsesSpread) {
         // Optional spread (ignore errors)
-        ParseVariant(aErrorCode, val->Item(IndexSpread), VARIANT_LENGTH,
+        ParseVariant(val->Item(IndexSpread), VARIANT_LENGTH,
                      nsnull);
       }
 
       if (!haveColor) {
         // Optional color (ignore errors)
-        ParseVariant(aErrorCode, val->Item(IndexColor), VARIANT_COLOR,
+        ParseVariant(val->Item(IndexColor), VARIANT_COLOR,
                      nsnull);
       }
 
       // Might be at a comma now
-      if (ExpectSymbol(aErrorCode, ',', PR_TRUE)) {
+      if (ExpectSymbol(',', PR_TRUE)) {
         // Go to next value
         continue;
       }
     }
 
-    if (!ExpectEndProperty(aErrorCode)) {
+    if (!ExpectEndProperty()) {
       // If we don't have a comma to delimit the next value, we
       // must be at the end of the property.  Otherwise we've hit
       // something else, which is an error.
       break;
     }
 
     // Only success case here, since having the failure case at the
     // end allows more sharing of code.
-    aErrorCode = NS_OK;
     return list;
   }
   // Have failure case at the end so we can |break| to get to it.
   delete list;
   return nsnull;
 }
 
-PRBool CSSParserImpl::ParseTextShadow(nsresult& aErrorCode)
-{
-  nsCSSValueList* list = ParseCSSShadowList(aErrorCode, PR_FALSE);
+PRBool
+CSSParserImpl::ParseTextShadow()
+{
+  nsCSSValueList* list = ParseCSSShadowList(PR_FALSE);
   if (!list)
     return PR_FALSE;
 
   mTempData.SetPropertyBit(eCSSProperty_text_shadow);
   mTempData.mText.mTextShadow = list;
   return PR_TRUE;
 }
 
-PRBool CSSParserImpl::ParseBoxShadow(nsresult& aErrorCode)
-{
-  nsCSSValueList* list = ParseCSSShadowList(aErrorCode, PR_TRUE);
+PRBool
+CSSParserImpl::ParseBoxShadow()
+{
+  nsCSSValueList* list = ParseCSSShadowList(PR_TRUE);
   if (!list)
     return PR_FALSE;
 
   mTempData.SetPropertyBit(eCSSProperty_box_shadow);
   mTempData.mMargin.mBoxShadow = list;
   return PR_TRUE;
 }
 
 PRBool
 CSSParserImpl::GetNamespaceIdForPrefix(const nsString& aPrefix,
-                                       PRInt32* aNameSpaceID,
-                                       nsresult& aErrorCode)
+                                       PRInt32* aNameSpaceID)
 {
   NS_PRECONDITION(!aPrefix.IsEmpty(), "Must have a prefix here");
-  NS_PRECONDITION(NS_SUCCEEDED(aErrorCode),
-                  "Why did we even get called?");
-  
+
   PRInt32 nameSpaceID = kNameSpaceID_Unknown;
   if (mNameSpaceMap) {
     // user-specified identifiers are case-sensitive (bug 416106)
     nsCOMPtr<nsIAtom> prefix = do_GetAtom(aPrefix);
     nameSpaceID = mNameSpaceMap->FindNameSpaceID(prefix);
   }
   // else no declared namespaces
 
   NS_ASSERTION(nameSpaceID != kNameSpaceID_None, "Shouldn't happen!");
 
   if (kNameSpaceID_Unknown == nameSpaceID) {   // unknown prefix, dump it
     const PRUnichar *params[] = {
       aPrefix.get()
     };
     REPORT_UNEXPECTED_P(PEUnknownNamespacePrefix, params);
-    if (mUnresolvablePrefixException) {
-      aErrorCode = NS_ERROR_DOM_NAMESPACE_ERR;
-    }
+    if (mUnresolvablePrefixException)
+      mScanner.SetLowLevelError(NS_ERROR_DOM_NAMESPACE_ERR);
     return PR_FALSE;
   }
 
   *aNameSpaceID = nameSpaceID;
   return PR_TRUE;
 }
 
 void
@@ -7275,95 +7233,95 @@ CSSParserImpl::SetDefaultNamespaceOnSele
     PRInt32 defaultID = mNameSpaceMap->FindNameSpaceID(nsnull);
     if (defaultID != kNameSpaceID_None) {
       aSelector.SetNameSpace(defaultID);
     }
   }
 }
 
 #ifdef MOZ_SVG
-PRBool CSSParserImpl::ParsePaint(nsresult& aErrorCode,
-                                 nsCSSValuePair* aResult,
-                                 nsCSSProperty aPropID)
-{
-  if (!ParseVariant(aErrorCode, aResult->mXValue,
+PRBool
+CSSParserImpl::ParsePaint(nsCSSValuePair* aResult,
+                          nsCSSProperty aPropID)
+{
+  if (!ParseVariant(aResult->mXValue,
                     VARIANT_HC | VARIANT_NONE | VARIANT_URL,
                     nsnull))
     return PR_FALSE;
-  
+
   if (aResult->mXValue.GetUnit() == eCSSUnit_URL) {
-    if (!ParseVariant(aErrorCode, aResult->mYValue, VARIANT_COLOR | VARIANT_NONE,
+    if (!ParseVariant(aResult->mYValue, VARIANT_COLOR | VARIANT_NONE,
                      nsnull))
       aResult->mYValue.SetColorValue(NS_RGB(0, 0, 0));
   } else {
     aResult->mYValue = aResult->mXValue;
   }
 
-  if (!ExpectEndProperty(aErrorCode))
+  if (!ExpectEndProperty())
     return PR_FALSE;
 
   mTempData.SetPropertyBit(aPropID);
   return PR_TRUE;
 }
 
-PRBool CSSParserImpl::ParseDasharray(nsresult& aErrorCode)
+PRBool
+CSSParserImpl::ParseDasharray()
 {
   nsCSSValue value;
-  if (ParseVariant(aErrorCode, value, VARIANT_HLPN | VARIANT_NONE, nsnull)) {
+  if (ParseVariant(value, VARIANT_HLPN | VARIANT_NONE, nsnull)) {
     nsCSSValueList *listHead = new nsCSSValueList;
     nsCSSValueList *list = listHead;
     if (!list) {
-      aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
       return PR_FALSE;
     }
 
     list->mValue = value;
 
     for (;;) {
-      if (ExpectEndProperty(aErrorCode)) {
+      if (ExpectEndProperty()) {
         mTempData.SetPropertyBit(eCSSProperty_stroke_dasharray);
         mTempData.mSVG.mStrokeDasharray = listHead;
-        aErrorCode = NS_OK;
         return PR_TRUE;
       }
 
       if (eCSSUnit_Inherit == value.GetUnit() ||
           eCSSUnit_Initial == value.GetUnit() ||
           eCSSUnit_None    == value.GetUnit())
         break;
 
-      if (!ExpectSymbol(aErrorCode, ',', PR_TRUE))
-        break;
-
-      if (!ParseVariant(aErrorCode, value,
+      if (!ExpectSymbol(',', PR_TRUE))
+        break;
+
+      if (!ParseVariant(value,
                         VARIANT_LENGTH | VARIANT_PERCENT | VARIANT_NUMBER,
                         nsnull))
         break;
 
       list->mNext = new nsCSSValueList;
       list = list->mNext;
       if (list)
         list->mValue = value;
       else {
-        aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+        mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
         break;
       }
     }
     delete listHead;
   }
   return PR_FALSE;
 }
 
-PRBool CSSParserImpl::ParseMarker(nsresult& aErrorCode)
+PRBool
+CSSParserImpl::ParseMarker()
 {
   nsCSSValue marker;
-  if (ParseSingleValueProperty(aErrorCode, marker, eCSSProperty_marker_end)) {
-    if (ExpectEndProperty(aErrorCode)) {
+  if (ParseSingleValueProperty(marker, eCSSProperty_marker_end)) {
+    if (ExpectEndProperty()) {
       AppendValue(eCSSProperty_marker_end, marker);
       AppendValue(eCSSProperty_marker_mid, marker);
       AppendValue(eCSSProperty_marker_start, marker);
-      aErrorCode = NS_OK;
-      return PR_TRUE;
-    }
-  }
-  return PR_FALSE;
-}
-#endif
+      return PR_TRUE;
+    }
+  }
+  return PR_FALSE;
+}
+#endif
diff -r b7bcdd009540 layout/style/nsCSSPseudoClassList.h
--- a/layout/style/nsCSSPseudoClassList.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/style/nsCSSPseudoClassList.h	Thu Sep 11 15:19:26 2008 +0300
@@ -87,16 +87,18 @@ CSS_PSEUDO_CLASS(nthLastOfType, ":nth-la
 CSS_PSEUDO_CLASS(nthLastOfType, ":nth-last-of-type")
 
 // Image, object, etc state pseudo-classes
 CSS_PSEUDO_CLASS(mozBroken, ":-moz-broken")
 CSS_PSEUDO_CLASS(mozUserDisabled, ":-moz-user-disabled")
 CSS_PSEUDO_CLASS(mozSuppressed, ":-moz-suppressed")
 CSS_PSEUDO_CLASS(mozLoading, ":-moz-loading")
 CSS_PSEUDO_CLASS(mozTypeUnsupported, ":-moz-type-unsupported")
+CSS_PSEUDO_CLASS(mozHandlerDisabled, ":-moz-handler-disabled")
+CSS_PSEUDO_CLASS(mozHandlerBlocked, ":-moz-handler-blocked")
 
 CSS_PSEUDO_CLASS(mozHasHandlerRef, ":-moz-has-handlerref")
 
 // Match nodes that are HTML but not XHTML
 CSS_PSEUDO_CLASS(mozIsHTML, ":-moz-is-html")
 
 // Matches anything when the specified look-and-feel metric is set
 CSS_PSEUDO_CLASS(mozSystemMetric, ":-moz-system-metric")
diff -r b7bcdd009540 layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/style/nsCSSRuleProcessor.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -1507,16 +1507,22 @@ static PRBool SelectorMatches(RuleProces
       stateToCheck = NS_EVENT_STATE_SUPPRESSED;
     }
     else if (nsCSSPseudoClasses::mozLoading == pseudoClass->mAtom) {
       stateToCheck = NS_EVENT_STATE_LOADING;
     }
     else if (nsCSSPseudoClasses::mozTypeUnsupported == pseudoClass->mAtom) {
       stateToCheck = NS_EVENT_STATE_TYPE_UNSUPPORTED;
     }
+    else if (nsCSSPseudoClasses::mozHandlerDisabled == pseudoClass->mAtom) {
+      stateToCheck = NS_EVENT_STATE_HANDLER_DISABLED;
+    }
+    else if (nsCSSPseudoClasses::mozHandlerBlocked == pseudoClass->mAtom) {
+      stateToCheck = NS_EVENT_STATE_HANDLER_BLOCKED;
+    }
     else if (nsCSSPseudoClasses::defaultPseudo == pseudoClass->mAtom) {
       stateToCheck = NS_EVENT_STATE_DEFAULT;
     }
     else if (nsCSSPseudoClasses::required == pseudoClass->mAtom) {
       stateToCheck = NS_EVENT_STATE_REQUIRED;
     }
     else if (nsCSSPseudoClasses::optional == pseudoClass->mAtom) {
       stateToCheck = NS_EVENT_STATE_OPTIONAL;
@@ -2322,27 +2328,26 @@ CascadeSheetRulesInto(nsICSSStyleSheet* 
 CascadeSheetRulesInto(nsICSSStyleSheet* aSheet, void* aData)
 {
   nsCSSStyleSheet*  sheet = static_cast<nsCSSStyleSheet*>(aSheet);
   CascadeEnumData* data = static_cast<CascadeEnumData*>(aData);
   PRBool bSheetApplicable = PR_TRUE;
   sheet->GetApplicable(bSheetApplicable);
 
   if (bSheetApplicable &&
-      sheet->UseForPresentation(data->mPresContext, data->mCacheKey)) {
-    nsCSSStyleSheet* child = sheet->mFirstChild;
+      sheet->UseForPresentation(data->mPresContext, data->mCacheKey) &&
+      sheet->mInner) {
+    nsCSSStyleSheet* child = sheet->mInner->mFirstChild;
     while (child) {
       CascadeSheetRulesInto(child, data);
       child = child->mNext;
     }
 
-    if (sheet->mInner) {
-      if (!sheet->mInner->mOrderedRules.EnumerateForwards(InsertRuleByWeight, data))
-        return PR_FALSE;
-    }
+    if (!sheet->mInner->mOrderedRules.EnumerateForwards(InsertRuleByWeight, data))
+      return PR_FALSE;
   }
   return PR_TRUE;
 }
 
 PR_STATIC_CALLBACK(int) CompareWeightData(const void* aArg1, const void* aArg2,
                                          void* closure)
 {
   const PerWeightData* arg1 = static_cast<const PerWeightData*>(aArg1);
diff -r b7bcdd009540 layout/style/nsCSSScanner.cpp
--- a/layout/style/nsCSSScanner.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/style/nsCSSScanner.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -56,35 +56,34 @@
 #include "nsIScriptError.h"
 #include "nsIStringBundle.h"
 #include "nsContentUtils.h"
 
 // Don't bother collecting whitespace characters in token's mIdent buffer
 #undef COLLECT_WHITESPACE
 
 static const PRUnichar CSS_ESCAPE = PRUnichar('\\');
-const PRUint8 nsCSSScanner::IS_DIGIT = 0x01;
-const PRUint8 nsCSSScanner::IS_HEX_DIGIT = 0x02;
-const PRUint8 nsCSSScanner::START_IDENT = 0x04;
-const PRUint8 nsCSSScanner::IS_IDENT = 0x08;
-const PRUint8 nsCSSScanner::IS_WHITESPACE = 0x10;
+static const PRUint8 IS_DIGIT = 0x01;
+static const PRUint8 IS_HEX_DIGIT = 0x02;
+static const PRUint8 START_IDENT = 0x04;
+static const PRUint8 IS_IDENT = 0x08;
+static const PRUint8 IS_WHITESPACE = 0x10;
 
 static PRBool gLexTableSetup = PR_FALSE;
-PRUint8 nsCSSScanner::gLexTable[256];
+static PRUint8 gLexTable[256];
 
 #ifdef CSS_REPORT_PARSE_ERRORS
 static PRBool gReportErrors = PR_TRUE;
 static nsIConsoleService *gConsoleService;
 static nsIFactory *gScriptErrorFactory;
 static nsIStringBundle *gStringBundle;
 #endif
 
-/* static */
-void
-nsCSSScanner::BuildLexTable()
+static void
+BuildLexTable()
 {
   gLexTableSetup = PR_TRUE;
 
   PRUint8* lt = gLexTable;
   int i;
   lt[CSS_ESCAPE] = START_IDENT;
   lt['-'] |= IS_IDENT;
   lt['_'] |= IS_IDENT | START_IDENT;
@@ -102,16 +101,50 @@ nsCSSScanner::BuildLexTable()
   for (i = 'A'; i <= 'Z'; i++) {
     if ((i >= 'A') && (i <= 'F')) {
       lt[i] |= IS_HEX_DIGIT;
       lt[i+32] |= IS_HEX_DIGIT;
     }
     lt[i] |= IS_IDENT | START_IDENT;
     lt[i+32] |= IS_IDENT | START_IDENT;
   }
+}
+
+static inline PRBool
+IsIdentStart(PRInt32 aChar)
+{
+  return aChar >= 0 &&
+    (aChar >= 256 || (gLexTable[aChar] & START_IDENT) != 0);
+}
+
+static inline PRBool
+StartsIdent(PRInt32 aFirstChar, PRInt32 aSecondChar)
+{
+  return IsIdentStart(aFirstChar) ||
+    (aFirstChar == '-' && IsIdentStart(aSecondChar));
+}
+
+static inline PRBool
+IsWhitespace(PRInt32 ch) {
+  return PRUint32(ch) < 256 && (gLexTable[ch] & IS_WHITESPACE) != 0;
+}
+
+static inline PRBool
+IsDigit(PRInt32 ch) {
+  return PRUint32(ch) < 256 && (gLexTable[ch] & IS_DIGIT) != 0;
+}
+
+static inline PRBool
+IsHexDigit(PRInt32 ch) {
+  return PRUint32(ch) < 256 && (gLexTable[ch] & IS_HEX_DIGIT) != 0;
+}
+
+static inline PRBool
+IsIdent(PRInt32 ch) {
+  return ch >= 0 && (ch >= 256 || (gLexTable[ch] & IS_IDENT) != 0);
 }
 
 nsCSSToken::nsCSSToken()
 {
   mType = eCSSToken_Symbol;
 }
 
 void 
@@ -184,16 +217,17 @@ nsCSSToken::AppendToString(nsString& aBu
       NS_ERROR("invalid token type");
       break;
   }
 }
 
 nsCSSScanner::nsCSSScanner()
   : mInputStream(nsnull)
   , mReadPointer(nsnull)
+  , mLowLevelError(NS_OK)
 #ifdef MOZ_SVG
   , mSVGMode(PR_FALSE)
 #endif
 #ifdef CSS_REPORT_PARSE_ERRORS
   , mError(mErrorBuf, NS_ARRAY_LENGTH(mErrorBuf), 0)
 #endif
 {
   MOZ_COUNT_CTOR(nsCSSScanner);
@@ -212,27 +246,43 @@ nsCSSScanner::~nsCSSScanner()
 {
   MOZ_COUNT_DTOR(nsCSSScanner);
   Close();
   if (mLocalPushback != mPushback) {
     delete [] mPushback;
   }
 }
 
+nsresult
+nsCSSScanner::GetLowLevelError()
+{
+  return mLowLevelError;
+}
+
+void
+nsCSSScanner::SetLowLevelError(nsresult aErrorCode)
+{
+  NS_ASSERTION(aErrorCode != NS_OK, "SetLowLevelError() used to clear error");
+  NS_ASSERTION(mLowLevelError == NS_OK, "there is already a low-level error");
+  mLowLevelError = aErrorCode;
+}
+
 #ifdef CSS_REPORT_PARSE_ERRORS
 #define CSS_ERRORS_PREF "layout.css.report_errors"
 
-PR_STATIC_CALLBACK(int) CSSErrorsPrefChanged(const char *aPref, void *aClosure)
+PR_STATIC_CALLBACK(int)
+CSSErrorsPrefChanged(const char *aPref, void *aClosure)
 {
   gReportErrors = nsContentUtils::GetBoolPref(CSS_ERRORS_PREF, PR_TRUE);
   return NS_OK;
 }
 #endif
 
-/* static */ PRBool nsCSSScanner::InitGlobals()
+/* static */ PRBool
+nsCSSScanner::InitGlobals()
 {
 #ifdef CSS_REPORT_PARSE_ERRORS
   if (gConsoleService && gScriptErrorFactory)
     return PR_TRUE;
   
   nsresult rv = CallGetService(NS_CONSOLESERVICE_CONTRACTID, &gConsoleService);
   NS_ENSURE_SUCCESS(rv, PR_FALSE);
 
@@ -242,29 +292,31 @@ PR_STATIC_CALLBACK(int) CSSErrorsPrefCha
                "unexpected null pointer without failure");
 
   nsContentUtils::RegisterPrefCallback(CSS_ERRORS_PREF, CSSErrorsPrefChanged, nsnull);
   CSSErrorsPrefChanged(CSS_ERRORS_PREF, nsnull);
 #endif
   return PR_TRUE;
 }
 
-/* static */ void nsCSSScanner::ReleaseGlobals()
+/* static */ void
+nsCSSScanner::ReleaseGlobals()
 {
 #ifdef CSS_REPORT_PARSE_ERRORS
   nsContentUtils::UnregisterPrefCallback(CSS_ERRORS_PREF, CSSErrorsPrefChanged, nsnull);
   NS_IF_RELEASE(gConsoleService);
   NS_IF_RELEASE(gScriptErrorFactory);
   NS_IF_RELEASE(gStringBundle);
 #endif
 }
 
-void nsCSSScanner::Init(nsIUnicharInputStream* aInput, 
-                        const PRUnichar * aBuffer, PRUint32 aCount, 
-                        nsIURI* aURI, PRUint32 aLineNumber)
+void
+nsCSSScanner::Init(nsIUnicharInputStream* aInput, 
+                   const PRUnichar * aBuffer, PRUint32 aCount, 
+                   nsIURI* aURI, PRUint32 aLineNumber)
 {
   NS_PRECONDITION(!mInputStream, "Should not have an existing input stream!");
   NS_PRECONDITION(!mReadPointer, "Should not have an existing input buffer!");
 
   // Read from stream via my own buffer
   if (aInput) {
     NS_PRECONDITION(!aBuffer, "Shouldn't have both input and buffer!");
     NS_PRECONDITION(aCount == 0, "Shouldn't have count with a stream");
@@ -291,45 +343,49 @@ void nsCSSScanner::Init(nsIUnicharInputS
     }
   }
 #endif // CSS_REPORT_PARSE_ERRORS
   mLineNumber = aLineNumber;
 
   // Reset variables that we use to keep track of our progress through the input
   mOffset = 0;
   mPushbackCount = 0;
+  mLowLevelError = NS_OK;
 
 #ifdef CSS_REPORT_PARSE_ERRORS
   mColNumber = 0;
 #endif
 }
 
 #ifdef CSS_REPORT_PARSE_ERRORS
 
 // @see REPORT_UNEXPECTED_EOF in nsCSSParser.cpp
 #define REPORT_UNEXPECTED_EOF(lf_) \
   ReportUnexpectedEOF(#lf_)
 
-void nsCSSScanner::AddToError(const nsSubstring& aErrorText)
+void
+nsCSSScanner::AddToError(const nsSubstring& aErrorText)
 {
   if (mError.IsEmpty()) {
     mErrorLineNumber = mLineNumber;
     mErrorColNumber = mColNumber;
     mError = aErrorText;
   } else {
     mError.Append(NS_LITERAL_STRING("  ") + aErrorText);
   }
 }
 
-void nsCSSScanner::ClearError()
+void
+nsCSSScanner::ClearError()
 {
   mError.Truncate();
 }
 
-void nsCSSScanner::OutputError()
+void
+nsCSSScanner::OutputError()
 {
   if (mError.IsEmpty()) return;
  
   // Log it to the Error console
 
   if (InitGlobals() && gReportErrors) {
     nsresult rv;
     nsCOMPtr<nsIScriptError> errorObject =
@@ -344,17 +400,18 @@ void nsCSSScanner::OutputError()
                              "CSS Parser");
       if (NS_SUCCEEDED(rv))
         gConsoleService->LogMessage(errorObject);
     }
   }
   ClearError();
 }
 
-static PRBool InitStringBundle()
+static PRBool
+InitStringBundle()
 {
   if (gStringBundle)
     return PR_TRUE;
 
   nsCOMPtr<nsIStringBundleService> sbs =
     do_GetService(NS_STRINGBUNDLE_CONTRACTID);
   if (!sbs)
     return PR_FALSE;
@@ -378,32 +435,34 @@ void nsCSSScanner::ReportUnexpected(cons
   ENSURE_STRINGBUNDLE;
 
   nsXPIDLString str;
   gStringBundle->GetStringFromName(NS_ConvertASCIItoUTF16(aMessage).get(),
                                    getter_Copies(str));
   AddToError(str);
 }
   
-void nsCSSScanner::ReportUnexpectedParams(const char* aMessage,
-                                          const PRUnichar **aParams,
-                                          PRUint32 aParamsLength)
+void
+nsCSSScanner::ReportUnexpectedParams(const char* aMessage,
+                                     const PRUnichar **aParams,
+                                     PRUint32 aParamsLength)
 {
   NS_PRECONDITION(aParamsLength > 0, "use the non-params version");
   ENSURE_STRINGBUNDLE;
 
   nsXPIDLString str;
   gStringBundle->FormatStringFromName(NS_ConvertASCIItoUTF16(aMessage).get(),
                                       aParams, aParamsLength,
                                       getter_Copies(str));
   AddToError(str);
 }
 
 // aLookingFor is a plain string, not a format string
-void nsCSSScanner::ReportUnexpectedEOF(const char* aLookingFor)
+void
+nsCSSScanner::ReportUnexpectedEOF(const char* aLookingFor)
 {
   ENSURE_STRINGBUNDLE;
 
   nsXPIDLString innerStr;
   gStringBundle->GetStringFromName(NS_ConvertASCIItoUTF16(aLookingFor).get(),
                                    getter_Copies(innerStr));
 
   const PRUnichar *params[] = {
@@ -412,53 +471,56 @@ void nsCSSScanner::ReportUnexpectedEOF(c
   nsXPIDLString str;
   gStringBundle->FormatStringFromName(NS_LITERAL_STRING("PEUnexpEOF2").get(),
                                       params, NS_ARRAY_LENGTH(params),
                                       getter_Copies(str));
   AddToError(str);
 }
 
 // aLookingFor is a single character
-void nsCSSScanner::ReportUnexpectedEOF(PRUnichar aLookingFor)
+void
+nsCSSScanner::ReportUnexpectedEOF(PRUnichar aLookingFor)
 {
   ENSURE_STRINGBUNDLE;
 
   const PRUnichar lookingForStr[] = {
     PRUnichar('\''), aLookingFor, PRUnichar('\''), PRUnichar(0)
   };
   const PRUnichar *params[] = { lookingForStr };
   nsXPIDLString str;
   gStringBundle->FormatStringFromName(NS_LITERAL_STRING("PEUnexpEOF2").get(),
                                       params, NS_ARRAY_LENGTH(params),
                                       getter_Copies(str));
   AddToError(str);
 }
 
 // aMessage must take 1 parameter (for the string representation of the
 // unexpected token)
-void nsCSSScanner::ReportUnexpectedToken(nsCSSToken& tok,
-                                         const char *aMessage)
+void
+nsCSSScanner::ReportUnexpectedToken(nsCSSToken& tok,
+                                    const char *aMessage)
 {
   ENSURE_STRINGBUNDLE;
   
   nsAutoString tokenString;
   tok.AppendToString(tokenString);
 
   const PRUnichar *params[] = {
     tokenString.get()
   };
 
   ReportUnexpectedParams(aMessage, params, NS_ARRAY_LENGTH(params));
 }
 
 // aParams's first entry must be null, and we'll fill in the token
-void nsCSSScanner::ReportUnexpectedTokenParams(nsCSSToken& tok,
-                                               const char* aMessage,
-                                               const PRUnichar **aParams,
-                                               PRUint32 aParamsLength)
+void
+nsCSSScanner::ReportUnexpectedTokenParams(nsCSSToken& tok,
+                                          const char* aMessage,
+                                          const PRUnichar **aParams,
+                                          PRUint32 aParamsLength)
 {
   NS_PRECONDITION(aParamsLength > 1, "use the non-params version");
   NS_PRECONDITION(aParams[0] == nsnull, "first param should be empty");
 
   ENSURE_STRINGBUNDLE;
   
   nsAutoString tokenString;
   tok.AppendToString(tokenString);
@@ -468,17 +530,18 @@ void nsCSSScanner::ReportUnexpectedToken
 }
 
 #else
 
 #define REPORT_UNEXPECTED_EOF(lf_)
 
 #endif // CSS_REPORT_PARSE_ERRORS
 
-void nsCSSScanner::Close()
+void
+nsCSSScanner::Close()
 {
   mInputStream = nsnull;
   mReadPointer = nsnull;
 
   // Clean things up so we don't hold on to memory if our parser gets recycled.
 #ifdef CSS_REPORT_PARSE_ERRORS
   mFileName.Truncate();
   mURI = nsnull;
@@ -490,49 +553,53 @@ void nsCSSScanner::Close()
     mPushbackSize = NS_ARRAY_LENGTH(mLocalPushback);
   }
 }
 
 #ifdef CSS_REPORT_PARSE_ERRORS
 #define TAB_STOP_WIDTH 8
 #endif
 
-PRBool nsCSSScanner::EnsureData(nsresult& aErrorCode)
+PRBool
+nsCSSScanner::EnsureData()
 {
   if (mOffset < mCount)
     return PR_TRUE;
 
-  if (mInputStream) {
-    mOffset = 0;
-    aErrorCode = mInputStream->Read(mBuffer, CSS_BUFFER_SIZE, &mCount);
-    if (NS_FAILED(aErrorCode) || mCount == 0) {
-      mCount = 0;
-      return PR_FALSE;
-    }
-    return PR_TRUE;
+  if (!mInputStream)
+    return PR_FALSE;
+
+  mOffset = 0;
+  nsresult rv = mInputStream->Read(mBuffer, CSS_BUFFER_SIZE, &mCount);
+
+  if (NS_FAILED(rv)) {
+    mCount = 0;
+    SetLowLevelError(rv);
+    return PR_FALSE;
   }
 
-  return PR_FALSE;
+  return mCount > 0;
 }
 
 // Returns -1 on error or eof
-PRInt32 nsCSSScanner::Read(nsresult& aErrorCode)
+PRInt32
+nsCSSScanner::Read()
 {
   PRInt32 rv;
   if (0 < mPushbackCount) {
     rv = PRInt32(mPushback[--mPushbackCount]);
   } else {
-    if (mOffset == mCount && !EnsureData(aErrorCode)) {
+    if (mOffset == mCount && !EnsureData()) {
       return -1;
     }
     rv = PRInt32(mReadPointer[mOffset++]);
     // There are four types of newlines in CSS: "\r", "\n", "\r\n", and "\f".
     // To simplify dealing with newlines, they are all normalized to "\n" here
     if (rv == '\r') {
-      if (EnsureData(aErrorCode) && mReadPointer[mOffset] == '\n') {
+      if (EnsureData() && mReadPointer[mOffset] == '\n') {
         mOffset++;
       }
       rv = '\n';
     } else if (rv == '\f') {
       rv = '\n';
     }
     if (rv == '\n') {
       // 0 is a magical line number meaning that we don't know (i.e., script)
@@ -550,195 +617,201 @@ PRInt32 nsCSSScanner::Read(nsresult& aEr
       mColNumber++;
     }
 #endif
   }
 //printf("Read => %x\n", rv);
   return rv;
 }
 
-PRInt32 nsCSSScanner::Peek(nsresult& aErrorCode)
+PRInt32
+nsCSSScanner::Peek()
 {
   if (0 == mPushbackCount) {
-    PRInt32 ch = Read(aErrorCode);
+    PRInt32 ch = Read();
     if (ch < 0) {
       return -1;
     }
     mPushback[0] = PRUnichar(ch);
     mPushbackCount++;
   }
 //printf("Peek => %x\n", mLookAhead);
   return PRInt32(mPushback[mPushbackCount - 1]);
 }
 
-void nsCSSScanner::Pushback(PRUnichar aChar)
+void
+nsCSSScanner::Pushback(PRUnichar aChar)
 {
   if (mPushbackCount == mPushbackSize) { // grow buffer
     PRUnichar*  newPushback = new PRUnichar[mPushbackSize + 4];
     if (nsnull == newPushback) {
       return;
     }
     mPushbackSize += 4;
     memcpy(newPushback, mPushback, sizeof(PRUnichar) * mPushbackCount);
     if (mPushback != mLocalPushback) {
       delete [] mPushback;
     }
     mPushback = newPushback;
   }
   mPushback[mPushbackCount++] = aChar;
 }
 
-PRBool nsCSSScanner::LookAhead(nsresult& aErrorCode, PRUnichar aChar)
+PRBool
+nsCSSScanner::LookAhead(PRUnichar aChar)
 {
-  PRInt32 ch = Read(aErrorCode);
+  PRInt32 ch = Read();
   if (ch < 0) {
     return PR_FALSE;
   }
   if (ch == aChar) {
     return PR_TRUE;
   }
   Pushback(ch);
   return PR_FALSE;
 }
 
-PRBool nsCSSScanner::EatWhiteSpace(nsresult& aErrorCode)
+PRBool
+nsCSSScanner::EatWhiteSpace()
 {
   PRBool eaten = PR_FALSE;
   for (;;) {
-    PRInt32 ch = Read(aErrorCode);
+    PRInt32 ch = Read();
     if (ch < 0) {
       break;
     }
     if ((ch == ' ') || (ch == '\n') || (ch == '\t')) {
       eaten = PR_TRUE;
       continue;
     }
     Pushback(ch);
     break;
   }
   return eaten;
 }
 
-PRBool nsCSSScanner::EatNewline(nsresult& aErrorCode)
+PRBool
+nsCSSScanner::EatNewline()
 {
-  PRInt32 ch = Read(aErrorCode);
+  PRInt32 ch = Read();
   if (ch < 0) {
     return PR_FALSE;
   }
   PRBool eaten = PR_FALSE;
   if (ch == '\n') {
     eaten = PR_TRUE;
   } else {
     Pushback(ch);
   }
   return eaten;
 }
 
-PRBool nsCSSScanner::Next(nsresult& aErrorCode, nsCSSToken& aToken)
+PRBool
+nsCSSScanner::Next(nsCSSToken& aToken)
 {
-  PRInt32 ch = Read(aErrorCode);
+  PRInt32 ch = Read();
   if (ch < 0) {
     return PR_FALSE;
   }
 
   // IDENT
-  if (StartsIdent(ch, Peek(aErrorCode)))
-    return ParseIdent(aErrorCode, ch, aToken);
+  if (StartsIdent(ch, Peek()))
+    return ParseIdent(ch, aToken);
 
   // AT_KEYWORD
   if (ch == '@') {
-    PRInt32 nextChar = Read(aErrorCode);
+    PRInt32 nextChar = Read();
     if (nextChar >= 0) {
-      PRInt32 followingChar = Peek(aErrorCode);
+      PRInt32 followingChar = Peek();
       Pushback(nextChar);
       if (StartsIdent(nextChar, followingChar))
-        return ParseAtKeyword(aErrorCode, ch, aToken);
+        return ParseAtKeyword(ch, aToken);
     }
   }
 
   // NUMBER or DIM
   if ((ch == '.') || (ch == '+') || (ch == '-')) {
-    PRInt32 nextChar = Peek(aErrorCode);
+    PRInt32 nextChar = Peek();
     if (IsDigit(nextChar)) {
-      return ParseNumber(aErrorCode, ch, aToken);
+      return ParseNumber(ch, aToken);
     }
     else if (('.' == nextChar) && ('.' != ch)) {
-      nextChar = Read(aErrorCode);
-      PRInt32 followingChar = Peek(aErrorCode);
+      nextChar = Read();
+      PRInt32 followingChar = Peek();
       Pushback(nextChar);
       if (IsDigit(followingChar))
-        return ParseNumber(aErrorCode, ch, aToken);
+        return ParseNumber(ch, aToken);
     }
   }
   if (IsDigit(ch)) {
-    return ParseNumber(aErrorCode, ch, aToken);
+    return ParseNumber(ch, aToken);
   }
 
   // ID
   if (ch == '#') {
-    return ParseRef(aErrorCode, ch, aToken);
+    return ParseRef(ch, aToken);
   }
 
   // STRING
   if ((ch == '"') || (ch == '\'')) {
-    return ParseString(aErrorCode, ch, aToken);
+    return ParseString(ch, aToken);
   }
 
   // WS
   if (IsWhitespace(ch)) {
     aToken.mType = eCSSToken_WhiteSpace;
     aToken.mIdent.Assign(PRUnichar(ch));
-    (void) EatWhiteSpace(aErrorCode);
+    (void) EatWhiteSpace();
     return PR_TRUE;
   }
   if (ch == '/') {
-    PRInt32 nextChar = Peek(aErrorCode);
+    PRInt32 nextChar = Peek();
     if (nextChar == '*') {
-      (void) Read(aErrorCode);
+      (void) Read();
 #if 0
       // If we change our storage data structures such that comments are
       // stored (for Editor), we should reenable this code, condition it
       // on being in editor mode, and apply glazou's patch from bug
       // 60290.
       aToken.mIdent.SetCapacity(2);
       aToken.mIdent.Assign(PRUnichar(ch));
       aToken.mIdent.Append(PRUnichar(nextChar));
-      return ParseCComment(aErrorCode, aToken);
+      return ParseCComment(aToken);
 #endif
-      return SkipCComment(aErrorCode) && Next(aErrorCode, aToken);
+      return SkipCComment() && Next(aToken);
     }
   }
   if (ch == '<') {  // consume HTML comment tags
-    if (LookAhead(aErrorCode, '!')) {
-      if (LookAhead(aErrorCode, '-')) {
-        if (LookAhead(aErrorCode, '-')) {
+    if (LookAhead('!')) {
+      if (LookAhead('-')) {
+        if (LookAhead('-')) {
           aToken.mType = eCSSToken_HTMLComment;
           aToken.mIdent.AssignLiteral("<!--");
           return PR_TRUE;
         }
         Pushback('-');
       }
       Pushback('!');
     }
   }
   if (ch == '-') {  // check for HTML comment end
-    if (LookAhead(aErrorCode, '-')) {
-      if (LookAhead(aErrorCode, '>')) {
+    if (LookAhead('-')) {
+      if (LookAhead('>')) {
         aToken.mType = eCSSToken_HTMLComment;
         aToken.mIdent.AssignLiteral("-->");
         return PR_TRUE;
       }
       Pushback('-');
     }
   }
 
   // INCLUDES ("~=") and DASHMATCH ("|=")
   if (( ch == '|' ) || ( ch == '~' ) || ( ch == '^' ) ||
       ( ch == '$' ) || ( ch == '*' )) {
-    PRInt32 nextChar = Read(aErrorCode);
+    PRInt32 nextChar = Read();
     if ( nextChar == '=' ) {
       if (ch == '~') {
         aToken.mType = eCSSToken_Includes;
       }
       else if (ch == '|') {
         aToken.mType = eCSSToken_Dashmatch;
       }
       else if (ch == '^') {
@@ -755,50 +828,51 @@ PRBool nsCSSScanner::Next(nsresult& aErr
       Pushback(nextChar);
     }
   }
   aToken.mType = eCSSToken_Symbol;
   aToken.mSymbol = ch;
   return PR_TRUE;
 }
 
-PRBool nsCSSScanner::NextURL(nsresult& aErrorCode, nsCSSToken& aToken)
+PRBool
+nsCSSScanner::NextURL(nsCSSToken& aToken)
 {
-  PRInt32 ch = Read(aErrorCode);
+  PRInt32 ch = Read();
   if (ch < 0) {
     return PR_FALSE;
   }
 
   // STRING
   if ((ch == '"') || (ch == '\'')) {
-    return ParseString(aErrorCode, ch, aToken);
+    return ParseString(ch, aToken);
   }
 
   // WS
   if (IsWhitespace(ch)) {
     aToken.mType = eCSSToken_WhiteSpace;
     aToken.mIdent.Assign(PRUnichar(ch));
-    (void) EatWhiteSpace(aErrorCode);
+    (void) EatWhiteSpace();
     return PR_TRUE;
   }
   if (ch == '/') {
-    PRInt32 nextChar = Peek(aErrorCode);
+    PRInt32 nextChar = Peek();
     if (nextChar == '*') {
-      (void) Read(aErrorCode);
+      (void) Read();
 #if 0
       // If we change our storage data structures such that comments are
       // stored (for Editor), we should reenable this code, condition it
       // on being in editor mode, and apply glazou's patch from bug
       // 60290.
       aToken.mIdent.SetCapacity(2);
       aToken.mIdent.Assign(PRUnichar(ch));
       aToken.mIdent.Append(PRUnichar(nextChar));
-      return ParseCComment(aErrorCode, aToken);
+      return ParseCComment(aToken);
 #endif
-      return SkipCComment(aErrorCode) && Next(aErrorCode, aToken);
+      return SkipCComment() && Next(aToken);
     }
   }
 
   // Process a url lexical token. A CSS1 url token can contain
   // characters beyond identifier characters (e.g. '/', ':', etc.)
   // Because of this the normal rules for tokenizing the input don't
   // apply very well. To simplify the parser and relax some of the
   // requirements on the scanner we parse url's here. If we find a
@@ -814,27 +888,27 @@ PRBool nsCSSScanner::NextURL(nsresult& a
     Pushback(ch);
     // empty url spec; just get out of here
     aToken.mType = eCSSToken_URL;
   } else {
     // start of a non-quoted url
     Pushback(ch);
     PRBool ok = PR_TRUE;
     for (;;) {
-      ch = Read(aErrorCode);
+      ch = Read();
       if (ch < 0) break;
       if (ch == CSS_ESCAPE) {
-        ParseAndAppendEscape(aErrorCode, ident);
+        ParseAndAppendEscape(ident);
       } else if ((ch == '"') || (ch == '\'') || (ch == '(')) {
         // This is an invalid URL spec
         ok = PR_FALSE;
       } else if (IsWhitespace(ch)) {
         // Whitespace is allowed at the end of the URL
-        (void) EatWhiteSpace(aErrorCode);
-        if (LookAhead(aErrorCode, ')')) {
+        (void) EatWhiteSpace();
+        if (LookAhead(')')) {
           Pushback(')');  // leave the closing symbol
           // done!
           break;
         }
         // Whitespace is followed by something other than a
         // ")". This is an invalid url spec.
         ok = PR_FALSE;
       } else if (ch == ')') {
@@ -853,28 +927,28 @@ PRBool nsCSSScanner::NextURL(nsresult& a
       aToken.mType = eCSSToken_URL;
     }
   }
   return PR_TRUE;
 }
 
 
 void
-nsCSSScanner::ParseAndAppendEscape(nsresult& aErrorCode, nsString& aOutput)
+nsCSSScanner::ParseAndAppendEscape(nsString& aOutput)
 {
-  PRInt32 ch = Peek(aErrorCode);
+  PRInt32 ch = Peek();
   if (ch < 0) {
     aOutput.Append(CSS_ESCAPE);
     return;
   }
   if (IsHexDigit(ch)) {
     PRInt32 rv = 0;
     int i;
     for (i = 0; i < 6; i++) { // up to six digits
-      ch = Read(aErrorCode);
+      ch = Read();
       if (ch < 0) {
         // Whoops: error or premature eof
         break;
       }
       if (!IsHexDigit(ch) && !IsWhitespace(ch)) {
         Pushback(ch);
         break;
       } else if (IsHexDigit(ch)) {
@@ -888,170 +962,168 @@ nsCSSScanner::ParseAndAppendEscape(nsres
         }
       } else {
         NS_ASSERTION(IsWhitespace(ch), "bad control flow");
         // single space ends escape
         break;
       }
     }
     if (6 == i) { // look for trailing whitespace and eat it
-      ch = Peek(aErrorCode);
+      ch = Peek();
       if (IsWhitespace(ch)) {
-        ch = Read(aErrorCode);
+        ch = Read();
       }
     }
     NS_ASSERTION(rv >= 0, "How did rv become negative?");
     if (rv > 0) {
       AppendUCS4ToUTF16(ENSURE_VALID_CHAR(rv), aOutput);
     }
     return;
   } else {
     // "Any character except a hexidecimal digit can be escaped to
     // remove its special meaning by putting a backslash in front"
     // -- CSS1 spec section 7.1
-    if (!EatNewline(aErrorCode)) { // skip escaped newline
-      (void) Read(aErrorCode);
+    if (!EatNewline()) { // skip escaped newline
+      (void) Read();
       if (ch > 0) {
         aOutput.Append(ch);
       }
     }
     return;
   }
 }
 
 /**
  * Gather up the characters in an identifier. The identfier was
  * started by "aChar" which will be appended to aIdent. The result
  * will be aIdent with all of the identifier characters appended
  * until the first non-identifier character is seen. The termination
  * character is unread for the future re-reading.
  */
-PRBool nsCSSScanner::GatherIdent(nsresult& aErrorCode, PRInt32 aChar,
-                                 nsString& aIdent)
+PRBool
+nsCSSScanner::GatherIdent(PRInt32 aChar, nsString& aIdent)
 {
   if (aChar == CSS_ESCAPE) {
-    ParseAndAppendEscape(aErrorCode, aIdent);
+    ParseAndAppendEscape(aIdent);
   }
   else if (0 < aChar) {
     aIdent.Append(aChar);
   }
   for (;;) {
     // If nothing in pushback, first try to get as much as possible in one go
-    if (!mPushbackCount && EnsureData(aErrorCode)) {
+    if (!mPushbackCount && EnsureData()) {
       // See how much we can consume and append in one go
       PRUint32 n = mOffset;
       // Count number of Ident characters that can be processed
       while (n < mCount && IsIdent(mReadPointer[n])) {
         ++n;
       }
       // Add to the token what we have so far
       if (n > mOffset) {
 #ifdef CSS_REPORT_PARSE_ERRORS
         mColNumber += n - mOffset;
 #endif
         aIdent.Append(&mReadPointer[mOffset], n - mOffset);
         mOffset = n;
       }
     }
 
-    aChar = Read(aErrorCode);
+    aChar = Read();
     if (aChar < 0) break;
     if (aChar == CSS_ESCAPE) {
-      ParseAndAppendEscape(aErrorCode, aIdent);
+      ParseAndAppendEscape(aIdent);
     } else if (IsIdent(aChar)) {
       aIdent.Append(PRUnichar(aChar));
     } else {
       Pushback(aChar);
       break;
     }
   }
   return PR_TRUE;
 }
 
-PRBool nsCSSScanner::ParseRef(nsresult& aErrorCode,
-                              PRInt32 aChar,
-                              nsCSSToken& aToken)
+PRBool
+nsCSSScanner::ParseRef(PRInt32 aChar, nsCSSToken& aToken)
 {
   aToken.mIdent.SetLength(0);
   aToken.mType = eCSSToken_Ref;
-  PRInt32 ch = Read(aErrorCode);
+  PRInt32 ch = Read();
   if (ch < 0) {
     return PR_FALSE;
   }
   if (IsIdent(ch) || ch == CSS_ESCAPE) {
     // First char after the '#' is a valid ident char (or an escape),
     // so it makes sense to keep going
-    if (StartsIdent(ch, Peek(aErrorCode))) {
+    if (StartsIdent(ch, Peek())) {
       aToken.mType = eCSSToken_ID;
     }
-    return GatherIdent(aErrorCode, ch, aToken.mIdent);
+    return GatherIdent(ch, aToken.mIdent);
   }
 
   // No ident chars after the '#'.  Just unread |ch| and get out of here.
   Pushback(ch);
   return PR_TRUE;
 }
 
-PRBool nsCSSScanner::ParseIdent(nsresult& aErrorCode,
-                                PRInt32 aChar,
-                                nsCSSToken& aToken)
+PRBool
+nsCSSScanner::ParseIdent(PRInt32 aChar, nsCSSToken& aToken)
 {
   nsString& ident = aToken.mIdent;
   ident.SetLength(0);
-  if (!GatherIdent(aErrorCode, aChar, ident)) {
+  if (!GatherIdent(aChar, ident)) {
     return PR_FALSE;
   }
 
   nsCSSTokenType tokenType = eCSSToken_Ident;
   // look for functions (ie: "ident(")
-  if (PRUnichar('(') == PRUnichar(Peek(aErrorCode))) { // this is a function definition
+  if (PRUnichar('(') == PRUnichar(Peek())) { // this is a function definition
     tokenType = eCSSToken_Function;
   }
 
   aToken.mType = tokenType;
   return PR_TRUE;
 }
 
-PRBool nsCSSScanner::ParseAtKeyword(nsresult& aErrorCode, PRInt32 aChar,
-                                    nsCSSToken& aToken)
+PRBool
+nsCSSScanner::ParseAtKeyword(PRInt32 aChar, nsCSSToken& aToken)
 {
   aToken.mIdent.SetLength(0);
   aToken.mType = eCSSToken_AtKeyword;
-  return GatherIdent(aErrorCode, 0, aToken.mIdent);
+  return GatherIdent(0, aToken.mIdent);
 }
 
-PRBool nsCSSScanner::ParseNumber(nsresult& aErrorCode, PRInt32 c,
-                                 nsCSSToken& aToken)
+PRBool
+nsCSSScanner::ParseNumber(PRInt32 c, nsCSSToken& aToken)
 {
   nsString& ident = aToken.mIdent;
   ident.SetLength(0);
   PRBool gotDot = (c == '.');
   aToken.mHasSign = (c == '+' || c == '-');
   if (c != '+') {
     ident.Append(PRUnichar(c));
   }
 
   // Gather up characters that make up the number
   PRBool gotE = PR_FALSE;
   for (;;) {
-    c = Read(aErrorCode);
+    c = Read();
     if (c < 0) break;
     if (!gotDot  && !gotE && (c == '.') &&
-        IsDigit(Peek(aErrorCode))) {
+        IsDigit(Peek())) {
       gotDot = PR_TRUE;
 #ifdef MOZ_SVG
     } else if (!gotE && (c == 'e' || c == 'E')) {
       if (!IsSVGMode()) {
         break;
       }
-      PRInt32 nextChar = Peek(aErrorCode);
+      PRInt32 nextChar = Peek();
       PRInt32 sign = 0;
       if (nextChar == '-' || nextChar == '+') {
-        sign = Read(aErrorCode);
-        nextChar = Peek(aErrorCode);
+        sign = Read();
+        nextChar = Peek();
       }
       if (IsDigit(nextChar)) {
         gotE = PR_TRUE;
         if (sign) {
           ident.Append(PRUnichar(c));
           c = sign;
         }
       } else {
@@ -1078,18 +1150,18 @@ PRBool nsCSSScanner::ParseNumber(nsresul
   if (!gotDot && !gotE) {
     aToken.mInteger = ident.ToInteger(&ec);
     aToken.mIntegerValid = PR_TRUE;
   }
   ident.SetLength(0);
 
   // Look at character that terminated the number
   if (c >= 0) {
-    if (StartsIdent(c, Peek(aErrorCode))) {
-      if (!GatherIdent(aErrorCode, c, ident)) {
+    if (StartsIdent(c, Peek())) {
+      if (!GatherIdent(c, ident)) {
         return PR_FALSE;
       }
       type = eCSSToken_Dimension;
     } else if ('%' == c) {
       type = eCSSToken_Percentage;
       value = value / 100.0f;
       aToken.mIntegerValid = PR_FALSE;
     } else {
@@ -1097,86 +1169,89 @@ PRBool nsCSSScanner::ParseNumber(nsresul
       Pushback(c);
     }
   }
   aToken.mNumber = value;
   aToken.mType = type;
   return PR_TRUE;
 }
 
-PRBool nsCSSScanner::SkipCComment(nsresult& aErrorCode)
+PRBool
+nsCSSScanner::SkipCComment()
 {
   for (;;) {
-    PRInt32 ch = Read(aErrorCode);
+    PRInt32 ch = Read();
     if (ch < 0) break;
     if (ch == '*') {
-      if (LookAhead(aErrorCode, '/')) {
+      if (LookAhead('/')) {
         return PR_TRUE;
       }
     }
   }
 
   REPORT_UNEXPECTED_EOF(PECommentEOF);
   return PR_FALSE;
 }
 
 #if 0
-PRBool nsCSSScanner::ParseCComment(nsresult& aErrorCode, nsCSSToken& aToken)
+PRBool
+nsCSSScanner::ParseCComment(nsCSSToken& aToken)
 {
   nsString& ident = aToken.mIdent;
   for (;;) {
-    PRInt32 ch = Read(aErrorCode);
+    PRInt32 ch = Read();
     if (ch < 0) break;
     if (ch == '*') {
-      if (LookAhead(aErrorCode, '/')) {
+      if (LookAhead('/')) {
         ident.Append(PRUnichar(ch));
         ident.Append(PRUnichar('/'));
         break;
       }
     }
 #ifdef COLLECT_WHITESPACE
     ident.Append(PRUnichar(ch));
 #endif
   }
   aToken.mType = eCSSToken_WhiteSpace;
   return PR_TRUE;
 }
 #endif
 
 #if 0
-PRBool nsCSSScanner::ParseEOLComment(nsresult& aErrorCode, nsCSSToken& aToken)
+PRBool
+nsCSSScanner::ParseEOLComment(nsCSSToken& aToken)
 {
   nsString& ident = aToken.mIdent;
   ident.SetLength(0);
   for (;;) {
-    if (EatNewline(aErrorCode)) {
+    if (EatNewline()) {
       break;
     }
-    PRInt32 ch = Read(aErrorCode);
+    PRInt32 ch = Read();
     if (ch < 0) {
       break;
     }
 #ifdef COLLECT_WHITESPACE
     ident.Append(PRUnichar(ch));
 #endif
   }
   aToken.mType = eCSSToken_WhiteSpace;
   return PR_TRUE;
 }
 #endif // 0
 
-PRBool nsCSSScanner::ParseString(nsresult& aErrorCode, PRInt32 aStop,
-                                 nsCSSToken& aToken)
+PRBool
+nsCSSScanner::ParseString(PRInt32 aStop, nsCSSToken& aToken)
 {
   aToken.mIdent.SetLength(0);
   aToken.mType = eCSSToken_String;
   aToken.mSymbol = PRUnichar(aStop); // remember how it's quoted
   for (;;) {
     // If nothing in pushback, first try to get as much as possible in one go
-    if (!mPushbackCount && EnsureData(aErrorCode)) {
+    if (!mPushbackCount && EnsureData()) {
       // See how much we can consume and append in one go
       PRUint32 n = mOffset;
       // Count number of characters that can be processed
       for (;n < mCount; ++n) {
         PRUnichar nextChar = mReadPointer[n];
         if ((nextChar == aStop) || (nextChar == CSS_ESCAPE) ||
             (nextChar == '\n') || (nextChar == '\r') || (nextChar == '\f')) {
           break;
@@ -1191,27 +1266,27 @@ PRBool nsCSSScanner::ParseString(nsresul
 #endif
       }
       // Add to the token what we have so far
       if (n > mOffset) {
         aToken.mIdent.Append(&mReadPointer[mOffset], n - mOffset);
         mOffset = n;
       }
     }
-    PRInt32 ch = Read(aErrorCode);
+    PRInt32 ch = Read();
     if (ch < 0 || ch == aStop) {
       break;
     }
     if (ch == '\n') {
       aToken.mType = eCSSToken_Error;
 #ifdef CSS_REPORT_PARSE_ERRORS
       ReportUnexpectedToken(aToken, "SEUnterminatedString");
 #endif
       break;
     }
     if (ch == CSS_ESCAPE) {
-      ParseAndAppendEscape(aErrorCode, aToken.mIdent);
+      ParseAndAppendEscape(aToken.mIdent);
     } else {
       aToken.mIdent.Append(ch);
     }
   }
   return PR_TRUE;
 }
diff -r b7bcdd009540 layout/style/nsCSSScanner.h
--- a/layout/style/nsCSSScanner.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/style/nsCSSScanner.h	Thu Sep 11 15:19:26 2008 +0300
@@ -183,108 +183,76 @@ class nsCSSScanner {
                                                const PRUnichar **aParams,
                                                PRUint32 aParamsLength);
 #endif
 
   PRUint32 GetLineNumber() { return mLineNumber; }
 
   // Get the next token. Return PR_FALSE on EOF. aTokenResult
   // is filled in with the data for the token.
-  PRBool Next(nsresult& aErrorCode, nsCSSToken& aTokenResult);
+  PRBool Next(nsCSSToken& aTokenResult);
 
   // Get the next token that may be a string or unquoted URL or whitespace
-  PRBool NextURL(nsresult& aErrorCode, nsCSSToken& aTokenResult);
+  PRBool NextURL(nsCSSToken& aTokenResult);
 
   // It's really ugly that we have to expose this, but it's the easiest
   // way to do :nth-child() parsing sanely.  (In particular, in
   // :nth-child(2n-1), "2n-1" is a dimension, and we need to push the
   // "-1" back so we can read it again as a number.)
   void Pushback(PRUnichar aChar);
 
-  static inline PRBool
-  IsIdentStart(PRInt32 aChar)
-  {
-    return aChar >= 0 &&
-      (aChar >= 256 || (gLexTable[aChar] & START_IDENT) != 0);
-  }
+  // Reports operating-system level errors, e.g. read failures and
+  // out of memory.
+  nsresult GetLowLevelError();
 
-  static inline PRBool
-  StartsIdent(PRInt32 aFirstChar, PRInt32 aSecondChar)
-  {
-    return IsIdentStart(aFirstChar) ||
-      (aFirstChar == '-' && IsIdentStart(aSecondChar));
-  }
-
-  static PRBool IsWhitespace(PRInt32 ch) {
-    return PRUint32(ch) < 256 && (gLexTable[ch] & IS_WHITESPACE) != 0;
-  }
-
-  static PRBool IsDigit(PRInt32 ch) {
-    return PRUint32(ch) < 256 && (gLexTable[ch] & IS_DIGIT) != 0;
-  }
-
-  static PRBool IsHexDigit(PRInt32 ch) {
-    return PRUint32(ch) < 256 && (gLexTable[ch] & IS_HEX_DIGIT) != 0;
-  }
-
-  static PRBool IsIdent(PRInt32 ch) {
-    return ch >= 0 && (ch >= 256 || (gLexTable[ch] & IS_IDENT) != 0);
-  }
+  // sometimes the parser wants to make note of a low-level error
+  void SetLowLevelError(nsresult aErrorCode);
   
 protected:
-  PRBool EnsureData(nsresult& aErrorCode);
-  PRInt32 Read(nsresult& aErrorCode);
-  PRInt32 Peek(nsresult& aErrorCode);
-  PRBool LookAhead(nsresult& aErrorCode, PRUnichar aChar);
-  PRBool EatWhiteSpace(nsresult& aErrorCode);
-  PRBool EatNewline(nsresult& aErrorCode);
+  PRBool EnsureData();
+  PRInt32 Read();
+  PRInt32 Peek();
+  PRBool LookAhead(PRUnichar aChar);
+  PRBool EatWhiteSpace();
+  PRBool EatNewline();
 
-  void ParseAndAppendEscape(nsresult& aErrorCode, nsString& aOutput);
-  PRBool ParseIdent(nsresult& aErrorCode, PRInt32 aChar, nsCSSToken& aResult);
-  PRBool ParseAtKeyword(nsresult& aErrorCode, PRInt32 aChar,
-                        nsCSSToken& aResult);
-  PRBool ParseNumber(nsresult& aErrorCode, PRInt32 aChar, nsCSSToken& aResult);
-  PRBool ParseRef(nsresult& aErrorCode, PRInt32 aChar, nsCSSToken& aResult);
-  PRBool ParseString(nsresult& aErrorCode, PRInt32 aChar, nsCSSToken& aResult);
+  void ParseAndAppendEscape(nsString& aOutput);
+  PRBool ParseIdent(PRInt32 aChar, nsCSSToken& aResult);
+  PRBool ParseAtKeyword(PRInt32 aChar, nsCSSToken& aResult);
+  PRBool ParseNumber(PRInt32 aChar, nsCSSToken& aResult);
+  PRBool ParseRef(PRInt32 aChar, nsCSSToken& aResult);
+  PRBool ParseString(PRInt32 aChar, nsCSSToken& aResult);
 #if 0
-  PRBool ParseEOLComment(nsresult& aErrorCode, nsCSSToken& aResult);
-  PRBool ParseCComment(nsresult& aErrorCode, nsCSSToken& aResult);
+  PRBool ParseCComment(nsCSSToken& aResult);
+  PRBool ParseEOLComment(nsCSSToken& aResult);
 #endif
-  PRBool SkipCComment(nsresult& aErrorCode);
+  PRBool SkipCComment();
 
-  PRBool GatherIdent(nsresult& aErrorCode, PRInt32 aChar, nsString& aIdent);
+  PRBool GatherIdent(PRInt32 aChar, nsString& aIdent);
 
   // Only used when input is a stream
   nsCOMPtr<nsIUnicharInputStream> mInputStream;
   PRUnichar mBuffer[CSS_BUFFER_SIZE];
 
   const PRUnichar *mReadPointer;
   PRUint32 mOffset;
   PRUint32 mCount;
   PRUnichar* mPushback;
   PRInt32 mPushbackCount;
   PRInt32 mPushbackSize;
   PRUnichar mLocalPushback[4];
+  nsresult mLowLevelError;
 
   PRUint32 mLineNumber;
 #ifdef MOZ_SVG
   // True if we are in SVG mode; false in "normal" CSS
   PRPackedBool mSVGMode;
 #endif
 #ifdef CSS_REPORT_PARSE_ERRORS
   nsXPIDLCString mFileName;
   nsCOMPtr<nsIURI> mURI;  // Cached so we know to not refetch mFileName
   PRUint32 mErrorLineNumber, mColNumber, mErrorColNumber;
   nsFixedString mError;
   PRUnichar mErrorBuf[200];
 #endif
-
-  static const PRUint8 IS_DIGIT;
-  static const PRUint8 IS_HEX_DIGIT;
-  static const PRUint8 START_IDENT;
-  static const PRUint8 IS_IDENT;
-  static const PRUint8 IS_WHITESPACE;
-
-  static PRUint8 gLexTable[256];
-  static void BuildLexTable();
 };
 
 #endif /* nsCSSScanner_h___ */
diff -r b7bcdd009540 layout/style/nsCSSStyleSheet.cpp
--- a/layout/style/nsCSSStyleSheet.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/style/nsCSSStyleSheet.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -747,102 +747,154 @@ nsMediaList::Append(const nsAString& aNe
   return rv;
 }
 
 // -------------------------------
 // CSS Style Sheet Inner Data Container
 //
 
 
-static PRBool SetStyleSheetReference(nsICSSRule* aRule, void* aSheet)
-{
-  if (aRule) {
-    aRule->SetStyleSheet((nsICSSStyleSheet*)aSheet);
-  }
-  return PR_TRUE;
-}
-
-nsCSSStyleSheetInner::nsCSSStyleSheetInner(nsICSSStyleSheet* aParentSheet)
+nsCSSStyleSheetInner::nsCSSStyleSheetInner(nsICSSStyleSheet* aPrimarySheet)
   : mSheets(),
     mComplete(PR_FALSE)
 #ifdef DEBUG
     , mPrincipalSet(PR_FALSE)
 #endif
 {
   MOZ_COUNT_CTOR(nsCSSStyleSheetInner);
-  mSheets.AppendElement(aParentSheet);
+  mSheets.AppendElement(aPrimarySheet);
 
   mPrincipal = do_CreateInstance("@mozilla.org/nullprincipal;1");
+}
+
+static PRBool SetStyleSheetReference(nsICSSRule* aRule, void* aSheet)
+{
+  if (aRule) {
+    aRule->SetStyleSheet((nsICSSStyleSheet*)aSheet);
+  }
+  return PR_TRUE;
 }
 
 static PRBool
 CloneRuleInto(nsICSSRule* aRule, void* aArray)
 {
   nsICSSRule* clone = nsnull;
   aRule->Clone(clone);
   if (clone) {
     static_cast<nsCOMArray<nsICSSRule>*>(aArray)->AppendObject(clone);
     NS_RELEASE(clone);
   }
   return PR_TRUE;
 }
 
+struct ChildSheetListBuilder {
+  nsRefPtr<nsCSSStyleSheet>* sheetSlot;
+  nsCSSStyleSheet* parent;
+
+  void SetParentLinks(nsCSSStyleSheet* aSheet) {
+    aSheet->mParent = parent;
+    aSheet->SetOwningDocument(parent->mDocument);
+  }
+};
+  
+static PRBool
+RebuildChildList(nsICSSRule* aRule, void* aBuilder)
+{
+  PRInt32 type;
+  aRule->GetType(type);
+  if (type == nsICSSRule::CHARSET_RULE) {
+    return PR_TRUE;
+  }
+
+  if (type == nsICSSRule::NAMESPACE_RULE || type == nsICSSRule::MEDIA_RULE ||
+      type == nsICSSRule::STYLE_RULE) {
+    return PR_FALSE;
+  }
+
+  ChildSheetListBuilder* builder =
+    static_cast<ChildSheetListBuilder*>(aBuilder);
+
+  // XXXbz We really need to decomtaminate all this stuff.  Is there a reason
+  // that I can't just QI to nsICSSImportRule and get an nsCSSStyleSheet
+  // directly from it?
+  nsCOMPtr<nsIDOMCSSImportRule> importRule(do_QueryInterface(aRule));
+  NS_ASSERTION(importRule, "GetType lied");
+
+  nsCOMPtr<nsIDOMCSSStyleSheet> childSheet;
+  importRule->GetStyleSheet(getter_AddRefs(childSheet));
+
+  // Have to do this QI to be safe, since XPConnect can fake
+  // nsIDOMCSSStyleSheets
+  nsCOMPtr<nsICSSStyleSheet> cssSheet = do_QueryInterface(childSheet);
+  if (!cssSheet) {
+    return PR_TRUE;
+  }
+
+  (*builder->sheetSlot) = static_cast<nsCSSStyleSheet*>(cssSheet.get());
+  builder->SetParentLinks(*builder->sheetSlot);
+  return PR_TRUE;
+}
+
 nsCSSStyleSheetInner::nsCSSStyleSheetInner(nsCSSStyleSheetInner& aCopy,
-                                           nsICSSStyleSheet* aParentSheet)
+                                           nsCSSStyleSheet* aPrimarySheet)
   : mSheets(),
     mSheetURI(aCopy.mSheetURI),
     mOriginalSheetURI(aCopy.mOriginalSheetURI),
     mBaseURI(aCopy.mBaseURI),
     mPrincipal(aCopy.mPrincipal),
     mComplete(aCopy.mComplete)
 #ifdef DEBUG
     , mPrincipalSet(aCopy.mPrincipalSet)
 #endif
 {
   MOZ_COUNT_CTOR(nsCSSStyleSheetInner);
-  mSheets.AppendElement(aParentSheet);
+  mSheets.AppendElement(aPrimarySheet);
   aCopy.mOrderedRules.EnumerateForwards(CloneRuleInto, &mOrderedRules);
-  mOrderedRules.EnumerateForwards(SetStyleSheetReference, aParentSheet);
+  mOrderedRules.EnumerateForwards(SetStyleSheetReference, aPrimarySheet);
+
+  ChildSheetListBuilder builder = { &mFirstChild, aPrimarySheet };
+  mOrderedRules.EnumerateForwards(RebuildChildList, &builder);
+
   RebuildNameSpaces();
 }
 
 nsCSSStyleSheetInner::~nsCSSStyleSheetInner()
 {
   MOZ_COUNT_DTOR(nsCSSStyleSheetInner);
   mOrderedRules.EnumerateForwards(SetStyleSheetReference, nsnull);
 }
 
 nsCSSStyleSheetInner* 
-nsCSSStyleSheetInner::CloneFor(nsICSSStyleSheet* aParentSheet)
+nsCSSStyleSheetInner::CloneFor(nsCSSStyleSheet* aPrimarySheet)
 {
-  return new nsCSSStyleSheetInner(*this, aParentSheet);
+  return new nsCSSStyleSheetInner(*this, aPrimarySheet);
 }
 
 void
-nsCSSStyleSheetInner::AddSheet(nsICSSStyleSheet* aParentSheet)
+nsCSSStyleSheetInner::AddSheet(nsICSSStyleSheet* aSheet)
 {
-  mSheets.AppendElement(aParentSheet);
+  mSheets.AppendElement(aSheet);
 }
 
 void
-nsCSSStyleSheetInner::RemoveSheet(nsICSSStyleSheet* aParentSheet)
+nsCSSStyleSheetInner::RemoveSheet(nsICSSStyleSheet* aSheet)
 {
   if (1 == mSheets.Count()) {
-    NS_ASSERTION(aParentSheet == (nsICSSStyleSheet*)mSheets.ElementAt(0), "bad parent");
+    NS_ASSERTION(aSheet == (nsICSSStyleSheet*)mSheets.ElementAt(0), "bad parent");
     delete this;
     return;
   }
-  if (aParentSheet == (nsICSSStyleSheet*)mSheets.ElementAt(0)) {
+  if (aSheet == (nsICSSStyleSheet*)mSheets.ElementAt(0)) {
     mSheets.RemoveElementAt(0);
     NS_ASSERTION(mSheets.Count(), "no parents");
     mOrderedRules.EnumerateForwards(SetStyleSheetReference,
                                     (nsICSSStyleSheet*)mSheets.ElementAt(0));
   }
   else {
-    mSheets.RemoveElement(aParentSheet);
+    mSheets.RemoveElement(aSheet);
   }
 }
 
 static PRBool
 CreateNameSpace(nsICSSRule* aRule, void* aNameSpacePtr)
 {
   PRInt32 type = nsICSSRule::UNKNOWN_RULE;
   aRule->GetType(type);
@@ -884,18 +936,16 @@ nsCSSStyleSheetInner::RebuildNameSpaces(
 // CSS Style Sheet
 //
 
 nsCSSStyleSheet::nsCSSStyleSheet()
   : nsICSSStyleSheet(),
     mRefCnt(0),
     mTitle(), 
     mMedia(nsnull),
-    mFirstChild(nsnull), 
-    mNext(nsnull),
     mParent(nsnull),
     mOwnerRule(nsnull),
     mRuleCollection(nsnull),
     mDocument(nsnull),
     mOwningNode(nsnull),
     mDisabled(PR_FALSE),
     mDirty(PR_FALSE),
     mRuleProcessors(nsnull)
@@ -908,18 +958,16 @@ nsCSSStyleSheet::nsCSSStyleSheet(const n
                                  nsICSSStyleSheet* aParentToUse,
                                  nsICSSImportRule* aOwnerRuleToUse,
                                  nsIDocument* aDocumentToUse,
                                  nsIDOMNode* aOwningNodeToUse)
   : nsICSSStyleSheet(),
     mRefCnt(0),
     mTitle(aCopy.mTitle), 
     mMedia(nsnull),
-    mFirstChild(nsnull), 
-    mNext(nsnull),
     mParent(aParentToUse),
     mOwnerRule(aOwnerRuleToUse),
     mRuleCollection(nsnull), // re-created lazily
     mDocument(aDocumentToUse),
     mOwningNode(aOwningNodeToUse),
     mDisabled(aCopy.mDisabled),
     mDirty(PR_FALSE),
     mInner(aCopy.mInner),
@@ -930,53 +978,34 @@ nsCSSStyleSheet::nsCSSStyleSheet(const n
 
   if (aCopy.mRuleCollection && 
       aCopy.mRuleCollection->mRulesAccessed) {  // CSSOM's been there, force full copy now
     NS_ASSERTION(mInner->mComplete, "Why have rules been accessed on an incomplete sheet?");
     EnsureUniqueInner();
   }
 
   if (aCopy.mMedia) {
+    // XXX This is wrong; we should be keeping @import rules and
+    // sheets in sync!
     aCopy.mMedia->Clone(getter_AddRefs(mMedia));
-  }
-
-  if (aCopy.mFirstChild) {
-    nsCSSStyleSheet*  otherChild = aCopy.mFirstChild;
-    nsCSSStyleSheet** ourSlot = &mFirstChild;
-    do {
-      // XXX This is wrong; we should be keeping @import rules and
-      // sheets in sync!
-      nsCSSStyleSheet* child = new nsCSSStyleSheet(*otherChild,
-                                                       this,
-                                                       nsnull,
-                                                       aDocumentToUse,
-                                                       nsnull);
-      if (child) {
-        NS_ADDREF(child);
-        (*ourSlot) = child;
-        ourSlot = &(child->mNext);
-      }
-      otherChild = otherChild->mNext;
-    }
-    while (otherChild && ourSlot);
   }
 }
 
 nsCSSStyleSheet::~nsCSSStyleSheet()
 {
-  if (mFirstChild) {
-    nsCSSStyleSheet* child = mFirstChild;
-    do {
+  for (nsCSSStyleSheet* child = mInner->mFirstChild;
+       child;
+       child = child->mNext) {
+    // XXXbz this is a little bogus; see the XXX comment where we
+    // declare mFirstChild.
+    if (child->mParent == this) {
       child->mParent = nsnull;
       child->mDocument = nsnull;
-      child = child->mNext;
-    } while (child);
-    NS_RELEASE(mFirstChild);
+    }
   }
-  NS_IF_RELEASE(mNext);
   if (nsnull != mRuleCollection) {
     mRuleCollection->DropReference();
     NS_RELEASE(mRuleCollection);
   }
   if (mMedia) {
     mMedia->SetStyleSheet(nsnull);
     mMedia = nsnull;
   }
@@ -1180,18 +1209,23 @@ nsCSSStyleSheet::GetOwningDocument(nsIDo
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCSSStyleSheet::SetOwningDocument(nsIDocument* aDocument)
 { // not ref counted
   mDocument = aDocument;
   // Now set the same document on all our child sheets....
-  for (nsCSSStyleSheet* child = mFirstChild; child; child = child->mNext) {
-    child->SetOwningDocument(aDocument);
+  // XXXbz this is a little bogus; see the XXX comment where we
+  // declare mFirstChild.
+  for (nsCSSStyleSheet* child = mInner->mFirstChild;
+       child; child = child->mNext) {
+    if (child->mParent == this) {
+      child->SetOwningDocument(aDocument);
+    }
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCSSStyleSheet::SetOwningNode(nsIDOMNode* aOwningNode)
 { // not ref counted
   mOwningNode = aOwningNode;
@@ -1229,55 +1263,48 @@ nsCSSStyleSheet::ContainsStyleSheet(nsIU
   
   // first check ourself out
   nsresult rv = mInner->mSheetURI->Equals(aURL, &aContains);
   if (NS_FAILED(rv)) aContains = PR_FALSE;
 
   if (aContains) {
     // if we found it and the out-param is there, set it and addref
     if (aTheChild) {
-      rv = QueryInterface( NS_GET_IID(nsIStyleSheet), (void **)aTheChild);
+      rv = CallQueryInterface(this, aTheChild);
     }
   } else {
-    nsCSSStyleSheet*  child = mFirstChild;
     // now check the chil'ins out (recursively)
-    while ((PR_FALSE == aContains) && (nsnull != child)) {
+    for (nsCSSStyleSheet* child = mInner->mFirstChild;
+         child;
+         child = child->mNext) {
       child->ContainsStyleSheet(aURL, aContains, aTheChild);
       if (aContains) {
         break;
-      } else {
-        child = child->mNext;
       }
     }
   }
 
   // NOTE: if there are errors in the above we are handling them locally 
   //       and not promoting them to the caller
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCSSStyleSheet::AppendStyleSheet(nsICSSStyleSheet* aSheet)
 {
   NS_PRECONDITION(nsnull != aSheet, "null arg");
 
   if (NS_SUCCEEDED(WillDirty())) {
-    NS_ADDREF(aSheet);
     nsCSSStyleSheet* sheet = (nsCSSStyleSheet*)aSheet;
 
-    if (! mFirstChild) {
-      mFirstChild = sheet;
+    nsRefPtr<nsCSSStyleSheet>* tail = &mInner->mFirstChild;
+    while (*tail) {
+      tail = &(*tail)->mNext;
     }
-    else {
-      nsCSSStyleSheet* child = mFirstChild;
-      while (child->mNext) {
-        child = child->mNext;
-      }
-      child->mNext = sheet;
-    }
+    *tail = sheet;
   
     // This is not reference counted. Our parent tells us when
     // it's going away.
     sheet->mParent = this;
     sheet->mDocument = mDocument;
     DidDirty();
   }
   return NS_OK;
@@ -1286,31 +1313,25 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsCSSStyleSheet::InsertStyleSheetAt(nsICSSStyleSheet* aSheet, PRInt32 aIndex)
 {
   NS_PRECONDITION(nsnull != aSheet, "null arg");
 
   nsresult result = WillDirty();
 
   if (NS_SUCCEEDED(result)) {
-    NS_ADDREF(aSheet);
     nsCSSStyleSheet* sheet = (nsCSSStyleSheet*)aSheet;
-    nsCSSStyleSheet* child = mFirstChild;
 
-    if (aIndex && child) {
-      while ((0 < --aIndex) && child->mNext) {
-        child = child->mNext;
-      }
-      sheet->mNext = child->mNext;
-      child->mNext = sheet;
+    nsRefPtr<nsCSSStyleSheet>* tail = &mInner->mFirstChild;
+    while (*tail && aIndex) {
+      --aIndex;
+      tail = &(*tail)->mNext;
     }
-    else {
-      sheet->mNext = mFirstChild;
-      mFirstChild = sheet; 
-    }
+    sheet->mNext = *tail;
+    *tail = sheet;
 
     // This is not reference counted. Our parent tells us when
     // it's going away.
     sheet->mParent = this;
     sheet->mDocument = mDocument;
     DidDirty();
   }
   return result;
@@ -1422,43 +1443,40 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsCSSStyleSheet::StyleSheetCount(PRInt32& aCount) const
 {
   // XXX Far from an ideal way to do this, but the hope is that
   // it won't be done too often. If it is, we might want to 
   // consider storing the children in an array.
   aCount = 0;
 
-  const nsCSSStyleSheet* child = mFirstChild;
+  const nsCSSStyleSheet* child = mInner->mFirstChild;
   while (child) {
     aCount++;
     child = child->mNext;
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCSSStyleSheet::GetStyleSheetAt(PRInt32 aIndex, nsICSSStyleSheet*& aSheet) const
 {
   // XXX Ughh...an O(n^2) method for doing iteration. Again, we hope
   // that this isn't done too often. If it is, we need to change the
   // underlying storage mechanism
   aSheet = nsnull;
 
-  if (mFirstChild) {
-    const nsCSSStyleSheet* child = mFirstChild;
-    while ((child) && (0 != aIndex)) {
-      --aIndex;
-      child = child->mNext;
-    }
+  nsCSSStyleSheet* child = mInner->mFirstChild;
+  while (child && (0 != aIndex)) {
+    --aIndex;
+    child = child->mNext;
+  }
     
-    aSheet = (nsICSSStyleSheet*)child;
-    NS_IF_ADDREF(aSheet);
-  }
+  NS_IF_ADDREF(aSheet = child);
 
   return NS_OK;
 }
 
 nsresult  
 nsCSSStyleSheet::EnsureUniqueInner()
 {
   if (1 < mInner->mSheets.Count()) {
@@ -1531,20 +1549,20 @@ void nsCSSStyleSheet::List(FILE* out, PR
   if (mMedia) {
     fputs(" media: ", out);
     nsAutoString  buffer;
     mMedia->GetText(buffer);
     fputs(NS_ConvertUTF16toUTF8(buffer).get(), out);
   }
   fputs("\n", out);
 
-  const nsCSSStyleSheet*  child = mFirstChild;
-  while (nsnull != child) {
+  for (const nsCSSStyleSheet*  child = mInner->mFirstChild;
+       child;
+       child = child->mNext) {
     child->List(out, aIndent + 1);
-    child = child->mNext;
   }
 
   fputs("Rules in source order:\n", out);
   ListRules(mInner->mOrderedRules, out, aIndent);
 }
 #endif
 
 static PRBool PR_CALLBACK
diff -r b7bcdd009540 layout/style/nsCSSStyleSheet.h
--- a/layout/style/nsCSSStyleSheet.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/style/nsCSSStyleSheet.h	Thu Sep 11 15:19:26 2008 +0300
@@ -51,54 +51,63 @@
 #include "nsIDOMCSSStyleSheet.h"
 #include "nsICSSLoaderObserver.h"
 #include "nsVoidArray.h"
 #include "nsCOMArray.h"
 
 class nsIURI;
 class nsMediaList;
 class nsMediaQueryResultCacheKey;
+class nsCSSStyleSheet;
 
 // -------------------------------
 // CSS Style Sheet Inner Data Container
 //
 
 class nsCSSStyleSheetInner {
 public:
-  nsCSSStyleSheetInner(nsICSSStyleSheet* aParentSheet);
-  nsCSSStyleSheetInner(nsCSSStyleSheetInner& aCopy, nsICSSStyleSheet* aParentSheet);
+  nsCSSStyleSheetInner(nsICSSStyleSheet* aPrimarySheet);
+  nsCSSStyleSheetInner(nsCSSStyleSheetInner& aCopy,
+                       nsCSSStyleSheet* aPrimarySheet);
   virtual ~nsCSSStyleSheetInner();
 
-  virtual nsCSSStyleSheetInner* CloneFor(nsICSSStyleSheet* aParentSheet);
-  virtual void AddSheet(nsICSSStyleSheet* aParentSheet);
-  virtual void RemoveSheet(nsICSSStyleSheet* aParentSheet);
+  virtual nsCSSStyleSheetInner* CloneFor(nsCSSStyleSheet* aPrimarySheet);
+  virtual void AddSheet(nsICSSStyleSheet* aSheet);
+  virtual void RemoveSheet(nsICSSStyleSheet* aSheet);
 
   virtual void RebuildNameSpaces();
 
   nsAutoVoidArray        mSheets;
   nsCOMPtr<nsIURI>       mSheetURI; // for error reports, etc.
   nsCOMPtr<nsIURI>       mOriginalSheetURI;  // for GetHref.  Can be null.
   nsCOMPtr<nsIURI>       mBaseURI; // for resolving relative URIs
   nsCOMPtr<nsIPrincipal> mPrincipal;
   nsCOMArray<nsICSSRule> mOrderedRules;
   nsAutoPtr<nsXMLNameSpaceMap> mNameSpaceMap;
   PRBool                 mComplete;
+  // Linked list of child sheets.  This is al fundamentally broken, because
+  // each of the child sheets has a unique parent... We can only hope (and
+  // currently this is the case) that any time page JS can get ts hands on a
+  // child sheet that means we've already ensured unique inners throughout its
+  // parent chain and things are good.
+  nsRefPtr<nsCSSStyleSheet> mFirstChild;
 
 #ifdef DEBUG
   PRBool                 mPrincipalSet;
 #endif
 };
 
 
 // -------------------------------
 // CSS Style Sheet
 //
 
 class CSSRuleListImpl;
 static PRBool CascadeSheetRulesInto(nsICSSStyleSheet* aSheet, void* aData);
+struct ChildSheetListBuilder;
 
 class nsCSSStyleSheet : public nsICSSStyleSheet, 
                         public nsIDOMCSSStyleSheet,
                         public nsICSSLoaderObserver
 {
 public:
   nsCSSStyleSheet();
 
@@ -195,29 +204,29 @@ protected:
   // Return success if the subject principal subsumes the principal of our
   // inner, error otherwise.  This will also succeed if the subject has
   // UniversalBrowserWrite.
   nsresult SubjectSubsumesInnerPrincipal() const;
 
 protected:
   nsString              mTitle;
   nsCOMPtr<nsMediaList> mMedia;
-  nsCSSStyleSheet*      mFirstChild;
-  nsCSSStyleSheet*      mNext;
+  nsRefPtr<nsCSSStyleSheet> mNext;
   nsICSSStyleSheet*     mParent;    // weak ref
   nsICSSImportRule*     mOwnerRule; // weak ref
 
   CSSRuleListImpl*      mRuleCollection;
   nsIDocument*          mDocument; // weak ref; parents maintain this for their children
   nsIDOMNode*           mOwningNode; // weak ref
   PRPackedBool          mDisabled;
   PRPackedBool          mDirty; // has been modified 
 
   nsCSSStyleSheetInner* mInner;
 
   nsAutoVoidArray*      mRuleProcessors;
 
   friend class nsMediaList;
   friend PRBool CascadeSheetRulesInto(nsICSSStyleSheet* aSheet, void* aData);
   friend nsresult NS_NewCSSStyleSheet(nsICSSStyleSheet** aInstancePtrResult);
+  friend struct ChildSheetListBuilder;
 };
 
 #endif /* !defined(nsCSSStyleSheet_h_) */
diff -r b7bcdd009540 layout/style/test/Makefile.in
--- a/layout/style/test/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/style/test/Makefile.in	Thu Sep 11 15:19:26 2008 +0300
@@ -90,16 +90,17 @@ _TEST_FILES =	test_acid3_test46.html \
 		test_bug389464.html \
 		test_bug391034.html \
 		test_bug391221.html \
 		test_bug397427.html \
 		test_bug401046.html \
 		test_bug405818.html \
 		test_bug412901.html \
 		test_bug437915.html \
+		test_bug453896_deck.html \
 		test_cascade.html \
 		test_compute_data_with_start_struct.html \
 		test_css_eof_handling.html \
 		test_dont_use_document_colors.html \
 		test_font_face_parser.html \
 		test_inherit_computation.html \
 		test_inherit_storage.html \
 		test_initial_computation.html \
@@ -131,13 +132,22 @@ _TEST_FILES =	test_acid3_test46.html \
 		redirect-3.css^headers^ \
 		post-redirect-3.css \
 		xbl_bindings.xml \
 		empty.html \
 		media_queries_iframe.html \
 		media_queries_dynamic_xbl_binding.xml \
 		media_queries_dynamic_xbl_iframe.html \
 		media_queries_dynamic_xbl_style.css \
+		bug453896_iframe.html \
 		$(NULL)
 
+_BROWSER_FILES = \
+		browser_bug453896.js \
+		bug453896_iframe.html \
+		media_queries_iframe.html \
+		$(NULL)
 
 libs:: $(_TEST_FILES)
 	$(INSTALL) $(foreach f,$^,"$f") $(DEPTH)/_tests/testing/mochitest/tests/$(relativesrcdir)
+
+libs:: $(_BROWSER_FILES)
+	$(INSTALL) $(foreach f,$^,"$f") $(DEPTH)/_tests/testing/mochitest/browser/$(relativesrcdir)
diff -r b7bcdd009540 layout/style/test/browser_bug453896.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/style/test/browser_bug453896.js	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,25 @@
+var listener = {
+  handleEvent : function(e) {
+    if (e.target == theBrowser.contentDocument)
+      doTest();
+  }
+}
+
+var theTab;
+var theBrowser;
+
+function test() {
+  waitForExplicitFinish();
+
+  theTab = gBrowser.addTab();
+  theBrowser = gBrowser.getBrowserForTab(theTab);
+  theBrowser.addEventListener("load", listener, true);
+  theBrowser.contentWindow.location = "chrome://mochikit/content/browser/layout/style/test/bug453896_iframe.html";
+}
+
+function doTest() {
+  theBrowser.removeEventListener("load", listener, true);
+  var fake_window = { ok: ok, SimpleTest: { finish: finish } };
+  theBrowser.contentWindow.wrappedJSObject.run(fake_window);
+  gBrowser.removeTab(theTab);
+}
diff -r b7bcdd009540 layout/style/test/bug453896_iframe.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/style/test/bug453896_iframe.html	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,68 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
+  "http://www.w3.org/TR/html4/strict.dtd">
+<html lang="en-US">
+<head>
+  <title>Bug 453896 Test middle frame</title>
+  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
+  <meta http-equiv="Content-Style-Type" content="text/css">
+  <script type="application/javascript; version=1.7">
+
+function run(test_window)
+{
+  var subdoc = document.getElementById("subdoc").contentDocument;
+  var subwin = document.getElementById("subdoc").contentWindow;
+  var style = subdoc.getElementById("style");
+  var iframe_style = document.getElementById("subdoc").style;
+  var body_cs = subdoc.defaultView.getComputedStyle(subdoc.body, "");
+
+  function query_applies(q) {
+    style.setAttribute("media", q);
+    return body_cs.getPropertyValue("text-decoration") == "underline";
+  }
+
+  function should_apply(q) {
+    test_window.ok(query_applies(q), q + " should apply");
+  }
+
+  function should_not_apply(q) {
+    test_window.ok(!query_applies(q), q + " should not apply");
+  }
+
+  // in this test, assume the common underlying implementation is correct
+  let width_val = 157; // pick two not-too-round numbers
+  let height_val = 182;
+  iframe_style.width = width_val + "px";
+  iframe_style.height = height_val + "px";
+  for (let [feature, value] in
+         Iterator({ "width": width_val, "height": height_val })) {
+    should_apply("all and (" + feature + ": " + value + "px)");
+    should_not_apply("all and (" + feature + ": " + (value + 1) + "px)");
+    should_not_apply("all and (" + feature + ": " + (value - 1) + "px)");
+  }
+
+  iframe_style.width = "0";
+  should_apply("all and (height)");
+  should_not_apply("all and (width)");
+  iframe_style.height = "0";
+  should_not_apply("all and (height)");
+  should_not_apply("all and (width)");
+  should_apply("all and (device-height)");
+  should_apply("all and (device-width)");
+  iframe_style.width = width_val + "px";
+  should_not_apply("all and (height)");
+  should_apply("all and (width)");
+  iframe_style.height = height_val + "px";
+  should_apply("all and (height)");
+  should_apply("all and (width)");
+
+  test_window.SimpleTest.finish();
+}
+
+  </script>
+</head>
+<body>
+
+<iframe id="subdoc" src="media_queries_iframe.html"></iframe>
+
+</body>
+</html>
diff -r b7bcdd009540 layout/style/test/test_bug453896_deck.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/style/test/test_bug453896_deck.html	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,42 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=453896
+-->
+<head>
+  <title>Test for Bug 453896</title>
+  <script type="text/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body onload="run()">
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=453896">Mozilla Bug 453896</a>
+<div id="display">
+
+<div style="display:-moz-deck; height: 300px; width: 300px;">
+  <iframe src="about:blank"></iframe>
+  <iframe id="subdoc" src="bug453896_iframe.html"></iframe>
+  <iframe src="about:blank"></iframe>
+</div>
+
+<pre id="test">
+<script class="testbody" type="text/javascript">
+
+/** Test for Bug 453896 **/
+
+function run()
+{
+  var iframe = document.getElementById("subdoc");
+  var subdoc = iframe.contentDocument;
+  var subwin = iframe.contentWindow;
+
+  subwin.run(window);
+}
+
+SimpleTest.waitForExplicitFinish();
+
+</script>
+</pre>
+</body>
+</html>
+
diff -r b7bcdd009540 layout/style/test/test_media_queries.html
--- a/layout/style/test/test_media_queries.html	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/style/test/test_media_queries.html	Thu Sep 11 15:19:26 2008 +0300
@@ -37,24 +37,16 @@ function run() {
   }
 
   function should_apply(q) {
     ok(query_applies(q), q + " should apply");
   }
 
   function should_not_apply(q) {
     ok(!query_applies(q), q + " should not apply");
-  }
-
-  function todo_should_apply(q) {
-    todo(query_applies(q), q + " should apply");
-  }
-
-  function todo_should_not_apply(q) {
-    todo(!query_applies(q), q + " should not apply");
   }
 
   /*
    * Functions to test whether a query is parseable at all.  (Should not
    * be used for parse errors within expressions.)
    */
   var parse_test_style_element = document.createElement("style");
   parse_test_style_element.type = "text/css";
@@ -164,30 +156,27 @@ function run() {
     should_apply("all and (min-" + feature + ": " +
                  (Math.floor(value/em_size) - 1) + "em)");
     should_apply("all and (max-" + feature + ": " +
                  (Math.ceil(value/em_size) + 1) + "em)");
     should_not_apply("all and (max-" + feature + ": " +
                      (Math.floor(value/em_size) - 1) + "em)");
   }
 
-  // TODO:  There are a bunch of todos here because of a bug related
-  // to dynamic changes not going into effect once one dimension is 0.
-  // (Patch to fix this is in bug 453759.)
   iframe_style.width = "0";
   should_apply("all and (height)");
   should_not_apply("all and (width)");
   iframe_style.height = "0";
-  todo_should_not_apply("all and (height)");
+  should_not_apply("all and (height)");
   should_not_apply("all and (width)");
   should_apply("all and (device-height)");
   should_apply("all and (device-width)");
   iframe_style.width = width_val + "px";
-  todo_should_not_apply("all and (height)");
-  todo_should_apply("all and (width)");
+  should_not_apply("all and (height)");
+  should_apply("all and (width)");
   iframe_style.height = height_val + "px";
   should_apply("all and (height)");
   should_apply("all and (width)");
 
   // ratio that reduces to 59/40
   iframe_style.width = "236px";
   iframe_style.height = "160px";
   expression_should_be_parseable("orientation");
diff -r b7bcdd009540 layout/style/ua.css
--- a/layout/style/ua.css	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/style/ua.css	Thu Sep 11 15:19:26 2008 +0300
@@ -123,16 +123,19 @@
   display: block !important;
   position: static !important;
 }
 
 *|*::-moz-anonymous-block, *|*::-moz-anonymous-positioned-block {
   /* we currently inherit from the inline that is split */
   outline: inherit;
   -moz-outline-offset: inherit;
+  clip-path: inherit;
+  filter: inherit;
+  mask: inherit;
 }
 
 *|*::-moz-xul-anonymous-block {
   display: block ! important;
   position: static ! important;
   float: none ! important;
 }
 
diff -r b7bcdd009540 layout/svg/base/src/Makefile.in
--- a/layout/svg/base/src/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/svg/base/src/Makefile.in	Thu Sep 11 15:19:26 2008 +0300
@@ -75,16 +75,17 @@ CPPSRCS		= \
 		nsSVGForeignObjectFrame.cpp \
 		nsSVGGFrame.cpp \
 		nsSVGGenericContainerFrame.cpp \
 		nsSVGGeometryFrame.cpp \
 		nsSVGGlyphFrame.cpp \
 		nsSVGGradientFrame.cpp \
 		nsSVGImageFrame.cpp \
 		nsSVGInnerSVGFrame.cpp \
+		nsSVGIntegrationUtils.cpp \
 		nsSVGLeafFrame.cpp \
 		nsSVGMarkerFrame.cpp \
 		nsSVGMaskFrame.cpp \
 		nsSVGOuterSVGFrame.cpp \
 		nsSVGPaintServerFrame.cpp \
 		nsSVGPathGeometryFrame.cpp \
 		nsSVGPatternFrame.cpp \
 		nsSVGStopFrame.cpp \
@@ -98,16 +99,17 @@ CPPSRCS		= \
 		$(NULL)
 
 include $(topsrcdir)/config/config.mk
 
 # we don't want the shared lib, but we want to force the creation of a static lib.
 FORCE_STATIC_LIB = 1
 
 EXPORTS = \
+	nsSVGIntegrationUtils.h \
 	nsSVGUtils.h \
 	nsSVGFilterInstance.h \
 	nsSVGForeignObjectFrame.h \
 	$(NULL)
 
 include $(topsrcdir)/config/rules.mk
 
 LOCAL_INCLUDES	= \
diff -r b7bcdd009540 layout/svg/base/src/nsISVGChildFrame.h
--- a/layout/svg/base/src/nsISVGChildFrame.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/svg/base/src/nsISVGChildFrame.h	Thu Sep 11 15:19:26 2008 +0300
@@ -46,18 +46,18 @@
 
 class gfxContext;
 class nsPresContext;
 class nsIDOMSVGRect;
 class nsIDOMSVGMatrix;
 class nsSVGRenderState;
 
 #define NS_ISVGCHILDFRAME_IID \
-{ 0xe4ecddbf, 0xde7c, 0x4cd9, \
- { 0x92, 0x4a, 0xfa, 0x81, 0xba, 0x83, 0x26, 0x69 } }
+{ 0x8b80b2a0, 0x2e1f, 0x4775, \
+  { 0xab, 0x47, 0xbe, 0xeb, 0x4b, 0x81, 0x63, 0x6d } }
 
 class nsISVGChildFrame : public nsISupports {
 public:
 
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_ISVGCHILDFRAME_IID)
 
   // Paint this frame - aDirtyRect is the area being redrawn, in frame
   // offset pixel coordinates
@@ -93,16 +93,17 @@ public:
   };
   virtual void NotifySVGChanged(PRUint32 aFlags)=0;
   NS_IMETHOD NotifyRedrawSuspended()=0;
   NS_IMETHOD NotifyRedrawUnsuspended()=0;
 
   // Set whether we should stop multiplying matrices when building up
   // the current transformation matrix at this frame.
   NS_IMETHOD SetMatrixPropagation(PRBool aPropagate)=0;
+  virtual PRBool GetMatrixPropagation()=0;
 
   // Set the current transformation matrix to a particular matrix.
   // Value is only used if matrix propagation is prevented
   // (SetMatrixPropagation()).  nsnull aCTM means identity transform.
   NS_IMETHOD SetOverrideCTM(nsIDOMSVGMatrix *aCTM)=0;
   virtual already_AddRefed<nsIDOMSVGMatrix> GetOverrideCTM()=0;
 
   // XXX move this function into interface nsISVGLocatableMetrics
diff -r b7bcdd009540 layout/svg/base/src/nsSVGClipPathFrame.cpp
--- a/layout/svg/base/src/nsSVGClipPathFrame.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/svg/base/src/nsSVGClipPathFrame.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -56,17 +56,17 @@ NS_NewSVGClipPathFrame(nsIPresShell* aPr
     return nsnull;
   }
 
   return new (aPresShell) nsSVGClipPathFrame(aContext);
 }
 
 nsresult
 nsSVGClipPathFrame::ClipPaint(nsSVGRenderState* aContext,
-                              nsISVGChildFrame* aParent,
+                              nsIFrame* aParent,
                               nsIDOMSVGMatrix *aMatrix)
 {
   // If the flag is set when we get here, it means this clipPath frame
   // has already been used painting the current clip, and the document
   // has a clip reference loop.
   if (mInUse) {
     NS_WARNING("Clip loop detected!");
     return NS_OK;
@@ -98,17 +98,17 @@ nsSVGClipPathFrame::ClipPaint(nsSVGRende
     aContext->GetGfxContext()->Clip();
     aContext->GetGfxContext()->NewPath();
   }
 
   return NS_OK;
 }
 
 PRBool
-nsSVGClipPathFrame::ClipHitTest(nsISVGChildFrame* aParent,
+nsSVGClipPathFrame::ClipHitTest(nsIFrame* aParent,
                                 nsIDOMSVGMatrix *aMatrix,
                                 const nsPoint &aPoint)
 {
   // If the flag is set when we get here, it means this clipPath frame
   // has already been used in hit testing against the current clip,
   // and the document has a clip reference loop.
   if (mInUse) {
     NS_WARNING("Clip loop detected!");
diff -r b7bcdd009540 layout/svg/base/src/nsSVGClipPathFrame.h
--- a/layout/svg/base/src/nsSVGClipPathFrame.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/svg/base/src/nsSVGClipPathFrame.h	Thu Sep 11 15:19:26 2008 +0300
@@ -49,20 +49,20 @@ protected:
   nsSVGClipPathFrame(nsStyleContext* aContext) :
     nsSVGClipPathFrameBase(aContext),
     mClipParentMatrix(nsnull),
     mInUse(PR_FALSE) {}
 
 public:
   // nsSVGClipPathFrame methods:
   nsresult ClipPaint(nsSVGRenderState* aContext,
-                     nsISVGChildFrame* aParent,
+                     nsIFrame* aParent,
                      nsIDOMSVGMatrix *aMatrix);
 
-  PRBool ClipHitTest(nsISVGChildFrame* aParent,
+  PRBool ClipHitTest(nsIFrame* aParent,
                      nsIDOMSVGMatrix *aMatrix,
                      const nsPoint &aPoint);
 
   // Check if this clipPath is made up of more than one geometry object.
   // If so, the clipping API in cairo isn't enough and we need to use
   // mask based clipping.
   PRBool IsTrivial();
 
@@ -95,17 +95,17 @@ public:
     }
     ~AutoClipPathReferencer() {
       mFrame->mInUse = PR_FALSE;
     }
   private:
     nsSVGClipPathFrame *mFrame;
   };
 
-  nsISVGChildFrame *mClipParent;
+  nsIFrame *mClipParent;
   nsCOMPtr<nsIDOMSVGMatrix> mClipParentMatrix;
 
   // nsSVGContainerFrame methods:
   virtual already_AddRefed<nsIDOMSVGMatrix> GetCanvasTM();
 
   // recursion prevention flag
   PRPackedBool mInUse;
 };
diff -r b7bcdd009540 layout/svg/base/src/nsSVGContainerFrame.cpp
--- a/layout/svg/base/src/nsSVGContainerFrame.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/svg/base/src/nsSVGContainerFrame.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -83,26 +83,27 @@ nsSVGContainerFrame::RemoveFrame(nsIAtom
   return mFrames.DestroyFrame(aOldFrame) ? NS_OK : NS_ERROR_FAILURE;
 }
 
 NS_IMETHODIMP
 nsSVGContainerFrame::Init(nsIContent* aContent,
                           nsIFrame* aParent,
                           nsIFrame* aPrevInFlow)
 {
-  AddStateBits(NS_STATE_SVG_NONDISPLAY_CHILD);
+  AddStateBits(NS_STATE_SVG_NONDISPLAY_CHILD | NS_STATE_SVG_PROPAGATE_TRANSFORM);
   nsresult rv = nsSVGContainerFrameBase::Init(aContent, aParent, aPrevInFlow);
   return rv;
 }
 
 NS_IMETHODIMP
 nsSVGDisplayContainerFrame::Init(nsIContent* aContent,
                                  nsIFrame* aParent,
                                  nsIFrame* aPrevInFlow)
 {
+  AddStateBits(NS_STATE_SVG_PROPAGATE_TRANSFORM);
   if (!(GetStateBits() & NS_STATE_IS_OUTER_SVG)) {
     AddStateBits(aParent->GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD);
   }
   nsresult rv = nsSVGContainerFrameBase::Init(aContent, aParent, aPrevInFlow);
   return rv;
 }
 
 NS_IMETHODIMP
@@ -272,8 +273,25 @@ nsSVGDisplayContainerFrame::NotifyRedraw
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsSVGDisplayContainerFrame::GetBBox(nsIDOMSVGRect **_retval)
 {
   return nsSVGUtils::GetBBox(&mFrames, _retval);
 }
+
+NS_IMETHODIMP
+nsSVGDisplayContainerFrame::SetMatrixPropagation(PRBool aPropagate)
+{
+  if (aPropagate) {
+    AddStateBits(NS_STATE_SVG_PROPAGATE_TRANSFORM);
+  } else {
+    RemoveStateBits(NS_STATE_SVG_PROPAGATE_TRANSFORM);
+  }
+  return NS_OK;
+}
+
+PRBool
+nsSVGDisplayContainerFrame::GetMatrixPropagation()
+{
+  return (GetStateBits() & NS_STATE_SVG_PROPAGATE_TRANSFORM) != 0;
+}
diff -r b7bcdd009540 layout/svg/base/src/nsSVGContainerFrame.h
--- a/layout/svg/base/src/nsSVGContainerFrame.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/svg/base/src/nsSVGContainerFrame.h	Thu Sep 11 15:19:26 2008 +0300
@@ -104,17 +104,18 @@ public:
   NS_IMETHOD PaintSVG(nsSVGRenderState* aContext, nsIntRect *aDirtyRect);
   NS_IMETHOD_(nsIFrame*) GetFrameForPoint(const nsPoint &aPoint);
   NS_IMETHOD_(nsRect) GetCoveredRegion();
   NS_IMETHOD UpdateCoveredRegion();
   NS_IMETHOD InitialUpdate();
   virtual void NotifySVGChanged(PRUint32 aFlags);
   NS_IMETHOD NotifyRedrawSuspended();
   NS_IMETHOD NotifyRedrawUnsuspended();
-  NS_IMETHOD SetMatrixPropagation(PRBool aPropagate) { return NS_ERROR_FAILURE; }
+  NS_IMETHOD SetMatrixPropagation(PRBool aPropagate);
+  virtual PRBool GetMatrixPropagation();
   NS_IMETHOD SetOverrideCTM(nsIDOMSVGMatrix *aCTM) { return NS_ERROR_FAILURE; }
   virtual already_AddRefed<nsIDOMSVGMatrix> GetOverrideCTM() { return nsnull; }
   NS_IMETHOD GetBBox(nsIDOMSVGRect **_retval);
   NS_IMETHOD_(PRBool) IsDisplayContainer() { return PR_TRUE; }
   NS_IMETHOD_(PRBool) HasValidCoveredRect() { return PR_FALSE; }
 };
 
 #endif
diff -r b7bcdd009540 layout/svg/base/src/nsSVGEffects.cpp
--- a/layout/svg/base/src/nsSVGEffects.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/svg/base/src/nsSVGEffects.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -122,17 +122,17 @@ nsSVGFilterProperty::nsSVGFilterProperty
   UpdateRect();
 }
 
 void
 nsSVGFilterProperty::UpdateRect()
 {
   nsSVGFilterFrame *filter = GetFilterFrame(nsnull);
   if (filter) {
-    mFilterRect = filter->GetInvalidationRegion(mFrame, mFrame->GetRect());
+    mFilterRect = filter->GetFilterBBox(mFrame, nsnull);
   } else {
     mFilterRect = nsRect();
   }
 }
 
 void
 nsSVGFilterProperty::DoUpdate()
 {
diff -r b7bcdd009540 layout/svg/base/src/nsSVGFilterFrame.cpp
--- a/layout/svg/base/src/nsSVGFilterFrame.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/svg/base/src/nsSVGFilterFrame.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -37,21 +37,23 @@
 #include "nsSVGFilterFrame.h"
 #include "nsIDocument.h"
 #include "nsISVGValueUtils.h"
 #include "nsSVGMatrix.h"
 #include "nsSVGOuterSVGFrame.h"
 #include "nsGkAtoms.h"
 #include "nsSVGUtils.h"
 #include "nsSVGFilterElement.h"
-#include "nsSVGFilterInstance.h"
 #include "nsSVGFilters.h"
 #include "gfxASurface.h"
 #include "gfxContext.h"
 #include "gfxImageSurface.h"
+#include "nsSVGFilterPaintCallback.h"
+#include "nsSVGRect.h"
+#include "nsSVGFilterInstance.h"
 
 nsIFrame*
 NS_NewSVGFilterFrame(nsIPresShell* aPresShell, nsIContent* aContent, nsStyleContext* aContext)
 {
   nsCOMPtr<nsIDOMSVGFilterElement> filter = do_QueryInterface(aContent);
   if (!filter) {
     NS_ERROR("Can't create frame! Content is not an SVG filter");
     return nsnull;
@@ -73,212 +75,233 @@ MapDeviceRectToFilterSpace(const gfxMatr
     nsIntRect intRect;
     if (NS_SUCCEEDED(nsSVGUtils::GfxRectToIntRect(r, &intRect))) {
       rect = intRect;
     }
   }
   return rect;
 }
 
-nsresult
-nsSVGFilterFrame::CreateInstance(nsISVGChildFrame *aTarget,
-                                 const nsIntRect *aDirtyOutputRect,
-                                 const nsIntRect *aDirtyInputRect,
-                                 nsSVGFilterInstance **aInstance)
+class NS_STACK_CLASS nsAutoFilterInstance {
+public:
+  nsAutoFilterInstance(nsIFrame *aTarget,
+                       nsSVGFilterFrame *aFilterFrame,
+                       nsSVGFilterPaintCallback *aPaint,
+                       const nsIntRect *aDirtyOutputRect,
+                       const nsIntRect *aDirtyInputRect,
+                       const nsIntRect *aOverrideSourceBBox);
+  ~nsAutoFilterInstance();
+
+  // If this returns null, then draw nothing. Either the filter draws
+  // nothing or it is "in error".
+  nsSVGFilterInstance* get() { return mInstance; }
+
+private:
+  nsAutoPtr<nsSVGFilterInstance> mInstance;
+  // Store mTarget separately even though mInstance has it, because if
+  // mInstance creation fails we still need to be able to clean up
+  nsISVGChildFrame*              mTarget;
+};
+
+nsAutoFilterInstance::nsAutoFilterInstance(nsIFrame *aTarget,
+                                           nsSVGFilterFrame *aFilterFrame,
+                                           nsSVGFilterPaintCallback *aPaint,
+                                           const nsIntRect *aDirtyOutputRect,
+                                           const nsIntRect *aDirtyInputRect,
+                                           const nsIntRect *aOverrideSourceBBox)
 {
-  *aInstance = nsnull;
+  nsCOMPtr<nsIDOMSVGMatrix> ctm = nsSVGUtils::GetCanvasTM(aTarget);
 
-  nsIFrame *frame;
-  CallQueryInterface(aTarget, &frame);
+  CallQueryInterface(aTarget, &mTarget);
+  if (mTarget) {
+    mTarget->SetMatrixPropagation(PR_FALSE);
+    mTarget->NotifySVGChanged(nsISVGChildFrame::SUPPRESS_INVALIDATION |
+                              nsISVGChildFrame::TRANSFORM_CHANGED);
+  }
 
-  nsCOMPtr<nsIDOMSVGMatrix> ctm = nsSVGUtils::GetCanvasTM(frame);
-
-  nsSVGElement *target = static_cast<nsSVGElement*>(frame->GetContent());
-
-  aTarget->SetMatrixPropagation(PR_FALSE);
-  aTarget->NotifySVGChanged(nsISVGChildFrame::SUPPRESS_INVALIDATION |
-                            nsISVGChildFrame::TRANSFORM_CHANGED);
-
-  nsSVGFilterElement *filter = static_cast<nsSVGFilterElement*>(mContent);
-
-  float x, y, width, height;
-  nsCOMPtr<nsIDOMSVGRect> bbox;
-  aTarget->GetBBox(getter_AddRefs(bbox));
-
-  nsSVGLength2 *tmpX, *tmpY, *tmpWidth, *tmpHeight;
-  tmpX = &filter->mLengthAttributes[nsSVGFilterElement::X];
-  tmpY = &filter->mLengthAttributes[nsSVGFilterElement::Y];
-  tmpWidth = &filter->mLengthAttributes[nsSVGFilterElement::WIDTH];
-  tmpHeight = &filter->mLengthAttributes[nsSVGFilterElement::HEIGHT];
+  nsSVGFilterElement *filter = static_cast<nsSVGFilterElement*>(
+          aFilterFrame->GetContent());
 
   PRUint16 units =
     filter->mEnumAttributes[nsSVGFilterElement::FILTERUNITS].GetAnimValue();
+  nsCOMPtr<nsIDOMSVGRect> bbox;
+  if (aOverrideSourceBBox) {
+    NS_NewSVGRect(getter_AddRefs(bbox),
+                  aOverrideSourceBBox->x, aOverrideSourceBBox->y,
+                  aOverrideSourceBBox->width, aOverrideSourceBBox->height);
+  } else {
+    bbox = nsSVGUtils::GetBBox(aTarget);
+  }
+  if (!bbox && units == nsIDOMSVGUnitTypes::SVG_UNIT_TYPE_OBJECTBOUNDINGBOX)
+    return;
 
-  // Compute filter effects region as per spec
-  if (units == nsIDOMSVGUnitTypes::SVG_UNIT_TYPE_OBJECTBOUNDINGBOX) {
-    if (!bbox)
-      return NS_OK;
+  gfxRect filterArea = nsSVGUtils::GetRelativeRect(units,
+    &filter->mLengthAttributes[nsSVGFilterElement::X], bbox, aTarget);
+  filterArea.RoundOut();
 
-    bbox->GetX(&x);
-    x += nsSVGUtils::ObjectSpace(bbox, tmpX);
-    bbox->GetY(&y);
-    y += nsSVGUtils::ObjectSpace(bbox, tmpY);
-    width = nsSVGUtils::ObjectSpace(bbox, tmpWidth);
-    height = nsSVGUtils::ObjectSpace(bbox, tmpHeight);
-  } else {
-    x = nsSVGUtils::UserSpace(target, tmpX);
-    y = nsSVGUtils::UserSpace(target, tmpY);
-    width = nsSVGUtils::UserSpace(target, tmpWidth);
-    height = nsSVGUtils::UserSpace(target, tmpHeight);
-  }
-  
   PRBool resultOverflows;
   gfxIntSize filterRes;
 
   // Compute size of filter buffer
-  if (mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::filterRes)) {
+  if (filter->HasAttr(kNameSpaceID_None, nsGkAtoms::filterRes)) {
     PRInt32 filterResX, filterResY;
     filter->GetAnimatedIntegerValues(&filterResX, &filterResY, nsnull);
 
     filterRes =
       nsSVGUtils::ConvertToSurfaceSize(gfxSize(filterResX, filterResY),
                                        &resultOverflows);
   } else {
     float scale = nsSVGUtils::MaxExpansion(ctm);
 #ifdef DEBUG_tor
     fprintf(stderr, "scale: %f\n", scale);
 #endif
 
     filterRes =
-      nsSVGUtils::ConvertToSurfaceSize(gfxSize(width, height) * scale,
+      nsSVGUtils::ConvertToSurfaceSize(filterArea.size * scale,
                                        &resultOverflows);
   }
 
   // 0 disables rendering, < 0 is error
   if (filterRes.width <= 0 || filterRes.height <= 0)
-    return NS_OK;
-
-#ifdef DEBUG_tor
-  fprintf(stderr, "filter bbox: %f,%f  %fx%f\n", x, y, width, height);
-  fprintf(stderr, "filterRes: %u %u\n", filterRes.width, filterRes.height);
-#endif
+    return;
 
   // 'fini' is the matrix we will finally use to transform filter space
   // to surface space for drawing
   nsCOMPtr<nsIDOMSVGMatrix> scale, fini;
   NS_NewSVGMatrix(getter_AddRefs(scale),
-                  width / filterRes.width, 0.0f,
-                  0.0f, height / filterRes.height,
-                  x, y);
+                  filterArea.Width() / filterRes.width, 0.0f,
+                  0.0f, filterArea.Height() / filterRes.height,
+                  filterArea.X(), filterArea.Y());
   ctm->Multiply(scale, getter_AddRefs(fini));
   
   gfxMatrix finiM = nsSVGUtils::ConvertSVGMatrixToThebes(fini);
   // fini is always invertible.
   finiM.Invert();
 
   nsIntRect dirtyOutputRect =
     MapDeviceRectToFilterSpace(finiM, filterRes, aDirtyOutputRect);
   nsIntRect dirtyInputRect =
     MapDeviceRectToFilterSpace(finiM, filterRes, aDirtyInputRect);
 
   // Setup instance data
   PRUint16 primitiveUnits =
     filter->mEnumAttributes[nsSVGFilterElement::PRIMITIVEUNITS].GetAnimValue();
-  *aInstance = new nsSVGFilterInstance(aTarget, mContent, bbox,
-                                       gfxRect(x, y, width, height),
-                                       nsIntSize(filterRes.width, filterRes.height),
-                                       fini,
-                                       dirtyOutputRect, dirtyInputRect,
-                                       primitiveUnits);
-  return *aInstance ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
+  mInstance = new nsSVGFilterInstance(aTarget, aPaint, filter, bbox, filterArea,
+                                      nsIntSize(filterRes.width, filterRes.height),
+                                      fini,
+                                      dirtyOutputRect, dirtyInputRect,
+                                      primitiveUnits);
 }
 
-static void
-RestoreTargetState(nsISVGChildFrame *aTarget)
+nsAutoFilterInstance::~nsAutoFilterInstance()
 {
-  aTarget->SetOverrideCTM(nsnull);
-  aTarget->SetMatrixPropagation(PR_TRUE);
-  aTarget->NotifySVGChanged(nsISVGChildFrame::SUPPRESS_INVALIDATION |
+  if (!mTarget)
+    return;
+
+  mTarget->SetOverrideCTM(nsnull);
+  mTarget->SetMatrixPropagation(PR_TRUE);
+  mTarget->NotifySVGChanged(nsISVGChildFrame::SUPPRESS_INVALIDATION |
                             nsISVGChildFrame::TRANSFORM_CHANGED);
 }
 
 nsresult
 nsSVGFilterFrame::FilterPaint(nsSVGRenderState *aContext,
-                              nsISVGChildFrame *aTarget,
+                              nsIFrame *aTarget,
+                              nsSVGFilterPaintCallback *aPaintCallback,
                               const nsIntRect *aDirtyRect)
 {
-  nsAutoPtr<nsSVGFilterInstance> instance;
-  nsresult rv = CreateInstance(aTarget, aDirtyRect, nsnull, getter_Transfers(instance));
+  nsAutoFilterInstance instance(aTarget, this, aPaintCallback,
+    aDirtyRect, nsnull, nsnull);
+  if (!instance.get())
+    return NS_OK;
 
-  if (NS_SUCCEEDED(rv) && instance) {
-    // Transformation from user space to filter space
-    nsCOMPtr<nsIDOMSVGMatrix> filterTransform =
-      instance->GetUserSpaceToFilterSpaceTransform();
-    aTarget->SetOverrideCTM(filterTransform);
-    aTarget->NotifySVGChanged(nsISVGChildFrame::SUPPRESS_INVALIDATION |
-                              nsISVGChildFrame::TRANSFORM_CHANGED);
-
-    nsRefPtr<gfxASurface> result;
-    rv = instance->Render(getter_AddRefs(result));
-    if (NS_SUCCEEDED(rv) && result) {
-      nsSVGUtils::CompositeSurfaceMatrix(aContext->GetGfxContext(),
-        result, instance->GetFilterSpaceToDeviceSpaceTransform(), 1.0);
-    }
-  }
-
-  RestoreTargetState(aTarget);
-
-  if (NS_FAILED(rv)) {
-    aTarget->PaintSVG(aContext, nsnull);
+  nsRefPtr<gfxASurface> result;
+  nsresult rv = instance.get()->Render(getter_AddRefs(result));
+  if (NS_SUCCEEDED(rv) && result) {
+    nsSVGUtils::CompositeSurfaceMatrix(aContext->GetGfxContext(),
+      result, instance.get()->GetFilterSpaceToDeviceSpaceTransform(), 1.0);
   }
   return rv;
 }
 
-nsRect
-nsSVGFilterFrame::GetInvalidationRegion(nsIFrame *aTarget, const nsRect& aRect)
+static nsresult
+TransformFilterSpaceToDeviceSpace(nsSVGFilterInstance *aInstance, nsIntRect *aRect)
 {
-  nsISVGChildFrame *svg;
-  CallQueryInterface(aTarget, &svg);
+  gfxMatrix m = nsSVGUtils::ConvertSVGMatrixToThebes(
+    aInstance->GetFilterSpaceToDeviceSpaceTransform());
+  gfxRect r(aRect->x, aRect->y, aRect->width, aRect->height);
+  r = m.TransformBounds(r);
+  r.RoundOut();
+  nsIntRect deviceRect;
+  nsresult rv = nsSVGUtils::GfxRectToIntRect(r, &deviceRect);
+  if (NS_FAILED(rv))
+    return rv;
+  *aRect = deviceRect;
+  return NS_OK;
+}
 
-  nscoord p2a = aTarget->PresContext()->AppUnitsPerDevPixel();
-  nsRect result = aRect;
-  nsIntRect rect = aRect;
-  rect.ScaleRoundOut(1.0/p2a);
+nsIntRect
+nsSVGFilterFrame::GetInvalidationBBox(nsIFrame *aTarget, const nsIntRect& aRect)
+{
+  nsAutoFilterInstance instance(aTarget, this, nsnull, nsnull, &aRect, nsnull);
+  if (!instance.get())
+    return nsIntRect();
 
-  nsAutoPtr<nsSVGFilterInstance> instance;
-  nsresult rv = CreateInstance(svg, nsnull, &rect, getter_Transfers(instance));
+  // We've passed in the source's dirty area so the instance knows about it.
+  // Now we can ask the instance to compute the area of the filter output
+  // that's dirty.
+  nsIntRect dirtyRect;
+  nsresult rv = instance.get()->ComputeOutputDirtyRect(&dirtyRect);
   if (NS_SUCCEEDED(rv)) {
-    if (!instance) {
-      // The filter draws nothing, so nothing is dirty.
-      result = nsRect();
-    } else {
-      // We've passed in the source's dirty area so the instance knows about it.
-      // Now we can ask the instance to compute the area of the filter output
-      // that's dirty.
-      nsIntRect filterSpaceDirtyRect;
-      rv = instance->ComputeOutputDirtyRect(&filterSpaceDirtyRect);
-      if (NS_SUCCEEDED(rv)) {
-        gfxMatrix m = nsSVGUtils::ConvertSVGMatrixToThebes(
-          instance->GetFilterSpaceToDeviceSpaceTransform());
-        gfxRect r(filterSpaceDirtyRect.x, filterSpaceDirtyRect.y,
-                  filterSpaceDirtyRect.width, filterSpaceDirtyRect.height);
-        r = m.TransformBounds(r);
-        r.RoundOut();
-        nsIntRect deviceRect;
-        rv = nsSVGUtils::GfxRectToIntRect(r, &deviceRect);
-        if (NS_SUCCEEDED(rv)) {
-          deviceRect.ScaleRoundOut(p2a);
-          result = deviceRect;
-        }
-      }
-    }
+    rv = TransformFilterSpaceToDeviceSpace(instance.get(), &dirtyRect);
+    if (NS_SUCCEEDED(rv))
+      return dirtyRect;
   }
 
-  RestoreTargetState(svg);
-
-  return result;
+  return nsIntRect();
 }
 
+nsIntRect
+nsSVGFilterFrame::GetSourceForInvalidArea(nsIFrame *aTarget, const nsIntRect& aRect)
+{
+  nsAutoFilterInstance instance(aTarget, this, nsnull, &aRect, nsnull, nsnull);
+  if (!instance.get())
+    return nsIntRect();
+
+  // Now we can ask the instance to compute the area of the source
+  // that's needed.
+  nsIntRect neededRect;
+  nsresult rv = instance.get()->ComputeSourceNeededRect(&neededRect);
+  if (NS_SUCCEEDED(rv)) {
+    rv = TransformFilterSpaceToDeviceSpace(instance.get(), &neededRect);
+    if (NS_SUCCEEDED(rv))
+      return neededRect;
+  }
+
+  return nsIntRect();
+}
+
+nsIntRect
+nsSVGFilterFrame::GetFilterBBox(nsIFrame *aTarget, const nsIntRect *aSourceBBox)
+{
+  nsAutoFilterInstance instance(aTarget, this, nsnull, nsnull, nsnull, aSourceBBox);
+  if (!instance.get())
+    return nsIntRect();
+
+  // We've passed in the source's bounding box so the instance knows about
+  // it. Now we can ask the instance to compute the bounding box of
+  // the filter output.
+  nsIntRect bbox;
+  nsresult rv = instance.get()->ComputeOutputBBox(&bbox);
+  if (NS_SUCCEEDED(rv)) {
+    rv = TransformFilterSpaceToDeviceSpace(instance.get(), &bbox);
+    if (NS_SUCCEEDED(rv))
+      return bbox;
+  }
+  
+  return nsIntRect();
+}
+  
 nsIAtom *
 nsSVGFilterFrame::GetType() const
 {
   return nsGkAtoms::svgFilterFrame;
 }
diff -r b7bcdd009540 layout/svg/base/src/nsSVGFilterFrame.h
--- a/layout/svg/base/src/nsSVGFilterFrame.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/svg/base/src/nsSVGFilterFrame.h	Thu Sep 11 15:19:26 2008 +0300
@@ -35,46 +35,56 @@
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef __NS_SVGFILTERFRAME_H__
 #define __NS_SVGFILTERFRAME_H__
 
 #include "nsRect.h"
 #include "nsSVGContainerFrame.h"
 
-class nsSVGFilterInstance;
+class nsSVGRenderState;
+class nsSVGFilterPaintCallback;
 
 typedef nsSVGContainerFrame nsSVGFilterFrameBase;
 class nsSVGFilterFrame : public nsSVGFilterFrameBase
 {
   friend nsIFrame*
   NS_NewSVGFilterFrame(nsIPresShell* aPresShell, nsIContent* aContent, nsStyleContext* aContext);
 protected:
   nsSVGFilterFrame(nsStyleContext* aContext) : nsSVGFilterFrameBase(aContext) {}
 
-public:    
+public:
   nsresult FilterPaint(nsSVGRenderState *aContext,
-                       nsISVGChildFrame *aTarget,
+                       nsIFrame *aTarget, nsSVGFilterPaintCallback *aPaintCallback,
                        const nsIntRect* aDirtyRect);
 
-  // Returns invalidation region for filter (can be bigger than the
-  // referencing geometry to filter region sizing) in app units
-  // relative to the origin of the outer svg.
-  // aRect is the area that would be invalidated. Normally you'd just pass
-  // aTarget->GetRect() here.
-  nsRect GetInvalidationRegion(nsIFrame *aTarget, const nsRect& aRect);
+  /**
+   * Returns the area that could change when the given rect of the source changes.
+   * The rectangles are relative to the origin of the outer svg, if aTarget is SVG,
+   * relative to aTarget itself otherwise, in device pixels.
+   */
+  nsIntRect GetInvalidationBBox(nsIFrame *aTarget, const nsIntRect& aRect);
+
+  /**
+   * Returns the area in device pixels that is needed from the source when
+   * the given area needs to be repainted.
+   * The rectangles are relative to the origin of the outer svg, if aTarget is SVG,
+   * relative to aTarget itself otherwise, in device pixels.
+   */
+  nsIntRect GetSourceForInvalidArea(nsIFrame *aTarget, const nsIntRect& aRect);
+
+  /**
+   * Returns the bounding box of the post-filter area of aTarget.
+   * The rectangles are relative to the origin of the outer svg, if aTarget is SVG,
+   * relative to aTarget itself otherwise, in device pixels.
+   * @param aSourceBBox overrides the normal bbox for the source, if non-null
+   */
+  nsIntRect GetFilterBBox(nsIFrame *aTarget, const nsIntRect *aSourceBBox);
 
   /**
    * Get the "type" of the frame
    *
    * @see nsGkAtoms::svgFilterFrame
    */
   virtual nsIAtom* GetType() const;
-
-private:
-  // implementation helpers
-  nsresult CreateInstance(nsISVGChildFrame *aTarget,
-                          const nsIntRect *aDirtyOutputRect,
-                          const nsIntRect *aDirtyInputRect,
-                          nsSVGFilterInstance **aInstance);
 };
 
 #endif
diff -r b7bcdd009540 layout/svg/base/src/nsSVGFilterInstance.cpp
--- a/layout/svg/base/src/nsSVGFilterInstance.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/svg/base/src/nsSVGFilterInstance.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -33,30 +33,34 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsSVGFilterInstance.h"
 #include "nsSVGUtils.h"
 #include "nsIDOMSVGUnitTypes.h"
 #include "nsSVGMatrix.h"
+#include "gfxPlatform.h"
+#include "nsSVGFilterPaintCallback.h"
+#include "nsSVGFilterElement.h"
 
 static double Square(double aX)
 {
   return aX*aX;
 }
 
 float
 nsSVGFilterInstance::GetPrimitiveLength(nsSVGLength2 *aLength) const
 {
   float value;
-  if (mPrimitiveUnits == nsIDOMSVGUnitTypes::SVG_UNIT_TYPE_OBJECTBOUNDINGBOX)
+  if (mPrimitiveUnits == nsIDOMSVGUnitTypes::SVG_UNIT_TYPE_OBJECTBOUNDINGBOX) {
     value = nsSVGUtils::ObjectSpace(mTargetBBox, aLength);
-  else
-    value = nsSVGUtils::UserSpace(TargetElement(), aLength);
+  } else {
+    value = nsSVGUtils::UserSpace(mTargetFrame, aLength);
+  }
 
   switch (aLength->GetCtxType()) {
   case nsSVGUtils::X:
     return value * mFilterSpaceSize.width / mFilterRect.Width();
   case nsSVGUtils::Y:
     return value * mFilterSpaceSize.height / mFilterRect.Height();
   case nsSVGUtils::XY:
   default:
@@ -118,39 +122,19 @@ nsSVGFilterInstance::ComputeFilterPrimit
           defaultFilterSubregion.Union(
               aPrimitive->mInputs[i]->mImage.mFilterPrimitiveSubregion);
     }
   } else {
     defaultFilterSubregion =
       gfxRect(0, 0, mFilterSpaceSize.width, mFilterSpaceSize.height);
   }
 
-  nsSVGLength2 *tmpX, *tmpY, *tmpWidth, *tmpHeight;
-  tmpX = &fE->mLengthAttributes[nsSVGFE::X];
-  tmpY = &fE->mLengthAttributes[nsSVGFE::Y];
-  tmpWidth = &fE->mLengthAttributes[nsSVGFE::WIDTH];
-  tmpHeight = &fE->mLengthAttributes[nsSVGFE::HEIGHT];
-
-  float x, y, width, height;
-  if (mPrimitiveUnits == nsIDOMSVGUnitTypes::SVG_UNIT_TYPE_OBJECTBOUNDINGBOX) {
-    mTargetBBox->GetX(&x);
-    x     += nsSVGUtils::ObjectSpace(mTargetBBox, tmpX);
-    mTargetBBox->GetY(&y);
-    y     += nsSVGUtils::ObjectSpace(mTargetBBox, tmpY);
-    width  = nsSVGUtils::ObjectSpace(mTargetBBox, tmpWidth);
-    height = nsSVGUtils::ObjectSpace(mTargetBBox, tmpHeight);
-  } else {
-    nsSVGElement* targetElement = TargetElement();
-    x      = nsSVGUtils::UserSpace(targetElement, tmpX);
-    y      = nsSVGUtils::UserSpace(targetElement, tmpY);
-    width  = nsSVGUtils::UserSpace(targetElement, tmpWidth);
-    height = nsSVGUtils::UserSpace(targetElement, tmpHeight);
-  }
-
-  gfxRect region = UserSpaceToFilterSpace(gfxRect(x, y, width, height));
+  gfxRect feArea = nsSVGUtils::GetRelativeRect(mPrimitiveUnits,
+    &fE->mLengthAttributes[nsSVGFE::X], mTargetBBox, mTargetFrame);
+  gfxRect region = UserSpaceToFilterSpace(feArea);
 
   if (!fE->HasAttr(kNameSpaceID_None, nsGkAtoms::x))
     region.pos.x = defaultFilterSubregion.X();
   if (!fE->HasAttr(kNameSpaceID_None, nsGkAtoms::y))
     region.pos.y = defaultFilterSubregion.Y();
   if (!fE->HasAttr(kNameSpaceID_None, nsGkAtoms::width))
     region.size.width = defaultFilterSubregion.Width();
   if (!fE->HasAttr(kNameSpaceID_None, nsGkAtoms::height))
@@ -335,29 +319,62 @@ nsSVGFilterInstance::ComputeUnionOfAllNe
     r.UnionRect(r, mPrimitives[i].mResultNeededBox);
   }
   return r;
 }
 
 nsresult
 nsSVGFilterInstance::BuildSourceImages()
 {
-  if (mSourceColorAlpha.mResultNeededBox.IsEmpty() &&
-      mSourceAlpha.mResultNeededBox.IsEmpty())
+  nsIntRect neededRect;
+  neededRect.UnionRect(mSourceColorAlpha.mResultNeededBox,
+                       mSourceAlpha.mResultNeededBox);
+  if (neededRect.IsEmpty())
     return NS_OK;
 
   nsRefPtr<gfxImageSurface> sourceColorAlpha = CreateImage();
   if (!sourceColorAlpha)
     return NS_ERROR_OUT_OF_MEMORY;
 
-  nsSVGRenderState tmpState(sourceColorAlpha);
-  nsresult rv = mTargetFrame->PaintSVG(&tmpState, nsnull);
-  if (NS_FAILED(rv))
-    return rv;
+  {
+    // Paint to an offscreen surface first, then copy it to an image
+    // surface. This can be faster especially when the stuff we're painting
+    // contains native themes.
+    nsRefPtr<gfxASurface> offscreen =
+      gfxPlatform::GetPlatform()->CreateOffscreenSurface(
+              gfxIntSize(mSurfaceRect.width, mSurfaceRect.height),
+              gfxASurface::ImageFormatARGB32);
+    if (!offscreen || offscreen->CairoStatus())
+      return NS_ERROR_OUT_OF_MEMORY;
+    offscreen->SetDeviceOffset(gfxPoint(-mSurfaceRect.x, -mSurfaceRect.y));
+  
+    nsSVGRenderState tmpState(offscreen);
+    nsCOMPtr<nsIDOMSVGMatrix> userSpaceToFilterSpaceTransform
+      = GetUserSpaceToFilterSpaceTransform();
+    if (!userSpaceToFilterSpaceTransform)
+      return NS_ERROR_OUT_OF_MEMORY;
 
+    gfxMatrix m =
+      nsSVGUtils::ConvertSVGMatrixToThebes(userSpaceToFilterSpaceTransform);
+    gfxRect r(neededRect.x, neededRect.y, neededRect.width, neededRect.height);
+    m.Invert();
+    r = m.TransformBounds(r);
+    r.RoundOut();
+    nsIntRect dirty;
+    nsresult rv = nsSVGUtils::GfxRectToIntRect(r, &dirty);
+    if (NS_FAILED(rv))
+      return rv;
+    mPaintCallback->Paint(&tmpState, mTargetFrame, &dirty,
+                          userSpaceToFilterSpaceTransform);
+
+    gfxContext copyContext(sourceColorAlpha);
+    copyContext.SetSource(offscreen);
+    copyContext.Paint();
+  }
+  
   if (!mSourceColorAlpha.mResultNeededBox.IsEmpty()) {
     NS_ASSERTION(mSourceColorAlpha.mImageUsers > 0, "Some user must have needed this");
     mSourceColorAlpha.mImage.mImage = sourceColorAlpha;
     // color model is PREMULTIPLIED SRGB by default.
   }
 
   if (!mSourceAlpha.mResultNeededBox.IsEmpty()) {
     NS_ASSERTION(mSourceAlpha.mImageUsers > 0, "Some user must have needed this");
@@ -523,8 +540,55 @@ nsSVGFilterInstance::ComputeOutputDirtyR
   mSourceColorAlpha.mResultChangeBox = mDirtyInputRect;
   mSourceAlpha.mResultChangeBox = mDirtyInputRect;
   ComputeResultChangeBoxes();
 
   PrimitiveInfo* result = &mPrimitives[mPrimitives.Length() - 1];
   *aDirty = result->mResultChangeBox;
   return NS_OK;
 }
+
+nsresult
+nsSVGFilterInstance::ComputeSourceNeededRect(nsIntRect* aDirty)
+{
+  nsresult rv = BuildSources();
+  if (NS_FAILED(rv))
+    return rv;
+
+  rv = BuildPrimitives();
+  if (NS_FAILED(rv))
+    return rv;
+
+  if (mPrimitives.IsEmpty()) {
+    // Nothing should be rendered, so nothing is needed.
+    return NS_OK;
+  }
+
+  ComputeResultBoundingBoxes();
+  ComputeNeededBoxes();
+  aDirty->UnionRect(mSourceColorAlpha.mResultNeededBox,
+                    mSourceAlpha.mResultNeededBox);
+  return NS_OK;
+}
+
+nsresult
+nsSVGFilterInstance::ComputeOutputBBox(nsIntRect* aDirty)
+{
+  nsresult rv = BuildSources();
+  if (NS_FAILED(rv))
+    return rv;
+
+  rv = BuildPrimitives();
+  if (NS_FAILED(rv))
+    return rv;
+
+  if (mPrimitives.IsEmpty()) {
+    // Nothing should be rendered.
+    *aDirty = nsIntRect();
+    return NS_OK;
+  }
+
+  ComputeResultBoundingBoxes();
+
+  PrimitiveInfo* result = &mPrimitives[mPrimitives.Length() - 1];
+  *aDirty = result->mResultBoundingBox;
+  return NS_OK;
+}
diff -r b7bcdd009540 layout/svg/base/src/nsSVGFilterInstance.h
--- a/layout/svg/base/src/nsSVGFilterInstance.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/svg/base/src/nsSVGFilterInstance.h	Thu Sep 11 15:19:26 2008 +0300
@@ -46,39 +46,43 @@
 #include "nsSVGFilters.h"
 #include "nsISVGChildFrame.h"
 #include "nsSVGString.h"
 
 #include "gfxImageSurface.h"
 
 class nsSVGLength2;
 class nsSVGElement;
+class nsSVGFilterElement;
+class nsSVGFilterPaintCallback;
 
 /**
  * This class performs all filter processing.
  * 
  * We build a graph of the filter image data flow, essentially
  * converting the filter graph to SSA. This lets us easily propagate
  * analysis data (such as bounding-boxes) over the filter primitive graph.
  */
 class NS_STACK_CLASS nsSVGFilterInstance
 {
 public:
   float GetPrimitiveLength(nsSVGLength2 *aLength) const;
 
-  nsSVGFilterInstance(nsISVGChildFrame *aTargetFrame,
-                      nsIContent* aFilterElement,
+  nsSVGFilterInstance(nsIFrame *aTargetFrame,
+                      nsSVGFilterPaintCallback *aPaintCallback,
+                      nsSVGFilterElement *aFilterElement,
                       nsIDOMSVGRect *aTargetBBox,
                       const gfxRect& aFilterRect,
                       const nsIntSize& aFilterSpaceSize,
                       nsIDOMSVGMatrix *aFilterSpaceToDeviceSpaceTransform,
                       const nsIntRect& aDirtyOutputRect,
                       const nsIntRect& aDirtyInputRect,
                       PRUint16 aPrimitiveUnits) :
     mTargetFrame(aTargetFrame),
+    mPaintCallback(aPaintCallback),
     mFilterElement(aFilterElement),
     mTargetBBox(aTargetBBox),
     mFilterSpaceToDeviceSpaceTransform(aFilterSpaceToDeviceSpaceTransform),
     mFilterRect(aFilterRect),
     mFilterSpaceSize(aFilterSpaceSize),
     mDirtyOutputRect(aDirtyOutputRect),
     mDirtyInputRect(aDirtyInputRect),
     mSurfaceRect(nsIntPoint(0, 0), aFilterSpaceSize),
@@ -95,16 +99,18 @@ public:
   PRUint32 GetFilterResY() const { return mFilterSpaceSize.height; }
   
   const nsIntRect& GetSurfaceRect() const { return mSurfaceRect; }
   PRInt32 GetSurfaceWidth() const { return mSurfaceRect.width; }
   PRInt32 GetSurfaceHeight() const { return mSurfaceRect.height; }
   
   nsresult Render(gfxASurface** aOutput);
   nsresult ComputeOutputDirtyRect(nsIntRect* aDirty);
+  nsresult ComputeSourceNeededRect(nsIntRect* aDirty);
+  nsresult ComputeOutputBBox(nsIntRect* aBBox);
 
   already_AddRefed<nsIDOMSVGMatrix> GetUserSpaceToFilterSpaceTransform() const;
   nsIDOMSVGMatrix* GetFilterSpaceToDeviceSpaceTransform() const {
     return mFilterSpaceToDeviceSpaceTransform.get();
   }
 
 private:
   typedef nsSVGFE::Image Image;
@@ -169,25 +175,20 @@ private:
 
   gfxRect UserSpaceToFilterSpace(const gfxRect& aUserSpace) const;
   void ClipToFilterSpace(nsIntRect* aRect) const
   {
     nsIntRect filterSpace(nsIntPoint(0, 0), mFilterSpaceSize);
     aRect->IntersectRect(*aRect, filterSpace);
   }
   void ClipToGfxRect(nsIntRect* aRect, const gfxRect& aGfx) const;
-  nsSVGElement* TargetElement() const
-  {
-    nsIFrame* f;
-    CallQueryInterface(mTargetFrame, &f);
-    return static_cast<nsSVGElement*>(f->GetContent());
-  }
 
-  nsISVGChildFrame*       mTargetFrame;
-  nsIContent*             mFilterElement;
+  nsIFrame*               mTargetFrame;
+  nsSVGFilterPaintCallback* mPaintCallback;
+  nsSVGFilterElement*     mFilterElement;
   nsCOMPtr<nsIDOMSVGRect> mTargetBBox;
   nsCOMPtr<nsIDOMSVGMatrix> mFilterSpaceToDeviceSpaceTransform;
   gfxRect                 mFilterRect;
   nsIntSize               mFilterSpaceSize;
   nsIntRect               mDirtyOutputRect;
   nsIntRect               mDirtyInputRect;
   nsIntRect               mSurfaceRect;
   PRUint16                mPrimitiveUnits;
diff -r b7bcdd009540 layout/svg/base/src/nsSVGFilterPaintCallback.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/svg/base/src/nsSVGFilterPaintCallback.h	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,64 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SVGFILTERPAINTCALLBACK_H__
+#define __NS_SVGFILTERPAINTCALLBACK_H__
+
+#include "nsRect.h"
+
+class nsIFrame;
+class nsIDOMSVGMatrix;
+class nsSVGRenderState;
+
+class nsSVGFilterPaintCallback {
+public:
+  /**
+   * Paint the frame contents. aTransform should be applied to aContext
+   * (either via SetOverrideCTM or by applying the transform to aContext
+   * directly).
+   * SVG frames will have had matrix propagation set to false already.
+   * frames have to do their own thing.
+   * The caller will do a Save()/Restore() as necessary so feel free
+   * to mess with context state.
+   * @param aDirtyRect the dirty rect *in user space pixels*
+   * @param aTransform the user-space-to-filter-space transform to apply.
+   * May be null if the identity matrix is requested.
+   */
+  virtual void Paint(nsSVGRenderState *aContext, nsIFrame *aTarget,
+                     const nsIntRect *aDirtyRect, nsIDOMSVGMatrix *aTransform) = 0;
+};
+
+#endif
diff -r b7bcdd009540 layout/svg/base/src/nsSVGForeignObjectFrame.cpp
--- a/layout/svg/base/src/nsSVGForeignObjectFrame.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/svg/base/src/nsSVGForeignObjectFrame.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -92,16 +92,17 @@ NS_INTERFACE_MAP_END_INHERITING(nsSVGFor
 // nsIFrame methods
 
 NS_IMETHODIMP
 nsSVGForeignObjectFrame::Init(nsIContent* aContent,
                               nsIFrame*   aParent,
                               nsIFrame*   aPrevInFlow)
 {
   nsresult rv = nsSVGForeignObjectFrameBase::Init(aContent, aParent, aPrevInFlow);
+  AddStateBits(NS_STATE_SVG_PROPAGATE_TRANSFORM);
   if (NS_SUCCEEDED(rv)) {
     nsSVGUtils::GetOuterSVGFrame(this)->RegisterForeignObject(this);
   }
   return rv;
 }
 
 void nsSVGForeignObjectFrame::Destroy()
 {
@@ -445,18 +446,28 @@ nsSVGForeignObjectFrame::NotifyRedrawUns
     }
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsSVGForeignObjectFrame::SetMatrixPropagation(PRBool aPropagate)
 {
-  mPropagateTransform = aPropagate;
+  if (aPropagate) {
+    AddStateBits(NS_STATE_SVG_PROPAGATE_TRANSFORM);
+  } else {
+    RemoveStateBits(NS_STATE_SVG_PROPAGATE_TRANSFORM);
+  }
   return NS_OK;
+}
+
+PRBool
+nsSVGForeignObjectFrame::GetMatrixPropagation()
+{
+  return (GetStateBits() & NS_STATE_SVG_PROPAGATE_TRANSFORM) != 0;
 }
 
 NS_IMETHODIMP
 nsSVGForeignObjectFrame::SetOverrideCTM(nsIDOMSVGMatrix *aCTM)
 {
   mOverrideCTM = aCTM;
   return NS_OK;
 }
@@ -509,17 +520,17 @@ nsSVGForeignObjectFrame::GetTMIncludingO
   nsIDOMSVGMatrix* matrix;
   ctm->Translate(x, y, &matrix);
   return matrix;
 }
 
 already_AddRefed<nsIDOMSVGMatrix>
 nsSVGForeignObjectFrame::GetCanvasTM()
 {
-  if (!mPropagateTransform) {
+  if (!GetMatrixPropagation()) {
     nsIDOMSVGMatrix *retval;
     if (mOverrideCTM) {
       retval = mOverrideCTM;
       NS_ADDREF(retval);
     } else {
       NS_NewSVGMatrix(&retval);
     }
     return retval;
diff -r b7bcdd009540 layout/svg/base/src/nsSVGForeignObjectFrame.h
--- a/layout/svg/base/src/nsSVGForeignObjectFrame.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/svg/base/src/nsSVGForeignObjectFrame.h	Thu Sep 11 15:19:26 2008 +0300
@@ -109,16 +109,17 @@ public:
   NS_IMETHOD_(nsIFrame*) GetFrameForPoint(const nsPoint &aPoint);
   NS_IMETHOD_(nsRect) GetCoveredRegion();
   NS_IMETHOD UpdateCoveredRegion();
   NS_IMETHOD InitialUpdate();
   virtual void NotifySVGChanged(PRUint32 aFlags);
   NS_IMETHOD NotifyRedrawSuspended();
   NS_IMETHOD NotifyRedrawUnsuspended();
   NS_IMETHOD SetMatrixPropagation(PRBool aPropagate);
+  virtual PRBool GetMatrixPropagation();
   NS_IMETHOD SetOverrideCTM(nsIDOMSVGMatrix *aCTM);
   virtual already_AddRefed<nsIDOMSVGMatrix> GetOverrideCTM();
   NS_IMETHOD GetBBox(nsIDOMSVGRect **_retval);
   NS_IMETHOD_(PRBool) IsDisplayContainer() { return PR_TRUE; }
   NS_IMETHOD_(PRBool) HasValidCoveredRect() { return PR_FALSE; }
 
   // foreignobject public methods
   /**
diff -r b7bcdd009540 layout/svg/base/src/nsSVGGFrame.cpp
--- a/layout/svg/base/src/nsSVGGFrame.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/svg/base/src/nsSVGGFrame.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -76,23 +76,16 @@ nsSVGGFrame::NotifySVGChanged(PRUint32 a
     // make sure our cached transform matrix gets (lazily) updated
     mCanvasTM = nsnull;
   }
 
   nsSVGGFrameBase::NotifySVGChanged(aFlags);
 }
 
 NS_IMETHODIMP
-nsSVGGFrame::SetMatrixPropagation(PRBool aPropagate)
-{
-  mPropagateTransform = aPropagate;
-  return NS_OK;
-}
-
-NS_IMETHODIMP
 nsSVGGFrame::SetOverrideCTM(nsIDOMSVGMatrix *aCTM)
 {
   mOverrideCTM = aCTM;
   return NS_OK;
 }
 
 already_AddRefed<nsIDOMSVGMatrix>
 nsSVGGFrame::GetOverrideCTM()
@@ -100,17 +93,17 @@ nsSVGGFrame::GetOverrideCTM()
   nsIDOMSVGMatrix *matrix = mOverrideCTM.get();
   NS_IF_ADDREF(matrix);
   return matrix;
 }
 
 already_AddRefed<nsIDOMSVGMatrix>
 nsSVGGFrame::GetCanvasTM()
 {
-  if (!mPropagateTransform) {
+  if (!GetMatrixPropagation()) {
     nsIDOMSVGMatrix *retval;
     if (mOverrideCTM) {
       retval = mOverrideCTM;
       NS_ADDREF(retval);
     } else {
       NS_NewSVGMatrix(&retval);
     }
     return retval;
diff -r b7bcdd009540 layout/svg/base/src/nsSVGGFrame.h
--- a/layout/svg/base/src/nsSVGGFrame.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/svg/base/src/nsSVGGFrame.h	Thu Sep 11 15:19:26 2008 +0300
@@ -68,17 +68,16 @@ public:
 
   // nsIFrame interface:
   NS_IMETHOD AttributeChanged(PRInt32         aNameSpaceID,
                               nsIAtom*        aAttribute,
                               PRInt32         aModType);
 
   // nsISVGChildFrame interface:
   virtual void NotifySVGChanged(PRUint32 aFlags);
-  NS_IMETHOD SetMatrixPropagation(PRBool aPropagate);
   NS_IMETHOD SetOverrideCTM(nsIDOMSVGMatrix *aCTM);
   virtual already_AddRefed<nsIDOMSVGMatrix> GetOverrideCTM();
 
   // nsSVGContainerFrame methods:
   virtual already_AddRefed<nsIDOMSVGMatrix> GetCanvasTM();
 
   nsCOMPtr<nsIDOMSVGMatrix> mCanvasTM;
   nsCOMPtr<nsIDOMSVGMatrix> mOverrideCTM;
diff -r b7bcdd009540 layout/svg/base/src/nsSVGGeometryFrame.cpp
--- a/layout/svg/base/src/nsSVGGeometryFrame.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/svg/base/src/nsSVGGeometryFrame.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -60,17 +60,18 @@ nsSVGGeometryFrame::Destroy()
   nsSVGGeometryFrameBase::Destroy();
 }
 
 NS_IMETHODIMP
 nsSVGGeometryFrame::Init(nsIContent* aContent,
                          nsIFrame* aParent,
                          nsIFrame* aPrevInFlow)
 {
-  AddStateBits(aParent->GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD);
+  AddStateBits((aParent->GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD) |
+               NS_STATE_SVG_PROPAGATE_TRANSFORM);
   nsresult rv = nsSVGGeometryFrameBase::Init(aContent, aParent, aPrevInFlow);
   return rv;
 }
 
 NS_IMETHODIMP
 nsSVGGeometryFrame::DidSetStyleContext()
 {
   // One of the styles that might have been changed are the urls that
diff -r b7bcdd009540 layout/svg/base/src/nsSVGGlyphFrame.cpp
--- a/layout/svg/base/src/nsSVGGlyphFrame.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/svg/base/src/nsSVGGlyphFrame.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -1279,16 +1279,33 @@ nsSVGGlyphFrame::EnsureTextRun(float *aD
       return PR_FALSE;
   }
 
   *aDrawScale = float(size/textRunSize);
   *aMetricsScale = (*aDrawScale)/GetTextRunUnitsFactor();
   return PR_TRUE;
 }
 
+NS_IMETHODIMP
+nsSVGGlyphFrame::SetMatrixPropagation(PRBool aPropagate)
+{
+  if (aPropagate) {
+    AddStateBits(NS_STATE_SVG_PROPAGATE_TRANSFORM);
+  } else {
+    RemoveStateBits(NS_STATE_SVG_PROPAGATE_TRANSFORM);
+  }
+  return NS_OK;
+}
+
+PRBool
+nsSVGGlyphFrame::GetMatrixPropagation()
+{
+  return (GetStateBits() & NS_STATE_SVG_PROPAGATE_TRANSFORM) != 0;
+}
+
 //----------------------------------------------------------------------
 // helper class
 
 CharacterIterator::CharacterIterator(nsSVGGlyphFrame *aSource,
         PRBool aForceGlobalTransform)
   : mSource(aSource), mCurrentAdvance(0), mCurrentChar(-1),
     mInError(PR_FALSE)
 {
diff -r b7bcdd009540 layout/svg/base/src/nsSVGGlyphFrame.h
--- a/layout/svg/base/src/nsSVGGlyphFrame.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/svg/base/src/nsSVGGlyphFrame.h	Thu Sep 11 15:19:26 2008 +0300
@@ -120,17 +120,18 @@ public:
   NS_IMETHOD UpdateCoveredRegion();
   NS_IMETHOD GetBBox(nsIDOMSVGRect **_retval);
 
   NS_IMETHOD_(nsRect) GetCoveredRegion();
   NS_IMETHOD InitialUpdate();
   virtual void NotifySVGChanged(PRUint32 aFlags);
   NS_IMETHOD NotifyRedrawSuspended();
   NS_IMETHOD NotifyRedrawUnsuspended();
-  NS_IMETHOD SetMatrixPropagation(PRBool aPropagate) { return NS_OK; }
+  NS_IMETHOD SetMatrixPropagation(PRBool aPropagate);
+  virtual PRBool GetMatrixPropagation();
   NS_IMETHOD SetOverrideCTM(nsIDOMSVGMatrix *aCTM) { return NS_ERROR_FAILURE; }
   virtual already_AddRefed<nsIDOMSVGMatrix> GetOverrideCTM() { return nsnull; }
   NS_IMETHOD_(PRBool) IsDisplayContainer() { return PR_FALSE; }
   NS_IMETHOD_(PRBool) HasValidCoveredRect() { return PR_TRUE; }
 
   // nsSVGGeometryFrame methods
   NS_IMETHOD GetCanvasTM(nsIDOMSVGMatrix * *aCTM);
 
diff -r b7bcdd009540 layout/svg/base/src/nsSVGInnerSVGFrame.cpp
--- a/layout/svg/base/src/nsSVGInnerSVGFrame.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/svg/base/src/nsSVGInnerSVGFrame.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -80,17 +80,16 @@ public:
   {
     return MakeFrameName(NS_LITERAL_STRING("SVGInnerSVG"), aResult);
   }
 #endif
 
   // nsISVGChildFrame interface:
   NS_IMETHOD PaintSVG(nsSVGRenderState *aContext, nsIntRect *aDirtyRect);
   virtual void NotifySVGChanged(PRUint32 aFlags);
-  NS_IMETHOD SetMatrixPropagation(PRBool aPropagate);
   NS_IMETHOD SetOverrideCTM(nsIDOMSVGMatrix *aCTM);
   virtual already_AddRefed<nsIDOMSVGMatrix> GetOverrideCTM();
   NS_IMETHOD_(nsIFrame*) GetFrameForPoint(const nsPoint &aPoint);
 
   // nsSVGContainerFrame methods:
   virtual already_AddRefed<nsIDOMSVGMatrix> GetCanvasTM();
 
   // nsISVGValueObserver
@@ -221,23 +220,16 @@ nsSVGInnerSVGFrame::NotifySVGChanged(PRU
   }
 
   if (aFlags & TRANSFORM_CHANGED) {
     // make sure our cached transform matrix gets (lazily) updated
     mCanvasTM = nsnull;
   }
 
   nsSVGInnerSVGFrameBase::NotifySVGChanged(aFlags);
-}
-
-NS_IMETHODIMP
-nsSVGInnerSVGFrame::SetMatrixPropagation(PRBool aPropagate)
-{
-  mPropagateTransform = aPropagate;
-  return NS_OK;
 }
 
 NS_IMETHODIMP
 nsSVGInnerSVGFrame::SetOverrideCTM(nsIDOMSVGMatrix *aCTM)
 {
   mOverrideCTM = aCTM;
   return NS_OK;
 }
diff -r b7bcdd009540 layout/svg/base/src/nsSVGIntegrationUtils.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/svg/base/src/nsSVGIntegrationUtils.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,414 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is IBM Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   rocallahan@mozilla.com
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSVGIntegrationUtils.h"
+
+#include "nsSVGUtils.h"
+#include "nsSVGEffects.h"
+#include "nsRegion.h"
+#include "nsLayoutUtils.h"
+#include "nsDisplayList.h"
+#include "nsSVGMatrix.h"
+#include "nsSVGFilterPaintCallback.h"
+
+// ----------------------------------------------------------------------
+
+PRBool
+nsSVGIntegrationUtils::UsingEffectsForFrame(const nsIFrame* aFrame)
+{
+  const nsStyleSVGReset *style = aFrame->GetStyleSVGReset();
+  return style->mFilter || style->mClipPath || style->mMask;
+}
+
+// Get the union the frame border-box rects over all continuations,
+// relative to aFirst. This defines "user space" for non-SVG frames.
+static nsRect GetNonSVGUserSpace(nsIFrame* aFirst)
+{
+  NS_ASSERTION(!aFirst->GetPrevContinuation(), "Not first continuation");
+  return nsLayoutUtils::GetAllInFlowRectsUnion(aFirst, aFirst);
+}
+
+static nsRect
+GetPreEffectsOverflowRect(nsIFrame* aFrame)
+{
+  nsRect* r = static_cast<nsRect*>(aFrame->GetProperty(nsGkAtoms::preEffectsBBoxProperty));
+  if (r)
+    return *r;
+  return aFrame->GetOverflowRect();
+}
+
+struct BBoxCollector : public nsLayoutUtils::BoxCallback {
+  nsIFrame*     mReferenceFrame;
+  nsIFrame*     mCurrentFrame;
+  const nsRect& mCurrentFrameOverflowArea;
+  nsRect        mResult;
+
+  BBoxCollector(nsIFrame* aReferenceFrame, nsIFrame* aCurrentFrame,
+                const nsRect& aCurrentFrameOverflowArea)
+    : mReferenceFrame(aReferenceFrame), mCurrentFrame(aCurrentFrame),
+      mCurrentFrameOverflowArea(aCurrentFrameOverflowArea) {}
+
+  virtual void AddBox(nsIFrame* aFrame) {
+    nsRect overflow = aFrame == mCurrentFrame ? mCurrentFrameOverflowArea
+        : GetPreEffectsOverflowRect(aFrame);
+    mResult.UnionRect(mResult, overflow + aFrame->GetOffsetTo(mReferenceFrame));
+  }
+};
+
+static nsRect
+GetSVGBBox(nsIFrame* aNonSVGFrame, nsIFrame* aCurrentFrame,
+           const nsRect& aCurrentOverflow, const nsRect& aUserSpaceRect)
+{
+  NS_ASSERTION(!aNonSVGFrame->GetPrevContinuation(),
+               "Need first continuation here");
+  // Compute union of all overflow areas relative to 'first'.
+  BBoxCollector collector(aNonSVGFrame, aCurrentFrame, aCurrentOverflow);
+  nsLayoutUtils::GetAllInFlowBoxes(aNonSVGFrame, &collector);
+  // Get it into "user space" for non-SVG frames
+  return collector.mResult - aUserSpaceRect.TopLeft();
+}
+
+nsRect
+nsSVGIntegrationUtils::ComputeFrameEffectsRect(nsIFrame* aFrame,
+                                               const nsRect& aOverflowRect)
+{
+  PRBool isOK;
+  nsIFrame* firstFrame =
+    nsLayoutUtils::GetFirstContinuationOrSpecialSibling(aFrame);
+  nsSVGEffects::EffectProperties effectProperties =
+    nsSVGEffects::GetEffectProperties(firstFrame);
+  nsSVGFilterFrame *filterFrame = effectProperties.mFilter ?
+    effectProperties.mFilter->GetFilterFrame(&isOK) : nsnull;
+  if (!filterFrame)
+    return aOverflowRect;
+
+  // XXX this isn't really right. We can't compute the correct filter
+  // bbox until all aFrame's continuations have been reflowed.
+  // but then it's too late to set the overflow areas for the earlier frames.
+  nsRect userSpaceRect = GetNonSVGUserSpace(firstFrame);
+  nsRect r = GetSVGBBox(firstFrame, aFrame, aOverflowRect, userSpaceRect);
+  // r is relative to user space
+  PRUint32 appUnitsPerDevPixel = aFrame->PresContext()->AppUnitsPerDevPixel();
+  r.ScaleRoundOutInverse(appUnitsPerDevPixel);
+  r = filterFrame->GetFilterBBox(firstFrame, &r);
+  r.ScaleRoundOut(appUnitsPerDevPixel);
+  // Make it relative to aFrame again
+  return r + userSpaceRect.TopLeft() - aFrame->GetOffsetTo(firstFrame);
+}
+
+nsRect
+nsSVGIntegrationUtils::GetInvalidAreaForChangedSource(nsIFrame* aFrame,
+                                                      const nsRect& aInvalidRect)
+{
+  // Don't bother calling GetEffectProperties; the filter property should
+  // already have been set up during reflow/ComputeFrameEffectsRect
+  nsIFrame* firstFrame =
+    nsLayoutUtils::GetFirstContinuationOrSpecialSibling(aFrame);
+  nsSVGFilterFrame* filterFrame = nsSVGEffects::GetFilterFrame(firstFrame);
+  if (!filterFrame)
+    return aInvalidRect;
+
+  PRInt32 appUnitsPerDevPixel = aFrame->PresContext()->AppUnitsPerDevPixel();
+  nsRect userSpaceRect = GetNonSVGUserSpace(firstFrame);
+  nsPoint offset = aFrame->GetOffsetTo(firstFrame) - userSpaceRect.TopLeft();
+  nsRect r = aInvalidRect + offset;
+  r.ScaleRoundOutInverse(appUnitsPerDevPixel);
+  r = filterFrame->GetInvalidationBBox(firstFrame, r);
+  r.ScaleRoundOut(appUnitsPerDevPixel);
+  return r - offset;
+}
+
+nsRect
+nsSVGIntegrationUtils::GetRequiredSourceForInvalidArea(nsIFrame* aFrame,
+                                                       const nsRect& aDamageRect)
+{
+  // Don't bother calling GetEffectProperties; the filter property should
+  // already have been set up during reflow/ComputeFrameEffectsRect
+  nsIFrame* firstFrame =
+    nsLayoutUtils::GetFirstContinuationOrSpecialSibling(aFrame);
+  nsSVGFilterFrame* filterFrame =
+    nsSVGEffects::GetFilterFrame(firstFrame);
+  if (!filterFrame)
+    return aDamageRect;
+  
+  PRInt32 appUnitsPerDevPixel = aFrame->PresContext()->AppUnitsPerDevPixel();
+  nsRect userSpaceRect = GetNonSVGUserSpace(firstFrame);
+  nsPoint offset = aFrame->GetOffsetTo(firstFrame) - userSpaceRect.TopLeft();
+  nsRect r = aDamageRect + offset;
+  r.ScaleRoundOutInverse(appUnitsPerDevPixel);
+  r = filterFrame->GetSourceForInvalidArea(firstFrame, r);
+  r.ScaleRoundOut(appUnitsPerDevPixel);
+  return r - offset;
+}
+
+PRBool
+nsSVGIntegrationUtils::HitTestFrameForEffects(nsIFrame* aFrame, const nsPoint& aPt)
+{
+  nsIFrame* firstFrame =
+    nsLayoutUtils::GetFirstContinuationOrSpecialSibling(aFrame);
+  nsRect userSpaceRect = GetNonSVGUserSpace(firstFrame);
+  // get point relative to userSpaceRect
+  nsPoint pt = aPt + aFrame->GetOffsetTo(firstFrame) - userSpaceRect.TopLeft();
+  return nsSVGUtils::HitTestClip(firstFrame, pt);
+}
+
+class RegularFramePaintCallback : public nsSVGFilterPaintCallback
+{
+public:
+  RegularFramePaintCallback(nsDisplayListBuilder* aBuilder,
+                            nsDisplayList* aInnerList,
+                            const nsPoint& aOffset)
+    : mBuilder(aBuilder), mInnerList(aInnerList), mOffset(aOffset) {}
+
+  virtual void Paint(nsSVGRenderState *aContext, nsIFrame *aTarget,
+                     const nsIntRect* aDirtyRect, nsIDOMSVGMatrix *aTransform)
+  {
+    nsIRenderingContext* ctx = aContext->GetRenderingContext(aTarget);
+    gfxContext* gfxCtx = aContext->GetGfxContext();
+
+    if (aTransform) {
+      // Transform by aTransform first
+      gfxMatrix m = nsSVGUtils::ConvertSVGMatrixToThebes(aTransform);
+      gfxCtx->Multiply(m);
+    }
+
+    // We're expected to paint with 1 unit equal to 1 CSS pixel. But
+    // mInnerList->Paint expects 1 unit to equal 1 device pixel. So
+    // adjust.
+    gfxFloat scale =
+      nsPresContext::AppUnitsToFloatCSSPixels(aTarget->PresContext()->AppUnitsPerDevPixel());
+    gfxCtx->Scale(scale, scale);
+
+    nsIRenderingContext::AutoPushTranslation push(ctx, -mOffset.x, -mOffset.y);
+    nsRect dirty;
+    if (aDirtyRect) {
+      dirty = *aDirtyRect;
+      dirty.ScaleRoundOut(nsIDeviceContext::AppUnitsPerCSSPixel());
+      dirty += mOffset;
+    } else {
+      dirty = mInnerList->GetBounds(mBuilder);
+    }
+    mInnerList->Paint(mBuilder, ctx, dirty);
+  }
+
+private:
+  nsDisplayListBuilder* mBuilder;
+  nsDisplayList* mInnerList;
+  nsPoint mOffset;
+};
+
+void
+nsSVGIntegrationUtils::PaintFramesWithEffects(nsIRenderingContext* aCtx,
+                                              nsIFrame* aEffectsFrame,
+                                              const nsRect& aDirtyRect,
+                                              nsDisplayListBuilder* aBuilder,
+                                              nsDisplayList* aInnerList)
+{
+#ifdef DEBUG
+  nsISVGChildFrame *svgChildFrame;
+  CallQueryInterface(aEffectsFrame, &svgChildFrame);
+#endif
+  NS_ASSERTION(!svgChildFrame, "Should never be called on an SVG frame");
+
+  float opacity = aEffectsFrame->GetStyleDisplay()->mOpacity;
+  if (opacity == 0.0f)
+    return;
+
+  /* Properties are added lazily and may have been removed by a restyle,
+     so make sure all applicable ones are set again. */
+  nsIFrame* firstFrame =
+    nsLayoutUtils::GetFirstContinuationOrSpecialSibling(aEffectsFrame);
+  nsSVGEffects::EffectProperties effectProperties =
+    nsSVGEffects::GetEffectProperties(firstFrame);
+
+  /* SVG defines the following rendering model:
+   *
+   *  1. Render geometry
+   *  2. Apply filter
+   *  3. Apply clipping, masking, group opacity
+   *
+   * We follow this, but perform a couple of optimizations:
+   *
+   * + Use cairo's clipPath when representable natively (single object
+   *   clip region).
+   *
+   * + Merge opacity and masking if both used together.
+   */
+
+  PRBool isOK = PR_TRUE;
+  nsSVGClipPathFrame *clipPathFrame = effectProperties.mClipPath ?
+    effectProperties.mClipPath->GetClipPathFrame(&isOK) : nsnull;
+  nsSVGFilterFrame *filterFrame = effectProperties.mFilter ?
+    effectProperties.mFilter->GetFilterFrame(&isOK) : nsnull;
+  nsSVGMaskFrame *maskFrame = effectProperties.mMask ?
+    effectProperties.mMask->GetMaskFrame(&isOK) : nsnull;
+
+  PRBool isTrivialClip = clipPathFrame ? clipPathFrame->IsTrivial() : PR_TRUE;
+
+  if (!isOK) {
+    // Some resource is missing. We shouldn't paint anything.
+    return;
+  }
+
+  gfxContext* gfx = aCtx->ThebesContext();
+  gfxMatrix savedCTM = gfx->CurrentMatrix();
+  nsSVGRenderState svgContext(aCtx);
+
+  nsRect userSpaceRect = GetNonSVGUserSpace(firstFrame) + aBuilder->ToReferenceFrame(firstFrame);
+  PRInt32 appUnitsPerDevPixel = aEffectsFrame->PresContext()->AppUnitsPerDevPixel();
+  userSpaceRect.ScaleRoundPreservingCentersInverse(appUnitsPerDevPixel);
+  userSpaceRect.ScaleRoundOut(appUnitsPerDevPixel);
+  aCtx->Translate(userSpaceRect.x, userSpaceRect.y);
+
+  nsCOMPtr<nsIDOMSVGMatrix> matrix = GetInitialMatrix(aEffectsFrame);
+
+  PRBool complexEffects = PR_FALSE;
+  /* Check if we need to do additional operations on this child's
+   * rendering, which necessitates rendering into another surface. */
+  if (opacity != 1.0f || maskFrame || (clipPathFrame && !isTrivialClip)) {
+    complexEffects = PR_TRUE;
+    gfx->Save();
+    gfx->PushGroup(gfxASurface::CONTENT_COLOR_ALPHA);
+  }
+
+  /* If this frame has only a trivial clipPath, set up cairo's clipping now so
+   * we can just do normal painting and get it clipped appropriately.
+   */
+  if (clipPathFrame && isTrivialClip) {
+    gfx->Save();
+    clipPathFrame->ClipPaint(&svgContext, aEffectsFrame, matrix);
+  }
+
+  /* Paint the child */
+  if (filterFrame) {
+    RegularFramePaintCallback paint(aBuilder, aInnerList, userSpaceRect.TopLeft());
+    nsRect r = aDirtyRect - userSpaceRect.TopLeft();
+    r.ScaleRoundOutInverse(appUnitsPerDevPixel);
+    filterFrame->FilterPaint(&svgContext, aEffectsFrame, &paint, &r);
+  } else {
+    gfx->SetMatrix(savedCTM);
+    aInnerList->Paint(aBuilder, aCtx, aDirtyRect);
+    aCtx->Translate(userSpaceRect.x, userSpaceRect.y);
+  }
+
+  if (clipPathFrame && isTrivialClip) {
+    gfx->Restore();
+  }
+
+  /* No more effects, we're done. */
+  if (!complexEffects) {
+    gfx->SetMatrix(savedCTM);
+    return;
+  }
+
+  gfx->PopGroupToSource();
+
+  nsRefPtr<gfxPattern> maskSurface =
+    maskFrame ? maskFrame->ComputeMaskAlpha(&svgContext, aEffectsFrame,
+                                            matrix, opacity) : nsnull;
+
+  nsRefPtr<gfxPattern> clipMaskSurface;
+  if (clipPathFrame && !isTrivialClip) {
+    gfx->PushGroup(gfxASurface::CONTENT_COLOR_ALPHA);
+
+    nsresult rv = clipPathFrame->ClipPaint(&svgContext, aEffectsFrame, matrix);
+    clipMaskSurface = gfx->PopGroup();
+
+    if (NS_SUCCEEDED(rv) && clipMaskSurface) {
+      // Still more set after clipping, so clip to another surface
+      if (maskSurface || opacity != 1.0f) {
+        gfx->PushGroup(gfxASurface::CONTENT_COLOR_ALPHA);
+        gfx->Mask(clipMaskSurface);
+        gfx->PopGroupToSource();
+      } else {
+        gfx->Mask(clipMaskSurface);
+      }
+    }
+  }
+
+  if (maskSurface) {
+    gfx->Mask(maskSurface);
+  } else if (opacity != 1.0f) {
+    gfx->Paint(opacity);
+  }
+
+  gfx->Restore();
+  gfx->SetMatrix(savedCTM);
+}
+
+already_AddRefed<nsIDOMSVGMatrix>
+nsSVGIntegrationUtils::GetInitialMatrix(nsIFrame* aNonSVGFrame)
+{
+  NS_ASSERTION(!aNonSVGFrame->IsFrameOfType(nsIFrame::eSVG),
+               "SVG frames should not get here");
+  PRInt32 appUnitsPerDevPixel = aNonSVGFrame->PresContext()->AppUnitsPerDevPixel();
+  nsCOMPtr<nsIDOMSVGMatrix> matrix;
+  float devPxPerCSSPx =
+    1 / nsPresContext::AppUnitsToFloatCSSPixels(appUnitsPerDevPixel);
+  NS_NewSVGMatrix(getter_AddRefs(matrix),
+                  devPxPerCSSPx, 0.0f,
+                  0.0f, devPxPerCSSPx);
+  return matrix.forget();
+}
+
+gfxRect
+nsSVGIntegrationUtils::GetSVGRectForNonSVGFrame(nsIFrame* aNonSVGFrame)
+{
+  NS_ASSERTION(!aNonSVGFrame->IsFrameOfType(nsIFrame::eSVG),
+               "SVG frames should not get here");
+  nsIFrame* firstFrame =
+    nsLayoutUtils::GetFirstContinuationOrSpecialSibling(aNonSVGFrame);
+  nsRect r = GetNonSVGUserSpace(firstFrame);
+  nsPresContext* presContext = firstFrame->PresContext();
+  return gfxRect(0, 0, presContext->AppUnitsToFloatCSSPixels(r.width),
+                       presContext->AppUnitsToFloatCSSPixels(r.height));
+}
+
+gfxRect
+nsSVGIntegrationUtils::GetSVGBBoxForNonSVGFrame(nsIFrame* aNonSVGFrame)
+{
+  NS_ASSERTION(!aNonSVGFrame->IsFrameOfType(nsIFrame::eSVG),
+               "SVG frames should not get here");
+  nsIFrame* firstFrame =
+    nsLayoutUtils::GetFirstContinuationOrSpecialSibling(aNonSVGFrame);
+  nsRect userSpaceRect = GetNonSVGUserSpace(firstFrame);
+  nsRect r = GetSVGBBox(firstFrame, nsnull, nsRect(), userSpaceRect);
+  gfxRect result(r.x, r.y, r.width, r.height);
+  nsPresContext* presContext = aNonSVGFrame->PresContext();
+  result.ScaleInverse(presContext->AppUnitsPerCSSPixel());
+  return result;
+}
diff -r b7bcdd009540 layout/svg/base/src/nsSVGIntegrationUtils.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/svg/base/src/nsSVGIntegrationUtils.h	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,116 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is IBM Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   rocallahan@mozilla.com
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef NSSVGINTEGRATIONUTILS_H_
+#define NSSVGINTEGRATIONUTILS_H_
+
+#include "nsPoint.h"
+#include "nsRect.h"
+#include "gfxRect.h"
+
+class nsIFrame;
+class nsDisplayListBuilder;
+class nsDisplayList;
+class nsIRenderingContext;
+class nsIDOMSVGMatrix;
+
+/***** Integration of SVG effects with regular frame painting *****/
+
+class nsSVGIntegrationUtils
+{
+public:
+  static PRBool
+  UsingEffectsForFrame(const nsIFrame* aFrame);
+
+  /**
+   * Adjust overflow rect for effects.
+   * XXX this is a problem. We really need to compute the effects rect for
+   * a whole chain of frames for a given element at once. but we have no
+   * way to do this effectively with Gecko's current reflow architecture.
+   * See http://groups.google.com/group/mozilla.dev.tech.layout/msg/6b179066f3051f65
+   */
+  static nsRect
+  ComputeFrameEffectsRect(nsIFrame* aFrame, const nsRect& aOverflowRect);
+  /**
+   * Adjust the frame's invalidation area to cover effects
+   */
+  static nsRect
+  GetInvalidAreaForChangedSource(nsIFrame* aFrame, const nsRect& aInvalidRect);
+  /**
+   * Figure out which area of the source is needed given an area to
+   * repaint
+   */
+  static nsRect
+  GetRequiredSourceForInvalidArea(nsIFrame* aFrame, const nsRect& aDamageRect);
+  /**
+   * Returns true if the given point is not clipped out by effects.
+   * @param aPt in appunits relative to aFrame
+   */
+  static PRBool
+  HitTestFrameForEffects(nsIFrame* aFrame, const nsPoint& aPt);
+
+  /**
+   * Paint non-SVG frame with SVG effects.
+   * @param aOffset the offset in appunits where aFrame should be positioned
+   * in aCtx's coordinate system
+   */
+  static void
+  PaintFramesWithEffects(nsIRenderingContext* aCtx,
+                         nsIFrame* aEffectsFrame, const nsRect& aDirtyRect,
+                         nsDisplayListBuilder* aBuilder,
+                         nsDisplayList* aInnerList);
+
+  static already_AddRefed<nsIDOMSVGMatrix>
+  GetInitialMatrix(nsIFrame* aNonSVGFrame);
+  /**
+   * Returns aNonSVGFrame's rect in CSS pixel units. This is the union
+   * of all its continuations' rectangles. The top-left is always 0,0
+   * since "user space" origin for non-SVG frames is the top-left of the
+   * union of all the continuations' rectangles.
+   */
+  static gfxRect
+  GetSVGRectForNonSVGFrame(nsIFrame* aNonSVGFrame);
+  /**
+   * Returns aNonSVGFrame's bounding box in CSS units. This is the union
+   * of all its continuations' overflow areas, relative to the top-left
+   * of all the continuations' rectangles.
+   */
+  static gfxRect
+  GetSVGBBoxForNonSVGFrame(nsIFrame* aNonSVGFrame);
+};
+
+#endif /*NSSVGINTEGRATIONUTILS_H_*/
diff -r b7bcdd009540 layout/svg/base/src/nsSVGMaskFrame.cpp
--- a/layout/svg/base/src/nsSVGMaskFrame.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/svg/base/src/nsSVGMaskFrame.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -56,17 +56,17 @@ NS_NewSVGMaskFrame(nsIPresShell* aPresSh
     return nsnull;
   }
 
   return new (aPresShell) nsSVGMaskFrame(aContext);
 }
 
 already_AddRefed<gfxPattern>
 nsSVGMaskFrame::ComputeMaskAlpha(nsSVGRenderState *aContext,
-                                 nsISVGChildFrame* aParent,
+                                 nsIFrame* aParent,
                                  nsIDOMSVGMatrix* aMatrix,
                                  float aOpacity)
 {
   // If the flag is set when we get here, it means this mask frame
   // has already been used painting the current mask, and the document
   // has a mask reference loop.
   if (mInUse) {
     NS_WARNING("Mask loop detected!");
@@ -74,77 +74,33 @@ nsSVGMaskFrame::ComputeMaskAlpha(nsSVGRe
   }
   AutoMaskReferencer maskRef(this);
 
   gfxContext *gfx = aContext->GetGfxContext();
 
   gfx->PushGroup(gfxASurface::CONTENT_COLOR_ALPHA);
 
   {
-    nsIFrame *frame;
-    CallQueryInterface(aParent, &frame);
-    nsSVGElement *parent = static_cast<nsSVGElement*>(frame->GetContent());
-
-    float x, y, width, height;
-
     nsSVGMaskElement *mask = static_cast<nsSVGMaskElement*>(mContent);
-
-    nsSVGLength2 *tmpX, *tmpY, *tmpWidth, *tmpHeight;
-    tmpX = &mask->mLengthAttributes[nsSVGMaskElement::X];
-    tmpY = &mask->mLengthAttributes[nsSVGMaskElement::Y];
-    tmpWidth = &mask->mLengthAttributes[nsSVGMaskElement::WIDTH];
-    tmpHeight = &mask->mLengthAttributes[nsSVGMaskElement::HEIGHT];
 
     PRUint16 units =
       mask->mEnumAttributes[nsSVGMaskElement::MASKUNITS].GetAnimValue();
-
+    nsCOMPtr<nsIDOMSVGRect> bbox;
     if (units == nsIDOMSVGUnitTypes::SVG_UNIT_TYPE_OBJECTBOUNDINGBOX) {
-
-      aParent->SetMatrixPropagation(PR_FALSE);
-      aParent->NotifySVGChanged(nsISVGChildFrame::SUPPRESS_INVALIDATION |
-                                nsISVGChildFrame::TRANSFORM_CHANGED);
-
-      nsCOMPtr<nsIDOMSVGRect> bbox;
-      aParent->GetBBox(getter_AddRefs(bbox));
-
-      aParent->SetMatrixPropagation(PR_TRUE);
-      aParent->NotifySVGChanged(nsISVGChildFrame::SUPPRESS_INVALIDATION |
-                                nsISVGChildFrame::TRANSFORM_CHANGED);
-
+      bbox = nsSVGUtils::GetBBox(aParent);
       if (!bbox)
         return nsnull;
-
-#ifdef DEBUG_tor
-      bbox->GetX(&x);
-      bbox->GetY(&y);
-      bbox->GetWidth(&width);
-      bbox->GetHeight(&height);
-
-      fprintf(stderr, "mask bbox: %f,%f %fx%f\n", x, y, width, height);
-#endif
-
-      bbox->GetX(&x);
-      x += nsSVGUtils::ObjectSpace(bbox, tmpX);
-      bbox->GetY(&y);
-      y += nsSVGUtils::ObjectSpace(bbox, tmpY);
-      width = nsSVGUtils::ObjectSpace(bbox, tmpWidth);
-      height = nsSVGUtils::ObjectSpace(bbox, tmpHeight);
-    } else {
-      x = nsSVGUtils::UserSpace(parent, tmpX);
-      y = nsSVGUtils::UserSpace(parent, tmpY);
-      width = nsSVGUtils::UserSpace(parent, tmpWidth);
-      height = nsSVGUtils::UserSpace(parent, tmpHeight);
     }
 
-#ifdef DEBUG_tor
-    fprintf(stderr, "mask clip: %f,%f %fx%f\n", x, y, width, height);
-#endif
+    gfxRect maskArea = nsSVGUtils::GetRelativeRect(units,
+      &mask->mLengthAttributes[nsSVGMaskElement::X], bbox, aParent);
 
     gfx->Save();
-    nsSVGUtils::SetClipRect(gfx, aMatrix, x, y, width, height);
+    nsSVGUtils::SetClipRect(gfx, aMatrix, maskArea.X(), maskArea.Y(),
+                            maskArea.Width(), maskArea.Height());
   }
 
   mMaskParent = aParent;
   mMaskParentMatrix = aMatrix;
 
   for (nsIFrame* kid = mFrames.FirstChild(); kid;
        kid = kid->GetNextSibling()) {
     nsSVGUtils::PaintChildWithEffects(aContext, nsnull, kid);
diff -r b7bcdd009540 layout/svg/base/src/nsSVGMaskFrame.h
--- a/layout/svg/base/src/nsSVGMaskFrame.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/svg/base/src/nsSVGMaskFrame.h	Thu Sep 11 15:19:26 2008 +0300
@@ -52,17 +52,17 @@ protected:
   nsSVGMaskFrame(nsStyleContext* aContext) :
     nsSVGMaskFrameBase(aContext),
     mMaskParentMatrix(nsnull),
     mInUse(PR_FALSE) {}
 
 public:
   // nsSVGMaskFrame method:
   already_AddRefed<gfxPattern> ComputeMaskAlpha(nsSVGRenderState *aContext,
-                                                nsISVGChildFrame* aParent,
+                                                nsIFrame* aParent,
                                                 nsIDOMSVGMatrix* aMatrix,
                                                 float aOpacity = 1.0f);
 
   /**
    * Get the "type" of the frame
    *
    * @see nsGkAtoms::svgMaskFrame
    */
@@ -90,17 +90,17 @@ private:
     }
     ~AutoMaskReferencer() {
       mFrame->mInUse = PR_FALSE;
     }
   private:
     nsSVGMaskFrame *mFrame;
   };
 
-  nsISVGChildFrame *mMaskParent;
+  nsIFrame *mMaskParent;
   nsCOMPtr<nsIDOMSVGMatrix> mMaskParentMatrix;
   // recursion prevention flag
   PRPackedBool mInUse;
 
   // nsSVGContainerFrame methods:
   virtual already_AddRefed<nsIDOMSVGMatrix> GetCanvasTM();
 };
 
diff -r b7bcdd009540 layout/svg/base/src/nsSVGOuterSVGFrame.cpp
--- a/layout/svg/base/src/nsSVGOuterSVGFrame.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/svg/base/src/nsSVGOuterSVGFrame.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -414,20 +414,17 @@ nsSVGOuterSVGFrame::DidReflow(nsPresCont
       kid = kid->GetNextSibling();
     }
     
     UnsuspendRedraw(); // For the SuspendRedraw in InitSVG
   } else {
     // Now that all viewport establishing descendants have their correct size,
     // tell our foreignObject descendants to reflow their children.
     if (mForeignObjectHash.IsInitialized()) {
-#ifdef DEBUG
-      PRUint32 count =
-#endif
-        mForeignObjectHash.EnumerateEntries(ReflowForeignObject, nsnull);
+      PRUint32 count = mForeignObjectHash.EnumerateEntries(ReflowForeignObject, nsnull);
       NS_ASSERTION(count == mForeignObjectHash.Count(),
                    "We didn't reflow all our nsSVGForeignObjectFrames!");
     }
   }
   
   return rv;
 }
 
diff -r b7bcdd009540 layout/svg/base/src/nsSVGPathGeometryFrame.cpp
--- a/layout/svg/base/src/nsSVGPathGeometryFrame.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/svg/base/src/nsSVGPathGeometryFrame.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -494,18 +494,28 @@ nsSVGPathGeometryFrame::NotifyRedrawUnsu
     nsSVGUtils::UpdateGraphic(this);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsSVGPathGeometryFrame::SetMatrixPropagation(PRBool aPropagate)
 {
-  mPropagateTransform = aPropagate;
+  if (aPropagate) {
+    AddStateBits(NS_STATE_SVG_PROPAGATE_TRANSFORM);
+  } else {
+    RemoveStateBits(NS_STATE_SVG_PROPAGATE_TRANSFORM);
+  }
   return NS_OK;
+}
+
+PRBool
+nsSVGPathGeometryFrame::GetMatrixPropagation()
+{
+  return (GetStateBits() & NS_STATE_SVG_PROPAGATE_TRANSFORM) != 0;
 }
 
 NS_IMETHODIMP
 nsSVGPathGeometryFrame::SetOverrideCTM(nsIDOMSVGMatrix *aCTM)
 {
   mOverrideCTM = aCTM;
   return NS_OK;
 }
@@ -533,17 +543,17 @@ nsSVGPathGeometryFrame::GetBBox(nsIDOMSV
 // nsSVGGeometryFrame methods:
 
 /* readonly attribute nsIDOMSVGMatrix canvasTM; */
 NS_IMETHODIMP
 nsSVGPathGeometryFrame::GetCanvasTM(nsIDOMSVGMatrix * *aCTM)
 {
   *aCTM = nsnull;
 
-  if (!mPropagateTransform) {
+  if (!GetMatrixPropagation()) {
     if (mOverrideCTM) {
       *aCTM = mOverrideCTM;
       NS_ADDREF(*aCTM);
       return NS_OK;
     }
     return NS_NewSVGMatrix(aCTM);
   }
 
diff -r b7bcdd009540 layout/svg/base/src/nsSVGPathGeometryFrame.h
--- a/layout/svg/base/src/nsSVGPathGeometryFrame.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/svg/base/src/nsSVGPathGeometryFrame.h	Thu Sep 11 15:19:26 2008 +0300
@@ -60,18 +60,17 @@ class nsSVGPathGeometryFrame : public ns
 class nsSVGPathGeometryFrame : public nsSVGPathGeometryFrameBase,
                                public nsISVGChildFrame
 {
   friend nsIFrame*
   NS_NewSVGPathGeometryFrame(nsIPresShell* aPresShell, nsIContent* aContent,
                              nsStyleContext* aContext);
 protected:
   nsSVGPathGeometryFrame(nsStyleContext* aContext) :
-    nsSVGPathGeometryFrameBase(aContext),
-    mPropagateTransform(PR_TRUE) {}
+    nsSVGPathGeometryFrameBase(aContext) {}
 
 public:
   // nsISupports interface:
   NS_IMETHOD QueryInterface(const nsIID& aIID, void** aInstancePtr);
 private:
   NS_IMETHOD_(nsrefcnt) AddRef() { return 1; }
   NS_IMETHOD_(nsrefcnt) Release() { return 1; }
 
@@ -107,16 +106,17 @@ protected:
   NS_IMETHOD_(nsIFrame*) GetFrameForPoint(const nsPoint &aPoint);
   NS_IMETHOD_(nsRect) GetCoveredRegion();
   NS_IMETHOD UpdateCoveredRegion();
   NS_IMETHOD InitialUpdate();
   virtual void NotifySVGChanged(PRUint32 aFlags);
   NS_IMETHOD NotifyRedrawSuspended();
   NS_IMETHOD NotifyRedrawUnsuspended();
   NS_IMETHOD SetMatrixPropagation(PRBool aPropagate);
+  virtual PRBool GetMatrixPropagation();
   NS_IMETHOD SetOverrideCTM(nsIDOMSVGMatrix *aCTM);
   virtual already_AddRefed<nsIDOMSVGMatrix> GetOverrideCTM();
   NS_IMETHOD GetBBox(nsIDOMSVGRect **_retval);
   NS_IMETHOD_(PRBool) IsDisplayContainer() { return PR_FALSE; }
   NS_IMETHOD_(PRBool) HasValidCoveredRect() { return PR_TRUE; }
 
 protected:
   virtual PRUint16 GetHittestMask();
@@ -138,12 +138,11 @@ private:
   }
 
   nsSVGMarkerProperty *GetMarkerProperty();
   void UpdateMarkerProperty();
 
   void RemovePathProperties();
 
   nsCOMPtr<nsIDOMSVGMatrix> mOverrideCTM;
-  PRPackedBool mPropagateTransform;
 };
 
 #endif // __NS_SVGPATHGEOMETRYFRAME_H__
diff -r b7bcdd009540 layout/svg/base/src/nsSVGTSpanFrame.cpp
--- a/layout/svg/base/src/nsSVGTSpanFrame.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/svg/base/src/nsSVGTSpanFrame.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -96,23 +96,16 @@ nsSVGTSpanFrame::AttributeChanged(PRInt3
     NotifyGlyphMetricsChange();
   }
 
   return NS_OK;
 }
 
 //----------------------------------------------------------------------
 // nsISVGChildFrame methods
-
-NS_IMETHODIMP
-nsSVGTSpanFrame::SetMatrixPropagation(PRBool aPropagate)
-{
-  mPropagateTransform = aPropagate;
-  return NS_OK;
-}
 
 NS_IMETHODIMP
 nsSVGTSpanFrame::SetOverrideCTM(nsIDOMSVGMatrix *aCTM)
 {
   mOverrideCTM = aCTM;
   return NS_OK;
 }
 
diff -r b7bcdd009540 layout/svg/base/src/nsSVGTSpanFrame.h
--- a/layout/svg/base/src/nsSVGTSpanFrame.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/svg/base/src/nsSVGTSpanFrame.h	Thu Sep 11 15:19:26 2008 +0300
@@ -76,17 +76,16 @@ public:
 
 #ifdef DEBUG
   NS_IMETHOD GetFrameName(nsAString& aResult) const
   {
     return MakeFrameName(NS_LITERAL_STRING("SVGTSpan"), aResult);
   }
 #endif
   // nsISVGChildFrame interface:
-  NS_IMETHOD SetMatrixPropagation(PRBool aPropagate);
   NS_IMETHOD SetOverrideCTM(nsIDOMSVGMatrix *aCTM);
   virtual already_AddRefed<nsIDOMSVGMatrix> GetOverrideCTM();
 
   // nsSVGContainerFrame methods:
   virtual already_AddRefed<nsIDOMSVGMatrix> GetCanvasTM();
   
   // nsISVGGlyphFragmentNode interface:
   NS_IMETHOD_(PRUint32) GetNumberOfChars();
diff -r b7bcdd009540 layout/svg/base/src/nsSVGTextFrame.cpp
--- a/layout/svg/base/src/nsSVGTextFrame.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/svg/base/src/nsSVGTextFrame.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -208,23 +208,16 @@ nsSVGTextFrame::NotifyRedrawUnsuspended(
 nsSVGTextFrame::NotifyRedrawUnsuspended()
 {
   mMetricsState = unsuspended;
   UpdateGlyphPositioning(PR_FALSE);
   return nsSVGTextFrameBase::NotifyRedrawUnsuspended();
 }
 
 NS_IMETHODIMP
-nsSVGTextFrame::SetMatrixPropagation(PRBool aPropagate)
-{
-  mPropagateTransform = aPropagate;
-  return NS_OK;
-}
-
-NS_IMETHODIMP
 nsSVGTextFrame::SetOverrideCTM(nsIDOMSVGMatrix *aCTM)
 {
   mOverrideCTM = aCTM;
   return NS_OK;
 }
 
 already_AddRefed<nsIDOMSVGMatrix>
 nsSVGTextFrame::GetOverrideCTM()
@@ -277,17 +270,17 @@ nsSVGTextFrame::GetBBox(nsIDOMSVGRect **
 }
 
 //----------------------------------------------------------------------
 // nsSVGContainerFrame methods:
 
 already_AddRefed<nsIDOMSVGMatrix>
 nsSVGTextFrame::GetCanvasTM()
 {
-  if (!mPropagateTransform) {
+  if (!GetMatrixPropagation()) {
     nsIDOMSVGMatrix *retval;
     if (mOverrideCTM) {
       retval = mOverrideCTM;
       NS_ADDREF(retval);
     } else {
       NS_NewSVGMatrix(&retval);
     }
     return retval;
diff -r b7bcdd009540 layout/svg/base/src/nsSVGTextFrame.h
--- a/layout/svg/base/src/nsSVGTextFrame.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/svg/base/src/nsSVGTextFrame.h	Thu Sep 11 15:19:26 2008 +0300
@@ -46,17 +46,16 @@ class nsSVGTextFrame : public nsSVGTextF
 class nsSVGTextFrame : public nsSVGTextFrameBase
 {
   friend nsIFrame*
   NS_NewSVGTextFrame(nsIPresShell* aPresShell, nsIContent* aContent, nsStyleContext* aContext);
 protected:
   nsSVGTextFrame(nsStyleContext* aContext)
     : nsSVGTextFrameBase(aContext),
       mMetricsState(unsuspended),
-      mPropagateTransform(PR_TRUE),
       mPositioningDirty(PR_TRUE) {}
 
 public:
   // nsIFrame:
   NS_IMETHOD  AttributeChanged(PRInt32         aNameSpaceID,
                                nsIAtom*        aAttribute,
                                PRInt32         aModType);
 
@@ -70,17 +69,16 @@ public:
 #ifdef DEBUG
   NS_IMETHOD GetFrameName(nsAString& aResult) const
   {
     return MakeFrameName(NS_LITERAL_STRING("SVGText"), aResult);
   }
 #endif
 
   // nsISVGChildFrame interface:
-  NS_IMETHOD SetMatrixPropagation(PRBool aPropagate);
   NS_IMETHOD SetOverrideCTM(nsIDOMSVGMatrix *aCTM);
   virtual already_AddRefed<nsIDOMSVGMatrix> GetOverrideCTM();
   virtual void NotifySVGChanged(PRUint32 aFlags);
   NS_IMETHOD NotifyRedrawSuspended();
   NS_IMETHOD NotifyRedrawUnsuspended();
   // Override these four to ensure that UpdateGlyphPositioning is called
   // to bring glyph positions up to date
   NS_IMETHOD PaintSVG(nsSVGRenderState* aContext, nsIntRect *aDirtyRect);
@@ -114,13 +112,12 @@ private:
   void UpdateGlyphPositioning(PRBool aForceGlobalTransform);
 
   nsCOMPtr<nsIDOMSVGMatrix> mCanvasTM;
   nsCOMPtr<nsIDOMSVGMatrix> mOverrideCTM;
 
   enum UpdateState { unsuspended, suspended };
   UpdateState mMetricsState;
 
-  PRPackedBool mPropagateTransform;
   PRPackedBool mPositioningDirty;
 };
 
 #endif
diff -r b7bcdd009540 layout/svg/base/src/nsSVGUtils.cpp
--- a/layout/svg/base/src/nsSVGUtils.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/svg/base/src/nsSVGUtils.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -78,16 +78,18 @@
 #include "gfxRect.h"
 #include "gfxImageSurface.h"
 #include "gfxPlatform.h"
 #include "nsSVGForeignObjectFrame.h"
 #include "nsIFontMetrics.h"
 #include "nsIDOMSVGUnitTypes.h"
 #include "nsSVGRect.h"
 #include "nsSVGEffects.h"
+#include "nsSVGIntegrationUtils.h"
+#include "nsSVGFilterPaintCallback.h"
 
 gfxASurface *nsSVGUtils::mThebesComputationalSurface = nsnull;
 
 // c = n / 255
 // (c <= 0.0031308 ? c * 12.92 : 1.055 * pow(c, 1 / 2.4) - 0.055) * 255 + 0.5
 static const PRUint8 glinearRGBTosRGBMap[256] = {
   0,  13,  22,  28,  34,  38,  42,  46,
  50,  53,  56,  59,  61,  64,  66,  69,
@@ -212,41 +214,53 @@ nsSVGUtils::GetFontSize(nsIContent *aCon
 nsSVGUtils::GetFontSize(nsIContent *aContent)
 {
   nsIFrame* frame = GetFrameForContent(aContent);
   if (!frame) {
     NS_WARNING("no frame in GetFontSize()");
     return 1.0f;
   }
 
-  return nsPresContext::AppUnitsToFloatCSSPixels(frame->GetStyleFont()->mSize) /
-         frame->PresContext()->TextZoom();
+  return GetFontSize(frame);
+}
+
+float
+nsSVGUtils::GetFontSize(nsIFrame *aFrame)
+{
+  return nsPresContext::AppUnitsToFloatCSSPixels(aFrame->GetStyleFont()->mSize) /
+         aFrame->PresContext()->TextZoom();
 }
 
 float
 nsSVGUtils::GetFontXHeight(nsIContent *aContent)
 {
   nsIFrame* frame = GetFrameForContent(aContent);
   if (!frame) {
     NS_WARNING("no frame in GetFontXHeight()");
     return 1.0f;
   }
 
+  return GetFontXHeight(frame);
+}
+  
+float
+nsSVGUtils::GetFontXHeight(nsIFrame *aFrame)
+{
   nsCOMPtr<nsIFontMetrics> fontMetrics;
-  nsLayoutUtils::GetFontMetricsForFrame(frame, getter_AddRefs(fontMetrics));
+  nsLayoutUtils::GetFontMetricsForFrame(aFrame, getter_AddRefs(fontMetrics));
 
   if (!fontMetrics) {
     NS_WARNING("no FontMetrics in GetFontXHeight()");
     return 1.0f;
   }
 
   nscoord xHeight;
   fontMetrics->GetXHeight(xHeight);
   return nsPresContext::AppUnitsToFloatCSSPixels(xHeight) /
-         frame->PresContext()->TextZoom();
+         aFrame->PresContext()->TextZoom();
 }
 
 void
 nsSVGUtils::UnPremultiplyImageDataAlpha(PRUint8 *data, 
                                         PRInt32 stride,
                                         const nsIntRect &rect)
 {
   for (PRInt32 y = rect.y; y < rect.YMost(); y++) {
@@ -575,17 +589,17 @@ nsSVGUtils::FindFilterInvalidation(nsIFr
   while (aFrame) {
     if (aFrame->GetStateBits() & NS_STATE_IS_OUTER_SVG)
       break;
 
     nsSVGFilterProperty *property = nsSVGEffects::GetFilterProperty(aFrame);
     if (property) {
       nsSVGFilterFrame *filter = property->GetFilterFrame(nsnull);
       if (filter) {
-        rect = filter->GetInvalidationRegion(aFrame, rect);
+        rect = filter->GetInvalidationBBox(aFrame, rect);
       }
     }
     aFrame = aFrame->GetParent();
   }
 
   return rect;
 }
 
@@ -650,17 +664,17 @@ nsSVGUtils::NotifyAncestorsOfFilterRegio
 
 double
 nsSVGUtils::ComputeNormalizedHypotenuse(double aWidth, double aHeight)
 {
   return sqrt((aWidth*aWidth + aHeight*aHeight)/2);
 }
 
 float
-nsSVGUtils::ObjectSpace(nsIDOMSVGRect *aRect, nsSVGLength2 *aLength)
+nsSVGUtils::ObjectSpace(nsIDOMSVGRect *aRect, const nsSVGLength2 *aLength)
 {
   float fraction, axis;
 
   switch (aLength->GetCtxType()) {
   case X:
     aRect->GetWidth(&axis);
     break;
   case Y:
@@ -680,19 +694,25 @@ nsSVGUtils::ObjectSpace(nsIDOMSVGRect *a
   } else
     fraction = aLength->GetAnimValue(static_cast<nsSVGSVGElement*>
                                                 (nsnull));
 
   return fraction * axis;
 }
 
 float
-nsSVGUtils::UserSpace(nsSVGElement *aSVGElement, nsSVGLength2 *aLength)
+nsSVGUtils::UserSpace(nsSVGElement *aSVGElement, const nsSVGLength2 *aLength)
 {
   return aLength->GetAnimValue(aSVGElement);
+}
+
+float
+nsSVGUtils::UserSpace(nsIFrame *aNonSVGContext, const nsSVGLength2 *aLength)
+{
+  return aLength->GetAnimValue(aNonSVGContext);
 }
 
 void
 nsSVGUtils::TransformPoint(nsIDOMSVGMatrix *matrix, 
                            float *x, float *y)
 {
   nsCOMPtr<nsIDOMSVGPoint> point;
   NS_NewSVGPoint(getter_AddRefs(point), *x, *y);
@@ -846,16 +866,19 @@ nsSVGUtils::GetViewBoxTransform(float aV
 }
 
 
 // This is ugly and roc will want to kill me...
 
 already_AddRefed<nsIDOMSVGMatrix>
 nsSVGUtils::GetCanvasTM(nsIFrame *aFrame)
 {
+  if (!aFrame->IsFrameOfType(nsIFrame::eSVG))
+    return nsSVGIntegrationUtils::GetInitialMatrix(aFrame);
+
   if (!aFrame->IsLeaf()) {
     // foreignObject is the one non-leaf svg frame that isn't a SVGContainer
     if (aFrame->GetType() == nsGkAtoms::svgForeignObjectFrame) {
       nsSVGForeignObjectFrame *foreignFrame =
         static_cast<nsSVGForeignObjectFrame*>(aFrame);
       return foreignFrame->GetCanvasTM();
     }
     nsSVGContainerFrame *containerFrame = static_cast<nsSVGContainerFrame*>
@@ -912,16 +935,36 @@ nsSVGUtils::RemoveObserver(nsISupports *
   CallQueryInterface(aObserver, &observer);
   CallQueryInterface(aTarget, &v);
   if (observer && v)
     v->RemoveObserver(observer);
 }
 
 // ************************************************************
 
+class SVGPaintCallback : public nsSVGFilterPaintCallback
+{
+public:
+  virtual void Paint(nsSVGRenderState *aContext, nsIFrame *aTarget,
+                     const nsIntRect* aDirtyRect, nsIDOMSVGMatrix *aTransform)
+  {
+    nsISVGChildFrame *svgChildFrame;
+    CallQueryInterface(aTarget, &svgChildFrame);
+    NS_ASSERTION(svgChildFrame, "Expected SVG frame here");
+
+    if (aTransform) {
+      svgChildFrame->SetOverrideCTM(aTransform);
+      svgChildFrame->NotifySVGChanged(nsISVGChildFrame::SUPPRESS_INVALIDATION |
+                                      nsISVGChildFrame::TRANSFORM_CHANGED);
+    }
+
+    svgChildFrame->PaintSVG(aContext, const_cast<nsIntRect*>(aDirtyRect));
+  }
+};
+
 void
 nsSVGUtils::PaintChildWithEffects(nsSVGRenderState *aContext,
                                   nsIntRect *aDirtyRect,
                                   nsIFrame *aFrame)
 {
   nsISVGChildFrame *svgChildFrame;
   CallQueryInterface(aFrame, &svgChildFrame);
 
@@ -933,24 +976,31 @@ nsSVGUtils::PaintChildWithEffects(nsSVGR
     return;
 
   /* Properties are added lazily and may have been removed by a restyle,
      so make sure all applicable ones are set again. */
 
   nsSVGEffects::EffectProperties effectProperties =
     nsSVGEffects::GetEffectProperties(aFrame);
 
-  /* Check if we need to draw anything */
+  PRBool isOK = PR_TRUE;
+  nsSVGFilterFrame *filterFrame = effectProperties.mFilter ?
+    effectProperties.mFilter->GetFilterFrame(&isOK) : nsnull;
+
+  /* Check if we need to draw anything. HasValidCoveredRect only returns
+   * true for path geometry and glyphs, so basically we're traversing
+   * all containers and we can only skip leaves here.
+   */
   if (aDirtyRect && svgChildFrame->HasValidCoveredRect()) {
-    nsRect rect = *aDirtyRect;
-    rect.ScaleRoundOut(aFrame->PresContext()->AppUnitsPerDevPixel());
-    if (effectProperties.mFilter) {
-      if (!rect.Intersects(FindFilterInvalidation(aFrame, aFrame->GetRect())))
+    if (filterFrame) {
+      if (!aDirtyRect->Intersects(filterFrame->GetFilterBBox(aFrame, nsnull)))
         return;
     } else {
+      nsRect rect = *aDirtyRect;
+      rect.ScaleRoundOut(aFrame->PresContext()->AppUnitsPerDevPixel());
       if (!rect.Intersects(aFrame->GetRect()))
         return;
     }
   }
 
   /* SVG defines the following rendering model:
    *
    *  1. Render geometry
@@ -966,21 +1016,18 @@ nsSVGUtils::PaintChildWithEffects(nsSVGR
    */
 
   if (opacity != 1.0f && CanOptimizeOpacity(aFrame))
     opacity = 1.0f;
 
   gfxContext *gfx = aContext->GetGfxContext();
   PRBool complexEffects = PR_FALSE;
 
-  PRBool isOK = PR_TRUE;
   nsSVGClipPathFrame *clipPathFrame = effectProperties.mClipPath ?
     effectProperties.mClipPath->GetClipPathFrame(&isOK) : nsnull;
-  nsSVGFilterFrame *filterFrame = effectProperties.mFilter ?
-    effectProperties.mFilter->GetFilterFrame(&isOK) : nsnull;
   nsSVGMaskFrame *maskFrame = effectProperties.mMask ?
     effectProperties.mMask->GetMaskFrame(&isOK) : nsnull;
 
   PRBool isTrivialClip = clipPathFrame ? clipPathFrame->IsTrivial() : PR_TRUE;
 
   if (!isOK) {
     // Some resource is missing. We shouldn't paint anything.
     return;
@@ -997,45 +1044,46 @@ nsSVGUtils::PaintChildWithEffects(nsSVGR
     gfx->PushGroup(gfxASurface::CONTENT_COLOR_ALPHA);
   }
 
   /* If this frame has only a trivial clipPath, set up cairo's clipping now so
    * we can just do normal painting and get it clipped appropriately.
    */
   if (clipPathFrame && isTrivialClip) {
     gfx->Save();
-    clipPathFrame->ClipPaint(aContext, svgChildFrame, matrix);
+    clipPathFrame->ClipPaint(aContext, aFrame, matrix);
   }
 
   /* Paint the child */
   if (filterFrame) {
-    filterFrame->FilterPaint(aContext, svgChildFrame, aDirtyRect);
+    SVGPaintCallback paintCallback;
+    filterFrame->FilterPaint(aContext, aFrame, &paintCallback, aDirtyRect);
   } else {
     svgChildFrame->PaintSVG(aContext, aDirtyRect);
   }
 
   if (clipPathFrame && isTrivialClip) {
     gfx->Restore();
   }
 
   /* No more effects, we're done. */
   if (!complexEffects)
     return;
 
   gfx->PopGroupToSource();
 
   nsRefPtr<gfxPattern> maskSurface =
-    maskFrame ? maskFrame->ComputeMaskAlpha(aContext, svgChildFrame,
+    maskFrame ? maskFrame->ComputeMaskAlpha(aContext, aFrame,
                                             matrix, opacity) : nsnull;
 
   nsRefPtr<gfxPattern> clipMaskSurface;
   if (clipPathFrame && !isTrivialClip) {
     gfx->PushGroup(gfxASurface::CONTENT_COLOR_ALPHA);
 
-    nsresult rv = clipPathFrame->ClipPaint(aContext, svgChildFrame, matrix);
+    nsresult rv = clipPathFrame->ClipPaint(aContext, aFrame, matrix);
     clipMaskSurface = gfx->PopGroup();
 
     if (NS_SUCCEEDED(rv) && clipMaskSurface) {
       // Still more set after clipping, so clip to another surface
       if (maskSurface || opacity != 1.0f) {
         gfx->PushGroup(gfxASurface::CONTENT_COLOR_ALPHA);
         gfx->Mask(clipMaskSurface);
         gfx->PopGroupToSource();
@@ -1072,21 +1120,18 @@ nsSVGUtils::HitTestClip(nsIFrame *aFrame
 
   nsSVGClipPathFrame *clipPathFrame = props.mClipPath->GetClipPathFrame(nsnull);
   if (!clipPathFrame) {
     // clipPath is not a valid resource, so nothing gets painted, so
     // hit-testing must fail.
     return PR_FALSE;
   }
 
-  nsISVGChildFrame* SVGFrame;
-  CallQueryInterface(aFrame, &SVGFrame);
-
   nsCOMPtr<nsIDOMSVGMatrix> matrix = GetCanvasTM(aFrame);
-  return clipPathFrame->ClipHitTest(SVGFrame, matrix, aPoint);
+  return clipPathFrame->ClipHitTest(aFrame, matrix, aPoint);
 }
 
 nsIFrame *
 nsSVGUtils::HitTestChildren(nsIFrame *aFrame, const nsPoint &aPoint)
 {
   // XXX: The frame's children are linked in a singly-linked list in document
   // order. If we were to hit test the children in this order we would need to
   // hit test *every* SVG frame, since even if we get a hit, later SVG frames
@@ -1322,16 +1367,68 @@ nsSVGUtils::GfxRectToIntRect(const gfxRe
 nsSVGUtils::GfxRectToIntRect(const gfxRect& aIn, nsIntRect* aOut)
 {
   *aOut = nsIntRect(PRInt32(aIn.X()), PRInt32(aIn.Y()),
                     PRInt32(aIn.Width()), PRInt32(aIn.Height()));
   return gfxRect(aOut->x, aOut->y, aOut->width, aOut->height) == aIn
     ? NS_OK : NS_ERROR_FAILURE;
 }
 
+already_AddRefed<nsIDOMSVGRect>
+nsSVGUtils::GetBBox(nsIFrame *aFrame)
+{
+  nsISVGChildFrame *svg;
+  CallQueryInterface(aFrame, &svg);
+  if (!svg) {
+    nsIDOMSVGRect *rect = nsnull;
+    gfxRect r = nsSVGIntegrationUtils::GetSVGBBoxForNonSVGFrame(aFrame);
+    NS_NewSVGRect(&rect, r);
+    return rect;
+  }
+
+  PRBool needToDisablePropagation = svg->GetMatrixPropagation();
+  if (needToDisablePropagation) {
+    svg->SetMatrixPropagation(PR_FALSE);
+    svg->NotifySVGChanged(nsISVGChildFrame::SUPPRESS_INVALIDATION |
+                          nsISVGChildFrame::TRANSFORM_CHANGED);
+  }
+  
+  nsCOMPtr<nsIDOMSVGRect> bbox;
+  svg->GetBBox(getter_AddRefs(bbox));
+  
+  if (needToDisablePropagation) {
+    svg->SetMatrixPropagation(PR_TRUE);
+    svg->NotifySVGChanged(nsISVGChildFrame::SUPPRESS_INVALIDATION |
+                          nsISVGChildFrame::TRANSFORM_CHANGED);
+  }
+
+  return bbox.forget();
+}
+
+gfxRect
+nsSVGUtils::GetRelativeRect(PRUint16 aUnits, const nsSVGLength2 *aXYWH,
+                            nsIDOMSVGRect *aBBox, nsIFrame *aFrame)
+{
+  float x, y, width, height;
+  if (aUnits == nsIDOMSVGUnitTypes::SVG_UNIT_TYPE_OBJECTBOUNDINGBOX) {
+    aBBox->GetX(&x);
+    x += ObjectSpace(aBBox, &aXYWH[0]);
+    aBBox->GetY(&y);
+    y += ObjectSpace(aBBox, &aXYWH[1]);
+    width = ObjectSpace(aBBox, &aXYWH[2]);
+    height = ObjectSpace(aBBox, &aXYWH[3]);
+  } else {
+    x = nsSVGUtils::UserSpace(aFrame, &aXYWH[0]);
+    y = nsSVGUtils::UserSpace(aFrame, &aXYWH[1]);
+    width = nsSVGUtils::UserSpace(aFrame, &aXYWH[2]);
+    height = nsSVGUtils::UserSpace(aFrame, &aXYWH[3]);
+  }
+  return gfxRect(x, y, width, height);
+}
+
 PRBool
 nsSVGUtils::CanOptimizeOpacity(nsIFrame *aFrame)
 {
   if (!aFrame->GetStyleSVGReset()->mFilter) {
     nsIAtom *type = aFrame->GetType();
     if (type == nsGkAtoms::svgImageFrame)
       return PR_TRUE;
     if (type == nsGkAtoms::svgPathGeometryFrame) {
@@ -1358,43 +1455,55 @@ nsSVGUtils::MaxExpansion(nsIDOMSVGMatrix
   float g = (a * a + b * b - c * c - d * d) / 2;
   float h = a * c + b * d;
   return sqrt(f + sqrt(g * g + h * h));
 }
 
 already_AddRefed<nsIDOMSVGMatrix>
 nsSVGUtils::AdjustMatrixForUnits(nsIDOMSVGMatrix *aMatrix,
                                  nsSVGEnum *aUnits,
-                                 nsISVGChildFrame *aFrame)
+                                 nsIFrame *aFrame)
 {
   nsCOMPtr<nsIDOMSVGMatrix> fini = aMatrix;
 
   if (aFrame &&
       aUnits->GetAnimValue() == nsIDOMSVGUnitTypes::SVG_UNIT_TYPE_OBJECTBOUNDINGBOX) {
-    nsCOMPtr<nsIDOMSVGRect> rect;
-    nsresult rv = aFrame->GetBBox(getter_AddRefs(rect));
+    float minx, miny, width, height;
 
-    if (NS_SUCCEEDED(rv)) {
-      float minx, miny, width, height;
-      rect->GetX(&minx);
-      rect->GetY(&miny);
-      rect->GetWidth(&width);
-      rect->GetHeight(&height);
+    PRBool gotRect = PR_FALSE;
+    if (aFrame->IsFrameOfType(nsIFrame::eSVG)) {
+      nsISVGChildFrame *svgFrame;
+      CallQueryInterface(aFrame, &svgFrame);
+      nsCOMPtr<nsIDOMSVGRect> rect;
+      svgFrame->GetBBox(getter_AddRefs(rect));
+      if (rect) {
+        gotRect = PR_TRUE;
+        rect->GetX(&minx);
+        rect->GetY(&miny);
+        rect->GetWidth(&width);
+        rect->GetHeight(&height);
+        // Correct for scaling in outersvg CTM
+        nsPresContext *presCtx = aFrame->PresContext();
+        float scaleInv =
+          presCtx->AppUnitsToGfxUnits(presCtx->AppUnitsPerCSSPixel());
+        minx /= scaleInv;
+        miny /= scaleInv;
+        width /= scaleInv;
+        height /= scaleInv;
+      }
+    } else {
+      gotRect = PR_TRUE;
+      gfxRect r = nsSVGIntegrationUtils::GetSVGBBoxForNonSVGFrame(aFrame);
+      minx = r.X();
+      miny = r.Y();
+      width = r.Width();
+      height = r.Height();
+    }
 
-      // Correct for scaling in outersvg CTM
-      nsIFrame *frame;
-      CallQueryInterface(aFrame, &frame);
-      nsPresContext *presCtx = frame->PresContext();
-      float cssPxPerDevPx =
-        presCtx->AppUnitsToFloatCSSPixels(presCtx->AppUnitsPerDevPixel());
-      minx *= cssPxPerDevPx;
-      miny *= cssPxPerDevPx;
-      width *= cssPxPerDevPx;
-      height *= cssPxPerDevPx;
-
+    if (gotRect) {
       nsCOMPtr<nsIDOMSVGMatrix> tmp;
       aMatrix->Translate(minx, miny, getter_AddRefs(tmp));
       tmp->ScaleNonUniform(width, height, getter_AddRefs(fini));
     }
   }
 
   nsIDOMSVGMatrix* retval = fini.get();
   NS_IF_ADDREF(retval);
@@ -1439,12 +1548,14 @@ nsSVGRenderState::nsSVGRenderState(gfxAS
 }
 
 nsIRenderingContext*
 nsSVGRenderState::GetRenderingContext(nsIFrame *aFrame)
 {
   if (!mRenderingContext) {
     nsIDeviceContext* devCtx = aFrame->PresContext()->DeviceContext();
     devCtx->CreateRenderingContextInstance(*getter_AddRefs(mRenderingContext));
+    if (!mRenderingContext)
+      return nsnull;
     mRenderingContext->Init(devCtx, mGfxContext);
   }
   return mRenderingContext;
 }
diff -r b7bcdd009540 layout/svg/base/src/nsSVGUtils.h
--- a/layout/svg/base/src/nsSVGUtils.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/svg/base/src/nsSVGUtils.h	Thu Sep 11 15:19:26 2008 +0300
@@ -95,16 +95,18 @@ class nsISVGChildFrame;
 /* Do we have a paint server for stroke with a valid URL? */
 #define NS_STATE_SVG_STROKE_PSERVER   0x01000000
 /* Do we have any paint servers with valid URLs? */
 #define NS_STATE_SVG_PSERVER_MASK     0x01800000
 
 /* are we the child of a non-display container? */
 #define NS_STATE_SVG_NONDISPLAY_CHILD 0x02000000
 
+#define NS_STATE_SVG_PROPAGATE_TRANSFORM 0x04000000
+
 /**
  * Byte offsets of channels in a native packed gfxColor or cairo image surface.
  */
 #ifdef IS_BIG_ENDIAN
 #define GFX_ARGB32_OFFSET_A 0
 #define GFX_ARGB32_OFFSET_R 1
 #define GFX_ARGB32_OFFSET_G 2
 #define GFX_ARGB32_OFFSET_B 3
@@ -187,21 +189,22 @@ NS_DEFINE_STATIC_IID_ACCESSOR(nsISVGFilt
 
 class nsSVGUtils
 {
 public:
   /*
    * Get a font-size (em) of an nsIContent
    */
   static float GetFontSize(nsIContent *aContent);
-
+  static float GetFontSize(nsIFrame *aFrame);
   /*
    * Get an x-height of of an nsIContent
    */
   static float GetFontXHeight(nsIContent *aContent);
+  static float GetFontXHeight(nsIFrame *aFrame);
 
   /*
    * Converts image data from premultipled to unpremultiplied alpha
    */
   static void UnPremultiplyImageDataAlpha(PRUint8 *data, 
                                           PRInt32 stride, 
                                           const nsIntRect &rect);
   /*
@@ -294,23 +297,29 @@ public:
    * Computes sqrt((aWidth^2 + aHeight^2)/2);
    */
   static double ComputeNormalizedHypotenuse(double aWidth, double aHeight);
 
   /* Computes the input length in terms of object space coordinates.
      Input: rect - bounding box
             length - length to be converted
   */
-  static float ObjectSpace(nsIDOMSVGRect *aRect, nsSVGLength2 *aLength);
+  static float ObjectSpace(nsIDOMSVGRect *aRect, const nsSVGLength2 *aLength);
 
   /* Computes the input length in terms of user space coordinates.
      Input: content - object to be used for determining user space
+     Input: length - length to be converted
+  */
+  static float UserSpace(nsSVGElement *aSVGElement, const nsSVGLength2 *aLength);
+
+  /* Computes the input length in terms of user space coordinates.
+     Input: aFrame - object to be used for determining user space
             length - length to be converted
   */
-  static float UserSpace(nsSVGElement *aSVGElement, nsSVGLength2 *aLength);
+  static float UserSpace(nsIFrame *aFrame, const nsSVGLength2 *aLength);
 
   /* Tranforms point by the matrix.  In/out: x,y */
   static void
   TransformPoint(nsIDOMSVGMatrix *matrix,
                  float *x, float *y);
 
   /* Returns the angle halfway between the two specified angles */
   static float
@@ -332,18 +341,18 @@ public:
   
   static already_AddRefed<nsIDOMSVGMatrix>
   GetViewBoxTransform(float aViewportWidth, float aViewportHeight,
                       float aViewboxX, float aViewboxY,
                       float aViewboxWidth, float aViewboxHeight,
                       nsIDOMSVGAnimatedPreserveAspectRatio *aPreserveAspectRatio,
                       PRBool aIgnoreAlign = PR_FALSE);
 
-  /* Paint frame with SVG effects - aDirtyRect is the area being
-   * redrawn, in frame offset pixel coordinates */
+  /* Paint SVG frame with SVG effects - aDirtyRect is the area being
+   * redrawn, in device pixel coordinates relative to the outer svg */
   static void
   PaintChildWithEffects(nsSVGRenderState *aContext,
                         nsIntRect *aDirtyRect,
                         nsIFrame *aFrame);
 
   /**
    * Called by nsCSSFrameConstructor when style changes require the
    * effect properties on aFrame to be updated
@@ -366,17 +375,18 @@ public:
   AddObserver(nsISupports *aObserver, nsISupports *aTarget);
 
   /* Remove observation of an nsISVGValue from an nsISVGValueObserver */
   static void
   RemoveObserver(nsISupports *aObserver, nsISupports *aTarget);
 
   /*
    * Returns the CanvasTM of the indicated frame, whether it's a
-   * child or container SVG frame.
+   * child SVG frame, container SVG frame, or a regular frame.
+   * For regular frames, we just return an identity matrix.
    */
   static already_AddRefed<nsIDOMSVGMatrix> GetCanvasTM(nsIFrame *aFrame);
 
   /*
    * Tells child frames that something that might affect them has changed
    */
   static void
   NotifyChildrenOfSVGChange(nsIFrame *aFrame, PRUint32 aFlags);
@@ -464,17 +474,36 @@ public:
   /* Calculate the maximum expansion of a matrix */
   static float
   MaxExpansion(nsIDOMSVGMatrix *aMatrix);
 
   /* Take a CTM and adjust for object bounding box coordinates, if needed */
   static already_AddRefed<nsIDOMSVGMatrix>
   AdjustMatrixForUnits(nsIDOMSVGMatrix *aMatrix,
                        nsSVGEnum *aUnits,
-                       nsISVGChildFrame *aFrame);
+                       nsIFrame *aFrame);
+
+  /**
+   * Get bounding-box for aFrame. Matrix propagation is disabled so the
+   * bounding box is computed in terms of aFrame's own user space.
+   */
+  static already_AddRefed<nsIDOMSVGRect>
+  GetBBox(nsIFrame *aFrame);
+  /**
+   * Compute a rectangle in userSpaceOnUse or objectBoundingBoxUnits.
+   * @param aXYWH pointer to 4 consecutive nsSVGLength2 objects containing
+   * the x, y, width and height values in that order
+   * @param aBBox the bounding box of the object the rect is relative to;
+   * may be null if aUnits is not SVG_UNIT_TYPE_OBJECTBOUNDINGBOX
+   * @param aFrame the object in which to interpret user-space units;
+   * may be null if aUnits is SVG_UNIT_TYPE_OBJECTBOUNDINGBOX
+   */
+  static gfxRect
+  GetRelativeRect(PRUint16 aUnits, const nsSVGLength2 *aXYWH, nsIDOMSVGRect *aBBox,
+                  nsIFrame *aFrame);
 
 #ifdef DEBUG
   static void
   WritePPM(const char *fname, gfxImageSurface *aSurface);
 #endif
 
 private:
   /* Computational (nil) surfaces */
diff -r b7bcdd009540 layout/tables/Makefile.in
--- a/layout/tables/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/tables/Makefile.in	Thu Sep 11 15:19:26 2008 +0300
@@ -84,17 +84,17 @@ CPPSRCS		= \
 		nsTableRowFrame.cpp \
 		nsTableRowGroupFrame.cpp \
 		nsTablePainter.cpp \
 		$(NULL)
 
 # we don't want the shared lib, but we want to force the creation of a static lib.
 FORCE_STATIC_LIB = 1
 
-ifdef MOZ_MOCHITEST
+ifdef ENABLE_TESTS
 DIRS  = test
 endif
 
 include $(topsrcdir)/config/rules.mk
 
 DEFINES         += -DDEBUG_TABLE_STRATEGY_off -D_IMPL_NS_LAYOUT
 
 LOCAL_INCLUDES	= \
diff -r b7bcdd009540 layout/tools/reftest/reftest-cmdline.js
--- a/layout/tools/reftest/reftest-cmdline.js	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/tools/reftest/reftest-cmdline.js	Thu Sep 11 15:19:26 2008 +0300
@@ -92,16 +92,22 @@ RefTestCmdLineHandler.prototype =
       catch (e) {
         return;
       }
     }
     catch (e) {
       cmdLine.handleFlag("reftest", true);
     }
 
+    /* Force sRGB as an output profile for color management before we load a
+       window. */
+    var prefs = Components.classes["@mozilla.org/preferences-service;1"].
+                getService(Components.interfaces.nsIPrefBranch2);
+    prefs.setBoolPref("gfx.color_management.force_srgb", true);
+
     var wwatch = Components.classes["@mozilla.org/embedcomp/window-watcher;1"]
                            .getService(nsIWindowWatcher);
     wwatch.openWindow(null, "chrome://reftest/content/reftest.xul", "_blank",
                       "chrome,dialog=no,all", args);
     cmdLine.preventDefault = true;
   },
 
   helpInfo : "  -reftest <file>    Run layout acceptance tests on given manifest.\n"
diff -r b7bcdd009540 layout/tools/reftest/reftest.js
--- a/layout/tools/reftest/reftest.js	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/tools/reftest/reftest.js	Thu Sep 11 15:19:26 2008 +0300
@@ -116,16 +116,21 @@ function OnRefTestLoad()
         //gBrowser.loadURI('data:text/plain,' + ex);
         dump("REFTEST TEST-FAIL | | EXCEPTION: " + ex + "\n");
         DoneTests();
     }
 }
 
 function OnRefTestUnload()
 {
+    /* Clear the sRGB forcing pref to leave the profile as we found it. */
+    var prefs = Components.classes["@mozilla.org/preferences-service;1"].
+                getService(Components.interfaces.nsIPrefBranch2);
+    prefs.clearUserPref("gfx.color_management.force_srgb");
+
     gBrowser.removeEventListener("load", OnDocumentLoad, true);
 }
 
 function ReadTopManifest(aFileURL)
 {
     gURLs = new Array();
     var url = gIOService.newURI(aFileURL, null, null);
     if (!url || !url.schemeIs("file"))
diff -r b7bcdd009540 layout/xul/Makefile.in
--- a/layout/xul/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/xul/Makefile.in	Thu Sep 11 15:19:26 2008 +0300
@@ -39,14 +39,14 @@ topsrcdir	= @top_srcdir@
 topsrcdir	= @top_srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 DIRS		= base
 
-ifdef MOZ_MOCHITEST
+ifdef ENABLE_TESTS
 DIRS		+= test
 endif
 
 include $(topsrcdir)/config/rules.mk
 
diff -r b7bcdd009540 layout/xul/base/Makefile.in
--- a/layout/xul/base/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/xul/base/Makefile.in	Thu Sep 11 15:19:26 2008 +0300
@@ -39,14 +39,14 @@ topsrcdir	= @top_srcdir@
 topsrcdir	= @top_srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 DIRS		= public src
 
-ifdef MOZ_MOCHITEST
+ifdef ENABLE_TESTS
 DIRS		+= test
 endif
 
 include $(topsrcdir)/config/rules.mk
 
diff -r b7bcdd009540 layout/xul/base/src/nsBox.cpp
--- a/layout/xul/base/src/nsBox.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/xul/base/src/nsBox.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -752,33 +752,35 @@ nsIBox::AddCSSMinSize(nsBoxLayoutState& 
     // we will assume 0 means not set.
     if (position->mMinWidth.GetUnit() == eStyleUnit_Coord) {
         nscoord min = position->mMinWidth.GetCoordValue();
         if (min && (!widthSet || (min > aSize.width && canOverride))) {
            aSize.width = min;
            widthSet = PR_TRUE;
         }
     } else if (position->mMinWidth.GetUnit() == eStyleUnit_Percent) {
-        NS_ASSERTION(position->mMinWidth.GetPercentValue() == 0.0f, "Non-zero percentage values not currently supported");
+        float min = position->mMinWidth.GetPercentValue();
+        NS_ASSERTION(min == 0.0f, "Non-zero percentage values not currently supported");
         aSize.width = 0;
         widthSet = PR_TRUE;
     }
     // XXX Handle eStyleUnit_Enumerated?
     // (Handling the eStyleUnit_Enumerated types requires
     // GetPrefSize/GetMinSize methods that don't consider
     // (min-/max-/)(width/height) properties.
 
     if (position->mMinHeight.GetUnit() == eStyleUnit_Coord) {
         nscoord min = position->mMinHeight.GetCoordValue();
         if (min && (!heightSet || (min > aSize.height && canOverride))) {
            aSize.height = min;
            heightSet = PR_TRUE;
         }
     } else if (position->mMinHeight.GetUnit() == eStyleUnit_Percent) {
-        NS_ASSERTION(position->mMinHeight.GetPercentValue() == 0.0f, "Non-zero percentage values not currently supported");
+        float min = position->mMinHeight.GetPercentValue();
+        NS_ASSERTION(min == 0.0f, "Non-zero percentage values not currently supported");
         aSize.height = 0;
         heightSet = PR_TRUE;
     }
 
     nsIContent* content = aBox->GetContent();
     if (content) {
         nsAutoString value;
         PRInt32 error;
diff -r b7bcdd009540 layout/xul/base/src/nsMenuPopupFrame.cpp
--- a/layout/xul/base/src/nsMenuPopupFrame.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/xul/base/src/nsMenuPopupFrame.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -69,29 +69,32 @@
 #include "nsIScrollableView.h"
 #include "nsIScrollableFrame.h"
 #include "nsGUIEvent.h"
 #include "nsIRootBox.h"
 #include "nsIDocShellTreeItem.h"
 #include "nsReadableUtils.h"
 #include "nsUnicharUtils.h"
 #include "nsLayoutUtils.h"
+#include "nsContentUtils.h"
 #include "nsCSSFrameConstructor.h"
 #include "nsIEventStateManager.h"
 #include "nsIBoxLayout.h"
 #include "nsIPopupBoxObject.h"
 #include "nsIReflowCallback.h"
 #include "nsBindingManager.h"
 #include "nsIDocShellTreeOwner.h"
 #include "nsIBaseWindow.h"
 #ifdef XP_WIN
 #include "nsISound.h"
 #endif
 
 const PRInt32 kMaxZ = 0x7fffffff; //XXX: Shouldn't there be a define somewhere for MaxInt for PRInt32
+
+PRInt8 nsMenuPopupFrame::sDefaultLevelParent = -1;
 
 // NS_NewMenuPopupFrame
 //
 // Wrapper for creating a new menu popup container
 //
 nsIFrame*
 NS_NewMenuPopupFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
 {
@@ -113,16 +116,20 @@ nsMenuPopupFrame::nsMenuPopupFrame(nsIPr
   mAdjustOffsetForContextMenu(PR_FALSE),
   mGeneratedChildren(PR_FALSE),
   mMenuCanOverlapOSBar(PR_FALSE),
   mShouldAutoPosition(PR_TRUE),
   mConsumeRollupEvent(nsIPopupBoxObject::ROLLUP_DEFAULT),
   mInContentShell(PR_TRUE),
   mPrefSize(-1, -1)
 {
+  if (sDefaultLevelParent >= 0)
+    return;
+  sDefaultLevelParent =
+    nsContentUtils::GetBoolPref("ui.panel.default_level_parent", PR_FALSE);
 } // ctor
 
 
 NS_IMETHODIMP
 nsMenuPopupFrame::Init(nsIContent*      aContent,
                        nsIFrame*        aParent,
                        nsIFrame*        aPrevInFlow)
 {
@@ -184,16 +191,41 @@ nsMenuPopupFrame::IsNoAutoHide()
   // Panels with noautohide="true" don't hide when the mouse is clicked
   // outside of them, or when another application is made active. Non-autohide
   // panels cannot be used in content windows.
   return (!mInContentShell && mPopupType == ePopupTypePanel &&
            mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::noautohide,
                                  nsGkAtoms::_true, eIgnoreCase));
 }
 
+PRBool
+nsMenuPopupFrame::IsTopMost()
+{
+  // If this panel is not a panel, this is always a top-most popup
+  if (mPopupType != ePopupTypePanel)
+    return PR_TRUE;
+
+  // If this panel is a noautohide panel, it should appear just above the parent
+  // window.
+  if (IsNoAutoHide())
+    return PR_FALSE;
+
+  // Otherwise, check the topmost attribute.
+  if (mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::level,
+                            nsGkAtoms::top, eIgnoreCase))
+    return PR_TRUE;
+
+  if (mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::level,
+                            nsGkAtoms::parent, eIgnoreCase))
+    return PR_FALSE;
+
+  // Otherwise, the result depends on the platform.
+  return sDefaultLevelParent ? PR_TRUE : PR_FALSE;
+}
+
 void
 nsMenuPopupFrame::EnsureWidget()
 {
   nsIView* ourView = GetView();
   if (!ourView->HasWidget()) {
     NS_ASSERTION(!mGeneratedChildren && !GetFirstChild(nsnull),
                  "Creating widget for MenuPopupFrame with children");
     CreateWidgetForView(ourView);
@@ -214,21 +246,21 @@ nsMenuPopupFrame::CreateWidgetForView(ns
                                      (eTransparencyTransparent ==
                                       nsLayoutUtils::GetFrameTransparency(this));
   nsIContent* parentContent = GetContent()->GetParent();
   nsIAtom *tag = nsnull;
   if (parentContent)
     tag = parentContent->Tag();
   widgetData.mDropShadow = !(viewHasTransparentContent || tag == nsGkAtoms::menulist);
 
-  // panels which don't auto-hide need a parent widget. This allows them
-  // to always appear in front of the parent window but behind other windows
-  // that should be in front of it.
+  // panels which are not topmost need a parent widget. This allows them to
+  // always appear in front of the parent window but behind other windows that
+  // should be in front of it.
   nsCOMPtr<nsIWidget> parentWidget;
-  if (IsNoAutoHide()) {
+  if (!IsTopMost()) {
     nsCOMPtr<nsISupports> cont = PresContext()->GetContainer();
     nsCOMPtr<nsIDocShellTreeItem> dsti = do_QueryInterface(cont);
     if (!dsti)
       return NS_ERROR_FAILURE;
 
     nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
     dsti->GetTreeOwner(getter_AddRefs(treeOwner));
     if (!treeOwner) return NS_ERROR_FAILURE;
diff -r b7bcdd009540 layout/xul/base/src/nsMenuPopupFrame.h
--- a/layout/xul/base/src/nsMenuPopupFrame.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/xul/base/src/nsMenuPopupFrame.h	Thu Sep 11 15:19:26 2008 +0300
@@ -175,16 +175,20 @@ public:
   virtual void InvalidateInternal(const nsRect& aDamageRect,
                                   nscoord aX, nscoord aY, nsIFrame* aForChild,
                                   PRBool aImmediate);
 
   // returns true if the popup is a panel with the noautohide attribute set to
   // true. These panels do not roll up automatically.
   PRBool IsNoAutoHide();
 
+  // returns true if the popup is a top-most window. Otherwise, the
+  // panel appears in front of the parent window.
+  PRBool IsTopMost();
+
   void EnsureWidget();
 
   virtual nsresult CreateWidgetForView(nsIView* aView);
 
   NS_IMETHOD SetInitialChildList(nsIAtom*        aListName,
                                  nsIFrame*       aChildList);
 
   virtual PRBool IsLeaf() const;
@@ -348,11 +352,12 @@ protected:
   // mRect in the case where the popup was resized because it was too large
   // for the screen. The preferred size mPrefSize holds the full size the popup
   // would be before resizing. Computations are performed using this size.
   // The parent frame is responsible for setting the preferred size using
   // SetPreferredBounds or SetPreferredSize before positioning the popup with
   // SetPopupPosition.
   nsSize mPrefSize;
 
+  static PRInt8 sDefaultLevelParent;
 }; // class nsMenuPopupFrame
 
 #endif
diff -r b7bcdd009540 layout/xul/base/src/nsSliderFrame.cpp
--- a/layout/xul/base/src/nsSliderFrame.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/xul/base/src/nsSliderFrame.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -84,20 +84,20 @@ GetContentOfBox(nsIBox *aBox)
   nsIContent* content = aBox->GetContent();
   NS_IF_ADDREF(content);
   return content;
 }
 
 // Helper function to collect the "scroll to click" metric. Beware of
 // caching this, users expect to be able to change the system preference
 // and see the browser change its behavior immediately.
-static PRInt32
+static PRBool
 GetScrollToClick()
 {
-  PRInt32 scrollToClick = PR_FALSE;
+  PRBool scrollToClick = PR_FALSE;
   nsresult rv;
   nsCOMPtr<nsILookAndFeel> lookNFeel =
     do_GetService("@mozilla.org/widget/lookandfeel;1", &rv);
   if (NS_SUCCEEDED(rv)) {
     PRInt32 scrollToClickMetric;
     rv = lookNFeel->GetMetric(nsILookAndFeel::eMetric_ScrollToClick,
                               scrollToClickMetric);
     if (NS_SUCCEEDED(rv) && scrollToClickMetric == 1)
diff -r b7bcdd009540 layout/xul/base/src/nsXULPopupManager.cpp
--- a/layout/xul/base/src/nsXULPopupManager.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/xul/base/src/nsXULPopupManager.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -526,17 +526,17 @@ CheckCaretDrawingState(nsIDocument *aDoc
   if (!focusedDoc)
     return;
 
   nsIPresShell* presShell = focusedDoc->GetPrimaryShell();
   if (!presShell)
     return;
 
   nsRefPtr<nsCaret> caret;
-  presShell->GetCaret(getter_AddRefs(caret));
+  nsresult res = presShell->GetCaret(getter_AddRefs(caret));
   if (!caret)
     return;
   caret->CheckCaretDrawingState();
 
 }
 
 void
 nsXULPopupManager::ShowPopupCallback(nsIContent* aPopup,
@@ -1205,45 +1205,53 @@ nsXULPopupManager::MayShowPopup(nsMenuPo
   // if the popup was just rolled up, don't reopen it
   nsCOMPtr<nsIWidget> widget;
   aPopup->GetWidget(getter_AddRefs(widget));
   if (widget && widget->GetLastRollup() == aPopup->GetContent())
       return PR_FALSE;
 
   nsCOMPtr<nsISupports> cont = aPopup->PresContext()->GetContainer();
   nsCOMPtr<nsIDocShellTreeItem> dsti = do_QueryInterface(cont);
-  if (!dsti)
+  nsCOMPtr<nsIBaseWindow> baseWin = do_QueryInterface(dsti);
+  if (!baseWin)
     return PR_FALSE;
 
-  // chrome shells can always open popups, but other types of shells can only
-  // open popups when they are focused
   PRInt32 type = -1;
   if (NS_FAILED(dsti->GetItemType(&type)))
     return PR_FALSE;
 
+  // chrome shells can always open popups, but other types of shells can only
+  // open popups when they are focused and visible
   if (type != nsIDocShellTreeItem::typeChrome) {
+    // only allow popups in active windows
     nsCOMPtr<nsPIDOMWindow> win = do_GetInterface(dsti);
     if (!win)
       return PR_FALSE;
 
-    // only allow popups in active windows
     PRBool active;
     nsIFocusController* focusController = win->GetRootFocusController();
     focusController->GetActive(&active);
     if (!active)
       return PR_FALSE;
 
-    nsCOMPtr<nsIBaseWindow> baseWin = do_QueryInterface(dsti);
-    if (!baseWin)
-      return PR_FALSE;
-
     // only allow popups in visible frames
     PRBool visible;
     baseWin->GetVisibility(&visible);
     if (!visible)
+      return PR_FALSE;
+  }
+
+  // platforms respond differently when an popup is opened in a minimized
+  // window, so this is always disabled.
+  nsCOMPtr<nsIWidget> mainWidget;
+  baseWin->GetMainWidget(getter_AddRefs(mainWidget));
+  if (mainWidget) {
+    PRInt32 sizeMode;
+    mainWidget->GetSizeMode(&sizeMode);
+    if (sizeMode == nsSizeMode_Minimized)
       return PR_FALSE;
   }
 
   // cannot open a popup that is a submenu of a menupopup that isn't open.
   nsIFrame* parent = aPopup->GetParent();
   if (parent && parent->GetType() == nsGkAtoms::menuFrame) {
     nsMenuFrame* menuFrame = static_cast<nsMenuFrame *>(parent);
     nsIMenuParent* parentPopup = menuFrame->GetMenuParent();
diff -r b7bcdd009540 layout/xul/base/src/nsXULTooltipListener.cpp
--- a/layout/xul/base/src/nsXULTooltipListener.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/xul/base/src/nsXULTooltipListener.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -476,20 +476,17 @@ static void
 static void
 SetTitletipLabel(nsITreeBoxObject* aTreeBox, nsIContent* aTooltip,
                  PRInt32 aRow, nsITreeColumn* aCol)
 {
   nsCOMPtr<nsITreeView> view;
   aTreeBox->GetView(getter_AddRefs(view));
   if (view) {
     nsAutoString label;
-#ifdef DEBUG
-    nsresult rv = 
-#endif
-      view->GetCellText(aRow, aCol, label);
+    nsresult rv = view->GetCellText(aRow, aCol, label);
     NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "Couldn't get the cell text!");
     aTooltip->SetAttr(kNameSpaceID_None, nsGkAtoms::label, label, PR_TRUE);
   }
 }
 #endif
 
 void
 nsXULTooltipListener::LaunchTooltip()
diff -r b7bcdd009540 layout/xul/base/src/tree/src/nsTreeBodyFrame.cpp
--- a/layout/xul/base/src/tree/src/nsTreeBodyFrame.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/layout/xul/base/src/tree/src/nsTreeBodyFrame.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -539,17 +539,19 @@ NS_IMETHODIMP nsTreeBodyFrame::SetView(n
       sel->SetTree(mTreeBoxObject);
     }
     else {
       NS_NewTreeSelection(mTreeBoxObject, getter_AddRefs(sel));
       mView->SetSelection(sel);
     }
 
     // View, meet the tree.
+    nsWeakFrame weakFrame(this);
     mView->SetTree(mTreeBoxObject);
+    NS_ENSURE_STATE(weakFrame.IsAlive());
     mView->GetRowCount(&mRowCount);
  
     PRBool isInReflow;
     PresContext()->PresShell()->IsReflowLocked(&isInReflow);
     if (!isInReflow) {
       // The scrollbar will need to be updated.
       FullScrollbarsUpdate(PR_FALSE);
     } else if (!mReflowCallbackPosted) {
@@ -1163,20 +1165,17 @@ nsTreeBodyFrame::GetCoordsForCellItem(PR
   nsRect theRect;
 
   nsPresContext* presContext = PresContext();
 
   for (nsTreeColumn* currCol = mColumns->GetFirstColumn(); currCol; currCol = currCol->GetNext()) {
 
     // The Rect for the current cell.
     nscoord colWidth;
-#ifdef DEBUG
-    nsresult rv =
-#endif
-      currCol->GetWidthInTwips(this, &colWidth);
+    nsresult rv = currCol->GetWidthInTwips(this, &colWidth);
     NS_ASSERTION(NS_SUCCEEDED(rv), "invalid column");
 
     nsRect cellRect(currX, mInnerBox.y + mRowHeight * (aRow - mTopRowIndex),
                     colWidth, mRowHeight);
 
     // Check the ID of the current column to see if it matches. If it doesn't 
     // increment the current X value and continue to the next column.
     if (currCol != aCol) {
@@ -3697,17 +3696,18 @@ nsTreeBodyFrame::PaintProgressMeter(PRIn
 
     // Set our color.
     aRenderingContext.SetColor(meterContext->GetStyleColor()->mColor);
 
     // Now obtain the value for our cell.
     nsAutoString value;
     mView->GetCellValue(aRowIndex, aColumn, value);
 
-    PRInt32 intValue = value.ToInteger(nsnull);
+    PRInt32 rv;
+    PRInt32 intValue = value.ToInteger(&rv);
     if (intValue < 0)
       intValue = 0;
     else if (intValue > 100)
       intValue = 100;
 
     meterRect.width = NSToCoordRound((float)intValue / 100 * meterRect.width);
     PRBool useImageRegion = PR_TRUE;
     nsCOMPtr<imgIContainer> image;
diff -r b7bcdd009540 modules/lcms/src/cmsxform.c
--- a/modules/lcms/src/cmsxform.c	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/lcms/src/cmsxform.c	Thu Sep 11 15:19:26 2008 +0300
@@ -248,16 +248,32 @@ void NullXFORM(_LPcmsTRANSFORM p,
        register LPBYTE output;
        WORD wIn[MAXCHANNELS];
        register unsigned int i, n;
 
 
        accum  = (LPBYTE) in;
        output = (LPBYTE) out;
        n = Size;                    // Buffer len
+
+       // If the input and output formats are the same,
+       // we don't need to pack and unpack pixels
+       if (p -> InputFormat == p -> OutputFormat) {
+
+              // Only copy bytes if the buffers aren't the same
+              if (in != out) {
+
+                     // Copy in a nondestructive manner in case
+                     // the buffers overlap for some reason
+                     memmove(out, in, 
+                             Size * T_BYTES(p -> InputFormat) * T_CHANNELS(p -> InputFormat));
+              }
+
+              return;
+       }
 
        for (i=0; i < n; i++)
        {
        accum = p -> FromInput(p, wIn, accum);
        output = p -> ToOutput(p, wIn, output);
        }
 
 }
@@ -1518,16 +1534,22 @@ _LPcmsTRANSFORM PickTransformRoutine(_LP
                    if ((*FromTagPtr == 0) && 
                        (*ToTagPtr == 0) && 
                        (!p->PreviewProfile) && 
                        (p -> Intent != INTENT_ABSOLUTE_COLORIMETRIC) && 
                        (p -> EntryColorSpace == icSigRgbData) && 
                        (p -> ExitColorSpace == icSigRgbData)  &&
                        !(p -> dwOriginalFlags & cmsFLAGS_BLACKPOINTCOMPENSATION)) {
 
+                          // If the input profile pointer-matches with the output profile, 
+                          // optimize the transformation away into a null xform
+                          if (p -> InputProfile == p -> OutputProfile) {
+                                 p -> xform = NullXFORM;
+                                 return p;
+                          }
 
                           // If the floating point path is requested, see if we support it
                           if (p -> dwOriginalFlags & cmsFLAGS_FLOATSHAPER)
                           {
 
 #ifndef HAVE_SSE2_INTEL_MNEMONICS 
                                  // Turn it off if we can't compile it
                                  p -> dwOriginalFlags &= ~cmsFLAGS_FLOATSHAPER;
diff -r b7bcdd009540 modules/libjar/test/Makefile.in
--- a/modules/libjar/test/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/libjar/test/Makefile.in	Thu Sep 11 15:19:26 2008 +0300
@@ -42,13 +42,11 @@ VPATH		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 MODULE		= test_libjar
 
 XPCSHELL_TESTS = unit
 
-ifdef MOZ_MOCHITEST
-DIRS		+= mochitest
-endif
+DIRS		= mochitest
 
 include $(topsrcdir)/config/rules.mk
diff -r b7bcdd009540 modules/libpr0n/decoders/bmp/nsBMPDecoder.cpp
--- a/modules/libpr0n/decoders/bmp/nsBMPDecoder.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/libpr0n/decoders/bmp/nsBMPDecoder.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -601,17 +601,19 @@ NS_METHOD nsBMPDecoder::ProcessData(cons
     const PRUint32 rows = mOldLine - mCurLine;
     if (rows) {
         nsIntRect r(0, mBIH.height < 0 ? -mBIH.height - mOldLine : mCurLine,
                     mBIH.width, rows);
 
         // Tell the image that it's data has been updated
         nsCOMPtr<nsIImage> img(do_GetInterface(mFrame, &rv));
         NS_ENSURE_SUCCESS(rv, rv);
-        img->ImageUpdated(nsnull, nsImageUpdateFlags_kBitsChanged, &r);
+        rv = img->ImageUpdated(nsnull, nsImageUpdateFlags_kBitsChanged, &r);        
+        if (NS_FAILED(rv))
+          return rv;
 
         mObserver->OnDataAvailable(nsnull, mFrame, &r);
         mOldLine = mCurLine;
     }
 
     return NS_OK;
 }
 
diff -r b7bcdd009540 modules/libpr0n/decoders/bmp/nsICODecoder.cpp
--- a/modules/libpr0n/decoders/bmp/nsICODecoder.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/libpr0n/decoders/bmp/nsICODecoder.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -105,19 +105,20 @@ NS_IMETHODIMP nsICODecoder::Init(imgILoa
 }
 
 NS_IMETHODIMP nsICODecoder::Close()
 {
   // Tell the image that it's data has been updated 
   // This should be a mFrame function, so that we don't have to query for interface...
   nsIntRect r(0, 0, mDirEntry.mWidth, mDirEntry.mHeight);
   nsCOMPtr<nsIImage> img(do_GetInterface(mFrame));
-  if (img)
-    img->ImageUpdated(nsnull, nsImageUpdateFlags_kBitsChanged, &r);
-
+  nsresult rv = NS_OK;
+  if (img) 
+    rv = img->ImageUpdated(nsnull, nsImageUpdateFlags_kBitsChanged, &r);
+    
   mImage->DecodingComplete();
 
   if (mObserver) {
     mObserver->OnDataAvailable(nsnull, mFrame, &r);
     mObserver->OnStopFrame(nsnull, mFrame);
     mObserver->OnStopContainer(nsnull, mImage);
     mObserver->OnStopDecode(nsnull, NS_OK, nsnull);
     mObserver = nsnull;
@@ -138,17 +139,17 @@ NS_IMETHODIMP nsICODecoder::Close()
   mNumIcons = 0;
 
   if (mRow) {
     free(mRow);
     mRow = nsnull;
   }
   mDecodingAndMask = PR_FALSE;
 
-  return NS_OK;
+  return rv;
 }
 
 NS_IMETHODIMP nsICODecoder::Flush()
 {
   return NS_OK;
 }
 
 
diff -r b7bcdd009540 modules/libpr0n/decoders/gif/nsGIFDecoder2.cpp
--- a/modules/libpr0n/decoders/gif/nsGIFDecoder2.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/libpr0n/decoders/gif/nsGIFDecoder2.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -194,70 +194,77 @@ static NS_METHOD ReadDataOut(nsIInputStr
   }
 
   return NS_OK;
 }
 
 // Push any new rows according to mCurrentPass/mLastFlushedPass and
 // mCurrentRow/mLastFlushedRow.  Note: caller is responsible for
 // updating mlastFlushed{Row,Pass}.
-void
+nsresult
 nsGIFDecoder2::FlushImageData(PRUint32 fromRow, PRUint32 rows)
 {
   nsIntRect r(0, fromRow, mGIFStruct.screen_width, rows);
 
   // Update image  
   nsCOMPtr<nsIImage> img(do_GetInterface(mImageFrame));
-  img->ImageUpdated(nsnull, nsImageUpdateFlags_kBitsChanged, &r);
+  nsresult rv = img->ImageUpdated(nsnull, nsImageUpdateFlags_kBitsChanged, &r);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
 
   // Offset to the frame position
   // Only notify observer(s) for first frame
   if (!mGIFStruct.images_decoded && mObserver) {
     r.y += mGIFStruct.y_offset;
     mObserver->OnDataAvailable(nsnull, mImageFrame, &r);
   }
+  return NS_OK;
 }
 
-void
+nsresult
 nsGIFDecoder2::FlushImageData()
 {
+  nsresult rv = NS_OK;
+
   switch (mCurrentPass - mLastFlushedPass) {
     case 0:  // same pass
       if (mCurrentRow - mLastFlushedRow)
-        FlushImageData(mLastFlushedRow + 1, mCurrentRow - mLastFlushedRow);
+        rv = FlushImageData(mLastFlushedRow + 1, mCurrentRow - mLastFlushedRow);
       break;
   
     case 1:  // one pass on - need to handle bottom & top rects
-      FlushImageData(0, mCurrentRow + 1);
-      FlushImageData(mLastFlushedRow + 1, mGIFStruct.height - (mLastFlushedRow + 1));
+      rv = FlushImageData(0, mCurrentRow + 1);
+      rv |= FlushImageData(mLastFlushedRow + 1, mGIFStruct.height - (mLastFlushedRow + 1));
       break;
 
     default:   // more than one pass on - push the whole frame
-      FlushImageData(0, mGIFStruct.height);
+      rv = FlushImageData(0, mGIFStruct.height);
   }
+  return rv;
 }
 
 //******************************************************************************
 nsresult nsGIFDecoder2::ProcessData(unsigned char *data, PRUint32 count, PRUint32 *_retval)
 {
   // Push the data to the GIF decoder
   
   nsresult rv = GifWrite(data, count);
   NS_ENSURE_SUCCESS(rv, rv);
 
   // Flushing is only needed for first frame
   if (!mGIFStruct.images_decoded && mImageFrame) {
-    FlushImageData();
+    rv = FlushImageData();
     mLastFlushedRow = mCurrentRow;
     mLastFlushedPass = mCurrentPass;
   }
 
   *_retval = count;
 
-  return NS_OK;
+  return rv;
 }
 
 //******************************************************************************
 /* unsigned long writeFrom (in nsIInputStream inStr, in unsigned long count); */
 NS_IMETHODIMP nsGIFDecoder2::WriteFrom(nsIInputStream *inStr, PRUint32 count, PRUint32 *_retval)
 {
   nsresult rv = inStr->ReadSegments(ReadDataOut, this,  count, _retval);
 
@@ -365,17 +372,17 @@ void nsGIFDecoder2::BeginImageFrame(gfx_
 
 
 //******************************************************************************
 void nsGIFDecoder2::EndImageFrame()
 {
   // First flush all pending image data 
   if (!mGIFStruct.images_decoded) {
     // Only need to flush first frame
-    FlushImageData();
+    (void) FlushImageData();
 
     // If the first frame is smaller in height than the entire image, send a
     // OnDataAvailable (Display Refresh) for the area it does not have data for.
     // This will clear the remaining bits of the placeholder. (Bug 37589)
     const PRUint32 realFrameHeight = mGIFStruct.height + mGIFStruct.y_offset;
     if (realFrameHeight < mGIFStruct.screen_height) {
       nsIntRect r(0, realFrameHeight, 
                   mGIFStruct.screen_width, 
diff -r b7bcdd009540 modules/libpr0n/decoders/gif/nsGIFDecoder2.h
--- a/modules/libpr0n/decoders/gif/nsGIFDecoder2.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/libpr0n/decoders/gif/nsGIFDecoder2.h	Thu Sep 11 15:19:26 2008 +0300
@@ -73,18 +73,18 @@ private:
 private:
   /* These functions will be called when the decoder has a decoded row,
    * frame size information, etc. */
 
   void      BeginGIF();
   void      EndGIF();
   void      BeginImageFrame(gfx_depth aDepth);
   void      EndImageFrame();
-  void      FlushImageData();
-  void      FlushImageData(PRUint32 fromRow, PRUint32 rows);
+  nsresult  FlushImageData();
+  nsresult  FlushImageData(PRUint32 fromRow, PRUint32 rows);
 
   nsresult  GifWrite(const PRUint8 * buf, PRUint32 numbytes);
   PRUint32  OutputRow();
   PRBool    DoLzw(const PRUint8 *q);
 
   inline int ClearCode() const { return 1 << mGIFStruct.datasize; }
 
   nsCOMPtr<imgIContainer> mImageContainer;
diff -r b7bcdd009540 modules/libpr0n/decoders/icon/nsIconDecoder.cpp
--- a/modules/libpr0n/decoders/icon/nsIconDecoder.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/libpr0n/decoders/icon/nsIconDecoder.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -138,14 +138,17 @@ NS_IMETHODIMP nsIconDecoder::WriteFrom(n
   // Read the image data direct into the frame data
   rv = inStr->Read((char*)imageData, imageLen, &readLen);
   NS_ENSURE_SUCCESS(rv, rv);
   NS_ENSURE_TRUE(readLen == imageLen, NS_ERROR_UNEXPECTED);
 
   // Notify the image...
   nsIntRect r(0, 0, w, h);
   nsCOMPtr<nsIImage> img(do_GetInterface(mFrame));
-  img->ImageUpdated(nsnull, nsImageUpdateFlags_kBitsChanged, &r);
+  rv = img->ImageUpdated(nsnull, nsImageUpdateFlags_kBitsChanged, &r);
+  if (NS_FAILED(rv))
+    return rv;
+
   mObserver->OnDataAvailable(nsnull, mFrame, &r);
 
   return NS_OK;
 }
 
diff -r b7bcdd009540 modules/libpr0n/decoders/jpeg/nsJPEGDecoder.cpp
--- a/modules/libpr0n/decoders/jpeg/nsJPEGDecoder.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/libpr0n/decoders/jpeg/nsJPEGDecoder.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -560,17 +560,22 @@ nsresult nsJPEGDecoder::ProcessData(cons
   }
 
   case JPEG_DECOMPRESS_SEQUENTIAL:
   {
     if (mState == JPEG_DECOMPRESS_SEQUENTIAL)
     {
       LOG_SCOPE(gJPEGlog, "nsJPEGDecoder::ProcessData -- JPEG_DECOMPRESS_SEQUENTIAL case");
       
-      if (!OutputScanlines()) {
+      PRBool suspend;
+      nsresult rv = OutputScanlines(&suspend);
+      if (NS_FAILED(rv))
+        return rv;
+      
+      if (suspend) {
         PR_LOG(gJPEGDecoderAccountingLog, PR_LOG_DEBUG,
                ("} (I/O suspension after OutputScanlines() - SEQUENTIAL)"));
         return NS_OK; /* I/O suspension */
       }
       
       /* If we've completed image output ... */
       NS_ASSERTION(mInfo.output_scanline == mInfo.output_height, "We didn't process all of the data!");
       mState = JPEG_DONE;
@@ -606,17 +611,22 @@ nsresult nsJPEGDecoder::ProcessData(cons
                    ("} (I/O suspension after jpeg_start_output() - PROGRESSIVE)"));
             return NS_OK; /* I/O suspension */
           }
         }
 
         if (mInfo.output_scanline == 0xffffff)
           mInfo.output_scanline = 0;
 
-        if (!OutputScanlines()) {
+        PRBool suspend;
+        nsresult rv = OutputScanlines(&suspend);
+        if (NS_FAILED(rv))
+          return rv;
+
+        if (suspend) {
           if (mInfo.output_scanline == 0) {
             /* didn't manage to read any lines - flag so we don't call
                jpeg_start_output() multiple times for the same scan */
             mInfo.output_scanline = 0xffffff;
           }
           PR_LOG(gJPEGDecoderAccountingLog, PR_LOG_DEBUG,
                  ("} (I/O suspension after OutputScanlines() - PROGRESSIVE)"));
           return NS_OK; /* I/O suspension */
@@ -683,52 +693,54 @@ nsresult nsJPEGDecoder::ProcessData(cons
   }
 
   PR_LOG(gJPEGDecoderAccountingLog, PR_LOG_DEBUG,
          ("} (end of function)"));
   return NS_OK;
 }
 
 
-PRBool
-nsJPEGDecoder::OutputScanlines()
+nsresult
+nsJPEGDecoder::OutputScanlines(PRBool* suspend)
 {
+  *suspend = PR_FALSE;
+
   const PRUint32 top = mInfo.output_scanline;
-  PRBool rv = PR_TRUE;
+  nsresult rv = NS_OK;
 
   mFrame->LockImageData();
   
   // we're thebes. we can write stuff directly to the data
   PRUint8 *imageData;
   PRUint32 imageDataLength;
   mFrame->GetImageData(&imageData, &imageDataLength);
 
   while ((mInfo.output_scanline < mInfo.output_height)) {
       /* Use the Cairo image buffer as scanline buffer */
       PRUint32 *imageRow = ((PRUint32*)imageData) +
                            (mInfo.output_scanline * mInfo.output_width);
 
       if (mInfo.cconvert->color_convert == ycc_rgb_convert_argb) {
         /* Special case: scanline will be directly converted into packed ARGB */
         if (jpeg_read_scanlines(&mInfo, (JSAMPARRAY)&imageRow, 1) != 1) {
-          rv = PR_FALSE; /* suspend */
+          *suspend = PR_TRUE; /* suspend */
           break;
         }
         continue; /* all done for this row! */
       }
 
       JSAMPROW sampleRow = (JSAMPROW)imageRow;
       if (mInfo.output_components == 3) {
         /* Put the pixels at end of row to enable in-place expansion */
         sampleRow += mInfo.output_width;
       }
 
       /* Request one scanline.  Returns 0 or 1 scanlines. */    
       if (jpeg_read_scanlines(&mInfo, &sampleRow, 1) != 1) {
-        rv = PR_FALSE; /* suspend */
+        *suspend = PR_TRUE; /* suspend */
         break;
       }
 
       if (mTransform) {
         JSAMPROW source = sampleRow;
         if (mInfo.out_color_space == JCS_GRAYSCALE) {
           /* Convert from the 1byte grey pixels at begin of row 
              to the 3byte RGB byte pixels at 'end' of row */
@@ -782,17 +794,17 @@ nsJPEGDecoder::OutputScanlines()
         *imageRow++ = GFX_PACKED_PIXEL(0xFF, sampleRow[0], sampleRow[1], sampleRow[2]);
         sampleRow += 3;
       }
   }
 
   if (top != mInfo.output_scanline) {
       nsIntRect r(0, top, mInfo.output_width, mInfo.output_scanline-top);
       nsCOMPtr<nsIImage> img(do_GetInterface(mFrame));
-      img->ImageUpdated(nsnull, nsImageUpdateFlags_kBitsChanged, &r);
+      rv = img->ImageUpdated(nsnull, nsImageUpdateFlags_kBitsChanged, &r);
       mObserver->OnDataAvailable(nsnull, mFrame, &r);
   }
   
   mFrame->UnlockImageData();
   
   return rv;
 }
 
diff -r b7bcdd009540 modules/libpr0n/decoders/jpeg/nsJPEGDecoder.h
--- a/modules/libpr0n/decoders/jpeg/nsJPEGDecoder.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/libpr0n/decoders/jpeg/nsJPEGDecoder.h	Thu Sep 11 15:19:26 2008 +0300
@@ -89,17 +89,17 @@ public:
   NS_DECL_IMGIDECODER
 
   nsJPEGDecoder();
   virtual ~nsJPEGDecoder();
 
   nsresult  ProcessData(const char *data, PRUint32 count, PRUint32 *writeCount);
 
 protected:
-  PRBool OutputScanlines();
+  nsresult OutputScanlines(PRBool* suspend);
 
 public:
   nsCOMPtr<imgIContainer> mImage;
   nsCOMPtr<imgILoad> mImageLoad;
   nsCOMPtr<gfxIImageFrame> mFrame;
 
   nsCOMPtr<imgIDecoderObserver> mObserver;
 
diff -r b7bcdd009540 modules/libpr0n/decoders/png/nsPNGDecoder.cpp
--- a/modules/libpr0n/decoders/png/nsPNGDecoder.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/libpr0n/decoders/png/nsPNGDecoder.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -184,17 +184,20 @@ void nsPNGDecoder::EndImageFrame()
   if (numFrames > 1) {
     // Tell the image renderer that the frame is complete
     PRInt32 width, height;
     mFrame->GetWidth(&width);
     mFrame->GetHeight(&height);
 
     nsIntRect r(0, 0, width, height);
     nsCOMPtr<nsIImage> img(do_GetInterface(mFrame));
-    img->ImageUpdated(nsnull, nsImageUpdateFlags_kBitsChanged, &r);
+    if (NS_FAILED(img->ImageUpdated(nsnull, nsImageUpdateFlags_kBitsChanged, &r))) {
+      mError = PR_TRUE;
+      // allow the call out to the observers.
+    }
     mObserver->OnDataAvailable(nsnull, mFrame, &r);
   }
 
   mImage->EndFrameDecode(numFrames, timeout);
   if (mObserver)
     mObserver->OnStopFrame(nsnull, mFrame);
 }
 
@@ -811,17 +814,20 @@ row_callback(png_structp png_ptr, png_by
       decoder->mFrameHasNoAlpha = PR_FALSE;
 
     PRUint32 numFrames = 0;
     decoder->mImage->GetNumFrames(&numFrames);
     if (numFrames <= 1) {
       // Only do incremental image display for the first frame
       nsIntRect r(0, row_num, width, 1);
       nsCOMPtr<nsIImage> img(do_GetInterface(decoder->mFrame));
-      img->ImageUpdated(nsnull, nsImageUpdateFlags_kBitsChanged, &r);
+      if (NS_FAILED(img->ImageUpdated(nsnull, nsImageUpdateFlags_kBitsChanged, &r))) {
+        decoder->mError = PR_TRUE;  /* bail */
+        return;
+      }
       decoder->mObserver->OnDataAvailable(nsnull, decoder->mFrame, &r);
     }
   }
 }
 
 // got the header of a new frame that's coming
 void
 frame_info_callback(png_structp png_ptr, png_uint_32 frame_num)
diff -r b7bcdd009540 modules/libpr0n/decoders/xbm/nsXBMDecoder.cpp
--- a/modules/libpr0n/decoders/xbm/nsXBMDecoder.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/libpr0n/decoders/xbm/nsXBMDecoder.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -274,17 +274,21 @@ nsresult nsXBMDecoder::ProcessData(const
             numPixels = PR_MIN(numPixels, mWidth - mCurCol);
             for (PRUint32 i = numPixels; i > 0; --i) {
                 *ar++ = kColors[pixel & 1];
                 pixel >>= 1;
             }
             mCurCol += numPixels;
             if (mCurCol == mWidth || mState == RECV_DONE) {
                 nsIntRect r(0, mCurRow, mWidth, 1);
-                img->ImageUpdated(nsnull, nsImageUpdateFlags_kBitsChanged, &r);
+                nsresult rv = img->ImageUpdated(nsnull, nsImageUpdateFlags_kBitsChanged, &r);
+                if (NS_FAILED(rv)) {
+                  return rv;
+                }
+
                 mObserver->OnDataAvailable(nsnull, mFrame, &r);
 
                 mCurRow++;
                 if (mCurRow == mHeight) {
                     mState = RECV_DONE;
                     return mObserver->OnStopFrame(nsnull, mFrame);
                 }
                 mCurCol = 0;
diff -r b7bcdd009540 modules/libpr0n/src/imgContainer.cpp
--- a/modules/libpr0n/src/imgContainer.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/libpr0n/src/imgContainer.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -940,17 +940,20 @@ nsresult imgContainer::DoComposite(gfxII
   PRInt32 timeout;
   aNextFrame->GetTimeout(&timeout);
   mAnim->compositingFrame->SetTimeout(timeout);
 
   // Tell the image that it is fully 'downloaded'.
   nsIntRect r;
   mAnim->compositingFrame->GetRect(r);
   nsCOMPtr<nsIImage> img = do_GetInterface(mAnim->compositingFrame);
-  img->ImageUpdated(nsnull, nsImageUpdateFlags_kBitsChanged, &r);
+  nsresult rv = img->ImageUpdated(nsnull, nsImageUpdateFlags_kBitsChanged, &r);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
 
   // We don't want to keep composite images for 8bit frames...
   if (isFullNextFrame && mAnimationMode == kNormalAnimMode && mLoopCount != 0 &&
       nextFormat != gfxIFormats::PAL && nextFormat != gfxIFormats::PAL_A1) {
     // We have a composited full frame
     // Store the composited frame into the mFrames[..] so we don't have to
     // continuously re-build it
     // Then set the previous frame's disposal to CLEAR_ALL so we just draw the
diff -r b7bcdd009540 modules/libpr0n/src/imgLoader.cpp
--- a/modules/libpr0n/src/imgLoader.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/libpr0n/src/imgLoader.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -285,16 +285,17 @@ void imgCacheQueue::UpdateSize(PRInt32 d
 }
 
 PRUint32 imgCacheQueue::GetSize() const
 {
   return mSize;
 }
 
 #include <algorithm>
+using namespace std;
 
 void imgCacheQueue::Remove(imgCacheEntry *entry)
 {
   queueContainer::iterator it = find(mQueue.begin(), mQueue.end(), entry);
   if (it != mQueue.end()) {
     mSize -= (*it)->GetDataSize();
     mQueue.erase(it);
     MarkDirty();
diff -r b7bcdd009540 modules/libpr0n/test/Makefile.in
--- a/modules/libpr0n/test/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/libpr0n/test/Makefile.in	Thu Sep 11 15:19:26 2008 +0300
@@ -43,17 +43,15 @@ relativesrcdir  = modules/libpr0n/test
 
 include $(DEPTH)/config/autoconf.mk
 
 # Module name for xpcshell tests.
 MODULE		= test_libpr0n
 
 XPCSHELL_TESTS  = unit
 
-#ifdef MOZ_MOCHITEST
 DIRS            += mochitest
-#endif
 
 include $(topsrcdir)/config/rules.mk
 
 # Note: Invoke any additional (non-xpcshell) test programs here.
 check::
 
diff -r b7bcdd009540 modules/libpref/src/init/all.js
--- a/modules/libpref/src/init/all.js	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/libpref/src/init/all.js	Thu Sep 11 15:19:26 2008 +0300
@@ -191,16 +191,21 @@ pref("toolkit.autocomplete.richBoundaryC
 
 pref("toolkit.scrollbox.smoothScroll", true);
 pref("toolkit.scrollbox.scrollIncrement", 20);
 pref("toolkit.scrollbox.clickToScroll.scrollDelay", 150);
 
 // view source
 pref("view_source.syntax_highlight", true);
 pref("view_source.wrap_long_lines", false);
+pref("view_source.editor.external", false);
+pref("view_source.editor.path", "");
+// allows to add further arguments to the editor; use the %LINE% placeholder
+// for jumping to a specific line (e.g. "/line:%LINE%" or "--goto %LINE%")
+pref("view_source.editor.args", "");
 
 // dispatch left clicks only to content in browser (still allows clicks to chrome/xul)
 pref("nglayout.events.dispatchLeftClickOnly", true);
 
 // whether or not to draw images while dragging
 pref("nglayout.enable_drag_images", true);
 
 // whether or not to use xbl form controls
@@ -778,21 +783,16 @@ pref("network.automatic-ntlm-auth.truste
 
 // This preference controls whether or not the LM hash will be included in
 // response to a NTLM challenge.  By default, this is disabled since servers
 // should almost never need the LM hash, and the LM hash is what makes NTLM
 // authentication less secure.  See bug 250691 for further details.
 // NOTE: automatic-ntlm-auth which leverages the OS-provided NTLM
 //       implementation will not be affected by this preference.
 pref("network.ntlm.send-lm-response", false);
-
-// sspitzer:  change this back to "news" when we get to beta.
-// for now, set this to news.mozilla.org because you can only
-// post to the server specified by this pref.
-pref("network.hosts.nntp_server",           "news.mozilla.org");
 
 pref("permissions.default.image",           1); // 1-Accept, 2-Deny, 3-dontAcceptForeign
 
 #ifndef XP_MACOSX
 #ifdef XP_UNIX
 pref("network.proxy.type",                  5);
 #else
 pref("network.proxy.type",                  0);
@@ -1510,16 +1510,19 @@ pref("advanced.system.supportDDEExec", t
 pref("advanced.system.supportDDEExec", true);
 
 // Use CP932 compatible map for JIS X 0208
 pref("intl.jis0208.map", "CP932");
 
 // Switch the keyboard layout per window
 pref("intl.keyboard.per_window_layout", false);
 
+// See bug 448927, on topmost panel, some IMEs are not usable on Windows.
+pref("ui.panel.default_level_parent", false);
+
 # WINNT
 #endif
 
 #ifdef XP_MACOSX
 // Mac specific preference defaults
 pref("browser.drag_out_of_frame_style", 1);
 pref("ui.key.saveLink.shift", false); // true = shift, false = meta
 pref("ui.click_hold_context_menus", false);
@@ -1927,16 +1930,19 @@ pref("ui.key.contentAccess", 2);
 
 // print_extra_margin enables platforms to specify an extra gap or margin
 // around the content of the page for Print Preview only
 pref("print.print_extra_margin", 90); // twips (90 twips is an eigth of an inch)
 
 // This indicates whether it should use the native dialog or the XP Dialog
 pref("print.use_native_print_dialog", true);
 
+// See bug 404131, topmost <panel> element wins to Dashboard on MacOSX.
+pref("ui.panel.default_level_parent", false);
+
 # XP_MACOSX
 #endif
 
 #ifdef XP_OS2
 
 pref("ui.key.menuAccessKeyFocuses", true);
 pref("layout.css.dpi", -1); // max(96dpi, System setting)
 
@@ -2124,16 +2130,21 @@ pref("mail.compose.max_recycled_windows"
 
 // Use IBM943 compatible map for JIS X 0208
 pref("intl.jis0208.map", "IBM943");
 
 // Disable IPv6 name lookups by default.
 // This is because OS/2 doesn't support IPv6
 pref("network.dns.disableIPv6", true);
 
+// IMEs of OS/2 might use non-topmost windows for topmost <panel> element,
+// see bug 451015. If there are other problems by this value, we may need to
+// change this value.
+pref("ui.panel.default_level_parent", false);
+
 # OS2
 #endif
 
 #ifdef XP_BEOS
 
 pref("layout.css.dpi", -1); // max(96dpi, System setting)
 
 pref("intl.font_charset", "");
@@ -2214,16 +2225,21 @@ pref("ui.key.generalAccessKey", -1);
 // If generalAccessKey is -1, use the following two prefs instead.
 // Use 0 for disabled, 1 for Shift, 2 for Ctrl, 4 for Alt, 8 for Meta
 // (values can be combined, e.g. 3 for Ctrl+Shift)
 pref("ui.key.chromeAccess", 2);
 pref("ui.key.contentAccess", 3);
 
 // xxx toolkit?
 pref("browser.download.dir", "/boot/home/Downloads");
+
+// IMEs of BeOS might use non-topmost windows for topmost <panel> element,
+// see bug 451015. If there are other problems by this value, we may need to
+// change this value.
+pref("ui.panel.default_level_parent", false);
 
 # BeOS
 #endif
 
 #ifndef XP_MACOSX
 #ifdef XP_UNIX
 // Handled differently under Mac/Windows
 pref("network.hosts.smtp_server", "localhost");
@@ -2477,16 +2493,27 @@ pref("font.size.fixed.x-sinh", 13);
 pref("font.size.fixed.x-sinh", 13);
 
 /* PostScript print module prefs */
 // pref("print.postscript.enabled",      true);
 pref("print.postscript.paper_size",    "letter");
 pref("print.postscript.orientation",   "portrait");
 pref("print.postscript.print_command", "lpr ${MOZ_PRINTER_NAME:+-P\"$MOZ_PRINTER_NAME\"}");
 
+// On GTK2 platform, we should use topmost window level for the default window
+// level of <panel> element of XUL. GTK2 has only two window types. One is
+// normal top level window, other is popup window. The popup window is always
+// topmost window level, therefore, we are using normal top level window for
+// non-topmost panel, but it is pretty hacky. On some Window Managers, we have
+// 2 problems:
+// 1. The non-topmost panel steals focus from its parent window at showing.
+// 2. The parent of non-topmost panel is not activated when the panel is hidden.
+// So, we have no reasons we should use non-toplevel window for popup.
+pref("ui.panel.default_level_parent", true);
+
 # XP_UNIX
 #endif
 #endif
 
 #if MOZ_WIDGET_TOOLKIT==photon
 
 // font names
 pref("font.name.serif.x-western", "serif");
diff -r b7bcdd009540 modules/plugin/Makefile.in
--- a/modules/plugin/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/plugin/Makefile.in	Thu Sep 11 15:19:26 2008 +0300
@@ -77,16 +77,17 @@ ifeq ($(MOZ_WIDGET_TOOLKIT),cocoa)
 ifeq ($(MOZ_WIDGET_TOOLKIT),cocoa)
 TOOL_DIRS += default/mac
 endif
 
 ifdef ENABLE_TESTS
 ifneq (,$(filter WINNT Darwin Linux,$(OS_ARCH)))
 TOOL_DIRS += sdk
 endif
+DIRS += test
 endif
 
 endif # MOZ_PLUGINS
 
 include $(topsrcdir)/config/rules.mk
 
 ifdef MOZ_PLUGINS
 $(DIST)/bin/plugins:
diff -r b7bcdd009540 modules/plugin/base/public/npapi.h
--- a/modules/plugin/base/public/npapi.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/plugin/base/public/npapi.h	Thu Sep 11 15:19:26 2008 +0300
@@ -30,94 +30,70 @@
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
-
 /*
  *  npapi.h $Revision: 3.48 $
  *  Netscape client plug-in API spec
  */
 
 #ifndef _NPAPI_H_
 #define _NPAPI_H_
 
 #ifdef __OS2__
 #pragma pack(1)
 #endif
 
-#include "prtypes.h"
-/* Copied from xp_core.h */
-/* removed #ifdef for hpux defined in /usr/include/model.h */
-#ifndef _INT16
-#define _INT16
-#endif
-#ifndef _INT32
-#define _INT32
-#endif
-#ifndef _UINT16
-#define _UINT16
-#endif
-#ifndef _UINT32
-#define _UINT32
-#endif
+#include "nptypes.h"
 
-/* 
- * NO_NSPR_10_SUPPORT disables the inclusion 
- * of obsolete/protypes.h, whose int16, uint16, 
- * int32, and uint32 typedefs conflict with those 
- * in this file. 
- */ 
-#ifndef NO_NSPR_10_SUPPORT
-#define NO_NSPR_10_SUPPORT
-#endif
 #ifdef OJI
 #include "jri.h"                /* Java Runtime Interface */
 #endif
 
-#if defined (__OS2__ ) || defined (OS2)
-#	ifndef XP_OS2
-#		define XP_OS2 1
-#	endif /* XP_OS2 */
+#if defined (__OS2__) || defined (OS2)
+# ifndef XP_OS2
+#  define XP_OS2 1
+# endif /* XP_OS2 */
 #endif /* __OS2__ */
 
 #ifdef _WINDOWS
-#	include <windef.h>
-#	ifndef XP_WIN
-#		define XP_WIN 1
-#	endif /* XP_WIN */
+# include <windef.h>
+# ifndef XP_WIN
+#  define XP_WIN 1
+# endif /* XP_WIN */
 #endif /* _WINDOWS */
 
 #ifdef __MWERKS__
-#	define _declspec __declspec
-#	ifdef __INTEL__
-#		undef NULL
-#		ifndef XP_WIN
-#			define XP_WIN 1
-#		endif /* XP_WIN */
-#	endif /* __INTEL__ */
+# define _declspec __declspec
+# ifdef __INTEL__
+#  undef NULL
+#  ifndef XP_WIN
+#   define XP_WIN 1
+#  endif /* XP_WIN */
+# endif /* __INTEL__ */
 #endif /* __MWERKS__ */
 
 #ifdef XP_MACOSX
 #include <Carbon/Carbon.h>
 #ifdef __LP64__
 #define NP_NO_QUICKDRAW
 #endif
 #endif
 
 #if defined(XP_UNIX) 
-#	include <stdio.h>
-#	if defined(MOZ_X11)
-#		include <X11/Xlib.h>
-#		include <X11/Xutil.h>
-#	endif
+# include <stdio.h>
+# if defined(MOZ_X11)
+#  include <X11/Xlib.h>
+#  include <X11/Xutil.h>
+# endif
 #endif
 
 /*----------------------------------------------------------------------*/
 /*                        Plugin Version Constants                      */
 /*----------------------------------------------------------------------*/
 
 #define NP_VERSION_MAJOR 0
 #define NP_VERSION_MINOR 20
@@ -142,17 +118,16 @@ RCDATA NP_INFO_FileOpenName{ "MMOS2 vide
 
 RCDATA NP_INFO_FileVersion       { 1,0,0,1 }
 RCDATA NP_INFO_CompanyName       { "Netscape Communications\0" }
 RCDATA NP_INFO_FileDescription   { "NPAVI32 Extension DLL\0"
 RCDATA NP_INFO_InternalName      { "NPAVI32\0" )
 RCDATA NP_INFO_LegalCopyright    { "Copyright Netscape Communications \251 1996\0"
 RCDATA NP_INFO_OriginalFilename  { "NVAPI32.DLL" }
 RCDATA NP_INFO_ProductName       { "NPAVI32 Dynamic Link Library\0" }
-
 */
 
 
 /* RC_DATA types for version info - required */
 #define NP_INFO_ProductVersion      1
 #define NP_INFO_MIMEType            2
 #define NP_INFO_FileOpenName        3
 #define NP_INFO_FileExtents         4
@@ -165,141 +140,85 @@ RCDATA NP_INFO_ProductName       { "NPAV
 #define NP_INFO_CompanyName         7
 #define NP_INFO_FileVersion         8
 #define NP_INFO_InternalName        9
 #define NP_INFO_LegalCopyright      10
 #define NP_INFO_OriginalFilename    11
 
 #ifndef RC_INVOKED
 
-
-
 /*----------------------------------------------------------------------*/
 /*                       Definition of Basic Types                      */
 /*----------------------------------------------------------------------*/
 
-#ifndef _UINT16
-typedef unsigned short uint16;
-#endif
-
-#ifndef _UINT32
-#    if defined(__alpha) || defined(__amd64__) || defined(__x86_64__) || defined(__LP64__)
-typedef unsigned int uint32;
-#    else  /* __alpha */
-typedef unsigned long uint32;
-#    endif /* __alpha */
-#endif
-
-/*
- * AIX defines these in sys/inttypes.h included from sys/types.h
- */
-#ifndef AIX
-#ifndef _INT16
-typedef short int16;
-#endif
-
-#ifndef _INT32
-#    if defined(__alpha) || defined(__amd64__) || defined(__x86_64__) || defined(__LP64__)
-typedef int int32;
-#    else  /* __alpha */
-typedef long int32;
-#    endif /* __alpha */
-#endif
-#endif
-
-#ifndef FALSE
-#define FALSE (0)
-#endif
-#ifndef TRUE
-#define TRUE (1)
-#endif
-#ifndef NULL
-#define NULL (0L)
-#endif
-
-#ifdef XP_MACOSX
-typedef enum {
-#ifndef NP_NO_QUICKDRAW
-  NPDrawingModelQuickDraw = 0,
-#endif
-  NPDrawingModelCoreGraphics = 1
-} NPDrawingModel;
-#endif
-
-typedef unsigned char	NPBool;
-typedef int16			NPError;
-typedef int16			NPReason;
-typedef char*			NPMIMEType;
-
-
+typedef unsigned char NPBool;
+typedef int16_t       NPError;
+typedef int16_t       NPReason;
+typedef char*         NPMIMEType;
 
 /*----------------------------------------------------------------------*/
 /*                       Structures and definitions                     */
 /*----------------------------------------------------------------------*/
 
 /*
  *  NPP is a plug-in's opaque instance handle
  */
 typedef struct _NPP
 {
-  void*	pdata;      /* plug-in private data */
-  void*	ndata;      /* netscape private data */
+  void* pdata;      /* plug-in private data */
+  void* ndata;      /* netscape private data */
 } NPP_t;
 
 typedef NPP_t*  NPP;
 
-
 typedef struct _NPStream
 {
-  void*  pdata; /* plug-in private data */
-  void*  ndata; /* netscape private data */
-  const  char* url;
-  uint32 end;
-  uint32 lastmodified;
-  void*  notifyData;
-  const  char* headers; /* Response headers from host.
-                         * Exists only for >= NPVERS_HAS_RESPONSE_HEADERS.
-                         * Used for HTTP only; NULL for non-HTTP.
-                         * Available from NPP_NewStream onwards.
-                         * Plugin should copy this data before storing it.
-                         * Includes HTTP status line and all headers,
-                         * preferably verbatim as received from server,
-                         * headers formatted as in HTTP ("Header: Value"),
-                         * and newlines (\n, NOT \r\n) separating lines.
-                         * Terminated by \n\0 (NOT \n\n\0). */
+  void*    pdata; /* plug-in private data */
+  void*    ndata; /* netscape private data */
+  const    char* url;
+  uint32_t end;
+  uint32_t lastmodified;
+  void*    notifyData;
+  const    char* headers; /* Response headers from host.
+                           * Exists only for >= NPVERS_HAS_RESPONSE_HEADERS.
+                           * Used for HTTP only; NULL for non-HTTP.
+                           * Available from NPP_NewStream onwards.
+                           * Plugin should copy this data before storing it.
+                           * Includes HTTP status line and all headers,
+                           * preferably verbatim as received from server,
+                           * headers formatted as in HTTP ("Header: Value"),
+                           * and newlines (\n, NOT \r\n) separating lines.
+                           * Terminated by \n\0 (NOT \n\n\0). */
 } NPStream;
-
 
 typedef struct _NPByteRange
 {
-  int32  offset; /* negative offset means from the end */
-  uint32 length;
+  int32_t  offset; /* negative offset means from the end */
+  uint32_t length;
   struct _NPByteRange* next;
 } NPByteRange;
 
-
 typedef struct _NPSavedData
 {
-  int32	len;
-  void*	buf;
+  int32_t len;
+  void*   buf;
 } NPSavedData;
-
 
 typedef struct _NPRect
 {
-  uint16 top;
-  uint16 left;
-  uint16 bottom;
-  uint16 right;
+  uint16_t top;
+  uint16_t left;
+  uint16_t bottom;
+  uint16_t right;
 } NPRect;
 
 typedef struct _NPSize 
 { 
-  int32 width; 
-  int32 height; 
+  int32_t width; 
+  int32_t height; 
 } NPSize; 
 
 #ifdef XP_UNIX
 /*
  * Unix specific structures and definitions
  */
 
 /*
@@ -309,38 +228,46 @@ typedef struct _NPSize
  */
 enum {
   NP_SETWINDOW = 1,
   NP_PRINT
 };
 
 typedef struct
 {
-  int32 type;
+  int32_t type;
 } NPAnyCallbackStruct;
 
 typedef struct
 {
-  int32        type;
+  int32_t      type;
 #ifdef MOZ_X11
   Display*     display;
   Visual*      visual;
   Colormap     colormap;
   unsigned int depth;
 #endif
 } NPSetWindowCallbackStruct;
 
 typedef struct
 {
-  int32 type;
+  int32_t type;
   FILE* fp;
 } NPPrintCallbackStruct;
 
 #endif /* XP_UNIX */
 
+#ifdef XP_MACOSX
+typedef enum {
+#ifndef NP_NO_QUICKDRAW
+  NPDrawingModelQuickDraw = 0,
+#endif
+  NPDrawingModelCoreGraphics = 1
+} NPDrawingModel;
+#endif
 
 /*
  *   The following masks are applied on certain platforms to NPNV and 
  *   NPPV selectors that pass around pointers to COM interfaces. Newer 
  *   compilers on some platforms may generate vtables that are not 
  *   compatible with older compilers. To prevent older plugins from 
  *   not understanding a new browser's ABI, these masks change the 
  *   values of those selectors on those platforms. To remain backwards
@@ -356,31 +283,29 @@ typedef struct
  *   previous compilers.
  */
 #if (defined (XP_UNIX) && defined(__GNUC__) && (__GNUC__ >= 3))
 #define _NP_ABI_MIXIN_FOR_GCC3 NP_ABI_GCC3_MASK
 #else
 #define _NP_ABI_MIXIN_FOR_GCC3 0
 #endif
 
-
 #define NP_ABI_MACHO_MASK 0x01000000
 /*
  *   On OSX, the Mach-O executable format is significantly
  *   different than CFM. In addition to having a different
  *   C++ ABI, it also has has different C calling convention.
  *   You must use glue code when calling between CFM and
  *   Mach-O C functions. 
  */
 #if (defined(TARGET_RT_MAC_MACHO))
 #define _NP_ABI_MIXIN_FOR_MACHO NP_ABI_MACHO_MASK
 #else
 #define _NP_ABI_MIXIN_FOR_MACHO 0
 #endif
-
 
 #define NP_ABI_MASK (_NP_ABI_MIXIN_FOR_GCC3 | _NP_ABI_MIXIN_FOR_MACHO)
 
 /*
  * List of variable names for which NPP_GetValue shall be implemented
  */
 typedef enum {
   NPPVpluginNameString = 1,
@@ -476,74 +401,74 @@ typedef enum {
 typedef enum {
   NPWindowTypeWindow = 1,
   NPWindowTypeDrawable
 } NPWindowType;
 
 typedef struct _NPWindow
 {
   void* window;  /* Platform specific window handle */
-                 /* OS/2: x - Position of bottom left corner  */
+                 /* OS/2: x - Position of bottom left corner */
                  /* OS/2: y - relative to visible netscape window */
-  int32 x;       /* Position of top left corner relative */
-  int32 y;       /* to a netscape page.					*/
-  uint32 width;  /* Maximum window size */
-  uint32 height;
-  NPRect clipRect; /* Clipping rectangle in port coordinates */
-                   /* Used by MAC only.			  */
+  int32_t  x;      /* Position of top left corner relative */
+  int32_t  y;      /* to a netscape page. */
+  uint32_t width;  /* Maximum window size */
+  uint32_t height;
+  NPRect   clipRect; /* Clipping rectangle in port coordinates */
+                     /* Used by MAC only. */
 #if defined(XP_UNIX) && !defined(XP_MACOSX)
   void * ws_info; /* Platform-dependent additonal data */
 #endif /* XP_UNIX */
   NPWindowType type; /* Is this a window or a drawable? */
 } NPWindow;
 
 
 typedef struct _NPFullPrint
 {
   NPBool pluginPrinted;/* Set TRUE if plugin handled fullscreen printing */
-  NPBool printOne;		 /* TRUE if plugin should print one copy to default printer */
+  NPBool printOne;     /* TRUE if plugin should print one copy to default printer */
   void* platformPrint; /* Platform-specific printing info */
 } NPFullPrint;
 
 typedef struct _NPEmbedPrint
 {
   NPWindow window;
   void* platformPrint; /* Platform-specific printing info */
 } NPEmbedPrint;
 
 typedef struct _NPPrint
 {
-  uint16 mode;               /* NP_FULL or NP_EMBED */
+  uint16_t mode;               /* NP_FULL or NP_EMBED */
   union
   {
     NPFullPrint fullPrint;   /* if mode is NP_FULL */
     NPEmbedPrint embedPrint; /* if mode is NP_EMBED */
   } print;
 } NPPrint;
 
 #ifdef XP_MACOSX
-typedef EventRecord	NPEvent;
+typedef EventRecord NPEvent;
 #elif defined(XP_WIN)
 typedef struct _NPEvent
 {
-  uint16 event;
-  uint32 wParam;
-  uint32 lParam;
+  uint16_t event;
+  uint32_t wParam;
+  uint32_t lParam;
 } NPEvent;
 #elif defined(XP_OS2)
 typedef struct _NPEvent
 {
-  uint32 event;
-  uint32 wParam;
-  uint32 lParam;
+  uint32_t event;
+  uint32_t wParam;
+  uint32_t lParam;
 } NPEvent;
 #elif defined (XP_UNIX) && defined(MOZ_X11)
 typedef XEvent NPEvent;
 #else
-typedef void*			NPEvent;
+typedef void*  NPEvent;
 #endif /* XP_MACOSX */
 
 #ifdef XP_MACOSX
 typedef void* NPRegion;
 #ifndef NP_NO_QUICKDRAW
 typedef RgnHandle NPQDRegion;
 #endif
 typedef CGPathRef NPCGRegion;
@@ -558,18 +483,18 @@ typedef void *NPRegion;
 #ifdef XP_MACOSX
 /*
  *  Mac-specific structures and definitions.
  */
 
 typedef struct NP_Port
 {
   CGrafPtr port; /* Grafport */
-  int32 portx;   /* position inside the topmost window */
-  int32 porty;
+  int32_t portx;   /* position inside the topmost window */
+  int32_t porty;
 } NP_Port;
 
 typedef struct NP_CGContext
 {
   CGContextRef context;
   WindowRef window;
 } NP_CGContext;
 
@@ -603,21 +528,21 @@ enum NPEventType {
 /*
  * Values for stream type passed to NPP_NewStream:
  */
 #define NP_NORMAL     1
 #define NP_SEEK       2
 #define NP_ASFILE     3
 #define NP_ASFILEONLY 4
 
-#define NP_MAXREADY	(((unsigned)(~0)<<1)>>1)
+#define NP_MAXREADY (((unsigned)(~0)<<1)>>1)
 
 
 /*----------------------------------------------------------------------*/
-/*		     Error and Reason Code definitions			*/
+/*       Error and Reason Code definitions                              */
 /*----------------------------------------------------------------------*/
 
 /*
  * Values of type NPError:
  */
 #define NPERR_BASE                         0
 #define NPERR_NO_ERROR                    (NPERR_BASE + 0)
 #define NPERR_GENERIC_ERROR               (NPERR_BASE + 1)
@@ -691,32 +616,32 @@ extern "C" {
 
 #ifdef XP_UNIX
 char* NPP_GetMIMEDescription(void);
 #endif /* XP_UNIX */
 
 NPError NP_LOADDS NPP_Initialize(void);
 void    NP_LOADDS NPP_Shutdown(void);
 NPError NP_LOADDS NPP_New(NPMIMEType pluginType, NPP instance,
-                          uint16 mode, int16 argc, char* argn[],
+                          uint16_t mode, int16_t argc, char* argn[],
                           char* argv[], NPSavedData* saved);
 NPError NP_LOADDS NPP_Destroy(NPP instance, NPSavedData** save);
 NPError NP_LOADDS NPP_SetWindow(NPP instance, NPWindow* window);
 NPError NP_LOADDS NPP_NewStream(NPP instance, NPMIMEType type,
                                 NPStream* stream, NPBool seekable,
-                                uint16* stype);
+                                uint16_t* stype);
 NPError NP_LOADDS NPP_DestroyStream(NPP instance, NPStream* stream,
                                     NPReason reason);
-int32   NP_LOADDS NPP_WriteReady(NPP instance, NPStream* stream);
-int32   NP_LOADDS NPP_Write(NPP instance, NPStream* stream, int32 offset,
-                            int32 len, void* buffer);
+int32_t NP_LOADDS NPP_WriteReady(NPP instance, NPStream* stream);
+int32_t NP_LOADDS NPP_Write(NPP instance, NPStream* stream, int32_t offset,
+                            int32_t len, void* buffer);
 void    NP_LOADDS NPP_StreamAsFile(NPP instance, NPStream* stream,
                                    const char* fname);
 void    NP_LOADDS NPP_Print(NPP instance, NPPrint* platformPrint);
-int16   NP_LOADDS NPP_HandleEvent(NPP instance, void* event);
+int16_t NP_LOADDS NPP_HandleEvent(NPP instance, void* event);
 void    NP_LOADDS NPP_URLNotify(NPP instance, const char* url,
                                 NPReason reason, void* notifyData);
 #ifdef OJI
 jref    NP_LOADDS NPP_GetJavaClass(void);
 #endif
 NPError NP_LOADDS NPP_GetValue(NPP instance, NPPVariable variable, void *value);
 NPError NP_LOADDS NPP_SetValue(NPP instance, NPNVariable variable, void *value);
 
@@ -725,32 +650,32 @@ NPError NP_LOADDS NPP_SetValue(NPP insta
  */
 void    NP_LOADDS NPN_Version(int* plugin_major, int* plugin_minor,
                               int* netscape_major, int* netscape_minor);
 NPError NP_LOADDS NPN_GetURLNotify(NPP instance, const char* url,
                                    const char* target, void* notifyData);
 NPError NP_LOADDS NPN_GetURL(NPP instance, const char* url,
                              const char* target);
 NPError NP_LOADDS NPN_PostURLNotify(NPP instance, const char* url,
-                                    const char* target, uint32 len,
+                                    const char* target, uint32_t len,
                                     const char* buf, NPBool file,
                                     void* notifyData);
 NPError NP_LOADDS NPN_PostURL(NPP instance, const char* url,
-                              const char* target, uint32 len,
+                              const char* target, uint32_t len,
                               const char* buf, NPBool file);
 NPError NP_LOADDS NPN_RequestRead(NPStream* stream, NPByteRange* rangeList);
 NPError NP_LOADDS NPN_NewStream(NPP instance, NPMIMEType type,
                                 const char* target, NPStream** stream);
-int32   NP_LOADDS NPN_Write(NPP instance, NPStream* stream, int32 len, void* buffer);
+int32_t NP_LOADDS NPN_Write(NPP instance, NPStream* stream, int32_t len, void* buffer);
 NPError NP_LOADDS NPN_DestroyStream(NPP instance, NPStream* stream, NPReason reason);
 void    NP_LOADDS NPN_Status(NPP instance, const char* message);
-const char* NP_LOADDS	NPN_UserAgent(NPP instance);
-void*   NP_LOADDS NPN_MemAlloc(uint32 size);
+const char* NP_LOADDS NPN_UserAgent(NPP instance);
+void*   NP_LOADDS NPN_MemAlloc(uint32_t size);
 void    NP_LOADDS NPN_MemFree(void* ptr);
-uint32  NP_LOADDS NPN_MemFlush(uint32 size);
+uint32_t NP_LOADDS NPN_MemFlush(uint32_t size);
 void    NP_LOADDS NPN_ReloadPlugins(NPBool reloadPages);
 #ifdef OJI
 JRIEnv* NP_LOADDS NPN_GetJavaEnv(void);
 jref    NP_LOADDS NPN_GetJavaPeer(NPP instance);
 #endif
 NPError NP_LOADDS NPN_GetValue(NPP instance, NPNVariable variable, void *value);
 NPError NP_LOADDS NPN_SetValue(NPP instance, NPPVariable variable, void *value);
 void    NP_LOADDS NPN_InvalidateRect(NPP instance, NPRect *invalidRect);
diff -r b7bcdd009540 modules/plugin/base/public/nptypes.h
--- a/modules/plugin/base/public/nptypes.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/plugin/base/public/nptypes.h	Thu Sep 11 15:19:26 2008 +0300
@@ -38,19 +38,21 @@
 
 /*
  * Header file for ensuring that C99 types ([u]int32_t and bool) are
  * available.
  */
 
 #if defined(WIN32) || defined(OS2)
   /*
-   * Win32 and OS/2 don't know C99, so define [u]int_32 here. The bool
+   * Win32 and OS/2 don't know C99, so define [u]int_16/32 here. The bool
    * is predefined tho, both in C and C++.
    */
+  typedef short int16_t;
+  typedef unsigned short uint16_t;
   typedef int int32_t;
   typedef unsigned int uint32_t;
 #elif defined(_AIX) || defined(__sun) || defined(__osf__) || defined(IRIX) || defined(HPUX)
   /*
    * AIX and SunOS ship a inttypes.h header that defines [u]int32_t,
    * but not bool for C.
    */
   #include <inttypes.h>
diff -r b7bcdd009540 modules/plugin/base/public/npupp.h
--- a/modules/plugin/base/public/npupp.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/plugin/base/public/npupp.h	Thu Sep 11 15:19:26 2008 +0300
@@ -78,17 +78,17 @@ typedef void (* NP_LOADDS NPP_Initialize
 /* NPP_Shutdown */
 typedef void (* NP_LOADDS NPP_ShutdownUPP)(void);
 #define NewNPP_ShutdownProc(FUNC)		\
 		((NPP_ShutdownUPP) (FUNC))
 #define CallNPP_ShutdownProc(FUNC)		\
 		(*(FUNC))()
 
 /* NPP_New */
-typedef NPError	(* NP_LOADDS NPP_NewUPP)(NPMIMEType pluginType, NPP instance, uint16 mode, int16 argc, char* argn[], char* argv[], NPSavedData* saved);
+typedef NPError	(* NP_LOADDS NPP_NewUPP)(NPMIMEType pluginType, NPP instance, uint16_t mode, int16_t argc, char* argn[], char* argv[], NPSavedData* saved);
 #define NewNPP_NewProc(FUNC)		\
 		((NPP_NewUPP) (FUNC))
 #define CallNPP_NewProc(FUNC, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)		\
 		(*(FUNC))((ARG1), (ARG2), (ARG3), (ARG4), (ARG5), (ARG6), (ARG7))
 
 /* NPP_Destroy */
 typedef NPError	(* NP_LOADDS NPP_DestroyUPP)(NPP instance, NPSavedData** save);
 #define NewNPP_DestroyProc(FUNC)		\
@@ -99,38 +99,38 @@ typedef NPError	(* NP_LOADDS NPP_Destroy
 /* NPP_SetWindow */
 typedef NPError	(* NP_LOADDS NPP_SetWindowUPP)(NPP instance, NPWindow* window);
 #define NewNPP_SetWindowProc(FUNC)		\
 		((NPP_SetWindowUPP) (FUNC))
 #define CallNPP_SetWindowProc(FUNC, ARG1, ARG2)		\
 		(*(FUNC))((ARG1), (ARG2))
 
 /* NPP_NewStream */
-typedef NPError	(* NP_LOADDS NPP_NewStreamUPP)(NPP instance, NPMIMEType type, NPStream* stream, NPBool seekable, uint16* stype);
+typedef NPError	(* NP_LOADDS NPP_NewStreamUPP)(NPP instance, NPMIMEType type, NPStream* stream, NPBool seekable, uint16_t* stype);
 #define NewNPP_NewStreamProc(FUNC)		\
 		((NPP_NewStreamUPP) (FUNC))
 #define CallNPP_NewStreamProc(FUNC, ARG1, ARG2, ARG3, ARG4, ARG5) \
 		(*(FUNC))((ARG1), (ARG2), (ARG3), (ARG4), (ARG5))
 
 /* NPP_DestroyStream */
 typedef NPError	(* NP_LOADDS NPP_DestroyStreamUPP)(NPP instance, NPStream* stream, NPReason reason);
 #define NewNPP_DestroyStreamProc(FUNC)		\
 		((NPP_DestroyStreamUPP) (FUNC))
 #define CallNPP_DestroyStreamProc(FUNC,  NPParg, NPStreamPtr, NPReasonArg)		\
 		(*(FUNC))((NPParg), (NPStreamPtr), (NPReasonArg))
 
 /* NPP_WriteReady */
-typedef int32 (* NP_LOADDS NPP_WriteReadyUPP)(NPP instance, NPStream* stream);
+typedef int32_t (* NP_LOADDS NPP_WriteReadyUPP)(NPP instance, NPStream* stream);
 #define NewNPP_WriteReadyProc(FUNC)		\
 		((NPP_WriteReadyUPP) (FUNC))
 #define CallNPP_WriteReadyProc(FUNC,  NPParg, NPStreamPtr)		\
 		(*(FUNC))((NPParg), (NPStreamPtr))
 
 /* NPP_Write */
-typedef int32 (* NP_LOADDS NPP_WriteUPP)(NPP instance, NPStream* stream, int32 offset, int32 len, void* buffer);
+typedef int32_t (* NP_LOADDS NPP_WriteUPP)(NPP instance, NPStream* stream, int32_t offset, int32_t len, void* buffer);
 #define NewNPP_WriteProc(FUNC)		\
 		((NPP_WriteUPP) (FUNC))
 #define CallNPP_WriteProc(FUNC,  NPParg, NPStreamPtr, offsetArg, lenArg, bufferPtr)		\
 		(*(FUNC))((NPParg), (NPStreamPtr), (offsetArg), (lenArg), (bufferPtr))
 
 /* NPP_StreamAsFile */
 typedef void (* NP_LOADDS NPP_StreamAsFileUPP)(NPP instance, NPStream* stream, const char* fname);
 #define NewNPP_StreamAsFileProc(FUNC)		\
@@ -141,17 +141,17 @@ typedef void (* NP_LOADDS NPP_StreamAsFi
 /* NPP_Print */
 typedef void (* NP_LOADDS NPP_PrintUPP)(NPP instance, NPPrint* platformPrint);
 #define NewNPP_PrintProc(FUNC)		\
 		((NPP_PrintUPP) (FUNC))
 #define CallNPP_PrintProc(FUNC,  NPParg, NPPrintArg)		\
 		(*(FUNC))((NPParg), (NPPrintArg))
 
 /* NPP_HandleEvent */
-typedef int16 (* NP_LOADDS NPP_HandleEventUPP)(NPP instance, void* event);
+typedef int16_t (* NP_LOADDS NPP_HandleEventUPP)(NPP instance, void* event);
 #define NewNPP_HandleEventProc(FUNC)		\
 		((NPP_HandleEventUPP) (FUNC))
 #define CallNPP_HandleEventProc(FUNC,  NPParg, voidPtr)		\
 		(*(FUNC))((NPParg), (voidPtr))
 
 /* NPP_URLNotify */
 typedef void (* NP_LOADDS NPP_URLNotifyUPP)(NPP instance, const char* url, NPReason reason, void* notifyData);
 #define NewNPP_URLNotifyProc(FUNC)		\
@@ -195,31 +195,31 @@ typedef NPError	(* NP_LOADDS NPN_SetValu
 /* NPN_GetUrlNotify */
 typedef NPError	(* NP_LOADDS NPN_GetURLNotifyUPP)(NPP instance, const char* url, const char* window, void* notifyData);
 #define NewNPN_GetURLNotifyProc(FUNC)		\
 		((NPN_GetURLNotifyUPP) (FUNC))
 #define CallNPN_GetURLNotifyProc(FUNC, ARG1, ARG2, ARG3, ARG4)		\
 		(*(FUNC))((ARG1), (ARG2), (ARG3), (ARG4))
 
 /* NPN_PostUrlNotify */
-typedef NPError (* NP_LOADDS NPN_PostURLNotifyUPP)(NPP instance, const char* url, const char* window, uint32 len, const char* buf, NPBool file, void* notifyData);
+typedef NPError (* NP_LOADDS NPN_PostURLNotifyUPP)(NPP instance, const char* url, const char* window, uint32_t len, const char* buf, NPBool file, void* notifyData);
 #define NewNPN_PostURLNotifyProc(FUNC)		\
 		((NPN_PostURLNotifyUPP) (FUNC))
 #define CallNPN_PostURLNotifyProc(FUNC, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) \
 		(*(FUNC))((ARG1), (ARG2), (ARG3), (ARG4), (ARG5), (ARG6), (ARG7))
 
 /* NPN_GetUrl */
 typedef NPError	(* NP_LOADDS NPN_GetURLUPP)(NPP instance, const char* url, const char* window);
 #define NewNPN_GetURLProc(FUNC)		\
 		((NPN_GetURLUPP) (FUNC))
 #define CallNPN_GetURLProc(FUNC, ARG1, ARG2, ARG3)		\
 		(*(FUNC))((ARG1), (ARG2), (ARG3))
 
 /* NPN_PostUrl */
-typedef NPError (* NP_LOADDS NPN_PostURLUPP)(NPP instance, const char* url, const char* window, uint32 len, const char* buf, NPBool file);
+typedef NPError (* NP_LOADDS NPN_PostURLUPP)(NPP instance, const char* url, const char* window, uint32_t len, const char* buf, NPBool file);
 #define NewNPN_PostURLProc(FUNC)		\
 		((NPN_PostURLUPP) (FUNC))
 #define CallNPN_PostURLProc(FUNC, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) \
 		(*(FUNC))((ARG1), (ARG2), (ARG3), (ARG4), (ARG5), (ARG6))
 
 /* NPN_RequestRead */
 typedef NPError	(* NP_LOADDS NPN_RequestReadUPP)(NPStream* stream, NPByteRange* rangeList);
 #define NewNPN_RequestReadProc(FUNC)		\
@@ -230,17 +230,17 @@ typedef NPError	(* NP_LOADDS NPN_Request
 /* NPN_NewStream */
 typedef NPError	(* NP_LOADDS NPN_NewStreamUPP)(NPP instance, NPMIMEType type, const char* window, NPStream** stream);
 #define NewNPN_NewStreamProc(FUNC)		\
 		((NPN_NewStreamUPP) (FUNC))
 #define CallNPN_NewStreamProc(FUNC, npp, type, window, stream)		\
 		(*(FUNC))((npp), (type), (window), (stream))
 
 /* NPN_Write */
-typedef int32 (* NP_LOADDS NPN_WriteUPP)(NPP instance, NPStream* stream, int32 len, void* buffer);
+typedef int32_t (* NP_LOADDS NPN_WriteUPP)(NPP instance, NPStream* stream, int32_t len, void* buffer);
 #define NewNPN_WriteProc(FUNC)		\
 		((NPN_WriteUPP) (FUNC))
 #define CallNPN_WriteProc(FUNC, npp, stream, len, buffer)		\
 		(*(FUNC))((npp), (stream), (len), (buffer))
 
 /* NPN_DestroyStream */
 typedef NPError (* NP_LOADDS NPN_DestroyStreamUPP)(NPP instance, NPStream* stream, NPReason reason);
 #define NewNPN_DestroyStreamProc(FUNC)		\
@@ -258,31 +258,31 @@ typedef void (* NP_LOADDS NPN_StatusUPP)
 /* NPN_UserAgent */
 typedef const char*	(* NP_LOADDS NPN_UserAgentUPP)(NPP instance);
 #define NewNPN_UserAgentProc(FUNC)              \
                 ((NPN_UserAgentUPP) (FUNC))
 #define CallNPN_UserAgentProc(FUNC, ARG1)               \
                 (*(FUNC))((ARG1))
 
 /* NPN_MemAlloc */
-typedef void* (* NP_LOADDS NPN_MemAllocUPP)(uint32 size);
+typedef void* (* NP_LOADDS NPN_MemAllocUPP)(uint32_t size);
 #define NewNPN_MemAllocProc(FUNC)		\
 		((NPN_MemAllocUPP) (FUNC))
 #define CallNPN_MemAllocProc(FUNC, ARG1)		\
 		(*(FUNC))((ARG1))	
 
 /* NPN__MemFree */
 typedef void (* NP_LOADDS NPN_MemFreeUPP)(void* ptr);
 #define NewNPN_MemFreeProc(FUNC)		\
 		((NPN_MemFreeUPP) (FUNC))
 #define CallNPN_MemFreeProc(FUNC, ARG1)		\
 		(*(FUNC))((ARG1))	
 
 /* NPN_MemFlush */
-typedef uint32 (* NP_LOADDS NPN_MemFlushUPP)(uint32 size);
+typedef uint32_t (* NP_LOADDS NPN_MemFlushUPP)(uint32_t size);
 #define NewNPN_MemFlushProc(FUNC)		\
 		((NPN_MemFlushUPP) (FUNC))
 #define CallNPN_MemFlushProc(FUNC, ARG1)		\
 		(*(FUNC))((ARG1))	
 
 /* NPN_ReloadPlugins */
 typedef void (* NP_LOADDS NPN_ReloadPluginsUPP)(NPBool reloadPages);
 #define NewNPN_ReloadPluginsProc(FUNC)		\
@@ -503,18 +503,18 @@ typedef bool (* NP_LOADDS NPN_ConstructU
 
 
 
 /******************************************************************************************
  * The actual plugin function table definitions
  *******************************************************************************************/
 
 typedef struct _NPPluginFuncs {
-    uint16 size;
-    uint16 version;
+    uint16_t size;
+    uint16_t version;
     NPP_NewUPP newp;
     NPP_DestroyUPP destroy;
     NPP_SetWindowUPP setwindow;
     NPP_NewStreamUPP newstream;
     NPP_DestroyStreamUPP destroystream;
     NPP_StreamAsFileUPP asfile;
     NPP_WriteReadyUPP writeready;
     NPP_WriteUPP write;
@@ -525,18 +525,18 @@ typedef struct _NPPluginFuncs {
     // Use void * here directly now that we don't expose any Java
     // specific things in the plugin API.
     void* javaClass;
     NPP_GetValueUPP getvalue;
     NPP_SetValueUPP setvalue;
 } NPPluginFuncs;
 
 typedef struct _NPNetscapeFuncs {
-    uint16 size;
-    uint16 version;
+    uint16_t size;
+    uint16_t version;
     NPN_GetURLUPP geturl;
     NPN_PostURLUPP posturl;
     NPN_RequestReadUPP requestread;
     NPN_NewStreamUPP newstream;
     NPN_WriteUPP write;
     NPN_DestroyStreamUPP destroystream;
     NPN_StatusUPP status;
     NPN_UserAgentUPP uagent;
diff -r b7bcdd009540 modules/plugin/base/src/nsPluginsDirDarwin.cpp
--- a/modules/plugin/base/src/nsPluginsDirDarwin.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/plugin/base/src/nsPluginsDirDarwin.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -148,16 +148,27 @@ static PRBool IsLoadablePlugin(CFURLRef 
       close(f);
     }
   }
   return isLoadable;
 }
 
 PRBool nsPluginsDir::IsPluginFile(nsIFile* file)
 {
+  nsCString temp;
+  file->GetNativeLeafName(temp);
+  /*
+   * Don't load the VDP fake plugin, to avoid tripping a bad bug in OS X
+   * 10.5.3 (see bug 436575).
+   */
+  if (!strcmp(temp.get(), "VerifiedDownloadPlugin.plugin")) {
+    NS_WARNING("Preventing load of VerifiedDownloadPlugin.plugin (see bug 436575)");
+    return PR_FALSE;
+  }
+    
   CFURLRef pluginURL = NULL;
   if (NS_FAILED(toCFURLRef(file, pluginURL)))
     return PR_FALSE;
   
   PRBool isPluginFile = PR_FALSE;
   
   CFBundleRef pluginBundle = CFBundleCreate(kCFAllocatorDefault, pluginURL);
   if (pluginBundle) {
@@ -281,26 +292,16 @@ nsresult nsPluginFile::LoadPlugin(PRLibr
 nsresult nsPluginFile::LoadPlugin(PRLibrary* &outLibrary)
 {
     const char* path;
 
     if (!mPlugin)
         return NS_ERROR_NULL_POINTER;
 
     nsCAutoString temp;
-    mPlugin->GetNativeLeafName(temp);
-    /*
-     * Don't load the VDP fake plugin, to avoid tripping a bad bug in OS X
-     * 10.5.3 (see bug 436575).
-     */
-    if (!strcmp(temp.get(), "VerifiedDownloadPlugin.plugin")) {
-        NS_WARNING("Preventing load of VerifiedDownloadPlugin.plugin (see bug 436575)");
-        return NS_ERROR_FAILURE;
-    }
-
     mPlugin->GetNativePath(temp);
     path = temp.get();
 
     outLibrary = PR_LoadLibrary(path);
     pLibrary = outLibrary;
     if (!outLibrary) {
         return NS_ERROR_FAILURE;
     }
diff -r b7bcdd009540 modules/plugin/default/mac/NullPlugin.cpp
--- a/modules/plugin/default/mac/NullPlugin.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/plugin/default/mac/NullPlugin.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -58,55 +58,55 @@ public:
   enum HiliteState { kUnhilited = 0, kHilited = 1 };  
 
   static NPError Initialize();
   static void Shutdown();
 
   // no ctor because CPlugin is allocated and constructed by hand.
   // ideally, this should use placement |new|.
 
-  void Constructor(NPP instance, NPMIMEType type, uint16 mode, int16 argc, char* argn[], char* argv[]);
+  void Constructor(NPP instance, NPMIMEType type, uint16_t mode, int16_t argc, char* argn[], char* argv[]);
   void Destructor();
 
   void SetWindow(NPWindow* window);
   void Print(NPPrint* printInfo);
   Boolean HandleEvent(EventRecord*);
 
 protected:
   void Draw(HiliteState hilite);
   void DrawString(const unsigned char* text, short width, short height, short centerX, Rect drawRect);
   void MouseDown();
 
   Boolean FocusDraw();
   void RestoreDraw();
       
-  void DetermineURL(int16 argc, char* argn[], char* argv[]);
+  void DetermineURL(int16_t argc, char* argn[], char* argv[]);
   char* MakeDefaultURL(void);
   void AddMimeTypeToList(StringPtr cTypeString);
   Boolean CheckMimeTypes();
   void AskAndLoadURL();
   void RefreshPluginPage();
       
   Ptr New(UInt32 size);
   void Delete(Ptr ptr);
 
-  Boolean IsPluginHidden(int16 argc, char* argn[], char* argv[]);
+  Boolean IsPluginHidden(int16_t argc, char* argn[], char* argv[]);
 
 private:
   static CIconHandle sIconHandle;
   static CursHandle sHandCursor;
   static char* sAltText;
   static char* sInstallCommand;
   static char* sDefaultPage;
   static char* sRefreshText;
   static char* sJavaScriptPage;
 
   NPP fInstance;
   NPWindow* fWindow;
-  uint16 fMode;
+  uint16_t fMode;
   NPMIMEType fType;
   char* fPageURL;
   char* fFileURL;
   NPBool m_bOffline;
   NPBool m_bJavaScript;
 
   GrafPtr fSavePort;
   RgnHandle fSaveClip;
@@ -155,17 +155,17 @@ NPError NPP_Initialize(void)
 
 
 void NPP_Shutdown(void)
 {
   CPlugin::Shutdown();
 }
 
 
-NPError NPP_New(NPMIMEType type, NPP instance, uint16 mode, int16 argc, char* argn[], char* argv[], NPSavedData*)
+NPError NPP_New(NPMIMEType type, NPP instance, uint16_t mode, int16_t argc, char* argn[], char* argv[], NPSavedData*)
 {
   if (!instance)
     return NPERR_INVALID_INSTANCE_ERROR;
     
   CPlugin* This = (CPlugin*) (char*)NPN_MemAlloc(sizeof(CPlugin));
   instance->pdata = This;
   if (This) {
     This->Constructor(instance, type, mode, argc, argn, argv);
@@ -207,39 +207,39 @@ NPError NPP_SetWindow(NPP instance, NPWi
 }
 
 
 NPError NP_LOADDS
 NPP_NewStream(NPP instance,
               NPMIMEType /*type*/,
               NPStream* /*stream*/, 
               NPBool /*seekable*/,
-              uint16* /*stype*/)
+              uint16_t* /*stype*/)
 {
   if (!instance)
     return NPERR_INVALID_INSTANCE_ERROR;
 
   return NPERR_NO_ERROR;
 }
 
 
-int32 STREAMBUFSIZE = 0X0FFFFFFF;   // If we are reading from a file in NPAsFile
+int32_t STREAMBUFSIZE = 0X0FFFFFFF;   // If we are reading from a file in NPAsFile
                                     // mode so we can take any size stream in our
                                     // write call (since we ignore it)
 
 
-int32 NP_LOADDS
+int32_t NP_LOADDS
 NPP_WriteReady(NPP /*instance*/, NPStream* /*stream*/)
 {
   return STREAMBUFSIZE; // Number of bytes ready to accept in NPP_Write()
 }
 
 
-int32 NP_LOADDS
-NPP_Write(NPP /*instance*/, NPStream* /*stream*/, int32 /*offset*/, int32 len, void* /*buffer*/)
+int32_t NP_LOADDS
+NPP_Write(NPP /*instance*/, NPStream* /*stream*/, int32_t /*offset*/, int32_t len, void* /*buffer*/)
 {
   return len; // The number of bytes accepted
 }
 
 
 NPError NP_LOADDS
 NPP_DestroyStream(NPP instance, NPStream* /*stream*/, NPError /*reason*/)
 {
@@ -271,17 +271,17 @@ NPP_Print(NPP instance, NPPrint* printIn
       if (This)
         This->Print(printInfo);
     }
   }
 }
 
 
 // Mac-only
-int16 NPP_HandleEvent(NPP instance, void* event)
+int16_t NPP_HandleEvent(NPP instance, void* event)
 {
   if (instance) {
     CPlugin* This = (CPlugin*) instance->pdata;
     if (This && event)
       return This->HandleEvent((EventRecord*) event);
   }
 
   return FALSE;
@@ -398,17 +398,17 @@ void CPlugin::Shutdown()
     NPN_MemFree(CPlugin::sInstallCommand);
   if (CPlugin::sDefaultPage)
     NPN_MemFree(CPlugin::sDefaultPage);
   if (CPlugin::sRefreshText)
     NPN_MemFree(CPlugin::sRefreshText);
 }
 
 
-void CPlugin::Constructor(NPP instance, NPMIMEType type, uint16 mode, int16 argc, char* argn[], char* argv[])
+void CPlugin::Constructor(NPP instance, NPMIMEType type, uint16_t mode, int16_t argc, char* argn[], char* argv[])
 {
   fWindow = NULL;
   fPageURL = NULL;
   fFileURL = NULL;
   fInstance = instance;
   fMode = mode; // Mode is NP_EMBED, NP_FULL, or NP_BACKGROUND (see npapi.h)
   fAskedLoadURL = false;
   fUserInstalledPlugin = false;
@@ -652,17 +652,17 @@ void CPlugin::RestoreDraw()
   SetOrigin(fSavePortLeft, fSavePortTop);
   SetClip(fSaveClip);
   SetPort(fSavePort);
 }
 
 
 // Get a URL from either the parameters passed from the EMBED.
 // Append "?" and our mime type and save for later use.
-void CPlugin::DetermineURL(int16 argc, char* argn[], char* argv[])
+void CPlugin::DetermineURL(int16_t argc, char* argn[], char* argv[])
 {
   char* url;
   SInt32 additionalLength = 0;
   SInt32 i;
 
   // Appended to the URL will be a "?" and the mime type of this instance.  This lets the server
   // do something intelligent with a CGI script.
 
@@ -916,17 +916,17 @@ void CPlugin::DrawString(const unsigned 
 
   if (width > textWidth && height > textHeight + 32) {
     MoveTo(centerX - (textWidth >> 1), drawRect.bottom + textHeight);
     DrawText(text, 0, length);
   }    
 }
 
 
-Boolean CPlugin::IsPluginHidden(int16 argc, char* argn[], char* argv[])
+Boolean CPlugin::IsPluginHidden(int16_t argc, char* argn[], char* argv[])
 {
   for (int i = 0; i < argc; i++) {
     if (!strcasecmp(argn[i], "HIDDEN")) {
       if (!strcasecmp(argv[i], "TRUE"))
         return true;
     }
   }
   return false;
diff -r b7bcdd009540 modules/plugin/default/mac/npmac.cpp
--- a/modules/plugin/default/mac/npmac.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/plugin/default/mac/npmac.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -55,17 +55,17 @@ static inline void* SetupFPtoTVGlue(TFPt
     functionGlue->glue[1] = 0;
     return functionGlue;
 }
 
 #define PLUGIN_TO_HOST_GLUE(name, fp) (SetupFPtoTVGlue(&gPluginFuncsGlueTable.name, (void*)fp))
 
 // glue for mapping netscape TVectors to Macho function pointers
 struct TTVtoFPGlue {
-    uint32 glue[6];
+    uint32_t glue[6];
 };
 
 struct netscapeFuncsGlueTable {
     TTVtoFPGlue             geturl;
     TTVtoFPGlue             posturl;
     TTVtoFPGlue             requestread;
     TTVtoFPGlue             newstream;
     TTVtoFPGlue             write;
@@ -156,34 +156,34 @@ NPError NPN_GetURLNotify(NPP instance, c
 	return err;
 }
 
 NPError NPN_GetURL(NPP instance, const char* url, const char* window)
 {
 	return CallNPN_GetURLProc(gNetscapeFuncs.geturl, instance, url, window);
 }
 
-NPError NPN_PostURLNotify(NPP instance, const char* url, const char* window, uint32 len, const char* buf, NPBool file, void* notifyData)
+NPError NPN_PostURLNotify(NPP instance, const char* url, const char* window, uint32_t len, const char* buf, NPBool file, void* notifyData)
 {
 	int navMinorVers = gNetscapeFuncs.version & 0xFF;
 	NPError err;
 	
 	if( navMinorVers >= NPVERS_HAS_NOTIFICATION )
 	{
 		err = CallNPN_PostURLNotifyProc(gNetscapeFuncs.posturlnotify, instance, url, 
 														window, len, buf, file, notifyData);
 	}
 	else
 	{
 		err = NPERR_INCOMPATIBLE_VERSION_ERROR;
 	}
 	return err;
 }
 
-NPError NPN_PostURL(NPP instance, const char* url, const char* window, uint32 len, const char* buf, NPBool file)
+NPError NPN_PostURL(NPP instance, const char* url, const char* window, uint32_t len, const char* buf, NPBool file)
 {
 	return CallNPN_PostURLProc(gNetscapeFuncs.posturl, instance, url, window, len, buf, file);
 }
 
 NPError NPN_RequestRead(NPStream* stream, NPByteRange* rangeList)
 {
 	return CallNPN_RequestReadProc(gNetscapeFuncs.requestread, stream, rangeList);
 }
@@ -199,17 +199,17 @@ NPError NPN_NewStream(NPP instance, NPMI
 	}
 	else
 	{
 		err = NPERR_INCOMPATIBLE_VERSION_ERROR;
 	}
 	return err;
 }
 
-int32 NPN_Write(NPP instance, NPStream* stream, int32 len, void* buffer)
+int32_t NPN_Write(NPP instance, NPStream* stream, int32_t len, void* buffer)
 {
 	int navMinorVers = gNetscapeFuncs.version & 0xFF;
 	NPError err;
 	
 	if( navMinorVers >= NPVERS_HAS_STREAMOUTPUT )
 	{
 		err = CallNPN_WriteProc(gNetscapeFuncs.write, instance, stream, len, buffer);
 	}
@@ -241,27 +241,27 @@ void NPN_Status(NPP instance, const char
 	CallNPN_StatusProc(gNetscapeFuncs.status, instance, message);
 }
 
 const char* NPN_UserAgent(NPP instance)
 {
 	return CallNPN_UserAgentProc(gNetscapeFuncs.uagent, instance);
 }
 
-void* NPN_MemAlloc(uint32 size)
+void* NPN_MemAlloc(uint32_t size)
 {
 	return CallNPN_MemAllocProc(gNetscapeFuncs.memalloc, size);
 }
 
 void NPN_MemFree(void* ptr)
 {
 	CallNPN_MemFreeProc(gNetscapeFuncs.memfree, ptr);
 }
 
-uint32 NPN_MemFlush(uint32 size)
+uint32_t NPN_MemFlush(uint32_t size)
 {
 	return CallNPN_MemFlushProc(gNetscapeFuncs.memflush, size);
 }
 
 void NPN_ReloadPlugins(NPBool reloadPages)
 {
 	CallNPN_ReloadPluginsProc(gNetscapeFuncs.reloadplugins, reloadPages);
 }
@@ -310,43 +310,43 @@ void NPN_PopPopupsEnabledState(NPP insta
 // as documented and defined in npapi.h, without needing to 
 // install those functions in the function table or worry about
 // setting up globals for 68K plugins.
 //
 //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
 
 NPError 	Private_Initialize(void);
 void 		Private_Shutdown(void);
-NPError		Private_New(NPMIMEType pluginType, NPP instance, uint16 mode, int16 argc, char* argn[], char* argv[], NPSavedData* saved);
+NPError		Private_New(NPMIMEType pluginType, NPP instance, uint16_t mode, int16_t argc, char* argn[], char* argv[], NPSavedData* saved);
 NPError 	Private_Destroy(NPP instance, NPSavedData** save);
 NPError		Private_SetWindow(NPP instance, NPWindow* window);
-NPError		Private_NewStream(NPP instance, NPMIMEType type, NPStream* stream, NPBool seekable, uint16* stype);
+NPError		Private_NewStream(NPP instance, NPMIMEType type, NPStream* stream, NPBool seekable, uint16_t* stype);
 NPError		Private_DestroyStream(NPP instance, NPStream* stream, NPError reason);
-int32		Private_WriteReady(NPP instance, NPStream* stream);
-int32		Private_Write(NPP instance, NPStream* stream, int32 offset, int32 len, void* buffer);
-void		Private_StreamAsFile(NPP instance, NPStream* stream, const char* fname);
-void		Private_Print(NPP instance, NPPrint* platformPrint);
-int16 		Private_HandleEvent(NPP instance, void* event);
-void        Private_URLNotify(NPP instance, const char* url, NPReason reason, void* notifyData);
+int32_t		Private_WriteReady(NPP instance, NPStream* stream);
+int32_t		Private_Write(NPP instance, NPStream* stream, int32_t offset, int32_t len, void* buffer);
+void		  Private_StreamAsFile(NPP instance, NPStream* stream, const char* fname);
+void	  	Private_Print(NPP instance, NPPrint* platformPrint);
+int16_t 	Private_HandleEvent(NPP instance, void* event);
+void      Private_URLNotify(NPP instance, const char* url, NPReason reason, void* notifyData);
 
 
 NPError Private_Initialize(void)
 {
 	PLUGINDEBUGSTR("\pInitialize;g;");
 	return NPP_Initialize();
 }
 
 void Private_Shutdown(void)
 {
 	PLUGINDEBUGSTR("\pShutdown;g;");
 	NPP_Shutdown();
 }
 
 
-NPError	Private_New(NPMIMEType pluginType, NPP instance, uint16 mode, int16 argc, char* argn[], char* argv[], NPSavedData* saved)
+NPError	Private_New(NPMIMEType pluginType, NPP instance, uint16_t mode, int16_t argc, char* argn[], char* argv[], NPSavedData* saved)
 {
 	PLUGINDEBUGSTR("\pNew;g;");
 	return NPP_New(pluginType, instance, mode, argc, argn, argv, saved);
 }
 
 NPError Private_Destroy(NPP instance, NPSavedData** save)
 {
 	PLUGINDEBUGSTR("\pDestroy;g;");
@@ -354,29 +354,29 @@ NPError Private_Destroy(NPP instance, NP
 }
 
 NPError Private_SetWindow(NPP instance, NPWindow* window)
 {
 	PLUGINDEBUGSTR("\pSetWindow;g;");
 	return NPP_SetWindow(instance, window);
 }
 
-NPError Private_NewStream(NPP instance, NPMIMEType type, NPStream* stream, NPBool seekable, uint16* stype)
+NPError Private_NewStream(NPP instance, NPMIMEType type, NPStream* stream, NPBool seekable, uint16_t* stype)
 {
 	PLUGINDEBUGSTR("\pNewStream;g;");
 	return NPP_NewStream(instance, type, stream, seekable, stype);
 }
 
-int32 Private_WriteReady(NPP instance, NPStream* stream)
+int32_t Private_WriteReady(NPP instance, NPStream* stream)
 {
 	PLUGINDEBUGSTR("\pWriteReady;g;");
 	return NPP_WriteReady(instance, stream);
 }
 
-int32 Private_Write(NPP instance, NPStream* stream, int32 offset, int32 len, void* buffer)
+int32_t Private_Write(NPP instance, NPStream* stream, int32_t offset, int32_t len, void* buffer)
 {
 	PLUGINDEBUGSTR("\pWrite;g;");
 	return NPP_Write(instance, stream, offset, len, buffer);
 }
 
 void Private_StreamAsFile(NPP instance, NPStream* stream, const char* fname)
 {
 	PLUGINDEBUGSTR("\pStreamAsFile;g;");
@@ -385,17 +385,17 @@ void Private_StreamAsFile(NPP instance, 
 
 
 NPError Private_DestroyStream(NPP instance, NPStream* stream, NPError reason)
 {
 	PLUGINDEBUGSTR("\pDestroyStream;g;");
 	return NPP_DestroyStream(instance, stream, reason);
 }
 
-int16 Private_HandleEvent(NPP instance, void* event)
+int16_t Private_HandleEvent(NPP instance, void* event)
 {
 	PLUGINDEBUGSTR("\pHandleEvent;g;");
 	return NPP_HandleEvent(instance, event);
 }
 
 void Private_Print(NPP instance, NPPrint* platformPrint)
 {
 	PLUGINDEBUGSTR("\pPrint;g;");
diff -r b7bcdd009540 modules/plugin/default/unix/npshell.c
--- a/modules/plugin/default/unix/npshell.c	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/plugin/default/unix/npshell.c	Thu Sep 11 15:19:26 2008 +0300
@@ -102,18 +102,18 @@ void
 void
 NPP_Shutdown(void)
 {
 }
 
 NPError 
 NPP_New(NPMIMEType pluginType,
     NPP instance,
-    uint16 mode,
-    int16 argc,
+    uint16_t mode,
+    int16_t argc,
     char* argn[],
     char* argv[],
     NPSavedData* saved)
 {
 
     PluginInstance* This;
 
     if (instance == NULL)
@@ -241,41 +241,41 @@ NPP_SetWindow(NPP instance, NPWindow* wi
 }
 
 
 NPError 
 NPP_NewStream(NPP instance,
           NPMIMEType type,
           NPStream *stream, 
           NPBool seekable,
-          uint16 *stype)
+          uint16_t *stype)
 {
     if (instance == NULL)
         return NPERR_INVALID_INSTANCE_ERROR;
 
     return NPERR_NO_ERROR;
 }
 
 
-int32 
+int32_t 
 NPP_WriteReady(NPP instance, NPStream *stream)
 {
     if (instance == NULL)
         return NPERR_INVALID_INSTANCE_ERROR;
 
     /* We don't want any data, kill the stream */
     NPN_DestroyStream(instance, stream, NPRES_DONE);
 
     /* Number of bytes ready to accept in NPP_Write() */
     return -1L;   /* don't accept any bytes in NPP_Write() */
 }
 
 
-int32 
-NPP_Write(NPP instance, NPStream *stream, int32 offset, int32 len, void *buffer)
+int32_t 
+NPP_Write(NPP instance, NPStream *stream, int32_t offset, int32_t len, void *buffer)
 {
     if (instance == NULL)
         return NPERR_INVALID_INSTANCE_ERROR;
 
     /* We don't want any data, kill the stream */
     NPN_DestroyStream(instance, stream, NPRES_DONE);
 
     return -1L;   /* don't accept any bytes in NPP_Write() */
diff -r b7bcdd009540 modules/plugin/default/unix/npunix.c
--- a/modules/plugin/default/unix/npunix.c	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/plugin/default/unix/npunix.c	Thu Sep 11 15:19:26 2008 +0300
@@ -125,24 +125,24 @@ NPError
 NPError
 NPN_GetURLNotify(NPP instance, const char* url, const char* window, void* notifyData)
 {
     return CallNPN_GetURLNotifyProc(gNetscapeFuncs.geturlnotify, instance, url, window, notifyData);
 }
 
 NPError
 NPN_PostURL(NPP instance, const char* url, const char* window,
-         uint32 len, const char* buf, NPBool file)
+         uint32_t len, const char* buf, NPBool file)
 {
     return CallNPN_PostURLProc(gNetscapeFuncs.posturl, instance,
                     url, window, len, buf, file);
 }
 
 NPError
-NPN_PostURLNotify(NPP instance, const char* url, const char* window, uint32 len,
+NPN_PostURLNotify(NPP instance, const char* url, const char* window, uint32_t len,
                   const char* buf, NPBool file, void* notifyData)
 {
     return CallNPN_PostURLNotifyProc(gNetscapeFuncs.posturlnotify,
             instance, url, window, len, buf, file, notifyData);
 }
 
 NPError
 NPN_RequestRead(NPStream* stream, NPByteRange* rangeList)
@@ -154,18 +154,18 @@ NPError
 NPError
 NPN_NewStream(NPP instance, NPMIMEType type, const char *window,
           NPStream** stream_ptr)
 {
     return CallNPN_NewStreamProc(gNetscapeFuncs.newstream, instance,
                     type, window, stream_ptr);
 }
 
-int32
-NPN_Write(NPP instance, NPStream* stream, int32 len, void* buffer)
+int32_t
+NPN_Write(NPP instance, NPStream* stream, int32_t len, void* buffer)
 {
     return CallNPN_WriteProc(gNetscapeFuncs.write, instance,
                     stream, len, buffer);
 }
 
 NPError
 NPN_DestroyStream(NPP instance, NPStream* stream, NPError reason)
 {
@@ -181,27 +181,27 @@ NPN_Status(NPP instance, const char* mes
 
 const char*
 NPN_UserAgent(NPP instance)
 {
     return CallNPN_UserAgentProc(gNetscapeFuncs.uagent, instance);
 }
 
 void*
-NPN_MemAlloc(uint32 size)
+NPN_MemAlloc(uint32_t size)
 {
     return CallNPN_MemAllocProc(gNetscapeFuncs.memalloc, size);
 }
 
 void NPN_MemFree(void* ptr)
 {
     CallNPN_MemFreeProc(gNetscapeFuncs.memfree, ptr);
 }
 
-uint32 NPN_MemFlush(uint32 size)
+uint32_t NPN_MemFlush(uint32_t size)
 {
     return CallNPN_MemFlushProc(gNetscapeFuncs.memflush, size);
 }
 
 void NPN_ReloadPlugins(NPBool reloadPages)
 {
     CallNPN_ReloadPluginsProc(gNetscapeFuncs.reloadplugins, reloadPages);
 }
@@ -358,18 +358,18 @@ void NPN_SetException(NPObject* obj, con
  * These functions let the plugin developer just create the APIs
  * as documented and defined in npapi.h, without needing to 
  * install those functions in the function table or worry about
  * setting up globals for 68K plugins.
  *
  ***********************************************************************/
 
 NPError
-Private_New(NPMIMEType pluginType, NPP instance, uint16 mode,
-        int16 argc, char* argn[], char* argv[], NPSavedData* saved)
+Private_New(NPMIMEType pluginType, NPP instance, uint16_t mode,
+        int16_t argc, char* argn[], char* argv[], NPSavedData* saved)
 {
     NPError ret;
     PLUGINDEBUGSTR("New");
     ret = NPP_New(pluginType, instance, mode, argc, argn, argv, saved);
     return ret; 
 }
 
 NPError
@@ -385,35 +385,35 @@ Private_SetWindow(NPP instance, NPWindow
     NPError err;
     PLUGINDEBUGSTR("SetWindow");
     err = NPP_SetWindow(instance, window);
     return err;
 }
 
 NPError
 Private_NewStream(NPP instance, NPMIMEType type, NPStream* stream,
-            NPBool seekable, uint16* stype)
+            NPBool seekable, uint16_t* stype)
 {
     NPError err;
     PLUGINDEBUGSTR("NewStream");
     err = NPP_NewStream(instance, type, stream, seekable, stype);
     return err;
 }
 
-int32
+int32_t
 Private_WriteReady(NPP instance, NPStream* stream)
 {
     unsigned int result;
     PLUGINDEBUGSTR("WriteReady");
     result = NPP_WriteReady(instance, stream);
     return result;
 }
 
-int32
-Private_Write(NPP instance, NPStream* stream, int32 offset, int32 len,
+int32_t
+Private_Write(NPP instance, NPStream* stream, int32_t offset, int32_t len,
         void* buffer)
 {
     unsigned int result;
     PLUGINDEBUGSTR("Write");
     result = NPP_Write(instance, stream, offset, len, buffer);
     return result;
 }
 
diff -r b7bcdd009540 modules/plugin/default/unix/nullplugin.h
--- a/modules/plugin/default/unix/nullplugin.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/plugin/default/unix/nullplugin.h	Thu Sep 11 15:19:26 2008 +0300
@@ -74,23 +74,23 @@ Click OK to download Plugin."
 Click OK to download Plugin."
 
 #define GET 1
 #define REFRESH 2
 #include <gtk/gtk.h>
 
 typedef struct _PluginInstance
 {
-    uint16 mode;
+    uint16_t mode;
 #ifdef MOZ_X11
     Window window;
     Display *display;
 #endif
-    uint32 x, y;
-    uint32 width, height;
+    uint32_t x, y;
+    uint32_t width, height;
     NPMIMEType type;
     char *message;
 
     NPP instance;
     char *pluginsPageUrl;
     char *pluginsFileUrl;
     NPBool pluginsHidden;
 #ifdef MOZ_X11
diff -r b7bcdd009540 modules/plugin/default/windows/npshell.cpp
--- a/modules/plugin/default/windows/npshell.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/plugin/default/windows/npshell.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -63,31 +63,31 @@ void NPP_Shutdown(void)
   UnregisterNullPluginWindowClass();
 }
 
 //---------------------------------------------------------------------------
 // NPP_New:
 //---------------------------------------------------------------------------
 NPError NP_LOADDS NPP_New(NPMIMEType pluginType,
                           NPP pInstance,
-                          uint16 mode,
-                          int16 argc,
+                          uint16_t mode,
+                          int16_t argc,
                           char* argn[],
                           char* argv[],
                           NPSavedData* saved)
 {
   if(pInstance == NULL)
     return NPERR_INVALID_INSTANCE_ERROR;
 
   // See if the content provider specified from where to fetch the plugin
   char * szPageURL = NULL;
   char * szFileURL = NULL;
   char * szFileExtension = NULL;
   char * buf = NULL;
-  BOOL bHidden = FALSE;
+  BOOL bHidden = false;
 
   for(int i = 0; i < argc; i++)
   {
     if(lstrcmpi(argn[i],"pluginspage") == 0 && argv[i] != NULL)
       szPageURL = (char *)argv[i];
     else if(lstrcmpi(argn[i],"codebase") == 0 && argv[i] != NULL)
       szPageURL = (char *)argv[i];
     else if(lstrcmpi(argn[i],"pluginurl") == 0 && argv[i] != NULL)
@@ -219,17 +219,17 @@ NPError NP_LOADDS NPP_SetWindow(NPP pIns
 //------------------------------------------------------------------------------------
 // NPP_NewStream:
 //------------------------------------------------------------------------------------
 NPError NP_LOADDS
 NPP_NewStream(NPP pInstance,
               NPMIMEType type,
               NPStream *stream, 
               NPBool seekable,
-              uint16 *stype)
+              uint16_t *stype)
 {
   dbgOut1("NPP_NewStream");
   if(pInstance == NULL)
     return NPERR_INVALID_INSTANCE_ERROR;
 
   CPlugin * pPlugin = (CPlugin *)pInstance->pdata;
   assert(pPlugin != NULL);
 
@@ -237,17 +237,17 @@ NPP_NewStream(NPP pInstance,
     return NPERR_GENERIC_ERROR;
 
   return pPlugin->newStream(type, stream, seekable, stype);
 }
 
 //------------------------------------------------------------------------------------
 // NPP_WriteReady:
 //------------------------------------------------------------------------------------
-int32 NP_LOADDS
+int32_t NP_LOADDS
 NPP_WriteReady(NPP pInstance, NPStream *stream)
 {
   dbgOut1("NPP_WriteReady");
   if(pInstance == NULL)
     return NPERR_INVALID_INSTANCE_ERROR;
 
   CPlugin * pPlugin = (CPlugin *)pInstance->pdata;
   assert(pPlugin != NULL);
@@ -256,18 +256,18 @@ NPP_WriteReady(NPP pInstance, NPStream *
   NPN_DestroyStream(pInstance, stream, NPRES_DONE);
 
   return -1L;   // don't accept any bytes in NPP_Write()
 }
 
 //------------------------------------------------------------------------------------
 // NPP_Write:
 //------------------------------------------------------------------------------------
-int32 NP_LOADDS
-NPP_Write(NPP pInstance, NPStream *stream, int32 offset, int32 len, void *buffer)
+int32_t NP_LOADDS
+NPP_Write(NPP pInstance, NPStream *stream, int32_t offset, int32_t len, void *buffer)
 {
   //dbgOut1("NPP_Write");
   if(pInstance == NULL)
     return NPERR_INVALID_INSTANCE_ERROR;
 
   CPlugin * pPlugin = (CPlugin *)pInstance->pdata;
   assert(pPlugin != NULL);
 
diff -r b7bcdd009540 modules/plugin/default/windows/npwin.cpp
--- a/modules/plugin/default/windows/npwin.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/plugin/default/windows/npwin.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -199,31 +199,31 @@ NPError NPN_GetURLNotify(NPP instance, c
 }
 
 
 NPError NPN_GetURL(NPP instance, const char *url, const char *target)
 {
     return g_pNavigatorFuncs->geturl(instance, url, target);
 }
 
-NPError NPN_PostURLNotify(NPP instance, const char* url, const char* window, uint32 len, const char* buf, NPBool file, void* notifyData)
+NPError NPN_PostURLNotify(NPP instance, const char* url, const char* window, uint32_t len, const char* buf, NPBool file, void* notifyData)
 {
 	int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
 	NPError err;
 	if( navMinorVers >= NPVERS_HAS_NOTIFICATION ) {
 		err = g_pNavigatorFuncs->posturlnotify(instance, url, window, len, buf, file, notifyData);
 	}
 	else {
 		err = NPERR_INCOMPATIBLE_VERSION_ERROR;
 	}
 	return err;
 }
 
 
-NPError NPN_PostURL(NPP instance, const char* url, const char* window, uint32 len, const char* buf, NPBool file)
+NPError NPN_PostURL(NPP instance, const char* url, const char* window, uint32_t len, const char* buf, NPBool file)
 {
     return g_pNavigatorFuncs->posturl(instance, url, window, len, buf, file);
 }
 
 /* Requests that a number of bytes be provided on a stream.  Typically
    this would be used if a stream was in "pull" mode.  An optional
    position can be provided for streams which are seekable.
 */
@@ -247,21 +247,21 @@ NPError NPN_NewStream(NPP instance, NPMI
 	else {
 		err = NPERR_INCOMPATIBLE_VERSION_ERROR;
 	}
 	return err;
 }
 
 /* Provides len bytes of data.
 */
-int32 NPN_Write(NPP instance, NPStream *stream,
-                int32 len, void *buffer)
+int32_t NPN_Write(NPP instance, NPStream *stream,
+                  int32_t len, void *buffer)
 {
 	int navMinorVersion = g_pNavigatorFuncs->version & 0xFF;
-	int32 result;
+	int32_t result;
 
 	if( navMinorVersion >= NPVERS_HAS_STREAMOUTPUT ) {
 		result = g_pNavigatorFuncs->write(instance, stream, len, buffer);
 	}
 	else {
 		result = -1;
 	}
 	return result;
@@ -298,17 +298,17 @@ const char* NPN_UserAgent(NPP instance)
     return g_pNavigatorFuncs->uagent(instance);
 }
 
 /* allocates memory from the Navigator's memory space.  Necessary so that
    saved instance data may be freed by Navigator when exiting.
 */
 
 
-void* NPN_MemAlloc(uint32 size)
+void* NPN_MemAlloc(uint32_t size)
 {
     return g_pNavigatorFuncs->memalloc(size);
 }
 
 /* reciprocal of MemAlloc() above
 */
 void NPN_MemFree(void* ptr)
 {
diff -r b7bcdd009540 modules/plugin/default/windows/plugin.cpp
--- a/modules/plugin/default/windows/plugin.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/plugin/default/windows/plugin.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -549,17 +549,17 @@ void CPlugin::URLNotify(const char * szU
 
   //char buf[] = "<html>\n<body>\n\n<h2 align=center>NPN_NewStream / NPN_Write - This seems to work.</h2>\n\n</body>\n</html>";
   
   NPN_Write(m_pNPInstance, pStream, iSize, buf);
 
   NPN_DestroyStream(m_pNPInstance, pStream, NPRES_DONE);
 }
 
-NPError CPlugin::newStream(NPMIMEType type, NPStream *stream, NPBool seekable, uint16 *stype)
+NPError CPlugin::newStream(NPMIMEType type, NPStream *stream, NPBool seekable, uint16_t *stype)
 {
   if (!m_bWaitingStreamFromPFS)
     return NPERR_NO_ERROR;
 
   m_bWaitingStreamFromPFS = FALSE;
   m_PFSStream = stream;
 
   if (stream) {
diff -r b7bcdd009540 modules/plugin/default/windows/plugin.h
--- a/modules/plugin/default/windows/plugin.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/plugin/default/windows/plugin.h	Thu Sep 11 15:19:26 2008 +0300
@@ -91,17 +91,17 @@ public:
   HWND getWindow();
   void showGetPluginDialog();
   void getPlugin();
   BOOL readyToRefresh();
 
   // NP API handlers
   void print(NPPrint * pNPPrint);
   void URLNotify(const char * szURL);
-  NPError newStream(NPMIMEType type, NPStream *stream, NPBool seekable, uint16 *stype);
+  NPError newStream(NPMIMEType type, NPStream *stream, NPBool seekable, uint16_t *stype);
   NPError destroyStream(NPStream *stream, NPError reason);
 
   // Windows message handlers
   void onCreate(HWND hWnd);
   void onLButtonUp(HWND hWnd, int x, int y, UINT keyFlags);
   void onRButtonUp(HWND hWnd, int x, int y, UINT keyFlags);
   void onPaint(HWND hWnd);
 
diff -r b7bcdd009540 modules/plugin/sdk/samples/basic/mac/plugin.cpp
--- a/modules/plugin/sdk/samples/basic/mac/plugin.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/plugin/sdk/samples/basic/mac/plugin.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -207,20 +207,20 @@ nsPluginInstance::SetWindow(NPWindow* wi
 	}
 	return NPERR_NO_ERROR;
 }
 
 /////////////////////////////////////////////////////////////
 //
 // HandleEvent
 //
-uint16
+uint16_t
 nsPluginInstance::HandleEvent(void* event)
 {
-	int16 eventHandled = FALSE;
+	int16_t eventHandled = FALSE;
 	
 	EventRecord* ev = (EventRecord*) event;
 	if (event != NULL)
 	{
 		switch (ev->what)
 		{
 			/*
 			 * Draw ourselves on update events
diff -r b7bcdd009540 modules/plugin/sdk/samples/basic/mac/plugin.h
--- a/modules/plugin/sdk/samples/basic/mac/plugin.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/plugin/sdk/samples/basic/mac/plugin.h	Thu Sep 11 15:19:26 2008 +0300
@@ -45,17 +45,17 @@ public:
 public:
   nsPluginInstance(NPP aInstance);
   ~nsPluginInstance();
 
   NPBool init(NPWindow* aWindow);
   void shut();
   NPBool isInitialized();
   NPError SetWindow(NPWindow* pNPWindow);
-  uint16  HandleEvent(void* event);
+  uint16_t  HandleEvent(void* event);
 
 private:
   // locals
   const char * getVersion();
   void DoDraw();
   NPBool StartDraw(NPWindow* window);
   void EndDraw(NPWindow* window);
   void DrawString(const unsigned char* text, short width, short height, short centerX, Rect drawRect);
diff -r b7bcdd009540 modules/plugin/sdk/samples/common/npn_gate.cpp
--- a/modules/plugin/sdk/samples/common/npn_gate.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/plugin/sdk/samples/common/npn_gate.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -62,30 +62,30 @@ NPError NPN_GetURLNotify(NPP instance, c
   return rv;
 }
 
 NPError NPN_GetURL(NPP instance, const char *url, const char *target)
 {
   return CallNPN_GetURLProc(NPNFuncs.geturl, instance, url, target);
 }
 
-NPError NPN_PostURLNotify(NPP instance, const char* url, const char* window, uint32 len, const char* buf, NPBool file, void* notifyData)
+NPError NPN_PostURLNotify(NPP instance, const char* url, const char* window, uint32_t len, const char* buf, NPBool file, void* notifyData)
 {
 	int navMinorVers = NPNFuncs.version & 0xFF;
   NPError rv = NPERR_NO_ERROR;
 
 	if (navMinorVers >= NPVERS_HAS_NOTIFICATION)
 		rv = CallNPN_PostURLNotifyProc(NPNFuncs.posturlnotify, instance, url, window, len, buf, file, notifyData);
 	else
 		rv = NPERR_INCOMPATIBLE_VERSION_ERROR;
 
   return rv;
 }
 
-NPError NPN_PostURL(NPP instance, const char* url, const char* window, uint32 len, const char* buf, NPBool file)
+NPError NPN_PostURL(NPP instance, const char* url, const char* window, uint32_t len, const char* buf, NPBool file)
 {
   return CallNPN_PostURLProc(NPNFuncs.posturl, instance, url, window, len, buf, file);
 } 
 
 NPError NPN_RequestRead(NPStream* stream, NPByteRange* rangeList)
 {
   return CallNPN_RequestReadProc(NPNFuncs.requestread, stream, rangeList);
 }
@@ -99,20 +99,20 @@ NPError NPN_NewStream(NPP instance, NPMI
 	if (navMinorVersion >= NPVERS_HAS_STREAMOUTPUT)
 		rv = CallNPN_NewStreamProc(NPNFuncs.newstream, instance, type, target, stream);
 	else
 		rv = NPERR_INCOMPATIBLE_VERSION_ERROR;
 
   return rv;
 }
 
-int32 NPN_Write(NPP instance, NPStream *stream, int32 len, void *buffer)
+int32_t NPN_Write(NPP instance, NPStream *stream, int32_t len, void *buffer)
 {
 	int navMinorVersion = NPNFuncs.version & 0xFF;
-  int32 rv = 0;
+  int32_t rv = 0;
 
   if (navMinorVersion >= NPVERS_HAS_STREAMOUTPUT)
 		rv = CallNPN_WriteProc(NPNFuncs.write, instance, stream, len, buffer);
 	else
 		rv = -1;
 
   return rv;
 }
@@ -135,27 +135,27 @@ void NPN_Status(NPP instance, const char
   CallNPN_StatusProc(NPNFuncs.status, instance, message);
 }
 
 const char* NPN_UserAgent(NPP instance)
 {
   return CallNPN_UserAgentProc(NPNFuncs.uagent, instance);
 }
 
-void* NPN_MemAlloc(uint32 size)
+void* NPN_MemAlloc(uint32_t size)
 {
   return CallNPN_MemAllocProc(NPNFuncs.memalloc, size);
 }
 
 void NPN_MemFree(void* ptr)
 {
   CallNPN_MemFreeProc(NPNFuncs.memfree, ptr);
 }
 
-uint32 NPN_MemFlush(uint32 size)
+uint32_t NPN_MemFlush(uint32_t size)
 {
   return CallNPN_MemFlushProc(NPNFuncs.memflush, size);
 }
 
 void NPN_ReloadPlugins(NPBool reloadPages)
 {
   CallNPN_ReloadPluginsProc(NPNFuncs.reloadplugins, reloadPages);
 }
diff -r b7bcdd009540 modules/plugin/sdk/samples/common/npp_gate.cpp
--- a/modules/plugin/sdk/samples/common/npp_gate.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/plugin/sdk/samples/common/npp_gate.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -37,17 +37,17 @@
 
 // Implementation of plugin entry points (NPP_*)
 
 #include "pluginbase.h"
 
 // here the plugin creates a plugin instance object which 
 // will be associated with this newly created NPP instance and 
 // will do all the necessary job
-NPError NPP_New(NPMIMEType pluginType, NPP instance, uint16 mode, int16 argc, char* argn[], char* argv[], NPSavedData* saved)
+NPError NPP_New(NPMIMEType pluginType, NPP instance, uint16_t mode, int16_t argc, char* argn[], char* argv[], NPSavedData* saved)
 {   
   if (!instance)
     return NPERR_INVALID_INSTANCE_ERROR;
 
   // create a new plugin instance object
   // initialization will be done when the associated window is ready
   nsPluginCreateData ds;
   
@@ -116,41 +116,41 @@ NPError NPP_SetWindow (NPP instance, NPW
 
   // this should not happen, nothing to do
   if (!pNPWindow->window && !plugin->isInitialized())
     return plugin->SetWindow(pNPWindow);
 
   return NPERR_NO_ERROR;
 }
 
-NPError NPP_NewStream(NPP instance, NPMIMEType type, NPStream* stream, NPBool seekable, uint16* stype)
+NPError NPP_NewStream(NPP instance, NPMIMEType type, NPStream* stream, NPBool seekable, uint16_t* stype)
 {
   if (!instance)
     return NPERR_INVALID_INSTANCE_ERROR;
 
   nsPluginInstanceBase * plugin = (nsPluginInstanceBase *)instance->pdata;
   if (!plugin) 
     return NPERR_GENERIC_ERROR;
 
   return plugin->NewStream(type, stream, seekable, stype);
 }
 
-int32 NPP_WriteReady (NPP instance, NPStream *stream)
+int32_t NPP_WriteReady (NPP instance, NPStream *stream)
 {
   if (!instance)
     return 0x0fffffff;
 
   nsPluginInstanceBase * plugin = (nsPluginInstanceBase *)instance->pdata;
   if (!plugin) 
     return 0x0fffffff;
 
   return plugin->WriteReady(stream);
 }
 
-int32 NPP_Write (NPP instance, NPStream *stream, int32 offset, int32 len, void *buffer)
+int32_t NPP_Write (NPP instance, NPStream *stream, int32_t offset, int32_t len, void *buffer)
 {   
   if (!instance)
     return len;
 
   nsPluginInstanceBase * plugin = (nsPluginInstanceBase *)instance->pdata;
   if (!plugin) 
     return len;
 
@@ -224,17 +224,17 @@ NPError NPP_SetValue(NPP instance, NPNVa
 
   nsPluginInstanceBase * plugin = (nsPluginInstanceBase *)instance->pdata;
   if (!plugin) 
     return NPERR_GENERIC_ERROR;
 
   return plugin->SetValue(variable, value);
 }
 
-int16	NPP_HandleEvent(NPP instance, void* event)
+int16_t	NPP_HandleEvent(NPP instance, void* event)
 {
   if (!instance)
     return 0;
 
   nsPluginInstanceBase * plugin = (nsPluginInstanceBase *)instance->pdata;
   if (!plugin) 
     return 0;
 
diff -r b7bcdd009540 modules/plugin/sdk/samples/include/pluginbase.h
--- a/modules/plugin/sdk/samples/include/pluginbase.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/plugin/sdk/samples/include/pluginbase.h	Thu Sep 11 15:19:26 2008 +0300
@@ -39,18 +39,18 @@
 #define pluginbase_h_
 
 #include "npplat.h"
 
 struct nsPluginCreateData
 {
   NPP instance;
   NPMIMEType type; 
-  uint16 mode; 
-  int16 argc; 
+  uint16_t mode; 
+  int16_t argc; 
   char** argn; 
   char** argv; 
   NPSavedData* saved;
 };
 
 class nsPluginInstanceBase
 {
 public:
@@ -59,24 +59,24 @@ public:
   virtual NPBool init(NPWindow* aWindow) = 0;
   virtual void shut() = 0;
   virtual NPBool isInitialized() = 0;
 
   // implement all or part of those methods in the derived 
   // class as needed
   virtual NPError SetWindow(NPWindow* pNPWindow)                    { return NPERR_NO_ERROR; }
   virtual NPError NewStream(NPMIMEType type, NPStream* stream, 
-                            NPBool seekable, uint16* stype)         { return NPERR_NO_ERROR; }
+                            NPBool seekable, uint16_t* stype)       { return NPERR_NO_ERROR; }
   virtual NPError DestroyStream(NPStream *stream, NPError reason)   { return NPERR_NO_ERROR; }
   virtual void    StreamAsFile(NPStream* stream, const char* fname) { return; }
-  virtual int32   WriteReady(NPStream *stream)                      { return 0x0fffffff; }
-  virtual int32   Write(NPStream *stream, int32 offset, 
-                        int32 len, void *buffer)                    { return len; }
+  virtual int32_t WriteReady(NPStream *stream)                      { return 0x0fffffff; }
+  virtual int32_t Write(NPStream *stream, int32_t offset, 
+                        int32_t len, void *buffer)                  { return len; }
   virtual void    Print(NPPrint* printInfo)                         { return; }
-  virtual uint16  HandleEvent(void* event)                          { return 0; }
+  virtual uint16_t HandleEvent(void* event)                         { return 0; }
   virtual void    URLNotify(const char* url, NPReason reason, 
                             void* notifyData)                       { return; }
   virtual NPError GetValue(NPPVariable variable, void *value)       { return NPERR_NO_ERROR; }
   virtual NPError SetValue(NPNVariable variable, void *value)       { return NPERR_NO_ERROR; }
 };
 
 // functions that should be implemented for each specific plugin
 
diff -r b7bcdd009540 modules/plugin/sdk/samples/npruntime/np_entry.cpp
--- a/modules/plugin/sdk/samples/npruntime/np_entry.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/plugin/sdk/samples/npruntime/np_entry.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -38,17 +38,17 @@
 //////////////////////////////////////////////////////////////
 //
 // Main plugin entry point implementation
 //
 #include "npapi.h"
 #include "npupp.h"
 
 #ifndef HIBYTE
-#define HIBYTE(x) ((((uint32)(x)) & 0xff00) >> 8)
+#define HIBYTE(x) ((((uint32_t)(x)) & 0xff00) >> 8)
 #endif
 
 NPNetscapeFuncs NPNFuncs;
 
 #ifdef XP_WIN
 
 NPError OSCALL NP_GetEntryPoints(NPPluginFuncs* pFuncs)
 {
diff -r b7bcdd009540 modules/plugin/sdk/samples/npruntime/npn_gate.cpp
--- a/modules/plugin/sdk/samples/npruntime/npn_gate.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/plugin/sdk/samples/npruntime/npn_gate.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -38,17 +38,17 @@
 ////////////////////////////////////////////////////////////
 //
 // Implementation of Netscape entry points (NPN_*)
 //
 #include "npapi.h"
 #include "npupp.h"
 
 #ifndef HIBYTE
-#define HIBYTE(x) ((((uint32)(x)) & 0xff00) >> 8)
+#define HIBYTE(x) ((((uint32_t)(x)) & 0xff00) >> 8)
 #endif
 
 #ifndef LOBYTE
 #define LOBYTE(W) ((W) & 0xFF)
 #endif
 
 extern NPNetscapeFuncs NPNFuncs;
 
@@ -74,30 +74,30 @@ NPError NPN_GetURLNotify(NPP instance, c
 }
 
 NPError NPN_GetURL(NPP instance, const char *url, const char *target)
 {
   NPError rv = NPNFuncs.geturl(instance, url, target);
   return rv;
 }
 
-NPError NPN_PostURLNotify(NPP instance, const char* url, const char* window, uint32 len, const char* buf, NPBool file, void* notifyData)
+NPError NPN_PostURLNotify(NPP instance, const char* url, const char* window, uint32_t len, const char* buf, NPBool file, void* notifyData)
 {
 	int navMinorVers = NPNFuncs.version & 0xFF;
   NPError rv = NPERR_NO_ERROR;
 
 	if( navMinorVers >= NPVERS_HAS_NOTIFICATION )
 		rv = NPNFuncs.posturlnotify(instance, url, window, len, buf, file, notifyData);
 	else
 		rv = NPERR_INCOMPATIBLE_VERSION_ERROR;
 
   return rv;
 }
 
-NPError NPN_PostURL(NPP instance, const char* url, const char* window, uint32 len, const char* buf, NPBool file)
+NPError NPN_PostURL(NPP instance, const char* url, const char* window, uint32_t len, const char* buf, NPBool file)
 {
   NPError rv = NPNFuncs.posturl(instance, url, window, len, buf, file);
   return rv;
 } 
 
 NPError NPN_RequestRead(NPStream* stream, NPByteRange* rangeList)
 {
   NPError rv = NPNFuncs.requestread(stream, rangeList);
@@ -113,20 +113,20 @@ NPError NPN_NewStream(NPP instance, NPMI
 	if( navMinorVersion >= NPVERS_HAS_STREAMOUTPUT )
 		rv = NPNFuncs.newstream(instance, type, target, stream);
 	else
 		rv = NPERR_INCOMPATIBLE_VERSION_ERROR;
 
   return rv;
 }
 
-int32 NPN_Write(NPP instance, NPStream *stream, int32 len, void *buffer)
+int32_t NPN_Write(NPP instance, NPStream *stream, int32_t len, void *buffer)
 {
 	int navMinorVersion = NPNFuncs.version & 0xFF;
-  int32 rv = 0;
+  int32_t rv = 0;
 
   if( navMinorVersion >= NPVERS_HAS_STREAMOUTPUT )
 		rv = NPNFuncs.write(instance, stream, len, buffer);
 	else
 		rv = -1;
 
   return rv;
 }
@@ -151,31 +151,31 @@ void NPN_Status(NPP instance, const char
 
 const char* NPN_UserAgent(NPP instance)
 {
   const char * rv = NULL;
   rv = NPNFuncs.uagent(instance);
   return rv;
 }
 
-void* NPN_MemAlloc(uint32 size)
+void* NPN_MemAlloc(uint32_t size)
 {
   void * rv = NULL;
   rv = NPNFuncs.memalloc(size);
   return rv;
 }
 
 void NPN_MemFree(void* ptr)
 {
   NPNFuncs.memfree(ptr);
 }
 
-uint32 NPN_MemFlush(uint32 size)
+uint32_t NPN_MemFlush(uint32_t size)
 {
-  uint32 rv = NPNFuncs.memflush(size);
+  uint32_t rv = NPNFuncs.memflush(size);
   return rv;
 }
 
 void NPN_ReloadPlugins(NPBool reloadPages)
 {
   NPNFuncs.reloadplugins(reloadPages);
 }
 
diff -r b7bcdd009540 modules/plugin/sdk/samples/npruntime/npp_gate.cpp
--- a/modules/plugin/sdk/samples/npruntime/npp_gate.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/plugin/sdk/samples/npruntime/npp_gate.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -59,18 +59,18 @@ void NPP_Shutdown(void)
 {
 }
 
 // here the plugin creates an instance of our CPlugin object which 
 // will be associated with this newly created plugin instance and 
 // will do all the neccessary job
 NPError NPP_New(NPMIMEType pluginType,
                 NPP instance,
-                uint16 mode,
-                int16 argc,
+                uint16_t mode,
+                int16_t argc,
                 char* argn[],
                 char* argv[],
                 NPSavedData* saved)
 {   
   if(instance == NULL)
     return NPERR_INVALID_INSTANCE_ERROR;
 
   NPError rv = NPERR_NO_ERROR;
@@ -180,40 +180,40 @@ NPError	NPP_GetValue(NPP instance, NPPVa
 
   return rv;
 }
 
 NPError NPP_NewStream(NPP instance,
                       NPMIMEType type,
                       NPStream* stream, 
                       NPBool seekable,
-                      uint16* stype)
+                      uint16_t* stype)
 {
   if(instance == NULL)
     return NPERR_INVALID_INSTANCE_ERROR;
 
   NPError rv = NPERR_NO_ERROR;
   return rv;
 }
 
-int32 NPP_WriteReady (NPP instance, NPStream *stream)
+int32_t NPP_WriteReady (NPP instance, NPStream *stream)
 {
   if(instance == NULL)
     return NPERR_INVALID_INSTANCE_ERROR;
 
-  int32 rv = 0x0fffffff;
+  int32_t rv = 0x0fffffff;
   return rv;
 }
 
-int32 NPP_Write (NPP instance, NPStream *stream, int32 offset, int32 len, void *buffer)
+int32_t NPP_Write (NPP instance, NPStream *stream, int32_t offset, int32_t len, void *buffer)
 {   
   if(instance == NULL)
     return NPERR_INVALID_INSTANCE_ERROR;
 
-  int32 rv = len;
+  int32_t rv = len;
   return rv;
 }
 
 NPError NPP_DestroyStream (NPP instance, NPStream *stream, NPError reason)
 {
   if(instance == NULL)
     return NPERR_INVALID_INSTANCE_ERROR;
 
@@ -243,22 +243,22 @@ NPError NPP_SetValue(NPP instance, NPNVa
 {
   if(instance == NULL)
     return NPERR_INVALID_INSTANCE_ERROR;
 
   NPError rv = NPERR_NO_ERROR;
   return rv;
 }
 
-int16	NPP_HandleEvent(NPP instance, void* event)
+int16_t	NPP_HandleEvent(NPP instance, void* event)
 {
   if(instance == NULL)
     return 0;
 
-  int16 rv = 0;
+  int16_t rv = 0;
   CPlugin * pPlugin = (CPlugin *)instance->pdata;
   if (pPlugin)
     rv = pPlugin->handleEvent(event);
 
   return rv;
 }
 
 NPObject *NPP_GetScriptableInstance(NPP instance)
diff -r b7bcdd009540 modules/plugin/sdk/samples/npruntime/plugin.cpp
--- a/modules/plugin/sdk/samples/npruntime/plugin.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/plugin/sdk/samples/npruntime/plugin.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -655,17 +655,17 @@ void CPlugin::shut()
   m_bInitialized = FALSE;
 }
 
 NPBool CPlugin::isInitialized()
 {
   return m_bInitialized;
 }
 
-int16 CPlugin::handleEvent(void* event)
+int16_t CPlugin::handleEvent(void* event)
 {
 #ifdef XP_MAC
   NPEvent* ev = (NPEvent*)event;
   if (m_Window) {
     Rect box = { m_Window->y, m_Window->x,
                  m_Window->y + m_Window->height, m_Window->x + m_Window->width };
     if (ev->what == updateEvt) {
       ::TETextBox(m_String, strlen(m_String), &box, teJustCenter);
@@ -684,19 +684,19 @@ void CPlugin::showVersion()
 #ifdef XP_WIN
   InvalidateRect(m_hWnd, NULL, TRUE);
   UpdateWindow(m_hWnd);
 #endif
 
   if (m_Window) {
     NPRect r =
       {
-        (uint16)m_Window->y, (uint16)m_Window->x,
-        (uint16)(m_Window->y + m_Window->height),
-        (uint16)(m_Window->x + m_Window->width)
+        (uint16_t)m_Window->y, (uint16_t)m_Window->x,
+        (uint16_t)(m_Window->y + m_Window->height),
+        (uint16_t)(m_Window->x + m_Window->width)
       };
 
     NPN_InvalidateRect(m_pNPInstance, &r);
   }
 }
 
 // this will clean the plugin window
 void CPlugin::clear()
diff -r b7bcdd009540 modules/plugin/sdk/samples/npruntime/plugin.h
--- a/modules/plugin/sdk/samples/npruntime/plugin.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/plugin/sdk/samples/npruntime/plugin.h	Thu Sep 11 15:19:26 2008 +0300
@@ -63,17 +63,17 @@ public:
 public:
   CPlugin(NPP pNPInstance);
   ~CPlugin();
 
   NPBool init(NPWindow* pNPWindow);
   void shut();
   NPBool isInitialized();
   
-  int16 handleEvent(void* event);
+  int16_t handleEvent(void* event);
 
   void showVersion();
   void clear();
   void getVersion(char* *aVersion);
 
   NPObject *GetScriptableObject();
 };
 
diff -r b7bcdd009540 modules/plugin/sdk/samples/unixprinting/npshell.c
--- a/modules/plugin/sdk/samples/unixprinting/npshell.c	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/plugin/sdk/samples/unixprinting/npshell.c	Thu Sep 11 15:19:26 2008 +0300
@@ -102,18 +102,18 @@ void
 void
 NPP_Shutdown(void)
 {
 }
 
 NPError
 NPP_New(NPMIMEType pluginType,
     NPP instance,
-    uint16 mode,
-    int16 argc,
+    uint16_t mode,
+    int16_t argc,
     char* argn[],
     char* argv[],
     NPSavedData* saved)
 {
 
     PluginInstance* This;
 
     if (instance == NULL)
@@ -130,17 +130,17 @@ NPP_New(NPMIMEType pluginType,
 
     memset(This, 0, sizeof(PluginInstance));
 
     /* mode is NP_EMBED, NP_FULL, or NP_BACKGROUND (see npapi.h) */
     This->mode = mode;
     This->type = dupMimeType(pluginType);
     This->instance = instance;
     This->pluginsPrintMessage = NULL;
-    This->exists = FALSE;
+    This->exists = false;
 
     /* Parse argument list passed to plugin instance */
     /* We are interested in these arguments
      *  PLUGINSPAGE = <url>
      */
     while (argc > 0)
     {
         argc --;
@@ -232,41 +232,41 @@ NPP_SetWindow(NPP instance, NPWindow* wi
 }
 
 
 NPError
 NPP_NewStream(NPP instance,
           NPMIMEType type,
           NPStream *stream,
           NPBool seekable,
-          uint16 *stype)
+          uint16_t *stype)
 {
     if (instance == NULL)
         return NPERR_INVALID_INSTANCE_ERROR;
 
     return NPERR_NO_ERROR;
 }
 
 
-int32
+int32_t
 NPP_WriteReady(NPP instance, NPStream *stream)
 {
     if (instance == NULL)
         return NPERR_INVALID_INSTANCE_ERROR;
 
     /* We don't want any data, kill the stream */
     NPN_DestroyStream(instance, stream, NPRES_DONE);
 
     /* Number of bytes ready to accept in NPP_Write() */
     return -1L;   /* don't accept any bytes in NPP_Write() */
 }
 
 
-int32
-NPP_Write(NPP instance, NPStream *stream, int32 offset, int32 len, void *buffer)
+int32_t
+NPP_Write(NPP instance, NPStream *stream, int32_t offset, int32_t len, void *buffer)
 {
     if (instance == NULL)
         return NPERR_INVALID_INSTANCE_ERROR;
 
     /* We don't want any data, kill the stream */
     NPN_DestroyStream(instance, stream, NPRES_DONE);
 
     return -1L;   /* don't accept any bytes in NPP_Write() */
@@ -325,17 +325,17 @@ NPP_Print(NPP instance, NPPrint* printIn
         if (printInfo->mode == NP_FULL) {
             /*
              * PLUGIN DEVELOPERS:
              *  If your plugin would like to take over
              *  printing completely when it is in full-screen mode,
              *  set printInfo->pluginPrinted to TRUE and print your
              *  plugin as you see fit.  If your plugin wants Netscape
              *  to handle printing in this case, set
-             *  printInfo->pluginPrinted to FALSE (the default) and
+             *  printInfo->pluginPrinted to false (the default) and
              *  do nothing.  If you do want to handle printing
              *  yourself, printOne is true if the print button
              *  (as opposed to the print menu) was clicked.
              *  On the Macintosh, platformPrint is a THPrint; on
              *  Windows, platformPrint is a structure
              *  (defined in npapi.h) containing the printer name, port,
              *  etc.
              */
@@ -343,17 +343,17 @@ NPP_Print(NPP instance, NPPrint* printIn
     /***** Insert NPP_Print code here *****\
             void* platformPrint =
                 printInfo->print.fullPrint.platformPrint;
             NPBool printOne =
                 printInfo->print.fullPrint.printOne;
     \**************************************/
 
             /* Do the default*/
-            printInfo->print.fullPrint.pluginPrinted = FALSE;
+            printInfo->print.fullPrint.pluginPrinted = false;
         }
         else {  /* If not fullscreen, we must be embedded */
             /*
              * PLUGIN DEVELOPERS:
              *  If your plugin is embedded, or is full-screen
              *  but you returned false in pluginPrinted above, NPP_Print
              *  will be called with mode == NP_EMBED.  The NPWindow
              *  in the printInfo gives the location and dimensions of
diff -r b7bcdd009540 modules/plugin/sdk/samples/unixprinting/npunix.c
--- a/modules/plugin/sdk/samples/unixprinting/npunix.c	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/plugin/sdk/samples/unixprinting/npunix.c	Thu Sep 11 15:19:26 2008 +0300
@@ -125,24 +125,24 @@ NPError
 NPError
 NPN_GetURLNotify(NPP instance, const char* url, const char* window, void* notifyData)
 {
     return CallNPN_GetURLNotifyProc(gNetscapeFuncs.geturlnotify, instance, url, window, notifyData);
 }
 
 NPError
 NPN_PostURL(NPP instance, const char* url, const char* window,
-         uint32 len, const char* buf, NPBool file)
+         uint32_t len, const char* buf, NPBool file)
 {
     return CallNPN_PostURLProc(gNetscapeFuncs.posturl, instance,
                     url, window, len, buf, file);
 }
 
 NPError
-NPN_PostURLNotify(NPP instance, const char* url, const char* window, uint32 len,
+NPN_PostURLNotify(NPP instance, const char* url, const char* window, uint32_t len,
                   const char* buf, NPBool file, void* notifyData)
 {
     return CallNPN_PostURLNotifyProc(gNetscapeFuncs.posturlnotify,
             instance, url, window, len, buf, file, notifyData);
 }
 
 NPError
 NPN_RequestRead(NPStream* stream, NPByteRange* rangeList)
@@ -154,18 +154,18 @@ NPError
 NPError
 NPN_NewStream(NPP instance, NPMIMEType type, const char *window,
           NPStream** stream_ptr)
 {
     return CallNPN_NewStreamProc(gNetscapeFuncs.newstream, instance,
                     type, window, stream_ptr);
 }
 
-int32
-NPN_Write(NPP instance, NPStream* stream, int32 len, void* buffer)
+int32_t
+NPN_Write(NPP instance, NPStream* stream, int32_t len, void* buffer)
 {
     return CallNPN_WriteProc(gNetscapeFuncs.write, instance,
                     stream, len, buffer);
 }
 
 NPError
 NPN_DestroyStream(NPP instance, NPStream* stream, NPError reason)
 {
@@ -181,27 +181,27 @@ NPN_Status(NPP instance, const char* mes
 
 const char*
 NPN_UserAgent(NPP instance)
 {
     return CallNPN_UserAgentProc(gNetscapeFuncs.uagent, instance);
 }
 
 void*
-NPN_MemAlloc(uint32 size)
+NPN_MemAlloc(uint32_t size)
 {
     return CallNPN_MemAllocProc(gNetscapeFuncs.memalloc, size);
 }
 
 void NPN_MemFree(void* ptr)
 {
     CallNPN_MemFreeProc(gNetscapeFuncs.memfree, ptr);
 }
 
-uint32 NPN_MemFlush(uint32 size)
+uint32_t NPN_MemFlush(uint32_t size)
 {
     return CallNPN_MemFlushProc(gNetscapeFuncs.memflush, size);
 }
 
 void NPN_ReloadPlugins(NPBool reloadPages)
 {
     CallNPN_ReloadPluginsProc(gNetscapeFuncs.reloadplugins, reloadPages);
 }
@@ -247,18 +247,18 @@ void NPN_PopPopupsEnabledState(NPP insta
  * These functions let the plugin developer just create the APIs
  * as documented and defined in npapi.h, without needing to 
  * install those functions in the function table or worry about
  * setting up globals for 68K plugins.
  *
  ***********************************************************************/
 
 NPError
-Private_New(NPMIMEType pluginType, NPP instance, uint16 mode,
-        int16 argc, char* argn[], char* argv[], NPSavedData* saved)
+Private_New(NPMIMEType pluginType, NPP instance, uint16_t mode,
+        int16_t argc, char* argn[], char* argv[], NPSavedData* saved)
 {
     NPError ret;
     PLUGINDEBUGSTR("New");
     ret = NPP_New(pluginType, instance, mode, argc, argn, argv, saved);
     return ret; 
 }
 
 NPError
@@ -274,35 +274,35 @@ Private_SetWindow(NPP instance, NPWindow
     NPError err;
     PLUGINDEBUGSTR("SetWindow");
     err = NPP_SetWindow(instance, window);
     return err;
 }
 
 NPError
 Private_NewStream(NPP instance, NPMIMEType type, NPStream* stream,
-            NPBool seekable, uint16* stype)
+            NPBool seekable, uint16_t* stype)
 {
     NPError err;
     PLUGINDEBUGSTR("NewStream");
     err = NPP_NewStream(instance, type, stream, seekable, stype);
     return err;
 }
 
-int32
+int32_t
 Private_WriteReady(NPP instance, NPStream* stream)
 {
     unsigned int result;
     PLUGINDEBUGSTR("WriteReady");
     result = NPP_WriteReady(instance, stream);
     return result;
 }
 
-int32
-Private_Write(NPP instance, NPStream* stream, int32 offset, int32 len,
+int32_t
+Private_Write(NPP instance, NPStream* stream, int32_t offset, int32_t len,
         void* buffer)
 {
     unsigned int result;
     PLUGINDEBUGSTR("Write");
     result = NPP_Write(instance, stream, offset, len, buffer);
     return result;
 }
 
diff -r b7bcdd009540 modules/plugin/sdk/samples/unixprinting/printplugin.h
--- a/modules/plugin/sdk/samples/unixprinting/printplugin.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/plugin/sdk/samples/unixprinting/printplugin.h	Thu Sep 11 15:19:26 2008 +0300
@@ -40,24 +40,24 @@
 #define UNIXPRINTING_SAMPLEPLUGIN_H 1
 
 #define MIME_TYPES_HANDLED "application/x-print-unix-nsplugin:.pnt:Demo Print Plugin for Unix/Linux"
 #define PLUGIN_NAME         "Demo Print Plugin for unix/linux"
 #define PLUGIN_DESCRIPTION   "The demo print plugin for unix."
 
 typedef struct _PluginInstance
 {
-    uint16       mode;
+    uint16_t     mode;
 #ifdef MOZ_X11
     Window       window;
     Display     *display;
 #endif /* MOZ_X11 */
-    uint32       x,
+    uint32_t     x,
                  y;
-    uint32       width,
+    uint32_t     width,
                  height;
     NPMIMEType   type;
     char        *message;
 
     NPP          instance;
     char        *pluginsPrintMessage;
     NPBool       pluginsHidden;
 #ifdef MOZ_X11
diff -r b7bcdd009540 modules/plugin/sdk/samples/winless/windows/plugin.cpp
--- a/modules/plugin/sdk/samples/winless/windows/plugin.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/plugin/sdk/samples/winless/windows/plugin.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -111,17 +111,17 @@ NPBool nsPluginInstance::isInitialized()
 
 NPError nsPluginInstance::SetWindow(NPWindow* aWindow)
 {
   // keep window parameters
   mWindow = aWindow;
   return NPERR_NO_ERROR;
 }
 
-uint16 nsPluginInstance::HandleEvent(void* aEvent)
+uint16_t nsPluginInstance::HandleEvent(void* aEvent)
 {
   NPEvent * event = (NPEvent *)aEvent;
   switch (event->event) {
     case WM_PAINT: 
     {
       if(!mWindow)
         break;
 
diff -r b7bcdd009540 modules/plugin/sdk/samples/winless/windows/plugin.h
--- a/modules/plugin/sdk/samples/winless/windows/plugin.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/modules/plugin/sdk/samples/winless/windows/plugin.h	Thu Sep 11 15:19:26 2008 +0300
@@ -46,17 +46,17 @@ public:
   nsPluginInstance(NPP aInstance);
   ~nsPluginInstance();
 
   NPBool init(NPWindow* aWindow);
   void shut();
   NPBool isInitialized();
 
   NPError SetWindow(NPWindow* aWindow);
-  uint16 HandleEvent(void* aEvent);
+  uint16_t HandleEvent(void* aEvent);
 
 private:
   NPP mInstance;
   NPBool mInitialized;
   NPWindow * mWindow;
 };
 
 #endif // __PLUGIN_H__
diff -r b7bcdd009540 modules/plugin/test/Makefile.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/modules/plugin/test/Makefile.in	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,49 @@
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is mozilla.org
+# Portions created by the Initial Developer are Copyright (C) 2008
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Dave Townsend <dtownsend@oxymoronical.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE = plugin
+
+DIRS = testplugin
+
+include $(topsrcdir)/config/rules.mk
diff -r b7bcdd009540 modules/plugin/test/testplugin/Info.plist
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/modules/plugin/test/testplugin/Info.plist	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,38 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+	<key>CFBundleDevelopmentRegion</key>
+	<string>English</string>
+	<key>CFBundleExecutable</key>
+	<string>libnptest.dylib</string>
+	<key>CFBundleIdentifier</key>
+	<string>com.mozilla.TestPlugin</string>
+	<key>CFBundleInfoDictionaryVersion</key>
+	<string>6.0</string>
+	<key>CFBundlePackageType</key>
+	<string>BRPL</string>
+	<key>CFBundleShortVersionString</key>
+	<string>1.0.0.0</string>
+	<key>CFBundleSignature</key>
+	<string>TEST</string>
+	<key>CFBundleVersion</key>
+	<string>1.0.0.0</string>
+	<key>WebPluginName</key>
+	<string>Test Plug-in</string>
+	<key>WebPluginDescription</key>
+	<string>Plug-in for testing purposes.</string>
+	<key>WebPluginMIMETypes</key>
+	<dict>
+		<key>application/x-test</key>
+		<dict>
+			<key>WebPluginExtensions</key>
+			<array>
+				<string>tst</string>
+			</array>
+			<key>WebPluginTypeDescription</key>
+			<string>Test mimetype</string>
+		</dict>
+	</dict>
+</dict>
+</plist>
\ No newline at end of file
diff -r b7bcdd009540 modules/plugin/test/testplugin/Makefile.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/modules/plugin/test/testplugin/Makefile.in	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,76 @@
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is mozilla.org
+# Portions created by the Initial Developer are Copyright (C) 2008
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Dave Townsend <dtownsend@oxymoronical.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH     = ../../../..
+topsrcdir = @top_srcdir@
+srcdir    = @srcdir@
+VPATH     = @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE       = nptest
+LIBRARY_NAME = nptest
+MODULE_NAME  = TestPlugin
+
+REQUIRES = \
+  plugin \
+  $(NULL)
+
+# Need to custom install plugins
+NO_DIST_INSTALL	= 1
+NO_INSTALL = 1
+
+ifeq ($(OS_ARCH),WINNT)
+RCFILE    = nptest.rc
+RESFILE   = nptest.res
+endif
+
+CPPSRCS   = nptest.cpp
+
+include $(topsrcdir)/config/rules.mk
+
+install-plugin: $(SHARED_LIBRARY)
+ifdef SHARED_LIBRARY
+ifeq ($(MOZ_WIDGET_TOOLKIT),cocoa)
+	$(INSTALL) $(srcdir)/Info.plist $(DIST)/bin/plugins/Test.plugin/Contents
+	$(INSTALL) $(SHARED_LIBRARY) $(DIST)/bin/plugins/Test.plugin/Contents/MacOS
+else
+	$(INSTALL) $(SHARED_LIBRARY) $(DIST)/bin/plugins
+endif
+endif
+
+libs:: install-plugin
diff -r b7bcdd009540 modules/plugin/test/testplugin/nptest.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/modules/plugin/test/testplugin/nptest.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,83 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is mozilla.org
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Dave Townsend <dtownsend@oxymoronical.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "npapi.h"
+#include "npupp.h"
+
+#if defined(XP_UNIX)
+
+#define PLUGIN_NAME         "Test Plug-in"
+#define PLUGIN_DESCRIPTION  "Plug-in for testing purposes."
+#define PLUGIN_VERSION      "1.0.0.0"
+
+NP_EXPORT(char*)
+NP_GetPluginVersion(void) {
+    return PLUGIN_VERSION;
+}
+
+NP_EXPORT(char*)
+NP_GetMIMEDescription(void) {
+    return "application/x-test:tst:Test mimetype";
+}
+
+NP_EXPORT(NPError)
+NP_Initialize(NPNetscapeFuncs*, NPPluginFuncs*) {
+    return NPERR_NO_ERROR;
+}
+
+NP_EXPORT(NPError)
+NP_Shutdown(void) {
+    return NPERR_NO_ERROR;
+}
+
+NP_EXPORT(NPError) 
+NP_GetValue(void *future, NPPVariable aVariable, void *aValue) {
+   switch (aVariable) {
+     case NPPVpluginNameString:
+       *((char **)aValue) = PLUGIN_NAME;
+       break;
+     case NPPVpluginDescriptionString:
+       *((char **)aValue) = PLUGIN_DESCRIPTION;
+       break;
+     default:
+       return NPERR_INVALID_PARAM;
+       break;
+   }
+   return NPERR_NO_ERROR;
+}
+
+#endif
diff -r b7bcdd009540 modules/plugin/test/testplugin/nptest.rc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/modules/plugin/test/testplugin/nptest.rc	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,42 @@
+#include<winver.h>
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// Version
+//
+
+VS_VERSION_INFO VERSIONINFO
+ FILEVERSION    1,0,0,0
+ PRODUCTVERSION 1,0,0,0
+ FILEFLAGSMASK 0x3fL
+#ifdef _DEBUG
+ FILEFLAGS 0x1L
+#else
+ FILEFLAGS 0x0L
+#endif
+ FILEOS VOS__WINDOWS32
+ FILETYPE VFT_DLL
+ FILESUBTYPE 0x0L
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "040904e4"
+        BEGIN
+            VALUE "CompanyName", "mozilla.org"
+            VALUE "FileDescription", "Plug-in for testing purposes."
+            VALUE "FileExtents", "tst"
+            VALUE "FileOpenName", "Test mimetype"
+            VALUE "FileVersion", "1.0"
+            VALUE "InternalName", "nptest"
+            VALUE "MIMEType", "application/x-test"
+            VALUE "OriginalFilename", "nptest.dll"
+            VALUE "ProductName", "Test Plug-in"
+            VALUE "ProductVersion", "1.0"
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x409, 1252
+    END
+END
diff -r b7bcdd009540 netwerk/protocol/ftp/src/nsFtpConnectionThread.cpp
--- a/netwerk/protocol/ftp/src/nsFtpConnectionThread.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/netwerk/protocol/ftp/src/nsFtpConnectionThread.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -89,16 +89,17 @@ nsFtpState::nsFtpState()
     , mReceivedControlData(PR_FALSE)
     , mTryingCachedControl(PR_FALSE)
     , mRETRFailed(PR_FALSE)
     , mFileSize(LL_MAXUINT)
     , mServerType(FTP_GENERIC_TYPE)
     , mAction(GET)
     , mAnonymous(PR_TRUE)
     , mRetryPass(PR_FALSE)
+    , mStorReplyReceived(PR_FALSE)
     , mInternalError(NS_OK)
     , mPort(21)
     , mAddressChecked(PR_FALSE)
     , mServerIsIPv6(PR_FALSE)
     , mControlStatus(NS_OK)
 {
     LOG_ALWAYS(("FTP:(%x) nsFtpState created", this));
 
@@ -1223,24 +1224,31 @@ nsFtpState::S_stor() {
     return SendFTPCommand(storStr);
 }
 
 FTP_STATE
 nsFtpState::R_stor() {
     if (mResponseCode/100 == 2) {
         //(DONE)
         mNextState = FTP_COMPLETE;
+        mStorReplyReceived = PR_TRUE;
+
+        // Call Close() if it was not called in nsFtpState::OnStoprequest()
+        if (!mUploadRequest && !IsClosed())
+            Close();
+
         return FTP_COMPLETE;
     }
 
     if (mResponseCode/100 == 1) {
         LOG(("FTP:(%x) writing on DT\n", this));
         return FTP_READ_BUF;
     }
 
+   mStorReplyReceived = PR_TRUE;
    return FTP_ERROR;
 }
 
 
 nsresult
 nsFtpState::S_pasv() {
     if (!mAddressChecked) {
         // Find socket address
@@ -1957,24 +1965,30 @@ nsFtpState::OnCacheEntryAvailable(nsICac
     return NS_OK;
 }
 
 //-----------------------------------------------------------------------------
 
 NS_IMETHODIMP
 nsFtpState::OnStartRequest(nsIRequest *request, nsISupports *context)
 {
+    mStorReplyReceived = PR_FALSE;
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsFtpState::OnStopRequest(nsIRequest *request, nsISupports *context,
                           nsresult status)
 {
     mUploadRequest = nsnull;
+
+    // Close() will be called when reply to STOR command is received
+    // see bug #389394
+    if (!mStorReplyReceived)
+      return NS_OK;
 
     // We're done uploading.  Let our consumer know that we're done.
     Close();
     return NS_OK;
 }
 
 //-----------------------------------------------------------------------------
 
diff -r b7bcdd009540 netwerk/protocol/ftp/src/nsFtpConnectionThread.h
--- a/netwerk/protocol/ftp/src/nsFtpConnectionThread.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/netwerk/protocol/ftp/src/nsFtpConnectionThread.h	Thu Sep 11 15:19:26 2008 +0300
@@ -261,16 +261,18 @@ private:
     PRInt32             mServerType;    // What kind of server are we talking to
 
         // ****** protocol interpretation related state vars
     nsString            mUsername;      // username
     nsString            mPassword;      // password
     FTP_ACTION          mAction;        // the higher level action (GET/PUT)
     PRPackedBool        mAnonymous;     // try connecting anonymous (default)
     PRPackedBool        mRetryPass;     // retrying the password
+    PRPackedBool        mStorReplyReceived; // FALSE if waiting for STOR
+                                            // completion status from server
     nsresult            mInternalError; // represents internal state errors
 
         // ****** URI vars
     PRInt32                mPort;       // the port to connect to
     nsString               mFilename;   // url filename (if any)
     nsCString              mPath;       // the url's path
     nsCString              mPwd;        // login Path
 
diff -r b7bcdd009540 netwerk/protocol/http/src/nsHttpChannel.cpp
--- a/netwerk/protocol/http/src/nsHttpChannel.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/netwerk/protocol/http/src/nsHttpChannel.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -424,17 +424,17 @@ nsHttpChannel::HandleAsyncRedirect()
         }
     }
 
     // close the cache entry.  Blow it away if we couldn't process the redirect
     // for some reason (the cache entry might be corrupt).
     if (mCacheEntry) {
         if (NS_FAILED(rv))
             mCacheEntry->Doom();
-        CloseCacheEntry();
+        CloseCacheEntry(PR_FALSE);
     }
 
     mIsPending = PR_FALSE;
 
     if (mLoadGroup)
         mLoadGroup->RemoveRequest(this, nsnull, mStatus);
 }
 
@@ -449,17 +449,17 @@ nsHttpChannel::HandleAsyncNotModified()
         mPendingAsyncCallOnResume = &nsHttpChannel::HandleAsyncNotModified;
         return;
     }
     
     LOG(("nsHttpChannel::HandleAsyncNotModified [this=%p]\n", this));
 
     DoNotifyListener();
 
-    CloseCacheEntry();
+    CloseCacheEntry(PR_TRUE);
 
     mIsPending = PR_FALSE;
 
     if (mLoadGroup)
         mLoadGroup->RemoveRequest(this, nsnull, mStatus);
 }
 
 nsresult
@@ -831,17 +831,17 @@ nsHttpChannel::ProcessResponse()
     case 303:
 #if 0
     case 305: // disabled as a security measure (see bug 187996).
 #endif
         // don't store the response body for redirects
         rv = ProcessRedirection(httpStatus);
         if (NS_SUCCEEDED(rv)) {
             InitCacheEntry();
-            CloseCacheEntry();
+            CloseCacheEntry(PR_FALSE);
 
             if (mCacheForOfflineUse) {
                 // Store response in the offline cache
                 InitOfflineCacheEntry();
                 CloseOfflineCacheEntry();
             }
         }    
         else {
@@ -888,17 +888,17 @@ nsHttpChannel::ProcessNormal()
     ClearBogusContentEncodingIfNeeded();
 
     // this must be called before firing OnStartRequest, since http clients,
     // such as imagelib, expect our cache entry to already have the correct
     // expiration time (bug 87710).
     if (mCacheEntry) {
         rv = InitCacheEntry();
         if (NS_FAILED(rv))
-            CloseCacheEntry();
+            CloseCacheEntry(PR_TRUE);
     }
 
     // Check that the server sent us what we were asking for
     if (mResuming) {
         // Create an entity id from the response
         nsCAutoString id;
         rv = GetEntityID(id);
         if (NS_FAILED(rv)) {
@@ -1965,32 +1965,33 @@ nsHttpChannel::ReadFromCache()
                                    stream, nsInt64(-1), nsInt64(-1), 0, 0,
                                    PR_TRUE);
     if (NS_FAILED(rv)) return rv;
 
     return mCachePump->AsyncRead(this, mListenerContext);
 }
 
 void
-nsHttpChannel::CloseCacheEntry()
+nsHttpChannel::CloseCacheEntry(PRBool doomOnFailure)
 {
     if (!mCacheEntry)
         return;
 
     LOG(("nsHttpChannel::CloseCacheEntry [this=%x]", this));
 
     // If we have begun to create or replace a cache entry, and that cache
     // entry is not complete and not resumable, then it needs to be doomed.
     // Otherwise, CheckCache will make the mistake of thinking that the
     // partial cache entry is complete.
 
     PRBool doom = PR_FALSE;
     if (mInitedCacheEntry) {
         NS_ASSERTION(mResponseHead, "oops");
-        if (NS_FAILED(mStatus) && (mCacheAccess & nsICache::ACCESS_WRITE) &&
+        if (NS_FAILED(mStatus) && doomOnFailure &&
+            (mCacheAccess & nsICache::ACCESS_WRITE) &&
             !mResponseHead->IsResumable())
             doom = PR_TRUE;
     }
     else if (mCacheAccess == nsICache::ACCESS_WRITE)
         doom = PR_TRUE;
 
     if (doom) {
         LOG(("  dooming cache entry!!"));
@@ -3756,17 +3757,17 @@ nsHttpChannel::AsyncOpen(nsIStreamListen
     // listeners or by load group observers; in that case, we should
     // not send the request to the server
     if (mCanceled)
         rv = mStatus;
     else
         rv = Connect();
     if (NS_FAILED(rv)) {
         LOG(("Calling AsyncAbort [rv=%x mCanceled=%i]\n", rv, mCanceled));
-        CloseCacheEntry();
+        CloseCacheEntry(PR_TRUE);
         AsyncAbort(rv);
     }
     return NS_OK;
 }
 //-----------------------------------------------------------------------------
 // nsHttpChannel::nsIHttpChannel
 //-----------------------------------------------------------------------------
 
@@ -4491,17 +4492,17 @@ nsHttpChannel::OnStopRequest(nsIRequest 
     if (mListener) {
         LOG(("  calling OnStopRequest\n"));
         mListener->OnStopRequest(this, mListenerContext, status);
         mListener = 0;
         mListenerContext = 0;
     }
 
     if (mCacheEntry)
-        CloseCacheEntry();
+        CloseCacheEntry(PR_TRUE);
 
     if (mOfflineCacheEntry)
         CloseOfflineCacheEntry();
 
     if (mLoadGroup)
         mLoadGroup->RemoveRequest(this, nsnull, status);
 
     mCallbacks = nsnull;
@@ -4595,18 +4596,20 @@ nsHttpChannel::OnTransportStatus(nsITran
         LOG(("sending status notification [this=%x status=%x progress=%llu/%llu]\n",
             this, status, progress, progressMax));
 
         nsCAutoString host;
         mURI->GetHost(host);
         mProgressSink->OnStatus(this, nsnull, status,
                                 NS_ConvertUTF8toUTF16(host).get());
 
-        if (progress > 0)
+        if (progress > 0) {
+            NS_ASSERTION(progress <= progressMax, "unexpected progress values");
             mProgressSink->OnProgress(this, nsnull, progress, progressMax);
+        }
     }
 #ifdef DEBUG
     else
         LOG(("skipping status notification [this=%x sink=%x pending=%u background=%x]\n",
             this, mProgressSink.get(), mIsPending, (mLoadFlags & LOAD_BACKGROUND)));
 #endif
 
     return NS_OK;
@@ -4854,17 +4857,17 @@ nsHttpChannel::OnCacheEntryAvailable(nsI
         // we must fail if we were unable to open a cache entry.
         rv = NS_ERROR_DOCUMENT_NOT_CACHED;
     else
         // advance to the next state...
         rv = Connect(PR_FALSE);
 
     // a failure from Connect means that we have to abort the channel.
     if (NS_FAILED(rv)) {
-        CloseCacheEntry();
+        CloseCacheEntry(PR_TRUE);
         AsyncAbort(rv);
     }
 
     return NS_OK;
 }
 
 nsresult
 nsHttpChannel::DoAuthRetry(nsAHttpConnection *conn)
diff -r b7bcdd009540 netwerk/protocol/http/src/nsHttpChannel.h
--- a/netwerk/protocol/http/src/nsHttpChannel.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/netwerk/protocol/http/src/nsHttpChannel.h	Thu Sep 11 15:19:26 2008 +0300
@@ -186,17 +186,17 @@ private:
     // cache specific methods
     nsresult OpenCacheEntry(PRBool offline, PRBool *delayed);
     nsresult OpenOfflineCacheEntryForWriting();
     nsresult GenerateCacheKey(nsACString &key);
     nsresult UpdateExpirationTime();
     nsresult CheckCache();
     nsresult ShouldUpdateOfflineCacheEntry(PRBool *shouldCacheForOfflineUse);
     nsresult ReadFromCache();
-    void     CloseCacheEntry();
+    void     CloseCacheEntry(PRBool doomOnFailure);
     void     CloseOfflineCacheEntry();
     nsresult InitCacheEntry();
     nsresult InitOfflineCacheEntry();
     nsresult AddCacheEntryHeaders(nsICacheEntryDescriptor *entry);
     nsresult StoreAuthorizationMetaData(nsICacheEntryDescriptor *entry);
     nsresult FinalizeCacheEntry();
     nsresult InstallCacheListener(PRUint32 offset = 0);
     nsresult InstallOfflineCacheListener();
diff -r b7bcdd009540 netwerk/protocol/http/src/nsHttpConnection.cpp
--- a/netwerk/protocol/http/src/nsHttpConnection.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/netwerk/protocol/http/src/nsHttpConnection.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -802,17 +802,17 @@ nsHttpConnection::OnTransportStatus(nsIT
 // not called on the socket transport thread
 NS_IMETHODIMP
 nsHttpConnection::GetInterface(const nsIID &iid, void **result)
 {
     // NOTE: This function is only called on the UI thread via sync proxy from
     //       the socket transport thread.  If that weren't the case, then we'd
     //       have to worry about the possibility of mTransaction going away
     //       part-way through this function call.  See CloseTransaction.
-    NS_ASSERTION(PR_GetCurrentThread() != gSocketThread, "wrong thread");
+    NS_ASSERTION(NS_IsMainThread(), "wrong thread");
  
     if (mTransaction) {
         nsCOMPtr<nsIInterfaceRequestor> callbacks;
         mTransaction->GetSecurityCallbacks(getter_AddRefs(callbacks));
         if (callbacks)
             return callbacks->GetInterface(iid, result);
     }
 
diff -r b7bcdd009540 netwerk/protocol/http/src/nsHttpTransaction.cpp
--- a/netwerk/protocol/http/src/nsHttpTransaction.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/netwerk/protocol/http/src/nsHttpTransaction.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -360,16 +360,23 @@ nsHttpTransaction::OnTransportStatus(nsr
     }
 
     nsUint64 progressMax;
 
     if (status == nsISocketTransport::STATUS_SENDING_TO) {
         // suppress progress when only writing request headers
         if (!mHasRequestBody)
             return;
+
+        nsCOMPtr<nsISeekableStream> seekable = do_QueryInterface(mRequestStream);
+        NS_ASSERTION(seekable, "Request stream isn't seekable?!?");
+
+        PRInt64 prog = 0;
+        seekable->Tell(&prog);
+        progress = prog;
 
         // when uploading, we include the request headers in the progress
         // notifications.
         progressMax = mRequestSize; // XXX mRequestSize is 32-bit!
     }
     else {
         progress = LL_ZERO;
         progressMax = 0;
diff -r b7bcdd009540 netwerk/test/httpserver/httpd.js
--- a/netwerk/test/httpserver/httpd.js	Mon Sep 08 00:36:19 2008 -0700
+++ b/netwerk/test/httpserver/httpd.js	Thu Sep 11 15:19:26 2008 +0300
@@ -1027,32 +1027,37 @@ RequestReader.prototype =
     var count = input.available();
 
     // Handle cases where we get more data after a request error has been
     // discovered but *before* we can close the connection.
     if (!this._data)
       return;
 
     var moreAvailable = false;
-
+    var wasInBody = false;
+    
     switch (this._state)
     {
       case READER_INITIAL:
         moreAvailable = this._processRequestLine(input, count);
         break;
 
       case READER_IN_HEADERS:
         moreAvailable = this._processHeaders(input, count);
         break;
 
+      case READER_IN_BODY:
+        wasInBody = true;
+        moreAvailable = this._processBody(input, count);
+        break;
       default:
         NS_ASSERT(false);
     }
 
-    if (this._state == READER_IN_BODY && moreAvailable)
+    if (!wasInBody && this._state == READER_IN_BODY && moreAvailable)
       moreAvailable = this._processBody(input, count);
 
     if (moreAvailable)
       input.asyncWait(this, 0, 0, gThreadManager.currentThread);
   },
 
   //
   // see nsISupports.QueryInterface
@@ -1169,17 +1174,17 @@ RequestReader.prototype =
   {
     NS_ASSERT(this._state == READER_IN_BODY);
 
     try
     {
       if (this._contentLength > 0)
       {
         var bodyData = this._data.purge();
-        if (bodyData.length == 0)
+        if (!bodyData || bodyData.length == 0)
         {
           if (count > this._contentLength)
             count = this._contentLength;
 
           bodyData = readBytes(input, count);
         }
         dumpn("*** loading data="+bodyData+" len="+bodyData.length);
 
diff -r b7bcdd009540 netwerk/test/unit/head_channels.js
--- a/netwerk/test/unit/head_channels.js	Mon Sep 08 00:36:19 2008 -0700
+++ b/netwerk/test/unit/head_channels.js	Thu Sep 11 15:19:26 2008 +0300
@@ -71,17 +71,17 @@ ChannelListener.prototype = {
   },
 
   onDataAvailable: function(request, context, stream, offset, count) {
     if (!this._got_onstartrequest)
       do_throw("onDataAvailable without onStartRequest event!");
     if (this._got_onstoprequest)
       do_throw("onDataAvailable after onStopRequest event!");
     if (!request.isPending())
-      do_throw("request reports itself as not pending from onStartRequest!");
+      do_throw("request reports itself as not pending from onDataAvailable!");
     if (this._flags & CL_EXPECT_FAILURE)
       do_throw("Got data despite expecting a failure");
 
     this._buffer = this._buffer.concat(read_stream(stream, count));
   },
 
   onStopRequest: function(request, context, status) {
     if (!this._got_onstartrequest)
diff -r b7bcdd009540 netwerk/test/unit/test_redirect_caching.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/netwerk/test/unit/test_redirect_caching.js	Thu Sep 11 15:19:26 2008 +0300
@@ -0,0 +1,54 @@
+do_import_script("netwerk/test/httpserver/httpd.js");
+
+var httpserver = null;
+// Need to randomize, because apparently no one clears our cache
+var randomPath = "/redirect/" + Math.random();
+var randomURI = "http://localhost:4444" + randomPath;
+
+function make_channel(url, callback, ctx) {
+  var ios = Cc["@mozilla.org/network/io-service;1"].
+            getService(Ci.nsIIOService);
+  return ios.newChannel(url, "", null);
+}
+
+const responseBody = "response body";
+
+function redirectHandler(metadata, response)
+{
+  response.setStatusLine(metadata.httpVersion, 301, "Moved");
+  response.setHeader("Location", "http://localhost:4444/content", false);
+  return;
+}
+
+function contentHandler(metadata, response)
+{
+  response.setHeader("Content-Type", "text/plain");
+  response.bodyOutputStream.write(responseBody, responseBody.length);
+}
+
+function firstTimeThrough(request, buffer)
+{
+  do_check_eq(buffer, responseBody);
+  var chan = make_channel(randomURI);
+  chan.loadFlags |= Ci.nsICachingChannel.LOAD_ONLY_FROM_CACHE;
+  chan.asyncOpen(new ChannelListener(finish_test, null), null);
+}
+
+function finish_test(request, buffer)
+{
+  httpserver.stop();
+  do_check_eq(buffer, responseBody);
+  do_test_finished();
+}
+
+function run_test()
+{
+  httpserver = new nsHttpServer();
+  httpserver.registerPathHandler(randomPath, redirectHandler);
+  httpserver.registerPathHandler("/content", contentHandler);
+  httpserver.start(4444);
+
+  var chan = make_channel(randomURI);
+  chan.asyncOpen(new ChannelListener(firstTimeThrough, null), null);
+  do_test_pending();
+}
diff -r b7bcdd009540 netwerk/test/unit/test_resumable_truncate.js
--- a/netwerk/test/unit/test_resumable_truncate.js	Mon Sep 08 00:36:19 2008 -0700
+++ b/netwerk/test/unit/test_resumable_truncate.js	Thu Sep 11 15:19:26 2008 +0300
@@ -23,17 +23,17 @@ function cachedHandler(metadata, respons
       response.setHeader("Content-Range", "*/" + responseBody.length, false);
       return;
     }
     body = responseBody.slice(from, to + 1);
     // always respond to successful range requests with 206
     response.setStatusLine(metadata.httpVersion, 206, "Partial Content");
     response.setHeader("Content-Range", from + "-" + to + "/" + responseBody.length, false);
   } else if (do304) {
-    response.setStatusList(metadata.httpVersion, 304, "Not Modified");
+    response.setStatusLine(metadata.httpVersion, 304, "Not Modified");
     return;
   }
 
   response.setHeader("Content-Type", "text/plain", false);
   response.setHeader("ETag", "Just testing");
   response.setHeader("Accept-Ranges", "bytes");
 
   response.bodyOutputStream.write(body, body.length);
diff -r b7bcdd009540 parser/htmlparser/src/CNavDTD.cpp
--- a/parser/htmlparser/src/CNavDTD.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/parser/htmlparser/src/CNavDTD.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -2240,17 +2240,17 @@ CNavDTD::CanPropagate(eHTMLTags aParent,
           }
         }
       }
     }
     if (mScratch.Length() - 1 > gHTMLElements[aParent].mPropagateRange) {
       result = PR_FALSE;
     }
   } else {
-    result = aParentContains;
+    result = !!aParentContains;
   }
 
 
   return result;
 }
 
 
 /**
diff -r b7bcdd009540 parser/htmlparser/src/nsExpatDriver.cpp
--- a/parser/htmlparser/src/nsExpatDriver.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/parser/htmlparser/src/nsExpatDriver.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -177,17 +177,17 @@ Driver_HandleStartDoctypeDecl(void *aUse
                               const XML_Char *aDoctypeName,
                               const XML_Char *aSysid,
                               const XML_Char *aPubid,
                               int aHasInternalSubset)
 {
   NS_ASSERTION(aUserData, "expat driver should exist");
   if (aUserData) {
     static_cast<nsExpatDriver*>(aUserData)->
-      HandleStartDoctypeDecl(aDoctypeName, aSysid, aPubid, aHasInternalSubset);
+      HandleStartDoctypeDecl(aDoctypeName, aSysid, aPubid, !!aHasInternalSubset);
   }
 }
 
 PR_STATIC_CALLBACK(void)
 Driver_HandleEndDoctypeDecl(void *aUserData)
 {
   NS_ASSERTION(aUserData, "expat driver should exist");
   if (aUserData) {
diff -r b7bcdd009540 parser/htmlparser/src/nsHTMLTokenizer.cpp
--- a/parser/htmlparser/src/nsHTMLTokenizer.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/parser/htmlparser/src/nsHTMLTokenizer.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -556,17 +556,17 @@ nsHTMLTokenizer::ConsumeTag(PRUnichar aC
         result = aScanner.Peek(theNextChar, 2);
 
         if (NS_OK == result) {
           // Get the original "<" (we've already seen it with a Peek)
           aScanner.GetChar(oldChar);
 
           // XML allows non ASCII tag names, consume this as an end tag. This
           // is needed to make XML view source work
-          PRBool isXML = mFlags & NS_IPARSER_FLAG_XML;
+          PRBool isXML = !!(mFlags & NS_IPARSER_FLAG_XML);
           if (nsCRT::IsAsciiAlpha(theNextChar) ||
               kGreaterThan == theNextChar      ||
               (isXML && !nsCRT::IsAscii(theNextChar))) {
             result = ConsumeEndTag(aChar, aToken, aScanner);
           } else {
             result = ConsumeComment(aChar, aToken, aScanner);
           }
         }
@@ -592,17 +592,17 @@ nsHTMLTokenizer::ConsumeTag(PRUnichar aC
         // It must be a processing instruction...
         // Get the original "<" (we've already seen it with a Peek)
         aScanner.GetChar(oldChar);
         result = ConsumeProcessingInstruction(aChar, aToken, aScanner);
         break;
 
       default:
         // XML allows non ASCII tag names, consume this as a start tag.
-        PRBool isXML = mFlags & NS_IPARSER_FLAG_XML;
+        PRBool isXML = !!(mFlags & NS_IPARSER_FLAG_XML);
         if (nsCRT::IsAsciiAlpha(aChar) ||
             (isXML && !nsCRT::IsAscii(aChar))) {
           // Get the original "<" (we've already seen it with a Peek)
           aScanner.GetChar(oldChar);
           result = ConsumeStartTag(aChar, aToken, aScanner, aFlushTokens);
         } else {
           // We are not dealing with a tag. So, don't consume the original
           // char and leave the decision to ConsumeText().
diff -r b7bcdd009540 parser/htmlparser/src/nsParserService.h
--- a/parser/htmlparser/src/nsParserService.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/parser/htmlparser/src/nsParserService.h	Thu Sep 11 15:19:26 2008 +0300
@@ -81,21 +81,21 @@ public:
   NS_IMETHOD GetTopicObservers(const nsAString& aTopic,
                                nsIObserverEntry** aEntry);
 
   nsresult CheckQName(const nsAString& aQName,
                       PRBool aNamespaceAware, const PRUnichar** aColon);
 
   PRBool IsXMLLetter(PRUnichar aChar)
   {
-    return MOZ_XMLIsLetter(reinterpret_cast<const char*>(&aChar));
+    return !!MOZ_XMLIsLetter(reinterpret_cast<const char*>(&aChar));
   }
   PRBool IsXMLNCNameChar(PRUnichar aChar)
   {
-    return MOZ_XMLIsNCNameChar(reinterpret_cast<const char*>(&aChar));
+    return !!MOZ_XMLIsNCNameChar(reinterpret_cast<const char*>(&aChar));
   }
   PRUint32 DecodeEntity(const PRUnichar* aStart, const PRUnichar* aEnd,
                         const PRUnichar** aNext, PRUnichar* aResult)
   {
     *aNext = nsnull;
     return MOZ_XMLTranslateEntity(reinterpret_cast<const char*>(aStart),
                                   reinterpret_cast<const char*>(aEnd),
                                   reinterpret_cast<const char**>(aNext),
diff -r b7bcdd009540 parser/htmlparser/tests/Makefile.in
--- a/parser/htmlparser/tests/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/parser/htmlparser/tests/Makefile.in	Thu Sep 11 15:19:26 2008 +0300
@@ -40,22 +40,18 @@ srcdir		= @srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 DIRS = \
 	grabpage \
 	html \
+	mochitest \
 	$(NULL)
 
 ifndef MOZ_ENABLE_LIBXUL
 DIRS += \
 	outsinks \
 	$(NULL)
 endif
 
-ifdef MOZ_MOCHITEST
-DIRS += mochitest \
-        $(NULL)
-endif
-
 include $(topsrcdir)/config/rules.mk
diff -r b7bcdd009540 security/manager/boot/src/nsSecureBrowserUIImpl.cpp
--- a/security/manager/boot/src/nsSecureBrowserUIImpl.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/security/manager/boot/src/nsSecureBrowserUIImpl.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -185,23 +185,22 @@ nsSecureBrowserUIImpl::~nsSecureBrowserU
   if (mTransferringRequests.ops) {
     PL_DHashTableFinish(&mTransferringRequests);
     mTransferringRequests.ops = nsnull;
   }
   if (mMonitor)
     PR_DestroyMonitor(mMonitor);
 }
 
-NS_IMPL_THREADSAFE_ISUPPORTS6(nsSecureBrowserUIImpl,
-                              nsISecureBrowserUI,
-                              nsIWebProgressListener,
-                              nsIFormSubmitObserver,
-                              nsIObserver,
-                              nsISupportsWeakReference,
-                              nsISSLStatusProvider)
+NS_IMPL_ISUPPORTS6(nsSecureBrowserUIImpl, nsISecureBrowserUI,
+                                          nsIWebProgressListener,
+                                          nsIFormSubmitObserver,
+                                          nsIObserver,
+                                          nsISupportsWeakReference,
+                                          nsISSLStatusProvider)
 
 NS_IMETHODIMP
 nsSecureBrowserUIImpl::Init(nsIDOMWindow *aWindow)
 {
 
 #ifdef PR_LOGGING
   nsCOMPtr<nsIDOMWindow> window(do_QueryReferent(mWindow));
 
diff -r b7bcdd009540 security/manager/locales/en-US/chrome/pippki/pippki.dtd
--- a/security/manager/locales/en-US/chrome/pippki/pippki.dtd	Mon Sep 08 00:36:19 2008 -0700
+++ b/security/manager/locales/en-US/chrome/pippki/pippki.dtd	Thu Sep 11 15:19:26 2008 +0300
@@ -46,17 +46,17 @@
 
 <!-- Values for resetpassword.xul -->
 <!ENTITY resetPasswordButtonLabel "Reset">
 <!ENTITY resetPassword.title  "Reset Master Password">
 <!ENTITY resetPassword.text  "If you reset your master password, all your stored web and e-mail passwords, form data, personal certificates, and private keys will be forgotten. Are you sure you want to reset your master password?">
 
 <!-- Values for getpassword.xul -->
 <!ENTITY getPassword.title  "Enter Master Password">
-<!ENTITY getPassword.tokenName.label "Security Device">
+<!ENTITY getPassword.tokenName2.label "Security Device:">
 <!ENTITY getPassword.password.label "Password:">
 
 <!-- These should be common -->
 <!ENTITY piperror.title "Error">
 <!ENTITY pipalert.title "Error - cannot recover">
 
 <!-- Prefs panel strings -->
 <!ENTITY pref.security.general.lHeader "Security">
diff -r b7bcdd009540 security/manager/pki/resources/content/getpassword.xul
--- a/security/manager/pki/resources/content/getpassword.xul	Mon Sep 08 00:36:19 2008 -0700
+++ b/security/manager/pki/resources/content/getpassword.xul	Thu Sep 11 15:19:26 2008 +0300
@@ -48,17 +48,17 @@
   buttons="accept,cancel"
   ondialogaccept="return getPassword();"
   onload="onLoad();">
 
   <script type="application/x-javascript" src="chrome://pippki/content/password.js"/>
   <script type="application/x-javascript" src="chrome://global/content/strres.js"/>
 
   <hbox>
-    <label value="&getPassword.tokenName.label;:"/>
+    <label value="&getPassword.tokenName2.label;"/>
     <label id="tokenName"/>
   </hbox>
   <separator/>
   <hbox align="center">
     <label value="&getPassword.password.label;"/>
     <textbox id="pw1" type="password"/>
   </hbox>
 
diff -r b7bcdd009540 security/manager/ssl/src/nsNSSIOLayer.cpp
--- a/security/manager/ssl/src/nsNSSIOLayer.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/security/manager/ssl/src/nsNSSIOLayer.cpp	Thu Sep 11 15:19:26 2008 +0300
@@ -217,21 +217,24 @@ nsNSSSocketInfo::nsNSSSocketInfo()
     mCanceled(PR_FALSE),
     mHasCleartextPhase(PR_FALSE),
     mHandshakeInProgress(PR_FALSE),
     mAllowTLSIntoleranceTimeout(PR_TRUE),
     mHandshakeStartTime(0),
     mPort(0)
 {
   mThreadData = new nsSSLSocketThreadData;
+  mCallbacksLock = nsAutoLock::NewLock("nsNSSSocketInfo::mCallbacksLock");
 }
 
 nsNSSSocketInfo::~nsNSSSocketInfo()
 {
   delete mThreadData;
+
+  nsAutoLock::DestroyLock(mCallbacksLock);
 
   nsNSSShutDownPreventionLock locker;
   if (isAlreadyShutDown())
     return;
 
   shutdown(calledFromObject);
 }
 
@@ -323,129 +326,202 @@ PRBool nsNSSSocketInfo::GetHasCleartextP
 PRBool nsNSSSocketInfo::GetHasCleartextPhase()
 {
   return mHasCleartextPhase;
 }
 
 NS_IMETHODIMP
 nsNSSSocketInfo::GetNotificationCallbacks(nsIInterfaceRequestor** aCallbacks)
 {
-  *aCallbacks = mCallbacks;
-  NS_IF_ADDREF(*aCallbacks);
+  nsCOMPtr<nsISupports> supports;
+  {
+    nsAutoLock lock(mCallbacksLock);
+    supports = mCallbacks;
+  }
+  nsCOMPtr<nsIInterfaceRequestor> callbacks(do_QueryInterface(supports));
+  callbacks.forget(aCallbacks);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsNSSSocketInfo::SetNotificationCallbacks(nsIInterfaceRequestor* aCallbacks)
 {
-  if (!aCallbacks) {
-    mCallbacks = nsnull;
-    return NS_OK;
-  }
+  nsCOMPtr<nsISupports> callbacks(do_QueryInterface(aCallbacks));
 
-  mCallbacks = aCallbacks;
-  mDocShellDependentStuffKnown = PR_FALSE;
+  nsAutoLock lock(mCallbacksLock);
 
-  return NS_OK;
-}
-
-nsresult
-nsNSSSocketInfo::EnsureDocShellDependentStuffKnown()
-{
-  if (mDocShellDependentStuffKnown)
-    return NS_OK;
-
-  if (!mCallbacks || nsSSLThread::exitRequested())
-    return NS_ERROR_FAILURE;
-
-  mDocShellDependentStuffKnown = PR_TRUE;
-
-  nsCOMPtr<nsIInterfaceRequestor> proxiedCallbacks;
-  NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
-                       NS_GET_IID(nsIInterfaceRequestor),
-                       static_cast<nsIInterfaceRequestor*>(mCallbacks),
-                       NS_PROXY_SYNC,
-                       getter_AddRefs(proxiedCallbacks));
-
-  // Are we running within a context that wants external SSL error reporting?
-  // We'll look at the presence of a security UI object inside docshell.
-  // If the docshell wants the lock icon, you'll get the ssl error pages, too.
-  // This is helpful to distinguish from all other contexts, like mail windows,
-  // or any other SSL connections running in the background.
-  // We must query it now and remember, because fatal SSL errors will come 
-  // with a socket close, and the socket transport might detach the callbacks 
-  // instance prior to our error reporting.
-
-  nsCOMPtr<nsIDocShell> docshell;
-
-  nsCOMPtr<nsIDocShellTreeItem> item(do_GetInterface(proxiedCallbacks));
-  if (item)
-  {
-    nsCOMPtr<nsIDocShellTreeItem> proxiedItem;
-    nsCOMPtr<nsIDocShellTreeItem> rootItem;
-    NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
-                         NS_GET_IID(nsIDocShellTreeItem),
-                         item.get(),
-                         NS_PROXY_SYNC,
-                         getter_AddRefs(proxiedItem));
-
-    proxiedItem->GetSameTypeRootTreeItem(getter_AddRefs(rootItem));
-    docshell = do_QueryInterface(rootItem);
-    NS_ASSERTION(docshell, "rootItem do_QI is null");
-  }
-
-  if (docshell)
-  {
-    nsCOMPtr<nsIDocShell> proxiedDocShell;
-    NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
-                         NS_GET_IID(nsIDocShell),
-                         docshell.get(),
-                         NS_PROXY_SYNC,
-                         getter_AddRefs(proxiedDocShell));
-    nsISecureBrowserUI* secureUI;
-    proxiedDocShell->GetSecurityUI(&secureUI);
-    if (secureUI)
-    {
-      nsCOMPtr<nsIThread> mainThread(do_GetMainThread());
-      NS_ProxyRelease(mainThread, secureUI, PR_FALSE);
-      mExternalErrorReporting = PR_TRUE;
-
-      // If this socket is associated to a docshell, let's try to remember
-      // the currently used cert. If this socket gets a notification from NSS
-      // having the same raw socket, we can keep the PSM wrapper object
-      // and all the data it has cached (like verification results).
-      nsCOMPtr<nsISSLStatusProvider> statprov = do_QueryInterface(secureUI);
-      if (statprov) {
-        nsCOMPtr<nsISupports> isup_stat;
-        statprov->GetSSLStatus(getter_AddRefs(isup_stat));
-        if (isup_stat) {
-          nsCOMPtr<nsISSLStatus> sslstat = do_QueryInterface(isup_stat);
-          if (sslstat) {
-            sslstat->GetServerCert(getter_AddRefs(mPreviousCert));
-          }
-        }
-      }
-    }
+  callbacks.swap(mCallbacks);
+  if (mCallbacks) {
+    mDocShellDependentStuffKnown = PR_FALSE;
   }
 
   return NS_OK;
 }
 
+class nsGatherDocshellInfoForPSMRunnable : public nsRunnable
+{
+public:
+  nsGatherDocshellInfoForPSMRunnable(nsIInterfaceRequestor* aCallbacks,
+                                     PRBool* aExternalReporting,
+                                     nsIX509Cert** aPreviousCert)
+  : mCallbacks(aCallbacks), mExternalReporting(aExternalReporting),
+    mPreviousCert(aPreviousCert)
+  {
+    NS_ASSERTION(aCallbacks, "Null pointer!");
+  }
+
+  NS_IMETHOD Run()
+  {
+    NS_ASSERTION(NS_IsMainThread(), "Must run only on the main thread!");
+
+    *mExternalReporting = PR_FALSE;
+    *mPreviousCert = nsnull;
+
+    // Are we running within a context that wants external SSL error reporting?
+    // We'll look at the presence of a security UI object inside docshell.
+    // If the docshell wants the lock icon, you'll get the ssl error pages, too.
+    // This is helpful to distinguish from all other contexts, like mail
+    // windows, or any other SSL connections running in the background.
+    // We must query it now and remember, because fatal SSL errors will come 
+    // with a socket close, and the socket transport might detach the callbacks 
+    // instance prior to our error reporting.
+
+    nsCOMPtr<nsIDocShellTreeItem> item(do_GetInterface(mCallbacks));
+    if (!item)
+      return NS_OK;
+
+    nsCOMPtr<nsIDocShellTreeItem> rootItem;
+    item->GetSameTypeRootTreeItem(getter_AddRefs(rootItem));
+
+    nsCOMPtr<nsIDocShell> docshell(do_QueryInterface(rootItem));
+    NS_ASSERTION(docshell, "rootItem do_QI is null");
+    if (!docshell)
+      return NS_OK;
+
+    nsCOMPtr<nsISecureBrowserUI> secureUI;
+    docshell->GetSecurityUI(getter_AddRefs(secureUI));
+    if (!secureUI)
+      return NS_OK;
+
+    *mExternalReporting = PR_TRUE;
+
+    // If this socket is associated to a docshell, let's try to remember
+    // the currently used cert. If this socket gets a notification from NSS
+    // having the same raw socket, we can keep the PSM wrapper object
+    // and all the data it has cached (like verification results).
+    nsCOMPtr<nsISSLStatusProvider> statprov(do_QueryInterface(secureUI));
+    if (!statprov)
+      return NS_OK;
+
+    nsCOMPtr<nsISupports> isup_stat;
+    statprov->GetSSLStatus(getter_AddRefs(isup_stat));
+
+    nsCOMPtr<nsISSLStatus> sslstat(do_QueryInterface(isup_stat));
+    if (!sslstat)
+      return NS_OK;
+
+    sslstat->GetServerCert(mPreviousCert);
+    return NS_OK;
+  }
+
+private:
+  nsIInterfaceRequestor* mCallbacks;
+  PRBool* mExternalReporting;
+  nsIX509Cert** mPreviousCert;
+};
+
+nsresult
+nsNSSSocketInfo::EnsureDocShellDependentStuffKnown(PRBool* aExternalReporting,
+                                                   nsIX509Cert** aPreviousCert)
+{
+  do {
+    nsCOMPtr<nsISupports> origCallbacks;
+    {
+      nsAutoLock lock(mCallbacksLock);
+
+      if (mDocShellDependentStuffKnown) {
+        if (aExternalReporting) {
+          *aExternalReporting = mExternalErrorReporting;
+        }
+        if (aPreviousCert) {
+          NS_IF_ADDREF(*aPreviousCert = mPreviousCert);
+        }
+        return NS_OK;
+      }
+
+      origCallbacks = mCallbacks;
+    }
+
+    if (nsSSLThread::exitRequested() || !origCallbacks) {
+      return NS_ERROR_FAILURE;
+    }
+
+    nsCOMPtr<nsIInterfaceRequestor> callbacks(do_QueryInterface(origCallbacks));
+    NS_ASSERTION(callbacks, "How does this not QI to nsIInterfaceRequestor?!");
+
+    // We're about to touch the docshell which we know to be main-thread-only.
+    nsCOMPtr<nsIThread> mainThread(do_GetMainThread());
+    NS_ENSURE_TRUE(mainThread, NS_ERROR_FAILURE);
+
+    PRBool externalReporting = PR_FALSE;
+    nsCOMPtr<nsIX509Cert> previousCert;
+
+    nsCOMPtr<nsIRunnable> runnable =
+      new nsGatherDocshellInfoForPSMRunnable(callbacks, &externalReporting,
+                                             getter_AddRefs(previousCert));
+    NS_ENSURE_TRUE(runnable, NS_ERROR_OUT_OF_MEMORY);
+
+    nsresult rv = mainThread->Dispatch(runnable, NS_DISPATCH_SYNC);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    {
+      nsAutoLock lock(mCallbacksLock);
+
+      // Check to see if anyone replaced mCallbacks while the runnable was
+      // queued. This is why we store nsISupports in mCallbacks - otherwise we'd
+      // have to QI inside this lock.
+      if (mCallbacks == origCallbacks) {
+        // No one reset this out from under us, so go ahead and update our data.
+        mDocShellDependentStuffKnown = PR_TRUE;
+        mExternalErrorReporting = externalReporting;
+        previousCert.swap(mPreviousCert);
+
+        if (aExternalReporting) {
+          *aExternalReporting = mExternalErrorReporting;
+        }
+        if (aPreviousCert) {
+          NS_IF_ADDREF(*aPreviousCert = mPreviousCert);
+        }
+        return NS_OK;
+      }
+    }
+
+    // Someone replaced mCallbacks while we were running, try again.
+    NS_WARNING("Contention for mCallbacks, trying again");
+
+  } while(1); // Loop until we don't have contention.
+
+  NS_NOTREACHED("Should never get here");
+  return NS_ERROR_UNEXPECTED;
+}
+
 nsresult
 nsNSSSocketInfo::GetExternalErrorReporting(PRBool* state)
 {
-  nsresult rv = EnsureDocShellDependentStuffKnown();
+  NS_ENSURE_ARG_POINTER(state);
+  nsresult rv = EnsureDocShellDependentStuffKnown(state);
   NS_ENSURE_SUCCESS(rv, rv);
-  *state = mExternalErrorReporting;
+
   return NS_OK;
 }
 
 nsresult
 nsNSSSocketInfo::SetExternalErrorReporting(PRBool aState)
 {
+  nsAutoLock lock(mCallbacksLock);
   mExternalErrorReporting = aState;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsNSSSocketInfo::GetSecurityState(PRUint32* state)
 {
   *state = mSecurityState;
@@ -539,37 +615,43 @@ nsNSSSocketInfo::SetErrorMessage(const P
 nsNSSSocketInfo::SetErrorMessage(const PRUnichar* aText) {
   mErrorMessage.Assign(aText);
   return NS_OK;
 }
 
 /* void getInterface (in nsIIDRef uuid, [iid_is (uuid), retval] out nsQIResult result); */
 NS_IMETHODIMP nsNSSSocketInfo::GetInterface(const nsIID & uuid, void * *result)
 {
-  nsresult rv;
-  if (!mCallbacks) {
-    nsCOMPtr<nsIInterfaceRequestor> ir = new PipUIContext();
-    if (!ir)
-      return NS_ERROR_OUT_OF_MEMORY;
+  nsCOMPtr<nsISupports> callbacks;
 
-    rv = ir->GetInterface(uuid, result);
-  } else {
+  {
+    nsAutoLock lock(mCallbacksLock);
+    callbacks = mCallbacks;
+  }
+
+  if (callbacks) {
+    // XXX Shouldn't we check this even if callbacks is null?
     if (nsSSLThread::exitRequested())
       return NS_ERROR_FAILURE;
 
     nsCOMPtr<nsIInterfaceRequestor> proxiedCallbacks;
-    NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
-                         NS_GET_IID(nsIInterfaceRequestor),
-                         mCallbacks,
-                         NS_PROXY_SYNC,
-                         getter_AddRefs(proxiedCallbacks));
+    nsresult rv = NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
+                                       NS_GET_IID(nsIInterfaceRequestor),
+                                       callbacks,
+                                       NS_PROXY_SYNC,
+                                       getter_AddRefs(proxiedCallbacks));
+    NS_ENSURE_SUCCESS(rv, rv);
 
-    rv = proxiedCallbacks->GetInterface(uuid, result);
+    return proxiedCallbacks->GetInterface(uuid, result);
   }
-  return rv;
+
+  nsCOMPtr<nsIInterfaceRequestor> ir = new PipUIContext();
+  NS_ENSURE_TRUE(ir, NS_ERROR_OUT_OF_MEMORY);
+
+  return ir->GetInterface(uuid, result);
 }
 
 nsresult
 nsNSSSocketInfo::GetForSTARTTLS(PRBool* aForSTARTTLS)
 {
   *aForSTARTTLS = mForSTARTTLS;
   return NS_OK;
 }
@@ -708,21 +790,18 @@ nsresult nsNSSSocketInfo::SetFileDescPtr
 {
   mFd = aFilePtr;
   return NS_OK;
 }
 
 nsresult nsNSSSocketInfo::GetPreviousCert(nsIX509Cert** _result)
 {
   NS_ENSURE_ARG_POINTER(_result);
-  nsresult rv = EnsureDocShellDependentStuffKnown();
+  nsresult rv = EnsureDocShellDependentStuffKnown(nsnull, _result);
   NS_ENSURE_SUCCESS(rv, rv);
-
-  *_result = mPreviousCert;
-  NS_IF_ADDREF(*_result);
 
   return NS_OK;
 }
 
 nsresult nsNSSSocketInfo::GetCert(nsIX509Cert** _result)
 {
   NS_ENSURE_ARG_POINTER(_result);
 
diff -r b7bcdd009540 security/manager/ssl/src/nsNSSIOLayer.h
--- a/security/manager/ssl/src/nsNSSIOLayer.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/security/manager/ssl/src/nsNSSIOLayer.h	Thu Sep 11 15:19:26 2008 +0300
@@ -38,16 +38,17 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef _NSNSSIOLAYER_H
 #define _NSNSSIOLAYER_H
 
 #include "prtypes.h"
 #include "prio.h"
+#include "prlock.h"
 #include "certt.h"
 #include "nsString.h"
 #include "nsIInterfaceRequestor.h"
 #include "nsIInterfaceRequestorUtils.h"
 #include "nsITransportSecurityInfo.h"
 #include "nsISSLSocketControl.h"
 #include "nsSSLStatus.h"
 #include "nsISSLStatusProvider.h"
@@ -196,17 +197,17 @@ public:
   /* Set SSL Status values */
   nsresult SetSSLStatus(nsSSLStatus *aSSLStatus);
   nsSSLStatus* SSLStatus() { return mSSLStatus; }
   PRBool hasCertErrors();
   
   PRStatus CloseSocketAndDestroy();
   
 protected:
-  nsCOMPtr<nsIInterfaceRequestor> mCallbacks;
+  nsCOMPtr<nsISupports> mCallbacks;
   PRFileDesc* mFd;
   nsCOMPtr<nsIX509Cert> mCert;
   nsCOMPtr<nsIX509Cert> mPreviousCert; // DocShellDependent
   enum { 
     blocking_state_unknown, is_nonblocking_socket, is_blocking_socket 
   } mBlockingState;
   PRUint32 mSecurityState;
   PRInt32 mSubRequestsHighSecurity;
@@ -230,17 +231,23 @@ protected:
 
   /* SSL Status */
   nsRefPtr<nsSSLStatus> mSSLStatus;
 
   nsresult ActivateSSL();
 
   nsSSLSocketThreadData *mThreadData;
 
-  nsresult EnsureDocShellDependentStuffKnown();
+  // This lock will protect mCallbacks, mDocShellDependentStuffKnown,
+  // mExternalErrorReporting, and mPreviousCert from concurrent changes.
+  PRLock* mCallbacksLock;
+
+  nsresult
+  EnsureDocShellDependentStuffKnown(PRBool* aExternalReporting = nsnull,
+                                    nsIX509Cert** aPreviousCert = nsnull);
 
 private:
   virtual void virtualDestroyNSSReference();
   void destructorSafeDestroyNSSReference();
 
 friend class nsSSLThread;
 };
 
diff -r b7bcdd009540 testing/mochitest/Makefile.in
--- a/testing/mochitest/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/testing/mochitest/Makefile.in	Thu Sep 11 15:19:26 2008 +0300
@@ -128,13 +128,10 @@ automation.py: $(topsrcdir)/build/pgo/au
 	$(PYTHON) $(topsrcdir)/config/Preprocessor.py \
 	$(TEST_DRIVER_PPARGS) $(DEFINES) $(ACDEFINES) $^ > $@
 
 GARBAGE += runtests.py automation.py
 
 libs:: $(_SERV_FILES)
 	$(INSTALL) $^ $(_DEST_DIR)
 
-#XXX: need to fix bug 447642
-ifdef ENABLE_TESTS
 libs::
 	$(PYTHON) $(DEPTH)/_profile/pgo/genpgocert.py --gen-server
-endif
\ No newline at end of file
diff -r b7bcdd009540 toolkit/components/Makefile.in
--- a/toolkit/components/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/toolkit/components/Makefile.in	Thu Sep 11 15:19:26 2008 +0300
@@ -103,19 +103,16 @@ DIRS += \
 	$(NULL)
 endif # MOZ_XUL
 
 ifdef MOZ_SUITE
 # Suite can't use passwordmgr because mail still depends on wallet (bug 239131)
 DIRS += passwordmgr/public
 else
 DIRS += passwordmgr
-ifndef MOZ_PLACES
-DIRS +=	history
-endif # MOZ_PLACES
 endif # MOZ_SUITE
 endif # MOZ_THUNDERBIRD
 
 ifndef SUITE_USING_XPFE_DM
 ifdef MOZ_RDF
 DIRS +=	downloads
 endif
 endif # SUITE_USING_XPFE_DM
diff -r b7bcdd009540 toolkit/components/console/content/console.xul
--- a/toolkit/components/console/content/console.xul	Mon Sep 08 00:36:19 2008 -0700
+++ b/toolkit/components/console/content/console.xul	Thu Sep 11 15:19:27 2008 +0300
@@ -54,16 +54,17 @@
         windowtype="global:console"
         width="640" height="480"
         screenX="10" screenY="10"
         persist="screenX screenY width height sizemode"
         onclose="return closeWindow(false);"> 
 
   <script type="application/javascript" src="chrome://global/content/globalOverlay.js"/>
   <script type="application/javascript" src="chrome://global/content/console.js"/>
+  <script type="application/javascript" src="chrome://global/content/viewSourceUtils.js"/>
 
   <stringbundle id="ConsoleBundle" src="chrome://global/locale/console.properties"/>
 
   <commandset id="editMenuCommands"/>
 
   <commandset id="consoleCommands">
     <command id="cmd_close" oncommand="closeWindow(true)"/>
   </commandset>
diff -r b7bcdd009540 toolkit/components/console/content/consoleBindings.xml
--- a/toolkit/components/console/content/consoleBindings.xml	Mon Sep 08 00:36:19 2008 -0700
+++ b/toolkit/components/console/content/consoleBindings.xml	Thu Sep 11 15:19:27 2008 +0300
@@ -420,19 +420,17 @@
     <content>
       <xul:label class="text-link" xbl:inherits="href,value=href" crop="right"/>
     </content>
 
     <handlers>
       <handler event="click" phase="capturing" button="0" preventdefault="true">
         <![CDATA[
           var url = this.getAttribute("href");
-          var line = getAttribute("line");  
-          window.openDialog(
-            "chrome://global/content/viewSource.xul", "_blank", 
-            "all,dialog=no", url, null, null, line, false);
+          var line = getAttribute("line");
+          gViewSourceUtils.viewSource(url, null, null, line);
         ]]>
       </handler>
     </handlers>
   </binding>
 
 </bindings>
 
diff -r b7bcdd009540 toolkit/components/cookie/content/contents.rdf
--- a/toolkit/components/cookie/content/contents.rdf	Mon Sep 08 00:36:19 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,18 +0,0 @@
-<?xml version="1.0"?>
-<RDF:RDF xmlns:RDF="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-         xmlns:chrome="http://www.mozilla.org/rdf/chrome#">
-
-  <!-- list all the packages being supplied by this jar -->
-  <RDF:Seq about="urn:mozilla:package:root">
-    <RDF:li resource="urn:mozilla:package:cookie"/>
-  </RDF:Seq>
-
-  <!-- package information -->
-  <RDF:Description about="urn:mozilla:package:cookie"
-        chrome:displayName="Cookie Manager"
-        chrome:author="mozilla.org"
-        chrome:name="cookie"
-#expand  	chrome:localeVersion="__MOZILLA_LOCALE_VERSION__">
-  </RDF:Description>
-
-</RDF:RDF>
diff -r b7bcdd009540 toolkit/components/history/Makefile.in
--- a/toolkit/components/history/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,52 +0,0 @@
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is mozilla.org code.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-DEPTH		= ../../..
-topsrcdir	= @top_srcdir@
-srcdir		= @srcdir@
-VPATH		= @srcdir@
-
-include $(DEPTH)/config/autoconf.mk
-
-DIRS = public
-
-ifndef MOZ_PLACES
-DIRS += src
-endif
-
-include $(topsrcdir)/config/rules.mk
-
diff -r b7bcdd009540 toolkit/components/history/public/Makefile.in
--- a/toolkit/components/history/public/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,53 +0,0 @@
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is mozilla.org code.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#   Joe Hewitt <hewitt@netscape.com> (Original Author)
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-DEPTH = ../../../..
-topsrcdir = @top_srcdir@
-srcdir = @srcdir@
-VPATH = @srcdir@
-
-include $(DEPTH)/config/autoconf.mk
-
-MODULE = history
-XPIDL_MODULE = history
-
-XPIDLSRCS  = \
-  nsIBrowserHistory.idl \
-  $(NULL)
-
-include $(topsrcdir)/config/rules.mk
diff -r b7bcdd009540 toolkit/components/history/public/nsIBrowserHistory.idl
--- a/toolkit/components/history/public/nsIBrowserHistory.idl	Mon Sep 08 00:36:19 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,108 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 1998
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-/*
- * browser-specific interface to global history
- */
-
-#include "nsISupports.idl"
-#include "nsIGlobalHistory2.idl"
-
-[scriptable, uuid(c43079c3-3d8d-4b7c-af14-0e30ab46865f)]
-interface nsIBrowserHistory : nsIGlobalHistory2
-{
-    /** 
-     * addPageWithDetails
-     * Adds a page to history with specific time stamp information. This is used in
-     * the History migrator. 
-     */
-    void addPageWithDetails(in nsIURI aURI, in wstring aTitle, in long long aLastVisited);
-
-    /**
-     * lastPageVisited
-     * The last page that was visited in a top-level window.
-     */
-    readonly attribute AUTF8String lastPageVisited;
-
-    /**
-     * count
-     * The number of entries in global history
-     */
-    readonly attribute PRUint32 count;
-
-    /**
-     * remove a page from history
-     */
-    void removePage(in nsIURI aURI);
-
-    /**
-     * removePagesFromHost
-     * Remove all pages from the given host.
-     * If aEntireDomain is true, will assume aHost is a domain,
-     * and remove all pages from the entire domain.
-     */
-    void removePagesFromHost(in AUTF8String aHost, in boolean aEntireDomain);
-
-    /**
-     * removeAllPages
-     * Remove all pages from global history
-     */
-    void removeAllPages();
-
-    /**
-     * hidePage
-     * Hide the specified URL from being enumerated (and thus
-     * displayed in the UI)
-     *
-     * if the page hasn't been visited yet, then it will be added
-     * as if it was visited, and then marked as hidden
-     */
-    void hidePage(in nsIURI aURI);
-
-    /**
-     * This is just like markPageAsFollowedBookmark (in nsINavHistory, 
-     * also implemented by the history service), but for URLs that a
-     * user visits from the chrome that are not bookmarks, such as a
-     * URL that is typed in the URL bar or clicking on a link in the 
-     * history menu or history sidebar.   It declares that the given URI
-     * is treated as if they typed the URL into the URL bar (which
-     * get more weight in our URL bar autocomplete algorithm.)
-     * If this URI is loaded soon after this message has been received, 
-     * that transition will be marked as typed.
-     */
-    void markPageAsTyped(in nsIURI aURI);
-};
diff -r b7bcdd009540 toolkit/components/history/src/Makefile.in
--- a/toolkit/components/history/src/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,75 +0,0 @@
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is mozilla.org code.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#   Joe Hewitt <hewitt@netscape.com> (Original Author)
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-DEPTH = ../../../..
-topsrcdir = @top_srcdir@
-srcdir = @srcdir@
-VPATH = @srcdir@
-
-include $(DEPTH)/config/autoconf.mk
-
-MODULE = history
-LIBRARY_NAME  = tkhstory
-IS_COMPONENT = 1
-MODULE_NAME = nsToolkitHistory
-LIBXUL_LIBRARY = 1
-EXPORT_LIBRARY = 1
-
-REQUIRES = xpcom \
-           string \
-           docshell \
-           rdf \
-           mork \
-           pref \
-           necko \
-           intl \
-           unicharutil \
-           autocomplete \
-           uconv \
-           toolkitcomps \
-           $(NULL)
-
-CPPSRCS = nsGlobalHistory.cpp  \
-          $(NULL)
-
-include $(topsrcdir)/config/rules.mk
-
-EXTRA_DSO_LDOPTS += \
-	$(MOZ_UNICHARUTIL_LIBS) \
-	$(MOZ_COMPONENT_LIBS) \
-	$(NULL)
diff -r b7bcdd009540 toolkit/components/history/src/nsGlobalHistory.cpp
--- a/toolkit/components/history/src/nsGlobalHistory.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,4642 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 1998
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Chris Waterson <waterson@netscape.com>
- *   Pierre Phaneuf <pp@ludusdesign.com>
- *   Joe Hewitt <hewitt@netscape.com>
- *   Blake Ross <blaker@netscape.com>
- *   Chris Sears <cbsears_sf@yahoo.com>
- *   Michael Lowe <michael.lowe@bigfoot.com>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-/*
-
-  A global browser history implementation that also supports the RDF
-  datasource interface.
-
-  TODO
-
-  1) Hook up Assert() etc. so that we can delete stuff.
-
-*/
-#include "nsNetUtil.h"
-#include "nsGlobalHistory.h"
-#include "nsCRT.h"
-#include "nsIEnumerator.h"
-#include "nsIServiceManager.h"
-#include "nsEnumeratorUtils.h"
-#include "nsRDFCID.h"
-#include "nsIDirectoryService.h"
-#include "nsAppDirectoryServiceDefs.h"
-#include "nsString.h"
-#include "nsReadableUtils.h"
-#include "nsUnicharUtils.h"
-#include "nsXPIDLString.h"
-#include "plhash.h"
-#include "plstr.h"
-#include "prprf.h"
-#include "prtime.h"
-#include "rdf.h"
-#include "nsCOMArray.h"
-#include "nsIIOService.h"
-#include "nsILocalFile.h"
-
-#include "nsIURL.h"
-#include "nsNetCID.h"
-
-#include "nsInt64.h"
-#include "nsMorkCID.h"
-#include "nsIMdbFactoryFactory.h"
-
-#include "nsIPrefService.h"
-#include "nsIPrefBranch2.h"
-
-#include "nsIObserverService.h"
-#include "nsITextToSubURI.h"
-
-#include "nsIGenericFactory.h"
-#include "nsToolkitCompsCID.h"
-#include "nsDocShellCID.h"
-
-PRInt32 nsGlobalHistory::gRefCnt;
-nsIRDFService* nsGlobalHistory::gRDFService;
-nsIRDFResource* nsGlobalHistory::kNC_Page;
-nsIRDFResource* nsGlobalHistory::kNC_Date;
-nsIRDFResource* nsGlobalHistory::kNC_FirstVisitDate;
-nsIRDFResource* nsGlobalHistory::kNC_VisitCount;
-nsIRDFResource* nsGlobalHistory::kNC_AgeInDays;
-nsIRDFResource* nsGlobalHistory::kNC_Name;
-nsIRDFResource* nsGlobalHistory::kNC_NameSort;
-nsIRDFResource* nsGlobalHistory::kNC_Hostname;
-nsIRDFResource* nsGlobalHistory::kNC_Referrer;
-nsIRDFResource* nsGlobalHistory::kNC_child;
-nsIRDFResource* nsGlobalHistory::kNC_URL;
-nsIRDFResource* nsGlobalHistory::kNC_HistoryRoot;
-nsIRDFResource* nsGlobalHistory::kNC_HistoryByDateAndSite;
-nsIRDFResource* nsGlobalHistory::kNC_HistoryByDate;
-nsIRDFResource* nsGlobalHistory::kNC_DayFolderIndex;
-nsIMdbFactory* nsGlobalHistory::gMdbFactory = nsnull;
-nsIPrefBranch* nsGlobalHistory::gPrefBranch = nsnull;
-
-#define PREF_BRANCH_BASE                        "browser."
-#define PREF_BROWSER_HISTORY_EXPIRE_DAYS        "history_expire_days"
-#define PREF_AUTOCOMPLETE_ONLY_TYPED            "urlbar.matchOnlyTyped"
-#define PREF_AUTOCOMPLETE_ENABLED               "urlbar.autocomplete.enabled"
-
-#define FIND_BY_AGEINDAYS_PREFIX "find:datasource=history&match=AgeInDays&method="
-
-// see bug #319004 -- clamp title and URL to generously-large but not too large
-// length
-#define HISTORY_URI_LENGTH_MAX 65536
-#define HISTORY_TITLE_LENGTH_MAX 4096
-
-// sync history every 10 seconds
-#define HISTORY_SYNC_TIMEOUT (10 * PR_MSEC_PER_SEC)
-//#define HISTORY_SYNC_TIMEOUT 3000 // every 3 seconds - testing only!
-
-// the value of mLastNow expires every 3 seconds
-#define HISTORY_EXPIRE_NOW_TIMEOUT (3 * PR_MSEC_PER_SEC)
-
-#define MSECS_PER_DAY (PR_MSEC_PER_SEC * 60 * 60 * 24)
-
-//----------------------------------------------------------------------
-//
-// CIDs
-
-static NS_DEFINE_CID(kRDFServiceCID,        NS_RDFSERVICE_CID);
-
-// closure structures for RemoveMatchingRows
-struct matchExpiration_t {
-  PRTime *expirationDate;
-  nsGlobalHistory *history;
-};
-
-struct matchHost_t {
-  const char *host;
-  PRBool entireDomain;          // should we delete the entire domain?
-  nsGlobalHistory *history;
-};
-
-struct matchSearchTerm_t {
-  nsIMdbEnv *env;
-  nsIMdbStore *store;
-  
-  searchTerm *term;
-  PRBool haveClosure;           // are the rest of the fields valid?
-  PRTime now;
-  PRInt32 intValue;
-};
-
-struct matchQuery_t {
-  searchQuery* query;
-  nsGlobalHistory* history;
-};
-
-// simple token/value struct
-class tokenPair {
-public:
-  tokenPair(const char *aName, PRUint32 aNameLen,
-            const char *aValue, PRUint32 aValueLen) :
-    tokenName(aName), tokenNameLength(aNameLen),
-    tokenValue(aValue), tokenValueLength(aValueLen) { MOZ_COUNT_CTOR(tokenPair); }
-  ~tokenPair() { MOZ_COUNT_DTOR(tokenPair); }
-  const char* tokenName;
-  PRUint32 tokenNameLength;
-  const char* tokenValue;
-  PRUint32 tokenValueLength;
-};
-
-// individual search term, pulled from token/value structs
-class searchTerm {
-public:
-  searchTerm(const char* aDatasource, PRUint32 aDatasourceLen,
-             const char *aProperty, PRUint32 aPropertyLen,
-             const char* aMethod, PRUint32 aMethodLen,
-             const char* aText, PRUint32 aTextLen):
-    datasource(aDatasource, aDatasource+aDatasourceLen),
-    property(aProperty, aProperty+aPropertyLen),
-    method(aMethod, aMethod+aMethodLen)
-  {
-    MOZ_COUNT_CTOR(searchTerm);
-    nsresult rv;
-    nsCOMPtr<nsITextToSubURI> textToSubURI = do_GetService(NS_ITEXTTOSUBURI_CONTRACTID, &rv);
-    if (NS_SUCCEEDED(rv))
-      textToSubURI->UnEscapeAndConvert("UTF-8", PromiseFlatCString(Substring(aText, aText + aTextLen)).get(), getter_Copies(text));
-  }
-  ~searchTerm() {
-    MOZ_COUNT_DTOR(searchTerm);
-  }
-  
-  nsDependentCSubstring datasource;  // should always be "history" ?
-  nsDependentCSubstring property;    // AgeInDays, Hostname, etc
-  nsDependentCSubstring method;      // is, isgreater, isless
-  nsXPIDLString text;          // text to match
-  rowMatchCallback match;      // matching callback if needed
-};
-
-// list of terms, plus an optional groupby column
-struct searchQuery {
-  nsVoidArray terms;            // array of searchTerms
-  mdb_column groupBy;           // column to group by
-};
-
-static PRBool HasCell(nsIMdbEnv *aEnv, nsIMdbRow* aRow, mdb_column aCol)
-{
-  mdbYarn yarn;
-  mdb_err err = aRow->AliasCellYarn(aEnv, aCol, &yarn);
-
-  // no cell
-  if (err != 0)
-    return PR_FALSE;
-
-  // if we have the cell, make sure it has a value??
-  return (yarn.mYarn_Fill != 0);
-}
-
-static PRTime
-NormalizeTime(PRTime aTime)
-{
-  // normalize both now and date to midnight of the day they occur on
-  PRExplodedTime explodedTime;
-  PR_ExplodeTime(aTime, PR_LocalTimeParameters, &explodedTime);
-
-  // set to midnight (0:00)
-  explodedTime.tm_min =
-    explodedTime.tm_hour =
-    explodedTime.tm_sec =
-    explodedTime.tm_usec = 0;
-
-  return PR_ImplodeTime(&explodedTime);
-}
-
-// pass in a pre-normalized now and a date, and we'll find
-// the difference since midnight on each of the days..
-static PRInt32
-GetAgeInDays(PRTime aNormalizedNow, PRTime aDate)
-{
-  PRTime dateMidnight = NormalizeTime(aDate);
-
-  PRTime diff;
-  LL_SUB(diff, aNormalizedNow, dateMidnight);
-
-  // two-step process since I can't seem to load
-  // MSECS_PER_DAY * PR_MSEC_PER_SEC into a PRInt64 at compile time
-  PRInt64 msecPerSec;
-  LL_I2L(msecPerSec, PR_MSEC_PER_SEC);
-  PRInt64 ageInSeconds;
-  LL_DIV(ageInSeconds, diff, msecPerSec);
-
-  PRInt32 ageSec; LL_L2I(ageSec, ageInSeconds);
-  
-  PRInt64 msecPerDay;
-  LL_I2L(msecPerDay, MSECS_PER_DAY);
-  
-  PRInt64 ageInDays;
-  LL_DIV(ageInDays, ageInSeconds, msecPerDay);
-
-  PRInt32 retval;
-  LL_L2I(retval, ageInDays);
-  return retval;
-}
-
-
-PRBool
-nsGlobalHistory::MatchExpiration(nsIMdbRow *row, PRTime* expirationDate)
-{
-  nsresult rv;
-  
-  // hidden and typed urls always match because they're invalid,
-  // so we want to expire them asap.  (if they were valid, they'd
-  // have been unhidden -- see AddExistingPageToDatabase)
-  if (HasCell(mEnv, row, kToken_HiddenColumn) && HasCell(mEnv, row, kToken_TypedColumn))
-    return PR_TRUE;
-
-  PRTime lastVisitedTime;
-  rv = GetRowValue(row, kToken_LastVisitDateColumn, &lastVisitedTime);
-
-  if (NS_FAILED(rv)) 
-    return PR_FALSE;
-  
-  return LL_CMP(lastVisitedTime, <, *expirationDate);
-}
-
-static PRBool
-matchAgeInDaysCallback(nsIMdbRow *row, void *aClosure)
-{
-  matchSearchTerm_t *matchSearchTerm = (matchSearchTerm_t*)aClosure;
-  const searchTerm *term = matchSearchTerm->term;
-  nsIMdbEnv *env = matchSearchTerm->env;
-  nsIMdbStore *store = matchSearchTerm->store;
-  
-  // fill in the rest of the closure if it's not filled in yet
-  // this saves us from recalculating this stuff on every row
-  if (!matchSearchTerm->haveClosure) {
-    PRInt32 err;
-    // Need to create an nsAutoString to use ToInteger
-    matchSearchTerm->intValue = nsAutoString(term->text).ToInteger(&err);
-    matchSearchTerm->now = NormalizeTime(PR_Now());
-    if (err != 0) return PR_FALSE;
-    matchSearchTerm->haveClosure = PR_TRUE;
-  }
-  
-  // XXX convert the property to a column, get the column value
-
-  mdb_column column;
-  mdb_err err = store->StringToToken(env, "LastVisitDate", &column);
-  if (err != 0) return PR_FALSE;
-
-  mdbYarn yarn;
-  err = row->AliasCellYarn(env, column, &yarn);
-  if (err != 0) return PR_FALSE;
-  
-  PRTime rowDate;
-  PR_sscanf((const char*)yarn.mYarn_Buf, "%lld", &rowDate);
-
-  PRInt32 days = GetAgeInDays(matchSearchTerm->now, rowDate);
-  
-  if (term->method.Equals("is"))
-    return (days == matchSearchTerm->intValue);
-  else if (term->method.Equals("isgreater"))
-    return (days >  matchSearchTerm->intValue);
-  else if (term->method.Equals("isless"))
-    return (days <  matchSearchTerm->intValue);
-  
-  return PR_FALSE;
-}
-
-static PRBool
-matchExpirationCallback(nsIMdbRow *row, void *aClosure)
-{
-  matchExpiration_t *expires = (matchExpiration_t*)aClosure;
-  return expires->history->MatchExpiration(row, expires->expirationDate);
-}
-
-static PRBool
-matchAllCallback(nsIMdbRow *row, void *aClosure)
-{
-  return PR_TRUE;
-}
-
-static PRBool
-matchHostCallback(nsIMdbRow *row, void *aClosure)
-{
-  matchHost_t *hostInfo = (matchHost_t*)aClosure;
-  return hostInfo->history->MatchHost(row, hostInfo);
-}
-
-static PRBool
-matchQueryCallback(nsIMdbRow *row, void *aClosure)
-{
-  matchQuery_t *query = (matchQuery_t*)aClosure;
-  return query->history->RowMatches(row, query->query, PR_TRUE);
-}
-//----------------------------------------------------------------------
-
-nsMdbTableEnumerator::nsMdbTableEnumerator()
-  : mEnv(nsnull),
-    mTable(nsnull),
-    mCursor(nsnull),
-    mCurrent(nsnull)
-{
-}
-
-
-nsresult
-nsMdbTableEnumerator::Init(nsIMdbEnv* aEnv,
-                           nsIMdbTable* aTable)
-{
-  NS_PRECONDITION(aEnv != nsnull, "null ptr");
-  if (! aEnv)
-    return NS_ERROR_NULL_POINTER;
-
-  NS_PRECONDITION(aTable != nsnull, "null ptr");
-  if (! aTable)
-    return NS_ERROR_NULL_POINTER;
-
-  mEnv = aEnv;
-  NS_ADDREF(mEnv);
-
-  mTable = aTable;
-  NS_ADDREF(mTable);
-
-  mdb_err err;
-  err = mTable->GetTableRowCursor(mEnv, -1, &mCursor);
-  if (err != 0) return NS_ERROR_FAILURE;
-
-  return NS_OK;
-}
-
-
-nsMdbTableEnumerator::~nsMdbTableEnumerator()
-{
-  NS_IF_RELEASE(mCurrent);
-
-  NS_IF_RELEASE(mCursor);
-
-  NS_IF_RELEASE(mTable);
-
-  NS_IF_RELEASE(mEnv);
-}
-
-
-NS_IMPL_ISUPPORTS1(nsMdbTableEnumerator, nsISimpleEnumerator)
-
-NS_IMETHODIMP
-nsMdbTableEnumerator::HasMoreElements(PRBool* _result)
-{
-  if (! mCurrent) {
-    mdb_err err;
-
-    while (1) {
-      mdb_pos pos;
-      err = mCursor->NextRow(mEnv, &mCurrent, &pos);
-      if (err != 0) return NS_ERROR_FAILURE;
-
-      // If there are no more rows, then bail.
-      if (! mCurrent)
-        break;
-
-      // If this is a result, the stop.
-      if (IsResult(mCurrent))
-        break;
-
-      // Otherwise, drop the ref to the row we retrieved, and continue
-      // on to the next one.
-      NS_RELEASE(mCurrent);
-      mCurrent = nsnull;
-    }
-  }
-
-  *_result = (mCurrent != nsnull);
-  return NS_OK;
-}
-
-
-NS_IMETHODIMP
-nsMdbTableEnumerator::GetNext(nsISupports** _result)
-{
-  nsresult rv;
-
-  PRBool hasMore;
-  rv = HasMoreElements(&hasMore);
-  if (NS_FAILED(rv)) return rv;
-
-  if (! hasMore)
-    return NS_ERROR_UNEXPECTED;
-
-  rv = ConvertToISupports(mCurrent, _result);
-
-  NS_RELEASE(mCurrent);
-  mCurrent = nsnull;
-
-  return rv;
-}
-
-
-//----------------------------------------------------------------------
-//
-// nsGlobalHistory
-//
-//   ctor dtor etc.
-//
-
-
-nsGlobalHistory::nsGlobalHistory()
-  : mExpireDays(9), // make default be nine days
-    mAutocompleteOnlyTyped(PR_FALSE),
-    mBatchesInProgress(0),
-    mNowValid(PR_FALSE),
-    mDirty(PR_FALSE),
-    mEnv(nsnull),
-    mStore(nsnull),
-    mTable(nsnull)
-{
-  LL_I2L(mFileSizeOnDisk, 0);
-  
-  // commonly used prefixes that should be chopped off all 
-  // history and input urls before comparison
-
-  mIgnoreSchemes.AppendString(NS_LITERAL_STRING("http://"));
-  mIgnoreSchemes.AppendString(NS_LITERAL_STRING("https://"));
-  mIgnoreSchemes.AppendString(NS_LITERAL_STRING("ftp://"));
-  mIgnoreHostnames.AppendString(NS_LITERAL_STRING("www."));
-  mIgnoreHostnames.AppendString(NS_LITERAL_STRING("ftp."));
-  
-  mTypedHiddenURIs.Init(3);
-}
-
-nsGlobalHistory::~nsGlobalHistory()
-{
-  gRDFService->UnregisterDataSource(this);
-
-  nsresult rv;
-  rv = CloseDB();
-
-  NS_IF_RELEASE(mTable);
-  NS_IF_RELEASE(mStore);
-  
-  if (--gRefCnt == 0) {
-    NS_IF_RELEASE(gRDFService);
-
-    NS_IF_RELEASE(kNC_Page);
-    NS_IF_RELEASE(kNC_Date);
-    NS_IF_RELEASE(kNC_FirstVisitDate);
-    NS_IF_RELEASE(kNC_VisitCount);
-    NS_IF_RELEASE(kNC_AgeInDays);
-    NS_IF_RELEASE(kNC_Name);
-    NS_IF_RELEASE(kNC_NameSort);
-    NS_IF_RELEASE(kNC_Hostname);
-    NS_IF_RELEASE(kNC_Referrer);
-    NS_IF_RELEASE(kNC_child);
-    NS_IF_RELEASE(kNC_URL);
-    NS_IF_RELEASE(kNC_HistoryRoot);
-    NS_IF_RELEASE(kNC_HistoryByDateAndSite);
-    NS_IF_RELEASE(kNC_HistoryByDate);
-    NS_IF_RELEASE(kNC_DayFolderIndex);
-    
-    NS_IF_RELEASE(gMdbFactory);
-    NS_IF_RELEASE(gPrefBranch);
-  }
-
-  NS_IF_RELEASE(mEnv);
-  if (mSyncTimer)
-    mSyncTimer->Cancel();
-
-  if (mExpireNowTimer)
-    mExpireNowTimer->Cancel();
-
-}
-
-
-
-//----------------------------------------------------------------------
-//
-// nsGlobalHistory
-//
-//   nsISupports methods
-
-NS_IMPL_CYCLE_COLLECTION_CLASS(nsGlobalHistory)
-NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsGlobalHistory)
-  NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMARRAY(mObservers)
-NS_IMPL_CYCLE_COLLECTION_UNLINK_END
-NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsGlobalHistory)
-  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mObservers)
-NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
-
-
-NS_IMPL_CYCLE_COLLECTING_ADDREF_AMBIGUOUS(nsGlobalHistory, nsIBrowserHistory)
-NS_IMPL_CYCLE_COLLECTING_RELEASE_AMBIGUOUS(nsGlobalHistory, nsIBrowserHistory)
-
-NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsGlobalHistory)
-  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsIGlobalHistory2, nsIGlobalHistory3)
-  NS_INTERFACE_MAP_ENTRY(nsIGlobalHistory3)
-  NS_INTERFACE_MAP_ENTRY(nsIBrowserHistory)
-  NS_INTERFACE_MAP_ENTRY(nsIObserver)
-  NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
-  NS_INTERFACE_MAP_ENTRY(nsIRDFDataSource)
-  NS_INTERFACE_MAP_ENTRY(nsIRDFRemoteDataSource)
-  NS_INTERFACE_MAP_ENTRY(nsIAutoCompleteSearch)
-  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIBrowserHistory)
-NS_INTERFACE_MAP_END
-
-//----------------------------------------------------------------------
-//
-// nsGlobalHistory
-//
-//   nsIGlobalHistory2 methods
-//
-
-NS_IMETHODIMP
-nsGlobalHistory::AddURI(nsIURI *aURI, PRBool aRedirect, PRBool aTopLevel, nsIURI *aReferrer)
-{
-  PRTime now = GetNow();
-
-  return AddPageToDatabase(aURI, aRedirect, aTopLevel, now, aReferrer);
-}
-
-nsresult
-nsGlobalHistory::AddPageToDatabase(nsIURI* aURI, PRBool aRedirect, PRBool aTopLevel,
-                                   PRTime aLastVisitDate, nsIURI *aReferrer)
-{
-  nsresult rv;
-  NS_ENSURE_ARG_POINTER(aURI);
-
-  // If history is set to expire after 0 days,
-  // then it's technically disabled. Don't even
-  // bother adding the page
-  if (mExpireDays == 0) {
-    NS_WARNING("mExpireDays == 0");
-    return NS_OK;
-  }
-
-  // filter out unwanted URIs such as chrome: mailbox: etc
-  // The model is really if we don't know differently then add which basically
-  // means we are suppose to try all the things we know not to allow in and
-  // then if we don't bail go on and allow it in.  But here lets compare
-  // against the most common case we know to allow in and go on and say yes
-  // to it.
-
-  PRBool isHTTP = PR_FALSE;
-  PRBool isHTTPS = PR_FALSE;
-
-  NS_ENSURE_SUCCESS(rv = aURI->SchemeIs("http", &isHTTP), rv);
-  NS_ENSURE_SUCCESS(rv = aURI->SchemeIs("https", &isHTTPS), rv);
-
-  if (!isHTTP && !isHTTPS) {
-    PRBool isAbout, isImap, isNews, isMailbox, isViewSource, isChrome, isData;
-
-    rv = aURI->SchemeIs("about", &isAbout);
-    rv |= aURI->SchemeIs("imap", &isImap);
-    rv |= aURI->SchemeIs("news", &isNews);
-    rv |= aURI->SchemeIs("mailbox", &isMailbox);
-    rv |= aURI->SchemeIs("view-source", &isViewSource);
-    rv |= aURI->SchemeIs("chrome", &isChrome);
-    rv |= aURI->SchemeIs("data", &isData);
-    NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
-
-    if (isAbout || isImap || isNews || isMailbox || isViewSource || isChrome || isData) {
-#ifdef DEBUG_bsmedberg
-      printf("Filtering out unwanted scheme.\n");
-#endif
-      return NS_OK;
-    }
-  }
-
-  rv = OpenDB();
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  nsCAutoString URISpec;
-  rv = aURI->GetSpec(URISpec);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  if (URISpec.Length() > HISTORY_URI_LENGTH_MAX)
-     return NS_OK;
-
-#ifdef DEBUG_bsmedberg
-  printf("AddURI: %s%s%s",
-         URISpec.get(),
-         aRedirect ? ", redirect" : "",
-         aTopLevel ? ", toplevel" : "");
-#endif
-
-  nsCOMPtr<nsIMdbRow> row;
-  rv = FindRow(kToken_URLColumn, URISpec.get(), getter_AddRefs(row));
-
-  if (NS_SUCCEEDED(rv)) {
-    // update the database, and get the old info back
-    PRTime oldDate;
-    PRInt32 oldCount;
-    rv = AddExistingPageToDatabase(row, aLastVisitDate, aReferrer, &oldDate, &oldCount);
-    NS_ASSERTION(NS_SUCCEEDED(rv), "AddExistingPageToDatabase failed; see bug 88961");
-    if (NS_FAILED(rv)) return rv;
-    
-#ifdef DEBUG_bsmedberg
-    printf("Existing page succeeded.\n");
-#endif
-  }
-  else {
-    rv = AddNewPageToDatabase(aURI, aLastVisitDate, aRedirect, 
-                              aTopLevel, aReferrer, getter_AddRefs(row));
-    NS_ASSERTION(NS_SUCCEEDED(rv), "AddNewPageToDatabase failed; see bug 88961");
-    if (NS_FAILED(rv)) return rv;
-
-#ifdef DEBUG_bsmedberg
-    printf("New page succeeded.\n");
-#endif
-  }
-
-  // Store last visited page if we have the pref set accordingly
-  if (aTopLevel) {
-    PRInt32 choice = 0;
-    if (NS_SUCCEEDED(gPrefBranch->GetIntPref("startup.page", &choice))) {
-      if (choice != 2) {
-        if (NS_SUCCEEDED(gPrefBranch->GetIntPref("windows.loadOnNewWindow", &choice))) {
-          if (choice != 2) {
-            gPrefBranch->GetIntPref("tabs.loadOnNewTab", &choice);
-          }
-        }
-      }
-    }
-    if (choice == 2) {
-      NS_ENSURE_STATE(mMetaRow);
-
-      SetRowValue(mMetaRow, kToken_LastPageVisited, URISpec.get());
-    }
-  }
- 
-  SetDirty();
-  
-  return NS_OK;
-}
-
-nsresult
-nsGlobalHistory::AddExistingPageToDatabase(nsIMdbRow *row,
-                                           PRTime aDate,
-                                           nsIURI* aReferrer,
-                                           PRTime *aOldDate,
-                                           PRInt32 *aOldCount)
-{
-  nsresult rv;
-  nsCAutoString oldReferrer;
-  
-  nsCAutoString URISpec;
-  rv = GetRowValue(row, kToken_URLColumn, URISpec);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  nsCAutoString referrerSpec;
-  if (aReferrer) {
-    rv = aReferrer->GetSpec(referrerSpec);
-    NS_ENSURE_SUCCESS(rv, rv);
-  }
-
-  // if the page was typed, unhide it now because it's
-  // known to be valid
-  if (HasCell(mEnv, row, kToken_TypedColumn)) {
-    mTypedHiddenURIs.Remove(URISpec);
-    row->CutColumn(mEnv, kToken_HiddenColumn);
-  }
-
-  // Update last visit date.
-  // First get the old date so we can update observers...
-  rv = GetRowValue(row, kToken_LastVisitDateColumn, aOldDate);
-  if (NS_FAILED(rv)) return rv;
-
-  // get the old count, so we can update it
-  rv = GetRowValue(row, kToken_VisitCountColumn, aOldCount);
-  if (NS_FAILED(rv) || *aOldCount < 1)
-    *aOldCount = 1;             // assume we've visited at least once
-
-  // ...now set the new date.
-  SetRowValue(row, kToken_LastVisitDateColumn, aDate);
-  SetRowValue(row, kToken_VisitCountColumn, (*aOldCount) + 1);
-
-  if (aReferrer) {
-    rv = GetRowValue(row, kToken_ReferrerColumn, oldReferrer);
-    // No referrer? Now there is!
-    if ((NS_FAILED(rv) || oldReferrer.IsEmpty()))
-       SetRowValue(row, kToken_ReferrerColumn, referrerSpec.get());
-  }
-
-  // Notify observers
-  nsCOMPtr<nsIRDFResource> url;
-  rv = gRDFService->GetResource(URISpec, getter_AddRefs(url));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  nsCOMPtr<nsIRDFDate> date;
-  rv = gRDFService->GetDateLiteral(aDate, getter_AddRefs(date));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  // visit date
-  nsCOMPtr<nsIRDFDate> oldDateLiteral;
-  rv = gRDFService->GetDateLiteral(*aOldDate, getter_AddRefs(oldDateLiteral));
-  NS_ENSURE_SUCCESS(rv, rv);
-  
-  rv = NotifyChange(url, kNC_Date, oldDateLiteral, date);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  // visit count
-  nsCOMPtr<nsIRDFInt> oldCountLiteral;
-  rv = gRDFService->GetIntLiteral(*aOldCount, getter_AddRefs(oldCountLiteral));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  nsCOMPtr<nsIRDFInt> newCountLiteral;
-  rv = gRDFService->GetIntLiteral(*aOldCount+1,
-                                  getter_AddRefs(newCountLiteral));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  rv = NotifyChange(url, kNC_VisitCount, oldCountLiteral, newCountLiteral);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  return NS_OK;
-}
-
-nsresult
-nsGlobalHistory::AddNewPageToDatabase(nsIURI* aURI,
-                                      PRTime aDate, 
-                                      PRBool aRedirect,
-                                      PRBool aTopLevel,
-                                      nsIURI* aReferrer,
-                                      nsIMdbRow **aResult)
-{
-  mdb_err err;
-  
-  NS_ENSURE_SUCCESS(OpenDB(), NS_ERROR_NOT_INITIALIZED);
-
-  nsCAutoString URISpec;
-  nsresult rv = aURI->GetSpec(URISpec);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  nsCAutoString referrerSpec;
-  if (aReferrer) {
-    rv = aReferrer->GetSpec(referrerSpec);
-    NS_ENSURE_SUCCESS(rv, rv);
-  }
-
-  // Create a new row
-  mdbOid rowId;
-  rowId.mOid_Scope = kToken_HistoryRowScope;
-  rowId.mOid_Id    = mdb_id(-1);
-  
-  NS_PRECONDITION(mTable != nsnull, "not initialized");
-  if (! mTable)
-    return NS_ERROR_NOT_INITIALIZED;
-
-  nsCOMPtr<nsIMdbRow> row;
-  err = mTable->NewRow(mEnv, &rowId, getter_AddRefs(row));
-  if (err != 0) return NS_ERROR_FAILURE;
-
-  // Set the URL
-  SetRowValue(row, kToken_URLColumn, URISpec.get());
-  
-  // Set the date.
-  SetRowValue(row, kToken_LastVisitDateColumn, aDate);
-  SetRowValue(row, kToken_FirstVisitDateColumn, aDate);
-
-  // Set the referrer if there is one.
-  if (aReferrer)
-    SetRowValue(row, kToken_ReferrerColumn, referrerSpec.get());
-
-  nsCOMPtr<nsIURI> uri;
-  NS_NewURI(getter_AddRefs(uri), URISpec, nsnull, nsnull);
-  nsCAutoString hostname;
-  if (uri)
-      uri->GetHost(hostname);
-
-  // Strip www.
-  if (Substring(hostname, 0, 4).EqualsLiteral("www."))
-    hostname.Cut(0, 4);
-
-  SetRowValue(row, kToken_HostnameColumn, hostname.get());
-
-  *aResult = row;
-  NS_ADDREF(*aResult);
-
-  PRBool isJavascript;
-  rv = aURI->SchemeIs("javascript", &isJavascript);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  if (isJavascript || aRedirect || !aTopLevel) {
-    // if this is a JS url, or a redirected URI or in a frame, hide it in
-    // global history so that it doesn't show up in the autocomplete
-    // dropdown. AddExistingPageToDatabase has logic to override this
-    // behavior for URIs which were typed. See bug 197127 and bug 161531
-    // for details.
-    rv = SetRowValue(row, kToken_HiddenColumn, 1);
-    NS_ENSURE_SUCCESS(rv, rv);
-  }
-  else {
-    // Notify observers
-    nsCOMPtr<nsIRDFResource> url;
-    rv = gRDFService->GetResource(URISpec, getter_AddRefs(url));
-    NS_ENSURE_SUCCESS(rv, rv);
-
-    nsCOMPtr<nsIRDFDate> date;
-    rv = gRDFService->GetDateLiteral(aDate, getter_AddRefs(date));
-    NS_ENSURE_SUCCESS(rv, rv);
-
-    rv = NotifyAssert(url, kNC_Date, date);
-    if (NS_FAILED(rv)) return rv;
-
-    rv = NotifyAssert(kNC_HistoryRoot, kNC_child, url);
-    if (NS_FAILED(rv)) return rv;
-  
-    NotifyFindAssertions(url, row);
-  }
-
-  return NS_OK;
-}
-
-nsresult
-nsGlobalHistory::RemovePageInternal(const char *aSpec)
-{
-  if (!mTable) return NS_ERROR_NOT_INITIALIZED;
-  // find the old row, ignore it if we don't have it
-  nsCOMPtr<nsIMdbRow> row;
-  nsresult rv = FindRow(kToken_URLColumn, aSpec, getter_AddRefs(row));
-  if (NS_FAILED(rv)) return NS_OK;
-
-  // remove the row
-  mdb_err err = mTable->CutRow(mEnv, row);
-  NS_ENSURE_TRUE(err == 0, NS_ERROR_FAILURE);
-
-  // if there are batches in progress, we don't want to notify
-  // observers that we're deleting items. the caller promises
-  // to handle whatever UI updating is necessary when we're finished.  
-  if (!mBatchesInProgress) {
-    // get the resource so we can do the notification
-    nsCOMPtr<nsIRDFResource> oldRowResource;
-    gRDFService->GetResource(nsDependentCString(aSpec), getter_AddRefs(oldRowResource));
-    NotifyFindUnassertions(oldRowResource, row);
-  }
-
-  // not a fatal error if we can't cut all column
-  err = row->CutAllColumns(mEnv);
-  NS_ASSERTION(err == 0, "couldn't cut all columns");
-
-  // Sigh. This is pretty bad - if the user selects a bunch of things then
-  // hits delete we'll be re-writing history over and over. Still, we will
-  // be whacking global history pretty hard after 1.0 so I don't feel too 
-  // bad.
-  return Commit(kCompressCommit);
-}
-
-nsresult
-nsGlobalHistory::SetRowValue(nsIMdbRow *aRow, mdb_column aCol, const PRTime& aValue)
-{
-  mdb_err err;
-  nsCAutoString val;
-  val.AppendInt(aValue);
-
-  mdbYarn yarn = { (void *)val.get(), val.Length(), val.Length(), 0, 0, nsnull };
-  
-  err = aRow->AddColumn(mEnv, aCol, &yarn);
-
-  if ( err != 0 ) return NS_ERROR_FAILURE;
-  
-  return NS_OK;
-}
-
-nsresult
-nsGlobalHistory::SetRowValue(nsIMdbRow *aRow, mdb_column aCol,
-                             const PRUnichar* aValue)
-{
-  mdb_err err;
-
-  PRInt32 len = (nsCRT::strlen(aValue) * sizeof(PRUnichar));
-  PRUnichar *swapval = nsnull;
-
-  // eventually turn this on when we're confident in mork's ability
-  // to handle yarn forms properly
-#if 0
-  NS_ConvertUTF16toUTF8 utf8Value(aValue);
-  printf("Storing utf8 value %s\n", utf8Value.get());
-  mdbYarn yarn = { (void *)utf8Value.get(), utf8Value.Length(), utf8Value.Length(), 0, 1, nsnull };
-#else
-
-  if (mReverseByteOrder) {
-    // The file is other-endian.  Byte-swap the value.
-    swapval = (PRUnichar *)malloc(len);
-    if (!swapval)
-      return NS_ERROR_OUT_OF_MEMORY;
-    SwapBytes(aValue, swapval, len / sizeof(PRUnichar));
-    aValue = swapval;
-  }
-  mdbYarn yarn = { (void *)aValue, len, len, 0, 0, nsnull };
-  
-#endif
-  err = aRow->AddColumn(mEnv, aCol, &yarn);
-  if (swapval)
-    free(swapval);
-  if (err != 0) return NS_ERROR_FAILURE;
-  return NS_OK;
-}
-
-nsresult
-nsGlobalHistory::SetRowValue(nsIMdbRow *aRow, mdb_column aCol,
-                             const char* aValue)
-{
-  mdb_err err;
-  PRInt32 len = PL_strlen(aValue);
-  mdbYarn yarn = { (void*) aValue, len, len, 0, 0, nsnull };
-  err = aRow->AddColumn(mEnv, aCol, &yarn);
-  if (err != 0) return NS_ERROR_FAILURE;
-
-  return NS_OK;
-}
-
-nsresult
-nsGlobalHistory::SetRowValue(nsIMdbRow *aRow, mdb_column aCol, const PRInt32 aValue)
-{
-  mdb_err err;
-  
-  nsCAutoString buf; buf.AppendInt(aValue);
-  mdbYarn yarn = { (void *)buf.get(), buf.Length(), buf.Length(), 0, 0, nsnull };
-
-  err = aRow->AddColumn(mEnv, aCol, &yarn);
-  
-  if (err != 0) return NS_ERROR_FAILURE;
-
-  return NS_OK;
-}
-
-nsresult
-nsGlobalHistory::GetRowValue(nsIMdbRow *aRow, mdb_column aCol,
-                             nsAString& aResult)
-{
-  mdb_err err;
-  
-  mdbYarn yarn;
-  err = aRow->AliasCellYarn(mEnv, aCol, &yarn);
-  if (err != 0) return NS_ERROR_FAILURE;
-
-  aResult.Truncate(0);
-  if (!yarn.mYarn_Fill)
-    return NS_OK;
-  
-  switch (yarn.mYarn_Form) {
-  case 0:                       // unicode
-    if (mReverseByteOrder) {
-      // The file is other-endian; we must byte-swap the result.
-      PRUnichar *swapval;
-      int len = yarn.mYarn_Fill / sizeof(PRUnichar);
-      swapval = (PRUnichar *)malloc(yarn.mYarn_Fill);
-      if (!swapval)
-        return NS_ERROR_OUT_OF_MEMORY;
-      SwapBytes((const PRUnichar *)yarn.mYarn_Buf, swapval, len);
-      aResult.Assign(swapval, len);
-      free(swapval);
-    }
-    else
-      aResult.Assign((const PRUnichar *)yarn.mYarn_Buf, yarn.mYarn_Fill/sizeof(PRUnichar));
-    break;
-
-    // eventually we'll be supporting this in SetRowValue()
-  case 1:                       // UTF8
-    aResult.Assign(NS_ConvertUTF8toUTF16((const char*)yarn.mYarn_Buf, yarn.mYarn_Fill));
-    break;
-
-  default:
-    return NS_ERROR_UNEXPECTED;
-  }
-  return NS_OK;
-}
-
-// Copy an array of 16-bit values, reversing the byte order.
-void
-nsGlobalHistory::SwapBytes(const PRUnichar *source, PRUnichar *dest,
-                           PRInt32 aLen)
-{
-  PRUint16 c;
-  const PRUnichar *inp;
-  PRUnichar *outp;
-  PRInt32 i;
-
-  inp = source;
-  outp = dest;
-  for (i = 0; i < aLen; i++) {
-    c = *inp++;
-    *outp++ = (((c >> 8) & 0xff) | (c << 8));
-  }
-  return;
-}
-      
-nsresult
-nsGlobalHistory::GetRowValue(nsIMdbRow *aRow, mdb_column aCol,
-                             PRTime *aResult)
-{
-  mdb_err err;
-  
-  mdbYarn yarn;
-  err = aRow->AliasCellYarn(mEnv, aCol, &yarn);
-  if (err != 0) return NS_ERROR_FAILURE;
-
-  *aResult = LL_ZERO;
-  
-  if (!yarn.mYarn_Fill || !yarn.mYarn_Buf)
-    return NS_OK;
-
-  PR_sscanf((const char*)yarn.mYarn_Buf, "%lld", aResult);
-  
-  return NS_OK;
-}
-
-nsresult
-nsGlobalHistory::GetRowValue(nsIMdbRow *aRow, mdb_column aCol,
-                             PRInt32 *aResult)
-{
-  mdb_err err;
-  
-  mdbYarn yarn;
-  err = aRow->AliasCellYarn(mEnv, aCol, &yarn);
-  if (err != 0) return NS_ERROR_FAILURE;
-
-  if (yarn.mYarn_Buf)
-    *aResult = atoi((char *)yarn.mYarn_Buf);
-  else
-    *aResult = 0;
-  
-  return NS_OK;
-}
-
-nsresult
-nsGlobalHistory::GetRowValue(nsIMdbRow *aRow, mdb_column aCol,
-                             nsACString& aResult)
-{
-  mdb_err err;
-  
-  mdbYarn yarn;
-  err = aRow->AliasCellYarn(mEnv, aCol, &yarn);
-  if (err != 0) return NS_ERROR_FAILURE;
-
-  const char* startPtr = (const char*)yarn.mYarn_Buf;
-  if (startPtr)
-    aResult.Assign(Substring(startPtr, startPtr + yarn.mYarn_Fill));
-  else
-    aResult.Truncate();
-  
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-nsGlobalHistory::AddPageWithDetails(nsIURI *aURI, const PRUnichar *aTitle, 
-                                    PRTime aLastVisitDate)
-{
-  nsresult rv = AddPageToDatabase(aURI, PR_FALSE, PR_TRUE, aLastVisitDate, nsnull);
-  if (NS_FAILED(rv)) return rv;
-
-  return SetPageTitle(aURI, nsDependentString(aTitle));
-}
-
-NS_IMETHODIMP
-nsGlobalHistory::GetCount(PRUint32* aCount)
-{
-  NS_ENSURE_ARG_POINTER(aCount);
-  NS_ENSURE_SUCCESS(OpenDB(), NS_ERROR_FAILURE);
-  if (!mTable) return NS_ERROR_FAILURE;
-
-  mdb_err err = mTable->GetCount(mEnv, aCount);
-  return (err == 0) ? NS_OK : NS_ERROR_FAILURE;
-}
-
-NS_IMETHODIMP
-nsGlobalHistory::SetPageTitle(nsIURI *aURI, const nsAString& aTitle)
-{
-  nsresult rv;
-  NS_ENSURE_ARG_POINTER(aURI);
-
-  nsAutoString titleString(StringHead(aTitle, HISTORY_TITLE_LENGTH_MAX));
-  if (titleString.Length() < aTitle.Length() &&
-      NS_IS_HIGH_SURROGATE(titleString.Last()))
-    titleString.Truncate(titleString.Length()-1);
-
-  // skip about: URIs to avoid reading in the db (about:blank, especially)
-  PRBool isAbout;
-  rv = aURI->SchemeIs("about", &isAbout);
-  NS_ENSURE_SUCCESS(rv, rv);
-  if (isAbout) return NS_OK;
-
-  NS_ENSURE_SUCCESS(OpenDB(), NS_ERROR_FAILURE);
-  
-  nsCAutoString URISpec;
-  rv = aURI->GetSpec(URISpec);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  nsCOMPtr<nsIMdbRow> row;
-  rv = FindRow(kToken_URLColumn, URISpec.get(), getter_AddRefs(row));
-
-  // if the row doesn't exist, we silently succeed
-  if (rv == NS_ERROR_NOT_AVAILABLE) return NS_OK;
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  // Get the old title so we can notify observers
-  nsAutoString oldtitle;
-  rv = GetRowValue(row, kToken_NameColumn, oldtitle);
-  if (NS_FAILED(rv)) return rv;
-
-  nsCOMPtr<nsIRDFLiteral> oldname;
-  if (!oldtitle.IsEmpty()) {
-    rv = gRDFService->GetLiteral(oldtitle.get(), getter_AddRefs(oldname));
-    if (NS_FAILED(rv)) return rv;
-  }
-
-  SetRowValue(row, kToken_NameColumn, titleString.get());
-
-  // ...and update observers
-  nsCOMPtr<nsIRDFResource> url;
-  rv = gRDFService->GetResource(URISpec, getter_AddRefs(url));
-  if (NS_FAILED(rv)) return rv;
-
-  nsCOMPtr<nsIRDFLiteral> name;
-  rv = gRDFService->GetLiteral(titleString.get(), getter_AddRefs(name));
-  if (NS_FAILED(rv)) return rv;
-
-  if (oldname) {
-    rv = NotifyChange(url, kNC_Name, oldname, name);
-  }
-  else {
-    rv = NotifyAssert(url, kNC_Name, name);
-  }
-
-  return rv;
-}
-
-
-NS_IMETHODIMP
-nsGlobalHistory::RemovePage(nsIURI *aURI)
-{
-  nsCAutoString spec;
-  nsresult rv = aURI->GetSpec(spec);
-  if (NS_SUCCEEDED(rv))
-    rv = RemovePageInternal(spec.get());
-  return rv;
-}
-
-NS_IMETHODIMP
-nsGlobalHistory::RemovePagesFromHost(const nsACString &aHost, PRBool aEntireDomain)
-{
-  const nsCString &host = PromiseFlatCString(aHost);
-
-  matchHost_t hostInfo;
-  hostInfo.history = this;
-  hostInfo.entireDomain = aEntireDomain;
-  hostInfo.host = host.get();
-
-  return RemoveMatchingRows(matchHostCallback, (void *)&hostInfo, PR_TRUE);
-}
-
-PRBool
-nsGlobalHistory::MatchHost(nsIMdbRow *aRow,
-                           matchHost_t *hostInfo)
-{
-  mdb_err err;
-  nsresult rv;
-
-  mdbYarn yarn;
-  err = aRow->AliasCellYarn(mEnv, kToken_URLColumn, &yarn);
-  if (err != 0) return PR_FALSE;
-
-  nsCOMPtr<nsIURI> uri;
-  // do smart zero-termination
-  const char* startPtr = (const char *)yarn.mYarn_Buf;
-  rv = NS_NewURI(getter_AddRefs(uri),
-                 Substring(startPtr, startPtr + yarn.mYarn_Fill));
-  if (NS_FAILED(rv)) return PR_FALSE;
-
-  nsCAutoString urlHost;
-  rv = uri->GetHost(urlHost);
-  if (NS_FAILED(rv)) return PR_FALSE;
-
-  if (PL_strcmp(urlHost.get(), hostInfo->host) == 0)
-    return PR_TRUE;
-
-  // now try for a domain match, if necessary
-  if (hostInfo->entireDomain) {
-    // do a reverse-search to match the end of the string
-    const char *domain = PL_strrstr(urlHost.get(), hostInfo->host);
-    
-    // now verify that we're matching EXACTLY the domain, and
-    // not some random string inside the hostname
-    if (domain && (PL_strcmp(domain, hostInfo->host) == 0))
-      return PR_TRUE;
-  }
-  
-  return PR_FALSE;
-}
-
-NS_IMETHODIMP
-nsGlobalHistory::RemoveAllPages()
-{
-  nsresult rv;
-
-  rv = RemoveMatchingRows(matchAllCallback, nsnull, PR_TRUE);
-  if (NS_FAILED(rv)) return rv;
-  
-  // Reset the file byte order.
-  rv = InitByteOrder(PR_TRUE);
-  if (NS_FAILED(rv)) return rv;
-
-  return Commit(kCompressCommit);
-}
-
-nsresult
-nsGlobalHistory::RemoveMatchingRows(rowMatchCallback aMatchFunc,
-                                    void *aClosure,
-                                    PRBool notify)
-{
-  NS_ENSURE_SUCCESS(OpenDB(), NS_ERROR_FAILURE);
-  nsresult rv;
-  if (!mTable) return NS_OK;
-
-  mdb_err err;
-  mdb_count count;
-  err = mTable->GetCount(mEnv, &count);
-  if (err != 0) return NS_ERROR_FAILURE;
-
-  BeginUpdateBatch();
-
-  // Begin the batch.
-  int marker;
-  err = mTable->StartBatchChangeHint(mEnv, &marker);
-  NS_ASSERTION(err == 0, "unable to start batch");
-  if (err != 0) return NS_ERROR_FAILURE;
-
-  nsCOMPtr<nsIRDFResource> resource;
-  // XXX from here until end batch, no early returns!
-  for (mdb_pos pos = count - 1; pos >= 0; --pos) {
-    nsCOMPtr<nsIMdbRow> row;
-    err = mTable->PosToRow(mEnv, pos, getter_AddRefs(row));
-    NS_ASSERTION(err == 0, "unable to get row");
-    if (err != 0)
-      break;
-
-    NS_ASSERTION(row != nsnull, "no row");
-    if (! row)
-      continue;
-
-    // now we actually do the match. If this row doesn't match, loop again
-    if (!(aMatchFunc)(row, aClosure))
-      continue;
-
-    if (notify) {
-      // What's the URL? We need to know to properly notify our RDF
-      // observers.
-      mdbYarn yarn;
-      err = row->AliasCellYarn(mEnv, kToken_URLColumn, &yarn);
-      if (err != 0)
-        continue;
-      
-      const char* startPtr = (const char*) yarn.mYarn_Buf;
-      nsCAutoString uri(Substring(startPtr, startPtr+yarn.mYarn_Fill));
-      rv = gRDFService->GetResource(uri, getter_AddRefs(resource));
-      NS_ASSERTION(NS_SUCCEEDED(rv), "unable to get resource");
-      if (NS_FAILED(rv))
-        continue;
-    }
-    // Officially cut the row *now*, before notifying any observers:
-    // that way, any re-entrant calls won't find the row.
-    err = mTable->CutRow(mEnv, row);
-    NS_ASSERTION(err == 0, "couldn't cut row");
-    if (err != 0)
-      continue;
-  
-    // possibly avoid leakage
-    err = row->CutAllColumns(mEnv);
-    NS_ASSERTION(err == 0, "couldn't cut all columns");
-    // we'll notify regardless of whether we could successfully
-    // CutAllColumns or not.
-    
-    
-  }
-  
-  // Finish the batch.
-  err = mTable->EndBatchChangeHint(mEnv, &marker);
-  NS_ASSERTION(err == 0, "error ending batch");
-
-  EndUpdateBatch();
-
-  if (err != 0)
-    return NS_ERROR_FAILURE;
-
-  return Commit(kCompressCommit);
-}
-
-NS_IMETHODIMP
-nsGlobalHistory::IsVisited(nsIURI* aURI, PRBool *_retval)
-{
-  NS_ENSURE_ARG_POINTER(aURI);
-
-  nsresult rv;
-  NS_ENSURE_SUCCESS(OpenDB(), NS_ERROR_NOT_INITIALIZED);
-
-  nsCAutoString URISpec;
-  rv = aURI->GetSpec(URISpec);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  rv = FindRow(kToken_URLColumn, URISpec.get(), nsnull);
-  *_retval = NS_SUCCEEDED(rv);
-  
-  // Hidden, typed URIs haven't really been visited yet. They've only
-  // been typed in and the actual load hasn't happened yet. We maintain
-  // the list of hidden+typed URIs in memory in mTypedHiddenURIs because
-  // the list will usually be small and checking the actual Mork row
-  // would require several dynamic memory allocations.
-  if (*_retval && mTypedHiddenURIs.Contains(URISpec))
-  {
-    *_retval = PR_FALSE;
-  }
-
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-nsGlobalHistory::GetLastPageVisited(nsACString& _retval)
-{ 
-  NS_ENSURE_SUCCESS(OpenDB(), NS_ERROR_FAILURE);
-
-  NS_ENSURE_STATE(mMetaRow);
-
-  mdb_err err = GetRowValue(mMetaRow, kToken_LastPageVisited, _retval);
-  NS_ENSURE_TRUE(err == 0, NS_ERROR_FAILURE);
-  
-  return NS_OK;
-}
-
-// Set the byte order in the history file.  The given string value should
-// be either "BE" (big-endian) or "LE" (little-endian).
-nsresult
-nsGlobalHistory::SaveByteOrder(const char *aByteOrder)
-{
-  if (PL_strcmp(aByteOrder, "BE") != 0 && PL_strcmp(aByteOrder, "LE") != 0) {
-    NS_WARNING("Invalid byte order argument.");
-    return NS_ERROR_INVALID_ARG;
-  }
-  NS_ENSURE_STATE(mMetaRow);
-
-  mdb_err err = SetRowValue(mMetaRow, kToken_ByteOrder, aByteOrder);
-  NS_ENSURE_TRUE(err == 0, NS_ERROR_FAILURE);
-
-  return NS_OK;
-}
-
-// Get the file byte order.
-nsresult
-nsGlobalHistory::GetByteOrder(char **_retval)
-{ 
-  NS_ENSURE_SUCCESS(OpenDB(), NS_ERROR_FAILURE);
-
-  NS_ENSURE_ARG_POINTER(_retval);
-  NS_ENSURE_STATE(mMetaRow);
-
-  nsCAutoString byteOrder;
-  mdb_err err = GetRowValue(mMetaRow, kToken_ByteOrder, byteOrder);
-  NS_ENSURE_TRUE(err == 0, NS_ERROR_FAILURE);
-
-  *_retval = ToNewCString(byteOrder);
-  NS_ENSURE_TRUE(*_retval, NS_ERROR_OUT_OF_MEMORY);
-
-  return NS_OK;
-}
-
-
-NS_IMETHODIMP
-nsGlobalHistory::HidePage(nsIURI *aURI)
-{
-  nsresult rv;
-  NS_ENSURE_ARG_POINTER(aURI);
-
-  nsCAutoString URISpec;
-  rv = aURI->GetSpec(URISpec);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  if (URISpec.Length() > HISTORY_URI_LENGTH_MAX)
-     return NS_OK;
-
-#ifdef DEBUG_bsmedberg
-  printf("nsGlobalHistory::HidePage: %s\n", URISpec.get());
-#endif
-  
-  nsCOMPtr<nsIMdbRow> row;
-
-  rv = FindRow(kToken_URLColumn, URISpec.get(), getter_AddRefs(row));
-
-  if (NS_FAILED(rv)) {
-    // it hasn't been visited yet, but if one ever comes in, we need
-    // to hide it when it is visited
-    rv = AddURI(aURI, PR_FALSE, PR_FALSE, nsnull);
-    if (NS_FAILED(rv)) return rv;
-    
-    rv = FindRow(kToken_URLColumn, URISpec.get(), getter_AddRefs(row));
-    if (NS_FAILED(rv)) return rv;
-  }
-
-  rv = SetRowValue(row, kToken_HiddenColumn, 1);
-  if (NS_FAILED(rv)) return rv;
-
-  // now pretend as if this row was deleted
-  // HasAssertion() correctly checks the Hidden column to show that
-  // the row is hidden
-  nsCOMPtr<nsIRDFResource> urlResource;
-  rv = gRDFService->GetResource(URISpec, getter_AddRefs(urlResource));
-  if (NS_FAILED(rv)) return rv;
-  return NotifyFindUnassertions(urlResource, row);
-}
-
-NS_IMETHODIMP
-nsGlobalHistory::MarkPageAsTyped(nsIURI *aURI)
-{
-  NS_ENSURE_ARG_POINTER(aURI);
-  nsCAutoString spec;
-  nsresult rv = aURI->GetSpec(spec);
-  if (NS_FAILED(rv))
-    return rv;
-  
-  if (spec.Length() > HISTORY_URI_LENGTH_MAX)
-     return NS_OK;
-
-  nsCOMPtr<nsIMdbRow> row;
-  rv = FindRow(kToken_URLColumn, spec.get(), getter_AddRefs(row));
-  if (NS_FAILED(rv)) {
-    rv = AddNewPageToDatabase(aURI, GetNow(), PR_FALSE, PR_TRUE, nsnull, getter_AddRefs(row));
-    NS_ENSURE_SUCCESS(rv, rv);
-
-    // We don't know if this is a valid URI yet. Hide it until it finishes
-    // loading.
-    SetRowValue(row, kToken_HiddenColumn, 1);
-    mTypedHiddenURIs.Put(spec);
-  }
-  
-  return SetRowValue(row, kToken_TypedColumn, 1);
-}
-
-NS_IMETHODIMP
-nsGlobalHistory::AddDocumentRedirect(nsIChannel *aOldChannel,
-                                     nsIChannel *aNewChannel,
-                                     PRInt32 aFlags,
-                                     PRBool aTopLevel)
-{
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-
-NS_IMETHODIMP
-nsGlobalHistory::SetURIGeckoFlags(nsIURI *aURI, PRUint32 aFlags)
-{
-  NS_ENSURE_ARG_POINTER(aURI);
-  nsCAutoString spec;
-  nsresult rv = aURI->GetSpec(spec);
-  if (NS_FAILED(rv))
-    return rv;
-
-  nsCOMPtr<nsIMdbRow> row;
-  rv = FindRow(kToken_URLColumn, spec.get(), getter_AddRefs(row));
-  if (NS_FAILED(rv))
-    return rv;
-
-  return SetRowValue(row, kToken_GeckoFlagsColumn, (PRInt32)aFlags);
-}
-
-NS_IMETHODIMP
-nsGlobalHistory::GetURIGeckoFlags(nsIURI *aURI, PRUint32* aFlags)
-{
-  NS_ENSURE_ARG_POINTER(aURI);
-  nsCAutoString spec;
-  nsresult rv = aURI->GetSpec(spec);
-  if (NS_FAILED(rv))
-    return rv;
-
-  nsCOMPtr<nsIMdbRow> row;
-  rv = FindRow(kToken_URLColumn, spec.get(), getter_AddRefs(row));
-  if (NS_FAILED(rv))
-    return rv;
-
-  if (!HasCell(mEnv, row, kToken_GeckoFlagsColumn))
-    return NS_ERROR_FAILURE;
-
-  PRInt32 val;
-  mdb_err err = GetRowValue(row, kToken_GeckoFlagsColumn, &val);
-  NS_ENSURE_TRUE(err == 0, NS_ERROR_FAILURE);
-  *aFlags = val;
-  return NS_OK;
-}
-
-//----------------------------------------------------------------------
-//
-// nsGlobalHistory
-//
-//   nsIRDFDataSource methods
-
-NS_IMETHODIMP
-nsGlobalHistory::GetURI(char* *aURI)
-{
-  NS_PRECONDITION(aURI != nsnull, "null ptr");
-  if (! aURI)
-    return NS_ERROR_NULL_POINTER;
-
-  *aURI = nsCRT::strdup("rdf:history");
-  if (! *aURI)
-    return NS_ERROR_OUT_OF_MEMORY;
-
-  return NS_OK;
-}
-
-
-NS_IMETHODIMP
-nsGlobalHistory::GetSource(nsIRDFResource* aProperty,
-                           nsIRDFNode* aTarget,
-                           PRBool aTruthValue,
-                           nsIRDFResource** aSource)
-{
-  NS_PRECONDITION(aProperty != nsnull, "null ptr");
-  if (! aProperty)
-    return NS_ERROR_NULL_POINTER;
-
-  NS_PRECONDITION(aTarget != nsnull, "null ptr");
-  if (! aTarget)
-    return NS_ERROR_NULL_POINTER;
-
-  nsresult rv;
-
-  *aSource = nsnull;
-
-  if (aProperty == kNC_URL) {
-    // See if we have the row...
-
-    // XXX We could be more forgiving here, and check for literal
-    // values as well.
-    nsCOMPtr<nsIRDFResource> target = do_QueryInterface(aTarget);
-    if (target && IsURLInHistory(target))
-      return CallQueryInterface(aTarget, aSource);
-    
-  }
-  else if ((aProperty == kNC_Date) ||
-           (aProperty == kNC_FirstVisitDate) ||
-           (aProperty == kNC_VisitCount) ||
-           (aProperty == kNC_Name) ||
-           (aProperty == kNC_Hostname) ||
-           (aProperty == kNC_Referrer)) {
-    // Call GetSources() and return the first one we find.
-    nsCOMPtr<nsISimpleEnumerator> sources;
-    rv = GetSources(aProperty, aTarget, aTruthValue, getter_AddRefs(sources));
-    if (NS_FAILED(rv)) return rv;
-
-    PRBool hasMore;
-    rv = sources->HasMoreElements(&hasMore);
-    if (NS_FAILED(rv)) return rv;
-
-    if (hasMore) {
-      nsCOMPtr<nsISupports> isupports;
-      rv = sources->GetNext(getter_AddRefs(isupports));
-      if (NS_FAILED(rv)) return rv;
-
-      return CallQueryInterface(isupports, aSource);
-    }
-  }
-
-  return NS_RDF_NO_VALUE;  
-}
-
-NS_IMETHODIMP
-nsGlobalHistory::GetSources(nsIRDFResource* aProperty,
-                            nsIRDFNode* aTarget,
-                            PRBool aTruthValue,
-                            nsISimpleEnumerator** aSources)
-{
-  // XXX TODO: make sure each URL in history is connected back to
-  // NC:HistoryRoot.
-  NS_PRECONDITION(aProperty != nsnull, "null ptr");
-  if (! aProperty)
-    return NS_ERROR_NULL_POINTER;
-
-  NS_PRECONDITION(aTarget != nsnull, "null ptr");
-  if (! aTarget)
-    return NS_ERROR_NULL_POINTER;
-
-  nsresult rv;
-
-  if (aProperty == kNC_URL) {
-    // Call GetSource() and return a singleton enumerator for the URL.
-    nsCOMPtr<nsIRDFResource> source;
-    rv = GetSource(aProperty, aTarget, aTruthValue, getter_AddRefs(source));
-    if (NS_FAILED(rv)) return rv;
-
-    return NS_NewSingletonEnumerator(aSources, source);
-  }
-  else {
-    // See if aProperty is something we understand, and create an
-    // URLEnumerator to select URLs with the appropriate value.
-
-    mdb_column col = 0; // == "not a property that I grok"
-    void* value = nsnull;
-    PRInt32 len = 0;
-
-    // PRInt64/date properties
-    if (aProperty == kNC_Date ||
-        aProperty == kNC_FirstVisitDate) {
-      nsCOMPtr<nsIRDFDate> date = do_QueryInterface(aTarget);
-      if (date) {
-        PRInt64 n;
-
-        rv = date->GetValue(&n);
-        if (NS_FAILED(rv)) return rv;
-
-        nsCAutoString valueStr;
-        valueStr.AppendInt(n);
-        
-        value = (void *)ToNewCString(valueStr);
-        if (aProperty == kNC_Date)
-          col = kToken_LastVisitDateColumn;
-        else
-          col = kToken_FirstVisitDateColumn;
-      }
-    }
-    // PRInt32 properties
-    else if (aProperty == kNC_VisitCount) {
-      nsCOMPtr<nsIRDFInt> countLiteral = do_QueryInterface(aTarget);
-      if (countLiteral) {
-        PRInt32 intValue;
-        rv = countLiteral->GetValue(&intValue);
-        if (NS_FAILED(rv)) return rv;
-
-        nsAutoString valueStr; valueStr.AppendInt(intValue);
-        value = ToNewUnicode(valueStr);
-        len = valueStr.Length() * sizeof(PRUnichar);
-        col = kToken_VisitCountColumn;
-      }
-      
-    }
-    // PRUnichar* properties
-    else if (aProperty == kNC_Name) {
-      nsCOMPtr<nsIRDFLiteral> name = do_QueryInterface(aTarget);
-      if (name) {
-        PRUnichar* p;
-        rv = name->GetValue(&p);
-        if (NS_FAILED(rv)) return rv;
-
-        len = nsCRT::strlen(p) * sizeof(PRUnichar);
-        value = p;
-
-        col = kToken_NameColumn;
-      }
-    }
-
-    // char* properties
-    else if (aProperty == kNC_Hostname ||
-             aProperty == kNC_Referrer) {
-      col = kToken_ReferrerColumn;
-      nsCOMPtr<nsIRDFResource> referrer = do_QueryInterface(aTarget);
-      if (referrer) {
-        char* p;
-        rv = referrer->GetValue(&p);
-        if (NS_FAILED(rv)) return rv;
-
-        len = PL_strlen(p);
-        value = p;
-
-        if (aProperty == kNC_Hostname)
-          col = kToken_HostnameColumn;
-        else if (aProperty == kNC_Referrer)
-          col = kToken_ReferrerColumn;
-      }
-    }
-
-    if (col) {
-      // The URLEnumerator takes ownership of the bytes allocated in |value|.
-      URLEnumerator* result = new URLEnumerator(kToken_URLColumn, col,
-                                                kToken_HiddenColumn,
-                                                value, len);
-      if (! result)
-        return NS_ERROR_OUT_OF_MEMORY;
-
-      rv = result->Init(mEnv, mTable);
-      if (NS_FAILED(rv)) return rv;
-
-      *aSources = result;
-      NS_ADDREF(*aSources);
-      return NS_OK;
-    }
-  }
-
-  return NS_NewEmptyEnumerator(aSources);
-}
-
-NS_IMETHODIMP
-nsGlobalHistory::GetTarget(nsIRDFResource* aSource,
-                           nsIRDFResource* aProperty,
-                           PRBool aTruthValue,
-                           nsIRDFNode** aTarget)
-{
-  
-  NS_PRECONDITION(aSource != nsnull, "null ptr");
-  if (! aSource)
-    return NS_ERROR_NULL_POINTER;
-
-  NS_PRECONDITION(aProperty != nsnull, "null ptr");
-  if (! aProperty)
-    return NS_ERROR_NULL_POINTER;
-
-  nsresult rv;
-
-  // Initialize return value.
-  *aTarget = nsnull;
-
-  // Only "positive" assertions here.
-  if (! aTruthValue)
-    return NS_RDF_NO_VALUE;
-
-    // XXX eventually use IsFindResource to simply return the first
-    // matching row?
-  if (aProperty == kNC_child &&
-      (aSource == kNC_HistoryRoot ||
-       aSource == kNC_HistoryByDateAndSite ||
-       aSource == kNC_HistoryByDate ||
-       IsFindResource(aSource))) {
-      
-    // If they're asking for all the children of the HistoryRoot, call
-    // through to GetTargets() and return the first one.
-    nsCOMPtr<nsISimpleEnumerator> targets;
-    rv = GetTargets(aSource, aProperty, aTruthValue, getter_AddRefs(targets));
-    if (NS_FAILED(rv)) return rv;
-    
-    PRBool hasMore;
-    rv = targets->HasMoreElements(&hasMore);
-    if (NS_FAILED(rv)) return rv;
-    
-    if (! hasMore) return NS_RDF_NO_VALUE;
-    
-    nsCOMPtr<nsISupports> isupports;
-    rv = targets->GetNext(getter_AddRefs(isupports));
-    if (NS_FAILED(rv)) return rv;
-    
-    return CallQueryInterface(isupports, aTarget);
-  }
-  else if ((aProperty == kNC_Date) ||
-           (aProperty == kNC_FirstVisitDate) ||
-           (aProperty == kNC_VisitCount) ||
-           (aProperty == kNC_AgeInDays) ||
-           (aProperty == kNC_Name) ||
-           (aProperty == kNC_NameSort) ||
-           (aProperty == kNC_Hostname) ||
-           (aProperty == kNC_Referrer) ||
-           (aProperty == kNC_URL) ||
-           (aProperty == kNC_DayFolderIndex)) {
-
-    const char* uri;
-    rv = aSource->GetValueConst(&uri);
-    if (NS_FAILED(rv)) return rv;
-
-    // url is self-referential, so we'll always just return itself
-    // however, don't return the URLs of find resources
-    if (aProperty == kNC_URL && !IsFindResource(aSource)) {
-      
-      nsCOMPtr<nsIRDFLiteral> uriLiteral;
-      rv = gRDFService->GetLiteral(NS_ConvertUTF8toUTF16(uri).get(), getter_AddRefs(uriLiteral));
-      if (NS_FAILED(rv))    return(rv);
-      *aTarget = uriLiteral;
-      NS_ADDREF(*aTarget);
-      return NS_OK;
-    }
-
-    // find URIs are special
-    if (IsFindResource(aSource)) {
-      if (aProperty == kNC_Name)
-        return GetFindUriName(uri, aTarget);
-        
-      if (aProperty == kNC_NameSort) {
-        // parse out the 'text' token
-        nsVoidArray tokenList;
-        FindUrlToTokenList(uri, tokenList);
-
-        nsCOMPtr<nsIRDFLiteral> literal; 
-
-        for (PRInt32 i = 0; i < tokenList.Count(); ++i) {
-          tokenPair* token = static_cast<tokenPair*>(tokenList[i]);
-
-          if (!strncmp(token->tokenName, "text", token->tokenNameLength)) {
-            rv = gRDFService->GetLiteral(NS_ConvertUTF8toUTF16(Substring(token->tokenValue, token->tokenValue + token->tokenValueLength)).get(),
-                                         getter_AddRefs(literal));
-            // We don't break out of the loop here because there could be other text tokens in the string.
-            // The last one is the most specific so wait and see if we've got one...
-          }
-        }
-
-        FreeTokenList(tokenList);
-  
-        if (literal && NS_SUCCEEDED(rv)) {
-          *aTarget = literal;
-          NS_ADDREF(*aTarget);
-          return NS_OK;
-        }
-        *aTarget = nsnull;
-        return rv;
-      }
-    }
-    
-    // ok, we got this far, so we have to retrieve something from
-    // the row in the database
-    nsCOMPtr<nsIMdbRow> row;
-    rv = FindRow(kToken_URLColumn, uri, getter_AddRefs(row));
-    if (NS_FAILED(rv)) return NS_RDF_NO_VALUE;
-
-    mdb_err err;
-    // ...and then depending on the property they want, we'll pull the
-    // cell they want out of it.
-    if (aProperty == kNC_Date  ||
-        aProperty == kNC_FirstVisitDate) {
-      // Last visit date
-      PRTime i;
-      if (aProperty == kNC_Date)
-        rv = GetRowValue(row, kToken_LastVisitDateColumn, &i);
-      else
-        rv = GetRowValue(row, kToken_FirstVisitDateColumn, &i);
-
-      if (NS_FAILED(rv)) return rv;
-
-      nsCOMPtr<nsIRDFDate> date;
-      rv = gRDFService->GetDateLiteral(i, getter_AddRefs(date));
-      if (NS_FAILED(rv)) return rv;
-
-      return CallQueryInterface(date, aTarget);
-    }
-    else if (aProperty == kNC_VisitCount) {
-      mdbYarn yarn;
-      err = row->AliasCellYarn(mEnv, kToken_VisitCountColumn, &yarn);
-      if (err != 0) return NS_ERROR_FAILURE;
-
-      PRInt32 visitCount = 0;
-      rv = GetRowValue(row, kToken_VisitCountColumn, &visitCount);
-      if (NS_FAILED(rv) || visitCount <1)
-        visitCount = 1;         // assume we've visited at least once
-
-      nsCOMPtr<nsIRDFInt> visitCountLiteral;
-      rv = gRDFService->GetIntLiteral(visitCount,
-                                      getter_AddRefs(visitCountLiteral));
-      if (NS_FAILED(rv)) return rv;
-
-      return CallQueryInterface(visitCountLiteral, aTarget);
-    }
-    else if (aProperty == kNC_AgeInDays) {
-      PRTime lastVisitDate;
-      rv = GetRowValue(row, kToken_LastVisitDateColumn, &lastVisitDate);
-      if (NS_FAILED(rv)) return rv;
-      
-      PRInt32 days = GetAgeInDays(NormalizeTime(GetNow()), lastVisitDate);
-
-      nsCOMPtr<nsIRDFInt> ageLiteral;
-      rv = gRDFService->GetIntLiteral(days, getter_AddRefs(ageLiteral));
-      if (NS_FAILED(rv)) return rv;
-
-      *aTarget = ageLiteral;
-      NS_ADDREF(*aTarget);
-      return NS_OK;
-    }
-    else if (aProperty == kNC_Name ||
-             aProperty == kNC_NameSort) {
-      // Site name (i.e., page title)
-      nsAutoString title;
-      rv = GetRowValue(row, kToken_NameColumn, title);
-      if (NS_FAILED(rv) || title.IsEmpty()) {
-        // yank out the filename from the url, use that
-        nsCOMPtr<nsIURI> aUri;
-        rv = NS_NewURI(getter_AddRefs(aUri), uri);
-        if (NS_FAILED(rv)) return rv;
-        nsCOMPtr<nsIURL> urlObj(do_QueryInterface(aUri));
-        if (!urlObj)
-            return NS_ERROR_FAILURE;
-
-        nsCAutoString filename;
-        rv = urlObj->GetFileName(filename);
-        if (NS_FAILED(rv) || filename.IsEmpty()) {
-          // ok fine. we'll use the file path. then we give up!
-          rv = urlObj->GetPath(filename);
-          if (strcmp(filename.get(), "/") == 0) {
-            // if the top of a site does not have a title
-            // (common for redirections) then return the hostname
-            rv = GetRowValue(row, kToken_HostnameColumn, filename);
-          }
-        }
-
-        if (NS_FAILED(rv)) return rv;
-        
-        // assume the url is in UTF8
-        title = NS_ConvertUTF8toUTF16(filename);
-      }
-      if (NS_FAILED(rv)) return rv;
-
-      nsCOMPtr<nsIRDFLiteral> name;
-      rv = gRDFService->GetLiteral(title.get(), getter_AddRefs(name));
-      if (NS_FAILED(rv)) return rv;
-
-      return CallQueryInterface(name, aTarget);
-    }
-    else if (aProperty == kNC_Hostname ||
-             aProperty == kNC_Referrer) {
-      
-      nsCAutoString str;
-      if (aProperty == kNC_Hostname)
-        rv = GetRowValue(row, kToken_HostnameColumn, str);
-      else if (aProperty == kNC_Referrer)
-        rv = GetRowValue(row, kToken_ReferrerColumn, str);
-      
-      if (NS_FAILED(rv)) return rv;
-      // Avoid trying to create a resource from an empty string, which
-      // will raise an exception
-      if (str.IsEmpty()) return NS_RDF_NO_VALUE;
-
-      nsCOMPtr<nsIRDFResource> resource;
-      rv = gRDFService->GetResource(str, getter_AddRefs(resource));
-      if (NS_FAILED(rv)) return rv;
-
-      return CallQueryInterface(resource, aTarget);
-    }
-
-    else {
-      NS_NOTREACHED("huh, how'd I get here?");
-    }
-  }
-  return NS_RDF_NO_VALUE;
-}
-
-void
-nsGlobalHistory::Sync()
-{
-  if (mDirty)
-    Flush();
-  
-  mDirty = PR_FALSE;
-  mSyncTimer = nsnull;
-}
-
-void
-nsGlobalHistory::ExpireNow()
-{
-  mNowValid = PR_FALSE;
-  mExpireNowTimer = nsnull;
-}
-
-// when we're dirty, we want to make sure we sync again soon,
-// but make sure that we don't keep syncing if someone is surfing
-// a lot, so cancel the existing timer if any is still waiting to fire
-nsresult
-nsGlobalHistory::SetDirty()
-{
-  nsresult rv;
-
-  if (mSyncTimer)
-    mSyncTimer->Cancel();
-
-  if (!mSyncTimer) {
-    mSyncTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
-    if (NS_FAILED(rv)) return rv;
-  }
-  
-  mDirty = PR_TRUE;
-  mSyncTimer->InitWithFuncCallback(fireSyncTimer, this, HISTORY_SYNC_TIMEOUT,
-                                   nsITimer::TYPE_ONE_SHOT);
-  
-
-  return NS_OK;
-}
-
-// hack to avoid calling PR_Now() too often, as is the case when
-// we're asked the ageindays of many history entries in a row
-PRTime
-nsGlobalHistory::GetNow()
-{
-  if (!mNowValid) {             // not dirty, mLastNow is crufty
-    mLastNow = PR_Now();
-    mNowValid = PR_TRUE;
-    if (!mExpireNowTimer)
-      mExpireNowTimer = do_CreateInstance("@mozilla.org/timer;1");
-
-    if (mExpireNowTimer)
-      mExpireNowTimer->InitWithFuncCallback(expireNowTimer, this, HISTORY_EXPIRE_NOW_TIMEOUT,
-                                            nsITimer::TYPE_ONE_SHOT);
-  }
-  
-  return mLastNow;
-}
-
-NS_IMETHODIMP
-nsGlobalHistory::GetTargets(nsIRDFResource* aSource,
-                            nsIRDFResource* aProperty,
-                            PRBool aTruthValue,
-                            nsISimpleEnumerator** aTargets)
-{
-  NS_PRECONDITION(aSource != nsnull, "null ptr");
-  if (! aSource)
-    return NS_ERROR_NULL_POINTER;
-
-  NS_PRECONDITION(aProperty != nsnull, "null ptr");
-  if (! aProperty)
-    return NS_ERROR_NULL_POINTER;
-
-  if (!aTruthValue)
-    return NS_NewEmptyEnumerator(aTargets);
-
-  NS_ENSURE_SUCCESS(OpenDB(), NS_ERROR_FAILURE);
-  
-  // list all URLs off the root
-  if ((aSource == kNC_HistoryRoot) &&
-      (aProperty == kNC_child)) {
-    URLEnumerator* result = new URLEnumerator(kToken_URLColumn,
-                                              kToken_HiddenColumn);
-    if (! result)
-      return NS_ERROR_OUT_OF_MEMORY;
-    
-    nsresult rv;
-    rv = result->Init(mEnv, mTable);
-    if (NS_FAILED(rv)) return rv;
-    
-    *aTargets = result;
-    NS_ADDREF(*aTargets);
-    return NS_OK;
-  }
-  else if ((aSource == kNC_HistoryByDateAndSite) &&
-           (aProperty == kNC_child)) {
-
-    return GetRootDayQueries(aTargets, PR_TRUE);
-  }
-  else if ((aSource == kNC_HistoryByDate) &&
-           (aProperty == kNC_child)) {
-
-    return GetRootDayQueries(aTargets, PR_FALSE);
-  }
-  else if (aProperty == kNC_child &&
-           IsFindResource(aSource)) {
-    return CreateFindEnumerator(aSource, aTargets);
-  }
-  
-  else if ((aProperty == kNC_Date) ||
-           (aProperty == kNC_FirstVisitDate) ||
-           (aProperty == kNC_VisitCount) ||
-           (aProperty == kNC_AgeInDays) ||
-           (aProperty == kNC_Name) ||
-           (aProperty == kNC_Hostname) ||
-           (aProperty == kNC_Referrer) ||
-           (aProperty == kNC_DayFolderIndex)) {
-    nsresult rv;
-    
-    nsCOMPtr<nsIRDFNode> target;
-    rv = GetTarget(aSource, aProperty, aTruthValue, getter_AddRefs(target));
-    if (NS_FAILED(rv)) return rv;
-    
-    if (rv == NS_OK) {
-      return NS_NewSingletonEnumerator(aTargets, target);
-    }
-  }
-
-  // we've already answered the queries from the root, so we must be
-  // looking for real entries
-
-  return NS_NewEmptyEnumerator(aTargets);
-}
-
-NS_IMETHODIMP
-nsGlobalHistory::Assert(nsIRDFResource* aSource, 
-                        nsIRDFResource* aProperty, 
-                        nsIRDFNode* aTarget,
-                        PRBool aTruthValue)
-{
-  // History cannot be modified
-  return NS_RDF_ASSERTION_REJECTED;
-}
-
-NS_IMETHODIMP
-nsGlobalHistory::Unassert(nsIRDFResource* aSource,
-                          nsIRDFResource* aProperty,
-                          nsIRDFNode* aTarget)
-{
-  // translate into an appropriate removehistory call
-  nsresult rv;
-  if ((aSource == kNC_HistoryRoot || aSource == kNC_HistoryByDateAndSite || aSource == kNC_HistoryByDate 
-       || IsFindResource(aSource)) &&
-      aProperty == kNC_child) {
-
-    nsCOMPtr<nsIRDFResource> resource = do_QueryInterface(aTarget, &rv);
-    if (NS_FAILED(rv)) return NS_RDF_ASSERTION_REJECTED; 
-
-    const char* targetUrl;
-    rv = resource->GetValueConst(&targetUrl);
-    if (NS_FAILED(rv)) return NS_RDF_ASSERTION_REJECTED;
-
-    if (IsFindResource(resource)) {
-      // convert uri to a query
-      searchQuery query;
-      rv = FindUrlToSearchQuery(targetUrl, query);
-      if (NS_FAILED(rv)) return NS_RDF_ASSERTION_REJECTED;
- 
-      matchQuery_t matchQuery;
-      matchQuery.history = this;
-      matchQuery.query = &query;
-      rv = RemoveMatchingRows(matchQueryCallback, (void*)&matchQuery, PR_TRUE); 
-      FreeSearchQuery(query);
-      if (NS_FAILED(rv)) return NS_RDF_ASSERTION_REJECTED;
-
-      // if there are batches in progress, we don't want to notify
-      // observers that we're deleting items. the caller promises
-      // to handle whatever UI updating is necessary when we're finished.
-      if (!mBatchesInProgress)
-        NotifyUnassert(aSource, aProperty, aTarget);
-
-      return NS_OK;
-    }
-
-    // ignore any error
-    rv = RemovePageInternal(targetUrl);
-    if (NS_FAILED(rv)) return NS_RDF_ASSERTION_REJECTED;
-
-    if (!mBatchesInProgress && IsFindResource(aSource)) {
-      // if there are batches in progress, we don't want to notify
-      // observers that we're deleting items. the caller promises
-      // to handle whatever UI updating is necessary when we're finished.
-      NotifyUnassert(aSource, aProperty, aTarget);
-    }
-
-    return NS_OK;
-  }
-  
-  return NS_RDF_ASSERTION_REJECTED;
-}
-
-NS_IMETHODIMP
-nsGlobalHistory::Change(nsIRDFResource* aSource,
-                        nsIRDFResource* aProperty,
-                        nsIRDFNode* aOldTarget,
-                        nsIRDFNode* aNewTarget)
-{
-  return NS_RDF_ASSERTION_REJECTED;
-}
-
-NS_IMETHODIMP
-nsGlobalHistory::Move(nsIRDFResource* aOldSource,
-                      nsIRDFResource* aNewSource,
-                      nsIRDFResource* aProperty,
-                      nsIRDFNode* aTarget)
-{
-  return NS_RDF_ASSERTION_REJECTED;
-}
-
-NS_IMETHODIMP
-nsGlobalHistory::HasAssertion(nsIRDFResource* aSource,
-                              nsIRDFResource* aProperty,
-                              nsIRDFNode* aTarget,
-                              PRBool aTruthValue,
-                              PRBool* aHasAssertion)
-{
-
-  NS_PRECONDITION(aSource != nsnull, "null ptr");
-  if (! aSource)
-    return NS_ERROR_NULL_POINTER;
-
-  NS_PRECONDITION(aProperty != nsnull, "null ptr");
-  if (! aProperty)
-    return NS_ERROR_NULL_POINTER;
-
-  NS_PRECONDITION(aTarget != nsnull, "null ptr");
-  if (! aTarget)
-    return NS_ERROR_NULL_POINTER;
-
-  // Only "positive" assertions here.
-  if (!aTruthValue) {
-    *aHasAssertion = PR_FALSE;
-    return NS_OK;
-  }
-
-  nsresult rv;
-  
-  // answer if a specific row matches a find URI
-  // 
-  // at some point, we should probably match groupby= findURIs with
-  // findURIs that match all their criteria
-  //
-  nsCOMPtr<nsIRDFResource> target = do_QueryInterface(aTarget);
-  if (target &&
-      aProperty == kNC_child &&
-      IsFindResource(aSource) &&
-      !IsFindResource(target)) {
-
-    const char *uri;
-    rv = target->GetValueConst(&uri);
-    if (NS_FAILED(rv)) return rv;
-
-    searchQuery query;
-    FindUrlToSearchQuery(uri, query);
-    
-    nsCOMPtr<nsIMdbRow> row;
-    rv = FindRow(kToken_URLColumn, uri, getter_AddRefs(row));
-    // not even in history. don't bother trying
-    if (NS_FAILED(rv) || HasCell(mEnv, row, kToken_HiddenColumn)) {
-      *aHasAssertion = PR_FALSE;
-      return NS_OK;
-    }
-    
-    *aHasAssertion = RowMatches(row, &query, PR_TRUE);
-    FreeSearchQuery(query);
-    return NS_OK;
-  }
-  
-  // Do |GetTargets()| and grovel through the results to see if we
-  // have the assertion.
-  //
-  // XXX *AHEM*, this could be implemented much more efficiently...
-
-  nsCOMPtr<nsISimpleEnumerator> targets;
-  rv = GetTargets(aSource, aProperty, aTruthValue, getter_AddRefs(targets));
-  if (NS_FAILED(rv)) return rv;
-  
-  while (1) {
-    PRBool hasMore;
-    rv = targets->HasMoreElements(&hasMore);
-    if (NS_FAILED(rv)) return rv;
-    
-    if (! hasMore)
-      break;
-    
-    nsCOMPtr<nsISupports> isupports;
-    rv = targets->GetNext(getter_AddRefs(isupports));
-    if (NS_FAILED(rv)) return rv;
-    
-    nsCOMPtr<nsIRDFNode> node = do_QueryInterface(isupports);
-    if (node.get() == aTarget) {
-      *aHasAssertion = PR_TRUE;
-      return NS_OK;
-    }
-  }
-
-  *aHasAssertion = PR_FALSE;
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-nsGlobalHistory::AddObserver(nsIRDFObserver* aObserver)
-{
-  NS_PRECONDITION(aObserver != nsnull, "null ptr");
-  if (! aObserver)
-    return NS_ERROR_NULL_POINTER;
-
-  mObservers.AppendObject(aObserver);
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-nsGlobalHistory::RemoveObserver(nsIRDFObserver* aObserver)
-{
-  NS_PRECONDITION(aObserver != nsnull, "null ptr");
-  if (! aObserver)
-    return NS_ERROR_NULL_POINTER;
-
-  mObservers.RemoveObject(aObserver);
-
-  return NS_OK;
-}
-
-NS_IMETHODIMP 
-nsGlobalHistory::HasArcIn(nsIRDFNode *aNode, nsIRDFResource *aArc, PRBool *result)
-{
-  NS_PRECONDITION(aNode != nsnull, "null ptr");
-  if (! aNode)
-    return NS_ERROR_NULL_POINTER;
-
-  nsCOMPtr<nsIRDFResource> resource = do_QueryInterface(aNode);
-  if (resource && IsURLInHistory(resource)) {
-    *result = (aArc == kNC_child);
-  }
-  else {
-    *result = PR_FALSE;
-  }
-  return NS_OK;
-}
-
-NS_IMETHODIMP 
-nsGlobalHistory::HasArcOut(nsIRDFResource *aSource, nsIRDFResource *aArc, PRBool *result)
-{
-  NS_PRECONDITION(aSource != nsnull, "null ptr");
-  if (! aSource)
-    return NS_ERROR_NULL_POINTER;
-
-  if ((aSource == kNC_HistoryRoot) ||
-      (aSource == kNC_HistoryByDateAndSite) ||
-      (aSource == kNC_HistoryByDate)) {
-    *result = (aArc == kNC_child);
-  }
-  else if (IsFindResource(aSource)) {
-    // we handle children of find urls
-    *result = (aArc == kNC_child ||
-               aArc == kNC_Name ||
-               aArc == kNC_NameSort ||
-               aArc == kNC_DayFolderIndex);
-  }
-  else if (IsURLInHistory(aSource)) {
-    // If the URL is in the history, then it'll have all the
-    // appropriate attributes.
-    *result = (aArc == kNC_Date ||
-               aArc == kNC_FirstVisitDate ||
-               aArc == kNC_VisitCount ||
-               aArc == kNC_Name ||
-               aArc == kNC_Hostname ||
-               aArc == kNC_Referrer);
-  }
-  else {
-    *result = PR_FALSE;
-  }
-  return NS_OK; 
-}
-
-NS_IMETHODIMP
-nsGlobalHistory::ArcLabelsIn(nsIRDFNode* aNode,
-                             nsISimpleEnumerator** aLabels)
-{
-  NS_PRECONDITION(aNode != nsnull, "null ptr");
-  if (! aNode)
-    return NS_ERROR_NULL_POINTER;
-
-  nsCOMPtr<nsIRDFResource> resource = do_QueryInterface(aNode);
-  if (resource && IsURLInHistory(resource)) {
-    return NS_NewSingletonEnumerator(aLabels, kNC_child);
-  }
-  else {
-    return NS_NewEmptyEnumerator(aLabels);
-  }
-}
-
-NS_IMETHODIMP
-nsGlobalHistory::ArcLabelsOut(nsIRDFResource* aSource,
-                              nsISimpleEnumerator** aLabels)
-{
-  NS_PRECONDITION(aSource != nsnull, "null ptr");
-  if (! aSource)
-    return NS_ERROR_NULL_POINTER;
-
-  nsresult rv;
-
-  if ((aSource == kNC_HistoryRoot) ||
-      (aSource == kNC_HistoryByDateAndSite) ||
-      (aSource == kNC_HistoryByDate)) {
-    return NS_NewSingletonEnumerator(aLabels, kNC_child);
-  }
-  else if (IsURLInHistory(aSource)) {
-    // If the URL is in the history, then it'll have all the
-    // appropriate attributes.
-    nsCOMPtr<nsISupportsArray> array;
-    rv = NS_NewISupportsArray(getter_AddRefs(array));
-    if (NS_FAILED(rv)) return rv;
-
-    array->AppendElement(kNC_Date);
-    array->AppendElement(kNC_FirstVisitDate);
-    array->AppendElement(kNC_VisitCount);
-    array->AppendElement(kNC_Name);
-    array->AppendElement(kNC_Hostname);
-    array->AppendElement(kNC_Referrer);
-
-    return NS_NewArrayEnumerator(aLabels, array);
-  }
-  else if (IsFindResource(aSource)) {
-    nsCOMPtr<nsISupportsArray> array;
-    rv = NS_NewISupportsArray(getter_AddRefs(array));
-    if (NS_FAILED(rv)) return rv;
-
-    array->AppendElement(kNC_child);
-    array->AppendElement(kNC_Name);
-    array->AppendElement(kNC_NameSort);
-    array->AppendElement(kNC_DayFolderIndex);
-    
-    return NS_NewArrayEnumerator(aLabels, array);
-  }
-  else {
-    return NS_NewEmptyEnumerator(aLabels);
-  }
-}
-
-NS_IMETHODIMP
-nsGlobalHistory::GetAllCmds(nsIRDFResource* aSource,
-                            nsISimpleEnumerator/*<nsIRDFResource>*/** aCommands)
-{
-  return NS_NewEmptyEnumerator(aCommands);
-}
-
-NS_IMETHODIMP
-nsGlobalHistory::IsCommandEnabled(nsISupportsArray/*<nsIRDFResource>*/* aSources,
-                                  nsIRDFResource*   aCommand,
-                                  nsISupportsArray/*<nsIRDFResource>*/* aArguments,
-                                  PRBool* aResult)
-{
-  NS_NOTYETIMPLEMENTED("sorry");
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-
-NS_IMETHODIMP
-nsGlobalHistory::DoCommand(nsISupportsArray/*<nsIRDFResource>*/* aSources,
-                           nsIRDFResource*   aCommand,
-                           nsISupportsArray/*<nsIRDFResource>*/* aArguments)
-{
-  NS_NOTYETIMPLEMENTED("sorry");
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-
-NS_IMETHODIMP
-nsGlobalHistory::GetAllResources(nsISimpleEnumerator** aResult)
-{
-  URLEnumerator* result = new URLEnumerator(kToken_URLColumn,
-                                            kToken_HiddenColumn);
-  if (! result)
-    return NS_ERROR_OUT_OF_MEMORY;
-
-  nsresult rv;
-  rv = result->Init(mEnv, mTable);
-  if (NS_FAILED(rv)) return rv;
-
-  *aResult = result;
-  NS_ADDREF(*aResult);
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-nsGlobalHistory::BeginUpdateBatch()
-{
-  nsresult rv = NS_OK;
-
-  ++mBatchesInProgress;
-  
-  PRUint32 i = mObservers.Count();
-  while (i > 0) {
-    rv = mObservers[--i]->OnBeginUpdateBatch(this);
-  }
-  return rv;
-}
-
-NS_IMETHODIMP
-nsGlobalHistory::EndUpdateBatch()
-{
-  nsresult rv = NS_OK;
-
-  --mBatchesInProgress;
-
-  PRUint32 i = mObservers.Count();
-  while (i > 0) {
-    rv = mObservers[--i]->OnEndUpdateBatch(this);
-  }
-  return rv;
-}
-
-
-
-////////////////////////////////////////////////////////////////////////
-// nsIRDFRemoteDataSource
-
-NS_IMETHODIMP
-nsGlobalHistory::GetLoaded(PRBool* _result)
-{
-    *_result = PR_TRUE;
-    return NS_OK;
-}
-
-
-
-NS_IMETHODIMP
-nsGlobalHistory::Init(const char* aURI)
-{
-    return(NS_OK);
-}
-
-
-
-NS_IMETHODIMP
-nsGlobalHistory::Refresh(PRBool aBlocking)
-{
-    return(NS_OK);
-}
-
-NS_IMETHODIMP
-nsGlobalHistory::Flush()
-{
-  return Commit(kLargeCommit);
-}
-
-NS_IMETHODIMP
-nsGlobalHistory::FlushTo(const char* aURI)
-{
-  // Do not ever implement this (security)
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-
-//----------------------------------------------------------------------
-//
-// nsGlobalHistory
-//
-//   Miscellaneous implementation methods
-//
-
-nsresult
-nsGlobalHistory::Init()
-{
-  nsresult rv;
-
-  // we'd like to get this pref when we need it, but at that point,
-  // we can't get the pref service. register a pref observer so we update
-  // if the pref changes
-
-  if (!gPrefBranch) {
-    nsCOMPtr<nsIPrefService> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID, &rv);
-    NS_ENSURE_SUCCESS(rv, rv);
-    rv = prefs->GetBranch(PREF_BRANCH_BASE, &gPrefBranch);
-    NS_ENSURE_SUCCESS(rv, rv);
-  }
-
-  gPrefBranch->GetIntPref(PREF_BROWSER_HISTORY_EXPIRE_DAYS, &mExpireDays);
-  gPrefBranch->GetBoolPref(PREF_AUTOCOMPLETE_ONLY_TYPED, &mAutocompleteOnlyTyped);
-  nsCOMPtr<nsIPrefBranch2> pbi = do_QueryInterface(gPrefBranch);
-  if (pbi) {
-    pbi->AddObserver(PREF_AUTOCOMPLETE_ONLY_TYPED, this, PR_FALSE);
-    pbi->AddObserver(PREF_BROWSER_HISTORY_EXPIRE_DAYS, this, PR_FALSE);
-  }
-
-  if (gRefCnt++ == 0) {
-    rv = CallGetService(kRDFServiceCID, &gRDFService);
-
-    NS_ASSERTION(NS_SUCCEEDED(rv), "unable to get RDF service");
-    if (NS_FAILED(rv)) return rv;
-
-    gRDFService->GetResource(NS_LITERAL_CSTRING(NC_NAMESPACE_URI "Page"),        &kNC_Page);
-    gRDFService->GetResource(NS_LITERAL_CSTRING(NC_NAMESPACE_URI "Date"),        &kNC_Date);
-    gRDFService->GetResource(NS_LITERAL_CSTRING(NC_NAMESPACE_URI "FirstVisitDate"),
-                             &kNC_FirstVisitDate);
-    gRDFService->GetResource(NS_LITERAL_CSTRING(NC_NAMESPACE_URI "VisitCount"),  &kNC_VisitCount);
-    gRDFService->GetResource(NS_LITERAL_CSTRING(NC_NAMESPACE_URI "AgeInDays"),  &kNC_AgeInDays);
-    gRDFService->GetResource(NS_LITERAL_CSTRING(NC_NAMESPACE_URI "Name"),        &kNC_Name);
-    gRDFService->GetResource(NS_LITERAL_CSTRING(NC_NAMESPACE_URI "Name?sort=true"), &kNC_NameSort);
-    gRDFService->GetResource(NS_LITERAL_CSTRING(NC_NAMESPACE_URI "Hostname"),    &kNC_Hostname);
-    gRDFService->GetResource(NS_LITERAL_CSTRING(NC_NAMESPACE_URI "Referrer"),    &kNC_Referrer);
-    gRDFService->GetResource(NS_LITERAL_CSTRING(NC_NAMESPACE_URI "child"),       &kNC_child);
-    gRDFService->GetResource(NS_LITERAL_CSTRING(NC_NAMESPACE_URI "URL"),         &kNC_URL);
-    gRDFService->GetResource(NS_LITERAL_CSTRING(NC_NAMESPACE_URI "DayFolderIndex"), &kNC_DayFolderIndex);
-    gRDFService->GetResource(NS_LITERAL_CSTRING("NC:HistoryRoot"),               &kNC_HistoryRoot);
-    gRDFService->GetResource(NS_LITERAL_CSTRING("NC:HistoryByDateAndSite"),           &kNC_HistoryByDateAndSite);
-    gRDFService->GetResource(NS_LITERAL_CSTRING("NC:HistoryByDate"),           &kNC_HistoryByDate);
-  }
-
-  // register this as a named data source with the RDF service
-  rv = gRDFService->RegisterDataSource(this, PR_FALSE);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  nsCOMPtr<nsIStringBundleService> bundleService =
-    do_GetService(NS_STRINGBUNDLE_CONTRACTID, &rv);
-  
-  if (NS_SUCCEEDED(rv)) {
-    rv = bundleService->CreateBundle("chrome://global/locale/history/history.properties", getter_AddRefs(mBundle));
-  }
-
-  // register to observe profile changes
-  nsCOMPtr<nsIObserverService> observerService = 
-           do_GetService("@mozilla.org/observer-service;1", &rv);
-  NS_ASSERTION(observerService, "failed to get observer service");
-  if (observerService) {
-    observerService->AddObserver(this, "profile-before-change", PR_TRUE);
-    observerService->AddObserver(this, "profile-do-change", PR_TRUE);
-    observerService->AddObserver(this, "quit-application", PR_TRUE);
-  }
-  
-  return NS_OK;
-}
-
-
-nsresult
-nsGlobalHistory::OpenDB()
-{
-  nsresult rv;
-
-  if (mStore) return NS_OK;
-  
-  nsCOMPtr <nsIFile> historyFile;
-  rv = NS_GetSpecialDirectory(NS_APP_HISTORY_50_FILE, getter_AddRefs(historyFile));
-  NS_ENSURE_SUCCESS(rv, rv);
-  nsCOMPtr <nsIMdbFactoryService> factoryfactory = do_GetService(NS_MORK_CONTRACTID, &rv);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  rv = factoryfactory->GetMdbFactory(&gMdbFactory);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  mdb_err err;
-
-  err = gMdbFactory->MakeEnv(nsnull, &mEnv);
-  mEnv->SetAutoClear(PR_TRUE);
-  NS_ASSERTION((err == 0), "unable to create mdb env");
-  if (err != 0) return NS_ERROR_FAILURE;
-
-  // MDB requires native file paths
-
-  nsCAutoString filePath;
-  rv = historyFile->GetNativePath(filePath);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  PRBool exists = PR_TRUE;
-
-  historyFile->Exists(&exists);
-    
-  if (!exists || NS_FAILED(rv = OpenExistingFile(gMdbFactory, filePath.get()))) {
-
-    // we couldn't open the file, so it's either corrupt or doesn't exist.
-    // attempt to delete the file, but ignore the error
-    historyFile->Remove(PR_FALSE);
-    rv = OpenNewFile(gMdbFactory, filePath.get());
-  }
-
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  // get the initial filesize. Used in Commit() to determine type of commit.
-  rv = historyFile->GetFileSize(&mFileSizeOnDisk);
-  if (NS_FAILED(rv)) {
-    LL_I2L(mFileSizeOnDisk, 0);
-  }
-  
-  // See if we need to byte-swap.
-  InitByteOrder(PR_FALSE);
-
-  return NS_OK;
-}
-
-nsresult
-nsGlobalHistory::OpenExistingFile(nsIMdbFactory *factory, const char *filePath)
-{
-
-  mdb_err err;
-  nsresult rv;
-  mdb_bool canopen = 0;
-  mdbYarn outfmt = { nsnull, 0, 0, 0, 0, nsnull };
-
-  nsIMdbHeap* dbHeap = 0;
-  mdb_bool dbFrozen = mdbBool_kFalse; // not readonly, we want modifiable
-  nsCOMPtr<nsIMdbFile> oldFile; // ensures file is released
-  err = factory->OpenOldFile(mEnv, dbHeap, filePath,
-                             dbFrozen, getter_AddRefs(oldFile));
-
-  // don't assert, the file might just not be there
-  if ((err !=0) || !oldFile) return NS_ERROR_FAILURE;
-
-  err = factory->CanOpenFilePort(mEnv, oldFile, // the file to investigate
-                                 &canopen, &outfmt);
-
-  // XXX possible that format out of date, in which case we should
-  // just re-write the file.
-  if ((err !=0) || !canopen) return NS_ERROR_FAILURE;
-
-  nsIMdbThumb* thumb = nsnull;
-  mdbOpenPolicy policy = { { 0, 0 }, 0, 0 };
-
-  err = factory->OpenFileStore(mEnv, dbHeap, oldFile, &policy, &thumb);
-  if ((err !=0) || !thumb) return NS_ERROR_FAILURE;
-
-  mdb_count total;
-  mdb_count current;
-  mdb_bool done;
-  mdb_bool broken;
-
-  do {
-    err = thumb->DoMore(mEnv, &total, &current, &done, &broken);
-  } while ((err == 0) && !broken && !done);
-
-  if ((err == 0) && done) {
-    err = factory->ThumbToOpenStore(mEnv, thumb, &mStore);
-  }
-
-  NS_IF_RELEASE(thumb);
-
-  if (err != 0) return NS_ERROR_FAILURE;
-
-  rv = CreateTokens();
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  mdbOid oid = { kToken_HistoryRowScope, 1 };
-  err = mStore->GetTable(mEnv, &oid, &mTable);
-  NS_ENSURE_TRUE(err == 0, NS_ERROR_FAILURE);
-  if (!mTable) {
-    NS_WARNING("Your history file is somehow corrupt.. deleting it.");
-    return NS_ERROR_FAILURE;
-  }
-
-  err = mTable->GetMetaRow(mEnv, &oid, nsnull, getter_AddRefs(mMetaRow));
-  if (err != 0)
-    NS_WARNING("Could not get meta row\n");
-
-  CheckHostnameEntries();
-
-  if (err != 0) return NS_ERROR_FAILURE;
-  
-  return NS_OK;
-}
-
-nsresult
-nsGlobalHistory::OpenNewFile(nsIMdbFactory *factory, const char *filePath)
-{
-  nsresult rv;
-  mdb_err err;
-  
-  nsIMdbHeap* dbHeap = 0;
-  nsCOMPtr<nsIMdbFile> newFile; // ensures file is released
-  err = factory->CreateNewFile(mEnv, dbHeap, filePath,
-                               getter_AddRefs(newFile));
-
-  if ((err != 0) || !newFile) return NS_ERROR_FAILURE;
-  
-  mdbOpenPolicy policy = { { 0, 0 }, 0, 0 };
-  err = factory->CreateNewFileStore(mEnv, dbHeap, newFile, &policy, &mStore);
-  
-  if (err != 0) return NS_ERROR_FAILURE;
-  
-  rv = CreateTokens();
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  // Create the one and only table in the history db
-  err = mStore->NewTable(mEnv, kToken_HistoryRowScope, kToken_HistoryKind, PR_TRUE, nsnull, &mTable);
-  if (err != 0) return NS_ERROR_FAILURE;
-  if (!mTable) return NS_ERROR_FAILURE;
-
-  // Create the meta row.
-  mdbOid oid = { kToken_HistoryRowScope, 1 };
-  err = mTable->GetMetaRow(mEnv, &oid, nsnull, getter_AddRefs(mMetaRow));
-  if (err != 0)
-    NS_WARNING("Could not get meta row\n");
-
-  // Force a commit now to get it written out.
-  nsCOMPtr<nsIMdbThumb> thumb;
-  err = mStore->LargeCommit(mEnv, getter_AddRefs(thumb));
-  if (err != 0) return NS_ERROR_FAILURE;
-
-  mdb_count total;
-  mdb_count current;
-  mdb_bool done;
-  mdb_bool broken;
-
-  do {
-    err = thumb->DoMore(mEnv, &total, &current, &done, &broken);
-  } while ((err == 0) && !broken && !done);
-
-  if ((err != 0) || !done) return NS_ERROR_FAILURE;
-
-  return NS_OK;
-}
-
-// Set the history file byte order if necessary, and determine if
-// we need to byte-swap Unicode values.
-// If the force argument is true, the file byte order will be set
-// to that of this machine.
-nsresult
-nsGlobalHistory::InitByteOrder(PRBool aForce)
-{
-#ifdef IS_LITTLE_ENDIAN
-  NS_NAMED_LITERAL_CSTRING(machine_byte_order, "LE");
-#endif
-#ifdef IS_BIG_ENDIAN
-  NS_NAMED_LITERAL_CSTRING(machine_byte_order, "BE");
-#endif
-  nsXPIDLCString file_byte_order;
-  nsresult rv = NS_OK;
-
-  if (!aForce)
-    rv = GetByteOrder(getter_Copies(file_byte_order));
-  if (aForce || NS_FAILED(rv) ||
-      !(file_byte_order.Equals(NS_LITERAL_CSTRING("BE")) ||
-        file_byte_order.Equals(NS_LITERAL_CSTRING("LE")))) {
-    // Byte order is not yet set, or needs to be reset; initialize it.
-    mReverseByteOrder = PR_FALSE;
-    rv = SaveByteOrder(machine_byte_order.get());
-    if (NS_FAILED(rv))
-      return rv;
-  }
-  else
-    mReverseByteOrder = !file_byte_order.Equals(machine_byte_order);
-
-  return NS_OK;
-}
-
-// break the uri down into a search query, and pass off to
-// SearchEnumerator
-nsresult
-nsGlobalHistory::CreateFindEnumerator(nsIRDFResource *aSource,
-                                      nsISimpleEnumerator **aResult)
-{
-  nsresult rv;
-  // make sure this was a find query
-  if (!IsFindResource(aSource))
-    return NS_ERROR_FAILURE;
-
-  const char* uri;
-  rv = aSource->GetValueConst(&uri);
-  if (NS_FAILED(rv)) return rv;
-
-  // convert uri to a query
-  searchQuery* query = new searchQuery;
-  if (!query) return NS_ERROR_OUT_OF_MEMORY;
-  FindUrlToSearchQuery(uri, *query);
-
-  // the enumerator will take ownership of the query
-  SearchEnumerator *result =
-    new SearchEnumerator(query, kToken_HiddenColumn, this);
-  if (!result) return NS_ERROR_OUT_OF_MEMORY;
-
-  rv = result->Init(mEnv, mTable);
-  if (NS_FAILED(rv)) return rv;
-
-  // return the value
-  *aResult = result;
-  NS_ADDREF(*aResult);
-  
-  return NS_OK;
-}
-
-
-// for each row, we need to parse out the hostname from the url
-// then store it in a column
-nsresult
-nsGlobalHistory::CheckHostnameEntries()
-{
-  nsresult rv = NS_OK;
-
-  mdb_err err;
-
-  nsCOMPtr<nsIMdbTableRowCursor> cursor;
-  nsCOMPtr<nsIMdbRow> row;
- 
-  err = mTable->GetTableRowCursor(mEnv, -1, getter_AddRefs(cursor));
-  if (err != 0) return NS_ERROR_FAILURE;
-
-  int marker;
-  err = mTable->StartBatchChangeHint(mEnv, &marker);
-  NS_ASSERTION(err == 0, "unable to start batch");
-  if (err != 0) return NS_ERROR_FAILURE;
-  
-  mdb_pos pos;
-  err = cursor->NextRow(mEnv, getter_AddRefs(row), &pos);
-  if (err != 0) return NS_ERROR_FAILURE;
-
-  // comment out this code to rebuild the hostlist at startup
-#if 1
-  // bail early if the first row has a hostname
-  if (row) {
-    nsCAutoString hostname;
-    rv = GetRowValue(row, kToken_HostnameColumn, hostname);
-    if (NS_SUCCEEDED(rv) && !hostname.IsEmpty())
-      return NS_OK;
-  }
-#endif
-  
-  // cached variables used in the loop
-  nsCAutoString url;
-  nsXPIDLCString hostname;
-
-  nsCOMPtr<nsIIOService> ioService = do_GetService(NS_IOSERVICE_CONTRACTID);
-  if (!ioService) return NS_ERROR_FAILURE;
-  
-
-  while (row) {
-#if 0
-    rv = GetRowValue(row, kToken_URLColumn, url);
-    if (NS_FAILED(rv)) break;
-
-    ioService->ExtractUrlPart(url, nsIIOService::url_Host, 0, 0, getter_Copies(hostname));
-
-    SetRowValue(row, kToken_HostnameColumn, hostname);
-    
-#endif
-
-    // to be turned on when we're confident in mork's ability
-    // to handle yarn forms properly
-#if 0
-    nsAutoString title;
-    rv = GetRowValue(row, kToken_NameColumn, title);
-    // reencode back into UTF8
-    if (NS_SUCCEEDED(rv))
-      SetRowValue(row, kToken_NameColumn, title.get());
-#endif
-    cursor->NextRow(mEnv, getter_AddRefs(row), &pos);
-  }
-
-  // Finish the batch.
-  err = mTable->EndBatchChangeHint(mEnv, &marker);
-  NS_ASSERTION(err == 0, "error ending batch");
-  
-  return rv;
-}
-
-nsresult
-nsGlobalHistory::CreateTokens()
-{
-  mdb_err err;
-
-  NS_PRECONDITION(mStore != nsnull, "not initialized");
-  if (! mStore)
-    return NS_ERROR_NOT_INITIALIZED;
-
-  err = mStore->StringToToken(mEnv, "ns:history:db:row:scope:history:all", &kToken_HistoryRowScope);
-  if (err != 0) return NS_ERROR_FAILURE;
-  
-  err = mStore->StringToToken(mEnv, "ns:history:db:table:kind:history", &kToken_HistoryKind);
-  if (err != 0) return NS_ERROR_FAILURE;
-  
-  err = mStore->StringToToken(mEnv, "URL", &kToken_URLColumn);
-  if (err != 0) return NS_ERROR_FAILURE;
-
-  err = mStore->StringToToken(mEnv, "Referrer", &kToken_ReferrerColumn);
-  if (err != 0) return NS_ERROR_FAILURE;
-
-  err = mStore->StringToToken(mEnv, "LastVisitDate", &kToken_LastVisitDateColumn);
-  if (err != 0) return NS_ERROR_FAILURE;
-
-  err = mStore->StringToToken(mEnv, "FirstVisitDate", &kToken_FirstVisitDateColumn);
-  if (err != 0) return NS_ERROR_FAILURE;
-
-  err = mStore->StringToToken(mEnv, "VisitCount", &kToken_VisitCountColumn);
-  if (err != 0) return NS_ERROR_FAILURE;
-
-  err = mStore->StringToToken(mEnv, "Name", &kToken_NameColumn);
-  if (err != 0) return NS_ERROR_FAILURE;
-
-  err = mStore->StringToToken(mEnv, "Hostname", &kToken_HostnameColumn);
-  if (err != 0) return NS_ERROR_FAILURE;
-  
-  err = mStore->StringToToken(mEnv, "Hidden", &kToken_HiddenColumn);
-  if (err != 0) return NS_ERROR_FAILURE;
-
-  err = mStore->StringToToken(mEnv, "Typed", &kToken_TypedColumn);
-  if (err != 0) return NS_ERROR_FAILURE;
-
-  err = mStore->StringToToken(mEnv, "GeckoFlags", &kToken_GeckoFlagsColumn);
-  if (err != 0) return NS_ERROR_FAILURE;
-
-  // meta-data tokens
-  err = mStore->StringToToken(mEnv, "LastPageVisited", &kToken_LastPageVisited);
-  err = mStore->StringToToken(mEnv, "ByteOrder", &kToken_ByteOrder);
-
-  return NS_OK;
-}
-
-nsresult nsGlobalHistory::Commit(eCommitType commitType)
-{
-  if (!mStore || !mTable)
-    return NS_OK;
-
-  nsresult  err = NS_OK;
-  nsCOMPtr<nsIMdbThumb> thumb;
-
-  if (commitType == kLargeCommit || commitType == kSessionCommit)
-  {
-    mdb_percent outActualWaste = 0;
-    mdb_bool outShould;
-    if (mStore) 
-    {
-      // check how much space would be saved by doing a compress commit.
-      // If it's more than 30%, go for it.
-      // N.B. - I'm not sure this calls works in Mork for all cases.
-      err = mStore->ShouldCompress(mEnv, 30, &outActualWaste, &outShould);
-      if (NS_SUCCEEDED(err) && outShould)
-      {
-          commitType = kCompressCommit;
-      }
-      else
-      {
-        mdb_count count;
-        err = mTable->GetCount(mEnv, &count);
-        // Since Mork's shouldCompress doesn't work, we need to look
-        // at the file size and the number of rows, and make a stab
-        // at guessing if we've got a lot of deleted rows. The file
-        // size is the size when we opened the db, and we really want
-        // it to be the size after we've written out the file,
-        // but I think this is a good enough approximation.
-        if (count > 0)
-        {
-          PRInt64 numRows;
-          PRInt64 bytesPerRow;
-          PRInt64 desiredAvgRowSize;
-
-          LL_UI2L(numRows, count);
-          LL_DIV(bytesPerRow, mFileSizeOnDisk, numRows);
-          LL_I2L(desiredAvgRowSize, 400);
-          if (LL_CMP(bytesPerRow, >, desiredAvgRowSize))
-            commitType = kCompressCommit;
-        }
-      }
-    }
-  }
-  switch (commitType)
-  {
-  case kLargeCommit:
-    err = mStore->LargeCommit(mEnv, getter_AddRefs(thumb));
-    break;
-  case kSessionCommit:
-    err = mStore->SessionCommit(mEnv, getter_AddRefs(thumb));
-    break;
-  case kCompressCommit:
-    err = mStore->CompressCommit(mEnv, getter_AddRefs(thumb));
-    break;
-  }
-  if (err == 0) {
-    mdb_count total;
-    mdb_count current;
-    mdb_bool done;
-    mdb_bool broken;
-
-    do {
-      err = thumb->DoMore(mEnv, &total, &current, &done, &broken);
-    } while ((err == 0) && !broken && !done);
-  }
-  if (err != 0) // mork doesn't return NS error codes. Yet.
-    return NS_ERROR_FAILURE;
-  else
-    return NS_OK;
-
-}
-// if notify is true, we'll notify rdf of deleted rows.
-// If we're shutting down history, then (maybe?) we don't
-// need or want to notify rdf.
-nsresult nsGlobalHistory::ExpireEntries(PRBool notify)
-{
-  PRTime expirationDate;
-  PRInt64 microSecondsPerSecond, secondsInDays, microSecondsInExpireDays;
-  
-  LL_I2L(microSecondsPerSecond, PR_USEC_PER_SEC);
-  LL_UI2L(secondsInDays, 60 * 60 * 24 * mExpireDays);
-  LL_MUL(microSecondsInExpireDays, secondsInDays, microSecondsPerSecond);
-  LL_SUB(expirationDate, GetNow(), microSecondsInExpireDays);
-
-  matchExpiration_t expiration;
-  expiration.history = this;
-  expiration.expirationDate = &expirationDate;
-  
-  return RemoveMatchingRows(matchExpirationCallback, (void *)&expiration, notify);
-}
-
-nsresult
-nsGlobalHistory::CloseDB()
-{
-  mdb_err err;
-
-  ExpireEntries(PR_FALSE /* don't notify */);
-  err = Commit(kSessionCommit);
-
-  // order is important here - logically smallest objects first
-  mMetaRow = nsnull;
-  
-  if (mTable)
-    mTable->Release();
-
-  if (mStore)
-    mStore->Release();
-
-  if (mEnv)
-    mEnv->Release();
-
-  mTable = nsnull; mEnv = nsnull; mStore = nsnull;
-
-  return NS_OK;
-}
-
-nsresult
-nsGlobalHistory::FindRow(mdb_column aCol,
-                         const char *aValue, nsIMdbRow **aResult)
-{
-  if (! mStore)
-    return NS_ERROR_NOT_INITIALIZED;
-
-  mdb_err err;
-  PRInt32 len = PL_strlen(aValue);
-  mdbYarn yarn = { (void*) aValue, len, len, 0, 0, nsnull };
-
-  mdbOid rowId;
-  nsCOMPtr<nsIMdbRow> row;
-  if (aResult) {
-    err = mStore->FindRow(mEnv, kToken_HistoryRowScope,
-                          aCol, &yarn, &rowId, getter_AddRefs(row));
-
-    if (!row) return NS_ERROR_NOT_AVAILABLE;
-  } else {
-    err = mStore->FindRow(mEnv, kToken_HistoryRowScope,
-                          aCol, &yarn, &rowId, nsnull);
-  }
-
-  // make sure it's actually stored in the main table
-  mdb_bool hasRow;
-  mTable->HasOid(mEnv, &rowId, &hasRow);
-
-  if (!hasRow) return NS_ERROR_NOT_AVAILABLE;
-  
-  if (aResult) {
-    *aResult = row;
-    (*aResult)->AddRef();
-  }
-
-  return NS_OK;
-}
-
-PRBool
-nsGlobalHistory::IsURLInHistory(nsIRDFResource* aResource)
-{
-  nsresult rv;
-
-  const char* url;
-  rv = aResource->GetValueConst(&url);
-  if (NS_FAILED(rv)) return PR_FALSE;
-
-  rv = FindRow(kToken_URLColumn, url, nsnull);
-  return (NS_SUCCEEDED(rv)) ? PR_TRUE : PR_FALSE;
-}
-
-
-nsresult
-nsGlobalHistory::NotifyAssert(nsIRDFResource* aSource,
-                              nsIRDFResource* aProperty,
-                              nsIRDFNode* aValue)
-{
-  PRUint32 i = mObservers.Count();
-  while (i > 0) {
-    mObservers[--i]->OnAssert(this, aSource, aProperty, aValue);
-  }
-
-  return NS_OK;
-}
-
-
-nsresult
-nsGlobalHistory::NotifyUnassert(nsIRDFResource* aSource,
-                                nsIRDFResource* aProperty,
-                                nsIRDFNode* aValue)
-{
-  PRUint32 i = mObservers.Count();
-  while (i > 0) {
-    mObservers[--i]->OnUnassert(this, aSource, aProperty, aValue);
-  }
-
-  return NS_OK;
-}
-
-
-
-nsresult
-nsGlobalHistory::NotifyChange(nsIRDFResource* aSource,
-                              nsIRDFResource* aProperty,
-                              nsIRDFNode* aOldValue,
-                              nsIRDFNode* aNewValue)
-{
-  PRUint32 i = mObservers.Count();
-  while (i > 0) {
-    mObservers[--i]->OnChange(this, aSource, aProperty, aOldValue, aNewValue);
-  }
-
-  return NS_OK;
-}
-
-//
-// this just generates a static list of find-style queries
-// only returns queries that currently have matches in global history
-// 
-nsresult
-nsGlobalHistory::GetRootDayQueries(nsISimpleEnumerator **aResult, PRBool aBySite)
-{
-  nsresult rv;
-  nsCOMPtr<nsISupportsArray> dayArray;
-  NS_NewISupportsArray(getter_AddRefs(dayArray));
-  
-  PRInt32 i;
-  nsCOMPtr<nsIRDFResource> finduri;
-  nsDependentCString
-    prefix(FIND_BY_AGEINDAYS_PREFIX "is" "&text=");
-  nsCAutoString uri;
-  nsCOMPtr<nsISimpleEnumerator> findEnumerator;
-  PRBool hasMore = PR_FALSE;
-  for (i=0; i<7; i++) {
-    uri = prefix;
-    uri.AppendInt(i);
-    if (aBySite)
-      uri.Append("&groupby=Hostname");
-    rv = gRDFService->GetResource(uri, getter_AddRefs(finduri));
-    if (NS_FAILED(rv)) continue;
-    rv = CreateFindEnumerator(finduri, getter_AddRefs(findEnumerator));
-    if (NS_FAILED(rv)) continue;
-    rv = findEnumerator->HasMoreElements(&hasMore);
-    if (NS_SUCCEEDED(rv) && hasMore)
-      dayArray->AppendElement(finduri);
-  }
-
-  uri = FIND_BY_AGEINDAYS_PREFIX "isgreater" "&text=";
-  uri.AppendInt(i-1);
-  if (aBySite)
-    uri.Append("&groupby=Hostname");
-  rv = gRDFService->GetResource(uri, getter_AddRefs(finduri));
-  if (NS_SUCCEEDED(rv)) {
-    rv = CreateFindEnumerator(finduri, getter_AddRefs(findEnumerator));
-    if (NS_SUCCEEDED(rv)) {
-      rv = findEnumerator->HasMoreElements(&hasMore);
-      if (NS_SUCCEEDED(rv) && hasMore)
-        dayArray->AppendElement(finduri);
-    }
-  }
-
-  return NS_NewArrayEnumerator(aResult, dayArray);
-}
-
-//
-// convert the name/value pairs stored in a string into an array of
-// these pairs
-// find:a=b&c=d&e=f&g=h
-// becomes an array containing
-// {"a" = "b", "c" = "d", "e" = "f", "g" = "h" }
-//
-nsresult
-nsGlobalHistory::FindUrlToTokenList(const char *aURL, nsVoidArray& aResult)
-{
-  if (PL_strncmp(aURL, "find:", 5) != 0)
-    return NS_ERROR_UNEXPECTED;
-  
-  const char *curpos = aURL + 5;
-  const char *tokenstart = curpos;
-
-  // this is where we will store the current name and value
-  const char *tokenName = nsnull;
-  const char *tokenValue = nsnull;
-  PRUint32 tokenNameLength=0;
-  PRUint32 tokenValueLength=0;
-  
-  PRBool haveValue = PR_FALSE;  // needed because some values are 0-length
-  while (PR_TRUE) {
-    while (*curpos && (*curpos != '&') && (*curpos != '='))
-      curpos++;
-
-    if (*curpos == '=')  {        // just found a token name
-      tokenName = tokenstart;
-      tokenNameLength = (curpos - tokenstart);
-    }
-    else if ((!*curpos || *curpos == '&') &&
-             (tokenNameLength>0)) { // found a value, and we have a
-                                    // name
-      tokenValue = tokenstart;
-      tokenValueLength = (curpos - tokenstart);
-      haveValue = PR_TRUE;
-    }
-
-    // once we have a name/value pair, store it away
-    // note we're looking at lengths, so that
-    // "find:&a=b" doesn't connect with a=""
-    if (tokenNameLength>0 && haveValue) {
-
-      tokenPair *tokenStruct = new tokenPair(tokenName, tokenNameLength,
-                                             tokenValue, tokenValueLength);
-      if (tokenStruct)
-        aResult.AppendElement((void *)tokenStruct);
-
-      // reset our state
-      tokenName = tokenValue = nsnull;
-      tokenNameLength = tokenValueLength = 0;
-      haveValue = PR_FALSE;
-    }
-
-    // the test has to be here to catch empty values
-    if (!*curpos) break;
-    
-    curpos++;
-    tokenstart = curpos;
-  }
-
-  return NS_OK;
-}
-
-void
-nsGlobalHistory::FreeTokenList(nsVoidArray& tokens)
-{
-  PRUint32 length = tokens.Count();
-  PRUint32 i;
-  for (i=0; i<length; i++) {
-    tokenPair *token = (tokenPair*)tokens[i];
-    delete token;
-  }
-  tokens.Clear();
-}
-
-void nsGlobalHistory::FreeSearchQuery(searchQuery& aQuery)
-{
-  // free up the token pairs
-  PRInt32 i;
-  for (i=0; i<aQuery.terms.Count(); i++) {
-    searchTerm *term = (searchTerm*)aQuery.terms.ElementAt(i);
-    delete term;
-  }
-  // clean out the array, just for good measure
-  aQuery.terms.Clear();
-}
-
-//
-// helper function to figure out if something starts with "find"
-//
-PRBool
-nsGlobalHistory::IsFindResource(nsIRDFResource *aResource)
-{
-  nsresult rv;
-  const char *value;
-  rv = aResource->GetValueConst(&value);
-  if (NS_FAILED(rv)) return PR_FALSE;
-
-  return (PL_strncmp(value, "find:", 5)==0);
-}
-
-//
-// convert a list of name/value pairs into a search query with 0 or
-// more terms and an optional groupby
-//
-// a term consists of the values of the 4 name/value pairs
-// {datasource, match, method, text}
-// groupby is stored as a column #
-//
-nsresult
-nsGlobalHistory::TokenListToSearchQuery(const nsVoidArray& aTokens,
-                                        searchQuery& aResult)
-{
-
-  PRInt32 i;
-  PRInt32 length = aTokens.Count();
-
-  aResult.groupBy = 0;
-  const char *datasource=nsnull, *property=nsnull,
-    *method=nsnull, *text=nsnull;
-
-  PRUint32 datasourceLen=0, propertyLen=0, methodLen=0, textLen=0;
-  rowMatchCallback matchCallback=nsnull; // matching callback if needed
-  
-  for (i=0; i<length; i++) {
-    tokenPair *token = (tokenPair *)aTokens[i];
-
-    // per-term tokens
-    const nsASingleFragmentCString& tokenName =
-        Substring(token->tokenName, token->tokenName + token->tokenNameLength);
-    if (tokenName.EqualsLiteral("datasource")) {
-      datasource = token->tokenValue;
-      datasourceLen = token->tokenValueLength;
-    }
-    else if (tokenName.EqualsLiteral("match")) {
-      if (Substring(token->tokenValue, token->tokenValue+token->tokenValueLength).Equals("AgeInDays"))
-        matchCallback = matchAgeInDaysCallback;
-      
-      property = token->tokenValue;
-      propertyLen = token->tokenValueLength;
-    }
-    else if (tokenName.EqualsLiteral("method")) {
-      method = token->tokenValue;
-      methodLen = token->tokenValueLength;
-    }    
-    else if (tokenName.EqualsLiteral("text")) {
-      text = token->tokenValue;
-      textLen = token->tokenValueLength;
-    }
-    
-    // really, we should be storing the group-by as a column number or
-    // rdf resource
-    else if (tokenName.EqualsLiteral("groupby")) {
-      mdb_err err;
-      err = mStore->QueryToken(mEnv,
-                               nsCAutoString(token->tokenValue).get(),
-                               &aResult.groupBy);
-      if (err != 0)
-        aResult.groupBy = 0;
-    }
-    
-    // once we complete a term, we move on to the next one
-    if (datasource && property && method && text) {
-      searchTerm *currentTerm = new searchTerm(datasource, datasourceLen,
-                                               property, propertyLen,
-                                               method, methodLen,
-                                               text, textLen);
-      currentTerm->match = matchCallback;
-      
-      // append the old one, then create a new one
-      aResult.terms.AppendElement((void *)currentTerm);
-
-      // reset our state
-      matchCallback=nsnull;
-      currentTerm = nsnull;
-      datasource = property = method = text = 0;
-    }
-  }
-
-  return NS_OK;
-}
-
-nsresult
-nsGlobalHistory::FindUrlToSearchQuery(const char *aUrl, searchQuery& aResult)
-{
-
-  nsresult rv;
-  // convert uri to list of tokens
-  nsVoidArray tokenPairs;
-  rv = FindUrlToTokenList(aUrl, tokenPairs);
-  if (NS_FAILED(rv)) return rv;
-
-  // now convert the tokens to a query
-  rv = TokenListToSearchQuery(tokenPairs, aResult);
-  
-  FreeTokenList(tokenPairs);
-
-  return rv;
-}
-
-// preemptively construct some common find-queries so that we show up
-// asychronously when a search is open
-
-// we have to do the following assertions:
-// (a=AgeInDays, h=hostname; g=groupby, -> = #child)
-// 1) NC:HistoryRoot -> uri
-//
-// 2) NC:HistoryByDate -> a&g=h
-// 3)                     a&g=h -> a&h
-// 4)                              a&h -> uri
-//
-// 5) g=h -> h
-// 6)        h->uri
-nsresult
-nsGlobalHistory::NotifyFindAssertions(nsIRDFResource *aSource,
-                                      nsIMdbRow *aRow)
-{
-  // we'll construct a bunch of sample queries, and then do
-  // appropriate assertions
-
-  // first pull out the appropriate values
-  PRTime lastVisited;
-  GetRowValue(aRow, kToken_LastVisitDateColumn, &lastVisited);
-
-  PRInt32 ageInDays = GetAgeInDays(NormalizeTime(GetNow()), lastVisited);
-  nsCAutoString ageString; ageString.AppendInt(ageInDays);
-
-  nsCAutoString hostname;
-  GetRowValue(aRow, kToken_HostnameColumn, hostname);
-  
-  // construct some terms that we'll use later
-  
-  // Hostname=<hostname>
-  searchTerm hostterm("history", sizeof("history")-1,
-                      "Hostname", sizeof("Hostname")-1,
-                      "is", sizeof("is")-1,
-                      hostname.get(), hostname.Length());
-
-  // AgeInDays=<age>
-  searchTerm ageterm("history", sizeof("history") -1,
-                     "AgeInDays", sizeof("AgeInDays")-1,
-                     "is", sizeof("is")-1,
-                     ageString.get(), ageString.Length());
-
-  searchQuery query;
-  nsCAutoString findUri;
-  nsCOMPtr<nsIRDFResource> childFindResource;
-  nsCOMPtr<nsIRDFResource> parentFindResource;
-
-  // 2) NC:HistoryByDate -> AgeInDays=<age>&groupby=Hostname
-  query.groupBy = kToken_HostnameColumn;
-  query.terms.AppendElement((void *)&ageterm);
-
-  GetFindUriPrefix(query, PR_TRUE, findUri);
-  gRDFService->GetResource(findUri, getter_AddRefs(childFindResource));
-  NotifyAssert(kNC_HistoryByDateAndSite, kNC_child, childFindResource);
-  parentFindResource = childFindResource;
-  
-  query.terms.Clear();
-
-  query.groupBy = 0;
-  query.terms.AppendElement((void *)&ageterm);
-
-  GetFindUriPrefix(query, PR_TRUE, findUri);
-  gRDFService->GetResource(findUri, getter_AddRefs(childFindResource));
-  NotifyAssert(kNC_HistoryByDate, kNC_child, childFindResource);
-
-  query.terms.Clear();
-  
-
-  query.groupBy = 0;
-  query.terms.AppendElement((void *)&ageterm);
-
-  GetFindUriPrefix(query, PR_TRUE, findUri);
-  gRDFService->GetResource(findUri, getter_AddRefs(childFindResource));
-  NotifyAssert(childFindResource, kNC_child, aSource);
-
-  query.terms.Clear();
-
-  // 3) AgeInDays=<age>&groupby=Hostname ->
-  //    AgeInDays=<age>&Hostname=<host>
-  
-
-  query.groupBy = 0;            // create AgeInDays=<age>&Hostname=<host>
-  query.terms.AppendElement((void *)&ageterm);
-  query.terms.AppendElement((void *)&hostterm);
-  
-  GetFindUriPrefix(query, PR_FALSE, findUri);
-  gRDFService->GetResource(findUri, getter_AddRefs(childFindResource));
-  NotifyAssert(parentFindResource, kNC_child, childFindResource);
-  
-  query.terms.Clear();
-
-  // 4) AgeInDays=<age>&Hostname=<host> -> uri
-  parentFindResource = childFindResource; // AgeInDays=<age>&hostname=<host>
-  NotifyAssert(childFindResource, kNC_child, aSource);
-  
-  // 5) groupby=Hostname -> Hostname=<host>
-  query.groupBy = kToken_HostnameColumn; // create groupby=Hostname
-  
-  GetFindUriPrefix(query, PR_TRUE, findUri);
-  gRDFService->GetResource(findUri, getter_AddRefs(parentFindResource));
-
-  query.groupBy = 0;            // create Hostname=<host>
-  query.terms.AppendElement((void *)&hostterm);
-  GetFindUriPrefix(query, PR_FALSE, findUri);
-  findUri.Append(hostname);     // append <host>
-  gRDFService->GetResource(findUri, getter_AddRefs(childFindResource));
-  
-  NotifyAssert(parentFindResource, kNC_child, childFindResource);
-
-  // 6) Hostname=<host> -> uri
-  parentFindResource = childFindResource; // Hostname=<host>
-  NotifyAssert(parentFindResource, kNC_child, aSource);
-
-  return NS_OK;
-}
-
-
-// simpler than NotifyFindAssertions - basically just notifies
-// unassertions from
-// 1) NC:HistoryRoot -> uri
-// 2) a&h -> uri
-// 3) h -> uri
-
-nsresult
-nsGlobalHistory::NotifyFindUnassertions(nsIRDFResource *aSource,
-                                        nsIMdbRow* aRow)
-{
-  // 1) NC:HistoryRoot
-  NotifyUnassert(kNC_HistoryRoot, kNC_child, aSource);
-
-  //    first get age in days
-  PRTime lastVisited;
-  GetRowValue(aRow, kToken_LastVisitDateColumn, &lastVisited);
-  PRInt32 ageInDays = GetAgeInDays(NormalizeTime(GetNow()), lastVisited);
-  nsCAutoString ageString; ageString.AppendInt(ageInDays);
-
-  //    now get hostname
-  nsCAutoString hostname;
-  GetRowValue(aRow, kToken_HostnameColumn, hostname);
-
-  //    construct some terms
-  //    Hostname=<hostname>
-  searchTerm hostterm("history", sizeof("history")-1,
-                      "Hostname", sizeof("Hostname")-1,
-                      "is", sizeof("is")-1,
-                      hostname.get(), hostname.Length());
-  
-  //    AgeInDays=<age>
-  searchTerm ageterm("history", sizeof("history") -1,
-                     "AgeInDays", sizeof("AgeInDays")-1,
-                     "is", sizeof("is")-1,
-                     ageString.get(), ageString.Length());
-
-  searchQuery query;
-  query.groupBy = 0;
-  
-  nsCAutoString findUri;
-  nsCOMPtr<nsIRDFResource> findResource;
-  
-  // 2) AgeInDays=<age>&Hostname=<host>
-  query.terms.AppendElement((void *)&ageterm);
-  query.terms.AppendElement((void *)&hostterm);
-  GetFindUriPrefix(query, PR_FALSE, findUri);
-  
-  gRDFService->GetResource(findUri, getter_AddRefs(findResource));
-  
-  NotifyUnassert(findResource, kNC_child, aSource);
-
-  // 3) Hostname=<host>
-  query.terms.Clear();
-  
-  query.terms.AppendElement((void *)&hostterm);
-  GetFindUriPrefix(query, PR_FALSE, findUri);
-  
-  gRDFService->GetResource(findUri, getter_AddRefs(findResource));
-  NotifyUnassert(findResource, kNC_child, aSource);
-
-  query.terms.Clear();
-
-  return NS_OK;
-}
-
-//
-// get the user-visible "name" of a find resource
-// we basically parse the string, and use the data stored in the last
-// term to generate an appropriate string
-//
-nsresult
-nsGlobalHistory::GetFindUriName(const char *aURL, nsIRDFNode **aResult)
-{
-
-  nsresult rv;
-
-  searchQuery query;
-  rv = FindUrlToSearchQuery(aURL, query);
-
-  // can't exactly get a name if there's nothing to search for
-  if (query.terms.Count() < 1)
-    return NS_OK;
-
-  // now build up a string from the query (using only the last term)
-  searchTerm *term = (searchTerm*)query.terms[query.terms.Count()-1];
-
-  // automatically build up string in the form
-  // findurl-<property>-<method>[-<text>]
-  // such as "finduri-AgeInDays-is" or "find-uri-AgeInDays-is-0"
-  nsAutoString stringName(NS_LITERAL_STRING("finduri-"));
-
-  // property
-  stringName.Append(NS_ConvertASCIItoUTF16(term->property));
-  stringName.Append(PRUnichar('-'));
-
-  // and now the method, such as "is" or "isgreater"
-  stringName.Append(NS_ConvertASCIItoUTF16(term->method));
-
-  // try adding -<text> to see if there's a match
-  // for example, to match
-  // finduri-LastVisitDate-is-0=Today
-  PRInt32 preTextLength = stringName.Length();
-  stringName.Append(PRUnichar('-'));
-  stringName.Append(term->text);
-  stringName.Append(PRUnichar(0));
-
-  // try to find a localizable string
-  const PRUnichar *strings[] = {
-    term->text.get()
-  };
-  nsXPIDLString value;
-
-  // first with the search text
-  rv = mBundle->FormatStringFromName(stringName.get(),
-                                     strings, 1, getter_Copies(value));
-
-  // ok, try it without the -<text>, to match
-  // finduri-LastVisitDate-is=%S days ago
-  if (NS_FAILED(rv)) {
-    stringName.Truncate(preTextLength);
-    rv = mBundle->FormatStringFromName(stringName.get(),
-                                       strings, 1, getter_Copies(value));
-  }
-
-  nsCOMPtr<nsIRDFLiteral> literal;
-  if (NS_SUCCEEDED(rv)) {
-    rv = gRDFService->GetLiteral(value, getter_AddRefs(literal));
-  } else {
-    // ok, no such string, so just put the match text itself there
-    rv = gRDFService->GetLiteral(term->text.get(),
-                                 getter_AddRefs(literal));
-  }
-  FreeSearchQuery(query);
-    
-  if (NS_FAILED(rv)) return rv;
-  
-  *aResult = literal;
-  NS_ADDREF(*aResult);
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-nsGlobalHistory::Observe(nsISupports *aSubject, 
-                         const char *aTopic,
-                         const PRUnichar *aSomeData)
-{
-  nsresult rv;
-  // pref changing - update member vars
-  if (!nsCRT::strcmp(aTopic, "nsPref:changed")) {
-    NS_ENSURE_STATE(gPrefBranch);
-
-    // expiration date
-    if (!nsCRT::strcmp(aSomeData, NS_LITERAL_STRING(PREF_BROWSER_HISTORY_EXPIRE_DAYS).get())) {
-      gPrefBranch->GetIntPref(PREF_BROWSER_HISTORY_EXPIRE_DAYS, &mExpireDays);
-    }
-    else if (!nsCRT::strcmp(aSomeData, NS_LITERAL_STRING(PREF_AUTOCOMPLETE_ONLY_TYPED).get())) {
-      gPrefBranch->GetBoolPref(PREF_AUTOCOMPLETE_ONLY_TYPED, &mAutocompleteOnlyTyped);
-    }
-  }
-  else if (!nsCRT::strcmp(aTopic, "profile-before-change")) {
-    rv = CloseDB();    
-    if (!nsCRT::strcmp(aSomeData, NS_LITERAL_STRING("shutdown-cleanse").get())) {
-      nsCOMPtr <nsIFile> historyFile;
-      rv = NS_GetSpecialDirectory(NS_APP_HISTORY_50_FILE, getter_AddRefs(historyFile));
-      if (NS_SUCCEEDED(rv))
-        rv = historyFile->Remove(PR_FALSE);
-    }
-  }
-  else if (!nsCRT::strcmp(aTopic, "profile-do-change"))
-    rv = OpenDB();
-  else if (!nsCRT::strcmp(aTopic, "quit-application"))
-    rv = Flush();
-
-  return NS_OK;
-}
-
-//----------------------------------------------------------------------
-//
-// nsGlobalHistory::URLEnumerator
-//
-//   Implementation
-
-nsGlobalHistory::URLEnumerator::~URLEnumerator()
-{
-  nsMemory::Free(mSelectValue);
-}
-
-
-PRBool
-nsGlobalHistory::URLEnumerator::IsResult(nsIMdbRow* aRow)
-{
-  if (HasCell(mEnv, aRow, mHiddenColumn))
-    return PR_FALSE;
-  
-  if (mSelectColumn) {
-    mdb_err err;
-
-    mdbYarn yarn;
-    err = aRow->AliasCellYarn(mEnv, mURLColumn, &yarn);
-    if (err != 0) return PR_FALSE;
-
-    // Do bitwise comparison
-    PRInt32 count = PRInt32(yarn.mYarn_Fill);
-    if (count != mSelectValueLen)
-      return PR_FALSE;
-
-    const char* p = (const char*) yarn.mYarn_Buf;
-    const char* q = (const char*) mSelectValue;
-
-    while (--count >= 0) {
-      if (*p++ != *q++)
-        return PR_FALSE;
-    }
-  }
-
-  return PR_TRUE;
-}
-
-nsresult
-nsGlobalHistory::URLEnumerator::ConvertToISupports(nsIMdbRow* aRow, nsISupports** aResult)
-{
-  mdb_err err;
-
-  mdbYarn yarn;
-  err = aRow->AliasCellYarn(mEnv, mURLColumn, &yarn);
-  if (err != 0) return NS_ERROR_FAILURE;
-
-  // Since the URLEnumerator always returns the value of the URL
-  // column, we create an RDF resource.
-  nsresult rv;
-  nsCOMPtr<nsIRDFResource> resource;
-  const char* startPtr = (const char*) yarn.mYarn_Buf;
-  rv = gRDFService->GetResource(
-            Substring(startPtr, startPtr+yarn.mYarn_Fill),
-            getter_AddRefs(resource));
-  if (NS_FAILED(rv)) return rv;
-
-  *aResult = resource;
-  NS_ADDREF(*aResult);
-  return NS_OK;
-}
-
-//----------------------------------------------------------------------
-// nsGlobalHistory::SearchEnumerator
-//
-//   Implementation
-
-nsGlobalHistory::SearchEnumerator::~SearchEnumerator()
-{
-  nsGlobalHistory::FreeSearchQuery(*mQuery);
-  delete mQuery;
-}
-
-
-// convert the query in mQuery into a find URI
-// if there is a groupby= in the query, then convert that
-// into the start of another search term
-// for example, in the following query with one term:
-//
-// term[0] = { history, AgeInDays, is, 0 }
-// groupby = Hostname
-//
-// we generate the following uri:
-//
-// find:datasource=history&match=AgeInDays&method=is&text=0&datasource=history
-//   &match=Hostname&method=is&text=
-//
-// and then the caller will append some text after after the "text="
-//
-void
-nsGlobalHistory::GetFindUriPrefix(const searchQuery& aQuery,
-                                  const PRBool aDoGroupBy,
-                                  nsACString& aResult)
-{
-  mdb_err err;
-  
-  aResult.Assign("find:");
-  PRUint32 length = aQuery.terms.Count();
-  PRUint32 i;
-  
-  for (i=0; i<length; i++) {
-    searchTerm *term = (searchTerm*)aQuery.terms[i];
-    if (i != 0)
-      aResult.Append('&');
-    aResult.Append("datasource=");
-    aResult.Append(term->datasource);
-    
-    aResult.Append("&match=");
-    aResult.Append(term->property);
-    
-    aResult.Append("&method=");
-    aResult.Append(term->method);
-
-    aResult.Append("&text=");
-    aResult.Append(NS_ConvertUTF16toUTF8(term->text));
-  }
-
-  if (aQuery.groupBy == 0) return;
-
-  // find out the name of the column we're grouping by
-  char groupby[100];
-  mdbYarn yarn = { groupby, 0, sizeof(groupby), 0, 0, nsnull };
-  err = mStore->TokenToString(mEnv, aQuery.groupBy, &yarn);
-  
-  // put a "groupby=<colname>"
-  if (aDoGroupBy) {
-    aResult.Append("&groupby=");
-    if (err == 0)
-      aResult.Append((const char*)yarn.mYarn_Buf, yarn.mYarn_Fill);
-  }
-
-  // put &datasource=history&match=<colname>&method=is&text=
-  else {
-    // if the query has a groupby=<foo> then we want to append that
-    // field as the last field to match.. caller has to be sure to
-    // append that!
-    aResult.Append("&datasource=history");
-    
-    aResult.Append("&match=");
-    if (err == 0)
-      aResult.Append((const char*)yarn.mYarn_Buf, yarn.mYarn_Fill);
-    // herep  
-    aResult.Append("&method=is");
-    aResult.Append("&text=");
-  }
-  
-}
-
-//
-// determines if the given row matches all terms
-//
-// if there is a "groupBy" column, then we have to remember that we've
-// seen a row with the given value in that column, and then make sure
-// all future rows with that value in that column DON'T match, no
-// matter if they match the terms or not.
-PRBool
-nsGlobalHistory::SearchEnumerator::IsResult(nsIMdbRow *aRow)
-{
-  if (HasCell(mEnv, aRow, mHiddenColumn))
-    return PR_FALSE;
-  
-  mdb_err err;
-
-  mdbYarn groupColumnValue = { nsnull, 0, 0, 0, 0, nsnull};
-  if (mQuery->groupBy!=0) {
-
-    // if we have a 'groupby', then we use the hashtable to make sure
-    // we only match the FIRST row with the column value that we're
-    // grouping by
-    
-    err = aRow->AliasCellYarn(mEnv, mQuery->groupBy, &groupColumnValue);
-    if (err!=0) return PR_FALSE;
-    if (!groupColumnValue.mYarn_Buf) return PR_FALSE;
-
-    const char* startPtr = (const char*)groupColumnValue.mYarn_Buf;
-    nsCStringKey key(Substring(startPtr,
-                               startPtr +  groupColumnValue.mYarn_Fill));
-
-    void *otherRow = mUniqueRows.Get(&key);
-
-    // Hey! we've seen this row before, so ignore it
-    if (otherRow) return PR_FALSE;
-  }
-
-  // now do the actual match
-  if (!mHistory->RowMatches(aRow, mQuery, PR_FALSE))
-    return PR_FALSE;
-
-  if (mQuery->groupBy != 0) {
-    // we got this far, so we must have matched.
-    // add ourselves to the hashtable so we don't match rows like this
-    // in the future
-    const char* startPtr = (const char*)groupColumnValue.mYarn_Buf;
-    nsCStringKey key(Substring(startPtr,
-                               startPtr + groupColumnValue.mYarn_Fill));
-    
-    // note - weak ref, don't worry about releasing
-    mUniqueRows.Put(&key, (void *)aRow);
-  }
-
-  return PR_TRUE;
-}
-
-//
-// determines if the row matches the given terms, used above
-//
-PRBool
-nsGlobalHistory::RowMatches(nsIMdbRow *aRow,
-                            searchQuery *aQuery,
-                            PRBool caseSensitive)
-{
-  PRUint32 length = aQuery->terms.Count();
-  PRUint32 i;
-
-  for (i=0; i<length; i++) {
-    
-    searchTerm *term = (searchTerm*)aQuery->terms[i];
-
-    if (!term->datasource.Equals("history"))
-      continue;                 // we only match against history queries
-    
-    // use callback if it exists
-    if (term->match) {
-      // queue up some values just in case callback needs it
-      // (how would we do this dynamically?)
-      matchSearchTerm_t matchSearchTerm = { mEnv, mStore, term , PR_FALSE};
-      
-      if (!term->match(aRow, (void *)&matchSearchTerm))
-        return PR_FALSE;
-    } else {
-      mdb_err err;
-
-      mdb_column property_column;
-      nsCAutoString property_name(term->property);
-      property_name.Append(char(0));
-      
-      err = mStore->QueryToken(mEnv, property_name.get(), &property_column);
-      if (err != 0) {
-        NS_WARNING("Unrecognized column!");
-        continue;               // assume we match???
-      }
-      
-      // match the term directly against the column?
-      mdbYarn yarn;
-      err = aRow->AliasCellYarn(mEnv, property_column, &yarn);
-      if (err != 0 || !yarn.mYarn_Buf) return PR_FALSE;
-      
-      nsAutoString rowVal;
-
-      PRInt32 yarnLength = yarn.mYarn_Fill;;
-      if (property_column == kToken_NameColumn) {
-        // The name column (page title) is stored as UTF-16.
-        rowVal.Assign((const PRUnichar*)yarn.mYarn_Buf, yarnLength / 2);
-      }
-      else {
-        // Other columns are stored as UTF-8 and can be null.
-        if (yarn.mYarn_Buf)
-          rowVal = NS_ConvertUTF8toUTF16((const char*)yarn.mYarn_Buf, yarnLength);
-      }
-      
-      // set up some iterators
-      nsString::const_iterator start, end;
-      rowVal.BeginReading(start);
-      rowVal.EndReading(end);
-
-      const nsXPIDLString& searchText = term->text;
-      
-      if (term->method.Equals("is")) {
-        if (caseSensitive) {
-          if (!searchText.Equals(rowVal, nsDefaultStringComparator()))
-            return PR_FALSE;
-        }
-        else {
-          if (!searchText.Equals(rowVal, nsCaseInsensitiveStringComparator()))
-            return PR_FALSE;
-        }
-      }
-
-      else if (term->method.Equals("isnot")) {        
-        if (caseSensitive) {
-          if (searchText.Equals(rowVal, nsDefaultStringComparator()))
-            return PR_FALSE;
-        }
-        else {
-          if (searchText.Equals(rowVal, nsCaseInsensitiveStringComparator()))
-            return PR_FALSE;
-        }
-      }
-
-      else if (term->method.Equals("contains")) {
-        if (caseSensitive) {
-          if (!FindInReadable(searchText, start, end, nsDefaultStringComparator()))
-            return PR_FALSE;
-        }
-        else {
-          if (!FindInReadable(searchText, start, end, nsCaseInsensitiveStringComparator()))
-            return PR_FALSE;
-        }
-      }
-
-      else if (term->method.Equals("doesntcontain")) {
-        if (caseSensitive) {
-          if (FindInReadable(searchText, start, end, nsDefaultStringComparator()))
-            return PR_FALSE;
-        }
-        else {
-          if (FindInReadable(searchText, start, end, nsCaseInsensitiveStringComparator()))
-            return PR_FALSE;
-        }
-      }
-
-      else if (term->method.Equals("startswith")) {
-        // need to make sure that the found string is 
-        // at the beginning of the string
-        nsAString::const_iterator real_start = start;
-        if (caseSensitive) {
-          if (!(FindInReadable(searchText, start, end, nsDefaultStringComparator()) && real_start == start))
-            return PR_FALSE;
-        }
-        else {
-          if (!(FindInReadable(searchText, start, end, nsCaseInsensitiveStringComparator()) &&
-                real_start == start))
-            return PR_FALSE;
-        }
-      }
-
-      else if (term->method.Equals("endswith")) {
-        // need to make sure that the found string ends
-        // at the end of the string
-        nsAString::const_iterator real_end = end;
-        if (caseSensitive) {
-          if (!(RFindInReadable(searchText, start, end, nsDefaultStringComparator()) && real_end == end))
-            return PR_FALSE;
-        }
-        else {
-          if (!(RFindInReadable(searchText, start, end, nsCaseInsensitiveStringComparator()) &&
-                real_end == end))
-          return PR_FALSE;
-        }
-      }
-
-      else {
-        NS_WARNING("Unrecognized search method in SearchEnumerator::RowMatches");
-        // don't handle other match types like isgreater/etc yet,
-        // so assume the match failed and bail
-        return PR_FALSE;
-      }
-      
-    }
-  }
-  
-  // we've gone through each term and didn't bail, so they must have
-  // all matched!
-  return PR_TRUE;
-}
-
-// 
-// return either the row, or another find resource.
-// if we're doing grouping, then we don't want to return a real row,
-// instead we want to expand the current query into a deeper query
-// where we match up the groupby attribute.
-// if we're not doing grouping, then we just return the URL for the
-// current row
-nsresult
-nsGlobalHistory::SearchEnumerator::ConvertToISupports(nsIMdbRow* aRow,
-                                                      nsISupports** aResult)
-
-{
-  mdb_err err;
-  nsresult rv;
-  
-  nsCOMPtr<nsIRDFResource> resource;
-  if (mQuery->groupBy == 0) {
-    // no column to group by
-    // just create a resource based on the URL of the current row
-    mdbYarn yarn;
-    err = aRow->AliasCellYarn(mEnv, mHistory->kToken_URLColumn, &yarn);
-    if (err != 0) return NS_ERROR_FAILURE;
-
-    
-    const char* startPtr = (const char*)yarn.mYarn_Buf;
-    rv = gRDFService->GetResource(
-            Substring(startPtr, startPtr+yarn.mYarn_Fill),
-            getter_AddRefs(resource));
-    if (NS_FAILED(rv)) return rv;
-
-    *aResult = resource;
-    NS_ADDREF(*aResult);
-    return NS_OK;
-  }
-
-  // we have a group by, so now we recreate the find url, but add a
-  // query for the row asked for by groupby
-  mdbYarn groupByValue;
-  err = aRow->AliasCellYarn(mEnv, mQuery->groupBy, &groupByValue);
-  if (err != 0) return NS_ERROR_FAILURE;
-
-  if (mFindUriPrefix.IsEmpty())
-    mHistory->GetFindUriPrefix(*mQuery, PR_FALSE, mFindUriPrefix);
-  
-  nsCAutoString findUri(mFindUriPrefix);
-
-  const char* startPtr = (const char *)groupByValue.mYarn_Buf;
-  findUri.Append(Substring(startPtr, startPtr+groupByValue.mYarn_Fill));
-  findUri.Append('\0');
-
-  rv = gRDFService->GetResource(findUri, getter_AddRefs(resource));
-  if (NS_FAILED(rv)) return rv;
-
-  *aResult = resource;
-  NS_ADDREF(*aResult);
-  return NS_OK;
-}
-
-//----------------------------------------------------------------------
-//
-// nsIAutoCompleteSession implementation
-//
-
-NS_IMETHODIMP
-nsGlobalHistory::StartSearch(const nsAString &aSearchString,
-                             const nsAString &aSearchParam,
-                             nsIAutoCompleteResult *aPreviousResult,
-                             nsIAutoCompleteObserver *aListener)
-{
-  NS_ENSURE_ARG_POINTER(aListener);
-  NS_ENSURE_STATE(gPrefBranch);
-
-  NS_ENSURE_SUCCESS(OpenDB(), NS_ERROR_FAILURE);
-  
-  nsCOMPtr<nsIAutoCompleteMdbResult2> result;
-  if (aSearchString.IsEmpty()) {
-    AutoCompleteTypedSearch(getter_AddRefs(result));
-  } else {
-    // if the search string is empty after it has had prefixes removed, then 
-    // we need to ignore the previous result set
-    nsAutoString cut(aSearchString);
-    AutoCompleteCutPrefix(cut, nsnull);
-    if (cut.Length() == 0)
-      aPreviousResult = nsnull;
-    
-    // pass string through filter and then determine which prefixes to exclude
-    // when chopping prefixes off of history urls during comparison
-    nsString filtered = AutoCompletePrefilter(aSearchString);
-    AutocompleteExclude exclude;
-    AutoCompleteGetExcludeInfo(filtered, &exclude);
-    
-    // perform the actual search here
-    nsresult rv = AutoCompleteSearch(filtered, &exclude,
-                                     static_cast<nsIAutoCompleteMdbResult2 *>
-                                                (aPreviousResult),
-                                     getter_AddRefs(result));
-    NS_ENSURE_SUCCESS(rv, rv);
-  }
-
-  aListener->OnSearchResult(this, result);  
-  
-  return NS_OK;
-}
-
-
-NS_IMETHODIMP
-nsGlobalHistory::StopSearch()
-{
-  return NS_OK;
-}
-
-//----------------------------------------------------------------------
-//
-// AutoComplete stuff
-//
-
-nsresult
-nsGlobalHistory::AutoCompleteTypedSearch(nsIAutoCompleteMdbResult2 **aResult)
-{
-  mdb_count count;
-  mdb_err err = mTable->GetCount(mEnv, &count);
-
-  // Get a cursor to iterate through all rows in the database
-  nsCOMPtr<nsIMdbTableRowCursor> rowCursor;
-   err = mTable->GetTableRowCursor(mEnv, count, getter_AddRefs(rowCursor));
-  NS_ENSURE_TRUE(!err, NS_ERROR_FAILURE);
-
-  nsresult rv;
-  nsCOMPtr<nsIAutoCompleteMdbResult2> result = do_CreateInstance("@mozilla.org/autocomplete/mdb-result;1", &rv);
-  NS_ENSURE_SUCCESS(rv, rv);
-  result->Init(mEnv, mTable);
-  result->SetTokens(kToken_URLColumn, nsIAutoCompleteMdbResult2::kCharType, kToken_NameColumn, nsIAutoCompleteMdbResult2::kUnicharType);
-  result->SetReverseByteOrder(mReverseByteOrder);
-
-  nsCOMPtr<nsIMdbRow> row;
-  mdb_pos pos;
-  do {
-    rowCursor->PrevRow(mEnv, getter_AddRefs(row), &pos);
-    if (!row) break;
-    
-    if (HasCell(mEnv, row, kToken_TypedColumn)) {
-      result->AddRow(row);
-    }
-  } while (row);
-
-  // Determine the result of the search
-  PRUint32 matchCount;
-  rv = result->GetMatchCount(&matchCount);
-  if (matchCount > 0) {
-    result->SetSearchResult(nsIAutoCompleteResult::RESULT_SUCCESS);
-    result->SetDefaultIndex(0);
-  } else {
-    result->SetSearchResult(nsIAutoCompleteResult::RESULT_NOMATCH);
-    result->SetDefaultIndex(-1);
-  }
-
-  *aResult = result;
-  NS_ADDREF(*aResult);
-  
-  return NS_OK;
-}
-
-nsresult
-nsGlobalHistory::AutoCompleteSearch(const nsAString &aSearchString,
-                                    AutocompleteExclude *aExclude,
-                                    nsIAutoCompleteMdbResult2 *aPrevResult,
-                                    nsIAutoCompleteMdbResult2 **aResult)
-{
-  // determine if we can skip searching the whole history and only search
-  // through the previous search results
-  PRBool searchPrevious = PR_FALSE;
-  if (aPrevResult) {
-    nsAutoString prevURLStr;
-    aPrevResult->GetSearchString(prevURLStr);
-    // if search string begins with the previous search string, it's a go
-    searchPrevious = Substring(aSearchString, 0, prevURLStr.Length()).Equals(prevURLStr);
-  }
-    
-  if (searchPrevious) {
-    // Search through the previous result
-    PRUint32 matchCount;
-    aPrevResult->GetMatchCount(&matchCount);
-    for (PRInt32 i = matchCount-1; i >= 0; --i) {
-      // Make a copy of the value because AutoCompleteCompare is destructive
-      nsAutoString url;
-      aPrevResult->GetValueAt(i, url);
-      
-      if (!AutoCompleteCompare(url, aSearchString, aExclude))
-        aPrevResult->RemoveValueAt(i, PR_FALSE);
-    }
-    
-    NS_ADDREF(*aResult = aPrevResult);
-  } else {
-    // Search through the entire history
-        
-    // Create and initialize a new result object
-    nsresult rv = NS_OK;
-    nsCOMPtr<nsIAutoCompleteMdbResult2> result = do_CreateInstance("@mozilla.org/autocomplete/mdb-result;1", &rv);
-    NS_ENSURE_SUCCESS(rv, rv);
-    result->Init(mEnv, mTable);
-    result->SetTokens(kToken_URLColumn, nsIAutoCompleteMdbResult2::kCharType, kToken_NameColumn, nsIAutoCompleteMdbResult2::kUnicharType);
-    result->SetReverseByteOrder(mReverseByteOrder);
-    result->SetSearchString(aSearchString);
-
-    // Get a cursor to iterate through all rows in the database
-    nsCOMPtr<nsIMdbTableRowCursor> rowCursor;
-    mdb_err err = mTable->GetTableRowCursor(mEnv, -1, getter_AddRefs(rowCursor));
-    NS_ENSURE_TRUE(!err, NS_ERROR_FAILURE);
-
-    // Store hits in an nsIArray initially
-    nsCOMArray<nsIMdbRow> resultArray;
-
-    nsCOMPtr<nsIMdbRow> row;
-    mdb_pos pos;
-    do {
-      rowCursor->NextRow(mEnv, getter_AddRefs(row), &pos);
-      if (!row) break;
-      
-      if (!HasCell(mEnv, row, kToken_TypedColumn))
-        if (mAutocompleteOnlyTyped || HasCell(mEnv, row, kToken_HiddenColumn))
-          continue;
-
-      nsCAutoString url;
-      GetRowValue(row, kToken_URLColumn, url);
-
-      NS_ConvertUTF8toUTF16 utf8Url(url);
-      if (AutoCompleteCompare(utf8Url, aSearchString, aExclude))
-        resultArray.AppendObject(row);
-    } while (row);
-    
-    // Setup the structure we pass into the sort function,
-    // including a set of url prefixes to ignore.   These prefixes 
-    // must match with the logic in nsGlobalHistory::nsGlobalHistory().
-    NS_NAMED_LITERAL_STRING(prefixHWStr, "http://www.");
-    NS_NAMED_LITERAL_STRING(prefixHStr, "http://");
-    NS_NAMED_LITERAL_STRING(prefixHSWStr, "https://www.");
-    NS_NAMED_LITERAL_STRING(prefixHSStr, "https://");
-    NS_NAMED_LITERAL_STRING(prefixFFStr, "ftp://ftp.");
-    NS_NAMED_LITERAL_STRING(prefixFStr, "ftp://");
-
-    // note: the number of prefixes stored in the closure below 
-    // must match with the constant AUTOCOMPLETE_PREFIX_LIST_COUNT
-    AutoCompleteSortClosure closure;
-    closure.history = this;
-    closure.prefixCount = AUTOCOMPLETE_PREFIX_LIST_COUNT;
-    closure.prefixes[0] = &prefixHWStr;
-    closure.prefixes[1] = &prefixHStr;
-    closure.prefixes[2] = &prefixHSWStr;
-    closure.prefixes[3] = &prefixHSStr;
-    closure.prefixes[4] = &prefixFFStr;
-    closure.prefixes[5] = &prefixFStr;
-
-    // sort it
-    resultArray.Sort(AutoCompleteSortComparison, static_cast<void*>(&closure));
-
-    // place the sorted array into the autocomplete results
-    PRUint32 count = resultArray.Count();
-    PRUint32 i;
-    for (i = 0; i < count; ++i) {
-      result->AddRow(resultArray[i]);
-    }
-
-    // Determine the result of the search
-    PRUint32 matchCount;
-    rv = result->GetMatchCount(&matchCount);
-    if (matchCount > 0) {
-      result->SetSearchResult(nsIAutoCompleteResult::RESULT_SUCCESS);
-      result->SetDefaultIndex(0);
-    } else {
-      result->SetSearchResult(nsIAutoCompleteResult::RESULT_NOMATCH);
-      result->SetDefaultIndex(-1);
-    }
-    
-    *aResult = result;
-    NS_ADDREF(*aResult);
-  }
-    
-  return NS_OK;
-}
-
-// If aURL begins with a protocol or domain prefix from our lists,
-// then mark their index in an AutocompleteExclude struct.
-void
-nsGlobalHistory::AutoCompleteGetExcludeInfo(const nsAString& aURL, AutocompleteExclude* aExclude)
-{
-  aExclude->schemePrefix = -1;
-  aExclude->hostnamePrefix = -1;
-  
-  PRInt32 index = 0;
-  PRInt32 i;
-  for (i = 0; i < mIgnoreSchemes.Count(); ++i) {
-    nsString* string = mIgnoreSchemes.StringAt(i);    
-    if (Substring(aURL, 0, string->Length()).Equals(*string)) {
-      aExclude->schemePrefix = i;
-      index = string->Length();
-      break;
-    }
-  }
-  
-  for (i = 0; i < mIgnoreHostnames.Count(); ++i) {
-    nsString* string = mIgnoreHostnames.StringAt(i);    
-    if (Substring(aURL, index, string->Length()).Equals(*string)) {
-      aExclude->hostnamePrefix = i;
-      break;
-    }
-  }
-}
-
-// Cut any protocol and domain prefixes from aURL, except for those which
-// are specified in aExclude
-void
-nsGlobalHistory::AutoCompleteCutPrefix(nsAString& aURL, AutocompleteExclude* aExclude)
-{
-  // This comparison is case-sensitive.  Therefore, it assumes that aUserURL is a 
-  // potential URL whose host name is in all lower case.
-  PRInt32 idx = 0;
-  PRInt32 i;
-  for (i = 0; i < mIgnoreSchemes.Count(); ++i) {
-    if (aExclude && i == aExclude->schemePrefix)
-      continue;
-    nsString* string = mIgnoreSchemes.StringAt(i);    
-    if (Substring(aURL, 0, string->Length()).Equals(*string)) {
-      idx = string->Length();
-      break;
-    }
-  }
-
-  if (idx > 0)
-    aURL.Cut(0, idx);
-
-  idx = 0;
-  for (i = 0; i < mIgnoreHostnames.Count(); ++i) {
-    if (aExclude && i == aExclude->hostnamePrefix)
-      continue;
-    nsString* string = mIgnoreHostnames.StringAt(i);    
-    if (Substring(aURL, 0, string->Length()).Equals(*string)) {
-      idx = string->Length();
-      break;
-    }
-  }
-
-  if (idx > 0)
-    aURL.Cut(0, idx);
-}
-
-nsString
-nsGlobalHistory::AutoCompletePrefilter(const nsAString& aSearchString)
-{
-  nsAutoString url(aSearchString);
-
-  PRInt32 slash = url.FindChar('/', 0);
-  if (slash >= 0) {
-    // if user is typing a url but has already typed past the host,
-    // then convert the host to lowercase
-    nsAutoString host;
-    url.Left(host, slash);
-    ToLowerCase(host);
-    url.Assign(host + Substring(url, slash, url.Length()-slash));
-  } else {
-    // otherwise, assume the user could still be typing the host, and
-    // convert everything to lowercase
-    ToLowerCase(url);
-  }
-  
-  return nsString(url);
-}
-
-PRBool
-nsGlobalHistory::AutoCompleteCompare(nsAString& aHistoryURL, 
-                                     const nsAString& aUserURL, 
-                                     AutocompleteExclude* aExclude)
-{
-  AutoCompleteCutPrefix(aHistoryURL, aExclude);
-  
-  return Substring(aHistoryURL, 0, aUserURL.Length()).Equals(aUserURL);
-}
-
-int PR_CALLBACK 
-nsGlobalHistory::AutoCompleteSortComparison(nsIMdbRow *row1, nsIMdbRow *row2, 
-                                            void *closureVoid) 
-{
-  //
-  // NOTE: The design and reasoning behind the following autocomplete 
-  // sort implementation is documented in bug 78270.
-  //
-  // cast our function parameters back into their real form
-  AutoCompleteSortClosure* closure = 
-      static_cast<AutoCompleteSortClosure*>(closureVoid);
-
-  // get visit counts - we're ignoring all errors from GetRowValue(), 
-  // and relying on default values
-  PRInt32 item1visits = 0, item2visits = 0;
-  closure->history->GetRowValue(row1, 
-                                closure->history->kToken_VisitCountColumn, 
-                                &item1visits);
-  closure->history->GetRowValue(row2, 
-                                closure->history->kToken_VisitCountColumn, 
-                                &item2visits);
-
-  // get URLs
-  nsAutoString url1, url2;
-  closure->history->GetRowValue(row1, closure->history->kToken_URLColumn, url1);
-  closure->history->GetRowValue(row2, closure->history->kToken_URLColumn, url2);
-
-  // Favour websites and webpaths more than webpages by boosting 
-  // their visit counts.  This assumes that URLs have been normalized, 
-  // appending a trailing '/'.
-  // 
-  // We use addition to boost the visit count rather than multiplication 
-  // since we want URLs with large visit counts to remain pretty much 
-  // in raw visit count order - we assume the user has visited these urls
-  // often for a reason and there shouldn't be a problem with putting them 
-  // high in the autocomplete list regardless of whether they are sites/
-  // paths or pages.  However for URLs visited only a few times, sites 
-  // & paths should be presented before pages since they are generally 
-  // more likely to be visited again.
-  //
-  PRBool isPath1 = PR_FALSE, isPath2 = PR_FALSE;
-  if (!url1.IsEmpty())
-  {
-    // url is a site/path if it has a trailing slash
-    isPath1 = (url1.Last() == PRUnichar('/'));
-    if (isPath1)
-      item1visits += AUTOCOMPLETE_NONPAGE_VISIT_COUNT_BOOST;
-  }
-  if (!url2.IsEmpty())
-  {
-    // url is a site/path if it has a trailing slash
-    isPath2 = (url2.Last() == PRUnichar('/'));
-    if (isPath2)
-      item2visits += AUTOCOMPLETE_NONPAGE_VISIT_COUNT_BOOST;
-  }
-
-  if (HasCell(closure->history->mEnv, row1, closure->history->kToken_TypedColumn))
-    item1visits += AUTOCOMPLETE_NONPAGE_VISIT_COUNT_BOOST;
-  if (HasCell(closure->history->mEnv, row2, closure->history->kToken_TypedColumn))
-    item2visits += AUTOCOMPLETE_NONPAGE_VISIT_COUNT_BOOST;
-  
-  // primary sort by visit count
-  if (item1visits != item2visits)
-  {
-    // return visit count comparison
-    return item2visits - item1visits;
-  }
-  else
-  {
-    // Favour websites and webpaths more than webpages
-    if (isPath1 && !isPath2) return -1; // url1 is a website/path, url2 isn't
-    if (!isPath1 && isPath2) return  1; // url1 isn't a website/path, url2 is
-
-    // We have two websites/paths.. ignore "http[s]://[www.]" & "ftp://[ftp.]"
-    // prefixes.  Find a starting position in the string, just past any of the 
-    // above prefixes.  Only check for the prefix once, in the far left of the 
-    // string - it is assumed there is no whitespace.
-    PRInt32 postPrefix1 = 0, postPrefix2 = 0;
-
-    size_t i;
-    // iterate through our prefixes looking for a match
-    for (i=0; i<closure->prefixCount; i++)
-    {
-      // Check if string is prefixed.  Note: the parameters of the Find() 
-      // method specify the url is searched at the 0th character and if there
-      // is no match the rest of the url is not searched.
-      if (url1.Find((*closure->prefixes[i]), 0, 1) == 0)
-      {
-        // found a match - record post prefix position
-        postPrefix1 = closure->prefixes[i]->Length();
-        // bail out of the for loop
-        break;
-      }
-    }
-
-    // iterate through our prefixes looking for a match
-    for (i=0; i<closure->prefixCount; i++)
-    {
-      // Check if string is prefixed.  Note: the parameters of the Find() 
-      // method specify the url is searched at the 0th character and if there
-      // is no match the rest of the url is not searched.
-      if (url2.Find((*closure->prefixes[i]), 0, 1) == 0)
-      {
-        // found a match - record post prefix position
-        postPrefix2 = closure->prefixes[i]->Length();
-        // bail out of the for loop
-        break;
-      }
-    }
-
-    // compare non-prefixed urls
-    PRInt32 ret = Compare(
-      Substring(url1, postPrefix1, url1.Length()),
-      Substring(url2, postPrefix2, url2.Length()));
-    if (ret != 0) return ret;
-
-    // sort http://xyz.com before http://www.xyz.com
-    return postPrefix1 - postPrefix2;
-  }
-  return 0;
-}
-
-NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsGlobalHistory, Init)
-
-static const nsModuleComponentInfo components[] =
-{
-  { "Global History",
-    NS_GLOBALHISTORY_CID,
-    NS_GLOBALHISTORY2_CONTRACTID,
-    nsGlobalHistoryConstructor },
-    
-  { "Global History",
-    NS_GLOBALHISTORY_CID,
-    NS_GLOBALHISTORY_DATASOURCE_CONTRACTID,
-    nsGlobalHistoryConstructor },
-    
-  { "Global History",
-    NS_GLOBALHISTORY_CID,
-    NS_GLOBALHISTORY_AUTOCOMPLETE_CONTRACTID,
-    nsGlobalHistoryConstructor }
-};
-
-NS_IMPL_NSGETMODULE(nsToolkitHistory, components)
diff -r b7bcdd009540 toolkit/components/history/src/nsGlobalHistory.h
--- a/toolkit/components/history/src/nsGlobalHistory.h	Mon Sep 08 00:36:19 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,455 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 1998
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Chris Waterson <waterson@netscape.com>
- *   Blake Ross <blaker@netscape.com>
- *   Joe Hewitt <hewitt@netscape.com>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#ifndef nsglobalhistory__h____
-#define nsglobalhistory__h____
-
-#include "nsIBrowserHistory.h"
-#include "nsIGlobalHistory3.h"
-#include "mdb.h"
-#include "nsIObserver.h"
-#include "nsIPrefBranch.h"
-#include "nsIRDFDataSource.h"
-#include "nsIRDFRemoteDataSource.h"
-#include "nsIRDFService.h"
-#include "nsISupportsArray.h"
-#include "nsIStringBundle.h"
-#include "nsWeakReference.h"
-#include "nsVoidArray.h"
-#include "nsHashtable.h"
-#include "nsCOMPtr.h"
-#include "nsString.h"
-#include "nsITimer.h"
-#include "nsIAutoCompleteSearch.h"
-#include "nsIAutoCompleteResult.h"
-#include "nsIAutoCompleteResultTypes.h"
-#include "nsHashSets.h"
-#include "nsCOMArray.h"
-#include "nsCycleCollectionParticipant.h"
-
-//----------------------------------------------------------------------
-//
-//  nsMdbTableEnumerator
-//
-//    An nsISimpleEnumerator implementation that returns the value of
-//    a column as an nsISupports. Allows for some simple selection.
-//
-
-class nsMdbTableEnumerator : public nsISimpleEnumerator
-{
-protected:
-  nsMdbTableEnumerator();
-  virtual ~nsMdbTableEnumerator();
-
-  nsIMdbEnv*   mEnv;
-
-private:
-  // subclasses should not tweak these
-  nsIMdbTable* mTable;
-  nsIMdbTableRowCursor* mCursor;
-  nsIMdbRow*            mCurrent;
-
-public:
-  // nsISupports methods
-  NS_DECL_ISUPPORTS
-
-  // nsISimpleEnumeratorMethods
-  NS_IMETHOD HasMoreElements(PRBool* _result);
-  NS_IMETHOD GetNext(nsISupports** _result);
-
-  // Implementation methods
-  virtual nsresult Init(nsIMdbEnv* aEnv, nsIMdbTable* aTable);
-
-protected:
-  virtual PRBool   IsResult(nsIMdbRow* aRow) = 0;
-  virtual nsresult ConvertToISupports(nsIMdbRow* aRow, nsISupports** aResult) = 0;
-};
-
-typedef PRBool (*rowMatchCallback)(nsIMdbRow *aRow, void *closure);
-
-struct matchHost_t;
-struct searchQuery;
-class searchTerm;
-
-// Number of prefixes used in the autocomplete sort comparison function
-#define AUTOCOMPLETE_PREFIX_LIST_COUNT 6
-// Size of visit count boost to give to urls which are sites or paths
-#define AUTOCOMPLETE_NONPAGE_VISIT_COUNT_BOOST 5
-
-//----------------------------------------------------------------------
-//
-// nsGlobalHistory
-//
-//   This class is the browser's implementation of the
-//   nsIGlobalHistory interface.
-//
-
-
-// Used to describe what prefixes shouldn't be cut from
-// history urls when doing an autocomplete url comparison.
-struct AutocompleteExclude {
-  PRInt32 schemePrefix;
-  PRInt32 hostnamePrefix;
-};
-
-class nsGlobalHistory : nsSupportsWeakReference,
-                        public nsIBrowserHistory,
-                        public nsIObserver,
-                        public nsIRDFDataSource,
-                        public nsIRDFRemoteDataSource,
-                        public nsIAutoCompleteSearch,
-                        public nsIGlobalHistory3
-{
-public:
-  // nsISupports methods 
-  NS_DECL_CYCLE_COLLECTING_ISUPPORTS
-  NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsGlobalHistory,
-                                           nsIBrowserHistory)
-
-  NS_DECL_NSIGLOBALHISTORY2
-  NS_DECL_NSIGLOBALHISTORY3
-  NS_DECL_NSIBROWSERHISTORY
-  NS_DECL_NSIOBSERVER
-  NS_DECL_NSIRDFDATASOURCE
-  NS_DECL_NSIRDFREMOTEDATASOURCE
-  NS_DECL_NSIAUTOCOMPLETESEARCH
-
-  NS_METHOD Init();
-
-  nsGlobalHistory(void);
-  virtual ~nsGlobalHistory();
-
-  // these must be public so that the callbacks can call them
-  PRBool MatchExpiration(nsIMdbRow *row, PRTime* expirationDate);
-  PRBool MatchHost(nsIMdbRow *row, matchHost_t *hostInfo);
-  PRBool RowMatches(nsIMdbRow* aRow, searchQuery *aQuery, PRBool caseSensitive);
-
-protected:
-
-  //
-  // database junk
-  //
-  enum eCommitType 
-  {
-    kLargeCommit = 0,
-    kSessionCommit = 1,
-    kCompressCommit = 2
-  };
-  
-  PRInt64   mFileSizeOnDisk;
-  nsresult OpenDB();
-  nsresult OpenExistingFile(nsIMdbFactory *factory, const char *filePath);
-  nsresult OpenNewFile(nsIMdbFactory *factory, const char *filePath);
-  nsresult CreateTokens();
-  nsresult CloseDB();
-  nsresult CheckHostnameEntries();
-  nsresult Commit(eCommitType commitType);
-
-  //
-  // expiration/removal stuff
-  //
-  PRInt32   mExpireDays;
-  nsresult ExpireEntries(PRBool notify);
-  nsresult RemoveMatchingRows(rowMatchCallback aMatchFunc,
-                              void *aClosure, PRBool notify);
-
-  //
-  // search stuff - find URL stuff, etc
-  //
-  nsresult GetRootDayQueries(nsISimpleEnumerator **aResult, PRBool aBySite);
-  nsresult GetFindUriName(const char *aURL, nsIRDFNode **aResult);
-  nsresult CreateFindEnumerator(nsIRDFResource *aSource,
-                                nsISimpleEnumerator **aResult);
-  
-  static nsresult FindUrlToTokenList(const char *aURL, nsVoidArray& aResult);
-  static void FreeTokenList(nsVoidArray& tokens);
-  static void FreeSearchQuery(searchQuery& aQuery);
-  static PRBool IsFindResource(nsIRDFResource *aResource);
-  void GetFindUriPrefix(const searchQuery& aQuery,
-                        const PRBool aDoGroupBy,
-                        nsACString& aResult);
-  
-  nsresult TokenListToSearchQuery(const nsVoidArray& tokens,
-                                  searchQuery& aResult);
-  nsresult FindUrlToSearchQuery(const char *aURL, searchQuery& aResult);
-  nsresult NotifyFindAssertions(nsIRDFResource *aSource, nsIMdbRow *aRow);
-  nsresult NotifyFindUnassertions(nsIRDFResource *aSource, nsIMdbRow *aRow);
-    
-  // 
-  // autocomplete stuff
-  //
-  PRBool mAutocompleteOnlyTyped;
-  nsStringArray mIgnoreSchemes;
-  nsStringArray mIgnoreHostnames;
-  
-  nsresult AutoCompleteTypedSearch(nsIAutoCompleteMdbResult2 **aResult);
-  nsresult AutoCompleteSearch(const nsAString& aSearchString,
-                              AutocompleteExclude* aExclude,
-                              nsIAutoCompleteMdbResult2* aPrevResult,
-                              nsIAutoCompleteMdbResult2** aResult);
-  void AutoCompleteCutPrefix(nsAString& aURL, AutocompleteExclude* aExclude);
-  void AutoCompleteGetExcludeInfo(const nsAString& aURL, AutocompleteExclude* aExclude);
-  nsString AutoCompletePrefilter(const nsAString& aSearchString);
-  PRBool AutoCompleteCompare(nsAString& aHistoryURL, 
-                             const nsAString& aUserURL,
-                             AutocompleteExclude* aExclude);
-  PR_STATIC_CALLBACK(int)
-  AutoCompleteSortComparison(nsIMdbRow *row1, nsIMdbRow *row2, void *closureVoid);
-
-  // AutoCompleteSortClosure - used to pass info into 
-  // AutoCompleteSortComparison from the NS_QuickSort() function
-  struct AutoCompleteSortClosure
-  {
-    nsGlobalHistory* history;
-    size_t prefixCount;
-    const nsAFlatString* prefixes[AUTOCOMPLETE_PREFIX_LIST_COUNT];
-  };
-
-  // caching of PR_Now() so we don't call it every time we do
-  // a history query
-  PRTime    mLastNow;           // cache the last PR_Now()
-  PRInt32   mBatchesInProgress;
-  PRBool    mNowValid;          // is mLastNow valid?
-  nsCOMPtr<nsITimer> mExpireNowTimer;
-  
-  PRTime GetNow();
-  void ExpireNow();
-  
-  static void expireNowTimer(nsITimer *aTimer, void *aClosure)
-  {((nsGlobalHistory *)aClosure)->ExpireNow(); }
-  
-  //
-  // sync stuff to write the db to disk every so often
-  //
-  PRBool    mDirty;             // if we've changed history
-  nsCOMPtr<nsITimer> mSyncTimer;
-  
-  void Sync();
-  nsresult SetDirty();
-  
-  static void fireSyncTimer(nsITimer *aTimer, void *aClosure)
-  {((nsGlobalHistory *)aClosure)->Sync(); }
-
-  //
-  // RDF stuff
-  //
-  nsCOMArray<nsIRDFObserver> mObservers;
-  
-  PRBool IsURLInHistory(nsIRDFResource* aResource);
-  
-  nsresult NotifyAssert(nsIRDFResource* aSource, nsIRDFResource* aProperty, nsIRDFNode* aValue);
-  nsresult NotifyUnassert(nsIRDFResource* aSource, nsIRDFResource* aProperty, nsIRDFNode* aValue);
-  nsresult NotifyChange(nsIRDFResource* aSource, nsIRDFResource* aProperty, nsIRDFNode* aOldValue, nsIRDFNode* aNewValue);
-
-  //
-  // row-oriented stuff
-  //
-  
-  // N.B., these are MDB interfaces, _not_ XPCOM interfaces.
-  nsIMdbEnv* mEnv;         // OWNER
-  nsIMdbStore* mStore;     // OWNER
-  nsIMdbTable* mTable;     // OWNER
-  
-  nsCOMPtr<nsIMdbRow> mMetaRow;
-  
-  mdb_scope  kToken_HistoryRowScope;
-  mdb_kind   kToken_HistoryKind;
-
-  mdb_column kToken_URLColumn;
-  mdb_column kToken_ReferrerColumn;
-  mdb_column kToken_LastVisitDateColumn;
-  mdb_column kToken_FirstVisitDateColumn;
-  mdb_column kToken_VisitCountColumn;
-  mdb_column kToken_NameColumn;
-  mdb_column kToken_HostnameColumn;
-  mdb_column kToken_HiddenColumn;
-  mdb_column kToken_TypedColumn;
-  mdb_column kToken_GeckoFlagsColumn;
-
-  mdb_column kToken_ByteOrder;
-  // meta-data tokens
-  mdb_column kToken_LastPageVisited;
-
-  // A set of the page URI specs that have been typed but not yet loaded
-  nsCStringHashSet mTypedHiddenURIs;
-  
-  //
-  // AddPage-oriented stuff
-  //
-  nsresult AddPageToDatabase(nsIURI* aURI, PRBool aRedirect, PRBool aTopLevel,
-                             PRTime aLastVisitDate, nsIURI * aReferrer);
-  nsresult AddExistingPageToDatabase(nsIMdbRow *row,
-                                     PRTime aDate,
-                                     nsIURI *aReferrer,
-                                     PRTime *aOldDate,
-                                     PRInt32 *aOldCount);
-  nsresult AddNewPageToDatabase(nsIURI* aURI,
-                                PRTime aDate,
-                                PRBool aRedirect,
-                                PRBool aTopLevel,
-                                nsIURI *aReferrer,
-                                nsIMdbRow **aResult);
-
-  nsresult RemovePageInternal(const char *aSpec);
-
-  //
-  // generic routines for setting/retrieving various datatypes
-  //
-  nsresult SetRowValue(nsIMdbRow *aRow, mdb_column aCol, const PRTime& aValue);
-  nsresult SetRowValue(nsIMdbRow *aRow, mdb_column aCol, const PRInt32 aValue);
-  nsresult SetRowValue(nsIMdbRow *aRow, mdb_column aCol, const char *aValue);
-  nsresult SetRowValue(nsIMdbRow *aRow, mdb_column aCol, const PRUnichar *aValue);
-
-  nsresult GetRowValue(nsIMdbRow *aRow, mdb_column aCol, nsAString& aResult);
-  // byte order
-  //
-  nsresult SaveByteOrder(const char *aByteOrder);
-  nsresult GetByteOrder(char **_retval);
-  nsresult InitByteOrder(PRBool aForce);
-  void SwapBytes(const PRUnichar *source, PRUnichar *dest, PRInt32 aLen);
-  PRBool mReverseByteOrder;
-
-  //
-  nsresult GetRowValue(nsIMdbRow *aRow, mdb_column aCol, nsACString& aResult);
-  nsresult GetRowValue(nsIMdbRow *aRow, mdb_column aCol, PRTime* aResult);
-  nsresult GetRowValue(nsIMdbRow *aRow, mdb_column aCol, PRInt32* aResult);
-
-  // Look up a row in mStore and returns success if it is found or failure
-  // if it is not.  |aResult| may be null if only testing for row existance.
-  nsresult FindRow(mdb_column aCol, const char *aURL, nsIMdbRow **aResult);
-
-  //
-  // misc unrelated stuff
-  //
-  nsCOMPtr<nsIStringBundle> mBundle;
-
-  // pseudo-constants. although the global history really is a
-  // singleton, we'll use this metaphor to be consistent.
-  static PRInt32 gRefCnt;
-  static nsIRDFService* gRDFService;
-  static nsIRDFResource* kNC_Page; // XXX do we need?
-  static nsIRDFResource* kNC_Date;
-  static nsIRDFResource* kNC_FirstVisitDate;
-  static nsIRDFResource* kNC_VisitCount;
-  static nsIRDFResource* kNC_AgeInDays;
-  static nsIRDFResource* kNC_Name;
-  static nsIRDFResource* kNC_NameSort;
-  static nsIRDFResource* kNC_Hostname;
-  static nsIRDFResource* kNC_Referrer;
-  static nsIRDFResource* kNC_child;
-  static nsIRDFResource* kNC_URL;  // XXX do we need?
-  static nsIRDFResource* kNC_HistoryRoot;
-  static nsIRDFResource* kNC_HistoryByDate;
-  static nsIRDFResource* kNC_HistoryByDateAndSite;
-  static nsIRDFResource* kNC_DayFolderIndex;
-
-  static nsIMdbFactory* gMdbFactory;
-  static nsIPrefBranch* gPrefBranch;
-  //
-  // custom enumerators
-  //
-
-  // URLEnumerator - for searching for a specific set of rows which
-  // match a particular column
-  class URLEnumerator : public nsMdbTableEnumerator
-  {
-  protected:
-    mdb_column mURLColumn;
-    mdb_column mHiddenColumn;
-    mdb_column mSelectColumn;
-    void*      mSelectValue;
-    PRInt32    mSelectValueLen;
-
-    virtual ~URLEnumerator();
-
-  public:
-    URLEnumerator(mdb_column aURLColumn,
-                  mdb_column aHiddenColumn,
-                  mdb_column aSelectColumn = mdb_column(0),
-                  void* aSelectValue = nsnull,
-                  PRInt32 aSelectValueLen = 0) :
-      mURLColumn(aURLColumn),
-      mHiddenColumn(aHiddenColumn),
-      mSelectColumn(aSelectColumn),
-      mSelectValue(aSelectValue),
-      mSelectValueLen(aSelectValueLen)
-    {}
-
-  protected:
-    virtual PRBool   IsResult(nsIMdbRow* aRow);
-    virtual nsresult ConvertToISupports(nsIMdbRow* aRow, nsISupports** aResult);
-  };
-
-  // SearchEnumerator - for matching a set of rows based on a search query
-  class SearchEnumerator : public nsMdbTableEnumerator
-  {
-  public:
-    SearchEnumerator(searchQuery *aQuery,
-                     mdb_column aHiddenColumn,
-                     nsGlobalHistory *aHistory) :
-      mQuery(aQuery),
-      mHiddenColumn(aHiddenColumn),
-      mHistory(aHistory)
-    {}
-
-    virtual ~SearchEnumerator();
-
-  protected:
-    searchQuery *mQuery;
-    mdb_column mHiddenColumn;
-    nsGlobalHistory *mHistory;
-    nsHashtable mUniqueRows;
-    
-    nsCString mFindUriPrefix;
-
-    virtual PRBool IsResult(nsIMdbRow* aRow);
-    virtual nsresult ConvertToISupports(nsIMdbRow* aRow,
-                                        nsISupports** aResult);
-    
-    PRBool RowMatches(nsIMdbRow* aRow, searchQuery *aQuery);
-  };
-
-
-  friend class URLEnumerator;
-  friend class SearchEnumerator;
-};
-
-
-#endif // nsglobalhistory__h____
diff -r b7bcdd009540 toolkit/components/history/src/nsHistoryLoadListener.h
--- a/toolkit/components/history/src/nsHistoryLoadListener.h	Mon Sep 08 00:36:19 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,63 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 1998
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-
-#include "nsIWebProgressListener.h"
-#include "nsIBrowserHistory.h"
-#include "nsCOMPtr.h"
-#include "nsIComponentManager.h"
-#include "nsWeakReference.h"
-#include "nsIGenericFactory.h"
-
-class nsHistoryLoadListener : public nsIWebProgressListener,
-                              public nsSupportsWeakReference
-{
- public:
-    nsHistoryLoadListener(nsIBrowserHistory *);
-    virtual ~nsHistoryLoadListener();
-
-    nsresult Init();
-
-    NS_DECL_ISUPPORTS
-    NS_DECL_NSIWEBPROGRESSLISTENER
-        
- protected:
-    nsCOMPtr<nsIBrowserHistory> mHistory;
-
-};
-
diff -r b7bcdd009540 toolkit/components/microformats/Makefile.in
--- a/toolkit/components/microformats/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/toolkit/components/microformats/Makefile.in	Thu Sep 11 15:19:27 2008 +0300
@@ -38,14 +38,14 @@ topsrcdir = @top_srcdir@
 topsrcdir = @top_srcdir@
 srcdir    = @srcdir@
 VPATH     = @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 DIRS = src
 
-ifdef MOZ_MOCHITEST
+ifdef ENABLE_TESTS
 DIRS += tests
 endif
 
 include $(topsrcdir)/config/rules.mk
 
diff -r b7bcdd009540 toolkit/components/places/src/nsLivemarkService.js
--- a/toolkit/components/places/src/nsLivemarkService.js	Mon Sep 08 00:36:19 2008 -0700
+++ b/toolkit/components/places/src/nsLivemarkService.js	Thu Sep 11 15:19:27 2008 +0300
@@ -75,17 +75,16 @@ const IO_CONTRACTID = "@mozilla.org/netw
 const IO_CONTRACTID = "@mozilla.org/network/io-service;1";
 const BMS_CONTRACTID = "@mozilla.org/browser/nav-bookmarks-service;1";
 const FAV_CONTRACTID = "@mozilla.org/browser/favicon-service;1";
 const LG_CONTRACTID = "@mozilla.org/network/load-group;1";
 const FP_CONTRACTID = "@mozilla.org/feed-processor;1";
 const SEC_CONTRACTID = "@mozilla.org/scriptsecuritymanager;1";
 const IS_CONTRACTID = "@mozilla.org/widget/idleservice;1";
 const SEC_FLAGS = Ci.nsIScriptSecurityManager.DISALLOW_INHERIT_PRINCIPAL;
-const NS_BINDING_ABORTED = 0x804b0002;
 
 // Expire livemarks after 1 hour by default
 var gExpiration = 3600000;
 
 // Expire livemarks after 10 minutes on error
 const ERROR_EXPIRATION = 600000;
 
 // Don't check when the user is idle for longer than half an hour
@@ -212,17 +211,17 @@ LivemarkService.prototype = {
   },
 
   _shutdown: function LS__shutdown() {
     // remove bookmarks observer
     this._bms.removeObserver(this);
 
     for (var livemark in this._livemarks) {
       if (livemark.loadGroup)
-        livemark.loadGroup.cancel(NS_BINDING_ABORTED);
+        livemark.loadGroup.cancel(Components.results.NS_BINDING_ABORTED);
     }
 
     // kill timer
     if (this._updateTimer) {
       this._updateTimer.cancel();
       this._updateTimer = null;
     }
   },
@@ -464,17 +463,17 @@ LivemarkService.prototype = {
       return;
     }
     var livemark = this._livemarks[livemarkIndex];
 
     // remove the livemark from the update array
     this._livemarks.splice(livemarkIndex, 1);
 
     if (livemark.loadGroup)
-      livemark.loadGroup.cancel(NS_BINDING_ABORTED);
+      livemark.loadGroup.cancel(Components.results.NS_BINDING_ABORTED);
   },
 
   createInstance: function LS_createInstance(aOuter, aIID) {
     if (aOuter != null)
       throw Cr.NS_ERROR_NO_AGGREGATION;
     return this.QueryInterface(aIID);
   },
 
diff -r b7bcdd009540 toolkit/components/places/tests/Makefile.in
--- a/toolkit/components/places/tests/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/toolkit/components/places/tests/Makefile.in	Thu Sep 11 15:19:27 2008 +0300
@@ -57,21 +57,19 @@ XPCSHELL_TESTS = \
 # Simple MochiTests
 MOCHI_TESTS = mochitest/test_bug_405924.html \
 							mochitest/test_bug_411966.html \
 							$(NULL)
 
 MOCHI_CONTENT = mochitest/prompt_common.js \
 								$(NULL)
 
-ifdef MOZ_MOCHITEST
 DIRS = \
 	chrome \
 	mochitest/bug_411966 \
 # These tests are disabled for the time being, see bug 416066
 #	browser \
 	$(NULL)
-endif
 
 include $(topsrcdir)/config/rules.mk
 
 libs:: $(MOCHI_TESTS) $(MOCHI_CONTENT)
 	$(INSTALL) $(foreach f,$^,"$f") $(DEPTH)/_tests/testing/mochitest/tests/$(relativesrcdir)
diff -r b7bcdd009540 toolkit/components/viewsource/content/viewSourceUtils.js
--- a/toolkit/components/viewsource/content/viewSourceUtils.js	Mon Sep 08 00:36:19 2008 -0700
+++ b/toolkit/components/viewsource/content/viewSourceUtils.js	Thu Sep 11 15:19:27 2008 +0300
@@ -15,16 +15,17 @@
 # The Original Code is View Source Utilities.
 #
 # The Initial Developer of the Original Code is
 # Jason Barnabe.
 # Portions created by the Initial Developer are Copyright (C) 2005
 # the Initial Developer. All Rights Reserved.
 #
 # Contributor(s):
+#   Simon Bnzli <zeniko@gmail.com>
 #
 # Alternatively, the contents of this file may be used under the terms of
 # either the GNU General Public License Version 2 or later (the "GPL"), or
 # the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 # in which case the provisions of the GPL or the LGPL are applicable instead
 # of those above. If you wish to allow use of your version of this file only
 # under the terms of either the GPL or the LGPL, and not to allow others to
 # use your version of this file under the terms of the MPL, indicate your
@@ -34,27 +35,39 @@
 # the terms of any one of the MPL, the GPL or the LGPL.
 #
 # ***** END LICENSE BLOCK *****
 
 /*
  * To keep the global namespace safe, don't define global variables and 
  * functions in this file.
  *
- * This file requires contentAreaUtils.js
-*/
+ * This file silently depends on contentAreaUtils.js for
+ * getDefaultFileName, getNormalizedLeafName and getDefaultExtension
+ */
 
 var gViewSourceUtils = {
 
   mnsIWebBrowserPersist: Components.interfaces.nsIWebBrowserPersist,
   mnsIWebProgress: Components.interfaces.nsIWebProgress,
   mnsIWebPageDescriptor: Components.interfaces.nsIWebPageDescriptor,
 
+  // Opens view source
+  viewSource: function(aURL, aPageDescriptor, aDocument, aLineNumber)
+  {
+    var prefs = Components.classes["@mozilla.org/preferences-service;1"]
+                          .getService(Components.interfaces.nsIPrefBranch);
+    if (prefs.getBoolPref("view_source.editor.external"))
+      this.openInExternalEditor(aURL, aPageDescriptor, aDocument, aLineNumber);
+    else
+      this.openInInternalViewer(aURL, aPageDescriptor, aDocument, aLineNumber);
+  },
+
   // Opens the interval view source viewer
-  openInInternalViewer: function(aURL, aPageDescriptor, aDocument)
+  openInInternalViewer: function(aURL, aPageDescriptor, aDocument, aLineNumber)
   {
     // try to open a view-source window while inheriting the charset (if any)
     var charset = null;
     var isForcedCharset = false;
     if (aDocument) {
       charset = "charset=" + aDocument.characterSet;
       try { 
         isForcedCharset =
@@ -63,24 +76,25 @@ var gViewSourceUtils = {
                    .getInterface(Components.interfaces.nsIDOMWindowUtils)
                    .docCharsetIsForced;
       } catch (ex) {
       }
     }
     openDialog("chrome://global/content/viewSource.xul",
                "_blank",
                "all,dialog=no",
-               aURL, charset, aPageDescriptor, 0, isForcedCharset);
+               aURL, charset, aPageDescriptor, aLineNumber, isForcedCharset);
   },
 
   // aCallBack is a function accepting two arguments - result (true=success) and a data object
   // It defaults to openInInternalViewer if undefined.
-  openInExternalEditor: function(aURL, aPageDescriptor, aDocument, aCallBack)
+  openInExternalEditor: function(aURL, aPageDescriptor, aDocument, aLineNumber, aCallBack)
   {
-    var data = {url: aURL, pageDescriptor: aPageDescriptor, doc: aDocument};
+    var data = {url: aURL, pageDescriptor: aPageDescriptor, doc: aDocument,
+                lineNumber: aLineNumber};
 
     try {
       var editor = this.getExternalViewSourceEditor();    
       if (!editor) {
         this.handleCallBack(aCallBack, false, data);
         return;
       }
 
@@ -134,17 +148,17 @@ var gViewSourceUtils = {
       return;
     }
   },
 
   // Default callback - opens the internal viewer if the external editor failed
   internalViewerFallback: function(result, data)
   {
     if (!result) {
-      this.openInInternalViewer(data.url, data.pageDescriptor, data.doc);
+      this.openInInternalViewer(data.url, data.pageDescriptor, data.doc, data.lineNumber);
     }
   },
 
   // Calls the callback, keeping in mind undefined or null values.
   handleCallBack: function(aCallBack, result, data)
   {
     // ifcallback is undefined, default to the internal viewer
     if (aCallBack === undefined) {
@@ -224,18 +238,33 @@ var gViewSourceUtils = {
 
             // write the source to the file
             coStream.writeString(webNavigation.document.body.textContent);
           
             // clean up
             coStream.close();
             foStream.close();
           }
-          // fire up the editor
-          this.editor.run(false, [this.file.path], 1);
+
+          // Determine the command line arguments to pass to the editor.
+          // We currently support a %LINE% placeholder which is set to the passed
+          // line number (or to 0 if there's none)
+          var editorArgs = [];
+          var prefs = Components.classes["@mozilla.org/preferences-service;1"]
+                                .getService(Components.interfaces.nsIPrefBranch);
+          var args = prefs.getCharPref("view_source.editor.args");
+          if (args) {
+            args = args.replace("%LINE%", this.data.lineNumber || "0");
+            // add the arguments to the array (keeping quoted strings intact)
+            const argumentRE = /"([^"]+)"|(\S+)/g;
+            while (argumentRE.test(args))
+              editorArgs.push(RegExp.$1 || RegExp.$2);
+          }
+          editorArgs.push(this.file.path);
+          this.editor.run(false, editorArgs, editorArgs.length);
 
           gViewSourceUtils.handleCallBack(this.callBack, true, this.data);
         } catch (ex) {
           // we failed loading it with the external editor.
           Components.utils.reportError(ex);
           gViewSourceUtils.handleCallBack(this.callBack, false, this.data);
         } finally {
           this.destroy();
@@ -254,18 +283,26 @@ var gViewSourceUtils = {
     editor: null,
     callBack: null,
     data: null,
     file: null
   },
 
   // returns an nsIFile for the passed document in the system temp directory
   getTemporaryFile: function(aURI, aDocument, aContentType) {
+    // include contentAreaUtils.js in our own context when we first need it
+    if (!this._caUtils) {
+      var scriptLoader = Components.classes["@mozilla.org/moz/jssubscript-loader;1"]
+                                   .getService(Components.interfaces.mozIJSSubScriptLoader);
+      this._caUtils = {};
+      scriptLoader.loadSubScript("chrome://global/content/contentAreaUtils.js", this._caUtils);
+    }
+
     var fileLocator = Components.classes["@mozilla.org/file/directory_service;1"]
                                 .getService(Components.interfaces.nsIProperties);
     var tempFile = fileLocator.get("TmpD", Components.interfaces.nsIFile);
-    var fileName = getDefaultFileName(null, aURI, aDocument, aContentType);
-    var extension = getDefaultExtension(fileName, aURI, aContentType);
-    var leafName = getNormalizedLeafName(fileName, extension);
+    var fileName = this._caUtils.getDefaultFileName(null, aURI, aDocument, aContentType);
+    var extension = this._caUtils.getDefaultExtension(fileName, aURI, aContentType);
+    var leafName = this._caUtils.getNormalizedLeafName(fileName, extension);
     tempFile.append(leafName);
     return tempFile;
   }
 }
diff -r b7bcdd009540 toolkit/content/about.xhtml
--- a/toolkit/content/about.xhtml	Mon Sep 08 00:36:19 2008 -0700
+++ b/toolkit/content/about.xhtml	Thu Sep 11 15:19:27 2008 +0300
@@ -53,17 +53,16 @@
 
 <html xmlns="http://www.w3.org/1999/xhtml">
 <head>
   <title>About:</title>
   <link rel="stylesheet" href="chrome://global/skin/about.css" type="text/css"/>
 </head>
 
 <body dir="&locale.dir;">
-<div id="aboutPageContainer">
   <div id="aboutLogoContainer">
     <a id="vendorURL" href="http://www.mozilla.org/">
       <img src="about:logo" alt="&brandShortName;"/>
 #expand <p id="version">&about.version; __MOZ_APP_VERSION__</p>
     </a>
   </div>
 
   <ul id="aboutPageList">
@@ -93,11 +92,10 @@
         var list = document.getElementById("aboutPageList");
         var listItem = list.appendChild(document.createElement("li"));
         listItem.appendChild(document.createTextNode("&about.buildIdentifier;"));
         listItem.appendChild(document.createTextNode(ua));
       }
     </script>
   </ul>
 
-</div>
 </body>
 </html>
diff -r b7bcdd009540 toolkit/content/buildconfig.html.in
--- a/toolkit/content/buildconfig.html.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/toolkit/content/buildconfig.html.in	Thu Sep 11 15:19:27 2008 +0300
@@ -1,14 +1,15 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
 <html>
 <head>
   <title>about:buildconfig</title>
+  <link rel="stylesheet" href="chrome://global/skin/about.css" type="text/css">
 </head>
-<body>
+<body class="aboutPageWideContainer">
 <h1>about:buildconfig</h1>
 <p> </p>
 <h2>Build platform</h2>
 <table>
   <tbody>
     <tr>
       <th>target</th>
     </tr>
diff -r b7bcdd009540 toolkit/content/license.html
--- a/toolkit/content/license.html	Mon Sep 08 00:36:19 2008 -0700
+++ b/toolkit/content/license.html	Thu Sep 11 15:19:27 2008 +0300
@@ -16,16 +16,17 @@
    - The Original Code is mozilla.org code.
    -
    - The Initial Developer of the Original Code is
    - Gervase Markham.
    - Portions created by the Initial Developer are Copyright (C) 2006
    - the Initial Developer. All Rights Reserved.
    -
    - Contributor(s):
+   -   Ehsan Akhgari <ehsan.akhgari@gmail.com>
    -
    - Alternatively, the contents of this file may be used under the terms of
    - either the GNU General Public License Version 2 or later (the "GPL"), or
    - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    - in which case the provisions of the GPL or the LGPL are applicable instead
    - of those above. If you wish to allow use of your version of this file only
    - under the terms of either the GPL or the LGPL, and not to allow others to
    - use your version of this file under the terms of the MPL, indicate your
@@ -57,16 +58,17 @@
       dd p {
         margin: 0;
       }
       
       .gnu-number {
         font-weight: bold;
       }
     </style>
+    <link rel="stylesheet" href="chrome://global/skin/about.css" type="text/css">
 
     <script type="text/javascript">
     function correctSpelling()
     {
       // Note that this code only runs if the page is requested using the
       // URL containing the correct spelling - e.g. "about:licence".
       if (document.location.href.match("icence"))
       {       
@@ -111,17 +113,17 @@
         }
       }
     }
     
     window.onload = correctSpelling;
     </script>    
   </head>
 
-  <body id="lic-info">
+  <body id="lic-info" class="aboutPageWideContainer">
     <h1 class="correctme"><a name="top"></a>about:license</h1>
 
     <div class="correctme">
 
 #ifdef APP_EULA_BLOCK
 #includesubst @APP_EULA_BLOCK@
 #endif
     
diff -r b7bcdd009540 toolkit/content/nsDragAndDrop.js
--- a/toolkit/content/nsDragAndDrop.js	Mon Sep 08 00:36:19 2008 -0700
+++ b/toolkit/content/nsDragAndDrop.js	Thu Sep 11 15:19:27 2008 +0300
@@ -466,24 +466,23 @@ var nsDragAndDrop = {
 
       var flavourSet = aDragDropObserver.getSupportedFlavours();
 
       var dt = aEvent.dataTransfer;
       var dataArray = [];
       var count = dt.mozItemCount;
       for (var i = 0; i < count; ++i) {
         var types = dt.mozTypesAt(i);
-        for (var j = 0; j < types.length; ++j) {
-          var type = types[j];
+        for (var j = 0; j < flavourSet.flavours.length; j++) {
+          var type = flavourSet.flavours[j].contentType;
           // dataTransfer uses text/plain but older code used text/unicode, so
           // switch this for compatibility
-          if (type == "text/plain")
-            type = "text/unicode";
-          if (type in flavourSet.flavourTable) {
-            var data = dt.mozGetDataAt(type, i);
+          var modtype = (type == "text/unicode") ? "text/plain" : type;
+          if (Array.indexOf(types, modtype) >= 0) {
+            var data = dt.mozGetDataAt(modtype, i);
             if (data) {
               var length = (typeof data == "string") ? data.length : kNonStringDataLength;
               dataArray[i] = FlavourToXfer(data, length, flavourSet.flavourTable[type]);
               break;
             }
           }
         }
       }
diff -r b7bcdd009540 toolkit/content/tests/Makefile.in
--- a/toolkit/content/tests/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/toolkit/content/tests/Makefile.in	Thu Sep 11 15:19:27 2008 +0300
@@ -42,13 +42,11 @@ VPATH		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 MODULE		= test_toolkit_general
 
 XPCSHELL_TESTS = unit
 
-ifdef MOZ_MOCHITEST
 DIRS = chrome widgets
-endif
 
 include $(topsrcdir)/config/rules.mk
diff -r b7bcdd009540 toolkit/content/tests/chrome/window_popup_preventdefault_chrome.xul
--- a/toolkit/content/tests/chrome/window_popup_preventdefault_chrome.xul	Mon Sep 08 00:36:19 2008 -0700
+++ b/toolkit/content/tests/chrome/window_popup_preventdefault_chrome.xul	Thu Sep 11 15:19:27 2008 +0300
@@ -1,32 +1,52 @@
 <?xml version="1.0"?>
 <?xml-stylesheet href="chrome://global/skin" type="text/css"?>
 
 <window title="Popup Prevent Default Tests"
-  onload="setTimeout(runTest, 0);"
+  onfocus="if (!gDone) { gDone = true; setTimeout(runTest, 0); }"
   xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
 
   <title>Popup Prevent Default Tests</title>
 
 <!--
   This tests checks that preventDefault can be called on a popupshowing
   event or popuphiding event to prevent the default behaviour.
   -->
 
 <script>
 
+var gDone = false;
 var gBlockShowing = true;
 var gBlockHiding = true;
 var gShownNotAllowed = true;
 var gHiddenNotAllowed = true;
 
+var is = function(l, r, v) { window.opener.wrappedJSObject.SimpleTest.is(l, r, v); }
+
 function runTest()
 {
+  is(window.windowState, window.STATE_NORMAL, "window is normal");
+  window.minimize();
+  is(window.windowState, window.STATE_MINIMIZED, "window is minimized");
+
   document.getElementById("menu").open = true;
+
+  setTimeout(runTestAfterMinimize, 0);
+}
+
+function runTestAfterMinimize()
+{
+  var menu = document.getElementById("menu");
+  is(menu.firstChild.state, "closed", "popup not opened when window minimized");
+
+  window.restore();
+  is(window.windowState, window.STATE_NORMAL, "window is restored");
+
+  menu.open = true;
 }
 
 function popupShowing(event)
 {
   if (gBlockShowing) {
     event.preventDefault();
     gBlockShowing = false;
     setTimeout(function() {
diff -r b7bcdd009540 toolkit/content/widgets/colorpicker.xml
--- a/toolkit/content/widgets/colorpicker.xml	Mon Sep 08 00:36:19 2008 -0700
+++ b/toolkit/content/widgets/colorpicker.xml	Thu Sep 11 15:19:27 2008 +0300
@@ -414,17 +414,17 @@
     <resources>
       <stylesheet src="chrome://global/skin/colorpicker.css"/>
     </resources>
     
     <content>
       <xul:hbox class="colorpicker-button-colorbox" anonid="colorbox" flex="1" xbl:inherits="disabled"/>
 
       <xul:panel class="colorpicker-button-menupopup"
-                 anonid="colorpopup" noautofocus="true"
+                 anonid="colorpopup" noautofocus="true" level="top"
                  onmousedown="event.stopPropagation()"
                  onpopupshowing="this._colorPicker.onPopupShowing()"
                  onpopuphiding="this._colorPicker.onPopupHiding()"
                  onselect="this._colorPicker.pickerChange()">
         <xul:colorpicker xbl:inherits="palettename,disabled" allowevents="true" anonid="colorpicker"/>
       </xul:panel>
     </content>
     
diff -r b7bcdd009540 toolkit/content/widgets/datetimepicker.xml
--- a/toolkit/content/widgets/datetimepicker.xml	Mon Sep 08 00:36:19 2008 -0700
+++ b/toolkit/content/widgets/datetimepicker.xml	Thu Sep 11 15:19:27 2008 +0300
@@ -1226,17 +1226,17 @@
                       size="2" maxlength="2" flex="1" chromedir="&locale.dir;" 
                       xbl:inherits="disabled,readonly"/>
         </xul:hbox>
       </xul:hbox>
       <xul:spinbuttons anonid="buttons" xbl:inherits="disabled" allowevents="true"
                        onup="this.parentNode._increaseOrDecrease(1);"
                        ondown="this.parentNode._increaseOrDecrease(-1);"/>
       <xul:dropmarker class="datepicker-dropmarker" xbl:inherits="disabled"/>
-      <xul:panel onpopupshown="this.firstChild.focus();">
+      <xul:panel onpopupshown="this.firstChild.focus();" level="top">
         <xul:datepicker anonid="grid" type="grid" class="datepicker-popupgrid"
                         xbl:inherits="disabled,readonly,firstdayofweek"/>
       </xul:panel>
     </content>
     <implementation>
       <constructor>
         var grid = document.getAnonymousElementByAttribute(this, "anonid", "grid");
         this.attachedControl = grid;
diff -r b7bcdd009540 toolkit/content/widgets/findbar.xml
--- a/toolkit/content/widgets/findbar.xml	Mon Sep 08 00:36:19 2008 -0700
+++ b/toolkit/content/widgets/findbar.xml	Thu Sep 11 15:19:27 2008 +0300
@@ -566,17 +566,16 @@
           if (textFound) {
             if (aHighlight)
              this._lastHighlightString = aWord;
             else {
               var sel = controller.getSelection(this.nsISelectionController.SELECTION_FIND);
               sel.removeAllRanges();
             }
             controller.setDisplaySelection(this.nsISelectionController.SELECTION_ON);
-            controller.repaintSelection(this.nsISelectionController.SELECTION_FIND);
           }
 
           return textFound;
         ]]></body>
       </method>
 
      <!--
        - Highlights the word in the passed range.
@@ -596,21 +595,18 @@
           var node = aRange.startContainer;
           var controller = aController;
           var isEditable = this._getEditableNode(node);
           if (isEditable)
             controller = isEditable.editor.selectionController;
           var findSelection = controller.getSelection(this.nsISelectionController.SELECTION_FIND);
           if (aHighlight)
             findSelection.addRange(aRange);
-          if (isEditable) {
-            if (!aHighlight)
-              findSelection.removeAllRanges();
-            controller.repaintSelection(this.nsISelectionController.SELECTION_FIND);
-          }
+          else if (isEditable)
+            findSelection.removeAllRanges();
         ]]></body>
       </method>
 
       <!--
         - Updates the case-sensitivity mode of the findbar and its UI.
         - @param [optional] aString
         -        The string for which case sensitivity might be turned on.
         -        This only used when case-sensitivity is in auto mode,
diff -r b7bcdd009540 toolkit/crashreporter/client/crashreporter.rc
--- a/toolkit/crashreporter/client/crashreporter.rc	Mon Sep 08 00:36:19 2008 -0700
+++ b/toolkit/crashreporter/client/crashreporter.rc	Thu Sep 11 15:19:27 2008 +0300
@@ -82,18 +82,18 @@ BEGIN
     EDITTEXT        IDC_COMMENTTEXT,24,59,210,43,ES_MULTILINE | ES_WANTRETURN | WS_VSCROLL
     CONTROL         "include the address of the page i was on",IDC_INCLUDEURLCHECK,
                     "Button",BS_AUTOCHECKBOX | WS_TABSTOP,24,107,210,10
     CONTROL         "tell mozilla to email me with more information",IDC_EMAILMECHECK,
                     "Button",BS_AUTOCHECKBOX | WS_TABSTOP,24,120,210,10
     EDITTEXT        IDC_EMAILTEXT,36,133,198,14,ES_AUTOHSCROLL
     CONTROL         "",IDC_THROBBER,"SysAnimate32",ACS_TRANSPARENT | NOT WS_VISIBLE | WS_TABSTOP,4,152,16,16
     LTEXT           "your crash report will be submitted when you restart",IDC_PROGRESSTEXT,24,152,210,10,SS_NOPREFIX
-    PUSHBUTTON      "quit without sending",IDC_CLOSEBUTTON,84,166,77,14
-    DEFPUSHBUTTON   "restart firefox",IDC_RESTARTBUTTON,166,166,68,14
+    DEFPUSHBUTTON   "restart firefox",IDC_RESTARTBUTTON,84,166,68,14
+    PUSHBUTTON      "quit without sending",IDC_CLOSEBUTTON,157,166,77,14
 END
 
 IDD_VIEWREPORTDIALOG DIALOGEX 0, 0, 208, 126
 STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | DS_CENTER | WS_POPUP | WS_CAPTION
 CAPTION "view report"
 FONT 8, "MS Shell Dlg", 400, 0, 0x1
 BEGIN
     CONTROL         "",IDC_VIEWREPORTTEXT,"RichEdit20A",ES_MULTILINE | ES_READONLY | WS_BORDER | WS_VSCROLL | WS_TABSTOP,7,7,194,92
diff -r b7bcdd009540 toolkit/crashreporter/client/crashreporter_win.cpp
--- a/toolkit/crashreporter/client/crashreporter_win.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/toolkit/crashreporter/client/crashreporter_win.cpp	Thu Sep 11 15:19:27 2008 +0300
@@ -967,68 +967,63 @@ static BOOL CALLBACK CrashReporterDialog
     RECT closeRect;
     HWND hwndClose = GetDlgItem(hwndDlg, IDC_CLOSEBUTTON);
     GetRelativeRect(hwndClose, hwndDlg, &closeRect);
 
     RECT restartRect;
     HWND hwndRestart = GetDlgItem(hwndDlg, IDC_RESTARTBUTTON);
     GetRelativeRect(hwndRestart, hwndDlg, &restartRect);
 
-    // Resize close button to fit text
-    ResizeControl(hwndClose, closeRect, Str(ST_QUIT), true, 0);
+    // set the close button text and shift the buttons around
+    // since the size may need to change
+    int sizeDiff = ResizeControl(hwndClose, closeRect, Str(ST_QUIT),
+                                 true, 0);
+    restartRect.left -= sizeDiff;
+    restartRect.right -= sizeDiff;
     SetDlgItemText(hwndDlg, IDC_CLOSEBUTTON, Str(ST_QUIT).c_str());
 
     if (gRestartArgs.size() > 0) {
-      // set the restart button text and shift the buttons around
-      // since the size may need to change
-      int sizeDiff = ResizeControl(hwndRestart, restartRect, Str(ST_RESTART),
-                                   true, 0);
-      closeRect.left -= sizeDiff;
-      closeRect.right -= sizeDiff;
+      // Resize restart button to fit text
+      ResizeControl(hwndRestart, restartRect, Str(ST_RESTART), true, 0);
       SetDlgItemText(hwndDlg, IDC_RESTARTBUTTON, Str(ST_RESTART).c_str());
     } else {
-      // No restart arguments, move the close button over to the side
-      // and hide the restart button
+      // No restart arguments, so just hide the restart button
       SetDlgItemVisible(hwndDlg, IDC_RESTARTBUTTON, false);
-
-      int size = closeRect.right - closeRect.left;
-      closeRect.right = restartRect.right;
-      closeRect.left = closeRect.right - size;
     }
     // See if we need to widen the window
     // Leave 6 pixels on either side + 6 pixels between the buttons
     int neededSize = closeRect.right - closeRect.left +
       restartRect.right - restartRect.left + 6 * 3;
     GetClientRect(hwndDlg, &r);
     // We may already have resized one of the checkboxes above
     maxdiff = max(maxdiff, neededSize - (r.right - r.left));
 
     if (maxdiff > 0) {
       // widen window
       GetWindowRect(hwndDlg, &r);
       r.right += maxdiff;
       MoveWindow(hwndDlg, r.left, r.top,
                  r.right - r.left, r.bottom - r.top, TRUE);
       // shift both buttons right
-      if (closeRect.left + maxdiff < 6)
+      if (restartRect.left + maxdiff < 6)
         maxdiff += 6;
       closeRect.left += maxdiff;
       closeRect.right += maxdiff;
       restartRect.left += maxdiff;
       restartRect.right += maxdiff;
-      MoveWindow(hwndRestart, restartRect.left, restartRect.top,
-                 restartRect.right - restartRect.left,
-                 restartRect.bottom - restartRect.top,
+      MoveWindow(hwndClose, closeRect.left, closeRect.top,
+                 closeRect.right - closeRect.left,
+                 closeRect.bottom - closeRect.top,
                  TRUE);
       StretchControlsToFit(hwndDlg);
     }
-    // need to move the close button regardless
-    MoveWindow(hwndClose, closeRect.left, closeRect.top,
-               closeRect.right - closeRect.left,
-               closeRect.bottom - closeRect.top,
+    // need to move the restart button regardless
+    MoveWindow(hwndRestart, restartRect.left, restartRect.top,
+               restartRect.right - restartRect.left,
+               restartRect.bottom - restartRect.top,
                TRUE);
 
     // Resize the description text last, in case the window was resized
     // before this.
     SendDlgItemMessage(hwndDlg, IDC_DESCRIPTIONTEXT,
                        EM_SETEVENTMASK, (WPARAM)NULL,
                        ENM_REQUESTRESIZE);
     
diff -r b7bcdd009540 toolkit/library/Makefile.in
--- a/toolkit/library/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/toolkit/library/Makefile.in	Thu Sep 11 15:19:27 2008 +0300
@@ -210,16 +210,24 @@ EXTRA_DSO_LDOPTS += \
 EXTRA_DSO_LDOPTS += \
 	-framework CoreAudio \
  	-framework AudioToolbox \
 	-framework AudioUnit \
 	$(NULL)
 endif
 endif
 
+ifdef MOZ_PLATFORM_HILDON
+EXTRA_DSO_LDOPTS += $(LIBHILDONMIME_LIBS)
+endif 
+
+ifdef NS_OSSO
+EXTRA_DSO_LDOPTS += $(LIBOSSO_LIBS)
+endif
+
 ifdef MOZ_ENABLE_DBUS
 EXTRA_DSO_LDOPTS += $(MOZ_DBUS_GLIB_LIBS)
 endif
 
 ifeq (gtk2,$(MOZ_WIDGET_TOOLKIT))
 EXTRA_DSO_LDOPTS += $(XLDFLAGS) $(XLIBS) $(MOZ_XFT_LIBS) $(MOZ_GTK2_LIBS) $(XT_LIBS) -lgthread-2.0
 EXTRA_DSO_LDOPTS += $(FT2_LIBS)
 endif
diff -r b7bcdd009540 toolkit/mozapps/downloads/tests/chrome/Makefile.in
--- a/toolkit/mozapps/downloads/tests/chrome/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/toolkit/mozapps/downloads/tests/chrome/Makefile.in	Thu Sep 11 15:19:27 2008 +0300
@@ -45,16 +45,17 @@ relativesrcdir = toolkit/mozapps/downloa
 
 include $(DEPTH)/config/autoconf.mk
 include $(topsrcdir)/config/rules.mk
 
 _CHROME_FILES = \
   test_basic_functionality.xul \
   test_cleanup_search.xul \
   test_clear_button_disabled.xul \
+  test_close_download_manager.xul \
   test_delete_key_removes.xul \
   test_esc_key_closes_clears.xul \
   test_multi_select.xul \
   test_multiword_search.xul \
   test_pause_button_state.xul \
   test_removeDownload_updates_ui.xul \
   test_retention_is_0_closes.xul \
   test_search_clearlist.xul \
diff -r b7bcdd009540 toolkit/mozapps/downloads/tests/chrome/test_close_download_manager.xul
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/mozapps/downloads/tests/chrome/test_close_download_manager.xul	Thu Sep 11 15:19:27 2008 +0300
@@ -0,0 +1,132 @@
+<?xml version="1.0"?>
+<!--
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Download Manager UI Test Code.
+ *
+ * The Initial Developer of the Original Code is
+ * Anoop Saldanha <poonaatsoc@gmail.com>
+ *
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/**
+ * This test basically checks if the download manager
+ * closes when you press the esc key and accel + w.
+ */
+-->
+
+<window title="Download Manager Test"
+        onload="runTest();"
+        xmlns:html="http://www.w3.org/1999/xhtml"
+        xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
+
+  <script type="application/javascript"
+          src="chrome://mochikit/content/MochiKit/packed.js"/>
+  <script type="application/javascript"
+          src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"/>
+  <script type="application/javascript"
+          src="chrome://mochikit/content/tests/SimpleTest/EventUtils.js"/>
+  <script type="application/javascript"
+          src="chrome://mochikit/content/chrome/toolkit/mozapps/downloads/tests/chrome/utils.js"/>
+
+  <script type="application/javascript">
+
+  <![CDATA[
+
+const dmui = Cc["@mozilla.org/download-manager-ui;1"].
+             getService(Ci.nsIDownloadManagerUI);
+
+function testCloseDMWithEscKey(aWin)
+{
+  function dmWindowClosedListener() {
+    aWin.removeEventListener("unload", dmWindowClosedListener, false);
+    ok(!dmui.visible, "DMUI closes with ESC key");
+    dmui.show();
+  }
+  aWin.addEventListener("unload", dmWindowClosedListener, false);
+
+  synthesizeKey("VK_ESCAPE", { }, aWin);
+}
+
+function testCloseDMWithAccelKey(aWin)
+{
+  function dmWindowClosedListener() {
+    aWin.removeEventListener("unload", dmWindowClosedListener, false);
+    ok(!dmui.visible, "DMUI closes with accel + w");
+    setCleanState();
+    SimpleTest.finish();
+  }
+  aWin.addEventListener("unload", dmWindowClosedListener, false);
+
+  synthesizeKey("w", { accelKey: true }, aWin);
+}
+
+function runTest()
+{
+  const DLMGR_UI_DONE = "download-manager-ui-done";
+
+  // Close the DM UI if it is already open
+  let dm_win = getDMWindow();
+  if (dm_win) dm_win.close();
+
+  let testPhase = 0;
+  // Specify an observer that will be notified when the dm has been rendered on screen
+  let obs = Cc["@mozilla.org/observer-service;1"].
+            getService(Ci.nsIObserverService);
+  let testObs = {
+    observe: function(aSubject, aTopic, aData) {
+      let win = aSubject.QueryInterface(Ci.nsIDOMWindow);
+      switch(testPhase++) {
+        case 0:
+          testCloseDMWithEscKey(win);
+          break;
+        case 1:
+          obs.removeObserver(testObs, DLMGR_UI_DONE);
+          testCloseDMWithAccelKey(win);
+      }
+    }
+  };
+  obs.addObserver(testObs, DLMGR_UI_DONE, false);
+
+  dmui.show();
+
+  SimpleTest.waitForExplicitFinish();
+}
+
+  ]]>
+  </script>
+
+  <body xmlns="http://www.w3.org/1999/xhtml">
+    <p id="display"></p>
+    <div id="content" style="display: none"></div>
+    <pre id="test"></pre>
+  </body>
+</window>
diff -r b7bcdd009540 toolkit/mozapps/installer/windows/nsis/common.nsh
--- a/toolkit/mozapps/installer/windows/nsis/common.nsh	Mon Sep 08 00:36:19 2008 -0700
+++ b/toolkit/mozapps/installer/windows/nsis/common.nsh	Thu Sep 11 15:19:27 2008 +0300
@@ -308,16 +308,19 @@
 
   !insertmacro MUI_LANGUAGEFILE_LANGSTRING_DEFINE MUI_UNABORTWARNING "MUI_UNTEXT_ABORTWARNING"
 
 !macroend
 
 
 ################################################################################
 # Macros for creating Install Options ini files
+#
+# DEPRECATED - all ini creation code should be added to the application's
+# installer and uninstaller files.
 
 !macro createComponentsINI
   WriteINIStr "$PLUGINSDIR\components.ini" "Settings" NumFields "5"
 
   WriteINIStr "$PLUGINSDIR\components.ini" "Field 1" Type   "label"
   WriteINIStr "$PLUGINSDIR\components.ini" "Field 1" Text   "$(OPTIONAL_COMPONENTS_LABEL)"
   WriteINIStr "$PLUGINSDIR\components.ini" "Field 1" Left   "0"
   WriteINIStr "$PLUGINSDIR\components.ini" "Field 1" Right  "-1"
diff -r b7bcdd009540 toolkit/mozapps/update/content/updates.js
--- a/toolkit/mozapps/update/content/updates.js	Mon Sep 08 00:36:19 2008 -0700
+++ b/toolkit/mozapps/update/content/updates.js	Thu Sep 11 15:19:27 2008 +0300
@@ -1443,17 +1443,16 @@ var gDownloadingPage = {
         ", status = " + status);
 
     if (this._downloadThrobber.hasAttribute("state"))
       this._downloadThrobber.removeAttribute("state");
     if (this._downloadProgress.mode != "normal")
       this._downloadProgress.mode = "normal";
 
     var u = gUpdates.update;
-    const NS_BINDING_ABORTED = 0x804b0002;
     switch (status) {
     case Components.results.NS_ERROR_UNEXPECTED:
       if (u.selectedPatch.state == STATE_DOWNLOAD_FAILED &&
           u.isCompleteUpdate) {
         // Verification error of complete patch, informational text is held in
         // the update object.
         gUpdates.wiz.currentPage = document.getElementById("errors");
       }
@@ -1468,17 +1467,17 @@ var gDownloadingPage = {
 
         var verificationFailed = document.getElementById("verificationFailed");
         verificationFailed.hidden = false;
 
         this._statusFormatter = null;
         return;
       }
       break;
-    case NS_BINDING_ABORTED:
+    case Components.results.NS_BINDING_ABORTED:
       LOG("UI:DownloadingPage", "onStopRequest: Pausing Download");
       // Return early, do not remove UI listener since the user may resume
       // downloading again.
       return;
     case Components.results.NS_OK:
       LOG("UI:DownloadingPage", "onStopRequest: Patch Verification Succeeded");
       gUpdates.wiz.canAdvance = true;
       gUpdates.wiz.advance();
diff -r b7bcdd009540 toolkit/mozapps/update/src/nsUpdateService.js.in
--- a/toolkit/mozapps/update/src/nsUpdateService.js.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/toolkit/mozapps/update/src/nsUpdateService.js.in	Thu Sep 11 15:19:27 2008 +0300
@@ -1,51 +1,58 @@
-#if 0
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is the Update Service.
- *
- * The Initial Developer of the Original Code is Ben Goodger.
- * Portions created by the Initial Developer are Copyright (C) 2004
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *  Ben Goodger <ben@mozilla.org> (Original Author)
- *  Darin Fisher <darin@meer.net>
- *  Ben Turner <bent.mozilla@gmail.com>
- *  Jeff Walden <jwalden+code@mit.edu>
- *  Alexander J. Vincent <ajvincent@gmail.com>
- *  Do Gottwald <dao@mozilla.com>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-#endif
+/*
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Update Service.
+#
+# The Initial Developer of the Original Code is Ben Goodger.
+# Portions created by the Initial Developer are Copyright (C) 2004
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#  Ben Goodger <ben@mozilla.org> (Original Author)
+#  Darin Fisher <darin@meer.net>
+#  Ben Turner <bent.mozilla@gmail.com>
+#  Jeff Walden <jwalden+code@mit.edu>
+#  Alexander J. Vincent <ajvincent@gmail.com>
+#  Do Gottwald <dao@mozilla.com>
+#  Robert Strong <robert.bugzilla@gmail.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK ***** */
+*/
+
+const Cc = Components.classes;
+const Ci = Components.interfaces;
+const Cr = Components.results;
+
+Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");
 
 const PREF_APP_UPDATE_ENABLED             = "app.update.enabled";
 const PREF_APP_UPDATE_AUTO                = "app.update.auto";
 const PREF_APP_UPDATE_MODE                = "app.update.mode";
 const PREF_APP_UPDATE_SILENT              = "app.update.silent";
 const PREF_APP_UPDATE_INTERVAL            = "app.update.interval";
 const PREF_APP_UPDATE_TIMER               = "app.update.timer";
 const PREF_APP_UPDATE_IDLETIME            = "app.update.idletime";
@@ -108,29 +115,16 @@ const DOWNLOAD_CHUNK_SIZE           = 30
 const DOWNLOAD_CHUNK_SIZE           = 300000; // bytes
 const DOWNLOAD_BACKGROUND_INTERVAL  = 600;    // seconds
 const DOWNLOAD_FOREGROUND_INTERVAL  = 0;
 
 const TOOLKIT_ID              = "toolkit@mozilla.org";
 
 const POST_UPDATE_CONTRACTID = "@mozilla.org/updates/post-update;1";
 
-const nsIExtensionManager     = Components.interfaces.nsIExtensionManager;
-const nsILocalFile            = Components.interfaces.nsILocalFile;
-const nsIUpdateService        = Components.interfaces.nsIUpdateService;
-const nsIUpdateItem           = Components.interfaces.nsIUpdateItem;
-const nsIPrefLocalizedString  = Components.interfaces.nsIPrefLocalizedString;
-const nsIIncrementalDownload  = Components.interfaces.nsIIncrementalDownload;
-const nsIFileInputStream      = Components.interfaces.nsIFileInputStream;
-const nsIFileOutputStream     = Components.interfaces.nsIFileOutputStream;
-const nsICryptoHash           = Components.interfaces.nsICryptoHash;
-const nsIINIParserFactory     = Components.interfaces.nsIINIParserFactory;
-
-const Node = Components.interfaces.nsIDOMNode;
-
 var gApp        = null;
 var gPref       = null;
 var gABI        = null;
 var gOSVersion  = null;
 var gLocale     = null;
 var gConsole    = null;
 var gLogEnabled = { };
 
@@ -165,20 +159,20 @@ function binaryToHex(input) {
 
 /**
  * Gets a File URL spec for a nsIFile
  * @param   file
  *          The file to get a file URL spec to
  * @returns The file URL spec to the file
  */
 function getURLSpecFromFile(file) {
-  var ioServ = Components.classes["@mozilla.org/network/io-service;1"]
-                         .getService(Components.interfaces.nsIIOService);
-  var fph = ioServ.getProtocolHandler("file")
-                  .QueryInterface(Components.interfaces.nsIFileProtocolHandler);
+  var ioServ = Cc["@mozilla.org/network/io-service;1"].
+               getService(Ci.nsIIOService);
+  var fph = ioServ.getProtocolHandler("file").
+            QueryInterface(Ci.nsIFileProtocolHandler);
   return fph.getURLSpecFromFile(file);
 }
 
 /**
  * Gets the specified directory at the specified hierarchy under a
  * Directory Service key.
  * @param   key
  *          The Directory Service Key to start from
@@ -235,31 +229,31 @@ function getUpdateDir(pathArray) {
  *          should be created if it does not exist,
  *          false otherwise.
  * @param   update
  *          true if finding the update directory,
  *          false otherwise.
  * @return  nsIFile object for the location specified.
  */
 function getDirInternal(key, pathArray, shouldCreate, update) {
-  var fileLocator = Components.classes["@mozilla.org/file/directory_service;1"]
-                              .getService(Components.interfaces.nsIProperties);
-  var dir = fileLocator.get(key, Components.interfaces.nsIFile);
+  var fileLocator = Cc["@mozilla.org/file/directory_service;1"].
+                    getService(Ci.nsIProperties);
+  var dir = fileLocator.get(key, Ci.nsIFile);
 #ifdef XP_WIN
   if (update) {
     try {
-      dir = fileLocator.get(KEY_UPDROOT, Components.interfaces.nsIFile);
+      dir = fileLocator.get(KEY_UPDROOT, Ci.nsIFile);
     } catch (e) {
     }
   }
 #endif
   for (var i = 0; i < pathArray.length; ++i) {
     dir.append(pathArray[i]);
     if (shouldCreate && !dir.exists())
-      dir.create(nsILocalFile.DIRECTORY_TYPE, PERMS_DIRECTORY);
+      dir.create(Ci.nsILocalFile.DIRECTORY_TYPE, PERMS_DIRECTORY);
   }
   return dir;
 }
 
 /**
  * Gets the file at the specified hierarchy under a Directory Service key.
  * @param   key
  *          The Directory Service Key to start from
@@ -294,17 +288,17 @@ function getUpdateFile(pathArray) {
 }
 
 /**
  * Closes a Safe Output Stream
  * @param   fos
  *          The Safe Output Stream to close
  */
 function closeSafeOutputStream(fos) {
-  if (fos instanceof Components.interfaces.nsISafeOutputStream) {
+  if (fos instanceof Ci.nsISafeOutputStream) {
     try {
       fos.finish();
     }
     catch (e) {
       fos.close();
     }
   }
   else
@@ -317,19 +311,19 @@ function closeSafeOutputStream(fos) {
  * @param   code
  *          The error code to look up human readable status text for
  * @param   defaultCode
  *          The default code to look up should human readable status text
  *          not exist for |code|
  * @returns A human readable status text string
  */
 function getStatusTextFromCode(code, defaultCode) {
-  const updateBundle = Components.classes["@mozilla.org/intl/stringbundle;1"]
-                                 .getService(Components.interfaces.nsIStringBundleService)
-                                 .createBundle(URI_UPDATES_PROPERTIES);
+  const updateBundle = Cc["@mozilla.org/intl/stringbundle;1"].
+                       getService(Ci.nsIStringBundleService).
+                       createBundle(URI_UPDATES_PROPERTIES);
   var reason;
   try {
     reason = updateBundle.GetStringFromName("checker_error-" + code);
     LOG("General", "Transfer Error: " + reason + ", code: " + code);
   }
   catch (e) {
     // Use the default reason
     reason = updateBundle.GetStringFromName("checker_error-" + defaultCode);
@@ -343,36 +337,35 @@ function getStatusTextFromCode(code, def
  * @param   key
  *          The Directory Service Key (optional).
  *          If used, don't search local appdata on Win32 and don't create dir.
  * @returns The active updates directory, as a nsIFile object
  */
 function getUpdatesDir(key) {
   // Right now, we only support downloading one patch at a time, so we always
   // use the same target directory.
-  var fileLocator =
-      Components.classes["@mozilla.org/file/directory_service;1"].
-      getService(Components.interfaces.nsIProperties);
-  var appDir;
+  var fileLocator = Cc["@mozilla.org/file/directory_service;1"].
+                    getService(Ci.nsIProperties);
+  var updateDir;
   if (key)
-    appDir = fileLocator.get(key, Components.interfaces.nsIFile);
+    updateDir = fileLocator.get(key, Ci.nsIFile);
   else {
-    appDir = fileLocator.get(KEY_APPDIR, Components.interfaces.nsIFile);
+    updateDir = fileLocator.get(KEY_APPDIR, Ci.nsIFile);
 #ifdef XP_WIN
     try {
-      appDir = fileLocator.get(KEY_UPDROOT, Components.interfaces.nsIFile);
+      updateDir = fileLocator.get(KEY_UPDROOT, Ci.nsIFile);
     } catch (e) {
     }
 #endif
   }
-  appDir.append(DIR_UPDATES);
-  appDir.append("0");
-  if (!appDir.exists() && !key)
-    appDir.create(nsILocalFile.DIRECTORY_TYPE, PERMS_DIRECTORY);
-  return appDir;
+  updateDir.append(DIR_UPDATES);
+  updateDir.append("0");
+  if (!updateDir.exists() && !key)
+    updateDir.create(Ci.nsILocalFile.DIRECTORY_TYPE, PERMS_DIRECTORY);
+  return updateDir;
 }
 
 /**
  * Reads the update state from the update.status file in the specified
  * directory.
  * @param   dir
  *          The dir to look for an update.status file in
  * @returns The status value of the update.
@@ -413,17 +406,17 @@ function cleanUpUpdatesDir(key) {
     updateDir = getUpdatesDir(key);
   }
   catch (e) {
     return;
   }
 
   var e = updateDir.directoryEntries;
   while (e.hasMoreElements()) {
-    var f = e.getNext().QueryInterface(Components.interfaces.nsIFile);
+    var f = e.getNext().QueryInterface(Ci.nsIFile);
     // Preserve the last update log file for debugging purposes
     if (f.leafName == FILE_UPDATE_LOG) {
       try {
         var dir = f.parent.parent;
         var logFile = dir.clone();
         logFile.append(FILE_LAST_LOG);
         if (logFile.exists())
           logFile.remove(false);
@@ -455,19 +448,18 @@ function cleanUpUpdatesDir(key) {
 /**
  * Clean up updates list and the updates directory.
  * @param   key
  *          The Directory Service Key under which update directory resides
  *          (optional).
  */
 function cleanupActiveUpdate(key) {
   // Move the update from the Active Update list into the Past Updates list.
-  var um =
-      Components.classes["@mozilla.org/updates/update-manager;1"].
-      getService(Components.interfaces.nsIUpdateManager);
+  var um = Cc["@mozilla.org/updates/update-manager;1"].
+           getService(Ci.nsIUpdateManager);
   um.activeUpdate = null;
   um.saveUpdates();
 
   // Now trash the updates directory, since we're done with it
   cleanUpUpdatesDir(key);
 }
 
 /**
@@ -495,38 +487,36 @@ function getPref(func, preference, defau
  * Gets the locale specified by the 'Locale' key in the 'Installation' section
  * of updater.ini.
  */
 function getLocale() {
   if (gLocale)
     return gLocale;
 
   var updaterIni = getFile(KEY_APPDIR, [FILE_UPDATER_INI]);
-  var iniParser = Components.classes["@mozilla.org/xpcom/ini-parser-factory;1"]
-                            .getService(nsIINIParserFactory).createINIParser(updaterIni);
+  var iniParser = Cc["@mozilla.org/xpcom/ini-parser-factory;1"].
+                  getService(Ci.nsIINIParserFactory).
+                  createINIParser(updaterIni);
   gLocale = iniParser.getString("Installation", "Locale");
   LOG("General", "Getting Locale from File: " + updaterIni.path + " Locale: " + gLocale);
   return gLocale;
 }
 
 /**
  * Read the update channel from defaults only.  We do this to ensure that
  * the channel is tightly coupled with the application and does not apply
  * to other instances of the application that may use the same profile.
  */
 function getUpdateChannel() {
   var channel = "default";
   var prefName;
   var prefValue;
 
-  var defaults =
-      gPref.QueryInterface(Components.interfaces.nsIPrefService).
-      getDefaultBranch(null);
   try {
-    channel = defaults.getCharPref(PREF_APP_UPDATE_CHANNEL);
+    channel = getDefaultPrefBranch().getCharPref(PREF_APP_UPDATE_CHANNEL);
   } catch (e) {
     // use default when pref not found
   }
 
   try {
     var partners = gPref.getChildList(PREF_PARTNER_BRANCH, { });
     if (partners.length) {
       channel += "-cck";
@@ -544,21 +534,18 @@ function getUpdateChannel() {
 
   return channel;
 }
 
 /* Get the distribution pref values, from defaults only */
 function getDistributionPrefValue(aPrefName) {
   var prefValue = "default";
 
-  var defaults =
-      gPref.QueryInterface(Components.interfaces.nsIPrefService).
-      getDefaultBranch(null);
   try {
-    prefValue = defaults.getCharPref(aPrefName);
+    prefValue = getDefaultPrefBranch().getCharPref(aPrefName);
   } catch (e) {
     // use default when pref not found
   }
 
   return prefValue;
 }
 
 /**
@@ -601,77 +588,78 @@ function stripPrefix(string, prefix) {
   return string.substr(prefix.length);
 }
 
 /**
  * Writes a string of text to a file.  A newline will be appended to the data
  * written to the file.  This function only works with ASCII text.
  */
 function writeStringToFile(file, text) {
-  var fos =
-      Components.classes["@mozilla.org/network/safe-file-output-stream;1"].
-      createInstance(nsIFileOutputStream);
+  var fos = Cc["@mozilla.org/network/safe-file-output-stream;1"].
+            createInstance(Ci.nsIFileOutputStream);
   var modeFlags = MODE_WRONLY | MODE_CREATE | MODE_TRUNCATE;
   if (!file.exists())
-    file.create(nsILocalFile.NORMAL_FILE_TYPE, PERMS_FILE);
+    file.create(Ci.nsILocalFile.NORMAL_FILE_TYPE, PERMS_FILE);
   fos.init(file, modeFlags, PERMS_FILE, 0);
   text += "\n";
   fos.write(text, text.length);
   closeSafeOutputStream(fos);
 }
 
 /**
  * Reads a string of text from a file.  A trailing newline will be removed
  * before the result is returned.  This function only works with ASCII text.
  */
 function readStringFromFile(file) {
-  var fis =
-      Components.classes["@mozilla.org/network/file-input-stream;1"].
-      createInstance(nsIFileInputStream);
+  var fis = Cc["@mozilla.org/network/file-input-stream;1"].
+            createInstance(Ci.nsIFileInputStream);
   var modeFlags = MODE_RDONLY;
   if (!file.exists())
     return null;
   fis.init(file, modeFlags, PERMS_FILE, 0);
-  var sis =
-      Components.classes["@mozilla.org/scriptableinputstream;1"].
-      createInstance(Components.interfaces.nsIScriptableInputStream);
+  var sis = Cc["@mozilla.org/scriptableinputstream;1"].
+            createInstance(Ci.nsIScriptableInputStream);
   sis.init(fis);
   var text = sis.read(sis.available());
   sis.close();
   if (text[text.length - 1] == "\n")
     text = text.slice(0, -1);
   return text;
 }
 
 function getObserverService()
 {
-  return Components.classes["@mozilla.org/observer-service;1"]
-                   .getService(Components.interfaces.nsIObserverService);
+  return Cc["@mozilla.org/observer-service;1"].
+         getService(Ci.nsIObserverService);
 }
 
+function getDefaultPrefBranch()
+{
+  return gPref.QueryInterface(Ci.nsIPrefService).getDefaultBranch(null);
+}
 /**
  * Update Patch
  * @param   patch
  *          A <patch> element to initialize this object with
  * @throws if patch has a size of 0
  * @constructor
  */
 function UpdatePatch(patch) {
   this._properties = {};
   for (var i = 0; i < patch.attributes.length; ++i) {
     var attr = patch.attributes.item(i);
-    attr.QueryInterface(Components.interfaces.nsIDOMAttr);
+    attr.QueryInterface(Ci.nsIDOMAttr);
     switch (attr.name) {
     case "selected":
       this.selected = attr.value == "true";
       break;
     case "size":
       if (0 == parseInt(attr.value)) {
         LOG("UpdatePatch", "0-sized patch!");
-        throw Components.results.NS_ERROR_ILLEGAL_VALUE;
+        throw Cr.NS_ERROR_ILLEGAL_VALUE;
       }
       // fall through
     default:
       this[attr.name] = attr.value;
       break;
     };
   }
 }
@@ -711,17 +699,17 @@ UpdatePatch.prototype = {
 
   /**
    * See nsIWritablePropertyBag.idl
    */
   deleteProperty: function(name) {
     if (name in this._properties)
       this._properties[name].present = false;
     else
-      throw Components.results.NS_ERROR_FAILURE;
+      throw Cr.NS_ERROR_FAILURE;
   },
 
   /**
    * See nsIPropertyBag.idl
    */
   get enumerator() {
     var properties = [];
     for (var p in this._properties)
@@ -731,17 +719,17 @@ UpdatePatch.prototype = {
 
   /**
    * See nsIPropertyBag.idl
    */
   getProperty: function(name) {
     if (name in this._properties &&
         this._properties[name].present)
       return this._properties[name].data;
-    throw Components.results.NS_ERROR_FAILURE;
+    throw Cr.NS_ERROR_FAILURE;
   },
 
   /**
    * Returns whether or not the update.status file for this patch exists at the
    * appropriate location.
    */
   get statusFileExists() {
     var statusFile = getUpdatesDir();
@@ -756,27 +744,19 @@ UpdatePatch.prototype = {
     if (!this.statusFileExists)
       return STATE_NONE;
     return this._properties.state;
   },
   set state(val) {
     this._properties.state = val;
   },
 
-  /**
-   * See nsISupports.idl
-   */
-  QueryInterface: function(iid) {
-    if (!iid.equals(Components.interfaces.nsIUpdatePatch) &&
-        !iid.equals(Components.interfaces.nsIPropertyBag) &&
-        !iid.equals(Components.interfaces.nsIWritablePropertyBag) &&
-        !iid.equals(Components.interfaces.nsISupports))
-      throw Components.results.NS_ERROR_NO_INTERFACE;
-    return this;
-  }
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIUpdatePatch,
+                                         Ci.nsIPropertyBag,
+                                         Ci.nsIWritablePropertyBag])
 };
 
 /**
  * Update
  * Implements nsIUpdate
  * @param   update
  *          An <update> element to initialize this object with
  * @throws if the update contains no patches
@@ -789,37 +769,38 @@ function Update(update) {
   this.isCompleteUpdate = false;
   this.channel = "default"
 
   // Null <update>, assume this is a message container and do no
   // further initialization
   if (!update)
     return;
 
+  const ELEMENT_NODE = Ci.nsIDOMNode.ELEMENT_NODE;
   for (var i = 0; i < update.childNodes.length; ++i) {
     var patchElement = update.childNodes.item(i);
-    if (patchElement.nodeType != Node.ELEMENT_NODE ||
+    if (patchElement.nodeType != ELEMENT_NODE ||
         patchElement.localName != "patch")
       continue;
 
-    patchElement.QueryInterface(Components.interfaces.nsIDOMElement);
+    patchElement.QueryInterface(Ci.nsIDOMElement);
     try {
       var patch = new UpdatePatch(patchElement);
     } catch (e) {
       continue;
     }
     this._patches.push(patch);
   }
 
   if (0 == this._patches.length)
-    throw Components.results.NS_ERROR_ILLEGAL_VALUE;
+    throw Cr.NS_ERROR_ILLEGAL_VALUE;
 
   for (var i = 0; i < update.attributes.length; ++i) {
     var attr = update.attributes.item(i);
-    attr.QueryInterface(Components.interfaces.nsIDOMAttr);
+    attr.QueryInterface(Ci.nsIDOMAttr);
     if (attr.name == "installDate" && attr.value)
       this.installDate = parseInt(attr.value);
     else if (attr.name == "isCompleteUpdate")
       this.isCompleteUpdate = attr.value == "true";
     else if (attr.name == "isSecurityUpdate")
       this.isSecurityUpdate = attr.value == "true";
     else if (attr.name == "detailsURL")
       this._detailsURL = attr.value;
@@ -830,18 +811,18 @@ function Update(update) {
   }
 
   // The Update Name is either the string provided by the <update> element, or
   // the string: "<App Name> <Update App Version>"
   var name = "";
   if (update.hasAttribute("name"))
     name = update.getAttribute("name");
   else {
-    var sbs = Components.classes["@mozilla.org/intl/stringbundle;1"]
-                        .getService(Components.interfaces.nsIStringBundleService);
+    var sbs = Cc["@mozilla.org/intl/stringbundle;1"].
+              getService(Ci.nsIStringBundleService);
     var brandBundle = sbs.createBundle(URI_BRAND_PROPERTIES);
     var updateBundle = sbs.createBundle(URI_UPDATES_PROPERTIES);
     var appName = brandBundle.GetStringFromName("brandShortName");
     name = updateBundle.formatStringFromName("updateName",
                                              [appName, this.version], 2);
   }
   this.name = name;
 }
@@ -900,18 +881,18 @@ Update.prototype = {
   /**
    * See nsIUpdateService.idl
    */
   get detailsURL() {
     if (!this._detailsURL) {
       try {
         // Try using a default details URL supplied by the distribution
         // if the update XML does not supply one.
-        var formatter = Components.classes["@mozilla.org/toolkit/URLFormatterService;1"]
-                                  .getService(Components.interfaces.nsIURLFormatter);
+        var formatter = Cc["@mozilla.org/toolkit/URLFormatterService;1"].
+                        getService(Ci.nsIURLFormatter);
         return formatter.formatURLPref(PREF_APP_UPDATE_URL_DETAILS);
       }
       catch (e) {
       }
     }
     return this._detailsURL || "";
   },
 
@@ -960,17 +941,17 @@ Update.prototype = {
 
   /**
    * See nsIWritablePropertyBag.idl
    */
   deleteProperty: function(name) {
     if (name in this._properties)
       this._properties[name].present = false;
     else
-      throw Components.results.NS_ERROR_FAILURE;
+      throw Cr.NS_ERROR_FAILURE;
   },
 
   /**
    * See nsIPropertyBag.idl
    */
   get enumerator() {
     var properties = [];
     for (var p in this._properties)
@@ -980,57 +961,58 @@ Update.prototype = {
 
   /**
    * See nsIPropertyBag.idl
    */
   getProperty: function(name) {
     if (name in this._properties &&
         this._properties[name].present)
       return this._properties[name].data;
-    throw Components.results.NS_ERROR_FAILURE;
+    throw Cr.NS_ERROR_FAILURE;
   },
 
-  /**
-   * See nsISupports.idl
-   */
-  QueryInterface: function(iid) {
-    if (!iid.equals(Components.interfaces.nsIUpdate) &&
-        !iid.equals(Components.interfaces.nsIPropertyBag) &&
-        !iid.equals(Components.interfaces.nsIWritablePropertyBag) &&
-        !iid.equals(Components.interfaces.nsISupports))
-      throw Components.results.NS_ERROR_NO_INTERFACE;
-    return this;
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIUpdate,
+                                         Ci.nsIPropertyBag,
+                                         Ci.nsIWritablePropertyBag])
+};
+
+const UpdateServiceFactory = {
+  _instance: null,
+  createInstance: function (outer, iid) {
+    if (outer != null)
+      throw Components.results.NS_ERROR_NO_AGGREGATION;
+    return this._instance == null ? this._instance = new UpdateService() :
+                                    this._instance;
   }
 };
 
 /**
  * UpdateService
  * A Service for managing the discovery and installation of software updates.
  * @constructor
  */
 function UpdateService() {
-  gApp  = Components.classes["@mozilla.org/xre/app-info;1"]
-                    .getService(Components.interfaces.nsIXULAppInfo)
-                    .QueryInterface(Components.interfaces.nsIXULRuntime);
-  gPref = Components.classes["@mozilla.org/preferences-service;1"]
-                    .getService(Components.interfaces.nsIPrefBranch2);
-  gConsole = Components.classes["@mozilla.org/consoleservice;1"]
-                       .getService(Components.interfaces.nsIConsoleService);
+  gApp  = Cc["@mozilla.org/xre/app-info;1"].getService(Ci.nsIXULAppInfo).
+          QueryInterface(Ci.nsIXULRuntime);
+  gPref = Cc["@mozilla.org/preferences-service;1"].
+          getService(Ci.nsIPrefBranch2);
+  gConsole = Cc["@mozilla.org/consoleservice;1"].
+             getService(Ci.nsIConsoleService);
 
   // Not all builds have a known ABI
   try {
     gABI = gApp.XPCOMABI;
   }
   catch (e) {
     LOG("UpdateService", "XPCOM ABI unknown: updates are not possible.");
   }
 
   var osVersion;
-  var sysInfo = Components.classes["@mozilla.org/system-info;1"]
-                          .getService(Components.interfaces.nsIPropertyBag2);
+  var sysInfo = Cc["@mozilla.org/system-info;1"].
+                getService(Ci.nsIPropertyBag2);
   try {
     osVersion = sysInfo.getProperty("name") + " " + sysInfo.getProperty("version");
   }
   catch (e) {
     LOG("UpdateService", "OS Version unknown: updates are not possible.");
   }
 
   if (osVersion) {
@@ -1041,18 +1023,18 @@ function UpdateService() {
       // Not all platforms have a secondary widget library, so an error is nothing to worry about.
     }
     gOSVersion = encodeURIComponent(osVersion);
   }
 
 #ifdef XP_MACOSX
   // Mac universal build should report a different ABI than either macppc
   // or mactel.
-  var macutils = Components.classes["@mozilla.org/xpcom/mac-utils;1"]
-                           .getService(Components.interfaces.nsIMacUtils);
+  var macutils = Cc["@mozilla.org/xpcom/mac-utils;1"].
+                 getService(Ci.nsIMacUtils);
 
   if (macutils.isUniversalBinary)
     gABI = "Universal-gcc3";
 #endif
 
   // Start the update timer only after a profile has been selected so that the
   // appropriate values for the update check are read from the user's profile.
   var os = getObserverService();
@@ -1105,25 +1087,24 @@ UpdateService.prototype = {
   _start: function() {
     // Start logging
     this._initLoggingPrefs();
 
     // Clean up any extant updates
     this._postUpdateProcessing();
 
     // Register a background update check timer
-    var tm =
-        Components.classes["@mozilla.org/updates/timer-manager;1"]
-                  .getService(Components.interfaces.nsIUpdateTimerManager);
+    var tm = Cc["@mozilla.org/updates/timer-manager;1"].
+             getService(Ci.nsIUpdateTimerManager);
     var interval = getPref("getIntPref", PREF_APP_UPDATE_INTERVAL, 86400);
     tm.registerTimer("background-update-timer", this, interval);
 
     // Resume fetching...
-    var um = Components.classes["@mozilla.org/updates/update-manager;1"]
-                        .getService(Components.interfaces.nsIUpdateManager);
+    var um = Cc["@mozilla.org/updates/update-manager;1"].
+             getService(Ci.nsIUpdateManager);
     var activeUpdate = um.activeUpdate;
     if (activeUpdate) {
       var status = this.downloadUpdate(activeUpdate, true);
       if (status == STATE_NONE)
         cleanupActiveUpdate();
     }
   },
 
@@ -1174,57 +1155,53 @@ UpdateService.prototype = {
       LOG("UpdateService", "_postUpdateProcessing: Downloading patch, resuming...");
     }
     else if (status != null) {
       // null status means the update.status file is not present, because either:
       // 1) no update was performed, and so there's no UI to show
       // 2) an update was attempted but failed during checking, transfer or
       //    verification, and was cleaned up at that point, and UI notifying of
       //    that error was shown at that stage.
-      var um =
-          Components.classes["@mozilla.org/updates/update-manager;1"].
-          getService(Components.interfaces.nsIUpdateManager);
-      var prompter =
-          Components.classes["@mozilla.org/updates/update-prompt;1"].
-          createInstance(Components.interfaces.nsIUpdatePrompt);
+      var um = Cc["@mozilla.org/updates/update-manager;1"].
+               getService(Ci.nsIUpdateManager);
+      var prompter = Cc["@mozilla.org/updates/update-prompt;1"].
+                     createInstance(Ci.nsIUpdatePrompt);
 
       var shouldCleanup = true;
       var update = um.activeUpdate;
       if (!update) {
         update = new Update(null);
       }
       update.state = status;
-      var sbs =
-          Components.classes["@mozilla.org/intl/stringbundle;1"].
-          getService(Components.interfaces.nsIStringBundleService);
+      var sbs = Cc["@mozilla.org/intl/stringbundle;1"].
+                getService(Ci.nsIStringBundleService);
       var bundle = sbs.createBundle(URI_UPDATES_PROPERTIES);
       if (status == STATE_SUCCEEDED) {
         update.statusText = bundle.GetStringFromName("installSuccess");
 
         // Dig through the update history to find the patch that was just
         // installed and update its metadata.
         for (var i = 0; i < um.updateCount; ++i) {
           var umUpdate = um.getUpdateAt(i);
           if (umUpdate && umUpdate.version == update.version &&
-                          umUpdate.buildID == update.buildID) {
+              umUpdate.buildID == update.buildID) {
             umUpdate.statusText = update.statusText;
             break;
           }
         }
 
         LOG("UpdateService", "_postUpdateProcessing: Install Succeeded, Showing UI");
         prompter.showUpdateInstalled(update);
 #ifdef MOZ_SUNBIRD
         // we need to fix both nsPostUpdateWin.js and
         // the uninstaller to work for sunbird
 #else
         // Perform platform-specific post-update processing.
-        if (POST_UPDATE_CONTRACTID in Components.classes) {
-          Components.classes[POST_UPDATE_CONTRACTID].
-              createInstance(Components.interfaces.nsIRunnable).run();
+        if (POST_UPDATE_CONTRACTID in Cc) {
+          Cc[POST_UPDATE_CONTRACTID].createInstance(Ci.nsIRunnable).run();
         }
 #endif
 
         // Done with this update. Clean it up.
         cleanupActiveUpdate(updRootKey);
       }
       else {
         // If we hit an error, then the error code will be included in the
@@ -1256,34 +1233,34 @@ UpdateService.prototype = {
           var status = this.downloadUpdate(update, true);
           if (status == STATE_NONE)
             cleanupActiveUpdate();
         }
         else {
           LOG("UpdateService", "_postUpdateProcessing: Install of Complete or " +
               "only patch failed. Showing error.");
         }
-        update.QueryInterface(Components.interfaces.nsIWritablePropertyBag);
+        update.QueryInterface(Ci.nsIWritablePropertyBag);
         update.setProperty("patchingFailed", oldType);
         prompter.showUpdateError(update);
       }
     }
     else {
       LOG("UpdateService", "_postUpdateProcessing: No Status, No Update");
     }
   },
 
   /**
    * Initialize Logging preferences, formatted like so:
    *  app.update.log.<moduleName> = <true|false>
    */
   _initLoggingPrefs: function() {
     try {
-      var ps = Components.classes["@mozilla.org/preferences-service;1"]
-                        .getService(Components.interfaces.nsIPrefService);
+      var ps = Cc["@mozilla.org/preferences-service;1"].
+               getService(Ci.nsIPrefService);
       var logBranch = ps.getBranch(PREF_APP_UPDATE_LOG_BRANCH);
       var modules = logBranch.getChildList("", { value: 0 });
 
       for (var i = 0; i < modules.length; ++i) {
         if (logBranch.prefHasUserValue(modules[i]))
           gLogEnabled[modules[i]] = logBranch.getBoolPref(modules[i]);
       }
     }
@@ -1361,17 +1338,17 @@ UpdateService.prototype = {
     // If app.update.enabled is set to false, an update check is not performed
     // at all, and so none of the decision making above is entered into.
     //
     if (update.type == "major") {
       LOG("Checker", "_shouldPrompt: Prompting because it is a major update");
       return true;
     }
 
-    update.QueryInterface(Components.interfaces.nsIPropertyBag);
+    update.QueryInterface(Ci.nsIPropertyBag);
     try {
       var licenseAccepted = update.getProperty("licenseAccepted") == "true";
     }
     catch (e) {
       licenseAccepted = false;
     }
 
     var updateEnabled = getPref("getBoolPref", PREF_APP_UPDATE_ENABLED, true);
@@ -1413,18 +1390,18 @@ UpdateService.prototype = {
   selectUpdate: function(updates) {
     if (updates.length == 0)
       return null;
 
     // Choose the newest of the available minor and major updates.
     var majorUpdate = null, minorUpdate = null;
     var newestMinor = updates[0], newestMajor = updates[0];
 
-    var vc = Components.classes["@mozilla.org/xpcom/version-comparator;1"]
-                       .getService(Components.interfaces.nsIVersionComparator);
+    var vc = Cc["@mozilla.org/xpcom/version-comparator;1"].
+             getService(Ci.nsIVersionComparator);
     for (var i = 0; i < updates.length; ++i) {
       if (updates[i].type == "major" &&
           vc.compare(newestMajor.version, updates[i].version) <= 0)
         majorUpdate = newestMajor = updates[i];
       if (updates[i].type == "minor" &&
           vc.compare(newestMinor.version, updates[i].version) <= 0)
         minorUpdate = newestMinor = updates[i];
     }
@@ -1446,18 +1423,18 @@ UpdateService.prototype = {
    * user for permission if required.
    * @param   updates
    *          An array of available updates
    */
   _selectAndInstallUpdate: function(updates) {
     // Don't prompt if there's an active update - the user is already
     // aware and is downloading, or performed some user action to prevent
     // notification.
-    var um = Components.classes["@mozilla.org/updates/update-manager;1"]
-                       .getService(Components.interfaces.nsIUpdateManager);
+    var um = Cc["@mozilla.org/updates/update-manager;1"].
+             getService(Ci.nsIUpdateManager);
     if (um.activeUpdate)
       return;
 
     var update = this.selectUpdate(updates, updates.length);
     if (!update)
       return;
 
     // check if the user said "never" to this version
@@ -1508,31 +1485,30 @@ UpdateService.prototype = {
   /**
    * See nsIUpdateService.idl
    */
   get canUpdate() {
     try {
       var appDirFile = getUpdateFile([FILE_PERMS_TEST]);
       LOG("UpdateService", "canUpdate?  testing " + appDirFile.path);
       if (!appDirFile.exists()) {
-        appDirFile.create(nsILocalFile.NORMAL_FILE_TYPE, PERMS_FILE);
+        appDirFile.create(Ci.nsILocalFile.NORMAL_FILE_TYPE, PERMS_FILE);
         appDirFile.remove(false);
       }
       var updateDir = getUpdatesDir();
       var upDirFile = updateDir.clone();
       upDirFile.append(FILE_PERMS_TEST);
       LOG("UpdateService", "canUpdate?  testing " + upDirFile.path);
       if (!upDirFile.exists()) {
-        upDirFile.create(nsILocalFile.NORMAL_FILE_TYPE, PERMS_FILE);
+        upDirFile.create(Ci.nsILocalFile.NORMAL_FILE_TYPE, PERMS_FILE);
         upDirFile.remove(false);
       }
 #ifdef XP_WIN
-      var sysInfo =
-        Components.classes["@mozilla.org/system-info;1"]
-                  .getService(Components.interfaces.nsIPropertyBag2);
+      var sysInfo = Cc["@mozilla.org/system-info;1"].
+                    getService(Ci.nsIPropertyBag2);
 
       // Example windowsVersion:  Windows XP == 5.1
       var windowsVersion = sysInfo.getProperty("version");
       LOG("UpdateService", "canUpdate?  windowsVersion = " + windowsVersion);
 
       // For Vista, updates can be performed to a location requiring 
       // admin privileges by requesting elevation via the UAC prompt when 
       // launching updater.exe if the appDir is under the Program Files 
@@ -1543,26 +1519,24 @@ UpdateService.prototype = {
       // turned on and the installation directory is in a restricted
       // location that requires admin privileges to update other than 
       // Program Files.
 
       var userCanElevate = false;
 
       if (parseFloat(windowsVersion) >= 6) {
         try {
-          var fileLocator = 
-            Components.classes["@mozilla.org/file/directory_service;1"]
-                      .getService(Components.interfaces.nsIProperties);
+          var fileLocator = Cc["@mozilla.org/file/directory_service;1"].
+                            getService(Ci.nsIProperties);
           // KEY_UPDROOT will fail and throw an exception if
           // appDir is not under the Program Files, so we rely on that
-          var dir = fileLocator.get(KEY_UPDROOT, Components.interfaces.nsIFile);
+          var dir = fileLocator.get(KEY_UPDROOT, Ci.nsIFile);
           // appDir is under Program Files, so check if the user can elevate
-          userCanElevate = 
-            gApp.QueryInterface(Components.interfaces.nsIWinAppHelper)
-                .userCanElevate;
+          userCanElevate = gApp.QueryInterface(Ci.nsIWinAppHelper).
+                           userCanElevate;
           LOG("UpdateService", 
               "canUpdate?  on Vista, userCanElevate = " + userCanElevate);
         }
         catch (ex) {
           // When the installation directory is not under Program Files,
           // fall through to checking if write access to the 
           // installation directory is available.
           LOG("UpdateService", 
@@ -1593,17 +1567,17 @@ UpdateService.prototype = {
       if (!userCanElevate) {
         // if we're unable to create the test file
         // the code below will throw an exception 
         var actualAppDir = getDir(KEY_APPDIR, []);
         var actualAppDirFile = actualAppDir.clone();
         actualAppDirFile.append(FILE_PERMS_TEST);
         LOG("UpdateService", "canUpdate?  testing " + actualAppDirFile.path);
         if (!actualAppDirFile.exists()) {
-          actualAppDirFile.create(nsILocalFile.NORMAL_FILE_TYPE, PERMS_FILE);
+          actualAppDirFile.create(Ci.nsILocalFile.NORMAL_FILE_TYPE, PERMS_FILE);
           actualAppDirFile.remove(false);
         }
       }
 #endif
     }
     catch (e) {
        LOG("UpdateService", "can't update, no privileges: " + e);
       // No write privileges to install directory
@@ -1656,17 +1630,17 @@ UpdateService.prototype = {
     this._downloader.removeDownloadListener(listener);
   },
 
   /**
    * See nsIUpdateService.idl
    */
   downloadUpdate: function(update, background) {
     if (!update)
-      throw Components.results.NS_ERROR_NULL_POINTER;
+      throw Cr.NS_ERROR_NULL_POINTER;
     if (this.isDownloading) {
       if (update.isCompleteUpdate == this._downloader.isCompleteUpdate &&
           background == this._downloader.background) {
         LOG("UpdateService", "no support for downloading more than one update at a time");
         return readStatusFile(getUpdatesDir());
       }
       this._downloader.cancel();
     }
@@ -1684,27 +1658,35 @@ UpdateService.prototype = {
 
   /**
    * See nsIUpdateService.idl
    */
   get isDownloading() {
     return this._downloader && this._downloader.isBusy;
   },
 
-  /**
-   * See nsISupports.idl
-   */
-  QueryInterface: function(iid) {
-    if (!iid.equals(Components.interfaces.nsIApplicationUpdateService) &&
-        !iid.equals(Components.interfaces.nsITimerCallback) &&
-        !iid.equals(Components.interfaces.nsIObserver) &&
-        !iid.equals(Components.interfaces.nsISupports))
-      throw Components.results.NS_ERROR_NO_INTERFACE;
-    return this;
-  }
+  // nsIClassInfo
+  flags: Ci.nsIClassInfo.SINGLETON,
+  implementationLanguage: Ci.nsIProgrammingLanguage.JAVASCRIPT,
+  getHelperForLanguage: function(language) null,
+  getInterfaces: function(count) {
+    var interfaces = [Ci.nsIApplicationUpdateService, Ci.nsITimerCallback,
+                      Ci.nsIObserver];
+    count.value = interfaces.length;
+    return interfaces;
+  },
+
+  classDescription: "Update Service",
+  contractID: "@mozilla.org/updates/update-service;1",
+  classID: Components.ID("{B3C290A6-3943-4B89-8BBE-C01EB7B3B311}"),
+  _xpcom_categories: [{ category: "app-startup", service: true }],
+  _xpcom_factory: UpdateServiceFactory,
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIApplicationUpdateService,
+                                         Ci.nsITimerCallback,
+                                         Ci.nsIObserver])
 };
 
 /**
  * A service to manage active and past updates.
  * @constructor
  */
 function UpdateManager() {
   // Ensure the Active Update file is loaded
@@ -1732,32 +1714,34 @@ UpdateManager.prototype = {
    */
   _loadXMLFileIntoArray: function(file) {
     if (!file.exists()) {
       LOG("UpdateManager", "_loadXMLFileIntoArray: XML File does not exist");
       return [];
     }
 
     var result = [];
-    var fileStream = Components.classes["@mozilla.org/network/file-input-stream;1"]
-                               .createInstance(Components.interfaces.nsIFileInputStream);
+    var fileStream = Cc["@mozilla.org/network/file-input-stream;1"].
+                     createInstance(Ci.nsIFileInputStream);
     fileStream.init(file, MODE_RDONLY, PERMS_FILE, 0);
     try {
-      var parser = Components.classes["@mozilla.org/xmlextras/domparser;1"]
-                            .createInstance(Components.interfaces.nsIDOMParser);
-      var doc = parser.parseFromStream(fileStream, "UTF-8", fileStream.available(), "text/xml");
+      var parser = Cc["@mozilla.org/xmlextras/domparser;1"].
+                   createInstance(Ci.nsIDOMParser);
+      var doc = parser.parseFromStream(fileStream, "UTF-8",
+                                       fileStream.available(), "text/xml");
 
+      const ELEMENT_NODE = Ci.nsIDOMNode.ELEMENT_NODE;
       var updateCount = doc.documentElement.childNodes.length;
       for (var i = 0; i < updateCount; ++i) {
         var updateElement = doc.documentElement.childNodes.item(i);
-        if (updateElement.nodeType != Node.ELEMENT_NODE ||
+        if (updateElement.nodeType != ELEMENT_NODE ||
             updateElement.localName != "update")
           continue;
 
-        updateElement.QueryInterface(Components.interfaces.nsIDOMElement);
+        updateElement.QueryInterface(Ci.nsIDOMElement);
         try {
           var update = new Update(updateElement);
         } catch (e) {
           LOG("UpdateManager", "_loadXMLFileIntoArray: invalid update");
           continue;
         }
         result.push(new Update(updateElement));
       }
@@ -1860,36 +1844,36 @@ UpdateManager.prototype = {
   /**
    * Serializes an array of updates to an XML file
    * @param   updates
    *          An array of nsIUpdate objects
    * @param   file
    *          The nsIFile object to serialize to
    */
   _writeUpdatesToXMLFile: function(updates, file) {
-    var fos = Components.classes["@mozilla.org/network/safe-file-output-stream;1"]
-                        .createInstance(Components.interfaces.nsIFileOutputStream);
+    var fos = Cc["@mozilla.org/network/safe-file-output-stream;1"].
+              createInstance(Ci.nsIFileOutputStream);
     var modeFlags = MODE_WRONLY | MODE_CREATE | MODE_TRUNCATE;
     if (!file.exists())
-      file.create(nsILocalFile.NORMAL_FILE_TYPE, PERMS_FILE);
+      file.create(Ci.nsILocalFile.NORMAL_FILE_TYPE, PERMS_FILE);
     fos.init(file, modeFlags, PERMS_FILE, 0);
 
     try {
-      var parser = Components.classes["@mozilla.org/xmlextras/domparser;1"]
-                            .createInstance(Components.interfaces.nsIDOMParser);
+      var parser = Cc["@mozilla.org/xmlextras/domparser;1"].
+                   createInstance(Ci.nsIDOMParser);
       const EMPTY_UPDATES_DOCUMENT = "<?xml version=\"1.0\"?><updates xmlns=\"http://www.mozilla.org/2005/app-update\"></updates>";
       var doc = parser.parseFromString(EMPTY_UPDATES_DOCUMENT, "text/xml");
 
       for (var i = 0; i < updates.length; ++i) {
         if (updates[i])
           doc.documentElement.appendChild(updates[i].serialize(doc));
       }
 
-      var serializer = Components.classes["@mozilla.org/xmlextras/xmlserializer;1"]
-                                .createInstance(Components.interfaces.nsIDOMSerializer);
+      var serializer = Cc["@mozilla.org/xmlextras/xmlserializer;1"].
+                       createInstance(Ci.nsIDOMSerializer);
       serializer.serializeToStream(doc.documentElement, fos, null);
     }
     catch (e) {
     }
 
     closeSafeOutputStream(fos);
   },
 
@@ -1900,25 +1884,20 @@ UpdateManager.prototype = {
     this._writeUpdatesToXMLFile([this._activeUpdate],
                                 getUpdateFile([FILE_UPDATE_ACTIVE]));
     if (this._updates) {
       this._writeUpdatesToXMLFile(this._updates.slice(0, 10),
                                   getUpdateFile([FILE_UPDATES_DB]));
     }
   },
 
-  /**
-   * See nsISupports.idl
-   */
-  QueryInterface: function(iid) {
-    if (!iid.equals(Components.interfaces.nsIUpdateManager) &&
-        !iid.equals(Components.interfaces.nsISupports))
-      throw Components.results.NS_ERROR_NO_INTERFACE;
-    return this;
-  }
+  classDescription: "Update Manager",
+  contractID: "@mozilla.org/updates/update-manager;1",
+  classID: Components.ID("{093C2356-4843-4C65-8709-D7DBCBBE7DFB}"),
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIUpdateManager])
 };
 
 
 /**
  * Checker
  * Checks for new Updates
  * @constructor
  */
@@ -1937,27 +1916,23 @@ Checker.prototype = {
 
   /**
    * The URL of the update service XML file to connect to that contains details
    * about available updates.
    */
   getUpdateURL: function(force) {
     this._forced = force;
 
-    var defaults =
-        gPref.QueryInterface(Components.interfaces.nsIPrefService).
-        getDefaultBranch(null);
-
     // Use the override URL if specified.
     var url = getPref("getCharPref", PREF_APP_UPDATE_URL_OVERRIDE, null);
 
     // Otherwise, construct the update URL from component parts.
     if (!url) {
       try {
-        url = defaults.getCharPref(PREF_APP_UPDATE_URL);
+        url = getDefaultPrefBranch().getCharPref(PREF_APP_UPDATE_URL);
       } catch (e) {
       }
     }
 
     if (!url || url == "") {
       LOG("Checker", "Update URL not defined");
       return null;
     }
@@ -1984,24 +1959,23 @@ Checker.prototype = {
     return url;
   },
 
   /**
    * See nsIUpdateService.idl
    */
   checkForUpdates: function(listener, force) {
     if (!listener)
-      throw Components.results.NS_ERROR_NULL_POINTER;
+      throw Cr.NS_ERROR_NULL_POINTER;
 
     if (!this.getUpdateURL(force) || (!this.enabled && !force))
       return;
 
-    this._request =
-      Components.classes["@mozilla.org/xmlextras/xmlhttprequest;1"].
-      createInstance(Components.interfaces.nsIXMLHttpRequest);
+    this._request = Cc["@mozilla.org/xmlextras/xmlhttprequest;1"].
+                    createInstance(Ci.nsIXMLHttpRequest);
     this._request.open("GET", this.getUpdateURL(force), true);
     this._request.channel.notificationCallbacks = new BadCertHandler();
     this._request.overrideMimeType("text/xml");
     this._request.setRequestHeader("Cache-Control", "no-cache");
 
     var self = this;
     this._request.onerror     = function(event) { self.onError(event);    };
     this._request.onload      = function(event) { self.onLoad(event);     };
@@ -2033,24 +2007,25 @@ Checker.prototype = {
       return [];
     }
 
     if (updatesElement.nodeName != "updates") {
       LOG("Checker", "get_updates: unexpected node name!");
       throw "";
     }
 
+    const ELEMENT_NODE = Ci.nsIDOMNode.ELEMENT_NODE;
     var updates = [];
     for (var i = 0; i < updatesElement.childNodes.length; ++i) {
       var updateElement = updatesElement.childNodes.item(i);
-      if (updateElement.nodeType != Node.ELEMENT_NODE ||
+      if (updateElement.nodeType != ELEMENT_NODE ||
           updateElement.localName != "update")
         continue;
 
-      updateElement.QueryInterface(Components.interfaces.nsIDOMElement);
+      updateElement.QueryInterface(Ci.nsIDOMElement);
       try {
         var update = new Update(updateElement);
       } catch (e) {
         LOG("Checker", "Invalid <update/>, ignoring...");
         continue;
       }
       update.serviceURL = this.getUpdateURL(this._forced);
       update.channel = getUpdateChannel();
@@ -2067,18 +2042,17 @@ Checker.prototype = {
     var status = 0;
     try {
       status = request.status;
     }
     catch (e) {
     }
 
     if (status == 0)
-      status = request.channel.QueryInterface(Components.interfaces.nsIRequest)
-                              .status;
+      status = request.channel.QueryInterface(Ci.nsIRequest).status;
     return status;
   },
 
   /**
    * The XMLHttpRequest succeeded and the document was loaded.
    * @param   event
    *          The nsIDOMEvent for the load
    */
@@ -2132,58 +2106,47 @@ Checker.prototype = {
 
     this._request = null;
   },
 
   /**
    * Whether or not we are allowed to do update checking.
    */
   _enabled: true,
-
-  /**
-   * See nsIUpdateService.idl
-   */
   get enabled() {
-    var aus =
-        Components.classes["@mozilla.org/updates/update-service;1"].
-        getService(Components.interfaces.nsIApplicationUpdateService);
+    var aus = Cc["@mozilla.org/updates/update-service;1"].
+              getService(Ci.nsIApplicationUpdateService);
     var enabled = getPref("getBoolPref", PREF_APP_UPDATE_ENABLED, true) &&
                   aus.canUpdate && this._enabled;
     return enabled;
   },
 
   /**
    * See nsIUpdateService.idl
    */
   stopChecking: function(duration) {
     // Always stop the current check
     if (this._request)
       this._request.abort();
 
-    const nsIUpdateChecker = Components.interfaces.nsIUpdateChecker;
     switch (duration) {
-    case nsIUpdateChecker.CURRENT_SESSION:
+    case Ci.nsIUpdateChecker.CURRENT_SESSION:
       this._enabled = false;
       break;
-    case nsIUpdateChecker.ANY_CHECKS:
+    case Ci.nsIUpdateChecker.ANY_CHECKS:
       this._enabled = false;
       gPref.setBoolPref(PREF_APP_UPDATE_ENABLED, this._enabled);
       break;
     }
   },
 
-  /**
-   * See nsISupports.idl
-   */
-  QueryInterface: function(iid) {
-    if (!iid.equals(Components.interfaces.nsIUpdateChecker) &&
-        !iid.equals(Components.interfaces.nsISupports))
-      throw Components.results.NS_ERROR_NO_INTERFACE;
-    return this;
-  }
+  classDescription: "Update Checker",
+  contractID: "@mozilla.org/updates/update-checker;1",
+  classID: Components.ID("{898CDC9B-E43F-422F-9CC4-2F6291B415A3}"),
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIUpdateChecker])
 };
 
 /**
  * Manages the download of updates
  * @param   background
  *          Whether or not this downloader is operating in background
  *          update mode.
  * @constructor
@@ -2213,18 +2176,17 @@ Downloader.prototype = {
    * between the new version and the previous version.
    */
   isCompleteUpdate: null,
 
   /**
    * Cancels the active download.
    */
   cancel: function() {
-    if (this._request &&
-        this._request instanceof Components.interfaces.nsIRequest) {
+    if (this._request && this._request instanceof Ci.nsIRequest) {
       const NS_BINDING_ABORTED = 0x804b0002;
       this._request.cancel(NS_BINDING_ABORTED);
     }
   },
 
   /**
    * Whether or not a patch has been downloaded and staged for installation.
    */
@@ -2241,26 +2203,26 @@ Downloader.prototype = {
       return false;
 
     var destination = this._request.destination;
 
     // Ensure that the file size matches the expected file size.
     if (destination.fileSize != this._patch.size)
       return false;
 
-    var fileStream = Components.classes["@mozilla.org/network/file-input-stream;1"].
-        createInstance(nsIFileInputStream);
+    var fileStream = Cc["@mozilla.org/network/file-input-stream;1"].
+                     createInstance(Ci.nsIFileInputStream);
     fileStream.init(destination, MODE_RDONLY, PERMS_FILE, 0);
 
     try {
-      var hash = Components.classes["@mozilla.org/security/hash;1"].
-          createInstance(nsICryptoHash);
-      var hashFunction = nsICryptoHash[this._patch.hashFunction.toUpperCase()];
+      var hash = Cc["@mozilla.org/security/hash;1"].
+                 createInstance(Ci.nsICryptoHash);
+      var hashFunction = Ci.nsICryptoHash[this._patch.hashFunction.toUpperCase()];
       if (hashFunction == undefined)
-        throw Components.results.NS_ERROR_UNEXPECTED;
+        throw Cr.NS_ERROR_UNEXPECTED;
       hash.init(hashFunction);
       hash.updateFromStream(fileStream, -1);
       // NOTE: For now, we assume that the format of _patch.hashValue is hex
       // encoded binary (such as what is typically output by programs like
       // sha1sum).  In the future, this may change to base64 depending on how
       // we choose to compute these hashes.
       digest = binaryToHex(hash.finish(false));
     } catch (e) {
@@ -2355,18 +2317,18 @@ Downloader.prototype = {
     // complete patch
     if (selectedPatch)
       selectedPatch.selected = true;
 
     update.isCompleteUpdate = useComplete;
 
     // Reset the Active Update object on the Update Manager and flush the
     // Active Update DB.
-    var um = Components.classes["@mozilla.org/updates/update-manager;1"]
-                       .getService(Components.interfaces.nsIUpdateManager);
+    var um = Cc["@mozilla.org/updates/update-manager;1"].
+             getService(Ci.nsIUpdateManager);
     um.activeUpdate = update;
 
     return selectedPatch;
   },
 
   /**
    * Whether or not we are currently downloading something.
    */
@@ -2376,17 +2338,17 @@ Downloader.prototype = {
 
   /**
    * Download and stage the given update.
    * @param   update
    *          A nsIUpdate object to download a patch for. Cannot be null.
    */
   downloadUpdate: function(update) {
     if (!update)
-      throw Components.results.NS_ERROR_NULL_POINTER;
+      throw Cr.NS_ERROR_NULL_POINTER;
 
     var updateDir = getUpdatesDir();
 
     this._update = update;
 
     // This function may return null, which indicates that there are no patches
     // to download.
     this._patch = this._selectPatch(update, updateDir);
@@ -2394,37 +2356,36 @@ Downloader.prototype = {
       LOG("Downloader", "no patch to download");
       return readStatusFile(updateDir);
     }
     this.isCompleteUpdate = this._patch.type == "complete";
 
     var patchFile = updateDir.clone();
     patchFile.append(FILE_UPDATE_ARCHIVE);
 
-    var ios = Components.classes["@mozilla.org/network/io-service;1"].
-        getService(Components.interfaces.nsIIOService);
+    var ios = Cc["@mozilla.org/network/io-service;1"].
+              getService(Ci.nsIIOService);
     var uri = ios.newURI(this._patch.URL, null, null);
 
-    this._request =
-        Components.classes["@mozilla.org/network/incremental-download;1"].
-        createInstance(nsIIncrementalDownload);
+    this._request = Cc["@mozilla.org/network/incremental-download;1"].
+                    createInstance(Ci.nsIIncrementalDownload);
 
     LOG("Downloader", "downloadUpdate: Downloading from " + uri.spec + " to " +
         patchFile.path);
 
     var interval = this.background ? DOWNLOAD_BACKGROUND_INTERVAL
                                    : DOWNLOAD_FOREGROUND_INTERVAL;
     this._request.init(uri, patchFile, DOWNLOAD_CHUNK_SIZE, interval);
     this._request.start(this, null);
 
     writeStatusFile(updateDir, STATE_DOWNLOADING);
-    this._patch.QueryInterface(Components.interfaces.nsIWritablePropertyBag);
+    this._patch.QueryInterface(Ci.nsIWritablePropertyBag);
     this._patch.state = STATE_DOWNLOADING;
-    var um = Components.classes["@mozilla.org/updates/update-manager;1"]
-                       .getService(Components.interfaces.nsIUpdateManager);
+    var um = Cc["@mozilla.org/updates/update-manager;1"].
+             getService(Ci.nsIUpdateManager);
     um.saveUpdates();
     return STATE_DOWNLOADING;
   },
 
   /**
    * An array of download listeners to notify when we receive
    * nsIRequestObserver or nsIProgressEventSink method calls.
    */
@@ -2461,17 +2422,17 @@ Downloader.prototype = {
   /**
    * When the async request begins
    * @param   request
    *          The nsIRequest object for the transfer
    * @param   context
    *          Additional data
    */
   onStartRequest: function(request, context) {
-    request.QueryInterface(nsIIncrementalDownload);
+    request.QueryInterface(Ci.nsIIncrementalDownload);
     LOG("Downloader", "onStartRequest: " + request.URI.spec);
 
     var listenerCount = this._listeners.length;
     for (var i = 0; i < listenerCount; ++i)
       this._listeners[i].onStartRequest(request, context);
   },
 
   /**
@@ -2481,97 +2442,94 @@ Downloader.prototype = {
    * @param   context
    *          Additional data
    * @param   progress
    *          The current number of bytes transferred
    * @param   maxProgress
    *          The total number of bytes that must be transferred
    */
   onProgress: function(request, context, progress, maxProgress) {
-    request.QueryInterface(nsIIncrementalDownload);
+    request.QueryInterface(Ci.nsIIncrementalDownload);
     LOG("Downloader.onProgress", "onProgress: " + request.URI.spec + ", " + progress + "/" + maxProgress);
 
     var listenerCount = this._listeners.length;
     for (var i = 0; i < listenerCount; ++i) {
       var listener = this._listeners[i];
-      if (listener instanceof Components.interfaces.nsIProgressEventSink)
+      if (listener instanceof Ci.nsIProgressEventSink)
         listener.onProgress(request, context, progress, maxProgress);
     }
   },
 
   /**
    * When we have new status text
    * @param   request
    *          The nsIRequest object for the transfer
    * @param   context
    *          Additional data
    * @param   status
    *          A status code
    * @param   statusText
    *          Human readable version of |status|
    */
   onStatus: function(request, context, status, statusText) {
-    request.QueryInterface(nsIIncrementalDownload);
+    request.QueryInterface(Ci.nsIIncrementalDownload);
     LOG("Downloader", "onStatus: " + request.URI.spec + " status = " + status + ", text = " + statusText);
     var listenerCount = this._listeners.length;
     for (var i = 0; i < listenerCount; ++i) {
       var listener = this._listeners[i];
-      if (listener instanceof Components.interfaces.nsIProgressEventSink)
+      if (listener instanceof Ci.nsIProgressEventSink)
         listener.onStatus(request, context, status, statusText);
     }
   },
 
   /**
    * When data transfer ceases
    * @param   request
    *          The nsIRequest object for the transfer
    * @param   context
    *          Additional data
    * @param   status
    *          Status code containing the reason for the cessation.
    */
   onStopRequest: function(request, context, status) {
-    request.QueryInterface(nsIIncrementalDownload);
+    request.QueryInterface(Ci.nsIIncrementalDownload);
     LOG("Downloader", "onStopRequest: " + request.URI.spec + ", status = " + status);
 
     var state = this._patch.state;
     var shouldShowPrompt = false;
     var deleteActiveUpdate = false;
     const NS_BINDING_ABORTED = 0x804b0002;
     const NS_ERROR_ABORT = 0x80004004;
     if (Components.isSuccessCode(status)) {
-      var sbs =
-          Components.classes["@mozilla.org/intl/stringbundle;1"].
-          getService(Components.interfaces.nsIStringBundleService);
+      var sbs = Cc["@mozilla.org/intl/stringbundle;1"].
+                getService(Ci.nsIStringBundleService);
       var updateStrings = sbs.createBundle(URI_UPDATES_PROPERTIES);
       if (this._verifyDownload()) {
         state = STATE_PENDING;
 
         // We only need to explicitly show the prompt if this is a backround
         // download, since otherwise some kind of UI is already visible and
         // that UI will notify.
         if (this.background)
           shouldShowPrompt = true;
 
         // Tell the updater.exe we're ready to apply.
         writeStatusFile(getUpdatesDir(), state);
         this._update.installDate = (new Date()).getTime();
-        this._update.statusText = updateStrings.
-          GetStringFromName("installPending");
+        this._update.statusText = updateStrings.GetStringFromName("installPending");
       } else {
         LOG("Downloader", "onStopRequest: download verification failed");
         state = STATE_DOWNLOAD_FAILED;
 
         var brandStrings = sbs.createBundle(URI_BRAND_PROPERTIES);
         var brandShortName = brandStrings.GetStringFromName("brandShortName");
-        this._update.statusText = updateStrings.
-          formatStringFromName("verificationError", [brandShortName], 1);
-
+        this._update.statusText = updateStrings.formatStringFromName("verificationError",
+                                                                     [brandShortName], 1);
         // TODO: use more informative error code here
-        status = Components.results.NS_ERROR_UNEXPECTED;
+        status = Cr.NS_ERROR_UNEXPECTED;
 
         // Yes, this code is a string.
         const vfCode = "verification_failed";
         var message = getStatusTextFromCode(vfCode, vfCode);
         this._update.statusText = message;
 
         if (this._update.isCompleteUpdate)
           deleteActiveUpdate = true;
@@ -2595,19 +2553,18 @@ Downloader.prototype = {
 
       // Destroy the updates directory, since we're done with it.
       cleanUpUpdatesDir();
 
       deleteActiveUpdate = true;
     }
     LOG("Downloader", "Setting state to: " + state);
     this._patch.state = state;
-    var um =
-        Components.classes["@mozilla.org/updates/update-manager;1"].
-        getService(Components.interfaces.nsIUpdateManager);
+    var um = Cc["@mozilla.org/updates/update-manager;1"].
+             getService(Ci.nsIUpdateManager);
     if (deleteActiveUpdate) {
       this._update.installDate = (new Date()).getTime();
       um.activeUpdate = null;
     }
     um.saveUpdates();
 
     var listenerCount = this._listeners.length;
     for (var i = 0; i < listenerCount; ++i)
@@ -2639,91 +2596,78 @@ Downloader.prototype = {
         // In all other failure cases, i.e. we're S.O.L. - no more failing over
         // ...
 
         // If this was ever a foreground download, and now there is no UI active
         // (e.g. because the user closed the download window) and there was an
         // error, we must notify now. Otherwise we can keep the failure to
         // ourselves since the user won't be expecting it.
         try {
-          this._update.QueryInterface(Components.interfaces.nsIWritablePropertyBag);
+          this._update.QueryInterface(Ci.nsIWritablePropertyBag);
           var fgdl = this._update.getProperty("foregroundDownload");
         }
         catch (e) {
         }
 
         if (fgdl == "true") {
-          var prompter =
-              Components.classes["@mozilla.org/updates/update-prompt;1"].
-              createInstance(Components.interfaces.nsIUpdatePrompt);
-          this._update.QueryInterface(Components.interfaces.nsIWritablePropertyBag);
+          var prompter = Cc["@mozilla.org/updates/update-prompt;1"].
+                         createInstance(Ci.nsIUpdatePrompt);
+          this._update.QueryInterface(Ci.nsIWritablePropertyBag);
           this._update.setProperty("downloadFailed", "true");
           prompter.showUpdateError(this._update);
         }
       }
 
       // the complete download succeeded or total failure was handled, so exit
       return;
     }
 
     // Do this after *everything* else, since it will likely cause the app
     // to shut down.
     if (shouldShowPrompt) {
       // Notify the user that an update has been downloaded and is ready for
       // installation (i.e. that they should restart the application). We do
       // not notify on failed update attempts.
-      var prompter =
-          Components.classes["@mozilla.org/updates/update-prompt;1"].
-          createInstance(Components.interfaces.nsIUpdatePrompt);
+      var prompter = Cc["@mozilla.org/updates/update-prompt;1"].
+                     createInstance(Ci.nsIUpdatePrompt);
       prompter.showUpdateDownloaded(this._update, true);
     }
   },
 
   /**
    * See nsIInterfaceRequestor.idl
    */
   getInterface: function(iid) {
     // The network request may require proxy authentication, so provide the
     // default nsIAuthPrompt if requested.
-    if (iid.equals(Components.interfaces.nsIAuthPrompt)) {
-      var prompt =
-          Components.classes["@mozilla.org/network/default-auth-prompt;1"].
-          createInstance();
+    if (iid.equals(Ci.nsIAuthPrompt)) {
+      var prompt = Cc["@mozilla.org/network/default-auth-prompt;1"].
+                   createInstance();
       return prompt.QueryInterface(iid);
     }
-    throw Components.results.NS_ERROR_NO_INTERFACE;
+    throw Cr.NS_ERROR_NO_INTERFACE;
   },
 
-  /**
-   * See nsISupports.idl
-   */
-  QueryInterface: function(iid) {
-    if (!iid.equals(Components.interfaces.nsIRequestObserver) &&
-        !iid.equals(Components.interfaces.nsIProgressEventSink) &&
-        !iid.equals(Components.interfaces.nsIInterfaceRequestor) &&
-        !iid.equals(Components.interfaces.nsISupports))
-      throw Components.results.NS_ERROR_NO_INTERFACE;
-    return this;
-  }
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIRequestObserver,
+                                         Ci.nsIProgressEventSink,
+                                         Ci.nsIInterfaceRequestor])
 };
 
 /**
  * A manager for update check timers. Manages timers that fire over long
  * periods of time (e.g. days, weeks).
  * @constructor
  */
 function TimerManager() {
   getObserverService().addObserver(this, "xpcom-shutdown", false);
 
-  const nsITimer = Components.interfaces.nsITimer;
-  this._timer = Components.classes["@mozilla.org/timer;1"]
-                          .createInstance(nsITimer);
+  this._timer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
   var timerInterval = getPref("getIntPref", PREF_APP_UPDATE_TIMER, 600000);
   this._timer.initWithCallback(this, timerInterval,
-                               nsITimer.TYPE_REPEATING_SLACK);
+                               Ci.nsITimer.TYPE_REPEATING_SLACK);
 }
 TimerManager.prototype = {
   /**
    * See nsIObserver.idl
    */
   observe: function(subject, topic, data) {
     if (topic == "xpcom-shutdown") {
      getObserverService().removeObserver(this, "xpcom-shutdown");
@@ -2761,17 +2705,17 @@ TimerManager.prototype = {
       // check interval (e.g. some random slice of 10 minutes) so that when
       // the time comes to check, we offset each client request by a random
       // amount so they don't all hit at once. app.update.timer is in milliseconds,
       // whereas app.update.lastUpdateTime is in seconds
       var timerInterval = getPref("getIntPref", PREF_APP_UPDATE_TIMER, 600000);
       lastUpdateTime += Math.round(Math.random() * timerInterval / 1000);
 
       if ((now - lastUpdateTime) > timerData.interval &&
-          timerData.callback instanceof Components.interfaces.nsITimerCallback) {
+          timerData.callback instanceof Ci.nsITimerCallback) {
         timerData.callback.notify(timer);
         timerData.lastUpdateTime = now;
         var preference = PREF_APP_UPDATE_LASTUPDATETIME_FMT.replace(/%ID%/, timerID);
         gPref.setIntPref(preference, now);
       }
     }
   },
 
@@ -2788,27 +2732,22 @@ TimerManager.prototype = {
       gPref.setIntPref(preference, now);
       lastUpdateTime = now;
     }
     this._timers[id] = { callback       : callback,
                          interval       : interval,
                          lastUpdateTime : lastUpdateTime };
   },
 
-  /**
-   * See nsISupports.idl
-   */
-  QueryInterface: function(iid) {
-    if (!iid.equals(Components.interfaces.nsIUpdateTimerManager) &&
-        !iid.equals(Components.interfaces.nsITimerCallback) &&
-        !iid.equals(Components.interfaces.nsIObserver) &&
-        !iid.equals(Components.interfaces.nsISupports))
-      throw Components.results.NS_ERROR_NO_INTERFACE;
-    return this;
-  }
+  classDescription: "Timer Manager",
+  contractID: "@mozilla.org/updates/timer-manager;1",
+  classID: Components.ID("{B322A5C0-A419-484E-96BA-D7182163899F}"),
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIUpdateTimerManager,
+                                         Ci.nsITimerCallback,
+                                         Ci.nsIObserver])
 };
 
 /**
  * UpdatePrompt
  * An object which can prompt the user with information about updates, request
  * action, etc. Embedding clients can override this component with one that
  * invokes a native front end.
  * @constructor
@@ -2827,34 +2766,36 @@ UpdatePrompt.prototype = {
   /**
    * See nsIUpdateService.idl
    */
   showUpdateAvailable: function(update) {
     if (!this._enabled)
       return;
     var bundle = this._updateBundle;
     var stringsPrefix = "updateAvailable_" + update.type + ".";
-    var title = bundle.formatStringFromName(stringsPrefix + "title", [update.name], 1);
+    var title = bundle.formatStringFromName(stringsPrefix + "title",
+                                            [update.name], 1);
     var text = bundle.GetStringFromName(stringsPrefix + "text");
     var imageUrl = "";
     this._showUnobtrusiveUI(null, URI_UPDATE_PROMPT_DIALOG, null,
                            "Update:Wizard", "updatesavailable", update,
                            title, text, imageUrl);
   },
 
   /**
    * See nsIUpdateService.idl
    */
   showUpdateDownloaded: function(update, background) {
     if (background) {
       if (!this._enabled)
         return;
       var bundle = this._updateBundle;
       var stringsPrefix = "updateDownloaded_" + update.type + ".";
-      var title = bundle.formatStringFromName(stringsPrefix + "title", [update.name], 1);
+      var title = bundle.formatStringFromName(stringsPrefix + "title",
+                                              [update.name], 1);
       var text = bundle.GetStringFromName(stringsPrefix + "text");
       var imageUrl = "";
       this._showUnobtrusiveUI(null, URI_UPDATE_PROMPT_DIALOG, null,
                               "Update:Wizard", "finishedBackground", update,
                               title, text, imageUrl);
     } else {
       this._showUI(null, URI_UPDATE_PROMPT_DIALOG, null,
                    "Update:Wizard", "finishedBackground", update);
@@ -2879,19 +2820,18 @@ UpdatePrompt.prototype = {
   showUpdateError: function(update) {
     if (this._enabled) {
       // In some cases, we want to just show a simple alert dialog:
       if (update.state == STATE_FAILED && update.errorCode == WRITE_ERROR) {
         var updateBundle = this._updateBundle;
         var title = updateBundle.GetStringFromName("updaterIOErrorTitle");
         var text = updateBundle.formatStringFromName("updaterIOErrorMsg",
                                                      [gApp.name, gApp.name], 2);
-        var ww =
-            Components.classes["@mozilla.org/embedcomp/window-watcher;1"].
-            getService(Components.interfaces.nsIWindowWatcher);
+        var ww = Cc["@mozilla.org/embedcomp/window-watcher;1"].
+                 getService(Ci.nsIWindowWatcher);
         ww.getNewPrompter(null).alert(title, text);
       } else {
         this._showUI(null, URI_UPDATE_PROMPT_DIALOG, null, "Update:Wizard",
                      "errors", update);
       }
     }
   },
 
@@ -2906,19 +2846,19 @@ UpdatePrompt.prototype = {
   /**
    * Whether or not we are enabled (i.e. not in Silent mode)
    */
   get _enabled() {
     return !getPref("getBoolPref", PREF_APP_UPDATE_SILENT, false);
   },
 
   get _updateBundle() {
-    return Components.classes["@mozilla.org/intl/stringbundle;1"]
-                     .getService(Components.interfaces.nsIStringBundleService)
-                     .createBundle(URI_UPDATES_PROPERTIES);
+    return Cc["@mozilla.org/intl/stringbundle;1"].
+           getService(Ci.nsIStringBundleService).
+           createBundle(URI_UPDATES_PROPERTIES);
   },
 
   /**
    * Initiate a less obtrusive UI, starting with a non-modal notification alert
    * @param   parent
    *          A parent window, can be null
    * @param   uri
    *          The URI string of the dialog to show
@@ -2957,36 +2897,34 @@ UpdatePrompt.prototype = {
             this.timer.cancel();
             this.service.removeObserver(this, "quit-application");
             break;
         }
       }
     };
 
     try {
-      var notifier = Components.classes["@mozilla.org/alerts-service;1"]
-                               .getService(Components.interfaces.nsIAlertsService);
+      var notifier = Cc["@mozilla.org/alerts-service;1"].
+                     getService(Ci.nsIAlertsService);
       notifier.showAlertNotification(imageUrl, title, text, true, "", observer);
     }
     catch (e) {
       // Failed to retrieve alerts service, platform unsupported
       this._showUIWhenIdle(parent, uri, features, name, page, update);
       return;
     }
 
-    observer.service =
-      Components.classes["@mozilla.org/observer-service;1"]
-                .getService(Components.interfaces.nsIObserverService);
+    observer.service = Cc["@mozilla.org/observer-service;1"].
+                       getService(Ci.nsIObserverService);
     observer.service.addObserver(observer, "quit-application", false);
 
     // Give the user x seconds to react before showing the big UI
     var promptWaitTime = getPref("getIntPref", PREF_APP_UPDATE_PROMPTWAITTIME, 43200);
-    observer.timer =
-      Components.classes["@mozilla.org/timer;1"]
-                .createInstance(Components.interfaces.nsITimer);
+    observer.timer = Cc["@mozilla.org/timer;1"].
+                     createInstance(Ci.nsITimer);
     observer.timer.initWithCallback(observer, promptWaitTime * 1000,
                                     observer.timer.TYPE_ONE_SHOT);
   },
 
   /**
    * Show the UI when the user was idle
    * @param   parent
    *          A parent window, can be null
@@ -2997,27 +2935,25 @@ UpdatePrompt.prototype = {
    *          and can merely be focused
    * @param   page
    *          The page of the wizard to be displayed, if one is already open.
    * @param   update
    *          An update to pass to the UI in the window arguments.
    *          Can be null
    */
   _showUIWhenIdle: function(parent, uri, features, name, page, update) {
-    var idleService =
-      Components.classes["@mozilla.org/widget/idleservice;1"]
-                .getService(Components.interfaces.nsIIdleService);
+    var idleService = Cc["@mozilla.org/widget/idleservice;1"].
+                      getService(Ci.nsIIdleService);
 
     const IDLE_TIME = getPref("getIntPref", PREF_APP_UPDATE_IDLETIME, 60);
     if (idleService.idleTime / 1000 >= IDLE_TIME) {
       this._showUI(parent, uri, features, name, page, update);
     } else {
-      var observerService =
-        Components.classes["@mozilla.org/observer-service;1"]
-                  .getService(Components.interfaces.nsIObserverService);
+      var observerService = Cc["@mozilla.org/observer-service;1"].
+                            getService(Ci.nsIObserverService);
       var observer = {
         updatePrompt: this,
         observe: function (aSubject, aTopic, aData) {
           switch (aTopic) {
             case "idle":
               this.updatePrompt._showUI(parent, uri, features, name, page, update);
               // fall thru
             case "quit-application":
@@ -3045,176 +2981,92 @@ UpdatePrompt.prototype = {
    *          The page of the wizard to be displayed, if one is already open.
    * @param   update
    *          An update to pass to the UI in the window arguments.
    *          Can be null
    */
   _showUI: function(parent, uri, features, name, page, update) {
     var ary = null;
     if (update) {
-      ary = Components.classes["@mozilla.org/supports-array;1"]
-                      .createInstance(Components.interfaces.nsISupportsArray);
+      ary = Cc["@mozilla.org/supports-array;1"].
+            createInstance(Ci.nsISupportsArray);
       ary.AppendElement(update);
     }
 
-    var wm = Components.classes["@mozilla.org/appshell/window-mediator;1"]
-                       .getService(Components.interfaces.nsIWindowMediator);
+    var wm = Cc["@mozilla.org/appshell/window-mediator;1"].
+             getService(Ci.nsIWindowMediator);
     var win = wm.getMostRecentWindow(name);
     if (win) {
       if (page && "setCurrentPage" in win)
         win.setCurrentPage(page);
       win.focus();
     }
     else {
       var openFeatures = "chrome,centerscreen,dialog=no,resizable=no,titlebar,toolbar=no";
       if (features)
         openFeatures += "," + features;
-      var ww = Components.classes["@mozilla.org/embedcomp/window-watcher;1"]
-                         .getService(Components.interfaces.nsIWindowWatcher);
+      var ww = Cc["@mozilla.org/embedcomp/window-watcher;1"].
+               getService(Ci.nsIWindowWatcher);
       ww.openWindow(parent, uri, "", openFeatures, ary);
     }
   },
 
-  /**
-   * See nsISupports.idl
-   */
-  QueryInterface: function(iid) {
-    if (!iid.equals(Components.interfaces.nsIUpdatePrompt) &&
-        !iid.equals(Components.interfaces.nsISupports))
-      throw Components.results.NS_ERROR_NO_INTERFACE;
-    return this;
-  }
+  classDescription: "Update Prompt",
+  contractID: "@mozilla.org/updates/update-prompt;1",
+  classID: Components.ID("{27ABA825-35B5-4018-9FDD-F99250A0E722}"),
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIUpdatePrompt])
 };
 
-var gModule = {
-  registerSelf: function(componentManager, fileSpec, location, type) {
-    componentManager = componentManager.QueryInterface(Components.interfaces.nsIComponentRegistrar);
-
-    for (var key in this._objects) {
-      var obj = this._objects[key];
-      componentManager.registerFactoryLocation(obj.CID, obj.className, obj.contractID,
-                                               fileSpec, location, type);
-    }
-
-    // Make the Update Service a startup observer
-    var categoryManager = Components.classes["@mozilla.org/categorymanager;1"]
-                                    .getService(Components.interfaces.nsICategoryManager);
-    categoryManager.addCategoryEntry("app-startup", this._objects.service.className,
-                                     "service," + this._objects.service.contractID,
-                                     true, true);
-  },
-
-  getClassObject: function(componentManager, cid, iid) {
-    if (!iid.equals(Components.interfaces.nsIFactory))
-      throw Components.results.NS_ERROR_NOT_IMPLEMENTED;
-
-    for (var key in this._objects) {
-      if (cid.equals(this._objects[key].CID))
-        return this._objects[key].factory;
-    }
-
-    throw Components.results.NS_ERROR_NO_INTERFACE;
-  },
-
-  _objects: {
-    service: { CID        : Components.ID("{B3C290A6-3943-4B89-8BBE-C01EB7B3B311}"),
-               contractID : "@mozilla.org/updates/update-service;1",
-               className  : "Update Service",
-               factory    : makeFactory(UpdateService)
-             },
-    checker: { CID        : Components.ID("{898CDC9B-E43F-422F-9CC4-2F6291B415A3}"),
-               contractID : "@mozilla.org/updates/update-checker;1",
-               className  : "Update Checker",
-               factory    : makeFactory(Checker)
-             },
-    prompt:  { CID        : Components.ID("{27ABA825-35B5-4018-9FDD-F99250A0E722}"),
-               contractID : "@mozilla.org/updates/update-prompt;1",
-               className  : "Update Prompt",
-               factory    : makeFactory(UpdatePrompt)
-             },
-    timers:  { CID        : Components.ID("{B322A5C0-A419-484E-96BA-D7182163899F}"),
-               contractID : "@mozilla.org/updates/timer-manager;1",
-               className  : "Timer Manager",
-               factory    : makeFactory(TimerManager)
-             },
-    manager: { CID        : Components.ID("{093C2356-4843-4C65-8709-D7DBCBBE7DFB}"),
-               contractID : "@mozilla.org/updates/update-manager;1",
-               className  : "Update Manager",
-               factory    : makeFactory(UpdateManager)
-             },
-  },
-
-  canUnload: function(componentManager) {
-    return true;
-  }
-};
-
-/**
- * Creates a factory for instances of an object created using the passed-in
- * constructor.
- */
-function makeFactory(ctor) {
-  function ci(outer, iid) {
-    if (outer != null)
-      throw Components.results.NS_ERROR_NO_AGGREGATION;
-    return (new ctor()).QueryInterface(iid);
-  }
-  return { createInstance: ci };
-}
-
-function NSGetModule(compMgr, fileSpec) {
-  return gModule;
-}
+function NSGetModule(compMgr, fileSpec)
+  XPCOMUtils.generateModule([UpdateService, Checker, UpdatePrompt, TimerManager, UpdateManager]);
 
 /**
  * Determines whether or there are installed addons which are incompatible
  * with this update.
  * @param   update
  *          The update to check compatibility against
  * @returns true if there are no addons installed that are incompatible with
  *          the specified update, false otherwise.
  */
 function isCompatible(update) {
-  var em =
-      Components.classes["@mozilla.org/extensions/manager;1"].
-      getService(nsIExtensionManager);
+  var em = Cc["@mozilla.org/extensions/manager;1"].
+           getService(Ci.nsIExtensionManager);
   var items = em.getIncompatibleItemList("", update.extensionVersion,
-    update.platformVersion, nsIUpdateItem.TYPE_ANY, false, { });
+                                         update.platformVersion,
+                                         Ci.nsIUpdateItem.TYPE_ANY, false, { });
   return items.length == 0;
 }
 
 /**
  * Shows a prompt for an update, provided there are no incompatible addons.
  * If there are, kick off an update check and see if updates are available
  * that will resolve the incompatibilities.
  * @param   update
  *          The available update to show
  */
 function showPromptIfNoIncompatibilities(update) {
   function showPrompt(update) {
     LOG("UpdateService", "_selectAndInstallUpdate: need to prompt user before continuing...");
-    var prompter =
-        Components.classes["@mozilla.org/updates/update-prompt;1"].
-        createInstance(Components.interfaces.nsIUpdatePrompt);
+    var prompter = Cc["@mozilla.org/updates/update-prompt;1"].
+                   createInstance(Ci.nsIUpdatePrompt);
     prompter.showUpdateAvailable(update);
   }
 
   /**
    * Determines if an addon is compatible with a particular update.
    * @param   addon
    *          The addon to check
    * @param   version
    *          The extensionVersion of the update to check for compatibility
    *          against.
    * @returns true if the addon is compatible, false otherwise
    */
   function addonIsCompatible(addon, version) {
-    var vc =
-        Components.classes["@mozilla.org/xpcom/version-comparator;1"].
-        getService(Components.interfaces.nsIVersionComparator);
+    var vc = Cc["@mozilla.org/xpcom/version-comparator;1"].
+             getService(Ci.nsIVersionComparator);
     return (vc.compare(version, addon.minAppVersion) >= 0) &&
            (vc.compare(version, addon.maxAppVersion) <= 0);
   }
 
   /**
    * An object implementing nsIAddonUpdateCheckListener that looks for
    * available updates to addons and if updates are found that will make the
    * user's installed addon set compatible with the update, suppresses the
@@ -3251,59 +3103,53 @@ function showPromptIfNoIncompatibilities
       //      suppresses most prompt dialogs.
       // UPDATE_CHECK_COMPATIBILITY    We count only VersionInfo updates
       //      against the list of incompatible addons installed - i.e. if the
       //      situation above with Foo 1.2 and available update to 2.0
       //      applies, we DO show the prompt since a download operation will
       //      be required after the update. This is not the default and is
       //      supplied only as a hidden option for those that want it.
       var mode = getPref("getIntPref", PREF_APP_UPDATE_INCOMPATIBLE_MODE,
-                         nsIExtensionManager.UPDATE_CHECK_NEWVERSION);
-      if ((mode == nsIExtensionManager.UPDATE_CHECK_NEWVERSION
+                         Ci.nsIExtensionManager.UPDATE_CHECK_NEWVERSION);
+      if ((mode == Ci.nsIExtensionManager.UPDATE_CHECK_NEWVERSION
            && this._addons.length) || !isCompatible(update))
         showPrompt(update);
     },
     onAddonUpdateStarted: function(addon) {
     },
     onAddonUpdateEnded: function(addon, status) {
-      const Ci = Components.interfaces;
       if (status != Ci.nsIAddonUpdateCheckListener.STATUS_UPDATE)
         return;
 
       var reqVersion = addon.targetAppID == TOOLKIT_ID ?
                        update.platformVersion :
                        update.extensionVersion;
       if (!addonIsCompatible(addon, reqVersion))
         return;
 
       for (var i = 0; i < this._addons.length; ++i) {
         if (this._addons[i] == addon) {
           this._addons.splice(i, 1);
           break;
         }
       }
     },
-    /**
-     * See nsISupports.idl
-     */
-    QueryInterface: function(iid) {
-      if (!iid.equals(Components.interfaces.nsIAddonUpdateCheckListener) &&
-          !iid.equals(Components.interfaces.nsISupports))
-        throw Components.results.NS_ERROR_NO_INTERFACE;
-      return this;
-    }
+
+    QueryInterface: XPCOMUtils.generateQI([Ci.nsIAddonUpdateCheckListener])
   };
 
   if (!isCompatible(update)) {
-    var em =
-        Components.classes["@mozilla.org/extensions/manager;1"].
-        getService(nsIExtensionManager);
+    var em = Cc["@mozilla.org/extensions/manager;1"].
+             getService(Ci.nsIExtensionManager);
     var items = em.getIncompatibleItemList("", update.extensionVersion,
-      update.platformVersion, nsIUpdateItem.TYPE_ANY, false, { });
+                                           update.platformVersion,
+                                           Ci.nsIUpdateItem.TYPE_ANY, false,
+                                           { });
+
     var listener = new Listener(items);
     // See documentation on |mode| above.
     var mode = getPref("getIntPref", PREF_APP_UPDATE_INCOMPATIBLE_MODE,
-                       nsIExtensionManager.UPDATE_CHECK_NEWVERSION);
+                       Ci.nsIExtensionManager.UPDATE_CHECK_NEWVERSION);
     em.update([], 0, mode, listener);
   }
   else
     showPrompt(update);
 }
diff -r b7bcdd009540 toolkit/mozapps/update/test/unit/data/aus-0110_general-1.mar
Binary file toolkit/mozapps/update/test/unit/data/aus-0110_general-1.mar has changed
diff -r b7bcdd009540 toolkit/mozapps/update/test/unit/data/aus-0110_general-1.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/mozapps/update/test/unit/data/aus-0110_general-1.xml	Thu Sep 11 15:19:27 2008 +0300
@@ -0,0 +1,6 @@
+<?xml version="1.0"?>
+<updates>
+  <update type="major" version="4.0" extensionVersion="4.0" buildID="20080811053724" licenseURL="http://dummylicense" detailsURL="http://dummydetails/">
+    <patch type="complete" URL="http://localhost:4444/data/aus-0110_general-1.mar" hashFunction="SHA1" hashValue="246522844a98564e831d89b8c9243efca90f687e" size="1444"/>
+  </update>
+</updates>
diff -r b7bcdd009540 toolkit/mozapps/update/test/unit/data/aus-0110_general-2.mar
Binary file toolkit/mozapps/update/test/unit/data/aus-0110_general-2.mar has changed
diff -r b7bcdd009540 toolkit/mozapps/update/test/unit/data/aus-0110_general-2.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/mozapps/update/test/unit/data/aus-0110_general-2.xml	Thu Sep 11 15:19:27 2008 +0300
@@ -0,0 +1,6 @@
+<?xml version="1.0"?>
+<updates>
+  <update type="major" version="4.0" extensionVersion="4.0" buildID="20080811053724" licenseURL="http://dummylicense" detailsURL="http://dummydetails/">
+    <patch type="partial" URL="http://localhost:4444/data/aus-0110_general-2.mar" hashFunction="SHA1" hashValue="62eeb2a3b4d0c46589400dd8e6806f707da05c3e" size="1255"/>
+  </update>
+</updates>
diff -r b7bcdd009540 toolkit/mozapps/update/test/unit/data/aus-0110_general_ref_image1.png
Binary file toolkit/mozapps/update/test/unit/data/aus-0110_general_ref_image1.png has changed
diff -r b7bcdd009540 toolkit/mozapps/update/test/unit/data/aus-0110_general_ref_image2.png
Binary file toolkit/mozapps/update/test/unit/data/aus-0110_general_ref_image2.png has changed
diff -r b7bcdd009540 toolkit/mozapps/update/test/unit/head_update.js
--- a/toolkit/mozapps/update/test/unit/head_update.js	Mon Sep 08 00:36:19 2008 -0700
+++ b/toolkit/mozapps/update/test/unit/head_update.js	Thu Sep 11 15:19:27 2008 +0300
@@ -191,19 +191,56 @@ function remove_dirs_and_files () {
   if (file.exists())
     file.remove(false);
 
   file = dir.clone();
   file.append("updates.xml");
   if (file.exists())
     file.remove(false);
 
+  file = dir.clone();
+  file.append("updates");
+  file.append("last-update.log");
+  try {
+    if (file.exists())
+      file.remove(false);
+  }
+  catch (e) {
+  }
+
+  file = dir.clone();
+  file.append("updates");
+  file.append("0");
+  file.append("update.mar");
+  try {
+    if (file.exists())
+      file.remove(false);
+  }
+  catch (e) {
+  }
+
+  file = dir.clone();
+  file.append("updates");
+  file.append("0");
+  file.append("update.status");
+  try {
+    if (file.exists())
+      file.remove(false);
+  }
+  catch (e) {
+  }
+
+  // This fails sporadically on Mac OS X so wrap it in a try catch
   dir.append("updates");
-  if (dir.exists())
-    dir.remove(true);
+  try {
+    if (dir.exists())
+      dir.remove(true);
+  }
+  catch (e) {
+  }
 }
 
 /**
  * Helper for starting the http server used by the tests
  * @param   aRelativeDirName
  *          The directory name to register relative to
  *          toolkit/mozapps/update/test/unit/
  */
diff -r b7bcdd009540 toolkit/mozapps/update/test/unit/test_0110_general.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/mozapps/update/test/unit/test_0110_general.js	Thu Sep 11 15:19:27 2008 +0300
@@ -0,0 +1,296 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Application Update Service.
+ *
+ * The Initial Developer of the Original Code is
+ * Robert Strong <robert.bugzilla@gmail.com>.
+ *
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Mozilla Foundation <http://www.mozilla.org/>. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK *****
+ */
+
+/* General MAR File Tests */
+
+const DIR_DATA = "data"
+const URL_PREFIX = "http://localhost:4444/" + DIR_DATA + "/";
+
+const PREF_APP_UPDATE_URL_OVERRIDE = "app.update.url.override";
+
+var gUpdates;
+var gUpdateCount;
+var gStatus;
+var gExpectedStatus;
+var gCheckFunc;
+var gNextRunFunc;
+
+var gTestDir;
+var gUpdater;
+var gUpdatesDir;
+var gUpdatesDirPath;
+
+function run_test() {
+  do_test_pending();
+
+  var fileLocator = AUS_Cc["@mozilla.org/file/directory_service;1"]
+                      .getService(AUS_Ci.nsIProperties);
+
+  // The directory the updates will be applied to is the current working
+  // directory (e.g. obj-dir/toolkit/mozapps/update/test) and not dist/bin
+  gTestDir = fileLocator.get("CurWorkD", AUS_Ci.nsIFile);
+  // The mar files were created with all files in a subdirectory named
+  // mar_test... clear it out of the way if it exists and recreate it.
+  gTestDir.append("mar_test");
+  if (gTestDir.exists())
+    gTestDir.remove(true);
+  gTestDir.create(AUS_Ci.nsIFile.DIRECTORY_TYPE, 0755);
+
+  // Create an empty test file to test the complete mar's ability to replace an
+  // existing file.
+  var testFile = gTestDir.clone();
+  testFile.append("text1");
+  testFile.create(AUS_Ci.nsIFile.NORMAL_FILE_TYPE, 0644);
+
+  var binDir = fileLocator.get("XCurProcD", AUS_Ci.nsIFile);
+
+  // The updater binary file
+  gUpdater = binDir.clone();
+  gUpdater.append("updater.app");
+  if (!gUpdater.exists()) {
+    gUpdater = binDir.clone();
+    gUpdater.append("updater.exe");
+    if (!gUpdater.exists()) {
+      gUpdater = binDir.clone();
+      gUpdater.append("updater");
+      if (!gUpdater.exists()) {
+        do_throw("Unable to find updater binary!");
+      }
+    }
+  }
+
+  // The dir where the mar file is located
+  gUpdatesDir = binDir.clone();
+  gUpdatesDir.append("updates");
+  gUpdatesDir.append("0");
+
+  // Quoted path to the dir where the mar file is located
+  gUpdatesDirPath = gUpdatesDir.path;
+  if (/ /.test(gUpdatesDirPath))
+    gUpdatesDirPath = '"' + gUpdatesDirPath + '"';
+
+  startAUS();
+  start_httpserver(DIR_DATA);
+  do_timeout(0, "run_test_pt1()");
+}
+
+function end_test() {
+  stop_httpserver();
+  if (gTestDir.exists())
+    gTestDir.remove(true);
+  do_test_finished();
+}
+
+// Helper functions for testing mar downloads that have the correct size
+// specified in the update xml.
+function run_test_helper(aUpdateXML, aMsg, aResult, aNextRunFunc) {
+  gUpdates = null;
+  gUpdateCount = null;
+  gStatus = null;
+  gCheckFunc = check_test_helper_pt1;
+  gNextRunFunc = aNextRunFunc;
+  gExpectedStatus = aResult;
+  var url = URL_PREFIX + aUpdateXML;
+  dump("Testing: " + aMsg + " - " + url + "\n");
+  gPrefs.setCharPref(PREF_APP_UPDATE_URL_OVERRIDE, url);
+  gUpdateChecker.checkForUpdates(updateCheckListener, true);
+}
+
+function check_test_helper_pt1() {
+  do_check_eq(gUpdateCount, 1);
+  gCheckFunc = check_test_helper_pt2;
+  var bestUpdate = gAUS.selectUpdate(gUpdates, gUpdateCount);
+  var state = gAUS.downloadUpdate(bestUpdate, false);
+  if (state == "null" || state == "failed")
+    do_throw("nsIApplicationUpdateService:downloadUpdate returned " + state);
+  gAUS.addDownloadListener(downloadListener);
+}
+
+function check_test_helper_pt2() {
+  do_check_eq(gStatus, gExpectedStatus);
+  gAUS.removeDownloadListener(downloadListener);
+  gNextRunFunc();
+}
+
+// Launches the updater binary to apply a mar file
+function runUpdate() {
+  // Copy the updater binary to the update directory so the updater.ini is not
+  // in the same directory as it is. This prevents ui from displaying and the
+  // PostUpdate executable which is defined in the updater.ini from launching.
+  gUpdater.copyTo(gUpdatesDir, gUpdater.leafName);
+  var updateBin = gUpdatesDir.clone();
+  updateBin.append(gUpdater.leafName);
+  if (updateBin.leafName == "updater.app") {
+    updateBin.append("Contents");
+    updateBin.append("MacOS");
+    updateBin.append("updater");
+    if (!updateBin.exists())
+      do_throw("Unable to find the updater executable!");
+  }
+
+  var process = AUS_Cc["@mozilla.org/process/util;1"]
+                  .createInstance(AUS_Ci.nsIProcess);
+  process.init(updateBin);
+  var args = [gUpdatesDirPath];
+  process.run(true, args, args.length);
+  return process.exitValue;
+}
+
+// Gets a file in the directory (the current working directory) where the mar
+// will be applied.
+function getTestFile(leafName) {
+  var file = gTestDir.clone();
+  file.append(leafName);
+  if (!(file instanceof AUS_Ci.nsILocalFile))
+    do_throw("File must be a nsILocalFile for this test! File: " + leafName);
+
+  return file;
+}
+
+// Returns the binary contents of a file
+function getFileBytes(file) {
+  var fis = AUS_Cc["@mozilla.org/network/file-input-stream;1"]
+              .createInstance(AUS_Ci.nsIFileInputStream);
+  fis.init(file, -1, -1, false);
+  var bis = AUS_Cc["@mozilla.org/binaryinputstream;1"]
+              .createInstance(AUS_Ci.nsIBinaryInputStream);
+  bis.setInputStream(fis);
+  var data = bis.readBytes(bis.available());
+  bis.close();
+  fis.close();
+  return data;
+}
+
+// applying a complete mar and replacing an existing file
+function run_test_pt1() {
+  run_test_helper("aus-0110_general-1.xml", "applying a complete mar",
+                  AUS_Cr.NS_OK, run_test_pt2);
+}
+
+// apply the complete mar and check the innards of the files
+function run_test_pt2() {
+  var exitValue = runUpdate();
+  do_check_eq(exitValue, 0);
+
+  dump("Testing: contents of files added\n");
+  do_check_eq(getFileBytes(getTestFile("text1")), "ToBeModified\n");
+  do_check_eq(getFileBytes(getTestFile("text2")), "ToBeDeleted\n");
+
+  var refImage = do_get_file("toolkit/mozapps/update/test/unit/data/aus-0110_general_ref_image1.png");
+  var srcImage = getTestFile("image1.png");
+  do_check_eq(getFileBytes(srcImage), getFileBytes(refImage));
+
+  remove_dirs_and_files();
+  run_test_pt3();
+}
+
+// applying a partial mar and remove an existing file
+function run_test_pt3() {
+  run_test_helper("aus-0110_general-2.xml", "applying a partial mar",
+                  AUS_Cr.NS_OK, run_test_pt4);
+}
+
+// apply the partial mar and check the innards of the files
+function run_test_pt4() {
+  var exitValue = runUpdate();
+  do_check_eq(exitValue, 0);
+
+  dump("Testing: removal of a file and contents of added / modified files\n");
+  do_check_eq(getFileBytes(getTestFile("text1")), "Modified\n");
+  do_check_false(getTestFile("text2").exists()); // file removed
+  do_check_eq(getFileBytes(getTestFile("text3")), "Added\n");
+
+  var refImage = do_get_file("toolkit/mozapps/update/test/unit/data/aus-0110_general_ref_image2.png");
+  var srcImage = getTestFile("image1.png");
+  do_check_eq(getFileBytes(srcImage), getFileBytes(refImage));
+
+  end_test();
+}
+
+// Update check listener
+const updateCheckListener = {
+  onProgress: function(request, position, totalSize) {
+  },
+
+  onCheckComplete: function(request, updates, updateCount) {
+    gUpdateCount = updateCount;
+    gUpdates = updates;
+    dump("onCheckComplete url = " + request.channel.originalURI.spec + "\n\n");
+    // Use a timeout to allow the XHR to complete
+    do_timeout(0, "gCheckFunc()");
+  },
+
+  onError: function(request, update) {
+    dump("onError url = " + request.channel.originalURI.spec + "\n\n");
+    // Use a timeout to allow the XHR to complete
+    do_timeout(0, "gCheckFunc()");
+  },
+
+  QueryInterface: function(aIID) {
+    if (!aIID.equals(AUS_Ci.nsIUpdateCheckListener) &&
+        !aIID.equals(AUS_Ci.nsISupports))
+      throw AUS_Cr.NS_ERROR_NO_INTERFACE;
+    return this;
+  }
+};
+
+/* Update download listener - nsIRequestObserver */
+const downloadListener = {
+  onStartRequest: function(request, context) {
+  },
+
+  onProgress: function(request, context, progress, maxProgress) {
+  },
+
+  onStatus: function(request, context, status, statusText) {
+  },
+
+  onStopRequest: function(request, context, status) {
+    gStatus = status;
+    // Use a timeout to allow the request to complete
+    do_timeout(0, "gCheckFunc()");
+  },
+
+  QueryInterface: function(iid) {
+    if (!iid.equals(AUS_Ci.nsIRequestObserver) &&
+        !iid.equals(AUS_Ci.nsIProgressEventSink) &&
+        !iid.equals(AUS_Ci.nsISupports))
+      throw AUS_Cr.NS_ERROR_NO_INTERFACE;
+    return this;
+  }
+};
diff -r b7bcdd009540 toolkit/themes/pinstripe/Makefile.in
--- a/toolkit/themes/pinstripe/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/toolkit/themes/pinstripe/Makefile.in	Thu Sep 11 15:19:27 2008 +0300
@@ -43,13 +43,13 @@ include $(DEPTH)/config/autoconf.mk
 include $(DEPTH)/config/autoconf.mk
 
 DIRS	= global mozapps
 
 ifdef MOZ_HELP_VIEWER
 DIRS	+= help
 endif
 
-ifdef MOZ_MOCHITEST
+ifdef ENABLE_TESTS
 DIRS  += tests
 endif
 
 include $(topsrcdir)/config/rules.mk
diff -r b7bcdd009540 toolkit/themes/winstripe/global/about.css
--- a/toolkit/themes/winstripe/global/about.css	Mon Sep 08 00:36:19 2008 -0700
+++ b/toolkit/themes/winstripe/global/about.css	Thu Sep 11 15:19:27 2008 +0300
@@ -1,33 +1,29 @@ html {
 html {
   background: -moz-Dialog;
+  padding: 0 1em;
+  font: message-box;
 }
 
 body {
-  margin: 0;
-  padding: 0 1em;
   color: -moz-FieldText;
-  font: message-box;
-}
-
-#aboutPageContainer {
   position: relative;
   min-width: 330px;
   max-width: 50em;
   margin: 4em auto;
   border: 1px solid ThreeDShadow;
   -moz-border-radius: 10px;
   padding: 3em;
   -moz-padding-start: 30px;
   background: -moz-Field;
 }
 
 .aboutPageWideContainer {
-  max-width: 80% !important;
+  max-width: 80%;
 }
 
 #aboutLogoContainer {
   border: 1px solid ThreeDLightShadow;
   width: 300px;
   margin-bottom: 2em;
 }
 
@@ -46,8 +42,12 @@ ul {
   -moz-margin-start: 1.5em;
   padding: 0;
   list-style: square;
 }
 
 ul > li {
   margin-top: .5em;
 }
+
+th, td {
+  padding: 0 5px;
+}
diff -r b7bcdd009540 toolkit/toolkit-makefiles.sh
--- a/toolkit/toolkit-makefiles.sh	Mon Sep 08 00:36:19 2008 -0700
+++ b/toolkit/toolkit-makefiles.sh	Thu Sep 11 15:19:27 2008 +0300
@@ -665,19 +665,16 @@ MAKEFILES_xulapp="
   toolkit/components/downloads/src/Makefile
   toolkit/components/filepicker/Makefile
   toolkit/components/filepicker/public/Makefile
   toolkit/components/filepicker/src/Makefile
   toolkit/system/gnome/Makefile
   toolkit/system/unixproxy/Makefile
   toolkit/system/osxproxy/Makefile
   toolkit/components/help/Makefile
-  toolkit/components/history/Makefile
-  toolkit/components/history/public/Makefile
-  toolkit/components/history/src/Makefile
   toolkit/components/passwordmgr/Makefile
   toolkit/components/passwordmgr/public/Makefile
   toolkit/components/passwordmgr/src/Makefile
   toolkit/components/passwordmgr/content/Makefile
   toolkit/components/passwordmgr/test/Makefile
   toolkit/components/places/Makefile
   toolkit/components/places/public/Makefile
   toolkit/components/places/src/Makefile
diff -r b7bcdd009540 toolkit/toolkit-tiers.mk
--- a/toolkit/toolkit-tiers.mk	Mon Sep 08 00:36:19 2008 -0700
+++ b/toolkit/toolkit-tiers.mk	Thu Sep 11 15:19:27 2008 +0300
@@ -263,11 +263,11 @@ ifdef MOZ_LEAKY
 ifdef MOZ_LEAKY
 tier_toolkit_dirs        += tools/leaky
 endif
 
 ifdef MOZ_MAPINFO
 tier_toolkit_dirs	+= tools/codesighs
 endif
 
-ifdef MOZ_MOCHITEST
+ifdef ENABLE_TESTS
 tier_toolkit_dirs	+= testing/mochitest
 endif
diff -r b7bcdd009540 uriloader/base/nsDocLoader.cpp
--- a/uriloader/base/nsDocLoader.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/uriloader/base/nsDocLoader.cpp	Thu Sep 11 15:19:27 2008 +0300
@@ -214,18 +214,18 @@ nsDocLoader::~nsDocLoader()
     PL_DHashTableFinish(&mRequestInfoHash);
   }
 }
 
 
 /*
  * Implementation of ISupports methods...
  */
-NS_IMPL_THREADSAFE_ADDREF(nsDocLoader)
-NS_IMPL_THREADSAFE_RELEASE(nsDocLoader)
+NS_IMPL_ADDREF(nsDocLoader)
+NS_IMPL_RELEASE(nsDocLoader)
 
 NS_INTERFACE_MAP_BEGIN(nsDocLoader)
    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIRequestObserver)
    NS_INTERFACE_MAP_ENTRY(nsIRequestObserver)
    NS_INTERFACE_MAP_ENTRY(nsIDocumentLoader)
    NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
    NS_INTERFACE_MAP_ENTRY(nsIWebProgress)
    NS_INTERFACE_MAP_ENTRY(nsIProgressEventSink)   
diff -r b7bcdd009540 uriloader/exthandler/nsHandlerService.js
--- a/uriloader/exthandler/nsHandlerService.js	Mon Sep 08 00:36:19 2008 -0700
+++ b/uriloader/exthandler/nsHandlerService.js	Thu Sep 11 15:19:27 2008 +0300
@@ -91,16 +91,27 @@ const NC_PRETTY_NAME        = NC_NS + "p
 const NC_PRETTY_NAME        = NC_NS + "prettyName";
 
 // nsILocalHandlerApp::executable
 const NC_PATH               = NC_NS + "path";
 
 // nsIWebHandlerApp::uriTemplate
 const NC_URI_TEMPLATE       = NC_NS + "uriTemplate";
 
+// nsIDBusHandlerApp::service
+const NC_SERVICE            = NC_NS + "service";
+
+// nsIDBusHandlerApp::method
+const NC_METHOD             = NC_NS + "method";
+
+// nsIDBusHandlerApp::objectPath
+const NC_OBJPATH            = NC_NS + "objectPath";
+
+// nsIDBusHandlerApp::dbusInterface
+const NC_INTERFACE            = NC_NS + "dBusInterface";
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
 
 function HandlerService() {
   this._init();
 }
 
@@ -561,16 +572,41 @@ HandlerService.prototype = {
       let uriTemplate = this._getValue(aHandlerAppID, NC_URI_TEMPLATE);
       if (!uriTemplate)
         return null;
 
       handlerApp = Cc["@mozilla.org/uriloader/web-handler-app;1"].
                    createInstance(Ci.nsIWebHandlerApp);
       handlerApp.uriTemplate = uriTemplate;
     }
+    else if (this._hasValue(aHandlerAppID, NC_SERVICE)) {
+      let service = this._getValue(aHandlerAppID, NC_SERVICE);
+      if (!service)
+        return null;
+      
+      let method = this._getValue(aHandlerAppID, NC_METHOD);
+      if (!method)
+        return null;
+      
+      let objpath = this._getValue(aHandlerAppID, NC_OBJPATH);
+      if (!objpath)
+        return null;
+      
+      let interface = this._getValue(aHandlerAppID, NC_INTERFACE);
+      if (!interface)
+        return null;
+      
+      handlerApp = Cc["@mozilla.org/uriloader/dbus-handler-app;1"].
+                   createInstance(Ci.nsIDBusHandlerApp);
+      handlerApp.service   = service;
+      handlerApp.method    = method;
+      handlerApp.objectPath   = objpath;
+      handlerApp.dBusInterface = interface;
+      
+    }
     else
       return null;
 
     handlerApp.name = this._getValue(aHandlerAppID, NC_PRETTY_NAME);
 
     return handlerApp;
   },
 
@@ -766,25 +802,38 @@ HandlerService.prototype = {
     // used to refer to a different kind of handler in the past (i.e. either
     // a local hander or a web handler), so if the new handler is a local
     // handler, then we remove any web handler properties and vice versa.
     // This is unnecessary but harmless for possible handlers.
 
     if (aHandlerApp instanceof Ci.nsILocalHandlerApp) {
       this._setLiteral(aHandlerAppID, NC_PATH, aHandlerApp.executable.path);
       this._removeTarget(aHandlerAppID, NC_URI_TEMPLATE);
+      this._removeTarget(aHandlerAppID, NC_METHOD);
+      this._removeTarget(aHandlerAppID, NC_SERVICE);
+      this._removeTarget(aHandlerAppID, NC_OBJPATH);
+      this._removeTarget(aHandlerAppID, NC_INTERFACE);
     }
     else if(aHandlerApp instanceof Ci.nsIWebHandlerApp){
       aHandlerApp.QueryInterface(Ci.nsIWebHandlerApp);
       this._setLiteral(aHandlerAppID, NC_URI_TEMPLATE, aHandlerApp.uriTemplate);
       this._removeTarget(aHandlerAppID, NC_PATH);
+      this._removeTarget(aHandlerAppID, NC_METHOD);
+      this._removeTarget(aHandlerAppID, NC_SERVICE);
+      this._removeTarget(aHandlerAppID, NC_OBJPATH);
+      this._removeTarget(aHandlerAppID, NC_INTERFACE);
     }
     else if(aHandlerApp instanceof Ci.nsIDBusHandlerApp){
       aHandlerApp.QueryInterface(Ci.nsIDBusHandlerApp);
-      
+      this._setLiteral(aHandlerAppID, NC_SERVICE, aHandlerApp.service);
+      this._setLiteral(aHandlerAppID, NC_METHOD, aHandlerApp.method);
+      this._setLiteral(aHandlerAppID, NC_OBJPATH, aHandlerApp.objectPath);
+      this._setLiteral(aHandlerAppID, NC_INTERFACE, aHandlerApp.dBusInterface);
+      this._removeTarget(aHandlerAppID, NC_PATH);
+      this._removeTarget(aHandlerAppID, NC_URI_TEMPLATE);
     }
     else {
 	throw "unknown handler type";
     }
 	
   },
 
   _storeAlwaysAsk: function HS__storeAlwaysAsk(aHandlerInfo) {
diff -r b7bcdd009540 uriloader/exthandler/unix/nsMIMEInfoUnix.cpp
--- a/uriloader/exthandler/unix/nsMIMEInfoUnix.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/uriloader/exthandler/unix/nsMIMEInfoUnix.cpp	Thu Sep 11 15:19:27 2008 +0300
@@ -32,40 +32,72 @@
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
+#ifdef MOZ_PLATFORM_HILDON
+#include <glib.h>
+#include <hildon-uri.h>
+#endif
+
+
 #include "nsMIMEInfoUnix.h"
 #include "nsGNOMERegistry.h"
 #include "nsIGnomeVFSService.h"
+#ifdef MOZ_ENABLE_DBUS
+#include "nsDBusHandlerApp.h"
+#endif
+
 
 nsresult
 nsMIMEInfoUnix::LoadUriInternal(nsIURI * aURI)
-{
-  return nsGNOMERegistry::LoadURL(aURI);
+{ 
+  nsresult rv = nsGNOMERegistry::LoadURL(aURI);
+#ifdef MOZ_PLATFORM_HILDON
+  if (NS_FAILED(rv)){
+    HildonURIAction *action = hildon_uri_get_default_action(mType.get(), nsnull);
+    if (action) {
+      nsCAutoString spec;
+      aURI->GetAsciiSpec(spec);
+      if (hildon_uri_open(spec.get(), action, nsnull))
+        rv = NS_OK;
+      hildon_uri_action_unref(action);
+    }
+  }
+#endif
+  return rv;
 }
 
 NS_IMETHODIMP
 nsMIMEInfoUnix::GetHasDefaultHandler(PRBool *_retval)
 {
   *_retval = PR_FALSE;
   nsCOMPtr<nsIGnomeVFSService> vfs = do_GetService(NS_GNOMEVFSSERVICE_CONTRACTID);
   if (vfs) {
     nsCOMPtr<nsIGnomeVFSMimeApp> app;
     if (NS_SUCCEEDED(vfs->GetAppForMimeType(mType, getter_AddRefs(app))) && app)
       *_retval = PR_TRUE;
   }
 
   if (*_retval)
     return NS_OK;
 
+#ifdef MOZ_PLATFORM_HILDON
+  HildonURIAction *action = hildon_uri_get_default_action(mType.get(), nsnull);
+  if (action) {
+    *_retval = PR_TRUE;
+    hildon_uri_action_unref(action);
+    return NS_OK;
+  }
+#endif
+  
   // If we didn't find a VFS handler, fallback.
   return nsMIMEInfoImpl::GetHasDefaultHandler(_retval);
 }
 
 nsresult
 nsMIMEInfoUnix::LaunchDefaultWithFile(nsIFile *aFile)
 {
   nsCAutoString nativePath;
@@ -79,8 +111,61 @@ nsMIMEInfoUnix::LaunchDefaultWithFile(ns
       return app->Launch(nativePath);
   }
 
   if (!mDefaultApplication)
     return NS_ERROR_FILE_NOT_FOUND;
 
   return LaunchWithIProcess(mDefaultApplication, nativePath);
 }
+
+#ifdef MOZ_PLATFORM_HILDON
+
+NS_IMETHODIMP
+nsMIMEInfoUnix::GetPossibleApplicationHandlers(nsIMutableArray ** aPossibleAppHandlers)
+{
+  if (!mPossibleApplications) {
+    mPossibleApplications = do_CreateInstance(NS_ARRAY_CONTRACTID);
+    
+    if (!mPossibleApplications)
+      return NS_ERROR_OUT_OF_MEMORY;
+    
+    GSList *actions = hildon_uri_get_actions(mType.get(), nsnull);
+    GSList *actionsPtr = actions;
+    while (actionsPtr) {
+      HildonURIAction *action = (HildonURIAction*)actionsPtr->data;
+      actionsPtr = actionsPtr->next;
+      nsDBusHandlerApp* app = new nsDBusHandlerApp();
+      if (!app){
+        hildon_uri_free_actions(actions);
+        return NS_ERROR_OUT_OF_MEMORY;
+      }
+      nsDependentCString method(hildon_uri_action_get_method(action));
+      nsDependentCString key(hildon_uri_action_get_service(action));
+      nsCString service, objpath, interface;
+      app->SetMethod(method);
+      app->SetName(NS_ConvertUTF8toUTF16(key));
+      
+      if (key.FindChar('.', 0) > 0) {
+        service.Assign(key);
+        objpath.Assign(NS_LITERAL_CSTRING("/")+ key);
+        objpath.ReplaceChar('.', '/');
+        interface.Assign(key);
+      } else {
+        service.Assign(NS_LITERAL_CSTRING("com.nokia.")+ key);
+        objpath.Assign(NS_LITERAL_CSTRING("/com/nokia/")+ key);
+        interface.Assign(NS_LITERAL_CSTRING("com.nokia.")+ key);  
+      }
+      
+      app->SetService(service);
+      app->SetObjectPath(objpath);
+      app->SetDBusInterface(interface);
+      
+      mPossibleApplications->AppendElement(app, PR_FALSE);
+    }
+    hildon_uri_free_actions(actions);
+  }
+
+  *aPossibleAppHandlers = mPossibleApplications;
+  NS_ADDREF(*aPossibleAppHandlers);
+  return NS_OK;
+}
+#endif
diff -r b7bcdd009540 uriloader/exthandler/unix/nsMIMEInfoUnix.h
--- a/uriloader/exthandler/unix/nsMIMEInfoUnix.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/uriloader/exthandler/unix/nsMIMEInfoUnix.h	Thu Sep 11 15:19:27 2008 +0300
@@ -51,11 +51,14 @@ public:
     nsMIMEInfoImpl(aType, aClass) {}
 
 protected:
   NS_IMETHOD GetHasDefaultHandler(PRBool *_retval);
 
   virtual NS_HIDDEN_(nsresult) LoadUriInternal(nsIURI *aURI);
 
   virtual NS_HIDDEN_(nsresult) LaunchDefaultWithFile(nsIFile *aFile);
+#ifdef MOZ_PLATFORM_HILDON
+  NS_IMETHOD GetPossibleApplicationHandlers(nsIMutableArray * *aPossibleAppHandlers);
+#endif
 };
 
 #endif // nsMIMEInfoUnix_h_
diff -r b7bcdd009540 view/public/nsIViewManager.h
--- a/view/public/nsIViewManager.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/view/public/nsIViewManager.h	Thu Sep 11 15:19:27 2008 +0300
@@ -55,20 +55,20 @@ enum nsRectVisibility {
   nsRectVisibility_kVisible, 
   nsRectVisibility_kAboveViewport, 
   nsRectVisibility_kBelowViewport, 
   nsRectVisibility_kLeftOfViewport, 
   nsRectVisibility_kRightOfViewport, 
   nsRectVisibility_kZeroAreaRect
 }; 
 
-// 855e75b8-32cf-4e16-bc50-4e04c53f6cbc
+// 7eae119d-9fc8-482d-92ec-145eef228a4a
 #define NS_IVIEWMANAGER_IID   \
-{ 0x855e75b8, 0x32cf, 0x4e16, \
-  { 0xbc, 0x50, 0x4e, 0x04, 0xc5, 0x3f, 0x6c, 0xbc } }
+{ 0x7eae119d, 0x9fc8, 0x482d, \
+  { 0x92, 0xec, 0x14, 0x5e, 0xef, 0x22, 0x8a, 0x4a } }
 
 class nsIViewManager : public nsISupports
 {
 public:
 
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_IVIEWMANAGER_IID)
   /**
    * Initialize the ViewManager
@@ -132,16 +132,21 @@ public:
   /**
    * Set the dimensions of the root window.
    * Called if the root window is resized. The dimensions are in
    * twips
    * @param aWidth of window in twips
    * @param aHeight of window in twips
    */
   NS_IMETHOD  SetWindowDimensions(nscoord aWidth, nscoord aHeight) = 0;
+
+  /**
+   * Do any resizes that are pending.
+   */
+  NS_IMETHOD  FlushDelayedResize() = 0;
 
   /**
    * Called to force a redrawing of any dirty areas.
    */
   // XXXbz why is this exposed?  Shouldn't update view batches handle this?
   // It's not like Composite() does what's expected inside a view update batch
   // anyway, since dirty areas may not have been invalidated on the widget yet
   // and widget changes may not have been propagated yet.  Maybe this should
diff -r b7bcdd009540 view/src/nsViewManager.cpp
--- a/view/src/nsViewManager.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/view/src/nsViewManager.cpp	Thu Sep 11 15:19:27 2008 +0300
@@ -370,16 +370,25 @@ NS_IMETHODIMP nsViewManager::SetWindowDi
     if (IsViewVisible(mRootView)) {
       mDelayedResize.SizeTo(NSCOORD_NONE, NSCOORD_NONE);
       DoSetWindowDimensions(aWidth, aHeight);
     } else {
       mDelayedResize.SizeTo(aWidth, aHeight);
     }
   }
 
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsViewManager::FlushDelayedResize()
+{
+  if (mDelayedResize != nsSize(NSCOORD_NONE, NSCOORD_NONE)) {
+    DoSetWindowDimensions(mDelayedResize.width, mDelayedResize.height);
+    mDelayedResize.SizeTo(NSCOORD_NONE, NSCOORD_NONE);
+  }
   return NS_OK;
 }
 
 static void ConvertNativeRegionToAppRegion(nsIRegion* aIn, nsRegion* aOut,
                                            nsIDeviceContext* context)
 {
   nsRegionRectSet* rects = nsnull;
   aIn->GetRects(&rects);
@@ -1068,19 +1077,17 @@ NS_IMETHODIMP nsViewManager::DispatchEve
           // have a delayed resize to handle.
           PRBool didResize = PR_FALSE;
           for (nsViewManager *vm = this; vm;
                vm = vm->mRootView->GetParent()
                       ? vm->mRootView->GetParent()->GetViewManager()
                       : nsnull) {
             if (vm->mDelayedResize != nsSize(NSCOORD_NONE, NSCOORD_NONE) &&
                 IsViewVisible(vm->mRootView)) {
-              vm->DoSetWindowDimensions(vm->mDelayedResize.width,
-                                        vm->mDelayedResize.height);
-              vm->mDelayedResize.SizeTo(NSCOORD_NONE, NSCOORD_NONE);
+              vm->FlushDelayedResize();
 
               // Paint later.
               vm->UpdateView(vm->mRootView, NS_VMREFRESH_NO_SYNC);
               didResize = PR_TRUE;
 
               // not sure if it's valid for us to claim that we
               // ignored this, but we're going to do so anyway, since
               // we didn't actually paint anything
diff -r b7bcdd009540 view/src/nsViewManager.h
--- a/view/src/nsViewManager.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/view/src/nsViewManager.h	Thu Sep 11 15:19:27 2008 +0300
@@ -118,16 +118,17 @@ public:
   NS_IMETHOD_(nsIScrollableView*) CreateScrollableView(const nsRect& aBounds,
                                                        const nsIView* aParent);
 
   NS_IMETHOD  GetRootView(nsIView *&aView);
   NS_IMETHOD  SetRootView(nsIView *aView);
 
   NS_IMETHOD  GetWindowDimensions(nscoord *width, nscoord *height);
   NS_IMETHOD  SetWindowDimensions(nscoord width, nscoord height);
+  NS_IMETHOD  FlushDelayedResize();
 
   NS_IMETHOD  Composite(void);
 
   NS_IMETHOD  UpdateView(nsIView *aView, PRUint32 aUpdateFlags);
   NS_IMETHOD  UpdateView(nsIView *aView, const nsRect &aRect, PRUint32 aUpdateFlags);
   NS_IMETHOD  UpdateAllViews(PRUint32 aUpdateFlags);
 
   NS_IMETHOD  DispatchEvent(nsGUIEvent *aEvent, nsEventStatus* aStatus);
@@ -312,17 +313,18 @@ private:
 
   nsresult GetVisibleRect(nsRect& aVisibleRect);
 
   void DoSetWindowDimensions(nscoord aWidth, nscoord aHeight)
   {
     nsRect oldDim;
     nsRect newDim(0, 0, aWidth, aHeight);
     mRootView->GetDimensions(oldDim);
-    if (oldDim != newDim) {
+    // We care about resizes even when one dimension is already zero.
+    if (!oldDim.IsExactEqual(newDim)) {
       // Don't resize the widget. It is already being set elsewhere.
       mRootView->SetDimensions(newDim, PR_TRUE, PR_FALSE);
       if (mObserver)
         mObserver->ResizeReflow(mRootView, aWidth, aHeight);
     }
   }
 
   // Safety helpers
diff -r b7bcdd009540 widget/Makefile.in
--- a/widget/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/widget/Makefile.in	Thu Sep 11 15:19:28 2008 +0300
@@ -39,14 +39,14 @@ topsrcdir	= @top_srcdir@
 topsrcdir	= @top_srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 DIRS	= public src
 
-ifdef MOZ_MOCHITEST
+ifdef ENABLE_TESTS
 DIRS  += tests
 endif
 
 include $(topsrcdir)/config/rules.mk
 
diff -r b7bcdd009540 widget/src/cocoa/nsCocoaWindow.h
--- a/widget/src/cocoa/nsCocoaWindow.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/widget/src/cocoa/nsCocoaWindow.h	Thu Sep 11 15:19:28 2008 +0300
@@ -245,16 +245,19 @@ public:
     NS_IMETHOD SetPreferredSize(PRInt32 aWidth, PRInt32 aHeight) { return NS_OK; }
     NS_IMETHOD DispatchEvent(nsGUIEvent* event, nsEventStatus & aStatus) ;
     NS_IMETHOD CaptureRollupEvents(nsIRollupListener * aListener, PRBool aDoCapture, PRBool aConsumeRollupEvent);
     NS_IMETHOD GetAttention(PRInt32 aCycleCount);
     virtual nsTransparencyMode GetTransparencyMode();
     virtual void SetTransparencyMode(nsTransparencyMode aMode);
     NS_IMETHOD SetWindowTitlebarColor(nscolor aColor, PRBool aActive);
 
+    // dispatch an NS_SIZEMODE event on miniaturize or deminiaturize
+    void DispatchSizeModeEvent(nsSizeMode aSizeMode);
+
     virtual gfxASurface* GetThebesSurface();
 
     // be notified that a some form of drag event needs to go into Gecko
     virtual PRBool DragEvent(unsigned int aMessage, Point aMouseGlobal, UInt16 aKeyModifiers);
 
     // Helpers to prevent recursive resizing during live-resize
     PRBool IsResizing () const { return mIsResizing; }
     void StartResizing () { mIsResizing = PR_TRUE; }
diff -r b7bcdd009540 widget/src/cocoa/nsCocoaWindow.mm
--- a/widget/src/cocoa/nsCocoaWindow.mm	Mon Sep 08 00:36:19 2008 -0700
+++ b/widget/src/cocoa/nsCocoaWindow.mm	Thu Sep 11 15:19:28 2008 +0300
@@ -904,17 +904,19 @@ NS_METHOD nsCocoaWindow::SetSizeMode(PRI
 
   PRInt32 previousMode;
   nsBaseWidget::GetSizeMode(&previousMode);
 
   nsresult rv = nsBaseWidget::SetSizeMode(aMode);
   NS_ENSURE_SUCCESS(rv, rv);
 
   if (aMode == nsSizeMode_Normal) {
-    if (previousMode == nsSizeMode_Maximized && [mWindow isZoomed])
+    if ([mWindow isMiniaturized])
+      [mWindow deminiaturize:nil];
+    else if (previousMode == nsSizeMode_Maximized && [mWindow isZoomed])
       [mWindow zoom:nil];
   }
   else if (aMode == nsSizeMode_Minimized) {
     if (![mWindow isMiniaturized])
       [mWindow miniaturize:nil];
   }
   else if (aMode == nsSizeMode_Maximized) {
     if ([mWindow isMiniaturized])
@@ -1152,16 +1154,27 @@ nsCocoaWindow::DispatchEvent(nsGUIEvent*
 
   NS_IF_RELEASE(aWidget);
 
   return NS_OK;
 }
 
 
 void
+nsCocoaWindow::DispatchSizeModeEvent(nsSizeMode aSizeMode)
+{
+  nsSizeModeEvent event(PR_TRUE, NS_SIZEMODE, this);
+  event.mSizeMode = aSizeMode;
+  event.time = PR_IntervalNow();
+
+  nsEventStatus status = nsEventStatus_eIgnore;
+  DispatchEvent(&event, status);
+}
+
+void
 nsCocoaWindow::ReportSizeEvent(NSRect *r)
 {
   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 
   NSRect windowFrame;
   if (r)
     windowFrame = [mWindow contentRectForFrameRect:(*r)];
   else
@@ -1319,19 +1332,27 @@ NS_IMETHODIMP nsCocoaWindow::SetWindowTi
   // If they pass a color with a complete transparent alpha component, use the
   // native titlebar appearance.
   if (NS_GET_A(aColor) == 0) {
     [(ToolbarWindow*)mWindow setTitlebarColor:nil forActiveWindow:(BOOL)aActive]; 
   } else {
     // Transform from sRGBA to monitor RGBA. This seems like it would make trying
     // to match the system appearance lame, so probably we just shouldn't color 
     // correct chrome.
-    cmsHTRANSFORM transform = NULL;
-    if ((gfxPlatform::GetCMSMode() == eCMSMode_All) && (transform = gfxPlatform::GetCMSRGBATransform()))
-      cmsDoTransform(transform, &aColor, &aColor, 1);
+    if (gfxPlatform::GetCMSMode() == eCMSMode_All) {
+      cmsHTRANSFORM transform = gfxPlatform::GetCMSRGBATransform();
+      if (transform) {
+        PRUint8 color[3];
+        color[0] = NS_GET_R(aColor);
+        color[1] = NS_GET_G(aColor);
+        color[2] = NS_GET_B(aColor);
+        cmsDoTransform(transform, color, color, 1);
+        aColor = NS_RGB(color[0], color[1], color[2]);
+      }
+    }
 
     [(ToolbarWindow*)mWindow setTitlebarColor:[NSColor colorWithDeviceRed:NS_GET_R(aColor)/255.0
                                                                     green:NS_GET_G(aColor)/255.0
                                                                      blue:NS_GET_B(aColor)/255.0
                                                                     alpha:NS_GET_A(aColor)/255.0]
                               forActiveWindow:(BOOL)aActive];
   }
   return NS_OK;
@@ -1550,16 +1571,30 @@ NS_IMETHODIMP nsCocoaWindow::EndSecureKe
 {
   RollUpPopups();
 }
 
 
 - (void)windowWillMiniaturize:(NSNotification *)aNotification
 {
   RollUpPopups();
+}
+
+
+- (void)windowDidMiniaturize:(NSNotification *)aNotification
+{
+  if (mGeckoWindow)
+    mGeckoWindow->DispatchSizeModeEvent(nsSizeMode_Minimized);
+}
+
+
+- (void)windowDidDeminiaturize:(NSNotification *)aNotification
+{
+  if (mGeckoWindow)
+    mGeckoWindow->DispatchSizeModeEvent(nsSizeMode_Normal);
 }
 
 
 - (void)sendFocusEvent:(PRUint32)eventType
 {
   if (!mGeckoWindow)
     return;
 
diff -r b7bcdd009540 widget/src/gtk2/nsWindow.cpp
--- a/widget/src/gtk2/nsWindow.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/widget/src/gtk2/nsWindow.cpp	Thu Sep 11 15:19:28 2008 +0300
@@ -32,16 +32,21 @@
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
+
+#ifdef MOZ_PLATFORM_HILDON
+#define MAEMO_CHANGES
+#include <gtk/gtkimcontext.h>
+#endif
 
 #include "prlink.h"
 
 #include "nsWindow.h"
 #include "nsGTKToolkit.h"
 #include "nsIDeviceContext.h"
 #include "nsIRenderingContext.h"
 #include "nsIRegion.h"
@@ -6109,16 +6114,23 @@ nsWindow::SetIMEEnabled(PRUint32 aState)
             focusedWin->IMELoseFocus();
         }
 
         mIMEData->mEnabled = aState;
 
         // Even when aState is not PR_TRUE, we need to set IME focus.
         // Because some IMs are updating the status bar of them in this time.
         focusedWin->IMESetFocus();
+#ifdef MOZ_PLATFORM_HILDON
+        if (mIMEData->mEnabled)
+            hildon_gtk_im_context_show (focusedIm);
+        else
+            hildon_gtk_im_context_hide (focusedIm);
+#endif
+        
     } else {
         if (IsIMEEditableState(mIMEData->mEnabled))
             ResetInputState();
         mIMEData->mEnabled = aState;
     }
 
     return NS_OK;
 }
diff -r b7bcdd009540 widget/src/windows/nsClipboard.cpp
--- a/widget/src/windows/nsClipboard.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/widget/src/windows/nsClipboard.cpp	Thu Sep 11 15:19:28 2008 +0300
@@ -45,31 +45,33 @@
 
 // shellapi.h is needed to build with WIN32_LEAN_AND_MEAN
 #include <shellapi.h>
 
 #include "nsCOMPtr.h"
 #include "nsDataObj.h"
 #include "nsIClipboardOwner.h"
 #include "nsString.h"
+#include "nsNativeCharsetUtils.h"
 #include "nsIFormatConverter.h"
 #include "nsITransferable.h"
 #include "nsCOMPtr.h"
 #include "nsXPCOM.h"
 #include "nsISupportsPrimitives.h"
 #include "nsXPIDLString.h"
 #include "nsReadableUtils.h"
 #include "nsUnicharUtils.h"
 #include "nsPrimitiveHelpers.h"
 #include "nsImageClipboard.h"
 #include "nsIWidget.h"
 #include "nsIComponentManager.h"
 #include "nsWidgetsCID.h"
 #include "nsCRT.h"
 #include "nsNetUtil.h"
+#include "nsEscape.h"
 
 #include "nsIImage.h"
 
 
 // oddly, this isn't in the MSVC headers anywhere.
 UINT nsClipboard::CF_HTML = ::RegisterClipboardFormatW(L"HTML Format");
 
 
@@ -814,16 +816,39 @@ nsClipboard :: FindURLFromNativeURL ( ID
     // the internal mozilla URL format, text/x-moz-url, contains
     // URL\ntitle.  Since we don't actually have a title here,
     // just repeat the URL to fake it.
     *outData = ToNewUnicode(urlString + NS_LITERAL_STRING("\n") + urlString);
     *outDataLen = nsCRT::strlen(static_cast<PRUnichar*>(*outData)) * sizeof(PRUnichar);
     nsMemory::Free(tempOutData);
     dataFound = PR_TRUE;
   }
+  else {
+    loadResult = GetNativeDataOffClipboard(inDataObject, inIndex, ::RegisterClipboardFormat(CFSTR_INETURLA), &tempOutData, &tempDataLen);
+    if ( NS_SUCCEEDED(loadResult) && tempOutData ) {
+      // CFSTR_INETURLA is (currently) equal to CFSTR_SHELLURL which is equal to CF_TEXT
+      // which is by definition ANSI encoded.
+      nsCString urlUnescapedA;
+      PRBool unescaped = NS_UnescapeURL(static_cast<char*>(tempOutData), tempDataLen, esc_OnlyNonASCII | esc_SkipControl, urlUnescapedA);
+
+      nsString urlString;
+      if (unescaped)
+        NS_CopyNativeToUnicode(urlUnescapedA, urlString);
+      else
+        NS_CopyNativeToUnicode(nsDependentCString(static_cast<char*>(tempOutData), tempDataLen), urlString);
+
+      // the internal mozilla URL format, text/x-moz-url, contains
+      // URL\ntitle.  Since we don't actually have a title here,
+      // just repeat the URL to fake it.
+      *outData = ToNewUnicode(urlString + NS_LITERAL_STRING("\n") + urlString);
+      *outDataLen = nsCRT::strlen(static_cast<PRUnichar*>(*outData)) * sizeof(PRUnichar);
+      nsMemory::Free(tempOutData);
+      dataFound = PR_TRUE;
+    }
+  }
 
   return dataFound;
 } // FindURLFromNativeURL
 
 //
 // ResolveShortcut
 //
 void
diff -r b7bcdd009540 widget/src/windows/nsNativeDragTarget.cpp
--- a/widget/src/windows/nsNativeDragTarget.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/widget/src/windows/nsNativeDragTarget.cpp	Thu Sep 11 15:19:28 2008 +0300
@@ -41,16 +41,17 @@
 #include "nsNativeDragTarget.h"
 #include "nsDragService.h"
 #include "nsIServiceManager.h"
 #include "nsIDOMNode.h"
 #include "nsCOMPtr.h"
 
 #include "nsIWidget.h"
 #include "nsWindow.h"
+#include "nsClipboard.h"
 
 #if (_MSC_VER == 1100)
 #define INITGUID
 #include "objbase.h"
 DEFINE_OLEGUID(IID_IDropTarget, 0x00000122L, 0, 0);
 DEFINE_OLEGUID(IID_IUnknown, 0x00000000L, 0, 0);
 #endif
 
@@ -153,19 +154,21 @@ nsNativeDragTarget::GetGeckoDragAction(L
 {
   // Check if we can link from this data object as well.
   PRBool canLink = PR_FALSE;
   if (pData)
     canLink = (S_OK == ::OleQueryLinkFromData(pData) ? PR_TRUE : PR_FALSE);
 
   // Default is move if we can, in fact drop here,
   // and if the drop source supports a move operation.
-  if (mCanMove) {
+  // If move is not preferred (mMovePreferred is false)
+  // move only when the shift key is down.
+  if (mCanMove && (mMovePreferred || (grfKeyState & MK_SHIFT))) {
+    *aGeckoAction = nsIDragService::DRAGDROP_ACTION_MOVE;
     *pdwEffect    = DROPEFFECT_MOVE;
-    *aGeckoAction = nsIDragService::DRAGDROP_ACTION_MOVE;
   } else {
     *aGeckoAction = nsIDragService::DRAGDROP_ACTION_COPY;
     *pdwEffect    = DROPEFFECT_COPY;
   }
 
   // Given the key modifiers figure out what state we are in for both
   // the native system and Gecko
   if (grfKeyState & MK_CONTROL) {
@@ -281,16 +284,30 @@ nsNativeDragTarget::DragEnter(LPDATAOBJE
 
   // tell the drag service about this drag (it may have come from an
   // outside app).
   mDragService->StartDragSession();
 
   // Remember if this operation allows a move.
   mCanMove = (*pdwEffect) & DROPEFFECT_MOVE;
 
+  void* tempOutData = nsnull;
+  PRUint32 tempDataLen = 0;
+  nsresult loadResult = nsClipboard::GetNativeDataOffClipboard(
+      pIDataSource, 0, ::RegisterClipboardFormat(CFSTR_PREFERREDDROPEFFECT), &tempOutData, &tempDataLen);
+  if (NS_SUCCEEDED(loadResult) && tempOutData) {
+    NS_ASSERTION(tempDataLen == 2, "Expected word size");
+    WORD preferredEffect = *((WORD*)tempOutData);
+
+    // Mask effect coming from function call with effect preferred by the source.
+    mMovePreferred = (preferredEffect & DROPEFFECT_MOVE) != 0;
+  }
+  else
+    mMovePreferred = mCanMove;
+
   // Set the native data object into drag service
   //
   // This cast is ok because in the constructor we created a
   // the actual implementation we wanted, so we know this is
   // a nsDragService. It should be a private interface, though.
   nsDragService * winDragService =
     static_cast<nsDragService *>(mDragService);
   winDragService->SetIDataObject(pIDataSource);
diff -r b7bcdd009540 widget/src/windows/nsNativeDragTarget.h
--- a/widget/src/windows/nsNativeDragTarget.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/widget/src/windows/nsNativeDragTarget.h	Thu Sep 11 15:19:28 2008 +0300
@@ -108,16 +108,17 @@ protected:
   void ProcessDrag(LPDATAOBJECT pData, PRUint32 aEventType, DWORD grfKeyState,
                    POINTL pt, DWORD* pdwEffect);
   void DispatchDragDropEvent(PRUint32 aType, POINTL pt);
 
   // Native Stuff
   ULONG            m_cRef;      // reference count
   HWND             mHWnd;
   PRBool           mCanMove;
+  PRBool           mMovePreferred;
 
   // Gecko Stuff
   nsIWidget      * mWindow;
   nsIDragService * mDragService;
 
   // Drag target helper 
 #ifndef WINCE
   IDropTargetHelper * mDropTargetHelper;
diff -r b7bcdd009540 widget/src/windows/nsWindow.cpp
--- a/widget/src/windows/nsWindow.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/widget/src/windows/nsWindow.cpp	Thu Sep 11 15:19:28 2008 +0300
@@ -424,16 +424,20 @@ static PRBool is_vk_down(int vk)
 #define GET_APPCOMMAND_LPARAM(lParam) ((short)(HIWORD(lParam) & ~FAPPCOMMAND_MASK))
 //#define GET_DEVICE_LPARAM(lParam)     ((WORD)(HIWORD(lParam) & FAPPCOMMAND_MASK))
 //#define GET_MOUSEORKEY_LPARAM         GET_DEVICE_LPARAM
 //#define GET_FLAGS_LPARAM(lParam)      (LOWORD(lParam))
 //#define GET_KEYSTATE_LPARAM(lParam)   GET_FLAGS_LPARAM(lParam)
 
 #endif  // #ifndef APPCOMMAND_BROWSER_BACKWARD
 
+#define VERIFY_WINDOW_STYLE(s) \
+  NS_ASSERTION(((s) & (WS_CHILD | WS_POPUP)) != (WS_CHILD | WS_POPUP), \
+               "WS_POPUP and WS_CHILD are mutually exclusive")
+
 /* This object maintains a correlation between attention timers and the
    windows to which they belong. It's lighter than a hashtable (expected usage
    is really just one at a time) and allows nsWindow::GetNSWindowPtr
    to remain private. */
 class nsAttentionTimerMonitor {
 public:
   nsAttentionTimerMonitor() : mHeadTimer(0) { }
   ~nsAttentionTimerMonitor() {
@@ -537,31 +541,31 @@ private:
     }
   }
 
   TimerInfo *mHeadTimer;
 };
 
 static nsAttentionTimerMonitor *gAttentionTimerMonitor = 0;
 
-HWND nsWindow::GetTopLevelHWND(HWND aWnd, PRBool aStopOnFirstTopLevel)
+HWND nsWindow::GetTopLevelHWND(HWND aWnd, PRBool aStopOnDialogOrPopup)
 {
   HWND curWnd = aWnd;
   HWND topWnd = NULL;
 
-  while (curWnd)
-  {
+  while (curWnd) {
     topWnd = curWnd;
 
 #ifndef WINCE
-    if (aStopOnFirstTopLevel)
-    {
+    if (aStopOnDialogOrPopup) {
       DWORD style = ::GetWindowLongW(curWnd, GWL_STYLE);
 
-      if (!(style & WS_CHILDWINDOW))    // first top-level window
+      VERIFY_WINDOW_STYLE(style);
+
+      if (!(style & WS_CHILD)) // first top-level window
         break;
     }
 #endif
 
     curWnd = ::GetParent(curWnd);       // Parent or owner (if has no parent)
   }
 
   return topWnd;
@@ -1511,28 +1515,28 @@ NS_IMETHODIMP nsWindow::SetParent(nsIWid
 
 //-------------------------------------------------------------------------
 //
 // Get this nsWindow parent
 //
 //-------------------------------------------------------------------------
 nsIWidget* nsWindow::GetParent(void)
 {
-  return GetParent(PR_TRUE);
-}
-
-// XXX does anyone pass false for aStopOnFirstTopLevel?
-nsWindow* nsWindow::GetParent(PRBool aStopOnFirstTopLevel)
-{
-  if (mIsTopWidgetWindow && aStopOnFirstTopLevel) {
+  return GetParentWindow();
+}
+
+nsWindow* nsWindow::GetParentWindow()
+{
+  if (mIsTopWidgetWindow) {
     // Must use a flag instead of mWindowType to tell if the window is the
     // owned by the topmost widget, because a child window can be embedded inside
     // a HWND which is not associated with a nsIWidget.
     return nsnull;
   }
+
   // If this widget has already been destroyed, pretend we have no parent.
   // This corresponds to code in Destroy which removes the destroyed
   // widget from its parent's child list.
   if (mIsDestroying || mOnDestroyCalled)
     return nsnull;
 
   nsWindow* widget = nsnull;
   if (mWnd) {
@@ -2621,16 +2625,17 @@ NS_IMETHODIMP nsWindow::HideWindowChrome
       mOldStyle = ::GetWindowLongW(hwnd, GWL_STYLE);
       mOldExStyle = ::GetWindowLongW(hwnd, GWL_EXSTYLE);
     }
 
     style = mOldStyle;
     exStyle = mOldExStyle;
   }
 
+  VERIFY_WINDOW_STYLE(style);
   ::SetWindowLongW(hwnd, GWL_STYLE, style);
   ::SetWindowLongW(hwnd, GWL_EXSTYLE, exStyle);
 
   return NS_OK;
 }
 
 // ------------------------------------------------------------------------
 //
@@ -5543,16 +5548,17 @@ DWORD nsWindow::WindowStyle()
 
   if (mBorderStyle != eBorderStyle_default && mBorderStyle != eBorderStyle_all) {
     if (mBorderStyle == eBorderStyle_none || !(mBorderStyle & eBorderStyle_border))
       style &= ~WS_BORDER;
 
     if (mBorderStyle == eBorderStyle_none || !(mBorderStyle & eBorderStyle_title)) {
       style &= ~WS_DLGFRAME;
       style |= WS_POPUP;
+      style &= ~WS_CHILD;
     }
 
     if (mBorderStyle == eBorderStyle_none || !(mBorderStyle & eBorderStyle_close))
       style &= ~0;
     // XXX The close box can only be removed by changing the window class,
     // as far as I know   --- roc+moz@cs.cmu.edu
 
     if (mBorderStyle == eBorderStyle_none ||
@@ -5568,16 +5574,17 @@ DWORD nsWindow::WindowStyle()
 
     if (mBorderStyle == eBorderStyle_none || !(mBorderStyle & eBorderStyle_minimize))
       style &= ~WS_MINIMIZEBOX;
 
     if (mBorderStyle == eBorderStyle_none || !(mBorderStyle & eBorderStyle_maximize))
       style &= ~WS_MAXIMIZEBOX;
   }
 #endif // WINCE
+  VERIFY_WINDOW_STYLE(style);
   return style;
 }
 
 
 //-------------------------------------------------------------------------
 //
 // return nsWindow extended styles
 //
@@ -5958,17 +5965,17 @@ static PRBool IsTopLevelMouseExit(HWND a
   POINT mp;
   mp.x = GET_X_LPARAM(pos);
   mp.y = GET_Y_LPARAM(pos);
   HWND mouseWnd = ::WindowFromPoint(mp);
 
   // GetTopLevelHWND will return a HWND for the window frame (which includes
   // the non-client area).  If the mouse has moved into the non-client area,
   // we should treat it as a top-level exit.
-  HWND mouseTopLevel = nsWindow::GetTopLevelHWND(mouseWnd, false);
+  HWND mouseTopLevel = nsWindow::GetTopLevelHWND(mouseWnd);
   if (mouseWnd == mouseTopLevel)
     return PR_TRUE;
 
   return nsWindow::GetTopLevelHWND(aWnd) != mouseTopLevel;
 }
 
 //-------------------------------------------------------------------------
 //
@@ -6330,17 +6337,21 @@ PRBool ChildWindow::DispatchMouseEvent(P
 
 //-------------------------------------------------------------------------
 //
 // return the style for a child nsWindow
 //
 //-------------------------------------------------------------------------
 DWORD ChildWindow::WindowStyle()
 {
-  return WS_CHILD | WS_CLIPCHILDREN | nsWindow::WindowStyle();
+  DWORD style = WS_CLIPCHILDREN | nsWindow::WindowStyle();
+  if (!(style & WS_POPUP))
+    style |= WS_CHILD; // WS_POPUP and WS_CHILD are mutually exclusive.
+  VERIFY_WINDOW_STYLE(style);
+  return style;
 }
 
 NS_METHOD nsWindow::SetTitle(const nsAString& aTitle)
 {
   const nsString& strTitle = PromiseFlatString(aTitle);
   ::SendMessageW(mWnd, WM_SETTEXT, (WPARAM)0, (LPARAM)(LPCWSTR)strTitle.get());
   return NS_OK;
 }
@@ -7154,17 +7165,19 @@ PRBool nsWindow::OnIMEQueryCharPosition(
     InitEvent(caretRect, &point);
     DispatchWindowEvent(&caretRect);
     if (!caretRect.mSucceeded)
       return PR_FALSE;
     r = caretRect.mReply.mRect;
   }
 
   nsRect screenRect;
-  ResolveIMECaretPos(GetTopLevelWindow(), r, nsnull, screenRect);
+  // We always need top level window that is owner window of the popup window
+  // even if the content of the popup window has focus.
+  ResolveIMECaretPos(GetTopLevelWindow(PR_FALSE), r, nsnull, screenRect);
   pCharPosition->pt.x = screenRect.x;
   pCharPosition->pt.y = screenRect.y;
 
   pCharPosition->cLineHeight = r.height;
 
   // XXX Should we create "query focused content rect event"?
   ::GetWindowRect(mWnd, &pCharPosition->rcDocument);
 
@@ -7981,28 +7994,35 @@ STDMETHODIMP_(LRESULT) nsWindow::Lresult
   }
 
   return 0;
 }
 #endif
 
 #ifdef MOZ_XUL
 
-nsWindow* nsWindow::GetTopLevelWindow()
+nsWindow* nsWindow::GetTopLevelWindow(PRBool aStopOnDialogOrPopup)
 {
   nsWindow* curWindow = this;
 
-  while (PR_TRUE)
-  {
-    nsWindow* parentWindow = curWindow->GetParent(PR_TRUE);
-
-    if (parentWindow)
-      curWindow = parentWindow;
-    else
+  while (PR_TRUE) {
+    if (aStopOnDialogOrPopup) {
+      switch (curWindow->mWindowType) {
+        case eWindowType_dialog:
+        case eWindowType_popup:
+          return curWindow;
+      }
+    }
+
+    nsWindow* parentWindow = curWindow->GetParentWindow();
+
+    if (!parentWindow)
       return curWindow;
+
+    curWindow = parentWindow;
   }
 }
 
 gfxASurface *nsWindow::GetThebesSurface()
 {
   if (mPaintDC)
     return (new gfxWindowsSurface(mPaintDC));
 
@@ -8015,22 +8035,22 @@ void nsWindow::ResizeTranslucentWindow(P
     return;
 
   mTransparentSurface = new gfxWindowsSurface(gfxIntSize(aNewWidth, aNewHeight), gfxASurface::ImageFormatARGB32);
   mMemoryDC = mTransparentSurface->GetDC();
 }
 
 nsTransparencyMode nsWindow::GetTransparencyMode()
 {
-  return GetTopLevelWindow()->GetWindowTranslucencyInner();
+  return GetTopLevelWindow(PR_TRUE)->GetWindowTranslucencyInner();
 }
 
 void nsWindow::SetTransparencyMode(nsTransparencyMode aMode)
 {
-  GetTopLevelWindow()->SetWindowTranslucencyInner(aMode);
+  GetTopLevelWindow(PR_TRUE)->SetWindowTranslucencyInner(aMode);
 }
 
 void nsWindow::SetWindowTranslucencyInner(nsTransparencyMode aMode)
 {
   if (aMode == mTransparencyMode)
     return;
 
   HWND hWnd = GetTopLevelHWND(mWnd, PR_TRUE);
@@ -8050,16 +8070,17 @@ void nsWindow::SetWindowTranslucencyInne
   switch(aMode) {
     case eTransparencyTransparent:
       exStyle |= WS_EX_LAYERED;
     case eTransparencyOpaque:
     case eTransparencyGlass:
       topWindow->mTransparencyMode = aMode;
       break;
   }
+  VERIFY_WINDOW_STYLE(style);
   ::SetWindowLongW(hWnd, GWL_STYLE, style);
   ::SetWindowLongW(hWnd, GWL_EXSTYLE, exStyle);
 
   mTransparencyMode = aMode;
 
   SetupTranslucentWindowMemoryBitmap(aMode);
   MARGINS margins = { 0, 0, 0, 0 };
   if(eTransparencyGlass == aMode)
diff -r b7bcdd009540 widget/src/windows/nsWindow.h
--- a/widget/src/windows/nsWindow.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/widget/src/windows/nsWindow.h	Thu Sep 11 15:19:29 2008 +0300
@@ -206,17 +206,22 @@ public:
 
   virtual void            SetUpForPaint(HDC aHDC);
   virtual void            ConvertToDeviceCoordinates(nscoord& aX,nscoord& aY) {}
 
   NS_IMETHOD              CaptureRollupEvents(nsIRollupListener * aListener, PRBool aDoCapture, PRBool aConsumeRollupEvent);
 
   NS_IMETHOD              GetAttention(PRInt32 aCycleCount);
   NS_IMETHOD              GetLastInputEventTime(PRUint32& aTime);
-  nsWindow*               GetTopLevelWindow();
+
+  // Note that the result of GetTopLevelWindow method can be different from the
+  // result of GetTopLevelHWND method.  The result can be non-floating window.
+  // Because our top level window may be contained in another window which is
+  // not managed by us.
+  nsWindow*               GetTopLevelWindow(PRBool aStopOnDialogOrPopup);
 
   gfxASurface             *GetThebesSurface();
 
 #ifdef MOZ_XUL
   virtual void            SetTransparencyMode(nsTransparencyMode aMode);
   virtual nsTransparencyMode GetTransparencyMode();
 private:
   void                    SetWindowTranslucencyInner(nsTransparencyMode aMode);
@@ -282,17 +287,17 @@ protected:
 #endif
 
   static BOOL             DealWithPopups (HWND inWnd, UINT inMsg, WPARAM inWParam, LPARAM inLParam, LRESULT* outResult);
 
   static PRBool           EventIsInsideWindow(UINT Msg, nsWindow* aWindow);
 
   static nsWindow*        GetNSWindowPtr(HWND aWnd);
   static BOOL             SetNSWindowPtr(HWND aWnd, nsWindow * ptr);
-  nsWindow*               GetParent(PRBool aStopOnFirstTopLevel);
+  nsWindow*               GetParentWindow();
 
   void                    DispatchPendingEvents();
   virtual PRBool          ProcessMessage(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *aRetValue);
   virtual PRBool          DispatchWindowEvent(nsGUIEvent* event);
   virtual PRBool          DispatchWindowEvent(nsGUIEvent*event, nsEventStatus &aStatus);
 
    // Allow Derived classes to modify the height that is passed
    // when the window is created or resized.
@@ -515,17 +520,22 @@ protected:
 
   static BOOL CALLBACK BroadcastMsgToChildren(HWND aWnd, LPARAM aMsg);
   static BOOL CALLBACK BroadcastMsg(HWND aTopWindow, LPARAM aMsg);
   static BOOL CALLBACK DispatchStarvedPaints(HWND aTopWindow, LPARAM aMsg);
   static BOOL CALLBACK InvalidateForeignChildWindows(HWND aWnd, LPARAM aMsg);
 
 public:
   static void GlobalMsgWindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
-  static HWND GetTopLevelHWND(HWND aWnd, PRBool aStopOnFirstTopLevel = PR_FALSE);
+  // Note that the result of GetTopLevelHWND can be different from the result
+  // of GetTopLevelWindow method.  Because this is checking whether the window
+  // is top level only in Win32 window system.  Therefore, the result window
+  // may not be managed by us.
+  static HWND GetTopLevelHWND(HWND aWnd,
+                              PRBool aStopOnDialogOrPopup = PR_FALSE);
 };
 
 //
 // A child window is a window with different style
 //
 class ChildWindow : public nsWindow {
 
 public:
diff -r b7bcdd009540 widget/src/xpwidgets/nsBaseDragService.cpp
--- a/widget/src/xpwidgets/nsBaseDragService.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/widget/src/xpwidgets/nsBaseDragService.cpp	Thu Sep 11 15:19:29 2008 +0300
@@ -474,21 +474,27 @@ nsBaseDragService::DrawDrag(nsIDOMNode* 
     NS_IF_ADDREF(*aSurface);
     return NS_OK;
   }
 
   // if an custom image was specified, check if it is an image node and draw
   // using the source rather than the displayed image. But if mImage isn't
   // an image, fall through to RenderNode below.
   if (mImage) {
+    nsCOMPtr<nsICanvasElement> canvas = do_QueryInterface(dragNode);
+    if (canvas) {
+      return DrawDragForImage(*aPresContext, nsnull, canvas, aScreenX,
+                              aScreenY, aScreenDragRect, aSurface);
+    }
+
     nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(dragNode);
     // for image nodes, create the drag image from the actual image data
     if (imageLoader) {
-      return DrawDragForImage(*aPresContext, imageLoader, aScreenX, aScreenY,
-                              aScreenDragRect, aSurface);
+      return DrawDragForImage(*aPresContext, imageLoader, nsnull, aScreenX,
+                              aScreenY, aScreenDragRect, aSurface);
     }
   }
 
   // otherwise, just draw the node
   nsCOMPtr<nsIRegion> clipRegion;
   if (aRegion)
     aRegion->GetRegion(getter_AddRefs(clipRegion));
 
@@ -507,45 +513,56 @@ nsBaseDragService::DrawDrag(nsIDOMNode* 
   NS_IF_ADDREF(*aSurface);
 
   return NS_OK;
 }
 
 nsresult
 nsBaseDragService::DrawDragForImage(nsPresContext* aPresContext,
                                     nsIImageLoadingContent* aImageLoader,
+                                    nsICanvasElement* aCanvas,
                                     PRInt32 aScreenX, PRInt32 aScreenY,
                                     nsRect* aScreenDragRect,
                                     gfxASurface** aSurface)
 {
-  nsCOMPtr<imgIRequest> imgRequest;
-  nsresult rv = aImageLoader->GetRequest(nsIImageLoadingContent::CURRENT_REQUEST,
-                                        getter_AddRefs(imgRequest));
-  NS_ENSURE_SUCCESS(rv, rv);
-  if (!imgRequest)
-    return NS_ERROR_NOT_AVAILABLE;
+  nsCOMPtr<nsIImage> img;
+  if (aImageLoader) {
+    nsCOMPtr<imgIRequest> imgRequest;
+    nsresult rv = aImageLoader->GetRequest(nsIImageLoadingContent::CURRENT_REQUEST,
+                                          getter_AddRefs(imgRequest));
+    NS_ENSURE_SUCCESS(rv, rv);
+    if (!imgRequest)
+      return NS_ERROR_NOT_AVAILABLE;
 
-  nsCOMPtr<imgIContainer> imgContainer;
-  rv = imgRequest->GetImage(getter_AddRefs(imgContainer));
-  NS_ENSURE_SUCCESS(rv, rv);
-  if (!imgContainer)
-    return NS_ERROR_NOT_AVAILABLE;
+    nsCOMPtr<imgIContainer> imgContainer;
+    rv = imgRequest->GetImage(getter_AddRefs(imgContainer));
+    NS_ENSURE_SUCCESS(rv, rv);
+    if (!imgContainer)
+      return NS_ERROR_NOT_AVAILABLE;
 
-  nsCOMPtr<gfxIImageFrame> iframe;
-  imgContainer->GetCurrentFrame(getter_AddRefs(iframe));
-  if (!iframe)
-    return NS_ERROR_FAILURE;
+    nsCOMPtr<gfxIImageFrame> iframe;
+    imgContainer->GetCurrentFrame(getter_AddRefs(iframe));
+    if (!iframe)
+      return NS_ERROR_FAILURE;
 
-  nsCOMPtr<nsIImage> img(do_GetInterface(iframe));
-  if (!img)
-    return NS_ERROR_FAILURE;
+    img = do_GetInterface(iframe);
+    if (!img)
+      return NS_ERROR_FAILURE;
 
-  // use the size of the image as the size of the drag image
-  imgContainer->GetWidth(&aScreenDragRect->width);
-  imgContainer->GetHeight(&aScreenDragRect->height);
+    // use the size of the image as the size of the drag image
+    imgContainer->GetWidth(&aScreenDragRect->width);
+    imgContainer->GetHeight(&aScreenDragRect->height);
+  }
+  else {
+    NS_ASSERTION(aCanvas, "both image and canvas are null");
+    PRUint32 width, height;
+    aCanvas->GetSize(&width, &height);
+    aScreenDragRect->width = width;
+    aScreenDragRect->height = height;
+  }
 
   nsRect srcRect = *aScreenDragRect;
   srcRect.MoveTo(0, 0);
   nsRect destRect = srcRect;
 
   if (destRect.width == 0 || destRect.height == 0)
     return NS_ERROR_FAILURE;
 
@@ -580,25 +597,30 @@ nsBaseDragService::DrawDragForImage(nsPr
 
   *aSurface = surface;
   NS_ADDREF(*aSurface);
 
   nsCOMPtr<nsIRenderingContext> rc;
   deviceContext->CreateRenderingContextInstance(*getter_AddRefs(rc));
   rc->Init(deviceContext, surface);
 
-  // clear the image before drawing
-  gfxContext context(surface);
-  context.SetOperator(gfxContext::OPERATOR_CLEAR);
-  context.Rectangle(gfxRect(0, 0, destRect.width, destRect.height));
-  context.Fill();
+  if (aImageLoader) {
+    // clear the image before drawing
+    gfxContext context(surface);
+    context.SetOperator(gfxContext::OPERATOR_CLEAR);
+    context.Rectangle(gfxRect(0, 0, destRect.width, destRect.height));
+    context.Fill();
 
-  gfxRect inRect = gfxRect(srcRect.x, srcRect.y, srcRect.width, srcRect.height);
-  gfxRect outRect = gfxRect(destRect.x, destRect.y, destRect.width, destRect.height);
-  return img->Draw(*rc, inRect, inRect, outRect);
+    gfxRect inRect = gfxRect(srcRect.x, srcRect.y, srcRect.width, srcRect.height);
+    gfxRect outRect = gfxRect(destRect.x, destRect.y, destRect.width, destRect.height);
+    return img->Draw(*rc, inRect, inRect, outRect);
+  }
+  else {
+    return aCanvas->RenderContexts(rc->ThebesContext());
+  }
 }
 
 void
 nsBaseDragService::ConvertToUnscaledDevPixels(nsPresContext* aPresContext,
                                               PRInt32* aScreenX, PRInt32* aScreenY)
 {
   PRInt32 adj = aPresContext->DeviceContext()->UnscaledAppUnitsPerDevPixel();
   *aScreenX = nsPresContext::CSSPixelsToAppUnits(*aScreenX) / adj;
diff -r b7bcdd009540 widget/src/xpwidgets/nsBaseDragService.h
--- a/widget/src/xpwidgets/nsBaseDragService.h	Mon Sep 08 00:36:19 2008 -0700
+++ b/widget/src/xpwidgets/nsBaseDragService.h	Thu Sep 11 15:19:29 2008 +0300
@@ -51,16 +51,17 @@
 
 // translucency level for drag images
 #define DRAG_TRANSLUCENCY 0.65
 
 class nsIDOMNode;
 class nsIFrame;
 class nsPresContext;
 class nsIImageLoadingContent;
+class nsICanvasElement;
 
 /**
  * XP DragService wrapper base class
  */
 
 class nsBaseDragService : public nsIDragService,
                           public nsIDragSession
 {
@@ -102,20 +103,22 @@ protected:
   nsresult DrawDrag(nsIDOMNode* aDOMNode,
                     nsIScriptableRegion* aRegion,
                     PRInt32 aScreenX, PRInt32 aScreenY,
                     nsRect* aScreenDragRect,
                     gfxASurface** aSurface,
                     nsPresContext **aPresContext);
 
   /**
-   * Draw a drag image for an image node. This is called by DrawDrag.
+   * Draw a drag image for an image node specified by aImageLoader or aCanvas.
+   * This is called by DrawDrag.
    */
   nsresult DrawDragForImage(nsPresContext* aPresContext,
                             nsIImageLoadingContent* aImageLoader,
+                            nsICanvasElement* aCanvas,
                             PRInt32 aScreenX, PRInt32 aScreenY,
                             nsRect* aScreenDragRect,
                             gfxASurface** aSurface);
 
   /**
    * Convert aScreenX and aScreenY from CSS pixels into unscaled device pixels.
    */
   void
diff -r b7bcdd009540 xpcom/analysis/flow.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/xpcom/analysis/flow.js	Thu Sep 11 15:19:29 2008 +0300
@@ -0,0 +1,155 @@
+require({ version: '1.8' });
+require({ after_gcc_pass: 'cfg' });
+
+include('treehydra.js');
+
+include('util.js');
+include('gcc_util.js');
+include('gcc_print.js');
+include('unstable/adts.js');
+include('unstable/analysis.js');
+include('unstable/esp.js');
+
+/* This implements the control flows-through analysis in bug 432917 */
+var Zero_NonZero = {}
+include('unstable/zero_nonzero.js', Zero_NonZero);
+
+MapFactory.use_injective = true;
+
+// Print a trace for each function analyzed
+let TRACE_FUNCTIONS = 0;
+// Trace operation of the ESP analysis, use 2 or 3 for more detail
+let TRACE_ESP = 0;
+// Print time-taken stats
+let TRACE_PERF = 0;
+
+function process_tree(fndecl) {
+  // At this point we have a function we want to analyze
+  if (TRACE_FUNCTIONS) {
+    print('* function ' + decl_name(fndecl));
+    print('    ' + loc_string(location_of(fndecl)));
+  }
+  if (TRACE_PERF) timer_start(fstring);
+
+  let cfg = function_decl_cfg(fndecl);
+
+
+  try {
+    let trace = TRACE_ESP;
+    let a = new FlowCheck(cfg, trace);
+    a.run();
+  } catch (e if e == "skip") {
+    return
+  }
+  print("checked " + decl_name(fndecl))
+  if (cfg.x_exit_block_ptr.stateIn.substates)
+    for each (let substate in cfg.x_exit_block_ptr.stateIn.substates.getValues()) {
+      for each (let v in substate.getVariables()) {
+        let var_state= substate.get (v)
+        let blame = substate.getBlame(v)
+        if (var_state != ESP.TOP && typeof var_state == 'string')
+          error(decl_name(fndecl) + ": Control did not flow through " +var_state, location_of(blame))
+      }
+    }
+  
+  if (TRACE_PERF) timer_stop(fstring);
+}
+
+let track_return_loc = 0;
+const FLOW_THROUGH = "MUST_FLOW_THROUGH"
+
+function FlowCheck(cfg, trace) {
+  let found = create_decl_set(); // ones we already found
+  for (let bb in cfg_bb_iterator(cfg)) {
+    for (let isn in bb_isn_iterator(bb)) {
+      switch (isn.tree_code()) {
+      case CALL_EXPR: {
+        let fn = call_function_decl(isn)
+        if (!fn || decl_name(fn) != FLOW_THROUGH)
+          continue;
+        this.must_flow_fn = fn
+        break
+      }
+      case RETURN_EXPR: {
+        let ret_expr = isn.operands()[0]
+        if (track_return_loc && ret_expr) 
+          switch (ret_expr.tree_code()) {
+          case GIMPLE_MODIFY_STMT:
+            this.rval = ret_expr.operands()[1].tree_check(VAR_DECL)
+            break;
+          case RESULT_DECL:
+            this.rval = ret_expr
+            break;
+          default:
+            throw new Error("Unhandled return expression")
+          }
+      }
+      }
+    }
+  }
+  if (!this.must_flow_fn)
+    throw "skip"
+
+  let psvar_list = [new ESP.PropVarSpec(this.must_flow_fn, true)]
+  
+  if (this.rval)
+    psvar_list.push(new ESP.PropVarSpec(this.rval))
+ 
+  this.zeroNonzero = new Zero_NonZero.Zero_NonZero()
+  ESP.Analysis.call(this, cfg, psvar_list, Zero_NonZero.meet, trace);
+}
+
+FlowCheck.prototype = new ESP.Analysis;
+
+function char_star_arg2string(tree) {
+  return TREE_STRING_POINTER(tree.tree_check(ADDR_EXPR).operands()[0].tree_check(ARRAY_REF).operands()[0])
+}
+
+// State transition function. Mostly, we delegate everything to
+// another function as either an assignment or a call.
+FlowCheck.prototype.flowState = function(isn, state) {
+  switch (TREE_CODE(isn)) {
+  case CALL_EXPR: {
+    let fn = call_function_decl(isn)
+    if (fn == this.must_flow_fn)
+      state.assignValue(fn, char_star_arg2string(call_arg(isn, 0)), isn)
+    break
+  }
+  case LABEL_EXPR: {
+    let label = decl_name(isn.operands()[0])
+    for ([value, blame] in state.yieldPreconditions(this.must_flow_fn)) {
+      if (label != value) continue
+      // reached the goto label we wanted =D
+      state.assignValue(this.must_flow_fn, ESP.TOP, isn)
+    }
+    break
+  }
+  case RETURN_EXPR: {
+    for ([value, blame] in state.yieldPreconditions(this.must_flow_fn)) {
+      if (typeof value != 'string') continue
+      let loc;
+      if (this.rval)
+        for ([value, blame] in state.yieldPreconditions(this.rval)) {
+          loc = value
+          break
+        }
+      error("return without going through label "+ value, loc);
+      return  
+    }
+    break
+  }
+  case GIMPLE_MODIFY_STMT:
+    if (track_return_loc && isn.operands()[0] == this.rval) {
+      state.assignValue(this.rval, location_of(isn), isn)
+      break
+    }
+  default:
+    this.zeroNonzero.flowState(isn, state)
+  }
+}
+
+// State transition function to apply branch filters. This is kind
+// of boilerplate--we're just handling some stuff that GCC generates.
+FlowCheck.prototype.flowStateCond = function(isn, truth, state) {
+  this.zeroNonzero.flowStateCond (isn, truth, state)
+}
diff -r b7bcdd009540 xpcom/glue/nsVoidArray.cpp
--- a/xpcom/glue/nsVoidArray.cpp	Mon Sep 08 00:36:19 2008 -0700
+++ b/xpcom/glue/nsVoidArray.cpp	Thu Sep 11 15:19:29 2008 +0300
@@ -727,16 +727,24 @@ nsStringArray::~nsStringArray(void)
 nsStringArray::~nsStringArray(void)
 {
   Clear();
 }
 
 nsStringArray& 
 nsStringArray::operator=(const nsStringArray& other)
 {
+  if (this == &other)
+  {
+    return *this;
+  }
+
+  // Free our strings
+  Clear();
+  
   // Copy the pointers
   nsVoidArray::operator=(other);
 
   // Now copy the strings
   PRInt32 count = Count();
   for (PRInt32 i = 0; i < count; ++i)
   {
     nsString* oldString = static_cast<nsString*>(other.ElementAt(i));
@@ -977,16 +985,24 @@ nsCStringArray::~nsCStringArray(void)
 nsCStringArray::~nsCStringArray(void)
 {
   Clear();
 }
 
 nsCStringArray& 
 nsCStringArray::operator=(const nsCStringArray& other)
 {
+  if (this == &other)
+  {
+    return *this;
+  }
+
+  // Free our strings
+  Clear();
+  
   // Copy the pointers
   nsVoidArray::operator=(other);
 
   // Now copy the strings
   PRInt32 count = Count();
   for (PRInt32 i = 0; i < count; ++i)
   {
     nsCString* oldString = static_cast<nsCString*>(other.ElementAt(i));
diff -r b7bcdd009540 xpcom/reflect/xptcall/tests/eVC4/XPTCInvoke_Testing.vcn
--- a/xpcom/reflect/xptcall/tests/eVC4/XPTCInvoke_Testing.vcn	Mon Sep 08 00:36:19 2008 -0700
+++ b/xpcom/reflect/xptcall/tests/eVC4/XPTCInvoke_Testing.vcn	Thu Sep 11 15:19:29 2008 +0300
@@ -79,17 +79,17 @@ CLEAN :
 	-@erase "$(OUTDIR)\XPTCInvoke_Testing.exe"
 
 "$(OUTDIR)" :
     if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
 
 RSC=rc.exe
 RSC_PROJ=/l 0x409 /fo"$(INTDIR)\XPTCInvoke_Testing.res" /i "C:\Program Files\Windows CE Tools\wce420\POCKET PC 2003\Include\Emulator" /d UNDER_CE=$(CEVersion) /d _WIN32_WCE=$(CEVersion) /d "UNICODE" /d "_UNICODE" /d "NDEBUG" /d "$(CePlatform)" /d "_X86_" /d "x86" /d "_i386_" /r 
 CPP=cl.exe
-CPP_PROJ=/nologo /W3 /I "..\..\..\..\..\arm_ppc\dist\include" /I "..\..\..\..\..\arm_ppc\dist\include\xpcom" /I "..\..\..\..\..\arm_ppc\dist\sdk\include" /I "C:\Program Files\Windows CE Tools\wce420\POCKET PC 2003\Include\Emulator" /D "NDEBUG" /D "_i386_" /D UNDER_CE=$(CEVersion) /D _WIN32_WCE=$(CEVersion) /D "$(CePlatform)" /D "i_386_" /D "UNICODE" /D "_UNICODE" /D "_X86_" /D "x86" /D "TRIMMED" /D CROSS_COMPILE=1 /D HAVE_MMINTRIN_H=1 /D X_DISPLAY_MISSING=1 /D MOZILLA_VERSION=\"1.8b2\" /D HAVE_SNPRINTF=1 /D _WINDOWS=1 /D _WIN32=1 /D WIN32=1 /D XP_WIN=1 /D XP_WIN32=1 /D HW_THREADS=1 /D STDC_HEADERS=1 /D WIN32_LEAN_AND_MEAN=1 /D D_INO=d_ino /D MOZ_DEFAULT_TOOLKIT=\"windows\" /D MOZ_BUILD_APP=suite /D MOZ_DISTRIBUTION_ID=\"org.mozilla\" /D OJI=1 /D IBMBIDI=1 /D MOZ_VIEW_SOURCE=1 /D MOZ_XTF=1 /D NS_DISABLE_LOGGING=1 /D MOZ_USER_DIR=\"Mozilla\" /D MOZ_DLL_SUFFIX=\".dll\" /D JS_THREADSAFE=1 /D NS_PRINT_PREVIEW=1 /D NS_PRINTING=1 /D MOZILLA_LOCALE_VERSION=\"1.8b2\" /D MOZILLA_REGION_VERSION=\"1.8b2\" /D MOZILLA_SKIN_VERSION=\"1.5\" /D "_MOZILLA_CONFIG_H_" /D "MOZILLA_CLIENT" /Fp"$(INTDIR)\XPTCInvoke_Testing.pch" /Yu"stdafx.h" /Fo"$(INTDIR)\\" /Gs8192 /GF /O2 /c 
+CPP_PROJ=/nologo /W3 /I "..\..\..\..\..\arm_ppc\dist\include" /I "..\..\..\..\..\arm_ppc\dist\include\xpcom" /I "..\..\..\..\..\arm_ppc\dist\sdk\include" /I "C:\Program Files\Windows CE Tools\wce420\POCKET PC 2003\Include\Emulator" /D "NDEBUG" /D "_i386_" /D UNDER_CE=$(CEVersion) /D _WIN32_WCE=$(CEVersion) /D "$(CePlatform)" /D "i_386_" /D "UNICODE" /D "_UNICODE" /D "_X86_" /D "x86" /D "TRIMMED" /D CROSS_COMPILE=1 /D HAVE_MMINTRIN_H=1 /D X_DISPLAY_MISSING=1 /D MOZILLA_VERSION=\"1.8b2\" /D HAVE_SNPRINTF=1 /D _WINDOWS=1 /D _WIN32=1 /D WIN32=1 /D XP_WIN=1 /D XP_WIN32=1 /D HW_THREADS=1 /D STDC_HEADERS=1 /D WIN32_LEAN_AND_MEAN=1 /D D_INO=d_ino /D MOZ_DEFAULT_TOOLKIT=\"windows\" /D MOZ_BUILD_APP=suite /D MOZ_DISTRIBUTION_ID=\"org.mozilla\" /D OJI=1 /D IBMBIDI=1 /D MOZ_VIEW_SOURCE=1 /D MOZ_XTF=1 /D NS_DISABLE_LOGGING=1 /D MOZ_USER_DIR=\"Mozilla\" /D MOZ_DLL_SUFFIX=\".dll\" /D JS_THREADSAFE=1 /D NS_PRINT_PREVIEW=1 /D NS_PRINTING=1 /D "_MOZILLA_CONFIG_H_" /D "MOZILLA_CLIENT" /Fp"$(INTDIR)\XPTCInvoke_Testing.pch" /Yu"stdafx.h" /Fo"$(INTDIR)\\" /Gs8192 /GF /O2 /c 
 
 .c{$(INTDIR)}.obj::
    $(CPP) @<<
    $(CPP_PROJ) $< 
 <<
 
 .cpp{$(INTDIR)}.obj::
    $(CPP) @<<
@@ -158,17 +158,17 @@ CLEAN :
 	-@erase "$(OUTDIR)\XPTCInvoke_Testing.pdb"
 
 "$(OUTDIR)" :
     if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
 
 RSC=rc.exe
 RSC_PROJ=/l 0x409 /fo"$(INTDIR)\XPTCInvoke_Testing.res" /i "C:\Program Files\Windows CE Tools\wce420\POCKET PC 2003\Include\Emulator" /d "$(CePlatform)" /d UNDER_CE=$(CEVersion) /d _WIN32_WCE=$(CEVersion) /d "UNICODE" /d "_UNICODE" /d "DEBUG" /d "_X86_" /d "x86" /d "_i386_" /r 
 CPP=cl.exe
-CPP_PROJ=/nologo /W3 /Zi /Od /I "..\..\..\..\..\arm_ppc\dist\include" /I "..\..\..\..\..\arm_ppc\dist\include\xpcom" /I "..\..\..\..\..\arm_ppc\dist\sdk\include" /I "C:\Program Files\Windows CE Tools\wce420\POCKET PC 2003\Include\Emulator" /D "DEBUG" /D "_i386_" /D UNDER_CE=$(CEVersion) /D _WIN32_WCE=$(CEVersion) /D "$(CePlatform)" /D "i_386_" /D "UNICODE" /D "_UNICODE" /D "_X86_" /D "x86" /D "TRIMMED" /D CROSS_COMPILE=1 /D HAVE_MMINTRIN_H=1 /D X_DISPLAY_MISSING=1 /D MOZILLA_VERSION=\"1.8b2\" /D HAVE_SNPRINTF=1 /D _WINDOWS=1 /D _WIN32=1 /D WIN32=1 /D XP_WIN=1 /D XP_WIN32=1 /D HW_THREADS=1 /D STDC_HEADERS=1 /D WIN32_LEAN_AND_MEAN=1 /D D_INO=d_ino /D MOZ_DEFAULT_TOOLKIT=\"windows\" /D MOZ_BUILD_APP=suite /D MOZ_DISTRIBUTION_ID=\"org.mozilla\" /D OJI=1 /D IBMBIDI=1 /D MOZ_VIEW_SOURCE=1 /D MOZ_XTF=1 /D NS_DISABLE_LOGGING=1 /D MOZ_USER_DIR=\"Mozilla\" /D MOZ_DLL_SUFFIX=\".dll\" /D JS_THREADSAFE=1 /D NS_PRINT_PREVIEW=1 /D NS_PRINTING=1 /D MOZILLA_LOCALE_VERSION=\"1.8b2\" /D MOZILLA_REGION_VERSION=\"1.8b2\" /D MOZILLA_SKIN_VERSION=\"1.5\" /D "_MOZILLA_CONFIG_H_" /D "MOZILLA_CLIENT" /Fp"$(INTDIR)\XPTCInvoke_Testing.pch" /Yu"stdafx.h" /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /Gs8192 /GF /c 
+CPP_PROJ=/nologo /W3 /Zi /Od /I "..\..\..\..\..\arm_ppc\dist\include" /I "..\..\..\..\..\arm_ppc\dist\include\xpcom" /I "..\..\..\..\..\arm_ppc\dist\sdk\include" /I "C:\Program Files\Windows CE Tools\wce420\POCKET PC 2003\Include\Emulator" /D "DEBUG" /D "_i386_" /D UNDER_CE=$(CEVersion) /D _WIN32_WCE=$(CEVersion) /D "$(CePlatform)" /D "i_386_" /D "UNICODE" /D "_UNICODE" /D "_X86_" /D "x86" /D "TRIMMED" /D CROSS_COMPILE=1 /D HAVE_MMINTRIN_H=1 /D X_DISPLAY_MISSING=1 /D MOZILLA_VERSION=\"1.8b2\" /D HAVE_SNPRINTF=1 /D _WINDOWS=1 /D _WIN32=1 /D WIN32=1 /D XP_WIN=1 /D XP_WIN32=1 /D HW_THREADS=1 /D STDC_HEADERS=1 /D WIN32_LEAN_AND_MEAN=1 /D D_INO=d_ino /D MOZ_DEFAULT_TOOLKIT=\"windows\" /D MOZ_BUILD_APP=suite /D MOZ_DISTRIBUTION_ID=\"org.mozilla\" /D OJI=1 /D IBMBIDI=1 /D MOZ_VIEW_SOURCE=1 /D MOZ_XTF=1 /D NS_DISABLE_LOGGING=1 /D MOZ_USER_DIR=\"Mozilla\" /D MOZ_DLL_SUFFIX=\".dll\" /D JS_THREADSAFE=1 /D NS_PRINT_PREVIEW=1 /D NS_PRINTING=1 /D "_MOZILLA_CONFIG_H_" /D "MOZILLA_CLIENT" /Fp"$(INTDIR)\XPTCInvoke_Testing.pch" /Yu"stdafx.h" /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /Gs8192 /GF /c 
 
 .c{$(INTDIR)}.obj::
    $(CPP) @<<
    $(CPP_PROJ) $< 
 <<
 
 .cpp{$(INTDIR)}.obj::
    $(CPP) @<<
@@ -234,17 +234,17 @@ CLEAN :
 	-@erase "$(OUTDIR)\XPTCInvoke_Testing.exe"
 
 "$(OUTDIR)" :
     if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
 
 RSC=rc.exe
 RSC_PROJ=/l 0x409 /fo"$(INTDIR)\XPTCInvoke_Testing.res" /i "C:\Program Files\Windows CE Tools\wce420\POCKET PC 2003\Include\Armv4" /d UNDER_CE=$(CEVersion) /d _WIN32_WCE=$(CEVersion) /d "NDEBUG" /d "UNICODE" /d "_UNICODE" /d "$(CePlatform)" /d "ARM" /d "_ARM_" /d "ARMV4" /r 
 CPP=clarm.exe
-CPP_PROJ=/nologo /W3 /I "..\..\..\..\..\arm_ppc\dist\include" /I "..\..\..\..\..\arm_ppc\dist\include\xpcom" /I "..\..\..\..\..\arm_ppc\dist\sdk\include" /I "C:\Program Files\Windows CE Tools\wce420\POCKET PC 2003\Include\Armv4" /D "NDEBUG" /D "ARM" /D "_ARM_" /D "ARMV4" /D UNDER_CE=$(CEVersion) /D _WIN32_WCE=$(CEVersion) /D "$(CePlatform)" /D "UNICODE" /D "_UNICODE" /D "TRIMMED" /D CROSS_COMPILE=1 /D HAVE_MMINTRIN_H=1 /D X_DISPLAY_MISSING=1 /D MOZILLA_VERSION=\"1.8b2\" /D HAVE_SNPRINTF=1 /D _WINDOWS=1 /D _WIN32=1 /D WIN32=1 /D XP_WIN=1 /D XP_WIN32=1 /D HW_THREADS=1 /D STDC_HEADERS=1 /D WIN32_LEAN_AND_MEAN=1 /D D_INO=d_ino /D MOZ_DEFAULT_TOOLKIT=\"windows\" /D MOZ_BUILD_APP=suite /D MOZ_DISTRIBUTION_ID=\"org.mozilla\" /D OJI=1 /D IBMBIDI=1 /D MOZ_VIEW_SOURCE=1 /D MOZ_XTF=1 /D NS_DISABLE_LOGGING=1 /D MOZ_USER_DIR=\"Mozilla\" /D MOZ_DLL_SUFFIX=\".dll\" /D JS_THREADSAFE=1 /D NS_PRINT_PREVIEW=1 /D NS_PRINTING=1 /D MOZILLA_LOCALE_VERSION=\"1.8b2\" /D MOZILLA_REGION_VERSION=\"1.8b2\" /D MOZILLA_SKIN_VERSION=\"1.5\" /D "_MOZILLA_CONFIG_H_" /D "MOZILLA_CLIENT" /Fp"$(INTDIR)\XPTCInvoke_Testing.pch" /Yu"stdafx.h" /Fo"$(INTDIR)\\" /O2 /M$(CECrtMT) /c 
+CPP_PROJ=/nologo /W3 /I "..\..\..\..\..\arm_ppc\dist\include" /I "..\..\..\..\..\arm_ppc\dist\include\xpcom" /I "..\..\..\..\..\arm_ppc\dist\sdk\include" /I "C:\Program Files\Windows CE Tools\wce420\POCKET PC 2003\Include\Armv4" /D "NDEBUG" /D "ARM" /D "_ARM_" /D "ARMV4" /D UNDER_CE=$(CEVersion) /D _WIN32_WCE=$(CEVersion) /D "$(CePlatform)" /D "UNICODE" /D "_UNICODE" /D "TRIMMED" /D CROSS_COMPILE=1 /D HAVE_MMINTRIN_H=1 /D X_DISPLAY_MISSING=1 /D MOZILLA_VERSION=\"1.8b2\" /D HAVE_SNPRINTF=1 /D _WINDOWS=1 /D _WIN32=1 /D WIN32=1 /D XP_WIN=1 /D XP_WIN32=1 /D HW_THREADS=1 /D STDC_HEADERS=1 /D WIN32_LEAN_AND_MEAN=1 /D D_INO=d_ino /D MOZ_DEFAULT_TOOLKIT=\"windows\" /D MOZ_BUILD_APP=suite /D MOZ_DISTRIBUTION_ID=\"org.mozilla\" /D OJI=1 /D IBMBIDI=1 /D MOZ_VIEW_SOURCE=1 /D MOZ_XTF=1 /D NS_DISABLE_LOGGING=1 /D MOZ_USER_DIR=\"Mozilla\" /D MOZ_DLL_SUFFIX=\".dll\" /D JS_THREADSAFE=1 /D NS_PRINT_PREVIEW=1 /D NS_PRINTING=1 /D "_MOZILLA_CONFIG_H_" /D "MOZILLA_CLIENT" /Fp"$(INTDIR)\XPTCInvoke_Testing.pch" /Yu"stdafx.h" /Fo"$(INTDIR)\\" /O2 /M$(CECrtMT) /c 
 
 .c{$(INTDIR)}.obj::
    $(CPP) @<<
    $(CPP_PROJ) $< 
 <<
 
 .cpp{$(INTDIR)}.obj::
    $(CPP) @<<
@@ -313,17 +313,17 @@ CLEAN :
 	-@erase "$(OUTDIR)\XPTCInvoke_Testing.pdb"
 
 "$(OUTDIR)" :
     if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
 
 RSC=rc.exe
 RSC_PROJ=/l 0x409 /fo"$(INTDIR)\XPTCInvoke_Testing.res" /i "C:\Program Files\Windows CE Tools\wce420\POCKET PC 2003\Include\Armv4" /d UNDER_CE=$(CEVersion) /d _WIN32_WCE=$(CEVersion) /d "DEBUG" /d "UNICODE" /d "_UNICODE" /d "$(CePlatform)" /d "ARM" /d "_ARM_" /d "ARMV4" /r 
 CPP=clarm.exe
-CPP_PROJ=/nologo /W3 /Zi /Od /I "..\..\..\..\..\arm_ppc\dist\include" /I "..\..\..\..\..\arm_ppc\dist\include\xpcom" /I "..\..\..\..\..\arm_ppc\dist\sdk\include" /I "C:\Program Files\Windows CE Tools\wce420\POCKET PC 2003\Include\Armv4" /D "$(CePlatform)" /D "ARM" /D "ARMV4" /D CANT_RESOLVE_CPP_CONST_AMBIGUITY=1 /D CROSS_COMPILE=1 /D "DEBUG" /D "DEBUG_dougt" /D D_INO=d_ino /D gid_t=int /D HAVE_COMPAT_H=1 /D HAVE_GETOPT_H=1 /D HAVE_GNU_LIBC_VERSION_H=1 /D HAVE_LIBM=1 /D HAVE_MALLOC_H=1 /D HAVE_MEMMOVE=1 /D HAVE_MEMORY_H=1 /D HAVE_MMINTRIN_H=1 /D HAVE_NL_TYPES_H=1 /D HAVE_SNPRINTF=1 /D HAVE_SYS_BITYPES_H=1 /D HAVE_SYS_STATFS_H=1 /D HAVE_SYS_STATVFS_H=1 /D HAVE_UINT=1 /D HAVE_UNISTD_H=1 /D HAVE_X11_XKBLIB_H=1 /D HW_THREADS=1 /D IBMBIDI=1 /D JS_THREADSAFE=1 /D mode_t=int /D "MOZILLA_CLIENT" /D MOZILLA_LOCALE_VERSION=\"1.8b2\" /D MOZILLA_REGION_VERSION=\"1.8b2\" /D MOZILLA_SKIN_VERSION=\"1.5\" /D MOZILLA_VERSION=\"1.8b2\" /D MOZ_APP_NAME=\"mozilla\" /D MOZ_BUILD_APP=suite /D MOZ_DEFAULT_TOOLKIT=\"windows\" /D MOZ_DISTRIBUTION_ID=\"org.mozilla\" /D MOZ_DLL_SUFFIX=\".dll\" /D MOZ_ENABLE_COREXFONTS=1 /D MOZ_USER_DIR=\"Mozilla\" /D MOZ_V1_STRING_ABI=1 /D MOZ_VIEW_SOURCE=1 /D MOZ_XTF=1 /D\
+CPP_PROJ=/nologo /W3 /Zi /Od /I "..\..\..\..\..\arm_ppc\dist\include" /I "..\..\..\..\..\arm_ppc\dist\include\xpcom" /I "..\..\..\..\..\arm_ppc\dist\sdk\include" /I "C:\Program Files\Windows CE Tools\wce420\POCKET PC 2003\Include\Armv4" /D "$(CePlatform)" /D "ARM" /D "ARMV4" /D CANT_RESOLVE_CPP_CONST_AMBIGUITY=1 /D CROSS_COMPILE=1 /D "DEBUG" /D "DEBUG_dougt" /D D_INO=d_ino /D gid_t=int /D HAVE_COMPAT_H=1 /D HAVE_GETOPT_H=1 /D HAVE_GNU_LIBC_VERSION_H=1 /D HAVE_LIBM=1 /D HAVE_MALLOC_H=1 /D HAVE_MEMMOVE=1 /D HAVE_MEMORY_H=1 /D HAVE_MMINTRIN_H=1 /D HAVE_NL_TYPES_H=1 /D HAVE_SNPRINTF=1 /D HAVE_SYS_BITYPES_H=1 /D HAVE_SYS_STATFS_H=1 /D HAVE_SYS_STATVFS_H=1 /D HAVE_UINT=1 /D HAVE_UNISTD_H=1 /D HAVE_X11_XKBLIB_H=1 /D HW_THREADS=1 /D IBMBIDI=1 /D JS_THREADSAFE=1 /D mode_t=int /D "MOZILLA_CLIENT" /D MOZILLA_VERSION=\"1.8b2\" /D MOZ_APP_NAME=\"mozilla\" /D MOZ_BUILD_APP=suite /D MOZ_DEFAULT_TOOLKIT=\"windows\" /D MOZ_DISTRIBUTION_ID=\"org.mozilla\" /D MOZ_DLL_SUFFIX=\".dll\" /D MOZ_ENABLE_COREXFONTS=1 /D MOZ_USER_DIR=\"Mozilla\" /D MOZ_V1_STRING_ABI=1 /D MOZ_VIEW_SOURCE=1 /D MOZ_XTF=1 /D\
  NEED_CPP_DERIVED_TEMPLATE_OPERATORS=1 /D NEED_CPP_TEMPLATE_CAST_TO_BASE=1 /D NO_MINUS_C_MINUS_O=1 /D NO_X11=1 /D NSCAP_DONT_PROVIDE_NONCONST_OPEQ=1 /D NS_DISABLE_LOGGING=1 /D NS_PRINTING=1 /D NS_PRINT_PREVIEW=1 /D off_t=long /D OJI=1 /D OSARCH=\"WINCE\" /D OSTYPE=\"WINCE420\" /D pid_t=int /D size_t=unsigned /D STDC_HEADERS=1 /D "TRACING" /D "TRIMMED" /D uid_t=int /D UNDER_CE=$(CEVersion) /D "UNICODE" /D UNIX_ASYNC_DNS=1 /D WIN32=1 /D WIN32_LEAN_AND_MEAN=1 /D XP_WIN32=1 /D XP_WIN=1 /D X_DISPLAY_MISSING=1 /D "_ARM_" /D "_DEBUG" /D "_IMPL_NS_GFX" /D "_IMPL_NS_MSG_BASE" /D "_IMPL_NS_WIDGET" /D "_MOZILLA_CONFIG_H_" /D "_UNICODE" /D _WIN32=1 /D _WIN32_WCE=$(CEVersion) /D _WINDOWS=1 /Fp"$(INTDIR)\XPTCInvoke_Testing.pch" /Yu"stdafx.h" /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /M$(CECrtMTDebug) /c 
 
 .c{$(INTDIR)}.obj::
    $(CPP) @<<
    $(CPP_PROJ) $< 
 <<
 
 .cpp{$(INTDIR)}.obj::
@@ -382,47 +382,47 @@ LINK32_OBJS= \
 !ENDIF 
 
 
 !IF "$(CFG)" == "XPTCInvoke_Testing - Win32 (WCE emulator) Release" || "$(CFG)" == "XPTCInvoke_Testing - Win32 (WCE emulator) Debug" || "$(CFG)" == "XPTCInvoke_Testing - Win32 (WCE ARMV4) Release" || "$(CFG)" == "XPTCInvoke_Testing - Win32 (WCE ARMV4) Debug"
 SOURCE=.\StdAfx.cpp
 
 !IF  "$(CFG)" == "XPTCInvoke_Testing - Win32 (WCE emulator) Release"
 
-CPP_SWITCHES=/nologo /W3 /I "..\..\..\..\..\arm_ppc\dist\include" /I "..\..\..\..\..\arm_ppc\dist\include\xpcom" /I "..\..\..\..\..\arm_ppc\dist\sdk\include" /I "C:\Program Files\Windows CE Tools\wce420\POCKET PC 2003\Include\Emulator" /D "NDEBUG" /D "_i386_" /D UNDER_CE=$(CEVersion) /D _WIN32_WCE=$(CEVersion) /D "$(CePlatform)" /D "i_386_" /D "UNICODE" /D "_UNICODE" /D "_X86_" /D "x86" /D "TRIMMED" /D CROSS_COMPILE=1 /D HAVE_MMINTRIN_H=1 /D X_DISPLAY_MISSING=1 /D MOZILLA_VERSION=\"1.8b2\" /D HAVE_SNPRINTF=1 /D _WINDOWS=1 /D _WIN32=1 /D WIN32=1 /D XP_WIN=1 /D XP_WIN32=1 /D HW_THREADS=1 /D STDC_HEADERS=1 /D WIN32_LEAN_AND_MEAN=1 /D D_INO=d_ino /D MOZ_DEFAULT_TOOLKIT=\"windows\" /D MOZ_BUILD_APP=suite /D MOZ_DISTRIBUTION_ID=\"org.mozilla\" /D OJI=1 /D IBMBIDI=1 /D MOZ_VIEW_SOURCE=1 /D MOZ_XTF=1 /D NS_DISABLE_LOGGING=1 /D MOZ_USER_DIR=\"Mozilla\" /D MOZ_DLL_SUFFIX=\".dll\" /D JS_THREADSAFE=1 /D NS_PRINT_PREVIEW=1 /D NS_PRINTING=1 /D MOZILLA_LOCALE_VERSION=\"1.8b2\" /D MOZILLA_REGION_VERSION=\"1.8b2\" /D MOZILLA_SKIN_VERSION=\"1.5\" /D "_MOZILLA_CONFIG_H_" /D "MOZILLA_CLIENT" /Fp"$(INTDIR)\XPTCInvoke_Testing.pch" /Yc"stdafx.h" /Fo"$(INTDIR)\\" /Gs8192 /GF /O2 /c 
+CPP_SWITCHES=/nologo /W3 /I "..\..\..\..\..\arm_ppc\dist\include" /I "..\..\..\..\..\arm_ppc\dist\include\xpcom" /I "..\..\..\..\..\arm_ppc\dist\sdk\include" /I "C:\Program Files\Windows CE Tools\wce420\POCKET PC 2003\Include\Emulator" /D "NDEBUG" /D "_i386_" /D UNDER_CE=$(CEVersion) /D _WIN32_WCE=$(CEVersion) /D "$(CePlatform)" /D "i_386_" /D "UNICODE" /D "_UNICODE" /D "_X86_" /D "x86" /D "TRIMMED" /D CROSS_COMPILE=1 /D HAVE_MMINTRIN_H=1 /D X_DISPLAY_MISSING=1 /D MOZILLA_VERSION=\"1.8b2\" /D HAVE_SNPRINTF=1 /D _WINDOWS=1 /D _WIN32=1 /D WIN32=1 /D XP_WIN=1 /D XP_WIN32=1 /D HW_THREADS=1 /D STDC_HEADERS=1 /D WIN32_LEAN_AND_MEAN=1 /D D_INO=d_ino /D MOZ_DEFAULT_TOOLKIT=\"windows\" /D MOZ_BUILD_APP=suite /D MOZ_DISTRIBUTION_ID=\"org.mozilla\" /D OJI=1 /D IBMBIDI=1 /D MOZ_VIEW_SOURCE=1 /D MOZ_XTF=1 /D NS_DISABLE_LOGGING=1 /D MOZ_USER_DIR=\"Mozilla\" /D MOZ_DLL_SUFFIX=\".dll\" /D JS_THREADSAFE=1 /D NS_PRINT_PREVIEW=1 /D NS_PRINTING=1 /D "_MOZILLA_CONFIG_H_" /D "MOZILLA_CLIENT" /Fp"$(INTDIR)\XPTCInvoke_Testing.pch" /Yc"stdafx.h" /Fo"$(INTDIR)\\" /Gs8192 /GF /O2 /c 
 
 "$(INTDIR)\StdAfx.obj"	"$(INTDIR)\XPTCInvoke_Testing.pch" : $(SOURCE) "$(INTDIR)"
 	$(CPP) @<<
   $(CPP_SWITCHES) $(SOURCE)
 <<
 
 
 !ELSEIF  "$(CFG)" == "XPTCInvoke_Testing - Win32 (WCE emulator) Debug"
 
-CPP_SWITCHES=/nologo /W3 /Zi /Od /I "..\..\..\..\..\arm_ppc\dist\include" /I "..\..\..\..\..\arm_ppc\dist\include\xpcom" /I "..\..\..\..\..\arm_ppc\dist\sdk\include" /I "C:\Program Files\Windows CE Tools\wce420\POCKET PC 2003\Include\Emulator" /D "DEBUG" /D "_i386_" /D UNDER_CE=$(CEVersion) /D _WIN32_WCE=$(CEVersion) /D "$(CePlatform)" /D "i_386_" /D "UNICODE" /D "_UNICODE" /D "_X86_" /D "x86" /D "TRIMMED" /D CROSS_COMPILE=1 /D HAVE_MMINTRIN_H=1 /D X_DISPLAY_MISSING=1 /D MOZILLA_VERSION=\"1.8b2\" /D HAVE_SNPRINTF=1 /D _WINDOWS=1 /D _WIN32=1 /D WIN32=1 /D XP_WIN=1 /D XP_WIN32=1 /D HW_THREADS=1 /D STDC_HEADERS=1 /D WIN32_LEAN_AND_MEAN=1 /D D_INO=d_ino /D MOZ_DEFAULT_TOOLKIT=\"windows\" /D MOZ_BUILD_APP=suite /D MOZ_DISTRIBUTION_ID=\"org.mozilla\" /D OJI=1 /D IBMBIDI=1 /D MOZ_VIEW_SOURCE=1 /D MOZ_XTF=1 /D NS_DISABLE_LOGGING=1 /D MOZ_USER_DIR=\"Mozilla\" /D MOZ_DLL_SUFFIX=\".dll\" /D JS_THREADSAFE=1 /D NS_PRINT_PREVIEW=1 /D NS_PRINTING=1 /D MOZILLA_LOCALE_VERSION=\"1.8b2\" /D MOZILLA_REGION_VERSION=\"1.8b2\" /D MOZILLA_SKIN_VERSION=\"1.5\" /D "_MOZILLA_CONFIG_H_" /D "MOZILLA_CLIENT" /Fp"$(INTDIR)\XPTCInvoke_Testing.pch" /Yc"stdafx.h" /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /Gs8192 /GF /c 
+CPP_SWITCHES=/nologo /W3 /Zi /Od /I "..\..\..\..\..\arm_ppc\dist\include" /I "..\..\..\..\..\arm_ppc\dist\include\xpcom" /I "..\..\..\..\..\arm_ppc\dist\sdk\include" /I "C:\Program Files\Windows CE Tools\wce420\POCKET PC 2003\Include\Emulator" /D "DEBUG" /D "_i386_" /D UNDER_CE=$(CEVersion) /D _WIN32_WCE=$(CEVersion) /D "$(CePlatform)" /D "i_386_" /D "UNICODE" /D "_UNICODE" /D "_X86_" /D "x86" /D "TRIMMED" /D CROSS_COMPILE=1 /D HAVE_MMINTRIN_H=1 /D X_DISPLAY_MISSING=1 /D MOZILLA_VERSION=\"1.8b2\" /D HAVE_SNPRINTF=1 /D _WINDOWS=1 /D _WIN32=1 /D WIN32=1 /D XP_WIN=1 /D XP_WIN32=1 /D HW_THREADS=1 /D STDC_HEADERS=1 /D WIN32_LEAN_AND_MEAN=1 /D D_INO=d_ino /D MOZ_DEFAULT_TOOLKIT=\"windows\" /D MOZ_BUILD_APP=suite /D MOZ_DISTRIBUTION_ID=\"org.mozilla\" /D OJI=1 /D IBMBIDI=1 /D MOZ_VIEW_SOURCE=1 /D MOZ_XTF=1 /D NS_DISABLE_LOGGING=1 /D MOZ_USER_DIR=\"Mozilla\" /D MOZ_DLL_SUFFIX=\".dll\" /D JS_THREADSAFE=1 /D NS_PRINT_PREVIEW=1 /D NS_PRINTING=1 /D "_MOZILLA_CONFIG_H_" /D "MOZILLA_CLIENT" /Fp"$(INTDIR)\XPTCInvoke_Testing.pch" /Yc"stdafx.h" /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /Gs8192 /GF /c 
 
 "$(INTDIR)\StdAfx.obj"	"$(INTDIR)\XPTCInvoke_Testing.pch" : $(SOURCE) "$(INTDIR)"
 	$(CPP) @<<
   $(CPP_SWITCHES) $(SOURCE)
 <<
 
 
 !ELSEIF  "$(CFG)" == "XPTCInvoke_Testing - Win32 (WCE ARMV4) Release"
 
-CPP_SWITCHES=/nologo /W3 /I "..\..\..\..\..\arm_ppc\dist\include" /I "..\..\..\..\..\arm_ppc\dist\include\xpcom" /I "..\..\..\..\..\arm_ppc\dist\sdk\include" /I "C:\Program Files\Windows CE Tools\wce420\POCKET PC 2003\Include\Armv4" /D "NDEBUG" /D "ARM" /D "_ARM_" /D "ARMV4" /D UNDER_CE=$(CEVersion) /D _WIN32_WCE=$(CEVersion) /D "$(CePlatform)" /D "UNICODE" /D "_UNICODE" /D "TRIMMED" /D CROSS_COMPILE=1 /D HAVE_MMINTRIN_H=1 /D X_DISPLAY_MISSING=1 /D MOZILLA_VERSION=\"1.8b2\" /D HAVE_SNPRINTF=1 /D _WINDOWS=1 /D _WIN32=1 /D WIN32=1 /D XP_WIN=1 /D XP_WIN32=1 /D HW_THREADS=1 /D STDC_HEADERS=1 /D WIN32_LEAN_AND_MEAN=1 /D D_INO=d_ino /D MOZ_DEFAULT_TOOLKIT=\"windows\" /D MOZ_BUILD_APP=suite /D MOZ_DISTRIBUTION_ID=\"org.mozilla\" /D OJI=1 /D IBMBIDI=1 /D MOZ_VIEW_SOURCE=1 /D MOZ_XTF=1 /D NS_DISABLE_LOGGING=1 /D MOZ_USER_DIR=\"Mozilla\" /D MOZ_DLL_SUFFIX=\".dll\" /D JS_THREADSAFE=1 /D NS_PRINT_PREVIEW=1 /D NS_PRINTING=1 /D MOZILLA_LOCALE_VERSION=\"1.8b2\" /D MOZILLA_REGION_VERSION=\"1.8b2\" /D MOZILLA_SKIN_VERSION=\"1.5\" /D "_MOZILLA_CONFIG_H_" /D "MOZILLA_CLIENT" /Fp"$(INTDIR)\XPTCInvoke_Testing.pch" /Yc"stdafx.h" /Fo"$(INTDIR)\\" /O2 /M$(CECrtMT) /c 
+CPP_SWITCHES=/nologo /W3 /I "..\..\..\..\..\arm_ppc\dist\include" /I "..\..\..\..\..\arm_ppc\dist\include\xpcom" /I "..\..\..\..\..\arm_ppc\dist\sdk\include" /I "C:\Program Files\Windows CE Tools\wce420\POCKET PC 2003\Include\Armv4" /D "NDEBUG" /D "ARM" /D "_ARM_" /D "ARMV4" /D UNDER_CE=$(CEVersion) /D _WIN32_WCE=$(CEVersion) /D "$(CePlatform)" /D "UNICODE" /D "_UNICODE" /D "TRIMMED" /D CROSS_COMPILE=1 /D HAVE_MMINTRIN_H=1 /D X_DISPLAY_MISSING=1 /D MOZILLA_VERSION=\"1.8b2\" /D HAVE_SNPRINTF=1 /D _WINDOWS=1 /D _WIN32=1 /D WIN32=1 /D XP_WIN=1 /D XP_WIN32=1 /D HW_THREADS=1 /D STDC_HEADERS=1 /D WIN32_LEAN_AND_MEAN=1 /D D_INO=d_ino /D MOZ_DEFAULT_TOOLKIT=\"windows\" /D MOZ_BUILD_APP=suite /D MOZ_DISTRIBUTION_ID=\"org.mozilla\" /D OJI=1 /D IBMBIDI=1 /D MOZ_VIEW_SOURCE=1 /D MOZ_XTF=1 /D NS_DISABLE_LOGGING=1 /D MOZ_USER_DIR=\"Mozilla\" /D MOZ_DLL_SUFFIX=\".dll\" /D JS_THREADSAFE=1 /D NS_PRINT_PREVIEW=1 /D NS_PRINTING=1 /D "_MOZILLA_CONFIG_H_" /D "MOZILLA_CLIENT" /Fp"$(INTDIR)\XPTCInvoke_Testing.pch" /Yc"stdafx.h" /Fo"$(INTDIR)\\" /O2 /M$(CECrtMT) /c 
 
 "$(INTDIR)\StdAfx.obj"	"$(INTDIR)\XPTCInvoke_Testing.pch" : $(SOURCE) "$(INTDIR)"
 	$(CPP) @<<
   $(CPP_SWITCHES) $(SOURCE)
 <<
 
 
 !ELSEIF  "$(CFG)" == "XPTCInvoke_Testing - Win32 (WCE ARMV4) Debug"
 
-CPP_SWITCHES=/nologo /W3 /Zi /Od /I "..\..\..\..\..\arm_ppc\dist\include" /I "..\..\..\..\..\arm_ppc\dist\include\xpcom" /I "..\..\..\..\..\arm_ppc\dist\sdk\include" /I "C:\Program Files\Windows CE Tools\wce420\POCKET PC 2003\Include\Armv4" /D "$(CePlatform)" /D "ARM" /D "ARMV4" /D CANT_RESOLVE_CPP_CONST_AMBIGUITY=1 /D CROSS_COMPILE=1 /D "DEBUG" /D "DEBUG_dougt" /D D_INO=d_ino /D gid_t=int /D HAVE_COMPAT_H=1 /D HAVE_GETOPT_H=1 /D HAVE_GNU_LIBC_VERSION_H=1 /D HAVE_LIBM=1 /D HAVE_MALLOC_H=1 /D HAVE_MEMMOVE=1 /D HAVE_MEMORY_H=1 /D HAVE_MMINTRIN_H=1 /D HAVE_NL_TYPES_H=1 /D HAVE_SNPRINTF=1 /D HAVE_SYS_BITYPES_H=1 /D HAVE_SYS_STATFS_H=1 /D HAVE_SYS_STATVFS_H=1 /D HAVE_UINT=1 /D HAVE_UNISTD_H=1 /D HAVE_X11_XKBLIB_H=1 /D HW_THREADS=1 /D IBMBIDI=1 /D JS_THREADSAFE=1 /D mode_t=int /D "MOZILLA_CLIENT" /D MOZILLA_LOCALE_VERSION=\"1.8b2\" /D MOZILLA_REGION_VERSION=\"1.8b2\" /D MOZILLA_SKIN_VERSION=\"1.5\" /D MOZILLA_VERSION=\"1.8b2\" /D MOZ_APP_NAME=\"mozilla\" /D MOZ_BUILD_APP=suite /D MOZ_DEFAULT_TOOLKIT=\"windows\" /D MOZ_DISTRIBUTION_ID=\"org.mozilla\" /D MOZ_DLL_SUFFIX=\".dll\" /D MOZ_ENABLE_COREXFONTS=1 /D MOZ_USER_DIR=\"Mozilla\" /D MOZ_V1_STRING_ABI=1 /D MOZ_VIEW_SOURCE=1 /D MOZ_XTF=1\
+CPP_SWITCHES=/nologo /W3 /Zi /Od /I "..\..\..\..\..\arm_ppc\dist\include" /I "..\..\..\..\..\arm_ppc\dist\include\xpcom" /I "..\..\..\..\..\arm_ppc\dist\sdk\include" /I "C:\Program Files\Windows CE Tools\wce420\POCKET PC 2003\Include\Armv4" /D "$(CePlatform)" /D "ARM" /D "ARMV4" /D CANT_RESOLVE_CPP_CONST_AMBIGUITY=1 /D CROSS_COMPILE=1 /D "DEBUG" /D "DEBUG_dougt" /D D_INO=d_ino /D gid_t=int /D HAVE_COMPAT_H=1 /D HAVE_GETOPT_H=1 /D HAVE_GNU_LIBC_VERSION_H=1 /D HAVE_LIBM=1 /D HAVE_MALLOC_H=1 /D HAVE_MEMMOVE=1 /D HAVE_MEMORY_H=1 /D HAVE_MMINTRIN_H=1 /D HAVE_NL_TYPES_H=1 /D HAVE_SNPRINTF=1 /D HAVE_SYS_BITYPES_H=1 /D HAVE_SYS_STATFS_H=1 /D HAVE_SYS_STATVFS_H=1 /D HAVE_UINT=1 /D HAVE_UNISTD_H=1 /D HAVE_X11_XKBLIB_H=1 /D HW_THREADS=1 /D IBMBIDI=1 /D JS_THREADSAFE=1 /D mode_t=int /D "MOZILLA_CLIENT" /D MOZILLA_VERSION=\"1.8b2\" /D MOZ_APP_NAME=\"mozilla\" /D MOZ_BUILD_APP=suite /D MOZ_DEFAULT_TOOLKIT=\"windows\" /D MOZ_DISTRIBUTION_ID=\"org.mozilla\" /D MOZ_DLL_SUFFIX=\".dll\" /D MOZ_ENABLE_COREXFONTS=1 /D MOZ_USER_DIR=\"Mozilla\" /D MOZ_V1_STRING_ABI=1 /D MOZ_VIEW_SOURCE=1 /D MOZ_XTF=1\
  /D NEED_CPP_DERIVED_TEMPLATE_OPERATORS=1 /D NEED_CPP_TEMPLATE_CAST_TO_BASE=1 /D NO_MINUS_C_MINUS_O=1 /D NO_X11=1 /D NSCAP_DONT_PROVIDE_NONCONST_OPEQ=1 /D NS_DISABLE_LOGGING=1 /D NS_PRINTING=1 /D NS_PRINT_PREVIEW=1 /D off_t=long /D OJI=1 /D OSARCH=\"WINCE\" /D OSTYPE=\"WINCE420\" /D pid_t=int /D size_t=unsigned /D STDC_HEADERS=1 /D "TRACING" /D "TRIMMED" /D uid_t=int /D UNDER_CE=$(CEVersion) /D "UNICODE" /D UNIX_ASYNC_DNS=1 /D WIN32=1 /D WIN32_LEAN_AND_MEAN=1 /D XP_WIN32=1 /D XP_WIN=1 /D X_DISPLAY_MISSING=1 /D "_ARM_" /D "_DEBUG" /D "_IMPL_NS_GFX" /D "_IMPL_NS_MSG_BASE" /D "_IMPL_NS_WIDGET" /D "_MOZILLA_CONFIG_H_" /D "_UNICODE" /D _WIN32=1 /D _WIN32_WCE=$(CEVersion) /D _WINDOWS=1 /Fp"$(INTDIR)\XPTCInvoke_Testing.pch" /Yc"stdafx.h" /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /M$(CECrtMTDebug) /c 
 
 "$(INTDIR)\StdAfx.obj"	"$(INTDIR)\XPTCInvoke_Testing.pch" : $(SOURCE) "$(INTDIR)"
 	$(CPP) @<<
   $(CPP_SWITCHES) $(SOURCE)
 <<
 
 
diff -r b7bcdd009540 xpcom/reflect/xptcall/tests/eVC4/XPTCInvoke_Testing.vcp
--- a/xpcom/reflect/xptcall/tests/eVC4/XPTCInvoke_Testing.vcp	Mon Sep 08 00:36:19 2008 -0700
+++ b/xpcom/reflect/xptcall/tests/eVC4/XPTCInvoke_Testing.vcp	Thu Sep 11 15:19:29 2008 +0300
@@ -46,17 +46,17 @@ CFG=XPTCInvoke_Testing - Win32 (WCE emul
 # PROP CPU_ID "{32E52003-403E-442D-BE48-DE10F8C6131D}"
 # PROP Platform_ID "{8A9A2F80-6887-11D3-842E-005004848CBA}"
 # PROP Target_Dir ""
 RSC=rc.exe
 # ADD BASE RSC /l 0x409 /d UNDER_CE=$(CEVersion) /d _WIN32_WCE=$(CEVersion) /d "UNICODE" /d "_UNICODE" /d "NDEBUG" /d "$(CePlatform)" /d "_X86_" /d "x86" /d "_i386_" /r
 # ADD RSC /l 0x409 /i "C:\Program Files\Windows CE Tools\wce420\POCKET PC 2003\Include\Emulator" /d UNDER_CE=$(CEVersion) /d _WIN32_WCE=$(CEVersion) /d "UNICODE" /d "_UNICODE" /d "NDEBUG" /d "$(CePlatform)" /d "_X86_" /d "x86" /d "_i386_" /r
 CPP=cl.exe
 # ADD BASE CPP /nologo /W3 /D _WIN32_WCE=$(CEVersion) /D "$(CePlatform)" /D "_i386_" /D UNDER_CE=$(CEVersion) /D "i_386_" /D "UNICODE" /D "_UNICODE" /D "_X86_" /D "x86" /D "NDEBUG" /Yu"stdafx.h" /Gs8192 /GF /O2 /c
-# ADD CPP /nologo /W3 /I "..\..\..\..\..\arm_ppc\dist\include" /I "..\..\..\..\..\arm_ppc\dist\include\xpcom" /I "..\..\..\..\..\arm_ppc\dist\sdk\include" /I "C:\Program Files\Windows CE Tools\wce420\POCKET PC 2003\Include\Emulator" /D "NDEBUG" /D "_i386_" /D UNDER_CE=$(CEVersion) /D _WIN32_WCE=$(CEVersion) /D "$(CePlatform)" /D "i_386_" /D "UNICODE" /D "_UNICODE" /D "_X86_" /D "x86" /D "TRIMMED" /D CROSS_COMPILE=1 /D HAVE_MMINTRIN_H=1 /D X_DISPLAY_MISSING=1 /D MOZILLA_VERSION=\"1.8b2\" /D HAVE_SNPRINTF=1 /D _WINDOWS=1 /D _WIN32=1 /D WIN32=1 /D XP_WIN=1 /D XP_WIN32=1 /D HW_THREADS=1 /D STDC_HEADERS=1 /D WIN32_LEAN_AND_MEAN=1 /D D_INO=d_ino /D MOZ_DEFAULT_TOOLKIT=\"windows\" /D MOZ_BUILD_APP=suite /D MOZ_DISTRIBUTION_ID=\"org.mozilla\" /D OJI=1 /D IBMBIDI=1 /D MOZ_VIEW_SOURCE=1 /D MOZ_XTF=1 /D NS_DISABLE_LOGGING=1 /D MOZ_USER_DIR=\"Mozilla\" /D MOZ_DLL_SUFFIX=\".dll\" /D JS_THREADSAFE=1 /D NS_PRINT_PREVIEW=1 /D NS_PRINTING=1 /D MOZILLA_LOCALE_VERSION=\"1.8b2\" /D MOZILLA_REGION_VERSION=\"1.8b2\" /D MOZILLA_SKIN_VERSION=\"1.5\" /D "_MOZILLA_CONFIG_H_" /D "MOZILLA_CLIENT" /Yu"stdafx.h" /Gs8192 /GF /O2 /c
+# ADD CPP /nologo /W3 /I "..\..\..\..\..\arm_ppc\dist\include" /I "..\..\..\..\..\arm_ppc\dist\include\xpcom" /I "..\..\..\..\..\arm_ppc\dist\sdk\include" /I "C:\Program Files\Windows CE Tools\wce420\POCKET PC 2003\Include\Emulator" /D "NDEBUG" /D "_i386_" /D UNDER_CE=$(CEVersion) /D _WIN32_WCE=$(CEVersion) /D "$(CePlatform)" /D "i_386_" /D "UNICODE" /D "_UNICODE" /D "_X86_" /D "x86" /D "TRIMMED" /D CROSS_COMPILE=1 /D HAVE_MMINTRIN_H=1 /D X_DISPLAY_MISSING=1 /D MOZILLA_VERSION=\"1.8b2\" /D HAVE_SNPRINTF=1 /D _WINDOWS=1 /D _WIN32=1 /D WIN32=1 /D XP_WIN=1 /D XP_WIN32=1 /D HW_THREADS=1 /D STDC_HEADERS=1 /D WIN32_LEAN_AND_MEAN=1 /D D_INO=d_ino /D MOZ_DEFAULT_TOOLKIT=\"windows\" /D MOZ_BUILD_APP=suite /D MOZ_DISTRIBUTION_ID=\"org.mozilla\" /D OJI=1 /D IBMBIDI=1 /D MOZ_VIEW_SOURCE=1 /D MOZ_XTF=1 /D NS_DISABLE_LOGGING=1 /D MOZ_USER_DIR=\"Mozilla\" /D MOZ_DLL_SUFFIX=\".dll\" /D JS_THREADSAFE=1 /D NS_PRINT_PREVIEW=1 /D NS_PRINTING=1 /D "_MOZILLA_CONFIG_H_" /D "MOZILLA_CLIENT" /Yu"stdafx.h" /Gs8192 /GF /O2 /c
 MTL=midl.exe
 # ADD BASE MTL /nologo /D "NDEBUG" /mktyplib203 /o "NUL" /win32
 # ADD MTL /nologo /D "NDEBUG" /mktyplib203 /o "NUL" /win32
 BSC32=bscmake.exe
 # ADD BASE BSC32 /nologo
 # ADD BSC32 /nologo
 LINK32=link.exe
 # ADD BASE LINK32 commctrl.lib coredll.lib $(CEx86Corelibc) aygshell.lib /nologo /base:"0x00010000" /stack:0x10000,0x1000 /entry:"WinMainCRTStartup" /nodefaultlib:"OLDNAMES.lib" /nodefaultlib:$(CENoDefaultLib) /subsystem:$(CESubsystem) /MACHINE:IX86
@@ -78,17 +78,17 @@ LINK32=link.exe
 # PROP CPU_ID "{32E52003-403E-442D-BE48-DE10F8C6131D}"
 # PROP Platform_ID "{8A9A2F80-6887-11D3-842E-005004848CBA}"
 # PROP Target_Dir ""
 RSC=rc.exe
 # ADD BASE RSC /l 0x409 /d "$(CePlatform)" /d UNDER_CE=$(CEVersion) /d _WIN32_WCE=$(CEVersion) /d "UNICODE" /d "_UNICODE" /d "DEBUG" /d "_X86_" /d "x86" /d "_i386_" /r
 # ADD RSC /l 0x409 /i "C:\Program Files\Windows CE Tools\wce420\POCKET PC 2003\Include\Emulator" /d "$(CePlatform)" /d UNDER_CE=$(CEVersion) /d _WIN32_WCE=$(CEVersion) /d "UNICODE" /d "_UNICODE" /d "DEBUG" /d "_X86_" /d "x86" /d "_i386_" /r
 CPP=cl.exe
 # ADD BASE CPP /nologo /W3 /Zi /Od /D "DEBUG" /D "_i386_" /D UNDER_CE=$(CEVersion) /D _WIN32_WCE=$(CEVersion) /D "$(CePlatform)" /D "i_386_" /D "UNICODE" /D "_UNICODE" /D "_X86_" /D "x86" /Yu"stdafx.h" /Gs8192 /GF /c
-# ADD CPP /nologo /W3 /Zi /Od /I "..\..\..\..\..\arm_ppc\dist\include" /I "..\..\..\..\..\arm_ppc\dist\include\xpcom" /I "..\..\..\..\..\arm_ppc\dist\sdk\include" /I "C:\Program Files\Windows CE Tools\wce420\POCKET PC 2003\Include\Emulator" /D "DEBUG" /D "_i386_" /D UNDER_CE=$(CEVersion) /D _WIN32_WCE=$(CEVersion) /D "$(CePlatform)" /D "i_386_" /D "UNICODE" /D "_UNICODE" /D "_X86_" /D "x86" /D "TRIMMED" /D CROSS_COMPILE=1 /D HAVE_MMINTRIN_H=1 /D X_DISPLAY_MISSING=1 /D MOZILLA_VERSION=\"1.8b2\" /D HAVE_SNPRINTF=1 /D _WINDOWS=1 /D _WIN32=1 /D WIN32=1 /D XP_WIN=1 /D XP_WIN32=1 /D HW_THREADS=1 /D STDC_HEADERS=1 /D WIN32_LEAN_AND_MEAN=1 /D D_INO=d_ino /D MOZ_DEFAULT_TOOLKIT=\"windows\" /D MOZ_BUILD_APP=suite /D MOZ_DISTRIBUTION_ID=\"org.mozilla\" /D OJI=1 /D IBMBIDI=1 /D MOZ_VIEW_SOURCE=1 /D MOZ_XTF=1 /D NS_DISABLE_LOGGING=1 /D MOZ_USER_DIR=\"Mozilla\" /D MOZ_DLL_SUFFIX=\".dll\" /D JS_THREADSAFE=1 /D NS_PRINT_PREVIEW=1 /D NS_PRINTING=1 /D MOZILLA_LOCALE_VERSION=\"1.8b2\" /D MOZILLA_REGION_VERSION=\"1.8b2\" /D MOZILLA_SKIN_VERSION=\"1.5\" /D "_MOZILLA_CONFIG_H_" /D "MOZILLA_CLIENT" /Yu"stdafx.h" /Gs8192 /GF /c
+# ADD CPP /nologo /W3 /Zi /Od /I "..\..\..\..\..\arm_ppc\dist\include" /I "..\..\..\..\..\arm_ppc\dist\include\xpcom" /I "..\..\..\..\..\arm_ppc\dist\sdk\include" /I "C:\Program Files\Windows CE Tools\wce420\POCKET PC 2003\Include\Emulator" /D "DEBUG" /D "_i386_" /D UNDER_CE=$(CEVersion) /D _WIN32_WCE=$(CEVersion) /D "$(CePlatform)" /D "i_386_" /D "UNICODE" /D "_UNICODE" /D "_X86_" /D "x86" /D "TRIMMED" /D CROSS_COMPILE=1 /D HAVE_MMINTRIN_H=1 /D X_DISPLAY_MISSING=1 /D MOZILLA_VERSION=\"1.8b2\" /D HAVE_SNPRINTF=1 /D _WINDOWS=1 /D _WIN32=1 /D WIN32=1 /D XP_WIN=1 /D XP_WIN32=1 /D HW_THREADS=1 /D STDC_HEADERS=1 /D WIN32_LEAN_AND_MEAN=1 /D D_INO=d_ino /D MOZ_DEFAULT_TOOLKIT=\"windows\" /D MOZ_BUILD_APP=suite /D MOZ_DISTRIBUTION_ID=\"org.mozilla\" /D OJI=1 /D IBMBIDI=1 /D MOZ_VIEW_SOURCE=1 /D MOZ_XTF=1 /D NS_DISABLE_LOGGING=1 /D MOZ_USER_DIR=\"Mozilla\" /D MOZ_DLL_SUFFIX=\".dll\" /D JS_THREADSAFE=1 /D NS_PRINT_PREVIEW=1 /D NS_PRINTING=1 /D "_MOZILLA_CONFIG_H_" /D "MOZILLA_CLIENT" /Yu"stdafx.h" /Gs8192 /GF /c
 MTL=midl.exe
 # ADD BASE MTL /nologo /D "_DEBUG" /mktyplib203 /o "NUL" /win32
 # ADD MTL /nologo /D "_DEBUG" /mktyplib203 /o "NUL" /win32
 BSC32=bscmake.exe
 # ADD BASE BSC32 /nologo
 # ADD BSC32 /nologo
 LINK32=link.exe
 # ADD BASE LINK32 commctrl.lib coredll.lib $(CEx86Corelibc) aygshell.lib /nologo /base:"0x00010000" /stack:0x10000,0x1000 /entry:"WinMainCRTStartup" /debug /nodefaultlib:"OLDNAMES.lib" /nodefaultlib:$(CENoDefaultLib) /subsystem:$(CESubsystem) /MACHINE:IX86
@@ -111,17 +111,17 @@ LINK32=link.exe
 # PROP Platform_ID "{8A9A2F80-6887-11D3-842E-005004848CBA}"
 # PROP Ignore_Export_Lib 0
 # PROP Target_Dir ""
 RSC=rc.exe
 # ADD BASE RSC /l 0x409 /d UNDER_CE=$(CEVersion) /d _WIN32_WCE=$(CEVersion) /d "NDEBUG" /d "UNICODE" /d "_UNICODE" /d "$(CePlatform)" /d "ARM" /d "_ARM_" /d "ARMV4" /r
 # ADD RSC /l 0x409 /i "C:\Program Files\Windows CE Tools\wce420\POCKET PC 2003\Include\Armv4" /d UNDER_CE=$(CEVersion) /d _WIN32_WCE=$(CEVersion) /d "NDEBUG" /d "UNICODE" /d "_UNICODE" /d "$(CePlatform)" /d "ARM" /d "_ARM_" /d "ARMV4" /r
 CPP=clarm.exe
 # ADD BASE CPP /nologo /W3 /D _WIN32_WCE=$(CEVersion) /D "$(CePlatform)" /D "ARM" /D "_ARM_" /D "ARMV4" /D UNDER_CE=$(CEVersion) /D "UNICODE" /D "_UNICODE" /D "NDEBUG" /Yu"stdafx.h" /O2 /M$(CECrtMT) /c
-# ADD CPP /nologo /W3 /I "..\..\..\..\..\arm_ppc\dist\include" /I "..\..\..\..\..\arm_ppc\dist\include\xpcom" /I "..\..\..\..\..\arm_ppc\dist\sdk\include" /I "C:\Program Files\Windows CE Tools\wce420\POCKET PC 2003\Include\Armv4" /D "NDEBUG" /D "ARM" /D "_ARM_" /D "ARMV4" /D UNDER_CE=$(CEVersion) /D _WIN32_WCE=$(CEVersion) /D "$(CePlatform)" /D "UNICODE" /D "_UNICODE" /D "TRIMMED" /D CROSS_COMPILE=1 /D HAVE_MMINTRIN_H=1 /D X_DISPLAY_MISSING=1 /D MOZILLA_VERSION=\"1.8b2\" /D HAVE_SNPRINTF=1 /D _WINDOWS=1 /D _WIN32=1 /D WIN32=1 /D XP_WIN=1 /D XP_WIN32=1 /D HW_THREADS=1 /D STDC_HEADERS=1 /D WIN32_LEAN_AND_MEAN=1 /D D_INO=d_ino /D MOZ_DEFAULT_TOOLKIT=\"windows\" /D MOZ_BUILD_APP=suite /D MOZ_DISTRIBUTION_ID=\"org.mozilla\" /D OJI=1 /D IBMBIDI=1 /D MOZ_VIEW_SOURCE=1 /D MOZ_XTF=1 /D NS_DISABLE_LOGGING=1 /D MOZ_USER_DIR=\"Mozilla\" /D MOZ_DLL_SUFFIX=\".dll\" /D JS_THREADSAFE=1 /D NS_PRINT_PREVIEW=1 /D NS_PRINTING=1 /D MOZILLA_LOCALE_VERSION=\"1.8b2\" /D MOZILLA_REGION_VERSION=\"1.8b2\" /D MOZILLA_SKIN_VERSION=\"1.5\" /D "_MOZILLA_CONFIG_H_" /D "MOZILLA_CLIENT" /Yu"stdafx.h" /O2 /M$(CECrtMT) /c
+# ADD CPP /nologo /W3 /I "..\..\..\..\..\arm_ppc\dist\include" /I "..\..\..\..\..\arm_ppc\dist\include\xpcom" /I "..\..\..\..\..\arm_ppc\dist\sdk\include" /I "C:\Program Files\Windows CE Tools\wce420\POCKET PC 2003\Include\Armv4" /D "NDEBUG" /D "ARM" /D "_ARM_" /D "ARMV4" /D UNDER_CE=$(CEVersion) /D _WIN32_WCE=$(CEVersion) /D "$(CePlatform)" /D "UNICODE" /D "_UNICODE" /D "TRIMMED" /D CROSS_COMPILE=1 /D HAVE_MMINTRIN_H=1 /D X_DISPLAY_MISSING=1 /D MOZILLA_VERSION=\"1.8b2\" /D HAVE_SNPRINTF=1 /D _WINDOWS=1 /D _WIN32=1 /D WIN32=1 /D XP_WIN=1 /D XP_WIN32=1 /D HW_THREADS=1 /D STDC_HEADERS=1 /D WIN32_LEAN_AND_MEAN=1 /D D_INO=d_ino /D MOZ_DEFAULT_TOOLKIT=\"windows\" /D MOZ_BUILD_APP=suite /D MOZ_DISTRIBUTION_ID=\"org.mozilla\" /D OJI=1 /D IBMBIDI=1 /D MOZ_VIEW_SOURCE=1 /D MOZ_XTF=1 /D NS_DISABLE_LOGGING=1 /D MOZ_USER_DIR=\"Mozilla\" /D MOZ_DLL_SUFFIX=\".dll\" /D JS_THREADSAFE=1 /D NS_PRINT_PREVIEW=1 /D NS_PRINTING=1 /D "_MOZILLA_CONFIG_H_" /D "MOZILLA_CLIENT" /Yu"stdafx.h" /O2 /M$(CECrtMT) /c
 MTL=midl.exe
 # ADD BASE MTL /nologo /D "NDEBUG" /mktyplib203 /o "NUL" /win32
 # ADD MTL /nologo /D "NDEBUG" /mktyplib203 /o "NUL" /win32
 BSC32=bscmake.exe
 # ADD BASE BSC32 /nologo
 # ADD BSC32 /nologo
 LINK32=link.exe
 # ADD BASE LINK32 commctrl.lib coredll.lib aygshell.lib /nologo /base:"0x00010000" /stack:0x10000,0x1000 /entry:"WinMainCRTStartup" /nodefaultlib:"$(CENoDefaultLib)" /subsystem:$(CESubsystem) /align:"4096" /MACHINE:ARM
@@ -144,17 +144,17 @@ LINK32=link.exe
 # PROP Platform_ID "{8A9A2F80-6887-11D3-842E-005004848CBA}"
 # PROP Ignore_Export_Lib 0
 # PROP Target_Dir ""
 RSC=rc.exe
 # ADD BASE RSC /l 0x409 /d UNDER_CE=$(CEVersion) /d _WIN32_WCE=$(CEVersion) /d "DEBUG" /d "UNICODE" /d "_UNICODE" /d "$(CePlatform)" /d "ARM" /d "_ARM_" /d "ARMV4" /r
 # ADD RSC /l 0x409 /i "C:\Program Files\Windows CE Tools\wce420\POCKET PC 2003\Include\Armv4" /d UNDER_CE=$(CEVersion) /d _WIN32_WCE=$(CEVersion) /d "DEBUG" /d "UNICODE" /d "_UNICODE" /d "$(CePlatform)" /d "ARM" /d "_ARM_" /d "ARMV4" /r
 CPP=clarm.exe
 # ADD BASE CPP /nologo /W3 /Zi /Od /D "DEBUG" /D "ARM" /D "_ARM_" /D "ARMV4" /D UNDER_CE=$(CEVersion) /D _WIN32_WCE=$(CEVersion) /D "$(CePlatform)" /D "UNICODE" /D "_UNICODE" /Yu"stdafx.h" /M$(CECrtMTDebug) /c
-# ADD CPP /nologo /W3 /Zi /Od /I "c:/builds/minimo/arm-build-minimo-opt-t/dist/include/string" /I "../../public" /I "c:/builds/minimo/arm-build-minimo-opt-t/dist/include/" /I "c:/builds/minimo/arm-build-minimo-opt-t/dist/include/xpcom" /I "c:/builds/minimo/arm-build-minimo-opt-t/dist\sdk\include" /I "C:\Program Files\Windows CE Tools\wce420\POCKET PC 2003\Include\Armv4" /D "$(CePlatform)" /D "ARM" /D "ARMV4" /D CANT_RESOLVE_CPP_CONST_AMBIGUITY=1 /D CROSS_COMPILE=1 /D "DEBUG" /D "DEBUG_dougt" /D D_INO=d_ino /D gid_t=int /D HAVE_COMPAT_H=1 /D HAVE_GETOPT_H=1 /D HAVE_GNU_LIBC_VERSION_H=1 /D HAVE_LIBM=1 /D HAVE_MALLOC_H=1 /D HAVE_MEMMOVE=1 /D HAVE_MEMORY_H=1 /D HAVE_MMINTRIN_H=1 /D HAVE_NL_TYPES_H=1 /D HAVE_SNPRINTF=1 /D HAVE_SYS_BITYPES_H=1 /D HAVE_SYS_STATFS_H=1 /D HAVE_SYS_STATVFS_H=1 /D HAVE_UINT=1 /D HAVE_UNISTD_H=1 /D HAVE_X11_XKBLIB_H=1 /D HW_THREADS=1 /D IBMBIDI=1 /D JS_THREADSAFE=1 /D mode_t=int /D "MOZILLA_CLIENT" /D MOZILLA_LOCALE_VERSION=\"1.8b2\" /D MOZILLA_REGION_VERSION=\"1.8b2\" /D MOZILLA_SKIN_VERSION=\"1.5\" /D MOZILLA_VERSION=\"1.8b2\" /D MOZ_APP_NAME=\"mozilla\" /D MOZ_BUILD_APP=suite /D MOZ_DEFAULT_TOOLKIT=\"windows\" /D MOZ_DISTRIBUTION_ID=\"org.mozilla\" /D MOZ_DLL_SUFFIX=\".dll\" /D MOZ_ENABLE_COREXFONTS=1 /D MOZ_USER_DIR=\"Mozilla\" /D MOZ_V1_STRING_ABI=1 /D MOZ_VIEW_SOURCE=1 /D MOZ_XTF=1 /D NEED_CPP_DERIVED_TEMPLATE_OPERATORS=1 /D NEED_CPP_TEMPLATE_CAST_TO_BASE=1 /D NO_MINUS_C_MINUS_O=1 /D NO_X11=1 /D NSCAP_DONT_PROVIDE_NONCONST_OPEQ=1 /D NS_DISABLE_LOGGING=1 /D NS_PRINTING=1 /D NS_PRINT_PREVIEW=1 /D off_t=long /D OJI=1 /D OSARCH=\"WINCE\" /D OSTYPE=\"WINCE420\" /D pid_t=int /D size_t=unsigned /D STDC_HEADERS=1 /D "TRACING" /D "TRIMMED" /D uid_t=int /D UNDER_CE=$(CEVersion) /D "UNICODE" /D UNIX_ASYNC_DNS=1 /D WIN32=1 /D WIN32_LEAN_AND_MEAN=1 /D XP_WIN32=1 /D XP_WIN=1 /D X_DISPLAY_MISSING=1 /D "_ARM_" /D "_DEBUG" /D "_IMPL_NS_GFX" /D "_IMPL_NS_MSG_BASE" /D "_IMPL_NS_WIDGET" /D "_MOZILLA_CONFIG_H_" /D "_UNICODE" /D _WIN32=1 /D _WIN32_WCE=$(CEVersion) /D _WINDOWS=1 /D "_IMPL_NS_COM" /D "_IMPL_NS_STRINGAPI" /D "EXPORT_XPT_API" /D "EXPORT_XPTC_API" /D "EXPORT_XPTI_API" /D "MOZILLA_INTERNAL_API" /Yu"stdafx.h" /M$(CECrtMTDebug) /c
+# ADD CPP /nologo /W3 /Zi /Od /I "c:/builds/minimo/arm-build-minimo-opt-t/dist/include/string" /I "../../public" /I "c:/builds/minimo/arm-build-minimo-opt-t/dist/include/" /I "c:/builds/minimo/arm-build-minimo-opt-t/dist/include/xpcom" /I "c:/builds/minimo/arm-build-minimo-opt-t/dist\sdk\include" /I "C:\Program Files\Windows CE Tools\wce420\POCKET PC 2003\Include\Armv4" /D "$(CePlatform)" /D "ARM" /D "ARMV4" /D CANT_RESOLVE_CPP_CONST_AMBIGUITY=1 /D CROSS_COMPILE=1 /D "DEBUG" /D "DEBUG_dougt" /D D_INO=d_ino /D gid_t=int /D HAVE_COMPAT_H=1 /D HAVE_GETOPT_H=1 /D HAVE_GNU_LIBC_VERSION_H=1 /D HAVE_LIBM=1 /D HAVE_MALLOC_H=1 /D HAVE_MEMMOVE=1 /D HAVE_MEMORY_H=1 /D HAVE_MMINTRIN_H=1 /D HAVE_NL_TYPES_H=1 /D HAVE_SNPRINTF=1 /D HAVE_SYS_BITYPES_H=1 /D HAVE_SYS_STATFS_H=1 /D HAVE_SYS_STATVFS_H=1 /D HAVE_UINT=1 /D HAVE_UNISTD_H=1 /D HAVE_X11_XKBLIB_H=1 /D HW_THREADS=1 /D IBMBIDI=1 /D JS_THREADSAFE=1 /D mode_t=int /D "MOZILLA_CLIENT" /D MOZILLA_VERSION=\"1.8b2\" /D MOZ_APP_NAME=\"mozilla\" /D MOZ_BUILD_APP=suite /D MOZ_DEFAULT_TOOLKIT=\"windows\" /D MOZ_DISTRIBUTION_ID=\"org.mozilla\" /D MOZ_DLL_SUFFIX=\".dll\" /D MOZ_ENABLE_COREXFONTS=1 /D MOZ_USER_DIR=\"Mozilla\" /D MOZ_V1_STRING_ABI=1 /D MOZ_VIEW_SOURCE=1 /D MOZ_XTF=1 /D NEED_CPP_DERIVED_TEMPLATE_OPERATORS=1 /D NEED_CPP_TEMPLATE_CAST_TO_BASE=1 /D NO_MINUS_C_MINUS_O=1 /D NO_X11=1 /D NSCAP_DONT_PROVIDE_NONCONST_OPEQ=1 /D NS_DISABLE_LOGGING=1 /D NS_PRINTING=1 /D NS_PRINT_PREVIEW=1 /D off_t=long /D OJI=1 /D OSARCH=\"WINCE\" /D OSTYPE=\"WINCE420\" /D pid_t=int /D size_t=unsigned /D STDC_HEADERS=1 /D "TRACING" /D "TRIMMED" /D uid_t=int /D UNDER_CE=$(CEVersion) /D "UNICODE" /D UNIX_ASYNC_DNS=1 /D WIN32=1 /D WIN32_LEAN_AND_MEAN=1 /D XP_WIN32=1 /D XP_WIN=1 /D X_DISPLAY_MISSING=1 /D "_ARM_" /D "_DEBUG" /D "_IMPL_NS_GFX" /D "_IMPL_NS_MSG_BASE" /D "_IMPL_NS_WIDGET" /D "_MOZILLA_CONFIG_H_" /D "_UNICODE" /D _WIN32=1 /D _WIN32_WCE=$(CEVersion) /D _WINDOWS=1 /D "_IMPL_NS_COM" /D "_IMPL_NS_STRINGAPI" /D "EXPORT_XPT_API" /D "EXPORT_XPTC_API" /D "EXPORT_XPTI_API" /D "MOZILLA_INTERNAL_API" /Yu"stdafx.h" /M$(CECrtMTDebug) /c
 MTL=midl.exe
 # ADD BASE MTL /nologo /D "_DEBUG" /mktyplib203 /o "NUL" /win32
 # ADD MTL /nologo /D "_DEBUG" /mktyplib203 /o "NUL" /win32
 BSC32=bscmake.exe
 # ADD BASE BSC32 /nologo
 # ADD BSC32 /nologo
 LINK32=link.exe
 # ADD BASE LINK32 commctrl.lib coredll.lib aygshell.lib /nologo /base:"0x00010000" /stack:0x10000,0x1000 /entry:"WinMainCRTStartup" /debug /nodefaultlib:"$(CENoDefaultLib)" /subsystem:$(CESubsystem) /align:"4096" /MACHINE:ARM
diff -r b7bcdd009540 xpcom/tests/static-checker/Makefile.in
--- a/xpcom/tests/static-checker/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/xpcom/tests/static-checker/Makefile.in	Thu Sep 11 15:19:29 2008 +0300
@@ -95,28 +95,36 @@ OUTPARAMS_PASS_TESTCASES = \
   o13.cpp \
   o14.cpp \
   o15.cpp \
   o16.cpp \
   onull.cpp \
   onull2.cpp \
   $(NULL)
 
+FLOW_PASS_TESTCASES = \
+ flow_through_pass.cpp
+
+FLOW_FAILURE_TESTCASES = \
+ flow_through_fail.cpp
+
 STATIC_FAILURE_TESTCASES = \
   $(FINAL_FAILURE_TESTCASES) \
   $(STACK_FAILURE_TESTCASES) \
+  $(FLOW_FAILURE_TESTCASES)
   $(NULL)
 
 STATIC_WARNING_TESTCASES = \
   $(OUTPARAMS_WARNING_TESTCASES) \
   $(NULL)
 
 STATIC_PASS_TESTCASES = \
   $(OUTPARAMS_PASS_TESTCASES) \
   $(STACK_PASS_TESTCASES) \
+  $(FLOW_PASS_TESTCASES) \
   $(NULL)
 
 include $(topsrcdir)/config/rules.mk
 
 # We want to compile each file and invert the result to ensure that
 # compilation failed.
 check:: \
   $(STATIC_FAILURE_TESTCASES:.cpp=.s-fail) \
diff -r b7bcdd009540 xpcom/tests/static-checker/flow_through_fail.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/xpcom/tests/static-checker/flow_through_fail.cpp	Thu Sep 11 15:19:29 2008 +0300
@@ -0,0 +1,16 @@
+static void MUST_FLOW_THROUGH(const char *label) {
+}
+
+int test(int x, int y) {
+  MUST_FLOW_THROUGH("out");
+  
+  if (!x) {
+    x = y;
+    goto out;
+  }
+
+  return y;
+ out:
+  x--;
+  return x;
+}
diff -r b7bcdd009540 xpcom/tests/static-checker/flow_through_pass.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/xpcom/tests/static-checker/flow_through_pass.cpp	Thu Sep 11 15:19:29 2008 +0300
@@ -0,0 +1,20 @@
+static void MUST_FLOW_THROUGH(const char *label) {
+}
+
+int test(int x, int y) {
+  if (x == 3)
+    return 0;
+
+  if(x)
+    MUST_FLOW_THROUGH("out");
+  
+  if (x) {
+    x = y;
+    goto out;
+  }
+
+  return y;
+ out:
+  x--;
+  return x;
+}
diff -r b7bcdd009540 xpfe/components/autocomplete/resources/content/autocomplete.xml
--- a/xpfe/components/autocomplete/resources/content/autocomplete.xml	Mon Sep 08 00:36:19 2008 -0700
+++ b/xpfe/components/autocomplete/resources/content/autocomplete.xml	Thu Sep 11 15:19:29 2008 +0300
@@ -27,17 +27,17 @@
         <children includes="hbox"/>
       </xul:hbox>
 
       <xul:dropmarker class="autocomplete-history-dropmarker" allowevents="true"
                       xbl:inherits="open,hidden=disablehistory" anonid="historydropmarker"/>
 
       <xul:popupset>
         <xul:panel type="autocomplete" anonid="popup"
-                   ignorekeys="true" noautofocus="true"
+                   ignorekeys="true" noautofocus="true" level="top"
                    xbl:inherits="for=id,nomatch"/>
       </xul:popupset>
       
       <children includes="menupopup"/>
     </content>
 
     <implementation implements="nsIDOMXULMenuListElement, nsIAccessibleProvider">
 
diff -r b7bcdd009540 xpfe/components/download-manager/resources/Makefile.in
--- a/xpfe/components/download-manager/resources/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ b/xpfe/components/download-manager/resources/Makefile.in	Thu Sep 11 15:19:29 2008 +0300
@@ -37,20 +37,14 @@
 
 DEPTH		= ../../../..
 topsrcdir	= @top_srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
-ifneq (,$(filter OS2 WINNT WINCE,$(OS_ARCH)))
-DIRS		= win
-else
 ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
 DIRS		= mac
-else
-DIRS		= unix
-endif
 endif
 
 include $(topsrcdir)/config/rules.mk
 
diff -r b7bcdd009540 xpfe/components/download-manager/resources/mac/contents.rdf
--- a/xpfe/components/download-manager/resources/mac/contents.rdf	Mon Sep 08 00:36:19 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,27 +0,0 @@
-<?xml version="1.0"?>
-
-<RDF:RDF xmlns:RDF="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-         xmlns:chrome="http://www.mozilla.org/rdf/chrome#">
-
-  <RDF:Seq about="urn:mozilla:package:root">
-    <RDF:li resource="urn:mozilla:package:download-manager"/>
-  </RDF:Seq>
- 
-  <RDF:Description about="urn:mozilla:package:download-manager"
-                   chrome:displayName="Mac-specific dl mgr files"
-                   chrome:author="mozilla.org"
-                   chrome:name="dlmgr"
-#expand                    chrome:localeVersion="__MOZILLA_LOCALE_VERSION__"
-#expand                    chrome:skinVersion="__MOZILLA_SKIN_VERSION__">
-  </RDF:Description>
- 
-  <!-- overlay information -->
-  <RDF:Seq about="urn:mozilla:overlays">
-    <RDF:li resource="chrome://communicator/content/downloadmanager/downloadmanager.xul"/>
-  </RDF:Seq>
-
-  <RDF:Seq about="chrome://communicator/content/downloadmanager/downloadmanager.xul">
-    <RDF:li>chrome://communicator/content/downloadmanager/dlmanagermenuoverlay.xul</RDF:li>
-  </RDF:Seq>
-
-</RDF:RDF>
diff -r b7bcdd009540 xpfe/components/download-manager/resources/mac/jar.mn
--- a/xpfe/components/download-manager/resources/mac/jar.mn	Mon Sep 08 00:36:19 2008 -0700
+++ b/xpfe/components/download-manager/resources/mac/jar.mn	Thu Sep 11 15:19:29 2008 +0300
@@ -1,3 +1,2 @@ comm.jar:
 comm.jar:
-*   content/communicator/downloadmanager/contents.rdf (contents.rdf)
    content/communicator/downloadmanager/dlmanagermenuoverlay.xul (dlmanagermenuoverlay.xul)
diff -r b7bcdd009540 xpfe/components/download-manager/resources/unix/Makefile.in
--- a/xpfe/components/download-manager/resources/unix/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,45 +0,0 @@
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is mozilla.org code.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 2002
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-DEPTH    = ../../../../..
-topsrcdir  = @top_srcdir@
-srcdir   = @srcdir@
-VPATH    = @srcdir@
-
-include $(DEPTH)/config/autoconf.mk
-
-include $(topsrcdir)/config/rules.mk
-
diff -r b7bcdd009540 xpfe/components/download-manager/resources/unix/contents.rdf
--- a/xpfe/components/download-manager/resources/unix/contents.rdf	Mon Sep 08 00:36:19 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,28 +0,0 @@
-<?xml version="1.0"?>
-
-<RDF:RDF xmlns:RDF="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-         xmlns:chrome="http://www.mozilla.org/rdf/chrome#">
-
-  <RDF:Seq about="urn:mozilla:package:root">
-    <RDF:li resource="urn:mozilla:package:download-manager"/>
-  </RDF:Seq>
- 
-  <RDF:Description about="urn:mozilla:package:download-manager"
-                   chrome:displayName="Unix-specific dl mgr files"
-                   chrome:author="mozilla.org"
-                   chrome:name="dlmgr"
-#expand                    chrome:localeVersion="__MOZILLA_LOCALE_VERSION__"
-#expand                    chrome:skinVersion="__MOZILLA_SKIN_VERSION__">
-  </RDF:Description>
- 
-  <!-- overlay information -->
-  <RDF:Seq about="urn:mozilla:overlays">
-    <RDF:li resource="chrome://communicator/content/downloadmanager/downloadmanager.xul"/>
-  </RDF:Seq>
-
-  <RDF:Seq about="chrome://communicator/content/downloadmanager/downloadmanager.xul">
-    <RDF:li>chrome://communicator/content/tasksOverlay.xul</RDF:li>
-    <RDF:li>chrome://communicator/content/utilityOverlay.xul</RDF:li>
-  </RDF:Seq>
-
-</RDF:RDF>
diff -r b7bcdd009540 xpfe/components/download-manager/resources/unix/jar.mn
--- a/xpfe/components/download-manager/resources/unix/jar.mn	Mon Sep 08 00:36:19 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,3 +0,0 @@
-comm.jar:
-*   content/communicator/downloadmanager/contents.rdf (contents.rdf)
-   
diff -r b7bcdd009540 xpfe/components/download-manager/resources/win/Makefile.in
--- a/xpfe/components/download-manager/resources/win/Makefile.in	Mon Sep 08 00:36:19 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,45 +0,0 @@
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is mozilla.org code.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 2002
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-DEPTH    = ../../../../..
-topsrcdir  = @top_srcdir@
-srcdir   = @srcdir@
-VPATH    = @srcdir@
-
-include $(DEPTH)/config/autoconf.mk
-
-include $(topsrcdir)/config/rules.mk
-
diff -r b7bcdd009540 xpfe/components/download-manager/resources/win/contents.rdf
--- a/xpfe/components/download-manager/resources/win/contents.rdf	Mon Sep 08 00:36:19 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,28 +0,0 @@
-<?xml version="1.0"?>
-
-<RDF:RDF xmlns:RDF="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-         xmlns:chrome="http://www.mozilla.org/rdf/chrome#">
-
-  <RDF:Seq about="urn:mozilla:package:root">
-    <RDF:li resource="urn:mozilla:package:download-manager"/>
-  </RDF:Seq>
- 
-  <RDF:Description about="urn:mozilla:package:download-manager"
-                   chrome:displayName="Win-specific dl mgr files"
-                   chrome:author="mozilla.org"
-                   chrome:name="dlmgr"
-#expand                    chrome:localeVersion="__MOZILLA_LOCALE_VERSION__"
-#expand                    chrome:skinVersion="__MOZILLA_SKIN_VERSION__">
-  </RDF:Description>
- 
-  <!-- overlay information -->
-  <RDF:Seq about="urn:mozilla:overlays">
-    <RDF:li resource="chrome://communicator/content/downloadmanager/downloadmanager.xul"/>
-  </RDF:Seq>
-
-  <RDF:Seq about="chrome://communicator/content/downloadmanager/downloadmanager.xul">
-    <RDF:li>chrome://communicator/content/tasksOverlay.xul</RDF:li>
-    <RDF:li>chrome://communicator/content/utilityOverlay.xul</RDF:li>
-  </RDF:Seq>
-
-</RDF:RDF>
diff -r b7bcdd009540 xpfe/components/download-manager/resources/win/jar.mn
--- a/xpfe/components/download-manager/resources/win/jar.mn	Mon Sep 08 00:36:19 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,3 +0,0 @@
-comm.jar:
-*   content/communicator/downloadmanager/contents.rdf (contents.rdf)
-   
