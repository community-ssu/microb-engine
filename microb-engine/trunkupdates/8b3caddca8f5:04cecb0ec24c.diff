diff -r 8b3caddca8f5 .hgtags
--- a/.hgtags	Sat Nov 15 23:56:49 2008 -0800
+++ b/.hgtags	Sat Nov 22 15:25:48 2008 -0500
@@ -19,8 +19,9 @@ 15cb5d25db054d2d0b56869a2f6351388bfcddcd
 15cb5d25db054d2d0b56869a2f6351388bfcddcd THUNDERBIRD_3_0a3_RELEASE
 15cb5d25db054d2d0b56869a2f6351388bfcddcd THUNDERBIRD_3_0a3_BUILD1
 0000000000000000000000000000000000000000 -m
 0000000000000000000000000000000000000000 Adding UPDATE_PACKAGING_R5 tag in order to make patcher work.
 f197b51bbc29a30860e750ee87fd0a047a024f2e UPDATE_PACKAGING_R6
 d7d64f68423b68a671f623f123e90057ebc49dac UPDATE_PACKAGING_R6
 0000000000000000000000000000000000000000 THUNDERBIRD_3_0a3_BUILD1
 0000000000000000000000000000000000000000 THUNDERBIRD_3_0a3_RELEASE
+0cd41f5990807fb6ab52cb59ba3c8e8247281045 GECKO_1_9_1_BASE
diff -r 8b3caddca8f5 accessible/tests/mochitest/Makefile.in
--- a/accessible/tests/mochitest/Makefile.in	Sat Nov 15 23:56:49 2008 -0800
+++ b/accessible/tests/mochitest/Makefile.in	Sat Nov 22 15:25:48 2008 -0500
@@ -55,48 +55,48 @@ _TEST_FILES =\
 		nsIAccessible_name.js \
 		nsIAccessible_name.xbl \
  		nsIAccessible_selects.js \
 		nsIAccessible_states.js \
 		nsIAccessibleEditableText.js \
 		test_aria_activedescendant.html \
 		test_aria_role_article.html \
 		test_aria_role_equation.html \
-		test_bug368835.xul \
+		$(warning test_bug368835.xul temporarily disabled) \
 		test_bug420863.html \
 		test_cssattrs.html \
 		test_events_caretmove.html \
-		test_groupattrs.xul \
+		$(warning test_groupattrs.xul temporarily disabled) \
 	$(warning test_table_indexes.html temporarily disabled) \
 		test_nsIAccessible_actions.html \
-		test_nsIAccessible_actions.xul \
+		$(warning test_nsIAccessible_actions.xul temporarily disabled) \
 		test_nsIAccessible_applicationAccessible.html \
 		test_nsIAccessible_editablebody.html \
 		test_nsIAccessible_editabledoc.html \
 		test_nsIAccessible_name.html \
 		test_nsIAccessible_name_button.html \
-		test_nsIAccessible_name.xul \
+		$(warning test_nsIAccessible_name.xul temporarily disabled) \
  		test_nsIAccessible_selects.html \
 		test_nsIAccessible_states.html \
 		test_nsIAccessible_focus.html \
 		test_nsIAccessibleDocument.html \
 		test_nsIAccessibleEditableText.html \
 		test_nsIAccessibleHyperLink.html \
-		test_nsIAccessibleHyperLink.xul \
+		$(warning test_nsIAccessibleHyperLink.xul temporarily disabled) \
 		test_nsIAccessibleHyperText.html \
 		test_nsIAccessibleImage.html \
 		test_nsIAccessibleTable_1.html \
 		test_nsIAccessibleTable_2.html \
 		test_nsIAccessibleTable_3.html \
 		test_nsIAccessibleTable_4.html \
-		test_nsIAccessibleTable_listboxes.xul \
+		$(warning test_nsIAccessibleTable_listboxes.xul temporarily disabled) \
 		test_nsIAccessNode_utils.html \
 		test_nsOuterDocAccessible.html \
 		test_textattrs.html \
 		test_textboxes.html \
-		test_textboxes.xul \
+		$(warning test_textboxes.xul temporarily disabled) \
 		testTextboxes.js \
 		test_bug429285.html \
 		test_bug434464.html \
 		$(NULL)
 
 libs:: $(_TEST_FILES)
 	$(INSTALL) $(foreach f,$^,"$f") $(DEPTH)/_tests/testing/mochitest/a11y/$(relativesrcdir)
diff -r 8b3caddca8f5 browser/base/content/browser-menubar.inc
--- a/browser/base/content/browser-menubar.inc	Sat Nov 15 23:56:49 2008 -0800
+++ b/browser/base/content/browser-menubar.inc	Sat Nov 22 15:25:48 2008 -0500
@@ -391,17 +391,17 @@
                   <menupopup id="historyUndoPopup" onpopupshowing="HistoryMenu.populateUndoSubmenu();"/>
                 </menu>
               </menupopup>
             </menu>
 
   <menu id="bookmarksMenu" 
         label="&bookmarksMenu.label;" accesskey="&bookmarksMenu.accesskey;"
         ondragenter="PlacesMenuDNDController.onBookmarksMenuDragEnter(event);"
-        ondragdrop="nsDragAndDrop.drop(event, BookmarksMenuDropHandler);"
+        ondrop="nsDragAndDrop.drop(event, BookmarksMenuDropHandler);"
         ondragover="nsDragAndDrop.dragOver(event, BookmarksMenuDropHandler);"
         ondragexit="nsDragAndDrop.dragExit(event, BookmarksMenuDropHandler);">
     <menupopup id="bookmarksMenuPopup"
                type="places"
                place="place:folder=BOOKMARKS_MENU"
                context="placesContext"
                openInTabs="children"
                oncommand="BookmarksEventHandler.onCommand(event);"
diff -r 8b3caddca8f5 browser/base/content/browser.js
--- a/browser/base/content/browser.js	Sat Nov 15 23:56:49 2008 -0800
+++ b/browser/base/content/browser.js	Sat Nov 22 15:25:48 2008 -0500
@@ -1106,16 +1106,17 @@ function prepareForStartup() {
   // though it had done this work itself
   gBrowser.browsers[0].removeAttribute("disablehistory");
 
   // enable global history
   gBrowser.docShell.QueryInterface(Components.interfaces.nsIDocShellHistory).useGlobalHistory = true;
 
   // hook up UI through progress listener
   gBrowser.addProgressListener(window.XULBrowserWindow, Components.interfaces.nsIWebProgress.NOTIFY_ALL);
+  gBrowser.addTabsProgressListener(window.TabsProgressListener);
 
   // setup our common DOMLinkAdded listener
   gBrowser.addEventListener("DOMLinkAdded", DOMLinkHandler, false);
 
   // setup simple gestures support
   gGestureSupport.init(true);
 }
 
@@ -1269,17 +1270,19 @@ function delayedStartup(isLoadingBlank, 
 
   // Attach a listener to watch for "command" events bubbling up from error
   // pages.  This lets us fix bugs like 401575 which require error page UI to
   // do privileged things, without letting error pages have any privilege
   // themselves.
   gBrowser.addEventListener("command", BrowserOnCommand, false);
 
   tabPreviews.init();
+#ifdef USE_TAB_PREVIEWS
   ctrlTab.init();
+#endif
 
   // Initialize the microsummary service by retrieving it, prompting its factory
   // to create its singleton, whose constructor initializes the service.
   // Started 4 seconds after delayedStartup (before the livemarks service below).
   setTimeout(function() {
     try {
       Cc["@mozilla.org/microsummary/service;1"].getService(Ci.nsIMicrosummaryService);
     } catch (ex) {
@@ -1316,34 +1319,36 @@ function delayedStartup(isLoadingBlank, 
 
   // initialize the private browsing UI
   gPrivateBrowsingUI.init();
 }
 
 function BrowserShutdown()
 {
   tabPreviews.uninit();
+#ifdef USE_TAB_PREVIEWS
   ctrlTab.uninit();
-
+#endif
   gGestureSupport.init(false);
 
   try {
     FullZoom.destroy();
   }
   catch(ex) {
     Components.utils.reportError(ex);
   }
 
   var os = Components.classes["@mozilla.org/observer-service;1"]
     .getService(Components.interfaces.nsIObserverService);
   os.removeObserver(gSessionHistoryObserver, "browser:purge-session-history");
   os.removeObserver(gXPInstallObserver, "xpinstall-install-blocked");
 
   try {
     gBrowser.removeProgressListener(window.XULBrowserWindow);
+    gBrowser.removeTabsProgressListener(window.TabsProgressListener);
   } catch (ex) {
   }
 
   PlacesStarButton.uninit();
 
   try {
     gPrefService.removeObserver(gAutoHideTabbarPrefListener.domain,
                                 gAutoHideTabbarPrefListener);
@@ -3791,18 +3796,17 @@ var XULBrowserWindow = {
     // and cause needless (slow!) UI updates
     if (this.statusText != text) {
       this.statusTextField.label = text;
       this.statusText = text;
     }
   },
   
   onLinkIconAvailable: function (aBrowser) {
-    if (gProxyFavIcon && gBrowser.mCurrentBrowser == aBrowser &&
-        gBrowser.userTypedValue === null)
+    if (gProxyFavIcon && gBrowser.userTypedValue === null)
       PageProxySetIcon(aBrowser.mIconURL); // update the favicon in the URL bar
   },
 
   onProgressChange: function (aWebProgress, aRequest,
                               aCurSelfProgress, aMaxSelfProgress,
                               aCurTotalProgress, aMaxTotalProgress) {
     if (aMaxTotalProgress > 0) {
       // This is highly optimized.  Don't touch this code unless
@@ -4039,34 +4043,205 @@ var XULBrowserWindow = {
     BrowserSearch.updateSearchButton();
   },
 
   onStatusChange: function (aWebProgress, aRequest, aStatus, aMessage) {
     this.status = aMessage;
     this.updateStatusField();
   },
 
-  onRefreshAttempted: function (aWebProgress, aURI, aDelay, aSameURI) {
+  // Properties used to cache security state used to update the UI
+  _state: null,
+  _host: undefined,
+  _tooltipText: null,
+  _hostChanged: false, // onLocationChange will flip this bit
+
+  onSecurityChange: function (aWebProgress, aRequest, aState) {
+    // Don't need to do anything if the data we use to update the UI hasn't
+    // changed
+    if (this._state == aState &&
+        this._tooltipText == gBrowser.securityUI.tooltipText &&
+        !this._hostChanged) {
+#ifdef DEBUG
+      try {
+        var contentHost = gBrowser.contentWindow.location.host;
+        if (this._host !== undefined && this._host != contentHost) {
+            Components.utils.reportError(
+              "ASSERTION: browser.js host is inconsistent. Content window has " + 
+              "<" + contentHost + "> but cached host is <" + this._host + ">.\n"
+            );
+        }
+      } catch (ex) {}
+#endif
+      return;
+    }
+    this._state = aState;
+
+    try {
+      this._host = gBrowser.contentWindow.location.host;
+    } catch(ex) {
+      this._host = null;
+    }
+
+    this._hostChanged = false;
+    this._tooltipText = gBrowser.securityUI.tooltipText
+
+    // aState is defined as a bitmask that may be extended in the future.
+    // We filter out any unknown bits before testing for known values.
+    const wpl = Components.interfaces.nsIWebProgressListener;
+    const wpl_security_bits = wpl.STATE_IS_SECURE |
+                              wpl.STATE_IS_BROKEN |
+                              wpl.STATE_IS_INSECURE |
+                              wpl.STATE_SECURE_HIGH |
+                              wpl.STATE_SECURE_MED |
+                              wpl.STATE_SECURE_LOW;
+    var level;
+    var setHost = false;
+
+    switch (this._state & wpl_security_bits) {
+      case wpl.STATE_IS_SECURE | wpl.STATE_SECURE_HIGH:
+        level = "high";
+        setHost = true;
+        break;
+      case wpl.STATE_IS_SECURE | wpl.STATE_SECURE_MED:
+      case wpl.STATE_IS_SECURE | wpl.STATE_SECURE_LOW:
+        level = "low";
+        setHost = true;
+        break;
+      case wpl.STATE_IS_BROKEN:
+        level = "broken";
+        break;
+    }
+
+    if (level) {
+      this.securityButton.setAttribute("level", level);
+      this.securityButton.hidden = false;
+      // We don't style the Location Bar based on the the 'level' attribute
+      // anymore, but still set it for third-party themes.
+      if (gURLBar)
+        gURLBar.setAttribute("level", level);
+    } else {
+      this.securityButton.hidden = true;
+      this.securityButton.removeAttribute("level");
+      if (gURLBar)
+        gURLBar.removeAttribute("level");
+    }
+
+    if (setHost && this._host)
+      this.securityButton.setAttribute("label", this._host);
+    else
+      this.securityButton.removeAttribute("label");
+
+    this.securityButton.setAttribute("tooltiptext", this._tooltipText);
+
+    // Don't pass in the actual location object, since it can cause us to 
+    // hold on to the window object too long.  Just pass in the fields we
+    // care about. (bug 424829)
+    var location = gBrowser.contentWindow.location;
+    var locationObj = {};
+    try {
+      locationObj.host = location.host;
+      locationObj.hostname = location.hostname;
+      locationObj.port = location.port;
+    } catch (ex) {
+      // Can sometimes throw if the URL being visited has no host/hostname,
+      // e.g. about:blank. The _state for these pages means we won't need these
+      // properties anyways, though.
+    }
+    gIdentityHandler.checkIdentity(this._state, locationObj);
+  },
+
+  // simulate all change notifications after switching tabs
+  onUpdateCurrentBrowser: function (aStateFlags, aStatus, aMessage, aTotalProgress) {
+    var nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;
+    var loadingDone = aStateFlags & nsIWebProgressListener.STATE_STOP;
+    // use a pseudo-object instead of a (potentially non-existing) channel for getting
+    // a correct error message - and make sure that the UI is always either in
+    // loading (STATE_START) or done (STATE_STOP) mode
+    this.onStateChange(
+      gBrowser.webProgress,
+      { URI: gBrowser.currentURI },
+      loadingDone ? nsIWebProgressListener.STATE_STOP : nsIWebProgressListener.STATE_START,
+      aStatus
+    );
+    // status message and progress value are undefined if we're done with loading
+    if (loadingDone)
+      return;
+    this.onStatusChange(gBrowser.webProgress, null, 0, aMessage);
+    this.onProgressChange(gBrowser.webProgress, 0, 0, aTotalProgress, 1);
+  },
+
+  startDocumentLoad: function (aRequest) {
+    // clear out feed data
+    gBrowser.mCurrentBrowser.feeds = null;
+
+    // clear out search-engine data
+    gBrowser.mCurrentBrowser.engines = null;    
+
+    var uri = aRequest.QueryInterface(Ci.nsIChannel).URI;
+    var observerService = Cc["@mozilla.org/observer-service;1"]
+                            .getService(Ci.nsIObserverService);
+
+    if (gURLBar &&
+        gURLBar.value == "" &&
+        getWebNavigation().currentURI.spec == "about:blank")
+      URLBarSetURI(uri);
+
+    try {
+      observerService.notifyObservers(content, "StartDocumentLoad", uri.spec);
+    } catch (e) {
+    }
+  },
+
+  endDocumentLoad: function (aRequest, aStatus) {
+    var urlStr = aRequest.QueryInterface(Ci.nsIChannel).originalURI.spec;
+
+    var observerService = Cc["@mozilla.org/observer-service;1"]
+                            .getService(Ci.nsIObserverService);
+
+    var notification = Components.isSuccessCode(aStatus) ? "EndDocumentLoad" : "FailDocumentLoad";
+    try {
+      observerService.notifyObservers(content, notification, urlStr);
+    } catch (e) {
+    }
+  }
+}
+
+var TabsProgressListener = {
+  onProgressChange: function (aBrowser, aWebProgress, aRequest,
+                              aCurSelfProgress, aMaxSelfProgress,
+                              aCurTotalProgress, aMaxTotalProgress) {
+  },
+
+  onStateChange: function (aBrowser, aWebProgress, aRequest, aStateFlags, aStatus) {
+  },
+
+  onLocationChange: function (aBrowser, aWebProgress, aRequest, aLocationURI) {
+  },
+  
+  onStatusChange: function (aBrowser, aWebProgress, aRequest, aStatus, aMessage) {
+  },
+
+  onRefreshAttempted: function (aBrowser, aWebProgress, aURI, aDelay, aSameURI) {
     if (gPrefService.getBoolPref("accessibility.blockautorefresh")) {
       let brandBundle = document.getElementById("bundle_brand");
       let brandShortName = brandBundle.getString("brandShortName");
       let refreshButtonText =
         gNavigatorBundle.getString("refreshBlocked.goButton");
       let refreshButtonAccesskey =
         gNavigatorBundle.getString("refreshBlocked.goButton.accesskey");
       let message =
         gNavigatorBundle.getFormattedString(aSameURI ? "refreshBlocked.refreshLabel"
                                                      : "refreshBlocked.redirectLabel",
                                             [brandShortName]);
-      let topBrowser = getBrowserFromContentWindow(aWebProgress.DOMWindow.top);
       let docShell = aWebProgress.DOMWindow
                                  .QueryInterface(Ci.nsIInterfaceRequestor)
                                  .getInterface(Ci.nsIWebNavigation)
                                  .QueryInterface(Ci.nsIDocShell);
-      let notificationBox = gBrowser.getNotificationBox(topBrowser);
+      let notificationBox = gBrowser.getNotificationBox(aBrowser);
       let notification = notificationBox.getNotificationWithValue("refresh-blocked");
       if (notification) {
         notification.label = message;
         notification.refreshURI = aURI;
         notification.delay = aDelay;
         notification.docShell = docShell;
       } else {
         let buttons = [{
@@ -4088,164 +4263,17 @@ var XULBrowserWindow = {
         notification.delay = aDelay;
         notification.docShell = docShell;
       }
       return false;
     }
     return true;
   },
 
-  // Properties used to cache security state used to update the UI
-  _state: null,
-  _host: undefined,
-  _tooltipText: null,
-  _hostChanged: false, // onLocationChange will flip this bit
-
-  onSecurityChange: function (aWebProgress, aRequest, aState) {
-    // Don't need to do anything if the data we use to update the UI hasn't
-    // changed
-    if (this._state == aState &&
-        this._tooltipText == gBrowser.securityUI.tooltipText &&
-        !this._hostChanged) {
-#ifdef DEBUG
-      try {
-        var contentHost = gBrowser.contentWindow.location.host;
-        if (this._host !== undefined && this._host != contentHost) {
-            Components.utils.reportError(
-              "ASSERTION: browser.js host is inconsistent. Content window has " + 
-              "<" + contentHost + "> but cached host is <" + this._host + ">.\n"
-            );
-        }
-      } catch (ex) {}
-#endif
-      return;
-    }
-    this._state = aState;
-
-    try {
-      this._host = gBrowser.contentWindow.location.host;
-    } catch(ex) {
-      this._host = null;
-    }
-
-    this._hostChanged = false;
-    this._tooltipText = gBrowser.securityUI.tooltipText
-
-    // aState is defined as a bitmask that may be extended in the future.
-    // We filter out any unknown bits before testing for known values.
-    const wpl = Components.interfaces.nsIWebProgressListener;
-    const wpl_security_bits = wpl.STATE_IS_SECURE |
-                              wpl.STATE_IS_BROKEN |
-                              wpl.STATE_IS_INSECURE |
-                              wpl.STATE_SECURE_HIGH |
-                              wpl.STATE_SECURE_MED |
-                              wpl.STATE_SECURE_LOW;
-    var level;
-    var setHost = false;
-
-    switch (this._state & wpl_security_bits) {
-      case wpl.STATE_IS_SECURE | wpl.STATE_SECURE_HIGH:
-        level = "high";
-        setHost = true;
-        break;
-      case wpl.STATE_IS_SECURE | wpl.STATE_SECURE_MED:
-      case wpl.STATE_IS_SECURE | wpl.STATE_SECURE_LOW:
-        level = "low";
-        setHost = true;
-        break;
-      case wpl.STATE_IS_BROKEN:
-        level = "broken";
-        break;
-    }
-
-    if (level) {
-      this.securityButton.setAttribute("level", level);
-      this.securityButton.hidden = false;
-    } else {
-      this.securityButton.hidden = true;
-      this.securityButton.removeAttribute("level");
-    }
-
-    if (setHost && this._host)
-      this.securityButton.setAttribute("label", this._host);
-    else
-      this.securityButton.removeAttribute("label");
-
-    this.securityButton.setAttribute("tooltiptext", this._tooltipText);
-
-    // Don't pass in the actual location object, since it can cause us to 
-    // hold on to the window object too long.  Just pass in the fields we
-    // care about. (bug 424829)
-    var location = gBrowser.contentWindow.location;
-    var locationObj = {};
-    try {
-      locationObj.host = location.host;
-      locationObj.hostname = location.hostname;
-      locationObj.port = location.port;
-    } catch (ex) {
-      // Can sometimes throw if the URL being visited has no host/hostname,
-      // e.g. about:blank. The _state for these pages means we won't need these
-      // properties anyways, though.
-    }
-    gIdentityHandler.checkIdentity(this._state, locationObj);
-  },
-
-  // simulate all change notifications after switching tabs
-  onUpdateCurrentBrowser: function (aStateFlags, aStatus, aMessage, aTotalProgress) {
-    var nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;
-    var loadingDone = aStateFlags & nsIWebProgressListener.STATE_STOP;
-    // use a pseudo-object instead of a (potentially non-existing) channel for getting
-    // a correct error message - and make sure that the UI is always either in
-    // loading (STATE_START) or done (STATE_STOP) mode
-    this.onStateChange(
-      gBrowser.webProgress,
-      { URI: gBrowser.currentURI },
-      loadingDone ? nsIWebProgressListener.STATE_STOP : nsIWebProgressListener.STATE_START,
-      aStatus
-    );
-    // status message and progress value are undefined if we're done with loading
-    if (loadingDone)
-      return;
-    this.onStatusChange(gBrowser.webProgress, null, 0, aMessage);
-    this.onProgressChange(gBrowser.webProgress, 0, 0, aTotalProgress, 1);
-  },
-
-  startDocumentLoad: function (aRequest) {
-    // clear out feed data
-    gBrowser.mCurrentBrowser.feeds = null;
-
-    // clear out search-engine data
-    gBrowser.mCurrentBrowser.engines = null;    
-
-    var uri = aRequest.QueryInterface(Ci.nsIChannel).URI;
-    var observerService = Cc["@mozilla.org/observer-service;1"]
-                            .getService(Ci.nsIObserverService);
-
-    if (gURLBar &&
-        gURLBar.value == "" &&
-        getWebNavigation().currentURI.spec == "about:blank")
-      URLBarSetURI(uri);
-
-    try {
-      observerService.notifyObservers(content, "StartDocumentLoad", uri.spec);
-    } catch (e) {
-    }
-  },
-
-  endDocumentLoad: function (aRequest, aStatus) {
-    var urlStr = aRequest.QueryInterface(Ci.nsIChannel).originalURI.spec;
-
-    var observerService = Cc["@mozilla.org/observer-service;1"]
-                            .getService(Ci.nsIObserverService);
-
-    var notification = Components.isSuccessCode(aStatus) ? "EndDocumentLoad" : "FailDocumentLoad";
-    try {
-      observerService.notifyObservers(content, notification, urlStr);
-    } catch (e) {
-    }
+  onSecurityChange: function (aBrowser, aWebProgress, aRequest, aState) {
   }
 }
 
 function nsBrowserAccess()
 {
 }
 
 nsBrowserAccess.prototype =
diff -r 8b3caddca8f5 browser/base/content/browser.xul
--- a/browser/base/content/browser.xul	Sat Nov 15 23:56:49 2008 -0800
+++ b/browser/base/content/browser.xul	Sat Nov 22 15:25:48 2008 -0500
@@ -228,17 +228,17 @@
           </hbox>
         </vbox>
       </hbox>
     </panel>
 
     <tooltip id="urlTooltip">
       <label crop="center" flex="1" class="tooltip-label"/>
     </tooltip>
-
+#ifdef USE_TAB_PREVIEWS
     <panel id="ctrlTab-panel" class="KUI-panel" hidden="true" norestorefocus="true" ignorekeys="true">
       <hbox pack="center">
         <textbox id="ctrlTab-search"
                  type="search"
                  emptytext="&ctrlTab.search.emptyText;"
                  oncommand="ctrlTab.search();"
                  onfocus="ctrlTab.sticky = true;"/>
       </hbox>
@@ -254,31 +254,32 @@
       </hbox>
       <hbox class="ctrlTab-row">
         <hbox flex="1" pack="center"><vbox class="ctrlTab-thumbnail"/></hbox>
         <vbox class="ctrlTab-thumbnail"/>
         <hbox flex="1" pack="center"><vbox class="ctrlTab-thumbnail"/></hbox>
       </hbox>
       <hbox id="ctrlTab-pages"/>
     </panel>
+#endif
   </popupset>
 
   <!-- bookmarks toolbar tooltip -->
   <tooltip id="btTooltip" noautohide="true"
            onpopupshowing="return BookmarksEventHandler.fillInBTTooltip(document.tooltipNode)">
     <vbox id="btTooltipTextBox" flex="1">
       <label id="btTitleText" class="tooltip-label" />
       <label id="btUrlText" crop="center" class="tooltip-label" />
     </vbox>
   </tooltip>
 
   <toolbox id="navigator-toolbox" class="toolbox-top" mode="icons"
-           ondragover="gBrowser._onDragOver(event); event.stopPropagation();"
-           ondrop="gBrowser._onDrop(event); event.stopPropagation();"
-           ondragleave="gBrowser._onDragLeave(event); event.stopPropagation();"
+           ondragover="gBrowser._onDragOver(event);"
+           ondrop="gBrowser._onDrop(event);"
+           ondragleave="gBrowser._onDragLeave(event);"
            defaultmode="icons">
     <!-- Menu -->
     <toolbar type="menubar" id="toolbar-menubar" class="chromeclass-menubar" customizable="true"
              defaultset="menubar-items"
              mode="icons" iconsize="small" defaulticonsize="small"
              context="toolbar-context-menu">
       <toolbaritem id="menubar-items" align="center">
 # The entire main menubar is placed into browser-menubar.inc, so that it can be shared by 
diff -r 8b3caddca8f5 browser/base/content/sanitize.js
--- a/browser/base/content/sanitize.js	Sat Nov 15 23:56:49 2008 -0800
+++ b/browser/base/content/sanitize.js	Sat Nov 22 15:25:48 2008 -0500
@@ -225,17 +225,20 @@ Sanitizer.prototype = {
           if (searchBar) {
             searchBar.value = "";
             searchBar.textbox.editor.transactionManager.clear();
           }
         }
 
         var formHistory = Components.classes["@mozilla.org/satchel/form-history;1"]
                                     .getService(Components.interfaces.nsIFormHistory2);
-        formHistory.removeAllEntries();
+        if (this.range)
+          formHistory.removeEntriesByTimeframe(this.range[0], this.range[1]);
+        else
+          formHistory.removeAllEntries();
       },
 
       get canClear()
       {
         var windowManager = Components.classes['@mozilla.org/appshell/window-mediator;1']
                                       .getService(Components.interfaces.nsIWindowMediator);
         var windows = windowManager.getEnumerator("navigator:browser");
         while (windows.hasMoreElements()) {
diff -r 8b3caddca8f5 browser/base/content/sanitize.xul
--- a/browser/base/content/sanitize.xul	Sat Nov 15 23:56:49 2008 -0800
+++ b/browser/base/content/sanitize.xul	Sat Nov 22 15:25:48 2008 -0500
@@ -192,17 +192,17 @@
     <preferences id="nonItemPreferences">
       <preference id="privacy.sanitize.timeSpan"
                   name="privacy.sanitize.timeSpan"
                   type="int"/>
     </preferences>
 
     <groupbox orient="vertical">
       <caption label="&historySection.label;"/>
-      <hbox id="SanitizeDurationBox">
+      <hbox id="SanitizeDurationBox" align="center">
         <label value="&clearDuration.label;" control="sanitizeDurationChoice" id="sanitizeDurationLabel"/>
         <menulist id="sanitizeDurationChoice"
                   preference="privacy.sanitize.timeSpan">
           <menupopup>
             <menuitem label="&clearDuration.lastHour;" value="1"/>
             <menuitem label="&clearDuration.last2Hours;" value="2"/>
             <menuitem label="&clearDuration.last4Hours;" value="3"/>
             <menuitem label="&clearDuration.today;" value="4"/>
diff -r 8b3caddca8f5 browser/base/content/tabbrowser.css
--- a/browser/base/content/tabbrowser.css	Sat Nov 15 23:56:49 2008 -0800
+++ b/browser/base/content/tabbrowser.css	Sat Nov 22 15:25:48 2008 -0500
@@ -4,16 +4,22 @@
 
 .tabbrowser-tab {
   -moz-binding: url("chrome://browser/content/tabbrowser.xml#tabbrowser-tab");
 }
 
 %ifdef XP_MACOSX
 .tabbrowser-arrowscrollbox {
   -moz-binding: url("chrome://browser/content/tabbrowser.xml#tabbrowser-arrowscrollbox");
+}
+%endif
+
+%ifndef USE_TAB_PREVIEWS
+.tabs-alltabs-popup {
+  -moz-binding: url("chrome://browser/content/tabbrowser.xml#tabbrowser-alltabs-popup");
 }
 %endif
 
 .tab-close-button, .tabs-closebutton {
   -moz-binding: url("chrome://browser/content/tabbrowser.xml#tabbrowser-close-tab-button");
 }
 
 .tab-close-button {
diff -r 8b3caddca8f5 browser/base/content/tabbrowser.xml
--- a/browser/base/content/tabbrowser.xml	Sat Nov 15 23:56:49 2008 -0800
+++ b/browser/base/content/tabbrowser.xml	Sat Nov 22 15:25:48 2008 -0500
@@ -64,28 +64,28 @@
       <stylesheet src="chrome://browser/content/tabbrowser.css"/>
     </resources>
 
     <content>
       <xul:stringbundle anonid="tbstringbundle" src="chrome://browser/locale/tabbrowser.properties"/>
       <xul:tabbox anonid="tabbox" flex="1" eventnode="document" xbl:inherits="handleCtrlPageUpDown"
                   onselect="if (!('updateCurrentBrowser' in this.parentNode) || event.target.localName != 'tabpanels') return; this.parentNode.updateCurrentBrowser();">
         <xul:hbox class="tab-drop-indicator-bar" collapsed="true" chromedir="&locale.dir;"
-                  ondragover="this.parentNode.parentNode._onDragOver(event); event.stopPropagation();"
-                  ondragleave="this.parentNode.parentNode._onDragLeave(event); event.stopPropagation();"
-                  ondrop="this.parentNode.parentNode._onDrop(event); event.stopPropagation();">
+                  ondragover="this.parentNode.parentNode._onDragOver(event);"
+                  ondragleave="this.parentNode.parentNode._onDragLeave(event);"
+                  ondrop="this.parentNode.parentNode._onDrop(event);">
           <xul:hbox class="tab-drop-indicator" mousethrough="always"/>
         </xul:hbox>
         <xul:hbox class="tabbrowser-strip" collapsed="true" tooltip="_child" context="_child"
                   anonid="strip"
-                  ondragstart="this.parentNode.parentNode._onDragStart(event); event.stopPropagation();"
-                  ondragover="this.parentNode.parentNode._onDragOver(event); event.stopPropagation();"
-                  ondrop="this.parentNode.parentNode._onDrop(event); event.stopPropagation();"
-                  ondragend="this.parentNode.parentNode._onDragEnd(event); event.stopPropagation();"
-                  ondragleave="this.parentNode.parentNode._onDragLeave(event); event.stopPropagation();">
+                  ondragstart="this.parentNode.parentNode._onDragStart(event);"
+                  ondragover="this.parentNode.parentNode._onDragOver(event);"
+                  ondrop="this.parentNode.parentNode._onDrop(event);"
+                  ondragend="this.parentNode.parentNode._onDragEnd(event);"
+                  ondragleave="this.parentNode.parentNode._onDragLeave(event);">
           <xul:tooltip onpopupshowing="return this.parentNode.parentNode.parentNode.createTooltip(event);"/>
           <xul:menupopup anonid="tabContextMenu" onpopupshowing="this.parentNode.parentNode.parentNode.updatePopupMenu(this);">
             <xul:menuitem id="context_newTab" label="&newTab.label;" accesskey="&newTab.accesskey;"
                           xbl:inherits="oncommand=onnewtab"/>
             <xul:menuseparator/>
             <xul:menuitem id="context_reloadTab" label="&reloadTab.label;" accesskey="&reloadTab.accesskey;"
                           oncommand="var tabbrowser = this.parentNode.parentNode.parentNode.parentNode;
                                      tabbrowser.reloadTab(tabbrowser.mContextTab);"/>
@@ -189,16 +189,19 @@
         null
       </field>
       <field name="mCurrentBrowser">
         null
       </field>
       <field name="mProgressListeners">
         []
       </field>
+      <field name="mTabsProgressListeners">
+        []
+      </field>
       <field name="mTabListeners">
         new Array()
       </field>
       <field name="mTabFilters">
         new Array()
       </field>
       <field name="mTabbedMode">
         false
@@ -298,32 +301,48 @@
 
             // count of open requests (should always be 0 or 1)
             mRequestCount: 0,
 
             onProgressChange : function (aWebProgress, aRequest,
                                          aCurSelfProgress, aMaxSelfProgress,
                                          aCurTotalProgress, aMaxTotalProgress)
             {
-              if (!this.mBlank && this.mTabBrowser.mCurrentTab == this.mTab) {
+              this.mTotalProgress = aMaxTotalProgress ? aCurTotalProgress / aMaxTotalProgress : 0;
+
+              if (this.mBlank)
+                return;
+
+              if (this.mTabBrowser.mCurrentTab == this.mTab) {
                 for (var i = 0; i < this.mTabBrowser.mProgressListeners.length; i++) {
                   var p = this.mTabBrowser.mProgressListeners[i];
                   if (p)
                     try {
                       p.onProgressChange(aWebProgress, aRequest,
                                          aCurSelfProgress, aMaxSelfProgress,
                                          aCurTotalProgress, aMaxTotalProgress);
                     } catch (e) {
                       // don't inhibit other listeners or following code
                       Components.utils.reportError(e);
                     }
                 }
               }
 
-              this.mTotalProgress = aMaxTotalProgress ? aCurTotalProgress / aMaxTotalProgress : 0;
+              for (var i = 0; i < this.mTabBrowser.mTabsProgressListeners.length; i++) {
+                var p = this.mTabBrowser.mTabsProgressListeners[i];
+                if (p)
+                  try {
+                    p.onProgressChange(this.mBrowser, aWebProgress, aRequest,
+                                       aCurSelfProgress, aMaxSelfProgress,
+                                       aCurTotalProgress, aMaxTotalProgress);
+                  } catch (e) {
+                    // don't inhibit other listeners or following code
+                    Components.utils.reportError(e);
+                  }
+              }
             },
 
             onProgressChange64 : function (aWebProgress, aRequest,
                                          aCurSelfProgress, aMaxSelfProgress,
                                          aCurTotalProgress, aMaxTotalProgress)
             {
               return this.onProgressChange(aWebProgress, aRequest,
                 aCurSelfProgress, aMaxSelfProgress, aCurTotalProgress,
@@ -422,16 +441,27 @@
                         p.onUpdateCurrentBrowser(aStateFlags, aStatus, "", 0);
                     } catch (e) {
                       // don't inhibit other listeners or following code
                       Components.utils.reportError(e);
                     }
                 }
               }
 
+              for (var i = 0; i < this.mTabBrowser.mTabsProgressListeners.length; i++) {
+                var p = this.mTabBrowser.mTabsProgressListeners[i];
+                if (p)
+                  try {
+                    p.onStateChange(this.mBrowser, aWebProgress, aRequest, aStateFlags, aStatus);
+                  } catch (e) {
+                    // don't inhibit other listeners or following code
+                    Components.utils.reportError(e);
+                  }
+              }
+
               if (aStateFlags & (nsIWebProgressListener.STATE_START |
                                  nsIWebProgressListener.STATE_STOP)) {
                 // reset cached temporary values at beginning and end
                 this.mMessage = "";
                 this.mTotalProgress = 0;
               }
               this.mStateFlags = aStateFlags;
               this.mStatus = aStatus;
@@ -445,27 +475,41 @@
 
               if (aWebProgress.DOMWindow == this.mBrowser.contentWindow &&
                   aWebProgress.isLoadingDocument)
                 this.mTabBrowser.setIcon(this.mTab, null);
 
               // changing location, clear out the missing plugins list
               this.mBrowser.missingPlugins = null;
 
-              if (!this.mBlank && this.mTabBrowser.mCurrentTab == this.mTab) {
+              if (this.mBlank)
+                return;
+
+              if (this.mTabBrowser.mCurrentTab == this.mTab) {
                 for (var i = 0; i < this.mTabBrowser.mProgressListeners.length; i++) {
                   var p = this.mTabBrowser.mProgressListeners[i];
                   if (p)
                     try {
                       p.onLocationChange(aWebProgress, aRequest, aLocation);
                     } catch (e) {
                       // don't inhibit other listeners
                       Components.utils.reportError(e);
                     }
                 }
+              }
+
+              for (var i = 0; i < this.mTabBrowser.mTabsProgressListeners.length; i++) {
+                var p = this.mTabBrowser.mTabsProgressListeners[i];
+                if (p)
+                  try {
+                    p.onLocationChange(this.mBrowser, aWebProgress, aRequest, aLocation);
+                  } catch (e) {
+                    // don't inhibit other listeners
+                    Components.utils.reportError(e);
+                  }
               }
             },
 
             onStatusChange : function(aWebProgress, aRequest, aStatus, aMessage)
             {
               if (this.mBlank)
                 return;
 
@@ -477,16 +521,27 @@
                       p.onStatusChange(aWebProgress, aRequest, aStatus, aMessage);
                     } catch (e) {
                       // don't inhibit other listeners or following code
                       Components.utils.reportError(e);
                     }
                 }
               }
 
+              for (var i = 0; i < this.mTabBrowser.mTabsProgressListeners.length; i++) {
+                var p = this.mTabBrowser.mTabsProgressListeners[i];
+                if (p)
+                  try {
+                    p.onStatusChange(this.mBrowser, aWebProgress, aRequest, aStatus, aMessage);
+                  } catch (e) {
+                    // don't inhibit other listeners or following code
+                    Components.utils.reportError(e);
+                  }
+              }
+
               this.mMessage = aMessage;
             },
 
             onSecurityChange : function(aWebProgress, aRequest, aState)
             {
               if (this.mTabBrowser.mCurrentTab == this.mTab) {
                 for (var i = 0; i < this.mTabBrowser.mProgressListeners.length; i++) {
                   var p = this.mTabBrowser.mProgressListeners[i];
@@ -494,36 +549,62 @@
                     try {
                       p.onSecurityChange(aWebProgress, aRequest, aState);
                     } catch (e) {
                       // don't inhibit other listeners
                       Components.utils.reportError(e);
                     }
                 }
               }
+
+              for (var i = 0; i < this.mTabBrowser.mTabsProgressListeners.length; i++) {
+                var p = this.mTabBrowser.mTabsProgressListeners[i];
+                if (p)
+                  try {
+                    p.onSecurityChange(this.mBrowser, aWebProgress, aRequest, aState);
+                  } catch (e) {
+                    // don't inhibit other listeners
+                    Components.utils.reportError(e);
+                  }
+              }
             },
 
-             onRefreshAttempted : function(aWebProgress, aURI, aDelay, aSameURI)
-             {
-               var allowRefresh = true;
-               for (var i = 0; i < this.mTabBrowser.mProgressListeners.length; i++) {
-                 var p = this.mTabBrowser.mProgressListeners[i];
-                 if (p && "onRefreshAttempted" in p) {
-                   try {
-                     if (!p.onRefreshAttempted(aWebProgress, aURI, aDelay, aSameURI))
-                       allowRefresh = false;
-                    } catch (e) {
-                      // don't inhibit other listeners or following code
-                      Components.utils.reportError(e);
-                    }
-                 }
-               }
-               return allowRefresh;
-             },
- 
+            onRefreshAttempted : function(aWebProgress, aURI, aDelay, aSameURI)
+            {
+              var allowRefresh = true;
+              if (this.mTabBrowser.mCurrentTab == this.mTab) {
+                for (var i = 0; i < this.mTabBrowser.mProgressListeners.length; i++) {
+                  var p = this.mTabBrowser.mProgressListeners[i];
+                  if (p && "onRefreshAttempted" in p) {
+                    try {
+                      if (!p.onRefreshAttempted(aWebProgress, aURI, aDelay, aSameURI))
+                        allowRefresh = false;
+                     } catch (e) {
+                       // don't inhibit other listeners or following code
+                       Components.utils.reportError(e);
+                     }
+                  }
+                }
+              }
+
+              for (var i = 0; i < this.mTabBrowser.mTabsProgressListeners.length; i++) {
+                var p = this.mTabBrowser.mTabsProgressListeners[i];
+                if (p && "onRefreshAttempted" in p) {
+                  try {
+                    if (!p.onRefreshAttempted(this.mBrowser, aWebProgress, aURI, aDelay, aSameURI))
+                      allowRefresh = false;
+                   } catch (e) {
+                     // don't inhibit other listeners or following code
+                     Components.utils.reportError(e);
+                   }
+                }
+              }
+              return allowRefresh;
+            },
+
             QueryInterface : function(aIID)
             {
               if (aIID.equals(Components.interfaces.nsIWebProgressListener) ||
                   aIID.equals(Components.interfaces.nsIWebProgressListener2) ||
                   aIID.equals(Components.interfaces.nsISupportsWeakReference) ||
                   aIID.equals(Components.interfaces.nsISupports))
                 return this;
               throw Components.results.NS_NOINTERFACE;
@@ -548,18 +629,31 @@
                 aURI = ios.newURI(aURI, null, null);
               }
               this.mFaviconService.setAndLoadFaviconForPage(browser.currentURI,
                                                             aURI, false);
             }
 
             this.updateIcon(aTab);
 
-            for (var i = 0; i < this.mProgressListeners.length; i++) {
-              var p = this.mProgressListeners[i];
+            if (browser == this.mCurrentBrowser) {
+              for (var i = 0; i < this.mProgressListeners.length; i++) {
+                var p = this.mProgressListeners[i];
+                if ('onLinkIconAvailable' in p)
+                  try {
+                    p.onLinkIconAvailable(browser);
+                  } catch (e) {
+                    // don't inhibit other listeners
+                    Components.utils.reportError(e);
+                  }
+              }
+            }
+
+            for (var i = 0; i < this.mTabsProgressListeners.length; i++) {
+              var p = this.mTabsProgressListeners[i];
               if ('onLinkIconAvailable' in p)
                 try {
                   p.onLinkIconAvailable(browser);
                 } catch (e) {
                   // don't inhibit other listeners
                   Components.utils.reportError(e);
                 }
             }
@@ -1726,16 +1820,36 @@
 
             if (!this.mTabbedMode)
               // Don't forget to remove it from the filter we hooked it up to
               this.mTabFilters[0].removeProgressListener(aListener);
          ]]>
         </body>
       </method>
 
+      <method name="addTabsProgressListener">
+        <parameter name="aListener"/>
+        <body>
+          if (!this.mTabbedMode)
+            this.enterTabbedMode();
+          this.mTabsProgressListeners.push(aListener);
+        </body>
+      </method>
+
+      <method name="removeTabsProgressListener">
+        <parameter name="aListener"/>
+        <body>
+        <![CDATA[
+          var pos = this.mTabsProgressListeners.indexOf(aListener);
+          if (pos >= 0)
+            this.mTabsProgressListeners.splice(pos, 1);
+        ]]>
+        </body>
+      </method>
+
       <method name="getBrowserForTab">
         <parameter name="aTab"/>
         <body>
         <![CDATA[
           return aTab.linkedBrowser;
         ]]>
         </body>
       </method>
@@ -1793,114 +1907,130 @@
           ]]>
         </getter>
       </property>
 
       <method name="_onDragStart">
         <parameter name="aEvent"/>
         <body>
         <![CDATA[
+          // don't interfere with toolbar customization
+          if (gNavToolbox.customizing)
+            return;
+
           var target = aEvent.target;
           if (target.localName == "tab" &&
               aEvent.originalTarget.localName != "toolbarbutton") {
             var dt = aEvent.dataTransfer;
             // We're internetionally not setting any other data-type, otherwise
             // applications may override our drop-as-window behavior
             dt.mozSetDataAt("application/x-moz-tabbrowser-tab", target, 0);
 
             var canvas = tabPreviews.capture(target, false);
             dt.setDragImage(canvas, 0, 0);
+            aEvent.stopPropagation();
           }
         ]]>
         </body>
       </method>
 
       <field name="mDragTime">0</field>
       <field name="mDragOverDelay">350</field>
 
       <field name="_supportedLinkDropTypes"><![CDATA[
         ["text/x-moz-url", "text/uri-list", "text/plain", "application/x-moz-file"]
       ]]></field>
 
       <field name="_cachedTargetInToolbox">null</field>
+      <field name="_draggingOnItself">false</field>
       <method name="_setEffectAllowedForDataTransfer">
         <parameter name="aEvent"/>
         <body>
           <![CDATA[
+            this._draggingOnItself = false;
+
             // Find out if the we're dragged over the toolbox
             var target = aEvent.target;
             var isInToolbox = target == this._cachedTargetInToolbox;
             while (target && !isInToolbox) {
               if (target == gNavToolbox) {
                 isInToolbox = true;
                 this._cachedTargetInToolbox = target;
               }
               else
                 target = target.parentNode;
             }
 
+            // NOTE: within the toolbox, we don't touch effectAllowed for
+            // anything but tabs
             var dt = aEvent.dataTransfer;
             // Disallow dropping multiple items
             if (dt.mozItemCount > 1)
-              return dt.effectAllowed = "none";
+              return isInToolbox ? "" : dt.effectAllowed = "none";
 
             var types = dt.mozTypesAt(0);
             var sourceNode = null;
             // tabs are always added as the first type
             if (types[0] == "application/x-moz-tabbrowser-tab") {
               var sourceNode = dt.mozGetDataAt("application/x-moz-tabbrowser-tab", 0);
               if (sourceNode instanceof XULElement &&
                   sourceNode.localName == "tab" &&
                   (sourceNode.parentNode == this.mTabContainer ||
                    (sourceNode.ownerDocument.defaultView instanceof ChromeWindow &&
                     sourceNode.ownerDocument.documentElement.getAttribute("windowtype") == "navigator:browser"))) {
                 if (sourceNode.parentNode == this.mTabContainer &&
                     (aEvent.screenX >= sourceNode.boxObject.screenX &&
                       aEvent.screenX <= (sourceNode.boxObject.screenX +
                                          sourceNode.boxObject.width))) {
+                  this._draggingOnItself = true;
                   return dt.effectAllowed = "none";
                 }
 
                 // Within the toolbox, allow dropping by the height of a tab off
                 // the tabbar
                 if (isInToolbox &&
                     aEvent.screenY < sourceNode.boxObject.screenY -
                                      sourceNode.boxObject.height)
                   return dt.effectAllowed = "none";
                 return dt.effectAllowed = "copyMove";
               }
             }
 
-            // only tab-drags are taken care off within the toolbox
-            if (!isInToolbox)
-              return dt.effectAllowed = "none";
+            // only tab-drags are taken care of within the toolbox
+            if (isInToolbox)
+              return ""; // see note above the tab-drags block
 
             for (var i=0; i < this._supportedLinkDropTypes.length; i++) {
               if (types.contains(this._supportedLinkDropTypes[i])) {
                 // Here we need to to do this manually
                 return dt.effectAllowed = dt.dropEffect = "link";
               }
             }
             return dt.effectAllowed = "none";
           ]]>
         </body>
       </method>
 
       <method name="_onDragOver">
         <parameter name="aEvent"/>
         <body>
           <![CDATA[
+            // don't interfere with toolbar customization
+            if (gNavToolbox.customizing)
+              return;
+
             var effects = this._setEffectAllowedForDataTransfer(aEvent);
 
             var ib = this.mTabDropIndicatorBar;
-            if (effects == "none") {
+            if (effects == "" || effects == "none") {
               ib.collapsed = "true";
               return;
             }
             aEvent.preventDefault();
+            aEvent.stopPropagation();
 
             var tabStrip = this.mTabContainer.mTabstrip;
             var ltr = (window.getComputedStyle(this.parentNode, null).direction
                        == "ltr");
 
             // autoscroll the tab strip if we drag over the scroll
             // buttons, even if we aren't dragging a tab, but then
             // return to avoid drawing the drop indicator
@@ -1984,26 +2114,32 @@
           ]]>
         </body>
       </method>
 
       <method name="_onDrop">
         <parameter name="aEvent"/>
         <body>
           <![CDATA[
+            // don't interfere with toolbar customization
+            if (gNavToolbox.customizing)
+              return;
+
             var dt = aEvent.dataTransfer;
             var dropEffect = dt.dropEffect;
             var draggedTab;
             if (dropEffect != "link") { // copy or move
               draggedTab = dt.mozGetDataAt("application/x-moz-tabbrowser-tab", 0);
-              NS_ASSERT(draggedTab && draggedTab.localName == "tab",
-                        "copy or move action without a tab");
+              // not our drop then
+              if (!draggedTab)
+                return;
             }
 
             this.mTabDropIndicatorBar.collapsed = true;
+            aEvent.stopPropagation();
 
             if (draggedTab && (dropEffect == "copy" ||
                 draggedTab.parentNode == this.mTabContainer)) {
               var newIndex = this.getNewIndex(aEvent);
               if (dropEffect == "copy") {
                 // copy the dropped tab (wherever it's from)
                 var newTab = this.duplicateTab(draggedTab);
                 this.moveTabTo(newTab, newIndex);
@@ -2102,20 +2238,21 @@
       <method name="_onDragEnd">
         <parameter name="aEvent"/>
         <body>
           <![CDATA[
             if (this.mTabs.length == 1)
               return;
 
             var dt = aEvent.dataTransfer;
-            if (dt.dropEffect == "none") {
+            if (dt.dropEffect == "none" && !this._draggingOnItself) {
               var draggedTab = dt.mozGetDataAt("application/x-moz-tabbrowser-tab", 0);
               this._replaceTabWithWindow(draggedTab);
             }
+            aEvent.stopPropagation();
           ]]>
         </body>
       </method>
 
       <method name="_replaceTabWithWindow">
         <parameter name="aTab"/>
         <body>
           <![CDATA[
@@ -2140,16 +2277,18 @@
             // This does not work at all (see bug 458613)
             var target = aEvent.relatedTarget;
             while (target && (target != this && target != gNavToolbox))
               target = target.parentNode;
             if (target)
               return;
 
             this.mTabDropIndicatorBar.collapsed = true;
+            this._draggingOnItself = false;
+            aEvent.stopPropagation();
           ]]>
         </body>
       </method>
 
       <method name="moveTabTo">
         <parameter name="aTab"/>
         <parameter name="aIndex"/>
         <body>
@@ -2801,20 +2940,30 @@
 #endif
                               class="tabbrowser-arrowscrollbox">
             <children/>
           </xul:arrowscrollbox>
           <xul:toolbarbutton class="tabs-newtab-button" anonid="newtab-button"
                              command="cmd_newNavigatorTab" chromedir="&locale.dir;"
                              tooltiptext="&newTabButton.tooltip;"/>
           <xul:stack align="center" pack="end" chromedir="&locale.dir;">
+#ifdef USE_TAB_PREVIEWS
             <xul:hbox flex="1" class="tabs-alltabs-box-animate" anonid="alltabs-box-animate"/>
             <xul:toolbarbutton class="tabs-alltabs-button" anonid="alltabs-button"
                                tooltiptext="&listAllTabs.label;"
                                oncommand="ctrlTab.open(true);"/>
+#else
+            <xul:hbox flex="1" class="tabs-alltabs-box" anonid="alltabs-box"/>
+            <xul:hbox flex="1" class="tabs-alltabs-box-animate" anonid="alltabs-box-animate"/>
+            <xul:toolbarbutton class="tabs-alltabs-button" type="menu" anonid="alltabs-button"
+                               tooltiptext="&listAllTabs.label;">
+             <xul:menupopup class="tabs-alltabs-popup" anonid="alltabs-popup"
+                            position="after_end"/>
+            </xul:toolbarbutton>
+#endif
           </xul:stack>
 #ifdef XP_MACOSX
           <xul:hbox anonid="tabstrip-closebutton" class="tabs-closebutton-box" align="center" pack="end" chromedir="&locale.dir;">
 #endif
           <xul:toolbarbutton anonid="tabs-closebutton"
                              class="close-button tabs-closebutton" chromedir="&locale.dir;"/>
 #ifdef XP_MACOSX
           </xul:hbox>
@@ -2997,16 +3146,23 @@
                 this._handleTabSelect();
                 this.mTabstripWidth = width;
               }
               break;
           }
         ]]></body>
       </method>
 
+#ifndef USE_TAB_PREVIEWS
+      <field name="mAllTabsPopup">
+        document.getAnonymousElementByAttribute(this, 
+                                                "anonid", "alltabs-popup");
+      </field>
+#endif
+
       <field name="mAllTabsBoxAnimate">
         document.getAnonymousElementByAttribute(this, 
                                                 "anonid",
                                                 "alltabs-box-animate");
       </field>
 
 #ifdef XP_MACOSX
       <field name="mDownBoxAnimate">
@@ -3104,16 +3260,235 @@
         ]]></body>
       </method>
     </implementation>
     <handlers>
       <handler event="TabSelect" action="this._handleTabSelect();"/>
     </handlers>
   </binding>
 
+#ifndef USE_TAB_PREVIEWS
+  <!-- alltabs-popup binding
+       This binding relies on the structure of the tabbrowser binding.
+       Therefore it should only be used as a child of the tabs element.
+       This binding is exposed as a pseudo-public-API so themes can customize
+       the tabbar appearance without having to be scriptable
+       (see globalBindings.xml in Pinstripe for example).
+  -->
+
+  <binding id="tabbrowser-alltabs-popup"
+           extends="chrome://global/content/bindings/popup.xml#popup">
+    <implementation implements="nsIDOMEventListener">
+      <field name="_xulWindow">
+        null
+      </field>
+
+      <constructor><![CDATA[
+        // We cannot cache the XULBrowserWindow object itself since it might
+        // be set after this binding is constructed.
+        try {
+          this._xulWindow = 
+            window.QueryInterface(Components.interfaces.nsIInterfaceRequestor)
+                  .getInterface(Components.interfaces.nsIWebNavigation)
+                  .QueryInterface(Components.interfaces.nsIDocShellTreeItem)
+                  .treeOwner
+                  .QueryInterface(Components.interfaces.nsIInterfaceRequestor)
+                  .getInterface(Components.interfaces.nsIXULWindow);
+        }
+        catch(ex) { }
+      ]]></constructor>
+
+      <method name="_menuItemOnCommand">
+        <parameter name="aEvent"/>
+
+        <body><![CDATA[
+          var tabcontainer = document.getBindingParent(this);
+          tabcontainer.selectedItem = aEvent.target.tab;
+        ]]></body>
+      </method>
+
+      <method name="_tabOnAttrModified">
+        <parameter name="aEvent"/>
+        <body><![CDATA[
+          var menuItem = aEvent.target.mCorrespondingMenuitem;
+          if (menuItem) {
+            var attrName = aEvent.attrName;
+            switch (attrName) {
+              case "label":
+              case "crop":
+              case "busy":
+              case "image":
+              case "selected":
+                if (aEvent.attrChange == aEvent.REMOVAL)
+                  menuItem.removeAttribute(attrName);
+                else
+                  menuItem.setAttribute(attrName, aEvent.newValue);
+            }
+          }
+        ]]></body>
+      </method>
+
+      <method name="_tabOnTabClose">
+        <parameter name="aEvent"/>
+
+        <body><![CDATA[
+          var menuItem = aEvent.target.mCorrespondingMenuitem;
+          if (menuItem)
+            this.removeChild(menuItem);
+        ]]></body>
+      </method>
+
+      <method name="handleEvent">
+        <parameter name="aEvent"/>
+        <body><![CDATA[
+          if (!aEvent.isTrusted)
+            return;
+
+          switch (aEvent.type) {
+            case "command":
+              this._menuItemOnCommand(aEvent);
+              break;
+            case "DOMAttrModified":
+              this._tabOnAttrModified(aEvent);
+              break;
+            case "TabClose":
+              this._tabOnTabClose(aEvent);
+              break;
+            case "TabOpen":
+              this._createTabMenuItem(aEvent.originalTarget);
+              break;
+            case "scroll":
+              this._updateTabsVisibilityStatus();
+              break;
+          }
+        ]]></body>
+      </method>
+
+      <method name="_updateTabsVisibilityStatus">
+        <body><![CDATA[
+          var tabContainer = document.getBindingParent(this);
+          // We don't want menu item decoration unless there is overflow.
+          if (tabContainer.getAttribute("overflow") != "true")
+            return;
+
+          var tabstripBO = tabContainer.mTabstrip.scrollBoxObject;
+          for (var i = 0; i < this.childNodes.length; i++) {
+            var curTabBO = this.childNodes[i].tab.boxObject;
+            if (curTabBO.screenX >= tabstripBO.screenX &&
+                curTabBO.screenX + curTabBO.width <= tabstripBO.screenX + tabstripBO.width)
+              this.childNodes[i].setAttribute("tabIsVisible", "true"); 
+            else
+              this.childNodes[i].removeAttribute("tabIsVisible");
+          }
+        ]]></body>
+
+      </method>
+
+      <method name="_createTabMenuItem">
+        <parameter name="aTab"/>
+        <body><![CDATA[
+          var menuItem = document.createElementNS(
+            "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul", 
+            "menuitem");
+
+          menuItem.setAttribute("class", "menuitem-iconic alltabs-item");
+
+          menuItem.setAttribute("label", aTab.label);
+          menuItem.setAttribute("crop", aTab.getAttribute("crop"));
+          menuItem.setAttribute("image", aTab.getAttribute("image"));
+
+          if (aTab.hasAttribute("busy"))
+            menuItem.setAttribute("busy", aTab.getAttribute("busy"));
+          if (aTab.selected)
+            menuItem.setAttribute("selected", "true");
+
+          // Keep some attributes of the menuitem in sync with its
+          // corresponding tab (e.g. the tab label)
+          aTab.mCorrespondingMenuitem = menuItem;
+          aTab.addEventListener("DOMAttrModified", this, false);
+          aTab.addEventListener("TabClose", this, false);
+          menuItem.tab = aTab;
+          menuItem.addEventListener("command", this, false);
+
+          this.appendChild(menuItem);
+          return menuItem;
+        ]]></body>
+      </method>
+    </implementation>
+
+    <handlers>
+      <handler event="popupshowing">
+
+      <![CDATA[
+        // set up the menu popup
+        var tabcontainer = document.getBindingParent(this);
+        var tabs = tabcontainer.childNodes;
+
+        // Listen for changes in the tab bar.
+        var tabbrowser = document.getBindingParent(tabcontainer);
+        tabbrowser.addEventListener("TabOpen", this, false);
+        tabcontainer.mTabstrip.addEventListener("scroll", this, false);
+
+        // if an animation is in progress and the user
+        // clicks on the "all tabs" button, stop the animation
+        tabcontainer._stopAnimation();
+
+        for (var i = 0; i < tabs.length; i++) {
+          this._createTabMenuItem(tabs[i]);
+        }
+        this._updateTabsVisibilityStatus();
+      ]]></handler>
+
+      <handler event="popuphiding">
+      <![CDATA[
+        // clear out the menu popup and remove the listeners
+        while (this.hasChildNodes()) {
+          var menuItem = this.lastChild;
+          menuItem.removeEventListener("command", this, false);
+          menuItem.tab.removeEventListener("DOMAttrModified", this, false);
+          menuItem.tab.removeEventListener("TabClose", this, false);
+          menuItem.tab.mCorrespondingMenuitem = null;
+          this.removeChild(menuItem);
+        }
+        var tabcontainer = document.getBindingParent(this);
+        tabcontainer.mTabstrip.removeEventListener("scroll", this, false);
+        document.getBindingParent(tabcontainer).removeEventListener("TabOpen", this, false);
+      ]]></handler>
+
+      <handler event="DOMMenuItemActive">
+      <![CDATA[
+        if (!this._xulWindow || !this._xulWindow.XULBrowserWindow)
+          return;
+
+        var tab = event.target.tab;
+        if (tab) {
+          var statusText = tab.linkedBrowser.currentURI.spec;
+          if (statusText == "about:blank") {
+            // XXXhack: Passing a space here (and not "")
+            // to make sure the the browser implementation would
+            // still consider it a hovered link.
+            statusText = " ";
+          }
+
+          this._xulWindow.XULBrowserWindow.setOverLink(statusText, null);
+        }
+      ]]></handler>
+
+      <handler event="DOMMenuItemInactive">
+      <![CDATA[
+        if (!this._xulWindow || !this._xulWindow.XULBrowserWindow)
+          return;
+
+        this._xulWindow.XULBrowserWindow.setOverLink("", null);
+      ]]></handler>
+
+    </handlers>
+  </binding>
+#endif
+
   <!-- close-tab-button binding
        This binding relies on the structure of the tabbrowser binding.
        Therefore it should only be used as a child of the tab or the tabs
        element (in both cases, when they are anonymous nodes of <tabbrowser>).
        This binding is exposed as a pseudo-public-API so themes can customize
        the tabbar appearance without having to be scriptable
        (see globalBindings.xml in Pinstripe for example).
   -->
@@ -3189,16 +3564,19 @@
              closetabtext="&closeTab.label;">
       <xul:image xbl:inherits="validate,src=image" class="tab-icon-image"/>
       <xul:label flex="1" xbl:inherits="value=label,crop,accesskey" class="tab-text"/>
       <xul:toolbarbutton anonid="close-button" tabindex="-1" class="tab-close-button"/>
     </content>
 
     <implementation>
       <field name="mOverCloseButton">false</field>
+#ifndef USE_TAB_PREVIEWS
+	  <field name="mCorrespondingMenuitem">null</field>
+#endif
     </implementation>
 
     <handlers>
       <handler event="mouseover">
         var anonid = event.originalTarget.getAttribute("anonid");
         if (anonid == "close-button")
           this.mOverCloseButton = true;
       </handler>
diff -r 8b3caddca8f5 browser/base/content/test/Makefile.in
--- a/browser/base/content/test/Makefile.in	Sat Nov 15 23:56:49 2008 -0800
+++ b/browser/base/content/test/Makefile.in	Sat Nov 22 15:25:48 2008 -0500
@@ -63,26 +63,27 @@ _BROWSER_FILES = browser_bug321000.js \
                  browser_bug427559.js \
                  browser_bug441778.js \
                  browser_discovery.js \
                  discovery.html \
                  moz.png \
                  browser_getshortcutoruri.js \
                  browser_page_style_menu.js \
                  page_style_sample.html \
-                 browser_ctrlTab.js \
                  browser_selectTabAtIndex.js \
                  browser_gestureSupport.js \
                  browser_feed_tab.js \
                  feed_tab.html \
                  browser_pluginnotification.js \
                  plugin_unknown.html \
                  plugin_test.html \
                  plugin_both.html \
                  plugin_both2.html \
+                 browser_alltabslistener.js \
+                 alltabslistener.html \
     $(NULL)
 
 ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
 _BROWSER_FILES += browser_customize.js \
     $(NULL)
 endif
 
 libs:: $(_TEST_FILES)
diff -r 8b3caddca8f5 browser/base/content/test/alltabslistener.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/base/content/test/alltabslistener.html	Sat Nov 22 15:25:48 2008 -0500
@@ -0,0 +1,8 @@
+<html>
+<head>
+<title>Test page for bug 463387</title>
+</head>
+<body>
+<p>Test page for bug 463387</p>
+</body>
+</html>
diff -r 8b3caddca8f5 browser/base/content/test/browser_alltabslistener.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/base/content/test/browser_alltabslistener.js	Sat Nov 22 15:25:48 2008 -0500
@@ -0,0 +1,196 @@
+const Ci = Components.interfaces;
+
+const gCompleteState = Ci.nsIWebProgressListener.STATE_STOP +
+                       Ci.nsIWebProgressListener.STATE_IS_NETWORK;
+
+var gFrontProgressListener = {
+  onProgressChange: function (aWebProgress, aRequest,
+                              aCurSelfProgress, aMaxSelfProgress,
+                              aCurTotalProgress, aMaxTotalProgress) {
+  },
+
+  onStateChange: function (aWebProgress, aRequest, aStateFlags, aStatus) {
+    var state = "onStateChange";
+    ok(gFrontNotificationsPos < gFrontNotifications.length, "Got an expected notification for the front notifications listener");
+    is(state, gFrontNotifications[gFrontNotificationsPos], "Got a notification for the front notifications listener");
+    gFrontNotificationsPos++;
+  },
+
+  onLocationChange: function (aWebProgress, aRequest, aLocationURI) {
+    var state = "onLocationChange";
+    ok(gFrontNotificationsPos < gFrontNotifications.length, "Got an expected notification for the front notifications listener");
+    is(state, gFrontNotifications[gFrontNotificationsPos], "Got a notification for the front notifications listener");
+    gFrontNotificationsPos++;
+  },
+  
+  onStatusChange: function (aWebProgress, aRequest, aStatus, aMessage) {
+  },
+
+  onSecurityChange: function (aWebProgress, aRequest, aState) {
+    var state = "onSecurityChange";
+    ok(gFrontNotificationsPos < gFrontNotifications.length, "Got an expected notification for the front notifications listener");
+    is(state, gFrontNotifications[gFrontNotificationsPos], "Got a notification for the front notifications listener");
+    gFrontNotificationsPos++;
+  }
+}
+
+var gAllProgressListener = {
+  onProgressChange: function (aBrowser, aWebProgress, aRequest,
+                              aCurSelfProgress, aMaxSelfProgress,
+                              aCurTotalProgress, aMaxTotalProgress) {
+  },
+
+  onStateChange: function (aBrowser, aWebProgress, aRequest, aStateFlags, aStatus) {
+    var state = "onStateChange";
+    ok(aBrowser == gTestBrowser, state + " notification came from the correct browser");
+    ok(gAllNotificationsPos < gAllNotifications.length, "Got an expected notification for the all notifications listener");
+    is(state, gAllNotifications[gAllNotificationsPos], "Got a notification for the all notifications listener");
+    gAllNotificationsPos++;
+
+    if ((aStateFlags & gCompleteState) == gCompleteState) {
+      ok(gAllNotificationsPos == gAllNotifications.length, "Saw the expected number of notifications");
+      ok(gFrontNotificationsPos == gFrontNotifications.length, "Saw the expected number of frontnotifications");
+      executeSoon(gNextTest);
+    }
+  },
+
+  onLocationChange: function (aBrowser, aWebProgress, aRequest, aLocationURI) {
+    var state = "onLocationChange";
+    ok(aBrowser == gTestBrowser, state + " notification came from the correct browser");
+    ok(gAllNotificationsPos < gAllNotifications.length, "Got an expected notification for the all notifications listener");
+    is(state, gAllNotifications[gAllNotificationsPos], "Got a notification for the all notifications listener");
+    gAllNotificationsPos++;
+  },
+  
+  onStatusChange: function (aBrowser, aWebProgress, aRequest, aStatus, aMessage) {
+    var state = "onStatusChange";
+    ok(aBrowser == gTestBrowser, state + " notification came from the correct browser");
+  },
+
+  onSecurityChange: function (aBrowser, aWebProgress, aRequest, aState) {
+    var state = "onSecurityChange";
+    ok(aBrowser == gTestBrowser, state + " notification came from the correct browser");
+    ok(gAllNotificationsPos < gAllNotifications.length, "Got an expected notification for the all notifications listener");
+    is(state, gAllNotifications[gAllNotificationsPos], "Got a notification for the all notifications listener");
+    gAllNotificationsPos++;
+  }
+}
+
+var gFrontNotifications, gAllNotifications, gFrontNotificationsPos, gAllNotificationsPos;
+var gBackgroundTab, gForegroundTab, gBackgroundBrowser, gForegroundBrowser, gTestBrowser;
+var gTestPage = "/browser/browser/base/content/test/alltabslistener.html";
+var gNextTest;
+
+function test() {
+  waitForExplicitFinish();
+
+  gBackgroundTab = gBrowser.addTab("about:blank");
+  gForegroundTab = gBrowser.addTab("about:blank");
+  gBackgroundBrowser = gBrowser.getBrowserForTab(gBackgroundTab);
+  gForegroundBrowser = gBrowser.getBrowserForTab(gForegroundTab);
+  gBrowser.selectedTab = gForegroundTab;
+
+  // We must wait until the about:blank page has completed loading before
+  // starting tests or we get notifications from that
+  gForegroundBrowser.addEventListener("load", startTests, true);
+}
+
+function runTest(browser, url, next) {
+  gFrontNotificationsPos = 0;
+  gAllNotificationsPos = 0;
+  gNextTest = next;
+  gTestBrowser = browser;
+  browser.loadURI(url);
+}
+
+function startTests() {
+  gForegroundBrowser.removeEventListener("load", startTests, true);
+  executeSoon(startTest1);
+}
+
+function startTest1() {
+  gBrowser.addProgressListener(gFrontProgressListener);
+  gBrowser.addTabsProgressListener(gAllProgressListener);
+
+  gAllNotifications = [
+    "onStateChange",
+    "onLocationChange",
+    "onSecurityChange",
+    "onStateChange"
+  ];
+  gFrontNotifications = gAllNotifications;
+  runTest(gForegroundBrowser, "http://example.org" + gTestPage, startTest2);
+}
+
+function startTest2() {
+  gAllNotifications = [
+    "onStateChange",
+    "onLocationChange",
+    "onSecurityChange",
+    "onSecurityChange",
+    "onStateChange"
+  ];
+  gFrontNotifications = gAllNotifications;
+  runTest(gForegroundBrowser, "https://example.com" + gTestPage, startTest3);
+}
+
+function startTest3() {
+  gAllNotifications = [
+    "onStateChange",
+    "onLocationChange",
+    "onSecurityChange",
+    "onStateChange"
+  ];
+  gFrontNotifications = [];
+  runTest(gBackgroundBrowser, "http://example.org" + gTestPage, startTest4);
+}
+
+function startTest4() {
+  gAllNotifications = [
+    "onStateChange",
+    "onLocationChange",
+    "onSecurityChange",
+    "onSecurityChange",
+    "onStateChange"
+  ];
+  gFrontNotifications = [];
+  runTest(gBackgroundBrowser, "https://example.com" + gTestPage, startTest5);
+}
+
+function startTest5() {
+  // Switch the foreground browser
+  [gForegroundBrowser, gBackgroundBrowser] = [gBackgroundBrowser, gForegroundBrowser];
+  [gForegroundTab, gBackgroundTab] = [gBackgroundTab, gForegroundTab];
+  // Avoid the onLocationChange this will fire
+  gBrowser.removeProgressListener(gFrontProgressListener);
+  gBrowser.selectedTab = gForegroundTab;
+  gBrowser.addProgressListener(gFrontProgressListener);
+
+  gAllNotifications = [
+    "onStateChange",
+    "onLocationChange",
+    "onSecurityChange",
+    "onStateChange"
+  ];
+  gFrontNotifications = gAllNotifications;
+  runTest(gForegroundBrowser, "http://example.org" + gTestPage, startTest6);
+}
+
+function startTest6() {
+  gAllNotifications = [
+    "onStateChange",
+    "onLocationChange",
+    "onSecurityChange",
+    "onStateChange"
+  ];
+  gFrontNotifications = [];
+  runTest(gBackgroundBrowser, "http://example.org" + gTestPage, finishTest);
+}
+
+function finishTest() {
+  gBrowser.removeProgressListener(gFrontProgressListener);
+  gBrowser.removeTabsProgressListener(gAllProgressListener);
+  gBrowser.removeTab(gBackgroundTab);
+  gBrowser.removeTab(gForegroundTab);
+  finish();
+}
diff -r 8b3caddca8f5 browser/base/content/test/browser_sanitize-timespans.js
--- a/browser/base/content/test/browser_sanitize-timespans.js	Sat Nov 15 23:56:49 2008 -0800
+++ b/browser/base/content/test/browser_sanitize-timespans.js	Sat Nov 22 15:25:48 2008 -0500
@@ -1,39 +1,41 @@
 // Bug 453440 - Test the timespan-based logic of the sanitizer code
 var now_uSec = Date.now() * 1000;
 
 const dm = Cc["@mozilla.org/download-manager;1"].getService(Ci.nsIDownloadManager);
 const bhist = Cc["@mozilla.org/browser/global-history;2"].getService(Ci.nsIBrowserHistory);
 const iosvc = Cc["@mozilla.org/network/io-service;1"].getService(Ci.nsIIOService);
+const formhist = Cc["@mozilla.org/satchel/form-history;1"].getService(Ci.nsIFormHistory2);
 
 Cc["@mozilla.org/moz/jssubscript-loader;1"].getService(Components.interfaces.mozIJSSubScriptLoader)
                                            .loadSubScript("chrome://browser/content/sanitize.js");
 
 function test() {
   
   var hoursSinceMidnight = new Date().getHours();
 
   setupHistory();
+  setupFormHistory();
   setupDownloads();
   
   // Should test cookies here, but nsICookieManager/nsICookieService
   // doesn't let us fake creation times.  bug 463127
   
   let s = new Sanitizer();
   s.ignoreTimespan = false;
   s.prefDomain = "privacy.cpd.";
   var itemPrefs = Cc["@mozilla.org/preferences-service;1"]
                   .getService(Components.interfaces.nsIPrefService)
                   .getBranch(s.prefDomain);
   itemPrefs.setBoolPref("history", true);
   itemPrefs.setBoolPref("downloads", true);
   itemPrefs.setBoolPref("cache", false);
   itemPrefs.setBoolPref("cookies", false);
-  itemPrefs.setBoolPref("formdata", false);
+  itemPrefs.setBoolPref("formdata", true);
   itemPrefs.setBoolPref("offlineApps", false);
   itemPrefs.setBoolPref("passwords", false);
   itemPrefs.setBoolPref("sessions", false);
   itemPrefs.setBoolPref("siteprefs", false);
   
   // Clear 1 hour
   Sanitizer.prefs.setIntPref("timeSpan", 1);
   s.sanitize();
@@ -41,16 +43,23 @@ function test() {
   ok(!bhist.isVisited(uri("http://1hour.com")), "1hour.com should now be deleted");
   ok(bhist.isVisited(uri("http://2hour.com")), "Pretend visit to 2hour.com should still exist");
   ok(bhist.isVisited(uri("http://4hour.com")), "Pretend visit to 4hour.com should still exist");
   
   if(hoursSinceMidnight > 1)
     ok(bhist.isVisited(uri("http://today.com")), "Pretend visit to today.com should still exist");
   ok(bhist.isVisited(uri("http://before-today.com")), "Pretend visit to before-today.com should still exist");
   
+  ok(!formhist.nameExists("1hour"), "1hour form entry should be deleted");
+  ok(formhist.nameExists("2hour"), "2hour form entry should still exist");
+  ok(formhist.nameExists("4hour"), "4hour form entry should still exist");
+  if(hoursSinceMidnight > 1)
+    ok(formhist.nameExists("today"), "today form entry should still exist");
+  ok(formhist.nameExists("b4today"), "b4today form entry should still exist");
+
   ok(!downloadExists(5555551), "<1 hour download should now be deleted");
   ok(downloadExists(5555550), "Year old download should still be present");
   ok(downloadExists(5555552), "<2 hour old download should still be present");
   ok(downloadExists(5555553), "<4 hour old download should still be present");
 
   if(hoursSinceMidnight > 1)
     ok(downloadExists(5555554), "'Today' download should still be present");
   
@@ -59,51 +68,68 @@ function test() {
   s.sanitize();
   
   ok(!bhist.isVisited(uri("http://2hour.com")), "Pretend visit to 2hour.com should now be deleted");
   ok(bhist.isVisited(uri("http://4hour.com")), "Pretend visit to 4hour.com should still exist");
   if(hoursSinceMidnight > 2)
     ok(bhist.isVisited(uri("http://today.com")), "Pretend visit to today.com should still exist");
   ok(bhist.isVisited(uri("http://before-today.com")), "Pretend visit to before-today.com should still exist");
   
+  ok(!formhist.nameExists("2hour"), "2hour form entry should be deleted");
+  ok(formhist.nameExists("4hour"), "4hour form entry should still exist");
+  if(hoursSinceMidnight > 2)
+    ok(formhist.nameExists("today"), "today form entry should still exist");
+  ok(formhist.nameExists("b4today"), "b4today form entry should still exist");
+
+  ok(formhist.nameExists("b4today"), "b4today form entry should still exist");
   ok(!downloadExists(5555552), "<2 hour old download should now be deleted");
   ok(downloadExists(5555550), "Year old download should still be present");
   ok(downloadExists(5555553), "<4 hour old download should still be present");
   if(hoursSinceMidnight > 2)
     ok(downloadExists(5555554), "'Today' download should still be present");
   
   // Clear 4 hours
   Sanitizer.prefs.setIntPref("timeSpan", 3);
   s.sanitize();
   
   ok(!bhist.isVisited(uri("http://4hour.com")), "Pretend visit to 4hour.com should now be deleted");
   if(hoursSinceMidnight > 4)
     ok(bhist.isVisited(uri("http://today.com")), "Pretend visit to today.com should still exist");
   ok(bhist.isVisited(uri("http://before-today.com")), "Pretend visit to before-today.com should still exist");
   
+  ok(!formhist.nameExists("4hour"), "4hour form entry should be deleted");
+  if(hoursSinceMidnight > 4)
+    ok(formhist.nameExists("today"), "today form entry should still exist");
+  ok(formhist.nameExists("b4today"), "b4today form entry should still exist");
+
   ok(!downloadExists(5555553), "<4 hour old download should now be deleted");
   ok(downloadExists(5555550), "Year old download should still be present");
   if(hoursSinceMidnight > 4)
     ok(downloadExists(5555554), "'Today' download should still be present");
 
   // Clear Today
   Sanitizer.prefs.setIntPref("timeSpan", 4);
   s.sanitize();
   
   ok(!bhist.isVisited(uri("http://today.com")), "Pretend visit to today.com should now be deleted");
   ok(bhist.isVisited(uri("http://before-today.com")), "Pretend visit to before-today.com should still exist");
 
+  ok(!formhist.nameExists("today"), "today form entry should be deleted");
+  ok(formhist.nameExists("b4today"), "b4today form entry should still exist");
+
   ok(!downloadExists(5555554), "'Today' download should now be deleted");
   ok(downloadExists(5555550), "Year old download should still be present");
 
   // Choose everything
   Sanitizer.prefs.setIntPref("timeSpan", 0);
   s.sanitize();
   
   ok(!bhist.isVisited(uri("http://before-today.com")), "Pretend visit to before-today.com should now be deleted");
+
+  ok(!formhist.nameExists("b4today"), "b4today form entry should be deleted");
   
   ok(!downloadExists(5555550), "Year old download should now be deleted");
 
 }
 
 function setupHistory() {
   bhist.addPageWithDetails(uri("http://1hour.com/"), "Less than 1 hour ago", now_uSec - 45*60*1000000);
   bhist.addPageWithDetails(uri("http://2hour.com/"), "Less than 2 hours ago", now_uSec - 90*60*1000000);
@@ -111,25 +137,70 @@ function setupHistory() {
   
   let today = new Date();
   today.setHours(0);
   today.setMinutes(0);
   today.setSeconds(30);
   bhist.addPageWithDetails(uri("http://today.com/"), "Today", today.valueOf() * 1000);
   
   let lastYear = new Date();
-  lastYear.setFullYear(lastYear.year - 1);
+  lastYear.setFullYear(lastYear.getFullYear() - 1);
   bhist.addPageWithDetails(uri("http://before-today.com/"), "Before Today", lastYear.valueOf() * 1000);
   
   // Confirm everything worked
   ok(bhist.isVisited(uri("http://1hour.com")), "Pretend visit to 1hour.com should exist");
   ok(bhist.isVisited(uri("http://2hour.com")), "Pretend visit to 2hour.com should exist");
   ok(bhist.isVisited(uri("http://4hour.com")), "Pretend visit to 4hour.com should exist");
   ok(bhist.isVisited(uri("http://today.com")), "Pretend visit to today.com should exist");
   ok(bhist.isVisited(uri("http://before-today.com")), "Pretend visit to before-today.com should exist");
+}
+
+function setupFormHistory() {
+  // Make sure we've got a clean DB to start with.
+  formhist.removeAllEntries();
+
+  // Add the entries we'll be testing.
+  formhist.addEntry("1hour", "1h");
+  formhist.addEntry("2hour", "2h");
+  formhist.addEntry("4hour", "4h");
+  formhist.addEntry("today", "1d");
+  formhist.addEntry("b4today", "1y");
+
+  // Artifically age the entries to the proper vintage.
+  let db = formhist.DBConnection;
+  let timestamp = now_uSec - 45*60*1000000;
+  db.executeSimpleSQL("UPDATE moz_formhistory SET firstUsed = " +
+                      timestamp +  " WHERE fieldname = '1hour'");
+  timestamp = now_uSec - 90*60*1000000;
+  db.executeSimpleSQL("UPDATE moz_formhistory SET firstUsed = " +
+                      timestamp +  " WHERE fieldname = '2hour'");
+  timestamp = now_uSec - 180*60*1000000;
+  db.executeSimpleSQL("UPDATE moz_formhistory SET firstUsed = " +
+                      timestamp +  " WHERE fieldname = '4hour'");
+
+  let today = new Date();
+  today.setHours(0);
+  today.setMinutes(0);
+  today.setSeconds(1);
+  timestamp = today.valueOf() * 1000;
+  db.executeSimpleSQL("UPDATE moz_formhistory SET firstUsed = " +
+                      timestamp +  " WHERE fieldname = 'today'");
+
+  let lastYear = new Date();
+  lastYear.setFullYear(lastYear.getFullYear() - 1);
+  timestamp = lastYear.valueOf() * 1000;
+  db.executeSimpleSQL("UPDATE moz_formhistory SET firstUsed = " +
+                      timestamp +  " WHERE fieldname = 'b4today'");
+
+  // Sanity check.
+  ok(formhist.nameExists("1hour"), "Checking for 1hour form history entry creation");
+  ok(formhist.nameExists("2hour"), "Checking for 2hour form history entry creation");
+  ok(formhist.nameExists("4hour"), "Checking for 4hour form history entry creation");
+  ok(formhist.nameExists("today"), "Checking for today form history entry creation");
+  ok(formhist.nameExists("b4today"), "Checking for b4today form history entry creation");
 }
 
 function setupDownloads() {
 
   // Add within-1-hour download to DB
   let data = {
     id:   "5555551",
     name: "fakefile-1-hour",
@@ -221,17 +292,17 @@ function setupDownloads() {
     stmt.execute();
   }
   finally {
     stmt.reset();
   }
   
   // Add "before today" download
   let lastYear = new Date();
-  lastYear.setFullYear(lastYear.year - 1);
+  lastYear.setFullYear(lastYear.getFullYear() - 1);
   data = {
     id:   "5555550",
     name: "fakefile-old",
     source: "https://bugzilla.mozilla.org/show_bug.cgi?id=453440",
     target: "fakefile-old",
     startTime: lastYear.valueOf() * 1000,  // 1 year ago, in uSec
     endTime: (lastYear.valueOf() + 1000) * 1000, // 1 second later
     state: Ci.nsIDownloadManager.DOWNLOAD_FINISHED,
diff -r 8b3caddca8f5 browser/components/nsBrowserGlue.js
--- a/browser/components/nsBrowserGlue.js	Sat Nov 15 23:56:49 2008 -0800
+++ b/browser/components/nsBrowserGlue.js	Sat Nov 22 15:25:48 2008 -0500
@@ -428,17 +428,18 @@ BrowserGlue.prototype = {
                       }
                     }
                   ];
 
     // Set pref to indicate we've shown the notification.
     var currentVersion = this._prefs.getIntPref("browser.rights.version");
     this._prefs.setBoolPref("browser.rights." + currentVersion + ".shown", true);
 
-    notifyBox.appendNotification(notifyText, "about-rights", null, notifyBox.PRIORITY_INFO_LOW, buttons);
+    var box = notifyBox.appendNotification(notifyText, "about-rights", null, notifyBox.PRIORITY_INFO_LOW, buttons);
+    box.persistence = 3; // arbitrary number, just so bar sticks around for a bit
   },
 
   // returns the (cached) Sanitizer constructor
   get Sanitizer() 
   {
     if(typeof(Sanitizer) != "function") { // we should dynamically load the script
       Cc["@mozilla.org/moz/jssubscript-loader;1"].
       getService(Ci.mozIJSSubScriptLoader).
@@ -534,37 +535,42 @@ BrowserGlue.prototype = {
     else {
       // Create a new Organizer left pane folder root, the old will not be
       // valid anymore.
       this._prefs.setIntPref("browser.places.leftPaneFolderId", -1);
 
       // ensurePlacesDefaultQueriesInitialized() is called by import.
       this._prefs.setIntPref("browser.places.smartBookmarksVersion", 0);
 
-      // Get bookmarks folder
+      // Get bookmarks.html file location
       var dirService = Cc["@mozilla.org/file/directory_service;1"].
                        getService(Ci.nsIProperties);
-      var bookmarksFile = dirService.get("BMarks", Ci.nsILocalFile);
 
-      // User wants to restore default bookmarks
-      if (restoreDefaultBookmarks || !bookmarksFile.exists()) {
-        // get bookmarks.html file from default profile folder
-        bookmarksFile = dirService.get("profDef", Ci.nsILocalFile);
-        bookmarksFile.append("bookmarks.html");
+      var bookmarksFile = null;
+      if (restoreDefaultBookmarks) {
+        // User wants to restore bookmarks.html file from default profile folder
+        bookmarksFile = dirService.get("profDef", Ci.nsILocalFile)
+                                      .append("bookmarks.html");
       }
+      else
+        bookmarksFile = dirService.get("BMarks", Ci.nsILocalFile);
 
-      // import the file
-      try {
-        var importer = Cc["@mozilla.org/browser/places/import-export-service;1"].
-                       getService(Ci.nsIPlacesImportExportService);
-        importer.importHTMLFromFile(bookmarksFile, true /* overwrite existing */);
-      } catch (err) {
-        // Report the error, but ignore it.
-        Cu.reportError(err);
+      if (bookmarksFile.exists()) {
+        // import the file
+        try {
+          var importer = Cc["@mozilla.org/browser/places/import-export-service;1"].
+                         getService(Ci.nsIPlacesImportExportService);
+          importer.importHTMLFromFile(bookmarksFile, true /* overwrite existing */);
+        } catch (err) {
+          // Report the error, but ignore it.
+          Cu.reportError("Bookmarks.html file could be corrupt. " + err);
+        }
       }
+      else
+        Cu.reportError("Unable to find bookmarks.html file.");
 
       // Reset preferences, so we won't try to import again at next run
       if (importBookmarksHTML)
         this._prefs.setBoolPref("browser.places.importBookmarksHTML", false);
       if (restoreDefaultBookmarks)
         this._prefs.setBoolPref("browser.bookmarks.restore_default_bookmarks",
                                 false);
     }
diff -r 8b3caddca8f5 browser/components/places/content/menu.xml
--- a/browser/components/places/content/menu.xml	Sat Nov 15 23:56:49 2008 -0800
+++ b/browser/components/places/content/menu.xml	Sat Nov 22 15:25:48 2008 -0500
@@ -149,16 +149,17 @@
           }
           else if (scrollDir == 1)
             newMarginTop = sbo.height;
 
           // set the new marginTop based on arrowscrollbox
           newMarginTop += sbo.y - this._scrollBox.boxObject.y;
           this._indicatorBar.firstChild.style.marginTop = newMarginTop + "px";
           this._indicatorBar.hidden = false;
+          aEvent.stopPropagation();
         ]]></body>
       </method>
 
       <method name="onDragExit">
         <parameter name="aEvent"/>
         <parameter name="aDragSession"/>
         <body><![CDATA[
           PlacesControllerDragHelper.currentDropTarget = null;
@@ -207,32 +208,34 @@
           // activate the view and cache the dragged node
           this._rootView._draggedNode = draggedNode;
           this._rootView.focus();
 
           // Fill the dataTransfer
           this._rootView._controller.setDataTransfer(aEvent);
 
           this.setAttribute("dragstart", "true");
+          aEvent.stopPropagation();
         ]]></body>
       </method>
 
       <method name="onDrop">
         <parameter name="aEvent"/>
         <parameter name="aDropData"/>
         <parameter name="aSession"/>
         <body><![CDATA[
           // Cache the dataTransfer
           PlacesControllerDragHelper.currentDataTransfer = aEvent.dataTransfer;
 
           var dropPoint = this._getDropPoint(aEvent);
           if (!dropPoint)
             return;
 
           PlacesControllerDragHelper.onDrop(dropPoint.ip);
+          aEvent.stopPropagation();
         ]]></body>
       </method>
 
       <!-- This returns the FavourSet accepted by this popup -->
       <method name="getSupportedFlavours">
         <body><![CDATA[
           return PlacesControllerDragHelper.flavourSet;
         ]]></body>
@@ -516,17 +519,17 @@
         var node = event.target;
         if (node.parentNode != this)
           return;
 
         if (window.XULBrowserWindow)
           window.XULBrowserWindow.setOverLink("", null);
       ]]></handler>
       <handler event="draggesture" action="if (event.target.node) nsDragAndDrop.startDrag(event, this);"/>
-      <handler event="dragdrop" action="nsDragAndDrop.drop(event, this);"/>
+      <handler event="drop" action="nsDragAndDrop.drop(event, this);"/>
       <handler event="dragover" action="nsDragAndDrop.dragOver(event, this);"/>
       <handler event="dragexit" action="nsDragAndDrop.dragExit(event, this);"/>
     </handlers>
   </binding>
 
 
   <binding id="places-menupopup"
            extends="chrome://browser/content/places/menu.xml#places-popup-base">
diff -r 8b3caddca8f5 browser/components/places/content/toolbar.xml
--- a/browser/components/places/content/toolbar.xml	Sat Nov 15 23:56:49 2008 -0800
+++ b/browser/components/places/content/toolbar.xml	Sat Nov 22 15:25:48 2008 -0500
@@ -1017,39 +1017,40 @@
           draggedDOMNode.firstChild.hidePopup();
         }
 
         // activate the view and cache the dragged node
         this._draggedNode = draggedDOMNode.node;
         this.focus();
 
         this._controller.setDataTransfer(event);
+        event.stopPropagation();
       ]]></handler>
 
       <handler event="dragover"><![CDATA[
         // Cache the dataTransfer
         var dt = PlacesControllerDragHelper.currentDataTransfer =
                  event.dataTransfer;
 
+        var ib = this._dropIndicatorBar;
         var ip = this.insertionPoint;
         if (!ip || !PlacesControllerDragHelper.canDrop(ip)) {
           ib.removeAttribute("dragging");
           PlacesControllerDragHelper.currentDataTransfer = null;
           return;
         }
 
         PlacesControllerDragHelper.currentDropTarget = event.target;
         var dropPoint = this._getDropPoint(event);
 
         if (this._ibTimer) {
           this._ibTimer.cancel();
           this._ibTimer = null;
         }
 
-        var ib = this._dropIndicatorBar;
         if (dropPoint.folderNode ||
             event.originalTarget == this._chevron) {
           // Dropping over a menubutton or chevron button
           // set styles and timer to open relative menupopup
           var overNode = dropPoint.folderNode || this._chevron;
           if (this._overFolder.node != overNode) {
             this._clearOverFolder();
             this._overFolder.node = overNode;
@@ -1096,45 +1097,52 @@
             }
           }
           // Clear out old folder information
           this._clearOverFolder();
         }
 
         dt.effectAllowed = "all";
         event.preventDefault();
+        event.stopPropagation();
       ]]></handler>
 
       <handler event="drop"><![CDATA[
-        // If the data-transfer isn't cached, it's not ours
-        // This happens when dropping tabs
-        if (event.dataTransfer != PlacesControllerDragHelper.currentDataTransfer)
+        PlacesControllerDragHelper.currentDataTransfer = event.dataTransfer;
+        PlacesControllerDragHelper.currentDropTarget = event.target;
+
+        var ip = this.insertionPoint;
+        if (!ip || !PlacesControllerDragHelper.canDrop(ip))
           return;
 
         var dropPoint = this._getDropPoint(event);
         if (!dropPoint)
           return;
+
         PlacesControllerDragHelper.onDrop(dropPoint.ip);
+        event.stopPropagation();
       ]]></handler>
 
       <handler event="dragleave"><![CDATA[
         PlacesControllerDragHelper.currentDropTarget = null;
         PlacesControllerDragHelper.currentDataTransfer = null;
 
         // Set timer to turn off indicator bar (if we turn it off
         // here, dragenter might be called immediately after, creating
         // flicker.)
         if (this._ibTimer)
           this._ibTimer.cancel();
         this._ibTimer = this._setTimer(10);
 
-        // Close any folder being hovered over
+        // If we hovered over a folder, close it now
         if (this._overFolder.node)
             this._overFolder.closeTimer = this._setTimer(this._overFolder.hoverTime);
+      ]]></handler>
 
+      <handler event="dragend"><![CDATA[
         this._draggedNode = null;
       ]]></handler>
 
       <handler event="popupshowing" phase="capturing"><![CDATA[
       // Don't show the popup if we are dragging a container.
       if (this._draggingContainer) {
           this._draggingContainer = false;
 #ifdef MOZ_WIDGET_GTK2
diff -r 8b3caddca8f5 browser/components/sessionstore/src/nsSessionStore.js
--- a/browser/components/sessionstore/src/nsSessionStore.js	Sat Nov 15 23:56:49 2008 -0800
+++ b/browser/components/sessionstore/src/nsSessionStore.js	Sat Nov 22 15:25:48 2008 -0500
@@ -1948,36 +1948,44 @@ SessionStoreService.prototype = {
    * Restore properties to a loaded document
    */
   restoreDocument_proxy: function sss_restoreDocument_proxy(aEvent) {
     // wait for the top frame to be loaded completely
     if (!aEvent || !aEvent.originalTarget || !aEvent.originalTarget.defaultView || aEvent.originalTarget.defaultView != aEvent.originalTarget.defaultView.top) {
       return;
     }
     
+    // always call this before injecting content into a document!
+    function hasExpectedURL(aDocument, aURL)
+      !aURL || aURL.replace(/#.*/, "") == aDocument.location.href.replace(/#.*/, "");
+    
     // restore text data saved by Firefox 2.0/3.0
     var textArray = this.__SS_restore_text ? this.__SS_restore_text.split(" ") : [];
-    function restoreTextData(aContent, aPrefix) {
+    function restoreTextData(aContent, aPrefix, aURL) {
       textArray.forEach(function(aEntry) {
-        if (/^((?:\d+\|)*)(#?)([^\s=]+)=(.*)$/.test(aEntry) && RegExp.$1 == aPrefix) {
+        if (/^((?:\d+\|)*)(#?)([^\s=]+)=(.*)$/.test(aEntry) &&
+            RegExp.$1 == aPrefix && hasExpectedURL(aContent.document, aURL)) {
           var document = aContent.document;
           var node = RegExp.$2 ? document.getElementById(RegExp.$3) : document.getElementsByName(RegExp.$3)[0] || null;
           if (node && "value" in node) {
             node.value = decodeURI(RegExp.$4);
             
             var event = document.createEvent("UIEvents");
             event.initUIEvent("input", true, true, aContent, 0);
             node.dispatchEvent(event);
           }
         }
       });
     }
     
-    function restoreFormData(aDocument, aData) {
+    function restoreFormData(aDocument, aData, aURL) {
       for (let key in aData) {
+        if (!hasExpectedURL(aDocument, aURL))
+          return;
+        
         let node = key.charAt(0) == "#" ? aDocument.getElementById(key.slice(1)) :
                                           XPathHelper.resolve(aDocument, key);
         if (!node)
           continue;
         
         let value = aData[key];
         if (typeof value == "string") {
           node.value = value;
@@ -1997,46 +2005,47 @@ SessionStoreService.prototype = {
             aOpt.selected = value.indexOf(aIx) > -1;
           });
         }
         // NB: dispatching "change" events might have unintended side-effects
       }
     }
     
     let selectedPageStyle = this.__SS_restore_pageStyle;
+    let window = this.ownerDocument.defaultView;
     function restoreTextDataAndScrolling(aContent, aData, aPrefix) {
       if (aData.formdata)
-        restoreFormData(aContent.document, aData.formdata);
+        restoreFormData(aContent.document, aData.formdata, aData.url);
       else
-        restoreTextData(aContent, aPrefix);
+        restoreTextData(aContent, aPrefix, aData.url);
       if (aData.innerHTML) {
-        aContent.setTimeout(
-              function(aHTML) {
-                if (aContent.document.designMode == "on") {
-                  aContent.document.body.innerHTML = aHTML;
-                }
-              }, 0, aData.innerHTML);
+        window.setTimeout(function() {
+          if (aContent.document.designMode == "on" &&
+              hasExpectedURL(aContent.document, aData.url)) {
+            aContent.document.body.innerHTML = aData.innerHTML;
+          }
+        }, 0);
       }
       if (aData.scroll && /(\d+),(\d+)/.test(aData.scroll)) {
         aContent.scrollTo(RegExp.$1, RegExp.$2);
       }
       Array.forEach(aContent.document.styleSheets, function(aSS) {
         aSS.disabled = aSS.title && aSS.title != selectedPageStyle;
       });
       for (var i = 0; i < aContent.frames.length; i++) {
-        if (aData.children && aData.children[i]) {
+        if (aData.children && aData.children[i] &&
+          hasExpectedURL(aContent.document, aData.url)) {
           restoreTextDataAndScrolling(aContent.frames[i], aData.children[i], aPrefix + i + "|");
         }
       }
     }
     
     // don't restore text data and scrolling state if the user has navigated
     // away before the loading completed (except for in-page navigation)
-    if (!this.__SS_restore_data.url || this.currentURI.spec.replace(/#.*/, "") ==
-                                       this.__SS_restore_data.url.replace(/#.*/, "")) {
+    if (hasExpectedURL(aEvent.originalTarget, this.__SS_restore_data.url)) {
       var content = aEvent.originalTarget.defaultView;
       if (this.currentURI.spec == "about:config") {
         // unwrap the document for about:config because otherwise the properties
         // of the XBL bindings - as the textbox - aren't accessible (see bug 350718)
         content = content.wrappedJSObject;
       }
       restoreTextDataAndScrolling(content, this.__SS_restore_data, "");
       this.markupDocumentViewer.authorStyleDisabled = selectedPageStyle == "_nostyle";
diff -r 8b3caddca8f5 browser/installer/removed-files.in
--- a/browser/installer/removed-files.in	Sat Nov 15 23:56:49 2008 -0800
+++ b/browser/installer/removed-files.in	Sat Nov 22 15:25:48 2008 -0500
@@ -579,16 +579,17 @@ res/fonts/pangoFontEncoding.properties
 res/fonts/pangoFontEncoding.properties
 res/fonts/fontNameMap.properties
 @DLL_PREFIX@xpcom_compat@DLL_SUFFIX@
 components/nsDictionary.js
 components/nsXmlRpcClient.js
 components/nsInterfaceInfoToIDL.js
 components/nsScriptableIO.js
 chrome/chromelist.txt
+modules/JSON.jsm
 #ifdef XP_MACOSX
 LICENSE
 extensions/inspector@mozilla.org/chrome/chromelist.txt
 components/accessibility.xpt
 components/crashreporter.xpt
 components/gksvgrenderer.xpt
 components/jsconsole.xpt
 components/necko_data.xpt
diff -r 8b3caddca8f5 browser/themes/gnomestripe/browser/browser.css
--- a/browser/themes/gnomestripe/browser/browser.css	Sat Nov 15 23:56:49 2008 -0800
+++ b/browser/themes/gnomestripe/browser/browser.css	Sat Nov 22 15:25:48 2008 -0500
@@ -1295,20 +1295,42 @@ tabpanels {
   margin: 0px;
 }
 
 .tabs-alltabs-box-animate {
   background-color: Highlight;
   opacity: 0.0;
 }
 
+%ifndef USE_TAB_PREVIEWS
+/* All tabs menupopup */
+.alltabs-item > .menu-iconic-left > .menu-iconic-icon {
+  list-style-image: url("chrome://global/skin/icons/folder-item.png");
+  -moz-image-region: rect(0px, 16px, 16px, 0px);
+}
+
+.alltabs-item[selected="true"] {
+  font-weight: bold;
+}
+
+.alltabs-item[busy] > .menu-iconic-left > .menu-iconic-icon {
+  list-style-image: url("chrome://global/skin/icons/loading_16.png");
+}
+
+.tabs-alltabs-button > .toolbarbutton-icon {
+  margin: 0px;
+}
+
+%else
+
 .tabs-alltabs-button > .toolbarbutton-icon {
   list-style-image: url("chrome://browser/skin/tabbrowser/alltabs.png");
   margin: 2px 0 2px;
 }
+%endif
 
 /* Sidebar */
 #sidebar-box .tabs-closebutton {
   margin-bottom: 0px !important;
   padding: 0px 2px 0px 2px !important;
 }
 
 #sidebar-throbber[loading="true"] {
diff -r 8b3caddca8f5 browser/themes/gnomestripe/browser/places/editBookmarkOverlay.css
--- a/browser/themes/gnomestripe/browser/places/editBookmarkOverlay.css	Sat Nov 15 23:56:49 2008 -0800
+++ b/browser/themes/gnomestripe/browser/places/editBookmarkOverlay.css	Sat Nov 22 15:25:48 2008 -0500
@@ -83,38 +83,34 @@
 
 /**** name picker ****/
 
 /* Make the microsummary picker look like a regular textbox instead of 
  * an editable menulist when no microsummaries are available.
  */
 #editBMPanel_namePicker[droppable="false"] {
   /* These rules come from the textbox element in textbox.css. */
-
-  /* Normal editable menulists set this to "none". */
-  -moz-appearance: textfield;
+  -moz-appearance: textfield; /* Normal editable menulists set this to "none". */
   cursor: text;
-
   border: 2px solid;
   -moz-border-top-colors: ThreeDShadow ThreeDDarkShadow;
   -moz-border-right-colors: ThreeDHighlight ThreeDLightShadow;
   -moz-border-bottom-colors: ThreeDHighlight ThreeDLightShadow;
   -moz-border-left-colors: ThreeDShadow ThreeDDarkShadow;
+  padding: 2px 2px 3px;
+  -moz-padding-start: 4px;
   background-color: -moz-Field;
   color: -moz-FieldText;
 }
 
 #editBMPanel_namePicker[droppable="false"] > .menulist-editable-box {
-  /* Normal editable menulists set this to "menulist-textfield". */
-  -moz-appearance: none;
-  padding: 2px 2px 3px 4px;
+  -moz-appearance: none; /* Normal editable menulists set this to "menulist-textfield". */
+  padding: 0;
 }
 
-
-/* Hide the drop marker and the popup. */
 #editBMPanel_namePicker[droppable="false"] > .menulist-dropmarker,
 #editBMPanel_namePicker[droppable="false"] > menupopup {
   display: none;
 }
 
 /* Hide the value column of the tag autocomplete popup
  * leaving only the comment column visible. This is
  * so that only the tag being edited is shown in the
diff -r 8b3caddca8f5 browser/themes/pinstripe/browser/browser.css
--- a/browser/themes/pinstripe/browser/browser.css	Sat Nov 15 23:56:49 2008 -0800
+++ b/browser/themes/pinstripe/browser/browser.css	Sat Nov 22 15:25:48 2008 -0500
@@ -1742,16 +1742,21 @@ tabbrowser > tabbox > tabpanels {
   -moz-image-region: rect(0px, 23px, 11px, 16px);
   background-color: transparent !important;
 }
 
 
 /**
  * New Tab & All Tabs Buttons
  */
+%ifndef USE_TAB_PREVIEWS
+.tabs-alltabs-box {
+  margin: 0;
+}
+%endif
 
 .tabs-newtab-button ,
 .tabs-alltabs-button {
   -moz-border-start: 2px solid;
   -moz-border-end: none;
   -moz-border-left-colors: rgba(0,0,0,0.25) rgba(255,255,255,0.15);
   -moz-border-right-colors: rgba(0,0,0,0.25) rgba(255,255,255,0.15);
   margin: 0;
@@ -1764,36 +1769,60 @@ tabbrowser > tabbox > tabpanels {
   padding-top: 2px;
   list-style-image: url(chrome://browser/skin/tabbrowser/alltabs-box-bkgnd-icon.png);
 }
 .tabs-newtab-button:hover ,
 .tabs-alltabs-button:hover {
   background-color: rgba(0,0,0,0.10);
 }
 .tabs-newtab-button:hover:active,
-.tabs-alltabs-button:hover:active {
+%ifndef USE_TAB_PREVIEWS
+.tabs-alltabs-button[open="true"],
+%endif
+.tabs-alltabs-button:hover:active{
   background-color: rgba(0,0,0,0.20);
 }
 
-.tabs-newtab-button > .toolbarbutton-text ,
+.tabs-newtab-button > .toolbarbutton-text,
+%ifndef USE_TAB_PREVIEWS
+.tabs-alltabs-button > .toolbarbutton-menu-dropmarker,
+%endif
 .tabs-alltabs-button > .toolbarbutton-text {
   display: none;
 }
 
 .tabs-alltabs-button > .toolbarbutton-icon {
   -moz-margin-end: 2px;
 }
 
 .tabs-alltabs-box-animate {
   margin: 1px 0px 0px 0px;
   width: 25px;
   background-image: url("chrome://browser/skin/tabbrowser/alltabs-box-overflow-bkgnd-animate.png");
   background-repeat: no-repeat;
   opacity: 0.0;
 }
+
+%ifndef USE_TAB_PREVIEWS
+/**
+ * All Tabs Menupopup 
+ */
+
+.alltabs-item > .menu-iconic-left > .menu-iconic-icon {
+  list-style-image: url("chrome://global/skin/tree/item.png");
+}
+
+.alltabs-item[selected="true"] {
+  font-weight: bold;
+}
+
+.alltabs-item[busy] > .menu-iconic-left > .menu-iconic-icon {
+  list-style-image: url("chrome://global/skin/icons/loading_16.png") !important;
+}
+%endif
 
 .tabs-closebutton {
   padding-right: 4px;
   list-style-image: url("chrome://global/skin/icons/closetab.png") !important;
   list-style-image: none;
   border: none;
   -moz-box-align: stretch;
 }
diff -r 8b3caddca8f5 browser/themes/winstripe/browser/browser.css
--- a/browser/themes/winstripe/browser/browser.css	Sat Nov 15 23:56:49 2008 -0800
+++ b/browser/themes/winstripe/browser/browser.css	Sat Nov 22 15:25:48 2008 -0500
@@ -1518,38 +1518,63 @@ tabpanels {
 
 .tabs-newtab-button > .toolbarbutton-icon {
   list-style-image: url(chrome://browser/skin/tabbrowser/newtab.png);
   margin: 3px 0 0;
   -moz-margin-end: 2px;
 }
 
 .tabs-newtab-button > .toolbarbutton-text,
-.tabs-alltabs-button > .toolbarbutton-text {
+%ifndef USE_TAB_PREVIEWS
+.tabs-alltabs-button > .toolbarbutton-icon,
+%endif
+.tabs-alltabs-button > .toolbarbutton-text  {
   display: none;
 }
 
+%ifdef USE_TAB_PREVIEWS
 .tabs-alltabs-button > .toolbarbutton-icon {
   list-style-image: url("chrome://browser/skin/tabbrowser/alltabs.png");
   margin: 6px 0 4px;
   -moz-image-region: auto;
 }
+%else
+.tabs-alltabs-button > .toolbarbutton-menu-dropmarker {
+  margin: 2px 1px 2px 0px;
+}
+%endif
 
 .tabs-alltabs-box-animate {
   margin-top: 2px;
   margin-bottom: 4px;
   width: 18px !important;
   background-image: url("chrome://browser/skin/tabbrowser/alltabs-box-overflow-end-bkgnd-animate.png");
   background-repeat: no-repeat;
   opacity: 0.0;
 }
 
 stack[chromedir="rtl"] > hbox > .tabs-alltabs-box-animate {
   background-image: url("chrome://browser/skin/tabbrowser/alltabs-box-overflow-start-bkgnd-animate.png");
 }
+
+%ifndef USE_TAB_PREVIEWS
+/* All tabs menupopup */
+.alltabs-item > .menu-iconic-left > .menu-iconic-icon {
+  list-style-image: url("chrome://global/skin/icons/folder-item.png");
+  -moz-image-region: rect(0px, 16px, 16px, 0px);
+}
+
+.alltabs-item[selected="true"] {
+  font-weight: bold;
+}
+
+.alltabs-item[busy] > .menu-iconic-left > .menu-iconic-icon {
+  list-style-image: url("chrome://global/skin/icons/loading_16.png");
+}
+%endif
 
 /* Tabstrip close button */
 .tabs-closebutton {
   -moz-appearance: none;
   list-style-image: url("chrome://global/skin/icons/close.png");
   -moz-image-region: rect(0px, 14px, 14px, 0px);
   padding: 4px 2px;
   margin: 0px;
diff -r 8b3caddca8f5 browser/themes/winstripe/browser/places/editBookmarkOverlay.css
--- a/browser/themes/winstripe/browser/places/editBookmarkOverlay.css	Sat Nov 15 23:56:49 2008 -0800
+++ b/browser/themes/winstripe/browser/places/editBookmarkOverlay.css	Sat Nov 22 15:25:48 2008 -0500
@@ -79,38 +79,32 @@
 
 /**** name picker ****/
 
 /* Make the microsummary picker look like a regular textbox instead of 
  * an editable menulist when no microsummaries are available.
  */
 #editBMPanel_namePicker[droppable="false"] {
   /* These rules come from the textbox element in textbox.css. */
-
-  /* Normal editable menulists set this to "none". */
-  -moz-appearance: textfield;
+  -moz-appearance: textfield; /* Normal editable menulists set this to "menulist". */
   cursor: text;
-
   border: 2px solid;
   -moz-border-top-colors: ThreeDShadow ThreeDDarkShadow;
   -moz-border-right-colors: ThreeDHighlight ThreeDLightShadow;
   -moz-border-bottom-colors: ThreeDHighlight ThreeDLightShadow;
   -moz-border-left-colors: ThreeDShadow ThreeDDarkShadow;
+  padding: 2px 2px 3px;
+  -moz-padding-start: 4px;
   background-color: -moz-Field;
   color: -moz-FieldText;
 }
 
 #editBMPanel_namePicker[droppable="false"] > .menulist-editable-box {
-  /* Normal editable menulists set this to "menulist-textfield". */
-  -moz-appearance: none;
-  padding: 2px 2px 3px 4px;
+  padding: 0;
 }
-
-
-/* Hide the drop marker and the popup. */
 
 #editBMPanel_namePicker[droppable="false"] > .menulist-dropmarker,
 #editBMPanel_namePicker[droppable="false"] > menupopup {
   display: none;
 }
 
 /* Hide the value column of the tag autocomplete popup
  * leaving only the comment column visible. This is
diff -r 8b3caddca8f5 build/Makefile.in
--- a/build/Makefile.in	Sat Nov 15 23:56:49 2008 -0800
+++ b/build/Makefile.in	Sat Nov 22 15:25:48 2008 -0500
@@ -104,16 +104,22 @@ endif
 endif
 
 ifeq ($(ENABLE_TESTS), 1)
 AUTOMATION_PPARGS += -DIS_TEST_BUILD=1
 else
 AUTOMATION_PPARGS += -DIS_TEST_BUILD=0
 endif
 
+ifeq ($(MOZ_DEBUG), 1)
+AUTOMATION_PPARGS += -DIS_DEBUG_BUILD=1
+else
+AUTOMATION_PPARGS += -DIS_DEBUG_BUILD=0
+endif
+
 _LEAKTEST_DIR = $(DEPTH)/_leaktest
 
 _LEAKTEST_FILES =    \
 		automation.py \
 		leaktest.py \
 		bloatcycle.html \
 		$(topsrcdir)/build/pgo/server-locations.txt \
 		$(NULL)
diff -r 8b3caddca8f5 build/pgo/Makefile.in
--- a/build/pgo/Makefile.in	Sat Nov 15 23:56:49 2008 -0800
+++ b/build/pgo/Makefile.in	Sat Nov 22 15:25:48 2008 -0500
@@ -109,16 +109,22 @@ endif
 endif
 
 ifeq ($(ENABLE_TESTS), 1)
 AUTOMATION_PPARGS += -DIS_TEST_BUILD=1
 else
 AUTOMATION_PPARGS += -DIS_TEST_BUILD=0
 endif
 
+ifeq ($(MOZ_DEBUG), 1)
+AUTOMATION_PPARGS += -DIS_DEBUG_BUILD=1
+else
+AUTOMATION_PPARGS += -DIS_DEBUG_BUILD=0
+endif
+
 automation.py: automation.py.in
 	$(PYTHON) $(topsrcdir)/config/Preprocessor.py \
 	$(AUTOMATION_PPARGS) $(DEFINES) $(ACDEFINES) $^ > $@
 
 genpgocert.py: genpgocert.py.in
 	$(PYTHON) $(topsrcdir)/config/Preprocessor.py \
 	$(AUTOMATION_PPARGS) $(DEFINES) $(ACDEFINES) $^ > $@
 
diff -r 8b3caddca8f5 build/pgo/automation.py.in
--- a/build/pgo/automation.py.in	Sat Nov 15 23:56:49 2008 -0800
+++ b/build/pgo/automation.py.in	Sat Nov 22 15:25:48 2008 -0500
@@ -79,16 +79,17 @@ IS_CYGWIN = False
 #expand IS_CAMINO = __IS_CAMINO__ != 0
 #expand BIN_SUFFIX = __BIN_SUFFIX__
 
 UNIXISH = not IS_WIN32 and not IS_MAC
 
 #expand DEFAULT_APP = "./" + __BROWSER_PATH__
 #expand CERTS_DIR = __CERTS_DIR__
 #expand IS_TEST_BUILD = __IS_TEST_BUILD__
+#expand IS_DEBUG_BUILD = __IS_DEBUG_BUILD__
 
 ###########
 # LOGGING #
 ###########
 
 # We use the logging system here primarily because it'll handle multiple
 # threads, which is needed to process the output of the server and application
 # processes simultaneously.
@@ -308,16 +309,23 @@ user_pref("layout.debug.enable_data_xbl"
 user_pref("layout.debug.enable_data_xbl", true);
 user_pref("browser.EULA.override", true);
 user_pref("javascript.options.jit.content", true);
 user_pref("gfx.color_management.force_srgb", true);
 
 user_pref("camino.warn_when_closing", false); // Camino-only, harmless to others
 """
   prefs.append(part)
+
+  # Increase the max script run time 10-fold for debug builds
+  if (IS_DEBUG_BUILD):
+    prefs.append("""\
+user_pref("dom.max_script_run_time", 100);
+user_pref("dom.max_chrome_script_run_time", 200);
+""")
 
   locations = readLocations()
 
   # Grant God-power to all the privileged servers on which tests run.
   privileged = filter(lambda loc: "privileged" in loc.options, locations)
   for (i, l) in itertools.izip(itertools.count(1), privileged):
     part = """
 user_pref("capability.principal.codebase.p%(i)d.granted",
diff -r 8b3caddca8f5 build/unix/run-mozilla.sh
--- a/build/unix/run-mozilla.sh	Sat Nov 15 23:56:49 2008 -0800
+++ b/build/unix/run-mozilla.sh	Sat Nov 22 15:25:48 2008 -0500
@@ -335,28 +335,28 @@ fi
 ##
 ## Set LD_LIBRARY_PATH
 ##
 ## On Solaris we use $ORIGIN (set in RUNPATH) instead of LD_LIBRARY_PATH 
 ## to locate shared libraries. 
 ##
 ## When a shared library is a symbolic link, $ORIGIN will be replaced with
 ## the real path (i.e., what the symbolic link points to) by the runtime
-## linker.  For example, if dist/bin/libmozjs.so is a symbolic link to
-## js/src/libmozjs.so, $ORIGIN will be "js/src" instead of "dist/bin".
-## So the runtime linker will use "js/src" NOT "dist/bin" to locate the
-## other shared libraries that libmozjs.so depends on.  This only happens
+## linker.  For example, if dist/bin/libgkgfx.so is a symbolic link to
+## gfx/src/libgkgfx.so, $ORIGIN will be "gfx/src" instead of "dist/bin".
+## So the runtime linker will use "gfx/src" NOT "dist/bin" to locate the
+## other shared libraries that libgkgfx.so depends on.  This only happens
 ## when a user (developer) tries to start firefox, thunderbird, or seamonkey
 ## under dist/bin. To solve the problem, we should rely on LD_LIBRARY_PATH
 ## to locate shared libraries.
 ##
 ## Note: 
-##  We choose libmozjs.so as a representative shared library. If it is 
+##  We choose libgkgfx.so as a representative shared library. If it is 
 ##  a symbolic link, all other shared libraries are symbolic links also.
-if [ `uname -s` != "SunOS" -o -h "$MOZ_DIST_BIN/libmozjs.so" ]
+if [ `uname -s` != "SunOS" -o -h "$MOZ_DIST_BIN/libgkgfx.so" ]
 then
 	LD_LIBRARY_PATH=${MOZ_DIST_BIN}:${MOZ_DIST_BIN}/plugins:${MRE_HOME}${LD_LIBRARY_PATH+":$LD_LIBRARY_PATH"}
 fi 
 
 if [ -n "$LD_LIBRARYN32_PATH" ]
 then
 	LD_LIBRARYN32_PATH=${MOZ_DIST_BIN}:${MOZ_DIST_BIN}/plugins:${MRE_HOME}${LD_LIBRARYN32_PATH+":$LD_LIBRARYN32_PATH"}
 fi
diff -r 8b3caddca8f5 configure.in
--- a/configure.in	Sat Nov 15 23:56:49 2008 -0800
+++ b/configure.in	Sat Nov 22 15:25:48 2008 -0500
@@ -5301,17 +5301,17 @@ if test -n "$MOZ_OGG"; then
     AC_DEFINE(MOZ_OGG)
     MOZ_SYDNEYAUDIO=1
     MOZ_MEDIA=1
 fi
 
 dnl ========================================================
 dnl = Disable Wave decoder support
 dnl ========================================================
-MOZ_ARG_ENABLE_BOOL(wave,
+MOZ_ARG_DISABLE_BOOL(wave,
 [  --disable-wave          Disable Wave decoder support],
     MOZ_WAVE=,
     MOZ_WAVE=1)
 
 AC_SUBST(MOZ_WAVE)
 
 if test -n "$MOZ_WAVE"; then
     AC_DEFINE(MOZ_WAVE)
diff -r 8b3caddca8f5 content/base/src/nsDocument.cpp
--- a/content/base/src/nsDocument.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/content/base/src/nsDocument.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -163,16 +163,17 @@ static NS_DEFINE_CID(kDOMEventGroupCID, 
 #include "nsIContentViewer.h"
 #include "nsIXMLContentSink.h"
 #include "nsIChannelEventSink.h"
 #include "nsContentErrors.h"
 #include "nsIXULDocument.h"
 #include "nsIProgressEventSink.h"
 #include "nsISecurityEventSink.h"
 #include "nsIPrompt.h"
+#include "nsIPropertyBag2.h"
 
 #include "nsFrameLoader.h"
 
 #include "mozAutoDocUpdate.h"
 
 
 #ifdef MOZ_LOGGING
 // so we can get logging even in release builds
@@ -1875,16 +1876,26 @@ nsDocument::Reset(nsIChannel* aChannel, 
     if (securityManager) {
       securityManager->GetChannelPrincipal(aChannel,
                                            getter_AddRefs(principal));
     }
   }
 
   ResetToURI(uri, aLoadGroup, principal);
 
+  nsCOMPtr<nsIPropertyBag2> bag = do_QueryInterface(aChannel);
+  if (bag) {
+    nsCOMPtr<nsIURI> baseURI;
+    bag->GetPropertyAsInterface(NS_LITERAL_STRING("baseURI"),
+                                NS_GET_IID(nsIURI), getter_AddRefs(baseURI));
+    if (baseURI) {
+      mDocumentBaseURI = baseURI;
+    }
+  }
+
   mChannel = aChannel;
 }
 
 void
 nsDocument::ResetToURI(nsIURI *aURI, nsILoadGroup *aLoadGroup,
                        nsIPrincipal* aPrincipal)
 {
   NS_PRECONDITION(aURI, "Null URI passed to ResetToURI");
diff -r 8b3caddca8f5 content/base/src/nsScriptLoader.cpp
--- a/content/base/src/nsScriptLoader.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/content/base/src/nsScriptLoader.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -191,41 +191,57 @@ IsScriptEventHandler(nsIScriptElement *a
 
     return PR_TRUE;
   }
 
   return PR_FALSE;
 }
 
 nsresult
+nsScriptLoader::CheckContentPolicy(nsScriptLoadRequest *aRequest,
+                                   nsISupports *aContext,
+                                   const nsAString &aType)
+{
+  PRInt16 shouldLoad = nsIContentPolicy::ACCEPT;
+  nsresult rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_SCRIPT,
+                                          aRequest->mURI,
+                                          mDocument->NodePrincipal(),
+                                          aContext,
+                                          NS_LossyConvertUTF16toASCII(aType),
+                                          nsnull,    //extra
+                                          &shouldLoad,
+                                          nsContentUtils::GetContentPolicy(),
+                                          nsContentUtils::GetSecurityManager());
+  if (NS_FAILED(rv) || NS_CP_REJECTED(shouldLoad)) {
+    if (NS_FAILED(rv) || shouldLoad != nsIContentPolicy::REJECT_TYPE) {
+      return NS_ERROR_CONTENT_BLOCKED;
+    }
+    return NS_ERROR_CONTENT_BLOCKED_SHOW_ALT;
+  }
+
+  return NS_OK;
+}
+
+nsresult
 nsScriptLoader::StartLoad(nsScriptLoadRequest *aRequest, const nsAString &aType)
 {
   // Check that the containing page is allowed to load this URI.
   nsresult rv = nsContentUtils::GetSecurityManager()->
     CheckLoadURIWithPrincipal(mDocument->NodePrincipal(), aRequest->mURI,
                               nsIScriptSecurityManager::ALLOW_CHROME);
 
   NS_ENSURE_SUCCESS(rv, rv);
 
   // After the security manager, the content-policy stuff gets a veto
-  PRInt16 shouldLoad = nsIContentPolicy::ACCEPT;
-  rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_SCRIPT,
-                                 aRequest->mURI,
-                                 mDocument->NodePrincipal(),
-                                 aRequest->mElement,
-                                 NS_LossyConvertUTF16toASCII(aType),
-                                 nsnull,    //extra
-                                 &shouldLoad,
-                                 nsContentUtils::GetContentPolicy(),
-                                 nsContentUtils::GetSecurityManager());
-  if (NS_FAILED(rv) || NS_CP_REJECTED(shouldLoad)) {
-    if (NS_FAILED(rv) || shouldLoad != nsIContentPolicy::REJECT_TYPE) {
-      return NS_ERROR_CONTENT_BLOCKED;
-    }
-    return NS_ERROR_CONTENT_BLOCKED_SHOW_ALT;
+  nsISupports *context = aRequest->mElement.get()
+                         ? static_cast<nsISupports *>(aRequest->mElement.get())
+                         : static_cast<nsISupports *>(mDocument);
+  rv = CheckContentPolicy(aRequest, context, aType);
+  if (NS_FAILED(rv)) {
+    return rv;
   }
 
   nsCOMPtr<nsILoadGroup> loadGroup = mDocument->GetDocumentLoadGroup();
   nsCOMPtr<nsIStreamLoader> loader;
 
   nsCOMPtr<nsPIDOMWindow> window(do_QueryInterface(mDocument->GetScriptGlobalObject()));
   nsIDocShell *docshell = window->GetDocShell();
 
@@ -457,16 +473,22 @@ nsScriptLoader::ProcessScriptElement(nsI
     nsTArray<PreloadInfo>::index_type i =
       mPreloads.IndexOf(scriptURI.get(), 0, PreloadURIComparator());
     if (i != nsTArray<PreloadInfo>::NoIndex) {
       request = mPreloads[i].mRequest;
       request->mElement = aElement;
       request->mJSVersion = version;
       request->mDefer = mDeferEnabled && aElement->GetScriptDeferred();
       mPreloads.RemoveElementAt(i);
+
+      rv = CheckContentPolicy(request, aElement, type);
+      if (NS_FAILED(rv)) {
+        // Note, we're dropping our last ref to request here.
+        return rv;
+      }
 
       if (!request->mLoading && !request->mDefer && !hadPendingRequests &&
             ReadyToExecuteScripts() && nsContentUtils::IsSafeToRunScript()) {
         return ProcessRequest(request);
       }
 
       // Not done loading yet. Move into the real requests queue and wait.
       mRequests.AppendObject(request);
diff -r 8b3caddca8f5 content/base/src/nsScriptLoader.h
--- a/content/base/src/nsScriptLoader.h	Sat Nov 15 23:56:49 2008 -0800
+++ b/content/base/src/nsScriptLoader.h	Sat Nov 22 15:25:48 2008 -0500
@@ -212,16 +212,23 @@ public:
    * @param aCharset The charset parameter for the script.
    * @param aType The type parameter for the script.
    */
   virtual void PreloadURI(nsIURI *aURI, const nsAString &aCharset,
                           const nsAString &aType);
 
 protected:
   /**
+   * Helper function to check the content policy for a given request.
+   */
+  nsresult CheckContentPolicy(nsScriptLoadRequest *aRequest,
+                              nsISupports *aContext,
+                              const nsAString &aType);
+
+  /**
    * Start a load for aRequest's URI.
    */
   nsresult StartLoad(nsScriptLoadRequest *aRequest, const nsAString &aType);
 
   /**
    * Process any pending requests asyncronously (i.e. off an event) if there
    * are any. Note that this is a no-op if there aren't any currently pending
    * requests.
diff -r 8b3caddca8f5 content/base/test/Makefile.in
--- a/content/base/test/Makefile.in	Sat Nov 15 23:56:49 2008 -0800
+++ b/content/base/test/Makefile.in	Sat Nov 22 15:25:48 2008 -0500
@@ -86,16 +86,18 @@ _TEST_FILES = 	test_bug5141.html \
 		test_bug218236.html \
 		file_bug218236_multipart.txt \
 		file_bug218236_multipart.txt^headers^ \
 		test_bug218277.html \
 		test_bug238409.html \
 		test_bug254337.html \
 		test_bug276037-1.html \
 		test_bug276037-2.xhtml \
+		test_bug298064.html \
+		bug298064-subframe.html \
 		test_bug308484.html \
 		test_bug311681.xml \
 		test_bug322317.html \
 		test_bug330925.xhtml \
 		test_bug337631.html \
 		test_bug338541.xhtml \
 		test_bug338679.html \
 		test_bug339494.html \
diff -r 8b3caddca8f5 content/base/test/bug298064-subframe.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/base/test/bug298064-subframe.html	Sat Nov 22 15:25:48 2008 -0500
@@ -0,0 +1,24 @@
+<!DOCTYPE HTML>
+<html>
+  <head>
+    <script>
+      function test_func() {
+        var bar = new Option();
+        parent.is(bar.ownerDocument, document,
+                  "Unexpected document for our new option");
+        bar = new Image();
+        parent.is(bar.ownerDocument, document,
+                  "Unexpected document for our new image");
+        bar = new parent.Option();
+        parent.is(bar.ownerDocument, parent.document,
+                  "Unexpected document for parent new option");
+        bar = new parent.Image();
+        parent.is(bar.ownerDocument, parent.document,
+                  "Unexpected document for parent new image");
+        parent.isnot(parent.document, document, "Documents should be different");
+      }
+    </script>
+  </head>
+<html>
+   
+  
diff -r 8b3caddca8f5 content/base/test/test_bug298064.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/base/test/test_bug298064.html	Sat Nov 22 15:25:48 2008 -0500
@@ -0,0 +1,33 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=298064
+-->
+<head>
+  <title>Test for Bug 298064</title>
+  <script type="application/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=298064">Mozilla Bug 298064</a>
+<p id="display"><iframe src="bug298064-subframe.html"></iframe></p>
+<div id="content" style="display: none">
+  
+</div>
+<pre id="test">
+<script type="application/javascript">
+
+/** Test for Bug 298064 **/
+SimpleTest.waitForExplicitFinish()
+addLoadEvent(function() {
+  window.frames[0].test_func();
+});
+addLoadEvent(SimpleTest.finish);
+
+
+
+</script>
+</pre>
+</body>
+</html>
diff -r 8b3caddca8f5 content/events/src/nsEventStateManager.h
--- a/content/events/src/nsEventStateManager.h	Sat Nov 15 23:56:49 2008 -0800
+++ b/content/events/src/nsEventStateManager.h	Sat Nov 22 15:25:48 2008 -0500
@@ -58,17 +58,19 @@ class nsIDocShell;
 class nsIDocShell;
 class nsIDocShellTreeNode;
 class nsIDocShellTreeItem;
 class nsIFocusController;
 class imgIContainer;
 class nsDOMDataTransfer;
 
 // mac uses click-hold context menus, a holdover from 4.x
-#ifdef XP_MACOSX
+// touch screens (like hildon) could use this also, 
+// perhaps we should move to NS_TOUCHSCREEN
+#if defined(XP_MACOSX) || defined(NS_HILDON)
 #define CLICK_HOLD_CONTEXT_MENUS 1
 #endif
 
 
 /*
  * Event listener manager
  */
 
diff -r 8b3caddca8f5 content/html/document/src/nsHTMLDocument.cpp
--- a/content/html/document/src/nsHTMLDocument.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/content/html/document/src/nsHTMLDocument.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -1815,20 +1815,23 @@ nsHTMLDocument::OpenCommon(const nsACStr
 
   // Note: We want to use GetDocumentFromContext here because this document
   // should inherit the security information of the document that's opening us,
   // (since if it's secure, then it's presumeably trusted).
   nsCOMPtr<nsIDocument> callerDoc =
     do_QueryInterface(nsContentUtils::GetDocumentFromContext());
 
   // Grab a reference to the calling documents security info (if any)
-  // and principal as it may be lost in the call to Reset().
+  // and URIs as they may be lost in the call to Reset().
   nsCOMPtr<nsISupports> securityInfo;
+  nsCOMPtr<nsIURI> uri, baseURI;
   if (callerDoc) {
     securityInfo = callerDoc->GetSecurityInfo();
+    uri = callerDoc->GetDocumentURI();
+    baseURI = callerDoc->GetBaseURI();
   }
 
   nsCOMPtr<nsIPrincipal> callerPrincipal;
   nsIScriptSecurityManager *secMan = nsContentUtils::GetSecurityManager();
 
   secMan->GetSubjectPrincipal(getter_AddRefs(callerPrincipal));
 
   if (!callerPrincipal) {
@@ -1849,28 +1852,16 @@ nsHTMLDocument::OpenCommon(const nsACStr
   // thing to do anyways.
 
   PRBool equals = PR_FALSE;
   if (NS_FAILED(callerPrincipal->Equals(NodePrincipal(), &equals)) ||
       !equals) {
     return NS_ERROR_DOM_SECURITY_ERR;
   }
 
-  // The URI for the document after this call. Get it from the calling
-  // principal (if available), or set it to "about:blank" if no
-  // principal is reachable.
-  nsCOMPtr<nsIURI> uri;
-  callerPrincipal->GetURI(getter_AddRefs(uri));
-
-  if (!uri) {
-    rv = NS_NewURI(getter_AddRefs(uri),
-                   NS_LITERAL_CSTRING("about:blank"));
-    NS_ENSURE_SUCCESS(rv, rv);
-  }
-
   // Stop current loads targeted at the window this document is in.
   if (mScriptGlobalObject) {
     nsCOMPtr<nsIContentViewer> cv;
     shell->GetContentViewer(getter_AddRefs(cv));
 
     if (cv) {
       PRBool okToUnload;
       rv = cv->PermitUnload(&okToUnload);
@@ -1891,16 +1882,19 @@ nsHTMLDocument::OpenCommon(const nsACStr
   nsCOMPtr<nsIChannel> channel;
   nsCOMPtr<nsILoadGroup> group = do_QueryReferent(mDocumentLoadGroup);
 
   rv = NS_NewChannel(getter_AddRefs(channel), uri, nsnull, group);
 
   if (NS_FAILED(rv)) {
     return rv;
   }
+
+  // We can't depend on channels implementing property bags, so do our
+  // base URI manually after reset.
 
   // Set the caller principal, if any, on the channel so that we'll
   // make sure to use it when we reset.
   rv = channel->SetOwner(callerPrincipal);
   NS_ENSURE_SUCCESS(rv, rv);
 
   // Before we reset the doc notify the globalwindow of the change,
   // but only if we still have a window (i.e. our window object the
@@ -1964,16 +1958,19 @@ nsHTMLDocument::OpenCommon(const nsACStr
 
   // Call Reset(), this will now do the full reset, except removing
   // the root from the document, doing that confuses the scrollbar
   // code in mozilla since the document in the root element and all
   // the anonymous content (i.e. scrollbar elements) is set to
   // null.
 
   Reset(channel, group);
+  if (baseURI) {
+    mDocumentBaseURI = baseURI;
+  }
 
   if (root) {
     // Tear down the frames for the root element.
     MOZ_AUTO_DOC_UPDATE(this, UPDATE_CONTENT_MODEL, PR_TRUE);
     nsNodeUtils::ContentRemoved(this, root, 0);
 
     // Put the root element back into the document, we don't notify
     // the document about this insertion since the sink will do that
diff -r 8b3caddca8f5 content/html/document/test/Makefile.in
--- a/content/html/document/test/Makefile.in	Sat Nov 15 23:56:49 2008 -0800
+++ b/content/html/document/test/Makefile.in	Sat Nov 22 15:25:48 2008 -0500
@@ -41,16 +41,17 @@ VPATH		= @srcdir@
 VPATH		= @srcdir@
 relativesrcdir  = content/html/document/test
 
 include $(DEPTH)/config/autoconf.mk
 include $(topsrcdir)/config/rules.mk
 
 _TEST_FILES = 	test_bug1682.html \
 		test_bug1823.html \
+		test_bug57600.html \
 		test_bug196523.html \
 		bug196523-subframe.html \
 		test_bug199692.html \
 		bug199692-nested.html \
 		bug199692-nested-d2.html \
 		bug199692-popup.html \
 		bug199692-scrolled.html \
 		test_bug172261.html \
@@ -68,16 +69,22 @@ _TEST_FILES = 	test_bug1682.html \
 		test_bug391777.html \
 		test_bug402680.html \
 		test_bug403868.html \
 		test_bug403868.xhtml \
 		test_bug404320.html \
 		test_form-parsing.html \
 		test_viewport.html \
 		test_documentAll.html \
+		test_bug445004.html \
+		bug445004-inner.js \
+		bug445004-outer-rel.html \
+		bug445004-outer-abs.html \
+		bug445004-outer-write.html \
+		bug445004-inner.html \
 		test_bug448564.html \
 		bug448564-iframe-1.html \
 		bug448564-iframe-2.html \
 		bug448564-iframe-3.html \
 		bug448564-echo.sjs \
 		bug448564-submit.js \
 		$(NULL)
 
diff -r 8b3caddca8f5 content/html/document/test/bug445004-inner.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/html/document/test/bug445004-inner.html	Sat Nov 22 15:25:48 2008 -0500
@@ -0,0 +1,14 @@
+<!DOCTYPE html>
+<html>
+  <head>
+    <base href="http://test1.example.org/tests/content/html/document/test/bug445004-inner.html">
+    <script src="bug445004-inner.js"></script>
+  </head>
+  <body>
+    <iframe name="w" id="w" width="100" height="100"></iframe>
+    <iframe name="x" id="x" width="100" height="100"></iframe>
+    <iframe name="y" id="y" width="100" height="100"></iframe>
+    <iframe name="z" id="z" width="100" height="100"></iframe>
+    <img src="test1.example.org.png">
+  </body>
+</html>
diff -r 8b3caddca8f5 content/html/document/test/bug445004-inner.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/html/document/test/bug445004-inner.js	Sat Nov 22 15:25:48 2008 -0500
@@ -0,0 +1,23 @@
+document.domain = "example.org";
+function $(str) { return document.getElementById(str); }
+function hookLoad(str) {
+  $(str).onload = function() { window.parent.parent.postMessage('end', '*'); };
+  window.parent.parent.postMessage('start', '*');
+}
+window.onload = function() {
+  hookLoad("w");
+  $("w").contentWindow.location.href = "test1.example.org.png";
+  hookLoad("x");
+  var doc = $("x").contentDocument;
+  doc.write('<img src="test1.example.org.png">');
+  doc.close();
+};
+function doIt() {
+  hookLoad("y");
+  $("y").contentWindow.location.href = "example.org.png";
+  hookLoad("z");
+  var doc = $("z").contentDocument;
+  doc.write('<img src="example.org.png">');
+  doc.close();
+}
+window.addEventListener("message", doIt, false);
\ No newline at end of file
diff -r 8b3caddca8f5 content/html/document/test/bug445004-outer-abs.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/html/document/test/bug445004-outer-abs.html	Sat Nov 22 15:25:48 2008 -0500
@@ -0,0 +1,11 @@
+<!DOCTYPE html>
+<html>
+  <head>
+    <base href="http://example.org/tests/content/html/document/test/bug445004-outer.html">
+    <script>document.domain = "example.org"</script>
+  </head>  
+  <body>
+    <iframe width="500" height="200" src="http://test1.example.org/tests/content/html/document/test/bug445004-inner.html"
+            onload="window.frames[0].doIt()"></iframe>
+  </body>
+</html>
diff -r 8b3caddca8f5 content/html/document/test/bug445004-outer-rel.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/html/document/test/bug445004-outer-rel.html	Sat Nov 22 15:25:48 2008 -0500
@@ -0,0 +1,11 @@
+<!DOCTYPE html>
+<html>
+  <head>
+    <base href="http://example.org/tests/content/html/document/test/bug445004-outer.html">
+    <script>document.domain = "example.org"</script>
+  </head>  
+  <body>
+    <iframe width="500" height="200" src="bug445004-inner.html"
+            onload="window.frames[0].doIt()"></iframe>
+  </body>
+</html>
diff -r 8b3caddca8f5 content/html/document/test/bug445004-outer-write.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/html/document/test/bug445004-outer-write.html	Sat Nov 22 15:25:48 2008 -0500
@@ -0,0 +1,11 @@
+<!DOCTYPE html>
+<html>
+  <head>
+    <base href="http://example.org/tests/content/html/document/test/bug445004-outer.html">
+    <script>document.domain = "example.org"</script>
+  </head>  
+  <body>
+    <iframe width="500" height="200" src="javascript:&quot;<!DOCTYPE html> <html>  <script> function $(str) { return document.getElementById(str); } function hookLoad(str) { $(str).onload = function() { window.parent.parent.postMessage('end', '*'); }; window.parent.parent.postMessage('start', '*'); } window.onload = function() { hookLoad(\&quot;w\&quot;); $(\&quot;w\&quot;).contentWindow.location.href = \&quot;example.org.png\&quot;; hookLoad(\&quot;x\&quot;); var doc = $(\&quot;x\&quot;).contentDocument; doc.write('<img src=\&quot;example.org.png\&quot;>'); doc.close(); }; function doIt() { hookLoad(\&quot;y\&quot;); $(\&quot;y\&quot;).contentWindow.location.href = \&quot;example.org.png\&quot;; hookLoad(\&quot;z\&quot;); var doc = $(\&quot;z\&quot;).contentDocument; doc.write('<img src=\&quot;example.org.png\&quot;>'); doc.close(); } </script> <body> <iframe name=\&quot;w\&quot; id=\&quot;w\&quot; width=\&quot;100\&quot; height=\&quot;100\&quot;></iframe> <iframe name=\&quot;x\&quot; id=\&quot;x\&quot; width=\&quot;100\&quot; height=\&quot;100\&quot;></iframe> <iframe name=\&quot;y\&quot; id=\&quot;y\&quot; width=\&quot;100\&quot; height=\&quot;100\&quot;></iframe> <iframe name=\&quot;z\&quot; id=\&quot;z\&quot; width=\&quot;100\&quot; height=\&quot;100\&quot;></iframe><img src=\&quot;example.org.png\&quot;> </body> </html>&quot; "
+            onload="window.frames[0].doIt();"></iframe>
+  </body>
+</html>
diff -r 8b3caddca8f5 content/html/document/test/test_bug445004.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/html/document/test/test_bug445004.html	Sat Nov 22 15:25:48 2008 -0500
@@ -0,0 +1,139 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=445004
+-->
+<head>
+  <title>Test for Bug 445004</title>
+  <script type="application/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=445004">Mozilla Bug 445004</a>
+<div id="content" style="display: none">
+  
+</div>
+<pre id="test">
+<script type="application/javascript">
+
+/** Test for Bug 445004 **/
+is(window.location.hostname, "localhost", "Unexpected hostname");
+is(window.location.port, "8888", "Unexpected port; fix testcase");
+
+SimpleTest.waitForExplicitFinish();
+
+var loads = 0;
+
+function loadStarted() {
+  ++loads;
+}
+function loadEnded() {
+  --loads;
+  if (loads == 0) {
+    doTest();
+  }
+}
+
+function getMessage(evt) {
+  ok(evt.data == "start" || evt.data == "end", "Must have start or end");
+  if (evt.data == "start")
+    loadStarted();
+  else
+    loadEnded();
+}
+
+window.addEventListener("message", getMessage, false);
+
+function checkURI(uri, name, type) {
+  var host = uri.match(/^http:\/\/([a-z.0-9]*)/)[1];
+  var file = uri.match(/([^\/]*).png$/)[1];
+  is(host, file, "Unexpected base URI for test " + name +
+     " when testing " + type);
+}
+
+function checkFrame(num) {
+  // Just snarf our data
+  netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
+
+  var outer = window.frames[num]
+  name = outer.name;
+
+  is(outer.document.baseURI,
+     "http://example.org/tests/content/html/document/test/bug445004-outer.html",
+     "Unexpected base URI for " + name);
+
+  var iswrite = name.match(/write/);
+
+  var inner = outer.frames[0];
+  if (iswrite) {
+    is(inner.document.baseURI,
+       "http://example.org/tests/content/html/document/test/bug445004-outer.html",
+       "Unexpected inner base URI for " + name);
+  } else {
+    is(inner.document.baseURI,
+       "http://test1.example.org/tests/content/html/document/test/bug445004-inner.html",
+       "Unexpected inner base URI for " + name);
+  }
+
+  var isrel = name.match(/rel/);
+  var offsite = name.match(/offsite/);
+
+  if (!iswrite) {
+    if ((isrel && !offsite) || (!isrel && offsite)) {
+      is(inner.location.hostname, outer.location.hostname,
+         "Unexpected hostnames for " + name);
+    } else {
+      isnot(inner.location.hostname, outer.location.hostname,
+            "Unexpected hostnames for " + name);
+    }
+  }
+
+  checkURI(inner.frames[0].location.href, name, "direct location");
+  checkURI(inner.frames[1].document.getElementsByTagName("img")[0].src,
+           name, "direct write");
+  if (!iswrite) {
+    is(inner.frames[1].location.hostname, inner.location.hostname,
+       "Incorrect hostname for " + name + " direct write")
+  }
+  checkURI(inner.frames[2].location.href, name, "indirect location");
+  checkURI(inner.frames[3].document.getElementsByTagName("img")[0].src,
+           name, "indirect write");
+  if (!iswrite) {
+    is(inner.frames[3].location.hostname, outer.location.hostname,
+       "Incorrect hostname for " + name + " indirect write")
+  }
+  checkURI(inner.document.getElementsByTagName("img")[0].src,
+           name, "direct image load");
+}
+
+
+function doTest() {
+  for (var num = 0; num < 5; ++num) {
+    checkFrame(num);
+  }
+
+  SimpleTest.finish();
+}
+
+</script>
+</pre>
+<p id="display">
+  <iframe
+     src="http://example.org/tests/content/html/document/test/bug445004-outer-rel.html"
+     name="bug445004-outer-rel.html"></iframe>
+  <iframe
+     src="http://test1.example.org/tests/content/html/document/test/bug445004-outer-rel.html">
+     name="bug445004-outer-rel.html offsite"></iframe>
+  <iframe
+     src="http://example.org/tests/content/html/document/test/bug445004-outer-abs.html">
+     name="bug445004-outer-abs.html"></iframe>
+  <iframe
+     src="http://test1.example.org/tests/content/html/document/test/bug445004-outer-abs.html"
+     name="bug445004-outer-abs.html offsite"></iframe>
+  <iframe
+     src="http://example.org/tests/content/html/document/test/bug445004-outer-write.html"
+     name="bug445004-outer-write.html"></iframe>
+</p>
+</body>
+</html>
diff -r 8b3caddca8f5 content/html/document/test/test_bug57600.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/html/document/test/test_bug57600.html	Sat Nov 22 15:25:48 2008 -0500
@@ -0,0 +1,43 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=57600
+-->
+<head>
+  <title>Test for Bug 57600</title>
+  <script type="application/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=57600">Mozilla Bug 57600</a>
+<div id="content" style="display: none">
+  
+</div>
+<pre id="test">
+<script type="application/javascript">
+
+/** Test for Bug 57600 **/
+SimpleTest.waitForExplicitFinish();
+var count = 0;
+function disp(win) {
+  var d = win ? win.document : self.testname.document;
+  var str = 'You should see this';
+  d.open();
+  d.write(str);
+  d.close();
+  is(d.documentElement.textContent, str, "Unexpected text");
+  if (++count == 2) {
+    SimpleTest.finish();
+  }
+}
+</script>
+</pre>
+<p id="display">
+  <iframe src="javascript:'<body onload=&quot;this.onerror = parent.onerror; parent.disp(self)&quot;></body>'"> 
+  </iframe>
+  <iframe name="testname" src="javascript:'<body onload=&quot;this.onerror = parent.onerror; parent.disp()&quot;></body>'"> 
+  </iframe>
+</p>
+</body>
+</html>
diff -r 8b3caddca8f5 content/media/video/public/nsOggDecoder.h
--- a/content/media/video/public/nsOggDecoder.h	Sat Nov 15 23:56:49 2008 -0800
+++ b/content/media/video/public/nsOggDecoder.h	Sat Nov 22 15:25:48 2008 -0500
@@ -328,55 +328,59 @@ class nsOggDecoder : public nsMediaDecod
   virtual void UpdateBytesDownloaded(PRUint64 aBytes);
 
   // Called when the video file has completed downloading.
   // Call on the main thread only.
   void ResourceLoaded();
 
   // Called if the media file encounters a network error.
   // Call on the main thread only.
-  void NetworkError();
+  virtual void NetworkError();
 
   // Call from any thread safely. Return PR_TRUE if we are currently
   // seeking in the media resource.
   virtual PRBool IsSeeking() const;
 
   // Get the size of the media file in bytes. Called on the main thread only.
   virtual void SetTotalBytes(PRInt64 aBytes);
 
   // Set a flag indicating whether seeking is supported
   virtual void SetSeekable(PRBool aSeekable);
 
   // Return PR_TRUE if seeking is supported.
   virtual PRBool GetSeekable();
 
+  // Returns the channel reader.
+  nsChannelReader* GetReader() { return mReader; }
+
 protected:
-  // Change to a new play state. This updates the mState variable and
-  // notifies any thread blocking on this objects monitor of the
-  // change. Can be called on any thread.
-  void ChangeState(PlayState aState);
 
   // Returns the monitor for other threads to synchronise access to
-  // state
+  // state.
   PRMonitor* GetMonitor() 
   { 
     return mMonitor; 
   }
 
-  // Return the current state. The caller must have entered the
-  // monitor.
+  // Return the current state. Can be called on any thread. If called from
+  // a non-main thread, the decoder monitor must be held.
   PlayState GetState()
   {
     return mPlayState;
   }
 
   /****** 
    * The following methods must only be called on the main
    * thread.
    ******/
+
+  // Change to a new play state. This updates the mState variable and
+  // notifies any thread blocking on this object's monitor of the
+  // change. Call on the main thread only.
+  void ChangeState(PlayState aState);
 
   // Called when the metadata from the Ogg file has been read.
   // Call on the main thread only.
   void MetadataLoaded();
 
   // Called when the first frame has been loaded.
   // Call on the main thread only.
   void FirstFrameLoaded();
@@ -481,29 +485,34 @@ private:
   nsCOMPtr<nsOggDecodeStateMachine> mDecodeStateMachine;
 
   // OggPlay object used to read data from a channel. Created on main
   // thread. Passed to liboggplay and the locking for multithreaded
   // access is handled by that library. Some methods are called from
   // the decoder thread, and the state machine for that thread keeps
   // a pointer to this reader. This is safe as the only methods called
   // are threadsafe (via the threadsafe nsMediaStream).
-  nsChannelReader* mReader;
+  nsAutoPtr<nsChannelReader> mReader;
 
   // Monitor for detecting when the video play state changes. A call
   // to Wait on this monitor will block the thread until the next
   // state change.
   PRMonitor* mMonitor;
 
   // Set to one of the valid play states. It is protected by the
   // monitor mMonitor. This monitor must be acquired when reading or
   // writing the state. Any change to the state on the main thread
   // must call NotifyAll on the monitor so the decode thread can wake up.
   PlayState mPlayState;
 
-  // The state to change to after a seek or load operation. It is
-  // protected by the monitor mMonitor. This monitor must be acquired
-  // when reading or writing the state. Any change to the state must
-  // call NotifyAll on the monitor.
-  PlayState mNextState;
+  // The state to change to after a seek or load operation. It must only
+  // be changed from the main thread. The decoder monitor must be acquired
+  // when writing to the state, or when reading from a non-main thread.
+  // Any change to the state must call NotifyAll on the monitor.
+  PlayState mNextState;	
+
+  // Flags if we've called Stop(). Prevents multiple events being
+  // sent to call Shutdown(). Accessed on the main thread
+  // only.
+  PRPackedBool mIsStopping;
 };
 
 #endif
diff -r 8b3caddca8f5 content/media/video/src/nsChannelReader.cpp
--- a/content/media/video/src/nsChannelReader.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/content/media/video/src/nsChannelReader.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -66,17 +66,16 @@ OggPlayErrorCode nsChannelReader::initia
 OggPlayErrorCode nsChannelReader::initialise(int aBlock)
 {
   return E_OGGPLAY_OK;
 }
 
 OggPlayErrorCode nsChannelReader::destroy()
 {
   mStream.Close();
-
   return E_OGGPLAY_OK;
 }
 
 size_t nsChannelReader::io_read(char* aBuffer, size_t aCount)
 {
   PRUint32 bytes = 0;
   nsresult rv = mStream.Read(aBuffer, aCount, &bytes);
   if (!NS_SUCCEEDED(rv)) {
@@ -108,19 +107,17 @@ static OggPlayErrorCode oggplay_channel_
     return E_OGGPLAY_BAD_READER;
   }
   return me->initialise(aBlock);
 }
 
 static OggPlayErrorCode oggplay_channel_reader_destroy(OggPlayReader* aReader) 
 {
   nsChannelReader* me = static_cast<nsChannelReader*>(aReader);
-  OggPlayErrorCode result = me->destroy();
-  delete me;
-  return result;
+  return me->destroy();
 }
 
 static size_t oggplay_channel_reader_io_read(void* aReader, void* aBuffer, size_t aCount) 
 {
   nsChannelReader* me = static_cast<nsChannelReader*>(aReader);
   return me->io_read(static_cast<char*>(aBuffer), aCount);
 }
 
diff -r 8b3caddca8f5 content/media/video/src/nsMediaStream.cpp
--- a/content/media/video/src/nsMediaStream.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/content/media/video/src/nsMediaStream.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -123,23 +123,22 @@ nsresult nsDefaultStreamStrategy::Open(n
 }
 
 nsresult nsDefaultStreamStrategy::Close()
 {
   nsAutoLock lock(mLock);
   if (mChannel) {
     mChannel->Cancel(NS_BINDING_ABORTED);
     mChannel = nsnull;
-
+  }
+  if (mPipeInput) {
     mPipeInput->Close();
     mPipeInput = nsnull;
-
-    mListener = nsnull;
   }
-
+  mListener = nsnull;
   return NS_OK;
 }
 
 nsresult nsDefaultStreamStrategy::Read(char* aBuffer, PRUint32 aCount, PRUint32* aBytes)
 {
   // The read request pulls from the pipe, not the channels input
   // stream. This allows calling from any thread as the pipe is
   // threadsafe.
@@ -461,23 +460,22 @@ nsresult nsHttpStreamStrategy::Open(nsIS
 }
 
 nsresult nsHttpStreamStrategy::Close()
 {
   nsAutoLock lock(mLock);
   if (mChannel) {
     mChannel->Cancel(NS_BINDING_ABORTED);
     mChannel = nsnull;
-
+  }
+  if (mPipeInput) {
     mPipeInput->Close();
     mPipeInput = nsnull;
-
-    mListener = nsnull;
   }
-
+  mListener = nsnull;
   return NS_OK;
 }
 
 nsresult nsHttpStreamStrategy::Read(char* aBuffer, PRUint32 aCount, PRUint32* aBytes)
 {
   // The read request pulls from the pipe, not the channels input
   // stream. This allows calling from any thread as the pipe is
   // threadsafe.
diff -r 8b3caddca8f5 content/media/video/src/nsOggDecoder.cpp
--- a/content/media/video/src/nsOggDecoder.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/content/media/video/src/nsOggDecoder.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -210,17 +210,17 @@ public:
     DECODER_STATE_DECODING_FIRSTFRAME,
     DECODER_STATE_DECODING,
     DECODER_STATE_SEEKING,
     DECODER_STATE_BUFFERING,
     DECODER_STATE_COMPLETED,
     DECODER_STATE_SHUTDOWN
   };
 
-  nsOggDecodeStateMachine(nsOggDecoder* aDecoder, nsChannelReader* aReader);
+  nsOggDecodeStateMachine(nsOggDecoder* aDecoder);
   ~nsOggDecodeStateMachine();
 
   // Cause state transitions. These methods obtain the decoder monitor
   // to synchronise the change of state, and to notify other threads
   // that the state has changed.
   void Shutdown();
   void Decode();
   void Seek(float aTime);
@@ -384,23 +384,16 @@ private:
   float   mFramerate;
 
   // Audio data. These are initially set when the metadata is loaded.
   // They are only accessed from the decoder thread.
   PRInt32 mAudioRate;
   PRInt32 mAudioChannels;
   PRInt32 mAudioTrack;
 
-  // Channel Reader. Originally created by the mDecoder object, it is
-  // destroyed when we close the mPlayer handle in the
-  // destructor. Used to obtain download and playback rate information
-  // for buffering.  Synchronisation for those methods are handled by
-  // nsMediaStream.
-  nsChannelReader* mReader;
-
   // Time that buffering started. Used for buffering timeout and only
   // accessed in the decoder thread.
   PRIntervalTime mBufferingStart;
 
   // Number of bytes to buffer when buffering. Only accessed in the
   // decoder thread.
   PRUint32 mBufferingBytes;
 
@@ -456,30 +449,29 @@ private:
 
   // PR_TRUE if an event to notify about a change in the playback
   // position has been queued, but not yet run. It is set to PR_FALSE when
   // the event is run. This allows coalescing of these events as they can be
   // produced many times per second. Synchronised via decoder monitor.
   PRPackedBool mPositionChangeQueued;
 };
 
-nsOggDecodeStateMachine::nsOggDecodeStateMachine(nsOggDecoder* aDecoder, nsChannelReader* aReader) :
+nsOggDecodeStateMachine::nsOggDecodeStateMachine(nsOggDecoder* aDecoder) :
   mDecoder(aDecoder),
   mPlayer(0),
   mPlayStartTime(0),
   mPauseStartTime(0),
   mPauseDuration(0),
   mPlaying(PR_FALSE),
   mCallbackPeriod(1.0),
   mVideoTrack(-1),
   mFramerate(0.0),
   mAudioRate(0),
   mAudioChannels(0),
   mAudioTrack(-1),
-  mReader(aReader),
   mBufferingStart(0),
   mBufferingBytes(0),
   mLastFrameTime(0),
   mState(DECODER_STATE_DECODING_METADATA),
   mSeekTime(0.0),
   mCurrentFrameTime(0.0),
   mVolume(1.0),
   mDuration(-1),
@@ -489,20 +481,18 @@ nsOggDecodeStateMachine::nsOggDecodeStat
 {
 }
 
 nsOggDecodeStateMachine::~nsOggDecodeStateMachine()
 {
   while (!mDecodedFrames.IsEmpty()) {
     delete mDecodedFrames.Pop();
   }
-
   oggplay_close(mPlayer);
 }
-
 
 OggPlayErrorCode nsOggDecodeStateMachine::DecodeFrame()
 {
   NS_ASSERTION(mState > DECODER_STATE_DECODING_METADATA, "DecodeFrame() called during invalid state");
   return oggplay_step_decoding(mPlayer);
 }
 
 nsOggDecodeStateMachine::FrameData* nsOggDecodeStateMachine::NextFrame()
@@ -848,16 +838,18 @@ void nsOggDecodeStateMachine::Seek(float
 {
   nsAutoMonitor mon(mDecoder->GetMonitor());
   mSeekTime = aTime;
   mState = DECODER_STATE_SEEKING;
 }
 
 nsresult nsOggDecodeStateMachine::Run()
 {
+  nsChannelReader* reader = mDecoder->GetReader();
+  NS_ENSURE_TRUE(reader, NS_ERROR_NULL_POINTER);
   while (PR_TRUE) {
    nsAutoMonitor mon(mDecoder->GetMonitor());
    switch(mState) {
     case DECODER_STATE_SHUTDOWN:
       return NS_OK;
 
     case DECODER_STATE_DECODING_METADATA:
       mon.Exit();
@@ -897,26 +889,26 @@ nsresult nsOggDecodeStateMachine::Run()
           mState = DECODER_STATE_DECODING;
         }
       }
       break;
 
     case DECODER_STATE_DECODING:
       {
         // Before decoding check if we should buffer more data
-        if (mReader->DownloadRate() >= 0 &&
-            mReader->Available() < mReader->PlaybackRate() * BUFFERING_SECONDS_LOW_WATER_MARK) {
+        if (reader->DownloadRate() >= 0 &&
+            reader->Available() < reader->PlaybackRate() * BUFFERING_SECONDS_LOW_WATER_MARK) {
           if (mDecoder->GetState() == nsOggDecoder::PLAY_STATE_PLAYING) {
             if (mPlaying) {
               StopPlayback();
             }
           }
 
           mBufferingStart = PR_IntervalNow();
-          mBufferingBytes = PRUint32(BUFFERING_RATE(mReader->PlaybackRate()) * BUFFERING_WAIT);
+          mBufferingBytes = PRUint32(BUFFERING_RATE(reader->PlaybackRate()) * BUFFERING_WAIT);
           mState = DECODER_STATE_BUFFERING;
 
           nsCOMPtr<nsIRunnable> event =
             NS_NEW_RUNNABLE_METHOD(nsOggDecoder, mDecoder, BufferingStarted);
           NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
         }
         else {
           if (!mDecodedFrames.IsFull()) {
@@ -1004,21 +996,21 @@ nsresult nsOggDecodeStateMachine::Run()
         if (mState == DECODER_STATE_SEEKING && mSeekTime == seekTime) {
           mState = DECODER_STATE_DECODING;
         }
       }
       break;
 
     case DECODER_STATE_BUFFERING:
       if ((PR_IntervalToMilliseconds(PR_IntervalNow() - mBufferingStart) < BUFFERING_WAIT*1000) &&
-          mReader->DownloadRate() >= 0 &&            
-          mReader->Available() < mBufferingBytes) {
+          reader->DownloadRate() >= 0 &&            
+          reader->Available() < mBufferingBytes) {
         LOG(PR_LOG_DEBUG, 
             ("Buffering data until %d bytes available or %d milliseconds", 
-             mBufferingBytes - mReader->Available(),
+             mBufferingBytes - reader->Available(),
              BUFFERING_WAIT*1000 - (PR_IntervalToMilliseconds(PR_IntervalNow() - mBufferingStart))));
         mon.Wait(PR_MillisecondsToInterval(1000));
         if (mState == DECODER_STATE_SHUTDOWN)
           continue;
       }
       else {
         mState = DECODER_STATE_DECODING;
       }
@@ -1064,17 +1056,17 @@ nsresult nsOggDecodeStateMachine::Run()
   }
 
   return NS_OK;
 }
 
 void nsOggDecodeStateMachine::LoadOggHeaders() 
 {
   LOG(PR_LOG_DEBUG, ("Loading Ogg Headers"));
-  mPlayer = oggplay_open_with_reader(mReader);
+  mPlayer = oggplay_open_with_reader(mDecoder->GetReader());
   if (mPlayer) {
     LOG(PR_LOG_DEBUG, ("There are %d tracks", oggplay_get_num_tracks(mPlayer)));
 
     for (int i = 0; i < oggplay_get_num_tracks(mPlayer); ++i) {
       LOG(PR_LOG_DEBUG, ("Tracks %d: %s", i, oggplay_get_track_typename(mPlayer, i)));
       if (mVideoTrack == -1 && oggplay_get_track_type(mPlayer, i) == OGGZ_CONTENT_THEORA) {
         oggplay_set_callback_num_frames(mPlayer, i, 1);
         mVideoTrack = i;
@@ -1179,17 +1171,18 @@ nsOggDecoder::nsOggDecoder() :
   mInitialVolume(0.0),
   mRequestedSeekTime(-1.0),
   mContentLength(-1),
   mNotifyOnShutdown(PR_FALSE),
   mSeekable(PR_TRUE),
   mReader(0),
   mMonitor(0),
   mPlayState(PLAY_STATE_PAUSED),
-  mNextState(PLAY_STATE_PAUSED)
+  mNextState(PLAY_STATE_PAUSED),
+  mIsStopping(PR_FALSE)
 {
   MOZ_COUNT_CTOR(nsOggDecoder);
 }
 
 PRBool nsOggDecoder::Init() 
 {
   mMonitor = nsAutoMonitor::NewMonitor("media.decoder");
   return mMonitor && nsMediaDecoder::Init();
@@ -1234,16 +1227,20 @@ nsOggDecoder::~nsOggDecoder()
 {
   MOZ_COUNT_DTOR(nsOggDecoder);
   nsAutoMonitor::DestroyMonitor(mMonitor);
 }
 
 nsresult nsOggDecoder::Load(nsIURI* aURI, nsIChannel* aChannel,
                             nsIStreamListener** aStreamListener)
 {
+  // Reset Stop guard flag flag, else shutdown won't occur properly when
+  // reusing decoder.
+  mIsStopping = PR_FALSE;
+
   if (aStreamListener) {
     *aStreamListener = nsnull;
   }
 
   if (aURI) {
     NS_ASSERTION(!aStreamListener, "No listener should be requested here");
     mURI = aURI;
   } else {
@@ -1265,17 +1262,17 @@ nsresult nsOggDecoder::Load(nsIURI* aURI
   NS_ENSURE_TRUE(mReader, NS_ERROR_OUT_OF_MEMORY);
 
   nsresult rv = mReader->Init(this, mURI, aChannel, aStreamListener);
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = NS_NewThread(getter_AddRefs(mDecodeThread));
   NS_ENSURE_SUCCESS(rv, rv);
 
-  mDecodeStateMachine = new nsOggDecodeStateMachine(this, mReader);
+  mDecodeStateMachine = new nsOggDecodeStateMachine(this);
   {
     nsAutoMonitor mon(mMonitor);
     mDecodeStateMachine->SetContentLength(mContentLength);
     mDecodeStateMachine->SetSeekable(mSeekable);
   }
 
   ChangeState(PLAY_STATE_LOADING);
 
@@ -1321,25 +1318,31 @@ nsresult nsOggDecoder::Seek(float aTime)
 
 nsresult nsOggDecoder::PlaybackRateChanged()
 {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 void nsOggDecoder::Stop()
 {
+  NS_ASSERTION(NS_IsMainThread(), 
+               "nsOggDecoder::Stop called on non-main thread");  
+  
+  if (mIsStopping)
+    return;
+  mIsStopping = PR_TRUE;
+
   ChangeState(PLAY_STATE_ENDED);
 
   StopProgress();
 
   // Force any outstanding seek and byterange requests to complete
   // to prevent shutdown from deadlocking.
   if (mReader) {
     mReader->Cancel();
-    mReader = nsnull;
   }
 
   // Shutdown must be on called the mDecodeStateMachine before deleting.
   // This is required to ensure that the state machine isn't running
   // in the thread and using internal objects when it is deleted.
   if (mDecodeStateMachine) {
     mDecodeStateMachine->Shutdown();
   }
@@ -1348,16 +1351,17 @@ void nsOggDecoder::Stop()
   // Shutdown. The Shutdown() on the state machine unblocks any
   // blocking calls preventing the thread Shutdown from deadlocking.
   if (mDecodeThread) {
     mDecodeThread->Shutdown();
     mDecodeThread = nsnull;
   }
 
   mDecodeStateMachine = nsnull;
+  mReader = nsnull;
   UnregisterShutdownObserver();
 }
 
 float nsOggDecoder::GetCurrentTime()
 {
   return mCurrentTime;
 }
 
@@ -1544,16 +1548,18 @@ void nsOggDecoder::UnregisterShutdownObs
       mNotifyOnShutdown = PR_FALSE;
       observerService->RemoveObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID);
     }
   }
 }
 
 void nsOggDecoder::ChangeState(PlayState aState)
 {
+  NS_ASSERTION(NS_IsMainThread(), 
+               "nsOggDecoder::ChangeState called on non-main thread");   
   nsAutoMonitor mon(mMonitor);
 
   if (mNextState == aState) {
     mNextState = PLAY_STATE_PAUSED;
   }
 
   if (mPlayState == PLAY_STATE_SHUTDOWN) {
     mon.NotifyAll();
diff -r 8b3caddca8f5 docshell/test/Makefile.in
--- a/docshell/test/Makefile.in	Sat Nov 15 23:56:49 2008 -0800
+++ b/docshell/test/Makefile.in	Sat Nov 22 15:25:48 2008 -0500
@@ -51,16 +51,18 @@ XPCSHELL_TESTS = unit
 XPCSHELL_TESTS = unit
 
 include $(DEPTH)/config/autoconf.mk
 include $(topsrcdir)/config/rules.mk
 
 _TEST_FILES = \
 		test_bug94514.html \
 		bug94514-postpage.html \
+		test_bug123696.html \
+		bug123696-subframe.html \
 		test_bug344861.html \
 		test_bug369814.html \
 		bug369814.zip       \
 		test_bug384014.html \
 		test_bug387979.html \
 		test_bug404548.html \
 		bug404548-subframe.html \
 		test_bug413310.html \
diff -r 8b3caddca8f5 docshell/test/bug123696-subframe.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/docshell/test/bug123696-subframe.html	Sat Nov 22 15:25:48 2008 -0500
@@ -0,0 +1,16 @@
+<!DOCTYPE html>
+<html>
+  <head>
+    <script>
+      function change() {
+        return "<html><body>change</body></html>";
+      }
+      function change2() {
+        return "<html><body>change2</body></html>";
+      }
+    </script>
+  </head>
+  <body>
+    <iframe src="javascript:parent.change()"></iframe>
+  </body>
+</html>
diff -r 8b3caddca8f5 docshell/test/test_bug123696.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/docshell/test/test_bug123696.html	Sat Nov 22 15:25:48 2008 -0500
@@ -0,0 +1,47 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=123696
+-->
+<head>
+  <title>Test for Bug 123696</title>
+  <script type="application/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=123696">Mozilla Bug 123696</a>
+<p id="display">
+  <iframe src="bug123696-subframe.html"></iframe>
+</p>
+<div id="content" style="display: none">
+  
+</div>
+<pre id="test">
+<script type="application/javascript">
+
+/** Test for Bug 123696 **/
+SimpleTest.waitForExplicitFinish();
+
+function finishTest() {
+  is(window.frames[0].frames[0].document.documentElement.textContent,
+     "change2", "Reload should have reloaded correctly!");
+  SimpleTest.finish();
+}
+
+function doReload() {
+  window.frames[0].frameElement.onload = finishTest;
+  window.frames[0].location.reload();
+}
+
+addLoadEvent(function() {
+  window.frames[0].frames[0].frameElement.onload = doReload;
+  window.frames[0].frames[0].frameElement.src = "javascript:parent.change2()";
+});
+
+
+
+</script>
+</pre>
+</body>
+</html>
diff -r 8b3caddca8f5 dom/src/base/nsGlobalWindow.cpp
--- a/dom/src/base/nsGlobalWindow.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/dom/src/base/nsGlobalWindow.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -2159,17 +2159,17 @@ nsGlobalWindow::SetOpenerWindow(nsIDOMWi
 
   NS_ASSERTION(!aOriginalOpener || !mSetOpenerWindowCalled,
                "aOriginalOpener is true, but not first call to "
                "SetOpenerWindow!");
   NS_ASSERTION(aOpener || !aOriginalOpener,
                "Shouldn't set mHadOriginalOpener if aOpener is null");
 
   mOpener = do_GetWeakReference(aOpener);
-  NS_ASSERTION(mOpener, "Opener must support weak references!");
+  NS_ASSERTION(mOpener || !aOpener, "Opener must support weak references!");
 
   if (aOriginalOpener) {
     mHadOriginalOpener = PR_TRUE;
   }
 
 #ifdef DEBUG
   mSetOpenerWindowCalled = PR_TRUE;
 #endif
diff -r 8b3caddca8f5 dom/src/base/nsJSEnvironment.cpp
--- a/dom/src/base/nsJSEnvironment.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/dom/src/base/nsJSEnvironment.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -845,19 +845,16 @@ PrintWinCodebase(nsGlobalWindow *win)
   }
 
   nsCAutoString spec;
   uri->GetSpec(spec);
   printf("%s\n", spec.get());
 }
 #endif
 
-// The accumulated operation weight before we call MaybeGC
-const PRUint32 MAYBE_GC_OPERATION_WEIGHT = 5000 * JS_OPERATION_WEIGHT_BASE;
-
 static void
 MaybeGC(JSContext *cx)
 {
   size_t bytes = cx->runtime->gcBytes;
   size_t lastBytes = cx->runtime->gcLastBytes;
 
   if ((bytes > 8192 && bytes / 16 > lastBytes)
 #ifdef DEBUG
@@ -927,34 +924,34 @@ nsJSContext::DOMOperationCallback(JSCont
     if (! ::JS_IsSystemObject(cx, ::JS_GetGlobalObject(cx))) {
 
       // lets see if CC() did anything, if not, cancel the script.
       mem->IsLowMemory(&lowMemory);
       if (lowMemory) {
 
         if (nsContentUtils::GetBoolPref("dom.prevent_oom_dialog", PR_FALSE))
           return JS_FALSE;
-        
+
         nsCOMPtr<nsIPrompt> prompt = GetPromptFromContext(ctx);
-        
+
         nsXPIDLString title, msg;
         rv = nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
                                                 "LowMemoryTitle",
                                                 title);
-        
+
         rv |= nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
                                                  "LowMemoryMessage",
                                                  msg);
-        
+
         //GetStringFromName can return NS_OK and still give NULL string
         if (NS_FAILED(rv) || !title || !msg) {
           NS_ERROR("Failed to get localized strings.");
           return JS_FALSE;
         }
-        
+
         prompt->Alert(title, msg);
         return JS_FALSE;
       }
     }
   }
 
   PRTime now = PR_Now();
 
@@ -1231,19 +1228,18 @@ nsJSContext::nsJSContext(JSRuntime *aRun
 
     // Make sure the new context gets the default context options
     ::JS_SetOptions(mContext, mDefaultJSOptions);
 
     // Watch for the JS boolean options
     nsContentUtils::RegisterPrefCallback(js_options_dot_str,
                                          JSOptionChangedCallback,
                                          this);
-
-    ::JS_SetOperationCallback(mContext, DOMOperationCallback,
-                              MAYBE_GC_OPERATION_WEIGHT);
+    ::JS_SetOperationCallback(mContext, DOMOperationCallback);
+    nsContentUtils::XPConnect()->SetWatchdogLimit(mContext, PR_TicksPerSecond()/10);
 
     static JSLocaleCallbacks localeCallbacks =
       {
         LocaleToUpperCase,
         LocaleToLowerCase,
         LocaleCompare,
         LocaleToUnicode
       };
diff -r 8b3caddca8f5 dom/src/base/nsLocation.cpp
--- a/dom/src/base/nsLocation.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/dom/src/base/nsLocation.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -239,17 +239,19 @@ nsLocation::CheckURL(nsIURI* aURI, nsIDo
 
   loadInfo.swap(*aLoadInfo);
 
   return NS_OK;
 }
 
 // Walk up the docshell hierarchy and find a usable base URI. Basically 
 // anything that would allow a relative uri.
-
+// XXXbz we don't need this for javascript: URIs anymore.  Do we need
+// it for about:blank?  I would think that we don't, and that we can
+// nuke this code.
 nsresult
 nsLocation::FindUsableBaseURI(nsIURI * aBaseURI, nsIDocShell * aParent,
                               nsIURI ** aUsableURI)
 {
   if (!aBaseURI || !aParent)
     return NS_ERROR_FAILURE;
   NS_ENSURE_ARG_POINTER(aUsableURI);
 
diff -r 8b3caddca8f5 dom/src/jsurl/nsJSProtocolHandler.cpp
--- a/dom/src/jsurl/nsJSProtocolHandler.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/dom/src/jsurl/nsJSProtocolHandler.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -70,16 +70,21 @@
 #include "nsIContentViewer.h"
 #include "nsIXPConnect.h"
 #include "nsContentUtils.h"
 #include "nsJSUtils.h"
 #include "nsThreadUtils.h"
 #include "nsIJSContextStack.h"
 #include "nsIScriptChannel.h"
 #include "nsIDocument.h"
+#include "nsIObjectInputStream.h"
+#include "nsIObjectOutputStream.h"
+#include "nsIWritablePropertyBag2.h"
+
+static NS_DEFINE_CID(kJSURICID, NS_JSURI_CID);
 
 class nsJSThunk : public nsIInputStream
 {
 public:
     nsJSThunk();
 
     NS_DECL_ISUPPORTS
     NS_FORWARD_SAFE_NSIINPUTSTREAM(mInnerStream)
@@ -378,27 +383,30 @@ nsresult nsJSThunk::EvaluateScript(nsICh
 
     return rv;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 
 class nsJSChannel : public nsIChannel,
                     public nsIStreamListener,
-                    public nsIScriptChannel
+                    public nsIScriptChannel,
+                    public nsIPropertyBag2
 {
 public:
     nsJSChannel();
 
     NS_DECL_ISUPPORTS
     NS_DECL_NSIREQUEST
     NS_DECL_NSICHANNEL
     NS_DECL_NSIREQUESTOBSERVER
     NS_DECL_NSISTREAMLISTENER
     NS_DECL_NSISCRIPTCHANNEL
+    NS_FORWARD_SAFE_NSIPROPERTYBAG(mPropertyBag)
+    NS_FORWARD_SAFE_NSIPROPERTYBAG2(mPropertyBag)
 
     nsresult Init(nsIURI *aURI);
 
     // Actually evaluate the script.
     void EvaluateScript();
     
 protected:
     virtual ~nsJSChannel();
@@ -406,16 +414,17 @@ protected:
     nsresult StopAll();
 
     void NotifyListener();
 
     void CleanupStrongRefs();
     
 protected:
     nsCOMPtr<nsIChannel>    mStreamChannel;
+    nsCOMPtr<nsIPropertyBag2> mPropertyBag;
     nsCOMPtr<nsIStreamListener> mListener;  // Our final listener
     nsCOMPtr<nsISupports> mContext; // The context passed to AsyncOpen
     nsCOMPtr<nsPIDOMWindow> mOriginalInnerWindow;  // The inner window our load
                                                    // started against.
     // If we blocked onload on a document in AsyncOpen, this is the document we
     // did it on.
     nsCOMPtr<nsIDocument>   mDocumentOnloadBlockedOn;
 
@@ -459,17 +468,20 @@ nsresult nsJSChannel::StopAll()
         rv = webNav->Stop(nsIWebNavigation::STOP_ALL);
     }
 
     return rv;
 }
 
 nsresult nsJSChannel::Init(nsIURI *aURI)
 {
-    nsresult rv;
+    nsRefPtr<nsJSURI> jsURI;
+    nsresult rv = aURI->QueryInterface(kJSURICID,
+                                       getter_AddRefs(jsURI));
+    NS_ENSURE_SUCCESS(rv, rv);
 
     // Create the nsIStreamIO layer used by the nsIStreamIOChannel.
     mIOThunk = new nsJSThunk();
     if (!mIOThunk)
         return NS_ERROR_OUT_OF_MEMORY;
 
     // Create a stock input stream channel...
     // Remember, until AsyncOpen is called, the script will not be evaluated
@@ -480,36 +492,35 @@ nsresult nsJSChannel::Init(nsIURI *aURI)
     // treat it as html.
     rv = NS_NewInputStreamChannel(getter_AddRefs(channel), aURI, mIOThunk,
                                   NS_LITERAL_CSTRING("text/html"));
     if (NS_FAILED(rv)) return rv;
 
     rv = mIOThunk->Init(aURI);
     if (NS_SUCCEEDED(rv)) {
         mStreamChannel = channel;
+        mPropertyBag = do_QueryInterface(channel);
+        nsCOMPtr<nsIWritablePropertyBag2> writableBag =
+            do_QueryInterface(channel);
+        if (writableBag && jsURI->GetBaseURI()) {
+            writableBag->SetPropertyAsInterface(NS_LITERAL_STRING("baseURI"),
+                                                jsURI->GetBaseURI());
+        }
     }
 
     return rv;
 }
 
 //
 // nsISupports implementation...
 //
 
-NS_IMPL_ADDREF(nsJSChannel)
-NS_IMPL_RELEASE(nsJSChannel)
-
-NS_INTERFACE_MAP_BEGIN(nsJSChannel)
-    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIChannel)
-    NS_INTERFACE_MAP_ENTRY(nsIRequest)
-    NS_INTERFACE_MAP_ENTRY(nsIChannel)
-    NS_INTERFACE_MAP_ENTRY(nsIRequestObserver)
-    NS_INTERFACE_MAP_ENTRY(nsIStreamListener)
-    NS_INTERFACE_MAP_ENTRY(nsIScriptChannel)
-NS_INTERFACE_MAP_END
+NS_IMPL_ISUPPORTS7(nsJSChannel, nsIChannel, nsIRequest, nsIRequestObserver,
+                   nsIStreamListener, nsIScriptChannel, nsIPropertyBag,
+                   nsIPropertyBag2)
 
 //
 // nsIRequest implementation...
 //
 
 NS_IMETHODIMP
 nsJSChannel::GetName(nsACString &aResult)
 {
@@ -1159,28 +1170,27 @@ nsJSProtocolHandler::GetProtocolFlags(PR
 {
     *result = URI_NORELATIVE | URI_NOAUTH | URI_INHERITS_SECURITY_CONTEXT |
         URI_LOADABLE_BY_ANYONE | URI_NON_PERSISTABLE;
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsJSProtocolHandler::NewURI(const nsACString &aSpec,
-                            const char *aCharset, // ignore charset info
+                            const char *aCharset,
                             nsIURI *aBaseURI,
                             nsIURI **result)
 {
     nsresult rv;
 
     // javascript: URLs (currently) have no additional structure beyond that
     // provided by standard URLs, so there is no "outer" object given to
     // CreateInstance.
 
-    nsIURI* url;
-    rv = CallCreateInstance(NS_SIMPLEURI_CONTRACTID, &url);
+    nsCOMPtr<nsIURI> url = do_CreateInstance(NS_SIMPLEURI_CONTRACTID, &rv);
 
     if (NS_FAILED(rv))
         return rv;
 
     if (!aCharset || !nsCRT::strcasecmp("UTF-8", aCharset))
       rv = url->SetSpec(aSpec);
     else {
       nsCAutoString utf8Spec;
@@ -1189,21 +1199,23 @@ nsJSProtocolHandler::NewURI(const nsACSt
         if (utf8Spec.IsEmpty())
           rv = url->SetSpec(aSpec);
         else
           rv = url->SetSpec(utf8Spec);
       }
     }
 
     if (NS_FAILED(rv)) {
-        NS_RELEASE(url);
         return rv;
     }
 
-    *result = url;
+    *result = new nsJSURI(aBaseURI, url);
+    NS_ENSURE_TRUE(*result, NS_ERROR_OUT_OF_MEMORY);
+
+    NS_ADDREF(*result);
     return rv;
 }
 
 NS_IMETHODIMP
 nsJSProtocolHandler::NewChannel(nsIURI* uri, nsIChannel* *result)
 {
     nsresult rv;
     nsJSChannel * channel;
@@ -1228,8 +1240,172 @@ NS_IMETHODIMP
 NS_IMETHODIMP 
 nsJSProtocolHandler::AllowPort(PRInt32 port, const char *scheme, PRBool *_retval)
 {
     // don't override anything.  
     *_retval = PR_FALSE;
     return NS_OK;
 }
 
+////////////////////////////////////////////////////////////
+// nsJSURI implementation
+
+NS_IMPL_ADDREF(nsJSURI)
+NS_IMPL_RELEASE(nsJSURI)
+
+NS_INTERFACE_MAP_BEGIN(nsJSURI)
+  NS_INTERFACE_MAP_ENTRY(nsIURI)
+  NS_INTERFACE_MAP_ENTRY(nsISerializable)
+  NS_INTERFACE_MAP_ENTRY(nsIClassInfo)
+  NS_INTERFACE_MAP_ENTRY(nsIMutable)
+  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIURI)
+  if (aIID.Equals(kJSURICID))
+      foundInterface = static_cast<nsIURI*>(this);
+  else
+NS_INTERFACE_MAP_END
+
+// nsISerializable methods:
+
+NS_IMETHODIMP
+nsJSURI::Read(nsIObjectInputStream* aStream)
+{
+    nsresult rv;
+
+    rv = aStream->ReadObject(PR_TRUE, getter_AddRefs(mSimpleURI));
+    if (NS_FAILED(rv)) return rv;
+
+    mMutable = do_QueryInterface(mSimpleURI);
+    NS_ENSURE_TRUE(mMutable, NS_ERROR_UNEXPECTED);
+
+    PRBool haveBase;
+    rv = aStream->ReadBoolean(&haveBase);
+    if (NS_FAILED(rv)) return rv;
+
+    if (haveBase) {
+        rv = aStream->ReadObject(PR_TRUE, getter_AddRefs(mBaseURI));
+        if (NS_FAILED(rv)) return rv;
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsJSURI::Write(nsIObjectOutputStream* aStream)
+{
+    nsresult rv;
+
+    rv = aStream->WriteObject(mSimpleURI, PR_TRUE);
+    if (NS_FAILED(rv)) return rv;
+
+    rv = aStream->WriteBoolean(mBaseURI != nsnull);
+    if (NS_FAILED(rv)) return rv;
+
+    if (mBaseURI) {
+        rv = aStream->WriteObject(mBaseURI, PR_TRUE);
+        if (NS_FAILED(rv)) return rv;
+    }
+
+    return NS_OK;
+}
+
+// nsIURI methods:
+
+NS_IMETHODIMP
+nsJSURI::Clone(nsIURI** aClone)
+{
+    nsCOMPtr<nsIURI> simpleClone;
+    nsresult rv = mSimpleURI->Clone(getter_AddRefs(simpleClone));
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    nsCOMPtr<nsIURI> baseClone;
+    if (mBaseURI) {
+        rv = mBaseURI->Clone(getter_AddRefs(baseClone));
+        NS_ENSURE_SUCCESS(rv, rv);
+    }
+
+    nsIURI* newURI = new nsJSURI(baseClone, simpleClone);
+    NS_ENSURE_TRUE(newURI, NS_ERROR_OUT_OF_MEMORY);
+
+    NS_ADDREF(*aClone = newURI);
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsJSURI::Equals(nsIURI* aOther, PRBool *aResult)
+{
+    if (!aOther) {
+        *aResult = PR_FALSE;
+        return NS_OK;
+    }
+    
+    nsRefPtr<nsJSURI> otherJSUri;
+    aOther->QueryInterface(kJSURICID, getter_AddRefs(otherJSUri));
+    if (!otherJSUri) {
+        *aResult = PR_FALSE;
+        return NS_OK;
+    }
+
+    return mSimpleURI->Equals(otherJSUri->mSimpleURI, aResult);
+}
+
+// nsIClassInfo methods:
+NS_IMETHODIMP 
+nsJSURI::GetInterfaces(PRUint32 *count, nsIID * **array)
+{
+    *count = 0;
+    *array = nsnull;
+    return NS_OK;
+}
+
+NS_IMETHODIMP 
+nsJSURI::GetHelperForLanguage(PRUint32 language, nsISupports **_retval)
+{
+    *_retval = nsnull;
+    return NS_OK;
+}
+
+NS_IMETHODIMP 
+nsJSURI::GetContractID(char * *aContractID)
+{
+    // Make sure to modify any subclasses as needed if this ever
+    // changes.
+    *aContractID = nsnull;
+    return NS_OK;
+}
+
+NS_IMETHODIMP 
+nsJSURI::GetClassDescription(char * *aClassDescription)
+{
+    *aClassDescription = nsnull;
+    return NS_OK;
+}
+
+NS_IMETHODIMP 
+nsJSURI::GetClassID(nsCID * *aClassID)
+{
+    // Make sure to modify any subclasses as needed if this ever
+    // changes to not call the virtual GetClassIDNoAlloc.
+    *aClassID = (nsCID*) nsMemory::Alloc(sizeof(nsCID));
+    if (!*aClassID)
+        return NS_ERROR_OUT_OF_MEMORY;
+    return GetClassIDNoAlloc(*aClassID);
+}
+
+NS_IMETHODIMP 
+nsJSURI::GetImplementationLanguage(PRUint32 *aImplementationLanguage)
+{
+    *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
+    return NS_OK;
+}
+
+NS_IMETHODIMP 
+nsJSURI::GetFlags(PRUint32 *aFlags)
+{
+    *aFlags = nsIClassInfo::MAIN_THREAD_ONLY;
+    return NS_OK;
+}
+
+NS_IMETHODIMP 
+nsJSURI::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
+{
+    *aClassIDNoAlloc = kJSURICID;
+    return NS_OK;
+}
diff -r 8b3caddca8f5 dom/src/jsurl/nsJSProtocolHandler.h
--- a/dom/src/jsurl/nsJSProtocolHandler.h	Sat Nov 15 23:56:49 2008 -0800
+++ b/dom/src/jsurl/nsJSProtocolHandler.h	Sat Nov 22 15:25:48 2008 -0500
@@ -35,23 +35,35 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef nsJSProtocolHandler_h___
 #define nsJSProtocolHandler_h___
 
 #include "nsIProtocolHandler.h"
 #include "nsITextToSubURI.h"
+#include "nsIURI.h"
+#include "nsIMutable.h"
+#include "nsISerializable.h"
+#include "nsIClassInfo.h"
 
 #define NS_JSPROTOCOLHANDLER_CID                     \
 { /* bfc310d2-38a0-11d3-8cd3-0060b0fc14a3 */         \
     0xbfc310d2,                                      \
     0x38a0,                                          \
     0x11d3,                                          \
     {0x8c, 0xd3, 0x00, 0x60, 0xb0, 0xfc, 0x14, 0xa3} \
+}
+
+#define NS_JSURI_CID                                 \
+{ /* 58f089ee-512a-42d2-a935-d0c874128930 */         \
+    0x58f089ee,                                      \
+    0x512a,                                          \
+    0x42d2,                                          \
+    {0xa9, 0x35, 0xd0, 0xc8, 0x74, 0x12, 0x89, 0x30} \
 }
 
 #define NS_JSPROTOCOLHANDLER_CONTRACTID \
     NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX "javascript"
 
 
 class nsJSProtocolHandler : public nsIProtocolHandler
 {
@@ -73,9 +85,63 @@ protected:
 protected:
 
     nsresult EnsureUTF8Spec(const nsAFlatCString &aSpec, const char *aCharset, 
                             nsACString &aUTF8Spec);
 
     nsCOMPtr<nsITextToSubURI>  mTextToSubURI;
 };
 
+// Use an extra base object to avoid having to manually retype all the
+// nsIURI methods.  I wish we could just inherit from nsSimpleURI instead.
+class nsJSURI_base : public nsIURI,
+                     public nsIMutable
+{
+public:
+    nsJSURI_base(nsIURI* aSimpleURI) :
+        mSimpleURI(aSimpleURI)
+    {
+        mMutable = do_QueryInterface(mSimpleURI);
+        NS_ASSERTION(aSimpleURI && mMutable, "This isn't going to work out");
+    }
+    virtual ~nsJSURI_base() {}
+
+    // For use only from deserialization
+    nsJSURI_base() {}
+    
+    NS_FORWARD_NSIURI(mSimpleURI->)
+    NS_FORWARD_NSIMUTABLE(mMutable->)
+
+protected:
+    nsCOMPtr<nsIURI> mSimpleURI;
+    nsCOMPtr<nsIMutable> mMutable;
+};
+
+class nsJSURI : public nsJSURI_base,
+                public nsISerializable,
+                public nsIClassInfo
+{
+public:
+    nsJSURI(nsIURI* aBaseURI, nsIURI* aSimpleURI) :
+        nsJSURI_base(aSimpleURI), mBaseURI(aBaseURI)
+    {}
+    virtual ~nsJSURI() {}
+
+    // For use only from deserialization
+    nsJSURI() : nsJSURI_base() {}
+
+    NS_DECL_ISUPPORTS
+    NS_DECL_NSISERIALIZABLE
+    NS_DECL_NSICLASSINFO
+
+    // Override Clone() and Equals()
+    NS_IMETHOD Clone(nsIURI** aClone);
+    NS_IMETHOD Equals(nsIURI* aOther, PRBool *aResult);
+
+    nsIURI* GetBaseURI() const {
+        return mBaseURI;
+    }
+
+private:
+    nsCOMPtr<nsIURI> mBaseURI;
+};
+    
 #endif /* nsJSProtocolHandler_h___ */
diff -r 8b3caddca8f5 dom/src/threads/nsDOMThreadService.cpp
--- a/dom/src/threads/nsDOMThreadService.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/dom/src/threads/nsDOMThreadService.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -728,18 +728,18 @@ nsDOMThreadService::CreateJSContext()
   gJSRuntimeService->GetRuntime(&rt);
   NS_ENSURE_TRUE(rt, nsnull);
 
   JSAutoContextDestroyer cx(JS_NewContext(rt, 8192));
   NS_ENSURE_TRUE(cx, nsnull);
 
   JS_SetErrorReporter(cx, DOMWorkerErrorReporter);
 
-  JS_SetOperationCallback(cx, DOMWorkerOperationCallback,
-                          100 * JS_OPERATION_WEIGHT_BASE);
+  JS_SetOperationCallback(cx, DOMWorkerOperationCallback);
+  nsContentUtils::XPConnect()->SetWatchdogLimit(cx, PR_TicksPerSecond()/100);
 
   static JSSecurityCallbacks securityCallbacks = {
     nsDOMWorkerSecurityManager::JSCheckAccess,
     nsDOMWorkerSecurityManager::JSTranscodePrincipals,
     nsDOMWorkerSecurityManager::JSFindPrincipal
   };
 
   JS_SetContextSecurityCallbacks(cx, &securityCallbacks);
diff -r 8b3caddca8f5 dom/src/threads/nsDOMWorker.cpp
--- a/dom/src/threads/nsDOMWorker.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/dom/src/threads/nsDOMWorker.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -1020,17 +1020,17 @@ nsDOMWorker::CompileGlobalObject(JSConte
 
   NS_ASSERTION(!mScriptURL.IsEmpty(), "Must have a url here!");
 
   JSAutoRequest ar(aCx);
 
   NS_ASSERTION(!JS_GetGlobalObject(aCx), "Global object should be unset!");
 
   nsRefPtr<nsDOMWorkerScope> scope = new nsDOMWorkerScope(this);
-  NS_ENSURE_TRUE(scope, NS_ERROR_OUT_OF_MEMORY);
+  NS_ENSURE_TRUE(scope, PR_FALSE);
 
   nsISupports* scopeSupports = NS_ISUPPORTS_CAST(nsIWorkerScope*, scope);
 
   nsIXPConnect* xpc = nsContentUtils::XPConnect();
 
   nsCOMPtr<nsIXPConnectJSObjectHolder> globalWrapper;
   nsresult rv =
     xpc->InitClassesWithNewWrappedGlobal(aCx, scopeSupports,
diff -r 8b3caddca8f5 dom/src/threads/nsDOMWorkerScriptLoader.cpp
--- a/dom/src/threads/nsDOMWorkerScriptLoader.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/dom/src/threads/nsDOMWorkerScriptLoader.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -192,21 +192,21 @@ nsDOMWorkerScriptLoader::VerifyScripts(J
   NS_ASSERTION(aCx, "Shouldn't be null!");
 
   nsresult rv = NS_OK;
 
   for (PRUint32 index = 0; index < mScriptCount; index++) {
     ScriptLoadInfo& loadInfo = mLoadInfos[index];
     NS_ASSERTION(loadInfo.done, "Inconsistent state!");
 
-    if (NS_SUCCEEDED(loadInfo.result) && loadInfo.scriptObj) {
+    if (NS_SUCCEEDED(loadInfo.result) && loadInfo.scriptObj.ToJSObject()) {
       continue;
     }
 
-    NS_ASSERTION(!loadInfo.scriptObj, "Inconsistent state!");
+    NS_ASSERTION(!loadInfo.scriptObj.ToJSObject(), "Inconsistent state!");
 
     // Flag failure before worrying about whether or not to report an error.
     rv = NS_FAILED(loadInfo.result) ? loadInfo.result : NS_ERROR_FAILURE;
 
     // If loadInfo.result is a success code then the compiler probably reported
     // an error already. Also we don't really care about NS_BINDING_ABORTED
     // since that's the code we set when some other script had a problem and the
     // rest were canceled.
@@ -248,17 +248,17 @@ nsDOMWorkerScriptLoader::ExecuteScripts(
 
   // Now execute all the scripts.
   for (PRUint32 index = 0; index < mScriptCount; index++) {
     ScriptLoadInfo& loadInfo = mLoadInfos[index];
 
     JSAutoRequest ar(aCx);
 
     JSScript* script =
-      static_cast<JSScript*>(JS_GetPrivate(aCx, loadInfo.scriptObj));
+      static_cast<JSScript*>(JS_GetPrivate(aCx, loadInfo.scriptObj.ToJSObject()));
     NS_ASSERTION(script, "This shouldn't ever be null!");
 
     JSObject* global = mWorker->mGlobal ?
                        mWorker->mGlobal :
                        JS_GetGlobalObject(aCx);
     NS_ENSURE_STATE(global);
 
     // Because we may have nested calls to this function we don't want the
@@ -686,17 +686,17 @@ nsDOMWorkerScriptLoader::ScriptCompiler:
 nsDOMWorkerScriptLoader::ScriptCompiler::Run()
 {
   NS_ASSERTION(!NS_IsMainThread(), "Wrong thread!");
 
   if (mRevoked) {
     return NS_OK;
   }
 
-  NS_ASSERTION(!mScriptObj, "Already have a script object?!");
+  NS_ASSERTION(!mScriptObj.ToJSObject(), "Already have a script object?!");
   NS_ASSERTION(mScriptObj.IsHeld(), "Not held?!");
   NS_ASSERTION(!mScriptText.IsEmpty(), "Shouldn't have empty source here!");
 
   JSContext* cx = nsDOMThreadService::GetCurrentContext();
   NS_ENSURE_STATE(cx);
 
   JSAutoRequest ar(cx);
 
@@ -718,17 +718,17 @@ nsDOMWorkerScriptLoader::ScriptCompiler:
 
   JS_SetOptions(cx, oldOpts);
 
   if (!script) {
     return NS_ERROR_FAILURE;
   }
 
   mScriptObj = JS_NewScriptObject(cx, script);
-  NS_ENSURE_STATE(mScriptObj);
+  NS_ENSURE_STATE(mScriptObj.ToJSObject());
 
   return NS_OK;
 }
 
 nsDOMWorkerScriptLoader::
 ScriptLoaderDone::ScriptLoaderDone(nsDOMWorkerScriptLoader* aLoader,
                                    volatile PRBool* aDoneFlag)
 : ScriptLoaderRunnable(aLoader),
diff -r 8b3caddca8f5 dom/tests/mochitest/ajax/offline/Makefile.in
--- a/dom/tests/mochitest/ajax/offline/Makefile.in	Sat Nov 15 23:56:49 2008 -0800
+++ b/dom/tests/mochitest/ajax/offline/Makefile.in	Sat Nov 22 15:25:48 2008 -0500
@@ -55,16 +55,23 @@ _TEST_FILES	= \
 	test_missingFile.html \
 	test_noManifest.html \
 	test_simpleManifest.html \
 	test_identicalManifest.html \
 	test_changingManifest.html \
 	test_refetchManifest.html \
 	test_offlineIFrame.html \
 	test_bug445544.html \
+	test_offlineMode.html \
+	test_foreign.html \
+	test_fallback.html \
+	test_updatingManifest.html \
+	notonwhitelist.html \
+	onwhitelist.html \
+	onwhitelist.html^headers^ \
 	445544_part1.html \
 	445544_part2.html \
 	445544.cacheManifest \
 	445544.cacheManifest^headers^ \
 	test_bug460353.html \
 	460353_iframe_nomanifest.html \
 	460353_iframe_ownmanifest.html \
 	460353_iframe_samemanifest.html \
diff -r 8b3caddca8f5 dom/tests/mochitest/ajax/offline/test_offlineMode.html
--- a/dom/tests/mochitest/ajax/offline/test_offlineMode.html	Sat Nov 15 23:56:49 2008 -0800
+++ b/dom/tests/mochitest/ajax/offline/test_offlineMode.html	Sat Nov 22 15:25:48 2008 -0500
@@ -113,17 +113,17 @@ function finalize()
   }
   else
   {
     gImplicitWindow.close();
 
     ioserv.offline = false;
 
     OfflineTest.is(gGotExplicitVersion, 1, "Explicit entry loaded");
-    OfflineTest.is(gGotImplicitVersion == 1, "Bug 461325 - Implicit entry loaded");
+    OfflineTest.is(gGotImplicitVersion, 1, "Bug 461325 - Implicit entry loaded");
     OfflineTest.is(gGotDynamicVersion, 1, "Dynamic entry loaded");
     OfflineTest.ok(gGotOnError, "Got onerror event invoked by implicit page load in offline mode");
 
     OfflineTest.teardown();
     OfflineTest.finish();
   }
 }
 
diff -r 8b3caddca8f5 dom/tests/mochitest/bugs/Makefile.in
--- a/dom/tests/mochitest/bugs/Makefile.in	Sat Nov 15 23:56:49 2008 -0800
+++ b/dom/tests/mochitest/bugs/Makefile.in	Sat Nov 22 15:25:48 2008 -0500
@@ -41,16 +41,19 @@ VPATH		= @srcdir@
 VPATH		= @srcdir@
 relativesrcdir	= dom/tests/mochitest/bugs
 
 include $(DEPTH)/config/autoconf.mk
 include $(topsrcdir)/config/rules.mk
 
 _TEST_FILES	= \
 		test_bug42976.html \
+		test_bug49312.html \
+		iframe_bug49312.html \
+		test_bug132255.html \
 		test_bug159849.html \
 		test_bug291377.html \
 		test_bug308856.html \
 		test_bug317448.html \
 		test_bug327891.html \
 		test_bug333983.html \
 		test_bug335976.xhtml \
 		test_bug342448.html \
diff -r 8b3caddca8f5 dom/tests/mochitest/bugs/iframe_bug49312.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/tests/mochitest/bugs/iframe_bug49312.html	Sat Nov 22 15:25:48 2008 -0500
@@ -0,0 +1,7 @@
+<!DOCTYPE html>
+<script>
+  window.onload = function() {
+    var win = window.opener ? window.opener : window.parent;
+    win.subframeLoaded(window);
+  }
+</script>
diff -r 8b3caddca8f5 dom/tests/mochitest/bugs/test_bug132255.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/tests/mochitest/bugs/test_bug132255.html	Sat Nov 22 15:25:48 2008 -0500
@@ -0,0 +1,39 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=132255
+-->
+<head>
+  <title>Test for Bug 132255</title>
+  <script type="application/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
+  <base href="http://localhost:8888/tests/dom/tests/mochitest/">
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=132255">Mozilla Bug 132255</a>
+<p id="display">
+  <iframe src="javascript:'<a href=\'foo.html\'>test-anchor</a>'"></iframe>
+  <iframe src="javascript:'<base href=\'http://example.com/\'><a href=\'foo.html\'>test-anchor</a>'"></iframe>
+</p>
+<div id="content" style="display: none">
+  
+</div>
+<pre id="test">
+<script type="application/javascript">
+
+/** Test for Bug 132255 **/
+SimpleTest.waitForExplicitFinish();
+addLoadEvent(function() {
+  is(window.frames[0].document.links[0].href,
+     window.location.href.replace(/bugs\/test_bug132255\.html/, "foo.html"),
+     "Unexpected anchor href");
+  is(window.frames[1].document.links[0].href,
+     "http://example.com/foo.html",
+     "Unexpected anchor href when base set");
+})
+addLoadEvent(SimpleTest.finish);
+</script>
+</pre>
+</body>
+</html>
diff -r 8b3caddca8f5 dom/tests/mochitest/bugs/test_bug49312.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/tests/mochitest/bugs/test_bug49312.html	Sat Nov 22 15:25:48 2008 -0500
@@ -0,0 +1,48 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=49312
+-->
+<head>
+  <title>Test for Bug 49312</title>
+  <script type="application/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
+  <script>
+    // Hack to set things up so that parent.fakeOpener works the same way for
+    // both test subframes.
+    var framesToLoad = 2;
+    function subframeLoaded(win) {
+      is(win.location.href
+            .replace(/iframe_bug49312\.html$/, "test_bug49312.html"),
+         window.location.href,
+         "Unexpected subframe href");
+      if (win == opened) {
+        opened.close();
+      }
+      if (--framesToLoad == 0) {
+        SimpleTest.finish();
+      }
+    }
+         
+  </script>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=49312">Mozilla Bug 49312</a>
+<p id="display">
+  <iframe src="javascript:'<script>location=\'iframe_bug49312.html\'</script>'"></iframe>
+</p>
+<div id="content" style="display: none">
+  
+</div>
+<pre id="test">
+<script type="application/javascript">
+
+/** Test for Bug 49312 **/
+SimpleTest.waitForExplicitFinish();
+var opened = window.open("javascript:'<script>location=\\\'iframe_bug49312.html\\\'</" + "script>'", "", "width=100,height=100")
+
+</script>
+</pre>
+</body>
+</html>
diff -r 8b3caddca8f5 dom/tests/unit/test_bug465752.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/tests/unit/test_bug465752.js	Sat Nov 22 15:25:48 2008 -0500
@@ -0,0 +1,61 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *      Boris Zbarsky <bzbarsky@mit.edu>.
+ *
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK *****
+ */
+
+function run_test()
+{
+  const ios = Components.classes["@mozilla.org/network/io-service;1"]
+                        .getService(Components.interfaces.nsIIOService);
+  const str = "javascript:10";
+  var uri = ios.newURI(str, null, null);
+  var uri2 = ios.newURI(str, null, null);
+  const str2 = "http://example.org";
+  var uri3 = ios.newURI(str2, null, null);
+  do_check_true(uri.equals(uri));
+  do_check_true(uri.equals(uri2));
+  do_check_true(uri2.equals(uri));
+  do_check_true(uri2.equals(uri2));
+  do_check_false(uri3.equals(uri2));
+  do_check_false(uri2.equals(uri3));
+
+  var simple = Components.classes["@mozilla.org/network/simple-uri;1"]
+                         .createInstance(Components.interfaces.nsIURI);
+  simple.spec = str;
+  do_check_eq(simple.spec, uri.spec);
+  do_check_false(simple.equals(uri));
+  do_check_false(uri.equals(simple));
+}
diff -r 8b3caddca8f5 editor/libeditor/text/nsTextEditRules.cpp
--- a/editor/libeditor/text/nsTextEditRules.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/editor/libeditor/text/nsTextEditRules.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -580,16 +580,18 @@ nsTextEditRules::WillInsertText(PRInt32 
   // So find out what we're expected to do:
   if (nsIPlaintextEditor::eEditorSingleLineMask & mFlags)
   {
     nsAutoString tString(*outString);
 
     switch(mEditor->mNewlineHandling)
     {
     case nsIPlaintextEditor::eNewlinesReplaceWithSpaces:
+      // Strip trailing newlines first so we don't wind up with trailing spaces
+      tString.Trim(CRLF, PR_FALSE, PR_TRUE);
       tString.ReplaceChar(CRLF, ' ');
       break;
     case nsIPlaintextEditor::eNewlinesStrip:
       tString.StripChars(CRLF);
       break;
     case nsIPlaintextEditor::eNewlinesPasteToFirst:
     default:
       {
diff -r 8b3caddca8f5 extensions/reporter/resources/content/reporter/reporterOverlay.xul
--- a/extensions/reporter/resources/content/reporter/reporterOverlay.xul	Sat Nov 15 23:56:49 2008 -0800
+++ b/extensions/reporter/resources/content/reporter/reporterOverlay.xul	Sat Nov 22 15:25:48 2008 -0500
@@ -40,33 +40,32 @@
 
 <!DOCTYPE overlay SYSTEM "chrome://reporter/locale/reporterOverlay.dtd">
 
 <overlay id="reporterMenuOverlay"
          xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
 
   <script type="application/x-javascript" src="chrome://reporter/content/reporterOverlay.js"/>
 
-  <!-- Firefox -->
+  <!-- Firefox and SeaMonkey -->
   <broadcasterset id="mainBroadcasterSet">
     <broadcaster id="reporterItemsBroadcaster" disabled="true"/>
   </broadcasterset>
+
+  <!-- Firefox -->
   <menupopup id="menu_HelpPopup">
     <menuitem id="menu_HelpPopup_reportertoolmenu" 
               label="&reporterMenu2.title;" 
               accesskey="&reporterMenu.accesskey;"
               insertafter="releaseNotes"
               observes="reporterItemsBroadcaster"
               oncommand="loadReporterWizard()"/>
   </menupopup>
 
   <!-- SeaMonkey -->
-  <broadcasterset id="navBroadcasters">
-    <broadcaster id="reporterItemsBroadcaster" disabled="true"/>
-  </broadcasterset>
   <menupopup id="helpPopup">
     <menuseparator insertbefore="menu_HelpAboutSeparator"/>
     <menuitem id="helpPopup_reportertoolmenu"
               label="&reporterMenu2.title;"
               accesskey="&reporterMenu.accesskey;"
               insertbefore="menu_HelpAboutSeparator"
               oncommand="loadReporterWizard()"
               observes="reporterItemsBroadcaster"/>
diff -r 8b3caddca8f5 js/src/builtins.tbl
--- a/js/src/builtins.tbl	Sat Nov 15 23:56:49 2008 -0800
+++ b/js/src/builtins.tbl	Sat Nov 22 15:25:48 2008 -0500
@@ -83,15 +83,16 @@ BUILTIN4(extern, BOOL,      js_Any_setel
 BUILTIN4(extern, BOOL,      js_Any_setelem, CONTEXT, OBJECT, INT32, JSVAL,      0, 0)
 BUILTIN3(extern, OBJECT,    js_FastValueToIterator, CONTEXT, UINT32, JSVAL,     0, 0)
 BUILTIN2(extern, JSVAL,     js_FastCallIteratorNext, CONTEXT, OBJECT,           0, 0)
 BUILTIN2(FRIEND, BOOL,      js_CloseIterator, CONTEXT, JSVAL,                   0, 0)
 BUILTIN2(extern, SIDEEXIT,  js_CallTree, INTERPSTATE, FRAGMENT,                 0, 0)
 BUILTIN2(extern, OBJECT,    js_FastNewObject, CONTEXT, OBJECT,                  0, 0)
 BUILTIN3(extern, BOOL,      js_AddProperty, CONTEXT, OBJECT, SCOPEPROP,         0, 0)
 BUILTIN3(extern, BOOL,      js_HasNamedProperty, CONTEXT, OBJECT, STRING,       0, 0)
+BUILTIN3(extern, BOOL,      js_HasNamedPropertyInt32, CONTEXT, OBJECT, INT32,   0, 0)
 BUILTIN3(extern, JSVAL,     js_CallGetter, CONTEXT, OBJECT, SCOPEPROP,          0, 0)
 BUILTIN2(extern, STRING,    js_TypeOfObject, CONTEXT, OBJECT,                   1, 1)
 BUILTIN2(extern, STRING,    js_TypeOfBoolean, CONTEXT, INT32,                   1, 1)
 BUILTIN2(extern, DOUBLE,    js_BooleanOrUndefinedToNumber, CONTEXT, INT32,      1, 1)
 BUILTIN2(extern, STRING,    js_BooleanOrUndefinedToString, CONTEXT, INT32,      1, 1)
 BUILTIN2(extern, STRING,    js_ObjectToString, CONTEXT, OBJECT,                 0, 0)
 BUILTIN1(extern, OBJECT,    js_Arguments, CONTEXT,                              0, 0)
diff -r 8b3caddca8f5 js/src/js.cpp
--- a/js/src/js.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/js/src/js.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -99,28 +99,41 @@ typedef enum JSShellExitCode {
 
 size_t gStackChunkSize = 8192;
 
 /* Assume that we can not use more than 5e5 bytes of C stack by default. */
 static size_t gMaxStackSize = 500000;
 static jsuword gStackBase;
 
 static size_t gScriptStackQuota = JS_DEFAULT_SCRIPT_STACK_QUOTA;
-
+#if JS_HAS_OPERATION_COUNT
 static JSBool gEnableBranchCallback = JS_FALSE;
+#endif
 static uint32 gBranchCount;
 static uint32 gBranchLimit;
 
 int gExitCode = 0;
 JSBool gQuitting = JS_FALSE;
 FILE *gErrFile = NULL;
 FILE *gOutFile = NULL;
 
 static JSBool reportWarnings = JS_TRUE;
 static JSBool compileOnly = JS_FALSE;
+
+#if !JS_HAS_OPERATION_COUNT
+/*
+ * Variables to support watchdog thread.
+ */
+static PRLock *gWatchdogLock;
+static PRCondVar *gWatchdogWakeup;
+static PRBool gWatchdogRunning;
+static PRThread *gWatchdogThread;
+static PRIntervalTime gCurrentInterval;
+static PRIntervalTime gWatchdogLimit;
+#endif
 
 typedef enum JSShellErrNum {
 #define MSG_DEF(name, number, count, exception, format) \
     name = number,
 #include "jsshell.msg"
 #undef MSG_DEF
     JSShellErr_Limit
 #undef MSGDEF
@@ -164,16 +177,17 @@ GetLine(JSContext *cx, char *bufp, FILE 
         fflush(gOutFile);
         if (!fgets(line, sizeof line, file))
             return JS_FALSE;
         strcpy(bufp, line);
     }
     return JS_TRUE;
 }
 
+#if JS_HAS_OPERATION_COUNT
 static JSBool
 my_BranchCallback(JSContext *cx, JSScript *script)
 {
     if (++gBranchCount == gBranchLimit) {
         if (script) {
             if (script->filename)
                 fprintf(gErrFile, "%s:", script->filename);
             fprintf(gErrFile, "%u: script branch callback (%u callbacks)\n",
@@ -192,16 +206,142 @@ my_BranchCallback(JSContext *cx, JSScrip
             JS_MaybeGC(cx);
 #ifdef JS_THREADSAFE
         else
             JS_YieldRequest(cx);
     }
 #endif
     return JS_TRUE;
 }
+#endif
+
+#if !JS_HAS_OPERATION_COUNT
+static void
+ShutdownWatchdog()
+{
+    PRThread *t;
+
+    PR_Lock(gWatchdogLock);
+    gWatchdogRunning = PR_FALSE;
+    t = gWatchdogThread;
+    gWatchdogThread = NULL;
+    PR_NotifyCondVar(gWatchdogWakeup);
+    PR_Unlock(gWatchdogLock);
+    if (t)
+        PR_JoinThread(t);
+}
+
+static void
+WakeupWatchdog()
+{
+    PR_Lock(gWatchdogLock);
+    if (gWatchdogThread && gWatchdogLimit &&
+        (gCurrentInterval == PR_INTERVAL_NO_TIMEOUT ||
+         gCurrentInterval > gWatchdogLimit)) {
+        PR_NotifyCondVar(gWatchdogWakeup);
+    }
+    PR_Unlock(gWatchdogLock);
+
+}
+
+static JSBool
+ShellOperationCallback(JSContext *cx)
+{
+    if (gWatchdogLimit) {
+        fprintf(stderr, "Error: Script is running too long\n");
+        return JS_FALSE;
+    }
+    return JS_TRUE;
+}
+
+static void
+WatchdogMain(void *arg)
+{
+    JSRuntime *rt = (JSRuntime *) arg;
+    PRStatus status;
+    PRBool isRunning;
+
+    do {
+        JSContext *iter = NULL;
+        JSContext *acx;
+        JSBool isContextRunning = JS_FALSE;
+        PRIntervalTime ct = PR_IntervalNow();
+
+        PR_Lock(gWatchdogLock);
+        if (gWatchdogLimit) {
+            JS_LOCK_GC(rt);
+            while ((acx = js_ContextIterator(rt, JS_FALSE, &iter))) {
+                if (acx->requestDepth) {
+                    if (ct - acx->startTime > gWatchdogLimit)
+                        JS_TriggerOperationCallback(acx);
+                    if (!isContextRunning)
+                        isContextRunning = JS_TRUE;
+                }
+            }
+            JS_UNLOCK_GC(rt);
+        }
+        gCurrentInterval = (isContextRunning && gWatchdogLimit)
+                           ? gWatchdogLimit
+                           : PR_INTERVAL_NO_TIMEOUT;
+        if (gWatchdogRunning)
+            status = PR_WaitCondVar(gWatchdogWakeup, gCurrentInterval);
+        isRunning = gWatchdogRunning;
+        PR_Unlock(gWatchdogLock);
+    } while (isRunning && status == PR_SUCCESS);
+}
+
+/*
+ * Get the watchdog limit associated with the watchdog callback.
+ */
+static PRIntervalTime
+GetWatchdogLimit(JSContext *cx)
+{
+    return gWatchdogLimit;
+}
+
+/*
+ * Change the watchdog limit associated with the watchdog callback. This API
+ * function may be called only when the result of JS_GetOperationCallback(cx)
+ * is not null.
+ */
+static JSBool
+SetWatchdogLimit(JSContext *cx, PRIntervalTime newWatchdogLimit)
+{
+    if (newWatchdogLimit == gWatchdogLimit)
+        return JS_TRUE;
+
+    gWatchdogLimit = newWatchdogLimit;
+
+    /*
+     * Start a new watchdog thread if it has not been started. If it has been
+     * started wake up the thread and cause the watchdog rescheduling.
+     */
+    PR_Lock(gWatchdogLock);
+    if (!gWatchdogThread) {
+        gWatchdogRunning = PR_TRUE;
+        gWatchdogThread =
+            PR_CreateThread(PRThreadType(PR_USER_THREAD),
+                            WatchdogMain,
+                            cx->runtime,
+                            PRThreadPriority(PR_PRIORITY_NORMAL),
+                            PRThreadScope(PR_LOCAL_THREAD),
+                            PRThreadState(PR_JOINABLE_THREAD),
+                            0);
+    }
+    PR_Unlock(gWatchdogLock);
+    if (!gWatchdogThread) {
+        JS_ReportError(cx, "Failed to create watchdog thread");
+        return JS_FALSE;
+    }
+
+    WakeupWatchdog();
+    return JS_TRUE;
+}
+
+#endif
 
 static void
 SetContextOptions(JSContext *cx)
 {
     jsuword stackLimit;
 
     if (gMaxStackSize == 0) {
         /*
@@ -212,20 +352,22 @@ SetContextOptions(JSContext *cx)
 #if JS_STACK_GROWTH_DIRECTION > 0
         stackLimit = gStackBase + gMaxStackSize;
 #else
         stackLimit = gStackBase - gMaxStackSize;
 #endif
     }
     JS_SetThreadStackLimit(cx, stackLimit);
     JS_SetScriptStackQuota(cx, gScriptStackQuota);
+#if JS_HAS_OPERATION_COUNT
     if (gEnableBranchCallback) {
         JS_SetBranchCallback(cx, my_BranchCallback);
         JS_ToggleOptions(cx, JSOPTION_NATIVE_BRANCH_CALLBACK);
     }
+#endif
 }
 
 static void
 Process(JSContext *cx, JSObject *obj, char *filename, JSBool forceTTY)
 {
     JSBool ok, hitEOF;
     JSScript *script;
     jsval result;
@@ -375,17 +517,19 @@ ProcessArgs(JSContext *cx, JSObject *obj
      * have to keep the option logic here and in the second for loop in sync.
      */
     for (i = 0; i < argc; i++) {
         if (argv[i][0] != '-' || argv[i][1] == '\0') {
             ++i;
             break;
         }
         switch (argv[i][1]) {
+#if JS_HAS_OPERATION_COUNT
           case 'b':
+#endif
           case 'c':
           case 'f':
           case 'e':
           case 'v':
           case 'S':
 #ifdef JS_GC_ZEAL
           case 'Z':
 #endif
@@ -466,17 +610,17 @@ ProcessArgs(JSContext *cx, JSObject *obj
 #if defined(JS_TRACER) && defined(DEBUG)
 extern struct JSClass jitstats_class;
 extern void js_InitJITStatsClass(JSContext *cx, JSObject *glob);
             js_InitJITStatsClass(cx, JS_GetGlobalObject(cx));
             JS_DefineObject(cx, JS_GetGlobalObject(cx), "tracemonkey",
                             &jitstats_class, NULL, 0);
 #endif
             break;
-            
+
         case 'o':
             if (++i == argc)
                 return usage();
 
             for (j = 0; js_options[j].name; ++j) {
                 if (strcmp(js_options[j].name, argv[i]) == 0) {
                     JS_ToggleOptions(cx, js_options[j].flag);
                     break;
@@ -496,20 +640,22 @@ extern void js_InitJITStatsClass(JSConte
                 if (!JS_SetPrototype(cx, gobj, obj))
                     return JS_FALSE;
                 JS_SetParent(cx, gobj, NULL);
                 JS_SetGlobalObject(cx, gobj);
                 obj = gobj;
             }
             break;
 
+#if JS_HAS_OPERATION_COUNT
         case 'b':
             gBranchLimit = atoi(argv[++i]);
             gEnableBranchCallback = (gBranchLimit != 0);
             break;
+#endif
 
         case 'c':
             /* set stack chunk size */
             gStackChunkSize = atoi(argv[++i]);
             break;
 
         case 'f':
             if (++i == argc)
@@ -1446,17 +1592,17 @@ static JSBool
 static JSBool
 DisassFile(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
     JSString *str;
     const char *filename;
     JSScript *script;
     JSBool ok;
     uint32 oldopts;
-    
+
     if (!argc)
         return JS_TRUE;
 
     str = JS_ValueToString(cx, argv[0]);
     if (!str)
         return JS_FALSE;
     argv[0] = STRING_TO_JSVAL(str);
 
@@ -1466,17 +1612,17 @@ DisassFile(JSContext *cx, JSObject *obj,
     script = JS_CompileFile(cx, obj, filename);
     JS_SetOptions(cx, oldopts);
     if (!script)
         return JS_FALSE;
 
     obj = JS_NewScriptObject(cx, script);
     if (!obj)
         return JS_FALSE;
-    
+
     *rval = OBJECT_TO_JSVAL(obj); /* I like to root it, root it. */
     ok = Disassemble(cx, obj, 1, rval, rval); /* gross, but works! */
     *rval = JSVAL_VOID;
 
     return ok;
 }
 
 static JSBool
@@ -2119,16 +2265,48 @@ TestUTF8(JSContext *cx, JSObject *obj, u
 
 static JSBool
 ThrowError(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
     JS_ReportError(cx, "This is an error");
     return JS_FALSE;
 }
 
+#if !JS_HAS_OPERATION_COUNT
+
+static JSBool
+WatchdogInterval(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    if (argc > 1) {
+        JS_ReportError(cx, "Wrong number of arguments");
+        return JS_FALSE;
+    }
+
+    if (argc == 0)
+        return JS_NewDoubleValue(cx, GetWatchdogLimit(cx), rval);
+
+    jsdouble interval;
+    if (!JS_ValueToNumber(cx, argv[0], &interval))
+        return JS_FALSE;
+
+    /* NB: The next condition take negative values and NaNs into account. */
+    if (!(interval >= 0.0)) {
+        JS_ReportError(cx, "Negative or NaN argument value");
+        return JS_FALSE;
+    }
+    if (interval > 1800.0) {
+        JS_ReportError(cx, "Excessive argument value");
+        return JS_FALSE;
+    }
+
+    return SetWatchdogLimit(cx, (PRIntervalTime) (interval * PR_TicksPerSecond()));
+}
+
+#endif
+
 #define LAZY_STANDARD_CLASSES
 
 /* A class for easily testing the inner/outer object callbacks. */
 typedef struct ComplexObject {
     JSBool isInner;
     JSBool frozen;
     JSObject *inner;
     JSObject *outer;
@@ -2679,22 +2857,24 @@ Scatter(JSContext *cx, uintN argc, jsval
     jsuint i;
     jsuint n;  /* number of threads */
     JSObject *inArr;
     JSObject *arr;
     ScatterData sd;
     JSBool ok;
     jsrefcount rc;
 
+#if JS_HAS_OPERATION_COUNT
     if (!gEnableBranchCallback) {
         /* Enable the branch callback, for periodic scope-sharing. */
         gEnableBranchCallback = JS_TRUE;
         JS_SetBranchCallback(cx, my_BranchCallback);
         JS_ToggleOptions(cx, JSOPTION_NATIVE_BRANCH_CALLBACK);
     }
+#endif
 
     sd.lock = NULL;
     sd.cvar = NULL;
     sd.results = NULL;
     sd.threads = NULL;
     sd.status = SCATTER_WAIT;
 
     if (argc == 0 || JSVAL_IS_PRIMITIVE(JS_ARGV(cx, vp)[0])) {
@@ -2860,16 +3040,19 @@ static JSFunctionSpec shell_functions[] 
     JS_FS("trap",           Trap,           3,0,0),
     JS_FS("untrap",         Untrap,         2,0,0),
     JS_FS("line2pc",        LineToPC,       0,0,0),
     JS_FS("pc2line",        PCToLine,       0,0,0),
     JS_FN("stackQuota",     StackQuota,     0,0),
     JS_FS("stringsAreUTF8", StringsAreUTF8, 0,0,0),
     JS_FS("testUTF8",       TestUTF8,       1,0,0),
     JS_FS("throwError",     ThrowError,     0,0,0),
+#if !JS_HAS_OPERATION_COUNT
+    JS_FS("watchint",       WatchdogInterval,     1,0,0),
+#endif
 #ifdef DEBUG
     JS_FS("dis",            Disassemble,    1,0,0),
     JS_FS("disfile",        DisassFile,     1,0,0),
     JS_FS("dissrc",         DisassWithSrc,  1,0,0),
     JS_FN("dumpHeap",       DumpHeap,       0,0),
     JS_FS("notes",          Notes,          1,0,0),
     JS_FS("tracing",        Tracing,        0,0,0),
     JS_FS("stats",          DumpStats,      1,0,0),
@@ -2941,16 +3124,21 @@ static const char *const shell_help_mess
 "trap([fun, [pc,]] exp)   Trap bytecode execution",
 "untrap(fun[, pc])        Remove a trap",
 "line2pc([fun,] line)     Map line number to PC",
 "pc2line(fun[, pc])       Map PC to line number",
 "stackQuota([number])     Query/set script stack quota",
 "stringsAreUTF8()         Check if strings are UTF-8 encoded",
 "testUTF8(mode)           Perform UTF-8 tests (modes are 1 to 4)",
 "throwError()             Throw an error from JS_ReportError",
+#if !JS_HAS_OPERATION_COUNT
+"watchint(interval)       Set watchdog interval to the specified number"
+" of seconds. If parameters are not specified it returns watchdog interval"
+" in seconds",
+#endif
 #ifdef DEBUG
 "dis([fun])               Disassemble functions into bytecodes",
 "disfile('foo.js')        Disassemble script file into bytecodes",
 "dissrc([fun])            Disassemble functions with source lines",
 "dumpHeap([fileName[, start[, toFind[, maxDepth[, toIgnore]]]]])\n"
 "  Interface to JS_DumpHeap with output sent to file",
 "notes([fun])             Show source notes for functions",
 "tracing([toggle])        Turn tracing on or off",
@@ -3882,17 +4070,24 @@ snarf(JSContext *cx, JSObject *obj, uint
 
 static JSBool
 ContextCallback(JSContext *cx, uintN contextOp)
 {
     if (contextOp == JSCONTEXT_NEW) {
         JS_SetErrorReporter(cx, my_ErrorReporter);
         JS_SetVersion(cx, JSVERSION_LATEST);
         SetContextOptions(cx);
-    }
+#if !JS_HAS_OPERATION_COUNT
+        JS_SetOperationCallback(cx, ShellOperationCallback);
+    } else if (contextOp == JSCONTEXT_REQUEST_START &&
+               cx->runtime->state != JSRTS_LANDING) {
+        WakeupWatchdog();
+#endif
+    }
+
     return JS_TRUE;
 }
 
 int
 main(int argc, char **argv, char **envp)
 {
     int stackDummy;
     JSRuntime *rt;
@@ -3929,16 +4124,28 @@ main(int argc, char **argv, char **envp)
     gOutFile = stdout;
 
     argc--;
     argv++;
 
     rt = JS_NewRuntime(64L * 1024L * 1024L);
     if (!rt)
         return 1;
+
+#if !JS_HAS_OPERATION_COUNT
+    gWatchdogLock = JS_NEW_LOCK();
+    if (!gWatchdogLock)
+        return 1;
+    gWatchdogWakeup = JS_NEW_CONDVAR(gWatchdogLock);
+    if (!gWatchdogWakeup)
+        return 1;
+    gWatchdogLimit = 0;
+    gWatchdogThread = NULL;
+#endif
+
     JS_SetContextCallback(rt, ContextCallback);
 
     cx = JS_NewContext(rt, gStackChunkSize);
     if (!cx)
         return 1;
 
 #ifdef JS_THREADSAFE
     JS_BeginRequest(cx);
@@ -4038,13 +4245,25 @@ main(int argc, char **argv, char **envp)
         JSD_DebuggerOff(jsdc);
     }
 #endif  /* JSDEBUGGER */
 
 #ifdef JS_THREADSAFE
     JS_EndRequest(cx);
 #endif
 
+#if !JS_HAS_OPERATION_COUNT
+    ShutdownWatchdog();
+#endif
+
+#if !JS_HAS_OPERATION_COUNT
+    if (gWatchdogWakeup)
+        JS_DESTROY_CONDVAR(gWatchdogWakeup);
+    if (gWatchdogLock)
+        JS_DESTROY_LOCK(gWatchdogLock);
+#endif
+
     JS_DestroyContext(cx);
     JS_DestroyRuntime(rt);
     JS_ShutDown();
+
     return result;
 }
diff -r 8b3caddca8f5 js/src/jsapi.cpp
--- a/js/src/jsapi.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/js/src/jsapi.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -898,36 +898,50 @@ JS_SetRuntimePrivate(JSRuntime *rt, void
     rt->data = data;
 }
 
 JS_PUBLIC_API(void)
 JS_BeginRequest(JSContext *cx)
 {
 #ifdef JS_THREADSAFE
     JSRuntime *rt;
+    JSContextCallback cxCallback;
 
     JS_ASSERT(cx->thread->id == js_CurrentThreadId());
     if (!cx->requestDepth) {
         JS_ASSERT(cx->gcLocalFreeLists == &js_GCEmptyFreeListSet);
 
         /* Wait until the GC is finished. */
         rt = cx->runtime;
+#if !JS_HAS_OPERATION_COUNT
+        cx->startTime = PR_IntervalNow();
+#endif
         JS_LOCK_GC(rt);
 
         /* NB: we use cx->thread here, not js_GetCurrentThread(). */
         if (rt->gcThread != cx->thread) {
             while (rt->gcLevel > 0)
                 JS_AWAIT_GC_DONE(rt);
         }
 
         /* Indicate that a request is running. */
         rt->requestCount++;
         cx->requestDepth = 1;
         cx->outstandingRequests++;
         JS_UNLOCK_GC(rt);
+
+        cxCallback = cx->runtime->cxCallback;
+        if (cxCallback) {
+#ifdef DEBUG
+            JSBool callbackStatus =
+#endif
+                cxCallback(cx, JSCONTEXT_REQUEST_START);
+            JS_ASSERT(callbackStatus);
+        }
+
         return;
     }
     cx->requestDepth++;
     cx->outstandingRequests++;
 #endif
 }
 
 JS_PUBLIC_API(void)
@@ -978,17 +992,19 @@ JS_EndRequest(JSContext *cx)
 
         js_RevokeGCLocalFreeLists(cx);
 
         /* Give the GC a chance to run if this was the last request running. */
         JS_ASSERT(rt->requestCount > 0);
         rt->requestCount--;
         if (rt->requestCount == 0)
             JS_NOTIFY_REQUEST_DONE(rt);
-
+#if !JS_HAS_OPERATION_COUNT
+        cx->startTime = 0;
+#endif
         JS_UNLOCK_GC(rt);
         return;
     }
 
     cx->requestDepth--;
     cx->outstandingRequests--;
 #endif
 }
@@ -3125,17 +3141,17 @@ DefinePropertyById(JSContext *cx, JSObje
                    uintN flags, intN tinyid)
 {
     if (flags != 0 && OBJ_IS_NATIVE(obj)) {
         JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED | JSRESOLVE_DECLARING);
         return js_DefineNativeProperty(cx, obj, id, value, getter, setter,
                                        attrs, flags, tinyid, NULL);
     }
     return OBJ_DEFINE_PROPERTY(cx, obj, id, value, getter, setter, attrs,
-                               NULL);   
+                               NULL);
 }
 
 static JSBool
 DefineProperty(JSContext *cx, JSObject *obj, const char *name, jsval value,
                JSPropertyOp getter, JSPropertyOp setter, uintN attrs,
                uintN flags, intN tinyid)
 {
     jsid id;
@@ -3802,17 +3818,17 @@ JS_HasUCProperty(JSContext *cx, JSObject
                  const jschar *name, size_t namelen,
                  JSBool *vp)
 {
     JSBool ok;
     JSObject *obj2;
     JSProperty *prop;
 
     CHECK_REQUEST(cx);
-    ok = LookupUCProperty(cx, obj, name, namelen, 
+    ok = LookupUCProperty(cx, obj, name, namelen,
                           JSRESOLVE_QUALIFIED | JSRESOLVE_DETECTING,
                           &obj2, &prop);
     if (ok) {
         *vp = (prop != NULL);
         if (prop)
             OBJ_DROP_PROPERTY(cx, obj2, prop);
     }
     return ok;
@@ -5239,16 +5255,17 @@ JS_CallFunctionValue(JSContext *cx, JSOb
     JSBool ok;
 
     CHECK_REQUEST(cx);
     ok = js_InternalCall(cx, obj, fval, argc, argv, rval);
     LAST_FRAME_CHECKS(cx, ok);
     return ok;
 }
 
+#if JS_HAS_OPERATION_COUNT
 JS_PUBLIC_API(void)
 JS_SetOperationCallback(JSContext *cx, JSOperationCallback callback,
                         uint32 operationLimit)
 {
     JS_ASSERT(callback);
     JS_ASSERT(operationLimit <= JS_MAX_OPERATION_LIMIT);
     JS_ASSERT(operationLimit > 0);
 
@@ -5313,16 +5330,43 @@ JS_SetBranchCallback(JSContext *cx, JSBr
     if (cb) {
         cx->operationCount = JSOW_SCRIPT_JUMP;
         cx->operationLimit = JSOW_SCRIPT_JUMP;
         cx->operationCallback = (JSOperationCallback) cb;
     } else {
         JS_ClearOperationCallback(cx);
     }
     return oldcb;
+}
+#else
+
+JS_PUBLIC_API(void)
+JS_SetOperationCallback(JSContext *cx, JSOperationCallback callback)
+{
+    cx->operationCallback = callback;
+}
+
+JS_PUBLIC_API(void)
+JS_ClearOperationCallback(JSContext *cx)
+{
+    cx->operationCallback = NULL;
+}
+
+JS_PUBLIC_API(JSOperationCallback)
+JS_GetOperationCallback(JSContext *cx)
+{
+    return cx->operationCallback;
+}
+
+#endif
+
+JS_PUBLIC_API(void)
+JS_TriggerOperationCallback(JSContext *cx)
+{
+    cx->operationCount = 0;
 }
 
 JS_PUBLIC_API(JSBool)
 JS_IsRunning(JSContext *cx)
 {
     return cx->fp != NULL;
 }
 
diff -r 8b3caddca8f5 js/src/jsapi.h
--- a/js/src/jsapi.h	Sat Nov 15 23:56:49 2008 -0800
+++ b/js/src/jsapi.h	Sat Nov 22 15:25:48 2008 -0500
@@ -40,16 +40,17 @@
 
 #ifndef jsapi_h___
 #define jsapi_h___
 /*
  * JavaScript API.
  */
 #include <stddef.h>
 #include <stdio.h>
+#include "jsversion.h"
 #include "js-config.h"
 #include "jspubtd.h"
 #include "jsutil.h"
 
 JS_BEGIN_EXTERN_C
 
 /*
  * Type tags stored in the low bits of a jsval.
@@ -2161,16 +2162,23 @@ extern JS_PUBLIC_API(JSBool)
 extern JS_PUBLIC_API(JSBool)
 JS_CallFunctionName(JSContext *cx, JSObject *obj, const char *name, uintN argc,
                     jsval *argv, jsval *rval);
 
 extern JS_PUBLIC_API(JSBool)
 JS_CallFunctionValue(JSContext *cx, JSObject *obj, jsval fval, uintN argc,
                      jsval *argv, jsval *rval);
 
+extern JS_PUBLIC_API(void)
+JS_ClearOperationCallback(JSContext *cx);
+
+extern JS_PUBLIC_API(JSOperationCallback)
+JS_GetOperationCallback(JSContext *cx);
+
+#if JS_HAS_OPERATION_COUNT
 /*
  * The maximum value of the operation limit to pass to JS_SetOperationCallback
  * and JS_SetOperationLimit.
  */
 #define JS_MAX_OPERATION_LIMIT ((uint32) 0x7FFFFFFF)
 
 #define JS_OPERATION_WEIGHT_BASE 4096
 
@@ -2184,22 +2192,16 @@ JS_CallFunctionValue(JSContext *cx, JSOb
  *
  *   100 * JS_OPERATION_WEIGHT_BASE
  *
  * as a value for operationLimit.
  */
 extern JS_PUBLIC_API(void)
 JS_SetOperationCallback(JSContext *cx, JSOperationCallback callback,
                         uint32 operationLimit);
-
-extern JS_PUBLIC_API(void)
-JS_ClearOperationCallback(JSContext *cx);
-
-extern JS_PUBLIC_API(JSOperationCallback)
-JS_GetOperationCallback(JSContext *cx);
 
 /*
  * Get the operation limit associated with the operation callback. This API
  * function may be called only when the result of JS_GetOperationCallback(cx)
  * is not null.
  */
 extern JS_PUBLIC_API(uint32)
 JS_GetOperationLimit(JSContext *cx);
@@ -2218,16 +2220,28 @@ JS_SetOperationLimit(JSContext *cx, uint
  *   JS_SetOperationCallback(cx, callback, 4096, NULL);
  *
  * except that the callback will not be called from a long-running native
  * function when JSOPTION_NATIVE_BRANCH_CALLBACK is not set and the top-most
  * frame is native.
  */
 extern JS_PUBLIC_API(JSBranchCallback)
 JS_SetBranchCallback(JSContext *cx, JSBranchCallback cb);
+#else
+/*
+ * Set the operation callback that the engine calls while resetting
+ * context.
+ */
+extern JS_PUBLIC_API(void)
+JS_SetOperationCallback(JSContext *cx, JSOperationCallback callback);
+
+#endif
+
+extern JS_PUBLIC_API(void)
+JS_TriggerOperationCallback(JSContext *cx);
 
 extern JS_PUBLIC_API(JSBool)
 JS_IsRunning(JSContext *cx);
 
 extern JS_PUBLIC_API(JSBool)
 JS_IsConstructing(JSContext *cx);
 
 /*
diff -r 8b3caddca8f5 js/src/jsbuiltins.cpp
--- a/js/src/jsbuiltins.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/js/src/jsbuiltins.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -179,17 +179,30 @@ js_StringToInt32(JSContext* cx, JSString
     const jschar* bp;
     const jschar* end;
     const jschar* ep;
     jsdouble d;
 
     JSSTRING_CHARS_AND_END(str, bp, end);
     if (!js_strtod(cx, bp, end, &ep, &d) || js_SkipWhiteSpace(ep, end) != end)
         return 0;
-    return (int32)d;
+    return js_DoubleToECMAInt32(d);
+}
+
+static inline JSBool
+js_Int32ToId(JSContext* cx, int32 index, jsid* id)
+{
+    if (index <= JSVAL_INT_MAX) {
+        *id = INT_TO_JSID(index);
+        return JS_TRUE;
+    }
+    JSString* str = js_NumberToString(cx, index);
+    if (!str)
+        return JS_FALSE;
+    return js_ValueToStringId(cx, STRING_TO_JSVAL(str), id);
 }
 
 jsval FASTCALL
 js_Any_getprop(JSContext* cx, JSObject* obj, JSString* idstr)
 {
     jsval v;
     jsid id;
 
@@ -209,33 +222,29 @@ js_Any_setprop(JSContext* cx, JSObject* 
     return OBJ_SET_PROPERTY(cx, obj, id, &v);
 }
 
 jsval FASTCALL
 js_Any_getelem(JSContext* cx, JSObject* obj, int32 index)
 {
     jsval v;
     jsid id;
-    if (index < 0)
-        return JSVAL_ERROR_COOKIE;
-    if (!js_IndexToId(cx, index, &id))
+    if (!js_Int32ToId(cx, index, &id))
         return JSVAL_ERROR_COOKIE;
     if (!OBJ_GET_PROPERTY(cx, obj, id, &v))
         return JSVAL_ERROR_COOKIE;
     return v;
 }
 
 JSBool FASTCALL
 js_Any_setelem(JSContext* cx, JSObject* obj, int32 index, jsval v)
 {
     jsid id;
-    if (index < 0)
+    if (!js_Int32ToId(cx, index, &id))
         return JSVAL_ERROR_COOKIE;
-    if (!js_IndexToId(cx, index, &id))
-        return JS_FALSE;
     return OBJ_SET_PROPERTY(cx, obj, id, &v);
 }
 
 JSObject* FASTCALL
 js_FastValueToIterator(JSContext* cx, jsuint flags, jsval v)
 {
     if (!js_ValueToIterator(cx, flags, &v))
         return NULL;
@@ -388,18 +397,34 @@ js_AddProperty(JSContext* cx, JSObject* 
     JS_UNLOCK_SCOPE(cx, scope);
     return JS_FALSE;
 }
 
 JSBool FASTCALL
 js_HasNamedProperty(JSContext* cx, JSObject* obj, JSString* idstr)
 {
     jsid id;
-    if (!js_ValueToStringId(cx, STRING_TO_JSVAL(idstr), &id))
-        return JS_FALSE;
+    if (!obj || !js_ValueToStringId(cx, STRING_TO_JSVAL(idstr), &id))
+        return JSVAL_TO_BOOLEAN(JSVAL_VOID);
+
+    JSObject* obj2;
+    JSProperty* prop;
+    if (!OBJ_LOOKUP_PROPERTY(cx, obj, id, &obj2, &prop))
+        return JSVAL_TO_BOOLEAN(JSVAL_VOID);
+    if (prop)
+        OBJ_DROP_PROPERTY(cx, obj2, prop);
+    return prop != NULL;
+}
+
+JSBool FASTCALL
+js_HasNamedPropertyInt32(JSContext* cx, JSObject* obj, int32 index)
+{
+    jsid id;
+    if (!obj || !js_Int32ToId(cx, index, &id))
+        return JSVAL_TO_BOOLEAN(JSVAL_VOID);
 
     JSObject* obj2;
     JSProperty* prop;
     if (!OBJ_LOOKUP_PROPERTY(cx, obj, id, &obj2, &prop))
         return JSVAL_TO_BOOLEAN(JSVAL_VOID);
     if (prop)
         OBJ_DROP_PROPERTY(cx, obj2, prop);
     return prop != NULL;
diff -r 8b3caddca8f5 js/src/jsbuiltins.h
--- a/js/src/jsbuiltins.h	Sat Nov 15 23:56:49 2008 -0800
+++ b/js/src/jsbuiltins.h	Sat Nov 22 15:25:48 2008 -0500
@@ -186,20 +186,27 @@ struct JSTraceableNative {
 #define _JS_extern_CI
 #define _JS_FRIEND_TN(t)  extern JS_FRIEND_API(t)
 #define _JS_FRIEND_CI
 #define _JS_TN_LINKAGE(linkage, t)  _JS_##linkage##_TN(t)
 #define _JS_CI_LINKAGE(linkage)     _JS_##linkage##_CI
 
 #define _JS_CALLINFO(name) name##_ci
 
+#if defined(JS_NO_FASTCALL) && defined(NANOJIT_IA32)
+#define _JS_DEFINE_CALLINFO(linkage, name, crtype, cargtypes, argtypes, cse, fold)                \
+    _JS_TN_LINKAGE(linkage, crtype) name cargtypes;                                               \
+    _JS_CI_LINKAGE(linkage) const nanojit::CallInfo _JS_CALLINFO(name) =                          \
+        { (intptr_t) &name, argtypes, cse, fold, nanojit::ABI_CDECL _JS_CI_NAME(name) };
+#else
 #define _JS_DEFINE_CALLINFO(linkage, name, crtype, cargtypes, argtypes, cse, fold)                \
     _JS_TN_LINKAGE(linkage, crtype) FASTCALL name cargtypes;                                      \
     _JS_CI_LINKAGE(linkage) const nanojit::CallInfo _JS_CALLINFO(name) =                          \
         { (intptr_t) &name, argtypes, cse, fold, nanojit::ABI_FASTCALL _JS_CI_NAME(name) };
+#endif
 
 /*
  * Declare a C function named <op> and a CallInfo struct named <op>_callinfo so the
  * tracer can call it. |linkage| controls the visibility of both the function
  * and the CallInfo global. It can be extern, static, or FRIEND, which
  * specifies JS_FRIEND_API linkage for the function.
  */
 #define JS_DEFINE_CALLINFO_1(linkage, rt, op, at0, cse, fold)                                     \
@@ -303,16 +310,22 @@ struct JSTraceableNative {
         { name, _JS_TN_INIT_HELPER_n tn0 | JSTN_MORE },                                           \
         { name, _JS_TN_INIT_HELPER_n tn1 | JSTN_MORE },                                           \
         { name, _JS_TN_INIT_HELPER_n tn2 | JSTN_MORE },                                           \
         { name, _JS_TN_INIT_HELPER_n tn3 }                                                        \
     };
 
 #define _JS_DEFINE_CALLINFO_n(n, args)  JS_DEFINE_CALLINFO_##n args
 
+jsdouble FASTCALL
+js_StringToNumber(JSContext* cx, JSString* str);
+
+jsdouble FASTCALL
+js_BooleanOrUndefinedToNumber(JSContext* cx, int32 unboxed);
+
 #else
 
 #define JS_DEFINE_CALLINFO_1(linkage, rt, op, at0, cse, fold)
 #define JS_DEFINE_CALLINFO_2(linkage, rt, op, at0, at1, cse, fold)
 #define JS_DEFINE_CALLINFO_3(linkage, rt, op, at0, at1, at2, cse, fold)
 #define JS_DEFINE_CALLINFO_4(linkage, rt, op, at0, at1, at2, at3, cse, fold)
 #define JS_DEFINE_CALLINFO_5(linkage, rt, op, at0, at1, at2, at3, at4, cse, fold)
 #define JS_DECLARE_CALLINFO(name)
diff -r 8b3caddca8f5 js/src/jscntxt.cpp
--- a/js/src/jscntxt.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/js/src/jscntxt.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -236,17 +236,21 @@ js_NewContext(JSRuntime *rt, size_t stac
     JSContextCallback cxCallback;
 
     cx = (JSContext *) malloc(sizeof *cx);
     if (!cx)
         return NULL;
     memset(cx, 0, sizeof *cx);
 
     cx->runtime = rt;
+#if JS_OPERATION_COUNT
     JS_ClearOperationCallback(cx);
+#else
+    cx->operationCount = 1;
+#endif
     cx->debugHooks = &rt->globalDebugHooks;
 #if JS_STACK_GROWTH_DIRECTION > 0
     cx->stackLimit = (jsuword)-1;
 #endif
     cx->scriptStackQuota = JS_DEFAULT_SCRIPT_STACK_QUOTA;
 #ifdef JS_THREADSAFE
     cx->gcLocalFreeLists = (JSGCFreeListSet *) &js_GCEmptyFreeListSet;
     JS_INIT_CLIST(&cx->threadLinks);
@@ -511,17 +515,17 @@ js_ValidContextPointer(JSRuntime *rt, JS
     for (cl = rt->contextList.next; cl != &rt->contextList; cl = cl->next) {
         if (cl == &cx->links)
             return JS_TRUE;
     }
     JS_RUNTIME_METER(rt, deadContexts);
     return JS_FALSE;
 }
 
-JSContext *
+JS_FRIEND_API(JSContext *)
 js_ContextIterator(JSRuntime *rt, JSBool unlocked, JSContext **iterp)
 {
     JSContext *cx = *iterp;
 
     if (unlocked)
         JS_LOCK_GC(rt);
     cx = (JSContext *) (cx ? cx->links.next : rt->contextList.next);
     if (&cx->links == &rt->contextList)
@@ -1366,29 +1370,39 @@ js_GetErrorMessage(void *userRef, const 
     if ((errorNumber > 0) && (errorNumber < JSErr_Limit))
         return &js_ErrorFormatString[errorNumber];
     return NULL;
 }
 
 JSBool
 js_ResetOperationCount(JSContext *cx)
 {
+    JS_ASSERT(cx->operationCount <= 0);
+
+#if JS_HAS_OPERATION_COUNT
     JSScript *script;
 
-    JS_ASSERT(cx->operationCount <= 0);
     JS_ASSERT(cx->operationLimit > 0);
 
     cx->operationCount = (int32) cx->operationLimit;
     if (cx->operationCallbackIsSet)
         return cx->operationCallback(cx);
 
     if (cx->operationCallback) {
         /*
          * Invoke the deprecated branch callback. It may be called only when
          * the top-most frame is scripted or JSOPTION_NATIVE_BRANCH_CALLBACK
          * is set.
          */
         script = cx->fp ? cx->fp->script : NULL;
         if (script || JS_HAS_OPTION(cx, JSOPTION_NATIVE_BRANCH_CALLBACK))
             return ((JSBranchCallback) cx->operationCallback)(cx, script);
     }
+#else
+    JSOperationCallback operationCallback;
+
+    cx->operationCount = 1;
+    operationCallback = cx->operationCallback;
+    if (operationCallback)
+        return operationCallback(cx);
+#endif
     return JS_TRUE;
 }
diff -r 8b3caddca8f5 js/src/jscntxt.h
--- a/js/src/jscntxt.h	Sat Nov 15 23:56:49 2008 -0800
+++ b/js/src/jscntxt.h	Sat Nov 22 15:25:48 2008 -0500
@@ -734,17 +734,21 @@ struct JSContext {
 struct JSContext {
     /* JSRuntime contextList linkage. */
     JSCList             links;
 
     /*
      * Operation count. It is declared early in the structure as a frequently
      * accessed field.
      */
+#if !JS_HAS_OPERATION_COUNT
+    volatile int32      operationCount;
+#else
     int32               operationCount;
+#endif
 
 #if JS_HAS_XML_SUPPORT
     /*
      * Bit-set formed from binary exponentials of the XML_* tiny-ids defined
      * for boolean settings in jsxml.c, plus an XSF_CACHE_VALID bit.  Together
      * these act as a cache of the boolean XML.ignore* and XML.prettyPrinting
      * property values associated with this context's global object.
      */
@@ -843,18 +847,20 @@ struct JSContext {
     /* Per-context optional error reporter. */
     JSErrorReporter     errorReporter;
 
     /*
      * Flag indicating that the operation callback is set. When the flag is 0
      * but operationCallback is not null, operationCallback stores the branch
      * callback.
      */
+#if JS_HAS_OPERATION_COUNT
     uint32              operationCallbackIsSet :    1;
     uint32              operationLimit         :    31;
+#endif
     JSOperationCallback operationCallback;
 
     /* Interpreter activation count. */
     uintN               interpLevel;
 
     /* Client opaque pointers. */
     void                *data;
     void                *data2;
@@ -868,16 +874,20 @@ struct JSContext {
     jsrefcount          outstandingRequests;
     JSTitle             *titleToShare;      /* weak reference, see jslock.c */
     JSTitle             *lockedSealedTitle; /* weak ref, for low-cost sealed
                                                title locking */
     JSCList             threadLinks;        /* JSThread contextList linkage */
 
 #define CX_FROM_THREAD_LINKS(tl) \
     ((JSContext *)((char *)(tl) - offsetof(JSContext, threadLinks)))
+#endif
+
+#if !JS_HAS_OPERATION_COUNT
+    PRIntervalTime      startTime;          /* time when the context thread was started */
 #endif
 
     /* PDL of stack headers describing stack slots not rooted by argv, etc. */
     JSStackHeader       *stackHeaders;
 
     /* Optional stack of heap-allocated scoped local GC roots. */
     JSLocalRootStack    *localRootStack;
 
@@ -1033,17 +1043,17 @@ js_DestroyContext(JSContext *cx, JSDestr
  */
 extern JSBool
 js_ValidContextPointer(JSRuntime *rt, JSContext *cx);
 
 /*
  * If unlocked, acquire and release rt->gcLock around *iterp update; otherwise
  * the caller must be holding rt->gcLock.
  */
-extern JSContext *
+extern JS_FRIEND_API(JSContext *)
 js_ContextIterator(JSRuntime *rt, JSBool unlocked, JSContext **iterp);
 
 /*
  * JSClass.resolve and watchpoint recursion damping machinery.
  */
 extern JSBool
 js_StartResolving(JSContext *cx, JSResolvingKey *key, uint32 flag,
                   JSResolvingEntry **entryp);
@@ -1195,51 +1205,57 @@ extern JSErrorFormatString js_ErrorForma
  * Update the operation counter according to the given weight and call the
  * operation callback when we reach the operation limit. To make this
  * frequently executed macro faster we decrease the counter from
  * JSContext.operationLimit and compare against zero to check the limit.
  *
  * This macro can run the full GC. Return true if it is OK to continue and
  * false otherwise.
  */
-#define JS_CHECK_OPERATION_LIMIT(cx, weight)                                  \
+#if JS_HAS_OPERATION_COUNT
+
+# define JS_CHECK_OPERATION_LIMIT(cx, weight)                                 \
     (JS_CHECK_OPERATION_WEIGHT(weight),                                       \
-     (((cx)->operationCount -= (weight)) > 0 || js_ResetOperationCount(cx)))
+    (((cx)->operationCount -= (weight)) > 0 || js_ResetOperationCount(cx)))
 
 /*
  * A version of JS_CHECK_OPERATION_LIMIT that just updates the operation count
  * without calling the operation callback or any other API. This macro resets
  * the count to 0 when it becomes negative to prevent a wrap-around when the
  * macro is called repeatably.
  */
-#define JS_COUNT_OPERATION(cx, weight)                                        \
+# define JS_COUNT_OPERATION(cx, weight)                                       \
     ((void)(JS_CHECK_OPERATION_WEIGHT(weight),                                \
-            (cx)->operationCount = ((cx)->operationCount > 0)                 \
-                                   ? (cx)->operationCount - (weight)          \
-                                   : 0))
+     (cx)->operationCount = ((cx)->operationCount > 0)                        \
+                            ? (cx)->operationCount - (weight)                 \
+                            : 0))
 
 /*
  * The implementation of the above macros assumes that subtracting weights
  * twice from a positive number does not wrap-around INT32_MIN.
  */
-#define JS_CHECK_OPERATION_WEIGHT(weight)                                     \
+# define JS_CHECK_OPERATION_WEIGHT(weight)                                    \
     (JS_ASSERT((uint32) (weight) > 0),                                        \
      JS_ASSERT((uint32) (weight) < JS_BIT(30)))
 
 /* Relative operations weights. */
-#define JSOW_JUMP                   1
-#define JSOW_ALLOCATION             100
-#define JSOW_LOOKUP_PROPERTY        5
-#define JSOW_GET_PROPERTY           10
-#define JSOW_SET_PROPERTY           20
-#define JSOW_NEW_PROPERTY           200
-#define JSOW_DELETE_PROPERTY        30
-#define JSOW_ENTER_SHARP            JS_OPERATION_WEIGHT_BASE
-#define JSOW_SCRIPT_JUMP            JS_OPERATION_WEIGHT_BASE
-
+# define JSOW_JUMP                 1
+# define JSOW_ALLOCATION           100
+# define JSOW_LOOKUP_PROPERTY      5
+# define JSOW_GET_PROPERTY         10
+# define JSOW_SET_PROPERTY         20
+# define JSOW_NEW_PROPERTY         200
+# define JSOW_DELETE_PROPERTY      30
+# define JSOW_ENTER_SHARP          JS_OPERATION_WEIGHT_BASE
+# define JSOW_SCRIPT_JUMP          JS_OPERATION_WEIGHT_BASE
+#else
+# define JS_CHECK_OPERATION_LIMIT(cx, weight)                                 \
+     (((cx)->operationCount) > 0 || js_ResetOperationCount(cx))
+# define JS_COUNT_OPERATION(cx, weight) ((void) 0)
+#endif
 /*
  * Reset the operation count and call the operation callback assuming that the
  * operation limit is reached.
  */
 extern JSBool
 js_ResetOperationCount(JSContext *cx);
 
 JS_END_EXTERN_C
diff -r 8b3caddca8f5 js/src/jsfun.cpp
--- a/js/src/jsfun.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/js/src/jsfun.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -48,16 +48,17 @@
 #include "jsutil.h" /* Added by JSIFY */
 #include "jsapi.h"
 #include "jsarray.h"
 #include "jsatom.h"
 #include "jsbuiltins.h"
 #include "jscntxt.h"
 #include "jsversion.h"
 #include "jsdbgapi.h"
+#include "jsemit.h"
 #include "jsfun.h"
 #include "jsgc.h"
 #include "jsinterp.h"
 #include "jslock.h"
 #include "jsnum.h"
 #include "jsobj.h"
 #include "jsopcode.h"
 #include "jsparse.h"
@@ -2032,20 +2033,21 @@ js_InitFunctionClass(JSContext *cx, JSOb
 
     proto = JS_InitClass(cx, obj, NULL, &js_FunctionClass, Function, 1,
                          function_props, function_methods, NULL, NULL);
     if (!proto)
         return NULL;
     fun = js_NewFunction(cx, proto, NULL, 0, JSFUN_INTERPRETED, obj, NULL);
     if (!fun)
         goto bad;
-    fun->u.i.script = js_NewScript(cx, 1, 0, 0, 0, 0, 0, 0);
+    fun->u.i.script = js_NewScript(cx, 1, 1, 0, 0, 0, 0, 0);
     if (!fun->u.i.script)
         goto bad;
     fun->u.i.script->code[0] = JSOP_STOP;
+    *SCRIPT_NOTES(fun->u.i.script) = SRC_NULL;
 #ifdef CHECK_SCRIPT_OWNER
     fun->u.i.script->owner = NULL;
 #endif
     return proto;
 
 bad:
     cx->weakRoots.newborn[GCX_OBJECT] = NULL;
     return NULL;
diff -r 8b3caddca8f5 js/src/jsgc.cpp
--- a/js/src/jsgc.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/js/src/jsgc.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -2791,18 +2791,16 @@ js_TraceStackFrame(JSTracer *trc, JSStac
         JS_CALL_OBJECT_TRACER(trc, fp->varobj, "variables");
     if (fp->script) {
         js_TraceScript(trc, fp->script);
         if (fp->regs) {
             /*
              * Don't mark what has not been pushed yet, or what has been
              * popped already.
              */
-            JS_ASSERT((size_t) (fp->regs->sp - fp->slots) <=
-                      fp->script->nslots);
             nslots = (uintN) (fp->regs->sp - fp->slots);
             TRACE_JSVALS(trc, nslots, fp->slots, "slot");
         }
     } else {
         JS_ASSERT(!fp->slots);
         JS_ASSERT(!fp->regs);
     }
 
@@ -3672,17 +3670,17 @@ out:
      */
     if (rt->gcLevel > 1 || rt->gcPoke) {
         rt->gcLevel = 1;
         rt->gcPoke = JS_FALSE;
         JS_UNLOCK_GC(rt);
         goto restart;
     }
 
-    if (rt->shapeGen & SHAPE_OVERFLOW_BIT) {
+    if (rt->shapeGen >= SHAPE_OVERFLOW_BIT - 1) {
         /*
          * FIXME bug 440834: The shape id space has overflowed. Currently we
          * cope badly with this. Every call to js_GenerateShape does GC, and
          * we never re-enable the property cache.
          */
         js_DisablePropertyCache(cx);
 #ifdef JS_THREADSAFE
         iter = NULL;
diff -r 8b3caddca8f5 js/src/jsinterp.cpp
--- a/js/src/jsinterp.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/js/src/jsinterp.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -80,27 +80,32 @@
 #endif
 
 #include "jsautooplen.h"
 
 /* jsinvoke_cpp___ indicates inclusion from jsinvoke.cpp. */
 #if !JS_LONE_INTERPRET ^ defined jsinvoke_cpp___
 
 uint32
-js_GenerateShape(JSContext *cx, JSBool gcLocked)
+js_GenerateShape(JSContext *cx, JSBool gcLocked, JSScopeProperty *sprop)
 {
     JSRuntime *rt;
     uint32 shape;
+    JSTempValueRooter tvr;
 
     rt = cx->runtime;
     shape = JS_ATOMIC_INCREMENT(&rt->shapeGen);
     JS_ASSERT(shape != 0);
     if (shape & SHAPE_OVERFLOW_BIT) {
         rt->gcPoke = JS_TRUE;
+        if (sprop)
+            JS_PUSH_TEMP_ROOT_SPROP(cx, sprop, &tvr);
         js_GC(cx, gcLocked ? GC_LOCK_HELD : GC_NORMAL);
+        if (sprop)
+            JS_POP_TEMP_ROOT(cx, &tvr);
         shape = JS_ATOMIC_INCREMENT(&rt->shapeGen);
         JS_ASSERT(shape != 0);
         JS_ASSERT_IF(shape & SHAPE_OVERFLOW_BIT,
                      JS_PROPERTY_CACHE(cx).disabled);
     }
     return shape;
 }
 
@@ -2574,17 +2579,26 @@ js_Interpret(JSContext *cx)
 
 #ifdef JS_TRACER
     /* We had better not be entering the interpreter from JIT-compiled code. */
     TraceRecorder *tr = NULL;
     if (JS_ON_TRACE(cx)) {
         tr = TRACE_RECORDER(cx);
         SET_TRACE_RECORDER(cx, NULL);
         JS_TRACE_MONITOR(cx).onTrace = JS_FALSE;
-        tr->pushAbortStack();
+        /*
+         * ON_TRACE means either recording or coming from traced code.
+         * If there's no recorder (the latter case), don't care.
+         */
+        if (tr) {
+            if (tr->wasDeepAborted())
+                tr->removeFragmentoReferences();
+            else
+                tr->pushAbortStack();
+        }
     }
 #endif
 
     /* Check for too deep of a native thread stack. */
     JS_CHECK_RECURSION(cx, return JS_FALSE);
 
     rt = cx->runtime;
 
@@ -2646,24 +2660,33 @@ js_Interpret(JSContext *cx)
 #define MONITOR_BRANCH() ((void) 0)
 
 #endif /* !JS_TRACER */
 
     /*
      * Prepare to call a user-supplied branch handler, and abort the script
      * if it returns false.
      */
-#define CHECK_BRANCH()                                                        \
+#if JS_HAS_OPERATION_COUNT
+# define CHECK_BRANCH()                                                       \
     JS_BEGIN_MACRO                                                            \
         if ((cx->operationCount -= JSOW_SCRIPT_JUMP) <= 0) {                  \
             if (!js_ResetOperationCount(cx))                                  \
                 goto error;                                                   \
         }                                                                     \
     JS_END_MACRO
-
+#else
+# define CHECK_BRANCH()                                                       \
+    JS_BEGIN_MACRO                                                            \
+        if (cx->operationCount < 1) {                                         \
+            if (!js_ResetOperationCount(cx))                                  \
+                goto error;                                                   \
+        }                                                                     \
+    JS_END_MACRO
+#endif
 #define BRANCH(n)                                                             \
     JS_BEGIN_MACRO                                                            \
         regs.pc += n;                                                         \
         if (n <= 0) {                                                         \
             CHECK_BRANCH();                                                   \
             MONITOR_BRANCH();                                                 \
         }                                                                     \
         op = (JSOp) *regs.pc;                                                 \
@@ -5932,17 +5955,17 @@ js_Interpret(JSContext *cx)
             obj = FUN_OBJECT(fun);
             if (OBJ_GET_PARENT(cx, obj) != parent) {
                 obj = js_CloneFunctionObject(cx, fun, parent);
                 if (!obj)
                     goto error;
             }
 
             TRACE_2(DefLocalFunSetSlot, slot, obj);
-            
+
             fp->slots[slot] = OBJECT_TO_JSVAL(obj);
           END_CASE(JSOP_DEFLOCALFUN)
 
           BEGIN_CASE(JSOP_ANONFUNOBJ)
             /* Load the specified function object literal. */
             LOAD_FUNCTION(0);
 
             /* If re-parenting, push a clone of the function object. */
diff -r 8b3caddca8f5 js/src/jsinterp.h
--- a/js/src/jsinterp.h	Sat Nov 15 23:56:49 2008 -0800
+++ b/js/src/jsinterp.h	Sat Nov 22 15:25:48 2008 -0500
@@ -193,18 +193,22 @@ typedef struct JSInlineFrame {
 
 #define PCVCAP_MAKE(t,s,p)      (((t) << PCVCAP_TAGBITS) |                    \
                                  ((s) << PCVCAP_PROTOBITS) |                  \
                                  (p))
 #define PCVCAP_SHAPE(t)         ((t) >> PCVCAP_TAGBITS)
 
 #define SHAPE_OVERFLOW_BIT      JS_BIT(32 - PCVCAP_TAGBITS)
 
+/*
+ * When sprop is not null and the shape generation triggers the GC due to a
+ * shape overflow, the functions roots sprop.
+ */
 extern uint32
-js_GenerateShape(JSContext *cx, JSBool gcLocked);
+js_GenerateShape(JSContext *cx, JSBool gcLocked, JSScopeProperty *sprop);
 
 struct JSPropCacheEntry {
     jsbytecode          *kpc;           /* pc if vcap tag is <= 1, else atom */
     jsuword             kshape;         /* key shape if pc, else obj for atom */
     jsuword             vcap;           /* value capability, see above */
     jsuword             vword;          /* value word, see PCVAL_* below */
 };
 
diff -r 8b3caddca8f5 js/src/jsopcode.cpp
--- a/js/src/jsopcode.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/js/src/jsopcode.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -680,17 +680,17 @@ struct JSPrinter {
 struct JSPrinter {
     Sprinter        sprinter;       /* base class state */
     JSArenaPool     pool;           /* string allocation pool */
     uintN           indent;         /* indentation in spaces */
     JSPackedBool    pretty;         /* pretty-print: indent, use newlines */
     JSPackedBool    grouped;        /* in parenthesized expression context */
     JSScript        *script;        /* script being printed */
     jsbytecode      *dvgfence;      /* DecompileExpression fencepost */
-    jsbytecode      **pcstack;      /* DecompileExpression modelled stack */
+    jsbytecode      **pcstack;      /* DecompileExpression modeled stack */
     JSFunction      *fun;           /* interpreted function */
     jsuword         *localNames;    /* argument and variable names */
 };
 
 /*
  * Hack another flag, a la JS_DONT_PRETTY_PRINT, into uintN indent parameters
  * to functions such as js_DecompileFunction and js_NewPrinter.  This time, as
  * opposed to JS_DONT_PRETTY_PRINT back in the dark ages, we can assume that a
@@ -2810,17 +2810,17 @@ Decompile(SprintStack *ss, jsbytecode *p
 
               case JSOP_SETLOCAL:
               case JSOP_SETLOCALPOP:
                 if (IsVarSlot(jp, pc, &i)) {
                     atom = GetArgOrVarAtom(jp, i);
                     LOCAL_ASSERT(atom);
                     goto do_setname;
                 }
-                lval = GetStr(ss, i);
+                lval = GetLocal(ss, i);
                 rval = POP_STR();
                 goto do_setlval;
 
               case JSOP_INCLOCAL:
               case JSOP_DECLOCAL:
                 if (IsVarSlot(jp, pc, &i)) {
                     atom = GetArgOrVarAtom(jp, i);
                     LOCAL_ASSERT(atom);
@@ -4948,78 +4948,90 @@ js_DecompileValueGenerator(JSContext *cx
 
     for (fp = cx->fp; fp && !fp->script; fp = fp->down)
         continue;
     if (!fp || !fp->regs)
         goto do_fallback;
 
     script = fp->script;
     regs = fp->regs;
-    pc = regs->pc;
+    pc = fp->imacpc ? fp->imacpc : regs->pc;
     if (pc < script->main || script->code + script->length <= pc) {
         JS_NOT_REACHED("bug");
         goto do_fallback;
     }
 
     if (spindex != JSDVG_IGNORE_STACK) {
         jsbytecode **pcstack;
 
         /*
          * Prepare computing pcstack containing pointers to opcodes that
          * populated interpreter's stack with its current content.
          */
         pcstack = (jsbytecode **)
                   JS_malloc(cx, StackDepth(script) * sizeof *pcstack);
         if (!pcstack)
             return NULL;
-        pcdepth = ReconstructPCStack(cx, script, regs->pc, pcstack);
+        pcdepth = ReconstructPCStack(cx, script, pc, pcstack);
         if (pcdepth < 0)
             goto release_pcstack;
 
         if (spindex != JSDVG_SEARCH_STACK) {
             JS_ASSERT(spindex < 0);
             pcdepth += spindex;
             if (pcdepth < 0)
                 goto release_pcstack;
             pc = pcstack[pcdepth];
         } else {
             /*
              * We search from fp->sp to base to find the most recently
              * calculated value matching v under assumption that it is
              * it that caused exception, see bug 328664.
              */
             stackBase = StackBase(fp);
-            JS_ASSERT((size_t) (regs->sp - stackBase) <= StackDepth(script));
             sp = regs->sp;
             do {
                 if (sp == stackBase) {
                     pcdepth = -1;
                     goto release_pcstack;
                 }
             } while (*--sp != v);
 
             if (sp >= stackBase + pcdepth) {
                 /*
-                 * This happens when the value comes from a temporary slot
-                 * that the interpreter uses for GC roots. Assume that it is
-                 * fp->pc that caused the exception.
-                 */
-                pc = regs->pc;
+                 * The value comes from a temporary slot that the interpreter
+                 * uses for GC roots or when JSOP_APPLY extended the stack to
+                 * fit the argument array elements. Assume that it is the
+                 * current PC that caused the exception.
+                 */
+                pc = fp->imacpc ? fp->imacpc : regs->pc;
             } else {
                 pc = pcstack[sp - stackBase];
             }
         }
 
       release_pcstack:
         JS_free(cx, pcstack);
         if (pcdepth < 0)
             goto do_fallback;
     }
 
-    name = DecompileExpression(cx, script, fp->fun, pc);
+    {
+        jsbytecode* savepc = regs->pc;
+        jsbytecode* imacpc = fp->imacpc;
+        if (imacpc) {
+            regs->pc = imacpc;
+            fp->imacpc = NULL;
+        }
+        name = DecompileExpression(cx, script, fp->fun, pc);
+        if (imacpc) {
+            regs->pc = savepc;
+            fp->imacpc = imacpc;
+        }
+    }
     if (name != FAILED_EXPRESSION_DECOMPILER)
         return name;
 
   do_fallback:
     if (!fallback) {
         fallback = js_ValueToSource(cx, v);
         if (!fallback)
             return NULL;
diff -r 8b3caddca8f5 js/src/jspubtd.h
--- a/js/src/jspubtd.h	Sat Nov 15 23:56:49 2008 -0800
+++ b/js/src/jspubtd.h	Sat Nov 22 15:25:48 2008 -0500
@@ -101,18 +101,18 @@ typedef enum JSProtoKey {
     JSProto_LIMIT
 } JSProtoKey;
 
 /* JSObjectOps.checkAccess mode enumeration. */
 typedef enum JSAccessMode {
     JSACC_PROTO  = 0,           /* XXXbe redundant w.r.t. id */
     JSACC_PARENT = 1,           /* XXXbe redundant w.r.t. id */
 
-                                /* 
-                                 * enum value #2 formerly called JSACC_IMPORT, 
+                                /*
+                                 * enum value #2 formerly called JSACC_IMPORT,
                                  * gap preserved for liveconnect ABI compatibility.
                                  */
 
     JSACC_WATCH  = 3,           /* a watchpoint on object foo for id 'bar' */
     JSACC_READ   = 4,           /* a "get" of foo.bar */
     JSACC_WRITE  = 8,           /* a "set" of foo.bar = baz */
     JSACC_LIMIT
 } JSAccessMode;
@@ -589,31 +589,35 @@ typedef JSBool
 /* See jsapi.h, the JS_CALLEE, JS_THIS, etc. macros. */
 typedef JSBool
 (* JSFastNative)(JSContext *cx, uintN argc, jsval *vp);
 
 /* Callbacks and their arguments. */
 
 typedef enum JSContextOp {
     JSCONTEXT_NEW,
-    JSCONTEXT_DESTROY
+    JSCONTEXT_DESTROY,
+    JSCONTEXT_REQUEST_START
 } JSContextOp;
 
 /*
  * The possible values for contextOp when the runtime calls the callback are:
- *   JSCONTEXT_NEW      JS_NewContext successfully created a new JSContext
- *                      instance. The callback can initialize the instance as
- *                      required. If the callback returns false, the instance
- *                      will be destroyed and JS_NewContext returns null. In
- *                      this case the callback is not called again.
- *   JSCONTEXT_DESTROY  One of JS_DestroyContext* methods is called. The
- *                      callback may perform its own cleanup and must always
- *                      return true.
- *   Any other value    For future compatibility the callback must do nothing
- *                      and return true in this case.
+ *  JSCONTEXT_NEW           JS_NewContext successfully created a new JSContext
+ *                          instance. The callback can initialize the instance as
+ *                          required. If the callback returns false, the instance
+ *                          will be destroyed and JS_NewContext returns null. In
+ *                          this case the callback is not called again.
+ *  JSCONTEXT_DESTROY       One of JS_DestroyContext* methods is called. The
+ *                          callback may perform its own cleanup and must always
+ *                          return true.
+ *  JSCONTEXT_REQUEST_START JS_BeginRequest was called with requestDepth == 0.
+ *                          This callback can be used to notify other components
+ *                          that execution has begun on this context.
+ *  Any other value         For future compatibility the callback must do nothing
+ *                          and return true in this case.
  */
 typedef JSBool
 (* JSContextCallback)(JSContext *cx, uintN contextOp);
 
 typedef enum JSGCStatus {
     JSGC_BEGIN,
     JSGC_END,
     JSGC_MARK_END,
diff -r 8b3caddca8f5 js/src/jsscope.cpp
--- a/js/src/jsscope.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/js/src/jsscope.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -804,16 +804,17 @@ GetPropertyTreeChild(JSContext *cx, JSSc
                      JSScopeProperty *child)
 {
     JSRuntime *rt;
     JSDHashTable *table;
     JSPropertyTreeEntry *entry;
     JSScopeProperty *sprop;
     PropTreeKidsChunk *chunk;
     uintN i, n;
+    uint32 shape;
 
     rt = cx->runtime;
     if (!parent) {
         JS_LOCK_GC(rt);
 
         table = &rt->propertyTreeHash;
         entry = (JSPropertyTreeEntry *)
                 JS_DHashTableOperate(table, child, JS_DHASH_ADD);
@@ -890,29 +891,35 @@ GetPropertyTreeChild(JSContext *cx, JSSc
             }
         }
 
     not_found:
         JS_LOCK_GC(rt);
     }
 
 locked_not_found:
+    /*
+     * Call js_GenerateShape before the allocation to prevent collecting the
+     * new property when the shape generation triggers the GC.
+     */
+    shape = js_GenerateShape(cx, JS_TRUE, NULL);
+
     sprop = NewScopeProperty(rt);
     if (!sprop)
         goto out_of_memory;
 
     sprop->id = child->id;
     sprop->getter = child->getter;
     sprop->setter = child->setter;
     sprop->slot = child->slot;
     sprop->attrs = child->attrs;
     sprop->flags = child->flags;
     sprop->shortid = child->shortid;
     sprop->parent = sprop->kids = NULL;
-    sprop->shape = js_GenerateShape(cx, JS_TRUE);
+    sprop->shape = shape;
 
     if (!parent) {
         entry->child = sprop;
     } else {
         if (!InsertPropertyTreeChild(rt, parent, sprop, NULL))
             goto out_of_memory;
     }
 
diff -r 8b3caddca8f5 js/src/jsscope.h
--- a/js/src/jsscope.h	Sat Nov 15 23:56:49 2008 -0800
+++ b/js/src/jsscope.h	Sat Nov 22 15:25:48 2008 -0500
@@ -216,25 +216,25 @@ JS_STATIC_ASSERT(offsetof(JSScope, title
 #endif
 
 #define JS_IS_SCOPE_LOCKED(cx, scope)   JS_IS_TITLE_LOCKED(cx, &(scope)->title)
 
 #define OBJ_SCOPE(obj)                  ((JSScope *)(obj)->map)
 #define OBJ_SHAPE(obj)                  (OBJ_SCOPE(obj)->shape)
 
 #define SCOPE_MAKE_UNIQUE_SHAPE(cx,scope)                                     \
-    ((scope)->shape = js_GenerateShape((cx), JS_FALSE))
+    ((scope)->shape = js_GenerateShape((cx), JS_FALSE, NULL))
 
 #define SCOPE_EXTEND_SHAPE(cx,scope,sprop)                                    \
     JS_BEGIN_MACRO                                                            \
         if (!(scope)->lastProp ||                                             \
             (scope)->shape == (scope)->lastProp->shape) {                     \
             (scope)->shape = (sprop)->shape;                                  \
         } else {                                                              \
-            (scope)->shape = js_GenerateShape((cx), JS_FALSE);                \
+            (scope)->shape = js_GenerateShape((cx), JS_FALSE, sprop);         \
         }                                                                     \
     JS_END_MACRO
 
 /* By definition, hashShift = JS_DHASH_BITS - log2(capacity). */
 #define SCOPE_CAPACITY(scope)           JS_BIT(JS_DHASH_BITS-(scope)->hashShift)
 
 /* Scope flags and some macros to hide them from other files than jsscope.c. */
 #define SCOPE_MIDDLE_DELETE             0x0001
diff -r 8b3caddca8f5 js/src/jsscript.h
--- a/js/src/jsscript.h	Sat Nov 15 23:56:49 2008 -0800
+++ b/js/src/jsscript.h	Sat Nov 22 15:25:48 2008 -0500
@@ -151,23 +151,23 @@ StackDepth(JSScript *script)
 #define JS_SCRIPT_REGEXPS(script)                                             \
     (JS_ASSERT((script)->regexpsOffset != 0),                                 \
      (JSObjectArray *)((uint8 *)(script) + (script)->regexpsOffset))
 
 #define JS_SCRIPT_TRYNOTES(script)                                            \
     (JS_ASSERT((script)->trynotesOffset != 0),                                \
      (JSTryNoteArray *)((uint8 *)(script) + (script)->trynotesOffset))
 
-#define JS_GET_SCRIPT_ATOM(script, index, atom)                               \
+#define JS_GET_SCRIPT_ATOM(script_, index, atom)                              \
     JS_BEGIN_MACRO                                                            \
-        JSAtomMap *atoms_ = &(script)->atomMap;                               \
-        if (cx->fp && cx->fp->imacpc) {                                       \
+        if (cx->fp && cx->fp->imacpc && cx->fp->script == script_) {          \
             JS_ASSERT((size_t)(index) < js_common_atom_count);                \
             (atom) = COMMON_ATOMS_START(&cx->runtime->atomState)[index];      \
         } else {                                                              \
+            JSAtomMap *atoms_ = &(script_)->atomMap;                          \
             JS_ASSERT((uint32)(index) < atoms_->length);                      \
             (atom) = atoms_->vector[index];                                   \
         }                                                                     \
     JS_END_MACRO
 
 #define JS_GET_SCRIPT_OBJECT(script, index, obj)                              \
     JS_BEGIN_MACRO                                                            \
         JSObjectArray *objects_ = JS_SCRIPT_OBJECTS(script);                  \
diff -r 8b3caddca8f5 js/src/jstracer.cpp
--- a/js/src/jstracer.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/js/src/jstracer.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -645,20 +645,19 @@ public:
         return out->insCall(ci, args);
     }
 };
 
 #endif // NJ_SOFTFLOAT
 
 class FuncFilter: public LirWriter
 {
-    TraceRecorder& recorder;
 public:
-    FuncFilter(LirWriter* out, TraceRecorder& _recorder):
-        LirWriter(out), recorder(_recorder)
+    FuncFilter(LirWriter* out):
+        LirWriter(out)
     {
     }
 
     LInsp ins2(LOpcode v, LInsp s0, LInsp s1)
     {
         if (s0 == s1 && v == LIR_feq) {
             if (isPromote(s0)) {
                 // double(int) and double(uint) cannot be nan
@@ -678,31 +677,16 @@ public:
                 v = LOpcode(v + (LIR_eq - LIR_feq));
                 return out->ins2(v, demote(out, s0), demote(out, s1));
             } else if (isPromoteUint(s0) && isPromoteUint(s1)) {
                 // uint compare
                 v = LOpcode(v + (LIR_eq - LIR_feq));
                 if (v != LIR_eq)
                     v = LOpcode(v + (LIR_ult - LIR_lt)); // cmp -> ucmp
                 return out->ins2(v, demote(out, s0), demote(out, s1));
-            }
-        } else if (v == LIR_fadd || v == LIR_fsub) {
-            /* demoting multiplication seems to be tricky since it can quickly overflow the
-               value range of int32 */
-            if (isPromoteInt(s0) && isPromoteInt(s1)) {
-                // demote fop to op
-                v = (LOpcode)((int)v & ~LIR64);
-                LIns* d0;
-                LIns* d1;
-                LIns* result = out->ins2(v, d0 = demote(out, s0), d1 = demote(out, s1));
-                if (!overflowSafe(d0) || !overflowSafe(d1)) {
-                    out->insGuard(LIR_xt, out->ins1(LIR_ov, result),
-                                  recorder.snapshot(OVERFLOW_EXIT));
-                }
-                return out->ins1(LIR_i2f, result);
             }
         } else if (v == LIR_or &&
                    s0->isop(LIR_lsh) && isconst(s0->oprnd2(), 16) &&
                    s1->isop(LIR_and) && isconst(s1->oprnd2(), 0xffff)) {
             LIns* msw = s0->oprnd1();
             LIns* lsw = s1->oprnd1();
             LIns* x;
             LIns* y;
@@ -748,17 +732,17 @@ public:
         if (ci == &js_DoubleToUint32_ci) {
             if (s0->isconstq())
                 return out->insImm(js_DoubleToECMAUint32(s0->constvalf()));
             if (isi2f(s0) || isu2f(s0))
                 return iu2fArg(s0);
         } else if (ci == &js_DoubleToInt32_ci) {
             if (s0->isconstq())
                 return out->insImm(js_DoubleToECMAInt32(s0->constvalf()));
-            if (s0->isop(LIR_fadd) || s0->isop(LIR_fsub) || s0->isop(LIR_fmul)) {
+            if (s0->isop(LIR_fadd) || s0->isop(LIR_fsub)) {
                 LInsp lhs = s0->oprnd1();
                 LInsp rhs = s0->oprnd2();
                 if (isPromote(lhs) && isPromote(rhs)) {
                     LOpcode op = LOpcode(s0->opcode() & ~LIR64);
                     return out->ins2(op, demote(out, lhs), demote(out, rhs));
                 }
             }
             if (isi2f(s0) || isu2f(s0))
@@ -890,17 +874,16 @@ js_NativeStackSlots(JSContext *cx, unsig
 {
     JSStackFrame* fp = cx->fp;
     unsigned slots = 0;
 #if defined _DEBUG
     unsigned int origCallDepth = callDepth;
 #endif
     for (;;) {
         unsigned operands = fp->regs->sp - StackBase(fp);
-        JS_ASSERT(operands <= unsigned(fp->script->nslots - fp->script->nfixed));
         slots += operands;
         if (fp->callee)
             slots += fp->script->nfixed;
         if (callDepth-- == 0) {
             if (fp->callee)
                 slots += 2/*callee,this*/ + fp->fun->nargs;
 #if defined _DEBUG
             unsigned int m = 0;
@@ -1014,17 +997,17 @@ TraceRecorder::TraceRecorder(JSContext* 
     if (verbose_debug)
         lir = verbose_filter = new (&gc) VerboseWriter(&gc, lir, lirbuf->names);
 #endif
 #ifdef NJ_SOFTFLOAT
     lir = float_filter = new (&gc) SoftFloatFilter(lir);
 #endif
     lir = cse_filter = new (&gc) CseFilter(lir, &gc);
     lir = expr_filter = new (&gc) ExprFilter(lir);
-    lir = func_filter = new (&gc) FuncFilter(lir, *this);
+    lir = func_filter = new (&gc) FuncFilter(lir);
     lir->ins0(LIR_start);
 
     if (!nanojit::AvmCore::config.tree_opt || fragment->root == fragment) 
         lirbuf->state = addName(lir->insParam(0, 0), "state");
 
     lirbuf->sp = addName(lir->insLoad(LIR_ldp, lirbuf->state, (int)offsetof(InterpState, sp)), "sp");
     lirbuf->rp = addName(lir->insLoad(LIR_ldp, lirbuf->state, offsetof(InterpState, rp)), "rp");
     cx_ins = addName(lir->insLoad(LIR_ldp, lirbuf->state, offsetof(InterpState, cx)), "cx");
@@ -1055,16 +1038,24 @@ TreeInfo::~TreeInfo()
         unstableExits = temp;
     }
 }
 
 TraceRecorder::~TraceRecorder()
 {
     JS_ASSERT(nextRecorderToAbort == NULL);
     JS_ASSERT(treeInfo && (fragment || wasDeepAborted()));
+#ifdef DEBUG
+    TraceRecorder* tr = JS_TRACE_MONITOR(cx).abortStack;
+    while (tr != NULL)
+    {
+        JS_ASSERT(this != tr);
+        tr = tr->nextRecorderToAbort;
+    }
+#endif
     if (fragment) {
         if (wasRootFragment && !fragment->root->code()) {
             JS_ASSERT(!fragment->root->vmprivate);
             delete treeInfo;
         }
         if (trashTree)
             js_TrashTree(cx, whichTreeToTrash);
     } else if (wasRootFragment) {
@@ -1232,20 +1223,16 @@ ValueToNative(JSContext* cx, jsval v, ui
         debug_only_v(printf("double<%g> ", d);)
         return;
       case JSVAL_BOOLEAN:
         JS_ASSERT(tag == JSVAL_BOOLEAN);
         *(JSBool*)slot = JSVAL_TO_BOOLEAN(v);
         debug_only_v(printf("boolean<%d> ", *(JSBool*)slot);)
         return;
       case JSVAL_STRING:
-        if (v == JSVAL_VOID) {
-            *(JSString**)slot = ATOM_TO_STRING(cx->runtime->atomState.typeAtoms[JSTYPE_VOID]); 
-            return;
-        } 
         JS_ASSERT(tag == JSVAL_STRING);
         *(JSString**)slot = JSVAL_TO_STRING(v);
         debug_only_v(printf("string<%p> ", *(JSString**)slot);)
         return;
       default:
         /* Note: we should never see JSVAL_BOXED in an entry type map. */
         JS_ASSERT(type == JSVAL_OBJECT);
         JS_ASSERT(tag == JSVAL_OBJECT);
@@ -2301,17 +2288,17 @@ TraceRecorder::closeLoop(Fragmento* frag
             /* If we were trying to stabilize a promotable tree, trash it. */
             if (promotedPeer)
                 js_TrashTree(cx, promotedPeer);
         } else {
             JS_ASSERT(peer->code());
             exit->target = peer;
             debug_only_v(printf("Joining type-unstable trace to target fragment %p.\n", peer);)
             stable = true;
-            ((TreeInfo*)peer->vmprivate)->dependentTrees.addUnique(fragment);
+            ((TreeInfo*)peer->vmprivate)->dependentTrees.addUnique(fragment->root);
         }
 
         compile(fragmento);
     } else {
         exit->target = fragment->root;
 #if defined(JS_HAS_OPERATION_COUNT) && !JS_HAS_OPERATION_COUNT
         exit->exitType = TIMEOUT_EXIT;
         guard(false, 
@@ -2668,17 +2655,17 @@ js_DeleteRecorder(JSContext* cx)
 
 /**
  * Checks whether the shape of the global object has changed.
  */
 static inline bool
 js_CheckGlobalObjectShape(JSContext* cx, JSTraceMonitor* tm, JSObject* globalObj)
 {
     /* Check the global shape. */
-    if (tm->globalSlots->length() && (OBJ_SHAPE(globalObj) != tm->globalShape)) {
+    if (OBJ_SHAPE(globalObj) != tm->globalShape) {
         AUDIT(globalShapeMismatchAtEntry);
         debug_only_v(printf("Global shape mismatch (%u vs. %u), flushing cache.\n",
                             OBJ_SHAPE(globalObj), tm->globalShape);)
         return false;
     }
     return true;
 }
 
@@ -2895,16 +2882,18 @@ js_SynthesizeFrame(JSContext* cx, const 
     return (fi.s.spdist - cx->fp->down->script->nfixed) +
            ((fun->nargs > cx->fp->argc) ? fun->nargs - cx->fp->argc : 0) +
            script->nfixed;
 }
 
 bool
 js_RecordTree(JSContext* cx, JSTraceMonitor* tm, Fragment* f, Fragment* outer, unsigned* demotes)
 {
+    JS_ASSERT(cx->fp->regs->pc == f->ip && f->root == f);
+    
     /* Avoid recording loops in overlarge scripts. */
     if (cx->fp->script->length >= SCRIPT_PC_ADJ_LIMIT) {
         js_AbortRecording(cx, "script too large");
         return false;
     }
 
     /* Make sure the global type map didn't change on us. */
     JSObject* globalObj = JS_GetGlobalForObject(cx, cx->fp->scopeChain);
@@ -3086,34 +3075,40 @@ js_FindVMCompatiblePeer(JSContext* cx, F
 
 static bool
 js_CloseLoop(JSContext* cx)
 {
     JSTraceMonitor* tm = &JS_TRACE_MONITOR(cx);
     Fragmento* fragmento = tm->fragmento;
     TraceRecorder* r = tm->recorder;
     JS_ASSERT(fragmento && r);
-
+    bool walkedOutOfLoop = r->walkedOutOfLoop();
+    
     if (fragmento->assm()->error()) {
         js_AbortRecording(cx, "Error during recording");
 
         /* If we ran out of memory, flush the code cache and abort. */
         if (fragmento->assm()->error() == OutOMem)
             js_FlushJITCache(cx);
         return false;
     }
 
     bool demote;
     Fragment* f = r->getFragment();
     TreeInfo* ti = r->getTreeInfo();
     unsigned* demotes = ALLOCA_UNDEMOTE_SLOTLIST(ti->stackTypeMap.length());
     r->closeLoop(fragmento, demote, demotes);
     JS_ASSERT(!demote || NUM_UNDEMOTE_SLOTS(demotes));
     js_DeleteRecorder(cx);
-    if (demote)
+    
+    /*
+     * If we just walked out of a thin loop, we can't immediately start the 
+     * compiler again here since we didn't return to the loop header.
+     */
+    if (demote && !walkedOutOfLoop)
         return js_RecordTree(cx, tm, f, NULL, demotes);
     return false;
 }
 
 bool
 js_RecordLoopEdge(JSContext* cx, TraceRecorder* r, uintN& inlineCallCount)
 {
 #ifdef JS_THREADSAFE
@@ -3257,17 +3252,17 @@ js_IsEntryTypeCompatible(jsval* vp, uint
         debug_only_v(printf("double != tag%u ", tag);)
         return false;
       case JSVAL_BOOLEAN:
         if (tag == JSVAL_BOOLEAN)
             return true;
         debug_only_v(printf("bool != tag%u", tag);)
         return false;
       case JSVAL_STRING:
-        if (*vp == JSVAL_VOID || tag == JSVAL_STRING)
+        if (tag == JSVAL_STRING)
             return true;
         debug_only_v(printf("string != tag%u", tag);)
         return false;
       default:
         JS_ASSERT(*m == JSVAL_OBJECT);
         if (tag == JSVAL_OBJECT)
             return true;
         debug_only_v(printf("object != tag%u", tag);)
@@ -4013,17 +4008,16 @@ TraceRecorder::varval(unsigned n) const
     JS_ASSERT(n < cx->fp->script->nslots);
     return cx->fp->slots[n];
 }
 
 jsval&
 TraceRecorder::stackval(int n) const
 {
     jsval* sp = cx->fp->regs->sp;
-    JS_ASSERT(size_t((sp + n) - StackBase(cx->fp)) < StackDepth(cx->fp->script));
     return sp[n];
 }
 
 LIns*
 TraceRecorder::scopeChain() const
 {
     return lir->insLoad(LIR_ldp,
                         lir->insLoad(LIR_ldp, cx_ins, offsetof(JSContext, fp)),
@@ -4123,22 +4117,74 @@ TraceRecorder::stack(int n)
 }
 
 void
 TraceRecorder::stack(int n, LIns* i)
 {
     set(&stackval(n), i, n >= 0);
 }
 
-LIns* TraceRecorder::f2i(LIns* f)
+LIns*
+TraceRecorder::alu(LOpcode v, jsdouble v0, jsdouble v1, LIns* s0, LIns* s1)
+{
+    if (v == LIR_fadd || v == LIR_fsub) {
+        jsdouble r;
+        if (v == LIR_fadd)
+            r = v0 + v1;
+        else
+            r = v0 - v1;
+        /*
+         * Calculate the result of the addition for the current values. If the
+         * value is not within the integer range, don't even try to demote 
+         * here.
+         */
+        if (!JSDOUBLE_IS_NEGZERO(r) && (jsint(r) == r) && isPromoteInt(s0) && isPromoteInt(s1)) {
+            LIns* d0 = ::demote(lir, s0);
+            LIns* d1 = ::demote(lir, s1);
+            /*
+             * If the inputs are constant, generate an integer constant for 
+             * this operation.
+             */
+            if (d0->isconst() && d1->isconst()) 
+                return lir->ins1(LIR_i2f, lir->insImm(jsint(r)));
+            /*
+             * Speculatively generate code that will perform the addition over
+             * the integer inputs as an integer addition/subtraction and exit
+             * if that fails.
+             */
+            v = (LOpcode)((int)v & ~LIR64);
+            LIns* result = lir->ins2(v, d0, d1);
+            if (!overflowSafe(d0) || !overflowSafe(d1)) {
+                lir->insGuard(LIR_xt, lir->ins1(LIR_ov, result),
+                              snapshot(OVERFLOW_EXIT));
+            }
+            return lir->ins1(LIR_i2f, result);
+        }
+        /*
+         * The result doesn't fit into the integer domain, so either generate
+         * a floating point constant or a floating point operation.
+         */
+        if (s0->isconst() && s1->isconst()) {
+            jsdpun u;
+            u.d = r;
+            return lir->insImmq(u.u64);
+        }
+        return lir->ins2(v, s0, s1);
+    }
+    return lir->ins2(v, s0, s1);
+}
+
+LIns*
+TraceRecorder::f2i(LIns* f)
 {
     return lir->insCall(&js_DoubleToInt32_ci, &f);
 }
 
-LIns* TraceRecorder::makeNumberInt32(LIns* f)
+LIns*
+TraceRecorder::makeNumberInt32(LIns* f)
 {
     JS_ASSERT(f->isQuad());
     LIns* x;
     if (!isPromote(f)) {
         x = f2i(f);
         guard(true, lir->ins2(LIR_feq, f, lir->ins1(LIR_i2f, x)), MISMATCH_EXIT);
     } else {
         x = ::demote(lir, f);
@@ -4155,35 +4201,36 @@ TraceRecorder::stringify(jsval& v)
 
     LIns* args[] = { v_ins, cx_ins };
     const CallInfo* ci;
     if (JSVAL_IS_NUMBER(v)) {
         ci = &js_NumberToString_ci;
     } else if (JSVAL_TAG(v) == JSVAL_BOOLEAN) {
         ci = &js_BooleanOrUndefinedToString_ci;
     } else {
-        JS_NOT_REACHED("caller of stringify should have used an imacro here");
+        /* We can't stringify objects here (use imacros instead), just return NULL. */
         return NULL;
     }
     v_ins = lir->insCall(ci, args);
     guard(false, lir->ins_eq0(v_ins), OOM_EXIT);
     return v_ins;
 }
 
 bool
 TraceRecorder::call_imacro(jsbytecode* imacro)
 {
     JSStackFrame* fp = cx->fp;
     JSFrameRegs* regs = fp->regs;
 
-    JS_ASSERT(!fp->imacpc);
-    fp->imacpc = regs->pc;
-    fp->flags |= JSFRAME_IMACRO_START;
-    regs->pc = imacro;
-    atoms = COMMON_ATOMS_START(&cx->runtime->atomState);
+    if (!fp->imacpc) {
+        fp->imacpc = regs->pc;
+        fp->flags |= JSFRAME_IMACRO_START;
+        regs->pc = imacro;
+        atoms = COMMON_ATOMS_START(&cx->runtime->atomState);
+    }
     return false;
 }
 
 bool
 TraceRecorder::ifop()
 {
     jsval& v = stackval(-1);
     LIns* v_ins = get(&v);
@@ -4279,17 +4326,17 @@ TraceRecorder::inc(jsval& v, LIns*& v_in
 TraceRecorder::inc(jsval& v, LIns*& v_ins, jsint incr, bool pre)
 {
     if (!isNumber(v))
         ABORT_TRACE("can only inc numbers");
 
     jsdpun u;
     u.d = jsdouble(incr);
 
-    LIns* v_after = lir->ins2(LIR_fadd, v_ins, lir->insImmq(u.u64));
+    LIns* v_after = alu(LIR_fadd, asNumber(v), incr, v_ins, lir->insImmq(u.u64));
 
     const JSCodeSpec& cs = js_CodeSpec[*cx->fp->regs->pc];
     JS_ASSERT(cs.ndefs == 1);
     stack(-cs.nuses, pre ? v_after : v_ins);
     v_ins = v_after;
     return true;
 }
 
@@ -4448,22 +4495,20 @@ TraceRecorder::cmp(LOpcode op, int flags
     // CMP_STRICT is set only for JSOP_STRICTEQ and JSOP_STRICTNE, which correspond to the
     // === and !== operators. negate is true for !== and false for ===. The strict equality
     // operators produce false if the types of the operands differ, i.e. if only one of 
     // them is a number. 
     if ((flags & CMP_STRICT) && getPromotedType(l) != getPromotedType(r)) {
         x = INS_CONST(negate);
         cond = negate;
     } else if (JSVAL_IS_STRING(l) || JSVAL_IS_STRING(r)) {
-        // The following cases always produce a constant false (or true if negated):
-        // - comparing a string against null
-        // - comparing a string against any boolean (including undefined)
-        if ((JSVAL_IS_NULL(l) && l_ins->isconst()) ||
-            (JSVAL_IS_NULL(r) && r_ins->isconst()) ||
-            (JSVAL_TAG(l) == JSVAL_BOOLEAN || JSVAL_TAG(r) == JSVAL_BOOLEAN)) {
+        // Comparing equality of a string against null always produces false.
+        if (op == LIR_feq &&
+            ((JSVAL_IS_NULL(l) && l_ins->isconst()) ||
+             (JSVAL_IS_NULL(r) && r_ins->isconst()))) {
             x = INS_CONST(negate);
             cond = negate;
         } else {
             if (!JSVAL_IS_STRING(l) || !JSVAL_IS_STRING(r))
                 ABORT_TRACE("unsupported type for cmp vs string");
 
             LIns* args[] = { r_ins, l_ins };
             if (op == LIR_feq)
@@ -4480,17 +4525,17 @@ TraceRecorder::cmp(LOpcode op, int flags
         fp = true;
 
         // TODO: coerce non-numbers to numbers if it's not string-on-string above
         jsdouble lnum;
         jsdouble rnum;
         LIns* args[] = { l_ins, cx_ins };
         if (l == JSVAL_NULL && l_ins->isconst()) {
             jsdpun u;
-            u.d = js_NaN;
+            u.d = (op == LIR_feq) ? js_NaN : 0.0;
             l_ins = lir->insImmq(u.u64);
         } else if (JSVAL_IS_STRING(l)) {
             l_ins = lir->insCall(&js_StringToNumber_ci, args);
         } else if (JSVAL_TAG(l) == JSVAL_BOOLEAN) {
             /*
              * What I really want here is for undefined to be type-specialized
              * differently from real booleans.  Failing that, I want to be able
              * to cmov on quads.  Failing that, I want to have small forward
@@ -4500,19 +4545,19 @@ TraceRecorder::cmp(LOpcode op, int flags
             l_ins = lir->insCall(&js_BooleanOrUndefinedToNumber_ci, args);
         } else if (!isNumber(l)) {
             ABORT_TRACE("unsupported LHS type for cmp vs number");
         }
         lnum = js_ValueToNumber(cx, &tmp[0]);
 
         args[0] = r_ins;
         args[1] = cx_ins;
-        if (r == JSVAL_NULL) {
+        if (r == JSVAL_NULL && r_ins->isconst()) {
             jsdpun u;
-            u.d = js_NaN;
+            u.d = (op == LIR_feq) ? js_NaN : 0.0;
             r_ins = lir->insImmq(u.u64);
         } else if (JSVAL_IS_STRING(r)) {
             r_ins = lir->insCall(&js_StringToNumber_ci, args);
         } else if (JSVAL_TAG(r) == JSVAL_BOOLEAN) {
             // See above for the sob story.
             r_ins = lir->insCall(&js_BooleanOrUndefinedToNumber_ci, args);
         } else if (!isNumber(r)) {
             ABORT_TRACE("unsupported RHS type for cmp vs number");
@@ -4621,50 +4666,60 @@ TraceRecorder::binary(LOpcode op)
         return call_imacro(binary_imacros.obj_any);
     }
     if (JSVAL_IS_OBJECT(r) && hasValueOfMethod(r))
         return call_imacro(binary_imacros.any_obj);
 
     bool intop = !(op & LIR64);
     LIns* a = get(&l);
     LIns* b = get(&r);
-    bool leftNumber = isNumber(l), rightNumber = isNumber(r);
+
+    bool leftIsNumber = isNumber(l);
+    jsdouble lnum = leftIsNumber ? asNumber(l) : 0;
+    
+    bool rightIsNumber = isNumber(r);
+    jsdouble rnum = rightIsNumber ? asNumber(r) : 0;
+    
     if ((op >= LIR_sub && op <= LIR_ush) ||  // sub, mul, (callh), or, xor, (not,) lsh, rsh, ush
         (op >= LIR_fsub && op <= LIR_fdiv)) { // fsub, fmul, fdiv
         LIns* args[2];
         if (JSVAL_IS_STRING(l)) {
             args[0] = a;
             args[1] = cx_ins;
             a = lir->insCall(&js_StringToNumber_ci, args);
-            leftNumber = true;
+            lnum = js_StringToNumber(cx, JSVAL_TO_STRING(l));
+            leftIsNumber = true;
         }
         if (JSVAL_IS_STRING(r)) {
             args[0] = b;
             args[1] = cx_ins;
             b = lir->insCall(&js_StringToNumber_ci, args);
-            rightNumber = true;
+            rnum = js_StringToNumber(cx, JSVAL_TO_STRING(r));
+            rightIsNumber = true;
         }
     }
     if (JSVAL_TAG(l) == JSVAL_BOOLEAN) {
         LIns* args[] = { a, cx_ins };
         a = lir->insCall(&js_BooleanOrUndefinedToNumber_ci, args);
-        leftNumber = true;
+        lnum = js_BooleanOrUndefinedToNumber(cx, JSVAL_TO_BOOLEAN(l));
+        leftIsNumber = true;
     }
     if (JSVAL_TAG(r) == JSVAL_BOOLEAN) {
         LIns* args[] = { b, cx_ins };
         b = lir->insCall(&js_BooleanOrUndefinedToNumber_ci, args);
-        rightNumber = true;
-    }
-    if (leftNumber && rightNumber) {
+        rnum = js_BooleanOrUndefinedToNumber(cx, JSVAL_TO_BOOLEAN(r));
+        rightIsNumber = true;
+    }
+    if (leftIsNumber && rightIsNumber) {
         if (intop) {
             LIns *args[] = { a };
             a = lir->insCall(op == LIR_ush ? &js_DoubleToUint32_ci : &js_DoubleToInt32_ci, args);
             b = f2i(b);
         }
-        a = lir->ins2(op, a, b);
+        a = alu(op, lnum, rnum, a, b);
         if (intop)
             a = lir->ins1(op == LIR_ush ? LIR_u2f : LIR_i2f, a);
         set(&l, a);
         return true;
     }
     return false;
 }
 
@@ -5546,17 +5601,19 @@ TraceRecorder::record_JSOP_NOT()
 TraceRecorder::record_JSOP_NOT()
 {
     jsval& v = stackval(-1);
     if (JSVAL_TAG(v) == JSVAL_BOOLEAN) {
         set(&v, lir->ins_eq0(lir->ins2i(LIR_eq, get(&v), 1)));
         return true;
     } 
     if (isNumber(v)) {
-        set(&v, lir->ins2(LIR_feq, get(&v), lir->insImmq(0)));
+        LIns* v_ins = get(&v);
+        set(&v, lir->ins2(LIR_or, lir->ins2(LIR_feq, v_ins, lir->insImmq(0)),
+                                  lir->ins_eq0(lir->ins2(LIR_feq, v_ins, v_ins))));
         return true;
     } 
     if (JSVAL_IS_OBJECT(v)) {
         set(&v, lir->ins_eq0(get(&v)));
         return true;
     }
     JS_ASSERT(JSVAL_IS_STRING(v));
     set(&v, lir->ins_eq0(lir->ins2(LIR_piand, 
@@ -6029,17 +6086,17 @@ TraceRecorder::record_JSOP_ELEMINC()
 TraceRecorder::record_JSOP_ELEMINC()
 {
     return incElem(1, false);
 }
 
 bool
 TraceRecorder::record_JSOP_NAMEDEC()
 {
-    return incName(-1, true);
+    return incName(-1, false);
 }
 
 bool
 TraceRecorder::record_JSOP_PROPDEC()
 {
     return incProp(-1, false);
 }
 
@@ -7152,91 +7209,49 @@ TraceRecorder::record_JSOP_THROW()
 {
     return false;
 }
 
 bool
 TraceRecorder::record_JSOP_IN()
 {
     jsval& rval = stackval(-1);
+    jsval& lval = stackval(-2);
+
     if (JSVAL_IS_PRIMITIVE(rval))
         ABORT_TRACE("JSOP_IN on non-object right operand");
-
-    jsval& lval = stackval(-2);
-    if (!JSVAL_IS_PRIMITIVE(lval))
-        ABORT_TRACE("JSOP_IN on E4X QName left operand");
+    JSObject* obj = JSVAL_TO_OBJECT(rval);
+    LIns* obj_ins = get(&rval);
 
     jsid id;
+    LIns* x;
     if (JSVAL_IS_INT(lval)) {
         id = INT_JSVAL_TO_JSID(lval);
-    } else {
-        if (!JSVAL_IS_STRING(lval))
-            ABORT_TRACE("non-string left operand to JSOP_IN");
+        LIns* args[] = { makeNumberInt32(get(&lval)), obj_ins, cx_ins };
+        x = lir->insCall(&js_HasNamedPropertyInt32_ci, args);
+    } else if (JSVAL_IS_STRING(lval)) {
         if (!js_ValueToStringId(cx, lval, &id))
-            return false;
-    }
-
-    // Expect what we see at trace recording time (hit or miss) to be the same
-    // when executing the trace. Use a builtin helper for named properties, as
-    // the for-in tracing code does. First, handle indexes in dense arrays as a
-    // special case.
-    JSObject* obj = JSVAL_TO_OBJECT(rval);
-    LIns* obj_ins = get(&rval);
-
-    bool cond;
-    LIns* x;
-    do {
-        if (guardDenseArray(obj, obj_ins, BRANCH_EXIT)) {
-            if (JSVAL_IS_INT(lval)) {
-                jsint idx = JSVAL_TO_INT(lval);
-                LIns* idx_ins = f2i(get(&lval));
-                LIns* dslots_ins = lir->insLoad(LIR_ldp, obj_ins, offsetof(JSObject, dslots));
-                if (!guardDenseArrayIndex(obj, idx, obj_ins, dslots_ins, idx_ins, MISMATCH_EXIT))
-                    ABORT_TRACE("dense array index out of bounds");
-
-                // We can't "see through" a hole to a possible Array.prototype
-                // property, so we must abort/guard.
-                if (obj->dslots[idx] == JSVAL_HOLE)
-                    ABORT_TRACE("can't see through hole in dense array");
-
-                LIns* addr_ins = lir->ins2(LIR_piadd, dslots_ins,
-                                           lir->ins2i(LIR_pilsh, idx_ins,
-                                                      (sizeof(jsval) == 4) ? 2 : 3));
-                guard(false,
-                      lir->ins2(LIR_eq, lir->insLoad(LIR_ldp, addr_ins, 0), INS_CONST(JSVAL_HOLE)),
-                      MISMATCH_EXIT);
-
-                cond = true;
-                x = INS_CONST(cond);
-                break;
-            }
-
-            // Not an index id, but a dense array -- go up to the proto. */
-            obj = STOBJ_GET_PROTO(obj);
-            obj_ins = stobj_get_fslot(obj_ins, JSSLOT_PROTO);
-        } else {
-            if (JSVAL_IS_INT(id))
-                ABORT_TRACE("INT in OBJ where OBJ is not a dense array");
-        }
-
-        JSObject* obj2;
-        JSProperty* prop;
-        if (!OBJ_LOOKUP_PROPERTY(cx, obj, id, &obj2, &prop))
-            ABORT_TRACE("OBJ_LOOKUP_PROPERTY failed in JSOP_IN");
-
-        cond = prop != NULL;
-        if (prop)
-            OBJ_DROP_PROPERTY(cx, obj2, prop);
-
+            ABORT_TRACE("left operand of JSOP_IN didn't convert to a string-id");
         LIns* args[] = { get(&lval), obj_ins, cx_ins };
         x = lir->insCall(&js_HasNamedProperty_ci, args);
-        guard(false, lir->ins2i(LIR_eq, x, JSVAL_TO_BOOLEAN(JSVAL_VOID)), OOM_EXIT);
-        x = lir->ins2i(LIR_eq, x, 1);
-    } while (0);
-
+    } else {
+        ABORT_TRACE("string or integer expected");
+    }        
+
+    guard(false, lir->ins2i(LIR_eq, x, JSVAL_TO_BOOLEAN(JSVAL_VOID)), OOM_EXIT);
+    x = lir->ins2i(LIR_eq, x, 1);
+
+    JSObject* obj2;
+    JSProperty* prop;
+    if (!OBJ_LOOKUP_PROPERTY(cx, obj, id, &obj2, &prop))
+        ABORT_TRACE("OBJ_LOOKUP_PROPERTY failed in JSOP_IN");
+    bool cond = prop != NULL;
+    if (prop)
+        OBJ_DROP_PROPERTY(cx, obj2, prop);
+    
     /* The interpreter fuses comparisons and the following branch,
        so we have to do that here as well. */
     fuseIf(cx->fp->regs->pc + 1, cond, x);
 
     /* We update the stack after the guard. This is safe since
        the guard bails out at the comparison and the interpreter
        will therefore re-execute the comparison. This way the
        value of the condition doesn't have to be calculated and
@@ -7799,16 +7814,20 @@ TraceRecorder::record_JSOP_CALLPROP()
     jsval& l = stackval(-1);
     JSObject* obj;
     LIns* obj_ins;
     LIns* this_ins;
     if (!JSVAL_IS_PRIMITIVE(l)) {
         obj = JSVAL_TO_OBJECT(l);
         obj_ins = get(&l);
         this_ins = obj_ins; // |this| for subsequent call
+        if (JSVAL_IS_NULL(l))
+            ABORT_TRACE("callprop on null");
+        if (!this_ins->isconstp())
+            guard(false, lir->ins_eq0(this_ins), MISMATCH_EXIT);
     } else {
         jsint i;
         debug_only(const char* protoname = NULL;)
         if (JSVAL_IS_STRING(l)) {
             i = JSProto_String;
             debug_only(protoname = "String.prototype";)
         } else if (JSVAL_IS_NUMBER(l)) {
             i = JSProto_Number;
diff -r 8b3caddca8f5 js/src/jstracer.h
--- a/js/src/jstracer.h	Sat Nov 15 23:56:49 2008 -0800
+++ b/js/src/jstracer.h	Sat Nov 22 15:25:48 2008 -0500
@@ -329,16 +329,18 @@ class TraceRecorder : public avmplus::GC
 
     nanojit::LIns* arg(unsigned n);
     void arg(unsigned n, nanojit::LIns* i);
     nanojit::LIns* var(unsigned n);
     void var(unsigned n, nanojit::LIns* i);
     nanojit::LIns* stack(int n);
     void stack(int n, nanojit::LIns* i);
 
+    nanojit::LIns* alu(nanojit::LOpcode op, jsdouble v0, jsdouble v1, 
+                       nanojit::LIns* s0, nanojit::LIns* s1);
     nanojit::LIns* f2i(nanojit::LIns* f);
     nanojit::LIns* makeNumberInt32(nanojit::LIns* f);
     nanojit::LIns* stringify(jsval& v);
 
     bool call_imacro(jsbytecode* imacro);
 
     bool ifop();
     bool switchop();
diff -r 8b3caddca8f5 js/src/jsversion.h
--- a/js/src/jsversion.h	Sat Nov 15 23:56:49 2008 -0800
+++ b/js/src/jsversion.h	Sat Nov 22 15:25:48 2008 -0500
@@ -236,8 +236,16 @@
 #endif
 
 /* Features that are present in all versions. */
 #define JS_HAS_RESERVED_JAVA_KEYWORDS   1
 #define JS_HAS_RESERVED_ECMA_KEYWORDS   1
 
 /* Feature-test macro for evolving destructuring support. */
 #define JS_HAS_DESTRUCTURING_SHORTHAND  (JS_HAS_DESTRUCTURING == 2)
+
+#ifndef JS_HAS_OPERATION_COUNT
+# if defined(MOZILLA_VERSION) || defined(JS_THREADSAFE)
+#  define JS_HAS_OPERATION_COUNT 0
+# else
+#  define JS_HAS_OPERATION_COUNT 1
+# endif
+#endif
diff -r 8b3caddca8f5 js/src/nanojit/LIR.cpp
--- a/js/src/nanojit/LIR.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/js/src/nanojit/LIR.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -1905,16 +1905,23 @@ namespace nanojit
 	{
 		uint32_t k;
 		LInsp found = exprs.find64(q, k);
 		if (found)
 			return found;
 		return exprs.add(out->insImmq(q), k);
 	}
 
+	LIns* CseFilter::ins0(LOpcode v)
+	{
+	    if (v == LIR_label)
+	        exprs.clear();
+	    return out->ins0(v);
+	}
+	
 	LIns* CseFilter::ins1(LOpcode v, LInsp a)
 	{
 		if (isCse(v)) {
 			NanoAssert(operandCount[v]==1);
 			uint32_t k;
 			LInsp found = exprs.find1(v, a, k);
 			if (found)
 				return found;
diff -r 8b3caddca8f5 js/src/nanojit/LIR.h
--- a/js/src/nanojit/LIR.h	Sat Nov 15 23:56:49 2008 -0800
+++ b/js/src/nanojit/LIR.h	Sat Nov 22 15:25:48 2008 -0500
@@ -649,16 +649,22 @@ namespace nanojit
 			return add(out->insStore(v, b, d));
 		}
 		LIns* insStorei(LInsp v, LInsp b, int32_t d) {
 			return add(out->insStorei(v, b, d));
 		}
         LIns* insAlloc(int32_t size) {
             return add(out->insAlloc(size));
         }
+        LIns* insImm(int32_t imm) {
+            return add(out->insImm(imm));
+        }
+        LIns* insImmq(uint64_t imm) {
+            return add(out->insImmq(imm));
+        }
     };
 
 #endif
 
 	class ExprFilter: public LirWriter
 	{
 	public:
 		ExprFilter(LirWriter *out) : LirWriter(out) {}
@@ -707,16 +713,17 @@ namespace nanojit
 
 	class CseFilter: public LirWriter
 	{
 	public:
 		LInsHashSet exprs;
 		CseFilter(LirWriter *out, avmplus::GC *gc);
 	    LIns* insImm(int32_t imm);
 	    LIns* insImmq(uint64_t q);
+	    LIns* ins0(LOpcode v);
 		LIns* ins1(LOpcode v, LInsp);
 		LIns* ins2(LOpcode v, LInsp, LInsp);
 		LIns* insLoad(LOpcode v, LInsp b, LInsp d);
 		LIns* insCall(const CallInfo *call, LInsp args[]);
 		LIns* insGuard(LOpcode op, LInsp cond, LIns *x);
 	};
 
 	class LirBuffer : public avmplus::GCFinalizedObject
diff -r 8b3caddca8f5 js/src/nanojit/Nativei386.cpp
--- a/js/src/nanojit/Nativei386.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/js/src/nanojit/Nativei386.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -1019,28 +1019,18 @@ namespace nanojit
 		LOpcode op = ins->opcode();			
 		LInsp lhs = ins->oprnd1();
 		LInsp rhs = ins->oprnd2();
 
 		Register rb = UnknownReg;
 		RegisterMask allow = GpRegs;
 		bool forceReg = (op == LIR_mul || !rhs->isconst());
 
-#ifdef NANOJIT_ARM
-		// Arm can't do an immediate op with immediates
-		// outside of +/-255 (for AND) r outside of
-		// 0..255 for others.
-		if (!forceReg)
-		{
-			if (rhs->isconst() && !isU8(rhs->constval()))
-				forceReg = true;
-		}
-#endif
-
-		if (lhs != rhs && forceReg)
+        /* Even if lhs == rhs && forceReg, shift instructions require ECX on the rhs. */
+		if ((lhs != rhs || (op == LIR_lsh || op == LIR_rsh || op == LIR_ush)) && forceReg)
 		{
 			if ((rb = asm_binop_rhs_reg(ins)) == UnknownReg) {
 				rb = findRegFor(rhs, allow);
 			}
 			allow &= ~rmask(rb);
 		}
 		else if ((op == LIR_add||op == LIR_addp) && lhs->isop(LIR_alloc) && rhs->isconst()) {
 			// add alloc+const, use lea
diff -r 8b3caddca8f5 js/src/trace-test.js
--- a/js/src/trace-test.js	Sat Nov 15 23:56:49 2008 -0800
+++ b/js/src/trace-test.js	Sat Nov 22 15:25:48 2008 -0500
@@ -31,16 +31,17 @@ function jitstatHandler(f)
     f("sideExitIntoInterpreter");
     f("typeMapMismatchAtEntry");
     f("returnToDifferentLoopHeader");
     f("traceTriggered");
     f("globalShapeMismatchAtEntry");
     f("treesTrashed");
     f("slotPromoted");
     f("unstableLoopVariable");
+    f("noCompatInnerTrees");
     f("breakLoopExits");
     f("returnLoopExits");
 }
 
 function test(f)
 {
   if (!testName || testName == f.name) {
     // Collect our jit stats
@@ -1861,16 +1862,78 @@ function testClosingRecursion() {
 function testClosingRecursion() {
     shortRecursiveLoop(false, 1);
     shortRecursiveLoop(true, 3);
     return true;
 }
 testClosingRecursion.expected = true;
 test(testClosingRecursion);
 
+// Test no assert or crash from outer recorders (bug 465145)
+function testBug465145() {
+	this.__defineSetter__("x", function(){});
+	this.watch("x", function(){});
+	y = this;
+	for (var z = 0; z < 2; ++z) { x = y };
+	this.__defineSetter__("x", function(){});
+	for (var z = 0; z < 2; ++z) { x = y };
+}
+
+function testTrueShiftTrue() {
+    var a = new Array(5);
+    for (var i=0;i<5;++i) a[i] = "" + (true << true);
+    return a.join(",");
+}
+testTrueShiftTrue.expected = "2,2,2,2,2";
+test(testTrueShiftTrue);
+
+// Test no assert or crash
+function testBug465261() {
+    for (let z = 0; z < 2; ++z) { for each (let x in [0, true, (void 0), 0, (void
+    0)]) { if(x){} } };
+    return true;
+}
+testBug465261.expected = true;
+test(testBug465261);
+
+function testBug465272() {
+    var a = new Array(5);
+    for (j=0;j<5;++j) a[j] = "" + ((5) - 2);
+    return a.join(",");
+}
+testBug465272.expected = "3,3,3,3,3"
+test(testBug465272);
+
+function testBug465483() {
+	var a = new Array(4);
+	var c = 0;
+	for each (i in [4, 'a', 'b', (void 0)]) a[c++] = '' + (i + i);
+	return a.join(',');
+}
+testBug465483.expected = '8,aa,bb,NaN';
+test(testBug465483);
+
+function testNullCallee() {
+    try {
+        function f() {
+            var x = new Array(5);
+            for (var i = 0; i < 5; i++)
+                x[i] = a[i].toString();
+            return x.join(',');
+        }
+        f([[1],[2],[3],[4],[5]]);
+        f([null, null, null, null, null]);
+    } catch (e) {
+        return true;
+    }
+    return false;
+}
+testNullCallee.expected = true;
+test(testNullCallee);
+
 // BEGIN MANDELBROT STUFF
 // XXXbz I would dearly like to wrap it up into a function to avoid polluting
 // the global scope, but the function ends up heavyweight, and then we lose on
 // the jit.
 load("mandelbrot-results.js");
 //function testMandelbrotAll() {
   // Configuration options that affect which codepaths we follow.
   var doImageData = true;
@@ -2390,21 +2453,202 @@ function testBoxDoubleWithDoubleSizedInt
   return a.join(",");
 }
 testBoxDoubleWithDoubleSizedInt.expected = "1518500249,1518500249,1518500249";
 test(testBoxDoubleWithDoubleSizedInt);
 
 function testObjectOrderedCmp()
 {
   var a = new Array(5);
-  for(i=0;i<5;++i) a[i] = ({} < {});
+  for(var i=0;i<5;++i) a[i] = ({} < {});
   return a.join(",");
 }
 testObjectOrderedCmp.expected = "false,false,false,false,false";
 test(testObjectOrderedCmp);
+
+function testObjectOrderedCmp2()
+{
+  var a = new Array(5);
+  for(var i=0;i<5;++i) a[i] = ("" <= null);
+  return a.join(",");
+}
+testObjectOrderedCmp2.expected = "true,true,true,true,true";
+test(testObjectOrderedCmp2);
+
+function testLogicalNotNaN() {
+    var i = 0;
+    var a = new Array(5);
+    while (i < a.length)
+        a[i++] = !NaN;
+    return a.join();
+}
+testLogicalNotNaN.expected = "true,true,true,true,true";
+test(testLogicalNotNaN);
+
+function testStringToInt32() {
+    var s = "";
+    for (let j = 0; j < 5; ++j) s += ("1e+81" ^  3);
+    return s;
+}
+testStringToInt32.expected = "33333";
+test(testStringToInt32);
+
+function testIn() {
+    var array = [3];
+    var obj = { "-1": 5, "1.7": 3, "foo": 5, "1": 7 };
+    var a = [];
+    for (let j = 0; j < 5; ++j) {
+        a.push("0" in array);
+        a.push(-1 in obj);
+        a.push(1.7 in obj);
+        a.push("foo" in obj);
+        a.push(1 in obj);
+        a.push("1" in array);  
+        a.push(-2 in obj);
+        a.push(2.7 in obj);
+        a.push("bar" in obj);
+        a.push(2 in obj);    
+    }
+    return a.join(",");
+}
+testIn.expected = "true,true,true,true,true,false,false,false,false,false,true,true,true,true,true,false,false,false,false,false,true,true,true,true,true,false,false,false,false,false,true,true,true,true,true,false,false,false,false,false,true,true,true,true,true,false,false,false,false,false";
+test(testIn);
+
+function testBranchCse() {
+    empty = [];
+    out = [];
+    for (var j=0;j<10;++j) { empty[42]; out.push((1 * (1)) | ""); }
+    return out.join(",");
+}
+testBranchCse.expected = "1,1,1,1,1,1,1,1,1,1";
+test(testBranchCse);
+
+function testMulOverflow() {
+    var a = [];
+    for (let j=0;j<5;++j) a.push(0 | ((0x60000009) * 0x60000009));
+    return a.join(",");
+}
+testMulOverflow.expected = "-1073741824,-1073741824,-1073741824,-1073741824,-1073741824";
+test(testMulOverflow);
+
+function testThinLoopDemote() {
+    function f()
+    {
+        var k = 1;
+        for (var n = 0; n < 2; n++) {
+            k = (k * 10);
+        }
+        return k;
+    }
+    f();
+    return f();
+}
+testThinLoopDemote.expected = 100;
+testThinLoopDemote.jitstats = {
+    recorderStarted: 3,
+    recorderAborted: 0,
+    traceCompleted: 1,
+    traceTriggered: 0,
+    unstableLoopVariable: 2
+};
+test(testThinLoopDemote);
+
+var global = this;
+function testWeirdDateParseOuter()
+{
+    var vDateParts = ["11", "17", "2008"];
+    var out = [];
+    for (var vI = 0; vI < vDateParts.length; vI++) {
+	out.push(testWeirdDateParseInner(vDateParts[vI]));
+    }
+    /* Mutate the global shape so we fall off trace; this causes
+     * additional oddity */
+    global.x = Math.random();
+    return out;
+} 
+function testWeirdDateParseInner(pVal)
+{
+    var vR = 0;
+    for (var vI = 0; vI < pVal.length; vI++) {
+	var vC = pVal.charAt(vI);
+	if ((vC >= '0') && (vC <= '9'))
+	    vR = (vR * 10) + parseInt(vC);
+    }
+    return vR;
+}
+function testWeirdDateParse() {
+    var result = [];
+    result.push(testWeirdDateParseInner("11"));
+    result.push(testWeirdDateParseInner("17"));
+    result.push(testWeirdDateParseInner("2008"));
+    result.push(testWeirdDateParseInner("11"));
+    result.push(testWeirdDateParseInner("17"));
+    result.push(testWeirdDateParseInner("2008"));
+    result = result.concat(testWeirdDateParseOuter());
+    result = result.concat(testWeirdDateParseOuter());
+    result.push(testWeirdDateParseInner("11"));
+    result.push(testWeirdDateParseInner("17"));
+    result.push(testWeirdDateParseInner("2008"));
+    return result.join(",");
+}
+testWeirdDateParse.expected = "11,17,2008,11,17,2008,11,17,2008,11,17,2008,11,17,2008";
+testWeirdDateParse.jitstats = {
+    recorderStarted: 10,
+    recorderAborted: 1,
+    traceCompleted: 5,
+    traceTriggered: 13,
+    unstableLoopVariable: 6,
+    noCompatInnerTrees: 1
+};
+test(testWeirdDateParse);
+
+function testUndemotableBinaryOp() {
+    var out = [];
+    for (let j = 0; j < 5; ++j) { out.push(6 - ((void 0) ^ 0x80000005)); }
+    return out.join(",");
+}
+testUndemotableBinaryOp.expected = "2147483649,2147483649,2147483649,2147483649,2147483649";
+test(testUndemotableBinaryOp);
+
+function testNullRelCmp() {
+    var out = [];
+    for(j=0;j<3;++j) { out.push(3 > null); out.push(3 < null); out.push(0 == null); out.push(3 == null); }
+    return out.join(",");
+}
+testNullRelCmp.expected = "true,false,false,false,true,false,false,false,true,false,false,false";
+test(testNullRelCmp);
+
+function testEqFalseEmptyString() {
+    var x = [];
+    for (var i=0;i<5;++i) x.push(false == "");
+    return x.join(",");
+}
+testEqFalseEmptyString.expected = "true,true,true,true,true";
+test(testEqFalseEmptyString);
+
+function testIncDec2(ii) {
+    var x = [];
+    for (let j=0;j<5;++j) { 
+	ii=j;
+	jj=j; 
+	var kk=j; 
+	x.push(ii--);
+	x.push(jj--); 
+	x.push(kk--); 
+	x.push(++ii);
+	x.push(++jj); 
+	x.push(++kk); 
+    }
+    return x.join(",");
+}
+function testIncDec() {
+    return testIncDec2(0);
+}
+testIncDec.expected = "0,0,0,0,0,0,1,1,1,1,1,1,2,2,2,2,2,2,3,3,3,3,3,3,4,4,4,4,4,4";
+test(testIncDec);
 
 /* NOTE: Keep this test last, since it screws up all for...in loops after it. */
 function testGlobalProtoAccess() {
     return "ok";
 }
 this.__proto__.a = 3; for (var j = 0; j < 4; ++j) { [a]; }
 testGlobalProtoAccess.expected = "ok";
 test(testGlobalProtoAccess);
diff -r 8b3caddca8f5 js/src/xpconnect/idl/nsIXPConnect.idl
--- a/js/src/xpconnect/idl/nsIXPConnect.idl	Sat Nov 15 23:56:49 2008 -0800
+++ b/js/src/xpconnect/idl/nsIXPConnect.idl	Sat Nov 22 15:25:48 2008 -0500
@@ -65,16 +65,17 @@
       native JSVal(jsval);
 [ptr] native JSClassConstPtr(const JSClass);
       native JSGetObjectOps(JSGetObjectOps);
       native JSID(jsid);
 [ptr] native voidPtrPtr(void*);
 [ptr] native nsScriptObjectTracerPtr(nsScriptObjectTracer);
 [ref] native nsCCTraversalCallbackRef(nsCycleCollectionTraversalCallback);
 [ptr] native nsAXPCNativeCallContextPtr(nsAXPCNativeCallContext);
+      native PRIntervalTime(PRIntervalTime);
 
 /***************************************************************************/
 
 %{ C++
 /***************************************************************************/
 #define GENERATE_XPC_FAILURE(x) \
             (NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_XPCONNECT,x))
 
@@ -400,17 +401,17 @@ interface nsIXPCFunctionThisTranslator :
 %{ C++
 // For use with the service manager
 // {CB6593E0-F9B2-11d2-BDD6-000064657374}
 #define NS_XPCONNECT_CID \
 { 0xcb6593e0, 0xf9b2, 0x11d2, \
     { 0xbd, 0xd6, 0x0, 0x0, 0x64, 0x65, 0x73, 0x74 } }
 %}
 
-[uuid(d4c6bc06-2a4f-4315-90ec-d12904aca046)]
+[uuid(eb95710a-e112-44ae-abe1-6f8dfb58d7f8)]
 interface nsIXPConnect : nsISupports
 {
 %{ C++
   NS_DEFINE_STATIC_CID_ACCESSOR(NS_XPCONNECT_CID)
 %}
 
     void
     initClasses(in JSContextPtr aJSContext,
@@ -762,9 +763,25 @@ interface nsIXPConnect : nsISupports
      *     interfaceCount are like what nsIClassInfo.getInterfaces returns.
      */
     [noscript,notxpcom] PRBool defineDOMQuickStubs(
         in JSContextPtr cx,
         in JSObjectPtr proto,
         in PRUint32 flags,
         in PRUint32 interfaceCount,
         [array, size_is(interfaceCount)] in nsIIDPtr interfaceArray);
+
+    /**
+     * Returns the value of the watchdog limit for the specified context.
+     * @param cx
+     *     A context
+     */
+    [noscript,notxpcom] PRIntervalTime getWatchdogLimit(in JSContextPtr cx);
+
+    /**
+     * Sets a new value of the watchdog limit.
+     * @param cx
+     *     A context
+     * @param limit
+     *     New value of the watchdog limit.
+     */
+    [noscript,notxpcom] PRBool setWatchdogLimit(in JSContextPtr cx, in PRIntervalTime limit);
 };
diff -r 8b3caddca8f5 js/src/xpconnect/loader/JSON.jsm
--- a/js/src/xpconnect/loader/JSON.jsm	Sat Nov 15 23:56:49 2008 -0800
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,178 +0,0 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla code.
- *
- * The Initial Developer of the Original Code is
- * Simon Bünzli <zeniko@gmail.com>
- * Portions created by the Initial Developer are Copyright (C) 2006-2007
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-/**
- * Utilities for JavaScript code to handle JSON content.
- * See http://www.json.org/ for comprehensive information about JSON.
- *
- * Import this module through
- *
- * Components.utils.import("resource://gre/modules/JSON.jsm");
- *
- * Usage:
- *
- * var newJSONString = JSONModule.toString( GIVEN_JAVASCRIPT_OBJECT );
- * var newJavaScriptObject = JSONModule.fromString( GIVEN_JSON_STRING );
- *
- * Note: For your own safety, Objects/Arrays returned by
- *       JSONModule.fromString aren't instanceof Object/Array.
- */
-
-var EXPORTED_SYMBOLS = ["JSONModule"];
-
-// The following code is a loose adaption of Douglas Crockford's code
-// from http://www.json.org/json.js (public domain'd)
-
-// Notable differences:
-// * Unserializable values such as |undefined| or functions aren't
-//   silently dropped but always lead to a TypeError.
-// * An optional key blacklist has been added to JSON.toString
-
-var JSONModule = {
-  /**
-   * Converts a JavaScript object into a JSON string.
-   *
-   * @param aJSObject is the object to be converted
-   * @param aKeysToDrop is an optional array of keys which will be
-   *                    ignored in all objects during the serialization
-   * @return the object's JSON representation
-   *
-   * Note: aJSObject MUST not contain cyclic references.
-   */
-  toString: function JSON_toString(aJSObject, aKeysToDrop) {
-    // we use a single string builder for efficiency reasons
-    var pieces = [];
-    
-    // this recursive function walks through all objects and appends their
-    // JSON representation (in one or several pieces) to the string builder
-    function append_piece(aObj) {
-      if (typeof aObj == "string") {
-        aObj = aObj.replace(/[\\"\x00-\x1F\u0080-\uFFFF]/g, function($0) {
-          // use the special escape notation if one exists, otherwise
-          // produce a general unicode escape sequence
-          switch ($0) {
-          case "\b": return "\\b";
-          case "\t": return "\\t";
-          case "\n": return "\\n";
-          case "\f": return "\\f";
-          case "\r": return "\\r";
-          case '"':  return '\\"';
-          case "\\": return "\\\\";
-          }
-          return "\\u" + ("0000" + $0.charCodeAt(0).toString(16)).slice(-4);
-        });
-        pieces.push('"' + aObj + '"')
-      }
-      else if (typeof aObj == "boolean") {
-        pieces.push(aObj ? "true" : "false");
-      }
-      else if (typeof aObj == "number" && isFinite(aObj)) {
-        // there is no representation for infinite numbers or for NaN!
-        pieces.push(aObj.toString());
-      }
-      else if (aObj === null) {
-        pieces.push("null");
-      }
-      // if it looks like an array, treat it as such - this is required
-      // for all arrays from either outside this module or a sandbox
-      else if (aObj instanceof Array ||
-               typeof aObj == "object" && "length" in aObj &&
-               (aObj.length === 0 || aObj[aObj.length - 1] !== undefined)) {
-        pieces.push("[");
-        for (var i = 0; i < aObj.length; i++) {
-          arguments.callee(aObj[i]);
-          pieces.push(",");
-        }
-        if (aObj.length > 0)
-          pieces.pop(); // drop the trailing colon
-        pieces.push("]");
-      }
-      else if (typeof aObj == "object") {
-        pieces.push("{");
-        for (var key in aObj) {
-          // allow callers to pass objects containing private data which
-          // they don't want the JSON string to contain (so they don't
-          // have to manually pre-process the object)
-          if (aKeysToDrop && aKeysToDrop.indexOf(key) != -1)
-            continue;
-          
-          arguments.callee(key.toString());
-          pieces.push(":");
-          arguments.callee(aObj[key]);
-          pieces.push(",");
-        }
-        if (pieces[pieces.length - 1] == ",")
-          pieces.pop(); // drop the trailing colon
-        pieces.push("}");
-      }
-      else {
-        throw new TypeError("No JSON representation for this object!");
-      }
-    }
-    append_piece(aJSObject);
-    
-    return pieces.join("");
-  },
-
-  /**
-   * Converts a JSON string into a JavaScript object.
-   *
-   * @param aJSONString is the string to be converted
-   * @return a JavaScript object for the given JSON representation
-   */
-  fromString: function JSON_fromString(aJSONString) {
-    if (!this.isMostlyHarmless(aJSONString))
-      throw new SyntaxError("No valid JSON string!");
-    
-    var s = new Components.utils.Sandbox("about:blank");
-    return Components.utils.evalInSandbox("(" + aJSONString + ")", s);
-  },
-
-  /**
-   * Checks whether the given string contains potentially harmful
-   * content which might be executed during its evaluation
-   * (no parser, thus not 100% safe! Best to use a Sandbox for evaluation)
-   *
-   * @param aString is the string to be tested
-   * @return a boolean
-   */
-  isMostlyHarmless: function JSON_isMostlyHarmless(aString) {
-    const maybeHarmful = /[^,:{}\[\]0-9.\-+Eaeflnr-u \n\r\t]/;
-    const jsonStrings = /"(\\.|[^"\\\n\r])*"/g;
-    
-    return !maybeHarmful.test(aString.replace(jsonStrings, ""));
-  }
-};
diff -r 8b3caddca8f5 js/src/xpconnect/loader/Makefile.in
--- a/js/src/xpconnect/loader/Makefile.in	Sat Nov 15 23:56:49 2008 -0800
+++ b/js/src/xpconnect/loader/Makefile.in	Sat Nov 22 15:25:48 2008 -0500
@@ -51,13 +51,13 @@ REQUIRES	= xpcom \
 		  xpconnect \
 		  js \
 		  caps \
 		  necko \
 		  $(NULL)
 
 CPPSRCS		= mozJSComponentLoader.cpp mozJSSubScriptLoader.cpp
 
-EXTRA_JS_MODULES = XPCOMUtils.jsm JSON.jsm ISO8601DateUtils.jsm
+EXTRA_JS_MODULES = XPCOMUtils.jsm ISO8601DateUtils.jsm
 
 include $(topsrcdir)/config/rules.mk
 
 DEFINES		+= -DJSFILE -DJS_THREADSAFE
diff -r 8b3caddca8f5 js/src/xpconnect/public/nsAutoJSValHolder.h
--- a/js/src/xpconnect/public/nsAutoJSValHolder.h	Sat Nov 15 23:56:49 2008 -0800
+++ b/js/src/xpconnect/public/nsAutoJSValHolder.h	Sat Nov 22 15:25:48 2008 -0500
@@ -114,22 +114,22 @@ public:
   /**
    * Determine if Hold has been called.
    */
   JSBool IsHeld() {
     return mHeld;
   }
 
   /**
-   * Pretend to be a JSObject*.
+   * Explicit JSObject* conversion.
    */
-  operator JSObject*() const {
+  JSObject* ToJSObject() const {
     return JSVAL_IS_OBJECT(mVal)
          ? JSVAL_TO_OBJECT(mVal)
-         : JSVAL_NULL;
+         : NULL;
   }
 
   /**
    * Pretend to be a jsval.
    */
   operator jsval() const { return mVal; }
 
   nsAutoJSValHolder &operator=(JSObject* aOther) {
diff -r 8b3caddca8f5 js/src/xpconnect/src/nsXPConnect.cpp
--- a/js/src/xpconnect/src/nsXPConnect.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/js/src/xpconnect/src/nsXPConnect.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -314,23 +314,23 @@ static PRBool IIDTester(nsIInterfaceInfo
 
 static PRBool NameTester(nsIInterfaceInfoManager* manager, const void* data,
                       nsIInterfaceInfo** info)
 {
     return NS_SUCCEEDED(manager->GetInfoForName((const char *) data, info)) &&
            *info;
 }
 
-static nsresult FindInfo(InfoTester tester, const void* data, 
+static nsresult FindInfo(InfoTester tester, const void* data,
                          nsIInterfaceInfoSuperManager* iism,
                          nsIInterfaceInfo** info)
 {
     if(tester(iism, data, info))
         return NS_OK;
-    
+
     // If not found, then let's ask additional managers.
 
     PRBool yes;
     nsCOMPtr<nsISimpleEnumerator> list;
 
     if(NS_SUCCEEDED(iism->HasAdditionalManagers(&yes)) && yes &&
        NS_SUCCEEDED(iism->EnumerateAdditionalManagers(getter_AddRefs(list))) &&
        list)
@@ -340,19 +340,19 @@ static nsresult FindInfo(InfoTester test
 
         while(NS_SUCCEEDED(list->HasMoreElements(&more)) && more &&
               NS_SUCCEEDED(list->GetNext(getter_AddRefs(current))) && current)
         {
             if(tester(current, data, info))
                 return NS_OK;
         }
     }
-    
+
     return NS_ERROR_NO_INTERFACE;
-}    
+}
 
 nsresult
 nsXPConnect::GetInfoForIID(const nsIID * aIID, nsIInterfaceInfo** info)
 {
     return FindInfo(IIDTester, aIID, mInterfaceInfoManager, info);
 }
 
 nsresult
@@ -429,17 +429,17 @@ nsXPConnect::Collect()
     //
     //
     // We split up garbage collection into 3 phases (1, 3 and 4) and do cycle
     // collection between the first 2 phases of garbage collection:
     //
     // 1. marking of the roots in category 1 by having the JS GC do its marking
     // 2. cycle collection
     // 3. marking of the roots in category 2 by
-    //    XPCJSRuntime::TraceXPConnectRoots 
+    //    XPCJSRuntime::TraceXPConnectRoots
     // 4. sweeping of unmarked JS objects
     //
     // During cycle collection, marked JS objects (and the objects they hold)
     // will be colored black. White objects holding roots from category 2 will
     // be forgotten by XPConnect (in the unlink callback of the white objects).
     // During phase 3 we'll only mark black objects holding JS objects (white
     // objects were forgotten) and white JS objects will be swept during
     // phase 4.
@@ -515,17 +515,17 @@ NoteJSRoot(JSTracer *trc, void *thing, u
     }
     else if(kind != JSTRACE_DOUBLE && kind != JSTRACE_STRING)
     {
         JS_TraceChildren(trc, thing, kind);
     }
 }
 #endif
 
-nsresult 
+nsresult
 nsXPConnect::BeginCycleCollection(nsCycleCollectionTraversalCallback &cb)
 {
 #ifdef DEBUG_CC
     NS_ASSERTION(!mJSRoots.ops, "Didn't call FinishCollection?");
 
     if(!mCycleCollectionContext)
     {
         // Being called from nsCycleCollector::ExplainLiveExpectedGarbage.
@@ -583,17 +583,17 @@ nsXPConnect::BeginCycleCollection(nsCycl
 #ifndef XPCONNECT_STANDALONE
 void
 nsXPConnect::RecordTraversal(void *p, nsISupports *s)
 {
     mScopes.Put(p, s);
 }
 #endif
 
-nsresult 
+nsresult
 nsXPConnect::FinishCycleCollection()
 {
 #ifdef DEBUG_CC
     if(mExplainCycleCollectionContext)
     {
         mCycleCollectionContext = nsnull;
         mExplainCycleCollectionContext = nsnull;
 
@@ -870,17 +870,17 @@ nsXPConnect::Traverse(void *p, nsCycleCo
 
     TraversalTracer trc(cb);
 
     JS_TRACER_INIT(&trc, cx, NoteJSChild);
     JS_TraceChildren(&trc, p, traceKind);
 
     if(traceKind != JSTRACE_OBJECT)
         return NS_OK;
-    
+
     JSObject *obj = static_cast<JSObject*>(p);
     JSClass* clazz = OBJ_GET_CLASS(cx, obj);
 
     if(clazz == &XPC_WN_Tearoff_JSClass)
     {
         // A tearoff holds a strong reference to its native object
         // (see XPCWrappedNative::FlatJSObjectFinalized). Its XPCWrappedNative
         // will be held alive through the parent of the JSObject of the tearoff.
@@ -1200,17 +1200,17 @@ nsXPConnect::WrapNative(JSContext * aJSC
         return rv;
 
 #ifdef DEBUG
     JSObject* returnObj;
     (*_retval)->GetJSObject(&returnObj);
     NS_ASSERTION(!XPCNativeWrapper::IsNativeWrapper(returnObj),
                  "Shouldn't be returning a native wrapper here");
 #endif
-    
+
     return NS_OK;
 }
 
 /* void wrapJS (in JSContextPtr aJSContext, in JSObjectPtr aJSObj, in nsIIDRef aIID, [iid_is (aIID), retval] out nsQIResult result); */
 NS_IMETHODIMP
 nsXPConnect::WrapJS(JSContext * aJSContext,
                     JSObject * aJSObj,
                     const nsIID & aIID,
@@ -1687,17 +1687,17 @@ nsXPConnect::GetFunctionThisTranslator(c
         old = map->Find(aIID);
         NS_IF_ADDREF(old);
         *_retval = old;
     }
     return NS_OK;
 }
 
 /* void setSafeJSContextForCurrentThread (in JSContextPtr cx); */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPConnect::SetSafeJSContextForCurrentThread(JSContext * cx)
 {
     XPCCallContext ccx(NATIVE_CALLER);
     if(!ccx.IsValid())
         return UnexpectedFailure(NS_ERROR_FAILURE);
     return ccx.GetThreadData()->GetJSContextStack()->SetSafeJSContext(cx);
 }
 
@@ -1708,20 +1708,20 @@ nsXPConnect::ClearAllWrappedNativeSecuri
     XPCCallContext ccx(NATIVE_CALLER);
     if(!ccx.IsValid())
         return UnexpectedFailure(NS_ERROR_FAILURE);
 
     return XPCWrappedNativeScope::ClearAllWrappedNativeSecurityPolicies(ccx);
 }
 
 /* void restoreWrappedNativePrototype (in JSContextPtr aJSContext, in JSObjectPtr aScope, in nsIClassInfo aClassInfo, in nsIXPConnectJSObjectHolder aPrototype); */
-NS_IMETHODIMP 
-nsXPConnect::RestoreWrappedNativePrototype(JSContext * aJSContext, 
-                                           JSObject * aScope, 
-                                           nsIClassInfo * aClassInfo, 
+NS_IMETHODIMP
+nsXPConnect::RestoreWrappedNativePrototype(JSContext * aJSContext,
+                                           JSObject * aScope,
+                                           nsIClassInfo * aClassInfo,
                                            nsIXPConnectJSObjectHolder * aPrototype)
 {
     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
     if(!ccx.IsValid())
         return UnexpectedFailure(NS_ERROR_FAILURE);
 
     if(!aClassInfo || !aPrototype)
         return UnexpectedFailure(NS_ERROR_INVALID_ARG);
@@ -1869,43 +1869,43 @@ nsXPConnect::GetXPCWrappedNativeJSClassI
     *clazz = &XPC_WN_NoHelper_JSClass.base;
     *ops1 = XPC_WN_GetObjectOpsNoCall;
     *ops2 = XPC_WN_GetObjectOpsWithCall;
 
     return NS_OK;
 }
 
 /* nsIXPConnectJSObjectHolder getWrappedNativePrototype (in JSContextPtr aJSContext, in JSObjectPtr aScope, in nsIClassInfo aClassInfo); */
-NS_IMETHODIMP 
-nsXPConnect::GetWrappedNativePrototype(JSContext * aJSContext, 
-                                       JSObject * aScope, 
-                                       nsIClassInfo *aClassInfo, 
+NS_IMETHODIMP
+nsXPConnect::GetWrappedNativePrototype(JSContext * aJSContext,
+                                       JSObject * aScope,
+                                       nsIClassInfo *aClassInfo,
                                        nsIXPConnectJSObjectHolder **_retval)
 {
     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
     if(!ccx.IsValid())
         return UnexpectedFailure(NS_ERROR_FAILURE);
 
     XPCWrappedNativeScope* scope =
         XPCWrappedNativeScope::FindInJSObjectScope(ccx, aScope);
     if(!scope)
         return UnexpectedFailure(NS_ERROR_FAILURE);
 
     XPCNativeScriptableCreateInfo sciProto;
     XPCWrappedNative::GatherProtoScriptableCreateInfo(aClassInfo, &sciProto);
 
     AutoMarkingWrappedNativeProtoPtr proto(ccx);
-    proto = XPCWrappedNativeProto::GetNewOrUsed(ccx, scope, aClassInfo, 
+    proto = XPCWrappedNativeProto::GetNewOrUsed(ccx, scope, aClassInfo,
                                                 &sciProto, JS_FALSE,
                                                 OBJ_IS_NOT_GLOBAL);
     if(!proto)
         return UnexpectedFailure(NS_ERROR_FAILURE);
 
     nsIXPConnectJSObjectHolder* holder;
-    *_retval = holder = XPCJSObjectHolder::newHolder(ccx, 
+    *_retval = holder = XPCJSObjectHolder::newHolder(ccx,
                                                      proto->GetJSProtoObject());
     if(!holder)
         return UnexpectedFailure(NS_ERROR_FAILURE);
 
     NS_ADDREF(holder);
     return NS_OK;
 }
 
@@ -1966,53 +1966,53 @@ nsXPConnect::UpdateXOWs(JSContext* aJSCo
         if(!PerformOp(aJSContext, aWay, cur->obj))
             return NS_ERROR_FAILURE;
     }
 
     return NS_OK;
 }
 
 /* void releaseJSContext (in JSContextPtr aJSContext, in PRBool noGC); */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPConnect::ReleaseJSContext(JSContext * aJSContext, PRBool noGC)
 {
     NS_ASSERTION(aJSContext, "bad param");
     XPCPerThreadData* tls = XPCPerThreadData::GetData(aJSContext);
     if(tls)
     {
         XPCCallContext* ccx = nsnull;
-        for(XPCCallContext* cur = tls->GetCallContext(); 
-            cur; 
+        for(XPCCallContext* cur = tls->GetCallContext();
+            cur;
             cur = cur->GetPrevCallContext())
         {
             if(cur->GetJSContext() == aJSContext)
             {
                 ccx = cur;
                 // Keep looping to find the deepest matching call context.
             }
         }
-    
+
         if(ccx)
         {
 #ifdef DEBUG_xpc_hacker
-            printf("!xpc - deferring destruction of JSContext @ %p\n", 
+            printf("!xpc - deferring destruction of JSContext @ %p\n",
                    (void *)aJSContext);
 #endif
             ccx->SetDestroyJSContextInDestructor(JS_TRUE);
             JS_ClearNewbornRoots(aJSContext);
             return NS_OK;
         }
         // else continue on and synchronously destroy the JSContext ...
 
-        NS_ASSERTION(!tls->GetJSContextStack() || 
+        NS_ASSERTION(!tls->GetJSContextStack() ||
                      !tls->GetJSContextStack()->
                         DEBUG_StackHasJSContext(aJSContext),
                      "JSContext still in threadjscontextstack!");
     }
-    
+
     if(noGC)
         JS_DestroyContextNoGC(aJSContext);
     else
         JS_DestroyContext(aJSContext);
     return NS_OK;
 }
 
 /* void debugDump (in short depth); */
@@ -2123,62 +2123,62 @@ nsXPConnect::DebugDumpEvalInJSStackFrame
         printf("there is no JSContext on the nsIThreadJSContextStack!\n");
     else
         xpc_DumpEvalInJSStackFrame(cx, aFrameNumber, aSourceText);
 
     return NS_OK;
 }
 
 /* JSVal variantToJS (in JSContextPtr ctx, in JSObjectPtr scope, in nsIVariant value); */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPConnect::VariantToJS(JSContext* ctx, JSObject* scope, nsIVariant* value, jsval* _retval)
 {
     NS_PRECONDITION(ctx, "bad param");
     NS_PRECONDITION(scope, "bad param");
     NS_PRECONDITION(value, "bad param");
     NS_PRECONDITION(_retval, "bad param");
 
     XPCCallContext ccx(NATIVE_CALLER, ctx);
     if(!ccx.IsValid())
         return NS_ERROR_FAILURE;
 
     nsresult rv = NS_OK;
     if(!XPCVariant::VariantDataToJS(ccx, value, scope, &rv, _retval))
     {
-        if(NS_FAILED(rv)) 
+        if(NS_FAILED(rv))
             return rv;
 
         return NS_ERROR_FAILURE;
     }
 
     return NS_OK;
 }
 
 /* nsIVariant JSToVariant (in JSContextPtr ctx, in JSVal value); */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPConnect::JSToVariant(JSContext* ctx, jsval value, nsIVariant** _retval)
 {
     NS_PRECONDITION(ctx, "bad param");
     NS_PRECONDITION(value, "bad param");
     NS_PRECONDITION(_retval, "bad param");
 
     XPCCallContext ccx(NATIVE_CALLER, ctx);
     if(!ccx.IsValid())
         return NS_ERROR_FAILURE;
 
     *_retval = XPCVariant::newVariant(ccx, value);
-    if(!(*_retval)) 
+    if(!(*_retval))
         return NS_ERROR_FAILURE;
 
     return NS_OK;
 }
 
 /* void flagSystemFilenamePrefix (in string filenamePrefix,
  *                                in PRBool aWantNativeWrappers); */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPConnect::FlagSystemFilenamePrefix(const char *aFilenamePrefix,
                                       PRBool aWantNativeWrappers)
 {
     NS_PRECONDITION(aFilenamePrefix, "bad param");
 
     JSRuntime* rt = GetRuntime()->GetJSRuntime();;
     uint32 flags = JSFILENAME_SYSTEM;
     if(aWantNativeWrappers)
@@ -2371,16 +2371,28 @@ nsXPConnect::SetSafeJSContext(JSContext 
     XPCPerThreadData* data = XPCPerThreadData::GetData(aSafeJSContext);
 
     if(!data)
         return NS_ERROR_FAILURE;
 
     return data->GetJSContextStack()->SetSafeJSContext(aSafeJSContext);
 }
 
+NS_IMETHODIMP_(PRBool)
+nsXPConnect::SetWatchdogLimit(JSContext *cx, PRIntervalTime limit)
+{
+    return GetRuntime()->SetWatchdogLimit(cx, limit);
+}
+
+NS_IMETHODIMP_(PRIntervalTime)
+nsXPConnect::GetWatchdogLimit(JSContext *cx)
+{
+    return GetRuntime()->GetWatchdogLimit(cx);
+}
+
 /* These are here to be callable from a debugger */
 JS_BEGIN_EXTERN_C
 JS_EXPORT_API(void) DumpJSStack()
 {
     nsresult rv;
     nsCOMPtr<nsIXPConnect> xpc(do_GetService(nsIXPConnect::GetCID(), &rv));
     if(NS_SUCCEEDED(rv) && xpc)
         xpc->DebugDumpJSStack(PR_TRUE, PR_TRUE, PR_FALSE);
diff -r 8b3caddca8f5 js/src/xpconnect/src/xpccomponents.cpp
--- a/js/src/xpconnect/src/xpccomponents.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/js/src/xpconnect/src/xpccomponents.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -760,17 +760,17 @@ nsXPCComponents_InterfacesByID::CanSetPr
 #endif
 
 /***************************************************************************/
 /***************************************************************************/
 /***************************************************************************/
 
 
 
-class nsXPCComponents_Classes : 
+class nsXPCComponents_Classes :
   public nsIXPCComponents_Classes,
   public nsIXPCScriptable,
   public nsIClassInfo
 {
 public:
     // all the interface method declarations...
     NS_DECL_ISUPPORTS
     NS_DECL_NSIXPCCOMPONENTS_CLASSES
@@ -778,19 +778,19 @@ public:
     NS_DECL_NSICLASSINFO
 
 public:
     nsXPCComponents_Classes();
     virtual ~nsXPCComponents_Classes();
 };
 
 /***************************************************************************/
-/* void getInterfaces (out PRUint32 count, [array, size_is (count), retval] 
-                       out nsIIDPtr array); */
-NS_IMETHODIMP 
+/* void getInterfaces (out PRUint32 count, [array, size_is (count), retval]
+                       out nsIIDPtr array); */
+NS_IMETHODIMP
 nsXPCComponents_Classes::GetInterfaces(PRUint32 *aCount, nsIID * **aArray)
 {
     PRUint32 count = 2;
     *aCount = count;
     nsIID **array;
     *aArray = array = static_cast<nsIID**>(nsMemory::Alloc(count * sizeof(nsIID*)));
     if(!array)
         return NS_ERROR_OUT_OF_MEMORY;
@@ -813,68 +813,68 @@ oom:
     while (index)
         nsMemory::Free(array[--index]);
     nsMemory::Free(array);
     *aArray = nsnull;
     return NS_ERROR_OUT_OF_MEMORY;
 }
 
 /* nsISupports getHelperForLanguage (in PRUint32 language); */
-NS_IMETHODIMP 
-nsXPCComponents_Classes::GetHelperForLanguage(PRUint32 language, 
-                                      nsISupports **retval)
-{
-    *retval = nsnull;
-    return NS_OK;
-}
-
-/* readonly attribute string contractID; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
+nsXPCComponents_Classes::GetHelperForLanguage(PRUint32 language,
+                                      nsISupports **retval)
+{
+    *retval = nsnull;
+    return NS_OK;
+}
+
+/* readonly attribute string contractID; */
+NS_IMETHODIMP
 nsXPCComponents_Classes::GetContractID(char * *aContractID)
 {
     *aContractID = nsnull;
     return NS_ERROR_NOT_AVAILABLE;
 }
 
 /* readonly attribute string classDescription; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCComponents_Classes::GetClassDescription(char * *aClassDescription)
 {
     static const char classDescription[] = "XPCComponents_Classes";
     *aClassDescription = (char*)nsMemory::Clone(classDescription, sizeof(classDescription));
     return *aClassDescription ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
 }
 
 /* readonly attribute nsCIDPtr classID; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCComponents_Classes::GetClassID(nsCID * *aClassID)
 {
     *aClassID = nsnull;
     return NS_OK;
 }
 
 /* readonly attribute PRUint32 implementationLanguage; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCComponents_Classes::GetImplementationLanguage(
     PRUint32 *aImplementationLanguage)
 {
     *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
     return NS_OK;
 }
 
 /* readonly attribute PRUint32 flags; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCComponents_Classes::GetFlags(PRUint32 *aFlags)
 {
     *aFlags = nsIClassInfo::THREADSAFE;
     return NS_OK;
 }
 
 /* [notxpcom] readonly attribute nsCID classIDNoAlloc; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCComponents_Classes::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
 {
     return NS_ERROR_NOT_AVAILABLE;
 }
 
 nsXPCComponents_Classes::nsXPCComponents_Classes()
 {
 }
@@ -1033,19 +1033,19 @@ public:
     NS_DECL_NSICLASSINFO
 
 public:
     nsXPCComponents_ClassesByID();
     virtual ~nsXPCComponents_ClassesByID();
 };
 
 /***************************************************************************/
-/* void getInterfaces (out PRUint32 count, [array, size_is (count), retval] 
-                       out nsIIDPtr array); */
-NS_IMETHODIMP 
+/* void getInterfaces (out PRUint32 count, [array, size_is (count), retval]
+                       out nsIIDPtr array); */
+NS_IMETHODIMP
 nsXPCComponents_ClassesByID::GetInterfaces(PRUint32 *aCount, nsIID * **aArray)
 {
     PRUint32 count = 2;
     *aCount = count;
     nsIID **array;
     *aArray = array = static_cast<nsIID**>(nsMemory::Alloc(count * sizeof(nsIID*)));
     if(!array)
         return NS_ERROR_OUT_OF_MEMORY;
@@ -1068,68 +1068,68 @@ oom:
     while (index)
         nsMemory::Free(array[--index]);
     nsMemory::Free(array);
     *aArray = nsnull;
     return NS_ERROR_OUT_OF_MEMORY;
 }
 
 /* nsISupports getHelperForLanguage (in PRUint32 language); */
-NS_IMETHODIMP 
-nsXPCComponents_ClassesByID::GetHelperForLanguage(PRUint32 language, 
-                                      nsISupports **retval)
-{
-    *retval = nsnull;
-    return NS_OK;
-}
-
-/* readonly attribute string contractID; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
+nsXPCComponents_ClassesByID::GetHelperForLanguage(PRUint32 language,
+                                      nsISupports **retval)
+{
+    *retval = nsnull;
+    return NS_OK;
+}
+
+/* readonly attribute string contractID; */
+NS_IMETHODIMP
 nsXPCComponents_ClassesByID::GetContractID(char * *aContractID)
 {
     *aContractID = nsnull;
     return NS_ERROR_NOT_AVAILABLE;
 }
 
 /* readonly attribute string classDescription; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCComponents_ClassesByID::GetClassDescription(char * *aClassDescription)
 {
     static const char classDescription[] = "XPCComponents_Interfaces";
     *aClassDescription = (char*)nsMemory::Clone(classDescription, sizeof(classDescription));
     return *aClassDescription ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
 }
 
 /* readonly attribute nsCIDPtr classID; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCComponents_ClassesByID::GetClassID(nsCID * *aClassID)
 {
     *aClassID = nsnull;
     return NS_OK;
 }
 
 /* readonly attribute PRUint32 implementationLanguage; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCComponents_ClassesByID::GetImplementationLanguage(
     PRUint32 *aImplementationLanguage)
 {
     *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
     return NS_OK;
 }
 
 /* readonly attribute PRUint32 flags; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCComponents_ClassesByID::GetFlags(PRUint32 *aFlags)
 {
     *aFlags = nsIClassInfo::THREADSAFE;
     return NS_OK;
 }
 
 /* [notxpcom] readonly attribute nsCID classIDNoAlloc; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCComponents_ClassesByID::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
 {
     return NS_ERROR_NOT_AVAILABLE;
 }
 
 nsXPCComponents_ClassesByID::nsXPCComponents_ClassesByID()
 {
 }
@@ -1307,19 +1307,19 @@ public:
     NS_DECL_NSICLASSINFO
 
 public:
     nsXPCComponents_Results();
     virtual ~nsXPCComponents_Results();
 };
 
 /***************************************************************************/
-/* void getInterfaces (out PRUint32 count, [array, size_is (count), retval] 
-                       out nsIIDPtr array); */
-NS_IMETHODIMP 
+/* void getInterfaces (out PRUint32 count, [array, size_is (count), retval]
+                       out nsIIDPtr array); */
+NS_IMETHODIMP
 nsXPCComponents_Results::GetInterfaces(PRUint32 *aCount, nsIID * **aArray)
 {
     PRUint32 count = 2;
     *aCount = count;
     nsIID **array;
     *aArray = array = static_cast<nsIID**>(nsMemory::Alloc(count * sizeof(nsIID*)));
     if(!array)
         return NS_ERROR_OUT_OF_MEMORY;
@@ -1342,68 +1342,68 @@ oom:
     while (index)
         nsMemory::Free(array[--index]);
     nsMemory::Free(array);
     *aArray = nsnull;
     return NS_ERROR_OUT_OF_MEMORY;
 }
 
 /* nsISupports getHelperForLanguage (in PRUint32 language); */
-NS_IMETHODIMP 
-nsXPCComponents_Results::GetHelperForLanguage(PRUint32 language, 
-                                      nsISupports **retval)
-{
-    *retval = nsnull;
-    return NS_OK;
-}
-
-/* readonly attribute string contractID; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
+nsXPCComponents_Results::GetHelperForLanguage(PRUint32 language,
+                                      nsISupports **retval)
+{
+    *retval = nsnull;
+    return NS_OK;
+}
+
+/* readonly attribute string contractID; */
+NS_IMETHODIMP
 nsXPCComponents_Results::GetContractID(char * *aContractID)
 {
     *aContractID = nsnull;
     return NS_ERROR_NOT_AVAILABLE;
 }
 
 /* readonly attribute string classDescription; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCComponents_Results::GetClassDescription(char * *aClassDescription)
 {
     static const char classDescription[] = "XPCComponents_Interfaces";
     *aClassDescription = (char*)nsMemory::Clone(classDescription, sizeof(classDescription));
     return *aClassDescription ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
 }
 
 /* readonly attribute nsCIDPtr classID; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCComponents_Results::GetClassID(nsCID * *aClassID)
 {
     *aClassID = nsnull;
     return NS_OK;
 }
 
 /* readonly attribute PRUint32 implementationLanguage; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCComponents_Results::GetImplementationLanguage(
     PRUint32 *aImplementationLanguage)
 {
     *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
     return NS_OK;
 }
 
 /* readonly attribute PRUint32 flags; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCComponents_Results::GetFlags(PRUint32 *aFlags)
 {
     *aFlags = nsIClassInfo::THREADSAFE;
     return NS_OK;
 }
 
 /* [notxpcom] readonly attribute nsCID classIDNoAlloc; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCComponents_Results::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
 {
     return NS_ERROR_NOT_AVAILABLE;
 }
 
 nsXPCComponents_Results::nsXPCComponents_Results()
 {
 }
@@ -1539,19 +1539,19 @@ private:
 private:
     NS_METHOD CallOrConstruct(nsIXPConnectWrappedNative *wrapper,
                               JSContext * cx, JSObject * obj,
                               PRUint32 argc, jsval * argv,
                               jsval * vp, PRBool *_retval);
 };
 
 /***************************************************************************/
-/* void getInterfaces (out PRUint32 count, [array, size_is (count), retval] 
-                       out nsIIDPtr array); */
-NS_IMETHODIMP 
+/* void getInterfaces (out PRUint32 count, [array, size_is (count), retval]
+                       out nsIIDPtr array); */
+NS_IMETHODIMP
 nsXPCComponents_ID::GetInterfaces(PRUint32 *aCount, nsIID * **aArray)
 {
     PRUint32 count = 2;
     *aCount = count;
     nsIID **array;
     *aArray = array = static_cast<nsIID**>(nsMemory::Alloc(count * sizeof(nsIID*)));
     if(!array)
         return NS_ERROR_OUT_OF_MEMORY;
@@ -1574,68 +1574,68 @@ oom:
     while (index)
         nsMemory::Free(array[--index]);
     nsMemory::Free(array);
     *aArray = nsnull;
     return NS_ERROR_OUT_OF_MEMORY;
 }
 
 /* nsISupports getHelperForLanguage (in PRUint32 language); */
-NS_IMETHODIMP 
-nsXPCComponents_ID::GetHelperForLanguage(PRUint32 language, 
-                                      nsISupports **retval)
-{
-    *retval = nsnull;
-    return NS_OK;
-}
-
-/* readonly attribute string contractID; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
+nsXPCComponents_ID::GetHelperForLanguage(PRUint32 language,
+                                      nsISupports **retval)
+{
+    *retval = nsnull;
+    return NS_OK;
+}
+
+/* readonly attribute string contractID; */
+NS_IMETHODIMP
 nsXPCComponents_ID::GetContractID(char * *aContractID)
 {
     *aContractID = nsnull;
     return NS_ERROR_NOT_AVAILABLE;
 }
 
 /* readonly attribute string classDescription; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCComponents_ID::GetClassDescription(char * *aClassDescription)
 {
     static const char classDescription[] = "XPCComponents_Interfaces";
     *aClassDescription = (char*)nsMemory::Clone(classDescription, sizeof(classDescription));
     return *aClassDescription ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
 }
 
 /* readonly attribute nsCIDPtr classID; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCComponents_ID::GetClassID(nsCID * *aClassID)
 {
     *aClassID = nsnull;
     return NS_OK;
 }
 
 /* readonly attribute PRUint32 implementationLanguage; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCComponents_ID::GetImplementationLanguage(
     PRUint32 *aImplementationLanguage)
 {
     *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
     return NS_OK;
 }
 
 /* readonly attribute PRUint32 flags; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCComponents_ID::GetFlags(PRUint32 *aFlags)
 {
     *aFlags = nsIClassInfo::THREADSAFE;
     return NS_OK;
 }
 
 /* [notxpcom] readonly attribute nsCID classIDNoAlloc; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCComponents_ID::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
 {
     return NS_ERROR_NOT_AVAILABLE;
 }
 
 nsXPCComponents_ID::nsXPCComponents_ID()
 {
 }
@@ -1766,19 +1766,19 @@ private:
 private:
     NS_METHOD CallOrConstruct(nsIXPConnectWrappedNative *wrapper,
                               JSContext * cx, JSObject * obj,
                               PRUint32 argc, jsval * argv,
                               jsval * vp, PRBool *_retval);
 };
 
 /***************************************************************************/
-/* void getInterfaces (out PRUint32 count, [array, size_is (count), retval] 
-                       out nsIIDPtr array); */
-NS_IMETHODIMP 
+/* void getInterfaces (out PRUint32 count, [array, size_is (count), retval]
+                       out nsIIDPtr array); */
+NS_IMETHODIMP
 nsXPCComponents_Exception::GetInterfaces(PRUint32 *aCount, nsIID * **aArray)
 {
     PRUint32 count = 2;
     *aCount = count;
     nsIID **array;
     *aArray = array = static_cast<nsIID**>(nsMemory::Alloc(count * sizeof(nsIID*)));
     if(!array)
         return NS_ERROR_OUT_OF_MEMORY;
@@ -1801,68 +1801,68 @@ oom:
     while (index)
         nsMemory::Free(array[--index]);
     nsMemory::Free(array);
     *aArray = nsnull;
     return NS_ERROR_OUT_OF_MEMORY;
 }
 
 /* nsISupports getHelperForLanguage (in PRUint32 language); */
-NS_IMETHODIMP 
-nsXPCComponents_Exception::GetHelperForLanguage(PRUint32 language, 
-                                      nsISupports **retval)
-{
-    *retval = nsnull;
-    return NS_OK;
-}
-
-/* readonly attribute string contractID; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
+nsXPCComponents_Exception::GetHelperForLanguage(PRUint32 language,
+                                      nsISupports **retval)
+{
+    *retval = nsnull;
+    return NS_OK;
+}
+
+/* readonly attribute string contractID; */
+NS_IMETHODIMP
 nsXPCComponents_Exception::GetContractID(char * *aContractID)
 {
     *aContractID = nsnull;
     return NS_ERROR_NOT_AVAILABLE;
 }
 
 /* readonly attribute string classDescription; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCComponents_Exception::GetClassDescription(char * *aClassDescription)
 {
     static const char classDescription[] = "XPCComponents_Interfaces";
     *aClassDescription = (char*)nsMemory::Clone(classDescription, sizeof(classDescription));
     return *aClassDescription ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
 }
 
 /* readonly attribute nsCIDPtr classID; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCComponents_Exception::GetClassID(nsCID * *aClassID)
 {
     *aClassID = nsnull;
     return NS_OK;
 }
 
 /* readonly attribute PRUint32 implementationLanguage; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCComponents_Exception::GetImplementationLanguage(
     PRUint32 *aImplementationLanguage)
 {
     *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
     return NS_OK;
 }
 
 /* readonly attribute PRUint32 flags; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCComponents_Exception::GetFlags(PRUint32 *aFlags)
 {
     *aFlags = nsIClassInfo::THREADSAFE;
     return NS_OK;
 }
 
 /* [notxpcom] readonly attribute nsCID classIDNoAlloc; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCComponents_Exception::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
 {
     return NS_ERROR_NOT_AVAILABLE;
 }
 
 nsXPCComponents_Exception::nsXPCComponents_Exception()
 {
 }
@@ -2059,19 +2059,19 @@ private:
                               jsval * vp, PRBool *_retval);
 private:
     nsIJSCID* mClassID;
     nsIJSIID* mInterfaceID;
     char*     mInitializer;
 };
 
 /***************************************************************************/
-/* void getInterfaces (out PRUint32 count, [array, size_is (count), retval] 
-                       out nsIIDPtr array); */
-NS_IMETHODIMP 
+/* void getInterfaces (out PRUint32 count, [array, size_is (count), retval]
+                       out nsIIDPtr array); */
+NS_IMETHODIMP
 nsXPCConstructor::GetInterfaces(PRUint32 *aCount, nsIID * **aArray)
 {
     PRUint32 count = 2;
     *aCount = count;
     nsIID **array;
     *aArray = array = static_cast<nsIID**>(nsMemory::Alloc(count * sizeof(nsIID*)));
     if(!array)
         return NS_ERROR_OUT_OF_MEMORY;
@@ -2094,68 +2094,68 @@ oom:
     while (index)
         nsMemory::Free(array[--index]);
     nsMemory::Free(array);
     *aArray = nsnull;
     return NS_ERROR_OUT_OF_MEMORY;
 }
 
 /* nsISupports getHelperForLanguage (in PRUint32 language); */
-NS_IMETHODIMP 
-nsXPCConstructor::GetHelperForLanguage(PRUint32 language, 
-                                      nsISupports **retval)
-{
-    *retval = nsnull;
-    return NS_OK;
-}
-
-/* readonly attribute string contractID; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
+nsXPCConstructor::GetHelperForLanguage(PRUint32 language,
+                                      nsISupports **retval)
+{
+    *retval = nsnull;
+    return NS_OK;
+}
+
+/* readonly attribute string contractID; */
+NS_IMETHODIMP
 nsXPCConstructor::GetContractID(char * *aContractID)
 {
     *aContractID = nsnull;
     return NS_ERROR_NOT_AVAILABLE;
 }
 
 /* readonly attribute string classDescription; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCConstructor::GetClassDescription(char * *aClassDescription)
 {
     static const char classDescription[] = "XPCComponents_Interfaces";
     *aClassDescription = (char*)nsMemory::Clone(classDescription, sizeof(classDescription));
     return *aClassDescription ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
 }
 
 /* readonly attribute nsCIDPtr classID; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCConstructor::GetClassID(nsCID * *aClassID)
 {
     *aClassID = nsnull;
     return NS_OK;
 }
 
 /* readonly attribute PRUint32 implementationLanguage; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCConstructor::GetImplementationLanguage(
     PRUint32 *aImplementationLanguage)
 {
     *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
     return NS_OK;
 }
 
 /* readonly attribute PRUint32 flags; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCConstructor::GetFlags(PRUint32 *aFlags)
 {
     *aFlags = nsIClassInfo::THREADSAFE;
     return NS_OK;
 }
 
 /* [notxpcom] readonly attribute nsCID classIDNoAlloc; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCConstructor::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
 {
     return NS_ERROR_NOT_AVAILABLE;
 }
 
 nsXPCConstructor::nsXPCConstructor(nsIJSCID* aClassID,
                                    nsIJSIID* aInterfaceID,
                                    const char* aInitializer)
@@ -2324,19 +2324,19 @@ private:
 private:
     NS_METHOD CallOrConstruct(nsIXPConnectWrappedNative *wrapper,
                               JSContext * cx, JSObject * obj,
                               PRUint32 argc, jsval * argv,
                               jsval * vp, PRBool *_retval);
 };
 
 /***************************************************************************/
-/* void getInterfaces (out PRUint32 count, [array, size_is (count), retval] 
-                       out nsIIDPtr array); */
-NS_IMETHODIMP 
+/* void getInterfaces (out PRUint32 count, [array, size_is (count), retval]
+                       out nsIIDPtr array); */
+NS_IMETHODIMP
 nsXPCComponents_Constructor::GetInterfaces(PRUint32 *aCount, nsIID * **aArray)
 {
     PRUint32 count = 2;
     *aCount = count;
     nsIID **array;
     *aArray = array = static_cast<nsIID**>(nsMemory::Alloc(count * sizeof(nsIID*)));
     if(!array)
         return NS_ERROR_OUT_OF_MEMORY;
@@ -2359,68 +2359,68 @@ oom:
     while (index)
         nsMemory::Free(array[--index]);
     nsMemory::Free(array);
     *aArray = nsnull;
     return NS_ERROR_OUT_OF_MEMORY;
 }
 
 /* nsISupports getHelperForLanguage (in PRUint32 language); */
-NS_IMETHODIMP 
-nsXPCComponents_Constructor::GetHelperForLanguage(PRUint32 language, 
-                                      nsISupports **retval)
-{
-    *retval = nsnull;
-    return NS_OK;
-}
-
-/* readonly attribute string contractID; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
+nsXPCComponents_Constructor::GetHelperForLanguage(PRUint32 language,
+                                      nsISupports **retval)
+{
+    *retval = nsnull;
+    return NS_OK;
+}
+
+/* readonly attribute string contractID; */
+NS_IMETHODIMP
 nsXPCComponents_Constructor::GetContractID(char * *aContractID)
 {
     *aContractID = nsnull;
     return NS_ERROR_NOT_AVAILABLE;
 }
 
 /* readonly attribute string classDescription; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCComponents_Constructor::GetClassDescription(char * *aClassDescription)
 {
     static const char classDescription[] = "XPCComponents_Interfaces";
     *aClassDescription = (char*)nsMemory::Clone(classDescription, sizeof(classDescription));
     return *aClassDescription ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
 }
 
 /* readonly attribute nsCIDPtr classID; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCComponents_Constructor::GetClassID(nsCID * *aClassID)
 {
     *aClassID = nsnull;
     return NS_OK;
 }
 
 /* readonly attribute PRUint32 implementationLanguage; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCComponents_Constructor::GetImplementationLanguage(
     PRUint32 *aImplementationLanguage)
 {
     *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
     return NS_OK;
 }
 
 /* readonly attribute PRUint32 flags; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCComponents_Constructor::GetFlags(PRUint32 *aFlags)
 {
     *aFlags = nsIClassInfo::THREADSAFE;
     return NS_OK;
 }
 
 /* [notxpcom] readonly attribute nsCID classIDNoAlloc; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCComponents_Constructor::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
 {
     return NS_ERROR_NOT_AVAILABLE;
 }
 
 nsXPCComponents_Constructor::nsXPCComponents_Constructor()
 {
 }
@@ -3215,17 +3215,17 @@ xpc_CreateSandboxObject(JSContext * cx, 
         if (!principal) {
             principal = do_CreateInstance("@mozilla.org/nullprincipal;1", &rv);
             NS_ASSERTION(NS_FAILED(rv) || principal,
                          "Bad return from do_CreateInstance");
 
             if (!principal || NS_FAILED(rv)) {
                 if (NS_SUCCEEDED(rv))
                     rv = NS_ERROR_FAILURE;
-                
+
                 return rv;
             }
         }
 
         sop = new PrincipalHolder(principal);
         if (!sop)
             return NS_ERROR_OUT_OF_MEMORY;
     }
@@ -3381,17 +3381,17 @@ public:
     {
         return mJSContext;
     }
 
     NS_DECL_ISUPPORTS
 
 private:
     static JSBool ContextHolderOperationCallback(JSContext *cx);
-    
+
     XPCAutoJSContext mJSContext;
     JSContext* mOrigCx;
 };
 
 NS_IMPL_ISUPPORTS0(ContextHolder)
 
 ContextHolder::ContextHolder(JSContext *aOuterCx, JSObject *aSandbox)
     : mJSContext(JS_NewContext(JS_GetRuntime(aOuterCx), 1024), JS_FALSE),
@@ -3400,21 +3400,27 @@ ContextHolder::ContextHolder(JSContext *
     if(mJSContext)
     {
         JS_SetOptions(mJSContext,
                       JSOPTION_DONT_REPORT_UNCAUGHT |
                       JSOPTION_PRIVATE_IS_NSISUPPORTS);
         JS_SetGlobalObject(mJSContext, aSandbox);
         JS_SetContextPrivate(mJSContext, this);
 
-        if(JS_GetOperationCallback(aOuterCx))
-        {
-            JS_SetOperationCallback(mJSContext, ContextHolderOperationCallback,
-                                    JS_GetOperationLimit(aOuterCx));
-        }
+        PRIntervalTime watchdogLimit =
+            nsXPConnect::GetXPConnect()->GetWatchdogLimit(aOuterCx);
+
+        if(watchdogLimit)
+        {
+            JS_SetOperationCallback(mJSContext,
+                                    ContextHolderOperationCallback);
+            nsXPConnect::GetXPConnect()->SetWatchdogLimit(mJSContext,
+                                                          watchdogLimit);
+        }
+
     }
 }
 
 JSBool
 ContextHolder::ContextHolderOperationCallback(JSContext *cx)
 {
     ContextHolder* thisObject =
         static_cast<ContextHolder*>(JS_GetContextPrivate(cx));
@@ -3426,17 +3432,19 @@ ContextHolder::ContextHolderOperationCal
     if(callback)
     {
         ok = callback(origCx);
         callback = JS_GetOperationCallback(origCx);
         if(callback)
         {
             // If the callback is still set in the original context, reflect
             // a possibly updated operation limit into cx.
-            JS_SetOperationLimit(cx, JS_GetOperationLimit(origCx));
+            PRIntervalTime limit =
+                nsXPConnect::GetXPConnect()->GetWatchdogLimit(origCx);
+            ok = nsXPConnect::GetXPConnect()->SetWatchdogLimit(cx, limit);
             return ok;
         }
     }
 
     JS_ClearOperationCallback(cx);
     return ok;
 }
 
@@ -3731,19 +3739,19 @@ NS_INTERFACE_MAP_BEGIN(nsXPCComponents)
   NS_INTERFACE_MAP_ENTRY(nsISecurityCheckedComponent)
 #endif
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIXPCComponents)
 NS_INTERFACE_MAP_END_THREADSAFE
 
 NS_IMPL_THREADSAFE_ADDREF(nsXPCComponents)
 NS_IMPL_THREADSAFE_RELEASE(nsXPCComponents)
 
-/* void getInterfaces (out PRUint32 count, [array, size_is (count), retval] 
-                       out nsIIDPtr array); */
-NS_IMETHODIMP 
+/* void getInterfaces (out PRUint32 count, [array, size_is (count), retval]
+                       out nsIIDPtr array); */
+NS_IMETHODIMP
 nsXPCComponents::GetInterfaces(PRUint32 *aCount, nsIID * **aArray)
 {
     PRUint32 count = 2;
 #ifdef XPC_USE_SECURITY_CHECKED_COMPONENT
     ++count;
 #endif
     *aCount = count;
     nsIID **array;
@@ -3772,68 +3780,68 @@ oom:
     while (index)
         nsMemory::Free(array[--index]);
     nsMemory::Free(array);
     *aArray = nsnull;
     return NS_ERROR_OUT_OF_MEMORY;
 }
 
 /* nsISupports getHelperForLanguage (in PRUint32 language); */
-NS_IMETHODIMP 
-nsXPCComponents::GetHelperForLanguage(PRUint32 language, 
-                                      nsISupports **retval)
-{
-    *retval = nsnull;
-    return NS_OK;
-}
-
-/* readonly attribute string contractID; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
+nsXPCComponents::GetHelperForLanguage(PRUint32 language,
+                                      nsISupports **retval)
+{
+    *retval = nsnull;
+    return NS_OK;
+}
+
+/* readonly attribute string contractID; */
+NS_IMETHODIMP
 nsXPCComponents::GetContractID(char * *aContractID)
 {
     *aContractID = nsnull;
     return NS_ERROR_NOT_AVAILABLE;
 }
 
 /* readonly attribute string classDescription; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCComponents::GetClassDescription(char * *aClassDescription)
 {
     static const char classDescription[] = "XPCComponents";
     *aClassDescription = (char*)nsMemory::Clone(classDescription, sizeof(classDescription));
     return *aClassDescription ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
 }
 
 /* readonly attribute nsCIDPtr classID; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCComponents::GetClassID(nsCID * *aClassID)
 {
     *aClassID = nsnull;
     return NS_OK;
 }
 
 /* readonly attribute PRUint32 implementationLanguage; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCComponents::GetImplementationLanguage(
     PRUint32 *aImplementationLanguage)
 {
     *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
     return NS_OK;
 }
 
 /* readonly attribute PRUint32 flags; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCComponents::GetFlags(PRUint32 *aFlags)
 {
     *aFlags = nsIClassInfo::THREADSAFE;
     return NS_OK;
 }
 
 /* [notxpcom] readonly attribute nsCID classIDNoAlloc; */
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsXPCComponents::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
 {
     return NS_ERROR_NOT_AVAILABLE;
 }
 
 nsXPCComponents::nsXPCComponents()
     :   mInterfaces(nsnull),
         mInterfacesByID(nsnull),
diff -r 8b3caddca8f5 js/src/xpconnect/src/xpccontext.cpp
--- a/js/src/xpconnect/src/xpccontext.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/js/src/xpconnect/src/xpccontext.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -47,16 +47,17 @@ XPCContext::XPCContext(XPCJSRuntime* aRu
 XPCContext::XPCContext(XPCJSRuntime* aRuntime,
                        JSContext* aJSContext)
     :   mRuntime(aRuntime),
         mJSContext(aJSContext),
         mLastResult(NS_OK),
         mPendingResult(NS_OK),
         mSecurityManager(nsnull),
         mException(nsnull),
+        mWatchdogLimit(0),
         mCallingLangType(LANG_UNKNOWN),
         mSecurityManagerFlags(0)
 {
     MOZ_COUNT_CTOR(XPCContext);
 
     PR_INIT_CLIST(&mScopes);
     for(const char** p =  XPC_ARG_FORMATTER_FORMAT_STRINGS; *p; p++)
         JS_AddArgumentFormatter(mJSContext, *p, XPC_JSArgumentFormatter);
diff -r 8b3caddca8f5 js/src/xpconnect/src/xpcjsruntime.cpp
--- a/js/src/xpconnect/src/xpcjsruntime.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/js/src/xpconnect/src/xpcjsruntime.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -211,17 +211,17 @@ DyingProtoKiller(JSDHashTable *table, JS
     delete proto;
     return JS_DHASH_REMOVE;
 }
 
 static JSDHashOperator
 DetachedWrappedNativeProtoMarker(JSDHashTable *table, JSDHashEntryHdr *hdr,
                                  uint32 number, void *arg)
 {
-    XPCWrappedNativeProto* proto = 
+    XPCWrappedNativeProto* proto =
         (XPCWrappedNativeProto*)((JSDHashEntryStub*)hdr)->key;
 
     proto->Mark();
     return JS_DHASH_NEXT;
 }
 
 // GCCallback calls are chained
 static JSBool
@@ -233,16 +233,24 @@ ContextCallback(JSContext *cx, uintN ope
         if(operation == JSCONTEXT_NEW)
         {
             if(!self->OnJSContextNew(cx))
                 return JS_FALSE;
         }
         else if(operation == JSCONTEXT_DESTROY)
         {
             delete XPCContext::GetXPCContext(cx);
+        }
+        else if(operation == JSCONTEXT_REQUEST_START)
+        {
+            // If we're called during context creation, we will assert if we
+            // try to call XPCContext::GetXPCContext.
+            if(!cx->data2)
+                return JS_TRUE;
+            self->WakeupWatchdog(cx);
         }
     }
     return JS_TRUE;
 }
 
 struct ObjectHolder : public JSDHashEntryHdr
 {
     void *holder;
@@ -304,17 +312,17 @@ void XPCJSRuntime::TraceJS(JSTracer* trc
             }
         }
     }
 
     // XPCJSObjectHolders don't participate in cycle collection, so always trace
     // them here.
     for(XPCRootSetElem *e = self->mObjectHolderRoots; e ; e = e->GetNextRoot())
         static_cast<XPCJSObjectHolder*>(e)->TraceJS(trc);
-        
+
     if(self->GetXPConnect()->ShouldTraceRoots())
     {
         // Only trace these if we're not cycle-collecting, the cycle collector
         // will do that if we are.
         self->TraceXPConnectRoots(trc);
     }
 }
 
@@ -522,17 +530,17 @@ JSBool XPCJSRuntime::GCCallback(JSContex
                 {
                     return JS_FALSE;
                 }
                 break;
             }
             case JSGC_MARK_END:
             {
                 NS_ASSERTION(!self->mDoingFinalization, "bad state");
-    
+
                 // mThreadRunningGC indicates that GC is running
                 { // scoped lock
                     XPCAutoLock lock(self->GetMapLock());
                     NS_ASSERTION(!self->mThreadRunningGC, "bad state");
                     self->mThreadRunningGC = PR_GetCurrentThread();
                 }
 
                 dyingWrappedJSArray = &self->mWrappedJSToReleaseArray;
@@ -545,18 +553,18 @@ JSBool XPCJSRuntime::GCCallback(JSContex
                     // we do not want to be changing the refcount of these wrappers.
                     // We add them to the array now and Release the array members
                     // later to avoid the posibility of doing any JS GCThing
                     // allocations during the gc cycle.
                     self->mWrappedJSMap->
                         Enumerate(WrappedJSDyingJSObjectFinder, &data);
                 }
 
-                // Do cleanup in NativeInterfaces. This part just finds 
-                // member cloned function objects that are about to be 
+                // Do cleanup in NativeInterfaces. This part just finds
+                // member cloned function objects that are about to be
                 // collected. It does not deal with collection of interfaces or
                 // sets at this point.
                 CX_AND_XPCRT_Data data = {cx, self};
 
                 self->mIID2NativeInterfaceMap->
                     Enumerate(NativeInterfaceGC, &data);
 
                 // Find dying scopes...
@@ -711,17 +719,17 @@ JSBool XPCJSRuntime::GCCallback(JSContex
                 // Skip this part if XPConnect is shutting down. We get into
                 // bad locking problems with the thread iteration otherwise.
                 if(!self->GetXPConnect()->IsShuttingDown())
                 {
                     PRLock* threadLock = XPCPerThreadData::GetLock();
                     if(threadLock)
                     {
                         // Do the marking...
-                        
+
                         { // scoped lock
                             nsAutoLock lock(threadLock);
 
                             XPCPerThreadData* iterp = nsnull;
                             XPCPerThreadData* thread;
 
                             while(nsnull != (thread =
                                      XPCPerThreadData::IterateThreads(&iterp)))
@@ -730,26 +738,26 @@ JSBool XPCJSRuntime::GCCallback(JSContex
                                 while(ccxp)
                                 {
                                     // Deal with the strictness of callcontext that
                                     // complains if you ask for a tearoff when
                                     // it is in a state where the tearoff could not
                                     // possibly be valid.
                                     if(ccxp->CanGetTearOff())
                                     {
-                                        XPCWrappedNativeTearOff* to = 
+                                        XPCWrappedNativeTearOff* to =
                                             ccxp->GetTearOff();
                                         if(to)
                                             to->Mark();
                                     }
                                     ccxp = ccxp->GetPrevCallContext();
                                 }
                             }
                         }
-    
+
                         // Do the sweeping...
                         XPCWrappedNativeScope::SweepAllWrappedNativeTearOffs();
                     }
                 }
 
                 // Now we need to kill the 'Dying' XPCWrappedNativeProtos.
                 // We transfered these native objects to this table when their
                 // JSObject's were finalized. We did not destroy them immediately
@@ -815,16 +823,136 @@ JSBool XPCJSRuntime::GCCallback(JSContex
             default:
                 break;
         }
     }
 
     return JS_TRUE;
 }
 
+/* static */
+void
+XPCJSRuntime::WatchdogMain(void *arg)
+{
+    XPCJSRuntime *xpcrt = (XPCJSRuntime *) arg;
+    JSRuntime *rt = xpcrt->GetJSRuntime();
+    PRStatus status;
+    PRBool isRunning;
+
+    do
+    {
+        JSContext *iter = NULL;
+        JSContext *acx;
+        PRIntervalTime newInterval = (PRIntervalTime) 0;
+        XPCContext *ccx;
+
+        PRIntervalTime ct = PR_IntervalNow();
+        PR_Lock(xpcrt->mWatchdogLock);
+        JS_LOCK_GC(rt);
+
+        while((acx = js_ContextIterator(rt, JS_FALSE, &iter)))
+        {
+            if(acx->requestDepth)
+            {
+                ccx = XPCContext::GetXPCContext(acx);
+                if(ccx->mWatchdogLimit &&
+                   ct - acx->startTime > ccx->mWatchdogLimit)
+                {
+                    JS_TriggerOperationCallback(acx);
+                }
+                if(newInterval > ccx->mWatchdogLimit || !newInterval)
+                    newInterval = ccx->mWatchdogLimit;
+            }
+        }
+        JS_UNLOCK_GC(rt);
+
+        xpcrt->mCurrentInterval = newInterval ? newInterval
+                                              : PR_INTERVAL_NO_TIMEOUT;
+        if (xpcrt->mWatchdogRunning)
+            status = PR_WaitCondVar(xpcrt->mWatchdogWakeup,
+                                    xpcrt->mCurrentInterval);
+        isRunning = xpcrt->mWatchdogRunning;
+        PR_Unlock(xpcrt->mWatchdogLock);
+    } while (isRunning && status == PR_SUCCESS);
+}
+
+PRBool
+XPCJSRuntime::SetWatchdogLimit(JSContext *cx, PRIntervalTime newWatchdogLimit)
+{
+    PRBool isRunning;
+    PRIntervalTime oldWatchdogLimit;
+    XPCContext *ccx = XPCContext::GetXPCContext(cx);
+
+    if(newWatchdogLimit == ccx->mWatchdogLimit)
+        return PR_TRUE;
+
+    oldWatchdogLimit = ccx->mWatchdogLimit;
+    ccx->mWatchdogLimit = newWatchdogLimit;
+
+    /*
+     * Start a new watchdog thread if it has not been started. If it has been
+     * started wake up the thread and cause the watchdog rescheduling.
+     */
+    PR_Lock(mWatchdogLock);
+    isRunning = !!mWatchdogThread;
+
+    if(!isRunning)
+    {
+        mWatchdogRunning = PR_TRUE;
+        mWatchdogThread =
+            PR_CreateThread(PRThreadType(PR_USER_THREAD),
+                            WatchdogMain,
+                            this,
+                            PRThreadPriority(PR_PRIORITY_NORMAL),
+                            PRThreadScope(PR_LOCAL_THREAD),
+                            PRThreadState(PR_JOINABLE_THREAD),
+                            0);
+    }
+    PR_Unlock(mWatchdogLock);
+    if(!mWatchdogThread)
+        return PR_FALSE;
+    if(isRunning &&
+       (oldWatchdogLimit > ccx->mWatchdogLimit ||
+        mCurrentInterval == PR_INTERVAL_NO_TIMEOUT))
+        WakeupWatchdog(cx);
+    return PR_TRUE;
+
+}
+
+void
+XPCJSRuntime::WakeupWatchdog(JSContext *cx)
+{
+    XPCContext *ccx = XPCContext::GetXPCContext(cx);
+    PR_Lock(mWatchdogLock);
+    if(mCurrentInterval == PR_INTERVAL_NO_TIMEOUT ||
+       (ccx && mCurrentInterval > ccx->mWatchdogLimit))
+        PR_NotifyCondVar(mWatchdogWakeup);
+    PR_Unlock(mWatchdogLock);
+}
+
+PRBool
+XPCJSRuntime::ShutdownWatchdog()
+{
+    PR_Lock(mWatchdogLock);
+    mWatchdogRunning = PR_FALSE;
+    PRThread *t = mWatchdogThread;
+    mWatchdogThread = NULL;
+    PR_NotifyCondVar(mWatchdogWakeup);
+    PR_Unlock(mWatchdogLock);
+    if(t)
+        PR_JoinThread(t);
+    return PR_TRUE;
+}
+
+PRIntervalTime
+XPCJSRuntime::GetWatchdogLimit(JSContext *cx)
+{
+    return XPCContext::GetXPCContext(cx)->mWatchdogLimit;
+}
+
 /***************************************************************************/
 
 #ifdef XPC_CHECK_WRAPPERS_AT_SHUTDOWN
 static JSDHashOperator
 DEBUG_WrapperChecker(JSDHashTable *table, JSDHashEntryHdr *hdr,
                      uint32 number, void *arg)
 {
     XPCWrappedNative* wrapper = (XPCWrappedNative*)((JSDHashEntryStub*)hdr)->key;
@@ -845,17 +973,17 @@ WrappedJSShutdownMarker(JSDHashTable *ta
     wrapper->SystemIsBeingShutDown(rt);
     return JS_DHASH_NEXT;
 }
 
 static JSDHashOperator
 DetachedWrappedNativeProtoShutdownMarker(JSDHashTable *table, JSDHashEntryHdr *hdr,
                                          uint32 number, void *arg)
 {
-    XPCWrappedNativeProto* proto = 
+    XPCWrappedNativeProto* proto =
         (XPCWrappedNativeProto*)((JSDHashEntryStub*)hdr)->key;
 
     proto->SystemIsBeingShutDown((JSContext*)arg);
     return JS_DHASH_NEXT;
 }
 
 void XPCJSRuntime::SystemIsBeingShutDown(JSContext* cx)
 {
@@ -1006,16 +1134,22 @@ XPCJSRuntime::~XPCJSRuntime()
         mJSHolders.ops = nsnull;
     }
     if(mClearedGlobalObjects.ops)
     {
         JS_DHashTableFinish(&mClearedGlobalObjects);
         mClearedGlobalObjects.ops = nsnull;
     }
 
+    ShutdownWatchdog();
+    if(mWatchdogWakeup)
+        JS_DESTROY_CONDVAR(mWatchdogWakeup);
+    if(mWatchdogLock)
+        JS_DESTROY_LOCK(mWatchdogLock);
+
     if(mJSRuntime)
     {
         JS_DestroyRuntime(mJSRuntime);
         JS_ShutDown();
 #ifdef DEBUG_shaver_off
         fprintf(stderr, "nJRSI: destroyed runtime %p\n", (void *)mJSRuntime);
 #endif
     }
@@ -1093,16 +1227,21 @@ XPCJSRuntime::XPCJSRuntime(nsXPConnect* 
                           sizeof(ClearedGlobalObject), JS_DHASH_MIN_SIZE))
         mClearedGlobalObjects.ops = nsnull;
 
     // Install a JavaScript 'debugger' keyword handler in debug builds only
 #ifdef DEBUG
     if(mJSRuntime && !JS_GetGlobalDebugHooks(mJSRuntime)->debuggerHandler)
         xpc_InstallJSDebuggerKeywordHandler(mJSRuntime);
 #endif
+
+    mWatchdogLock = JS_NEW_LOCK();
+    mWatchdogWakeup = JS_NEW_CONDVAR(mWatchdogLock);
+    mWatchdogThread = NULL;
+
 }
 
 // static
 XPCJSRuntime*
 XPCJSRuntime::newXPCJSRuntime(nsXPConnect* aXPConnect)
 {
     NS_PRECONDITION(aXPConnect,"bad param");
 
@@ -1142,25 +1281,25 @@ XPCJSRuntime::OnJSContextNew(JSContext *
             {
                 mStrIDs[0] = 0;
                 ok = JS_FALSE;
                 break;
             }
             mStrJSVals[i] = STRING_TO_JSVAL(str);
         }
     }
-    if (!ok)
+    if(!ok)
         return JS_FALSE;
 
     XPCPerThreadData* tls = XPCPerThreadData::GetData(cx);
     if(!tls)
         return JS_FALSE;
 
     XPCContext* xpc = new XPCContext(this, cx);
-    if (!xpc)
+    if(!xpc)
         return JS_FALSE;
 
     JS_SetThreadStackLimit(cx, tls->GetStackLimit());
     JS_SetScriptStackQuota(cx, 100*1024*1024);
     return JS_TRUE;
 }
 
 JSBool
diff -r 8b3caddca8f5 js/src/xpconnect/src/xpcprivate.h
--- a/js/src/xpconnect/src/xpcprivate.h	Sat Nov 15 23:56:49 2008 -0800
+++ b/js/src/xpconnect/src/xpcprivate.h	Sat Nov 22 15:25:48 2008 -0500
@@ -270,32 +270,32 @@ extern const char XPC_XPCONNECT_CONTRACT
 
 // We PROMISE to never screw this up.
 #ifdef _MSC_VER
 #pragma warning(disable : 4355) // OK to pass "this" in member initializer
 #endif
 
 typedef PRMonitor XPCLock;
 
-static inline void xpc_Wait(XPCLock* lock) 
+static inline void xpc_Wait(XPCLock* lock)
     {
         NS_ASSERTION(lock, "xpc_Wait called with null lock!");
 #ifdef DEBUG
-        PRStatus result = 
+        PRStatus result =
 #endif
         PR_Wait(lock, PR_INTERVAL_NO_TIMEOUT);
         NS_ASSERTION(PR_SUCCESS == result, "bad result from PR_Wait!");
     }
 
-static inline void xpc_NotifyAll(XPCLock* lock) 
+static inline void xpc_NotifyAll(XPCLock* lock)
     {
         NS_ASSERTION(lock, "xpc_NotifyAll called with null lock!");
 #ifdef DEBUG
-        PRStatus result = 
-#endif    
+        PRStatus result =
+#endif
         PR_NotifyAll(lock);
         NS_ASSERTION(PR_SUCCESS == result, "bad result from PR_NotifyAll!");
     }
 
 // This is a cloned subset of nsAutoMonitor. We want the use of a monitor -
 // mostly because we need reenterability - but we also want to support passing
 // a null monitor in without things blowing up. This is used for wrappers that
 // are guaranteed to be used only on one thread. We avoid lock overhead by
@@ -505,17 +505,17 @@ public:
     nsresult GetInfoForName(const char * name, nsIInterfaceInfo** info);
 
     // nsCycleCollectionParticipant
     NS_IMETHOD RootAndUnlinkJSObjects(void *p);
     NS_IMETHOD Unlink(void *p);
     NS_IMETHOD Unroot(void *p);
     NS_IMETHOD Traverse(void *p,
                         nsCycleCollectionTraversalCallback &cb);
-    
+
     // nsCycleCollectionLanguageRuntime
     virtual nsresult BeginCycleCollection(nsCycleCollectionTraversalCallback &cb);
     virtual nsresult FinishCycleCollection();
     virtual nsCycleCollectionParticipant *ToParticipant(void *p);
     virtual PRBool Collect();
 #ifdef DEBUG_CC
     virtual void PrintAllReferencesTo(void *p);
 #endif
@@ -733,16 +733,20 @@ public:
     void DebugDump(PRInt16 depth);
 
     void SystemIsBeingShutDown(JSContext* cx);
 
     PRThread* GetThreadRunningGC() const {return mThreadRunningGC;}
 
     ~XPCJSRuntime();
 
+    PRIntervalTime GetWatchdogLimit(JSContext *cx);
+    PRBool SetWatchdogLimit(JSContext *cx, PRIntervalTime limit);
+    void WakeupWatchdog(JSContext *cx);
+
 #ifdef XPC_CHECK_WRAPPERS_AT_SHUTDOWN
    void DEBUG_AddWrappedNative(nsIXPConnectWrappedNative* wrapper)
         {XPCAutoLock lock(GetMapLock());
          JSDHashEntryHdr *entry =
             JS_DHashTableOperate(DEBUG_WrappedNativeHashtable,
                                  wrapper, JS_DHASH_ADD);
          if(entry) ((JSDHashEntryStub *)entry)->key = wrapper;}
 
@@ -753,16 +757,19 @@ private:
 private:
    JSDHashTable* DEBUG_WrappedNativeHashtable;
 public:
 #endif
 
 private:
     XPCJSRuntime(); // no implementation
     XPCJSRuntime(nsXPConnect* aXPConnect);
+
+    PRBool ShutdownWatchdog();
+    static void WatchdogMain(void *args);
 
 private:
     static const char* mStrings[IDX_TOTAL_COUNT];
     jsid mStrIDs[IDX_TOTAL_COUNT];
     jsval mStrJSVals[IDX_TOTAL_COUNT];
 
     nsXPConnect* mXPConnect;
     JSRuntime*  mJSRuntime;
@@ -781,16 +788,25 @@ private:
     nsVoidArray mWrappedJSToReleaseArray;
     nsVoidArray mNativesToReleaseArray;
     JSBool mDoingFinalization;
     XPCRootSetElem *mVariantRoots;
     XPCRootSetElem *mWrappedJSRoots;
     XPCRootSetElem *mObjectHolderRoots;
     JSDHashTable mJSHolders;
     JSDHashTable mClearedGlobalObjects;
+
+    /*
+     * Variables to support watchdog thread.
+     */
+    PRLock *mWatchdogLock;
+    PRCondVar *mWatchdogWakeup;
+    PRBool mWatchdogRunning;
+    PRThread *mWatchdogThread;
+    PRIntervalTime mCurrentInterval;
 };
 
 /***************************************************************************/
 /***************************************************************************/
 // XPCContext is mostly a dumb class to hold JSContext specific data and
 // maps that let us find wrappers created for the given JSContext.
 
 // no virtuals
@@ -803,36 +819,36 @@ public:
             NS_ASSERTION(aJSContext->data2, "should already have XPCContext");
             return static_cast<XPCContext *>(aJSContext->data2);
         }
 
     XPCJSRuntime* GetRuntime() const {return mRuntime;}
     JSContext* GetJSContext() const {return mJSContext;}
 
     enum LangType {LANG_UNKNOWN, LANG_JS, LANG_NATIVE};
-    
+
     LangType GetCallingLangType() const
         {
             return mCallingLangType;
         }
     LangType SetCallingLangType(LangType lt)
         {
-            LangType tmp = mCallingLangType; 
-            mCallingLangType = lt; 
+            LangType tmp = mCallingLangType;
+            mCallingLangType = lt;
             return tmp;
         }
-    JSBool CallerTypeIsJavaScript() const 
+    JSBool CallerTypeIsJavaScript() const
         {
             return LANG_JS == mCallingLangType;
         }
-    JSBool CallerTypeIsNative() const 
+    JSBool CallerTypeIsNative() const
         {
             return LANG_NATIVE == mCallingLangType;
         }
-    JSBool CallerTypeIsKnown() const 
+    JSBool CallerTypeIsKnown() const
         {
             return LANG_UNKNOWN != mCallingLangType;
         }
 
     nsresult GetException(nsIException** e)
         {
             NS_IF_ADDREF(mException);
             *e = mException;
@@ -896,16 +912,17 @@ private:
                                      JSContext* aJSContext);
 private:
     XPCJSRuntime* mRuntime;
     JSContext*  mJSContext;
     nsresult mLastResult;
     nsresult mPendingResult;
     nsIXPCSecurityManager* mSecurityManager;
     nsIException* mException;
+    PRIntervalTime mWatchdogLimit;
     LangType mCallingLangType;
     PRUint16 mSecurityManagerFlags;
 
     // A linked list of scopes to notify when we are destroyed.
     PRCList mScopes;
 };
 
 /***************************************************************************/
@@ -1239,17 +1256,17 @@ public:
     GetPrototypeNoHelper(XPCCallContext& ccx);
 
 #ifndef XPCONNECT_STANDALONE
     nsIPrincipal*
     GetPrincipal() const
     {return mScriptObjectPrincipal ?
          mScriptObjectPrincipal->GetPrincipal() : nsnull;}
 #endif
-    
+
     JSObject*
     GetPrototypeJSFunction() const {return mPrototypeJSFunction;}
 
     void RemoveWrappedNativeProtos();
 
     static XPCWrappedNativeScope*
     FindInJSObjectScope(XPCCallContext& ccx, JSObject* obj,
                         JSBool OKIfNotInitialized = JS_FALSE);
@@ -1972,17 +1989,17 @@ public:
             mScriptableInfo->Mark();
     }
 
     // NOP. This is just here to make the AutoMarkingPtr code compile.
     inline void AutoTrace(JSTracer* trc) {}
 
     // Yes, we *do* need to mark the mScriptableInfo in both cases.
     void Mark() const
-        {mSet->Mark(); 
+        {mSet->Mark();
          if(mScriptableInfo) mScriptableInfo->Mark();}
 
 #ifdef DEBUG
     void ASSERT_SetNotMarked() const {mSet->ASSERT_NotMarked();}
 #endif
 
     ~XPCWrappedNativeProto();
 
@@ -2494,19 +2511,19 @@ public:
 
     JSObject*  CallQueryInterfaceOnJSObject(XPCCallContext& ccx,
                                             JSObject* jsobj, REFNSIID aIID);
 
     static nsresult BuildPropertyEnumerator(XPCCallContext& ccx,
                                             JSObject* aJSObj,
                                             nsISimpleEnumerator** aEnumerate);
 
-    static nsresult GetNamedPropertyAsVariant(XPCCallContext& ccx, 
+    static nsresult GetNamedPropertyAsVariant(XPCCallContext& ccx,
                                               JSObject* aJSObj,
-                                              jsval aName, 
+                                              jsval aName,
                                               nsIVariant** aResult);
 
     virtual ~nsXPCWrappedJSClass();
 
     static nsresult CheckForException(XPCCallContext & ccx,
                                       const char * aPropertyName,
                                       const char * anInterfaceName,
                                       PRBool aForceReport);
@@ -2732,17 +2749,17 @@ public:
      * @param ccx the context for the whole procedure
      * @param d [out] the resulting jsval
      * @param s the native object we're working with
      * @param type the type of object that s is
      * @param iid the interface of s that we want
      * @param scope the default scope to put on the new JSObject's __parent__
      *        chain
      * @param pErr [out] relevant error code, if any.
-     */    
+     */
     static JSBool NativeData2JS(XPCCallContext& ccx, jsval* d, const void* s,
                                 const nsXPTType& type, const nsID* iid,
                                 JSObject* scope, nsresult* pErr);
 
     static JSBool JSData2Native(XPCCallContext& ccx, void* d, jsval s,
                                 const nsXPTType& type,
                                 JSBool useAllocator, const nsID* iid,
                                 nsresult* pErr);
@@ -2766,17 +2783,17 @@ public:
                                            const nsID* iid,
                                            JSObject* scope,
                                            PRBool allowNativeWrapper,
                                            PRBool isGlobal,
                                            nsresult* pErr);
 
     static JSBool GetNativeInterfaceFromJSObject(XPCCallContext& ccx,
                                                  void** dest, JSObject* src,
-                                                 const nsID* iid, 
+                                                 const nsID* iid,
                                                  nsresult* pErr);
     static JSBool JSObject2NativeInterface(XPCCallContext& ccx,
                                            void** dest, JSObject* src,
                                            const nsID* iid,
                                            nsISupports* aOuter,
                                            nsresult* pErr);
     static JSBool GetISupportsFromJSObject(JSObject* obj, nsISupports** iface);
 
@@ -2787,17 +2804,17 @@ public:
      * @param d [out] the resulting jsval
      * @param s the native array we're working with
      * @param type the type of objects in the array
      * @param iid the interface of each object in the array that we want
      * @param count the number of items in the array
      * @param scope the default scope to put on the new JSObjects' __parent__
      *        chain
      * @param pErr [out] relevant error code, if any.
-     */    
+     */
     static JSBool NativeArray2JS(XPCCallContext& ccx,
                                  jsval* d, const void** s,
                                  const nsXPTType& type, const nsID* iid,
                                  JSUint32 count, JSObject* scope,
                                  nsresult* pErr);
 
     static JSBool JSArray2Native(XPCCallContext& ccx, void** d, jsval s,
                                  JSUint32 count, JSUint32 capacity,
@@ -2837,17 +2854,16 @@ public:
                                        nsIException** exception,
                                        JSContext* cx,
                                        jsval *jsExceptionPtr);
 
     static void RemoveXPCOMUCStringFinalizer();
 
 private:
     XPCConvert(); // not implemented
-
 };
 
 /***************************************************************************/
 
 // readable string conversions, static methods only
 class XPCStringConvert
 {
 public:
@@ -2875,17 +2891,17 @@ class XPCThrower
 class XPCThrower
 {
 public:
     static void Throw(nsresult rv, JSContext* cx);
     static void Throw(nsresult rv, XPCCallContext& ccx);
     static void ThrowBadResult(nsresult rv, nsresult result, XPCCallContext& ccx);
     static void ThrowBadParam(nsresult rv, uintN paramNum, XPCCallContext& ccx);
 #ifdef XPC_IDISPATCH_SUPPORT
-    static void ThrowCOMError(JSContext* cx, unsigned long COMErrorCode, 
+    static void ThrowCOMError(JSContext* cx, unsigned long COMErrorCode,
                               nsresult rv = NS_ERROR_XPC_COM_ERROR,
                               const EXCEPINFO * exception = nsnull);
 #endif
     static JSBool SetVerbosity(JSBool state)
         {JSBool old = sVerbose; sVerbose = state; return old;}
 
     static void BuildAndThrowException(JSContext* cx, nsresult rv, const char* sz);
     static JSBool CheckForPendingException(nsresult result, JSContext *cx);
@@ -3282,17 +3298,17 @@ private:
     JSUint32             mWrappedNativeThreadsafetyReportDepth;
 #endif
     PRThread*            mThread;
 
     static PRLock*           gLock;
     static XPCPerThreadData* gThreads;
     static PRUintn           gTLSIndex;
 
-    // Cached value of cx->thread on the main thread. 
+    // Cached value of cx->thread on the main thread.
     static void *sMainJSThread;
 
     // Cached per thread data for the main thread. Only safe to access
     // if cx->thread == sMainJSThread.
     static XPCPerThreadData *sMainThreadData;
 };
 
 /***************************************************************************/
@@ -3590,17 +3606,17 @@ private:
             mDepth = JS_SuspendRequest(mCX);
         else
             mCX = nsnull;
     }
 
     JSContext *mCX;
     jsrefcount mDepth;
 };
-        
+
 
 /*****************************************/
 
 class AutoJSRequestWithNoCallContext
 {
 public:
     AutoJSRequestWithNoCallContext(JSContext* aCX) : mCX(aCX) {BeginRequest();}
     ~AutoJSRequestWithNoCallContext() {EndRequest();}
@@ -3686,17 +3702,17 @@ public:
 public:
     AutoResolveName(XPCCallContext& ccx, jsval name)
         : mTLS(ccx.GetThreadData()),
           mOld(mTLS->SetResolveName(name)),
           mCheck(name) {}
     ~AutoResolveName()
         {
 #ifdef DEBUG
-            jsval old = 
+            jsval old =
 #endif
             mTLS->SetResolveName(mOld);
             NS_ASSERTION(old == mCheck, "Bad Nesting!");
         }
 
 private:
     XPCPerThreadData* mTLS;
     jsval mOld;
@@ -3712,54 +3728,54 @@ public:
     ~XPCMarkableJSVal() {}
     void Mark() {}
     void TraceJS(JSTracer* trc)
     {
         JS_CALL_VALUE_TRACER(trc, *mValPtr, "XPCMarkableJSVal");
     }
     void AutoTrace(JSTracer* trc) {}
 private:
-    XPCMarkableJSVal(); // not implemented    
+    XPCMarkableJSVal(); // not implemented
     jsval  mVal;
     jsval* mValPtr;
-}; 
-
-/***************************************************************************/
-// AutoMarkingPtr is the base class for the various AutoMarking pointer types 
-// below. This system allows us to temporarily protect instances of our garbage 
-// collected types after they are constructed but before they are safely 
+};
+
+/***************************************************************************/
+// AutoMarkingPtr is the base class for the various AutoMarking pointer types
+// below. This system allows us to temporarily protect instances of our garbage
+// collected types after they are constructed but before they are safely
 // attached to other rooted objects.
-// This base class has pure virtual support for marking. 
+// This base class has pure virtual support for marking.
 
 class AutoMarkingPtr
 {
 public:
     AutoMarkingPtr(XPCCallContext& ccx)
         : mNext(nsnull), mTLS(ccx.GetThreadData()) {Link();}
 
     virtual ~AutoMarkingPtr() {Unlink();}
-    
-    void Link() 
+
+    void Link()
         {if(!mTLS) return;
-         AutoMarkingPtr** list = mTLS->GetAutoRootsAdr(); 
+         AutoMarkingPtr** list = mTLS->GetAutoRootsAdr();
          mNext = *list; *list = this;}
 
-    void Unlink() 
+    void Unlink()
         {if(!mTLS) return;
-         AutoMarkingPtr** cur = mTLS->GetAutoRootsAdr(); 
+         AutoMarkingPtr** cur = mTLS->GetAutoRootsAdr();
          while(*cur != this) {
             NS_ASSERTION(*cur, "This object not in list!");
             cur = &(*cur)->mNext;
          }
          *cur = mNext;
          mTLS = nsnull;
         }
 
     AutoMarkingPtr* GetNext() {return mNext;}
-    
+
     virtual void TraceJS(JSTracer* trc) = 0;
     virtual void MarkAfterJSFinalize() = 0;
 
 protected:
     AutoMarkingPtr* mNext;
     XPCPerThreadData* mTLS;
 };
 
@@ -3798,17 +3814,17 @@ protected:                              
 // Use the macro above to define our AutoMarking types...
 
 DEFINE_AUTO_MARKING_PTR_TYPE(AutoMarkingNativeInterfacePtr, XPCNativeInterface)
 DEFINE_AUTO_MARKING_PTR_TYPE(AutoMarkingNativeSetPtr, XPCNativeSet)
 DEFINE_AUTO_MARKING_PTR_TYPE(AutoMarkingWrappedNativePtr, XPCWrappedNative)
 DEFINE_AUTO_MARKING_PTR_TYPE(AutoMarkingWrappedNativeTearOffPtr, XPCWrappedNativeTearOff)
 DEFINE_AUTO_MARKING_PTR_TYPE(AutoMarkingWrappedNativeProtoPtr, XPCWrappedNativeProto)
 DEFINE_AUTO_MARKING_PTR_TYPE(AutoMarkingJSVal, XPCMarkableJSVal)
-                                    
+
 #define DEFINE_AUTO_MARKING_ARRAY_PTR_TYPE(class_, type_)                    \
 class class_ : public AutoMarkingPtr                                         \
 {                                                                            \
 public:                                                                      \
     class_ (XPCCallContext& ccx)                                             \
         : AutoMarkingPtr(ccx), mPtr(nsnull), mCount(0) {}                    \
     class_ (XPCCallContext& ccx, type_** aPtr, PRUint32 aCount,              \
             PRBool aClear = PR_FALSE)                                        \
@@ -3853,19 +3869,19 @@ public:                                 
                                                                              \
 protected:                                                                   \
     type_ ** mPtr;                                                           \
     PRUint32 mCount;                                                         \
 };
 
 DEFINE_AUTO_MARKING_ARRAY_PTR_TYPE(AutoMarkingNativeInterfacePtrArrayPtr,
                                    XPCNativeInterface)
-    
+
 // Note: It looked like I would need one of these AutoMarkingPtr types for
-// XPCNativeScriptableInfo in order to manage marking its 
+// XPCNativeScriptableInfo in order to manage marking its
 // XPCNativeScriptableShared member during construction. But AFAICT we build
 // these and bind them to rooted things so immediately that this just is not
 // needed.
 
 #define AUTO_MARK_JSVAL_HELPER2(tok, line) tok##line
 #define AUTO_MARK_JSVAL_HELPER(tok, line) AUTO_MARK_JSVAL_HELPER2(tok, line)
 
 #define AUTO_MARK_JSVAL(ccx, val)                                            \
@@ -3898,18 +3914,18 @@ public:
     NS_DECL_CYCLE_COLLECTING_ISUPPORTS
     NS_DECL_NSIVARIANT
     NS_DECL_CYCLE_COLLECTION_CLASS(XPCVariant)
 
     // If this class ever implements nsIWritableVariant, take special care with
     // the case when mJSVal is JSVAL_STRING, since we don't own the data in
     // that case.
 
-    // We #define and iid so that out module local code can use QI to detect 
-    // if a given nsIVariant is in fact an XPCVariant. 
+    // We #define and iid so that out module local code can use QI to detect
+    // if a given nsIVariant is in fact an XPCVariant.
     NS_DECLARE_STATIC_IID_ACCESSOR(XPCVARIANT_IID)
 
     static XPCVariant* newVariant(XPCCallContext& ccx, jsval aJSVal);
 
     jsval GetJSVal() const {return mJSVal;}
 
     XPCVariant(jsval aJSVal);
 
@@ -3917,18 +3933,18 @@ public:
      * Convert a variant into a jsval.
      *
      * @param ccx the context for the whole procedure
      * @param variant the variant to convert
      * @param scope the default scope to put on the new JSObject's __parent__
      *        chain
      * @param pErr [out] relevant error code, if any.
      * @param pJSVal [out] the resulting jsval.
-     */    
-    static JSBool VariantDataToJS(XPCCallContext& ccx, 
+     */
+    static JSBool VariantDataToJS(XPCCallContext& ccx,
                                   nsIVariant* variant,
                                   JSObject* scope, nsresult* pErr,
                                   jsval* pJSVal);
 
 protected:
     virtual ~XPCVariant() { }
 
     JSBool InitializeData(XPCCallContext& ccx);
diff -r 8b3caddca8f5 js/src/xpconnect/src/xpcwrappedjsclass.cpp
--- a/js/src/xpconnect/src/xpcwrappedjsclass.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/js/src/xpconnect/src/xpcwrappedjsclass.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -276,18 +276,61 @@ nsXPCWrappedJSClass::CallQueryInterfaceO
 
     // XXX we should install an error reporter that will send reports to
     // the JS error console service.
     scriptEval.StartEvaluating();
 
     id = xpc_NewIDObject(cx, jsobj, aIID);
     if(id)
     {
+        // Throwing NS_NOINTERFACE is the prescribed way to fail QI from JS. It
+        // is not an exception that is ever worth reporting, but we don't want
+        // to eat all exceptions either.
+
+        uint32 oldOpts =
+          JS_SetOptions(cx, JS_GetOptions(cx) | JSOPTION_DONT_REPORT_UNCAUGHT);
+
         jsval args[1] = {OBJECT_TO_JSVAL(id)};
         success = JS_CallFunctionValue(cx, jsobj, fun, 1, args, &retval);
+
+        if(!success)
+        {
+            NS_ASSERTION(JS_IsExceptionPending(cx),
+                         "JS failed without setting an exception!");
+
+            jsval jsexception;
+            AUTO_MARK_JSVAL(ccx, jsexception);
+
+            if(JS_GetPendingException(cx, &jsexception) &&
+               JSVAL_IS_OBJECT(jsexception))
+            {
+                nsCOMPtr<nsIXPConnectWrappedNative> wrapper;
+
+                nsXPConnect::GetXPConnect()->
+                    GetWrappedNativeOfJSObject(ccx,
+                                               JSVAL_TO_OBJECT(jsexception),
+                                               getter_AddRefs(wrapper));
+
+                if(wrapper)
+                {
+                    nsresult rv;
+                    nsCOMPtr<nsIException> exception =
+                        do_QueryWrappedNative(wrapper);
+                    if(exception && NS_SUCCEEDED(exception->GetResult(&rv)) &&
+                       rv == NS_NOINTERFACE)
+                    {
+                        JS_ClearPendingException(cx);
+                    }
+                }
+            }
+
+            JS_ReportPendingException(cx);
+        }
+
+        JS_SetOptions(cx, oldOpts);
     }
 
     if(success)
         success = JS_ValueToObject(cx, retval, &retObj);
 
     return success ? retObj : nsnull;
 }
 
diff -r 8b3caddca8f5 js/src/xpconnect/tests/unit/test_json.js
--- a/js/src/xpconnect/tests/unit/test_json.js	Sat Nov 15 23:56:49 2008 -0800
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,131 +0,0 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code.
- *
- * The Initial Developer of the Original Code is
- * Simon Bünzli <zeniko@gmail.com>
- * Portions created by the Initial Developer are Copyright (C) 2007
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-function run_test() {
-  // converts an object to a JSON string and tests its integrity
-  function toJSONString(a) {
-    var res = JSONModule.toString(a);
-    if (!JSONModule.isMostlyHarmless(res))
-      throw new SyntaxError("Invalid JSON string: " + res);
-    return res;
-  }
-  
-  // ensures that an object can't be converted to a JSON string
-  function isInvalidType(a) {
-    try {
-      JSONModule.toString(a);
-      return false;
-    } catch (ex) {
-      return ex.name == "TypeError";
-    }
-  }
-  // ensures that a string can't be converted back to a JavaScript object
-  function isInvalidSyntax(a) {
-    try {
-      JSONModule.fromString(a);
-      return false;
-    } catch (ex) {
-      return ex.name == "SyntaxError";
-    }
-  }
-  
-  Components.utils.import("resource://gre/modules/JSON.jsm");
-  do_check_eq(typeof(JSONModule), "object");
-  
-  // some of the tests are adapted from /testing/mochitest/tests/test_Base.js
-  do_check_eq(toJSONString(true), "true");
-  do_check_eq(toJSONString(false), "false");
-  
-  do_check_eq(toJSONString(1), "1");
-  do_check_eq(toJSONString(1.23), "1.23");
-  do_check_eq(toJSONString(1.23e-45), "1.23e-45");
-  
-  do_check_true(isInvalidType(Infinity));
-  do_check_true(isInvalidType(NaN));
-  
-  //XXXzeniko: using € instead of \u20ac fails because of encoding issues
-  do_check_eq(toJSONString("Foo-Bar \b\t\n\f\r\"\\ \x01\u20ac"),
-              '"Foo-Bar \\b\\t\\n\\f\\r\\"\\\\ \\u0001\\u20ac"');
-  
-  do_check_eq(toJSONString(null), "null");
-  do_check_true(isInvalidType(undefined));
-  
-  do_check_eq(toJSONString([1, "2", 3.3]), '[1,"2",3.3]');
-  // duck-typed Array (since we'll never really get something instanceof Array)
-  do_check_eq(toJSONString({ 0: 0, 1: "1", 2: -2.2, length: 3 }), '[0,"1",-2.2]');
-  
-  var obj = { a: 1, b: "2", c: [-3e+30] };
-  do_check_eq(toJSONString(obj), '{"a":1,"b":"2","c":[-3e+30]}');
-  do_check_eq(JSONModule.toString(obj, ["b", "c"] /* keys to drop */), '{"a":1}');
-  
-  do_check_true(isInvalidType(function() { }));
-  
-  // make sure that toJSONString actually works...
-  do_check_eq(toJSONString(obj), JSONModule.toString(obj));
-  
-  do_check_eq(JSONModule.fromString("true"), true);
-  do_check_eq(JSONModule.fromString("false"), false);
-  do_check_eq(JSONModule.fromString("1"), 1);
-  do_check_eq(JSONModule.fromString('"2.2"'), "2.2");
-  do_check_eq(JSONModule.fromString("1.23e-45"), 1.23e-45);
-  do_check_true(isInvalidSyntax("NaN"));
-  
-  do_check_eq(JSONModule.fromString('"Foo-Bar \\b\\t\\n\\f\\r\\"\\\\ \\u0001\\u20ac"'),
-                              "Foo-Bar \b\t\n\f\r\"\\ \x01\u20ac");
-  do_check_true(isInvalidSyntax('"multi\nline"'));
-  do_check_eq(JSONModule.fromString("null"), null);
-  do_check_true(isInvalidSyntax("."));
-  
-  var res = JSONModule.fromString('[1,"2",3.3]');
-  do_check_eq(res.length, 3);
-  do_check_eq(res[2], 3.3);
-  // res is an instance of the sandbox's array
-  do_check_false(res instanceof Array);
-  
-  res = JSONModule.fromString(toJSONString(obj));
-  do_check_eq(res.a, obj.a);
-  do_check_eq(res.b, obj.b);
-  do_check_eq(res.c.length, obj.c.length);
-  do_check_eq(res.c[0], obj.c[0]);
-  
-  // those would throw on JSONModule.fromString if there's no object |a|
-  do_check_true(JSONModule.isMostlyHarmless("a"));
-  do_check_true(JSONModule.isMostlyHarmless("a[0]"));
-  do_check_true(JSONModule.isMostlyHarmless('a["alert(\\"P0wn3d!\\");"]'));
-  
-  do_check_false(JSONModule.isMostlyHarmless('(function() { alert("P0wn3d!"); })()'));
-  do_check_false(JSONModule.isMostlyHarmless('{ get a() { return "P0wn3d!"; } }'));
-}
diff -r 8b3caddca8f5 layout/base/nsCSSRenderingBorders.cpp
--- a/layout/base/nsCSSRenderingBorders.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/layout/base/nsCSSRenderingBorders.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -260,16 +260,20 @@ nsCSSBorderRenderer::AreBorderSideFinalS
                "AreBorderSidesSame: invalid whichSides!");
 
   /* First check if the specified styles and colors are the same for all sides */
   int firstStyle = 0;
   NS_FOR_CSS_SIDES (i) {
     if (firstStyle == i) {
       if (((1 << i) & aSides) == 0)
         firstStyle++;
+      continue;
+    }
+
+    if (((1 << i) & aSides) == 0) {
       continue;
     }
 
     if (mBorderStyles[firstStyle] != mBorderStyles[i] ||
         mBorderColors[firstStyle] != mBorderColors[i] ||
         !nsBorderColors::Equal(mCompositeColors[firstStyle],
                                mCompositeColors[i]))
       return PR_FALSE;
diff -r 8b3caddca8f5 layout/base/nsDocumentViewer.cpp
--- a/layout/base/nsDocumentViewer.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/layout/base/nsDocumentViewer.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -120,16 +120,17 @@
 #include "nsIFocusController.h"
 #include "nsIMenuParent.h"
 
 #include "nsIScrollableView.h"
 #include "nsIHTMLDocument.h"
 #include "nsITimelineService.h"
 #include "nsGfxCIID.h"
 #include "nsStyleSheetService.h"
+#include "ImageErrors.h"
 
 #include "nsIPrompt.h"
 #include "imgIContainer.h" // image animation mode constants
 
 //--------------------------
 // Printing Include
 //---------------------------
 #ifdef NS_PRINTING
@@ -958,17 +959,22 @@ DocumentViewerImpl::LoadComplete(nsresul
 
   // First, get the window from the document...
   nsPIDOMWindow *window = mDocument->GetWindow();
 
   mLoaded = PR_TRUE;
 
   // Now, fire either an OnLoad or OnError event to the document...
   PRBool restoring = PR_FALSE;
-  if(NS_SUCCEEDED(aStatus) && window) {
+  // XXXbz imagelib kills off the document load for a full-page image with
+  // NS_IMAGELIB_ERROR_LOAD_ABORTED if it's in the cache.  So we want to treat
+  // that one as a success code; otherwise whether we fire onload for the image
+  // will depend on whether it's cached!
+  if(window &&
+     (NS_SUCCEEDED(aStatus) || aStatus == NS_IMAGELIB_ERROR_LOAD_ABORTED)) {
     nsEventStatus status = nsEventStatus_eIgnore;
     nsEvent event(PR_TRUE, NS_LOAD);
     event.flags |= NS_EVENT_FLAG_CANT_BUBBLE;
      // XXX Dispatching to |window|, but using |document| as the target.
     event.target = mDocument;
 
     // If the document presentation is being restored, we don't want to fire
     // onload to the document content since that would likely confuse scripts
diff -r 8b3caddca8f5 layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/layout/base/nsLayoutUtils.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -2657,22 +2657,46 @@ nsLayoutUtils::GetClosestLayer(nsIFrame*
           layer->GetParent()->GetType() == nsGkAtoms::scrollFrame))
       break;
   }
   if (layer)
     return layer;
   return aFrame->PresContext()->PresShell()->FrameManager()->GetRootFrame();
 }
 
+/**
+ * Given an image being drawn into an appunit coordinate system, and
+ * a point in that coordinate system, map the point back into image
+ * pixel space.
+ * @param aSize the size of the image, in pixels
+ * @param aDest the rectangle that the image is being mapped into
+ * @param aPt a point in the same coordinate system as the rectangle
+ */
 static gfxPoint
 MapToFloatImagePixels(const nsIntSize& aSize,
                       const nsRect& aDest, const nsPoint& aPt)
 {
   return gfxPoint((gfxFloat(aPt.x - aDest.x)*aSize.width)/aDest.width,
                   (gfxFloat(aPt.y - aDest.y)*aSize.height)/aDest.height);
+}
+
+/**
+ * Given an image being drawn into an pixel-based coordinate system, and
+ * a point in image space, map the point into the pixel-based coordinate
+ * system.
+ * @param aSize the size of the image, in pixels
+ * @param aDest the rectangle that the image is being mapped into
+ * @param aPt a point in image space
+ */
+static gfxPoint
+MapToFloatUserPixels(const nsIntSize& aSize,
+                     const gfxRect& aDest, const gfxPoint& aPt)
+{
+  return gfxPoint(aPt.x*aDest.size.width/aSize.width + aDest.pos.x,
+                  aPt.y*aDest.size.height/aSize.height + aDest.pos.y);
 }
 
 /* static */ nsresult
 nsLayoutUtils::DrawImage(nsIRenderingContext* aRenderingContext,
                          imgIContainer*       aImage,
                          const nsRect&        aDest,
                          const nsRect&        aFill,
                          const nsPoint&       aAnchor,
@@ -2728,25 +2752,32 @@ nsLayoutUtils::DrawImage(nsIRenderingCon
   intSubimage.SizeTo(NSToIntCeil(subimageBottomRight.x) - intSubimage.x,
                      NSToIntCeil(subimageBottomRight.y) - intSubimage.y);
 
   // Compute the anchor point and compute final fill rect.
   // This code assumes that pixel-based devices have one pixel per
   // device unit!
   gfxPoint anchorPoint(aAnchor.x/appUnitsPerDevPixel,
                        aAnchor.y/appUnitsPerDevPixel);
+  gfxPoint imageSpaceAnchorPoint =
+    MapToFloatImagePixels(imageSize, aDest, aAnchor);
   gfxMatrix currentMatrix = ctx->CurrentMatrix();
+
   gfxRect finalFillRect = fill;
   if (didSnap) {
     NS_ASSERTION(!currentMatrix.HasNonAxisAlignedTransform(),
                  "How did we snap, then?");
-    anchorPoint.x = fill.pos.x + 
-        (anchorPoint.x - devPixelFill.pos.x)*fill.size.width/devPixelFill.size.width;
-    anchorPoint.y = fill.pos.y +
-        (anchorPoint.y - devPixelFill.pos.y)*fill.size.height/devPixelFill.size.height;
+    imageSpaceAnchorPoint.Round();
+    anchorPoint = imageSpaceAnchorPoint;
+    gfxRect devPixelDest(aDest.x/appUnitsPerDevPixel,
+                         aDest.y/appUnitsPerDevPixel,
+                         aDest.width/appUnitsPerDevPixel,
+                         aDest.height/appUnitsPerDevPixel);
+    anchorPoint = MapToFloatUserPixels(imageSize, devPixelDest, anchorPoint);
+    anchorPoint = currentMatrix.Transform(anchorPoint);
     anchorPoint.Round();
 
     // This form of Transform is safe to call since non-axis-aligned
     // transforms wouldn't be snapped.
     dirty = currentMatrix.Transform(dirty);
     dirty.RoundOut();
     finalFillRect = fill.Intersect(dirty);
     if (finalFillRect.IsEmpty())
@@ -2754,19 +2785,16 @@ nsLayoutUtils::DrawImage(nsIRenderingCon
 
     ctx->IdentityMatrix();
   }
   // If we're not snapping, then we ignore the dirty rect. It's hard
   // to correctly use it with arbitrary transforms --- it really *has*
   // to be aligned perfectly with pixel boundaries or the choice of
   // dirty rect will affect the values of rendered pixels.
 
-  gfxPoint imageSpaceAnchorPoint =
-    MapToFloatImagePixels(imageSize, aDest, aAnchor);
-  imageSpaceAnchorPoint.Round();
   gfxFloat scaleX = imageSize.width*appUnitsPerDevPixel/aDest.width;
   gfxFloat scaleY = imageSize.height*appUnitsPerDevPixel/aDest.height;
   if (didSnap) {
     // ctx now has the identity matrix, so we need to adjust our
     // scales to match
     scaleX /= currentMatrix.xx;
     scaleY /= currentMatrix.yy;
   }
diff -r 8b3caddca8f5 layout/build/nsLayoutModule.cpp
--- a/layout/build/nsLayoutModule.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/layout/build/nsLayoutModule.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -535,16 +535,18 @@ MAKE_CTOR(CreateVideoDocument,          
 #endif
 
 #ifdef MOZ_ENABLE_CANVAS
 MAKE_CTOR(CreateCanvasRenderingContext2D, nsIDOMCanvasRenderingContext2D, NS_NewCanvasRenderingContext2D)
 #endif
 
 NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsStyleSheetService, Init)
 
+NS_GENERIC_FACTORY_CONSTRUCTOR(nsJSURI)
+
 // views are not refcounted, so this is the same as
 // NS_GENERIC_FACTORY_CONSTRUCTOR without the NS_ADDREF/NS_RELEASE
 #define NS_GENERIC_FACTORY_CONSTRUCTOR_NOREFS(_InstanceClass)                 \
 static NS_IMETHODIMP                                                          \
 _InstanceClass##Constructor(nsISupports *aOuter, REFNSIID aIID,               \
                             void **aResult)                                   \
 {                                                                             \
     nsresult rv;                                                              \
@@ -1250,16 +1252,20 @@ static const nsModuleComponentInfo gComp
     NS_BASE_DOM_EXCEPTION_CID,
     nsnull,
     nsBaseDOMExceptionConstructor
   },
   { "JavaScript Protocol Handler",
     NS_JSPROTOCOLHANDLER_CID,
     NS_JSPROTOCOLHANDLER_CONTRACTID,
     nsJSProtocolHandler::Create },
+  { "JavaScript URI",
+    NS_JSURI_CID,
+    nsnull,
+    nsJSURIConstructor },
   { "Window Command Table",
     NS_WINDOWCOMMANDTABLE_CID,
     "",
     CreateWindowCommandTableConstructor
   },
   { "Window Command Controller",
     NS_WINDOWCONTROLLER_CID,
     NS_WINDOWCONTROLLER_CONTRACTID,
diff -r 8b3caddca8f5 layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h	Sat Nov 15 23:56:49 2008 -0800
+++ b/layout/generic/nsIFrame.h	Sat Nov 22 15:25:48 2008 -0500
@@ -691,17 +691,17 @@ public:
 
   /**
    * Accessor functions for geometric parent
    */
   nsIFrame* GetParent() const { return mParent; }
   NS_IMETHOD SetParent(const nsIFrame* aParent) { mParent = (nsIFrame*)aParent; return NS_OK; }
 
   /**
-   * Bounding rect of the frame. The values are in twips, and the origin is
+   * Bounding rect of the frame. The values are in app units, and the origin is
    * relative to the upper-left of the geometric parent. The size includes the
    * content area, borders, and padding.
    *
    * Note: moving or sizing the frame does not affect the view's size or
    * position.
    */
   nsRect GetRect() const { return mRect; }
   nsPoint GetPosition() const { return nsPoint(mRect.x, mRect.y); }
@@ -762,17 +762,17 @@ public:
   /**
    * Apply the result of GetSkipSides() on this frame to an nsMargin by
    * setting to zero any sides that are skipped.
    */
   void ApplySkipSides(nsMargin& aMargin) const;
 
   /**
    * Like the frame's rect (see |GetRect|), which is the border rect,
-   * other rectangles of the frame, in twips, relative to the parent.
+   * other rectangles of the frame, in app units, relative to the parent.
    *
    * Note that GetMarginRect is not meaningful for blocks (anything with
    * 'display:block', whether block frame or not) because of both the
    * collapsing and 'auto' issues with GetUsedMargin (on which it
    * depends).
    */
   nsRect GetMarginRect() const;
   nsRect GetPaddingRect() const;
diff -r 8b3caddca8f5 layout/reftests/bugs/413292-1.html
--- a/layout/reftests/bugs/413292-1.html	Sat Nov 15 23:56:49 2008 -0800
+++ b/layout/reftests/bugs/413292-1.html	Sat Nov 22 15:25:48 2008 -0500
@@ -23,17 +23,17 @@ function cp()
 {
   document.getElementById("iframe").setAttribute("src", src);
   setTimeout(looop, pause);
 }
 
 function looop()
 {
   loopCount++;
-  if (loopCount < 20) {
+  if (loopCount < 10) {
     ap();
   } else {
     document.body.textContent = "Done";
     document.documentElement.className = '';
   }
 }
 </script>
 
diff -r 8b3caddca8f5 layout/reftests/bugs/433640-1-ref.html
--- a/layout/reftests/bugs/433640-1-ref.html	Sat Nov 15 23:56:49 2008 -0800
+++ b/layout/reftests/bugs/433640-1-ref.html	Sat Nov 22 15:25:48 2008 -0500
@@ -23,27 +23,27 @@
 <div class="cell"><p>31.1  x 32</p><div style="width:31px; background-position:-16px -16px;"  class="image"></div></div>
 <div class="cell"><p>31.5  x 32</p><div style="width:32px; background-position:-16px -16px;"  class="image"></div></div>
 <div class="cell"><p>31.8  x 32</p><div style="width:32px; background-position:-16px -16px;"  class="image"></div></div>
 </div>
 
 <div>
 <div class="cell"><p>32    x 32</p><div style="width:32px; background-position:-16px -16px;"  class="image"></div></div>
 <div class="cell"><p>32.1  x 32</p><div style="width:32px; background-position:-16px -16px;"  class="image"></div></div>
-<div class="cell"><p>32.5  x 32</p><div style="width:33px; background-position:-15px -16px;"  class="image"></div></div>
-<div class="cell"><p>32.8  x 32</p><div style="width:33px; background-position:-15px -16px;"  class="image"></div></div>
+<div class="cell"><p>32.5  x 32</p><div style="width:33px; background-position:-16px -16px;"  class="image"></div></div>
+<div class="cell"><p>32.8  x 32</p><div style="width:33px; background-position:-16px -16px;"  class="image"></div></div>
 </div>
 
 <div>
 <div class="cell"><p>32 x 31   </p><div style="height:31px; background-position:-16px -16px;" class="image"></div></div>
 <div class="cell"><p>32 x 31.1 </p><div style="height:31px; background-position:-16px -16px;" class="image"></div></div>
 <div class="cell"><p>32 x 31.5 </p><div style="height:32px; background-position:-16px -16px;" class="image"></div></div>
 <div class="cell"><p>32 x 31.8 </p><div style="height:32px; background-position:-16px -16px;" class="image"></div></div>
 </div>
 
 <div>
 <div class="cell"><p>32 x 32   </p><div style="height:32px; background-position:-16px -16px;" class="image"></div></div>
 <div class="cell"><p>32 x 32.1 </p><div style="height:32px; background-position:-16px -16px;" class="image"></div></div>
-<div class="cell"><p>32 x 32.5 </p><div style="height:33px; background-position:-16px -15px;" class="image"></div></div>
-<div class="cell"><p>32 x 32.8 </p><div style="height:33px; background-position:-16px -15px;" class="image"></div></div>
+<div class="cell"><p>32 x 32.5 </p><div style="height:33px; background-position:-16px -16px;" class="image"></div></div>
+<div class="cell"><p>32 x 32.8 </p><div style="height:33px; background-position:-16px -16px;" class="image"></div></div>
 </div>
 
 </body></html>
diff -r 8b3caddca8f5 layout/reftests/bugs/445004-1-ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/445004-1-ref.html	Sat Nov 22 15:25:48 2008 -0500
@@ -0,0 +1,4 @@
+<!DOCTYPE html>
+<body>
+  <iframe width="500" height="200" src="subdir/445004-ref-subframe.html"></iframe>
+</body>
diff -r 8b3caddca8f5 layout/reftests/bugs/445004-1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/445004-1.html	Sat Nov 22 15:25:48 2008 -0500
@@ -0,0 +1,31 @@
+<!DOCTYPE html>
+<html class="reftest-wait">
+  <head>
+    <script>
+      var loads = 0;
+      function loadStarted() {
+        ++loads;
+      }
+      function loadEnded() {
+        --loads;
+        if (loads == 0) {
+          document.documentElement.className = "";
+        }
+      }
+      loadStarted();
+      window.onload = function() {
+        if (location.protocol != 'file:') {
+          var txt = document.createTextNode('Must be run from file://');
+          var div = document.createElement("div");
+          div.appendChild(txt);
+          document.body.appendChild(div);
+        }
+        loadEnded();
+      }
+    </script>
+  </head>  
+  <body>
+    <iframe width="500" height="200" src="subdir/445004-subframe.html"
+            onload="window.frames[0].doIt();"></iframe>
+  </body>
+</html>
diff -r 8b3caddca8f5 layout/reftests/bugs/464811-1-ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/464811-1-ref.html	Sat Nov 22 15:25:48 2008 -0500
@@ -0,0 +1,7 @@
+<!DOCTYPE HTML>
+<html>
+<body>
+<div style="background:url(mozilla-banner.gif); width:600px; height:58px;"></div>
+<div style="margin-left: 100px; background:url(mozilla-banner.gif) -100px 0px; width:1px; height:58px;"></div>
+</body>
+</html>
diff -r 8b3caddca8f5 layout/reftests/bugs/464811-1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/464811-1.html	Sat Nov 22 15:25:48 2008 -0500
@@ -0,0 +1,7 @@
+<!DOCTYPE HTML>
+<html>
+<body>
+<div style="background:url(mozilla-banner.gif); width:600px; height:58px;"></div>
+<div style="margin-left: 100.4px; background:url(mozilla-banner.gif) -100.4px 0px; width:0.2px; height:58px;"></div>
+</body>
+</html>
diff -r 8b3caddca8f5 layout/reftests/bugs/passinner.png
Binary file layout/reftests/bugs/passinner.png has changed
diff -r 8b3caddca8f5 layout/reftests/bugs/passouter.png
Binary file layout/reftests/bugs/passouter.png has changed
diff -r 8b3caddca8f5 layout/reftests/bugs/reftest.list
--- a/layout/reftests/bugs/reftest.list	Sat Nov 15 23:56:49 2008 -0800
+++ b/layout/reftests/bugs/reftest.list	Sat Nov 22 15:25:48 2008 -0500
@@ -913,16 +913,17 @@ random == 429849-1.html 429849-1-ref.htm
 == 439910.html 439910-ref.html
 == 441259-1.html 441259-1-ref.html
 fails == 441259-2.html 441259-2-ref.html # bug 441400
 == 442542-1.html 442542-1-ref.html
 == 444015-1.html 444015-1-ref.html
 == 444928-1.html 444928-1-ref.html
 == 444928-2.html 444928-2-ref.html
 != 444928-3.html 444928-3-notref.html
+== 445004-1.html 445004-1-ref.html
 == 446100-1a.html about:blank
 == 446100-1b.html about:blank
 == 446100-1c.html about:blank
 == 446100-1d.html about:blank
 == 446100-1e.html about:blank
 == 446100-1f.html about:blank
 == 446100-1g.html about:blank
 == 446100-1h.html about:blank
@@ -955,8 +956,9 @@ fails-if(MOZ_WIDGET_TOOLKIT=="cocoa") ==
 == 458487-4b.html 458487-4-ref.html
 == 458487-4c.html 458487-4-ref.html
 == 458487-5a.html 458487-5-ref.html
 == 458487-5b.html 458487-5-ref.html
 == 461266-1.html 461266-1-ref.html
 fails == 461512-1.html 461512-1-ref.html # Bug 461512
 == 463204-1.html 463204-1-ref.html
 == 463217-1.xul 463217-1-ref.xul
+== 464811-1.html 464811-1-ref.html
diff -r 8b3caddca8f5 layout/reftests/bugs/subdir/445004-ref-subframe.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/subdir/445004-ref-subframe.html	Sat Nov 22 15:25:48 2008 -0500
@@ -0,0 +1,8 @@
+<!DOCTYPE html>
+<body>
+  <iframe name="w" width="100" height="100" src="passinner.png"></iframe>
+  <iframe name="x" width="100" height="100" src="445004-ref-subsubframe.html"></iframe>
+  <iframe name="y" width="100" height="100" src="passinner.png"></iframe>
+  <iframe name="z" width="100" height="100" src="445004-ref-subsubframe.html"></iframe>
+  <img src="passinner.png">  
+</body>
diff -r 8b3caddca8f5 layout/reftests/bugs/subdir/445004-ref-subsubframe.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/subdir/445004-ref-subsubframe.html	Sat Nov 22 15:25:48 2008 -0500
@@ -0,0 +1,1 @@
+<img src="passinner.png">
diff -r 8b3caddca8f5 layout/reftests/bugs/subdir/445004-subframe.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/subdir/445004-subframe.html	Sat Nov 22 15:25:48 2008 -0500
@@ -0,0 +1,35 @@
+<!DOCTYPE html>
+<html>
+  <head>
+    <script>
+      function $(str) { return document.getElementById(str); }
+      function hookLoad(str) {
+        $(str).onload = function() { window.parent.loadEnded(); };
+        window.parent.loadStarted();
+      }
+      window.onload = function() { 
+      hookLoad("w");
+        $("w").contentWindow.location.href = "passinner.png";
+        hookLoad("x");
+        var doc = $("x").contentDocument;
+        doc.write('<img src="passinner.png">');
+        doc.close();
+      };
+      function doIt() {
+        hookLoad("y");
+        $("y").contentWindow.location.href = "passouter.png";
+        hookLoad("z");
+        var doc = $("z").contentDocument;
+        doc.write('<img src="passouter.png">');
+        doc.close();
+      }
+    </script>
+  </head>
+  <body>
+    <iframe name="w" id="w" width="100" height="100"></iframe>
+    <iframe name="x" id="x" width="100" height="100"></iframe>
+    <iframe name="y" id="y" width="100" height="100"></iframe>
+    <iframe name="z" id="z" width="100" height="100"></iframe>
+    <img src="passinner.png">
+  </body>
+</html>
diff -r 8b3caddca8f5 layout/reftests/bugs/subdir/passinner.png
Binary file layout/reftests/bugs/subdir/passinner.png has changed
diff -r 8b3caddca8f5 layout/reftests/bugs/subdir/passouter.png
Binary file layout/reftests/bugs/subdir/passouter.png has changed
diff -r 8b3caddca8f5 layout/reftests/pixel-rounding/reftest.list
--- a/layout/reftests/pixel-rounding/reftest.list	Sat Nov 15 23:56:49 2008 -0800
+++ b/layout/reftests/pixel-rounding/reftest.list	Sat Nov 22 15:25:48 2008 -0500
@@ -27,34 +27,32 @@ random == check-image.html check-image-r
 == background-color-height-top-4.html background-color-height-4.html
 == background-color-height-top-5.html background-color-height-5.html
 == background-color-height-top-6.html background-color-height-6.html
 == background-color-width-left-4.html background-color-width-4.html
 == background-color-width-left-5.html background-color-width-5.html
 == background-color-width-left-6.html background-color-width-6.html
 
 
-# The cocoa failures are due to bug 379317
 != border-base-ref.html border-height-10-ref.html
-fails-if(MOZ_WIDGET_TOOLKIT=="cocoa") == border-height-4.html border-base-ref.html
-fails-if(MOZ_WIDGET_TOOLKIT=="cocoa") == border-height-5.html border-height-10-ref.html
-fails-if(MOZ_WIDGET_TOOLKIT=="cocoa") == border-height-6.html border-height-10-ref.html
+== border-height-4.html border-base-ref.html
+== border-height-5.html border-height-10-ref.html
+== border-height-6.html border-height-10-ref.html
 != border-base-ref.html border-width-10-ref.html
-fails-if(MOZ_WIDGET_TOOLKIT=="cocoa") == border-width-4.html border-base-ref.html
-fails-if(MOZ_WIDGET_TOOLKIT=="cocoa") == border-width-5.html border-width-10-ref.html
-fails-if(MOZ_WIDGET_TOOLKIT=="cocoa") == border-width-6.html border-width-10-ref.html
+== border-width-4.html border-base-ref.html
+== border-width-5.html border-width-10-ref.html
+== border-width-6.html border-width-10-ref.html
 != border-base-ref.html border-left-10-ref.html
-fails-if(MOZ_WIDGET_TOOLKIT=="cocoa") == border-left-4.html border-base-ref.html
-fails-if(MOZ_WIDGET_TOOLKIT=="cocoa") == border-left-5.html border-left-10-ref.html
-fails-if(MOZ_WIDGET_TOOLKIT=="cocoa") == border-left-6.html border-left-10-ref.html
+== border-left-4.html border-base-ref.html
+== border-left-5.html border-left-10-ref.html
+== border-left-6.html border-left-10-ref.html
 != border-base-ref.html border-top-10-ref.html
-fails-if(MOZ_WIDGET_TOOLKIT=="cocoa") == border-top-4.html border-base-ref.html
-fails-if(MOZ_WIDGET_TOOLKIT=="cocoa") == border-top-5.html border-top-10-ref.html
-fails-if(MOZ_WIDGET_TOOLKIT=="cocoa") == border-top-6.html border-top-10-ref.html
-
+== border-top-4.html border-base-ref.html
+== border-top-5.html border-top-10-ref.html
+== border-top-6.html border-top-10-ref.html
 
 != background-image-base.html background-image-height-10-ref.html
 == background-image-height-4.html background-image-base.html
 == background-image-height-5.html background-image-height-10-ref.html
 == background-image-height-6.html background-image-height-10-ref.html
 != background-image-base.html background-image-top-10-ref.html
 == background-image-top-4.html background-image-base.html
 == background-image-top-5.html background-image-top-10-ref.html
diff -r 8b3caddca8f5 memory/jemalloc/jemalloc.c
--- a/memory/jemalloc/jemalloc.c	Sat Nov 15 23:56:49 2008 -0800
+++ b/memory/jemalloc/jemalloc.c	Sat Nov 22 15:25:48 2008 -0500
@@ -169,17 +169,17 @@
    /*
     * MALLOC_PAGEFILE causes all mmap()ed memory to be backed by temporary
     * files, so that if a chunk is mapped, it is guaranteed to be swappable.
     * This avoids asynchronous OOM failures that are due to VM over-commit.
     *
     * XXX OS X over-commits, so we should probably use mmap() instead of
     * vm_allocate(), so that MALLOC_PAGEFILE works.
     */
-#  define MALLOC_PAGEFILE
+//#  define MALLOC_PAGEFILE
 #endif
 
 #ifdef MALLOC_PAGEFILE
 /* Write size when initializing a page file. */
 #  define MALLOC_PAGEFILE_WRITE_SIZE 512
 #endif
 
 #ifdef MOZ_MEMORY_LINUX
@@ -5094,18 +5094,19 @@ malloc_ncpus(void)
 #elif (defined(MOZ_MEMORY_LINUX))
 #include <fcntl.h>
 
 static inline unsigned
 malloc_ncpus(void)
 {
 	unsigned ret;
 	int fd, nread, column;
-	char buf[1];
+	char buf[1024];
 	static const char matchstr[] = "processor\t:";
+	int i;
 
 	/*
 	 * sysconf(3) would be the preferred method for determining the number
 	 * of CPUs, but it uses malloc internally, which causes untennable
 	 * recursion during malloc initialization.
 	 */
 	fd = open("/proc/cpuinfo", O_RDONLY);
 	if (fd == -1)
@@ -5115,30 +5116,33 @@ malloc_ncpus(void)
 	 * lines.  This treats hyperthreaded CPUs as multiple processors.
 	 */
 	column = 0;
 	ret = 0;
 	while (true) {
 		nread = read(fd, &buf, sizeof(buf));
 		if (nread <= 0)
 			break; /* EOF or error. */
-
-		if (buf[0] == '\n')
-			column = 0;
-		else if (column != -1) {
-			if (buf[0] == matchstr[column]) {
-				column++;
-				if (column == sizeof(matchstr) - 1) {
+		for (i = 0;i < nread;i++) {
+			char c = buf[i];
+			if (c == '\n')
+				column = 0;
+			else if (column != -1) {
+				if (c == matchstr[column]) {
+					column++;
+					if (column == sizeof(matchstr) - 1) {
+						column = -1;
+						ret++;
+					}
+				} else
 					column = -1;
-					ret++;
-				}
-			} else
-				column = -1;
-		}
-	}
+			}
+		}
+	}
+
 	if (ret == 0)
 		ret = 1; /* Something went wrong in the parser. */
 	close(fd);
 
 	return (ret);
 }
 #elif (defined(MOZ_MEMORY_DARWIN))
 #include <mach/mach_init.h>
diff -r 8b3caddca8f5 modules/libjar/nsJAR.cpp
--- a/modules/libjar/nsJAR.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/modules/libjar/nsJAR.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -371,25 +371,18 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsJAR::GetCertificatePrincipal(const char* aFilename, nsIPrincipal** aPrincipal)
 {
   //-- Parameter check
   if (!aPrincipal)
     return NS_ERROR_NULL_POINTER;
   *aPrincipal = nsnull;
 
-  //-- Get the signature verifier service
-  nsresult rv;
-  nsCOMPtr<nsISignatureVerifier> verifier = 
-           do_GetService(SIGNATURE_VERIFIER_CONTRACTID, &rv);
-  if (NS_FAILED(rv)) // No signature verifier available
-    return NS_OK;
-
   //-- Parse the manifest
-  rv = ParseManifest(verifier);
+  nsresult rv = ParseManifest();
   if (NS_FAILED(rv)) return rv;
   if (mGlobalStatus == JAR_NO_MANIFEST)
     return NS_OK;
 
   PRInt16 requestedStatus;
   if (aFilename)
   {
     //-- Find the item
@@ -520,17 +513,17 @@ nsJAR::ReadLine(const char** src)
 #define JAR_MF 1
 #define JAR_SF 2
 #define JAR_MF_SEARCH_STRING "(M|/M)ETA-INF/(M|m)(ANIFEST|anifest).(MF|mf)$"
 #define JAR_SF_SEARCH_STRING "(M|/M)ETA-INF/*.(SF|sf)$"
 #define JAR_MF_HEADER (const char*)"Manifest-Version: 1.0"
 #define JAR_SF_HEADER (const char*)"Signature-Version: 1.0"
 
 nsresult
-nsJAR::ParseManifest(nsISignatureVerifier* verifier)
+nsJAR::ParseManifest()
 {
   //-- Verification Step 1
   if (mParsedManifest)
     return NS_OK;
   //-- (1)Manifest (MF) file
   nsCOMPtr<nsIUTF8StringEnumerator> files;
   nsresult rv = FindEntries(JAR_MF_SEARCH_STRING, getter_AddRefs(files));
   if (!files) rv = NS_ERROR_FAILURE;
@@ -601,16 +594,26 @@ nsJAR::ParseManifest(nsISignatureVerifie
     rv = LoadEntry(tempFilename.get(), getter_Copies(sigBuffer), &sigLen);
   }
   if (NS_FAILED(rv))
   {
     nsCAutoString tempFilename(sigFilename); tempFilename.Append("RSA", 3);
     rv = LoadEntry(tempFilename.get(), getter_Copies(sigBuffer), &sigLen);
   }
   if (NS_FAILED(rv))
+  {
+    mGlobalStatus = JAR_NO_MANIFEST;
+    mParsedManifest = PR_TRUE;
+    return NS_OK;
+  }
+
+  //-- Get the signature verifier service
+  nsCOMPtr<nsISignatureVerifier> verifier = 
+           do_GetService(SIGNATURE_VERIFIER_CONTRACTID, &rv);
+  if (NS_FAILED(rv)) // No signature verifier available
   {
     mGlobalStatus = JAR_NO_MANIFEST;
     mParsedManifest = PR_TRUE;
     return NS_OK;
   }
 
   //-- Verify that the signature file is a valid signature of the SF file
   PRInt32 verifyError;
diff -r 8b3caddca8f5 modules/libjar/nsJAR.h
--- a/modules/libjar/nsJAR.h	Sat Nov 15 23:56:49 2008 -0800
+++ b/modules/libjar/nsJAR.h	Sat Nov 22 15:25:48 2008 -0500
@@ -149,17 +149,17 @@ class nsJAR : public nsIZipReader, publi
     nsZipReaderCache*        mCache;          // if cached, this points to the cache it's contained in
     PRLock*                  mLock;	
     PRInt64                  mMtime;
     PRInt32                  mTotalItemsInManifest;
     
     //-- Private functions
     PRFileDesc* OpenFile();
 
-    nsresult ParseManifest(nsISignatureVerifier* verifier);
+    nsresult ParseManifest();
     void     ReportError(const char* aFilename, PRInt16 errorCode);
     nsresult LoadEntry(const char* aFilename, char** aBuf, 
                        PRUint32* aBufLen = nsnull);
     PRInt32  ReadLine(const char** src); 
     nsresult ParseOneFile(const char* filebuf, PRInt16 aFileType);
     nsresult VerifyEntry(nsJARManifestItem* aEntry, const char* aEntryData, 
                          PRUint32 aLen);
 
diff -r 8b3caddca8f5 netwerk/cache/src/nsMemoryCacheDevice.cpp
--- a/netwerk/cache/src/nsMemoryCacheDevice.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/netwerk/cache/src/nsMemoryCacheDevice.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -102,37 +102,37 @@ nsMemoryCacheDevice::Shutdown()
     mMemCacheEntries.Shutdown();
 
     // evict all entries
     nsCacheEntry * entry, * next;
 
     for (int i = kQueueCount - 1; i >= 0; --i) {
         entry = (nsCacheEntry *)PR_LIST_HEAD(&mEvictionList[i]);
         while (entry != &mEvictionList[i]) {
-            NS_ASSERTION(entry->IsInUse() == PR_FALSE, "### shutting down with active entries.\n");
+            NS_ASSERTION(entry->IsInUse() == PR_FALSE, "### shutting down with active entries");
             next = (nsCacheEntry *)PR_NEXT_LINK(entry);
             PR_REMOVE_AND_INIT_LINK(entry);
         
             // update statistics
             PRInt32 memoryRecovered = (PRInt32)entry->Size();
             mTotalSize    -= memoryRecovered;
             mInactiveSize -= memoryRecovered;
             --mEntryCount;
 
             delete entry;
             entry = next;
         }
     }
 
 /*
  * we're not factoring in changes to meta data yet...    
- *  NS_ASSERTION(mTotalSize == 0, "### mem cache leaking entries?\n");
+ *  NS_ASSERTION(mTotalSize == 0, "### mem cache leaking entries?");
  */
-    NS_ASSERTION(mInactiveSize == 0, "### mem cache leaking entries?\n");
-    NS_ASSERTION(mEntryCount == 0, "### mem cache leaking entries?\n");
+    NS_ASSERTION(mInactiveSize == 0, "### mem cache leaking entries?");
+    NS_ASSERTION(mEntryCount == 0, "### mem cache leaking entries?");
     
     mInitialized = PR_FALSE;
 
     return NS_OK;
 }
 
 
 const char *
diff -r 8b3caddca8f5 storage/src/mozStorageService.cpp
--- a/storage/src/mozStorageService.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/storage/src/mozStorageService.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -43,16 +43,17 @@
 #include "mozStorageConnection.h"
 #include "nsCRT.h"
 #include "plstr.h"
 #include "prinit.h"
 #include "nsAutoLock.h"
 #include "nsAutoPtr.h"
 #include "nsEmbedCID.h"
 #include "mozStoragePrivateHelpers.h"
+#include "nsIXPConnect.h"
 
 #include "sqlite3.h"
 
 #include "nsIPromptService.h"
 
 NS_IMPL_THREADSAFE_ISUPPORTS1(mozStorageService, mozIStorageService)
 
 mozStorageService *mozStorageService::gStorageService = nsnull;
@@ -87,20 +88,38 @@ mozStorageService::GetSingleton()
         NS_ADDREF(gStorageService);
         if (NS_FAILED(gStorageService->Init()))
             NS_RELEASE(gStorageService);
     }
 
     return gStorageService;
 }
 
+nsIXPConnect *mozStorageService::sXPConnect = nsnull;
+
+nsIXPConnect *
+mozStorageService::XPConnect()
+{
+  NS_ASSERTION(gStorageService,
+               "Can not get XPConnect without an instance of our service!");
+
+  if (!sXPConnect) {
+    (void)CallGetService(nsIXPConnect::GetCID(), &sXPConnect);
+    NS_ASSERTION(sXPConnect, "Could not get XPConnect!");
+  }
+  return sXPConnect;
+}
+
 mozStorageService::~mozStorageService()
 {
     gStorageService = nsnull;
     PR_DestroyLock(mLock);
+
+    NS_IF_RELEASE(sXPConnect);
+    sXPConnect = nsnull;
 }
 
 nsresult
 mozStorageService::Init()
 {
     mLock = PR_NewLock();
     if (!mLock)
         return NS_ERROR_OUT_OF_MEMORY;
diff -r 8b3caddca8f5 storage/src/mozStorageService.h
--- a/storage/src/mozStorageService.h	Sat Nov 15 23:56:49 2008 -0800
+++ b/storage/src/mozStorageService.h	Sat Nov 22 15:25:48 2008 -0500
@@ -46,16 +46,17 @@
 #include "nsIFile.h"
 #include "nsIObserver.h"
 #include "nsIObserverService.h"
 #include "prlock.h"
 
 #include "mozIStorageService.h"
 
 class mozStorageConnection;
+class nsIXPConnect;
 
 class mozStorageService : public mozIStorageService
 {
     friend class mozStorageConnection;
 
 public:
     // two-phase init, must call before using service
     nsresult Init();
@@ -63,23 +64,29 @@ public:
     static mozStorageService *GetSingleton();
 
     // nsISupports
     NS_DECL_ISUPPORTS
 
     // mozIStorageService
     NS_DECL_MOZISTORAGESERVICE
 
+    /**
+     * Obtains a pointer to XPConnect.  This is used by language helpers.
+     */
+    static nsIXPConnect *XPConnect();
 private:
     virtual ~mozStorageService();
 
     /**
      * Used for locking around calls when initializing connections so that we
      * can ensure that the state of sqlite3_enable_shared_cache is sane.
      */
     PRLock *mLock;
 protected:
     nsCOMPtr<nsIFile> mProfileStorageFile;
 
     static mozStorageService *gStorageService;
+
+    static nsIXPConnect *sXPConnect;
 };
 
 #endif /* _MOZSTORAGESERVICE_H_ */
diff -r 8b3caddca8f5 storage/src/mozStorageStatement.cpp
--- a/storage/src/mozStorageStatement.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/storage/src/mozStorageStatement.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -49,16 +49,18 @@
 #include "nsIProgrammingLanguage.h"
 
 #include "mozStorageConnection.h"
 #include "mozStorageStatement.h"
 #include "mozStorageStatementJSHelper.h"
 #include "mozStorageValueArray.h"
 #include "mozStoragePrivateHelpers.h"
 #include "mozStorageEvents.h"
+#include "mozStorageStatementParams.h"
+#include "mozStorageStatementRow.h"
 
 #include "prlog.h"
 
 #ifdef PR_LOGGING
 extern PRLogModuleInfo* gStorageLog;
 #endif
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -284,27 +286,52 @@ mozStorageStatement::Clone(mozIStorageSt
     NS_ADDREF(*_retval = mss);
     return NS_OK;
 }
 
 /* void finalize(); */
 NS_IMETHODIMP
 mozStorageStatement::Finalize()
 {
-    if (mDBStatement) {
+    if (!mDBStatement)
+        return NS_OK;
+
 #ifdef PR_LOGGING
-        PR_LOG(gStorageLog, PR_LOG_NOTICE, ("Finalizing statement '%s'",
-                                            sqlite3_sql(mDBStatement)));
+    PR_LOG(gStorageLog, PR_LOG_NOTICE, ("Finalizing statement '%s'",
+                                        sqlite3_sql(mDBStatement)));
 #endif
 
-        int srv = sqlite3_finalize(mDBStatement);
-        mDBStatement = NULL;
-        return ConvertResultCode(srv);
+    int srv = sqlite3_finalize(mDBStatement);
+    mDBStatement = NULL;
+
+    // We are considered dead at this point, so any wrappers for row or params
+    // need to lose their reference to us.
+    if (mStatementParamsHolder) {
+        nsCOMPtr<nsIXPConnectWrappedNative> wrapper =
+            do_QueryInterface(mStatementParamsHolder);
+        nsCOMPtr<mozIStorageStatementParams> iParams =
+            do_QueryWrappedNative(wrapper);
+        mozStorageStatementParams *params =
+            static_cast<mozStorageStatementParams *>(iParams.get());
+        params->mStatement = nsnull;
+        mStatementParamsHolder = nsnull;
     }
-    return NS_OK;
+
+    if (mStatementRowHolder) {
+        nsCOMPtr<nsIXPConnectWrappedNative> wrapper =
+            do_QueryInterface(mStatementRowHolder);
+        nsCOMPtr<mozIStorageStatementRow> iRow =
+            do_QueryWrappedNative(wrapper);
+        mozStorageStatementRow *row =
+            static_cast<mozStorageStatementRow *>(iRow.get());
+        row->mStatement = nsnull;
+        mStatementRowHolder = nsnull;
+    }
+
+    return ConvertResultCode(srv);
 }
 
 /* readonly attribute unsigned long parameterCount; */
 NS_IMETHODIMP
 mozStorageStatement::GetParameterCount(PRUint32 *aParameterCount)
 {
     NS_ENSURE_ARG_POINTER(aParameterCount);
 
diff -r 8b3caddca8f5 storage/src/mozStorageStatementJSHelper.cpp
--- a/storage/src/mozStorageStatementJSHelper.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/storage/src/mozStorageStatementJSHelper.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -34,46 +34,35 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsIXPConnect.h"
 #include "mozStorageStatement.h"
+#include "mozStorageService.h"
 
 #include "nsMemory.h"
 #include "nsString.h"
 #include "nsServiceManagerUtils.h"
 
 #include "mozStorageStatementJSHelper.h"
 
 #include "mozStorageStatementRow.h"
 #include "mozStorageStatementParams.h"
 
 #include "jsapi.h"
 
-static nsIXPConnect *sXPConnect = nsnull;
-static inline
-nsIXPConnect *
-XPConnect()
-{
-  if (!sXPConnect) {
-    (void)CallGetService(nsIXPConnect::GetCID(), &sXPConnect);
-    NS_ASSERTION(sXPConnect, "Could not get XPConnect!");
-  }
-  return sXPConnect;
-}
-
 static
 JSBool
 stepFunc(JSContext *aCtx, PRUint32, jsval *_vp)
 {
   nsCOMPtr<nsIXPConnectWrappedNative> wrapper;
-  nsresult rv = XPConnect()->GetWrappedNativeOfJSObject(
+  nsresult rv = mozStorageService::XPConnect()->GetWrappedNativeOfJSObject(
     aCtx, JS_THIS_OBJECT(aCtx, _vp), getter_AddRefs(wrapper)
   );
   if (NS_FAILED(rv)) {
     JS_ReportError(aCtx, "mozIStorageStatement::step() could not obtain native statement");
     return JS_FALSE;
   }
 
   mozStorageStatement *stmt =
@@ -115,19 +104,23 @@ mozStorageStatementJSHelper::getRow(mozS
   if (state != mozIStorageStatement::MOZ_STORAGE_STATEMENT_EXECUTING)
     return NS_ERROR_UNEXPECTED;
 
   if (!aStatement->mStatementRowHolder) {
     nsCOMPtr<mozIStorageStatementRow> row =
       new mozStorageStatementRow(aStatement);
     NS_ENSURE_TRUE(row, NS_ERROR_OUT_OF_MEMORY);
 
-    rv = XPConnect()->WrapNative(aCtx, ::JS_GetGlobalForObject(aCtx, aScopeObj),
-                                 row, NS_GET_IID(mozIStorageStatementRow),
-                                 getter_AddRefs(aStatement->mStatementRowHolder));
+    rv = mozStorageService::XPConnect()->WrapNative(
+      aCtx,
+      ::JS_GetGlobalForObject(aCtx, aScopeObj),
+      row,
+      NS_GET_IID(mozIStorageStatementRow),
+      getter_AddRefs(aStatement->mStatementRowHolder)
+    );
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   JSObject *obj = nsnull;
   rv = aStatement->mStatementRowHolder->GetJSObject(&obj);
   NS_ENSURE_SUCCESS(rv, rv);
 
   *_row = OBJECT_TO_JSVAL(obj);
@@ -146,19 +139,23 @@ mozStorageStatementJSHelper::getParams(m
   if (state != mozIStorageStatement::MOZ_STORAGE_STATEMENT_READY)
     return NS_ERROR_UNEXPECTED;
 
   if (!aStatement->mStatementParamsHolder) {
     nsCOMPtr<mozIStorageStatementParams> params =
       new mozStorageStatementParams(aStatement);
     NS_ENSURE_TRUE(params, NS_ERROR_OUT_OF_MEMORY);
 
-    rv = XPConnect()->WrapNative(aCtx, ::JS_GetGlobalForObject(aCtx, aScopeObj),
-                                 params, NS_GET_IID(mozIStorageStatementParams),
-                                 getter_AddRefs(aStatement->mStatementParamsHolder));
+    rv = mozStorageService::XPConnect()->WrapNative(
+      aCtx,
+      ::JS_GetGlobalForObject(aCtx, aScopeObj),
+      params,
+      NS_GET_IID(mozIStorageStatementParams),
+      getter_AddRefs(aStatement->mStatementParamsHolder)
+    );
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   JSObject *obj = nsnull;
   rv = aStatement->mStatementParamsHolder->GetJSObject(&obj);
   NS_ENSURE_SUCCESS(rv, rv);
 
   *_params = OBJECT_TO_JSVAL(obj);
diff -r 8b3caddca8f5 storage/src/mozStorageStatementParams.cpp
--- a/storage/src/mozStorageStatementParams.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/storage/src/mozStorageStatementParams.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -95,16 +95,18 @@ mozStorageStatementParams::GetProperty(n
 }
 
 
 /* PRBool setProperty (in nsIXPConnectWrappedNative wrapper, in JSContextPtr cx, in JSObjectPtr obj, in JSVal id, in JSValPtr vp); */
 NS_IMETHODIMP
 mozStorageStatementParams::SetProperty(nsIXPConnectWrappedNative *wrapper, JSContext * cx,
                          JSObject * obj, jsval id, jsval * vp, PRBool *_retval)
 {
+    NS_ENSURE_TRUE(mStatement, NS_ERROR_NOT_INITIALIZED);
+
     if (JSVAL_IS_INT(id)) {
         int idx = JSVAL_TO_INT(id);
 
         *_retval = JSValStorageStatementBinder (cx, mStatement, idx, *vp);
     } else if (JSVAL_IS_STRING(id)) {
         sqlite3_stmt *stmt = mStatement->GetNativeStatementPointer();
 
         JSString *str = JSVAL_TO_STRING(id);
@@ -188,16 +190,18 @@ mozStorageStatementParams::NewEnumerate(
     return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 /* PRBool newResolve (in nsIXPConnectWrappedNative wrapper, in JSContextPtr cx, in JSObjectPtr obj, in JSVal id, in PRUint32 flags, out JSObjectPtr objp); */
 NS_IMETHODIMP
 mozStorageStatementParams::NewResolve(nsIXPConnectWrappedNative *wrapper, JSContext * cx,
                                    JSObject * obj, jsval id, PRUint32 flags, JSObject * *objp, PRBool *_retval)
 {
+    NS_ENSURE_TRUE(mStatement, NS_ERROR_NOT_INITIALIZED);
+
     int idx = -1;
 
     if (JSVAL_IS_INT(id)) {
         idx = JSVAL_TO_INT(id);
     } else if (JSVAL_IS_STRING(id)) {
         JSString *str = JSVAL_TO_STRING(id);
         nsCAutoString name(":");
         name.Append(NS_ConvertUTF16toUTF8(nsDependentString((PRUnichar *)::JS_GetStringChars(str),
diff -r 8b3caddca8f5 storage/src/mozStorageStatementParams.h
--- a/storage/src/mozStorageStatementParams.h	Sat Nov 15 23:56:49 2008 -0800
+++ b/storage/src/mozStorageStatementParams.h	Sat Nov 22 15:25:48 2008 -0500
@@ -41,30 +41,34 @@
 
 #include "mozIStorageStatement.h"
 #include "mozIStorageStatementWrapper.h"
 #include "nsIXPCScriptable.h"
 
 #include "jsapi.h"
 #include "jsdate.h"
 
+class mozStorageStatement;
+
 class mozStorageStatementParams : public mozIStorageStatementParams,
                                   public nsIXPCScriptable
 {
 public:
     mozStorageStatementParams(mozIStorageStatement *aStatement);
 
     // interfaces
     NS_DECL_ISUPPORTS
     NS_DECL_MOZISTORAGESTATEMENTPARAMS
     NS_DECL_NSIXPCSCRIPTABLE
 
 protected:
-    nsCOMPtr<mozIStorageStatement> mStatement;
+    mozIStorageStatement *mStatement;
     PRUint32 mParamCount;
+
+    friend class mozStorageStatement;
 };
 
 static PRBool
 JSValStorageStatementBinder (JSContext *cx,
                              mozIStorageStatement *aStatement,
                              int aIdx,
                              jsval val)
 {
diff -r 8b3caddca8f5 storage/src/mozStorageStatementRow.cpp
--- a/storage/src/mozStorageStatementRow.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/storage/src/mozStorageStatementRow.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -87,16 +87,18 @@ mozStorageStatementRow::GetScriptableFla
     return NS_OK;
 }
 
 /* PRBool getProperty (in nsIXPConnectWrappedNative wrapper, in JSContextPtr cx, in JSObjectPtr obj, in JSVal id, in JSValPtr vp); */
 NS_IMETHODIMP
 mozStorageStatementRow::GetProperty(nsIXPConnectWrappedNative *wrapper, JSContext * cx,
                          JSObject * obj, jsval id, jsval * vp, PRBool *_retval)
 {
+    NS_ENSURE_TRUE(mStatement, NS_ERROR_NOT_INITIALIZED);
+
     if (JSVAL_IS_STRING(id)) {
         nsDependentCString jsid(::JS_GetStringBytes(JSVAL_TO_STRING(id)));
 
         PRUint32 idx;
         nsresult rv = mStatement->GetColumnIndex(jsid, &idx);
         NS_ENSURE_SUCCESS(rv, rv);
         int ctype = sqlite3_column_type(NativeStatement(), idx);
 
@@ -196,16 +198,18 @@ mozStorageStatementRow::NewEnumerate(nsI
     return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 /* PRBool newResolve (in nsIXPConnectWrappedNative wrapper, in JSContextPtr cx, in JSObjectPtr obj, in JSVal id, in PRUint32 flags, out JSObjectPtr objp); */
 NS_IMETHODIMP
 mozStorageStatementRow::NewResolve(nsIXPConnectWrappedNative *wrapper, JSContext * cx,
                                    JSObject * obj, jsval id, PRUint32 flags, JSObject * *objp, PRBool *_retval)
 {
+    NS_ENSURE_TRUE(mStatement, NS_ERROR_NOT_INITIALIZED);
+
     if (JSVAL_IS_STRING(id)) {
         JSString *str = JSVAL_TO_STRING(id);
         nsDependentCString name(::JS_GetStringBytes(str));
 
         PRUint32 idx;
         nsresult rv = mStatement->GetColumnIndex(name, &idx);
         NS_ENSURE_SUCCESS(rv, rv);
 
diff -r 8b3caddca8f5 storage/src/mozStorageStatementRow.h
--- a/storage/src/mozStorageStatementRow.h	Sat Nov 15 23:56:49 2008 -0800
+++ b/storage/src/mozStorageStatementRow.h	Sat Nov 22 15:25:48 2008 -0500
@@ -59,12 +59,14 @@ public:
 
     // nsIXPCScriptable interface
     NS_DECL_NSIXPCSCRIPTABLE
 protected:
     sqlite3_stmt* NativeStatement() {
         return mStatement->GetNativeStatementPointer();
     }
 
-    nsRefPtr<mozStorageStatement> mStatement;
+    mozStorageStatement *mStatement;
+
+    friend class mozStorageStatement;
 };
 
 #endif /* _MOZSTORAGESTATEMENTROW_H_ */
diff -r 8b3caddca8f5 testing/mochitest/Makefile.in
--- a/testing/mochitest/Makefile.in	Sat Nov 15 23:56:49 2008 -0800
+++ b/testing/mochitest/Makefile.in	Sat Nov 22 15:25:48 2008 -0500
@@ -121,16 +121,22 @@ endif
 endif
 
 ifeq ($(ENABLE_TESTS), 1)
 TEST_DRIVER_PPARGS += -DIS_TEST_BUILD=1
 else
 TEST_DRIVER_PPARGS += -DIS_TEST_BUILD=0
 endif
 
+ifeq ($(MOZ_DEBUG), 1)
+TEST_DRIVER_PPARGS += -DIS_DEBUG_BUILD=1
+else
+TEST_DRIVER_PPARGS += -DIS_DEBUG_BUILD=0
+endif
+
 runtests.py: runtests.py.in
 	$(PYTHON) $(topsrcdir)/config/Preprocessor.py \
 	$(TEST_DRIVER_PPARGS) $(DEFINES) $(ACDEFINES) $^ > $@
 
 automation.py: $(topsrcdir)/build/pgo/automation.py.in
 	$(PYTHON) $(topsrcdir)/config/Preprocessor.py \
 	$(TEST_DRIVER_PPARGS) $(DEFINES) $(ACDEFINES) $^ > $@
 
diff -r 8b3caddca8f5 testing/mochitest/runtests.py.in
--- a/testing/mochitest/runtests.py.in	Sat Nov 15 23:56:49 2008 -0800
+++ b/testing/mochitest/runtests.py.in	Sat Nov 22 15:25:48 2008 -0500
@@ -454,17 +454,18 @@ def maybeForceLeakThreshold(options):
   and platform in use.
   """
   if options.leakThreshold == INFINITY:
     if options.chrome:
       # We don't leak running the --chrome tests.
       options.leakThreshold = 0
     elif options.browserChrome:
       # We still leak a nondeterministic amount running browser-chrome tests.
-      pass
+      # But we are close to 0 (bug), so start to prevent/detect regressions. (Bug 460548)
+      options.leakThreshold = 75000
     else:
       # Normal Mochitests: no leaks.
       options.leakThreshold = 0
 
 def makeTestConfig(options):
   "Creates a test configuration file for customizing test execution."
   def boolString(b):
     if b:
diff -r 8b3caddca8f5 toolkit/components/satchel/public/nsIFormHistory.idl
--- a/toolkit/components/satchel/public/nsIFormHistory.idl	Sat Nov 15 23:56:49 2008 -0800
+++ b/toolkit/components/satchel/public/nsIFormHistory.idl	Sat Nov 22 15:25:48 2008 -0500
@@ -45,17 +45,17 @@ interface mozIStorageConnection;
  * to values the user has submitted.  So, several values may exist for a single
  * name.
  *
  * Note: this interface provides no means to access stored values.
  * Stored values are used by the FormFillController to generate
  * autocomplete matches.
  */
 
-[scriptable, uuid(d73f5924-3e39-4c67-8f4a-290b85448480)]
+[scriptable, uuid(5d7d84d1-9798-4016-bf61-a32acf09b29d)]
 interface nsIFormHistory2 : nsISupports
 {
   /**
    * Returns true if the form history has any entries.
    */
   readonly attribute boolean hasEntries;
   
   /**
@@ -84,16 +84,26 @@ interface nsIFormHistory2 : nsISupports
   boolean nameExists(in AString name);
 
   /**
    * Gets whether a name and value pair exists in the form history.
    */
   boolean entryExists(in AString name, in AString value);
 
   /**
+   * Removes entries that were created between the specified times.
+   *
+   * @param aBeginTime
+   *        The beginning of the timeframe, in microseconds
+   * @param aEndTime
+   *        The end of the timeframe, in microseconds
+   */
+  void removeEntriesByTimeframe(in long long aBeginTime, in long long aEndTime);
+
+  /**
    * Returns the underlying DB connection the form history module is using.
    */
   readonly attribute mozIStorageConnection DBConnection;
 };
 
 /**
  * nsIFormHistoryImporter is an interface for importing a Mork formhistory.dat
  * file into the new form history storage.
diff -r 8b3caddca8f5 toolkit/components/satchel/src/nsFormHistory.cpp
--- a/toolkit/components/satchel/src/nsFormHistory.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/toolkit/components/satchel/src/nsFormHistory.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -208,16 +208,22 @@ nsFormHistory::RemoveAllEntries()
   nsresult rv = RemoveEntriesInternal(nsnull);
 
   if (NS_SUCCEEDED(rv))
     rv = InitByteOrder(PR_TRUE);
   
   rv |= Flush();
   
   return rv;
+}
+
+NS_IMETHODIMP
+nsFormHistory::RemoveEntriesByTimeframe(PRInt64 aStartTime, PRInt64 aEndTime)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP
 nsFormHistory::GetDBConnection()
 {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
diff -r 8b3caddca8f5 toolkit/components/satchel/src/nsStorageFormHistory.cpp
--- a/toolkit/components/satchel/src/nsStorageFormHistory.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/toolkit/components/satchel/src/nsStorageFormHistory.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -406,16 +406,37 @@ nsFormHistory::RemoveAllEntries()
   if (NS_SUCCEEDED(oldFormHistoryFile->Exists(&fileExists)) && fileExists) {
     rv = oldFormHistoryFile->Remove(PR_FALSE);
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   return dbDeleteAll->Execute();
 }
 
+
+NS_IMETHODIMP
+nsFormHistory::RemoveEntriesByTimeframe(PRInt64 aStartTime, PRInt64 aEndTime)
+{
+  nsCOMPtr<mozIStorageStatement> stmt;
+  nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
+    "DELETE FROM moz_formhistory "
+    "WHERE firstUsed >= ?1 "
+    "AND firstUsed <= ?2"), getter_AddRefs(stmt));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // Bind the times and execute statement.
+  rv = stmt->BindInt64Parameter(0, aStartTime);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->BindInt64Parameter(1, aEndTime);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->Execute();
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  return NS_OK;
+}
 
 NS_IMETHODIMP
 nsFormHistory::GetDBConnection(mozIStorageConnection **aResult)
 {
   NS_ADDREF(*aResult = mDBConn);
   return NS_OK;
 }
 
diff -r 8b3caddca8f5 toolkit/components/satchel/test/unit/formhistory_apitest.sqlite
Binary file toolkit/components/satchel/test/unit/formhistory_apitest.sqlite has changed
diff -r 8b3caddca8f5 toolkit/components/satchel/test/unit/test_history_api.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/components/satchel/test/unit/test_history_api.js	Sat Nov 22 15:25:48 2008 -0500
@@ -0,0 +1,158 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Satchel Test Code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Justin Dolske <dolske@mozilla.com> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+var testnum = 0;
+var fh;
+
+function run_test()
+{
+  try {
+
+  // ===== test init =====
+  var testfile = do_get_file("toolkit/components/satchel/test/unit/formhistory_apitest.sqlite");
+  var profileDir = dirSvc.get("ProfD", Ci.nsIFile);
+
+  // Cleanup from any previous tests or failures.
+  var destFile = profileDir.clone();
+  destFile.append("formhistory.sqlite");
+  if (destFile.exists())
+    destFile.remove(false);
+
+  testfile.copyTo(profileDir, "formhistory.sqlite");
+
+  fh = Cc["@mozilla.org/satchel/form-history;1"].
+       getService(Ci.nsIFormHistory2);
+
+
+  // ===== 1 =====
+  // Check initial state is as expected
+  testnum++;
+  do_check_true(fh.hasEntries);
+  do_check_true(fh.nameExists("name-A"));
+  do_check_true(fh.nameExists("name-B"));
+  do_check_true(fh.nameExists("name-C"));
+  do_check_true(fh.nameExists("name-D"));
+  do_check_true(fh.entryExists("name-A", "value-A"));
+  do_check_true(fh.entryExists("name-B", "value-B1"));
+  do_check_true(fh.entryExists("name-B", "value-B2"));
+  do_check_true(fh.entryExists("name-C", "value-C"));
+  do_check_true(fh.entryExists("name-D", "value-D"));
+  // time-A/B/C/D checked below.
+
+  // ===== 2 =====
+  // Test looking for non-existant / bogus data.
+  testnum++;
+  do_check_false(fh.nameExists("blah"));
+  do_check_false(fh.nameExists(""));
+  do_check_false(fh.nameExists(null));
+  do_check_false(fh.entryExists("name-A", "blah"));
+  do_check_false(fh.entryExists("name-A", ""));
+  do_check_false(fh.entryExists("name-A", null));
+  do_check_false(fh.entryExists("blah", "value-A"));
+  do_check_false(fh.entryExists("", "value-A"));
+  do_check_false(fh.entryExists(null, "value-A"));
+
+  // ===== 3 =====
+  // Test removeEntriesForName with a single matching value
+  testnum++;
+  fh.removeEntriesForName("name-A");
+  do_check_false(fh.entryExists("name-A", "value-A"));
+  do_check_true(fh.entryExists("name-B", "value-B1"));
+  do_check_true(fh.entryExists("name-B", "value-B2"));
+  do_check_true(fh.entryExists("name-C", "value-C"));
+  do_check_true(fh.entryExists("name-D", "value-D"));
+
+  // ===== 4 =====
+  // Test removeEntriesForName with multiple matching values
+  testnum++;
+  fh.removeEntriesForName("name-B");
+  do_check_false(fh.entryExists("name-A", "value-A"));
+  do_check_false(fh.entryExists("name-B", "value-B1"));
+  do_check_false(fh.entryExists("name-B", "value-B2"));
+  do_check_true(fh.entryExists("name-C", "value-C"));
+  do_check_true(fh.entryExists("name-D", "value-D"));
+
+  // ===== 5 =====
+  // Test removing by time range (single entry, not surrounding entries)
+  testnum++;
+  do_check_true(fh.nameExists("time-A")); // firstUsed=1000, lastUsed=1000
+  do_check_true(fh.nameExists("time-B")); // firstUsed=1000, lastUsed=1099
+  do_check_true(fh.nameExists("time-C")); // firstUsed=1099, lastUsed=1099
+  do_check_true(fh.nameExists("time-D")); // firstUsed=2001, lastUsed=2001
+  fh.removeEntriesByTimeframe(1050, 2000);
+  do_check_true(fh.nameExists("time-A"));
+  do_check_true(fh.nameExists("time-B"));
+  do_check_false(fh.nameExists("time-C"));
+  do_check_true(fh.nameExists("time-D"));
+
+  // ===== 6 =====
+  // Test removing by time range (multiple entries)
+  testnum++;
+  fh.removeEntriesByTimeframe(1000, 2000);
+  do_check_false(fh.nameExists("time-A"));
+  do_check_false(fh.nameExists("time-B"));
+  do_check_false(fh.nameExists("time-C"));
+  do_check_true(fh.nameExists("time-D"));
+
+  // ===== 7 =====
+  // test removeAllEntries
+  testnum++;
+  fh.removeAllEntries();
+  do_check_false(fh.hasEntries);
+  do_check_false(fh.nameExists("name-C"));
+  do_check_false(fh.nameExists("name-D"));
+  do_check_false(fh.entryExists("name-C", "value-C"));
+  do_check_false(fh.entryExists("name-D", "value-D"));
+
+  // ===== 8 =====
+  // Add a single entry back
+  testnum++;
+  fh.addEntry("newname-A", "newvalue-A");
+  do_check_true(fh.hasEntries);
+  do_check_true(fh.entryExists("newname-A", "newvalue-A"));
+
+  // ===== 9 =====
+  // Remove the single entry
+  testnum++;
+  fh.removeEntry("newname-A", "newvalue-A");
+  do_check_false(fh.hasEntries);
+  do_check_false(fh.entryExists("newname-A", "newvalue-A"));
+
+  } catch (e) {
+    throw "FAILED in test #" + testnum + " -- " + e;
+  }
+}
diff -r 8b3caddca8f5 toolkit/content/tests/chrome/test_bug253481.xul
--- a/toolkit/content/tests/chrome/test_bug253481.xul	Sat Nov 15 23:56:49 2008 -0800
+++ b/toolkit/content/tests/chrome/test_bug253481.xul	Sat Nov 22 15:25:48 2008 -0500
@@ -36,39 +36,46 @@ https://bugzilla.mozilla.org/show_bug.cg
 <textbox id="strip" newlines="strip"/>
 <textbox id="replacewithcommas" newlines="replacewithcommas"/>
 <textbox id="stripsurroundingwhitespace" newlines="stripsurroundingwhitespace"/>
 </vbox>
 <script class="testbody" type="application/javascript;version=1.7">
 <![CDATA[
 /** Test for Bug 253481 **/
 function testPaste(name, element, expected) {
+  element.value = "";
   element.focus();
   synthesizeKey("v", { accelKey: true });
   is(element.value, expected, name);
 }
 
 SimpleTest.waitForExplicitFinish();
 
 addLoadEvent(function() {
 setTimeout(function() {
-var testString = "  hello hello  \n  world\nworld  ";
+var testString = "\n  hello hello  \n  world\nworld  \n";
 var expectedResults = {
-"pasteintact": testString,
-"pastetofirst": testString.split(/\n/)[0],
-"replacewithspaces": testString.replace('\n',' ','g'),
+// even "pasteintact" strips leading/trailing newlines
+"pasteintact": testString.replace(/^\n/, '').replace(/\n$/, ''),
+// "pastetofirst" strips leading newlines
+"pastetofirst": testString.replace(/^\n/, '').split(/\n/)[0],
+// "replacewithspaces" strips trailing newlines first - bug 432415
+"replacewithspaces": testString.replace(/\n$/, '').replace('\n',' ','g'),
+// "strip" is pretty straightforward
 "strip": testString.replace('\n','','g'),
-"replacewithcommas": testString.replace('\n',',','g'),
+// "replacewithcommas" strips leading and trailing newlines first
+"replacewithcommas": testString.replace(/^\n/, '').replace(/\n$/, '').replace('\n',',','g'),
+// "stripsurroundingwhitespace" strips all newlines and whitespace around them
 "stripsurroundingwhitespace": testString.replace(/\s*\n\s*/g,'')
 };
 
 // Put a multi-line string in the clipboard
-Components.classes["@mozilla.org/widget/clipboardhelper;1"]
-          .getService(Components.interfaces.nsIClipboardHelper)
-          .copyString(testString);
+var clip = Components.classes["@mozilla.org/widget/clipboardhelper;1"]
+                     .getService(Components.interfaces.nsIClipboardHelper);
+clip.copyString(testString);
 
 for (let [item, expected] in Iterator(expectedResults)) {
    testPaste(item, $(item), expected);
 }
 
 SimpleTest.finish();
 }, 0);
 });
diff -r 8b3caddca8f5 toolkit/mozapps/update/content/updates.js
--- a/toolkit/mozapps/update/content/updates.js	Sat Nov 15 23:56:49 2008 -0800
+++ b/toolkit/mozapps/update/content/updates.js	Sat Nov 22 15:25:48 2008 -0500
@@ -199,16 +199,18 @@ var gUpdates = {
     // Set the labels for the next / finish, extra1, and extra2 buttons
     this._setButton(bnf, nextFinishButtonString);
     this._setButton(be1, extra1ButtonString);
     this._setButton(be2, extra2ButtonString);
 
     bnf.hidden = !nextFinishButtonString;
     be1.hidden = !extra1ButtonString;
     be2.hidden = !extra2ButtonString;
+    // Hide the back button each time setButtons is called (see bug 464765)
+    this.wiz.getButton("back").hidden = true;
   },
 
   getAUSString: function(key, strings) {
     if (strings)
       return this.strings.getFormattedString(key, strings);
     return this.strings.getString(key);
   },
 
@@ -323,17 +325,16 @@ var gUpdates = {
     }
 
     // Cache the standard button labels in case we need to restore them
     this._cacheButtonStrings("next");
     this._cacheButtonStrings("finish");
     this._cacheButtonStrings("extra1");
     this._cacheButtonStrings("extra2");
 
-    this.wiz.getButton("back").hidden = true;
     this.wiz.getButton("cancel").hidden = true;
 
     // Advance to the Start page.
     var startPage = this.startPage;
     LOG("gUpdates", "onLoad - setting current page to startpage " + startPage.id);
     gUpdates.wiz.currentPage = startPage;
   },
 
@@ -735,32 +736,31 @@ var gUpdatesAvailablePage = {
     if (gUpdates.update.channel == "nightly")
       updateName = updateName + " " + gUpdates.update.buildID + " nightly";
     var updateNameElement = document.getElementById("updateName");
     updateNameElement.value = updateName;
     var updateTypeElement = document.getElementById("updateType");
     updateTypeElement.setAttribute("severity", severity);
 
     var moreInfoContent = document.getElementById("moreInfoContent");
-    var moreInfoURL = document.getElementById("moreInfoURL");
     var intro;
     if (severity == "major") {
       // for major updates, use the brandName and the version for the intro
       intro = gUpdates.getAUSString("intro_major_app_and_version",
                                     [gUpdates.brandName, gUpdates.update.version]);
       var remoteContent = document.getElementById("updateMoreInfoContent");
       // update_name and update_version need to be set before url
       // so that when attempting to download the url, we can show
       // the formatted "Download..." string
       remoteContent.update_name = gUpdates.brandName;
       remoteContent.update_version = gUpdates.update.version;
       remoteContent.url = gUpdates.update.detailsURL;
 
-      moreInfoURL.hidden = true;
       moreInfoContent.hidden = false;
+      document.getElementById("moreInfoURL").hidden = true;
       document.getElementById("updateName").hidden = true;
       document.getElementById("updateNameSep").hidden = true;
       document.getElementById("upgradeEvangelism").hidden = true;
       document.getElementById("upgradeEvangelismSep").hidden = true;
 
       // Clear the "never" pref for this version.  this is to handle the
       // scenario where the user clicked "never" for a major update and then at
       // a later point, did "Check for Updates..." and then canceled.  If we
@@ -773,19 +773,18 @@ var gUpdatesAvailablePage = {
       gPref.setBoolPref(neverPrefName, false);
     }
     else {
       // for minor updates, just use the brandName for the intro
       intro = gUpdates.getAUSString("intro_minor_app", [gUpdates.brandName]);
       // This element when hidden still receives focus events which will
       // cause assertions with debug builds so remove it if it isn't used.
       moreInfoContent.parentNode.removeChild(moreInfoContent);
-      var moreInfoURL = document.getElementById("updateMoreInfoURL");
-      moreInfoURL.setAttribute("url", gUpdates.update.detailsURL);
-      moreInfoURL.hidden = false;
+      var updateMoreInfoURL = document.getElementById("updateMoreInfoURL");
+      updateMoreInfoURL.setAttribute("url", gUpdates.update.detailsURL);
     }
     updateTypeElement.textContent = intro;
 
     var updateTitle = gUpdates.getAUSString("updatesfound_" + severity +
                                             ".title");
     gUpdates.wiz.currentPage.setAttribute("label", updateTitle);
     // this is necessary to make this change to the label of the current
     // wizard page show up
diff -r 8b3caddca8f5 toolkit/themes/gnomestripe/mozapps/plugins/pluginBlocked-16.png
Binary file toolkit/themes/gnomestripe/mozapps/plugins/pluginBlocked-16.png has changed
diff -r 8b3caddca8f5 toolkit/themes/gnomestripe/mozapps/plugins/pluginBlocked.png
Binary file toolkit/themes/gnomestripe/mozapps/plugins/pluginBlocked.png has changed
diff -r 8b3caddca8f5 toolkit/themes/gnomestripe/mozapps/plugins/pluginDisabled-16.png
Binary file toolkit/themes/gnomestripe/mozapps/plugins/pluginDisabled-16.png has changed
diff -r 8b3caddca8f5 toolkit/themes/gnomestripe/mozapps/plugins/pluginDisabled.png
Binary file toolkit/themes/gnomestripe/mozapps/plugins/pluginDisabled.png has changed
diff -r 8b3caddca8f5 toolkit/themes/pinstripe/mozapps/plugins/pluginBlocked-16.png
Binary file toolkit/themes/pinstripe/mozapps/plugins/pluginBlocked-16.png has changed
diff -r 8b3caddca8f5 toolkit/themes/pinstripe/mozapps/plugins/pluginBlocked.png
Binary file toolkit/themes/pinstripe/mozapps/plugins/pluginBlocked.png has changed
diff -r 8b3caddca8f5 toolkit/themes/pinstripe/mozapps/plugins/pluginDisabled-16.png
Binary file toolkit/themes/pinstripe/mozapps/plugins/pluginDisabled-16.png has changed
diff -r 8b3caddca8f5 toolkit/themes/pinstripe/mozapps/plugins/pluginDisabled.png
Binary file toolkit/themes/pinstripe/mozapps/plugins/pluginDisabled.png has changed
diff -r 8b3caddca8f5 toolkit/themes/winstripe/mozapps/plugins/pluginBlocked-16-aero.png
Binary file toolkit/themes/winstripe/mozapps/plugins/pluginBlocked-16-aero.png has changed
diff -r 8b3caddca8f5 toolkit/themes/winstripe/mozapps/plugins/pluginBlocked-16.png
Binary file toolkit/themes/winstripe/mozapps/plugins/pluginBlocked-16.png has changed
diff -r 8b3caddca8f5 toolkit/themes/winstripe/mozapps/plugins/pluginBlocked-aero.png
Binary file toolkit/themes/winstripe/mozapps/plugins/pluginBlocked-aero.png has changed
diff -r 8b3caddca8f5 toolkit/themes/winstripe/mozapps/plugins/pluginBlocked.png
Binary file toolkit/themes/winstripe/mozapps/plugins/pluginBlocked.png has changed
diff -r 8b3caddca8f5 toolkit/themes/winstripe/mozapps/plugins/pluginDisabled-16-aero.png
Binary file toolkit/themes/winstripe/mozapps/plugins/pluginDisabled-16-aero.png has changed
diff -r 8b3caddca8f5 toolkit/themes/winstripe/mozapps/plugins/pluginDisabled-16.png
Binary file toolkit/themes/winstripe/mozapps/plugins/pluginDisabled-16.png has changed
diff -r 8b3caddca8f5 toolkit/themes/winstripe/mozapps/plugins/pluginDisabled-aero.png
Binary file toolkit/themes/winstripe/mozapps/plugins/pluginDisabled-aero.png has changed
diff -r 8b3caddca8f5 toolkit/themes/winstripe/mozapps/plugins/pluginDisabled.png
Binary file toolkit/themes/winstripe/mozapps/plugins/pluginDisabled.png has changed
diff -r 8b3caddca8f5 widget/src/windows/nsWindow.cpp
--- a/widget/src/windows/nsWindow.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/widget/src/windows/nsWindow.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -7877,17 +7877,17 @@ nsWindow :: DealWithPopups ( HWND inWnd,
         inMsg == WM_NCRBUTTONDOWN || 
         inMsg == WM_MOVING || 
         inMsg == WM_SIZING || 
         inMsg == WM_NCLBUTTONDOWN || 
         inMsg == WM_NCMBUTTONDOWN ||
         inMsg == WM_MOUSEACTIVATE ||
         inMsg == WM_ACTIVATEAPP ||
         inMsg == WM_MENUSELECT ||
-        // Non-toplevel windows normally don't get WM_GETMINMAXINFO.
+        // Non-toplevel windows normally don't get WM_GETMINMAXINFO.
         // Therefore if a non-toplevel window gets this message, we should ignore it.
         (inMsg == WM_GETMINMAXINFO && !::GetParent(inWnd))
 #endif
         )
     {
       // Rollup if the event is outside the popup.
       PRBool rollup = !nsWindow::EventIsInsideWindow(inMsg, (nsWindow*)gRollupWidget);
 
@@ -7939,29 +7939,32 @@ nsWindow :: DealWithPopups ( HWND inWnd,
             }
           }
         }
       }
       // if we've still determined that we should still rollup everything, do it.
       else
 #endif
       if ( rollup ) {
+        // gRollupConsumeRollupEvent may be modified by
+        // nsIRollupListener::Rollup.
+        PRBool consumeRollupEvent = gRollupConsumeRollupEvent;
         // only need to deal with the last rollup for left mouse down events.
         gRollupListener->Rollup(inMsg == WM_LBUTTONDOWN ? &mLastRollup : nsnull);
 
         // Tell hook to stop processing messages
         gProcessHook = PR_FALSE;
         gRollupMsgId = 0;
         gRollupMsgWnd = NULL;
 
         // return TRUE tells Windows that the event is consumed,
         // false allows the event to be dispatched
         //
         // So if we are NOT supposed to be consuming events, let it go through
-        if (gRollupConsumeRollupEvent && inMsg != WM_RBUTTONDOWN) {
+        if (consumeRollupEvent && inMsg != WM_RBUTTONDOWN) {
           *outResult = TRUE;
           return TRUE;
         }
       }
     } // if event that might trigger a popup to rollup
   } // if rollup listeners registered
 
   return FALSE;
diff -r 8b3caddca8f5 xpcom/io/nsEscape.cpp
--- a/xpcom/io/nsEscape.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/xpcom/io/nsEscape.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -290,17 +290,17 @@ nsEscapeHTML2(const PRUnichar *aSourceBu
 {
   // if the caller didn't calculate the length
   if (aSourceBufferLen == -1) {
     aSourceBufferLen = nsCRT::strlen(aSourceBuffer); // ...then I will
   }
 
   /* XXX Hardcoded max entity len. */
   if (aSourceBufferLen >=
-      ((PR_UINT32_MAX / (6 * sizeof(PRUnichar))) + sizeof(PRUnichar)))
+      ((PR_UINT32_MAX - sizeof(PRUnichar)) / (6 * sizeof(PRUnichar))) )
     return nsnull;
 
   PRUnichar *resultBuffer = (PRUnichar *)nsMemory::Alloc(aSourceBufferLen *
                             6 * sizeof(PRUnichar) + sizeof(PRUnichar('\0')));
   PRUnichar *ptr = resultBuffer;
 
   if (resultBuffer) {
     PRInt32 i;
diff -r 8b3caddca8f5 xpfe/appshell/src/nsXULWindow.cpp
--- a/xpfe/appshell/src/nsXULWindow.cpp	Sat Nov 15 23:56:49 2008 -0800
+++ b/xpfe/appshell/src/nsXULWindow.cpp	Sat Nov 22 15:25:48 2008 -0500
@@ -86,16 +86,17 @@
 #include "nsIURI.h"
 #include "nsIDOMDocumentView.h"
 #include "nsIDOMViewCSS.h"
 #include "nsIDOMCSSStyleDeclaration.h"
 #include "nsITimelineService.h"
 #include "nsAppShellCID.h"
 #include "nsReadableUtils.h"
 #include "nsStyleConsts.h"
+#include "nsPresContext.h"
 
 #include "nsWebShellWindow.h" // get rid of this one, too...
 
 #define SIZEMODE_NORMAL    NS_LITERAL_STRING("normal")
 #define SIZEMODE_MAXIMIZED NS_LITERAL_STRING("maximized")
 #define SIZEMODE_MINIMIZED NS_LITERAL_STRING("minimized")
 
 #define WINDOWTYPE_ATTRIBUTE NS_LITERAL_STRING("windowtype")
@@ -572,18 +573,24 @@ NS_IMETHODIMP nsXULWindow::SetSize(PRInt
 NS_IMETHODIMP nsXULWindow::SetSize(PRInt32 aCX, PRInt32 aCY, PRBool aRepaint)
 {
   /* any attempt to set the window's size or position overrides the window's
      zoom state. this is important when these two states are competing while
      the window is being opened. but it should probably just always be so. */
   mWindow->SetSizeMode(nsSizeMode_Normal);
 
   mIntrinsicallySized = PR_FALSE;
+  PRInt32 devX = NSAppUnitsToIntPixels(nsPresContext::CSSPixelsToAppUnits(aCX),
+                                       float(mWindow->GetDeviceContext()->
+                                             AppUnitsPerDevPixel()));
+  PRInt32 devY = NSAppUnitsToIntPixels(nsPresContext::CSSPixelsToAppUnits(aCY),
+                                       float(mWindow->GetDeviceContext()->
+                                             AppUnitsPerDevPixel()));
 
-  NS_ENSURE_SUCCESS(mWindow->Resize(aCX, aCY, aRepaint), NS_ERROR_FAILURE);
+  NS_ENSURE_SUCCESS(mWindow->Resize(devX, devY, aRepaint), NS_ERROR_FAILURE);
   PersistentAttributesDirty(PAD_SIZE);
   SavePersistentAttributes();
   return NS_OK;
 }
 
 NS_IMETHODIMP nsXULWindow::GetSize(PRInt32* aCX, PRInt32* aCY)
 {
   return GetPositionAndSize(nsnull, nsnull, aCX, aCY);
