diff -r a131999fa900 accessible/public/Makefile.in
--- a/accessible/public/Makefile.in	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/public/Makefile.in	Sat Nov 01 13:47:50 2008 +0200
@@ -59,17 +59,16 @@ XPIDLSRCS = \
       nsIAccessibleRole.idl \
       nsIAccessibleStates.idl \
       nsPIAccessible.idl \
       nsIAccessibleDocument.idl \
       nsPIAccessibleDocument.idl \
       nsIAccessibleProvider.idl \
       nsIAccessibleSelectable.idl \
       nsIAccessNode.idl \
-      nsPIAccessNode.idl \
       nsIAccessibleEvent.idl \
       nsIAccessibleEditableText.idl \
       nsIAccessibleHyperLink.idl \
       nsIAccessibleHyperText.idl \
       nsIAccessibleTable.idl \
       nsIAccessibleText.idl \
       nsIAccessibleValue.idl \
       nsIAccessibleImage.idl \
diff -r a131999fa900 accessible/public/nsPIAccessNode.idl
--- a/accessible/public/nsPIAccessNode.idl	Thu Oct 30 23:42:02 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,49 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 2003
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Original Author: Aaron Leventhal (aaronl@netscape.com)
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either of the GNU General Public License Version 2 or later (the "GPL"),
- * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#include "nsISupports.idl"
-
-interface nsIFrame;
-
-[scriptable, uuid(b3507946-4a44-4e40-b66c-f23e320997c5)]
-interface nsPIAccessNode : nsISupports
-{
-  [noscript] void init();
-  [noscript] void shutdown();
-  [notxpcom] nsIFrame GetFrame();
-};
diff -r a131999fa900 accessible/src/atk/nsAccessibleWrap.cpp
--- a/accessible/src/atk/nsAccessibleWrap.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/atk/nsAccessibleWrap.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -319,17 +319,18 @@ void nsAccessibleWrap::ShutdownAtkObject
             MAI_ATK_OBJECT(mAtkObject)->accWrap = nsnull;
         }
         SetMaiHyperlink(nsnull);
         g_object_unref(mAtkObject);
         mAtkObject = nsnull;
     }
 }
 
-NS_IMETHODIMP nsAccessibleWrap::Shutdown()
+nsresult
+nsAccessibleWrap::Shutdown()
 {
     ShutdownAtkObject();
     return nsAccessible::Shutdown();
 }
 
 MaiHyperlink* nsAccessibleWrap::GetMaiHyperlink(PRBool aCreate /* = PR_TRUE */)
 {
     // make sure mAtkObject is created
diff -r a131999fa900 accessible/src/atk/nsAccessibleWrap.h
--- a/accessible/src/atk/nsAccessibleWrap.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/atk/nsAccessibleWrap.h	Sat Nov 01 13:47:50 2008 +0200
@@ -83,17 +83,19 @@ class MaiHyperlink;
  * implementation of AtkObject.
  */
 class nsAccessibleWrap: public nsAccessible
 {
 public:
     nsAccessibleWrap(nsIDOMNode*, nsIWeakReference *aShell);
     virtual ~nsAccessibleWrap();
     void ShutdownAtkObject();
-    NS_IMETHOD Shutdown();
+
+    // nsAccessNode
+    virtual nsresult Shutdown();
 
 #ifdef MAI_LOGGING
     virtual void DumpnsAccessibleWrapInfo(int aDepth) {}
     static PRInt32 mAccWrapCreated;
     static PRInt32 mAccWrapDeleted;
 #endif
 
     // return the atk object for this nsAccessibleWrap
diff -r a131999fa900 accessible/src/atk/nsAppRootAccessible.cpp
--- a/accessible/src/atk/nsAppRootAccessible.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/atk/nsAppRootAccessible.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -521,17 +521,17 @@ nsApplicationAccessibleWrap::nsApplicati
 }
 
 nsApplicationAccessibleWrap::~nsApplicationAccessibleWrap()
 {
     MAI_LOG_DEBUG(("======Destory AppRootAcc=%p\n", (void*)this));
     nsAccessibleWrap::ShutdownAtkObject();
 }
 
-NS_IMETHODIMP
+nsresult
 nsApplicationAccessibleWrap::Init()
 {
     // XXX following code is copied from widget/src/gtk2/nsWindow.cpp
     // we should put it to somewhere that can be used from both modules
     // see bug 390761
 
     // check if accessibility enabled/disabled by environment variable
     PRBool isGnomeATEnabled = PR_FALSE;
diff -r a131999fa900 accessible/src/atk/nsAppRootAccessible.h
--- a/accessible/src/atk/nsAppRootAccessible.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/atk/nsAppRootAccessible.h	Sat Nov 01 13:47:50 2008 +0200
@@ -49,18 +49,18 @@ public:
 public:
     static void Unload();
     static void PreCreate();
 
 public:
     nsApplicationAccessibleWrap();
     virtual ~nsApplicationAccessibleWrap();
 
-    // nsPIAccessNode
-    NS_IMETHOD Init();
+    // nsAccessNode
+    virtual nsresult Init();
 
     // return the atk object for app root accessible
     NS_IMETHOD GetNativeInterface(void **aOutAccessible);
 
     // nsApplicationAccessible
     virtual nsresult AddRootAccessible(nsIAccessible *aRootAccWrap);
     virtual nsresult RemoveRootAccessible(nsIAccessible *aRootAccWrap);
 };
diff -r a131999fa900 accessible/src/atk/nsMaiInterfaceHypertext.cpp
--- a/accessible/src/atk/nsMaiInterfaceHypertext.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/atk/nsMaiInterfaceHypertext.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -35,17 +35,17 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsMaiInterfaceHypertext.h"
 #include "nsIAccessibleDocument.h"
-#include "nsPIAccessNode.h"
+#include "nsAccessNode.h"
 
 void
 hypertextInterfaceInitCB(AtkHypertextIface *aIface)
 {
     g_return_if_fail(aIface != NULL);
 
     aIface->get_link = getLinkCB;
     aIface->get_n_links = getLinkCountCB;
diff -r a131999fa900 accessible/src/base/nsAccUtils.cpp
--- a/accessible/src/base/nsAccUtils.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/base/nsAccUtils.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -37,17 +37,16 @@
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsCoreUtils.h"
 #include "nsAccUtils.h"
 
 #include "nsIAccessibleStates.h"
 #include "nsIAccessibleTypes.h"
 #include "nsPIAccessible.h"
-#include "nsPIAccessNode.h"
 
 #include "nsAccessibleEventData.h"
 #include "nsHyperTextAccessible.h"
 #include "nsAccessibilityAtoms.h"
 #include "nsAccessible.h"
 #include "nsARIAMap.h"
 
 #include "nsIDOMXULContainerElement.h"
@@ -592,26 +591,26 @@ nsAccUtils::GetScreenCoordsForWindow(nsI
     return nsCoreUtils::GetScreenCoordsForWindow(DOMNode);
 
   return nsIntPoint(0, 0);
 }
 
 nsIntPoint
 nsAccUtils::GetScreenCoordsForParent(nsIAccessNode *aAccessNode)
 {
-  nsCOMPtr<nsPIAccessNode> parent;
+  nsRefPtr<nsAccessNode> parent;
   nsCOMPtr<nsIAccessible> accessible(do_QueryInterface(aAccessNode));
   if (accessible) {
     nsCOMPtr<nsIAccessible> parentAccessible;
     accessible->GetParent(getter_AddRefs(parentAccessible));
-    parent = do_QueryInterface(parentAccessible);
+    parent = nsAccUtils::QueryAccessNode(parentAccessible);
   } else {
     nsCOMPtr<nsIAccessNode> parentAccessNode;
     aAccessNode->GetParentNode(getter_AddRefs(parentAccessNode));
-    parent = do_QueryInterface(parentAccessNode);
+    parent = nsAccUtils::QueryAccessNode(parentAccessNode);
   }
 
   if (!parent)
     return nsIntPoint(0, 0);
 
   nsIFrame *parentFrame = parent->GetFrame();
   if (!parentFrame)
     return nsIntPoint(0, 0);
@@ -694,19 +693,19 @@ nsAccUtils::IsTextInterfaceSupportCorrec
 #endif
 
 PRInt32
 nsAccUtils::TextLength(nsIAccessible *aAccessible)
 {
   if (!IsText(aAccessible))
     return 1;
   
-  nsCOMPtr<nsPIAccessNode> pAccNode(do_QueryInterface(aAccessible));
+  nsRefPtr<nsAccessNode> accNode = nsAccUtils::QueryAccessNode(aAccessible);
   
-  nsIFrame *frame = pAccNode->GetFrame();
+  nsIFrame *frame = accNode->GetFrame();
   if (frame && frame->GetType() == nsAccessibilityAtoms::textFrame) {
     // Ensure that correct text length is calculated (with non-rendered
     // whitespace chars not counted).
     nsIContent *content = frame->GetContent();
     if (content) {
       PRUint32 length;
       nsresult rv = nsHyperTextAccessible::
         ContentToRenderedOffset(frame, content->TextLength(), &length);
diff -r a131999fa900 accessible/src/base/nsAccUtils.h
--- a/accessible/src/base/nsAccUtils.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/base/nsAccUtils.h	Sat Nov 01 13:47:50 2008 +0200
@@ -36,24 +36,27 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef nsAccUtils_h_
 #define nsAccUtils_h_
 
 #include "nsIAccessible.h"
 #include "nsIAccessNode.h"
+#include "nsIAccessibleDocument.h"
 #include "nsIAccessibleRole.h"
 #include "nsIAccessibleText.h"
 #include "nsARIAMap.h"
 
 #include "nsIDOMNode.h"
 #include "nsIPersistentProperties2.h"
 #include "nsIContent.h"
 #include "nsPoint.h"
+
+class nsAccessNode;
 
 class nsAccUtils
 {
 public:
   /**
    * Returns value of attribute from the given attributes container.
    *
    * @param aAttributes - attributes container
@@ -245,16 +248,55 @@ public:
   {
     PRUint32 state = 0;
     if (aAcc)
       aAcc->GetFinalState(&state, nsnull);
 
     return state;
   }
 
+  /**
+   * Query nsAccessNode from the given nsIAccessible.
+   */
+  static already_AddRefed<nsAccessNode>
+    QueryAccessNode(nsIAccessible *aAccessible)
+  {
+    nsAccessNode* accessNode = nsnull;
+    if (aAccessible)
+      CallQueryInterface(aAccessible, &accessNode);
+
+    return accessNode;
+  }
+
+  /**
+   * Query nsAccessNode from the given nsIAccessNode.
+   */
+  static already_AddRefed<nsAccessNode>
+    QueryAccessNode(nsIAccessNode *aAccessNode)
+  {
+    nsAccessNode* accessNode = nsnull;
+    if (aAccessNode)
+      CallQueryInterface(aAccessNode, &accessNode);
+    
+    return accessNode;
+  }
+
+  /**
+   * Query nsAccessNode from the given nsIAccessNode.
+   */
+  static already_AddRefed<nsAccessNode>
+    QueryAccessNode(nsIAccessibleDocument *aAccessibleDocument)
+  {
+    nsAccessNode* accessNode = nsnull;
+    if (aAccessibleDocument)
+      CallQueryInterface(aAccessibleDocument, &accessNode);
+    
+    return accessNode;
+  }
+
 #ifdef DEBUG_A11Y
   /**
    * Detect whether the given accessible object implements nsIAccessibleText,
    * when it is text or has text child node.
    */
   static PRBool IsTextInterfaceSupportCorrect(nsIAccessible *aAccessible);
 #endif
 
diff -r a131999fa900 accessible/src/base/nsAccessNode.cpp
--- a/accessible/src/base/nsAccessNode.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/base/nsAccessNode.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -112,17 +112,17 @@ nsIAccessibilityService *nsAccessNode::G
  
 ////////////////////////////////////////////////////////////////////////////////
 // nsAccessible. nsISupports
 
 NS_IMPL_CYCLE_COLLECTION_0(nsAccessNode)
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsAccessNode)
   NS_INTERFACE_MAP_ENTRY(nsIAccessNode)
-  NS_INTERFACE_MAP_ENTRY(nsPIAccessNode)
+  NS_INTERFACE_MAP_ENTRY(nsAccessNode)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIAccessNode)
 NS_INTERFACE_MAP_END
  
 NS_IMPL_CYCLE_COLLECTING_ADDREF_AMBIGUOUS(nsAccessNode, nsIAccessNode)
 NS_IMPL_CYCLE_COLLECTING_RELEASE_FULL(nsAccessNode, nsIAccessNode,
                                       LastRelease())
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -150,17 +150,18 @@ void nsAccessNode::LastRelease()
   if (mWeakShell) {
     Shutdown();
     NS_ASSERTION(!mWeakShell, "A Shutdown() impl forgot to call its parent's Shutdown?");
   }
   // ... then die.
   NS_DELETEXPCOM(this);
 }
 
-NS_IMETHODIMP nsAccessNode::Init()
+nsresult
+nsAccessNode::Init()
 {
   // We have to put this here, instead of constructor, otherwise
   // we don't have the virtual GetUniqueID() method for the hash key.
   // We need that for accessibles that don't have DOM nodes
 
 #ifdef DEBUG_A11Y
   NS_ASSERTION(!mIsInitialized, "Initialized twice!");
 #endif
@@ -213,17 +214,18 @@ NS_IMETHODIMP nsAccessNode::Init()
 #ifdef DEBUG_A11Y
   mIsInitialized = PR_TRUE;
 #endif
 
   return NS_OK;
 }
 
 
-NS_IMETHODIMP nsAccessNode::Shutdown()
+nsresult
+nsAccessNode::Shutdown()
 {
   mDOMNode = nsnull;
   mWeakShell = nsnull;
 
   return NS_OK;
 }
 
 NS_IMETHODIMP nsAccessNode::GetUniqueID(void **aUniqueID)
@@ -395,17 +397,18 @@ already_AddRefed<nsRootAccessible> nsAcc
 
   // nsRootAccessible has a special QI
   // that let us get that concrete type directly.
   nsRootAccessible* rootAccessible;
   accDoc->QueryInterface(NS_GET_IID(nsRootAccessible), (void**)&rootAccessible); // addrefs
   return rootAccessible;
 }
 
-nsIFrame* nsAccessNode::GetFrame()
+nsIFrame*
+nsAccessNode::GetFrame()
 {
   nsCOMPtr<nsIPresShell> shell(do_QueryReferent(mWeakShell));
   if (!shell) 
     return nsnull;  
 
   nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
   return content ? shell->GetPrimaryFrameFor(content) : nsnull;
 }
@@ -736,18 +739,19 @@ nsAccessNode::GetCacheEntry(nsAccessNode
 {
   aCache.Get(aUniqueID, aAccessNode);  // AddRefs for us
 }
 
 PLDHashOperator nsAccessNode::ClearCacheEntry(const void* aKey, nsCOMPtr<nsIAccessNode>& aAccessNode, void* aUserArg)
 {
   NS_ASSERTION(aAccessNode, "Calling ClearCacheEntry with a NULL pointer!");
   if (aAccessNode) {
-    nsCOMPtr<nsPIAccessNode> privateAccessNode(do_QueryInterface(aAccessNode));
-    privateAccessNode->Shutdown();
+    nsRefPtr<nsAccessNode> accessNode =
+      nsAccUtils::QueryAccessNode(aAccessNode);
+    accessNode->Shutdown();
   }
 
   return PL_DHASH_REMOVE;
 }
 
 void
 nsAccessNode::ClearCache(nsAccessNodeHashtable& aCache)
 {
diff -r a131999fa900 accessible/src/base/nsAccessNode.h
--- a/accessible/src/base/nsAccessNode.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/base/nsAccessNode.h	Sat Nov 01 13:47:50 2008 +0200
@@ -46,17 +46,16 @@
 #include "nsCOMPtr.h"
 #include "nsAccessibilityAtoms.h"
 #include "nsCoreUtils.h"
 #include "nsAccUtils.h"
 
 #include "nsIAccessibleTypes.h"
 #include "nsIAccessNode.h"
 #include "nsIContent.h"
-#include "nsPIAccessNode.h"
 #include "nsIDOMNode.h"
 #include "nsINameSpaceManager.h"
 #include "nsIStringBundle.h"
 #include "nsWeakReference.h"
 #include "nsInterfaceHashtable.h"
 #include "nsIAccessibilityService.h"
 
 class nsIPresShell;
@@ -70,28 +69,35 @@ class nsIDocShellTreeItem;
 class nsIDocShellTreeItem;
 
 #define ACCESSIBLE_BUNDLE_URL "chrome://global-platform/locale/accessible.properties"
 #define PLATFORM_KEYS_BUNDLE_URL "chrome://global-platform/locale/platformKeys.properties"
 
 typedef nsInterfaceHashtable<nsVoidPtrHashKey, nsIAccessNode>
         nsAccessNodeHashtable;
 
-class nsAccessNode: public nsIAccessNode,
-                    public nsPIAccessNode
+#define NS_ACCESSNODE_IMPL_CID                          \
+{  /* 13555f6e-0c0f-4002-84f6-558d47b8208e */           \
+  0x13555f6e,                                           \
+  0xc0f,                                                \
+  0x4002,                                               \
+  { 0x84, 0xf6, 0x55, 0x8d, 0x47, 0xb8, 0x20, 0x8e }    \
+}
+
+class nsAccessNode: public nsIAccessNode
 {
   public: // construction, destruction
     nsAccessNode(nsIDOMNode *, nsIWeakReference* aShell);
     virtual ~nsAccessNode();
 
     NS_DECL_CYCLE_COLLECTING_ISUPPORTS
     NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsAccessNode, nsIAccessNode)
 
     NS_DECL_NSIACCESSNODE
-    NS_DECL_NSPIACCESSNODE
+    NS_DECLARE_STATIC_IID_ACCESSOR(NS_ACCESSNODE_IMPL_CID)
 
     static void InitXPAccessibility();
     static void ShutdownXPAccessibility();
 
     /**
      * Return an application accessible.
      */
     static already_AddRefed<nsApplicationAccessibleWrap> GetApplicationAccessible();
@@ -116,16 +122,31 @@ class nsAccessNode: public nsIAccessNode
     static nsIDOMNode *gLastFocusedNode;
     static nsIAccessibilityService* GetAccService();
     already_AddRefed<nsIDOMNode> GetCurrentFocus();
 
     /**
      * Returns true when the accessible is defunct.
      */
     virtual PRBool IsDefunct() { return !mDOMNode; }
+
+    /**
+     * Initialize the access node object, add it to the cache.
+     */
+    virtual nsresult Init();
+
+    /**
+     * Shutdown the access node object.
+     */
+    virtual nsresult Shutdown();
+
+    /**
+     * Return frame for the given access node object.
+     */
+    virtual nsIFrame* GetFrame();
 
 protected:
     nsresult MakeAccessNode(nsIDOMNode *aNode, nsIAccessNode **aAccessNode);
     already_AddRefed<nsIPresShell> GetPresShell();
     nsPresContext* GetPresContext();
     already_AddRefed<nsIAccessibleDocument> GetDocAccessible();
     void LastRelease();
 
@@ -152,10 +173,13 @@ protected:
 
     static nsAccessNodeHashtable gGlobalDocAccessibleCache;
 
 private:
   static nsIAccessibilityService *sAccService;
   static nsApplicationAccessibleWrap *gApplicationAccessible;
 };
 
+NS_DEFINE_STATIC_IID_ACCESSOR(nsAccessNode,
+                              NS_ACCESSNODE_IMPL_CID)
+
 #endif
 
diff -r a131999fa900 accessible/src/base/nsAccessibilityService.cpp
--- a/accessible/src/base/nsAccessibilityService.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/base/nsAccessibilityService.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -71,17 +71,16 @@
 #include "nsIPluginInstance.h"
 #include "nsIPresShell.h"
 #include "nsISupportsUtils.h"
 #include "nsIWebNavigation.h"
 #include "nsObjectFrame.h"
 #include "nsOuterDocAccessible.h"
 #include "nsRootAccessibleWrap.h"
 #include "nsTextFragment.h"
-#include "nsPIAccessNode.h"
 #include "nsPresContext.h"
 #include "nsServiceManagerUtils.h"
 #include "nsUnicharUtils.h"
 #include "nsIWebProgress.h"
 #include "nsNetError.h"
 #include "nsDocShellLoadTypes.h"
 
 #ifdef MOZ_XUL
@@ -447,21 +446,21 @@ nsAccessibilityService::CreateRootAccess
     *aRootAcc = new nsDocAccessibleWrap(rootNode, weakShell);
   }
   else {
     *aRootAcc = new nsRootAccessibleWrap(rootNode, weakShell);
   }
   if (!*aRootAcc)
     return NS_ERROR_OUT_OF_MEMORY;
 
-  nsCOMPtr<nsPIAccessNode> privateAccessNode(do_QueryInterface(*aRootAcc));
-  privateAccessNode->Init();
+  nsRefPtr<nsAccessNode> rootAcc = nsAccUtils::QueryAccessNode(*aRootAcc);
+  rootAcc->Init();
+
   nsRoleMapEntry *roleMapEntry = nsAccUtils::GetRoleMapEntry(rootNode);
-  nsCOMPtr<nsPIAccessible> privateAccessible =
-    do_QueryInterface(privateAccessNode);
+  nsCOMPtr<nsPIAccessible> privateAccessible(do_QueryInterface(*aRootAcc));
   privateAccessible->SetRoleMapEntry(roleMapEntry);
 
   NS_ADDREF(*aRootAcc);
 
   return NS_OK;
 }
 
  /**
@@ -1243,26 +1242,26 @@ nsresult nsAccessibilityService::InitAcc
                                                 nsIAccessible **aAccessibleOut,
                                                 nsRoleMapEntry *aRoleMapEntry)
 {
   if (!aAccessibleIn) {
     return NS_ERROR_FAILURE; // No accessible to init
   }
   NS_ASSERTION(aAccessibleOut && !*aAccessibleOut, "Out param should already be cleared out");
 
-  nsCOMPtr<nsPIAccessNode> privateAccessNode = do_QueryInterface(aAccessibleIn);
-  NS_ASSERTION(privateAccessNode, "All accessibles must support nsPIAccessNode");
-  nsresult rv = privateAccessNode->Init(); // Add to cache, etc.
-  if (NS_SUCCEEDED(rv)) {
-    nsCOMPtr<nsPIAccessible> privateAccessible =
-      do_QueryInterface(privateAccessNode);
-    privateAccessible->SetRoleMapEntry(aRoleMapEntry);
-    NS_ADDREF(*aAccessibleOut = aAccessibleIn);
-  }
-  return rv;
+  nsRefPtr<nsAccessNode> acc = nsAccUtils::QueryAccessNode(aAccessibleIn);
+  nsresult rv = acc->Init(); // Add to cache, etc.
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsCOMPtr<nsPIAccessible> privateAccessible =
+    do_QueryInterface(aAccessibleIn);
+  privateAccessible->SetRoleMapEntry(aRoleMapEntry);
+  NS_ADDREF(*aAccessibleOut = aAccessibleIn);
+
+  return NS_OK;
 }
 
 static PRBool HasRelatedContent(nsIContent *aContent)
 {
   nsAutoString id;
   if (!aContent || !nsCoreUtils::GetID(aContent, id) || id.IsEmpty()) {
     return PR_FALSE;
   }
diff -r a131999fa900 accessible/src/base/nsAccessible.cpp
--- a/accessible/src/base/nsAccessible.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/base/nsAccessible.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -464,17 +464,18 @@ NS_IMETHODIMP nsAccessible::SetFirstChil
 }
 
 NS_IMETHODIMP nsAccessible::SetNextSibling(nsIAccessible *aNextSibling)
 {
   mNextSibling = aNextSibling;
   return NS_OK;
 }
 
-NS_IMETHODIMP nsAccessible::Shutdown()
+nsresult
+nsAccessible::Shutdown()
 {
   mNextSibling = nsnull;
 
   // Invalidate the child count and pointers to other accessibles, also make
   // sure none of its children point to this parent
   InvalidateChildren();
   if (mParent) {
     nsCOMPtr<nsPIAccessible> privateParent(do_QueryInterface(mParent));
@@ -1072,21 +1073,20 @@ nsAccessible::GetDeepestChildAtPoint(PRI
   // therefore accessible for containing block may be different from accessible
   // for DOM parent but GetFrameForPoint() should be called for containing block
   // to get an out of flow element.
   nsCOMPtr<nsIAccessibleDocument> accDocument;
   nsresult rv = GetAccessibleDocument(getter_AddRefs(accDocument));
   NS_ENSURE_SUCCESS(rv, rv);
   NS_ENSURE_TRUE(accDocument, NS_ERROR_FAILURE);
 
-  nsCOMPtr<nsPIAccessNode> accessNodeDocument(do_QueryInterface(accDocument));
-  NS_ASSERTION(accessNodeDocument,
-               "nsIAccessibleDocument doesn't implement nsPIAccessNode");
+  nsRefPtr<nsAccessNode> docAccessNode =
+    nsAccUtils::QueryAccessNode(accDocument);
 
-  nsIFrame *frame = accessNodeDocument->GetFrame();
+  nsIFrame *frame = docAccessNode->GetFrame();
   NS_ENSURE_STATE(frame);
 
   nsPresContext *presContext = frame->PresContext();
 
   nsIntRect screenRect = frame->GetScreenRectExternal();
   nsPoint offset(presContext->DevPixelsToAppUnits(aX - screenRect.x),
                  presContext->DevPixelsToAppUnits(aY - screenRect.y));
 
@@ -2164,30 +2164,33 @@ nsAccessible::GetAttributesInternal(nsIP
     NS_ENSURE_STATE(startContent);
     nsIDocument *doc = startContent->GetDocument();
     nsCOMPtr<nsIDOMNode> docNode = do_QueryInterface(doc);
     NS_ENSURE_STATE(docNode);
     nsIContent *topContent = nsCoreUtils::GetRoleContent(docNode);
     NS_ENSURE_STATE(topContent);
     nsAccUtils::SetLiveContainerAttributes(aAttributes, startContent,
                                            topContent);
+
     // Allow ARIA live region markup from outer documents to override
-    nsCOMPtr<nsISupports> container = doc->GetContainer();
-    nsIDocShellTreeItem *docShellTreeItem = nsnull;
-    if (container)
-      CallQueryInterface(container, &docShellTreeItem);
+    nsCOMPtr<nsISupports> container = doc->GetContainer(); 
+    nsCOMPtr<nsIDocShellTreeItem> docShellTreeItem =
+      do_QueryInterface(container);
     if (!docShellTreeItem)
       break;
-    nsIDocShellTreeItem *sameTypeParent = nsnull;
-    docShellTreeItem->GetSameTypeParent(&sameTypeParent);
+
+    nsCOMPtr<nsIDocShellTreeItem> sameTypeParent;
+    docShellTreeItem->GetSameTypeParent(getter_AddRefs(sameTypeParent));
     if (!sameTypeParent || sameTypeParent == docShellTreeItem)
       break;
+
     nsIDocument *parentDoc = doc->GetParentDocument();
     if (!parentDoc)
       break;
+
     startContent = parentDoc->FindContentForSubDocument(doc);      
   }
 
   // Expose 'display' attribute.
   nsAutoString value;
   nsresult rv = GetComputedStyleValue(EmptyString(),
                                       NS_LITERAL_STRING("display"),
                                       value);
diff -r a131999fa900 accessible/src/base/nsAccessible.h
--- a/accessible/src/base/nsAccessible.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/base/nsAccessible.h	Sat Nov 01 13:47:50 2008 +0200
@@ -115,18 +115,20 @@ public:
 
   NS_DECL_NSIACCESSIBLE
   NS_DECL_NSPIACCESSIBLE
   NS_DECL_NSIACCESSIBLEHYPERLINK
   NS_DECL_NSIACCESSIBLESELECTABLE
   NS_DECL_NSIACCESSIBLEVALUE
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_ACCESSIBLE_IMPL_CID)
 
-  // nsIAccessNode
-  NS_IMETHOD Shutdown();
+  //////////////////////////////////////////////////////////////////////////////
+  // nsAccessNode
+
+  virtual nsresult Shutdown();
 
   //////////////////////////////////////////////////////////////////////////////
   // Public methods
 
   /**
    * Returns the accessible name specified by ARIA.
    */
   nsresult GetARIAName(nsAString& aName);
diff -r a131999fa900 accessible/src/base/nsApplicationAccessible.cpp
--- a/accessible/src/base/nsApplicationAccessible.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/base/nsApplicationAccessible.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -87,17 +87,17 @@ NS_INTERFACE_MAP_END_INHERITING(nsAccess
 NS_INTERFACE_MAP_END_INHERITING(nsAccessible)
 
 NS_IMPL_ADDREF_INHERITED(nsApplicationAccessible, nsAccessible)
 NS_IMPL_RELEASE_INHERITED(nsApplicationAccessible, nsAccessible)
 
 ////////////////////////////////////////////////////////////////////////////////
 // nsIAccessNode
 
-NS_IMETHODIMP
+nsresult
 nsApplicationAccessible::Init()
 {
   nsresult rv;
   mChildren = do_CreateInstance(NS_ARRAY_CONTRACTID, &rv);
   return rv;
 }
 
 // nsIAccessible
diff -r a131999fa900 accessible/src/base/nsApplicationAccessible.h
--- a/accessible/src/base/nsApplicationAccessible.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/base/nsApplicationAccessible.h	Sat Nov 01 13:47:50 2008 +0200
@@ -61,18 +61,18 @@ public:
 public:
   nsApplicationAccessible();
 
   // nsISupports
   NS_DECL_ISUPPORTS_INHERITED
   NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(nsApplicationAccessible,
                                            nsAccessible)
 
-  // nsPIAccessNode
-  NS_IMETHOD Init();
+  // nsAccessNode
+  virtual nsresult Init();
 
   // nsIAccessible
   NS_IMETHOD GetName(nsAString & aName);
   NS_IMETHOD GetRole(PRUint32 *aRole);
   NS_IMETHOD GetFinalRole(PRUint32 *aFinalRole);
   NS_IMETHOD GetState(PRUint32 *aState, PRUint32 *aExtraState);
   NS_IMETHOD GetParent(nsIAccessible * *aParent);
   NS_IMETHOD GetNextSibling(nsIAccessible * *aNextSibling);
diff -r a131999fa900 accessible/src/base/nsBaseWidgetAccessible.cpp
--- a/accessible/src/base/nsBaseWidgetAccessible.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/base/nsBaseWidgetAccessible.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -228,26 +228,26 @@ nsLinkableAccessible::GetURI(PRInt32 aIn
         return hyperLinkAcc->GetURI(aIndex, aURI);
     }
   }
   
   return NS_ERROR_INVALID_ARG;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
-// nsLinkableAccessible. nsPIAccessNode
+// nsLinkableAccessible. nsAccessNode
 
-NS_IMETHODIMP
+nsresult
 nsLinkableAccessible::Init()
 {
   CacheActionContent();
   return nsHyperTextAccessibleWrap::Init();
 }
 
-NS_IMETHODIMP
+nsresult
 nsLinkableAccessible::Shutdown()
 {
   mActionContent = nsnull;
   return nsHyperTextAccessibleWrap::Shutdown();
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // nsLinkableAccessible
diff -r a131999fa900 accessible/src/base/nsBaseWidgetAccessible.h
--- a/accessible/src/base/nsBaseWidgetAccessible.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/base/nsBaseWidgetAccessible.h	Sat Nov 01 13:47:50 2008 +0200
@@ -88,19 +88,19 @@ public:
   NS_IMETHOD GetState(PRUint32 *aState, PRUint32 *aExtraState);
   NS_IMETHOD GetValue(nsAString& _retval);
   NS_IMETHOD TakeFocus();
   NS_IMETHOD GetKeyboardShortcut(nsAString& _retval);
 
   // nsIHyperLinkAccessible
   NS_IMETHOD GetURI(PRInt32 i, nsIURI **aURI);
 
-  // nsPIAccessNode
-  NS_IMETHOD Init();
-  NS_IMETHOD Shutdown();
+  // nsAccessNode
+  virtual nsresult Init();
+  virtual nsresult Shutdown();
 
 protected:
   /**
    * Return an accessible for cached action node.
    */
   already_AddRefed<nsIAccessible> GetActionAccessible();
 
   /**
diff -r a131999fa900 accessible/src/base/nsDocAccessible.cpp
--- a/accessible/src/base/nsDocAccessible.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/base/nsDocAccessible.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -559,18 +559,18 @@ nsDocAccessible::CacheAccessNode(void *a
 {
   // If there is an access node for the given unique ID then let's shutdown it.
   // The unique ID may be presented in the cache if originally we created
   // access node object and then we want to create accessible object when
   // DOM node is changed.
   nsCOMPtr<nsIAccessNode> accessNode;
   GetCacheEntry(mAccessNodeCache, aUniqueID, getter_AddRefs(accessNode));
   if (accessNode) {
-    nsCOMPtr<nsPIAccessNode> prAccessNode = do_QueryInterface(accessNode);
-    prAccessNode->Shutdown();
+    nsRefPtr<nsAccessNode> accNode = nsAccUtils::QueryAccessNode(accessNode);
+    accNode->Shutdown();
   }
 
   PutCacheEntry(mAccessNodeCache, aUniqueID, aAccessNode);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsDocAccessible::GetParent(nsIAccessible **aParent)
 {
@@ -593,29 +593,31 @@ NS_IMETHODIMP nsDocAccessible::GetParent
         // It should be changed to use GetAccessibleInWeakShell()
         accService->GetAccessibleFor(ownerNode, getter_AddRefs(mParent));
       }
     }
   }
   return mParent ? nsAccessible::GetParent(aParent) : NS_ERROR_FAILURE;
 }
 
-NS_IMETHODIMP nsDocAccessible::Init()
+nsresult
+nsDocAccessible::Init()
 {
   PutCacheEntry(gGlobalDocAccessibleCache, mDocument, this);
 
   AddEventListeners();
 
   nsCOMPtr<nsIAccessible> parentAccessible;  // Ensure outer doc mParent accessible
   GetParent(getter_AddRefs(parentAccessible));
 
   return nsHyperTextAccessibleWrap::Init();
 }
 
-NS_IMETHODIMP nsDocAccessible::Shutdown()
+nsresult
+nsDocAccessible::Shutdown()
 {
   if (!mWeakShell) {
     return NS_OK;  // Already shutdown
   }
 
   nsCOMPtr<nsIDocShellTreeItem> treeItem =
     nsCoreUtils::GetDocShellTreeItemFor(mDOMNode);
   ShutdownChildDocuments(treeItem);
@@ -665,25 +667,27 @@ void nsDocAccessible::ShutdownChildDocum
       nsCOMPtr<nsIDocShellTreeItem> treeItemChild;
       treeNode->GetChildAt(count, getter_AddRefs(treeItemChild));
       NS_ASSERTION(treeItemChild, "No tree item when there should be");
       if (!treeItemChild) {
         continue;
       }
       nsCOMPtr<nsIAccessibleDocument> docAccessible =
         GetDocAccessibleFor(treeItemChild);
-      nsCOMPtr<nsPIAccessNode> accessNode = do_QueryInterface(docAccessible);
-      if (accessNode) {
-        accessNode->Shutdown();
+      if (docAccessible) {
+        nsRefPtr<nsAccessNode> docAccNode =
+          nsAccUtils::QueryAccessNode(docAccessible);
+        docAccNode->Shutdown();
       }
     }
   }
 }
 
-nsIFrame* nsDocAccessible::GetFrame()
+nsIFrame*
+nsDocAccessible::GetFrame()
 {
   nsCOMPtr<nsIPresShell> shell(do_QueryReferent(mWeakShell));
 
   nsIFrame* root = nsnull;
   if (shell)
     root = shell->GetRootFrame();
 
   return root;
@@ -1831,18 +1835,18 @@ void nsDocAccessible::RefreshNodes(nsIDO
     // all pointers to them are correct
     InvalidateChildren();
     return;
   }
 
   // Shut down the actual accessible or access node
   void *uniqueID;
   accessNode->GetUniqueID(&uniqueID);
-  nsCOMPtr<nsPIAccessNode> privateAccessNode(do_QueryInterface(accessNode));
-  privateAccessNode->Shutdown();
+  nsRefPtr<nsAccessNode> accNode = nsAccUtils::QueryAccessNode(accessNode);
+  accNode->Shutdown();
 
   // Remove from hash table as well
   mAccessNodeCache.Remove(uniqueID);
 }
 
 NS_IMETHODIMP nsDocAccessible::InvalidateCacheSubtree(nsIContent *aChild,
                                                       PRUint32 aChangeEventType)
 {
diff -r a131999fa900 accessible/src/base/nsDocAccessible.h
--- a/accessible/src/base/nsDocAccessible.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/base/nsDocAccessible.h	Sat Nov 01 13:47:50 2008 +0200
@@ -91,22 +91,20 @@ class nsDocAccessible : public nsHyperTe
     virtual void ViewPositionDidChange(nsIScrollableView* aScrollable) {}
     NS_IMETHOD ScrollPositionDidChange(nsIScrollableView *aView, nscoord aX, nscoord aY);
 
     // nsIDocumentObserver
     NS_DECL_NSIDOCUMENTOBSERVER
 
     static void FlushEventsCallback(nsITimer *aTimer, void *aClosure);
 
-    // nsIAccessNode
-    NS_IMETHOD Shutdown();
-    NS_IMETHOD Init();
-
-    // nsPIAccessNode
-    NS_IMETHOD_(nsIFrame *) GetFrame(void);
+    // nsAccessNode
+    virtual nsresult Init();
+    virtual nsresult Shutdown();
+    virtual nsIFrame* GetFrame();
 
     // nsIAccessibleText
     NS_IMETHOD GetAssociatedEditor(nsIEditor **aEditor);
 
     /**
       * Non-virtual method to fire a delayed event after a 0 length timeout
       *
       * @param aEvent - the nsIAccessibleEvent event type
diff -r a131999fa900 accessible/src/base/nsRootAccessible.cpp
--- a/accessible/src/base/nsRootAccessible.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/base/nsRootAccessible.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -625,20 +625,21 @@ nsresult nsRootAccessible::HandleEventWi
     // pagehide event can be fired under several conditions, such as HTML
     // document going away, closing a window/dialog, and wizard page changing.
     // We only destroy the accessible object when it's a document accessible,
     // so that we don't destroy something still in use, like wizard page. 
     // And we only get cached document accessible to destroy, so that we don't
     // create it just to destroy it.
     nsCOMPtr<nsIDocument> doc(do_QueryInterface(aTargetNode));
     nsCOMPtr<nsIAccessibleDocument> accDoc = GetDocAccessibleFor(doc);
-    nsCOMPtr<nsPIAccessNode> privateAcc = do_QueryInterface(accDoc);
-    if (privateAcc) {
-      privateAcc->Shutdown();
+    if (accDoc) {
+      nsRefPtr<nsAccessNode> docAccNode = nsAccUtils::QueryAccessNode(accDoc);
+      docAccNode->Shutdown();
     }
+
     return NS_OK;
   }
 
   nsCOMPtr<nsIPresShell> eventShell = nsCoreUtils::GetPresShellFor(aTargetNode);
   if (!eventShell) {
     return NS_OK;
   }
 
@@ -858,20 +859,22 @@ nsresult nsRootAccessible::HandleEventWi
   else if (eventType.EqualsLiteral("DOMMenuItemActive")) {
     PRBool fireFocus = PR_FALSE;
     if (!treeItemAccessible) {
 #ifdef MOZ_XUL
       if (isTree) {
         return NS_OK; // Tree with nothing selected
       }
 #endif
-      nsCOMPtr<nsPIAccessNode> menuAccessNode = do_QueryInterface(accessible);
-      NS_ENSURE_TRUE(menuAccessNode, NS_ERROR_FAILURE);
+      nsRefPtr<nsAccessNode> menuAccessNode =
+        nsAccUtils::QueryAccessNode(accessible);
+  
       nsIFrame* menuFrame = menuAccessNode->GetFrame();
       NS_ENSURE_TRUE(menuFrame, NS_ERROR_FAILURE);
+
       nsIMenuFrame* imenuFrame;
       CallQueryInterface(menuFrame, &imenuFrame);
       if (imenuFrame)
         fireFocus = PR_TRUE;
       // QI failed for nsIMenuFrame means it's not on menu bar
       if (imenuFrame && imenuFrame->IsOnMenuBar() &&
                        !imenuFrame->IsOnActiveMenuBar()) {
         // It is a top level menuitem. Only fire a focus event when the menu bar
@@ -966,30 +969,31 @@ void nsRootAccessible::GetTargetNode(nsI
 
 void nsRootAccessible::FireFocusCallback(nsITimer *aTimer, void *aClosure)
 {
   nsRootAccessible *rootAccessible = static_cast<nsRootAccessible*>(aClosure);
   NS_ASSERTION(rootAccessible, "How did we get here without a root accessible?");
   rootAccessible->FireCurrentFocusEvent();
 }
 
-NS_IMETHODIMP
+nsresult
 nsRootAccessible::Init()
 {
   nsresult rv = nsDocAccessibleWrap::Init();
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsRefPtr<nsApplicationAccessibleWrap> root = GetApplicationAccessible();
   NS_ENSURE_STATE(root);
 
   root->AddRootAccessible(this);
   return NS_OK;
 }
 
-NS_IMETHODIMP nsRootAccessible::Shutdown()
+nsresult
+nsRootAccessible::Shutdown()
 {
   // Called manually or by nsAccessNode::LastRelease()
   if (!mWeakShell) {
     return NS_OK;  // Already shutdown
   }
 
   nsRefPtr<nsApplicationAccessibleWrap> root = GetApplicationAccessible();
   NS_ENSURE_STATE(root);
diff -r a131999fa900 accessible/src/base/nsRootAccessible.h
--- a/accessible/src/base/nsRootAccessible.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/base/nsRootAccessible.h	Sat Nov 01 13:47:50 2008 +0200
@@ -82,19 +82,19 @@ class nsRootAccessible : public nsDocAcc
                                     nsIAccessible **aRelated);
 
     // ----- nsPIAccessibleDocument -----------------------
     NS_IMETHOD FireDocLoadEvents(PRUint32 aEventType);
 
     // ----- nsIDOMEventListener --------------------------
     NS_IMETHOD HandleEvent(nsIDOMEvent* aEvent);
 
-    // nsIAccessNode
-    NS_IMETHOD Init();
-    NS_IMETHOD Shutdown();
+    // nsAccessNode
+    virtual nsresult Init();
+    virtual nsresult Shutdown();
 
     void ShutdownAll();
     
     NS_DECLARE_STATIC_IID_ACCESSOR(NS_ROOTACCESSIBLE_IMPL_CID)
 
     /**
       * Fire an accessible focus event for the current focusAccssible
       * and attach a new selection listener, if necessary.
diff -r a131999fa900 accessible/src/base/nsTextAccessible.cpp
--- a/accessible/src/base/nsTextAccessible.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/base/nsTextAccessible.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -48,17 +48,18 @@ nsTextAccessible::nsTextAccessible(nsIDO
 nsTextAccessible::nsTextAccessible(nsIDOMNode* aDOMNode, nsIWeakReference* aShell):
 nsLinkableAccessible(aDOMNode, aShell)
 { 
 }
 
 // Make sure we don't support text or other irrelevant interfaces.
 // We have nsLinkableAccessible in our inheritance chain as a convenience in order to
 // get link actions and states on the text accessibles. Windows screen readers expect that.
-NS_IMPL_ISUPPORTS_INHERITED2(nsTextAccessible, nsAccessNode, nsIAccessible, nsPIAccessible)
+NS_IMPL_ISUPPORTS_INHERITED3(nsTextAccessible, nsAccessNode,
+                             nsAccessible, nsIAccessible, nsPIAccessible)
 
 /**
   * We are text
   */
 NS_IMETHODIMP nsTextAccessible::GetRole(PRUint32 *_retval)
 {
   *_retval = nsIAccessibleRole::ROLE_TEXT_LEAF;
   return NS_OK;
diff -r a131999fa900 accessible/src/html/nsHTMLImageAccessible.cpp
--- a/accessible/src/html/nsHTMLImageAccessible.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/html/nsHTMLImageAccessible.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -338,19 +338,19 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsHTMLImageAccessible::GetImageSize(PRInt32 *aWidth, PRInt32 *aHeight)
 {
   PRInt32 x, y;
   return GetBounds(&x, &y, aWidth, aHeight);
 }
 
 ////////////////////////////////////////////////////////////////////////////////
-// nsPIAccessNode
+// nsHTMLImageAccessible. nsAccessNode
 
-NS_IMETHODIMP
+nsresult
 nsHTMLImageAccessible::Shutdown()
 {
   nsLinkableAccessible::Shutdown();
 
   if (mAccessNodeCache) {
     ClearCache(*mAccessNodeCache);
     delete mAccessNodeCache;
     mAccessNodeCache = nsnull;
@@ -411,21 +411,18 @@ nsHTMLImageAccessible::GetAreaAccessible
   GetCacheEntry(*mAccessNodeCache, (void*)(aAreaNum),
                 getter_AddRefs(accessNode));
   
   if (!accessNode) {
     accessNode = new nsHTMLAreaAccessible(domNode, this, mWeakShell);
     if (!accessNode)
       return nsnull;
     
-    nsCOMPtr<nsPIAccessNode> privateAccessNode(do_QueryInterface(accessNode));
-    NS_ASSERTION(privateAccessNode,
-                 "Accessible doesn't implement nsPIAccessNode");
-    
-    nsresult rv = privateAccessNode->Init();
+    nsRefPtr<nsAccessNode> accNode = nsAccUtils::QueryAccessNode(accessNode);
+    nsresult rv = accNode->Init();
     if (NS_FAILED(rv))
       return nsnull;
     
     PutCacheEntry(*mAccessNodeCache, (void*)(aAreaNum), accessNode);
   }
 
   nsIAccessible *accessible = nsnull;
   CallQueryInterface(accessNode, &accessible);
diff -r a131999fa900 accessible/src/html/nsHTMLImageAccessible.h
--- a/accessible/src/html/nsHTMLImageAccessible.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/html/nsHTMLImageAccessible.h	Sat Nov 01 13:47:50 2008 +0200
@@ -64,21 +64,21 @@ public:
   NS_IMETHOD GetActionName(PRUint8 aIndex, nsAString& aName);
   NS_IMETHOD DoAction(PRUint8 index);
 
   // nsIAccessibleHyperLink
   NS_IMETHOD GetAnchorCount(PRInt32 *aAnchorCount);
   NS_IMETHOD GetURI(PRInt32 aIndex, nsIURI **aURI);
   NS_IMETHOD GetAnchor(PRInt32 aIndex, nsIAccessible **aAccessible);
 
-  // nsPIAccessNode
-  NS_IMETHOD Shutdown();
-
   // nsIAccessibleImage
   NS_DECL_NSIACCESSIBLEIMAGE
+
+  // nsAccessNode
+  virtual nsresult Shutdown();
 
   // nsAccessible
   virtual nsresult GetNameInternal(nsAString& aName);
   virtual nsresult GetAttributesInternal(nsIPersistentProperties *aAttributes);
 
 protected:
   // nsAccessible
   virtual void CacheChildren();
diff -r a131999fa900 accessible/src/html/nsHTMLSelectAccessible.cpp
--- a/accessible/src/html/nsHTMLSelectAccessible.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/html/nsHTMLSelectAccessible.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -1041,17 +1041,18 @@ void nsHTMLComboboxAccessible::CacheChil
     mListAccessible->SetParent(this);
     mListAccessible->SetNextSibling(nsnull);
     mListAccessible->Init();
 
     ++ mAccChildCount;  // List accessible child successfully added
   }
 }
 
-NS_IMETHODIMP nsHTMLComboboxAccessible::Shutdown()
+nsresult
+nsHTMLComboboxAccessible::Shutdown()
 {
   nsAccessibleWrap::Shutdown();
 
   if (mListAccessible) {
     mListAccessible->Shutdown();
     mListAccessible = nsnull;
   }
   return NS_OK;
@@ -1417,17 +1418,18 @@ nsHTMLComboboxButtonAccessible::GetState
 
 nsHTMLComboboxListAccessible::nsHTMLComboboxListAccessible(nsIAccessible *aParent,
                                                            nsIDOMNode* aDOMNode,
                                                            nsIWeakReference* aShell):
 nsHTMLSelectListAccessible(aDOMNode, aShell)
 {
 }
 
-nsIFrame *nsHTMLComboboxListAccessible::GetFrame()
+nsIFrame*
+nsHTMLComboboxListAccessible::GetFrame()
 {
   nsIFrame* frame = nsHTMLSelectListAccessible::GetFrame();
 
   if (frame) {
     nsIComboboxControlFrame* comboBox;
     CallQueryInterface(frame, &comboBox);
     if (comboBox) {
       return comboBox->GetDropDown();
diff -r a131999fa900 accessible/src/html/nsHTMLSelectAccessible.h
--- a/accessible/src/html/nsHTMLSelectAccessible.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/html/nsHTMLSelectAccessible.h	Sat Nov 01 13:47:50 2008 +0200
@@ -221,17 +221,19 @@ public:
   NS_IMETHOD GetState(PRUint32 *aState, PRUint32 *aExtraState);
   NS_IMETHOD GetValue(nsAString& _retval);
   NS_IMETHOD GetDescription(nsAString& aDescription);
   NS_IMETHOD DoAction(PRUint8 index);
   NS_IMETHOD GetNumActions(PRUint8 *aNumActions);
   NS_IMETHOD GetActionName(PRUint8 aIndex, nsAString& aName);
 
   void CacheChildren();
-  NS_IMETHOD Shutdown();
+
+  // nsAccessNode
+  virtual nsresult Shutdown();
 
 protected:
   already_AddRefed<nsIAccessible> GetFocusedOptionAccessible();
 
 private:
   nsRefPtr<nsHTMLComboboxListAccessible> mListAccessible;
 };
 
@@ -300,15 +302,15 @@ public:
                                nsIWeakReference* aShell);
   virtual ~nsHTMLComboboxListAccessible() {}
 
   /* ----- nsIAccessible ----- */
   NS_IMETHOD GetState(PRUint32 *aState, PRUint32 *aExtraState);
   NS_IMETHOD GetParent(nsIAccessible **aParent);
   NS_IMETHOD GetUniqueID(void **aUniqueID);
 
-  // nsPIAccessNode
-  NS_IMETHOD_(nsIFrame *) GetFrame(void);
+  // nsAccessNode
+  virtual nsIFrame* GetFrame();
 
   virtual void GetBoundsRect(nsRect& aBounds, nsIFrame** aBoundingFrame);
 };
 
 #endif
diff -r a131999fa900 accessible/src/html/nsHTMLTableAccessible.cpp
--- a/accessible/src/html/nsHTMLTableAccessible.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/html/nsHTMLTableAccessible.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -316,21 +316,20 @@ nsHTMLTableAccessible::GetColumnHeader(n
   nsCOMPtr<nsIDOMNode> sectionNode(do_QueryInterface(section));
   if (sectionNode) {
     rv = accService->GetCachedAccessible(sectionNode, mWeakShell,
                                          getter_AddRefs(accHead));
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   if (!accHead) {
-     accService->CreateHTMLTableHeadAccessible(section,
-                                               getter_AddRefs(accHead));
-                                                   
-    nsCOMPtr<nsPIAccessNode> accessNode(do_QueryInterface(accHead));
-    NS_ENSURE_TRUE(accHead, NS_ERROR_FAILURE);
+    accService->CreateHTMLTableHeadAccessible(section, getter_AddRefs(accHead));
+    NS_ENSURE_STATE(accHead);
+
+    nsRefPtr<nsAccessNode> accessNode = nsAccUtils::QueryAccessNode(accHead);
     rv = accessNode->Init();
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   nsCOMPtr<nsIAccessibleTable> accTableHead(do_QueryInterface(accHead));
   NS_ENSURE_TRUE(accTableHead, NS_ERROR_FAILURE);
 
   *aColumnHeader = accTableHead;
@@ -1163,21 +1162,25 @@ NS_IMETHODIMP nsHTMLTableAccessible::IsP
   GetComputedStyleValue(EmptyString(), NS_LITERAL_STRING("width"), styledWidth);
   if (styledWidth.EqualsLiteral("100%")) {
     RETURN_LAYOUT_ANSWER(PR_TRUE, "<=4 columns and 100% width");
   }
   if (styledWidth.Find(NS_LITERAL_STRING("px"))) { // Hardcoded in pixels
     nsIFrame *tableFrame = GetFrame();
     NS_ENSURE_TRUE(tableFrame , NS_ERROR_FAILURE);
     nsSize tableSize  = tableFrame->GetSize();
+
     nsCOMPtr<nsIAccessibleDocument> docAccessible = GetDocAccessible();
-    nsCOMPtr<nsPIAccessNode> docAccessNode(do_QueryInterface(docAccessible));
-    NS_ENSURE_TRUE(docAccessNode, NS_ERROR_FAILURE);
+    NS_ENSURE_TRUE(docAccessible, NS_ERROR_FAILURE);
+
+    nsRefPtr<nsAccessNode> docAccessNode = nsAccUtils::QueryAccessNode(docAccessible);
+
     nsIFrame *docFrame = docAccessNode->GetFrame();
     NS_ENSURE_TRUE(docFrame , NS_ERROR_FAILURE);
+
     nsSize docSize = docFrame->GetSize();
     if (docSize.width > 0) {
       PRInt32 percentageOfDocWidth = (100 * tableSize.width) / docSize.width;
       if (percentageOfDocWidth > 95) {
         // 3-4 columns, no borders, not a lot of rows, and 95% of the doc's width
         // Probably for layout
         RETURN_LAYOUT_ANSWER(PR_TRUE, "<=4 columns, width hardcoded in pixels and 95% of document width");
       }
diff -r a131999fa900 accessible/src/html/nsHTMLTextAccessible.cpp
--- a/accessible/src/html/nsHTMLTextAccessible.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/html/nsHTMLTextAccessible.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -220,24 +220,23 @@ NS_IMETHODIMP nsHTMLLabelAccessible::Get
 
 nsHTMLLIAccessible::nsHTMLLIAccessible(nsIDOMNode *aDOMNode, nsIWeakReference* aShell, 
                                        const nsAString& aBulletText):
   nsLinkableAccessible(aDOMNode, aShell)
 {
   if (!aBulletText.IsEmpty()) {
     mBulletAccessible = new nsHTMLListBulletAccessible(mDOMNode, mWeakShell, 
                                                        aBulletText);
-    nsCOMPtr<nsPIAccessNode> bulletANode(mBulletAccessible);
-    if (bulletANode) {
-      bulletANode->Init();
-    }
+    if (mBulletAccessible)
+      mBulletAccessible->Init();
   }
 }
 
-NS_IMETHODIMP nsHTMLLIAccessible::Shutdown()
+nsresult
+nsHTMLLIAccessible::Shutdown()
 {
   if (mBulletAccessible) {
     // Ensure that weak pointer to this is nulled out
     mBulletAccessible->Shutdown();
   }
   nsresult rv = nsLinkableAccessible::Shutdown();
   mBulletAccessible = nsnull;
   return rv;
@@ -299,17 +298,17 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsHTMLListBulletAccessible::GetUniqueID(void **aUniqueID)
 {
   // Since mDOMNode is same as for list item, use |this| pointer as the unique Id
   *aUniqueID = static_cast<void*>(this);
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 nsHTMLListBulletAccessible::Shutdown()
 {
   mBulletText.Truncate();
   mWeakParent = nsnull;
 
   return nsLeafAccessible::Shutdown();
 }
 
diff -r a131999fa900 accessible/src/html/nsHTMLTextAccessible.h
--- a/accessible/src/html/nsHTMLTextAccessible.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/html/nsHTMLTextAccessible.h	Sat Nov 01 13:47:50 2008 +0200
@@ -102,29 +102,29 @@ class nsHTMLListBulletAccessible : publi
 {
 public:
   nsHTMLListBulletAccessible(nsIDOMNode *aDOMNode, nsIWeakReference* aShell,
                              const nsAString& aBulletText);
 
   // nsIAccessNode
   NS_IMETHOD GetUniqueID(void **aUniqueID);
 
-  // nsPIAccessNode
-  NS_IMETHOD Shutdown();
-
   // nsIAccessible
   NS_IMETHOD GetRole(PRUint32 *aRole);
   NS_IMETHOD GetName(nsAString& aName);
   NS_IMETHOD GetState(PRUint32 *aState, PRUint32 *aExtraState);
 
   // Don't cache via unique ID -- bullet accessible shares the same dom node as
   // this LI accessible. Also, don't cache via mParent/SetParent(), prevent
   // circular reference since li holds onto us.
   NS_IMETHOD SetParent(nsIAccessible *aParentAccessible);
   NS_IMETHOD GetParent(nsIAccessible **aParentAccessible);
+
+  // nsAccessNode
+  virtual nsresult Shutdown();
 
   // nsPIAccessible
   NS_IMETHOD AppendTextTo(nsAString& aText, PRUint32 aStartOffset, PRUint32 aLength);
 
 protected:
   // XXX: Ideally we'd get the bullet text directly from the bullet frame via
   // nsBulletFrame::GetListItemText(), but we'd need an interface for getting
   // text from contentless anonymous frames. Perhaps something like
@@ -150,18 +150,18 @@ public:
   nsHTMLLIAccessible(nsIDOMNode *aDOMNode, nsIWeakReference* aShell, 
                      const nsAString& aBulletText);
 
   // nsIAccessible
   NS_IMETHOD GetRole(PRUint32 *aRole) { *aRole = nsIAccessibleRole::ROLE_LISTITEM; return NS_OK; }
   NS_IMETHOD GetState(PRUint32 *aState, PRUint32 *aExtraState);
   NS_IMETHOD GetBounds(PRInt32 *x, PRInt32 *y, PRInt32 *width, PRInt32 *height);
 
-  // nsPIAccessNode
-  NS_IMETHOD Shutdown();
+  // nsAccessNode
+  virtual nsresult Shutdown();
 
 protected:
   void CacheChildren();  // Include bullet accessible
 
   nsRefPtr<nsHTMLListBulletAccessible> mBulletAccessible;
 };
 
 #endif  
diff -r a131999fa900 accessible/src/html/nsHyperTextAccessible.cpp
--- a/accessible/src/html/nsHyperTextAccessible.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/html/nsHyperTextAccessible.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -38,17 +38,16 @@
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsHyperTextAccessible.h"
 #include "nsAccessibilityAtoms.h"
 #include "nsAccessibilityService.h"
 #include "nsAccessibleTreeWalker.h"
 #include "nsTextUtils.h"
 
-#include "nsPIAccessNode.h"
 #include "nsIClipboard.h"
 #include "nsContentCID.h"
 #include "nsIDOMAbstractView.h"
 #include "nsIDOMCharacterData.h"
 #include "nsIDOMDocument.h"
 #include "nsPIDOMWindow.h"        
 #include "nsIDOMDocumentView.h"
 #include "nsIDOMRange.h"
@@ -379,17 +378,18 @@ nsHyperTextAccessible::GetPosAndText(PRI
 
   gfxSkipChars skipChars;
   gfxSkipCharsIterator iter;
 
   // Loop through children and collect valid offsets, text and bounds
   // depending on what we need for out parameters
   while (NextChild(accessible)) {
     lastAccessible = accessible;
-    nsCOMPtr<nsPIAccessNode> accessNode(do_QueryInterface(accessible));
+    nsRefPtr<nsAccessNode> accessNode = nsAccUtils::QueryAccessNode(accessible);
+
     nsIFrame *frame = accessNode->GetFrame();
     if (!frame) {
       continue;
     }
     nsIFrame *primaryFrame = frame;
     if (nsAccUtils::IsText(accessible)) {
       // We only need info up to rendered offset -- that is what we're
       // converting to content offset
@@ -816,21 +816,22 @@ nsHyperTextAccessible::GetRelativeOffset
   }
 
   // Ask layout for the new node and offset, after moving the appropriate amount
   nsPeekOffsetStruct pos;
 
   nsresult rv;
   PRInt32 contentOffset = aFromOffset;
   if (nsAccUtils::IsText(aFromAccessible)) {
-    nsCOMPtr<nsPIAccessNode> accessNode(do_QueryInterface(aFromAccessible));
-    NS_ASSERTION(accessNode, "nsIAccessible doesn't support nsPIAccessNode");
+    nsRefPtr<nsAccessNode> accessNode =
+      nsAccUtils::QueryAccessNode(aFromAccessible);
 
     nsIFrame *frame = accessNode->GetFrame();
     NS_ENSURE_TRUE(frame, -1);
+
     if (frame->GetType() == nsAccessibilityAtoms::textFrame) {
       rv = RenderedToContentOffset(frame, aFromOffset, &contentOffset);
       NS_ENSURE_SUCCESS(rv, -1);
     }
   }
 
   pos.SetData(aAmount, aDirection, contentOffset,
               0, kIsJumpLinesOk, kIsScrollViewAStop, kIsKeyboardSelect, kIsVisualBidi,
@@ -1008,18 +1009,19 @@ nsresult nsHyperTextAccessible::GetTextH
   nsIFrame *startFrame = GetPosAndText(startOffset, endOffset, nsnull, nsnull,
                                        nsnull, getter_AddRefs(startAcc));
 
   if (!startFrame) {
     PRInt32 textLength;
     GetCharacterCount(&textLength);
     if (aBoundaryType == BOUNDARY_LINE_START && aOffset > 0 && aOffset == textLength) {
       // Asking for start of line, while on last character
-      nsCOMPtr<nsPIAccessNode> startAccessNode = do_QueryInterface(startAcc);
-      if (startAccessNode) {
+      if (startAcc) {
+        nsRefPtr<nsAccessNode> startAccessNode =
+          nsAccUtils::QueryAccessNode(startAcc);
         startFrame = startAccessNode->GetFrame();
       }
     }
     if (!startFrame) {
       return aOffset > textLength ? NS_ERROR_FAILURE : NS_OK;
     }
     else {
       // We're on the last continuation since we're on the last character
@@ -1364,17 +1366,18 @@ nsHyperTextAccessible::GetOffsetAtPoint(
   // When one does, add up the character offsets until we have a match
 
   // We have an point in an accessible child of this, now we need to add up the
   // offsets before it to what we already have
   nsCOMPtr<nsIAccessible> accessible;
   PRInt32 offset = 0;
 
   while (NextChild(accessible)) {
-    nsCOMPtr<nsPIAccessNode> accessNode(do_QueryInterface(accessible));
+    nsRefPtr<nsAccessNode> accessNode = nsAccUtils::QueryAccessNode(accessible);
+
     nsIFrame *primaryFrame = accessNode->GetFrame();
     NS_ENSURE_TRUE(primaryFrame, NS_ERROR_FAILURE);
 
     nsIFrame *frame = primaryFrame;
     while (frame) {
       nsIContent *content = frame->GetContent();
       NS_ENSURE_TRUE(content, NS_ERROR_FAILURE);
       nsPoint pointInFrame = pointInHyperText - frame->GetOffsetToExternal(hyperFrame);
diff -r a131999fa900 accessible/src/mac/nsAccessibleWrap.mm
--- a/accessible/src/mac/nsAccessibleWrap.mm	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/mac/nsAccessibleWrap.mm	Sat Nov 01 13:47:50 2008 +0200
@@ -57,17 +57,17 @@ nsAccessibleWrap::~nsAccessibleWrap()
 nsAccessibleWrap::~nsAccessibleWrap()
 {
   if (mNativeWrapper) {
     delete mNativeWrapper;
     mNativeWrapper = nsnull;
   }
 }
 
-NS_IMETHODIMP
+nsresult
 nsAccessibleWrap::Init () 
 {
   // need to pass the call up, so we're cached (which nsAccessNode::Init() takes care of).
   nsresult rv = nsAccessible::Init();
   NS_ENSURE_SUCCESS(rv, rv);
   
   if (!mNativeWrapper && !AncestorIsFlat()) {
     // Create our native object using the class type specified in GetNativeType().
diff -r a131999fa900 accessible/src/msaa/nsAccessibleWrap.cpp
--- a/accessible/src/msaa/nsAccessibleWrap.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/msaa/nsAccessibleWrap.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -1723,24 +1723,22 @@ PRInt32 nsAccessibleWrap::GetChildIDFor(
   // Yes, this means we're only compatibible with 32 bit
   // MSAA is only available for 32 bit windows, so it's okay
   return - NS_PTR_TO_INT32(uniqueID);
 }
 
 HWND
 nsAccessibleWrap::GetHWNDFor(nsIAccessible *aAccessible)
 {
-  nsCOMPtr<nsIAccessNode> accessNode(do_QueryInterface(aAccessible));
-  nsCOMPtr<nsPIAccessNode> privateAccessNode(do_QueryInterface(accessNode));
-  if (!privateAccessNode)
+  nsRefPtr<nsAccessNode> accessNode = nsAccUtils::QueryAccessNode(aAccessible);
+  if (!accessNode)
     return 0;
 
   HWND hWnd = 0;
-
-  nsIFrame *frame = privateAccessNode->GetFrame();
+  nsIFrame *frame = accessNode->GetFrame();
   if (frame) {
     nsIWidget *window = frame->GetWindow();
     PRBool isVisible;
     window->IsVisible(isVisible);
     if (isVisible) {
       // Short explanation:
       // If HWND for frame is inside a hidden window, fire the event on the
       // containing document's visible window.
diff -r a131999fa900 accessible/src/msaa/nsHTMLWin32ObjectAccessible.cpp
--- a/accessible/src/msaa/nsHTMLWin32ObjectAccessible.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/msaa/nsHTMLWin32ObjectAccessible.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -41,17 +41,18 @@
 
 
 nsHTMLWin32ObjectOwnerAccessible::nsHTMLWin32ObjectOwnerAccessible(nsIDOMNode* aNode, nsIWeakReference* aShell, void* aHwnd):
 nsAccessibleWrap(aNode, aShell)
 {
   mHwnd = aHwnd;
 }
 
-NS_IMETHODIMP nsHTMLWin32ObjectOwnerAccessible::Shutdown()
+nsresult
+nsHTMLWin32ObjectOwnerAccessible::Shutdown()
 {
   nsAccessibleWrap::Shutdown();
   mNativeAccessible = nsnull;
   return NS_OK;
 }
 
 /** 
   * Our only child is a nsHTMLWin32ObjectAccessible 
diff -r a131999fa900 accessible/src/msaa/nsHTMLWin32ObjectAccessible.h
--- a/accessible/src/msaa/nsHTMLWin32ObjectAccessible.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/msaa/nsHTMLWin32ObjectAccessible.h	Sat Nov 01 13:47:50 2008 +0200
@@ -50,20 +50,24 @@ public:
   // This will own the nsHTMLWin32ObjectAccessible. We create this where the
   // <object> or <embed> exists in the tree, so that get_accNextSibling() etc.
   // will still point to Gecko accessible sibling content. This is necessary
   // because the native plugin accessible doesn't know where it exists in the
   // Mozilla tree, and returns null for previous and next sibling. This would
   // have the effect of cutting off all content after the plugin.
   nsHTMLWin32ObjectOwnerAccessible(nsIDOMNode* aNode, nsIWeakReference* aShell, void* aHwnd);
   virtual ~nsHTMLWin32ObjectOwnerAccessible() {}
-  NS_IMETHOD Shutdown();
+
+  // nsIAccessible
   NS_IMETHOD GetFirstChild(nsIAccessible **aFirstChild);
   NS_IMETHOD GetLastChild(nsIAccessible **aLastChild);
   NS_IMETHOD GetChildCount(PRInt32 *aChildCount);  // Zero or one child
+
+  // nsAccessNode
+  virtual nsresult Shutdown();
 
 protected:
   void* mHwnd;
   nsCOMPtr<nsIAccessible> mNativeAccessible;
 };
 
 /**
   * This class is used only internally, we never! send out an IAccessible linked
diff -r a131999fa900 accessible/src/xul/nsXULMenuAccessible.cpp
--- a/accessible/src/xul/nsXULMenuAccessible.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/xul/nsXULMenuAccessible.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -66,17 +66,18 @@ nsXULSelectableAccessible::nsXULSelectab
                                                      nsIWeakReference* aShell):
 nsAccessibleWrap(aDOMNode, aShell)
 {
   mSelectControl = do_QueryInterface(aDOMNode);
 }
 
 NS_IMPL_ISUPPORTS_INHERITED1(nsXULSelectableAccessible, nsAccessible, nsIAccessibleSelectable)
 
-NS_IMETHODIMP nsXULSelectableAccessible::Shutdown()
+nsresult
+nsXULSelectableAccessible::Shutdown()
 {
   mSelectControl = nsnull;
   return nsAccessibleWrap::Shutdown();
 }
 
 nsresult nsXULSelectableAccessible::ChangeSelection(PRInt32 aIndex, PRUint8 aMethod, PRBool *aSelState)
 {
   *aSelState = PR_FALSE;
@@ -263,17 +264,18 @@ NS_IMETHODIMP nsXULSelectableAccessible:
 
 // ------------------------ Menu Item -----------------------------
 
 nsXULMenuitemAccessible::nsXULMenuitemAccessible(nsIDOMNode* aDOMNode, nsIWeakReference* aShell): 
 nsAccessibleWrap(aDOMNode, aShell)
 { 
 }
 
-NS_IMETHODIMP nsXULMenuitemAccessible::Init()
+nsresult
+nsXULMenuitemAccessible::Init()
 {
   nsresult rv = nsAccessibleWrap::Init();
   nsXULMenupopupAccessible::GenerateMenu(mDOMNode);
   return rv;
 }
 
 NS_IMETHODIMP
 nsXULMenuitemAccessible::GetState(PRUint32 *aState, PRUint32 *aExtraState)
diff -r a131999fa900 accessible/src/xul/nsXULMenuAccessible.h
--- a/accessible/src/xul/nsXULMenuAccessible.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/xul/nsXULMenuAccessible.h	Sat Nov 01 13:47:50 2008 +0200
@@ -50,17 +50,19 @@ class nsXULSelectableAccessible : public
 class nsXULSelectableAccessible : public nsAccessibleWrap
 {
 public:
   NS_DECL_ISUPPORTS_INHERITED
   NS_DECL_NSIACCESSIBLESELECTABLE
 
   nsXULSelectableAccessible(nsIDOMNode* aDOMNode, nsIWeakReference* aShell);
   virtual ~nsXULSelectableAccessible() {}
-  NS_IMETHOD Shutdown();
+
+  // nsAccessNode
+  virtual nsresult Shutdown();
 
 protected:
   nsresult ChangeSelection(PRInt32 aIndex, PRUint8 aMethod, PRBool *aSelState);
   nsresult AppendFlatStringFromSubtree(nsIContent *aContent, nsAString *aFlatString)
     { return NS_OK; }  // Overrides base impl in nsAccessible
 
   // nsIDOMXULMultiSelectControlElement inherits from this, so we'll always have
   // one of these if the widget is valid and not defunct
@@ -82,18 +84,18 @@ public:
   NS_IMETHOD GetKeyboardShortcut(nsAString& _retval);
   NS_IMETHOD GetDefaultKeyBinding(nsAString& aKeyBinding);
   NS_IMETHOD GetState(PRUint32 *aState, PRUint32 *aExtraState);
   NS_IMETHOD GetRole(PRUint32 *_retval); 
   NS_IMETHOD DoAction(PRUint8 index);
   NS_IMETHOD GetActionName(PRUint8 aIndex, nsAString& aName);
   NS_IMETHOD GetNumActions(PRUint8 *_retval);
 
-  // nsPIAccessNode
-  NS_IMETHOD Init();
+  // nsAccessNode
+  virtual nsresult Init();
 
   // nsAccessible
   virtual nsresult GetNameInternal(nsAString& aName); 
   virtual nsresult GetAttributesInternal(nsIPersistentProperties *aAttributes);
 
   NS_IMETHOD GetAllowsAnonChildAccessibles(PRBool *aAllowsAnonChildren);
 };
 
diff -r a131999fa900 accessible/src/xul/nsXULSelectAccessible.cpp
--- a/accessible/src/xul/nsXULSelectAccessible.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/xul/nsXULSelectAccessible.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -1000,17 +1000,18 @@ nsXULListCellAccessible::GetRole(PRUint3
 /** ----- nsXULComboboxAccessible ----- */
 
 /** Constructor */
 nsXULComboboxAccessible::nsXULComboboxAccessible(nsIDOMNode* aDOMNode, nsIWeakReference* aShell):
 nsAccessibleWrap(aDOMNode, aShell)
 {
 }
 
-NS_IMETHODIMP nsXULComboboxAccessible::Init()
+nsresult
+nsXULComboboxAccessible::Init()
 {
   nsresult rv = nsAccessibleWrap::Init();
   nsXULMenupopupAccessible::GenerateMenu(mDOMNode);
   return rv;
 }
 
 /** We are a combobox */
 NS_IMETHODIMP nsXULComboboxAccessible::GetRole(PRUint32 *aRole)
diff -r a131999fa900 accessible/src/xul/nsXULSelectAccessible.h
--- a/accessible/src/xul/nsXULSelectAccessible.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/xul/nsXULSelectAccessible.h	Sat Nov 01 13:47:50 2008 +0200
@@ -178,23 +178,23 @@ class nsXULComboboxAccessible : public n
 class nsXULComboboxAccessible : public nsAccessibleWrap
 {
 public:
   enum { eAction_Click = 0 };
 
   nsXULComboboxAccessible(nsIDOMNode* aDOMNode, nsIWeakReference* aShell);
   virtual ~nsXULComboboxAccessible() {}
 
-  /* ----- nsPIAccessible ---- */
-  NS_IMETHOD Init();
-
   /* ----- nsIAccessible ----- */
   NS_IMETHOD GetRole(PRUint32 *_retval);
   NS_IMETHOD GetState(PRUint32 *aState, PRUint32 *aExtraState);
   NS_IMETHOD GetValue(nsAString& _retval);
   NS_IMETHOD GetDescription(nsAString& aDescription);
   NS_IMETHOD GetAllowsAnonChildAccessibles(PRBool *aAllowsAnonChildren);
   NS_IMETHOD DoAction(PRUint8 index);
   NS_IMETHOD GetNumActions(PRUint8 *aNumActions);
   NS_IMETHOD GetActionName(PRUint8 index, nsAString& aName);
+
+  // nsAccessNode
+  virtual nsresult Init();
 };
 
 #endif
diff -r a131999fa900 accessible/src/xul/nsXULTreeAccessible.cpp
--- a/accessible/src/xul/nsXULTreeAccessible.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/xul/nsXULTreeAccessible.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -218,17 +218,18 @@ NS_IMETHODIMP nsXULTreeAccessible::GetVa
       cols->GetKeyColumn(getter_AddRefs(keyCol));
 
     return mTreeView->GetCellText(currentIndex, keyCol, _retval);
   }
 
   return NS_OK;
 }
 
-NS_IMETHODIMP nsXULTreeAccessible::Shutdown()
+nsresult
+nsXULTreeAccessible::Shutdown()
 {
   mTree = nsnull;
   mTreeView = nsnull;
 
   nsXULSelectableAccessible::Shutdown();
 
   if (mAccessNodeCache) {
     ClearCache(*mAccessNodeCache);
@@ -545,22 +546,24 @@ nsXULTreeAccessible::GetCachedTreeitemAc
     return NS_OK;
 
   col->GetIndex(&columnIndex);
 
   nsCOMPtr<nsIAccessNode> accessNode;
   GetCacheEntry(*mAccessNodeCache, (void*)(aRow * kMaxTreeColumns + columnIndex), getter_AddRefs(accessNode));
   if (!accessNode)
   {
-    accessNode = new nsXULTreeitemAccessibleWrap(this, mDOMNode, mWeakShell, aRow, col);
-    nsCOMPtr<nsPIAccessNode> privateAccessNode(do_QueryInterface(accessNode));
-    if (!privateAccessNode)
-      return NS_ERROR_OUT_OF_MEMORY;
-    nsresult rv = privateAccessNode->Init();
+    nsXULTreeitemAccessibleWrap* treeItemAcc =
+      new nsXULTreeitemAccessibleWrap(this, mDOMNode, mWeakShell, aRow, col);
+    NS_ENSURE_TRUE(treeItemAcc, NS_ERROR_OUT_OF_MEMORY);
+
+    nsresult rv = treeItemAcc->Init();
     NS_ENSURE_SUCCESS(rv, rv);
+
+    accessNode = treeItemAcc;
     PutCacheEntry(*mAccessNodeCache, (void*)(aRow * kMaxTreeColumns + columnIndex), accessNode);
   }
   nsCOMPtr<nsIAccessible> accessible(do_QueryInterface(accessNode));
   NS_IF_ADDREF(*aAccessible = accessible);
   return NS_OK;
 }
 
 // void nsIAccessibleTreeCache::
@@ -779,17 +782,18 @@ nsXULTreeitemAccessible::nsXULTreeitemAc
     if (cols)
       cols->GetKeyColumn(getter_AddRefs(mColumn));
   }
 }
 
 NS_IMPL_ISUPPORTS_INHERITED1(nsXULTreeitemAccessible, nsLeafAccessible,
                              nsPIAccessibleTreeItem)
 
-NS_IMETHODIMP nsXULTreeitemAccessible::Shutdown()
+nsresult
+nsXULTreeitemAccessible::Shutdown()
 {
   mTree = nsnull;
   mTreeView = nsnull;
   mColumn = nsnull;
   return nsLeafAccessible::Shutdown();
 }
 
 NS_IMETHODIMP
@@ -817,18 +821,18 @@ nsXULTreeitemAccessible::GetName(nsAStri
 
 NS_IMETHODIMP nsXULTreeitemAccessible::GetUniqueID(void **aUniqueID)
 {
   // Since mDOMNode is same for all tree item, use |this| pointer as the unique Id
   *aUniqueID = static_cast<void*>(this);
   return NS_OK;
 }
 
-// nsPIAccessNode::init()
-NS_IMETHODIMP
+// nsAccessNode::Init()
+nsresult
 nsXULTreeitemAccessible::Init()
 {
   nsresult rv = nsLeafAccessible::Init();
   NS_ENSURE_SUCCESS(rv, rv);
 
   return GetName(mCachedName);
 }
 
diff -r a131999fa900 accessible/src/xul/nsXULTreeAccessible.h
--- a/accessible/src/xul/nsXULTreeAccessible.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/src/xul/nsXULTreeAccessible.h	Sat Nov 01 13:47:50 2008 +0200
@@ -57,30 +57,32 @@ public:
   NS_DECL_ISUPPORTS_INHERITED
   NS_DECL_NSIACCESSIBLESELECTABLE
   NS_DECL_NSIACCESSIBLETREECACHE
 
   nsXULTreeAccessible(nsIDOMNode* aDOMNode, nsIWeakReference* aShell);
   virtual ~nsXULTreeAccessible() {}
 
   /* ----- nsIAccessible ----- */
-  NS_IMETHOD Shutdown();
   NS_IMETHOD GetRole(PRUint32 *_retval);
   NS_IMETHOD GetState(PRUint32 *aState, PRUint32 *aExtraState);
   NS_IMETHOD GetValue(nsAString& _retval);
 
   NS_IMETHOD GetFirstChild(nsIAccessible **_retval);
   NS_IMETHOD GetLastChild(nsIAccessible **_retval);
   NS_IMETHOD GetChildCount(PRInt32 *_retval);
   NS_IMETHOD GetFocusedChild(nsIAccessible **aFocusedChild);
 
   NS_IMETHOD GetChildAtPoint(PRInt32 aX, PRInt32 aY,
                              nsIAccessible **aAccessible);
   NS_IMETHOD GetDeepestChildAtPoint(PRInt32 aX, PRInt32 aY,
                                     nsIAccessible **aAccessible);
+
+  // nsAccessNode
+  virtual nsresult Shutdown();
 
   static void GetTreeBoxObject(nsIDOMNode* aDOMNode, nsITreeBoxObject** aBoxObject);
   static nsresult GetColumnCount(nsITreeBoxObject* aBoxObject, PRInt32 *aCount);
 
   static PRBool IsColumnHidden(nsITreeColumn *aColumn);
   static already_AddRefed<nsITreeColumn> GetNextVisibleColumn(nsITreeColumn *aColumn);
   static already_AddRefed<nsITreeColumn> GetFirstVisibleColumn(nsITreeBoxObject *aTree);
   static already_AddRefed<nsITreeColumn> GetLastVisibleColumn(nsITreeBoxObject *aTree);
@@ -103,18 +105,16 @@ public:
   enum { eAction_Click = 0, eAction_Expand = 1 };
 
   NS_DECL_ISUPPORTS_INHERITED
   NS_DECL_NSPIACCESSIBLETREEITEM
 
   nsXULTreeitemAccessible(nsIAccessible *aParent, nsIDOMNode *aDOMNode, nsIWeakReference *aShell, PRInt32 aRow, nsITreeColumn* aColumn = nsnull);
   virtual ~nsXULTreeitemAccessible() {}
 
-  NS_IMETHOD Shutdown();
-
   // nsIAccessible
   NS_IMETHOD GetName(nsAString& aName);
   NS_IMETHOD GetRole(PRUint32 *_retval);
   NS_IMETHOD GetState(PRUint32 *aState, PRUint32 *aExtraState);
   NS_IMETHOD GetNumActions(PRUint8 *_retval);
   NS_IMETHOD GetActionName(PRUint8 aIndex, nsAString& aName);
   virtual nsresult GetAttributesInternal(nsIPersistentProperties *aAttributes);
 
@@ -127,21 +127,20 @@ public:
   NS_IMETHOD SetSelected(PRBool aSelect); 
   NS_IMETHOD TakeFocus(void); 
 
   NS_IMETHOD GetAccessibleRelated(PRUint32 aRelationType, nsIAccessible **aRelated);
 
   // nsIAccessNode
   NS_IMETHOD GetUniqueID(void **aUniqueID);
 
-  // nsPIAccessNode
-  NS_IMETHOD Init();
-
   // nsAccessNode
   virtual PRBool IsDefunct();
+  virtual nsresult Init();
+  virtual nsresult Shutdown();
 
 protected:
   PRBool IsExpandable();
   nsCOMPtr<nsITreeBoxObject> mTree;
   nsCOMPtr<nsITreeView> mTreeView;
   PRInt32 mRow;
   nsCOMPtr<nsITreeColumn> mColumn;
   nsString mCachedName;
diff -r a131999fa900 accessible/tests/mochitest/Makefile.in
--- a/accessible/tests/mochitest/Makefile.in	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/tests/mochitest/Makefile.in	Sat Nov 01 13:47:50 2008 +0200
@@ -54,16 +54,17 @@ _TEST_FILES =\
 		nsIAccessible_name.css \
 		nsIAccessible_name.js \
 		nsIAccessible_name.xbl \
  		nsIAccessible_selects.js \
 		nsIAccessible_states.js \
 		nsIAccessibleEditableText.js \
 		test_aria_activedescendant.html \
 		test_aria_role_article.html \
+		test_aria_role_equation.html \
 		test_bug368835.xul \
 		test_bug420863.html \
 		test_cssattrs.html \
 		test_events_caretmove.html \
 		test_groupattrs.xul \
 	$(warning test_table_indexes.html temporarily disabled) \
 		test_nsIAccessible_actions.html \
 		test_nsIAccessible_actions.xul \
@@ -88,15 +89,14 @@ _TEST_FILES =\
 		test_nsIAccessibleTable_4.html \
 		test_nsIAccessibleTable_listboxes.xul \
 		test_nsIAccessNode_utils.html \
 		test_nsOuterDocAccessible.html \
 		test_textattrs.html \
 		test_textboxes.html \
 		test_textboxes.xul \
 		testTextboxes.js \
-		test_bug428479.html \
 		test_bug429285.html \
 		test_bug434464.html \
 		$(NULL)
 
 libs:: $(_TEST_FILES)
 	$(INSTALL) $(foreach f,$^,"$f") $(DEPTH)/_tests/testing/mochitest/a11y/$(relativesrcdir)
diff -r a131999fa900 accessible/tests/mochitest/common.js
--- a/accessible/tests/mochitest/common.js	Thu Oct 30 23:42:02 2008 -0700
+++ b/accessible/tests/mochitest/common.js	Sat Nov 01 13:47:50 2008 +0200
@@ -33,16 +33,17 @@ const nsIPropertyElement = Components.in
 
 ////////////////////////////////////////////////////////////////////////////////
 // Roles
 
 const ROLE_COMBOBOX = nsIAccessibleRole.ROLE_COMBOBOX;
 const ROLE_COMBOBOX_LIST = nsIAccessibleRole.ROLE_COMBOBOX_LIST;
 const ROLE_COMBOBOX_OPTION = nsIAccessibleRole.ROLE_COMBOBOX_OPTION;
 const ROLE_DOCUMENT = nsIAccessibleRole.ROLE_DOCUMENT;
+const ROLE_FLAT_EQUATION = nsIAccessibleRole.ROLE_FLAT_EQUATION;
 const ROLE_LABEL = nsIAccessibleRole.ROLE_LABEL;
 const ROLE_LIST = nsIAccessibleRole.ROLE_LIST;
 const ROLE_OPTION = nsIAccessibleRole.ROLE_OPTION;
 const ROLE_TEXT_LEAF = nsIAccessibleRole.ROLE_TEXT_LEAF;
 
 ////////////////////////////////////////////////////////////////////////////////
 // States
 
diff -r a131999fa900 accessible/tests/mochitest/test_aria_role_equation.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/accessible/tests/mochitest/test_aria_role_equation.html	Sat Nov 01 13:47:50 2008 +0200
@@ -0,0 +1,59 @@
+<!DOCTYPE html>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=428479
+-->
+<head>
+  <title>ARIA role math chrome tests</title>
+  <link rel="stylesheet" type="text/css" href="chrome://mochikit/content/tests/SimpleTest/test.css" />
+
+  <script type="application/javascript"
+          src="chrome://mochikit/content/MochiKit/packed.js"></script>
+  <script type="application/javascript"
+          src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>
+
+  <script type="application/javascript"
+          src="chrome://mochikit/content/a11y/accessible/common.js"></script>
+
+  <script type="application/javascript">
+    function testThis(aID)
+    {
+      var eqAcc = getAccessible(aID);
+      if (eqAcc) {
+        is(eqAcc.finalRole, ROLE_FLAT_EQUATION,
+           "Wrong role for " + aID +"!");
+        is(eqAcc.name, "x^2 + y^2 + z^2", "Wrong name for " + aID + "!");
+      }
+    }
+
+    function doTest()
+    {
+      // Test equation image
+      testThis("img_eq");
+
+      // Test textual equation
+      testThis("txt_eq");
+
+      SimpleTest.finish();
+    }
+
+    SimpleTest.waitForExplicitFinish();
+    addLoadEvent(doTest);
+  </script>
+</head>
+<body>
+
+  <a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=428479">Mozilla Bug 428479</a>
+  <p id="display"></p>
+  <div id="content" style="display: none"></div>
+  <pre id="test">
+  </pre>
+  <p>Image: 
+    <img id="img_eq" role="math" src="foo" alt="x^2 + y^2 + z^2">
+  </p>
+  <p>Text: 
+    <span id="txt_eq" role="math" title="x^2 + y^2 + z^2">x<sup>2</sup> + 
+      y<sup>2</sup> + z<sup>2</sup></span>
+  </p>
+</body>
+</html>
diff -r a131999fa900 accessible/tests/mochitest/test_bug428479.html
--- a/accessible/tests/mochitest/test_bug428479.html	Thu Oct 30 23:42:02 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,71 +0,0 @@
-<!DOCTYPE html>
-<html>
-<!--
-https://bugzilla.mozilla.org/show_bug.cgi?id=428479
--->
-<head>
-  <title>ARIA role math chrome tests</title>
-  <link rel="stylesheet" type="text/css" href="chrome://mochikit/content/tests/SimpleTest/test.css" />
-
-  <script type="application/javascript" src="chrome://mochikit/content/MochiKit/packed.js"></script>
-  <script type="application/javascript" src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>
-
-  <script type="application/javascript">
-    function testThis(aID, aAcc)
-    {
-      is(aAcc.finalRole,
-         Components.interfaces.nsIAccessibleRole.ROLE_FLAT_EQUATION,
-         "Wrong role for " + aID +"!");
-      is(aAcc.name, "x^2 + y^2 + z^2", "Wrong name for " + aID + "!");
-    }
-
-    function doTest()
-    {
-      var accRetrieval = Components.classes["@mozilla.org/accessibleRetrieval;1"].
-                       getService(Components.interfaces.nsIAccessibleRetrieval);
-
-      // Test equation image
-      var imgEqElement = document.getElementById("img_eq");
-      var imgEqAcc;
-      try {
-        imgEqAcc = accRetrieval.getAccessibleFor(imgEqElement);
-      } catch(e) {
-      }
-      ok(imgEqAcc, "no accessible for image equation!");
-      if (imgEqAcc)
-        testThis("img_eq", imgEqAcc);
-
-      // Test textual equation
-      var txtEqElement = document.getElementById("txt_eq");
-      var txtEqAcc;
-      try {
-        txtEqAcc = accRetrieval.getAccessibleFor(txtEqElement);
-      } catch(e) {
-      }
-      ok(txtEqAcc, "no accessible for textual equation!");
-      if (txtEqAcc)
-        testThis("txt_eq", txtEqAcc);
-
-      SimpleTest.finish();
-    }
-
-    SimpleTest.waitForExplicitFinish();
-    addLoadEvent(doTest);
-  </script>
-</head>
-<body>
-
-  <a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=428479">Mozilla Bug 428479</a>
-  <p id="display"></p>
-  <div id="content" style="display: none"></div>
-  <pre id="test">
-  </pre>
-  <p>Image: 
-    <img id="img_eq" role="math" src="foo" alt="x^2 + y^2 + z^2">
-  </p>
-  <p>Text: 
-    <span id="txt_eq" role="math" title="x^2 + y^2 + z^2">x<sup>2</sup> + 
-      y<sup>2</sup> + z<sup>2</sup></span>
-  </p>
-</body>
-</html>
diff -r a131999fa900 browser/base/content/browser-places.js
--- a/browser/base/content/browser-places.js	Thu Oct 30 23:42:02 2008 -0700
+++ b/browser/base/content/browser-places.js	Sat Nov 01 13:47:50 2008 +0200
@@ -118,17 +118,20 @@ var StarUI = {
             var elt = aEvent.target;
             if (elt.localName != "tree" ||
                 (elt.localName == "tree" && !elt.hasAttribute("editing")))
               this.cancelButtonOnCommand();
           }
         }
         else if (aEvent.keyCode == KeyEvent.DOM_VK_RETURN) {
           // hide the panel unless the folder tree is focused
-          if (aEvent.target.localName != "tree")
+          // or the tag autocomplete popup is open
+          if (aEvent.target.localName != "tree" &&
+              (aEvent.target.id != "editBMPanel_tagsField" ||
+               !aEvent.target.popupOpen))
             this.panel.hidePopup();
         }
         break;
     }
   },
 
   _overlayLoaded: false,
   _overlayLoading: false,
diff -r a131999fa900 browser/base/content/browser.js
--- a/browser/base/content/browser.js	Thu Oct 30 23:42:02 2008 -0700
+++ b/browser/base/content/browser.js	Sat Nov 01 13:47:50 2008 +0200
@@ -261,23 +261,18 @@ function SetClickAndHoldHandlers()
     forwardButton.setAttribute("type", "menu-button");
     forwardButton.appendChild(popup);    
     _addClickAndHoldListenersOnElement(forwardButton);
     unifiedButton._clickHandlersAttached = true;
   }
 }
 #endif
 
-function BookmarkThisTab()
-{
-  var tab = gBrowser.mContextTab;
-  if (tab.localName != "tab")
-    tab = gBrowser.mCurrentTab;
-
-  PlacesCommandHook.bookmarkPage(tab.linkedBrowser,
+function BookmarkThisTab() {
+  PlacesCommandHook.bookmarkPage(gBrowser.mContextTab.linkedBrowser,
                                  PlacesUtils.bookmarksMenuFolderId, true);
 }
 
 const gSessionHistoryObserver = {
   observe: function(subject, topic, data)
   {
     if (topic != "browser:purge-session-history")
       return;
@@ -1148,16 +1143,24 @@ function delayedStartup(isLoadingBlank, 
 
 #ifdef XP_MACOSX
   // Setup click-and-hold gestures access to the session history
   // menus if global click-and-hold isn't turned on
   if (!getBoolPref("ui.click_hold_context_menus", false))
     SetClickAndHoldHandlers();
 #endif
 
+  // Initialize the microsummary service by retrieving it, prompting its factory
+  // to create its singleton, whose constructor initializes the service.
+  try {
+    Cc["@mozilla.org/microsummary/service;1"].getService(Ci.nsIMicrosummaryService);
+  } catch (ex) {
+    Components.utils.reportError("Failed to init microsummary service:\n" + ex);
+  }
+
   // Initialize the full zoom setting.
   // We do this before the session restore service gets initialized so we can
   // apply full zoom settings to tabs restored by the session restore service.
   try {
     FullZoom.init();
   }
   catch(ex) {
     Components.utils.reportError("Failed to init content pref service:\n" + ex);
@@ -1203,32 +1206,21 @@ function delayedStartup(isLoadingBlank, 
   gBrowser.addEventListener("command", BrowserOnCommand, false);
 
   tabPreviews.init();
   if ((!gPrefService.prefHasUserValue("browser.ctrlTab.disallowForScreenReaders") ||
        !gPrefService.getBoolPref("browser.ctrlTab.disallowForScreenReaders")) &&
        gPrefService.getBoolPref("browser.ctrlTab.mostRecentlyUsed"))
     ctrlTab.init();
 
-  // Initialize the microsummary service by retrieving it, prompting its factory
-  // to create its singleton, whose constructor initializes the service.
-  // Started 4 seconds after delayedStartup (before the livemarks service below).
-  setTimeout(function() {
-    try {
-      Cc["@mozilla.org/microsummary/service;1"].getService(Ci.nsIMicrosummaryService);
-    } catch (ex) {
-      Components.utils.reportError("Failed to init microsummary service:\n" + ex);
-    }
-  }, 4000);
-
   // Delayed initialization of the livemarks update timer.
   // Livemark updates don't need to start until after bookmark UI 
   // such as the toolbar has initialized. Starting 5 seconds after
-  // delayedStartup in order to stagger this after the microsummary
-  // service (see above) and before the download manager starts (see below).
+  // delayedStartup in order to stagger this before the download
+  // manager starts (see below).
   setTimeout(function() PlacesUtils.livemarks.start(), 5000);
 
   // Initialize the download manager some time after the app starts so that
   // auto-resume downloads begin (such as after crashing or quitting with
   // active downloads) and speeds up the first-load of the download manager UI.
   // If the user manually opens the download manager before the timeout, the
   // downloads will start right away, and getting the service again won't hurt.
   setTimeout(function() {
diff -r a131999fa900 browser/base/content/browser.xul
--- a/browser/base/content/browser.xul	Thu Oct 30 23:42:02 2008 -0700
+++ b/browser/base/content/browser.xul	Sat Nov 01 13:47:50 2008 +0200
@@ -60,17 +60,16 @@
 # hiddenWindow.xul.
 #include browser-doctype.inc
 
 <window id="main-window"
         xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
         onload="BrowserStartup()" onunload="BrowserShutdown()" onclose="return WindowIsClosing();"
-        contenttitlesetting="true"
         title="&mainWindow.title;"
         titlemodifier="&mainWindow.title;"
         titlemenuseparator="&mainWindow.titlemodifiermenuseparator;"
         windowtype="navigator:browser"
         screenX="4" screenY="4"
         persist="screenX screenY width height sizemode"> 
 
 # All JS files which are not content (only) dependent that browser.xul
diff -r a131999fa900 browser/components/places/content/editBookmarkOverlay.xul
--- a/browser/components/places/content/editBookmarkOverlay.xul	Thu Oct 30 23:42:02 2008 -0700
+++ b/browser/components/places/content/editBookmarkOverlay.xul	Sat Nov 01 13:47:50 2008 +0200
@@ -172,16 +172,21 @@
         </row>
 
         <row align="center" id="editBMPanel_tagsRow">
           <label value="&editBookmarkOverlay.tags.label;"
                  accesskey="&editBookmarkOverlay.tags.accesskey;"
                  control="editBMPanel_tagsField"
                  observes="paneElementsBroadcaster"/>
           <textbox id="editBMPanel_tagsField"
+                   type="autocomplete"
+                   autocompletesearch="places-tag-autocomplete" 
+                   completedefaultindex="true"
+                   tabscrolling="true"
+                   showcommentcolumn="true"
                    onblur="gEditItemOverlay.onTagsFieldBlur();"
                    observes="paneElementsBroadcaster"
                    emptytext="&editBookmarkOverlay.tagsEmptyDesc.label;"/>
           <button id="editBMPanel_tagsSelectorExpander"
                   class="expander-down"
                   tooltiptext="&editBookmarkOverlay.tagsExpanderDown.tooltip;"
                   tooltiptextdown="&editBookmarkOverlay.tagsExpanderDown.tooltip;"
                   tooltiptextup="&editBookmarkOverlay.expanderUp.tooltip;"
diff -r a131999fa900 browser/components/sessionstore/test/browser/browser_339445.js
--- a/browser/components/sessionstore/test/browser/browser_339445.js	Thu Oct 30 23:42:02 2008 -0700
+++ b/browser/components/sessionstore/test/browser/browser_339445.js	Sat Nov 01 13:47:50 2008 +0200
@@ -35,17 +35,17 @@
  * ***** END LICENSE BLOCK ***** */
 
 function test() {
   /** Test for Bug 339445 **/
   
   waitForExplicitFinish();
   
   let testURL = "http://localhost:8888/browser/" +
-    "browser/components/sessionstore/test/browser/browser_339445_sample.html"
+    "browser/components/sessionstore/test/browser/browser_339445_sample.html";
   
   let tab = gBrowser.addTab(testURL);
   tab.linkedBrowser.addEventListener("load", function(aEvent) {
     let doc = tab.linkedBrowser.contentDocument;
     is(doc.getElementById("storageTestItem").textContent, "PENDING",
        "sessionStorage value has been set");
     
     let tab2 = gBrowser.duplicateTab(tab);
diff -r a131999fa900 browser/locales/en-US/chrome/browser/aboutRights.dtd
--- a/browser/locales/en-US/chrome/browser/aboutRights.dtd	Thu Oct 30 23:42:02 2008 -0700
+++ b/browser/locales/en-US/chrome/browser/aboutRights.dtd	Sat Nov 01 13:47:50 2008 +0200
@@ -1,17 +1,17 @@
 <!-- rights.locale-direction instead of the usual local.dir entity, so RTL can skip translating page. -->
 <!ENTITY rights.locale-direction "ltr">
 <!ENTITY rights.pagetitle       "about:rights">
 <!ENTITY rights.intro-header    "About Your Rights">
 <!ENTITY rights.intro "&brandFullName; is free and open source software, built by a community of thousands from all over the world. There are a few things you should know:">
 
 <!-- Note on pointa / pointb / pointc form:
      These points each have an embedded link in the HTML, so each point is
-     split into chunks for text before the link, the link test, and the text
+     split into chunks for text before the link, the link text, and the text
      after the link. If a localized grammar doesn't need the before or after
      chunk, it can be left blank.
 
      Also note the leading/trailing whitespace in strings here, which is
      deliberate for formatting around the embedded links. -->
 <!ENTITY rights.intro-point1a "&brandShortName; is made available to you under the terms of the ">
 <!ENTITY rights.intro-point1b "Mozilla Public License">
 <!ENTITY rights.intro-point1c ". This means you may use, copy and distribute &brandShortName; to others.  You are also welcome to modify the source code of &brandShortName; as you want to meet your needs. The Mozilla Public License also gives you the right to distribute your modified versions.">
diff -r a131999fa900 browser/themes/gnomestripe/browser/places/editBookmarkOverlay.css
--- a/browser/themes/gnomestripe/browser/places/editBookmarkOverlay.css	Thu Oct 30 23:42:02 2008 -0700
+++ b/browser/themes/gnomestripe/browser/places/editBookmarkOverlay.css	Sat Nov 01 13:47:50 2008 +0200
@@ -110,16 +110,25 @@
 
 
 /* Hide the drop marker and the popup. */
 #editBMPanel_namePicker[droppable="false"] > .menulist-dropmarker,
 #editBMPanel_namePicker[droppable="false"] > menupopup {
   display: none;
 }
 
+/* Hide the value column of the tag autocomplete popup
+ * leaving only the comment column visible. This is
+ * so that only the tag being edited is shown in the
+ * popup.
+ */
+#editBMPanel_tagsField #treecolAutoCompleteValue {
+  visibility: collapse;
+}
+
 
 /* Bookmark panel dropdown menu items */
 #editBMPanel_folderMenuList[selectedIndex="0"],
 #editBMPanel_toolbarFolderItem {
   list-style-image: url("chrome://browser/skin/places/bookmarksToolbar.png") !important;  
 }
 
 #editBMPanel_folderMenuList[selectedIndex="1"],
diff -r a131999fa900 browser/themes/pinstripe/browser/browser.css
--- a/browser/themes/pinstripe/browser/browser.css	Thu Oct 30 23:42:02 2008 -0700
+++ b/browser/themes/pinstripe/browser/browser.css	Sat Nov 01 13:47:50 2008 +0200
@@ -1321,17 +1321,21 @@ richlistitem[selected="true"][current="t
 #editBookmarkPanel #editBMPanel_namePicker[droppable="false"] {
   color: #ffffff;
 }
 
 #editBookmarkPanel #editBMPanel_namePicker[droppable="false"] > .menulist-dropmarker {
   display: none;
 }
 
-#editBookmarkPanel #editBMPanel_tagsField,
+#editBookmarkPanel #editBMPanel_tagsField[focused="true"] {
+  background-color: #eeeeee;
+  color: #000000;
+}
+
 #editBookmarkPanel #editBMPanel_namePicker[droppable="false"] > .menulist-editable-box {
   -moz-appearance: none !important;
   cursor: text;
   margin: 2px 4px;
   border: 2px solid;
   -moz-border-top-colors: #1c1c1c #545454 ;
   -moz-border-right-colors: #1c1c1c #636363;
   -moz-border-bottom-colors: #1c1c1c #797979;
@@ -1341,17 +1345,16 @@ richlistitem[selected="true"][current="t
   background-color: #666666;
   color: #ffffff;
 }
 
 #editBookmarkPanel #editBMPanel_tagsField[empty="true"] {
   color: #bbbbbb;
 }
 
-#editBookmarkPanel #editBMPanel_tagsField[focused="true"],
 #editBookmarkPanel #editBMPanel_namePicker[droppable="false"][focused="true"] > .menulist-editable-box {
   outline: 2px solid -moz-mac-focusring;
   outline-offset: -1px;
   -moz-outline-radius: 1px;
   background-color: #eeeeee;
   color: #000000;
 }
 
diff -r a131999fa900 browser/themes/pinstripe/browser/places/editBookmarkOverlay.css
--- a/browser/themes/pinstripe/browser/places/editBookmarkOverlay.css	Thu Oct 30 23:42:02 2008 -0700
+++ b/browser/themes/pinstripe/browser/places/editBookmarkOverlay.css	Sat Nov 01 13:47:50 2008 +0200
@@ -148,16 +148,25 @@
 #editBMPanel_namePicker[droppable="false"] > .menulist-dropmarker {
   display: none;
 }
 
 #editBMPanel_namePicker[droppable="false"] > menupopup {
   display: none;
 }
 
+/* Hide the value column of the tag autocomplete popup
+ * leaving only the comment column visible. This is
+ * so that only the tag being edited is shown in the
+ * popup.
+ */
+#editBMPanel_tagsField #treecolAutoCompleteValue {
+  visibility: collapse;
+}
+
 
 /* ----- BOOKMARK PANEL DROPDOWN MENU ITEMS ----- */	
 
 #editBMPanel_folderMenuList[selectedIndex="0"],
 #editBMPanel_toolbarFolderItem {
   list-style-image: url("chrome://browser/skin/places/bookmarksToolbar.png") !important;  
 }
 
diff -r a131999fa900 browser/themes/winstripe/browser/places/editBookmarkOverlay.css
--- a/browser/themes/winstripe/browser/places/editBookmarkOverlay.css	Thu Oct 30 23:42:02 2008 -0700
+++ b/browser/themes/winstripe/browser/places/editBookmarkOverlay.css	Sat Nov 01 13:47:50 2008 +0200
@@ -107,16 +107,25 @@
 
 /* Hide the drop marker and the popup. */
 
 #editBMPanel_namePicker[droppable="false"] > .menulist-dropmarker,
 #editBMPanel_namePicker[droppable="false"] > menupopup {
   display: none;
 }
 
+/* Hide the value column of the tag autocomplete popup
+ * leaving only the comment column visible. This is
+ * so that only the tag being edited is shown in the
+ * popup.
+ */
+#editBMPanel_tagsField #treecolAutoCompleteValue {
+  visibility: collapse;
+}
+
 
 /* ::::: bookmark panel dropdown icons ::::: */
 
 #editBMPanel_folderMenuList[selectedIndex="0"],
 #editBMPanel_toolbarFolderItem {
   list-style-image: url("chrome://browser/skin/places/bookmarksToolbar.png") !important;
   -moz-image-region: auto !important;
 }
diff -r a131999fa900 configure.in
--- a/configure.in	Thu Oct 30 23:42:02 2008 -0700
+++ b/configure.in	Sat Nov 01 13:47:50 2008 +0200
@@ -8281,18 +8281,20 @@ if test -z "$MOZ_NATIVE_NSPR"; then
     fi
     rm -f config/autoconf.mk.bak
 fi
 
 # Run the SpiderMonkey 'configure' script.
 dist=$MOZ_BUILD_ROOT/dist
 ac_configure_args="$_SUBDIR_CONFIG_ARGS"
 ac_configure_args="$ac_configure_args --enable-threadsafe"
-ac_configure_args="$ac_configure_args --with-nspr-cflags='$NSPR_CFLAGS'"
-ac_configure_args="$ac_configure_args --with-nspr-libs='$NSPR_LIBS'"
+if test -z "$MOZ_NATIVE_NSPR"; then
+    ac_configure_args="$ac_configure_args --with-nspr-cflags='$NSPR_CFLAGS'"
+    ac_configure_args="$ac_configure_args --with-nspr-libs='$NSPR_LIBS'"
+fi
 ac_configure_args="$ac_configure_args --includedir=$dist/include"
 ac_configure_args="$ac_configure_args --bindir=$dist/bin"
 ac_configure_args="$ac_configure_args --libdir=$dist/lib"
 ac_configure_args="$ac_configure_args --with-sync-build-files=$srcdir"
 if test "$MOZ_MEMORY"; then
    ac_configure_args="$ac_configure_args --enable-jemalloc"  
 fi
 AC_OUTPUT_SUBDIRS(js/src)
diff -r a131999fa900 content/base/public/nsIXMLHttpRequest.idl
--- a/content/base/public/nsIXMLHttpRequest.idl	Thu Oct 30 23:42:02 2008 -0700
+++ b/content/base/public/nsIXMLHttpRequest.idl	Sat Nov 01 13:47:50 2008 +0200
@@ -362,17 +362,17 @@ interface nsIXMLHttpRequest : nsISupport
    * Call open() before setting an onreadystatechange listener.
    */
   attribute nsIDOMEventListener onreadystatechange;
 };
 
 /**
  * DEPRECATED.
  */
-[scriptable, uuid(261676b4-d508-43bf-b099-74635a0ee2e9)]
+[scriptable, uuid(423fdd3d-41c9-4149-8fe5-b14a1d3912a0)]
 interface nsIJSXMLHttpRequest : nsISupports {
   /**
    * Meant to be a script-only mechanism for setting an upload progress event
    * listener.
    * This attribute should not be used from native code!!
    * This event listener may be called multiple times during the upload..
    *
    * After the initial response, all event listeners will be cleared.
diff -r a131999fa900 content/base/src/nsContentList.cpp
--- a/content/base/src/nsContentList.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/content/base/src/nsContentList.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -346,16 +346,17 @@ nsContentList::~nsContentList()
     // Clean up mData
     (*mDestroyFunc)(mData);
   }
 }
 
 
 // QueryInterface implementation for nsContentList
 NS_INTERFACE_MAP_BEGIN(nsContentList)
+  NS_INTERFACE_MAP_ENTRY(nsIHTMLCollection)
   NS_INTERFACE_MAP_ENTRY(nsIDOMHTMLCollection)
   NS_INTERFACE_MAP_ENTRY(nsIMutationObserver)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(ContentList)
 NS_INTERFACE_MAP_END_INHERITING(nsBaseContentList)
 
 
 NS_IMPL_ADDREF_INHERITED(nsContentList, nsBaseContentList)
 NS_IMPL_RELEASE_INHERITED(nsContentList, nsBaseContentList)
@@ -494,16 +495,30 @@ nsContentList::NamedItem(const nsAString
 
   return NS_OK;
 }
 
 nsINode*
 nsContentList::GetNodeAt(PRUint32 aIndex)
 {
   return Item(aIndex, PR_TRUE);
+}
+
+nsISupports*
+nsContentList::GetNodeAt(PRUint32 aIndex, nsresult* aResult)
+{
+  *aResult = NS_OK;
+  return Item(aIndex, PR_TRUE);
+}
+
+nsISupports*
+nsContentList::GetNamedItem(const nsAString& aName, nsresult* aResult)
+{
+  *aResult = NS_OK;
+  return NamedItem(aName, PR_TRUE);
 }
 
 void
 nsContentList::AttributeChanged(nsIDocument *aDocument, nsIContent* aContent,
                                 PRInt32 aNameSpaceID, nsIAtom* aAttribute,
                                 PRInt32 aModType, PRUint32 aStateMask)
 {
   NS_PRECONDITION(aContent, "Must have a content node to work with");
diff -r a131999fa900 content/base/src/nsContentList.h
--- a/content/base/src/nsContentList.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/content/base/src/nsContentList.h	Sat Nov 01 13:47:50 2008 +0200
@@ -42,17 +42,17 @@
  */
 
 #ifndef nsContentList_h___
 #define nsContentList_h___
 
 #include "nsISupports.h"
 #include "nsCOMArray.h"
 #include "nsString.h"
-#include "nsIDOMHTMLCollection.h"
+#include "nsIHTMLCollection.h"
 #include "nsIDOMNodeList.h"
 #include "nsINodeList.h"
 #include "nsStubMutationObserver.h"
 #include "nsIAtom.h"
 #include "nsINameSpaceManager.h"
 #include "nsCycleCollectionParticipant.h"
 
 // Magic namespace id that means "match all namespaces".  This is
@@ -176,17 +176,17 @@ protected:
 #define LIST_LAZY 2
 
 /**
  * Class that implements a live NodeList that matches Elements in the
  * tree based on some criterion.
  */
 class nsContentList : public nsBaseContentList,
                       protected nsContentListKey,
-                      public nsIDOMHTMLCollection,
+                      public nsIHTMLCollection,
                       public nsStubMutationObserver
 {
 public:
   NS_DECL_ISUPPORTS_INHERITED
 
   /**
    * @param aRootNode The node under which to limit our search.
    * @param aMatchAtom An atom whose meaning depends on aMatchNameSpaceId.
@@ -236,17 +236,20 @@ public:
   virtual ~nsContentList();
 
   // nsIDOMHTMLCollection
   NS_DECL_NSIDOMHTMLCOLLECTION
 
   // nsBaseContentList overrides
   virtual PRInt32 IndexOf(nsIContent *aContent, PRBool aDoFlush);
   virtual nsINode* GetNodeAt(PRUint32 aIndex);
-  
+
+  // nsIHTMLCollection
+  virtual nsISupports* GetNodeAt(PRUint32 aIndex, nsresult* aResult);
+  virtual nsISupports* GetNamedItem(const nsAString& aName, nsresult* aResult);
 
   // nsContentList public methods
   NS_HIDDEN_(nsISupports*) GetParentObject();
   NS_HIDDEN_(PRUint32) Length(PRBool aDoFlush);
   NS_HIDDEN_(nsIContent*) Item(PRUint32 aIndex, PRBool aDoFlush);
   NS_HIDDEN_(nsIContent*) NamedItem(const nsAString& aName, PRBool aDoFlush);
 
   nsContentListKey* GetKey() {
diff -r a131999fa900 content/base/src/nsDOMAttributeMap.cpp
--- a/content/base/src/nsDOMAttributeMap.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/content/base/src/nsDOMAttributeMap.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -211,31 +211,45 @@ nsDOMAttributeMap::GetAttribute(nsINodeI
     if (newAttr && mAttributeCache.Put(attr, newAttr)) {
       node = newAttr;
     }
   }
 
   return node;
 }
 
+nsIDOMNode*
+nsDOMAttributeMap::GetNamedItem(const nsAString& aAttrName, nsresult *aResult)
+{
+  *aResult = NS_OK;
+
+  if (mContent) {
+    nsCOMPtr<nsINodeInfo> ni =
+      mContent->GetExistingAttrNameFromQName(aAttrName);
+    if (ni) {
+      nsIDOMNode* node = GetAttribute(ni);
+      if (node) {
+        return node;
+      }
+
+      *aResult = NS_ERROR_OUT_OF_MEMORY;
+    }
+  }
+
+  return nsnull;
+}
+
 NS_IMETHODIMP
 nsDOMAttributeMap::GetNamedItem(const nsAString& aAttrName,
                                 nsIDOMNode** aAttribute)
 {
   NS_ENSURE_ARG_POINTER(aAttribute);
-  *aAttribute = nsnull;
 
-  nsresult rv = NS_OK;
-  if (mContent) {
-    nsCOMPtr<nsINodeInfo> ni =
-      mContent->GetExistingAttrNameFromQName(aAttrName);
-    if (ni) {
-      rv = GetAttribute(ni, aAttribute);
-    }
-  }
+  nsresult rv;
+  NS_IF_ADDREF(*aAttribute = GetNamedItem(aAttrName, &rv));
 
   return rv;
 }
 
 NS_IMETHODIMP
 nsDOMAttributeMap::SetNamedItem(nsIDOMNode *aNode, nsIDOMNode **aReturn)
 {
   return SetNamedItemInternal(aNode, aReturn, PR_FALSE);
diff -r a131999fa900 content/base/src/nsDOMAttributeMap.h
--- a/content/base/src/nsDOMAttributeMap.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/content/base/src/nsDOMAttributeMap.h	Sat Nov 01 13:47:50 2008 +0200
@@ -166,16 +166,17 @@ public:
    * Enumerates over the attribute nodess in the map and calls aFunc for each
    * one. If aFunc returns PL_DHASH_STOP we'll stop enumerating at that point.
    *
    * @return The number of attribute nodes that aFunc was called for.
    */
   PRUint32 Enumerate(AttrCache::EnumReadFunction aFunc, void *aUserArg) const;
 
   nsIDOMNode* GetItemAt(PRUint32 aIndex, nsresult *rv);
+  nsIDOMNode* GetNamedItem(const nsAString& aAttrName, nsresult *rv);
 
   static nsDOMAttributeMap* FromSupports(nsISupports* aSupports)
   {
 #ifdef DEBUG
     {
       nsCOMPtr<nsIDOMNamedNodeMap> map_qi = do_QueryInterface(aSupports);
 
       // If this assertion fires the QI implementation for the object in
diff -r a131999fa900 content/html/content/public/nsIHTMLCollection.h
--- a/content/html/content/public/nsIHTMLCollection.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/content/html/content/public/nsIHTMLCollection.h	Sat Nov 01 13:47:50 2008 +0200
@@ -37,29 +37,35 @@
 
 #ifndef nsIHTMLCollection_h___
 #define nsIHTMLCollection_h___
 
 #include "nsIDOMHTMLCollection.h"
 
 // IID for the nsIHTMLCollection interface
 #define NS_IHTMLCOLLECTION_IID \
-{ 0xb90f2c8c, 0xc564, 0x4464, \
- { 0x97, 0x01, 0x05, 0x14, 0xe4, 0xeb, 0x69, 0x65 } }
+{ 0x5709485b, 0xc057, 0x4ba7, \
+ { 0x95, 0xbd, 0x98, 0xb7, 0x94, 0x4f, 0x13, 0xe7 } }
 
 /**
  * An internal interface that allows QI-less getting of nodes from HTML
  * collections
  */
 class nsIHTMLCollection : public nsIDOMHTMLCollection
 {
 public:
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_IHTMLCOLLECTION_IID)
 
   /**
-   * Get the node at the index.  Returns null if the index is out of bounds
+   * Get the node at the index.  Returns null if the index is out of bounds.
    */
   virtual nsISupports* GetNodeAt(PRUint32 aIndex, nsresult* aResult) = 0;
+
+  /**
+   * Get the node for the name.  Returns null if no node exists for the name.
+   */
+  virtual nsISupports* GetNamedItem(const nsAString& aName,
+                                    nsresult* aResult) = 0;
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(nsIHTMLCollection, NS_IHTMLCOLLECTION_IID)
 
 #endif /* nsIHTMLCollection_h___ */
diff -r a131999fa900 content/html/content/src/nsHTMLFormElement.cpp
--- a/content/html/content/src/nsHTMLFormElement.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/content/html/content/src/nsHTMLFormElement.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -370,26 +370,31 @@ public:
   virtual nsISupports* GetNodeAt(PRUint32 aIndex, nsresult* aResult)
   {
     FlushPendingNotifications();
 
     *aResult = NS_OK;
 
     return mElements.SafeElementAt(aIndex, nsnull);
   }
+  virtual nsISupports* GetNamedItem(const nsAString& aName, nsresult* aResult)
+  {
+    *aResult = NS_OK;
+
+    return NamedItemInternal(aName, PR_TRUE);
+  }
 
   nsresult AddElementToTable(nsIFormControl* aChild,
                              const nsAString& aName);
   nsresult RemoveElementFromTable(nsIFormControl* aChild,
                                   const nsAString& aName);
   nsresult IndexOfControl(nsIFormControl* aControl,
                           PRInt32* aIndex);
 
-  void NamedItemInternal(const nsAString& aName, PRBool aFlushContent,
-                         nsISupports **aResult);
+  nsISupports* NamedItemInternal(const nsAString& aName, PRBool aFlushContent);
   
   /**
    * Create a sorted list of form control elements. This list is sorted
    * in document order and contains the controls in the mElements and
    * mNotInElements list. This function does not add references to the
    * elements.
    *
    * @param aControls The list of sorted controls[out].
@@ -1542,18 +1547,18 @@ nsHTMLFormElement::ResolveName(const nsA
 {
   return DoResolveName(aName, PR_TRUE);
 }
 
 already_AddRefed<nsISupports>
 nsHTMLFormElement::DoResolveName(const nsAString& aName,
                                  PRBool aFlushContent)
 {
-  nsISupports *result = nsnull;
-  mControls->NamedItemInternal(aName, aFlushContent, &result);
+  nsISupports *result;
+  NS_IF_ADDREF(result = mControls->NamedItemInternal(aName, aFlushContent));
   return result;
 }
 
 NS_IMETHODIMP
 nsHTMLFormElement::OnSubmitClickBegin()
 {
   mDeferSubmission = PR_TRUE;
 
@@ -2192,30 +2197,29 @@ nsFormControlList::NamedItem(const nsASt
 
   return rv;
 }
 
 NS_IMETHODIMP
 nsFormControlList::NamedItem(const nsAString& aName,
                              nsISupports** aReturn)
 {
-  NamedItemInternal(aName, PR_TRUE, aReturn);
+  NS_IF_ADDREF(*aReturn = NamedItemInternal(aName, PR_TRUE));
   return NS_OK;
 }
 
-void
+nsISupports*
 nsFormControlList::NamedItemInternal(const nsAString& aName,
-                                     PRBool aFlushContent,
-                                     nsISupports** aReturn)
+                                     PRBool aFlushContent)
 {
   if (aFlushContent) {
     FlushPendingNotifications();
   }
 
-  mNameLookupTable.Get(aName, aReturn);
+  return mNameLookupTable.GetWeak(aName);
 }
 
 nsresult
 nsFormControlList::AddElementToTable(nsIFormControl* aChild,
                                      const nsAString& aName)
 {
   if (!ShouldBeInElements(aChild)) {
     return NS_OK;
diff -r a131999fa900 content/html/content/src/nsHTMLSelectElement.cpp
--- a/content/html/content/src/nsHTMLSelectElement.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/content/html/content/src/nsHTMLSelectElement.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -1954,41 +1954,49 @@ nsHTMLOptionCollection::Item(PRUint32 aI
     *aReturn = nsnull;
 
     return rv;
   }
 
   return CallQueryInterface(item, aReturn);
 }
 
+nsISupports*
+nsHTMLOptionCollection::GetNamedItem(const nsAString& aName, nsresult* aResult)
+{
+  *aResult = NS_OK;
+
+  PRInt32 count = mElements.Count();
+  for (PRInt32 i = 0; i < count; i++) {
+    nsCOMPtr<nsIContent> content = do_QueryInterface(mElements.ObjectAt(i));
+    if (content &&
+        (content->AttrValueIs(kNameSpaceID_None, nsGkAtoms::name, aName,
+                              eCaseMatters) ||
+         content->AttrValueIs(kNameSpaceID_None, nsGkAtoms::id, aName,
+                              eCaseMatters))) {
+      return content;
+    }
+  }
+
+  return nsnull;
+}
+
 NS_IMETHODIMP
 nsHTMLOptionCollection::NamedItem(const nsAString& aName,
                                   nsIDOMNode** aReturn)
 {
-  PRInt32 count = mElements.Count();
-  nsresult rv = NS_OK;
+  nsresult rv;
+  nsISupports* item = GetNamedItem(aName, &rv);
+  if (!item) {
+    *aReturn = nsnull;
 
-  *aReturn = nsnull;
-
-  for (PRInt32 i = 0; i < count; i++) {
-    nsCOMPtr<nsIContent> content = do_QueryInterface(mElements.ObjectAt(i));
-
-    if (content) {
-      if (content->AttrValueIs(kNameSpaceID_None, nsGkAtoms::name, aName,
-                               eCaseMatters) ||
-          content->AttrValueIs(kNameSpaceID_None, nsGkAtoms::id, aName,
-                               eCaseMatters)) {
-        rv = CallQueryInterface(content, aReturn);
-
-        break;
-      }
-    }
+    return rv;
   }
 
-  return rv;
+  return CallQueryInterface(item, aReturn);
 }
 
 NS_IMETHODIMP
 nsHTMLOptionCollection::GetSelect(nsIDOMHTMLSelectElement **aReturn)
 {
   NS_IF_ADDREF(*aReturn = mSelect);
   return NS_OK;
 }
diff -r a131999fa900 content/html/content/src/nsHTMLSelectElement.h
--- a/content/html/content/src/nsHTMLSelectElement.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/content/html/content/src/nsHTMLSelectElement.h	Sat Nov 01 13:47:50 2008 +0200
@@ -89,16 +89,17 @@ public:
   // nsIDOMHTMLOptionsCollection
 
   virtual nsISupports* GetNodeAt(PRUint32 aIndex, nsresult* aResult)
   {
     *aResult = NS_OK;
 
     return mElements.SafeObjectAt(aIndex);
   }
+  virtual nsISupports* GetNamedItem(const nsAString& aName, nsresult* aResult);
 
   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsHTMLOptionCollection,
                                            nsIHTMLCollection)
 
   // Helpers for nsHTMLSelectElement
   /**
    * Insert an option
    * @param aOption the option to insert
diff -r a131999fa900 content/html/content/src/nsHTMLTableElement.cpp
--- a/content/html/content/src/nsHTMLTableElement.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/content/html/content/src/nsHTMLTableElement.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -113,16 +113,17 @@ public:
   virtual ~TableRowsCollection();
 
   nsresult Init();
 
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_NSIDOMHTMLCOLLECTION
 
   virtual nsISupports* GetNodeAt(PRUint32 aIndex, nsresult* aResult);
+  virtual nsISupports* GetNamedItem(const nsAString& aName, nsresult* aResult);
 
   NS_IMETHOD    ParentDestroyed();
 
   NS_DECL_CYCLE_COLLECTION_CLASS(TableRowsCollection)
 
 protected:
   // Those rows that are not in table sections
   nsRefPtr<nsContentList> mOrphanRows;  
@@ -319,42 +320,56 @@ TableRowsCollection::Item(PRUint32 aInde
     *aReturn = nsnull;
 
     return rv;
   }
 
   return CallQueryInterface(node, aReturn);
 }
 
-static nsresult
+static nsISupports*
 GetNamedItemInRowGroup(nsIDOMHTMLCollection* aRows,
-                       const nsAString& aName, nsIDOMNode** aNamedItem)
+                       const nsAString& aName, nsresult* aResult)
 {
-  if (aRows) {
-    return aRows->NamedItem(aName, aNamedItem);
+  nsCOMPtr<nsIHTMLCollection> rows = do_QueryInterface(aRows);
+  if (rows) {
+    return rows->GetNamedItem(aName, aResult);
   }
 
-  *aNamedItem = nsnull;
-  return NS_OK;
+  *aResult = NS_OK;
+  return nsnull;
+}
+
+nsISupports* 
+TableRowsCollection::GetNamedItem(const nsAString& aName, nsresult* aResult)
+{
+  nsresult rv = NS_OK;
+  DO_FOR_EACH_ROWGROUP(
+    nsISupports* item = GetNamedItemInRowGroup(rows, aName, aResult);
+    if (NS_FAILED(*aResult) || item) {
+      return item;
+    }
+  );
+  *aResult = rv;
+  return nsnull;
 }
 
 NS_IMETHODIMP 
 TableRowsCollection::NamedItem(const nsAString& aName,
                                nsIDOMNode** aReturn)
 {
-  *aReturn = nsnull;
-  nsresult rv = NS_OK;
-  DO_FOR_EACH_ROWGROUP(
-    rv = GetNamedItemInRowGroup(rows, aName, aReturn);
-    NS_ENSURE_SUCCESS(rv, rv);
-    if (*aReturn) {
-      return rv;
-    }
-  );
-  return rv;
+  nsresult rv;
+  nsISupports* item = GetNamedItem(aName, &rv);
+  if (!item) {
+    *aReturn = nsnull;
+
+    return rv;
+  }
+
+  return CallQueryInterface(item, aReturn);
 }
 
 NS_IMETHODIMP
 TableRowsCollection::ParentDestroyed()
 {
   // see comment in destructor, do NOT release mParent!
   mParent = nsnull;
 
diff -r a131999fa900 content/xslt/public/Makefile.in
--- a/content/xslt/public/Makefile.in	Thu Oct 30 23:42:02 2008 -0700
+++ b/content/xslt/public/Makefile.in	Sat Nov 01 13:47:50 2008 +0200
@@ -53,12 +53,13 @@ XPIDLSRCS	= \
 XPIDLSRCS	= \
 		nsIXSLTException.idl  \
 		nsIXSLTProcessor.idl  \
 		nsIXSLTProcessorObsolete.idl  \
 		nsIXSLTProcessorPrivate.idl  \
 		txIFunctionEvaluationContext.idl  \
 		txINodeSet.idl  \
 		txIEXSLTRegExFunctions.idl  \
+		txIXPathObject.idl  \
 		$(NULL)
 
 include $(topsrcdir)/config/rules.mk
 
diff -r a131999fa900 content/xslt/public/txINodeSet.idl
--- a/content/xslt/public/txINodeSet.idl	Thu Oct 30 23:42:02 2008 -0700
+++ b/content/xslt/public/txINodeSet.idl	Sat Nov 01 13:47:50 2008 +0200
@@ -34,24 +34,17 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "domstubs.idl"
 
-%{ C++
-class txAExprResult;
-%}
-
-[ptr] native txAExprResultPtr(txAExprResult);
-
 [scriptable, uuid(15d424c0-6b47-11d9-9791-000a95dc234c)]
 interface txINodeSet : nsISupports
 {
     nsIDOMNode item(in unsigned long index);
     double itemAsNumber(in unsigned long index);
     DOMString itemAsString(in unsigned long index);
     readonly attribute unsigned long length;
     void add(in nsIDOMNode node);
-    [noscript, notxpcom] txAExprResultPtr getTxNodeSet();
 };
diff -r a131999fa900 content/xslt/public/txIXPathObject.idl
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/xslt/public/txIXPathObject.idl	Sat Nov 01 13:47:50 2008 +0200
@@ -0,0 +1,49 @@
+/* -*- Mode: IDL; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Initial Developer of the Original Code is
+ * IBM Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ * Merle Sterling <msterlin@us.ibm.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "domstubs.idl"
+
+%{ C++
+class txAExprResult;
+%}
+
+[ptr] native txAExprResultPtr(txAExprResult);
+
+[scriptable, uuid(67706346-dece-4c9b-9fc2-57cf19071014)]
+interface txIXPathObject : nsISupports
+{
+    [noscript, notxpcom] txAExprResultPtr getResult();
+};
diff -r a131999fa900 content/xslt/src/xpath/txNodeSetAdaptor.cpp
--- a/content/xslt/src/xpath/txNodeSetAdaptor.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/content/xslt/src/xpath/txNodeSetAdaptor.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -36,95 +36,88 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "txNodeSetAdaptor.h"
 #include "txXPathTreeWalker.h"
 
 txNodeSetAdaptor::txNodeSetAdaptor()
-    : mWritable(PR_TRUE)
+    : txXPathObjectAdaptor(),
+      mWritable(PR_TRUE)
 {
 }
 
 txNodeSetAdaptor::txNodeSetAdaptor(txNodeSet *aNodeSet)
-    : mNodeSet(aNodeSet),
+    : txXPathObjectAdaptor(aNodeSet),
       mWritable(PR_FALSE)
 {
-    NS_ASSERTION(aNodeSet,
-                 "Don't create an adaptor if you don't have a txNodeSet");
 }
 
-NS_IMPL_ISUPPORTS1(txNodeSetAdaptor, txINodeSet)
+NS_IMPL_ISUPPORTS_INHERITED1(txNodeSetAdaptor, txXPathObjectAdaptor, txINodeSet)
 
 nsresult
 txNodeSetAdaptor::Init()
 {
-    if (!mNodeSet) {
-        mNodeSet = new txNodeSet(nsnull);
+    if (!mValue) {
+        mValue = new txNodeSet(nsnull);
     }
 
-    return mNodeSet ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
+    return mValue ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
 }
 
 NS_IMETHODIMP
 txNodeSetAdaptor::Item(PRUint32 aIndex, nsIDOMNode **aResult)
 {
     *aResult = nsnull;
 
-    if (aIndex > (PRUint32)mNodeSet->size()) {
+    if (aIndex > (PRUint32)NodeSet()->size()) {
         return NS_ERROR_ILLEGAL_VALUE;
     }
 
-    return txXPathNativeNode::getNode(mNodeSet->get(aIndex), aResult);
+    return txXPathNativeNode::getNode(NodeSet()->get(aIndex), aResult);
 }
 
 NS_IMETHODIMP
 txNodeSetAdaptor::ItemAsNumber(PRUint32 aIndex, double *aResult)
 {
-    if (aIndex > (PRUint32)mNodeSet->size()) {
+    if (aIndex > (PRUint32)NodeSet()->size()) {
         return NS_ERROR_ILLEGAL_VALUE;
     }
 
     nsAutoString result;
-    txXPathNodeUtils::appendNodeValue(mNodeSet->get(aIndex), result);
+    txXPathNodeUtils::appendNodeValue(NodeSet()->get(aIndex), result);
 
     *aResult = Double::toDouble(result);
 
     return NS_OK;
 }
 
 NS_IMETHODIMP
 txNodeSetAdaptor::ItemAsString(PRUint32 aIndex, nsAString &aResult)
 {
-    if (aIndex > (PRUint32)mNodeSet->size()) {
+    if (aIndex > (PRUint32)NodeSet()->size()) {
         return NS_ERROR_ILLEGAL_VALUE;
     }
 
-    txXPathNodeUtils::appendNodeValue(mNodeSet->get(aIndex), aResult);
+    txXPathNodeUtils::appendNodeValue(NodeSet()->get(aIndex), aResult);
 
     return NS_OK;
 }
 
 NS_IMETHODIMP
 txNodeSetAdaptor::GetLength(PRUint32 *aLength)
 {
-    *aLength = (PRUint32)mNodeSet->size();
+    *aLength = (PRUint32)NodeSet()->size();
 
     return NS_OK;
 }
 
 NS_IMETHODIMP
 txNodeSetAdaptor::Add(nsIDOMNode *aNode)
 {
     NS_ENSURE_TRUE(mWritable, NS_ERROR_FAILURE);
 
     nsAutoPtr<txXPathNode> node(txXPathNativeNode::createXPathNode(aNode,
                                                                    PR_TRUE));
 
-    return node ? mNodeSet->add(*node) : NS_ERROR_OUT_OF_MEMORY;
+    return node ? NodeSet()->add(*node) : NS_ERROR_OUT_OF_MEMORY;
 }
-
-txAExprResult*
-txNodeSetAdaptor::GetTxNodeSet()
-{
-    return mNodeSet;
-}
diff -r a131999fa900 content/xslt/src/xpath/txNodeSetAdaptor.h
--- a/content/xslt/src/xpath/txNodeSetAdaptor.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/content/xslt/src/xpath/txNodeSetAdaptor.h	Sat Nov 01 13:47:50 2008 +0200
@@ -37,30 +37,36 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef txNodeSetAdaptor_h__
 #define txNodeSetAdaptor_h__
 
 #include "txINodeSet.h"
 #include "txNodeSet.h"
+#include "txXPathObjectAdaptor.h"
 
 /**
  * Implements an XPCOM wrapper around an XPath NodeSet.
  */
 
-class txNodeSetAdaptor : public txINodeSet 
+class txNodeSetAdaptor : public txXPathObjectAdaptor,
+                         public txINodeSet 
 {
 public:
     txNodeSetAdaptor();
     txNodeSetAdaptor(txNodeSet *aNodeSet);
 
     nsresult Init();
 
-    NS_DECL_ISUPPORTS
+    NS_DECL_ISUPPORTS_INHERITED
     NS_DECL_TXINODESET
 
 private:
-    nsRefPtr<txNodeSet> mNodeSet;
+    txNodeSet* NodeSet()
+    {
+        return static_cast<txNodeSet*>(mValue.get());
+    }
+
     PRBool mWritable;
 };
 
 #endif // txNodeSetAdaptor_h__
diff -r a131999fa900 content/xslt/src/xpath/txXPCOMExtensionFunction.cpp
--- a/content/xslt/src/xpath/txXPCOMExtensionFunction.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/content/xslt/src/xpath/txXPCOMExtensionFunction.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -16,16 +16,17 @@
  *
  * The Initial Developer of the Original Code is
  * Peter Van der Beken.
  * Portions created by the Initial Developer are Copyright (C) 2005
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Peter Van der Beken <peterv@propagandism.org>
+ *   Merle Sterling <msterlin@us.ibm.com>
  *
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
@@ -44,16 +45,19 @@
 #include "nsIInterfaceInfoManager.h"
 #include "nsServiceManagerUtils.h"
 #include "txExpr.h"
 #include "txIFunctionEvaluationContext.h"
 #include "txIXPathContext.h"
 #include "txNodeSetAdaptor.h"
 #include "txXPathTreeWalker.h"
 #include "xptcall.h"
+#include "txXPathObjectAdaptor.h"
+
+NS_IMPL_ISUPPORTS1(txXPathObjectAdaptor, txIXPathObject)
 
 class txFunctionEvaluationContext : public txIFunctionEvaluationContext
 {
 public:
     txFunctionEvaluationContext(txIEvalContext *aContext, nsISupports *aState);
 
     NS_DECL_ISUPPORTS
     NS_DECL_TXIFUNCTIONEVALUATIONCONTEXT
@@ -114,16 +118,17 @@ txFunctionEvaluationContext::GetState(ns
 }
 
 enum txArgumentType {
     eBOOLEAN = nsXPTType::T_BOOL,
     eNUMBER = nsXPTType::T_DOUBLE,
     eSTRING = nsXPTType::T_DOMSTRING,
     eNODESET,
     eCONTEXT,
+    eOBJECT,
     eUNKNOWN
 };
 
 class txXPCOMExtensionFunctionCall : public FunctionCall
 {
 public:
     txXPCOMExtensionFunctionCall(nsISupports *aHelper, const nsIID &aIID,
                                  PRUint16 aMethodIndex,
@@ -302,16 +307,19 @@ txXPCOMExtensionFunctionCall::GetParamTy
             nsIID iid;
             aInfo->GetIIDForParamNoAlloc(mMethodIndex, &aParam, &iid);
             if (iid.Equals(NS_GET_IID(txINodeSet))) {
                 return eNODESET;
             }
             if (iid.Equals(NS_GET_IID(txIFunctionEvaluationContext))) {
                 return eCONTEXT;
             }
+            if (iid.Equals(NS_GET_IID(txIXPathObject))) {
+                return eOBJECT;
+            }
         }
         default:
         {
             // XXX Error!
             return eUNKNOWN;
         }
     }
 }
@@ -483,16 +491,32 @@ txXPCOMExtensionFunctionCall::evaluate(t
 
                 rv = expr->evaluateToString(aContext, *value);
                 NS_ENSURE_SUCCESS(rv, rv);
 
                 invokeParam.SetValIsDOMString();
                 invokeParam.val.p = value;
                 break;
             }
+            case eOBJECT:
+            {
+              nsRefPtr<txAExprResult> exprRes;
+              rv = expr->evaluate(aContext, getter_AddRefs(exprRes));
+              NS_ENSURE_SUCCESS(rv, rv);
+
+              nsCOMPtr<txIXPathObject> adaptor =
+                new txXPathObjectAdaptor(exprRes);
+              if (!adaptor) {
+                  return NS_ERROR_OUT_OF_MEMORY;
+              }
+
+              invokeParam.SetValIsInterface();
+              adaptor.swap((txIXPathObject*&)invokeParam.val.p);
+              break;
+            }
             case eCONTEXT:
             case eUNKNOWN:
             {
                 // We only support passing the context as the *first* argument.
                 return NS_ERROR_FAILURE;
             }
         }
     }
@@ -527,20 +551,21 @@ txXPCOMExtensionFunctionCall::evaluate(t
         context->ClearContext();
     }
 
     NS_ENSURE_SUCCESS(rv, rv);
 
     switch (returnType) {
         case eNODESET:
         {
-            txINodeSet *nodeSet = static_cast<txINodeSet*>
-                                             (returnParam.val.p);
+            txINodeSet* nodeSet = static_cast<txINodeSet*>(returnParam.val.p);
+            nsCOMPtr<txIXPathObject> object = do_QueryInterface(nodeSet, &rv);
+            NS_ENSURE_SUCCESS(rv, rv);
 
-            NS_ADDREF(*aResult = nodeSet->GetTxNodeSet());
+            NS_ADDREF(*aResult = object->GetResult());
 
             return NS_OK;
         }
         case eBOOLEAN:
         {
             aContext->recycler()->getBoolResult(returnParam.val.b, aResult);
 
             return NS_OK;
@@ -550,16 +575,25 @@ txXPCOMExtensionFunctionCall::evaluate(t
             return aContext->recycler()->getNumberResult(returnParam.val.d,
                                                          aResult);
         }
         case eSTRING:
         {
             nsString *returned = static_cast<nsString*>
                                             (returnParam.val.p);
             return aContext->recycler()->getStringResult(*returned, aResult);
+        }
+        case eOBJECT:
+        {
+            txIXPathObject *object =
+                 static_cast<txIXPathObject*>(returnParam.val.p);
+
+            NS_ADDREF(*aResult = object->GetResult());
+
+            return NS_OK;
         }
         default:
         {
             // Huh?
             return NS_ERROR_FAILURE;
         }
     }
 }
diff -r a131999fa900 content/xslt/src/xpath/txXPathObjectAdaptor.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/xslt/src/xpath/txXPathObjectAdaptor.h	Sat Nov 01 13:47:50 2008 +0200
@@ -0,0 +1,74 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Initial Developer of the Original Code is
+ * IBM Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 20008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ * Merle Sterling <msterlin@us.ibm.com>
+
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef txXPathObjectAdaptor_h__
+#define txXPathObjectAdaptor_h__
+
+#include "txExprResult.h"
+#include "txINodeSet.h"
+#include "txIXPathObject.h"
+
+/**
+ * Implements an XPCOM wrapper around XPath data types boolean, number, string,
+ * or nodeset.
+ */
+
+class txXPathObjectAdaptor : public txIXPathObject
+{
+public:
+    txXPathObjectAdaptor(txAExprResult *aValue) : mValue(aValue)
+    {
+        NS_ASSERTION(aValue,
+                     "Don't create a txXPathObjectAdaptor if you don't have a "
+                     "txAExprResult");
+    }
+
+    NS_DECL_ISUPPORTS
+
+    NS_IMETHODIMP_(txAExprResult*) GetResult()
+    {
+        return mValue;
+    }
+
+protected:
+    txXPathObjectAdaptor() : mValue(nsnull)
+    {
+    }
+
+    nsRefPtr<txAExprResult> mValue;
+};
+
+#endif // txXPathObjectAdaptor_h__
diff -r a131999fa900 dom/public/idl/base/nsIDOMNavigator.idl
--- a/dom/public/idl/base/nsIDOMNavigator.idl	Thu Oct 30 23:42:02 2008 -0700
+++ b/dom/public/idl/base/nsIDOMNavigator.idl	Sat Nov 01 13:47:50 2008 +0200
@@ -36,17 +36,17 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "domstubs.idl"
 
 interface nsIDOMWorkerPool;
 
-[scriptable, uuid(8e150a70-3e51-45df-bee3-77505fbe016c)]
+[scriptable, uuid(c206f746-52e2-47dd-8ccc-ce76ccda6c6d)]
 interface nsIDOMNavigator : nsISupports
 {
   readonly attribute DOMString           appCodeName;
   readonly attribute DOMString           appName;
   readonly attribute DOMString           appVersion;
   readonly attribute DOMString           language;
   readonly attribute nsIDOMMimeTypeArray mimeTypes;
   readonly attribute DOMString           platform;
diff -r a131999fa900 dom/public/idl/html/nsIDOMHTMLCanvasElement.idl
--- a/dom/public/idl/html/nsIDOMHTMLCanvasElement.idl	Thu Oct 30 23:42:02 2008 -0700
+++ b/dom/public/idl/html/nsIDOMHTMLCanvasElement.idl	Sat Nov 01 13:47:50 2008 +0200
@@ -42,17 +42,17 @@
  * <canvas> element.
  *
  * For more information on this interface, please see
  * http://www.whatwg.org/specs/web-apps/current-work/#graphics
  *
  * @status UNDER_DEVELOPMENT
  */
 
-[scriptable, uuid(0583A2EA-AB19-40e1-8BE4-5E9B2F275560)]
+[scriptable, uuid(d87394af-d31a-484e-8b7c-75381045384d)]
 interface nsIDOMHTMLCanvasElement : nsIDOMHTMLElement
 {
   attribute long width;
   attribute long height;
   attribute boolean mozOpaque;
 
   nsISupports getContext(in DOMString contextId);
 
diff -r a131999fa900 dom/public/idl/traversal/nsIDOMNodeIterator.idl
--- a/dom/public/idl/traversal/nsIDOMNodeIterator.idl	Thu Oct 30 23:42:02 2008 -0700
+++ b/dom/public/idl/traversal/nsIDOMNodeIterator.idl	Sat Nov 01 13:47:50 2008 +0200
@@ -38,17 +38,17 @@
  * ***** END LICENSE BLOCK ***** */
 
 #include "domstubs.idl"
 
 interface nsIDOMNodeIterator;
 interface nsIDOMNodeFilter;
 
 
-[scriptable, uuid(354b5f02-1dd2-11b2-b053-b8c2997022a0)]
+[scriptable, uuid(5af83f50-c8d5-4824-be29-1aa9d640bacb)]
 // Introduced in DOM Level 2:
 interface nsIDOMNodeIterator : nsISupports
 {
   readonly attribute nsIDOMNode       root;
   readonly attribute unsigned long    whatToShow;
   readonly attribute nsIDOMNodeFilter filter;
   readonly attribute boolean          expandEntityReferences;
   nsIDOMNode         nextNode()
diff -r a131999fa900 dom/src/base/nsDOMClassInfo.cpp
--- a/dom/src/base/nsDOMClassInfo.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/dom/src/base/nsDOMClassInfo.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -438,22 +438,17 @@
 
 #ifdef MOZ_ENABLE_CANVAS
 #include "nsIDOMCanvasRenderingContext2D.h"
 #endif
 
 #include "nsIImageDocument.h"
 
 // Storage includes
-#include "nsIDOMStorage.h"
-#include "nsPIDOMStorage.h"
-#include "nsIDOMStorageList.h"
-#include "nsIDOMStorageItem.h"
-#include "nsIDOMStorageEvent.h"
-#include "nsIDOMToString.h"
+#include "nsDOMStorage.h"
 
 // Drag and drop
 #include "nsIDOMDataTransfer.h"
 
 // Offline includes
 #include "nsIDOMLoadStatus.h"
 #include "nsIDOMLoadStatusEvent.h"
 
@@ -669,17 +664,17 @@ static nsDOMClassInfoData sClassInfoData
   // Misc HTML classes
   NS_DEFINE_CLASSINFO_DATA(HTMLDocument, nsHTMLDocumentSH,
                            DOCUMENT_SCRIPTABLE_FLAGS)
   NS_DEFINE_CLASSINFO_DATA(HTMLOptionsCollection,
                            nsHTMLOptionsCollectionSH,
                            ARRAY_SCRIPTABLE_FLAGS |
                            nsIXPCScriptable::WANT_SETPROPERTY)
   NS_DEFINE_CLASSINFO_DATA_WITH_NAME(HTMLFormControlCollection, HTMLCollection,
-                                     nsFormControlListSH,
+                                     nsHTMLCollectionSH,
                                      ARRAY_SCRIPTABLE_FLAGS)
   NS_DEFINE_CLASSINFO_DATA_WITH_NAME(HTMLGenericCollection, HTMLCollection,
                                      nsHTMLCollectionSH,
                                      ARRAY_SCRIPTABLE_FLAGS)
 
   // HTML element classes
   NS_DEFINE_CLASSINFO_DATA(HTMLAnchorElement, nsHTMLElementSH,
                            ELEMENT_SCRIPTABLE_FLAGS)
@@ -7710,19 +7705,19 @@ nsStringListSH::GetStringAt(nsISupports 
 // Named Array helper
 
 NS_IMETHODIMP
 nsNamedArraySH::GetProperty(nsIXPConnectWrappedNative *wrapper, JSContext *cx,
                             JSObject *obj, jsval id, jsval *vp,
                             PRBool *_retval)
 {
   if (JSVAL_IS_STRING(id) && !ObjectIsNativeWrapper(cx, obj)) {
-    nsCOMPtr<nsISupports> item;
-    nsresult rv = GetNamedItem(wrapper->Native(), nsDependentJSString(id),
-                               getter_AddRefs(item));
+    nsresult rv = NS_OK;
+    nsISupports* item = GetNamedItem(wrapper->Native(), nsDependentJSString(id),
+                                     &rv);
     NS_ENSURE_SUCCESS(rv, rv);
 
     if (item) {
       nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
       rv = WrapNative(cx, obj, item, NS_GET_IID(nsISupports), vp,
                       getter_AddRefs(holder));
       NS_ENSURE_SUCCESS(rv, rv);
 
@@ -7743,67 +7738,86 @@ nsNamedNodeMapSH::GetItemAt(nsISupports 
 nsNamedNodeMapSH::GetItemAt(nsISupports *aNative, PRUint32 aIndex,
                             nsresult *aResult)
 {
   nsDOMAttributeMap* map = nsDOMAttributeMap::FromSupports(aNative);
 
   return map->GetItemAt(aIndex, aResult);
 }
 
-nsresult
+nsISupports*
 nsNamedNodeMapSH::GetNamedItem(nsISupports *aNative, const nsAString& aName,
-                               nsISupports **aResult)
-{
-  nsCOMPtr<nsIDOMNamedNodeMap> map(do_QueryInterface(aNative));
-  NS_ENSURE_TRUE(map, NS_ERROR_UNEXPECTED);
-
-  nsIDOMNode *node = nsnull; // Weak, transfer the ownership over to aResult
-  nsresult rv = map->GetNamedItem(aName, &node);
-
-  *aResult = node;
-
-  return rv;
+                               nsresult *aResult)
+{
+  nsDOMAttributeMap* map = nsDOMAttributeMap::FromSupports(aNative);
+
+  return map->GetNamedItem(aName, aResult);
 }
 
 
 // HTMLCollection helper
 
-nsISupports*
-nsHTMLCollectionSH::GetItemAt(nsISupports *aNative, PRUint32 aIndex,
-                              nsresult *aResult)
-{
-  nsIHTMLCollection* collection = static_cast<nsIHTMLCollection*>(aNative);
-#ifdef DEBUG
-  {
-    nsCOMPtr<nsIHTMLCollection> collection_qi = do_QueryInterface(aNative);
+nsresult
+nsHTMLCollectionSH::GetLength(nsIXPConnectWrappedNative *wrapper, JSContext *cx,
+                              JSObject *obj, PRUint32 *length)
+{
+  nsIHTMLCollection* collection =
+    static_cast<nsIHTMLCollection*>(wrapper->Native());
+#ifdef DEBUG
+  {
+    nsCOMPtr<nsIHTMLCollection> collection_qi =
+      do_QueryInterface(wrapper->Native());
 
     // If this assertion fires the QI implementation for the object in
     // question doesn't use the nsIHTMLCollection pointer as the nsISupports
     // pointer. That must be fixed, or we'll crash...
     NS_ASSERTION(collection_qi == collection, "Uh, fix QI!");
   }
 #endif
 
+  return collection->GetLength(length);
+}
+
+nsISupports*
+nsHTMLCollectionSH::GetItemAt(nsISupports *aNative, PRUint32 aIndex,
+                              nsresult *aResult)
+{
+  nsIHTMLCollection* collection = static_cast<nsIHTMLCollection*>(aNative);
+#ifdef DEBUG
+  {
+    nsCOMPtr<nsIHTMLCollection> collection_qi = do_QueryInterface(aNative);
+
+    // If this assertion fires the QI implementation for the object in
+    // question doesn't use the nsIHTMLCollection pointer as the nsISupports
+    // pointer. That must be fixed, or we'll crash...
+    NS_ASSERTION(collection_qi == collection, "Uh, fix QI!");
+  }
+#endif
+
   return collection->GetNodeAt(aIndex, aResult);
 }
 
-nsresult
+nsISupports*
 nsHTMLCollectionSH::GetNamedItem(nsISupports *aNative,
                                  const nsAString& aName,
-                                 nsISupports **aResult)
-{
-  nsCOMPtr<nsIDOMHTMLCollection> collection(do_QueryInterface(aNative));
-  NS_ENSURE_TRUE(collection, NS_ERROR_UNEXPECTED);
-
-  nsIDOMNode *node = nsnull; // Weak, transfer the ownership over to aResult
-  nsresult rv = collection->NamedItem(aName, &node);
-
-  *aResult = node;
-
-  return rv;
+                                 nsresult *aResult)
+{
+  nsIHTMLCollection* collection = static_cast<nsIHTMLCollection*>(aNative);
+#ifdef DEBUG
+  {
+    nsCOMPtr<nsIHTMLCollection> collection_qi = do_QueryInterface(aNative);
+
+    // If this assertion fires the QI implementation for the object in
+    // question doesn't use the nsIHTMLCollection pointer as the nsISupports
+    // pointer. That must be fixed, or we'll crash...
+    NS_ASSERTION(collection_qi == collection, "Uh, fix QI!");
+  }
+#endif
+
+  return collection->GetNamedItem(aName, aResult);
 }
 
 
 // ContentList helper
 nsresult
 nsContentListSH::PreCreate(nsISupports *nativeObj, JSContext *cx,
                            JSObject *globalObj, JSObject **parentObj)
 {
@@ -7821,51 +7835,43 @@ nsContentListSH::PreCreate(nsISupports *
                            NS_GET_IID(nsISupports), &v,
                            getter_AddRefs(holder));
 
   *parentObj = JSVAL_TO_OBJECT(v);
 
   return rv;
 }
 
-NS_IMETHODIMP
-nsContentListSH::GetProperty(nsIXPConnectWrappedNative *wrapper, JSContext *cx,
-                             JSObject *obj, jsval id, jsval *vp,
-                             PRBool *_retval)
-{
-  if (JSVAL_IS_STRING(id) && !ObjectIsNativeWrapper(cx, obj)) {
-    nsContentList *list = nsContentList::FromSupports(wrapper->Native());
-    nsINode* node = list->NamedItem(nsDependentJSString(id), PR_TRUE);
-    if (!node) {
-      return NS_OK;
-    }
-
-    nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
-    nsresult rv = WrapNative(cx, obj, node, NS_GET_IID(nsISupports), vp,
-                             getter_AddRefs(holder));
-
-    return NS_FAILED(rv) ? rv : NS_SUCCESS_I_DID_SOMETHING;
-  }
-
-  return nsNodeListSH::GetProperty(wrapper, cx, obj, id, vp, _retval);
-}
-
-
-// FormControlList helper
-
-nsresult
-nsFormControlListSH::GetNamedItem(nsISupports *aNative,
-                                  const nsAString& aName,
-                                  nsISupports **aResult)
-{
-  nsCOMPtr<nsIDOMNSHTMLFormControlList> list(do_QueryInterface(aNative));
-  NS_ENSURE_TRUE(list, NS_ERROR_UNEXPECTED);
-
-  return list->NamedItem(aName, aResult);
-}
+nsresult
+nsContentListSH::GetLength(nsIXPConnectWrappedNative *wrapper, JSContext *cx,
+                           JSObject *obj, PRUint32 *length)
+{
+  nsContentList *list = nsContentList::FromSupports(wrapper->Native());
+
+  return list->GetLength(length);
+}
+
+nsISupports*
+nsContentListSH::GetItemAt(nsISupports *aNative, PRUint32 aIndex,
+                           nsresult *aResult)
+{
+  nsContentList *list = nsContentList::FromSupports(aNative);
+
+  return list->GetNodeAt(aIndex, aResult);
+}
+
+nsISupports*
+nsContentListSH::GetNamedItem(nsISupports *aNative, const nsAString& aName,
+                              nsresult *aResult)
+{
+  nsContentList *list = nsContentList::FromSupports(aNative);
+
+  return list->GetNamedItem(aName, aResult);
+}
+
 
 // Document helper for document.location and document.on*
 
 NS_IMETHODIMP
 nsDocumentSH::AddProperty(nsIXPConnectWrappedNative *wrapper, JSContext *cx,
                           JSObject *obj, jsval id, jsval *vp,
                           PRBool *_retval)
 {
@@ -9890,86 +9896,65 @@ nsPluginSH::GetItemAt(nsISupports *aNati
 nsPluginSH::GetItemAt(nsISupports *aNative, PRUint32 aIndex,
                       nsresult *aResult)
 {
   nsPluginElement* plugin = nsPluginElement::FromSupports(aNative);
 
   return plugin->GetItemAt(aIndex, aResult);
 }
 
-nsresult
+nsISupports*
 nsPluginSH::GetNamedItem(nsISupports *aNative, const nsAString& aName,
-                         nsISupports **aResult)
-{
-  nsCOMPtr<nsIDOMPlugin> plugin(do_QueryInterface(aNative));
-  NS_ENSURE_TRUE(plugin, NS_ERROR_UNEXPECTED);
-
-  nsIDOMMimeType *mime_type = nsnull;
-
-  nsresult rv = plugin->NamedItem(aName, &mime_type);
-
-  *aResult = mime_type;
-
-  return rv;
+                         nsresult *aResult)
+{
+  nsPluginElement* plugin = nsPluginElement::FromSupports(aNative);
+
+  return plugin->GetNamedItem(aName, aResult);
 }
 
 
 // PluginArray helper
 
 nsISupports*
 nsPluginArraySH::GetItemAt(nsISupports *aNative, PRUint32 aIndex,
                            nsresult *aResult)
 {
   nsPluginArray* array = nsPluginArray::FromSupports(aNative);
 
   return array->GetItemAt(aIndex, aResult);
 }
 
-nsresult
+nsISupports*
 nsPluginArraySH::GetNamedItem(nsISupports *aNative, const nsAString& aName,
-                              nsISupports **aResult)
-{
-  nsCOMPtr<nsIDOMPluginArray> array(do_QueryInterface(aNative));
-  NS_ENSURE_TRUE(array, NS_ERROR_UNEXPECTED);
-
-  nsIDOMPlugin *plugin = nsnull;
-
-  nsresult rv = array->NamedItem(aName, &plugin);
-
-  *aResult = plugin;
-
-  return rv;
+                              nsresult *aResult)
+{
+  nsPluginArray* array = nsPluginArray::FromSupports(aNative);
+
+  return array->GetNamedItem(aName, aResult);
 }
 
 
 // MimeTypeArray helper
 
 nsISupports*
 nsMimeTypeArraySH::GetItemAt(nsISupports *aNative, PRUint32 aIndex,
                              nsresult *aResult)
 {
   nsMimeTypeArray* array = nsMimeTypeArray::FromSupports(aNative);
 
   return array->GetItemAt(aIndex, aResult);
 }
 
-nsresult
+nsISupports*
 nsMimeTypeArraySH::GetNamedItem(nsISupports *aNative, const nsAString& aName,
-                                nsISupports **aResult)
-{
-  nsCOMPtr<nsIDOMMimeTypeArray> array(do_QueryInterface(aNative));
-  NS_ENSURE_TRUE(array, NS_ERROR_UNEXPECTED);
-
-  nsIDOMMimeType *mime_type = nsnull;
-
-  nsresult rv = array->NamedItem(aName, &mime_type);
-
-  *aResult = mime_type;
-
-  return rv;
+                                nsresult *aResult)
+{
+  nsMimeTypeArray* array = nsMimeTypeArray::FromSupports(aNative);
+
+  return array->GetNamedItem(aName, aResult);
 }
 
 
 // StringArray helper
 
 NS_IMETHODIMP
 nsStringArraySH::GetProperty(nsIXPConnectWrappedNative *wrapper, JSContext *cx,
                              JSObject *obj, jsval id, jsval *vp,
@@ -10140,30 +10125,24 @@ nsTreeColumnsSH::GetItemAt(nsISupports *
 nsTreeColumnsSH::GetItemAt(nsISupports *aNative, PRUint32 aIndex,
                            nsresult *aResult)
 {
   nsTreeColumns* columns = nsTreeColumns::FromSupports(aNative);
 
   return columns->GetColumnAt(aIndex);
 }
 
-nsresult
+nsISupports*
 nsTreeColumnsSH::GetNamedItem(nsISupports *aNative,
                               const nsAString& aName,
-                              nsISupports **aResult)
-{
-  nsCOMPtr<nsITreeColumns> columns(do_QueryInterface(aNative));
-  NS_ENSURE_TRUE(columns, NS_ERROR_UNEXPECTED);
-
-  nsITreeColumn* column = nsnull; // Weak, transfer the ownership over to aResult
-  nsresult rv = columns->GetNamedColumn(aName, &column);
-
-  *aResult = column;
-
-  return rv;
+                              nsresult *aResult)
+{
+  nsTreeColumns* columns = nsTreeColumns::FromSupports(aNative);
+
+  return columns->GetNamedColumn(aName);
 }
 #endif
 
 
 // Storage scriptable helper
 
 // One reason we need a newResolve hook is that in order for
 // enumeration of storage object keys to work the keys we're
@@ -10219,30 +10198,23 @@ nsStorageSH::NewResolve(nsIXPConnectWrap
     }
 
     *objp = realObj;
   }
 
   return NS_OK;
 }
 
-nsresult
+nsISupports*
 nsStorageSH::GetNamedItem(nsISupports *aNative, const nsAString& aName,
-                          nsISupports **aResult)
-{
-  nsCOMPtr<nsIDOMStorage> storage(do_QueryInterface(aNative));
-  NS_ENSURE_TRUE(storage, NS_ERROR_UNEXPECTED);
-
-  // Weak, transfer the ownership over to aResult
-  nsIDOMStorageItem* item = nsnull;
-  nsresult rv = storage->GetItem(aName, &item);
-
-  *aResult = item;
-
-  return rv;
+                          nsresult *aResult)
+{
+  nsDOMStorage* storage = nsDOMStorage::FromSupports(aNative);
+
+  return storage->GetNamedItem(aName, aResult);
 }
 
 NS_IMETHODIMP
 nsStorageSH::SetProperty(nsIXPConnectWrappedNative *wrapper,
                          JSContext *cx, JSObject *obj, jsval id,
                          jsval *vp, PRBool *_retval)
 {
   nsCOMPtr<nsIDOMStorage> storage(do_QueryWrappedNative(wrapper));
@@ -10337,30 +10309,23 @@ nsStorageSH::NewEnumerate(nsIXPConnectWr
   }
 
   return NS_OK;
 }
 
 
 // StorageList scriptable helper
 
-nsresult
+nsISupports*
 nsStorageListSH::GetNamedItem(nsISupports *aNative, const nsAString& aName,
-                              nsISupports **aResult)
-{
-  nsCOMPtr<nsIDOMStorageList> storagelist(do_QueryInterface(aNative));
-  NS_ENSURE_TRUE(storagelist, NS_ERROR_UNEXPECTED);
-
-  // Weak, transfer the ownership over to aResult
-  nsIDOMStorage* storage = nsnull;
-  nsresult rv = storagelist->NamedItem(aName, &storage);
-
-  *aResult = storage;
-
-  return rv;
+                              nsresult *aResult)
+{
+  nsDOMStorageList* storagelist = static_cast<nsDOMStorageList*>(aNative);
+
+  return storagelist->GetNamedItem(aName, aResult);
 }
 
 
 // nsIDOMEventListener::HandleEvent() 'this' converter helper
 
 NS_INTERFACE_MAP_BEGIN(nsEventListenerThisTranslator)
   NS_INTERFACE_MAP_ENTRY(nsIXPCFunctionThisTranslator)
   NS_INTERFACE_MAP_ENTRY(nsISupports)
diff -r a131999fa900 dom/src/base/nsDOMClassInfo.h
--- a/dom/src/base/nsDOMClassInfo.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/dom/src/base/nsDOMClassInfo.h	Sat Nov 01 13:47:50 2008 +0200
@@ -688,18 +688,19 @@ protected:
   nsNamedArraySH(nsDOMClassInfoData* aData) : nsArraySH(aData)
   {
   }
 
   virtual ~nsNamedArraySH()
   {
   }
 
-  virtual nsresult GetNamedItem(nsISupports *aNative, const nsAString& aName,
-                                nsISupports **aResult) = 0;
+  virtual nsISupports* GetNamedItem(nsISupports *aNative,
+                                    const nsAString& aName,
+                                    nsresult *aResult) = 0;
 
 public:
   NS_IMETHOD GetProperty(nsIXPConnectWrappedNative *wrapper, JSContext *cx,
                          JSObject *obj, jsval id, jsval *vp, PRBool *_retval);
 
 private:
   // Not implemented, nothing should create an instance of this class.
   static nsIClassInfo *doCreate(nsDOMClassInfoData* aData);
@@ -718,18 +719,19 @@ protected:
   virtual ~nsNamedNodeMapSH()
   {
   }
 
   virtual nsISupports* GetItemAt(nsISupports *aNative, PRUint32 aIndex,
                                  nsresult *aResult);
 
   // Override nsNamedArraySH::GetNamedItem()
-  virtual nsresult GetNamedItem(nsISupports *aNative, const nsAString& aName,
-                                nsISupports **aResult);
+  virtual nsISupports* GetNamedItem(nsISupports *aNative,
+                                    const nsAString& aName,
+                                    nsresult *aResult);
 
 public:
   static nsIClassInfo *doCreate(nsDOMClassInfoData* aData)
   {
     return new nsNamedNodeMapSH(aData);
   }
 };
 
@@ -742,78 +744,61 @@ protected:
   nsHTMLCollectionSH(nsDOMClassInfoData* aData) : nsNamedArraySH(aData)
   {
   }
 
   virtual ~nsHTMLCollectionSH()
   {
   }
 
+  virtual nsresult GetLength(nsIXPConnectWrappedNative *wrapper, JSContext *cx,
+                             JSObject *obj, PRUint32 *length);
   virtual nsISupports* GetItemAt(nsISupports *aNative, PRUint32 aIndex,
                                  nsresult *aResult);
 
   // Override nsNamedArraySH::GetNamedItem()
-  virtual nsresult GetNamedItem(nsISupports *aNative, const nsAString& aName,
-                                nsISupports **aResult);
+  virtual nsISupports* GetNamedItem(nsISupports *aNative,
+                                    const nsAString& aName,
+                                    nsresult *aResult);
 
 public:
   static nsIClassInfo *doCreate(nsDOMClassInfoData* aData)
   {
     return new nsHTMLCollectionSH(aData);
   }
 };
 
 
 // ContentList helper
 
-class nsContentListSH : public nsNodeListSH
+class nsContentListSH : public nsNamedArraySH
 {
 protected:
-  nsContentListSH(nsDOMClassInfoData* aData) : nsNodeListSH(aData)
+  nsContentListSH(nsDOMClassInfoData* aData) : nsNamedArraySH(aData)
   {
   }
 
 public:
   NS_IMETHOD PreCreate(nsISupports *nativeObj, JSContext *cx,
                        JSObject *globalObj, JSObject **parentObj);
-  NS_IMETHOD GetProperty(nsIXPConnectWrappedNative *wrapper, JSContext *cx,
-                         JSObject *obj, jsval id, jsval *vp, PRBool *_retval);
+
+  virtual nsresult GetLength(nsIXPConnectWrappedNative *wrapper, JSContext *cx,
+                             JSObject *obj, PRUint32 *length);
+  virtual nsISupports* GetItemAt(nsISupports *aNative, PRUint32 aIndex,
+                                 nsresult *aResult);
+  virtual nsISupports* GetNamedItem(nsISupports *aNative,
+                                    const nsAString& aName,
+                                    nsresult *aResult);
 
   static nsIClassInfo *doCreate(nsDOMClassInfoData* aData)
   {
     return new nsContentListSH(aData);
   }
 };
 
-
-
-// FomrControlList helper
-
-class nsFormControlListSH : public nsHTMLCollectionSH
-{
-protected:
-  nsFormControlListSH(nsDOMClassInfoData* aData) : nsHTMLCollectionSH(aData)
-  {
-  }
-
-  virtual ~nsFormControlListSH()
-  {
-  }
-
-  // Override nsNamedArraySH::GetNamedItem() since our NamedItem() can
-  // return either a nsIDOMNode or a nsIHTMLCollection
-  virtual nsresult GetNamedItem(nsISupports *aNative, const nsAString& aName,
-                                nsISupports **aResult);
-
-public:
-  static nsIClassInfo *doCreate(nsDOMClassInfoData* aData)
-  {
-    return new nsFormControlListSH(aData);
-  }
-};
 
 
 // Document helper, for document.location and document.on*
 
 class nsDocumentSH : public nsNodeSH
 {
 public:
   nsDocumentSH(nsDOMClassInfoData* aData) : nsNodeSH(aData)
@@ -1090,18 +1075,19 @@ protected:
   virtual ~nsPluginSH()
   {
   }
 
   virtual nsISupports* GetItemAt(nsISupports *aNative, PRUint32 aIndex,
                                  nsresult *aResult);
 
   // Override nsNamedArraySH::GetNamedItem()
-  virtual nsresult GetNamedItem(nsISupports *aNative, const nsAString& aName,
-                                nsISupports **aResult);
+  virtual nsISupports* GetNamedItem(nsISupports *aNative,
+                                    const nsAString& aName,
+                                    nsresult *aResult);
 
 public:
   static nsIClassInfo *doCreate(nsDOMClassInfoData* aData)
   {
     return new nsPluginSH(aData);
   }
 };
 
@@ -1118,18 +1104,19 @@ protected:
   virtual ~nsPluginArraySH()
   {
   }
 
   virtual nsISupports* GetItemAt(nsISupports *aNative, PRUint32 aIndex,
                                  nsresult *aResult);
 
   // Override nsNamedArraySH::GetNamedItem()
-  virtual nsresult GetNamedItem(nsISupports *aNative, const nsAString& aName,
-                                nsISupports **aResult);
+  virtual nsISupports* GetNamedItem(nsISupports *aNative,
+                                    const nsAString& aName,
+                                    nsresult *aResult);
 
 public:
   static nsIClassInfo *doCreate(nsDOMClassInfoData* aData)
   {
     return new nsPluginArraySH(aData);
   }
 };
 
@@ -1146,18 +1133,19 @@ protected:
   virtual ~nsMimeTypeArraySH()
   {
   }
 
   virtual nsISupports* GetItemAt(nsISupports *aNative, PRUint32 aIndex,
                                  nsresult *aResult);
 
   // Override nsNamedArraySH::GetNamedItem()
-  virtual nsresult GetNamedItem(nsISupports *aNative, const nsAString& aName,
-                                nsISupports **aResult);
+  virtual nsISupports* GetNamedItem(nsISupports *aNative,
+                                    const nsAString& aName,
+                                    nsresult *aResult);
 
 public:
   static nsIClassInfo *doCreate(nsDOMClassInfoData* aData)
   {
     return new nsMimeTypeArraySH(aData);
   }
 };
 
@@ -1392,18 +1380,19 @@ protected:
   virtual ~nsTreeColumnsSH()
   {
   }
 
   virtual nsISupports* GetItemAt(nsISupports *aNative, PRUint32 aIndex,
                                  nsresult *aResult);
 
   // Override nsNamedArraySH::GetNamedItem()
-  virtual nsresult GetNamedItem(nsISupports *aNative, const nsAString& aName,
-                                nsISupports **aResult);
+  virtual nsISupports* GetNamedItem(nsISupports *aNative,
+                                    const nsAString& aName,
+                                    nsresult *aResult);
 
 public:
   static nsIClassInfo *doCreate(nsDOMClassInfoData* aData)
   {
     return new nsTreeColumnsSH(aData);
   }
 };
 #endif
@@ -1433,18 +1422,19 @@ protected:
                           jsid *idp, PRBool *_retval);
 
   virtual nsISupports* GetItemAt(nsISupports *aNative, PRUint32 aIndex,
                                  nsresult *aResult)
   {
     return nsnull;
   }
   // Override nsNamedArraySH::GetNamedItem()
-  virtual nsresult GetNamedItem(nsISupports *aNative, const nsAString& aName,
-                                nsISupports **aResult);
+  virtual nsISupports* GetNamedItem(nsISupports *aNative,
+                                    const nsAString& aName,
+                                    nsresult *aResult);
 
 public:
   static nsIClassInfo *doCreate(nsDOMClassInfoData* aData)
   {
     return new nsStorageSH(aData);
   }
 };
 
@@ -1460,18 +1450,19 @@ protected:
   }
 
   virtual nsISupports* GetItemAt(nsISupports *aNative, PRUint32 aIndex,
                                  nsresult *aResult)
   {
     return nsnull;
   }
   // Override nsNamedArraySH::GetNamedItem()
-  virtual nsresult GetNamedItem(nsISupports *aNative, const nsAString& aName,
-                                nsISupports **aResult);
+  virtual nsISupports* GetNamedItem(nsISupports *aNative,
+                                    const nsAString& aName,
+                                    nsresult *aResult);
 
 public:
   static nsIClassInfo *doCreate(nsDOMClassInfoData* aData)
   {
     return new nsStorageListSH(aData);
   }
 };
 
diff -r a131999fa900 dom/src/base/nsJSEnvironment.cpp
--- a/dom/src/base/nsJSEnvironment.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/dom/src/base/nsJSEnvironment.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -1167,22 +1167,16 @@ nsJSContext::JSOptionChangedCallback(con
 
   nsIScriptGlobalObject *global = context->GetGlobalObject();
   // XXX should we check for sysprin instead of a chrome window, to make
   // XXX components be covered by the chrome pref instead of the content one?
   nsCOMPtr<nsIDOMChromeWindow> chromeWindow(do_QueryInterface(global));
   PRBool useJIT = nsContentUtils::GetBoolPref(chromeWindow ?
                                               js_jit_chrome_str :
                                               js_jit_content_str);
-
-#ifdef MOZ_JSDEBUGGER
-  if (context->mContext->debugHooks->debuggerHandler)
-    useJIT = PR_FALSE;
-#endif
-
   if (useJIT)
     newDefaultJSOptions |= JSOPTION_JIT;
   else
     newDefaultJSOptions &= ~JSOPTION_JIT;
 
 #ifdef DEBUG
   // In debug builds, warnings are always enabled in chrome context
   // Note this callback is also called from context's InitClasses thus we don't
diff -r a131999fa900 dom/src/base/nsMimeTypeArray.cpp
--- a/dom/src/base/nsMimeTypeArray.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/dom/src/base/nsMimeTypeArray.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -44,20 +44,20 @@
 #include "nsIDOMPlugin.h"
 #include "nsDOMClassInfo.h"
 #include "nsIMIMEService.h"
 #include "nsIMIMEInfo.h"
 #include "nsIFile.h"
 
 
 nsMimeTypeArray::nsMimeTypeArray(nsIDOMNavigator* navigator)
+  : mNavigator(navigator),
+    mPluginMimeTypeCount(0),
+    mInited(PR_FALSE)
 {
-  mNavigator = navigator;
-  mMimeTypeCount = 0;
-  mMimeTypeArray = nsnull;
 }
 
 nsMimeTypeArray::~nsMimeTypeArray()
 {
   Clear();
 }
 
 
@@ -71,35 +71,44 @@ NS_INTERFACE_MAP_END
 
 NS_IMPL_ADDREF(nsMimeTypeArray)
 NS_IMPL_RELEASE(nsMimeTypeArray)
 
 
 NS_IMETHODIMP
 nsMimeTypeArray::GetLength(PRUint32* aLength)
 {
-  if (mMimeTypeArray == nsnull) {
+  if (!mInited) {
     nsresult rv = GetMimeTypes();
     if (rv != NS_OK)
       return rv;
   }
-  *aLength = mMimeTypeCount;
+
+  NS_ASSERTION(mPluginMimeTypeCount <= mMimeTypeArray.Count(),
+               "The number of total mimetypes should be equal to or higher "
+               "than the number of plugin mimetypes.");
+ 
+  *aLength = mPluginMimeTypeCount;
   return NS_OK;
 }
 
 nsIDOMMimeType*
 nsMimeTypeArray::GetItemAt(PRUint32 aIndex, nsresult *aResult)
 {
-  if (mMimeTypeArray == nsnull) {
+  if (!mInited) {
     *aResult = GetMimeTypes();
     if (*aResult != NS_OK)
       return nsnull;
   }
 
-  if (aIndex >= mMimeTypeCount) {
+  NS_ASSERTION(mPluginMimeTypeCount <= mMimeTypeArray.Count(),
+               "The number of total mimetypes should be equal to or higher "
+               "than the number of plugin mimetypes.");
+
+  if (aIndex >= mPluginMimeTypeCount) {
     *aResult = NS_ERROR_FAILURE;
 
     return nsnull;
   }
 
   *aResult = NS_OK;
 
   return mMimeTypeArray[aIndex];
@@ -110,41 +119,40 @@ nsMimeTypeArray::Item(PRUint32 aIndex, n
 {
   nsresult rv;
 
   NS_IF_ADDREF(*aReturn = GetItemAt(aIndex, &rv));
 
   return rv;
 }
 
-NS_IMETHODIMP
-nsMimeTypeArray::NamedItem(const nsAString& aName, nsIDOMMimeType** aReturn)
+nsIDOMMimeType*
+nsMimeTypeArray::GetNamedItem(const nsAString& aName, nsresult* aResult)
 {
-  NS_ENSURE_ARG_POINTER(aReturn);
-  *aReturn = nsnull;
+  if (!mInited) {
+    *aResult = GetMimeTypes();
+    if (*aResult != NS_OK)
+      return nsnull;
+  }
 
-  if (mMimeTypeArray == nsnull) {
-    nsresult rv = GetMimeTypes();
-    if (rv != NS_OK)
-      return rv;
-  }
+  NS_ASSERTION(mPluginMimeTypeCount <= mMimeTypeArray.Count(),
+               "The number of total mimetypes should be equal to or higher "
+               "than the number of plugin mimetypes.");
+
+  *aResult = NS_OK;
 
   nsAutoString type;
 
-  for (PRUint32 i = 0; i < mMimeTypeCount; i++) {
+  for (PRInt32 i = 0; i < mMimeTypeArray.Count(); i++) {
     nsIDOMMimeType *mtype = mMimeTypeArray[i];
 
     mtype->GetType(type);
 
     if (type.Equals(aName)) {
-      *aReturn = mtype;
-
-      NS_ADDREF(*aReturn);
-
-      return NS_OK;
+      return mtype;
     }
   }
 
   // Now let's check with the MIME service.
   nsCOMPtr<nsIMIMEService> mimeSrv = do_GetService("@mozilla.org/mime;1");
   if (mimeSrv) {
     nsCOMPtr<nsIMIMEInfo> mimeInfo;
     mimeSrv->GetFromTypeAndExtension(NS_ConvertUTF16toUTF8(aName), EmptyCString(),
@@ -161,94 +169,99 @@ nsMimeTypeArray::NamedItem(const nsAStri
           mimeInfo->GetPreferredApplicationHandler(getter_AddRefs(helper));
           if (!helper) {
             // mime info from the OS may not have a PreferredApplicationHandler
             // so just check for an empty default description
             nsAutoString defaultDescription;
             mimeInfo->GetDefaultDescription(defaultDescription);
             if (defaultDescription.IsEmpty()) {
               // no support; just leave
-              return NS_OK;
+              return nsnull;
             }
           }
         }
       }
 
       // If we got here, we support this type!  Say so.
-      nsCOMPtr<nsIDOMMimeType> helper = new nsHelperMimeType(aName);
-      if (!helper) {
-        return NS_ERROR_OUT_OF_MEMORY;
-      }
-      nsCOMPtr<nsIDOMMimeType> entry = new nsMimeType(nsnull, helper);
-      if (!entry) {
-        return NS_ERROR_OUT_OF_MEMORY;
+      nsCOMPtr<nsIDOMMimeType> helper, entry;
+      if (!(helper = new nsHelperMimeType(aName)) ||
+          !(entry = new nsMimeType(nsnull, helper)) ||
+          !mMimeTypeArray.AppendObject(entry)) {
+        *aResult = NS_ERROR_OUT_OF_MEMORY;
+
+        return nsnull;
       }
 
-      entry.swap(*aReturn);
+      return entry;
     }
   }
 
-  return NS_OK;
+  return nsnull;
+}
+
+NS_IMETHODIMP
+nsMimeTypeArray::NamedItem(const nsAString& aName, nsIDOMMimeType** aReturn)
+{
+  nsresult rv;
+
+  NS_IF_ADDREF(*aReturn = GetNamedItem(aName, &rv));
+
+  return rv;
 }
 
 void  nsMimeTypeArray::Clear()
 {
-  if (mMimeTypeArray != nsnull) {
-    for (PRUint32 i = 0; i < mMimeTypeCount; i++) {
-      NS_IF_RELEASE(mMimeTypeArray[i]);
-    }
-    delete[] mMimeTypeArray;
-    mMimeTypeArray = nsnull;
-  }
-  mMimeTypeCount = 0;
+  mMimeTypeArray.Clear();
+  mPluginMimeTypeCount = 0;
 }
 
 nsresult nsMimeTypeArray::Refresh()
 {
   Clear();
   return GetMimeTypes();
 }
 
 nsresult nsMimeTypeArray::GetMimeTypes()
 {
-  NS_PRECONDITION(!mMimeTypeArray && mMimeTypeCount==0,
+  NS_PRECONDITION(!mInited && mPluginMimeTypeCount==0,
                       "already initialized");
 
   nsIDOMPluginArray* pluginArray = nsnull;
   nsresult rv = mNavigator->GetPlugins(&pluginArray);
   if (rv == NS_OK) {
     // count up all possible MimeTypes, and collect them here. Later,
     // we'll remove duplicates.
-    mMimeTypeCount = 0;
+    mPluginMimeTypeCount = 0;
     PRUint32 pluginCount = 0;
     rv = pluginArray->GetLength(&pluginCount);
     if (rv == NS_OK) {
       PRUint32 i;
       for (i = 0; i < pluginCount; i++) {
         nsCOMPtr<nsIDOMPlugin> plugin;
         if (NS_SUCCEEDED(pluginArray->Item(i, getter_AddRefs(plugin))) &&
             plugin) {
           PRUint32 mimeTypeCount = 0;
           if (plugin->GetLength(&mimeTypeCount) == NS_OK)
-            mMimeTypeCount += mimeTypeCount;
+            mPluginMimeTypeCount += mimeTypeCount;
         }
       }
       // now we know how many there are, start gathering them.
-      mMimeTypeArray = new nsIDOMMimeType*[mMimeTypeCount];
-      if (mMimeTypeArray == nsnull)
+      if (!mMimeTypeArray.SetCapacity(mPluginMimeTypeCount))
         return NS_ERROR_OUT_OF_MEMORY;
-      PRUint32 mimeTypeIndex = 0;
       PRUint32 k;
       for (k = 0; k < pluginCount; k++) {
         nsIDOMPlugin* plugin = nsnull;
         if (pluginArray->Item(k, &plugin) == NS_OK) {
           PRUint32 mimeTypeCount = 0;
           if (plugin->GetLength(&mimeTypeCount) == NS_OK) {
-            for (PRUint32 j = 0; j < mimeTypeCount; j++)
-              plugin->Item(j, &mMimeTypeArray[mimeTypeIndex++]);
+            nsCOMPtr<nsIDOMMimeType> item;
+            for (PRUint32 j = 0; j < mimeTypeCount; j++) {
+              plugin->Item(j, getter_AddRefs(item));
+              mMimeTypeArray.AppendObject(item);
+            }
           }
           NS_RELEASE(plugin);
         }
       }
     }
     NS_RELEASE(pluginArray);
   }
   return rv;
diff -r a131999fa900 dom/src/base/nsMimeTypeArray.h
--- a/dom/src/base/nsMimeTypeArray.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/dom/src/base/nsMimeTypeArray.h	Sat Nov 01 13:47:50 2008 +0200
@@ -37,31 +37,33 @@
 
 #ifndef nsMimeTypeArray_h___
 #define nsMimeTypeArray_h___
 
 #include "nsIDOMMimeTypeArray.h"
 #include "nsIDOMMimeType.h"
 #include "nsString.h"
 #include "nsCOMPtr.h"
+#include "nsCOMArray.h"
 
 class nsIDOMNavigator;
 
 class nsMimeTypeArray : public nsIDOMMimeTypeArray
 {
 public:
   nsMimeTypeArray(nsIDOMNavigator* navigator);
   virtual ~nsMimeTypeArray();
 
   NS_DECL_ISUPPORTS
   NS_DECL_NSIDOMMIMETYPEARRAY
 
   nsresult Refresh();
 
   nsIDOMMimeType* GetItemAt(PRUint32 aIndex, nsresult* aResult);
+  nsIDOMMimeType* GetNamedItem(const nsAString& aName, nsresult* aResult);
 
   static nsMimeTypeArray* FromSupports(nsISupports* aSupports)
   {
 #ifdef DEBUG
     {
       nsCOMPtr<nsIDOMMimeTypeArray> array_qi = do_QueryInterface(aSupports);
 
       // If this assertion fires the QI implementation for the object in
@@ -76,18 +78,24 @@ public:
   }
 
 private:
   nsresult GetMimeTypes();
   void     Clear();
 
 protected:
   nsIDOMNavigator* mNavigator;
-  PRUint32 mMimeTypeCount;
-  nsIDOMMimeType** mMimeTypeArray;
+  // Number of mimetypes handled by plugins.
+  PRUint32 mPluginMimeTypeCount;
+  // mMimeTypeArray contains all mimetypes handled by plugins
+  // (mPluginMimeTypeCount) and any mimetypes that we handle internally and
+  // have been looked up before. The number of items in mMimeTypeArray should
+  // thus always be equal to or higher than mPluginMimeTypeCount.
+  nsCOMArray<nsIDOMMimeType> mMimeTypeArray;
+  PRBool mInited;
 };
 
 class nsMimeType : public nsIDOMMimeType
 {
 public:
   nsMimeType(nsIDOMPlugin* aPlugin, nsIDOMMimeType* aMimeType);
   virtual ~nsMimeType();
 
diff -r a131999fa900 dom/src/base/nsPluginArray.cpp
--- a/dom/src/base/nsPluginArray.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/dom/src/base/nsPluginArray.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -127,44 +127,51 @@ nsPluginArray::Item(PRUint32 aIndex, nsI
 {
   nsresult rv;
 
   NS_IF_ADDREF(*aReturn = GetItemAt(aIndex, &rv));
 
   return rv;
 }
 
-NS_IMETHODIMP
-nsPluginArray::NamedItem(const nsAString& aName, nsIDOMPlugin** aReturn)
+nsIDOMPlugin*
+nsPluginArray::GetNamedItem(const nsAString& aName, nsresult* aResult)
 {
-  NS_PRECONDITION(nsnull != aReturn, "null arg");
-  *aReturn = nsnull;
+  *aResult = NS_OK;
 
   if (!AllowPlugins())
-    return NS_OK;
+    return nsnull;
 
   if (mPluginArray == nsnull) {
-    nsresult rv = GetPlugins();
-    if (rv != NS_OK)
-      return rv;
+    *aResult = GetPlugins();
+    if (*aResult != NS_OK)
+      return nsnull;
   }
 
   for (PRUint32 i = 0; i < mPluginCount; i++) {
     nsAutoString pluginName;
     nsIDOMPlugin* plugin = mPluginArray[i];
-    if (plugin->GetName(pluginName) == NS_OK) {
-      if (pluginName.Equals(aName)) {
-        *aReturn = plugin;
-        NS_IF_ADDREF(plugin);
-        break;
-      }
+    if (plugin->GetName(pluginName) == NS_OK && pluginName.Equals(aName)) {
+      return plugin;
     }
   }
 
-  return NS_OK;
+  return nsnull;
+}
+
+NS_IMETHODIMP
+nsPluginArray::NamedItem(const nsAString& aName, nsIDOMPlugin** aReturn)
+{
+  NS_PRECONDITION(nsnull != aReturn, "null arg");
+
+  nsresult rv;
+
+  NS_IF_ADDREF(*aReturn = GetNamedItem(aName, &rv));
+
+  return rv;
 }
 
 nsresult
 nsPluginArray::GetPluginHost(nsIPluginHost** aPluginHost)
 {
   NS_ENSURE_ARG_POINTER(aPluginHost);
 
   nsresult rv = NS_OK;
@@ -359,39 +366,45 @@ nsPluginElement::Item(PRUint32 aIndex, n
 {
   nsresult rv;
 
   NS_IF_ADDREF(*aReturn = GetItemAt(aIndex, &rv));
 
   return rv;
 }
 
+nsIDOMMimeType*
+nsPluginElement::GetNamedItem(const nsAString& aName, nsresult *aResult)
+{
+  if (mMimeTypeArray == nsnull) {
+    *aResult = GetMimeTypes();
+    if (*aResult != NS_OK)
+      return nsnull;
+  }
+
+  *aResult = NS_OK;
+  for (PRUint32 i = 0; i < mMimeTypeCount; i++) {
+    nsAutoString type;
+    nsIDOMMimeType* mimeType = mMimeTypeArray[i];
+    if (mimeType->GetType(type) == NS_OK && type.Equals(aName)) {
+      return mimeType;
+    }
+  }
+
+  return nsnull;
+}
+
 NS_IMETHODIMP
 nsPluginElement::NamedItem(const nsAString& aName, nsIDOMMimeType** aReturn)
 {
-  if (mMimeTypeArray == nsnull) {
-    nsresult rv = GetMimeTypes();
-    if (rv != NS_OK)
-      return rv;
-  }
+  nsresult rv;
 
-  *aReturn = nsnull;
-  for (PRUint32 i = 0; i < mMimeTypeCount; i++) {
-    nsAutoString type;
-    nsIDOMMimeType* mimeType = mMimeTypeArray[i];
-    if (mimeType->GetType(type) == NS_OK) {
-      if (type.Equals(aName)) {
-        *aReturn = mimeType;
-        NS_ADDREF(mimeType);
-        break;
-      }
-    }
-  }
+  NS_IF_ADDREF(*aReturn = GetNamedItem(aName, &rv));
 
-  return NS_OK;
+  return rv;
 }
 
 nsresult
 nsPluginElement::GetMimeTypes()
 {
   nsresult rv = mPlugin->GetLength(&mMimeTypeCount);
   if (rv == NS_OK) {
     mMimeTypeArray = new nsIDOMMimeType*[mMimeTypeCount];
diff -r a131999fa900 dom/src/base/nsPluginArray.h
--- a/dom/src/base/nsPluginArray.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/dom/src/base/nsPluginArray.h	Sat Nov 01 13:47:50 2008 +0200
@@ -56,16 +56,17 @@ public:
   NS_DECL_ISUPPORTS
 
   // nsIDOMPluginArray
   NS_DECL_NSIDOMPLUGINARRAY
 
   nsresult GetPluginHost(nsIPluginHost** aPluginHost);
 
   nsIDOMPlugin* GetItemAt(PRUint32 aIndex, nsresult* aResult);
+  nsIDOMPlugin* GetNamedItem(const nsAString& aName, nsresult* aResult);
 
   static nsPluginArray* FromSupports(nsISupports* aSupports)
   {
 #ifdef DEBUG
     {
       nsCOMPtr<nsIDOMPluginArray> array_qi = do_QueryInterface(aSupports);
 
       // If this assertion fires the QI implementation for the object in
@@ -99,16 +100,17 @@ public:
 public:
   nsPluginElement(nsIDOMPlugin* plugin);
   virtual ~nsPluginElement();
 
   NS_DECL_ISUPPORTS
   NS_DECL_NSIDOMPLUGIN
 
   nsIDOMMimeType* GetItemAt(PRUint32 aIndex, nsresult* aResult);
+  nsIDOMMimeType* GetNamedItem(const nsAString& aName, nsresult* aResult);
 
   static nsPluginElement* FromSupports(nsISupports* aSupports)
   {
 #ifdef DEBUG
     {
       nsCOMPtr<nsIDOMPlugin> plugin_qi = do_QueryInterface(aSupports);
 
       // If this assertion fires the QI implementation for the object in
diff -r a131999fa900 dom/src/storage/nsDOMStorage.cpp
--- a/dom/src/storage/nsDOMStorage.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/dom/src/storage/nsDOMStorage.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -601,58 +601,69 @@ nsDOMStorage::Key(PRUint32 aIndex, nsASt
     return NS_ERROR_DOM_INDEX_SIZE_ERR;
   }
 
   aKey = data.mItem->GetKey();
 
   return NS_OK;
 }
 
-NS_IMETHODIMP
-nsDOMStorage::GetItem(const nsAString& aKey, nsIDOMStorageItem **aItem)
+nsIDOMStorageItem*
+nsDOMStorage::GetNamedItem(const nsAString& aKey, nsresult* aResult)
 {
-  *aItem = nsnull;
+  if (!CacheStoragePermissions()) {
+    *aResult = NS_ERROR_DOM_SECURITY_ERR;
+    return nsnull;
+  }
 
-  if (!CacheStoragePermissions())
-    return NS_ERROR_DOM_SECURITY_ERR;
-
+  *aResult = NS_OK;
   if (aKey.IsEmpty())
-    return NS_OK;
+    return nsnull;
 
   nsSessionStorageEntry *entry = mItems.GetEntry(aKey);
- 
+  nsIDOMStorageItem* item = nsnull;
   if (entry) {
-    if (!IsCallerSecure() && entry->mItem->IsSecure()) {
-      return NS_OK;
+    if (IsCallerSecure() || !entry->mItem->IsSecure()) {
+      item = entry->mItem;
     }
-    NS_ADDREF(*aItem = entry->mItem);
   }
   else if (UseDB()) {
     PRBool secure;
     nsAutoString value;
     nsAutoString unused;
     nsresult rv = GetDBValue(aKey, value, &secure, unused);
     // return null if access isn't allowed or the key wasn't found
     if (rv == NS_ERROR_DOM_SECURITY_ERR || rv == NS_ERROR_DOM_NOT_FOUND_ERR)
-      return NS_OK;
-    NS_ENSURE_SUCCESS(rv, rv);
+      return nsnull;
+
+    *aResult = rv;
+    NS_ENSURE_SUCCESS(rv, nsnull);
 
     nsRefPtr<nsDOMStorageItem> newitem =
       new nsDOMStorageItem(this, aKey, value, secure);
-    if (!newitem)
-      return NS_ERROR_OUT_OF_MEMORY;
-
-    entry = mItems.PutEntry(aKey);
-    NS_ENSURE_TRUE(entry, NS_ERROR_OUT_OF_MEMORY);
-
-    entry->mItem = newitem;
-    NS_ADDREF(*aItem = newitem);
+    if (newitem && (entry = mItems.PutEntry(aKey))) {
+      item = entry->mItem = newitem;
+    }
+    else {
+      *aResult = NS_ERROR_OUT_OF_MEMORY;
+    }
   }
 
-  return NS_OK;
+  return item;
+}
+
+
+NS_IMETHODIMP
+nsDOMStorage::GetItem(const nsAString& aKey, nsIDOMStorageItem **aItem)
+{
+  nsresult rv;
+
+  NS_IF_ADDREF(*aItem = GetNamedItem(aKey, &rv));
+
+  return rv;
 }
 
 NS_IMETHODIMP
 nsDOMStorage::SetItem(const nsAString& aKey, const nsAString& aData)
 {
   if (!CacheStoragePermissions())
     return NS_ERROR_DOM_SECURITY_ERR;
 
@@ -1036,138 +1047,152 @@ NS_INTERFACE_MAP_BEGIN(nsDOMStorageList)
   NS_INTERFACE_MAP_ENTRY(nsISupports)
   NS_INTERFACE_MAP_ENTRY(nsIDOMStorageList)
   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(StorageList)
 NS_INTERFACE_MAP_END
 
 NS_IMPL_ADDREF(nsDOMStorageList)
 NS_IMPL_RELEASE(nsDOMStorageList)
 
-nsresult
-nsDOMStorageList::NamedItem(const nsAString& aDomain,
-                            nsIDOMStorage** aStorage)
+nsIDOMStorage*
+nsDOMStorageList::GetNamedItem(const nsAString& aDomain, nsresult* aResult)
 {
-  *aStorage = nsnull;
-
   nsCAutoString requestedDomain;
 
-  nsresult rv;
   // Normalize the requested domain
   nsCOMPtr<nsIIDNService> idn = do_GetService(NS_IDNSERVICE_CONTRACTID);
   if (idn) {
-    rv = idn->ConvertUTF8toACE(NS_ConvertUTF16toUTF8(aDomain),
-                               requestedDomain);
-    NS_ENSURE_SUCCESS(rv, rv);
+    *aResult = idn->ConvertUTF8toACE(NS_ConvertUTF16toUTF8(aDomain),
+                                     requestedDomain);
+    NS_ENSURE_SUCCESS(*aResult, nsnull);
   } else {
     // Don't have the IDN service, best we can do is URL escape.
     NS_EscapeURL(NS_ConvertUTF16toUTF8(aDomain),
                  esc_OnlyNonASCII | esc_AlwaysCopy,
                  requestedDomain);
   }
   ToLowerCase(requestedDomain);
 
   nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
-  if (!ssm)
-    return NS_ERROR_FAILURE;
+  if (!ssm) {
+    *aResult = NS_ERROR_FAILURE;
+    return nsnull;
+  }
 
   nsCOMPtr<nsIPrincipal> subjectPrincipal;
-  rv = ssm->GetSubjectPrincipal(getter_AddRefs(subjectPrincipal));
-  NS_ENSURE_SUCCESS(rv, rv);
+  *aResult = ssm->GetSubjectPrincipal(getter_AddRefs(subjectPrincipal));
+  NS_ENSURE_SUCCESS(*aResult, nsnull);
 
   nsCOMPtr<nsIURI> uri;
   nsCAutoString currentDomain;
   if (subjectPrincipal) {
-    rv = subjectPrincipal->GetDomain(getter_AddRefs(uri));
-    NS_ENSURE_SUCCESS(rv, rv);
+    *aResult = subjectPrincipal->GetDomain(getter_AddRefs(uri));
+    NS_ENSURE_SUCCESS(*aResult, nsnull);
 
     if (!uri) {
-      rv = subjectPrincipal->GetURI(getter_AddRefs(uri));
-      NS_ENSURE_SUCCESS(rv, rv);
+      *aResult = subjectPrincipal->GetURI(getter_AddRefs(uri));
+      NS_ENSURE_SUCCESS(*aResult, nsnull);
     }
 
     if (uri) {
       PRPackedBool sessionOnly;
-      if (!nsDOMStorage::CanUseStorage(uri, &sessionOnly))
-        return NS_ERROR_DOM_SECURITY_ERR;
+      if (!nsDOMStorage::CanUseStorage(uri, &sessionOnly)) {
+        *aResult = NS_ERROR_DOM_SECURITY_ERR;
+        return nsnull;
+      }
 
       nsCOMPtr<nsIURI> innerUri = NS_GetInnermostURI(uri);
-      if (!innerUri)
-        return NS_ERROR_UNEXPECTED;
+      if (!innerUri) {
+        *aResult = NS_ERROR_UNEXPECTED;
+        return nsnull;
+      }
 
       uri = innerUri;
-      rv = uri->GetAsciiHost(currentDomain);
-      NS_ENSURE_SUCCESS(rv, NS_ERROR_DOM_SECURITY_ERR);
+      nsresult rv = uri->GetAsciiHost(currentDomain);
+      if (NS_FAILED(rv)) {
+        *aResult = NS_ERROR_DOM_SECURITY_ERR;
+        return nsnull;
+      }
     }
   }
 
   PRBool isSystem;
-  rv = ssm->SubjectPrincipalIsSystem(&isSystem);
-  NS_ENSURE_SUCCESS(rv, rv);
+  *aResult = ssm->SubjectPrincipalIsSystem(&isSystem);
+  NS_ENSURE_SUCCESS(*aResult, nsnull);
 
   // allow code that has read privileges to get the storage for any domain
   if (!isSystem && nsContentUtils::IsCallerTrustedForRead())
     isSystem = PR_TRUE;
 
   if (isSystem || !currentDomain.IsEmpty()) {
     return GetStorageForDomain(uri, NS_ConvertUTF8toUTF16(requestedDomain),
                                NS_ConvertUTF8toUTF16(currentDomain),
-                               isSystem, aStorage);
+                               isSystem, aResult);
   }
 
-  return NS_ERROR_DOM_SECURITY_ERR;
+  *aResult = NS_ERROR_DOM_SECURITY_ERR;
+  return nsnull;
+}
+
+NS_IMETHODIMP
+nsDOMStorageList::NamedItem(const nsAString& aDomain,
+                            nsIDOMStorage** aStorage)
+{
+  nsresult rv;
+  NS_IF_ADDREF(*aStorage = GetNamedItem(aDomain, &rv));
+  return rv;
 }
 
 // static
 PRBool
 nsDOMStorageList::CanAccessDomain(const nsAString& aRequestedDomain,
                                   const nsAString& aCurrentDomain)
 {
   return aRequestedDomain.Equals(aCurrentDomain);
 }
 
-nsresult
+nsIDOMStorage*
 nsDOMStorageList::GetStorageForDomain(nsIURI* aURI,
                                       const nsAString& aRequestedDomain,
                                       const nsAString& aCurrentDomain,
                                       PRBool aNoCurrentDomainCheck,
-                                      nsIDOMStorage** aStorage)
+                                      nsresult* aResult)
 {
-  if (!aNoCurrentDomainCheck && !CanAccessDomain(aRequestedDomain,
-                                                 aCurrentDomain)) {
-    return NS_ERROR_DOM_SECURITY_ERR;
+  nsStringArray requestedDomainArray;
+  if ((!aNoCurrentDomainCheck &&
+       !CanAccessDomain(aRequestedDomain, aCurrentDomain)) ||
+      !ConvertDomainToArray(aRequestedDomain, &requestedDomainArray)) {
+    *aResult = NS_ERROR_DOM_SECURITY_ERR;
+
+    return nsnull;
   }
 
-  nsStringArray requestedDomainArray;
-  PRBool ok = ConvertDomainToArray(aRequestedDomain, &requestedDomainArray);
-  if (!ok)
-    return NS_ERROR_DOM_SECURITY_ERR;
-  
   // now rebuild a string for the domain.
   nsAutoString usedDomain;
   PRInt32 requestedPos = 0;
   for (requestedPos = 0; requestedPos < requestedDomainArray.Count();
        requestedPos++) {
     if (!usedDomain.IsEmpty())
       usedDomain.AppendLiteral(".");
     usedDomain.Append(*requestedDomainArray[requestedPos]);
   }
 
+  *aResult = NS_OK;
+
   // now have a valid domain, so look it up in the storage table
-  if (!mStorages.Get(usedDomain, aStorage)) {
+  nsIDOMStorage* storage = mStorages.GetWeak(usedDomain);
+  if (!storage) {
     nsCOMPtr<nsIDOMStorage> newstorage = new nsDOMStorage(aURI, usedDomain, PR_TRUE);
-    if (!newstorage)
-      return NS_ERROR_OUT_OF_MEMORY;
-
-    if (!mStorages.Put(usedDomain, newstorage))
-      return NS_ERROR_OUT_OF_MEMORY;
-
-    newstorage.swap(*aStorage);
+    if (newstorage && mStorages.Put(usedDomain, newstorage))
+      storage = newstorage;
+    else
+      *aResult = NS_ERROR_OUT_OF_MEMORY;
   }
 
-  return NS_OK;
+  return storage;
 }
 
 // static
 PRBool
 nsDOMStorageList::ConvertDomainToArray(const nsAString& aDomain,
                                        nsStringArray* aArray)
 {
   PRInt32 length = aDomain.Length();
diff -r a131999fa900 dom/src/storage/nsDOMStorage.h
--- a/dom/src/storage/nsDOMStorage.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/dom/src/storage/nsDOMStorage.h	Sat Nov 01 13:47:50 2008 +0200
@@ -162,16 +162,23 @@ public:
 
   // set the value corresponding to a key as secure.
   nsresult
   SetSecure(const nsAString& aKey, PRBool aSecure);
 
   // clear all values from the store
   void ClearAll();
 
+  nsIDOMStorageItem* GetNamedItem(const nsAString& aKey, nsresult* aResult);
+
+  static nsDOMStorage* FromSupports(nsISupports* aSupports)
+  {
+    return static_cast<nsDOMStorage*>(static_cast<nsIDOMStorage*>(aSupports));
+  }
+
 protected:
 
   friend class nsDOMStorageManager;
 
   static nsresult InitDB();
 
   // cache the keys from the database for faster lookup
   nsresult CacheKeysFromDB();
@@ -212,16 +219,18 @@ public:
   virtual ~nsDOMStorageList() {}
 
   // nsISupports
   NS_DECL_ISUPPORTS
 
   // nsIDOMStorageList
   NS_DECL_NSIDOMSTORAGELIST
 
+  nsIDOMStorage* GetNamedItem(const nsAString& aDomain, nsresult* aResult);
+
   /**
    * Check whether aCurrentDomain has access to aRequestedDomain
    */
   static PRBool
   CanAccessDomain(const nsAString& aRequestedDomain,
                   const nsAString& aCurrentDomain);
 
 protected:
@@ -231,22 +240,22 @@ protected:
    * aNoCurrentDomainCheck may be true to skip the domain comparison;
    * this is used for chrome code so that it may retrieve data from
    * any domain.
    *
    * @param aRequestedDomain domain to return
    * @param aCurrentDomain domain of current caller
    * @param aNoCurrentDomainCheck true to skip domain comparison
    */
-  nsresult
+  nsIDOMStorage*
   GetStorageForDomain(nsIURI* aURI,
                       const nsAString& aRequestedDomain,
                       const nsAString& aCurrentDomain,
                       PRBool aNoCurrentDomainCheck,
-                      nsIDOMStorage** aStorage);
+                      nsresult* aResult);
 
   /**
    * Convert the domain into an array of its component parts.
    */
   static PRBool
   ConvertDomainToArray(const nsAString& aDomain,
                        nsStringArray* aArray);
 
diff -r a131999fa900 editor/libeditor/html/nsHTMLEditRules.cpp
--- a/editor/libeditor/html/nsHTMLEditRules.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/editor/libeditor/html/nsHTMLEditRules.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -544,23 +544,16 @@ nsHTMLEditRules::AfterEditInner(PRInt32 
       mHTMLEditor->mTypeInState->UpdateSelState(selection);
       res = ReapplyCachedStyles();
       if (NS_FAILED(res)) return res;
       res = ClearCachedStyles();
       if (NS_FAILED(res)) return res;
     }    
   }
 
-  // Ensure range offsets are up to date.
-  if (mDocChangeRange) {
-    mDocChangeRange->GetStartContainer(getter_AddRefs(rangeStartParent));
-    mDocChangeRange->GetEndContainer(getter_AddRefs(rangeEndParent));
-    mDocChangeRange->GetStartOffset(&rangeStartOffset);
-    mDocChangeRange->GetEndOffset(&rangeEndOffset);
-  }
   res = mHTMLEditor->HandleInlineSpellCheck(action, selection, 
                                             mRangeItem.startNode, mRangeItem.startOffset,
                                             rangeStartParent, rangeStartOffset,
                                             rangeEndParent, rangeEndOffset);
   if (NS_FAILED(res)) 
     return res;
 
   // detect empty doc
diff -r a131999fa900 editor/libeditor/html/tests/Makefile.in
--- a/editor/libeditor/html/tests/Makefile.in	Thu Oct 30 23:42:02 2008 -0700
+++ b/editor/libeditor/html/tests/Makefile.in	Sat Nov 01 13:47:50 2008 +0200
@@ -40,14 +40,15 @@ srcdir		= @srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 relativesrcdir  = editor/libeditor/html/tests
 
 include $(DEPTH)/config/autoconf.mk
 include $(topsrcdir)/config/rules.mk
 
 _TEST_FILES = \
+		test_bug432225.html \
 		test_bug456244.html \
 		$(NULL)
 
 libs:: $(_TEST_FILES)
 	$(INSTALL) $(foreach f,$^,"$f") $(DEPTH)/_tests/testing/mochitest/tests/$(relativesrcdir)
 
diff -r a131999fa900 editor/libeditor/html/tests/test_bug432225.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/editor/libeditor/html/tests/test_bug432225.html	Sat Nov 01 13:47:50 2008 +0200
@@ -0,0 +1,96 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=432225
+-->
+<head>
+  <title>Test for Bug 432225</title>
+  <script type="application/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
+  <script type="text/javascript" src="/tests/SimpleTest/EventUtils.js"></script>  
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=432225">Mozilla Bug 432225</a>
+<p id="display"></p>
+<div id="content" style="display: none">
+  
+</div>
+<pre id="test">
+<script type="application/javascript">
+
+/** Test for Bug 432225 **/
+
+SimpleTest.waitForExplicitFinish();
+addLoadEvent(runTest);
+
+var gMisspeltWords = [];
+
+function getEdit() {
+  return document.getElementById('edit');
+}
+
+function editDoc() {
+  return getEdit().contentDocument;
+}
+
+function getSpellCheckSelection() {
+  var Ci = Components.interfaces;
+  var win = editDoc().defaultView;
+  var editingSession = win.QueryInterface(Ci.nsIInterfaceRequestor)
+                          .getInterface(Ci.nsIWebNavigation)
+                          .QueryInterface(Ci.nsIInterfaceRequestor)
+                          .getInterface(Ci.nsIEditingSession);
+  var editor = editingSession.getEditorForWindow(win);
+  var selcon = editor.selectionController;
+  return selcon.getSelection(selcon.SELECTION_SPELLCHECK);  
+}
+
+function runTest() {
+  editDoc().designMode = "on";
+  setTimeout(function() { addWords(100); }, 0);
+}  
+ 
+function addWords(aLimit) {
+  netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
+  if (aLimit == 0) {
+    is(isSpellingCheckOk(), true, "All misspellings accounted for.");
+    SimpleTest.finish();
+    return;
+  }
+  getEdit().focus();
+  sendChar('a', editDoc());
+  sendChar('a', editDoc());
+  sendChar(' ', editDoc());
+  sendChar('O', editDoc());
+  sendChar('K', editDoc());
+  sendChar(' ', editDoc());
+  gMisspeltWords.push("aa");
+  setTimeout(function() { addWords(aLimit-1); }, 0);
+}
+
+function isSpellingCheckOk() {
+  var sel = getSpellCheckSelection();
+  var numWords = sel.rangeCount;
+  
+  is(numWords, gMisspeltWords.length, "Correct number of misspellings and words.");
+  
+  if (numWords != gMisspeltWords.length) 
+    return false;
+  
+  for (var i=0; i<numWords; i++) {
+    var word = sel.getRangeAt(i);
+    is (word, gMisspeltWords[i], "Misspelling is what we think it is.");
+    if (word != gMisspeltWords[i])
+      return false;
+  }
+  return true;
+}
+
+</script>
+</pre>
+
+<iframe id="edit" width="200" height="100" src="about:blank"></iframe>
+
+</body>
+</html>
diff -r a131999fa900 extensions/universalchardet/src/base/CharDistribution.cpp
--- a/extensions/universalchardet/src/base/CharDistribution.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/extensions/universalchardet/src/base/CharDistribution.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -44,22 +44,23 @@
 #include "GB2312Freq.tab"
 
 #define SURE_YES 0.99f
 #define SURE_NO  0.01f
 
 #define MINIMUM_DATA_THRESHOLD  4
 
 //return confidence base on received data
-float CharDistributionAnalysis::GetConfidence()
+float CharDistributionAnalysis::GetConfidence(PRBool aIsPreferredLanguage)
 { 
   //if we didn't receive any character in our consideration range, or the
   // number of frequent characters is below the minimum threshold, return
   // negative answer
-  if (mTotalChars <= 0 || mFreqChars <= MINIMUM_DATA_THRESHOLD)
+  if (mTotalChars <= 0 ||
+      !aIsPreferredLanguage && mFreqChars <= MINIMUM_DATA_THRESHOLD)
     return SURE_NO;
 
   if (mTotalChars != mFreqChars) {
     float r = mFreqChars / ((mTotalChars - mFreqChars) * mTypicalDistributionRatio);
 
     if (r < SURE_YES)
       return r;
   }
diff -r a131999fa900 extensions/universalchardet/src/base/CharDistribution.h
--- a/extensions/universalchardet/src/base/CharDistribution.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/extensions/universalchardet/src/base/CharDistribution.h	Sat Nov 01 13:47:50 2008 +0200
@@ -66,17 +66,17 @@ public:
       {
         if (512 > mCharToFreqOrder[order])
           mFreqChars++;
       }
     }
   }
 
   //return confidence base on existing data
-  float GetConfidence();
+  float GetConfidence(PRBool aIsPreferredLanguage);
 
   //Reset analyser, clear any state 
   void      Reset(void) 
   {
     mDone = PR_FALSE;
     mTotalChars = 0;
     mFreqChars = 0;
   }
diff -r a131999fa900 extensions/universalchardet/src/base/JpCntx.cpp
--- a/extensions/universalchardet/src/base/JpCntx.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/extensions/universalchardet/src/base/JpCntx.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -176,20 +176,20 @@ void JapaneseContextAnalysis::Reset(void
   for (PRUint32 i = 0; i < NUM_OF_CATEGORY; i++)
     mRelSample[i] = 0;
   mNeedToSkipCharNum = 0;
   mLastCharOrder = -1;
   mDone = PR_FALSE;
 }
 #define DONT_KNOW (float)-1
 
-float  JapaneseContextAnalysis::GetConfidence()
+float  JapaneseContextAnalysis::GetConfidence(PRBool aIsPreferredLanguage)
 {
   //This is just one way to calculate confidence. It works well for me.
-  if (mTotalRel > MINIMUM_DATA_THRESHOLD)
+  if (aIsPreferredLanguage || mTotalRel > MINIMUM_DATA_THRESHOLD)
     return ((float)(mTotalRel - mRelSample[0]))/mTotalRel;
   else 
     return (float)DONT_KNOW;
 }
 
 
 PRInt32 SJISContextAnalysis::GetOrder(const char* str, PRUint32 *charLen)
 {
diff -r a131999fa900 extensions/universalchardet/src/base/JpCntx.h
--- a/extensions/universalchardet/src/base/JpCntx.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/extensions/universalchardet/src/base/JpCntx.h	Sat Nov 01 13:47:50 2008 +0200
@@ -69,17 +69,17 @@ public:
     {
       mTotalRel++;
       //count this sequence to its category counter
       mRelSample[jp2CharContext[mLastCharOrder][order]]++;
     }
     mLastCharOrder = order;
   }
 
-  float GetConfidence();
+  float GetConfidence(PRBool aIsPreferredLanguage);
   void      Reset(void);
   void      SetOpion(){}
   PRBool GotEnoughData() {return mTotalRel > ENOUGH_REL_THRESHOLD;}
 
 protected:
   virtual PRInt32 GetOrder(const char* str, PRUint32 *charLen) = 0;
   virtual PRInt32 GetOrder(const char* str) = 0;
 
diff -r a131999fa900 extensions/universalchardet/src/base/nsBig5Prober.cpp
--- a/extensions/universalchardet/src/base/nsBig5Prober.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/extensions/universalchardet/src/base/nsBig5Prober.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -76,13 +76,13 @@ nsProbingState nsBig5Prober::HandleData(
     if (mDistributionAnalyser.GotEnoughData() && GetConfidence() > SHORTCUT_THRESHOLD)
       mState = eFoundIt;
 
   return mState;
 }
 
 float nsBig5Prober::GetConfidence(void)
 {
-  float distribCf = mDistributionAnalyser.GetConfidence();
+  float distribCf = mDistributionAnalyser.GetConfidence(mIsPreferredLanguage);
 
   return (float)distribCf;
 }
 
diff -r a131999fa900 extensions/universalchardet/src/base/nsBig5Prober.h
--- a/extensions/universalchardet/src/base/nsBig5Prober.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/extensions/universalchardet/src/base/nsBig5Prober.h	Sat Nov 01 13:47:50 2008 +0200
@@ -39,18 +39,20 @@
 #define nsBig5Prober_h__
 
 #include "nsCharSetProber.h"
 #include "nsCodingStateMachine.h"
 #include "CharDistribution.h"
 
 class nsBig5Prober: public nsCharSetProber {
 public:
-  nsBig5Prober(void){mCodingSM = new nsCodingStateMachine(&Big5SMModel);
-                      Reset();}
+  nsBig5Prober(PRBool aIsPreferredLanguage)
+    :mIsPreferredLanguage(aIsPreferredLanguage) 
+  {mCodingSM = new nsCodingStateMachine(&Big5SMModel); 
+    Reset();}
   virtual ~nsBig5Prober(void){delete mCodingSM;}
   nsProbingState HandleData(const char* aBuf, PRUint32 aLen);
   const char* GetCharSetName() {return "Big5";}
   nsProbingState GetState(void) {return mState;}
   void      Reset(void);
   float     GetConfidence(void);
   void      SetOpion() {}
 
@@ -58,14 +60,15 @@ protected:
   void      GetDistribution(PRUint32 aCharLen, const char* aStr);
   
   nsCodingStateMachine* mCodingSM;
   nsProbingState mState;
 
   //Big5ContextAnalysis mContextAnalyser;
   Big5DistributionAnalysis mDistributionAnalyser;
   char mLastChar[2];
+  PRBool mIsPreferredLanguage;
 
 };
 
 
 #endif /* nsBig5Prober_h__ */
 
diff -r a131999fa900 extensions/universalchardet/src/base/nsEUCJPProber.cpp
--- a/extensions/universalchardet/src/base/nsEUCJPProber.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/extensions/universalchardet/src/base/nsEUCJPProber.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -86,14 +86,14 @@ nsProbingState nsEUCJPProber::HandleData
     if (mContextAnalyser.GotEnoughData() && GetConfidence() > SHORTCUT_THRESHOLD)
       mState = eFoundIt;
 
   return mState;
 }
 
 float nsEUCJPProber::GetConfidence(void)
 {
-  float contxtCf = mContextAnalyser.GetConfidence();
-  float distribCf = mDistributionAnalyser.GetConfidence();
+  float contxtCf = mContextAnalyser.GetConfidence(mIsPreferredLanguage);
+  float distribCf = mDistributionAnalyser.GetConfidence(mIsPreferredLanguage);
 
   return (contxtCf > distribCf ? contxtCf : distribCf);
 }
 
diff -r a131999fa900 extensions/universalchardet/src/base/nsEUCJPProber.h
--- a/extensions/universalchardet/src/base/nsEUCJPProber.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/extensions/universalchardet/src/base/nsEUCJPProber.h	Sat Nov 01 13:47:50 2008 +0200
@@ -45,31 +45,34 @@
 
 #include "nsCharSetProber.h"
 #include "nsCodingStateMachine.h"
 #include "JpCntx.h"
 #include "CharDistribution.h"
 
 class nsEUCJPProber: public nsCharSetProber {
 public:
-  nsEUCJPProber(void){mCodingSM = new nsCodingStateMachine(&EUCJPSMModel);
-                      Reset();}
+  nsEUCJPProber(PRBool aIsPreferredLanguage)
+    :mIsPreferredLanguage(aIsPreferredLanguage)
+  {mCodingSM = new nsCodingStateMachine(&EUCJPSMModel);
+    Reset();}
   virtual ~nsEUCJPProber(void){delete mCodingSM;}
   nsProbingState HandleData(const char* aBuf, PRUint32 aLen);
   const char* GetCharSetName() {return "EUC-JP";}
   nsProbingState GetState(void) {return mState;}
   void      Reset(void);
   float     GetConfidence(void);
   void      SetOpion() {}
 
 protected:
   nsCodingStateMachine* mCodingSM;
   nsProbingState mState;
 
   EUCJPContextAnalysis mContextAnalyser;
   EUCJPDistributionAnalysis mDistributionAnalyser;
 
   char mLastChar[2];
+  PRBool mIsPreferredLanguage;
 };
 
 
 #endif /* nsEUCJPProber_h__ */
 
diff -r a131999fa900 extensions/universalchardet/src/base/nsEUCKRProber.cpp
--- a/extensions/universalchardet/src/base/nsEUCKRProber.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/extensions/universalchardet/src/base/nsEUCKRProber.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -79,13 +79,13 @@ nsProbingState nsEUCKRProber::HandleData
 //    else
 //      mDistributionAnalyser.HandleData(aBuf, aLen);
 
   return mState;
 }
 
 float nsEUCKRProber::GetConfidence(void)
 {
-  float distribCf = mDistributionAnalyser.GetConfidence();
+  float distribCf = mDistributionAnalyser.GetConfidence(mIsPreferredLanguage);
 
   return (float)distribCf;
 }
 
diff -r a131999fa900 extensions/universalchardet/src/base/nsEUCKRProber.h
--- a/extensions/universalchardet/src/base/nsEUCKRProber.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/extensions/universalchardet/src/base/nsEUCKRProber.h	Sat Nov 01 13:47:50 2008 +0200
@@ -39,18 +39,21 @@
 #define nsEUCKRProber_h__
 
 #include "nsCharSetProber.h"
 #include "nsCodingStateMachine.h"
 #include "CharDistribution.h"
 
 class nsEUCKRProber: public nsCharSetProber {
 public:
-  nsEUCKRProber(void){mCodingSM = new nsCodingStateMachine(&EUCKRSMModel);
-                      Reset();}
+  nsEUCKRProber(PRBool aIsPreferredLanguage)
+    :mIsPreferredLanguage(aIsPreferredLanguage)
+  {mCodingSM = new nsCodingStateMachine(&EUCKRSMModel);
+    Reset();
+  }
   virtual ~nsEUCKRProber(void){delete mCodingSM;}
   nsProbingState HandleData(const char* aBuf, PRUint32 aLen);
   const char* GetCharSetName() {return "EUC-KR";}
   nsProbingState GetState(void) {return mState;}
   void      Reset(void);
   float     GetConfidence(void);
   void      SetOpion() {}
 
@@ -58,14 +61,15 @@ protected:
   void      GetDistribution(PRUint32 aCharLen, const char* aStr);
   
   nsCodingStateMachine* mCodingSM;
   nsProbingState mState;
 
   //EUCKRContextAnalysis mContextAnalyser;
   EUCKRDistributionAnalysis mDistributionAnalyser;
   char mLastChar[2];
+  PRBool mIsPreferredLanguage;
 
 };
 
 
 #endif /* nsEUCKRProber_h__ */
 
diff -r a131999fa900 extensions/universalchardet/src/base/nsEUCTWProber.cpp
--- a/extensions/universalchardet/src/base/nsEUCTWProber.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/extensions/universalchardet/src/base/nsEUCTWProber.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -79,13 +79,13 @@ nsProbingState nsEUCTWProber::HandleData
 //    else
 //      mDistributionAnalyser.HandleData(aBuf, aLen);
 
   return mState;
 }
 
 float nsEUCTWProber::GetConfidence(void)
 {
-  float distribCf = mDistributionAnalyser.GetConfidence();
+  float distribCf = mDistributionAnalyser.GetConfidence(mIsPreferredLanguage);
 
   return (float)distribCf;
 }
 
diff -r a131999fa900 extensions/universalchardet/src/base/nsEUCTWProber.h
--- a/extensions/universalchardet/src/base/nsEUCTWProber.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/extensions/universalchardet/src/base/nsEUCTWProber.h	Sat Nov 01 13:47:50 2008 +0200
@@ -39,18 +39,20 @@
 #define nsEUCTWProber_h__
 
 #include "nsCharSetProber.h"
 #include "nsCodingStateMachine.h"
 #include "CharDistribution.h"
 
 class nsEUCTWProber: public nsCharSetProber {
 public:
-  nsEUCTWProber(void){mCodingSM = new nsCodingStateMachine(&EUCTWSMModel);
-                      Reset();}
+  nsEUCTWProber(PRBool aIsPreferredLanguage)
+    :mIsPreferredLanguage(aIsPreferredLanguage)
+  {mCodingSM = new nsCodingStateMachine(&EUCTWSMModel);
+    Reset();}
   virtual ~nsEUCTWProber(void){delete mCodingSM;}
   nsProbingState HandleData(const char* aBuf, PRUint32 aLen);
   const char* GetCharSetName() {return "x-euc-tw";}
   nsProbingState GetState(void) {return mState;}
   void      Reset(void);
   float     GetConfidence(void);
   void      SetOpion() {}
 
@@ -58,14 +60,15 @@ protected:
   void      GetDistribution(PRUint32 aCharLen, const char* aStr);
   
   nsCodingStateMachine* mCodingSM;
   nsProbingState mState;
 
   //EUCTWContextAnalysis mContextAnalyser;
   EUCTWDistributionAnalysis mDistributionAnalyser;
   char mLastChar[2];
+  PRBool mIsPreferredLanguage;
 
 };
 
 
 #endif /* nsEUCTWProber_h__ */
 
diff -r a131999fa900 extensions/universalchardet/src/base/nsGB2312Prober.cpp
--- a/extensions/universalchardet/src/base/nsGB2312Prober.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/extensions/universalchardet/src/base/nsGB2312Prober.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -84,13 +84,13 @@ nsProbingState nsGB18030Prober::HandleDa
 //    else
 //      mDistributionAnalyser.HandleData(aBuf, aLen);
 
   return mState;
 }
 
 float nsGB18030Prober::GetConfidence(void)
 {
-  float distribCf = mDistributionAnalyser.GetConfidence();
+  float distribCf = mDistributionAnalyser.GetConfidence(mIsPreferredLanguage);
 
   return (float)distribCf;
 }
 
diff -r a131999fa900 extensions/universalchardet/src/base/nsGB2312Prober.h
--- a/extensions/universalchardet/src/base/nsGB2312Prober.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/extensions/universalchardet/src/base/nsGB2312Prober.h	Sat Nov 01 13:47:50 2008 +0200
@@ -41,18 +41,20 @@
 #include "nsCharSetProber.h"
 #include "nsCodingStateMachine.h"
 #include "CharDistribution.h"
 
 // We use gb18030 to replace gb2312, because 18030 is a superset. 
 
 class nsGB18030Prober: public nsCharSetProber {
 public:
-  nsGB18030Prober(void){mCodingSM = new nsCodingStateMachine(&GB18030SMModel);
-                      Reset();}
+  nsGB18030Prober(PRBool aIsPreferredLanguage)
+    :mIsPreferredLanguage(aIsPreferredLanguage)
+  {mCodingSM = new nsCodingStateMachine(&GB18030SMModel);
+    Reset();}
   virtual ~nsGB18030Prober(void){delete mCodingSM;}
   nsProbingState HandleData(const char* aBuf, PRUint32 aLen);
   const char* GetCharSetName() {return "gb18030";}
   nsProbingState GetState(void) {return mState;}
   void      Reset(void);
   float     GetConfidence(void);
   void      SetOpion() {}
 
@@ -60,14 +62,15 @@ protected:
   void      GetDistribution(PRUint32 aCharLen, const char* aStr);
   
   nsCodingStateMachine* mCodingSM;
   nsProbingState mState;
 
   //GB2312ContextAnalysis mContextAnalyser;
   GB2312DistributionAnalysis mDistributionAnalyser;
   char mLastChar[2];
+  PRBool mIsPreferredLanguage;
 
 };
 
 
 #endif /* nsGB2312Prober_h__ */
 
diff -r a131999fa900 extensions/universalchardet/src/base/nsMBCSGroupProber.cpp
--- a/extensions/universalchardet/src/base/nsMBCSGroupProber.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/extensions/universalchardet/src/base/nsMBCSGroupProber.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -58,27 +58,27 @@ nsMBCSGroupProber::nsMBCSGroupProber(PRU
 nsMBCSGroupProber::nsMBCSGroupProber(PRUint32 aLanguageFilter)
 {
   for (PRUint32 i = 0; i < NUM_OF_PROBERS; i++)
     mProbers[i] = nsnull;
 
   mProbers[0] = new nsUTF8Prober();
   if (aLanguageFilter & NS_FILTER_JAPANESE) 
   {
-    mProbers[1] = new nsSJISProber();
-    mProbers[2] = new nsEUCJPProber();
+    mProbers[1] = new nsSJISProber(aLanguageFilter == NS_FILTER_JAPANESE);
+    mProbers[2] = new nsEUCJPProber(aLanguageFilter == NS_FILTER_JAPANESE);
   }
   if (aLanguageFilter & NS_FILTER_CHINESE_SIMPLIFIED)
-    mProbers[3] = new nsGB18030Prober();
+    mProbers[3] = new nsGB18030Prober(aLanguageFilter == NS_FILTER_CHINESE_SIMPLIFIED);
   if (aLanguageFilter & NS_FILTER_KOREAN)
-    mProbers[4] = new nsEUCKRProber();
+    mProbers[4] = new nsEUCKRProber(aLanguageFilter == NS_FILTER_KOREAN);
   if (aLanguageFilter & NS_FILTER_CHINESE_TRADITIONAL) 
   {
-    mProbers[5] = new nsBig5Prober();
-    mProbers[6] = new nsEUCTWProber();
+    mProbers[5] = new nsBig5Prober(aLanguageFilter == NS_FILTER_CHINESE_TRADITIONAL);
+    mProbers[6] = new nsEUCTWProber(aLanguageFilter == NS_FILTER_CHINESE_TRADITIONAL);
   }
   Reset();
 }
 
 nsMBCSGroupProber::~nsMBCSGroupProber()
 {
   for (PRUint32 i = 0; i < NUM_OF_PROBERS; i++)
   {
diff -r a131999fa900 extensions/universalchardet/src/base/nsSJISProber.cpp
--- a/extensions/universalchardet/src/base/nsSJISProber.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/extensions/universalchardet/src/base/nsSJISProber.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -85,14 +85,14 @@ nsProbingState nsSJISProber::HandleData(
     if (mContextAnalyser.GotEnoughData() && GetConfidence() > SHORTCUT_THRESHOLD)
       mState = eFoundIt;
 
   return mState;
 }
 
 float nsSJISProber::GetConfidence(void)
 {
-  float contxtCf = mContextAnalyser.GetConfidence();
-  float distribCf = mDistributionAnalyser.GetConfidence();
+  float contxtCf = mContextAnalyser.GetConfidence(mIsPreferredLanguage);
+  float distribCf = mDistributionAnalyser.GetConfidence(mIsPreferredLanguage);
 
   return (contxtCf > distribCf ? contxtCf : distribCf);
 }
 
diff -r a131999fa900 extensions/universalchardet/src/base/nsSJISProber.h
--- a/extensions/universalchardet/src/base/nsSJISProber.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/extensions/universalchardet/src/base/nsSJISProber.h	Sat Nov 01 13:47:50 2008 +0200
@@ -46,32 +46,35 @@
 #include "nsCharSetProber.h"
 #include "nsCodingStateMachine.h"
 #include "JpCntx.h"
 #include "CharDistribution.h"
 
 
 class nsSJISProber: public nsCharSetProber {
 public:
-  nsSJISProber(void){mCodingSM = new nsCodingStateMachine(&SJISSMModel);
-                      Reset();}
+  nsSJISProber(PRBool aIsPreferredLanguage)
+    :mIsPreferredLanguage(aIsPreferredLanguage)
+  {mCodingSM = new nsCodingStateMachine(&SJISSMModel);
+    Reset();}
   virtual ~nsSJISProber(void){delete mCodingSM;}
   nsProbingState HandleData(const char* aBuf, PRUint32 aLen);
   const char* GetCharSetName() {return "Shift_JIS";}
   nsProbingState GetState(void) {return mState;}
   void      Reset(void);
   float     GetConfidence(void);
   void      SetOpion() {}
 
 protected:
   nsCodingStateMachine* mCodingSM;
   nsProbingState mState;
 
   SJISContextAnalysis mContextAnalyser;
   SJISDistributionAnalysis mDistributionAnalyser;
 
   char mLastChar[2];
+  PRBool mIsPreferredLanguage;
 
 };
 
 
 #endif /* nsSJISProber_h__ */
 
diff -r a131999fa900 extensions/universalchardet/tests/Makefile.in
--- a/extensions/universalchardet/tests/Makefile.in	Thu Oct 30 23:42:02 2008 -0700
+++ b/extensions/universalchardet/tests/Makefile.in	Sat Nov 01 13:47:50 2008 +0200
@@ -78,12 +78,15 @@ _TEST_FILES =	\
 		bug306272_text.html \
 		test_bug306272.html \
 		bug421271_text.html \
 		test_bug421271.html \
 		bug426271_text-euc-jp.html \
 		test_bug426271-euc-jp.html \
 		bug426271_text-utf-8.html \
 		test_bug426271-utf-8.html \
+		bug431054_text.html \
+		test_bug431054.html \
+		test_bug431054-japanese.html \
 		$(NULL)
 
 libs:: $(_TEST_FILES)
 	$(INSTALL) $(foreach f,$^,"$f") $(DEPTH)/_tests/testing/mochitest/tests/$(relativesrcdir)
diff -r a131999fa900 extensions/universalchardet/tests/bug431054_text.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/extensions/universalchardet/tests/bug431054_text.html	Sat Nov 01 13:47:50 2008 +0200
@@ -0,0 +1,5 @@
+<html>
+<body>
+
+</body>
+</html>
diff -r a131999fa900 extensions/universalchardet/tests/test_bug306272.html
--- a/extensions/universalchardet/tests/test_bug306272.html	Thu Oct 30 23:42:02 2008 -0700
+++ b/extensions/universalchardet/tests/test_bug306272.html	Sat Nov 01 13:47:50 2008 +0200
@@ -17,17 +17,16 @@ https://bugzilla.mozilla.org/show_bug.cg
 </div>
 <iframe id="testframe"></iframe>
 <pre id="test">
 <script class="testbody" type="text/javascript">
 /** Test for Bug 306272 **/
 CharsetDetectionTests("bug306272_text.html",
 		      "UTF-8",
 		      new Array("ja_parallel_state_machine",
-				"ko_parallel_state_machine",
 				"zh_parallel_state_machine",
 				"zhtw_parallel_state_machine",
 				"zhcn_parallel_state_machine",
 				"cjk_parallel_state_machine",
 				"universal_charset_detector"));
 </script>
 </pre>
 </body>
diff -r a131999fa900 extensions/universalchardet/tests/test_bug431054-japanese.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/extensions/universalchardet/tests/test_bug431054-japanese.html	Sat Nov 01 13:47:50 2008 +0200
@@ -0,0 +1,28 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=431054
+-->
+<head>
+  <title>Test for Bug 431054</title>
+  <script type="text/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <script type="text/javascript" src="CharsetDetectionTests.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=426271">Mozilla Bug 431054</a>
+<p id="display"></p>
+<div id="content" style="display: none">  
+</div>
+<iframe id="testframe"></iframe>
+<pre id="test">
+<script class="testbody" type="text/javascript">
+/** Test for Bug 431054 **/
+CharsetDetectionTests("bug431054_text.html",
+		      "EUC-JP",
+		      new Array("ja_parallel_state_machine"));
+</script>
+</pre>
+</body>
+</html>
diff -r a131999fa900 extensions/universalchardet/tests/test_bug431054.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/extensions/universalchardet/tests/test_bug431054.html	Sat Nov 01 13:47:50 2008 +0200
@@ -0,0 +1,32 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=431054
+-->
+<head>
+  <title>Test for Bug 431054</title>
+  <script type="text/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <script type="text/javascript" src="CharsetDetectionTests.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=426271">Mozilla Bug 431054</a>
+<p id="display"></p>
+<div id="content" style="display: none">  
+</div>
+<iframe id="testframe"></iframe>
+<pre id="test">
+<script class="testbody" type="text/javascript">
+/** Test for Bug 431054 **/
+CharsetDetectionTests("bug431054_text.html",
+		      "windows-1252",
+		      new Array("zhtw_parallel_state_machine",
+				"zhcn_parallel_state_machine",
+				"zh_parallel_state_machine",
+				"cjk_parallel_state_machine",
+				"universal_charset_detector"));
+</script>
+</pre>
+</body>
+</html>
diff -r a131999fa900 js/src/jstracer.cpp
--- a/js/src/jstracer.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/js/src/jstracer.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -2395,22 +2395,45 @@ js_SynthesizeFrame(JSContext* cx, const 
         JSStackFrame **disp = &cx->display[script->staticDepth];
         newifp->frame.displaySave = *disp;
         *disp = &newifp->frame;
     }
 #ifdef DEBUG
     newifp->frame.pcDisabledSave = 0;
 #endif
 
+    /*
+     * Note that cx->fp->script is still the caller's script; set the callee
+     * inline frame's idea of caller version from its version.
+     */
+    newifp->callerVersion = (JSVersion) cx->fp->script->version;
+
     cx->fp->regs = &newifp->callerRegs;
     cx->fp = &newifp->frame;
 
     if (fun->flags & JSFUN_HEAVYWEIGHT) {
+        /*
+         * Set hookData to null because the failure case for js_GetCallObject
+         * involves it calling the debugger hook.
+         */
+        newifp->hookData = NULL;
         if (!js_GetCallObject(cx, &newifp->frame, newifp->frame.scopeChain))
             return -1;
+    }
+
+    /*
+     * If there's a call hook, invoke it to compute the hookData used by
+     * debuggers that cooperate with the interpreter.
+     */
+    JSInterpreterHook hook = cx->debugHooks->callHook;
+    if (hook) {
+        newifp->hookData = hook(cx, &newifp->frame, JS_TRUE, 0,
+                                cx->debugHooks->callHookData);
+    } else {
+        newifp->hookData = NULL;
     }
 
     // FIXME? we must count stack slots from caller's operand stack up to (but not including)
     // callee's, including missing arguments. Could we shift everything down to the caller's
     // fp->slots (where vars start) and avoid some of the complexity?
     return (fi.s.spdist - cx->fp->down->script->nfixed) +
            ((fun->nargs > cx->fp->argc) ? fun->nargs - cx->fp->argc : 0) +
            script->nfixed;
diff -r a131999fa900 layout/Makefile.in
--- a/layout/Makefile.in	Thu Oct 30 23:42:02 2008 -0700
+++ b/layout/Makefile.in	Sat Nov 01 13:47:50 2008 +0200
@@ -39,45 +39,53 @@ topsrcdir	= @top_srcdir@
 topsrcdir	= @top_srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 MODULE		= layout
 
-DIRS		= \
+PARALLEL_DIRS = \
 		style \
 		base \
 		generic \
 		forms \
 		tables \
-		xul \
+		xul/base/public \
+		xul/base/src \
 		$(NULL)
 
 ifdef NS_PRINTING
-DIRS           += printing
+PARALLEL_DIRS += printing
 endif
 
 ifdef MOZ_MATHML
-DIRS           += mathml
+PARALLEL_DIRS += \
+  mathml/content/src \
+  mathml/base/src \
+  $(NULL)
 endif
 
 ifdef MOZ_SVG
-DIRS           += svg
+PARALLEL_DIRS += svg/base/src
 endif
 
 ifndef MOZ_NO_INSPECTOR_APIS
-DIRS           += inspector
+PARALLEL_DIRS += inspector/public inspector/src
 endif
 
 DIRS           += build
 
 ifdef ENABLE_TESTS
+PARALLEL_DIRS += \
+  xul/test \
+  xul/base/test \
+  $(NULL)
+
 TOOL_DIRS      += tools/reftest
 DIRS           += tools/pageloader
 ifndef MOZ_ENABLE_LIBXUL
 TOOL_DIRS	+= html/tests
 endif
 endif
 
 include $(topsrcdir)/config/rules.mk
-
diff -r a131999fa900 layout/inspector/Makefile.in
--- a/layout/inspector/Makefile.in	Thu Oct 30 23:42:02 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,47 +0,0 @@
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla code.
-#
-# The Initial Developer of the Original Code is
-# Benjamin Smedberg <benjamin@smedbergs.us>.
-#
-# Portions created by the Initial Developer are Copyright (C) 2005
-# the Mozilla Foundation <http://www.mozilla.org/>. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-DEPTH = ../..
-topsrcdir = @top_srcdir@
-srcdir = @srcdir@
-VPATH = @srcdir@
-
-include $(DEPTH)/config/autoconf.mk
-
-DIRS = public src
-
-include $(topsrcdir)/config/rules.mk
diff -r a131999fa900 layout/mathml/Makefile.in
--- a/layout/mathml/Makefile.in	Thu Oct 30 23:42:02 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,51 +0,0 @@
-#!gmake
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla MathML Project.
-#
-# The Initial Developer of the Original Code is
-# Heriot-Watt University, Edinburgh.
-# Portions created by the Initial Developer are Copyright (C) 1999
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#   David J. Fiddes <D.J.Fiddes@hw.ac.uk>
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either of the GNU General Public License Version 2 or later (the "GPL"),
-# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-DEPTH = ../..
-topsrcdir	= @top_srcdir@
-srcdir		= @srcdir@
-VPATH		= @srcdir@
-
-include $(DEPTH)/config/autoconf.mk
-
-DIRS = content base
-
-include $(topsrcdir)/config/config.mk
-
-include $(topsrcdir)/config/rules.mk
diff -r a131999fa900 layout/mathml/base/Makefile.in
--- a/layout/mathml/base/Makefile.in	Thu Oct 30 23:42:02 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,51 +0,0 @@
-#!gmake
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla MathML Project.
-#
-# The Initial Developer of the Original Code is
-# Heriot-Watt University, Edinburgh.
-# Portions created by the Initial Developer are Copyright (C) 1999
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#   David J. Fiddes <D.J.Fiddes@hw.ac.uk>
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either of the GNU General Public License Version 2 or later (the "GPL"),
-# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-DEPTH = ../../..
-topsrcdir	= @top_srcdir@
-srcdir		= @srcdir@
-VPATH		= @srcdir@
-
-include $(DEPTH)/config/autoconf.mk
-
-DIRS = src
-
-include $(topsrcdir)/config/config.mk
-
-include $(topsrcdir)/config/rules.mk
diff -r a131999fa900 layout/mathml/content/Makefile.in
--- a/layout/mathml/content/Makefile.in	Thu Oct 30 23:42:02 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,51 +0,0 @@
-#!gmake
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla MathML Project.
-#
-# The Initial Developer of the Original Code is
-# Heriot-Watt University, Edinburgh.
-# Portions created by the Initial Developer are Copyright (C) 1999
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#   David J. Fiddes <D.J.Fiddes@hw.ac.uk>
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either of the GNU General Public License Version 2 or later (the "GPL"),
-# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-DEPTH = ../../..
-topsrcdir	= @top_srcdir@
-srcdir		= @srcdir@
-VPATH		= @srcdir@
-
-include $(DEPTH)/config/autoconf.mk
-
-DIRS = src
-
-include $(topsrcdir)/config/config.mk
-
-include $(topsrcdir)/config/rules.mk
diff -r a131999fa900 layout/style/nsStyleContext.cpp
--- a/layout/style/nsStyleContext.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/layout/style/nsStyleContext.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -230,17 +230,17 @@ const void* nsStyleContext::GetStyleData
       return cachedData; /* We have computed data stored on this node */    \
                          /* in the context tree. */                         \
     /* Else our rule node will take care of it for us. */                   \
     return mRuleNode->GetStyle##name_(this, PR_TRUE);                       \
   }
 #include "nsStyleStructList.h"
 #undef STYLE_STRUCT
 
-inline const void* nsStyleContext::PeekStyleData(nsStyleStructID aSID)
+const void* nsStyleContext::PeekStyleData(nsStyleStructID aSID)
 {
   const void* cachedData = mCachedStyleData.GetStyleData(aSID); 
   if (cachedData)
     return cachedData; // We have computed data stored on this node in the context tree.
   return mRuleNode->GetStyleData(aSID, this, PR_FALSE); // Our rule node will take care of it for us.
 }
 
 // This is an evil evil function, since it forces you to alloc your own separate copy of
diff -r a131999fa900 layout/svg/Makefile.in
--- a/layout/svg/Makefile.in	Thu Oct 30 23:42:02 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,48 +0,0 @@
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is mozilla.org code.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either of the GNU General Public License Version 2 or later (the "GPL"),
-# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-DEPTH		= ../..
-topsrcdir	= @top_srcdir@
-srcdir		= @srcdir@
-VPATH		= @srcdir@
-
-include $(DEPTH)/config/autoconf.mk
-
-DIRS		= base
-
-include $(topsrcdir)/config/rules.mk
-
diff -r a131999fa900 layout/svg/base/Makefile.in
--- a/layout/svg/base/Makefile.in	Thu Oct 30 23:42:02 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,48 +0,0 @@
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is mozilla.org code.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either of the GNU General Public License Version 2 or later (the "GPL"),
-# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-DEPTH		= ../../..
-topsrcdir	= @top_srcdir@
-srcdir		= @srcdir@
-VPATH		= @srcdir@
-
-include $(DEPTH)/config/autoconf.mk
-
-DIRS		= src
-
-include $(topsrcdir)/config/rules.mk
-
diff -r a131999fa900 layout/tables/nsTableFrame.cpp
--- a/layout/tables/nsTableFrame.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/layout/tables/nsTableFrame.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -269,17 +269,16 @@ nsTableFrame::~nsTableFrame()
 }
 
 void
 nsTableFrame::Destroy()
 {
   mColGroups.DestroyFrames();
   nsHTMLContainerFrame::Destroy();
 }
-
 
 // Make sure any views are positioned properly
 void
 nsTableFrame::RePositionViews(nsIFrame* aFrame)
 {
   nsContainerFrame::PositionFrameView(aFrame);
   nsContainerFrame::PositionChildViews(aFrame);
 }
@@ -2222,18 +2221,17 @@ nsTableFrame::GetCollapsedWidth(nsMargin
             width += cellSpacingX;
         }
       }
     }
   }
   return width;
 }
 
-
-   /* virtual */ void
+/* virtual */ void
 nsTableFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
 {
    if (!aOldStyleContext) //avoid this on init
      return;
    
    if (IsBorderCollapse() &&
        BCRecalcNeeded(aOldStyleContext, GetStyleContext())) {
      nsRect damageArea(0, 0, GetColCount(), GetRowCount());
@@ -4693,33 +4691,57 @@ class nsDelayedCalcBCBorders : public ns
 class nsDelayedCalcBCBorders : public nsRunnable {
 public:
   nsDelayedCalcBCBorders(nsIFrame* aFrame) :
     mFrame(aFrame) {}
 
   NS_IMETHOD Run() {
     if (mFrame) {
       nsTableFrame* tableFrame = static_cast <nsTableFrame*>(mFrame.GetFrame());
-      if (tableFrame) {
-        if (tableFrame->NeedToCalcBCBorders()) {
-          tableFrame->CalcBCBorders();
-        }
+      if (tableFrame->NeedToCalcBCBorders()) {
+        tableFrame->CalcBCBorders();
       }
     }
     return NS_OK;
   }
 private:
   nsWeakFrame mFrame;
 };
   
 PRBool
 nsTableFrame::BCRecalcNeeded(nsStyleContext* aOldStyleContext,
                              nsStyleContext* aNewStyleContext)
 {
-  // XXX bernd temp disabled till I figure out the mac failure
+  // Attention: the old style context is the one we're forgetting,
+  // and hence possibly completely bogus for GetStyle* purposes.
+  // We use PeekStyleData instead.
+
+  const nsStyleBorder* oldStyleData = static_cast<const nsStyleBorder*>
+                        (aOldStyleContext->PeekStyleData(eStyleStruct_Border));
+  if (!oldStyleData)
+    return PR_FALSE;
+
+  const nsStyleBorder* newStyleData = aNewStyleContext->GetStyleBorder();
+  nsChangeHint change = newStyleData->CalcDifference(*oldStyleData);
+  if (change == NS_STYLE_HINT_NONE)
+    return PR_FALSE;
+  if ((change & NS_STYLE_HINT_REFLOW) == NS_STYLE_HINT_REFLOW)
+    return PR_TRUE; // the caller only needs to mark the bc damage area
+  if ((change & NS_STYLE_HINT_VISUAL) == NS_STYLE_HINT_VISUAL) {
+    NS_FOR_CSS_SIDES(side) {
+      if (newStyleData->GetBorderStyle(side) !=
+          oldStyleData->GetBorderStyle(side)) {
+        // we need to recompute the borders and the caller needs to mark
+        // the bc damage area
+        nsCOMPtr<nsIRunnable> evt = new nsDelayedCalcBCBorders(this);
+        NS_DispatchToCurrentThread(evt);
+        return PR_TRUE;
+      }
+    }
+  }
   return PR_FALSE;
 }
 
 /* BCCellBorder represents a border segment which can be either a horizontal
  * or a vertical segment. For each segment we need to know the color, width,
  * style, who owns it and how long it is in cellmap coordinates.
  * Ownership of these segments is  important to calculate which corners should
  * be bevelled. This structure has dual use, its used first to compute the
diff -r a131999fa900 layout/xul/Makefile.in
--- a/layout/xul/Makefile.in	Thu Oct 30 23:42:02 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,52 +0,0 @@
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is mozilla.org code.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either of the GNU General Public License Version 2 or later (the "GPL"),
-# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-DEPTH		= ../..
-topsrcdir	= @top_srcdir@
-srcdir		= @srcdir@
-VPATH		= @srcdir@
-
-include $(DEPTH)/config/autoconf.mk
-
-DIRS		= base
-
-ifdef ENABLE_TESTS
-DIRS		+= test
-endif
-
-include $(topsrcdir)/config/rules.mk
-
diff -r a131999fa900 layout/xul/base/Makefile.in
--- a/layout/xul/base/Makefile.in	Thu Oct 30 23:42:02 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,52 +0,0 @@
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is mozilla.org code.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either of the GNU General Public License Version 2 or later (the "GPL"),
-# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-DEPTH		= ../../..
-topsrcdir	= @top_srcdir@
-srcdir		= @srcdir@
-VPATH		= @srcdir@
-
-include $(DEPTH)/config/autoconf.mk
-
-DIRS		= public src
-
-ifdef ENABLE_TESTS
-DIRS		+= test
-endif
-
-include $(topsrcdir)/config/rules.mk
-
diff -r a131999fa900 layout/xul/base/src/Makefile.in
--- a/layout/xul/base/src/Makefile.in	Thu Oct 30 23:42:02 2008 -0700
+++ b/layout/xul/base/src/Makefile.in	Sat Nov 01 13:47:50 2008 +0200
@@ -70,17 +70,17 @@ ifdef MOZ_ENABLE_CANVAS
 ifdef MOZ_ENABLE_CANVAS
 REQUIRES        += \
                 cairo \
                 libpixman \
                 $(NULL)
 endif
 
 ifdef MOZ_XUL
-DIRS		= tree grid
+PARALLEL_DIRS = tree/public tree/src grid
 endif
 
 EXPORTS		= nsIMenuParent.h
 
 CPPSRCS		= \
 		nsScrollBoxFrame.cpp \
 		nsRootBoxFrame.cpp \
 		nsBox.cpp \
diff -r a131999fa900 layout/xul/base/src/tree/Makefile.in
--- a/layout/xul/base/src/tree/Makefile.in	Thu Oct 30 23:42:02 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,48 +0,0 @@
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is mozilla.org code.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1998
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either of the GNU General Public License Version 2 or later (the "GPL"),
-# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-DEPTH		= ../../../../..
-topsrcdir	= @top_srcdir@
-srcdir		= @srcdir@
-VPATH		= @srcdir@
-
-include $(DEPTH)/config/autoconf.mk
-
-DIRS		= public src
-
-include $(topsrcdir)/config/rules.mk
-
diff -r a131999fa900 layout/xul/base/src/tree/src/nsTreeColumns.cpp
--- a/layout/xul/base/src/tree/src/nsTreeColumns.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/layout/xul/base/src/tree/src/nsTreeColumns.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -519,27 +519,32 @@ nsTreeColumns::GetColumnFor(nsIDOMElemen
       NS_ADDREF(*_retval = currCol);
       break;
     }
   }
 
   return NS_OK;
 }
 
+nsITreeColumn*
+nsTreeColumns::GetNamedColumn(const nsAString& aId)
+{
+  EnsureColumns();
+  for (nsTreeColumn* currCol = mFirstColumn; currCol; currCol = currCol->GetNext()) {
+    if (currCol->GetId().Equals(aId)) {
+      return currCol;
+    }
+  }
+  return nsnull;
+}
+
 NS_IMETHODIMP
 nsTreeColumns::GetNamedColumn(const nsAString& aId, nsITreeColumn** _retval)
 {
-  EnsureColumns();
-  *_retval = nsnull;
-  for (nsTreeColumn* currCol = mFirstColumn; currCol; currCol = currCol->GetNext()) {
-    if (currCol->GetId().Equals(aId)) {
-      NS_ADDREF(*_retval = currCol);
-      break;
-    }
-  }
+  NS_IF_ADDREF(*_retval = GetNamedColumn(aId));
   return NS_OK;
 }
 
 nsITreeColumn*
 nsTreeColumns::GetColumnAt(PRInt32 aIndex)
 {
   EnsureColumns();
   for (nsTreeColumn* currCol = mFirstColumn; currCol; currCol = currCol->GetNext()) {
@@ -548,17 +553,16 @@ nsTreeColumns::GetColumnAt(PRInt32 aInde
     }
   }
   return nsnull;
 }
 
 NS_IMETHODIMP
 nsTreeColumns::GetColumnAt(PRInt32 aIndex, nsITreeColumn** _retval)
 {
-  EnsureColumns();
   NS_IF_ADDREF(*_retval = GetColumnAt(aIndex));
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsTreeColumns::InvalidateColumns()
 {
   NS_IF_RELEASE(mFirstColumn);
diff -r a131999fa900 layout/xul/base/src/tree/src/nsTreeColumns.h
--- a/layout/xul/base/src/tree/src/nsTreeColumns.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/layout/xul/base/src/tree/src/nsTreeColumns.h	Sat Nov 01 13:47:50 2008 +0200
@@ -144,16 +144,17 @@ public:
 public:
   nsTreeColumns(nsITreeBoxObject* aTree);
   ~nsTreeColumns();
 
   NS_DECL_ISUPPORTS
   NS_DECL_NSITREECOLUMNS
 
   nsITreeColumn* GetColumnAt(PRInt32 aIndex);
+  nsITreeColumn* GetNamedColumn(const nsAString& aId);
 
   static nsTreeColumns* FromSupports(nsISupports* aSupports)
   {
 #ifdef DEBUG
     {
       nsCOMPtr<nsITreeColumns> columns_qi = do_QueryInterface(aSupports);
 
       // If this assertion fires the QI implementation for the object in
diff -r a131999fa900 modules/libjar/zipwriter/src/nsZipHeader.h
--- a/modules/libjar/zipwriter/src/nsZipHeader.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/modules/libjar/zipwriter/src/nsZipHeader.h	Sat Nov 01 13:47:50 2008 +0200
@@ -40,34 +40,41 @@
 #define _nsZipHeader_h_
 
 #include "nsString.h"
 #include "nsIOutputStream.h"
 #include "nsIInputStream.h"
 #include "nsIZipReader.h"
 #include "nsAutoPtr.h"
 
-#define ZIP_ATTRS_FILE 0
-#define ZIP_ATTRS_DIRECTORY 16
+// High word is S_IFREG, low word is DOS file attribute
+#define ZIP_ATTRS_FILE 0x80000000
+// High word is S_IFDIR, low word is DOS dir attribute
+#define ZIP_ATTRS_DIRECTORY 0x40000010
+#define PERMISSIONS_FILE 0644
+#define PERMISSIONS_DIR 0755
+
+// Combine file type attributes with unix style permissions
+#define ZIP_ATTRS(p, a) ((p & 0xfff) << 16) | a
 
 class nsZipHeader : public nsIZipEntry
 {
 public:
     NS_DECL_ISUPPORTS
     NS_DECL_NSIZIPENTRY
 
     nsZipHeader() :
         mCRC(0),
         mCSize(0),
         mUSize(0),
         mEAttr(0),
         mOffset(0),
         mFieldLength(0),
-        mVersionMade(20),
-        mVersionNeeded(20),
+        mVersionMade(0x0300 + 23), // Generated on Unix by v2.3 (matches infozip)
+        mVersionNeeded(20), // Requires v2.0 to extract
         mFlags(0),
         mMethod(0),
         mTime(0),
         mDate(0),
         mDisk(0),
         mIAttr(0),
         mInited(PR_FALSE),
         mExtraField(NULL)
diff -r a131999fa900 modules/libjar/zipwriter/src/nsZipWriter.cpp
--- a/modules/libjar/zipwriter/src/nsZipWriter.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/modules/libjar/zipwriter/src/nsZipWriter.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -352,24 +352,25 @@ NS_IMETHODIMP nsZipWriter::AddEntryDirec
     if (!mStream)
         return NS_ERROR_NOT_INITIALIZED;
 
     if (aQueue) {
         nsZipQueueItem item;
         item.mOperation = OPERATION_ADD;
         item.mZipEntry = aZipEntry;
         item.mModTime = aModTime;
+        item.mPermissions = PERMISSIONS_DIR;
         if (!mQueue.AppendElement(item))
             return NS_ERROR_OUT_OF_MEMORY;
         return NS_OK;
     }
 
     if (mInQueue)
         return NS_ERROR_IN_PROGRESS;
-    return InternalAddEntryDirectory(aZipEntry, aModTime);
+    return InternalAddEntryDirectory(aZipEntry, aModTime, PERMISSIONS_DIR);
 }
 
 /* void addEntryFile (in AUTF8String aZipEntry, in PRInt32 aCompression,
  *                    in nsIFile aFile, in boolean aQueue); */
 NS_IMETHODIMP nsZipWriter::AddEntryFile(const nsACString & aZipEntry,
                                         PRInt32 aCompression, nsIFile *aFile,
                                         PRBool aQueue)
 {
@@ -403,29 +404,33 @@ NS_IMETHODIMP nsZipWriter::AddEntryFile(
     rv = aFile->IsDirectory(&isdir);
     NS_ENSURE_SUCCESS(rv, rv);
 
     PRInt64 modtime;
     rv = aFile->GetLastModifiedTime(&modtime);
     NS_ENSURE_SUCCESS(rv, rv);
     modtime *= PR_USEC_PER_MSEC;
 
+    PRUint32 permissions;
+    rv = aFile->GetPermissions(&permissions);
+    NS_ENSURE_SUCCESS(rv, rv);
+
     if (isdir)
-        return InternalAddEntryDirectory(aZipEntry, modtime);
+        return InternalAddEntryDirectory(aZipEntry, modtime, permissions);
 
     if (mEntryHash.Get(aZipEntry, nsnull))
         return NS_ERROR_FILE_ALREADY_EXISTS;
 
     nsCOMPtr<nsIInputStream> inputStream;
     rv = NS_NewLocalFileInputStream(getter_AddRefs(inputStream),
                                     aFile);
     NS_ENSURE_SUCCESS(rv, rv);
 
     rv = AddEntryStream(aZipEntry, modtime, aCompression, inputStream,
-                        PR_FALSE);
+                        PR_FALSE, permissions);
     NS_ENSURE_SUCCESS(rv, rv);
 
     return inputStream->Close();
 }
 
 /* void addEntryChannel (in AUTF8String aZipEntry, in PRTime aModTime,
  *                       in PRInt32 aCompression, in nsIChannel aChannel,
  *                       in boolean aQueue); */
@@ -440,71 +445,88 @@ NS_IMETHODIMP nsZipWriter::AddEntryChann
         return NS_ERROR_NOT_INITIALIZED;
 
     if (aQueue) {
         nsZipQueueItem item;
         item.mOperation = OPERATION_ADD;
         item.mZipEntry = aZipEntry;
         item.mModTime = aModTime;
         item.mCompression = aCompression;
+        item.mPermissions = PERMISSIONS_FILE;
         item.mChannel = aChannel;
         if (!mQueue.AppendElement(item))
             return NS_ERROR_OUT_OF_MEMORY;
         return NS_OK;
     }
 
     if (mInQueue)
         return NS_ERROR_IN_PROGRESS;
     if (mEntryHash.Get(aZipEntry, nsnull))
         return NS_ERROR_FILE_ALREADY_EXISTS;
 
     nsCOMPtr<nsIInputStream> inputStream;
     nsresult rv = aChannel->Open(getter_AddRefs(inputStream));
     NS_ENSURE_SUCCESS(rv, rv);
 
     rv = AddEntryStream(aZipEntry, aModTime, aCompression, inputStream,
-                        PR_FALSE);
+                        PR_FALSE, PERMISSIONS_FILE);
     NS_ENSURE_SUCCESS(rv, rv);
 
     return inputStream->Close();
 }
 
 /* void addEntryStream (in AUTF8String aZipEntry, in PRTime aModTime,
  *                      in PRInt32 aCompression, in nsIInputStream aStream,
  *                      in boolean aQueue); */
 NS_IMETHODIMP nsZipWriter::AddEntryStream(const nsACString & aZipEntry,
                                           PRTime aModTime,
                                           PRInt32 aCompression,
                                           nsIInputStream *aStream,
                                           PRBool aQueue)
 {
+    return AddEntryStream(aZipEntry, aModTime, aCompression, aStream, aQueue,
+                          PERMISSIONS_FILE);
+}
+
+/* void addEntryStream (in AUTF8String aZipEntry, in PRTime aModTime,
+ *                      in PRInt32 aCompression, in nsIInputStream aStream,
+ *                      in boolean aQueue, in unsigned long aPermissions); */
+nsresult nsZipWriter::AddEntryStream(const nsACString & aZipEntry,
+                                     PRTime aModTime,
+                                     PRInt32 aCompression,
+                                     nsIInputStream *aStream,
+                                     PRBool aQueue,
+                                     PRUint32 aPermissions)
+{
     NS_ENSURE_ARG_POINTER(aStream);
     if (!mStream)
         return NS_ERROR_NOT_INITIALIZED;
 
     if (aQueue) {
         nsZipQueueItem item;
         item.mOperation = OPERATION_ADD;
         item.mZipEntry = aZipEntry;
         item.mModTime = aModTime;
         item.mCompression = aCompression;
+        item.mPermissions = aPermissions;
         item.mStream = aStream;
         if (!mQueue.AppendElement(item))
             return NS_ERROR_OUT_OF_MEMORY;
         return NS_OK;
     }
 
     if (mInQueue)
         return NS_ERROR_IN_PROGRESS;
     if (mEntryHash.Get(aZipEntry, nsnull))
         return NS_ERROR_FILE_ALREADY_EXISTS;
 
     nsRefPtr<nsZipHeader> header = new nsZipHeader();
     NS_ENSURE_TRUE(header, NS_ERROR_OUT_OF_MEMORY);
-    header->Init(aZipEntry, aModTime, ZIP_ATTRS_FILE, mCDSOffset);
+    header->Init(aZipEntry, aModTime, ZIP_ATTRS(aPermissions, ZIP_ATTRS_FILE),
+                 mCDSOffset);
     nsresult rv = header->WriteFileHeader(mStream);
     if (NS_FAILED(rv)) {
         SeekCDS();
         return rv;
     }
 
     nsRefPtr<nsZipDataStream> stream = new nsZipDataStream();
     if (!stream) {
@@ -737,28 +759,31 @@ NS_IMETHODIMP nsZipWriter::OnStopRequest
     }
 
     BeginProcessingNextItem();
 
     return NS_OK;
 }
 
 nsresult nsZipWriter::InternalAddEntryDirectory(const nsACString & aZipEntry,
-                                                PRTime aModTime)
+                                                PRTime aModTime,
+                                                PRUint32 aPermissions)
 {
     nsRefPtr<nsZipHeader> header = new nsZipHeader();
     NS_ENSURE_TRUE(header, NS_ERROR_OUT_OF_MEMORY);
 
+    PRUint32 zipAttributes = ZIP_ATTRS(aPermissions, ZIP_ATTRS_DIRECTORY);
+
     if (aZipEntry.Last() != '/') {
         nsCString dirPath;
         dirPath.Assign(aZipEntry + NS_LITERAL_CSTRING("/"));
-        header->Init(dirPath, aModTime, ZIP_ATTRS_DIRECTORY, mCDSOffset);
+        header->Init(dirPath, aModTime, zipAttributes, mCDSOffset);
     }
     else
-        header->Init(aZipEntry, aModTime, ZIP_ATTRS_DIRECTORY, mCDSOffset);
+        header->Init(aZipEntry, aModTime, zipAttributes, mCDSOffset);
 
     if (mEntryHash.Get(header->mName, nsnull))
         return NS_ERROR_FILE_ALREADY_EXISTS;
 
     nsresult rv = header->WriteFileHeader(mStream);
     if (NS_FAILED(rv)) {
         Cleanup();
         return rv;
@@ -855,30 +880,35 @@ inline nsresult nsZipWriter::BeginProces
         PRBool isdir;
         rv = aItem->mFile->IsDirectory(&isdir);
         NS_ENSURE_SUCCESS(rv, rv);
 
         rv = aItem->mFile->GetLastModifiedTime(&aItem->mModTime);
         NS_ENSURE_SUCCESS(rv, rv);
         aItem->mModTime *= PR_USEC_PER_MSEC;
 
+        rv = aItem->mFile->GetPermissions(&aItem->mPermissions);
+        NS_ENSURE_SUCCESS(rv, rv);
+
         if (!isdir) {
             // Set up for fall through to stream reader
             rv = NS_NewLocalFileInputStream(getter_AddRefs(aItem->mStream),
                                             aItem->mFile);
             NS_ENSURE_SUCCESS(rv, rv);
         }
         // If a dir then this will fall through to the plain dir addition
     }
 
+    PRUint32 zipAttributes = ZIP_ATTRS(aItem->mPermissions, ZIP_ATTRS_FILE);
+
     if (aItem->mStream) {
         nsRefPtr<nsZipHeader> header = new nsZipHeader();
         NS_ENSURE_TRUE(header, NS_ERROR_OUT_OF_MEMORY);
 
-        header->Init(aItem->mZipEntry, aItem->mModTime, ZIP_ATTRS_FILE,
+        header->Init(aItem->mZipEntry, aItem->mModTime, zipAttributes,
                      mCDSOffset);
         nsresult rv = header->WriteFileHeader(mStream);
         NS_ENSURE_SUCCESS(rv, rv);
 
         nsRefPtr<nsZipDataStream> stream = new nsZipDataStream();
         rv = stream->Init(this, mStream, header, aItem->mCompression);
         NS_ENSURE_SUCCESS(rv, rv);
 
@@ -892,32 +922,33 @@ inline nsresult nsZipWriter::BeginProces
 
         return NS_OK;
     }
 
     if (aItem->mChannel) {
         nsRefPtr<nsZipHeader> header = new nsZipHeader();
         NS_ENSURE_TRUE(header, NS_ERROR_OUT_OF_MEMORY);
 
-        header->Init(aItem->mZipEntry, aItem->mModTime, ZIP_ATTRS_FILE,
+        header->Init(aItem->mZipEntry, aItem->mModTime, zipAttributes,
                      mCDSOffset);
 
         nsRefPtr<nsZipDataStream> stream = new nsZipDataStream();
         NS_ENSURE_TRUE(stream, NS_ERROR_OUT_OF_MEMORY);
         nsresult rv = stream->Init(this, mStream, header, aItem->mCompression);
         NS_ENSURE_SUCCESS(rv, rv);
         rv = aItem->mChannel->AsyncOpen(stream, nsnull);
         NS_ENSURE_SUCCESS(rv, rv);
 
         return NS_OK;
     }
 
     // Must be plain directory addition
     *complete = PR_TRUE;
-    return InternalAddEntryDirectory(aItem->mZipEntry, aItem->mModTime);
+    return InternalAddEntryDirectory(aItem->mZipEntry, aItem->mModTime,
+                                     aItem->mPermissions);
 }
 
 inline nsresult nsZipWriter::BeginProcessingRemoval(PRInt32 aPos)
 {
     // Open the zip file for reading
     nsCOMPtr<nsIInputStream> inputStream;
     nsresult rv = NS_NewLocalFileInputStream(getter_AddRefs(inputStream),
                                              mFile);
diff -r a131999fa900 modules/libjar/zipwriter/src/nsZipWriter.h
--- a/modules/libjar/zipwriter/src/nsZipWriter.h	Thu Oct 30 23:42:02 2008 -0700
+++ b/modules/libjar/zipwriter/src/nsZipWriter.h	Sat Nov 01 13:47:50 2008 +0200
@@ -62,16 +62,17 @@ public:
 public:
     PRUint32 mOperation;
     nsCString mZipEntry;
     nsCOMPtr<nsIFile> mFile;
     nsCOMPtr<nsIChannel> mChannel;
     nsCOMPtr<nsIInputStream> mStream;
     PRTime mModTime;
     PRInt32 mCompression;
+    PRUint32 mPermissions;
 };
 
 class nsZipWriter : public nsIZipWriter,
                     public nsIRequestObserver
 {
 public:
     NS_DECL_ISUPPORTS
     NS_DECL_NSIZIPWRITER
@@ -95,16 +96,19 @@ private:
     nsTArray<nsZipQueueItem> mQueue;
     nsDataHashtable<nsCStringHashKey, PRInt32> mEntryHash;
     nsCString mComment;
 
     nsresult SeekCDS();
     void Cleanup();
     nsresult ReadFile(nsIFile *aFile);
     nsresult InternalAddEntryDirectory(const nsACString & aZipEntry,
-                                       PRTime aModTime);
+                                       PRTime aModTime, PRUint32 aPermissions);
     nsresult BeginProcessingAddition(nsZipQueueItem* aItem, PRBool* complete);
     nsresult BeginProcessingRemoval(PRInt32 aPos);
+    nsresult AddEntryStream(const nsACString & aZipEntry, PRTime aModTime,
+                            PRInt32 aCompression, nsIInputStream *aStream,
+                            PRBool aQueue, PRUint32 aPermissions);
     void BeginProcessingNextItem();
     void FinishQueue(nsresult aStatus);
 };
 
 #endif
diff -r a131999fa900 modules/libjar/zipwriter/test/unit/test_bug446708.js
--- a/modules/libjar/zipwriter/test/unit/test_bug446708.js	Thu Oct 30 23:42:02 2008 -0700
+++ b/modules/libjar/zipwriter/test/unit/test_bug446708.js	Sat Nov 01 13:47:50 2008 +0200
@@ -25,28 +25,13 @@ function AddToZip(zipWriter, path, file)
     }
   }
   
   // ...otherwise, we're done
 }
 
 function RecursivelyZipDirectory(bundle)
 {
-  // create directory service
-  var dirUtils = Components.classes["@mozilla.org/file/directory_service;1"]
-      .createInstance(Components.interfaces.nsIProperties);
-  
-  // get the temp dir, where our temporary zip attachments can be stored
-  var tempFile = dirUtils.get("TmpD", Components.interfaces.nsIFile).clone();
-
-  // create unique file there
-  tempFile.append(bundle.leafName + ".zip");
-  tempFile.createUnique(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, 
-                        0600);
-  
-  zipW.open(tempFile, PR_RDWR | PR_CREATE_FILE | PR_TRUNCATE);
-  
+  zipW.open(tmpFile, PR_RDWR | PR_CREATE_FILE | PR_TRUNCATE);
   AddToZip(zipW, "", bundle); 
-  
-  // we're done.
   zipW.close();
 }
 
diff -r a131999fa900 modules/libjar/zipwriter/test/unit/test_zippermissions.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/modules/libjar/zipwriter/test/unit/test_zippermissions.js	Sat Nov 01 13:47:50 2008 +0200
@@ -0,0 +1,106 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Zip Writer Component.
+ *
+ * The Initial Developer of the Original Code is
+ * Dave Townsend <dtownsend@oxymoronical.com>.
+ *
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK *****
+ */
+
+const DATA = "ZIP WRITER TEST DATA";
+
+var TESTS = [];
+
+function build_tests() {
+  var id = 0;
+
+  // Minimum mode is 0400
+  for (let u = 4; u <= 7; u++) {
+    for (let g = 0; g <= 7; g++) {
+      for (let o = 0; o <= 7; o++) {
+        TESTS[id] = {
+          name: "test" + u + g + o,
+          permission: (u << 6) + (g << 3) + o
+        };
+        id++;
+      }
+    }
+  }
+}
+
+function run_test() {
+  build_tests();
+
+  var foStream = Cc["@mozilla.org/network/file-output-stream;1"].
+                 createInstance(Ci.nsIFileOutputStream);
+
+  var tmp = tmpDir.clone();
+  tmp.append("temp-permissions");
+  tmp.createUnique(Ci.nsILocalFile.DIRECTORY_TYPE, 0755);
+
+  var file = tmp.clone();
+  file.append("tempfile");
+
+  zipW.open(tmpFile, PR_RDWR | PR_CREATE_FILE | PR_TRUNCATE);
+  for (let i = 0; i < TESTS.length; i++) {
+    // Open the file with the permissions to match how the zipreader extracts
+    // This obeys the umask
+    foStream.init(file, 0x02 | 0x08 | 0x20, TESTS[i].permission, 0);
+    foStream.close();
+
+    // umask may have altered the permissions so test against what they really were.
+    // This reduces the coverage of the test but there isn't much we can do
+    var perm = file.permissions & 0xfff;
+    if (TESTS[i].permission != perm) {
+      dump("File permissions for " + TESTS[i].name + " were " + perm.toString(8) + "\n");
+      TESTS[i].permission = perm;
+    }
+
+    zipW.addEntryFile(TESTS[i].name, Ci.nsIZipWriter.COMPRESSION_NONE, file, false);
+    file.permissions = 0600;
+    file.remove(true);
+  }
+  zipW.close();
+
+  zipR = new ZipReader(tmpFile);
+  for (let i = 0; i < TESTS.length; i++) {
+    zipR.extract(TESTS[i].name, file);
+    dump("Testing file permissions for " + TESTS[i].name + "\n");
+    do_check_eq(file.permissions & 0xfff, TESTS[i].permission);
+    do_check_false(file.isDirectory());
+    file.permissions = 0600;
+    file.remove(true);
+  }
+  zipR.close();
+
+  tmp.remove(true);
+}
diff -r a131999fa900 netwerk/cookie/public/nsICookie2.idl
--- a/netwerk/cookie/public/nsICookie2.idl	Thu Oct 30 23:42:02 2008 -0700
+++ b/netwerk/cookie/public/nsICookie2.idl	Sat Nov 01 13:47:50 2008 +0200
@@ -39,17 +39,17 @@
 #include "nsICookie.idl"
 
 /** 
  * Main cookie object interface for use by consumers:
  * extends nsICookie, a frozen interface for external
  * access of cookie objects
  */
 
-[scriptable, uuid(736619fe-8d09-4e59-8223-32f176c22977)]
+[scriptable, uuid(8587f4e0-870c-11dd-ad8b-0800200c9a66)]
 
 interface nsICookie2 : nsICookie
 {
 
     /**
      * the host (possibly fully qualified) of the cookie,
      * without a leading dot to represent if it is a
      * domain cookie.
@@ -73,10 +73,16 @@ interface nsICookie2 : nsICookie
      */
     readonly attribute PRInt64 expiry;
 
     /**
      * true if the cookie is an http only cookie
      */
     readonly attribute boolean isHttpOnly;
 
+    /**
+     * the creation time of the cookie, in microseconds
+     * since midnight (00:00:00), January 1, 1970 UTC.
+     */
+    readonly attribute PRInt64 creationTime;
+
 
 };
diff -r a131999fa900 netwerk/cookie/src/nsCookie.cpp
--- a/netwerk/cookie/src/nsCookie.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/netwerk/cookie/src/nsCookie.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -137,16 +137,17 @@ NS_IMETHODIMP nsCookie::GetPath(nsACStri
 NS_IMETHODIMP nsCookie::GetPath(nsACString &aPath)         { aPath = Path();            return NS_OK; }
 NS_IMETHODIMP nsCookie::GetExpiry(PRInt64 *aExpiry)        { *aExpiry = Expiry();       return NS_OK; }
 NS_IMETHODIMP nsCookie::GetIsSession(PRBool *aIsSession)   { *aIsSession = IsSession(); return NS_OK; }
 NS_IMETHODIMP nsCookie::GetIsDomain(PRBool *aIsDomain)     { *aIsDomain = IsDomain();   return NS_OK; }
 NS_IMETHODIMP nsCookie::GetIsSecure(PRBool *aIsSecure)     { *aIsSecure = IsSecure();   return NS_OK; }
 NS_IMETHODIMP nsCookie::GetIsHttpOnly(PRBool *aHttpOnly)   { *aHttpOnly = IsHttpOnly(); return NS_OK; }
 NS_IMETHODIMP nsCookie::GetStatus(nsCookieStatus *aStatus) { *aStatus = 0;              return NS_OK; }
 NS_IMETHODIMP nsCookie::GetPolicy(nsCookiePolicy *aPolicy) { *aPolicy = 0;              return NS_OK; }
+NS_IMETHODIMP nsCookie::GetCreationTime(PRInt64 *aCreation){ *aCreation = CreationID(); return NS_OK; }
 
 // compatibility method, for use with the legacy nsICookie interface.
 // here, expires == 0 denotes a session cookie.
 NS_IMETHODIMP
 nsCookie::GetExpires(PRUint64 *aExpires)
 {
   if (IsSession()) {
     *aExpires = 0;
diff -r a131999fa900 netwerk/test/unit/test_bug411952.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/netwerk/test/unit/test_bug411952.js	Sat Nov 01 13:47:50 2008 +0200
@@ -0,0 +1,38 @@
+const Cc = Components.classes;
+const Ci = Components.interfaces;
+
+function run_test() {
+  try {
+    var cm = Cc["@mozilla.org/cookiemanager;1"].
+             getService(Ci.nsICookieManager2);
+    do_check_neq(cm, null, "Retrieving the cookie manager failed");
+
+    const time = (new Date("Jan 1, 2030")).getTime() / 1000;
+    cm.add("example.com", "/", "C", "V", false, true, false, time);
+    const now = Math.floor((new Date()).getTime() / 1000);
+
+    var enumerator = cm.enumerator, found = false;
+    while (enumerator.hasMoreElements()) {
+      var cookie = enumerator.getNext().QueryInterface(Ci.nsICookie2);
+      if (cookie.host == "example.com" &&
+          cookie.path == "/" &&
+          cookie.name == "C") {
+        do_check_true("creationTime" in cookie,
+          "creationTime attribute is not accessible on the cookie");
+        var creationTime = Math.floor(cookie.creationTime / 1000000);
+        // allow the times to slip by one second at most,
+        // which should be fine under normal circumstances.
+        do_check_true(Math.abs(creationTime - now) <= 1,
+          "Cookie's creationTime is set incorrectly");
+        found = true;
+        break;
+      }
+    }
+
+    do_check_true(found, "Didn't find the cookie we were after");
+  } catch (e) {
+    do_throw("Unexpected exception: " + e.toString());
+  }
+
+  do_test_finished();
+}
diff -r a131999fa900 storage/src/mozStorageService.cpp
--- a/storage/src/mozStorageService.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/storage/src/mozStorageService.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -41,30 +41,50 @@
 
 #include "mozStorageService.h"
 #include "mozStorageConnection.h"
 #include "nsCRT.h"
 #include "plstr.h"
 #include "prinit.h"
 #include "nsAutoLock.h"
 #include "nsAutoPtr.h"
+#include "nsEmbedCID.h"
 #include "mozStoragePrivateHelpers.h"
 
 #include "sqlite3.h"
+
+#include "nsIPromptService.h"
 
 NS_IMPL_THREADSAFE_ISUPPORTS1(mozStorageService, mozIStorageService)
 
 mozStorageService *mozStorageService::gStorageService = nsnull;
 
 mozStorageService *
 mozStorageService::GetSingleton()
 {
     if (gStorageService) {
         NS_ADDREF(gStorageService);
         return gStorageService;
+    }
+
+    // Ensure that we are using the same version of SQLite that we compiled with
+    // or newer.  Our configure check ensures we are using a new enough version
+    // at compile time.
+    if (SQLITE_VERSION_NUMBER > sqlite3_libversion_number()) {
+        nsCOMPtr<nsIPromptService> ps =
+            do_GetService(NS_PROMPTSERVICE_CONTRACTID);
+        if (ps) {
+            nsAutoString title, message;
+            title.AppendASCII("SQLite Version Error");
+            message.AppendASCII("The application has been updated, but your "
+                                "version of SQLite is too old and the "
+                                "application cannot run.");
+            (void)ps->Alert(nsnull, title.get(), message.get());
+        }
+        PR_Abort();
     }
 
     gStorageService = new mozStorageService();
     if (gStorageService) {
         NS_ADDREF(gStorageService);
         if (NS_FAILED(gStorageService->Init()))
             NS_RELEASE(gStorageService);
     }
diff -r a131999fa900 toolkit/components/downloads/src/nsDownloadScanner.cpp
--- a/toolkit/components/downloads/src/nsDownloadScanner.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/toolkit/components/downloads/src/nsDownloadScanner.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -146,16 +146,19 @@
   { 0xb50563d1, 0x16b6, 0x43c2, { 0xa6, 0x6a, 0xfa, 0xe6, 0xd2, 0x11, 0xf2, \
   0xea } }
 #endif
 static const GUID GUID_MozillaVirusScannerPromptGeneric =
   MOZ_VIRUS_SCANNER_PROMPT_GUID;
 
 // Initial timeout is 30 seconds
 #define WATCHDOG_TIMEOUT (30*PR_USEC_PER_SEC)
+
+// Maximum length for URI's passed into IAE
+#define MAX_IAEURILENGTH 1683
 
 class nsDownloadScannerWatchdog 
 {
   typedef nsDownloadScanner::Scan Scan;
 public:
   nsDownloadScannerWatchdog();
   ~nsDownloadScannerWatchdog();
 
@@ -382,16 +385,19 @@ nsDownloadScanner::CheckPolicy(nsIURI *a
   hr = ae->CheckPolicy();
 
   if (hr == S_OK)
     return AVPOLICY_DOWNLOAD;
 
   if (hr == S_FALSE)
     return AVPOLICY_PROMPT;
 
+  if (hr == E_INVALIDARG)
+    return AVPOLICY_PROMPT;
+
   return AVPOLICY_BLOCKED;
 }
 
 #ifndef THREAD_MODE_BACKGROUND_BEGIN
 #define THREAD_MODE_BACKGROUND_BEGIN 0x00010000
 #endif
 
 #ifndef THREAD_MODE_BACKGROUND_END
@@ -475,16 +481,23 @@ nsDownloadScanner::Scan::Start()
   // Get the origin
   nsCOMPtr<nsIURI> uri;
   rv = mDownload->GetSource(getter_AddRefs(uri));
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCAutoString origin;
   rv = uri->GetSpec(origin);
   NS_ENSURE_SUCCESS(rv, rv);
+
+  // Certain virus interfaces do not like extremely long uris.
+  // Chop off the path and cgi data and just pass the base domain. 
+  if (origin.Length() > MAX_IAEURILENGTH) {
+    rv = uri->GetPrePath(origin);
+    NS_ENSURE_SUCCESS(rv, rv);
+  }
 
   CopyUTF8toUTF16(origin, mOrigin);
 
   // We count https/ftp/http as an http download
   PRBool isHttp(PR_FALSE), isFtp(PR_FALSE), isHttps(PR_FALSE);
   nsCOMPtr<nsIURI> innerURI = NS_GetInnermostURI(uri);
   if (!innerURI) innerURI = uri;
   (void)innerURI->SchemeIs("http", &isHttp);
@@ -599,16 +612,20 @@ nsDownloadScanner::Scan::DoScanAES()
       if(gotException) {
         newState = AVSCAN_FAILED;
       }
       else if (SUCCEEDED(hr)) { // Passed the scan
         newState = AVSCAN_GOOD;
       }
       else if (HRESULT_CODE(hr) == ERROR_FILE_NOT_FOUND) {
         NS_WARNING("Downloaded file disappeared before it could be scanned");
+        newState = AVSCAN_FAILED;
+      }
+      else if (hr == E_INVALIDARG) {
+        NS_WARNING("IAttachementExecute returned invalid argument error");
         newState = AVSCAN_FAILED;
       }
       else { 
         newState = AVSCAN_UGLY;
       }
     }
     else {
       newState = AVSCAN_FAILED;
diff -r a131999fa900 toolkit/components/places/src/nsPlacesDBFlush.js
--- a/toolkit/components/places/src/nsPlacesDBFlush.js	Thu Oct 30 23:42:02 2008 -0700
+++ b/toolkit/components/places/src/nsPlacesDBFlush.js	Sat Nov 01 13:47:50 2008 +0200
@@ -197,35 +197,32 @@ nsPlacesDBFlush.prototype = {
 
     let statements = [];
     for (let i = 0; i < aTableNames.length; i++)
       statements.push(this._getSyncTableStatement(aTableNames[i]));
 
     // Execute sync statements async in a transaction
     // XXX due to a bug in sqlite, we cannot wrap these in a transaction.  See
     //     https://bugzilla.mozilla.org/show_bug.cgi?id=462379#c2 for details.
-    this._db.executeAsync(statements, statements.length, this);
+    //this._db.executeAsync(statements, statements.length, this);
 
-    // XXX Disabled due to persistent test failures on the tinderbox.
-    /*
     let self = this;
     let listener = {
       // We also need to batch the two handleCompletion objects into one.
-      _count: 0,
+      _count: statements.length,
       handleError: function(aError) self.handleError(aError),
       handleCompletion: function(aReason) {
-        this._count++;
-        if (this._count == 2) {
-          // we have gotten both notifications
+        this._count--;
+        if (this._count == 0) {
+          // we have gotten all notifications
           self.handleCompletion(aReason);
         }
       }
     };
     statements.forEach(function(stmt) stmt.executeAsync(listener));
-    */
 
     // Finalize statements, otherwise we could get in trouble
     statements.forEach(function(stmt) stmt.finalize());
   },
 
   /**
    * Generate the statement to synchronizes the moz_{aTableName} and
    * moz_{aTableName}_temp by copying all the data from the temporary table
diff -r a131999fa900 toolkit/components/places/src/nsTaggingService.js
--- a/toolkit/components/places/src/nsTaggingService.js	Thu Oct 30 23:42:02 2008 -0700
+++ b/toolkit/components/places/src/nsTaggingService.js	Sat Nov 01 13:47:50 2008 +0200
@@ -78,16 +78,17 @@ TaggingService.prototype = {
 
   get _tagsResult() {
     if (!this.__tagsResult) {
       var options = this._history.getNewQueryOptions();
       var query = this._history.getNewQuery();
       query.setFolders([this._bms.tagsFolder], 1);
       this.__tagsResult = this._history.executeQuery(query, options);
       this.__tagsResult.root.containerOpen = true;
+      this.__tagsResult.viewer = this;
 
       // we need to null out the result on shutdown
       var observerSvc = Cc[OBSS_CONTRACTID].getService(Ci.nsIObserverService);
       observerSvc.addObserver(this, "xpcom-shutdown", false);
     }
     return this.__tagsResult;
   },
 
@@ -275,36 +276,278 @@ TaggingService.prototype = {
 
     // sort the tag list
     tags.sort();
     aCount.value = tags.length;
     return tags;
   },
 
   // nsITaggingService
+  _allTags: null,
   get allTags() {
-    var tags = [];
-    var root = this._tagsResult.root;
-    var cc = root.childCount;
-    for (var j=0; j < cc; j++) {
-      var child = root.getChild(j);
-      tags.push(child.title);
+    if (!this._allTags) {
+      this._allTags = [];
+      var root = this._tagsResult.root;
+      var cc = root.childCount;
+      for (var j=0; j < cc; j++) {
+        var child = root.getChild(j);
+        this._allTags.push(child.title);
+      }
+
+      // sort the tag list
+      this.allTags.sort();
     }
-
-    // sort the tag list
-    tags.sort();
-    return tags;
+    return this._allTags;
   },
 
   // nsIObserver
-  observe: function TS_observe(subject, topic, data) {
-    if (topic == "xpcom-shutdown") {
+  observe: function TS_observe(aSubject, aTopic, aData) {
+    if (aTopic == "xpcom-shutdown") {
       this.__tagsResult.root.containerOpen = false;
+      this.__tagsResult.viewer = null;
       this.__tagsResult = null;
       var observerSvc = Cc[OBSS_CONTRACTID].getService(Ci.nsIObserverService);
       observerSvc.removeObserver(this, "xpcom-shutdown");
     }
+  },
+
+  // nsINavHistoryResultViewer
+  // Used to invalidate the cached tag list
+  itemInserted: function() this._allTags = null,
+  itemRemoved: function() this._allTags = null,
+  itemMoved: function() {},
+  itemChanged: function() {},
+  itemReplaced: function() {},
+  containerOpened: function() {},
+  containerClosed: function() {},
+  invalidateContainer: function() this._allTags = null,
+  invalidateAll: function() this._allTags = null,
+  sortingChanged: function() {},
+  result: null
+};
+
+// Implements nsIAutoCompleteResult
+function TagAutoCompleteResult(searchString, searchResult,
+                               defaultIndex, errorDescription,
+                               results, comments) {
+  this._searchString = searchString;
+  this._searchResult = searchResult;
+  this._defaultIndex = defaultIndex;
+  this._errorDescription = errorDescription;
+  this._results = results;
+  this._comments = comments;
+}
+
+TagAutoCompleteResult.prototype = {
+  
+  /**
+   * The original search string
+   */
+  get searchString() {
+    return this._searchString;
+  },
+
+  /**
+   * The result code of this result object, either:
+   *         RESULT_IGNORED   (invalid searchString)
+   *         RESULT_FAILURE   (failure)
+   *         RESULT_NOMATCH   (no matches found)
+   *         RESULT_SUCCESS   (matches found)
+   */
+  get searchResult() {
+    return this._searchResult;
+  },
+
+  /**
+   * Index of the default item that should be entered if none is selected
+   */
+  get defaultIndex() {
+    return this._defaultIndex;
+  },
+
+  /**
+   * A string describing the cause of a search failure
+   */
+  get errorDescription() {
+    return this._errorDescription;
+  },
+
+  /**
+   * The number of matches
+   */
+  get matchCount() {
+    return this._results.length;
+  },
+
+  /**
+   * Get the value of the result at the given index
+   */
+  getValueAt: function PTACR_getValueAt(index) {
+    return this._results[index];
+  },
+
+  /**
+   * Get the comment of the result at the given index
+   */
+  getCommentAt: function PTACR_getCommentAt(index) {
+    return this._comments[index];
+  },
+
+  /**
+   * Get the style hint for the result at the given index
+   */
+  getStyleAt: function PTACR_getStyleAt(index) {
+    if (!this._comments[index])
+      return null;  // not a category label, so no special styling
+
+    if (index == 0)
+      return "suggestfirst";  // category label on first line of results
+
+    return "suggesthint";   // category label on any other line of results
+  },
+
+  /**
+   * Get the image for the result at the given index
+   */
+  getImageAt: function PTACR_getImageAt(index) {
+    return null;
+  },
+
+  /**
+   * Remove the value at the given index from the autocomplete results.
+   * If removeFromDb is set to true, the value should be removed from
+   * persistent storage as well.
+   */
+  removeValueAt: function PTACR_removeValueAt(index, removeFromDb) {
+    this._results.splice(index, 1);
+    this._comments.splice(index, 1);
+  },
+
+  QueryInterface: function(aIID) {
+    if (!aIID.equals(Ci.nsIAutoCompleteResult) && !aIID.equals(Ci.nsISupports))
+        throw Components.results.NS_ERROR_NO_INTERFACE;
+    return this;
   }
 };
 
+// Implements nsIAutoCompleteSearch
+function TagAutoCompleteSearch() {
+}
+
+TagAutoCompleteSearch.prototype = {
+  _stopped : false, 
+
+  get tagging() {
+    let svc = Cc["@mozilla.org/browser/tagging-service;1"].
+              getService(Ci.nsITaggingService);
+    this.__defineGetter__("tagging", function() svc);
+    return this.tagging;
+  },
+
+  /*
+   * Search for a given string and notify a listener (either synchronously
+   * or asynchronously) of the result
+   *
+   * @param searchString - The string to search for
+   * @param searchParam - An extra parameter
+   * @param previousResult - A previous result to use for faster searching
+   * @param listener - A listener to notify when the search is complete
+   */
+  startSearch: function PTACS_startSearch(searchString, searchParam, result, listener) {
+    var searchResults = this.tagging.allTags;
+    var results = [];
+    var comments = [];
+    this._stopped = false;
+
+    // only search on characters for the last tag
+    var index = Math.max(searchString.lastIndexOf(","), 
+      searchString.lastIndexOf(";"));
+    var before = ''; 
+    if (index != -1) {  
+      before = searchString.slice(0, index+1);
+      searchString = searchString.slice(index+1);
+      // skip past whitespace
+      var m = searchString.match(/\s+/);
+      if (m) {
+         before += m[0];
+         searchString = searchString.slice(m[0].length);
+      }
+    }
+
+    if (!searchString.length) {
+      var newResult = new TagAutoCompleteResult(searchString,
+        Ci.nsIAutoCompleteResult.RESULT_NOMATCH, 0, "", results, comments);
+      listener.onSearchResult(self, newResult);
+      return;
+    }
+    
+    var self = this;
+    // generator: if yields true, not done
+    function doSearch() {
+      var i = 0;
+      while (i < searchResults.length) {
+        if (self._stopped)
+          yield false;
+        // for each match, prepend what the user has typed so far
+        var pattern = new RegExp("(^" + searchResults[i] + "$|" + searchResults[i] + "(,|;))");
+        if (searchResults[i].indexOf(searchString) == 0 &&
+            !pattern.test(before)) {
+          results.push(before + searchResults[i]);
+          comments.push(searchResults[i]);
+        }
+    
+        ++i;
+        // 100 loops per yield
+        if ((i % 100) == 0) {
+          var newResult = new TagAutoCompleteResult(searchString,
+            Ci.nsIAutoCompleteResult.RESULT_SUCCESS_ONGOING, 0, "", results, comments);
+          listener.onSearchResult(self, newResult);
+          yield true;
+        } 
+      }
+
+      var newResult = new TagAutoCompleteResult(searchString,
+        Ci.nsIAutoCompleteResult.RESULT_SUCCESS, 0, "", results, comments);
+      listener.onSearchResult(self, newResult);
+      yield false;
+    }
+    
+    // chunk the search results via a generator
+    var gen = doSearch();
+    function driveGenerator() {
+      if (gen.next()) { 
+        var timer = Cc["@mozilla.org/timer;1"]
+          .createInstance(Components.interfaces.nsITimer);
+        self._callback = driveGenerator;
+        timer.initWithCallback(self, 0, timer.TYPE_ONE_SHOT);
+      }
+      else {
+        gen.close();	
+      }
+    }
+    driveGenerator();
+  },
+
+  notify: function PTACS_notify(timer) {
+    if (this._callback) 
+      this._callback();
+  },
+
+  /*
+   * Stop an asynchronous search that is in progress
+   */
+  stopSearch: function PTACS_stopSearch() {
+    this._stopped = true;
+  },
+
+  // nsISupports
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIAutoCompleteSearch,
+                                         Ci.nsITimerCallback]), 
+
+  classDescription: "Places Tag AutoComplete",
+  contractID: "@mozilla.org/autocomplete/search;1?name=places-tag-autocomplete",
+  classID: Components.ID("{1dcc23b0-d4cb-11dc-9ad6-479d56d89593}")
+};
+
+var component = [TaggingService, TagAutoCompleteSearch];
 function NSGetModule(compMgr, fileSpec) {
-  return XPCOMUtils.generateModule([TaggingService]);
+  return XPCOMUtils.generateModule(component);
 }
diff -r a131999fa900 toolkit/components/places/tests/unit/test_tag_autocomplete_search.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/components/places/tests/unit/test_tag_autocomplete_search.js	Sat Nov 01 13:47:50 2008 +0200
@@ -0,0 +1,167 @@
+/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is tag autocomplete search unit test code.
+ *
+ * The Initial Developer of the Original Code is POTI Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Matt Crocker <matt@songbirdnest.com>
+ *   Seth Spitzer <sspitzer@mozilla.org>
+ *   Adam Souzis <adam@souzis.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+var current_test = 0;
+
+function AutoCompleteInput(aSearches) {
+  this.searches = aSearches;
+}
+AutoCompleteInput.prototype = {
+  constructor: AutoCompleteInput, 
+
+  searches: null,
+  
+  minResultsForPopup: 0,
+  timeout: 10,
+  searchParam: "",
+  textValue: "",
+  disableAutoComplete: false,  
+  completeDefaultIndex: false,
+  
+  get searchCount() {
+    return this.searches.length;
+  },
+  
+  getSearchAt: function(aIndex) {
+    return this.searches[aIndex];
+  },
+  
+  onSearchBegin: function() {},
+  onSearchComplete: function() {},
+  
+  popupOpen: false,  
+  
+  popup: { 
+    setSelectedIndex: function(aIndex) {},
+    invalidate: function() {},
+
+    // nsISupports implementation
+    QueryInterface: function(iid) {
+      if (iid.equals(Ci.nsISupports) ||
+          iid.equals(Ci.nsIAutoCompletePopup))
+        return this;
+
+      throw Components.results.NS_ERROR_NO_INTERFACE;
+    }    
+  },
+    
+  // nsISupports implementation
+  QueryInterface: function(iid) {
+    if (iid.equals(Ci.nsISupports) ||
+        iid.equals(Ci.nsIAutoCompleteInput))
+      return this;
+
+    throw Components.results.NS_ERROR_NO_INTERFACE;
+  }
+}
+
+// Get tagging service
+try {
+  var tagssvc = Cc["@mozilla.org/browser/tagging-service;1"].
+                getService(Ci.nsITaggingService);
+} catch(ex) {
+  do_throw("Could not get tagging service\n");
+}
+
+function ensure_tag_results(results, searchTerm)
+{
+  var controller = Cc["@mozilla.org/autocomplete/controller;1"].
+                   getService(Ci.nsIAutoCompleteController);  
+  
+  // Make an AutoCompleteInput that uses our searches
+  // and confirms results on search complete
+  var input = new AutoCompleteInput(["places-tag-autocomplete"]);
+
+  controller.input = input;
+
+  var numSearchesStarted = 0;
+  input.onSearchBegin = function input_onSearchBegin() {
+    numSearchesStarted++;
+    do_check_eq(numSearchesStarted, 1);
+  };
+
+  input.onSearchComplete = function input_onSearchComplete() {
+    do_check_eq(numSearchesStarted, 1);
+    if (results.length)
+      do_check_eq(controller.searchStatus, 
+                  Ci.nsIAutoCompleteController.STATUS_COMPLETE_MATCH);
+    else
+      do_check_eq(controller.searchStatus, 
+                  Ci.nsIAutoCompleteController.STATUS_COMPLETE_NO_MATCH);
+
+    do_check_eq(controller.matchCount, results.length);
+    for (var i=0; i<controller.matchCount; i++) {
+      do_check_eq(controller.getValueAt(i), results[i]);
+    }
+   
+    if (current_test < (tests.length - 1)) {
+      current_test++;
+      tests[current_test]();
+    }
+
+    do_test_finished();
+  };
+
+  // Search is asynchronous, so don't let the test finish immediately
+  do_test_pending();
+
+  controller.startSearch(searchTerm);
+}
+
+var uri1 = uri("http://site.tld/1");
+  
+var tests = [
+  function test1() { ensure_tag_results(["bar", "baz", "boo"], "b"); },
+  function test2() { ensure_tag_results(["bar", "baz"], "ba"); },
+  function test3() { ensure_tag_results(["bar"], "bar"); }, 
+  function test4() { ensure_tag_results([], "barb"); }, 
+  function test5() { ensure_tag_results([], "foo"); },
+  function test6() { ensure_tag_results(["first tag, bar", "first tag, baz"], "first tag, ba"); },
+  function test7() { ensure_tag_results(["first tag;  bar", "first tag;  baz"], "first tag;  ba"); }
+];
+
+/** 
+ * Test tag autocomplete
+ */
+function run_test() {
+  tagssvc.tagURI(uri1, ["bar", "baz", "boo"]);
+
+  tests[0]();
+}
diff -r a131999fa900 toolkit/toolkit-makefiles.sh
--- a/toolkit/toolkit-makefiles.sh	Thu Oct 30 23:42:02 2008 -0700
+++ b/toolkit/toolkit-makefiles.sh	Sat Nov 01 13:47:50 2008 +0200
@@ -242,21 +242,18 @@ MAKEFILES_layout="
   layout/Makefile
   layout/base/Makefile
   layout/base/tests/Makefile
   layout/build/Makefile
   layout/forms/Makefile
   layout/html/tests/Makefile
   layout/style/Makefile
   layout/printing/Makefile
-  layout/xul/Makefile
-  layout/xul/base/Makefile
   layout/xul/base/public/Makefile
   layout/xul/base/src/Makefile
-  layout/xul/base/src/tree/Makefile
   layout/xul/base/src/tree/src/Makefile
   layout/xul/base/src/tree/public/Makefile
 "
 
 MAKEFILES_libimg="
   modules/libimg/Makefile
 "
 
@@ -1018,34 +1015,29 @@ if [ "$MOZ_MAPINFO" ]; then
   add_makefiles "
     tools/codesighs/Makefile
   "
 fi
 
 if [ "$MOZ_MATHML" ]; then
   add_makefiles "
     intl/uconv/ucvmath/Makefile
-    layout/mathml/Makefile
-    layout/mathml/base/Makefile
     layout/mathml/base/src/Makefile
-    layout/mathml/content/Makefile
     layout/mathml/content/src/Makefile
   "
 fi
 
 if [ "$MOZ_SVG" ]; then
   add_makefiles "
     content/svg/Makefile
     content/svg/document/Makefile
     content/svg/document/src/Makefile
     content/svg/content/Makefile
     content/svg/content/src/Makefile
     dom/public/idl/svg/Makefile
-    layout/svg/Makefile
-    layout/svg/base/Makefile
     layout/svg/base/src/Makefile
   "
 fi
 
 if [ "$MOZ_XTF" ]; then
   add_makefiles "
     content/xtf/Makefile
     content/xtf/public/Makefile
diff -r a131999fa900 widget/src/cocoa/nsPIWidgetCocoa.idl
--- a/widget/src/cocoa/nsPIWidgetCocoa.idl	Thu Oct 30 23:42:02 2008 -0700
+++ b/widget/src/cocoa/nsPIWidgetCocoa.idl	Sat Nov 01 13:47:50 2008 +0200
@@ -46,17 +46,17 @@ interface nsIWidget;
 [ptr] native NSWindowPtr(NSWindow);
 
 //
 // nsPIWidgetCocoa
 //
 // A private interface (unfrozen, private to the widget implementation) that
 // gives us access to some extra features on a widget/window.
 //
-[uuid(F08E9D06-6705-4749-BE81-CEF931246E06)]
+[uuid(f75ff69e-3a51-419e-bd29-042f804bc2ed)]
 interface nsPIWidgetCocoa : nsISupports
 {
   void SendSetZLevelEvent();
 
   // Find the displayed child sheet (if aShown) or a child sheet that
   // wants to be displayed (if !aShown)
   nsCocoaWindow GetChildSheet(in boolean aShown);
   
diff -r a131999fa900 widget/src/gtk2/nsWindow.cpp
--- a/widget/src/gtk2/nsWindow.cpp	Thu Oct 30 23:42:02 2008 -0700
+++ b/widget/src/gtk2/nsWindow.cpp	Sat Nov 01 13:47:50 2008 +0200
@@ -79,17 +79,16 @@
 #include "nsIPrefService.h"
 #include "nsIPrefBranch.h"
 #include "nsIServiceManager.h"
 #include "nsIStringBundle.h"
 #include "nsGfxCIID.h"
 
 #ifdef ACCESSIBILITY
 #include "nsIAccessibleRole.h"
-#include "nsPIAccessNode.h"
 #include "nsPIAccessible.h"
 #include "nsIAccessibleEvent.h"
 #include "prenv.h"
 #include "stdlib.h"
 static PRBool sAccessibilityChecked = PR_FALSE;
 /* static */
 PRBool nsWindow::sAccessibilityEnabled = PR_FALSE;
 static const char sSysPrefService [] = "@mozilla.org/system-preference-service;1";
diff -r a131999fa900 xpcom/threads/nsIThreadPool.idl
--- a/xpcom/threads/nsIThreadPool.idl	Thu Oct 30 23:42:02 2008 -0700
+++ b/xpcom/threads/nsIThreadPool.idl	Sat Nov 01 13:47:50 2008 +0200
@@ -54,17 +54,17 @@ interface nsIThreadPoolListener : nsISup
   void onThreadShuttingDown();
 };
 
 /**
  * An interface to a thread pool.  A thread pool creates a limited number of
  * anonymous (unnamed) worker threads.  An event dispatched to the thread pool
  * will be run on the next available worker thread.
  */
-[scriptable, uuid(394c29f0-225f-487f-86d3-4c259da76cab)]
+[scriptable, uuid(d628159b-1a03-4985-aa77-43122eb23bfc)]
 interface nsIThreadPool : nsIEventTarget
 {
   /**
    * Shutdown the thread pool.  This method may not be executed from any thread
    * in the thread pool.  Instead, it is meant to be executed from another
    * thread (usually the thread that created this thread pool).  When this
    * function returns, the thread pool and all of its threads will be shutdown,
    * and it will no longer be possible to dispatch tasks to the thread pool.
