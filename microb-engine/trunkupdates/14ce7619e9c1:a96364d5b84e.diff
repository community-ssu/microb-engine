diff -r 14ce7619e9c1 browser/base/content/browser.js
--- a/browser/base/content/browser.js	Sat Sep 06 22:21:37 2008 +1200
+++ b/browser/base/content/browser.js	Mon Sep 08 10:35:44 2008 +0300
@@ -860,11 +860,11 @@ function prepareForStartup() {
     return;
   }
 
   // initialize observers and listeners
   // and give C++ access to gBrowser
-  window.XULBrowserWindow = new nsBrowserStatusHandler();
+  XULBrowserWindow.init();
   window.QueryInterface(Ci.nsIInterfaceRequestor)
         .getInterface(nsIWebNavigation)
         .QueryInterface(Ci.nsIDocShellTreeItem).treeOwner
         .QueryInterface(Ci.nsIInterfaceRequestor)
         .getInterface(Ci.nsIXULWindow)
@@ -2823,13 +2823,12 @@ const DOMLinkHandler = {
         case "alternate":
           if (!feedAdded) {
             if (!rels.feed && rels.alternate && rels.stylesheet)
               break;
 
-            var feed = { title: link.title, href: link.href, type: link.type };
-            if (isValidFeed(feed, link.ownerDocument.nodePrincipal, rels.feed)) {
-              FeedHandler.addFeed(feed, link.ownerDocument);
+            if (isValidFeed(link, link.ownerDocument.nodePrincipal, rels.feed)) {
+              FeedHandler.addFeed(link, link.ownerDocument);
               feedAdded = true;
             }
           }
           break;
         case "icon":
@@ -3723,255 +3722,250 @@ function mimeTypeIsTextBased(aMimeType)
          aMimeType == "application/javascript" ||
          aMimeType == "application/xml" ||
          aMimeType == "mozilla.application/cached-xul";
 }
 
-function nsBrowserStatusHandler()
-{
-  this.init();
-}
-
-nsBrowserStatusHandler.prototype =
-{
+var XULBrowserWindow = {
   // Stored Status, Link and Loading values
-  status : "",
-  defaultStatus : "",
-  jsStatus : "",
-  jsDefaultStatus : "",
-  overLink : "",
-  startTime : 0,
+  status: "",
+  defaultStatus: "",
+  jsStatus: "",
+  jsDefaultStatus: "",
+  overLink: "",
+  startTime: 0,
   statusText: "",
   lastURI: null,
 
-  statusTimeoutInEffect : false,
-
-  QueryInterface : function(aIID)
-  {
+  statusTimeoutInEffect: false,
+
+  QueryInterface: function (aIID) {
     if (aIID.equals(Ci.nsIWebProgressListener) ||
         aIID.equals(Ci.nsIWebProgressListener2) ||
         aIID.equals(Ci.nsISupportsWeakReference) ||
         aIID.equals(Ci.nsIXULBrowserWindow) ||
         aIID.equals(Ci.nsISupports))
       return this;
     throw Cr.NS_NOINTERFACE;
   },
 
-  init : function()
-  {
+  get statusMeter () {
+    delete this.statusMeter;
+    return this.statusMeter = document.getElementById("statusbar-icon");
+  },
+  get stopCommand () {
+    delete this.stopCommand;
+    return this.stopCommand = document.getElementById("Browser:Stop");
+  },
+  get reloadCommand () {
+    delete this.reloadCommand;
+    return this.reloadCommand = document.getElementById("Browser:Reload");
+  },
+  get statusTextField () {
+    delete this.statusTextField;
+    return this.statusTextField = document.getElementById("statusbar-display");
+  },
+  get securityButton () {
+    delete this.securityButton;
+    return this.securityButton = document.getElementById("security-button");
+  },
+  get isImage () {
+    delete this.isImage;
+    return this.isImage = document.getElementById("isImage");
+  },
+
+  init: function () {
     this.throbberElement = document.getElementById("navigator-throbber");
-    this.statusMeter     = document.getElementById("statusbar-icon");
-    this.stopCommand     = document.getElementById("Browser:Stop");
-    this.reloadCommand   = document.getElementById("Browser:Reload");
-    this.statusTextField = document.getElementById("statusbar-display");
-    this.securityButton  = document.getElementById("security-button");
-    this.urlBar          = document.getElementById("urlbar");
-    this.isImage         = document.getElementById("isImage");
 
     // Initialize the security button's state and tooltip text.  Remember to reset
     // _hostChanged, otherwise onSecurityChange will short circuit.
     var securityUI = gBrowser.securityUI;
     this._hostChanged = true;
     this.onSecurityChange(null, null, securityUI.state);
   },
 
-  destroy : function()
-  {
+  destroy: function () {
     // XXXjag to avoid leaks :-/, see bug 60729
-    this.throbberElement = null;
-    this.statusMeter     = null;
-    this.stopCommand     = null;
-    this.reloadCommand   = null;
-    this.statusTextField = null;
-    this.securityButton  = null;
-    this.urlBar          = null;
-    this.statusText      = null;
-    this.lastURI         = null;
-  },
-
-  setJSStatus : function(status)
-  {
+    delete this.throbberElement;
+    delete this.statusMeter;
+    delete this.stopCommand;
+    delete this.reloadCommand;
+    delete this.statusTextField;
+    delete this.securityButton;
+    delete this.statusText;
+    delete this.lastURI;
+  },
+
+  setJSStatus: function (status) {
     this.jsStatus = status;
     this.updateStatusField();
   },
 
-  setJSDefaultStatus : function(status)
-  {
+  setJSDefaultStatus: function (status) {
     this.jsDefaultStatus = status;
     this.updateStatusField();
   },
 
-  setDefaultStatus : function(status)
-  {
+  setDefaultStatus: function (status) {
     this.defaultStatus = status;
     this.updateStatusField();
   },
 
-  setOverLink : function(link, b)
-  {
+  setOverLink: function (link, b) {
     // Encode bidirectional formatting characters.
     // (RFC 3987 sections 3.2 and 4.1 paragraph 6)
     this.overLink = link.replace(/[\u200e\u200f\u202a\u202b\u202c\u202d\u202e]/g,
                                  encodeURIComponent);
     this.updateStatusField();
   },
 
-  updateStatusField : function()
-  {
+  updateStatusField: function () {
     var text = this.overLink || this.status || this.jsStatus || this.jsDefaultStatus || this.defaultStatus;
 
     // check the current value so we don't trigger an attribute change
     // and cause needless (slow!) UI updates
     if (this.statusText != text) {
       this.statusTextField.label = text;
       this.statusText = text;
     }
   },
   
-  onLinkIconAvailable : function(aBrowser)
-  {
+  onLinkIconAvailable: function (aBrowser) {
     if (gProxyFavIcon && gBrowser.mCurrentBrowser == aBrowser &&
         gBrowser.userTypedValue === null)
       PageProxySetIcon(aBrowser.mIconURL); // update the favicon in the URL bar
   },
 
-  onProgressChange : function (aWebProgress, aRequest,
-                               aCurSelfProgress, aMaxSelfProgress,
-                               aCurTotalProgress, aMaxTotalProgress)
-  {
+  onProgressChange: function (aWebProgress, aRequest,
+                              aCurSelfProgress, aMaxSelfProgress,
+                              aCurTotalProgress, aMaxTotalProgress) {
     if (aMaxTotalProgress > 0) {
       // This is highly optimized.  Don't touch this code unless
       // you are intimately familiar with the cost of setting
       // attrs on XUL elements. -- hyatt
       var percentage = (aCurTotalProgress * 100) / aMaxTotalProgress;
       this.statusMeter.value = percentage;
     }
   },
 
-  onProgressChange64 : function (aWebProgress, aRequest,
-                                 aCurSelfProgress, aMaxSelfProgress,
-                                 aCurTotalProgress, aMaxTotalProgress)
-  {
+  onProgressChange64: function (aWebProgress, aRequest,
+                                aCurSelfProgress, aMaxSelfProgress,
+                                aCurTotalProgress, aMaxTotalProgress) {
     return this.onProgressChange(aWebProgress, aRequest,
       aCurSelfProgress, aMaxSelfProgress, aCurTotalProgress,
       aMaxTotalProgress);
   },
 
-  onStateChange : function(aWebProgress, aRequest, aStateFlags, aStatus)
-  {
+  onStateChange: function (aWebProgress, aRequest, aStateFlags, aStatus) {
     const nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;
     const nsIChannel = Components.interfaces.nsIChannel;
     if (aStateFlags & nsIWebProgressListener.STATE_START) {
-        // This (thanks to the filter) is a network start or the first
-        // stray request (the first request outside of the document load),
-        // initialize the throbber and his friends.
-
-        // Call start document load listeners (only if this is a network load)
-        if (aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK &&
-            aRequest && aWebProgress.DOMWindow == content)
-          this.startDocumentLoad(aRequest);
-
-        if (this.throbberElement) {
-          // Turn the throbber on.
-          this.throbberElement.setAttribute("busy", "true");
-        }
-
-        // Turn the status meter on.
-        this.statusMeter.value = 0;  // be sure to clear the progress bar
-        if (gProgressCollapseTimer) {
-          window.clearTimeout(gProgressCollapseTimer);
-          gProgressCollapseTimer = null;
-        }
-        else
-          this.statusMeter.parentNode.collapsed = false;
-
-        // XXX: This needs to be based on window activity...
-        this.stopCommand.removeAttribute("disabled");
+      // This (thanks to the filter) is a network start or the first
+      // stray request (the first request outside of the document load),
+      // initialize the throbber and his friends.
+
+      // Call start document load listeners (only if this is a network load)
+      if (aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK &&
+          aRequest && aWebProgress.DOMWindow == content)
+        this.startDocumentLoad(aRequest);
+
+      if (this.throbberElement) {
+        // Turn the throbber on.
+        this.throbberElement.setAttribute("busy", "true");
+      }
+
+      // Turn the status meter on.
+      this.statusMeter.value = 0;  // be sure to clear the progress bar
+      if (gProgressCollapseTimer) {
+        window.clearTimeout(gProgressCollapseTimer);
+        gProgressCollapseTimer = null;
+      }
+      else
+        this.statusMeter.parentNode.collapsed = false;
+
+      // XXX: This needs to be based on window activity...
+      this.stopCommand.removeAttribute("disabled");
     }
     else if (aStateFlags & nsIWebProgressListener.STATE_STOP) {
       if (aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK) {
         if (aWebProgress.DOMWindow == content) {
           if (aRequest)
             this.endDocumentLoad(aRequest, aStatus);
-          var browser = gBrowser.mCurrentBrowser;
-          if (!gBrowser.mTabbedMode && !browser.mIconURL)
+          if (!gBrowser.mTabbedMode && !gBrowser.mCurrentBrowser.mIconURL)
             gBrowser.useDefaultIcon(gBrowser.mCurrentTab);
 
           if (Components.isSuccessCode(aStatus) &&
-              content.document.documentElement.getAttribute("manifest")) {
+              content.document.documentElement.getAttribute("manifest"))
             OfflineApps.offlineAppRequested(content);
-          }
         }
       }
 
       // This (thanks to the filter) is a network stop or the last
       // request stop outside of loading the document, stop throbbers
       // and progress bars and such
       if (aRequest) {
-        var msg = "";
-          // Get the URI either from a channel or a pseudo-object
-          if (aRequest instanceof nsIChannel || "URI" in aRequest) {
-            var location = aRequest.URI;
-
-            // For keyword URIs clear the user typed value since they will be changed into real URIs
-            if (location.scheme == "keyword" && aWebProgress.DOMWindow == content)
-              gBrowser.userTypedValue = null;
-
-            if (location.spec != "about:blank") {
-              const kErrorBindingAborted = 0x804B0002;
-              const kErrorNetTimeout = 0x804B000E;
-              switch (aStatus) {
-                case kErrorBindingAborted:
-                  msg = gNavigatorBundle.getString("nv_stopped");
-                  break;
-                case kErrorNetTimeout:
-                  msg = gNavigatorBundle.getString("nv_timeout");
-                  break;
-              }
-            }
-          }
-          // If msg is false then we did not have an error (channel may have
-          // been null, in the case of a stray image load).
-          if (!msg && (!location || location.spec != "about:blank")) {
-            msg = gNavigatorBundle.getString("nv_done");
-          }
-          this.status = "";
-          this.setDefaultStatus(msg);
-
-          // Disable menu entries for images, enable otherwise
-          if (content.document && mimeTypeIsTextBased(content.document.contentType))
-            this.isImage.removeAttribute('disabled');
-          else
-            this.isImage.setAttribute('disabled', 'true');
-        }
-
-        // Turn the progress meter and throbber off.
-        gProgressCollapseTimer = window.setTimeout(
-          function() {
-            gProgressMeterPanel.collapsed = true;
-            gProgressCollapseTimer = null;
-          }, 100);
-
-        if (this.throbberElement)
-          this.throbberElement.removeAttribute("busy");
-
-        this.stopCommand.setAttribute("disabled", "true");
-    }
-  },
-
-  onLocationChange : function(aWebProgress, aRequest, aLocationURI)
-  {
+        let msg = "";
+        // Get the URI either from a channel or a pseudo-object
+        if (aRequest instanceof nsIChannel || "URI" in aRequest) {
+          let location = aRequest.URI;
+
+          // For keyword URIs clear the user typed value since they will be changed into real URIs
+          if (location.scheme == "keyword" && aWebProgress.DOMWindow == content)
+            gBrowser.userTypedValue = null;
+
+          if (location.spec != "about:blank") {
+            const kErrorBindingAborted = 0x804B0002;
+            const kErrorNetTimeout = 0x804B000E;
+            switch (aStatus) {
+              case kErrorBindingAborted:
+                msg = gNavigatorBundle.getString("nv_stopped");
+                break;
+              case kErrorNetTimeout:
+                msg = gNavigatorBundle.getString("nv_timeout");
+                break;
+            }
+          }
+        }
+        // If msg is false then we did not have an error (channel may have
+        // been null, in the case of a stray image load).
+        if (!msg && (!location || location.spec != "about:blank"))
+          msg = gNavigatorBundle.getString("nv_done");
+
+        this.status = "";
+        this.setDefaultStatus(msg);
+
+        // Disable menu entries for images, enable otherwise
+        if (content.document && mimeTypeIsTextBased(content.document.contentType))
+          this.isImage.removeAttribute('disabled');
+        else
+          this.isImage.setAttribute('disabled', 'true');
+      }
+
+      // Turn the progress meter and throbber off.
+      gProgressCollapseTimer = window.setTimeout(function () {
+        gProgressMeterPanel.collapsed = true;
+        gProgressCollapseTimer = null;
+      }, 100);
+
+      if (this.throbberElement)
+        this.throbberElement.removeAttribute("busy");
+
+      this.stopCommand.setAttribute("disabled", "true");
+    }
+  },
+
+  onLocationChange: function (aWebProgress, aRequest, aLocationURI) {
     var location = aLocationURI ? aLocationURI.spec : "";
     this._hostChanged = true;
 
     if (document.tooltipNode) {
       // Optimise for the common case
       if (aWebProgress.DOMWindow == content) {
         document.getElementById("aHTMLTooltip").hidePopup();
         document.tooltipNode = null;
       }
       else {
-        for (var tooltipWindow =
+        for (let tooltipWindow =
                document.tooltipNode.ownerDocument.defaultView;
              tooltipWindow != tooltipWindow.parent;
              tooltipWindow = tooltipWindow.parent) {
           if (tooltipWindow == aWebProgress.DOMWindow) {
             document.getElementById("aHTMLTooltip").hidePopup();
@@ -3990,22 +3984,22 @@ nsBrowserStatusHandler.prototype =
     // <a href="#" onclick="return install();">Install Foo</a>
     //
     // - which fires a onLocationChange message to uri + '#'...
     var selectedBrowser = gBrowser.selectedBrowser;
     if (selectedBrowser.lastURI) {
-      var oldSpec = selectedBrowser.lastURI.spec;
-      var oldIndexOfHash = oldSpec.indexOf("#");
+      let oldSpec = selectedBrowser.lastURI.spec;
+      let oldIndexOfHash = oldSpec.indexOf("#");
       if (oldIndexOfHash != -1)
         oldSpec = oldSpec.substr(0, oldIndexOfHash);
-      var newSpec = location;
-      var newIndexOfHash = newSpec.indexOf("#");
+      let newSpec = location;
+      let newIndexOfHash = newSpec.indexOf("#");
       if (newIndexOfHash != -1)
         newSpec = newSpec.substr(0, newSpec.indexOf("#"));
       if (newSpec != oldSpec) {
         // Remove all the notifications, except for those which want to
         // persist across the first location change.
-        var nBox = gBrowser.getNotificationBox(selectedBrowser);
+        let nBox = gBrowser.getNotificationBox(selectedBrowser);
         nBox.removeTransientNotifications();
       }
     }
     selectedBrowser.lastURI = aLocationURI;
 
@@ -4022,27 +4016,24 @@ nsBrowserStatusHandler.prototype =
     // Update urlbar only if a new page was loaded on the primary content area
     // Do not update urlbar if there was a subframe navigation
 
     var browser = gBrowser.selectedBrowser;
     if (aWebProgress.DOMWindow == content) {
-
       if ((location == "about:blank" && !content.opener) ||
-           location == "") {  // Second condition is for new tabs, otherwise
-                              // reload function is enabled until tab is refreshed.
+          location == "") {  // Second condition is for new tabs, otherwise
+                             // reload function is enabled until tab is refreshed.
         this.reloadCommand.setAttribute("disabled", "true");
       } else {
         this.reloadCommand.removeAttribute("disabled");
       }
 
       if (!gBrowser.mTabbedMode && aWebProgress.isLoadingDocument)
         gBrowser.setIcon(gBrowser.mCurrentTab, null);
 
       if (gURLBar) {
         URLBarSetURI(aLocationURI);
-
-        // Update starring UI
-        PlacesStarButton.updateState();
+        PlacesStarButton.updateState(); // Update starring UI
       }
 
       FullZoom.onLocationChange(aLocationURI);
     }
     UpdateBackForwardCommands(gBrowser.webNavigation);
@@ -4058,77 +4049,66 @@ nsBrowserStatusHandler.prototype =
     // fix bug 253793 - turn off highlight when page changes
     gFindBar.getElement("highlight").checked = false;
 
     // See bug 358202, when tabs are switched during a drag operation,
     // timers don't fire on windows (bug 203573)
-    if (aRequest) {
-      var self = this;
-      setTimeout(function() { self.asyncUpdateUI(); }, 0);
-    } 
+    if (aRequest)
+      setTimeout(function () { XULBrowserWindow.asyncUpdateUI(); }, 0);
     else
       this.asyncUpdateUI();
   },
   
-  asyncUpdateUI : function () {
+  asyncUpdateUI: function () {
     FeedHandler.updateFeeds();
     BrowserSearch.updateSearchButton();
   },
 
-  onStatusChange : function(aWebProgress, aRequest, aStatus, aMessage)
-  {
+  onStatusChange: function (aWebProgress, aRequest, aStatus, aMessage) {
     this.status = aMessage;
     this.updateStatusField();
   },
 
-  onRefreshAttempted : function(aWebProgress, aURI, aDelay, aSameURI)
-  {
+  onRefreshAttempted: function (aWebProgress, aURI, aDelay, aSameURI) {
     if (gPrefService.getBoolPref("accessibility.blockautorefresh")) {
-      var brandBundle = document.getElementById("bundle_brand");
-      var brandShortName = brandBundle.getString("brandShortName");
-      var refreshButtonText = 
+      let brandBundle = document.getElementById("bundle_brand");
+      let brandShortName = brandBundle.getString("brandShortName");
+      let refreshButtonText =
         gNavigatorBundle.getString("refreshBlocked.goButton");
-      var refreshButtonAccesskey = 
+      let refreshButtonAccesskey =
         gNavigatorBundle.getString("refreshBlocked.goButton.accesskey");
-      var message;
-      if (aSameURI)
-        message = gNavigatorBundle.getFormattedString(
-          "refreshBlocked.refreshLabel", [brandShortName]);
-      else
-        message = gNavigatorBundle.getFormattedString(
-          "refreshBlocked.redirectLabel", [brandShortName]);
-      var topBrowser = getBrowserFromContentWindow(aWebProgress.DOMWindow.top);
-      var docShell = aWebProgress.DOMWindow
+      let message =
+        gNavigatorBundle.getFormattedString(aSameURI ? "refreshBlocked.refreshLabel"
+                                                     : "refreshBlocked.redirectLabel",
+                                            [brandShortName]);
+      let topBrowser = getBrowserFromContentWindow(aWebProgress.DOMWindow.top);
+      let docShell = aWebProgress.DOMWindow
                                  .QueryInterface(Ci.nsIInterfaceRequestor)
                                  .getInterface(Ci.nsIWebNavigation)
                                  .QueryInterface(Ci.nsIDocShell);
-      var notificationBox = gBrowser.getNotificationBox(topBrowser);
-      var notification = notificationBox.getNotificationWithValue(
-        "refresh-blocked");
+      let notificationBox = gBrowser.getNotificationBox(topBrowser);
+      let notification = notificationBox.getNotificationWithValue("refresh-blocked");
       if (notification) {
         notification.label = message;
         notification.refreshURI = aURI;
         notification.delay = aDelay;
         notification.docShell = docShell;
-      }
-      else {
-        var buttons = [{
+      } else {
+        let buttons = [{
           label: refreshButtonText,
           accessKey: refreshButtonAccesskey,
-          callback: function(aNotification, aButton) {
+          callback: function (aNotification, aButton) {
             var refreshURI = aNotification.docShell
                                           .QueryInterface(Ci.nsIRefreshURI);
             refreshURI.forceRefreshURI(aNotification.refreshURI,
                                        aNotification.delay, true);
           }
         }];
-        const priority = notificationBox.PRIORITY_INFO_MEDIUM;
-        notification = notificationBox.appendNotification(
-          message,
-          "refresh-blocked",
-          "chrome://browser/skin/Info.png",
-          priority,
-          buttons);
+        notification =
+          notificationBox.appendNotification(message, "refresh-blocked",
+                                             "chrome://browser/skin/Info.png",
+                                             notificationBox.PRIORITY_INFO_MEDIUM,
+                                             buttons);
         notification.refreshURI = aURI;
         notification.delay = aDelay;
         notification.docShell = docShell;
       }
       return false;
@@ -4140,13 +4120,11 @@ nsBrowserStatusHandler.prototype =
   _state: null,
   _host: undefined,
   _tooltipText: null,
   _hostChanged: false, // onLocationChange will flip this bit
 
-  onSecurityChange : function browser_onSecChange(aWebProgress,
-                                                  aRequest, aState)
-  {
+  onSecurityChange: function (aWebProgress, aRequest, aState) {
     // Don't need to do anything if the data we use to update the UI hasn't
     // changed
     if (this._state == aState &&
         this._tooltipText == gBrowser.securityUI.tooltipText &&
         !this._hostChanged) {
@@ -4181,11 +4159,11 @@ nsBrowserStatusHandler.prototype =
                               wpl.STATE_IS_BROKEN |
                               wpl.STATE_IS_INSECURE |
                               wpl.STATE_SECURE_HIGH |
                               wpl.STATE_SECURE_MED |
                               wpl.STATE_SECURE_LOW;
-    var level = null;
+    var level;
     var setHost = false;
 
     switch (this._state & wpl_security_bits) {
       case wpl.STATE_IS_SECURE | wpl.STATE_SECURE_HIGH:
         level = "high";
@@ -4201,16 +4179,14 @@ nsBrowserStatusHandler.prototype =
         break;
     }
 
     if (level) {
       this.securityButton.setAttribute("level", level);
-      if (this.urlBar)
-        this.urlBar.setAttribute("level", level);    
-    } else {
+      this.securityButton.hidden = false;
+    } else {
+      this.securityButton.hidden = true;
       this.securityButton.removeAttribute("level");
-      if (this.urlBar)
-        this.urlBar.removeAttribute("level");
     }
 
     if (setHost && this._host)
       this.securityButton.setAttribute("label", this._host);
     else
@@ -4234,12 +4210,11 @@ nsBrowserStatusHandler.prototype =
     }
     gIdentityHandler.checkIdentity(this._state, locationObj);
   },
 
   // simulate all change notifications after switching tabs
-  onUpdateCurrentBrowser : function(aStateFlags, aStatus, aMessage, aTotalProgress)
-  {
+  onUpdateCurrentBrowser: function (aStateFlags, aStatus, aMessage, aTotalProgress) {
     var nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;
     var loadingDone = aStateFlags & nsIWebProgressListener.STATE_STOP;
     // use a pseudo-object instead of a (potentially non-existing) channel for getting
     // a correct error message - and make sure that the UI is always either in
     // loading (STATE_START) or done (STATE_STOP) mode
@@ -4254,12 +4229,11 @@ nsBrowserStatusHandler.prototype =
       return;
     this.onStatusChange(gBrowser.webProgress, null, 0, aMessage);
     this.onProgressChange(gBrowser.webProgress, 0, 0, aTotalProgress, 1);
   },
 
-  startDocumentLoad : function(aRequest)
-  {
+  startDocumentLoad: function (aRequest) {
     // clear out feed data
     gBrowser.mCurrentBrowser.feeds = null;
 
     // clear out search-engine data
     gBrowser.mCurrentBrowser.engines = null;    
@@ -4272,12 +4246,11 @@ nsBrowserStatusHandler.prototype =
       observerService.notifyObservers(content, "StartDocumentLoad", urlStr);
     } catch (e) {
     }
   },
 
-  endDocumentLoad : function(aRequest, aStatus)
-  {
+  endDocumentLoad: function (aRequest, aStatus) {
     const nsIChannel = Components.interfaces.nsIChannel;
     var urlStr = aRequest.QueryInterface(nsIChannel).originalURI.spec;
 
     var observerService = Components.classes["@mozilla.org/observer-service;1"]
                                     .getService(Components.interfaces.nsIObserverService);
diff -r 14ce7619e9c1 browser/base/content/browser.xul
--- a/browser/base/content/browser.xul	Sat Sep 06 22:21:37 2008 +1200
+++ b/browser/base/content/browser.xul	Mon Sep 08 10:35:44 2008 +0300
@@ -563,10 +563,11 @@
       </statusbarpanel>
       <statusbarpanel id="download-monitor" class="statusbarpanel-iconic-text"
                       tooltiptext="&downloadMonitor2.tooltip;" hidden="true"
                       command="Tools:Downloads"/>
       <statusbarpanel id="security-button" class="statusbarpanel-iconic-text"
+                      hidden="true"
                       ondblclick="if (event.button == 0) displaySecurityInfo();"/>
       <statusbarpanel id="page-report-button" type="menu"
                       class="statusbarpanel-menu-iconic"
                       tooltiptext="&pageReportIcon.tooltip;">
         <menupopup onpopupshowing="gPopupBlockerObserver.fillPopupList(event);">
diff -r 14ce7619e9c1 browser/base/content/pageinfo/feeds.js
--- a/browser/base/content/pageinfo/feeds.js	Sat Sep 06 22:21:37 2008 +1200
+++ b/browser/base/content/pageinfo/feeds.js	Mon Sep 08 10:35:44 2008 +0300
@@ -60,13 +60,13 @@ function initFeedTab()
       for each (let relVal in rel.split(/\s+/))
         rels[relVal] = true;
     }
 
     if (rels.feed || (link.type && rels.alternate && !rels.stylesheet)) {
-      var feed = { title: link.title, href: link.href, type: link.type || "" };
-      if (isValidFeed(feed, gDocument.nodePrincipal, rels.feed)) {
-        var type = feedTypes[feed.type] || feedTypes["application/rss+xml"];
+      var type = isValidFeed(link, gDocument.nodePrincipal, rels.feed);
+      if (type) {
+        type = feedTypes[type] || feedTypes["application/rss+xml"];
         addRow(feed.title, type, feed.href);
       }
     }
   }
 
diff -r 14ce7619e9c1 browser/base/content/test/Makefile.in
--- a/browser/base/content/test/Makefile.in	Sat Sep 06 22:21:37 2008 +1200
+++ b/browser/base/content/test/Makefile.in	Mon Sep 08 10:35:44 2008 +0300
@@ -52,10 +52,11 @@ _TEST_FILES =	test_feed_discovery.html \
 # browser_bug423833.js disabled temporarily since it's unreliable: bug 428712
 # browser_sanitize-download-history.js disabled temporarily since it's unreliable: bug 432425
 _BROWSER_FILES = browser_bug321000.js \
                  browser_bug405137.js \
                  browser_bug409481.js \
+                 browser_bug413915.js \
                  browser_autodiscovery.js \
                  browser_bug420160.js \
                  browser_bug441778.js \
                  autodiscovery.html \
                  moz.png \
diff -r 14ce7619e9c1 browser/base/content/test/browser_bug413915.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/base/content/test/browser_bug413915.js	Mon Sep 08 10:35:44 2008 +0300
@@ -0,0 +1,62 @@
+function test() {
+  var ioserv = Components.classes["@mozilla.org/network/io-service;1"].
+               getService(Components.interfaces.nsIIOService);
+  var exampleUri = ioserv.newURI("http://example.com/", null, null);
+  var secman = Components.classes["@mozilla.org/scriptsecuritymanager;1"].
+               getService(Components.interfaces.nsIScriptSecurityManager);
+  var principal = secman.getCodebasePrincipal(exampleUri);
+
+  function testIsFeed(aTitle, aHref, aType, aKnown) {
+    var link = { title: aTitle, href: aHref, type: aType };
+    return isValidFeed(link, principal, aKnown);
+  }
+
+  var href = "http://example.com/feed/";
+  var atomType = "application/atom+xml";
+  var funkyAtomType = " aPPLICAtion/Atom+XML ";
+  var rssType = "application/rss+xml";
+  var funkyRssType = " Application/RSS+XML  ";
+  var rdfType = "application/rdf+xml";
+  var texmlType = "text/xml";
+  var appxmlType = "application/xml";
+  var noRss = "Foo";
+  var rss = "RSS";
+
+  // things that should be valid
+  ok(testIsFeed(noRss, href, atomType, false) == atomType,
+     "detect Atom feed");
+  ok(testIsFeed(noRss, href, funkyAtomType, false) == atomType,
+     "clean up and detect Atom feed");
+  ok(testIsFeed(noRss, href, rssType, false) == rssType,
+     "detect RSS feed");
+  ok(testIsFeed(noRss, href, funkyRssType, false) == rssType,
+     "clean up and detect RSS feed");
+
+  // things that should not be feeds
+  ok(testIsFeed(noRss, href, rdfType, false) == null,
+     "should not detect RDF non-feed");
+  ok(testIsFeed(rss, href, rdfType, false) == null,
+     "should not detect RDF feed from type and title");
+  ok(testIsFeed(noRss, href, texmlType, false) == null,
+     "should not detect text/xml non-feed");
+  ok(testIsFeed(rss, href, texmlType, false) == null,
+     "should not detect text/xml feed from type and title");
+  ok(testIsFeed(noRss, href, appxmlType, false) == null,
+     "should not detect application/xml non-feed");
+  ok(testIsFeed(rss, href, appxmlType, false) == null,
+     "should not detect application/xml feed from type and title");
+
+  // security check only, returns cleaned up type or "application/rss+xml"
+  ok(testIsFeed(noRss, href, atomType, true) == atomType,
+     "feed security check should return Atom type");
+  ok(testIsFeed(noRss, href, funkyAtomType, true) == atomType,
+     "feed security check should return cleaned up Atom type");
+  ok(testIsFeed(noRss, href, rssType, true) == rssType,
+     "feed security check should return RSS type");
+  ok(testIsFeed(noRss, href, funkyRssType, true) == rssType,
+     "feed security check should return cleaned up RSS type");
+  ok(testIsFeed(noRss, href, "", true) == rssType,
+     "feed security check without type should return RSS type");
+  ok(testIsFeed(noRss, href, "garbage", true) == "garbage",
+     "feed security check with garbage type should return garbage");
+}
diff -r 14ce7619e9c1 browser/base/content/test/feed_discovery.html
--- a/browser/base/content/test/feed_discovery.html	Sat Sep 06 22:21:37 2008 +1200
+++ b/browser/base/content/test/feed_discovery.html	Mon Sep 08 10:35:44 2008 +0300
@@ -26,21 +26,12 @@ https://bugzilla.mozilla.org/show_bug.cg
     <link rel="alternate" type="  application/atom+xml  " title="11" href="/11.atom" />
 
     <!-- type is case-insensitive -->
     <link rel="alternate" type="aPPliCAtion/ATom+xML" title="12" href="/12.atom" />
 
-    <!-- tolerate application/rdf+xml if the title includes 'rss' -->
-    <link rel="alternate" type="application/rdf+xml" title="13 rss" href="/13.rdf" />
-
-    <!-- tolerate application/xml if the title includes 'rss' -->
-    <link rel="alternate" type="application/xml" title="14 rss" href="/14.xml" />
-
-    <!-- tolerate text/xml if the title includes 'rss' -->
-    <link rel="alternate" type="text/xml" title="15 rss" href="/15.xml" />
-
     <!-- "feed stylesheet" is a feed, though "alternate stylesheet" isn't -->
-    <link rel="feed stylesheet" title="16" href="/16.atom" />
+    <link rel="feed stylesheet" title="13" href="/13.atom" />
 
     <!-- hyphens or letters around rel not allowed -->
     <link rel="disabled-alternate" type="application/atom+xml" title="Bogus1" href="/Bogus1" />
     <link rel="alternates" type="application/atom+xml" title="Bogus2" href="/Bogus2" />
     <link rel=" alternate-like" type="application/atom+xml" title="Bogus3" href="/Bogus3" />
@@ -61,12 +52,21 @@ https://bugzilla.mozilla.org/show_bug.cg
     <link rel="foopy" type="application/atom+xml" title="Bogus8 Atom and RSS" href="/Bogus8" />
 
     <!-- don't find application/rss+xml by title -->
     <link rel="goats" type="application/rss+xml" title="Bogus9 RSS and Atom" href="/Bogus9" />
 
+    <!-- don't find application/rdf+xml by title -->
+    <link rel="alternate" type="application/rdf+xml" title="Bogus10 RSS and Atom" href="/Bogus10" />
+
+    <!-- don't find application/xml by title -->
+    <link rel="alternate" type="application/xml" title="Bogus11 RSS and Atom" href="/Bogus11" />
+
+    <!-- don't find text/xml by title -->
+    <link rel="alternate" type="text/xml" title="Bogus12 RSS and Atom" href="/Bogus12" />
+
     <!-- alternate and stylesheet isn't a feed -->
-    <link rel="alternate stylesheet" type="application/rss+xml" title="Bogus10 RSS" href="/Bogus10" />
+    <link rel="alternate stylesheet" type="application/rss+xml" title="Bogus13 RSS" href="/Bogus13" />
   </head>
   <body>
     <script type="text/javascript">
       window.onload = function() {
         netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
diff -r 14ce7619e9c1 browser/base/content/utilityOverlay.js
--- a/browser/base/content/utilityOverlay.js	Sat Sep 06 22:21:37 2008 +1200
+++ b/browser/base/content/utilityOverlay.js	Mon Sep 08 10:35:44 2008 +0300
@@ -629,52 +629,40 @@ function openNewWindowWith(aURL, aDocume
 }
 
 /**
  * isValidFeed: checks whether the given data represents a valid feed.
  *
- * @param  aData
+ * @param  aLink
  *         An object representing a feed with title, href and type.
  * @param  aPrincipal
  *         The principal of the document, used for security check.
  * @param  aIsFeed
  *         Whether this is already a known feed or not, if true only a security
  *         check will be performed.
  */ 
-function isValidFeed(aData, aPrincipal, aIsFeed)
+function isValidFeed(aLink, aPrincipal, aIsFeed)
 {
-  if (!aData || !aPrincipal)
+  if (!aLink || !aPrincipal)
     return false;
 
+  var type = aLink.type.toLowerCase().replace(/^\s+|\s*(?:;.*)?$/g, "");
   if (!aIsFeed) {
-    var type = aData.type && aData.type.toLowerCase();
-    type = type.replace(/^\s+|\s*(?:;.*)?$/g, "");
-
     aIsFeed = (type == "application/rss+xml" ||
                type == "application/atom+xml");
-
-    if (!aIsFeed) {
-      // really slimy: general XML types with magic letters in the title
-      const titleRegex = /(^|\s)rss($|\s)/i;
-      aIsFeed = ((type == "text/xml" || type == "application/rdf+xml" ||
-                  type == "application/xml") && titleRegex.test(aData.title));
-    }
   }
 
   if (aIsFeed) {
     try {
-      urlSecurityCheck(aData.href, aPrincipal,
+      urlSecurityCheck(aLink.href, aPrincipal,
                        Components.interfaces.nsIScriptSecurityManager.DISALLOW_INHERIT_PRINCIPAL);
+      return type || "application/rss+xml";
     }
     catch(ex) {
-      aIsFeed = false;
     }
   }
 
-  if (type)
-    aData.type = type;
-
-  return aIsFeed;
+  return null;
 }
 
 // aCalledFromModal is optional
 function openHelpLink(aHelpTopic, aCalledFromModal) {
   var url = Components.classes["@mozilla.org/toolkit/URLFormatterService;1"]
diff -r 14ce7619e9c1 browser/components/preferences/cookies.js
--- a/browser/components/preferences/cookies.js	Sat Sep 06 22:21:37 2008 +1200
+++ b/browser/components/preferences/cookies.js	Mon Sep 08 10:35:44 2008 +0300
@@ -65,12 +65,15 @@ var gCookiesWindow = {
     if (this._view.rowCount > 0) 
       this._tree.view.selection.select(0);
 
     if ("arguments" in window && window.arguments[0] &&
         window.arguments[0].filterString)
-      this.setFilter(window.arguments[0].filterString);
-    
+    {
+      document.getElementById("filter").value = window.arguments[0].filterString;
+      this.filter();
+    }
+
     this._saveState();
       
     document.getElementById("filter").focus();
   },
   
@@ -788,12 +791,11 @@ var gCookiesWindow = {
   clearFilter: function ()
   {
     // Revert to single-select in the tree
     this._tree.setAttribute("seltype", "single");
     
-    // Clear the Filter and the Tree Display
-    document.getElementById("filter").value = "";
+    // Clear the Tree Display
     this._view._filtered = false;
     this._view._rowCount = 0;
     this._tree.treeBoxObject.rowCountChanged(0, -this._view._filterSet.length);
     this._view._filterSet = [];
 
@@ -824,12 +826,10 @@ var gCookiesWindow = {
       this._view.selection.rangedSelect(range.min, range.max, true);
     }
     this._lastSelectedRanges = [];
 
     document.getElementById("cookiesIntro").value = this._bundle.getString("cookiesAll");
-    document.getElementById("clearFilter").disabled = true;
-    document.getElementById("filter").focus();
   },
   
   _cookieMatchesFilter: function (aCookie)
   {
     return aCookie.rawHost.indexOf(this._view._filterValue) != -1 ||
@@ -873,70 +873,46 @@ var gCookiesWindow = {
       var item = this._view._getItemAtIndex(i);
       if (item && item.container && item.open)
         this._openIndices.push(i);
     }
   },
-  
-  _filterTimeout: -1,
-  onFilterInput: function ()
-  {
-    if (this._filterTimeout != -1)
-      clearTimeout(this._filterTimeout);
-   
-    function filterCookies()
-    {
-      var filter = document.getElementById("filter").value;
-      if (filter == "") {
-        gCookiesWindow.clearFilter();
-        return;
-      }        
-      var view = gCookiesWindow._view;
-      view._filterSet = gCookiesWindow._filterCookies(filter);
-      if (!view._filtered) {
-        // Save Display Info for the Non-Filtered mode when we first
-        // enter Filtered mode. 
-        gCookiesWindow._saveState();
-        view._filtered = true;
-      }
-      // Move to multi-select in the tree
-      gCookiesWindow._tree.setAttribute("seltype", "multiple");
-      
-      // Clear the display
-      var oldCount = view._rowCount;
-      view._rowCount = 0;
-      gCookiesWindow._tree.treeBoxObject.rowCountChanged(0, -oldCount);
-      // Set up the filtered display
-      view._rowCount = view._filterSet.length;
-      gCookiesWindow._tree.treeBoxObject.rowCountChanged(0, view.rowCount);
-      
-      // if the view is not empty then select the first item
-      if (view.rowCount > 0)
-        view.selection.select(0);
 
-      document.getElementById("cookiesIntro").value = gCookiesWindow._bundle.getString("cookiesFiltered");
-      document.getElementById("clearFilter").disabled = false;
-    }
-    window.filterCookies = filterCookies;
-    this._filterTimeout = setTimeout("filterCookies();", 500);
-  },
-  
-  onFilterKeyPress: function (aEvent)
+  filter: function ()
   {
     var filter = document.getElementById("filter").value;
-    if (aEvent.keyCode == 27 && filter != "") // ESC key
-      this.clearFilter();
+    if (filter == "") {
+      gCookiesWindow.clearFilter();
+      return;
+    }
+    var view = gCookiesWindow._view;
+    view._filterSet = gCookiesWindow._filterCookies(filter);
+    if (!view._filtered) {
+      // Save Display Info for the Non-Filtered mode when we first
+      // enter Filtered mode.
+      gCookiesWindow._saveState();
+      view._filtered = true;
+    }
+    // Move to multi-select in the tree
+    gCookiesWindow._tree.setAttribute("seltype", "multiple");
+
+    // Clear the display
+    var oldCount = view._rowCount;
+    view._rowCount = 0;
+    gCookiesWindow._tree.treeBoxObject.rowCountChanged(0, -oldCount);
+    // Set up the filtered display
+    view._rowCount = view._filterSet.length;
+    gCookiesWindow._tree.treeBoxObject.rowCountChanged(0, view.rowCount);
+
+    // if the view is not empty then select the first item
+    if (view.rowCount > 0)
+      view.selection.select(0);
+
+    document.getElementById("cookiesIntro").value = gCookiesWindow._bundle.getString("cookiesFiltered");
   },
-  
+
   focusFilterBox: function ()
-  { 
+  {
     var filter = document.getElementById("filter");
     filter.focus();
     filter.select();
-  },
-
-  setFilter: function (aFilterString)
-  {
-    document.getElementById("filter").value = aFilterString;
-    this.onFilterInput();
   }
 };
-
diff -r 14ce7619e9c1 browser/components/preferences/cookies.xul
--- a/browser/components/preferences/cookies.xul	Sat Sep 06 22:21:37 2008 +1200
+++ b/browser/components/preferences/cookies.xul	Mon Sep 08 10:35:44 2008 +0300
@@ -60,19 +60,15 @@
   <keyset>
     <key key="&windowClose.key;" modifiers="accel" oncommand="window.close();"/>
     <key key="&focusSearch1.key;" modifiers="accel" oncommand="gCookiesWindow.focusFilterBox();"/>
     <key key="&focusSearch2.key;" modifiers="accel" oncommand="gCookiesWindow.focusFilterBox();"/>
   </keyset>
-           
+
   <vbox flex="1" class="contentPane">
     <hbox align="center">
       <label accesskey="&filter.accesskey;" control="filter">&filter.label;</label>
-      <textbox id="filter" flex="1" oninput="gCookiesWindow.onFilterInput();" 
-               onkeypress="gCookiesWindow.onFilterKeyPress(event);"/>
-      <button id="clearFilter" icon="clear" label="&clear.label;"
-              accesskey="&clear.accesskey;" 
-              oncommand="gCookiesWindow.clearFilter();" disabled="true"/>
+      <textbox type="search" id="filter" flex="1" oncommand="gCookiesWindow.filter();"/>
     </hbox>
     <separator class="thin"/>
     <label control="cookiesList" id="cookiesIntro" value="&cookiesonsystem.label;"/>
     <separator class="thin"/>
     <tree id="cookiesList" flex="1" style="height: 10em;"
diff -r 14ce7619e9c1 browser/components/sessionstore/src/nsSessionStartup.js
--- a/browser/components/sessionstore/src/nsSessionStartup.js	Sat Sep 06 22:21:37 2008 +1200
+++ b/browser/components/sessionstore/src/nsSessionStartup.js	Mon Sep 08 10:35:44 2008 +0300
@@ -99,43 +99,44 @@ SessionStartup.prototype = {
                        getService(Ci.nsIPrefService).getBranch("browser.");
 
     // get file references
     var dirService = Cc["@mozilla.org/file/directory_service;1"].
                      getService(Ci.nsIProperties);
-    this._sessionFile = dirService.get("ProfD", Ci.nsILocalFile);
-    this._sessionFile.append("sessionstore.js");
+    let sessionFile = dirService.get("ProfD", Ci.nsILocalFile);
+    sessionFile.append("sessionstore.js");
+    
+    let doResumeSession = this._prefBranch.getBoolPref("sessionstore.resume_session_once") ||
+                          this._prefBranch.getIntPref("startup.page") == 3;
     
     // only read the session file if config allows possibility of restoring
     var resumeFromCrash = this._prefBranch.getBoolPref("sessionstore.resume_from_crash");
-    if ((resumeFromCrash || this._doResumeSession()) && this._sessionFile.exists()) {
-      // get string containing session state
-      this._iniString = this._readStateFile(this._sessionFile);
-      if (this._iniString) {
-        try {
-          // parse the session state into JS objects
-          var s = new Components.utils.Sandbox("about:blank");
-          var initialState = Components.utils.evalInSandbox(this._iniString, s);
-
-          // set bool detecting crash
-          this._lastSessionCrashed =
-            initialState.session && initialState.session.state &&
-            initialState.session.state == STATE_RUNNING_STR;
-        // invalid .INI file - nothing can be restored
-        }
-        catch (ex) { debug("The session file is invalid: " + ex); } 
-      }
+    if (!resumeFromCrash && !doResumeSession || !sessionFile.exists())
+      return;
+    
+    // get string containing session state
+    this._iniString = this._readStateFile(sessionFile);
+    if (!this._iniString)
+      return;
+    
+    try {
+      // parse the session state into JS objects
+      var s = new Components.utils.Sandbox("about:blank");
+      var initialState = Components.utils.evalInSandbox(this._iniString, s);
     }
-
-    // prompt and check prefs
-    if (this._iniString) {
-      if (this._lastSessionCrashed && this._doRecoverSession())
-        this._sessionType = Ci.nsISessionStartup.RECOVER_SESSION;
-      else if (!this._lastSessionCrashed && this._doResumeSession())
-        this._sessionType = Ci.nsISessionStartup.RESUME_SESSION;
-      else
-        this._iniString = null; // reset the state string
-    }
+    catch (ex) { debug("The session file is invalid: " + ex); } 
+    
+    let lastSessionCrashed =
+      initialState && initialState.session && initialState.session.state &&
+      initialState.session.state == STATE_RUNNING_STR;
+    
+    // set the startup type
+    if (lastSessionCrashed && resumeFromCrash && this._doRecoverSession())
+      this._sessionType = Ci.nsISessionStartup.RECOVER_SESSION;
+    else if (!lastSessionCrashed && doResumeSession)
+      this._sessionType = Ci.nsISessionStartup.RESUME_SESSION;
+    else
+      this._iniString = null; // reset the state string
 
     if (this._sessionType != Ci.nsISessionStartup.NO_SESSION) {
       // wait for the first browser window to open
       var observerService = Cc["@mozilla.org/observer-service;1"].
                             getService(Ci.nsIObserverService);
@@ -235,28 +236,15 @@ SessionStartup.prototype = {
   },
 
 /* ........ Auxiliary Functions .............. */
 
   /**
-   * Whether or not to resume session, if not recovering from a crash.
-   * @returns bool
-   */
-  _doResumeSession: function sss_doResumeSession() {
-    return this._prefBranch.getIntPref("startup.page") == 3 || 
-      this._prefBranch.getBoolPref("sessionstore.resume_session_once");
-  },
-
-  /**
    * prompt user whether or not to restore the previous session,
    * if the browser crashed
    * @returns bool
    */
   _doRecoverSession: function sss_doRecoverSession() {
-    // do not prompt or resume, post-crash
-    if (!this._prefBranch.getBoolPref("sessionstore.resume_from_crash"))
-      return false;
-
     // if the prompt fails, recover anyway
     var recover = true;
 
     // allow extensions to hook in a more elaborate restore prompt
     // XXXzeniko drop this when we're using our own dialog instead of a standard prompt
@@ -358,11 +346,11 @@ SessionStartup.prototype = {
       }
       cvstream.close();
       
       return content.replace(/\r\n?/g, "\n");
     }
-    catch (ex) { } // inexisting file?
+    catch (ex) { Components.utils.reportError(ex); }
     
     return null;
   },
 
   /* ........ QueryInterface .............. */
@@ -379,10 +367,7 @@ SessionStartup.prototype = {
     { category: "app-startup", service: true }
   ]
 
 };
 
-//module initialization
-function NSGetModule(aCompMgr, aFileSpec) {
-  return XPCOMUtils.generateModule([SessionStartup]);
-}
-
+function NSGetModule(aCompMgr, aFileSpec)
+  XPCOMUtils.generateModule([SessionStartup]);
diff -r 14ce7619e9c1 browser/components/sessionstore/src/nsSessionStore.js
--- a/browser/components/sessionstore/src/nsSessionStore.js	Sat Sep 06 22:21:37 2008 +1200
+++ b/browser/components/sessionstore/src/nsSessionStore.js	Mon Sep 08 10:35:44 2008 +0300
@@ -148,13 +148,10 @@ SessionStoreService.prototype = {
   _lastClosedWindows: null,
 
   // not-"dirty" windows usually don't need to have their data updated
   _dirtyWindows: {},
 
-  // flag all windows as dirty
-  _dirty: false,
-
 /* ........ Global Event Handlers .............. */
 
   /**
    * Initialize the component
    */
@@ -194,11 +191,11 @@ SessionStoreService.prototype = {
                      getService(Ci.nsIProperties);
     this._sessionFile = dirService.get("ProfD", Ci.nsILocalFile);
     this._sessionFileBackup = this._sessionFile.clone();
     this._sessionFile.append("sessionstore.js");
     this._sessionFileBackup.append("sessionstore.bak");
-   
+
     // get string containing session state
     var iniString;
     try {
       var ss = Cc["@mozilla.org/browser/sessionstartup;1"].
                getService(Ci.nsISessionStartup);
@@ -209,27 +206,26 @@ SessionStoreService.prototype = {
 
     if (iniString) {
       try {
         // parse the session state into JS objects
         this._initialState = this._safeEval(iniString);
-        // set bool detecting crash
-        this._lastSessionCrashed =
+        
+        // if last session crashed, backup the session
+        let lastSessionCrashed =
           this._initialState.session && this._initialState.session.state &&
           this._initialState.session.state == STATE_RUNNING_STR;
+        if (lastSessionCrashed) {
+          try {
+            this._writeFile(this._sessionFileBackup, iniString);
+          }
+          catch (ex) { } // nothing else we can do here
+        }
         
         // make sure that at least the first window doesn't have anything hidden
         delete this._initialState.windows[0].hidden;
       }
       catch (ex) { debug("The session file is invalid: " + ex); }
-    }
-    
-    // if last session crashed, backup the session
-    if (this._lastSessionCrashed) {
-      try {
-        this._writeFile(this._sessionFileBackup, iniString);
-      }
-      catch (ex) { } // nothing else we can do here
     }
 
     // remove the session data files if crash recovery is disabled
     if (!this._resume_from_crash)
       this._clearDisk();
@@ -283,11 +279,10 @@ SessionStoreService.prototype = {
       // get a current snapshot of all windows
       this._forEachBrowserWindow(function(aWindow) {
         this._collectWindowData(aWindow);
       });
       this._dirtyWindows = [];
-      this._dirty = false;
       break;
     case "quit-application-granted":
       // freeze the data at what we've got (ignoring closing windows)
       this._loadState = STATE_QUITTING;
       break;
@@ -1290,27 +1285,28 @@ SessionStoreService.prototype = {
       delete winData.sidebar;
   },
 
   /**
    * serialize session data as Ini-formatted string
+   * @param aUpdateAll
+   *        Bool update all windows 
    * @returns string
    */
-  _getCurrentState: function sss_getCurrentState() {
+  _getCurrentState: function sss_getCurrentState(aUpdateAll) {
     var activeWindow = this._getMostRecentBrowserWindow();
     
     if (this._loadState == STATE_RUNNING) {
       // update the data for all windows with activities since the last save operation
       this._forEachBrowserWindow(function(aWindow) {
-        if (this._dirty || this._dirtyWindows[aWindow.__SSi] || aWindow == activeWindow) {
+        if (aUpdateAll || this._dirtyWindows[aWindow.__SSi] || aWindow == activeWindow) {
           this._collectWindowData(aWindow);
         }
         else { // always update the window features (whose change alone never triggers a save operation)
           this._updateWindowFeatures(aWindow);
         }
       }, this);
       this._dirtyWindows = [];
-      this._dirty = false;
     }
     
     // collect the data for all windows
     var total = [], windows = [];
     var nonPopupCount = 0;
@@ -1968,12 +1964,11 @@ SessionStoreService.prototype = {
   saveState: function sss_saveState(aUpdateAll) {
     // if crash recovery is disabled, only save session resuming information
     if (!this._resume_from_crash && this._loadState == STATE_RUNNING)
       return;
     
-    this._dirty = aUpdateAll;
-    var oState = this._getCurrentState();
+    var oState = this._getCurrentState(aUpdateAll);
     oState.session = { state: ((this._loadState == STATE_RUNNING) ? STATE_RUNNING_STR : STATE_STOPPED_STR) };
     
     var stateString = Cc["@mozilla.org/supports-string;1"].
                         createInstance(Ci.nsISupportsString);
     stateString.data = oState.toSource();
diff -r 14ce7619e9c1 browser/components/sidebar/src/nsSidebar.js
--- a/browser/components/sidebar/src/nsSidebar.js	Sat Sep 06 22:21:37 2008 +1200
+++ b/browser/components/sidebar/src/nsSidebar.js	Mon Sep 08 10:35:44 2008 +0300
@@ -96,15 +96,15 @@ nsSidebar.prototype.addPanel =
 nsSidebar.prototype.addPanel =
 function (aTitle, aContentURL, aCustomizeURL)
 {
     debug("addPanel(" + aTitle + ", " + aContentURL + ", " +
           aCustomizeURL + ")");
-   
+
     return this.addPanelInternal(aTitle, aContentURL, aCustomizeURL, false);
 }
 
-nsSidebar.prototype.addPersistentPanel = 
+nsSidebar.prototype.addPersistentPanel =
 function(aTitle, aContentURL, aCustomizeURL)
 {
     debug("addPersistentPanel(" + aTitle + ", " + aContentURL + ", " +
            aCustomizeURL + ")\n");
 
@@ -270,44 +270,46 @@ nsSidebar.prototype.getInterfaces = func
 // method of nsIClassInfo
 nsSidebar.prototype.getHelperForLanguage = function(count) {return null;}
 
 nsSidebar.prototype.QueryInterface =
 function (iid) {
-    if (!iid.equals(nsISidebar) &&
-        !iid.equals(nsISidebarExternal) &&
-        !iid.equals(nsIClassInfo) &&
-        !iid.equals(nsISupports))
-        throw Components.results.NS_ERROR_NO_INTERFACE;
-    return this;
+    if (iid.equals(nsISidebar) ||
+        iid.equals(nsISidebarExternal) ||
+        iid.equals(nsIClassInfo) ||
+        iid.equals(nsISupports))
+        return this;
+
+    throw Components.results.NS_ERROR_NO_INTERFACE;
 }
 
 var sidebarModule = new Object();
 
 sidebarModule.registerSelf =
 function (compMgr, fileSpec, location, type)
 {
     debug("registering (all right -- a JavaScript module!)");
     compMgr = compMgr.QueryInterface(Components.interfaces.nsIComponentRegistrar);
 
-    compMgr.registerFactoryLocation(SIDEBAR_CID, 
+    compMgr.registerFactoryLocation(SIDEBAR_CID,
                                     "Sidebar JS Component",
-                                    SIDEBAR_CONTRACTID, 
-                                    fileSpec, 
+                                    SIDEBAR_CONTRACTID,
+                                    fileSpec,
                                     location,
                                     type);
+
     const CATMAN_CONTRACTID = "@mozilla.org/categorymanager;1";
     const nsICategoryManager = Components.interfaces.nsICategoryManager;
     var catman = Components.classes[CATMAN_CONTRACTID].
                             getService(nsICategoryManager);
-                            
+
     const JAVASCRIPT_GLOBAL_PROPERTY_CATEGORY = "JavaScript global property";
     catman.addCategoryEntry(JAVASCRIPT_GLOBAL_PROPERTY_CATEGORY,
                             "sidebar",
                             SIDEBAR_CONTRACTID,
                             true,
                             true);
-                            
+
     catman.addCategoryEntry(JAVASCRIPT_GLOBAL_PROPERTY_CATEGORY,
                             "external",
                             SIDEBAR_CONTRACTID,
                             true,
                             true);
@@ -315,24 +317,24 @@ function (compMgr, fileSpec, location, t
 
 sidebarModule.getClassObject =
 function (compMgr, cid, iid) {
     if (!cid.equals(SIDEBAR_CID))
         throw Components.results.NS_ERROR_NO_INTERFACE;
-    
+
     if (!iid.equals(Components.interfaces.nsIFactory))
         throw Components.results.NS_ERROR_NOT_IMPLEMENTED;
-    
+
     return sidebarFactory;
 }
 
 sidebarModule.canUnload =
 function(compMgr)
 {
     debug("Unloading component.");
     return true;
 }
-    
+
 /* factory object */
 var sidebarFactory = new Object();
 
 sidebarFactory.createInstance =
 function (outer, iid) {
@@ -352,26 +354,17 @@ if (DEBUG)
 if (DEBUG)
     debug = function (s) { dump("-*- sidebar component: " + s + "\n"); }
 else
     debug = function (s) {}
 
-var strBundleService = null;
+// String bundle service
+var gStrBundleService = null;
+
 function srGetStrBundle(path)
 {
-   var strBundle = null;
-   if (!strBundleService) {
-       try {
-          strBundleService =
-          Components.classes["@mozilla.org/intl/stringbundle;1"].getService(); 
-          strBundleService = 
-          strBundleService.QueryInterface(Components.interfaces.nsIStringBundleService);
-       } catch (ex) {
-          dump("\n--** strBundleService failed: " + ex + "\n");
-          return null;
-      }
-   }
-   strBundle = strBundleService.createBundle(path); 
-   if (!strBundle) {
-       dump("\n--** strBundle createInstance failed **--\n");
-   }
-   return strBundle;
+  if (!gStrBundleService)
+    gStrBundleService =
+      Components.classes["@mozilla.org/intl/stringbundle;1"]
+                .getService(Components.interfaces.nsIStringBundleService);
+
+  return gStrBundleService.createBundle(path);
 }
diff -r 14ce7619e9c1 browser/config/mozconfig
--- a/browser/config/mozconfig	Sat Sep 06 22:21:37 2008 +1200
+++ b/browser/config/mozconfig	Mon Sep 08 10:35:44 2008 +0300
@@ -1,6 +1,5 @@
 # This file specifies the build flags for Firefox.  You can use it by adding:
 #  . $topsrcdir/browser/config/mozconfig
 # to the top of your mozconfig file.
 
-mk_add_options MOZ_CO_PROJECT=browser
 ac_add_options --enable-application=browser
diff -r 14ce7619e9c1 browser/fuel/test/Makefile.in
--- a/browser/fuel/test/Makefile.in	Sat Sep 06 22:21:37 2008 +1200
+++ b/browser/fuel/test/Makefile.in	Mon Sep 08 10:35:44 2008 +0300
@@ -45,10 +45,11 @@ include $(topsrcdir)/config/rules.mk
 include $(topsrcdir)/config/rules.mk
 
 _BROWSER_FILES =browser_Application.js \
 		browser_ApplicationPrefs.js \
 		browser_ApplicationStorage.js \
+		browser_ApplicationQuitting.js \
 		browser_Browser.js \
 		browser_Bookmarks.js \
 		ContentA.html \
 		ContentB.html \
 		ContentWithFrames.html \
diff -r 14ce7619e9c1 browser/fuel/test/browser_ApplicationQuitting.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/fuel/test/browser_ApplicationQuitting.js	Mon Sep 08 10:35:44 2008 +0300
@@ -0,0 +1,21 @@
+function test() {
+  let quitRequestObserver = {
+    observe: function(aSubject, aTopic, aData) {
+      ok(aTopic == "quit-application-requested" &&
+         aSubject instanceof Components.interfaces.nsISupportsPRBool,
+         "Received a quit request we're going to deny");
+      aSubject.data = true;
+    }
+  };
+  
+  // ensure that we don't accidentally quit
+  let os = Components.classes["@mozilla.org/observer-service;1"]
+                     .getService(Components.interfaces.nsIObserverService);
+  os.addObserver(quitRequestObserver, "quit-application-requested", false);
+  
+  ok(!Application.quit(),    "Tried to quit - and didn't succeed");
+  ok(!Application.restart(), "Tried to restart - and didn't succeed");
+  
+  // clean up
+  os.removeObserver(quitRequestObserver, "quit-application-requested", false);
+}
diff -r 14ce7619e9c1 browser/locales/en-US/chrome/browser/preferences/cookies.dtd
--- a/browser/locales/en-US/chrome/browser/preferences/cookies.dtd	Sat Sep 06 22:21:37 2008 +1200
+++ b/browser/locales/en-US/chrome/browser/preferences/cookies.dtd	Mon Sep 08 10:35:44 2008 +0300
@@ -20,11 +20,8 @@
 <!ENTITY     focusSearch1.key               "f">
 <!ENTITY     focusSearch2.key               "k">
 
 <!ENTITY     filter.label                   "Search:">
 <!ENTITY     filter.accesskey               "S">
-<!ENTITY     clear.label                    "Clear">
-<!ENTITY     clear.accesskey                "l">
 
 <!ENTITY     button.close.label             "Close">
 <!ENTITY     button.close.accesskey         "C">
-
diff -r 14ce7619e9c1 browser/themes/gnomestripe/browser/browser.css
--- a/browser/themes/gnomestripe/browser/browser.css	Sat Sep 06 22:21:37 2008 +1200
+++ b/browser/themes/gnomestripe/browser/browser.css	Mon Sep 08 10:35:44 2008 +0300
@@ -1130,25 +1130,21 @@ statusbarpanel#statusbar-display {
 statusbarpanel#statusbar-display {
   -moz-padding-start: 0;
 }
 
 #security-button {
-  list-style-image: none;
   min-width: 20px;
   -moz-box-direction: reverse;
-  display: none;
 }
 
 #security-button[level="high"],
 #security-button[level="low"] {
   list-style-image: url("chrome://browser/skin/Secure.png");
-  display: -moz-box;
 }
 
 #security-button[level="broken"] {
   list-style-image: url("chrome://browser/skin/Security-broken.png");
-  display: -moz-box;
 }
 
 /* XXXsw prevent margins of a value-less label from shifting the image */
 #security-button > label:not([value]) {
   display: none;
diff -r 14ce7619e9c1 browser/themes/pinstripe/browser/browser.css
--- a/browser/themes/pinstripe/browser/browser.css	Sat Sep 06 22:21:37 2008 +1200
+++ b/browser/themes/pinstripe/browser/browser.css	Mon Sep 08 10:35:44 2008 +0300
@@ -1491,27 +1491,20 @@ sidebarheader > .tabs-closebutton > .too
 
 
 /* ----- SECURITY DISPLAY ----- */
 
 #security-button {
-  display: none;
   -moz-box-direction: reverse;
 }
 
-#security-button[level="high"] {
-  list-style-image: url("chrome://browser/skin/Secure-statusbar.png");
-  display: -moz-box;
-}
-
+#security-button[level="high"] ,
 #security-button[level="low"] {
   list-style-image: url("chrome://browser/skin/Secure-statusbar.png");
-  display: -moz-box;
 }
 
 #security-button[level="broken"] {
   list-style-image: url("chrome://browser/skin/Secure-statusbar-broken.png");
-  display: -moz-box;
 }
 
 /* ----- PAGE REPORT DISPLAY ----- */
 
 #page-report-button {
diff -r 14ce7619e9c1 browser/themes/winstripe/browser/browser.css
--- a/browser/themes/winstripe/browser/browser.css	Sat Sep 06 22:21:37 2008 +1200
+++ b/browser/themes/winstripe/browser/browser.css	Mon Sep 08 10:35:44 2008 +0300
@@ -1299,25 +1299,21 @@ statusbarpanel#statusbar-display {
 #status-bar {
   border-top: none;
 }
 
 #security-button {
-  list-style-image: none;
   min-width: 20px;
   -moz-box-direction: reverse;
-  display: none;
 }
 
 #security-button[level="high"],
 #security-button[level="low"] {
   list-style-image: url("chrome://browser/skin/Secure.png");
-  display: -moz-box;
 }
 
 #security-button[level="broken"] {
   list-style-image: url("chrome://browser/skin/Security-broken.png");
-  display: -moz-box;
 }
 
 /* XXXsw prevent margins of a value-less label from shifting the image */
 #security-button > label:not([value]) {
   display: none;
diff -r 14ce7619e9c1 caps/include/nsScriptSecurityManager.h
--- a/caps/include/nsScriptSecurityManager.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/caps/include/nsScriptSecurityManager.h	Mon Sep 08 10:35:44 2008 +0300
@@ -421,11 +421,11 @@ private:
 
     // GetScriptSecurityManager is the only call that can make one
     nsScriptSecurityManager();
     virtual ~nsScriptSecurityManager();
 
-    static JSBool JS_DLL_CALLBACK
+    static JSBool
     CheckObjectAccess(JSContext *cx, JSObject *obj,
                       jsval id, JSAccessMode mode,
                       jsval *vp);
 
     // Returns null if a principal cannot be found; generally callers
diff -r 14ce7619e9c1 caps/src/nsJSPrincipals.cpp
--- a/caps/src/nsJSPrincipals.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/caps/src/nsJSPrincipals.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -47,23 +47,23 @@
 #include "nsIJSRuntimeService.h"
 #include "nsIServiceManager.h"
 #include "nsMemory.h"
 #include "nsStringBuffer.h"
 
-JS_STATIC_DLL_CALLBACK(void *)
+static void *
 nsGetPrincipalArray(JSContext *cx, JSPrincipals *prin)
 {
     return nsnull;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 nsGlobalPrivilegesEnabled(JSContext *cx, JSPrincipals *jsprin)
 {
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 nsJSPrincipalsSubsume(JSPrincipals *jsprin, JSPrincipals *other)
 {
     nsJSPrincipals *nsjsprin = static_cast<nsJSPrincipals *>(jsprin);
     nsJSPrincipals *nsother  = static_cast<nsJSPrincipals *>(other);
 
@@ -71,11 +71,11 @@ nsJSPrincipalsSubsume(JSPrincipals *jspr
     nsresult rv = nsjsprin->nsIPrincipalPtr->Subsumes(nsother->nsIPrincipalPtr,
                                                       &result);
     return NS_SUCCEEDED(rv) && result;
 }
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 nsDestroyJSPrincipals(JSContext *cx, struct JSPrincipals *jsprin)
 {
     nsJSPrincipals *nsjsprin = static_cast<nsJSPrincipals *>(jsprin);
 
     // We need to destroy the nsIPrincipal. We'll do this by adding
@@ -97,11 +97,11 @@ nsDestroyJSPrincipals(JSContext *cx, str
     nsjsprin->nsIPrincipalPtr->Release();
     // The nsIPrincipal that we release owns the JSPrincipal struct,
     // so we don't need to worry about "codebase"
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 nsTranscodeJSPrincipals(JSXDRState *xdr, JSPrincipals **jsprinp)
 {
     nsresult rv;
 
     if (xdr->mode == JSXDR_ENCODE) {
diff -r 14ce7619e9c1 caps/src/nsScriptSecurityManager.cpp
--- a/caps/src/nsScriptSecurityManager.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/caps/src/nsScriptSecurityManager.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -449,11 +449,11 @@ NS_IMPL_ISUPPORTS5(nsScriptSecurityManag
 ///////////////////////////////////////////////////
 // Methods implementing nsIScriptSecurityManager //
 ///////////////////////////////////////////////////
 
 ///////////////// Security Checks /////////////////
-JSBool JS_DLL_CALLBACK
+JSBool
 nsScriptSecurityManager::CheckObjectAccess(JSContext *cx, JSObject *obj,
                                            jsval id, JSAccessMode mode,
                                            jsval *vp)
 {
     // Get the security manager
diff -r 14ce7619e9c1 configure.in
--- a/configure.in	Sat Sep 06 22:21:37 2008 +1200
+++ b/configure.in	Mon Sep 08 10:35:45 2008 +0300
@@ -2952,10 +2952,15 @@ EOF
         fi # have visibility pragma bug
       fi   # have visibility pragma
     fi     # have visibility(default) attribute
   fi       # have visibility(hidden) attribute
 fi         # GNU_CC
+
+# visibility hidden flag for Sun Studio on Solaris
+if test -z "$GNU_CC" && test -z "$GNU_CXX" && test "$OS_ARCH" = "SunOS"; then
+VISIBILITY_FLAGS='-xldscope=hidden'
+fi         # Sun Studio on Solaris
 
 AC_SUBST(WRAP_SYSTEM_INCLUDES)
 AC_SUBST(VISIBILITY_FLAGS)
 
 dnl Checks for header files.
diff -r 14ce7619e9c1 content/base/public/nsContentUtils.h
--- a/content/base/public/nsContentUtils.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/content/base/public/nsContentUtils.h	Mon Sep 08 10:35:45 2008 +0300
@@ -92,10 +92,11 @@ class nsIWordBreaker;
 class nsIWordBreaker;
 class nsIJSRuntimeService;
 class nsIEventListenerManager;
 class nsIScriptContext;
 class nsIRunnable;
+class nsIInterfaceRequestor;
 template<class E> class nsCOMArray;
 class nsIPref;
 class nsVoidArray;
 struct JSRuntime;
 class nsICaseConversion;
@@ -1324,10 +1325,13 @@ public:
   static nsresult GetContextForEventHandlers(nsINode* aNode,
                                              nsIScriptContext** aContext);
 
   static JSContext *GetCurrentJSContext();
 
+                                             
+  static nsIInterfaceRequestor* GetSameOriginChecker();
+                                           
 private:
 
   static PRBool InitializeEventTable();
 
   static nsresult doReparentContentWrapper(nsIContent *aChild,
@@ -1401,10 +1405,12 @@ private:
   static PRBool sInitialized;
   static PRUint32 sScriptBlockerCount;
   static PRUint32 sRemovableScriptBlockerCount;
   static nsCOMArray<nsIRunnable>* sBlockedScriptRunners;
   static PRUint32 sRunnersCountAtFirstBlocker;
+
+  static nsIInterfaceRequestor* sSameOriginChecker;
 };
 
 #define NS_HOLD_JS_OBJECTS(obj, clazz)                                         \
   nsContentUtils::HoldJSObjects(NS_CYCLE_COLLECTION_UPCAST(obj, clazz),        \
                                 &NS_CYCLE_COLLECTION_NAME(clazz))
diff -r 14ce7619e9c1 content/base/src/nsContentUtils.cpp
--- a/content/base/src/nsContentUtils.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/content/base/src/nsContentUtils.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -153,10 +153,12 @@ static NS_DEFINE_CID(kXTFServiceCID, NS_
 #include "nsGenericHTMLElement.h"
 #include "nsAttrValue.h"
 #include "nsReferencedElement.h"
 #include "nsIUGenCategory.h"
 #include "nsIDragService.h"
+#include "nsIChannelEventSink.h"
+#include "nsIInterfaceRequestor.h"
 
 #ifdef IBMBIDI
 #include "nsIBidiKeyboard.h"
 #endif
 #include "nsCycleCollectionParticipant.h"
@@ -206,10 +208,11 @@ nsIBidiKeyboard *nsContentUtils::sBidiKe
 #endif
 PRUint32 nsContentUtils::sScriptBlockerCount = 0;
 PRUint32 nsContentUtils::sRemovableScriptBlockerCount = 0;
 nsCOMArray<nsIRunnable>* nsContentUtils::sBlockedScriptRunners = nsnull;
 PRUint32 nsContentUtils::sRunnersCountAtFirstBlocker = 0;
+nsIInterfaceRequestor* nsContentUtils::sSameOriginChecker = nsnull;
 
 nsIJSRuntimeService *nsAutoGCRoot::sJSRuntimeService;
 JSRuntime *nsAutoGCRoot::sJSScriptRuntime;
 
 PRUint32 nsMutationGuard::sMutationCount = 0;
@@ -254,10 +257,18 @@ EventListenerManagerHashClearEntry(PLDHa
     static_cast<EventListenerManagerMapEntry *>(entry);
 
   // Let the EventListenerManagerMapEntry clean itself up...
   lm->~EventListenerManagerMapEntry();
 }
+
+class nsSameOriginChecker : public nsIChannelEventSink,
+                            public nsIInterfaceRequestor
+{
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSICHANNELEVENTSINK
+  NS_DECL_NSIINTERFACEREQUESTOR
+};
 
 // static
 nsresult
 nsContentUtils::Init()
 {
@@ -897,10 +908,12 @@ nsContentUtils::Shutdown()
                sBlockedScriptRunners->Count() == 0,
                "How'd this happen?");
   delete sBlockedScriptRunners;
   sBlockedScriptRunners = nsnull;
 
+  NS_IF_RELEASE(sSameOriginChecker);
+  
   nsAutoGCRoot::Shutdown();
 }
 
 // static
 PRBool
@@ -4360,5 +4373,47 @@ nsContentUtils::IsNamedItem(nsIContent* 
     return val->GetAtomValue();
   }
 
   return nsnull;
 }
+
+/* static */
+nsIInterfaceRequestor*
+nsContentUtils::GetSameOriginChecker()
+{
+  if (!sSameOriginChecker) {
+    sSameOriginChecker = new nsSameOriginChecker();
+    NS_IF_ADDREF(sSameOriginChecker);
+  }
+  return sSameOriginChecker;
+}
+
+
+NS_IMPL_ISUPPORTS2(nsSameOriginChecker,
+                   nsIChannelEventSink,
+                   nsIInterfaceRequestor)
+
+NS_IMETHODIMP
+nsSameOriginChecker::OnChannelRedirect(nsIChannel *aOldChannel,
+                                       nsIChannel *aNewChannel,
+                                       PRUint32    aFlags)
+{
+  NS_PRECONDITION(aNewChannel, "Redirecting to null channel?");
+
+  nsCOMPtr<nsIURI> oldURI;
+  nsresult rv = aOldChannel->GetURI(getter_AddRefs(oldURI)); // The original URI
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsCOMPtr<nsIURI> newURI;
+  rv = aNewChannel->GetURI(getter_AddRefs(newURI)); // The new URI
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  return nsContentUtils::GetSecurityManager()->
+    CheckSameOriginURI(oldURI, newURI, PR_TRUE);
+}
+
+NS_IMETHODIMP
+nsSameOriginChecker::GetInterface(const nsIID & aIID, void **aResult)
+{
+  return QueryInterface(aIID, aResult);
+}
+
diff -r 14ce7619e9c1 content/base/test/Makefile.in
--- a/content/base/test/Makefile.in	Sat Sep 06 22:21:37 2008 +1200
+++ b/content/base/test/Makefile.in	Mon Sep 08 10:35:45 2008 +0300
@@ -184,13 +184,14 @@ _TEST_FILES = 	test_bug5141.html \
 		file_bug428847-1.xhtml \
 		file_bug428847-2.xhtml \
 		test_bug425201.html \
 		test_bug431701.html \
 		test_bug431833.html \
-		test_bug435425.html \
-		bug435425.sjs \
-		bug435425_redirect.sjs \
+# bug 451664
+#		test_bug435425.html \
+#		bug435425.sjs \
+#		bug435425_redirect.sjs \
 		test_bug438519.html \
 		test_bug444722.html \
 		test_bug451376.html \
 		test_text_replaceWholeText.html \
 		test_text_wholeText.html \
diff -r 14ce7619e9c1 content/canvas/src/nsCanvasRenderingContext2D.cpp
--- a/content/canvas/src/nsCanvasRenderingContext2D.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/content/canvas/src/nsCanvasRenderingContext2D.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -234,11 +234,10 @@ public:
                     PRBool forceWriteOnly)
         : mPattern(pat),
           mPrincipal(principalForSecurityCheck),
           mForceWriteOnly(forceWriteOnly)
     {
-        NS_PRECONDITION(mPrincipal, "Must have a principal");
     }
 
     void Apply(gfxContext* ctx) {
         ctx->SetPattern(mPattern);
     }
@@ -676,12 +675,10 @@ nsCanvasRenderingContext2D::DirtyAllStyl
 
 void
 nsCanvasRenderingContext2D::DoDrawImageSecurityCheck(nsIPrincipal* aPrincipal,
                                                      PRBool forceWriteOnly)
 {
-    NS_PRECONDITION(aPrincipal, "Must have a principal here");
-
     // Callers should ensure that mCanvasElement is non-null before calling this
     if (!mCanvasElement) {
         NS_WARNING("DoDrawImageSecurityCheck called without canvas element!");
         return;
     }
@@ -693,10 +690,13 @@ nsCanvasRenderingContext2D::DoDrawImageS
     if (forceWriteOnly) {
         mCanvasElement->SetWriteOnly();
         return;
     }
 
+    if (aPrincipal == nsnull)
+        return;
+
     nsCOMPtr<nsINode> elem = do_QueryInterface(mCanvasElement);
     if (elem) { // XXXbz How could this actually be null?
         PRBool subsumes;
         nsresult rv =
             elem->NodePrincipal()->Subsumes(aPrincipal, &subsumes);
@@ -704,11 +704,11 @@ nsCanvasRenderingContext2D::DoDrawImageS
         if (NS_SUCCEEDED(rv) && subsumes) {
             // This canvas has access to that image anyway
             return;
         }
     }
-    
+
     mCanvasElement->SetWriteOnly();
 }
 
 void
 nsCanvasRenderingContext2D::ApplyStyle(Style aWhichStyle)
@@ -2802,10 +2802,16 @@ nsCanvasRenderingContext2D::ThebesSurfac
 #ifdef MOZ_MEDIA
     /* Maybe it's <video>? */
     nsCOMPtr<nsIDOMHTMLVideoElement> ve = do_QueryInterface(imgElt);
     if (node && ve) {
         nsHTMLVideoElement *video = static_cast<nsHTMLVideoElement*>(ve.get());
+
+        /* If it doesn't have a principal, just bail */
+        nsCOMPtr<nsIPrincipal> principal = video->GetCurrentPrincipal();
+        if (!principal)
+            return NS_ERROR_DOM_SECURITY_ERR;
+
         PRUint32 videoWidth, videoHeight;
         rv = video->GetVideoWidth(&videoWidth);
         rv |= video->GetVideoHeight(&videoHeight);
         if (NS_FAILED(rv))
             return NS_ERROR_NOT_AVAILABLE;
@@ -2821,11 +2827,11 @@ nsCanvasRenderingContext2D::ThebesSurfac
 
         *aSurface = surf.forget().get();
         *widthOut = videoWidth;
         *heightOut = videoHeight;
 
-        NS_ADDREF(*prinOut = node->NodePrincipal());
+        *prinOut = principal.forget().get();
         *forceWriteOnlyOut = PR_FALSE;
 
         return NS_OK;
     }
 #endif
@@ -2848,14 +2854,30 @@ nsCanvasRenderingContext2D::ThebesSurfac
     PRUint32 status;
     imgRequest->GetImageStatus(&status);
     if ((status & imgIRequest::STATUS_LOAD_COMPLETE) == 0)
         return NS_ERROR_NOT_AVAILABLE;
 
+    // In case of data: URIs, we want to ignore principals;
+    // they should have the originating content's principal,
+    // but that's broken at the moment in imgLib.
     nsCOMPtr<nsIURI> uri;
-    rv = imgRequest->GetImagePrincipal(prinOut);
-    NS_ENSURE_SUCCESS(rv, rv);
-    NS_ENSURE_TRUE(*prinOut, NS_ERROR_DOM_SECURITY_ERR);
+    rv = imgRequest->GetURI(getter_AddRefs(uri));
+    NS_ENSURE_SUCCESS(rv, NS_ERROR_DOM_SECURITY_ERR);
+
+    PRBool isDataURI = PR_FALSE;
+    rv = uri->SchemeIs("data", &isDataURI);
+    NS_ENSURE_SUCCESS(rv, NS_ERROR_DOM_SECURITY_ERR);
+    
+    // Data URIs are always OK; set the principal
+    // to null to indicate that.
+    if (isDataURI) {
+        *prinOut = nsnull;
+    } else {
+        rv = imgRequest->GetImagePrincipal(prinOut);
+        NS_ENSURE_SUCCESS(rv, rv);
+        NS_ENSURE_TRUE(*prinOut, NS_ERROR_DOM_SECURITY_ERR);
+    }
 
     *forceWriteOnlyOut = PR_FALSE;
 
     rv = imgRequest->GetImage(getter_AddRefs(imgContainer));
     NS_ENSURE_SUCCESS(rv, rv);
diff -r 14ce7619e9c1 content/html/content/public/nsHTMLMediaElement.h
--- a/content/html/content/public/nsHTMLMediaElement.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/content/html/content/public/nsHTMLMediaElement.h	Mon Sep 08 10:35:45 2008 +0300
@@ -116,10 +116,13 @@ public:
 
   // Use this method to change the mReadyState member, so required
   // events can be fired.
   void ChangeReadyState(nsMediaReadyState aState);
 
+  // principal of the currently playing stream
+  nsIPrincipal* GetCurrentPrincipal();
+
 protected:
   nsresult PickMediaElement(nsAString& aChosenMediaResource);
   virtual nsresult InitializeDecoder(nsAString& aChosenMediaResource);
 
   nsRefPtr<nsVideoDecoder> mDecoder;
diff -r 14ce7619e9c1 content/html/content/src/nsHTMLMediaElement.cpp
--- a/content/html/content/src/nsHTMLMediaElement.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/content/html/content/src/nsHTMLMediaElement.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -771,5 +771,14 @@ nsresult nsHTMLMediaElement::DoneAddingC
 
 PRBool nsHTMLMediaElement::IsDoneAddingChildren()
 {
   return mIsDoneAddingChildren;
 }
+
+nsIPrincipal*
+nsHTMLMediaElement::GetCurrentPrincipal()
+{
+  if (!mDecoder)
+    return nsnull;
+
+  return mDecoder->GetCurrentPrincipal();
+}
diff -r 14ce7619e9c1 content/media/video/public/nsChannelReader.h
--- a/content/media/video/public/nsChannelReader.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/content/media/video/public/nsChannelReader.h	Mon Sep 08 10:35:45 2008 +0300
@@ -42,10 +42,11 @@
 #include "nsIChannel.h"
 #include "nsIInputStream.h"
 #include "nsIOutputStream.h"
 #include "nsIRequestObserver.h"
 #include "nsIStreamListener.h"
+#include "nsIPrincipal.h"
 
 #include "oggplay/oggplay.h"
 
 class nsOggDecoder;
 
@@ -70,13 +71,16 @@ class nsChannelToPipeListener : public n
   nsresult Init();
   void GetInputStream(nsIInputStream** aStream);
   void Stop();
   double BytesPerSecond() const;
 
+  nsIPrincipal* GetCurrentPrincipal();
+
 private:
   nsCOMPtr<nsIInputStream> mInput;
   nsCOMPtr<nsIOutputStream> mOutput;
+  nsCOMPtr<nsIPrincipal> mPrincipal;
   nsOggDecoder* mDecoder;
 
   // Interval when download started. Used in
   // computing bytes per second download rate.
   PRIntervalTime mIntervalStart;
@@ -102,11 +106,14 @@ public:
   long io_tell();  
 
   // Return average number of bytes per second that the 
   // download of the media resource is achieving.
   double BytesPerSecond() const;
-  
+
+  // return the principal that we saved in GetRequest
+  nsIPrincipal* GetCurrentPrincipal();
+
 public:
   nsCOMPtr<nsIChannel>  mChannel;
   nsCOMPtr<nsIInputStream>  mInput;
   nsCOMPtr<nsChannelToPipeListener> mListener;
   unsigned long mCurrentPosition;
diff -r 14ce7619e9c1 content/media/video/public/nsOggDecoder.h
--- a/content/media/video/public/nsOggDecoder.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/content/media/video/public/nsOggDecoder.h	Mon Sep 08 10:35:45 2008 +0300
@@ -165,10 +165,11 @@ class nsOggDecoder : public nsVideoDecod
   float GetVolume();
   void SetVolume(float volume);
   float GetDuration();
 
   void GetCurrentURI(nsIURI** aURI);
+  nsIPrincipal* GetCurrentPrincipal();
 
   virtual void UpdateBytesDownloaded(PRUint32 aBytes);
 
 protected:
   /******
diff -r 14ce7619e9c1 content/media/video/public/nsVideoDecoder.h
--- a/content/media/video/public/nsVideoDecoder.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/content/media/video/public/nsVideoDecoder.h	Mon Sep 08 10:35:45 2008 +0300
@@ -68,13 +68,15 @@ class nsVideoDecoder : public nsIObserve
   // Perform any initialization required for the decoder.
   // Return PR_TRUE on successful initialisation, PR_FALSE
   // on failure.
   virtual PRBool Init();
 
-  
   // Return the current URI being played or downloaded.
   virtual void GetCurrentURI(nsIURI** aURI) = 0;
+
+  // Return the principal of the current URI being played or downloaded.
+  virtual nsIPrincipal* GetCurrentPrincipal() = 0;
 
   // Return the time position in the video stream being
   // played measured in seconds.
   virtual float GetCurrentTime() = 0;
 
diff -r 14ce7619e9c1 content/media/video/src/nsChannelReader.cpp
--- a/content/media/video/src/nsChannelReader.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/content/media/video/src/nsChannelReader.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -39,10 +39,11 @@
 #include "nsThreadUtils.h"
 #include "nsNetUtil.h"
 #include "prlog.h"
 #include "nsOggDecoder.h"
 #include "nsChannelReader.h"
+#include "nsIScriptSecurityManager.h"
 
 nsChannelToPipeListener::nsChannelToPipeListener(nsOggDecoder* aDecoder) :
   mDecoder(aDecoder),
   mIntervalStart(0),
   mIntervalEnd(0),
@@ -85,10 +86,25 @@ nsresult nsChannelToPipeListener::OnStar
 {
   mIntervalStart = PR_IntervalNow();
   mIntervalEnd = mIntervalStart;
   mTotalBytes = 0;
   mDecoder->UpdateBytesDownloaded(mTotalBytes);
+
+  /* Get our principal */
+  nsCOMPtr<nsIChannel> chan(do_QueryInterface(aRequest));
+  if (chan) {
+    nsCOMPtr<nsIScriptSecurityManager> secMan =
+      do_GetService("@mozilla.org/scriptsecuritymanager;1");
+    if (secMan) {
+      nsresult rv = secMan->GetChannelPrincipal(chan,
+                                                getter_AddRefs(mPrincipal));
+      if (NS_FAILED(rv)) {
+        return rv;
+      }
+    }
+  }
+
   return NS_OK;
 }
 
 nsresult nsChannelToPipeListener::OnStopRequest(nsIRequest* aRequest, nsISupports* aContext, nsresult aStatus) 
 {
@@ -120,10 +136,16 @@ nsresult nsChannelToPipeListener::OnData
     nsresult rv = mOutput->Flush();
     NS_ENSURE_SUCCESS(rv, rv);
     mIntervalEnd = PR_IntervalNow();
   }
   return NS_OK;
+}
+
+nsIPrincipal*
+nsChannelToPipeListener::GetCurrentPrincipal()
+{
+  return mPrincipal;
 }
 
 NS_IMPL_ISUPPORTS2(nsChannelToPipeListener, nsIRequestObserver, nsIStreamListener)
 
 PRUint32 nsChannelReader::Available()
@@ -251,5 +273,13 @@ nsChannelReader::nsChannelReader()
   reader->seek = nsnull;
   reader->io_read = &oggplay_channel_reader_io_read;
   reader->io_seek = &oggplay_channel_reader_io_seek;
   reader->io_tell = &oggplay_channel_reader_io_tell;
 }
+
+nsIPrincipal*
+nsChannelReader::GetCurrentPrincipal()
+{
+  if (!mListener)
+    return nsnull;
+  return mListener->GetCurrentPrincipal();
+}
diff -r 14ce7619e9c1 content/media/video/src/nsOggDecoder.cpp
--- a/content/media/video/src/nsOggDecoder.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/content/media/video/src/nsOggDecoder.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -730,10 +730,17 @@ void nsOggDecoder::GetCurrentURI(nsIURI*
 void nsOggDecoder::GetCurrentURI(nsIURI** aURI)
 {
   NS_IF_ADDREF(*aURI = mURI);
 }
 
+nsIPrincipal* nsOggDecoder::GetCurrentPrincipal()
+{
+  if (!mReader)
+    return nsnull;
+
+  return mReader->GetCurrentPrincipal();
+}
 
 void nsOggDecoder::DisplayFirstFrame()
 {
   // Step through the decoded frames, allowing display of the first frame
   // of video.
diff -r 14ce7619e9c1 content/svg/content/src/crashtests/427325-1.svg
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/svg/content/src/crashtests/427325-1.svg	Mon Sep 08 10:35:45 2008 +0300
@@ -0,0 +1,11 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+
+  <filter id="f">
+    <feGaussianBlur stdDeviation="0.1"/>
+  </filter>
+
+  <g filter="url(#f)">
+    <rect width="100" height="100" fill="lime"/>
+  </g>
+
+</svg>
diff -r 14ce7619e9c1 content/svg/content/src/crashtests/crashtests.list
--- a/content/svg/content/src/crashtests/crashtests.list	Sat Sep 06 22:21:37 2008 +1200
+++ b/content/svg/content/src/crashtests/crashtests.list	Mon Sep 08 10:35:45 2008 +0300
@@ -34,7 +34,8 @@ load 410659-2.svg
 load 410659-2.svg
 load 410659-3.svg
 load 412104-1.svg
 load 413174-1.svg
 load 414188-1.svg
+load 427325-1.svg
 load 428228-1.svg
 load 428841-1.svg
diff -r 14ce7619e9c1 content/xbl/crashtests/378521-1.xhtml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/xbl/crashtests/378521-1.xhtml	Mon Sep 08 10:35:45 2008 +0300
@@ -0,0 +1,18 @@
+<html xmlns="http://www.w3.org/1999/xhtml" xmlns:html="http://www.w3.org/1999/xhtml">
+<head>
+<bindings xmlns="http://www.mozilla.org/xbl">
+  <binding id="foo" extends="html:input">
+    <content>
+      Foo?
+      <children/>
+    </content>
+  </binding>
+</bindings>
+</head>
+
+<body>
+<div>Hi!</div>
+<div style="-moz-binding: url(#foo)">XXX</div>
+</body>
+
+</html>
\ No newline at end of file
diff -r 14ce7619e9c1 content/xbl/crashtests/crashtests.list
--- a/content/xbl/crashtests/crashtests.list	Sat Sep 06 22:21:37 2008 +1200
+++ b/content/xbl/crashtests/crashtests.list	Mon Sep 08 10:35:45 2008 +0300
@@ -1,13 +1,14 @@ load 368276-1.xhtml
+load 342954-1.xhtml
+load 342954-2.xhtml
 load 368276-1.xhtml
 load 368641-1.xhtml
+load 378521-1.xhtml
 load 382376-1.xhtml
 load 382376-2.xhtml
-load 342954-1.xhtml
-load 342954-2.xhtml
 load 406900-1.xul
 load 406904-1.xhtml
 load 406904-2.xhtml
 load 418133-1.xhtml
+load 415192-1.xul
 load 421997-1.xhtml
-load 415192-1.xul
 load 432813-1.xhtml
diff -r 14ce7619e9c1 content/xbl/src/nsXBLBinding.cpp
--- a/content/xbl/src/nsXBLBinding.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/content/xbl/src/nsXBLBinding.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -111,22 +111,22 @@
 
 /***********************************************************************/
 //
 // The JS class for XBLBinding
 //
-JS_STATIC_DLL_CALLBACK(void)
+static void
 XBLFinalize(JSContext *cx, JSObject *obj)
 {
   nsIXBLDocumentInfo* docInfo =
     static_cast<nsIXBLDocumentInfo*>(::JS_GetPrivate(cx, obj));
   NS_RELEASE(docInfo);
   
   nsXBLJSClass* c = static_cast<nsXBLJSClass*>(::JS_GET_CLASS(cx, obj));
   c->Drop();
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XBLResolve(JSContext *cx, JSObject *obj, jsval id, uintN flags,
            JSObject **objp)
 {
   // Note: if we get here, that means that the implementation for some binding
   // was installed, which means that AllowScripts() tested true.  Hence no need
diff -r 14ce7619e9c1 content/xbl/src/nsXBLDocumentInfo.cpp
--- a/content/xbl/src/nsXBLDocumentInfo.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/content/xbl/src/nsXBLDocumentInfo.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -215,11 +215,11 @@ NS_INTERFACE_MAP_END
 NS_INTERFACE_MAP_END
 
 NS_IMPL_CYCLE_COLLECTING_ADDREF_AMBIGUOUS(nsXBLDocGlobalObject, nsIScriptGlobalObject)
 NS_IMPL_CYCLE_COLLECTING_RELEASE_AMBIGUOUS(nsXBLDocGlobalObject, nsIScriptGlobalObject)
 
-void JS_DLL_CALLBACK
+void
 XBL_ProtoErrorReporter(JSContext *cx,
                        const char *message,
                        JSErrorReport *report)
 {
   // Make an nsIScriptError and populate it with information from
diff -r 14ce7619e9c1 content/xbl/src/nsXBLPrototypeHandler.cpp
--- a/content/xbl/src/nsXBLPrototypeHandler.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/content/xbl/src/nsXBLPrototypeHandler.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -598,29 +598,28 @@ PRBool
 PRBool
 nsXBLPrototypeHandler::KeyEventMatched(nsIDOMKeyEvent* aKeyEvent,
                                        PRUint32 aCharCode,
                                        PRBool aIgnoreShiftKey)
 {
-  if (mDetail == -1)
-    return PR_TRUE; // No filters set up. It's generic.
+  if (mDetail != -1) {
+    // Get the keycode or charcode of the key event.
+    PRUint32 code;
 
-  // Get the keycode or charcode of the key event.
-  PRUint32 code;
+    if (mMisc) {
+      if (aCharCode)
+        code = aCharCode;
+      else
+        aKeyEvent->GetCharCode(&code);
+      if (IS_IN_BMP(code))
+        code = ToLowerCase(PRUnichar(code));
+    }
+    else
+      aKeyEvent->GetKeyCode(&code);
 
-  if (mMisc) {
-    if (aCharCode)
-      code = aCharCode;
-    else
-      aKeyEvent->GetCharCode(&code);
-    if (IS_IN_BMP(code))
-      code = ToLowerCase(PRUnichar(code));
+    if (code != PRUint32(mDetail))
+      return PR_FALSE;
   }
-  else
-    aKeyEvent->GetKeyCode(&code);
-
-  if (code != PRUint32(mDetail))
-    return PR_FALSE;
 
   return ModifiersMatchMask(aKeyEvent, aIgnoreShiftKey);
 }
 
 PRBool
diff -r 14ce7619e9c1 content/xbl/src/nsXBLService.cpp
--- a/content/xbl/src/nsXBLService.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/content/xbl/src/nsXBLService.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -1196,47 +1196,10 @@ nsXBLService::LoadBindingDocumentInfo(ns
   NS_IF_ADDREF(*aResult);
 
   return NS_OK;
 }
 
-class nsSameOriginChecker : public nsIChannelEventSink,
-                            public nsIInterfaceRequestor
-{
-  NS_DECL_ISUPPORTS
-  NS_DECL_NSICHANNELEVENTSINK
-  NS_DECL_NSIINTERFACEREQUESTOR
-};
-
-NS_IMPL_ISUPPORTS2(nsSameOriginChecker,
-                   nsIChannelEventSink,
-                   nsIInterfaceRequestor)
-
-NS_IMETHODIMP
-nsSameOriginChecker::OnChannelRedirect(nsIChannel *aOldChannel,
-                                       nsIChannel *aNewChannel,
-                                       PRUint32    aFlags)
-{
-    NS_PRECONDITION(aNewChannel, "Redirecting to null channel?");
-
-    nsCOMPtr<nsIURI> oldURI;
-    nsresult rv = aOldChannel->GetURI(getter_AddRefs(oldURI)); // The original URI
-    NS_ENSURE_SUCCESS(rv, rv);
-
-    nsCOMPtr<nsIURI> newURI;
-    rv = aNewChannel->GetURI(getter_AddRefs(newURI)); // The new URI
-    NS_ENSURE_SUCCESS(rv, rv);
-
-    return nsContentUtils::GetSecurityManager()->
-      CheckSameOriginURI(oldURI, newURI, PR_TRUE);
-}
-
-NS_IMETHODIMP
-nsSameOriginChecker::GetInterface(const nsIID & aIID, void **aResult)
-{
-    return QueryInterface(aIID, aResult);
-}
-
 nsresult
 nsXBLService::FetchBindingDocument(nsIContent* aBoundElement, nsIDocument* aBoundDocument,
                                    nsIURI* aDocumentURI, nsIURI* aBindingURI, 
                                    PRBool aForceSyncLoad, nsIDocument** aResult)
 {
@@ -1267,11 +1230,11 @@ nsXBLService::FetchBindingDocument(nsICo
   // Open channel
   nsCOMPtr<nsIChannel> channel;
   rv = NS_NewChannel(getter_AddRefs(channel), aDocumentURI, nsnull, loadGroup);
   NS_ENSURE_SUCCESS(rv, rv);
 
-  nsCOMPtr<nsIInterfaceRequestor> sameOriginChecker = new nsSameOriginChecker;
+  nsCOMPtr<nsIInterfaceRequestor> sameOriginChecker = nsContentUtils::GetSameOriginChecker();
   NS_ENSURE_TRUE(sameOriginChecker, NS_ERROR_OUT_OF_MEMORY);
 
   channel->SetNotificationCallbacks(sameOriginChecker);
 
   nsCOMPtr<nsIStreamListener> listener;
diff -r 14ce7619e9c1 dom/locales/en-US/chrome/layout/css.properties
--- a/dom/locales/en-US/chrome/layout/css.properties	Sat Sep 06 22:21:37 2008 +1200
+++ b/dom/locales/en-US/chrome/layout/css.properties	Mon Sep 08 10:35:45 2008 +0300
@@ -131,6 +131,7 @@ PEUnknownFontDesc=Unknown descriptor '%1
 PEUnknownFontDesc=Unknown descriptor '%1$S' in @font-face rule.
 PEMQExpectedExpressionStart=Expected '(' to start media query expression but found '%1$S'.
 PEMQExpressionEOF=contents of media query expression
 PEMQExpectedFeatureName=Expected media feature name but found '%1$S'.
 PEMQExpectedFeatureNameEnd=Expected ':' or ')' after media feature name but found '%1$S'.
+PEMQNoMinMaxWithoutValue=Media features with min- or max- must have a value.
 PEMQExpectedFeatureValue=Found invalid value for media feature.
diff -r 14ce7619e9c1 dom/public/idl/threads/nsIDOMThreads.idl
--- a/dom/public/idl/threads/nsIDOMThreads.idl	Sat Sep 06 22:21:37 2008 +1200
+++ b/dom/public/idl/threads/nsIDOMThreads.idl	Mon Sep 08 10:35:45 2008 +0300
@@ -120,10 +120,19 @@ interface nsIDOMWorkerPool : nsISupports
    * @param aSourceScript (in DOMString)
    *        The script to compile. See below for details on the scope in which
    *        the script will run.
    */
   nsIDOMWorkerThread createWorker(in DOMString aSourceScript);
+
+  /**
+   * Create a new worker object by evaluating the given script.
+   *
+   * @param aSourceURL (in AString)
+   *        The script url to load and compile. See below for details on the
+   *        scope in which the script will run.
+   */
+  nsIDOMWorkerThread createWorkerFromURL(in AString aSourceURL);
 };
 
 [scriptable, uuid(0f2a52ea-afc9-49e6-86dd-2d0cb65b5dd5)]
 interface nsIDOMThreadService : nsISupports
 {
diff -r 14ce7619e9c1 dom/src/base/nsDOMClassInfo.cpp
--- a/dom/src/base/nsDOMClassInfo.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/dom/src/base/nsDOMClassInfo.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -4345,11 +4345,11 @@ static JSClass sGlobalScopePolluterClass
   nsHTMLDocumentSH::ReleaseDocument
 };
 
 
 // static
-JSBool JS_DLL_CALLBACK
+JSBool
 nsWindowSH::GlobalScopePolluterGetProperty(JSContext *cx, JSObject *obj,
                                            jsval id, jsval *vp)
 {
   // Someone is accessing a element by referencing its name/id in the
   // global scope, do a security check to make sure that's ok.
@@ -4372,11 +4372,11 @@ nsWindowSH::GlobalScopePolluterGetProper
 
   return JS_TRUE;
 }
 
 // static
-JSBool JS_DLL_CALLBACK
+JSBool
 nsWindowSH::SecurityCheckOnSetProp(JSContext *cx, JSObject *obj, jsval id,
                                    jsval *vp)
 {
   // Someone is accessing a element by referencing its name/id in the
   // global scope, do a security check to make sure that's ok.
@@ -4390,11 +4390,11 @@ nsWindowSH::SecurityCheckOnSetProp(JSCon
   // manager set a JS exception for us.
   return NS_SUCCEEDED(rv);
 }
 
 // static
-JSBool JS_DLL_CALLBACK
+JSBool
 nsWindowSH::GlobalScopePolluterNewResolve(JSContext *cx, JSObject *obj,
                                           jsval id, uintN flags,
                                           JSObject **objp)
 {
   if (flags & (JSRESOLVE_ASSIGNING | JSRESOLVE_DECLARING |
@@ -5824,11 +5824,11 @@ nsWindowSH::GlobalResolve(nsGlobalWindow
   return rv;
 }
 
 // Native code for window._content getter, this simply maps
 // window._content to window.content for backwards compatibility only.
-static JSBool JS_DLL_CALLBACK
+static JSBool
 ContentWindowGetter(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                     jsval *rval)
 {
   return ::JS_GetProperty(cx, obj, "content", rval);
 }
@@ -7028,11 +7028,11 @@ nsEventReceiverSH::ReallyIsEventName(jsv
 
   return PR_FALSE;
 }
 
 // static
-JSBool JS_DLL_CALLBACK
+JSBool
 nsEventReceiverSH::AddEventListenerHelper(JSContext *cx, JSObject *obj,
                                           uintN argc, jsval *argv, jsval *rval)
 {
   if (argc < 3 || argc > 4) {
     ThrowJSException(cx, NS_ERROR_XPC_NOT_ENOUGH_ARGS);
@@ -8014,11 +8014,11 @@ nsHTMLDocumentSH::ResolveImpl(JSContext 
 
   return doc->ResolveName(nsDependentJSString(str), nsnull, result);
 }
 
 // static
-JSBool JS_DLL_CALLBACK
+JSBool
 nsHTMLDocumentSH::DocumentOpen(JSContext *cx, JSObject *obj, uintN argc,
                                jsval *argv, jsval *rval)
 {
   if (argc > 2) {
     JSObject *global = ::JS_GetGlobalForObject(cx, obj);
@@ -8174,11 +8174,11 @@ nsHTMLDocumentSH::GetDocumentAllNodeList
   }
 
   return *nodeList != nsnull;
 }
 
-JSBool JS_DLL_CALLBACK
+JSBool
 nsHTMLDocumentSH::DocumentAllGetProperty(JSContext *cx, JSObject *obj,
                                          jsval id, jsval *vp)
 {
   // document.all.item and .namedItem get their value in the
   // newResolve hook, so nothing to do for those properties here. And
@@ -8258,11 +8258,11 @@ nsHTMLDocumentSH::DocumentAllGetProperty
   }
 
   return JS_TRUE;
 }
 
-JSBool JS_DLL_CALLBACK
+JSBool
 nsHTMLDocumentSH::DocumentAllNewResolve(JSContext *cx, JSObject *obj, jsval id,
                                         uintN flags, JSObject **objp)
 {
   if (flags & JSRESOLVE_ASSIGNING) {
     // Nothing to do here if we're assigning
@@ -8334,19 +8334,19 @@ nsHTMLDocumentSH::DocumentAllNewResolve(
 }
 
 // Finalize hook used by document related JS objects, but also by
 // sGlobalScopePolluterClass!
 
-void JS_DLL_CALLBACK
+void
 nsHTMLDocumentSH::ReleaseDocument(JSContext *cx, JSObject *obj)
 {
   nsIHTMLDocument *doc = (nsIHTMLDocument *)::JS_GetPrivate(cx, obj);
 
   NS_IF_RELEASE(doc);
 }
 
-JSBool JS_DLL_CALLBACK
+JSBool
 nsHTMLDocumentSH::CallToGetPropMapper(JSContext *cx, JSObject *obj, uintN argc,
                                       jsval *argv, jsval *rval)
 {
   // Handle document.all("foo") style access to document.all.
 
@@ -8393,11 +8393,11 @@ GetDocumentAllHelper(JSContext *cx, JSOb
   }
 
   return obj;
 }
 
-JSBool JS_DLL_CALLBACK
+JSBool
 nsHTMLDocumentSH::DocumentAllHelperGetProperty(JSContext *cx, JSObject *obj,
                                                jsval id, jsval *vp)
 {
   if (id != nsDOMClassInfo::sAll_id) {
     return JS_TRUE;
@@ -8459,11 +8459,11 @@ nsHTMLDocumentSH::DocumentAllHelperGetPr
   }
 
   return JS_TRUE;
 }
 
-JSBool JS_DLL_CALLBACK
+JSBool
 nsHTMLDocumentSH::DocumentAllHelperNewResolve(JSContext *cx, JSObject *obj,
                                               jsval id, uintN flags,
                                               JSObject **objp)
 {
   if (id == nsDOMClassInfo::sAll_id) {
@@ -8482,11 +8482,11 @@ nsHTMLDocumentSH::DocumentAllHelperNewRe
 
   return JS_TRUE;
 }
 
 
-JSBool JS_DLL_CALLBACK
+JSBool
 nsHTMLDocumentSH::DocumentAllTagsNewResolve(JSContext *cx, JSObject *obj,
                                             jsval id, uintN flags,
                                             JSObject **objp)
 {
   if (JSVAL_IS_STRING(id)) {
@@ -8693,11 +8693,11 @@ nsHTMLDocumentSH::GetProperty(nsIXPConne
 }
 
 // HTMLElement helper
 
 // static
-JSBool JS_DLL_CALLBACK
+JSBool
 nsHTMLElementSH::ScrollIntoView(JSContext *cx, JSObject *obj, uintN argc,
                                 jsval *argv, jsval *rval)
 {
   nsCOMPtr<nsIXPConnectWrappedNative> wrapper;
 
@@ -9710,11 +9710,11 @@ nsHTMLOptionsCollectionSH::NewResolve(ns
   }
 
   return nsHTMLCollectionSH::NewResolve(wrapper, cx, obj, id, flags, objp, _retval);
 }
 
-JSBool JS_DLL_CALLBACK
+JSBool
 nsHTMLOptionsCollectionSH::Add(JSContext *cx, JSObject *obj, uintN argc,
                                jsval *argv, jsval *rval)
 {
   *rval = JSVAL_VOID;
 
diff -r 14ce7619e9c1 dom/src/base/nsDOMClassInfo.h
--- a/dom/src/base/nsDOMClassInfo.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/dom/src/base/nsDOMClassInfo.h	Mon Sep 08 10:35:45 2008 +0300
@@ -363,14 +363,12 @@ protected:
     }
 
     return PR_FALSE;
   }
 
-  static JSBool JS_DLL_CALLBACK AddEventListenerHelper(JSContext *cx,
-                                                       JSObject *obj,
-                                                       uintN argc, jsval *argv,
-                                                       jsval *rval);
+  static JSBool AddEventListenerHelper(JSContext *cx, JSObject *obj,
+                                       uintN argc, jsval *argv, jsval *rval);
 
   nsresult RegisterCompileHandler(nsIXPConnectWrappedNative *wrapper,
                                   JSContext *cx, JSObject *obj, jsval id,
                                   PRBool compile, PRBool remove,
                                   PRBool *did_define);
@@ -452,22 +450,17 @@ public:
   NS_IMETHOD OuterObject(nsIXPConnectWrappedNative *wrapper, JSContext * cx,
                          JSObject * obj, JSObject * *_retval);
   NS_IMETHOD InnerObject(nsIXPConnectWrappedNative *wrapper, JSContext * cx,
                          JSObject * obj, JSObject * *_retval);
 
-  static JSBool JS_DLL_CALLBACK GlobalScopePolluterNewResolve(JSContext *cx,
-                                                              JSObject *obj,
-                                                              jsval id,
-                                                              uintN flags,
-                                                              JSObject **objp);
-  static JSBool JS_DLL_CALLBACK GlobalScopePolluterGetProperty(JSContext *cx,
-                                                               JSObject *obj,
-                                                               jsval id,
-                                                               jsval *vp);
-  static JSBool JS_DLL_CALLBACK SecurityCheckOnSetProp(JSContext *cx,
-                                                       JSObject *obj, jsval id,
-                                                       jsval *vp);
+  static JSBool GlobalScopePolluterNewResolve(JSContext *cx, JSObject *obj,
+                                              jsval id, uintN flags,
+                                              JSObject **objp);
+  static JSBool GlobalScopePolluterGetProperty(JSContext *cx, JSObject *obj,
+                                               jsval id, jsval *vp);
+  static JSBool SecurityCheckOnSetProp(JSContext *cx, JSObject *obj, jsval id,
+                                       jsval *vp);
   static void InvalidateGlobalScopePolluter(JSContext *cx, JSObject *obj);
   static nsresult InstallGlobalScopePolluter(JSContext *cx, JSObject *obj,
                                              nsIHTMLDocument *doc);
 
   static nsIClassInfo *doCreate(nsDOMClassInfoData* aData)
@@ -843,43 +836,32 @@ protected:
   }
 
   static nsresult ResolveImpl(JSContext *cx,
                               nsIXPConnectWrappedNative *wrapper, jsval id,
                               nsISupports **result);
-  static JSBool JS_DLL_CALLBACK DocumentOpen(JSContext *cx, JSObject *obj,
-                                             uintN argc, jsval *argv,
-                                             jsval *rval);
+  static JSBool DocumentOpen(JSContext *cx, JSObject *obj, uintN argc,
+                             jsval *argv, jsval *rval);
   static JSBool GetDocumentAllNodeList(JSContext *cx, JSObject *obj,
                                        nsIDOMDocument *doc,
                                        nsIDOMNodeList **nodeList);
 
 public:
-  static JSBool JS_DLL_CALLBACK DocumentAllGetProperty(JSContext *cx,
-                                                       JSObject *obj, jsval id,
-                                                       jsval *vp);
-  static JSBool JS_DLL_CALLBACK DocumentAllNewResolve(JSContext *cx,
-                                                      JSObject *obj, jsval id,
-                                                      uintN flags,
-                                                      JSObject **objp);
-  static void JS_DLL_CALLBACK ReleaseDocument(JSContext *cx, JSObject *obj);
-  static JSBool JS_DLL_CALLBACK CallToGetPropMapper(JSContext *cx,
-                                                    JSObject *obj, uintN argc,
-                                                    jsval *argv, jsval *rval);
-  static JSBool JS_DLL_CALLBACK DocumentAllHelperGetProperty(JSContext *cx,
-                                                             JSObject *obj,
-                                                             jsval id,
-                                                             jsval *vp);
-  static JSBool JS_DLL_CALLBACK DocumentAllHelperNewResolve(JSContext *cx,
-                                                            JSObject *obj,
-                                                            jsval id,
-                                                            uintN flags,
-                                                            JSObject **objp);
-  static JSBool JS_DLL_CALLBACK DocumentAllTagsNewResolve(JSContext *cx,
-                                                          JSObject *obj,
-                                                          jsval id,
-                                                          uintN flags,
-                                                          JSObject **objp);
+  static JSBool DocumentAllGetProperty(JSContext *cx, JSObject *obj, jsval id,
+                                       jsval *vp);
+  static JSBool DocumentAllNewResolve(JSContext *cx, JSObject *obj, jsval id,
+                                      uintN flags, JSObject **objp);
+  static void ReleaseDocument(JSContext *cx, JSObject *obj);
+  static JSBool CallToGetPropMapper(JSContext *cx, JSObject *obj, uintN argc,
+                                    jsval *argv, jsval *rval);
+  static JSBool DocumentAllHelperGetProperty(JSContext *cx, JSObject *obj,
+                                             jsval id, jsval *vp);
+  static JSBool DocumentAllHelperNewResolve(JSContext *cx, JSObject *obj,
+                                            jsval id, uintN flags,
+                                            JSObject **objp);
+  static JSBool DocumentAllTagsNewResolve(JSContext *cx, JSObject *obj,
+                                          jsval id, uintN flags,
+                                          JSObject **objp);
 
   NS_IMETHOD NewResolve(nsIXPConnectWrappedNative *wrapper, JSContext *cx,
                         JSObject *obj, jsval id, PRUint32 flags,
                         JSObject **objp, PRBool *_retval);
   NS_IMETHOD GetProperty(nsIXPConnectWrappedNative *wrapper, JSContext *cx,
@@ -903,13 +885,12 @@ protected:
 
   virtual ~nsHTMLElementSH()
   {
   }
 
-  static JSBool JS_DLL_CALLBACK ScrollIntoView(JSContext *cx, JSObject *obj,
-                                               uintN argc, jsval *argv,
-                                               jsval *rval);
+  static JSBool ScrollIntoView(JSContext *cx, JSObject *obj, uintN argc,
+                               jsval *argv, jsval *rval);
 
 public:
   NS_IMETHOD NewResolve(nsIXPConnectWrappedNative *wrapper, JSContext *cx,
                         JSObject *obj, jsval id, PRUint32 flags,
                         JSObject **objp, PRBool *_retval);
@@ -1051,12 +1032,12 @@ protected:
 
   virtual ~nsHTMLOptionsCollectionSH()
   {
   }
 
-  static JSBool JS_DLL_CALLBACK Add(JSContext *cx, JSObject *obj, uintN argc,
-                                    jsval *argv, jsval *rval);
+  static JSBool Add(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
+                    jsval *rval);
 
 public:
   NS_IMETHOD SetProperty(nsIXPConnectWrappedNative *wrapper, JSContext *cx,
                          JSObject *obj, jsval id, jsval *vp, PRBool *_retval);
   NS_IMETHOD NewResolve(nsIXPConnectWrappedNative *wrapper, JSContext *cx,
diff -r 14ce7619e9c1 dom/src/base/nsJSEnvironment.cpp
--- a/dom/src/base/nsJSEnvironment.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/dom/src/base/nsJSEnvironment.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -416,11 +416,11 @@ NS_HandleScriptError(nsIScriptGlobalObje
 
 // NOTE: This function could be refactored to use the above.  The only reason
 // it has not been done is that the code below only fills the error event
 // after it has a good nsPresContext - whereas using the above function
 // would involve always filling it.  Is that a concern?
-void JS_DLL_CALLBACK
+void
 NS_ScriptErrorReporter(JSContext *cx,
                        const char *message,
                        JSErrorReport *report)
 {
   // XXX this means we are not going to get error reports on non DOM contexts
@@ -604,11 +604,11 @@ NS_ScriptErrorReporter(JSContext *cx,
             : ""));
   }
 #endif
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 LocaleToUnicode(JSContext *cx, char *src, jsval *rval)
 {
   nsresult rv;
 
   if (!gDecoder) {
@@ -697,23 +697,23 @@ ChangeCase(JSContext *cx, JSString *src,
   *rval = STRING_TO_JSVAL(ucstr);
 
   return JS_TRUE;
 }
 
-static JSBool JS_DLL_CALLBACK
+static JSBool
 LocaleToUpperCase(JSContext *cx, JSString *src, jsval *rval)
 {
   return ChangeCase(cx, src, rval, ToUpperCase);
 }
 
-static JSBool JS_DLL_CALLBACK
+static JSBool
 LocaleToLowerCase(JSContext *cx, JSString *src, jsval *rval)
 {
   return ChangeCase(cx, src, rval, ToLowerCase);
 }
 
-static JSBool JS_DLL_CALLBACK
+static JSBool
 LocaleCompare(JSContext *cx, JSString *src1, JSString *src2, jsval *rval)
 {
   nsresult rv;
 
   if (!gCollation) {
@@ -868,11 +868,11 @@ GetPromptFromContext(nsJSContext* ctx)
   nsIPrompt* prompt;
   ireq->GetInterface(NS_GET_IID(nsIPrompt), (void**)&prompt);
   return prompt;
 }
 
-JSBool JS_DLL_CALLBACK
+JSBool
 nsJSContext::DOMOperationCallback(JSContext *cx)
 {
   nsresult rv;
 
   // Get the native context
@@ -2882,22 +2882,22 @@ static JSPropertySpec OptionsProperties[
   {"werror",    (int8)JSOPTION_WERROR,   JSPROP_ENUMERATE | JSPROP_PERMANENT},
   {"relimit",   (int8)JSOPTION_RELIMIT,  JSPROP_ENUMERATE | JSPROP_PERMANENT},
   {0}
 };
 
-static JSBool JS_DLL_CALLBACK
+static JSBool
 GetOptionsProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 {
   if (JSVAL_IS_INT(id)) {
     uint32 optbit = (uint32) JSVAL_TO_INT(id);
     if ((optbit & (optbit - 1)) == 0 && optbit <= JSOPTION_WERROR)
       *vp = (JS_GetOptions(cx) & optbit) ? JSVAL_TRUE : JSVAL_FALSE;
   }
   return JS_TRUE;
 }
 
-static JSBool JS_DLL_CALLBACK
+static JSBool
 SetOptionsProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 {
   if (JSVAL_IS_INT(id)) {
     uint32 optbit = (uint32) JSVAL_TO_INT(id);
 
@@ -3572,11 +3572,11 @@ nsJSContext::FireGCTimer(PRBool aLoadInP
   sLoadInProgressGCTimer = aLoadInProgress;
 
   first = PR_FALSE;
 }
 
-static JSBool JS_DLL_CALLBACK
+static JSBool
 DOMGCCallback(JSContext *cx, JSGCStatus status)
 {
   JSBool result = gOldJSGCCallback ? gOldJSGCCallback(cx, status) : JS_TRUE;
 
   if (status == JSGC_BEGIN && !NS_IsMainThread())
@@ -3728,11 +3728,11 @@ ReportAllJSExceptionsPrefChangedCallback
   PRBool reportAll = nsContentUtils::GetBoolPref(aPrefName, PR_FALSE);
   nsContentUtils::XPConnect()->SetReportAllJSExceptions(reportAll);
   return 0;
 }
 
-JS_STATIC_DLL_CALLBACK(JSPrincipals *)
+static JSPrincipals *
 ObjectPrincipalFinder(JSContext *cx, JSObject *obj)
 {
   if (!sSecurityManager)
     return nsnull;
 
diff -r 14ce7619e9c1 dom/src/base/nsJSEnvironment.h
--- a/dom/src/base/nsJSEnvironment.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/dom/src/base/nsJSEnvironment.h	Mon Sep 08 10:35:45 2008 +0300
@@ -292,11 +292,11 @@ private:
 
   nsCOMPtr<nsISupports> mGlobalWrapperRef;
 
   static int PR_CALLBACK JSOptionChangedCallback(const char *pref, void *data);
 
-  static JSBool JS_DLL_CALLBACK DOMOperationCallback(JSContext *cx);
+  static JSBool DOMOperationCallback(JSContext *cx);
 };
 
 class nsIJSRuntimeService;
 
 class nsJSRuntime : public nsIScriptRuntime
@@ -355,8 +355,8 @@ NS_DEFINE_STATIC_IID_ACCESSOR(nsIJSArgAr
 
 /* factory functions */
 nsresult NS_CreateJSRuntime(nsIScriptRuntime **aRuntime);
 
 /* prototypes */
-void JS_DLL_CALLBACK NS_ScriptErrorReporter(JSContext *cx, const char *message, JSErrorReport *report);
+void NS_ScriptErrorReporter(JSContext *cx, const char *message, JSErrorReport *report);
 
 #endif /* nsJSEnvironment_h___ */
diff -r 14ce7619e9c1 dom/src/json/nsJSON.cpp
--- a/dom/src/json/nsJSON.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/dom/src/json/nsJSON.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -722,11 +722,11 @@ NS_NewJSON(nsISupports* aOuter, REFNSIID
 
   return NS_OK;
 }
 
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 trace_json_stack(JSTracer *trc, JSTempValueRooter *tvr)
 {
   nsJSONObjectStack *tmp = static_cast<nsJSONObjectStack *>(tvr);
 
   for (PRUint32 i = 0; i < tmp->Length(); ++i) {
diff -r 14ce7619e9c1 dom/src/threads/Makefile.in
--- a/dom/src/threads/Makefile.in	Sat Sep 06 22:21:37 2008 +1200
+++ b/dom/src/threads/Makefile.in	Mon Sep 08 10:35:45 2008 +0300
@@ -51,10 +51,11 @@ REQUIRES = \
 REQUIRES = \
   caps \
   content \
   js \
   layout \
+  necko \
   pref \
   string \
   widget \
   xpcom \
   xpconnect \
@@ -62,10 +63,11 @@ REQUIRES = \
 
 CPPSRCS = \
   nsDOMThreadService.cpp \
   nsDOMWorkerBase.cpp \
   nsDOMWorkerPool.cpp \
+  nsDOMWorkerScriptLoader.cpp \
   nsDOMWorkerSecurityManager.cpp \
   nsDOMWorkerThread.cpp \
   nsDOMWorkerTimeout.cpp \
   $(NULL)
 
diff -r 14ce7619e9c1 dom/src/threads/nsAutoJSObjectHolder.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/src/threads/nsAutoJSObjectHolder.h	Mon Sep 08 10:35:45 2008 +0300
@@ -0,0 +1,160 @@
+/* -*- Mode: c++; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is worker threads.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Turner <bent.mozilla@gmail.com> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NSAUTOJSOBJECTHOLDER_H__
+#define __NSAUTOJSOBJECTHOLDER_H__
+
+#include "jsapi.h"
+
+/**
+ * Simple class that looks and acts like a JSObject* except that it unroots
+ * itself automatically if Root() is ever called. Designed to be rooted on the
+ * context or runtime (but not both!). Also automatically nulls its JSObject*
+ * on Unroot and asserts that Root has been called prior to assigning an object.
+ */
+class nsAutoJSObjectHolder
+{
+public:
+  /**
+   * Default constructor, no holding.
+   */
+  nsAutoJSObjectHolder()
+  : mRt(NULL), mObj(NULL), mHeld(PR_FALSE) { }
+
+  /**
+   * Hold by rooting on the context's runtime in the constructor, passing the
+   * result out.
+   */
+  nsAutoJSObjectHolder(JSContext* aCx, JSBool* aRv = NULL,
+                       JSObject* aObj = NULL)
+  : mRt(NULL), mObj(aObj), mHeld(JS_FALSE) {
+    JSBool rv = Hold(aCx);
+    if (aRv) {
+      *aRv = rv;
+    }
+  }
+
+  /**
+   * Hold by rooting on the runtime in the constructor, passing the result out.
+   */
+  nsAutoJSObjectHolder(JSRuntime* aRt, JSBool* aRv = NULL,
+                       JSObject* aObj = NULL)
+  : mRt(aRt), mObj(aObj), mHeld(JS_FALSE) {
+    JSBool rv = Hold(aRt);
+    if (aRv) {
+      *aRv = rv;
+    }
+  }
+
+  /**
+   * Always release on destruction.
+   */
+  ~nsAutoJSObjectHolder() {
+    Release();
+  }
+
+  /**
+   * Hold by rooting on the context's runtime.
+   */
+  JSBool Hold(JSContext* aCx) {
+    return Hold(JS_GetRuntime(aCx));
+  }
+
+  /**
+   * Hold by rooting on the runtime.
+   */
+  JSBool Hold(JSRuntime* aRt) {
+    if (!mHeld) {
+      mHeld = JS_AddNamedRootRT(aRt, &mObj, "nsAutoRootedJSObject");
+      if (mHeld) {
+        mRt = aRt;
+      }
+    }
+    return mHeld;
+  }
+
+  /**
+   * Manually release.
+   */
+  void Release() {
+    NS_ASSERTION(!mHeld || mRt, "Bad!");
+    if (mHeld) {
+      mHeld = !JS_RemoveRootRT(mRt, &mObj);
+      if (!mHeld) {
+        mRt = NULL;
+      }
+      mObj = NULL;
+    }
+  }
+
+  /**
+   * Determine if Hold has been called.
+   */
+  JSBool IsHeld() {
+    return mHeld;
+  }
+
+  /**
+   * Pretend to be a JSObject*.
+   */
+  JSObject* get() const {
+    return mObj;
+  }
+
+  /**
+   * Pretend to be a JSObject*.
+   */
+  operator JSObject*() const {
+    return get();
+  }
+
+  /**
+   * Pretend to be a JSObject*. Assert if not held.
+   */
+  JSObject* operator=(JSObject* aOther) {
+    NS_ASSERTION(mHeld, "Not rooted!");
+    return mObj = aOther;
+  }
+
+private:
+  JSRuntime* mRt;
+  JSObject* mObj;
+  JSBool mHeld;
+};
+
+#endif /* __NSAUTOJSOBJECTHOLDER_H__ */
diff -r 14ce7619e9c1 dom/src/threads/nsDOMThreadService.cpp
--- a/dom/src/threads/nsDOMThreadService.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/dom/src/threads/nsDOMThreadService.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -40,10 +40,12 @@
 #include "nsDOMThreadService.h"
 
 // Interfaces
 #include "nsIComponentManager.h"
 #include "nsIConsoleService.h"
+#include "nsIDocument.h"
+#include "nsIDOMDocument.h"
 #include "nsIEventTarget.h"
 #include "nsIGenericFactory.h"
 #include "nsIJSContextStack.h"
 #include "nsIJSRuntimeService.h"
 #include "nsIObserverService.h"
@@ -85,10 +87,18 @@ PR_STATIC_ASSERT(THREADPOOL_MAX_THREADS 
 
 // The maximum number of idle threads in the internal thread pool
 #define THREADPOOL_IDLE_THREADS 3
 
 PR_STATIC_ASSERT(THREADPOOL_MAX_THREADS >= THREADPOOL_IDLE_THREADS);
+
+// As we suspend threads for various reasons (navigating away from the page,
+// loading scripts, etc.) we open another slot in the thread pool for another
+// worker to use. We can't do this forever so we set an absolute cap on the
+// number of threads we'll allow to prevent DOS attacks.
+#define THREADPOOL_THREAD_CAP 20
+
+PR_STATIC_ASSERT(THREADPOOL_THREAD_CAP >= THREADPOOL_MAX_THREADS);
 
 // The number of times our JS operation callback will be called before yielding
 // the thread
 #define CALLBACK_YIELD_THRESHOLD 100
 
@@ -374,41 +384,46 @@ protected:
 
 /*******************************************************************************
  * JS environment function and callbacks
  */
 
-JSBool JS_DLL_CALLBACK
+JSBool
 DOMWorkerOperationCallback(JSContext* aCx)
 {
   nsDOMWorkerThread* worker = (nsDOMWorkerThread*)JS_GetContextPrivate(aCx);
 
   // Want a strong ref here to make sure that the monitor we wait on won't go
   // away.
   nsRefPtr<nsDOMWorkerPool> pool;
 
   PRBool wasSuspended = PR_FALSE;
+  PRBool extraThreadAllowed = PR_FALSE;
   jsrefcount suspendDepth = 0;
 
   while (1) {
     // Kill execution if we're canceled.
     if (worker->IsCanceled()) {
       LOG(("Forcefully killing JS for worker [0x%p]",
            static_cast<void*>(worker)));
 
       if (wasSuspended) {
-        gDOMThreadService->ChangeThreadPoolMaxThreads(-1);
+        if (extraThreadAllowed) {
+          gDOMThreadService->ChangeThreadPoolMaxThreads(-1);
+        }
         JS_ResumeRequest(aCx, suspendDepth);
       }
 
       // Kill exectuion of the currently running JS.
       return PR_FALSE;
     }
 
     // Break out if we're not suspended.
     if (!worker->IsSuspended()) {
       if (wasSuspended) {
-        gDOMThreadService->ChangeThreadPoolMaxThreads(-1);
+        if (extraThreadAllowed) {
+          gDOMThreadService->ChangeThreadPoolMaxThreads(-1);
+        }
         JS_ResumeRequest(aCx, suspendDepth);
       }
       break;
     }
 
@@ -425,12 +440,14 @@ DOMWorkerOperationCallback(JSContext* aC
       // Make sure to suspend our request while we block like this, otherwise we
       // prevent GC for everyone.
       suspendDepth = JS_SuspendRequest(aCx);
 
       // Since we're going to block this thread we should open up a new thread
-      // in the thread pool for other workers.
-      gDOMThreadService->ChangeThreadPoolMaxThreads(1);
+      // in the thread pool for other workers. Must check the return value to
+      // make sure we don't decrement when we failed.
+      extraThreadAllowed =
+        NS_SUCCEEDED(gDOMThreadService->ChangeThreadPoolMaxThreads(1));
 
       // Only do all this setup once.
       wasSuspended = PR_TRUE;
     }
 
@@ -450,11 +467,11 @@ DOMWorkerOperationCallback(JSContext* aC
 
   // Continue execution.
   return JS_TRUE;
 }
 
-void JS_DLL_CALLBACK
+void
 DOMWorkerErrorReporter(JSContext* aCx,
                        const char* aMessage,
                        JSErrorReport* aReport)
 {
   NS_ASSERTION(!NS_IsMainThread(), "Huh?!");
@@ -763,10 +780,18 @@ nsDOMThreadService::CreateJSContext()
   JS_SetErrorReporter(cx, DOMWorkerErrorReporter);
 
   JS_SetOperationCallback(cx, DOMWorkerOperationCallback,
                           100 * JS_OPERATION_WEIGHT_BASE);
 
+  static JSSecurityCallbacks securityCallbacks = {
+    nsDOMWorkerSecurityManager::JSCheckAccess,
+    NULL,
+    NULL
+  };
+
+  JS_SetContextSecurityCallbacks(cx, &securityCallbacks);
+
   nsresult rv = nsContentUtils::XPConnect()->
     SetSecurityManagerForJSContext(cx, gWorkerSecurityManager, 0);
   NS_ENSURE_SUCCESS(rv, nsnull);
 
   return cx.forget();
@@ -830,10 +855,15 @@ nsDOMThreadService::ChangeThreadPoolMaxT
   NS_ENSURE_SUCCESS(rv, rv);
 
   PRInt32 newThreadCount = (PRInt32)currentThreadCount + (PRInt32)aDelta;
   NS_ASSERTION(newThreadCount >= THREADPOOL_MAX_THREADS,
                "Can't go below initial thread count!");
+
+  if (newThreadCount > THREADPOOL_THREAD_CAP) {
+    NS_WARNING("Thread pool cap reached!");
+    return NS_ERROR_FAILURE;
+  }
 
   rv = mThreadPool->SetThreadLimit((PRUint32)newThreadCount);
   NS_ENSURE_SUCCESS(rv, rv);
 
   return NS_OK;
@@ -976,11 +1006,17 @@ nsDOMThreadService::CreatePool(nsIDOMWor
 {
   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
 
   NS_ENSURE_TRUE(mThreadPool, NS_ERROR_ILLEGAL_DURING_SHUTDOWN);
 
-  nsRefPtr<nsDOMWorkerPool> pool(new nsDOMWorkerPool());
+  nsIDOMDocument* domDocument = nsContentUtils::GetDocumentFromCaller();
+  NS_ENSURE_TRUE(domDocument, NS_ERROR_UNEXPECTED);
+
+  nsCOMPtr<nsIDocument> callingDocument(do_QueryInterface(domDocument));
+  NS_ENSURE_TRUE(callingDocument, NS_ERROR_NO_INTERFACE);
+
+  nsRefPtr<nsDOMWorkerPool> pool(new nsDOMWorkerPool(callingDocument));
   NS_ENSURE_TRUE(pool, NS_ERROR_OUT_OF_MEMORY);
 
   nsresult rv = pool->Init();
   NS_ENSURE_SUCCESS(rv, rv);
 
diff -r 14ce7619e9c1 dom/src/threads/nsDOMWorkerPool.cpp
--- a/dom/src/threads/nsDOMWorkerPool.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/dom/src/threads/nsDOMWorkerPool.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -67,14 +67,16 @@
     for (PRUint32 i = 0; i < workerCount; i++) {          \
       mWorkers[i]-> _func _args ;                         \
     }                                                     \
   PR_END_MACRO
 
-nsDOMWorkerPool::nsDOMWorkerPool()
-: mParentGlobal(nsnull)
+nsDOMWorkerPool::nsDOMWorkerPool(nsIDocument* aDocument)
+: mParentGlobal(nsnull),
+  mParentDocument(aDocument)
 {
   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
+  NS_ASSERTION(aDocument, "Must have a document!");
 }
 
 nsDOMWorkerPool::~nsDOMWorkerPool()
 {
   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
@@ -232,10 +234,18 @@ nsDOMWorkerPool::ResumeWorkersForGlobal(
     nsAutoMonitor mon(mMonitor);
     mon.NotifyAll();
   }
 }
 
+nsIDocument*
+nsDOMWorkerPool::GetParentDocument()
+{
+  NS_ASSERTION(NS_IsMainThread(),
+               "Don't touch the non-threadsafe document off the main thread!");
+  return mParentDocument;
+}
+
 NS_IMETHODIMP
 nsDOMWorkerPool::PostMessage(const nsAString& aMessage)
 {
   nsresult rv = PostMessageInternal(aMessage);
   NS_ENSURE_SUCCESS(rv, rv);
@@ -274,19 +284,20 @@ nsDOMWorkerPool::GetErrorListener(nsIDOM
   NS_IF_ADDREF(*aListener = mErrorListener);
   return NS_OK;
 }
 
 NS_IMETHODIMP
-nsDOMWorkerPool::CreateWorker(const nsAString& fullScript,
+nsDOMWorkerPool::CreateWorker(const nsAString& aFullScript,
                               nsIDOMWorkerThread** _retval)
 {
   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
 
-  NS_ENSURE_ARG(!fullScript.IsEmpty());
+  NS_ENSURE_ARG(!aFullScript.IsEmpty());
   NS_ENSURE_ARG_POINTER(_retval);
 
-  nsRefPtr<nsDOMWorkerThread> worker(new nsDOMWorkerThread(this, fullScript));
+  nsRefPtr<nsDOMWorkerThread> worker =
+    new nsDOMWorkerThread(this, aFullScript, PR_FALSE);
   NS_ENSURE_TRUE(worker, NS_ERROR_OUT_OF_MEMORY);
 
   nsresult rv = worker->Init();
   NS_ENSURE_SUCCESS(rv, rv);
 
@@ -294,5 +305,28 @@ nsDOMWorkerPool::CreateWorker(const nsAS
   mWorkers.AppendElement(worker);
 
   NS_ADDREF(*_retval = worker);
   return NS_OK;
 }
+
+NS_IMETHODIMP
+nsDOMWorkerPool::CreateWorkerFromURL(const nsAString& aScriptURL,
+                                     nsIDOMWorkerThread** _retval)
+{
+  NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
+
+  NS_ENSURE_ARG(!aScriptURL.IsEmpty());
+  NS_ENSURE_ARG_POINTER(_retval);
+
+  nsRefPtr<nsDOMWorkerThread> worker =
+    new nsDOMWorkerThread(this, aScriptURL, PR_TRUE);
+  NS_ENSURE_TRUE(worker, NS_ERROR_OUT_OF_MEMORY);
+
+  nsresult rv = worker->Init();
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  NS_ASSERTION(!mWorkers.Contains(worker), "Um?!");
+  mWorkers.AppendElement(worker);
+
+  NS_ADDREF(*_retval = worker);
+  return NS_OK;
+}
diff -r 14ce7619e9c1 dom/src/threads/nsDOMWorkerPool.h
--- a/dom/src/threads/nsDOMWorkerPool.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/dom/src/threads/nsDOMWorkerPool.h	Mon Sep 08 10:35:45 2008 +0300
@@ -50,10 +50,11 @@
 #include "nsStringGlue.h"
 #include "nsTPtrArray.h"
 #include "prmon.h"
 
 class nsDOMWorkerThread;
+class nsIDocument;
 class nsIScriptError;
 class nsIScriptGlobalObject;
 
 /**
  * The pool is almost always touched only on the main thread.
@@ -63,20 +64,22 @@ class nsDOMWorkerPool : public nsDOMWork
                         public nsIClassInfo
 {
   friend class nsDOMThreadService;
   friend class nsDOMWorkerFunctions;
   friend class nsDOMWorkerPoolWeakRef;
+  friend class nsDOMWorkerScriptLoader;
+  friend class nsDOMWorkerStreamObserver;
   friend class nsDOMWorkerThread;
   friend class nsReportErrorRunnable;
   friend JSBool DOMWorkerOperationCallback(JSContext* aCx);
 
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSIDOMWORKERPOOL
   NS_DECL_NSICLASSINFO
 
-  nsDOMWorkerPool();
+  nsDOMWorkerPool(nsIDocument* aDocument);
 
   // For nsDOMWorkerBase
   virtual nsDOMWorkerPool* Pool() {
     return this;
   }
@@ -104,12 +107,17 @@ private:
 
   PRMonitor* Monitor() {
     return mMonitor;
   }
 
+  nsIDocument* GetParentDocument();
+
   // Weak reference to the window that created and owns this pool.
   nsISupports* mParentGlobal;
+
+  // Weak reference to the document that created this pool.
+  nsIDocument* mParentDocument;
 
   // Weak array of workers. The idea is that workers can be garbage collected
   // independently of the owning pool and other workers.
   nsTPtrArray<nsDOMWorkerThread> mWorkers;
 
diff -r 14ce7619e9c1 dom/src/threads/nsDOMWorkerScriptLoader.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/src/threads/nsDOMWorkerScriptLoader.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -0,0 +1,790 @@
+/* -*- Mode: c++; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is worker threads.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Turner <bent.mozilla@gmail.com> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsDOMWorkerScriptLoader.h"
+
+// Interfaces
+#include "nsIContentPolicy.h"
+#include "nsIIOService.h"
+#include "nsIRequest.h"
+#include "nsIScriptSecurityManager.h"
+#include "nsIStreamLoader.h"
+
+// Other includes
+#include "nsAutoLock.h"
+#include "nsContentErrors.h"
+#include "nsContentPolicyUtils.h"
+#include "nsContentUtils.h"
+#include "nsISupportsPrimitives.h"
+#include "nsNetError.h"
+#include "nsNetUtil.h"
+#include "nsScriptLoader.h"
+#include "nsThreadUtils.h"
+#include "pratom.h"
+
+// DOMWorker includes
+#include "nsDOMWorkerPool.h"
+#include "nsDOMThreadService.h"
+#include "nsDOMWorkerTimeout.h"
+
+#define LOG(_args) PR_LOG(gDOMThreadsLog, PR_LOG_DEBUG, _args)
+
+nsDOMWorkerScriptLoader::nsDOMWorkerScriptLoader()
+: mWorker(nsnull),
+  mTarget(nsnull),
+  mCx(NULL),
+  mScriptCount(0),
+  mCanceled(PR_FALSE),
+  mTrackedByWorker(PR_FALSE)
+{
+  // Created on worker thread.
+  NS_ASSERTION(!NS_IsMainThread(), "Wrong thread!");
+}
+
+nsDOMWorkerScriptLoader::~nsDOMWorkerScriptLoader()
+{
+  // Can't touch mWorker's lock
+  if (!mCanceled) {
+    // Destroyed on worker thread, unless canceled (and then who knows!).
+    NS_ASSERTION(!NS_IsMainThread(), "Wrong thread!");
+
+    if (mTrackedByWorker) {
+      jsrefcount suspendDepth;
+      if (mCx) {
+        suspendDepth = JS_SuspendRequest(mCx);
+      }
+
+      nsAutoLock lock(mWorker->Lock());
+  #ifdef DEBUG
+      PRBool removed =
+  #endif
+      mWorker->mScriptLoaders.RemoveElement(this);
+      NS_ASSERTION(removed, "Something is wrong here!");
+
+      if (mCx) {
+        JS_ResumeRequest(mCx, suspendDepth);
+      }
+    }
+  }
+}
+
+NS_IMPL_ISUPPORTS_INHERITED1(nsDOMWorkerScriptLoader, nsRunnable,
+                                                      nsIStreamLoaderObserver)
+
+nsresult
+nsDOMWorkerScriptLoader::LoadScripts(nsDOMWorkerThread* aWorker,
+                                     JSContext* aCx,
+                                     const nsTArray<nsString>& aURLs)
+{
+  NS_ASSERTION(!NS_IsMainThread(), "Wrong thread!");
+  NS_ASSERTION(aWorker, "Null worker!");
+  NS_ASSERTION(aCx, "Null context!");
+
+  NS_ASSERTION(!mWorker, "Not designed to be used more than once!");
+
+  mWorker = aWorker;
+  mCx = aCx;
+
+  mTarget = NS_GetCurrentThread();
+  NS_ASSERTION(mTarget, "This should never be null!");
+
+  {
+    JSAutoSuspendRequest asr(aCx);
+    nsAutoLock lock(mWorker->Lock());
+    mTrackedByWorker = nsnull != mWorker->mScriptLoaders.AppendElement(this);
+    NS_ASSERTION(mTrackedByWorker, "Failed to add loader to worker's array!");
+  }
+
+  if (mCanceled) {
+    return NS_ERROR_ABORT;
+  }
+
+  mScriptCount = aURLs.Length();
+  if (!mScriptCount) {
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  // Do all the memory work for these arrays now rather than checking for
+  // failures all along the way.
+  PRBool success = mLoadInfos.SetCapacity(mScriptCount);
+  NS_ENSURE_TRUE(success, NS_ERROR_OUT_OF_MEMORY);
+
+  // Need one runnable per script and then an extra for the finished
+  // notification.
+  success = mPendingRunnables.SetCapacity(mScriptCount + 1);
+  NS_ENSURE_TRUE(success, NS_ERROR_OUT_OF_MEMORY);
+
+  for (PRUint32 index = 0; index < mScriptCount; index++) {
+    ScriptLoadInfo* newInfo = mLoadInfos.AppendElement();
+    NS_ASSERTION(newInfo, "Shouldn't fail if SetCapacity succeeded above!");
+
+    newInfo->url.Assign(aURLs[index]);
+    if (newInfo->url.IsEmpty()) {
+      return NS_ERROR_INVALID_ARG;
+    }
+
+    success = newInfo->scriptObj.Hold(aCx);
+    NS_ENSURE_TRUE(success, NS_ERROR_FAILURE);
+  }
+
+  // Don't want timeouts, etc., from queuing up while we're waiting on the
+  // network or compiling.
+  AutoSuspendWorkerEvents aswe(this);
+
+  nsresult rv = DoRunLoop();
+
+  {
+    JSAutoSuspendRequest asr(aCx);
+    nsAutoLock lock(mWorker->Lock());
+#ifdef DEBUG
+    PRBool removed =
+#endif
+    mWorker->mScriptLoaders.RemoveElement(this);
+    NS_ASSERTION(removed, "Something is wrong here!");
+    mTrackedByWorker = PR_FALSE;
+   }
+
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  // Verify that all scripts downloaded and compiled.
+  rv = VerifyScripts();
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  rv = ExecuteScripts();
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  return NS_OK;
+}
+
+nsresult
+nsDOMWorkerScriptLoader::LoadScript(nsDOMWorkerThread* aWorker,
+                                    JSContext* aCx,
+                                    const nsString& aURL)
+{
+  nsAutoTArray<nsString, 1> url;
+  url.AppendElement(aURL);
+
+  return LoadScripts(aWorker, aCx, url);
+}
+
+nsresult
+nsDOMWorkerScriptLoader::DoRunLoop()
+{
+  NS_ASSERTION(!NS_IsMainThread(), "Wrong thread!");
+
+  volatile PRBool done = PR_FALSE;
+  mDoneRunnable = new ScriptLoaderDone(this, &done);
+  NS_ENSURE_TRUE(mDoneRunnable, NS_ERROR_OUT_OF_MEMORY);
+
+  nsresult rv = NS_DispatchToMainThread(this);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  if (!(done || mCanceled)) {
+    // Since we're going to lock up this thread we might as well allow the
+    // thread service to schedule another worker on a new thread.
+    nsDOMThreadService* threadService = nsDOMThreadService::get();
+    PRBool changed = NS_SUCCEEDED(threadService->ChangeThreadPoolMaxThreads(1));
+
+    while (!(done || mCanceled)) {
+      JSAutoSuspendRequest asr(mCx);
+      NS_ProcessNextEvent(mTarget);
+    }
+
+    if (changed) {
+      threadService->ChangeThreadPoolMaxThreads(-1);
+    }
+  }
+
+  return mCanceled ? NS_ERROR_ABORT : NS_OK;
+}
+
+nsresult
+nsDOMWorkerScriptLoader::VerifyScripts()
+{
+  nsresult rv = NS_OK;
+
+  for (PRUint32 index = 0; index < mScriptCount; index++) {
+    ScriptLoadInfo& loadInfo = mLoadInfos[index];
+    NS_ASSERTION(loadInfo.done, "Inconsistent state!");
+
+    if (NS_SUCCEEDED(loadInfo.result) && loadInfo.scriptObj) {
+      continue;
+    }
+
+    NS_ASSERTION(!loadInfo.scriptObj, "Inconsistent state!");
+
+    // Flag failure before worrying about whether or not to report an error.
+    rv = NS_FAILED(loadInfo.result) ? loadInfo.result : NS_ERROR_FAILURE;
+
+    // If loadInfo.result is a success code then the compiler probably reported
+    // an error already. Also we don't really care about NS_BINDING_ABORTED
+    // since that's the code we set when some other script had a problem and the
+    // rest were canceled.
+    if (NS_SUCCEEDED(loadInfo.result) || loadInfo.result == NS_BINDING_ABORTED) {
+      continue;
+    }
+
+    // Ok, this is the script that caused us to fail.
+
+    // Only throw an error there is no other pending exception.
+    if (!JS_IsExceptionPending(mCx)) {
+      NS_ConvertUTF16toUTF8 url(loadInfo.url);
+      JS_ReportError(mCx, "Failed to compile script: %s", url.get());
+    }
+    break;
+  }
+
+  return rv;
+}
+
+nsresult
+nsDOMWorkerScriptLoader::ExecuteScripts()
+{
+  // Now execute all the scripts.
+  for (PRUint32 index = 0; index < mScriptCount; index++) {
+    ScriptLoadInfo& loadInfo = mLoadInfos[index];
+
+    JSScript* script =
+      static_cast<JSScript*>(JS_GetPrivate(mCx, loadInfo.scriptObj));
+    NS_ASSERTION(script, "This shouldn't ever be null!");
+
+    JSObject* global = mWorker->mGlobal ?
+                       mWorker->mGlobal :
+                       JS_GetGlobalObject(mCx);
+    NS_ENSURE_STATE(global);
+
+    // Because we may have nested calls to this function we don't want the
+    // execution to automatically report errors. We let them propagate instead.
+    uint32 oldOpts =
+      JS_SetOptions(mCx, JS_GetOptions(mCx) | JSOPTION_DONT_REPORT_UNCAUGHT);
+
+    jsval val;
+    PRBool success = JS_ExecuteScript(mCx, global, script, &val);
+
+    JS_SetOptions(mCx, oldOpts);
+
+    if (!success) {
+      return NS_ERROR_FAILURE;
+    }
+  }
+  return NS_OK;
+}
+
+void
+nsDOMWorkerScriptLoader::Cancel()
+{
+  NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
+
+  NS_ASSERTION(!mCanceled, "Cancel called more than once!");
+  mCanceled = PR_TRUE;
+
+  for (PRUint32 index = 0; index < mScriptCount; index++) {
+    ScriptLoadInfo& loadInfo = mLoadInfos[index];
+
+    nsIRequest* request =
+      static_cast<nsIRequest*>(loadInfo.channel.get());
+    if (request) {
+#ifdef DEBUG
+      nsresult rv =
+#endif
+      request->Cancel(NS_BINDING_ABORTED);
+      NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "Failed to cancel channel!");
+    }
+  }
+
+  nsAutoTArray<ScriptLoaderRunnable*, 10> runnables;
+  {
+    nsAutoLock lock(mWorker->Lock());
+    runnables.AppendElements(mPendingRunnables);
+    mPendingRunnables.Clear();
+  }
+
+  PRUint32 runnableCount = runnables.Length();
+  for (PRUint32 index = 0; index < runnableCount; index++) {
+    runnables[index]->Revoke();
+  }
+
+  // We're about to post a revoked event to the worker thread, which seems
+  // silly, but we have to do this because the worker thread may be sleeping
+  // waiting on its event queue.
+  NotifyDone();
+}
+
+NS_IMETHODIMP
+nsDOMWorkerScriptLoader::Run()
+{
+  NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
+
+  // We may have been canceled already.
+  if (mCanceled) {
+    return NS_BINDING_ABORTED;
+  }
+
+  nsresult rv = RunInternal();
+  if (NS_SUCCEEDED(rv)) {
+    return rv;
+  }
+
+  // Ok, something failed beyond a normal cancel.
+
+  // If necko is holding a ref to us then we'll end up notifying in the
+  // OnStreamComplete method, not here.
+  PRBool needsNotify = PR_TRUE;
+
+  // Cancel any async channels that were already opened.
+  for (PRUint32 index = 0; index < mScriptCount; index++) {
+    ScriptLoadInfo& loadInfo = mLoadInfos[index];
+
+    nsIRequest* request = static_cast<nsIRequest*>(loadInfo.channel.get());
+    if (request) {
+#ifdef DEBUG
+      nsresult rvInner =
+#endif
+      request->Cancel(NS_BINDING_ABORTED);
+      NS_WARN_IF_FALSE(NS_SUCCEEDED(rvInner), "Failed to cancel channel!");
+
+      // Necko is holding a ref to us so make sure that the OnStreamComplete
+      // code sends the done event.
+      needsNotify = PR_FALSE;
+    }
+    else {
+      // Make sure to set this so that the OnStreamComplete code will dispatch
+      // the done event.
+      loadInfo.done = PR_TRUE;
+    }
+  }
+
+  if (needsNotify) {
+    NotifyDone();
+  }
+
+  return rv;
+}
+
+NS_IMETHODIMP
+nsDOMWorkerScriptLoader::OnStreamComplete(nsIStreamLoader* aLoader,
+                                          nsISupports* aContext,
+                                          nsresult aStatus,
+                                          PRUint32 aStringLen,
+                                          const PRUint8* aString)
+{
+  NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
+
+  // We may have been canceled already.
+  if (mCanceled) {
+    return NS_BINDING_ABORTED;
+  }
+
+  nsresult rv = OnStreamCompleteInternal(aLoader, aContext, aStatus, aStringLen,
+                                         aString);
+
+  // Dispatch the done event if we've received all the data.
+  for (PRUint32 index = 0; index < mScriptCount; index++) {
+    if (!mLoadInfos[index].done) {
+      // Some async load is still outstanding, don't notify yet.
+      break;
+    }
+
+    if (index == mScriptCount - 1) {
+      // All loads complete, signal the thread.
+      NotifyDone();
+    }
+  }
+
+  return rv;
+}
+
+nsresult
+nsDOMWorkerScriptLoader::RunInternal()
+{
+  NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
+
+  // Things we need to make all this work...
+  nsIDocument* parentDoc = mWorker->Pool()->GetParentDocument();
+  NS_ASSERTION(parentDoc, "Null parent document?!");
+
+  // All of these can potentially be null, but that should be ok. We'll either
+  // succeed without them or fail below.
+  nsIURI* parentBaseURI = parentDoc->GetBaseURI();
+  nsCOMPtr<nsILoadGroup> loadGroup(parentDoc->GetDocumentLoadGroup());
+  nsCOMPtr<nsIIOService> ios(do_GetIOService());
+
+  for (PRUint32 index = 0; index < mScriptCount; index++) {
+    ScriptLoadInfo& loadInfo = mLoadInfos[index];
+    nsresult& rv = loadInfo.result;
+
+    nsCOMPtr<nsIURI>& uri = loadInfo.finalURI;
+    rv = nsContentUtils::NewURIWithDocumentCharset(getter_AddRefs(uri),
+                                                   loadInfo.url, parentDoc,
+                                                   parentBaseURI);
+    if (NS_FAILED(rv)) {
+      return rv;
+    }
+
+    nsIScriptSecurityManager* secMan = nsContentUtils::GetSecurityManager();
+    NS_ENSURE_TRUE(secMan, NS_ERROR_FAILURE);
+
+    rv =
+      secMan->CheckLoadURIWithPrincipal(parentDoc->NodePrincipal(), uri,
+                                        nsIScriptSecurityManager::ALLOW_CHROME);
+    if (NS_FAILED(rv)) {
+      return rv;
+    }
+
+    PRInt16 shouldLoad = nsIContentPolicy::ACCEPT;
+    rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_SCRIPT,
+                                   uri,
+                                   parentDoc->NodePrincipal(),
+                                   parentDoc,
+                                   NS_LITERAL_CSTRING("text/javascript"),
+                                   nsnull,
+                                   &shouldLoad,
+                                   nsContentUtils::GetContentPolicy(),
+                                   secMan);
+    if (NS_FAILED(rv) || NS_CP_REJECTED(shouldLoad)) {
+      if (NS_FAILED(rv) || shouldLoad != nsIContentPolicy::REJECT_TYPE) {
+        return NS_ERROR_CONTENT_BLOCKED;
+      }
+      return NS_ERROR_CONTENT_BLOCKED_SHOW_ALT;
+    }
+
+    // We need to know which index we're on in OnStreamComplete so we know where
+    // to put the result.
+    nsCOMPtr<nsISupportsPRUint32> indexSupports =
+      do_CreateInstance(NS_SUPPORTS_PRUINT32_CONTRACTID, &rv);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    rv = indexSupports->SetData(index);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    // We don't care about progress so just use the simple stream loader for
+    // OnStreamComplete notification only.
+    nsCOMPtr<nsIStreamLoader> loader;
+    rv = NS_NewStreamLoader(getter_AddRefs(loader), this);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    rv = NS_NewChannel(getter_AddRefs(loadInfo.channel), uri, ios, loadGroup);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    rv = loadInfo.channel->AsyncOpen(loader, indexSupports);
+    if (NS_FAILED(rv)) {
+      // Null this out so we don't try to cancel it later.
+      loadInfo.channel = nsnull;
+      return rv;
+    }
+  }
+
+  return NS_OK;
+}
+
+nsresult
+nsDOMWorkerScriptLoader::OnStreamCompleteInternal(nsIStreamLoader* aLoader,
+                                                  nsISupports* aContext,
+                                                  nsresult aStatus,
+                                                  PRUint32 aStringLen,
+                                                  const PRUint8* aString)
+{
+  NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
+
+  nsCOMPtr<nsISupportsPRUint32> indexSupports(do_QueryInterface(aContext));
+  NS_ENSURE_TRUE(indexSupports, NS_ERROR_NO_INTERFACE);
+
+  PRUint32 index = PR_UINT32_MAX;
+  indexSupports->GetData(&index);
+
+  if (index >= mScriptCount) {
+    NS_NOTREACHED("This really can't fail or we'll hang!");
+    return NS_ERROR_FAILURE;
+  }
+
+  ScriptLoadInfo& loadInfo = mLoadInfos[index];
+
+  NS_ASSERTION(!loadInfo.done, "Got complete on the same load twice!");
+  loadInfo.done = PR_TRUE;
+
+#ifdef DEBUG
+  // Make sure we're seeing the channel that we expect.
+  nsCOMPtr<nsIRequest> request;
+  nsresult rvDebug = aLoader->GetRequest(getter_AddRefs(request));
+
+  // When we cancel sometimes we get null here. That should be ok, but only if
+  // we're canceled.
+  NS_ASSERTION(NS_SUCCEEDED(rvDebug) || mCanceled, "GetRequest failed!");
+
+  if (NS_SUCCEEDED(rvDebug)) {
+    nsCOMPtr<nsIChannel> channel(do_QueryInterface(request));
+    NS_ASSERTION(channel, "QI failed!");
+
+    nsCOMPtr<nsISupports> thisChannel(do_QueryInterface(channel));
+    NS_ASSERTION(thisChannel, "QI failed!");
+
+    nsCOMPtr<nsISupports> ourChannel(do_QueryInterface(loadInfo.channel));
+    NS_ASSERTION(ourChannel, "QI failed!");
+
+    NS_ASSERTION(thisChannel == ourChannel, "Wrong channel!");
+  }
+#endif
+
+  // Use an alias to keep rv and loadInfo.result in sync.
+  nsresult& rv = loadInfo.result = aStatus;
+
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  if (!(aStringLen && aString)) {
+    return rv = NS_ERROR_UNEXPECTED;
+  }
+
+  nsIDocument* parentDoc = mWorker->Pool()->GetParentDocument();
+  NS_ASSERTION(parentDoc, "Null parent document?!");
+
+  // Use the regular nsScriptLoader for this grunt work! Should be just fine
+  // because we're running on the main thread.
+  rv = nsScriptLoader::ConvertToUTF16(loadInfo.channel, aString, aStringLen,
+                                      EmptyString(), parentDoc,
+                                      loadInfo.scriptText);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  if (loadInfo.scriptText.IsEmpty()) {
+    return rv = NS_ERROR_FAILURE;
+  }
+
+  nsCString filename;
+  loadInfo.finalURI->GetSpec(filename);
+
+  if (filename.IsEmpty()) {
+    filename.Assign(NS_LossyConvertUTF16toASCII(loadInfo.url));
+  }
+  else {
+    // This will help callers figure out what their script url resolved to in
+    // case of errors.
+    loadInfo.url.Assign(NS_ConvertUTF8toUTF16(filename));
+  }
+
+  nsRefPtr<ScriptCompiler> compiler =
+    new ScriptCompiler(this, mCx, loadInfo.scriptText, filename,
+                       loadInfo.scriptObj);
+  NS_ASSERTION(compiler, "Out of memory!");
+  if (!compiler) {
+    return rv = NS_ERROR_OUT_OF_MEMORY;
+  }
+
+  rv = mTarget->Dispatch(compiler, NS_DISPATCH_NORMAL);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  return rv;
+}
+
+void
+nsDOMWorkerScriptLoader::NotifyDone()
+{
+  NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
+
+  if (!mDoneRunnable) {
+    // We've already completed, no need to cancel anything.
+    return;
+  }
+
+  for (PRUint32 index = 0; index < mScriptCount; index++) {
+    ScriptLoadInfo& loadInfo = mLoadInfos[index];
+    // Null both of these out because they aren't threadsafe and must be
+    // destroyed on this thread.
+    loadInfo.channel = nsnull;
+    loadInfo.finalURI = nsnull;
+
+    if (mCanceled) {
+      // Simulate a complete, yet failed, load.
+      loadInfo.done = PR_TRUE;
+      loadInfo.result = NS_BINDING_ABORTED;
+    }
+  }
+
+#ifdef DEBUG
+  nsresult rv =
+#endif
+  mTarget->Dispatch(mDoneRunnable, NS_DISPATCH_NORMAL);
+  NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "Couldn't dispatch done event!");
+
+  mDoneRunnable = nsnull;
+}
+
+void
+nsDOMWorkerScriptLoader::SuspendWorkerEvents()
+{
+  NS_ASSERTION(mWorker, "No worker yet!");
+  mWorker->SuspendTimeouts();
+}
+
+void
+nsDOMWorkerScriptLoader::ResumeWorkerEvents()
+{
+  NS_ASSERTION(mWorker, "No worker yet!");
+  mWorker->ResumeTimeouts();
+}
+
+nsDOMWorkerScriptLoader::
+ScriptLoaderRunnable::ScriptLoaderRunnable(nsDOMWorkerScriptLoader* aLoader)
+: mRevoked(PR_FALSE),
+  mLoader(aLoader)
+{
+  nsAutoLock lock(aLoader->Lock());
+#ifdef DEBUG
+  nsDOMWorkerScriptLoader::ScriptLoaderRunnable** added =
+#endif
+  aLoader->mPendingRunnables.AppendElement(this);
+  NS_ASSERTION(added, "This shouldn't fail because we SetCapacity earlier!");
+}
+
+nsDOMWorkerScriptLoader::
+ScriptLoaderRunnable::~ScriptLoaderRunnable()
+{
+  if (!mRevoked) {
+    nsAutoLock lock(mLoader->Lock());
+#ifdef DEBUG
+    PRBool removed =
+#endif
+    mLoader->mPendingRunnables.RemoveElement(this);
+    NS_ASSERTION(removed, "Someone has changed the array!");
+  }
+}
+
+void
+nsDOMWorkerScriptLoader::ScriptLoaderRunnable::Revoke()
+{
+  mRevoked = PR_TRUE;
+}
+
+nsDOMWorkerScriptLoader::
+ScriptCompiler::ScriptCompiler(nsDOMWorkerScriptLoader* aLoader,
+                               JSContext* aCx,
+                               const nsString& aScriptText,
+                               const nsCString& aFilename,
+                               nsAutoJSObjectHolder& aScriptObj)
+: ScriptLoaderRunnable(aLoader),
+  mCx(aCx),
+  mScriptText(aScriptText),
+  mFilename(aFilename),
+  mScriptObj(aScriptObj)
+{
+  NS_ASSERTION(aCx, "Null context!");
+  NS_ASSERTION(!aScriptText.IsEmpty(), "No script to compile!");
+  NS_ASSERTION(aScriptObj.IsHeld(), "Should be held!");
+}
+
+NS_IMETHODIMP
+nsDOMWorkerScriptLoader::ScriptCompiler::Run()
+{
+  NS_ASSERTION(!NS_IsMainThread(), "Wrong thread!");
+
+  if (mRevoked) {
+    return NS_OK;
+  }
+
+  NS_ASSERTION(!mScriptObj, "Already have a script object?!");
+  NS_ASSERTION(mScriptObj.IsHeld(), "Not held?!");
+  NS_ASSERTION(!mScriptText.IsEmpty(), "Shouldn't have empty source here!");
+
+  JSAutoRequest ar(mCx);
+
+  JSObject* global = JS_GetGlobalObject(mCx);
+  NS_ENSURE_STATE(global);
+
+  // Because we may have nested calls to this function we don't want the
+  // execution to automatically report errors. We let them propagate instead.
+  uint32 oldOpts =
+    JS_SetOptions(mCx, JS_GetOptions(mCx) | JSOPTION_DONT_REPORT_UNCAUGHT);
+
+  JSScript* script = JS_CompileUCScript(mCx, global, mScriptText.BeginReading(),
+                                        mScriptText.Length(), mFilename.get(),
+                                        1);
+  JS_SetOptions(mCx, oldOpts);
+
+  if (!script) {
+    return NS_ERROR_FAILURE;
+  }
+
+  mScriptObj = JS_NewScriptObject(mCx, script);
+  NS_ENSURE_STATE(mScriptObj);
+
+  return NS_OK;
+}
+
+nsDOMWorkerScriptLoader::
+ScriptLoaderDone::ScriptLoaderDone(nsDOMWorkerScriptLoader* aLoader,
+                                   volatile PRBool* aDoneFlag)
+: ScriptLoaderRunnable(aLoader),
+  mDoneFlag(aDoneFlag)
+{
+  NS_ASSERTION(aDoneFlag && !*aDoneFlag, "Bad setup!");
+}
+
+NS_IMETHODIMP
+nsDOMWorkerScriptLoader::ScriptLoaderDone::Run()
+{
+  NS_ASSERTION(!NS_IsMainThread(), "Wrong thread!");
+
+  if (mRevoked) {
+    return NS_OK;
+  }
+
+  *mDoneFlag = PR_TRUE;
+  return NS_OK;
+}
+
+nsDOMWorkerScriptLoader::
+AutoSuspendWorkerEvents::AutoSuspendWorkerEvents(nsDOMWorkerScriptLoader* aLoader)
+: mLoader(aLoader)
+{
+  NS_ASSERTION(aLoader, "Don't hand me null!");
+  aLoader->SuspendWorkerEvents();
+}
+
+nsDOMWorkerScriptLoader::
+AutoSuspendWorkerEvents::~AutoSuspendWorkerEvents()
+{
+  mLoader->ResumeWorkerEvents();
+}
diff -r 14ce7619e9c1 dom/src/threads/nsDOMWorkerScriptLoader.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/src/threads/nsDOMWorkerScriptLoader.h	Mon Sep 08 10:35:45 2008 +0300
@@ -0,0 +1,224 @@
+/* -*- Mode: c++; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is worker threads.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Turner <bent.mozilla@gmail.com> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NSDOMWORKERSCRIPTLOADER_H__
+#define __NSDOMWORKERSCRIPTLOADER_H__
+
+// Bases
+#include "nsThreadUtils.h"
+#include "nsIStreamLoader.h"
+
+// Interfaces
+#include "nsIChannel.h"
+#include "nsIURI.h"
+
+// Other includes
+#include "jsapi.h"
+#include "nsAutoPtr.h"
+#include "nsAutoJSObjectHolder.h"
+#include "nsCOMPtr.h"
+#include "nsStringGlue.h"
+#include "nsTArray.h"
+#include "prlock.h"
+
+// DOMWorker includes
+#include "nsDOMWorkerThread.h"
+
+/**
+ * This class takes a list of script URLs, downloads the scripts, compiles the
+ * scripts, and then finally executes them. Due to platform limitations all
+ * network operations must happen on the main thread so this object sends events
+ * back and forth from the worker thread to the main thread. The flow goes like
+ * this:
+ *
+ *  1. (Worker thread) nsDOMWorkerScriptLoader created.
+ *  2. (Worker thread) LoadScript(s) called. Some simple argument validation is
+ *                     performed (currently limited to ensuring that all
+ *                     arguments are strings). nsDOMWorkerScriptLoader is then
+ *                     dispatched to the main thread.
+ *  3. (Main thread)   Arguments validated as URIs, security checks performed,
+ *                     content policy consulted. Network loads begin.
+ *  4. (Necko thread)  Necko stuff!
+ *  5. (Main thread)   Completed downloads are packaged in a ScriptCompiler
+ *                     runnable and sent to the worker thread.
+ *  6. (Worker thread) ScriptCompiler runnables are processed (i.e. their
+ *                     scripts are compiled) in the order in which the necko
+ *                     downloads completed.
+ *  7. (Worker thread) After all loads complete and all compilation succeeds
+ *                     the scripts are executed in the order that the URLs were
+ *                     given to LoadScript(s).
+ *
+ * Currently if *anything* after 2 fails then we cancel any pending loads and
+ * bail out entirely.
+ */
+class nsDOMWorkerScriptLoader : public nsRunnable,
+                                public nsIStreamLoaderObserver
+{
+  friend class AutoSuspendWorkerEvents;
+  friend class nsDOMWorkerFunctions;
+  friend class nsDOMWorkerThread;
+  friend class ScriptLoaderRunnable;
+
+public:
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_NSIRUNNABLE
+  NS_DECL_NSISTREAMLOADEROBSERVER
+
+  nsDOMWorkerScriptLoader();
+
+  nsresult LoadScripts(nsDOMWorkerThread* aWorker,
+                       JSContext* aCx,
+                       const nsTArray<nsString>& aURLs);
+
+  nsresult LoadScript(nsDOMWorkerThread* aWorker,
+                       JSContext* aCx,
+                       const nsString& aURL);
+
+  void Cancel();
+
+private:
+  ~nsDOMWorkerScriptLoader();
+
+  nsresult DoRunLoop();
+  nsresult VerifyScripts();
+  nsresult ExecuteScripts();
+
+  nsresult RunInternal();
+
+  nsresult OnStreamCompleteInternal(nsIStreamLoader* aLoader,
+                                    nsISupports* aContext,
+                                    nsresult aStatus,
+                                    PRUint32 aStringLen,
+                                    const PRUint8* aString);
+
+  void NotifyDone();
+
+  void SuspendWorkerEvents();
+  void ResumeWorkerEvents();
+
+  PRLock* Lock() {
+    return mWorker->Lock();
+  }
+
+  class ScriptLoaderRunnable : public nsRunnable
+  {
+  protected:
+    // Meant to be inherited.
+    ScriptLoaderRunnable(nsDOMWorkerScriptLoader* aLoader);
+    virtual ~ScriptLoaderRunnable();
+
+  public:
+    void Revoke();
+
+  protected:
+    PRBool mRevoked;
+
+  private:
+    nsDOMWorkerScriptLoader* mLoader;
+  };
+
+  class ScriptCompiler : public ScriptLoaderRunnable
+  {
+  public:
+    NS_DECL_NSIRUNNABLE
+
+    ScriptCompiler(nsDOMWorkerScriptLoader* aLoader,
+                   JSContext* aCx,
+                   const nsString& aScriptText,
+                   const nsCString& aFilename,
+                   nsAutoJSObjectHolder& aScriptObj);
+
+  private:
+    JSContext* mCx;
+    nsString mScriptText;
+    nsCString mFilename;
+    nsAutoJSObjectHolder& mScriptObj;
+  };
+
+  class ScriptLoaderDone : public ScriptLoaderRunnable
+  {
+  public:
+    NS_DECL_NSIRUNNABLE
+
+    ScriptLoaderDone(nsDOMWorkerScriptLoader* aLoader,
+                     volatile PRBool* aDoneFlag);
+
+  private:
+    volatile PRBool* mDoneFlag;
+  };
+
+  class AutoSuspendWorkerEvents
+  {
+  public:
+    AutoSuspendWorkerEvents(nsDOMWorkerScriptLoader* aLoader);
+    ~AutoSuspendWorkerEvents();
+
+  private:
+    nsDOMWorkerScriptLoader* mLoader;
+  };
+
+  struct ScriptLoadInfo
+  {
+    ScriptLoadInfo() : done(PR_FALSE), result(NS_ERROR_NOT_INITIALIZED) { }
+
+    nsString url;
+    nsString scriptText;
+    PRBool done;
+    nsresult result;
+    nsCOMPtr<nsIURI> finalURI;
+    nsCOMPtr<nsIChannel> channel;
+    nsAutoJSObjectHolder scriptObj;
+  };
+
+  nsDOMWorkerThread* mWorker;
+  nsIThread* mTarget;
+  JSContext* mCx;
+
+  nsRefPtr<ScriptLoaderDone> mDoneRunnable;
+
+  PRUint32 mScriptCount;
+  nsTArray<ScriptLoadInfo> mLoadInfos;
+
+  PRPackedBool mCanceled;
+  PRPackedBool mTrackedByWorker;
+
+  // Protected by mWorker's lock!
+  nsTArray<ScriptLoaderRunnable*> mPendingRunnables;
+};
+
+#endif /* __NSDOMWORKERSCRIPTLOADER_H__ */
diff -r 14ce7619e9c1 dom/src/threads/nsDOMWorkerSecurityManager.cpp
--- a/dom/src/threads/nsDOMWorkerSecurityManager.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/dom/src/threads/nsDOMWorkerSecurityManager.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -86,5 +86,15 @@ nsDOMWorkerSecurityManager::CanAccess(PR
                                       jsval aName,
                                       void** aPolicy)
 {
   return NS_OK;
 }
+
+JSBool
+nsDOMWorkerSecurityManager::JSCheckAccess(JSContext *cx,
+                                          JSObject *obj,
+                                          jsval id,
+                                          JSAccessMode mode,
+                                          jsval *vp)
+{
+  return JS_TRUE;
+}
diff -r 14ce7619e9c1 dom/src/threads/nsDOMWorkerSecurityManager.h
--- a/dom/src/threads/nsDOMWorkerSecurityManager.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/dom/src/threads/nsDOMWorkerSecurityManager.h	Mon Sep 08 10:35:45 2008 +0300
@@ -38,14 +38,19 @@
 
 #ifndef __NSDOMWORKERSECURITYMANAGER_H__
 #define __NSDOMWORKERSECURITYMANAGER_H__
 
 #include "nsIXPCSecurityManager.h"
+#include "jsapi.h"
 
 class nsDOMWorkerSecurityManager : public nsIXPCSecurityManager
 {
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSIXPCSECURITYMANAGER
+
+  static JSBool JSCheckAccess(JSContext *cx, JSObject *obj, jsval id,
+                              JSAccessMode mode, jsval *vp);
+
 };
 
 #endif /* __NSDOMWORKERSECURITYMANAGER_H__ */
diff -r 14ce7619e9c1 dom/src/threads/nsDOMWorkerThread.cpp
--- a/dom/src/threads/nsDOMWorkerThread.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/dom/src/threads/nsDOMWorkerThread.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -52,13 +52,15 @@
 #endif
 #include "nsAutoLock.h"
 #include "nsContentUtils.h"
 #include "nsJSUtils.h"
 #include "nsJSEnvironment.h"
+#include "nsThreadUtils.h"
 
 // DOMWorker includes
 #include "nsDOMWorkerPool.h"
+#include "nsDOMWorkerScriptLoader.h"
 #include "nsDOMThreadService.h"
 #include "nsDOMWorkerTimeout.h"
 
 #define LOG(_args) PR_LOG(gDOMThreadsLog, PR_LOG_DEBUG, _args)
 
@@ -92,17 +94,20 @@ public:
 
   // Used for both clearTimeout() and clearInterval().
   static JSBool KillTimeout(JSContext* aCx, JSObject* aObj, uintN aArgc,
                             jsval* aArgv, jsval* aRval);
 
+  static JSBool LoadScripts(JSContext* aCx, JSObject* aObj, uintN aArgc,
+                            jsval* aArgv, jsval* aRval);
+
 private:
   // Internal helper for SetTimeout and SetInterval.
   static JSBool MakeTimeout(JSContext* aCx, JSObject* aObj, uintN aArgc,
                             jsval* aArgv, jsval* aRval, PRBool aIsInterval);
 };
 
-JSBool JS_DLL_CALLBACK
+JSBool
 nsDOMWorkerFunctions::Dump(JSContext* aCx,
                            JSObject* /* aObj */,
                            uintN aArgc,
                            jsval* aArgv,
                            jsval* /* aRval */)
@@ -116,11 +121,11 @@ nsDOMWorkerFunctions::Dump(JSContext* aC
     fflush(stderr);
   }
   return JS_TRUE;
 }
 
-JSBool JS_DLL_CALLBACK
+JSBool
 nsDOMWorkerFunctions::DebugDump(JSContext* aCx,
                                 JSObject* aObj,
                                 uintN aArgc,
                                 jsval* aArgv,
                                 jsval* aRval)
@@ -130,11 +135,11 @@ nsDOMWorkerFunctions::DebugDump(JSContex
 #else
   return JS_TRUE;
 #endif
 }
 
-JSBool JS_DLL_CALLBACK
+JSBool
 nsDOMWorkerFunctions::PostMessage(JSContext* aCx,
                                   JSObject* /* aObj */,
                                   uintN aArgc,
                                   jsval* aArgv,
                                   jsval* /* aRval */)
@@ -157,16 +162,20 @@ nsDOMWorkerFunctions::PostMessage(JSCont
     rv = pool->PostMessageInternal(nsDependentJSString(str), worker);
   }
   else {
     rv = pool->PostMessageInternal(EmptyString(), worker);
   }
-  NS_ENSURE_SUCCESS(rv, JS_FALSE);
+
+  if (NS_FAILED(rv)) {
+    JS_ReportError(aCx, "Failed to post message!");
+    return JS_FALSE;
+  }
 
   return JS_TRUE;
 }
 
-JSBool JS_DLL_CALLBACK
+JSBool
 nsDOMWorkerFunctions::MakeTimeout(JSContext* aCx,
                                   JSObject* /* aObj */,
                                   uintN aArgc,
                                   jsval* aArgv,
                                   jsval* aRval,
@@ -182,22 +191,28 @@ nsDOMWorkerFunctions::MakeTimeout(JSCont
 
   PRUint32 id = ++worker->mNextTimeoutId;
 
   nsAutoPtr<nsDOMWorkerTimeout>
     timeout(new nsDOMWorkerTimeout(worker, id));
-  NS_ENSURE_TRUE(timeout, JS_FALSE);
+  if (!timeout) {
+    JS_ReportOutOfMemory(aCx);
+    return JS_FALSE;
+  }
 
   nsresult rv = timeout->Init(aCx, aArgc, aArgv, aIsInterval);
-  NS_ENSURE_SUCCESS(rv, JS_FALSE);
+  if (NS_FAILED(rv)) {
+    JS_ReportError(aCx, "Failed to initialize timeout!");
+    return JS_FALSE;
+  }
 
   timeout.forget();
 
   *aRval = INT_TO_JSVAL(id);
   return JS_TRUE;
 }
 
-JSBool JS_DLL_CALLBACK
+JSBool
 nsDOMWorkerFunctions::KillTimeout(JSContext* aCx,
                                   JSObject* /* aObj */,
                                   uintN aArgc,
                                   jsval* aArgv,
                                   jsval* /* aRval */)
@@ -224,18 +239,80 @@ nsDOMWorkerFunctions::KillTimeout(JSCont
 
   worker->CancelTimeout(PRUint32(id));
   return JS_TRUE;
 }
 
+JSBool JS_DLL_CALLBACK
+nsDOMWorkerFunctions::LoadScripts(JSContext* aCx,
+                                  JSObject* /* aObj */,
+                                  uintN aArgc,
+                                  jsval* aArgv,
+                                  jsval* /* aRval */)
+{
+  nsDOMWorkerThread* worker =
+    static_cast<nsDOMWorkerThread*>(JS_GetContextPrivate(aCx));
+  NS_ASSERTION(worker, "This should be set by the DOM thread service!");
+
+  if (worker->IsCanceled()) {
+    return JS_FALSE;
+  }
+
+  if (!aArgc) {
+    JS_ReportError(aCx, "Function must have at least one argument!");
+    return JS_FALSE;
+  }
+
+  nsAutoTArray<nsString, 5> urls;
+
+  if (!urls.SetCapacity((PRUint32)aArgc)) {
+    JS_ReportOutOfMemory(aCx);
+    return JS_FALSE;
+  }
+
+  for (uintN index = 0; index < aArgc; index++) {
+    jsval val = aArgv[index];
+
+    if (!JSVAL_IS_STRING(val)) {
+      JS_ReportError(aCx, "Argument %d must be a string", index);
+      return JS_FALSE;
+    }
+
+    JSString* str = JS_ValueToString(aCx, val);
+    if (!str) {
+      JS_ReportError(aCx, "Couldn't convert argument %d to a string", index);
+      return JS_FALSE;
+    }
+
+    nsString* newURL = urls.AppendElement();
+    NS_ASSERTION(newURL, "Shouldn't fail if SetCapacity succeeded above!");
+
+    newURL->Assign(nsDependentJSString(str));
+  }
+
+  nsRefPtr<nsDOMWorkerScriptLoader> loader = new nsDOMWorkerScriptLoader();
+  if (!loader) {
+    JS_ReportOutOfMemory(aCx);
+    return JS_FALSE;
+  }
+
+  nsresult rv = loader->LoadScripts(worker, aCx, urls);
+  if (NS_FAILED(rv)) {
+    return JS_FALSE;
+  }
+
+  return JS_TRUE;
+}
+
 JSFunctionSpec gDOMWorkerFunctions[] = {
   { "dump",                  nsDOMWorkerFunctions::Dump,              1, 0, 0 },
   { "debug",                 nsDOMWorkerFunctions::DebugDump,         1, 0, 0 },
   { "postMessageToPool",     nsDOMWorkerFunctions::PostMessage,       1, 0, 0 },
   { "setTimeout",            nsDOMWorkerFunctions::SetTimeout,        1, 0, 0 },
   { "clearTimeout",          nsDOMWorkerFunctions::KillTimeout,       1, 0, 0 },
   { "setInterval",           nsDOMWorkerFunctions::SetInterval,       1, 0, 0 },
   { "clearInterval",         nsDOMWorkerFunctions::KillTimeout,       1, 0, 0 },
+  { "loadScripts",           nsDOMWorkerFunctions::LoadScripts,       1, 0, 0 },
 #ifdef MOZ_SHARK
   { "startShark",            js_StartShark,                           0, 0, 0 },
   { "stopShark",             js_StopShark,                            0, 0, 0 },
   { "connectShark",          js_ConnectShark,                         0, 0, 0 },
   { "disconnectShark",       js_DisconnectShark,                      0, 0, 0 },
@@ -304,21 +381,28 @@ nsDOMWorkerThreadContext::GetThisThread(
   NS_ADDREF(*aThisThread = mWeakRef);
   return NS_OK;
 }
 
 nsDOMWorkerThread::nsDOMWorkerThread(nsDOMWorkerPool* aPool,
-                                     const nsAString& aSource)
+                                     const nsAString& aSource,
+                                     PRBool aSourceIsURL)
 : mPool(aPool),
-  mSource(aSource),
-  mGlobal(nsnull),
   mCompiled(PR_FALSE),
   mCallbackCount(0),
   mNextTimeoutId(0),
   mLock(nsnull)
 {
   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
-  NS_ASSERTION(!aSource.IsEmpty(), "Empty source string!");
+
+  if (aSourceIsURL) {
+    mSourceURL.Assign(aSource);
+    NS_ASSERTION(!mSourceURL.IsEmpty(), "Empty source url!");
+  }
+  else {
+    mSource.Assign(aSource);
+    NS_ASSERTION(!mSource.IsEmpty(), "Empty source string!");
+  }
 
   PR_INIT_CLIST(&mTimeouts);
 }
 
 nsDOMWorkerThread::~nsDOMWorkerThread()
@@ -329,21 +413,10 @@ nsDOMWorkerThread::~nsDOMWorkerThread()
     nsRefPtr<nsDOMWorkerPool> pool = Pool();
     pool->NoteDyingWorker(this);
   }
 
   ClearTimeouts();
-
-  // Only clean up if we created a global object
-  if (mGlobal) {
-    JSRuntime* rt;
-    if (NS_SUCCEEDED(nsDOMThreadService::JSRuntimeService()->GetRuntime(&rt))) {
-      JS_RemoveRootRT(rt, &mGlobal);
-    }
-    else {
-      NS_ERROR("This shouldn't fail!");
-    }
-  }
 
   if (mLock) {
     nsAutoLock::DestroyLock(mLock);
   }
 }
@@ -360,17 +433,24 @@ nsDOMWorkerThread::Init()
   mLock = nsAutoLock::NewLock("nsDOMWorkerThread::mLock");
   NS_ENSURE_TRUE(mLock, NS_ERROR_OUT_OF_MEMORY);
 
   NS_ASSERTION(!mGlobal, "Already got a global?!");
 
+  JSRuntime* rt;
+  nsresult rv = nsDOMThreadService::JSRuntimeService()->GetRuntime(&rt);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  PRBool success = mGlobal.Hold(rt);
+  NS_ENSURE_TRUE(success, NS_ERROR_FAILURE);
+
   // This is pretty cool - all we have to do to get our script executed is to
   // pass a no-op runnable to the thread service and it will make sure we have
   // a context and global object.
   nsCOMPtr<nsIRunnable> runnable(new nsRunnable());
   NS_ENSURE_TRUE(runnable, NS_ERROR_OUT_OF_MEMORY);
 
-  nsresult rv = nsDOMThreadService::get()->Dispatch(this, runnable);
+  rv = nsDOMThreadService::get()->Dispatch(this, runnable);
   NS_ENSURE_SUCCESS(rv, rv);
 
   return NS_OK;
 }
 
@@ -443,18 +523,14 @@ nsDOMWorkerThread::HandleMessage(const n
 
   // And call it.
   jsval rval;
   PRBool success = JS_CallFunctionValue(cx, mGlobal, OBJECT_TO_JSVAL(listener),
                                         2, argv, &rval);
-  if (!success) {
+  if (!success && JS_IsExceptionPending(cx)) {
     // Make sure any pending exceptions are converted to errors for the pool.
     JS_ReportPendingException(cx);
   }
-
-  // We shouldn't leave any pending exceptions - our error reporter should
-  // clear any exception it reports.
-  NS_ASSERTION(!JS_IsExceptionPending(cx), "Huh?!");
 
   return NS_OK;
 }
 
 // From nsDOMWorkerBase
@@ -469,10 +545,13 @@ nsDOMWorkerThread::DispatchMessage(nsIRu
 
 void
 nsDOMWorkerThread::Cancel()
 {
   nsDOMWorkerBase::Cancel();
+
+  // Do this before waiting on the thread service below!
+  CancelScriptLoaders();
 
   // If we're suspended there's a good chance that we're already paused waiting
   // on the pool's monitor. Waiting on the thread service's lock will deadlock.
   if (!IsSuspended()) {
     nsDOMThreadService::get()->WaitForCanceledWorker(this);
@@ -497,11 +576,13 @@ nsDOMWorkerThread::Resume()
 
 PRBool
 nsDOMWorkerThread::SetGlobalForContext(JSContext* aCx)
 {
   PRBool success = CompileGlobalObject(aCx);
-  NS_ENSURE_TRUE(success, PR_FALSE);
+  if (!success) {
+    return PR_FALSE;
+  }
 
   JS_SetGlobalObject(aCx, mGlobal);
   return PR_TRUE;
 }
 
@@ -561,36 +642,42 @@ nsDOMWorkerThread::CompileGlobalObject(J
   success = JS_DefineProperty(aCx, global, "threadContext",
                               OBJECT_TO_JSVAL(contextObj), nsnull, nsnull,
                               JSPROP_ENUMERATE);
   NS_ENSURE_TRUE(success, PR_FALSE);
 
-  JSScript* script = JS_CompileUCScript(aCx, global,
-                                        reinterpret_cast<const jschar*>
-                                            (mSource.BeginReading()),
-                                        mSource.Length(), nsnull, 1);
-  NS_ENSURE_TRUE(script, PR_FALSE);
+  jsval val;
 
-  JSRuntime* rt;
-  rv = nsDOMThreadService::JSRuntimeService()->GetRuntime(&rt);
-  NS_ENSURE_SUCCESS(rv, PR_FALSE);
+  // From here on out we have to remember to null mGlobal if something fails!
+  mGlobal = global;
 
-  mGlobal = global;
-  success = JS_AddNamedRootRT(rt, &mGlobal, "nsDOMWorkerThread Global Object");
-  if (!success) {
-    NS_WARNING("Failed to root global object for worker thread!");
-    mGlobal = nsnull;
-    return PR_FALSE;
+  if (mSource.IsEmpty()) {
+    NS_ASSERTION(!mSourceURL.IsEmpty(), "Must have a url here!");
+
+    nsRefPtr<nsDOMWorkerScriptLoader> loader = new nsDOMWorkerScriptLoader();
+    NS_ASSERTION(loader, "Out of memory!");
+    if (!loader) {
+      mGlobal = NULL;
+      return PR_FALSE;
+    }
+
+    rv = loader->LoadScript(this, aCx, mSourceURL);
+    JS_ReportPendingException(aCx);
+    if (NS_FAILED(rv)) {
+      mGlobal = NULL;
+      return PR_FALSE;
+    }
   }
+  else {
+    NS_ASSERTION(!mSource.IsEmpty(), "No source text!");
 
-  // Execute the script
-  jsval val;
-  success = JS_ExecuteScript(aCx, global, script, &val);
-  if (!success) {
-    NS_WARNING("Failed to evaluate script for worker thread!");
-    JS_RemoveRootRT(rt, &mGlobal);
-    mGlobal = nsnull;
-    return PR_FALSE;
+    // Evaluate and execute the script
+    success = JS_EvaluateUCScript(aCx, global, mSource.get(), mSource.Length(),
+                                  "DOMWorker inline script", 1, &val);
+    if (!success) {
+      mGlobal = NULL;
+      return PR_FALSE;
+    }
   }
 
   // See if the message listener function was defined.
   nsCOMPtr<nsIDOMWorkerMessageListener> listener;
   if (JS_LookupProperty(aCx, global, "messageListener", &val) &&
@@ -743,10 +830,30 @@ nsDOMWorkerThread::ResumeTimeouts()
   for (PRUint32 i = 0; i < count; i++) {
     timeouts[i]->Resume(now);
   }
 }
 
+void
+nsDOMWorkerThread::CancelScriptLoaders()
+{
+  nsAutoTArray<nsDOMWorkerScriptLoader*, 20> loaders;
+
+  // Must call cancel on the loaders outside the lock!
+  {
+    nsAutoLock lock(mLock);
+    loaders.AppendElements(mScriptLoaders);
+
+    // Don't clear mScriptLoaders, they'll remove themselves as they get
+    // destroyed.
+  }
+
+  PRUint32 loaderCount = loaders.Length();
+  for (PRUint32 index = 0; index < loaderCount; index++) {
+    loaders[index]->Cancel();
+  }
+}
+
 NS_IMETHODIMP
 nsDOMWorkerThread::PostMessage(const nsAString& aMessage)
 {
   nsresult rv = PostMessageInternal(aMessage);
   NS_ENSURE_SUCCESS(rv, rv);
diff -r 14ce7619e9c1 dom/src/threads/nsDOMWorkerThread.h
--- a/dom/src/threads/nsDOMWorkerThread.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/dom/src/threads/nsDOMWorkerThread.h	Mon Sep 08 10:35:45 2008 +0300
@@ -45,12 +45,14 @@
 #include "nsIClassInfo.h"
 #include "nsIDOMThreads.h"
 
 // Other includes
 #include "jsapi.h"
+#include "nsAutoJSObjectHolder.h"
 #include "nsCOMPtr.h"
 #include "nsStringGlue.h"
+#include "nsTArray.h"
 #include "nsThreadUtils.h"
 #include "prclist.h"
 #include "prlock.h"
 
 // DOMWorker includes
@@ -111,31 +113,34 @@ _class::GetClassIDNoAlloc(nsCID* _classI
 {                                                                             \
   return NS_ERROR_NOT_AVAILABLE;                                              \
 }
 
 class nsDOMWorkerPool;
+class nsDOMWorkerScriptLoader;
 class nsDOMWorkerTimeout;
 
 class nsDOMWorkerThread : public nsDOMWorkerBase,
                           public nsIDOMWorkerThread,
                           public nsIClassInfo
 {
   friend class nsDOMCreateJSContextRunnable;
   friend class nsDOMWorkerFunctions;
   friend class nsDOMWorkerPool;
   friend class nsDOMWorkerRunnable;
+  friend class nsDOMWorkerScriptLoader;
   friend class nsDOMWorkerTimeout;
 
   friend JSBool DOMWorkerOperationCallback(JSContext* aCx);
 
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSIDOMWORKERTHREAD
   NS_DECL_NSICLASSINFO
 
   nsDOMWorkerThread(nsDOMWorkerPool* aPool,
-                    const nsAString& aSource);
+                    const nsAString& aSource,
+                    PRBool aSourceIsURL);
 
   virtual nsDOMWorkerPool* Pool() {
     NS_ASSERTION(!IsCanceled(), "Don't touch Pool after we've been canceled!");
     return mPool;
   }
@@ -167,20 +172,29 @@ private:
   void ClearTimeouts();
   void CancelTimeout(PRUint32 aId);
   void SuspendTimeouts();
   void ResumeTimeouts();
 
+  void CancelScriptLoaders();
+
+  PRLock* Lock() {
+    return mLock;
+  }
+
   nsDOMWorkerPool* mPool;
   nsString mSource;
+  nsString mSourceURL;
 
-  JSObject* mGlobal;
+  nsAutoJSObjectHolder mGlobal;
   PRBool mCompiled;
 
   PRUint32 mCallbackCount;
 
   PRUint32 mNextTimeoutId;
 
   PRLock* mLock;
   PRCList mTimeouts;
+
+  nsTArray<nsDOMWorkerScriptLoader*> mScriptLoaders;
 };
 
 #endif /* __NSDOMWORKERTHREAD_H__ */
diff -r 14ce7619e9c1 dom/src/threads/test/Makefile.in
--- a/dom/src/threads/test/Makefile.in	Sat Sep 06 22:21:37 2008 +1200
+++ b/dom/src/threads/test/Makefile.in	Mon Sep 08 10:35:45 2008 +0300
@@ -45,10 +45,16 @@ relativesrcdir   = dom/src/threads/tests
 
 include $(DEPTH)/config/autoconf.mk
 include $(topsrcdir)/config/rules.mk
 
 _TEST_FILES = \
+  importScripts_worker.js \
+  importScripts_worker_imported1.js \
+  importScripts_worker_imported2.js \
+  importScripts_worker_imported3.js \
+  importScripts_worker_imported4.js \
+  test_importScripts.html \
   test_simpleThread.html \
   test_threadErrors.html \
   test_threadTimeouts.html \
   test_longThread.html \
   $(NULL)
diff -r 14ce7619e9c1 dom/src/threads/test/importScripts_worker.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/src/threads/test/importScripts_worker.js	Mon Sep 08 10:35:45 2008 +0300
@@ -0,0 +1,54 @@
+function messageListener(message, source) {
+  switch (message) {
+    case 'start':
+      loadScripts("importScripts_worker_imported2.js");
+      importedScriptFunction2();
+      tryBadScripts();
+      source.postMessage('started');
+      break;
+    case 'stop':
+      tryBadScripts();
+      postMessageToPool('stopped');
+      break;
+    default:
+      throw new Error("Bad message: " + message);
+      break;
+  }
+}
+
+// This caused security exceptions in the past, make sure it doesn't!
+var constructor = {}.constructor;
+
+loadScripts("importScripts_worker_imported1.js");
+
+// Try to call a function defined in the imported script.
+importedScriptFunction();
+
+function tryBadScripts() {
+  var badScripts = [
+    // Has a syntax error
+    "importScripts_worker_imported3.js",
+    // Throws an exception
+    "importScripts_worker_imported4.js",
+    // Shouldn't exist!
+    "http://flippety.com/floppety/foo.js",
+    // Not a valid url
+    "http://flippety::foo_js ftw"
+  ];
+
+  for (var i = 0; i < badScripts.length; i++) {
+    var caughtException = false;
+    var url = badScripts[i];
+    try {
+      loadScripts(url);
+    }
+    catch (e) {
+      caughtException = true;
+    }
+    if (!caughtException) {
+      throw "Bad script didn't throw exception: " + url;
+    }
+  }
+}
+
+tryBadScripts();
diff -r 14ce7619e9c1 dom/src/threads/test/importScripts_worker_imported1.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/src/threads/test/importScripts_worker_imported1.js	Mon Sep 08 10:35:45 2008 +0300
@@ -0,0 +1,7 @@
+// This caused security exceptions in the past, make sure it doesn't!
+var myConstructor = {}.constructor;
+
+// Try to call a function defined in the imported script.
+function importedScriptFunction() {
+  dump("running importedScriptFunction\n");
+}
diff -r 14ce7619e9c1 dom/src/threads/test/importScripts_worker_imported2.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/src/threads/test/importScripts_worker_imported2.js	Mon Sep 08 10:35:45 2008 +0300
@@ -0,0 +1,7 @@
+// This caused security exceptions in the past, make sure it doesn't!
+var myConstructor2 = {}.constructor;
+
+// Try to call a function defined in the imported script.
+function importedScriptFunction2() {
+  dump("running importedScriptFunction2\n");
+}
diff -r 14ce7619e9c1 dom/src/threads/test/importScripts_worker_imported3.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/src/threads/test/importScripts_worker_imported3.js	Mon Sep 08 10:35:45 2008 +0300
@@ -0,0 +1,2 @@
+// Deliberate syntax error, should generate a worker exception!
+for (var index = 0; index < 100) {}
diff -r 14ce7619e9c1 dom/src/threads/test/importScripts_worker_imported4.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/src/threads/test/importScripts_worker_imported4.js	Mon Sep 08 10:35:45 2008 +0300
@@ -0,0 +1,2 @@
+// Deliberate throw, should generate a worker exception!
+throw new Error("Bah!");
diff -r 14ce7619e9c1 dom/src/threads/test/test_importScripts.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/src/threads/test/test_importScripts.html	Mon Sep 08 10:35:45 2008 +0300
@@ -0,0 +1,49 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+Tests of DOM Worker Threads (Bug 437152)
+-->
+<head>
+  <title>Test for DOM Worker Threads (Bug 437152)</title>
+  <script type="text/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=437152">DOM Worker Threads Bug 437152</a>
+<p id="display"></p>
+<div id="content" style="display: none">
+  
+</div>
+<pre id="test">
+<script class="testbody" type="text/javascript">
+
+  var pool = navigator.newWorkerPool();
+  pool.messageListener = function(message, source) {
+    switch (message) {
+      case "started":
+        source.postMessage("stop");
+        break;
+      case "stopped":
+        SimpleTest.finish();
+        break;
+      default:
+        ok(false, "Unexpected message:" + message);
+        SimpleTest.finish();
+    }
+  };
+
+  pool.errorListener = function(error, source) {
+    ok(false, "Worker had an error:" + error);
+    SimpleTest.finish();
+  }
+
+  var worker = pool.createWorkerFromURL("importScripts_worker.js");
+  worker.postMessage("start");
+
+  SimpleTest.waitForExplicitFinish();
+</script>
+</pre>
+</body>
+</html>
+
diff -r 14ce7619e9c1 extensions/jssh/nsJSSh.cpp
--- a/extensions/jssh/nsJSSh.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/extensions/jssh/nsJSSh.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -109,11 +109,11 @@ PRBool GetJSShGlobal(JSContext *cx, JSOb
   NS_ASSERTION(jssh, "no jssh global");
   *shell = static_cast<nsJSSh*>((nsIJSSh*)(jssh.get()));
   return PR_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 my_ErrorReporter(JSContext *cx, const char *message, JSErrorReport *report)
 {
   // xxx getting the global obj from the cx. will that give us grief?
   JSObject* obj = JS_GetGlobalObject(cx);
   nsJSSh* shell;
@@ -130,11 +130,11 @@ my_ErrorReporter(JSContext *cx, const ch
     }
     shell->mOutput->Write(message, strlen(message), &bytesWritten);
   }
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 Print(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
   nsJSSh* shell;
   if (!GetJSShGlobal(cx, obj, &shell)) return JS_FALSE;
 
@@ -166,11 +166,11 @@ Print(JSContext *cx, JSObject *obj, uint
 #endif
    }
   return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 Quit(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
   nsJSSh* shell;
   if (!GetJSShGlobal(cx, obj, &shell)) return JS_FALSE;
 
@@ -181,11 +181,11 @@ Quit(JSContext *cx, JSObject *obj, uintN
   shell->mQuit = PR_TRUE;
   
   return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 Load(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
   nsJSSh* shell;
 
   JSAutoRequest ar(cx);
@@ -201,22 +201,22 @@ Load(JSContext *cx, JSObject *obj, uintN
       return JS_FALSE;
   }
   return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 FlushEventQueue(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
   nsJSSh* shell;
   if (!GetJSShGlobal(cx, obj, &shell)) return JS_FALSE;
 
   NS_ProcessPendingEvents(nsnull);
            
   return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 Suspend(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
   nsJSSh* shell;
   if (!GetJSShGlobal(cx, obj, &shell)) return JS_FALSE;
 
@@ -230,22 +230,22 @@ Suspend(JSContext *cx, JSObject *obj, ui
   }
            
   return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 Resume(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
   nsJSSh* shell;
   if (!GetJSShGlobal(cx, obj, &shell)) return JS_FALSE;
 
   PR_AtomicDecrement(&shell->mSuspendCount);
   
   return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 AddressOf(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
   if (argc!=1) return JS_FALSE;
 
   JSAutoRequest ar(cx);
@@ -264,11 +264,11 @@ AddressOf(JSContext *cx, JSObject *obj, 
   JSString *str = JS_NewStringCopyZ(cx, buf);
   *rval = STRING_TO_JSVAL(str);
   return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 SetProtocol(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
   if (argc!=1) return JS_FALSE;
   nsJSSh* shell;
   if (!GetJSShGlobal(cx, obj, &shell)) return JS_FALSE;
@@ -297,11 +297,11 @@ SetProtocol(JSContext *cx, JSObject *obj
   else return JS_FALSE;
   
   return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 GetProtocol(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
   nsJSSh* shell;
   if (!GetJSShGlobal(cx, obj, &shell)) return JS_FALSE;
 
@@ -310,11 +310,11 @@ GetProtocol(JSContext *cx, JSObject *obj
   JSString *str = JS_NewStringCopyZ(cx, shell->mProtocol.get());
   *rval = STRING_TO_JSVAL(str);
   return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 SetContextObj(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
   nsJSSh* shell;
   if (!GetJSShGlobal(cx, obj, &shell)) return JS_FALSE;
 
@@ -336,22 +336,22 @@ SetContextObj(JSContext *cx, JSObject *o
     JS_AddRoot(cx, &(shell->mContextObj));
   
   return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 DebugBreak(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
   nsJSSh* shell;
   if (!GetJSShGlobal(cx, obj, &shell)) return JS_FALSE;
 
   NS_BREAK();
   
   return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 GetInputStream(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
   nsJSSh* shell;
   if (!GetJSShGlobal(cx, obj, &shell)) return JS_FALSE;
 
@@ -379,11 +379,11 @@ GetInputStream(JSContext *cx, JSObject *
   *rval = OBJECT_TO_JSVAL(wrapper_jsobj);
   
   return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 GetOutputStream(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
   nsJSSh* shell;
   if (!GetJSShGlobal(cx, obj, &shell)) return JS_FALSE;
 
diff -r 14ce7619e9c1 extensions/pref/autoconfig/src/nsJSConfigTriggers.cpp
--- a/extensions/pref/autoconfig/src/nsJSConfigTriggers.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/extensions/pref/autoconfig/src/nsJSConfigTriggers.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -111,11 +111,11 @@ static JSClass global_class = {
     "autoconfig_global", 0,
     JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,
     JS_EnumerateStub, JS_ResolveStub,   JS_ConvertStub,   JS_FinalizeStub
 };
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 autoConfigErrorReporter(JSContext *cx, const char *message, 
                         JSErrorReport *report)
 {
     NS_ERROR(message);
     PR_LOG(MCD, PR_LOG_DEBUG, ("JS error in js from MCD server: %s\n", message));
diff -r 14ce7619e9c1 gfx/cairo/README
--- a/gfx/cairo/README	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/README	Mon Sep 08 10:35:45 2008 +0300
@@ -5,12 +5,12 @@ documentation and similar, please see th
 documentation and similar, please see the official tarballs at
 http://www.cairographics.org/.
 
 VERSIONS:
 
-  cairo (1.6.4-350-g1a9809b)
-  pixman (pixman-0.11.8-7-gdb3fb5e)
+  cairo (1.7.4-136-g5ea2555)
+  pixman (pixman-0.11.8-17-gf9d3f37)
 
 ***** NOTE FOR VISUAL C++ 6.0 *****
 
 VC6 is not supported.  Please upgrade to VC8.
 
diff -r 14ce7619e9c1 gfx/cairo/cairo-version-fixes.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/cairo/cairo-version-fixes.patch	Mon Sep 08 10:35:45 2008 +0300
@@ -0,0 +1,26 @@
+diff --git a/gfx/cairo/cairo/src/cairo-version.c b/gfx/cairo/cairo/src/cairo-version.c
+--- a/gfx/cairo/cairo/src/cairo-version.c
++++ b/gfx/cairo/cairo/src/cairo-version.c
+@@ -42,7 +42,7 @@
+ 
+ /* get the "real" version info instead of dummy cairo-version.h */
+ #undef CAIRO_VERSION_H
+-#include "../cairo-version.h"
++#include "cairo-features.h"
+ 
+ /**
+  * cairo_version:
+diff --git a/gfx/cairo/cairo/src/cairo-version.h b/gfx/cairo/cairo/src/cairo-version.h
+--- a/gfx/cairo/cairo/src/cairo-version.h
++++ b/gfx/cairo/cairo/src/cairo-version.h
+@@ -7,8 +7,10 @@
+ #ifndef CAIRO_VERSION_H
+ #define CAIRO_VERSION_H
+ 
++#if 0
+ #define CAIRO_VERSION_MAJOR USE_cairo_version_OR_cairo_version_string_INSTEAD
+ #define CAIRO_VERSION_MINOR USE_cairo_version_OR_cairo_version_string_INSTEAD
+ #define CAIRO_VERSION_MICRO USE_cairo_version_OR_cairo_version_string_INSTEAD
++#endif
+ 
+ #endif
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/Makefile.in
--- a/gfx/cairo/cairo/src/Makefile.in	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/Makefile.in	Mon Sep 08 10:35:45 2008 +0300
@@ -117,14 +117,15 @@ CSRCS   = \
         cairo-surface.c \
         cairo-surface-fallback.c \
         cairo-traps.c \
         cairo-unicode.c \
 	cairo-user-font.c \
+	cairo-version.c \
         cairo-wideint.c \
         $(NULL)
 
-EXPORTS = cairo.h cairo-features.h cairo-platform.h cairo-deprecated.h cairo-rename.h
+EXPORTS = cairo.h cairo-version.h cairo-features.h cairo-platform.h cairo-deprecated.h cairo-rename.h
 
 # cairo-type1-subset.c should be here, but it's only supported on freetype platforms
 
 PSPDF_BASE_CSRCS = \
 	cairo-base85-stream.c \
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-analysis-surface.c
--- a/gfx/cairo/cairo/src/cairo-analysis-surface.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-analysis-surface.c	Mon Sep 08 10:35:45 2008 +0300
@@ -619,11 +619,11 @@ static cairo_bool_t
 static cairo_bool_t
 _cairo_analysis_surface_has_show_text_glyphs (void *abstract_surface)
 {
     cairo_analysis_surface_t *surface = abstract_surface;
 
-    return _cairo_surface_has_show_text_glyphs (surface->target);
+    return cairo_surface_has_show_text_glyphs (surface->target);
 }
 
 static cairo_int_status_t
 _cairo_analysis_surface_show_text_glyphs (void			    *abstract_surface,
 					  cairo_operator_t	     op,
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-cache.c
--- a/gfx/cairo/cairo/src/cairo-cache.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-cache.c	Mon Sep 08 10:35:45 2008 +0300
@@ -237,26 +237,25 @@ _cairo_cache_lookup (cairo_cache_t	  *ca
  * _cairo_cache_remove_random:
  * @cache: a cache
  *
  * Remove a random entry from the cache.
  *
- * Return value: %CAIRO_STATUS_SUCCESS if an entry was successfully
- * removed. %CAIRO_INT_STATUS_CACHE_EMPTY if there are no entries that
- * can be removed.
+ * Return value: %TRUE if an entry was successfully removed.
+ * %FALSE if there are no entries that can be removed.
  **/
-static cairo_int_status_t
+static cairo_bool_t
 _cairo_cache_remove_random (cairo_cache_t *cache)
 {
     cairo_cache_entry_t *entry;
 
     entry = _cairo_hash_table_random_entry (cache->hash_table, NULL);
     if (entry == NULL)
-	return CAIRO_INT_STATUS_CACHE_EMPTY;
+	return FALSE;
 
     _cairo_cache_remove (cache, entry);
 
-    return CAIRO_STATUS_SUCCESS;
+    return TRUE;
 }
 
 /**
  * _cairo_cache_shrink_to_accommodate:
  * @cache: a cache
@@ -267,24 +266,18 @@ _cairo_cache_remove_random (cairo_cache_
  * cache->max_size. That is, make enough room to accommodate a new
  * entry of size @additional.
  **/
 static void
 _cairo_cache_shrink_to_accommodate (cairo_cache_t *cache,
-				   unsigned long  additional)
+				    unsigned long  additional)
 {
-    cairo_int_status_t status;
-
     if (cache->freeze_count)
 	return;
 
     while (cache->size + additional > cache->max_size) {
-	status = _cairo_cache_remove_random (cache);
-	if (status) {
-	    if (status == CAIRO_INT_STATUS_CACHE_EMPTY)
-		return;
-	    ASSERT_NOT_REACHED;
-	}
+	if (! _cairo_cache_remove_random (cache))
+	    return;
     }
 }
 
 /**
  * _cairo_cache_insert:
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-cff-subset.c
--- a/gfx/cairo/cairo/src/cairo-cff-subset.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-cff-subset.c	Mon Sep 08 10:35:45 2008 +0300
@@ -39,10 +39,13 @@
  * http://www.adobe.com/devnet/font/pdfs/5176.CFF.pdf
  */
 
 #define _BSD_SOURCE /* for snprintf(), strdup() */
 #include "cairoint.h"
+
+#if CAIRO_HAS_FONT_SUBSET
+
 #include "cairo-scaled-font-subsets-private.h"
 #include "cairo-truetype-subset-private.h"
 #include <string.h>
 
 /* CFF Dict Operators. If the high byte is 0 the command is encoded
@@ -2280,5 +2283,7 @@ _cairo_cff_fallback_fini (cairo_cff_subs
 {
     free (subset->base_font);
     free (subset->widths);
     free (subset->data);
 }
+
+#endif /* CAIRO_HAS_FONT_SUBSET */
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-clip-private.h
--- a/gfx/cairo/cairo/src/cairo-clip-private.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-clip-private.h	Mon Sep 08 10:35:45 2008 +0300
@@ -34,12 +34,15 @@
  */
 
 #ifndef CAIRO_CLIP_PRIVATE_H
 #define CAIRO_CLIP_PRIVATE_H
 
+#include "cairo-types-private.h"
 #include "cairo-compiler-private.h"
 #include "cairo-path-fixed-private.h"
+#include "cairo-reference-count-private.h"
+#include "cairo-region-private.h"
 
 extern const cairo_private cairo_rectangle_list_t _cairo_rectangles_nil;
 
 struct _cairo_clip_path {
     cairo_reference_count_t	 ref_count;
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-clip.c
--- a/gfx/cairo/cairo/src/cairo-clip.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-clip.c	Mon Sep 08 10:35:45 2008 +0300
@@ -57,11 +57,11 @@ _cairo_clip_init (cairo_clip_t *clip, ca
     clip->all_clipped = FALSE;
 
     clip->surface = NULL;
     clip->surface_rect.x = 0;
     clip->surface_rect.y = 0;
-    clip->surface_rect.width = 0;
+    clip->surface_rect.width  = 0;
     clip->surface_rect.height = 0;
 
     clip->serial = 0;
 
     _cairo_region_init (&clip->region);
@@ -84,10 +84,11 @@ _cairo_clip_init_copy (cairo_clip_t *cli
 
     _cairo_region_init (&clip->region);
 
     if (other->has_region) {
 	cairo_status_t status;
+
 	status = _cairo_region_copy (&clip->region, &other->region);
 	if (status) {
 	    _cairo_region_fini (&clip->region);
 	    cairo_surface_destroy (clip->surface);
 	    return status;
@@ -378,18 +379,17 @@ _cairo_clip_intersect_region (cairo_clip
     status = _cairo_traps_extract_region (traps, &region);
 
     if (status)
 	return status;
 
-    status = CAIRO_STATUS_SUCCESS;
-
     if (!clip->has_region) {
         status = _cairo_region_copy (&clip->region, &region);
 	if (status == CAIRO_STATUS_SUCCESS)
 	    clip->has_region = TRUE;
     } else {
 	cairo_region_t intersection;
+
         _cairo_region_init (&intersection);
 
 	status = _cairo_region_intersect (&intersection,
 		                         &clip->region,
 		                         &region);
@@ -725,11 +725,11 @@ _cairo_clip_int_rect_to_user (cairo_gsta
 
     _cairo_gstate_backend_to_user_rectangle (gstate, &x1, &y1, &x2, &y2, &is_tight);
 
     user_rect->x = x1;
     user_rect->y = y1;
-    user_rect->width = x2 - x1;
+    user_rect->width  = x2 - x1;
     user_rect->height = y2 - y1;
 
     return is_tight;
 }
 
@@ -762,13 +762,16 @@ _cairo_clip_copy_rectangle_list (cairo_c
 		_cairo_error_throw (CAIRO_STATUS_NO_MEMORY);
 		return (cairo_rectangle_list_t*) &_cairo_rectangles_nil;
 	    }
 
 	    for (i = 0; i < n_boxes; ++i) {
-		cairo_rectangle_int_t clip_rect = { boxes[i].p1.x, boxes[i].p1.y,
-						    boxes[i].p2.x - boxes[i].p1.x,
-						    boxes[i].p2.y - boxes[i].p1.y };
+               cairo_rectangle_int_t clip_rect;
+
+               clip_rect.x = boxes[i].p1.x;
+               clip_rect.y = boxes[i].p1.y;
+               clip_rect.width  = boxes[i].p2.x - boxes[i].p1.x;
+               clip_rect.height = boxes[i].p2.y - boxes[i].p1.y;
 
 		if (!_cairo_clip_int_rect_to_user(gstate, &clip_rect, &rectangles[i])) {
 		    _cairo_error_throw (CAIRO_STATUS_CLIP_NOT_REPRESENTABLE);
 		    _cairo_region_boxes_fini (&clip->region, boxes);
 		    free (rectangles);
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-compiler-private.h
--- a/gfx/cairo/cairo/src/cairo-compiler-private.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-compiler-private.h	Mon Sep 08 10:35:45 2008 +0300
@@ -36,11 +36,13 @@
  */
 
 #ifndef CAIRO_COMPILER_PRIVATE_H
 #define CAIRO_COMPILER_PRIVATE_H
 
-CAIRO_BEGIN_DECLS
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
 
 #if __GNUC__ >= 3 && defined(__ELF__) && !defined(__sun)
 # define slim_hidden_proto(name)		slim_hidden_proto1(name, slim_hidden_int_name(name)) cairo_private
 # define slim_hidden_proto_no_warn(name)	slim_hidden_proto1(name, slim_hidden_int_name(name)) cairo_private_no_warn
 # define slim_hidden_def(name)			slim_hidden_def1(name, slim_hidden_int_name(name))
@@ -106,10 +108,11 @@ CAIRO_BEGIN_DECLS
 #else
 # define CAIRO_FUNCTION_ALIAS(old, new)
 #endif
 
 #ifndef __GNUC__
+#undef __attribute__
 #define __attribute__(x)
 #endif
 
 #if (defined(__WIN32__) && !defined(__WINE__)) || defined(_MSC_VER)
 #define snprintf _snprintf
@@ -123,8 +126,6 @@ CAIRO_BEGIN_DECLS
 #ifdef __STRICT_ANSI__
 #undef inline
 #define inline __inline__
 #endif
 
-CAIRO_END_DECLS
-
 #endif
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-directfb-surface.c
--- a/gfx/cairo/cairo/src/cairo-directfb-surface.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-directfb-surface.c	Mon Sep 08 10:35:45 2008 +0300
@@ -61,19 +61,23 @@
 #define DFB_COMPOSITE 1 
 
 /*
  * CompositeTrapezoids works (without antialiasing).
  */
-#define DFB_COMPOSITE_TRAPEZOIDS 0
+#define DFB_COMPOSITE_TRAPEZOIDS 1
 
 /*
  * ShowGlyphs works fine.
  */
 #define DFB_SHOW_GLYPHS 1
 
 
-D_DEBUG_DOMAIN (Cairo_DirectFB, "Cairo/DirectFB", "Cairo DirectFB backend");
+D_DEBUG_DOMAIN( CairoDFB_Acquire, "CairoDFB/Acquire", "Cairo DirectFB Acquire" );
+D_DEBUG_DOMAIN( CairoDFB_Clip,    "CairoDFB/Clip",    "Cairo DirectFB Clipping" );
+D_DEBUG_DOMAIN( CairoDFB_Font,    "CairoDFB/Font",    "Cairo DirectFB Font Rendering" );
+D_DEBUG_DOMAIN( CairoDFB_Render,  "CairoDFB/Render",  "Cairo DirectFB Rendering" );
+D_DEBUG_DOMAIN( CairoDFB_Surface, "CairoDFB/Surface", "Cairo DirectFB Surface" );
 
 /*****************************************************************************/
 
 
 typedef struct _cairo_directfb_surface {
@@ -337,11 +341,11 @@ _directfb_acquire_surface (cairo_directf
     IDirectFBSurface *buffer = NULL;
     DFBRectangle source_rect;
     cairo_format_t cairo_format;
     void *data;
     int   pitch; 
-        
+
     if (surface->format == (cairo_format_t) -1) {
         DFBSurfaceCapabilities caps;
         
         if (intrest_rec) {
             source_rect.x = intrest_rec->x;
@@ -364,28 +368,28 @@ _directfb_acquire_surface (cairo_directf
             }
         }
         
         cairo_format = _cairo_format_from_content (surface->content);
         if (!surface->tmpsurface) {
-            D_DEBUG_AT (Cairo_DirectFB, "Allocating buffer for surface %p.\n", surface);
+            D_DEBUG_AT (CairoDFB_Acquire, "Allocating buffer for surface %p.\n", surface);
        
             surface->tmpsurface = 
                 _directfb_buffer_surface_create (surface->dfb, 
                                                  _cairo_to_directfb_format (cairo_format),
                                                  source_rect.w, source_rect.h);
             if (!surface->tmpsurface)
                 goto ERROR;
         }
         buffer = surface->tmpsurface;
         
-        surface->dfbsurface->GetCapabilities (surface->dfbsurface, &caps);
+/*        surface->dfbsurface->GetCapabilities (surface->dfbsurface, &caps);
         if (caps & DSCAPS_FLIPPING) {
             DFBRegion region = { .x1 = source_rect.x, .y1 = source_rect.y, 
                                  .x2 = source_rect.x + source_rect.w - 1,
                                  .y2 = source_rect.y + source_rect.h - 1 };
             surface->dfbsurface->Flip (surface->dfbsurface, &region, DSFLIP_BLIT);
-        } 
+        } */
         buffer->Blit (buffer, surface->dfbsurface, &source_rect, 0, 0);
     }
     else {
         /*might be a subsurface get the offset*/
         surface->dfbsurface->GetVisibleRectangle (surface->dfbsurface, &source_rect);
@@ -394,11 +398,11 @@ _directfb_acquire_surface (cairo_directf
     }
     
     *image_extra = buffer;
     
     if (buffer->Lock (buffer, lock_flags, &data, &pitch)) {
-        D_DEBUG_AT (Cairo_DirectFB, "Couldn't lock surface!\n");
+        D_DEBUG_AT (CairoDFB_Acquire, "Couldn't lock surface!\n");
         goto ERROR;
     }
             
     *image_out = (cairo_image_surface_t *)
                     cairo_image_surface_create_for_data (data, cairo_format,
@@ -441,11 +445,11 @@ _cairo_directfb_surface_create_similar (
 {
     cairo_directfb_surface_t *source  = abstract_src;
     cairo_directfb_surface_t *surface;
     cairo_format_t            format;
     
-    D_DEBUG_AT (Cairo_DirectFB, 
+    D_DEBUG_AT (CairoDFB_Surface, 
                 "%s( src=%p, content=0x%x, width=%d, height=%d).\n",
                 __FUNCTION__, source, content, width, height);
     
     width = (width <= 0) ? 1 : width;
     height = (height<= 0) ? 1 : height;
@@ -495,12 +499,11 @@ static cairo_status_t
 static cairo_status_t
 _cairo_directfb_surface_finish (void *data)
 {
     cairo_directfb_surface_t *surface = (cairo_directfb_surface_t *)data;
     
-    D_DEBUG_AT (Cairo_DirectFB, 
-                "%s( surface=%p ).\n", __FUNCTION__, surface);
+    D_DEBUG_AT (CairoDFB_Surface, "%s( surface=%p ).\n", __FUNCTION__, surface);
         
     if (surface->clips) {
         free (surface->clips);
         surface->clips   = NULL;
         surface->n_clips = 0;
@@ -532,11 +535,11 @@ _cairo_directfb_surface_acquire_source_i
                                               cairo_image_surface_t **image_out,
                                               void                  **image_extra)
 {
     cairo_directfb_surface_t *surface = abstract_surface;
     
-    D_DEBUG_AT (Cairo_DirectFB, 
+    D_DEBUG_AT (CairoDFB_Acquire, 
                 "%s( surface=%p ).\n", __FUNCTION__, surface);
     
     return _directfb_acquire_surface (surface, NULL, image_out, 
                                       NULL, image_extra, DSLF_READ);
 }
@@ -547,11 +550,11 @@ _cairo_directfb_surface_release_source_i
                                               void                  *image_extra)
 {
     cairo_directfb_surface_t *surface = abstract_surface;
     IDirectFBSurface *buffer = image_extra;
     
-    D_DEBUG_AT (Cairo_DirectFB, 
+    D_DEBUG_AT (CairoDFB_Acquire, 
                 "%s( surface=%p ).\n", __FUNCTION__, surface);
     
     buffer->Unlock (buffer);
     
     cairo_surface_destroy (&image->base);
@@ -564,17 +567,17 @@ _cairo_directfb_surface_acquire_dest_ima
                                             cairo_rectangle_int_t    *image_rect_out,
                                             void                    **image_extra)
 {
     cairo_directfb_surface_t *surface = abstract_surface;
     
-    D_DEBUG_AT (Cairo_DirectFB, 
-                "%s( surface=%p, interest_rect={ %d %d %d %d } ).\n", 
-                __FUNCTION__, surface, 
+    D_DEBUG_AT (CairoDFB_Acquire, 
+                "%s( surface=%p (%dx%d), interest_rect={ %u %u %u %u } ).\n", 
+                __FUNCTION__, surface, surface->width, surface->height,
                 interest_rect ? interest_rect->x : 0,
                 interest_rect ? interest_rect->y : 0,
-                interest_rect ? interest_rect->width : surface->width,
-                interest_rect ? interest_rect->height : surface->height);
+                interest_rect ? interest_rect->width  : (unsigned) surface->width,
+                interest_rect ? interest_rect->height : (unsigned) surface->height);
     
     return _directfb_acquire_surface (surface, interest_rect, image_out, 
                                       image_rect_out, image_extra, DSLF_READ | DSLF_WRITE);
 }
 
@@ -586,11 +589,11 @@ _cairo_directfb_surface_release_dest_ima
                                             void                  *image_extra)
 {
     cairo_directfb_surface_t *surface = abstract_surface;
     IDirectFBSurface *buffer = image_extra; 
     
-    D_DEBUG_AT (Cairo_DirectFB, 
+    D_DEBUG_AT (CairoDFB_Acquire, 
                 "%s( surface=%p ).\n", __FUNCTION__, surface);
     
     buffer->Unlock (buffer);
 
     if (surface->dfbsurface != buffer) {
@@ -616,11 +619,11 @@ _cairo_directfb_surface_clone_similar (v
                                        cairo_surface_t **clone_out)
 {
     cairo_directfb_surface_t *surface = abstract_surface;
     cairo_directfb_surface_t *clone;
     
-    D_DEBUG_AT (Cairo_DirectFB, 
+    D_DEBUG_AT (CairoDFB_Surface, 
                 "%s( surface=%p, src=%p ).\n", __FUNCTION__, surface, src);
 
     if (src->backend == surface->base.backend) {
         cairo_surface_reference (src);
         *clone_out = src;
@@ -724,11 +727,11 @@ _directfb_prepare_composite (cairo_direc
             
             if (src_pattern->type != CAIRO_PATTERN_TYPE_SOLID ||
                 sblend == DSBF_INVDESTALPHA) /* Doesn't work correctly */
                 return CAIRO_INT_STATUS_UNSUPPORTED;
                 
-            D_DEBUG_AT (Cairo_DirectFB, "Replacing src pattern by mask pattern.\n");
+            D_DEBUG_AT (CairoDFB_Render, "Replacing src pattern by mask pattern.\n");
                 
             tmp = src_pattern;
             tmp_x = *src_x; tmp_y = *src_y;
             
             src_pattern = mask_pattern;
@@ -881,11 +884,11 @@ _cairo_directfb_surface_composite (cairo
     cairo_directfb_surface_t   *src;
     cairo_surface_attributes_t  src_attr;
     DFBAccelerationMask         accel, mask;
     cairo_int_status_t          ret;
     
-    D_DEBUG_AT (Cairo_DirectFB,
+    D_DEBUG_AT (CairoDFB_Render,
                 "%s( op=%d, src_pattern=%p, mask_pattern=%p, dst=%p,"
                    " src_x=%d, src_y=%d, mask_x=%d, mask_y=%d, dst_x=%d,"
                    " dst_y=%d, width=%u, height=%u ).\n",
                 __FUNCTION__, op, src_pattern, mask_pattern, dst, 
                 src_x, src_y, mask_x, mask_y, dst_x, dst_y, width, height);
@@ -898,11 +901,11 @@ _cairo_directfb_surface_composite (cairo
         
     accel = _directfb_categorize_operation (&src_attr);
     
     dst->dfbsurface->GetAccelerationMask (dst->dfbsurface, src->dfbsurface, &mask);
     if (!(mask & accel)) {
-        D_DEBUG_AT (Cairo_DirectFB, "No acceleration (%08x)!\n", accel);
+        D_DEBUG_AT (CairoDFB_Render, "No acceleration (%08x)!\n", accel);
         if (accel != DFXL_BLIT) {
             _directfb_finish_composite (dst, src_pattern, &src->base, &src_attr);
             return CAIRO_INT_STATUS_UNSUPPORTED;
         }
     }
@@ -918,11 +921,11 @@ _cairo_directfb_surface_composite (cairo
             sr.y = src_y + _cairo_lround (src_attr.matrix.y0);
             sr.w = width;
             sr.h = height;
         
             if (src_attr.extend == CAIRO_EXTEND_NONE) {
-                D_DEBUG_AT (Cairo_DirectFB, "Running Blit().\n");
+                D_DEBUG_AT (CairoDFB_Render, "Running Blit().\n");
         
                 RUN_CLIPPED( dst, NULL,
                              dst->dfbsurface->Blit (dst->dfbsurface,
                                             src->dfbsurface, &sr, dst_x, dst_y));
             }
@@ -932,11 +935,11 @@ _cairo_directfb_surface_composite (cairo
                 clip.x1 = dst_x;
                 clip.y1 = dst_y;
                 clip.x2 = dst_x + width  - 1;
                 clip.y2 = dst_y + height - 1;
             
-                D_DEBUG_AT (Cairo_DirectFB, "Running TileBlit().\n");
+                D_DEBUG_AT (CairoDFB_Render, "Running TileBlit().\n");
             
                 RUN_CLIPPED( dst, &clip,
                              dst->dfbsurface->TileBlit (dst->dfbsurface, 
                                             src->dfbsurface, &sr, dst_x, dst_y));
             }
@@ -959,11 +962,11 @@ _cairo_directfb_surface_composite (cairo
             dr.x = dst_x;
             dr.y = dst_y;
             dr.w = width;
             dr.h = height;
             
-            D_DEBUG_AT (Cairo_DirectFB, "Running StretchBlit().\n");
+            D_DEBUG_AT (CairoDFB_Render, "Running StretchBlit().\n");
 
             RUN_CLIPPED (dst, NULL,
                          dst->dfbsurface->StretchBlit (dst->dfbsurface, 
                                                        src->dfbsurface, &sr, &dr));
         }   break;
@@ -1017,11 +1020,11 @@ _cairo_directfb_surface_composite (cairo
             clip.x1 = dst_x;
             clip.y1 = dst_y;
             clip.x2 = dst_x + width  - 1;
             clip.y2 = dst_y + height - 1;
         
-            D_DEBUG_AT (Cairo_DirectFB, "Running TextureTriangles().\n");
+            D_DEBUG_AT (CairoDFB_Render, "Running TextureTriangles().\n");
             
             RUN_CLIPPED (dst, &clip,
                          dst->dfbsurface->TextureTriangles (dst->dfbsurface, 
                                             src->dfbsurface, v, NULL, 4, DTTF_FAN));
         }   break;
@@ -1050,11 +1053,11 @@ _cairo_directfb_surface_fill_rectangles 
     DFBSurfaceBlendFunction   sblend;
     DFBSurfaceBlendFunction   dblend;
     DFBRectangle              r[n_rects];
     int                       i;
     
-    D_DEBUG_AT (Cairo_DirectFB, 
+    D_DEBUG_AT (CairoDFB_Render, 
                 "%s( dst=%p, op=%d, color=%p, rects=%p, n_rects=%d ).\n",
                 __FUNCTION__, dst, op, color, rects, n_rects);
 
     if (_directfb_get_operator (op, &sblend, &dblend))
         return CAIRO_INT_STATUS_UNSUPPORTED;
@@ -1126,11 +1129,11 @@ _cairo_directfb_surface_composite_trapez
     cairo_directfb_surface_t   *src;
     cairo_surface_attributes_t  src_attr;
     cairo_status_t              ret;
     DFBAccelerationMask         accel;
     
-    D_DEBUG_AT (Cairo_DirectFB,
+    D_DEBUG_AT (CairoDFB_Render,
                 "%s( op=%d, pattern=%p, dst=%p, antialias=%d,"
                    " src_x=%d, src_y=%d, dst_x=%d, dst_y=%d,"
                    " width=%u, height=%u, traps=%p, num_traps=%d ).\n",
                 __FUNCTION__, op, pattern, dst, antialias,
                 src_x, src_y, dst_x, dst_y, width, height, traps, num_traps);
@@ -1233,11 +1236,11 @@ _cairo_directfb_surface_composite_trapez
             traps++;
         }
         
 #undef ADD_TRI
               
-        D_DEBUG_AT (Cairo_DirectFB, "Running TextureTriangles().\n");
+        D_DEBUG_AT (CairoDFB_Render, "Running TextureTriangles().\n");
             
         RUN_CLIPPED (dst, NULL,
                      dst->dfbsurface->TextureTriangles (dst->dfbsurface, src->dfbsurface, 
                                                     vertex, NULL, n, DTTF_LIST));
                                             
@@ -1254,21 +1257,23 @@ _cairo_directfb_surface_set_clip_region 
 _cairo_directfb_surface_set_clip_region (void           *abstract_surface,
                                          cairo_region_t *region)
 {
     cairo_directfb_surface_t *surface = abstract_surface;
     
-    D_DEBUG_AT (Cairo_DirectFB, 
+    D_DEBUG_AT (CairoDFB_Clip, 
                 "%s( surface=%p, region=%p ).\n",
                 __FUNCTION__, surface, region);
     
     if (region) {
         cairo_box_int_t *boxes;
         int              n_boxes;
         cairo_status_t   status;
         int              i;
 
         status = _cairo_region_get_boxes (region, &n_boxes, &boxes);
+        if (n_boxes == 0)
+            return CAIRO_STATUS_SUCCESS;
         if (status)
             return status;
         
         if (surface->n_clips != n_boxes) {
             if (surface->clips)
@@ -1308,11 +1313,11 @@ _cairo_directfb_abstract_surface_get_ext
 _cairo_directfb_abstract_surface_get_extents (void                  *abstract_surface,
                                               cairo_rectangle_int_t *rectangle)
 {
     cairo_directfb_surface_t *surface = abstract_surface;
     
-    D_DEBUG_AT (Cairo_DirectFB,
+    D_DEBUG_AT (CairoDFB_Surface,
                 "%s( surface=%p, rectangle=%p ).\n",
                 __FUNCTION__, surface, rectangle);
     
     if (rectangle) {
         if (!surface->local) {
@@ -1377,46 +1382,61 @@ _directfb_acquire_font_cache (cairo_dire
     int                          y         = 0;
     int                          w         = 8;
     int                          h         = 8;
     int                          i;
     
+    D_DEBUG_AT (CairoDFB_Font, "%s( %p [%d] )\n", __FUNCTION__, glyphs, num_glyphs );
+
     if (scaled_font->surface_private) {
         cache = scaled_font->surface_private;
         x = cache->x;
         y = cache->y;
     }
-    
+
+    _cairo_cache_freeze( scaled_font->glyphs );
+
     for (i = 0; i < num_glyphs; i++) {
         cairo_scaled_glyph_t  *scaled_glyph;
         cairo_image_surface_t *img;
         
+        D_DEBUG_AT (CairoDFB_Font, "  -> [%2d] = %4lu\n", i, glyphs[i].index );
+
         ret = _cairo_scaled_glyph_lookup (scaled_font, glyphs[i].index,
                                           CAIRO_SCALED_GLYPH_INFO_SURFACE,
                                           &scaled_glyph);
-        if (ret)
+        if (ret) {
+            _cairo_cache_thaw( scaled_font->glyphs );
             return ret;
+        }
         
         img = scaled_glyph->surface;
         switch (img->format) {
             case CAIRO_FORMAT_A1:
             case CAIRO_FORMAT_A8:
             case CAIRO_FORMAT_ARGB32:
                 break;
             default:
-                D_DEBUG_AT (Cairo_DirectFB,
-                            "Unsupported font format %d!\n", img->format);
+                D_DEBUG_AT (CairoDFB_Font,
+                            "  -> Unsupported font format %d!\n", img->format);
+                _cairo_cache_thaw( scaled_font->glyphs );
                 return CAIRO_INT_STATUS_UNSUPPORTED;
         }
         
         points[n].x = _cairo_lround (glyphs[i].x - img->base.device_transform.x0);
         points[n].y = _cairo_lround (glyphs[i].y - img->base.device_transform.y0);
         
+//        D_DEBUG_AT (CairoDFB_Font, "            (%4d,%4d) [%2d]\n", points[n].x, points[n].y, n );
+
         if (points[n].x >= surface->width  ||
             points[n].y >= surface->height ||
             points[n].x+img->width  <= 0   ||
             points[n].y+img->height <= 0)
-            continue;
+        {
+             D_DEBUG_AT (CairoDFB_Font,
+                         "  -> Unsupported font format %d!\n", img->format);
+             continue;
+        }
         
         if (!scaled_glyph->surface_private) {
             DFBRectangle *rect;
             
             if (x+img->width > 2048) {
@@ -1434,34 +1454,35 @@ _directfb_acquire_font_cache (cairo_dire
             h  = MAX (h, img->height);
             w  = MAX (w, x);
             
             /* Remember glyph location */ 
             rect = malloc (sizeof(DFBRectangle));
-            if (!rect)
+            if (!rect) {
+                _cairo_cache_thaw( scaled_font->glyphs );
                 return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+            }
             *rect = rects[n];
             
             scaled_glyph->surface_private = rect;
             chars[num_chars++] = scaled_glyph;
             
-            /*D_DEBUG_AT (Cairo_DirectFB, 
-                        "Glyph %lu will be loaded at (%d,%d).\n",
-                        glyphs[i].index, rects[n].x, rects[n].y);*/
+            D_DEBUG_AT (CairoDFB_Font, "  -> loading at %4d,%2d <- rect %p, img %p, entry %p\n",
+                        rects[n].x, rects[n].y, rect, scaled_glyph->surface, scaled_glyph);
         }
         else {
             rects[n] = *((DFBRectangle *)scaled_glyph->surface_private);
             
-            /*D_DEBUG_AT (Cairo_DirectFB, 
-                        "Glyph %lu already loaded at (%d,%d).\n",
-                        glyphs[i].index, rects[n].x, rects[n].y);*/
+            D_DEBUG_AT (CairoDFB_Font, "  -> exists at  %4d,%2d\n", rects[n].x, rects[n].y);
         }
             
         n++;
     }
     
-    if (!n)
+    if (!n) {
+        _cairo_cache_thaw( scaled_font->glyphs );
         return CAIRO_INT_STATUS_NOTHING_TO_DO;
+    }
     
     h += y;
     w = MAX (w, 8);
     h = MAX (h, 8);
      
@@ -1470,31 +1491,33 @@ _directfb_acquire_font_cache (cairo_dire
             cairo_directfb_font_cache_t *new_cache;
             
             w = MAX (w, cache->width);
             h = MAX (h, cache->height);
             
-            D_DEBUG_AT (Cairo_DirectFB,
-                        "Reallocating font cache (%dx%d).\n", w, h);
+            D_DEBUG_AT (CairoDFB_Font, "  -> Reallocating font cache (%dx%d).\n", w, h);
             
             new_cache = _directfb_allocate_font_cache (surface->dfb, w, h);
-            if (!new_cache)
+            if (!new_cache) {
+                _cairo_cache_thaw( scaled_font->glyphs );
                 return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+            }
             
             new_cache->dfbsurface->Blit (new_cache->dfbsurface,
                                          cache->dfbsurface, NULL, 0, 0);
             
             _directfb_destroy_font_cache (cache);
             scaled_font->surface_private = cache = new_cache;
         }
     }
     else {
-        D_DEBUG_AT (Cairo_DirectFB,
-                    "Allocating font cache (%dx%d).\n", w, h);
+        D_DEBUG_AT (CairoDFB_Font, "  -> Allocating font cache (%dx%d).\n", w, h);
         
         cache = _directfb_allocate_font_cache (surface->dfb, w, h);
-        if (!cache)
+        if (!cache) {
+            _cairo_cache_thaw( scaled_font->glyphs );
             return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+        }
             
         scaled_font->surface_backend = &cairo_directfb_surface_backend;
         scaled_font->surface_private = cache;
     }
     
@@ -1502,21 +1525,34 @@ _directfb_acquire_font_cache (cairo_dire
         unsigned char *data;
         int            pitch;
     
         if (cache->dfbsurface->Lock (cache->dfbsurface, 
                                      DSLF_WRITE, (void *)&data, &pitch))
+        {
+            _cairo_cache_thaw( scaled_font->glyphs );
             return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+        }
             
+        D_DEBUG_AT (CairoDFB_Font, "  => %d chars to load, cache %dx%d\n", num_chars, cache->width, cache->height);
+
         for (i = 0; i < num_chars; i++) {
             cairo_image_surface_t *img  = chars[i]->surface;
             DFBRectangle          *rect = chars[i]->surface_private;
             unsigned char         *dst  = data;
-            unsigned char         *src  = img->data;
+            unsigned char         *src;
             int                    j;
             
+            D_DEBUG_AT (CairoDFB_Font, "  -> loading [%2d] <- rect %p, img %p, entry %p\n", i, rect, img, chars[i]);
+
+            src = img->data;
+
+            D_DEBUG_AT (CairoDFB_Font, "     from %p\n", src);
+
             dst += rect->y * pitch + (_directfb_argb_font ? (rect->x<<2) : rect->x);
                         
+            D_DEBUG_AT (CairoDFB_Font, "     to %4d,%2d (%p)\n", rect->x, rect->y, dst);
+
             if (img->format == CAIRO_FORMAT_A1) {
                 for (h = rect->h; h; h--) {
                     if (_directfb_argb_font) {
                         for (j = 0; j < rect->w; j++)
                             ((uint32_t *)dst)[j] = (src[j>>3] & (1 << (j&7))) ? 0xffffffff : 0;
@@ -1561,13 +1597,17 @@ _directfb_acquire_font_cache (cairo_dire
         }
         
         cache->dfbsurface->Unlock (cache->dfbsurface);
     }
 
+    _cairo_cache_thaw( scaled_font->glyphs );
+
     cache->x = x;
     cache->y = y;
     
+    D_DEBUG_AT (CairoDFB_Font, "  => cache %d,%d, %p [%d]\n", x, y, cache, n);
+
     *ret_cache = cache;
     *ret_num   = n;
 
     return CAIRO_STATUS_SUCCESS;
 }
@@ -1575,11 +1615,11 @@ static void
 static void
 _cairo_directfb_surface_scaled_font_fini (cairo_scaled_font_t *scaled_font)
 {
     cairo_directfb_font_cache_t *cache = scaled_font->surface_private;
     
-    D_DEBUG_AT (Cairo_DirectFB,
+    D_DEBUG_AT (CairoDFB_Font,
                 "%s( scaled_font=%p ).\n", __FUNCTION__, scaled_font);
     
     if (cache) {
         _directfb_destroy_font_cache (cache);
         scaled_font->surface_private = NULL;
@@ -1588,11 +1628,11 @@ _cairo_directfb_surface_scaled_font_fini
 
 static void
 _cairo_directfb_surface_scaled_glyph_fini (cairo_scaled_glyph_t *scaled_glyph,
                                            cairo_scaled_font_t  *scaled_font)
 {
-     D_DEBUG_AT (Cairo_DirectFB,
+     D_DEBUG_AT (CairoDFB_Font,
                  "%s( scaled_glyph=%p, scaled_font=%p ).\n",
                  __FUNCTION__, scaled_glyph, scaled_font);
 
      if (scaled_glyph->surface_private) {
           free (scaled_glyph->surface_private);
@@ -1618,11 +1658,11 @@ _cairo_directfb_surface_show_glyphs (voi
     DFBColor                     color;
     DFBRectangle                 rects[num_glyphs];
     DFBPoint                     points[num_glyphs];
     int                          num;
     
-    D_DEBUG_AT (Cairo_DirectFB,
+    D_DEBUG_AT (CairoDFB_Font,
                 "%s( dst=%p, op=%d, pattern=%p, glyphs=%p, num_glyphs=%d, scaled_font=%p ).\n",
                 __FUNCTION__, dst, op, pattern, glyphs, num_glyphs, scaled_font);
                             
     if (pattern->type != CAIRO_PATTERN_TYPE_SOLID)
         return CAIRO_INT_STATUS_UNSUPPORTED;
@@ -1659,11 +1699,11 @@ _cairo_directfb_surface_show_glyphs (voi
     dst->dfbsurface->SetBlittingFlags (dst->dfbsurface, flags);
     dst->dfbsurface->SetSrcBlendFunction (dst->dfbsurface, sblend);
     dst->dfbsurface->SetDstBlendFunction (dst->dfbsurface, dblend);
     dst->dfbsurface->SetColor (dst->dfbsurface, color.r, color.g, color.b, color.a);
     
-    D_DEBUG_AT (Cairo_DirectFB, "Running BatchBlit().\n");
+    D_DEBUG_AT (CairoDFB_Font, "Running BatchBlit().\n");
         
     RUN_CLIPPED (dst, NULL,
                  dst->dfbsurface->BatchBlit (dst->dfbsurface,
                                          cache->dfbsurface, rects, points, num));
         
@@ -1757,31 +1797,31 @@ cairo_directfb_surface_backend_init (IDi
 #if DFB_SHOW_GLYPHS
         cairo_directfb_surface_backend.scaled_font_fini = NULL;
         cairo_directfb_surface_backend.scaled_glyph_fini = NULL;
         cairo_directfb_surface_backend.show_glyphs = NULL;
 #endif
-        D_DEBUG_AT (Cairo_DirectFB, "Acceleration disabled.\n");
+        D_DEBUG_AT (CairoDFB_Surface, "Acceleration disabled.\n");
     }
     else {
         DFBGraphicsDeviceDescription dsc;
         
         dfb->GetDeviceDescription (dfb, &dsc);
     
 #if DFB_COMPOSITE
-        if (!(dsc.acceleration_mask & DFXL_BLIT))
-            cairo_directfb_surface_backend.composite = NULL;
+//        if (!(dsc.acceleration_mask & DFXL_BLIT))
+//            cairo_directfb_surface_backend.composite = NULL;
 #endif
 
 #if DFB_COMPOSITE_TRAPEZOIDS
-        if (!(dsc.acceleration_mask & DFXL_TEXTRIANGLES))
-            cairo_directfb_surface_backend.composite_trapezoids = NULL;
+//        if (!(dsc.acceleration_mask & DFXL_TEXTRIANGLES))
+//            cairo_directfb_surface_backend.composite_trapezoids = NULL;
 #endif
     }
     
     if (getenv ("CAIRO_DIRECTFB_ARGB_FONT")) {
         _directfb_argb_font = 1;
-        D_DEBUG_AT (Cairo_DirectFB, "Using ARGB fonts.\n");
+        D_DEBUG_AT (CairoDFB_Surface, "Using ARGB fonts.\n");
     }
 
     done = 1;
 }   
 
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-features-win32.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/cairo/cairo/src/cairo-features-win32.h	Mon Sep 08 10:35:45 2008 +0300
@@ -0,0 +1,14 @@
+#ifndef CAIRO_FEATURES_H
+#define CAIRO_FEATURES_H
+
+#define HAVE_WINDOWS_H 1
+
+#define CAIRO_HAS_SVG_SURFACE 1
+#define CAIRO_HAS_PDF_SURFACE 1
+#define CAIRO_HAS_PS_SURFACE 1
+#define CAIRO_HAS_WIN32_SURFACE 1
+#define CAIRO_HAS_WIN32_FONT 1
+#define CAIRO_HAS_PNG_FUNCTIONS 1
+
+#endif
+
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-features.h.in
--- a/gfx/cairo/cairo/src/cairo-features.h.in	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-features.h.in	Mon Sep 08 10:35:45 2008 +0300
@@ -50,14 +50,12 @@
 #ifndef cairo_public
 # define cairo_public
 #endif
 
 #define CAIRO_VERSION_MAJOR 1
-#define CAIRO_VERSION_MINOR 6
+#define CAIRO_VERSION_MINOR 7
 #define CAIRO_VERSION_MICRO 4
-
-#define CAIRO_VERSION_STRING "1.6.4"
 
 @PS_SURFACE_FEATURE@
 
 @PDF_SURFACE_FEATURE@
 
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-font-face.c
--- a/gfx/cairo/cairo/src/cairo-font-face.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-font-face.c	Mon Sep 08 10:35:45 2008 +0300
@@ -39,23 +39,82 @@
  */
 
 #define _BSD_SOURCE /* for strdup() */
 #include "cairoint.h"
 
-/* Forward declare so we can use it as an arbitrary backend for
- * _cairo_font_face_nil.
- */
 static const cairo_font_face_backend_t _cairo_toy_font_face_backend;
 
 /* #cairo_font_face_t */
 
-const cairo_font_face_t _cairo_font_face_nil = {
-    { 0 },			/* hash_entry */
-    CAIRO_STATUS_NO_MEMORY,	/* status */
+const cairo_toy_font_face_t _cairo_font_face_nil = {
+    {
+    { 0 },				/* hash_entry */
+    CAIRO_STATUS_NO_MEMORY,		/* status */
     CAIRO_REFERENCE_COUNT_INVALID,	/* ref_count */
-    { 0, 0, 0, NULL },		/* user_data */
+    { 0, 0, 0, NULL },			/* user_data */
     &_cairo_toy_font_face_backend
+    },
+    CAIRO_FONT_FAMILY_DEFAULT,		/* family */
+    TRUE,				/* owns_family */
+    CAIRO_FONT_SLANT_DEFAULT,		/* slant */
+    CAIRO_FONT_WEIGHT_DEFAULT		/* weight */
+};
+
+static const cairo_toy_font_face_t _cairo_font_face_null_pointer = {
+    {
+    { 0 },				/* hash_entry */
+    CAIRO_STATUS_NULL_POINTER,		/* status */
+    CAIRO_REFERENCE_COUNT_INVALID,	/* ref_count */
+    { 0, 0, 0, NULL },			/* user_data */
+    &_cairo_toy_font_face_backend
+    },
+    CAIRO_FONT_FAMILY_DEFAULT,		/* family */
+    TRUE,				/* owns_family */
+    CAIRO_FONT_SLANT_DEFAULT,		/* slant */
+    CAIRO_FONT_WEIGHT_DEFAULT		/* weight */
+};
+
+static const cairo_toy_font_face_t _cairo_font_face_invalid_string = {
+    {
+    { 0 },				/* hash_entry */
+    CAIRO_STATUS_INVALID_STRING,	/* status */
+    CAIRO_REFERENCE_COUNT_INVALID,	/* ref_count */
+    { 0, 0, 0, NULL },			/* user_data */
+    &_cairo_toy_font_face_backend
+    },
+    CAIRO_FONT_FAMILY_DEFAULT,		/* family */
+    TRUE,				/* owns_family */
+    CAIRO_FONT_SLANT_DEFAULT,		/* slant */
+    CAIRO_FONT_WEIGHT_DEFAULT		/* weight */
+};
+
+static const cairo_toy_font_face_t _cairo_font_face_invalid_slant = {
+    {
+    { 0 },				/* hash_entry */
+    CAIRO_STATUS_INVALID_SLANT,		/* status */
+    CAIRO_REFERENCE_COUNT_INVALID,	/* ref_count */
+    { 0, 0, 0, NULL },			/* user_data */
+    &_cairo_toy_font_face_backend
+    },
+    CAIRO_FONT_FAMILY_DEFAULT,		/* family */
+    TRUE,				/* owns_family */
+    CAIRO_FONT_SLANT_DEFAULT,		/* slant */
+    CAIRO_FONT_WEIGHT_DEFAULT		/* weight */
+};
+
+static const cairo_toy_font_face_t _cairo_font_face_invalid_weight = {
+    {
+    { 0 },				/* hash_entry */
+    CAIRO_STATUS_INVALID_WEIGHT,	/* status */
+    CAIRO_REFERENCE_COUNT_INVALID,	/* ref_count */
+    { 0, 0, 0, NULL },			/* user_data */
+    &_cairo_toy_font_face_backend
+    },
+    CAIRO_FONT_FAMILY_DEFAULT,		/* family */
+    TRUE,				/* owns_family */
+    CAIRO_FONT_SLANT_DEFAULT,		/* slant */
+    CAIRO_FONT_WEIGHT_DEFAULT		/* weight */
 };
 
 cairo_status_t
 _cairo_font_face_set_error (cairo_font_face_t *font_face,
 	                    cairo_status_t     status)
@@ -369,30 +428,69 @@ _cairo_toy_font_face_keys_equal (const v
 	    face_a->slant == face_b->slant &&
 	    face_a->weight == face_b->weight);
 }
 
 /**
- * _cairo_toy_font_face_create:
+ * cairo_toy_font_face_create:
  * @family: a font family name, encoded in UTF-8
  * @slant: the slant for the font
  * @weight: the weight for the font
  *
  * Creates a font face from a triplet of family, slant, and weight.
  * These font faces are used in implementation of the the #cairo_t "toy"
  * font API.
  *
- * Return value: a newly created #cairo_font_face_t, destroy with
- *  cairo_font_face_destroy()
+ * If @family is the zero-length string "", the platform-specific default
+ * family is assumed.  The default family then can be queried using
+ * cairo_toy_font_face_get_family().
+ *
+ * The cairo_select_font_face() function uses this to create font faces.
+ * See that function for limitations of toy font faces.
+ *
+ * Return value: a newly created #cairo_font_face_t. Free with
+ *  cairo_font_face_destroy() when you are done using it.
+ *
+ * Since: 1.8
  **/
 cairo_font_face_t *
-_cairo_toy_font_face_create (const char          *family,
-			     cairo_font_slant_t   slant,
-			     cairo_font_weight_t  weight)
+cairo_toy_font_face_create (const char          *family,
+			    cairo_font_slant_t   slant,
+			    cairo_font_weight_t  weight)
 {
     cairo_status_t status;
     cairo_toy_font_face_t key, *font_face;
     cairo_hash_table_t *hash_table;
+
+    if (family == NULL)
+	return (cairo_font_face_t*) &_cairo_font_face_null_pointer;
+
+    /* Make sure we've got valid UTF-8 for the family */
+    status = _cairo_utf8_to_ucs4 (family, -1, NULL, NULL);
+    if (status == CAIRO_STATUS_INVALID_STRING)
+	return (cairo_font_face_t*) &_cairo_font_face_invalid_string;
+    else if (status)
+	return (cairo_font_face_t*) &_cairo_font_face_nil;
+
+    switch (slant) {
+	case CAIRO_FONT_SLANT_NORMAL:
+	case CAIRO_FONT_SLANT_ITALIC:
+	case CAIRO_FONT_SLANT_OBLIQUE:
+	    break;
+	default:
+	    return (cairo_font_face_t*) &_cairo_font_face_invalid_slant;
+    }
+
+    switch (weight) {
+	case CAIRO_FONT_WEIGHT_NORMAL:
+	case CAIRO_FONT_WEIGHT_BOLD:
+	    break;
+	default:
+	    return (cairo_font_face_t*) &_cairo_font_face_invalid_weight;
+    }
+
+    if (*family == '\0')
+	family = CAIRO_FONT_FAMILY_DEFAULT;
 
     hash_table = _cairo_toy_font_face_hash_table_lock ();
     if (hash_table == NULL)
 	goto UNWIND;
 
@@ -442,10 +540,11 @@ _cairo_toy_font_face_create (const char 
  UNWIND_HASH_TABLE_LOCK:
     _cairo_toy_font_face_hash_table_unlock ();
  UNWIND:
     return (cairo_font_face_t*) &_cairo_font_face_nil;
 }
+slim_hidden_def (cairo_toy_font_face_create);
 
 static void
 _cairo_toy_font_face_destroy (void *abstract_face)
 {
     cairo_toy_font_face_t *font_face = abstract_face;
@@ -489,10 +588,81 @@ _cairo_toy_font_face_scaled_font_create 
 	                               backend->create_toy (font_face,
 				                            font_matrix,
 							    ctm,
 							    options,
 							    scaled_font));
+}
+
+static cairo_bool_t
+_cairo_font_face_is_toy (cairo_font_face_t *font_face)
+{
+    return font_face->backend == &_cairo_toy_font_face_backend;
+}
+
+/**
+ * cairo_toy_font_face_get_family:
+ * @font_face: A toy font face
+ *
+ * Gets the familly name of a toy font.
+ *
+ * Return value: The family name.  This string is owned by the font face
+ * and remains valid as long as the font face is alive (referenced).
+ *
+ * Since: 1.8
+ **/
+const char *
+cairo_toy_font_face_get_family (cairo_font_face_t *font_face)
+{
+    cairo_toy_font_face_t *toy_font_face = (cairo_toy_font_face_t *) font_face;
+    if (! _cairo_font_face_is_toy (font_face)) {
+	if (_cairo_font_face_set_error (font_face, CAIRO_STATUS_FONT_TYPE_MISMATCH))
+	    return CAIRO_FONT_FAMILY_DEFAULT;
+    }
+    assert (toy_font_face->owns_family);
+    return toy_font_face->family;
+}
+
+/**
+ * cairo_toy_font_face_get_slant:
+ * @font_face: A toy font face
+ *
+ * Gets the slant a toy font.
+ *
+ * Return value: The slant value
+ *
+ * Since: 1.8
+ **/
+cairo_font_slant_t
+cairo_toy_font_face_get_slant (cairo_font_face_t *font_face)
+{
+    cairo_toy_font_face_t *toy_font_face = (cairo_toy_font_face_t *) font_face;
+    if (! _cairo_font_face_is_toy (font_face)) {
+	if (_cairo_font_face_set_error (font_face, CAIRO_STATUS_FONT_TYPE_MISMATCH))
+	    return CAIRO_FONT_SLANT_DEFAULT;
+    }
+    return toy_font_face->slant;
+}
+
+/**
+ * cairo_toy_font_face_get_weight:
+ * @font_face: A toy font face
+ *
+ * Gets the weight a toy font.
+ *
+ * Return value: The weight value
+ *
+ * Since: 1.8
+ **/
+cairo_font_weight_t
+cairo_toy_font_face_get_weight (cairo_font_face_t *font_face)
+{
+    cairo_toy_font_face_t *toy_font_face = (cairo_toy_font_face_t *) font_face;
+    if (! _cairo_font_face_is_toy (font_face)) {
+	if (_cairo_font_face_set_error (font_face, CAIRO_STATUS_FONT_TYPE_MISMATCH))
+	    return CAIRO_FONT_WEIGHT_DEFAULT;
+    }
+    return toy_font_face->weight;
 }
 
 static const cairo_font_face_backend_t _cairo_toy_font_face_backend = {
     CAIRO_FONT_TYPE_TOY,
     _cairo_toy_font_face_destroy,
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-font-options.c
--- a/gfx/cairo/cairo/src/cairo-font-options.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-font-options.c	Mon Sep 08 10:35:45 2008 +0300
@@ -37,10 +37,11 @@
 #include "cairoint.h"
 
 static const cairo_font_options_t _cairo_font_options_nil = {
     CAIRO_ANTIALIAS_DEFAULT,
     CAIRO_SUBPIXEL_ORDER_DEFAULT,
+    CAIRO_LCD_FILTER_DEFAULT,
     CAIRO_HINT_STYLE_DEFAULT,
     CAIRO_HINT_METRICS_DEFAULT
 };
 
 /**
@@ -52,20 +53,22 @@ void
 void
 _cairo_font_options_init_default (cairo_font_options_t *options)
 {
     options->antialias = CAIRO_ANTIALIAS_DEFAULT;
     options->subpixel_order = CAIRO_SUBPIXEL_ORDER_DEFAULT;
+    options->lcd_filter = CAIRO_LCD_FILTER_DEFAULT;
     options->hint_style = CAIRO_HINT_STYLE_DEFAULT;
     options->hint_metrics = CAIRO_HINT_METRICS_DEFAULT;
 }
 
 void
 _cairo_font_options_init_copy (cairo_font_options_t		*options,
 			       const cairo_font_options_t	*other)
 {
     options->antialias = other->antialias;
     options->subpixel_order = other->subpixel_order;
+    options->lcd_filter = other->lcd_filter;
     options->hint_style = other->hint_style;
     options->hint_metrics = other->hint_metrics;
 }
 
 /**
@@ -187,10 +190,12 @@ cairo_font_options_merge (cairo_font_opt
 
     if (other->antialias != CAIRO_ANTIALIAS_DEFAULT)
 	options->antialias = other->antialias;
     if (other->subpixel_order != CAIRO_SUBPIXEL_ORDER_DEFAULT)
 	options->subpixel_order = other->subpixel_order;
+    if (other->lcd_filter != CAIRO_LCD_FILTER_DEFAULT)
+	options->lcd_filter = other->lcd_filter;
     if (other->hint_style != CAIRO_HINT_STYLE_DEFAULT)
 	options->hint_style = other->hint_style;
     if (other->hint_metrics != CAIRO_HINT_METRICS_DEFAULT)
 	options->hint_metrics = other->hint_metrics;
 }
@@ -219,10 +224,11 @@ cairo_font_options_equal (const cairo_fo
     if (options == other)
 	return TRUE;
 
     return (options->antialias == other->antialias &&
 	    options->subpixel_order == other->subpixel_order &&
+	    options->lcd_filter == other->lcd_filter &&
 	    options->hint_style == other->hint_style &&
 	    options->hint_metrics == other->hint_metrics);
 }
 slim_hidden_def (cairo_font_options_equal);
 
@@ -244,11 +250,12 @@ cairo_font_options_hash (const cairo_fon
     if (cairo_font_options_status ((cairo_font_options_t *) options))
 	options = &_cairo_font_options_nil; /* force default values */
 
     return ((options->antialias) |
 	    (options->subpixel_order << 4) |
-	    (options->hint_style << 8) |
+	    (options->lcd_filter << 8) |
+	    (options->hint_style << 12) |
 	    (options->hint_metrics << 16));
 }
 slim_hidden_def (cairo_font_options_hash);
 
 /**
@@ -326,10 +333,53 @@ cairo_font_options_get_subpixel_order (c
 
     return options->subpixel_order;
 }
 
 /**
+ * cairo_font_options_set_lcd_filter:
+ * @options: a #cairo_font_options_t
+ * @lcd_filter: the new LCD filter
+ *
+ * Sets the LCD filter for the font options object. The LCD filter
+ * specifies how pixels are filtered when rendered with an antialiasing
+ * mode of %CAIRO_ANTIALIAS_SUBPIXEL. See the documentation for
+ * #cairo_lcd_filter_t for full details.
+ *
+ * Since: 1.8
+ **/
+void
+cairo_font_options_set_lcd_filter (cairo_font_options_t *options,
+				   cairo_lcd_filter_t    lcd_filter)
+{
+    if (cairo_font_options_status (options))
+	return;
+
+    options->lcd_filter = lcd_filter;
+}
+slim_hidden_def (cairo_font_options_set_lcd_filter);
+
+/**
+ * cairo_font_options_get_lcd_filter:
+ * @options: a #cairo_font_options_t
+ *
+ * Gets the LCD filter for the font options object.
+ * See the documentation for #cairo_lcd_filter_t for full details.
+ *
+ * Return value: the LCD filter for the font options object
+ *
+ * Since: 1.8
+ **/
+cairo_lcd_filter_t
+cairo_font_options_get_lcd_filter (const cairo_font_options_t *options)
+{
+    if (cairo_font_options_status ((cairo_font_options_t *) options))
+	return CAIRO_LCD_FILTER_DEFAULT;
+
+    return options->lcd_filter;
+}
+
+/**
  * cairo_font_options_set_hint_style:
  * @options: a #cairo_font_options_t
  * @hint_style: the new hint style
  *
  * Sets the hint style for font outlines for the font options object.
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-freelist-private.h
--- a/gfx/cairo/cairo/src/cairo-freelist-private.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-freelist-private.h	Mon Sep 08 10:35:45 2008 +0300
@@ -21,10 +21,11 @@
  */
 #ifndef CAIRO_FREELIST_H
 #define CAIRO_FREELIST_H
 
 #include "cairo-types-private.h"
+#include "cairo-compiler-private.h"
 
 /* Opaque implementation types. */
 typedef struct _cairo_freelist cairo_freelist_t;
 typedef struct _cairo_freelist_node cairo_freelist_node_t;
 
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-ft-font.c
--- a/gfx/cairo/cairo/src/cairo-ft-font.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-ft-font.c	Mon Sep 08 10:35:45 2008 +0300
@@ -53,10 +53,34 @@
 #include FT_OUTLINE_H
 #include FT_IMAGE_H
 #include FT_TRUETYPE_TABLES_H
 #if HAVE_FT_GLYPHSLOT_EMBOLDEN
 #include FT_SYNTHESIS_H
+#endif
+
+#if HAVE_FT_LIBRARY_SETLCDFILTER
+#include FT_LCD_FILTER_H
+#endif
+
+/* Fontconfig version older than 2.6 didn't have these options */
+#ifndef FC_LCD_FILTER
+#define FC_LCD_FILTER	"lcdfilter"
+#endif
+/* Some Ubuntu versions defined FC_LCD_FILTER without defining the following */
+#ifndef FC_LCD_NONE
+#define FC_LCD_NONE	0
+#define FC_LCD_DEFAULT	1
+#define FC_LCD_LIGHT	2
+#define FC_LCD_LEGACY	3
+#endif
+
+/* FreeType version older than 2.3.5(?) didn't have these options */
+#ifndef FT_LCD_FILTER_NONE
+#define FT_LCD_FILTER_NONE	0
+#define FT_LCD_FILTER_DEFAULT	1
+#define FT_LCD_FILTER_LIGHT	2
+#define FT_LCD_FILTER_LEGACY	16
 #endif
 
 #define DOUBLE_TO_26_6(d) ((FT_F26Dot6)((d) * 64.0))
 #define DOUBLE_FROM_26_6(t) ((double)(t) / 64.0)
 #define DOUBLE_TO_16_16(d) ((FT_Fixed)((d) * 65536.0))
@@ -539,11 +563,11 @@ _has_unlocked_face (void *entry)
  * MAX_OPEN_FACES, try to close some.
  *
  * This differs from _cairo_ft_scaled_font_lock_face in that it doesn't
  * set the scale on the face, but just returns it at the last scale.
  */
-FT_Face
+cairo_warn FT_Face
 _cairo_ft_unscaled_font_lock_face (cairo_ft_unscaled_font_t *unscaled)
 {
     cairo_ft_unscaled_font_map_t *font_map;
     FT_Face face = NULL;
 
@@ -620,11 +644,11 @@ _compute_transform (cairo_ft_font_transf
      * chooses hints, as well as selecting different bitmaps in
      * hand-rendered fonts. We also copy the normalized matrix to
      * freetype's transformation.
      */
 
-    status = _cairo_matrix_compute_scale_factors (scale,
+    status = _cairo_matrix_compute_basis_scale_factors (scale,
 						  &x_scale, &y_scale,
 						  1);
     if (status)
 	return status;
 
@@ -741,27 +765,290 @@ _cairo_ft_unscaled_font_set_scale (cairo
     }
 
     return CAIRO_STATUS_SUCCESS;
 }
 
-/* Empirically-derived subpixel filtering values thanks to Keith
- * Packard and libXft. */
-static const int    filters[3][3] = {
-    /* red */
-#if 0
-    {    65538*4/7,65538*2/7,65538*1/7 },
-    /* green */
-    {    65536*1/4, 65536*2/4, 65537*1/4 },
-    /* blue */
-    {    65538*1/7,65538*2/7,65538*4/7 },
+/* we sometimes need to convert the glyph bitmap in a FT_GlyphSlot
+ * into a different format. For example, we want to convert a
+ * FT_PIXEL_MODE_LCD or FT_PIXEL_MODE_LCD_V bitmap into a 32-bit
+ * ARGB or ABGR bitmap.
+ *
+ * this function prepares a target descriptor for this operation.
+ *
+ * input :: target bitmap descriptor. The function will set its
+ *          'width', 'rows' and 'pitch' fields, and only these
+ *
+ * slot  :: the glyph slot containing the source bitmap. this
+ *          function assumes that slot->format == FT_GLYPH_FORMAT_BITMAP
+ *
+ * mode  :: the requested final rendering mode. supported values are
+ *          MONO, NORMAL (i.e. gray), LCD and LCD_V
+ *
+ * the function returns the size in bytes of the corresponding buffer,
+ * it's up to the caller to allocate the corresponding memory block
+ * before calling _fill_xrender_bitmap
+ *
+ * it also returns -1 in case of error (e.g. incompatible arguments,
+ * like trying to convert a gray bitmap into a monochrome one)
+ */
+static int
+_compute_xrender_bitmap_size(FT_Bitmap      *target,
+			     FT_GlyphSlot    slot,
+			     FT_Render_Mode  mode)
+{
+    FT_Bitmap *ftbit;
+    int width, height, pitch;
+
+    if (slot->format != FT_GLYPH_FORMAT_BITMAP)
+	return -1;
+
+    /* compute the size of the final bitmap */
+    ftbit = &slot->bitmap;
+
+    width = ftbit->width;
+    height = ftbit->rows;
+    pitch = (width + 3) & ~3;
+
+    switch (ftbit->pixel_mode) {
+    case FT_PIXEL_MODE_MONO:
+	if (mode == FT_RENDER_MODE_MONO) {
+	    pitch = (((width + 31) & ~31) >> 3);
+	    break;
+	}
+	/* fall-through */
+
+    case FT_PIXEL_MODE_GRAY:
+	if (mode == FT_RENDER_MODE_LCD ||
+	    mode == FT_RENDER_MODE_LCD_V)
+	{
+	    /* each pixel is replicated into a 32-bit ARGB value */
+	    pitch = width * 4;
+	}
+	break;
+
+    case FT_PIXEL_MODE_LCD:
+	if (mode != FT_RENDER_MODE_LCD)
+	    return -1;
+
+	/* horz pixel triplets are packed into 32-bit ARGB values */
+	width /= 3;
+	pitch = width * 4;
+	break;
+
+    case FT_PIXEL_MODE_LCD_V:
+	if (mode != FT_RENDER_MODE_LCD_V)
+	    return -1;
+
+	/* vert pixel triplets are packed into 32-bit ARGB values */
+	height /= 3;
+	pitch = width * 4;
+	break;
+
+    default:  /* unsupported source format */
+	return -1;
+    }
+
+    target->width = width;
+    target->rows = height;
+    target->pitch = pitch;
+    target->buffer = NULL;
+
+    return pitch * height;
+}
+
+/* this functions converts the glyph bitmap found in a FT_GlyphSlot
+ * into a different format (see _compute_xrender_bitmap_size)
+ *
+ * you should call this function after _compute_xrender_bitmap_size
+ *
+ * target :: target bitmap descriptor. Note that its 'buffer' pointer
+ *           must point to memory allocated by the caller
+ *
+ * slot   :: the glyph slot containing the source bitmap
+ *
+ * mode   :: the requested final rendering mode
+ *
+ * bgr    :: boolean, set if BGR or VBGR pixel ordering is needed
+ */
+static void
+_fill_xrender_bitmap(FT_Bitmap      *target,
+		     FT_GlyphSlot    slot,
+		     FT_Render_Mode  mode,
+		     int             bgr)
+{
+    FT_Bitmap *ftbit = &slot->bitmap;
+    unsigned char *srcLine = ftbit->buffer;
+    unsigned char *dstLine = target->buffer;
+    int src_pitch = ftbit->pitch;
+    int width = target->width;
+    int height = target->rows;
+    int pitch = target->pitch;
+    int subpixel;
+    int h;
+
+    subpixel = (mode == FT_RENDER_MODE_LCD ||
+		mode == FT_RENDER_MODE_LCD_V);
+
+    if (src_pitch < 0)
+	srcLine -= src_pitch * (ftbit->rows - 1);
+
+    target->pixel_mode = ftbit->pixel_mode;
+
+    switch (ftbit->pixel_mode) {
+    case FT_PIXEL_MODE_MONO:
+	if (subpixel) {
+	    /* convert mono to ARGB32 values */
+
+	    for (h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch) {
+		int x;
+
+		for (x = 0; x < width; x++) {
+		    if (srcLine[(x >> 3)] & (0x80 >> (x & 7)))
+			((unsigned int *) dstLine)[x] = 0xffffffffU;
+		}
+	    }
+	    target->pixel_mode = FT_PIXEL_MODE_LCD;
+
+	} else if (mode == FT_RENDER_MODE_NORMAL) {
+	    /* convert mono to 8-bit gray */
+
+	    for (h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch) {
+		int x;
+
+		for (x = 0; x < width; x++) {
+		    if (srcLine[(x >> 3)] & (0x80 >> (x & 7)))
+			dstLine[x] = 0xff;
+		}
+	    }
+	    target->pixel_mode = FT_PIXEL_MODE_GRAY;
+
+	} else {
+	    /* copy mono to mono */
+
+	    int  bytes = (width + 7) >> 3;
+
+	    for (h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch)
+		memcpy (dstLine, srcLine, bytes);
+	}
+	break;
+
+    case FT_PIXEL_MODE_GRAY:
+	if (subpixel) {
+	    /* convert gray to ARGB32 values */
+
+	    for (h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch) {
+		int x;
+		unsigned int *dst = (unsigned int *) dstLine;
+
+		for (x = 0; x < width; x++) {
+		    unsigned int pix = srcLine[x];
+
+		    pix |= (pix << 8);
+		    pix |= (pix << 16);
+
+		    dst[x] = pix;
+		}
+	    }
+	    target->pixel_mode = FT_PIXEL_MODE_LCD;
+        } else {
+            /* copy gray into gray */
+
+            for (h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch)
+                memcpy (dstLine, srcLine, width);
+        }
+        break;
+
+    case FT_PIXEL_MODE_LCD:
+	if (!bgr) {
+	    /* convert horizontal RGB into ARGB32 */
+
+	    for (h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch) {
+		int x;
+		unsigned char *src = srcLine;
+		unsigned int *dst = (unsigned int *) dstLine;
+
+		for (x = 0; x < width; x++, src += 3) {
+		    unsigned int  pix;
+
+		    pix = ((unsigned int)src[0] << 16) |
+			  ((unsigned int)src[1] <<  8) |
+			  ((unsigned int)src[2]      ) |
+			  ((unsigned int)src[1] << 24) ;
+
+		    dst[x] = pix;
+		}
+	    }
+	} else {
+	    /* convert horizontal BGR into ARGB32 */
+
+	    for (h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch) {
+
+		int x;
+		unsigned char *src = srcLine;
+		unsigned int *dst = (unsigned int *) dstLine;
+
+		for (x = 0; x < width; x++, src += 3) {
+		    unsigned int  pix;
+
+		    pix = ((unsigned int)src[2] << 16) |
+			  ((unsigned int)src[1] <<  8) |
+			  ((unsigned int)src[0]      ) |
+			  ((unsigned int)src[1] << 24) ;
+
+		    dst[x] = pix;
+		}
+	    }
+	}
+	break;
+
+    default:  /* FT_PIXEL_MODE_LCD_V */
+	/* convert vertical RGB into ARGB32 */
+	if (!bgr) {
+
+	    for (h = height; h > 0; h--, srcLine += 3 * src_pitch, dstLine += pitch) {
+		int x;
+		unsigned char* src = srcLine;
+		unsigned int*  dst = (unsigned int *) dstLine;
+
+		for (x = 0; x < width; x++, src += 1) {
+		    unsigned int pix;
+#if 1
+		    pix = ((unsigned int)src[0]           << 16) |
+			  ((unsigned int)src[src_pitch]   <<  8) |
+			  ((unsigned int)src[src_pitch*2]      ) |
+			  0xFF000000 ;
+#else
+		    pix = ((unsigned int)src[0]           << 16) |
+			  ((unsigned int)src[src_pitch]   <<  8) |
+			  ((unsigned int)src[src_pitch*2]      ) |
+			  ((unsigned int)src[src_pitch]   << 24) ;
 #endif
-    {    65538*9/13,65538*3/13,65538*1/13 },
-    /* green */
-    {    65538*1/6, 65538*4/6, 65538*1/6 },
-    /* blue */
-    {    65538*1/13,65538*3/13,65538*9/13 },
-};
+		    dst[x] = pix;
+		}
+	    }
+	} else {
+
+	    for (h = height; h > 0; h--, srcLine += 3*src_pitch, dstLine += pitch) {
+		int x;
+		unsigned char *src = srcLine;
+		unsigned int *dst = (unsigned int *) dstLine;
+
+		for (x = 0; x < width; x++, src += 1) {
+		    unsigned int  pix;
+
+		    pix = ((unsigned int)src[src_pitch * 2] << 16) |
+			  ((unsigned int)src[src_pitch]     <<  8) |
+			  ((unsigned int)src[0]                  ) |
+			  ((unsigned int)src[src_pitch]     << 24) ;
+
+		    dst[x] = pix;
+		}
+	    }
+	}
+    }
+}
+
 
 /* Fills in val->image with an image surface created from @bitmap
  */
 static cairo_status_t
 _get_bitmap_surface (FT_Bitmap		     *bitmap,
@@ -770,11 +1057,11 @@ _get_bitmap_surface (FT_Bitmap		     *bi
 		     cairo_image_surface_t  **surface)
 {
     int width, height, stride;
     unsigned char *data;
     int format = CAIRO_FORMAT_A8;
-    cairo_bool_t subpixel = FALSE;
+    cairo_image_surface_t *image;
 
     width = bitmap->width;
     height = bitmap->rows;
 
     if (width == 0 || height == 0) {
@@ -812,11 +1099,11 @@ _get_bitmap_surface (FT_Bitmap		     *bi
 	    }
 	}
 
 #ifndef WORDS_BIGENDIAN
 	{
-	    unsigned char   *d = data;
+	    uint8_t   *d = data;
 	    int		count = stride * height;
 
 	    while (count--) {
 		*d = CAIRO_BITSWAP8 (*d);
 		d++;
@@ -827,15 +1114,11 @@ _get_bitmap_surface (FT_Bitmap		     *bi
 	break;
 
     case FT_PIXEL_MODE_LCD:
     case FT_PIXEL_MODE_LCD_V:
     case FT_PIXEL_MODE_GRAY:
-	switch (font_options->antialias) {
-	case CAIRO_ANTIALIAS_DEFAULT:
-	case CAIRO_ANTIALIAS_GRAY:
-	case CAIRO_ANTIALIAS_NONE:
-	default:
+        if (font_options->antialias != CAIRO_ANTIALIAS_SUBPIXEL) {
 	    stride = bitmap->pitch;
 	    if (own_buffer) {
 		data = bitmap->buffer;
 	    } else {
 		data = _cairo_malloc_ab (height, stride);
@@ -843,108 +1126,20 @@ _get_bitmap_surface (FT_Bitmap		     *bi
 		    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
 
 		memcpy (data, bitmap->buffer, stride * height);
 	    }
 	    format = CAIRO_FORMAT_A8;
-	    break;
-	case CAIRO_ANTIALIAS_SUBPIXEL: {
-	    int		    x, y;
-	    unsigned char   *in_line, *out_line, *in;
-	    unsigned int    *out;
-	    unsigned int    red, green, blue;
-	    int		    rf, gf, bf;
-	    int		    s;
-	    int		    o, os;
-	    unsigned char   *data_rgba;
-	    unsigned int    width_rgba, stride_rgba;
-	    int		    vmul = 1;
-	    int		    hmul = 1;
+	} else {
+	    /* if we get there, the  data from the source bitmap
+	     * really comes from _fill_xrender_bitmap, and is
+	     * made of 32-bit ARGB or ABGR values */
+	    assert (own_buffer != 0);
+	    assert (bitmap->pixel_mode != FT_PIXEL_MODE_GRAY);
 
-	    switch (font_options->subpixel_order) {
-	    case CAIRO_SUBPIXEL_ORDER_DEFAULT:
-	    case CAIRO_SUBPIXEL_ORDER_RGB:
-	    case CAIRO_SUBPIXEL_ORDER_BGR:
-	    default:
-		width /= 3;
-		hmul = 3;
-		break;
-	    case CAIRO_SUBPIXEL_ORDER_VRGB:
-	    case CAIRO_SUBPIXEL_ORDER_VBGR:
-		vmul = 3;
-		height /= 3;
-		break;
-	    }
-	    /*
-	     * Filter the glyph to soften the color fringes
-	     */
-	    width_rgba = width;
+	    data = bitmap->buffer;
 	    stride = bitmap->pitch;
-	    stride_rgba = (width_rgba * 4 + 3) & ~3;
-	    data_rgba = calloc (stride_rgba, height);
-	    if (data_rgba == NULL) {
-		if (own_buffer)
-		    free (bitmap->buffer);
-		return _cairo_error (CAIRO_STATUS_NO_MEMORY);
-	    }
-
-	    os = 1;
-	    switch (font_options->subpixel_order) {
-	    case CAIRO_SUBPIXEL_ORDER_VRGB:
-		os = stride;
-	    case CAIRO_SUBPIXEL_ORDER_DEFAULT:
-	    case CAIRO_SUBPIXEL_ORDER_RGB:
-	    default:
-		rf = 0;
-		gf = 1;
-		bf = 2;
-		break;
-	    case CAIRO_SUBPIXEL_ORDER_VBGR:
-		os = stride;
-	    case CAIRO_SUBPIXEL_ORDER_BGR:
-		bf = 0;
-		gf = 1;
-		rf = 2;
-		break;
-	    }
-	    in_line = bitmap->buffer;
-	    out_line = data_rgba;
-	    for (y = 0; y < height; y++)
-	    {
-		in = in_line;
-		out = (unsigned int *) out_line;
-		in_line += stride * vmul;
-		out_line += stride_rgba;
-		for (x = 0; x < width * hmul; x += hmul)
-		{
-		    red = green = blue = 0;
-		    o = 0;
-		    for (s = 0; s < 3; s++)
-		    {
-			red += filters[rf][s]*in[x+o];
-			green += filters[gf][s]*in[x+o];
-			blue += filters[bf][s]*in[x+o];
-			o += os;
-		    }
-		    red = red / 65536;
-		    green = green / 65536;
-		    blue = blue / 65536;
-		    *out++ = (green << 24) | (red << 16) | (green << 8) | blue;
-		}
-	    }
-
-	    /* Images here are stored in native format. The
-	     * backend must convert to its own format as needed
-	     */
-
-	    if (own_buffer)
-		free (bitmap->buffer);
-	    data = data_rgba;
-	    stride = stride_rgba;
 	    format = CAIRO_FORMAT_ARGB32;
-	    subpixel = TRUE;
-	    break;
-	}
 	}
 	break;
     case FT_PIXEL_MODE_GRAY2:
     case FT_PIXEL_MODE_GRAY4:
 	/* These could be triggered by very rare types of TrueType fonts */
@@ -952,23 +1147,24 @@ _get_bitmap_surface (FT_Bitmap		     *bi
 	if (own_buffer)
 	    free (bitmap->buffer);
 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
     }
 
-    *surface = (cairo_image_surface_t *)
+    /* XXX */
+    *surface = image = (cairo_image_surface_t *)
 	cairo_image_surface_create_for_data (data,
 					     format,
 					     width, height, stride);
-    if ((*surface)->base.status) {
+    if (image->base.status) {
 	free (data);
 	return (*surface)->base.status;
     }
 
-    if (subpixel)
-	pixman_image_set_component_alpha ((*surface)->pixman_image, TRUE);
+    if (font_options->antialias == CAIRO_ANTIALIAS_SUBPIXEL)
+	pixman_image_set_component_alpha (image->pixman_image, TRUE);
 
-    _cairo_image_surface_assume_ownership_of_data ((*surface));
+    _cairo_image_surface_assume_ownership_of_data (image);
 
     return CAIRO_STATUS_SUCCESS;
 }
 
 /* Converts an outline FT_GlyphSlot into an image
@@ -989,44 +1185,88 @@ static cairo_status_t
 static cairo_status_t
 _render_glyph_outline (FT_Face                    face,
 		       cairo_font_options_t	 *font_options,
 		       cairo_image_surface_t	**surface)
 {
+    int rgba = FC_RGBA_UNKNOWN;
+    int lcd_filter = FT_LCD_FILTER_LEGACY;
     FT_GlyphSlot glyphslot = face->glyph;
     FT_Outline *outline = &glyphslot->outline;
     FT_Bitmap bitmap;
     FT_BBox cbox;
-    FT_Matrix matrix;
-    int hmul = 1;
-    int vmul = 1;
-    unsigned int width, height, stride;
-    cairo_bool_t subpixel = FALSE;
+    unsigned int width, height;
     cairo_status_t status;
+    FT_Error fterror;
+    FT_Library library = glyphslot->library;
+    FT_Render_Mode render_mode = FT_RENDER_MODE_NORMAL;
+
+    switch (font_options->antialias) {
+    case CAIRO_ANTIALIAS_NONE:
+	render_mode = FT_RENDER_MODE_MONO;
+	break;
+
+    case CAIRO_ANTIALIAS_SUBPIXEL:
+	switch (font_options->subpixel_order) {
+	    case CAIRO_SUBPIXEL_ORDER_DEFAULT:
+	    case CAIRO_SUBPIXEL_ORDER_RGB:
+	    case CAIRO_SUBPIXEL_ORDER_BGR:
+		render_mode = FT_RENDER_MODE_LCD;
+		break;
+
+	    case CAIRO_SUBPIXEL_ORDER_VRGB:
+	    case CAIRO_SUBPIXEL_ORDER_VBGR:
+		render_mode = FT_RENDER_MODE_LCD_V;
+		break;
+	}
+
+	switch (font_options->lcd_filter) {
+	case CAIRO_LCD_FILTER_NONE:
+	    lcd_filter = FT_LCD_FILTER_NONE;
+	    break;
+	case CAIRO_LCD_FILTER_DEFAULT:
+	case CAIRO_LCD_FILTER_INTRA_PIXEL:
+	    lcd_filter = FT_LCD_FILTER_LEGACY;
+	    break;
+	case CAIRO_LCD_FILTER_FIR3:
+	    lcd_filter = FT_LCD_FILTER_LIGHT;
+	    break;
+	case CAIRO_LCD_FILTER_FIR5:
+	    lcd_filter = FT_LCD_FILTER_DEFAULT;
+	    break;
+	}
+
+	break;
+
+    case CAIRO_ANTIALIAS_DEFAULT:
+    case CAIRO_ANTIALIAS_GRAY:
+	render_mode = FT_RENDER_MODE_NORMAL;
+    }
 
     FT_Outline_Get_CBox (outline, &cbox);
 
     cbox.xMin &= -64;
     cbox.yMin &= -64;
     cbox.xMax = (cbox.xMax + 63) & -64;
     cbox.yMax = (cbox.yMax + 63) & -64;
 
     width = (unsigned int) ((cbox.xMax - cbox.xMin) >> 6);
     height = (unsigned int) ((cbox.yMax - cbox.yMin) >> 6);
-    stride = (width * hmul + 3) & ~3;
 
     if (width * height == 0) {
 	cairo_format_t format;
 	/* Looks like fb handles zero-sized images just fine */
-	switch (font_options->antialias) {
-	case CAIRO_ANTIALIAS_NONE:
+	switch (render_mode) {
+	case FT_RENDER_MODE_MONO:
 	    format = CAIRO_FORMAT_A1;
 	    break;
-	case CAIRO_ANTIALIAS_SUBPIXEL:
+	case FT_RENDER_MODE_LCD:
+	case FT_RENDER_MODE_LCD_V:
 	    format= CAIRO_FORMAT_ARGB32;
 	    break;
-	case CAIRO_ANTIALIAS_DEFAULT:
-	case CAIRO_ANTIALIAS_GRAY:
+	case FT_RENDER_MODE_LIGHT:
+	case FT_RENDER_MODE_NORMAL:
+	case FT_RENDER_MODE_MAX:
 	default:
 	    format = CAIRO_FORMAT_A8;
 	    break;
 	}
 
@@ -1034,77 +1274,77 @@ _render_glyph_outline (FT_Face          
 	    cairo_image_surface_create_for_data (NULL, format, 0, 0, 0);
 	if ((*surface)->base.status)
 	    return (*surface)->base.status;
     } else  {
 
-	matrix.xx = matrix.yy = 0x10000L;
-	matrix.xy = matrix.yx = 0;
+	int bitmap_size;
 
-	switch (font_options->antialias) {
-	case CAIRO_ANTIALIAS_NONE:
-	    bitmap.pixel_mode = FT_PIXEL_MODE_MONO;
-	    bitmap.num_grays  = 1;
-	    stride = ((width + 31) & -32) >> 3;
+	switch (render_mode) {
+	case FT_RENDER_MODE_LCD:
+	    if (font_options->subpixel_order == CAIRO_SUBPIXEL_ORDER_BGR) {
+		rgba = FC_RGBA_BGR;
+	    } else {
+		rgba = FC_RGBA_RGB;
+	    }
 	    break;
-	case CAIRO_ANTIALIAS_DEFAULT:
-	case CAIRO_ANTIALIAS_GRAY:
-	    bitmap.pixel_mode = FT_PIXEL_MODE_GRAY;
-	    bitmap.num_grays  = 256;
-	    stride = (width + 3) & -4;
+	case FT_RENDER_MODE_LCD_V:
+	    if (font_options->subpixel_order == CAIRO_SUBPIXEL_ORDER_VBGR) {
+		rgba = FC_RGBA_VBGR;
+	    } else {
+		rgba = FC_RGBA_VRGB;
+	    }
 	    break;
-	case CAIRO_ANTIALIAS_SUBPIXEL:
-	    switch (font_options->subpixel_order) {
-	    case CAIRO_SUBPIXEL_ORDER_RGB:
-	    case CAIRO_SUBPIXEL_ORDER_BGR:
-	    case CAIRO_SUBPIXEL_ORDER_DEFAULT:
-	    default:
-		matrix.xx *= 3;
-		hmul = 3;
-		subpixel = TRUE;
-		break;
-	    case CAIRO_SUBPIXEL_ORDER_VRGB:
-	    case CAIRO_SUBPIXEL_ORDER_VBGR:
-		matrix.yy *= 3;
-		vmul = 3;
-		subpixel = TRUE;
-		break;
-	    }
-	    FT_Outline_Transform (outline, &matrix);
-
-	    bitmap.pixel_mode = FT_PIXEL_MODE_GRAY;
-	    bitmap.num_grays  = 256;
-	    stride = (width * hmul + 3) & -4;
+	case FT_RENDER_MODE_MONO:
+	case FT_RENDER_MODE_LIGHT:
+	case FT_RENDER_MODE_NORMAL:
+	case FT_RENDER_MODE_MAX:
+	default:
+	    break;
 	}
 
-	bitmap.pitch = stride;
-	bitmap.width = width * hmul;
-	bitmap.rows = height * vmul;
-	bitmap.buffer = calloc (stride, bitmap.rows);
+#if HAVE_FT_LIBRARY_SETLCDFILTER
+	FT_Library_SetLcdFilter (library, lcd_filter);
+#endif
+
+	fterror = FT_Render_Glyph (face->glyph, render_mode);
+
+#if HAVE_FT_LIBRARY_SETLCDFILTER
+	FT_Library_SetLcdFilter (library, FT_LCD_FILTER_NONE);
+#endif
+
+	if (fterror != 0)
+	    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+
+	bitmap_size = _compute_xrender_bitmap_size (&bitmap,
+						    face->glyph,
+						    render_mode);
+	if (bitmap_size < 0)
+	    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+
+	bitmap.buffer = calloc (1, bitmap_size);
 	if (bitmap.buffer == NULL)
 	    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
 
-	FT_Outline_Translate (outline, -cbox.xMin*hmul, -cbox.yMin*vmul);
+	_fill_xrender_bitmap (&bitmap, face->glyph, render_mode,
+			      (rgba == FC_RGBA_BGR || rgba == FC_RGBA_VBGR));
 
-	if (FT_Outline_Get_Bitmap (glyphslot->library, outline, &bitmap) != 0) {
-	    free (bitmap.buffer);
-	    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
-	}
-
+	/* Note:
+	 * _get_bitmap_surface will free bitmap.buffer if there is an error
+	 */
 	status = _get_bitmap_surface (&bitmap, TRUE, font_options, surface);
 	if (status)
 	    return status;
+
+	/* Note: the font's coordinate system is upside down from ours, so the
+	 * Y coordinate of the control box needs to be negated.  Moreover, device
+	 * offsets are position of glyph origin relative to top left while xMin
+	 * and yMax are offsets of top left relative to origin.  Another negation.
+	 */
+	cairo_surface_set_device_offset (&(*surface)->base,
+					 (double)-glyphslot->bitmap_left,
+					 (double)+glyphslot->bitmap_top);
     }
-
-    /*
-     * Note: the font's coordinate system is upside down from ours, so the
-     * Y coordinate of the control box needs to be negated.  Moreover, device
-     * offsets are position of glyph origin relative to top left while xMin
-     * and yMax are offsets of top left relative to origin.  Another negation.
-     */
-    cairo_surface_set_device_offset (&(*surface)->base,
-				     floor (-(double) cbox.xMin / 64.0),
-				     floor (+(double) cbox.yMax / 64.0));
 
     return CAIRO_STATUS_SUCCESS;
 }
 
 /* Converts a bitmap (or other) FT_GlyphSlot into an image */
@@ -1320,10 +1560,11 @@ _get_pattern_ft_options (FcPattern *patt
 			  FC_ANTIALIAS, 0, &antialias) != FcResultMatch)
 	antialias = FcTrue;
     
     if (antialias) {
 	cairo_subpixel_order_t subpixel_order;
+	int lcd_filter;
 
 	/* disable hinting if requested */
 	if (FcPatternGetBool (pattern,
 			      FC_HINTING, 0, &hinting) != FcResultMatch)
 	    hinting = FcTrue;
@@ -1353,10 +1594,29 @@ _get_pattern_ft_options (FcPattern *patt
 	}
 
 	if (subpixel_order != CAIRO_SUBPIXEL_ORDER_DEFAULT) {
 	    ft_options.base.subpixel_order = subpixel_order;
 	    ft_options.base.antialias = CAIRO_ANTIALIAS_SUBPIXEL;
+	}
+
+	if (FcPatternGetInteger (pattern,
+				 FC_LCD_FILTER, 0, &lcd_filter) == FcResultMatch)
+	{
+	    switch (lcd_filter) {
+	    case FC_LCD_NONE:
+		ft_options.base.lcd_filter = CAIRO_LCD_FILTER_NONE;
+		break;
+	    case FC_LCD_DEFAULT:
+		ft_options.base.lcd_filter = CAIRO_LCD_FILTER_FIR5;
+		break;
+	    case FC_LCD_LIGHT:
+		ft_options.base.lcd_filter = CAIRO_LCD_FILTER_FIR3;
+		break;
+	    case FC_LCD_LEGACY:
+		ft_options.base.lcd_filter = CAIRO_LCD_FILTER_INTRA_PIXEL;
+		break;
+	    }
 	}
 
 #ifdef FC_HINT_STYLE    
 	if (FcPatternGetInteger (pattern, 
 				 FC_HINT_STYLE, 0, &hintstyle) != FcResultMatch)
@@ -1455,10 +1715,16 @@ _cairo_ft_options_merge (cairo_ft_option
 	options->base.hint_style = other->base.hint_style;
 
     if (other->base.hint_style == CAIRO_HINT_STYLE_NONE)
 	options->base.hint_style = CAIRO_HINT_STYLE_NONE;
 
+    if (options->base.lcd_filter == CAIRO_LCD_FILTER_DEFAULT)
+	options->base.lcd_filter = other->base.lcd_filter;
+
+    if (other->base.lcd_filter == CAIRO_LCD_FILTER_NONE)
+	options->base.lcd_filter = CAIRO_LCD_FILTER_NONE;
+
     if (options->base.antialias == CAIRO_ANTIALIAS_NONE) {
 	if (options->base.hint_style == CAIRO_HINT_STYLE_NONE)
 	    load_flags |= FT_LOAD_NO_HINTING;
 	else
 	    load_target = FT_LOAD_TARGET_MONO;
@@ -1478,15 +1744,15 @@ _cairo_ft_options_merge (cairo_ft_option
 	    if (options->base.antialias == CAIRO_ANTIALIAS_SUBPIXEL) {
 		switch (options->base.subpixel_order) {
 		case CAIRO_SUBPIXEL_ORDER_DEFAULT:
 		case CAIRO_SUBPIXEL_ORDER_RGB:
 		case CAIRO_SUBPIXEL_ORDER_BGR:
-		    load_target |= FT_LOAD_TARGET_LCD;
+		    load_target = FT_LOAD_TARGET_LCD;
 		    break;
 		case CAIRO_SUBPIXEL_ORDER_VRGB:
 		case CAIRO_SUBPIXEL_ORDER_VBGR:
-		    load_target |= FT_LOAD_TARGET_LCD_V;
+		    load_target = FT_LOAD_TARGET_LCD_V;
 		break;
 		}
 	    }
 	    break;
 	}
@@ -2144,11 +2410,15 @@ _cairo_ft_ucs4_to_index (void	    *abstr
     FT_UInt index;
 
     face = _cairo_ft_unscaled_font_lock_face (unscaled);
     if (!face)
 	return 0;
-    index = FT_Get_Char_Index (face, ucs4);
+
+    /* If making this compile without fontconfig, use:
+     * index = FT_Get_Char_Index (face, ucs4); */
+    index = FcFreeTypeCharIndex (face, ucs4);
+
     _cairo_ft_unscaled_font_unlock_face (unscaled);
     return index;
 }
 
 static cairo_int_status_t
@@ -2417,10 +2687,38 @@ _cairo_ft_font_options_substitute (const
 	    } else {
 		rgba = FC_RGBA_NONE;
 	    }
 
 	    if (! FcPatternAddInteger (pattern, FC_RGBA, rgba))
+		return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+	}
+    }
+
+    if (options->lcd_filter != CAIRO_LCD_FILTER_DEFAULT)
+    {
+	if (FcPatternGet (pattern, FC_LCD_FILTER, 0, &v) == FcResultNoMatch)
+	{
+	    int lcd_filter;
+
+	    switch (options->lcd_filter) {
+	    case CAIRO_LCD_FILTER_NONE:
+		lcd_filter = FT_LCD_FILTER_NONE;
+		break;
+	    case CAIRO_LCD_FILTER_DEFAULT:
+	    case CAIRO_LCD_FILTER_INTRA_PIXEL:
+		lcd_filter = FT_LCD_FILTER_LEGACY;
+		break;
+	    case CAIRO_LCD_FILTER_FIR3:
+		lcd_filter = FT_LCD_FILTER_LIGHT;
+		break;
+	    default:
+	    case CAIRO_LCD_FILTER_FIR5:
+		lcd_filter = FT_LCD_FILTER_DEFAULT;
+		break;
+	    }
+
+	    if (! FcPatternAddInteger (pattern, FC_LCD_FILTER, lcd_filter))
 		return _cairo_error (CAIRO_STATUS_NO_MEMORY);
 	}
     }
 
     if (options->hint_style != CAIRO_HINT_STYLE_DEFAULT)
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-gstate.c
--- a/gfx/cairo/cairo/src/cairo-gstate.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-gstate.c	Mon Sep 08 10:35:45 2008 +0300
@@ -97,12 +97,13 @@ _cairo_gstate_init (cairo_gstate_t  *gst
 
     gstate->target = cairo_surface_reference (target);
     gstate->parent_target = NULL;
     gstate->original_target = cairo_surface_reference (target);
 
-    _cairo_gstate_identity_matrix (gstate);
-    gstate->source_ctm_inverse = gstate->ctm_inverse;
+    cairo_matrix_init_identity (&gstate->ctm);
+    gstate->ctm_inverse = gstate->ctm;
+    gstate->source_ctm_inverse = gstate->ctm;
 
     gstate->source = _cairo_pattern_create_solid (CAIRO_COLOR_BLACK,
 						  CAIRO_CONTENT_COLOR);
 
     /* Now that the gstate is fully initialized and ready for the eventual
@@ -651,10 +652,13 @@ _cairo_gstate_transform (cairo_gstate_t	
 			 const cairo_matrix_t *matrix)
 {
     cairo_matrix_t tmp;
     cairo_status_t status;
 
+    if (_cairo_matrix_is_identity (matrix))
+	return CAIRO_STATUS_SUCCESS;
+
     tmp = *matrix;
     status = cairo_matrix_invert (&tmp);
     if (status)
 	return status;
 
@@ -674,10 +678,13 @@ _cairo_gstate_set_matrix (cairo_gstate_t
 _cairo_gstate_set_matrix (cairo_gstate_t       *gstate,
 			  const cairo_matrix_t *matrix)
 {
     cairo_status_t status;
 
+    if (memcmp (matrix, &gstate->ctm, sizeof (cairo_matrix_t)) == 0)
+	return CAIRO_STATUS_SUCCESS;
+
     if (! _cairo_matrix_is_invertible (matrix))
 	return _cairo_error (CAIRO_STATUS_INVALID_MATRIX);
 
     _cairo_gstate_unset_scaled_font (gstate);
 
@@ -690,10 +697,13 @@ _cairo_gstate_set_matrix (cairo_gstate_t
 }
 
 void
 _cairo_gstate_identity_matrix (cairo_gstate_t *gstate)
 {
+    if (_cairo_matrix_is_identity (&gstate->ctm))
+	return;
+
     _cairo_gstate_unset_scaled_font (gstate);
 
     cairo_matrix_init_identity (&gstate->ctm);
     cairo_matrix_init_identity (&gstate->ctm_inverse);
 }
@@ -1213,11 +1223,11 @@ _cairo_gstate_select_font_face (cairo_gs
 				cairo_font_weight_t   weight)
 {
     cairo_font_face_t *font_face;
     cairo_status_t status;
 
-    font_face = _cairo_toy_font_face_create (family, slant, weight);
+    font_face = cairo_toy_font_face_create (family, slant, weight);
     if (font_face->status)
 	return font_face->status;
 
     status = _cairo_gstate_set_font_face (gstate, font_face);
     cairo_font_face_destroy (font_face);
@@ -1238,10 +1248,13 @@ _cairo_gstate_set_font_size (cairo_gstat
 
 cairo_status_t
 _cairo_gstate_set_font_matrix (cairo_gstate_t	    *gstate,
 			       const cairo_matrix_t *matrix)
 {
+    if (memcmp (matrix, &gstate->font_matrix, sizeof (cairo_matrix_t)) == 0)
+	return CAIRO_STATUS_SUCCESS;
+
     if (! _cairo_matrix_is_invertible (matrix))
 	return _cairo_error (CAIRO_STATUS_INVALID_MATRIX);
 
     _cairo_gstate_unset_scaled_font (gstate);
 
@@ -1259,10 +1272,13 @@ _cairo_gstate_get_font_matrix (cairo_gst
 
 void
 _cairo_gstate_set_font_options (cairo_gstate_t             *gstate,
 				const cairo_font_options_t *options)
 {
+    if (memcmp (options, &gstate->font_options, sizeof (cairo_font_options_t)) == 0)
+	return;
+
     _cairo_gstate_unset_scaled_font (gstate);
 
     _cairo_font_options_init_copy (&gstate->font_options, options);
 }
 
@@ -1387,13 +1403,13 @@ _cairo_gstate_ensure_font_face (cairo_gs
 
     if (gstate->font_face != NULL)
 	return gstate->font_face->status;
 
 
-    font_face = _cairo_toy_font_face_create (CAIRO_FONT_FAMILY_DEFAULT,
-					     CAIRO_FONT_SLANT_DEFAULT,
-					     CAIRO_FONT_WEIGHT_DEFAULT);
+    font_face = cairo_toy_font_face_create (CAIRO_FONT_FAMILY_DEFAULT,
+					    CAIRO_FONT_SLANT_DEFAULT,
+					    CAIRO_FONT_WEIGHT_DEFAULT);
     if (font_face->status)
 	return font_face->status;
 
     gstate->font_face = font_face;
 
@@ -1443,38 +1459,46 @@ _cairo_gstate_get_font_extents (cairo_gs
 
     return cairo_scaled_font_status (gstate->scaled_font);
 }
 
 cairo_status_t
-_cairo_gstate_text_to_glyphs (cairo_gstate_t *gstate,
-			      const char     *utf8,
-			      double	      x,
-			      double	      y,
-			      cairo_glyph_t **glyphs,
-			      int	     *num_glyphs)
+_cairo_gstate_text_to_glyphs (cairo_gstate_t	    *gstate,
+			      double		     x,
+			      double		     y,
+			      const char	    *utf8,
+			      int		     utf8_len,
+			      cairo_glyph_t	   **glyphs,
+			      int		    *num_glyphs,
+			      cairo_text_cluster_t **clusters,
+			      int		    *num_clusters,
+			      cairo_bool_t	    *backward)
 {
     cairo_status_t status;
 
     status = _cairo_gstate_ensure_scaled_font (gstate);
     if (status)
 	return status;
 
-    return _cairo_scaled_font_text_to_glyphs (gstate->scaled_font, x, y,
-					      utf8, glyphs, num_glyphs);
+    return cairo_scaled_font_text_to_glyphs (gstate->scaled_font, x, y,
+					     utf8, utf8_len,
+					     glyphs, num_glyphs,
+					     clusters, num_clusters,
+					     backward);
 }
 
 cairo_status_t
 _cairo_gstate_set_font_face (cairo_gstate_t    *gstate,
 			     cairo_font_face_t *font_face)
 {
     if (font_face && font_face->status)
 	return font_face->status;
 
-    if (font_face != gstate->font_face) {
-	cairo_font_face_destroy (gstate->font_face);
-	gstate->font_face = cairo_font_face_reference (font_face);
-    }
+    if (font_face == gstate->font_face)
+	return CAIRO_STATUS_SUCCESS;
+
+    cairo_font_face_destroy (gstate->font_face);
+    gstate->font_face = cairo_font_face_reference (font_face);
 
     _cairo_gstate_unset_scaled_font (gstate);
 
     return CAIRO_STATUS_SUCCESS;
 }
@@ -1499,11 +1523,11 @@ _cairo_gstate_glyph_extents (cairo_gstat
 }
 
 cairo_bool_t
 _cairo_gstate_has_show_text_glyphs (cairo_gstate_t *gstate)
 {
-    return _cairo_surface_has_show_text_glyphs (gstate->target);
+    return cairo_surface_has_show_text_glyphs (gstate->target);
 }
 
 cairo_status_t
 _cairo_gstate_show_text_glyphs (cairo_gstate_t		   *gstate,
 				const char		   *utf8,
@@ -1531,11 +1555,11 @@ _cairo_gstate_show_text_glyphs (cairo_gs
 	return status;
 
     if (num_glyphs <= ARRAY_LENGTH (stack_transformed_glyphs)) {
 	transformed_glyphs = stack_transformed_glyphs;
     } else {
-	transformed_glyphs = _cairo_malloc_ab (num_glyphs, sizeof(cairo_glyph_t));
+	transformed_glyphs = cairo_glyph_allocate (num_glyphs);
 	if (transformed_glyphs == NULL)
 	    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
     }
 
     _cairo_gstate_transform_glyphs_to_backend (gstate, glyphs, num_glyphs,
@@ -1545,10 +1569,14 @@ _cairo_gstate_show_text_glyphs (cairo_gs
 	goto CLEANUP_GLYPHS;
 
     status = _cairo_gstate_copy_transformed_source (gstate, &source_pattern.base);
     if (status)
 	goto CLEANUP_GLYPHS;
+
+    /* Just in case */
+    if (!clusters)
+	num_clusters = 0;
 
     /* For really huge font sizes, we can just do path;fill instead of
      * show_glyphs, as show_glyphs would put excess pressure on the cache,
      * and moreover, not all components below us correctly handle huge font
      * sizes.  I wanted to set the limit at 256.  But alas, seems like cairo's
@@ -1593,11 +1621,11 @@ _cairo_gstate_show_text_glyphs (cairo_gs
 
     _cairo_pattern_fini (&source_pattern.base);
 
 CLEANUP_GLYPHS:
     if (transformed_glyphs != stack_transformed_glyphs)
-      free (transformed_glyphs);
+      cairo_glyph_free (transformed_glyphs);
 
     return status;
 }
 
 cairo_status_t
@@ -1615,11 +1643,11 @@ _cairo_gstate_glyph_path (cairo_gstate_t
 	return status;
 
     if (num_glyphs < ARRAY_LENGTH (stack_transformed_glyphs))
       transformed_glyphs = stack_transformed_glyphs;
     else
-      transformed_glyphs = _cairo_malloc_ab (num_glyphs, sizeof(cairo_glyph_t));
+      transformed_glyphs = cairo_glyph_allocate (num_glyphs);
     if (transformed_glyphs == NULL)
 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
 
     _cairo_gstate_transform_glyphs_to_backend (gstate, glyphs, num_glyphs,
                                                transformed_glyphs, NULL);
@@ -1629,11 +1657,11 @@ _cairo_gstate_glyph_path (cairo_gstate_t
 					    transformed_glyphs, num_glyphs,
 					    path);
     CAIRO_MUTEX_UNLOCK (gstate->scaled_font->mutex);
 
     if (transformed_glyphs != stack_transformed_glyphs)
-      free (transformed_glyphs);
+      cairo_glyph_free (transformed_glyphs);
 
     return status;
 }
 
 cairo_status_t
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-image-surface.c
--- a/gfx/cairo/cairo/src/cairo-image-surface.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-image-surface.c	Mon Sep 08 10:35:45 2008 +0300
@@ -257,18 +257,19 @@ _cairo_image_surface_create_with_masks (
     pixman_format_code_t pixman_format;
 
     status = _pixman_format_from_masks (masks, &pixman_format);
     if (status == CAIRO_INT_STATUS_UNSUPPORTED) {
 	fprintf (stderr,
-		 "Error: Cairo " PACKAGE_VERSION " does not yet support the requested image format:\n"
+		 "Error: Cairo %s does not yet support the requested image format:\n"
 		 "\tDepth: %d\n"
 		 "\tAlpha mask: 0x%08lx\n"
 		 "\tRed   mask: 0x%08lx\n"
 		 "\tGreen mask: 0x%08lx\n"
 		 "\tBlue  mask: 0x%08lx\n"
 		 "Please file an enhancement request (quoting the above) at:\n"
 		 PACKAGE_BUGREPORT "\n",
+		 cairo_version_string (),
 		 masks->bpp, masks->alpha_mask,
 		 masks->red_mask, masks->green_mask, masks->blue_mask);
 
 	ASSERT_NOT_REACHED;
     }
@@ -790,12 +791,13 @@ _cairo_image_surface_set_matrix (cairo_i
 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
 
     return CAIRO_STATUS_SUCCESS;
 }
 
-static void
-_cairo_image_surface_set_filter (cairo_image_surface_t *surface, cairo_filter_t filter)
+static cairo_status_t
+_cairo_image_surface_set_filter (cairo_image_surface_t *surface,
+				 cairo_filter_t filter)
 {
     pixman_filter_t pixman_filter;
 
     switch (filter) {
     case CAIRO_FILTER_FAST:
@@ -821,11 +823,18 @@ _cairo_image_surface_set_filter (cairo_i
 	 * implementation for it. */
     default:
 	pixman_filter = PIXMAN_FILTER_BEST;
     }
 
-    pixman_image_set_filter (surface->pixman_image, pixman_filter, NULL, 0);
+    if (! pixman_image_set_filter (surface->pixman_image,
+				   pixman_filter,
+				   NULL, 0))
+    {
+	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+    }
+
+    return CAIRO_STATUS_SUCCESS;
 }
 
 static cairo_status_t
 _cairo_image_surface_set_attributes (cairo_image_surface_t      *surface,
 				     cairo_surface_attributes_t *attributes)
@@ -849,11 +858,13 @@ _cairo_image_surface_set_attributes (cai
     case CAIRO_EXTEND_PAD:
         pixman_image_set_repeat (surface->pixman_image, PIXMAN_REPEAT_PAD);
 	break;
     }
 
-    _cairo_image_surface_set_filter (surface, attributes->filter);
+    status = _cairo_image_surface_set_filter (surface, attributes->filter);
+    if (status)
+	return status;
 
     return CAIRO_STATUS_SUCCESS;
 }
 
 /* XXX: I think we should fix pixman to match the names/order of the
@@ -1056,12 +1067,11 @@ _cairo_image_surface_composite_trapezoid
     pixman_format_code_t	 format;
     uint32_t			*mask_data;
     pixman_trapezoid_t		 stack_traps[CAIRO_STACK_ARRAY_LENGTH (pixman_trapezoid_t)];
     pixman_trapezoid_t		*pixman_traps = stack_traps;
     int				 mask_stride;
-    int				 mask_bpp;
-    int				 ret, i;
+    int				 i;
 
     if (height == 0 || width == 0)
 	return CAIRO_STATUS_SUCCESS;
 
     /* Convert traps to pixman traps */
@@ -1121,22 +1131,18 @@ _cairo_image_surface_composite_trapezoid
 	goto CLEANUP_SOURCE;
 
     switch (antialias) {
     case CAIRO_ANTIALIAS_NONE:
 	format = PIXMAN_a1;
-	ret = 1;
 	mask_stride = ((width + 31) / 8) & ~0x03;
-	mask_bpp = 1;
 	break;
     case CAIRO_ANTIALIAS_GRAY:
     case CAIRO_ANTIALIAS_SUBPIXEL:
     case CAIRO_ANTIALIAS_DEFAULT:
     default:
 	format = PIXMAN_a8;
-	ret = 1;
 	mask_stride = (width + 3) & ~3;
-	mask_bpp = 8;
 	break;
     }
 
     /* The image must be initially transparent */
     mask_data = calloc (mask_stride, height);
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-matrix.c
--- a/gfx/cairo/cairo/src/cairo-matrix.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-matrix.c	Mon Sep 08 10:35:45 2008 +0300
@@ -486,11 +486,11 @@ cairo_matrix_invert (cairo_matrix_t *mat
 cairo_matrix_invert (cairo_matrix_t *matrix)
 {
     /* inv (A) = 1/det (A) * adj (A) */
     double det;
 
-    _cairo_matrix_compute_determinant (matrix, &det);
+    det = _cairo_matrix_compute_determinant (matrix);
 
     if (! ISFINITE (det))
 	return _cairo_error (CAIRO_STATUS_INVALID_MATRIX);
 
     if (det == 0)
@@ -506,46 +506,58 @@ cairo_bool_t
 cairo_bool_t
 _cairo_matrix_is_invertible (const cairo_matrix_t *matrix)
 {
     double det;
 
-    _cairo_matrix_compute_determinant (matrix, &det);
+    det = _cairo_matrix_compute_determinant (matrix);
 
     return ISFINITE (det) && det != 0.;
 }
 
-void
-_cairo_matrix_compute_determinant (const cairo_matrix_t *matrix,
-				   double		*det)
+double
+_cairo_matrix_compute_determinant (const cairo_matrix_t *matrix)
 {
     double a, b, c, d;
 
     a = matrix->xx; b = matrix->yx;
     c = matrix->xy; d = matrix->yy;
 
-    *det = a*d - b*c;
+    return a*d - b*c;
 }
 
-/* Compute the amount that each basis vector is scaled by. */
+/**
+ * _cairo_matrix_compute_basis_scale_factors:
+ * @matrix: a matrix
+ * @basis_scale: the scale factor in the direction of basis
+ * @normal_scale: the scale factor in the direction normal to the basis
+ * @x_basis: basis to use.  X basis if true, Y basis otherwise.
+ *
+ * Computes |Mv| and det(M)/|Mv| for v=[1,0] if x_basis is true, and v=[0,1]
+ * otherwise, and M is @matrix.
+ *
+ * Return value: the scale factor of @matrix on the height of the font,
+ * or 1.0 if @matrix is %NULL.
+ **/
 cairo_status_t
-_cairo_matrix_compute_scale_factors (const cairo_matrix_t *matrix,
-				     double *sx, double *sy, int x_major)
+_cairo_matrix_compute_basis_scale_factors (const cairo_matrix_t *matrix,
+					   double *basis_scale, double *normal_scale,
+					   cairo_bool_t x_basis)
 {
     double det;
 
-    _cairo_matrix_compute_determinant (matrix, &det);
+    det = _cairo_matrix_compute_determinant (matrix);
 
     if (! ISFINITE (det))
 	return _cairo_error (CAIRO_STATUS_INVALID_MATRIX);
 
     if (det == 0)
     {
-	*sx = *sy = 0;
+	*basis_scale = *normal_scale = 0;
     }
     else
     {
-	double x = x_major != 0;
+	double x = x_basis != 0;
 	double y = x == 0;
 	double major, minor;
 
 	cairo_matrix_transform_distance (matrix, &x, &y);
 	major = sqrt(x*x + y*y);
@@ -556,19 +568,19 @@ _cairo_matrix_compute_scale_factors (con
 	    det = -det;
 	if (major)
 	    minor = det / major;
 	else
 	    minor = 0.0;
-	if (x_major)
+	if (x_basis)
 	{
-	    *sx = major;
-	    *sy = minor;
+	    *basis_scale = major;
+	    *normal_scale = minor;
 	}
 	else
 	{
-	    *sx = minor;
-	    *sy = major;
+	    *basis_scale = minor;
+	    *normal_scale = major;
 	}
     }
 
     return CAIRO_STATUS_SUCCESS;
 }
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-meta-surface.c
--- a/gfx/cairo/cairo/src/cairo-meta-surface.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-meta-surface.c	Mon Sep 08 10:35:45 2008 +0300
@@ -842,18 +842,16 @@ _cairo_meta_surface_replay_internal (cai
 	    break;
 	case CAIRO_COMMAND_STROKE:
 	{
 	    cairo_matrix_t dev_ctm = command->stroke.ctm;
 	    cairo_matrix_t dev_ctm_inverse = command->stroke.ctm_inverse;
-	    cairo_matrix_t tmp;
 
 	    if (has_device_transform) {
 		cairo_matrix_multiply (&dev_ctm, &dev_ctm, device_transform);
-		tmp = surface->device_transform;
-		status = cairo_matrix_invert (&tmp);
-		assert (status == CAIRO_STATUS_SUCCESS);
-		cairo_matrix_multiply (&dev_ctm_inverse, &tmp, &dev_ctm_inverse);
+		cairo_matrix_multiply (&dev_ctm_inverse,
+				       &surface->device_transform_inverse,
+				       &dev_ctm_inverse);
 	    }
 
 	    status = _cairo_surface_stroke (target,
 					    command->stroke.op,
 					    &command->stroke.source.base,
@@ -883,21 +881,19 @@ _cairo_meta_surface_replay_internal (cai
 	    if (stroke_command != NULL &&
 		stroke_command->header.type == CAIRO_COMMAND_STROKE &&
 		_cairo_path_fixed_is_equal (dev_path, _cairo_command_get_path (stroke_command))) {
 		cairo_matrix_t dev_ctm;
 		cairo_matrix_t dev_ctm_inverse;
-		cairo_matrix_t tmp;
 
 		dev_ctm = stroke_command->stroke.ctm;
 		dev_ctm_inverse = stroke_command->stroke.ctm_inverse;
 
 		if (has_device_transform) {
 		    cairo_matrix_multiply (&dev_ctm, &dev_ctm, device_transform);
-		    tmp = surface->device_transform;
-		    status = cairo_matrix_invert (&tmp);
-		    assert (status == CAIRO_STATUS_SUCCESS);
-		    cairo_matrix_multiply (&dev_ctm_inverse, &tmp, &dev_ctm_inverse);
+		    cairo_matrix_multiply (&dev_ctm_inverse,
+					   &surface->device_transform_inverse,
+					   &dev_ctm_inverse);
 		}
 
 		status = _cairo_surface_fill_stroke (target,
 						     command->fill.op,
 						     &command->fill.source.base,
@@ -971,11 +967,10 @@ _cairo_meta_surface_replay_internal (cai
 		status = _cairo_clip_clip (&clip, dev_path,
 					   command->intersect_clip_path.fill_rule,
 					   command->intersect_clip_path.tolerance,
 					   command->intersect_clip_path.antialias,
 					   target);
-            assert (status == 0);
 	    break;
 	default:
 	    ASSERT_NOT_REACHED;
 	}
 
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-misc.c
--- a/gfx/cairo/cairo/src/cairo-misc.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-misc.c	Mon Sep 08 10:35:45 2008 +0300
@@ -1,10 +1,11 @@
 /* -*- Mode: c; c-basic-offset: 4; indent-tabs-mode: t; tab-width: 8; -*- */
 /* cairo - a vector graphics library with display and print output
  *
  * Copyright © 2002 University of Southern California
  * Copyright © 2005 Red Hat, Inc.
+ * Copyright © 2007 Adrian Johnson
  *
  * This library is free software; you can redistribute it and/or
  * modify it either under the terms of the GNU Lesser General Public
  * License version 2.1 as published by the Free Software Foundation
  * (the "LGPL") or, at your option, under the terms of the Mozilla
@@ -32,16 +33,19 @@
  * The Initial Developer of the Original Code is University of Southern
  * California.
  *
  * Contributor(s):
  *	Carl D. Worth <cworth@cworth.org>
+ *      Adrian Johnson <ajohnson@redneon.com>
  */
 
 #include "cairoint.h"
 
 COMPILE_TIME_ASSERT (CAIRO_STATUS_LAST_STATUS < CAIRO_INT_STATUS_UNSUPPORTED);
 COMPILE_TIME_ASSERT (CAIRO_INT_STATUS_LAST_STATUS <= 127);
+
+/* Public stuff */
 
 /**
  * cairo_status_to_string:
  * @status: a cairo status
  *
@@ -111,13 +115,193 @@ cairo_status_to_string (cairo_status_t s
 	return "error occurred in a user-font callback function";
     case CAIRO_STATUS_NEGATIVE_COUNT:
 	return "negative number used where it is not allowed";
     case CAIRO_STATUS_INVALID_CLUSTERS:
 	return "input clusters do not represent the accompanying text and glyph arrays";
+    case CAIRO_STATUS_INVALID_SLANT:
+	return "invalid value for an input #cairo_font_slant_t";
+    case CAIRO_STATUS_INVALID_WEIGHT:
+	return "input value for an input #cairo_font_weight_t";
     }
 
     return "<unknown error status>";
+}
+
+
+/**
+ * cairo_glyph_allocate:
+ * @num_glyphs: number of glyphs to allocate
+ *
+ * Allocates an array of #cairo_glyph_t's.
+ * This function is only useful in implementations of
+ * #cairo_user_scaled_font_text_to_glyphs_func_t where the user
+ * needs to allocate an array of glyphs that cairo will free.
+ * For all other uses, user can use their own allocation method
+ * for glyphs.
+ *
+ * This function returns %NULL if @num_glyphs is not positive,
+ * or if out of memory.  That means, the %NULL return value
+ * signals out-of-memory only if @num_glyphs was positive.
+ *
+ * Returns: the newly allocated array of glyphs that should be
+ *          freed using cairo_glyph_free()
+ *
+ * Since: 1.8
+ */
+cairo_glyph_t *
+cairo_glyph_allocate (int num_glyphs)
+{
+    if (num_glyphs <= 0)
+	return NULL;
+
+    return _cairo_malloc_ab (num_glyphs, sizeof (cairo_glyph_t));
+}
+slim_hidden_def (cairo_glyph_allocate);
+
+/**
+ * cairo_glyph_free:
+ * @glyphs: array of glyphs to free, or %NULL
+ *
+ * Frees an array of #cairo_glyph_t's allocated using cairo_glyph_allocate().
+ * This function is only useful to free glyph array returned
+ * by cairo_scaled_font_text_to_glyphs() where cairo returns
+ * an array of glyphs that the user will free.
+ * For all other uses, user can use their own allocation method
+ * for glyphs.
+ *
+ * Since: 1.8
+ */
+void
+cairo_glyph_free (cairo_glyph_t *glyphs)
+{
+    if (glyphs)
+	free (glyphs);
+}
+slim_hidden_def (cairo_glyph_free);
+
+/**
+ * cairo_text_cluster_allocate:
+ * @num_clusters: number of text_clusters to allocate
+ *
+ * Allocates an array of #cairo_text_cluster_t's.
+ * This function is only useful in implementations of
+ * #cairo_user_scaled_font_text_to_glyphs_func_t where the user
+ * needs to allocate an array of text clusters that cairo will free.
+ * For all other uses, user can use their own allocation method
+ * for text clusters.
+ *
+ * This function returns %NULL if @num_clusters is not positive,
+ * or if out of memory.  That means, the %NULL return value
+ * signals out-of-memory only if @num_clusters was positive.
+ *
+ * Returns: the newly allocated array of text clusters that should be
+ *          freed using cairo_text_cluster_free()
+ *
+ * Since: 1.8
+ */
+cairo_text_cluster_t *
+cairo_text_cluster_allocate (int num_clusters)
+{
+    if (num_clusters <= 0)
+	return NULL;
+
+    return _cairo_malloc_ab (num_clusters, sizeof (cairo_text_cluster_t));
+}
+slim_hidden_def (cairo_text_cluster_allocate);
+
+/**
+ * cairo_text_cluster_free:
+ * @clusters: array of text clusters to free, or %NULL
+ *
+ * Frees an array of #cairo_text_cluster's allocated using cairo_text_cluster_allocate().
+ * This function is only useful to free text cluster array returned
+ * by cairo_scaled_font_text_to_glyphs() where cairo returns
+ * an array of text clusters that the user will free.
+ * For all other uses, user can use their own allocation method
+ * for text clusters.
+ *
+ * Since: 1.8
+ */
+void
+cairo_text_cluster_free (cairo_text_cluster_t *clusters)
+{
+    if (clusters)
+	free (clusters);
+}
+slim_hidden_def (cairo_text_cluster_free);
+
+
+/* Private stuff */
+
+/**
+ * _cairo_validate_text_clusters:
+ * @utf8: UTF-8 text
+ * @utf8_len: length of @utf8 in bytes
+ * @glyphs: array of glyphs
+ * @num_glyphs: number of glyphs
+ * @clusters: array of cluster mapping information
+ * @num_clusters: number of clusters in the mapping
+ * @backward: whether the text to glyphs mapping goes backward
+ *
+ * Check that clusters cover the entire glyphs and utf8 arrays,
+ * and that cluster boundaries are UTF-8 boundaries.
+ *
+ * Return value: %CAIRO_STATUS_SUCCESS upon success, or
+ *               %CAIRO_STATUS_INVALID_CLUSTERS on error.
+ *               The error is either invalid UTF-8 input,
+ *               or bad cluster mapping.
+ */
+cairo_status_t
+_cairo_validate_text_clusters (const char		   *utf8,
+			       int			    utf8_len,
+			       const cairo_glyph_t	   *glyphs,
+			       int			    num_glyphs,
+			       const cairo_text_cluster_t  *clusters,
+			       int			    num_clusters,
+			       cairo_bool_t		    backward)
+{
+    cairo_status_t status;
+    unsigned int n_bytes  = 0;
+    unsigned int n_glyphs = 0;
+    int i;
+
+    for (i = 0; i < num_clusters; i++) {
+	int cluster_bytes  = clusters[i].num_bytes;
+	int cluster_glyphs = clusters[i].num_glyphs;
+
+	if (cluster_bytes < 0 || cluster_glyphs < 0)
+	    goto BAD;
+
+	/* A cluster should cover at least one character or glyph.
+	 * I can't see any use for a 0,0 cluster.
+	 * I can't see an immediate use for a zero-text cluster
+	 * right now either, but they don't harm.
+	 * Zero-glyph clusters on the other hand are useful for
+	 * things like U+200C ZERO WIDTH NON-JOINER */
+	if (cluster_bytes == 0 && cluster_glyphs == 0)
+	    goto BAD;
+
+	/* Since n_bytes and n_glyphs are unsigned, but the rest of
+	 * values involved are signed, we can detect overflow easily */
+	if (n_bytes+cluster_bytes > (unsigned int)utf8_len || n_glyphs+cluster_glyphs > (unsigned int)num_glyphs)
+	    goto BAD;
+
+	/* Make sure we've got valid UTF-8 for the cluster */
+	status = _cairo_utf8_to_ucs4 (utf8+n_bytes, cluster_bytes, NULL, NULL);
+	if (status)
+	    return CAIRO_STATUS_INVALID_CLUSTERS;
+
+	n_bytes  += cluster_bytes ;
+	n_glyphs += cluster_glyphs;
+    }
+
+    if (n_bytes != (unsigned int) utf8_len || n_glyphs != (unsigned int) num_glyphs) {
+      BAD:
+	return CAIRO_STATUS_INVALID_CLUSTERS;
+    }
+
+    return CAIRO_STATUS_SUCCESS;
 }
 
 /**
  * _cairo_operator_bounded_by_mask:
  * @op: a #cairo_operator_t
@@ -415,5 +599,71 @@ _cairo_lround (double d)
 
     return output;
 #undef MSW
 #undef LSW
 }
+
+
+#ifdef _WIN32
+
+#define WIN32_LEAN_AND_MEAN
+/* We require Windows 2000 features such as ETO_PDY */
+#if !defined(WINVER) || (WINVER < 0x0500)
+# define WINVER 0x0500
+#endif
+#if !defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500)
+# define _WIN32_WINNT 0x0500
+#endif
+
+#include <windows.h>
+#include <io.h>
+
+/* tmpfile() replacment for Windows.
+ *
+ * On Windows tmpfile() creates the file in the root directory. This
+ * may fail due to unsufficient privileges.
+ */
+FILE *
+_cairo_win32_tmpfile (void)
+{
+    DWORD path_len;
+    WCHAR path_name[MAX_PATH + 1];
+    WCHAR file_name[MAX_PATH + 1];
+    HANDLE handle;
+    int fd;
+    FILE *fp;
+
+    path_len = GetTempPathW (MAX_PATH, path_name);
+    if (path_len <= 0 || path_len >= MAX_PATH)
+	return NULL;
+
+    if (GetTempFileNameW (path_name, L"ps_", 0, file_name) == 0)
+	return NULL;
+
+    handle = CreateFileW (file_name,
+			 GENERIC_READ | GENERIC_WRITE,
+			 0,
+			 NULL,
+			 CREATE_ALWAYS,
+			 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE,
+			 NULL);
+    if (handle == INVALID_HANDLE_VALUE) {
+	DeleteFileW (file_name);
+	return NULL;
+    }
+
+    fd = _open_osfhandle((intptr_t) handle, 0);
+    if (fd < 0) {
+	CloseHandle (handle);
+	return NULL;
+    }
+
+    fp = fdopen(fd, "w+b");
+    if (fp == NULL) {
+	_close(fd);
+	return NULL;
+    }
+
+    return fp;
+}
+
+#endif /* _WIN32 */
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-mutex-impl-private.h
--- a/gfx/cairo/cairo/src/cairo-mutex-impl-private.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-mutex-impl-private.h	Mon Sep 08 10:35:45 2008 +0300
@@ -42,14 +42,10 @@
 #define CAIRO_MUTEX_IMPL_PRIVATE_H
 
 #if HAVE_CONFIG_H
 #include "config.h"
 #endif
-
-#include "cairo-features.h"
-
-CAIRO_BEGIN_DECLS
 
 
 /* A fully qualified no-operation statement */
 #define CAIRO_MUTEX_IMPL_NOOP	do {/*no-op*/} while (0)
 /* And one that evaluates it's argument once */
@@ -219,8 +215,6 @@ CAIRO_BEGIN_DECLS
 # error "XXX: No mutex implementation found.  Cairo will not work with multiple threads.  Define CAIRO_NO_MUTEX to 1 to acknowledge and accept this limitation and compile cairo without thread-safety support."
 
 
 #endif
 
-CAIRO_END_DECLS
-
 #endif
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-mutex-private.h
--- a/gfx/cairo/cairo/src/cairo-mutex-private.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-mutex-private.h	Mon Sep 08 10:35:45 2008 +0300
@@ -39,10 +39,14 @@
  */
 
 #ifndef CAIRO_MUTEX_PRIVATE_H
 #define CAIRO_MUTEX_PRIVATE_H
 
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
 #include "cairo-mutex-type-private.h"
 
 CAIRO_BEGIN_DECLS
 
 #if _CAIRO_MUTEX_IMPL_USE_STATIC_INITIALIZER
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-mutex-type-private.h
--- a/gfx/cairo/cairo/src/cairo-mutex-type-private.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-mutex-type-private.h	Mon Sep 08 10:35:45 2008 +0300
@@ -39,16 +39,10 @@
  */
 
 #ifndef CAIRO_MUTEX_TYPE_PRIVATE_H
 #define CAIRO_MUTEX_TYPE_PRIVATE_H
 
-#if HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include "cairo-features.h"
-
 #include "cairo-compiler-private.h"
 #include "cairo-mutex-impl-private.h"
 
 /* Only the following three are mandatory at this point */
 #ifndef CAIRO_MUTEX_IMPL_LOCK
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-no-features.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/cairo/cairo/src/cairo-no-features.h	Mon Sep 08 10:35:45 2008 +0300
@@ -0,0 +1,12 @@
+/* Generated by configure.  Do not edit */
+#ifndef CAIRO_NO_FEATURES_H
+#define CAIRO_NO_FEATURES_H
+
+#include <cairo-features.h>
+
+/* This is a dummy header, to trick gtk-doc only */
+
+#define CAIRO_HAS_WIN32_FONT 1
+#define CAIRO_HAS_WIN32_SURFACE 1
+
+#endif
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-output-stream-private.h
--- a/gfx/cairo/cairo/src/cairo-output-stream-private.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-output-stream-private.h	Mon Sep 08 10:35:45 2008 +0300
@@ -37,10 +37,14 @@
 #define CAIRO_OUTPUT_STREAM_PRIVATE_H
 
 #include "cairo-compiler-private.h"
 #include "cairo-types-private.h"
 
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdarg.h>
+
 typedef cairo_status_t (*cairo_output_stream_write_func_t) (cairo_output_stream_t *output_stream,
 							    const unsigned char   *data,
 							    unsigned int           length);
 
 typedef cairo_status_t (*cairo_output_stream_close_func_t) (cairo_output_stream_t *output_stream);
@@ -105,11 +109,11 @@ _cairo_output_stream_write (cairo_output
 _cairo_output_stream_write (cairo_output_stream_t *stream,
 			    const void *data, size_t length);
 
 cairo_private void
 _cairo_output_stream_write_hex_string (cairo_output_stream_t *stream,
-				       const char *data,
+				       const unsigned char *data,
 				       size_t length);
 
 cairo_private void
 _cairo_output_stream_vprintf (cairo_output_stream_t *stream,
 			      const char *fmt,
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-output-stream.c
--- a/gfx/cairo/cairo/src/cairo-output-stream.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-output-stream.c	Mon Sep 08 10:35:45 2008 +0300
@@ -235,11 +235,11 @@ _cairo_output_stream_write (cairo_output
     stream->position += length;
 }
 
 void
 _cairo_output_stream_write_hex_string (cairo_output_stream_t *stream,
-				       const char *data,
+				       const unsigned char *data,
 				       size_t length)
 {
     const char hex_chars[] = "0123456789abcdef";
     char buffer[2];
     unsigned int i, column;
@@ -421,11 +421,10 @@ _cairo_output_stream_vprintf (cairo_outp
 	memcpy (single_fmt, start, single_fmt_length);
 	single_fmt[single_fmt_length] = '\0';
 
 	/* Flush contents of buffer before snprintf()'ing into it. */
 	_cairo_output_stream_write (stream, buffer, p - buffer);
-	p = buffer;
 
 	/* We group signed and unsigned together in this switch, the
 	 * only thing that matters here is the size of the arguments,
 	 * since we're just passing the data through to sprintf(). */
 	switch (*f | length_modifier) {
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-paginated-surface.c
--- a/gfx/cairo/cairo/src/cairo-paginated-surface.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-paginated-surface.c	Mon Sep 08 10:35:45 2008 +0300
@@ -607,11 +607,11 @@ static cairo_bool_t
 static cairo_bool_t
 _cairo_paginated_surface_has_show_text_glyphs (void *abstract_surface)
 {
     cairo_paginated_surface_t *surface = abstract_surface;
 
-    return _cairo_surface_has_show_text_glyphs (surface->target);
+    return cairo_surface_has_show_text_glyphs (surface->target);
 }
 
 static cairo_int_status_t
 _cairo_paginated_surface_show_text_glyphs (void			    *abstract_surface,
 					  cairo_operator_t	     op,
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-path-fixed-private.h
--- a/gfx/cairo/cairo/src/cairo-path-fixed-private.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-path-fixed-private.h	Mon Sep 08 10:35:45 2008 +0300
@@ -33,10 +33,12 @@
  *	Carl D. Worth <cworth@redhat.com>
  */
 
 #ifndef CAIRO_PATH_FIXED_PRIVATE_H
 #define CAIRO_PATH_FIXED_PRIVATE_H
+
+#include "cairo-types-private.h"
 
 enum cairo_path_op {
     CAIRO_PATH_OP_MOVE_TO = 0,
     CAIRO_PATH_OP_LINE_TO = 1,
     CAIRO_PATH_OP_CURVE_TO = 2,
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-path-stroke.c
--- a/gfx/cairo/cairo/src/cairo-path-stroke.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-path-stroke.c	Mon Sep 08 10:35:45 2008 +0300
@@ -167,15 +167,12 @@ _cairo_stroker_init (cairo_stroker_t		*s
     stroker->ctm = ctm;
     stroker->ctm_inverse = ctm_inverse;
     stroker->tolerance = tolerance;
     stroker->traps = traps;
 
-    _cairo_matrix_compute_determinant (stroker->ctm, &stroker->ctm_determinant);
-    if (stroker->ctm_determinant >= 0.0)
-	stroker->ctm_det_positive = TRUE;
-    else
-	stroker->ctm_det_positive = FALSE;
+    stroker->ctm_determinant = _cairo_matrix_compute_determinant (stroker->ctm);
+    stroker->ctm_det_positive = stroker->ctm_determinant >= 0.0;
 
     status = _cairo_pen_init (&stroker->pen,
 		              stroke_style->line_width / 2.0,
 			      tolerance, ctm);
     if (status)
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-pattern.c
--- a/gfx/cairo/cairo/src/cairo-pattern.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-pattern.c	Mon Sep 08 10:35:45 2008 +0300
@@ -93,12 +93,15 @@ _cairo_pattern_set_error (cairo_pattern_
 
 static void
 _cairo_pattern_init (cairo_pattern_t *pattern, cairo_pattern_type_t type)
 {
     pattern->type      = type;
-    CAIRO_REFERENCE_COUNT_INIT (&pattern->ref_count, 1);
     pattern->status    = CAIRO_STATUS_SUCCESS;
+
+    /* Set the reference count to zero for on-stack patterns.
+     * Callers needs to explicitly increment the count for heap allocations. */
+    CAIRO_REFERENCE_COUNT_INIT (&pattern->ref_count, 0);
 
     _cairo_user_data_array_init (&pattern->user_data);
 
     if (type == CAIRO_PATTERN_TYPE_SURFACE)
 	pattern->extend = CAIRO_EXTEND_SURFACE_DEFAULT;
@@ -181,11 +184,11 @@ _cairo_pattern_init_copy (cairo_pattern_
 
     } break;
     }
 
     /* The reference count and user_data array are unique to the copy. */
-    CAIRO_REFERENCE_COUNT_INIT (&pattern->ref_count, 1);
+    CAIRO_REFERENCE_COUNT_INIT (&pattern->ref_count, 0);
     _cairo_user_data_array_init (&pattern->user_data);
 
     return CAIRO_STATUS_SUCCESS;
 }
 
@@ -243,10 +246,12 @@ _cairo_pattern_create_copy (cairo_patter
     status = _cairo_pattern_init_copy (*pattern, other);
     if (status) {
 	free (*pattern);
 	return status;
     }
+
+    CAIRO_REFERENCE_COUNT_INIT (&(*pattern)->ref_count, 1);
 
     return CAIRO_STATUS_SUCCESS;
 }
 
 
@@ -348,12 +353,14 @@ _cairo_pattern_create_solid (const cairo
     }
 
     if (pattern == NULL) {
 	_cairo_error_throw (CAIRO_STATUS_NO_MEMORY);
 	pattern = (cairo_solid_pattern_t *) &_cairo_pattern_nil;
-    } else
+    } else {
 	_cairo_pattern_init_solid (pattern, color, content);
+	CAIRO_REFERENCE_COUNT_INIT (&pattern->base.ref_count, 1);
+    }
 
     return &pattern->base;
 }
 
 static void
@@ -502,10 +509,11 @@ cairo_pattern_create_for_surface (cairo_
     }
 
     CAIRO_MUTEX_INITIALIZE ();
 
     _cairo_pattern_init_for_surface (pattern, surface);
+    CAIRO_REFERENCE_COUNT_INIT (&pattern->base.ref_count, 1);
 
     return &pattern->base;
 }
 slim_hidden_def (cairo_pattern_create_for_surface);
 
@@ -547,10 +555,11 @@ cairo_pattern_create_linear (double x0, 
     }
 
     CAIRO_MUTEX_INITIALIZE ();
 
     _cairo_pattern_init_linear (pattern, x0, y0, x1, y1);
+    CAIRO_REFERENCE_COUNT_INIT (&pattern->base.base.ref_count, 1);
 
     return &pattern->base.base;
 }
 
 /**
@@ -594,10 +603,11 @@ cairo_pattern_create_radial (double cx0,
     }
 
     CAIRO_MUTEX_INITIALIZE ();
 
     _cairo_pattern_init_radial (pattern, cx0, cy0, radius0, cx1, cy1, radius1);
+    CAIRO_REFERENCE_COUNT_INIT (&pattern->base.base.ref_count, 1);
 
     return &pattern->base.base;
 }
 
 /**
@@ -1306,18 +1316,23 @@ _cairo_pattern_acquire_surface_for_gradi
 	    width = 8;
 	    repeat = TRUE;
 	}
     }
 
+    if (! pixman_image_set_filter (pixman_image, PIXMAN_FILTER_BILINEAR,
+				   NULL, 0))
+    {
+	pixman_image_unref (pixman_image);
+	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+    }
+
     image = (cairo_image_surface_t *)
 	cairo_image_surface_create (CAIRO_FORMAT_ARGB32, width, height);
     if (image->base.status) {
 	pixman_image_unref (pixman_image);
 	return image->base.status;
     }
-
-    pixman_image_set_filter (pixman_image, PIXMAN_FILTER_BILINEAR, NULL, 0);
 
     _cairo_matrix_to_pixman_matrix (&pattern->base.matrix, &pixman_transform);
     if (!pixman_image_set_transform (pixman_image, &pixman_transform)) {
 	cairo_surface_destroy (&image->base);
 	pixman_image_unref (pixman_image);
@@ -2076,14 +2091,15 @@ _cairo_pattern_get_extents (cairo_patter
     /* XXX: We could optimize gradients with pattern->extend of NONE
      * here in some cases, (eg. radial gradients and 1 axis of
      * horizontal/vertical linear gradients).
      */
 
+    /* unbounded patterns -> 'infinite' extents */
     extents->x = CAIRO_RECT_INT_MIN;
     extents->y = CAIRO_RECT_INT_MIN;
-    extents->width = CAIRO_RECT_INT_MIN + CAIRO_RECT_INT_MAX;
-    extents->height = CAIRO_RECT_INT_MIN + CAIRO_RECT_INT_MAX;
+    extents->width = CAIRO_RECT_INT_MAX - CAIRO_RECT_INT_MIN;
+    extents->height = CAIRO_RECT_INT_MAX - CAIRO_RECT_INT_MIN;
 
     return CAIRO_STATUS_SUCCESS;
 }
 
 /**
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-pdf-operators-private.h
--- a/gfx/cairo/cairo/src/cairo-pdf-operators-private.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-pdf-operators-private.h	Mon Sep 08 10:35:45 2008 +0300
@@ -160,7 +160,6 @@ _cairo_pdf_operators_show_text_glyphs (c
 				       const cairo_text_cluster_t *clusters,
 				       int                         num_clusters,
 				       cairo_bool_t                backward,
 				       cairo_scaled_font_t	  *scaled_font);
 
-
 #endif /* CAIRO_PDF_OPERATORS_H */
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-pdf-operators.c
--- a/gfx/cairo/cairo/src/cairo-pdf-operators.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-pdf-operators.c	Mon Sep 08 10:35:45 2008 +0300
@@ -38,10 +38,13 @@
  *	Carl Worth <cworth@cworth.org>
  *	Adrian Johnson <ajohnson@redneon.com>
  */
 
 #include "cairoint.h"
+
+#if CAIRO_HAS_PDF_OPERATORS
+
 #include "cairo-pdf-operators-private.h"
 #include "cairo-path-fixed-private.h"
 #include "cairo-output-stream-private.h"
 #include "cairo-scaled-font-subsets-private.h"
 
@@ -681,19 +684,22 @@ _cairo_pdf_operators_emit_stroke (cairo_
 _cairo_pdf_operators_emit_stroke (cairo_pdf_operators_t	*pdf_operators,
 				  cairo_path_fixed_t	*path,
 				  cairo_stroke_style_t	*style,
 				  cairo_matrix_t	*ctm,
 				  cairo_matrix_t	*ctm_inverse,
-				  const char 		*pdf_operator)
+				  const char		*pdf_operator)
 {
     cairo_status_t status;
     cairo_matrix_t m, path_transform;
     cairo_bool_t has_ctm = TRUE;
     double scale = 1.0;
 
-    if (pdf_operators->in_text_object)
+    if (pdf_operators->in_text_object) {
 	status = _cairo_pdf_operators_end_text (pdf_operators);
+	if (status)
+	    return status;
+    }
 
     /* Optimize away the stroke ctm when it does not affect the
      * stroke. There are other ctm cases that could be optimized
      * however this is the most common.
      */
@@ -786,12 +792,15 @@ _cairo_pdf_operators_fill (cairo_pdf_ope
 			   cairo_fill_rule_t		fill_rule)
 {
     const char *pdf_operator;
     cairo_status_t status;
 
-    if (pdf_operators->in_text_object)
+    if (pdf_operators->in_text_object) {
 	status = _cairo_pdf_operators_end_text (pdf_operators);
+	if (status)
+	    return status;
+    }
 
     status = _cairo_pdf_operators_emit_path (pdf_operators,
 					     path,
 					     &pdf_operators->cairo_to_pdf,
 					     CAIRO_LINE_CAP_ROUND);
@@ -925,16 +934,16 @@ _cairo_pdf_operators_emit_glyph_string_w
 
 static cairo_status_t
 _cairo_pdf_operators_flush_glyphs (cairo_pdf_operators_t    *pdf_operators)
 {
     cairo_output_stream_t *word_wrap_stream;
-    cairo_status_t status;
+    cairo_status_t status, status2;
     int i;
     double x;
 
     if (pdf_operators->num_glyphs == 0)
-	return 0;
+	return CAIRO_STATUS_SUCCESS;
 
     word_wrap_stream = _word_wrap_stream_create (pdf_operators->stream, 72);
     status = _cairo_output_stream_get_status (word_wrap_stream);
     if (status)
 	return _cairo_output_stream_destroy (word_wrap_stream);
@@ -953,13 +962,13 @@ _cairo_pdf_operators_flush_glyphs (cairo
 	status = _cairo_pdf_operators_emit_glyph_string_with_positioning (
 	    pdf_operators, word_wrap_stream);
     }
 
     pdf_operators->num_glyphs = 0;
-    status = _cairo_output_stream_destroy (word_wrap_stream);
-    if (status)
-	return status;
+    status2 = _cairo_output_stream_destroy (word_wrap_stream);
+    if (status == CAIRO_STATUS_SUCCESS)
+	status = status2;
 
     return status;
 }
 
 static cairo_status_t
@@ -1264,33 +1273,41 @@ _cairo_pdf_operators_emit_cluster (cairo
     if (num_glyphs == 1 && utf8_len != 0) {
 	status = _cairo_scaled_font_subsets_map_glyph (pdf_operators->font_subsets,
 						       scaled_font,
 						       glyphs->index,
 						       utf8,
-						       utf8_len < 0 ? 0 : utf8_len,
+						       utf8_len,
 						       &subset_glyph);
 	if (status)
 	    return status;
 
 	if (subset_glyph.utf8_is_mapped || utf8_len < 0) {
 	    status = _cairo_pdf_operators_emit_glyph (pdf_operators,
 						      glyphs,
 						      &subset_glyph);
-	    return 0;
+	    if (status)
+		return status;
+
+	    return CAIRO_STATUS_SUCCESS;
 	}
     }
 
     /* Fallback to using ActualText to map zero or more glyphs to a
      * unicode string. */
     _cairo_pdf_operators_flush_glyphs (pdf_operators);
     status = _cairo_pdf_operators_begin_actualtext (pdf_operators, utf8, utf8_len);
+    if (status)
+	return status;
+
     cur_glyph = glyphs;
+    /* XXX
+     * If no glyphs, we should put *something* here for the text to be selectable. */
     for (i = 0; i < num_glyphs; i++) {
 	status = _cairo_scaled_font_subsets_map_glyph (pdf_operators->font_subsets,
 						       scaled_font,
 						       cur_glyph->index,
-						       NULL, 0,
+						       NULL, -1,
 						       &subset_glyph);
 	if (status)
 	    return status;
 
 	status = _cairo_pdf_operators_emit_glyph (pdf_operators,
@@ -1409,5 +1426,7 @@ _cairo_pdf_operators_show_text_glyphs (c
 	}
     }
 
     return _cairo_output_stream_get_status (pdf_operators->stream);
 }
+
+#endif /* CAIRO_HAS_PDF_OPERATORS */
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-pdf-surface.c
--- a/gfx/cairo/cairo/src/cairo-pdf-surface.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-pdf-surface.c	Mon Sep 08 10:35:45 2008 +0300
@@ -2866,11 +2866,11 @@ _cairo_pdf_surface_emit_unicode_for_glyp
     cairo_status_t status;
     int i;
 
     if (utf8 && *utf8) {
 	status = _cairo_utf8_to_utf16 (utf8, -1, &utf16, &utf16_len);
-	if (status && status != CAIRO_STATUS_INVALID_STRING)
+	if (status)
 	    return status;
     }
 
     _cairo_output_stream_printf (surface->output, "<");
     if (utf16 == NULL || utf16_len == 0) {
@@ -3442,11 +3442,11 @@ _cairo_pdf_surface_emit_truetype_font_su
 
 static cairo_status_t
 _cairo_pdf_emit_imagemask (cairo_image_surface_t *image,
 			     cairo_output_stream_t *stream)
 {
-    unsigned char *byte, output_byte;
+    uint8_t *byte, output_byte;
     int row, col, num_cols;
 
     /* The only image type supported by Type 3 fonts are 1-bit image
      * masks */
     assert (image->format == CAIRO_FORMAT_A1);
@@ -3485,11 +3485,10 @@ _cairo_pdf_surface_emit_type3_font_subse
 					   cairo_scaled_font_subset_t	*font_subset)
 {
     cairo_status_t status = CAIRO_STATUS_SUCCESS;
     cairo_pdf_resource_t *glyphs, encoding, char_procs, subset_resource, to_unicode_stream;
     cairo_pdf_font_t font;
-    cairo_matrix_t matrix;
     double *widths;
     unsigned int i;
     cairo_box_t font_bbox = {{0,0},{0,0}};
     cairo_box_t bbox = {{0,0},{0,0}};
     cairo_surface_t *type3_surface;
@@ -3520,10 +3519,13 @@ _cairo_pdf_surface_emit_type3_font_subse
     for (i = 0; i < font_subset->num_glyphs; i++) {
 	status = _cairo_pdf_surface_open_stream (surface,
 						 NULL,
 						 surface->compress_content,
 						 NULL);
+	if (status)
+	    break;
+
 	glyphs[i] = surface->pdf_stream.self;
 	if (i == 0) {
 	    status = _cairo_type3_glyph_surface_emit_notdef_glyph (type3_surface,
 								   surface->output,
 								   &bbox,
@@ -3533,10 +3535,13 @@ _cairo_pdf_surface_emit_type3_font_subse
 							    surface->output,
 							    font_subset->glyphs[i],
 							    &bbox,
 							    &widths[i]);
 	}
+	if (status)
+	    break;
+
 	status = _cairo_pdf_surface_close_stream (surface);
 	if (status)
 	    break;
 
         if (i == 0) {
@@ -3608,11 +3613,10 @@ _cairo_pdf_surface_emit_type3_font_subse
 	free (widths);
 	return status;
     }
 
     _cairo_pdf_surface_update_object (surface, subset_resource);
-    matrix = font_subset->scaled_font->scale_inverse;
     _cairo_output_stream_printf (surface->output,
 				 "%d 0 obj\n"
 				 "<< /Type /Font\n"
 				 "   /Subtype /Type3\n"
 				 "   /FontBBox [%f %f %f %f]\n"
@@ -4781,12 +4785,12 @@ _cairo_pdf_surface_show_text_glyphs (voi
 	group->operation = PDF_SHOW_GLYPHS;
 	group->source = cairo_pattern_reference (source);
 	group->source_res = pattern_res;
 
 	if (utf8_len) {
-	    group->utf8 = malloc(utf8_len);
-	    if (group->utf8) {
+	    group->utf8 = malloc (utf8_len);
+	    if (group->utf8 == NULL) {
 		_cairo_pdf_smask_group_destroy (group);
 		return _cairo_error (CAIRO_STATUS_NO_MEMORY);
 	    }
 	    memcpy (group->utf8, utf8, utf8_len);
 	}
@@ -4802,11 +4806,11 @@ _cairo_pdf_surface_show_text_glyphs (voi
 	}
 	group->num_glyphs = num_glyphs;
 
 	if (num_clusters) {
 	    group->clusters = _cairo_malloc_ab (num_clusters, sizeof (cairo_text_cluster_t));
-	    if (group->clusters) {
+	    if (group->clusters == NULL) {
 		_cairo_pdf_smask_group_destroy (group);
 		return _cairo_error (CAIRO_STATUS_NO_MEMORY);
 	    }
 	    memcpy (group->clusters, clusters, sizeof (cairo_text_cluster_t) * num_clusters);
 	}
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-pen.c
--- a/gfx/cairo/cairo/src/cairo-pen.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-pen.c	Mon Sep 08 10:35:45 2008 +0300
@@ -51,21 +51,15 @@ _cairo_pen_init (cairo_pen_t	*pen,
 		 double		 tolerance,
 		 cairo_matrix_t	*ctm)
 {
     int i;
     int reflect;
-    double  det;
 
     pen->radius = radius;
     pen->tolerance = tolerance;
 
-    _cairo_matrix_compute_determinant (ctm, &det);
-    if (det >= 0) {
-	reflect = 0;
-    } else {
-	reflect = 1;
-    }
+    reflect = _cairo_matrix_compute_determinant (ctm) < 0.;
 
     pen->num_vertices = _cairo_pen_vertices_needed (tolerance,
 						    radius,
 						    ctm);
 
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-png.c
--- a/gfx/cairo/cairo/src/cairo-png.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-png.c	Mon Sep 08 10:35:45 2008 +0300
@@ -117,10 +117,17 @@ png_simple_warning_callback (png_structp
 
     /* png does not expect to abort and will try to tidy up after a warning */
 }
 
 
+/* Starting with libpng-1.2.30, we must explicitly specify an output_flush_fn.
+ * Otherwise, we will segfault if we are writing to a stream. */
+static void
+png_simple_output_flush_fn (png_structp png_ptr)
+{
+}
+
 static cairo_status_t
 write_png (cairo_surface_t	*surface,
 	   png_rw_ptr		write_func,
 	   void			*closure)
 {
@@ -128,11 +135,10 @@ write_png (cairo_surface_t	*surface,
     cairo_status_t status;
     cairo_image_surface_t *image;
     void *image_extra;
     png_struct *png;
     png_info *info;
-    png_time pt;
     png_byte **volatile rows = NULL;
     png_color_16 white;
     int png_color_type;
     int depth;
 
@@ -177,11 +183,11 @@ write_png (cairo_surface_t	*surface,
 #ifdef PNG_SETJMP_SUPPORTED
     if (setjmp (png_jmpbuf (png)))
 	goto BAIL3;
 #endif
 
-    png_set_write_fn (png, closure, write_func, NULL);
+    png_set_write_fn (png, closure, write_func, png_simple_output_flush_fn);
 
     switch (image->format) {
     case CAIRO_FORMAT_ARGB32:
 	depth = 8;
 	png_color_type = PNG_COLOR_TYPE_RGB_ALPHA;
@@ -216,12 +222,16 @@ write_png (cairo_surface_t	*surface,
 
     white.gray = (1 << depth) - 1;
     white.red = white.blue = white.green = white.gray;
     png_set_bKGD (png, info, &white);
 
-    png_convert_from_time_t (&pt, time (NULL));
-    png_set_tIME (png, info, &pt);
+    if (0) { /* XXX extract meta-data from surface (i.e. creation date) */
+	png_time pt;
+
+	png_convert_from_time_t (&pt, time (NULL));
+	png_set_tIME (png, info, &pt);
+    }
 
     /* We have to call png_write_info() before setting up the write
      * transformation, since it stores data internally in 'png'
      * that is needed for the write transformation functions to work.
      */
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-ps-surface-private.h
--- a/gfx/cairo/cairo/src/cairo-ps-surface-private.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-ps-surface-private.h	Mon Sep 08 10:35:45 2008 +0300
@@ -44,10 +44,12 @@
 #include "cairo-ps.h"
 
 #include "cairo-surface-private.h"
 #include "cairo-pdf-operators-private.h"
 
+#include <time.h>
+
 typedef struct cairo_ps_surface {
     cairo_surface_t base;
 
     /* Here final_stream corresponds to the stream/file passed to
      * cairo_ps_surface_create surface is built. Meanwhile stream is a
@@ -78,10 +80,12 @@ typedef struct cairo_ps_surface {
     int num_pages;
 
     cairo_paginated_mode_t paginated_mode;
 
     cairo_bool_t force_fallbacks;
+    cairo_bool_t has_creation_date;
+    time_t creation_date;
 
     cairo_scaled_font_subsets_t *font_subsets;
 
     cairo_array_t dsc_header_comments;
     cairo_array_t dsc_setup_comments;
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-ps-surface.c
--- a/gfx/cairo/cairo/src/cairo-ps-surface.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-ps-surface.c	Mon Sep 08 10:35:45 2008 +0300
@@ -88,11 +88,14 @@ _cairo_ps_surface_emit_header (cairo_ps_
     char **comments;
     int i, num_comments;
     int level;
     const char *eps_header = "";
 
-    now = time (NULL);
+    if (surface->has_creation_date)
+	now = surface->creation_date;
+    else
+	now = time (NULL);
 
     if (surface->ps_level_used == CAIRO_PS_LEVEL_2)
 	level = 2;
     else
 	level = 3;
@@ -362,11 +365,11 @@ _cairo_ps_surface_emit_truetype_font_sub
         _cairo_output_stream_printf (surface->final_stream,"<");
         _cairo_output_stream_write_hex_string (surface->final_stream,
                                                subset.data + begin, end - begin);
         _cairo_output_stream_printf (surface->final_stream,"00>\n");
         begin = end;
-    } 
+    }
     if (subset.data_length > end) {
         _cairo_output_stream_printf (surface->final_stream,"<");
         _cairo_output_stream_write_hex_string (surface->final_stream,
                                                subset.data + end, subset.data_length - end);
         _cairo_output_stream_printf (surface->final_stream,"00>\n");
@@ -383,11 +386,11 @@ _cairo_ps_surface_emit_truetype_font_sub
 
 static cairo_status_t
 _cairo_ps_emit_imagemask (cairo_image_surface_t *image,
 			  cairo_output_stream_t *stream)
 {
-    unsigned char *row, *byte;
+    uint8_t *row, *byte;
     int rows, cols;
 
     /* The only image type supported by Type 3 fonts are 1-bit image
      * masks */
     assert (image->format == CAIRO_FORMAT_A1);
@@ -405,22 +408,19 @@ _cairo_ps_emit_imagemask (cairo_image_su
 				 image->width,
 				 -image->height,
 				 image->height);
 
     _cairo_output_stream_printf (stream,
-				 "   /DataSource   {<");
+				 "   /DataSource {<\n   ");
     for (row = image->data, rows = image->height; rows; row += image->stride, rows--) {
 	for (byte = row, cols = (image->width + 7) / 8; cols; byte++, cols--) {
-	    unsigned char output_byte = CAIRO_BITSWAP8_IF_LITTLE_ENDIAN (*byte);
+	    uint8_t output_byte = CAIRO_BITSWAP8_IF_LITTLE_ENDIAN (*byte);
 	    _cairo_output_stream_printf (stream, "%02x ", output_byte);
 	}
 	_cairo_output_stream_printf (stream, "\n   ");
     }
-    _cairo_output_stream_printf (stream,
-				 "   >}\n");
-    _cairo_output_stream_printf (stream,
-				 ">>\n");
+    _cairo_output_stream_printf (stream, ">}\n>>\n");
 
     _cairo_output_stream_printf (stream,
 				 "imagemask\n");
 
     return _cairo_output_stream_get_status (stream);
@@ -431,11 +431,10 @@ _cairo_ps_surface_emit_type3_font_subset
 					  cairo_scaled_font_subset_t	*font_subset)
 
 
 {
     cairo_status_t status;
-    cairo_matrix_t matrix;
     unsigned int i;
     cairo_box_t font_bbox = {{0,0},{0,0}};
     cairo_box_t bbox = {{0,0},{0,0}};
     cairo_surface_t *type3_surface;
     double width;
@@ -443,11 +442,10 @@ _cairo_ps_surface_emit_type3_font_subset
 #if DEBUG_PS
     _cairo_output_stream_printf (surface->final_stream,
 				 "%% _cairo_ps_surface_emit_type3_font_subset\n");
 #endif
 
-    matrix = font_subset->scaled_font->scale_inverse;
     _cairo_output_stream_printf (surface->final_stream,
 				 "8 dict begin\n"
 				 "/FontType 3 def\n"
 				 "/FontMatrix [1 0 0 1 0 0] def\n"
 				 "/Encoding 256 array def\n"
@@ -616,10 +614,13 @@ _cairo_ps_surface_emit_body (cairo_ps_su
 
     rewind (surface->tmpfile);
     while ((n = fread (buf, 1, sizeof (buf), surface->tmpfile)) > 0)
 	_cairo_output_stream_write (surface->final_stream, buf, n);
 
+    if (ferror (surface->tmpfile) != 0)
+	return _cairo_error (CAIRO_STATUS_TEMP_FILE_ERROR);
+
     return CAIRO_STATUS_SUCCESS;
 }
 
 static void
 _cairo_ps_surface_emit_footer (cairo_ps_surface_t *surface)
@@ -679,10 +680,11 @@ _cairo_ps_surface_create_for_stream_inte
     if (surface->font_subsets == NULL) {
 	status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
 	goto CLEANUP_OUTPUT_STREAM;
     }
 
+    surface->has_creation_date = FALSE;
     surface->eps = FALSE;
     surface->ps_level = CAIRO_PS_LEVEL_3;
     surface->ps_level_used = CAIRO_PS_LEVEL_2;
     surface->width  = width;
     surface->height = height;
@@ -1583,11 +1585,14 @@ _string_array_stream_write (cairo_output
 	/* Have to be careful to never split the final ~> sequence. */
         if (c == '~') {
 	    _cairo_output_stream_write (stream->output, &c, 1);
 	    stream->column++;
 	    stream->string_size++;
-	    length--;
+
+	    if (length-- == 0)
+		break;
+
 	    c = *data++;
 	}
 	_cairo_output_stream_write (stream->output, &c, 1);
 	stream->column++;
 	stream->string_size++;
@@ -2229,15 +2234,17 @@ _cairo_ps_surface_paint_surface (cairo_p
     ps_p2d = surface->cairo_to_ps;
     cairo_matrix_multiply (&ps_p2d, &cairo_p2d, &ps_p2d);
     cairo_matrix_translate (&ps_p2d, 0.0, height);
     cairo_matrix_scale (&ps_p2d, 1.0, -1.0);
 
-    _cairo_output_stream_printf (surface->stream,
-				 "[ %f %f %f %f %f %f ] concat\n",
-				 ps_p2d.xx, ps_p2d.yx,
-				 ps_p2d.xy, ps_p2d.yy,
-				 ps_p2d.x0, ps_p2d.y0);
+    if (! _cairo_matrix_is_identity (&ps_p2d)) {
+	_cairo_output_stream_printf (surface->stream,
+				     "[ %f %f %f %f %f %f ] concat\n",
+				     ps_p2d.xx, ps_p2d.yx,
+				     ps_p2d.xy, ps_p2d.yy,
+				     ps_p2d.x0, ps_p2d.y0);
+    }
 
     status = _cairo_ps_surface_emit_surface (surface, pattern, op);
     _cairo_ps_surface_release_surface (surface, pattern);
 
     return status;
@@ -2703,21 +2710,21 @@ _cairo_ps_surface_emit_linear_pattern (c
 				 "<< /PatternType 2\n"
 				 "   /Shading\n"
 				 "   << /ShadingType 2\n"
 				 "      /ColorSpace /DeviceRGB\n"
 				 "      /Coords [ %f %f %f %f ]\n"
-                                 "      /Domain [ %f %f ]\r\n"
+                                 "      /Domain [ %f %f ]\n"
 				 "      /Function CairoFunction\n",
 				 x1, y1, x2, y2,
 				 first_stop, last_stop);
 
     if (extend == CAIRO_EXTEND_PAD) {
 	_cairo_output_stream_printf (surface->stream,
-                                     "      /Extend [ true true ]\r\n");
+                                     "      /Extend [ true true ]\n");
     } else {
 	_cairo_output_stream_printf (surface->stream,
-                                     "      /Extend [ false false ]\r\n");
+                                     "      /Extend [ false false ]\n");
     }
 
     _cairo_output_stream_printf (surface->stream,
 				 "   >>\n"
 				 ">>\n");
@@ -2785,14 +2792,14 @@ _cairo_ps_surface_emit_radial_pattern (c
 				 "      /Function CairoFunction\n",
 				 x1, y1, r1, x2, y2, r2);
 
     if (extend == CAIRO_EXTEND_PAD) {
 	_cairo_output_stream_printf (surface->stream,
-                                     "      /Extend [ true true ]\r\n");
+                                     "      /Extend [ true true ]\n");
     } else {
 	_cairo_output_stream_printf (surface->stream,
-                                     "      /Extend [ false false ]\r\n");
+                                     "      /Extend [ false false ]\n");
     }
 
     _cairo_output_stream_printf (surface->stream,
 				 "   >>\n"
 				 ">>\n");
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-quartz-font.c
--- a/gfx/cairo/cairo/src/cairo-quartz-font.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-quartz-font.c	Mon Sep 08 10:35:45 2008 +0300
@@ -388,11 +388,11 @@ _cairo_matrix_to_unit_quartz_matrix (con
 {
     CGAffineTransform transform;
     double xscale, yscale;
     cairo_status_t status;
 
-    status = _cairo_matrix_compute_scale_factors (m, &xscale, &yscale, 1);
+    status = _cairo_matrix_compute_basis_scale_factors (m, &xscale, &yscale, 1);
     if (status)
 	return status;
 
     transform = CGAffineTransformMake (m->xx, - m->yx,
 				       - m->xy, m->yy,
@@ -433,11 +433,11 @@ _cairo_quartz_init_glyph_metrics (cairo_
 
     if (!CGFontGetGlyphAdvancesPtr (font_face->cgFont, &glyph, 1, &advance) ||
 	!CGFontGetGlyphBBoxesPtr (font_face->cgFont, &glyph, 1, &bbox))
 	goto FAIL;
 
-    status = _cairo_matrix_compute_scale_factors (&font->base.scale,
+    status = _cairo_matrix_compute_basis_scale_factors (&font->base.scale,
 						  &xscale, &yscale, 1);
     if (status)
 	goto FAIL;
 
     bbox = CGRectMake (bbox.origin.x / emscale,
@@ -630,11 +630,11 @@ _cairo_quartz_init_glyph_surface (cairo_
 	!CGFontGetGlyphBBoxesPtr (font_face->cgFont, &glyph, 1, &bbox))
     {
 	return CAIRO_INT_STATUS_UNSUPPORTED;
     }
 
-    status = _cairo_matrix_compute_scale_factors (&font->base.scale,
+    status = _cairo_matrix_compute_basis_scale_factors (&font->base.scale,
 						  &xscale, &yscale, 1);
     if (status)
 	return status;
 
     textMatrix = CGAffineTransformMake (font->base.scale.xx,
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-reference-count-private.h
--- a/gfx/cairo/cairo/src/cairo-reference-count-private.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-reference-count-private.h	Mon Sep 08 10:35:45 2008 +0300
@@ -35,10 +35,14 @@
  */
 
 #ifndef CAIRO_REFRENCE_COUNT_PRIVATE_H
 #define CAIRO_REFRENCE_COUNT_PRIVATE_H
 
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
 #include "cairo-atomic-private.h"
 
 CAIRO_BEGIN_DECLS
 
 /* Encapsulate operations on the object's reference count */
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-region-private.h
--- a/gfx/cairo/cairo/src/cairo-region-private.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-region-private.h	Mon Sep 08 10:35:45 2008 +0300
@@ -38,10 +38,11 @@
 #define CAIRO_REGION_PRIVATE_H
 
 #include <pixman.h>
 
 #include "cairo-compiler-private.h"
+#include "cairo-types-private.h"
 
 /* #cairo_region_t is defined in cairoint.h */
 
 struct _cairo_region {
     pixman_region32_t rgn;
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-rename.h
--- a/gfx/cairo/cairo/src/cairo-rename.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-rename.h	Mon Sep 08 10:35:45 2008 +0300
@@ -12,15 +12,10 @@
 #define cairo_copy_page _moz_cairo_copy_page
 #define cairo_copy_path _moz_cairo_copy_path
 #define cairo_copy_path_flat _moz_cairo_copy_path_flat
 #define cairo_create _moz_cairo_create
 #define cairo_curve_to _moz_cairo_curve_to
-#define cairo_debug_dump_clip _moz_cairo_debug_dump_clip
-#define cairo_debug_dump_path _moz_cairo_debug_dump_path
-#define cairo_debug_dump_trapezoid_array _moz_cairo_debug_dump_trapezoid_array
-#define cairo_debug_dump_traps _moz_cairo_debug_dump_traps
-#define cairo_debug_reset_static_data _moz_cairo_debug_reset_static_data
 #define cairo_debug_reset_static_data _moz_cairo_debug_reset_static_data
 #define cairo_destroy _moz_cairo_destroy
 #define cairo_device_to_user _moz_cairo_device_to_user
 #define cairo_device_to_user_distance _moz_cairo_device_to_user_distance
 #define cairo_directfb_surface_create _moz_cairo_directfb_surface_create
@@ -40,16 +35,18 @@
 #define cairo_font_options_destroy _moz_cairo_font_options_destroy
 #define cairo_font_options_equal _moz_cairo_font_options_equal
 #define cairo_font_options_get_antialias _moz_cairo_font_options_get_antialias
 #define cairo_font_options_get_hint_metrics _moz_cairo_font_options_get_hint_metrics
 #define cairo_font_options_get_hint_style _moz_cairo_font_options_get_hint_style
+#define cairo_font_options_get_lcd_filter _moz_cairo_font_options_get_lcd_filter
 #define cairo_font_options_get_subpixel_order _moz_cairo_font_options_get_subpixel_order
 #define cairo_font_options_hash _moz_cairo_font_options_hash
 #define cairo_font_options_merge _moz_cairo_font_options_merge
 #define cairo_font_options_set_antialias _moz_cairo_font_options_set_antialias
 #define cairo_font_options_set_hint_metrics _moz_cairo_font_options_set_hint_metrics
 #define cairo_font_options_set_hint_style _moz_cairo_font_options_set_hint_style
+#define cairo_font_options_set_lcd_filter _moz_cairo_font_options_set_lcd_filter
 #define cairo_font_options_set_subpixel_order _moz_cairo_font_options_set_subpixel_order
 #define cairo_font_options_status _moz_cairo_font_options_status
 #define cairo_format_stride_for_width _moz_cairo_format_stride_for_width
 #define cairo_ft_font_face_create_for_ft_face _moz_cairo_ft_font_face_create_for_ft_face
 #define cairo_ft_font_face_create_for_pattern _moz_cairo_ft_font_face_create_for_pattern
@@ -76,11 +73,13 @@
 #define cairo_get_source _moz_cairo_get_source
 #define cairo_get_target _moz_cairo_get_target
 #define cairo_get_tolerance _moz_cairo_get_tolerance
 #define cairo_get_user_data _moz_cairo_get_user_data
 #define cairo_glitz_surface_create _moz_cairo_glitz_surface_create
+#define cairo_glyph_allocate _moz_cairo_glyph_allocate
 #define cairo_glyph_extents _moz_cairo_glyph_extents
+#define cairo_glyph_free _moz_cairo_glyph_free
 #define cairo_glyph_path _moz_cairo_glyph_path
 #define cairo_has_current_point _moz_cairo_has_current_point
 #define cairo_has_show_text_glyphs _moz_cairo_has_show_text_glyphs
 #define cairo_identity_matrix _moz_cairo_identity_matrix
 #define cairo_image_surface_create _moz_cairo_image_surface_create
@@ -166,10 +165,16 @@
 #define cairo_ps_surface_restrict_to_level _moz_cairo_ps_surface_restrict_to_level
 #define cairo_ps_surface_set_eps _moz_cairo_ps_surface_set_eps
 #define cairo_ps_surface_set_size _moz_cairo_ps_surface_set_size
 #define cairo_push_group _moz_cairo_push_group
 #define cairo_push_group_with_content _moz_cairo_push_group_with_content
+#define cairo_qpainter_surface_create _moz_cairo_qpainter_surface_create
+#define cairo_qpainter_surface_create_with_qimage _moz_cairo_qpainter_surface_create_with_qimage
+#define cairo_qpainter_surface_create_with_qpixmap _moz_cairo_qpainter_surface_create_with_qpixmap
+#define cairo_qpainter_surface_get_image _moz_cairo_qpainter_surface_get_image
+#define cairo_qpainter_surface_get_qimage _moz_cairo_qpainter_surface_get_qimage
+#define cairo_qpainter_surface_get_qpainter _moz_cairo_qpainter_surface_get_qpainter
 #define cairo_quartz_font_face_create_for_atsu_font_id _moz_cairo_quartz_font_face_create_for_atsu_font_id
 #define cairo_quartz_font_face_create_for_cgfont _moz_cairo_quartz_font_face_create_for_cgfont
 #define cairo_quartz_image_surface_create _moz_cairo_quartz_image_surface_create
 #define cairo_quartz_image_surface_get_image _moz_cairo_quartz_image_surface_get_image
 #define cairo_quartz_surface_create _moz_cairo_quartz_surface_create
@@ -200,10 +205,11 @@
 #define cairo_scaled_font_glyph_extents _moz_cairo_scaled_font_glyph_extents
 #define cairo_scaled_font_reference _moz_cairo_scaled_font_reference
 #define cairo_scaled_font_set_user_data _moz_cairo_scaled_font_set_user_data
 #define cairo_scaled_font_status _moz_cairo_scaled_font_status
 #define cairo_scaled_font_text_extents _moz_cairo_scaled_font_text_extents
+#define cairo_scaled_font_text_to_glyphs _moz_cairo_scaled_font_text_to_glyphs
 #define cairo_select_font_face _moz_cairo_select_font_face
 #define cairo_set_antialias _moz_cairo_set_antialias
 #define cairo_set_dash _moz_cairo_set_dash
 #define cairo_set_fill_rule _moz_cairo_set_fill_rule
 #define cairo_set_font_face _moz_cairo_set_font_face
@@ -243,10 +249,11 @@
 #define cairo_surface_get_fallback_resolution _moz_cairo_surface_get_fallback_resolution
 #define cairo_surface_get_font_options _moz_cairo_surface_get_font_options
 #define cairo_surface_get_reference_count _moz_cairo_surface_get_reference_count
 #define cairo_surface_get_type _moz_cairo_surface_get_type
 #define cairo_surface_get_user_data _moz_cairo_surface_get_user_data
+#define cairo_surface_has_show_text_glyphs _moz_cairo_surface_has_show_text_glyphs
 #define cairo_surface_mark_dirty _moz_cairo_surface_mark_dirty
 #define cairo_surface_mark_dirty_rectangle _moz_cairo_surface_mark_dirty_rectangle
 #define cairo_surface_reference _moz_cairo_surface_reference
 #define cairo_surface_set_device_offset _moz_cairo_surface_set_device_offset
 #define cairo_surface_set_fallback_resolution _moz_cairo_surface_set_fallback_resolution
@@ -258,12 +265,18 @@
 #define cairo_svg_get_versions _moz_cairo_svg_get_versions
 #define cairo_svg_surface_create _moz_cairo_svg_surface_create
 #define cairo_svg_surface_create_for_stream _moz_cairo_svg_surface_create_for_stream
 #define cairo_svg_surface_restrict_to_version _moz_cairo_svg_surface_restrict_to_version
 #define cairo_svg_version_to_string _moz_cairo_svg_version_to_string
+#define cairo_text_cluster_allocate _moz_cairo_text_cluster_allocate
+#define cairo_text_cluster_free _moz_cairo_text_cluster_free
 #define cairo_text_extents _moz_cairo_text_extents
 #define cairo_text_path _moz_cairo_text_path
+#define cairo_toy_font_face_create _moz_cairo_toy_font_face_create
+#define cairo_toy_font_face_get_family _moz_cairo_toy_font_face_get_family
+#define cairo_toy_font_face_get_slant _moz_cairo_toy_font_face_get_slant
+#define cairo_toy_font_face_get_weight _moz_cairo_toy_font_face_get_weight
 #define cairo_transform _moz_cairo_transform
 #define cairo_translate _moz_cairo_translate
 #define cairo_user_font_face_create _moz_cairo_user_font_face_create
 #define cairo_user_font_face_get_init_func _moz_cairo_user_font_face_get_init_func
 #define cairo_user_font_face_get_render_glyph_func _moz_cairo_user_font_face_get_render_glyph_func
@@ -372,18 +385,18 @@
 #define pixman_image_set_repeat _moz_pixman_image_set_repeat
 #define pixman_image_set_filter _moz_pixman_image_set_filter
 #define pixman_image_set_source_clipping _moz_pixman_image_set_source_clipping
 #define pixman_image_set_alpha_map _moz_pixman_image_set_alpha_map
 #define pixman_image_set_component_alpha _moz_pixman_image_set_component_alpha
-#define pixman_image_set_accessors _moz_pixman_image_set_accessors
-#define pixman_image_set_indexed _moz_pixman_image_set_indexed
+#define pixman_image_set_accessors	 _moz_pixman_image_set_accessors	
+#define pixman_image_set_indexed	 _moz_pixman_image_set_indexed	
 #define pixman_image_get_data _moz_pixman_image_get_data
 #define pixman_image_get_width _moz_pixman_image_get_width
 #define pixman_image_get_height _moz_pixman_image_get_height
 #define pixman_image_get_stride _moz_pixman_image_get_stride
 #define pixman_image_get_depth _moz_pixman_image_get_depth
-#define pixman_image_fill_rectangles _moz_pixman_image_fill_rectangles
+#define pixman_image_fill_rectangles	 _moz_pixman_image_fill_rectangles	
 #define pixman_compute_composite_region _moz_pixman_compute_composite_region
 #define pixman_image_composite _moz_pixman_image_composite
 #define pixman_sample_ceil_y _moz_pixman_sample_ceil_y
 #define pixman_sample_floor_y _moz_pixman_sample_floor_y
 #define pixman_edge_step _moz_pixman_edge_step
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-scaled-font-subsets-private.h
--- a/gfx/cairo/cairo/src/cairo-scaled-font-subsets-private.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-scaled-font-subsets-private.h	Mon Sep 08 10:35:45 2008 +0300
@@ -36,10 +36,12 @@
 
 #ifndef CAIRO_SCALED_FONT_SUBSETS_PRIVATE_H
 #define CAIRO_SCALED_FONT_SUBSETS_PRIVATE_H
 
 #include "cairoint.h"
+
+#if CAIRO_HAS_FONT_SUBSET
 
 typedef struct _cairo_scaled_font_subsets_glyph {
     unsigned int font_id;
     unsigned int subset_id;
     unsigned int subset_glyph_index;
@@ -125,15 +127,13 @@ _cairo_scaled_font_subsets_destroy (cair
 /**
  * _cairo_scaled_font_subsets_map_glyph:
  * @font_subsets: a #cairo_scaled_font_subsets_t
  * @scaled_font: the font of the glyph to be mapped
  * @scaled_font_glyph_index: the index of the glyph to be mapped
+ * @utf8: a string of text encoded in UTF-8
+ * @utf8_len: length of @utf8 in bytes
  * @subset_glyph_ret: return structure containing subset font and glyph id
- *
- * @font_id_ret: return value giving the font ID of the mapped glyph
- * @subset_id_ret: return value giving the subset ID of the mapped glyph within the @font_id_ret
- * @subset_glyph_index_ret: return value giving the index of the mapped glyph within the @subset_id_ret subset
  *
  * Map a glyph from a #cairo_scaled_font to a new index within a
  * subset of that font. The mapping performed is from the tuple:
  *
  *	(scaled_font, scaled_font_glyph_index)
@@ -167,10 +167,18 @@ _cairo_scaled_font_subsets_destroy (cair
  * exists a mapping of scaled_glyph_font_index to subset_glyph_index.
  *
  * This final description of a font subset is the same representation
  * used by #cairo_scaled_font_subset_t as provided by
  * _cairo_scaled_font_subsets_foreach.
+ *
+ * @utf8 and @utf8_len specify a string of unicode characters that the
+ * glyph @scaled_font_glyph_index maps to. If @utf8_is_mapped in
+ * @subset_glyph_ret is %TRUE, the font subsetting will (where index to
+ * unicode mapping is supported) ensure that @scaled_font_glyph_index
+ * maps to @utf8. If @utf8_is_mapped is %FALSE,
+ * @scaled_font_glyph_index has already been mapped to a different
+ * unicode string.
  *
  * The returned values in the #cairo_scaled_font_subsets_glyph_t struct are:
  *
  * @font_id: The font ID of the mapped glyph
  * @subset_id : The subset ID of the mapped glyph within the @font_id
@@ -363,11 +371,11 @@ typedef struct _cairo_truetype_subset {
 typedef struct _cairo_truetype_subset {
     char *base_font;
     double *widths;
     double x_min, y_min, x_max, y_max;
     double ascent, descent;
-    char *data;
+    unsigned char *data;
     unsigned long data_length;
     unsigned long *string_offsets;
     unsigned long num_string_offsets;
 } cairo_truetype_subset_t;
 
@@ -413,10 +421,13 @@ typedef struct _cairo_type1_subset {
     unsigned long header_length;
     unsigned long data_length;
     unsigned long trailer_length;
 } cairo_type1_subset_t;
 
+
+#if CAIRO_HAS_FT_FONT
+
 /**
  * _cairo_type1_subset_init:
  * @type1_subset: a #cairo_type1_subset_t to initialize
  * @font_subset: the #cairo_scaled_font_subset_t to initialize from
  * @hex_encode: if true the encrypted portion of the font is hex encoded
@@ -445,10 +456,13 @@ _cairo_type1_subset_init (cairo_type1_su
  * @type1_subset should not be used again without a subsequent call to
  * _cairo_truetype_type1_init() again first.
  **/
 cairo_private void
 _cairo_type1_subset_fini (cairo_type1_subset_t *subset);
+
+#endif /* CAIRO_HAS_FT_FONT */
+
 
 /**
  * _cairo_type1_scaled_font_is_type1:
  * @scaled_font: a #cairo_scaled_font_t
  *
@@ -584,6 +598,8 @@ cairo_private cairo_int_status_t
 cairo_private cairo_int_status_t
 _cairo_truetype_index_to_ucs4 (cairo_scaled_font_t *scaled_font,
                                unsigned long        index,
                                uint32_t            *ucs4);
 
+#endif /* CAIRO_HAS_FONT_SUBSET */
+
 #endif /* CAIRO_SCALED_FONT_SUBSETS_PRIVATE_H */
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-scaled-font-subsets.c
--- a/gfx/cairo/cairo/src/cairo-scaled-font-subsets.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-scaled-font-subsets.c	Mon Sep 08 10:35:45 2008 +0300
@@ -40,10 +40,13 @@
  *	Adrian Johnson <ajohnson@redneon.com>
  */
 
 #define _BSD_SOURCE /* for snprintf(), strdup() */
 #include "cairoint.h"
+
+#if CAIRO_HAS_FONT_SUBSET
+
 #include "cairo-scaled-font-subsets-private.h"
 #include "cairo-user-font-private.h"
 
 #define MAX_GLYPHS_PER_SIMPLE_FONT 256
 #define MAX_GLYPHS_PER_COMPOSITE_FONT 65536
@@ -278,11 +281,11 @@ _cairo_sub_font_create (cairo_scaled_fon
 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
     }
     sub_font->next = NULL;
 
     /* Reserve first glyph in subset for the .notdef glyph */
-    status = _cairo_sub_font_map_glyph (sub_font, 0, NULL, 0, &subset_glyph);
+    status = _cairo_sub_font_map_glyph (sub_font, 0, NULL, -1, &subset_glyph);
     if (status) {
 	_cairo_hash_table_destroy (sub_font->sub_font_glyphs);
 	free (sub_font);
 	return status;
     }
@@ -322,27 +325,35 @@ _cairo_sub_font_glyph_lookup_unicode (ca
     int len;
     cairo_status_t status;
 
     /* Do a reverse lookup on the glyph index. unicode is -1 if the
      * index could not be mapped to a unicode character. */
-    status = _cairo_truetype_index_to_ucs4 (scaled_font, scaled_font_glyph_index, &unicode);
+    unicode = -1;
+    status = _cairo_truetype_index_to_ucs4 (scaled_font,
+					    scaled_font_glyph_index,
+					    &unicode);
     if (status && status != CAIRO_INT_STATUS_UNSUPPORTED)
 	return status;
 
-    if (status == CAIRO_INT_STATUS_UNSUPPORTED)
-	unicode = -1;
-
-    if (unicode == (uint32_t)-1 && scaled_font->backend->index_to_ucs4)
-	status = scaled_font->backend->index_to_ucs4 (scaled_font, scaled_font_glyph_index, &unicode);
+    if (unicode == (uint32_t)-1 && scaled_font->backend->index_to_ucs4) {
+	status = scaled_font->backend->index_to_ucs4 (scaled_font,
+						      scaled_font_glyph_index,
+						      &unicode);
+	if (status)
+	    return status;
+    }
 
     sub_font_glyph->unicode = unicode;
     sub_font_glyph->utf8 = NULL;
     sub_font_glyph->utf8_len = 0;
-    if (unicode != (uint32_t)-1) {
+    if (unicode != (uint32_t) -1) {
 	len = _cairo_ucs4_to_utf8 (unicode, buf);
 	if (len > 0) {
-	    sub_font_glyph->utf8 = malloc(len + 1);
+	    sub_font_glyph->utf8 = malloc (len + 1);
+	    if (sub_font_glyph->utf8 == NULL)
+		return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+
 	    memcpy (sub_font_glyph->utf8, buf, len);
 	    sub_font_glyph->utf8[len] = 0;
 	    sub_font_glyph->utf8_len = len;
 	}
     }
@@ -350,14 +361,18 @@ _cairo_sub_font_glyph_lookup_unicode (ca
     return CAIRO_STATUS_SUCCESS;
 }
 
 static cairo_bool_t
 _cairo_sub_font_glyph_map_to_unicode (cairo_sub_font_glyph_t *sub_font_glyph,
-				      const char 	     *utf8,
-				      int 		      utf8_len)
+				      const char	     *utf8,
+				      int		      utf8_len)
 {
-    int add_zero_byte = 0;
+    if (utf8_len < 0)
+	return FALSE;
+
+    if (utf8 != NULL && utf8_len != 0 && utf8[utf8_len - 1] == '\0')
+	utf8_len--;
 
     if (utf8 != NULL && utf8_len != 0) {
 	if (sub_font_glyph->utf8 != NULL) {
 	    if (utf8_len == sub_font_glyph->utf8_len &&
 		memcmp (utf8, sub_font_glyph->utf8, utf8_len) == 0)
@@ -370,16 +385,13 @@ _cairo_sub_font_glyph_map_to_unicode (ca
 		/* Requested utf8 mapping does not match the existing mapping */
 		return FALSE;
 	    }
 	} else {
 	    /* No existing mapping. Use the requested mapping */
-	    if (sub_font_glyph->utf8[utf8_len - 1] != 0)
-		add_zero_byte = 1;
-	    sub_font_glyph->utf8 = malloc (utf8_len + add_zero_byte);
+	    sub_font_glyph->utf8 = malloc (utf8_len + 1);
 	    memcpy (sub_font_glyph->utf8, utf8, utf8_len);
-	    if (add_zero_byte)
-		sub_font_glyph->utf8[utf8_len] = 0;
+	    sub_font_glyph->utf8[utf8_len] = 0;
 	    sub_font_glyph->utf8_len = utf8_len;
 	    return TRUE;
 	}
     }
 
@@ -388,11 +400,11 @@ _cairo_sub_font_glyph_map_to_unicode (ca
 }
 
 static cairo_bool_t
 _cairo_sub_font_lookup_glyph (cairo_sub_font_t	                *sub_font,
                               unsigned long	                 scaled_font_glyph_index,
-			      const char * 			 utf8,
+			      const char			*utf8,
 			      int				 utf8_len,
                               cairo_scaled_font_subsets_glyph_t *subset_glyph)
 {
     cairo_sub_font_glyph_t key, *sub_font_glyph;
 
@@ -417,30 +429,31 @@ _cairo_sub_font_lookup_glyph (cairo_sub_
 }
 
 static cairo_status_t
 _cairo_sub_font_map_glyph (cairo_sub_font_t	*sub_font,
 			   unsigned long	 scaled_font_glyph_index,
-			   const char * 	 utf8,
+			   const char		*utf8,
 			   int			 utf8_len,
                            cairo_scaled_font_subsets_glyph_t *subset_glyph)
 {
     cairo_sub_font_glyph_t key, *sub_font_glyph;
     cairo_status_t status;
     cairo_scaled_glyph_t *scaled_glyph;
-    cairo_scaled_font_subsets_glyph_t tmp_subset_glyph;
 
     _cairo_sub_font_glyph_init_key (&key, scaled_font_glyph_index);
     if (! _cairo_hash_table_lookup (sub_font->sub_font_glyphs, &key.base,
 				    (cairo_hash_entry_t **) &sub_font_glyph))
     {
 	if (sub_font->num_glyphs_in_current_subset == sub_font->max_glyphs_per_subset)
 	{
+	    cairo_scaled_font_subsets_glyph_t tmp_subset_glyph;
+
 	    sub_font->current_subset++;
 	    sub_font->num_glyphs_in_current_subset = 0;
 
 	    /* Reserve first glyph in subset for the .notdef glyph */
-	    status = _cairo_sub_font_map_glyph (sub_font, 0, NULL, 0, &tmp_subset_glyph);
+	    status = _cairo_sub_font_map_glyph (sub_font, 0, NULL, -1, &tmp_subset_glyph);
 	    if (status)
 		return status;
 	}
 
         status = _cairo_scaled_glyph_lookup (sub_font->scaled_font,
@@ -457,29 +470,30 @@ _cairo_sub_font_map_glyph (cairo_sub_fon
                                                        scaled_glyph->metrics.x_advance,
                                                        scaled_glyph->metrics.y_advance);
 	if (sub_font_glyph == NULL)
 	    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
 
-	_cairo_sub_font_glyph_lookup_unicode (sub_font_glyph,
-					      sub_font->scaled_font,
-					      scaled_font_glyph_index);
+	status = _cairo_sub_font_glyph_lookup_unicode (sub_font_glyph,
+						       sub_font->scaled_font,
+						       scaled_font_glyph_index);
+	if (status) {
+	    _cairo_sub_font_glyph_destroy (sub_font_glyph);
+	    return status;
+	}
 
 	status = _cairo_hash_table_insert (sub_font->sub_font_glyphs, &sub_font_glyph->base);
 	if (status) {
 	    _cairo_sub_font_glyph_destroy (sub_font_glyph);
 	    return status;
 	}
 
 	sub_font->num_glyphs_in_current_subset++;
 
-        if (sub_font->is_scaled)
-        {
+        if (sub_font->is_scaled) {
             if (sub_font->num_glyphs_in_current_subset > sub_font->parent->max_glyphs_per_scaled_subset_used)
                 sub_font->parent->max_glyphs_per_scaled_subset_used = sub_font->num_glyphs_in_current_subset;
-        }
-        else
-        {
+        } else {
             if (sub_font->num_glyphs_in_current_subset > sub_font->parent->max_glyphs_per_unscaled_subset_used)
                 sub_font->parent->max_glyphs_per_unscaled_subset_used = sub_font->num_glyphs_in_current_subset;
         }
     }
 
@@ -488,11 +502,12 @@ _cairo_sub_font_map_glyph (cairo_sub_fon
     subset_glyph->subset_glyph_index = sub_font_glyph->subset_glyph_index;
     subset_glyph->is_scaled = sub_font->is_scaled;
     subset_glyph->is_composite = sub_font->is_composite;
     subset_glyph->x_advance = sub_font_glyph->x_advance;
     subset_glyph->y_advance = sub_font_glyph->y_advance;
-    subset_glyph->utf8_is_mapped = FALSE;
+    subset_glyph->utf8_is_mapped = _cairo_sub_font_glyph_map_to_unicode (sub_font_glyph, utf8, utf8_len);
+    subset_glyph->unicode = sub_font_glyph->unicode;
 
     return CAIRO_STATUS_SUCCESS;
 }
 
 static void
@@ -942,12 +957,12 @@ _cairo_scaled_font_subset_create_glyph_n
 	utf8 = subset->utf8[i];
 	utf16 = NULL;
 	utf16_len = 0;
 	if (utf8 && *utf8) {
 	    status = _cairo_utf8_to_utf16 (utf8, -1, &utf16, &utf16_len);
-	    if (status && status != CAIRO_STATUS_INVALID_STRING)
-		return status; // FIXME
+	    if (status)
+		return status; /* FIXME */
 	}
 
 	if (utf16_len == 1) {
 	    snprintf (buf, sizeof(buf), "uni%04X", (int)(utf16[0]));
 	    _cairo_string_init_key (&key, buf);
@@ -1002,5 +1017,7 @@ CLEANUP_HASH:
 	subset->glyph_names = NULL;
     }
 
     return status;
 }
+
+#endif /* CAIRO_HAS_FONT_SUBSET */
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-scaled-font.c
--- a/gfx/cairo/cairo/src/cairo-scaled-font.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-scaled-font.c	Mon Sep 08 10:35:45 2008 +0300
@@ -297,10 +297,11 @@ slim_hidden_def (cairo_scaled_font_statu
  * of scaled fonts we keep around even when not otherwise referenced
  */
 #define CAIRO_SCALED_FONT_MAX_HOLDOVERS 256
 
 typedef struct _cairo_scaled_font_map {
+    cairo_scaled_font_t *mru_scaled_font;
     cairo_hash_table_t *hash_table;
     cairo_scaled_font_t *holdovers[CAIRO_SCALED_FONT_MAX_HOLDOVERS];
     int num_holdovers;
 } cairo_scaled_font_map_t;
 
@@ -317,10 +318,11 @@ _cairo_scaled_font_map_lock (void)
     if (cairo_scaled_font_map == NULL) {
 	cairo_scaled_font_map = malloc (sizeof (cairo_scaled_font_map_t));
 	if (cairo_scaled_font_map == NULL)
 	    goto CLEANUP_MUTEX_LOCK;
 
+	cairo_scaled_font_map->mru_scaled_font = NULL;
 	cairo_scaled_font_map->hash_table =
 	    _cairo_hash_table_create (_cairo_scaled_font_keys_equal);
 
 	if (cairo_scaled_font_map->hash_table == NULL)
 	    goto CLEANUP_SCALED_FONT_MAP;
@@ -356,15 +358,21 @@ _cairo_scaled_font_map_destroy (void)
     font_map = cairo_scaled_font_map;
     if (font_map == NULL) {
         goto CLEANUP_MUTEX_LOCK;
     }
 
+    scaled_font = font_map->mru_scaled_font;
+    if (scaled_font != NULL) {
+	CAIRO_MUTEX_UNLOCK (_cairo_scaled_font_map_mutex);
+	cairo_scaled_font_destroy (scaled_font);
+	CAIRO_MUTEX_LOCK (_cairo_scaled_font_map_mutex);
+    }
+
     /* remove scaled_fonts starting from the end so that font_map->holdovers
      * is always in a consistent state when we release the mutex. */
     while (font_map->num_holdovers) {
 	scaled_font = font_map->holdovers[font_map->num_holdovers-1];
-
 	assert (! CAIRO_REFERENCE_COUNT_HAS_REFERENCE (&scaled_font->ref_count));
 	_cairo_hash_table_remove (font_map->hash_table,
 				  &scaled_font->hash_entry);
 
 	font_map->num_holdovers--;
@@ -671,11 +679,11 @@ _cairo_scaled_font_set_metrics (cairo_sc
 				cairo_font_extents_t	    *fs_metrics)
 {
     cairo_status_t status;
     double  font_scale_x, font_scale_y;
 
-    status = _cairo_matrix_compute_scale_factors (&scaled_font->font_matrix,
+    status = _cairo_matrix_compute_basis_scale_factors (&scaled_font->font_matrix,
 						  &font_scale_x, &font_scale_y,
 						  1);
     if (status)
 	return status;
 
@@ -743,11 +751,11 @@ cairo_scaled_font_create (cairo_font_fac
 			  const cairo_matrix_t       *ctm,
 			  const cairo_font_options_t *options)
 {
     cairo_status_t status;
     cairo_scaled_font_map_t *font_map;
-    cairo_scaled_font_t key, *scaled_font = NULL;
+    cairo_scaled_font_t key, *old = NULL, *scaled_font = NULL;
 
     if (font_face->status)
 	return _cairo_scaled_font_create_in_error (font_face->status);
 
     status = cairo_font_options_status ((cairo_font_options_t *) options);
@@ -761,46 +769,16 @@ cairo_scaled_font_create (cairo_font_fac
     if (font_map == NULL)
 	return _cairo_scaled_font_create_in_error (_cairo_error (CAIRO_STATUS_NO_MEMORY));
 
     _cairo_scaled_font_init_key (&key, font_face,
 				 font_matrix, ctm, options);
-
-
-    while (_cairo_hash_table_lookup (font_map->hash_table, &key.hash_entry,
-				     (cairo_hash_entry_t**) &scaled_font))
+    scaled_font = font_map->mru_scaled_font;
+    if (scaled_font != NULL &&
+	scaled_font->hash_entry.hash == key.hash_entry.hash &&
+	_cairo_scaled_font_keys_equal (scaled_font, &key))
     {
-	if (!scaled_font->placeholder)
-	    break;
-
-	/* If the scaled font is being created (happens for user-font),
-	 * just wait until it's done, then retry */
-	_cairo_scaled_font_placeholder_wait_for_creation_to_finish (scaled_font);
-    }
-
-    /* Return existing scaled_font if it exists in the hash table. */
-    if (scaled_font)
-    {
-	/* If the original reference count is 0, then this font must have
-	 * been found in font_map->holdovers, (which means this caching is
-	 * actually working). So now we remove it from the holdovers
-	 * array. */
-	if (! CAIRO_REFERENCE_COUNT_HAS_REFERENCE (&scaled_font->ref_count)) {
-	    int i;
-
-	    for (i = 0; i < font_map->num_holdovers; i++)
-		if (font_map->holdovers[i] == scaled_font)
-		    break;
-	    assert (i < font_map->num_holdovers);
-
-	    font_map->num_holdovers--;
-	    memmove (&font_map->holdovers[i],
-		     &font_map->holdovers[i+1],
-		     (font_map->num_holdovers - i) * sizeof (cairo_scaled_font_t*));
-
-	    /* reset any error status */
-	    scaled_font->status = CAIRO_STATUS_SUCCESS;
-	}
+	assert (! scaled_font->placeholder);
 
 	if (scaled_font->status == CAIRO_STATUS_SUCCESS) {
 	    /* We increment the reference count manually here, (rather
 	     * than calling into cairo_scaled_font_reference), since we
 	     * must modify the reference count while our lock is still
@@ -812,10 +790,70 @@ cairo_scaled_font_create (cairo_font_fac
 
 	/* the font has been put into an error status - abandon the cache */
 	_cairo_hash_table_remove (font_map->hash_table, &key.hash_entry);
 	scaled_font->hash_entry.hash = ZOMBIE;
     }
+    else
+    {
+	while (_cairo_hash_table_lookup (font_map->hash_table, &key.hash_entry,
+					 (cairo_hash_entry_t**) &scaled_font))
+	{
+	    if (! scaled_font->placeholder)
+		break;
+
+	    /* If the scaled font is being created (happens for user-font),
+	     * just wait until it's done, then retry */
+	    _cairo_scaled_font_placeholder_wait_for_creation_to_finish (scaled_font);
+	}
+
+	/* Return existing scaled_font if it exists in the hash table. */
+	if (scaled_font != NULL) {
+	    /* If the original reference count is 0, then this font must have
+	     * been found in font_map->holdovers, (which means this caching is
+	     * actually working). So now we remove it from the holdovers
+	     * array. */
+	    if (! CAIRO_REFERENCE_COUNT_HAS_REFERENCE (&scaled_font->ref_count)) {
+		int i;
+
+		for (i = 0; i < font_map->num_holdovers; i++)
+		    if (font_map->holdovers[i] == scaled_font)
+			break;
+		assert (i < font_map->num_holdovers);
+
+		font_map->num_holdovers--;
+		memmove (&font_map->holdovers[i],
+			 &font_map->holdovers[i+1],
+			 (font_map->num_holdovers - i) * sizeof (cairo_scaled_font_t*));
+
+		/* reset any error status */
+		scaled_font->status = CAIRO_STATUS_SUCCESS;
+	    }
+
+	    if (scaled_font->status == CAIRO_STATUS_SUCCESS) {
+		/* We increment the reference count manually here, (rather
+		 * than calling into cairo_scaled_font_reference), since we
+		 * must modify the reference count while our lock is still
+		 * held. */
+
+		old = font_map->mru_scaled_font;
+		font_map->mru_scaled_font = scaled_font;
+		/* increment reference count for the mru cache */
+		_cairo_reference_count_inc (&scaled_font->ref_count);
+		/* and increment for the returned reference */
+		_cairo_reference_count_inc (&scaled_font->ref_count);
+		_cairo_scaled_font_map_unlock ();
+
+		cairo_scaled_font_destroy (old);
+
+		return scaled_font;
+	    }
+
+	    /* the font has been put into an error status - abandon the cache */
+	    _cairo_hash_table_remove (font_map->hash_table, &key.hash_entry);
+	    scaled_font->hash_entry.hash = ZOMBIE;
+	}
+    }
 
     /* Otherwise create it and insert it into the hash table. */
     status = font_face->backend->scaled_font_create (font_face, font_matrix,
 						     ctm, options, &scaled_font);
     if (status) {
@@ -824,20 +862,28 @@ cairo_scaled_font_create (cairo_font_fac
 	return _cairo_scaled_font_create_in_error (status);
     }
 
     status = _cairo_hash_table_insert (font_map->hash_table,
 				       &scaled_font->hash_entry);
+    if (status == CAIRO_STATUS_SUCCESS) {
+	old = font_map->mru_scaled_font;
+	font_map->mru_scaled_font = scaled_font;
+	_cairo_reference_count_inc (&scaled_font->ref_count);
+    }
+
     _cairo_scaled_font_map_unlock ();
 
     if (status) {
 	/* We can't call _cairo_scaled_font_destroy here since it expects
 	 * that the font has already been successfully inserted into the
 	 * hash table. */
 	_cairo_scaled_font_fini (scaled_font);
 	free (scaled_font);
 	return _cairo_scaled_font_create_in_error (status);
     }
+
+    cairo_scaled_font_destroy (old);
 
     return scaled_font;
 }
 slim_hidden_def (cairo_scaled_font_create);
 
@@ -1081,11 +1127,11 @@ slim_hidden_def (cairo_scaled_font_exten
 slim_hidden_def (cairo_scaled_font_extents);
 
 /**
  * cairo_scaled_font_text_extents:
  * @scaled_font: a #cairo_scaled_font_t
- * @utf8: a string of text, encoded in UTF-8
+ * @utf8: a NUL-terminated string of text, encoded in UTF-8
  * @extents: a #cairo_text_extents_t which to store the retrieved extents.
  *
  * Gets the extents for a string of text. The extents describe a
  * user-space rectangle that encloses the "inked" portion of the text
  * drawn at the origin (0,0) (as it would be drawn by cairo_show_text()
@@ -1107,20 +1153,24 @@ cairo_scaled_font_text_extents (cairo_sc
 cairo_scaled_font_text_extents (cairo_scaled_font_t   *scaled_font,
 				const char            *utf8,
 				cairo_text_extents_t  *extents)
 {
     cairo_status_t status;
-    cairo_glyph_t *glyphs;
+    cairo_glyph_t *glyphs = NULL;
     int num_glyphs;
 
     if (scaled_font->status)
 	goto ZERO_EXTENTS;
 
     if (utf8 == NULL)
 	goto ZERO_EXTENTS;
 
-    status = _cairo_scaled_font_text_to_glyphs (scaled_font, 0., 0., utf8, &glyphs, &num_glyphs);
+    status = cairo_scaled_font_text_to_glyphs (scaled_font, 0., 0.,
+					       utf8, -1,
+					       &glyphs, &num_glyphs,
+					       NULL, NULL,
+					       NULL);
     if (status)
 	goto ZERO_EXTENTS;
 
     cairo_scaled_font_glyph_extents (scaled_font, glyphs, num_glyphs, extents);
     free (glyphs);
@@ -1164,19 +1214,19 @@ cairo_scaled_font_glyph_extents (cairo_s
     int i;
     double min_x = 0.0, min_y = 0.0, max_x = 0.0, max_y = 0.0;
     cairo_bool_t visible = FALSE;
     cairo_scaled_glyph_t *scaled_glyph = NULL;
 
-    if (scaled_font->status) {
-	extents->x_bearing = 0.0;
-	extents->y_bearing = 0.0;
-	extents->width  = 0.0;
-	extents->height = 0.0;
-	extents->x_advance = 0.0;
-	extents->y_advance = 0.0;
+    extents->x_bearing = 0.0;
+    extents->y_bearing = 0.0;
+    extents->width  = 0.0;
+    extents->height = 0.0;
+    extents->x_advance = 0.0;
+    extents->y_advance = 0.0;
+
+    if (scaled_font->status)
 	return;
-    }
 
     if (num_glyphs == 0)
 	return;
 
     if (num_glyphs < 0) {
@@ -1262,91 +1312,370 @@ cairo_scaled_font_glyph_extents (cairo_s
     _cairo_scaled_font_thaw_cache (scaled_font);
     CAIRO_MUTEX_UNLOCK (scaled_font->mutex);
 }
 slim_hidden_def (cairo_scaled_font_glyph_extents);
 
+/**
+ * cairo_scaled_font_text_to_glyphs:
+ * @x: X position to place first glyph
+ * @y: Y position to place first glyph
+ * @scaled_font: a #cairo_scaled_font_t
+ * @utf8: a string of text encoded in UTF-8
+ * @utf8_len: length of @utf8 in bytes, or -1 if it is NUL-terminated
+ * @glyphs: pointer to array of glyphs to fill
+ * @num_glyphs: pointer to number of glyphs
+ * @clusters: pointer to array of cluster mapping information to fill, or %NULL
+ * @num_clusters: pointer to number of clusters, or %NULL
+ * @backward: pointer to whether the text to glyphs mapping goes backward, or
+ *            %NULL
+ *
+ * Converts UTF-8 text to an array of glyphs, optionally with cluster
+ * mapping, that can be used to render later using @scaled_font.
+ *
+ * If @glyphs initially points to a non-%NULL value, that array is used
+ * as a glyph buffer, and @num_glyphs should point to the number of glyph
+ * entries available there.  If the provided glyph array is too short for
+ * the conversion, a new glyph array is allocated using cairo_glyph_allocate()
+ * and placed in @glyphs.  Upon return, @num_glyphs always contains the
+ * number of generated glyphs.  If the value @glyphs points at has changed
+ * after the call, the user is responsible for freeing the allocated glyph
+ * array using cairo_glyph_free().
+ *
+ * If @clusters is not %NULL, @num_clusters and @backward should not be %NULL,
+ * and cluster mapping will be computed.
+ * The semantics of how cluster array allocation works is similar to the glyph
+ * array.  That is,
+ * if @clusters initially points to a non-%NULL value, that array is used
+ * as a cluster buffer, and @num_clusters should point to the number of cluster
+ * entries available there.  If the provided cluster array is too short for
+ * the conversion, a new cluster array is allocated using cairo_text_cluster_allocate()
+ * and placed in @clusters.  Upon return, @num_clusters always contains the
+ * number of generated clusters.  If the value @clusters points at has changed
+ * after the call, the user is responsible for freeing the allocated cluster
+ * array using cairo_text_cluster_free().
+ *
+ * In the simplest case, @glyphs and @clusters can point to %NULL initially
+ * and a suitable array will be allocated.  In code:
+ * <informalexample><programlisting>
+ * cairo_status_t status;
+ *
+ * cairo_glyph_t *glyphs = NULL;
+ * int num_glyphs;
+ * cairo_text_cluster_t *clusters = NULL;
+ * int num_clusters;
+ * cairo_bool_t backward;
+ *
+ * status = cairo_scaled_font_text_to_glyphs (scaled_font,
+ *                                            x, y,
+ *                                            utf8, utf8_len,
+ *                                            &amp;glyphs, &amp;num_glyphs,
+ *                                            &amp;clusters, &amp;num_clusters,
+ *                                            &amp;backward);
+ *
+ * if (status == CAIRO_STATUS_SUCCESS) {
+ *     cairo_show_text_glyphs (cr,
+ *                             utf8, utf8_len,
+ *                             *glyphs, *num_glyphs,
+ *                             *clusters, *num_clusters,
+ *                             *backward);
+ *
+ *     cairo_glyph_free (*glyphs);
+ *     cairo_text_cluster_free (*clusters);
+ * }
+ * </programlisting></informalexample>
+ *
+ * If no cluster mapping is needed:
+ * <informalexample><programlisting>
+ * cairo_status_t status;
+ *
+ * cairo_glyph_t *glyphs = NULL;
+ * int num_glyphs;
+ *
+ * status = cairo_scaled_font_text_to_glyphs (scaled_font,
+ *                                            x, y,
+ *                                            utf8, utf8_len,
+ *                                            &amp;glyphs, &amp;num_glyphs,
+ *                                            NULL, NULL,
+ *                                            NULL);
+ *
+ * if (status == CAIRO_STATUS_SUCCESS) {
+ *     cairo_show_glyphs (cr, *glyphs, *num_glyphs);
+ *     cairo_glyph_free (*glyphs);
+ * }
+ * </programlisting></informalexample>
+ *
+ * If stack-based glyph and cluster arrays are to be used for small
+ * arrays:
+ * <informalexample><programlisting>
+ * cairo_status_t status;
+ *
+ * cairo_glyph_t stack_glyphs[40];
+ * cairo_glyph_t *glyphs = stack_glyphs;
+ * int num_glyphs = sizeof (stack_glyphs) / sizeof (stack_glyphs[0]);
+ * cairo_text_cluster_t stack_clusters[40];
+ * cairo_text_cluster_t *clusters = stack_clusters;
+ * int num_clusters = sizeof (stack_clusters) / sizeof (stack_clusters[0]);
+ * cairo_bool_t backward;
+ *
+ * status = cairo_scaled_font_text_to_glyphs (scaled_font,
+ *                                            x, y,
+ *                                            utf8, utf8_len,
+ *                                            &amp;glyphs, &amp;num_glyphs,
+ *                                            &amp;clusters, &amp;num_clusters,
+ *                                            &amp;backward);
+ *
+ * if (status == CAIRO_STATUS_SUCCESS) {
+ *     cairo_show_text_glyphs (cr,
+ *                             utf8, utf8_len,
+ *                             *glyphs, *num_glyphs,
+ *                             *clusters, *num_clusters,
+ *                             *backward);
+ *
+ *     if (glyphs != stack_glyphs)
+ *         cairo_glyph_free (*glyphs);
+ *     if (clusters != stack_clusters)
+ *         cairo_text_cluster_free (*clusters);
+ * }
+ * </programlisting></informalexample>
+ *
+ * For details of how @clusters, @num_clusters, and @backward map input
+ * UTF-8 text to the output glyphs see cairo_show_text_glyphs().
+ *
+ * The output values can be readily passed to cairo_show_text_glyphs()
+ * cairo_show_glyphs(), or related functions, assuming that the exact
+ * same @scaled_font is used for the operation.
+ *
+ * Return value: %CAIRO_STATUS_SUCCESS upon success, or an error status
+ * if the input values are wrong or if conversion failed.  If the input
+ * values are correct but the conversion failed, the error status is also
+ * set on @scaled_font.
+ *
+ * Since: 1.8
+ **/
 cairo_status_t
-_cairo_scaled_font_text_to_glyphs (cairo_scaled_font_t *scaled_font,
-				   double		x,
-				   double		y,
-				   const char          *utf8,
-				   cairo_glyph_t      **glyphs,
-				   int 		       *num_glyphs)
+cairo_scaled_font_text_to_glyphs (cairo_scaled_font_t   *scaled_font,
+				  double		 x,
+				  double		 y,
+				  const char	        *utf8,
+				  int		         utf8_len,
+				  cairo_glyph_t	       **glyphs,
+				  int		        *num_glyphs,
+				  cairo_text_cluster_t **clusters,
+				  int		        *num_clusters,
+				  cairo_bool_t	        *backward)
 {
     int i;
-    uint32_t *ucs4 = NULL;
+    int num_chars = 0;
+    const char *p;
     cairo_status_t status;
-    cairo_scaled_glyph_t *scaled_glyph;
-
-    *num_glyphs = 0;
-    *glyphs = NULL;
+    cairo_glyph_t *orig_glyphs;
+    cairo_text_cluster_t *orig_clusters;
 
     status = scaled_font->status;
     if (status)
 	return status;
 
-    if (utf8[0] == '\0')
-	return CAIRO_STATUS_SUCCESS;
+    /* A slew of sanity checks */
+
+    /* glyphs and num_glyphs can't be NULL */
+    if (glyphs     == NULL ||
+	num_glyphs == NULL) {
+	status = CAIRO_STATUS_NULL_POINTER;
+	goto BAIL;
+    }
+
+    /* Special case for NULL and -1 */
+    if (utf8 == NULL && utf8_len == -1)
+	utf8_len = 0;
+
+    /* No NULLs for non-NULLs! */
+    if ((utf8_len && utf8         == NULL) ||
+	(clusters && num_clusters == NULL) ||
+	(clusters && backward     == NULL)) {
+	status = CAIRO_STATUS_NULL_POINTER;
+	goto BAIL;
+    }
+
+    /* A -1 for utf8_len means NUL-terminated */
+    if (utf8_len == -1)
+	utf8_len = strlen (utf8);
+
+    /* A NULL *glyphs means no prealloced glyphs array */
+    if (glyphs && *glyphs == NULL)
+	*num_glyphs = 0;
+
+    /* A NULL *clusters means no prealloced clusters array */
+    if (clusters && *clusters == NULL)
+	*num_clusters = 0;
+
+    if (!clusters && num_clusters) {
+	num_clusters = NULL;
+    }
+
+    if (backward) {
+	*backward = FALSE;
+    }
+
+    if (!clusters && backward) {
+	backward = NULL;
+    }
+
+    /* Apart from that, no negatives */
+    if (utf8_len < 0 ||
+	*num_glyphs < 0 ||
+	(num_clusters && *num_clusters < 0)) {
+	status = CAIRO_STATUS_NEGATIVE_COUNT;
+	goto BAIL;
+    }
+
+    if (utf8_len == 0) {
+	status = CAIRO_STATUS_SUCCESS;
+	goto BAIL;
+    }
+
+    /* validate input so backend does not have to */
+    status = _cairo_utf8_to_ucs4 (utf8, utf8_len, NULL, &num_chars);
+    if (status)
+	goto BAIL;
 
     CAIRO_MUTEX_LOCK (scaled_font->mutex);
     _cairo_scaled_font_freeze_cache (scaled_font);
 
+    orig_glyphs = *glyphs;
+    orig_clusters = clusters ? *clusters : NULL;
+
     if (scaled_font->backend->text_to_glyphs) {
 
-	/* validate input so backend does not have to */
-	status = _cairo_utf8_to_ucs4 (utf8, -1, NULL, NULL);
-	if (status)
-	    goto DONE;
+	status = scaled_font->backend->text_to_glyphs (scaled_font, x, y,
+						       utf8, utf8_len,
+						       glyphs, num_glyphs,
+						       clusters, num_clusters,
+						       backward);
 
-	status = scaled_font->backend->text_to_glyphs (scaled_font,
-						       x, y, utf8,
-						       glyphs, num_glyphs);
+        if (status != CAIRO_INT_STATUS_UNSUPPORTED) {
 
-        if (status != CAIRO_INT_STATUS_UNSUPPORTED)
+	    if (status == CAIRO_STATUS_SUCCESS) {
+
+	        /* The checks here are crude; we only should do them in
+		 * user-font backend, but they don't hurt here.  This stuff
+		 * can be hard to get right. */
+
+	        if (*num_glyphs < 0) {
+		    status = CAIRO_STATUS_NEGATIVE_COUNT;
+		    goto DONE;
+		}
+		if (num_glyphs && *glyphs == NULL) {
+		    status = CAIRO_STATUS_NULL_POINTER;
+		    goto DONE;
+		}
+
+		if (clusters) {
+
+		    if (*num_clusters < 0) {
+			status = CAIRO_STATUS_NEGATIVE_COUNT;
+			goto DONE;
+		    }
+		    if (num_clusters && *clusters == NULL) {
+			status = CAIRO_STATUS_NULL_POINTER;
+			goto DONE;
+		    }
+
+		    /* Dont trust the backend, validate clusters! */
+		    status = _cairo_validate_text_clusters (utf8, utf8_len,
+							    *glyphs, *num_glyphs,
+							    *clusters, *num_clusters,
+							    *backward);
+		}
+	    }
+
             goto DONE;
+	}
     }
 
-    status = _cairo_utf8_to_ucs4 (utf8, -1, &ucs4, num_glyphs);
-    if (status)
-	goto DONE;
+    if (*num_glyphs < num_chars) {
+	*glyphs = cairo_glyph_allocate (num_chars);
+	if (*glyphs == NULL) {
+	    status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
+	    goto DONE;
+	}
+    }
+    *num_glyphs = num_chars;
 
-    *glyphs = (cairo_glyph_t *) _cairo_malloc_ab ((*num_glyphs), sizeof (cairo_glyph_t));
-
-    if (*glyphs == NULL) {
-	status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
-	goto DONE;
+    if (clusters) {
+	if (*num_clusters < num_chars) {
+	    *clusters = cairo_text_cluster_allocate (num_chars);
+	    if (*clusters == NULL) {
+		status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
+		goto DONE;
+	    }
+	}
+	*num_clusters = num_chars;
     }
 
-    for (i = 0; i < *num_glyphs; i++) {
-        (*glyphs)[i].index = (*scaled_font->backend->
-			      ucs4_to_index) (scaled_font, ucs4[i]);
+    p = utf8;
+    for (i = 0; i < num_chars; i++) {
+	int num_bytes;
+	uint32_t unicode;
+	cairo_scaled_glyph_t *scaled_glyph;
+
+	num_bytes = _cairo_utf8_get_char_validated (p, &unicode);
+	p += num_bytes;
+
+        (*glyphs)[i].index = (*scaled_font->backend->ucs4_to_index) (scaled_font, unicode);
 	(*glyphs)[i].x = x;
 	(*glyphs)[i].y = y;
+
+	if (clusters) {
+	    (*clusters)[i].num_bytes  = num_bytes;
+	    (*clusters)[i].num_glyphs = 1;
+	}
 
 	status = _cairo_scaled_glyph_lookup (scaled_font,
 					     (*glyphs)[i].index,
 					     CAIRO_SCALED_GLYPH_INFO_METRICS,
 					     &scaled_glyph);
 	if (status) {
-	    free (*glyphs);
-	    *glyphs = NULL;
 	    goto DONE;
 	}
 
         x += scaled_glyph->metrics.x_advance;
         y += scaled_glyph->metrics.y_advance;
     }
 
- DONE:
+ DONE: /* error that should be logged on scaled_font happened */
     _cairo_scaled_font_thaw_cache (scaled_font);
     CAIRO_MUTEX_UNLOCK (scaled_font->mutex);
 
-    if (ucs4)
-	free (ucs4);
+    if (status) {
+	*num_glyphs = 0;
+	if (*glyphs != orig_glyphs) {
+	    cairo_glyph_free (*glyphs);
+	    *glyphs = orig_glyphs;
+	}
+
+	if (clusters) {
+	    *num_clusters = 0;
+	    if (*clusters != orig_clusters) {
+		cairo_text_cluster_free (*clusters);
+		*clusters = orig_clusters;
+	    }
+	}
+    }
 
     return _cairo_scaled_font_set_error (scaled_font, status);
+
+ BAIL: /* error with input arguments */
+
+    if (num_glyphs)
+	*num_glyphs = 0;
+
+    if (num_clusters)
+	*num_clusters = 0;
+
+    return status;
 }
+slim_hidden_def (cairo_scaled_font_text_to_glyphs);
 
 /*
  * Compute a device-space bounding box for the glyphs.
  */
 cairo_status_t
@@ -1450,12 +1779,10 @@ _cairo_scaled_font_show_glyphs (cairo_sc
 	if (status != CAIRO_INT_STATUS_UNSUPPORTED)
 	    return _cairo_scaled_font_set_error (scaled_font, status);
     }
 
     /* Font display routine either does not exist or failed. */
-
-    status = CAIRO_STATUS_SUCCESS;
 
     _cairo_pattern_init_solid (&white_pattern, CAIRO_COLOR_WHITE, CAIRO_CONTENT_COLOR);
 
     _cairo_cache_freeze (scaled_font->glyphs);
 
@@ -1694,11 +2021,11 @@ _trace_mask_to_path (cairo_image_surface
 _trace_mask_to_path (cairo_image_surface_t *mask,
 		     cairo_path_fixed_t *path)
 {
     cairo_status_t status;
     cairo_image_surface_t *a1_mask;
-    unsigned char *row, *byte_ptr, byte;
+    uint8_t *row, *byte_ptr, byte;
     int rows, cols, bytes_per_row;
     int x, y, bit;
     double xoff, yoff;
 
     if (mask->format == CAIRO_FORMAT_A1)
@@ -1714,11 +2041,11 @@ _trace_mask_to_path (cairo_image_surface
 
     cairo_surface_get_device_offset (&mask->base, &xoff, &yoff);
 
     bytes_per_row = (a1_mask->width + 7) / 8;
     for (y = 0, row = a1_mask->data, rows = a1_mask->height; rows; row += a1_mask->stride, rows--, y++) {
-	for (x = 0, byte_ptr = row, cols = (a1_mask->width + 7) / 8; cols; byte_ptr++, cols--) {
+	for (x = 0, byte_ptr = row, cols = bytes_per_row; cols; byte_ptr++, cols--) {
 	    byte = CAIRO_BITSWAP8_IF_LITTLE_ENDIAN (*byte_ptr);
 	    for (bit = 7; bit >= 0 && x < a1_mask->width; bit--, x++) {
 		if (byte & (1 << bit)) {
 		    status = _add_unit_rectangle_to_path (path,
 							  x - xoff, y - yoff);
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-surface.c
--- a/gfx/cairo/cairo/src/cairo-surface.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-surface.c	Mon Sep 08 10:35:45 2008 +0300
@@ -69,14 +69,15 @@ const cairo_surface_t name = {					\
     NULL,				/* clip */		\
     0,					/* next_clip_serial */	\
     0,					/* current_clip_serial */	\
     FALSE,				/* is_snapshot */	\
     FALSE,				/* has_font_options */	\
-    { CAIRO_ANTIALIAS_DEFAULT,					\
-      CAIRO_SUBPIXEL_ORDER_DEFAULT,				\
-      CAIRO_HINT_STYLE_DEFAULT,					\
-      CAIRO_HINT_METRICS_DEFAULT				\
+    { CAIRO_ANTIALIAS_DEFAULT,		/* antialias */		\
+      CAIRO_SUBPIXEL_ORDER_DEFAULT,	/* subpixel_order */	\
+      CAIRO_LCD_FILTER_DEFAULT,		/* lcd_filter */	\
+      CAIRO_HINT_STYLE_DEFAULT,		/* hint_style */	\
+      CAIRO_HINT_METRICS_DEFAULT	/* hint_metrics */	\
     }					/* font_options */	\
 }
 
 static DEFINE_NIL_SURFACE(CAIRO_STATUS_NO_MEMORY, _cairo_surface_nil);
 static DEFINE_NIL_SURFACE(CAIRO_STATUS_INVALID_CONTENT, _cairo_surface_nil_invalid_content);
@@ -646,11 +647,16 @@ cairo_surface_get_font_options (cairo_su
 				cairo_font_options_t  *options)
 {
     if (cairo_font_options_status (options))
 	return;
 
-    if (!surface->has_font_options) {
+    if (surface->status) {
+	_cairo_font_options_init_default (options);
+	return;
+    }
+
+    if (! surface->has_font_options) {
 	surface->has_font_options = TRUE;
 
 	_cairo_font_options_init_default (&surface->font_options);
 
 	if (!surface->finished && surface->backend->get_font_options) {
@@ -1730,10 +1736,13 @@ _cairo_surface_composite_trapezoids (cai
  * Emits the current page for backends that support multiple pages,
  * but doesn't clear it, so that the contents of the current page will
  * be retained for the next page.  Use cairo_surface_show_page() if you
  * want to get an empty page after the emission.
  *
+ * There is a convenience function for this that takes a #cairo_t,
+ * namely cairo_copy_page().
+ *
  * Since: 1.6
  */
 void
 cairo_surface_copy_page (cairo_surface_t *surface)
 {
@@ -1763,10 +1772,13 @@ slim_hidden_def (cairo_surface_copy_page
  * cairo_surface_show_page:
  * @surface: a #cairo_Surface_t
  *
  * Emits and clears the current page for backends that support multiple
  * pages.  Use cairo_surface_copy_page() if you don't want to clear the page.
+ *
+ * There is a convenience function for this that takes a #cairo_t,
+ * namely cairo_show_page().
  *
  * Since: 1.6
  **/
 void
 cairo_surface_show_page (cairo_surface_t *surface)
@@ -2133,18 +2145,54 @@ _cairo_surface_get_extents (cairo_surfac
     }
 
     return status;
 }
 
+/**
+ * cairo_surface_has_show_text_glyphs:
+ * @surface: a #cairo_surface_t
+ *
+ * Returns whether the surface supports
+ * sophisticated cairo_show_text_glyphs() operations.  That is,
+ * whether it actually uses the provided text and cluster data
+ * to a cairo_show_text_glyphs() call.
+ *
+ * Note: Even if this function returns %FALSE, a
+ * cairo_show_text_glyphs() operation targeted at @surface will
+ * still succeed.  It just will
+ * act like a cairo_show_glyphs() operation.  Users can use this
+ * function to avoid computing UTF-8 text and cluster mapping if the
+ * target surface does not use it.
+ *
+ * There is a convenience function for this that takes a #cairo_t,
+ * namely cairo_has_show_text_glyphs().
+ *
+ * Return value: %TRUE if @surface supports
+ *               cairo_show_text_glyphs(), %FALSE otherwise
+ *
+ * Since: 1.8
+ **/
 cairo_bool_t
-_cairo_surface_has_show_text_glyphs (cairo_surface_t	    *surface)
+cairo_surface_has_show_text_glyphs (cairo_surface_t	    *surface)
 {
+    cairo_status_t status_ignored;
+
+    if (surface->status)
+	return FALSE;
+
+    if (surface->finished) {
+	status_ignored = _cairo_surface_set_error (surface,
+						   CAIRO_STATUS_SURFACE_FINISHED);
+	return FALSE;
+    }
+
     if (surface->backend->has_show_text_glyphs)
 	return surface->backend->has_show_text_glyphs (surface);
     else
 	return surface->backend->show_text_glyphs != NULL;
 }
+slim_hidden_def (cairo_surface_has_show_text_glyphs);
 
 /* Note: the backends may modify the contents of the glyph array as long as
  * they do not return %CAIRO_INT_STATUS_UNSUPPORTED. This makes it possible to
  * avoid copying the array again and again, and edit it in-place.
  * Backends are in fact free to use the array as a generic buffer as they
@@ -2556,19 +2604,12 @@ _cairo_surface_copy_pattern_for_destinat
     status = _cairo_pattern_create_copy (pattern_out, pattern);
     if (status)
 	return status;
 
     if (_cairo_surface_has_device_transform (destination)) {
-	cairo_matrix_t device_to_surface = destination->device_transform;
-
-	status = cairo_matrix_invert (&device_to_surface);
-	/* We only ever allow for scaling (under the implementation's
-	 * control) or translation (under the user's control). So the
-	 * matrix should always be invertible. */
-	assert (status == CAIRO_STATUS_SUCCESS);
-
-	_cairo_pattern_transform (*pattern_out, &device_to_surface);
+	_cairo_pattern_transform (*pattern_out,
+		                  &destination->device_transform_inverse);
     }
 
     return CAIRO_STATUS_SUCCESS;
 }
 
@@ -2637,10 +2678,12 @@ _cairo_surface_create_in_error (cairo_st
     case CAIRO_STATUS_FONT_TYPE_MISMATCH:
     case CAIRO_STATUS_USER_FONT_IMMUTABLE:
     case CAIRO_STATUS_USER_FONT_ERROR:
     case CAIRO_STATUS_NEGATIVE_COUNT:
     case CAIRO_STATUS_INVALID_CLUSTERS:
+    case CAIRO_STATUS_INVALID_SLANT:
+    case CAIRO_STATUS_INVALID_WEIGHT:
     default:
 	_cairo_error_throw (CAIRO_STATUS_NO_MEMORY);
 	return (cairo_surface_t *) &_cairo_surface_nil;
     }
 }
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-svg-surface.c
--- a/gfx/cairo/cairo/src/cairo-svg-surface.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-svg-surface.c	Mon Sep 08 10:35:45 2008 +0300
@@ -649,11 +649,11 @@ _cairo_svg_document_emit_bitmap_glyph_da
 					    unsigned long		 glyph_index)
 {
     cairo_image_surface_t *image;
     cairo_scaled_glyph_t *scaled_glyph;
     cairo_status_t status;
-    unsigned char *row, *byte;
+    uint8_t *row, *byte;
     int rows, cols;
     int x, y, bit;
 
     status = _cairo_scaled_glyph_lookup (scaled_font,
 					 glyph_index,
@@ -675,11 +675,11 @@ _cairo_svg_document_emit_bitmap_glyph_da
 				       &image->base.device_transform_inverse, NULL);
     _cairo_output_stream_printf (document->xml_node_glyphs, ">/n");
 
     for (y = 0, row = image->data, rows = image->height; rows; row += image->stride, rows--, y++) {
 	for (x = 0, byte = row, cols = (image->width + 7) / 8; cols; byte++, cols--) {
-	    unsigned char output_byte = CAIRO_BITSWAP8_IF_LITTLE_ENDIAN (*byte);
+	    uint8_t output_byte = CAIRO_BITSWAP8_IF_LITTLE_ENDIAN (*byte);
 	    for (bit = 7; bit >= 0 && x < image->width; bit--, x++) {
 		if (output_byte & (1 << bit)) {
 		    _cairo_output_stream_printf (document->xml_node_glyphs,
 						 "<rect x=\"%d\" y=\"%d\" width=\"1\" height=\"1\"/>\n",
 						 x, y);
@@ -868,45 +868,45 @@ _cairo_svg_surface_emit_alpha_filter (ca
 }
 
 typedef struct {
     cairo_output_stream_t *output;
     unsigned int in_mem;
+    unsigned int trailing;
     unsigned char src[3];
-    unsigned char dst[5];
-    unsigned int trailing;
 } base64_write_closure_t;
 
-static char const *base64_table =
+static char const base64_table[64] =
 "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
 
 static cairo_status_t
 base64_write_func (void *closure,
 		   const unsigned char *data,
 		   unsigned int length)
 {
     base64_write_closure_t *info = (base64_write_closure_t *) closure;
     unsigned int i;
-    unsigned char *src, *dst;
+    unsigned char *src;
 
-    dst = info->dst;
     src = info->src;
 
     if (info->in_mem + length < 3) {
 	for (i = 0; i < length; i++) {
-	    src[i + info->in_mem] = *data;
-	    data++;
+	    src[i + info->in_mem] = *data++;
 	}
 	info->in_mem += length;
 	return CAIRO_STATUS_SUCCESS;
     }
 
-    while (info->in_mem + length >= 3) {
-	for (i = 0; i < 3 - info->in_mem; i++) {
-	    src[i + info->in_mem] = *data;
-	    data++;
+    do {
+	unsigned char dst[4];
+
+	for (i = info->in_mem; i < 3; i++) {
+	    src[i] = *data++;
 	    length--;
 	}
+	info->in_mem = 0;
+
 	dst[0] = base64_table[src[0] >> 2];
 	dst[1] = base64_table[(src[0] & 0x03) << 4 | src[1] >> 4];
 	dst[2] = base64_table[(src[1] & 0x0f) << 2 | src[2] >> 6];
 	dst[3] = base64_table[src[2] & 0xfc >> 2];
 	/* Special case for the last missing bits */
@@ -917,20 +917,18 @@ base64_write_func (void *closure,
 		dst[3] = '=';
 	    default:
 		break;
 	}
 	_cairo_output_stream_write (info->output, dst, 4);
-	info->in_mem = 0;
-    }
+    } while (length >= 3);
 
     for (i = 0; i < length; i++) {
-	src[i] = *data;
-	data++;
+	src[i] = *data++;
     }
     info->in_mem = length;
 
-    return CAIRO_STATUS_SUCCESS;
+    return _cairo_output_stream_get_status (info->output);
 }
 
 static cairo_int_status_t
 _cairo_surface_base64_encode (cairo_surface_t       *surface,
 			      cairo_output_stream_t *output)
@@ -940,11 +938,10 @@ _cairo_surface_base64_encode (cairo_surf
     unsigned int i;
 
     info.output = output;
     info.in_mem = 0;
     info.trailing = 0;
-    memset (info.dst, '\x0', 5);
 
     _cairo_output_stream_printf (info.output, "data:image/png;base64,");
 
     status = cairo_surface_write_to_png_stream (surface, base64_write_func,
 						(void *) &info);
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-truetype-subset-private.h
--- a/gfx/cairo/cairo/src/cairo-truetype-subset-private.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-truetype-subset-private.h	Mon Sep 08 10:35:45 2008 +0300
@@ -36,10 +36,12 @@
 
 #ifndef CAIRO_TRUETYPE_SUBSET_PRIVATE_H
 #define CAIRO_TRUETYPE_SUBSET_PRIVATE_H
 
 #include "cairoint.h"
+
+#if CAIRO_HAS_FONT_SUBSET
 
 /* The structs defined here should strictly follow the TrueType
  * specification and not be padded.  We use only 16-bit integer
  * in their definition to guarantee that.  The fields of type
  * "FIXED" in the TT spec are broken into two *_1 and *_2 16-bit
@@ -190,6 +192,8 @@ typedef struct _tt_glyph_data {
     int16_t           num_contours;
     int8_t            data[8];
     tt_composite_glyph_t glyph;
 } tt_glyph_data_t;
 
+#endif /* CAIRO_HAS_FONT_SUBSET */
+
 #endif /* CAIRO_TRUETYPE_SUBSET_PRIVATE_H */
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-truetype-subset.c
--- a/gfx/cairo/cairo/src/cairo-truetype-subset.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-truetype-subset.c	Mon Sep 08 10:35:45 2008 +0300
@@ -40,10 +40,12 @@
  * http://www.microsoft.com/typography/specs/default.htm
  */
 
 #define _BSD_SOURCE /* for snprintf(), strdup() */
 #include "cairoint.h"
+
+#if CAIRO_HAS_FONT_SUBSET
 
 #include "cairo-scaled-font-subsets-private.h"
 #include "cairo-truetype-subset-private.h"
 
 
@@ -1222,12 +1224,11 @@ _cairo_truetype_reverse_cmap (cairo_scal
     start_code = &(end_code[num_segments + 1]);
     delta = &(start_code[num_segments]);
     range_offset = &(delta[num_segments]);
     glyph_array = &(range_offset[num_segments]);
 
-    /* search for glyph in segments
-     * with rangeOffset=0 */
+    /* search for glyph in segments with rangeOffset=0 */
     for (i = 0; i < num_segments; i++) {
 	c = index - be16_to_cpu (delta[i]);
 	if (range_offset[i] == 0 &&
 	    c >= be16_to_cpu (start_code[i]) &&
 	    c <= be16_to_cpu (end_code[i]))
@@ -1243,16 +1244,17 @@ _cairo_truetype_reverse_cmap (cairo_scal
 	    uint16_t *glyph_ids = &range_offset[i] + be16_to_cpu (range_offset[i])/2;
 	    int range_size = be16_to_cpu (end_code[i]) - be16_to_cpu (start_code[i]) + 1;
 	    uint16_t g_id_be = cpu_to_be16 (index);
 	    int j;
 
-	    for (j = 0; j < range_size; j++) {
-		if (glyph_ids[j] == g_id_be) {
-		    *ucs4 = be16_to_cpu (start_code[i]) + j;
-		    goto found;
+	    if (range_size > 0)
+		for (j = 0; j < range_size; j++) {
+		    if (glyph_ids[j] == g_id_be) {
+			*ucs4 = be16_to_cpu (start_code[i]) + j;
+			goto found;
+		    }
 		}
-	    }
 	}
     }
 
     /* glyph not found */
     *ucs4 = -1;
@@ -1291,11 +1293,11 @@ _cairo_truetype_index_to_ucs4 (cairo_sca
 	return status;
 
     cmap = (tt_cmap_t *) buf;
     num_tables = be16_to_cpu (cmap->num_tables);
     size = 4 + num_tables*sizeof(tt_cmap_index_t);
-    cmap = malloc (size);
+    cmap = _cairo_malloc_ab_plus_c (num_tables, sizeof (tt_cmap_index_t), 4);
     if (cmap == NULL)
 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
 
     status = backend->load_truetype_table (scaled_font,
 	                                   TT_TAG_cmap, 0,
@@ -1320,5 +1322,7 @@ cleanup:
 cleanup:
     free (cmap);
 
     return status;
 }
+
+#endif /* CAIRO_HAS_FONT_SUBSET */
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-type1-fallback.c
--- a/gfx/cairo/cairo/src/cairo-type1-fallback.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-type1-fallback.c	Mon Sep 08 10:35:45 2008 +0300
@@ -33,10 +33,13 @@
  *	Adrian Johnson <ajohnson@redneon.com>
  */
 
 #define _BSD_SOURCE /* for snprintf(), strdup() */
 #include "cairoint.h"
+
+#if CAIRO_HAS_FONT_SUBSET
+
 #include "cairo-type1-private.h"
 #include "cairo-scaled-font-subsets-private.h"
 #include "cairo-path-fixed-private.h"
 #include "cairo-output-stream-private.h"
 
@@ -871,5 +874,7 @@ _cairo_type2_charstrings_fini (cairo_typ
     }
     _cairo_array_fini (&type2_subset->charstrings);
 
     free (type2_subset->widths);
 }
+
+#endif /* CAIRO_HAS_FONT_SUBSET */
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-type1-private.h
--- a/gfx/cairo/cairo/src/cairo-type1-private.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-type1-private.h	Mon Sep 08 10:35:45 2008 +0300
@@ -34,12 +34,18 @@
  */
 
 #ifndef CAIRO_TYPE1_PRIVATE_H
 #define CAIRO_TYPE1_PRIVATE_H
 
+#include "cairoint.h"
+
+#if CAIRO_HAS_FONT_SUBSET
+
 /* Magic constants for the type1 eexec encryption */
 #define CAIRO_TYPE1_ENCRYPT_C1		((unsigned short) 52845)
 #define CAIRO_TYPE1_ENCRYPT_C2		((unsigned short) 22719)
 #define CAIRO_TYPE1_PRIVATE_DICT_KEY	((unsigned short) 55665)
 #define CAIRO_TYPE1_CHARSTRING_KEY	((unsigned short) 4330)
 
+#endif /* CAIRO_HAS_FONT_SUBSET */
+
 #endif /* CAIRO_TYPE1_PRIVATE_H */
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-type1-subset.c
--- a/gfx/cairo/cairo/src/cairo-type1-subset.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-type1-subset.c	Mon Sep 08 10:35:45 2008 +0300
@@ -36,17 +36,23 @@
 /*
  * Useful links:
  * http://partners.adobe.com/public/developer/en/font/T1_SPEC.PDF
  */
 
+
 #define _BSD_SOURCE /* for snprintf(), strdup() */
 #include "cairoint.h"
+
+#if CAIRO_HAS_FONT_SUBSET
+
 #include "cairo-type1-private.h"
 #include "cairo-scaled-font-subsets-private.h"
 #include "cairo-output-stream-private.h"
 
 /* XXX: Eventually, we need to handle other font backends */
+#if CAIRO_HAS_FT_FONT
+
 #include "cairo-ft-private.h"
 
 #include <ft2build.h>
 #include FT_FREETYPE_H
 #include FT_OUTLINE_H
@@ -1403,5 +1409,9 @@ _cairo_type1_scaled_font_is_type1 (cairo
 
     _cairo_ft_unscaled_font_unlock_face (unscaled);
 
     return is_type1;
 }
+
+#endif /* CAIRO_HAS_FT_FONT */
+
+#endif /* CAIRO_HAS_FONT_SUBSET */
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-type3-glyph-surface-private.h
--- a/gfx/cairo/cairo/src/cairo-type3-glyph-surface-private.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-type3-glyph-surface-private.h	Mon Sep 08 10:35:45 2008 +0300
@@ -35,10 +35,14 @@
  */
 
 #ifndef CAIRO_TYPE3_GLYPH_SURFACE_PRIVATE_H
 #define CAIRO_TYPE3_GLYPH_SURFACE_PRIVATE_H
 
+#include "cairoint.h"
+
+#if CAIRO_HAS_FONT_SUBSET
+
 #include "cairo-surface-private.h"
 #include "cairo-pdf-operators-private.h"
 
 typedef cairo_status_t (*cairo_type3_glyph_surface_emit_image_t) (cairo_image_surface_t *image,
 								  cairo_output_stream_t	*stream);
@@ -69,6 +73,8 @@ _cairo_type3_glyph_surface_emit_glyph (v
 				       cairo_output_stream_t *stream,
 				       unsigned long	      glyph_index,
 				       cairo_box_t           *bbox,
 				       double                *width);
 
+#endif /* CAIRO_HAS_FONT_SUBSET */
+
 #endif /* CAIRO_TYPE3_GLYPH_SURFACE_PRIVATE_H */
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-type3-glyph-surface.c
--- a/gfx/cairo/cairo/src/cairo-type3-glyph-surface.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-type3-glyph-surface.c	Mon Sep 08 10:35:45 2008 +0300
@@ -33,10 +33,13 @@
  * Contributor(s):
  *	Adrian Johnson <ajohnson@redneon.com>
  */
 
 #include "cairoint.h"
+
+#if CAIRO_HAS_FONT_SUBSET
+
 #include "cairo-type3-glyph-surface-private.h"
 #include "cairo-output-stream-private.h"
 #include "cairo-meta-surface-private.h"
 
 static const cairo_surface_backend_t cairo_type3_glyph_surface_backend;
@@ -110,11 +113,11 @@ _cairo_type3_glyph_surface_emit_image (c
 				 "Q\n");
 
     if (image_mask != image)
 	cairo_surface_destroy (&image_mask->base);
 
-    return CAIRO_STATUS_SUCCESS;
+    return status;
 }
 
 static cairo_status_t
 _cairo_type3_glyph_surface_emit_image_pattern (cairo_type3_glyph_surface_t *surface,
 					       cairo_image_surface_t       *image,
@@ -441,5 +444,7 @@ _cairo_type3_glyph_surface_emit_glyph (v
     if (status == CAIRO_INT_STATUS_IMAGE_FALLBACK)
 	status = _cairo_type3_glyph_surface_emit_fallback_image (surface, glyph_index);
 
     return status;
 }
+
+#endif /* CAIRO_HAS_FONT_SUBSET */
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-types-private.h
--- a/gfx/cairo/cairo/src/cairo-types-private.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-types-private.h	Mon Sep 08 10:35:45 2008 +0300
@@ -43,21 +43,31 @@
  * typedefs.*/
 #include "cairo.h"
 #include "cairo-fixed-type-private.h"
 
 typedef struct _cairo_array cairo_array_t;
+typedef struct _cairo_cache cairo_cache_t;
+typedef struct _cairo_clip cairo_clip_t;
+typedef struct _cairo_clip_path cairo_clip_path_t;
+typedef struct _cairo_color cairo_color_t;
+typedef struct _cairo_font_face_backend     cairo_font_face_backend_t;
+typedef struct _cairo_gstate cairo_gstate_t;
+typedef struct _cairo_hash_entry cairo_hash_entry_t;
 typedef struct _cairo_hash_table cairo_hash_table_t;
-typedef struct _cairo_cache cairo_cache_t;
-typedef struct _cairo_hash_entry cairo_hash_entry_t;
+typedef struct _cairo_image_surface cairo_image_surface_t;
+typedef struct _cairo_output_stream cairo_output_stream_t;
+typedef struct _cairo_paginated_surface_backend cairo_paginated_surface_backend_t;
+typedef struct _cairo_path_fixed cairo_path_fixed_t;
+typedef struct _cairo_rectangle_int16 cairo_glyph_size_t;
+typedef struct _cairo_region cairo_region_t;
+typedef struct _cairo_scaled_font_backend   cairo_scaled_font_backend_t;
+typedef struct _cairo_scaled_font_subsets cairo_scaled_font_subsets_t;
+typedef struct _cairo_solid_pattern cairo_solid_pattern_t;
 typedef struct _cairo_surface_backend cairo_surface_backend_t;
-typedef struct _cairo_clip cairo_clip_t;
-typedef struct _cairo_output_stream cairo_output_stream_t;
-typedef struct _cairo_scaled_font_subsets cairo_scaled_font_subsets_t;
-typedef struct _cairo_paginated_surface_backend cairo_paginated_surface_backend_t;
-typedef struct _cairo_scaled_font_backend   cairo_scaled_font_backend_t;
-typedef struct _cairo_font_face_backend     cairo_font_face_backend_t;
+typedef struct _cairo_unscaled_font_backend cairo_unscaled_font_backend_t;
 typedef struct _cairo_xlib_screen_info cairo_xlib_screen_info_t;
+
 typedef cairo_array_t cairo_user_data_array_t;
 
 /**
  * cairo_hash_entry_t:
  *
@@ -106,10 +116,11 @@ struct _cairo_array {
 };
 
 struct _cairo_font_options {
     cairo_antialias_t antialias;
     cairo_subpixel_order_t subpixel_order;
+    cairo_lcd_filter_t lcd_filter;
     cairo_hint_style_t hint_style;
     cairo_hint_metrics_t hint_metrics;
 };
 
 struct _cairo_cache {
@@ -135,11 +146,10 @@ typedef enum _cairo_paginated_mode {
  * that for #cairo_status_t */
 typedef enum _cairo_int_status {
     CAIRO_INT_STATUS_UNSUPPORTED = 100,
     CAIRO_INT_STATUS_DEGENERATE,
     CAIRO_INT_STATUS_NOTHING_TO_DO,
-    CAIRO_INT_STATUS_CACHE_EMPTY,
     CAIRO_INT_STATUS_FLATTEN_TRANSPARENCY,
     CAIRO_INT_STATUS_IMAGE_FALLBACK,
     CAIRO_INT_STATUS_ANALYZE_META_SURFACE_PATTERN,
 
     CAIRO_INT_STATUS_LAST_STATUS
@@ -153,12 +163,10 @@ typedef enum _cairo_internal_surface_typ
     CAIRO_INTERNAL_SURFACE_TYPE_TEST_FALLBACK,
     CAIRO_INTERNAL_SURFACE_TYPE_TEST_PAGINATED,
     CAIRO_INTERNAL_SURFACE_TYPE_NULL,
     CAIRO_INTERNAL_SURFACE_TYPE_TYPE3_GLYPH
 } cairo_internal_surface_type_t;
-
-typedef struct _cairo_region cairo_region_t;
 
 typedef struct _cairo_point {
     cairo_fixed_t x;
     cairo_fixed_t y;
 } cairo_point_t;
@@ -197,12 +205,10 @@ struct _cairo_rectangle_int32 {
 struct _cairo_rectangle_int32 {
     int32_t x, y;
     uint32_t width, height;
 };
 
-typedef struct _cairo_rectangle_int16 cairo_glyph_size_t;
-
 struct _cairo_point_int16 {
     int16_t x, y;
 };
 
 struct _cairo_point_int32 {
@@ -231,17 +237,15 @@ typedef enum _cairo_direction {
 typedef enum _cairo_direction {
     CAIRO_DIRECTION_FORWARD,
     CAIRO_DIRECTION_REVERSE
 } cairo_direction_t;
 
-typedef struct _cairo_path_fixed cairo_path_fixed_t;
 typedef enum _cairo_clip_mode {
     CAIRO_CLIP_MODE_PATH,
     CAIRO_CLIP_MODE_REGION,
     CAIRO_CLIP_MODE_MASK
 } cairo_clip_mode_t;
-typedef struct _cairo_clip_path cairo_clip_path_t;
 
 typedef struct _cairo_edge {
     cairo_line_t edge;
     int clockWise;
 
@@ -290,13 +294,10 @@ typedef struct _cairo_pen {
     int num_vertices;
     cairo_pen_vertex_t *vertices;
     cairo_pen_vertex_t  vertices_embedded[32];
 } cairo_pen_t;
 
-typedef struct _cairo_color cairo_color_t;
-typedef struct _cairo_image_surface cairo_image_surface_t;
-
 typedef struct _cairo_stroke_style {
     double		 line_width;
     cairo_line_cap_t	 line_cap;
     cairo_line_join_t	 line_join;
     double		 miter_limit;
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-unicode.c
--- a/gfx/cairo/cairo/src/cairo-unicode.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-unicode.c	Mon Sep 08 10:35:45 2008 +0300
@@ -194,10 +194,44 @@ _utf8_get_char_extended (const unsigned 
 
     return wc;
 }
 
 /**
+ * _cairo_utf8_get_char_validated:
+ * @p: a UTF-8 string
+ * @unicode: location to store one Unicode character
+ *
+ * Decodes the first character of a valid UTF-8 string, and returns
+ * the number of bytes consumed.
+ *
+ * Note that the string should be valid.  Do not use this without
+ * validating the string first.
+ *
+ * Returns: the number of bytes forming the character returned.
+ **/
+int
+_cairo_utf8_get_char_validated (const char *p,
+				uint32_t   *unicode)
+{
+    int i, mask = 0, len;
+    uint32_t result;
+    unsigned char c = (unsigned char) *p;
+
+    UTF8_COMPUTE (c, mask, len);
+    if (len == -1) {
+	if (unicode)
+	    *unicode = (uint32_t)-1;
+	return 1;
+    }
+    UTF8_GET (result, p, i, mask, len);
+
+    if (unicode)
+	*unicode = result;
+    return len;
+}
+
+/**
  * _cairo_utf8_to_utf32:
  * @str: an UTF-8 string
  * @len: length of @str in bytes, or -1 if it is nul-terminated.
  *   If @len is supplied and the string has an embedded nul
  *   byte, only the portion before the nul byte is converted.
@@ -264,11 +298,11 @@ _cairo_utf8_to_ucs4 (const char *str,
 
 /**
  * _cairo_ucs4_to_utf8:
  * @unicode: a UCS-4 character
  * @utf8: buffer to write utf8 string into. Must have at least 4 bytes
- * space available.
+ * space available. Or %NULL.
  *
  * Return value: Number of bytes in the utf8 string or 0 if an invalid
  * unicode character
  **/
 int
@@ -277,21 +311,25 @@ _cairo_ucs4_to_utf8 (uint32_t  unicode,
 {
     int bytes;
     char *p;
 
     if (unicode < 0x80) {
-	*utf8 = unicode;
+	if (utf8)
+	    *utf8 = unicode;
 	return 1;
     } else if (unicode < 0x800) {
 	bytes = 2;
     } else if (unicode < 0x10000) {
 	bytes = 3;
     } else if (unicode < 0x200000) {
 	bytes = 4;
     } else {
 	return 0;
     }
+
+    if (!utf8)
+	return bytes;
 
     p = utf8 + bytes;
     while (p > utf8) {
 	*--p = 0x80 | (unicode & 0x3f);
 	unicode >>= 6;
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-user-font-private.h
--- a/gfx/cairo/cairo/src/cairo-user-font-private.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-user-font-private.h	Mon Sep 08 10:35:45 2008 +0300
@@ -36,10 +36,11 @@
 
 #ifndef CAIRO_USER_FONT_PRIVATE_H
 #define CAIRO_USER_FONT_PRIVATE_H
 
 #include "cairo.h"
+#include "cairo-compiler-private.h"
 
 cairo_private cairo_bool_t
 _cairo_font_face_is_user (cairo_font_face_t *font_face);
 
 #endif /* CAIRO_USER_FONT_PRIVATE_H */
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-user-font.c
--- a/gfx/cairo/cairo/src/cairo-user-font.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-user-font.c	Mon Sep 08 10:35:45 2008 +0300
@@ -72,10 +72,32 @@ typedef struct _cairo_user_scaled_font {
 
 } cairo_user_scaled_font_t;
 
 /* #cairo_user_scaled_font_t */
 
+static cairo_t *
+_cairo_user_scaled_font_create_meta_context (cairo_user_scaled_font_t *scaled_font)
+{
+    cairo_content_t content;
+    cairo_surface_t *meta_surface;
+    cairo_t *cr;
+
+    content = scaled_font->base.options.antialias == CAIRO_ANTIALIAS_SUBPIXEL ?
+						     CAIRO_CONTENT_COLOR_ALPHA :
+						     CAIRO_CONTENT_ALPHA;
+
+    meta_surface = _cairo_meta_surface_create (content, -1, -1);
+    cr = cairo_create (meta_surface);
+    cairo_surface_destroy (meta_surface);
+
+    cairo_set_matrix (cr, &scaled_font->base.scale);
+    cairo_set_font_size (cr, 1.0);
+    cairo_set_font_options (cr, &scaled_font->base.options);
+
+    return cr;
+}
+
 static const cairo_scaled_font_backend_t cairo_user_scaled_font_backend;
 
 static cairo_int_status_t
 _cairo_user_scaled_glyph_init (void			 *abstract_font,
 			       cairo_scaled_glyph_t	 *scaled_glyph,
@@ -87,31 +109,25 @@ _cairo_user_scaled_glyph_init (void			 *
 
     if (!scaled_glyph->meta_surface) {
 	cairo_user_font_face_t *face =
 	    (cairo_user_font_face_t *) scaled_font->base.font_face;
 	cairo_text_extents_t extents = scaled_font->default_glyph_extents;
-	cairo_content_t content = scaled_font->base.options.antialias == CAIRO_ANTIALIAS_SUBPIXEL ?
-									 CAIRO_CONTENT_COLOR_ALPHA :
-									 CAIRO_CONTENT_ALPHA;
 	cairo_t *cr;
 
-	meta_surface = _cairo_meta_surface_create (content, -1, -1);
-	cr = cairo_create (meta_surface);
-
-	cairo_set_matrix (cr, &scaled_font->base.scale);
-	cairo_set_font_size (cr, 1.0);
-	cairo_set_font_options (cr, &scaled_font->base.options);
+	cr = _cairo_user_scaled_font_create_meta_context (scaled_font);
 
 	if (face->scaled_font_methods.render_glyph)
 	    status = face->scaled_font_methods.render_glyph ((cairo_scaled_font_t *)scaled_font,
 							     _cairo_scaled_glyph_index(scaled_glyph),
 							     cr, &extents);
 	else
 	    status = CAIRO_STATUS_USER_FONT_ERROR;
 
 	if (status == CAIRO_STATUS_SUCCESS)
 	    status = cairo_status (cr);
+
+	meta_surface = cairo_surface_reference (cairo_get_target (cr));
 
 	cairo_destroy (cr);
 
 	if (status) {
 	    cairo_surface_destroy (meta_surface);
@@ -129,18 +145,24 @@ _cairo_user_scaled_glyph_init (void			 *
 	    /* Compute extents.x/y/width/height from meta_surface, in font space */
 
 	    cairo_box_t bbox;
 	    double x1, y1, x2, y2;
 	    double x_scale, y_scale;
-	    cairo_surface_t *null_surface = _cairo_null_surface_create (cairo_surface_get_content (meta_surface));
-	    cairo_surface_t *analysis_surface = _cairo_analysis_surface_create (null_surface, -1, -1);
+	    cairo_surface_t *null_surface;
+	    cairo_surface_t *analysis_surface;
+
+	    null_surface = _cairo_null_surface_create (cairo_surface_get_content (meta_surface));
+	    analysis_surface = _cairo_analysis_surface_create (null_surface, -1, -1);
 	    cairo_surface_destroy (null_surface);
 
 	    _cairo_analysis_surface_set_ctm (analysis_surface, &scaled_font->extent_scale);
 	    status = _cairo_meta_surface_replay (meta_surface, analysis_surface);
 	    _cairo_analysis_surface_get_bounding_box (analysis_surface, &bbox);
 	    cairo_surface_destroy (analysis_surface);
+
+	    if (status)
+		return status;
 
 	    _cairo_box_to_doubles (&bbox, &x1, &y1, &x2, &y2);
 
 	    x_scale = scaled_font->extent_x_scale;
 	    y_scale = scaled_font->extent_y_scale;
@@ -247,44 +269,44 @@ _cairo_user_ucs4_to_index (void	    *abs
 
     return glyph;
 }
 
 static cairo_int_status_t
-_cairo_user_text_to_glyphs (void           *abstract_font,
-			    double          x,
-			    double          y,
-			    const char     *utf8,
-			    cairo_glyph_t **glyphs,
-			    int	           *num_glyphs)
+_cairo_user_text_to_glyphs (void		 *abstract_font,
+			    double		  x,
+			    double		  y,
+			    const char		 *utf8,
+			    int			  utf8_len,
+			    cairo_glyph_t	**glyphs,
+			    int			  *num_glyphs,
+			    cairo_text_cluster_t **clusters,
+			    int			  *num_clusters,
+			    cairo_bool_t	  *backward)
 {
     cairo_int_status_t status = CAIRO_INT_STATUS_UNSUPPORTED;
 
     cairo_user_scaled_font_t *scaled_font = abstract_font;
     cairo_user_font_face_t *face =
 	(cairo_user_font_face_t *) scaled_font->base.font_face;
 
     if (face->scaled_font_methods.text_to_glyphs) {
 	int i;
+	int orig_num_glyphs = *num_glyphs;
 
-	*glyphs = NULL;
-	*num_glyphs = -1;
+	status = face->scaled_font_methods.text_to_glyphs (&scaled_font->base,
+							   utf8, utf8_len,
+							   glyphs, num_glyphs,
+							   clusters, num_clusters,
+							   backward);
 
-	/* XXX currently user allocs glyphs array but cairo frees it */
-	status = face->scaled_font_methods.text_to_glyphs (&scaled_font->base,
-							   utf8, glyphs, num_glyphs);
+	if (status != CAIRO_STATUS_SUCCESS)
+	    return status;
 
-	if (status != CAIRO_STATUS_SUCCESS) {
-	    status = _cairo_scaled_font_set_error (&scaled_font->base, status);
-	    if (*glyphs) {
-		free (*glyphs);
-		*glyphs = NULL;
-	    }
-	    return status;
+	if (*num_glyphs < 0) {
+	    *num_glyphs = orig_num_glyphs;
+	    return CAIRO_INT_STATUS_UNSUPPORTED;
 	}
-
-	if (*num_glyphs < 0)
-	    return CAIRO_INT_STATUS_UNSUPPORTED;
 
 	/* Convert from font space to user space and add x,y */
 	for (i = 0; i < *num_glyphs; i++) {
 	    double gx = (*glyphs)[i].x;
 	    double gy = (*glyphs)[i].y;
@@ -349,11 +371,11 @@ _cairo_user_font_face_scaled_font_create
      * representation. */
     {
 	double fixed_scale, x_scale, y_scale;
 
 	user_scaled_font->extent_scale = user_scaled_font->base.scale_inverse;
-	status = _cairo_matrix_compute_scale_factors (&user_scaled_font->extent_scale,
+	status = _cairo_matrix_compute_basis_scale_factors (&user_scaled_font->extent_scale,
 						      &x_scale, &y_scale,
 						      1);
 	if (status == CAIRO_STATUS_SUCCESS) {
 
 	    if (x_scale == 0) x_scale = 1.;
@@ -375,19 +397,29 @@ _cairo_user_font_face_scaled_font_create
 	}
     }
 
     if (status == CAIRO_STATUS_SUCCESS && font_face->scaled_font_methods.init != NULL) {
 
+	cairo_t *cr;
+
 	/* Lock the scaled_font mutex such that user doesn't accidentally try
          * to use it just yet. */
 	CAIRO_MUTEX_LOCK (user_scaled_font->base.mutex);
 
 	/* Give away fontmap lock such that user-font can use other fonts */
 	_cairo_scaled_font_register_placeholder_and_unlock_font_map (&user_scaled_font->base);
 
+	cr = _cairo_user_scaled_font_create_meta_context (user_scaled_font);
+
 	status = font_face->scaled_font_methods.init (&user_scaled_font->base,
+						      cr,
 						      &font_extents);
+
+	if (status == CAIRO_STATUS_SUCCESS)
+	    status = cairo_status (cr);
+
+	cairo_destroy (cr);
 
 	_cairo_scaled_font_unregister_placeholder_and_lock_font_map (&user_scaled_font->base);
 
 	CAIRO_MUTEX_UNLOCK (user_scaled_font->base.mutex);
     }
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-version.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/cairo/cairo/src/cairo-version.c	Mon Sep 08 10:35:45 2008 +0300
@@ -0,0 +1,88 @@
+/* -*- Mode: c; c-basic-offset: 4; indent-tabs-mode: t; tab-width: 8; -*- */
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2002 University of Southern California
+ * Copyright © 2005 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is University of Southern
+ * California.
+ *
+ * Contributor(s):
+ *	Carl D. Worth <cworth@cworth.org>
+ */
+
+#define CAIRO_VERSION_H 1
+
+#include "cairoint.h"
+
+/* get the "real" version info instead of dummy cairo-version.h */
+#undef CAIRO_VERSION_H
+#include "cairo-features.h"
+
+/**
+ * cairo_version:
+ *
+ * Returns the version of the cairo library encoded in a single
+ * integer as per %CAIRO_VERSION_ENCODE. The encoding ensures that
+ * later versions compare greater than earlier versions.
+ *
+ * A run-time comparison to check that cairo's version is greater than
+ * or equal to version X.Y.Z could be performed as follows:
+ *
+ * <informalexample><programlisting>
+ * if (cairo_version() >= CAIRO_VERSION_ENCODE(X,Y,Z)) {...}
+ * </programlisting></informalexample>
+ *
+ * See also cairo_version_string() as well as the compile-time
+ * equivalents %CAIRO_VERSION and %CAIRO_VERSION_STRING.
+ *
+ * Return value: the encoded version.
+ **/
+int
+cairo_version (void)
+{
+    return CAIRO_VERSION;
+}
+
+/**
+ * cairo_version_string:
+ *
+ * Returns the version of the cairo library as a human-readable string
+ * of the form "X.Y.Z".
+ *
+ * See also cairo_version() as well as the compile-time equivalents
+ * %CAIRO_VERSION_STRING and %CAIRO_VERSION.
+ *
+ * Return value: a string containing the version.
+ **/
+const char*
+cairo_version_string (void)
+{
+    return CAIRO_VERSION_STRING;
+}
+slim_hidden_def (cairo_version_string);
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-version.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/cairo/cairo/src/cairo-version.h	Mon Sep 08 10:35:45 2008 +0300
@@ -0,0 +1,16 @@
+/* This is a dummy file.
+ * The actual version info is in toplevel cairo-version.h.
+ * The purpose of this file is to make most of the source files NOT depend
+ * on the real cairo-version.h, and as a result, changing library version
+ * would not cause a complete rebuild of all object files (just a relink).
+ * This is useful when bisecting. */
+#ifndef CAIRO_VERSION_H
+#define CAIRO_VERSION_H
+
+#if 0
+#define CAIRO_VERSION_MAJOR USE_cairo_version_OR_cairo_version_string_INSTEAD
+#define CAIRO_VERSION_MINOR USE_cairo_version_OR_cairo_version_string_INSTEAD
+#define CAIRO_VERSION_MICRO USE_cairo_version_OR_cairo_version_string_INSTEAD
+#endif
+
+#endif
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-wideint-type-private.h
--- a/gfx/cairo/cairo/src/cairo-wideint-type-private.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-wideint-type-private.h	Mon Sep 08 10:35:45 2008 +0300
@@ -57,27 +57,28 @@
   typedef __int64 int64_t;
   typedef unsigned __int64 uint64_t;
 # ifndef HAVE_UINT64_T
 #  define HAVE_UINT64_T 1
 # endif
-# ifndef INT16_MIN
-#  define INT16_MIN	(-32767-1)
-# endif
-# ifndef INT16_MAX
-#  define INT16_MAX	(32767)
-# endif
-# ifndef UINT16_MAX
-#  define UINT16_MAX	(65535)
-# endif
-# ifndef INT32_MIN
-#  define INT32_MIN	(-2147483647-1)
-# endif
-# ifndef INT32_MAX
-#  define INT32_MAX	(2147483647)
-# endif
 #else
 #error Cannot find definitions for fixed-width integral types (uint8_t, uint32_t, etc.)
+#endif
+
+#ifndef INT16_MIN
+# define INT16_MIN	(-32767-1)
+#endif
+#ifndef INT16_MAX
+# define INT16_MAX	(32767)
+#endif
+#ifndef UINT16_MAX
+# define UINT16_MAX	(65535)
+#endif
+#ifndef INT32_MIN
+# define INT32_MIN	(-2147483647-1)
+#endif
+#ifndef INT32_MAX
+# define INT32_MAX	(2147483647)
 #endif
 
 #if HAVE_BYTESWAP_H
 # include <byteswap.h>
 #endif
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-win32-font.c
--- a/gfx/cairo/cairo/src/cairo-win32-font.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-win32-font.c	Mon Sep 08 10:35:45 2008 +0300
@@ -128,10 +128,32 @@ _cairo_win32_scaled_font_init_glyph_path
 _cairo_win32_scaled_font_init_glyph_path (cairo_win32_scaled_font_t *scaled_font,
 					  cairo_scaled_glyph_t      *scaled_glyph);
 
 #define NEARLY_ZERO(d) (fabs(d) < (1. / 65536.))
 
+static HDC
+_get_global_font_dc (void)
+{
+    static HDC hdc;
+
+    if (!hdc) {
+	hdc = CreateCompatibleDC (NULL);
+	if (!hdc) {
+	    _cairo_win32_print_gdi_error ("_get_global_font_dc");
+	    return NULL;
+	}
+
+	if (!SetGraphicsMode (hdc, GM_ADVANCED)) {
+	    _cairo_win32_print_gdi_error ("_get_global_font_dc");
+	    DeleteDC (hdc);
+	    return NULL;
+	}
+    }
+
+    return hdc;
+}
+
 static cairo_status_t
 _compute_transform (cairo_win32_scaled_font_t *scaled_font,
 		    cairo_matrix_t            *sc)
 {
     cairo_status_t status;
@@ -173,11 +195,11 @@ _compute_transform (cairo_win32_scaled_f
      */
     cairo_matrix_init (&scaled_font->logical_to_device,
 		       sc->xx, sc->yx, sc->xy, sc->yy, 0, 0);
 
     if (!scaled_font->preserve_axes) {
-	status = _cairo_matrix_compute_scale_factors (&scaled_font->logical_to_device,
+	status = _cairo_matrix_compute_basis_scale_factors (&scaled_font->logical_to_device,
 						      &scaled_font->x_scale, &scaled_font->y_scale,
 						      TRUE);	/* XXX: Handle vertical text */
 	if (status)
 	    return status;
 
@@ -257,13 +279,18 @@ _win32_scaled_font_create (LOGFONTW     
 			   const cairo_matrix_t       *font_matrix,
 			   const cairo_matrix_t       *ctm,
 			   const cairo_font_options_t *options,
 			   cairo_scaled_font_t       **font_out)
 {
+    HDC hdc;
     cairo_win32_scaled_font_t *f;
     cairo_matrix_t scale;
     cairo_status_t status;
+
+    hdc = _get_global_font_dc ();
+    if (hdc == NULL)
+	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
 
     f = malloc (sizeof(cairo_win32_scaled_font_t));
     if (f == NULL)
 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
 
@@ -361,88 +388,63 @@ _win32_scaled_font_set_identity_transfor
 	return _cairo_win32_print_gdi_error ("_win32_scaled_font_set_identity_transform");
 
     return CAIRO_STATUS_SUCCESS;
 }
 
-static HDC
-_get_global_font_dc (void)
-{
-    static HDC hdc;
-
-    if (!hdc) {
-	hdc = CreateCompatibleDC (NULL);
-	if (!hdc) {
-	    _cairo_win32_print_gdi_error ("_get_global_font_dc");
-	    return NULL;
-	}
-
-	if (!SetGraphicsMode (hdc, GM_ADVANCED)) {
-	    _cairo_win32_print_gdi_error ("_get_global_font_dc");
-	    DeleteDC (hdc);
-	    return NULL;
-	}
-    }
-
-    return hdc;
-}
-
-static HFONT
-_win32_scaled_font_get_scaled_hfont (cairo_win32_scaled_font_t *scaled_font)
+static cairo_status_t
+_win32_scaled_font_get_scaled_hfont (cairo_win32_scaled_font_t *scaled_font,
+				     HFONT *hfont_out)
 {
     if (!scaled_font->scaled_hfont) {
 	LOGFONTW logfont = scaled_font->logfont;
 	logfont.lfHeight = -scaled_font->logical_size;
 	logfont.lfWidth = 0;
 	logfont.lfEscapement = 0;
 	logfont.lfOrientation = 0;
 	logfont.lfQuality = scaled_font->quality;
 
 	scaled_font->scaled_hfont = CreateFontIndirectW (&logfont);
-	if (!scaled_font->scaled_hfont) {
-	    _cairo_win32_print_gdi_error ("_win32_scaled_font_get_scaled_hfont");
-	    return NULL;
-	}
+	if (!scaled_font->scaled_hfont)
+	    return _cairo_win32_print_gdi_error ("_win32_scaled_font_get_scaled_hfont");
     }
 
-    return scaled_font->scaled_hfont;
+    *hfont_out = scaled_font->scaled_hfont;
+    return CAIRO_STATUS_SUCCESS;
 }
 
-static HFONT
+static cairo_status_t
 _win32_scaled_font_get_unscaled_hfont (cairo_win32_scaled_font_t *scaled_font,
-				       HDC                        hdc)
+				       HDC                        hdc,
+				       HFONT			 *hfont_out)
 {
-    if (!scaled_font->unscaled_hfont) {
+    if (scaled_font->unscaled_hfont == NULL) {
 	OUTLINETEXTMETRIC *otm;
 	unsigned int otm_size;
 	HFONT scaled_hfont;
 	LOGFONTW logfont;
+	cairo_status_t status;
 
-	scaled_hfont = _win32_scaled_font_get_scaled_hfont (scaled_font);
-	if (!scaled_hfont)
-	    return NULL;
+	status = _win32_scaled_font_get_scaled_hfont (scaled_font,
+						      &scaled_hfont);
+	if (status)
+	    return status;
 
-	if (!SelectObject (hdc, scaled_hfont)) {
-	    _cairo_win32_print_gdi_error ("_win32_scaled_font_get_unscaled_hfont:SelectObject");
-	    return NULL;
-	}
+	if (! SelectObject (hdc, scaled_hfont))
+	    return _cairo_win32_print_gdi_error ("_win32_scaled_font_get_unscaled_hfont:SelectObject");
 
 	otm_size = GetOutlineTextMetrics (hdc, 0, NULL);
-	if (!otm_size) {
-	    _cairo_win32_print_gdi_error ("_win32_scaled_font_get_unscaled_hfont:GetOutlineTextMetrics");
-	    return NULL;
-	}
+	if (! otm_size)
+	    return _cairo_win32_print_gdi_error ("_win32_scaled_font_get_unscaled_hfont:GetOutlineTextMetrics");
 
 	otm = malloc (otm_size);
-	if (!otm) {
-	    _cairo_error_throw (CAIRO_STATUS_NO_MEMORY);
-	    return NULL;
-	}
+	if (otm == NULL)
+	    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
 
-	if (!GetOutlineTextMetrics (hdc, otm_size, otm)) {
-	    _cairo_win32_print_gdi_error ("_win32_scaled_font_get_unscaled_hfont:GetOutlineTextMetrics");
+	if (! GetOutlineTextMetrics (hdc, otm_size, otm)) {
+	    status = _cairo_win32_print_gdi_error ("_win32_scaled_font_get_unscaled_hfont:GetOutlineTextMetrics");
 	    free (otm);
-	    return NULL;
+	    return status;
 	}
 
 	scaled_font->em_square = otm->otmEMSquare;
 	free (otm);
 
@@ -452,30 +454,29 @@ _win32_scaled_font_get_unscaled_hfont (c
 	logfont.lfEscapement = 0;
 	logfont.lfOrientation = 0;
 	logfont.lfQuality = scaled_font->quality;
 
 	scaled_font->unscaled_hfont = CreateFontIndirectW (&logfont);
-	if (!scaled_font->unscaled_hfont) {
-	    _cairo_win32_print_gdi_error ("_win32_scaled_font_get_unscaled_hfont:CreateIndirect");
-	    return NULL;
-	}
+	if (! scaled_font->unscaled_hfont)
+	    return _cairo_win32_print_gdi_error ("_win32_scaled_font_get_unscaled_hfont:CreateIndirect");
     }
 
-    return scaled_font->unscaled_hfont;
+    *hfont_out = scaled_font->unscaled_hfont;
+    return CAIRO_STATUS_SUCCESS;
 }
 
 static cairo_status_t
 _cairo_win32_scaled_font_select_unscaled_font (cairo_scaled_font_t *scaled_font,
 					       HDC                  hdc)
 {
     cairo_status_t status;
     HFONT hfont;
     HFONT old_hfont = NULL;
 
-    hfont = _win32_scaled_font_get_unscaled_hfont ((cairo_win32_scaled_font_t *)scaled_font, hdc);
-    if (!hfont)
-	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+    status = _win32_scaled_font_get_unscaled_hfont ((cairo_win32_scaled_font_t *)scaled_font, hdc, &hfont);
+    if (status)
+	return status;
 
     old_hfont = SelectObject (hdc, hfont);
     if (!old_hfont)
 	return _cairo_win32_print_gdi_error ("_cairo_win32_scaled_font_select_unscaled_font");
 
@@ -613,11 +614,11 @@ _cairo_win32_scaled_font_type1_text_to_g
 {
     uint16_t *utf16;
     int n16;
     int i;
     WORD *glyph_indices = NULL;
-    cairo_status_t status = CAIRO_STATUS_SUCCESS;
+    cairo_status_t status;
     double x_pos, y_pos;
     HDC hdc = NULL;
     cairo_matrix_t mat;
 
     status = _cairo_utf8_to_utf16 (utf8, -1, &utf16, &n16);
@@ -629,14 +630,11 @@ _cairo_win32_scaled_font_type1_text_to_g
 	status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
 	goto FAIL1;
     }
 
     hdc = _get_global_font_dc ();
-    if (!hdc) {
-	status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
-	goto FAIL2;
-    }
+    assert (hdc != NULL);
 
     status = cairo_win32_scaled_font_select_font (&scaled_font->base, hdc);
     if (status)
 	goto FAIL2;
 
@@ -653,11 +651,12 @@ _cairo_win32_scaled_font_type1_text_to_g
     }
 
     x_pos = x;
     y_pos = y;
     mat = scaled_font->base.ctm;
-    cairo_matrix_invert (&mat);
+    status = cairo_matrix_invert (&mat);
+    assert (status == CAIRO_STATUS_SUCCESS);
     for (i = 0; i < n16; i++) {
 	cairo_scaled_glyph_t *scaled_glyph;
 
 	(*glyphs)[i].index = glyph_indices[i];
 	(*glyphs)[i].x = x_pos;
@@ -702,11 +701,11 @@ _cairo_win32_scaled_font_text_to_glyphs 
     int n16;
     GCP_RESULTSW gcp_results;
     unsigned int buffer_size, i;
     WCHAR *glyph_indices = NULL;
     int *dx = NULL;
-    cairo_status_t status = CAIRO_STATUS_SUCCESS;
+    cairo_status_t status;
     double x_pos, y_pos;
     double x_incr, y_incr;
     HDC hdc = NULL;
 
     /* GetCharacterPlacement() returns utf16 instead of glyph indices
@@ -741,14 +740,11 @@ _cairo_win32_scaled_font_text_to_glyphs 
 	status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
 	goto FAIL1;
     }
 
     hdc = _get_global_font_dc ();
-    if (!hdc) {
-	status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
-	goto FAIL1;
-    }
+    assert (hdc != NULL);
 
     status = cairo_win32_scaled_font_select_font (&scaled_font->base, hdc);
     if (status)
 	goto FAIL1;
 
@@ -784,11 +780,11 @@ _cairo_win32_scaled_font_text_to_glyphs 
 	if (gcp_results.lpDx && gcp_results.lpGlyphs)
 	    break;
 
 	/* Too small a buffer, try again */
 
-	buffer_size *= 1.5;
+	buffer_size += buffer_size / 2;
 	if (buffer_size > INT_MAX) {
 	    status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
 	    goto FAIL2;
 	}
     }
@@ -824,22 +820,50 @@ _cairo_win32_scaled_font_text_to_glyphs 
     free (utf16);
 
     return status;
 }
 
+static unsigned long
+_cairo_win32_scaled_font_ucs4_to_index (void		*abstract_font,
+					uint32_t	 ucs4)
+{
+    cairo_win32_scaled_font_t *scaled_font = abstract_font;
+    wchar_t unicode[2];
+    WORD glyph_index;
+    HDC hdc = NULL;
+    cairo_status_t status;
+
+    hdc = _get_global_font_dc ();
+    assert (hdc != NULL);
+
+    status = cairo_win32_scaled_font_select_font (&scaled_font->base, hdc);
+    if (status)
+	return 0;
+
+    unicode[0] = ucs4;
+    unicode[1] = 0;
+    if (GetGlyphIndicesW (hdc, unicode, 1, &glyph_index, 0) == GDI_ERROR) {
+	_cairo_win32_print_gdi_error ("_cairo_win32_scaled_font_ucs4_to_index:GetGlyphIndicesW");
+	glyph_index = 0;
+    }
+
+    cairo_win32_scaled_font_done_font (&scaled_font->base);
+
+    return glyph_index;
+}
+
 static cairo_status_t
 _cairo_win32_scaled_font_set_metrics (cairo_win32_scaled_font_t *scaled_font)
 {
     cairo_status_t status;
     cairo_font_extents_t extents;
 
     TEXTMETRIC metrics;
     HDC hdc;
 
     hdc = _get_global_font_dc ();
-    if (!hdc)
-	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+    assert (hdc != NULL);
 
     if (scaled_font->preserve_axes || scaled_font->base.options.hint_metrics == CAIRO_HINT_METRICS_OFF) {
 	/* For 90-degree rotations (including 0), we get the metrics
 	 * from the GDI in logical space, then convert back to font space
 	 */
@@ -910,29 +934,31 @@ _cairo_win32_scaled_font_init_glyph_metr
     cairo_status_t status;
     cairo_text_extents_t extents;
     HDC hdc;
 
     hdc = _get_global_font_dc ();
-    if (!hdc)
-	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+    assert (hdc != NULL);
 
     if (scaled_font->is_bitmap) {
 	/* GetGlyphOutline will not work. Assume that the glyph does not extend outside the font box. */
 	cairo_font_extents_t font_extents;
 	INT width = 0;
 	UINT charIndex = _cairo_scaled_glyph_index (scaled_glyph);
 
 	cairo_scaled_font_extents (&scaled_font->base, &font_extents);
 
 	status = cairo_win32_scaled_font_select_font (&scaled_font->base, hdc);
-	if (!status) {
-	    if (!GetCharWidth32(hdc, charIndex, charIndex, &width)) {
-		status = _cairo_win32_print_gdi_error ("_cairo_win32_scaled_font_init_glyph_metrics:GetCharWidth32");
-		width = 0;
-	    }
+	if (status)
+	    return status;
+
+	if (!GetCharWidth32(hdc, charIndex, charIndex, &width)) {
+	    status = _cairo_win32_print_gdi_error ("_cairo_win32_scaled_font_init_glyph_metrics:GetCharWidth32");
+	    width = 0;
 	}
 	cairo_win32_scaled_font_done_font (&scaled_font->base);
+	if (status)
+	    return status;
 
 	extents.x_bearing = 0;
 	extents.y_bearing = scaled_font->base.ctm.yy * (-font_extents.ascent / scaled_font->y_scale);
 	extents.width = width / (WIN32_FONT_LOGICAL_SCALE * scaled_font->x_scale);
 	extents.height = scaled_font->base.ctm.yy * (font_extents.ascent + font_extents.descent) / scaled_font->y_scale;
@@ -943,17 +969,20 @@ _cairo_win32_scaled_font_init_glyph_metr
 	 * from the GDI in device space and convert to font space.
 	 */
 	status = cairo_win32_scaled_font_select_font (&scaled_font->base, hdc);
 	if (status)
 	    return status;
+
 	if (GetGlyphOutlineW (hdc, _cairo_scaled_glyph_index (scaled_glyph),
 			      GGO_METRICS | GGO_GLYPH_INDEX,
 			      &metrics, 0, NULL, &matrix) == GDI_ERROR) {
 	  status = _cairo_win32_print_gdi_error ("_cairo_win32_scaled_font_init_glyph_metrics:GetGlyphOutlineW");
 	  memset (&metrics, 0, sizeof (GLYPHMETRICS));
 	}
 	cairo_win32_scaled_font_done_font (&scaled_font->base);
+	if (status)
+	    return status;
 
 	if (scaled_font->swap_axes) {
 	    extents.x_bearing = - metrics.gmptGlyphOrigin.y / scaled_font->y_scale;
 	    extents.y_bearing = metrics.gmptGlyphOrigin.x / scaled_font->x_scale;
 	    extents.width = metrics.gmBlackBoxY / scaled_font->y_scale;
@@ -982,17 +1011,22 @@ _cairo_win32_scaled_font_init_glyph_metr
     } else {
 	/* For all other transformations, we use the design metrics
 	 * of the font.
 	 */
 	status = _cairo_win32_scaled_font_select_unscaled_font (&scaled_font->base, hdc);
+	if (status)
+	    return status;
+
 	if (GetGlyphOutlineW (hdc, _cairo_scaled_glyph_index (scaled_glyph),
 	                      GGO_METRICS | GGO_GLYPH_INDEX,
 			      &metrics, 0, NULL, &matrix) == GDI_ERROR) {
 	  status = _cairo_win32_print_gdi_error ("_cairo_win32_scaled_font_init_glyph_metrics:GetGlyphOutlineW");
 	  memset (&metrics, 0, sizeof (GLYPHMETRICS));
 	}
 	_cairo_win32_scaled_font_done_unscaled_font (&scaled_font->base);
+	if (status)
+	    return status;
 
 	extents.x_bearing = (double)metrics.gmptGlyphOrigin.x / scaled_font->em_square;
 	extents.y_bearing = - (double)metrics.gmptGlyphOrigin.y / scaled_font->em_square;
 	extents.width = (double)metrics.gmBlackBoxX / scaled_font->em_square;
 	extents.height = (double)metrics.gmBlackBoxY / scaled_font->em_square;
@@ -1022,17 +1056,17 @@ _cairo_win32_scaled_font_glyph_bbox (voi
     static const MAT2 matrix = { { 0, 1 }, { 0, 0 }, { 0, 0 }, { 0, 1 } };
     cairo_win32_scaled_font_t *scaled_font = abstract_font;
     int x1 = 0, x2 = 0, y1 = 0, y2 = 0;
 
     if (num_glyphs > 0) {
-	HDC hdc = _get_global_font_dc ();
+	HDC hdc;
 	GLYPHMETRICS metrics;
 	cairo_status_t status;
 	int i;
 
-	if (!hdc)
-	    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+	hdc = _get_global_font_dc ();
+	assert (hdc != NULL);
 
 	status = cairo_win32_scaled_font_select_font (&scaled_font->base, hdc);
 	if (status)
 	    return status;
 
@@ -1162,31 +1196,34 @@ _add_glyph (cairo_glyph_state_t *state,
 	return status;
 
     return CAIRO_STATUS_SUCCESS;
 }
 
-static void
+static cairo_status_t
 _finish_glyphs (cairo_glyph_state_t *state)
 {
-    /* ignore errors as we only call _finish_glyphs on the error path */
-    _flush_glyphs (state);
+    cairo_status_t status;
+
+    status = _flush_glyphs (state);
 
     _cairo_array_fini (&state->glyphs);
     _cairo_array_fini (&state->dx);
+
+    return status;
 }
 
 static cairo_status_t
 _draw_glyphs_on_surface (cairo_win32_surface_t     *surface,
 			 cairo_win32_scaled_font_t *scaled_font,
 			 COLORREF                   color,
 			 int                        x_offset,
 			 int                        y_offset,
 			 const cairo_glyph_t       *glyphs,
-			 int                 	    num_glyphs)
+			 int			    num_glyphs)
 {
     cairo_glyph_state_t state;
-    cairo_status_t status = CAIRO_STATUS_SUCCESS;
+    cairo_status_t status, status2;
     int i;
 
     if (!SaveDC (surface->dc))
 	return _cairo_win32_print_gdi_error ("_draw_glyphs_on_surface:SaveDC");
 
@@ -1206,11 +1243,14 @@ _draw_glyphs_on_surface (cairo_win32_sur
 	if (status)
 	    goto FAIL2;
     }
 
  FAIL2:
-    _finish_glyphs (&state);
+    status2 = _finish_glyphs (&state);
+    if (status == CAIRO_STATUS_SUCCESS)
+	status = status2;
+
     cairo_win32_scaled_font_done_font (&scaled_font->base);
  FAIL1:
     RestoreDC (surface->dc, -1);
 
     return status;
@@ -1258,14 +1298,17 @@ _compute_a8_mask (cairo_win32_surface_t 
 {
     cairo_image_surface_t *image24 = (cairo_image_surface_t *)mask_surface->image;
     cairo_image_surface_t *image8;
     int i, j;
 
+    if (image24->base.status)
+	return cairo_surface_reference (&image24->base);
+
     image8 = (cairo_image_surface_t *)cairo_image_surface_create (CAIRO_FORMAT_A8,
 								  image24->width, image24->height);
     if (image8->base.status)
-	return NULL;
+	return &image8->base;
 
     for (i = 0; i < image24->height; i++) {
 	uint32_t *p = (uint32_t *) (image24->data + i * image24->stride);
 	unsigned char *q = (unsigned char *) (image8->data + i * image8->stride);
 
@@ -1400,12 +1443,13 @@ _cairo_win32_scaled_font_show_glyphs (vo
 	    pixman_image_set_component_alpha (((cairo_image_surface_t *)tmp_surface->image)->pixman_image, TRUE);
 
 	} else {
 	    mask_surface = _compute_a8_mask (tmp_surface);
 	    cairo_surface_destroy (&tmp_surface->base);
-	    if (!mask_surface)
-		return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+	    status = mask_surface->status;
+	    if (status)
+		return status;
 	}
 
 	/* For op == OVER, no-cleartype, a possible optimization here is to
 	 * draw onto an intermediate ARGB32 surface and alpha-blend that with the
 	 * destination
@@ -1433,17 +1477,16 @@ _cairo_win32_scaled_font_load_truetype_t
                                              unsigned long      tag,
                                              long               offset,
                                              unsigned char     *buffer,
                                              unsigned long     *length)
 {
+    cairo_win32_scaled_font_t *scaled_font = abstract_font;
     HDC hdc;
     cairo_status_t status;
 
-    cairo_win32_scaled_font_t *scaled_font = abstract_font;
     hdc = _get_global_font_dc ();
-    if (!hdc)
-	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+    assert (hdc != NULL);
 
     tag = (tag&0x000000ff)<<24 | (tag&0x0000ff00)<<8 | (tag&0x00ff0000)>>8 | (tag&0xff000000)>>24;
     status = cairo_win32_scaled_font_select_font (&scaled_font->base, hdc);
     if (status)
 	return status;
@@ -1455,27 +1498,26 @@ _cairo_win32_scaled_font_load_truetype_t
     cairo_win32_scaled_font_done_font (&scaled_font->base);
 
     return status;
 }
 
-static cairo_status_t
-_cairo_win32_scaled_font_index_to_ucs4 (void 		*abstract_font,
+static cairo_int_status_t
+_cairo_win32_scaled_font_index_to_ucs4 (void		*abstract_font,
 					unsigned long    index,
 					uint32_t	*ucs4)
 {
     cairo_win32_scaled_font_t *scaled_font = abstract_font;
     GLYPHSET *glyph_set;
     uint16_t *utf16 = NULL;
     WORD *glyph_indices = NULL;
     HDC hdc = NULL;
     int res;
     unsigned int i, j, num_glyphs;
-    cairo_status_t status = CAIRO_STATUS_SUCCESS;
+    cairo_status_t status;
 
     hdc = _get_global_font_dc ();
-    if (!hdc)
-	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+    assert (hdc != NULL);
 
     status = cairo_win32_scaled_font_select_font (&scaled_font->base, hdc);
     if (status)
 	return status;
 
@@ -1551,11 +1593,11 @@ exit1:
 
 static cairo_status_t
 _cairo_win32_scaled_font_init_glyph_surface (cairo_win32_scaled_font_t *scaled_font,
                                              cairo_scaled_glyph_t      *scaled_glyph)
 {
-    cairo_status_t status = CAIRO_STATUS_SUCCESS;
+    cairo_status_t status;
     cairo_glyph_t glyph;
     cairo_win32_surface_t *surface;
     cairo_t *cr;
     cairo_surface_t *image;
     int width, height;
@@ -1569,27 +1611,39 @@ _cairo_win32_scaled_font_init_glyph_surf
     height = y2 - y1;
 
     surface = (cairo_win32_surface_t *)
 	cairo_win32_surface_create_with_dib (CAIRO_FORMAT_RGB24, width, height);
 
-    cr = cairo_create((cairo_surface_t *)surface);
+    cr = cairo_create (&surface->base);
     cairo_set_source_rgb (cr, 1, 1, 1);
     cairo_paint (cr);
+    status = cairo_status (cr);
     cairo_destroy(cr);
+    if (status)
+	goto FAIL;
 
     glyph.index = _cairo_scaled_glyph_index (scaled_glyph);
     glyph.x = -x1;
     glyph.y = -y1;
     status = _draw_glyphs_on_surface (surface, scaled_font, RGB(0,0,0),
                                       0, 0, &glyph, 1);
+    if (status)
+	goto FAIL;
+
     GdiFlush();
 
     image = _compute_a8_mask (surface);
-    cairo_surface_set_device_offset ((cairo_surface_t *)image, -x1, -y1);
+    status = image->status;
+    if (status)
+	goto FAIL;
+
+    cairo_surface_set_device_offset (image, -x1, -y1);
     _cairo_scaled_glyph_set_surface (scaled_glyph,
                                      &scaled_font->base,
-                                     (cairo_image_surface_t*)image);
+                                     (cairo_image_surface_t *) image);
+
+  FAIL:
     cairo_surface_destroy (&surface->base);
 
     return status;
 }
 
@@ -1621,12 +1675,11 @@ _cairo_win32_scaled_font_init_glyph_path
 
     if (scaled_font->is_bitmap)
 	return CAIRO_INT_STATUS_UNSUPPORTED;
 
     hdc = _get_global_font_dc ();
-    if (!hdc)
-        return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+    assert (hdc != NULL);
 
     path = _cairo_path_fixed_create ();
     if (!path)
 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
 
@@ -1649,11 +1702,10 @@ _cairo_win32_scaled_font_init_glyph_path
 	status = _cairo_win32_print_gdi_error ("_cairo_win32_scaled_font_glyph_path");
 	goto CLEANUP_FONT;
     }
 
     ptr = buffer = malloc (bytesGlyph);
-
     if (!buffer) {
 	status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
 	goto CLEANUP_FONT;
     }
 
@@ -1778,12 +1830,12 @@ const cairo_scaled_font_backend_t _cairo
 const cairo_scaled_font_backend_t _cairo_win32_scaled_font_backend = {
     CAIRO_FONT_TYPE_WIN32,
     _cairo_win32_scaled_font_create_toy,
     _cairo_win32_scaled_font_fini,
     _cairo_win32_scaled_font_glyph_init,
-    _cairo_win32_scaled_font_text_to_glyphs,
-    NULL,			/* ucs4_to_index */
+    NULL, /* _cairo_win32_scaled_font_text_to_glyphs, FIXME */
+    _cairo_win32_scaled_font_ucs4_to_index,
     _cairo_win32_scaled_font_show_glyphs,
     _cairo_win32_scaled_font_load_truetype_table,
     _cairo_win32_scaled_font_index_to_ucs4,
 };
 
@@ -1983,13 +2035,13 @@ cairo_win32_scaled_font_select_font (cai
     }
 
     if (scaled_font->status)
 	return scaled_font->status;
 
-    hfont = _win32_scaled_font_get_scaled_hfont ((cairo_win32_scaled_font_t *)scaled_font);
-    if (!hfont)
-	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+    status = _win32_scaled_font_get_scaled_hfont ((cairo_win32_scaled_font_t *)scaled_font, &hfont);
+    if (status)
+	return status;
 
     old_hfont = SelectObject (hdc, hfont);
     if (!old_hfont)
 	return _cairo_win32_print_gdi_error ("cairo_win32_scaled_font_select_font:SelectObject");
 
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-win32-printing-surface.c
--- a/gfx/cairo/cairo/src/cairo-win32-printing-surface.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-win32-printing-surface.c	Mon Sep 08 10:35:45 2008 +0300
@@ -49,10 +49,11 @@
 #include "cairo-paginated-private.h"
 
 #include "cairo-clip-private.h"
 #include "cairo-win32-private.h"
 #include "cairo-meta-surface-private.h"
+#include "cairo-scaled-font-subsets-private.h"
 
 #include <windows.h>
 
 #if !defined(POSTSCRIPT_IDENTIFY)
 # define POSTSCRIPT_IDENTIFY 0x1015
@@ -1311,20 +1312,18 @@ _cairo_win32_printing_surface_show_glyph
 	source = (cairo_pattern_t*) &clear;
 	op = CAIRO_OPERATOR_SOURCE;
     }
 
     if (surface->paginated_mode == CAIRO_PAGINATED_MODE_ANALYZE) {
-	/* Calling ExtTextOutW() with ETO_GLYPH_INDEX and a Type 1 or
-	 * bitmap font on a printer DC prints garbled text. The text
-	 * displays correctly on a display DC. It appears that when
-	 * using a printer DC. ExtTextOutW() only works with
-	 * characters and not glyph indices.
+	/* When printing bitmap fonts to a printer DC, Windows may
+	 * substitute an outline font for bitmap font. As the win32
+	 * font backend always uses a screen DC when obtaining the
+	 * font metrics the metrics of the substituted font will not
+	 * match the metrics that the win32 font backend returns.
 	 *
-	 * For now we don't use ExtTextOutW for Type 1 or bitmap
-	 * fonts. These fonts will go through the fallback path for
-	 * non Windows fonts. ie filled outlines for Type 1 fonts and
-	 * fallback images for bitmap fonts.
+	 * If we are printing a bitmap font, use fallback images to
+	 * ensure the font is not substituted.
 	 */
 	if (cairo_scaled_font_get_type (scaled_font) == CAIRO_FONT_TYPE_WIN32) {
 	    if (_cairo_win32_scaled_font_is_bitmap (scaled_font))
 		return CAIRO_INT_STATUS_UNSUPPORTED;
 	    else
@@ -1362,14 +1361,50 @@ _cairo_win32_printing_surface_show_glyph
 	    return opaque->status;
 	source = opaque;
     }
 
     if (cairo_scaled_font_get_type (scaled_font) == CAIRO_FONT_TYPE_WIN32 &&
-	! _cairo_win32_scaled_font_is_type1 (scaled_font) &&
 	source->type == CAIRO_PATTERN_TYPE_SOLID)
     {
 	cairo_matrix_t ctm;
+	cairo_glyph_t  *type1_glyphs = NULL;
+	cairo_scaled_font_subsets_glyph_t subset_glyph;
+
+	/* Calling ExtTextOutW() with ETO_GLYPH_INDEX and a Type 1
+	 * font on a printer DC prints garbled text. The text displays
+	 * correctly on a display DC. When using a printer
+	 * DC, ExtTextOutW() only works with characters and not glyph
+	 * indices.
+	 *
+	 * For Type 1 fonts the glyph indices are converted back to
+	 * unicode characters before calling _cairo_win32_surface_show_glyphs().
+	 *
+	 * As _cairo_win32_scaled_font_index_to_ucs4() is a slow
+	 * operation, the font subsetting function
+	 * _cairo_scaled_font_subsets_map_glyph() is used to obtain
+	 * the unicode value because it caches the reverse mapping in
+	 * the subsets.
+	 */
+	if (_cairo_win32_scaled_font_is_type1 (scaled_font)) {
+	    type1_glyphs = _cairo_malloc_ab (num_glyphs, sizeof (cairo_glyph_t));
+	    if (type1_glyphs == NULL)
+		return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+
+	    memcpy (type1_glyphs, glyphs, num_glyphs * sizeof (cairo_glyph_t));
+	    for (i = 0; i < num_glyphs; i++) {
+		status = _cairo_scaled_font_subsets_map_glyph (surface->font_subsets,
+							       scaled_font,
+							       type1_glyphs[i].index,
+							       NULL, 0,
+							       &subset_glyph);
+		if (status)
+		    return status;
+
+		type1_glyphs[i].index = subset_glyph.unicode;
+	    }
+	    glyphs = type1_glyphs;
+	}
 
 	if (surface->has_ctm) {
 	    for (i = 0; i < num_glyphs; i++)
 		cairo_matrix_transform_point (&surface->ctm, &glyphs[i].x, &glyphs[i].y);
 	    cairo_matrix_multiply (&ctm, &scaled_font->ctm, &surface->ctm);
@@ -1382,10 +1417,13 @@ _cairo_win32_printing_surface_show_glyph
 						   source, glyphs,
 						   num_glyphs, scaled_font,
 						   remaining_glyphs);
 	if (surface->has_ctm)
 	    cairo_scaled_font_destroy (scaled_font);
+
+	if (type1_glyphs != NULL)
+	    free (type1_glyphs);
 
 	return status;
     }
 
     SaveDC (surface->dc);
@@ -1529,10 +1567,15 @@ cairo_win32_printing_surface_create (HDC
     surface->bitmap = NULL;
     surface->is_dib = FALSE;
     surface->saved_dc_bitmap = NULL;
     surface->brush = NULL;
     surface->old_brush = NULL;
+    surface->font_subsets = _cairo_scaled_font_subsets_create_scaled ();
+    if (surface->font_subsets == NULL) {
+	free (surface);
+	return _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_NO_MEMORY));
+    }
 
     GetClipBox(hdc, &rect);
     surface->extents.x = rect.left;
     surface->extents.y = rect.top;
     surface->extents.width = rect.right - rect.left;
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-win32-private.h
--- a/gfx/cairo/cairo/src/cairo-win32-private.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-win32-private.h	Mon Sep 08 10:35:45 2008 +0300
@@ -90,10 +90,11 @@ typedef struct _cairo_win32_surface {
     cairo_content_t content;
     cairo_bool_t path_empty;
     cairo_bool_t has_ctm;
     cairo_matrix_t ctm;
     HBRUSH brush, old_brush;
+    cairo_scaled_font_subsets_t *font_subsets;
 } cairo_win32_surface_t;
 
 /* Surface DC flag values */
 enum {
     /* If this is a surface created for printing or not */
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-win32-surface.c
--- a/gfx/cairo/cairo/src/cairo-win32-surface.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-win32-surface.c	Mon Sep 08 10:35:45 2008 +0300
@@ -48,10 +48,11 @@
 #include "cairoint.h"
 
 #include "cairo-clip-private.h"
 #include "cairo-paginated-private.h"
 #include "cairo-win32-private.h"
+#include "cairo-scaled-font-subsets-private.h"
 
 #include <windows.h>
 
 #if defined(__MINGW32__) && !defined(ETO_PDY)
 # define ETO_PDY 0x2000
@@ -357,10 +358,11 @@ _cairo_win32_surface_create_for_dc (HDC 
 
     surface->initial_clip_rgn = NULL;
     surface->had_simple_clip = FALSE;
 
     surface->extents = surface->clip_rect;
+    surface->font_subsets = NULL;
 
     _cairo_surface_init (&surface->base, &cairo_win32_surface_backend,
 			 _cairo_content_from_format (format));
 
     return &surface->base;
@@ -494,10 +496,13 @@ _cairo_win32_surface_finish (void *abstr
 	_cairo_win32_restore_initial_clip (surface);
     }
 
     if (surface->initial_clip_rgn)
 	DeleteObject (surface->initial_clip_rgn);
+
+    if (surface->font_subsets != NULL)
+	_cairo_scaled_font_subsets_destroy (surface->font_subsets);
 
     return CAIRO_STATUS_SUCCESS;
 }
 
 static cairo_status_t
@@ -1576,10 +1581,11 @@ _cairo_win32_surface_show_glyphs (void		
     cairo_matrix_t device_to_logical;
 
     int start_x, start_y;
     double user_x, user_y;
     int logical_x, logical_y;
+    unsigned int glyph_index_option;
 
     /* We can only handle win32 fonts */
     if (cairo_scaled_font_get_type (scaled_font) != CAIRO_FONT_TYPE_WIN32)
 	return CAIRO_INT_STATUS_UNSUPPORTED;
 
@@ -1661,14 +1667,28 @@ _cairo_win32_surface_show_glyphs (void		
             logical_x = next_logical_x;
             logical_y = next_logical_y;
         }
     }
 
+    /* Using glyph indices for a Type 1 font does not work on a
+     * printer DC. The win32 printing surface will convert the the
+     * glyph indices of Type 1 fonts to the unicode values.
+     */
+    if ((dst->flags & CAIRO_WIN32_SURFACE_FOR_PRINTING) &&
+	_cairo_win32_scaled_font_is_type1 (scaled_font))
+    {
+	glyph_index_option = 0;
+    }
+    else
+    {
+	glyph_index_option = ETO_GLYPH_INDEX;
+    }
+
     win_result = ExtTextOutW(dst->dc,
                              start_x,
                              start_y,
-                             ETO_GLYPH_INDEX | ETO_PDY,
+                             glyph_index_option | ETO_PDY,
                              NULL,
                              glyph_buf,
                              num_glyphs,
                              dxy_buf);
     if (!win_result) {
@@ -1729,10 +1749,11 @@ cairo_win32_surface_create (HDC hdc)
     surface->bitmap = NULL;
     surface->is_dib = FALSE;
     surface->saved_dc_bitmap = NULL;
     surface->brush = NULL;
     surface->old_brush = NULL;
+    surface->font_subsets = NULL;
 
     GetClipBox(hdc, &rect);
     surface->extents.x = rect.left;
     surface->extents.y = rect.top;
     surface->extents.width = rect.right - rect.left;
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-xlib-display.c
--- a/gfx/cairo/cairo/src/cairo-xlib-display.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-xlib-display.c	Mon Sep 08 10:35:45 2008 +0300
@@ -27,10 +27,12 @@
  *
  * The Original Code is the cairo graphics library.
  *
  * The Initial Developer of the Original Code is Chris Wilson.
  *
+ * Contributor(s):
+ *	Karl Tomlinson <karlt+@karlt.net>, Mozilla Corporation
  */
 
 #include "cairoint.h"
 
 #include "cairo-xlib-private.h"
@@ -65,43 +67,35 @@ static cairo_xlib_display_t *_cairo_xlib
 static cairo_xlib_display_t *_cairo_xlib_display_list;
 
 static int buggy_repeat_force = -1;
 
 static void
+_cairo_xlib_remove_close_display_hook_internal (cairo_xlib_display_t *display,
+						cairo_xlib_hook_t *hook);
+
+static void
 _cairo_xlib_call_close_display_hooks (cairo_xlib_display_t *display)
 {
     cairo_xlib_screen_info_t	    *screen;
-    cairo_xlib_hook_t		    *hooks, *list;
+    cairo_xlib_hook_t		    *hook;
 
     /* call all registered shutdown routines */
     CAIRO_MUTEX_LOCK (display->mutex);
 
     for (screen = display->screens; screen != NULL; screen = screen->next)
 	_cairo_xlib_screen_info_close_display (screen);
 
-    hooks = display->close_display_hooks;
-    while (hooks != NULL) {
-	display->close_display_hooks = NULL;
+    while (TRUE) {
+	hook = display->close_display_hooks;
+	if (hook == NULL)
+	    break;
+
+	_cairo_xlib_remove_close_display_hook_internal (display, hook);
+
 	CAIRO_MUTEX_UNLOCK (display->mutex);
-
-	list = hooks;
-	do {
-	    cairo_xlib_hook_t *hook = list;
-	    list = hook->next;
-
-	    hook->func (display->display, hook->data);
-	} while (list != NULL);
-
+	hook->func (display, hook);
 	CAIRO_MUTEX_LOCK (display->mutex);
-	do {
-	    cairo_xlib_hook_t *hook = hooks;
-	    hooks = hook->next;
-
-	    _cairo_freelist_free (&display->hook_freelist, hook);
-	} while (hooks != NULL);
-
-	hooks = display->close_display_hooks;
     }
     display->closed = TRUE;
 
     CAIRO_MUTEX_UNLOCK (display->mutex);
 }
@@ -151,11 +145,10 @@ _cairo_xlib_display_destroy (cairo_xlib_
 	    job->func.work.destroy (job->func.work.data);
 
 	_cairo_freelist_free (&display->wq_freelist, job);
     }
     _cairo_freelist_fini (&display->wq_freelist);
-    _cairo_freelist_fini (&display->hook_freelist);
 
     CAIRO_MUTEX_FINI (display->mutex);
 
     free (display);
 }
@@ -277,11 +270,10 @@ _cairo_xlib_display_get (Display *dpy)
     }
 
     XESetCloseDisplay (dpy, codes->extension, _cairo_xlib_close_display);
 
     _cairo_freelist_init (&display->wq_freelist, sizeof (cairo_xlib_job_t));
-    _cairo_freelist_init (&display->hook_freelist, sizeof (cairo_xlib_hook_t));
 
     CAIRO_REFERENCE_COUNT_INIT (&display->ref_count, 2); /* add one for the CloseDisplay */
     CAIRO_MUTEX_INIT (display->mutex);
     display->display = dpy;
     display->screens = NULL;
@@ -336,65 +328,47 @@ UNLOCK:
 UNLOCK:
     CAIRO_MUTEX_UNLOCK (_cairo_xlib_display_mutex);
     return display;
 }
 
-cairo_bool_t
-_cairo_xlib_add_close_display_hook (Display *dpy, void (*func) (Display *, void *), void *data, const void *key)
+void
+_cairo_xlib_add_close_display_hook (cairo_xlib_display_t	*display,
+				    cairo_xlib_hook_t		*hook)
 {
-    cairo_xlib_display_t *display;
-    cairo_xlib_hook_t *hook;
-    cairo_bool_t ret = FALSE;
+    CAIRO_MUTEX_LOCK (display->mutex);
+    hook->prev = NULL;
+    hook->next = display->close_display_hooks;
+    if (hook->next != NULL)
+	hook->next->prev = hook;
+    display->close_display_hooks = hook;
+    CAIRO_MUTEX_UNLOCK (display->mutex);
+}
 
-    display = _cairo_xlib_display_get (dpy);
-    if (display == NULL)
-	return FALSE;
+/* display->mutex must be held */
+static void
+_cairo_xlib_remove_close_display_hook_internal (cairo_xlib_display_t *display,
+						cairo_xlib_hook_t *hook)
+{
+    if (display->close_display_hooks == hook)
+	display->close_display_hooks = hook->next;
+    else if (hook->prev != NULL)
+	hook->prev->next = hook->next;
 
-    CAIRO_MUTEX_LOCK (display->mutex);
-    if (display->closed == FALSE) {
-	hook = _cairo_freelist_alloc (&display->hook_freelist);
-	if (hook != NULL) {
-	    hook->func = func;
-	    hook->data = data;
-	    hook->key = key;
+    if (hook->next != NULL)
+	hook->next->prev = hook->prev;
 
-	    hook->next = display->close_display_hooks;
-	    display->close_display_hooks = hook;
-	    ret = TRUE;
-	}
-    }
-    CAIRO_MUTEX_UNLOCK (display->mutex);
-
-    _cairo_xlib_display_destroy (display);
-
-    return ret;
+    hook->prev = NULL;
+    hook->next = NULL;
 }
 
 void
-_cairo_xlib_remove_close_display_hooks (Display *dpy, const void *key)
+_cairo_xlib_remove_close_display_hook (cairo_xlib_display_t	*display,
+				       cairo_xlib_hook_t	*hook)
 {
-    cairo_xlib_display_t *display;
-    cairo_xlib_hook_t *hook, *next, **prev;
-
-    display = _cairo_xlib_display_get (dpy);
-    if (display == NULL)
-	return;
-
     CAIRO_MUTEX_LOCK (display->mutex);
-    prev = &display->close_display_hooks;
-    for (hook = display->close_display_hooks; hook != NULL; hook = next) {
-	next = hook->next;
-	if (hook->key == key) {
-	    *prev = hook->next;
-	    _cairo_freelist_free (&display->hook_freelist, hook);
-	} else
-	    prev = &hook->next;
-    }
-    *prev = NULL;
+    _cairo_xlib_remove_close_display_hook_internal (display, hook);
     CAIRO_MUTEX_UNLOCK (display->mutex);
-
-    _cairo_xlib_display_destroy (display);
 }
 
 cairo_status_t
 _cairo_xlib_display_queue_resource (cairo_xlib_display_t *display,
 	                            cairo_xlib_notify_resource_func notify,
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-xlib-private.h
--- a/gfx/cairo/cairo/src/cairo-xlib-private.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-xlib-private.h	Mon Sep 08 10:35:45 2008 +0300
@@ -26,10 +26,14 @@
  * the specific language governing rights and limitations.
  *
  * The Original Code is the cairo graphics library.
  *
  * The Initial Developer of the Original Code is Red Hat, Inc.
+ *
+ * Contributors(s):
+ *	Chris Wilson <chris@chris-wilson.co.uk>
+ *	Karl Tomlinson <karlt+@karlt.net>, Mozilla Corporation
  */
 
 #ifndef CAIRO_XLIB_PRIVATE_H
 #define CAIRO_XLIB_PRIVATE_H
 
@@ -46,14 +50,12 @@ typedef struct _cairo_xlib_job cairo_xli
 typedef struct _cairo_xlib_job cairo_xlib_job_t;
 typedef void (*cairo_xlib_notify_func) (Display *, void *);
 typedef void (*cairo_xlib_notify_resource_func) (Display *, XID);
 
 struct _cairo_xlib_hook {
-    cairo_xlib_hook_t *next;
-    void (*func) (Display *display, void *data);
-    void *data;
-    const void *key;
+    cairo_xlib_hook_t *prev, *next; /* private */
+    void (*func) (cairo_xlib_display_t *display, void *data);
 };
 
 struct _cairo_xlib_display {
     cairo_xlib_display_t *next;
     cairo_reference_count_t ref_count;
@@ -65,11 +67,10 @@ struct _cairo_xlib_display {
     XRenderPictFormat *cached_xrender_formats[CAIRO_FORMAT_A1 + 1];
 
     cairo_xlib_job_t *workqueue;
     cairo_freelist_t wq_freelist;
 
-    cairo_freelist_t hook_freelist;
     cairo_xlib_hook_t *close_display_hooks;
     unsigned int buggy_repeat :1;
     unsigned int closed :1;
 };
 
@@ -110,14 +111,15 @@ cairo_private cairo_xlib_display_t *
 cairo_private cairo_xlib_display_t *
 _cairo_xlib_display_reference (cairo_xlib_display_t *info);
 cairo_private void
 _cairo_xlib_display_destroy (cairo_xlib_display_t *info);
 
-cairo_private cairo_bool_t
-_cairo_xlib_add_close_display_hook (Display *display, void (*func) (Display *, void *), void *data, const void *key);
 cairo_private void
-_cairo_xlib_remove_close_display_hooks (Display *display, const void *key);
+_cairo_xlib_add_close_display_hook (cairo_xlib_display_t *display, cairo_xlib_hook_t *hook);
+
+cairo_private void
+_cairo_xlib_remove_close_display_hook (cairo_xlib_display_t *display, cairo_xlib_hook_t *hook);
 
 cairo_private cairo_status_t
 _cairo_xlib_display_queue_work (cairo_xlib_display_t *display,
 	                        cairo_xlib_notify_func notify,
 				void *data,
@@ -132,11 +134,11 @@ cairo_private XRenderPictFormat *
 cairo_private XRenderPictFormat *
 _cairo_xlib_display_get_xrender_format (cairo_xlib_display_t	*display,
 	                                cairo_format_t		 format);
 
 cairo_private cairo_xlib_screen_info_t *
-_cairo_xlib_screen_info_get (Display *display, Screen *screen);
+_cairo_xlib_screen_info_get (cairo_xlib_display_t *display, Screen *screen);
 
 cairo_private cairo_xlib_screen_info_t *
 _cairo_xlib_screen_info_reference (cairo_xlib_screen_info_t *info);
 cairo_private void
 _cairo_xlib_screen_info_destroy (cairo_xlib_screen_info_t *info);
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-xlib-screen.c
--- a/gfx/cairo/cairo/src/cairo-xlib-screen.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-xlib-screen.c	Mon Sep 08 10:35:45 2008 +0300
@@ -104,21 +104,20 @@ static cairo_bool_t
 static cairo_bool_t
 get_integer_default (Display    *dpy,
 		     const char *option,
 		     int        *value)
 {
-    int i;
     char *v, *e;
 
     v = XGetDefault (dpy, "Xft", option);
     if (v) {
 #if CAIRO_HAS_FT_FONT
 	if (FcNameConstant ((FcChar8 *) v, value))
 	    return TRUE;
 #endif
 
-	i = strtol (v, &e, 0);
+	*value = strtol (v, &e, 0);
 	if (e != v)
 	    return TRUE;
     }
 
     return FALSE;
@@ -130,23 +129,44 @@ get_integer_default (Display    *dpy,
 #define FC_HINT_SLIGHT      1
 #define FC_HINT_MEDIUM      2
 #define FC_HINT_FULL        3
 #endif
 
+/* Fontconfig version older than 2.6 didn't have these options */
+#ifndef FC_LCD_FILTER
+#define FC_LCD_FILTER	"lcdfilter"
+#endif
+/* Some Ubuntu versions defined FC_LCD_FILTER without defining the following */
+#ifndef FC_LCD_NONE
+#define FC_LCD_NONE	0
+#define FC_LCD_DEFAULT	1
+#define FC_LCD_LIGHT	2
+#define FC_LCD_LEGACY	3
+#endif
+
 static void
 _cairo_xlib_init_screen_font_options (Display *dpy, cairo_xlib_screen_info_t *info)
 {
     cairo_bool_t xft_hinting;
     cairo_bool_t xft_antialias;
     int xft_hintstyle;
     int xft_rgba;
+    int xft_lcdfilter;
     cairo_antialias_t antialias;
     cairo_subpixel_order_t subpixel_order;
+    cairo_lcd_filter_t lcd_filter;
     cairo_hint_style_t hint_style;
 
     if (!get_boolean_default (dpy, "antialias", &xft_antialias))
 	xft_antialias = TRUE;
+
+    if (!get_integer_default (dpy, "lcdfilter", &xft_lcdfilter)) {
+	/* -1 is an non-existant Fontconfig constant used to differentiate
+	 * the case when no lcdfilter property is available.
+	 */
+	xft_lcdfilter = -1;
+    }
 
     if (!get_boolean_default (dpy, "hinting", &xft_hinting))
 	xft_hinting = TRUE;
 
     if (!get_integer_default (dpy, "hintstyle", &xft_hintstyle))
@@ -226,10 +246,28 @@ _cairo_xlib_init_screen_font_options (Di
     case FC_RGBA_NONE:
     default:
 	subpixel_order = CAIRO_SUBPIXEL_ORDER_DEFAULT;
     }
 
+    switch (xft_lcdfilter) {
+    case FC_LCD_NONE:
+	lcd_filter = CAIRO_LCD_FILTER_NONE;
+	break;
+    case FC_LCD_DEFAULT:
+	lcd_filter = CAIRO_LCD_FILTER_FIR5;
+	break;
+    case FC_LCD_LIGHT:
+	lcd_filter = CAIRO_LCD_FILTER_FIR3;
+	break;
+    case FC_LCD_LEGACY:
+	lcd_filter = CAIRO_LCD_FILTER_INTRA_PIXEL;
+	break;
+    default:
+	lcd_filter = CAIRO_LCD_FILTER_DEFAULT;
+	break;
+    }
+
     if (xft_antialias) {
 	if (subpixel_order == CAIRO_SUBPIXEL_ORDER_DEFAULT)
 	    antialias = CAIRO_ANTIALIAS_GRAY;
 	else
 	    antialias = CAIRO_ANTIALIAS_SUBPIXEL;
@@ -238,10 +276,11 @@ _cairo_xlib_init_screen_font_options (Di
     }
 
     cairo_font_options_set_hint_style (&info->font_options, hint_style);
     cairo_font_options_set_antialias (&info->font_options, antialias);
     cairo_font_options_set_subpixel_order (&info->font_options, subpixel_order);
+    cairo_font_options_set_lcd_filter (&info->font_options, lcd_filter);
     cairo_font_options_set_hint_metrics (&info->font_options, CAIRO_HINT_METRICS_ON);
 }
 
 cairo_xlib_screen_info_t *
 _cairo_xlib_screen_info_reference (cairo_xlib_screen_info_t *info)
@@ -305,23 +344,18 @@ _cairo_xlib_screen_info_destroy (cairo_x
 
     free (info);
 }
 
 cairo_xlib_screen_info_t *
-_cairo_xlib_screen_info_get (Display *dpy, Screen *screen)
+_cairo_xlib_screen_info_get (cairo_xlib_display_t *display, Screen *screen)
 {
-    cairo_xlib_display_t *display;
     cairo_xlib_screen_info_t *info = NULL, **prev;
-
-    display = _cairo_xlib_display_get (dpy);
-    if (display == NULL)
-	return NULL;
 
     CAIRO_MUTEX_LOCK (display->mutex);
     if (display->closed) {
 	CAIRO_MUTEX_UNLOCK (display->mutex);
-	goto DONE;
+	return NULL;
     }
 
     for (prev = &display->screens; (info = *prev); prev = &(*prev)->next) {
 	if (info->screen == screen) {
 	    /*
@@ -353,11 +387,13 @@ _cairo_xlib_screen_info_get (Display *dp
 
 	    _cairo_array_init (&info->visuals,
 			       sizeof (cairo_xlib_visual_info_t*));
 
 	    if (screen) {
+		Display *dpy = display->display;
 		int event_base, error_base;
+
 		info->has_render = (XRenderQueryExtension (dpy, &event_base, &error_base) &&
 			(XRenderFindVisualFormat (dpy, DefaultVisual (dpy, DefaultScreen (dpy))) != 0));
 		_cairo_xlib_init_screen_font_options (dpy, info);
 	    }
 
@@ -365,13 +401,10 @@ _cairo_xlib_screen_info_get (Display *dp
 	    info->next = display->screens;
 	    display->screens = info;
 	    CAIRO_MUTEX_UNLOCK (display->mutex);
 	}
     }
-
-DONE:
-    _cairo_xlib_display_destroy (display);
 
     return info;
 }
 
 static int
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-xlib-surface-private.h
--- a/gfx/cairo/cairo/src/cairo-xlib-surface-private.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-xlib-surface-private.h	Mon Sep 08 10:35:45 2008 +0300
@@ -43,11 +43,13 @@ typedef struct _cairo_xlib_surface cairo
 
 struct _cairo_xlib_surface {
     cairo_surface_t base;
 
     Display *dpy;
+    cairo_xlib_display_t *display;
     cairo_xlib_screen_info_t *screen_info;
+    cairo_xlib_hook_t close_display_hook;
 
     GC gc;
     Drawable drawable;
     Screen *screen;
     cairo_bool_t owns_pixmap;
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-xlib-surface.c
--- a/gfx/cairo/cairo/src/cairo-xlib-surface.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-xlib-surface.c	Mon Sep 08 10:35:45 2008 +0300
@@ -1,5 +1,6 @@
+/* -*- Mode: c; c-basic-offset: 4; indent-tabs-mode: t; tab-width: 8; -*- */
 /* cairo - a vector graphics library with display and print output
  *
  * Copyright © 2002 University of Southern California
  * Copyright © 2005 Red Hat, Inc.
  *
@@ -32,20 +33,24 @@
  * California.
  *
  * Contributor(s):
  *	Carl D. Worth <cworth@cworth.org>
  *	Behdad Esfahbod <behdad@behdad.org>
+ *	Chris Wilson <chris@chris-wilson.co.uk>
+ *	Karl Tomlinson <karlt+@karlt.net>, Mozilla Corporation
  */
 
 #include "cairoint.h"
 
 #include "cairo-xlib-private.h"
 #include "cairo-xlib-surface-private.h"
 #include "cairo-clip-private.h"
 #include "cairo-scaled-font-private.h"
 
 #include <X11/Xutil.h> /* for XDestroyImage */
+
+#define XLIB_COORD_MAX 32767
 
 /* Xlib doesn't define a typedef, so define one ourselves */
 typedef int (*cairo_xlib_error_func_t) (Display     *display,
 					XErrorEvent *event);
 
@@ -128,10 +133,13 @@ _cairo_xlib_surface_create_similar_with_
     Display *dpy = src->dpy;
     Pixmap pix;
     cairo_xlib_surface_t *surface;
     XRenderPictFormat *xrender_format;
 
+    if (width > XLIB_COORD_MAX || height > XLIB_COORD_MAX)
+	return NULL;
+
     /* As a good first approximation, if the display doesn't have even
      * the most elementary RENDER operation, then we're better off
      * using image surfaces for all temporary operations, so return NULL
      * and let the fallback code happen.
      */
@@ -197,10 +205,13 @@ _cairo_xlib_surface_create_similar (void
 {
     cairo_xlib_surface_t *src = abstract_src;
     XRenderPictFormat *xrender_format = src->xrender_format;
     cairo_xlib_surface_t *surface;
     Pixmap pix;
+
+    if (width > XLIB_COORD_MAX || height > XLIB_COORD_MAX)
+	return _cairo_surface_create_in_error (_cairo_error(CAIRO_STATUS_NO_MEMORY));
 
     _cairo_xlib_display_notify (src->screen_info->display);
 
     /* Start by examining the surface's XRenderFormat, or if it
      * doesn't have one, then look one up through its visual (in the
@@ -307,14 +318,17 @@ _cairo_xlib_surface_finish (void *abstra
 	free (surface->clip_rects);
 
     if (surface->screen_info != NULL)
 	_cairo_xlib_screen_info_destroy (surface->screen_info);
 
-    if (surface->dpy != NULL) {
-	_cairo_xlib_remove_close_display_hooks (surface->dpy, surface);
-	surface->dpy = NULL;
+    if (surface->display != NULL) {
+	_cairo_xlib_remove_close_display_hook (surface->display,
+					       &surface->close_display_hook);
+	_cairo_xlib_display_destroy (surface->display);
     }
+
+    surface->dpy = NULL;
 
     return status;
 }
 
 static int
@@ -635,13 +649,13 @@ _get_image_surface (cairo_xlib_surface_t
 	cairo_status_t status = _cairo_xlib_surface_ensure_gc (surface);
 	if (status)
 	    return status;
 
 	pixmap = XCreatePixmap (surface->dpy,
-				       surface->drawable,
-				       x2 - x1, y2 - y1,
-				       surface->depth);
+				surface->drawable,
+				x2 - x1, y2 - y1,
+				surface->depth);
 	if (pixmap) {
 	    XCopyArea (surface->dpy, surface->drawable, pixmap, surface->gc,
 		       x1, y1, x2 - x1, y2 - y1, 0, 0);
 
 	    ximage = XGetImage (surface->dpy,
@@ -907,24 +921,30 @@ _draw_image_surface (cairo_xlib_surface_
 
     if (image_masks.red_mask   == surface->r_mask &&
 	image_masks.green_mask == surface->g_mask &&
 	image_masks.blue_mask  == surface->b_mask)
     {
+	int ret;
+
 	ximage.bits_per_pixel = image_masks.bpp;
 	ximage.bytes_per_line = image->stride;
 	ximage.data = (char *)image->data;
 	own_data = FALSE;
-	XInitImage (&ximage);
+
+	ret = XInitImage (&ximage);
+	assert (ret != 0);
     } else {
 	unsigned int stride, rowstride;
 	int x, y, x0, y0, x_off, y_off;
 	uint32_t in_pixel, out_pixel, *row;
 	int i_a_width=0, i_r_width=0, i_g_width=0, i_b_width=0;
 	int i_a_shift=0, i_r_shift=0, i_g_shift=0, i_b_shift=0;
 	int o_a_width=0, o_r_width=0, o_g_width=0, o_b_width=0;
 	int o_a_shift=0, o_r_shift=0, o_g_shift=0, o_b_shift=0;
 	cairo_xlib_visual_info_t *visual_info = NULL;
+	cairo_bool_t true_color;
+	int ret;
 
 	if (surface->depth > 16) {
 	    ximage.bits_per_pixel = 32;
 	} else if (surface->depth > 8) {
 	    ximage.bits_per_pixel = 16;
@@ -940,69 +960,74 @@ _draw_image_surface (cairo_xlib_surface_
 	if (ximage.data == NULL)
 	    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
 
 	own_data = TRUE;
 
-	XInitImage (&ximage);
+	ret = XInitImage (&ximage);
+	assert (ret != 0);
 
 	_characterize_field (image_masks.alpha_mask, &i_a_width, &i_a_shift);
 	_characterize_field (image_masks.red_mask  , &i_r_width, &i_r_shift);
 	_characterize_field (image_masks.green_mask, &i_g_width, &i_g_shift);
 	_characterize_field (image_masks.blue_mask , &i_b_width, &i_b_shift);
 
-	if (surface->visual == NULL || surface->visual->class == TrueColor) {
-
+	true_color = surface->visual == NULL ||
+	             surface->visual->class == TrueColor;
+	if (true_color) {
 	    _characterize_field (surface->a_mask, &o_a_width, &o_a_shift);
 	    _characterize_field (surface->r_mask, &o_r_width, &o_r_shift);
 	    _characterize_field (surface->g_mask, &o_g_width, &o_g_shift);
 	    _characterize_field (surface->b_mask, &o_b_width, &o_b_shift);
-
 	} else {
-
 	    status = _cairo_xlib_screen_get_visual_info (surface->screen_info,
 							 surface->visual,
 							 &visual_info);
 	    if (status)
 		goto BAIL;
-
 	}
 
 	rowstride = cairo_image_surface_get_stride (&image->base) >> 2;
 	row = (uint32_t *) cairo_image_surface_get_data (&image->base);
 	x0 = dst_x + surface->base.device_transform.x0;
 	y0 = dst_y + surface->base.device_transform.y0;
 	for (y = 0, y_off = y0 % ARRAY_LENGTH (dither_pattern);
 	     y < ximage.height;
-	     y++, y_off = (y_off+1) % ARRAY_LENGTH (dither_pattern)) {
+	     y++, y_off = (y_off+1) % ARRAY_LENGTH (dither_pattern))
+	{
 	    const int8_t *dither_row = dither_pattern[y_off];
+
 	    for (x = 0, x_off = x0 % ARRAY_LENGTH (dither_pattern[0]);
 		 x < ximage.width;
-		 x++, x_off = (x_off+1) % ARRAY_LENGTH (dither_pattern[0])) {
+		 x++, x_off = (x_off+1) % ARRAY_LENGTH (dither_pattern[0]))
+	    {
 		int dither_adjustment = dither_row[x_off];
-
 		int a, r, g, b;
 
 		if (image_masks.bpp <= 8)
 		    in_pixel = ((uint8_t*)row)[x];
 		else if (image_masks.bpp <= 16)
 		    in_pixel = ((uint16_t*)row)[x];
 		else
 		    in_pixel = row[x];
+
 		a = _field_to_8 (in_pixel & image_masks.alpha_mask, i_a_width, i_a_shift);
 		r = _field_to_8 (in_pixel & image_masks.red_mask  , i_r_width, i_r_shift);
 		g = _field_to_8 (in_pixel & image_masks.green_mask, i_g_width, i_g_shift);
 		b = _field_to_8 (in_pixel & image_masks.blue_mask , i_b_width, i_b_shift);
-		if (surface->visual == NULL || surface->visual->class == TrueColor) {
-		    out_pixel = (_field_from_8        (a, o_a_width, o_a_shift) |
-				 _field_from_8_dither (r, o_r_width, o_r_shift, dither_adjustment) |
-				 _field_from_8_dither (g, o_g_width, o_g_shift, dither_adjustment) |
-				 _field_from_8_dither (b, o_b_width, o_b_shift, dither_adjustment));
+
+		if (true_color) {
+		    out_pixel = _field_from_8        (a, o_a_width, o_a_shift) |
+				_field_from_8_dither (r, o_r_width, o_r_shift, dither_adjustment) |
+				_field_from_8_dither (g, o_g_width, o_g_shift, dither_adjustment) |
+				_field_from_8_dither (b, o_b_width, o_b_shift, dither_adjustment);
 		} else {
 		    out_pixel = _pseudocolor_from_rgb888_dither (visual_info, r, g, b, dither_adjustment);
 		}
+
 		XPutPixel (&ximage, x, y, out_pixel);
 	    }
+
 	    row += rowstride;
 	}
     }
 
     status = _cairo_xlib_surface_ensure_gc (surface);
@@ -1129,10 +1154,13 @@ _cairo_xlib_surface_clone_similar (void	
 	cairo_image_surface_t *image_src = (cairo_image_surface_t *)src;
 
 	if (! CAIRO_FORMAT_VALID (image_src->format))
 	    return CAIRO_INT_STATUS_UNSUPPORTED;
 
+	if (image_src->width > XLIB_COORD_MAX || image_src->height > XLIB_COORD_MAX)
+	    return CAIRO_STATUS_NO_MEMORY;
+
 	clone = (cairo_xlib_surface_t *)
 	    _cairo_xlib_surface_create_similar_with_format (surface, image_src->format,
 						image_src->width, image_src->height);
 	if (clone == NULL)
 	    return CAIRO_INT_STATUS_UNSUPPORTED;
@@ -1170,35 +1198,40 @@ _cairo_xlib_surface_create_solid_pattern
     cairo_xlib_surface_t *other = abstract_surface;
     cairo_image_surface_t *image;
     cairo_xlib_surface_t *surface = NULL;
     cairo_status_t status = CAIRO_STATUS_SUCCESS;
 
-    Pixmap pixmap;
+    int width = ARRAY_LENGTH (dither_pattern[0]);
+    int height = ARRAY_LENGTH (dither_pattern);
+
+    Pixmap pixmap = None;
 
     if (CAIRO_SURFACE_RENDER_HAS_COMPOSITE (other))
 	return NULL;
 
+    if (width > XLIB_COORD_MAX || height > XLIB_COORD_MAX)
+	return NULL;
+
     image = (cairo_image_surface_t *)
 	    _cairo_image_surface_create_with_content (solid_pattern->content,
-						      ARRAY_LENGTH (dither_pattern[0]),
-						      ARRAY_LENGTH (dither_pattern));
+						      width, height);
     status = image->base.status;
     if (status)
 	goto BAIL;
 
     pixmap = XCreatePixmap (other->dpy,
 			    other->drawable,
-			    image->width, image->height,
+			    width, height,
 			    other->depth);
 
     surface = (cairo_xlib_surface_t *)
 	      _cairo_xlib_surface_create_internal (other->dpy,
 						   pixmap,
 						   other->screen, other->visual,
-						   NULL,
-						   image->width, image->height,
-						   0);
+						   other->xrender_format,
+						   width, height,
+						   other->depth);
     status = surface->base.status;
     if (status)
 	goto BAIL;
     surface->owns_pixmap = TRUE;
 
@@ -1206,11 +1239,11 @@ _cairo_xlib_surface_create_solid_pattern
     if (status)
 	goto BAIL;
 
     status = _draw_image_surface (surface, image,
 				  0, 0,
-				  image->width, image->height,
+				  width, height,
 				  0, 0);
     if (status)
 	goto BAIL;
 
 
@@ -1311,29 +1344,27 @@ _cairo_xlib_surface_set_filter (cairo_xl
     surface->filter = filter;
 
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static void
 _cairo_xlib_surface_set_repeat (cairo_xlib_surface_t *surface, int repeat)
 {
     XRenderPictureAttributes pa;
     unsigned long	     mask;
 
     if (!surface->src_picture)
-	return CAIRO_STATUS_SUCCESS;
+	return;
 
     if (surface->repeat == repeat)
-	return CAIRO_STATUS_SUCCESS;
+	return;
 
     mask = CPRepeat;
     pa.repeat = repeat;
 
     XRenderChangePicture (surface->dpy, surface->src_picture, mask, &pa);
     surface->repeat = repeat;
-
-    return CAIRO_STATUS_SUCCESS;
 }
 
 static cairo_int_status_t
 _cairo_xlib_surface_set_attributes (cairo_xlib_surface_t	    *surface,
 				    cairo_surface_attributes_t	    *attributes)
@@ -1346,22 +1377,20 @@ _cairo_xlib_surface_set_attributes (cair
     if (status)
 	return status;
 
     switch (attributes->extend) {
     case CAIRO_EXTEND_NONE:
-	status = _cairo_xlib_surface_set_repeat (surface, 0);
+	_cairo_xlib_surface_set_repeat (surface, 0);
 	break;
     case CAIRO_EXTEND_REPEAT:
-	status = _cairo_xlib_surface_set_repeat (surface, 1);
+	_cairo_xlib_surface_set_repeat (surface, 1);
 	break;
     case CAIRO_EXTEND_REFLECT:
     case CAIRO_EXTEND_PAD:
     default:
-	status = CAIRO_INT_STATUS_UNSUPPORTED;
+	return CAIRO_INT_STATUS_UNSUPPORTED;
     }
-    if (status)
-	return status;
 
     status = _cairo_xlib_surface_set_filter (surface, attributes->filter);
     if (status)
 	return status;
 
@@ -1885,15 +1914,20 @@ _create_a8_picture (cairo_xlib_surface_t
 		    cairo_bool_t          repeat)
 {
     XRenderPictureAttributes pa;
     unsigned long mask = 0;
 
-    Pixmap pixmap = XCreatePixmap (surface->dpy, surface->drawable,
-				   width <= 0 ? 1 : width,
-				   height <= 0 ? 1 : height,
-				   8);
+    Pixmap pixmap;
     Picture picture;
+
+    if (width > XLIB_COORD_MAX || height > XLIB_COORD_MAX)
+	return None;
+
+    pixmap = XCreatePixmap (surface->dpy, surface->drawable,
+			    width <= 0 ? 1 : width,
+			    height <= 0 ? 1 : height,
+			    8);
 
     if (repeat) {
 	pa.repeat = TRUE;
 	mask = CPRepeat;
     }
@@ -1933,11 +1967,11 @@ _create_trapezoid_mask (cairo_xlib_surfa
      * of RENDER rather than conditionalizing. We should still hit an
      * optimization that avoids creating another intermediate surface on
      * the servers that have XRenderAddTraps().
      */
     mask_picture = _create_a8_picture (dst, &transparent, width, height, FALSE);
-    if (num_traps == 0)
+    if (mask_picture == None || num_traps == 0)
 	return mask_picture;
 
     offset_traps = _cairo_malloc_ab (num_traps, sizeof (XTrapezoid));
     if (!offset_traps) {
 	XRenderFreePicture (dst->dpy, mask_picture);
@@ -2169,12 +2203,15 @@ _cairo_xlib_surface_set_clip_region (voi
 	    _cairo_region_fini (&bounded);
 	    return status;
 	}
 
 	status = _cairo_region_get_boxes (&bounded, &n_boxes, &boxes);
-        if (status)
-            return status;
+	if (status) {
+	    _cairo_region_fini (&bound);
+	    _cairo_region_fini (&bounded);
+	    return status;
+	}
 
 	if (n_boxes > ARRAY_LENGTH (surface->embedded_clip_rects)) {
 	    rects = _cairo_malloc_ab (n_boxes, sizeof (XRectangle));
 	    if (rects == NULL) {
                 _cairo_region_boxes_fini (&bounded, boxes);
@@ -2342,15 +2379,20 @@ _cairo_surface_is_xlib (cairo_surface_t 
 _cairo_surface_is_xlib (cairo_surface_t *surface)
 {
     return surface->backend == &cairo_xlib_surface_backend;
 }
 
+/* callback from CloseDisplay */
 static void
-_cairo_xlib_surface_detach_display (Display *dpy, void *data)
+_cairo_xlib_surface_detach_display (cairo_xlib_display_t *display, void *data)
 {
-    cairo_xlib_surface_t *surface = data;
+    cairo_xlib_surface_t *surface = cairo_container_of (data,
+							cairo_xlib_surface_t,
+							close_display_hook);
+    Display *dpy;
 
+    dpy = surface->dpy;
     surface->dpy = NULL;
 
     if (surface->dst_picture != None) {
 	XRenderFreePicture (dpy, surface->dst_picture);
 	surface->dst_picture = None;
@@ -2382,39 +2424,26 @@ _cairo_xlib_surface_create_internal (Dis
 				     int			width,
 				     int			height,
 				     int			depth)
 {
     cairo_xlib_surface_t *surface;
+    cairo_xlib_display_t *display;
     cairo_xlib_screen_info_t *screen_info;
 
     CAIRO_MUTEX_INITIALIZE ();
 
-    screen_info = _cairo_xlib_screen_info_get (dpy, screen);
-    if (screen_info == NULL)
-	return _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_NO_MEMORY));
-
-    surface = malloc (sizeof (cairo_xlib_surface_t));
-    if (surface == NULL) {
-	_cairo_xlib_screen_info_destroy (screen_info);
-	return _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_NO_MEMORY));
-    }
-
-    if (! _cairo_xlib_add_close_display_hook (dpy,
-	    _cairo_xlib_surface_detach_display, surface, surface)) {
-	free (surface);
-	_cairo_xlib_screen_info_destroy (screen_info);
-	return _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_NO_MEMORY));
-    }
-
     if (xrender_format) {
 	depth = xrender_format->depth;
+
+	/* XXX find matching visual for core/dithering fallbacks? */
     } else if (visual) {
 	int j, k;
 
 	/* This is ugly, but we have to walk over all visuals
-	 * for the display to find the depth.
+	 * for the display to find the correct depth.
 	 */
+	depth = 0;
 	for (j = 0; j < screen->ndepths; j++) {
 	    Depth *d = &screen->depths[j];
 	    for (k = 0; k < d->nvisuals; k++) {
 		if (&d->visuals[k] == visual) {
 		    depth = d->depth;
@@ -2423,10 +2452,34 @@ _cairo_xlib_surface_create_internal (Dis
 	    }
 	}
     found:
 	;
     }
+
+    if (depth == 0)
+	return _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_INVALID_VISUAL));
+
+    display = _cairo_xlib_display_get (dpy);
+    if (display == NULL)
+	return _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_NO_MEMORY));
+
+    screen_info = _cairo_xlib_screen_info_get (display, screen);
+    if (screen_info == NULL) {
+	_cairo_xlib_display_destroy (display);
+	return _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_NO_MEMORY));
+    }
+
+    surface = malloc (sizeof (cairo_xlib_surface_t));
+    if (surface == NULL) {
+	_cairo_xlib_screen_info_destroy (screen_info);
+	_cairo_xlib_display_destroy (display);
+	return _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_NO_MEMORY));
+    }
+
+    /* initialize and hook into the CloseDisplay callback */
+    surface->close_display_hook.func = _cairo_xlib_surface_detach_display;
+    _cairo_xlib_add_close_display_hook (display, &surface->close_display_hook);
 
     if (! XRenderQueryVersion (dpy, &surface->render_major, &surface->render_minor)) {
 	surface->render_major = -1;
 	surface->render_minor = -1;
     }
@@ -2444,10 +2497,11 @@ _cairo_xlib_surface_create_internal (Dis
 
     _cairo_surface_init (&surface->base, &cairo_xlib_surface_backend,
 			 _xrender_format_to_content (xrender_format));
 
     surface->dpy = dpy;
+    surface->display = display;
     surface->screen_info = screen_info;
 
     surface->gc = NULL;
     surface->drawable = drawable;
     surface->screen = screen;
@@ -2943,37 +2997,50 @@ typedef struct _cairo_xlib_font_glyphset
     XRenderPictFormat	*xrender_format;
     cairo_xlib_font_glyphset_free_glyphs_t *pending_free_glyphs;
 } cairo_xlib_font_glyphset_info_t;
 
 typedef struct _cairo_xlib_surface_font_private {
+    cairo_scaled_font_t		    *scaled_font;
+    cairo_xlib_hook_t                close_display_hook;
     cairo_xlib_display_t	    *display;
     cairo_xlib_font_glyphset_info_t  glyphset_info[NUM_GLYPHSETS];
 } cairo_xlib_surface_font_private_t;
 
+/* callback from CloseDisplay */
 static void
-_cairo_xlib_surface_remove_scaled_font (Display *dpy,
-	                                void    *data)
+_cairo_xlib_surface_remove_scaled_font (cairo_xlib_display_t	*display,
+	                                void			*data)
 {
-    cairo_scaled_font_t *scaled_font = data;
     cairo_xlib_surface_font_private_t	*font_private;
+    cairo_scaled_font_t			*scaled_font;
+
+    font_private = cairo_container_of (data,
+				       cairo_xlib_surface_font_private_t,
+				       close_display_hook);
+    scaled_font = font_private->scaled_font;
 
     CAIRO_MUTEX_LOCK (scaled_font->mutex);
     font_private  = scaled_font->surface_private;
     scaled_font->surface_private = NULL;
 
     _cairo_scaled_font_reset_cache (scaled_font);
     CAIRO_MUTEX_UNLOCK (scaled_font->mutex);
 
     if (font_private != NULL) {
+	Display *dpy;
 	int i;
 
+	dpy = display->display;
 	for (i = 0; i < NUM_GLYPHSETS; i++) {
 	    cairo_xlib_font_glyphset_info_t *glyphset_info;
 
 	    glyphset_info = &font_private->glyphset_info[i];
 	    if (glyphset_info->glyphset)
 		XRenderFreeGlyphSet (dpy, glyphset_info->glyphset);
+
+	    if (glyphset_info->pending_free_glyphs != NULL)
+		free (glyphset_info->pending_free_glyphs);
 	}
 
 	_cairo_xlib_display_destroy (font_private->display);
 	free (font_private);
     }
@@ -2988,20 +3055,24 @@ _cairo_xlib_surface_font_init (Display		
 
     font_private = malloc (sizeof (cairo_xlib_surface_font_private_t));
     if (font_private == NULL)
 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
 
-    if (! _cairo_xlib_add_close_display_hook (dpy,
-		                         _cairo_xlib_surface_remove_scaled_font,
-					 scaled_font, scaled_font))
-    {
+    font_private->scaled_font = scaled_font;
+    font_private->display = _cairo_xlib_display_get (dpy);
+    if (font_private->display == NULL) {
 	free (font_private);
 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
     }
 
+    /* initialize and hook into the CloseDisplay callback */
+    font_private->close_display_hook.func =
+	_cairo_xlib_surface_remove_scaled_font;
+    _cairo_xlib_add_close_display_hook (font_private->display,
+					&font_private->close_display_hook);
 
-    font_private->display = _cairo_xlib_display_get (dpy);
+
     for (i = 0; i < NUM_GLYPHSETS; i++) {
 	cairo_xlib_font_glyphset_info_t *glyphset_info = &font_private->glyphset_info[i];
 	switch (i) {
 	case GLYPHSET_INDEX_ARGB32: glyphset_info->format = CAIRO_FORMAT_ARGB32; break;
 	case GLYPHSET_INDEX_A8:     glyphset_info->format = CAIRO_FORMAT_A8;     break;
@@ -3028,11 +3099,12 @@ _cairo_xlib_surface_scaled_font_fini (ca
     if (font_private != NULL) {
 	cairo_xlib_display_t *display;
 	int i;
 
 	display = font_private->display;
-	_cairo_xlib_remove_close_display_hooks (display->display, scaled_font);
+	_cairo_xlib_remove_close_display_hook (display,
+					       &font_private->close_display_hook);
 
 	for (i = 0; i < NUM_GLYPHSETS; i++) {
 	    cairo_xlib_font_glyphset_info_t *glyphset_info;
 
 	    glyphset_info = &font_private->glyphset_info[i];
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo-xlib-xrender-private.h
--- a/gfx/cairo/cairo/src/cairo-xlib-xrender-private.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo-xlib-xrender-private.h	Mon Sep 08 10:35:45 2008 +0300
@@ -31,10 +31,15 @@
  */
 
 #ifndef CAIRO_XLIB_XRENDER_PRIVATE_H
 #define CAIRO_XLIB_XRENDER_PRIVATE_H
 
+#include "cairo-features.h"
+#include "cairo-compiler-private.h"
+
+#include <X11/Xlib.h>
+
 #if CAIRO_HAS_XLIB_XRENDER_SURFACE
 
 #include "cairo-xlib-xrender.h"
 
 #include <X11/extensions/Xrender.h>
@@ -50,11 +55,11 @@
 
 /* As it happens, it is the case that, all libxrender functions
  * take a pointer as first argument */
 
 __attribute__((__unused__)) static void   _void_consume        (void *p, ...)   { }
-__attribute__((__unused__)) static void * _voidp_consume       (void *p, ...)   { return NULL; }
+__attribute__((__unused__)) static void * _voidp_consume       (void *p, ...)   { return (void *)0; }
 __attribute__((__unused__)) static int    _int_consume         (void *p, ...)   { return 0; }
 __attribute__((__unused__)) static void   _void_consume_free   (Display *p, XID n) { }
 
 #define XRenderQueryExtension				_int_consume
 #define XRenderQueryVersion				_int_consume
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo.c
--- a/gfx/cairo/cairo/src/cairo.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo.c	Mon Sep 08 10:35:45 2008 +0300
@@ -116,53 +116,10 @@ _cairo_set_error (cairo_t *cr, cairo_sta
      * error, which is the most significant. */
     _cairo_status_set_error (&cr->status, status);
 
     status = _cairo_error (status);
 }
-
-/**
- * cairo_version:
- *
- * Returns the version of the cairo library encoded in a single
- * integer as per %CAIRO_VERSION_ENCODE. The encoding ensures that
- * later versions compare greater than earlier versions.
- *
- * A run-time comparison to check that cairo's version is greater than
- * or equal to version X.Y.Z could be performed as follows:
- *
- * <informalexample><programlisting>
- * if (cairo_version() >= CAIRO_VERSION_ENCODE(X,Y,Z)) {...}
- * </programlisting></informalexample>
- *
- * See also cairo_version_string() as well as the compile-time
- * equivalents %CAIRO_VERSION and %CAIRO_VERSION_STRING.
- *
- * Return value: the encoded version.
- **/
-int
-cairo_version (void)
-{
-    return CAIRO_VERSION;
-}
-
-/**
- * cairo_version_string:
- *
- * Returns the version of the cairo library as a human-readable string
- * of the form "X.Y.Z".
- *
- * See also cairo_version() as well as the compile-time equivalents
- * %CAIRO_VERSION_STRING and %CAIRO_VERSION.
- *
- * Return value: a string containing the version.
- **/
-const char*
-cairo_version_string (void)
-{
-    return CAIRO_VERSION_STRING;
-}
-slim_hidden_def (cairo_version_string);
 
 /**
  * cairo_create:
  * @target: target surface for the context
  *
@@ -585,11 +542,21 @@ cairo_pop_group (cairo_t *cr)
 	_cairo_set_error (cr, cairo_pattern_status (group_pattern));
         goto done;
     }
 
     _cairo_gstate_get_matrix (cr->gstate, &group_matrix);
-    cairo_pattern_set_matrix (group_pattern, &group_matrix);
+    /* Transform by group_matrix centered around device_transform so that when
+     * we call _cairo_gstate_copy_transformed_pattern the result is a pattern
+     * with a matrix equivalent to the device_transform of group_surface. */
+    if (_cairo_surface_has_device_transform (group_surface)) {
+	cairo_pattern_set_matrix (group_pattern, &group_surface->device_transform);
+	_cairo_pattern_transform (group_pattern, &group_matrix);
+	_cairo_pattern_transform (group_pattern, &group_surface->device_transform_inverse);
+    } else {
+	cairo_pattern_set_matrix (group_pattern, &group_matrix);
+    }
+
 done:
     cairo_surface_destroy (group_surface);
 
     return group_pattern;
 }
@@ -2607,11 +2574,11 @@ cairo_copy_clip_rectangle_list (cairo_t 
  * adequate for serious text-using applications.
  *
  * Selects a family and style of font from a simplified description as
  * a family name, slant and weight. Cairo provides no operation to
  * list available family names on the system (this is a "toy",
- * remember"), but the standard CSS2 generic family names, ("serif",
+ * remember), but the standard CSS2 generic family names, ("serif",
  * "sans-serif", "cursive", "fantasy", "monospace"), are likely to
  * work as expected.
  *
  * For "real" font selection, see the font-backend-specific
  * font_face_create functions for the font backend you are using. (For
@@ -2629,12 +2596,16 @@ cairo_copy_clip_rectangle_list (cairo_t 
  * comprehensive font handling and text layout library, (for example,
  * pango), in conjunction with cairo.
  *
  * If text is drawn without a call to cairo_select_font_face(), (nor
  * cairo_set_font_face() nor cairo_set_scaled_font()), the default
- * family is "sans", slant is %CAIRO_FONT_SLANT_NORMAL, and weight is
+ * family is platform-specific, but is essentially "sans-serif".
+ * Default slant is %CAIRO_FONT_SLANT_NORMAL, and default weight is
  * %CAIRO_FONT_WEIGHT_NORMAL.
+ *
+ * This function is equivalent to a call to cairo_toy_font_face_create()
+ * followed by cairo_set_font_face().
  **/
 void
 cairo_select_font_face (cairo_t              *cr,
 			const char           *family,
 			cairo_font_slant_t    slant,
@@ -2889,10 +2860,15 @@ cairo_set_scaled_font (cairo_t          
     cairo_status_t status;
 
     if (cr->status)
 	return;
 
+    if (scaled_font == NULL) {
+	status = CAIRO_STATUS_NULL_POINTER;
+	goto BAIL;
+    }
+
     status = scaled_font->status;
     if (status)
         goto BAIL;
 
     status = _cairo_gstate_set_font_face (cr->gstate, scaled_font->font_face);
@@ -2950,11 +2926,11 @@ cairo_get_scaled_font (cairo_t *cr)
 }
 
 /**
  * cairo_text_extents:
  * @cr: a #cairo_t
- * @utf8: a string of text encoded in UTF-8, or %NULL
+ * @utf8: a NUL-terminated string of text encoded in UTF-8, or %NULL
  * @extents: a #cairo_text_extents_t object into which the results
  * will be stored
  *
  * Gets the extents for a string of text. The extents describe a
  * user-space rectangle that encloses the "inked" portion of the text,
@@ -2992,20 +2968,22 @@ cairo_text_extents (cairo_t             
     if (utf8 == NULL)
 	return;
 
     cairo_get_current_point (cr, &x, &y);
 
-    status = _cairo_gstate_text_to_glyphs (cr->gstate, utf8,
+    status = _cairo_gstate_text_to_glyphs (cr->gstate,
 					   x, y,
-					   &glyphs, &num_glyphs);
+					   utf8, strlen (utf8),
+					   &glyphs, &num_glyphs,
+					   NULL, NULL,
+					   NULL);
 
     if (status == CAIRO_STATUS_SUCCESS)
 	status = _cairo_gstate_glyph_extents (cr->gstate,
 		                              glyphs, num_glyphs,
 					      extents);
-    if (glyphs)
-	free (glyphs);
+    cairo_glyph_free (glyphs);
 
     if (status)
 	_cairo_set_error (cr, status);
 }
 
@@ -3065,11 +3043,11 @@ cairo_glyph_extents (cairo_t            
 }
 
 /**
  * cairo_show_text:
  * @cr: a cairo context
- * @utf8: a string of text encoded in UTF-8, or %NULL
+ * @utf8: a NUL-terminated string of text encoded in UTF-8, or %NULL
  *
  * A drawing operator that generates the shape from a string of UTF-8
  * characters, rendered according to the current font_face, font_size
  * (font_matrix), and font_options.
  *
@@ -3095,35 +3073,42 @@ cairo_show_text (cairo_t *cr, const char
 cairo_show_text (cairo_t *cr, const char *utf8)
 {
     cairo_text_extents_t extents;
     cairo_status_t status;
     cairo_glyph_t *glyphs = NULL, *last_glyph;
-    int num_glyphs;
+    cairo_text_cluster_t *clusters = NULL;
+    int utf8_len, num_glyphs, num_clusters;
+    cairo_bool_t backward;
     double x, y;
 
     if (cr->status)
 	return;
 
     if (utf8 == NULL)
 	return;
 
     cairo_get_current_point (cr, &x, &y);
 
-    status = _cairo_gstate_text_to_glyphs (cr->gstate, utf8,
+    utf8_len = strlen (utf8);
+
+    status = _cairo_gstate_text_to_glyphs (cr->gstate,
 					   x, y,
-					   &glyphs, &num_glyphs);
+					   utf8, utf8_len,
+					   &glyphs, &num_glyphs,
+					   cairo_has_show_text_glyphs (cr) ? &clusters : NULL, &num_clusters,
+					   &backward);
     if (status)
 	goto BAIL;
 
     if (num_glyphs == 0)
 	return;
 
     status = _cairo_gstate_show_text_glyphs (cr->gstate,
-					     NULL, 0,
+					     utf8, utf8_len,
 					     glyphs, num_glyphs,
-					     NULL, 0,
-					     FALSE);
+					     clusters, num_clusters,
+					     backward);
     if (status)
 	goto BAIL;
 
     last_glyph = &glyphs[num_glyphs - 1];
     status = _cairo_gstate_glyph_extents (cr->gstate,
@@ -3135,12 +3120,12 @@ cairo_show_text (cairo_t *cr, const char
     x = last_glyph->x + extents.x_advance;
     y = last_glyph->y + extents.y_advance;
     cairo_move_to (cr, x, y);
 
  BAIL:
-    if (glyphs)
-	free (glyphs);
+    cairo_glyph_free (glyphs);
+    cairo_text_cluster_free (clusters);
 
     if (status)
 	_cairo_set_error (cr, status);
 }
 
@@ -3149,12 +3134,12 @@ cairo_show_text (cairo_t *cr, const char
  * @cr: a cairo context
  * @glyphs: array of glyphs to show
  * @num_glyphs: number of glyphs to show
  *
  * A drawing operator that generates the shape from an array of glyphs,
- * rendered according to the current font_face, font_size
- * (font_matrix), and font_options.
+ * rendered according to the current font face, font size
+ * (font matrix), and font options.
  **/
 void
 cairo_show_glyphs (cairo_t *cr, const cairo_glyph_t *glyphs, int num_glyphs)
 {
     cairo_status_t status;
@@ -3182,16 +3167,73 @@ cairo_show_glyphs (cairo_t *cr, const ca
 					     FALSE);
     if (status)
 	_cairo_set_error (cr, status);
 }
 
+/**
+ * cairo_has_show_text_glyphs:
+ * @cr: a cairo context
+ *
+ * Returns whether the target surface of a cairo context supports
+ * sophisticated cairo_show_text_glyphs() operations.  That is,
+ * whether it actually uses the provided text and cluster data
+ * to a cairo_show_text_glyphs() call.
+ *
+ * Note: Even if this function returns %FALSE, a
+ * cairo_show_text_glyphs() operation will still succeed.  It just will
+ * act like a cairo_show_glyphs() operation.  Users can use this
+ * function to avoid computing UTF-8 text and cluster mapping if the
+ * target surface does not use it.
+ *
+ * This is a convenience function that simply calls
+ * cairo_surface_has_show_text_glyphs() on @cr's target.
+ *
+ * Return value: %TRUE if the target surface of @cr supports
+ *               cairo_show_text_glyphs(), %FALSE otherwise
+ *
+ * Since: 1.8
+ **/
 cairo_bool_t
 cairo_has_show_text_glyphs (cairo_t			   *cr)
 {
     return _cairo_gstate_has_show_text_glyphs (cr->gstate);
 }
+slim_hidden_def (cairo_has_show_text_glyphs);
 
+/**
+ * cairo_show_text_glyphs:
+ * @cr: a cairo context
+ * @utf8: a string of text encoded in UTF-8
+ * @utf8_len: length of @utf8 in bytes, or -1 if it is NUL-terminated
+ * @glyphs: array of glyphs to show
+ * @num_glyphs: number of glyphs to show
+ * @clusters: array of cluster mapping information
+ * @num_clusters: number of clusters in the mapping
+ * @backward: whether the text to glyphs mapping goes backward
+ *
+ * This operation has rendering effects similar to cairo_show_glyphs()
+ * but, if the target surface supports it, uses the provided text and
+ * cluster mapping to embed the text for the glyphs shown in the output.
+ * The cairo_has_show_text_glyphs() function can be used to query that.
+ * If the target does not support it, this function acts like
+ * cairo_show_glyphs().
+ *
+ * The mapping between @utf8 and @glyphs is provided by an array of
+ * <firstterm>clusters</firstterm>.  Each cluster covers a number of
+ * text bytes and glyphs, and neighboring clusters cover neighboring
+ * areas of @utf8 and @glyphs.  The clusters should collectively cover @utf8
+ * and @glyphs in entirety.
+ *
+ * The first cluster always covers bytes from the beginning of @utf8.
+ * If @backward is %FALSE, the first cluster also covers the beginning
+ * of @glyphs, otherwise it covers the end of the @glyphs array and
+ * following clusters move backward.
+ *
+ * See #cairo_text_cluster_t for constraints on valid clusters.
+ *
+ * Since: 1.8
+ **/
 void
 cairo_show_text_glyphs (cairo_t			   *cr,
 			const char		   *utf8,
 			int			    utf8_len,
 			const cairo_glyph_t	   *glyphs,
@@ -3205,72 +3247,50 @@ cairo_show_text_glyphs (cairo_t			   *cr
     if (cr->status)
 	return;
 
     /* A slew of sanity checks */
 
+    /* Special case for NULL and -1 */
+    if (utf8 == NULL && utf8_len == -1)
+	utf8_len = 0;
+
+    /* No NULLs for non-zeros */
+    if ((num_glyphs   && glyphs   == NULL) ||
+	(utf8_len     && utf8     == NULL) ||
+	(num_clusters && clusters == NULL)) {
+	_cairo_set_error (cr, CAIRO_STATUS_NULL_POINTER);
+	return;
+    }
+
     /* A -1 for utf8_len means NUL-terminated */
     if (utf8_len == -1)
 	utf8_len = strlen (utf8);
 
     /* Apart from that, no negatives */
     if (num_glyphs < 0 || utf8_len < 0 || num_clusters < 0) {
 	_cairo_set_error (cr, CAIRO_STATUS_NEGATIVE_COUNT);
 	return;
     }
 
-    /* And no NULLs for non-zeros */
-    if ((num_glyphs   && glyphs   == NULL) ||
-	(utf8_len     && utf8     == NULL) ||
-	(num_clusters && clusters == NULL)) {
-	_cairo_set_error (cr, CAIRO_STATUS_NULL_POINTER);
-	return;
-    }
-
     /* Make sure clusters cover the entire glyphs and utf8 arrays,
      * and that cluster boundaries are UTF-8 boundaries. */
-    {
-	unsigned int n_bytes  = 0;
-	unsigned int n_glyphs = 0;
-	int i;
+    status = _cairo_validate_text_clusters (utf8, utf8_len,
+					    glyphs, num_glyphs,
+					    clusters, num_clusters,
+					    backward);
+    if (status == CAIRO_STATUS_INVALID_CLUSTERS) {
+	/* Either got invalid UTF-8 text, or cluster mapping is bad.
+	 * Differentiate those. */
 
-	for (i = 0; i < num_clusters; i++) {
-	    int cluster_bytes  = clusters[i].num_bytes;
-	    int cluster_glyphs = clusters[i].num_glyphs;
+	cairo_status_t status2;
 
-	    if (cluster_bytes < 0 || cluster_glyphs < 0)
-	        goto BAD;
+	status2 = _cairo_utf8_to_ucs4 (utf8, utf8_len, NULL, NULL);
+	if (status2)
+	    status = status2;
 
-	    /* A cluster should cover at least one character or glyph.
-	     * I can't see any use for a 0,0 cluster.
-	     * I can't see an immediate use for a zero-text cluster
-	     * right now either, but they don't harm.
-	     * Zero-glyph clusters on the other hand are useful for
-	     * things like U+200C ZERO WIDTH NON-JOINER */
-	    if (cluster_bytes == 0 && cluster_glyphs == 0)
-	        goto BAD;
-
-	    /* Since n_bytes and n_glyphs are unsigned, but the rest of
-	     * values involved are signed, we can detect overflow easily */
-	    if (n_bytes+cluster_bytes > (unsigned int)utf8_len || n_glyphs+cluster_glyphs > (unsigned int)num_glyphs)
-	        goto BAD;
-
-	    /* Make sure we've got valid UTF-8 for the cluster */
-	    status = _cairo_utf8_to_ucs4 (utf8+n_bytes, cluster_bytes, NULL, NULL);
-	    if (status) {
-		_cairo_set_error (cr, status);
-		return;
-	    }
-
-	    n_bytes  += cluster_bytes ;
-	    n_glyphs += cluster_glyphs;
-	}
-
-	if (n_bytes != (unsigned int)utf8_len || n_glyphs != (unsigned int)num_glyphs) {
-	  BAD:
-	    _cairo_set_error (cr, CAIRO_STATUS_INVALID_CLUSTERS);
-	    return;
-	}
+	_cairo_set_error (cr, status);
+	return;
     }
 
     if (num_glyphs == 0 && utf8_len == 0)
 	return;
 
@@ -3284,11 +3304,11 @@ cairo_show_text_glyphs (cairo_t			   *cr
 }
 
 /**
  * cairo_text_path:
  * @cr: a cairo context
- * @utf8: a string of text encoded in UTF-8, or %NULL
+ * @utf8: a NUL-terminated string of text encoded in UTF-8, or %NULL
  *
  * Adds closed paths for text to the current path.  The generated
  * path if filled, achieves an effect similar to that of
  * cairo_show_text().
  *
@@ -3322,13 +3342,16 @@ cairo_text_path  (cairo_t *cr, const cha
     if (utf8 == NULL)
 	return;
 
     cairo_get_current_point (cr, &x, &y);
 
-    status = _cairo_gstate_text_to_glyphs (cr->gstate, utf8,
+    status = _cairo_gstate_text_to_glyphs (cr->gstate,
 					   x, y,
-					   &glyphs, &num_glyphs);
+					   utf8, strlen (utf8),
+					   &glyphs, &num_glyphs,
+					   NULL, NULL,
+					   NULL);
 
     if (status)
 	goto BAIL;
 
     if (num_glyphs == 0)
@@ -3352,12 +3375,11 @@ cairo_text_path  (cairo_t *cr, const cha
     x = last_glyph->x + extents.x_advance;
     y = last_glyph->y + extents.y_advance;
     cairo_move_to (cr, x, y);
 
  BAIL:
-    if (glyphs)
-	free (glyphs);
+    cairo_glyph_free (glyphs);
 
     if (status)
 	_cairo_set_error (cr, status);
 }
 
@@ -3490,15 +3512,15 @@ cairo_has_current_point (cairo_t *cr)
  * cairo_new_path(), cairo_new_sub_path(),
  * cairo_append_path(), cairo_close_path(),
  * cairo_move_to(), cairo_line_to(), cairo_curve_to(),
  * cairo_rel_move_to(), cairo_rel_line_to(), cairo_rel_curve_to(),
  * cairo_arc(), cairo_arc_negative(), cairo_rectangle(),
- * cairo_text_path(), cairo_glyph_path(), cairo_stroke_to_path()
+ * cairo_text_path(), cairo_glyph_path(), cairo_stroke_to_path().
  *
- * Some functions use and alter the current point but do not otherwise
- * change current path:
- * cairo_show_text(), cairo_show_glyphs().
+ * Some functions use and alter the current point but do not
+ * otherwise change current path:
+ * cairo_show_text().
  *
  * Some functions unset the current path and as a result, current point:
  * cairo_fill(), cairo_stroke().
  **/
 void
@@ -3656,10 +3678,11 @@ cairo_get_target (cairo_t *cr)
     if (cr->status)
 	return _cairo_surface_create_in_error (cr->status);
 
     return _cairo_gstate_get_original_target (cr->gstate);
 }
+slim_hidden_def (cairo_get_target);
 
 /**
  * cairo_get_group_target:
  * @cr: a cairo context
  *
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairo.h
--- a/gfx/cairo/cairo/src/cairo.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairo.h	Mon Sep 08 10:35:45 2008 +0300
@@ -36,24 +36,49 @@
  */
 
 #ifndef CAIRO_H
 #define CAIRO_H
 
+#include "cairo-version.h"
 #include "cairo-features.h"
 #include "cairo-deprecated.h"
 
+#ifdef  __cplusplus
+# define CAIRO_BEGIN_DECLS  extern "C" {
+# define CAIRO_END_DECLS    }
+#else
+# define CAIRO_BEGIN_DECLS
+# define CAIRO_END_DECLS
+#endif
+
+#ifndef cairo_public
+# define cairo_public
+#endif
+
 CAIRO_BEGIN_DECLS
 
-#define CAIRO_VERSION_ENCODE(major, minor, micro) (     \
-	  ((major) * 10000)                             \
-	+ ((minor) *   100)                             \
+#define CAIRO_VERSION_ENCODE(major, minor, micro) (	\
+	  ((major) * 10000)				\
+	+ ((minor) *   100)				\
 	+ ((micro) *     1))
 
-#define CAIRO_VERSION CAIRO_VERSION_ENCODE(     \
-	CAIRO_VERSION_MAJOR,                    \
-	CAIRO_VERSION_MINOR,                    \
+#define CAIRO_VERSION CAIRO_VERSION_ENCODE(	\
+	CAIRO_VERSION_MAJOR,			\
+	CAIRO_VERSION_MINOR,			\
 	CAIRO_VERSION_MICRO)
+
+
+#define CAIRO_VERSION_STRINGIZE_(major, minor, micro)	\
+	#major"."#minor"."#micro
+#define CAIRO_VERSION_STRINGIZE(major, minor, micro)	\
+	CAIRO_VERSION_STRINGIZE_(major, minor, micro)
+
+#define CAIRO_VERSION_STRING CAIRO_VERSION_STRINGIZE(	\
+	CAIRO_VERSION_MAJOR,				\
+	CAIRO_VERSION_MINOR,				\
+	CAIRO_VERSION_MICRO)
+
 
 cairo_public int
 cairo_version (void);
 
 cairo_public const char*
@@ -206,10 +231,12 @@ typedef struct _cairo_user_data_key {
  * @CAIRO_STATUS_FONT_TYPE_MISMATCH: the font type is not appropriate for the operation (Since 1.8)
  * @CAIRO_STATUS_USER_FONT_IMMUTABLE: the user-font is immutable (Since 1.8)
  * @CAIRO_STATUS_USER_FONT_ERROR: error occurred in a user-font callback function (Since 1.8)
  * @CAIRO_STATUS_NEGATIVE_COUNT: negative number used where it is not allowed (Since 1.8)
  * @CAIRO_STATUS_INVALID_CLUSTERS: input clusters do not represent the accompanying text and glyph array (Since 1.8)
+ * @CAIRO_STATUS_INVALID_SLANT: invalid value for an input #cairo_font_slant_t (Since 1.8)
+ * @CAIRO_STATUS_INVALID_WEIGHT: invalid value for an input #cairo_font_weight_t (Since 1.8)
  *
  * #cairo_status_t is used to indicate errors that can occur when
  * using Cairo. In some cases it is returned directly by functions.
  * but when using #cairo_t, the last error, if any, is stored in
  * the context and can be retrieved with cairo_status().
@@ -245,11 +272,13 @@ typedef enum _cairo_status {
     CAIRO_STATUS_INVALID_STRIDE,
     CAIRO_STATUS_FONT_TYPE_MISMATCH,
     CAIRO_STATUS_USER_FONT_IMMUTABLE,
     CAIRO_STATUS_USER_FONT_ERROR,
     CAIRO_STATUS_NEGATIVE_COUNT,
-    CAIRO_STATUS_INVALID_CLUSTERS
+    CAIRO_STATUS_INVALID_CLUSTERS,
+    CAIRO_STATUS_INVALID_SLANT,
+    CAIRO_STATUS_INVALID_WEIGHT
     /* after adding a new error: update CAIRO_STATUS_LAST_STATUS in cairoint.h */
 } cairo_status_t;
 
 /**
  * cairo_content_t:
@@ -824,14 +853,46 @@ typedef struct {
     unsigned long        index;
     double               x;
     double               y;
 } cairo_glyph_t;
 
+cairo_public cairo_glyph_t *
+cairo_glyph_allocate (int num_glyphs);
+
+cairo_public void
+cairo_glyph_free (cairo_glyph_t *glyphs);
+
+/**
+ * cairo_text_cluster_t:
+ * @num_bytes: the number of bytes of UTF-8 text covered by cluster
+ * @num_glyphs: the number of glyphs covered by cluster
+ *
+ * The #cairo_text_cluster_t structure holds information about a single
+ * <firstterm>text cluster</firstterm>.  A text cluster is a minimal
+ * mapping of some glyphs corresponding to some UTF-8 text.
+ *
+ * For a cluster to be valid, both @num_bytes and @num_glyphs should
+ * be non-negative, and at least one should be non-zero.
+ * Note that clusters with zero glyphs are not as well supported as
+ * normal clusters.  For example, PDF rendering applications typically
+ * ignore those clusters when PDF text is being selected.
+ *
+ * See cairo_show_text_glyphs() for how clusters are used in advanced
+ * text operations.
+ *
+ * Since: 1.8
+ **/
 typedef struct {
     int        num_bytes;
     int        num_glyphs;
 } cairo_text_cluster_t;
+
+cairo_public cairo_text_cluster_t *
+cairo_text_cluster_allocate (int num_clusters);
+
+cairo_public void
+cairo_text_cluster_free (cairo_text_cluster_t *clusters);
 
 /**
  * cairo_text_extents_t:
  * @x_bearing: the horizontal distance from the origin to the
  *   leftmost part of the glyphs as drawn. Positive if the
@@ -966,10 +1027,32 @@ typedef enum _cairo_subpixel_order {
     CAIRO_SUBPIXEL_ORDER_VRGB,
     CAIRO_SUBPIXEL_ORDER_VBGR
 } cairo_subpixel_order_t;
 
 /**
+ * cairo_lcd_filter_t:
+ * @CAIRO_LCD_FILTER_DEFAULT: Use the default LCD filter for
+ *   font backend and target device
+ * @CAIRO_LCD_FILTER_NONE: Do not perform LCD filtering
+ * @CAIRO_LCD_FILTER_INTRA_PIXEL: Intra-pixel filter
+ * @CAIRO_LCD_FILTER_FIR3: FIR filter with a 3x3 kernel
+ * @CAIRO_LCD_FILTER_FIR5: FIR filter with a 5x5 kernel
+ *
+ * The LCD filter specifies the low-pass filter applied to LCD-optimized
+ * bitmaps generated with an antialiasing mode of %CAIRO_ANTIALIAS_SUBPIXEL.
+ *
+ * Since: 1.8
+ **/
+typedef enum _cairo_lcd_filter {
+    CAIRO_LCD_FILTER_DEFAULT,
+    CAIRO_LCD_FILTER_NONE,
+    CAIRO_LCD_FILTER_INTRA_PIXEL,
+    CAIRO_LCD_FILTER_FIR3,
+    CAIRO_LCD_FILTER_FIR5
+} cairo_lcd_filter_t;
+
+/**
  * cairo_hint_style_t:
  * @CAIRO_HINT_STYLE_DEFAULT: Use the default hint style for
  *   font backend and target device
  * @CAIRO_HINT_STYLE_NONE: Do not hint outlines
  * @CAIRO_HINT_STYLE_SLIGHT: Hint outlines slightly to improve
@@ -1069,10 +1152,16 @@ cairo_public void
 cairo_public void
 cairo_font_options_set_subpixel_order (cairo_font_options_t   *options,
 				       cairo_subpixel_order_t  subpixel_order);
 cairo_public cairo_subpixel_order_t
 cairo_font_options_get_subpixel_order (const cairo_font_options_t *options);
+
+cairo_public void
+cairo_font_options_set_lcd_filter (cairo_font_options_t   *options,
+				   cairo_lcd_filter_t  lcd_filter);
+cairo_public cairo_lcd_filter_t
+cairo_font_options_get_lcd_filter (const cairo_font_options_t *options);
 
 cairo_public void
 cairo_font_options_set_hint_style (cairo_font_options_t *options,
 				   cairo_hint_style_t     hint_style);
 cairo_public cairo_hint_style_t
@@ -1284,10 +1373,22 @@ cairo_scaled_font_glyph_extents (cairo_s
 cairo_scaled_font_glyph_extents (cairo_scaled_font_t   *scaled_font,
 				 const cairo_glyph_t   *glyphs,
 				 int                   num_glyphs,
 				 cairo_text_extents_t  *extents);
 
+cairo_public cairo_status_t
+cairo_scaled_font_text_to_glyphs (cairo_scaled_font_t   *scaled_font,
+				  double		 x,
+				  double		 y,
+				  const char	        *utf8,
+				  int		         utf8_len,
+				  cairo_glyph_t	       **glyphs,
+				  int		        *num_glyphs,
+				  cairo_text_cluster_t **clusters,
+				  int		        *num_clusters,
+				  cairo_bool_t	        *backward);
+
 cairo_public cairo_font_face_t *
 cairo_scaled_font_get_font_face (cairo_scaled_font_t *scaled_font);
 
 cairo_public void
 cairo_scaled_font_get_font_matrix (cairo_scaled_font_t	*scaled_font,
@@ -1303,24 +1404,49 @@ cairo_scaled_font_get_scale_matrix (cair
 
 cairo_public void
 cairo_scaled_font_get_font_options (cairo_scaled_font_t		*scaled_font,
 				    cairo_font_options_t	*options);
 
+
+/* Toy fonts */
+
+cairo_public cairo_font_face_t *
+cairo_toy_font_face_create (const char           *family,
+			    cairo_font_slant_t    slant,
+			    cairo_font_weight_t   weight);
+
+cairo_public const char *
+cairo_toy_font_face_get_family (cairo_font_face_t *font_face);
+
+cairo_public cairo_font_slant_t
+cairo_toy_font_face_get_slant (cairo_font_face_t *font_face);
+
+cairo_public cairo_font_weight_t
+cairo_toy_font_face_get_weight (cairo_font_face_t *font_face);
+
+
 /* User fonts */
 
 cairo_public cairo_font_face_t *
 cairo_user_font_face_create (void);
 
 /* User-font method signatures */
 
 /**
  * cairo_user_scaled_font_init_func_t:
  * @scaled_font: the scaled-font being created
+ * @cr: a cairo context, in font space
  * @extents: font extents to fill in, in font space
  *
  * #cairo_user_scaled_font_init_func_t is the type of function which is
  * called when a scaled-font needs to be created for a user font-face.
+ *
+ * The cairo context @cr is not used by the caller, but is prepared in font
+ * space, similar to what the cairo contexts passed to the render_glyph
+ * method will look like.  The callback can use this context for extents
+ * computation for example.  After the callback is called, @cr is checked
+ * for any error status.
  *
  * The @extents argument is where the user font sets the font extents for
  * @scaled_font.  It is in font space, which means that for most cases its
  * ascent and descent members should add to 1.0.  @extents is preset to
  * hold a value of 1.0 for ascent, height, and max_x_advance, and 0.0 for
@@ -1334,15 +1460,14 @@ cairo_user_font_face_create (void);
  * in deadlock.
  *
  * Returns: %CAIRO_STATUS_SUCCESS upon success, or
  * %CAIRO_STATUS_USER_FONT_ERROR or any other error status on error.
  *
- * Returns: the status code of the operation
- *
  * Since: 1.8
  **/
 typedef cairo_status_t (*cairo_user_scaled_font_init_func_t) (cairo_scaled_font_t  *scaled_font,
+							      cairo_t              *cr,
 							      cairo_font_extents_t *extents);
 
 /**
  * cairo_user_scaled_font_render_glyph_func_t:
  * @scaled_font: user scaled-font
@@ -1392,45 +1517,80 @@ typedef cairo_status_t (*cairo_user_scal
 								      cairo_text_extents_t *extents);
 
 /**
  * cairo_user_scaled_font_text_to_glyphs_func_t:
  * @scaled_font: the scaled-font being created
- * @utf8: input string of text, encoded in UTF-8
- * @glyphs: output array of glyphs, in font space
- * @num_glyphs: number of output glyphs
+ * @utf8: a string of text encoded in UTF-8
+ * @utf8_len: length of @utf8 in bytes
+ * @glyphs: pointer to array of glyphs to fill, in font space
+ * @num_glyphs: pointer to number of glyphs
+ * @clusters: pointer to array of cluster mapping information to fill, or %NULL
+ * @num_clusters: pointer to number of clusters
+ * @backward: pointer to whether the text to glyphs mapping goes backward
  *
  * #cairo_user_scaled_font_text_to_glyphs_func_t is the type of function which
  * is called to convert input text to an array of glyphs.  This is used by the
  * cairo_show_text() operation.
  *
- * Using this callback the user font has full control on glyphs and their
+ * Using this callback the user-font has full control on glyphs and their
  * positions.  That means, it allows for features like ligatures and kerning,
  * as well as complex <firstterm>shaping</firstterm> required for scripts like
  * Arabic and Indic.
  *
  * The @num_glyphs argument is preset to -1.  The callback should allocate an
  * array for the resulting glyphs (using malloc()), and populate the glyph indices and
  * positions (in font space) assuming that the text is to be shown at the
  * origin.  Cairo will free the glyph array when done with it, no matter what
  * the return value of the callback is.
  *
+ * If @glyphs initially points to a non-%NULL value, that array can be used
+ * as a glyph buffer, and @num_glyphs points to the number of glyph
+ * entries available there.  If the provided glyph array is too short for
+ * the conversion (or for convenience), a new glyph array may be allocated
+ * using cairo_glyph_allocate() and placed in @glyphs.  Upon return,
+ * @num_glyphs should contain the number of generated glyphs.
+ * If the value @glyphs points at has changed after the call, cairo will
+ * free the allocated glyph array using cairo_glyph_free().
+ *
+ * If @clusters is not %NULL, @num_clusters and @backward are also non-%NULL,
+ * and cluster mapping should be computed.
+ * The semantics of how cluster array allocation works is similar to the glyph
+ * array.  That is,
+ * if @clusters initially points to a non-%NULL value, that array may be used
+ * as a cluster buffer, and @num_clusters points to the number of cluster
+ * entries available there.  If the provided cluster array is too short for
+ * the conversion (or for convenience), a new cluster array may be allocated
+ * using cairo_text_cluster_allocate() and placed in @clusters.  Upon return,
+ * @num_clusters should contain the number of generated clusters.
+ * If the value @clusters points at has changed after the call, cairo will
+ * free the allocated cluster array using cairo_text_cluster_free().
+ *
  * The callback is optional.  If not set, or if @num_glyphs is negative upon
- * the callback returning (which by default is), the unicode_to_glyph callback
+ * the callback returning, the unicode_to_glyph callback
  * is tried.  See #cairo_user_scaled_font_unicode_to_glyph_func_t.
  *
- * Note: The signature and details of this callback is expected to change
- * before cairo 1.8.0 is released.
+ * Note: While cairo does not impose any limitation on glyph indices,
+ * some applications may assume that a glyph index fits in a 16-bit
+ * unsigned integer.  As such, it is advised that user-fonts keep their
+ * glyphs in the 0 to 65535 range.  Furthermore, some applications may
+ * assume that glyph 0 is a special glyph-not-found glyph.  User-fonts
+ * are advised to use glyph 0 for such purposes and do not use that
+ * glyph value for other purposes.
  *
  * Returns: %CAIRO_STATUS_SUCCESS upon success, or
  * %CAIRO_STATUS_USER_FONT_ERROR or any other error status on error.
  *
  * Since: 1.8
  **/
 typedef cairo_status_t (*cairo_user_scaled_font_text_to_glyphs_func_t) (cairo_scaled_font_t   *scaled_font,
-									const char            *utf8,
-									cairo_glyph_t        **glyphs,
-									int                   *num_glyphs);
+									const char	      *utf8,
+									int		       utf8_len,
+									cairo_glyph_t	     **glyphs,
+									int		      *num_glyphs,
+									cairo_text_cluster_t **clusters,
+									int		      *num_clusters,
+									cairo_bool_t	      *backward);
 
 /**
  * cairo_user_scaled_font_unicode_to_glyph_func_t:
  * @scaled_font: the scaled-font being created
  * @unicode: input unicode character code-point
@@ -1450,10 +1610,18 @@ typedef cairo_status_t (*cairo_user_scal
  * complex scripts can be implemented using this callback.
  *
  * The callback is optional, and only used if text_to_glyphs callback is not
  * set or fails to return glyphs.  If this callback is not set, an identity
  * mapping from Unicode code-points to glyph indices is assumed.
+ *
+ * Note: While cairo does not impose any limitation on glyph indices,
+ * some applications may assume that a glyph index fits in a 16-bit
+ * unsigned integer.  As such, it is advised that user-fonts keep their
+ * glyphs in the 0 to 65535 range.  Furthermore, some applications may
+ * assume that glyph 0 is a special glyph-not-found glyph.  User-fonts
+ * are advised to use glyph 0 for such purposes and do not use that
+ * glyph value for other purposes.
  *
  * Returns: %CAIRO_STATUS_SUCCESS upon success, or
  * %CAIRO_STATUS_USER_FONT_ERROR or any other error status on error.
  *
  * Since: 1.8
@@ -1837,10 +2005,13 @@ cairo_surface_copy_page (cairo_surface_t
 cairo_surface_copy_page (cairo_surface_t *surface);
 
 cairo_public void
 cairo_surface_show_page (cairo_surface_t *surface);
 
+cairo_public cairo_bool_t
+cairo_surface_has_show_text_glyphs (cairo_surface_t *surface);
+
 /* Image-surface functions */
 
 /**
  * cairo_format_t:
  * @CAIRO_FORMAT_ARGB32: each pixel is a 32-bit quantity, with
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/cairoint.h
--- a/gfx/cairo/cairo/src/cairoint.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/cairoint.h	Mon Sep 08 10:35:45 2008 +0300
@@ -48,10 +48,17 @@
 
 #if HAVE_CONFIG_H
 #include "config.h"
 #endif
 
+/* We use our own macros */
+#undef PACKAGE
+#undef PACKAGE_NAME
+#undef PACKAGE_STRING
+#undef PACKAGE_TARNAME
+#undef PACKAGE_VERSION
+
 #include <assert.h>
 #include <stdlib.h>
 #include <string.h>
 #include <stdarg.h>
 #include <stddef.h>
@@ -65,10 +72,18 @@
 
 #include "cairo.h"
 #include <pixman.h>
 
 #include "cairo-compiler-private.h"
+
+#if defined(CAIRO_HAS_PS_SURFACE) || defined(CAIRO_HAS_PDF_SURFACE) || defined(CAIRO_HAS_SVG_SURFACE)
+#define CAIRO_HAS_FONT_SUBSET 1
+#endif
+
+#if defined(CAIRO_HAS_PS_SURFACE) || defined(CAIRO_HAS_PDF_SURFACE)
+#define CAIRO_HAS_PDF_OPERATORS 1
+#endif
 
 CAIRO_BEGIN_DECLS
 
 #ifdef _WIN32
 cairo_private FILE *
@@ -115,11 +130,21 @@ _cairo_win32_tmpfile (void);
 
 /* This has to be updated whenever #cairo_status_t is extended.  That's
  * a bit of a pain, but it should be easy to always catch as long as
  * one adds a new test case to test a trigger of the new status value.
  */
-#define CAIRO_STATUS_LAST_STATUS CAIRO_STATUS_INVALID_CLUSTERS
+#define CAIRO_STATUS_LAST_STATUS CAIRO_STATUS_INVALID_SLANT
+
+#ifdef __GNUC__
+#define cairo_container_of(ptr, type, member) ({ \
+    const typeof(((type *) 0)->member) *mptr__ = (ptr); \
+    (type *) ((char *) mptr__ - offsetof (type, member)); \
+})
+#else
+#define cairo_container_of(ptr, type, member) \
+    (type *)((char *) (ptr) - (char *) &((type *)0)->member)
+#endif
 
 
 /* Size in bytes of buffer to use off the stack per functions.
  * Mostly used by text functions.  For larger allocations, they'll
  * malloc(). */
@@ -304,12 +329,10 @@ _cairo_user_data_array_set_data (cairo_u
 				 cairo_destroy_func_t	      destroy);
 
 cairo_private unsigned long
 _cairo_hash_string (const char *c);
 
-typedef struct _cairo_unscaled_font_backend cairo_unscaled_font_backend_t;
-
 /*
  * A #cairo_unscaled_font_t is just an opaque handle we use in the
  * glyph cache.
  */
 typedef struct _cairo_unscaled_font {
@@ -413,16 +436,20 @@ struct _cairo_scaled_font_backend {
     /* A backend only needs to implement this or ucs4_to_index(), not
      * both. This allows the backend to do something more sophisticated
      * then just converting characters one by one.
      */
     cairo_warn cairo_int_status_t
-    (*text_to_glyphs) (void                *scaled_font,
-		       double		    x,
-		       double		    y,
-		       const char          *utf8,
-		       cairo_glyph_t      **glyphs,
-		       int 		   *num_glyphs);
+    (*text_to_glyphs) (void                  *scaled_font,
+		       double		      x,
+		       double		      y,
+		       const char	     *utf8,
+		       int		      utf8_len,
+		       cairo_glyph_t	    **glyphs,
+		       int		     *num_glyphs,
+		       cairo_text_cluster_t **clusters,
+		       int		     *num_clusters,
+		       cairo_bool_t	     *backward);
 
     unsigned long
     (*ucs4_to_index)		(void			     *scaled_font,
 				 uint32_t		      ucs4);
     cairo_warn cairo_int_status_t
@@ -487,12 +514,10 @@ extern const cairo_private struct _cairo
 #if CAIRO_HAS_QUARTZ_FONT
 
 extern const cairo_private struct _cairo_scaled_font_backend _cairo_quartz_scaled_font_backend;
 
 #endif
-
-typedef struct _cairo_solid_pattern cairo_solid_pattern_t;
 
 struct _cairo_surface_backend {
     cairo_surface_type_t type;
 
     cairo_surface_t *
@@ -956,12 +981,10 @@ typedef struct _cairo_traps {
 #define CAIRO_GSTATE_DEFAULT_FONT_SIZE  10.0
 
 #define CAIRO_SURFACE_RESOLUTION_DEFAULT 72.0
 #define CAIRO_SURFACE_FALLBACK_RESOLUTION_DEFAULT 300.0
 
-typedef struct _cairo_gstate cairo_gstate_t;
-
 typedef struct _cairo_stroke_face {
     cairo_point_t ccw;
     cairo_point_t point;
     cairo_point_t cw;
     cairo_slope_t dev_vector;
@@ -1224,16 +1247,20 @@ cairo_private cairo_status_t
 cairo_private cairo_status_t
 _cairo_gstate_set_font_face (cairo_gstate_t    *gstate,
 			     cairo_font_face_t *font_face);
 
 cairo_private cairo_status_t
-_cairo_gstate_text_to_glyphs (cairo_gstate_t *font,
-			      const char     *utf8,
-			      double	      x,
-			      double	      y,
-			      cairo_glyph_t **glyphs,
-			      int	     *num_glyphs);
+_cairo_gstate_text_to_glyphs (cairo_gstate_t	    *gstate,
+			      double		     x,
+			      double		     y,
+			      const char	    *utf8,
+			      int		     utf8_len,
+			      cairo_glyph_t	   **glyphs,
+			      int		    *num_glyphs,
+			      cairo_text_cluster_t **clusters,
+			      int		    *num_clusters,
+			      cairo_bool_t	    *backward);
 
 cairo_private cairo_status_t
 _cairo_gstate_glyph_extents (cairo_gstate_t *gstate,
 			     const cairo_glyph_t *glyphs,
 			     int num_glyphs,
@@ -1309,24 +1336,19 @@ _cairo_color_equal (const cairo_color_t 
 _cairo_color_equal (const cairo_color_t *color_a,
                     const cairo_color_t *color_b);
 
 /* cairo-font-face.c */
 
-extern const cairo_private cairo_font_face_t _cairo_font_face_nil;
+extern const cairo_private cairo_toy_font_face_t _cairo_font_face_nil;
 
 cairo_private void
 _cairo_font_face_init (cairo_font_face_t               *font_face,
 		       const cairo_font_face_backend_t *backend);
 
 cairo_private cairo_status_t
 _cairo_font_face_set_error (cairo_font_face_t *font_face,
 	                    cairo_status_t     status);
-
-cairo_private cairo_font_face_t *
-_cairo_toy_font_face_create (const char           *family,
-			     cairo_font_slant_t    slant,
-			     cairo_font_weight_t   weight);
 
 cairo_private void
 _cairo_unscaled_font_init (cairo_unscaled_font_t               *font,
 			   const cairo_unscaled_font_backend_t *backend);
 
@@ -1350,10 +1372,20 @@ _cairo_hull_compute (cairo_pen_vertex_t 
 _cairo_hull_compute (cairo_pen_vertex_t *vertices, int *num_vertices);
 
 /* cairo-lzw.c */
 cairo_private unsigned char *
 _cairo_lzw_compress (unsigned char *data, unsigned long *size_in_out);
+
+/* cairo-misc.c */
+cairo_private cairo_status_t
+_cairo_validate_text_clusters (const char		   *utf8,
+			       int			    utf8_len,
+			       const cairo_glyph_t	   *glyphs,
+			       int			    num_glyphs,
+			       const cairo_text_cluster_t  *clusters,
+			       int			    num_clusters,
+			       cairo_bool_t		    backward);
 
 /* cairo-path-fixed.c */
 cairo_private void
 _cairo_path_fixed_init (cairo_path_fixed_t *path);
 
@@ -1537,18 +1569,10 @@ _cairo_scaled_font_fini (cairo_scaled_fo
 _cairo_scaled_font_fini (cairo_scaled_font_t *scaled_font);
 
 cairo_private cairo_status_t
 _cairo_scaled_font_font_extents (cairo_scaled_font_t  *scaled_font,
 				 cairo_font_extents_t *extents);
-
-cairo_private cairo_status_t
-_cairo_scaled_font_text_to_glyphs (cairo_scaled_font_t	*scaled_font,
-				   double		x,
-				   double		y,
-				   const char           *utf8,
-				   cairo_glyph_t       **glyphs,
-				   int 		        *num_glyphs);
 
 cairo_private cairo_status_t
 _cairo_scaled_font_glyph_device_extents (cairo_scaled_font_t	 *scaled_font,
 					 const cairo_glyph_t	 *glyphs,
 					 int                      num_glyphs,
@@ -1751,13 +1775,10 @@ _cairo_surface_fill (cairo_surface_t	*su
 		     cairo_pattern_t	*source,
 		     cairo_path_fixed_t	*path,
 		     cairo_fill_rule_t	 fill_rule,
 		     double		 tolerance,
 		     cairo_antialias_t	 antialias);
-
-cairo_private cairo_bool_t
-_cairo_surface_has_show_text_glyphs (cairo_surface_t	    *surface);
 
 cairo_private cairo_status_t
 _cairo_surface_show_text_glyphs (cairo_surface_t	    *surface,
 				 cairo_operator_t	     op,
 				 cairo_pattern_t	    *source,
@@ -2136,15 +2157,15 @@ _cairo_matrix_transform_bounding_box_fix
 					    cairo_bool_t         *is_tight);
 
 cairo_private cairo_bool_t
 _cairo_matrix_is_invertible (const cairo_matrix_t *matrix);
 
-cairo_private void
-_cairo_matrix_compute_determinant (const cairo_matrix_t *matrix, double *det);
+cairo_private double
+_cairo_matrix_compute_determinant (const cairo_matrix_t *matrix);
 
 cairo_private cairo_status_t
-_cairo_matrix_compute_scale_factors (const cairo_matrix_t *matrix,
+_cairo_matrix_compute_basis_scale_factors (const cairo_matrix_t *matrix,
 				     double *sx, double *sy, int x_major);
 
 cairo_private cairo_bool_t
 _cairo_matrix_is_identity (const cairo_matrix_t *matrix);
 
@@ -2326,10 +2347,14 @@ _cairo_gstate_get_antialias (cairo_gstat
 
 #include "cairo-region-private.h"
 
 /* cairo-unicode.c */
 
+cairo_private int
+_cairo_utf8_get_char_validated (const char *p,
+				uint32_t   *unicode);
+
 cairo_private cairo_status_t
 _cairo_utf8_to_ucs4 (const char *str,
 		     int	 len,
 		     uint32_t  **result,
 		     int	*items_written);
@@ -2371,15 +2396,20 @@ slim_hidden_proto (cairo_font_options_ha
 slim_hidden_proto (cairo_font_options_hash);
 slim_hidden_proto (cairo_font_options_merge);
 slim_hidden_proto (cairo_font_options_set_antialias);
 slim_hidden_proto (cairo_font_options_set_hint_metrics);
 slim_hidden_proto (cairo_font_options_set_hint_style);
+slim_hidden_proto (cairo_font_options_set_lcd_filter);
 slim_hidden_proto (cairo_font_options_set_subpixel_order);
 slim_hidden_proto (cairo_font_options_status);
 slim_hidden_proto (cairo_get_current_point);
 slim_hidden_proto (cairo_get_matrix);
+slim_hidden_proto (cairo_get_target);
 slim_hidden_proto (cairo_get_tolerance);
+slim_hidden_proto (cairo_has_show_text_glyphs);
+slim_hidden_proto (cairo_glyph_allocate);
+slim_hidden_proto (cairo_glyph_free);
 slim_hidden_proto (cairo_image_surface_create);
 slim_hidden_proto (cairo_image_surface_create_for_data);
 slim_hidden_proto (cairo_image_surface_get_data);
 slim_hidden_proto (cairo_image_surface_get_height);
 slim_hidden_proto (cairo_image_surface_get_stride);
@@ -2424,10 +2454,11 @@ slim_hidden_proto (cairo_scaled_font_ext
 slim_hidden_proto (cairo_scaled_font_extents);
 slim_hidden_proto (cairo_scaled_font_get_ctm);
 slim_hidden_proto (cairo_scaled_font_get_font_face);
 slim_hidden_proto (cairo_scaled_font_get_font_matrix);
 slim_hidden_proto (cairo_scaled_font_get_font_options);
+slim_hidden_proto (cairo_scaled_font_text_to_glyphs);
 slim_hidden_proto (cairo_scaled_font_glyph_extents);
 slim_hidden_proto_no_warn (cairo_scaled_font_reference);
 slim_hidden_proto (cairo_scaled_font_status);
 slim_hidden_proto (cairo_set_font_size);
 slim_hidden_proto (cairo_set_font_options);
@@ -2444,17 +2475,21 @@ slim_hidden_proto (cairo_surface_flush);
 slim_hidden_proto (cairo_surface_flush);
 slim_hidden_proto (cairo_surface_get_content);
 slim_hidden_proto (cairo_surface_get_device_offset);
 slim_hidden_proto (cairo_surface_get_font_options);
 slim_hidden_proto (cairo_surface_get_type);
+slim_hidden_proto (cairo_surface_has_show_text_glyphs);
 slim_hidden_proto (cairo_surface_mark_dirty_rectangle);
 slim_hidden_proto_no_warn (cairo_surface_reference);
 slim_hidden_proto (cairo_surface_set_device_offset);
 slim_hidden_proto (cairo_surface_set_fallback_resolution);
 slim_hidden_proto (cairo_surface_copy_page);
 slim_hidden_proto (cairo_surface_show_page);
 slim_hidden_proto (cairo_surface_status);
+slim_hidden_proto (cairo_text_cluster_allocate);
+slim_hidden_proto (cairo_text_cluster_free);
+slim_hidden_proto (cairo_toy_font_face_create);
 slim_hidden_proto (cairo_version_string);
 
 #if CAIRO_HAS_PNG_FUNCTIONS
 
 slim_hidden_proto (cairo_surface_write_to_png_stream);
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/check-link.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/cairo/cairo/src/check-link.c	Mon Sep 08 10:35:45 2008 +0300
@@ -0,0 +1,24 @@
+#define CAIRO_VERSION_H 1
+
+#include <cairo.h>
+
+/* get the "real" version info instead of dummy cairo-version.h */
+#undef CAIRO_VERSION_H
+#include "../cairo-version.h"
+
+#include <stdio.h>
+
+int
+main (void)
+{
+  printf ("Check linking to the just built cairo library\n");
+  if (cairo_version () == CAIRO_VERSION) {
+    return 0;
+  } else {
+    fprintf (stderr,
+	     "Error: linked to cairo version %s instead of %s\n",
+	     cairo_version_string (),
+	     CAIRO_VERSION_STRING);
+    return 1;
+  }
+}
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/test-meta-surface.c
--- a/gfx/cairo/cairo/src/test-meta-surface.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/test-meta-surface.c	Mon Sep 08 10:35:45 2008 +0300
@@ -258,11 +258,11 @@ static cairo_bool_t
 static cairo_bool_t
 _test_meta_surface_has_show_text_glyphs (void *abstract_surface)
 {
     test_meta_surface_t *surface = abstract_surface;
 
-    return _cairo_surface_has_show_text_glyphs (surface->meta);
+    return cairo_surface_has_show_text_glyphs (surface->meta);
 }
 
 static cairo_int_status_t
 _test_meta_surface_show_text_glyphs (void		    *abstract_surface,
 				     cairo_operator_t	     op,
diff -r 14ce7619e9c1 gfx/cairo/cairo/src/test-paginated-surface.c
--- a/gfx/cairo/cairo/src/test-paginated-surface.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/cairo/src/test-paginated-surface.c	Mon Sep 08 10:35:45 2008 +0300
@@ -235,11 +235,11 @@ static cairo_bool_t
 static cairo_bool_t
 _test_paginated_surface_has_show_text_glyphs (void *abstract_surface)
 {
     test_paginated_surface_t *surface = abstract_surface;
 
-    return _cairo_surface_has_show_text_glyphs (surface->target);
+    return cairo_surface_has_show_text_glyphs (surface->target);
 }
 
 static cairo_int_status_t
 _test_paginated_surface_show_text_glyphs (void			    *abstract_surface,
 					  cairo_operator_t	     op,
diff -r 14ce7619e9c1 gfx/cairo/clip-clone.patch
--- a/gfx/cairo/clip-clone.patch	Sat Sep 06 22:21:37 2008 +1200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,31 +0,0 @@
-diff -NrpU12 mozilla-trunk.56113bebf57f/gfx/cairo/cairo/src/cairo-clip.c mozilla-trunk/gfx/cairo/cairo/src/cairo-clip.c
---- mozilla-trunk.56113bebf57f/gfx/cairo/cairo/src/cairo-clip.c	2008-04-16 16:02:09.000000000 +1200
-+++ mozilla-trunk/gfx/cairo/cairo/src/cairo-clip.c	2008-04-16 16:02:09.000000000 +1200
-@@ -669,26 +669,25 @@ _cairo_clip_init_deep_copy (cairo_clip_t
-          * whatever the right handling is happen */
-     } else {
-         if (other->has_region) {
-             status = _cairo_region_copy (&clip->region, &other->region);
- 	    if (status)
- 		goto BAIL;
- 
- 	    clip->has_region = TRUE;
-         }
- 
-         if (other->surface) {
-             status = _cairo_surface_clone_similar (target, other->surface,
--					           other->surface_rect.x,
--						   other->surface_rect.y,
-+					           0, 0,
- 						   other->surface_rect.width,
- 						   other->surface_rect.height,
- 						   &clip->surface);
- 	    if (status)
- 		goto BAIL;
- 
-             clip->surface_rect = other->surface_rect;
-         }
- 
-         if (other->path) {
-             status = _cairo_clip_path_reapply_clip_path (clip, other->path);
- 	    if (status && status != CAIRO_INT_STATUS_UNSUPPORTED)
diff -r 14ce7619e9c1 gfx/cairo/libpixman/src/Makefile.in
--- a/gfx/cairo/libpixman/src/Makefile.in	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/libpixman/src/Makefile.in	Mon Sep 08 10:35:45 2008 +0300
@@ -46,14 +46,10 @@ include $(DEPTH)/config/autoconf.mk
 
 MODULE		= libpixman
 LIBRARY_NAME	= mozlibpixman
 LIBXUL_LIBRARY = 1
 
-ifndef MOZ_ENABLE_LIBXUL
-VISIBILITY_FLAGS =
-endif
-
 ifdef GNU_CC
 MODULE_OPTIMIZE_FLAGS = -O2
 else
 ifeq ($(OS_ARCH),SunOS)
 MODULE_OPTIMIZE_FLAGS = -xO5
@@ -66,20 +62,19 @@ endif
 endif
 
 # Build MMX code either with VC or with gcc-on-x86
 ifdef _MSC_VER
 USE_MMX=1
-# no SSE2 yet, until compilation is fixed
 #USE_SSE2=1
 MMX_CFLAGS=
 endif
 
 ifdef GNU_CC
 ifeq (86,$(findstring 86,$(OS_TEST)))
 USE_MMX=1
 MMX_CFLAGS=-mmmx -Winline
-# See bug 410509 why we can't use SSE2 yet
+# See bug 410509 why we can't use SSE2 yet on linux
 #USE_SSE2=1
 #MMX_CFLAGS+=-msse -msse2
 ifneq ($(MOZ_WIDGET_TOOLKIT),os2)
 MMX_CFLAGS+=--param inline-unit-growth=10000 --param large-function-growth=10000
 endif
@@ -112,11 +107,11 @@ CSRCS += pixman-mmx.c
 CSRCS += pixman-mmx.c
 DEFINES += -DUSE_MMX
 endif
 
 ifdef USE_SSE2
-CSRCS += pixman-sse.c
+CSRCS += pixman-sse2.c
 DEFINES += -DUSE_SSE -DUSE_SSE2
 endif
 
 ifdef USE_VMX
 CSRCS += pixman-vmx.c
@@ -139,9 +134,9 @@ pixman-mmx.$(OBJ_SUFFIX): pixman-mmx.c M
 pixman-mmx.$(OBJ_SUFFIX): pixman-mmx.c Makefile Makefile.in
 	$(REPORT_BUILD)
 	@$(MAKE_DEPS_AUTO_CC)
 	$(ELOG) $(CC) $(OUTOPTION)$@ -c $(COMPILE_CFLAGS) $(MMX_CFLAGS) $(_VPATH_SRCS)
 
-pixman-sse.$(OBJ_SUFFIX): pixman-sse.c Makefile Makefile.in
+pixman-sse2.$(OBJ_SUFFIX): pixman-sse2.c Makefile Makefile.in
 	$(REPORT_BUILD)
 	@$(MAKE_DEPS_AUTO_CC)
 	$(ELOG) $(CC) $(OUTOPTION)$@ -c $(COMPILE_CFLAGS) $(MMX_CFLAGS) $(_VPATH_SRCS)
diff -r 14ce7619e9c1 gfx/cairo/libpixman/src/pixman-combine32.h
--- a/gfx/cairo/libpixman/src/pixman-combine32.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/libpixman/src/pixman-combine32.h	Mon Sep 08 10:35:45 2008 +0300
@@ -59,23 +59,35 @@
 
 /*
   x_c = (x_c * a) / 255 + y
 */
 #define FbByteMulAdd(x, a, y) do {                                      \
+        /* multiply and divide: trunc((i + 128)*257/65536) */           \
         uint32_t t = ((x & RB_MASK) * a) + RB_ONE_HALF;                  \
         t = (t + ((t >> COMPONENT_SIZE) & RB_MASK)) >> COMPONENT_SIZE;  \
         t &= RB_MASK;                                                   \
+                                                                        \
+        /* add */                                                       \
         t += y & RB_MASK;                                               \
+                                                                        \
+        /* saturate */                                                  \
         t |= RB_MASK_PLUS_ONE - ((t >> COMPONENT_SIZE) & RB_MASK);      \
         t &= RB_MASK;                                                   \
                                                                         \
+        /* multiply and divide */                                       \
         x = (((x >> COMPONENT_SIZE) & RB_MASK) * a) + RB_ONE_HALF;      \
         x = (x + ((x >> COMPONENT_SIZE) & RB_MASK)) >> COMPONENT_SIZE;  \
         x &= RB_MASK;                                                   \
+                                                                        \
+        /* add */                                                       \
         x += (y >> COMPONENT_SIZE) & RB_MASK;                           \
+                                                                        \
+        /* saturate */                                                  \
         x |= RB_MASK_PLUS_ONE - ((x >> COMPONENT_SIZE) & RB_MASK);      \
         x &= RB_MASK;                                                   \
+                                                                        \
+        /* recombine */                                                 \
         x <<= COMPONENT_SIZE;                                           \
         x += t;                                                         \
     } while (0)
 
 /*
diff -r 14ce7619e9c1 gfx/cairo/libpixman/src/pixman-combine64.h
--- a/gfx/cairo/libpixman/src/pixman-combine64.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/libpixman/src/pixman-combine64.h	Mon Sep 08 10:35:45 2008 +0300
@@ -59,23 +59,35 @@
 
 /*
   x_c = (x_c * a) / 255 + y
 */
 #define FbByteMulAdd(x, a, y) do {                                      \
+        /* multiply and divide: trunc((i + 128)*257/65536) */           \
         uint64_t t = ((x & RB_MASK) * a) + RB_ONE_HALF;                  \
         t = (t + ((t >> COMPONENT_SIZE) & RB_MASK)) >> COMPONENT_SIZE;  \
         t &= RB_MASK;                                                   \
+                                                                        \
+        /* add */                                                       \
         t += y & RB_MASK;                                               \
+                                                                        \
+        /* saturate */                                                  \
         t |= RB_MASK_PLUS_ONE - ((t >> COMPONENT_SIZE) & RB_MASK);      \
         t &= RB_MASK;                                                   \
                                                                         \
+        /* multiply and divide */                                       \
         x = (((x >> COMPONENT_SIZE) & RB_MASK) * a) + RB_ONE_HALF;      \
         x = (x + ((x >> COMPONENT_SIZE) & RB_MASK)) >> COMPONENT_SIZE;  \
         x &= RB_MASK;                                                   \
+                                                                        \
+        /* add */                                                       \
         x += (y >> COMPONENT_SIZE) & RB_MASK;                           \
+                                                                        \
+        /* saturate */                                                  \
         x |= RB_MASK_PLUS_ONE - ((x >> COMPONENT_SIZE) & RB_MASK);      \
         x &= RB_MASK;                                                   \
+                                                                        \
+        /* recombine */                                                 \
         x <<= COMPONENT_SIZE;                                           \
         x += t;                                                         \
     } while (0)
 
 /*
diff -r 14ce7619e9c1 gfx/cairo/libpixman/src/pixman-mmx.c
--- a/gfx/cairo/libpixman/src/pixman-mmx.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/libpixman/src/pixman-mmx.c	Mon Sep 08 10:35:45 2008 +0300
@@ -34,13 +34,10 @@
 #endif
 
 #ifdef USE_MMX
 
 #include <mmintrin.h>
-#ifdef USE_SSE
-#include <xmmintrin.h> /* for _mm_shuffle_pi16 and _MM_SHUFFLE */
-#endif
 
 #include "pixman-mmx.h"
 
 #undef READ
 #undef WRITE
@@ -225,32 +222,10 @@ pix_add (__m64 a, __m64 b)
 pix_add (__m64 a, __m64 b)
 {
     return  _mm_adds_pu8 (a, b);
 }
 
-#ifdef USE_SSE
-
-static inline __m64
-expand_alpha (__m64 pixel)
-{
-    return _mm_shuffle_pi16 (pixel, _MM_SHUFFLE(3, 3, 3, 3));
-}
-
-static inline __m64
-expand_alpha_rev (__m64 pixel)
-{
-    return _mm_shuffle_pi16 (pixel, _MM_SHUFFLE(0, 0, 0, 0));
-}
-
-static inline __m64
-invert_colors (__m64 pixel)
-{
-    return _mm_shuffle_pi16 (pixel, _MM_SHUFFLE(3, 0, 1, 2));
-}
-
-#else
-
 static inline __m64
 expand_alpha (__m64 pixel)
 {
     __m64 t1, t2;
 
@@ -297,12 +272,10 @@ invert_colors (__m64 pixel)
     x = _mm_or_si64 (x, y);
     x = _mm_or_si64 (x, z);
 
     return x;
 }
-
-#endif
 
 static inline __m64
 over (__m64 src, __m64 srca, __m64 dest)
 {
     return  _mm_adds_pu8 (src, pix_multiply(dest, negate(srca)));
diff -r 14ce7619e9c1 gfx/cairo/libpixman/src/pixman-pict.c
--- a/gfx/cairo/libpixman/src/pixman-pict.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/libpixman/src/pixman-pict.c	Mon Sep 08 10:35:45 2008 +0300
@@ -31,11 +31,11 @@
 #include <stdlib.h>
 #include <string.h>
 #include "pixman-private.h"
 #include "pixman-mmx.h"
 #include "pixman-vmx.h"
-#include "pixman-sse.h"
+#include "pixman-sse2.h"
 #include "pixman-combine32.h"
 
 #ifdef __GNUC__
 #   define inline __inline__ __attribute__ ((__always_inline__))
 #endif
@@ -1393,11 +1393,11 @@ static const FastPathInfo mmx_fast_paths
     { PIXMAN_OP_NONE },
 };
 #endif
 
 #ifdef USE_SSE2
-static const FastPathInfo sse_fast_paths[] =
+static const FastPathInfo sse2_fast_paths[] =
 {
     { PIXMAN_OP_OVER, PIXMAN_solid,    PIXMAN_a8,       PIXMAN_r5g6b5,   fbCompositeSolidMask_nx8x0565sse2,     0 },
     { PIXMAN_OP_OVER, PIXMAN_solid,    PIXMAN_a8,       PIXMAN_b5g6r5,   fbCompositeSolidMask_nx8x0565sse2,     0 },
     { PIXMAN_OP_OVER, PIXMAN_solid,    PIXMAN_null,     PIXMAN_a8r8g8b8, fbCompositeSolid_nx8888sse2,           0 },
     { PIXMAN_OP_OVER, PIXMAN_solid,    PIXMAN_null,     PIXMAN_x8r8g8b8, fbCompositeSolid_nx8888sse2,           0 },
@@ -1753,11 +1753,11 @@ pixman_image_composite (pixman_op_t     
 #ifdef USE_VMX
     fbComposeSetupVMX();
 #endif
 
 #ifdef USE_SSE2
-    fbComposeSetupSSE();
+    fbComposeSetupSSE2();
 #endif
 
     if (srcRepeat && srcTransform &&
 	pSrc->bits.width == 1 &&
 	pSrc->bits.height == 1)
@@ -1813,12 +1813,12 @@ pixman_image_composite (pixman_op_t     
 	    !pMask->common.component_alpha	&&
 	    !maskRepeat;
 	info = NULL;
 	
 #ifdef USE_SSE2
-	if (pixman_have_sse ())
-	    info = get_fast_path (sse_fast_paths, op, pSrc, pMask, pDst, pixbuf);
+	if (pixman_have_sse2 ())
+	    info = get_fast_path (sse2_fast_paths, op, pSrc, pMask, pDst, pixbuf);
 #endif
 
 #ifdef USE_MMX
 	if (!info && pixman_have_mmx())
 	    info = get_fast_path (mmx_fast_paths, op, pSrc, pMask, pDst, pixbuf);
@@ -2147,23 +2147,23 @@ pixman_have_mmx (void)
     return mmx_present;
 }
 
 #ifdef USE_SSE2
 pixman_bool_t
-pixman_have_sse (void)
+pixman_have_sse2 (void)
 {
     static pixman_bool_t initialized = FALSE;
-    static pixman_bool_t sse_present;
+    static pixman_bool_t sse2_present;
 
     if (!initialized)
     {
         unsigned int features = detectCPUFeatures();
-        sse_present = (features & (MMX|MMX_Extensions|SSE|SSE2)) == (MMX|MMX_Extensions|SSE|SSE2);
+        sse2_present = (features & (MMX|MMX_Extensions|SSE|SSE2)) == (MMX|MMX_Extensions|SSE|SSE2);
         initialized = TRUE;
     }
 
-    return sse_present;
+    return sse2_present;
 }
 #endif
 
 #endif /* __amd64__ */
 #endif
diff -r 14ce7619e9c1 gfx/cairo/libpixman/src/pixman-private.h
--- a/gfx/cairo/libpixman/src/pixman-private.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/libpixman/src/pixman-private.h	Mon Sep 08 10:35:45 2008 +0300
@@ -729,10 +729,13 @@ pixman_compute_composite_region32 (pixma
 				   uint16_t		height);
 
 /* GCC visibility */
 #if defined(__GNUC__) && __GNUC__ >= 4
 #define PIXMAN_EXPORT __attribute__ ((visibility("default")))
+/* Sun Studio 8 visibility */
+#elif defined(__SUNPRO_C) && (__SUNPRO_C >= 0x550)
+#define PIXMAN_EXPORT __global
 #else
 #define PIXMAN_EXPORT
 #endif
 
 /* Region Helpers */
diff -r 14ce7619e9c1 gfx/cairo/libpixman/src/pixman-sse.c
--- a/gfx/cairo/libpixman/src/pixman-sse.c	Sat Sep 06 22:21:37 2008 +1200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,4653 +0,0 @@
-/*
- * Copyright © 2008 Rodrigo Kumpera
- * Copyright © 2008 André Tupinambá
- *
- * Permission to use, copy, modify, distribute, and sell this software and its
- * documentation for any purpose is hereby granted without fee, provided that
- * the above copyright notice appear in all copies and that both that
- * copyright notice and this permission notice appear in supporting
- * documentation, and that the name of Red Hat not be used in advertising or
- * publicity pertaining to distribution of the software without specific,
- * written prior permission.  Red Hat makes no representations about the
- * suitability of this software for any purpose.  It is provided "as is"
- * without express or implied warranty.
- *
- * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
- * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
- * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
- * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
- * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
- * SOFTWARE.
- *
- * Author:  Rodrigo Kumpera (kumpera@gmail.com)
- *          André Tupinambá (andrelrt@gmail.com)
- * 
- * Based on work by Owen Taylor and Søren Sandmann
- */
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <mmintrin.h>
-#include <xmmintrin.h> /* for _mm_shuffle_pi16 and _MM_SHUFFLE */
-#include <emmintrin.h> /* for SSE2 intrinsics */
-
-#include "pixman-sse.h"
-
-#ifdef USE_SSE2
-
-#ifdef _MSC_VER
-#undef inline
-#define inline __forceinline
-#endif
-
-/* -------------------------------------------------------------------------------------------------
- * Locals
- */
-
-static __m64 xMask0080;
-static __m64 xMask00ff;
-static __m64 xMask0101;
-static __m64 xMaskAlpha;
-
-static __m64 xMask565rgb;
-static __m64 xMask565Unpack;
-
-static __m128i Mask0080;
-static __m128i Mask00ff;
-static __m128i Mask0101;
-static __m128i Maskffff;
-static __m128i Maskff000000;
-static __m128i MaskAlpha;
-
-static __m128i Mask565r;
-static __m128i Mask565g1, Mask565g2;
-static __m128i Mask565b;
-static __m128i MaskRed;
-static __m128i MaskGreen;
-static __m128i MaskBlue;
-
-/* -------------------------------------------------------------------------------------------------
- * SSE2 Inlines
- */
-static inline __m128i
-unpack_32_1x128 (uint32_t data)
-{
-    return _mm_unpacklo_epi8 (_mm_cvtsi32_si128 (data), _mm_setzero_si128());
-}
-
-static inline void
-unpack_128_2x128 (__m128i data, __m128i* dataLo, __m128i* dataHi)
-{
-    *dataLo = _mm_unpacklo_epi8 (data, _mm_setzero_si128 ());
-    *dataHi = _mm_unpackhi_epi8 (data, _mm_setzero_si128 ());
-}
-
-static inline void
-unpack565_128_4x128 (__m128i data, __m128i* data0, __m128i* data1, __m128i* data2, __m128i* data3)
-{
-    __m128i lo, hi;
-    __m128i r, g, b;
-
-    lo = _mm_unpacklo_epi16 (data, _mm_setzero_si128 ());
-    hi = _mm_unpackhi_epi16 (data, _mm_setzero_si128 ());
-
-    r = _mm_and_si128 (_mm_slli_epi32 (lo, 8), MaskRed);
-    g = _mm_and_si128 (_mm_slli_epi32 (lo, 5), MaskGreen);
-    b = _mm_and_si128 (_mm_slli_epi32 (lo, 3), MaskBlue);
-
-    lo = _mm_or_si128 (_mm_or_si128 (r, g), b);
-
-    r = _mm_and_si128 (_mm_slli_epi32 (hi, 8), MaskRed);
-    g = _mm_and_si128 (_mm_slli_epi32 (hi, 5), MaskGreen);
-    b = _mm_and_si128 (_mm_slli_epi32 (hi, 3), MaskBlue);
-
-    hi = _mm_or_si128 (_mm_or_si128 (r, g), b);
-
-    unpack_128_2x128 (lo, data0, data1);
-    unpack_128_2x128 (hi, data2, data3);
-}
-
-static inline uint16_t
-pack565_32_16 (uint32_t pixel)
-{
-    return (uint16_t) (((pixel>>8) & 0xf800) | ((pixel>>5) & 0x07e0) | ((pixel>>3) & 0x001f));
-}
-
-static inline __m128i
-pack_2x128_128 (__m128i lo, __m128i hi)
-{
-    return _mm_packus_epi16 (lo, hi);
-}
-
-static inline __m128i
-pack565_2x128_128 (__m128i lo, __m128i hi)
-{
-    __m128i data;
-    __m128i r, g1, g2, b;
-
-    data = pack_2x128_128 ( lo, hi );
-
-    r  = _mm_and_si128 (data , Mask565r);
-    g1 = _mm_and_si128 (_mm_slli_epi32 (data , 3), Mask565g1);
-    g2 = _mm_and_si128 (_mm_srli_epi32 (data , 5), Mask565g2);
-    b  = _mm_and_si128 (_mm_srli_epi32 (data , 3), Mask565b);
-
-    return _mm_or_si128 (_mm_or_si128 (_mm_or_si128 (r, g1), g2), b);
-}
-
-static inline __m128i
-pack565_4x128_128 (__m128i xmm0, __m128i xmm1, __m128i xmm2, __m128i xmm3)
-{
-    __m128i lo, hi;
-
-    lo = _mm_packus_epi16 (pack565_2x128_128 ( xmm0, xmm1 ), _mm_setzero_si128 ());
-    hi = _mm_packus_epi16 (_mm_setzero_si128 (), pack565_2x128_128 ( xmm2, xmm3 ));
-
-    return _mm_or_si128 (lo, hi);
-}
-
-static inline uint32_t
-packAlpha (__m128i x)
-{
-    return _mm_cvtsi128_si32 (_mm_packus_epi16 (_mm_packus_epi16 (_mm_srli_epi32 (x, 24),
-                                                                  _mm_setzero_si128 ()),
-                                                _mm_setzero_si128 ()));
-}
-
-static inline __m128i
-expandPixel_32_1x128 (uint32_t data)
-{
-    return _mm_shuffle_epi32 (unpack_32_1x128 (data), _MM_SHUFFLE(1, 0, 1, 0));
-}
-
-static inline __m128i
-expandAlpha_1x128 (__m128i data)
-{
-    return _mm_shufflehi_epi16 (_mm_shufflelo_epi16 (data, _MM_SHUFFLE(3, 3, 3, 3)), _MM_SHUFFLE(3, 3, 3, 3));
-}
-
-static inline void
-expandAlpha_2x128 (__m128i dataLo, __m128i dataHi, __m128i* alphaLo, __m128i* alphaHi)
-{
-    __m128i lo, hi;
-
-    lo = _mm_shufflelo_epi16 (dataLo, _MM_SHUFFLE(3, 3, 3, 3));
-    hi = _mm_shufflelo_epi16 (dataHi, _MM_SHUFFLE(3, 3, 3, 3));
-    *alphaLo = _mm_shufflehi_epi16 (lo, _MM_SHUFFLE(3, 3, 3, 3));
-    *alphaHi = _mm_shufflehi_epi16 (hi, _MM_SHUFFLE(3, 3, 3, 3));
-}
-
-static inline void
-expandAlphaRev_2x128 (__m128i dataLo, __m128i dataHi, __m128i* alphaLo, __m128i* alphaHi)
-{
-    __m128i lo, hi;
-
-    lo = _mm_shufflelo_epi16 (dataLo, _MM_SHUFFLE(0, 0, 0, 0));
-    hi = _mm_shufflelo_epi16 (dataHi, _MM_SHUFFLE(0, 0, 0, 0));
-    *alphaLo = _mm_shufflehi_epi16 (lo, _MM_SHUFFLE(0, 0, 0, 0));
-    *alphaHi = _mm_shufflehi_epi16 (hi, _MM_SHUFFLE(0, 0, 0, 0));
-}
-
-static inline void
-pixMultiply_2x128 (__m128i dataLo, __m128i dataHi, __m128i alphaLo, __m128i alphaHi, __m128i* retLo, __m128i* retHi)
-{
-    __m128i lo, hi;
-
-    lo = _mm_mullo_epi16 (dataLo, alphaLo);
-    hi = _mm_mullo_epi16 (dataHi, alphaHi);
-    lo = _mm_adds_epu16 (lo, Mask0080);
-    hi = _mm_adds_epu16 (hi, Mask0080);
-    *retLo = _mm_mulhi_epu16 (lo, Mask0101);
-    *retHi = _mm_mulhi_epu16 (hi, Mask0101);
-}
-
-static inline void
-pixAddMultiply_2x128 (__m128i srcLo, __m128i srcHi, __m128i alphaDstLo, __m128i alphaDstHi,
-                      __m128i dstLo, __m128i dstHi, __m128i alphaSrcLo, __m128i alphaSrcHi,
-                      __m128i* retLo, __m128i* retHi)
-{
-    __m128i lo, hi;
-    __m128i mulLo, mulHi;
-
-    lo = _mm_mullo_epi16 (srcLo, alphaDstLo);
-    hi = _mm_mullo_epi16 (srcHi, alphaDstHi);
-    mulLo = _mm_mullo_epi16 (dstLo, alphaSrcLo);
-    mulHi = _mm_mullo_epi16 (dstHi, alphaSrcHi);
-    lo = _mm_adds_epu16 (lo, Mask0080);
-    hi = _mm_adds_epu16 (hi, Mask0080);
-    lo = _mm_adds_epu16 (lo, mulLo);
-    hi = _mm_adds_epu16 (hi, mulHi);
-    *retLo = _mm_mulhi_epu16 (lo, Mask0101);
-    *retHi = _mm_mulhi_epu16 (hi, Mask0101);
-}
-
-static inline void
-negate_2x128 (__m128i dataLo, __m128i dataHi, __m128i* negLo, __m128i* negHi)
-{
-    *negLo = _mm_xor_si128 (dataLo, Mask00ff);
-    *negHi = _mm_xor_si128 (dataHi, Mask00ff);
-}
-
-static inline void
-invertColors_2x128 (__m128i dataLo, __m128i dataHi, __m128i* invLo, __m128i* invHi)
-{
-    __m128i lo, hi;
-
-    lo = _mm_shufflelo_epi16 (dataLo, _MM_SHUFFLE(3, 0, 1, 2));
-    hi = _mm_shufflelo_epi16 (dataHi, _MM_SHUFFLE(3, 0, 1, 2));
-    *invLo = _mm_shufflehi_epi16 (lo, _MM_SHUFFLE(3, 0, 1, 2));
-    *invHi = _mm_shufflehi_epi16 (hi, _MM_SHUFFLE(3, 0, 1, 2));
-}
-
-static inline void
-over_2x128 (__m128i srcLo, __m128i srcHi, __m128i alphaLo, __m128i alphaHi, __m128i* dstLo, __m128i* dstHi)
-{
-    negate_2x128 (alphaLo, alphaHi, &alphaLo, &alphaHi);
-
-    pixMultiply_2x128 (*dstLo, *dstHi, alphaLo, alphaHi, dstLo, dstHi);
-
-    *dstLo = _mm_adds_epu8 (srcLo, *dstLo);
-    *dstHi = _mm_adds_epu8 (srcHi, *dstHi);
-}
-
-static inline void
-overRevNonPre_2x128 (__m128i srcLo, __m128i srcHi, __m128i* dstLo, __m128i* dstHi)
-{
-    __m128i lo, hi;
-    __m128i alphaLo, alphaHi;
-
-    expandAlpha_2x128 (srcLo, srcHi, &alphaLo, &alphaHi);
-
-    lo = _mm_or_si128 (alphaLo, MaskAlpha);
-    hi = _mm_or_si128 (alphaHi, MaskAlpha);
-
-    invertColors_2x128 (srcLo, srcHi, &srcLo, &srcHi);
-
-    pixMultiply_2x128 (srcLo, srcHi, lo, hi, &lo, &hi);
-
-    over_2x128 (lo, hi, alphaLo, alphaHi, dstLo, dstHi);
-}
-
-static inline void
-inOver_2x128 (__m128i srcLo,  __m128i srcHi,  __m128i  alphaLo, __m128i  alphaHi,
-              __m128i maskLo, __m128i maskHi, __m128i* dstLo,   __m128i* dstHi)
-{
-    __m128i sLo, sHi;
-    __m128i aLo, aHi;
-
-    pixMultiply_2x128 (  srcLo,   srcHi, maskLo, maskHi, &sLo, &sHi);
-    pixMultiply_2x128 (alphaLo, alphaHi, maskLo, maskHi, &aLo, &aHi);
-
-    over_2x128 (sLo, sHi, aLo, aHi, dstLo, dstHi);
-}
-
-static inline void
-cachePrefetch (__m128i* addr)
-{
-    _mm_prefetch (addr, _MM_HINT_T0);
-}
-
-static inline void
-cachePrefetchNext (__m128i* addr)
-{
-    _mm_prefetch (addr + 4, _MM_HINT_T0); // 64 bytes ahead
-}
-
-/* load 4 pixels from a 16-byte boundary aligned address */
-static inline __m128i
-load128Aligned (__m128i* src)
-{
-    return _mm_load_si128 (src);
-}
-
-/* load 4 pixels from a unaligned address */
-static inline __m128i
-load128Unaligned (__m128i* src)
-{
-    return _mm_loadu_si128 (src);
-}
-
-/* save 4 pixels using Write Combining memory on a 16-byte boundary aligned address */
-static inline void
-save128WriteCombining (__m128i* dst, __m128i data)
-{
-    _mm_stream_si128 (dst, data);
-}
-
-/* save 4 pixels on a 16-byte boundary aligned address */
-static inline void
-save128Aligned (__m128i* dst, __m128i data)
-{
-    _mm_store_si128 (dst, data);
-}
-
-/* save 4 pixels on a unaligned address */
-static inline void
-save128Unaligned (__m128i* dst, __m128i data)
-{
-    _mm_storeu_si128 (dst, data);
-}
-
-/* -------------------------------------------------------------------------------------------------
- * MMX inlines
- */
-
-static inline __m64
-unpack_32_1x64 (uint32_t data)
-{
-    return _mm_unpacklo_pi8 (_mm_cvtsi32_si64 (data), _mm_setzero_si64());
-}
-
-static inline __m64
-expandAlpha_1x64 (__m64 data)
-{
-    return _mm_shuffle_pi16 (data, _MM_SHUFFLE(3, 3, 3, 3));
-}
-
-static inline __m64
-expandAlphaRev_1x64 (__m64 data)
-{
-    return _mm_shuffle_pi16 (data, _MM_SHUFFLE(0, 0, 0, 0));
-}
-
-static inline __m64
-expandPixel_8_1x64 (uint8_t data)
-{
-    return _mm_shuffle_pi16 (unpack_32_1x64 ((uint32_t)data), _MM_SHUFFLE(0, 0, 0, 0));
-}
-
-static inline __m64
-pixMultiply_1x64 (__m64 data, __m64 alpha)
-{
-    return _mm_mulhi_pu16 (_mm_adds_pu16 (_mm_mullo_pi16 (data, alpha),
-                                          xMask0080),
-                           xMask0101);
-}
-
-static inline __m64
-pixAddMultiply_1x64 (__m64 src, __m64 alphaDst, __m64 dst, __m64 alphaSrc)
-{
-    return _mm_mulhi_pu16 (_mm_adds_pu16 (_mm_adds_pu16 (_mm_mullo_pi16 (src, alphaDst),
-                                                         xMask0080),
-                                          _mm_mullo_pi16 (dst, alphaSrc)),
-                           xMask0101);
-}
-
-static inline __m64
-negate_1x64 (__m64 data)
-{
-    return _mm_xor_si64 (data, xMask00ff);
-}
-
-static inline __m64
-invertColors_1x64 (__m64 data)
-{
-    return _mm_shuffle_pi16 (data, _MM_SHUFFLE(3, 0, 1, 2));
-}
-
-static inline __m64
-over_1x64 (__m64 src, __m64 alpha, __m64 dst)
-{
-    return _mm_adds_pu8 (src, pixMultiply_1x64 (dst, negate_1x64 (alpha)));
-}
-
-static inline __m64
-inOver_1x64 (__m64 src, __m64 alpha, __m64 mask, __m64 dst)
-{
-    return over_1x64 (pixMultiply_1x64 (src, mask),
-                      pixMultiply_1x64 (alpha, mask),
-                      dst);
-}
-
-static inline __m64
-overRevNonPre_1x64 (__m64 src, __m64 dst)
-{
-    __m64 alpha = expandAlpha_1x64 (src);
-
-    return over_1x64 (pixMultiply_1x64 (invertColors_1x64 (src),
-                                        _mm_or_si64 (alpha, xMaskAlpha)),
-                      alpha,
-                      dst);
-}
-
-static inline uint32_t
-pack_1x64_32( __m64 data )
-{
-    return _mm_cvtsi64_si32 (_mm_packs_pu16 (data, _mm_setzero_si64()));
-}
-
-/* Expand 16 bits positioned at @pos (0-3) of a mmx register into
- *
- *    00RR00GG00BB
- *
- * --- Expanding 565 in the low word ---
- *
- * m = (m << (32 - 3)) | (m << (16 - 5)) | m;
- * m = m & (01f0003f001f);
- * m = m * (008404100840);
- * m = m >> 8;
- *
- * Note the trick here - the top word is shifted by another nibble to
- * avoid it bumping into the middle word
- */
-static inline __m64
-expand565_16_1x64 (uint16_t pixel)
-{
-    __m64 p;
-    __m64 t1, t2;
-
-    p = _mm_cvtsi32_si64 ((uint32_t) pixel);
-
-    t1 = _mm_slli_si64 (p, 36 - 11);
-    t2 = _mm_slli_si64 (p, 16 - 5);
-
-    p = _mm_or_si64 (t1, p);
-    p = _mm_or_si64 (t2, p);
-    p = _mm_and_si64 (p, xMask565rgb);
-    p = _mm_mullo_pi16 (p, xMask565Unpack);
-
-    return _mm_srli_pi16 (p, 8);
-}
-
-/* -------------------------------------------------------------------------------------------------
- * Compose Core transformations
- */
-static inline uint32_t
-coreCombineOverUPixelsse2 (uint32_t src, uint32_t dst)
-{
-    uint8_t     a;
-    __m64       ms;
-
-    a = src >> 24;
-
-    if (a == 0xff)
-    {
-        return src;
-    }
-    else if (a)
-    {
-        ms = unpack_32_1x64 (src);
-        return pack_1x64_32 (over_1x64 (ms, expandAlpha_1x64 (ms), unpack_32_1x64 (dst)));
-    }
-
-    return dst;
-}
-
-static inline void
-coreCombineOverUsse2 (uint32_t* pd, const uint32_t* ps, int w)
-{
-    uint32_t pa;
-    uint32_t s, d;
-
-    __m128i xmmDstLo, xmmDstHi;
-    __m128i xmmSrcLo, xmmSrcHi;
-    __m128i xmmAlphaLo, xmmAlphaHi;
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-
-    /* Align dst on a 16-byte boundary */
-    while (w &&
-           ((unsigned long)pd & 15))
-    {
-        d = *pd;
-        s = *ps++;
-
-        *pd++ = coreCombineOverUPixelsse2 (s, d);
-        w--;
-    }
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-
-    while (w >= 4)
-    {
-        /* fill cache line with next memory */
-        cachePrefetchNext ((__m128i*)ps);
-        cachePrefetchNext ((__m128i*)pd);
-
-        /* I'm loading unaligned because I'm not sure about the address alignment. */
-        xmmSrcHi = load128Unaligned ((__m128i*) ps);
-
-        /* Check the alpha channel */
-        pa = packAlpha (xmmSrcHi);
-
-        if (pa == 0xffffffff)
-        {
-            save128Aligned ((__m128i*)pd, xmmSrcHi);
-        }
-        else if (pa)
-        {
-            xmmDstHi = load128Aligned ((__m128i*) pd);
-
-            unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
-            unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
-
-            expandAlpha_2x128 (xmmSrcLo, xmmSrcHi, &xmmAlphaLo, &xmmAlphaHi);
-
-            over_2x128 (xmmSrcLo, xmmSrcHi, xmmAlphaLo, xmmAlphaHi, &xmmDstLo, &xmmDstHi);
-
-            /* rebuid the 4 pixel data and save*/
-            save128Aligned ((__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
-        }
-
-        w -= 4;
-        ps += 4;
-        pd += 4;
-    }
-
-    while (w)
-    {
-        d = *pd;
-        s = *ps++;
-
-        *pd++ = coreCombineOverUPixelsse2 (s, d);
-        w--;
-    }
-}
-
-static inline void
-coreCombineOverReverseUsse2 (uint32_t* pd, const uint32_t* ps, int w)
-{
-    uint32_t s, d;
-
-    __m128i xmmDstLo, xmmDstHi;
-    __m128i xmmSrcLo, xmmSrcHi;
-    __m128i xmmAlphaLo, xmmAlphaHi;
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-
-    /* Align dst on a 16-byte boundary */
-    while (w &&
-           ((unsigned long)pd & 15))
-    {
-        d = *pd;
-        s = *ps++;
-
-        *pd++ = coreCombineOverUPixelsse2 (d, s);
-        w--;
-    }
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-
-    while (w >= 4)
-    {
-        /* fill cache line with next memory */
-        cachePrefetchNext ((__m128i*)ps);
-        cachePrefetchNext ((__m128i*)pd);
-
-        /* I'm loading unaligned because I'm not sure about the address alignment. */
-        xmmSrcHi = load128Unaligned ((__m128i*) ps);
-        xmmDstHi = load128Aligned ((__m128i*) pd);
-
-        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
-        unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
-
-        expandAlpha_2x128 (xmmDstLo, xmmDstHi, &xmmAlphaLo, &xmmAlphaHi);
-
-        over_2x128 (xmmDstLo, xmmDstHi, xmmAlphaLo, xmmAlphaHi, &xmmSrcLo, &xmmSrcHi);
-
-        /* rebuid the 4 pixel data and save*/
-        save128Aligned ((__m128i*)pd, pack_2x128_128 (xmmSrcLo, xmmSrcHi));
-
-        w -= 4;
-        ps += 4;
-        pd += 4;
-    }
-
-    while (w)
-    {
-        d = *pd;
-        s = *ps++;
-
-        *pd++ = coreCombineOverUPixelsse2 (d, s);
-        w--;
-    }
-}
-
-static inline uint32_t
-coreCombineInUPixelsse2 (uint32_t src, uint32_t dst)
-{
-    uint32_t maska = src >> 24;
-
-    if (maska == 0)
-    {
-        return 0;
-    }
-    else if (maska != 0xff)
-    {
-        return pack_1x64_32(pixMultiply_1x64 (unpack_32_1x64 (dst), expandAlpha_1x64 (unpack_32_1x64 (src))));
-    }
-
-    return dst;
-}
-
-static inline void
-coreCombineInUsse2 (uint32_t* pd, const uint32_t* ps, int w)
-{
-    uint32_t s, d;
-
-    __m128i xmmSrcLo, xmmSrcHi;
-    __m128i xmmDstLo, xmmDstHi;
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-
-    while (w && ((unsigned long) pd & 15))
-    {
-        s = *ps++;
-        d = *pd;
-
-        *pd++ = coreCombineInUPixelsse2 (d, s);
-        w--;
-    }
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-
-    while (w >= 4)
-    {
-        /* fill cache line with next memory */
-        cachePrefetchNext ((__m128i*)ps);
-        cachePrefetchNext ((__m128i*)pd);
-
-        xmmDstHi = load128Aligned ((__m128i*) pd);
-        xmmSrcHi = load128Unaligned ((__m128i*) ps);
-
-        unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
-        expandAlpha_2x128 (xmmDstLo, xmmDstHi, &xmmDstLo, &xmmDstHi);
-
-        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
-        pixMultiply_2x128 (xmmSrcLo, xmmSrcHi, xmmDstLo, xmmDstHi, &xmmDstLo, &xmmDstHi);
-
-        save128Aligned ((__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
-
-        ps += 4;
-        pd += 4;
-        w -= 4;
-    }
-
-    while (w)
-    {
-        s = *ps++;
-        d = *pd;
-
-        *pd++ = coreCombineInUPixelsse2 (d, s);
-        w--;
-    }
-}
-
-static inline void
-coreCombineReverseInUsse2 (uint32_t* pd, const uint32_t* ps, int w)
-{
-    uint32_t s, d;
-
-    __m128i xmmSrcLo, xmmSrcHi;
-    __m128i xmmDstLo, xmmDstHi;
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-
-    while (w && ((unsigned long) pd & 15))
-    {
-        s = *ps++;
-        d = *pd;
-
-        *pd++ = coreCombineInUPixelsse2 (s, d);
-        w--;
-    }
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-
-    while (w >= 4)
-    {
-        /* fill cache line with next memory */
-        cachePrefetchNext ((__m128i*)ps);
-        cachePrefetchNext ((__m128i*)pd);
-
-        xmmDstHi = load128Aligned ((__m128i*) pd);
-        xmmSrcHi = load128Unaligned ((__m128i*) ps);
-
-        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
-        expandAlpha_2x128 (xmmSrcLo, xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
-
-        unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
-        pixMultiply_2x128 (xmmDstLo, xmmDstHi, xmmSrcLo, xmmSrcHi, &xmmDstLo, &xmmDstHi);
-
-        save128Aligned ((__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
-
-        ps += 4;
-        pd += 4;
-        w -= 4;
-    }
-
-    while (w)
-    {
-        s = *ps++;
-        d = *pd;
-
-        *pd++ = coreCombineInUPixelsse2 (s, d);
-        w--;
-    }
-}
-
-static inline void
-coreCombineReverseOutUsse2 (uint32_t* pd, const uint32_t* ps, int w)
-{
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-
-    while (w && ((unsigned long) pd & 15))
-    {
-        uint32_t s = *ps++;
-        uint32_t d = *pd;
-
-        *pd++ = pack_1x64_32 (pixMultiply_1x64 (unpack_32_1x64 (d), negate_1x64 (expandAlpha_1x64 (unpack_32_1x64 (s)))));
-        w--;
-    }
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-
-    while (w >= 4)
-    {
-        __m128i xmmSrcLo, xmmSrcHi;
-        __m128i xmmDstLo, xmmDstHi;
-
-        /* fill cache line with next memory */
-        cachePrefetchNext ((__m128i*)ps);
-        cachePrefetchNext ((__m128i*)pd);
-
-        xmmSrcHi = load128Unaligned ((__m128i*) ps);
-        xmmDstHi = load128Aligned ((__m128i*) pd);
-
-        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
-        unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
-
-        expandAlpha_2x128 (xmmSrcLo, xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
-        negate_2x128      (xmmSrcLo, xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
-
-        pixMultiply_2x128 (xmmDstLo, xmmDstHi, xmmSrcLo, xmmSrcHi, &xmmDstLo, &xmmDstHi);
-
-        save128Aligned ((__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
-
-        ps += 4;
-        pd += 4;
-        w -= 4;
-    }
-
-    while (w)
-    {
-        uint32_t s = *ps++;
-        uint32_t d = *pd;
-
-        *pd++ = pack_1x64_32 (pixMultiply_1x64 (unpack_32_1x64 (d), negate_1x64 (expandAlpha_1x64 (unpack_32_1x64 (s)))));
-        w--;
-    }
-}
-
-static inline void
-coreCombineOutUsse2 (uint32_t* pd, const uint32_t* ps, int w)
-{
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-
-    while (w && ((unsigned long) pd & 15))
-    {
-        uint32_t s = *ps++;
-        uint32_t d = *pd;
-
-        *pd++ = pack_1x64_32 (pixMultiply_1x64 (unpack_32_1x64 (s), negate_1x64 (expandAlpha_1x64 (unpack_32_1x64 (d)))));
-        w--;
-    }
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-
-    while (w >= 4)
-    {
-        __m128i xmmSrcLo, xmmSrcHi;
-        __m128i xmmDstLo, xmmDstHi;
-
-        /* fill cache line with next memory */
-        cachePrefetchNext ((__m128i*)ps);
-        cachePrefetchNext ((__m128i*)pd);
-
-        xmmSrcHi = load128Unaligned ((__m128i*) ps);
-        xmmDstHi = load128Aligned ((__m128i*) pd);
-
-        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
-        unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
-
-        expandAlpha_2x128 (xmmDstLo, xmmDstHi, &xmmDstLo, &xmmDstHi);
-        negate_2x128      (xmmDstLo, xmmDstHi, &xmmDstLo, &xmmDstHi);
-
-        pixMultiply_2x128 (xmmSrcLo, xmmSrcHi, xmmDstLo, xmmDstHi, &xmmDstLo, &xmmDstHi);
-
-        save128Aligned ((__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
-
-        ps += 4;
-        pd += 4;
-        w -= 4;
-    }
-
-    while (w)
-    {
-        uint32_t s = *ps++;
-        uint32_t d = *pd;
-
-        *pd++ = pack_1x64_32 (pixMultiply_1x64 (unpack_32_1x64 (s), negate_1x64 (expandAlpha_1x64 (unpack_32_1x64 (d)))));
-        w--;
-    }
-}
-
-static inline uint32_t
-coreCombineAtopUPixelsse2 (uint32_t src, uint32_t dst)
-{
-    __m64 s = unpack_32_1x64 (src);
-    __m64 d = unpack_32_1x64 (dst);
-
-    __m64 sa = negate_1x64 (expandAlpha_1x64 (s));
-    __m64 da = expandAlpha_1x64 (d);
-
-    return pack_1x64_32 (pixAddMultiply_1x64 (s, da, d, sa));
-}
-
-static inline void
-coreCombineAtopUsse2 (uint32_t* pd, const uint32_t* ps, int w)
-{
-    uint32_t s, d;
-
-    __m128i xmmSrcLo, xmmSrcHi;
-    __m128i xmmDstLo, xmmDstHi;
-    __m128i xmmAlphaSrcLo, xmmAlphaSrcHi;
-    __m128i xmmAlphaDstLo, xmmAlphaDstHi;
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-
-    while (w && ((unsigned long) pd & 15))
-    {
-        s = *ps++;
-        d = *pd;
-
-        *pd++ = coreCombineAtopUPixelsse2 (s, d);
-        w--;
-    }
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-
-    while (w >= 4)
-    {
-        /* fill cache line with next memory */
-        cachePrefetchNext ((__m128i*)ps);
-        cachePrefetchNext ((__m128i*)pd);
-
-        xmmSrcHi = load128Unaligned ((__m128i*) ps);
-        xmmDstHi = load128Aligned ((__m128i*) pd);
-
-        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
-        unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
-
-        expandAlpha_2x128 (xmmSrcLo, xmmSrcHi, &xmmAlphaSrcLo, &xmmAlphaSrcHi);
-        expandAlpha_2x128 (xmmDstLo, xmmDstHi, &xmmAlphaDstLo, &xmmAlphaDstHi);
-
-        negate_2x128 (xmmAlphaSrcLo, xmmAlphaSrcHi, &xmmAlphaSrcLo, &xmmAlphaSrcHi);
-
-        pixAddMultiply_2x128 ( xmmSrcLo, xmmSrcHi, xmmAlphaDstLo, xmmAlphaDstHi,
-                               xmmDstLo, xmmDstHi, xmmAlphaSrcLo, xmmAlphaSrcHi,
-                               &xmmDstLo, &xmmDstHi );
-
-        save128Aligned ((__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
-
-        ps += 4;
-        pd += 4;
-        w -= 4;
-    }
-
-    while (w)
-    {
-        s = *ps++;
-        d = *pd;
-
-        *pd++ = coreCombineAtopUPixelsse2 (s, d);
-        w--;
-    }
-}
-
-static inline uint32_t
-coreCombineReverseAtopUPixelsse2 (uint32_t src, uint32_t dst)
-{
-    __m64 s = unpack_32_1x64 (src);
-    __m64 d = unpack_32_1x64 (dst);
-
-    __m64 sa = expandAlpha_1x64 (s);
-    __m64 da = negate_1x64 (expandAlpha_1x64 (d));
-
-    return pack_1x64_32 (pixAddMultiply_1x64 (s, da, d, sa));
-}
-
-static inline void
-coreCombineReverseAtopUsse2 (uint32_t* pd, const uint32_t* ps, int w)
-{
-    uint32_t s, d;
-
-    __m128i xmmSrcLo, xmmSrcHi;
-    __m128i xmmDstLo, xmmDstHi;
-    __m128i xmmAlphaSrcLo, xmmAlphaSrcHi;
-    __m128i xmmAlphaDstLo, xmmAlphaDstHi;
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-
-    while (w && ((unsigned long) pd & 15))
-    {
-        s = *ps++;
-        d = *pd;
-
-        *pd++ = coreCombineReverseAtopUPixelsse2 (s, d);
-        w--;
-    }
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-
-    while (w >= 4)
-    {
-        /* fill cache line with next memory */
-        cachePrefetchNext ((__m128i*)ps);
-        cachePrefetchNext ((__m128i*)pd);
-
-        xmmSrcHi = load128Unaligned ((__m128i*) ps);
-        xmmDstHi = load128Aligned ((__m128i*) pd);
-
-        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
-        unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
-
-        expandAlpha_2x128 (xmmSrcLo, xmmSrcHi, &xmmAlphaSrcLo, &xmmAlphaSrcHi);
-        expandAlpha_2x128 (xmmDstLo, xmmDstHi, &xmmAlphaDstLo, &xmmAlphaDstHi);
-
-        negate_2x128 (xmmAlphaDstLo, xmmAlphaDstHi, &xmmAlphaDstLo, &xmmAlphaDstHi);
-
-        pixAddMultiply_2x128 ( xmmSrcLo, xmmSrcHi, xmmAlphaDstLo, xmmAlphaDstHi,
-                               xmmDstLo, xmmDstHi, xmmAlphaSrcLo, xmmAlphaSrcHi,
-                               &xmmDstLo, &xmmDstHi );
-
-        save128Aligned ((__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
-
-        ps += 4;
-        pd += 4;
-        w -= 4;
-    }
-
-    while (w)
-    {
-        s = *ps++;
-        d = *pd;
-
-        *pd++ = coreCombineReverseAtopUPixelsse2 (s, d);
-        w--;
-    }
-}
-
-static inline uint32_t
-coreCombineXorUPixelsse2 (uint32_t src, uint32_t dst)
-{
-    __m64 s = unpack_32_1x64 (src);
-    __m64 d = unpack_32_1x64 (dst);
-
-    return pack_1x64_32 (pixAddMultiply_1x64 (s, negate_1x64 (expandAlpha_1x64 (d)), d, negate_1x64 (expandAlpha_1x64 (s))));
-}
-
-static inline void
-coreCombineXorUsse2 (uint32_t* dst, const uint32_t* src, int width)
-{
-    int w = width;
-    uint32_t s, d;
-    uint32_t* pd = dst;
-    const uint32_t* ps = src;
-
-    __m128i xmmSrc, xmmSrcLo, xmmSrcHi;
-    __m128i xmmDst, xmmDstLo, xmmDstHi;
-    __m128i xmmAlphaSrcLo, xmmAlphaSrcHi;
-    __m128i xmmAlphaDstLo, xmmAlphaDstHi;
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-
-    while (w && ((unsigned long) pd & 15))
-    {
-        s = *ps++;
-        d = *pd;
-
-        *pd++ = coreCombineXorUPixelsse2 (s, d);
-        w--;
-    }
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-
-    while (w >= 4)
-    {
-        /* fill cache line with next memory */
-        cachePrefetchNext ((__m128i*)ps);
-        cachePrefetchNext ((__m128i*)pd);
-
-        xmmSrc = load128Unaligned ((__m128i*) ps);
-        xmmDst = load128Aligned ((__m128i*) pd);
-
-        unpack_128_2x128 (xmmSrc, &xmmSrcLo, &xmmSrcHi);
-        unpack_128_2x128 (xmmDst, &xmmDstLo, &xmmDstHi);
-
-        expandAlpha_2x128 (xmmSrcLo, xmmSrcHi, &xmmAlphaSrcLo, &xmmAlphaSrcHi);
-        expandAlpha_2x128 (xmmDstLo, xmmDstHi, &xmmAlphaDstLo, &xmmAlphaDstHi);
-
-        negate_2x128 (xmmAlphaSrcLo, xmmAlphaSrcHi, &xmmAlphaSrcLo, &xmmAlphaSrcHi);
-        negate_2x128 (xmmAlphaDstLo, xmmAlphaDstHi, &xmmAlphaDstLo, &xmmAlphaDstHi);
-
-        pixAddMultiply_2x128 ( xmmSrcLo, xmmSrcHi, xmmAlphaDstLo, xmmAlphaDstHi,
-                               xmmDstLo, xmmDstHi, xmmAlphaSrcLo, xmmAlphaSrcHi,
-                               &xmmDstLo, &xmmDstHi );
-
-        save128Aligned ((__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
-
-        ps += 4;
-        pd += 4;
-        w -= 4;
-    }
-
-    while (w)
-    {
-        s = *ps++;
-        d = *pd;
-
-        *pd++ = coreCombineXorUPixelsse2 (s, d);
-        w--;
-    }
-}
-
-static inline void
-coreCombineAddUsse2 (uint32_t* dst, const uint32_t* src, int width)
-{
-    int w = width;
-    uint32_t s,d;
-    uint32_t* pd = dst;
-    const uint32_t* ps = src;
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-
-    while (w && (unsigned long)pd & 15)
-    {
-        s = *ps++;
-        d = *pd;
-        *pd++ = _mm_cvtsi64_si32 (_mm_adds_pu8 (_mm_cvtsi32_si64 (s), _mm_cvtsi32_si64 (d)));
-        w--;
-    }
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-
-    while (w >= 4)
-    {
-        /* fill cache line with next memory */
-        cachePrefetchNext ((__m128i*)ps);
-        cachePrefetchNext ((__m128i*)pd);
-
-        save128Aligned( (__m128i*)pd,
-                        _mm_adds_epu8( load128Unaligned((__m128i*)ps),
-                                       load128Aligned  ((__m128i*)pd)) );
-        pd += 4;
-        ps += 4;
-        w -= 4;
-    }
-
-    while (w--)
-    {
-        s = *ps++;
-        d = *pd;
-        *pd++ = _mm_cvtsi64_si32 (_mm_adds_pu8 (_mm_cvtsi32_si64 (s), _mm_cvtsi32_si64 (d)));
-    }
-}
-
-static inline uint32_t
-coreCombineSaturateUPixelsse2 (uint32_t src, uint32_t dst)
-{
-    __m64 ms = unpack_32_1x64 (src);
-    __m64 md = unpack_32_1x64 (dst);
-    uint32_t sa = src >> 24;
-    uint32_t da = ~dst >> 24;
-
-    if (sa > da)
-    {
-        ms = pixMultiply_1x64 (ms, expandAlpha_1x64 (unpack_32_1x64 (FbIntDiv(da, sa) << 24)));
-    }
-
-    return pack_1x64_32 (_mm_adds_pu16 (md, ms));
-}
-
-static inline void
-coreCombineSaturateUsse2 (uint32_t *pd, const uint32_t *ps, int w)
-{
-    uint32_t s,d;
-
-    uint32_t packCmp;
-    __m128i xmmSrc, xmmDst;
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-
-    while (w && (unsigned long)pd & 15)
-    {
-        s = *ps++;
-        d = *pd;
-        *pd++ = coreCombineSaturateUPixelsse2 (s, d);
-        w--;
-    }
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-
-    while (w >= 4)
-    {
-        /* fill cache line with next memory */
-        cachePrefetchNext ((__m128i*)ps);
-        cachePrefetchNext ((__m128i*)pd);
-
-        xmmDst = load128Aligned  ((__m128i*)pd);
-        xmmSrc = load128Unaligned((__m128i*)ps);
-
-        packCmp = _mm_movemask_epi8 (_mm_cmpgt_epi32 (_mm_srli_epi32 (xmmSrc, 24),
-                                                      _mm_srli_epi32 (_mm_xor_si128 (xmmDst, Maskff000000), 24)));
-
-        /* if some alpha src is grater than respective ~alpha dst */
-        if (packCmp)
-        {
-            s = *ps++;
-            d = *pd;
-            *pd++ = coreCombineSaturateUPixelsse2 (s, d);
-
-            s = *ps++;
-            d = *pd;
-            *pd++ = coreCombineSaturateUPixelsse2 (s, d);
-
-            s = *ps++;
-            d = *pd;
-            *pd++ = coreCombineSaturateUPixelsse2 (s, d);
-
-            s = *ps++;
-            d = *pd;
-            *pd++ = coreCombineSaturateUPixelsse2 (s, d);
-        }
-        else
-        {
-            save128Aligned ((__m128i*)pd, _mm_adds_epu8 (xmmDst, xmmSrc));
-
-            pd += 4;
-            ps += 4;
-        }
-
-        w -= 4;
-    }
-
-    while (w--)
-    {
-        s = *ps++;
-        d = *pd;
-        *pd++ = coreCombineSaturateUPixelsse2 (s, d);
-    }
-}
-
-static inline void
-coreCombineSrcCsse2 (uint32_t* pd, const uint32_t* ps, const uint32_t *pm, int w)
-{
-    uint32_t s, m;
-
-    __m128i xmmSrcLo, xmmSrcHi;
-    __m128i xmmMaskLo, xmmMaskHi;
-    __m128i xmmDstLo, xmmDstHi;
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-    cachePrefetch ((__m128i*)pm);
-
-    while (w && (unsigned long)pd & 15)
-    {
-        s = *ps++;
-        m = *pm++;
-        *pd++ = pack_1x64_32 (pixMultiply_1x64 (unpack_32_1x64 (s), unpack_32_1x64 (m)));
-        w--;
-    }
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-    cachePrefetch ((__m128i*)pm);
-
-    while (w >= 4)
-    {
-        /* fill cache line with next memory */
-        cachePrefetchNext ((__m128i*)ps);
-        cachePrefetchNext ((__m128i*)pd);
-        cachePrefetchNext ((__m128i*)pm);
-
-        xmmSrcHi = load128Unaligned ((__m128i*)ps);
-        xmmMaskHi = load128Unaligned ((__m128i*)pm);
-
-        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
-        unpack_128_2x128 (xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
-
-        pixMultiply_2x128 (xmmSrcLo, xmmSrcHi, xmmMaskLo, xmmMaskHi, &xmmDstLo, &xmmDstHi);
-
-        save128Aligned( (__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
-
-        ps += 4;
-        pd += 4;
-        pm += 4;
-        w -= 4;
-    }
-
-    while (w)
-    {
-        s = *ps++;
-        m = *pm++;
-        *pd++ = pack_1x64_32 (pixMultiply_1x64 (unpack_32_1x64 (s), unpack_32_1x64 (m)));
-        w--;
-    }
-}
-
-static inline uint32_t
-coreCombineOverCPixelsse2 (uint32_t src, uint32_t mask, uint32_t dst)
-{
-    __m64 s = unpack_32_1x64 (src);
-
-    return pack_1x64_32 (inOver_1x64 (s, expandAlpha_1x64 (s), unpack_32_1x64 (mask), unpack_32_1x64 (dst)));
-}
-
-static inline void
-coreCombineOverCsse2 (uint32_t* pd, const uint32_t* ps, const uint32_t *pm, int w)
-{
-    uint32_t s, m, d;
-
-    __m128i xmmAlphaLo, xmmAlphaHi;
-    __m128i xmmSrcLo, xmmSrcHi;
-    __m128i xmmDstLo, xmmDstHi;
-    __m128i xmmMaskLo, xmmMaskHi;
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-    cachePrefetch ((__m128i*)pm);
-
-    while (w && (unsigned long)pd & 15)
-    {
-        s = *ps++;
-        m = *pm++;
-        d = *pd;
-
-        *pd++ = coreCombineOverCPixelsse2 (s, m, d);
-        w--;
-    }
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-    cachePrefetch ((__m128i*)pm);
-
-    while (w >= 4)
-    {
-        /* fill cache line with next memory */
-        cachePrefetchNext ((__m128i*)ps);
-        cachePrefetchNext ((__m128i*)pd);
-        cachePrefetchNext ((__m128i*)pm);
-
-        xmmDstHi = load128Aligned ((__m128i*)pd);
-        xmmSrcHi = load128Unaligned ((__m128i*)ps);
-        xmmMaskHi = load128Unaligned ((__m128i*)pm);
-
-        unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
-        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
-        unpack_128_2x128 (xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
-
-        expandAlpha_2x128 (xmmSrcLo, xmmSrcHi, &xmmAlphaLo, &xmmAlphaHi);
-
-        inOver_2x128 (xmmSrcLo, xmmSrcHi, xmmAlphaLo, xmmAlphaHi, xmmMaskLo, xmmMaskHi, &xmmDstLo, &xmmDstHi);
-
-        save128Aligned( (__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
-
-        ps += 4;
-        pd += 4;
-        pm += 4;
-        w -= 4;
-    }
-
-    while (w)
-    {
-        s = *ps++;
-        m = *pm++;
-        d = *pd;
-
-        *pd++ = coreCombineOverCPixelsse2 (s, m, d);
-        w--;
-    }
-}
-
-static inline uint32_t
-coreCombineOverReverseCPixelsse2 (uint32_t src, uint32_t mask, uint32_t dst)
-{
-    __m64 d = unpack_32_1x64 (dst);
-
-	return pack_1x64_32(over_1x64 (d, expandAlpha_1x64 (d), pixMultiply_1x64 (unpack_32_1x64 (src), unpack_32_1x64 (mask))));
-}
-
-static inline void
-coreCombineOverReverseCsse2 (uint32_t* pd, const uint32_t* ps, const uint32_t *pm, int w)
-{
-    uint32_t s, m, d;
-
-    __m128i xmmAlphaLo, xmmAlphaHi;
-    __m128i xmmSrcLo, xmmSrcHi;
-    __m128i xmmDstLo, xmmDstHi;
-    __m128i xmmMaskLo, xmmMaskHi;
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-    cachePrefetch ((__m128i*)pm);
-
-    while (w && (unsigned long)pd & 15)
-    {
-        s = *ps++;
-        m = *pm++;
-        d = *pd;
-
-        *pd++ = coreCombineOverReverseCPixelsse2 (s, m, d);
-        w--;
-    }
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-    cachePrefetch ((__m128i*)pm);
-
-    while (w >= 4)
-    {
-        /* fill cache line with next memory */
-        cachePrefetchNext ((__m128i*)ps);
-        cachePrefetchNext ((__m128i*)pd);
-        cachePrefetchNext ((__m128i*)pm);
-
-        xmmDstHi = load128Aligned ((__m128i*)pd);
-        xmmSrcHi = load128Unaligned ((__m128i*)ps);
-        xmmMaskHi = load128Unaligned ((__m128i*)pm);
-
-        unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
-        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
-        unpack_128_2x128 (xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
-
-        expandAlpha_2x128 (xmmDstLo, xmmDstHi, &xmmAlphaLo, &xmmAlphaHi);
-        pixMultiply_2x128 (xmmSrcLo, xmmSrcHi, xmmMaskLo, xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
-
-        over_2x128 (xmmDstLo, xmmDstHi, xmmAlphaLo, xmmAlphaHi, &xmmMaskLo, &xmmMaskHi);
-
-        save128Aligned( (__m128i*)pd, pack_2x128_128 (xmmMaskLo, xmmMaskHi));
-
-        ps += 4;
-        pd += 4;
-        pm += 4;
-        w -= 4;
-    }
-
-    while (w)
-    {
-        s = *ps++;
-        m = *pm++;
-        d = *pd;
-
-        *pd++ = coreCombineOverReverseCPixelsse2 (s, m, d);
-        w--;
-    }
-}
-
-static inline void
-coreCombineInCsse2 (uint32_t *pd, uint32_t *ps, uint32_t *pm, int w)
-{
-    uint32_t s, m, d;
-
-    __m128i xmmAlphaLo, xmmAlphaHi;
-    __m128i xmmSrcLo, xmmSrcHi;
-    __m128i xmmDstLo, xmmDstHi;
-    __m128i xmmMaskLo, xmmMaskHi;
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-    cachePrefetch ((__m128i*)pm);
-
-    while (w && (unsigned long)pd & 15)
-    {
-        s = *ps++;
-        m = *pm++;
-        d = *pd;
-
-        *pd++ = pack_1x64_32 (pixMultiply_1x64 (pixMultiply_1x64 (unpack_32_1x64 (s), unpack_32_1x64 (m)),
-                                                expandAlpha_1x64 (unpack_32_1x64 (d))));
-        w--;
-    }
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-    cachePrefetch ((__m128i*)pm);
-
-    while (w >= 4)
-    {
-        /* fill cache line with next memory */
-        cachePrefetchNext ((__m128i*)ps);
-        cachePrefetchNext ((__m128i*)pd);
-        cachePrefetchNext ((__m128i*)pm);
-
-        xmmDstHi = load128Aligned ((__m128i*)pd);
-        xmmSrcHi = load128Unaligned ((__m128i*)ps);
-        xmmMaskHi = load128Unaligned ((__m128i*)pm);
-
-        unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
-        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
-        unpack_128_2x128 (xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
-
-        expandAlpha_2x128 (xmmDstLo, xmmDstHi, &xmmAlphaLo, &xmmAlphaHi);
-        pixMultiply_2x128 (xmmSrcLo, xmmSrcHi, xmmMaskLo, xmmMaskHi, &xmmDstLo, &xmmDstHi);
-
-        pixMultiply_2x128 (xmmDstLo, xmmDstHi, xmmAlphaLo, xmmAlphaHi, &xmmDstLo, &xmmDstHi);
-
-        save128Aligned( (__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
-
-        ps += 4;
-        pd += 4;
-        pm += 4;
-        w -= 4;
-    }
-
-    while (w)
-    {
-        s = *ps++;
-        m = *pm++;
-        d = *pd;
-
-        *pd++ = pack_1x64_32 (pixMultiply_1x64 (pixMultiply_1x64 (unpack_32_1x64 (s), unpack_32_1x64 (m)),
-                                                expandAlpha_1x64 (unpack_32_1x64 (d))));
-        w--;
-    }
-}
-
-static inline void
-coreCombineInReverseCsse2 (uint32_t *pd, uint32_t *ps, uint32_t *pm, int w)
-{
-    uint32_t s, m, d;
-
-    __m128i xmmAlphaLo, xmmAlphaHi;
-    __m128i xmmSrcLo, xmmSrcHi;
-    __m128i xmmDstLo, xmmDstHi;
-    __m128i xmmMaskLo, xmmMaskHi;
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-    cachePrefetch ((__m128i*)pm);
-
-    while (w && (unsigned long)pd & 15)
-    {
-        s = *ps++;
-        m = *pm++;
-        d = *pd;
-
-        *pd++ = pack_1x64_32 (pixMultiply_1x64 (unpack_32_1x64 (d),
-                                                pixMultiply_1x64 (unpack_32_1x64 (m),
-                                                                  expandAlpha_1x64 (unpack_32_1x64 (s)))));
-        w--;
-    }
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-    cachePrefetch ((__m128i*)pm);
-
-    while (w >= 4)
-    {
-        /* fill cache line with next memory */
-        cachePrefetchNext ((__m128i*)ps);
-        cachePrefetchNext ((__m128i*)pd);
-        cachePrefetchNext ((__m128i*)pm);
-
-        xmmDstHi = load128Aligned ((__m128i*)pd);
-        xmmSrcHi = load128Unaligned ((__m128i*)ps);
-        xmmMaskHi = load128Unaligned ((__m128i*)pm);
-
-        unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
-        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
-        unpack_128_2x128 (xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
-
-        expandAlpha_2x128 (xmmSrcLo, xmmSrcHi, &xmmAlphaLo, &xmmAlphaHi);
-        pixMultiply_2x128 (xmmMaskLo, xmmMaskHi, xmmAlphaLo, xmmAlphaHi, &xmmAlphaLo, &xmmAlphaHi);
-
-        pixMultiply_2x128 (xmmDstLo, xmmDstHi, xmmAlphaLo, xmmAlphaHi, &xmmDstLo, &xmmDstHi);
-
-        save128Aligned( (__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
-
-        ps += 4;
-        pd += 4;
-        pm += 4;
-        w -= 4;
-    }
-
-    while (w)
-    {
-        s = *ps++;
-        m = *pm++;
-        d = *pd;
-
-        *pd++ = pack_1x64_32 (pixMultiply_1x64 (unpack_32_1x64 (d),
-                                                pixMultiply_1x64 (unpack_32_1x64 (m),
-                                                                  expandAlpha_1x64 (unpack_32_1x64 (s)))));
-        w--;
-    }
-}
-
-static inline void
-coreCombineOutCsse2 (uint32_t *pd, uint32_t *ps, uint32_t *pm, int w)
-{
-    uint32_t s, m, d;
-
-    __m128i xmmAlphaLo, xmmAlphaHi;
-    __m128i xmmSrcLo, xmmSrcHi;
-    __m128i xmmDstLo, xmmDstHi;
-    __m128i xmmMaskLo, xmmMaskHi;
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-    cachePrefetch ((__m128i*)pm);
-
-    while (w && (unsigned long)pd & 15)
-    {
-        s = *ps++;
-        m = *pm++;
-        d = *pd;
-
-        *pd++ = pack_1x64_32 (pixMultiply_1x64 (pixMultiply_1x64 (unpack_32_1x64 (s), unpack_32_1x64 (m)),
-                                                negate_1x64 (expandAlpha_1x64 (unpack_32_1x64 (d)))));
-        w--;
-    }
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-    cachePrefetch ((__m128i*)pm);
-
-    while (w >= 4)
-    {
-        /* fill cache line with next memory */
-        cachePrefetchNext ((__m128i*)ps);
-        cachePrefetchNext ((__m128i*)pd);
-        cachePrefetchNext ((__m128i*)pm);
-
-        xmmDstHi = load128Aligned ((__m128i*)pd);
-        xmmSrcHi = load128Unaligned ((__m128i*)ps);
-        xmmMaskHi = load128Unaligned ((__m128i*)pm);
-
-        unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
-        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
-        unpack_128_2x128 (xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
-
-        expandAlpha_2x128 (xmmDstLo, xmmDstHi, &xmmAlphaLo, &xmmAlphaHi);
-        negate_2x128 (xmmAlphaLo, xmmAlphaHi, &xmmAlphaLo, &xmmAlphaHi);
-
-        pixMultiply_2x128 (xmmSrcLo, xmmSrcHi, xmmMaskLo, xmmMaskHi, &xmmDstLo, &xmmDstHi);
-        pixMultiply_2x128 (xmmDstLo, xmmDstHi, xmmAlphaLo, xmmAlphaHi, &xmmDstLo, &xmmDstHi);
-
-        save128Aligned( (__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
-
-        ps += 4;
-        pd += 4;
-        pm += 4;
-        w -= 4;
-    }
-
-    while (w)
-    {
-        s = *ps++;
-        m = *pm++;
-        d = *pd;
-
-        *pd++ = pack_1x64_32 (pixMultiply_1x64 (pixMultiply_1x64 (unpack_32_1x64 (s), unpack_32_1x64 (m)),
-                                                negate_1x64 (expandAlpha_1x64 (unpack_32_1x64 (d)))));
-        w--;
-    }
-}
-
-static inline void
-coreCombineOutReverseCsse2 (uint32_t *pd, uint32_t *ps, uint32_t *pm, int w)
-{
-    uint32_t s, m, d;
-
-    __m128i xmmAlphaLo, xmmAlphaHi;
-    __m128i xmmSrcLo, xmmSrcHi;
-    __m128i xmmDstLo, xmmDstHi;
-    __m128i xmmMaskLo, xmmMaskHi;
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-    cachePrefetch ((__m128i*)pm);
-
-    while (w && (unsigned long)pd & 15)
-    {
-        s = *ps++;
-        m = *pm++;
-        d = *pd;
-
-        *pd++ = pack_1x64_32 (pixMultiply_1x64 (unpack_32_1x64 (d),
-                                                negate_1x64 (pixMultiply_1x64 (unpack_32_1x64 (m),
-                                                                               expandAlpha_1x64 (unpack_32_1x64 (s))))));
-        w--;
-    }
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-    cachePrefetch ((__m128i*)pm);
-
-    while (w >= 4)
-    {
-        /* fill cache line with next memory */
-        cachePrefetchNext ((__m128i*)ps);
-        cachePrefetchNext ((__m128i*)pd);
-        cachePrefetchNext ((__m128i*)pm);
-
-        xmmDstHi = load128Aligned ((__m128i*)pd);
-        xmmSrcHi = load128Unaligned ((__m128i*)ps);
-        xmmMaskHi = load128Unaligned ((__m128i*)pm);
-
-        unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
-        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
-        unpack_128_2x128 (xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
-
-        expandAlpha_2x128 (xmmSrcLo, xmmSrcHi, &xmmAlphaLo, &xmmAlphaHi);
-
-        pixMultiply_2x128 (xmmMaskLo, xmmMaskHi, xmmAlphaLo, xmmAlphaHi, &xmmMaskLo, &xmmMaskHi);
-
-        negate_2x128 (xmmMaskLo, xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
-
-        pixMultiply_2x128 (xmmDstLo, xmmDstHi, xmmMaskLo, xmmMaskHi, &xmmDstLo, &xmmDstHi);
-
-        save128Aligned( (__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
-
-        ps += 4;
-        pd += 4;
-        pm += 4;
-        w -= 4;
-    }
-
-    while (w)
-    {
-        s = *ps++;
-        m = *pm++;
-        d = *pd;
-
-        *pd++ = pack_1x64_32 (pixMultiply_1x64 (unpack_32_1x64 (d),
-                                                negate_1x64 (pixMultiply_1x64 (unpack_32_1x64 (m),
-                                                                               expandAlpha_1x64 (unpack_32_1x64 (s))))));
-        w--;
-    }
-}
-
-static inline uint32_t
-coreCombineAtopCPixelsse2 (uint32_t src, uint32_t mask, uint32_t dst)
-{
-    __m64 m = unpack_32_1x64 (mask);
-    __m64 s = unpack_32_1x64 (src);
-    __m64 d = unpack_32_1x64 (dst);
-    __m64 sa = expandAlpha_1x64 (s);
-    __m64 da = expandAlpha_1x64 (d);
-
-    s = pixMultiply_1x64 (s, m);
-    m = negate_1x64 (pixMultiply_1x64 (m, sa));
-
-    return pack_1x64_32 (pixAddMultiply_1x64 (d, m, s, da));
-}
-
-static inline void
-coreCombineAtopCsse2 (uint32_t *pd, uint32_t *ps, uint32_t *pm, int w)
-{
-    uint32_t s, m, d;
-
-    __m128i xmmSrcLo, xmmSrcHi;
-    __m128i xmmDstLo, xmmDstHi;
-    __m128i xmmAlphaSrcLo, xmmAlphaSrcHi;
-    __m128i xmmAlphaDstLo, xmmAlphaDstHi;
-    __m128i xmmMaskLo, xmmMaskHi;
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-    cachePrefetch ((__m128i*)pm);
-
-    while (w && (unsigned long)pd & 15)
-    {
-        s = *ps++;
-        m = *pm++;
-        d = *pd;
-
-        *pd++ = coreCombineAtopCPixelsse2 (s, m, d);
-        w--;
-    }
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-    cachePrefetch ((__m128i*)pm);
-
-    while (w >= 4)
-    {
-        /* fill cache line with next memory */
-        cachePrefetchNext ((__m128i*)ps);
-        cachePrefetchNext ((__m128i*)pd);
-        cachePrefetchNext ((__m128i*)pm);
-
-        xmmDstHi = load128Aligned ((__m128i*)pd);
-        xmmSrcHi = load128Unaligned ((__m128i*)ps);
-        xmmMaskHi = load128Unaligned ((__m128i*)pm);
-
-        unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
-        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
-        unpack_128_2x128 (xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
-
-        expandAlpha_2x128 (xmmSrcLo, xmmSrcHi, &xmmAlphaSrcLo, &xmmAlphaSrcHi);
-        expandAlpha_2x128 (xmmDstLo, xmmDstHi, &xmmAlphaDstLo, &xmmAlphaDstHi);
-
-        pixMultiply_2x128 (xmmSrcLo, xmmSrcHi, xmmMaskLo, xmmMaskHi, &xmmSrcLo, &xmmSrcHi);
-        pixMultiply_2x128 (xmmMaskLo, xmmMaskHi, xmmAlphaSrcLo, xmmAlphaSrcHi, &xmmMaskLo, &xmmMaskHi);
-
-        negate_2x128 (xmmMaskLo, xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
-
-        pixAddMultiply_2x128 (xmmDstLo, xmmDstHi, xmmMaskLo, xmmMaskHi,
-                              xmmSrcLo, xmmSrcHi, xmmAlphaDstLo, xmmAlphaDstHi,
-                              &xmmDstLo, &xmmDstHi);
-
-        save128Aligned( (__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
-
-        ps += 4;
-        pd += 4;
-        pm += 4;
-        w -= 4;
-    }
-
-    while (w)
-    {
-        s = *ps++;
-        m = *pm++;
-        d = *pd;
-
-        *pd++ = coreCombineAtopCPixelsse2 (s, m, d);
-        w--;
-    }
-}
-
-static inline uint32_t
-coreCombineReverseAtopCPixelsse2 (uint32_t src, uint32_t mask, uint32_t dst)
-{
-    __m64 m = unpack_32_1x64 (mask);
-    __m64 s = unpack_32_1x64 (src);
-    __m64 d = unpack_32_1x64 (dst);
-
-    __m64 da = negate_1x64 (expandAlpha_1x64 (d));
-    __m64 sa = expandAlpha_1x64 (s);
-
-    s = pixMultiply_1x64 (s, m);
-    m = pixMultiply_1x64 (m, sa);
-
-    return pack_1x64_32 (pixAddMultiply_1x64 (d, m, s, da));
-}
-
-static inline void
-coreCombineReverseAtopCsse2 (uint32_t *pd, uint32_t *ps, uint32_t *pm, int w)
-{
-    uint32_t s, m, d;
-
-    __m128i xmmSrcLo, xmmSrcHi;
-    __m128i xmmDstLo, xmmDstHi;
-    __m128i xmmAlphaSrcLo, xmmAlphaSrcHi;
-    __m128i xmmAlphaDstLo, xmmAlphaDstHi;
-    __m128i xmmMaskLo, xmmMaskHi;
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-    cachePrefetch ((__m128i*)pm);
-
-    while (w && (unsigned long)pd & 15)
-    {
-        s = *ps++;
-        m = *pm++;
-        d = *pd;
-
-        *pd++ = coreCombineReverseAtopCPixelsse2 (s, m, d);
-        w--;
-    }
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-    cachePrefetch ((__m128i*)pm);
-
-    while (w >= 4)
-    {
-        /* fill cache line with next memory */
-        cachePrefetchNext ((__m128i*)ps);
-        cachePrefetchNext ((__m128i*)pd);
-        cachePrefetchNext ((__m128i*)pm);
-
-        xmmDstHi = load128Aligned ((__m128i*)pd);
-        xmmSrcHi = load128Unaligned ((__m128i*)ps);
-        xmmMaskHi = load128Unaligned ((__m128i*)pm);
-
-        unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
-        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
-        unpack_128_2x128 (xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
-
-        expandAlpha_2x128 (xmmSrcLo, xmmSrcHi, &xmmAlphaSrcLo, &xmmAlphaSrcHi);
-        expandAlpha_2x128 (xmmDstLo, xmmDstHi, &xmmAlphaDstLo, &xmmAlphaDstHi);
-
-        pixMultiply_2x128 (xmmSrcLo, xmmSrcHi, xmmMaskLo, xmmMaskHi, &xmmSrcLo, &xmmSrcHi);
-        pixMultiply_2x128 (xmmMaskLo, xmmMaskHi, xmmAlphaSrcLo, xmmAlphaSrcHi, &xmmMaskLo, &xmmMaskHi);
-
-        negate_2x128 (xmmAlphaDstLo, xmmAlphaDstHi, &xmmAlphaDstLo, &xmmAlphaDstHi);
-
-        pixAddMultiply_2x128 (xmmDstLo, xmmDstHi, xmmMaskLo, xmmMaskHi,
-                              xmmSrcLo, xmmSrcHi, xmmAlphaDstLo, xmmAlphaDstHi,
-                              &xmmDstLo, &xmmDstHi);
-
-        save128Aligned( (__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
-
-        ps += 4;
-        pd += 4;
-        pm += 4;
-        w -= 4;
-    }
-
-    while (w)
-    {
-        s = *ps++;
-        m = *pm++;
-        d = *pd;
-
-        *pd++ = coreCombineReverseAtopCPixelsse2 (s, m, d);
-        w--;
-    }
-}
-
-static inline uint32_t
-coreCombineXorCPixelsse2 (uint32_t src, uint32_t mask, uint32_t dst)
-{
-    __m64 a = unpack_32_1x64 (mask);
-    __m64 s = unpack_32_1x64 (src);
-    __m64 d = unpack_32_1x64 (dst);
-
-    return pack_1x64_32 (pixAddMultiply_1x64 (d,
-                                              negate_1x64 (pixMultiply_1x64 (a, expandAlpha_1x64 (s))),
-                                              pixMultiply_1x64 (s, a),
-                                              negate_1x64 (expandAlpha_1x64 (d))));
-}
-
-static inline void
-coreCombineXorCsse2 (uint32_t *pd, uint32_t *ps, uint32_t *pm, int w)
-{
-    uint32_t s, m, d;
-
-    __m128i xmmSrcLo, xmmSrcHi;
-    __m128i xmmDstLo, xmmDstHi;
-    __m128i xmmAlphaSrcLo, xmmAlphaSrcHi;
-    __m128i xmmAlphaDstLo, xmmAlphaDstHi;
-    __m128i xmmMaskLo, xmmMaskHi;
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-    cachePrefetch ((__m128i*)pm);
-
-    while (w && (unsigned long)pd & 15)
-    {
-        s = *ps++;
-        m = *pm++;
-        d = *pd;
-
-        *pd++ = coreCombineXorCPixelsse2 (s, m, d);
-        w--;
-    }
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-    cachePrefetch ((__m128i*)pm);
-
-    while (w >= 4)
-    {
-        /* fill cache line with next memory */
-        cachePrefetchNext ((__m128i*)ps);
-        cachePrefetchNext ((__m128i*)pd);
-        cachePrefetchNext ((__m128i*)pm);
-
-        xmmDstHi = load128Aligned ((__m128i*)pd);
-        xmmSrcHi = load128Unaligned ((__m128i*)ps);
-        xmmMaskHi = load128Unaligned ((__m128i*)pm);
-
-        unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
-        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
-        unpack_128_2x128 (xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
-
-        expandAlpha_2x128 (xmmSrcLo, xmmSrcHi, &xmmAlphaSrcLo, &xmmAlphaSrcHi);
-        expandAlpha_2x128 (xmmDstLo, xmmDstHi, &xmmAlphaDstLo, &xmmAlphaDstHi);
-
-        pixMultiply_2x128 (xmmSrcLo, xmmSrcHi, xmmMaskLo, xmmMaskHi, &xmmSrcLo, &xmmSrcHi);
-        pixMultiply_2x128 (xmmMaskLo, xmmMaskHi, xmmAlphaSrcLo, xmmAlphaSrcHi, &xmmMaskLo, &xmmMaskHi);
-
-        negate_2x128 (xmmAlphaDstLo, xmmAlphaDstHi, &xmmAlphaDstLo, &xmmAlphaDstHi);
-        negate_2x128 (xmmMaskLo, xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
-
-        pixAddMultiply_2x128 (xmmDstLo, xmmDstHi, xmmMaskLo, xmmMaskHi,
-                              xmmSrcLo, xmmSrcHi, xmmAlphaDstLo, xmmAlphaDstHi,
-                              &xmmDstLo, &xmmDstHi);
-
-        save128Aligned( (__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
-
-        ps += 4;
-        pd += 4;
-        pm += 4;
-        w -= 4;
-    }
-
-    while (w)
-    {
-        s = *ps++;
-        m = *pm++;
-        d = *pd;
-
-        *pd++ = coreCombineXorCPixelsse2 (s, m, d);
-        w--;
-    }
-}
-
-static inline void
-coreCombineAddCsse2 (uint32_t *pd, uint32_t *ps, uint32_t *pm, int w)
-{
-    uint32_t s, m, d;
-
-    __m128i xmmSrcLo, xmmSrcHi;
-    __m128i xmmDstLo, xmmDstHi;
-    __m128i xmmMaskLo, xmmMaskHi;
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-    cachePrefetch ((__m128i*)pm);
-
-    while (w && (unsigned long)pd & 15)
-    {
-        s = *ps++;
-        m = *pm++;
-        d = *pd;
-
-        *pd++ = pack_1x64_32 (_mm_adds_pu8 (pixMultiply_1x64 (unpack_32_1x64 (s),
-                                                              unpack_32_1x64 (m)),
-                                            unpack_32_1x64 (d)));
-        w--;
-    }
-
-    /* call prefetch hint to optimize cache load*/
-    cachePrefetch ((__m128i*)ps);
-    cachePrefetch ((__m128i*)pd);
-    cachePrefetch ((__m128i*)pm);
-
-    while (w >= 4)
-    {
-        /* fill cache line with next memory */
-        cachePrefetchNext ((__m128i*)ps);
-        cachePrefetchNext ((__m128i*)pd);
-        cachePrefetchNext ((__m128i*)pm);
-
-        xmmSrcHi = load128Unaligned ((__m128i*)ps);
-        xmmMaskHi = load128Unaligned ((__m128i*)pm);
-        xmmDstHi = load128Aligned ((__m128i*)pd);
-
-        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
-        unpack_128_2x128 (xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
-        unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
-
-        pixMultiply_2x128 (xmmSrcLo, xmmSrcHi, xmmMaskLo, xmmMaskHi, &xmmSrcLo, &xmmSrcHi);
-
-        save128Aligned( (__m128i*)pd, pack_2x128_128 (_mm_adds_epu8 (xmmSrcLo, xmmDstLo),
-                                                      _mm_adds_epu8 (xmmSrcHi, xmmDstHi)));
-
-        ps += 4;
-        pd += 4;
-        pm += 4;
-        w -= 4;
-    }
-
-    while (w)
-    {
-        s = *ps++;
-        m = *pm++;
-        d = *pd;
-
-        *pd++ = pack_1x64_32 (_mm_adds_pu8 (pixMultiply_1x64 (unpack_32_1x64 (s),
-                                                              unpack_32_1x64 (m)),
-                                            unpack_32_1x64 (d)));
-        w--;
-    }
-}
-
-/* -------------------------------------------------------------------------------------------------
- * fbComposeSetupSSE
- */
-static inline __m64
-createMask_16_64 (uint16_t mask)
-{
-    return _mm_set1_pi16 (mask);
-}
-
-static inline __m128i
-createMask_16_128 (uint16_t mask)
-{
-    return _mm_set1_epi16 (mask);
-}
-
-static inline __m64
-createMask_2x32_64 (uint32_t mask0, uint32_t mask1)
-{
-    return _mm_set_pi32 (mask0, mask1);
-}
-
-static inline __m128i
-createMask_2x32_128 (uint32_t mask0, uint32_t mask1)
-{
-    return _mm_set_epi32 (mask0, mask1, mask0, mask1);
-}
-
-/* SSE2 code patch for fbcompose.c */
-
-static FASTCALL void
-sse2CombineMaskU (uint32_t *dst, const uint32_t *src, int width)
-{
-    coreCombineReverseInUsse2 (dst, src, width);
-    _mm_empty();
-}
-
-static FASTCALL void
-sse2CombineOverU (uint32_t *dst, const uint32_t *src, int width)
-{
-    coreCombineOverUsse2 (dst, src, width);
-    _mm_empty();
-}
-
-static FASTCALL void
-sse2CombineOverReverseU (uint32_t *dst, const uint32_t *src, int width)
-{
-    coreCombineOverReverseUsse2 (dst, src, width);
-    _mm_empty();
-}
-
-static FASTCALL void
-sse2CombineInU (uint32_t *dst, const uint32_t *src, int width)
-{
-    coreCombineInUsse2 (dst, src, width);
-    _mm_empty();
-}
-
-static FASTCALL void
-sse2CombineInReverseU (uint32_t *dst, const uint32_t *src, int width)
-{
-    coreCombineReverseInUsse2 (dst, src, width);
-    _mm_empty();
-}
-
-static FASTCALL void
-sse2CombineOutU (uint32_t *dst, const uint32_t *src, int width)
-{
-    coreCombineOutUsse2 (dst, src, width);
-    _mm_empty();
-}
-
-static FASTCALL void
-sse2CombineOutReverseU (uint32_t *dst, const uint32_t *src, int width)
-{
-    coreCombineReverseOutUsse2 (dst, src, width);
-    _mm_empty();
-}
-
-static FASTCALL void
-sse2CombineAtopU (uint32_t *dst, const uint32_t *src, int width)
-{
-    coreCombineAtopUsse2 (dst, src, width);
-    _mm_empty();
-}
-
-static FASTCALL void
-sse2CombineAtopReverseU (uint32_t *dst, const uint32_t *src, int width)
-{
-    coreCombineReverseAtopUsse2 (dst, src, width);
-    _mm_empty();
-}
-
-static FASTCALL void
-sse2CombineXorU (uint32_t *dst, const uint32_t *src, int width)
-{
-    coreCombineXorUsse2 (dst, src, width);
-    _mm_empty();
-}
-
-static FASTCALL void
-sse2CombineAddU (uint32_t *dst, const uint32_t *src, int width)
-{
-    coreCombineAddUsse2 (dst, src, width);
-    _mm_empty();
-}
-
-static FASTCALL void
-sse2CombineSaturateU (uint32_t *dst, const uint32_t *src, int width)
-{
-    coreCombineSaturateUsse2 (dst, src, width);
-    _mm_empty();
-}
-
-static FASTCALL void
-sse2CombineSrcC (uint32_t *dst, uint32_t *src, uint32_t *mask, int width)
-{
-    coreCombineSrcCsse2 (dst, src, mask, width);
-    _mm_empty();
-}
-
-static FASTCALL void
-sse2CombineOverC (uint32_t *dst, uint32_t *src, uint32_t *mask, int width)
-{
-    coreCombineOverCsse2 (dst, src, mask, width);
-    _mm_empty();
-}
-
-static FASTCALL void
-sse2CombineOverReverseC (uint32_t *dst, uint32_t *src, uint32_t *mask, int width)
-{
-    coreCombineOverReverseCsse2 (dst, src, mask, width);
-    _mm_empty();
-}
-
-static FASTCALL void
-sse2CombineInC (uint32_t *dst, uint32_t *src, uint32_t *mask, int width)
-{
-    coreCombineInCsse2 (dst, src, mask, width);
-    _mm_empty();
-}
-
-static FASTCALL void
-sse2CombineInReverseC (uint32_t *dst, uint32_t *src, uint32_t *mask, int width)
-{
-    coreCombineInReverseCsse2 (dst, src, mask, width);
-    _mm_empty();
-}
-
-static FASTCALL void
-sse2CombineOutC (uint32_t *dst, uint32_t *src, uint32_t *mask, int width)
-{
-    coreCombineOutCsse2 (dst, src, mask, width);
-    _mm_empty();
-}
-
-static FASTCALL void
-sse2CombineOutReverseC (uint32_t *dst, uint32_t *src, uint32_t *mask, int width)
-{
-    coreCombineOutReverseCsse2 (dst, src, mask, width);
-    _mm_empty();
-}
-
-static FASTCALL void
-sse2CombineAtopC (uint32_t *dst, uint32_t *src, uint32_t *mask, int width)
-{
-    coreCombineAtopCsse2 (dst, src, mask, width);
-    _mm_empty();
-}
-
-static FASTCALL void
-sse2CombineAtopReverseC (uint32_t *dst, uint32_t *src, uint32_t *mask, int width)
-{
-    coreCombineReverseAtopCsse2 (dst, src, mask, width);
-    _mm_empty();
-}
-
-static FASTCALL void
-sse2CombineXorC (uint32_t *dst, uint32_t *src, uint32_t *mask, int width)
-{
-    coreCombineXorCsse2 (dst, src, mask, width);
-    _mm_empty();
-}
-
-static FASTCALL void
-sse2CombineAddC (uint32_t *dst, uint32_t *src, uint32_t *mask, int width)
-{
-    coreCombineAddCsse2 (dst, src, mask, width);
-    _mm_empty();
-}
-
-void
-fbComposeSetupSSE(void)
-{
-    static pixman_bool_t initialized = FALSE;
-
-    if (initialized)
-	return;
-    
-    /* check if we have SSE2 support and initialize accordingly */
-    if (pixman_have_sse())
-    {
-        /* SSE2 constants */
-        Mask565r  = createMask_2x32_128 (0x00f80000, 0x00f80000);
-        Mask565g1 = createMask_2x32_128 (0x00070000, 0x00070000);
-        Mask565g2 = createMask_2x32_128 (0x000000e0, 0x000000e0);
-        Mask565b  = createMask_2x32_128 (0x0000001f, 0x0000001f);
-        MaskRed   = createMask_2x32_128 (0x00f80000, 0x00f80000);
-        MaskGreen = createMask_2x32_128 (0x0000fc00, 0x0000fc00);
-        MaskBlue  = createMask_2x32_128 (0x000000f8, 0x000000f8);
-
-        Mask0080 = createMask_16_128 (0x0080);
-        Mask00ff = createMask_16_128 (0x00ff);
-        Mask0101 = createMask_16_128 (0x0101);
-        Maskffff = createMask_16_128 (0xffff);
-        Maskff000000 = createMask_2x32_128 (0xff000000, 0xff000000);
-        MaskAlpha = createMask_2x32_128 (0x00ff0000, 0x00000000);
-
-        /* MMX constants */
-        xMask565rgb = createMask_2x32_64 (0x000001f0, 0x003f001f);
-        xMask565Unpack = createMask_2x32_64 (0x00000084, 0x04100840);
-
-        xMask0080 = createMask_16_64 (0x0080);
-        xMask00ff = createMask_16_64 (0x00ff);
-        xMask0101 = createMask_16_64 (0x0101);
-        xMaskAlpha = createMask_2x32_64 (0x00ff0000, 0x00000000);
-
-        /* SSE code patch for fbcompose.c */
-        pixman_composeFunctions.combineU[PIXMAN_OP_OVER] = sse2CombineOverU;
-        pixman_composeFunctions.combineU[PIXMAN_OP_OVER_REVERSE] = sse2CombineOverReverseU;
-        pixman_composeFunctions.combineU[PIXMAN_OP_IN] = sse2CombineInU;
-        pixman_composeFunctions.combineU[PIXMAN_OP_IN_REVERSE] = sse2CombineInReverseU;
-        pixman_composeFunctions.combineU[PIXMAN_OP_OUT] = sse2CombineOutU;
-
-        pixman_composeFunctions.combineU[PIXMAN_OP_OUT_REVERSE] = sse2CombineOutReverseU;
-        pixman_composeFunctions.combineU[PIXMAN_OP_ATOP] = sse2CombineAtopU;
-        pixman_composeFunctions.combineU[PIXMAN_OP_ATOP_REVERSE] = sse2CombineAtopReverseU;
-        pixman_composeFunctions.combineU[PIXMAN_OP_XOR] = sse2CombineXorU;
-        pixman_composeFunctions.combineU[PIXMAN_OP_ADD] = sse2CombineAddU;
-
-        pixman_composeFunctions.combineU[PIXMAN_OP_SATURATE] = sse2CombineSaturateU;
-
-        pixman_composeFunctions.combineC[PIXMAN_OP_SRC] = sse2CombineSrcC;
-        pixman_composeFunctions.combineC[PIXMAN_OP_OVER] = sse2CombineOverC;
-        pixman_composeFunctions.combineC[PIXMAN_OP_OVER_REVERSE] = sse2CombineOverReverseC;
-        pixman_composeFunctions.combineC[PIXMAN_OP_IN] = sse2CombineInC;
-        pixman_composeFunctions.combineC[PIXMAN_OP_IN_REVERSE] = sse2CombineInReverseC;
-        pixman_composeFunctions.combineC[PIXMAN_OP_OUT] = sse2CombineOutC;
-        pixman_composeFunctions.combineC[PIXMAN_OP_OUT_REVERSE] = sse2CombineOutReverseC;
-        pixman_composeFunctions.combineC[PIXMAN_OP_ATOP] = sse2CombineAtopC;
-        pixman_composeFunctions.combineC[PIXMAN_OP_ATOP_REVERSE] = sse2CombineAtopReverseC;
-        pixman_composeFunctions.combineC[PIXMAN_OP_XOR] = sse2CombineXorC;
-        pixman_composeFunctions.combineC[PIXMAN_OP_ADD] = sse2CombineAddC;
-
-        pixman_composeFunctions.combineMaskU = sse2CombineMaskU;
-    }
-
-    initialized = TRUE;
-
-    _mm_empty();
-}
-
-
-/* -------------------------------------------------------------------------------------------------
- * fbCompositeSolid_nx8888
- */
-
-void
-fbCompositeSolid_nx8888sse2 (pixman_op_t op,
-			    pixman_image_t * pSrc,
-			    pixman_image_t * pMask,
-			    pixman_image_t * pDst,
-			    int16_t	xSrc,
-			    int16_t	ySrc,
-			    int16_t	xMask,
-			    int16_t	yMask,
-			    int16_t	xDst,
-			    int16_t	yDst,
-			    uint16_t	width,
-			    uint16_t	height)
-{
-    uint32_t	src;
-    uint32_t	*dstLine, *dst, d;
-    uint16_t	w;
-    int	dstStride;
-    __m128i xmmSrc, xmmAlpha;
-    __m128i xmmDst, xmmDstLo, xmmDstHi;
-
-    fbComposeGetSolid(pSrc, src, pDst->bits.format);
-
-    if (src >> 24 == 0)
-	return;
-
-    fbComposeGetStart (pDst, xDst, yDst, uint32_t, dstStride, dstLine, 1);
-
-    xmmSrc = expandPixel_32_1x128 (src);
-    xmmAlpha = expandAlpha_1x128 (xmmSrc);
-
-    while (height--)
-    {
-        dst = dstLine;
-
-        /* call prefetch hint to optimize cache load*/
-        cachePrefetch ((__m128i*)dst);
-
-        dstLine += dstStride;
-        w = width;
-
-        while (w && (unsigned long)dst & 15)
-        {
-            d = *dst;
-            *dst++ = pack_1x64_32 (over_1x64 (_mm_movepi64_pi64 (xmmSrc),
-                                              _mm_movepi64_pi64 (xmmAlpha),
-                                              unpack_32_1x64 (d)));
-            w--;
-        }
-
-        cachePrefetch ((__m128i*)dst);
-
-        while (w >= 4)
-        {
-            /* fill cache line with next memory */
-            cachePrefetchNext ((__m128i*)dst);
-
-            xmmDst = load128Aligned ((__m128i*)dst);
-
-            unpack_128_2x128 (xmmDst, &xmmDstLo, &xmmDstHi);
-
-            over_2x128 (xmmSrc, xmmSrc, xmmAlpha, xmmAlpha, &xmmDstLo, &xmmDstHi);
-
-            /* rebuid the 4 pixel data and save*/
-            save128Aligned ((__m128i*)dst, pack_2x128_128 (xmmDstLo, xmmDstHi));
-
-            w -= 4;
-            dst += 4;
-        }
-
-        while (w)
-        {
-            d = *dst;
-            *dst++ = pack_1x64_32 (over_1x64 (_mm_movepi64_pi64 (xmmSrc),
-                                              _mm_movepi64_pi64 (xmmAlpha),
-                                              unpack_32_1x64 (d)));
-            w--;
-        }
-
-    }
-    _mm_empty();
-}
-
-/* -------------------------------------------------------------------------------------------------
- * fbCompositeSolid_nx0565
- */
-void
-fbCompositeSolid_nx0565sse2 (pixman_op_t op,
-			    pixman_image_t * pSrc,
-			    pixman_image_t * pMask,
-			    pixman_image_t * pDst,
-			    int16_t	xSrc,
-			    int16_t	ySrc,
-			    int16_t	xMask,
-			    int16_t	yMask,
-			    int16_t	xDst,
-			    int16_t	yDst,
-			    uint16_t	width,
-			    uint16_t	height)
-{
-    uint32_t	src;
-    uint16_t	*dstLine, *dst, d;
-    uint16_t	w;
-    int	        dstStride;
-    __m128i xmmSrc, xmmAlpha;
-    __m128i xmmDst, xmmDst0, xmmDst1, xmmDst2, xmmDst3;
-
-    fbComposeGetSolid(pSrc, src, pDst->bits.format);
-
-    if (src >> 24 == 0)
-        return;
-
-    fbComposeGetStart (pDst, xDst, yDst, uint16_t, dstStride, dstLine, 1);
-
-    xmmSrc = expandPixel_32_1x128 (src);
-    xmmAlpha = expandAlpha_1x128 (xmmSrc);
-
-    while (height--)
-    {
-        dst = dstLine;
-
-        /* call prefetch hint to optimize cache load*/
-        cachePrefetch ((__m128i*)dst);
-
-        dstLine += dstStride;
-        w = width;
-
-        while (w && (unsigned long)dst & 15)
-        {
-            d = *dst;
-            *dst++ = pack565_32_16 (pack_1x64_32 (over_1x64 (_mm_movepi64_pi64 (xmmSrc),
-                                                             _mm_movepi64_pi64 (xmmAlpha),
-                                                             expand565_16_1x64 (d))));
-            w--;
-        }
-
-        /* call prefetch hint to optimize cache load*/
-        cachePrefetch ((__m128i*)dst);
-
-        while (w >= 8)
-        {
-            /* fill cache line with next memory */
-            cachePrefetchNext ((__m128i*)dst);
-
-            xmmDst = load128Aligned ((__m128i*)dst);
-
-            unpack565_128_4x128 (xmmDst, &xmmDst0, &xmmDst1, &xmmDst2, &xmmDst3);
-
-            over_2x128 (xmmSrc, xmmSrc, xmmAlpha, xmmAlpha, &xmmDst0, &xmmDst1);
-            over_2x128 (xmmSrc, xmmSrc, xmmAlpha, xmmAlpha, &xmmDst2, &xmmDst3);
-
-            xmmDst = pack565_4x128_128 (xmmDst0, xmmDst1, xmmDst2, xmmDst3);
-
-            save128Aligned ((__m128i*)dst, xmmDst);
-
-            dst += 8;
-            w -= 8;
-        }
-
-        while (w--)
-        {
-            d = *dst;
-            *dst++ = pack565_32_16 (pack_1x64_32 (over_1x64 (_mm_movepi64_pi64 (xmmSrc),
-                                                             _mm_movepi64_pi64 (xmmAlpha),
-                                                             expand565_16_1x64 (d))));
-        }
-    }
-
-    _mm_empty();
-}
-
-/* -------------------------------------------------------------------------------------------------
- * fbCompositeSolidMask_nx8888x8888C
- */
-
-void
-fbCompositeSolidMask_nx8888x8888Csse2 (pixman_op_t op,
-				      pixman_image_t * pSrc,
-				      pixman_image_t * pMask,
-				      pixman_image_t * pDst,
-				      int16_t	xSrc,
-				      int16_t	ySrc,
-				      int16_t	xMask,
-				      int16_t	yMask,
-				      int16_t	xDst,
-				      int16_t	yDst,
-				      uint16_t	width,
-				      uint16_t	height)
-{
-    uint32_t	src, srca;
-    uint32_t	*dstLine, d;
-    uint32_t	*maskLine, m;
-    uint32_t    packCmp;
-    int	dstStride, maskStride;
-
-    __m128i xmmSrc, xmmAlpha;
-    __m128i xmmDst, xmmDstLo, xmmDstHi;
-    __m128i xmmMask, xmmMaskLo, xmmMaskHi;
-
-    fbComposeGetSolid(pSrc, src, pDst->bits.format);
-
-    srca = src >> 24;
-    if (srca == 0)
-	return;
-
-    fbComposeGetStart (pDst, xDst, yDst, uint32_t, dstStride, dstLine, 1);
-    fbComposeGetStart (pMask, xMask, yMask, uint32_t, maskStride, maskLine, 1);
-
-    xmmSrc = _mm_unpacklo_epi8 (createMask_2x32_128 (src, src), _mm_setzero_si128 ());
-    xmmAlpha = expandAlpha_1x128 (xmmSrc);
-
-    while (height--)
-    {
-        int w = width;
-        uint32_t *pm = (uint32_t *)maskLine;
-        uint32_t *pd = (uint32_t *)dstLine;
-
-        dstLine += dstStride;
-        maskLine += maskStride;
-
-        /* call prefetch hint to optimize cache load*/
-        cachePrefetch ((__m128i*)pd);
-        cachePrefetch ((__m128i*)pm);
-
-        while (w && (unsigned long)pd & 15)
-        {
-            m = *pm++;
-
-            if (m)
-            {
-                d = *pd;
-
-                *pd = pack_1x64_32 (inOver_1x64 (_mm_movepi64_pi64 (xmmSrc),
-                                                 _mm_movepi64_pi64 (xmmAlpha),
-                                                 unpack_32_1x64 (m),
-                                                 unpack_32_1x64 (d)));
-            }
-
-            pd++;
-            w--;
-        }
-
-        /* call prefetch hint to optimize cache load*/
-        cachePrefetch ((__m128i*)pd);
-        cachePrefetch ((__m128i*)pm);
-
-        while (w >= 4)
-        {
-            /* fill cache line with next memory */
-            cachePrefetchNext ((__m128i*)pd);
-            cachePrefetchNext ((__m128i*)pm);
-
-            xmmMask = load128Unaligned ((__m128i*)pm);
-
-            packCmp = _mm_movemask_epi8 (_mm_cmpeq_epi32 (xmmMask, _mm_setzero_si128()));
-
-            /* if all bits in mask are zero, packCmp are equal to 0xffff */
-            if (packCmp != 0xffff)
-            {
-                xmmDst = load128Aligned ((__m128i*)pd);
-
-                unpack_128_2x128 (xmmMask, &xmmMaskLo, &xmmMaskHi);
-                unpack_128_2x128 (xmmDst, &xmmDstLo, &xmmDstHi);
-
-                inOver_2x128 (xmmSrc, xmmSrc, xmmAlpha, xmmAlpha, xmmMaskLo, xmmMaskHi, &xmmDstLo, &xmmDstHi);
-
-                save128Aligned ((__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
-            }
-
-            pd += 4;
-            pm += 4;
-            w -= 4;
-        }
-
-        while (w)
-        {
-            m = *pm++;
-
-            if (m)
-            {
-                d = *pd;
-
-                *pd = pack_1x64_32 (inOver_1x64 (_mm_movepi64_pi64 (xmmSrc),
-                                                 _mm_movepi64_pi64 (xmmAlpha),
-                                                 unpack_32_1x64 (m),
-                                                 unpack_32_1x64 (d)));
-            }
-
-            pd++;
-            w--;
-        }
-    }
-
-    _mm_empty();
-}
-
-
-/* -------------------------------------------------------------------------------------------------
- * fbCompositeSrc_8888x8x8888
- */
-
-void
-fbCompositeSrc_8888x8x8888sse2 (pixman_op_t op,
-			       pixman_image_t * pSrc,
-			       pixman_image_t * pMask,
-			       pixman_image_t * pDst,
-			       int16_t	xSrc,
-			       int16_t	ySrc,
-			       int16_t      xMask,
-			       int16_t      yMask,
-			       int16_t      xDst,
-			       int16_t      yDst,
-			       uint16_t     width,
-			       uint16_t     height)
-{
-    uint32_t	*dstLine, *dst;
-    uint32_t	*srcLine, *src;
-    uint32_t	mask;
-    uint16_t	w;
-    int	dstStride, srcStride;
-
-    __m128i xmmMask;
-    __m128i xmmSrc, xmmSrcLo, xmmSrcHi;
-    __m128i xmmDst, xmmDstLo, xmmDstHi;
-    __m128i xmmAlphaLo, xmmAlphaHi;
-
-    fbComposeGetStart (pDst, xDst, yDst, uint32_t, dstStride, dstLine, 1);
-    fbComposeGetStart (pSrc, xSrc, ySrc, uint32_t, srcStride, srcLine, 1);
-    fbComposeGetSolid (pMask, mask, pDst->bits.format);
-
-    xmmMask = createMask_16_128 (mask >> 24);
-
-    while (height--)
-    {
-        dst = dstLine;
-        dstLine += dstStride;
-        src = srcLine;
-        srcLine += srcStride;
-        w = width;
-
-        /* call prefetch hint to optimize cache load*/
-        cachePrefetch ((__m128i*)dst);
-        cachePrefetch ((__m128i*)src);
-
-        while (w && (unsigned long)dst & 15)
-        {
-            uint32_t s = *src++;
-            uint32_t d = *dst;
-
-            __m64 ms = unpack_32_1x64 (s);
-
-            *dst++ = pack_1x64_32 (inOver_1x64 (ms,
-                                                 expandAlpha_1x64 (ms),
-                                                 _mm_movepi64_pi64 (xmmMask),
-                                                 unpack_32_1x64 (d)));
-
-            w--;
-        }
-
-        /* call prefetch hint to optimize cache load*/
-        cachePrefetch ((__m128i*)dst);
-        cachePrefetch ((__m128i*)src);
-
-        while (w >= 4)
-        {
-            /* fill cache line with next memory */
-            cachePrefetchNext ((__m128i*)dst);
-            cachePrefetchNext ((__m128i*)src);
-
-            xmmSrc = load128Unaligned ((__m128i*)src);
-            xmmDst = load128Aligned ((__m128i*)dst);
-
-            unpack_128_2x128 (xmmSrc, &xmmSrcLo, &xmmSrcHi);
-            unpack_128_2x128 (xmmDst, &xmmDstLo, &xmmDstHi);
-            expandAlpha_2x128 (xmmSrcLo, xmmSrcHi, &xmmAlphaLo, &xmmAlphaHi);
-
-            inOver_2x128 (xmmSrcLo, xmmSrcHi, xmmAlphaLo, xmmAlphaHi, xmmMask, xmmMask, &xmmDstLo, &xmmDstHi);
-
-            save128Aligned( (__m128i*)dst, pack_2x128_128 (xmmDstLo, xmmDstHi));
-
-            dst += 4;
-            src += 4;
-            w -= 4;
-        }
-
-        while (w)
-        {
-            uint32_t s = *src++;
-            uint32_t d = *dst;
-
-            __m64 ms = unpack_32_1x64 (s);
-
-            *dst++ = pack_1x64_32 (inOver_1x64 (ms,
-                                                 expandAlpha_1x64 (ms),
-                                                 _mm_movepi64_pi64 (xmmMask),
-                                                 unpack_32_1x64 (d)));
-
-            w--;
-        }
-    }
-
-    _mm_empty();
-}
-
-/* -------------------------------------------------------------------------------------------------
- * fbCompositeSrc_x888xnx8888
- */
-void
-fbCompositeSrc_x888xnx8888sse2 (pixman_op_t op,
-			       pixman_image_t * pSrc,
-			       pixman_image_t * pMask,
-			       pixman_image_t * pDst,
-			       int16_t	xSrc,
-			       int16_t	ySrc,
-			       int16_t      xMask,
-			       int16_t      yMask,
-			       int16_t      xDst,
-			       int16_t      yDst,
-			       uint16_t     width,
-			       uint16_t     height)
-{
-    uint32_t	*dstLine, *dst;
-    uint32_t	*srcLine, *src;
-    uint32_t	mask;
-    int	dstStride, srcStride;
-    uint16_t	w;
-
-    __m128i xmmMask, xmmAlpha;
-    __m128i xmmSrc, xmmSrcLo, xmmSrcHi;
-    __m128i xmmDst, xmmDstLo, xmmDstHi;
-
-    fbComposeGetStart (pDst, xDst, yDst, uint32_t, dstStride, dstLine, 1);
-    fbComposeGetStart (pSrc, xSrc, ySrc, uint32_t, srcStride, srcLine, 1);
-    fbComposeGetSolid (pMask, mask, pDst->bits.format);
-
-    xmmMask = createMask_16_128 (mask >> 24);
-    xmmAlpha = Mask00ff;
-
-    while (height--)
-    {
-        dst = dstLine;
-        dstLine += dstStride;
-        src = srcLine;
-        srcLine += srcStride;
-        w = width;
-
-        /* call prefetch hint to optimize cache load*/
-        cachePrefetch ((__m128i*)dst);
-        cachePrefetch ((__m128i*)src);
-
-        while (w && (unsigned long)dst & 15)
-        {
-            uint32_t s = (*src++) | 0xff000000;
-            uint32_t d = *dst;
-
-            *dst++ = pack_1x64_32 (inOver_1x64 (unpack_32_1x64 (s),
-                                                 _mm_movepi64_pi64 (xmmAlpha),
-                                                 _mm_movepi64_pi64 (xmmMask),
-                                                 unpack_32_1x64 (d)));
-
-            w--;
-        }
-
-        /* call prefetch hint to optimize cache load*/
-        cachePrefetch ((__m128i*)dst);
-        cachePrefetch ((__m128i*)src);
-
-        while (w >= 4)
-        {
-            /* fill cache line with next memory */
-            cachePrefetchNext ((__m128i*)dst);
-            cachePrefetchNext ((__m128i*)src);
-
-            xmmSrc = _mm_or_si128 (load128Unaligned ((__m128i*)src), Maskff000000);
-            xmmDst = load128Aligned ((__m128i*)dst);
-
-            unpack_128_2x128 (xmmSrc, &xmmSrcLo, &xmmSrcHi);
-            unpack_128_2x128 (xmmDst, &xmmDstLo, &xmmDstHi);
-
-            inOver_2x128 (xmmSrcLo, xmmSrcHi, xmmAlpha, xmmAlpha, xmmMask, xmmMask, &xmmDstLo, &xmmDstHi);
-
-            save128Aligned( (__m128i*)dst, pack_2x128_128 (xmmDstLo, xmmDstHi));
-
-            dst += 4;
-            src += 4;
-            w -= 4;
-
-        }
-
-        while (w)
-        {
-            uint32_t s = (*src++) | 0xff000000;
-            uint32_t d = *dst;
-
-            *dst++ = pack_1x64_32 (inOver_1x64 (unpack_32_1x64 (s),
-                                                 _mm_movepi64_pi64 (xmmAlpha),
-                                                 _mm_movepi64_pi64 (xmmMask),
-                                                 unpack_32_1x64 (d)));
-
-            w--;
-        }
-    }
-
-    _mm_empty();
-}
-
-/* -------------------------------------------------------------------------------------------------
- * fbCompositeSrc_8888x8888
- */
-void
-fbCompositeSrc_8888x8888sse2 (pixman_op_t op,
-			     pixman_image_t * pSrc,
-			     pixman_image_t * pMask,
-			     pixman_image_t * pDst,
-			     int16_t	xSrc,
-			     int16_t	ySrc,
-			     int16_t      xMask,
-			     int16_t      yMask,
-			     int16_t      xDst,
-			     int16_t      yDst,
-			     uint16_t     width,
-			     uint16_t     height)
-{
-    int	        dstStride, srcStride;
-    uint32_t	*dstLine, *dst;
-    uint32_t	*srcLine, *src;
-
-    fbComposeGetStart (pDst, xDst, yDst, uint32_t, dstStride, dstLine, 1);
-    fbComposeGetStart (pSrc, xSrc, ySrc, uint32_t, srcStride, srcLine, 1);
-
-    dst = dstLine;
-    src = srcLine;
-
-    while (height--)
-    {
-        coreCombineOverUsse2 (dst, src, width);
-
-        dst += dstStride;
-        src += srcStride;
-    }
-    _mm_empty();
-}
-
-/* -------------------------------------------------------------------------------------------------
- * fbCompositeSrc_8888x0565
- */
-static inline uint16_t
-fbCompositeSrc_8888x0565pixel (uint32_t src, uint16_t dst)
-{
-    __m64       ms;
-
-    ms = unpack_32_1x64 (src);
-    return pack565_32_16( pack_1x64_32 (over_1x64 (ms,
-                                                   expandAlpha_1x64 (ms),
-                                                   expand565_16_1x64 (dst))));
-}
-
-void
-fbCompositeSrc_8888x0565sse2 (pixman_op_t op,
-			     pixman_image_t * pSrc,
-			     pixman_image_t * pMask,
-			     pixman_image_t * pDst,
-			     int16_t      xSrc,
-			     int16_t      ySrc,
-			     int16_t      xMask,
-			     int16_t      yMask,
-			     int16_t      xDst,
-			     int16_t      yDst,
-			     uint16_t     width,
-			     uint16_t     height)
-{
-    uint16_t	*dstLine, *dst, d;
-    uint32_t	*srcLine, *src, s;
-    int	dstStride, srcStride;
-    uint16_t	w;
-
-    __m128i xmmAlphaLo, xmmAlphaHi;
-    __m128i xmmSrc, xmmSrcLo, xmmSrcHi;
-    __m128i xmmDst, xmmDst0, xmmDst1, xmmDst2, xmmDst3;
-
-    fbComposeGetStart (pDst, xDst, yDst, uint16_t, dstStride, dstLine, 1);
-    fbComposeGetStart (pSrc, xSrc, ySrc, uint32_t, srcStride, srcLine, 1);
-
-#if 0
-    /* FIXME
-     *
-     * I copy the code from MMX one and keep the fixme.
-     * If it's a problem there, probably is a problem here.
-     */
-    assert (pSrc->pDrawable == pMask->pDrawable);
-#endif
-
-    while (height--)
-    {
-        dst = dstLine;
-        src = srcLine;
-
-        /* call prefetch hint to optimize cache load*/
-        cachePrefetch ((__m128i*)src);
-        cachePrefetch ((__m128i*)dst);
-
-        dstLine += dstStride;
-        srcLine += srcStride;
-        w = width;
-
-        /* Align dst on a 16-byte boundary */
-        while (w &&
-               ((unsigned long)dst & 15))
-        {
-            s = *src++;
-            d = *dst;
-
-            *dst++ = fbCompositeSrc_8888x0565pixel (s, d);
-            w--;
-        }
-
-        /* call prefetch hint to optimize cache load*/
-        cachePrefetch ((__m128i*)src);
-        cachePrefetch ((__m128i*)dst);
-
-        /* It's a 8 pixel loop */
-        while (w >= 8)
-        {
-            /* fill cache line with next memory */
-            cachePrefetchNext ((__m128i*)src);
-            cachePrefetchNext ((__m128i*)dst);
-
-            /* I'm loading unaligned because I'm not sure about the address alignment. */
-            xmmSrc = load128Unaligned ((__m128i*) src);
-            xmmDst = load128Aligned ((__m128i*) dst);
-
-            /* Unpacking */
-            unpack_128_2x128 (xmmSrc, &xmmSrcLo, &xmmSrcHi);
-            unpack565_128_4x128 (xmmDst, &xmmDst0, &xmmDst1, &xmmDst2, &xmmDst3);
-            expandAlpha_2x128 (xmmSrcLo, xmmSrcHi, &xmmAlphaLo, &xmmAlphaHi);
-
-            /* I'm loading next 4 pixels from memory before to optimze the memory read. */
-            xmmSrc = load128Unaligned ((__m128i*) (src+4));
-
-            over_2x128 (xmmSrcLo, xmmSrcHi, xmmAlphaLo, xmmAlphaHi, &xmmDst0, &xmmDst1);
-
-            /* Unpacking */
-            unpack_128_2x128 (xmmSrc, &xmmSrcLo, &xmmSrcHi);
-            expandAlpha_2x128 (xmmSrcLo, xmmSrcHi, &xmmAlphaLo, &xmmAlphaHi);
-
-            over_2x128 (xmmSrcLo, xmmSrcHi, xmmAlphaLo, xmmAlphaHi, &xmmDst2, &xmmDst3);
-
-            save128Aligned ((__m128i*)dst, pack565_4x128_128 (xmmDst0, xmmDst1, xmmDst2, xmmDst3));
-
-            w -= 8;
-            dst += 8;
-            src += 8;
-        }
-
-        while (w--)
-        {
-            s = *src++;
-            d = *dst;
-
-            *dst++ = fbCompositeSrc_8888x0565pixel (s, d);
-        }
-    }
-
-    _mm_empty();
-}
-
-/* -------------------------------------------------------------------------------------------------
- * fbCompositeSolidMask_nx8x8888
- */
-
-void
-fbCompositeSolidMask_nx8x8888sse2 (pixman_op_t op,
-				  pixman_image_t * pSrc,
-				  pixman_image_t * pMask,
-				  pixman_image_t * pDst,
-				  int16_t      xSrc,
-				  int16_t      ySrc,
-				  int16_t      xMask,
-				  int16_t      yMask,
-				  int16_t      xDst,
-				  int16_t      yDst,
-				  uint16_t     width,
-				  uint16_t     height)
-{
-    uint32_t	src, srca;
-    uint32_t	*dstLine, *dst;
-    uint8_t	*maskLine, *mask;
-    int	dstStride, maskStride;
-    uint16_t	w;
-    uint32_t m, d;
-
-    __m128i xmmSrc, xmmAlpha, xmmDef;
-    __m128i xmmDst, xmmDstLo, xmmDstHi;
-    __m128i xmmMask, xmmMaskLo, xmmMaskHi;
-
-    fbComposeGetSolid(pSrc, src, pDst->bits.format);
-
-    srca = src >> 24;
-    if (srca == 0)
-	return;
-
-    fbComposeGetStart (pDst, xDst, yDst, uint32_t, dstStride, dstLine, 1);
-    fbComposeGetStart (pMask, xMask, yMask, uint8_t, maskStride, maskLine, 1);
-
-    xmmDef = createMask_2x32_128 (src, src);
-    xmmSrc = expandPixel_32_1x128 (src);
-    xmmAlpha = expandAlpha_1x128 (xmmSrc);
-
-    while (height--)
-    {
-        dst = dstLine;
-        dstLine += dstStride;
-        mask = maskLine;
-        maskLine += maskStride;
-        w = width;
-
-        /* call prefetch hint to optimize cache load*/
-        cachePrefetch ((__m128i*)mask);
-        cachePrefetch ((__m128i*)dst);
-
-        while (w && (unsigned long)dst & 15)
-        {
-            uint8_t m = *mask++;
-
-            if (m)
-            {
-                d = *dst;
-
-                *dst = pack_1x64_32 (inOver_1x64 (_mm_movepi64_pi64 (xmmSrc),
-                                                  _mm_movepi64_pi64 (xmmAlpha),
-                                                  expandPixel_8_1x64 (m),
-                                                  unpack_32_1x64 (d)));
-            }
-
-            w--;
-            dst++;
-        }
-
-        /* call prefetch hint to optimize cache load*/
-        cachePrefetch ((__m128i*)mask);
-        cachePrefetch ((__m128i*)dst);
-
-        while (w >= 4)
-        {
-            /* fill cache line with next memory */
-            cachePrefetchNext ((__m128i*)mask);
-            cachePrefetchNext ((__m128i*)dst);
-
-            m = *((uint32_t*)mask);
-
-            if (srca == 0xff && m == 0xffffffff)
-            {
-                save128Aligned ((__m128i*)dst, xmmDef);
-            }
-            else if (m)
-            {
-                xmmDst = load128Aligned ((__m128i*) dst);
-                xmmMask = unpack_32_1x128 (m);
-                xmmMask = _mm_unpacklo_epi8 (xmmMask, _mm_setzero_si128());
-
-                /* Unpacking */
-                unpack_128_2x128 (xmmDst, &xmmDstLo, &xmmDstHi);
-                unpack_128_2x128 (xmmMask, &xmmMaskLo, &xmmMaskHi);
-
-                expandAlphaRev_2x128 (xmmMaskLo, xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
-
-                inOver_2x128 (xmmSrc, xmmSrc, xmmAlpha, xmmAlpha, xmmMaskLo, xmmMaskHi, &xmmDstLo, &xmmDstHi);
-
-                save128Aligned ((__m128i*)dst, pack_2x128_128 (xmmDstLo, xmmDstHi));
-            }
-
-            w -= 4;
-            dst += 4;
-            mask += 4;
-        }
-
-        while (w)
-        {
-            uint8_t m = *mask++;
-
-            if (m)
-            {
-                d = *dst;
-
-                *dst = pack_1x64_32 (inOver_1x64 (_mm_movepi64_pi64 (xmmSrc),
-                                                  _mm_movepi64_pi64 (xmmAlpha),
-                                                  expandPixel_8_1x64 (m),
-                                                  unpack_32_1x64 (d)));
-            }
-
-            w--;
-            dst++;
-        }
-    }
-
-    _mm_empty();
-}
-
-/* -------------------------------------------------------------------------------------------------
- * fbCompositeSolidMask_nx8x8888
- */
-
-pixman_bool_t
-pixmanFillsse2 (uint32_t *bits,
-		 int stride,
-		 int bpp,
-		 int x,
-		 int y,
-		 int width,
-		 int height,
-		 uint32_t data)
-{
-    uint32_t	byte_width;
-    uint8_t	    *byte_line;
-
-    __m128i xmmDef;
-
-    if (bpp == 16 && (data >> 16 != (data & 0xffff)))
-	return FALSE;
-
-    if (bpp != 16 && bpp != 32)
-	return FALSE;
-
-    if (bpp == 16)
-    {
-        stride = stride * (int) sizeof (uint32_t) / 2;
-        byte_line = (uint8_t *)(((uint16_t *)bits) + stride * y + x);
-        byte_width = 2 * width;
-        stride *= 2;
-    }
-    else
-    {
-        stride = stride * (int) sizeof (uint32_t) / 4;
-        byte_line = (uint8_t *)(((uint32_t *)bits) + stride * y + x);
-        byte_width = 4 * width;
-        stride *= 4;
-    }
-
-    cachePrefetch ((__m128i*)byte_line);
-    xmmDef = createMask_2x32_128 (data, data);
-
-    while (height--)
-    {
-        int w;
-        uint8_t *d = byte_line;
-        byte_line += stride;
-        w = byte_width;
-
-
-        cachePrefetchNext ((__m128i*)d);
-
-        while (w >= 2 && ((unsigned long)d & 3))
-        {
-            *(uint16_t *)d = data;
-            w -= 2;
-            d += 2;
-        }
-
-        while (w >= 4 && ((unsigned long)d & 15))
-        {
-            *(uint32_t *)d = data;
-
-            w -= 4;
-            d += 4;
-        }
-
-        cachePrefetchNext ((__m128i*)d);
-
-        while (w >= 128)
-        {
-            cachePrefetch (((__m128i*)d) + 12);
-
-            save128Aligned ((__m128i*)(d),     xmmDef);
-            save128Aligned ((__m128i*)(d+16),  xmmDef);
-            save128Aligned ((__m128i*)(d+32),  xmmDef);
-            save128Aligned ((__m128i*)(d+48),  xmmDef);
-            save128Aligned ((__m128i*)(d+64),  xmmDef);
-            save128Aligned ((__m128i*)(d+80),  xmmDef);
-            save128Aligned ((__m128i*)(d+96),  xmmDef);
-            save128Aligned ((__m128i*)(d+112), xmmDef);
-
-            d += 128;
-            w -= 128;
-        }
-
-        if (w >= 64)
-        {
-            cachePrefetch (((__m128i*)d) + 8);
-
-            save128Aligned ((__m128i*)(d),     xmmDef);
-            save128Aligned ((__m128i*)(d+16),  xmmDef);
-            save128Aligned ((__m128i*)(d+32),  xmmDef);
-            save128Aligned ((__m128i*)(d+48),  xmmDef);
-
-            d += 64;
-            w -= 64;
-        }
-
-        cachePrefetchNext ((__m128i*)d);
-
-        if (w >= 32)
-        {
-            save128Aligned ((__m128i*)(d),     xmmDef);
-            save128Aligned ((__m128i*)(d+16),  xmmDef);
-
-            d += 32;
-            w -= 32;
-        }
-
-        if (w >= 16)
-        {
-            save128Aligned ((__m128i*)(d),     xmmDef);
-
-            d += 16;
-            w -= 16;
-        }
-
-        cachePrefetchNext ((__m128i*)d);
-
-        while (w >= 4)
-        {
-            *(uint32_t *)d = data;
-
-            w -= 4;
-            d += 4;
-        }
-
-        if (w >= 2)
-        {
-            *(uint16_t *)d = data;
-            w -= 2;
-            d += 2;
-        }
-    }
-
-    _mm_empty();
-    return TRUE;
-}
-
-void
-fbCompositeSolidMaskSrc_nx8x8888sse2 (pixman_op_t op,
-				     pixman_image_t * pSrc,
-				     pixman_image_t * pMask,
-				     pixman_image_t * pDst,
-				     int16_t      xSrc,
-				     int16_t      ySrc,
-				     int16_t      xMask,
-				     int16_t      yMask,
-				     int16_t      xDst,
-				     int16_t      yDst,
-				     uint16_t     width,
-				     uint16_t     height)
-{
-    uint32_t	src, srca;
-    uint32_t	*dstLine, *dst;
-    uint8_t	*maskLine, *mask;
-    int	dstStride, maskStride;
-    uint16_t	w;
-    uint32_t    m;
-
-    __m128i xmmSrc, xmmDef;
-    __m128i xmmMask, xmmMaskLo, xmmMaskHi;
-
-    fbComposeGetSolid(pSrc, src, pDst->bits.format);
-
-    srca = src >> 24;
-    if (srca == 0)
-    {
-        pixmanFillsse2 (pDst->bits.bits, pDst->bits.rowstride,
-                        PIXMAN_FORMAT_BPP (pDst->bits.format),
-                        xDst, yDst, width, height, 0);
-        return;
-    }
-
-    fbComposeGetStart (pDst, xDst, yDst, uint32_t, dstStride, dstLine, 1);
-    fbComposeGetStart (pMask, xMask, yMask, uint8_t, maskStride, maskLine, 1);
-
-    xmmDef = createMask_2x32_128 (src, src);
-    xmmSrc = expandPixel_32_1x128 (src);
-
-    while (height--)
-    {
-        dst = dstLine;
-        dstLine += dstStride;
-        mask = maskLine;
-        maskLine += maskStride;
-        w = width;
-
-        /* call prefetch hint to optimize cache load*/
-        cachePrefetch ((__m128i*)mask);
-        cachePrefetch ((__m128i*)dst);
-
-        while (w && (unsigned long)dst & 15)
-        {
-            uint8_t m = *mask++;
-
-            if (m)
-            {
-                *dst = pack_1x64_32 (pixMultiply_1x64 (_mm_movepi64_pi64 (xmmSrc), expandPixel_8_1x64 (m)));
-            }
-            else
-            {
-                *dst = 0;
-            }
-
-            w--;
-            dst++;
-        }
-
-        /* call prefetch hint to optimize cache load*/
-        cachePrefetch ((__m128i*)mask);
-        cachePrefetch ((__m128i*)dst);
-
-        while (w >= 4)
-        {
-            /* fill cache line with next memory */
-            cachePrefetchNext ((__m128i*)mask);
-            cachePrefetchNext ((__m128i*)dst);
-
-            m = *((uint32_t*)mask);
-
-            if (srca == 0xff && m == 0xffffffff)
-            {
-                save128Aligned ((__m128i*)dst, xmmDef);
-            }
-            else if (m)
-            {
-                xmmMask = unpack_32_1x128 (m);
-                xmmMask = _mm_unpacklo_epi8 (xmmMask, _mm_setzero_si128());
-
-                /* Unpacking */
-                unpack_128_2x128 (xmmMask, &xmmMaskLo, &xmmMaskHi);
-
-                expandAlphaRev_2x128 (xmmMaskLo, xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
-
-                pixMultiply_2x128 (xmmSrc, xmmSrc, xmmMaskLo, xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
-
-                save128Aligned ((__m128i*)dst, pack_2x128_128 (xmmMaskLo, xmmMaskHi));
-            }
-            else
-            {
-                save128Aligned ((__m128i*)dst, _mm_setzero_si128());
-            }
-
-            w -= 4;
-            dst += 4;
-            mask += 4;
-        }
-
-        while (w)
-        {
-            uint8_t m = *mask++;
-
-            if (m)
-            {
-                *dst = pack_1x64_32 (pixMultiply_1x64 (_mm_movepi64_pi64 (xmmSrc), expandPixel_8_1x64 (m)));
-            }
-            else
-            {
-                *dst = 0;
-            }
-
-            w--;
-            dst++;
-        }
-    }
-
-    _mm_empty();
-}
-
-/* -------------------------------------------------------------------------------------------------
- * fbCompositeSolidMask_nx8x0565
- */
-
-void
-fbCompositeSolidMask_nx8x0565sse2 (pixman_op_t op,
-				  pixman_image_t * pSrc,
-				  pixman_image_t * pMask,
-				  pixman_image_t * pDst,
-				  int16_t      xSrc,
-				  int16_t      ySrc,
-				  int16_t      xMask,
-				  int16_t      yMask,
-				  int16_t      xDst,
-				  int16_t      yDst,
-				  uint16_t     width,
-				  uint16_t     height)
-{
-    uint32_t	src, srca;
-    uint16_t	*dstLine, *dst, d;
-    uint8_t	*maskLine, *mask;
-    int	dstStride, maskStride;
-    uint16_t	w;
-    uint32_t m;
-
-    __m128i xmmSrc, xmmAlpha;
-    __m128i xmmMask, xmmMaskLo, xmmMaskHi;
-    __m128i xmmDst, xmmDst0, xmmDst1, xmmDst2, xmmDst3;
-
-    fbComposeGetSolid(pSrc, src, pDst->bits.format);
-
-    srca = src >> 24;
-    if (srca == 0)
-	return;
-
-    fbComposeGetStart (pDst, xDst, yDst, uint16_t, dstStride, dstLine, 1);
-    fbComposeGetStart (pMask, xMask, yMask, uint8_t, maskStride, maskLine, 1);
-
-    xmmSrc = expandPixel_32_1x128 (src);
-    xmmAlpha = expandAlpha_1x128 (xmmSrc);
-
-    while (height--)
-    {
-        dst = dstLine;
-        dstLine += dstStride;
-        mask = maskLine;
-        maskLine += maskStride;
-        w = width;
-
-        /* call prefetch hint to optimize cache load*/
-        cachePrefetch ((__m128i*)mask);
-        cachePrefetch ((__m128i*)dst);
-
-        while (w && (unsigned long)dst & 15)
-        {
-            m = *mask++;
-
-            if (m)
-            {
-                d = *dst;
-
-                *dst = pack565_32_16 (pack_1x64_32 (inOver_1x64 (_mm_movepi64_pi64 (xmmSrc),
-                                                                 _mm_movepi64_pi64 (xmmAlpha),
-                                                                 expandAlphaRev_1x64 (unpack_32_1x64 (m)),
-                                                                 expand565_16_1x64 (d))));
-            }
-
-            w--;
-            dst++;
-        }
-
-        /* call prefetch hint to optimize cache load*/
-        cachePrefetch ((__m128i*)mask);
-        cachePrefetch ((__m128i*)dst);
-
-        while (w >= 8)
-        {
-            /* fill cache line with next memory */
-            cachePrefetchNext ((__m128i*)mask);
-            cachePrefetchNext ((__m128i*)dst);
-
-            xmmDst = load128Aligned ((__m128i*) dst);
-            unpack565_128_4x128 (xmmDst, &xmmDst0, &xmmDst1, &xmmDst2, &xmmDst3);
-
-            m = *((uint32_t*)mask);
-            mask += 4;
-
-            if (m)
-            {
-                xmmMask = unpack_32_1x128 (m);
-                xmmMask = _mm_unpacklo_epi8 (xmmMask, _mm_setzero_si128());
-
-                /* Unpacking */
-                unpack_128_2x128 (xmmMask, &xmmMaskLo, &xmmMaskHi);
-
-                expandAlphaRev_2x128 (xmmMaskLo, xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
-                inOver_2x128 (xmmSrc, xmmSrc, xmmAlpha, xmmAlpha, xmmMaskLo, xmmMaskHi, &xmmDst0, &xmmDst1);
-            }
-
-            m = *((uint32_t*)mask);
-            mask += 4;
-
-            if (m)
-            {
-                xmmMask = unpack_32_1x128 (m);
-                xmmMask = _mm_unpacklo_epi8 (xmmMask, _mm_setzero_si128());
-
-                /* Unpacking */
-                unpack_128_2x128 (xmmMask, &xmmMaskLo, &xmmMaskHi);
-
-                expandAlphaRev_2x128 (xmmMaskLo, xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
-                inOver_2x128 (xmmSrc, xmmSrc, xmmAlpha, xmmAlpha, xmmMaskLo, xmmMaskHi, &xmmDst2, &xmmDst3);
-            }
-
-            save128Aligned ((__m128i*)dst, pack565_4x128_128 (xmmDst0, xmmDst1, xmmDst2, xmmDst3));
-
-            w -= 8;
-            dst += 8;
-        }
-
-        while (w)
-        {
-            m = *mask++;
-
-            if (m)
-            {
-                d = *dst;
-
-                *dst = pack565_32_16 (pack_1x64_32 (inOver_1x64 (_mm_movepi64_pi64 (xmmSrc),
-                                                                 _mm_movepi64_pi64 (xmmAlpha),
-                                                                 expandAlphaRev_1x64 (unpack_32_1x64 (m)),
-                                                                 expand565_16_1x64 (d))));
-            }
-
-            w--;
-            dst++;
-        }
-    }
-
-    _mm_empty();
-}
-
-/* -------------------------------------------------------------------------------------------------
- * fbCompositeSrc_8888RevNPx0565
- */
-
-void
-fbCompositeSrc_8888RevNPx0565sse2 (pixman_op_t op,
-				  pixman_image_t * pSrc,
-				  pixman_image_t * pMask,
-				  pixman_image_t * pDst,
-				  int16_t      xSrc,
-				  int16_t      ySrc,
-				  int16_t      xMask,
-				  int16_t      yMask,
-				  int16_t      xDst,
-				  int16_t      yDst,
-				  uint16_t     width,
-				  uint16_t     height)
-{
-    uint16_t	*dstLine, *dst, d;
-    uint32_t	*srcLine, *src, s;
-    int	dstStride, srcStride;
-    uint16_t	w;
-    uint32_t    packCmp;
-
-    __m64 ms;
-    __m128i xmmSrc, xmmSrcLo, xmmSrcHi;
-    __m128i xmmDst, xmmDst0, xmmDst1, xmmDst2, xmmDst3;
-
-    fbComposeGetStart (pDst, xDst, yDst, uint16_t, dstStride, dstLine, 1);
-    fbComposeGetStart (pSrc, xSrc, ySrc, uint32_t, srcStride, srcLine, 1);
-
-#if 0
-    /* FIXME
-     *
-     * I copy the code from MMX one and keep the fixme.
-     * If it's a problem there, probably is a problem here.
-     */
-    assert (pSrc->pDrawable == pMask->pDrawable);
-#endif
-
-    while (height--)
-    {
-        dst = dstLine;
-        dstLine += dstStride;
-        src = srcLine;
-        srcLine += srcStride;
-        w = width;
-
-        /* call prefetch hint to optimize cache load*/
-        cachePrefetch ((__m128i*)src);
-        cachePrefetch ((__m128i*)dst);
-
-        while (w && (unsigned long)dst & 15)
-        {
-            s = *src++;
-            d = *dst;
-
-            ms = unpack_32_1x64 (s);
-
-            *dst++ = pack565_32_16 (pack_1x64_32 (overRevNonPre_1x64(ms, expand565_16_1x64 (d))));
-            w--;
-        }
-
-        /* call prefetch hint to optimize cache load*/
-        cachePrefetch ((__m128i*)src);
-        cachePrefetch ((__m128i*)dst);
-
-        while (w >= 8)
-        {
-            /* fill cache line with next memory */
-            cachePrefetchNext ((__m128i*)src);
-            cachePrefetchNext ((__m128i*)dst);
-
-            /* First round */
-            xmmSrc = load128Unaligned((__m128i*)src);
-            xmmDst = load128Aligned  ((__m128i*)dst);
-
-            packCmp = packAlpha (xmmSrc);
-
-            unpack565_128_4x128 (xmmDst, &xmmDst0, &xmmDst1, &xmmDst2, &xmmDst3);
-            unpack_128_2x128 (xmmSrc, &xmmSrcLo, &xmmSrcHi);
-
-            /* preload next round*/
-            xmmSrc = load128Unaligned((__m128i*)(src+4));
-            /* preload next round*/
-
-            if (packCmp == 0xffffffff)
-            {
-                invertColors_2x128 (xmmSrcLo, xmmSrcHi, &xmmDst0, &xmmDst1);
-            }
-            else if (packCmp)
-            {
-                overRevNonPre_2x128 (xmmSrcLo, xmmSrcHi, &xmmDst0, &xmmDst1);
-            }
-
-            /* Second round */
-            packCmp = packAlpha (xmmSrc);
-
-            unpack_128_2x128 (xmmSrc, &xmmSrcLo, &xmmSrcHi);
-
-            if (packCmp == 0xffffffff)
-            {
-                invertColors_2x128 (xmmSrcLo, xmmSrcHi, &xmmDst2, &xmmDst3);
-            }
-            else if (packCmp)
-            {
-                overRevNonPre_2x128 (xmmSrcLo, xmmSrcHi, &xmmDst2, &xmmDst3);
-            }
-
-            save128Aligned ((__m128i*)dst, pack565_4x128_128 (xmmDst0, xmmDst1, xmmDst2, xmmDst3));
-
-            w -= 8;
-            src += 8;
-            dst += 8;
-        }
-
-        while (w)
-        {
-            s = *src++;
-            d = *dst;
-
-            ms = unpack_32_1x64 (s);
-
-            *dst++ = pack565_32_16 (pack_1x64_32 (overRevNonPre_1x64(ms, expand565_16_1x64 (d))));
-            w--;
-        }
-    }
-
-    _mm_empty();
-}
-
-/* "8888RevNP" is GdkPixbuf's format: ABGR, non premultiplied */
-
-/* -------------------------------------------------------------------------------------------------
- * fbCompositeSrc_8888RevNPx8888
- */
-
-void
-fbCompositeSrc_8888RevNPx8888sse2 (pixman_op_t op,
-				  pixman_image_t * pSrc,
-				  pixman_image_t * pMask,
-				  pixman_image_t * pDst,
-				  int16_t      xSrc,
-				  int16_t      ySrc,
-				  int16_t      xMask,
-				  int16_t      yMask,
-				  int16_t      xDst,
-				  int16_t      yDst,
-				  uint16_t     width,
-				  uint16_t     height)
-{
-    uint32_t	*dstLine, *dst, d;
-    uint32_t	*srcLine, *src, s;
-    int	dstStride, srcStride;
-    uint16_t	w;
-    uint32_t    packCmp;
-
-    __m128i xmmSrcLo, xmmSrcHi;
-    __m128i xmmDstLo, xmmDstHi;
-
-    fbComposeGetStart (pDst, xDst, yDst, uint32_t, dstStride, dstLine, 1);
-    fbComposeGetStart (pSrc, xSrc, ySrc, uint32_t, srcStride, srcLine, 1);
-
-#if 0
-    /* FIXME
-     *
-     * I copy the code from MMX one and keep the fixme.
-     * If it's a problem there, probably is a problem here.
-     */
-    assert (pSrc->pDrawable == pMask->pDrawable);
-#endif
-
-    while (height--)
-    {
-        dst = dstLine;
-        dstLine += dstStride;
-        src = srcLine;
-        srcLine += srcStride;
-        w = width;
-
-        /* call prefetch hint to optimize cache load*/
-        cachePrefetch ((__m128i*)src);
-        cachePrefetch ((__m128i*)dst);
-
-        while (w && (unsigned long)dst & 15)
-        {
-            s = *src++;
-            d = *dst;
-
-            *dst++ = pack_1x64_32 (overRevNonPre_1x64 (unpack_32_1x64 (s), unpack_32_1x64 (d)));
-
-            w--;
-        }
-
-        /* call prefetch hint to optimize cache load*/
-        cachePrefetch ((__m128i*)src);
-        cachePrefetch ((__m128i*)dst);
-
-        while (w >= 4)
-        {
-            /* fill cache line with next memory */
-            cachePrefetchNext ((__m128i*)src);
-            cachePrefetchNext ((__m128i*)dst);
-
-            xmmSrcHi = load128Unaligned((__m128i*)src);
-
-            packCmp = packAlpha (xmmSrcHi);
-
-            unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
-
-            if (packCmp == 0xffffffff)
-            {
-                invertColors_2x128( xmmSrcLo, xmmSrcHi, &xmmDstLo, &xmmDstHi);
-
-                save128Aligned ((__m128i*)dst, pack_2x128_128 (xmmDstLo, xmmDstHi));
-            }
-            else if (packCmp)
-            {
-                xmmDstHi = load128Aligned  ((__m128i*)dst);
-
-                unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
-
-                overRevNonPre_2x128 (xmmSrcLo, xmmSrcHi, &xmmDstLo, &xmmDstHi);
-
-                save128Aligned ((__m128i*)dst, pack_2x128_128 (xmmDstLo, xmmDstHi));
-            }
-
-            w -= 4;
-            dst += 4;
-            src += 4;
-        }
-
-        while (w)
-        {
-            s = *src++;
-            d = *dst;
-
-            *dst++ = pack_1x64_32 (overRevNonPre_1x64 (unpack_32_1x64 (s), unpack_32_1x64 (d)));
-
-            w--;
-        }
-    }
-
-    _mm_empty();
-}
-
-/* -------------------------------------------------------------------------------------------------
- * fbCompositeSolidMask_nx8888x0565C
- */
-
-void
-fbCompositeSolidMask_nx8888x0565Csse2 (pixman_op_t op,
-				      pixman_image_t * pSrc,
-				      pixman_image_t * pMask,
-				      pixman_image_t * pDst,
-				      int16_t      xSrc,
-				      int16_t      ySrc,
-				      int16_t      xMask,
-				      int16_t      yMask,
-				      int16_t      xDst,
-				      int16_t      yDst,
-				      uint16_t     width,
-				      uint16_t     height)
-{
-    uint32_t	src, srca;
-    uint16_t	*dstLine, *dst, d;
-    uint32_t	*maskLine, *mask, m;
-    int	dstStride, maskStride;
-    int w;
-    uint32_t packCmp;
-
-    __m128i xmmSrc, xmmAlpha;
-    __m128i xmmMask, xmmMaskLo, xmmMaskHi;
-    __m128i xmmDst, xmmDst0, xmmDst1, xmmDst2, xmmDst3;
-
-    fbComposeGetSolid(pSrc, src, pDst->bits.format);
-
-    srca = src >> 24;
-    if (srca == 0)
-        return;
-
-    fbComposeGetStart (pDst, xDst, yDst, uint16_t, dstStride, dstLine, 1);
-    fbComposeGetStart (pMask, xMask, yMask, uint32_t, maskStride, maskLine, 1);
-
-    xmmSrc = expandPixel_32_1x128 (src);
-    xmmAlpha = expandAlpha_1x128 (xmmSrc);
-
-    while (height--)
-    {
-        w = width;
-        mask = maskLine;
-        dst = dstLine;
-        maskLine += maskStride;
-        dstLine += dstStride;
-
-        /* call prefetch hint to optimize cache load*/
-        cachePrefetch ((__m128i*)mask);
-        cachePrefetch ((__m128i*)dst);
-
-        while (w && ((unsigned long)dst & 15))
-        {
-            m = *(uint32_t *) mask;
-
-            if (m)
-            {
-                d = *dst;
-
-                *dst = pack565_32_16 (pack_1x64_32 (inOver_1x64 (_mm_movepi64_pi64 (xmmSrc),
-                                                                   _mm_movepi64_pi64 (xmmAlpha),
-                                                                   unpack_32_1x64 (m),
-                                                                   expand565_16_1x64 (d))));
-            }
-
-            w--;
-            dst++;
-            mask++;
-        }
-
-        /* call prefetch hint to optimize cache load*/
-        cachePrefetch ((__m128i*)mask);
-        cachePrefetch ((__m128i*)dst);
-
-        while (w >= 8)
-        {
-            /* fill cache line with next memory */
-            cachePrefetchNext ((__m128i*)mask);
-            cachePrefetchNext ((__m128i*)dst);
-
-            /* First round */
-            xmmMask = load128Unaligned((__m128i*)mask);
-            xmmDst = load128Aligned((__m128i*)dst);
-
-            packCmp = _mm_movemask_epi8 (_mm_cmpeq_epi32 (xmmMask, _mm_setzero_si128()));
-
-            unpack565_128_4x128 (xmmDst, &xmmDst0, &xmmDst1, &xmmDst2, &xmmDst3);
-            unpack_128_2x128 (xmmMask, &xmmMaskLo, &xmmMaskHi);
-
-            /* preload next round*/
-            xmmMask = load128Unaligned((__m128i*)(mask+4));
-            /* preload next round*/
-
-            if (packCmp != 0xffff)
-            {
-                inOver_2x128(xmmSrc, xmmSrc, xmmAlpha, xmmAlpha, xmmMaskLo, xmmMaskHi, &xmmDst0, &xmmDst1);
-            }
-
-            /* Second round */
-            packCmp = _mm_movemask_epi8 (_mm_cmpeq_epi32 (xmmMask, _mm_setzero_si128()));
-
-            unpack_128_2x128 (xmmMask, &xmmMaskLo, &xmmMaskHi);
-
-            if (packCmp != 0xffff)
-            {
-                inOver_2x128(xmmSrc, xmmSrc, xmmAlpha, xmmAlpha, xmmMaskLo, xmmMaskHi, &xmmDst2, &xmmDst3);
-            }
-
-            save128Aligned ((__m128i*)dst, pack565_4x128_128 (xmmDst0, xmmDst1, xmmDst2, xmmDst3));
-
-            w -= 8;
-            dst += 8;
-            mask += 8;
-        }
-
-        while (w)
-        {
-            m = *(uint32_t *) mask;
-
-            if (m)
-            {
-                d = *dst;
-
-                *dst = pack565_32_16 (pack_1x64_32 (inOver_1x64 (_mm_movepi64_pi64 (xmmSrc),
-                                                                   _mm_movepi64_pi64 (xmmAlpha),
-                                                                   unpack_32_1x64 (m),
-                                                                   expand565_16_1x64 (d))));
-            }
-
-            w--;
-            dst++;
-            mask++;
-        }
-    }
-
-    _mm_empty ();
-}
-
-/* -------------------------------------------------------------------------------------------------
- * fbCompositeIn_nx8x8
- */
-
-void
-fbCompositeIn_nx8x8sse2 (pixman_op_t op,
-			pixman_image_t * pSrc,
-			pixman_image_t * pMask,
-			pixman_image_t * pDst,
-			int16_t      xSrc,
-			int16_t      ySrc,
-			int16_t      xMask,
-			int16_t      yMask,
-			int16_t      xDst,
-			int16_t      yDst,
-			uint16_t     width,
-			uint16_t     height)
-{
-    uint8_t	*dstLine, *dst;
-    uint8_t	*maskLine, *mask;
-    int	dstStride, maskStride;
-    uint16_t	w, d, m;
-    uint32_t	src;
-    uint8_t	sa;
-
-    __m128i xmmAlpha;
-    __m128i xmmMask, xmmMaskLo, xmmMaskHi;
-    __m128i xmmDst, xmmDstLo, xmmDstHi;
-
-    fbComposeGetStart (pDst, xDst, yDst, uint8_t, dstStride, dstLine, 1);
-    fbComposeGetStart (pMask, xMask, yMask, uint8_t, maskStride, maskLine, 1);
-
-    fbComposeGetSolid(pSrc, src, pDst->bits.format);
-
-    sa = src >> 24;
-    if (sa == 0)
-        return;
-
-    xmmAlpha = expandAlpha_1x128 (expandPixel_32_1x128 (src));
-
-    while (height--)
-    {
-        dst = dstLine;
-        dstLine += dstStride;
-        mask = maskLine;
-        maskLine += maskStride;
-        w = width;
-
-        /* call prefetch hint to optimize cache load*/
-        cachePrefetch ((__m128i*)mask);
-        cachePrefetch ((__m128i*)dst);
-
-        while (w && ((unsigned long)dst & 15))
-        {
-            m = (uint32_t) *mask++;
-            d = (uint32_t) *dst;
-
-            *dst++ = (uint8_t) pack_1x64_32 (pixMultiply_1x64 (pixMultiply_1x64 (_mm_movepi64_pi64 (xmmAlpha), unpack_32_1x64 (m)),
-                                                               unpack_32_1x64 (d)));
-            w--;
-        }
-
-        /* call prefetch hint to optimize cache load*/
-        cachePrefetch ((__m128i*)mask);
-        cachePrefetch ((__m128i*)dst);
-
-        while (w >= 16)
-        {
-            /* fill cache line with next memory */
-            cachePrefetchNext ((__m128i*)mask);
-            cachePrefetchNext ((__m128i*)dst);
-
-            xmmMask = load128Unaligned((__m128i*)mask);
-            xmmDst = load128Aligned((__m128i*)dst);
-
-            unpack_128_2x128 (xmmMask, &xmmMaskLo, &xmmMaskHi);
-            unpack_128_2x128 (xmmDst, &xmmDstLo, &xmmDstHi);
-
-            pixMultiply_2x128 (xmmAlpha, xmmAlpha, xmmMaskLo, xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
-            pixMultiply_2x128 (xmmMaskLo, xmmMaskHi, xmmDstLo, xmmDstHi, &xmmDstLo, &xmmDstHi);
-
-            save128Aligned ((__m128i*)dst, pack_2x128_128 (xmmDstLo, xmmDstHi));
-
-            mask += 16;
-            dst += 16;
-            w -= 16;
-        }
-
-        while (w)
-        {
-            m = (uint32_t) *mask++;
-            d = (uint32_t) *dst;
-
-            *dst++ = (uint8_t) pack_1x64_32 (pixMultiply_1x64 (pixMultiply_1x64 (_mm_movepi64_pi64 (xmmAlpha), unpack_32_1x64 (m)),
-                                                               unpack_32_1x64 (d)));
-            w--;
-        }
-    }
-
-    _mm_empty();
-}
-
-/* -------------------------------------------------------------------------------------------------
- * fbCompositeIn_8x8
- */
-
-void
-fbCompositeIn_8x8sse2 (pixman_op_t op,
-		      pixman_image_t * pSrc,
-		      pixman_image_t * pMask,
-		      pixman_image_t * pDst,
-		      int16_t      xSrc,
-		      int16_t      ySrc,
-		      int16_t      xMask,
-		      int16_t      yMask,
-		      int16_t      xDst,
-		      int16_t      yDst,
-		      uint16_t     width,
-		      uint16_t     height)
-{
-    uint8_t	*dstLine, *dst;
-    uint8_t	*srcLine, *src;
-    int	srcStride, dstStride;
-    uint16_t	w;
-    uint32_t    s, d;
-
-    __m128i xmmSrc, xmmSrcLo, xmmSrcHi;
-    __m128i xmmDst, xmmDstLo, xmmDstHi;
-
-    fbComposeGetStart (pDst, xDst, yDst, uint8_t, dstStride, dstLine, 1);
-    fbComposeGetStart (pSrc, xSrc, ySrc, uint8_t, srcStride, srcLine, 1);
-
-    while (height--)
-    {
-        dst = dstLine;
-        dstLine += dstStride;
-        src = srcLine;
-        srcLine += srcStride;
-        w = width;
-
-        /* call prefetch hint to optimize cache load*/
-        cachePrefetch ((__m128i*)src);
-        cachePrefetch ((__m128i*)dst);
-
-        while (w && ((unsigned long)dst & 15))
-        {
-            s = (uint32_t) *src++;
-            d = (uint32_t) *dst;
-
-            *dst++ = (uint8_t) pack_1x64_32 (pixMultiply_1x64 (unpack_32_1x64 (s),unpack_32_1x64 (d)));
-            w--;
-        }
-
-        /* call prefetch hint to optimize cache load*/
-        cachePrefetch ((__m128i*)src);
-        cachePrefetch ((__m128i*)dst);
-
-        while (w >= 16)
-        {
-            /* fill cache line with next memory */
-            cachePrefetchNext ((__m128i*)src);
-            cachePrefetchNext ((__m128i*)dst);
-
-            xmmSrc = load128Unaligned((__m128i*)src);
-            xmmDst = load128Aligned((__m128i*)dst);
-
-            unpack_128_2x128 (xmmSrc, &xmmSrcLo, &xmmSrcHi);
-            unpack_128_2x128 (xmmDst, &xmmDstLo, &xmmDstHi);
-
-            pixMultiply_2x128 (xmmSrcLo, xmmSrcHi, xmmDstLo, xmmDstHi, &xmmDstLo, &xmmDstHi);
-
-            save128Aligned ((__m128i*)dst, pack_2x128_128 (xmmDstLo, xmmDstHi));
-
-            src += 16;
-            dst += 16;
-            w -= 16;
-        }
-
-        while (w)
-        {
-            s = (uint32_t) *src++;
-            d = (uint32_t) *dst;
-
-            *dst++ = (uint8_t) pack_1x64_32 (pixMultiply_1x64 (unpack_32_1x64 (s),unpack_32_1x64 (d)));
-            w--;
-        }
-    }
-
-    _mm_empty ();
-}
-
-/* -------------------------------------------------------------------------------------------------
- * fbCompositeSrcAdd_8888x8x8
- */
-
-void
-fbCompositeSrcAdd_8888x8x8sse2 (pixman_op_t op,
-			       pixman_image_t * pSrc,
-			       pixman_image_t * pMask,
-			       pixman_image_t * pDst,
-			       int16_t      xSrc,
-			       int16_t      ySrc,
-			       int16_t      xMask,
-			       int16_t      yMask,
-			       int16_t      xDst,
-			       int16_t      yDst,
-			       uint16_t     width,
-			       uint16_t     height)
-{
-    uint8_t	*dstLine, *dst;
-    uint8_t	*maskLine, *mask;
-    int	dstStride, maskStride;
-    uint16_t	w;
-    uint32_t	src;
-    uint8_t	sa;
-    uint32_t m, d;
-
-    __m128i xmmAlpha;
-    __m128i xmmMask, xmmMaskLo, xmmMaskHi;
-    __m128i xmmDst, xmmDstLo, xmmDstHi;
-
-    fbComposeGetStart (pDst, xDst, yDst, uint8_t, dstStride, dstLine, 1);
-    fbComposeGetStart (pMask, xMask, yMask, uint8_t, maskStride, maskLine, 1);
-
-    fbComposeGetSolid(pSrc, src, pDst->bits.format);
-
-    sa = src >> 24;
-    if (sa == 0)
-        return;
-
-    xmmAlpha = expandAlpha_1x128 (expandPixel_32_1x128 (src));
-
-    while (height--)
-    {
-        dst = dstLine;
-        dstLine += dstStride;
-        mask = maskLine;
-        maskLine += maskStride;
-        w = width;
-
-        /* call prefetch hint to optimize cache load*/
-        cachePrefetch ((__m128i*)mask);
-        cachePrefetch ((__m128i*)dst);
-
-        while (w && ((unsigned long)dst & 15))
-        {
-            m = (uint32_t) *mask++;
-            d = (uint32_t) *dst;
-
-            *dst++ = (uint8_t) pack_1x64_32 (_mm_adds_pu16 (pixMultiply_1x64 (_mm_movepi64_pi64 (xmmAlpha), unpack_32_1x64 (m)),
-                                                                              unpack_32_1x64 (d)));
-            w--;
-        }
-
-        /* call prefetch hint to optimize cache load*/
-        cachePrefetch ((__m128i*)mask);
-        cachePrefetch ((__m128i*)dst);
-
-        while (w >= 16)
-        {
-            /* fill cache line with next memory */
-            cachePrefetchNext ((__m128i*)mask);
-            cachePrefetchNext ((__m128i*)dst);
-
-            xmmMask = load128Unaligned((__m128i*)mask);
-            xmmDst = load128Aligned((__m128i*)dst);
-
-            unpack_128_2x128 (xmmMask, &xmmMaskLo, &xmmMaskHi);
-            unpack_128_2x128 (xmmDst, &xmmDstLo, &xmmDstHi);
-
-            pixMultiply_2x128 (xmmAlpha, xmmAlpha, xmmMaskLo, xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
-
-            xmmDstLo = _mm_adds_epu16 (xmmMaskLo, xmmDstLo);
-            xmmDstHi = _mm_adds_epu16 (xmmMaskHi, xmmDstHi);
-
-            save128Aligned ((__m128i*)dst, pack_2x128_128 (xmmDstLo, xmmDstHi));
-
-            mask += 16;
-            dst += 16;
-            w -= 16;
-        }
-
-        while (w)
-        {
-            m = (uint32_t) *mask++;
-            d = (uint32_t) *dst;
-
-            *dst++ = (uint8_t) pack_1x64_32 (_mm_adds_pu16 (pixMultiply_1x64 (_mm_movepi64_pi64 (xmmAlpha), unpack_32_1x64 (m)),
-                                                                              unpack_32_1x64 (d)));
-            w--;
-        }
-    }
-
-    _mm_empty();
-}
-
-/* -------------------------------------------------------------------------------------------------
- * fbCompositeSrcAdd_8000x8000
- */
-
-void
-fbCompositeSrcAdd_8000x8000sse2 (pixman_op_t op,
-				pixman_image_t * pSrc,
-				pixman_image_t * pMask,
-				pixman_image_t * pDst,
-				int16_t      xSrc,
-				int16_t      ySrc,
-				int16_t      xMask,
-				int16_t      yMask,
-				int16_t      xDst,
-				int16_t      yDst,
-				uint16_t     width,
-				uint16_t     height)
-{
-    uint8_t	*dstLine, *dst;
-    uint8_t	*srcLine, *src;
-    int	dstStride, srcStride;
-    uint16_t	w;
-    uint16_t	t;
-
-    fbComposeGetStart (pSrc, xSrc, ySrc, uint8_t, srcStride, srcLine, 1);
-    fbComposeGetStart (pDst, xDst, yDst, uint8_t, dstStride, dstLine, 1);
-
-    while (height--)
-    {
-        dst = dstLine;
-        src = srcLine;
-
-        /* call prefetch hint to optimize cache load*/
-        cachePrefetch ((__m128i*)src);
-        cachePrefetch ((__m128i*)dst);
-
-        dstLine += dstStride;
-        srcLine += srcStride;
-        w = width;
-
-        /* Small head */
-        while (w && (unsigned long)dst & 3)
-        {
-            t = (*dst) + (*src++);
-            *dst++ = t | (0 - (t >> 8));
-            w--;
-        }
-
-        coreCombineAddUsse2 ((uint32_t*)dst, (uint32_t*)src, w >> 2);
-
-        /* Small tail */
-        dst += w & 0xfffc;
-        src += w & 0xfffc;
-
-        w &= 3;
-
-        while (w)
-        {
-            t = (*dst) + (*src++);
-            *dst++ = t | (0 - (t >> 8));
-            w--;
-        }
-    }
-
-    _mm_empty();
-}
-
-/* -------------------------------------------------------------------------------------------------
- * fbCompositeSrcAdd_8888x8888
- */
-void
-fbCompositeSrcAdd_8888x8888sse2 (pixman_op_t 	op,
-				pixman_image_t *	pSrc,
-				pixman_image_t *	pMask,
-				pixman_image_t *	 pDst,
-				int16_t		 xSrc,
-				int16_t      ySrc,
-				int16_t      xMask,
-				int16_t      yMask,
-				int16_t      xDst,
-				int16_t      yDst,
-				uint16_t     width,
-				uint16_t     height)
-{
-    uint32_t	*dstLine, *dst;
-    uint32_t	*srcLine, *src;
-    int	dstStride, srcStride;
-
-    fbComposeGetStart (pSrc, xSrc, ySrc, uint32_t, srcStride, srcLine, 1);
-    fbComposeGetStart (pDst, xDst, yDst, uint32_t, dstStride, dstLine, 1);
-
-    while (height--)
-    {
-        dst = dstLine;
-        dstLine += dstStride;
-        src = srcLine;
-        srcLine += srcStride;
-
-        coreCombineAddUsse2 (dst, src, width);
-    }
-
-    _mm_empty();
-}
-
-/* -------------------------------------------------------------------------------------------------
- * fbCompositeCopyAreasse2
- */
-
-pixman_bool_t
-pixmanBltsse2 (uint32_t *src_bits,
-		uint32_t *dst_bits,
-		int src_stride,
-		int dst_stride,
-		int src_bpp,
-		int dst_bpp,
-		int src_x, int src_y,
-		int dst_x, int dst_y,
-		int width, int height)
-{
-    uint8_t *	src_bytes;
-    uint8_t *	dst_bytes;
-    int		byte_width;
-
-    if (src_bpp != dst_bpp)
-        return FALSE;
-
-    if (src_bpp == 16)
-    {
-        src_stride = src_stride * (int) sizeof (uint32_t) / 2;
-        dst_stride = dst_stride * (int) sizeof (uint32_t) / 2;
-        src_bytes = (uint8_t *)(((uint16_t *)src_bits) + src_stride * (src_y) + (src_x));
-        dst_bytes = (uint8_t *)(((uint16_t *)dst_bits) + dst_stride * (dst_y) + (dst_x));
-        byte_width = 2 * width;
-        src_stride *= 2;
-        dst_stride *= 2;
-    }
-    else if (src_bpp == 32)
-    {
-        src_stride = src_stride * (int) sizeof (uint32_t) / 4;
-        dst_stride = dst_stride * (int) sizeof (uint32_t) / 4;
-        src_bytes = (uint8_t *)(((uint32_t *)src_bits) + src_stride * (src_y) + (src_x));
-        dst_bytes = (uint8_t *)(((uint32_t *)dst_bits) + dst_stride * (dst_y) + (dst_x));
-        byte_width = 4 * width;
-        src_stride *= 4;
-        dst_stride *= 4;
-    }
-    else
-    {
-        return FALSE;
-    }
-
-    cachePrefetch ((__m128i*)src_bytes);
-    cachePrefetch ((__m128i*)dst_bytes);
-
-    while (height--)
-    {
-        int w;
-        uint8_t *s = src_bytes;
-        uint8_t *d = dst_bytes;
-        src_bytes += src_stride;
-        dst_bytes += dst_stride;
-        w = byte_width;
-
-        cachePrefetchNext ((__m128i*)s);
-        cachePrefetchNext ((__m128i*)d);
-
-        while (w >= 2 && ((unsigned long)d & 3))
-        {
-            *(uint16_t *)d = *(uint16_t *)s;
-            w -= 2;
-            s += 2;
-            d += 2;
-        }
-
-        while (w >= 4 && ((unsigned long)d & 15))
-        {
-            *(uint32_t *)d = *(uint32_t *)s;
-
-            w -= 4;
-            s += 4;
-            d += 4;
-        }
-
-        cachePrefetchNext ((__m128i*)s);
-        cachePrefetchNext ((__m128i*)d);
-
-        while (w >= 64)
-        {
-            __m128i xmm0, xmm1, xmm2, xmm3;
-
-            /* 128 bytes ahead */
-            cachePrefetch (((__m128i*)s) + 8);
-            cachePrefetch (((__m128i*)d) + 8);
-
-            xmm0 = load128Unaligned ((__m128i*)(s));
-            xmm1 = load128Unaligned ((__m128i*)(s+16));
-            xmm2 = load128Unaligned ((__m128i*)(s+32));
-            xmm3 = load128Unaligned ((__m128i*)(s+48));
-
-            save128Aligned ((__m128i*)(d),    xmm0);
-            save128Aligned ((__m128i*)(d+16), xmm1);
-            save128Aligned ((__m128i*)(d+32), xmm2);
-            save128Aligned ((__m128i*)(d+48), xmm3);
-
-            s += 64;
-            d += 64;
-            w -= 64;
-        }
-
-        cachePrefetchNext ((__m128i*)s);
-        cachePrefetchNext ((__m128i*)d);
-
-        while (w >= 16)
-        {
-            save128Aligned ((__m128i*)d, load128Unaligned ((__m128i*)s) );
-
-            w -= 16;
-            d += 16;
-            s += 16;
-        }
-
-        cachePrefetchNext ((__m128i*)s);
-        cachePrefetchNext ((__m128i*)d);
-
-        while (w >= 4)
-        {
-            *(uint32_t *)d = *(uint32_t *)s;
-
-            w -= 4;
-            s += 4;
-            d += 4;
-        }
-
-        if (w >= 2)
-        {
-            *(uint16_t *)d = *(uint16_t *)s;
-            w -= 2;
-            s += 2;
-            d += 2;
-        }
-    }
-
-    _mm_empty();
-
-    return TRUE;
-}
-
-void
-fbCompositeCopyAreasse2 (pixman_op_t       op,
-			pixman_image_t *	pSrc,
-			pixman_image_t *	pMask,
-			pixman_image_t *	pDst,
-			int16_t		xSrc,
-			int16_t		ySrc,
-			int16_t		xMask,
-			int16_t		yMask,
-			int16_t		xDst,
-			int16_t		yDst,
-			uint16_t		width,
-			uint16_t		height)
-{
-    pixmanBltsse2 (pSrc->bits.bits,
-		    pDst->bits.bits,
-		    pSrc->bits.rowstride,
-		    pDst->bits.rowstride,
-		    PIXMAN_FORMAT_BPP (pSrc->bits.format),
-		    PIXMAN_FORMAT_BPP (pDst->bits.format),
-		    xSrc, ySrc, xDst, yDst, width, height);
-}
-
-#if 0
-/* This code are buggy in MMX version, now the bug was translated to SSE2 version */
-void
-fbCompositeOver_x888x8x8888sse2 (pixman_op_t      op,
-				pixman_image_t * pSrc,
-				pixman_image_t * pMask,
-				pixman_image_t * pDst,
-				int16_t      xSrc,
-				int16_t      ySrc,
-				int16_t      xMask,
-				int16_t      yMask,
-				int16_t      xDst,
-				int16_t      yDst,
-				uint16_t     width,
-				uint16_t     height)
-{
-    uint32_t	*src, *srcLine, s;
-    uint32_t    *dst, *dstLine, d;
-    uint8_t	    *mask, *maskLine;
-    uint32_t    m;
-    int		 srcStride, maskStride, dstStride;
-    uint16_t w;
-
-    __m128i xmmSrc, xmmSrcLo, xmmSrcHi;
-    __m128i xmmDst, xmmDstLo, xmmDstHi;
-    __m128i xmmMask, xmmMaskLo, xmmMaskHi;
-
-    fbComposeGetStart (pDst, xDst, yDst, uint32_t, dstStride, dstLine, 1);
-    fbComposeGetStart (pMask, xMask, yMask, uint8_t, maskStride, maskLine, 1);
-    fbComposeGetStart (pSrc, xSrc, ySrc, uint32_t, srcStride, srcLine, 1);
-
-    while (height--)
-    {
-        src = srcLine;
-        srcLine += srcStride;
-        dst = dstLine;
-        dstLine += dstStride;
-        mask = maskLine;
-        maskLine += maskStride;
-
-        w = width;
-
-        /* call prefetch hint to optimize cache load*/
-        cachePrefetch ((__m128i*)src);
-        cachePrefetch ((__m128i*)dst);
-        cachePrefetch ((__m128i*)mask);
-
-        while (w && (unsigned long)dst & 15)
-        {
-            s = 0xff000000 | *src++;
-            m = (uint32_t) *mask++;
-            d = *dst;
-
-            __m64 ms = unpack_32_1x64 (s);
-
-            if (m != 0xff)
-            {
-                ms = inOver_1x64 (ms,
-                                  xMask00ff,
-                                  expandAlphaRev_1x64 (unpack_32_1x64 (m)),
-                                  unpack_32_1x64 (d));
-            }
-
-            *dst++ = pack_1x64_32 (ms);
-            w--;
-        }
-
-        /* call prefetch hint to optimize cache load*/
-        cachePrefetch ((__m128i*)src);
-        cachePrefetch ((__m128i*)dst);
-        cachePrefetch ((__m128i*)mask);
-
-        while (w >= 4)
-        {
-            /* fill cache line with next memory */
-            cachePrefetchNext ((__m128i*)src);
-            cachePrefetchNext ((__m128i*)dst);
-            cachePrefetchNext ((__m128i*)mask);
-
-            m = *(uint32_t*) mask;
-            xmmSrc = _mm_or_si128 (load128Unaligned ((__m128i*)src), Maskff000000);
-
-            if (m == 0xffffffff)
-            {
-                save128Aligned ((__m128i*)dst, xmmSrc);
-            }
-            else
-            {
-                xmmDst = load128Aligned ((__m128i*)dst);
-
-                xmmMask = _mm_unpacklo_epi16 (unpack_32_1x128 (m), _mm_setzero_si128());
-
-                unpack_128_2x128 (xmmSrc, &xmmSrcLo, &xmmSrcHi);
-                unpack_128_2x128 (xmmMask, &xmmMaskLo, &xmmMaskHi);
-                unpack_128_2x128 (xmmDst, &xmmDstLo, &xmmDstHi);
-
-                expandAlphaRev_2x128 (xmmMaskLo, xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
-
-                inOver_2x128 (xmmSrcLo, xmmSrcHi, Mask00ff, Mask00ff, xmmMaskLo, xmmMaskHi, &xmmDstLo, &xmmDstHi);
-
-                save128Aligned( (__m128i*)dst, pack_2x128_128 (xmmDstLo, xmmDstHi));
-            }
-
-            src += 4;
-            dst += 4;
-            mask += 4;
-            w -= 4;
-        }
-
-        while (w)
-        {
-            m = (uint32_t) *mask++;
-
-            if (m)
-            {
-                s = 0xff000000 | *src;
-
-                if (m == 0xff)
-                {
-                    *dst = s;
-                }
-                else
-                {
-                    d = *dst;
-
-                    *dst = pack_1x64_32 (inOver_1x64 (unpack_32_1x64 (s),
-                                                      xMask00ff,
-                                                      expandAlphaRev_1x64 (unpack_32_1x64 (m)),
-                                                      unpack_32_1x64 (d)));
-                }
-
-            }
-
-            src++;
-            dst++;
-            w--;
-        }
-    }
-
-    _mm_empty();
-}
-#endif /* #if 0 */
-
-#endif /* USE_SSE2 */
diff -r 14ce7619e9c1 gfx/cairo/libpixman/src/pixman-sse.h
--- a/gfx/cairo/libpixman/src/pixman-sse.h	Sat Sep 06 22:21:37 2008 +1200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,358 +0,0 @@
-/*
- * Copyright © 2008 Rodrigo Kumpera
- * Copyright © 2008 André Tupinambá
- *
- * Permission to use, copy, modify, distribute, and sell this software and its
- * documentation for any purpose is hereby granted without fee, provided that
- * the above copyright notice appear in all copies and that both that
- * copyright notice and this permission notice appear in supporting
- * documentation, and that the name of Red Hat not be used in advertising or
- * publicity pertaining to distribution of the software without specific,
- * written prior permission.  Red Hat makes no representations about the
- * suitability of this software for any purpose.  It is provided "as is"
- * without express or implied warranty.
- *
- * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
- * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
- * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
- * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
- * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
- * SOFTWARE.
- *
- * Author:  Rodrigo Kumpera (kumpera@gmail.com)
- *          André Tupinambá (andrelrt@gmail.com)
- * 
- * Based on work by Owen Taylor and Søren Sandmann
- */
-#ifndef _PIXMAN_SSE_H_
-#define _PIXMAN_SSE_H_
-
-#ifdef HAVE_DIX_CONFIG_H
-#include <dix-config.h>
-#endif
-
-#include "pixman-private.h"
-
-#ifdef USE_SSE2
-
-#if !defined(__amd64__) && !defined(__x86_64__)
-pixman_bool_t pixman_have_sse(void);
-#else
-#define pixman_have_sse() TRUE
-#endif
-
-#else
-#define pixman_have_sse() FALSE
-#endif
-
-#ifdef USE_SSE2
-
-void fbComposeSetupSSE(void);
-
-pixman_bool_t
-pixmanFillsse2 (uint32_t *bits,
-		 int stride,
-		 int bpp,
-		 int x,
-		 int y,
-		 int width,
-		 int height,
-		 uint32_t data);
-
-pixman_bool_t
-pixmanBltsse2 (uint32_t *src_bits,
-		uint32_t *dst_bits,
-		int src_stride,
-		int dst_stride,
-		int src_bpp,
-		int dst_bpp,
-		int src_x, int src_y,
-		int dst_x, int dst_y,
-		int width, int height);
-
-void
-fbCompositeSolid_nx8888sse2 (pixman_op_t op,
-			    pixman_image_t * pSrc,
-			    pixman_image_t * pMask,
-			    pixman_image_t * pDst,
-			    int16_t	xSrc,
-			    int16_t	ySrc,
-			    int16_t	xMask,
-			    int16_t	yMask,
-			    int16_t	xDst,
-			    int16_t	yDst,
-			    uint16_t	width,
-			    uint16_t	height);
-
-void
-fbCompositeSolid_nx0565sse2 (pixman_op_t op,
-			    pixman_image_t * pSrc,
-			    pixman_image_t * pMask,
-			    pixman_image_t * pDst,
-			    int16_t	xSrc,
-			    int16_t	ySrc,
-			    int16_t	xMask,
-			    int16_t	yMask,
-			    int16_t	xDst,
-			    int16_t	yDst,
-			    uint16_t	width,
-			    uint16_t	height);
-
-void
-fbCompositeSolidMask_nx8888x8888Csse2 (pixman_op_t op,
-				      pixman_image_t * pSrc,
-				      pixman_image_t * pMask,
-				      pixman_image_t * pDst,
-				      int16_t	xSrc,
-				      int16_t	ySrc,
-				      int16_t	xMask,
-				      int16_t	yMask,
-				      int16_t	xDst,
-				      int16_t	yDst,
-				      uint16_t	width,
-				      uint16_t	height);
-
-void
-fbCompositeSrc_8888x8x8888sse2 (pixman_op_t op,
-			       pixman_image_t * pSrc,
-			       pixman_image_t * pMask,
-			       pixman_image_t * pDst,
-			       int16_t	xSrc,
-			       int16_t	ySrc,
-			       int16_t      xMask,
-			       int16_t      yMask,
-			       int16_t      xDst,
-			       int16_t      yDst,
-			       uint16_t     width,
-			       uint16_t     height);
-
-void
-fbCompositeSrc_x888xnx8888sse2 (pixman_op_t op,
-			       pixman_image_t * pSrc,
-			       pixman_image_t * pMask,
-			       pixman_image_t * pDst,
-			       int16_t	xSrc,
-			       int16_t	ySrc,
-			       int16_t      xMask,
-			       int16_t      yMask,
-			       int16_t      xDst,
-			       int16_t      yDst,
-			       uint16_t     width,
-			       uint16_t     height);
-
-void
-fbCompositeSrc_8888x8888sse2 (pixman_op_t op,
-                 pixman_image_t * pSrc,
-                 pixman_image_t * pMask,
-                 pixman_image_t * pDst,
-                 int16_t    xSrc,
-                 int16_t    ySrc,
-                 int16_t      xMask,
-                 int16_t      yMask,
-                 int16_t      xDst,
-                 int16_t      yDst,
-                 uint16_t     width,
-                 uint16_t     height);
-
-void
-fbCompositeSrc_8888x0565sse2 (pixman_op_t op,
-                 pixman_image_t * pSrc,
-                 pixman_image_t * pMask,
-                 pixman_image_t * pDst,
-                 int16_t      xSrc,
-                 int16_t      ySrc,
-                 int16_t      xMask,
-                 int16_t      yMask,
-                 int16_t      xDst,
-                 int16_t      yDst,
-                 uint16_t     width,
-                 uint16_t     height);
-
-void
-fbCompositeSolidMask_nx8x8888sse2 (pixman_op_t op,
-				  pixman_image_t * pSrc,
-				  pixman_image_t * pMask,
-				  pixman_image_t * pDst,
-				  int16_t      xSrc,
-				  int16_t      ySrc,
-				  int16_t      xMask,
-				  int16_t      yMask,
-				  int16_t      xDst,
-				  int16_t      yDst,
-				  uint16_t     width,
-				  uint16_t     height);
-
-void
-fbCompositeSolidMaskSrc_nx8x8888sse2 (pixman_op_t op,
-				     pixman_image_t * pSrc,
-				     pixman_image_t * pMask,
-				     pixman_image_t * pDst,
-				     int16_t      xSrc,
-				     int16_t      ySrc,
-				     int16_t      xMask,
-				     int16_t      yMask,
-				     int16_t      xDst,
-				     int16_t      yDst,
-				     uint16_t     width,
-				     uint16_t     height);
-
-void
-fbCompositeSolidMask_nx8x0565sse2 (pixman_op_t op,
-				  pixman_image_t * pSrc,
-				  pixman_image_t * pMask,
-				  pixman_image_t * pDst,
-				  int16_t      xSrc,
-				  int16_t      ySrc,
-				  int16_t      xMask,
-				  int16_t      yMask,
-				  int16_t      xDst,
-				  int16_t      yDst,
-				  uint16_t     width,
-				  uint16_t     height);
-
-void
-fbCompositeSrc_8888RevNPx0565sse2 (pixman_op_t op,
-				  pixman_image_t * pSrc,
-				  pixman_image_t * pMask,
-				  pixman_image_t * pDst,
-				  int16_t      xSrc,
-				  int16_t      ySrc,
-				  int16_t      xMask,
-				  int16_t      yMask,
-				  int16_t      xDst,
-				  int16_t      yDst,
-				  uint16_t     width,
-				  uint16_t     height);
-
-void
-fbCompositeSrc_8888RevNPx8888sse2 (pixman_op_t op,
-				  pixman_image_t * pSrc,
-				  pixman_image_t * pMask,
-				  pixman_image_t * pDst,
-				  int16_t      xSrc,
-				  int16_t      ySrc,
-				  int16_t      xMask,
-				  int16_t      yMask,
-				  int16_t      xDst,
-				  int16_t      yDst,
-				  uint16_t     width,
-				  uint16_t     height);
-
-void
-fbCompositeSolidMask_nx8888x0565Csse2 (pixman_op_t op,
-				      pixman_image_t * pSrc,
-				      pixman_image_t * pMask,
-				      pixman_image_t * pDst,
-				      int16_t      xSrc,
-				      int16_t      ySrc,
-				      int16_t      xMask,
-				      int16_t      yMask,
-				      int16_t      xDst,
-				      int16_t      yDst,
-				      uint16_t     width,
-				      uint16_t     height);
-
-void
-fbCompositeIn_nx8x8sse2 (pixman_op_t op,
-			pixman_image_t * pSrc,
-			pixman_image_t * pMask,
-			pixman_image_t * pDst,
-			int16_t      xSrc,
-			int16_t      ySrc,
-			int16_t      xMask,
-			int16_t      yMask,
-			int16_t      xDst,
-			int16_t      yDst,
-			uint16_t     width,
-			uint16_t     height);
-
-void
-fbCompositeIn_8x8sse2 (pixman_op_t op,
-		      pixman_image_t * pSrc,
-		      pixman_image_t * pMask,
-		      pixman_image_t * pDst,
-		      int16_t      xSrc,
-		      int16_t      ySrc,
-		      int16_t      xMask,
-		      int16_t      yMask,
-		      int16_t      xDst,
-		      int16_t      yDst,
-		      uint16_t     width,
-		      uint16_t     height);
-
-void
-fbCompositeSrcAdd_8888x8x8sse2 (pixman_op_t op,
-			       pixman_image_t * pSrc,
-			       pixman_image_t * pMask,
-			       pixman_image_t * pDst,
-			       int16_t      xSrc,
-			       int16_t      ySrc,
-			       int16_t      xMask,
-			       int16_t      yMask,
-			       int16_t      xDst,
-			       int16_t      yDst,
-			       uint16_t     width,
-			       uint16_t     height);
-
-
-void
-fbCompositeSrcAdd_8000x8000sse2 (pixman_op_t op,
-                pixman_image_t * pSrc,
-                pixman_image_t * pMask,
-                pixman_image_t * pDst,
-                int16_t      xSrc,
-                int16_t      ySrc,
-                int16_t      xMask,
-                int16_t      yMask,
-                int16_t      xDst,
-                int16_t      yDst,
-                uint16_t     width,
-                uint16_t     height);
-
-void
-fbCompositeSrcAdd_8888x8888sse2 (pixman_op_t    op,
-                pixman_image_t *    pSrc,
-                pixman_image_t *    pMask,
-                pixman_image_t *     pDst,
-                int16_t      xSrc,
-                int16_t      ySrc,
-                int16_t      xMask,
-                int16_t      yMask,
-                int16_t      xDst,
-                int16_t      yDst,
-                uint16_t     width,
-                uint16_t     height);
-
-void
-fbCompositeCopyAreasse2 (pixman_op_t       op,
-			pixman_image_t *	pSrc,
-			pixman_image_t *	pMask,
-			pixman_image_t *	pDst,
-			int16_t		xSrc,
-			int16_t		ySrc,
-			int16_t		xMask,
-			int16_t		yMask,
-			int16_t		xDst,
-			int16_t		yDst,
-			uint16_t		width,
-			uint16_t		height);
-
-void
-fbCompositeOver_x888x8x8888sse2 (pixman_op_t      op,
-				pixman_image_t * pSrc,
-				pixman_image_t * pMask,
-				pixman_image_t * pDst,
-				int16_t      xSrc,
-				int16_t      ySrc,
-				int16_t      xMask,
-				int16_t      yMask,
-				int16_t      xDst,
-				int16_t      yDst,
-				uint16_t     width,
-				uint16_t     height);
-
-#endif /* USE_SSE2 */
-
-#endif /* _PIXMAN_SSE_H_ */
diff -r 14ce7619e9c1 gfx/cairo/libpixman/src/pixman-sse2.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/cairo/libpixman/src/pixman-sse2.c	Mon Sep 08 10:35:45 2008 +0300
@@ -0,0 +1,4709 @@
+/*
+ * Copyright © 2008 Rodrigo Kumpera
+ * Copyright © 2008 André Tupinambá
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Red Hat not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  Red Hat makes no representations about the
+ * suitability of this software for any purpose.  It is provided "as is"
+ * without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ *
+ * Author:  Rodrigo Kumpera (kumpera@gmail.com)
+ *          André Tupinambá (andrelrt@gmail.com)
+ * 
+ * Based on work by Owen Taylor and Søren Sandmann
+ */
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <mmintrin.h>
+#include <xmmintrin.h> /* for _mm_shuffle_pi16 and _MM_SHUFFLE */
+#include <emmintrin.h> /* for SSE2 intrinsics */
+
+#include "pixman-sse2.h"
+
+#ifdef USE_SSE2
+
+#ifdef _MSC_VER
+#undef inline
+#define inline __forceinline
+#endif
+
+#ifdef __GNUC__
+#    define inline __inline__ __attribute__ ((__always_inline__))
+#endif
+
+/* -------------------------------------------------------------------------------------------------
+ * Locals
+ */
+
+static __m64 xMask0080;
+static __m64 xMask00ff;
+static __m64 xMask0101;
+static __m64 xMaskAlpha;
+
+static __m64 xMask565rgb;
+static __m64 xMask565Unpack;
+
+static __m128i Mask0080;
+static __m128i Mask00ff;
+static __m128i Mask0101;
+static __m128i Maskffff;
+static __m128i Maskff000000;
+static __m128i MaskAlpha;
+
+static __m128i Mask565r;
+static __m128i Mask565g1, Mask565g2;
+static __m128i Mask565b;
+static __m128i MaskRed;
+static __m128i MaskGreen;
+static __m128i MaskBlue;
+
+/* -------------------------------------------------------------------------------------------------
+ * SSE2 Inlines
+ */
+static inline __m128i
+unpack_32_1x128 (uint32_t data)
+{
+    return _mm_unpacklo_epi8 (_mm_cvtsi32_si128 (data), _mm_setzero_si128());
+}
+
+static inline void
+unpack_128_2x128 (__m128i data, __m128i* dataLo, __m128i* dataHi)
+{
+    *dataLo = _mm_unpacklo_epi8 (data, _mm_setzero_si128 ());
+    *dataHi = _mm_unpackhi_epi8 (data, _mm_setzero_si128 ());
+}
+
+static inline void
+unpack565_128_4x128 (__m128i data, __m128i* data0, __m128i* data1, __m128i* data2, __m128i* data3)
+{
+    __m128i lo, hi;
+    __m128i r, g, b;
+
+    lo = _mm_unpacklo_epi16 (data, _mm_setzero_si128 ());
+    hi = _mm_unpackhi_epi16 (data, _mm_setzero_si128 ());
+
+    r = _mm_and_si128 (_mm_slli_epi32 (lo, 8), MaskRed);
+    g = _mm_and_si128 (_mm_slli_epi32 (lo, 5), MaskGreen);
+    b = _mm_and_si128 (_mm_slli_epi32 (lo, 3), MaskBlue);
+
+    lo = _mm_or_si128 (_mm_or_si128 (r, g), b);
+
+    r = _mm_and_si128 (_mm_slli_epi32 (hi, 8), MaskRed);
+    g = _mm_and_si128 (_mm_slli_epi32 (hi, 5), MaskGreen);
+    b = _mm_and_si128 (_mm_slli_epi32 (hi, 3), MaskBlue);
+
+    hi = _mm_or_si128 (_mm_or_si128 (r, g), b);
+
+    unpack_128_2x128 (lo, data0, data1);
+    unpack_128_2x128 (hi, data2, data3);
+}
+
+static inline uint16_t
+pack565_32_16 (uint32_t pixel)
+{
+    return (uint16_t) (((pixel>>8) & 0xf800) | ((pixel>>5) & 0x07e0) | ((pixel>>3) & 0x001f));
+}
+
+static inline __m128i
+pack_2x128_128 (__m128i lo, __m128i hi)
+{
+    return _mm_packus_epi16 (lo, hi);
+}
+
+static inline __m128i
+pack565_2x128_128 (__m128i lo, __m128i hi)
+{
+    __m128i data;
+    __m128i r, g1, g2, b;
+
+    data = pack_2x128_128 ( lo, hi );
+
+    r  = _mm_and_si128 (data , Mask565r);
+    g1 = _mm_and_si128 (_mm_slli_epi32 (data , 3), Mask565g1);
+    g2 = _mm_and_si128 (_mm_srli_epi32 (data , 5), Mask565g2);
+    b  = _mm_and_si128 (_mm_srli_epi32 (data , 3), Mask565b);
+
+    return _mm_or_si128 (_mm_or_si128 (_mm_or_si128 (r, g1), g2), b);
+}
+
+static inline __m128i
+pack565_4x128_128 (__m128i* xmm0, __m128i* xmm1, __m128i* xmm2, __m128i* xmm3)
+{
+    return _mm_packus_epi16 (pack565_2x128_128 (*xmm0, *xmm1), pack565_2x128_128 (*xmm2, *xmm3));
+}
+
+static inline uint32_t
+packAlpha (__m128i x)
+{
+    return _mm_cvtsi128_si32 (_mm_packus_epi16 (_mm_packus_epi16 (_mm_srli_epi32 (x, 24),
+                                                                  _mm_setzero_si128 ()),
+                                                _mm_setzero_si128 ()));
+}
+
+static inline __m128i
+expandPixel_32_1x128 (uint32_t data)
+{
+    return _mm_shuffle_epi32 (unpack_32_1x128 (data), _MM_SHUFFLE(1, 0, 1, 0));
+}
+
+static inline __m128i
+expandAlpha_1x128 (__m128i data)
+{
+    return _mm_shufflehi_epi16 (_mm_shufflelo_epi16 (data, _MM_SHUFFLE(3, 3, 3, 3)), _MM_SHUFFLE(3, 3, 3, 3));
+}
+
+static inline void
+expandAlpha_2x128 (__m128i dataLo, __m128i dataHi, __m128i* alphaLo, __m128i* alphaHi)
+{
+    __m128i lo, hi;
+
+    lo = _mm_shufflelo_epi16 (dataLo, _MM_SHUFFLE(3, 3, 3, 3));
+    hi = _mm_shufflelo_epi16 (dataHi, _MM_SHUFFLE(3, 3, 3, 3));
+    *alphaLo = _mm_shufflehi_epi16 (lo, _MM_SHUFFLE(3, 3, 3, 3));
+    *alphaHi = _mm_shufflehi_epi16 (hi, _MM_SHUFFLE(3, 3, 3, 3));
+}
+
+static inline void
+expandAlphaRev_2x128 (__m128i dataLo, __m128i dataHi, __m128i* alphaLo, __m128i* alphaHi)
+{
+    __m128i lo, hi;
+
+    lo = _mm_shufflelo_epi16 (dataLo, _MM_SHUFFLE(0, 0, 0, 0));
+    hi = _mm_shufflelo_epi16 (dataHi, _MM_SHUFFLE(0, 0, 0, 0));
+    *alphaLo = _mm_shufflehi_epi16 (lo, _MM_SHUFFLE(0, 0, 0, 0));
+    *alphaHi = _mm_shufflehi_epi16 (hi, _MM_SHUFFLE(0, 0, 0, 0));
+}
+
+static inline void
+pixMultiply_2x128 (__m128i* dataLo, __m128i* dataHi, __m128i* alphaLo, __m128i* alphaHi, __m128i* retLo, __m128i* retHi)
+{
+    __m128i lo, hi;
+
+    lo = _mm_mullo_epi16 (*dataLo, *alphaLo);
+    hi = _mm_mullo_epi16 (*dataHi, *alphaHi);
+    lo = _mm_adds_epu16 (lo, Mask0080);
+    hi = _mm_adds_epu16 (hi, Mask0080);
+    *retLo = _mm_mulhi_epu16 (lo, Mask0101);
+    *retHi = _mm_mulhi_epu16 (hi, Mask0101);
+}
+
+static inline void
+pixAddMultiply_2x128 (__m128i* srcLo, __m128i* srcHi, __m128i* alphaDstLo, __m128i* alphaDstHi,
+                      __m128i* dstLo, __m128i* dstHi, __m128i* alphaSrcLo, __m128i* alphaSrcHi,
+                      __m128i* retLo, __m128i* retHi)
+{
+    __m128i lo, hi;
+    __m128i mulLo, mulHi;
+
+    lo = _mm_mullo_epi16 (*srcLo, *alphaDstLo);
+    hi = _mm_mullo_epi16 (*srcHi, *alphaDstHi);
+    mulLo = _mm_mullo_epi16 (*dstLo, *alphaSrcLo);
+    mulHi = _mm_mullo_epi16 (*dstHi, *alphaSrcHi);
+    lo = _mm_adds_epu16 (lo, Mask0080);
+    hi = _mm_adds_epu16 (hi, Mask0080);
+    lo = _mm_adds_epu16 (lo, mulLo);
+    hi = _mm_adds_epu16 (hi, mulHi);
+    *retLo = _mm_mulhi_epu16 (lo, Mask0101);
+    *retHi = _mm_mulhi_epu16 (hi, Mask0101);
+}
+
+static inline void
+negate_2x128 (__m128i dataLo, __m128i dataHi, __m128i* negLo, __m128i* negHi)
+{
+    *negLo = _mm_xor_si128 (dataLo, Mask00ff);
+    *negHi = _mm_xor_si128 (dataHi, Mask00ff);
+}
+
+static inline void
+invertColors_2x128 (__m128i dataLo, __m128i dataHi, __m128i* invLo, __m128i* invHi)
+{
+    __m128i lo, hi;
+
+    lo = _mm_shufflelo_epi16 (dataLo, _MM_SHUFFLE(3, 0, 1, 2));
+    hi = _mm_shufflelo_epi16 (dataHi, _MM_SHUFFLE(3, 0, 1, 2));
+    *invLo = _mm_shufflehi_epi16 (lo, _MM_SHUFFLE(3, 0, 1, 2));
+    *invHi = _mm_shufflehi_epi16 (hi, _MM_SHUFFLE(3, 0, 1, 2));
+}
+
+static inline void
+over_2x128 (__m128i* srcLo, __m128i* srcHi, __m128i* alphaLo, __m128i* alphaHi, __m128i* dstLo, __m128i* dstHi)
+{
+    negate_2x128 (*alphaLo, *alphaHi, alphaLo, alphaHi);
+
+    pixMultiply_2x128 (dstLo, dstHi, alphaLo, alphaHi, dstLo, dstHi);
+
+    *dstLo = _mm_adds_epu8 (*srcLo, *dstLo);
+    *dstHi = _mm_adds_epu8 (*srcHi, *dstHi);
+}
+
+static inline void
+overRevNonPre_2x128 (__m128i srcLo, __m128i srcHi, __m128i* dstLo, __m128i* dstHi)
+{
+    __m128i lo, hi;
+    __m128i alphaLo, alphaHi;
+
+    expandAlpha_2x128 (srcLo, srcHi, &alphaLo, &alphaHi);
+
+    lo = _mm_or_si128 (alphaLo, MaskAlpha);
+    hi = _mm_or_si128 (alphaHi, MaskAlpha);
+
+    invertColors_2x128 (srcLo, srcHi, &srcLo, &srcHi);
+
+    pixMultiply_2x128 (&srcLo, &srcHi, &lo, &hi, &lo, &hi);
+
+    over_2x128 (&lo, &hi, &alphaLo, &alphaHi, dstLo, dstHi);
+}
+
+static inline void
+inOver_2x128 (__m128i* srcLo,  __m128i* srcHi,  __m128i*  alphaLo, __m128i*  alphaHi,
+              __m128i* maskLo, __m128i* maskHi, __m128i* dstLo,   __m128i* dstHi)
+{
+    __m128i sLo, sHi;
+    __m128i aLo, aHi;
+
+    pixMultiply_2x128 (  srcLo,   srcHi, maskLo, maskHi, &sLo, &sHi);
+    pixMultiply_2x128 (alphaLo, alphaHi, maskLo, maskHi, &aLo, &aHi);
+
+    over_2x128 (&sLo, &sHi, &aLo, &aHi, dstLo, dstHi);
+}
+
+static inline void
+cachePrefetch (__m128i* addr)
+{
+    _mm_prefetch (addr, _MM_HINT_T0);
+}
+
+static inline void
+cachePrefetchNext (__m128i* addr)
+{
+    _mm_prefetch (addr + 4, _MM_HINT_T0); // 64 bytes ahead
+}
+
+/* load 4 pixels from a 16-byte boundary aligned address */
+static inline __m128i
+load128Aligned (__m128i* src)
+{
+    return _mm_load_si128 (src);
+}
+
+/* load 4 pixels from a unaligned address */
+static inline __m128i
+load128Unaligned (__m128i* src)
+{
+    return _mm_loadu_si128 (src);
+}
+
+/* save 4 pixels using Write Combining memory on a 16-byte boundary aligned address */
+static inline void
+save128WriteCombining (__m128i* dst, __m128i data)
+{
+    _mm_stream_si128 (dst, data);
+}
+
+/* save 4 pixels on a 16-byte boundary aligned address */
+static inline void
+save128Aligned (__m128i* dst, __m128i data)
+{
+    _mm_store_si128 (dst, data);
+}
+
+/* save 4 pixels on a unaligned address */
+static inline void
+save128Unaligned (__m128i* dst, __m128i data)
+{
+    _mm_storeu_si128 (dst, data);
+}
+
+/* -------------------------------------------------------------------------------------------------
+ * MMX inlines
+ */
+
+static inline __m64
+unpack_32_1x64 (uint32_t data)
+{
+    return _mm_unpacklo_pi8 (_mm_cvtsi32_si64 (data), _mm_setzero_si64());
+}
+
+static inline __m64
+expandAlpha_1x64 (__m64 data)
+{
+    return _mm_shuffle_pi16 (data, _MM_SHUFFLE(3, 3, 3, 3));
+}
+
+static inline __m64
+expandAlphaRev_1x64 (__m64 data)
+{
+    return _mm_shuffle_pi16 (data, _MM_SHUFFLE(0, 0, 0, 0));
+}
+
+static inline __m64
+expandPixel_8_1x64 (uint8_t data)
+{
+    return _mm_shuffle_pi16 (unpack_32_1x64 ((uint32_t)data), _MM_SHUFFLE(0, 0, 0, 0));
+}
+
+static inline __m64
+pixMultiply_1x64 (__m64 data, __m64 alpha)
+{
+    return _mm_mulhi_pu16 (_mm_adds_pu16 (_mm_mullo_pi16 (data, alpha),
+                                          xMask0080),
+                           xMask0101);
+}
+
+static inline __m64
+pixAddMultiply_1x64 (__m64* src, __m64* alphaDst, __m64* dst, __m64* alphaSrc)
+{
+    return _mm_mulhi_pu16 (_mm_adds_pu16 (_mm_adds_pu16 (_mm_mullo_pi16 (*src, *alphaDst),
+                                                         xMask0080),
+                                          _mm_mullo_pi16 (*dst, *alphaSrc)),
+                           xMask0101);
+}
+
+static inline __m64
+negate_1x64 (__m64 data)
+{
+    return _mm_xor_si64 (data, xMask00ff);
+}
+
+static inline __m64
+invertColors_1x64 (__m64 data)
+{
+    return _mm_shuffle_pi16 (data, _MM_SHUFFLE(3, 0, 1, 2));
+}
+
+static inline __m64
+over_1x64 (__m64 src, __m64 alpha, __m64 dst)
+{
+    return _mm_adds_pu8 (src, pixMultiply_1x64 (dst, negate_1x64 (alpha)));
+}
+
+static inline __m64
+inOver_1x64 (__m64* src, __m64* alpha, __m64* mask, __m64* dst)
+{
+    return over_1x64 (pixMultiply_1x64 (*src, *mask),
+                      pixMultiply_1x64 (*alpha, *mask),
+                      *dst);
+}
+
+static inline __m64
+overRevNonPre_1x64 (__m64 src, __m64 dst)
+{
+    __m64 alpha = expandAlpha_1x64 (src);
+
+    return over_1x64 (pixMultiply_1x64 (invertColors_1x64 (src),
+                                        _mm_or_si64 (alpha, xMaskAlpha)),
+                      alpha,
+                      dst);
+}
+
+static inline uint32_t
+pack_1x64_32( __m64 data )
+{
+    return _mm_cvtsi64_si32 (_mm_packs_pu16 (data, _mm_setzero_si64()));
+}
+
+/* Expand 16 bits positioned at @pos (0-3) of a mmx register into
+ *
+ *    00RR00GG00BB
+ *
+ * --- Expanding 565 in the low word ---
+ *
+ * m = (m << (32 - 3)) | (m << (16 - 5)) | m;
+ * m = m & (01f0003f001f);
+ * m = m * (008404100840);
+ * m = m >> 8;
+ *
+ * Note the trick here - the top word is shifted by another nibble to
+ * avoid it bumping into the middle word
+ */
+static inline __m64
+expand565_16_1x64 (uint16_t pixel)
+{
+    __m64 p;
+    __m64 t1, t2;
+
+    p = _mm_cvtsi32_si64 ((uint32_t) pixel);
+
+    t1 = _mm_slli_si64 (p, 36 - 11);
+    t2 = _mm_slli_si64 (p, 16 - 5);
+
+    p = _mm_or_si64 (t1, p);
+    p = _mm_or_si64 (t2, p);
+    p = _mm_and_si64 (p, xMask565rgb);
+    p = _mm_mullo_pi16 (p, xMask565Unpack);
+
+    return _mm_srli_pi16 (p, 8);
+}
+
+/* -------------------------------------------------------------------------------------------------
+ * Compose Core transformations
+ */
+static inline uint32_t
+coreCombineOverUPixelsse2 (uint32_t src, uint32_t dst)
+{
+    uint8_t     a;
+    __m64       ms;
+
+    a = src >> 24;
+
+    if (a == 0xff)
+    {
+        return src;
+    }
+    else if (a)
+    {
+        ms = unpack_32_1x64 (src);
+        return pack_1x64_32 (over_1x64 (ms, expandAlpha_1x64 (ms), unpack_32_1x64 (dst)));
+    }
+
+    return dst;
+}
+
+static inline void
+coreCombineOverUsse2 (uint32_t* pd, const uint32_t* ps, int w)
+{
+    uint32_t pa;
+    uint32_t s, d;
+
+    __m128i xmmDstLo, xmmDstHi;
+    __m128i xmmSrcLo, xmmSrcHi;
+    __m128i xmmAlphaLo, xmmAlphaHi;
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+
+    /* Align dst on a 16-byte boundary */
+    while (w &&
+           ((unsigned long)pd & 15))
+    {
+        d = *pd;
+        s = *ps++;
+
+        *pd++ = coreCombineOverUPixelsse2 (s, d);
+        w--;
+    }
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+
+    while (w >= 4)
+    {
+        /* fill cache line with next memory */
+        cachePrefetchNext ((__m128i*)ps);
+        cachePrefetchNext ((__m128i*)pd);
+
+        /* I'm loading unaligned because I'm not sure about the address alignment. */
+        xmmSrcHi = load128Unaligned ((__m128i*) ps);
+
+        /* Check the alpha channel */
+        pa = packAlpha (xmmSrcHi);
+
+        if (pa == 0xffffffff)
+        {
+            save128Aligned ((__m128i*)pd, xmmSrcHi);
+        }
+        else if (pa)
+        {
+            xmmDstHi = load128Aligned ((__m128i*) pd);
+
+            unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
+            unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
+
+            expandAlpha_2x128 (xmmSrcLo, xmmSrcHi, &xmmAlphaLo, &xmmAlphaHi);
+
+            over_2x128 (&xmmSrcLo, &xmmSrcHi, &xmmAlphaLo, &xmmAlphaHi, &xmmDstLo, &xmmDstHi);
+
+            /* rebuid the 4 pixel data and save*/
+            save128Aligned ((__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
+        }
+
+        w -= 4;
+        ps += 4;
+        pd += 4;
+    }
+
+    while (w)
+    {
+        d = *pd;
+        s = *ps++;
+
+        *pd++ = coreCombineOverUPixelsse2 (s, d);
+        w--;
+    }
+}
+
+static inline void
+coreCombineOverReverseUsse2 (uint32_t* pd, const uint32_t* ps, int w)
+{
+    uint32_t s, d;
+
+    __m128i xmmDstLo, xmmDstHi;
+    __m128i xmmSrcLo, xmmSrcHi;
+    __m128i xmmAlphaLo, xmmAlphaHi;
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+
+    /* Align dst on a 16-byte boundary */
+    while (w &&
+           ((unsigned long)pd & 15))
+    {
+        d = *pd;
+        s = *ps++;
+
+        *pd++ = coreCombineOverUPixelsse2 (d, s);
+        w--;
+    }
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+
+    while (w >= 4)
+    {
+        /* fill cache line with next memory */
+        cachePrefetchNext ((__m128i*)ps);
+        cachePrefetchNext ((__m128i*)pd);
+
+        /* I'm loading unaligned because I'm not sure about the address alignment. */
+        xmmSrcHi = load128Unaligned ((__m128i*) ps);
+        xmmDstHi = load128Aligned ((__m128i*) pd);
+
+        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
+        unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
+
+        expandAlpha_2x128 (xmmDstLo, xmmDstHi, &xmmAlphaLo, &xmmAlphaHi);
+
+        over_2x128 (&xmmDstLo, &xmmDstHi, &xmmAlphaLo, &xmmAlphaHi, &xmmSrcLo, &xmmSrcHi);
+
+        /* rebuid the 4 pixel data and save*/
+        save128Aligned ((__m128i*)pd, pack_2x128_128 (xmmSrcLo, xmmSrcHi));
+
+        w -= 4;
+        ps += 4;
+        pd += 4;
+    }
+
+    while (w)
+    {
+        d = *pd;
+        s = *ps++;
+
+        *pd++ = coreCombineOverUPixelsse2 (d, s);
+        w--;
+    }
+}
+
+static inline uint32_t
+coreCombineInUPixelsse2 (uint32_t src, uint32_t dst)
+{
+    uint32_t maska = src >> 24;
+
+    if (maska == 0)
+    {
+        return 0;
+    }
+    else if (maska != 0xff)
+    {
+        return pack_1x64_32(pixMultiply_1x64 (unpack_32_1x64 (dst), expandAlpha_1x64 (unpack_32_1x64 (src))));
+    }
+
+    return dst;
+}
+
+static inline void
+coreCombineInUsse2 (uint32_t* pd, const uint32_t* ps, int w)
+{
+    uint32_t s, d;
+
+    __m128i xmmSrcLo, xmmSrcHi;
+    __m128i xmmDstLo, xmmDstHi;
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+
+    while (w && ((unsigned long) pd & 15))
+    {
+        s = *ps++;
+        d = *pd;
+
+        *pd++ = coreCombineInUPixelsse2 (d, s);
+        w--;
+    }
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+
+    while (w >= 4)
+    {
+        /* fill cache line with next memory */
+        cachePrefetchNext ((__m128i*)ps);
+        cachePrefetchNext ((__m128i*)pd);
+
+        xmmDstHi = load128Aligned ((__m128i*) pd);
+        xmmSrcHi = load128Unaligned ((__m128i*) ps);
+
+        unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
+        expandAlpha_2x128 (xmmDstLo, xmmDstHi, &xmmDstLo, &xmmDstHi);
+
+        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
+        pixMultiply_2x128 (&xmmSrcLo, &xmmSrcHi, &xmmDstLo, &xmmDstHi, &xmmDstLo, &xmmDstHi);
+
+        save128Aligned ((__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
+
+        ps += 4;
+        pd += 4;
+        w -= 4;
+    }
+
+    while (w)
+    {
+        s = *ps++;
+        d = *pd;
+
+        *pd++ = coreCombineInUPixelsse2 (d, s);
+        w--;
+    }
+}
+
+static inline void
+coreCombineReverseInUsse2 (uint32_t* pd, const uint32_t* ps, int w)
+{
+    uint32_t s, d;
+
+    __m128i xmmSrcLo, xmmSrcHi;
+    __m128i xmmDstLo, xmmDstHi;
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+
+    while (w && ((unsigned long) pd & 15))
+    {
+        s = *ps++;
+        d = *pd;
+
+        *pd++ = coreCombineInUPixelsse2 (s, d);
+        w--;
+    }
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+
+    while (w >= 4)
+    {
+        /* fill cache line with next memory */
+        cachePrefetchNext ((__m128i*)ps);
+        cachePrefetchNext ((__m128i*)pd);
+
+        xmmDstHi = load128Aligned ((__m128i*) pd);
+        xmmSrcHi = load128Unaligned ((__m128i*) ps);
+
+        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
+        expandAlpha_2x128 (xmmSrcLo, xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
+
+        unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
+        pixMultiply_2x128 (&xmmDstLo, &xmmDstHi, &xmmSrcLo, &xmmSrcHi, &xmmDstLo, &xmmDstHi);
+
+        save128Aligned ((__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
+
+        ps += 4;
+        pd += 4;
+        w -= 4;
+    }
+
+    while (w)
+    {
+        s = *ps++;
+        d = *pd;
+
+        *pd++ = coreCombineInUPixelsse2 (s, d);
+        w--;
+    }
+}
+
+static inline void
+coreCombineReverseOutUsse2 (uint32_t* pd, const uint32_t* ps, int w)
+{
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+
+    while (w && ((unsigned long) pd & 15))
+    {
+        uint32_t s = *ps++;
+        uint32_t d = *pd;
+
+        *pd++ = pack_1x64_32 (pixMultiply_1x64 (unpack_32_1x64 (d), negate_1x64 (expandAlpha_1x64 (unpack_32_1x64 (s)))));
+        w--;
+    }
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+
+    while (w >= 4)
+    {
+        __m128i xmmSrcLo, xmmSrcHi;
+        __m128i xmmDstLo, xmmDstHi;
+
+        /* fill cache line with next memory */
+        cachePrefetchNext ((__m128i*)ps);
+        cachePrefetchNext ((__m128i*)pd);
+
+        xmmSrcHi = load128Unaligned ((__m128i*) ps);
+        xmmDstHi = load128Aligned ((__m128i*) pd);
+
+        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
+        unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
+
+        expandAlpha_2x128 (xmmSrcLo, xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
+        negate_2x128      (xmmSrcLo, xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
+
+        pixMultiply_2x128 (&xmmDstLo, &xmmDstHi, &xmmSrcLo, &xmmSrcHi, &xmmDstLo, &xmmDstHi);
+
+        save128Aligned ((__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
+
+        ps += 4;
+        pd += 4;
+        w -= 4;
+    }
+
+    while (w)
+    {
+        uint32_t s = *ps++;
+        uint32_t d = *pd;
+
+        *pd++ = pack_1x64_32 (pixMultiply_1x64 (unpack_32_1x64 (d), negate_1x64 (expandAlpha_1x64 (unpack_32_1x64 (s)))));
+        w--;
+    }
+}
+
+static inline void
+coreCombineOutUsse2 (uint32_t* pd, const uint32_t* ps, int w)
+{
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+
+    while (w && ((unsigned long) pd & 15))
+    {
+        uint32_t s = *ps++;
+        uint32_t d = *pd;
+
+        *pd++ = pack_1x64_32 (pixMultiply_1x64 (unpack_32_1x64 (s), negate_1x64 (expandAlpha_1x64 (unpack_32_1x64 (d)))));
+        w--;
+    }
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+
+    while (w >= 4)
+    {
+        __m128i xmmSrcLo, xmmSrcHi;
+        __m128i xmmDstLo, xmmDstHi;
+
+        /* fill cache line with next memory */
+        cachePrefetchNext ((__m128i*)ps);
+        cachePrefetchNext ((__m128i*)pd);
+
+        xmmSrcHi = load128Unaligned ((__m128i*) ps);
+        xmmDstHi = load128Aligned ((__m128i*) pd);
+
+        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
+        unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
+
+        expandAlpha_2x128 (xmmDstLo, xmmDstHi, &xmmDstLo, &xmmDstHi);
+        negate_2x128      (xmmDstLo, xmmDstHi, &xmmDstLo, &xmmDstHi);
+
+        pixMultiply_2x128 (&xmmSrcLo, &xmmSrcHi, &xmmDstLo, &xmmDstHi, &xmmDstLo, &xmmDstHi);
+
+        save128Aligned ((__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
+
+        ps += 4;
+        pd += 4;
+        w -= 4;
+    }
+
+    while (w)
+    {
+        uint32_t s = *ps++;
+        uint32_t d = *pd;
+
+        *pd++ = pack_1x64_32 (pixMultiply_1x64 (unpack_32_1x64 (s), negate_1x64 (expandAlpha_1x64 (unpack_32_1x64 (d)))));
+        w--;
+    }
+}
+
+static inline uint32_t
+coreCombineAtopUPixelsse2 (uint32_t src, uint32_t dst)
+{
+    __m64 s = unpack_32_1x64 (src);
+    __m64 d = unpack_32_1x64 (dst);
+
+    __m64 sa = negate_1x64 (expandAlpha_1x64 (s));
+    __m64 da = expandAlpha_1x64 (d);
+
+    return pack_1x64_32 (pixAddMultiply_1x64 (&s, &da, &d, &sa));
+}
+
+static inline void
+coreCombineAtopUsse2 (uint32_t* pd, const uint32_t* ps, int w)
+{
+    uint32_t s, d;
+
+    __m128i xmmSrcLo, xmmSrcHi;
+    __m128i xmmDstLo, xmmDstHi;
+    __m128i xmmAlphaSrcLo, xmmAlphaSrcHi;
+    __m128i xmmAlphaDstLo, xmmAlphaDstHi;
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+
+    while (w && ((unsigned long) pd & 15))
+    {
+        s = *ps++;
+        d = *pd;
+
+        *pd++ = coreCombineAtopUPixelsse2 (s, d);
+        w--;
+    }
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+
+    while (w >= 4)
+    {
+        /* fill cache line with next memory */
+        cachePrefetchNext ((__m128i*)ps);
+        cachePrefetchNext ((__m128i*)pd);
+
+        xmmSrcHi = load128Unaligned ((__m128i*) ps);
+        xmmDstHi = load128Aligned ((__m128i*) pd);
+
+        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
+        unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
+
+        expandAlpha_2x128 (xmmSrcLo, xmmSrcHi, &xmmAlphaSrcLo, &xmmAlphaSrcHi);
+        expandAlpha_2x128 (xmmDstLo, xmmDstHi, &xmmAlphaDstLo, &xmmAlphaDstHi);
+
+        negate_2x128 (xmmAlphaSrcLo, xmmAlphaSrcHi, &xmmAlphaSrcLo, &xmmAlphaSrcHi);
+
+        pixAddMultiply_2x128 ( &xmmSrcLo, &xmmSrcHi, &xmmAlphaDstLo, &xmmAlphaDstHi,
+                               &xmmDstLo, &xmmDstHi, &xmmAlphaSrcLo, &xmmAlphaSrcHi,
+                               &xmmDstLo, &xmmDstHi );
+
+        save128Aligned ((__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
+
+        ps += 4;
+        pd += 4;
+        w -= 4;
+    }
+
+    while (w)
+    {
+        s = *ps++;
+        d = *pd;
+
+        *pd++ = coreCombineAtopUPixelsse2 (s, d);
+        w--;
+    }
+}
+
+static inline uint32_t
+coreCombineReverseAtopUPixelsse2 (uint32_t src, uint32_t dst)
+{
+    __m64 s = unpack_32_1x64 (src);
+    __m64 d = unpack_32_1x64 (dst);
+
+    __m64 sa = expandAlpha_1x64 (s);
+    __m64 da = negate_1x64 (expandAlpha_1x64 (d));
+
+    return pack_1x64_32 (pixAddMultiply_1x64 (&s, &da, &d, &sa));
+}
+
+static inline void
+coreCombineReverseAtopUsse2 (uint32_t* pd, const uint32_t* ps, int w)
+{
+    uint32_t s, d;
+
+    __m128i xmmSrcLo, xmmSrcHi;
+    __m128i xmmDstLo, xmmDstHi;
+    __m128i xmmAlphaSrcLo, xmmAlphaSrcHi;
+    __m128i xmmAlphaDstLo, xmmAlphaDstHi;
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+
+    while (w && ((unsigned long) pd & 15))
+    {
+        s = *ps++;
+        d = *pd;
+
+        *pd++ = coreCombineReverseAtopUPixelsse2 (s, d);
+        w--;
+    }
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+
+    while (w >= 4)
+    {
+        /* fill cache line with next memory */
+        cachePrefetchNext ((__m128i*)ps);
+        cachePrefetchNext ((__m128i*)pd);
+
+        xmmSrcHi = load128Unaligned ((__m128i*) ps);
+        xmmDstHi = load128Aligned ((__m128i*) pd);
+
+        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
+        unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
+
+        expandAlpha_2x128 (xmmSrcLo, xmmSrcHi, &xmmAlphaSrcLo, &xmmAlphaSrcHi);
+        expandAlpha_2x128 (xmmDstLo, xmmDstHi, &xmmAlphaDstLo, &xmmAlphaDstHi);
+
+        negate_2x128 (xmmAlphaDstLo, xmmAlphaDstHi, &xmmAlphaDstLo, &xmmAlphaDstHi);
+
+        pixAddMultiply_2x128 ( &xmmSrcLo, &xmmSrcHi, &xmmAlphaDstLo, &xmmAlphaDstHi,
+                               &xmmDstLo, &xmmDstHi, &xmmAlphaSrcLo, &xmmAlphaSrcHi,
+                               &xmmDstLo, &xmmDstHi );
+
+        save128Aligned ((__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
+
+        ps += 4;
+        pd += 4;
+        w -= 4;
+    }
+
+    while (w)
+    {
+        s = *ps++;
+        d = *pd;
+
+        *pd++ = coreCombineReverseAtopUPixelsse2 (s, d);
+        w--;
+    }
+}
+
+static inline uint32_t
+coreCombineXorUPixelsse2 (uint32_t src, uint32_t dst)
+{
+    __m64 s = unpack_32_1x64 (src);
+    __m64 d = unpack_32_1x64 (dst);
+
+    __m64 negD = negate_1x64 (expandAlpha_1x64 (d));
+    __m64 negS = negate_1x64 (expandAlpha_1x64 (s));
+
+    return pack_1x64_32 (pixAddMultiply_1x64 (&s, &negD, &d, &negS));
+}
+
+static inline void
+coreCombineXorUsse2 (uint32_t* dst, const uint32_t* src, int width)
+{
+    int w = width;
+    uint32_t s, d;
+    uint32_t* pd = dst;
+    const uint32_t* ps = src;
+
+    __m128i xmmSrc, xmmSrcLo, xmmSrcHi;
+    __m128i xmmDst, xmmDstLo, xmmDstHi;
+    __m128i xmmAlphaSrcLo, xmmAlphaSrcHi;
+    __m128i xmmAlphaDstLo, xmmAlphaDstHi;
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+
+    while (w && ((unsigned long) pd & 15))
+    {
+        s = *ps++;
+        d = *pd;
+
+        *pd++ = coreCombineXorUPixelsse2 (s, d);
+        w--;
+    }
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+
+    while (w >= 4)
+    {
+        /* fill cache line with next memory */
+        cachePrefetchNext ((__m128i*)ps);
+        cachePrefetchNext ((__m128i*)pd);
+
+        xmmSrc = load128Unaligned ((__m128i*) ps);
+        xmmDst = load128Aligned ((__m128i*) pd);
+
+        unpack_128_2x128 (xmmSrc, &xmmSrcLo, &xmmSrcHi);
+        unpack_128_2x128 (xmmDst, &xmmDstLo, &xmmDstHi);
+
+        expandAlpha_2x128 (xmmSrcLo, xmmSrcHi, &xmmAlphaSrcLo, &xmmAlphaSrcHi);
+        expandAlpha_2x128 (xmmDstLo, xmmDstHi, &xmmAlphaDstLo, &xmmAlphaDstHi);
+
+        negate_2x128 (xmmAlphaSrcLo, xmmAlphaSrcHi, &xmmAlphaSrcLo, &xmmAlphaSrcHi);
+        negate_2x128 (xmmAlphaDstLo, xmmAlphaDstHi, &xmmAlphaDstLo, &xmmAlphaDstHi);
+
+        pixAddMultiply_2x128 ( &xmmSrcLo, &xmmSrcHi, &xmmAlphaDstLo, &xmmAlphaDstHi,
+                               &xmmDstLo, &xmmDstHi, &xmmAlphaSrcLo, &xmmAlphaSrcHi,
+                               &xmmDstLo, &xmmDstHi );
+
+        save128Aligned ((__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
+
+        ps += 4;
+        pd += 4;
+        w -= 4;
+    }
+
+    while (w)
+    {
+        s = *ps++;
+        d = *pd;
+
+        *pd++ = coreCombineXorUPixelsse2 (s, d);
+        w--;
+    }
+}
+
+static inline void
+coreCombineAddUsse2 (uint32_t* dst, const uint32_t* src, int width)
+{
+    int w = width;
+    uint32_t s,d;
+    uint32_t* pd = dst;
+    const uint32_t* ps = src;
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+
+    while (w && (unsigned long)pd & 15)
+    {
+        s = *ps++;
+        d = *pd;
+        *pd++ = _mm_cvtsi64_si32 (_mm_adds_pu8 (_mm_cvtsi32_si64 (s), _mm_cvtsi32_si64 (d)));
+        w--;
+    }
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+
+    while (w >= 4)
+    {
+        /* fill cache line with next memory */
+        cachePrefetchNext ((__m128i*)ps);
+        cachePrefetchNext ((__m128i*)pd);
+
+        save128Aligned( (__m128i*)pd,
+                        _mm_adds_epu8( load128Unaligned((__m128i*)ps),
+                                       load128Aligned  ((__m128i*)pd)) );
+        pd += 4;
+        ps += 4;
+        w -= 4;
+    }
+
+    while (w--)
+    {
+        s = *ps++;
+        d = *pd;
+        *pd++ = _mm_cvtsi64_si32 (_mm_adds_pu8 (_mm_cvtsi32_si64 (s), _mm_cvtsi32_si64 (d)));
+    }
+}
+
+static inline uint32_t
+coreCombineSaturateUPixelsse2 (uint32_t src, uint32_t dst)
+{
+    __m64 ms = unpack_32_1x64 (src);
+    __m64 md = unpack_32_1x64 (dst);
+    uint32_t sa = src >> 24;
+    uint32_t da = ~dst >> 24;
+
+    if (sa > da)
+    {
+        ms = pixMultiply_1x64 (ms, expandAlpha_1x64 (unpack_32_1x64 (FbIntDiv(da, sa) << 24)));
+    }
+
+    return pack_1x64_32 (_mm_adds_pu16 (md, ms));
+}
+
+static inline void
+coreCombineSaturateUsse2 (uint32_t *pd, const uint32_t *ps, int w)
+{
+    uint32_t s,d;
+
+    uint32_t packCmp;
+    __m128i xmmSrc, xmmDst;
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+
+    while (w && (unsigned long)pd & 15)
+    {
+        s = *ps++;
+        d = *pd;
+        *pd++ = coreCombineSaturateUPixelsse2 (s, d);
+        w--;
+    }
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+
+    while (w >= 4)
+    {
+        /* fill cache line with next memory */
+        cachePrefetchNext ((__m128i*)ps);
+        cachePrefetchNext ((__m128i*)pd);
+
+        xmmDst = load128Aligned  ((__m128i*)pd);
+        xmmSrc = load128Unaligned((__m128i*)ps);
+
+        packCmp = _mm_movemask_epi8 (_mm_cmpgt_epi32 (_mm_srli_epi32 (xmmSrc, 24),
+                                                      _mm_srli_epi32 (_mm_xor_si128 (xmmDst, Maskff000000), 24)));
+
+        /* if some alpha src is grater than respective ~alpha dst */
+        if (packCmp)
+        {
+            s = *ps++;
+            d = *pd;
+            *pd++ = coreCombineSaturateUPixelsse2 (s, d);
+
+            s = *ps++;
+            d = *pd;
+            *pd++ = coreCombineSaturateUPixelsse2 (s, d);
+
+            s = *ps++;
+            d = *pd;
+            *pd++ = coreCombineSaturateUPixelsse2 (s, d);
+
+            s = *ps++;
+            d = *pd;
+            *pd++ = coreCombineSaturateUPixelsse2 (s, d);
+        }
+        else
+        {
+            save128Aligned ((__m128i*)pd, _mm_adds_epu8 (xmmDst, xmmSrc));
+
+            pd += 4;
+            ps += 4;
+        }
+
+        w -= 4;
+    }
+
+    while (w--)
+    {
+        s = *ps++;
+        d = *pd;
+        *pd++ = coreCombineSaturateUPixelsse2 (s, d);
+    }
+}
+
+static inline void
+coreCombineSrcCsse2 (uint32_t* pd, const uint32_t* ps, const uint32_t *pm, int w)
+{
+    uint32_t s, m;
+
+    __m128i xmmSrcLo, xmmSrcHi;
+    __m128i xmmMaskLo, xmmMaskHi;
+    __m128i xmmDstLo, xmmDstHi;
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+    cachePrefetch ((__m128i*)pm);
+
+    while (w && (unsigned long)pd & 15)
+    {
+        s = *ps++;
+        m = *pm++;
+        *pd++ = pack_1x64_32 (pixMultiply_1x64 (unpack_32_1x64 (s), unpack_32_1x64 (m)));
+        w--;
+    }
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+    cachePrefetch ((__m128i*)pm);
+
+    while (w >= 4)
+    {
+        /* fill cache line with next memory */
+        cachePrefetchNext ((__m128i*)ps);
+        cachePrefetchNext ((__m128i*)pd);
+        cachePrefetchNext ((__m128i*)pm);
+
+        xmmSrcHi = load128Unaligned ((__m128i*)ps);
+        xmmMaskHi = load128Unaligned ((__m128i*)pm);
+
+        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
+        unpack_128_2x128 (xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
+
+        pixMultiply_2x128 (&xmmSrcLo, &xmmSrcHi, &xmmMaskLo, &xmmMaskHi, &xmmDstLo, &xmmDstHi);
+
+        save128Aligned( (__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
+
+        ps += 4;
+        pd += 4;
+        pm += 4;
+        w -= 4;
+    }
+
+    while (w)
+    {
+        s = *ps++;
+        m = *pm++;
+        *pd++ = pack_1x64_32 (pixMultiply_1x64 (unpack_32_1x64 (s), unpack_32_1x64 (m)));
+        w--;
+    }
+}
+
+static inline uint32_t
+coreCombineOverCPixelsse2 (uint32_t src, uint32_t mask, uint32_t dst)
+{
+    __m64 s = unpack_32_1x64 (src);
+    __m64 expAlpha = expandAlpha_1x64 (s);
+    __m64 unpkMask = unpack_32_1x64 (mask);
+    __m64 unpkDst  = unpack_32_1x64 (dst);
+
+    return pack_1x64_32 (inOver_1x64 (&s, &expAlpha, &unpkMask, &unpkDst));
+}
+
+static inline void
+coreCombineOverCsse2 (uint32_t* pd, const uint32_t* ps, const uint32_t *pm, int w)
+{
+    uint32_t s, m, d;
+
+    __m128i xmmAlphaLo, xmmAlphaHi;
+    __m128i xmmSrcLo, xmmSrcHi;
+    __m128i xmmDstLo, xmmDstHi;
+    __m128i xmmMaskLo, xmmMaskHi;
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+    cachePrefetch ((__m128i*)pm);
+
+    while (w && (unsigned long)pd & 15)
+    {
+        s = *ps++;
+        m = *pm++;
+        d = *pd;
+
+        *pd++ = coreCombineOverCPixelsse2 (s, m, d);
+        w--;
+    }
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+    cachePrefetch ((__m128i*)pm);
+
+    while (w >= 4)
+    {
+        /* fill cache line with next memory */
+        cachePrefetchNext ((__m128i*)ps);
+        cachePrefetchNext ((__m128i*)pd);
+        cachePrefetchNext ((__m128i*)pm);
+
+        xmmDstHi = load128Aligned ((__m128i*)pd);
+        xmmSrcHi = load128Unaligned ((__m128i*)ps);
+        xmmMaskHi = load128Unaligned ((__m128i*)pm);
+
+        unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
+        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
+        unpack_128_2x128 (xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
+
+        expandAlpha_2x128 (xmmSrcLo, xmmSrcHi, &xmmAlphaLo, &xmmAlphaHi);
+
+        inOver_2x128 (&xmmSrcLo, &xmmSrcHi, &xmmAlphaLo, &xmmAlphaHi, &xmmMaskLo, &xmmMaskHi, &xmmDstLo, &xmmDstHi);
+
+        save128Aligned( (__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
+
+        ps += 4;
+        pd += 4;
+        pm += 4;
+        w -= 4;
+    }
+
+    while (w)
+    {
+        s = *ps++;
+        m = *pm++;
+        d = *pd;
+
+        *pd++ = coreCombineOverCPixelsse2 (s, m, d);
+        w--;
+    }
+}
+
+static inline uint32_t
+coreCombineOverReverseCPixelsse2 (uint32_t src, uint32_t mask, uint32_t dst)
+{
+    __m64 d = unpack_32_1x64 (dst);
+
+	return pack_1x64_32(over_1x64 (d, expandAlpha_1x64 (d), pixMultiply_1x64 (unpack_32_1x64 (src), unpack_32_1x64 (mask))));
+}
+
+static inline void
+coreCombineOverReverseCsse2 (uint32_t* pd, const uint32_t* ps, const uint32_t *pm, int w)
+{
+    uint32_t s, m, d;
+
+    __m128i xmmAlphaLo, xmmAlphaHi;
+    __m128i xmmSrcLo, xmmSrcHi;
+    __m128i xmmDstLo, xmmDstHi;
+    __m128i xmmMaskLo, xmmMaskHi;
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+    cachePrefetch ((__m128i*)pm);
+
+    while (w && (unsigned long)pd & 15)
+    {
+        s = *ps++;
+        m = *pm++;
+        d = *pd;
+
+        *pd++ = coreCombineOverReverseCPixelsse2 (s, m, d);
+        w--;
+    }
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+    cachePrefetch ((__m128i*)pm);
+
+    while (w >= 4)
+    {
+        /* fill cache line with next memory */
+        cachePrefetchNext ((__m128i*)ps);
+        cachePrefetchNext ((__m128i*)pd);
+        cachePrefetchNext ((__m128i*)pm);
+
+        xmmDstHi = load128Aligned ((__m128i*)pd);
+        xmmSrcHi = load128Unaligned ((__m128i*)ps);
+        xmmMaskHi = load128Unaligned ((__m128i*)pm);
+
+        unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
+        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
+        unpack_128_2x128 (xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
+
+        expandAlpha_2x128 (xmmDstLo, xmmDstHi, &xmmAlphaLo, &xmmAlphaHi);
+        pixMultiply_2x128 (&xmmSrcLo, &xmmSrcHi, &xmmMaskLo, &xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
+
+        over_2x128 (&xmmDstLo, &xmmDstHi, &xmmAlphaLo, &xmmAlphaHi, &xmmMaskLo, &xmmMaskHi);
+
+        save128Aligned( (__m128i*)pd, pack_2x128_128 (xmmMaskLo, xmmMaskHi));
+
+        ps += 4;
+        pd += 4;
+        pm += 4;
+        w -= 4;
+    }
+
+    while (w)
+    {
+        s = *ps++;
+        m = *pm++;
+        d = *pd;
+
+        *pd++ = coreCombineOverReverseCPixelsse2 (s, m, d);
+        w--;
+    }
+}
+
+static inline void
+coreCombineInCsse2 (uint32_t *pd, uint32_t *ps, uint32_t *pm, int w)
+{
+    uint32_t s, m, d;
+
+    __m128i xmmAlphaLo, xmmAlphaHi;
+    __m128i xmmSrcLo, xmmSrcHi;
+    __m128i xmmDstLo, xmmDstHi;
+    __m128i xmmMaskLo, xmmMaskHi;
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+    cachePrefetch ((__m128i*)pm);
+
+    while (w && (unsigned long)pd & 15)
+    {
+        s = *ps++;
+        m = *pm++;
+        d = *pd;
+
+        *pd++ = pack_1x64_32 (pixMultiply_1x64 (pixMultiply_1x64 (unpack_32_1x64 (s), unpack_32_1x64 (m)),
+                                                expandAlpha_1x64 (unpack_32_1x64 (d))));
+        w--;
+    }
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+    cachePrefetch ((__m128i*)pm);
+
+    while (w >= 4)
+    {
+        /* fill cache line with next memory */
+        cachePrefetchNext ((__m128i*)ps);
+        cachePrefetchNext ((__m128i*)pd);
+        cachePrefetchNext ((__m128i*)pm);
+
+        xmmDstHi = load128Aligned ((__m128i*)pd);
+        xmmSrcHi = load128Unaligned ((__m128i*)ps);
+        xmmMaskHi = load128Unaligned ((__m128i*)pm);
+
+        unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
+        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
+        unpack_128_2x128 (xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
+
+        expandAlpha_2x128 (xmmDstLo, xmmDstHi, &xmmAlphaLo, &xmmAlphaHi);
+        pixMultiply_2x128 (&xmmSrcLo, &xmmSrcHi, &xmmMaskLo, &xmmMaskHi, &xmmDstLo, &xmmDstHi);
+
+        pixMultiply_2x128 (&xmmDstLo, &xmmDstHi, &xmmAlphaLo, &xmmAlphaHi, &xmmDstLo, &xmmDstHi);
+
+        save128Aligned( (__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
+
+        ps += 4;
+        pd += 4;
+        pm += 4;
+        w -= 4;
+    }
+
+    while (w)
+    {
+        s = *ps++;
+        m = *pm++;
+        d = *pd;
+
+        *pd++ = pack_1x64_32 (pixMultiply_1x64 (pixMultiply_1x64 (unpack_32_1x64 (s), unpack_32_1x64 (m)),
+                                                expandAlpha_1x64 (unpack_32_1x64 (d))));
+        w--;
+    }
+}
+
+static inline void
+coreCombineInReverseCsse2 (uint32_t *pd, uint32_t *ps, uint32_t *pm, int w)
+{
+    uint32_t s, m, d;
+
+    __m128i xmmAlphaLo, xmmAlphaHi;
+    __m128i xmmSrcLo, xmmSrcHi;
+    __m128i xmmDstLo, xmmDstHi;
+    __m128i xmmMaskLo, xmmMaskHi;
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+    cachePrefetch ((__m128i*)pm);
+
+    while (w && (unsigned long)pd & 15)
+    {
+        s = *ps++;
+        m = *pm++;
+        d = *pd;
+
+        *pd++ = pack_1x64_32 (pixMultiply_1x64 (unpack_32_1x64 (d),
+                                                pixMultiply_1x64 (unpack_32_1x64 (m),
+                                                                  expandAlpha_1x64 (unpack_32_1x64 (s)))));
+        w--;
+    }
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+    cachePrefetch ((__m128i*)pm);
+
+    while (w >= 4)
+    {
+        /* fill cache line with next memory */
+        cachePrefetchNext ((__m128i*)ps);
+        cachePrefetchNext ((__m128i*)pd);
+        cachePrefetchNext ((__m128i*)pm);
+
+        xmmDstHi = load128Aligned ((__m128i*)pd);
+        xmmSrcHi = load128Unaligned ((__m128i*)ps);
+        xmmMaskHi = load128Unaligned ((__m128i*)pm);
+
+        unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
+        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
+        unpack_128_2x128 (xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
+
+        expandAlpha_2x128 (xmmSrcLo, xmmSrcHi, &xmmAlphaLo, &xmmAlphaHi);
+        pixMultiply_2x128 (&xmmMaskLo, &xmmMaskHi, &xmmAlphaLo, &xmmAlphaHi, &xmmAlphaLo, &xmmAlphaHi);
+
+        pixMultiply_2x128 (&xmmDstLo, &xmmDstHi, &xmmAlphaLo, &xmmAlphaHi, &xmmDstLo, &xmmDstHi);
+
+        save128Aligned( (__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
+
+        ps += 4;
+        pd += 4;
+        pm += 4;
+        w -= 4;
+    }
+
+    while (w)
+    {
+        s = *ps++;
+        m = *pm++;
+        d = *pd;
+
+        *pd++ = pack_1x64_32 (pixMultiply_1x64 (unpack_32_1x64 (d),
+                                                pixMultiply_1x64 (unpack_32_1x64 (m),
+                                                                  expandAlpha_1x64 (unpack_32_1x64 (s)))));
+        w--;
+    }
+}
+
+static inline void
+coreCombineOutCsse2 (uint32_t *pd, uint32_t *ps, uint32_t *pm, int w)
+{
+    uint32_t s, m, d;
+
+    __m128i xmmAlphaLo, xmmAlphaHi;
+    __m128i xmmSrcLo, xmmSrcHi;
+    __m128i xmmDstLo, xmmDstHi;
+    __m128i xmmMaskLo, xmmMaskHi;
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+    cachePrefetch ((__m128i*)pm);
+
+    while (w && (unsigned long)pd & 15)
+    {
+        s = *ps++;
+        m = *pm++;
+        d = *pd;
+
+        *pd++ = pack_1x64_32 (pixMultiply_1x64 (pixMultiply_1x64 (unpack_32_1x64 (s), unpack_32_1x64 (m)),
+                                                negate_1x64 (expandAlpha_1x64 (unpack_32_1x64 (d)))));
+        w--;
+    }
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+    cachePrefetch ((__m128i*)pm);
+
+    while (w >= 4)
+    {
+        /* fill cache line with next memory */
+        cachePrefetchNext ((__m128i*)ps);
+        cachePrefetchNext ((__m128i*)pd);
+        cachePrefetchNext ((__m128i*)pm);
+
+        xmmDstHi = load128Aligned ((__m128i*)pd);
+        xmmSrcHi = load128Unaligned ((__m128i*)ps);
+        xmmMaskHi = load128Unaligned ((__m128i*)pm);
+
+        unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
+        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
+        unpack_128_2x128 (xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
+
+        expandAlpha_2x128 (xmmDstLo, xmmDstHi, &xmmAlphaLo, &xmmAlphaHi);
+        negate_2x128 (xmmAlphaLo, xmmAlphaHi, &xmmAlphaLo, &xmmAlphaHi);
+
+        pixMultiply_2x128 (&xmmSrcLo, &xmmSrcHi, &xmmMaskLo, &xmmMaskHi, &xmmDstLo, &xmmDstHi);
+        pixMultiply_2x128 (&xmmDstLo, &xmmDstHi, &xmmAlphaLo, &xmmAlphaHi, &xmmDstLo, &xmmDstHi);
+
+        save128Aligned( (__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
+
+        ps += 4;
+        pd += 4;
+        pm += 4;
+        w -= 4;
+    }
+
+    while (w)
+    {
+        s = *ps++;
+        m = *pm++;
+        d = *pd;
+
+        *pd++ = pack_1x64_32 (pixMultiply_1x64 (pixMultiply_1x64 (unpack_32_1x64 (s), unpack_32_1x64 (m)),
+                                                negate_1x64 (expandAlpha_1x64 (unpack_32_1x64 (d)))));
+        w--;
+    }
+}
+
+static inline void
+coreCombineOutReverseCsse2 (uint32_t *pd, uint32_t *ps, uint32_t *pm, int w)
+{
+    uint32_t s, m, d;
+
+    __m128i xmmAlphaLo, xmmAlphaHi;
+    __m128i xmmSrcLo, xmmSrcHi;
+    __m128i xmmDstLo, xmmDstHi;
+    __m128i xmmMaskLo, xmmMaskHi;
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+    cachePrefetch ((__m128i*)pm);
+
+    while (w && (unsigned long)pd & 15)
+    {
+        s = *ps++;
+        m = *pm++;
+        d = *pd;
+
+        *pd++ = pack_1x64_32 (pixMultiply_1x64 (unpack_32_1x64 (d),
+                                                negate_1x64 (pixMultiply_1x64 (unpack_32_1x64 (m),
+                                                                               expandAlpha_1x64 (unpack_32_1x64 (s))))));
+        w--;
+    }
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+    cachePrefetch ((__m128i*)pm);
+
+    while (w >= 4)
+    {
+        /* fill cache line with next memory */
+        cachePrefetchNext ((__m128i*)ps);
+        cachePrefetchNext ((__m128i*)pd);
+        cachePrefetchNext ((__m128i*)pm);
+
+        xmmDstHi = load128Aligned ((__m128i*)pd);
+        xmmSrcHi = load128Unaligned ((__m128i*)ps);
+        xmmMaskHi = load128Unaligned ((__m128i*)pm);
+
+        unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
+        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
+        unpack_128_2x128 (xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
+
+        expandAlpha_2x128 (xmmSrcLo, xmmSrcHi, &xmmAlphaLo, &xmmAlphaHi);
+
+        pixMultiply_2x128 (&xmmMaskLo, &xmmMaskHi, &xmmAlphaLo, &xmmAlphaHi, &xmmMaskLo, &xmmMaskHi);
+
+        negate_2x128 (xmmMaskLo, xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
+
+        pixMultiply_2x128 (&xmmDstLo, &xmmDstHi, &xmmMaskLo, &xmmMaskHi, &xmmDstLo, &xmmDstHi);
+
+        save128Aligned( (__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
+
+        ps += 4;
+        pd += 4;
+        pm += 4;
+        w -= 4;
+    }
+
+    while (w)
+    {
+        s = *ps++;
+        m = *pm++;
+        d = *pd;
+
+        *pd++ = pack_1x64_32 (pixMultiply_1x64 (unpack_32_1x64 (d),
+                                                negate_1x64 (pixMultiply_1x64 (unpack_32_1x64 (m),
+                                                                               expandAlpha_1x64 (unpack_32_1x64 (s))))));
+        w--;
+    }
+}
+
+static inline uint32_t
+coreCombineAtopCPixelsse2 (uint32_t src, uint32_t mask, uint32_t dst)
+{
+    __m64 m = unpack_32_1x64 (mask);
+    __m64 s = unpack_32_1x64 (src);
+    __m64 d = unpack_32_1x64 (dst);
+    __m64 sa = expandAlpha_1x64 (s);
+    __m64 da = expandAlpha_1x64 (d);
+
+    s = pixMultiply_1x64 (s, m);
+    m = negate_1x64 (pixMultiply_1x64 (m, sa));
+
+    return pack_1x64_32 (pixAddMultiply_1x64 (&d, &m, &s, &da));
+}
+
+static inline void
+coreCombineAtopCsse2 (uint32_t *pd, uint32_t *ps, uint32_t *pm, int w)
+{
+    uint32_t s, m, d;
+
+    __m128i xmmSrcLo, xmmSrcHi;
+    __m128i xmmDstLo, xmmDstHi;
+    __m128i xmmAlphaSrcLo, xmmAlphaSrcHi;
+    __m128i xmmAlphaDstLo, xmmAlphaDstHi;
+    __m128i xmmMaskLo, xmmMaskHi;
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+    cachePrefetch ((__m128i*)pm);
+
+    while (w && (unsigned long)pd & 15)
+    {
+        s = *ps++;
+        m = *pm++;
+        d = *pd;
+
+        *pd++ = coreCombineAtopCPixelsse2 (s, m, d);
+        w--;
+    }
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+    cachePrefetch ((__m128i*)pm);
+
+    while (w >= 4)
+    {
+        /* fill cache line with next memory */
+        cachePrefetchNext ((__m128i*)ps);
+        cachePrefetchNext ((__m128i*)pd);
+        cachePrefetchNext ((__m128i*)pm);
+
+        xmmDstHi = load128Aligned ((__m128i*)pd);
+        xmmSrcHi = load128Unaligned ((__m128i*)ps);
+        xmmMaskHi = load128Unaligned ((__m128i*)pm);
+
+        unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
+        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
+        unpack_128_2x128 (xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
+
+        expandAlpha_2x128 (xmmSrcLo, xmmSrcHi, &xmmAlphaSrcLo, &xmmAlphaSrcHi);
+        expandAlpha_2x128 (xmmDstLo, xmmDstHi, &xmmAlphaDstLo, &xmmAlphaDstHi);
+
+        pixMultiply_2x128 (&xmmSrcLo, &xmmSrcHi, &xmmMaskLo, &xmmMaskHi, &xmmSrcLo, &xmmSrcHi);
+        pixMultiply_2x128 (&xmmMaskLo, &xmmMaskHi, &xmmAlphaSrcLo, &xmmAlphaSrcHi, &xmmMaskLo, &xmmMaskHi);
+
+        negate_2x128 (xmmMaskLo, xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
+
+        pixAddMultiply_2x128 (&xmmDstLo, &xmmDstHi, &xmmMaskLo, &xmmMaskHi,
+                              &xmmSrcLo, &xmmSrcHi, &xmmAlphaDstLo, &xmmAlphaDstHi,
+                              &xmmDstLo, &xmmDstHi);
+
+        save128Aligned( (__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
+
+        ps += 4;
+        pd += 4;
+        pm += 4;
+        w -= 4;
+    }
+
+    while (w)
+    {
+        s = *ps++;
+        m = *pm++;
+        d = *pd;
+
+        *pd++ = coreCombineAtopCPixelsse2 (s, m, d);
+        w--;
+    }
+}
+
+static inline uint32_t
+coreCombineReverseAtopCPixelsse2 (uint32_t src, uint32_t mask, uint32_t dst)
+{
+    __m64 m = unpack_32_1x64 (mask);
+    __m64 s = unpack_32_1x64 (src);
+    __m64 d = unpack_32_1x64 (dst);
+
+    __m64 da = negate_1x64 (expandAlpha_1x64 (d));
+    __m64 sa = expandAlpha_1x64 (s);
+
+    s = pixMultiply_1x64 (s, m);
+    m = pixMultiply_1x64 (m, sa);
+
+    return pack_1x64_32 (pixAddMultiply_1x64 (&d, &m, &s, &da));
+}
+
+static inline void
+coreCombineReverseAtopCsse2 (uint32_t *pd, uint32_t *ps, uint32_t *pm, int w)
+{
+    uint32_t s, m, d;
+
+    __m128i xmmSrcLo, xmmSrcHi;
+    __m128i xmmDstLo, xmmDstHi;
+    __m128i xmmAlphaSrcLo, xmmAlphaSrcHi;
+    __m128i xmmAlphaDstLo, xmmAlphaDstHi;
+    __m128i xmmMaskLo, xmmMaskHi;
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+    cachePrefetch ((__m128i*)pm);
+
+    while (w && (unsigned long)pd & 15)
+    {
+        s = *ps++;
+        m = *pm++;
+        d = *pd;
+
+        *pd++ = coreCombineReverseAtopCPixelsse2 (s, m, d);
+        w--;
+    }
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+    cachePrefetch ((__m128i*)pm);
+
+    while (w >= 4)
+    {
+        /* fill cache line with next memory */
+        cachePrefetchNext ((__m128i*)ps);
+        cachePrefetchNext ((__m128i*)pd);
+        cachePrefetchNext ((__m128i*)pm);
+
+        xmmDstHi = load128Aligned ((__m128i*)pd);
+        xmmSrcHi = load128Unaligned ((__m128i*)ps);
+        xmmMaskHi = load128Unaligned ((__m128i*)pm);
+
+        unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
+        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
+        unpack_128_2x128 (xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
+
+        expandAlpha_2x128 (xmmSrcLo, xmmSrcHi, &xmmAlphaSrcLo, &xmmAlphaSrcHi);
+        expandAlpha_2x128 (xmmDstLo, xmmDstHi, &xmmAlphaDstLo, &xmmAlphaDstHi);
+
+        pixMultiply_2x128 (&xmmSrcLo, &xmmSrcHi, &xmmMaskLo, &xmmMaskHi, &xmmSrcLo, &xmmSrcHi);
+        pixMultiply_2x128 (&xmmMaskLo, &xmmMaskHi, &xmmAlphaSrcLo, &xmmAlphaSrcHi, &xmmMaskLo, &xmmMaskHi);
+
+        negate_2x128 (xmmAlphaDstLo, xmmAlphaDstHi, &xmmAlphaDstLo, &xmmAlphaDstHi);
+
+        pixAddMultiply_2x128 (&xmmDstLo, &xmmDstHi, &xmmMaskLo, &xmmMaskHi,
+                              &xmmSrcLo, &xmmSrcHi, &xmmAlphaDstLo, &xmmAlphaDstHi,
+                              &xmmDstLo, &xmmDstHi);
+
+        save128Aligned( (__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
+
+        ps += 4;
+        pd += 4;
+        pm += 4;
+        w -= 4;
+    }
+
+    while (w)
+    {
+        s = *ps++;
+        m = *pm++;
+        d = *pd;
+
+        *pd++ = coreCombineReverseAtopCPixelsse2 (s, m, d);
+        w--;
+    }
+}
+
+static inline uint32_t
+coreCombineXorCPixelsse2 (uint32_t src, uint32_t mask, uint32_t dst)
+{
+    __m64 a = unpack_32_1x64 (mask);
+    __m64 s = unpack_32_1x64 (src);
+    __m64 d = unpack_32_1x64 (dst);
+
+    __m64 alphaDst = negate_1x64 (pixMultiply_1x64 (a, expandAlpha_1x64 (s)));
+    __m64 dest      = pixMultiply_1x64 (s, a);
+    __m64 alphaSrc = negate_1x64 (expandAlpha_1x64 (d));
+
+    return pack_1x64_32 (pixAddMultiply_1x64 (&d,
+                                              &alphaDst,
+                                              &dest,
+                                              &alphaSrc));
+}
+
+static inline void
+coreCombineXorCsse2 (uint32_t *pd, uint32_t *ps, uint32_t *pm, int w)
+{
+    uint32_t s, m, d;
+
+    __m128i xmmSrcLo, xmmSrcHi;
+    __m128i xmmDstLo, xmmDstHi;
+    __m128i xmmAlphaSrcLo, xmmAlphaSrcHi;
+    __m128i xmmAlphaDstLo, xmmAlphaDstHi;
+    __m128i xmmMaskLo, xmmMaskHi;
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+    cachePrefetch ((__m128i*)pm);
+
+    while (w && (unsigned long)pd & 15)
+    {
+        s = *ps++;
+        m = *pm++;
+        d = *pd;
+
+        *pd++ = coreCombineXorCPixelsse2 (s, m, d);
+        w--;
+    }
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+    cachePrefetch ((__m128i*)pm);
+
+    while (w >= 4)
+    {
+        /* fill cache line with next memory */
+        cachePrefetchNext ((__m128i*)ps);
+        cachePrefetchNext ((__m128i*)pd);
+        cachePrefetchNext ((__m128i*)pm);
+
+        xmmDstHi = load128Aligned ((__m128i*)pd);
+        xmmSrcHi = load128Unaligned ((__m128i*)ps);
+        xmmMaskHi = load128Unaligned ((__m128i*)pm);
+
+        unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
+        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
+        unpack_128_2x128 (xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
+
+        expandAlpha_2x128 (xmmSrcLo, xmmSrcHi, &xmmAlphaSrcLo, &xmmAlphaSrcHi);
+        expandAlpha_2x128 (xmmDstLo, xmmDstHi, &xmmAlphaDstLo, &xmmAlphaDstHi);
+
+        pixMultiply_2x128 (&xmmSrcLo, &xmmSrcHi, &xmmMaskLo, &xmmMaskHi, &xmmSrcLo, &xmmSrcHi);
+        pixMultiply_2x128 (&xmmMaskLo, &xmmMaskHi, &xmmAlphaSrcLo, &xmmAlphaSrcHi, &xmmMaskLo, &xmmMaskHi);
+
+        negate_2x128 (xmmAlphaDstLo, xmmAlphaDstHi, &xmmAlphaDstLo, &xmmAlphaDstHi);
+        negate_2x128 (xmmMaskLo, xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
+
+        pixAddMultiply_2x128 (&xmmDstLo, &xmmDstHi, &xmmMaskLo, &xmmMaskHi,
+                              &xmmSrcLo, &xmmSrcHi, &xmmAlphaDstLo, &xmmAlphaDstHi,
+                              &xmmDstLo, &xmmDstHi);
+
+        save128Aligned( (__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
+
+        ps += 4;
+        pd += 4;
+        pm += 4;
+        w -= 4;
+    }
+
+    while (w)
+    {
+        s = *ps++;
+        m = *pm++;
+        d = *pd;
+
+        *pd++ = coreCombineXorCPixelsse2 (s, m, d);
+        w--;
+    }
+}
+
+static inline void
+coreCombineAddCsse2 (uint32_t *pd, uint32_t *ps, uint32_t *pm, int w)
+{
+    uint32_t s, m, d;
+
+    __m128i xmmSrcLo, xmmSrcHi;
+    __m128i xmmDstLo, xmmDstHi;
+    __m128i xmmMaskLo, xmmMaskHi;
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+    cachePrefetch ((__m128i*)pm);
+
+    while (w && (unsigned long)pd & 15)
+    {
+        s = *ps++;
+        m = *pm++;
+        d = *pd;
+
+        *pd++ = pack_1x64_32 (_mm_adds_pu8 (pixMultiply_1x64 (unpack_32_1x64 (s),
+                                                              unpack_32_1x64 (m)),
+                                            unpack_32_1x64 (d)));
+        w--;
+    }
+
+    /* call prefetch hint to optimize cache load*/
+    cachePrefetch ((__m128i*)ps);
+    cachePrefetch ((__m128i*)pd);
+    cachePrefetch ((__m128i*)pm);
+
+    while (w >= 4)
+    {
+        /* fill cache line with next memory */
+        cachePrefetchNext ((__m128i*)ps);
+        cachePrefetchNext ((__m128i*)pd);
+        cachePrefetchNext ((__m128i*)pm);
+
+        xmmSrcHi = load128Unaligned ((__m128i*)ps);
+        xmmMaskHi = load128Unaligned ((__m128i*)pm);
+        xmmDstHi = load128Aligned ((__m128i*)pd);
+
+        unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
+        unpack_128_2x128 (xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
+        unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
+
+        pixMultiply_2x128 (&xmmSrcLo, &xmmSrcHi, &xmmMaskLo, &xmmMaskHi, &xmmSrcLo, &xmmSrcHi);
+
+        save128Aligned( (__m128i*)pd, pack_2x128_128 (_mm_adds_epu8 (xmmSrcLo, xmmDstLo),
+                                                      _mm_adds_epu8 (xmmSrcHi, xmmDstHi)));
+
+        ps += 4;
+        pd += 4;
+        pm += 4;
+        w -= 4;
+    }
+
+    while (w)
+    {
+        s = *ps++;
+        m = *pm++;
+        d = *pd;
+
+        *pd++ = pack_1x64_32 (_mm_adds_pu8 (pixMultiply_1x64 (unpack_32_1x64 (s),
+                                                              unpack_32_1x64 (m)),
+                                            unpack_32_1x64 (d)));
+        w--;
+    }
+}
+
+/* -------------------------------------------------------------------------------------------------
+ * fbComposeSetupSSE2
+ */
+static inline __m64
+createMask_16_64 (uint16_t mask)
+{
+    return _mm_set1_pi16 (mask);
+}
+
+static inline __m128i
+createMask_16_128 (uint16_t mask)
+{
+    return _mm_set1_epi16 (mask);
+}
+
+static inline __m64
+createMask_2x32_64 (uint32_t mask0, uint32_t mask1)
+{
+    return _mm_set_pi32 (mask0, mask1);
+}
+
+static inline __m128i
+createMask_2x32_128 (uint32_t mask0, uint32_t mask1)
+{
+    return _mm_set_epi32 (mask0, mask1, mask0, mask1);
+}
+
+/* SSE2 code patch for fbcompose.c */
+
+static FASTCALL void
+sse2CombineMaskU (uint32_t *dst, const uint32_t *src, int width)
+{
+    coreCombineReverseInUsse2 (dst, src, width);
+    _mm_empty();
+}
+
+static FASTCALL void
+sse2CombineOverU (uint32_t *dst, const uint32_t *src, int width)
+{
+    coreCombineOverUsse2 (dst, src, width);
+    _mm_empty();
+}
+
+static FASTCALL void
+sse2CombineOverReverseU (uint32_t *dst, const uint32_t *src, int width)
+{
+    coreCombineOverReverseUsse2 (dst, src, width);
+    _mm_empty();
+}
+
+static FASTCALL void
+sse2CombineInU (uint32_t *dst, const uint32_t *src, int width)
+{
+    coreCombineInUsse2 (dst, src, width);
+    _mm_empty();
+}
+
+static FASTCALL void
+sse2CombineInReverseU (uint32_t *dst, const uint32_t *src, int width)
+{
+    coreCombineReverseInUsse2 (dst, src, width);
+    _mm_empty();
+}
+
+static FASTCALL void
+sse2CombineOutU (uint32_t *dst, const uint32_t *src, int width)
+{
+    coreCombineOutUsse2 (dst, src, width);
+    _mm_empty();
+}
+
+static FASTCALL void
+sse2CombineOutReverseU (uint32_t *dst, const uint32_t *src, int width)
+{
+    coreCombineReverseOutUsse2 (dst, src, width);
+    _mm_empty();
+}
+
+static FASTCALL void
+sse2CombineAtopU (uint32_t *dst, const uint32_t *src, int width)
+{
+    coreCombineAtopUsse2 (dst, src, width);
+    _mm_empty();
+}
+
+static FASTCALL void
+sse2CombineAtopReverseU (uint32_t *dst, const uint32_t *src, int width)
+{
+    coreCombineReverseAtopUsse2 (dst, src, width);
+    _mm_empty();
+}
+
+static FASTCALL void
+sse2CombineXorU (uint32_t *dst, const uint32_t *src, int width)
+{
+    coreCombineXorUsse2 (dst, src, width);
+    _mm_empty();
+}
+
+static FASTCALL void
+sse2CombineAddU (uint32_t *dst, const uint32_t *src, int width)
+{
+    coreCombineAddUsse2 (dst, src, width);
+    _mm_empty();
+}
+
+static FASTCALL void
+sse2CombineSaturateU (uint32_t *dst, const uint32_t *src, int width)
+{
+    coreCombineSaturateUsse2 (dst, src, width);
+    _mm_empty();
+}
+
+static FASTCALL void
+sse2CombineSrcC (uint32_t *dst, uint32_t *src, uint32_t *mask, int width)
+{
+    coreCombineSrcCsse2 (dst, src, mask, width);
+    _mm_empty();
+}
+
+static FASTCALL void
+sse2CombineOverC (uint32_t *dst, uint32_t *src, uint32_t *mask, int width)
+{
+    coreCombineOverCsse2 (dst, src, mask, width);
+    _mm_empty();
+}
+
+static FASTCALL void
+sse2CombineOverReverseC (uint32_t *dst, uint32_t *src, uint32_t *mask, int width)
+{
+    coreCombineOverReverseCsse2 (dst, src, mask, width);
+    _mm_empty();
+}
+
+static FASTCALL void
+sse2CombineInC (uint32_t *dst, uint32_t *src, uint32_t *mask, int width)
+{
+    coreCombineInCsse2 (dst, src, mask, width);
+    _mm_empty();
+}
+
+static FASTCALL void
+sse2CombineInReverseC (uint32_t *dst, uint32_t *src, uint32_t *mask, int width)
+{
+    coreCombineInReverseCsse2 (dst, src, mask, width);
+    _mm_empty();
+}
+
+static FASTCALL void
+sse2CombineOutC (uint32_t *dst, uint32_t *src, uint32_t *mask, int width)
+{
+    coreCombineOutCsse2 (dst, src, mask, width);
+    _mm_empty();
+}
+
+static FASTCALL void
+sse2CombineOutReverseC (uint32_t *dst, uint32_t *src, uint32_t *mask, int width)
+{
+    coreCombineOutReverseCsse2 (dst, src, mask, width);
+    _mm_empty();
+}
+
+static FASTCALL void
+sse2CombineAtopC (uint32_t *dst, uint32_t *src, uint32_t *mask, int width)
+{
+    coreCombineAtopCsse2 (dst, src, mask, width);
+    _mm_empty();
+}
+
+static FASTCALL void
+sse2CombineAtopReverseC (uint32_t *dst, uint32_t *src, uint32_t *mask, int width)
+{
+    coreCombineReverseAtopCsse2 (dst, src, mask, width);
+    _mm_empty();
+}
+
+static FASTCALL void
+sse2CombineXorC (uint32_t *dst, uint32_t *src, uint32_t *mask, int width)
+{
+    coreCombineXorCsse2 (dst, src, mask, width);
+    _mm_empty();
+}
+
+static FASTCALL void
+sse2CombineAddC (uint32_t *dst, uint32_t *src, uint32_t *mask, int width)
+{
+    coreCombineAddCsse2 (dst, src, mask, width);
+    _mm_empty();
+}
+
+void
+fbComposeSetupSSE2(void)
+{
+    static pixman_bool_t initialized = FALSE;
+
+    if (initialized)
+	return;
+    
+    /* check if we have SSE2 support and initialize accordingly */
+    if (pixman_have_sse2())
+    {
+        /* SSE2 constants */
+        Mask565r  = createMask_2x32_128 (0x00f80000, 0x00f80000);
+        Mask565g1 = createMask_2x32_128 (0x00070000, 0x00070000);
+        Mask565g2 = createMask_2x32_128 (0x000000e0, 0x000000e0);
+        Mask565b  = createMask_2x32_128 (0x0000001f, 0x0000001f);
+        MaskRed   = createMask_2x32_128 (0x00f80000, 0x00f80000);
+        MaskGreen = createMask_2x32_128 (0x0000fc00, 0x0000fc00);
+        MaskBlue  = createMask_2x32_128 (0x000000f8, 0x000000f8);
+
+        Mask0080 = createMask_16_128 (0x0080);
+        Mask00ff = createMask_16_128 (0x00ff);
+        Mask0101 = createMask_16_128 (0x0101);
+        Maskffff = createMask_16_128 (0xffff);
+        Maskff000000 = createMask_2x32_128 (0xff000000, 0xff000000);
+        MaskAlpha = createMask_2x32_128 (0x00ff0000, 0x00000000);
+
+        /* MMX constants */
+        xMask565rgb = createMask_2x32_64 (0x000001f0, 0x003f001f);
+        xMask565Unpack = createMask_2x32_64 (0x00000084, 0x04100840);
+
+        xMask0080 = createMask_16_64 (0x0080);
+        xMask00ff = createMask_16_64 (0x00ff);
+        xMask0101 = createMask_16_64 (0x0101);
+        xMaskAlpha = createMask_2x32_64 (0x00ff0000, 0x00000000);
+
+        /* SSE code patch for fbcompose.c */
+        pixman_composeFunctions.combineU[PIXMAN_OP_OVER] = sse2CombineOverU;
+        pixman_composeFunctions.combineU[PIXMAN_OP_OVER_REVERSE] = sse2CombineOverReverseU;
+        pixman_composeFunctions.combineU[PIXMAN_OP_IN] = sse2CombineInU;
+        pixman_composeFunctions.combineU[PIXMAN_OP_IN_REVERSE] = sse2CombineInReverseU;
+        pixman_composeFunctions.combineU[PIXMAN_OP_OUT] = sse2CombineOutU;
+
+        pixman_composeFunctions.combineU[PIXMAN_OP_OUT_REVERSE] = sse2CombineOutReverseU;
+        pixman_composeFunctions.combineU[PIXMAN_OP_ATOP] = sse2CombineAtopU;
+        pixman_composeFunctions.combineU[PIXMAN_OP_ATOP_REVERSE] = sse2CombineAtopReverseU;
+        pixman_composeFunctions.combineU[PIXMAN_OP_XOR] = sse2CombineXorU;
+        pixman_composeFunctions.combineU[PIXMAN_OP_ADD] = sse2CombineAddU;
+
+        pixman_composeFunctions.combineU[PIXMAN_OP_SATURATE] = sse2CombineSaturateU;
+
+        pixman_composeFunctions.combineC[PIXMAN_OP_SRC] = sse2CombineSrcC;
+        pixman_composeFunctions.combineC[PIXMAN_OP_OVER] = sse2CombineOverC;
+        pixman_composeFunctions.combineC[PIXMAN_OP_OVER_REVERSE] = sse2CombineOverReverseC;
+        pixman_composeFunctions.combineC[PIXMAN_OP_IN] = sse2CombineInC;
+        pixman_composeFunctions.combineC[PIXMAN_OP_IN_REVERSE] = sse2CombineInReverseC;
+        pixman_composeFunctions.combineC[PIXMAN_OP_OUT] = sse2CombineOutC;
+        pixman_composeFunctions.combineC[PIXMAN_OP_OUT_REVERSE] = sse2CombineOutReverseC;
+        pixman_composeFunctions.combineC[PIXMAN_OP_ATOP] = sse2CombineAtopC;
+        pixman_composeFunctions.combineC[PIXMAN_OP_ATOP_REVERSE] = sse2CombineAtopReverseC;
+        pixman_composeFunctions.combineC[PIXMAN_OP_XOR] = sse2CombineXorC;
+        pixman_composeFunctions.combineC[PIXMAN_OP_ADD] = sse2CombineAddC;
+
+        pixman_composeFunctions.combineMaskU = sse2CombineMaskU;
+    }
+
+    initialized = TRUE;
+
+    _mm_empty();
+}
+
+
+/* -------------------------------------------------------------------------------------------------
+ * fbCompositeSolid_nx8888
+ */
+
+void
+fbCompositeSolid_nx8888sse2 (pixman_op_t op,
+			    pixman_image_t * pSrc,
+			    pixman_image_t * pMask,
+			    pixman_image_t * pDst,
+			    int16_t	xSrc,
+			    int16_t	ySrc,
+			    int16_t	xMask,
+			    int16_t	yMask,
+			    int16_t	xDst,
+			    int16_t	yDst,
+			    uint16_t	width,
+			    uint16_t	height)
+{
+    uint32_t	src;
+    uint32_t	*dstLine, *dst, d;
+    uint16_t	w;
+    int	dstStride;
+    __m128i xmmSrc, xmmAlpha;
+    __m128i xmmDst, xmmDstLo, xmmDstHi;
+
+    fbComposeGetSolid(pSrc, src, pDst->bits.format);
+
+    if (src >> 24 == 0)
+	return;
+
+    fbComposeGetStart (pDst, xDst, yDst, uint32_t, dstStride, dstLine, 1);
+
+    xmmSrc = expandPixel_32_1x128 (src);
+    xmmAlpha = expandAlpha_1x128 (xmmSrc);
+
+    while (height--)
+    {
+        dst = dstLine;
+
+        /* call prefetch hint to optimize cache load*/
+        cachePrefetch ((__m128i*)dst);
+
+        dstLine += dstStride;
+        w = width;
+
+        while (w && (unsigned long)dst & 15)
+        {
+            d = *dst;
+            *dst++ = pack_1x64_32 (over_1x64 (_mm_movepi64_pi64 (xmmSrc),
+                                              _mm_movepi64_pi64 (xmmAlpha),
+                                              unpack_32_1x64 (d)));
+            w--;
+        }
+
+        cachePrefetch ((__m128i*)dst);
+
+        while (w >= 4)
+        {
+            /* fill cache line with next memory */
+            cachePrefetchNext ((__m128i*)dst);
+
+            xmmDst = load128Aligned ((__m128i*)dst);
+
+            unpack_128_2x128 (xmmDst, &xmmDstLo, &xmmDstHi);
+
+            over_2x128 (&xmmSrc, &xmmSrc, &xmmAlpha, &xmmAlpha, &xmmDstLo, &xmmDstHi);
+
+            /* rebuid the 4 pixel data and save*/
+            save128Aligned ((__m128i*)dst, pack_2x128_128 (xmmDstLo, xmmDstHi));
+
+            w -= 4;
+            dst += 4;
+        }
+
+        while (w)
+        {
+            d = *dst;
+            *dst++ = pack_1x64_32 (over_1x64 (_mm_movepi64_pi64 (xmmSrc),
+                                              _mm_movepi64_pi64 (xmmAlpha),
+                                              unpack_32_1x64 (d)));
+            w--;
+        }
+
+    }
+    _mm_empty();
+}
+
+/* -------------------------------------------------------------------------------------------------
+ * fbCompositeSolid_nx0565
+ */
+void
+fbCompositeSolid_nx0565sse2 (pixman_op_t op,
+			    pixman_image_t * pSrc,
+			    pixman_image_t * pMask,
+			    pixman_image_t * pDst,
+			    int16_t	xSrc,
+			    int16_t	ySrc,
+			    int16_t	xMask,
+			    int16_t	yMask,
+			    int16_t	xDst,
+			    int16_t	yDst,
+			    uint16_t	width,
+			    uint16_t	height)
+{
+    uint32_t	src;
+    uint16_t	*dstLine, *dst, d;
+    uint16_t	w;
+    int	        dstStride;
+    __m128i xmmSrc, xmmAlpha;
+    __m128i xmmDst, xmmDst0, xmmDst1, xmmDst2, xmmDst3;
+
+    fbComposeGetSolid(pSrc, src, pDst->bits.format);
+
+    if (src >> 24 == 0)
+        return;
+
+    fbComposeGetStart (pDst, xDst, yDst, uint16_t, dstStride, dstLine, 1);
+
+    xmmSrc = expandPixel_32_1x128 (src);
+    xmmAlpha = expandAlpha_1x128 (xmmSrc);
+
+    while (height--)
+    {
+        dst = dstLine;
+
+        /* call prefetch hint to optimize cache load*/
+        cachePrefetch ((__m128i*)dst);
+
+        dstLine += dstStride;
+        w = width;
+
+        while (w && (unsigned long)dst & 15)
+        {
+            d = *dst;
+            *dst++ = pack565_32_16 (pack_1x64_32 (over_1x64 (_mm_movepi64_pi64 (xmmSrc),
+                                                             _mm_movepi64_pi64 (xmmAlpha),
+                                                             expand565_16_1x64 (d))));
+            w--;
+        }
+
+        /* call prefetch hint to optimize cache load*/
+        cachePrefetch ((__m128i*)dst);
+
+        while (w >= 8)
+        {
+            /* fill cache line with next memory */
+            cachePrefetchNext ((__m128i*)dst);
+
+            xmmDst = load128Aligned ((__m128i*)dst);
+
+            unpack565_128_4x128 (xmmDst, &xmmDst0, &xmmDst1, &xmmDst2, &xmmDst3);
+
+            over_2x128 (&xmmSrc, &xmmSrc, &xmmAlpha, &xmmAlpha, &xmmDst0, &xmmDst1);
+            over_2x128 (&xmmSrc, &xmmSrc, &xmmAlpha, &xmmAlpha, &xmmDst2, &xmmDst3);
+
+            xmmDst = pack565_4x128_128 (&xmmDst0, &xmmDst1, &xmmDst2, &xmmDst3);
+
+            save128Aligned ((__m128i*)dst, xmmDst);
+
+            dst += 8;
+            w -= 8;
+        }
+
+        while (w--)
+        {
+            d = *dst;
+            *dst++ = pack565_32_16 (pack_1x64_32 (over_1x64 (_mm_movepi64_pi64 (xmmSrc),
+                                                             _mm_movepi64_pi64 (xmmAlpha),
+                                                             expand565_16_1x64 (d))));
+        }
+    }
+
+    _mm_empty();
+}
+
+/* -------------------------------------------------------------------------------------------------
+ * fbCompositeSolidMask_nx8888x8888C
+ */
+
+void
+fbCompositeSolidMask_nx8888x8888Csse2 (pixman_op_t op,
+				      pixman_image_t * pSrc,
+				      pixman_image_t * pMask,
+				      pixman_image_t * pDst,
+				      int16_t	xSrc,
+				      int16_t	ySrc,
+				      int16_t	xMask,
+				      int16_t	yMask,
+				      int16_t	xDst,
+				      int16_t	yDst,
+				      uint16_t	width,
+				      uint16_t	height)
+{
+    uint32_t	src, srca;
+    uint32_t	*dstLine, d;
+    uint32_t	*maskLine, m;
+    uint32_t    packCmp;
+    int	dstStride, maskStride;
+
+    __m128i xmmSrc, xmmAlpha;
+    __m128i xmmDst, xmmDstLo, xmmDstHi;
+    __m128i xmmMask, xmmMaskLo, xmmMaskHi;
+
+    __m64 mmxSrc, mmxAlpha, mmxMask, mmxDst;
+
+    fbComposeGetSolid(pSrc, src, pDst->bits.format);
+
+    srca = src >> 24;
+    if (srca == 0)
+	return;
+
+    fbComposeGetStart (pDst, xDst, yDst, uint32_t, dstStride, dstLine, 1);
+    fbComposeGetStart (pMask, xMask, yMask, uint32_t, maskStride, maskLine, 1);
+
+    xmmSrc = _mm_unpacklo_epi8 (createMask_2x32_128 (src, src), _mm_setzero_si128 ());
+    xmmAlpha = expandAlpha_1x128 (xmmSrc);
+    mmxSrc   = _mm_movepi64_pi64 (xmmSrc);
+    mmxAlpha = _mm_movepi64_pi64 (xmmAlpha);
+
+    while (height--)
+    {
+        int w = width;
+        uint32_t *pm = (uint32_t *)maskLine;
+        uint32_t *pd = (uint32_t *)dstLine;
+
+        dstLine += dstStride;
+        maskLine += maskStride;
+
+        /* call prefetch hint to optimize cache load*/
+        cachePrefetch ((__m128i*)pd);
+        cachePrefetch ((__m128i*)pm);
+
+        while (w && (unsigned long)pd & 15)
+        {
+            m = *pm++;
+
+            if (m)
+            {
+                d = *pd;
+                mmxMask = unpack_32_1x64 (m);
+                mmxDst = unpack_32_1x64 (d);
+
+                *pd = pack_1x64_32 (inOver_1x64 (&mmxSrc,
+                                                 &mmxAlpha,
+                                                 &mmxMask,
+                                                 &mmxDst));
+            }
+
+            pd++;
+            w--;
+        }
+
+        /* call prefetch hint to optimize cache load*/
+        cachePrefetch ((__m128i*)pd);
+        cachePrefetch ((__m128i*)pm);
+
+        while (w >= 4)
+        {
+            /* fill cache line with next memory */
+            cachePrefetchNext ((__m128i*)pd);
+            cachePrefetchNext ((__m128i*)pm);
+
+            xmmMask = load128Unaligned ((__m128i*)pm);
+
+            packCmp = _mm_movemask_epi8 (_mm_cmpeq_epi32 (xmmMask, _mm_setzero_si128()));
+
+            /* if all bits in mask are zero, packCmp are equal to 0xffff */
+            if (packCmp != 0xffff)
+            {
+                xmmDst = load128Aligned ((__m128i*)pd);
+
+                unpack_128_2x128 (xmmMask, &xmmMaskLo, &xmmMaskHi);
+                unpack_128_2x128 (xmmDst, &xmmDstLo, &xmmDstHi);
+
+                inOver_2x128 (&xmmSrc, &xmmSrc, &xmmAlpha, &xmmAlpha, &xmmMaskLo, &xmmMaskHi, &xmmDstLo, &xmmDstHi);
+
+                save128Aligned ((__m128i*)pd, pack_2x128_128 (xmmDstLo, xmmDstHi));
+            }
+
+            pd += 4;
+            pm += 4;
+            w -= 4;
+        }
+
+        while (w)
+        {
+            m = *pm++;
+
+            if (m)
+            {
+                d = *pd;
+                mmxMask = unpack_32_1x64 (m);
+                mmxDst = unpack_32_1x64 (d);
+
+                *pd = pack_1x64_32 (inOver_1x64 (&mmxSrc,
+                                                 &mmxAlpha,
+                                                 &mmxMask,
+                                                 &mmxDst));
+            }
+
+            pd++;
+            w--;
+        }
+    }
+
+    _mm_empty();
+}
+
+
+/* -------------------------------------------------------------------------------------------------
+ * fbCompositeSrc_8888x8x8888
+ */
+
+void
+fbCompositeSrc_8888x8x8888sse2 (pixman_op_t op,
+			       pixman_image_t * pSrc,
+			       pixman_image_t * pMask,
+			       pixman_image_t * pDst,
+			       int16_t	xSrc,
+			       int16_t	ySrc,
+			       int16_t      xMask,
+			       int16_t      yMask,
+			       int16_t      xDst,
+			       int16_t      yDst,
+			       uint16_t     width,
+			       uint16_t     height)
+{
+    uint32_t	*dstLine, *dst;
+    uint32_t	*srcLine, *src;
+    uint32_t	mask;
+    uint16_t	w;
+    int	dstStride, srcStride;
+
+    __m128i xmmMask;
+    __m128i xmmSrc, xmmSrcLo, xmmSrcHi;
+    __m128i xmmDst, xmmDstLo, xmmDstHi;
+    __m128i xmmAlphaLo, xmmAlphaHi;
+
+    fbComposeGetStart (pDst, xDst, yDst, uint32_t, dstStride, dstLine, 1);
+    fbComposeGetStart (pSrc, xSrc, ySrc, uint32_t, srcStride, srcLine, 1);
+    fbComposeGetSolid (pMask, mask, pDst->bits.format);
+
+    xmmMask = createMask_16_128 (mask >> 24);
+
+    while (height--)
+    {
+        dst = dstLine;
+        dstLine += dstStride;
+        src = srcLine;
+        srcLine += srcStride;
+        w = width;
+
+        /* call prefetch hint to optimize cache load*/
+        cachePrefetch ((__m128i*)dst);
+        cachePrefetch ((__m128i*)src);
+
+        while (w && (unsigned long)dst & 15)
+        {
+            uint32_t s = *src++;
+            uint32_t d = *dst;
+
+            __m64 ms = unpack_32_1x64 (s);
+            __m64 alpha    = expandAlpha_1x64 (ms);
+            __m64 dest     = _mm_movepi64_pi64 (xmmMask);
+            __m64 alphaDst = unpack_32_1x64 (d);
+
+            *dst++ = pack_1x64_32 (inOver_1x64 (&ms,
+                                                &alpha,
+                                                &dest,
+                                                &alphaDst));
+
+            w--;
+        }
+
+        /* call prefetch hint to optimize cache load*/
+        cachePrefetch ((__m128i*)dst);
+        cachePrefetch ((__m128i*)src);
+
+        while (w >= 4)
+        {
+            /* fill cache line with next memory */
+            cachePrefetchNext ((__m128i*)dst);
+            cachePrefetchNext ((__m128i*)src);
+
+            xmmSrc = load128Unaligned ((__m128i*)src);
+            xmmDst = load128Aligned ((__m128i*)dst);
+
+            unpack_128_2x128 (xmmSrc, &xmmSrcLo, &xmmSrcHi);
+            unpack_128_2x128 (xmmDst, &xmmDstLo, &xmmDstHi);
+            expandAlpha_2x128 (xmmSrcLo, xmmSrcHi, &xmmAlphaLo, &xmmAlphaHi);
+
+            inOver_2x128 (&xmmSrcLo, &xmmSrcHi, &xmmAlphaLo, &xmmAlphaHi, &xmmMask, &xmmMask, &xmmDstLo, &xmmDstHi);
+
+            save128Aligned( (__m128i*)dst, pack_2x128_128 (xmmDstLo, xmmDstHi));
+
+            dst += 4;
+            src += 4;
+            w -= 4;
+        }
+
+        while (w)
+        {
+            uint32_t s = *src++;
+            uint32_t d = *dst;
+
+            __m64 ms = unpack_32_1x64 (s);
+            __m64 alpha = expandAlpha_1x64 (ms);
+            __m64 mask  = _mm_movepi64_pi64 (xmmMask);
+            __m64 dest  = unpack_32_1x64 (d);
+
+            *dst++ = pack_1x64_32 (inOver_1x64 (&ms,
+                                                &alpha,
+                                                &mask,
+                                                &dest));
+
+            w--;
+        }
+    }
+
+    _mm_empty();
+}
+
+/* -------------------------------------------------------------------------------------------------
+ * fbCompositeSrc_x888xnx8888
+ */
+void
+fbCompositeSrc_x888xnx8888sse2 (pixman_op_t op,
+			       pixman_image_t * pSrc,
+			       pixman_image_t * pMask,
+			       pixman_image_t * pDst,
+			       int16_t	xSrc,
+			       int16_t	ySrc,
+			       int16_t      xMask,
+			       int16_t      yMask,
+			       int16_t      xDst,
+			       int16_t      yDst,
+			       uint16_t     width,
+			       uint16_t     height)
+{
+    uint32_t	*dstLine, *dst;
+    uint32_t	*srcLine, *src;
+    uint32_t	mask;
+    int	dstStride, srcStride;
+    uint16_t	w;
+
+    __m128i xmmMask, xmmAlpha;
+    __m128i xmmSrc, xmmSrcLo, xmmSrcHi;
+    __m128i xmmDst, xmmDstLo, xmmDstHi;
+
+    fbComposeGetStart (pDst, xDst, yDst, uint32_t, dstStride, dstLine, 1);
+    fbComposeGetStart (pSrc, xSrc, ySrc, uint32_t, srcStride, srcLine, 1);
+    fbComposeGetSolid (pMask, mask, pDst->bits.format);
+
+    xmmMask = createMask_16_128 (mask >> 24);
+    xmmAlpha = Mask00ff;
+
+    while (height--)
+    {
+        dst = dstLine;
+        dstLine += dstStride;
+        src = srcLine;
+        srcLine += srcStride;
+        w = width;
+
+        /* call prefetch hint to optimize cache load*/
+        cachePrefetch ((__m128i*)dst);
+        cachePrefetch ((__m128i*)src);
+
+        while (w && (unsigned long)dst & 15)
+        {
+            uint32_t s = (*src++) | 0xff000000;
+            uint32_t d = *dst;
+
+            __m64 src   = unpack_32_1x64 (s);
+            __m64 alpha = _mm_movepi64_pi64 (xmmAlpha);
+            __m64 mask  = _mm_movepi64_pi64 (xmmMask);
+            __m64 dest  = unpack_32_1x64 (d);
+
+            *dst++ = pack_1x64_32 (inOver_1x64 (&src,
+                                                &alpha,
+                                                &mask,
+                                                &dest));
+
+            w--;
+        }
+
+        /* call prefetch hint to optimize cache load*/
+        cachePrefetch ((__m128i*)dst);
+        cachePrefetch ((__m128i*)src);
+
+        while (w >= 4)
+        {
+            /* fill cache line with next memory */
+            cachePrefetchNext ((__m128i*)dst);
+            cachePrefetchNext ((__m128i*)src);
+
+            xmmSrc = _mm_or_si128 (load128Unaligned ((__m128i*)src), Maskff000000);
+            xmmDst = load128Aligned ((__m128i*)dst);
+
+            unpack_128_2x128 (xmmSrc, &xmmSrcLo, &xmmSrcHi);
+            unpack_128_2x128 (xmmDst, &xmmDstLo, &xmmDstHi);
+
+            inOver_2x128 (&xmmSrcLo, &xmmSrcHi, &xmmAlpha, &xmmAlpha, &xmmMask, &xmmMask, &xmmDstLo, &xmmDstHi);
+
+            save128Aligned( (__m128i*)dst, pack_2x128_128 (xmmDstLo, xmmDstHi));
+
+            dst += 4;
+            src += 4;
+            w -= 4;
+
+        }
+
+        while (w)
+        {
+            uint32_t s = (*src++) | 0xff000000;
+            uint32_t d = *dst;
+
+            __m64 src  = unpack_32_1x64 (s);
+            __m64 alpha = _mm_movepi64_pi64 (xmmAlpha);
+            __m64 mask  = _mm_movepi64_pi64 (xmmMask);
+            __m64 dest  = unpack_32_1x64 (d);
+
+            *dst++ = pack_1x64_32 (inOver_1x64 (&src,
+                                                &alpha,
+                                                &mask,
+                                                &dest));
+
+            w--;
+        }
+    }
+
+    _mm_empty();
+}
+
+/* -------------------------------------------------------------------------------------------------
+ * fbCompositeSrc_8888x8888
+ */
+void
+fbCompositeSrc_8888x8888sse2 (pixman_op_t op,
+			     pixman_image_t * pSrc,
+			     pixman_image_t * pMask,
+			     pixman_image_t * pDst,
+			     int16_t	xSrc,
+			     int16_t	ySrc,
+			     int16_t      xMask,
+			     int16_t      yMask,
+			     int16_t      xDst,
+			     int16_t      yDst,
+			     uint16_t     width,
+			     uint16_t     height)
+{
+    int	        dstStride, srcStride;
+    uint32_t	*dstLine, *dst;
+    uint32_t	*srcLine, *src;
+
+    fbComposeGetStart (pDst, xDst, yDst, uint32_t, dstStride, dstLine, 1);
+    fbComposeGetStart (pSrc, xSrc, ySrc, uint32_t, srcStride, srcLine, 1);
+
+    dst = dstLine;
+    src = srcLine;
+
+    while (height--)
+    {
+        coreCombineOverUsse2 (dst, src, width);
+
+        dst += dstStride;
+        src += srcStride;
+    }
+    _mm_empty();
+}
+
+/* -------------------------------------------------------------------------------------------------
+ * fbCompositeSrc_8888x0565
+ */
+static inline uint16_t
+fbCompositeSrc_8888x0565pixel (uint32_t src, uint16_t dst)
+{
+    __m64       ms;
+
+    ms = unpack_32_1x64 (src);
+    return pack565_32_16( pack_1x64_32 (over_1x64 (ms,
+                                                   expandAlpha_1x64 (ms),
+                                                   expand565_16_1x64 (dst))));
+}
+
+void
+fbCompositeSrc_8888x0565sse2 (pixman_op_t op,
+			     pixman_image_t * pSrc,
+			     pixman_image_t * pMask,
+			     pixman_image_t * pDst,
+			     int16_t      xSrc,
+			     int16_t      ySrc,
+			     int16_t      xMask,
+			     int16_t      yMask,
+			     int16_t      xDst,
+			     int16_t      yDst,
+			     uint16_t     width,
+			     uint16_t     height)
+{
+    uint16_t	*dstLine, *dst, d;
+    uint32_t	*srcLine, *src, s;
+    int	dstStride, srcStride;
+    uint16_t	w;
+
+    __m128i xmmAlphaLo, xmmAlphaHi;
+    __m128i xmmSrc, xmmSrcLo, xmmSrcHi;
+    __m128i xmmDst, xmmDst0, xmmDst1, xmmDst2, xmmDst3;
+
+    fbComposeGetStart (pDst, xDst, yDst, uint16_t, dstStride, dstLine, 1);
+    fbComposeGetStart (pSrc, xSrc, ySrc, uint32_t, srcStride, srcLine, 1);
+
+#if 0
+    /* FIXME
+     *
+     * I copy the code from MMX one and keep the fixme.
+     * If it's a problem there, probably is a problem here.
+     */
+    assert (pSrc->pDrawable == pMask->pDrawable);
+#endif
+
+    while (height--)
+    {
+        dst = dstLine;
+        src = srcLine;
+
+        /* call prefetch hint to optimize cache load*/
+        cachePrefetch ((__m128i*)src);
+        cachePrefetch ((__m128i*)dst);
+
+        dstLine += dstStride;
+        srcLine += srcStride;
+        w = width;
+
+        /* Align dst on a 16-byte boundary */
+        while (w &&
+               ((unsigned long)dst & 15))
+        {
+            s = *src++;
+            d = *dst;
+
+            *dst++ = fbCompositeSrc_8888x0565pixel (s, d);
+            w--;
+        }
+
+        /* call prefetch hint to optimize cache load*/
+        cachePrefetch ((__m128i*)src);
+        cachePrefetch ((__m128i*)dst);
+
+        /* It's a 8 pixel loop */
+        while (w >= 8)
+        {
+            /* fill cache line with next memory */
+            cachePrefetchNext ((__m128i*)src);
+            cachePrefetchNext ((__m128i*)dst);
+
+            /* I'm loading unaligned because I'm not sure about the address alignment. */
+            xmmSrc = load128Unaligned ((__m128i*) src);
+            xmmDst = load128Aligned ((__m128i*) dst);
+
+            /* Unpacking */
+            unpack_128_2x128 (xmmSrc, &xmmSrcLo, &xmmSrcHi);
+            unpack565_128_4x128 (xmmDst, &xmmDst0, &xmmDst1, &xmmDst2, &xmmDst3);
+            expandAlpha_2x128 (xmmSrcLo, xmmSrcHi, &xmmAlphaLo, &xmmAlphaHi);
+
+            /* I'm loading next 4 pixels from memory before to optimze the memory read. */
+            xmmSrc = load128Unaligned ((__m128i*) (src+4));
+
+            over_2x128 (&xmmSrcLo, &xmmSrcHi, &xmmAlphaLo, &xmmAlphaHi, &xmmDst0, &xmmDst1);
+
+            /* Unpacking */
+            unpack_128_2x128 (xmmSrc, &xmmSrcLo, &xmmSrcHi);
+            expandAlpha_2x128 (xmmSrcLo, xmmSrcHi, &xmmAlphaLo, &xmmAlphaHi);
+
+            over_2x128 (&xmmSrcLo, &xmmSrcHi, &xmmAlphaLo, &xmmAlphaHi, &xmmDst2, &xmmDst3);
+
+            save128Aligned ((__m128i*)dst, pack565_4x128_128 (&xmmDst0, &xmmDst1, &xmmDst2, &xmmDst3));
+
+            w -= 8;
+            dst += 8;
+            src += 8;
+        }
+
+        while (w--)
+        {
+            s = *src++;
+            d = *dst;
+
+            *dst++ = fbCompositeSrc_8888x0565pixel (s, d);
+        }
+    }
+
+    _mm_empty();
+}
+
+/* -------------------------------------------------------------------------------------------------
+ * fbCompositeSolidMask_nx8x8888
+ */
+
+void
+fbCompositeSolidMask_nx8x8888sse2 (pixman_op_t op,
+				  pixman_image_t * pSrc,
+				  pixman_image_t * pMask,
+				  pixman_image_t * pDst,
+				  int16_t      xSrc,
+				  int16_t      ySrc,
+				  int16_t      xMask,
+				  int16_t      yMask,
+				  int16_t      xDst,
+				  int16_t      yDst,
+				  uint16_t     width,
+				  uint16_t     height)
+{
+    uint32_t	src, srca;
+    uint32_t	*dstLine, *dst;
+    uint8_t	*maskLine, *mask;
+    int	dstStride, maskStride;
+    uint16_t	w;
+    uint32_t m, d;
+
+    __m128i xmmSrc, xmmAlpha, xmmDef;
+    __m128i xmmDst, xmmDstLo, xmmDstHi;
+    __m128i xmmMask, xmmMaskLo, xmmMaskHi;
+
+    __m64 mmxSrc, mmxAlpha, mmxMask, mmxDest;
+
+    fbComposeGetSolid(pSrc, src, pDst->bits.format);
+
+    srca = src >> 24;
+    if (srca == 0)
+	return;
+
+    fbComposeGetStart (pDst, xDst, yDst, uint32_t, dstStride, dstLine, 1);
+    fbComposeGetStart (pMask, xMask, yMask, uint8_t, maskStride, maskLine, 1);
+
+    xmmDef = createMask_2x32_128 (src, src);
+    xmmSrc = expandPixel_32_1x128 (src);
+    xmmAlpha = expandAlpha_1x128 (xmmSrc);
+    mmxSrc   = _mm_movepi64_pi64 (xmmSrc);
+    mmxAlpha = _mm_movepi64_pi64 (xmmAlpha);
+
+    while (height--)
+    {
+        dst = dstLine;
+        dstLine += dstStride;
+        mask = maskLine;
+        maskLine += maskStride;
+        w = width;
+
+        /* call prefetch hint to optimize cache load*/
+        cachePrefetch ((__m128i*)mask);
+        cachePrefetch ((__m128i*)dst);
+
+        while (w && (unsigned long)dst & 15)
+        {
+            uint8_t m = *mask++;
+
+            if (m)
+            {
+                d = *dst;
+                mmxMask = expandPixel_8_1x64 (m);
+                mmxDest = unpack_32_1x64 (d);
+
+                *dst = pack_1x64_32 (inOver_1x64 (&mmxSrc,
+                                                  &mmxAlpha,
+                                                  &mmxMask,
+                                                  &mmxDest));
+            }
+
+            w--;
+            dst++;
+        }
+
+        /* call prefetch hint to optimize cache load*/
+        cachePrefetch ((__m128i*)mask);
+        cachePrefetch ((__m128i*)dst);
+
+        while (w >= 4)
+        {
+            /* fill cache line with next memory */
+            cachePrefetchNext ((__m128i*)mask);
+            cachePrefetchNext ((__m128i*)dst);
+
+            m = *((uint32_t*)mask);
+
+            if (srca == 0xff && m == 0xffffffff)
+            {
+                save128Aligned ((__m128i*)dst, xmmDef);
+            }
+            else if (m)
+            {
+                xmmDst = load128Aligned ((__m128i*) dst);
+                xmmMask = unpack_32_1x128 (m);
+                xmmMask = _mm_unpacklo_epi8 (xmmMask, _mm_setzero_si128());
+
+                /* Unpacking */
+                unpack_128_2x128 (xmmDst, &xmmDstLo, &xmmDstHi);
+                unpack_128_2x128 (xmmMask, &xmmMaskLo, &xmmMaskHi);
+
+                expandAlphaRev_2x128 (xmmMaskLo, xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
+
+                inOver_2x128 (&xmmSrc, &xmmSrc, &xmmAlpha, &xmmAlpha, &xmmMaskLo, &xmmMaskHi, &xmmDstLo, &xmmDstHi);
+
+                save128Aligned ((__m128i*)dst, pack_2x128_128 (xmmDstLo, xmmDstHi));
+            }
+
+            w -= 4;
+            dst += 4;
+            mask += 4;
+        }
+
+        while (w)
+        {
+            uint8_t m = *mask++;
+
+            if (m)
+            {
+                d = *dst;
+                mmxMask = expandPixel_8_1x64 (m);
+                mmxDest = unpack_32_1x64 (d);
+
+                *dst = pack_1x64_32 (inOver_1x64 (&mmxSrc,
+                                                  &mmxAlpha,
+                                                  &mmxMask,
+                                                  &mmxDest));
+            }
+
+            w--;
+            dst++;
+        }
+    }
+
+    _mm_empty();
+}
+
+/* -------------------------------------------------------------------------------------------------
+ * fbCompositeSolidMask_nx8x8888
+ */
+
+pixman_bool_t
+pixmanFillsse2 (uint32_t *bits,
+		 int stride,
+		 int bpp,
+		 int x,
+		 int y,
+		 int width,
+		 int height,
+		 uint32_t data)
+{
+    uint32_t	byte_width;
+    uint8_t	    *byte_line;
+
+    __m128i xmmDef;
+
+    if (bpp == 16 && (data >> 16 != (data & 0xffff)))
+	return FALSE;
+
+    if (bpp != 16 && bpp != 32)
+	return FALSE;
+
+    if (bpp == 16)
+    {
+        stride = stride * (int) sizeof (uint32_t) / 2;
+        byte_line = (uint8_t *)(((uint16_t *)bits) + stride * y + x);
+        byte_width = 2 * width;
+        stride *= 2;
+    }
+    else
+    {
+        stride = stride * (int) sizeof (uint32_t) / 4;
+        byte_line = (uint8_t *)(((uint32_t *)bits) + stride * y + x);
+        byte_width = 4 * width;
+        stride *= 4;
+    }
+
+    cachePrefetch ((__m128i*)byte_line);
+    xmmDef = createMask_2x32_128 (data, data);
+
+    while (height--)
+    {
+        int w;
+        uint8_t *d = byte_line;
+        byte_line += stride;
+        w = byte_width;
+
+
+        cachePrefetchNext ((__m128i*)d);
+
+        while (w >= 2 && ((unsigned long)d & 3))
+        {
+            *(uint16_t *)d = data;
+            w -= 2;
+            d += 2;
+        }
+
+        while (w >= 4 && ((unsigned long)d & 15))
+        {
+            *(uint32_t *)d = data;
+
+            w -= 4;
+            d += 4;
+        }
+
+        cachePrefetchNext ((__m128i*)d);
+
+        while (w >= 128)
+        {
+            cachePrefetch (((__m128i*)d) + 12);
+
+            save128Aligned ((__m128i*)(d),     xmmDef);
+            save128Aligned ((__m128i*)(d+16),  xmmDef);
+            save128Aligned ((__m128i*)(d+32),  xmmDef);
+            save128Aligned ((__m128i*)(d+48),  xmmDef);
+            save128Aligned ((__m128i*)(d+64),  xmmDef);
+            save128Aligned ((__m128i*)(d+80),  xmmDef);
+            save128Aligned ((__m128i*)(d+96),  xmmDef);
+            save128Aligned ((__m128i*)(d+112), xmmDef);
+
+            d += 128;
+            w -= 128;
+        }
+
+        if (w >= 64)
+        {
+            cachePrefetch (((__m128i*)d) + 8);
+
+            save128Aligned ((__m128i*)(d),     xmmDef);
+            save128Aligned ((__m128i*)(d+16),  xmmDef);
+            save128Aligned ((__m128i*)(d+32),  xmmDef);
+            save128Aligned ((__m128i*)(d+48),  xmmDef);
+
+            d += 64;
+            w -= 64;
+        }
+
+        cachePrefetchNext ((__m128i*)d);
+
+        if (w >= 32)
+        {
+            save128Aligned ((__m128i*)(d),     xmmDef);
+            save128Aligned ((__m128i*)(d+16),  xmmDef);
+
+            d += 32;
+            w -= 32;
+        }
+
+        if (w >= 16)
+        {
+            save128Aligned ((__m128i*)(d),     xmmDef);
+
+            d += 16;
+            w -= 16;
+        }
+
+        cachePrefetchNext ((__m128i*)d);
+
+        while (w >= 4)
+        {
+            *(uint32_t *)d = data;
+
+            w -= 4;
+            d += 4;
+        }
+
+        if (w >= 2)
+        {
+            *(uint16_t *)d = data;
+            w -= 2;
+            d += 2;
+        }
+    }
+
+    _mm_empty();
+    return TRUE;
+}
+
+void
+fbCompositeSolidMaskSrc_nx8x8888sse2 (pixman_op_t op,
+				     pixman_image_t * pSrc,
+				     pixman_image_t * pMask,
+				     pixman_image_t * pDst,
+				     int16_t      xSrc,
+				     int16_t      ySrc,
+				     int16_t      xMask,
+				     int16_t      yMask,
+				     int16_t      xDst,
+				     int16_t      yDst,
+				     uint16_t     width,
+				     uint16_t     height)
+{
+    uint32_t	src, srca;
+    uint32_t	*dstLine, *dst;
+    uint8_t	*maskLine, *mask;
+    int	dstStride, maskStride;
+    uint16_t	w;
+    uint32_t    m;
+
+    __m128i xmmSrc, xmmDef;
+    __m128i xmmMask, xmmMaskLo, xmmMaskHi;
+
+    fbComposeGetSolid(pSrc, src, pDst->bits.format);
+
+    srca = src >> 24;
+    if (srca == 0)
+    {
+        pixmanFillsse2 (pDst->bits.bits, pDst->bits.rowstride,
+                        PIXMAN_FORMAT_BPP (pDst->bits.format),
+                        xDst, yDst, width, height, 0);
+        return;
+    }
+
+    fbComposeGetStart (pDst, xDst, yDst, uint32_t, dstStride, dstLine, 1);
+    fbComposeGetStart (pMask, xMask, yMask, uint8_t, maskStride, maskLine, 1);
+
+    xmmDef = createMask_2x32_128 (src, src);
+    xmmSrc = expandPixel_32_1x128 (src);
+
+    while (height--)
+    {
+        dst = dstLine;
+        dstLine += dstStride;
+        mask = maskLine;
+        maskLine += maskStride;
+        w = width;
+
+        /* call prefetch hint to optimize cache load*/
+        cachePrefetch ((__m128i*)mask);
+        cachePrefetch ((__m128i*)dst);
+
+        while (w && (unsigned long)dst & 15)
+        {
+            uint8_t m = *mask++;
+
+            if (m)
+            {
+                *dst = pack_1x64_32 (pixMultiply_1x64 (_mm_movepi64_pi64 (xmmSrc), expandPixel_8_1x64 (m)));
+            }
+            else
+            {
+                *dst = 0;
+            }
+
+            w--;
+            dst++;
+        }
+
+        /* call prefetch hint to optimize cache load*/
+        cachePrefetch ((__m128i*)mask);
+        cachePrefetch ((__m128i*)dst);
+
+        while (w >= 4)
+        {
+            /* fill cache line with next memory */
+            cachePrefetchNext ((__m128i*)mask);
+            cachePrefetchNext ((__m128i*)dst);
+
+            m = *((uint32_t*)mask);
+
+            if (srca == 0xff && m == 0xffffffff)
+            {
+                save128Aligned ((__m128i*)dst, xmmDef);
+            }
+            else if (m)
+            {
+                xmmMask = unpack_32_1x128 (m);
+                xmmMask = _mm_unpacklo_epi8 (xmmMask, _mm_setzero_si128());
+
+                /* Unpacking */
+                unpack_128_2x128 (xmmMask, &xmmMaskLo, &xmmMaskHi);
+
+                expandAlphaRev_2x128 (xmmMaskLo, xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
+
+                pixMultiply_2x128 (&xmmSrc, &xmmSrc, &xmmMaskLo, &xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
+
+                save128Aligned ((__m128i*)dst, pack_2x128_128 (xmmMaskLo, xmmMaskHi));
+            }
+            else
+            {
+                save128Aligned ((__m128i*)dst, _mm_setzero_si128());
+            }
+
+            w -= 4;
+            dst += 4;
+            mask += 4;
+        }
+
+        while (w)
+        {
+            uint8_t m = *mask++;
+
+            if (m)
+            {
+                *dst = pack_1x64_32 (pixMultiply_1x64 (_mm_movepi64_pi64 (xmmSrc), expandPixel_8_1x64 (m)));
+            }
+            else
+            {
+                *dst = 0;
+            }
+
+            w--;
+            dst++;
+        }
+    }
+
+    _mm_empty();
+}
+
+/* -------------------------------------------------------------------------------------------------
+ * fbCompositeSolidMask_nx8x0565
+ */
+
+void
+fbCompositeSolidMask_nx8x0565sse2 (pixman_op_t op,
+				  pixman_image_t * pSrc,
+				  pixman_image_t * pMask,
+				  pixman_image_t * pDst,
+				  int16_t      xSrc,
+				  int16_t      ySrc,
+				  int16_t      xMask,
+				  int16_t      yMask,
+				  int16_t      xDst,
+				  int16_t      yDst,
+				  uint16_t     width,
+				  uint16_t     height)
+{
+    uint32_t	src, srca;
+    uint16_t	*dstLine, *dst, d;
+    uint8_t	*maskLine, *mask;
+    int	dstStride, maskStride;
+    uint16_t	w;
+    uint32_t m;
+    __m64 mmxSrc, mmxAlpha, mmxMask, mmxDest;
+
+    __m128i xmmSrc, xmmAlpha;
+    __m128i xmmMask, xmmMaskLo, xmmMaskHi;
+    __m128i xmmDst, xmmDst0, xmmDst1, xmmDst2, xmmDst3;
+
+    fbComposeGetSolid(pSrc, src, pDst->bits.format);
+
+    srca = src >> 24;
+    if (srca == 0)
+	return;
+
+    fbComposeGetStart (pDst, xDst, yDst, uint16_t, dstStride, dstLine, 1);
+    fbComposeGetStart (pMask, xMask, yMask, uint8_t, maskStride, maskLine, 1);
+
+    xmmSrc = expandPixel_32_1x128 (src);
+    xmmAlpha = expandAlpha_1x128 (xmmSrc);
+    mmxSrc = _mm_movepi64_pi64 (xmmSrc);
+    mmxAlpha = _mm_movepi64_pi64 (xmmAlpha);
+
+    while (height--)
+    {
+        dst = dstLine;
+        dstLine += dstStride;
+        mask = maskLine;
+        maskLine += maskStride;
+        w = width;
+
+        /* call prefetch hint to optimize cache load*/
+        cachePrefetch ((__m128i*)mask);
+        cachePrefetch ((__m128i*)dst);
+
+        while (w && (unsigned long)dst & 15)
+        {
+            m = *mask++;
+
+            if (m)
+            {
+                d = *dst;
+                mmxMask = expandAlphaRev_1x64 (unpack_32_1x64 (m));
+                mmxDest = expand565_16_1x64 (d);
+
+                *dst = pack565_32_16 (pack_1x64_32 (inOver_1x64 (&mmxSrc,
+                                                                 &mmxAlpha,
+                                                                 &mmxMask,
+                                                                 &mmxDest)));
+            }
+
+            w--;
+            dst++;
+        }
+
+        /* call prefetch hint to optimize cache load*/
+        cachePrefetch ((__m128i*)mask);
+        cachePrefetch ((__m128i*)dst);
+
+        while (w >= 8)
+        {
+            /* fill cache line with next memory */
+            cachePrefetchNext ((__m128i*)mask);
+            cachePrefetchNext ((__m128i*)dst);
+
+            xmmDst = load128Aligned ((__m128i*) dst);
+            unpack565_128_4x128 (xmmDst, &xmmDst0, &xmmDst1, &xmmDst2, &xmmDst3);
+
+            m = *((uint32_t*)mask);
+            mask += 4;
+
+            if (m)
+            {
+                xmmMask = unpack_32_1x128 (m);
+                xmmMask = _mm_unpacklo_epi8 (xmmMask, _mm_setzero_si128());
+
+                /* Unpacking */
+                unpack_128_2x128 (xmmMask, &xmmMaskLo, &xmmMaskHi);
+
+                expandAlphaRev_2x128 (xmmMaskLo, xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
+                inOver_2x128 (&xmmSrc, &xmmSrc, &xmmAlpha, &xmmAlpha, &xmmMaskLo, &xmmMaskHi, &xmmDst0, &xmmDst1);
+            }
+
+            m = *((uint32_t*)mask);
+            mask += 4;
+
+            if (m)
+            {
+                xmmMask = unpack_32_1x128 (m);
+                xmmMask = _mm_unpacklo_epi8 (xmmMask, _mm_setzero_si128());
+
+                /* Unpacking */
+                unpack_128_2x128 (xmmMask, &xmmMaskLo, &xmmMaskHi);
+
+                expandAlphaRev_2x128 (xmmMaskLo, xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
+                inOver_2x128 (&xmmSrc, &xmmSrc, &xmmAlpha, &xmmAlpha, &xmmMaskLo, &xmmMaskHi, &xmmDst2, &xmmDst3);
+            }
+
+            save128Aligned ((__m128i*)dst, pack565_4x128_128 (&xmmDst0, &xmmDst1, &xmmDst2, &xmmDst3));
+
+            w -= 8;
+            dst += 8;
+        }
+
+        while (w)
+        {
+            m = *mask++;
+
+            if (m)
+            {
+                d = *dst;
+                mmxMask = expandAlphaRev_1x64 (unpack_32_1x64 (m));
+                mmxDest = expand565_16_1x64 (d);
+
+                *dst = pack565_32_16 (pack_1x64_32 (inOver_1x64 (&mmxSrc,
+                                                                 &mmxAlpha,
+                                                                 &mmxMask,
+                                                                 &mmxDest)));
+            }
+
+            w--;
+            dst++;
+        }
+    }
+
+    _mm_empty();
+}
+
+/* -------------------------------------------------------------------------------------------------
+ * fbCompositeSrc_8888RevNPx0565
+ */
+
+void
+fbCompositeSrc_8888RevNPx0565sse2 (pixman_op_t op,
+				  pixman_image_t * pSrc,
+				  pixman_image_t * pMask,
+				  pixman_image_t * pDst,
+				  int16_t      xSrc,
+				  int16_t      ySrc,
+				  int16_t      xMask,
+				  int16_t      yMask,
+				  int16_t      xDst,
+				  int16_t      yDst,
+				  uint16_t     width,
+				  uint16_t     height)
+{
+    uint16_t	*dstLine, *dst, d;
+    uint32_t	*srcLine, *src, s;
+    int	dstStride, srcStride;
+    uint16_t	w;
+    uint32_t    packCmp;
+
+    __m64 ms;
+    __m128i xmmSrc, xmmSrcLo, xmmSrcHi;
+    __m128i xmmDst, xmmDst0, xmmDst1, xmmDst2, xmmDst3;
+
+    fbComposeGetStart (pDst, xDst, yDst, uint16_t, dstStride, dstLine, 1);
+    fbComposeGetStart (pSrc, xSrc, ySrc, uint32_t, srcStride, srcLine, 1);
+
+#if 0
+    /* FIXME
+     *
+     * I copy the code from MMX one and keep the fixme.
+     * If it's a problem there, probably is a problem here.
+     */
+    assert (pSrc->pDrawable == pMask->pDrawable);
+#endif
+
+    while (height--)
+    {
+        dst = dstLine;
+        dstLine += dstStride;
+        src = srcLine;
+        srcLine += srcStride;
+        w = width;
+
+        /* call prefetch hint to optimize cache load*/
+        cachePrefetch ((__m128i*)src);
+        cachePrefetch ((__m128i*)dst);
+
+        while (w && (unsigned long)dst & 15)
+        {
+            s = *src++;
+            d = *dst;
+
+            ms = unpack_32_1x64 (s);
+
+            *dst++ = pack565_32_16 (pack_1x64_32 (overRevNonPre_1x64(ms, expand565_16_1x64 (d))));
+            w--;
+        }
+
+        /* call prefetch hint to optimize cache load*/
+        cachePrefetch ((__m128i*)src);
+        cachePrefetch ((__m128i*)dst);
+
+        while (w >= 8)
+        {
+            /* fill cache line with next memory */
+            cachePrefetchNext ((__m128i*)src);
+            cachePrefetchNext ((__m128i*)dst);
+
+            /* First round */
+            xmmSrc = load128Unaligned((__m128i*)src);
+            xmmDst = load128Aligned  ((__m128i*)dst);
+
+            packCmp = packAlpha (xmmSrc);
+
+            unpack565_128_4x128 (xmmDst, &xmmDst0, &xmmDst1, &xmmDst2, &xmmDst3);
+            unpack_128_2x128 (xmmSrc, &xmmSrcLo, &xmmSrcHi);
+
+            /* preload next round*/
+            xmmSrc = load128Unaligned((__m128i*)(src+4));
+            /* preload next round*/
+
+            if (packCmp == 0xffffffff)
+            {
+                invertColors_2x128 (xmmSrcLo, xmmSrcHi, &xmmDst0, &xmmDst1);
+            }
+            else if (packCmp)
+            {
+                overRevNonPre_2x128 (xmmSrcLo, xmmSrcHi, &xmmDst0, &xmmDst1);
+            }
+
+            /* Second round */
+            packCmp = packAlpha (xmmSrc);
+
+            unpack_128_2x128 (xmmSrc, &xmmSrcLo, &xmmSrcHi);
+
+            if (packCmp == 0xffffffff)
+            {
+                invertColors_2x128 (xmmSrcLo, xmmSrcHi, &xmmDst2, &xmmDst3);
+            }
+            else if (packCmp)
+            {
+                overRevNonPre_2x128 (xmmSrcLo, xmmSrcHi, &xmmDst2, &xmmDst3);
+            }
+
+            save128Aligned ((__m128i*)dst, pack565_4x128_128 (&xmmDst0, &xmmDst1, &xmmDst2, &xmmDst3));
+
+            w -= 8;
+            src += 8;
+            dst += 8;
+        }
+
+        while (w)
+        {
+            s = *src++;
+            d = *dst;
+
+            ms = unpack_32_1x64 (s);
+
+            *dst++ = pack565_32_16 (pack_1x64_32 (overRevNonPre_1x64(ms, expand565_16_1x64 (d))));
+            w--;
+        }
+    }
+
+    _mm_empty();
+}
+
+/* "8888RevNP" is GdkPixbuf's format: ABGR, non premultiplied */
+
+/* -------------------------------------------------------------------------------------------------
+ * fbCompositeSrc_8888RevNPx8888
+ */
+
+void
+fbCompositeSrc_8888RevNPx8888sse2 (pixman_op_t op,
+				  pixman_image_t * pSrc,
+				  pixman_image_t * pMask,
+				  pixman_image_t * pDst,
+				  int16_t      xSrc,
+				  int16_t      ySrc,
+				  int16_t      xMask,
+				  int16_t      yMask,
+				  int16_t      xDst,
+				  int16_t      yDst,
+				  uint16_t     width,
+				  uint16_t     height)
+{
+    uint32_t	*dstLine, *dst, d;
+    uint32_t	*srcLine, *src, s;
+    int	dstStride, srcStride;
+    uint16_t	w;
+    uint32_t    packCmp;
+
+    __m128i xmmSrcLo, xmmSrcHi;
+    __m128i xmmDstLo, xmmDstHi;
+
+    fbComposeGetStart (pDst, xDst, yDst, uint32_t, dstStride, dstLine, 1);
+    fbComposeGetStart (pSrc, xSrc, ySrc, uint32_t, srcStride, srcLine, 1);
+
+#if 0
+    /* FIXME
+     *
+     * I copy the code from MMX one and keep the fixme.
+     * If it's a problem there, probably is a problem here.
+     */
+    assert (pSrc->pDrawable == pMask->pDrawable);
+#endif
+
+    while (height--)
+    {
+        dst = dstLine;
+        dstLine += dstStride;
+        src = srcLine;
+        srcLine += srcStride;
+        w = width;
+
+        /* call prefetch hint to optimize cache load*/
+        cachePrefetch ((__m128i*)src);
+        cachePrefetch ((__m128i*)dst);
+
+        while (w && (unsigned long)dst & 15)
+        {
+            s = *src++;
+            d = *dst;
+
+            *dst++ = pack_1x64_32 (overRevNonPre_1x64 (unpack_32_1x64 (s), unpack_32_1x64 (d)));
+
+            w--;
+        }
+
+        /* call prefetch hint to optimize cache load*/
+        cachePrefetch ((__m128i*)src);
+        cachePrefetch ((__m128i*)dst);
+
+        while (w >= 4)
+        {
+            /* fill cache line with next memory */
+            cachePrefetchNext ((__m128i*)src);
+            cachePrefetchNext ((__m128i*)dst);
+
+            xmmSrcHi = load128Unaligned((__m128i*)src);
+
+            packCmp = packAlpha (xmmSrcHi);
+
+            unpack_128_2x128 (xmmSrcHi, &xmmSrcLo, &xmmSrcHi);
+
+            if (packCmp == 0xffffffff)
+            {
+                invertColors_2x128( xmmSrcLo, xmmSrcHi, &xmmDstLo, &xmmDstHi);
+
+                save128Aligned ((__m128i*)dst, pack_2x128_128 (xmmDstLo, xmmDstHi));
+            }
+            else if (packCmp)
+            {
+                xmmDstHi = load128Aligned  ((__m128i*)dst);
+
+                unpack_128_2x128 (xmmDstHi, &xmmDstLo, &xmmDstHi);
+
+                overRevNonPre_2x128 (xmmSrcLo, xmmSrcHi, &xmmDstLo, &xmmDstHi);
+
+                save128Aligned ((__m128i*)dst, pack_2x128_128 (xmmDstLo, xmmDstHi));
+            }
+
+            w -= 4;
+            dst += 4;
+            src += 4;
+        }
+
+        while (w)
+        {
+            s = *src++;
+            d = *dst;
+
+            *dst++ = pack_1x64_32 (overRevNonPre_1x64 (unpack_32_1x64 (s), unpack_32_1x64 (d)));
+
+            w--;
+        }
+    }
+
+    _mm_empty();
+}
+
+/* -------------------------------------------------------------------------------------------------
+ * fbCompositeSolidMask_nx8888x0565C
+ */
+
+void
+fbCompositeSolidMask_nx8888x0565Csse2 (pixman_op_t op,
+				      pixman_image_t * pSrc,
+				      pixman_image_t * pMask,
+				      pixman_image_t * pDst,
+				      int16_t      xSrc,
+				      int16_t      ySrc,
+				      int16_t      xMask,
+				      int16_t      yMask,
+				      int16_t      xDst,
+				      int16_t      yDst,
+				      uint16_t     width,
+				      uint16_t     height)
+{
+    uint32_t	src, srca;
+    uint16_t	*dstLine, *dst, d;
+    uint32_t	*maskLine, *mask, m;
+    int	dstStride, maskStride;
+    int w;
+    uint32_t packCmp;
+
+    __m128i xmmSrc, xmmAlpha;
+    __m128i xmmMask, xmmMaskLo, xmmMaskHi;
+    __m128i xmmDst, xmmDst0, xmmDst1, xmmDst2, xmmDst3;
+
+    __m64 mmxSrc, mmxAlpha, mmxMask, mmxDest;
+
+    fbComposeGetSolid(pSrc, src, pDst->bits.format);
+
+    srca = src >> 24;
+    if (srca == 0)
+        return;
+
+    fbComposeGetStart (pDst, xDst, yDst, uint16_t, dstStride, dstLine, 1);
+    fbComposeGetStart (pMask, xMask, yMask, uint32_t, maskStride, maskLine, 1);
+
+    xmmSrc = expandPixel_32_1x128 (src);
+    xmmAlpha = expandAlpha_1x128 (xmmSrc);
+    mmxSrc = _mm_movepi64_pi64 (xmmSrc);
+    mmxAlpha = _mm_movepi64_pi64 (xmmAlpha);
+
+    while (height--)
+    {
+        w = width;
+        mask = maskLine;
+        dst = dstLine;
+        maskLine += maskStride;
+        dstLine += dstStride;
+
+        /* call prefetch hint to optimize cache load*/
+        cachePrefetch ((__m128i*)mask);
+        cachePrefetch ((__m128i*)dst);
+
+        while (w && ((unsigned long)dst & 15))
+        {
+            m = *(uint32_t *) mask;
+
+            if (m)
+            {
+                d = *dst;
+                mmxMask = unpack_32_1x64 (m);
+                mmxDest = expand565_16_1x64 (d);
+
+                *dst = pack565_32_16 (pack_1x64_32 (inOver_1x64 (&mmxSrc,
+                                                                 &mmxAlpha,
+                                                                 &mmxMask,
+                                                                 &mmxDest)));
+            }
+
+            w--;
+            dst++;
+            mask++;
+        }
+
+        /* call prefetch hint to optimize cache load*/
+        cachePrefetch ((__m128i*)mask);
+        cachePrefetch ((__m128i*)dst);
+
+        while (w >= 8)
+        {
+            /* fill cache line with next memory */
+            cachePrefetchNext ((__m128i*)mask);
+            cachePrefetchNext ((__m128i*)dst);
+
+            /* First round */
+            xmmMask = load128Unaligned((__m128i*)mask);
+            xmmDst = load128Aligned((__m128i*)dst);
+
+            packCmp = _mm_movemask_epi8 (_mm_cmpeq_epi32 (xmmMask, _mm_setzero_si128()));
+
+            unpack565_128_4x128 (xmmDst, &xmmDst0, &xmmDst1, &xmmDst2, &xmmDst3);
+            unpack_128_2x128 (xmmMask, &xmmMaskLo, &xmmMaskHi);
+
+            /* preload next round*/
+            xmmMask = load128Unaligned((__m128i*)(mask+4));
+            /* preload next round*/
+
+            if (packCmp != 0xffff)
+            {
+                inOver_2x128(&xmmSrc, &xmmSrc, &xmmAlpha, &xmmAlpha, &xmmMaskLo, &xmmMaskHi, &xmmDst0, &xmmDst1);
+            }
+
+            /* Second round */
+            packCmp = _mm_movemask_epi8 (_mm_cmpeq_epi32 (xmmMask, _mm_setzero_si128()));
+
+            unpack_128_2x128 (xmmMask, &xmmMaskLo, &xmmMaskHi);
+
+            if (packCmp != 0xffff)
+            {
+                inOver_2x128(&xmmSrc, &xmmSrc, &xmmAlpha, &xmmAlpha, &xmmMaskLo, &xmmMaskHi, &xmmDst2, &xmmDst3);
+            }
+
+            save128Aligned ((__m128i*)dst, pack565_4x128_128 (&xmmDst0, &xmmDst1, &xmmDst2, &xmmDst3));
+
+            w -= 8;
+            dst += 8;
+            mask += 8;
+        }
+
+        while (w)
+        {
+            m = *(uint32_t *) mask;
+
+            if (m)
+            {
+                d = *dst;
+                mmxMask = unpack_32_1x64 (m);
+                mmxDest = expand565_16_1x64 (d);
+
+                *dst = pack565_32_16 (pack_1x64_32 (inOver_1x64 (&mmxSrc,
+                                                                 &mmxAlpha,
+                                                                 &mmxMask,
+                                                                 &mmxDest)));
+            }
+
+            w--;
+            dst++;
+            mask++;
+        }
+    }
+
+    _mm_empty ();
+}
+
+/* -------------------------------------------------------------------------------------------------
+ * fbCompositeIn_nx8x8
+ */
+
+void
+fbCompositeIn_nx8x8sse2 (pixman_op_t op,
+			pixman_image_t * pSrc,
+			pixman_image_t * pMask,
+			pixman_image_t * pDst,
+			int16_t      xSrc,
+			int16_t      ySrc,
+			int16_t      xMask,
+			int16_t      yMask,
+			int16_t      xDst,
+			int16_t      yDst,
+			uint16_t     width,
+			uint16_t     height)
+{
+    uint8_t	*dstLine, *dst;
+    uint8_t	*maskLine, *mask;
+    int	dstStride, maskStride;
+    uint16_t	w, d, m;
+    uint32_t	src;
+    uint8_t	sa;
+
+    __m128i xmmAlpha;
+    __m128i xmmMask, xmmMaskLo, xmmMaskHi;
+    __m128i xmmDst, xmmDstLo, xmmDstHi;
+
+    fbComposeGetStart (pDst, xDst, yDst, uint8_t, dstStride, dstLine, 1);
+    fbComposeGetStart (pMask, xMask, yMask, uint8_t, maskStride, maskLine, 1);
+
+    fbComposeGetSolid(pSrc, src, pDst->bits.format);
+
+    sa = src >> 24;
+    if (sa == 0)
+        return;
+
+    xmmAlpha = expandAlpha_1x128 (expandPixel_32_1x128 (src));
+
+    while (height--)
+    {
+        dst = dstLine;
+        dstLine += dstStride;
+        mask = maskLine;
+        maskLine += maskStride;
+        w = width;
+
+        /* call prefetch hint to optimize cache load*/
+        cachePrefetch ((__m128i*)mask);
+        cachePrefetch ((__m128i*)dst);
+
+        while (w && ((unsigned long)dst & 15))
+        {
+            m = (uint32_t) *mask++;
+            d = (uint32_t) *dst;
+
+            *dst++ = (uint8_t) pack_1x64_32 (pixMultiply_1x64 (pixMultiply_1x64 (_mm_movepi64_pi64 (xmmAlpha), unpack_32_1x64 (m)),
+                                                               unpack_32_1x64 (d)));
+            w--;
+        }
+
+        /* call prefetch hint to optimize cache load*/
+        cachePrefetch ((__m128i*)mask);
+        cachePrefetch ((__m128i*)dst);
+
+        while (w >= 16)
+        {
+            /* fill cache line with next memory */
+            cachePrefetchNext ((__m128i*)mask);
+            cachePrefetchNext ((__m128i*)dst);
+
+            xmmMask = load128Unaligned((__m128i*)mask);
+            xmmDst = load128Aligned((__m128i*)dst);
+
+            unpack_128_2x128 (xmmMask, &xmmMaskLo, &xmmMaskHi);
+            unpack_128_2x128 (xmmDst, &xmmDstLo, &xmmDstHi);
+
+            pixMultiply_2x128 (&xmmAlpha, &xmmAlpha, &xmmMaskLo, &xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
+            pixMultiply_2x128 (&xmmMaskLo, &xmmMaskHi, &xmmDstLo, &xmmDstHi, &xmmDstLo, &xmmDstHi);
+
+            save128Aligned ((__m128i*)dst, pack_2x128_128 (xmmDstLo, xmmDstHi));
+
+            mask += 16;
+            dst += 16;
+            w -= 16;
+        }
+
+        while (w)
+        {
+            m = (uint32_t) *mask++;
+            d = (uint32_t) *dst;
+
+            *dst++ = (uint8_t) pack_1x64_32 (pixMultiply_1x64 (pixMultiply_1x64 (_mm_movepi64_pi64 (xmmAlpha), unpack_32_1x64 (m)),
+                                                               unpack_32_1x64 (d)));
+            w--;
+        }
+    }
+
+    _mm_empty();
+}
+
+/* -------------------------------------------------------------------------------------------------
+ * fbCompositeIn_8x8
+ */
+
+void
+fbCompositeIn_8x8sse2 (pixman_op_t op,
+		      pixman_image_t * pSrc,
+		      pixman_image_t * pMask,
+		      pixman_image_t * pDst,
+		      int16_t      xSrc,
+		      int16_t      ySrc,
+		      int16_t      xMask,
+		      int16_t      yMask,
+		      int16_t      xDst,
+		      int16_t      yDst,
+		      uint16_t     width,
+		      uint16_t     height)
+{
+    uint8_t	*dstLine, *dst;
+    uint8_t	*srcLine, *src;
+    int	srcStride, dstStride;
+    uint16_t	w;
+    uint32_t    s, d;
+
+    __m128i xmmSrc, xmmSrcLo, xmmSrcHi;
+    __m128i xmmDst, xmmDstLo, xmmDstHi;
+
+    fbComposeGetStart (pDst, xDst, yDst, uint8_t, dstStride, dstLine, 1);
+    fbComposeGetStart (pSrc, xSrc, ySrc, uint8_t, srcStride, srcLine, 1);
+
+    while (height--)
+    {
+        dst = dstLine;
+        dstLine += dstStride;
+        src = srcLine;
+        srcLine += srcStride;
+        w = width;
+
+        /* call prefetch hint to optimize cache load*/
+        cachePrefetch ((__m128i*)src);
+        cachePrefetch ((__m128i*)dst);
+
+        while (w && ((unsigned long)dst & 15))
+        {
+            s = (uint32_t) *src++;
+            d = (uint32_t) *dst;
+
+            *dst++ = (uint8_t) pack_1x64_32 (pixMultiply_1x64 (unpack_32_1x64 (s),unpack_32_1x64 (d)));
+            w--;
+        }
+
+        /* call prefetch hint to optimize cache load*/
+        cachePrefetch ((__m128i*)src);
+        cachePrefetch ((__m128i*)dst);
+
+        while (w >= 16)
+        {
+            /* fill cache line with next memory */
+            cachePrefetchNext ((__m128i*)src);
+            cachePrefetchNext ((__m128i*)dst);
+
+            xmmSrc = load128Unaligned((__m128i*)src);
+            xmmDst = load128Aligned((__m128i*)dst);
+
+            unpack_128_2x128 (xmmSrc, &xmmSrcLo, &xmmSrcHi);
+            unpack_128_2x128 (xmmDst, &xmmDstLo, &xmmDstHi);
+
+            pixMultiply_2x128 (&xmmSrcLo, &xmmSrcHi, &xmmDstLo, &xmmDstHi, &xmmDstLo, &xmmDstHi);
+
+            save128Aligned ((__m128i*)dst, pack_2x128_128 (xmmDstLo, xmmDstHi));
+
+            src += 16;
+            dst += 16;
+            w -= 16;
+        }
+
+        while (w)
+        {
+            s = (uint32_t) *src++;
+            d = (uint32_t) *dst;
+
+            *dst++ = (uint8_t) pack_1x64_32 (pixMultiply_1x64 (unpack_32_1x64 (s),unpack_32_1x64 (d)));
+            w--;
+        }
+    }
+
+    _mm_empty ();
+}
+
+/* -------------------------------------------------------------------------------------------------
+ * fbCompositeSrcAdd_8888x8x8
+ */
+
+void
+fbCompositeSrcAdd_8888x8x8sse2 (pixman_op_t op,
+			       pixman_image_t * pSrc,
+			       pixman_image_t * pMask,
+			       pixman_image_t * pDst,
+			       int16_t      xSrc,
+			       int16_t      ySrc,
+			       int16_t      xMask,
+			       int16_t      yMask,
+			       int16_t      xDst,
+			       int16_t      yDst,
+			       uint16_t     width,
+			       uint16_t     height)
+{
+    uint8_t	*dstLine, *dst;
+    uint8_t	*maskLine, *mask;
+    int	dstStride, maskStride;
+    uint16_t	w;
+    uint32_t	src;
+    uint8_t	sa;
+    uint32_t m, d;
+
+    __m128i xmmAlpha;
+    __m128i xmmMask, xmmMaskLo, xmmMaskHi;
+    __m128i xmmDst, xmmDstLo, xmmDstHi;
+
+    fbComposeGetStart (pDst, xDst, yDst, uint8_t, dstStride, dstLine, 1);
+    fbComposeGetStart (pMask, xMask, yMask, uint8_t, maskStride, maskLine, 1);
+
+    fbComposeGetSolid(pSrc, src, pDst->bits.format);
+
+    sa = src >> 24;
+    if (sa == 0)
+        return;
+
+    xmmAlpha = expandAlpha_1x128 (expandPixel_32_1x128 (src));
+
+    while (height--)
+    {
+        dst = dstLine;
+        dstLine += dstStride;
+        mask = maskLine;
+        maskLine += maskStride;
+        w = width;
+
+        /* call prefetch hint to optimize cache load*/
+        cachePrefetch ((__m128i*)mask);
+        cachePrefetch ((__m128i*)dst);
+
+        while (w && ((unsigned long)dst & 15))
+        {
+            m = (uint32_t) *mask++;
+            d = (uint32_t) *dst;
+
+            *dst++ = (uint8_t) pack_1x64_32 (_mm_adds_pu16 (pixMultiply_1x64 (_mm_movepi64_pi64 (xmmAlpha), unpack_32_1x64 (m)),
+                                                                              unpack_32_1x64 (d)));
+            w--;
+        }
+
+        /* call prefetch hint to optimize cache load*/
+        cachePrefetch ((__m128i*)mask);
+        cachePrefetch ((__m128i*)dst);
+
+        while (w >= 16)
+        {
+            /* fill cache line with next memory */
+            cachePrefetchNext ((__m128i*)mask);
+            cachePrefetchNext ((__m128i*)dst);
+
+            xmmMask = load128Unaligned((__m128i*)mask);
+            xmmDst = load128Aligned((__m128i*)dst);
+
+            unpack_128_2x128 (xmmMask, &xmmMaskLo, &xmmMaskHi);
+            unpack_128_2x128 (xmmDst, &xmmDstLo, &xmmDstHi);
+
+            pixMultiply_2x128 (&xmmAlpha, &xmmAlpha, &xmmMaskLo, &xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
+
+            xmmDstLo = _mm_adds_epu16 (xmmMaskLo, xmmDstLo);
+            xmmDstHi = _mm_adds_epu16 (xmmMaskHi, xmmDstHi);
+
+            save128Aligned ((__m128i*)dst, pack_2x128_128 (xmmDstLo, xmmDstHi));
+
+            mask += 16;
+            dst += 16;
+            w -= 16;
+        }
+
+        while (w)
+        {
+            m = (uint32_t) *mask++;
+            d = (uint32_t) *dst;
+
+            *dst++ = (uint8_t) pack_1x64_32 (_mm_adds_pu16 (pixMultiply_1x64 (_mm_movepi64_pi64 (xmmAlpha), unpack_32_1x64 (m)),
+                                                                              unpack_32_1x64 (d)));
+            w--;
+        }
+    }
+
+    _mm_empty();
+}
+
+/* -------------------------------------------------------------------------------------------------
+ * fbCompositeSrcAdd_8000x8000
+ */
+
+void
+fbCompositeSrcAdd_8000x8000sse2 (pixman_op_t op,
+				pixman_image_t * pSrc,
+				pixman_image_t * pMask,
+				pixman_image_t * pDst,
+				int16_t      xSrc,
+				int16_t      ySrc,
+				int16_t      xMask,
+				int16_t      yMask,
+				int16_t      xDst,
+				int16_t      yDst,
+				uint16_t     width,
+				uint16_t     height)
+{
+    uint8_t	*dstLine, *dst;
+    uint8_t	*srcLine, *src;
+    int	dstStride, srcStride;
+    uint16_t	w;
+    uint16_t	t;
+
+    fbComposeGetStart (pSrc, xSrc, ySrc, uint8_t, srcStride, srcLine, 1);
+    fbComposeGetStart (pDst, xDst, yDst, uint8_t, dstStride, dstLine, 1);
+
+    while (height--)
+    {
+        dst = dstLine;
+        src = srcLine;
+
+        /* call prefetch hint to optimize cache load*/
+        cachePrefetch ((__m128i*)src);
+        cachePrefetch ((__m128i*)dst);
+
+        dstLine += dstStride;
+        srcLine += srcStride;
+        w = width;
+
+        /* Small head */
+        while (w && (unsigned long)dst & 3)
+        {
+            t = (*dst) + (*src++);
+            *dst++ = t | (0 - (t >> 8));
+            w--;
+        }
+
+        coreCombineAddUsse2 ((uint32_t*)dst, (uint32_t*)src, w >> 2);
+
+        /* Small tail */
+        dst += w & 0xfffc;
+        src += w & 0xfffc;
+
+        w &= 3;
+
+        while (w)
+        {
+            t = (*dst) + (*src++);
+            *dst++ = t | (0 - (t >> 8));
+            w--;
+        }
+    }
+
+    _mm_empty();
+}
+
+/* -------------------------------------------------------------------------------------------------
+ * fbCompositeSrcAdd_8888x8888
+ */
+void
+fbCompositeSrcAdd_8888x8888sse2 (pixman_op_t 	op,
+				pixman_image_t *	pSrc,
+				pixman_image_t *	pMask,
+				pixman_image_t *	 pDst,
+				int16_t		 xSrc,
+				int16_t      ySrc,
+				int16_t      xMask,
+				int16_t      yMask,
+				int16_t      xDst,
+				int16_t      yDst,
+				uint16_t     width,
+				uint16_t     height)
+{
+    uint32_t	*dstLine, *dst;
+    uint32_t	*srcLine, *src;
+    int	dstStride, srcStride;
+
+    fbComposeGetStart (pSrc, xSrc, ySrc, uint32_t, srcStride, srcLine, 1);
+    fbComposeGetStart (pDst, xDst, yDst, uint32_t, dstStride, dstLine, 1);
+
+    while (height--)
+    {
+        dst = dstLine;
+        dstLine += dstStride;
+        src = srcLine;
+        srcLine += srcStride;
+
+        coreCombineAddUsse2 (dst, src, width);
+    }
+
+    _mm_empty();
+}
+
+/* -------------------------------------------------------------------------------------------------
+ * fbCompositeCopyAreasse2
+ */
+
+pixman_bool_t
+pixmanBltsse2 (uint32_t *src_bits,
+		uint32_t *dst_bits,
+		int src_stride,
+		int dst_stride,
+		int src_bpp,
+		int dst_bpp,
+		int src_x, int src_y,
+		int dst_x, int dst_y,
+		int width, int height)
+{
+    uint8_t *	src_bytes;
+    uint8_t *	dst_bytes;
+    int		byte_width;
+
+    if (src_bpp != dst_bpp)
+        return FALSE;
+
+    if (src_bpp == 16)
+    {
+        src_stride = src_stride * (int) sizeof (uint32_t) / 2;
+        dst_stride = dst_stride * (int) sizeof (uint32_t) / 2;
+        src_bytes = (uint8_t *)(((uint16_t *)src_bits) + src_stride * (src_y) + (src_x));
+        dst_bytes = (uint8_t *)(((uint16_t *)dst_bits) + dst_stride * (dst_y) + (dst_x));
+        byte_width = 2 * width;
+        src_stride *= 2;
+        dst_stride *= 2;
+    }
+    else if (src_bpp == 32)
+    {
+        src_stride = src_stride * (int) sizeof (uint32_t) / 4;
+        dst_stride = dst_stride * (int) sizeof (uint32_t) / 4;
+        src_bytes = (uint8_t *)(((uint32_t *)src_bits) + src_stride * (src_y) + (src_x));
+        dst_bytes = (uint8_t *)(((uint32_t *)dst_bits) + dst_stride * (dst_y) + (dst_x));
+        byte_width = 4 * width;
+        src_stride *= 4;
+        dst_stride *= 4;
+    }
+    else
+    {
+        return FALSE;
+    }
+
+    cachePrefetch ((__m128i*)src_bytes);
+    cachePrefetch ((__m128i*)dst_bytes);
+
+    while (height--)
+    {
+        int w;
+        uint8_t *s = src_bytes;
+        uint8_t *d = dst_bytes;
+        src_bytes += src_stride;
+        dst_bytes += dst_stride;
+        w = byte_width;
+
+        cachePrefetchNext ((__m128i*)s);
+        cachePrefetchNext ((__m128i*)d);
+
+        while (w >= 2 && ((unsigned long)d & 3))
+        {
+            *(uint16_t *)d = *(uint16_t *)s;
+            w -= 2;
+            s += 2;
+            d += 2;
+        }
+
+        while (w >= 4 && ((unsigned long)d & 15))
+        {
+            *(uint32_t *)d = *(uint32_t *)s;
+
+            w -= 4;
+            s += 4;
+            d += 4;
+        }
+
+        cachePrefetchNext ((__m128i*)s);
+        cachePrefetchNext ((__m128i*)d);
+
+        while (w >= 64)
+        {
+            __m128i xmm0, xmm1, xmm2, xmm3;
+
+            /* 128 bytes ahead */
+            cachePrefetch (((__m128i*)s) + 8);
+            cachePrefetch (((__m128i*)d) + 8);
+
+            xmm0 = load128Unaligned ((__m128i*)(s));
+            xmm1 = load128Unaligned ((__m128i*)(s+16));
+            xmm2 = load128Unaligned ((__m128i*)(s+32));
+            xmm3 = load128Unaligned ((__m128i*)(s+48));
+
+            save128Aligned ((__m128i*)(d),    xmm0);
+            save128Aligned ((__m128i*)(d+16), xmm1);
+            save128Aligned ((__m128i*)(d+32), xmm2);
+            save128Aligned ((__m128i*)(d+48), xmm3);
+
+            s += 64;
+            d += 64;
+            w -= 64;
+        }
+
+        cachePrefetchNext ((__m128i*)s);
+        cachePrefetchNext ((__m128i*)d);
+
+        while (w >= 16)
+        {
+            save128Aligned ((__m128i*)d, load128Unaligned ((__m128i*)s) );
+
+            w -= 16;
+            d += 16;
+            s += 16;
+        }
+
+        cachePrefetchNext ((__m128i*)s);
+        cachePrefetchNext ((__m128i*)d);
+
+        while (w >= 4)
+        {
+            *(uint32_t *)d = *(uint32_t *)s;
+
+            w -= 4;
+            s += 4;
+            d += 4;
+        }
+
+        if (w >= 2)
+        {
+            *(uint16_t *)d = *(uint16_t *)s;
+            w -= 2;
+            s += 2;
+            d += 2;
+        }
+    }
+
+    _mm_empty();
+
+    return TRUE;
+}
+
+void
+fbCompositeCopyAreasse2 (pixman_op_t       op,
+			pixman_image_t *	pSrc,
+			pixman_image_t *	pMask,
+			pixman_image_t *	pDst,
+			int16_t		xSrc,
+			int16_t		ySrc,
+			int16_t		xMask,
+			int16_t		yMask,
+			int16_t		xDst,
+			int16_t		yDst,
+			uint16_t		width,
+			uint16_t		height)
+{
+    pixmanBltsse2 (pSrc->bits.bits,
+		    pDst->bits.bits,
+		    pSrc->bits.rowstride,
+		    pDst->bits.rowstride,
+		    PIXMAN_FORMAT_BPP (pSrc->bits.format),
+		    PIXMAN_FORMAT_BPP (pDst->bits.format),
+		    xSrc, ySrc, xDst, yDst, width, height);
+}
+
+#if 0
+/* This code are buggy in MMX version, now the bug was translated to SSE2 version */
+void
+fbCompositeOver_x888x8x8888sse2 (pixman_op_t      op,
+				pixman_image_t * pSrc,
+				pixman_image_t * pMask,
+				pixman_image_t * pDst,
+				int16_t      xSrc,
+				int16_t      ySrc,
+				int16_t      xMask,
+				int16_t      yMask,
+				int16_t      xDst,
+				int16_t      yDst,
+				uint16_t     width,
+				uint16_t     height)
+{
+    uint32_t	*src, *srcLine, s;
+    uint32_t    *dst, *dstLine, d;
+    uint8_t	    *mask, *maskLine;
+    uint32_t    m;
+    int		 srcStride, maskStride, dstStride;
+    uint16_t w;
+
+    __m128i xmmSrc, xmmSrcLo, xmmSrcHi;
+    __m128i xmmDst, xmmDstLo, xmmDstHi;
+    __m128i xmmMask, xmmMaskLo, xmmMaskHi;
+
+    fbComposeGetStart (pDst, xDst, yDst, uint32_t, dstStride, dstLine, 1);
+    fbComposeGetStart (pMask, xMask, yMask, uint8_t, maskStride, maskLine, 1);
+    fbComposeGetStart (pSrc, xSrc, ySrc, uint32_t, srcStride, srcLine, 1);
+
+    while (height--)
+    {
+        src = srcLine;
+        srcLine += srcStride;
+        dst = dstLine;
+        dstLine += dstStride;
+        mask = maskLine;
+        maskLine += maskStride;
+
+        w = width;
+
+        /* call prefetch hint to optimize cache load*/
+        cachePrefetch ((__m128i*)src);
+        cachePrefetch ((__m128i*)dst);
+        cachePrefetch ((__m128i*)mask);
+
+        while (w && (unsigned long)dst & 15)
+        {
+            s = 0xff000000 | *src++;
+            m = (uint32_t) *mask++;
+            d = *dst;
+
+            __m64 ms = unpack_32_1x64 (s);
+
+            if (m != 0xff)
+            {
+                ms = inOver_1x64 (ms,
+                                  xMask00ff,
+                                  expandAlphaRev_1x64 (unpack_32_1x64 (m)),
+                                  unpack_32_1x64 (d));
+            }
+
+            *dst++ = pack_1x64_32 (ms);
+            w--;
+        }
+
+        /* call prefetch hint to optimize cache load*/
+        cachePrefetch ((__m128i*)src);
+        cachePrefetch ((__m128i*)dst);
+        cachePrefetch ((__m128i*)mask);
+
+        while (w >= 4)
+        {
+            /* fill cache line with next memory */
+            cachePrefetchNext ((__m128i*)src);
+            cachePrefetchNext ((__m128i*)dst);
+            cachePrefetchNext ((__m128i*)mask);
+
+            m = *(uint32_t*) mask;
+            xmmSrc = _mm_or_si128 (load128Unaligned ((__m128i*)src), Maskff000000);
+
+            if (m == 0xffffffff)
+            {
+                save128Aligned ((__m128i*)dst, xmmSrc);
+            }
+            else
+            {
+                xmmDst = load128Aligned ((__m128i*)dst);
+
+                xmmMask = _mm_unpacklo_epi16 (unpack_32_1x128 (m), _mm_setzero_si128());
+
+                unpack_128_2x128 (xmmSrc, &xmmSrcLo, &xmmSrcHi);
+                unpack_128_2x128 (xmmMask, &xmmMaskLo, &xmmMaskHi);
+                unpack_128_2x128 (xmmDst, &xmmDstLo, &xmmDstHi);
+
+                expandAlphaRev_2x128 (xmmMaskLo, xmmMaskHi, &xmmMaskLo, &xmmMaskHi);
+
+                inOver_2x128 (xmmSrcLo, xmmSrcHi, Mask00ff, Mask00ff, xmmMaskLo, xmmMaskHi, &xmmDstLo, &xmmDstHi);
+
+                save128Aligned( (__m128i*)dst, pack_2x128_128 (xmmDstLo, xmmDstHi));
+            }
+
+            src += 4;
+            dst += 4;
+            mask += 4;
+            w -= 4;
+        }
+
+        while (w)
+        {
+            m = (uint32_t) *mask++;
+
+            if (m)
+            {
+                s = 0xff000000 | *src;
+
+                if (m == 0xff)
+                {
+                    *dst = s;
+                }
+                else
+                {
+                    d = *dst;
+
+                    *dst = pack_1x64_32 (inOver_1x64 (unpack_32_1x64 (s),
+                                                      xMask00ff,
+                                                      expandAlphaRev_1x64 (unpack_32_1x64 (m)),
+                                                      unpack_32_1x64 (d)));
+                }
+
+            }
+
+            src++;
+            dst++;
+            w--;
+        }
+    }
+
+    _mm_empty();
+}
+#endif /* #if 0 */
+
+#endif /* USE_SSE2 */
diff -r 14ce7619e9c1 gfx/cairo/libpixman/src/pixman-sse2.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/cairo/libpixman/src/pixman-sse2.h	Mon Sep 08 10:35:45 2008 +0300
@@ -0,0 +1,358 @@
+/*
+ * Copyright © 2008 Rodrigo Kumpera
+ * Copyright © 2008 André Tupinambá
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Red Hat not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  Red Hat makes no representations about the
+ * suitability of this software for any purpose.  It is provided "as is"
+ * without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ *
+ * Author:  Rodrigo Kumpera (kumpera@gmail.com)
+ *          André Tupinambá (andrelrt@gmail.com)
+ * 
+ * Based on work by Owen Taylor and Søren Sandmann
+ */
+#ifndef _PIXMAN_SSE_H_
+#define _PIXMAN_SSE_H_
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#include "pixman-private.h"
+
+#ifdef USE_SSE2
+
+#if !defined(__amd64__) && !defined(__x86_64__)
+pixman_bool_t pixman_have_sse2(void);
+#else
+#define pixman_have_sse2() TRUE
+#endif
+
+#else
+#define pixman_have_sse2() FALSE
+#endif
+
+#ifdef USE_SSE2
+
+void fbComposeSetupSSE2(void);
+
+pixman_bool_t
+pixmanFillsse2 (uint32_t *bits,
+		 int stride,
+		 int bpp,
+		 int x,
+		 int y,
+		 int width,
+		 int height,
+		 uint32_t data);
+
+pixman_bool_t
+pixmanBltsse2 (uint32_t *src_bits,
+		uint32_t *dst_bits,
+		int src_stride,
+		int dst_stride,
+		int src_bpp,
+		int dst_bpp,
+		int src_x, int src_y,
+		int dst_x, int dst_y,
+		int width, int height);
+
+void
+fbCompositeSolid_nx8888sse2 (pixman_op_t op,
+			    pixman_image_t * pSrc,
+			    pixman_image_t * pMask,
+			    pixman_image_t * pDst,
+			    int16_t	xSrc,
+			    int16_t	ySrc,
+			    int16_t	xMask,
+			    int16_t	yMask,
+			    int16_t	xDst,
+			    int16_t	yDst,
+			    uint16_t	width,
+			    uint16_t	height);
+
+void
+fbCompositeSolid_nx0565sse2 (pixman_op_t op,
+			    pixman_image_t * pSrc,
+			    pixman_image_t * pMask,
+			    pixman_image_t * pDst,
+			    int16_t	xSrc,
+			    int16_t	ySrc,
+			    int16_t	xMask,
+			    int16_t	yMask,
+			    int16_t	xDst,
+			    int16_t	yDst,
+			    uint16_t	width,
+			    uint16_t	height);
+
+void
+fbCompositeSolidMask_nx8888x8888Csse2 (pixman_op_t op,
+				      pixman_image_t * pSrc,
+				      pixman_image_t * pMask,
+				      pixman_image_t * pDst,
+				      int16_t	xSrc,
+				      int16_t	ySrc,
+				      int16_t	xMask,
+				      int16_t	yMask,
+				      int16_t	xDst,
+				      int16_t	yDst,
+				      uint16_t	width,
+				      uint16_t	height);
+
+void
+fbCompositeSrc_8888x8x8888sse2 (pixman_op_t op,
+			       pixman_image_t * pSrc,
+			       pixman_image_t * pMask,
+			       pixman_image_t * pDst,
+			       int16_t	xSrc,
+			       int16_t	ySrc,
+			       int16_t      xMask,
+			       int16_t      yMask,
+			       int16_t      xDst,
+			       int16_t      yDst,
+			       uint16_t     width,
+			       uint16_t     height);
+
+void
+fbCompositeSrc_x888xnx8888sse2 (pixman_op_t op,
+			       pixman_image_t * pSrc,
+			       pixman_image_t * pMask,
+			       pixman_image_t * pDst,
+			       int16_t	xSrc,
+			       int16_t	ySrc,
+			       int16_t      xMask,
+			       int16_t      yMask,
+			       int16_t      xDst,
+			       int16_t      yDst,
+			       uint16_t     width,
+			       uint16_t     height);
+
+void
+fbCompositeSrc_8888x8888sse2 (pixman_op_t op,
+                 pixman_image_t * pSrc,
+                 pixman_image_t * pMask,
+                 pixman_image_t * pDst,
+                 int16_t    xSrc,
+                 int16_t    ySrc,
+                 int16_t      xMask,
+                 int16_t      yMask,
+                 int16_t      xDst,
+                 int16_t      yDst,
+                 uint16_t     width,
+                 uint16_t     height);
+
+void
+fbCompositeSrc_8888x0565sse2 (pixman_op_t op,
+                 pixman_image_t * pSrc,
+                 pixman_image_t * pMask,
+                 pixman_image_t * pDst,
+                 int16_t      xSrc,
+                 int16_t      ySrc,
+                 int16_t      xMask,
+                 int16_t      yMask,
+                 int16_t      xDst,
+                 int16_t      yDst,
+                 uint16_t     width,
+                 uint16_t     height);
+
+void
+fbCompositeSolidMask_nx8x8888sse2 (pixman_op_t op,
+				  pixman_image_t * pSrc,
+				  pixman_image_t * pMask,
+				  pixman_image_t * pDst,
+				  int16_t      xSrc,
+				  int16_t      ySrc,
+				  int16_t      xMask,
+				  int16_t      yMask,
+				  int16_t      xDst,
+				  int16_t      yDst,
+				  uint16_t     width,
+				  uint16_t     height);
+
+void
+fbCompositeSolidMaskSrc_nx8x8888sse2 (pixman_op_t op,
+				     pixman_image_t * pSrc,
+				     pixman_image_t * pMask,
+				     pixman_image_t * pDst,
+				     int16_t      xSrc,
+				     int16_t      ySrc,
+				     int16_t      xMask,
+				     int16_t      yMask,
+				     int16_t      xDst,
+				     int16_t      yDst,
+				     uint16_t     width,
+				     uint16_t     height);
+
+void
+fbCompositeSolidMask_nx8x0565sse2 (pixman_op_t op,
+				  pixman_image_t * pSrc,
+				  pixman_image_t * pMask,
+				  pixman_image_t * pDst,
+				  int16_t      xSrc,
+				  int16_t      ySrc,
+				  int16_t      xMask,
+				  int16_t      yMask,
+				  int16_t      xDst,
+				  int16_t      yDst,
+				  uint16_t     width,
+				  uint16_t     height);
+
+void
+fbCompositeSrc_8888RevNPx0565sse2 (pixman_op_t op,
+				  pixman_image_t * pSrc,
+				  pixman_image_t * pMask,
+				  pixman_image_t * pDst,
+				  int16_t      xSrc,
+				  int16_t      ySrc,
+				  int16_t      xMask,
+				  int16_t      yMask,
+				  int16_t      xDst,
+				  int16_t      yDst,
+				  uint16_t     width,
+				  uint16_t     height);
+
+void
+fbCompositeSrc_8888RevNPx8888sse2 (pixman_op_t op,
+				  pixman_image_t * pSrc,
+				  pixman_image_t * pMask,
+				  pixman_image_t * pDst,
+				  int16_t      xSrc,
+				  int16_t      ySrc,
+				  int16_t      xMask,
+				  int16_t      yMask,
+				  int16_t      xDst,
+				  int16_t      yDst,
+				  uint16_t     width,
+				  uint16_t     height);
+
+void
+fbCompositeSolidMask_nx8888x0565Csse2 (pixman_op_t op,
+				      pixman_image_t * pSrc,
+				      pixman_image_t * pMask,
+				      pixman_image_t * pDst,
+				      int16_t      xSrc,
+				      int16_t      ySrc,
+				      int16_t      xMask,
+				      int16_t      yMask,
+				      int16_t      xDst,
+				      int16_t      yDst,
+				      uint16_t     width,
+				      uint16_t     height);
+
+void
+fbCompositeIn_nx8x8sse2 (pixman_op_t op,
+			pixman_image_t * pSrc,
+			pixman_image_t * pMask,
+			pixman_image_t * pDst,
+			int16_t      xSrc,
+			int16_t      ySrc,
+			int16_t      xMask,
+			int16_t      yMask,
+			int16_t      xDst,
+			int16_t      yDst,
+			uint16_t     width,
+			uint16_t     height);
+
+void
+fbCompositeIn_8x8sse2 (pixman_op_t op,
+		      pixman_image_t * pSrc,
+		      pixman_image_t * pMask,
+		      pixman_image_t * pDst,
+		      int16_t      xSrc,
+		      int16_t      ySrc,
+		      int16_t      xMask,
+		      int16_t      yMask,
+		      int16_t      xDst,
+		      int16_t      yDst,
+		      uint16_t     width,
+		      uint16_t     height);
+
+void
+fbCompositeSrcAdd_8888x8x8sse2 (pixman_op_t op,
+			       pixman_image_t * pSrc,
+			       pixman_image_t * pMask,
+			       pixman_image_t * pDst,
+			       int16_t      xSrc,
+			       int16_t      ySrc,
+			       int16_t      xMask,
+			       int16_t      yMask,
+			       int16_t      xDst,
+			       int16_t      yDst,
+			       uint16_t     width,
+			       uint16_t     height);
+
+
+void
+fbCompositeSrcAdd_8000x8000sse2 (pixman_op_t op,
+                pixman_image_t * pSrc,
+                pixman_image_t * pMask,
+                pixman_image_t * pDst,
+                int16_t      xSrc,
+                int16_t      ySrc,
+                int16_t      xMask,
+                int16_t      yMask,
+                int16_t      xDst,
+                int16_t      yDst,
+                uint16_t     width,
+                uint16_t     height);
+
+void
+fbCompositeSrcAdd_8888x8888sse2 (pixman_op_t    op,
+                pixman_image_t *    pSrc,
+                pixman_image_t *    pMask,
+                pixman_image_t *     pDst,
+                int16_t      xSrc,
+                int16_t      ySrc,
+                int16_t      xMask,
+                int16_t      yMask,
+                int16_t      xDst,
+                int16_t      yDst,
+                uint16_t     width,
+                uint16_t     height);
+
+void
+fbCompositeCopyAreasse2 (pixman_op_t       op,
+			pixman_image_t *	pSrc,
+			pixman_image_t *	pMask,
+			pixman_image_t *	pDst,
+			int16_t		xSrc,
+			int16_t		ySrc,
+			int16_t		xMask,
+			int16_t		yMask,
+			int16_t		xDst,
+			int16_t		yDst,
+			uint16_t		width,
+			uint16_t		height);
+
+void
+fbCompositeOver_x888x8x8888sse2 (pixman_op_t      op,
+				pixman_image_t * pSrc,
+				pixman_image_t * pMask,
+				pixman_image_t * pDst,
+				int16_t      xSrc,
+				int16_t      ySrc,
+				int16_t      xMask,
+				int16_t      yMask,
+				int16_t      xDst,
+				int16_t      yDst,
+				uint16_t     width,
+				uint16_t     height);
+
+#endif /* USE_SSE2 */
+
+#endif /* _PIXMAN_SSE_H_ */
diff -r 14ce7619e9c1 gfx/cairo/libpixman/src/pixman-utils.c
--- a/gfx/cairo/libpixman/src/pixman-utils.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/libpixman/src/pixman-utils.c	Mon Sep 08 10:35:45 2008 +0300
@@ -535,10 +535,12 @@ PIXMAN_EXPORT pixman_bool_t
 PIXMAN_EXPORT pixman_bool_t
 pixman_format_supported_source (pixman_format_code_t format)
 {
     switch (format) {
     /* 32 bpp formats */
+    case PIXMAN_a2b10g10r10:
+    case PIXMAN_x2b10g10r10:
     case PIXMAN_a8r8g8b8:
     case PIXMAN_x8r8g8b8:
     case PIXMAN_a8b8g8r8:
     case PIXMAN_x8b8g8r8:
     case PIXMAN_r8g8b8:
diff -r 14ce7619e9c1 gfx/cairo/libpixman/src/pixman-version.h
--- a/gfx/cairo/libpixman/src/pixman-version.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/libpixman/src/pixman-version.h	Mon Sep 08 10:35:45 2008 +0300
@@ -31,13 +31,13 @@
 #  error pixman-version.h should only be included by pixman.h
 #endif
 
 #define PIXMAN_VERSION_MAJOR 0
 #define PIXMAN_VERSION_MINOR 11
-#define PIXMAN_VERSION_MICRO 7
+#define PIXMAN_VERSION_MICRO 9
 
-#define PIXMAN_VERSION_STRING "0.11.7"
+#define PIXMAN_VERSION_STRING "0.11.9"
 
 #define PIXMAN_VERSION_ENCODE(major, minor, micro) (	\
 	  ((major) * 10000)				\
 	+ ((minor) *   100)				\
 	+ ((micro) *     1))
diff -r 14ce7619e9c1 gfx/cairo/libpixman/src/pixman.h
--- a/gfx/cairo/libpixman/src/pixman.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/cairo/libpixman/src/pixman.h	Mon Sep 08 10:35:45 2008 +0300
@@ -83,10 +83,12 @@ typedef unsigned __int16 uint16_t;
 typedef unsigned __int16 uint16_t;
 typedef __int32 int32_t;
 typedef unsigned __int32 uint32_t;
 typedef __int64 int64_t;
 typedef unsigned __int64 uint64_t;
+#elif defined (_AIX)
+#  include <sys/inttypes.h>
 #else
 #  include <stdint.h>
 #endif
 
 /*
diff -r 14ce7619e9c1 gfx/public/nsFont.h
--- a/gfx/public/nsFont.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/gfx/public/nsFont.h	Mon Sep 08 10:35:45 2008 +0300
@@ -66,22 +66,22 @@ struct NS_GFX nsFont {
 struct NS_GFX nsFont {
   // The family name of the font
   nsString name;
 
   // The style of font (normal, italic, oblique)
-  unsigned int style : 7;
+  PRUint8 style;
 
   // Force this font to not be considered a 'generic' font, even if
   // the name is the same as a CSS generic font family.
-  unsigned int systemFont : 1;
+  PRUint8 systemFont;
 
   // The variant of the font (normal, small-caps)
-  PRUint8 variant : 7;
+  PRUint8 variant;
 
   // True if the character set quirks (for treatment of "Symbol",
   // "Wingdings", etc.) should be applied.
-  PRUint8 familyNameQuirks : 1;
+  PRUint8 familyNameQuirks;
 
   // The weight of the font (0-999)
   PRUint16 weight;
 
   // The decorations on the font (underline, overline,
diff -r 14ce7619e9c1 js/jsd/jsd.h
--- a/js/jsd/jsd.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/jsd/jsd.h	Mon Sep 08 10:35:45 2008 +0300
@@ -370,11 +370,11 @@ extern JSBool
 extern JSBool
 jsd_GetErrorReporter(JSDContext*        jsdc,
                      JSD_ErrorReporter* reporter,
                      void**             callerdata);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 jsd_DebugErrorHook(JSContext *cx, const char *message,
                    JSErrorReport *report, void *closure);
 
 /***************************************************************************/
 /* Script functions */
@@ -465,20 +465,20 @@ jsd_GetClosestPC(JSDContext* jsdc, JSDSc
 jsd_GetClosestPC(JSDContext* jsdc, JSDScript* jsdscript, uintN line);
 
 extern uintN
 jsd_GetClosestLine(JSDContext* jsdc, JSDScript* jsdscript, jsuword pc);
 
-extern void JS_DLL_CALLBACK
+extern void
 jsd_NewScriptHookProc(
                 JSContext   *cx,
                 const char  *filename,      /* URL this script loads from */
                 uintN       lineno,         /* line where this script starts */
                 JSScript    *script,
                 JSFunction  *fun,
                 void*       callerdata);
 
-extern void JS_DLL_CALLBACK
+extern void
 jsd_DestroyScriptHookProc(
                 JSContext   *cx,
                 JSScript    *script,
                 void*       callerdata);
 
@@ -632,15 +632,15 @@ jsd_SetThrowHook(JSDContext*           j
                  JSD_ExecutionHookProc hook,
                  void*                 callerdata);
 extern JSBool
 jsd_ClearThrowHook(JSDContext* jsdc);
 
-extern JSTrapStatus JS_DLL_CALLBACK
+extern JSTrapStatus
 jsd_DebuggerHandler(JSContext *cx, JSScript *script, jsbytecode *pc,
                     jsval *rval, void *closure);
 
-extern JSTrapStatus JS_DLL_CALLBACK
+extern JSTrapStatus
 jsd_ThrowHandler(JSContext *cx, JSScript *script, jsbytecode *pc,
                  jsval *rval, void *closure);
 
 extern JSBool
 jsd_SetFunctionHook(JSDContext*      jsdc,
@@ -1007,15 +1007,15 @@ jsd_GetPropertyVarArgSlot(JSDContext* js
 jsd_GetPropertyVarArgSlot(JSDContext* jsdc, JSDProperty* jsdprop);
 
 /**************************************************/
 /* Stepping Functions */
 
-extern void * JS_DLL_CALLBACK
+extern void *
 jsd_FunctionCallHook(JSContext *cx, JSStackFrame *fp, JSBool before,
                      JSBool *ok, void *closure);
 
-extern void * JS_DLL_CALLBACK
+extern void *
 jsd_TopLevelCallHook(JSContext *cx, JSStackFrame *fp, JSBool before,
                      JSBool *ok, void *closure);
 
 /**************************************************/
 /* Object Functions */
@@ -1024,11 +1024,11 @@ jsd_InitObjectManager(JSDContext* jsdc);
 jsd_InitObjectManager(JSDContext* jsdc);
 
 extern void
 jsd_DestroyObjectManager(JSDContext* jsdc);
 
-extern void JS_DLL_CALLBACK
+extern void
 jsd_ObjectHook(JSContext *cx, JSObject *obj, JSBool isNew, void *closure);
 
 extern void
 jsd_Constructing(JSDContext* jsdc, JSContext *cx, JSObject *obj,
                  JSStackFrame *fp);
@@ -1115,11 +1115,11 @@ jsdlw_ProcessedToRawLineNumber(JSDContex
                                uintN lineIn, uintN* lineOut);
 
 
 #if 0
 /* our hook proc for LiveWire app start/stop */
-extern void JS_DLL_CALLBACK
+extern void
 jsdlw_AppHookProc(LWDBGApp* app,
                   JSBool created,
                   void *callerdata);
 #endif
 
diff -r 14ce7619e9c1 js/jsd/jsd_atom.c
--- a/js/jsd/jsd_atom.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/jsd/jsd_atom.c	Mon Sep 08 10:35:45 2008 +0300
@@ -65,11 +65,11 @@ _testAtoms(JSDContext*jsdc)
     jsd_DropAtom(jsdc, atom3);
     jsd_DropAtom(jsdc, atom4);
 }        
 #endif    
 
-JS_STATIC_DLL_CALLBACK(intN)
+static intN
 _atom_smasher(JSHashEntry *he, intN i, void *arg)
 {
     JS_ASSERT(he);
     JS_ASSERT(he->value);
     JS_ASSERT(((JSDAtom*)(he->value))->str);
@@ -79,17 +79,17 @@ _atom_smasher(JSHashEntry *he, intN i, v
     he->value = NULL;
     he->key   = NULL;
     return HT_ENUMERATE_NEXT;
 }
 
-JS_STATIC_DLL_CALLBACK(intN)
+static intN
 _compareAtomKeys(const void *v1, const void *v2)
 {
     return 0 == strcmp((const char*)v1, (const char*)v2);
 }        
 
-JS_STATIC_DLL_CALLBACK(intN)
+static intN
 _compareAtoms(const void *v1, const void *v2)
 {
     return 0 == strcmp(((JSDAtom*)v1)->str, ((JSDAtom*)v2)->str);
 }        
 
diff -r 14ce7619e9c1 js/jsd/jsd_high.c
--- a/js/jsd/jsd_high.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/jsd/jsd_high.c	Mon Sep 08 10:35:45 2008 +0300
@@ -322,11 +322,11 @@ jsd_JSDContextForJSContext(JSContext* co
     }
     JSD_UNLOCK();
     return jsdc;
 }    
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 jsd_DebugErrorHook(JSContext *cx, const char *message,
                    JSErrorReport *report, void *closure)
 {
     JSDContext* jsdc = (JSDContext*) closure;
     JSD_ErrorReporter errorReporter;
diff -r 14ce7619e9c1 js/jsd/jsd_hook.c
--- a/js/jsd/jsd_hook.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/jsd/jsd_hook.c	Mon Sep 08 10:35:45 2008 +0300
@@ -39,11 +39,11 @@
  * JavaScript Debugging support - Hook support
  */
 
 #include "jsd.h"
 
-JSTrapStatus JS_DLL_CALLBACK
+JSTrapStatus
 jsd_InterruptHandler(JSContext *cx, JSScript *script, jsbytecode *pc, jsval *rval,
                      void *closure)
 {
     JSDScript*      jsdscript;
     JSDContext*     jsdc = (JSDContext*) closure;
@@ -78,11 +78,11 @@ jsd_InterruptHandler(JSContext *cx, JSSc
 
     return jsd_CallExecutionHook(jsdc, cx, JSD_HOOK_INTERRUPTED,
                                  hook, hookData, rval);
 }
 
-JSTrapStatus JS_DLL_CALLBACK
+JSTrapStatus
 jsd_DebuggerHandler(JSContext *cx, JSScript *script, jsbytecode *pc,
                     jsval *rval, void *closure)
 {
     JSDScript*      jsdscript;
     JSDContext*     jsdc = (JSDContext*) closure;
@@ -112,11 +112,11 @@ jsd_DebuggerHandler(JSContext *cx, JSScr
     return jsd_CallExecutionHook(jsdc, cx, JSD_HOOK_DEBUGGER_KEYWORD,
                                  hook, hookData, rval);
 }
 
 
-JSTrapStatus JS_DLL_CALLBACK
+JSTrapStatus
 jsd_ThrowHandler(JSContext *cx, JSScript *script, jsbytecode *pc,
                  jsval *rval, void *closure)
 {
     JSDScript*      jsdscript;
     JSDContext*     jsdc = (JSDContext*) closure;
diff -r 14ce7619e9c1 js/jsd/jsd_obj.c
--- a/js/jsd/jsd_obj.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/jsd/jsd_obj.c	Mon Sep 08 10:35:45 2008 +0300
@@ -154,11 +154,11 @@ _createJSDObject(JSDContext* jsdc, JSCon
         }
     }
     return jsdobj;
 }
 
-void JS_DLL_CALLBACK
+void
 jsd_ObjectHook(JSContext *cx, JSObject *obj, JSBool isNew, void *closure)
 {
     JSDObject* jsdobj;
     JSDContext* jsdc = (JSDContext*) closure;
 
@@ -218,11 +218,11 @@ jsd_Constructing(JSDContext* jsdc, JSCon
     }
     TRACEOBJ(jsdc, jsdobj, 3);
     JSD_UNLOCK_OBJECTS(jsdc);
 }
 
-JS_STATIC_DLL_CALLBACK(JSHashNumber)
+static JSHashNumber
 _hash_root(const void *key)
 {
     return ((JSHashNumber) key) >> 2; /* help lame MSVC1.5 on Win16 */
 }
 
diff -r 14ce7619e9c1 js/jsd/jsd_scpt.c
--- a/js/jsd/jsd_scpt.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/jsd/jsd_scpt.c	Mon Sep 08 10:35:45 2008 +0300
@@ -214,35 +214,35 @@ _dumpJSDScriptList( JSDContext* jsdc )
         _dumpJSDScript( jsdc, jsdscript, "  script: " );
 }
 #endif /* JSD_DUMP */
 
 /***************************************************************************/
-JS_STATIC_DLL_CALLBACK(JSHashNumber)
+static JSHashNumber
 jsd_hash_script(const void *key)
 {
     return ((JSHashNumber) key) >> 2; /* help lame MSVC1.5 on Win16 */
 }
 
-JS_STATIC_DLL_CALLBACK(void *)
+static void *
 jsd_alloc_script_table(void *priv, size_t size)
 {
     return malloc(size);
 }
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 jsd_free_script_table(void *priv, void *item)
 {
     free(item);
 }
 
-JS_STATIC_DLL_CALLBACK(JSHashEntry *)
+static JSHashEntry *
 jsd_alloc_script_entry(void *priv, const void *item)
 {
     return (JSHashEntry*) malloc(sizeof(JSHashEntry));
 }
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 jsd_free_script_entry(void *priv, JSHashEntry *he, uintN flag)
 {
     if (flag == HT_FREE_ENTRY)
     {
         _destroyJSDScript((JSDContext*) priv, (JSDScript*) he->value);
@@ -542,11 +542,11 @@ jsd_GetScriptHook(JSDContext* jsdc, JSD_
     return JS_TRUE;
 }    
 
 /***************************************************************************/
 
-void JS_DLL_CALLBACK
+void
 jsd_NewScriptHookProc( 
                 JSContext   *cx,
                 const char  *filename,      /* URL this script loads from */
                 uintN       lineno,         /* line where this script starts */
                 JSScript    *script,
@@ -589,11 +589,11 @@ jsd_NewScriptHookProc(
 
     if( hook )
         hook(jsdc, jsdscript, JS_TRUE, hookData);
 }                
 
-void JS_DLL_CALLBACK
+void
 jsd_DestroyScriptHookProc( 
                 JSContext   *cx,
                 JSScript    *script,
                 void*       callerdata )
 {
@@ -689,11 +689,11 @@ _isActiveHook(JSDContext* jsdc, JSScript
     JSD_UNLOCK_SCRIPTS(jsdc);
     return JS_FALSE;
 }
 
 
-JSTrapStatus JS_DLL_CALLBACK
+JSTrapStatus
 jsd_TrapHandler(JSContext *cx, JSScript *script, jsbytecode *pc, jsval *rval,
                 void *closure)
 {
     JSDExecHook* jsdhook = (JSDExecHook*) JSVAL_TO_PRIVATE(((jsval)closure));
     JSD_ExecutionHookProc hook;
diff -r 14ce7619e9c1 js/jsd/jsd_step.c
--- a/js/jsd/jsd_step.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/jsd/jsd_step.c	Mon Sep 08 10:35:45 2008 +0300
@@ -264,11 +264,11 @@ _callHook(JSDContext *jsdc, JSContext *c
     return hookresult;
 #endif
 
 }
 
-void * JS_DLL_CALLBACK
+void *
 jsd_FunctionCallHook(JSContext *cx, JSStackFrame *fp, JSBool before,
                      JSBool *ok, void *closure)
 {
     JSDContext*       jsdc;
     JSD_CallHookProc  hook;
@@ -290,11 +290,11 @@ jsd_FunctionCallHook(JSContext *cx, JSSt
     }
     
     return NULL;
 }
 
-void * JS_DLL_CALLBACK
+void *
 jsd_TopLevelCallHook(JSContext *cx, JSStackFrame *fp, JSBool before,
                      JSBool *ok, void *closure)
 {
     JSDContext*       jsdc;
     JSD_CallHookProc  hook;
diff -r 14ce7619e9c1 js/jsd/jsd_xpc.cpp
--- a/js/jsd/jsd_xpc.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/jsd/jsd_xpc.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -106,11 +106,11 @@
 #define AUTOREG_CATEGORY  "xpcom-autoregistration"
 #define APPSTART_CATEGORY "app-startup"
 #define JSD_AUTOREG_ENTRY "JSDebugger Startup Observer"
 #define JSD_STARTUP_ENTRY "JSDebugger Startup Observer"
 
-JS_STATIC_DLL_CALLBACK (JSBool)
+static JSBool
 jsds_GCCallbackProc (JSContext *cx, JSGCStatus status);
 
 /*******************************************************************************
  * global vars
  ******************************************************************************/
@@ -459,11 +459,11 @@ jsds_FilterHook (JSDContext *jsdc, JSDTh
 
 /*******************************************************************************
  * c callbacks
  *******************************************************************************/
 
-JS_STATIC_DLL_CALLBACK (void)
+static void
 jsds_NotifyPendingDeadScripts (JSContext *cx)
 {
 #ifdef CAUTIOUS_SCRIPTHOOK
     JSRuntime *rt = JS_GetRuntime(cx);
 #endif
@@ -511,11 +511,11 @@ jsds_NotifyPendingDeadScripts (JSContext
         jsds->UnPause(nsnull);
         NS_RELEASE(jsds);
     }
 }
 
-JS_STATIC_DLL_CALLBACK (JSBool)
+static JSBool
 jsds_GCCallbackProc (JSContext *cx, JSGCStatus status)
 {
 #ifdef DEBUG_verbose
     printf ("new gc status is %i\n", status);
 #endif
@@ -531,11 +531,11 @@ jsds_GCCallbackProc (JSContext *cx, JSGC
         return gLastGCProc (cx, status);
     
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK (uintN)
+static uintN
 jsds_ErrorHookProc (JSDContext *jsdc, JSContext *cx, const char *message,
                     JSErrorReport *report, void *callerdata)
 {
     static PRBool running = PR_FALSE;
 
@@ -588,11 +588,11 @@ jsds_ErrorHookProc (JSDContext *jsdc, JS
         return JSD_ERROR_REPORTER_DEBUG;
     
     return JSD_ERROR_REPORTER_PASS_ALONG;
 }
 
-JS_STATIC_DLL_CALLBACK (JSBool)
+static JSBool
 jsds_CallHookProc (JSDContext* jsdc, JSDThreadState* jsdthreadstate,
                    uintN type, void* callerdata)
 {
     nsCOMPtr<jsdICallHook> hook;
 
@@ -628,11 +628,11 @@ jsds_CallHookProc (JSDContext* jsdc, JSD
     jsdStackFrame::InvalidateAll();
 
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK (PRUint32)
+static PRUint32
 jsds_ExecutionHookProc (JSDContext* jsdc, JSDThreadState* jsdthreadstate,
                         uintN type, void* callerdata, jsval* rval)
 {
     nsCOMPtr<jsdIExecutionHook> hook(0);
     PRUint32 hook_rv = JSD_HOOK_RETURN_CONTINUE;
@@ -704,11 +704,11 @@ jsds_ExecutionHookProc (JSDContext* jsdc
     }
     
     return hook_rv;
 }
 
-JS_STATIC_DLL_CALLBACK (void)
+static void
 jsds_ScriptHookProc (JSDContext* jsdc, JSDScript* jsdscript, JSBool creating,
                      void* callerdata)
 {
 #ifdef CAUTIOUS_SCRIPTHOOK
     JSContext *cx = JSD_GetDefaultJSContext(jsdc);
diff -r 14ce7619e9c1 js/jsd/jsdebug.h
--- a/js/jsd/jsdebug.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/jsd/jsdebug.h	Mon Sep 08 10:35:45 2008 +0300
@@ -106,11 +106,11 @@ typedef struct JSDObject         JSDObje
 * turned on or off. This is especially useful in the Java-based debugging
 * system used in mozilla because the debugger applet controls starting
 * up the JSD system.
 */
 typedef void
-(* JS_DLL_CALLBACK JSD_SetContextProc)(JSDContext* jsdc, void* user);
+(* JSD_SetContextProc)(JSDContext* jsdc, void* user);
 
 /* This struct could have more fields in future versions */
 typedef struct
 {
     uintN              size;       /* size of this struct (init before use)*/
@@ -432,14 +432,14 @@ JSD_GetScriptLineExtent(JSDContext* jsdc
 * 'creating' is JS_TRUE if creating new script, JS_FALSE if destroying existing
 * script (callback called just before actual destruction).
 * 'callerdata' is what was passed to JSD_SetScriptHook to set the hook.
 */
 typedef void
-(* JS_DLL_CALLBACK JSD_ScriptHookProc)(JSDContext* jsdc,
-                                       JSDScript*  jsdscript,
-                                       JSBool      creating,
-                                       void*       callerdata);
+(* JSD_ScriptHookProc)(JSDContext* jsdc,
+                       JSDScript*  jsdscript,
+                       JSBool      creating,
+                       void*       callerdata);
 
 /*
 * Set a hook to be called when scripts are created or destroyed (loaded or
 * unloaded).
 * 'callerdata' can be whatever you want it to be.
@@ -711,15 +711,15 @@ JSD_AddFullSourceText(JSDContext* jsdc,
 
 /*
 * Implement a callback of this form in order to hook execution.
 */
 typedef uintN
-(* JS_DLL_CALLBACK JSD_ExecutionHookProc)(JSDContext*     jsdc,
-                                          JSDThreadState* jsdthreadstate,
-                                          uintN           type,
-                                          void*           callerdata,
-                                          jsval*          rval);
+(* JSD_ExecutionHookProc)(JSDContext*     jsdc,
+                          JSDThreadState* jsdthreadstate,
+                          uintN           type,
+                          void*           callerdata,
+                          jsval*          rval);
 
 /* possible 'type' params for JSD_CallHookProc */
 #define JSD_HOOK_TOPLEVEL_START  0   /* about to evaluate top level script */
 #define JSD_HOOK_TOPLEVEL_END    1   /* done evaluting top level script    */
 #define JSD_HOOK_FUNCTION_CALL   2   /* about to call a function           */
@@ -730,14 +730,14 @@ typedef uintN
 * Return JS_TRUE from a TOPLEVEL_START or FUNCTION_CALL type call hook if you
 * want to hear about the TOPLEVEL_END or FUNCTION_RETURN too.  Return value is
 * ignored to TOPLEVEL_END and FUNCTION_RETURN type hooks.
 */
 typedef JSBool
-(* JS_DLL_CALLBACK JSD_CallHookProc)(JSDContext*     jsdc,
-                                     JSDThreadState* jsdthreadstate,
-                                     uintN           type,
-                                     void*           callerdata);
+(* JSD_CallHookProc)(JSDContext*     jsdc,
+                     JSDThreadState* jsdthreadstate,
+                     uintN           type,
+                     void*           callerdata);
 
 /*
 * Set Hook to be called whenever the given pc is about to be executed --
 * i.e. for 'trap' or 'breakpoint'
 */
@@ -1048,15 +1048,15 @@ JSD_SetException(JSDContext* jsdc, JSDTh
 
 /*
 * Implement a callback of this form in order to hook the ErrorReporter
 */
 typedef uintN
-(* JS_DLL_CALLBACK JSD_ErrorReporter)(JSDContext*     jsdc,
-                                      JSContext*      cx,
-                                      const char*     message,
-                                      JSErrorReport*  report,
-                                      void*           callerdata);
+(* JSD_ErrorReporter)(JSDContext*     jsdc,
+                      JSContext*      cx,
+                      const char*     message,
+                      JSErrorReport*  report,
+                      void*           callerdata);
 
 /* Set ErrorReporter hook */
 extern JSD_PUBLIC_API(JSBool)
 JSD_SetErrorReporter(JSDContext*       jsdc,
                      JSD_ErrorReporter reporter,
diff -r 14ce7619e9c1 js/src/js.cpp
--- a/js/src/js.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/js.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -2119,11 +2119,11 @@ split_create_inner(JSContext *cx, JSObje
 split_create_inner(JSContext *cx, JSObject *outer);
 
 static ComplexObject *
 split_get_private(JSContext *cx, JSObject *obj);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 split_addProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 {
     ComplexObject *cpx;
     jsid asId;
 
@@ -2138,11 +2138,11 @@ split_addProperty(JSContext *cx, JSObjec
                                    JSPROP_ENUMERATE, NULL);
     }
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 split_getProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 {
     ComplexObject *cpx;
 
     cpx = split_get_private(cx, obj);
@@ -2162,11 +2162,11 @@ split_getProperty(JSContext *cx, JSObjec
     }
 
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 split_setProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 {
     ComplexObject *cpx;
 
     cpx = split_get_private(cx, obj);
@@ -2186,11 +2186,11 @@ split_setProperty(JSContext *cx, JSObjec
     }
 
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 split_delProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 {
     ComplexObject *cpx;
     jsid asId;
 
@@ -2204,11 +2204,11 @@ split_delProperty(JSContext *cx, JSObjec
         return OBJ_DELETE_PROPERTY(cx, cpx->inner, asId, vp);
     }
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 split_enumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op,
                   jsval *statep, jsid *idp)
 {
     ComplexObject *cpx;
     JSObject *iterator;
@@ -2245,11 +2245,11 @@ split_enumerate(JSContext *cx, JSObject 
     }
 
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 split_resolve(JSContext *cx, JSObject *obj, jsval id, uintN flags,
                 JSObject **objp)
 {
     ComplexObject *cpx;
 
@@ -2287,17 +2287,17 @@ split_resolve(JSContext *cx, JSObject *o
 
     /* XXX For additional realism, let's resolve some random property here. */
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 split_finalize(JSContext *cx, JSObject *obj)
 {
     JS_free(cx, JS_GetPrivate(cx, obj));
 }
 
-JS_STATIC_DLL_CALLBACK(uint32)
+static uint32
 split_mark(JSContext *cx, JSObject *obj, void *arg)
 {
     ComplexObject *cpx;
 
     cpx = (ComplexObject *) JS_GetPrivate(cx, obj);
@@ -2308,20 +2308,20 @@ split_mark(JSContext *cx, JSObject *obj,
     }
 
     return 0;
 }
 
-JS_STATIC_DLL_CALLBACK(JSObject *)
+static JSObject *
 split_outerObject(JSContext *cx, JSObject *obj)
 {
     ComplexObject *cpx;
 
     cpx = (ComplexObject *) JS_GetPrivate(cx, obj);
     return cpx->isInner ? cpx->outer : obj;
 }
 
-JS_STATIC_DLL_CALLBACK(JSObject *)
+static JSObject *
 split_innerObject(JSContext *cx, JSObject *obj)
 {
     ComplexObject *cpx;
 
     cpx = (ComplexObject *) JS_GetPrivate(cx, obj);
diff -r 14ce7619e9c1 js/src/jsapi.cpp
--- a/js/src/jsapi.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/jsapi.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -4309,11 +4309,11 @@ JS_ObjectIsFunction(JSContext *cx, JSObj
 {
     return OBJ_GET_CLASS(cx, obj) == &js_FunctionClass;
 }
 
 JS_BEGIN_EXTERN_C
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 js_generic_fast_native_method_dispatcher(JSContext *cx, uintN argc, jsval *vp)
 {
     jsval fsv;
     JSFunctionSpec *fs;
     JSObject *tmp;
@@ -4362,11 +4362,11 @@ js_generic_fast_native_method_dispatcher
         --argc;
 
     return ((JSFastNative) fs->call)(cx, argc, vp);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 js_generic_native_method_dispatcher(JSContext *cx, JSObject *obj,
                                     uintN argc, jsval *argv, jsval *rval)
 {
     jsval fsv;
     JSFunctionSpec *fs;
diff -r 14ce7619e9c1 js/src/jsapi.h
--- a/js/src/jsapi.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/jsapi.h	Mon Sep 08 10:35:45 2008 +0300
@@ -889,11 +889,11 @@ JS_DumpNamedRoots(JSRuntime *rt,
 #define JS_MAP_GCROOT_NEXT      0       /* continue mapping entries */
 #define JS_MAP_GCROOT_STOP      1       /* stop mapping entries */
 #define JS_MAP_GCROOT_REMOVE    2       /* remove and free the current entry */
 
 typedef intN
-(* JS_DLL_CALLBACK JSGCRootMapFun)(void *rp, const char *name, void *data);
+(* JSGCRootMapFun)(void *rp, const char *name, void *data);
 
 extern JS_PUBLIC_API(uint32)
 JS_MapGCRoots(JSRuntime *rt, JSGCRootMapFun map, void *data);
 
 extern JS_PUBLIC_API(JSBool)
@@ -1807,18 +1807,18 @@ JS_SetReservedSlot(JSContext *cx, JSObje
  */
 struct JSPrincipals {
     char *codebase;
 
     /* XXX unspecified and unused by Mozilla code -- can we remove these? */
-    void * (* JS_DLL_CALLBACK getPrincipalArray)(JSContext *cx, JSPrincipals *);
-    JSBool (* JS_DLL_CALLBACK globalPrivilegesEnabled)(JSContext *cx, JSPrincipals *);
+    void * (* getPrincipalArray)(JSContext *cx, JSPrincipals *);
+    JSBool (* globalPrivilegesEnabled)(JSContext *cx, JSPrincipals *);
 
     /* Don't call "destroy"; use reference counting macros below. */
     jsrefcount refcount;
 
-    void   (* JS_DLL_CALLBACK destroy)(JSContext *cx, JSPrincipals *);
-    JSBool (* JS_DLL_CALLBACK subsume)(JSPrincipals *, JSPrincipals *);
+    void   (* destroy)(JSContext *cx, JSPrincipals *);
+    JSBool (* subsume)(JSPrincipals *, JSPrincipals *);
 };
 
 #ifdef JS_THREADSAFE
 #define JSPRINCIPALS_HOLD(cx, principals)   JS_HoldPrincipals(cx,principals)
 #define JSPRINCIPALS_DROP(cx, principals)   JS_DropPrincipals(cx,principals)
diff -r 14ce7619e9c1 js/src/jsatom.cpp
--- a/js/src/jsatom.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/jsatom.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -239,20 +239,20 @@ JS_STATIC_ASSERT(ATOM_ENTRY_FLAG_MASK < 
 #define ADD_ATOM_ENTRY_FLAGS(entry, flags)                                    \
     ((void)((entry)->keyAndFlags |= (jsuword)(flags)))
 #define CLEAR_ATOM_ENTRY_FLAGS(entry, flags)                                  \
     ((void)((entry)->keyAndFlags &= ~(jsuword)(flags)))
 
-JS_STATIC_DLL_CALLBACK(JSDHashNumber)
+static JSDHashNumber
 HashDouble(JSDHashTable *table, const void *key);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 MatchDouble(JSDHashTable *table, const JSDHashEntryHdr *hdr, const void *key);
 
-JS_STATIC_DLL_CALLBACK(JSDHashNumber)
+static JSDHashNumber
 HashString(JSDHashTable *table, const void *key);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 MatchString(JSDHashTable *table, const JSDHashEntryHdr *hdr, const void *key);
 
 static const JSDHashTableOps DoubleHashOps = {
     JS_DHashAllocTable,
     JS_DHashFreeTable,
@@ -278,28 +278,28 @@ static const JSDHashTableOps StringHashO
 #define IS_DOUBLE_TABLE(table)      ((table)->ops == &DoubleHashOps)
 #define IS_STRING_TABLE(table)      ((table)->ops == &StringHashOps)
 
 #define IS_INITIALIZED_STATE(state) IS_DOUBLE_TABLE(&(state)->doubleAtoms)
 
-JS_STATIC_DLL_CALLBACK(JSDHashNumber)
+static JSDHashNumber
 HashDouble(JSDHashTable *table, const void *key)
 {
     jsdouble d;
 
     JS_ASSERT(IS_DOUBLE_TABLE(table));
     d = *(jsdouble *)key;
     return JSDOUBLE_HI32(d) ^ JSDOUBLE_LO32(d);
 }
 
-JS_STATIC_DLL_CALLBACK(JSDHashNumber)
+static JSDHashNumber
 HashString(JSDHashTable *table, const void *key)
 {
     JS_ASSERT(IS_STRING_TABLE(table));
     return js_HashString((JSString *)key);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 MatchDouble(JSDHashTable *table, const JSDHashEntryHdr *hdr, const void *key)
 {
     JSAtomHashEntry *entry = TO_ATOM_ENTRY(hdr);
     jsdouble d1, d2;
 
@@ -319,11 +319,11 @@ MatchDouble(JSDHashTable *table, const J
         return JS_FALSE;
 #endif
     return d1 == d2;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 MatchString(JSDHashTable *table, const JSDHashEntryHdr *hdr, const void *key)
 {
     JSAtomHashEntry *entry = TO_ATOM_ENTRY(hdr);
 
     JS_ASSERT(IS_STRING_TABLE(table));
@@ -388,11 +388,11 @@ js_InitAtomState(JSRuntime *rt)
 #endif
     JS_ASSERT(IS_INITIALIZED_STATE(state));
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 js_string_uninterner(JSDHashTable *table, JSDHashEntryHdr *hdr,
                      uint32 number, void *arg)
 {
     JSAtomHashEntry *entry = TO_ATOM_ENTRY(hdr);
     JSRuntime *rt = (JSRuntime *)arg;
@@ -454,11 +454,11 @@ js_InitCommonAtoms(JSContext *cx)
     memset(atoms, 0, ATOM_OFFSET_LIMIT - LAZY_ATOM_OFFSET_START);
 
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 js_atom_unpinner(JSDHashTable *table, JSDHashEntryHdr *hdr,
                  uint32 number, void *arg)
 {
     JS_ASSERT(IS_STRING_TABLE(table));
     CLEAR_ATOM_ENTRY_FLAGS(TO_ATOM_ENTRY(hdr), ATOM_PINNED);
@@ -475,11 +475,11 @@ js_FinishCommonAtoms(JSContext *cx)
     memset(COMMON_ATOMS_START(state), JS_FREE_PATTERN,
            ATOM_OFFSET_LIMIT - ATOM_OFFSET_START);
 #endif
 }
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 js_locked_atom_tracer(JSDHashTable *table, JSDHashEntryHdr *hdr,
                       uint32 number, void *arg)
 {
     JSAtomHashEntry *entry = TO_ATOM_ENTRY(hdr);
     JSTracer *trc = (JSTracer *)arg;
@@ -492,11 +492,11 @@ js_locked_atom_tracer(JSDHashTable *tabl
     JS_CallTracer(trc, ATOM_ENTRY_KEY(entry),
                   IS_STRING_TABLE(table) ? JSTRACE_STRING : JSTRACE_DOUBLE);
     return JS_DHASH_NEXT;
 }
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 js_pinned_atom_tracer(JSDHashTable *table, JSDHashEntryHdr *hdr,
                         uint32 number, void *arg)
 {
     JSAtomHashEntry *entry = TO_ATOM_ENTRY(hdr);
     JSTracer *trc = (JSTracer *)arg;
@@ -526,11 +526,11 @@ js_TraceAtomState(JSTracer *trc, JSBool 
     } else {
         JS_DHashTableEnumerate(&state->stringAtoms, js_pinned_atom_tracer, trc);
     }
 }
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 js_atom_sweeper(JSDHashTable *table, JSDHashEntryHdr *hdr,
                 uint32 number, void *arg)
 {
     JSAtomHashEntry *entry = TO_ATOM_ENTRY(hdr);
     JSContext *cx = (JSContext *)arg;
@@ -830,11 +830,11 @@ js_ValueToStringId(JSContext *cx, jsval 
     return JS_TRUE;
 }
 
 #ifdef DEBUG
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 atom_dumper(JSDHashTable *table, JSDHashEntryHdr *hdr,
             uint32 number, void *arg)
 {
     JSAtomHashEntry *entry = TO_ATOM_ENTRY(hdr);
     FILE *fp = (FILE *)arg;
@@ -884,18 +884,18 @@ js_DumpAtoms(JSContext *cx, FILE *fp)
     putc('\n', fp);
 }
 
 #endif
 
-JS_STATIC_DLL_CALLBACK(JSHashNumber)
+static JSHashNumber
 js_hash_atom_ptr(const void *key)
 {
     const JSAtom *atom = (const JSAtom *) key;
     return ATOM_HASH(atom);
 }
 
-JS_STATIC_DLL_CALLBACK(void *)
+static void *
 js_alloc_temp_space(void *priv, size_t size)
 {
     JSContext *cx = (JSContext *) priv;
     void *space;
 
@@ -903,16 +903,16 @@ js_alloc_temp_space(void *priv, size_t s
     if (!space)
         js_ReportOutOfScriptQuota(cx);
     return space;
 }
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 js_free_temp_space(void *priv, void *item)
 {
 }
 
-JS_STATIC_DLL_CALLBACK(JSHashEntry *)
+static JSHashEntry *
 js_alloc_temp_entry(void *priv, const void *key)
 {
     JSContext *cx = (JSContext *) priv;
     JSAtomListElement *ale;
 
@@ -922,11 +922,11 @@ js_alloc_temp_entry(void *priv, const vo
         return NULL;
     }
     return &ale->entry;
 }
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 js_free_temp_entry(void *priv, JSHashEntry *he, uintN flag)
 {
 }
 
 static JSHashAllocOps temp_alloc_ops = {
@@ -994,11 +994,11 @@ js_IndexAtom(JSContext *cx, JSAtom *atom
         ALE_SET_INDEX(ale, al->count++);
     }
     return ale;
 }
 
-JS_STATIC_DLL_CALLBACK(intN)
+static intN
 js_map_atom(JSHashEntry *he, intN i, void *arg)
 {
     JSAtomListElement *ale = (JSAtomListElement *)he;
     JSAtom **vector = (JSAtom **) arg;
 
diff -r 14ce7619e9c1 js/src/jscntxt.cpp
--- a/js/src/jscntxt.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/jscntxt.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -80,11 +80,11 @@ static PRUintn threadTPIndex;
 static PRUintn threadTPIndex;
 static JSBool  tpIndexInited = JS_FALSE;
 
 JS_BEGIN_EXTERN_C
 JSBool
-js_InitThreadPrivateIndex(void (JS_DLL_CALLBACK *ptr)(void *))
+js_InitThreadPrivateIndex(void (*ptr)(void *))
 {
     PRStatus status;
 
     if (tpIndexInited)
         return JS_TRUE;
@@ -99,11 +99,11 @@ JS_END_EXTERN_C
 
 /*
  * Callback function to delete a JSThread info when the thread that owns it
  * is destroyed.
  */
-void JS_DLL_CALLBACK
+void
 js_ThreadDestructorCB(void *ptr)
 {
     JSThread *thread = (JSThread *)ptr;
 
     if (!thread)
@@ -519,11 +519,11 @@ js_ContextIterator(JSRuntime *rt, JSBool
     if (unlocked)
         JS_UNLOCK_GC(rt);
     return cx;
 }
 
-JS_STATIC_DLL_CALLBACK(JSDHashNumber)
+static JSDHashNumber
 resolving_HashKey(JSDHashTable *table, const void *ptr)
 {
     const JSResolvingKey *key = (const JSResolvingKey *)ptr;
 
     return ((JSDHashNumber)JS_PTR_TO_UINT32(key->obj) >> JSVAL_TAGBITS) ^ key->id;
diff -r 14ce7619e9c1 js/src/jscntxt.h
--- a/js/src/jscntxt.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/jscntxt.h	Mon Sep 08 10:35:45 2008 +0300
@@ -191,11 +191,11 @@ struct JSThread {
 #define JS_GSN_CACHE(cx)        ((cx)->thread->gsnCache)
 #define JS_PROPERTY_CACHE(cx)   ((cx)->thread->propertyCache)
 #define JS_TRACE_MONITOR(cx)    ((cx)->thread->traceMonitor)
 #define JS_SCRIPTS_TO_GC(cx)    ((cx)->thread->scriptsToGC)
 
-extern void JS_DLL_CALLBACK
+extern void
 js_ThreadDestructorCB(void *ptr);
 
 extern JSBool
 js_SetContextThread(JSContext *cx);
 
@@ -964,11 +964,11 @@ class JSAutoTempValueRooter
  * Initialize a library-wide thread private data index, and remember that it
  * has already been done, so that it happens only once ever.  Returns true on
  * success.
  */
 extern JSBool
-js_InitThreadPrivateIndex(void (JS_DLL_CALLBACK *ptr)(void *));
+js_InitThreadPrivateIndex(void (*ptr)(void *));
 
 /*
  * Common subroutine of JS_SetVersion and js_SetVersion, to update per-context
  * data that depends on version.
  */
diff -r 14ce7619e9c1 js/src/jsdbgapi.cpp
--- a/js/src/jsdbgapi.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/jsdbgapi.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -528,11 +528,11 @@ js_GetWatchedSetter(JSRuntime *rt, JSSco
     if (scope)
         DBG_UNLOCK(rt);
     return setter;
 }
 
-JSBool JS_DLL_CALLBACK
+JSBool
 js_watch_set(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 {
     JSRuntime *rt;
     JSWatchPoint *wp;
     JSScopeProperty *sprop;
@@ -672,11 +672,11 @@ js_watch_set(JSContext *cx, JSObject *ob
     }
     DBG_UNLOCK(rt);
     return JS_TRUE;
 }
 
-JSBool JS_DLL_CALLBACK
+JSBool
 js_watch_set_wrapper(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                      jsval *rval)
 {
     JSObject *funobj;
     JSFunction *wrapper;
diff -r 14ce7619e9c1 js/src/jsdbgapi.h
--- a/js/src/jsdbgapi.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/jsdbgapi.h	Mon Sep 08 10:35:45 2008 +0300
@@ -118,14 +118,14 @@ js_FindWatchPoint(JSRuntime *rt, JSScope
  */
 extern JSPropertyOp
 js_GetWatchedSetter(JSRuntime *rt, JSScope *scope,
                     const JSScopeProperty *sprop);
 
-extern JSBool JS_DLL_CALLBACK
+extern JSBool
 js_watch_set(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
 
-extern JSBool JS_DLL_CALLBACK
+extern JSBool
 js_watch_set_wrapper(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                      jsval *rval);
 
 extern JSPropertyOp
 js_WrapWatchedSetter(JSContext *cx, jsid id, uintN attrs, JSPropertyOp setter);
diff -r 14ce7619e9c1 js/src/jsdhash.h
--- a/js/src/jsdhash.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/jsdhash.h	Mon Sep 08 10:35:45 2008 +0300
@@ -236,70 +236,66 @@ struct JSDHashTable {
  * Table space at entryStore is allocated and freed using these callbacks.
  * The allocator should return null on error only (not if called with nbytes
  * equal to 0; but note that jsdhash.c code will never call with 0 nbytes).
  */
 typedef void *
-(* JS_DLL_CALLBACK JSDHashAllocTable)(JSDHashTable *table, uint32 nbytes);
+(* JSDHashAllocTable)(JSDHashTable *table, uint32 nbytes);
 
 typedef void
-(* JS_DLL_CALLBACK JSDHashFreeTable) (JSDHashTable *table, void *ptr);
+(* JSDHashFreeTable) (JSDHashTable *table, void *ptr);
 
 /*
  * Compute the hash code for a given key to be looked up, added, or removed
  * from table.  A hash code may have any JSDHashNumber value.
  */
 typedef JSDHashNumber
-(* JS_DLL_CALLBACK JSDHashHashKey)   (JSDHashTable *table, const void *key);
+(* JSDHashHashKey)   (JSDHashTable *table, const void *key);
 
 /*
  * Compare the key identifying entry in table with the provided key parameter.
  * Return JS_TRUE if keys match, JS_FALSE otherwise.
  */
 typedef JSBool
-(* JS_DLL_CALLBACK JSDHashMatchEntry)(JSDHashTable *table,
-                                      const JSDHashEntryHdr *entry,
-                                      const void *key);
+(* JSDHashMatchEntry)(JSDHashTable *table, const JSDHashEntryHdr *entry,
+                      const void *key);
 
 /*
  * Copy the data starting at from to the new entry storage at to.  Do not add
  * reference counts for any strong references in the entry, however, as this
  * is a "move" operation: the old entry storage at from will be freed without
  * any reference-decrementing callback shortly.
  */
 typedef void
-(* JS_DLL_CALLBACK JSDHashMoveEntry)(JSDHashTable *table,
-                                     const JSDHashEntryHdr *from,
-                                     JSDHashEntryHdr *to);
+(* JSDHashMoveEntry)(JSDHashTable *table, const JSDHashEntryHdr *from,
+                     JSDHashEntryHdr *to);
 
 /*
  * Clear the entry and drop any strong references it holds.  This callback is
  * invoked during a JS_DHASH_REMOVE operation (see below for operation codes),
  * but only if the given key is found in the table.
  */
 typedef void
-(* JS_DLL_CALLBACK JSDHashClearEntry)(JSDHashTable *table,
-                                      JSDHashEntryHdr *entry);
+(* JSDHashClearEntry)(JSDHashTable *table, JSDHashEntryHdr *entry);
 
 /*
  * Called when a table (whether allocated dynamically by itself, or nested in
  * a larger structure, or allocated on the stack) is finished.  This callback
  * allows table->ops-specific code to finalize table->data.
  */
 typedef void
-(* JS_DLL_CALLBACK JSDHashFinalize)  (JSDHashTable *table);
+(* JSDHashFinalize)  (JSDHashTable *table);
 
 /*
  * Initialize a new entry, apart from keyHash.  This function is called when
  * JS_DHashTableOperate's JS_DHASH_ADD case finds no existing entry for the
  * given key, and must add a new one.  At that point, entry->keyHash is not
  * set yet, to avoid claiming the last free entry in a severely overloaded
  * table.
  */
 typedef JSBool
-(* JS_DLL_CALLBACK JSDHashInitEntry)(JSDHashTable *table,
-                                     JSDHashEntryHdr *entry,
-                                     const void *key);
+(* JSDHashInitEntry)(JSDHashTable *table, JSDHashEntryHdr *entry,
+                     const void *key);
 
 /*
  * Finally, the "vtable" structure for JSDHashTable.  The first eight hooks
  * must be provided by implementations; they're called unconditionally by the
  * generic jsdhash.c code.  Hooks after these may be null.
@@ -572,12 +568,12 @@ JS_DHashTableRawRemove(JSDHashTable *tab
  * you want to remove entries, but for some reason you do not want entryStore
  * to be shrunk or compressed, you can call JS_DHashTableRawRemove safely on
  * the entry being enumerated, rather than returning JS_DHASH_REMOVE.
  */
 typedef JSDHashOperator
-(* JS_DLL_CALLBACK JSDHashEnumerator)(JSDHashTable *table, JSDHashEntryHdr *hdr,
-                                      uint32 number, void *arg);
+(* JSDHashEnumerator)(JSDHashTable *table, JSDHashEntryHdr *hdr, uint32 number,
+                      void *arg);
 
 extern JS_PUBLIC_API(uint32)
 JS_DHashTableEnumerate(JSDHashTable *table, JSDHashEnumerator etor, void *arg);
 
 #ifdef JS_DHASHMETER
diff -r 14ce7619e9c1 js/src/jsfun.cpp
--- a/js/src/jsfun.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/jsfun.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -2527,11 +2527,11 @@ typedef struct JSLocalNameEnumeratorArgs
     uintN           nCopiedArgs;
     uintN           nCopiedVars;
 #endif
 } JSLocalNameEnumeratorArgs;
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 get_local_names_enumerator(JSDHashTable *table, JSDHashEntryHdr *hdr,
                            uint32 number, void *arg)
 {
     JSLocalNameHashEntry *entry;
     JSLocalNameEnumeratorArgs *args;
@@ -2607,11 +2607,11 @@ js_GetLocalNameArray(JSContext *cx, JSFu
     JS_ASSERT(args.nCopiedVars == fun->u.i.nvars);
 
     return names;
 }
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 trace_local_names_enumerator(JSDHashTable *table, JSDHashEntryHdr *hdr,
                              uint32 number, void *arg)
 {
     JSLocalNameHashEntry *entry;
     JSTracer *trc;
diff -r 14ce7619e9c1 js/src/jsgc.cpp
--- a/js/src/jsgc.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/jsgc.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -1508,11 +1508,11 @@ js_RemoveRoot(JSRuntime *rt, void *rp)
     return JS_TRUE;
 }
 
 #ifdef DEBUG
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 js_root_printer(JSDHashTable *table, JSDHashEntryHdr *hdr, uint32 i, void *arg)
 {
     uint32 *leakedroots = (uint32 *)arg;
     JSGCRootHashEntry *rhe = (JSGCRootHashEntry *)hdr;
 
@@ -1552,11 +1552,11 @@ typedef struct NamedRootDumpArgs {
 typedef struct NamedRootDumpArgs {
     void (*dump)(const char *name, void *rp, void *data);
     void *data;
 } NamedRootDumpArgs;
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 js_named_root_dumper(JSDHashTable *table, JSDHashEntryHdr *hdr, uint32 number,
                      void *arg)
 {
     NamedRootDumpArgs *args = (NamedRootDumpArgs *) arg;
     JSGCRootHashEntry *rhe = (JSGCRootHashEntry *)hdr;
@@ -1585,11 +1585,11 @@ typedef struct GCRootMapArgs {
 typedef struct GCRootMapArgs {
     JSGCRootMapFun map;
     void *data;
 } GCRootMapArgs;
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 js_gcroot_mapper(JSDHashTable *table, JSDHashEntryHdr *hdr, uint32 number,
                  void *arg)
 {
     GCRootMapArgs *args = (GCRootMapArgs *) arg;
     JSGCRootHashEntry *rhe = (JSGCRootHashEntry *)hdr;
@@ -2592,11 +2592,11 @@ js_CallValueTracerIfGCThing(JSTracer *tr
         return;
     }
     JS_CallTracer(trc, thing, kind);
 }
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 gc_root_traversal(JSDHashTable *table, JSDHashEntryHdr *hdr, uint32 num,
                   void *arg)
 {
     JSGCRootHashEntry *rhe = (JSGCRootHashEntry *)hdr;
     JSTracer *trc = (JSTracer *)arg;
@@ -2651,11 +2651,11 @@ gc_root_traversal(JSDHashTable *table, J
     }
 
     return JS_DHASH_NEXT;
 }
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 gc_lock_traversal(JSDHashTable *table, JSDHashEntryHdr *hdr, uint32 num,
                   void *arg)
 {
     JSGCLockHashEntry *lhe = (JSGCLockHashEntry *)hdr;
     void *thing = (void *)lhe->thing;
diff -r 14ce7619e9c1 js/src/jshash.h
--- a/js/src/jshash.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/jshash.h	Mon Sep 08 10:35:45 2008 +0300
@@ -54,13 +54,13 @@ typedef struct JSHashTable JSHashTable;
 typedef struct JSHashTable JSHashTable;
 
 #define JS_HASH_BITS 32
 #define JS_GOLDEN_RATIO 0x9E3779B9U
 
-typedef JSHashNumber (* JS_DLL_CALLBACK JSHashFunction)(const void *key);
-typedef intN (* JS_DLL_CALLBACK JSHashComparator)(const void *v1, const void *v2);
-typedef intN (* JS_DLL_CALLBACK JSHashEnumerator)(JSHashEntry *he, intN i, void *arg);
+typedef JSHashNumber (* JSHashFunction)(const void *key);
+typedef intN (* JSHashComparator)(const void *v1, const void *v2);
+typedef intN (* JSHashEnumerator)(JSHashEntry *he, intN i, void *arg);
 
 /* Flag bits in JSHashEnumerator's return value */
 #define HT_ENUMERATE_NEXT       0       /* continue enumerating entries */
 #define HT_ENUMERATE_STOP       1       /* stop enumerating entries */
 #define HT_ENUMERATE_REMOVE     2       /* remove and free the current entry */
diff -r 14ce7619e9c1 js/src/jsify.pl
--- a/js/src/jsify.pl	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/jsify.pl	Mon Sep 08 10:35:45 2008 +0300
@@ -416,12 +416,10 @@ sub convert_declarations {
 sub convert_declarations {
     ($line) = @_;
     $line =~ s/PR_EXTERN/JS_EXTERN_API/g;
     $line =~ s/PR_IMPLEMENT_DATA/JS_EXPORT_DATA/g;
     $line =~ s/PR_IMPLEMENT/JS_EXPORT_API/g;
-    $line =~ s/PR_CALLBACK/JS_DLL_CALLBACK/g;
-    $line =~ s/PR_STATIC_CALLBACK/JS_STATIC_DLL_CALLBACK/g;
     $line =~ s/PR_IMPORT/JS_IMPORT/g;
     $line =~ s/PR_PUBLIC_API/JS_EXPORT_API/g;
     $line =~ s/PR_PUBLIC_DATA/JS_EXPORT_DATA/g;
     return $line;
 }    
diff -r 14ce7619e9c1 js/src/jsobj.cpp
--- a/js/src/jsobj.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/jsobj.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -325,11 +325,11 @@ js_SetProtoOrParent(JSContext *cx, JSObj
         return JS_FALSE;
     }
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSHashNumber)
+static JSHashNumber
 js_hash_object(const void *key)
 {
     return (JSHashNumber)JS_PTR_TO_UINT32(key) >> JSVAL_TAGBITS;
 }
 
@@ -568,11 +568,11 @@ js_LeaveSharpObject(JSContext *cx, JSIdA
             *idap = NULL;
         }
     }
 }
 
-JS_STATIC_DLL_CALLBACK(intN)
+static intN
 gc_sharp_table_entry_marker(JSHashEntry *he, intN i, void *arg)
 {
     JS_CALL_OBJECT_TRACER((JSTracer *)arg, (JSObject *)he->key,
                           "sharp table entry");
     return JS_DHASH_NEXT;
@@ -2675,11 +2675,11 @@ earlybad:
     return NULL;
 }
 
 JS_BEGIN_EXTERN_C
 
-JS_STATIC_DLL_CALLBACK(JSObject *)
+static JSObject *
 js_InitNullClass(JSContext *cx, JSObject *obj)
 {
     JS_ASSERT(0);
     return NULL;
 }
diff -r 14ce7619e9c1 js/src/jsparse.cpp
--- a/js/src/jsparse.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/jsparse.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -1849,11 +1849,11 @@ typedef struct FindPropValEntry {
     JS_ASSERT((pnkey)->pn_arity == PN_NULLARY &&                              \
               ((pnkey)->pn_type == TOK_NUMBER ||                              \
                (pnkey)->pn_type == TOK_STRING ||                              \
                (pnkey)->pn_type == TOK_NAME))
 
-JS_STATIC_DLL_CALLBACK(JSDHashNumber)
+static JSDHashNumber
 HashFindPropValKey(JSDHashTable *table, const void *key)
 {
     const JSParseNode *pnkey = (const JSParseNode *)key;
 
     ASSERT_VALID_PROPERTY_KEY(pnkey);
@@ -1861,11 +1861,11 @@ HashFindPropValKey(JSDHashTable *table, 
            ? (JSDHashNumber) (JSDOUBLE_HI32(pnkey->pn_dval) ^
                               JSDOUBLE_LO32(pnkey->pn_dval))
            : ATOM_HASH(pnkey->pn_atom);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 MatchFindPropValEntry(JSDHashTable *table,
                       const JSDHashEntryHdr *entry,
                       const void *key)
 {
     const FindPropValEntry *fpve = (const FindPropValEntry *)entry;
diff -r 14ce7619e9c1 js/src/jsprvtd.h
--- a/js/src/jsprvtd.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/jsprvtd.h	Mon Sep 08 10:35:45 2008 +0300
@@ -136,36 +136,35 @@ typedef enum JSTrapStatus {
     JSTRAP_THROW,
     JSTRAP_LIMIT
 } JSTrapStatus;
 
 typedef JSTrapStatus
-(* JS_DLL_CALLBACK JSTrapHandler)(JSContext *cx, JSScript *script,
-                                  jsbytecode *pc, jsval *rval, void *closure);
+(* JSTrapHandler)(JSContext *cx, JSScript *script, jsbytecode *pc, jsval *rval,
+                  void *closure);
 
 typedef JSBool
-(* JS_DLL_CALLBACK JSWatchPointHandler)(JSContext *cx, JSObject *obj, jsval id,
-                                        jsval old, jsval *newp, void *closure);
+(* JSWatchPointHandler)(JSContext *cx, JSObject *obj, jsval id, jsval old,
+                        jsval *newp, void *closure);
 
 /* called just after script creation */
 typedef void
-(* JS_DLL_CALLBACK JSNewScriptHook)(JSContext  *cx,
-                                    const char *filename,  /* URL of script */
-                                    uintN      lineno,     /* first line */
-                                    JSScript   *script,
-                                    JSFunction *fun,
-                                    void       *callerdata);
+(* JSNewScriptHook)(JSContext  *cx,
+                    const char *filename,  /* URL of script */
+                    uintN      lineno,     /* first line */
+                    JSScript   *script,
+                    JSFunction *fun,
+                    void       *callerdata);
 
 /* called just before script destruction */
 typedef void
-(* JS_DLL_CALLBACK JSDestroyScriptHook)(JSContext *cx,
-                                        JSScript  *script,
-                                        void      *callerdata);
+(* JSDestroyScriptHook)(JSContext *cx,
+                        JSScript  *script,
+                        void      *callerdata);
 
 typedef void
-(* JS_DLL_CALLBACK JSSourceHandler)(const char *filename, uintN lineno,
-                                    jschar *str, size_t length,
-                                    void **listenerTSData, void *closure);
+(* JSSourceHandler)(const char *filename, uintN lineno, jschar *str,
+                    size_t length, void **listenerTSData, void *closure);
 
 /*
  * This hook captures high level script execution and function calls (JS or
  * native).  It is used by JS_SetExecuteHook to hook top level scripts and by
  * JS_SetCallHook to hook function calls.  It will get called twice per script
@@ -189,20 +188,19 @@ typedef void
  *
  * Returning NULL in the 'before' hook will cause the 'after' hook *not* to
  * be called.
  */
 typedef void *
-(* JS_DLL_CALLBACK JSInterpreterHook)(JSContext *cx, JSStackFrame *fp, JSBool before,
-                                      JSBool *ok, void *closure);
+(* JSInterpreterHook)(JSContext *cx, JSStackFrame *fp, JSBool before,
+                      JSBool *ok, void *closure);
 
 typedef void
-(* JS_DLL_CALLBACK JSObjectHook)(JSContext *cx, JSObject *obj, JSBool isNew,
-                                 void *closure);
+(* JSObjectHook)(JSContext *cx, JSObject *obj, JSBool isNew, void *closure);
 
 typedef JSBool
-(* JS_DLL_CALLBACK JSDebugErrorHook)(JSContext *cx, const char *message,
-                                     JSErrorReport *report, void *closure);
+(* JSDebugErrorHook)(JSContext *cx, const char *message, JSErrorReport *report,
+                     void *closure);
 
 typedef struct JSDebugHooks {
     JSTrapHandler       interruptHandler;
     void                *interruptHandlerData;
     JSNewScriptHook     newScriptHook;
@@ -228,11 +226,11 @@ typedef struct JSDebugHooks {
 /*
  * Type definitions for temporary GC roots that register with GC local C
  * variables. See jscntxt.h for details.
  */
 typedef void
-(* JS_DLL_CALLBACK JSTempValueTrace)(JSTracer *trc, JSTempValueRooter *tvr);
+(* JSTempValueTrace)(JSTracer *trc, JSTempValueRooter *tvr);
 
 typedef union JSTempValueUnion {
     jsval               value;
     JSObject            *object;
     JSString            *string;
diff -r 14ce7619e9c1 js/src/jspubtd.h
--- a/js/src/jspubtd.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/jspubtd.h	Mon Sep 08 10:35:45 2008 +0300
@@ -163,12 +163,11 @@ typedef struct JSSecurityCallbacks JSSec
  * index).  The *vp out parameter, on success, is the new property value after
  * an add, get, or set.  After a successful delete, *vp is JSVAL_FALSE iff
  * obj[id] can't be deleted (because it's permanent).
  */
 typedef JSBool
-(* JS_DLL_CALLBACK JSPropertyOp)(JSContext *cx, JSObject *obj, jsval id,
-                                 jsval *vp);
+(* JSPropertyOp)(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
 
 /*
  * This function type is used for callbacks that enumerate the properties of
  * a JSObject.  The behavior depends on the value of enum_op:
  *
@@ -194,20 +193,19 @@ typedef JSBool
  *
  * The return value is used to indicate success, with a value of JS_FALSE
  * indicating failure.
  */
 typedef JSBool
-(* JS_DLL_CALLBACK JSNewEnumerateOp)(JSContext *cx, JSObject *obj,
-                                     JSIterateOp enum_op,
-                                     jsval *statep, jsid *idp);
+(* JSNewEnumerateOp)(JSContext *cx, JSObject *obj, JSIterateOp enum_op,
+                     jsval *statep, jsid *idp);
 
 /*
  * The old-style JSClass.enumerate op should define all lazy properties not
  * yet reflected in obj.
  */
 typedef JSBool
-(* JS_DLL_CALLBACK JSEnumerateOp)(JSContext *cx, JSObject *obj);
+(* JSEnumerateOp)(JSContext *cx, JSObject *obj);
 
 /*
  * Resolve a lazy property named by id in obj by defining it directly in obj.
  * Lazy properties are those reflected from some peer native property space
  * (e.g., the DOM attributes for a given node reflected as obj) on demand.
@@ -218,11 +216,11 @@ typedef JSBool
  * is repeated with obj's prototype, etc.
  *
  * NB: JSNewResolveOp provides a cheaper way to resolve lazy properties.
  */
 typedef JSBool
-(* JS_DLL_CALLBACK JSResolveOp)(JSContext *cx, JSObject *obj, jsval id);
+(* JSResolveOp)(JSContext *cx, JSObject *obj, jsval id);
 
 /*
  * Like JSResolveOp, but flags provide contextual information as follows:
  *
  *  JSRESOLVE_QUALIFIED   a qualified property id: obj.id or obj[id], not id
@@ -250,35 +248,34 @@ typedef JSBool
  * This is not good practice, but enough existing hook implementations count
  * on it that we can't break compatibility by passing the starting object in
  * *objp without a new JSClass flag.
  */
 typedef JSBool
-(* JS_DLL_CALLBACK JSNewResolveOp)(JSContext *cx, JSObject *obj, jsval id,
-                                   uintN flags, JSObject **objp);
+(* JSNewResolveOp)(JSContext *cx, JSObject *obj, jsval id, uintN flags,
+                   JSObject **objp);
 
 /*
  * Convert obj to the given type, returning true with the resulting value in
  * *vp on success, and returning false on error or exception.
  */
 typedef JSBool
-(* JS_DLL_CALLBACK JSConvertOp)(JSContext *cx, JSObject *obj, JSType type,
-                                jsval *vp);
+(* JSConvertOp)(JSContext *cx, JSObject *obj, JSType type, jsval *vp);
 
 /*
  * Finalize obj, which the garbage collector has determined to be unreachable
  * from other live objects or from GC roots.  Obviously, finalizers must never
  * store a reference to obj.
  */
 typedef void
-(* JS_DLL_CALLBACK JSFinalizeOp)(JSContext *cx, JSObject *obj);
+(* JSFinalizeOp)(JSContext *cx, JSObject *obj);
 
 /*
  * Used by JS_AddExternalStringFinalizer and JS_RemoveExternalStringFinalizer
  * to extend and reduce the set of string types finalized by the GC.
  */
 typedef void
-(* JS_DLL_CALLBACK JSStringFinalizeOp)(JSContext *cx, JSString *str);
+(* JSStringFinalizeOp)(JSContext *cx, JSString *str);
 
 /*
  * The signature for JSClass.getObjectOps, used by JS_NewObject's internals
  * to discover the set of high-level object operations to use for new objects
  * of the given class.  All native objects have a JSClass, which is stored as
@@ -301,11 +298,11 @@ typedef void
  * Further extension to preserve API compatibility: if this function returns
  * a pointer to JSXMLObjectOps.base, not to JSObjectOps, then the engine calls
  * extended hooks needed for E4X.
  */
 typedef JSObjectOps *
-(* JS_DLL_CALLBACK JSGetObjectOps)(JSContext *cx, JSClass *clasp);
+(* JSGetObjectOps)(JSContext *cx, JSClass *clasp);
 
 /*
  * JSClass.checkAccess type: check whether obj[id] may be accessed per mode,
  * returning false on error/exception, true on success with obj[id]'s last-got
  * value in *vp, and its attributes in *attrsp.  As for JSPropertyOp above, id
@@ -316,36 +313,35 @@ typedef JSObjectOps *
  * jsval.  The native js_ObjectOps.checkAccess simply forwards to the object's
  * clasp->checkAccess, so that both JSClass and JSObjectOps implementors may
  * specialize access checks.
  */
 typedef JSBool
-(* JS_DLL_CALLBACK JSCheckAccessOp)(JSContext *cx, JSObject *obj, jsval id,
-                                    JSAccessMode mode, jsval *vp);
+(* JSCheckAccessOp)(JSContext *cx, JSObject *obj, jsval id, JSAccessMode mode,
+                    jsval *vp);
 
 /*
  * Encode or decode an object, given an XDR state record representing external
  * data.  See jsxdrapi.h.
  */
 typedef JSBool
-(* JS_DLL_CALLBACK JSXDRObjectOp)(JSXDRState *xdr, JSObject **objp);
+(* JSXDRObjectOp)(JSXDRState *xdr, JSObject **objp);
 
 /*
  * Check whether v is an instance of obj.  Return false on error or exception,
  * true on success with JS_TRUE in *bp if v is an instance of obj, JS_FALSE in
  * *bp otherwise.
  */
 typedef JSBool
-(* JS_DLL_CALLBACK JSHasInstanceOp)(JSContext *cx, JSObject *obj, jsval v,
-                                    JSBool *bp);
+(* JSHasInstanceOp)(JSContext *cx, JSObject *obj, jsval v, JSBool *bp);
 
 /*
  * Deprecated function type for JSClass.mark. All new code should define
  * JSTraceOp instead to ensure the traversal of traceable things stored in
  * the native structures.
  */
 typedef uint32
-(* JS_DLL_CALLBACK JSMarkOp)(JSContext *cx, JSObject *obj, void *arg);
+(* JSMarkOp)(JSContext *cx, JSObject *obj, void *arg);
 
 /*
  * Function type for trace operation of the class called to enumerate all
  * traceable things reachable from obj's private data structure. For each such
  * thing, a trace implementation must call
@@ -366,11 +362,11 @@ typedef uint32
  * JSCLASS_MARK_IS_TRACE to class flags and use JS_CLASS_TRACE(method)
  * macro below to convert JSTraceOp to JSMarkOp when initializing or
  * assigning JSClass.mark field.
  */
 typedef void
-(* JS_DLL_CALLBACK JSTraceOp)(JSTracer *trc, JSObject *obj);
+(* JSTraceOp)(JSTracer *trc, JSObject *obj);
 
 #if defined __GNUC__ && __GNUC__ >= 4 && !defined __cplusplus
 # define JS_CLASS_TRACE(method)                                               \
     (__builtin_types_compatible_p(JSTraceOp, __typeof(&(method)))             \
      ? (JSMarkOp)(method)                                                     \
@@ -393,20 +389,19 @@ extern JSMarkOp js_WrongTypeForClassTrac
  * a tag denoting internal implementation-specific traversal kind. In the
  * latter case the only operations on thing that the callback can do is to call
  * JS_TraceChildren or DEBUG-only JS_PrintTraceThingInfo.
  */
 typedef void
-(* JS_DLL_CALLBACK JSTraceCallback)(JSTracer *trc, void *thing, uint32 kind);
+(* JSTraceCallback)(JSTracer *trc, void *thing, uint32 kind);
 
 /*
  * DEBUG only callback that JSTraceOp implementation can provide to return
  * a string describing the reference traced with JS_CallTracer.
  */
 #ifdef DEBUG
 typedef void
-(* JS_DLL_CALLBACK JSTraceNamePrinter)(JSTracer *trc, char *buf,
-                                       size_t bufsize);
+(* JSTraceNamePrinter)(JSTracer *trc, char *buf, size_t bufsize);
 #endif
 
 /*
  * The optional JSClass.reserveSlots hook allows a class to make computed
  * per-instance object slots reservations, in addition to or instead of using
@@ -418,11 +413,11 @@ typedef void
  * NB: called with obj locked by the JSObjectOps-specific mutual exclusion
  * mechanism appropriate for obj, so don't nest other operations that might
  * also lock obj.
  */
 typedef uint32
-(* JS_DLL_CALLBACK JSReserveSlotsOp)(JSContext *cx, JSObject *obj);
+(* JSReserveSlotsOp)(JSContext *cx, JSObject *obj);
 
 /* JSObjectOps function pointer typedefs. */
 
 /*
  * Create a new subclass of JSObjectMap (see jsobj.h), with the nrefs and ops
@@ -436,20 +431,19 @@ typedef uint32
  * number of js_HoldObjectMap and js_DropObjectMap calls ensue.  When nrefs
  * reaches 0 due to a js_DropObjectMap call, JSObjectOps.destroyObjectMap will
  * be called to dispose of the map.
  */
 typedef JSObjectMap *
-(* JS_DLL_CALLBACK JSNewObjectMapOp)(JSContext *cx, jsrefcount nrefs,
-                                     JSObjectOps *ops, JSClass *clasp,
-                                     JSObject *obj);
+(* JSNewObjectMapOp)(JSContext *cx, jsrefcount nrefs, JSObjectOps *ops,
+                     JSClass *clasp, JSObject *obj);
 
 /*
  * Generic type for an infallible JSObjectMap operation, used currently by
  * JSObjectOps.destroyObjectMap.
  */
 typedef void
-(* JS_DLL_CALLBACK JSObjectMapOp)(JSContext *cx, JSObjectMap *map);
+(* JSObjectMapOp)(JSContext *cx, JSObjectMap *map);
 
 /*
  * Look for id in obj and its prototype chain, returning false on error or
  * exception, true on success.  On success, return null in *propp if id was
  * not found.  If id was found, return the first object searching from obj
@@ -465,12 +459,12 @@ typedef void
  * have locked *objp and added a reference count associated with *propp, so
  * callers should not risk deadlock by nesting or interleaving other lookups
  * or any obj-bearing ops before dropping *propp.
  */
 typedef JSBool
-(* JS_DLL_CALLBACK JSLookupPropOp)(JSContext *cx, JSObject *obj, jsid id,
-                                   JSObject **objp, JSProperty **propp);
+(* JSLookupPropOp)(JSContext *cx, JSObject *obj, jsid id, JSObject **objp,
+                   JSProperty **propp);
 
 /*
  * Define obj[id], a direct property of obj named id, having the given initial
  * value, with the specified getter, setter, and attributes.  If the propp out
  * param is non-null, *propp on successful return contains an opaque property
@@ -481,81 +475,76 @@ typedef JSBool
  * If propp is non-null and JSDefinePropOp succeeds, its caller must be sure
  * to drop *propp using JSObjectOps.dropProperty in short order, just as with
  * JSLookupPropOp.
  */
 typedef JSBool
-(* JS_DLL_CALLBACK JSDefinePropOp)(JSContext *cx, JSObject *obj,
-                                   jsid id, jsval value,
-                                   JSPropertyOp getter, JSPropertyOp setter,
-                                   uintN attrs, JSProperty **propp);
+(* JSDefinePropOp)(JSContext *cx, JSObject *obj, jsid id, jsval value,
+                   JSPropertyOp getter, JSPropertyOp setter, uintN attrs,
+                   JSProperty **propp);
 
 /*
  * Get, set, or delete obj[id], returning false on error or exception, true
  * on success.  If getting or setting, the new value is returned in *vp on
  * success.  If deleting without error, *vp will be JSVAL_FALSE if obj[id] is
  * permanent, and JSVAL_TRUE if id named a direct property of obj that was in
  * fact deleted, or if id names no direct property of obj (id could name a
  * prototype property, or no property in obj or its prototype chain).
  */
 typedef JSBool
-(* JS_DLL_CALLBACK JSPropertyIdOp)(JSContext *cx, JSObject *obj, jsid id,
-                                   jsval *vp);
+(* JSPropertyIdOp)(JSContext *cx, JSObject *obj, jsid id, jsval *vp);
 
 /*
  * Get or set attributes of the property obj[id].  Return false on error or
  * exception, true with current attributes in *attrsp.  If prop is non-null,
  * it must come from the *propp out parameter of a prior JSDefinePropOp or
  * JSLookupPropOp call.
  */
 typedef JSBool
-(* JS_DLL_CALLBACK JSAttributesOp)(JSContext *cx, JSObject *obj, jsid id,
-                                   JSProperty *prop, uintN *attrsp);
+(* JSAttributesOp)(JSContext *cx, JSObject *obj, jsid id, JSProperty *prop,
+                   uintN *attrsp);
 
 /*
  * JSObjectOps.checkAccess type: check whether obj[id] may be accessed per
  * mode, returning false on error/exception, true on success with obj[id]'s
  * last-got value in *vp, and its attributes in *attrsp.
  */
 typedef JSBool
-(* JS_DLL_CALLBACK JSCheckAccessIdOp)(JSContext *cx, JSObject *obj, jsid id,
-                                      JSAccessMode mode, jsval *vp,
-                                      uintN *attrsp);
+(* JSCheckAccessIdOp)(JSContext *cx, JSObject *obj, jsid id, JSAccessMode mode,
+                      jsval *vp, uintN *attrsp);
 
 /*
  * A generic type for functions mapping an object to another object, or null
  * if an error or exception was thrown on cx.  Used by JSObjectOps.thisObject
  * at present.
  */
 typedef JSObject *
-(* JS_DLL_CALLBACK JSObjectOp)(JSContext *cx, JSObject *obj);
+(* JSObjectOp)(JSContext *cx, JSObject *obj);
 
 /*
  * Hook that creates an iterator object for a given object. Returns the
  * iterator object or null if an error or exception was thrown on cx.
  */
 typedef JSObject *
-(* JS_DLL_CALLBACK JSIteratorOp)(JSContext *cx, JSObject *obj,
-                                 JSBool keysonly);
+(* JSIteratorOp)(JSContext *cx, JSObject *obj, JSBool keysonly);
 
 /*
  * A generic type for functions taking a context, object, and property, with
  * no return value.  Used by JSObjectOps.dropProperty currently (see above,
  * JSDefinePropOp and JSLookupPropOp, for the object-locking protocol in which
  * dropProperty participates).
  */
 typedef void
-(* JS_DLL_CALLBACK JSPropertyRefOp)(JSContext *cx, JSObject *obj,
-                                    JSProperty *prop);
+(* JSPropertyRefOp)(JSContext *cx, JSObject *obj, JSProperty *prop);
 
 /*
  * Function pointer type for JSObjectOps.setProto and JSObjectOps.setParent.
  * These hooks must check for cycles without deadlocking, and otherwise take
  * special steps. See jsobj.c and jsgc.c for details.
  */
 typedef JSBool
-(* JS_DLL_CALLBACK JSSetObjectSlotOp)(JSContext *cx, JSObject *obj,
-                                      uint32 slot, JSObject *pobj);
+(* JSSetObjectSlotOp)(JSContext *cx, JSObject *obj, uint32 slot,
+                      JSObject *pobj);
 
 /*
  * Get and set a required slot, one that should already have been allocated.
  * These operations are infallible, so required slots must be pre-allocated,
  * or implementations must suppress out-of-memory errors.  The native ops
@@ -567,47 +556,40 @@ typedef JSBool
  * points, which is a zero-based index into the JSCLASS_RESERVED_SLOTS(clasp)
  * reserved slots that come after the initial well-known slots: proto, parent,
  * class, and optionally, the private data slot.
  */
 typedef jsval
-(* JS_DLL_CALLBACK JSGetRequiredSlotOp)(JSContext *cx, JSObject *obj,
-                                        uint32 slot);
+(* JSGetRequiredSlotOp)(JSContext *cx, JSObject *obj, uint32 slot);
 
 typedef JSBool
-(* JS_DLL_CALLBACK JSSetRequiredSlotOp)(JSContext *cx, JSObject *obj,
-                                        uint32 slot, jsval v);
+(* JSSetRequiredSlotOp)(JSContext *cx, JSObject *obj, uint32 slot, jsval v);
 
 typedef JSObject *
-(* JS_DLL_CALLBACK JSGetMethodOp)(JSContext *cx, JSObject *obj, jsid id,
-                                  jsval *vp);
+(* JSGetMethodOp)(JSContext *cx, JSObject *obj, jsid id, jsval *vp);
 
 typedef JSBool
-(* JS_DLL_CALLBACK JSSetMethodOp)(JSContext *cx, JSObject *obj, jsid id,
-                                  jsval *vp);
+(* JSSetMethodOp)(JSContext *cx, JSObject *obj, jsid id, jsval *vp);
 
 typedef JSBool
-(* JS_DLL_CALLBACK JSEnumerateValuesOp)(JSContext *cx, JSObject *obj,
-                                        JSIterateOp enum_op,
-                                        jsval *statep, jsid *idp, jsval *vp);
+(* JSEnumerateValuesOp)(JSContext *cx, JSObject *obj, JSIterateOp enum_op,
+                        jsval *statep, jsid *idp, jsval *vp);
 
 typedef JSBool
-(* JS_DLL_CALLBACK JSEqualityOp)(JSContext *cx, JSObject *obj, jsval v,
-                                 JSBool *bp);
+(* JSEqualityOp)(JSContext *cx, JSObject *obj, jsval v, JSBool *bp);
 
 typedef JSBool
-(* JS_DLL_CALLBACK JSConcatenateOp)(JSContext *cx, JSObject *obj, jsval v,
-                                    jsval *vp);
+(* JSConcatenateOp)(JSContext *cx, JSObject *obj, jsval v, jsval *vp);
 
 /* Typedef for native functions called by the JS VM. */
 
 typedef JSBool
-(* JS_DLL_CALLBACK JSNative)(JSContext *cx, JSObject *obj, uintN argc,
-                             jsval *argv, jsval *rval);
+(* JSNative)(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
+             jsval *rval);
 
 /* See jsapi.h, the JS_CALLEE, JS_THIS, etc. macros. */
 typedef JSBool
-(* JS_DLL_CALLBACK JSFastNative)(JSContext *cx, uintN argc, jsval *vp);
+(* JSFastNative)(JSContext *cx, uintN argc, jsval *vp);
 
 /* Callbacks and their arguments. */
 
 typedef enum JSContextOp {
     JSCONTEXT_NEW,
@@ -626,41 +608,40 @@ typedef enum JSContextOp {
  *                      return true.
  *   Any other value    For future compatibility the callback must do nothing
  *                      and return true in this case.
  */
 typedef JSBool
-(* JS_DLL_CALLBACK JSContextCallback)(JSContext *cx, uintN contextOp);
+(* JSContextCallback)(JSContext *cx, uintN contextOp);
 
 typedef enum JSGCStatus {
     JSGC_BEGIN,
     JSGC_END,
     JSGC_MARK_END,
     JSGC_FINALIZE_END
 } JSGCStatus;
 
 typedef JSBool
-(* JS_DLL_CALLBACK JSGCCallback)(JSContext *cx, JSGCStatus status);
+(* JSGCCallback)(JSContext *cx, JSGCStatus status);
 
 /*
  * Generic trace operation that calls JS_CallTracer on each traceable thing
  * stored in data.
  */
 typedef void
-(* JS_DLL_CALLBACK JSTraceDataOp)(JSTracer *trc, void *data);
+(* JSTraceDataOp)(JSTracer *trc, void *data);
 
 typedef JSBool
-(* JS_DLL_CALLBACK JSOperationCallback)(JSContext *cx);
+(* JSOperationCallback)(JSContext *cx);
 
 /*
  * Deprecated form of JSOperationCallback.
  */
 typedef JSBool
-(* JS_DLL_CALLBACK JSBranchCallback)(JSContext *cx, JSScript *script);
+(* JSBranchCallback)(JSContext *cx, JSScript *script);
 
 typedef void
-(* JS_DLL_CALLBACK JSErrorReporter)(JSContext *cx, const char *message,
-                                    JSErrorReport *report);
+(* JSErrorReporter)(JSContext *cx, const char *message, JSErrorReport *report);
 
 /*
  * Possible exception types. These types are part of a JSErrorFormatString
  * structure. They define which error to throw in case of a runtime error.
  * JSEXN_NONE marks an unthrowable error.
@@ -688,37 +669,33 @@ typedef struct JSErrorFormatString {
     /* One of the JSExnType constants above. */
     int16 exnType;
 } JSErrorFormatString;
 
 typedef const JSErrorFormatString *
-(* JS_DLL_CALLBACK JSErrorCallback)(void *userRef, const char *locale,
-                                    const uintN errorNumber);
+(* JSErrorCallback)(void *userRef, const char *locale,
+                    const uintN errorNumber);
 
 #ifdef va_start
 #define JS_ARGUMENT_FORMATTER_DEFINED 1
 
 typedef JSBool
-(* JS_DLL_CALLBACK JSArgumentFormatter)(JSContext *cx, const char *format,
-                                        JSBool fromJS, jsval **vpp,
-                                        va_list *app);
+(* JSArgumentFormatter)(JSContext *cx, const char *format, JSBool fromJS,
+                        jsval **vpp, va_list *app);
 #endif
 
 typedef JSBool
-(* JS_DLL_CALLBACK JSLocaleToUpperCase)(JSContext *cx, JSString *src,
-                                        jsval *rval);
+(* JSLocaleToUpperCase)(JSContext *cx, JSString *src, jsval *rval);
 
 typedef JSBool
-(* JS_DLL_CALLBACK JSLocaleToLowerCase)(JSContext *cx, JSString *src,
-                                        jsval *rval);
+(* JSLocaleToLowerCase)(JSContext *cx, JSString *src, jsval *rval);
 
 typedef JSBool
-(* JS_DLL_CALLBACK JSLocaleCompare)(JSContext *cx,
-                                    JSString *src1, JSString *src2,
-                                    jsval *rval);
+(* JSLocaleCompare)(JSContext *cx, JSString *src1, JSString *src2,
+                    jsval *rval);
 
 typedef JSBool
-(* JS_DLL_CALLBACK JSLocaleToUnicode)(JSContext *cx, char *src, jsval *rval);
+(* JSLocaleToUnicode)(JSContext *cx, char *src, jsval *rval);
 
 /*
  * Security protocol types.
  */
 typedef struct JSPrincipals JSPrincipals;
@@ -729,22 +706,21 @@ typedef struct JSPrincipals JSPrincipals
  * in which case implementations must return a held (via JSPRINCIPALS_HOLD),
  * non-null *principalsp out parameter.  Return true on success, false on any
  * error, which the implementation must have reported.
  */
 typedef JSBool
-(* JS_DLL_CALLBACK JSPrincipalsTranscoder)(JSXDRState *xdr,
-                                           JSPrincipals **principalsp);
+(* JSPrincipalsTranscoder)(JSXDRState *xdr, JSPrincipals **principalsp);
 
 /*
  * Return a weak reference to the principals associated with obj, possibly via
  * the immutable parent chain leading from obj to a top-level container (e.g.,
  * a window object in the DOM level 0).  If there are no principals associated
  * with obj, return null.  Therefore null does not mean an error was reported;
  * in no event should an error be reported or an exception be thrown by this
  * callback's implementation.
  */
 typedef JSPrincipals *
-(* JS_DLL_CALLBACK JSObjectPrincipalsFinder)(JSContext *cx, JSObject *obj);
+(* JSObjectPrincipalsFinder)(JSContext *cx, JSObject *obj);
 
 JS_END_EXTERN_C
 
 #endif /* jspubtd_h___ */
diff -r 14ce7619e9c1 js/src/jsscope.cpp
--- a/js/src/jsscope.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/jsscope.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -391,11 +391,11 @@ ChangeScope(JSContext *cx, JSScope *scop
 /*
  * Take care to exclude the mark bits in case we're called from the GC.
  */
 #define SPROP_FLAGS_NOT_MATCHED (SPROP_MARK | SPROP_FLAG_SHAPE_REGEN)
 
-JS_STATIC_DLL_CALLBACK(JSDHashNumber)
+static JSDHashNumber
 js_HashScopeProperty(JSDHashTable *table, const void *key)
 {
     const JSScopeProperty *sprop = (const JSScopeProperty *)key;
     JSDHashNumber hash;
     JSPropertyOp gsop;
@@ -437,11 +437,11 @@ js_HashScopeProperty(JSDHashTable *table
      (sprop)->slot == (aslot) &&                                              \
      (sprop)->attrs == (aattrs) &&                                            \
      (((sprop)->flags ^ (aflags)) & ~SPROP_FLAGS_NOT_MATCHED) == 0 &&         \
      (sprop)->shortid == (ashortid))
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 js_MatchScopeProperty(JSDHashTable *table,
                       const JSDHashEntryHdr *hdr,
                       const void *key)
 {
     const JSPropertyTreeEntry *entry = (const JSPropertyTreeEntry *)hdr;
@@ -1615,11 +1615,11 @@ MeterPropertyTree(JSBasicStats *bs, JSSc
     }
 
     MeterKidCount(bs, nkids);
 }
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 js_MeterPropertyTree(JSDHashTable *table, JSDHashEntryHdr *hdr, uint32 number,
                      void *arg)
 {
     JSPropertyTreeEntry *entry = (JSPropertyTreeEntry *)hdr;
     JSBasicStats *bs = (JSBasicStats *)arg;
diff -r 14ce7619e9c1 js/src/jsscript.cpp
--- a/js/src/jsscript.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/jsscript.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -961,11 +961,11 @@ js_InitScriptClass(JSContext *cx, JSObje
 #endif /* JS_HAS_SCRIPT_OBJECT */
 
 /*
  * Shared script filename management.
  */
-JS_STATIC_DLL_CALLBACK(int)
+static int
 js_compare_strings(const void *k1, const void *k2)
 {
     return strcmp((const char *) k1, (const char *) k2) == 0;
 }
 
@@ -977,32 +977,32 @@ typedef struct ScriptFilenameEntry {
     uint32              flags;          /* user-defined filename prefix flags */
     JSPackedBool        mark;           /* GC mark flag */
     char                filename[3];    /* two or more bytes, NUL-terminated */
 } ScriptFilenameEntry;
 
-JS_STATIC_DLL_CALLBACK(void *)
+static void *
 js_alloc_table_space(void *priv, size_t size)
 {
     return malloc(size);
 }
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 js_free_table_space(void *priv, void *item)
 {
     free(item);
 }
 
-JS_STATIC_DLL_CALLBACK(JSHashEntry *)
+static JSHashEntry *
 js_alloc_sftbl_entry(void *priv, const void *key)
 {
     size_t nbytes = offsetof(ScriptFilenameEntry, filename) +
                     strlen((const char *) key) + 1;
 
     return (JSHashEntry *) malloc(JS_MAX(nbytes, sizeof(JSHashEntry)));
 }
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 js_free_sftbl_entry(void *priv, JSHashEntry *he, uintN flag)
 {
     if (flag != HT_FREE_ENTRY)
         return;
     free(he);
@@ -1236,11 +1236,11 @@ js_MarkScriptFilename(const char *filena
     sfe = FILENAME_TO_SFE(filename);
     ASSERT_VALID_SFE(sfe);
     sfe->mark = JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(intN)
+static intN
 js_script_filename_marker(JSHashEntry *he, intN i, void *arg)
 {
     ScriptFilenameEntry *sfe = (ScriptFilenameEntry *) he;
 
     sfe->mark = JS_TRUE;
@@ -1267,11 +1267,11 @@ js_MarkScriptFilenames(JSRuntime *rt, JS
         sfp = (ScriptFilenamePrefix *) link;
         js_MarkScriptFilename(sfp->name);
     }
 }
 
-JS_STATIC_DLL_CALLBACK(intN)
+static intN
 js_script_filename_sweeper(JSHashEntry *he, intN i, void *arg)
 {
     ScriptFilenameEntry *sfe = (ScriptFilenameEntry *) he;
 
     if (!sfe->mark)
diff -r 14ce7619e9c1 js/src/jsstr.cpp
--- a/js/src/jsstr.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/jsstr.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -1145,10 +1145,58 @@ str_lastIndexOf(JSContext *cx, uintN arg
     }
     *vp = INT_TO_JSVAL(i);
     return JS_TRUE;
 }
 
+static JSBool
+js_TrimString(JSContext *cx, jsval *vp, JSBool trimLeft, JSBool trimRight)
+{
+    JSString *str;
+    const jschar *chars;
+    size_t length, begin, end;
+
+    NORMALIZE_THIS(cx, vp, str);
+    JSSTRING_CHARS_AND_LENGTH(str, chars, length);
+    begin = 0;
+    end = length;
+
+    if (trimLeft) {
+        while (begin < length && JS_ISSPACE(chars[begin]))
+            ++begin;
+    }
+
+    if (trimRight) {
+        while (end > begin && JS_ISSPACE(chars[end-1]))
+            --end;
+    }
+
+    str = js_NewDependentString(cx, str, begin, end - begin);
+    if (!str)
+        return JS_FALSE;
+
+    *vp = STRING_TO_JSVAL(str);
+    return JS_TRUE;
+}
+
+static JSBool
+str_trim(JSContext *cx, uintN argc, jsval *vp)
+{
+    return js_TrimString(cx, vp, JS_TRUE, JS_TRUE);
+}
+
+static JSBool
+str_trimLeft(JSContext *cx, uintN argc, jsval *vp)
+{
+    return js_TrimString(cx, vp, JS_TRUE, JS_FALSE);
+}
+
+static JSBool
+str_trimRight(JSContext *cx, uintN argc, jsval *vp)
+{
+    return js_TrimString(cx, vp, JS_FALSE, JS_TRUE);
+}
+
 /*
  * Perl-inspired string functions.
  */
 typedef struct GlobData {
     jsbytecode  *pc;            /* in: program counter resulting in us matching */
@@ -2278,10 +2326,13 @@ static JSFunctionSpec string_methods[] =
     JS_FN("toUpperCase",       js_str_toUpperCase,    0,GENERIC_PRIMITIVE),
     JS_FN("charAt",            js_str_charAt,         1,GENERIC_PRIMITIVE),
     JS_FN("charCodeAt",        js_str_charCodeAt,     1,GENERIC_PRIMITIVE),
     JS_FN("indexOf",           str_indexOf,           1,GENERIC_PRIMITIVE),
     JS_FN("lastIndexOf",       str_lastIndexOf,       1,GENERIC_PRIMITIVE),
+    JS_FN("trim",              str_trim,              0,GENERIC_PRIMITIVE),
+    JS_FN("trimLeft",          str_trimLeft,          0,GENERIC_PRIMITIVE),
+    JS_FN("trimRight",         str_trimRight,         0,GENERIC_PRIMITIVE),
     JS_FN("toLocaleLowerCase", str_toLocaleLowerCase, 0,GENERIC_PRIMITIVE),
     JS_FN("toLocaleUpperCase", str_toLocaleUpperCase, 0,GENERIC_PRIMITIVE),
     JS_FN("localeCompare",     str_localeCompare,     1,GENERIC_PRIMITIVE),
 
     /* Perl-ish methods (search is actually Python-esque). */
@@ -2381,11 +2432,11 @@ static JSFunctionSpec string_static_meth
 static JSFunctionSpec string_static_methods[] = {
     JS_FN("fromCharCode",    js_str_fromCharCode,    1,0),
     JS_FS_END
 };
 
-JS_STATIC_DLL_CALLBACK(JSHashNumber)
+static JSHashNumber
 js_hash_string_pointer(const void *key)
 {
     return (JSHashNumber)JS_PTR_TO_UINT32(key) >> JSVAL_TAGBITS;
 }
 
diff -r 14ce7619e9c1 js/src/jstypes.h
--- a/js/src/jstypes.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/jstypes.h	Mon Sep 08 10:35:45 2008 +0300
@@ -82,38 +82,31 @@
 # define JS_EXTERN_API(__type)  extern __declspec(dllexport) __type
 # define JS_EXPORT_API(__type)  __declspec(dllexport) __type
 # define JS_EXTERN_DATA(__type) extern __declspec(dllexport) __type
 # define JS_EXPORT_DATA(__type) __declspec(dllexport) __type
 
-# define JS_DLL_CALLBACK
-# define JS_STATIC_DLL_CALLBACK(__x)    static __x
-
 #elif defined(XP_OS2) && defined(__declspec)
 
 # define JS_EXTERN_API(__type)  extern __declspec(dllexport) __type
 # define JS_EXPORT_API(__type)  __declspec(dllexport) __type
 # define JS_EXTERN_DATA(__type) extern __declspec(dllexport) __type
 # define JS_EXPORT_DATA(__type) __declspec(dllexport) __type
 
-# define JS_DLL_CALLBACK
-# define JS_STATIC_DLL_CALLBACK(__x)    static __x
-
 #else /* Unix */
 
 # ifdef HAVE_VISIBILITY_ATTRIBUTE
 #  define JS_EXTERNAL_VIS __attribute__((visibility ("default")))
+# elif defined(__SUNPRO_C) || defined(__SUNPRO_CC)
+#  define JS_EXTERNAL_VIS __global
 # else
 #  define JS_EXTERNAL_VIS
 # endif
 
 # define JS_EXTERN_API(__type)  extern JS_EXTERNAL_VIS __type
 # define JS_EXPORT_API(__type)  JS_EXTERNAL_VIS __type
 # define JS_EXTERN_DATA(__type) extern JS_EXTERNAL_VIS __type
 # define JS_EXPORT_DATA(__type) JS_EXTERNAL_VIS __type
-
-# define JS_DLL_CALLBACK
-# define JS_STATIC_DLL_CALLBACK(__x)    static __x
 
 #endif
 
 #ifdef _WIN32
 # if defined(__MWERKS__) || defined(__GNUC__)
diff -r 14ce7619e9c1 js/src/jsxml.cpp
--- a/js/src/jsxml.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/jsxml.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -6034,11 +6034,11 @@ TraceObjectVector(JSTracer *trc, JSObjec
             JS_CallTracer(trc, obj, JSTRACE_OBJECT);
         }
     }
 }
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 trace_temp_ns_array(JSTracer *trc, JSTempValueRooter *tvr)
 {
     JSTempRootedNSArray *tmp = (JSTempRootedNSArray *)tvr;
 
     TraceObjectVector(trc,
diff -r 14ce7619e9c1 js/src/jsxml.h
--- a/js/src/jsxml.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/jsxml.h	Mon Sep 08 10:35:45 2008 +0300
@@ -53,11 +53,11 @@ extern const char js_gt_entity_str[];
 extern const char js_gt_entity_str[];
 extern const char js_lt_entity_str[];
 extern const char js_quot_entity_str[];
 
 typedef JSBool
-(* JS_DLL_CALLBACK JSIdentityOp)(const void *a, const void *b);
+(* JSIdentityOp)(const void *a, const void *b);
 
 struct JSXMLArray {
     uint32              length;
     uint32              capacity;
     void                **vector;
diff -r 14ce7619e9c1 js/src/liveconnect/README.html
--- a/js/src/liveconnect/README.html	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/liveconnect/README.html	Mon Sep 08 10:35:45 2008 +0300
@@ -464,17 +464,10 @@ format tables or table-like code.</li>
 <li>
 DLL entry points have their return type expanded within a JS_EXPORT_API()&nbsp;
 macro call, to get the right Windows secret type qualifiers in the right
 places for both 16- and 32-bit builds.</li>
 
-<li>
-Callback functions that might be called from a DLL are similarly macroized
-with JS_STATIC_DLL_CALLBACK (if the function otherwise would be static
-to hide its name) or JS_DLL_CALLBACK (this macro takes no type argument;
-it should be used after the return type and before the function name).</li>
-</ul>
-
 <h2>
 <a NAME="API"></a>The LiveConnect API</h2>
 All public LiveConnect entry points and callbacks are documented in 
 <A HREF=http://lxr.mozilla.org/mozilla/source/js/src/liveconnect/jsjava.h>jsjava.h</A>,
 the header file that exports those functions.
diff -r 14ce7619e9c1 js/src/liveconnect/jsj_JSObject.c
--- a/js/src/liveconnect/jsj_JSObject.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/liveconnect/jsj_JSObject.c	Mon Sep 08 10:35:45 2008 +0300
@@ -372,11 +372,11 @@ destroy_saved_js_error(JNIEnv *jEnv, Cap
  * netscape.javascript.JSException.  If the resulting JSException is not caught
  * within Java, it may be propagated up the stack beyond the Java caller back
  * into JavaScript, in which case the error will be re-reported as a JavaScript
  * error.
  */
-JS_STATIC_DLL_CALLBACK(void)
+static void
 capture_js_error_reports_for_java(JSContext *cx, const char *message,
                                   JSErrorReport *report)
 {
     CapturedJSError *new_error;
     JSJavaThreadState *jsj_env;
diff -r 14ce7619e9c1 js/src/liveconnect/jsj_JavaArray.c
--- a/js/src/liveconnect/jsj_JavaArray.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/liveconnect/jsj_JavaArray.c	Mon Sep 08 10:35:45 2008 +0300
@@ -206,11 +206,11 @@ access_java_array_element(JSContext *cx,
         return jsj_GetJavaArrayElement(cx, jEnv, java_array, index,
                                        array_component_signature, vp);
     }
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaArray_getPropertyById(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 {
     JNIEnv *jEnv;
     JSJavaThreadState *jsj_env;
     JSBool result;
@@ -221,11 +221,11 @@ JavaArray_getPropertyById(JSContext *cx,
     result = access_java_array_element(cx, jEnv, obj, id, vp, JS_FALSE);
     jsj_ExitJava(jsj_env);
     return result;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaArray_setPropertyById(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 {
     JNIEnv *jEnv;
     JSJavaThreadState *jsj_env;
     JSBool result;
@@ -236,11 +236,11 @@ JavaArray_setPropertyById(JSContext *cx,
     result = access_java_array_element(cx, jEnv, obj, id, vp, JS_TRUE);
     jsj_ExitJava(jsj_env);
     return result;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaArray_lookupProperty(JSContext *cx, JSObject *obj, jsid id,
                          JSObject **objp, JSProperty **propp)
 {
     JNIEnv *jEnv;
     JSErrorReporter old_reporter;
@@ -261,11 +261,11 @@ JavaArray_lookupProperty(JSContext *cx, 
     JS_SetErrorReporter(cx, old_reporter);
     jsj_ExitJava(jsj_env);
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaArray_defineProperty(JSContext *cx, JSObject *obj, jsid id, jsval value,
                          JSPropertyOp getter, JSPropertyOp setter,
                          uintN attrs, JSProperty **propp)
 {
     jsval *vp = &value;
@@ -275,20 +275,20 @@ JavaArray_defineProperty(JSContext *cx, 
         return JS_FALSE;
 
     return JavaArray_setPropertyById(cx, obj, id, vp);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaArray_getAttributes(JSContext *cx, JSObject *obj, jsid id,
                         JSProperty *prop, uintN *attrsp)
 {
     /* We don't maintain JS property attributes for Java class members */
     *attrsp = JSPROP_PERMANENT|JSPROP_ENUMERATE;
     return JS_FALSE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaArray_setAttributes(JSContext *cx, JSObject *obj, jsid id,
                         JSProperty *prop, uintN *attrsp)
 {
     /* We don't maintain JS property attributes for Java class members */
     if (*attrsp != (JSPROP_PERMANENT|JSPROP_ENUMERATE)) {
@@ -298,11 +298,11 @@ JavaArray_setAttributes(JSContext *cx, J
 
     /* Silently ignore all setAttribute attempts */
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaArray_deleteProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
 {
     JSVersion version = JS_GetVersion(cx);
 
     *vp = JSVAL_FALSE;
@@ -316,18 +316,18 @@ JavaArray_deleteProperty(JSContext *cx, 
            by ECMAScript. */
         return JS_TRUE;
     }
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaArray_defaultValue(JSContext *cx, JSObject *obj, JSType type, jsval *vp)
 {
     /* printf("In JavaArray_defaultValue()\n"); */
     return JavaObject_convert(cx, obj, JSTYPE_STRING, vp);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaArray_newEnumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op,
                        jsval *statep, jsid *idp)
 {
     JavaObjectWrapper *java_wrapper;
     JSJavaThreadState *jsj_env;
@@ -386,11 +386,11 @@ JavaArray_newEnumerate(JSContext *cx, JS
 
     jsj_ExitJava(jsj_env);
     return ok;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaArray_checkAccess(JSContext *cx, JSObject *obj, jsid id,
                       JSAccessMode mode, jsval *vp, uintN *attrsp)
 {
     switch (mode) {
     case JSACC_WATCH:
@@ -431,11 +431,11 @@ JSObjectOps JavaArray_ops = {
     NULL,                           /* clear */
     jsj_wrapper_getRequiredSlot,    /* getRequiredSlot */
     jsj_wrapper_setRequiredSlot     /* setRequiredSlot */
 };
 
-JS_STATIC_DLL_CALLBACK(JSObjectOps *)
+static JSObjectOps *
 JavaArray_getObjectOps(JSContext *cx, JSClass *clazz)
 {
     return &JavaArray_ops;
 }
 
diff -r 14ce7619e9c1 js/src/liveconnect/jsj_JavaClass.c
--- a/js/src/liveconnect/jsj_JavaClass.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/liveconnect/jsj_JavaClass.c	Mon Sep 08 10:35:45 2008 +0300
@@ -56,11 +56,11 @@
 #include <stdlib.h>
 #include <string.h>
 
 #include "jsj_private.h"        /* LiveConnect internals */
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaClass_convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp)
 {
     char *name;
     JSString *str;
 
@@ -156,11 +156,11 @@ done:
     if (memberp)
         *memberp = member_descriptor;
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaClass_getPropertyById(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
 {
     jsval idval;
     jclass java_class;
     const char *member_name;
@@ -225,11 +225,11 @@ JavaClass_getPropertyById(JSContext *cx,
 
     jsj_ExitJava(jsj_env);
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaClass_setPropertyById(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
 {
     jclass java_class;
     const char *member_name;
     JavaClassDescriptor *class_descriptor;
@@ -278,11 +278,11 @@ no_such_field:
 }
 
 /*
  * Free the private native data associated with the JavaPackage object.
  */
-JS_STATIC_DLL_CALLBACK(void)
+static void
 JavaClass_finalize(JSContext *cx, JSObject *obj)
 {
     JNIEnv *jEnv;
     JSJavaThreadState *jsj_env;
 
@@ -299,11 +299,11 @@ JavaClass_finalize(JSContext *cx, JSObje
     jsj_ReleaseJavaClassDescriptor(cx, jEnv, class_descriptor);
     jsj_ExitJava(jsj_env);
 }
 
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaClass_lookupProperty(JSContext *cx, JSObject *obj, jsid id,
                          JSObject **objp, JSProperty **propp)
 {
     JNIEnv *jEnv;
     JSErrorReporter old_reporter;
@@ -328,11 +328,11 @@ JavaClass_lookupProperty(JSContext *cx, 
     JS_SetErrorReporter(cx, old_reporter);
     jsj_ExitJava(jsj_env);
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaClass_defineProperty(JSContext *cx, JSObject *obj, jsid id, jsval value,
                          JSPropertyOp getter, JSPropertyOp setter,
                          uintN attrs, JSProperty **propp)
 {
     JavaClassDescriptor *class_descriptor;
@@ -346,20 +346,20 @@ JavaClass_defineProperty(JSContext *cx, 
     JS_ReportErrorNumber(cx, jsj_GetErrorMessage, NULL, 
                          JSJMSG_JCLASS_PROP_DEFINE);
     return JS_FALSE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaClass_getAttributes(JSContext *cx, JSObject *obj, jsid id,
                         JSProperty *prop, uintN *attrsp)
 {
     /* We don't maintain JS property attributes for Java class members */
     *attrsp = JSPROP_PERMANENT|JSPROP_ENUMERATE;
     return JS_FALSE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaClass_setAttributes(JSContext *cx, JSObject *obj, jsid id,
                         JSProperty *prop, uintN *attrsp)
 {
     /* We don't maintain JS property attributes for Java class members */
     if (*attrsp != (JSPROP_PERMANENT|JSPROP_ENUMERATE)) {
@@ -369,11 +369,11 @@ JavaClass_setAttributes(JSContext *cx, J
 
     /* Silently ignore all setAttribute attempts */
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaClass_deleteProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
 {
     JSVersion version = JS_GetVersion(cx);
     
     *vp = JSVAL_FALSE;
@@ -387,18 +387,18 @@ JavaClass_deleteProperty(JSContext *cx, 
            by ECMAScript. */
         return JS_TRUE;
     }
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaClass_defaultValue(JSContext *cx, JSObject *obj, JSType type, jsval *vp)
 {
     /* printf("In JavaClass_defaultValue()\n"); */
     return JavaClass_convert(cx, obj, JSTYPE_STRING, vp);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaClass_newEnumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op,
                        jsval *statep, jsid *idp)
 {
     JavaMemberDescriptor *member_descriptor;
     JavaClassDescriptor *class_descriptor;
@@ -456,11 +456,11 @@ JavaClass_newEnumerate(JSContext *cx, JS
         JS_ASSERT(0);
         return JS_FALSE;
     }
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaClass_checkAccess(JSContext *cx, JSObject *obj, jsid id,
                       JSAccessMode mode, jsval *vp, uintN *attrsp)
 {
     switch (mode) {
     case JSACC_WATCH:
@@ -475,11 +475,11 @@ JavaClass_checkAccess(JSContext *cx, JSO
 
 /*
  * Implement the JavaScript instanceof operator for JavaClass objects by using
  * the equivalent Java instanceof operation.
  */
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaClass_hasInstance(JSContext *cx, JSObject *obj, jsval candidate_jsval,
                       JSBool *has_instancep)
 {
     JavaClassDescriptor *class_descriptor;
     JavaObjectWrapper *java_wrapper;
@@ -556,11 +556,11 @@ JSObjectOps JavaClass_ops = {
     NULL,                           /* clear */
     jsj_wrapper_getRequiredSlot,    /* getRequiredSlot */
     jsj_wrapper_setRequiredSlot     /* setRequiredSlot */
 };
 
-JS_STATIC_DLL_CALLBACK(JSObjectOps *)
+static JSObjectOps *
 JavaClass_getObjectOps(JSContext *cx, JSClass *clazz)
 {
     return &JavaClass_ops;
 }
 
@@ -629,11 +629,11 @@ jsj_define_JavaClass(JSContext *cx, JNIE
  * is useful for accessing static methods and fields.
  *
  *    js> getClass(new java.lang.String("foo"))
  *    [JavaClass java.lang.String]
  */
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 getClass(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
     JSObject *obj_arg, *JavaClass_obj;
     JavaObjectWrapper *java_wrapper;
     JavaClassDescriptor *class_descriptor;
@@ -672,11 +672,11 @@ getClass(JSContext *cx, JSObject *obj, u
     *rval = OBJECT_TO_JSVAL(JavaClass_obj);
     jsj_ExitJava(jsj_env);
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaClass_construct(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
     JSObject *obj_arg, *JavaClass_obj;
     JavaObjectWrapper *java_wrapper;
     JavaClassDescriptor *class_descriptor;
diff -r 14ce7619e9c1 js/src/liveconnect/jsj_JavaMember.c
--- a/js/src/liveconnect/jsj_JavaMember.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/liveconnect/jsj_JavaMember.c	Mon Sep 08 10:35:45 2008 +0300
@@ -90,22 +90,22 @@ jsj_CreateJavaMember(JSContext *cx, jsva
     JS_SetPrivate(cx, JavaMember_obj, (void *)member_val);
 
     return JavaMember_obj;
 }
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 JavaMember_finalize(JSContext *cx, JSObject *obj)
 {
     JavaMethodOrFieldValue *member_val;
 
     member_val = JS_GetPrivate(cx, obj);
     if (!member_val)
         return;
     JS_free(cx, member_val);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaMember_convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp)
 {
     JavaMethodOrFieldValue *member_val;
         
     member_val = JS_GetPrivate(cx, obj);
@@ -141,18 +141,18 @@ JavaMember_convert(JSContext *cx, JSObje
 /*
  * This function exists only to make JavaMember's Call'able.  The way the JS
  * engine is written now, it's never actually called because when a JavaMember
  * is invoked, it's converted to a JS function via JavaMember_convert().
  */
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaMember_Call(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
     JS_ASSERT(0);
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 JavaMember_trace(JSTracer *trc, JSObject *obj)
 {
     JavaMethodOrFieldValue *member_val;
 
     member_val = (JavaMethodOrFieldValue *)JS_GetPrivate(trc->context, obj);
diff -r 14ce7619e9c1 js/src/liveconnect/jsj_JavaObject.c
--- a/js/src/liveconnect/jsj_JavaObject.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/liveconnect/jsj_JavaObject.c	Mon Sep 08 10:35:45 2008 +0300
@@ -88,11 +88,11 @@ static int java_obj_reflections_mutation
 
 static JSBool installed_GC_callback = JS_FALSE;
 static JSGCCallback old_GC_callback = NULL;
 static JavaObjectWrapper* deferred_wrappers = NULL;
 
-static JSBool JS_DLL_CALLBACK jsj_GC_callback(JSContext *cx, JSGCStatus status)
+static JSBool jsj_GC_callback(JSContext *cx, JSGCStatus status)
 {
     if (status == JSGC_END && deferred_wrappers) {
         JNIEnv *jEnv;
         JSJavaThreadState *jsj_env = jsj_EnterJava(cx, &jEnv);
         if (jEnv) {
@@ -370,11 +370,11 @@ jsj_DiscardJavaObjReflections(JNIEnv *jE
         JSJ_HashTableDestroy(java_obj_reflections);
         java_obj_reflections = NULL;
     }
 }
 
-JSBool JS_DLL_CALLBACK
+JSBool
 JavaObject_convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp)
 {
     JavaObjectWrapper *java_wrapper;
     JavaClassDescriptor *class_descriptor;
     jobject java_obj;
@@ -725,11 +725,11 @@ JavaObject_getPropertyById(JSContext *cx
 
     jsj_ExitJava(jsj_env);
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaObject_setPropertyById(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
 {
     jobject java_obj;
     const char *member_name;
     JavaObjectWrapper *java_wrapper;
@@ -809,11 +809,11 @@ no_such_field:
                          member_name, class_descriptor->name);
     jsj_ExitJava(jsj_env);
     return JS_FALSE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaObject_lookupProperty(JSContext *cx, JSObject *obj, jsid id,
                          JSObject **objp, JSProperty **propp)
 {
     JNIEnv *jEnv;
     JSErrorReporter old_reporter;
@@ -849,30 +849,30 @@ JavaObject_lookupProperty(JSContext *cx,
     JS_SetErrorReporter(cx, old_reporter);
     jsj_ExitJava(jsj_env);
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaObject_defineProperty(JSContext *cx, JSObject *obj, jsid id, jsval value,
                          JSPropertyOp getter, JSPropertyOp setter,
                          uintN attrs, JSProperty **propp)
 {
     JS_ReportErrorNumber(cx, jsj_GetErrorMessage, NULL,
                          JSJMSG_JOBJECT_PROP_DEFINE);
     return JS_FALSE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaObject_getAttributes(JSContext *cx, JSObject *obj, jsid id,
                         JSProperty *prop, uintN *attrsp)
 {
     /* We don't maintain JS property attributes for Java class members */
     *attrsp = JSPROP_PERMANENT|JSPROP_ENUMERATE;
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaObject_setAttributes(JSContext *cx, JSObject *obj, jsid id,
                         JSProperty *prop, uintN *attrsp)
 {
     /* We don't maintain JS property attributes for Java class members */
     if (*attrsp != (JSPROP_PERMANENT|JSPROP_ENUMERATE)) {
@@ -882,11 +882,11 @@ JavaObject_setAttributes(JSContext *cx, 
 
     /* Silently ignore all setAttribute attempts */
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaObject_deleteProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
 {
     JSVersion version = JS_GetVersion(cx);
 
     *vp = JSVAL_FALSE;
@@ -900,18 +900,18 @@ JavaObject_deleteProperty(JSContext *cx,
            by ECMAScript. */
         return JS_TRUE;
     }
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaObject_defaultValue(JSContext *cx, JSObject *obj, JSType type, jsval *vp)
 {
     /* printf("In JavaObject_defaultValue()\n"); */
     return JavaObject_convert(cx, obj, type, vp);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaObject_newEnumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op,
                         jsval *statep, jsid *idp)
 {
     JavaObjectWrapper *java_wrapper;
     JavaMemberDescriptor *member_descriptor;
@@ -974,11 +974,11 @@ JavaObject_newEnumerate(JSContext *cx, J
         JS_ASSERT(0);
         return JS_FALSE;
     }
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaObject_checkAccess(JSContext *cx, JSObject *obj, jsid id,
                       JSAccessMode mode, jsval *vp, uintN *attrsp)
 {
     switch (mode) {
     case JSACC_WATCH:
@@ -991,11 +991,11 @@ JavaObject_checkAccess(JSContext *cx, JS
     }
 }
 
 #define JSJ_SLOT_COUNT (JSSLOT_PRIVATE+1)
 
-JSObjectMap * JS_DLL_CALLBACK
+JSObjectMap *
 jsj_wrapper_newObjectMap(JSContext *cx, jsrefcount nrefs, JSObjectOps *ops,
                          JSClass *clasp, JSObject *obj)
 {
     JSObjectMap * map;
 
@@ -1006,25 +1006,25 @@ jsj_wrapper_newObjectMap(JSContext *cx, 
         map->freeslot = JSJ_SLOT_COUNT;
     }
     return map;
 }
 
-void JS_DLL_CALLBACK
+void
 jsj_wrapper_destroyObjectMap(JSContext *cx, JSObjectMap *map)
 {
     JS_free(cx, map);
 }
 
-jsval JS_DLL_CALLBACK
+jsval
 jsj_wrapper_getRequiredSlot(JSContext *cx, JSObject *obj, uint32 slot)
 {
     JS_ASSERT(slot < JSJ_SLOT_COUNT);
     JS_ASSERT(obj->map->freeslot == JSJ_SLOT_COUNT);
     return STOBJ_GET_SLOT(obj, slot);
 }
 
-JSBool JS_DLL_CALLBACK
+JSBool
 jsj_wrapper_setRequiredSlot(JSContext *cx, JSObject *obj, uint32 slot, jsval v)
 {
     JS_ASSERT(slot < JSJ_SLOT_COUNT);
     JS_ASSERT(obj->map->freeslot == JSJ_SLOT_COUNT);
     STOBJ_SET_SLOT(obj, slot, v);
@@ -1059,11 +1059,11 @@ JSObjectOps JavaObject_ops = {
     NULL,                           /* clear */
     jsj_wrapper_getRequiredSlot,    /* getRequiredSlot */
     jsj_wrapper_setRequiredSlot     /* setRequiredSlot */
 };
 
-JS_STATIC_DLL_CALLBACK(JSObjectOps *)
+static JSObjectOps *
 JavaObject_getObjectOps(JSContext *cx, JSClass *clazz)
 {
     return &JavaObject_ops;
 }
 
diff -r 14ce7619e9c1 js/src/liveconnect/jsj_JavaPackage.c
--- a/js/src/liveconnect/jsj_JavaPackage.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/liveconnect/jsj_JavaPackage.c	Mon Sep 08 10:35:45 2008 +0300
@@ -135,11 +135,11 @@ define_JavaPackage(JSContext *cx, JSObje
 /*
  * Don't allow user-defined properties to be set on Java package objects, e.g.
  * it is illegal to write "java.lang.myProperty = 4".  We probably could relax
  * this restriction, but it's potentially confusing and not clearly useful.
  */
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaPackage_setProperty(JSContext *cx, JSObject *obj, jsval slot, jsval *vp)
 {
     JavaPackage_Private *package = JS_GetPrivate(cx, obj);
     if (!package) {
         JS_ReportErrorNumber(cx, jsj_GetErrorMessage, NULL, 
@@ -154,11 +154,11 @@ static JSBool quiet_resolve_failure;
 static JSBool quiet_resolve_failure;
 
 /*
  * Resolve a component name to be either the name of a class or a package.
  */
-JS_STATIC_DLL_CALLBACK(JSBool)
+static  JSBool
 JavaPackage_resolve(JSContext *cx, JSObject *obj, jsval id)
 {
     JavaPackage_Private *package;
     JSBool ok = JS_TRUE;
     jclass jclazz;
@@ -287,11 +287,11 @@ out:
     JS_smprintf_free(newPath);
     jsj_ExitJava(jsj_env);
     return ok;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaPackage_convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp)
 {
     JSString *str;
     char *name, *cp;
 
@@ -340,11 +340,11 @@ JavaPackage_convert(JSContext *cx, JSObj
 }
 
 /*
  * Free the private native data associated with the JavaPackage object.
  */
-JS_STATIC_DLL_CALLBACK(void)
+static void
 JavaPackage_finalize(JSContext *cx, JSObject *obj)
 {
     JavaPackage_Private *package = JS_GetPrivate(cx, obj);
     if (!package)
         return;
@@ -530,11 +530,11 @@ error:
     JS_FREE_IF(cx, package_name);
     JS_FREE_IF(cx, path);
     return JS_FALSE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 JavaPackage_toString(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                  jsval *rval)
 {
     if (!JS_InstanceOf(cx, obj, &JavaPackage_class, argv))
         return JS_FALSE;
diff -r 14ce7619e9c1 js/src/liveconnect/jsj_class.c
--- a/js/src/liveconnect/jsj_class.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/liveconnect/jsj_class.c	Mon Sep 08 10:35:45 2008 +0300
@@ -402,11 +402,11 @@ error:
     destroy_class_descriptor(cx, jEnv, class_descriptor);
     return NULL;
 }
 
 /* Trivial helper for jsj_DiscardJavaClassReflections(), below */
-JS_STATIC_DLL_CALLBACK(JSIntn)
+static JSIntn
 enumerate_remove_java_class(JSJHashEntry *he, JSIntn i, void *arg)
 {
     JSJavaThreadState *jsj_env = (JSJavaThreadState *)arg;
     JavaClassDescriptor *class_descriptor;
 
diff -r 14ce7619e9c1 js/src/liveconnect/jsj_hash.h
--- a/js/src/liveconnect/jsj_hash.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/liveconnect/jsj_hash.h	Mon Sep 08 10:35:45 2008 +0300
@@ -59,13 +59,13 @@ JS_BEGIN_EXTERN_C
 
 typedef struct JSJHashEntry  JSJHashEntry;
 typedef struct JSJHashTable  JSJHashTable;
 typedef JSUint32 JSJHashNumber;
 #define JSJ_HASH_BITS 32
-typedef JSJHashNumber (* JS_DLL_CALLBACK JSJHashFunction)(const void *key, void *arg);
-typedef JSIntn (* JS_DLL_CALLBACK JSJHashComparator)(const void *v1, const void *v2, void *arg);
-typedef JSIntn (* JS_DLL_CALLBACK JSJHashEnumerator)(JSJHashEntry *he, JSIntn i, void *arg);
+typedef JSJHashNumber (* JSJHashFunction)(const void *key, void *arg);
+typedef JSIntn (* JSJHashComparator)(const void *v1, const void *v2, void *arg);
+typedef JSIntn (* JSJHashEnumerator)(JSJHashEntry *he, JSIntn i, void *arg);
 
 /* Flag bits in JSJHashEnumerator's return value */
 #define HT_ENUMERATE_NEXT       0       /* continue enumerating entries */
 #define HT_ENUMERATE_STOP       1       /* stop enumerating entries */
 #define HT_ENUMERATE_REMOVE     2       /* remove and free the current entry */
diff -r 14ce7619e9c1 js/src/liveconnect/jsj_private.h
--- a/js/src/liveconnect/jsj_private.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/liveconnect/jsj_private.h	Mon Sep 08 10:35:45 2008 +0300
@@ -553,11 +553,11 @@ jsj_WrapJavaObject(JSContext *cx, JNIEnv
 jsj_WrapJavaObject(JSContext *cx, JNIEnv *jEnv, jobject java_obj, jclass java_class);
 
 extern void
 jsj_DiscardJavaObjReflections(JNIEnv *jEnv);
 
-extern JSBool JS_DLL_CALLBACK
+extern JSBool
 JavaObject_convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp);
 
 JS_EXTERN_API(void)
 JavaObject_finalize(JSContext *cx, JSObject *obj);
 
@@ -608,17 +608,17 @@ jsj_GetJavaErrorMessage(JNIEnv *env);
 jsj_GetJavaErrorMessage(JNIEnv *env);
 
 extern void
 jsj_LogError(const char *error_msg);
 
-extern const JSErrorFormatString * JS_DLL_CALLBACK
+extern const JSErrorFormatString *
 jsj_GetErrorMessage(void *userRef, const char *locale, const uintN errorNumber);
 
-JSJHashNumber JS_DLL_CALLBACK
+JSJHashNumber
 jsj_HashJavaObject(const void *key, void* env);
 
-intN JS_DLL_CALLBACK
+intN
 jsj_JavaObjectComparator(const void *v1, const void *v2, void *arg);
 
 extern JSJavaThreadState *
 jsj_MapJavaThreadToJSJavaThreadState(JNIEnv *jEnv, char **errp);
 
@@ -641,21 +641,21 @@ jsj_EnterJava(JSContext *cx, JNIEnv **en
 jsj_EnterJava(JSContext *cx, JNIEnv **envp);
 
 extern void
 jsj_ExitJava(JSJavaThreadState *jsj_env);
 
-extern JSObjectMap * JS_DLL_CALLBACK
+extern JSObjectMap *
 jsj_wrapper_newObjectMap(JSContext *cx, jsrefcount nrefs, JSObjectOps *ops,
                          JSClass *clasp, JSObject *obj);
 
-extern void JS_DLL_CALLBACK
+extern void
 jsj_wrapper_destroyObjectMap(JSContext *cx, JSObjectMap *map);
 
-extern jsval JS_DLL_CALLBACK
+extern jsval
 jsj_wrapper_getRequiredSlot(JSContext *cx, JSObject *obj, uint32 slot);
 
-extern JSBool JS_DLL_CALLBACK
+extern JSBool
 jsj_wrapper_setRequiredSlot(JSContext *cx, JSObject *obj, uint32 slot, jsval v);
 
 #ifdef DEBUG
 #define DEBUG_LOG(args) printf args
 #endif
diff -r 14ce7619e9c1 js/src/liveconnect/jsj_simpleapi.c
--- a/js/src/liveconnect/jsj_simpleapi.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/liveconnect/jsj_simpleapi.c	Mon Sep 08 10:35:45 2008 +0300
@@ -78,11 +78,11 @@ default_map_java_object_to_js_object(JNI
 default_map_java_object_to_js_object(JNIEnv *jEnv, void *hint, char **errp)
 {
     return the_global_js_obj;
 }
 
-static JSBool JS_DLL_CALLBACK
+static JSBool
 default_create_java_vm(SystemJavaVM* *jvm, JNIEnv* *initialEnv, void* initargs)
 {
     jint err;
     const char* user_classpath = (const char*)initargs;
     char* full_classpath = NULL;
@@ -114,37 +114,37 @@ default_create_java_vm(SystemJavaVM* *jv
         JS_smprintf_free(full_classpath);
     
     return err == 0;
 }
 
-static JSBool JS_DLL_CALLBACK
+static JSBool
 default_destroy_java_vm(SystemJavaVM* jvm, JNIEnv* initialEnv)
 {
     JavaVM* java_vm = (JavaVM*)jvm;
     jint err = (*java_vm)->DestroyJavaVM(java_vm);
     return err == 0;
 }
 
-static JNIEnv* JS_DLL_CALLBACK
+static JNIEnv*
 default_attach_current_thread(SystemJavaVM* jvm)
 {
     JavaVM* java_vm = (JavaVM*)jvm;
     JNIEnv* env = NULL;
     (*java_vm)->AttachCurrentThread(java_vm, &env, NULL);
     return env;
 }
 
-static JSBool JS_DLL_CALLBACK
+static JSBool
 default_detach_current_thread(SystemJavaVM* jvm, JNIEnv* env)
 {
     JavaVM* java_vm = (JavaVM*)jvm;
     /* assert that env is the JNIEnv of the current thread */
     jint err = (*java_vm)->DetachCurrentThread(java_vm);
     return err == 0;
 }
 
-static SystemJavaVM* JS_DLL_CALLBACK
+static SystemJavaVM*
 default_get_java_vm(JNIEnv* env)
 {
     JavaVM* java_vm = NULL;
     (*env)->GetJavaVM(env, &java_vm);
     return (SystemJavaVM*)java_vm;
diff -r 14ce7619e9c1 js/src/liveconnect/jsj_utils.c
--- a/js/src/liveconnect/jsj_utils.c	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/liveconnect/jsj_utils.c	Mon Sep 08 10:35:45 2008 +0300
@@ -61,11 +61,11 @@
 
 /*
  * This is a hash-table utility routine that computes the hash code of a Java
  * object by calling java.lang.System.identityHashCode()
  */
-JSJHashNumber JS_DLL_CALLBACK
+JSJHashNumber
 jsj_HashJavaObject(const void *key, void* env)
 {
     JSHashNumber hash_code;
     jobject java_obj;
     JNIEnv *jEnv;
@@ -91,11 +91,11 @@ jsj_HashJavaObject(const void *key, void
  * It's not possible to use the == operator to directly compare two jobject's,
  * since they're opaque references and aren't guaranteed to be simple pointers
  * or handles (though they may be in some JVM implementations).  Instead,
  * use the JNI routine for comparing the two objects.
  */
-intN JS_DLL_CALLBACK
+intN
 jsj_JavaObjectComparator(const void *v1, const void *v2, void *arg)
 {
     jobject java_obj1, java_obj2;
     JNIEnv *jEnv;
 
diff -r 14ce7619e9c1 js/src/plify_jsdhash.sed
--- a/js/src/plify_jsdhash.sed	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/plify_jsdhash.sed	Mon Sep 08 10:35:45 2008 +0300
@@ -23,12 +23,10 @@ s/uint16/PRUint16/g
 s/uint16/PRUint16/g
 s/\([^U]\)int16/\1PRInt16/g
 s/JSBool/PRBool/g
 s/extern JS_PUBLIC_API(\([^()]*\))/NS_COM_GLUE \1/
 s/JS_PUBLIC_API(\([^()]*\))/\1/
-s/JS_DLL_CALLBACK/PR_CALLBACK/
-s/JS_STATIC_DLL_CALLBACK/PR_STATIC_CALLBACK/
 s/JS_NewDHashTable/PL_NewDHashTable/
 s/JS_ASSERT(0)/NS_NOTREACHED("0")/
 s/\( *\)JS_ASSERT(\(.*\));/\1NS_ASSERTION(\2,\n\1             "\2");/
 s/JSDHASH_ONELINE_ASSERT(\(.*\));/NS_ASSERTION(\1, "\1");/
 s/JS_UNLIKELY/NS_UNLIKELY/g
diff -r 14ce7619e9c1 js/src/prmjtime.cpp
--- a/js/src/prmjtime.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/prmjtime.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -557,11 +557,11 @@ PRMJ_DSTOffset(JSInt64 local_time)
 
     return(local_time);
 }
 
 #ifdef NS_HAVE_INVALID_PARAMETER_HANDLER
-JS_STATIC_DLL_CALLBACK(void)
+static void
 PRMJ_InvalidParameterHandler(const wchar_t *expression,
                              const wchar_t *function,
                              const wchar_t *file,
                              unsigned int   line,
                              uintptr_t      pReserved)
diff -r 14ce7619e9c1 js/src/xpconnect/loader/mozJSComponentLoader.cpp
--- a/js/src/xpconnect/loader/mozJSComponentLoader.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/xpconnect/loader/mozJSComponentLoader.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -121,11 +121,11 @@ static PRLogModuleInfo *gJSCLLog;
 #define ERROR_GETTING_ARRAY_LENGTH "%s - Error getting array length of EXPORTED_SYMBOLS."
 #define ERROR_ARRAY_ELEMENT "%s - EXPORTED_SYMBOLS[%d] is not a string."
 #define ERROR_GETTING_SYMBOL "%s - Could not get symbol '%s'."
 #define ERROR_SETTING_SYMBOL "%s - Could not set symbol '%s' on target object."
 
-void JS_DLL_CALLBACK
+void
 mozJSLoaderErrorReporter(JSContext *cx, const char *message, JSErrorReport *rep)
 {
     nsresult rv;
 
     /* Use the console service to register the error. */
@@ -179,11 +179,11 @@ mozJSLoaderErrorReporter(JSContext *cx, 
             rep->filename, rep->lineno,
             message ? message : "<no message>");
 #endif
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 Dump(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
     JSString *str;
     if (!argc)
         return JS_TRUE;
@@ -195,21 +195,21 @@ Dump(JSContext *cx, JSObject *obj, uintN
     char *bytes = JS_GetStringBytes(str);
     fputs(bytes, stderr);
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 Debug(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
 #ifdef DEBUG
     return Dump(cx, obj, argc, argv, rval);
 #else
     return JS_TRUE;
 #endif
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 Atob(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
     JSString *str;
     if (!argc)
         return JS_TRUE;
@@ -241,11 +241,11 @@ Atob(JSContext *cx, JSObject *obj, uintN
 
     *rval = STRING_TO_JSVAL(str);
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 Btoa(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
     JSString *str;
     if (!argc)
         return JS_TRUE;
diff -r 14ce7619e9c1 js/src/xpconnect/loader/mozJSSubScriptLoader.cpp
--- a/js/src/xpconnect/loader/mozJSSubScriptLoader.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/xpconnect/loader/mozJSSubScriptLoader.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -71,11 +71,11 @@
 #define LOAD_ERROR_READUNDERFLOW "File Read Error (underflow.)"
 #define LOAD_ERROR_NOPRINCIPALS "Failed to get principals."
 #define LOAD_ERROR_NOSPEC "Failed to get URI spec.  This is bad."
 
 // We just use the same reporter as the component loader
-extern void JS_DLL_CALLBACK
+extern void
 mozJSLoaderErrorReporter(JSContext *cx, const char *message, JSErrorReport *rep);
 
 mozJSSubScriptLoader::mozJSSubScriptLoader() : mSystemPrincipal(nsnull)
 {
 }
diff -r 14ce7619e9c1 js/src/xpconnect/shell/xpcshell.cpp
--- a/js/src/xpconnect/shell/xpcshell.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/xpconnect/shell/xpcshell.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -111,11 +111,11 @@ static JSBool reportWarnings = JS_TRUE;
 static JSBool reportWarnings = JS_TRUE;
 static JSBool compileOnly = JS_FALSE;
 
 JSPrincipals *gJSPrincipals = nsnull;
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 my_ErrorReporter(JSContext *cx, const char *message, JSErrorReport *report)
 {
     int i, j, k, n;
     char *prefix = NULL, *tmp;
     const char *ctmp;
@@ -178,11 +178,11 @@ my_ErrorReporter(JSContext *cx, const ch
     if (!JSREPORT_IS_WARNING(report->flags))
         gExitCode = EXITCODE_RUNTIME_ERROR;
     JS_free(cx, prefix);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 Print(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
     uintN i, n;
     JSString *str;
 
@@ -196,11 +196,11 @@ Print(JSContext *cx, JSObject *obj, uint
     if (n)
         fputc('\n', gOutFile);
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 Dump(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
     JSString *str;
     if (!argc)
         return JS_TRUE;
@@ -215,11 +215,11 @@ Dump(JSContext *cx, JSObject *obj, uintN
     fputs(bytes, gOutFile);
     free(bytes);
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 Load(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
     uintN i;
     JSString *str;
     const char *filename;
@@ -249,28 +249,28 @@ Load(JSContext *cx, JSObject *obj, uintN
             return JS_FALSE;
     }
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 Version(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
     if (argc > 0 && JSVAL_IS_INT(argv[0]))
         *rval = INT_TO_JSVAL(JS_SetVersion(cx, JSVersion(JSVAL_TO_INT(argv[0]))));
     else
         *rval = INT_TO_JSVAL(JS_GetVersion(cx));
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 BuildDate(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
     fprintf(gOutFile, "built on %s at %s\n", __DATE__, __TIME__);
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 Quit(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
 #ifdef LIVECONNECT
     JSJ_SimpleShutdown();
 #endif
@@ -281,11 +281,11 @@ Quit(JSContext *cx, JSObject *obj, uintN
     gQuitting = JS_TRUE;
 //    exit(0);
     return JS_FALSE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 DumpXPC(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
     int32 depth = 2;
 
     if (argc > 0) {
@@ -300,11 +300,11 @@ DumpXPC(JSContext *cx, JSObject *obj, ui
 }
 
 /* XXX needed only by GC() */
 #include "jscntxt.h"
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 GC(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
     JSRuntime *rt;
     uint32 preBytes;
 
@@ -406,11 +406,11 @@ DumpHeap(JSContext *cx, JSObject *obj, u
     return JS_FALSE;
 }
 
 #endif /* DEBUG */
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 Clear(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
     if (argc > 0 && !JSVAL_IS_PRIMITIVE(argv[0])) {
         JS_ClearScope(cx, JSVAL_TO_OBJECT(argv[0]));
     } else {
@@ -584,11 +584,11 @@ JSErrorFormatString jsShell_ErrorFormatS
     { format, count } ,
 #include "jsshell.msg"
 #undef MSG_DEF
 };
 
-JS_STATIC_DLL_CALLBACK(const JSErrorFormatString *)
+static const JSErrorFormatString *
 my_GetErrorMessage(void *userRef, const char *locale, const uintN errorNumber)
 {
     if ((errorNumber > 0) && (errorNumber < JSShellErr_Limit))
             return &jsShell_ErrorFormatString[errorNumber];
         else
@@ -1301,11 +1301,11 @@ nsXPCFunctionThisTranslator::TranslateTh
     return NS_OK;
 }
 
 #endif
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 ContextCallback(JSContext *cx, uintN contextOp)
 {
     if (contextOp == JSCONTEXT_NEW) {
         JS_SetErrorReporter(cx, my_ErrorReporter);
         JS_SetVersion(cx, JSVERSION_LATEST);
diff -r 14ce7619e9c1 js/src/xpconnect/src/XPCCrossOriginWrapper.cpp
--- a/js/src/xpconnect/src/XPCCrossOriginWrapper.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/xpconnect/src/XPCCrossOriginWrapper.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -47,56 +47,56 @@
 #include "nsIDOMWindowCollection.h"
 
 // This file implements a wrapper around objects that allows them to be
 // accessed safely from across origins.
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_XOW_AddProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_XOW_DelProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_XOW_GetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_XOW_SetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_XOW_Enumerate(JSContext *cx, JSObject *obj);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_XOW_NewResolve(JSContext *cx, JSObject *obj, jsval id, uintN flags,
                    JSObject **objp);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_XOW_Convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp);
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 XPC_XOW_Finalize(JSContext *cx, JSObject *obj);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_XOW_CheckAccess(JSContext *cx, JSObject *obj, jsval id, JSAccessMode mode,
                     jsval *vp);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_XOW_Call(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_XOW_Construct(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                   jsval *rval);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_XOW_HasInstance(JSContext *cx, JSObject *obj, jsval v, JSBool *bp);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_XOW_Equality(JSContext *cx, JSObject *obj, jsval v, JSBool *bp);
 
-JS_STATIC_DLL_CALLBACK(JSObject *)
+static JSObject *
 XPC_XOW_Iterator(JSContext *cx, JSObject *obj, JSBool keysonly);
 
-JS_STATIC_DLL_CALLBACK(JSObject *)
+static JSObject *
 XPC_XOW_WrappedObject(JSContext *cx, JSObject *obj);
 
 JSExtendedClass sXPC_XOW_JSClass = {
   // JSClass (JSExtendedClass.base) initialization
   { "XPCCrossOriginWrapper",
@@ -130,11 +130,11 @@ JSExtendedClass sXPC_XOW_JSClass = {
 // Therefore, we can look in gDyingScopes, and if our scope is there,
 // then the map is about to be destroyed anyway, so we don't need to
 // do anything.
 static const int XPC_XOW_ScopeSlot = XPCWrapper::sNumSlots;
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_XOW_toString(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                  jsval *rval);
 
 // Throws an exception on context |cx|.
 static inline
@@ -540,11 +540,11 @@ XPC_XOW_WrapObject(JSContext *cx, JSObje
   }
 
   return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_XOW_AddProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 {
   // All AddProperty needs to do is pass on addProperty requests to
   // same-origin objects, and throw for all else.
 
@@ -580,11 +580,11 @@ XPC_XOW_AddProperty(JSContext *cx, JSObj
 
   // Same origin, pass this request along.
   return XPCWrapper::AddProperty(cx, obj, wrappedObj, id, vp);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_XOW_DelProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 {
   JSObject *wrappedObj = GetWrappedObject(cx, obj);
   if (!wrappedObj) {
     return ThrowException(NS_ERROR_ILLEGAL_VALUE, cx);
@@ -735,23 +735,23 @@ XPC_XOW_GetOrSetProperty(JSContext *cx, 
   }
 
   return WrapSameOriginProp(cx, obj, vp);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_XOW_GetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 {
   return XPC_XOW_GetOrSetProperty(cx, obj, id, vp, JS_FALSE);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_XOW_SetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 {
   return XPC_XOW_GetOrSetProperty(cx, obj, id, vp, JS_TRUE);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_XOW_Enumerate(JSContext *cx, JSObject *obj)
 {
   obj = GetWrapper(obj);
   JSObject *wrappedObj = GetWrappedObject(cx, obj);
   if (!wrappedObj) {
@@ -775,11 +775,11 @@ XPC_XOW_Enumerate(JSContext *cx, JSObjec
   }
 
   return XPCWrapper::Enumerate(cx, obj, wrappedObj);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_XOW_NewResolve(JSContext *cx, JSObject *obj, jsval id, uintN flags,
                    JSObject **objp)
 {
   obj = GetWrapper(obj);
 
@@ -851,11 +851,11 @@ XPC_XOW_NewResolve(JSContext *cx, JSObje
   }
 
   return XPCWrapper::NewResolve(cx, obj, wrappedObj, id, flags, objp);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_XOW_Convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp)
 {
   // Don't do any work to convert to object.
   if (type == JSTYPE_OBJECT) {
     *vp = OBJECT_TO_JSVAL(obj);
@@ -898,11 +898,11 @@ XPC_XOW_Convert(JSContext *cx, JSObject 
   return NS_SUCCEEDED(rv)
          ? WrapSameOriginProp(cx, obj, vp)
          : XPC_XOW_RewrapIfNeeded(cx, obj, vp);
 }
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 XPC_XOW_Finalize(JSContext *cx, JSObject *obj)
 {
   JSObject *wrappedObj = GetWrappedObject(cx, obj);
   if (!wrappedObj) {
     return;
@@ -925,11 +925,11 @@ XPC_XOW_Finalize(JSContext *cx, JSObject
 
   // Remove ourselves from the map.
   scope->GetWrapperMap()->Remove(wrappedObj);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_XOW_CheckAccess(JSContext *cx, JSObject *obj, jsval prop, JSAccessMode mode,
                     jsval *vp)
 {
   // Simply forward checkAccess to our wrapped object. It's already expecting
   // untrusted things to ask it about accesses.
@@ -938,11 +938,11 @@ XPC_XOW_CheckAccess(JSContext *cx, JSObj
   jsid id;
   return JS_ValueToId(cx, prop, &id) &&
          JS_CheckAccess(cx, GetWrappedObject(cx, obj), id, mode, vp, &junk);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_XOW_Call(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
   JSObject *wrappedObj = GetWrappedObject(cx, obj);
   if (!wrappedObj) {
     // Nothing to call.
@@ -973,11 +973,11 @@ XPC_XOW_Call(JSContext *cx, JSObject *ob
   }
 
   return XPC_XOW_RewrapIfNeeded(cx, callee, rval);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_XOW_Construct(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                   jsval *rval)
 {
   JSObject *realObj = GetWrapper(JSVAL_TO_OBJECT(argv[-2]));
   JSObject *wrappedObj = GetWrappedObject(cx, realObj);
@@ -1009,11 +1009,11 @@ XPC_XOW_Construct(JSContext *cx, JSObjec
   }
 
   return XPC_XOW_RewrapIfNeeded(cx, callee, rval);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_XOW_HasInstance(JSContext *cx, JSObject *obj, jsval v, JSBool *bp)
 {
   JSObject *iface = GetWrappedObject(cx, obj);
 
   XPCCallContext ccx(JS_CALLER, cx);
@@ -1049,11 +1049,11 @@ XPC_XOW_HasInstance(JSContext *cx, JSObj
   }
 
   return clasp->hasInstance(cx, iface, v, bp);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_XOW_Equality(JSContext *cx, JSObject *obj, jsval v, JSBool *bp)
 {
   // Convert both sides to XPCWrappedNative and see if they match.
   if (JSVAL_IS_PRIMITIVE(v)) {
     *bp = JS_FALSE;
@@ -1090,11 +1090,11 @@ XPC_XOW_Equality(JSContext *cx, JSObject
   test = other->GetFlatJSObject();
   return ((JSExtendedClass *)STOBJ_GET_CLASS(obj))->
     equality(cx, obj, OBJECT_TO_JSVAL(test), bp);
 }
 
-JS_STATIC_DLL_CALLBACK(JSObject *)
+static JSObject *
 XPC_XOW_Iterator(JSContext *cx, JSObject *obj, JSBool keysonly)
 {
   JSObject *wrappedObj = GetWrappedObject(cx, obj);
   if (!wrappedObj) {
     ThrowException(NS_ERROR_INVALID_ARG, cx);
@@ -1139,17 +1139,17 @@ XPC_XOW_Iterator(JSContext *cx, JSObject
 
   return XPCWrapper::CreateIteratorObj(cx, wrapperIter, obj, wrappedObj,
                                        keysonly);
 }
 
-JS_STATIC_DLL_CALLBACK(JSObject *)
+static JSObject *
 XPC_XOW_WrappedObject(JSContext *cx, JSObject *obj)
 {
   return GetWrappedObject(cx, obj);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_XOW_toString(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                  jsval *rval)
 {
   obj = GetWrapper(obj);
   if (!obj) {
diff -r 14ce7619e9c1 js/src/xpconnect/src/XPCDispObject.cpp
--- a/js/src/xpconnect/src/XPCDispObject.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/xpconnect/src/XPCDispObject.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -456,11 +456,11 @@ JSBool GetMember(XPCCallContext& ccx, JS
  * @param argc Number of arguments in this call
  * @param argv The parameters passed in if any
  * @param vp The return value
  * @return Returns JS_TRUE if the operation succeeded
  */
-JSBool JS_DLL_CALLBACK
+JSBool
 XPC_IDispatch_CallMethod(JSContext* cx, JSObject* obj, uintN argc,
                          jsval* argv, jsval* vp)
 {
     NS_ASSERTION(JS_TypeOfValue(cx, argv[-2]) == JSTYPE_FUNCTION, "bad function");
     JSObject* funobj = JSVAL_TO_OBJECT(argv[-2]);
@@ -490,11 +490,11 @@ XPC_IDispatch_CallMethod(JSContext* cx, 
  * @param argc Number of arguments in this call
  * @param argv The parameters passed in if any
  * @param vp The return value
  * @return Returns JS_TRUE if the operation succeeded
  */
-JSBool JS_DLL_CALLBACK
+JSBool
 XPC_IDispatch_GetterSetter(JSContext *cx, JSObject *obj, uintN argc,
                            jsval *argv, jsval *vp)
 {
     NS_ASSERTION(JS_TypeOfValue(cx, argv[-2]) == JSTYPE_FUNCTION, "bad function");
     JSObject* funobj = JSVAL_TO_OBJECT(argv[-2]);
diff -r 14ce7619e9c1 js/src/xpconnect/src/XPCDispParamPropJSClass.cpp
--- a/js/src/xpconnect/src/XPCDispParamPropJSClass.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/xpconnect/src/XPCDispParamPropJSClass.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -64,11 +64,11 @@ XPCDispParamPropJSClass* GetParamProp(JS
  * @param obj The object to perform the get on
  * @param id ID of the parameter to get
  * @param vp Pointer to the return value
  * @return JSBool JS_TRUE if property was retrieved
  */
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_PP_GetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 {
     XPCDispParamPropJSClass* paramProp = GetParamProp(cx, obj);
     JSObject* originalObj = paramProp->GetWrapper()->GetFlatJSObject();
     XPCCallContext ccx(JS_CALLER, cx, originalObj, nsnull, id, 
@@ -85,11 +85,11 @@ XPC_PP_GetProperty(JSContext *cx, JSObje
  * @param obj The object to perform the get on
  * @param id ID of the parameter to get
  * @param vp Pointer to the return value
  * @return JSBool JS_TRUE if property was retrieved
  */
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_PP_SetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 {
     XPCDispParamPropJSClass* paramProp = GetParamProp(cx, obj);
     JSObject* originalObj = paramProp->GetWrapper()->GetFlatJSObject();
     XPCCallContext ccx(JS_CALLER, cx, originalObj, nsnull, id, 
@@ -124,22 +124,22 @@ XPC_PP_SetProperty(JSContext *cx, JSObje
  * @param obj The object to perform the get on
  * @param id ID of the parameter to get
  * @param vp Pointer to the return value
  * @return JSBool JS_TRUE if property was retrieved
  */
-JS_STATIC_DLL_CALLBACK(void)
+static void
 XPC_PP_Finalize(JSContext *cx, JSObject *obj)
 {
     delete GetParamProp(cx, obj);
 }
 
 /**
  * Is called to trace things that the object holds.
  * @param trc the tracing structure
  * @param obj the object being marked
  */
-JS_STATIC_DLL_CALLBACK(void)
+static void
 XPC_PP_Trace(JSTracer *trc, JSObject *obj)
 {
     XPCDispParamPropJSClass* paramProp = GetParamProp(trc->context, obj);
     if(paramProp)
     {
diff -r 14ce7619e9c1 js/src/xpconnect/src/XPCDispPrivate.h
--- a/js/src/xpconnect/src/XPCDispPrivate.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/xpconnect/src/XPCDispPrivate.h	Mon Sep 08 10:35:45 2008 +0300
@@ -211,11 +211,11 @@ private:
  * @param argc the number of parameters passed to the function
  * @param argv the array of parameters passed to the function
  * @param vp holds the result of the function
  * @return true if the function completes without error
  */
-JSBool JS_DLL_CALLBACK
+JSBool
 XPC_IDispatch_CallMethod(JSContext *cx, JSObject *obj, uintN argc,
                          jsval *argv, jsval *vp);
 /**
  * JS callback function that is called when a getter/setter is invoked
  * @param cx the JS context the function is invoked with
@@ -223,11 +223,11 @@ XPC_IDispatch_CallMethod(JSContext *cx, 
  * @param argc the number of parameters passed to the function
  * @param argv the array of parameters passed to the function
  * @param vp holds the result of the function
  * @return true if the function completes without error
  */
-JSBool JS_DLL_CALLBACK
+JSBool
 XPC_IDispatch_GetterSetter(JSContext *cx, JSObject *obj, uintN argc, 
                            jsval *argv, jsval *vp);
 
 /**
  * This class holds an array of names. This is only used in wrapped
diff -r 14ce7619e9c1 js/src/xpconnect/src/XPCDispTearOff.cpp
--- a/js/src/xpconnect/src/XPCDispTearOff.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/xpconnect/src/XPCDispTearOff.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -229,11 +229,11 @@ STDMETHODIMP XPCDispatchTearOff::GetIDsO
         return pTypeInfo->GetIDsOfNames(rgszNames, cNames, rgDispId);
     }
     return S_OK;
 }
 
-void JS_DLL_CALLBACK
+void
 xpcWrappedJSErrorReporter(JSContext *cx, const char *message,
                           JSErrorReport *report);
 
 STDMETHODIMP XPCDispatchTearOff::Invoke(DISPID dispIdMember, REFIID riid, 
                                         LCID lcid, WORD wFlags,
diff -r 14ce7619e9c1 js/src/xpconnect/src/XPCIDispatchExtension.cpp
--- a/js/src/xpconnect/src/XPCIDispatchExtension.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/xpconnect/src/XPCIDispatchExtension.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -126,27 +126,27 @@ CommonConstructor(JSContext *cx, int nam
     }
     *rval = OBJECT_TO_JSVAL(jsobj);
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 COMObjectConstructor(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, 
                      jsval *rval)
 {
     return CommonConstructor(cx, XPCJSRuntime::IDX_COM_OBJECT, obj, argc,
                              argv, rval, PR_FALSE);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 ActiveXConstructor(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, 
                    jsval *rval)
 {
     return CommonConstructor(cx, XPCJSRuntime::IDX_ACTIVEX_OBJECT, obj, argc, argv,
                              rval, PR_TRUE);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 ActiveXSupports(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, 
                 jsval *rval)
 {
     XPCCallContext ccx(JS_CALLER, cx, JS_GetGlobalObject(cx));
     // Check if IDispatch is enabled, fail if not
diff -r 14ce7619e9c1 js/src/xpconnect/src/XPCNativeWrapper.cpp
--- a/js/src/xpconnect/src/XPCNativeWrapper.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/xpconnect/src/XPCNativeWrapper.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -42,57 +42,57 @@
 #include "XPCNativeWrapper.h"
 #include "XPCWrapper.h"
 #include "jsdbgapi.h"
 #include "jsscope.h"
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_NW_AddProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_NW_DelProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_NW_GetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_NW_SetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_NW_Enumerate(JSContext *cx, JSObject *obj);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_NW_NewResolve(JSContext *cx, JSObject *obj, jsval id, uintN flags,
                   JSObject **objp);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_NW_Convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp);
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 XPC_NW_Finalize(JSContext *cx, JSObject *obj);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_NW_CheckAccess(JSContext *cx, JSObject *obj, jsval id,
                    JSAccessMode mode, jsval *vp);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_NW_Call(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
             jsval *rval);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_NW_Construct(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                  jsval *rval);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_NW_HasInstance(JSContext *cx, JSObject *obj, jsval v, JSBool *bp);
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 XPC_NW_Trace(JSTracer *trc, JSObject *obj);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_NW_Equality(JSContext *cx, JSObject *obj, jsval v, JSBool *bp);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_NW_FunctionWrapper(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                        jsval *rval);
 
 // JS class for XPCNativeWrapper (and this doubles as the constructor
 // for XPCNativeWrapper for the moment too...)
@@ -178,15 +178,15 @@ ShouldBypassNativeWrapper(JSContext *cx,
   XPC_NW_BYPASS_BASE(cx, obj,                                                 \
     JSClass *clasp_ = STOBJ_GET_CLASS(obj);                                  \
     return !clasp_->hook || clasp_->hook args;                                \
   )
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_NW_toString(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                 jsval *rval);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPCNativeWrapperCtor(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                      jsval *rval);
 
 static inline
 JSBool
@@ -274,11 +274,11 @@ XPC_NW_WrapFunction(JSContext* cx, JSObj
   ::JS_SetParent(cx, funWrapperObj, funobj);
   *rval = OBJECT_TO_JSVAL(funWrapperObj);
   return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_NW_AddProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 {
   JSProperty *prop;
   JSObject *pobj;
   jsid idAsId;
@@ -308,11 +308,11 @@ XPC_NW_AddProperty(JSContext *cx, JSObje
   // on |obj|.
   return EnsureLegalActivity(cx, obj) &&
          XPC_NW_RewrapIfDeepWrapper(cx, obj, *vp, vp);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_NW_DelProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 {
   if (!EnsureLegalActivity(cx, obj)) {
     return JS_FALSE;
   }
@@ -413,11 +413,11 @@ XPC_NW_RewrapIfDeepWrapper(JSContext *cx
   }
 
   return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_NW_FunctionWrapper(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                        jsval *rval)
 {
   JSObject *funObj = JSVAL_TO_OBJECT(argv[-2]);
   if (!::JS_ObjectIsFunction(cx, funObj)) {
@@ -529,23 +529,23 @@ XPC_NW_GetOrSetProperty(JSContext *cx, J
 
   return XPCWrapper::GetOrSetNativeProperty(cx, obj, wrappedNative, id, vp,
                                             aIsSet, JS_TRUE);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_NW_GetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 {
   return XPC_NW_GetOrSetProperty(cx, obj, id, vp, PR_FALSE);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_NW_SetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 {
   return XPC_NW_GetOrSetProperty(cx, obj, id, vp, PR_TRUE);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_NW_Enumerate(JSContext *cx, JSObject *obj)
 {
   // We are being notified of a for-in loop or similar operation on this
   // XPCNativeWrapper, so forward to the correct high-level object hook,
   // OBJ_ENUMERATE on the XPCWrappedNative's object, called via the
@@ -562,11 +562,11 @@ XPC_NW_Enumerate(JSContext *cx, JSObject
   }
 
   return XPCWrapper::Enumerate(cx, obj, wn->GetFlatJSObject());
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_NW_NewResolve(JSContext *cx, JSObject *obj, jsval id, uintN flags,
                   JSObject **objp)
 {
   // No need to preserve on sets of wrappedJSObject or toString, since callers
   // couldn't get at those values anyway.  Also, we always deal with
@@ -642,22 +642,22 @@ XPC_NW_NewResolve(JSContext *cx, JSObjec
                                            wrappedNative->GetFlatJSObject(),
                                            wrappedNative, id, flags, objp,
                                            JS_TRUE);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_NW_Convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp)
 {
   if (!EnsureLegalActivity(cx, obj)) {
     return JS_FALSE;
   }
 
   XPC_NW_BYPASS(cx, obj, convert, (cx, obj, type, vp));
   return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 XPC_NW_Finalize(JSContext *cx, JSObject *obj)
 {
   // We must not use obj's private data here since it's likely that it
   // has already been finalized.
   XPCJSRuntime *rt = nsXPConnect::GetRuntime();
@@ -667,11 +667,11 @@ XPC_NW_Finalize(JSContext *cx, JSObject 
     XPCAutoLock lock(rt->GetMapLock());
     rt->GetExplicitNativeWrapperMap()->Remove(obj);
   }
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_NW_CheckAccess(JSContext *cx, JSObject *obj, jsval id,
                    JSAccessMode mode, jsval *vp)
 {
   // Prevent setting __proto__ on an XPCNativeWrapper
   if ((mode & JSACC_WATCH) == JSACC_PROTO && (mode & JSACC_WRITE)) {
@@ -695,11 +695,11 @@ XPC_NW_CheckAccess(JSContext *cx, JSObje
   JSClass *clazz = STOBJ_GET_CLASS(wrapperJSObject);
   return !clazz->checkAccess ||
     clazz->checkAccess(cx, wrapperJSObject, id, mode, vp);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_NW_Call(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
   if (!XPCNativeWrapper::IsNativeWrapper(obj)) {
     // If obj is not an XPCNativeWrapper, then someone's probably trying to call
     // our prototype (i.e., XPCNativeWrapper.prototype()). In this case, it is
@@ -716,11 +716,11 @@ XPC_NW_Call(JSContext *cx, JSObject *obj
   XPC_NW_BYPASS_TEST(cx, obj, call, (cx, obj, argc, argv, rval));
 
   return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_NW_Construct(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                  jsval *rval)
 {
   // The object given to us by the JS engine is actually a stub object (the
   // "new" object). This isn't any help to us, so instead use the function
@@ -757,11 +757,11 @@ XPC_NW_Construct(JSContext *cx, JSObject
   }
 
   return XPC_NW_RewrapIfDeepWrapper(cx, obj, *rval, rval);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_NW_HasInstance(JSContext *cx, JSObject *obj, jsval v, JSBool *bp)
 {
   XPC_NW_BYPASS_TEST(cx, obj, hasInstance, (cx, obj, v, bp));
 
   return JS_TRUE;
@@ -783,11 +783,11 @@ MirrorWrappedNativeParent(JSContext *cx,
       return JS_FALSE;
   }
   return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPCNativeWrapperCtor(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                      jsval *rval)
 {
   if (argc < 1) {
     return ThrowException(NS_ERROR_XPC_NOT_ENOUGH_ARGS, cx);
@@ -973,22 +973,22 @@ XPCNativeWrapperCtor(JSContext *cx, JSOb
   }
 
   return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 XPC_NW_Trace(JSTracer *trc, JSObject *obj)
 {
   XPCWrappedNative *wrappedNative = XPCNativeWrapper::GetWrappedNative(obj);
 
   if (wrappedNative && wrappedNative->IsValid()) {
     JS_CALL_OBJECT_TRACER(trc, wrappedNative->GetFlatJSObject(),
                           "wrappedNative.flatJSObject");
   }
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_NW_Equality(JSContext *cx, JSObject *obj, jsval v, JSBool *bp)
 {
   NS_ASSERTION(XPCNativeWrapper::IsNativeWrapper(obj),
                "Uh, we should only ever be called for XPCNativeWrapper "
                "objects!");
@@ -1018,11 +1018,11 @@ XPC_NW_Equality(JSContext *cx, JSObject 
   }
 
   return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_NW_toString(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                 jsval *rval)
 {
   while (!XPCNativeWrapper::IsNativeWrapper(obj)) {
     obj = STOBJ_GET_PROTO(obj);
@@ -1176,11 +1176,11 @@ struct WrapperAndCxHolder
 {
     XPCWrappedNative* wrapper;
     JSContext* cx;
 };
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 ClearNativeWrapperScope(JSDHashTable *table, JSDHashEntryHdr *hdr,
                         uint32 number, void *arg)
 {
     JSDHashEntryStub* entry = (JSDHashEntryStub*)hdr;
     WrapperAndCxHolder* d = (WrapperAndCxHolder*)arg;
diff -r 14ce7619e9c1 js/src/xpconnect/src/XPCSafeJSObjectWrapper.cpp
--- a/js/src/xpconnect/src/XPCSafeJSObjectWrapper.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/xpconnect/src/XPCSafeJSObjectWrapper.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -40,54 +40,54 @@
 #include "xpcprivate.h"
 #include "jsdbgapi.h"
 #include "jsscript.h" // for js_ScriptClass
 #include "XPCWrapper.h"
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_SJOW_AddProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_SJOW_DelProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_SJOW_GetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_SJOW_SetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_SJOW_Enumerate(JSContext *cx, JSObject *obj);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_SJOW_NewResolve(JSContext *cx, JSObject *obj, jsval id, uintN flags,
                     JSObject **objp);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_SJOW_Convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp);
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 XPC_SJOW_Finalize(JSContext *cx, JSObject *obj);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_SJOW_CheckAccess(JSContext *cx, JSObject *obj, jsval id, JSAccessMode mode,
                      jsval *vp);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_SJOW_Call(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
               jsval *rval);
 
 JSBool
 XPC_SJOW_Construct(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                    jsval *rval);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_SJOW_Equality(JSContext *cx, JSObject *obj, jsval v, JSBool *bp);
 
-JS_STATIC_DLL_CALLBACK(JSObject *)
+static JSObject *
 XPC_SJOW_Iterator(JSContext *cx, JSObject *obj, JSBool keysonly);
 
-JS_STATIC_DLL_CALLBACK(JSObject *)
+static JSObject *
 XPC_SJOW_WrappedObject(JSContext *cx, JSObject *obj);
 
 static inline
 JSBool
 ThrowException(nsresult ex, JSContext *cx)
@@ -206,11 +206,11 @@ JSExtendedClass sXPC_SJOW_JSClass = {
   XPC_SJOW_Iterator,
   XPC_SJOW_WrappedObject,
   JSCLASS_NO_RESERVED_MEMBERS
 };
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_SJOW_toString(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                   jsval *rval);
 
 // Reserved slot indexes on safe wrappers.
 
@@ -460,11 +460,11 @@ GetScriptedFunction(JSContext *cx, JSObj
 
   return JS_TRUE;
 }
 
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_SJOW_AddProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 {
   // The constructor and toString properties needs to live on the safe
   // wrapper.
   if (id == GetRTStringByIndex(cx, XPCJSRuntime::IDX_CONSTRUCTOR) ||
@@ -496,11 +496,11 @@ XPC_SJOW_AddProperty(JSContext *cx, JSOb
   }
 
   return XPCWrapper::AddProperty(cx, obj, unsafeObj, id, vp);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_SJOW_DelProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 {
   JSObject *unsafeObj = GetUnsafeObject(obj);
   if (!unsafeObj) {
     return ThrowException(NS_ERROR_UNEXPECTED, cx);
@@ -517,11 +517,11 @@ XPC_SJOW_DelProperty(JSContext *cx, JSOb
 
 // Call wrapper to help with wrapping calls to functions or callable
 // objects in a scripted function (see XPC_SJOW_Call()). The first
 // argument passed to this method is the unsafe function to call, the
 // rest are the arguments to pass to the function we're calling.
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_SJOW_CallWrapper(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                      jsval *rval)
 {
   // Make sure we've got at least one argument (which may not be the
   // case if someone's monkeying with this function directly from JS).
@@ -585,23 +585,23 @@ XPC_SJOW_GetOrSetProperty(JSContext *cx,
                                      aIsSet ? 2 : 1, args, &val);
 
   return ok && WrapJSValue(cx, obj, val, vp);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_SJOW_GetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 {
   return XPC_SJOW_GetOrSetProperty(cx, obj, id, vp, PR_FALSE);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_SJOW_SetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 {
   return XPC_SJOW_GetOrSetProperty(cx, obj, id, vp, PR_TRUE);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_SJOW_Enumerate(JSContext *cx, JSObject *obj)
 {
   obj = FindSafeObject(obj);
   NS_ASSERTION(obj != nsnull, "FindSafeObject() returned null in class hook!");
 
@@ -629,11 +629,11 @@ XPC_SJOW_Enumerate(JSContext *cx, JSObje
   // access that, it'll throw and we'll be safe.
 
   return XPCWrapper::Enumerate(cx, obj, unsafeObj);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_SJOW_NewResolve(JSContext *cx, JSObject *obj, jsval id, uintN flags,
                     JSObject **objp)
 {
   obj = FindSafeObject(obj);
   NS_ASSERTION(obj != nsnull, "FindSafeObject() returned null in class hook!");
@@ -659,18 +659,18 @@ XPC_SJOW_NewResolve(JSContext *cx, JSObj
   }
 
   return XPCWrapper::NewResolve(cx, obj, unsafeObj, id, flags, objp);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_SJOW_Convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp)
 {
   NS_ASSERTION(type != JSTYPE_STRING, "toString failed us");
   return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 XPC_SJOW_Finalize(JSContext *cx, JSObject *obj)
 {
   // Release the reference to the cached principal if we have one.
   jsval v;
   if (::JS_GetReservedSlot(cx, obj, XPC_SJOW_SLOT_PRINCIPAL, &v) &&
@@ -679,11 +679,11 @@ XPC_SJOW_Finalize(JSContext *cx, JSObjec
 
     NS_RELEASE(principal);
   }
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_SJOW_CheckAccess(JSContext *cx, JSObject *obj, jsval id,
                      JSAccessMode mode, jsval *vp)
 {
   // Prevent setting __proto__ on an XPCSafeJSObjectWrapper
   if ((mode & JSACC_WATCH) == JSACC_PROTO && (mode & JSACC_WRITE)) {
@@ -712,11 +712,11 @@ XPC_SJOW_CheckAccess(JSContext *cx, JSOb
   JSClass *clazz = STOBJ_GET_CLASS(unsafeObj);
   return !clazz->checkAccess ||
     clazz->checkAccess(cx, unsafeObj, id, mode, vp);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_SJOW_Call(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
               jsval *rval)
 {
   JSObject *tmp = FindSafeObject(obj);
   JSObject *unsafeObj, *callThisObj = nsnull;
@@ -943,11 +943,11 @@ XPC_SJOW_Construct(JSContext *cx, JSObje
   *rval = OBJECT_TO_JSVAL(wrapperObj);
 
   return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_SJOW_Equality(JSContext *cx, JSObject *obj, jsval v, JSBool *bp)
 {
   if (JSVAL_IS_PRIMITIVE(v)) {
     *bp = JS_FALSE;
   } else {
@@ -974,11 +974,11 @@ XPC_SJOW_Equality(JSContext *cx, JSObjec
   }
 
   return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSObject *)
+static JSObject *
 XPC_SJOW_Iterator(JSContext *cx, JSObject *obj, JSBool keysonly)
 {
   obj = FindSafeObject(obj);
   NS_ASSERTION(obj != nsnull, "FindSafeObject() returned null in class hook!");
 
@@ -1013,17 +1013,17 @@ XPC_SJOW_Iterator(JSContext *cx, JSObjec
   // Initialize the wrapper.
   return XPCWrapper::CreateIteratorObj(cx, wrapperIter, obj, unsafeObj,
                                        keysonly);
 }
 
-JS_STATIC_DLL_CALLBACK(JSObject *)
+static JSObject *
 XPC_SJOW_WrappedObject(JSContext *cx, JSObject *obj)
 {
   return GetUnsafeObject(obj);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_SJOW_toString(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                   jsval *rval)
 {
   obj = FindSafeObject(obj);
   if (!obj) {
diff -r 14ce7619e9c1 js/src/xpconnect/src/XPCWrapper.cpp
--- a/js/src/xpconnect/src/XPCWrapper.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/xpconnect/src/XPCWrapper.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -53,11 +53,11 @@ XPCWrapper::sNumSlots = 2;
 XPCWrapper::sNumSlots = 2;
 
 JSNative
 XPCWrapper::sEvalNative = nsnull;
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 IteratorFinalize(JSContext *cx, JSObject *obj)
 {
   jsval v;
   JS_GetReservedSlot(cx, obj, 0, &v);
 
@@ -65,11 +65,11 @@ IteratorFinalize(JSContext *cx, JSObject
   if (ida) {
     JS_DestroyIdArray(cx, ida);
   }
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 IteratorNext(JSContext *cx, uintN argc, jsval *vp)
 {
   JSObject *obj;
   jsval v;
  
diff -r 14ce7619e9c1 js/src/xpconnect/src/nsXPConnect.cpp
--- a/js/src/xpconnect/src/nsXPConnect.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/xpconnect/src/nsXPConnect.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -423,11 +423,11 @@ static PRBool gDidCollection;
 // Whether starting cycle collection was successful.
 static PRBool gInCollection;
 // Whether cycle collection collected anything.
 static PRBool gCollected;
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPCCycleCollectGCCallback(JSContext *cx, JSGCStatus status)
 {
     // Launch the cycle collector.
     if(status == JSGC_MARK_END)
     {
@@ -552,11 +552,11 @@ struct NoteJSRootTracer : public JSTrace
     }
     PLDHashTable* mObjects;
     nsCycleCollectionTraversalCallback& mCb;
 };
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 NoteJSRoot(JSTracer *trc, void *thing, uint32 kind)
 {
     if(ADD_TO_CC(kind))
     {
         NoteJSRootTracer *tracer = static_cast<NoteJSRootTracer*>(trc);
@@ -717,11 +717,11 @@ struct TraversalTracer : public JSTracer
     {
     }
     nsCycleCollectionTraversalCallback &cb;
 };
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 NoteJSChild(JSTracer *trc, void *thing, uint32 kind)
 {
     if(ADD_TO_CC(kind))
     {
         TraversalTracer *tracer = static_cast<TraversalTracer*>(trc);
@@ -1111,11 +1111,11 @@ nsXPConnect::InitClasses(JSContext * aJS
         return UnexpectedFailure(NS_ERROR_FAILURE);
 
     return NS_OK;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 TempGlobalResolve(JSContext *aJSContext, JSObject *obj, jsval id)
 {
     JSBool resolved;
     return JS_ResolveStandardClass(aJSContext, obj, id, &resolved);
 }
@@ -1404,11 +1404,11 @@ nsXPConnect::ReparentWrappedNativeIfFoun
     return XPCWrappedNative::
         ReparentWrapperIfFound(ccx, scope, scope2, aNewParent, aCOMObj,
                                (XPCWrappedNative**) _retval);
 }
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 MoveableWrapperFinder(JSDHashTable *table, JSDHashEntryHdr *hdr,
                       uint32 number, void *arg)
 {
     // Every element counts.
     nsVoidArray *va = static_cast<nsVoidArray *>(arg);
diff -r 14ce7619e9c1 js/src/xpconnect/src/qsgen.py
--- a/js/src/xpconnect/src/qsgen.py	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/xpconnect/src/qsgen.py	Mon Sep 08 10:35:45 2008 +0300
@@ -615,11 +615,11 @@ def writeQuickStub(f, member, stubName, 
     isMethod = (member.kind == 'method')
     assert isAttr or isMethod
     isGetter = isAttr and not isSetter
 
     # Function prolog.
-    f.write("static JS_DLL_CALLBACK JSBool\n")
+    f.write("static JSBool\n")
     if isAttr:
         # JSPropertyOp signature.
         f.write(stubName + "(JSContext *cx, JSObject *obj, jsval id, "
                 "jsval *vp)\n")
     else:
diff -r 14ce7619e9c1 js/src/xpconnect/src/xpccomponents.cpp
--- a/js/src/xpconnect/src/xpccomponents.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/xpconnect/src/xpccomponents.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -2967,11 +2967,11 @@ PrincipalHolder::GetPrincipal()
 PrincipalHolder::GetPrincipal()
 {
     return mHoldee;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 SandboxDump(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
     JSString *str;
     if (!argc)
         return JS_TRUE;
@@ -2986,21 +2986,21 @@ SandboxDump(JSContext *cx, JSObject *obj
 
     fputs(bytes, stderr);
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 SandboxDebug(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
 #ifdef DEBUG
     return SandboxDump(cx, obj, argc, argv, rval);
 #else
     return JS_TRUE;
 #endif
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 SandboxFunForwarder(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                     jsval *rval)
 {
     jsval v;
     if (!JS_GetReservedSlot(cx, JSVAL_TO_OBJECT(argv[-2]), 0, &v) ||
@@ -3013,11 +3013,11 @@ SandboxFunForwarder(JSContext *cx, JSObj
     
     XPCThrower::Throw(NS_ERROR_NOT_IMPLEMENTED, cx);
     return JS_FALSE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 SandboxImport(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
               jsval *rval)
 {
     if (argc < 1) {
         XPCThrower::Throw(NS_ERROR_INVALID_ARG, cx);
@@ -3079,24 +3079,24 @@ SandboxImport(JSContext *cx, JSObject *o
     // Functions come with two extra reserved slots on them. Use the 0-th slot
     // to communicate the wrapped function to our forwarder.
     return JS_SetReservedSlot(cx, newfunobj, 0, argv[0]);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 sandbox_enumerate(JSContext *cx, JSObject *obj)
 {
     return JS_EnumerateStandardClasses(cx, obj);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 sandbox_resolve(JSContext *cx, JSObject *obj, jsval id)
 {
     JSBool resolved;
     return JS_ResolveStandardClass(cx, obj, id, &resolved);
 }
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 sandbox_finalize(JSContext *cx, JSObject *obj)
 {
     nsIScriptObjectPrincipal *sop =
         (nsIScriptObjectPrincipal *)xpc_GetJSPrivate(obj);
     NS_IF_RELEASE(sop);
@@ -3342,11 +3342,11 @@ public:
     }
 
     NS_DECL_ISUPPORTS
 
 private:
-    static JSBool JS_DLL_CALLBACK ContextHolderOperationCallback(JSContext *cx);
+    static JSBool ContextHolderOperationCallback(JSContext *cx);
     
     XPCAutoJSContext mJSContext;
     JSContext* mOrigCx;
 };
 
@@ -3370,11 +3370,11 @@ ContextHolder::ContextHolder(JSContext *
                                     JS_GetOperationLimit(aOuterCx));
         }
     }
 }
 
-JSBool JS_DLL_CALLBACK
+JSBool
 ContextHolder::ContextHolderOperationCallback(JSContext *cx)
 {
     ContextHolder* thisObject =
         static_cast<ContextHolder*>(JS_GetContextPrivate(cx));
     NS_ASSERTION(thisObject, "How did that happen?");
diff -r 14ce7619e9c1 js/src/xpconnect/src/xpcconvert.cpp
--- a/js/src/xpconnect/src/xpcconvert.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/xpconnect/src/xpcconvert.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -163,11 +163,11 @@ XPCConvert::GetISupportsFromJSObject(JSO
     return JS_FALSE;
 }
 
 /***************************************************************************/
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 FinalizeXPCOMUCString(JSContext *cx, JSString *str)
 {
     NS_ASSERTION(sXPCOMUCStringFinalizerIndex != -1,
                  "XPCConvert: XPCOM Unicode string finalizer called uninitialized!");
 
@@ -1643,11 +1643,11 @@ XPCConvert::JSErrorToXPCException(XPCCal
 #endif
 
 // We assert below that these formats all begin with "%i".
 const char* XPC_ARG_FORMATTER_FORMAT_STRINGS[] = {"%ip", "%iv", "%is", nsnull};
 
-JSBool JS_DLL_CALLBACK
+JSBool
 XPC_JSArgumentFormatter(JSContext *cx, const char *format,
                         JSBool fromJS, jsval **vpp, va_list *app)
 {
     XPCCallContext ccx(NATIVE_CALLER, cx);
     if(!ccx.IsValid())
diff -r 14ce7619e9c1 js/src/xpconnect/src/xpcdebug.cpp
--- a/js/src/xpconnect/src/xpcdebug.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/xpconnect/src/xpcdebug.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -303,11 +303,11 @@ xpc_DumpJSStack(JSContext* cx, JSBool sh
     return JS_TRUE;
 }
 
 /***************************************************************************/
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 xpcDumpEvalErrorReporter(JSContext *cx, const char *message,
                          JSErrorReport *report)
 {
     printf("Error: %s\n", message);
 }
@@ -361,11 +361,11 @@ xpc_DumpEvalInJSStackFrame(JSContext* cx
     return JS_TRUE;
 }
 
 /***************************************************************************/
 
-JSTrapStatus JS_DLL_CALLBACK
+JSTrapStatus
 xpc_DebuggerKeywordHandler(JSContext *cx, JSScript *script, jsbytecode *pc,
                            jsval *rval, void *closure)
 {
     static const char line[] =
     "------------------------------------------------------------------------";
diff -r 14ce7619e9c1 js/src/xpconnect/src/xpcjsruntime.cpp
--- a/js/src/xpconnect/src/xpcjsruntime.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/xpconnect/src/xpcjsruntime.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -81,11 +81,11 @@ struct JSDyingJSObjectData
 {
     JSContext* cx;
     nsVoidArray* array;
 };
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 WrappedJSDyingJSObjectFinder(JSDHashTable *table, JSDHashEntryHdr *hdr,
                 uint32 number, void *arg)
 {
     JSDyingJSObjectData* data = (JSDyingJSObjectData*) arg;
     nsXPCWrappedJS* wrapper = ((JSObject2WrappedJSMap::Entry*)hdr)->value;
@@ -108,21 +108,21 @@ struct CX_AND_XPCRT_Data
 {
     JSContext* cx;
     XPCJSRuntime* rt;
 };
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 NativeInterfaceGC(JSDHashTable *table, JSDHashEntryHdr *hdr,
                   uint32 number, void *arg)
 {
     CX_AND_XPCRT_Data* data = (CX_AND_XPCRT_Data*) arg;
     ((IID2NativeInterfaceMap::Entry*)hdr)->value->
             DealWithDyingGCThings(data->cx, data->rt);
     return JS_DHASH_NEXT;
 }
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 NativeInterfaceSweeper(JSDHashTable *table, JSDHashEntryHdr *hdr,
                        uint32 number, void *arg)
 {
     CX_AND_XPCRT_Data* data = (CX_AND_XPCRT_Data*) arg;
     XPCNativeInterface* iface = ((IID2NativeInterfaceMap::Entry*)hdr)->value;
@@ -144,21 +144,21 @@ NativeInterfaceSweeper(JSDHashTable *tab
 // *Some* NativeSets are referenced from mClassInfo2NativeSetMap.
 // *All* NativeSets are referenced from mNativeSetMap.
 // So, in mClassInfo2NativeSetMap we just clear references to the unmarked.
 // In mNativeSetMap we clear the references to the unmarked *and* delete them.
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 NativeUnMarkedSetRemover(JSDHashTable *table, JSDHashEntryHdr *hdr,
                          uint32 number, void *arg)
 {
     XPCNativeSet* set = ((ClassInfo2NativeSetMap::Entry*)hdr)->value;
     if(set->IsMarked())
         return JS_DHASH_NEXT;
     return JS_DHASH_REMOVE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 NativeSetSweeper(JSDHashTable *table, JSDHashEntryHdr *hdr,
                  uint32 number, void *arg)
 {
     XPCNativeSet* set = ((NativeSetMap::Entry*)hdr)->key_value;
     if(set->IsMarked())
@@ -179,11 +179,11 @@ NativeSetSweeper(JSDHashTable *table, JS
 
     XPCNativeSet::DestroyInstance(set);
     return JS_DHASH_REMOVE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 JSClassSweeper(JSDHashTable *table, JSDHashEntryHdr *hdr,
                uint32 number, void *arg)
 {
     XPCNativeScriptableShared* shared =
         ((XPCNativeScriptableSharedMap::Entry*) hdr)->key;
@@ -206,21 +206,21 @@ JSClassSweeper(JSDHashTable *table, JSDH
 
     delete shared;
     return JS_DHASH_REMOVE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 DyingProtoKiller(JSDHashTable *table, JSDHashEntryHdr *hdr,
                  uint32 number, void *arg)
 {
     XPCWrappedNativeProto* proto =
         (XPCWrappedNativeProto*)((JSDHashEntryStub*)hdr)->key;
     delete proto;
     return JS_DHASH_REMOVE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 DetachedWrappedNativeProtoMarker(JSDHashTable *table, JSDHashEntryHdr *hdr,
                                  uint32 number, void *arg)
 {
     XPCWrappedNativeProto* proto = 
         (XPCWrappedNativeProto*)((JSDHashEntryStub*)hdr)->key;
@@ -228,11 +228,11 @@ DetachedWrappedNativeProtoMarker(JSDHash
     proto->Mark();
     return JS_DHASH_NEXT;
 }
 
 // GCCallback calls are chained
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 ContextCallback(JSContext *cx, uintN operation)
 {
     XPCJSRuntime* self = nsXPConnect::GetRuntime();
     if (self)
     {
@@ -337,11 +337,11 @@ TraceJSObject(PRUint32 aLangID, void *aS
                        js_GetGCThingTraceKind(aScriptThing),
                        "JSObjectHolder");
     }
 }
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 TraceJSHolder(JSDHashTable *table, JSDHashEntryHdr *hdr, uint32 number,
               void *arg)
 {
     ObjectHolder* entry = reinterpret_cast<ObjectHolder*>(hdr);
 
@@ -386,11 +386,11 @@ void XPCJSRuntime::TraceXPConnectRoots(J
 
     if(mJSHolders.ops)
         JS_DHashTableEnumerate(&mJSHolders, TraceJSHolder, trc);
 }
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 NoteJSHolder(JSDHashTable *table, JSDHashEntryHdr *hdr, uint32 number,
              void *arg)
 {
     ObjectHolder* entry = reinterpret_cast<ObjectHolder*>(hdr);
 
@@ -832,22 +832,22 @@ JSBool XPCJSRuntime::GCCallback(JSContex
 }
 
 /***************************************************************************/
 
 #ifdef XPC_CHECK_WRAPPERS_AT_SHUTDOWN
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 DEBUG_WrapperChecker(JSDHashTable *table, JSDHashEntryHdr *hdr,
                      uint32 number, void *arg)
 {
     XPCWrappedNative* wrapper = (XPCWrappedNative*)((JSDHashEntryStub*)hdr)->key;
     NS_ASSERTION(!wrapper->IsValid(), "found a 'valid' wrapper!");
     ++ *((int*)arg);
     return JS_DHASH_NEXT;
 }
 #endif
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 WrappedJSShutdownMarker(JSDHashTable *table, JSDHashEntryHdr *hdr,
                         uint32 number, void *arg)
 {
     JSRuntime* rt = (JSRuntime*) arg;
     nsXPCWrappedJS* wrapper = ((JSObject2WrappedJSMap::Entry*)hdr)->value;
@@ -855,11 +855,11 @@ WrappedJSShutdownMarker(JSDHashTable *ta
     NS_ASSERTION(wrapper->IsValid(), "found an invalid JS wrapper!");
     wrapper->SystemIsBeingShutDown(rt);
     return JS_DHASH_NEXT;
 }
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 DetachedWrappedNativeProtoShutdownMarker(JSDHashTable *table, JSDHashEntryHdr *hdr,
                                          uint32 number, void *arg)
 {
     XPCWrappedNativeProto* proto = 
         (XPCWrappedNativeProto*)((JSDHashEntryStub*)hdr)->key;
@@ -1147,11 +1147,11 @@ XPCJSRuntime::GetXPCContext(JSContext* c
         xpcc = SyncXPCContextList(cx);
     return xpcc;
 }
 
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 SweepContextsCB(JSDHashTable *table, JSDHashEntryHdr *hdr,
                 uint32 number, void *arg)
 {
     XPCContext* xpcc = ((JSContext2XPCContextMap::Entry*)hdr)->value;
     if(xpcc->IsMarked())
@@ -1214,11 +1214,11 @@ XPCJSRuntime::SyncXPCContextList(JSConte
 
     return found;
 }
 
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 PurgeContextsCB(JSDHashTable *table, JSDHashEntryHdr *hdr,
                 uint32 number, void *arg)
 {
     delete ((JSContext2XPCContextMap::Entry*)hdr)->value;
     return JS_DHASH_REMOVE;
@@ -1268,32 +1268,32 @@ XPCJSRuntime::DeferredRelease(nsISupport
 }
 
 /***************************************************************************/
 
 #ifdef DEBUG
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 ContextMapDumpEnumerator(JSDHashTable *table, JSDHashEntryHdr *hdr,
                          uint32 number, void *arg)
 {
     ((JSContext2XPCContextMap::Entry*)hdr)->value->DebugDump(*(PRInt16*)arg);
     return JS_DHASH_NEXT;
 }
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 WrappedJSClassMapDumpEnumerator(JSDHashTable *table, JSDHashEntryHdr *hdr,
                                 uint32 number, void *arg)
 {
     ((IID2WrappedJSClassMap::Entry*)hdr)->value->DebugDump(*(PRInt16*)arg);
     return JS_DHASH_NEXT;
 }
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 WrappedJSMapDumpEnumerator(JSDHashTable *table, JSDHashEntryHdr *hdr,
                            uint32 number, void *arg)
 {
     ((JSObject2WrappedJSMap::Entry*)hdr)->value->DebugDump(*(PRInt16*)arg);
     return JS_DHASH_NEXT;
 }
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 NativeSetDumpEnumerator(JSDHashTable *table, JSDHashEntryHdr *hdr,
                         uint32 number, void *arg)
 {
     ((NativeSetMap::Entry*)hdr)->key_value->DebugDump(*(PRInt16*)arg);
     return JS_DHASH_NEXT;
diff -r 14ce7619e9c1 js/src/xpconnect/src/xpcmaps.cpp
--- a/js/src/xpconnect/src/xpcmaps.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/xpconnect/src/xpcmaps.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -47,26 +47,26 @@
 // static shared...
 
 // Note this is returning the bit pattern of the first part of the nsID, not
 // the pointer to the nsID.
 
-static JSDHashNumber JS_DLL_CALLBACK
+static JSDHashNumber
 HashIIDPtrKey(JSDHashTable *table, const void *key)
 {
     return *((JSHashNumber*)key);
 }
 
-static JSBool JS_DLL_CALLBACK
+static JSBool
 MatchIIDPtrKey(JSDHashTable *table,
             const JSDHashEntryHdr *entry,
             const void *key)
 {
     return ((const nsID*)key)->
                 Equals(*((const nsID*)((JSDHashEntryStub*)entry)->key));
 }
 
-static JSDHashNumber JS_DLL_CALLBACK
+static JSDHashNumber
 HashNativeKey(JSDHashTable *table, const void *key)
 {
     XPCNativeSetKey* Key = (XPCNativeSetKey*) key;
 
     JSDHashNumber h = 0;
@@ -325,11 +325,11 @@ ClassInfo2WrappedNativeProtoMap::~ClassI
 }
 
 /***************************************************************************/
 // implement NativeSetMap...
 
-JSBool JS_DLL_CALLBACK
+JSBool
 NativeSetMap::Entry::Match(JSDHashTable *table,
                            const JSDHashEntryHdr *entry,
                            const void *key)
 {
     XPCNativeSetKey* Key = (XPCNativeSetKey*) key;
@@ -440,19 +440,19 @@ NativeSetMap::~NativeSetMap()
 }
 
 /***************************************************************************/
 // implement IID2ThisTranslatorMap...
 
-JSBool JS_DLL_CALLBACK
+JSBool
 IID2ThisTranslatorMap::Entry::Match(JSDHashTable *table,
                                     const JSDHashEntryHdr *entry,
                                     const void *key)
 {
     return ((const nsID*)key)->Equals(((Entry*)entry)->key);
 }
 
-void JS_DLL_CALLBACK
+void
 IID2ThisTranslatorMap::Entry::Clear(JSDHashTable *table, JSDHashEntryHdr *entry)
 {
     NS_IF_RELEASE(((Entry*)entry)->value);
     memset(entry, 0, table->entrySize);
 }
@@ -490,11 +490,11 @@ IID2ThisTranslatorMap::~IID2ThisTranslat
         JS_DHashTableDestroy(mTable);
 }
 
 /***************************************************************************/
 
-JSDHashNumber JS_DLL_CALLBACK
+JSDHashNumber
 XPCNativeScriptableSharedMap::Entry::Hash(JSDHashTable *table, const void *key)
 {
     JSDHashNumber h;
     const unsigned char *s;
 
@@ -507,11 +507,11 @@ XPCNativeScriptableSharedMap::Entry::Has
     for (s = (const unsigned char*) obj->GetJSClass()->name; *s != '\0'; s++)
         h = JS_ROTATE_LEFT32(h, 4) ^ *s;
     return h;
 }
 
-JSBool JS_DLL_CALLBACK
+JSBool
 XPCNativeScriptableSharedMap::Entry::Match(JSDHashTable *table,
                                          const JSDHashEntryHdr *entry,
                                          const void *key)
 {
     XPCNativeScriptableShared* obj1 =
diff -r 14ce7619e9c1 js/src/xpconnect/src/xpcmaps.h
--- a/js/src/xpconnect/src/xpcmaps.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/xpconnect/src/xpcmaps.h	Mon Sep 08 10:35:45 2008 +0300
@@ -455,11 +455,11 @@ public:
 public:
     struct Entry : public JSDHashEntryHdr
     {
         XPCNativeSet* key_value;
 
-        static JSBool JS_DLL_CALLBACK
+        static JSBool
         Match(JSDHashTable *table,
               const JSDHashEntryHdr *entry,
               const void *key);
 
         static struct JSDHashTableOps sOps;
@@ -524,16 +524,16 @@ public:
     struct Entry : public JSDHashEntryHdr
     {
         nsIID                         key;
         nsIXPCFunctionThisTranslator* value;
 
-        static JSBool JS_DLL_CALLBACK
+        static JSBool
         Match(JSDHashTable *table,
               const JSDHashEntryHdr *entry,
               const void *key);
 
-        static void JS_DLL_CALLBACK
+        static void
         Clear(JSDHashTable *table, JSDHashEntryHdr *entry);
 
         static struct JSDHashTableOps sOps;
     };
 
@@ -587,14 +587,14 @@ public:
 public:
     struct Entry : public JSDHashEntryHdr
     {
         XPCNativeScriptableShared* key;
 
-        static JSDHashNumber JS_DLL_CALLBACK
+        static JSDHashNumber
         Hash(JSDHashTable *table, const void *key);
 
-        static JSBool JS_DLL_CALLBACK
+        static JSBool
         Match(JSDHashTable *table,
               const JSDHashEntryHdr *entry,
               const void *key);
 
         static struct JSDHashTableOps sOps;
diff -r 14ce7619e9c1 js/src/xpconnect/src/xpcprivate.h
--- a/js/src/xpconnect/src/xpcprivate.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/xpconnect/src/xpcprivate.h	Mon Sep 08 10:35:45 2008 +0300
@@ -707,16 +707,16 @@ public:
     {
         NS_ASSERTION(index < IDX_TOTAL_COUNT, "index out of range");
         return mStrings[index];
     }
 
-    static void JS_DLL_CALLBACK TraceJS(JSTracer* trc, void* data);
+    static void TraceJS(JSTracer* trc, void* data);
     void TraceXPConnectRoots(JSTracer *trc);
     void AddXPConnectRoots(JSContext* cx,
                            nsCycleCollectionTraversalCallback& cb);
 
-    static JSBool JS_DLL_CALLBACK GCCallback(JSContext *cx, JSGCStatus status);
+    static JSBool GCCallback(JSContext *cx, JSGCStatus status);
 
     inline void AddVariantRoot(XPCTraceableVariant* variant);
     inline void AddWrappedJSRoot(nsXPCWrappedJS* wrappedJS);
     inline void AddObjectHolderRoot(XPCJSObjectHolder* holder);
 
@@ -1169,24 +1169,24 @@ extern JSClass XPC_WN_ModsAllowed_WithCa
 extern JSClass XPC_WN_ModsAllowed_WithCall_Proto_JSClass;
 extern JSClass XPC_WN_ModsAllowed_NoCall_Proto_JSClass;
 extern JSClass XPC_WN_Tearoff_JSClass;
 extern JSClass XPC_WN_NoHelper_Proto_JSClass;
 
-extern JSObjectOps * JS_DLL_CALLBACK
+extern JSObjectOps *
 XPC_WN_GetObjectOpsNoCall(JSContext *cx, JSClass *clazz);
 
-extern JSObjectOps * JS_DLL_CALLBACK
+extern JSObjectOps *
 XPC_WN_GetObjectOpsWithCall(JSContext *cx, JSClass *clazz);
 
-extern JSObjectOps * JS_DLL_CALLBACK
+extern JSObjectOps *
 XPC_WN_Proto_GetObjectOps(JSContext *cx, JSClass *clazz);
 
-extern JSBool JS_DLL_CALLBACK
+extern JSBool
 XPC_WN_CallMethod(JSContext *cx, JSObject *obj,
                   uintN argc, jsval *argv, jsval *vp);
 
-extern JSBool JS_DLL_CALLBACK
+extern JSBool
 XPC_WN_GetterSetter(JSContext *cx, JSObject *obj,
                     uintN argc, jsval *argv, jsval *vp);
 
 extern JSBool
 xpc_InitWrappedNativeJSOps();
@@ -2799,11 +2799,11 @@ public:
 
 private:
     XPCStringConvert();         // not implemented
 };
 
-extern JSBool JS_DLL_CALLBACK
+extern JSBool
 XPC_JSArgumentFormatter(JSContext *cx, const char *format,
                         JSBool fromJS, jsval **vpp, va_list *app);
 
 
 /***************************************************************************/
diff -r 14ce7619e9c1 js/src/xpconnect/src/xpcstring.cpp
--- a/js/src/xpconnect/src/xpcstring.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/xpconnect/src/xpcstring.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -55,11 +55,11 @@
 #include "xpcprivate.h"
 #include "nsStringBuffer.h"
 
 static int sDOMStringFinalizerIndex = -1;
 
-static void JS_DLL_CALLBACK
+static void
 DOMStringFinalizer(JSContext *cx, JSString *str)
 {
     nsStringBuffer::FromData(JS_GetStringChars(str))->Release();
 }
 
diff -r 14ce7619e9c1 js/src/xpconnect/src/xpcthreadcontext.cpp
--- a/js/src/xpconnect/src/xpcthreadcontext.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/xpconnect/src/xpcthreadcontext.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -151,18 +151,18 @@ XPCJSContextStack::DEBUG_StackHasJSConte
             return JS_TRUE;
     return JS_FALSE;
 }
 #endif
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 SafeGlobalResolve(JSContext *cx, JSObject *obj, jsval id)
 {
     JSBool resolved;
     return JS_ResolveStandardClass(cx, obj, id, &resolved);
 }
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 SafeFinalize(JSContext* cx, JSObject* obj)
 {
 #ifndef XPCONNECT_STANDALONE
     nsIScriptObjectPrincipal* sop =
         static_cast<nsIScriptObjectPrincipal*>(xpc_GetJSPrivate(obj));
@@ -457,12 +457,10 @@ GetThreadStackLimit()
                  : (jsuword) -1;
 #endif
 
   return stackLimit;
 }
-
-MOZ_DECL_CTOR_COUNTER(xpcPerThreadData)
 
 XPCPerThreadData::XPCPerThreadData()
     :   mJSContextStack(new XPCJSContextStack()),
         mNextThread(nsnull),
         mCallContext(nsnull),
diff -r 14ce7619e9c1 js/src/xpconnect/src/xpcwrappedjsclass.cpp
--- a/js/src/xpconnect/src/xpcwrappedjsclass.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/xpconnect/src/xpcwrappedjsclass.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -708,11 +708,11 @@ nsXPCWrappedJSClass::GetRootJSObject(XPC
     JSObject* result = CallQueryInterfaceOnJSObject(ccx, aJSObj,
                                                     NS_GET_IID(nsISupports));
     return result ? result : aJSObj;
 }
 
-void JS_DLL_CALLBACK
+void
 xpcWrappedJSErrorReporter(JSContext *cx, const char *message,
                           JSErrorReport *report)
 {
     if(report)
     {
diff -r 14ce7619e9c1 js/src/xpconnect/src/xpcwrappednativejsops.cpp
--- a/js/src/xpconnect/src/xpcwrappednativejsops.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/xpconnect/src/xpcwrappednativejsops.cpp	Mon Sep 08 10:35:45 2008 +0300
@@ -117,21 +117,21 @@ ToStringGuts(XPCCallContext& ccx)
     return JS_TRUE;
 }
 
 /***************************************************************************/
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_WN_Shared_ToString(JSContext *cx, JSObject *obj,
                        uintN argc, jsval *argv, jsval *vp)
 {
     XPCCallContext ccx(JS_CALLER, cx, obj);
     ccx.SetName(ccx.GetRuntime()->GetStringJSVal(XPCJSRuntime::IDX_TO_STRING));
     ccx.SetArgsAndResultPtr(argc, argv, vp);
     return ToStringGuts(ccx);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_WN_Shared_ToSource(JSContext *cx, JSObject *obj,
                        uintN argc, jsval *argv, jsval *vp)
 {
     static const char empty[] = "{}";
     *vp = STRING_TO_JSVAL(JS_NewStringCopyN(cx, empty, sizeof(empty)-1));
@@ -176,11 +176,11 @@ GetDoubleWrappedJSObject(XPCCallContext&
 }
 
 // This is the getter native function we use to handle 'wrappedJSObject' for
 // double wrapped JSObjects.
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_WN_DoubleWrappedGetter(JSContext *cx, JSObject *obj,
                            uintN argc, jsval *argv, jsval *vp)
 {
     XPCCallContext ccx(JS_CALLER, cx, obj);
     XPCWrappedNative* wrapper = ccx.GetWrapper();
@@ -489,11 +489,11 @@ DefinePropertyIfFound(XPCCallContext& cc
 }
 
 /***************************************************************************/
 /***************************************************************************/
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_WN_OnlyIWrite_PropertyStub(JSContext *cx, JSObject *obj, jsval idval, jsval *vp)
 {
     CHECK_IDVAL(cx, idval);
 
     XPCCallContext ccx(JS_CALLER, cx, obj, nsnull, idval);
@@ -505,18 +505,18 @@ XPC_WN_OnlyIWrite_PropertyStub(JSContext
         return JS_TRUE;
 
     return Throw(NS_ERROR_XPC_CANT_MODIFY_PROP_ON_WN, cx);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_WN_CannotModifyPropertyStub(JSContext *cx, JSObject *obj, jsval idval, jsval *vp)
 {
     CHECK_IDVAL(cx, idval);
     return Throw(NS_ERROR_XPC_CANT_MODIFY_PROP_ON_WN, cx);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_WN_Shared_Convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp)
 {
     if(type == JSTYPE_OBJECT)
     {
         *vp = OBJECT_TO_JSVAL(obj);
@@ -574,11 +574,11 @@ XPC_WN_Shared_Convert(JSContext *cx, JSO
     }
     NS_NOTREACHED("huh?");
     return JS_FALSE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_WN_Shared_Enumerate(JSContext *cx, JSObject *obj)
 {
     XPCCallContext ccx(JS_CALLER, cx, obj);
     XPCWrappedNative* wrapper = ccx.GetWrapper();
     THROW_AND_RETURN_IF_BAD_WRAPPER(cx, wrapper);
@@ -629,11 +629,11 @@ XPC_WN_Shared_Enumerate(JSContext *cx, J
     return JS_TRUE;
 }
 
 /***************************************************************************/
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 XPC_WN_NoHelper_Finalize(JSContext *cx, JSObject *obj)
 {
     XPCWrappedNative* p = (XPCWrappedNative*) xpc_GetJSPrivate(obj);
     if(!p)
         return;
@@ -693,21 +693,21 @@ xpc_TraceForValidWrapper(JSTracer *trc, 
     wrapper->TraceJS(trc);
      
     TraceScopeJSObjects(trc, wrapper->GetScope());
 }
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 XPC_WN_Shared_Trace(JSTracer *trc, JSObject *obj)
 {
     XPCWrappedNative* wrapper =
         XPCWrappedNative::GetWrappedNativeOfJSObject(trc->context, obj);
 
     if(wrapper && wrapper->IsValid())
         xpc_TraceForValidWrapper(trc, wrapper);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_WN_NoHelper_Resolve(JSContext *cx, JSObject *obj, jsval idval)
 {
     CHECK_IDVAL(cx, idval);
 
     XPCCallContext ccx(JS_CALLER, cx, obj, nsnull, idval);
@@ -749,11 +749,11 @@ XPC_GetIdentityObject(JSContext *cx, JSO
     }
 
     return wrapper->GetIdentityObject();
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_WN_Equality(JSContext *cx, JSObject *obj, jsval v, JSBool *bp)
 {
     *bp = JS_FALSE;
 
     XPCWrappedNative *wrapper =
@@ -787,11 +787,11 @@ XPC_WN_Equality(JSContext *cx, JSObject 
     }
 
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSObject *)
+static JSObject *
 XPC_WN_OuterObject(JSContext *cx, JSObject *obj)
 {
     XPCWrappedNative *wrapper =
         XPCWrappedNative::GetWrappedNativeOfJSObject(cx, obj);
     if(!wrapper)
@@ -826,11 +826,11 @@ XPC_WN_OuterObject(JSContext *cx, JSObje
     }
 
     return obj;
 }
 
-JS_STATIC_DLL_CALLBACK(JSObject *)
+static JSObject *
 XPC_WN_InnerObject(JSContext *cx, JSObject *obj)
 {
     XPCWrappedNative *wrapper =
         XPCWrappedNative::GetWrappedNativeOfJSObject(cx, obj);
     if(!wrapper)
@@ -903,11 +903,11 @@ JSExtendedClass XPC_WN_NoHelper_JSClass 
 };
 
 
 /***************************************************************************/
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_WN_MaybeResolvingPropertyStub(JSContext *cx, JSObject *obj, jsval idval, jsval *vp)
 {
     CHECK_IDVAL(cx, idval);
     XPCCallContext ccx(JS_CALLER, cx, obj);
     XPCWrappedNative* wrapper = ccx.GetWrapper();
@@ -929,61 +929,61 @@ XPC_WN_MaybeResolvingPropertyStub(JSCont
 #define POST_HELPER_STUB                                                     \
     if(NS_FAILED(rv))                                                        \
         return Throw(rv, cx);                                                \
     return retval;
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_WN_Helper_AddProperty(JSContext *cx, JSObject *obj, jsval idval, jsval *vp)
 {
     PRE_HELPER_STUB
     AddProperty(wrapper, cx, obj, idval, vp, &retval);
     POST_HELPER_STUB
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_WN_Helper_DelProperty(JSContext *cx, JSObject *obj, jsval idval, jsval *vp)
 {
     PRE_HELPER_STUB
     DelProperty(wrapper, cx, obj, idval, vp, &retval);
     POST_HELPER_STUB
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_WN_Helper_GetProperty(JSContext *cx, JSObject *obj, jsval idval, jsval *vp)
 {
     PRE_HELPER_STUB
     GetProperty(wrapper, cx, obj, idval, vp, &retval);
     POST_HELPER_STUB
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_WN_Helper_SetProperty(JSContext *cx, JSObject *obj, jsval idval, jsval *vp)
 {
     PRE_HELPER_STUB
     SetProperty(wrapper, cx, obj, idval, vp, &retval);
     POST_HELPER_STUB
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_WN_Helper_Convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp)
 {
     PRE_HELPER_STUB
     Convert(wrapper, cx, obj, type, vp, &retval);
     POST_HELPER_STUB
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_WN_Helper_CheckAccess(JSContext *cx, JSObject *obj, jsval idval,
                           JSAccessMode mode, jsval *vp)
 {
     CHECK_IDVAL(cx, idval);
     PRE_HELPER_STUB
     CheckAccess(wrapper, cx, obj, idval, mode, vp, &retval);
     POST_HELPER_STUB
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_WN_Helper_Call(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                    jsval *rval)
 {
     // this is a hack to get the obj of the actual object not the object
     // that JS thinks is the 'this' (which it passes as 'obj').
@@ -993,11 +993,11 @@ XPC_WN_Helper_Call(JSContext *cx, JSObje
     PRE_HELPER_STUB
     Call(wrapper, cx, obj, argc, argv, rval, &retval);
     POST_HELPER_STUB
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_WN_Helper_Construct(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                         jsval *rval)
 {
     // this is a hack to get the obj of the actual object not the object
     // that JS thinks is the 'this' (which it passes as 'obj').
@@ -1007,29 +1007,29 @@ XPC_WN_Helper_Construct(JSContext *cx, J
     PRE_HELPER_STUB
     Construct(wrapper, cx, obj, argc, argv, rval, &retval);
     POST_HELPER_STUB
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_WN_Helper_HasInstance(JSContext *cx, JSObject *obj, jsval v, JSBool *bp)
 {
     PRE_HELPER_STUB
     HasInstance(wrapper, cx, obj, v, bp, &retval);
     POST_HELPER_STUB
 }
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 XPC_WN_Helper_Finalize(JSContext *cx, JSObject *obj)
 {
     XPCWrappedNative* wrapper = (XPCWrappedNative*) xpc_GetJSPrivate(obj);
     if(!wrapper)
         return;
     wrapper->GetScriptableCallback()->Finalize(wrapper, cx, obj);
     wrapper->FlatJSObjectFinalized(cx);
 }
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 XPC_WN_Helper_Trace(JSTracer *trc, JSObject *obj)
 {
     XPCWrappedNative* wrapper =
         XPCWrappedNative::GetWrappedNativeOfJSObject(trc->context, obj);
     if(wrapper && wrapper->IsValid())
@@ -1037,11 +1037,11 @@ XPC_WN_Helper_Trace(JSTracer *trc, JSObj
         wrapper->GetScriptableCallback()->Trace(wrapper, trc, obj);
         xpc_TraceForValidWrapper(trc, wrapper);
     }
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_WN_Helper_NewResolve(JSContext *cx, JSObject *obj, jsval idval, uintN flags,
                          JSObject **objp)
 {
     CHECK_IDVAL(cx, idval);
 
@@ -1168,11 +1168,11 @@ static JSObjectOps XPC_WN_NoCall_JSOps;
             use enumerate stub - don't use this JSOp thing at all
         else
             do shared enumerate - don't use this JSOp thing at all
 */
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_WN_JSOp_Enumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op,
                       jsval *statep, jsid *idp)
 {
     JSClass *clazz = STOBJ_GET_CLASS(obj);
     if(!IS_WRAPPER_CLASS(clazz) || clazz == &XPC_WN_NoHelper_JSClass.base)
@@ -1248,11 +1248,11 @@ XPC_WN_JSOp_Enumerate(JSContext *cx, JSO
     // else call js_ObjectOps.enumerate...
 
     return js_ObjectOps.enumerate(cx, obj, enum_op, statep, idp);
 }
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 XPC_WN_JSOp_Clear(JSContext *cx, JSObject *obj)
 {
     // We're likely to enter this JSOp with a wrapper prototype
     // object. In that case we won't find a wrapper, so we'll just
     // call into js_ObjectOps.clear(), which is exactly what we want.
@@ -1271,17 +1271,17 @@ XPC_WN_JSOp_Clear(JSContext *cx, JSObjec
     }
 
     js_ObjectOps.clear(cx, obj);
 }
 
-JSObjectOps * JS_DLL_CALLBACK
+JSObjectOps *
 XPC_WN_GetObjectOpsNoCall(JSContext *cx, JSClass *clazz)
 {
     return &XPC_WN_NoCall_JSOps;
 }
 
-JSObjectOps * JS_DLL_CALLBACK
+JSObjectOps *
 XPC_WN_GetObjectOpsWithCall(JSContext *cx, JSClass *clazz)
 {
     return &XPC_WN_WithCall_JSOps;
 }
 
@@ -1452,11 +1452,11 @@ XPCNativeScriptableShared::PopulateJSCla
 }
 
 /***************************************************************************/
 /***************************************************************************/
 
-JSBool JS_DLL_CALLBACK
+JSBool
 XPC_WN_CallMethod(JSContext *cx, JSObject *obj,
                   uintN argc, jsval *argv, jsval *vp)
 {
     NS_ASSERTION(JS_TypeOfValue(cx, argv[-2]) == JSTYPE_FUNCTION, "bad function");
     JSObject* funobj = JSVAL_TO_OBJECT(argv[-2]);
@@ -1471,11 +1471,11 @@ XPC_WN_CallMethod(JSContext *cx, JSObjec
         return Throw(NS_ERROR_XPC_CANT_GET_METHOD_INFO, cx);
     ccx.SetCallInfo(iface, member, JS_FALSE);
     return XPCWrappedNative::CallMethod(ccx);
 }
 
-JSBool JS_DLL_CALLBACK
+JSBool
 XPC_WN_GetterSetter(JSContext *cx, JSObject *obj,
                     uintN argc, jsval *argv, jsval *vp)
 {
     NS_ASSERTION(JS_TypeOfValue(cx, argv[-2]) == JSTYPE_FUNCTION, "bad function");
     JSObject* funobj = JSVAL_TO_OBJECT(argv[-2]);
@@ -1505,11 +1505,11 @@ XPC_WN_GetterSetter(JSContext *cx, JSObj
     return XPCWrappedNative::GetAttribute(ccx);
 }
 
 /***************************************************************************/
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_WN_Shared_Proto_Enumerate(JSContext *cx, JSObject *obj)
 {
     NS_ASSERTION(
         JS_InstanceOf(cx, obj, &XPC_WN_ModsAllowed_WithCall_Proto_JSClass,
                       nsnull) ||
@@ -1550,27 +1550,27 @@ XPC_WN_Shared_Proto_Enumerate(JSContext 
     }
 
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_WN_Shared_Proto_Convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp)
 {
     // XXX ?
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 XPC_WN_Shared_Proto_Finalize(JSContext *cx, JSObject *obj)
 {
     // This can be null if xpc shutdown has already happened
     XPCWrappedNativeProto* p = (XPCWrappedNativeProto*) xpc_GetJSPrivate(obj);
     if(p)
         p->JSProtoObjectFinalized(cx, obj);
 }
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 XPC_WN_Shared_Proto_Trace(JSTracer *trc, JSObject *obj)
 {
     // This can be null if xpc shutdown has already happened
     XPCWrappedNativeProto* p =
         (XPCWrappedNativeProto*) xpc_GetJSPrivate(obj);
@@ -1578,11 +1578,11 @@ XPC_WN_Shared_Proto_Trace(JSTracer *trc,
         TraceScopeJSObjects(trc, p->GetScope());
 }
 
 /*****************************************************/
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_WN_ModsAllowed_Proto_Resolve(JSContext *cx, JSObject *obj, jsval idval)
 {
     CHECK_IDVAL(cx, idval);
 
     NS_ASSERTION(
@@ -1615,11 +1615,11 @@ XPC_WN_ModsAllowed_Proto_Resolve(JSConte
 // Give our proto classes object ops that match the respective
 // wrappers so that the JS engine can share scope (maps) among
 // wrappers. This essentially duplicates the number of JSClasses we
 // use for prototype objects (from 2 to 4), but the scope sharing
 // benefit is well worth it.
-JSObjectOps * JS_DLL_CALLBACK
+JSObjectOps *
 XPC_WN_Proto_GetObjectOps(JSContext *cx, JSClass *clazz)
 {
     // Protos for wrappers that want calls to their call() hooks get
     // jsops with a call hook, others get jsops w/o a call hook.
 
@@ -1658,11 +1658,11 @@ JSClass XPC_WN_ModsAllowed_WithCall_Prot
     nsnull,                         // hasInstance;
     JS_CLASS_TRACE(XPC_WN_Shared_Proto_Trace), // mark/trace;
     nsnull                          // spare;
 };
 
-JSObjectOps * JS_DLL_CALLBACK
+JSObjectOps *
 XPC_WN_ModsAllowedProto_NoCall_GetObjectOps(JSContext *cx, JSClass *clazz)
 {
     return &XPC_WN_NoCall_JSOps;
 }
 
@@ -1691,11 +1691,11 @@ JSClass XPC_WN_ModsAllowed_NoCall_Proto_
     nsnull                          // spare;
 };
 
 /***************************************************************************/
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_WN_OnlyIWrite_Proto_PropertyStub(JSContext *cx, JSObject *obj, jsval idval, jsval *vp)
 {
     CHECK_IDVAL(cx, idval);
 
     NS_ASSERTION(
@@ -1717,11 +1717,11 @@ XPC_WN_OnlyIWrite_Proto_PropertyStub(JSC
         return JS_TRUE;
 
     return Throw(NS_ERROR_XPC_BAD_OP_ON_WN_PROTO, cx);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_WN_NoMods_Proto_Resolve(JSContext *cx, JSObject *obj, jsval idval)
 {
     CHECK_IDVAL(cx, idval);
 
     NS_ASSERTION(
@@ -1801,11 +1801,11 @@ JSClass XPC_WN_NoMods_NoCall_Proto_JSCla
     nsnull                          // spare;
 };
 
 /***************************************************************************/
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_WN_TearOff_Enumerate(JSContext *cx, JSObject *obj)
 {
     XPCCallContext ccx(JS_CALLER, cx, obj);
     XPCWrappedNative* wrapper = ccx.GetWrapper();
     THROW_AND_RETURN_IF_BAD_WRAPPER(cx, wrapper);
@@ -1824,11 +1824,11 @@ XPC_WN_TearOff_Enumerate(JSContext *cx, 
     }
 
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 XPC_WN_TearOff_Resolve(JSContext *cx, JSObject *obj, jsval idval)
 {
     CHECK_IDVAL(cx, idval);
 
     XPCCallContext ccx(JS_CALLER, cx, obj);
@@ -1847,11 +1847,11 @@ XPC_WN_TearOff_Resolve(JSContext *cx, JS
                                  JSPROP_READONLY |
                                  JSPROP_PERMANENT |
                                  JSPROP_ENUMERATE, nsnull);
 }
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 XPC_WN_TearOff_Finalize(JSContext *cx, JSObject *obj)
 {
     XPCWrappedNativeTearOff* p = (XPCWrappedNativeTearOff*)
         xpc_GetJSPrivate(obj);
     if(!p)
diff -r 14ce7619e9c1 js/src/xpconnect/src/xpcwrappednativescope.cpp
--- a/js/src/xpconnect/src/xpcwrappednativescope.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/xpconnect/src/xpcwrappednativescope.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -348,11 +348,11 @@ XPCWrappedNativeScope::GetPrototypeNoHel
     }
 
     return mPrototypeNoHelper;
 }
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 WrappedNativeJSGCThingTracer(JSDHashTable *table, JSDHashEntryHdr *hdr,
                              uint32 number, void *arg)
 {
     XPCWrappedNative* wrapper = ((Native2WrappedNativeMap::Entry*)hdr)->value;
     if(wrapper->HasExternalReference() && !wrapper->IsWrapperExpired())
@@ -389,11 +389,11 @@ struct SuspectClosure
 
     JSContext* cx;
     nsCycleCollectionTraversalCallback& cb;
 };
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 WrappedNativeSuspecter(JSDHashTable *table, JSDHashEntryHdr *hdr,
                        uint32 number, void *arg)
 {
     SuspectClosure* closure = static_cast<SuspectClosure*>(arg);
     XPCWrappedNative* wrapper = ((Native2WrappedNativeMap::Entry*)hdr)->value;
@@ -502,21 +502,21 @@ XPCWrappedNativeScope::FinishedFinalizat
     // to JS runtime. See bug 380139.
     XPCAutoLock lock(rt->GetMapLock());
     KillDyingScopes();
 }
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 WrappedNativeMarker(JSDHashTable *table, JSDHashEntryHdr *hdr,
                     uint32 number, void *arg)
 {
     ((Native2WrappedNativeMap::Entry*)hdr)->value->Mark();
     return JS_DHASH_NEXT;
 }
 
 // We need to explicitly mark all the protos too because some protos may be
 // alive in the hashtable but not currently in use by any wrapper
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 WrappedNativeProtoMarker(JSDHashTable *table, JSDHashEntryHdr *hdr,
                          uint32 number, void *arg)
 {
     ((ClassInfo2WrappedNativeProtoMap::Entry*)hdr)->value->Mark();
     return JS_DHASH_NEXT;
@@ -534,19 +534,19 @@ XPCWrappedNativeScope::MarkAllWrappedNat
 
     DEBUG_TrackScopeTraversal();
 }
 
 #ifdef DEBUG
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 ASSERT_WrappedNativeSetNotMarked(JSDHashTable *table, JSDHashEntryHdr *hdr,
                                  uint32 number, void *arg)
 {
     ((Native2WrappedNativeMap::Entry*)hdr)->value->ASSERT_SetsNotMarked();
     return JS_DHASH_NEXT;
 }
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 ASSERT_WrappedNativeProtoSetNotMarked(JSDHashTable *table, JSDHashEntryHdr *hdr,
                                       uint32 number, void *arg)
 {
     ((ClassInfo2WrappedNativeProtoMap::Entry*)hdr)->value->ASSERT_SetNotMarked();
     return JS_DHASH_NEXT;
@@ -564,11 +564,11 @@ XPCWrappedNativeScope::ASSERT_NoInterfac
             ASSERT_WrappedNativeProtoSetNotMarked, nsnull);
     }
 }
 #endif
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 WrappedNativeTearoffSweeper(JSDHashTable *table, JSDHashEntryHdr *hdr,
                             uint32 number, void *arg)
 {
     ((Native2WrappedNativeMap::Entry*)hdr)->value->SweepTearOffs();
     return JS_DHASH_NEXT;
@@ -608,11 +608,11 @@ struct ShutdownData
     int wrapperCount;
     int sharedProtoCount;
     int nonSharedProtoCount;
 };
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 WrappedNativeShutdownEnumerator(JSDHashTable *table, JSDHashEntryHdr *hdr,
                                 uint32 number, void *arg)
 {
     ShutdownData* data = (ShutdownData*) arg;
     XPCWrappedNative* wrapper = ((Native2WrappedNativeMap::Entry*)hdr)->value;
@@ -625,11 +625,11 @@ WrappedNativeShutdownEnumerator(JSDHashT
         data->wrapperCount++;
     }
     return JS_DHASH_REMOVE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 WrappedNativeProtoShutdownEnumerator(JSDHashTable *table, JSDHashEntryHdr *hdr,
                                      uint32 number, void *arg)
 {
     ShutdownData* data = (ShutdownData*) arg;
     ((ClassInfo2WrappedNativeProtoMap::Entry*)hdr)->value->
@@ -822,21 +822,21 @@ XPCWrappedNativeScope::FindInJSObjectSco
 }
 
 
 /***************************************************************************/
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 WNProtoSecPolicyClearer(JSDHashTable *table, JSDHashEntryHdr *hdr,
                         uint32 number, void *arg)
 {
     XPCWrappedNativeProto* proto =
         ((ClassInfo2WrappedNativeProtoMap::Entry*)hdr)->value;
     *(proto->GetSecurityInfoAddr()) = nsnull;
     return JS_DHASH_NEXT;
 }
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 WNSecPolicyClearer(JSDHashTable *table, JSDHashEntryHdr *hdr,
                     uint32 number, void *arg)
 {
     XPCWrappedNative* wrapper = ((Native2WrappedNativeMap::Entry*)hdr)->value;
     if(wrapper->HasProto() && !wrapper->HasSharedProto())
@@ -860,11 +860,11 @@ XPCWrappedNativeScope::ClearAllWrappedNa
     DEBUG_TrackScopeTraversal();
 
     return NS_OK;
 }
 
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 WNProtoRemover(JSDHashTable *table, JSDHashEntryHdr *hdr,
                uint32 number, void *arg)
 {
     XPCWrappedNativeProtoMap* detachedMap = (XPCWrappedNativeProtoMap*)arg;
     
@@ -909,18 +909,18 @@ XPCWrappedNativeScope::DebugDumpAllScope
     XPC_LOG_OUTDENT();
 #endif
 }
 
 #ifdef DEBUG
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 WrappedNativeMapDumpEnumerator(JSDHashTable *table, JSDHashEntryHdr *hdr,
                                uint32 number, void *arg)
 {
     ((Native2WrappedNativeMap::Entry*)hdr)->value->DebugDump(*(PRInt16*)arg);
     return JS_DHASH_NEXT;
 }
-JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+static JSDHashOperator
 WrappedNativeProtoMapDumpEnumerator(JSDHashTable *table, JSDHashEntryHdr *hdr,
                                     uint32 number, void *arg)
 {
     ((ClassInfo2WrappedNativeProtoMap::Entry*)hdr)->value->DebugDump(*(PRInt16*)arg);
     return JS_DHASH_NEXT;
diff -r 14ce7619e9c1 js/src/xpconnect/tests/TestXPC.cpp
--- a/js/src/xpconnect/tests/TestXPC.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/xpconnect/tests/TestXPC.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -66,11 +66,11 @@
 // host support for jsengine
 
 FILE *gOutFile = NULL;
 FILE *gErrFile = NULL;
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 Print(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
     uintN i, n;
     JSString *str;
 
@@ -84,11 +84,11 @@ Print(JSContext *cx, JSObject *obj, uint
     if (n)
         fputc('\n', gOutFile);
     return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 Load(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
     uintN i;
     JSString *str;
     const char *filename;
@@ -125,11 +125,11 @@ static JSClass global_class = {
     "global", 0,
     JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,
     JS_EnumerateStub, JS_ResolveStub,   JS_ConvertStub,   JS_FinalizeStub
 };
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 my_ErrorReporter(JSContext *cx, const char *message, JSErrorReport *report)
 {
     printf(message);
 }
 
diff -r 14ce7619e9c1 js/src/xpconnect/tools/src/nsXPCToolsCompiler.cpp
--- a/js/src/xpconnect/tools/src/nsXPCToolsCompiler.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/xpconnect/tools/src/nsXPCToolsCompiler.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -67,11 +67,11 @@ NS_IMETHODIMP nsXPCToolsCompiler::GetBin
     nsCOMPtr<nsILocalFile> lfile = do_QueryInterface(file);
     NS_ADDREF(*aBinDir = lfile);
     return NS_OK;
 }
 
-JS_STATIC_DLL_CALLBACK(void) ErrorReporter(JSContext *cx, const char *message,
+static void ErrorReporter(JSContext *cx, const char *message,
                           JSErrorReport *report)
 {
     printf("compile error!\n");
 }
 
diff -r 14ce7619e9c1 js/src/xpconnect/tools/src/nsXPCToolsProfiler.cpp
--- a/js/src/xpconnect/tools/src/nsXPCToolsProfiler.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/js/src/xpconnect/tools/src/nsXPCToolsProfiler.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -128,11 +128,11 @@ nsXPCToolsProfiler::~nsXPCToolsProfiler(
 
 /***************************************************************************/
 // the hooks...
 
 /* called just after script creation */
-JS_STATIC_DLL_CALLBACK(void)
+static void
 xpctools_JSNewScriptHook(JSContext  *cx,
                          const char *filename,  /* URL of script */
                          uintN      lineno,     /* line script starts */
                          JSScript   *script,
                          JSFunction *fun,
@@ -170,11 +170,11 @@ xpctools_JSNewScriptHook(JSContext  *cx,
     }
     PR_Unlock(self->mLock);
 }
 
 /* called just before script destruction */
-JS_STATIC_DLL_CALLBACK(void)
+static void
 xpctools_JSDestroyScriptHook(JSContext  *cx,
                              JSScript   *script,
                              void       *callerdata)
 {
     if(!script)
@@ -186,11 +186,11 @@ xpctools_JSDestroyScriptHook(JSContext  
     PR_Unlock(self->mLock);
 }
 
 
 /* called on entry and return of functions and top level scripts */
-JS_STATIC_DLL_CALLBACK(void*)
+static void*
 xpctools_InterpreterHook(JSContext *cx, JSStackFrame *fp, JSBool before,
                          JSBool *ok, void *closure)
 {
     // ignore returns
     NS_ASSERTION(fp, "bad frame pointer!");
diff -r 14ce7619e9c1 layout/base/crashtests/428448-1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/base/crashtests/428448-1.html	Mon Sep 08 10:35:46 2008 +0300
@@ -0,0 +1,9 @@
+<!DOCTYPE html>
+<html>
+<head></head>
+
+<body style="-moz-column-width: 1px"><span>!</span>
+<span style="float: left"></span>
+x</body>
+
+</html>
diff -r 14ce7619e9c1 layout/base/crashtests/crashtests.list
--- a/layout/base/crashtests/crashtests.list	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/base/crashtests/crashtests.list	Mon Sep 08 10:35:46 2008 +0300
@@ -1,11 +1,10 @@ load 56746-1.html
 load 56746-1.html
 load 143862-1.html
 load 143862-2.html
 load 243159-1.html
 load 243159-2.xhtml
-load 243519-1.html
 load 306940-1.html
 load 310267-1.xml
 load 310638-1.svg
 load 310638-2.html
 load 313086-1.xml
@@ -114,8 +113,9 @@ load 411870-1.html
 load 411870-1.html
 load 412651-1.html
 load 420031-1.html
 load 420213-1.html
 load 423107-1.xhtml
+load 428448-1.html
 load 432752-1.svg
 load 433450-1.html
 load 444925-1.xul
diff -r 14ce7619e9c1 layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/base/nsCSSFrameConstructor.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -1804,13 +1804,13 @@ nsCSSFrameConstructor::nsCSSFrameConstru
   , mGfxScrollFrame(nsnull)
   , mPageSequenceFrame(nsnull)
   , mUpdateCount(0)
   , mQuotesDirty(PR_FALSE)
   , mCountersDirty(PR_FALSE)
+  , mInitialContainingBlockIsAbsPosContainer(PR_FALSE)
   , mIsDestroyingFrameTree(PR_FALSE)
   , mRebuildAllStyleData(PR_FALSE)
-  , mHasRootAbsPosContainingBlock(PR_FALSE)
 {
   if (!gGotXBLFormPrefs) {
     gGotXBLFormPrefs = PR_TRUE;
 
     gUseXBLForms =
@@ -3970,10 +3970,36 @@ nsCSSFrameConstructor::GetDisplay(nsIFra
 
 /***********************************************
  * END TABLE SECTION
  ***********************************************/
 
+nsresult
+nsCSSFrameConstructor::ConstructDocElementTableFrame(nsIContent*     aDocElement,
+                                                     nsIFrame*       aParentFrame,
+                                                     nsIFrame**      aNewTableFrame,
+                                                     nsFrameConstructorState& aState)
+{
+  nsFrameItems    frameItems;
+
+  // XXXbz this is wrong.  We should at least be setting the fixed container in
+  // the framestate here.  Better yet, we should pass through aState
+  // unmodified.  Can't do that, though, because then a fixed or absolute
+  // positioned root table with auto offsets would look for a block to compute
+  // its hypothetical box and crash.  So we just disable fixed positioning
+  // altogether in documents where the root is a table.  Oh, well.
+  nsFrameConstructorState state(mPresShell, nsnull, nsnull, nsnull,
+                                aState.mFrameState);
+  ConstructFrame(state, aDocElement, aParentFrame, frameItems);
+  *aNewTableFrame = frameItems.childList;
+  if (!*aNewTableFrame) {
+    NS_WARNING("cannot get table contentFrame");
+    // XXXbz maybe better to return the error from ConstructFrame?
+    return NS_ERROR_FAILURE;
+  }
+  return NS_OK;
+}
+
 static PRBool CheckOverflow(nsPresContext* aPresContext,
                             const nsStyleDisplay* aDisplay)
 {
   if (aDisplay->mOverflowX == NS_STYLE_OVERFLOW_VISIBLE)
     return PR_FALSE;
@@ -4065,10 +4091,33 @@ nsCSSFrameConstructor::ConstructDocEleme
 nsCSSFrameConstructor::ConstructDocElementFrame(nsFrameConstructorState& aState,
                                                 nsIContent*              aDocElement,
                                                 nsIFrame*                aParentFrame,
                                                 nsIFrame**               aNewFrame)
 {
+    // how the root frame hierarchy should look
+
+    /*
+
+---------------No Scrollbars------
+
+
+     AreaFrame or BoxFrame (InitialContainingBlock)
+  
+
+
+---------------Gfx Scrollbars ------
+
+
+     ScrollFrame
+
+         ^
+         |
+         |
+     AreaFrame or BoxFrame (InitialContainingBlock)
+          
+*/    
+
   *aNewFrame = nsnull;
 
   if (!mTempFrameTreeState)
     aState.mPresShell->CaptureHistoryState(getter_AddRefs(mTempFrameTreeState));
 
@@ -4138,17 +4187,12 @@ nsCSSFrameConstructor::ConstructDocEleme
                aState.mPresContext->IsPaginated() ||
                propagatedScrollToViewport,
                "Scrollbars should have been propagated to the viewport");
 #endif
 
-  nsFrameConstructorSaveState absoluteSaveState;
-  if (mHasRootAbsPosContainingBlock) {
-    // Push the absolute containing block now so we can absolutely position
-    // the root element
-    aState.PushAbsoluteContainingBlock(mDocElementContainingBlock, absoluteSaveState);
-  }
-
+  nsIFrame* contentFrame = nsnull;
+  PRBool isBlockFrame = PR_FALSE;
   nsresult rv;
 
   // The rules from CSS 2.1, section 9.2.4, have already been applied
   // by the style system, so we can assume that display->mDisplay is
   // either NONE, BLOCK, or TABLE.
@@ -4156,99 +4200,56 @@ nsCSSFrameConstructor::ConstructDocEleme
   PRBool docElemIsTable = (display->mDisplay == NS_STYLE_DISPLAY_TABLE) &&
                           !IsSpecialContent(aDocElement, aDocElement->Tag(),
                                             aDocElement->GetNameSpaceID(),
                                             styleContext);
 
-  // contentFrame is the primary frame for the root element. *aNewFrame
-  // is the frame that will be the child of the initial containing block.
-  // These are usually the same frame but they can be different, in
-  // particular if the root frame is positioned, in which case
-  // contentFrame is the out-of-flow frame and *aNewFrame is the
-  // placeholder.
-  nsIFrame* contentFrame;
-  PRBool processChildren = PR_FALSE;
   if (docElemIsTable) {
-    nsIFrame* innerTableFrame;
-    nsFrameItems frameItems;
     // if the document is a table then just populate it.
-    rv = ConstructTableFrame(aState, aDocElement,
-                             aParentFrame, styleContext,
-                             kNameSpaceID_None, PR_FALSE, frameItems, contentFrame,
-                             innerTableFrame);
-    if (NS_FAILED(rv))
-      return rv;
-    if (!contentFrame || !frameItems.childList)
-      return NS_ERROR_FAILURE;
-    *aNewFrame = frameItems.childList;
-    NS_ASSERTION(!frameItems.childList->GetNextSibling(),
-                 "multiple root element frames");
+    rv = ConstructDocElementTableFrame(aDocElement, aParentFrame, &contentFrame,
+                                       aState);
+    if (NS_FAILED(rv)) {
+      return rv;
+    }
+    styleContext = contentFrame->GetStyleContext();
   } else {
     // otherwise build a box or a block
 #ifdef MOZ_XUL
     if (aDocElement->IsNodeOfType(nsINode::eXUL)) {
       contentFrame = NS_NewDocElementBoxFrame(mPresShell, styleContext);
-      if (NS_UNLIKELY(!contentFrame)) {
-        return NS_ERROR_OUT_OF_MEMORY;
-      }
-      InitAndRestoreFrame(aState, aDocElement, aParentFrame, nsnull, contentFrame);
-      *aNewFrame = contentFrame;
-      processChildren = PR_TRUE;
     }
     else
 #endif 
 #ifdef MOZ_SVG
     if (aDocElement->GetNameSpaceID() == kNameSpaceID_SVG) {
       if (aDocElement->Tag() == nsGkAtoms::svg && NS_SVGEnabled()) {
         contentFrame = NS_NewSVGOuterSVGFrame(mPresShell, aDocElement, styleContext);
-        if (NS_UNLIKELY(!contentFrame)) {
-          return NS_ERROR_OUT_OF_MEMORY;
-        }
-        InitAndRestoreFrame(aState, aDocElement,
-                            aState.GetGeometricParent(display, aParentFrame),
-                            nsnull, contentFrame);
-
-        // AddChild takes care of transforming the frame tree for fixed-pos
-        // or abs-pos situations
-        nsFrameItems frameItems;
-        rv = aState.AddChild(contentFrame, frameItems, aDocElement,
-                             styleContext, aParentFrame);
-        if (NS_FAILED(rv) || !frameItems.childList) {
-          return rv;
-        }
-        *aNewFrame = frameItems.childList;
-        processChildren = PR_TRUE;
-
-        // See if we need to create a view, e.g. the frame is absolutely positioned
-        nsHTMLContainerFrame::CreateViewForFrame(contentFrame, aParentFrame, PR_FALSE);
       } else {
         return NS_ERROR_FAILURE;
       }
     }
     else 
 #endif
     {
-      contentFrame = NS_NewBlockFrame(mPresShell, styleContext,
-        NS_BLOCK_SPACE_MGR|NS_BLOCK_MARGIN_ROOT);
-      if (!contentFrame)
-        return NS_ERROR_OUT_OF_MEMORY;
-      nsFrameItems frameItems;
-      rv = ConstructBlock(aState, display, aDocElement,
-                          aState.GetGeometricParent(display, aParentFrame),
-                          aParentFrame, styleContext, &contentFrame,
-                          frameItems, display->IsPositioned());
-      if (NS_FAILED(rv) || !frameItems.childList)
-        return rv;
-      *aNewFrame = frameItems.childList;
-      NS_ASSERTION(!frameItems.childList->GetNextSibling(),
-                   "multiple root element frames");
-    }
+      contentFrame = NS_NewDocumentElementFrame(mPresShell, styleContext);
+      isBlockFrame = PR_TRUE;
+    }
+    
+    if (NS_UNLIKELY(!contentFrame)) {
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+
+    // initialize the child
+    InitAndRestoreFrame(aState, aDocElement, aParentFrame, nsnull, contentFrame);
   }
 
   // set the primary frame
   aState.mFrameManager->SetPrimaryFrameFor(aDocElement, contentFrame);
 
+  *aNewFrame = contentFrame;
+
   mInitialContainingBlock = contentFrame;
+  mInitialContainingBlockIsAbsPosContainer = PR_FALSE;
 
   // Figure out which frame has the main style for the document element,
   // assigning it to mRootElementStyleFrame.
   // Backgrounds should be propagated from that frame to the viewport.
   PRBool isChild;
@@ -4256,23 +4257,35 @@ nsCSSFrameConstructor::ConstructDocEleme
           &mRootElementStyleFrame, &isChild);
   if (!isChild) {
     mRootElementStyleFrame = mInitialContainingBlock;
   }
 
-  if (processChildren) {
-    // Still need to process the child content
-    nsFrameItems childItems;
+  // if it was a table then we don't need to process our children.
+  if (!docElemIsTable) {
+    // Process the child content
+    nsFrameConstructorSaveState absoluteSaveState;
+    nsFrameConstructorSaveState floatSaveState;
+    nsFrameItems                childItems;
+
+    if (isBlockFrame) {
+      PRBool haveFirstLetterStyle, haveFirstLineStyle;
+      ShouldHaveSpecialBlockStyle(aDocElement, styleContext,
+                                  &haveFirstLetterStyle, &haveFirstLineStyle);
+      mInitialContainingBlockIsAbsPosContainer = PR_TRUE;
+      aState.PushAbsoluteContainingBlock(contentFrame, absoluteSaveState);
+      aState.PushFloatContainingBlock(contentFrame, floatSaveState,
+                                      haveFirstLetterStyle,
+                                      haveFirstLineStyle);
+    }
 
     // Create any anonymous frames the doc element frame requires
     // This must happen before ProcessChildren to ensure that popups are
     // never constructed before the popupset.
     CreateAnonymousFrames(nsnull, aState, aDocElement, contentFrame,
                           PR_FALSE, childItems, PR_TRUE);
-    NS_ASSERTION(!nsLayoutUtils::GetAsBlock(contentFrame),
-                 "Only XUL and SVG frames should reach here");
     ProcessChildren(aState, aDocElement, contentFrame, PR_TRUE, childItems,
-                    PR_FALSE);
+                    isBlockFrame);
 
     // Set the initial child lists
     contentFrame->SetInitialChildList(nsnull, childItems.childList);
   }
 
@@ -4285,66 +4298,40 @@ nsCSSFrameConstructor::ConstructRootFram
                                           nsIFrame**      aNewFrame)
 {
   AUTO_LAYOUT_PHASE_ENTRY_POINT(mPresShell->GetPresContext(), FrameC);
   NS_PRECONDITION(aNewFrame, "null out param");
   
+  // how the root frame hierarchy should look
+
     /*
-       how the root frame hierarchy should look
-
-  Galley presentation, non-XUL, with scrolling (i.e. not a frameset):
-  
-      ViewportFrame [fixed-cb]
-        nsHTMLScrollFrame
-          CanvasFrame [abs-cb]
-            root element frame (nsBlockFrame, nsSVGOuterSVGFrame,
-                                nsTableOuterFrame, nsPlaceholderFrame)
-
-  Galley presentation, non-XUL, without scrolling (i.e. a frameset):
-  
-      ViewportFrame [fixed-cb]
-        CanvasFrame [abs-cb]
-          root element frame (nsBlockFrame)
-
-  Galley presentation, XUL
-  
-      ViewportFrame [fixed-cb]
-        nsRootBoxFrame
-          root element frame (nsDocElementBoxFrame)
-
-  Print presentation, non-XUL
-
-      ViewportFrame
-        nsSimplePageSequenceFrame
-          nsPageFrame [fixed-cb]
-            nsPageContentFrame
-              CanvasFrame [abs-cb]
-                root element frame (nsBlockFrame, nsSVGOuterSVGFrame,
-                                    nsTableOuterFrame, nsPlaceholderFrame)
-
-  Print-preview presentation, non-XUL
-
-      ViewportFrame
-        nsHTMLScrollFrame
-          nsSimplePageSequenceFrame
-            nsPageFrame [fixed-cb]
-              nsPageContentFrame
-                CanvasFrame [abs-cb]
-                  root element frame (nsBlockFrame, nsSVGOuterSVGFrame,
-                                      nsTableOuterFrame, nsPlaceholderFrame)
-
-  Print/print preview of XUL is not supported.
-  [fixed-cb]: the default containing block for fixed-pos content
-  [abs-cb]: the default containing block for abs-pos content
- 
-  Meaning of nsCSSFrameConstructor fields:
-    mInitialContainingBlock is "root element frame".
-    mDocElementContainingBlock is the parent of mInitialContainingBlock
-      (i.e. CanvasFrame or nsRootBoxFrame)
-    mFixedContainingBlock is the [fixed-cb]
-    mGfxScrollFrame is the nsHTMLScrollFrame mentioned above, or null if there isn't one
-    mPageSequenceFrame is the nsSimplePageSequenceFrame, or null if there isn't one
-*/
+
+---------------No Scrollbars------
+
+
+
+     ViewPortFrame (FixedContainingBlock) <---- RootView
+
+         ^
+         |
+     RootFrame(DocElementContainingBlock)
+  
+
+
+---------------Gfx Scrollbars ------
+
+
+     ViewPortFrame (FixedContainingBlock) <---- RootView
+
+         ^
+         |
+     ScrollFrame
+
+         ^
+         |
+     RootFrame(DocElementContainingBlock)
+          
+*/    
 
   // Set up our style rule observer.
   {
     mPresShell->StyleSet()->SetBindingManager(mDocument->BindingManager());
   }
@@ -4405,11 +4392,10 @@ nsCSSFrameConstructor::ConstructRootFram
     } else
 #endif
     {
       // pass a temporary stylecontext, the correct one will be set later
       rootFrame = NS_NewCanvasFrame(mPresShell, viewportPseudoStyle);
-      mHasRootAbsPosContainingBlock = PR_TRUE;
     }
 
     rootPseudo = nsCSSAnonBoxes::canvas;
     mDocElementContainingBlock = rootFrame;
   } else {
@@ -4534,35 +4520,34 @@ nsCSSFrameConstructor::ConstructRootFram
   }
   
   if (isPaginated) { // paginated
     // Create the first page
     // Set the initial child lists
-    nsIFrame *pageFrame, *canvasFrame;
+    nsIFrame *pageFrame, *pageContentFrame;
     ConstructPageFrame(mPresShell, presContext, rootFrame, nsnull,
-                       pageFrame, canvasFrame);
+                       pageFrame, pageContentFrame);
     rootFrame->SetInitialChildList(nsnull, pageFrame);
 
     // The eventual parent of the document element frame.
     // XXX should this be set for every new page (in ConstructPageFrame)?
-    mDocElementContainingBlock = canvasFrame;
-    mHasRootAbsPosContainingBlock = PR_TRUE;
+    mDocElementContainingBlock = pageContentFrame;
   }
 
   viewportFrame->SetInitialChildList(nsnull, newFrame);
   
   *aNewFrame = viewportFrame;
 
   return NS_OK;
 }
 
 nsresult
-nsCSSFrameConstructor::ConstructPageFrame(nsIPresShell*  aPresShell,
+nsCSSFrameConstructor::ConstructPageFrame(nsIPresShell*   aPresShell,
                                           nsPresContext* aPresContext,
-                                          nsIFrame*      aParentFrame,
-                                          nsIFrame*      aPrevPageFrame,
-                                          nsIFrame*&     aPageFrame,
-                                          nsIFrame*&     aCanvasFrame)
+                                          nsIFrame*       aParentFrame,
+                                          nsIFrame*       aPrevPageFrame,
+                                          nsIFrame*&      aPageFrame,
+                                          nsIFrame*&      aPageContentFrame)
 {
   nsStyleContext* parentStyleContext = aParentFrame->GetStyleContext();
   nsStyleSet *styleSet = aPresShell->StyleSet();
 
   nsRefPtr<nsStyleContext> pagePseudoStyle;
@@ -4581,41 +4566,25 @@ nsCSSFrameConstructor::ConstructPageFram
   nsRefPtr<nsStyleContext> pageContentPseudoStyle;
   pageContentPseudoStyle = styleSet->ResolvePseudoStyleFor(nsnull,
                                                            nsCSSAnonBoxes::pageContent,
                                                            pagePseudoStyle);
 
-  nsIFrame* pageContentFrame = NS_NewPageContentFrame(aPresShell, pageContentPseudoStyle);
-  if (NS_UNLIKELY(!pageContentFrame))
+  aPageContentFrame = NS_NewPageContentFrame(aPresShell, pageContentPseudoStyle);
+  if (NS_UNLIKELY(!aPageContentFrame))
     return NS_ERROR_OUT_OF_MEMORY;
 
   // Initialize the page content frame and force it to have a view. Also make it the
   // containing block for fixed elements which are repeated on every page.
   nsIFrame* prevPageContentFrame = nsnull;
   if (aPrevPageFrame) {
     prevPageContentFrame = aPrevPageFrame->GetFirstChild(nsnull);
     NS_ASSERTION(prevPageContentFrame, "missing page content frame");
   }
-  pageContentFrame->Init(nsnull, aPageFrame, prevPageContentFrame);
-  aPageFrame->SetInitialChildList(nsnull, pageContentFrame);
-  mFixedContainingBlock = pageContentFrame;
-
-  nsRefPtr<nsStyleContext> canvasPseudoStyle;
-  canvasPseudoStyle = styleSet->ResolvePseudoStyleFor(nsnull,
-                                                      nsCSSAnonBoxes::canvas,
-                                                      pageContentPseudoStyle);
-
-  aCanvasFrame = NS_NewCanvasFrame(aPresShell, canvasPseudoStyle);
-  if (NS_UNLIKELY(!aCanvasFrame))
-    return NS_ERROR_OUT_OF_MEMORY;
-
-  nsIFrame* prevCanvasFrame = nsnull;
-  if (prevPageContentFrame) {
-    prevCanvasFrame = prevPageContentFrame->GetFirstChild(nsnull);
-    NS_ASSERTION(prevCanvasFrame, "missing canvas frame");
-  }
-  aCanvasFrame->Init(nsnull, pageContentFrame, prevCanvasFrame);
-  pageContentFrame->SetInitialChildList(nsnull, aCanvasFrame);
+  aPageContentFrame->Init(nsnull, aPageFrame, prevPageContentFrame);
+  mFixedContainingBlock = aPageContentFrame;
+
+  aPageFrame->SetInitialChildList(nsnull, aPageContentFrame);
 
   return NS_OK;
 }
 
 /* static */
@@ -6710,28 +6679,21 @@ nsCSSFrameConstructor::InitAndRestoreFra
 
 already_AddRefed<nsStyleContext>
 nsCSSFrameConstructor::ResolveStyleContext(nsIFrame*         aParentFrame,
                                            nsIContent*       aContent)
 {
-  nsStyleContext* parentStyleContext = nsnull;
+  nsStyleContext* parentStyleContext;
   if (aContent->GetParent()) {
     aParentFrame = nsFrame::CorrectStyleParentFrame(aParentFrame, nsnull);
   
-    if (aParentFrame) {
-      // Resolve the style context based on the content object and the parent
-      // style context
-      parentStyleContext = aParentFrame->GetStyleContext();
-    } else {
-      // Perhaps aParentFrame is a canvasFrame and we're replicating
-      // fixed-pos frames.
-      // XXX should we create a way to tell ConstructFrame which style
-      // context to use, and pass it the style context for the
-      // previous page's fixed-pos frame?
-    }
+    // Resolve the style context based on the content object and the parent
+    // style context
+    parentStyleContext = aParentFrame->GetStyleContext();
   } else {
     // This has got to be a call from ConstructDocElementTableFrame.
-    // Not sure how best to assert that here.
+    // Not sure how best to asserrt that here.
+    parentStyleContext = nsnull;
   }
 
   nsStyleSet *styleSet = mPresShell->StyleSet();
 
   if (aContent->IsNodeOfType(nsINode::eELEMENT)) {
@@ -7436,16 +7398,19 @@ nsCSSFrameConstructor::ConstructFrameInt
       ) {
     return NS_OK;
   }
 #endif
 
-  // Style resolution can normally happen lazily.  However, getting the
-  // Visibility struct can cause |SetBidiEnabled| to be called on the
-  // pres context, and this needs to happen before we start reflow, so
-  // do it now, when constructing frames.  See bug 115921.
+  // If the page contains markup that overrides text direction, and
+  // does not contain any characters that would activate the Unicode
+  // bidi algorithm, we need to call |SetBidiEnabled| on the pres
+  // context before reflow starts.  This requires us to resolve some
+  // style information now.  See bug 115921.
   {
-    styleContext->GetStyleVisibility();
+    if (styleContext->GetStyleVisibility()->mDirection ==
+        NS_STYLE_DIRECTION_RTL)
+      aState.mPresContext->SetBidiEnabled();
   }
   // Start background loads during frame construction. This is just
   // a hint; the paint code will do the right thing in any case.
   {
     styleContext->GetStyleBackground();
@@ -7540,70 +7505,49 @@ nsCSSFrameConstructor::ReconstructDocEle
   // XXXbz is that null-check needed?  Why?
   if (mDocument && mPresShell) {
     nsIContent *rootContent = mDocument->GetRootContent();
     
     if (rootContent) {
+      // Before removing the frames associated with the content object, ask them to save their
+      // state onto a temporary state object.
+      CaptureStateForFramesOf(rootContent, mTempFrameTreeState);
+
       nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
                                     nsnull, nsnull, mTempFrameTreeState);
-
-      // Before removing the frames associated with the content object, ask them to save their
-      // state onto a temporary state object.
-      CaptureStateFor(state.mFrameManager->GetRootFrame(), mTempFrameTreeState);
 
       // Get the frame that corresponds to the document element
       nsIFrame* docElementFrame =
         state.mFrameManager->GetPrimaryFrameFor(rootContent, -1);
-
-      if (docElementFrame) {
-        // Destroy out-of-flow frames that might not be in the frame subtree
-        // rooted at docElementFrame
-        ::DeletingFrameSubtree(state.mFrameManager, docElementFrame);
-      }
-
+        
       // Remove any existing fixed items: they are always on the
       // FixedContainingBlock.  Note that this has to be done before we call
       // ClearPlaceholderFrameMap(), since RemoveFixedItems uses the
       // placeholder frame map.
-      rv = RemoveFixedItems(state, docElementFrame);
-
+      rv = RemoveFixedItems(state);
       if (NS_SUCCEEDED(rv)) {
-        nsPlaceholderFrame* placeholderFrame = nsnull;
-        if (docElementFrame &&
-            (docElementFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW)) {
-          // Get the placeholder frame now, before we tear down the
-          // placeholder frame map
-          placeholderFrame =
-            state.mFrameManager->GetPlaceholderFrameFor(docElementFrame);
-          NS_ASSERTION(placeholderFrame, "No placeholder for out-of-flow?");
-        }
-
         // Clear the hash tables that map from content to frame and out-of-flow
         // frame to placeholder frame
         state.mFrameManager->ClearPrimaryFrameMap();
         state.mFrameManager->ClearPlaceholderFrameMap();
         state.mFrameManager->ClearUndisplayedContentMap();
 
         if (docElementFrame) {
           // Take the docElementFrame, and remove it from its parent.
+        
           // XXXbz So why can't we reuse ContentRemoved?
+
+          NS_ASSERTION(docElementFrame->GetParent() == mDocElementContainingBlock,
+                       "Unexpected doc element parent frame");
 
           // Notify self that we will destroy the entire frame tree, this blocks
           // RemoveMappingsForFrameSubtree() which would otherwise lead to a
           // crash since we cleared the placeholder map above (bug 398982).
           PRBool wasDestroyingFrameTree = mIsDestroyingFrameTree;
           WillDestroyFrameTree();
-
-          rv = state.mFrameManager->RemoveFrame(docElementFrame->GetParent(),
-                    GetChildListNameFor(docElementFrame), docElementFrame);
-          
-          if (placeholderFrame) {
-            // Remove the placeholder frame first (XXX second for now) (so
-            // that it doesn't retain a dangling pointer to memory)
-            rv |= state.mFrameManager->RemoveFrame(placeholderFrame->GetParent(),
-                                            nsnull, placeholderFrame);
-          }
-
+          // Remove the old document element hieararchy
+          rv = state.mFrameManager->RemoveFrame(mDocElementContainingBlock,
+                                                nsnull, docElementFrame);
           mIsDestroyingFrameTree = wasDestroyingFrameTree;
           if (NS_FAILED(rv)) {
             return rv;
           }
         }
@@ -7696,12 +7640,13 @@ nsCSSFrameConstructor::GetAbsoluteContai
   // If we found an absolutely positioned containing block, then use the
   // first-continuation.
   if (containingBlock)
     return AdjustAbsoluteContainingBlock(containingBlock);
 
-  // If we didn't find it, then use the document element containing block
-  return mHasRootAbsPosContainingBlock ? mDocElementContainingBlock : nsnull;
+  // If we didn't find it, then use the initial containing block if it
+  // supports abs pos kids.
+  return mInitialContainingBlockIsAbsPosContainer ? mInitialContainingBlock : nsnull;
 }
 
 nsIFrame*
 nsCSSFrameConstructor::GetFloatContainingBlock(nsIFrame* aFrame)
 {
@@ -10282,13 +10227,13 @@ nsCSSFrameConstructor::CreateContinuingF
       // XXXbz should we be passing in a non-null aContentParentFrame?
       nsHTMLContainerFrame::CreateViewForFrame(newFrame, nsnull, PR_FALSE);
     }
 
   } else if (nsGkAtoms::pageFrame == frameType) {
-    nsIFrame* canvasFrame;
+    nsIFrame* pageContentFrame;
     rv = ConstructPageFrame(shell, aPresContext, aParentFrame, aFrame,
-                            newFrame, canvasFrame);
+                            newFrame, pageContentFrame);
   } else if (nsGkAtoms::tableOuterFrame == frameType) {
     rv = CreateContinuingOuterTableFrame(shell, aPresContext, aFrame, aParentFrame,
                                          content, styleContext, &newFrame);
 
   } else if (nsGkAtoms::tableFrame == frameType) {
@@ -10473,21 +10418,21 @@ nsCSSFrameConstructor::CreateContinuingF
 }
 
 nsresult
 nsCSSFrameConstructor::ReplicateFixedFrames(nsPageContentFrame* aParentFrame)
 {
-  // Now deal with fixed-pos things....  They should appear on all pages,
-  // so we want to move over the placeholders when processing the child
-  // of the pageContentFrame.
+  // Now deal with fixed-pos things....  They should appear on all pages, and
+  // the placeholders must be kids of a block, so we want to move over the
+  // placeholders when processing the child of the pageContentFrame.
 
   nsIFrame* prevPageContentFrame = aParentFrame->GetPrevInFlow();
   if (!prevPageContentFrame) {
     return NS_OK;
   }
-  nsIFrame* canvasFrame = aParentFrame->GetFirstChild(nsnull);
-  nsIFrame* prevCanvasFrame = prevPageContentFrame->GetFirstChild(nsnull);
-  if (!canvasFrame || !prevCanvasFrame) {
+  nsIFrame* docRootFrame = aParentFrame->GetFirstChild(nsnull);
+  nsIFrame* prevDocRootFrame = prevPageContentFrame->GetFirstChild(nsnull);
+  if (!docRootFrame || !prevDocRootFrame) {
     // document's root element frame missing
     return NS_ERROR_UNEXPECTED;
   }
 
   nsFrameItems fixedPlaceholders;
@@ -10511,23 +10456,23 @@ nsCSSFrameConstructor::ReplicateFixedFra
   // page - bug 389619)
   for (nsIFrame* fixed = firstFixed; fixed; fixed = fixed->GetNextSibling()) {
     nsIFrame* prevPlaceholder = nsnull;
     mPresShell->GetPlaceholderFrameFor(fixed, &prevPlaceholder);
     if (prevPlaceholder &&
-        nsLayoutUtils::IsProperAncestorFrame(prevCanvasFrame, prevPlaceholder)) {
+        nsLayoutUtils::IsProperAncestorFrame(prevDocRootFrame, prevPlaceholder)) {
       nsresult rv = ConstructFrame(state, fixed->GetContent(),
-                                   canvasFrame, fixedPlaceholders);
+                                   docRootFrame, fixedPlaceholders);
       NS_ENSURE_SUCCESS(rv, rv);
     }
   }
 
   // Add the placeholders to our primary child list.
-  // XXXbz this is a little screwed up, since the fixed frames will have 
-  // broken auto-positioning. Oh, well.
-  NS_ASSERTION(!canvasFrame->GetFirstChild(nsnull),
+  // XXXbz this is a little screwed up, since the fixed frames will have the
+  // wrong parent block and hence auto-positioning will be broken.  Oh, well.
+  NS_ASSERTION(!docRootFrame->GetFirstChild(nsnull),
                "leaking frames; doc root continuation must be empty");
-  canvasFrame->SetInitialChildList(nsnull, fixedPlaceholders.childList);
+  docRootFrame->SetInitialChildList(nsnull, fixedPlaceholders.childList);
   return NS_OK;
 }
 
 static PRBool
 IsBindingAncestor(nsIContent* aContent, nsIContent* aBindingRoot)
@@ -12854,26 +12799,18 @@ nsCSSFrameConstructor::ReframeContaining
 
   // If we get here, we're screwed!
   return ReconstructDocElementHierarchyInternal();
 }
 
-nsresult
-nsCSSFrameConstructor::RemoveFixedItems(const nsFrameConstructorState& aState,
-                                        nsIFrame *aRootElementFrame)
+nsresult nsCSSFrameConstructor::RemoveFixedItems(const nsFrameConstructorState& aState)
 {
   nsresult rv=NS_OK;
 
   if (mFixedContainingBlock) {
     nsIFrame *fixedChild = nsnull;
     do {
       fixedChild = mFixedContainingBlock->GetFirstChild(nsGkAtoms::fixedList);
-      if (fixedChild == aRootElementFrame) {
-        // Skip the root element frame, if it happens to be fixed-positioned
-        // It will be explicitly removed later in
-        // ReconstructDocElementHierarchyInternal
-        fixedChild = fixedChild->GetNextSibling();
-      }
       if (fixedChild) {
         // Remove the placeholder so it doesn't end up sitting about pointing
         // to the removed fixed frame.
         nsPlaceholderFrame *placeholderFrame =
           aState.mFrameManager->GetPlaceholderFrameFor(fixedChild);
diff -r 14ce7619e9c1 layout/base/nsCSSFrameConstructor.h
--- a/layout/base/nsCSSFrameConstructor.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/base/nsCSSFrameConstructor.h	Mon Sep 08 10:35:46 2008 +0300
@@ -268,11 +268,11 @@ private:
   nsresult ConstructPageFrame(nsIPresShell*  aPresShell, 
                               nsPresContext* aPresContext,
                               nsIFrame*      aParentFrame,
                               nsIFrame*      aPrevPageFrame,
                               nsIFrame*&     aPageFrame,
-                              nsIFrame*&     aCanvasFrame);
+                              nsIFrame*&     aPageContentFrame);
 
   void DoContentStateChanged(nsIContent*     aContent,
                              PRInt32         aStateMask);
 
   /* aMinHint is the minimal change that should be made to the element */
@@ -1047,12 +1047,11 @@ private:
                                  nsIFrame*                aBlockFrame,
                                  nsIFrame**               aParentFrame,
                                  nsIFrame*                aPrevSibling,
                                  nsFrameItems&            aFrameItems);
 
-  nsresult RemoveFixedItems(const nsFrameConstructorState& aState,
-                            nsIFrame*                      aRootElementFrame);
+  nsresult RemoveFixedItems(const nsFrameConstructorState& aState);
 
   // Find the right frame to use for aContent when looking for sibling
   // frames for aTargetContent.  If aPrevSibling is true, this
   // will look for last continuations, etc, as necessary.  This calls
   // IsValidSibling as needed; if that returns false it returns null.
@@ -1163,13 +1162,10 @@ private:
   };
 
   nsIDocument*        mDocument;  // Weak ref
   nsIPresShell*       mPresShell; // Weak ref
 
-  // See the comment at the start of ConstructRootFrame for more details
-  // about the following frames.
-  
   // This is not the real CSS 2.1 "initial containing block"! It is just
   // the outermost frame for the root element.
   nsIFrame*           mInitialContainingBlock;
   // This is the frame for the root element that has no pseudo-element style.
   nsIFrame*           mRootElementStyleFrame;
@@ -1183,14 +1179,13 @@ private:
   nsQuoteList         mQuoteList;
   nsCounterManager    mCounterManager;
   PRUint16            mUpdateCount;
   PRPackedBool        mQuotesDirty : 1;
   PRPackedBool        mCountersDirty : 1;
+  PRPackedBool        mInitialContainingBlockIsAbsPosContainer : 1;
   PRPackedBool        mIsDestroyingFrameTree : 1;
   PRPackedBool        mRebuildAllStyleData : 1;
-  // This is true if mDocElementContainingBlock supports absolute positioning
-  PRPackedBool        mHasRootAbsPosContainingBlock : 1;
 
   nsRevocableEventPtr<RestyleEvent> mRestyleEvent;
 
   nsCOMPtr<nsILayoutHistoryState> mTempFrameTreeState;
 
diff -r 14ce7619e9c1 layout/base/nsDisplayList.h
--- a/layout/base/nsDisplayList.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/base/nsDisplayList.h	Mon Sep 08 10:35:46 2008 +0300
@@ -955,11 +955,10 @@ protected:
 #define DO_GLOBAL_REFLOW_COUNT_DSP_COLOR(_name, _color)
 #define DECL_DO_GLOBAL_REFLOW_COUNT_DSP(_class, _super)
 
 #endif // MOZ_REFLOW_PERF_DSP && MOZ_REFLOW_PERF
 
-MOZ_DECL_CTOR_COUNTER(nsDisplayCaret)
 class nsDisplayCaret : public nsDisplayItem {
 public:
   nsDisplayCaret(nsIFrame* aCaretFrame, nsCaret *aCaret)
     : nsDisplayItem(aCaretFrame), mCaret(aCaret) {
     MOZ_COUNT_CTOR(nsDisplayCaret);
diff -r 14ce7619e9c1 layout/base/nsImageLoader.cpp
--- a/layout/base/nsImageLoader.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/base/nsImageLoader.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -210,11 +210,14 @@ void
 void
 nsImageLoader::RedrawDirtyFrame(const nsRect* aDamageRect)
 {
   if (mReflowOnLoad) {
     nsIPresShell *shell = mPresContext->GetPresShell();
-    nsresult rv = shell->FrameNeedsReflow(mFrame, nsIPresShell::eStyleChange, NS_FRAME_IS_DIRTY);
+#ifdef DEBUG
+    nsresult rv = 
+#endif
+      shell->FrameNeedsReflow(mFrame, nsIPresShell::eStyleChange, NS_FRAME_IS_DIRTY);
     NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "Could not reflow after loading border-image");
     // The reflow might not do all the invalidation we need, so continue
     // on with the invalidation codepath.
   }
   // NOTE: It is not sufficient to invalidate only the size of the image:
diff -r 14ce7619e9c1 layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/base/nsLayoutUtils.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -1851,11 +1851,10 @@ nsLayoutUtils::ComputeWidthDependentValu
                  const nsStyleCoord&  aCoord)
 {
   NS_PRECONDITION(aContainingBlockWidth != NS_UNCONSTRAINEDSIZE,
                   "unconstrained widths no longer supported");
 
-  nscoord result;
   if (eStyleUnit_Coord == aCoord.GetUnit()) {
     return aCoord.GetCoordValue();
   }
   if (eStyleUnit_Percent == aCoord.GetUnit()) {
     return NSToCoordFloor(aContainingBlockWidth * aCoord.GetPercentValue());
@@ -1929,11 +1928,10 @@ nsLayoutUtils::ComputeWidthValue(
 /* static */ nscoord
 nsLayoutUtils::ComputeHeightDependentValue(
                  nscoord              aContainingBlockHeight,
                  const nsStyleCoord&  aCoord)
 {
-  nscoord result;
   if (eStyleUnit_Coord == aCoord.GetUnit()) {
     return aCoord.GetCoordValue();
   }
   if (eStyleUnit_Percent == aCoord.GetUnit()) {
     // XXXldb Some callers explicitly check aContainingBlockHeight
diff -r 14ce7619e9c1 layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/base/nsPresShell.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -2698,12 +2698,11 @@ void PresShell::RestoreCaret()
   mCaret = mOriginalCaret;
 }
 
 NS_IMETHODIMP PresShell::SetCaretEnabled(PRBool aInEnable)
 {
-  nsresult result = NS_OK;
-  PRBool   oldEnabled = mCaretEnabled;
+  PRBool oldEnabled = mCaretEnabled;
 
   mCaretEnabled = aInEnable;
 
   if (mCaret && (mCaretEnabled != oldEnabled))
   {
diff -r 14ce7619e9c1 layout/forms/nsListControlFrame.cpp
--- a/layout/forms/nsListControlFrame.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/forms/nsListControlFrame.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -669,11 +669,13 @@ nsListControlFrame::ReflowAsDropdown(nsP
                   "We should not have a computed height here!");
   
   mMightNeedSecondPass = NS_SUBTREE_DIRTY(this) ||
     aReflowState.ShouldReflowAllKids();
 
+#ifdef DEBUG
   nscoord oldHeightOfARow = HeightOfARow();
+#endif
 
   nsHTMLReflowState state(aReflowState);
 
   nscoord oldVisibleHeight;
   if (!(GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
@@ -1543,17 +1545,20 @@ nsListControlFrame::SetOptionsSelectedFr
                                                 PRBool aValue,
                                                 PRBool aClearAll)
 {
   nsCOMPtr<nsISelectElement> selectElement(do_QueryInterface(mContent));
   PRBool wasChanged = PR_FALSE;
-  nsresult rv = selectElement->SetOptionsSelectedByIndex(aStartIndex,
-                                                         aEndIndex,
-                                                         aValue,
-                                                         aClearAll,
-                                                         PR_FALSE,
-                                                         PR_TRUE,
-                                                         &wasChanged);
+#ifdef DEBUG
+  nsresult rv = 
+#endif
+    selectElement->SetOptionsSelectedByIndex(aStartIndex,
+                                             aEndIndex,
+                                             aValue,
+                                             aClearAll,
+                                             PR_FALSE,
+                                             PR_TRUE,
+                                             &wasChanged);
   NS_ASSERTION(NS_SUCCEEDED(rv), "SetSelected failed");
   return wasChanged;
 }
 
 PRBool
diff -r 14ce7619e9c1 layout/generic/crashtests/302260-1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/generic/crashtests/302260-1.html	Mon Sep 08 10:35:46 2008 +0300
@@ -0,0 +1,21 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
+    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+
+<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
+<head>
+
+<style type="text/css">
+
+body {
+	text-indent:20px;
+}
+
+span {
+	float:right;
+}
+</style>
+</head>
+
+<body><span>What's Clicking Now</span>
+</body>
+</html>
diff -r 14ce7619e9c1 layout/generic/crashtests/382131-1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/generic/crashtests/382131-1.html	Mon Sep 08 10:35:46 2008 +0300
@@ -0,0 +1,25 @@
+<html class="reftest-wait">
+<head>
+<script>
+
+function crash()
+{
+  try {
+    window.getSelection().containsNode([], false);
+  } catch(e) { }
+
+  try {
+    window.getSelection().containsNode(null, false);
+  } catch(e) { }
+  
+  document.documentElement.removeAttribute("class");
+}
+
+</script>
+</head>
+
+<body onload="setTimeout(crash, 10);">
+Foo
+</body>
+
+</html>
diff -r 14ce7619e9c1 layout/generic/crashtests/crashtests.list
--- a/layout/generic/crashtests/crashtests.list	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/generic/crashtests/crashtests.list	Mon Sep 08 10:35:46 2008 +0300
@@ -1,5 +1,6 @@ load 307979-1.html
+load 302260-1.html
 load 307979-1.html
 load 310556-1.xhtml
 load 322780-1.xul
 load 323386-1.html
 load 323389-1.html
@@ -50,10 +51,11 @@ load 379217-1.xhtml
 load 379217-1.xhtml
 load 379217-2.xhtml
 load 379917-1.xhtml
 load 380012-1.html
 load 382129-1.xhtml
+load 382131-1.html
 load 382199-1.html
 load 382208-1.xhtml
 load 382262-1.html
 load 382396-1.xhtml
 load 383089-1.html
diff -r 14ce7619e9c1 layout/generic/nsAbsoluteContainingBlock.cpp
--- a/layout/generic/nsAbsoluteContainingBlock.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/generic/nsAbsoluteContainingBlock.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -49,10 +49,21 @@
 #include "nsPresContext.h"
 
 #ifdef DEBUG
 #include "nsBlockFrame.h"
 #endif
+
+
+nsresult
+nsAbsoluteContainingBlock::FirstChild(const nsIFrame* aDelegatingFrame,
+                                      nsIAtom*        aListName,
+                                      nsIFrame**      aFirstChild) const
+{
+  NS_PRECONDITION(GetChildListName() == aListName, "unexpected child list name");
+  *aFirstChild = mAbsoluteFrames.FirstChild();
+  return NS_OK;
+}
 
 nsresult
 nsAbsoluteContainingBlock::SetInitialChildList(nsIFrame*       aDelegatingFrame,
                                                nsIAtom*        aListName,
                                                nsIFrame*       aChildList)
diff -r 14ce7619e9c1 layout/generic/nsAbsoluteContainingBlock.h
--- a/layout/generic/nsAbsoluteContainingBlock.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/generic/nsAbsoluteContainingBlock.h	Mon Sep 08 10:35:46 2008 +0300
@@ -82,11 +82,14 @@ public:
 
 #ifdef DEBUG
   nsIAtom* GetChildListName() const { return mChildListName; }
 #endif
 
-  nsIFrame* GetFirstChild() const { return mAbsoluteFrames.FirstChild(); }
+  nsresult FirstChild(const nsIFrame* aDelegatingFrame,
+                      nsIAtom*        aListName,
+                      nsIFrame**      aFirstChild) const;
+  nsIFrame* GetFirstChild() { return mAbsoluteFrames.FirstChild(); }
 
   nsresult SetInitialChildList(nsIFrame*       aDelegatingFrame,
                                nsIAtom*        aListName,
                                nsIFrame*       aChildList);
   nsresult AppendFrames(nsIFrame*      aDelegatingFrame,
diff -r 14ce7619e9c1 layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/generic/nsBlockFrame.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -518,11 +518,13 @@ nsBlockFrame::GetBaseline() const
 
 nsIFrame*
 nsBlockFrame::GetFirstChild(nsIAtom* aListName) const
 {
   if (nsGkAtoms::absoluteList == aListName) {
-    return mAbsoluteContainer.GetFirstChild();
+    nsIFrame* result = nsnull;
+    mAbsoluteContainer.FirstChild(this, aListName, &result);
+    return result;
   }
   else if (nsnull == aListName) {
     return (mLines.empty()) ? nsnull : mLines.front()->mFirstChild;
   }
   else if (aListName == nsGkAtoms::overflowList) {
@@ -799,29 +801,31 @@ CalculateContainingBlockSizeForAbsolutes
   const nsMargin& border =
     aReflowState.mComputedBorderPadding - aReflowState.mComputedPadding;
   cbSize.width -= border.LeftRight();
   cbSize.height -= border.TopBottom();
 
-  if (frame->GetParent()->GetContent() == frame->GetContent() &&
-      frame->GetParent()->GetType() != nsGkAtoms::canvasFrame) {
-    // We are a wrapped frame for the content (and the wrapper is not the
-    // canvas frame, whose size is not meaningful here).
-    // Use the container's dimensions, if they have been precomputed.
+  if (frame->GetParent()->GetContent() == frame->GetContent()) {
+    // We are a wrapped frame for the content. Use the container's
+    // dimensions, if they have been precomputed.
     // XXX This is a hack! We really should be waiting until the outermost
     // frame is fully reflowed and using the resulting dimensions, even
     // if they're intrinsic.
     // In fact we should be attaching absolute children to the outermost
     // frame and not always sticking them in block frames.
 
     // First, find the reflow state for the outermost frame for this
     // content.
     const nsHTMLReflowState* aLastRS = &aReflowState;
     const nsHTMLReflowState* lastButOneRS = &aReflowState;
+    PRBool isCanvasBlock = PR_FALSE;
     while (aLastRS->parentReflowState &&
            aLastRS->parentReflowState->frame->GetContent() == frame->GetContent()) {
       lastButOneRS = aLastRS;
       aLastRS = aLastRS->parentReflowState;
+      if (aLastRS->frame->GetType() == nsGkAtoms::canvasFrame) {
+        isCanvasBlock = PR_TRUE;
+      }
     }
     if (aLastRS != &aReflowState) {
       // Scrollbars need to be specifically excluded, if present, because they are outside the
       // padding-edge. We need better APIs for getting the various boxes from a frame.
       nsIScrollableFrame* scrollFrame;
@@ -838,15 +842,27 @@ CalculateContainingBlockSizeForAbsolutes
           scrollbars.left = scrollbars.right = 0;
         }
       }
       // We found a reflow state for the outermost wrapping frame, so use
       // its computed metrics if available
-      if (aLastRS->ComputedWidth() != NS_UNCONSTRAINEDSIZE) {
+      // XXX grotesque hack for Firefox 2 compatibility until we can
+      // properly fix abs-pos containers! If this is the block for
+      // the root element, don't adjust the width here, just use the block's
+      // width. We have to do this because the abs-pos frame will be
+      // positioned relative to the block, not the canvas frame, and the
+      // block might have borders and margin which will throw things off
+      // if we use the canvas frame width.
+      // Positioning abs-pos frames relative to the canvas is bug 425432.
+      if (aLastRS->ComputedWidth() != NS_UNCONSTRAINEDSIZE && !isCanvasBlock) {
         cbSize.width = PR_MAX(0,
           aLastRS->ComputedWidth() + aLastRS->mComputedPadding.LeftRight() - scrollbars.LeftRight());
       }
       if (aLastRS->ComputedHeight() != NS_UNCONSTRAINEDSIZE) {
+        // XXX This can be terribly wrong if we're the root element's block,
+        // because our margin and borders will be included in the height
+        // here but the abs-pos element(s) are positioned relative to
+        // our content rect...
         cbSize.height = PR_MAX(0,
           aLastRS->ComputedHeight() + aLastRS->mComputedPadding.TopBottom() - scrollbars.TopBottom());
       }
     }
   }
@@ -4259,11 +4275,13 @@ nsBlockFrame::HandleOverflowPlaceholders
   nsBlockReflowState& aState, nsLineBox* aLine)
 {
   // First, see if it's a line of continuation placeholders. If it
   // is, remove one and retry.
   if (aLine->mFirstChild && IsContinuationPlaceholder(aLine->mFirstChild)) {
+#ifdef DEBUG
     PRBool taken =
+#endif
       HandleOverflowPlaceholdersForPulledFrame(aState, aLine->mFirstChild);
     NS_ASSERTION(taken, "We must have removed that frame");
     return PR_TRUE;
   }
  
@@ -4611,12 +4629,14 @@ nsBlockFrame::SetOverflowOutOfFlows(cons
 {
   if (aList.IsEmpty()) {
     if (!(GetStateBits() & NS_BLOCK_HAS_OVERFLOW_OUT_OF_FLOWS)) {
       return;
     }
+#ifdef DEBUG
     nsIFrame* result = static_cast<nsIFrame*>
-                                  (UnsetProperty(nsGkAtoms::overflowOutOfFlowsProperty));
+#endif
+      (UnsetProperty(nsGkAtoms::overflowOutOfFlowsProperty));
     NS_ASSERTION(result, "value should always be non-empty when state set");
     RemoveStateBits(NS_BLOCK_HAS_OVERFLOW_OUT_OF_FLOWS);
   } else {
     SetProperty(nsGkAtoms::overflowOutOfFlowsProperty,
                 aList.FirstChild(), nsnull);
@@ -5589,12 +5609,11 @@ nsBlockFrame::StealFrame(nsPresContext* 
 
 void
 nsBlockFrame::DeleteNextInFlowChild(nsPresContext* aPresContext,
                                     nsIFrame*       aNextInFlow)
 {
-  nsIFrame* prevInFlow = aNextInFlow->GetPrevInFlow();
-  NS_PRECONDITION(prevInFlow, "bad next-in-flow");
+  NS_PRECONDITION(aNextInFlow->GetPrevInFlow(), "bad next-in-flow");
 
   if (NS_FRAME_IS_OVERFLOW_CONTAINER & aNextInFlow->GetStateBits()) {
     nsContainerFrame::DeleteNextInFlowChild(aPresContext, aNextInFlow);
   }
   else {
diff -r 14ce7619e9c1 layout/generic/nsContainerFrame.cpp
--- a/layout/generic/nsContainerFrame.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/generic/nsContainerFrame.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -221,11 +221,14 @@ nsContainerFrame::RemoveFrame(nsIAtom*  
       //      inline containing blocks.
       if (parent == this) {
         if (!parent->mFrames.DestroyFrame(aOldFrame)) {
           // Try to remove it from our overflow list, if we have one.
           // The simplest way is to reuse StealFrame.
-          nsresult rv = StealFrame(PresContext(), aOldFrame, PR_TRUE);
+#ifdef DEBUG
+          nsresult rv =
+#endif
+            StealFrame(PresContext(), aOldFrame, PR_TRUE);
           NS_ASSERTION(NS_SUCCEEDED(rv), "Could not find frame to remove!");
           aOldFrame->Destroy();
         }
       } else {
         // This recursive call takes care of all continuations after aOldFrame,
@@ -487,12 +490,11 @@ SyncFrameViewGeometryDependentProperties
 {
   nsIViewManager* vm = aView->GetViewManager();
 
   PRBool isCanvas;
   const nsStyleBackground* bg;
-  PRBool hasBG =
-    nsCSSRendering::FindBackground(aPresContext, aFrame, &bg, &isCanvas);
+  nsCSSRendering::FindBackground(aPresContext, aFrame, &bg, &isCanvas);
 
   if (isCanvas) {
     nsIView* rootView;
     vm->GetRootView(rootView);
 
@@ -1095,11 +1097,14 @@ nsContainerFrame::StealFrame(nsPresConte
  */
 void
 nsContainerFrame::DeleteNextInFlowChild(nsPresContext* aPresContext,
                                         nsIFrame*      aNextInFlow)
 {
+#ifdef DEBUG
   nsIFrame* prevInFlow = aNextInFlow->GetPrevInFlow();
+#endif
+
   NS_PRECONDITION(prevInFlow, "bad prev-in-flow");
 
   // If the next-in-flow has a next-in-flow then delete it, too (and
   // delete it first).
   // Do this in a loop so we don't overflow the stack for frames
@@ -1121,11 +1126,14 @@ nsContainerFrame::DeleteNextInFlowChild(
 
   // Disconnect the next-in-flow from the flow list
   nsSplittableFrame::BreakFromPrevFlow(aNextInFlow);
 
   // Take the next-in-flow out of the parent's child list
-  nsresult rv = StealFrame(aPresContext, aNextInFlow);
+#ifdef DEBUG
+  nsresult rv = 
+#endif
+    StealFrame(aPresContext, aNextInFlow);
   NS_ASSERTION(NS_SUCCEEDED(rv), "StealFrame failure");
 
   // Delete the next-in-flow frame and its descendants.
   aNextInFlow->Destroy();
 
@@ -1582,13 +1590,10 @@ nsContainerFrame::List(FILE* out, PRInt3
   // Output the children
   nsIAtom* listName = nsnull;
   PRInt32 listIndex = 0;
   PRBool outputOneList = PR_FALSE;
   do {
-    if (!outputOneList) {
-      fputs("\n", out);
-    }
     nsIFrame* kid = GetFirstChild(listName);
     if (nsnull != kid) {
       if (outputOneList) {
         IndentBy(out, aIndent);
       }
diff -r 14ce7619e9c1 layout/generic/nsFirstLetterFrame.cpp
--- a/layout/generic/nsFirstLetterFrame.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/generic/nsFirstLetterFrame.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -109,18 +109,18 @@ nsFirstLetterFrame::SetInitialChildList(
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
-nsFirstLetterFrame::SetSelected(nsPresContext* aPresContext, nsIDOMRange *aRange,PRBool aSelected, nsSpread aSpread)
+nsFirstLetterFrame::SetSelected(nsPresContext* aPresContext, nsIDOMRange *aRange,PRBool aSelected, nsSpread aSpread, SelectionType aType)
 {
   if (aSelected && ParentDisablesSelection())
     return NS_OK;
   nsIFrame *child = GetFirstChild(nsnull);
   while (child)
   {
-    child->SetSelected(aPresContext, aRange, aSelected, aSpread);
+    child->SetSelected(aPresContext, aRange, aSelected, aSpread, aType);
     // don't worry about result. there are more frames to come
     child = child->GetNextSibling();
   }
   return NS_OK;
 }
diff -r 14ce7619e9c1 layout/generic/nsFirstLetterFrame.h
--- a/layout/generic/nsFirstLetterFrame.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/generic/nsFirstLetterFrame.h	Mon Sep 08 10:35:46 2008 +0300
@@ -81,11 +81,11 @@ public:
                     const nsHTMLReflowState& aReflowState,
                     nsReflowStatus&          aStatus);
 
   virtual PRBool CanContinueTextRun() const;
 
-  NS_IMETHOD SetSelected(nsPresContext* aPresContext, nsIDOMRange *aRange,PRBool aSelected, nsSpread aSpread);
+  NS_IMETHOD SetSelected(nsPresContext* aPresContext, nsIDOMRange *aRange,PRBool aSelected, nsSpread aSpread, SelectionType aType);
 
 //override of nsFrame method
   NS_IMETHOD GetChildFrameContainingOffset(PRInt32 inContentOffset,
                                            PRBool inHint,
                                            PRInt32* outFrameContentOffset,
diff -r 14ce7619e9c1 layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/generic/nsFrame.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -4146,22 +4146,24 @@ nsFrame::VerifyTree() const
 #endif
 
 /*this method may.. invalidate if the state was changed or if aForceRedraw is PR_TRUE
   it will not update immediately.*/
 NS_IMETHODIMP
-nsFrame::SetSelected(nsPresContext* aPresContext, nsIDOMRange *aRange, PRBool aSelected, nsSpread aSpread)
+nsFrame::SetSelected(nsPresContext* aPresContext, nsIDOMRange *aRange, PRBool aSelected, nsSpread aSpread, SelectionType aType)
 {
 /*
   if (aSelected && ParentDisablesSelection())
     return NS_OK;
 */
 
-  // check whether style allows selection
-  PRBool  selectable;
-  IsSelectable(&selectable, nsnull);
-  if (!selectable)
-    return NS_OK;
+  if (aType == nsISelectionController::SELECTION_NORMAL) {
+    // check whether style allows selection
+    PRBool  selectable;
+    IsSelectable(&selectable, nsnull);
+    if (!selectable)
+      return NS_OK;
+  }
 
 /*
   if (eSpreadDown == aSpread){
     nsIFrame* kid = GetFirstChild(nsnull);
     while (nsnull != kid) {
@@ -4184,11 +4186,11 @@ nsFrame::SetSelected(nsPresContext* aPre
   nsIFrame* frame = GetNextSibling();
   if (frame) {
     GetFirstLeaf(aPresContext, &frame);
     GetOffsets(start, end);
     if (start && end) {
-      frame->SetSelected(aPresContext, aRange, aSelected, aSpread);
+      frame->SetSelected(aPresContext, aRange, aSelected, aSpread, aType);
     }
   }
 #endif // IBMBIDI
 
   return NS_OK;
@@ -5557,23 +5559,16 @@ nsFrame::CorrectStyleParentFrame(nsIFram
     }
 
     parent = parent->GetParent();
   } while (parent);
 
-  if (aProspectiveParent->GetStyleContext()->GetPseudoType() ==
-      nsCSSAnonBoxes::viewportScroll) {
-    // aProspectiveParent is the scrollframe for a viewport
-    // and the kids are the anonymous scrollbars
-    return aProspectiveParent;
-  }
-
-  // We can get here if the root element is absolutely positioned.
-  // We can't test for this very accurately, but it can only happen
-  // when the prospective parent is a canvas frame.
-  NS_ASSERTION(aProspectiveParent->GetType() == nsGkAtoms::canvasFrame,
+  // We can get here if aProspectiveParent is the scrollframe for a viewport
+  // and the kids are the anonymous scrollbars.
+  NS_ASSERTION(aProspectiveParent->GetStyleContext()->GetPseudoType() ==
+                 nsCSSAnonBoxes::viewportScroll,
                "Should have found a parent before this");
-  return nsnull;
+  return aProspectiveParent;
 }
 
 nsresult
 nsFrame::DoGetParentStyleContextFrame(nsPresContext* aPresContext,
                                       nsIFrame**      aProviderFrame,
@@ -6614,12 +6609,10 @@ DR_cookie::~DR_cookie()
 {
   MOZ_COUNT_DTOR(DR_cookie);
   nsFrame::DisplayReflowExit(mPresContext, mFrame, mMetrics, mStatus, mValue);
 }
 
-MOZ_DECL_CTOR_COUNTER(DR_layout_cookie)
-
 DR_layout_cookie::DR_layout_cookie(nsIFrame* aFrame)
   : mFrame(aFrame)
 {
   MOZ_COUNT_CTOR(DR_layout_cookie);
   mValue = nsFrame::DisplayLayoutEnter(mFrame);
@@ -6628,12 +6621,10 @@ DR_layout_cookie::~DR_layout_cookie()
 DR_layout_cookie::~DR_layout_cookie()
 {
   MOZ_COUNT_DTOR(DR_layout_cookie);
   nsFrame::DisplayLayoutExit(mFrame, mValue);
 }
-
-MOZ_DECL_CTOR_COUNTER(DR_intrinsic_width_cookie)
 
 DR_intrinsic_width_cookie::DR_intrinsic_width_cookie(
                      nsIFrame*                aFrame, 
                      const char*              aType,
                      nscoord&                 aResult)
@@ -6648,12 +6639,10 @@ DR_intrinsic_width_cookie::~DR_intrinsic
 DR_intrinsic_width_cookie::~DR_intrinsic_width_cookie()
 {
   MOZ_COUNT_DTOR(DR_intrinsic_width_cookie);
   nsFrame::DisplayIntrinsicWidthExit(mFrame, mType, mResult, mValue);
 }
-
-MOZ_DECL_CTOR_COUNTER(DR_intrinsic_size_cookie)
 
 DR_intrinsic_size_cookie::DR_intrinsic_size_cookie(
                      nsIFrame*                aFrame, 
                      const char*              aType,
                      nsSize&                  aResult)
diff -r 14ce7619e9c1 layout/generic/nsFrame.h
--- a/layout/generic/nsFrame.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/generic/nsFrame.h	Mon Sep 08 10:35:46 2008 +0300
@@ -236,11 +236,11 @@ public:
   NS_IMETHOD_(nsFrameState) GetDebugStateBits() const;
   NS_IMETHOD  DumpRegressionData(nsPresContext* aPresContext, FILE* out, PRInt32 aIndent, PRBool aIncludeStyleData);
   NS_IMETHOD  VerifyTree() const;
 #endif
 
-  NS_IMETHOD  SetSelected(nsPresContext* aPresContext, nsIDOMRange *aRange,PRBool aSelected, nsSpread aSpread);
+  NS_IMETHOD  SetSelected(nsPresContext* aPresContext, nsIDOMRange *aRange,PRBool aSelected, nsSpread aSpread, SelectionType aType);
   NS_IMETHOD  GetSelected(PRBool *aSelected) const;
   NS_IMETHOD  IsSelectable(PRBool* aIsSelectable, PRUint8* aSelectStyle) const;
 
   NS_IMETHOD  GetSelectionController(nsPresContext *aPresContext, nsISelectionController **aSelCon);
 
diff -r 14ce7619e9c1 layout/generic/nsHTMLFrame.cpp
--- a/layout/generic/nsHTMLFrame.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/generic/nsHTMLFrame.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -52,11 +52,10 @@
 #include "nsIEventStateManager.h"
 #include "nsIDeviceContext.h"
 #include "nsIPresShell.h"
 #include "nsIScrollPositionListener.h"
 #include "nsDisplayList.h"
-#include "nsAbsoluteContainingBlock.h"
 
 // for focus
 #include "nsIDOMWindowInternal.h"
 #include "nsIFocusController.h"
 #include "nsIScrollableFrame.h"
@@ -65,12 +64,10 @@
 #include "nsICanvasFrame.h"
 
 #ifdef DEBUG_rods
 //#define DEBUG_CANVAS_FOCUS
 #endif
-
-#define CANVAS_ABS_POS_CHILD_LIST NS_CONTAINER_LIST_COUNT_INCL_OC
 
 // Interface IDs
 
 /**
  * Root frame class.
@@ -82,46 +79,35 @@ class CanvasFrame : public nsHTMLContain
 class CanvasFrame : public nsHTMLContainerFrame, 
                     public nsIScrollPositionListener, 
                     public nsICanvasFrame {
 public:
   CanvasFrame(nsStyleContext* aContext)
-  : nsHTMLContainerFrame(aContext), mDoPaintFocus(PR_FALSE),
-    mAbsoluteContainer(nsGkAtoms::absoluteList) {}
+  : nsHTMLContainerFrame(aContext), mDoPaintFocus(PR_FALSE) {}
 
    // nsISupports
   NS_IMETHOD QueryInterface(const nsIID& aIID, void** aInstancePtr);
 
   NS_IMETHOD Init(nsIContent*      aContent,
                   nsIFrame*        aParent,
                   nsIFrame*        aPrevInFlow);
   virtual void Destroy();
 
-  NS_IMETHOD SetInitialChildList(nsIAtom*        aListName,
-                                 nsIFrame*       aChildList);
   NS_IMETHOD AppendFrames(nsIAtom*        aListName,
                           nsIFrame*       aFrameList);
   NS_IMETHOD InsertFrames(nsIAtom*        aListName,
                           nsIFrame*       aPrevFrame,
                           nsIFrame*       aFrameList);
   NS_IMETHOD RemoveFrame(nsIAtom*        aListName,
                          nsIFrame*       aOldFrame);
 
-  virtual nsIAtom* GetAdditionalChildListName(PRInt32 aIndex) const;
-  virtual nsIFrame* GetFirstChild(nsIAtom* aListName) const;
-
   virtual nscoord GetMinWidth(nsIRenderingContext *aRenderingContext);
   virtual nscoord GetPrefWidth(nsIRenderingContext *aRenderingContext);
   NS_IMETHOD Reflow(nsPresContext*          aPresContext,
                     nsHTMLReflowMetrics&     aDesiredSize,
                     const nsHTMLReflowState& aReflowState,
                     nsReflowStatus&          aStatus);
   virtual PRBool IsContainingBlock() const { return PR_TRUE; }
-  virtual PRBool IsFrameOfType(PRUint32 aFlags) const
-  {
-    return nsHTMLContainerFrame::IsFrameOfType(aFlags &
-             ~(nsIFrame::eCanContainOverflowContainers));
-  }
 
   NS_IMETHOD BuildDisplayList(nsDisplayListBuilder*   aBuilder,
                               const nsRect&           aDirtyRect,
                               const nsDisplayListSet& aLists);
 
@@ -140,25 +126,10 @@ public:
    *
    * @see nsGkAtoms::canvasFrame
    */
   virtual nsIAtom* GetType() const;
 
-  virtual nsresult StealFrame(nsPresContext* aPresContext,
-                              nsIFrame*      aChild,
-                              PRBool         aForceNormal)
-  {
-    NS_ASSERTION(!aForceNormal, "No-one should be passing this in here");
-
-    // CanvasFrame keeps overflow container continuations of its child
-    // frame in main child list
-    nsresult rv = nsContainerFrame::StealFrame(aPresContext, aChild, PR_TRUE);
-    if (NS_FAILED(rv)) {
-      rv = nsContainerFrame::StealFrame(aPresContext, aChild);
-    }
-    return rv;
-  }
-
 #ifdef DEBUG
   NS_IMETHOD GetFrameName(nsAString& aResult) const;
 #endif
   NS_IMETHOD GetContentForEvent(nsPresContext* aPresContext,
                                 nsEvent* aEvent,
@@ -168,13 +139,12 @@ public:
 
 protected:
   virtual PRIntn GetSkipSides() const;
 
   // Data members
-  PRPackedBool              mDoPaintFocus;
-  nsCOMPtr<nsIViewManager>  mViewManager;
-  nsAbsoluteContainingBlock mAbsoluteContainer;
+  PRPackedBool             mDoPaintFocus;
+  nsCOMPtr<nsIViewManager> mViewManager;
 
 private:
   NS_IMETHOD_(nsrefcnt) AddRef() { return NS_OK; }
   NS_IMETHOD_(nsrefcnt) Release() { return NS_OK; }
 };
@@ -226,12 +196,10 @@ CanvasFrame::Init(nsIContent*      aCont
 }
 
 void
 CanvasFrame::Destroy()
 {
-  mAbsoluteContainer.DestroyFrames(this);
-
   nsIScrollableView* scrollingView = nsnull;
   mViewManager->GetRootScrollableView(&scrollingView);
   if (scrollingView) {
     scrollingView->RemoveScrollPositionListener(this);
   }
@@ -276,35 +244,23 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 CanvasFrame::SetHasFocus(PRBool aHasFocus)
 {
   if (mDoPaintFocus != aHasFocus) {
     mDoPaintFocus = aHasFocus;
-    mViewManager->UpdateAllViews(NS_VMREFRESH_NO_SYNC);
+    nsIViewManager* vm = PresContext()->PresShell()->GetViewManager();
+    if (vm) {
+      vm->UpdateAllViews(NS_VMREFRESH_NO_SYNC);
+    }
   }
   return NS_OK;
-}
-
-NS_IMETHODIMP
-CanvasFrame::SetInitialChildList(nsIAtom*        aListName,
-                                 nsIFrame*       aChildList)
-{
-  if (nsGkAtoms::absoluteList == aListName)
-    return mAbsoluteContainer.SetInitialChildList(this, aListName, aChildList);
-
-  NS_ASSERTION(aListName || !aChildList || !aChildList->GetNextSibling(),
-               "Primary child list can have at most one frame in it");
-  return nsHTMLContainerFrame::SetInitialChildList(aListName, aChildList);
 }
 
 NS_IMETHODIMP
 CanvasFrame::AppendFrames(nsIAtom*        aListName,
                           nsIFrame*       aFrameList)
 {
   nsresult  rv;
-
-  if (nsGkAtoms::absoluteList == aListName)
-    return mAbsoluteContainer.AppendFrames(this, aListName, aFrameList);
 
   NS_ASSERTION(!aListName, "unexpected child list name");
   NS_PRECONDITION(mFrames.IsEmpty(), "already have a child frame");
   if (aListName) {
     // We only support unnamed principal child list
@@ -334,13 +290,10 @@ CanvasFrame::InsertFrames(nsIAtom*      
                           nsIFrame*       aPrevFrame,
                           nsIFrame*       aFrameList)
 {
   nsresult  rv;
 
-  if (nsGkAtoms::absoluteList == aListName)
-    return mAbsoluteContainer.InsertFrames(this, aListName, aPrevFrame, aFrameList);
-
   // Because we only support a single child frame inserting is the same
   // as appending
   NS_PRECONDITION(!aPrevFrame, "unexpected previous sibling frame");
   if (aPrevFrame) {
     rv = NS_ERROR_UNEXPECTED;
@@ -354,13 +307,10 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 CanvasFrame::RemoveFrame(nsIAtom*        aListName,
                          nsIFrame*       aOldFrame)
 {
   nsresult  rv;
-
-  if (nsGkAtoms::absoluteList == aListName)
-    return mAbsoluteContainer.RemoveFrame(this, aListName, aOldFrame);
 
   NS_ASSERTION(!aListName, "unexpected child list name");
   if (aListName) {
     // We only support the unnamed principal child list
     rv = NS_ERROR_INVALID_ARG;
@@ -381,28 +331,10 @@ CanvasFrame::RemoveFrame(nsIAtom*       
   } else {
     rv = NS_ERROR_FAILURE;
   }
 
   return rv;
-}
-
-nsIAtom*
-CanvasFrame::GetAdditionalChildListName(PRInt32 aIndex) const
-{
-  if (CANVAS_ABS_POS_CHILD_LIST == aIndex)
-    return nsGkAtoms::absoluteList;
-
-  return nsHTMLContainerFrame::GetAdditionalChildListName(aIndex);
-}
-
-nsIFrame*
-CanvasFrame::GetFirstChild(nsIAtom* aListName) const
-{
-  if (nsGkAtoms::absoluteList == aListName)
-    return mAbsoluteContainer.GetFirstChild();
-
-  return nsHTMLContainerFrame::GetFirstChild(aListName);
 }
 
 nsRect CanvasFrame::CanvasArea() const
 {
   nsRect result(GetOverflowRect());
@@ -485,17 +417,10 @@ CanvasFrame::BuildDisplayList(nsDisplayL
 CanvasFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
                               const nsRect&           aDirtyRect,
                               const nsDisplayListSet& aLists)
 {
   nsresult rv;
-
-  if (GetPrevInFlow()) {
-    DisplayOverflowContainers(aBuilder, aDirtyRect, aLists);
-  }
-
-  aBuilder->MarkFramesForDisplayList(this, mAbsoluteContainer.GetFirstChild(), aDirtyRect);
-  
   // Force a background to be shown. We may have a background propagated to us,
   // in which case GetStyleBackground wouldn't have the right background
   // and the code in nsFrame::DisplayBorderBackgroundOutline might not give us
   // a background.
   // We don't have any border or outline, and our background draws over
@@ -505,12 +430,12 @@ CanvasFrame::BuildDisplayList(nsDisplayL
     rv = aLists.BorderBackground()->AppendNewToTop(new (aBuilder)
            nsDisplayCanvasBackground(this));
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
-  nsIFrame* kid;
-  for (kid = GetFirstChild(nsnull); kid; kid = kid->GetNextSibling()) {
+  nsIFrame* kid = GetFirstChild(nsnull);
+  if (kid) {
     // Put our child into its own pseudo-stack.
     rv = BuildDisplayListForChild(aBuilder, kid, aDirtyRect, aLists,
                                   DISPLAY_CHILD_FORCE_PSEUDO_STACKING_CONTEXT);
     NS_ENSURE_SUCCESS(rv, rv);
   }
@@ -601,11 +526,11 @@ CanvasFrame::GetPrefWidth(nsIRenderingCo
     result = mFrames.FirstChild()->GetPrefWidth(aRenderingContext);
   return result;
 }
 
 NS_IMETHODIMP
-CanvasFrame::Reflow(nsPresContext*           aPresContext,
+CanvasFrame::Reflow(nsPresContext*          aPresContext,
                     nsHTMLReflowMetrics&     aDesiredSize,
                     const nsHTMLReflowState& aReflowState,
                     nsReflowStatus&          aStatus)
 {
   DO_GLOBAL_REFLOW_COUNT("CanvasFrame");
@@ -613,88 +538,41 @@ CanvasFrame::Reflow(nsPresContext*      
   NS_FRAME_TRACE_REFLOW_IN("CanvasFrame::Reflow");
 
   // Initialize OUT parameter
   aStatus = NS_FRAME_COMPLETE;
 
-  CanvasFrame* prevCanvasFrame = static_cast<CanvasFrame*>
-                                               (GetPrevInFlow());
-  if (prevCanvasFrame) {
-    nsIFrame* overflow = prevCanvasFrame->GetOverflowFrames(aPresContext, PR_TRUE);
-    if (overflow) {
-      NS_ASSERTION(!overflow->GetNextSibling(),
-                   "must have doc root as canvas frame's only child");
-      nsHTMLContainerFrame::ReparentFrameView(aPresContext, overflow, prevCanvasFrame, this);
-      // Prepend overflow to the our child list. There may already be
-      // children placeholders for fixed-pos elements, which don't get
-      // reflowed but must not be lost until the canvas frame is destroyed.
-      mFrames.InsertFrames(this, nsnull, overflow);
-    }
-  }
-
-  // Reflow our one and only normal child frame. It's either the root
-  // element's frame or a placeholder for that frame, if the root element
-  // is abs-pos or fixed-pos. We may have additional children which
-  // are placeholders for continuations of fixed-pos content, but those
-  // don't need to be reflowed. The normal child is always comes before
-  // the fixed-pos placeholders, because we insert it at the start
-  // of the child list, above.
+  // Reflow our one and only child frame
   nsHTMLReflowMetrics kidDesiredSize;
   if (mFrames.IsEmpty()) {
     // We have no child frame, so return an empty size
     aDesiredSize.width = aDesiredSize.height = 0;
   } else {
     nsIFrame* kidFrame = mFrames.FirstChild();
     PRBool kidDirty = (kidFrame->GetStateBits() & NS_FRAME_IS_DIRTY) != 0;
 
+    // We must specify an unconstrained available height, because constrained
+    // is only for when we're paginated...
     nsHTMLReflowState kidReflowState(aPresContext, aReflowState, kidFrame,
                                      nsSize(aReflowState.availableWidth,
-                                            aReflowState.availableHeight));
+                                            NS_UNCONSTRAINEDSIZE));
 
     if (aReflowState.mFlags.mVResize &&
         (kidFrame->GetStateBits() & NS_FRAME_CONTAINS_RELATIVE_HEIGHT)) {
       // Tell our kid it's being vertically resized too.  Bit of a
       // hack for framesets.
       kidReflowState.mFlags.mVResize = PR_TRUE;
     }
-
-    nsPoint kidPt(kidReflowState.mComputedMargin.left,
-                  kidReflowState.mComputedMargin.top);
-    // Apply CSS relative positioning
-    const nsStyleDisplay* styleDisp = kidFrame->GetStyleDisplay();
-    if (NS_STYLE_POSITION_RELATIVE == styleDisp->mPosition) {
-      kidPt += nsPoint(kidReflowState.mComputedOffsets.left,
-                       kidReflowState.mComputedOffsets.top);
-    }
-
+    
     // Reflow the frame
     ReflowChild(kidFrame, aPresContext, kidDesiredSize, kidReflowState,
-                kidPt.x, kidPt.y, 0, aStatus);
+                kidReflowState.mComputedMargin.left, kidReflowState.mComputedMargin.top,
+                0, aStatus);
 
     // Complete the reflow and position and size the child frame
     FinishReflowChild(kidFrame, aPresContext, &kidReflowState, kidDesiredSize,
-                      kidPt.x, kidPt.y, 0);
-
-    if (!NS_FRAME_IS_FULLY_COMPLETE(aStatus)) {
-      nsIFrame* nextFrame = kidFrame->GetNextInFlow();
-      NS_ASSERTION(nextFrame || aStatus & NS_FRAME_REFLOW_NEXTINFLOW,
-        "If it's incomplete and has no nif yet, it must flag a nif reflow.");
-      if (!nextFrame) {
-        nsresult rv = nsHTMLContainerFrame::CreateNextInFlow(aPresContext,
-                                              this, kidFrame, nextFrame);
-        NS_ENSURE_SUCCESS(rv, rv);
-        kidFrame->SetNextSibling(nextFrame->GetNextSibling());
-        nextFrame->SetNextSibling(nsnull);
-        SetOverflowFrames(aPresContext, nextFrame);
-        // Root overflow containers will be normal children of
-        // the canvas frame, but that's ok because there
-        // aren't any other frames we need to isolate them from
-        // during reflow.
-      }
-      if (NS_FRAME_OVERFLOW_IS_INCOMPLETE(aStatus)) {
-        nextFrame->AddStateBits(NS_FRAME_IS_OVERFLOW_CONTAINER);
-      }
-    }
+                      kidReflowState.mComputedMargin.left,
+                      kidReflowState.mComputedMargin.top, 0);
 
     // If the child frame was just inserted, then we're responsible for making sure
     // it repaints
     if (kidDirty) {
       // But we have a new child, which will affect our background, so
@@ -706,38 +584,23 @@ CanvasFrame::Reflow(nsPresContext*      
       // could also include overflow to our top and left (out of the viewport)
       // which doesn't need to be painted.
       nsIFrame* viewport = PresContext()->GetPresShell()->GetRootFrame();
       viewport->Invalidate(nsRect(nsPoint(0, 0), viewport->GetSize()));
     }
-    
+
     // Return our desired size (which doesn't matter)
-    aDesiredSize.width = aReflowState.ComputedWidth();
-    aDesiredSize.height = aReflowState.ComputedHeight();
+    aDesiredSize.width = aReflowState.availableWidth;
+    aDesiredSize.height = kidDesiredSize.height +
+                          kidReflowState.mComputedMargin.TopBottom();
 
     aDesiredSize.mOverflowArea.UnionRect(
       nsRect(0, 0, aDesiredSize.width, aDesiredSize.height),
-      kidDesiredSize.mOverflowArea + kidPt);
-
-    if (mAbsoluteContainer.HasAbsoluteFrames()) {
-      PRBool widthChanged = aDesiredSize.width != mRect.width;
-      PRBool heightChanged = aDesiredSize.height != mRect.height;
-      nsRect absPosBounds;
-      mAbsoluteContainer.Reflow(this, aPresContext, aReflowState, aStatus,
-                                aDesiredSize.width, aDesiredSize.height,
-                                PR_TRUE, widthChanged, heightChanged,
-                                &absPosBounds);
-      aDesiredSize.mOverflowArea.UnionRect(aDesiredSize.mOverflowArea, absPosBounds);
-    }
+      kidDesiredSize.mOverflowArea +
+        nsPoint(kidReflowState.mComputedMargin.left,
+                kidReflowState.mComputedMargin.top));
+    FinishAndStoreOverflow(&aDesiredSize);
   }
-
-  if (prevCanvasFrame) {
-    ReflowOverflowContainerChildren(aPresContext, aReflowState,
-                                    aDesiredSize.mOverflowArea, 0,
-                                    aStatus);
-  }
-
-  FinishAndStoreOverflow(&aDesiredSize);
 
   NS_FRAME_TRACE_REFLOW_OUT("CanvasFrame::Reflow", aStatus);
   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aDesiredSize);
   return NS_OK;
 }
diff -r 14ce7619e9c1 layout/generic/nsHTMLParts.h
--- a/layout/generic/nsHTMLParts.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/generic/nsHTMLParts.h	Mon Sep 08 10:35:46 2008 +0300
@@ -111,28 +111,35 @@ inline nsIFrame*
 inline nsIFrame*
 NS_NewTableCellInnerFrame(nsIPresShell* aPresShell, nsStyleContext* aContext) {
   return NS_NewBlockFrame(aPresShell, aContext);
 }
 
-// This type of BlockFrame is a margin root, but does not shrink wrap
+// This type of AreaFrame is the document root, a margin root, and the
+// initial containing block for absolutely positioned elements
+inline nsIFrame*
+NS_NewDocumentElementFrame(nsIPresShell* aPresShell, nsStyleContext* aContext) {
+  return NS_NewAreaFrame(aPresShell, aContext, NS_BLOCK_SPACE_MGR|NS_BLOCK_MARGIN_ROOT);
+}
+
+// This type of AreaFrame is a margin root, but does not shrink wrap
 inline nsIFrame*
 NS_NewAbsoluteItemWrapperFrame(nsIPresShell* aPresShell, nsStyleContext* aContext) {
-  return NS_NewBlockFrame(aPresShell, aContext, NS_BLOCK_SPACE_MGR|NS_BLOCK_MARGIN_ROOT);
+  return NS_NewAreaFrame(aPresShell, aContext, NS_BLOCK_SPACE_MGR|NS_BLOCK_MARGIN_ROOT);
 }
 
-// This type of BlockFrame shrink wraps
+// This type of AreaFrame shrink wraps
 inline nsIFrame*
 NS_NewFloatingItemWrapperFrame(nsIPresShell* aPresShell, nsStyleContext* aContext) {
-  return NS_NewBlockFrame(aPresShell, aContext,
+  return NS_NewAreaFrame(aPresShell, aContext,
     NS_BLOCK_SPACE_MGR|NS_BLOCK_MARGIN_ROOT);
 }
 
-// This type of BlockFrame doesn't use its own space manager and
+// This type of AreaFrame doesn't use its own space manager and
 // doesn't shrink wrap.
 inline nsIFrame*
 NS_NewRelativeItemWrapperFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, PRUint32 aFlags) {
-  return NS_NewBlockFrame(aPresShell, aContext, aFlags);
+  return NS_NewAreaFrame(aPresShell, aContext, aFlags);
 }
 
 nsIFrame*
 NS_NewBRFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
 
diff -r 14ce7619e9c1 layout/generic/nsHTMLReflowState.cpp
--- a/layout/generic/nsHTMLReflowState.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/generic/nsHTMLReflowState.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -1529,11 +1529,29 @@ nsHTMLReflowState::ComputeContainingBloc
                    "Negative containing block height!");
     } else {
       // If the ancestor is block-level, the containing block is formed by the
       // padding edge of the ancestor
       aContainingBlockWidth += aContainingBlockRS->mComputedPadding.LeftRight();
-      aContainingBlockHeight += aContainingBlockRS->mComputedPadding.TopBottom();
+
+      // If the containing block is the initial containing block and it has a
+      // height that depends on its content, then use the viewport height instead.
+      // This gives us a reasonable value against which to compute percentage
+      // based heights and to do bottom relative positioning
+      if ((NS_AUTOHEIGHT == aContainingBlockHeight) &&
+          nsLayoutUtils::IsInitialContainingBlock(aContainingBlockRS->frame)) {
+
+        // Use the viewport height as the containing block height
+        const nsHTMLReflowState* rs = aContainingBlockRS->parentReflowState;
+        while (rs) {
+          aContainingBlockHeight = rs->mComputedHeight;
+          rs = rs->parentReflowState;
+        }
+
+      } else {
+        aContainingBlockHeight +=
+          aContainingBlockRS->mComputedPadding.TopBottom();
+      }
     }
   } else {
     // an element in quirks mode gets a containing block based on looking for a
     // parent with a non-auto height if the element has a percent height
     if (NS_AUTOHEIGHT == aContainingBlockHeight) {
diff -r 14ce7619e9c1 layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/generic/nsIFrame.h	Mon Sep 08 10:35:46 2008 +0300
@@ -1722,15 +1722,17 @@ public:
    *  to redraw event if aSelected == the frame selection with the last parameter.
    *  data in struct may be changed when passed in.
    *  @param aRange is the range that will dictate if the frames need to be redrawn null means the whole content needs to be redrawn
    *  @param aSelected is it selected?
    *  @param aSpread should it spread the selection to flow elements around it? or go down to its children?
+   *  @param aType the selection type of the selection that you are setting on the frame
    */
   NS_IMETHOD  SetSelected(nsPresContext* aPresContext,
                           nsIDOMRange*    aRange,
                           PRBool          aSelected,
-                          nsSpread        aSpread) = 0;
+                          nsSpread        aSpread,
+                          SelectionType   aType) = 0;
 
   NS_IMETHOD  GetSelected(PRBool *aSelected) const = 0;
 
   /**
    *  called to discover where this frame, or a parent frame has user-select style
diff -r 14ce7619e9c1 layout/generic/nsImageMap.cpp
--- a/layout/generic/nsImageMap.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/generic/nsImageMap.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -159,169 +159,165 @@ static void logMessage(nsIContent*      
      0, /* column number */
      aFlags,
      "ImageMap");
 }
 
-// XXX straight copy from laymap.c
-static nscoord* lo_parse_coord_list(char *str, PRInt32* value_cnt)
-{
-  char *tptr;
-  char *n_str;
-  PRInt32 i, cnt;
-  PRInt32 *value_list;
-
-  /*
-   * Nothing in an empty list
-   */
-  *value_cnt = 0;
-  if (!str || *str == '\0')
-  {
-    return nsnull;
-  }
-
-  /*
-   * Skip beginning whitespace, all whitespace is empty list.
-   */
-  n_str = str;
-  while (is_space(*n_str))
-  {
-    n_str++;
-  }
-  if (*n_str == '\0')
-  {
-    return nsnull;
-  }
-
-  /*
-   * Make a pass where any two numbers separated by just whitespace
-   * are given a comma separator.  Count entries while passing.
-   */
-  cnt = 0;
-  while (*n_str != '\0')
-  {
-    PRBool has_comma;
-
-    /*
-     * Skip to a separator
-     */
-    tptr = n_str;
-    while (!is_space(*tptr) && *tptr != ',' && *tptr != '\0')
-    {
-      tptr++;
-    }
-    n_str = tptr;
-
-    /*
-     * If no more entries, break out here
-     */
-    if (*n_str == '\0')
-    {
-      break;
-    }
-
-    /*
-     * Skip to the end of the separator, noting if we have a
-     * comma.
-     */
-    has_comma = PR_FALSE;
-    while (is_space(*tptr) || *tptr == ',')
-    {
-      if (*tptr == ',')
-      {
-        if (has_comma == PR_FALSE)
-        {
-          has_comma = PR_TRUE;
-        }
-        else
-        {
-          break;
-        }
-      }
-      tptr++;
-    }
-    /*
-     * If this was trailing whitespace we skipped, we are done.
-     */
-    if ((*tptr == '\0')&&(has_comma == PR_FALSE))
-    {
-      break;
-    }
-    /*
-     * Else if the separator is all whitespace, and this is not the
-     * end of the string, add a comma to the separator.
-     */
-    else if (has_comma == PR_FALSE)
-    {
-      *n_str = ',';
-    }
-
-    /*
-     * count the entry skipped.
-     */
-    cnt++;
-
-    n_str = tptr;
-  }
-  /*
-   * count the last entry in the list.
-   */
-  cnt++;
- 
-  /*
-   * Allocate space for the coordinate array.
-   */
-  value_list = new nscoord[cnt];
-  if (!value_list)
-  {
-    return nsnull;
-  }
-
-  /*
-   * Second pass to copy integer values into list.
-   */
-  tptr = str;
-  for (i=0; i<cnt; i++)
-  {
-    char *ptr;
-
-    ptr = strchr(tptr, ',');
-    if (ptr)
-    {
-      *ptr = '\0';
-    }
-    /*
-     * Strip whitespace in front of number because I don't
-     * trust atoi to do it on all platforms.
-     */
-    while (is_space(*tptr))
-    {
-      tptr++;
-    }
-    if (*tptr == '\0')
-    {
-      value_list[i] = 0;
-    }
-    else
-    {
-      value_list[i] = (nscoord) ::atoi(tptr);
-    }
-    if (ptr)
-    {
-      *ptr = ',';
-      tptr = ptr + 1;
-    }
-  }
-
-  *value_cnt = cnt;
-  return value_list;
-}
-
 void Area::ParseCoords(const nsAString& aSpec)
 {
   char* cp = ToNewCString(aSpec);
   if (cp) {
-    mCoords = lo_parse_coord_list(cp, &mNumCoords);
+    char *tptr;
+    char *n_str;
+    PRInt32 i, cnt;
+    PRInt32 *value_list;
+
+    /*
+     * Nothing in an empty list
+     */
+    mNumCoords = 0;
+    mCoords = nsnull;
+    if (*cp == '\0')
+    {
+      return;
+    }
+
+    /*
+     * Skip beginning whitespace, all whitespace is empty list.
+     */
+    n_str = cp;
+    while (is_space(*n_str))
+    {
+      n_str++;
+    }
+    if (*n_str == '\0')
+    {
+      return;
+    }
+
+    /*
+     * Make a pass where any two numbers separated by just whitespace
+     * are given a comma separator.  Count entries while passing.
+     */
+    cnt = 0;
+    while (*n_str != '\0')
+    {
+      PRBool has_comma;
+
+      /*
+       * Skip to a separator
+       */
+      tptr = n_str;
+      while (!is_space(*tptr) && *tptr != ',' && *tptr != '\0')
+      {
+        tptr++;
+      }
+      n_str = tptr;
+
+      /*
+       * If no more entries, break out here
+       */
+      if (*n_str == '\0')
+      {
+        break;
+      }
+
+      /*
+       * Skip to the end of the separator, noting if we have a
+       * comma.
+       */
+      has_comma = PR_FALSE;
+      while (is_space(*tptr) || *tptr == ',')
+      {
+        if (*tptr == ',')
+        {
+          if (has_comma == PR_FALSE)
+          {
+            has_comma = PR_TRUE;
+          }
+          else
+          {
+            break;
+          }
+        }
+        tptr++;
+      }
+      /*
+       * If this was trailing whitespace we skipped, we are done.
+       */
+      if ((*tptr == '\0')&&(has_comma == PR_FALSE))
+      {
+        break;
+      }
+      /*
+       * Else if the separator is all whitespace, and this is not the
+       * end of the string, add a comma to the separator.
+       */
+      else if (has_comma == PR_FALSE)
+      {
+        *n_str = ',';
+      }
+
+      /*
+       * count the entry skipped.
+       */
+      cnt++;
+
+      n_str = tptr;
+    }
+    /*
+     * count the last entry in the list.
+     */
+    cnt++;
+ 
+    /*
+     * Allocate space for the coordinate array.
+     */
+    value_list = new nscoord[cnt];
+    if (!value_list)
+    {
+      return;
+    }
+
+    /*
+     * Second pass to copy integer values into list.
+     */
+    tptr = cp;
+    for (i=0; i<cnt; i++)
+    {
+      char *ptr;
+
+      ptr = strchr(tptr, ',');
+      if (ptr)
+      {
+        *ptr = '\0';
+      }
+      /*
+       * Strip whitespace in front of number because I don't
+       * trust atoi to do it on all platforms.
+       */
+      while (is_space(*tptr))
+      {
+        tptr++;
+      }
+      if (*tptr == '\0')
+      {
+        value_list[i] = 0;
+      }
+      else
+      {
+        value_list[i] = (nscoord) ::atoi(tptr);
+      }
+      if (ptr)
+      {
+        *ptr = ',';
+        tptr = ptr + 1;
+      }
+    }
+
+    mNumCoords = cnt;
+    mCoords = value_list;
+  
     NS_Free(cp);
   }
 }
 
 void Area::HasFocus(PRBool aHasFocus)
diff -r 14ce7619e9c1 layout/generic/nsInlineFrame.cpp
--- a/layout/generic/nsInlineFrame.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/generic/nsInlineFrame.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -1071,12 +1071,15 @@ nsPositionedInlineFrame::GetAdditionalCh
 }
 
 nsIFrame*
 nsPositionedInlineFrame::GetFirstChild(nsIAtom* aListName) const
 {
-  if (nsGkAtoms::absoluteList == aListName)
-    return mAbsoluteContainer.GetFirstChild();
+  if (nsGkAtoms::absoluteList == aListName) {
+    nsIFrame* result = nsnull;
+    mAbsoluteContainer.FirstChild(this, aListName, &result);
+    return result;
+  }
 
   return nsInlineFrame::GetFirstChild(aListName);
 }
 
 nsIAtom*
diff -r 14ce7619e9c1 layout/generic/nsObjectFrame.cpp
--- a/layout/generic/nsObjectFrame.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/generic/nsObjectFrame.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -1167,11 +1167,10 @@ nsObjectFrame::PrintPlugin(nsIRenderingC
   nsCOMPtr<nsIPluginInstance> pi;
   if (NS_FAILED(objectFrame->GetPluginInstance(*getter_AddRefs(pi))) || !pi)
     return;
 
   // now we need to setup the correct location for printing
-  nsresult rv;
   nsPluginWindow    window;
   window.window =   nsnull;
 
   // prepare embedded mode printing struct
   nsPluginPrint npprint;
@@ -1216,11 +1215,11 @@ nsObjectFrame::PrintPlugin(nsIRenderingC
   window.x =   aDirtyRect.x;
   window.y =   aDirtyRect.y;
   window.width =   aDirtyRect.width;
   window.height =   aDirtyRect.height;
   npprint.print.embedPrint.window        = window;
-  rv = pi->Print(&npprint);
+  nsresult rv = pi->Print(&npprint);
   if (NS_FAILED(rv)) {
     PR_LOG(nsObjectFrameLM, PR_LOG_DEBUG, ("error: plugin returned failure %lx\n", (long)rv));
     fclose(plugintmpfile);
     return;
   }
@@ -1239,11 +1238,11 @@ nsObjectFrame::PrintPlugin(nsIRenderingC
     return;
 
   npprint.print.embedPrint.platformPrint = hps;
   npprint.print.embedPrint.window = window;
   // send off print info to plugin
-  rv = pi->Print(&npprint);
+  pi->Print(&npprint);
 #elif defined(XP_WIN)
 
   /* On Windows, we use the win32 printing surface to print.  This, in
    * turn, uses the Cairo paginated surface, which in turn uses the
    * meta surface to record all operations and then play them back.
@@ -1293,11 +1292,11 @@ nsObjectFrame::PrintPlugin(nsIRenderingC
       return;
 
     npprint.print.embedPrint.platformPrint = dc;
     npprint.print.embedPrint.window = window;
     // send off print info to plugin
-    rv = pi->Print(&npprint);
+    pi->Print(&npprint);
 
     nativeDraw.EndNativeDrawing();
   } while (nativeDraw.ShouldRenderAgain());
   nativeDraw.PaintToContext();
 
@@ -1330,11 +1329,11 @@ nsObjectFrame::PrintPlugin(nsIRenderingC
     return; // no dc implemented so quit
 
   npprint.print.embedPrint.platformPrint = dc;
   npprint.print.embedPrint.window = window;
   // send off print info to plugin
-    rv = pi->Print(&npprint);
+  pi->Print(&npprint);
 #endif
 
   // XXX Nav 4.x always sent a SetWindow call after print. Should we do the same?
   nsDidReflowStatus status = NS_FRAME_REFLOW_FINISHED; // should we use a special status?
   frame->DidReflow(presContext,
diff -r 14ce7619e9c1 layout/generic/nsPageContentFrame.cpp
--- a/layout/generic/nsPageContentFrame.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/generic/nsPageContentFrame.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -67,10 +67,59 @@ nsPageContentFrame::ComputeSize(nsIRende
                    ? NS_UNCONSTRAINEDSIZE
                    : (mPD->mReflowSize.height - mPD->mReflowMargin.TopBottom());
   return nsSize(aAvailableWidth, height);
 }
 
+/**
+ * Returns true if aFrame is a placeholder for one of our fixed frames.
+ */
+inline PRBool
+nsPageContentFrame::IsFixedPlaceholder(nsIFrame* aFrame)
+{
+  if (!aFrame || nsGkAtoms::placeholderFrame != aFrame->GetType())
+    return PR_FALSE;
+
+  return static_cast<nsPlaceholderFrame*>(aFrame)->GetOutOfFlowFrame()
+           ->GetParent() == this;
+}
+
+/**
+ * Steals replicated fixed placeholder frames from aDocRoot so they don't
+ * get in the way of reflow.
+ */
+inline nsFrameList
+nsPageContentFrame::StealFixedPlaceholders(nsIFrame* aDocRoot)
+{
+  nsPresContext* presContext = PresContext();
+  nsFrameList list;
+  if (GetPrevInFlow()) {
+    for (nsIFrame* f = aDocRoot->GetFirstChild(nsnull);
+        IsFixedPlaceholder(f); f = aDocRoot->GetFirstChild(nsnull)) {
+      nsresult rv = static_cast<nsContainerFrame*>(aDocRoot)
+                      ->StealFrame(presContext, f);
+      NS_ENSURE_SUCCESS(rv, list);
+      list.AppendFrame(nsnull, f);
+    }
+  }
+  return list;
+}
+
+/**
+ * Restores stolen replicated fixed placeholder frames to aDocRoot.
+ */
+static inline nsresult
+ReplaceFixedPlaceholders(nsIFrame*    aDocRoot,
+                         nsFrameList& aPlaceholderList)
+{
+  nsresult rv = NS_OK;
+  if (aPlaceholderList.NotEmpty()) {
+    rv = static_cast<nsContainerFrame*>(aDocRoot)
+           ->AddFrames(aPlaceholderList.FirstChild(), nsnull);
+  }
+  return rv;
+}
+
 NS_IMETHODIMP
 nsPageContentFrame::Reflow(nsPresContext*           aPresContext,
                            nsHTMLReflowMetrics&     aDesiredSize,
                            const nsHTMLReflowState& aReflowState,
                            nsReflowStatus&          aStatus)
@@ -78,30 +127,70 @@ nsPageContentFrame::Reflow(nsPresContext
   DO_GLOBAL_REFLOW_COUNT("nsPageContentFrame");
   DISPLAY_REFLOW(aPresContext, this, aReflowState, aDesiredSize, aStatus);
   aStatus = NS_FRAME_COMPLETE;  // initialize out parameter
   nsresult rv = NS_OK;
 
-  if (GetPrevInFlow() && (GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
+  // A PageContentFrame must always have one child: the doc root element's frame.
+  // We only need to get overflow frames if we don't already have that child;
+  // Also we need to avoid repeating the call to ReplicateFixedFrames.
+  nsPageContentFrame* prevPageContentFrame = static_cast<nsPageContentFrame*>
+                                               (GetPrevInFlow());
+  if (mFrames.IsEmpty() && prevPageContentFrame) {
+    // Pull the doc root frame's continuation and copy fixed frames.
+    nsIFrame* overflow = prevPageContentFrame->GetOverflowFrames(aPresContext, PR_TRUE);
+    NS_ASSERTION(overflow && !overflow->GetNextSibling(),
+                 "must have doc root as pageContentFrame's only child");
+    nsHTMLContainerFrame::ReparentFrameView(aPresContext, overflow, prevPageContentFrame, this);
+    // Prepend overflow to the page content frame. There may already be
+    // children placeholders which don't get reflowed but must not be
+    // lost until the page content frame is destroyed.
+    mFrames.InsertFrames(this, nsnull, overflow);
     nsresult rv = aPresContext->PresShell()->FrameConstructor()
                     ->ReplicateFixedFrames(this);
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
-  // A PageContentFrame must always have one child: the canvas frame.
   // Resize our frame allowing it only to be as big as we are
   // XXX Pay attention to the page's border and padding...
   if (mFrames.NotEmpty()) {
     nsIFrame* frame = mFrames.FirstChild();
     nsSize  maxSize(aReflowState.availableWidth, aReflowState.availableHeight);
     nsHTMLReflowState kidReflowState(aPresContext, aReflowState, frame, maxSize);
-    kidReflowState.SetComputedHeight(aReflowState.availableHeight);
 
     mPD->mPageContentSize  = aReflowState.availableWidth;
+
+    // Get replicated fixed frames' placeholders out of the way
+    nsFrameList stolenPlaceholders = StealFixedPlaceholders(frame);
 
     // Reflow the page content area
     rv = ReflowChild(frame, aPresContext, aDesiredSize, kidReflowState, 0, 0, 0, aStatus);
     NS_ENSURE_SUCCESS(rv, rv);
+
+    // Put removed fixed placeholders back
+    rv = ReplaceFixedPlaceholders(frame, stolenPlaceholders);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    if (!NS_FRAME_IS_FULLY_COMPLETE(aStatus)) {
+      nsIFrame* nextFrame = frame->GetNextInFlow();
+      NS_ASSERTION(nextFrame || aStatus & NS_FRAME_REFLOW_NEXTINFLOW,
+        "If it's incomplete and has no nif yet, it must flag a nif reflow.");
+      if (!nextFrame) {
+        nsresult rv = nsHTMLContainerFrame::CreateNextInFlow(aPresContext,
+                                              this, frame, nextFrame);
+        NS_ENSURE_SUCCESS(rv, rv);
+        frame->SetNextSibling(nextFrame->GetNextSibling());
+        nextFrame->SetNextSibling(nsnull);
+        SetOverflowFrames(aPresContext, nextFrame);
+        // Root overflow containers will be normal children of
+        // the pageContentFrame, but that's ok because there
+        // aren't any other frames we need to isolate them from
+        // during reflow.
+      }
+      if (NS_FRAME_OVERFLOW_IS_INCOMPLETE(aStatus)) {
+        nextFrame->AddStateBits(NS_FRAME_IS_OVERFLOW_CONTAINER);
+      }
+    }
 
     // The document element's background should cover the entire canvas, so
     // take into account the combined area and any space taken up by
     // absolutely positioned elements
     nsMargin padding(0,0,0,0);
diff -r 14ce7619e9c1 layout/generic/nsPageContentFrame.h
--- a/layout/generic/nsPageContentFrame.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/generic/nsPageContentFrame.h	Mon Sep 08 10:35:46 2008 +0300
@@ -81,9 +81,13 @@ public:
 
 protected:
   nsPageContentFrame(nsStyleContext* aContext) : ViewportFrame(aContext) {}
 
   nsSharedPageData*         mPD;
+
+private:
+  PRBool IsFixedPlaceholder(nsIFrame* aFrame);
+  nsFrameList StealFixedPlaceholders(nsIFrame* aDocRoot);
 };
 
 #endif /* nsPageContentFrame_h___ */
 
diff -r 14ce7619e9c1 layout/generic/nsSelection.cpp
--- a/layout/generic/nsSelection.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/generic/nsSelection.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -5057,11 +5057,11 @@ nsTypedSelection::selectFrames(nsPresCon
     // First select frame of content passed in
     frame = mFrameSelection->GetShell()->GetPrimaryFrameFor(aContent);
     if (frame)
     {
       //NOTE: eSpreadDown is now IGNORED. Selected state is set only for given frame
-      frame->SetSelected(aPresContext, nsnull, aFlags, eSpreadDown);
+      frame->SetSelected(aPresContext, nsnull, aFlags, eSpreadDown, mType);
 #ifndef OLD_TABLE_SELECTION
       if (mFrameSelection->GetTableCellSelection())
       {
         nsITableCellLayout *tcl = nsnull;
         CallQueryInterface(frame, &tcl);
@@ -5082,11 +5082,11 @@ nsTypedSelection::selectFrames(nsPresCon
       {
         //NOTE: eSpreadDown is now IGNORED. Selected state is set only
         //for given frame
 
         //spread from here to hit all frames in flow
-        frame->SetSelected(aPresContext, nsnull,aFlags,eSpreadDown);
+        frame->SetSelected(aPresContext, nsnull, aFlags, eSpreadDown, mType);
         nsRect frameRect = frame->GetRect();
 
         //if a rect is 0 height/width then try to notify next
         //available in flow of selection status.
         while (!frameRect.width || !frameRect.height)
@@ -5094,11 +5094,11 @@ nsTypedSelection::selectFrames(nsPresCon
           //try to notify next in flow that its content is selected.
           frame = frame->GetNextInFlow();
           if (frame)
           {
             frameRect = frame->GetRect();
-            frame->SetSelected(aPresContext, nsnull,aFlags,eSpreadDown);
+            frame->SetSelected(aPresContext, nsnull, aFlags, eSpreadDown, mType);
           }
           else
             break;
         }
         //if the frame is splittable and this frame is 0,0 then set
@@ -5160,11 +5160,11 @@ nsTypedSelection::selectFrames(nsPresCon
 
     if (!content->IsNodeOfType(nsINode::eELEMENT))
     {
       frame = mFrameSelection->GetShell()->GetPrimaryFrameFor(content);
       if (frame)
-        frame->SetSelected(aPresContext, aRange,aFlags,eSpreadDown);//spread from here to hit all frames in flow
+        frame->SetSelected(aPresContext, aRange, aFlags, eSpreadDown, mType);//spread from here to hit all frames in flow
     }
 //end start content
     iter->First();
 
     while (!iter->IsDone())
@@ -5184,11 +5184,11 @@ nsTypedSelection::selectFrames(nsPresCon
 
       if (!content->IsNodeOfType(nsINode::eELEMENT))
       {
         frame = mFrameSelection->GetShell()->GetPrimaryFrameFor(content);
         if (frame)
-           frame->SetSelected(aPresContext, aRange,aFlags,eSpreadDown);//spread from here to hit all frames in flow
+           frame->SetSelected(aPresContext, aRange, aFlags, eSpreadDown, mType);//spread from here to hit all frames in flow
       }
     }
 //end end parent
   }
   return result;
diff -r 14ce7619e9c1 layout/generic/nsTextFrame.h
--- a/layout/generic/nsTextFrame.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/generic/nsTextFrame.h	Mon Sep 08 10:35:46 2008 +0300
@@ -151,11 +151,12 @@ public:
   virtual ContentOffsets CalcContentOffsetsFromFramePoint(nsPoint aPoint);
    
   NS_IMETHOD SetSelected(nsPresContext* aPresContext,
                          nsIDOMRange *aRange,
                          PRBool aSelected,
-                         nsSpread aSpread);
+                         nsSpread aSpread,
+                         SelectionType aType);
   
   virtual PRBool PeekOffsetNoAmount(PRBool aForward, PRInt32* aOffset);
   virtual PRBool PeekOffsetCharacter(PRBool aForward, PRInt32* aOffset);
   virtual PRBool PeekOffsetWord(PRBool aForward, PRBool aWordSelectEatSpace, PRBool aIsKeyboardSelect,
                                 PRInt32* aOffset, PeekWordState* aState);
diff -r 14ce7619e9c1 layout/generic/nsTextFrameThebes.cpp
--- a/layout/generic/nsTextFrameThebes.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/generic/nsTextFrameThebes.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -4610,26 +4610,29 @@ nsTextFrame::HasSelectionOverflowingDeco
 //null range means the whole thing
 NS_IMETHODIMP
 nsTextFrame::SetSelected(nsPresContext* aPresContext,
                          nsIDOMRange *aRange,
                          PRBool aSelected,
-                         nsSpread aSpread)
+                         nsSpread aSpread,
+                         SelectionType aType)
 {
   DEBUG_VERIFY_NOT_DIRTY(mState);
 #if 0 //XXXrbs disable due to bug 310318
   if (mState & NS_FRAME_IS_DIRTY)
     return NS_ERROR_UNEXPECTED;
 #endif
 
   if (aSelected && ParentDisablesSelection())
     return NS_OK;
 
-  // check whether style allows selection
-  PRBool selectable;
-  IsSelectable(&selectable, nsnull);
-  if (!selectable)
-    return NS_OK;//do not continue no selection for this frame.
+  if (aType == nsISelectionController::SELECTION_NORMAL) {
+    // check whether style allows selection
+    PRBool selectable;
+    IsSelectable(&selectable, nsnull);
+    if (!selectable)
+      return NS_OK;//do not continue no selection for this frame.
+  }
 
   PRBool found = PR_FALSE;
   if (aRange) {
     //lets see if the range contains us, if so we must redraw!
     nsCOMPtr<nsIDOMNode> endNode;
@@ -4705,16 +4708,16 @@ nsTextFrame::SetSelected(nsPresContext* 
   }
   if (aSpread == eSpreadDown)
   {
     nsIFrame* frame = GetPrevContinuation();
     while(frame){
-      frame->SetSelected(aPresContext, aRange,aSelected,eSpreadNone);
+      frame->SetSelected(aPresContext, aRange,aSelected,eSpreadNone, aType);
       frame = frame->GetPrevContinuation();
     }
     frame = GetNextContinuation();
     while (frame){
-      frame->SetSelected(aPresContext, aRange,aSelected,eSpreadNone);
+      frame->SetSelected(aPresContext, aRange,aSelected,eSpreadNone, aType);
       frame = frame->GetNextContinuation();
     }
   }
   return NS_OK;
 }
diff -r 14ce7619e9c1 layout/generic/nsViewportFrame.cpp
--- a/layout/generic/nsViewportFrame.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/generic/nsViewportFrame.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -177,12 +177,15 @@ ViewportFrame::GetAdditionalChildListNam
 }
 
 nsIFrame*
 ViewportFrame::GetFirstChild(nsIAtom* aListName) const
 {
-  if (nsGkAtoms::fixedList == aListName)
-    return mFixedContainer.GetFirstChild();
+  if (nsGkAtoms::fixedList == aListName) {
+    nsIFrame* result = nsnull;
+    mFixedContainer.FirstChild(this, aListName, &result);
+    return result;
+  }
 
   return nsContainerFrame::GetFirstChild(aListName);
 }
 
 /* virtual */ nscoord
@@ -304,11 +307,12 @@ ViewportFrame::Reflow(nsPresContext*    
   // to reflect the available space for the fixed items
   nsHTMLReflowState reflowState(aReflowState);
   nsPoint offset = AdjustReflowStateForScrollbars(&reflowState);
   
 #ifdef DEBUG
-  nsIFrame* f = mFixedContainer.GetFirstChild();
+  nsIFrame* f;
+  mFixedContainer.FirstChild(this, nsGkAtoms::fixedList, &f);
   NS_ASSERTION(!f || (offset.x == 0 && offset.y == 0),
                "We don't handle correct positioning of fixed frames with "
                "scrollbars in odd positions");
 #endif
 
diff -r 14ce7619e9c1 layout/reftests/bugs/reftest.list
--- a/layout/reftests/bugs/reftest.list	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/reftests/bugs/reftest.list	Mon Sep 08 10:35:46 2008 +0300
@@ -123,11 +123,10 @@ fails == 25888-3r.html 25888-3r-ref.html
 == 169749-1.html 169749-1-ref.html
 == 172073-1.html 172073-1-ref.html
 == 180085-1.html 180085-1-ref.html
 == 180085-2.html 180085-2-ref.html
 == 185388-1.html 185388-1-ref.html
-!= 200774-1.html about:blank # really a crashtest
 == 201215-1.html 201215-1-ref.html
 == 201293-1a.html 201293-1-ref.html
 == 201293-1b.html 201293-1-ref.html
 == 201293-1c.html 201293-1-ref.html
 == 201293-1d.html 201293-1-ref.html
@@ -165,31 +164,10 @@ fails == 25888-3r.html 25888-3r-ref.html
 == 235593-1.html 235593-1-ref.html
 == 236539-1.html 236539-1-ref.html
 == 240470-1.html 240470-1-ref.html
 == 243266-1.html 243266-1-ref.html
 == 243302-1.html 243302-1-ref.html
-== 243519-1.html 243519-1-ref.html
-== 243519-2.html 243519-2-ref.html
-== 243519-3.html 243519-3-ref.html
-== 243519-4a.html 243519-4-ref.html
-== 243519-4b.html 243519-4-ref.html
-== 243519-4c.html 243519-4-ref.html
-== 243519-4d.html 243519-4-ref.html
-== 243519-4e.html 243519-4-ref.html
-== 243519-4f.html 243519-4-ref.html
-== 243519-5a.html 243519-5-ref.html
-== 243519-5b.html 243519-5-ref.html
-== 243519-5c.html 243519-5-ref.html
-== 243519-5d.html 243519-5-ref.html
-== 243519-6.html 243519-6-ref.html
-== 243519-7.html 243519-7-ref.html
-== 243519-8.svg 243519-8-ref.svg
-== 243519-9a.html 243519-9-ref.html
-== 243519-9b.html 243519-9-ref.html
-== 243519-9c.html 243519-9-ref.html
-== 243519-9d.html 243519-9-ref.html
-== 243519-9e.html 243519-9-ref.html
 == 244135-1.html 244135-1-ref.html
 == 244135-2.html 244135-2-ref.html
 == 244932-1.html 244932-1-ref.html
 == 249982-1.html 249982-1-ref.html
 == 253701-1.html 253701-1-ref.html
@@ -342,11 +320,11 @@ random-if(MOZ_WIDGET_TOOLKIT=="gtk2") ==
 == 346189-1.xul 346189-1-ref.xul
 == 346774-1a.html 346774-1-ref.html
 == 346774-1b.html 346774-1-ref.html
 == 346774-1c.html 346774-1-ref.html
 == 347348-1.xhtml 347348-1-ref.xhtml
-skip-if(MOZ_WIDGET_TOOLKIT=="windows") == 347496-1.xhtml 347496-1-ref.xhtml # Bug 409150
+== 347496-1.xhtml 347496-1-ref.xhtml
 == 347912-1.html 347912-1-ref.html
 == 348049-1.xhtml 348049-1-ref.xhtml
 == 348516-1.html 348516-1-ref.html
 == 348516-2.html 348516-2-ref.html
 != 348516-2.html 348516-2-notref.html
diff -r 14ce7619e9c1 layout/style/nsCSSDataBlock.cpp
--- a/layout/style/nsCSSDataBlock.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/style/nsCSSDataBlock.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -685,11 +685,13 @@ nsCSSExpandedDataBlock::ComputeSize()
                 continue;
             nsCSSProperty iProp =
                 nsCSSProperty(iHigh * kPropertiesSetChunkSize + iLow);
             NS_ASSERTION(0 <= iProp && iProp < eCSSProperty_COUNT_no_shorthands,
                          "out of range");
+#ifdef DEBUG
             void *prop = PropertyAt(iProp);
+#endif
             PRUint32 increment = 0;
             switch (nsCSSProps::kTypeTable[iProp]) {
                 case eCSSType_Value: {
 #ifdef DEBUG
                     nsCSSValue* val = static_cast<nsCSSValue*>(prop);
diff -r 14ce7619e9c1 layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/style/nsCSSParser.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -1657,11 +1657,16 @@ PRBool CSSParserImpl::ParseMediaQueryExp
     SkipUntil(aErrorCode, ')');
     return PR_FALSE;
   }
 
   if (mToken.mSymbol == PRUnichar(')')) {
-    // All query expressions can be given without a value.
+    // Query expressions for any feature can be given without a value.
+    // However, min/max prefixes are not allowed.
+    if (expr->mRange != nsMediaExpression::eEqual) {
+      REPORT_UNEXPECTED(PEMQNoMinMaxWithoutValue);
+      return PR_FALSE;
+    }
     expr->mValue.Reset();
     return PR_TRUE;
   }
 
   PRBool rv;
@@ -1669,12 +1674,18 @@ PRBool CSSParserImpl::ParseMediaQueryExp
     case nsMediaFeature::eLength:
       rv = ParsePositiveVariant(aErrorCode, expr->mValue,
                                 VARIANT_LENGTH, nsnull);
       break;
     case nsMediaFeature::eInteger:
+    case nsMediaFeature::eBoolInteger:
       rv = ParsePositiveVariant(aErrorCode, expr->mValue,
                                 VARIANT_INTEGER, nsnull);
+      // Enforce extra restrictions for eBoolInteger
+      if (rv &&
+          feature->mValueType == nsMediaFeature::eBoolInteger &&
+          expr->mValue.GetIntValue() > 1)
+        rv = PR_FALSE;
       break;
     case nsMediaFeature::eIntRatio:
       {
         // Two integers separated by '/', with optional whitespace on
         // either side of the '/'.
diff -r 14ce7619e9c1 layout/style/nsCSSStyleSheet.cpp
--- a/layout/style/nsCSSStyleSheet.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/style/nsCSSStyleSheet.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -186,14 +186,17 @@ nsMediaExpression::Matches(nsPresContext
   if (actual.GetUnit() == eCSSUnit_Null) {
     return PR_FALSE;
   }
 
   // If the expression had no value to match, the match succeeds,
-  // unless the value is an integer 0.
+  // unless the value is an integer 0 or a zero length.
   if (required.GetUnit() == eCSSUnit_Null) {
-    return actual.GetUnit() != eCSSUnit_Integer ||
-           actual.GetIntValue() != 0;
+    if (actual.GetUnit() == eCSSUnit_Integer)
+      return actual.GetIntValue() != 0;
+    if (actual.IsLengthUnit())
+      return actual.GetFloatValue() != 0;
+    return PR_TRUE;
   }
 
   NS_ASSERTION(mFeature->mRangeType == nsMediaFeature::eMinMaxAllowed ||
                mRange == nsMediaExpression::eEqual, "yikes");
   PRInt32 cmp; // -1 (actual < required)
@@ -210,15 +213,22 @@ nsMediaExpression::Matches(nsPresContext
                                   aPresContext, required);
         cmp = DoCompare(actualCoord, requiredCoord);
       }
       break;
     case nsMediaFeature::eInteger:
+    case nsMediaFeature::eBoolInteger:
       {
         NS_ASSERTION(actual.GetUnit() == eCSSUnit_Integer,
                      "bad actual value");
         NS_ASSERTION(required.GetUnit() == eCSSUnit_Integer,
                      "bad required value");
+        NS_ASSERTION(mFeature->mValueType != nsMediaFeature::eBoolInteger ||
+                     actual.GetIntValue() == 0 || actual.GetIntValue() == 1,
+                     "bad actual bool integer value");
+        NS_ASSERTION(mFeature->mValueType != nsMediaFeature::eBoolInteger ||
+                     required.GetIntValue() == 0 || required.GetIntValue() == 1,
+                     "bad required bool integer value");
         cmp = DoCompare(actual.GetIntValue(), required.GetIntValue());
       }
       break;
     case nsMediaFeature::eIntRatio:
       {
@@ -390,10 +400,11 @@ nsMediaQuery::AppendToString(nsAString& 
           // written in the normal way.
           nsCSSDeclaration::AppendCSSValueToString(eCSSProperty_width,
                                                    expr.mValue, aString);
           break;
         case nsMediaFeature::eInteger:
+        case nsMediaFeature::eBoolInteger:
           NS_ASSERTION(expr.mValue.GetUnit() == eCSSUnit_Integer,
                        "bad unit");
           // Use 'z-index' as a property that takes integer values
           // written without anything extra.
           nsCSSDeclaration::AppendCSSValueToString(eCSSProperty_z_index,
diff -r 14ce7619e9c1 layout/style/nsMediaFeatures.cpp
--- a/layout/style/nsMediaFeatures.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/style/nsMediaFeatures.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -334,11 +334,11 @@ nsMediaFeatures::features[] = {
         GetScan
     },
     {
         &nsGkAtoms::grid,
         nsMediaFeature::eMinMaxNotAllowed,
-        nsMediaFeature::eInteger,
+        nsMediaFeature::eBoolInteger,
         nsnull,
         GetGrid
     },
     // Null-mName terminator:
     {
diff -r 14ce7619e9c1 layout/style/nsMediaFeatures.h
--- a/layout/style/nsMediaFeatures.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/style/nsMediaFeatures.h	Mon Sep 08 10:35:46 2008 +0300
@@ -59,10 +59,11 @@ struct nsMediaFeature {
     enum ValueType {
         // All value types allow eCSSUnit_Null to indicate that no value
         // was given (in addition to the types listed below).
         eLength,     // values are such that nsCSSValue::IsLengthUnit() is true
         eInteger,    // values are eCSSUnit_Integer
+        eBoolInteger,// values are eCSSUnit_Integer (0, -0, or 1 only)
         eIntRatio,   // values are eCSSUnit_Array of two eCSSUnit_Integer
         eResolution, // values are in eCSSUnit_Inch (for dpi) or
                      //   eCSSUnit_Centimeter (for dpcm)
         eEnumerated  // values are eCSSUnit_Enumerated (uses keyword table)
 
diff -r 14ce7619e9c1 layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/style/nsRuleNode.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -406,10 +406,151 @@ static PRBool SetColor(const nsCSSValue&
     aResult = aParentColor;
     result = PR_TRUE;
     aInherited = PR_TRUE;
   }
   return result;
+}
+
+// flags for SetDiscrete - align values with SETCOORD_* constants
+// where possible
+
+#define SETDSC_NORMAL                 0x01   // N
+#define SETDSC_AUTO                   0x02   // A
+#define SETDSC_INTEGER                0x40   // I
+#define SETDSC_ENUMERATED             0x80   // E
+#define SETDSC_NONE                   0x100  // O
+#define SETDSC_SYSTEM_FONT            0x2000
+
+// no caller cares whether aField was changed or not
+template <typename FieldT,
+          typename T1, typename T2, typename T3, typename T4, typename T5>
+static void
+SetDiscrete(const nsCSSValue& aValue, FieldT & aField,
+            PRBool& aInherited, PRUint32 aMask,
+            FieldT aParentValue,
+            T1 aInitialValue,
+            T2 aAutoValue,
+            T3 aNoneValue,
+            T4 aNormalValue,
+            T5 aSystemFontValue)
+{
+  switch (aValue.GetUnit()) {
+  case eCSSUnit_Null:
+    return;
+
+    // every caller of SetDiscrete provides inherit and initial
+    // alternatives, so we don't require them to say so in the mask
+  case eCSSUnit_Inherit:
+    aInherited = PR_TRUE;
+    aField = aParentValue;
+    return;
+
+  case eCSSUnit_Initial:
+    aField = aInitialValue;
+    return;
+
+    // every caller provides one or other of these alternatives,
+    // but they have to say which
+  case eCSSUnit_Enumerated:
+    if (aMask & SETDSC_ENUMERATED) {
+      aField = aValue.GetIntValue();
+      return;
+    }
+    break;
+
+  case eCSSUnit_Integer:
+    if (aMask & SETDSC_INTEGER) {
+      aField = aValue.GetIntValue();
+      return;
+    }
+    break;
+
+    // remaining possibilities in descending order of frequency of use
+  case eCSSUnit_Auto:
+    if (aMask & SETDSC_AUTO) {
+      aField = aAutoValue;
+      return;
+    }
+    break;
+
+  case eCSSUnit_None:
+    if (aMask & SETDSC_NONE) {
+      aField = aNoneValue;
+      return;
+    }
+    break;
+    
+  case eCSSUnit_Normal:
+    if (aMask & SETDSC_NORMAL) {
+      aField = aNormalValue;
+      return;
+    }
+    break;
+
+  case eCSSUnit_System_Font:
+    if (aMask & SETDSC_SYSTEM_FONT) {
+      aField = aSystemFontValue;
+      return;
+    }
+    break;
+
+  default:
+    break;
+  }
+
+  NS_NOTREACHED("SetDiscrete: inappropriate unit");
+}
+
+// flags for SetFactor
+#define SETFCT_POSITIVE 0x01        // assert value is >= 0.0f
+#define SETFCT_OPACITY  0x02        // clamp value to [0.0f .. 1.0f]
+#define SETFCT_NONE     0x04        // allow _None (uses aInitialValue).
+
+static void
+SetFactor(const nsCSSValue& aValue, float& aField, PRBool& aInherited,
+          float aParentValue, float aInitialValue, PRUint32 aFlags = 0)
+{
+  switch (aValue.GetUnit()) {
+  case eCSSUnit_Null:
+    return;
+
+  case eCSSUnit_Number:
+    aField = aValue.GetFloatValue();
+    if (aFlags & SETFCT_POSITIVE) {
+      NS_ASSERTION(aField >= 0.0f, "negative value for positive-only property");
+      if (aField < 0.0f)
+        aField = 0.0f;
+    }
+    if (aFlags & SETFCT_OPACITY) {
+      if (aField < 0.0f)
+        aField = 0.0f;
+      if (aField > 1.0f)
+        aField = 1.0f;
+    }
+    return;
+
+  case eCSSUnit_Inherit:
+    aInherited = PR_TRUE;
+    aField = aParentValue;
+    return;
+
+  case eCSSUnit_Initial:
+    aField = aInitialValue;
+    return;
+
+  case eCSSUnit_None:
+    if (aFlags & SETFCT_NONE) {
+      aField = aInitialValue;
+      return;
+    }
+    break;
+
+  default:
+    break;
+  }
+
+  NS_NOTREACHED("SetFactor: inappropriate unit");
 }
 
 // Overloaded new operator. Initializes the memory to 0 and relies on an arena
 // (which comes from the presShell) to perform the allocation.
 void* 
@@ -2253,51 +2394,31 @@ nsRuleNode::SetFont(nsPresContext* aPres
   if (aGenericFontID != kGenericFont_NONE) {
     aFont->mFlags &= ~NS_STYLE_FONT_FACE_MASK;
     aFont->mFlags |= aGenericFontID;
   }
 
-  // font-style: enum, normal, inherit
-  if (eCSSUnit_Enumerated == aFontData.mStyle.GetUnit()) {
-    aFont->mFont.style = aFontData.mStyle.GetIntValue();
-  }
-  else if (eCSSUnit_Normal == aFontData.mStyle.GetUnit()) {
-    aFont->mFont.style = NS_STYLE_FONT_STYLE_NORMAL;
-  }
-  else if (eCSSUnit_System_Font == aFontData.mStyle.GetUnit()) {
-    aFont->mFont.style = systemFont.style;
-  }
-  else if (eCSSUnit_Inherit == aFontData.mStyle.GetUnit()) {
-    aInherited = PR_TRUE;
-    aFont->mFont.style = aParentFont->mFont.style;
-  }
-  else if (eCSSUnit_Initial == aFontData.mStyle.GetUnit()) {
-    aFont->mFont.style = defaultVariableFont->style;
-  }
-
-  // font-variant: enum, normal, inherit
-  if (eCSSUnit_Enumerated == aFontData.mVariant.GetUnit()) {
-    aFont->mFont.variant = aFontData.mVariant.GetIntValue();
-  }
-  else if (eCSSUnit_Normal == aFontData.mVariant.GetUnit()) {
-    aFont->mFont.variant = NS_STYLE_FONT_VARIANT_NORMAL;
-  }
-  else if (eCSSUnit_System_Font == aFontData.mVariant.GetUnit()) {
-    aFont->mFont.variant = systemFont.variant;
-  }
-  else if (eCSSUnit_Inherit == aFontData.mVariant.GetUnit()) {
-    aInherited = PR_TRUE;
-    aFont->mFont.variant = aParentFont->mFont.variant;
-  }
-  else if (eCSSUnit_Initial == aFontData.mVariant.GetUnit()) {
-    aFont->mFont.variant = defaultVariableFont->variant;
-  }
-
-  // font-weight: int, enum, normal, inherit
-  if (eCSSUnit_Integer == aFontData.mWeight.GetUnit()) {
-    aFont->mFont.weight = aFontData.mWeight.GetIntValue();
-  }
-  else if (eCSSUnit_Enumerated == aFontData.mWeight.GetUnit()) {
+  // font-style: enum, normal, inherit, initial, -moz-system-font
+  SetDiscrete(aFontData.mStyle, aFont->mFont.style, aInherited,
+              SETDSC_ENUMERATED | SETDSC_NORMAL | SETDSC_SYSTEM_FONT,
+              aParentFont->mFont.style,
+              defaultVariableFont->style,
+              0, 0,
+              NS_STYLE_FONT_STYLE_NORMAL,
+              systemFont.style);
+
+  // font-variant: enum, normal, inherit, initial, -moz-system-font
+  SetDiscrete(aFontData.mVariant, aFont->mFont.variant, aInherited,
+              SETDSC_ENUMERATED | SETDSC_NORMAL | SETDSC_SYSTEM_FONT,
+              aParentFont->mFont.variant,
+              defaultVariableFont->variant,
+              0, 0,
+              NS_STYLE_FONT_VARIANT_NORMAL,
+              systemFont.variant);
+
+  // font-weight: int, enum, normal, inherit, initial, -moz-system-font
+  // special handling for enum
+  if (eCSSUnit_Enumerated == aFontData.mWeight.GetUnit()) {
     PRInt32 value = aFontData.mWeight.GetIntValue();
     switch (value) {
       case NS_STYLE_FONT_WEIGHT_NORMAL:
       case NS_STYLE_FONT_WEIGHT_BOLD:
         aFont->mFont.weight = value;
@@ -2306,24 +2427,18 @@ nsRuleNode::SetFont(nsPresContext* aPres
       case NS_STYLE_FONT_WEIGHT_LIGHTER:
         aInherited = PR_TRUE;
         aFont->mFont.weight = nsStyleUtil::ConstrainFontWeight(aParentFont->mFont.weight + value);
         break;
     }
-  }
-  else if (eCSSUnit_Normal == aFontData.mWeight.GetUnit()) {
-    aFont->mFont.weight = NS_STYLE_FONT_WEIGHT_NORMAL;
-  }
-  else if (eCSSUnit_System_Font == aFontData.mWeight.GetUnit()) {
-    aFont->mFont.weight = systemFont.weight;
-  }
-  else if (eCSSUnit_Inherit == aFontData.mWeight.GetUnit()) {
-    aInherited = PR_TRUE;
-    aFont->mFont.weight = aParentFont->mFont.weight;
-  }
-  else if (eCSSUnit_Initial == aFontData.mWeight.GetUnit()) {
-    aFont->mFont.weight = defaultVariableFont->weight;
-  }
+  } else 
+    SetDiscrete(aFontData.mWeight, aFont->mFont.weight, aInherited,
+                SETDSC_INTEGER | SETDSC_NORMAL | SETDSC_SYSTEM_FONT,
+                aParentFont->mFont.weight,
+                defaultVariableFont->weight,
+                0, 0,
+                NS_STYLE_FONT_WEIGHT_NORMAL,
+                systemFont.weight);
 
 #ifdef MOZ_MATHML
   // Compute scriptlevel, scriptminsize and scriptsizemultiplier now so
   // they're available for font-size computation.
 
@@ -2335,22 +2450,15 @@ nsRuleNode::SetFont(nsPresContext* aPres
     aFont->mScriptMinSize =
       CalcLengthWith(aFontData.mScriptMinSize, aParentFont->mSize, aParentFont, nsnull,
                      aPresContext, aInherited);
   }
 
-  // -moz-script-size-multiplier: factor, inherit
-  if (eCSSUnit_Number == aFontData.mScriptSizeMultiplier.GetUnit()) {
-    aFont->mScriptSizeMultiplier = aFontData.mScriptSizeMultiplier.GetFloatValue();
-    NS_ASSERTION(aFont->mScriptSizeMultiplier >= 0.0f, "Cannot have negative script size multiplier");
-  }
-  else if (eCSSUnit_Inherit == aFontData.mScriptSizeMultiplier.GetUnit()) {
-    aInherited = PR_TRUE;
-    aFont->mScriptSizeMultiplier = aParentFont->mScriptSizeMultiplier;
-  }
-  else if (eCSSUnit_Initial == aFontData.mScriptSizeMultiplier.GetUnit()) {
-    aFont->mScriptSizeMultiplier = NS_MATHML_DEFAULT_SCRIPT_SIZE_MULTIPLIER;
-  }
+  // -moz-script-size-multiplier: factor, inherit, initial
+  SetFactor(aFontData.mScriptSizeMultiplier, aFont->mScriptSizeMultiplier,
+            aInherited, aParentFont->mScriptSizeMultiplier,
+            NS_MATHML_DEFAULT_SCRIPT_SIZE_MULTIPLIER,
+            SETFCT_POSITIVE);
   
   // -moz-script-level: integer, number, inherit
   if (eCSSUnit_Integer == aFontData.mScriptLevel.GetUnit()) {
     // "relative"
     aFont->mScriptLevel = ClampTo8Bit(aParentFont->mScriptLevel + aFontData.mScriptLevel.GetIntValue());
@@ -2406,27 +2514,16 @@ nsRuleNode::SetFont(nsPresContext* aPres
   if (0 < aFont->mSize && aFont->mSize < aMinFontSize)
     aFont->mFont.size = aMinFontSize;
   else
     aFont->mFont.size = aFont->mSize;
 
-  // font-size-adjust: number, none, inherit
-  if (eCSSUnit_Number == aFontData.mSizeAdjust.GetUnit()) {
-    aFont->mFont.sizeAdjust = aFontData.mSizeAdjust.GetFloatValue();
-  }
-  else if (eCSSUnit_None == aFontData.mSizeAdjust.GetUnit()) {
-    aFont->mFont.sizeAdjust = 0.0f;
-  }
-  else if (eCSSUnit_System_Font == aFontData.mSizeAdjust.GetUnit()) {
+  // font-size-adjust: number, none, inherit, initial, -moz-system-font
+  if (eCSSUnit_System_Font == aFontData.mSizeAdjust.GetUnit()) {
     aFont->mFont.sizeAdjust = systemFont.sizeAdjust;
-  }
-  else if (eCSSUnit_Inherit == aFontData.mSizeAdjust.GetUnit()) {
-    aInherited = PR_TRUE;
-    aFont->mFont.sizeAdjust = aParentFont->mFont.sizeAdjust;
-  }
-  else if (eCSSUnit_Initial == aFontData.mSizeAdjust.GetUnit()) {
-    aFont->mFont.sizeAdjust = 0.0f;
-  }
+  } else
+    SetFactor(aFontData.mSizeAdjust, aFont->mFont.sizeAdjust, aInherited,
+              aParentFont->mFont.sizeAdjust, 0.0f, SETFCT_NONE);
 }
 
 // SetGenericFont:
 //  - backtrack to an ancestor with the same generic font name (possibly
 //    up to the root where default values come from the presentation context)
@@ -2737,72 +2834,46 @@ nsRuleNode::ComputeTextData(void* aStart
       text->mLineHeight.SetCoordValue(lh);
     }
   }
 
 
-  // text-align: enum, string, inherit
-  if (eCSSUnit_Enumerated == textData.mTextAlign.GetUnit()) {
-    text->mTextAlign = textData.mTextAlign.GetIntValue();
-  }
-  else if (eCSSUnit_String == textData.mTextAlign.GetUnit()) {
+  // text-align: enum, string, inherit, initial
+  if (eCSSUnit_String == textData.mTextAlign.GetUnit()) {
     NS_NOTYETIMPLEMENTED("align string");
-  }
-  else if (eCSSUnit_Inherit == textData.mTextAlign.GetUnit()) {
-    inherited = PR_TRUE;
-    text->mTextAlign = parentText->mTextAlign;
-  }
-  else if (eCSSUnit_Initial == textData.mTextAlign.GetUnit())
-    text->mTextAlign = NS_STYLE_TEXT_ALIGN_DEFAULT;
-
-  // text-indent: length, percent, inherit
+  } else
+    SetDiscrete(textData.mTextAlign, text->mTextAlign, inherited,
+                SETDSC_ENUMERATED, parentText->mTextAlign,
+                NS_STYLE_TEXT_ALIGN_DEFAULT,
+                0, 0, 0, 0);
+
+  // text-indent: length, percent, inherit, initial
   SetCoord(textData.mTextIndent, text->mTextIndent, parentText->mTextIndent,
            SETCOORD_LPH | SETCOORD_INITIAL_ZERO, aContext,
            mPresContext, inherited);
 
-  // text-transform: enum, none, inherit
-  if (eCSSUnit_Enumerated == textData.mTextTransform.GetUnit()) {
-    text->mTextTransform = textData.mTextTransform.GetIntValue();
-  }
-  else if (eCSSUnit_None == textData.mTextTransform.GetUnit() ||
-           eCSSUnit_Initial == textData.mTextTransform.GetUnit()) {
-    text->mTextTransform = NS_STYLE_TEXT_TRANSFORM_NONE;
-  }
-  else if (eCSSUnit_Inherit == textData.mTextTransform.GetUnit()) {
-    inherited = PR_TRUE;
-    text->mTextTransform = parentText->mTextTransform;
-  }
-
-  // white-space: enum, normal, inherit
-  if (eCSSUnit_Enumerated == textData.mWhiteSpace.GetUnit()) {
-    text->mWhiteSpace = textData.mWhiteSpace.GetIntValue();
-  }
-  else if (eCSSUnit_Normal == textData.mWhiteSpace.GetUnit() ||
-           eCSSUnit_Initial == textData.mWhiteSpace.GetUnit()) {
-    text->mWhiteSpace = NS_STYLE_WHITESPACE_NORMAL;
-  }
-  else if (eCSSUnit_Inherit == textData.mWhiteSpace.GetUnit()) {
-    inherited = PR_TRUE;
-    text->mWhiteSpace = parentText->mWhiteSpace;
-  }
-
+  // text-transform: enum, none, inherit, initial
+  SetDiscrete(textData.mTextTransform, text->mTextTransform, inherited,
+              SETDSC_ENUMERATED | SETDSC_NONE, parentText->mTextTransform,
+              NS_STYLE_TEXT_TRANSFORM_NONE, 0,
+              NS_STYLE_TEXT_TRANSFORM_NONE, 0, 0);
+
+  // white-space: enum, normal, inherit, initial
+  SetDiscrete(textData.mWhiteSpace, text->mWhiteSpace, inherited,
+              SETDSC_ENUMERATED | SETDSC_NORMAL, parentText->mWhiteSpace,
+              NS_STYLE_WHITESPACE_NORMAL, 0, 0,
+              NS_STYLE_WHITESPACE_NORMAL, 0);
+ 
   // word-spacing: normal, length, inherit
   SetCoord(textData.mWordSpacing, text->mWordSpacing, parentText->mWordSpacing,
            SETCOORD_LH | SETCOORD_NORMAL | SETCOORD_INITIAL_NORMAL,
            aContext, mPresContext, inherited);
 
-  // word-wrap: enum, normal, inherit
-  if (eCSSUnit_Enumerated == textData.mWordWrap.GetUnit()) {
-    text->mWordWrap = textData.mWordWrap.GetIntValue();
-  }
-  else if (eCSSUnit_Normal == textData.mWordWrap.GetUnit() ||
-           eCSSUnit_Initial == textData.mWordWrap.GetUnit()) {
-    text->mWordWrap = NS_STYLE_WORDWRAP_NORMAL;
-  }
-  else if (eCSSUnit_Inherit == textData.mWordWrap.GetUnit()) {
-    inherited = PR_TRUE;
-    text->mWordWrap = parentText->mWordWrap;
-  }
+  // word-wrap: enum, normal, inherit, initial
+  SetDiscrete(textData.mWordWrap, text->mWordWrap, inherited,
+              SETDSC_ENUMERATED | SETDSC_NORMAL, parentText->mWordWrap,
+              NS_STYLE_WORDWRAP_NORMAL, 0, 0,
+              NS_STYLE_WORDWRAP_NORMAL, 0);
 
   COMPUTE_END_INHERITED(Text, text)
 }
 
 const void*
@@ -2822,11 +2893,11 @@ nsRuleNode::ComputeTextResetData(void* a
       text->mVerticalAlign.SetIntValue(NS_STYLE_VERTICAL_ALIGN_BASELINE,
                                        eStyleUnit_Enumerated);
     }
   }
 
-  // text-decoration: none, enum (bit field), inherit
+  // text-decoration: none, enum (bit field), inherit, initial
   if (eCSSUnit_Enumerated == textData.mDecoration.GetUnit()) {
     PRInt32 td = textData.mDecoration.GetIntValue();
     text->mTextDecoration = td;
     if (td & NS_STYLE_TEXT_DECORATION_PREF_ANCHORS) {
       PRBool underlineLinks =
@@ -2837,31 +2908,23 @@ nsRuleNode::ComputeTextResetData(void* a
       else {
         text->mTextDecoration &= ~NS_STYLE_TEXT_DECORATION_UNDERLINE;
       }
     }
   }
-  else if (eCSSUnit_None == textData.mDecoration.GetUnit() ||
-           eCSSUnit_Initial == textData.mDecoration.GetUnit()) {
-    text->mTextDecoration = NS_STYLE_TEXT_DECORATION_NONE;
-  }
-  else if (eCSSUnit_Inherit == textData.mDecoration.GetUnit()) {
-    inherited = PR_TRUE;
-    text->mTextDecoration = parentText->mTextDecoration;
-  }
-
-  // unicode-bidi: enum, normal, inherit
-  if (eCSSUnit_Normal == textData.mUnicodeBidi.GetUnit() ||
-      eCSSUnit_Initial == textData.mUnicodeBidi.GetUnit()) {
-    text->mUnicodeBidi = NS_STYLE_UNICODE_BIDI_NORMAL;
-  }
-  else if (eCSSUnit_Enumerated == textData.mUnicodeBidi.GetUnit() ) {
-    text->mUnicodeBidi = textData.mUnicodeBidi.GetIntValue();
-  }
-  else if (eCSSUnit_Inherit == textData.mUnicodeBidi.GetUnit() ) {
-    inherited = PR_TRUE;
-    text->mUnicodeBidi = parentText->mUnicodeBidi;
-  }
+  else
+    SetDiscrete(textData.mDecoration, text->mTextDecoration, inherited,
+                SETDSC_NONE,
+                parentText->mTextDecoration,
+                NS_STYLE_TEXT_DECORATION_NONE, 0,
+                NS_STYLE_TEXT_DECORATION_NONE, 0, 0);
+
+  // unicode-bidi: enum, normal, inherit, initial
+  SetDiscrete(textData.mUnicodeBidi, text->mUnicodeBidi, inherited,
+              SETDSC_ENUMERATED | SETDSC_NORMAL,
+              parentText->mUnicodeBidi,
+              NS_STYLE_UNICODE_BIDI_NORMAL, 0, 0,
+              NS_STYLE_UNICODE_BIDI_NORMAL, 0);
 
   COMPUTE_END_RESET(TextReset, text)
 }
 
 const void*
@@ -2934,53 +2997,35 @@ nsRuleNode::ComputeUserInterfaceData(voi
         ui->mCursor = NS_STYLE_CURSOR_AUTO;
       }
     }
   }
 
-  // user-input: auto, none, enum, inherit
-  if (eCSSUnit_Enumerated == uiData.mUserInput.GetUnit()) {
-    ui->mUserInput = uiData.mUserInput.GetIntValue();
-  }
-  else if (eCSSUnit_Auto == uiData.mUserInput.GetUnit() ||
-           eCSSUnit_Initial == uiData.mUserInput.GetUnit()) {
-    ui->mUserInput = NS_STYLE_USER_INPUT_AUTO;
-  }
-  else if (eCSSUnit_None == uiData.mUserInput.GetUnit()) {
-    ui->mUserInput = NS_STYLE_USER_INPUT_NONE;
-  }
-  else if (eCSSUnit_Inherit == uiData.mUserInput.GetUnit()) {
-    inherited = PR_TRUE;
-    ui->mUserInput = parentUI->mUserInput;
-  }
-
-  // user-modify: enum, inherit
-  if (eCSSUnit_Enumerated == uiData.mUserModify.GetUnit()) {
-    ui->mUserModify = uiData.mUserModify.GetIntValue();
-  }
-  else if (eCSSUnit_Inherit == uiData.mUserModify.GetUnit()) {
-    inherited = PR_TRUE;
-    ui->mUserModify = parentUI->mUserModify;
-  }
-  else if (eCSSUnit_Initial == uiData.mUserModify.GetUnit()) {
-    ui->mUserModify = NS_STYLE_USER_MODIFY_READ_ONLY;
-  }
-
-  // user-focus: none, normal, enum, inherit
-  if (eCSSUnit_Enumerated == uiData.mUserFocus.GetUnit()) {
-    ui->mUserFocus = uiData.mUserFocus.GetIntValue();
-  }
-  else if (eCSSUnit_None == uiData.mUserFocus.GetUnit() ||
-           eCSSUnit_Initial == uiData.mUserFocus.GetUnit()) {
-    ui->mUserFocus = NS_STYLE_USER_FOCUS_NONE;
-  }
-  else if (eCSSUnit_Normal == uiData.mUserFocus.GetUnit()) {
-    ui->mUserFocus = NS_STYLE_USER_FOCUS_NORMAL;
-  }
-  else if (eCSSUnit_Inherit == uiData.mUserFocus.GetUnit()) {
-    inherited = PR_TRUE;
-    ui->mUserFocus = parentUI->mUserFocus;
-  }
+  // user-input: auto, none, enum, inherit, initial
+  SetDiscrete(uiData.mUserInput, ui->mUserInput, inherited,
+              SETDSC_ENUMERATED | SETDSC_NONE | SETDSC_AUTO,
+              parentUI->mUserInput,
+              NS_STYLE_USER_INPUT_AUTO,
+              NS_STYLE_USER_INPUT_AUTO,
+              NS_STYLE_USER_INPUT_NONE,
+              0, 0);
+
+  // user-modify: enum, inherit, initial
+  SetDiscrete(uiData.mUserModify, ui->mUserModify, inherited,
+              SETDSC_ENUMERATED,
+              parentUI->mUserModify,
+              NS_STYLE_USER_MODIFY_READ_ONLY, 
+              0, 0, 0, 0);
+
+  // user-focus: none, normal, enum, inherit, initial
+  SetDiscrete(uiData.mUserFocus, ui->mUserFocus, inherited,
+              SETDSC_ENUMERATED | SETDSC_NONE | SETDSC_NORMAL,
+              parentUI->mUserFocus,
+              NS_STYLE_USER_FOCUS_NONE,
+              0,
+              NS_STYLE_USER_FOCUS_NONE,
+              NS_STYLE_USER_FOCUS_NORMAL,
+              0);
 
   COMPUTE_END_INHERITED(UserInterface, ui)
 }
 
 const void*
@@ -2990,51 +3035,36 @@ nsRuleNode::ComputeUIResetData(void* aSt
                                nsRuleNode* aHighestNode,
                                const RuleDetail aRuleDetail, PRBool aInherited)
 {
   COMPUTE_START_RESET(UIReset, (), ui, parentUI, UserInterface, uiData)
   
-  // user-select: none, enum, inherit
-  if (eCSSUnit_Enumerated == uiData.mUserSelect.GetUnit()) {
-    ui->mUserSelect = uiData.mUserSelect.GetIntValue();
-  }
-  else if (eCSSUnit_None == uiData.mUserSelect.GetUnit()) {
-    ui->mUserSelect = NS_STYLE_USER_SELECT_NONE;
-  }
-  else if (eCSSUnit_Inherit == uiData.mUserSelect.GetUnit()) {
-    inherited = PR_TRUE;
-    ui->mUserSelect = parentUI->mUserSelect;
-  }
-  else if (eCSSUnit_Initial == uiData.mUserSelect.GetUnit() ||
-           eCSSUnit_Auto == uiData.mUserSelect.GetUnit()) {
-    ui->mUserSelect = NS_STYLE_USER_SELECT_AUTO;
-  }
-
-  // ime-mode: auto, normal, enum, inherit
-  if (eCSSUnit_Auto == uiData.mIMEMode.GetUnit() ||
-      eCSSUnit_Initial == uiData.mIMEMode.GetUnit()) {
-    ui->mIMEMode = NS_STYLE_IME_MODE_AUTO;
-  }
-  else if (eCSSUnit_Normal == uiData.mIMEMode.GetUnit()) {
-    ui->mIMEMode = NS_STYLE_IME_MODE_NORMAL;
-  }
-  else if (eCSSUnit_Enumerated == uiData.mIMEMode.GetUnit()) {
-    ui->mIMEMode = uiData.mIMEMode.GetIntValue();
-  }
-  else if (eCSSUnit_Inherit == uiData.mIMEMode.GetUnit()) {
-    inherited = PR_TRUE;
-    ui->mIMEMode = parentUI->mIMEMode;
-  }
-
-  // force-broken-image-icons: integer
-  if (eCSSUnit_Integer == uiData.mForceBrokenImageIcon.GetUnit()) {
-    ui->mForceBrokenImageIcon = uiData.mForceBrokenImageIcon.GetIntValue();
-  } else if (eCSSUnit_Inherit == uiData.mForceBrokenImageIcon.GetUnit()) {
-    inherited = PR_TRUE;
-    ui->mForceBrokenImageIcon = parentUI->mForceBrokenImageIcon;
-  } else if (eCSSUnit_Initial == uiData.mForceBrokenImageIcon.GetUnit()) {
-    ui->mForceBrokenImageIcon = 0;
-  }
+  // user-select: auto, none, enum, inherit, initial
+  SetDiscrete(uiData.mUserSelect, ui->mUserSelect, inherited,
+              SETDSC_ENUMERATED | SETDSC_NONE | SETDSC_AUTO,
+              parentUI->mUserSelect,
+              NS_STYLE_USER_SELECT_AUTO,
+              NS_STYLE_USER_SELECT_AUTO,
+              NS_STYLE_USER_SELECT_NONE,
+              0, 0);
+
+  // ime-mode: auto, normal, enum, inherit, initial
+  SetDiscrete(uiData.mIMEMode, ui->mIMEMode, inherited,
+              SETDSC_ENUMERATED | SETDSC_NORMAL | SETDSC_AUTO,
+              parentUI->mIMEMode,
+              NS_STYLE_IME_MODE_AUTO,
+              NS_STYLE_IME_MODE_AUTO,
+              0,
+              NS_STYLE_IME_MODE_NORMAL,
+              0);
+
+  // force-broken-image-icons: integer, inherit, initial
+  SetDiscrete(uiData.mForceBrokenImageIcon, ui->mForceBrokenImageIcon,
+              inherited,
+              SETDSC_INTEGER,
+              parentUI->mForceBrokenImageIcon,
+              0, 0, 0, 0, 0);
+
   COMPUTE_END_RESET(UIReset, ui)
 }
 
 const void*
 nsRuleNode::ComputeDisplayData(void* aStartStruct,
@@ -3051,53 +3081,25 @@ nsRuleNode::ComputeDisplayData(void* aSt
   NS_ASSERTION(!generatedContent || parentContext,
                "Must have parent context for generated content");
   if (parentDisplay == display && generatedContent)
     parentDisplay = parentContext->GetStyleDisplay();
 
-  // opacity: factor, inherit
-  if (eCSSUnit_Number == displayData.mOpacity.GetUnit()) {
-    display->mOpacity = displayData.mOpacity.GetFloatValue();
-    if (display->mOpacity > 1.0f)
-      display->mOpacity = 1.0f;
-    if (display->mOpacity < 0.0f)
-      display->mOpacity = 0.0f;
-  }
-  else if (eCSSUnit_Inherit == displayData.mOpacity.GetUnit()) {
-    inherited = PR_TRUE;
-    display->mOpacity = parentDisplay->mOpacity;
-  }
-  else if (eCSSUnit_Initial == displayData.mOpacity.GetUnit()) {
-    display->mOpacity = 1.0f;
-  }
-
-  // display: enum, none, inherit
-  if (eCSSUnit_Enumerated == displayData.mDisplay.GetUnit()) {
-    display->mDisplay = displayData.mDisplay.GetIntValue();
-  }
-  else if (eCSSUnit_None == displayData.mDisplay.GetUnit()) {
-    display->mDisplay = NS_STYLE_DISPLAY_NONE;
-  }
-  else if (eCSSUnit_Inherit == displayData.mDisplay.GetUnit()) {
-    inherited = PR_TRUE;
-    display->mDisplay = parentDisplay->mDisplay;
-  }
-  else if (eCSSUnit_Initial == displayData.mDisplay.GetUnit()) {
-    display->mDisplay = NS_STYLE_DISPLAY_INLINE;
-  }
-
-  // appearance: enum, none, inherit
-  if (eCSSUnit_Enumerated == displayData.mAppearance.GetUnit()) {
-    display->mAppearance = displayData.mAppearance.GetIntValue();
-  }
-  else if (eCSSUnit_None == displayData.mAppearance.GetUnit() ||
-           eCSSUnit_Initial == displayData.mAppearance.GetUnit()) {
-    display->mAppearance = NS_THEME_NONE;
-  }
-  else if (eCSSUnit_Inherit == displayData.mAppearance.GetUnit()) {
-    inherited = PR_TRUE;
-    display->mAppearance = parentDisplay->mAppearance;
-  }
+  // opacity: factor, inherit, initial
+  SetFactor(displayData.mOpacity, display->mOpacity, inherited,
+            parentDisplay->mOpacity, 1.0f, SETFCT_OPACITY);
+
+  // display: enum, none, inherit, initial
+  SetDiscrete(displayData.mDisplay, display->mDisplay, inherited,
+              SETDSC_ENUMERATED | SETDSC_NONE, parentDisplay->mDisplay,
+              NS_STYLE_DISPLAY_INLINE, 0,
+              NS_STYLE_DISPLAY_NONE, 0, 0);
+
+  // appearance: enum, none, inherit, initial
+  SetDiscrete(displayData.mAppearance, display->mAppearance, inherited,
+              SETDSC_ENUMERATED | SETDSC_NONE, parentDisplay->mAppearance,
+              NS_THEME_NONE, 0,
+              NS_THEME_NONE, 0, 0);
 
   // binding: url, none, inherit
   if (eCSSUnit_URL == displayData.mBinding.GetUnit()) {
     nsCSSValue::URL* url = displayData.mBinding.GetURLStructValue();
     NS_ASSERTION(url, "What's going on here?");
@@ -3115,34 +3117,20 @@ nsRuleNode::ComputeDisplayData(void* aSt
   else if (eCSSUnit_Inherit == displayData.mBinding.GetUnit()) {
     inherited = PR_TRUE;
     display->mBinding = parentDisplay->mBinding;
   }
 
-  // position: enum, inherit
-  if (eCSSUnit_Enumerated == displayData.mPosition.GetUnit()) {
-    display->mPosition = displayData.mPosition.GetIntValue();
-  }
-  else if (eCSSUnit_Inherit == displayData.mPosition.GetUnit()) {
-    inherited = PR_TRUE;
-    display->mPosition = parentDisplay->mPosition;
-  }
-  else if (eCSSUnit_Initial == displayData.mPosition.GetUnit()) {
-    display->mPosition = NS_STYLE_POSITION_STATIC;
-  }
-
-  // clear: enum, none, inherit
-  if (eCSSUnit_Enumerated == displayData.mClear.GetUnit()) {
-    display->mBreakType = displayData.mClear.GetIntValue();
-  }
-  else if (eCSSUnit_None == displayData.mClear.GetUnit() ||
-           eCSSUnit_Initial == displayData.mClear.GetUnit()) {
-    display->mBreakType = NS_STYLE_CLEAR_NONE;
-  }
-  else if (eCSSUnit_Inherit == displayData.mClear.GetUnit()) {
-    inherited = PR_TRUE;
-    display->mBreakType = parentDisplay->mBreakType;
-  }
+  // position: enum, inherit, initial
+  SetDiscrete(displayData.mPosition, display->mPosition, inherited,
+              SETDSC_ENUMERATED, parentDisplay->mPosition,
+              NS_STYLE_POSITION_STATIC, 0, 0, 0, 0);
+
+  // clear: enum, none, inherit, initial
+  SetDiscrete(displayData.mClear, display->mBreakType, inherited,
+              SETDSC_ENUMERATED | SETDSC_NONE, parentDisplay->mBreakType,
+              NS_STYLE_CLEAR_NONE, 0,
+              NS_STYLE_CLEAR_NONE, 0, 0);
 
   // temp fix for bug 24000
   // Map 'auto' and 'avoid' to PR_FALSE, and 'always', 'left', and
   // 'right' to PR_TRUE.
   // "A conforming user agent may interpret the values 'left' and
@@ -3170,52 +3158,31 @@ nsRuleNode::ComputeDisplayData(void* aSt
     inherited = PR_TRUE;
     display->mBreakAfter = parentDisplay->mBreakAfter;
   }
   // end temp fix
 
-  // float: enum, none, inherit
-  if (eCSSUnit_Enumerated == displayData.mFloat.GetUnit()) {
-    display->mFloats = displayData.mFloat.GetIntValue();
-  }
-  else if (eCSSUnit_None == displayData.mFloat.GetUnit() ||
-           eCSSUnit_Initial == displayData.mFloat.GetUnit()) {
-    display->mFloats = NS_STYLE_FLOAT_NONE;
-  }
-  else if (eCSSUnit_Inherit == displayData.mFloat.GetUnit()) {
-    inherited = PR_TRUE;
-    display->mFloats = parentDisplay->mFloats;
-  }
-
-  // overflow-x: enum, auto, inherit
-  if (eCSSUnit_Enumerated == displayData.mOverflowX.GetUnit()) {
-    display->mOverflowX = displayData.mOverflowX.GetIntValue();
-  }
-  else if (eCSSUnit_Auto == displayData.mOverflowX.GetUnit()) {
-    display->mOverflowX = NS_STYLE_OVERFLOW_AUTO;
-  }
-  else if (eCSSUnit_Inherit == displayData.mOverflowX.GetUnit()) {
-    inherited = PR_TRUE;
-    display->mOverflowX = parentDisplay->mOverflowX;
-  }
-  else if (eCSSUnit_Initial == displayData.mOverflowX.GetUnit()) {
-    display->mOverflowX = NS_STYLE_OVERFLOW_VISIBLE;
-  }
-
-  // overflow-y: enum, auto, inherit
-  if (eCSSUnit_Enumerated == displayData.mOverflowY.GetUnit()) {
-    display->mOverflowY = displayData.mOverflowY.GetIntValue();
-  }
-  else if (eCSSUnit_Auto == displayData.mOverflowY.GetUnit()) {
-    display->mOverflowY = NS_STYLE_OVERFLOW_AUTO;
-  }
-  else if (eCSSUnit_Inherit == displayData.mOverflowY.GetUnit()) {
-    inherited = PR_TRUE;
-    display->mOverflowY = parentDisplay->mOverflowY;
-  }
-  else if (eCSSUnit_Initial == displayData.mOverflowY.GetUnit()) {
-    display->mOverflowY = NS_STYLE_OVERFLOW_VISIBLE;
-  }
+  // float: enum, none, inherit, initial
+  SetDiscrete(displayData.mFloat, display->mFloats, inherited,
+              SETDSC_ENUMERATED | SETDSC_NONE, parentDisplay->mFloats,
+              NS_STYLE_FLOAT_NONE, 0,
+              NS_STYLE_FLOAT_NONE, 0, 0);
+
+  // overflow-x: enum, auto, inherit, initial
+  SetDiscrete(displayData.mOverflowX, display->mOverflowX, inherited,
+              SETDSC_ENUMERATED | SETDSC_AUTO,
+              parentDisplay->mOverflowX,
+              NS_STYLE_OVERFLOW_VISIBLE,
+              NS_STYLE_OVERFLOW_AUTO,
+              0, 0, 0);
+
+  // overflow-y: enum, auto, inherit, initial
+  SetDiscrete(displayData.mOverflowY, display->mOverflowY, inherited,
+              SETDSC_ENUMERATED | SETDSC_AUTO,
+              parentDisplay->mOverflowY,
+              NS_STYLE_OVERFLOW_VISIBLE,
+              NS_STYLE_OVERFLOW_AUTO,
+              0, 0, 0);
 
   // CSS3 overflow-x and overflow-y require some fixup as well in some
   // cases.  NS_STYLE_OVERFLOW_VISIBLE and NS_STYLE_OVERFLOW_CLIP are
   // meaningful only when used in both dimensions.
   if (display->mOverflowX != display->mOverflowY &&
@@ -3364,39 +3331,22 @@ nsRuleNode::ComputeVisibilityData(void* 
 {
   COMPUTE_START_INHERITED(Visibility, (mPresContext),
                           visibility, parentVisibility,
                           Display, displayData)
 
-  // direction: enum, inherit
-  if (eCSSUnit_Enumerated == displayData.mDirection.GetUnit()) {
-    visibility->mDirection = displayData.mDirection.GetIntValue();
-    if (NS_STYLE_DIRECTION_RTL == visibility->mDirection)
-      mPresContext->SetBidiEnabled();
-  }
-  else if (eCSSUnit_Inherit == displayData.mDirection.GetUnit()) {
-    inherited = PR_TRUE;
-    visibility->mDirection = parentVisibility->mDirection;
-  }
-  else if (eCSSUnit_Initial == displayData.mDirection.GetUnit()) {
-    PRUint32 bidiOptions = mPresContext->GetBidi();
-    if (GET_BIDI_OPTION_DIRECTION(bidiOptions) == IBMBIDI_TEXTDIRECTION_RTL)
-      visibility->mDirection = NS_STYLE_DIRECTION_RTL;
-    else
-      visibility->mDirection = NS_STYLE_DIRECTION_LTR;
-  }
-
-  // visibility: enum, inherit
-  if (eCSSUnit_Enumerated == displayData.mVisibility.GetUnit()) {
-    visibility->mVisible = displayData.mVisibility.GetIntValue();
-  }
-  else if (eCSSUnit_Inherit == displayData.mVisibility.GetUnit()) {
-    inherited = PR_TRUE;
-    visibility->mVisible = parentVisibility->mVisible;
-  }
-  else if (eCSSUnit_Initial == displayData.mVisibility.GetUnit()) {
-    visibility->mVisible = NS_STYLE_VISIBILITY_VISIBLE;
-  }
+  // direction: enum, inherit, initial
+  SetDiscrete(displayData.mDirection, visibility->mDirection, inherited,
+              SETDSC_ENUMERATED, parentVisibility->mDirection,
+              (GET_BIDI_OPTION_DIRECTION(mPresContext->GetBidi())
+               == IBMBIDI_TEXTDIRECTION_RTL)
+              ? NS_STYLE_DIRECTION_RTL : NS_STYLE_DIRECTION_LTR,
+              0, 0, 0, 0);
+
+  // visibility: enum, inherit, initial
+  SetDiscrete(displayData.mVisibility, visibility->mVisible, inherited,
+              SETDSC_ENUMERATED, parentVisibility->mVisible,
+              NS_STYLE_VISIBILITY_VISIBLE, 0, 0, 0, 0);
 
   // lang: string, inherit
   // this is not a real CSS property, it is a html attribute mapped to CSS struture
   if (eCSSUnit_String == displayData.mLang.GetUnit()) {
     if (!gLangService) {
@@ -3488,66 +3438,35 @@ nsRuleNode::ComputeBackgroundData(void* 
     bg->mBackgroundFlags &= ~NS_STYLE_BG_IMAGE_NONE;
   } else {
     bg->mBackgroundFlags |= NS_STYLE_BG_IMAGE_NONE;
   }
 
-  // background-repeat: enum, inherit
-  if (eCSSUnit_Enumerated == colorData.mBackRepeat.GetUnit()) {
-    bg->mBackgroundRepeat = colorData.mBackRepeat.GetIntValue();
-  }
-  else if (eCSSUnit_Inherit == colorData.mBackRepeat.GetUnit()) {
-    inherited = PR_TRUE;
-    bg->mBackgroundRepeat = parentBG->mBackgroundRepeat;
-  }
-  else if (eCSSUnit_Initial == colorData.mBackRepeat.GetUnit()) {
-    bg->mBackgroundRepeat = NS_STYLE_BG_REPEAT_XY;
-  }
-
-  // background-attachment: enum, inherit
-  if (eCSSUnit_Enumerated == colorData.mBackAttachment.GetUnit()) {
-    bg->mBackgroundAttachment = colorData.mBackAttachment.GetIntValue();
-  }
-  else if (eCSSUnit_Inherit == colorData.mBackAttachment.GetUnit()) {
-    inherited = PR_TRUE;
-    bg->mBackgroundAttachment = parentBG->mBackgroundAttachment;
-  }
-  else if (eCSSUnit_Initial == colorData.mBackAttachment.GetUnit()) {
-    bg->mBackgroundAttachment = NS_STYLE_BG_ATTACHMENT_SCROLL;
-  }
+  // background-repeat: enum, inherit, initial
+  SetDiscrete(colorData.mBackRepeat, bg->mBackgroundRepeat, inherited,
+              SETDSC_ENUMERATED, parentBG->mBackgroundRepeat,
+              NS_STYLE_BG_REPEAT_XY, 0, 0, 0, 0);
+
+  // background-attachment: enum, inherit, initial
+  SetDiscrete(colorData.mBackAttachment, bg->mBackgroundAttachment, inherited,
+              SETDSC_ENUMERATED, parentBG->mBackgroundAttachment,
+              NS_STYLE_BG_ATTACHMENT_SCROLL, 0, 0, 0, 0);
 
   // background-clip: enum, inherit, initial
-  if (eCSSUnit_Enumerated == colorData.mBackClip.GetUnit()) {
-    bg->mBackgroundClip = colorData.mBackClip.GetIntValue();
-  }
-  else if (eCSSUnit_Inherit == colorData.mBackClip.GetUnit()) {
-    bg->mBackgroundClip = parentBG->mBackgroundClip;
-  }
-  else if (eCSSUnit_Initial == colorData.mBackClip.GetUnit()) {
-    bg->mBackgroundClip = NS_STYLE_BG_CLIP_BORDER;
-  }
+  SetDiscrete(colorData.mBackClip, bg->mBackgroundClip, inherited,
+              SETDSC_ENUMERATED, parentBG->mBackgroundClip,
+              NS_STYLE_BG_CLIP_BORDER, 0, 0, 0, 0);
 
   // background-inline-policy: enum, inherit, initial
-  if (eCSSUnit_Enumerated == colorData.mBackInlinePolicy.GetUnit()) {
-    bg->mBackgroundInlinePolicy = colorData.mBackInlinePolicy.GetIntValue();
-  }
-  else if (eCSSUnit_Inherit == colorData.mBackInlinePolicy.GetUnit()) {
-    bg->mBackgroundInlinePolicy = parentBG->mBackgroundInlinePolicy;
-  }
-  else if (eCSSUnit_Initial == colorData.mBackInlinePolicy.GetUnit()) {
-    bg->mBackgroundInlinePolicy = NS_STYLE_BG_INLINE_POLICY_CONTINUOUS;
-  }
+  SetDiscrete(colorData.mBackInlinePolicy, bg->mBackgroundInlinePolicy,
+              inherited, SETDSC_ENUMERATED,
+              parentBG->mBackgroundInlinePolicy,
+              NS_STYLE_BG_INLINE_POLICY_CONTINUOUS, 0, 0, 0, 0);
 
   // background-origin: enum, inherit, initial
-  if (eCSSUnit_Enumerated == colorData.mBackOrigin.GetUnit()) {
-    bg->mBackgroundOrigin = colorData.mBackOrigin.GetIntValue();
-  }
-  else if (eCSSUnit_Inherit == colorData.mBackOrigin.GetUnit()) {
-    bg->mBackgroundOrigin = parentBG->mBackgroundOrigin;
-  }
-  else if (eCSSUnit_Initial == colorData.mBackOrigin.GetUnit()) {
-    bg->mBackgroundOrigin = NS_STYLE_BG_ORIGIN_PADDING;
-  }
+  SetDiscrete(colorData.mBackOrigin, bg->mBackgroundOrigin, inherited,
+              SETDSC_ENUMERATED, parentBG->mBackgroundOrigin,
+              NS_STYLE_BG_ORIGIN_PADDING, 0, 0, 0, 0);
 
   // background-position: enum, length, percent (flags), inherit
   if (eCSSUnit_Percent == colorData.mBackPosition.mXValue.GetUnit()) {
     bg->mBackgroundXPosition.mFloat = colorData.mBackPosition.mXValue.GetPercentValue();
     bg->mBackgroundFlags |= NS_STYLE_BG_X_POSITION_PERCENT;
@@ -3866,20 +3785,14 @@ nsRuleNode::ComputeBorderData(void* aSta
                    aContext, mPresContext, inherited))
         border->mBorderRadius.Set(side, coord);
     }
   }
 
-  // float-edge: enum, inherit
-  if (eCSSUnit_Enumerated == marginData.mFloatEdge.GetUnit())
-    border->mFloatEdge = marginData.mFloatEdge.GetIntValue();
-  else if (eCSSUnit_Inherit == marginData.mFloatEdge.GetUnit()) {
-    inherited = PR_TRUE;
-    border->mFloatEdge = parentBorder->mFloatEdge;
-  }
-  else if (eCSSUnit_Initial == marginData.mFloatEdge.GetUnit()) {
-    border->mFloatEdge = NS_STYLE_FLOAT_EDGE_CONTENT;
-  }
+  // float-edge: enum, inherit, initial
+  SetDiscrete(marginData.mFloatEdge, border->mFloatEdge, inherited,
+              SETDSC_ENUMERATED, parentBorder->mFloatEdge,
+              NS_STYLE_FLOAT_EDGE_CONTENT, 0, 0, 0, 0);
   
   // border-image
   if (eCSSUnit_Array == marginData.mBorderImage.GetUnit()) {
     nsCSSValue::Array *arr = marginData.mBorderImage.GetArrayValue();
     
@@ -4057,11 +3970,12 @@ nsRuleNode::ComputeOutlineData(void* aSt
                    aContext, mPresContext, inherited))
         outline->mOutlineRadius.Set(side, coord);
     }
   }
 
-  // outline-style: auto, enum, none, inherit
+  // outline-style: auto, enum, none, inherit, initial
+  // cannot use SetDiscrete because of SetOutlineStyle
   if (eCSSUnit_Enumerated == marginData.mOutlineStyle.GetUnit())
     outline->SetOutlineStyle(marginData.mOutlineStyle.GetIntValue());
   else if (eCSSUnit_None == marginData.mOutlineStyle.GetUnit() ||
            eCSSUnit_Initial == marginData.mOutlineStyle.GetUnit())
     outline->SetOutlineStyle(NS_STYLE_BORDER_STYLE_NONE);
@@ -4083,24 +3997,15 @@ nsRuleNode::ComputeListData(void* aStart
                             nsRuleNode* aHighestNode,
                             const RuleDetail aRuleDetail, PRBool aInherited)
 {
   COMPUTE_START_INHERITED(List, (), list, parentList, List, listData)
 
-  // list-style-type: enum, none, inherit
-  if (eCSSUnit_Enumerated == listData.mType.GetUnit()) {
-    list->mListStyleType = listData.mType.GetIntValue();
-  }
-  else if (eCSSUnit_None == listData.mType.GetUnit()) {
-    list->mListStyleType = NS_STYLE_LIST_STYLE_NONE;
-  }
-  else if (eCSSUnit_Inherit == listData.mType.GetUnit()) {
-    inherited = PR_TRUE;
-    list->mListStyleType = parentList->mListStyleType;
-  }
-  else if (eCSSUnit_Initial == listData.mType.GetUnit()) {
-    list->mListStyleType = NS_STYLE_LIST_STYLE_DISC;
-  }
+  // list-style-type: enum, none, inherit, initial
+  SetDiscrete(listData.mType, list->mListStyleType, inherited,
+              SETDSC_ENUMERATED | SETDSC_NONE, parentList->mListStyleType,
+              NS_STYLE_LIST_STYLE_DISC, 0,
+              NS_STYLE_LIST_STYLE_NONE, 0, 0);
 
   // list-style-image: url, none, inherit
   if (eCSSUnit_Image == listData.mImage.GetUnit()) {
     list->mListStyleImage = listData.mImage.GetImageValue();
   }
@@ -4111,21 +4016,14 @@ nsRuleNode::ComputeListData(void* aStart
   else if (eCSSUnit_Inherit == listData.mImage.GetUnit()) {
     inherited = PR_TRUE;
     list->mListStyleImage = parentList->mListStyleImage;
   }
 
-  // list-style-position: enum, inherit
-  if (eCSSUnit_Enumerated == listData.mPosition.GetUnit()) {
-    list->mListStylePosition = listData.mPosition.GetIntValue();
-  }
-  else if (eCSSUnit_Inherit == listData.mPosition.GetUnit()) {
-    inherited = PR_TRUE;
-    list->mListStylePosition = parentList->mListStylePosition;
-  }
-  else if (eCSSUnit_Initial == listData.mPosition.GetUnit()) {
-    list->mListStylePosition = NS_STYLE_LIST_STYLE_POSITION_OUTSIDE;
-  }
+  // list-style-position: enum, inherit, initial
+  SetDiscrete(listData.mPosition, list->mListStylePosition, inherited,
+              SETDSC_ENUMERATED, parentList->mListStylePosition,
+              NS_STYLE_LIST_STYLE_POSITION_OUTSIDE, 0, 0, 0, 0);
 
   // image region property: length, auto, inherit
   if (eCSSUnit_Inherit == listData.mImageRegion.mTop.GetUnit()) { // if one is inherit, they all are
     inherited = PR_TRUE;
     list->mImageRegion = parentList->mImageRegion;
@@ -4199,21 +4097,14 @@ nsRuleNode::ComputePositionData(void* aS
            mPresContext, inherited);
   SetCoord(posData.mMaxHeight, pos->mMaxHeight, parentPos->mMaxHeight,
            SETCOORD_LPOH | SETCOORD_INITIAL_NONE, aContext,
            mPresContext, inherited);
 
-  // box-sizing: enum, inherit
-  if (eCSSUnit_Enumerated == posData.mBoxSizing.GetUnit()) {
-    pos->mBoxSizing = posData.mBoxSizing.GetIntValue();
-  }
-  else if (eCSSUnit_Inherit == posData.mBoxSizing.GetUnit()) {
-    inherited = PR_TRUE;
-    pos->mBoxSizing = parentPos->mBoxSizing;
-  }
-  else if (eCSSUnit_Initial == posData.mBoxSizing.GetUnit()) {
-    pos->mBoxSizing = NS_STYLE_BOX_SIZING_CONTENT;
-  }
+  // box-sizing: enum, inherit, initial
+  SetDiscrete(posData.mBoxSizing, pos->mBoxSizing, inherited,
+              SETDSC_ENUMERATED, parentPos->mBoxSizing,
+              NS_STYLE_BOX_SIZING_CONTENT, 0, 0, 0, 0);
 
   // z-index
   if (! SetCoord(posData.mZIndex, pos->mZIndex, parentPos->mZIndex,
                  SETCOORD_IA | SETCOORD_INITIAL_AUTO, aContext,
                  nsnull, inherited)) {
@@ -4234,20 +4125,16 @@ nsRuleNode::ComputeTableData(void* aStar
                              nsRuleNode* aHighestNode,
                              const RuleDetail aRuleDetail, PRBool aInherited)
 {
   COMPUTE_START_RESET(Table, (), table, parentTable, Table, tableData)
 
-  // table-layout: auto, enum, inherit
-  if (eCSSUnit_Enumerated == tableData.mLayout.GetUnit())
-    table->mLayoutStrategy = tableData.mLayout.GetIntValue();
-  else if (eCSSUnit_Auto == tableData.mLayout.GetUnit() ||
-           eCSSUnit_Initial == tableData.mLayout.GetUnit())
-    table->mLayoutStrategy = NS_STYLE_TABLE_LAYOUT_AUTO;
-  else if (eCSSUnit_Inherit == tableData.mLayout.GetUnit()) {
-    inherited = PR_TRUE;
-    table->mLayoutStrategy = parentTable->mLayoutStrategy;
-  }
+  // table-layout: auto, enum, inherit, initial
+  SetDiscrete(tableData.mLayout, table->mLayoutStrategy, inherited,
+              SETDSC_ENUMERATED | SETDSC_AUTO,
+              parentTable->mLayoutStrategy,
+              NS_STYLE_TABLE_LAYOUT_AUTO,
+              NS_STYLE_TABLE_LAYOUT_AUTO, 0, 0, 0);
 
   // rules: enum (not a real CSS prop)
   if (eCSSUnit_Enumerated == tableData.mRules.GetUnit())
     table->mRules = tableData.mRules.GetIntValue();
 
@@ -4276,58 +4163,36 @@ nsRuleNode::ComputeTableBorderData(void*
                                    const RuleDetail aRuleDetail, PRBool aInherited)
 {
   COMPUTE_START_INHERITED(TableBorder, (mPresContext), table, parentTable,
                           Table, tableData)
 
-  // border-collapse: enum, inherit
-  if (eCSSUnit_Enumerated == tableData.mBorderCollapse.GetUnit()) {
-    table->mBorderCollapse = tableData.mBorderCollapse.GetIntValue();
-  }
-  else if (eCSSUnit_Inherit == tableData.mBorderCollapse.GetUnit()) {
-    inherited = PR_TRUE;
-    table->mBorderCollapse = parentTable->mBorderCollapse;
-  }
-  else if (eCSSUnit_Initial == tableData.mBorderCollapse.GetUnit()) {
-    table->mBorderCollapse = NS_STYLE_BORDER_SEPARATE;
-  }
+  // border-collapse: enum, inherit, initial
+  SetDiscrete(tableData.mBorderCollapse, table->mBorderCollapse, inherited,
+              SETDSC_ENUMERATED, parentTable->mBorderCollapse,
+              NS_STYLE_BORDER_SEPARATE, 0, 0, 0, 0);
 
   // border-spacing-x: length, inherit
   SetCoord(tableData.mBorderSpacing.mXValue, table->mBorderSpacingX,
            parentTable->mBorderSpacingX, SETCOORD_LH | SETCOORD_INITIAL_ZERO,
            aContext, mPresContext, inherited);
   // border-spacing-y: length, inherit
   SetCoord(tableData.mBorderSpacing.mYValue, table->mBorderSpacingY,
            parentTable->mBorderSpacingY, SETCOORD_LH | SETCOORD_INITIAL_ZERO,
            aContext, mPresContext, inherited);
 
-  // caption-side: enum, inherit
-  if (eCSSUnit_Enumerated == tableData.mCaptionSide.GetUnit()) {
-    table->mCaptionSide = tableData.mCaptionSide.GetIntValue();
-  }
-  else if (eCSSUnit_Inherit == tableData.mCaptionSide.GetUnit()) {
-    inherited = PR_TRUE;
-    table->mCaptionSide = parentTable->mCaptionSide;
-  }
-  else if (eCSSUnit_Initial == tableData.mCaptionSide.GetUnit()) {
-    table->mCaptionSide = NS_STYLE_CAPTION_SIDE_TOP;
-  }
-
-  // empty-cells: enum, inherit
-  if (eCSSUnit_Enumerated == tableData.mEmptyCells.GetUnit()) {
-    table->mEmptyCells = tableData.mEmptyCells.GetIntValue();
-  }
-  else if (eCSSUnit_Inherit == tableData.mEmptyCells.GetUnit()) {
-    inherited = PR_TRUE;
-    table->mEmptyCells = parentTable->mEmptyCells;
-  }
-  else if (eCSSUnit_Initial == tableData.mEmptyCells.GetUnit()) {
-    table->mEmptyCells =
-      (mPresContext->CompatibilityMode() == eCompatibility_NavQuirks)
-        ? NS_STYLE_TABLE_EMPTY_CELLS_SHOW_BACKGROUND     
-        : NS_STYLE_TABLE_EMPTY_CELLS_SHOW;
-
-  }
+  // caption-side: enum, inherit, initial
+  SetDiscrete(tableData.mCaptionSide, table->mCaptionSide, inherited,
+              SETDSC_ENUMERATED, parentTable->mCaptionSide,
+              NS_STYLE_CAPTION_SIDE_TOP, 0, 0, 0, 0);
+
+  // empty-cells: enum, inherit, initial
+  SetDiscrete(tableData.mEmptyCells, table->mEmptyCells, inherited,
+              SETDSC_ENUMERATED, parentTable->mEmptyCells,
+              (mPresContext->CompatibilityMode() == eCompatibility_NavQuirks)
+              ? NS_STYLE_TABLE_EMPTY_CELLS_SHOW_BACKGROUND     
+              : NS_STYLE_TABLE_EMPTY_CELLS_SHOW,
+              0, 0, 0, 0);
 
   COMPUTE_END_INHERITED(TableBorder, table)
 }
 
 const void* 
@@ -4574,79 +4439,38 @@ nsRuleNode::ComputeXULData(void* aStartS
                            nsRuleNode* aHighestNode,
                            const RuleDetail aRuleDetail, PRBool aInherited)
 {
   COMPUTE_START_RESET(XUL, (), xul, parentXUL, XUL, xulData)
 
-  // box-align: enum, inherit
-  if (eCSSUnit_Enumerated == xulData.mBoxAlign.GetUnit()) {
-    xul->mBoxAlign = xulData.mBoxAlign.GetIntValue();
-  }
-  else if (eCSSUnit_Inherit == xulData.mBoxAlign.GetUnit()) {
-    inherited = PR_TRUE;
-    xul->mBoxAlign = parentXUL->mBoxAlign;
-  }
-  else if (eCSSUnit_Initial == xulData.mBoxAlign.GetUnit()) {
-    xul->mBoxAlign = NS_STYLE_BOX_ALIGN_STRETCH;
-  }
-
-  // box-direction: enum, inherit
-  if (eCSSUnit_Enumerated == xulData.mBoxDirection.GetUnit()) {
-    xul->mBoxDirection = xulData.mBoxDirection.GetIntValue();
-  }
-  else if (eCSSUnit_Inherit == xulData.mBoxDirection.GetUnit()) {
-    inherited = PR_TRUE;
-    xul->mBoxDirection = parentXUL->mBoxDirection;
-  }
-  else if (eCSSUnit_Initial == xulData.mBoxDirection.GetUnit()) {
-    xul->mBoxDirection = NS_STYLE_BOX_DIRECTION_NORMAL;
-  }
+  // box-align: enum, inherit, initial
+  SetDiscrete(xulData.mBoxAlign, xul->mBoxAlign, inherited,
+              SETDSC_ENUMERATED, parentXUL->mBoxAlign,
+              NS_STYLE_BOX_ALIGN_STRETCH, 0, 0, 0, 0);
+
+  // box-direction: enum, inherit, initial
+  SetDiscrete(xulData.mBoxDirection, xul->mBoxDirection, inherited,
+              SETDSC_ENUMERATED, parentXUL->mBoxDirection,
+              NS_STYLE_BOX_DIRECTION_NORMAL, 0, 0, 0, 0);
 
   // box-flex: factor, inherit
-  if (eCSSUnit_Number == xulData.mBoxFlex.GetUnit()) {
-    xul->mBoxFlex = xulData.mBoxFlex.GetFloatValue();
-  }
-  else if (eCSSUnit_Inherit == xulData.mBoxFlex.GetUnit()) {
-    inherited = PR_TRUE;
-    xul->mBoxFlex = parentXUL->mBoxFlex;
-  }
-  else if (eCSSUnit_Initial == xulData.mBoxFlex.GetUnit()) {
-    xul->mBoxFlex = 0.0f;
-  }
-
-  // box-orient: enum, inherit
-  if (eCSSUnit_Enumerated == xulData.mBoxOrient.GetUnit()) {
-    xul->mBoxOrient = xulData.mBoxOrient.GetIntValue();
-  }
-  else if (eCSSUnit_Inherit == xulData.mBoxOrient.GetUnit()) {
-    inherited = PR_TRUE;
-    xul->mBoxOrient = parentXUL->mBoxOrient;
-  }
-  else if (eCSSUnit_Initial == xulData.mBoxOrient.GetUnit()) {
-    xul->mBoxOrient = NS_STYLE_BOX_ORIENT_HORIZONTAL;
-  }
-
-  // box-pack: enum, inherit
-  if (eCSSUnit_Enumerated == xulData.mBoxPack.GetUnit()) {
-    xul->mBoxPack = xulData.mBoxPack.GetIntValue();
-  }
-  else if (eCSSUnit_Inherit == xulData.mBoxPack.GetUnit()) {
-    inherited = PR_TRUE;
-    xul->mBoxPack = parentXUL->mBoxPack;
-  }
-  else if (eCSSUnit_Initial == xulData.mBoxPack.GetUnit()) {
-    xul->mBoxPack = NS_STYLE_BOX_PACK_START;
-  }
-
-  // box-ordinal-group: integer
-  if (eCSSUnit_Integer == xulData.mBoxOrdinal.GetUnit()) {
-    xul->mBoxOrdinal = xulData.mBoxOrdinal.GetIntValue();
-  } else if (eCSSUnit_Inherit == xulData.mBoxOrdinal.GetUnit()) {
-    inherited = PR_TRUE;
-    xul->mBoxOrdinal = parentXUL->mBoxOrdinal;
-  } else if (eCSSUnit_Initial == xulData.mBoxOrdinal.GetUnit()) {
-    xul->mBoxOrdinal = 1;
-  }
+  SetFactor(xulData.mBoxFlex, xul->mBoxFlex, inherited,
+            parentXUL->mBoxFlex, 0.0f);
+
+  // box-orient: enum, inherit, initial
+  SetDiscrete(xulData.mBoxOrient, xul->mBoxOrient, inherited,
+              SETDSC_ENUMERATED, parentXUL->mBoxOrient,
+              NS_STYLE_BOX_ORIENT_HORIZONTAL, 0, 0, 0, 0);
+
+  // box-pack: enum, inherit, initial
+  SetDiscrete(xulData.mBoxPack, xul->mBoxPack, inherited,
+              SETDSC_ENUMERATED, parentXUL->mBoxPack,
+              NS_STYLE_BOX_PACK_START, 0, 0, 0, 0);
+
+  // box-ordinal-group: integer, inherit, initial
+  SetDiscrete(xulData.mBoxOrdinal, xul->mBoxOrdinal, inherited,
+              SETDSC_INTEGER, parentXUL->mBoxOrdinal, 1,
+              0, 0, 0, 0);
 
   if (eCSSUnit_Inherit == xulData.mStackSizing.GetUnit()) {
     inherited = PR_TRUE;
     xul->mStretchStack = parentXUL->mStretchStack;
   } else if (eCSSUnit_Initial == xulData.mStackSizing.GetUnit()) {
@@ -4783,97 +4607,51 @@ SetSVGPaint(const nsCSSValuePair& aValue
     aResult.SetType(eStyleSVGPaintType_Color);
     aResult.mPaint.mColor = color;
   }
 }
 
-static void
-SetSVGOpacity(const nsCSSValue& aValue, float parentOpacity, float& opacity, PRBool& aInherited)
-{
-  if (aValue.GetUnit() == eCSSUnit_Inherit) {
-    opacity = parentOpacity;
-    aInherited = PR_TRUE;
-  }
-  else if (aValue.GetUnit() == eCSSUnit_Number) {
-    opacity = aValue.GetFloatValue();
-    opacity = PR_MAX(opacity, 0.0f);
-    opacity = PR_MIN(opacity, 1.0f);
-  }
-  else if (aValue.GetUnit() == eCSSUnit_Initial) {
-    opacity = 1.0f;
-  }
-}
-
 const void* 
 nsRuleNode::ComputeSVGData(void* aStartStruct,
                            const nsRuleDataStruct& aData, 
                            nsStyleContext* aContext, 
                            nsRuleNode* aHighestNode,
                            const RuleDetail aRuleDetail, PRBool aInherited)
 {
   COMPUTE_START_INHERITED(SVG, (), svg, parentSVG, SVG, SVGData)
 
-  // clip-rule: enum, inherit
-  if (eCSSUnit_Enumerated == SVGData.mClipRule.GetUnit()) {
-    svg->mClipRule = SVGData.mClipRule.GetIntValue();
-  }
-  else if (eCSSUnit_Inherit == SVGData.mClipRule.GetUnit()) {
-    inherited = PR_TRUE;
-    svg->mClipRule = parentSVG->mClipRule;
-  }
-  else if (eCSSUnit_Initial == SVGData.mClipRule.GetUnit()) {
-    svg->mClipRule = NS_STYLE_FILL_RULE_NONZERO;
-  }
-
-  // color-interpolation: auto, sRGB, linearRGB, inherit
-  if (eCSSUnit_Enumerated == SVGData.mColorInterpolation.GetUnit()) {
-    svg->mColorInterpolation = SVGData.mColorInterpolation.GetIntValue();
-  }
-  else if (eCSSUnit_Auto == SVGData.mColorInterpolation.GetUnit()) {
-    svg->mColorInterpolation = NS_STYLE_COLOR_INTERPOLATION_AUTO;
-  }
-  else if (eCSSUnit_Inherit == SVGData.mColorInterpolation.GetUnit()) {
-    inherited = PR_TRUE;
-    svg->mColorInterpolation = parentSVG->mColorInterpolation;
-  }
-  else if (eCSSUnit_Initial == SVGData.mColorInterpolation.GetUnit()) {
-    svg->mColorInterpolation = NS_STYLE_COLOR_INTERPOLATION_SRGB;
-  }
-
-  // color-interpolation-filters: auto, sRGB, linearRGB, inherit
-  if (eCSSUnit_Enumerated == SVGData.mColorInterpolationFilters.GetUnit()) {
-    svg->mColorInterpolationFilters = SVGData.mColorInterpolationFilters.GetIntValue();
-  }
-  else if (eCSSUnit_Auto == SVGData.mColorInterpolationFilters.GetUnit()) {
-    svg->mColorInterpolationFilters = NS_STYLE_COLOR_INTERPOLATION_AUTO;
-  }
-  else if (eCSSUnit_Inherit == SVGData.mColorInterpolationFilters.GetUnit()) {
-    inherited = PR_TRUE;
-    svg->mColorInterpolationFilters = parentSVG->mColorInterpolationFilters;
-  }
-  else if (eCSSUnit_Initial == SVGData.mColorInterpolationFilters.GetUnit()) {
-    svg->mColorInterpolationFilters = NS_STYLE_COLOR_INTERPOLATION_LINEARRGB;
-  }
+  // clip-rule: enum, inherit, initial
+  SetDiscrete(SVGData.mClipRule, svg->mClipRule, inherited,
+              SETDSC_ENUMERATED, parentSVG->mClipRule,
+              NS_STYLE_FILL_RULE_NONZERO, 0, 0, 0, 0);
+
+  // color-interpolation: enum, auto, inherit, initial
+  SetDiscrete(SVGData.mColorInterpolation, svg->mColorInterpolation, inherited,
+              SETDSC_ENUMERATED | SETDSC_AUTO,
+              parentSVG->mColorInterpolation,
+              NS_STYLE_COLOR_INTERPOLATION_SRGB,
+              NS_STYLE_COLOR_INTERPOLATION_AUTO, 0, 0, 0);
+
+  // color-interpolation-filters: enum, auto, inherit, initial
+  SetDiscrete(SVGData.mColorInterpolationFilters,
+              svg->mColorInterpolationFilters, inherited,
+              SETDSC_ENUMERATED | SETDSC_AUTO,
+              parentSVG->mColorInterpolationFilters,
+              NS_STYLE_COLOR_INTERPOLATION_LINEARRGB,
+              NS_STYLE_COLOR_INTERPOLATION_AUTO, 0, 0, 0);
 
   // fill: 
   SetSVGPaint(SVGData.mFill, parentSVG->mFill, mPresContext, aContext,
               svg->mFill, eStyleSVGPaintType_Color, inherited);
 
-  // fill-opacity:
-  SetSVGOpacity(SVGData.mFillOpacity, parentSVG->mFillOpacity,
-                svg->mFillOpacity, inherited);
-
-  // fill-rule: enum, inherit
-  if (eCSSUnit_Enumerated == SVGData.mFillRule.GetUnit()) {
-    svg->mFillRule = SVGData.mFillRule.GetIntValue();
-  }
-  else if (eCSSUnit_Inherit == SVGData.mFillRule.GetUnit()) {
-    inherited = PR_TRUE;
-    svg->mFillRule = parentSVG->mFillRule;
-  }
-  else if (eCSSUnit_Initial == SVGData.mFillRule.GetUnit()) {
-    svg->mFillRule = NS_STYLE_FILL_RULE_NONZERO;
-  }
+  // fill-opacity: factor, inherit, initial
+  SetFactor(SVGData.mFillOpacity, svg->mFillOpacity, inherited,
+            parentSVG->mFillOpacity, 1.0f, SETFCT_OPACITY);
+
+  // fill-rule: enum, inherit, initial
+  SetDiscrete(SVGData.mFillRule, svg->mFillRule, inherited,
+              SETDSC_ENUMERATED, parentSVG->mFillRule,
+              NS_STYLE_FILL_RULE_NONZERO, 0, 0, 0, 0);
 
   // marker-end: url, none, inherit
   if (eCSSUnit_URL == SVGData.mMarkerEnd.GetUnit()) {
     svg->mMarkerEnd = SVGData.mMarkerEnd.GetURLValue();
   } else if (eCSSUnit_None == SVGData.mMarkerEnd.GetUnit() ||
@@ -4904,34 +4682,22 @@ nsRuleNode::ComputeSVGData(void* aStartS
   } else if (eCSSUnit_Inherit == SVGData.mMarkerStart.GetUnit()) {
     inherited = PR_TRUE;
     svg->mMarkerStart = parentSVG->mMarkerStart;
   }
 
-  // pointer-events: enum, inherit
-  if (eCSSUnit_Enumerated == SVGData.mPointerEvents.GetUnit()) {
-    svg->mPointerEvents = SVGData.mPointerEvents.GetIntValue();
-  } else if (eCSSUnit_None == SVGData.mPointerEvents.GetUnit()) {
-    svg->mPointerEvents = NS_STYLE_POINTER_EVENTS_NONE;
-  } else if (eCSSUnit_Inherit == SVGData.mPointerEvents.GetUnit()) {
-    inherited = PR_TRUE;
-    svg->mPointerEvents = parentSVG->mPointerEvents;
-  } else if (eCSSUnit_Initial == SVGData.mPointerEvents.GetUnit()) {
-    svg->mPointerEvents = NS_STYLE_POINTER_EVENTS_VISIBLEPAINTED;
-  }
+  // pointer-events: enum, none, inherit, initial
+  SetDiscrete(SVGData.mPointerEvents, svg->mPointerEvents, inherited,
+              SETDSC_ENUMERATED | SETDSC_NONE, parentSVG->mPointerEvents,
+              NS_STYLE_POINTER_EVENTS_VISIBLEPAINTED, 0,
+              NS_STYLE_POINTER_EVENTS_NONE, 0, 0);
 
   // shape-rendering: enum, auto, inherit
-  if (eCSSUnit_Enumerated == SVGData.mShapeRendering.GetUnit()) {
-    svg->mShapeRendering = SVGData.mShapeRendering.GetIntValue();
-  }
-  else if (eCSSUnit_Auto == SVGData.mShapeRendering.GetUnit() ||
-           eCSSUnit_Initial == SVGData.mShapeRendering.GetUnit()) {
-    svg->mShapeRendering = NS_STYLE_SHAPE_RENDERING_AUTO;
-  }
-  else if (eCSSUnit_Inherit == SVGData.mShapeRendering.GetUnit()) {
-    inherited = PR_TRUE;
-    svg->mShapeRendering = parentSVG->mShapeRendering;
-  }
+  SetDiscrete(SVGData.mShapeRendering, svg->mShapeRendering, inherited,
+              SETDSC_ENUMERATED | SETDSC_AUTO,
+              parentSVG->mShapeRendering,
+              NS_STYLE_SHAPE_RENDERING_AUTO, 
+              NS_STYLE_SHAPE_RENDERING_AUTO, 0, 0, 0);
 
   // stroke: 
   SetSVGPaint(SVGData.mStroke, parentSVG->mStroke, mPresContext, aContext,
               svg->mStroke, eStyleSVGPaintType_None, inherited);
 
@@ -4992,49 +4758,27 @@ nsRuleNode::ComputeSVGData(void* aStartS
   SetCoord(SVGData.mStrokeDashoffset,
            svg->mStrokeDashoffset, parentSVG->mStrokeDashoffset,
            SETCOORD_LPH | SETCOORD_FACTOR | SETCOORD_INITIAL_ZERO,
            aContext, mPresContext, inherited);
 
-  // stroke-linecap: enum, inherit
-  if (eCSSUnit_Enumerated == SVGData.mStrokeLinecap.GetUnit()) {
-    svg->mStrokeLinecap = SVGData.mStrokeLinecap.GetIntValue();
-  }
-  else if (eCSSUnit_Inherit == SVGData.mStrokeLinecap.GetUnit()) {
-    inherited = PR_TRUE;
-    svg->mStrokeLinecap = parentSVG->mStrokeLinecap;
-  }
-  else if (eCSSUnit_Initial == SVGData.mStrokeLinecap.GetUnit()) {
-    svg->mStrokeLinecap = NS_STYLE_STROKE_LINECAP_BUTT;
-  }
-
-  // stroke-linejoin: enum, inherit
-  if (eCSSUnit_Enumerated == SVGData.mStrokeLinejoin.GetUnit()) {
-    svg->mStrokeLinejoin = SVGData.mStrokeLinejoin.GetIntValue();
-  }
-  else if (eCSSUnit_Inherit == SVGData.mStrokeLinejoin.GetUnit()) {
-    inherited = PR_TRUE;
-    svg->mStrokeLinejoin = parentSVG->mStrokeLinejoin;
-  }
-  else if (eCSSUnit_Initial == SVGData.mStrokeLinejoin.GetUnit()) {
-    svg->mStrokeLinejoin = NS_STYLE_STROKE_LINEJOIN_MITER;
-  }
+  // stroke-linecap: enum, inherit, initial
+  SetDiscrete(SVGData.mStrokeLinecap, svg->mStrokeLinecap, inherited,
+              SETDSC_ENUMERATED, parentSVG->mStrokeLinecap,
+              NS_STYLE_STROKE_LINECAP_BUTT, 0, 0, 0, 0);
+
+  // stroke-linejoin: enum, inherit, initial
+  SetDiscrete(SVGData.mStrokeLinejoin, svg->mStrokeLinejoin, inherited,
+              SETDSC_ENUMERATED, parentSVG->mStrokeLinejoin,
+              NS_STYLE_STROKE_LINEJOIN_MITER, 0, 0, 0, 0);
 
   // stroke-miterlimit: <miterlimit>, inherit
-  if (eCSSUnit_Number == SVGData.mStrokeMiterlimit.GetUnit()) {
-    svg->mStrokeMiterlimit = SVGData.mStrokeMiterlimit.GetFloatValue();
-  }
-  else if (eCSSUnit_Inherit == SVGData.mStrokeMiterlimit.GetUnit()) {
-    svg->mStrokeMiterlimit = parentSVG->mStrokeMiterlimit;
-    inherited = PR_TRUE;
-  }
-  else if (eCSSUnit_Initial == SVGData.mStrokeMiterlimit.GetUnit()) {
-    svg->mStrokeMiterlimit = 4.0f;
-  }
+  SetFactor(SVGData.mStrokeMiterlimit, svg->mStrokeMiterlimit, inherited,
+            parentSVG->mStrokeMiterlimit, 4.0f);
 
   // stroke-opacity:
-  SetSVGOpacity(SVGData.mStrokeOpacity, parentSVG->mStrokeOpacity,
-                svg->mStrokeOpacity, inherited);  
+  SetFactor(SVGData.mStrokeOpacity, svg->mStrokeOpacity, inherited,
+            parentSVG->mStrokeOpacity, 1.0f, SETFCT_OPACITY);
 
   // stroke-width:
   if (eCSSUnit_Initial == SVGData.mStrokeWidth.GetUnit()) {
     svg->mStrokeWidth.SetCoordValue(nsPresContext::CSSPixelsToAppUnits(1));
   } else {
@@ -5042,34 +4786,21 @@ nsRuleNode::ComputeSVGData(void* aStartS
              svg->mStrokeWidth, parentSVG->mStrokeWidth,
              SETCOORD_LPH | SETCOORD_FACTOR,
              aContext, mPresContext, inherited);
   }
 
-  // text-anchor: enum, inherit
-  if (eCSSUnit_Enumerated == SVGData.mTextAnchor.GetUnit()) {
-    svg->mTextAnchor = SVGData.mTextAnchor.GetIntValue();
-  }
-  else if (eCSSUnit_Inherit == SVGData.mTextAnchor.GetUnit()) {
-    inherited = PR_TRUE;
-    svg->mTextAnchor = parentSVG->mTextAnchor;
-  }
-  else if (eCSSUnit_Initial == SVGData.mTextAnchor.GetUnit()) {
-    svg->mTextAnchor = NS_STYLE_TEXT_ANCHOR_START;
-  }
-  
-  // text-rendering: enum, auto, inherit
-  if (eCSSUnit_Enumerated == SVGData.mTextRendering.GetUnit()) {
-    svg->mTextRendering = SVGData.mTextRendering.GetIntValue();
-  }
-  else if (eCSSUnit_Auto == SVGData.mTextRendering.GetUnit() ||
-           eCSSUnit_Initial == SVGData.mTextRendering.GetUnit()) {
-    svg->mTextRendering = NS_STYLE_TEXT_RENDERING_AUTO;
-  }
-  else if (eCSSUnit_Inherit == SVGData.mTextRendering.GetUnit()) {
-    inherited = PR_TRUE;
-    svg->mTextRendering = parentSVG->mTextRendering;
-  }
+  // text-anchor: enum, inherit, initial
+  SetDiscrete(SVGData.mTextAnchor, svg->mTextAnchor, inherited,
+              SETDSC_ENUMERATED, parentSVG->mTextAnchor,
+              NS_STYLE_TEXT_ANCHOR_START, 0, 0, 0, 0);
+  
+  // text-rendering: enum, auto, inherit, initial
+  SetDiscrete(SVGData.mTextRendering, svg->mTextRendering, inherited,
+              SETDSC_ENUMERATED | SETDSC_AUTO,
+              parentSVG->mTextRendering,
+              NS_STYLE_TEXT_RENDERING_AUTO,
+              NS_STYLE_TEXT_RENDERING_AUTO, 0, 0, 0);
 
   COMPUTE_END_INHERITED(SVG, svg)
 }
 
 const void* 
@@ -5115,29 +4846,24 @@ nsRuleNode::ComputeSVGResetData(void* aS
     inherited = PR_TRUE;
     svgReset->mClipPath = parentSVGReset->mClipPath;
   }
 
   // stop-opacity:
-  SetSVGOpacity(SVGData.mStopOpacity, parentSVGReset->mStopOpacity,
-                svgReset->mStopOpacity, inherited);
+  SetFactor(SVGData.mStopOpacity, svgReset->mStopOpacity, inherited,
+            parentSVGReset->mStopOpacity, 1.0f, SETFCT_OPACITY);
 
   // flood-opacity:
-  SetSVGOpacity(SVGData.mFloodOpacity, parentSVGReset->mFloodOpacity,
-                svgReset->mFloodOpacity, inherited);
-
-  // dominant-baseline: enum, auto, inherit
-  if (eCSSUnit_Enumerated == SVGData.mDominantBaseline.GetUnit()) {
-    svgReset->mDominantBaseline = SVGData.mDominantBaseline.GetIntValue();
-  }
-  else if (eCSSUnit_Auto == SVGData.mDominantBaseline.GetUnit() ||
-           eCSSUnit_Initial == SVGData.mDominantBaseline.GetUnit()) {
-    svgReset->mDominantBaseline = NS_STYLE_DOMINANT_BASELINE_AUTO;
-  }
-  else if (eCSSUnit_Inherit == SVGData.mDominantBaseline.GetUnit()) {
-    inherited = PR_TRUE;
-    svgReset->mDominantBaseline = parentSVGReset->mDominantBaseline;
-  }
+  SetFactor(SVGData.mFloodOpacity, svgReset->mFloodOpacity, inherited,
+            parentSVGReset->mFloodOpacity, 1.0f, SETFCT_OPACITY);
+
+  // dominant-baseline: enum, auto, inherit, initial
+  SetDiscrete(SVGData.mDominantBaseline, svgReset->mDominantBaseline,
+              inherited,
+              SETDSC_ENUMERATED | SETDSC_AUTO,
+              parentSVGReset->mDominantBaseline,
+              NS_STYLE_DOMINANT_BASELINE_AUTO,
+              NS_STYLE_DOMINANT_BASELINE_AUTO, 0, 0, 0);
 
   // filter: url, none, inherit
   if (eCSSUnit_URL == SVGData.mFilter.GetUnit()) {
     svgReset->mFilter = SVGData.mFilter.GetURLValue();
   } else if (eCSSUnit_None == SVGData.mFilter.GetUnit() ||
diff -r 14ce7619e9c1 layout/style/nsStyleStruct.h
--- a/layout/style/nsStyleStruct.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/style/nsStyleStruct.h	Mon Sep 08 10:35:46 2008 +0300
@@ -159,20 +159,16 @@ struct nsStyleBackground {
   nsChangeHint CalcDifference(const nsStyleBackground& aOther) const;
 #ifdef DEBUG
   static nsChangeHint MaxDifference();
 #endif
 
-  // On Linux (others?), there is an extra byte being used up by
-  // inheritance so we only have 3 bytes to fit these 6 things into.
-  // Fortunately, the properties are enums which have few possible
-  // values.
-  PRUint8 mBackgroundFlags;            // [reset] See nsStyleConsts.h
-  PRUint8 mBackgroundAttachment   : 4; // [reset] See nsStyleConsts.h
-  PRUint8 mBackgroundClip         : 3; // [reset] See nsStyleConsts.h
-  PRUint8 mBackgroundInlinePolicy : 2; // [reset] See nsStyleConsts.h
-  PRUint8 mBackgroundOrigin       : 3; // [reset] See nsStyleConsts.h
-  PRUint8 mBackgroundRepeat       : 4; // [reset] See nsStyleConsts.h
+  PRUint8 mBackgroundFlags;        // [reset] See nsStyleConsts.h
+  PRUint8 mBackgroundAttachment;   // [reset] See nsStyleConsts.h
+  PRUint8 mBackgroundClip;         // [reset] See nsStyleConsts.h
+  PRUint8 mBackgroundInlinePolicy; // [reset] See nsStyleConsts.h
+  PRUint8 mBackgroundOrigin;       // [reset] See nsStyleConsts.h
+  PRUint8 mBackgroundRepeat;       // [reset] See nsStyleConsts.h
 
   // Note: a member of this union is valid IFF the appropriate bit flag
   // is set in mBackgroundFlags.
   union {
     nscoord mCoord;
diff -r 14ce7619e9c1 layout/style/test/test_media_queries.html
--- a/layout/style/test/test_media_queries.html	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/style/test/test_media_queries.html	Mon Sep 08 10:35:46 2008 +0300
@@ -101,20 +101,10 @@ function run() {
   function expression_should_not_be_parseable(e) {
     ok(!expression_is_parseable(e),
        "expression " + e + " should not be parseable");
   }
 
-  function todo_expression_should_be_parseable(e) {
-    todo(expression_is_parseable(e),
-         "expression " + e + " should be parseable");
-  }
-
-  function todo_expression_should_not_be_parseable(e) {
-    todo(!expression_is_parseable(e),
-         "expression " + e + " should not be parseable");
-  }
-
   // The no-type syntax doesn't mix with the not and only keywords.
   query_should_be_parseable("(orientation)");
   query_should_not_be_parseable("not (orientation)");
   query_should_not_be_parseable("only (orientation)");
   query_should_be_parseable("all and (orientation)");
@@ -137,10 +127,12 @@ function run() {
     expression_should_not_be_parseable(feature + ": -1px");
     expression_should_not_be_parseable("min-" + feature + ": -1px");
     expression_should_not_be_parseable("max-" + feature + ": -1px");
     expression_should_not_be_parseable(feature + ": -0.00001mm");
     expression_should_not_be_parseable(feature + ": -100000em");
+    expression_should_not_be_parseable("min-" + feature);
+    expression_should_not_be_parseable("max-" + feature);
   }
 
   var content_div = document.getElementById("content");
   content_div.style.font = "-moz-initial";
   var em_size =
@@ -175,26 +167,24 @@ function run() {
                  (Math.ceil(value/em_size) + 1) + "em)");
     should_not_apply("all and (max-" + feature + ": " +
                      (Math.floor(value/em_size) - 1) + "em)");
   }
 
-  // FIXME: The TODOs in this section are because the spec is still a
-  // bit unclear here.  Until I'm sure that the spec is really asking
-  // for the more complex implementation, I'm going to stick with the
-  // simpler one.  See
-  // http://lists.w3.org/Archives/Public/www-style/2008Jun/0212.html
+  // TODO:  There are a bunch of todos here because of a bug related
+  // to dynamic changes not going into effect once one dimension is 0.
+  // (Patch to fix this is in bug 453759.)
   iframe_style.width = "0";
   should_apply("all and (height)");
-  todo_should_not_apply("all and (width)");
+  should_not_apply("all and (width)");
   iframe_style.height = "0";
   todo_should_not_apply("all and (height)");
-  todo_should_not_apply("all and (width)");
+  should_not_apply("all and (width)");
   should_apply("all and (device-height)");
   should_apply("all and (device-width)");
   iframe_style.width = width_val + "px";
   todo_should_not_apply("all and (height)");
-  should_apply("all and (width)");
+  todo_should_apply("all and (width)");
   iframe_style.height = height_val + "px";
   should_apply("all and (height)");
   should_apply("all and (width)");
 
   // ratio that reduces to 59/40
@@ -230,22 +220,25 @@ function run() {
   should_apply("(aspect-ratio: 5900/8000)");
   should_not_apply("(aspect-ratio: 5901/8000)");
   should_not_apply("(aspect-ratio: 5899/8000)");
   should_not_apply("(aspect-ratio: 5900/8001)");
   should_not_apply("(aspect-ratio: 5900/7999)");
+  should_apply("(aspect-ratio)");
 
   should_apply("(min-aspect-ratio: 59/80)");
   should_apply("(min-aspect-ratio: 58/80)");
   should_apply("(min-aspect-ratio: 59/81)");
   should_not_apply("(min-aspect-ratio: 60/80)");
   should_not_apply("(min-aspect-ratio: 59/79)");
+  expression_should_not_be_parseable("min-aspect-ratio");
 
   should_apply("(max-aspect-ratio: 59/80)");
   should_not_apply("(max-aspect-ratio: 58/80)");
   should_not_apply("(max-aspect-ratio: 59/81)");
   should_apply("(max-aspect-ratio: 60/80)");
   should_apply("(max-aspect-ratio: 59/79)");
+  expression_should_not_be_parseable("max-aspect-ratio");
 
   let real_dar = device_width + "/" + device_height;
   let high_dar_1 = (device_width + 1) + "/" + device_height;
   let high_dar_2 = device_width + "/" + (device_height - 1);
   let low_dar_1 = (device_width - 1) + "/" + device_height;
@@ -253,22 +246,25 @@ function run() {
   should_apply("(device-aspect-ratio: " + real_dar + ")");
   should_apply("not all and (device-aspect-ratio: " + high_dar_1 + ")");
   should_not_apply("all and (device-aspect-ratio: " + high_dar_2 + ")");
   should_not_apply("all and (device-aspect-ratio: " + low_dar_1 + ")");
   should_apply("not all and (device-aspect-ratio: " + low_dar_2 + ")");
+  should_apply("(device-aspect-ratio)");
 
   should_apply("(min-device-aspect-ratio: " + real_dar + ")");
   should_not_apply("all and (min-device-aspect-ratio: " + high_dar_1 + ")");
   should_apply("not all and (min-device-aspect-ratio: " + high_dar_2 + ")");
   should_not_apply("not all and (min-device-aspect-ratio: " + low_dar_1 + ")");
   should_apply("all and (min-device-aspect-ratio: " + low_dar_2 + ")");
+  expression_should_not_be_parseable("min-device-aspect-ratio");
 
   should_apply("all and (max-device-aspect-ratio: " + real_dar + ")");
   should_apply("(max-device-aspect-ratio: " + high_dar_1 + ")");
   should_apply("(max-device-aspect-ratio: " + high_dar_2 + ")");
   should_not_apply("all and (max-device-aspect-ratio: " + low_dar_1 + ")");
   should_apply("not all and (max-device-aspect-ratio: " + low_dar_2 + ")");
+  expression_should_not_be_parseable("max-device-aspect-ratio");
 
   for each (let feature in [ "max-aspect-ratio", "device-aspect-ratio" ]) {
     expression_should_be_parseable(feature + ": 1/1");
     expression_should_be_parseable(feature + ": 1  /1");
     expression_should_be_parseable(feature + ": 1  / \t\n1");
@@ -310,27 +306,19 @@ function run() {
   should_apply(depth_query("max-", depth));
   should_not_apply(depth_query("max-", depth - 1));
   should_apply(depth_query("max-", depth + 1));
 
   (is_color ? should_apply : should_not_apply)("all and (color)");
-  (is_color ? should_apply : should_not_apply)("all and (max-color)");
-  (is_color ? should_apply : should_not_apply)("all and (min-color)");
+  expression_should_not_be_parseable("max-color");
+  expression_should_not_be_parseable("min-color");
   (is_color ? should_not_apply : should_apply)("all and (monochrome)");
-  (is_color ? should_not_apply : should_apply)("all and (max-monochrome)");
-  (is_color ? should_not_apply : should_apply)("all and (min-monochrome)");
+  expression_should_not_be_parseable("max-monochrome");
+  expression_should_not_be_parseable("min-monochrome");
   (is_color ? should_apply : should_not_apply)("not all and (monochrome)");
-  (is_color ? should_apply : should_not_apply)("not all and (max-monochrome)");
-  (is_color ? should_apply : should_not_apply)("not all and (min-monochrome)");
   (is_color ? should_not_apply : should_apply)("not all and (color)");
-  (is_color ? should_not_apply : should_apply)("not all and (max-color)");
-  (is_color ? should_not_apply : should_apply)("not all and (min-color)");
   (is_color ? should_apply : should_not_apply)("only all and (color)");
-  (is_color ? should_apply : should_not_apply)("only all and (max-color)");
-  (is_color ? should_apply : should_not_apply)("only all and (min-color)");
   (is_color ? should_not_apply : should_apply)("only all and (monochrome)");
-  (is_color ? should_not_apply : should_apply)("only all and (max-monochrome)");
-  (is_color ? should_not_apply : should_apply)("only all and (min-monochrome)");
 
   for each (let feature in [ "color", "min-monochrome", "max-color-index" ]) {
     expression_should_be_parseable(feature + ": 1");
     expression_should_be_parseable(feature + ": 327");
     expression_should_be_parseable(feature + ": 0");
@@ -404,10 +392,11 @@ function run() {
   expression_should_be_parseable("scan: progressive");
   expression_should_be_parseable("scan:interlace");
   expression_should_not_be_parseable("min-scan:interlace");
   expression_should_not_be_parseable("scan: 1");
   expression_should_not_be_parseable("max-scan");
+  expression_should_not_be_parseable("max-scan: progressive");
   // Assume we don't support tv devices.
   should_not_apply("(scan)");
   should_not_apply("(scan: progressive)");
   should_not_apply("(scan: interlace)");
   should_apply("not all and (scan)");
@@ -417,15 +406,14 @@ function run() {
   expression_should_be_parseable("grid");
   expression_should_be_parseable("grid: 0");
   expression_should_be_parseable("grid: 1");
   expression_should_be_parseable("grid: 1");
   expression_should_not_be_parseable("min-grid");
+  expression_should_not_be_parseable("min-grid:0");
   expression_should_not_be_parseable("max-grid: 1");
-  // FIXME: Mark these as todo since the spec isn't clear:
-  // http://lists.w3.org/Archives/Public/www-style/2008Jun/0214.html
-  todo_expression_should_not_be_parseable("grid: 2");
-  todo_expression_should_be_parseable("grid: -1");
+  expression_should_not_be_parseable("grid: 2");
+  expression_should_not_be_parseable("grid: -1");
 
   // Assume we don't support grid devices
   should_not_apply("(grid)");
   should_apply("(grid: 0)");
   should_not_apply("(grid: 1)");
diff -r 14ce7619e9c1 layout/svg/base/src/nsSVGGlyphFrame.cpp
--- a/layout/svg/base/src/nsSVGGlyphFrame.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/svg/base/src/nsSVGGlyphFrame.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -240,23 +240,26 @@ nsSVGGlyphFrame::DidSetStyleContext()
 
 NS_IMETHODIMP
 nsSVGGlyphFrame::SetSelected(nsPresContext* aPresContext,
                              nsIDOMRange*    aRange,
                              PRBool          aSelected,
-                             nsSpread        aSpread)
+                             nsSpread        aSpread,
+                             SelectionType   aType)
 {
 #if defined(DEBUG) && defined(SVG_DEBUG_SELECTION)
   printf("nsSVGGlyphFrame(%p)::SetSelected()\n", this);
 #endif
-//  return nsSVGGlyphFrameBase::SetSelected(aPresContext, aRange, aSelected, aSpread);
+//  return nsSVGGlyphFrameBase::SetSelected(aPresContext, aRange, aSelected, aSpread, aType);
 
-  // check whether style allows selection
-  PRBool  selectable;
-  IsSelectable(&selectable, nsnull);
-  if (!selectable)
-    return NS_OK;
-  
+  if (aType == nsISelectionController::SELECTION_NORMAL) {
+    // check whether style allows selection
+    PRBool  selectable;
+    IsSelectable(&selectable, nsnull);
+    if (!selectable)
+      return NS_OK;
+  }
+
   if ( aSelected ){
     mState |=  NS_FRAME_SELECTED_CONTENT;
   }
   else
     mState &= ~NS_FRAME_SELECTED_CONTENT;
diff -r 14ce7619e9c1 layout/svg/base/src/nsSVGGlyphFrame.h
--- a/layout/svg/base/src/nsSVGGlyphFrame.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/svg/base/src/nsSVGGlyphFrame.h	Mon Sep 08 10:35:46 2008 +0300
@@ -84,11 +84,12 @@ public:
   NS_IMETHOD  DidSetStyleContext();
 
   NS_IMETHOD  SetSelected(nsPresContext* aPresContext,
                           nsIDOMRange*    aRange,
                           PRBool          aSelected,
-                          nsSpread        aSpread);
+                          nsSpread        aSpread,
+                          SelectionType   aType);
   NS_IMETHOD  GetSelected(PRBool *aSelected) const;
   NS_IMETHOD  IsSelectable(PRBool* aIsSelectable, PRUint8* aSelectStyle) const;
 
   /**
    * Get the "type" of the frame
diff -r 14ce7619e9c1 layout/svg/base/src/nsSVGOuterSVGFrame.cpp
--- a/layout/svg/base/src/nsSVGOuterSVGFrame.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/svg/base/src/nsSVGOuterSVGFrame.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -417,11 +417,14 @@ nsSVGOuterSVGFrame::DidReflow(nsPresCont
     UnsuspendRedraw(); // For the SuspendRedraw in InitSVG
   } else {
     // Now that all viewport establishing descendants have their correct size,
     // tell our foreignObject descendants to reflow their children.
     if (mForeignObjectHash.IsInitialized()) {
-      PRUint32 count = mForeignObjectHash.EnumerateEntries(ReflowForeignObject, nsnull);
+#ifdef DEBUG
+      PRUint32 count =
+#endif
+        mForeignObjectHash.EnumerateEntries(ReflowForeignObject, nsnull);
       NS_ASSERTION(count == mForeignObjectHash.Count(),
                    "We didn't reflow all our nsSVGForeignObjectFrames!");
     }
   }
   
diff -r 14ce7619e9c1 layout/tables/crashtests/392132-1.xhtml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/tables/crashtests/392132-1.xhtml	Mon Sep 08 10:35:46 2008 +0300
@@ -0,0 +1,9 @@
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+</head>
+<body>
+
+<span style="border-spacing: 3ch;"><td></td></span>
+
+</body>
+</html>
diff -r 14ce7619e9c1 layout/tables/crashtests/crashtests.list
--- a/layout/tables/crashtests/crashtests.list	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/tables/crashtests/crashtests.list	Mon Sep 08 10:35:46 2008 +0300
@@ -35,10 +35,11 @@ load 385132-2.html
 load 385132-2.html
 load 387051-1.html
 load 388700-1.html
 load 391898-1.html
 load 391901-1.html
+load 392132-1.xhtml
 load 397448-1.html
 load 398157-1.xhtml
 load 399209-1.xhtml
 load 403249-1.html
 load 403579-1.html
diff -r 14ce7619e9c1 layout/tables/nsTableCellFrame.cpp
--- a/layout/tables/nsTableCellFrame.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/tables/nsTableCellFrame.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -491,11 +491,12 @@ nsTableCellFrame::BuildDisplayList(nsDis
 //null range means the whole thing
 NS_IMETHODIMP
 nsTableCellFrame::SetSelected(nsPresContext* aPresContext,
                               nsIDOMRange*    aRange,
                               PRBool          aSelected,
-                              nsSpread        aSpread)
+                              nsSpread        aSpread,
+                              SelectionType   aType)
 {
   //traverse through children unselect tables
 #if 0
   if ((aSpread == eSpreadDown)){
     nsIFrame* kid = GetFirstChild(nsnull);
@@ -507,11 +508,11 @@ nsTableCellFrame::SetSelected(nsPresCont
   //return nsFrame::SetSelected(aRange,aSelected,eSpreadNone);
 #endif
   // Must call base class to set mSelected state and trigger repaint of frame
   // Note that in current version, aRange and aSpread are ignored,
   //   only this frame is considered
-  nsFrame::SetSelected(aPresContext, aRange, aSelected, aSpread);
+  nsFrame::SetSelected(aPresContext, aRange, aSelected, aSpread, aType);
 
   nsCOMPtr<nsFrameSelection> frameSelection =
     aPresContext->PresShell()->FrameSelection();
   if (frameSelection->GetTableCellSelection()) {
     // Selection can affect content, border and outline
diff -r 14ce7619e9c1 layout/tables/nsTableCellFrame.h
--- a/layout/tables/nsTableCellFrame.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/tables/nsTableCellFrame.h	Mon Sep 08 10:35:46 2008 +0300
@@ -128,11 +128,12 @@ public:
                            const nsRect& aDirtyRect, nsPoint aPt);
 
   NS_IMETHOD SetSelected(nsPresContext* aPresContext,
                          nsIDOMRange *aRange,
                          PRBool aSelected,
-                         nsSpread aSpread);
+                         nsSpread aSpread,
+                         SelectionType aType);
 
   virtual nscoord GetMinWidth(nsIRenderingContext *aRenderingContext);
   virtual nscoord GetPrefWidth(nsIRenderingContext *aRenderingContext);
   virtual IntrinsicWidthOffsetData
     IntrinsicWidthOffsets(nsIRenderingContext* aRenderingContext);
diff -r 14ce7619e9c1 layout/tables/nsTableFrame.cpp
--- a/layout/tables/nsTableFrame.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/tables/nsTableFrame.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -1481,11 +1481,12 @@ nsTableFrame::PaintTableBorderBackground
 //null range means the whole thing
 NS_IMETHODIMP
 nsTableFrame::SetSelected(nsPresContext* aPresContext,
                           nsIDOMRange *aRange,
                           PRBool aSelected,
-                          nsSpread aSpread)
+                          nsSpread aSpread,
+                          SelectionType aType)
 {
 #if 0
   //traverse through children unselect tables
   if ((aSpread == eSpreadDown)){
     nsIFrame* kid = GetFirstChild(nsnull);
@@ -1496,12 +1497,12 @@ nsTableFrame::SetSelected(nsPresContext*
   }
 #endif
   // Must call base class to set mSelected state and trigger repaint of frame
   // Note that in current version, aRange and aSpread are ignored,
   //   only this frame is considered
-  nsFrame::SetSelected(aPresContext, aRange, aSelected, aSpread);
-  return NS_OK;//return nsFrame::SetSelected(aRange,aSelected,eSpreadNone);
+  nsFrame::SetSelected(aPresContext, aRange, aSelected, aSpread, aType);
+  return NS_OK;//return nsFrame::SetSelected(aRange,aSelected,eSpreadNone, aType);
   
 }
 
 PRBool nsTableFrame::ParentDisablesSelection() const //override default behavior
 {
diff -r 14ce7619e9c1 layout/tables/nsTableFrame.h
--- a/layout/tables/nsTableFrame.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/tables/nsTableFrame.h	Mon Sep 08 10:35:46 2008 +0300
@@ -313,11 +313,12 @@ public:
   /** nsIFrame method overridden to handle table specifics
   */
   NS_IMETHOD SetSelected(nsPresContext* aPresContext,
                          nsIDOMRange *aRange,
                          PRBool aSelected,
-                         nsSpread aSpread);
+                         nsSpread aSpread,
+                         SelectionType aType);
 
   virtual void MarkIntrinsicWidthsDirty();
   // For border-collapse tables, the caller must not add padding and
   // border to the results of these functions.
   virtual nscoord GetMinWidth(nsIRenderingContext *aRenderingContext);
diff -r 14ce7619e9c1 layout/tables/nsTableOuterFrame.cpp
--- a/layout/tables/nsTableOuterFrame.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/tables/nsTableOuterFrame.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -406,15 +406,16 @@ nsTableOuterFrame::BuildDisplayListForIn
 }
 
 NS_IMETHODIMP nsTableOuterFrame::SetSelected(nsPresContext* aPresContext,
                                              nsIDOMRange *aRange,
                                              PRBool aSelected,
-                                             nsSpread aSpread)
+                                             nsSpread aSpread,
+                                             SelectionType aType)
 {
-  nsresult result = nsFrame::SetSelected(aPresContext, aRange,aSelected, aSpread);
+  nsresult result = nsFrame::SetSelected(aPresContext, aRange,aSelected, aSpread, aType);
   if (NS_SUCCEEDED(result) && mInnerTableFrame)
-    return mInnerTableFrame->SetSelected(aPresContext, aRange,aSelected, aSpread);
+    return mInnerTableFrame->SetSelected(aPresContext, aRange,aSelected, aSpread, aType);
   return result;
 }
 
 NS_IMETHODIMP 
 nsTableOuterFrame::GetParentStyleContextFrame(nsPresContext* aPresContext,
diff -r 14ce7619e9c1 layout/tables/nsTableOuterFrame.h
--- a/layout/tables/nsTableOuterFrame.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/tables/nsTableOuterFrame.h	Mon Sep 08 10:35:46 2008 +0300
@@ -173,11 +173,12 @@ public:
   /** SetSelected needs to be overridden to talk to inner tableframe
    */
   NS_IMETHOD SetSelected(nsPresContext* aPresContext,
                          nsIDOMRange *aRange,
                          PRBool aSelected,
-                         nsSpread aSpread);
+                         nsSpread aSpread,
+                         SelectionType aType);
 
   NS_IMETHOD GetParentStyleContextFrame(nsPresContext* aPresContext,
                                         nsIFrame**      aProviderFrame,
                                         PRBool*         aIsChild);
 
diff -r 14ce7619e9c1 layout/xul/base/src/nsBox.cpp
--- a/layout/xul/base/src/nsBox.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/xul/base/src/nsBox.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -755,12 +755,11 @@ nsIBox::AddCSSMinSize(nsBoxLayoutState& 
         if (min && (!widthSet || (min > aSize.width && canOverride))) {
            aSize.width = min;
            widthSet = PR_TRUE;
         }
     } else if (position->mMinWidth.GetUnit() == eStyleUnit_Percent) {
-        float min = position->mMinWidth.GetPercentValue();
-        NS_ASSERTION(min == 0.0f, "Non-zero percentage values not currently supported");
+        NS_ASSERTION(position->mMinWidth.GetPercentValue() == 0.0f, "Non-zero percentage values not currently supported");
         aSize.width = 0;
         widthSet = PR_TRUE;
     }
     // XXX Handle eStyleUnit_Enumerated?
     // (Handling the eStyleUnit_Enumerated types requires
@@ -772,12 +771,11 @@ nsIBox::AddCSSMinSize(nsBoxLayoutState& 
         if (min && (!heightSet || (min > aSize.height && canOverride))) {
            aSize.height = min;
            heightSet = PR_TRUE;
         }
     } else if (position->mMinHeight.GetUnit() == eStyleUnit_Percent) {
-        float min = position->mMinHeight.GetPercentValue();
-        NS_ASSERTION(min == 0.0f, "Non-zero percentage values not currently supported");
+        NS_ASSERTION(position->mMinHeight.GetPercentValue() == 0.0f, "Non-zero percentage values not currently supported");
         aSize.height = 0;
         heightSet = PR_TRUE;
     }
 
     nsIContent* content = aBox->GetContent();
diff -r 14ce7619e9c1 layout/xul/base/src/nsXULPopupManager.cpp
--- a/layout/xul/base/src/nsXULPopupManager.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/xul/base/src/nsXULPopupManager.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -529,11 +529,11 @@ CheckCaretDrawingState(nsIDocument *aDoc
   nsIPresShell* presShell = focusedDoc->GetPrimaryShell();
   if (!presShell)
     return;
 
   nsRefPtr<nsCaret> caret;
-  nsresult res = presShell->GetCaret(getter_AddRefs(caret));
+  presShell->GetCaret(getter_AddRefs(caret));
   if (!caret)
     return;
   caret->CheckCaretDrawingState();
 
 }
diff -r 14ce7619e9c1 layout/xul/base/src/nsXULTooltipListener.cpp
--- a/layout/xul/base/src/nsXULTooltipListener.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/xul/base/src/nsXULTooltipListener.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -479,11 +479,14 @@ SetTitletipLabel(nsITreeBoxObject* aTree
 {
   nsCOMPtr<nsITreeView> view;
   aTreeBox->GetView(getter_AddRefs(view));
   if (view) {
     nsAutoString label;
-    nsresult rv = view->GetCellText(aRow, aCol, label);
+#ifdef DEBUG
+    nsresult rv = 
+#endif
+      view->GetCellText(aRow, aCol, label);
     NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "Couldn't get the cell text!");
     aTooltip->SetAttr(kNameSpaceID_None, nsGkAtoms::label, label, PR_TRUE);
   }
 }
 #endif
diff -r 14ce7619e9c1 layout/xul/base/src/tree/src/nsTreeBodyFrame.cpp
--- a/layout/xul/base/src/tree/src/nsTreeBodyFrame.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/layout/xul/base/src/tree/src/nsTreeBodyFrame.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -1166,11 +1166,14 @@ nsTreeBodyFrame::GetCoordsForCellItem(PR
 
   for (nsTreeColumn* currCol = mColumns->GetFirstColumn(); currCol; currCol = currCol->GetNext()) {
 
     // The Rect for the current cell.
     nscoord colWidth;
-    nsresult rv = currCol->GetWidthInTwips(this, &colWidth);
+#ifdef DEBUG
+    nsresult rv =
+#endif
+      currCol->GetWidthInTwips(this, &colWidth);
     NS_ASSERTION(NS_SUCCEEDED(rv), "invalid column");
 
     nsRect cellRect(currX, mInnerBox.y + mRowHeight * (aRow - mTopRowIndex),
                     colWidth, mRowHeight);
 
@@ -3697,12 +3700,11 @@ nsTreeBodyFrame::PaintProgressMeter(PRIn
 
     // Now obtain the value for our cell.
     nsAutoString value;
     mView->GetCellValue(aRowIndex, aColumn, value);
 
-    PRInt32 rv;
-    PRInt32 intValue = value.ToInteger(&rv);
+    PRInt32 intValue = value.ToInteger(nsnull);
     if (intValue < 0)
       intValue = 0;
     else if (intValue > 100)
       intValue = 100;
 
diff -r 14ce7619e9c1 modules/libjar/nsJAR.cpp
--- a/modules/libjar/nsJAR.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/modules/libjar/nsJAR.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -1113,10 +1113,11 @@ nsZipReaderCache::~nsZipReaderCache()
 }
 
 NS_IMETHODIMP
 nsZipReaderCache::GetZip(nsIFile* zipFile, nsIZipReader* *result)
 {
+  NS_ENSURE_ARG_POINTER(zipFile);
   nsresult rv;
   nsAutoLock lock(mLock);
 
 #ifdef ZIP_CACHE_HIT_RATE
   mZipCacheLookups++;
diff -r 14ce7619e9c1 modules/libjar/test/unit/test_bug453254.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/modules/libjar/test/unit/test_bug453254.js	Mon Sep 08 10:35:46 2008 +0300
@@ -0,0 +1,12 @@
+function run_test() {
+  const zipCache = Components.classes["@mozilla.org/libjar/zip-reader-cache;1"]
+                             .createInstance(Components.interfaces.nsIZipReaderCache);
+  zipCache.init(1024);
+  try {
+    zipCache.getZip(null);
+    do_throw("Shouldn't get here!");
+  } catch (e if ((e instanceof Components.interfaces.nsIException) &&
+                 (e.result == Components.results.NS_ERROR_INVALID_POINTER))) {
+    // do nothing, this test passes
+  }
+}
diff -r 14ce7619e9c1 modules/oji/src/lcglue.cpp
--- a/modules/oji/src/lcglue.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/modules/oji/src/lcglue.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -120,11 +120,11 @@ JVMContext* GetJVMContext()
 
 JS_BEGIN_EXTERN_C
 
 #include "jscntxt.h"
 
-JS_STATIC_DLL_CALLBACK(JSContext*)
+static JSContext*
 map_jsj_thread_to_js_context_impl(JSJavaThreadState *jsj_env, void* java_applet_obj, JNIEnv *env, char **errp)
 {
 	// Guess what? This design is totally invalid under Gecko, because there isn't a 1 to 1 mapping
 	// between NSPR threads and JSContexts. We have to ask the plugin instance peer what JSContext
 	// it lives in to make any sense of all this.
@@ -148,11 +148,11 @@ map_jsj_thread_to_js_context_impl(JSJava
 ** This callback is called to map a JSContext to a JSJavaThreadState which
 ** is a wrapper around JNIEnv. Hence this callback essentially maps a JSContext
 ** to a java thread. JSJ_AttachCurrentThreadToJava just calls AttachCurrentThread
 ** on the java vm.
 */
-JS_STATIC_DLL_CALLBACK(JSJavaThreadState*)
+static JSJavaThreadState*
 map_js_context_to_jsj_thread_impl(JSContext *cx, char **errp)
 {
 	*errp = NULL;
 
     // FIXME:  how do we ever break the association between the jsj_env and the
@@ -190,11 +190,11 @@ map_js_context_to_jsj_thread_impl(JSCont
 ** Note that once a mapping between applet -> javascript JSObject -> Java wrapper JSObject 
 ** is made, all subsequent method calls via JSObject use the internal field
 ** to get to the javascript JSObject.
 */
 
-JS_STATIC_DLL_CALLBACK(JSObject*)
+static JSObject*
 map_java_object_to_js_object_impl(JNIEnv *env, void *pluginInstancePtr, char* *errp)
 {
 	JSObject        *window = NULL;
 	PRBool           mayscript = PR_FALSE;
 	PRBool           jvmMochaPrefsEnabled = PR_TRUE;
@@ -243,11 +243,11 @@ map_java_object_to_js_object_impl(JNIEnv
 	//TODO: Get to the window object using DOM.
 	// window = getDOMWindow().getScriptOwner().getJSObject().
 	return window;
 }
 
-JS_STATIC_DLL_CALLBACK(JSPrincipals*)
+static JSPrincipals*
 get_JSPrincipals_from_java_caller_impl(JNIEnv *pJNIEnv, JSContext *pJSContext, void  **ppNSIPrincipalArrayIN, int numPrincipals, void *pNSISecurityContext)
 {
     nsresult rv;
     nsCOMPtr<nsIScriptSecurityManager> secMan = 
         do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
@@ -263,11 +263,11 @@ get_JSPrincipals_from_java_caller_impl(J
     JSPrincipals* jsprincipals = NULL;
     principal->GetJSPrincipals(pJSContext, &jsprincipals);
     return jsprincipals;
 }
 
-JS_STATIC_DLL_CALLBACK(jobject)
+static jobject
 get_java_wrapper_impl(JNIEnv *pJNIEnv, lcjsobject a_jsobject)
 {
     nsresult       err    = NS_OK;
     jobject  pJSObjectWrapper = NULL;
     nsCOMPtr<nsIJVMManager> managerService = do_GetService(kJVMManagerCID, &err);
@@ -284,11 +284,11 @@ get_java_wrapper_impl(JNIEnv *pJNIEnv, l
        return NULL;
     }
     return pJSObjectWrapper;
 }
 
-JS_STATIC_DLL_CALLBACK(lcjsobject)
+static lcjsobject
 unwrap_java_wrapper_impl(JNIEnv *pJNIEnv, jobject java_wrapper)
 {
     lcjsobject obj = 0;
     nsresult       err    = NS_OK;
     nsCOMPtr<nsIJVMManager> managerService = do_GetService(kJVMManagerCID, &err);
@@ -305,20 +305,20 @@ unwrap_java_wrapper_impl(JNIEnv *pJNIEnv
        return 0;
     }
     return obj;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 enter_js_from_java_impl(JNIEnv *jEnv, char **errp,
                         void **pNSIPrincipaArray, int numPrincipals, 
                         void *pNSISecurityContext,
                         void *java_applet_obj)
 {
 	return PR_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 exit_js_impl(JNIEnv *jEnv, JSContext *cx)
 {
     // The main idea is to execute terminate function if have any;
     if (cx)
     {
@@ -330,11 +330,11 @@ exit_js_impl(JNIEnv *jEnv, JSContext *cx
         }
     }
     return;
 }
 
-JS_STATIC_DLL_CALLBACK(PRBool)
+static PRBool
 create_java_vm_impl(SystemJavaVM* *jvm, JNIEnv* *initialEnv, void* initargs)
 {
     // const char* classpath = (const char*)initargs;
     nsCOMPtr<nsIJVMManager> serv = do_GetService(kJVMManagerCID);
     if (!serv)
@@ -346,32 +346,32 @@ create_java_vm_impl(SystemJavaVM* *jvm, 
     // the XPCOM service manager will keep it alive.
     *jvm = reinterpret_cast<SystemJavaVM*>(serv.get());
     return PR_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(PRBool)
+static PRBool
 destroy_java_vm_impl(SystemJavaVM* jvm, JNIEnv* initialEnv)
 {
     JVM_ReleaseJNIEnv(initialEnv);
     // need to release jvm
     return PR_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JNIEnv*)
+static JNIEnv*
 attach_current_thread_impl(SystemJavaVM* jvm)
 {
     return JVM_GetJNIEnv();
 }
 
-JS_STATIC_DLL_CALLBACK(PRBool)
+static PRBool
 detach_current_thread_impl(SystemJavaVM* jvm, JNIEnv* env)
 {
     JVM_ReleaseJNIEnv(env);
     return PR_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(SystemJavaVM*)
+static SystemJavaVM*
 get_java_vm_impl(JNIEnv* env)
 {
     // only one SystemJavaVM for the whole browser, so it doesn't depend on env
     nsresult rv;
     nsCOMPtr<nsIJVMManager> managerService = do_GetService(kJVMManagerCID, &rv);
diff -r 14ce7619e9c1 modules/plugin/base/public/npupp.h
--- a/modules/plugin/base/public/npupp.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/modules/plugin/base/public/npupp.h	Mon Sep 08 10:35:46 2008 +0300
@@ -649,10 +649,12 @@ typedef OSErr (* NP_LOADDS BP_GetSupport
 #if defined(XP_UNIX)
 /* GCC 3.3 and later support the visibility attribute. */
 #if defined(__GNUC__) && \
     ((__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3))
 #define NP_VISIBILITY_DEFAULT __attribute__((visibility("default")))
+#elif defined(__SUNPRO_C) || defined(__SUNPRO_CC)
+#define NP_VISIBILITY_DEFAULT __global
 #else
 #define NP_VISIBILITY_DEFAULT
 #endif
 
 #define NP_EXPORT(__type) NP_VISIBILITY_DEFAULT __type
diff -r 14ce7619e9c1 modules/plugin/base/src/nsJSNPRuntime.cpp
--- a/modules/plugin/base/src/nsJSNPRuntime.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/modules/plugin/base/src/nsJSNPRuntime.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -116,41 +116,41 @@ NPClass nsJSObjWrapper::sJSObjWrapperNPC
     nsJSObjWrapper::NP_RemoveProperty,
     nsJSObjWrapper::NP_Enumerate,
     nsJSObjWrapper::NP_Construct
   };
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 NPObjWrapper_AddProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 NPObjWrapper_DelProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 NPObjWrapper_SetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 NPObjWrapper_GetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 NPObjWrapper_newEnumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op,
                           jsval *statep, jsid *idp);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 NPObjWrapper_NewResolve(JSContext *cx, JSObject *obj, jsval id, uintN flags,
                         JSObject **objp);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 NPObjWrapper_Convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp);
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 NPObjWrapper_Finalize(JSContext *cx, JSObject *obj);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 NPObjWrapper_Call(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                   jsval *rval);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 NPObjWrapper_Construct(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                        jsval *rval);
 
 static bool
 CreateNPObjectMember(NPP npp, JSContext *cx, JSObject *obj,
@@ -173,21 +173,21 @@ typedef struct NPObjectMemberPrivate {
     jsval fieldValue;
     jsval methodName;
     NPP   npp;
 } NPObjectMemberPrivate;
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 NPObjectMember_Convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp);
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 NPObjectMember_Finalize(JSContext *cx, JSObject *obj);
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 NPObjectMember_Call(JSContext *cx, JSObject *obj, uintN argc,
                     jsval *argv, jsval *rval);
 
-JS_STATIC_DLL_CALLBACK(uint32)
+static uint32
 NPObjectMember_Mark(JSContext *cx, JSObject *obj, void *arg);
 
 static JSClass sNPObjectMemberClass =
   {
     "NPObject Ambiguous Member class", JSCLASS_HAS_PRIVATE,
@@ -1134,11 +1134,11 @@ GetNPObject(JSContext *cx, JSObject *obj
   }
 
   return (NPObject *)::JS_GetPrivate(cx, obj);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 NPObjWrapper_AddProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 {
   NPObject *npobj = GetNPObject(cx, obj);
 
   if (!npobj || !npobj->_class || !npobj->_class->hasProperty ||
@@ -1159,11 +1159,11 @@ NPObjWrapper_AddProperty(JSContext *cx, 
   }
 
   return ReportExceptionIfPending(cx);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 NPObjWrapper_DelProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 {
   NPObject *npobj = GetNPObject(cx, obj);
 
   if (!npobj || !npobj->_class || !npobj->_class->hasProperty) {
@@ -1180,11 +1180,11 @@ NPObjWrapper_DelProperty(JSContext *cx, 
   }
 
   return ReportExceptionIfPending(cx);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 NPObjWrapper_SetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 {
   NPObject *npobj = GetNPObject(cx, obj);
 
   if (!npobj || !npobj->_class || !npobj->_class->hasProperty ||
@@ -1231,11 +1231,11 @@ NPObjWrapper_SetProperty(JSContext *cx, 
   }
 
   return ReportExceptionIfPending(cx);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 NPObjWrapper_GetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 {
   NPObject *npobj = GetNPObject(cx, obj);
 
   if (!npobj || !npobj->_class || !npobj->_class->hasProperty ||
@@ -1284,11 +1284,11 @@ NPObjWrapper_GetProperty(JSContext *cx, 
   }
 
   return ReportExceptionIfPending(cx);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 CallNPMethodInternal(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                      jsval *rval, PRBool ctorCall)
 {
   while (obj && JS_GET_CLASS(cx, obj) != &sNPObjectJSWrapperClass) {
     obj = ::JS_GetPrototype(cx, obj);
@@ -1416,11 +1416,11 @@ CallNPMethodInternal(JSContext *cx, JSOb
   _releasevariantvalue(&v);
 
   return ReportExceptionIfPending(cx);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 CallNPMethod(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
              jsval *rval)
 {
   return CallNPMethodInternal(cx, obj, argc, argv, rval, PR_FALSE);
 }
@@ -1429,11 +1429,11 @@ struct NPObjectEnumerateState {
   PRUint32     index;
   PRUint32     length;
   NPIdentifier *value;
 };
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 NPObjWrapper_newEnumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op,
                           jsval *statep, jsid *idp)
 {
   NPObject *npobj = GetNPObject(cx, obj);
   NPIdentifier *enum_value;
@@ -1500,11 +1500,11 @@ NPObjWrapper_newEnumerate(JSContext *cx,
   }
 
   return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 NPObjWrapper_NewResolve(JSContext *cx, JSObject *obj, jsval id, uintN flags,
                         JSObject **objp)
 {
   NPObject *npobj = GetNPObject(cx, obj);
 
@@ -1562,11 +1562,11 @@ NPObjWrapper_NewResolve(JSContext *cx, J
   }
 
   return ReportExceptionIfPending(cx);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 NPObjWrapper_Convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp)
 {
   // The sole reason we implement this hook is to prevent the JS
   // engine from calling valueOf() on NPObject's. Some NPObject's may
   // actually implement a method named valueOf, but it's unlikely to
@@ -1574,11 +1574,11 @@ NPObjWrapper_Convert(JSContext *cx, JSOb
   // that overrides what the default hook does.
 
   return JS_TRUE;
 }
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 NPObjWrapper_Finalize(JSContext *cx, JSObject *obj)
 {
   NPObject *npobj = (NPObject *)::JS_GetPrivate(cx, obj);
 
   if (npobj) {
@@ -1591,19 +1591,19 @@ NPObjWrapper_Finalize(JSContext *cx, JSO
   }
 
   OnWrapperDestroyed();
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 NPObjWrapper_Call(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                   jsval *rval)
 {
   return CallNPMethodInternal(cx, JSVAL_TO_OBJECT(argv[-2]), argc, argv, rval,
                               PR_FALSE);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 NPObjWrapper_Construct(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                        jsval *rval)
 {
   return CallNPMethodInternal(cx, JSVAL_TO_OBJECT(argv[-2]), argc, argv, rval,
                               PR_TRUE);
@@ -2033,11 +2033,11 @@ CreateNPObjectMember(NPP npp, JSContext 
   ::JS_RemoveRoot(cx, vp);
 
   return true;
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 NPObjectMember_Convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp)
 {
   NPObjectMemberPrivate *memberPrivate =
     (NPObjectMemberPrivate *)::JS_GetInstancePrivate(cx, obj,
                                                      &sNPObjectMemberClass,
@@ -2059,11 +2059,11 @@ NPObjectMember_Convert(JSContext *cx, JS
     NS_ERROR("illegal operation on JSObject prototype object");
     return JS_FALSE;
   }
 }
 
-JS_STATIC_DLL_CALLBACK(void)
+static void
 NPObjectMember_Finalize(JSContext *cx, JSObject *obj)
 {
   NPObjectMemberPrivate *memberPrivate;
 
   memberPrivate = (NPObjectMemberPrivate *)::JS_GetPrivate(cx, obj);
@@ -2071,11 +2071,11 @@ NPObjectMember_Finalize(JSContext *cx, J
     return;
 
   PR_Free(memberPrivate);
 }
 
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 NPObjectMember_Call(JSContext *cx, JSObject *obj,
                     uintN argc, jsval *argv, jsval *rval)
 {
   JSObject *memobj = JSVAL_TO_OBJECT(argv[-2]);
   NS_ENSURE_TRUE(memobj, JS_FALSE);
@@ -2149,11 +2149,11 @@ NPObjectMember_Call(JSContext *cx, JSObj
   _releasevariantvalue(&npv);
 
   return ReportExceptionIfPending(cx);
 }
 
-JS_STATIC_DLL_CALLBACK(uint32)
+static uint32
 NPObjectMember_Mark(JSContext *cx, JSObject *obj, void *arg)
 {
   NPObjectMemberPrivate *memberPrivate =
     (NPObjectMemberPrivate *)::JS_GetInstancePrivate(cx, obj,
                                                      &sNPObjectMemberClass,
diff -r 14ce7619e9c1 modules/zlib/src/mozzconf.h
--- a/modules/zlib/src/mozzconf.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/modules/zlib/src/mozzconf.h	Mon Sep 08 10:35:46 2008 +0300
@@ -39,10 +39,12 @@
 
 #if defined(XP_WIN) && defined(ZLIB_DLL)
 #undef ZLIB_DLL
 #elif defined(HAVE_VISIBILITY_ATTRIBUTE) && !defined(MOZ_ENABLE_LIBXUL)
 #define ZEXTERN __attribute__((visibility ("default"))) extern
+#elif (defined(__SUNPRO_C) || defined(__SUNPRO_CC)) && !defined(MOZ_ENABLE_LIBXUL)
+#define ZEXTERN __global extern
 #endif
 
 /* Exported Symbols */
 #define zlibVersion MOZ_Z_zlibVersion
 #define deflate MOZ_Z_deflate
diff -r 14ce7619e9c1 netwerk/base/src/nsAutodialWin.cpp
--- a/netwerk/base/src/nsAutodialWin.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/netwerk/base/src/nsAutodialWin.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -765,31 +765,31 @@ PRBool nsRASAutodial::LoadRASapi32DLL()
         mhRASapi32 = ::LoadLibraryW(L"rasapi32.dll");
         if ((UINT)mhRASapi32 > 32)
         {
             // RasEnumConnections
             mpRasEnumConnections = (tRASENUMCONNECTIONS)
-             ::GetProcAddress(mhRASapi32, "RasEnumConnectionsA");
+             ::GetProcAddress(mhRASapi32, "RasEnumConnectionsW");
 
             // RasEnumEntries
             mpRasEnumEntries = (tRASENUMENTRIES)
-             ::GetProcAddress(mhRASapi32, "RasEnumEntriesA");
+             ::GetProcAddress(mhRASapi32, "RasEnumEntriesW");
 
             // RasSetAutodialAddress
             mpRasSetAutodialAddress = (tRASSETAUTODIALADDRESS)
-                ::GetProcAddress(mhRASapi32, "RasSetAutodialAddressA");
+                ::GetProcAddress(mhRASapi32, "RasSetAutodialAddressW");
 
             // RasGetAutodialAddress
             mpRasGetAutodialAddress = (tRASGETAUTODIALADDRESS)
-             ::GetProcAddress(mhRASapi32, "RasGetAutodialAddressA");
+             ::GetProcAddress(mhRASapi32, "RasGetAutodialAddressW");
 
             // RasGetAutodialEnable
             mpRasGetAutodialEnable = (tRASGETAUTODIALENABLE)
-             ::GetProcAddress(mhRASapi32, "RasGetAutodialEnableA");
+             ::GetProcAddress(mhRASapi32, "RasGetAutodialEnableW");
 
             // RasGetAutodialParam
             mpRasGetAutodialParam = (tRASGETAUTODIALPARAM)
-             ::GetProcAddress(mhRASapi32, "RasGetAutodialParamA");
+             ::GetProcAddress(mhRASapi32, "RasGetAutodialParamW");
         }
 
     }
 
     if (!mhRASapi32 
diff -r 14ce7619e9c1 netwerk/base/src/nsURLHelperUnix.cpp
--- a/netwerk/base/src/nsURLHelperUnix.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/netwerk/base/src/nsURLHelperUnix.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -45,24 +45,31 @@
 #include "nsNativeCharsetUtils.h"
 
 nsresult
 net_GetURLSpecFromFile(nsIFile *aFile, nsACString &result)
 {
-    // NOTE: This is identical to the implementation in nsURLHelperOSX.cpp
-
     nsresult rv;
+    nsCAutoString nativePath, ePath;
     nsAutoString path;
 
-    // construct URL spec from  file path
-    rv = aFile->GetPath(path);
+    rv = aFile->GetNativePath(nativePath);
     if (NS_FAILED(rv)) return rv;
 
+    // Convert to unicode and back to check correct conversion to native charset
+    NS_CopyNativeToUnicode(nativePath, path);
+    NS_CopyUnicodeToNative(path, ePath);
+
+    // Use UTF8 version if conversion was successful
+    if (nativePath == ePath)
+        CopyUTF16toUTF8(path, ePath);
+    else
+        ePath = nativePath;
+    
     nsCAutoString escPath;
     NS_NAMED_LITERAL_CSTRING(prefix, "file://");
         
     // Escape the path with the directory mask
-    NS_ConvertUTF16toUTF8 ePath(path);
     if (NS_EscapeURL(ePath.get(), -1, esc_Directory+esc_Forced, escPath))
         escPath.Insert(prefix, 0);
     else
         escPath.Assign(prefix + ePath);
 
diff -r 14ce7619e9c1 netwerk/protocol/ftp/src/nsFtpConnectionThread.cpp
--- a/netwerk/protocol/ftp/src/nsFtpConnectionThread.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/netwerk/protocol/ftp/src/nsFtpConnectionThread.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -1115,10 +1115,11 @@ nsFtpState::R_list() {
     }
 
     if (mResponseCode/100 == 2) {
         //(DONE)
         mNextState = FTP_COMPLETE;
+        mDoomCache = PR_FALSE;
         return FTP_COMPLETE;
     }
     return FTP_ERROR;
 }
 
@@ -1944,10 +1945,11 @@ nsFtpState::OnCacheEntryAvailable(nsICac
 {
     // We may have been closed while we were waiting for this cache entry.
     if (IsClosed())
         return NS_OK;
 
+    mDoomCache = PR_TRUE;
     mCacheEntry = entry;
     if (CanReadCacheEntry() && ReadCacheEntry()) {
         mState = FTP_READ_CACHE;
     } else {
         Connect();
@@ -2024,10 +2026,12 @@ nsFtpState::CloseWithStatus(nsresult sta
         mDataTransport->Close(NS_ERROR_ABORT);
         mDataTransport = nsnull;
     }
 
     mDataStream = nsnull;
+    if (mDoomCache && mCacheEntry)
+        mCacheEntry->Doom();
     mCacheEntry = nsnull;
 
     return nsBaseContentStream::CloseWithStatus(status);
 }
 
@@ -2076,10 +2080,11 @@ nsFtpState::ReadCacheEntry()
         return PR_FALSE;
 
     if (HasPendingCallback())
         mDataStream->AsyncWait(this, 0, 0, CallbackTarget());
 
+    mDoomCache = PR_FALSE;
     return PR_TRUE;
 }
 
 PRBool
 nsFtpState::CheckCache()
@@ -2133,12 +2138,14 @@ nsFtpState::CheckCache()
     // Try to open a cache entry immediately, but if the cache entry is busy,
     // then wait for it to be available.
 
     session->OpenCacheEntry(key, accessReq, PR_FALSE,
                             getter_AddRefs(mCacheEntry));
-    if (mCacheEntry)
+    if (mCacheEntry) {
+        mDoomCache = PR_TRUE;
         return PR_FALSE;  // great, we're ready to proceed!
+    }
 
     nsresult rv = session->AsyncOpenCacheEntry(key, accessReq, this);
     return NS_SUCCEEDED(rv);
 }
 
diff -r 14ce7619e9c1 netwerk/protocol/ftp/src/nsFtpConnectionThread.h
--- a/netwerk/protocol/ftp/src/nsFtpConnectionThread.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/netwerk/protocol/ftp/src/nsFtpConnectionThread.h	Mon Sep 08 10:35:46 2008 +0300
@@ -288,10 +288,11 @@ private:
     // ***** control read gvars
     nsresult                mControlStatus;
     nsCString               mControlReadCarryOverBuf;
 
     nsCOMPtr<nsICacheEntryDescriptor> mCacheEntry;
+    PRPackedBool            mDoomCache;
     
     nsCString mSuppliedEntityID;
 };
 
 #endif //__nsFtpState__h_
diff -r 14ce7619e9c1 netwerk/test/httpserver/httpd.js
--- a/netwerk/test/httpserver/httpd.js	Sat Sep 06 22:21:37 2008 +1200
+++ b/netwerk/test/httpserver/httpd.js	Mon Sep 08 10:35:46 2008 +0300
@@ -986,10 +986,12 @@ function RequestReader(connection)
    * upon (by passing it to the request handler or by extracting request
    * metadata from it).
    */
   this._data = new LineData();
 
+  this._contentLength = 0;
+
   /** The current state of parsing the incoming request. */
   this._state = READER_INITIAL;
 
   /** Metadata constructed from the incoming request for the request handler. */
   this._metadata = new Request(connection.port);
@@ -1039,17 +1041,16 @@ RequestReader.prototype =
 
       case READER_IN_HEADERS:
         moreAvailable = this._processHeaders(input, count);
         break;
 
-      case READER_IN_BODY:
-        // XXX handle the request body!  until then, just stop reading
-        break;
-
       default:
         NS_ASSERT(false);
     }
+
+    if (this._state == READER_IN_BODY && moreAvailable)
+      moreAvailable = this._processBody(input, count);
 
     if (moreAvailable)
       input.asyncWait(this, 0, 0, gThreadManager.currentThread);
   },
 
@@ -1103,10 +1104,14 @@ RequestReader.prototype =
     {
       this._parseRequestLine(line.value);
 
       // do we have more header data to read?
       if (!this._parseHeaders())
+        return true;
+
+      dumpn("_processRequestLine, Content-length="+this._contentLength);
+      if (this._contentLength > 0)
         return true;
 
       // headers complete, do a data check and then forward to the handler
       this._validateRequest();
       return this._handleResponse();
@@ -1143,11 +1148,51 @@ RequestReader.prototype =
     {
       // do we have all the headers?
       if (!this._parseHeaders())
         return true;
 
+      dumpn("_processHeaders, Content-length="+this._contentLength);
+      if (this._contentLength > 0)
+        return true;
+
       // we have all the headers, continue with the body
+      this._validateRequest();
+      return this._handleResponse();
+    }
+    catch (e)
+    {
+      this._handleError(e);
+      return false;
+    }
+  },
+
+  _processBody: function(input, count)
+  {
+    NS_ASSERT(this._state == READER_IN_BODY);
+
+    try
+    {
+      if (this._contentLength > 0)
+      {
+        var bodyData = this._data.purge();
+        if (bodyData.length == 0)
+        {
+          if (count > this._contentLength)
+            count = this._contentLength;
+
+          bodyData = readBytes(input, count);
+        }
+        dumpn("*** loading data="+bodyData+" len="+bodyData.length);
+
+        this._metadata._body.appendBytes(bodyData);
+        this._contentLength -= bodyData.length;
+      }
+
+      dumpn("*** remainig body data len="+this._contentLength);
+      if (this._contentLength > 0)
+        return true;
+
       this._validateRequest();
       return this._handleResponse();
     }
     catch (e)
     {
@@ -1277,20 +1322,18 @@ RequestReader.prototype =
   /**
    * Now that we've read the request line and headers, we can actually hand off
    * the request to be handled.
    *
    * This method is called once per request, after the request line and all
-   * headers have been received.
+   * headers and the body, if any, have been received.
    *
    * @returns boolean
    *   true if more data must be read, false otherwise
    */
   _handleResponse: function()
   {
     NS_ASSERT(this._state == READER_IN_BODY);
-
-    // XXX set up a stream for data in the request body here
 
     // We don't need the line-based data any more, so make attempted reuse an
     // error.
     this._data = null;
 
@@ -1467,10 +1510,16 @@ RequestReader.prototype =
           // no headers in request -- valid for HTTP/1.0 requests
         }
 
         // either way, we're done processing headers
         this._state = READER_IN_BODY;
+        try
+        {
+          this._contentLength = parseInt(headers.getHeader("Content-Length"));
+          dumpn("Content-Length="+this._contentLength);
+        }
+        catch (e) {}
         return true;
       }
       else if (firstChar == " " || firstChar == "\t")
       {
         // multi-line header if we've already seen a header line
@@ -1867,10 +1916,15 @@ function ServerHandler(server)
    * pairs are stored as property-value pairs in this property.
    *
    * @see ServerHandler.prototype._defaultPaths
    */
   this._overridePaths = {};
+  
+  /** 
+   * Put data overrides, privileged before _overridePaths.
+   */
+  this._putDataOverrides = {};
 
   /**
    * Custom request handlers for the error handlers in the server in which this
    * resides.  Path-handler pairs are stored as property-value pairs in this
    * property.
@@ -1915,14 +1969,65 @@ ServerHandler.prototype =
 
     try
     {
       try
       {
-        // explicit paths first, then files based on existing directory mappings,
-        // then (if the file doesn't exist) built-in server default paths
-        if (path in this._overridePaths)
+        if (metadata.method == "PUT")
+        {
+          // remotely set path override
+          var data = metadata.body.purge();
+          data = String.fromCharCode.apply(null, data.splice(0, data.length + 2));
+          var contentType;
+          try
+          {
+            contentType = metadata.getHeader("Content-Type");
+          }
+          catch (ex)
+          {
+            contentType = "application/octet-stream";
+          }
+
+          dumpn("PUT data \'"+data+"\' for "+path);
+          this._putDataOverrides[path] =
+            function(ametadata, aresponse)
+            {
+              aresponse.setStatusLine(metadata.httpVersion, 200, "OK");
+              aresponse.setHeader("Content-Type", contentType, false);
+              dumpn("*** writting PUT data=\'"+data+"\'");
+              aresponse.bodyOutputStream.write(data, data.length);
+            };
+
+          response.setStatusLine(metadata.httpVersion, 200, "OK");
+        }
+        else if (metadata.method == "DELETE")
+        {
+          if (path in this._putDataOverrides)
+          {
+            delete this._putDataOverrides[path];
+            dumpn("clearing PUT data for "+path);
+            response.setStatusLine(metadata.httpVersion, 200, "OK");
+          }
+          else
+          {
+            dumpn("no PUT data for "+path+" to delete");
+            response.setStatusLine(metadata.httpVersion, 204, "No Content");
+          }
+        }
+        else if (path in this._putDataOverrides)
+        {
+          // PUT data overrides are priviledged before all
+          // other overrides.
+          dumpn("calling PUT data override for "+path);
+          this._putDataOverrides[path](metadata, response);
+        }
+        else if (path in this._overridePaths)
+        {
+          // explicit paths first, then files based on existing directory mappings,
+          // then (if the file doesn't exist) built-in server default paths
+          dumpn("calling override for "+path);
           this._overridePaths[path](metadata, response);
+        }
         else
           this._handleDefault(metadata, response);
       }
       catch (e)
       {
@@ -3482,10 +3587,13 @@ function Request(port)
   this._host = undefined;
 
   /** Port number over which the request was received. */
   this._port = port;
 
+  /** Body data of the request */
+  this._body = new LineData();
+
   /**
    * The headers in this request.
    */
   this._headers = new nsHttpHeaders();
 
@@ -3605,10 +3713,15 @@ Request.prototype =
   /** Ensures a property bag has been created for ad-hoc behaviors. */
   _ensurePropertyBag: function()
   {
     if (!this._bag)
       this._bag = new WritablePropertyBag();
+  },
+
+  get body()
+  {
+    return this._body;
   }
 };
 
 
 // XPCOM trappings
diff -r 14ce7619e9c1 netwerk/test/httpserver/test/test_remotesetpath.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/netwerk/test/httpserver/test/test_remotesetpath.js	Mon Sep 08 10:35:46 2008 +0300
@@ -0,0 +1,201 @@
+/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is MozJSHTTP code.
+ *
+ * The Initial Developer of the Original Code is
+ * Jeff Walden <jwalden+code@mit.edu>.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+// Make sure setIndexHandler works as expected
+
+
+var paths =
+  [
+   "http://localhost:4444/my/first-path/override/",
+   "http://localhost:4444/my/second-path/override",
+   "http://localhost:4444/my/second-path/override",
+   "http://localhost:4444/my/second-path/override"
+  ];
+  
+var methods =
+  [
+   "PUT",
+   "PUT",
+   "DELETE",
+   "DELETE"
+  ];
+  
+var contents =
+  [
+   "First content",
+   "Second content",
+   // The third is missing - it is being deleted from the server
+  ];
+
+var putResponses =
+  [
+   200,
+   200,
+   200,
+   204
+  ];
+  
+var success =
+  [
+   true, 
+   true, 
+   false,
+   false
+  ];
+
+var currPathIndex = 0;
+
+var uploadListener =
+  {
+    // NSISTREAMLISTENER
+    onDataAvailable: function(request, cx, inputStream, offset, count)
+    {
+      makeBIS(inputStream).readByteArray(count); // required by API
+    },
+
+    // NSIREQUESTOBSERVER
+    onStartRequest: function(request, cx)
+    {
+      var ch = request.QueryInterface(Ci.nsIHttpChannel);
+      do_check_eq(ch.responseStatus, putResponses[currPathIndex]);
+    },
+    onStopRequest: function(request, cx, status)
+    {
+      do_check_true(Components.isSuccessCode(status));
+      var ch = makeChannel(paths[currPathIndex]);
+      ch.asyncOpen(downloadListener, null);
+    },
+
+    // NSISUPPORTS
+    QueryInterface: function(aIID)
+    {
+      if (aIID.equals(Ci.nsIStreamListener) ||
+          aIID.equals(Ci.nsIRequestObserver) ||
+          aIID.equals(Ci.nsISupports))
+        return this;
+      throw Cr.NS_ERROR_NO_INTERFACE;
+    }
+  };
+
+var downloadListener =
+  {
+    // NSISTREAMLISTENER
+    onDataAvailable: function(request, cx, inputStream, offset, count)
+    {
+      var content = makeBIS(inputStream).readByteArray(count); // required by API
+
+      if (success[currPathIndex])
+      {
+        for (var i=0; i<count; ++i)
+          do_check_eq(contents[currPathIndex].charCodeAt(i), content[i])
+      }
+    },
+
+    // NSIREQUESTOBSERVER
+    onStartRequest: function(request, cx)
+    {
+      if (success[currPathIndex])
+      {
+        // expected success, check we get the correct content-type
+        var ch = request.QueryInterface(Ci.nsIHttpChannel)
+                        .QueryInterface(Ci.nsIHttpChannelInternal);
+        do_check_eq(ch.getResponseHeader("Content-Type"), "application/x-moz-put-test");
+      }
+    },
+    onStopRequest: function(request, cx, status)
+    {
+      do_check_true(Components.isSuccessCode(status));
+
+      var ch = request.QueryInterface(Ci.nsIHttpChannel)
+                      .QueryInterface(Ci.nsIHttpChannelInternal);
+      do_check_true(ch.requestSucceeded == success[currPathIndex]);
+
+      if (++currPathIndex == paths.length)
+        srv.stop();
+      else
+        performNextTest();
+      do_test_finished();
+    },
+
+    // NSISUPPORTS
+    QueryInterface: function(aIID)
+    {
+      if (aIID.equals(Ci.nsIStreamListener) ||
+          aIID.equals(Ci.nsIRequestObserver) ||
+          aIID.equals(Ci.nsISupports))
+        return this;
+      throw Cr.NS_ERROR_NO_INTERFACE;
+    }
+  };
+
+function performNextTest()
+{
+  do_test_pending();
+
+  var ch = makeChannel(paths[currPathIndex]);
+
+  var method = methods[currPathIndex];
+  switch (method)
+  {
+  case "PUT":
+    var stream = Cc["@mozilla.org/io/string-input-stream;1"]
+        .createInstance(Ci.nsIStringInputStream);
+    stream.setData(contents[currPathIndex], contents[currPathIndex].length);
+
+    var upch = ch.QueryInterface(Ci.nsIUploadChannel);
+    upch.setUploadStream(stream, "application/x-moz-put-test", stream.available());
+    break;
+    
+  case "DELETE":
+    var httpch = ch.QueryInterface(Ci.nsIHttpChannel);
+    httpch.requestMethod = method;
+    break;
+  }
+
+  ch.asyncOpen(uploadListener, null);
+}
+
+var srv, serverBasePath;
+
+function run_test()
+{
+  srv = createServer();
+  srv.start(4444);
+
+  performNextTest();
+}
diff -r 14ce7619e9c1 toolkit/components/exthelper/extApplication.js
--- a/toolkit/components/exthelper/extApplication.js	Sat Sep 06 22:21:37 2008 +1200
+++ b/toolkit/components/exthelper/extApplication.js	Mon Sep 08 10:35:46 2008 +0300
@@ -683,7 +683,32 @@ extApplication.prototype = {
         this._events = new Events();
 
     return this._events;
   },
 
+  // helper method for correct quitting/restarting
+  _quitWithFlags: function app__quitWithFlags(aFlags) {
+    let os = Components.classes["@mozilla.org/observer-service;1"]
+                       .getService(Components.interfaces.nsIObserverService);
+    let cancelQuit = Components.classes["@mozilla.org/supports-PRBool;1"]
+                               .createInstance(Components.interfaces.nsISupportsPRBool);
+    os.notifyObservers(cancelQuit, "quit-application-requested", null);
+    if (cancelQuit.data)
+      return false; // somebody canceled our quit request
+    
+    let appStartup = Components.classes['@mozilla.org/toolkit/app-startup;1']
+                               .getService(Components.interfaces.nsIAppStartup);
+    appStartup.quit(aFlags);
+    return true;
+  },
+
+  quit: function app_quit() {
+    return this._quitWithFlags(Components.interfaces.nsIAppStartup.eAttemptQuit);
+  },
+
+  restart: function app_restart() {
+    return this._quitWithFlags(Components.interfaces.nsIAppStartup.eAttemptQuit |
+                               Components.interfaces.nsIAppStartup.eRestart);
+  },
+
   QueryInterface : XPCOMUtils.generateQI([Ci.extIApplication, Ci.nsISupportsWeakReference])
 };
diff -r 14ce7619e9c1 toolkit/components/exthelper/extIApplication.idl
--- a/toolkit/components/exthelper/extIApplication.idl	Sat Sep 06 22:21:37 2008 +1200
+++ b/toolkit/components/exthelper/extIApplication.idl	Mon Sep 08 10:35:46 2008 +0300
@@ -380,11 +380,11 @@ interface extISessionStorage : nsISuppor
    *          exists with the given name.
    */
   nsIVariant get(in AString aName, in nsIVariant aDefaultValue);
 }; 
 
-[scriptable, uuid(ba9442ee-7070-44fb-8157-c111e1fa70b6)]
+[scriptable, uuid(e53d6610-7468-11dd-ad8b-0800200c9a66)]
 interface extIApplication : nsISupports
 {
   /**
    * The id of the application.
    */
@@ -425,6 +425,18 @@ interface extIApplication : nsISupports
   /**
    * The events object for the application.
    * supports: "load", "ready", "quit", "unload"
    */
   readonly attribute extIEvents events;
+
+  /**
+   * Quits the application (if nobody objects to quit-application-requested).
+   * @returns whether quitting will proceed
+   */
+  boolean quit();
+
+  /**
+   * Restarts the application (if nobody objects to quit-application-requested).
+   * @returns whether restarting will proceed
+   */
+  boolean restart();
 };
diff -r 14ce7619e9c1 toolkit/components/passwordmgr/src/nsLoginManager.js
--- a/toolkit/components/passwordmgr/src/nsLoginManager.js	Sat Sep 06 22:21:37 2008 +1200
+++ b/toolkit/components/passwordmgr/src/nsLoginManager.js	Mon Sep 08 10:35:46 2008 +0300
@@ -323,21 +323,31 @@ LoginManager.prototype = {
 
 
         handleEvent : function (event) {
             this._pwmgr.log("domEventListener: got event " + event.type);
 
-            var doc, inputElement;
             switch (event.type) {
                 case "DOMContentLoaded":
-                    doc = event.target;
-                    this._pwmgr._fillDocument(doc);
+                    this._pwmgr._fillDocument(event.target);
                     return;
 
                 case "DOMAutoComplete":
                 case "blur":
-                    inputElement = event.target;
-                    this._pwmgr._fillPassword(inputElement);
+                    var acInputField = event.target;
+                    var acForm = acInputField.form;
+                    // Make sure the username field fillForm will use is the
+                    // same field as the autocomplete was activated on. If
+                    // not, the DOM has been altered and we'll just give up.
+                    var [usernameField, passwordField, ignored] =
+                        this._pwmgr._getFormFields(acForm, false);
+                    if (usernameField == acInputField && passwordField) {
+                        // Clobber any existing password.
+                        passwordField.value = "";
+                        this._pwmgr._fillForm(acForm, true, true, null);
+                    } else {
+                        this._pwmgr.log("Oops, form changed before AC invoked");
+                    }
                     return;
 
                 default:
                     this._pwmgr.log("Oops! This event unexpected.");
                     return;
@@ -1008,15 +1018,10 @@ LoginManager.prototype = {
                               usernameField.readOnly)) {
             this.log("not filling form, login fields disabled");
             return [false, foundLogins];
         }
 
-        // If there's only a password field and it has a value, there's
-        // nothing for us to do. (Don't clobber the existing value)
-        if (!usernameField && passwordField.value)
-            return [false, foundLogins];
-
         // Need to get a list of logins if we weren't given them
         if (foundLogins == null) {
             var formOrigin = 
                 this._getPasswordOrigin(form.ownerDocument.documentURI);
             var actionOrigin = this._getActionOrigin(form);
@@ -1058,10 +1063,14 @@ LoginManager.prototype = {
         // one. This is normally used to select from multiple accounts,
         // but even with one account we should refill if the user edits.
         if (usernameField)
             this._attachToInput(usernameField);
 
+        // Don't clobber an existing password.
+        if (passwordField.value)
+            return [false, foundLogins];
+
         // If the form has an autocomplete=off attribute in play, don't
         // fill in the login automatically. We check this after attaching
         // the autocomplete stuff to the username field, so the user can
         // still manually select a login to be filled in.
         var isFormDisabled = false;
@@ -1080,17 +1089,17 @@ LoginManager.prototype = {
 
         if (usernameField && usernameField.value) {
             // If username was specified in the form, only fill in the
             // password if we find a matching login.
 
-            var username = usernameField.value;
+            var username = usernameField.value.toLowerCase();
 
             var matchingLogin;
             var found = logins.some(function(l) {
-                                        matchingLogin = l;
-                                        return (l.username == username);
-                                    });
+                                matchingLogin = l;
+                                return (l.username.toLowerCase() == username);
+                            });
             if (found)
                 selectedLogin = matchingLogin;
             else
                 this.log("Password not filled. None of the stored " +
                          "logins match the username already present.");
@@ -1157,67 +1166,10 @@ LoginManager.prototype = {
         element.addEventListener("blur",
                                 this._domEventListener, false);
         element.addEventListener("DOMAutoComplete",
                                 this._domEventListener, false);
         this._formFillService.markAsLoginManagerField(element);
-    },
-
-
-    /*
-     * _fillPassword
-     *
-     * The user has autocompleted a username field, so fill in the password.
-     */
-    _fillPassword : function (usernameField) {
-        this.log("fillPassword autocomplete username: " + usernameField.value);
-
-        var form = usernameField.form;
-        var doc = form.ownerDocument;
-
-        var hostname = this._getPasswordOrigin(doc.documentURI);
-        var formSubmitURL = this._getActionOrigin(form)
-
-        // Find the password field. We should always have at least one,
-        // or else something has gone rather wrong.
-        var pwFields = this._getPasswordFields(form, false);
-        if (!pwFields) {
-            const err = "No password field for autocomplete password fill.";
-
-            // We want to know about this even if debugging is disabled.
-            if (!this._debug)
-                dump(err);
-            else
-                this.log(err);
-
-            return;
-        }
-
-        // If there are multiple passwords fields, we can't really figure
-        // out what each field is for, so just fill out the last field.
-        var passwordField = pwFields[0].element;
-
-        // Temporary LoginInfo with the info we know.
-        var currentLogin = new this._nsLoginInfo();
-        currentLogin.init(hostname, formSubmitURL, null,
-                          usernameField.value, null,
-                          usernameField.name, passwordField.name);
-
-        // Look for a existing login and use its password.
-        var match = null;
-        var logins = this.findLogins({}, hostname, formSubmitURL, null);
-
-        if (!logins.some(function(l) {
-                                match = l;
-                                return currentLogin.matches(l, true);
-                        }))
-        {
-            this.log("Can't find a login for this autocomplete result.");
-            return;
-        }
-
-        this.log("Found a matching login, filling in password.");
-        passwordField.value = match.password;
     }
 }; // end of LoginManager implementation
 
 
 
@@ -1293,11 +1245,11 @@ UserAutoCompleteResult.prototype = {
         if (removeFromDB) {
             var pwmgr = Cc["@mozilla.org/login-manager;1"].
                         getService(Ci.nsILoginManager);
             pwmgr.removeLogin(removedLogin);
         }
-    },
+    }
 };
 
 var component = [LoginManager];
 function NSGetModule (compMgr, fileSpec) {
     return XPCOMUtils.generateModule(component);
diff -r 14ce7619e9c1 toolkit/components/passwordmgr/src/nsLoginManagerPrompter.js
--- a/toolkit/components/passwordmgr/src/nsLoginManagerPrompter.js	Sat Sep 06 22:21:37 2008 +1200
+++ b/toolkit/components/passwordmgr/src/nsLoginManagerPrompter.js	Mon Sep 08 10:35:46 2008 +0300
@@ -266,10 +266,15 @@ LoginManagerPrompter.prototype = {
                     checkBoxLabel, checkBox);
 
         if (!ok || !checkBox.value || !hostname)
             return ok;
 
+        if (!aPassword.value) {
+            this.log("No password entered, so won't offer to save.");
+            return ok;
+        }
+
         var newLogin = Cc["@mozilla.org/login-manager/loginInfo;1"].
                        createInstance(Ci.nsILoginInfo);
         newLogin.init(hostname, null, realm, aUsername.value, aPassword.value,
                       "", "");
 
@@ -348,11 +353,11 @@ LoginManagerPrompter.prototype = {
 
         var ok = this._promptService.promptPassword(this._window, aDialogTitle,
                                                     aText, aPassword,
                                                     checkBoxLabel, checkBox);
 
-        if (ok && checkBox.value && hostname) {
+        if (ok && checkBox.value && hostname && aPassword.value) {
             var newLogin = Cc["@mozilla.org/login-manager/loginInfo;1"].
                            createInstance(Ci.nsILoginInfo);
             newLogin.init(hostname, null, realm, username,
                           aPassword.value, "", "");
 
@@ -465,10 +470,15 @@ LoginManagerPrompter.prototype = {
         if (!ok || !rememberLogin || epicfail)
             return ok;
 
         try {
             var [username, password] = this._GetAuthInfo(aAuthInfo);
+
+            if (!password) {
+                this.log("No password entered, so won't offer to save.");
+                return ok;
+            }
 
             var newLogin = Cc["@mozilla.org/login-manager/loginInfo;1"].
                            createInstance(Ci.nsILoginInfo);
             newLogin.init(hostname, null, httpRealm,
                           username, password, "", "");
diff -r 14ce7619e9c1 toolkit/components/passwordmgr/test/test_basic_form_1pw.html
--- a/toolkit/components/passwordmgr/test/test_basic_form_1pw.html	Sat Sep 06 22:21:37 2008 +1200
+++ b/toolkit/components/passwordmgr/test/test_basic_form_1pw.html	Mon Sep 08 10:35:46 2008 +0300
@@ -2740,46 +2740,48 @@ function startTest() {
 function startTest() {
     var f;
 
     for (f = 1;   f <= 4;   f++) { checkForm(f, "testpass"); }
     for (f = 5;   f <= 6;   f++) { checkUnmodifiedForm(f); }
-    for (f = 7;   f <= 14;   f++) { checkForm(f, "testuser", "testpass"); }
-    todo(false, "Don't clobber prefilled differing password");
-    //for (f = 15;   f <= 18;  f++) { checkUnmodifiedForm(f); }
+    for (f = 7;   f <= 10;  f++) { checkForm(f, "testuser", "testpass"); }
+    // 11-14 have the password prefilled, we skip filling the username.
+    for (f = 11;  f <= 14;  f++) { checkUnmodifiedForm(f); }
+    for (f = 15;  f <= 18;  f++) { checkUnmodifiedForm(f); }
     for (f = 19;  f <= 26;  f++) { checkForm(f, "testuser", "testpass"); }
-    todo(false, "Don't clobber prefilled differing password");
-    //for (f = 27;  f <= 30;  f++) { checkUnmodifiedForm(f); }
+    for (f = 27;  f <= 30;  f++) { checkUnmodifiedForm(f); }
     for (f = 31;  f <= 42;  f++) { checkUnmodifiedForm(f); }
 
     todo(false, "Add support for password before username");
     //for (f = 43;  f <= 50;  f++) { checkForm(f, "testpass", "testuser"); }
     //for (f = 51;  f <= 54;  f++) { checkUnmodifiedForm(f); }
     //for (f = 55;  f <= 62;  f++) { checkForm(f, "testpass", "testuser"); }
     //for (f = 63;  f <= 78;  f++) { checkUnmodifiedForm(f); }
 
     //for (f = 79;  f <= 90;  f++) { checkUnmodifiedForm(f); }
 
-    for (f = 91;  f <= 98;  f++) { checkForm(f, "testuser", "testpass", ""); }
-    todo(false, "Don't clobber prefilled differing password");
-    //for (f = 99;  f <= 102; f++) { checkUnmodifiedForm(f); }
+    for (f = 91;  f <= 94;  f++) { checkForm(f, "testuser", "testpass", ""); }
+    // 95-98 have the password prefilled, we skip filling the username.
+    for (f = 95;  f <= 98;  f++) { checkUnmodifiedForm(f); }
+    for (f = 99;  f <= 102; f++) { checkUnmodifiedForm(f); }
     for (f = 103; f <= 110; f++) { checkForm(f, "testuser", "testpass", ""); }
-    todo(false, "Don't clobber prefilled differing password");
-    //for (f = 111;  f <= 114;  f++) { checkUnmodifiedForm(f); }
-    for (f = 115;  f <= 126; f++) { checkUnmodifiedForm(f); }
+    for (f = 111; f <= 114; f++) { checkUnmodifiedForm(f); }
+    for (f = 115; f <= 126; f++) { checkUnmodifiedForm(f); }
 
     todo(false, "Ambigious username fields,");
     //for (f = 127; f <= 134; f++) { checkForm(f, "testuser", "", "testpass"); }
 
     todo(false, "More of the same, just hard to split up...");
     //for (f = 135; f <= 138; f++) { checkUnmodifiedForm(f); }
     //for (f = 139; f <= 146; f++) { checkForm(f, "testuser", "", "testpass"); }
     //for (f = 147; f <= 162; f++) { checkUnmodifiedForm(f); }
 
-    for (f = 163; f <= 170; f++) { checkForm(f, "", "testuser", "testpass"); }
-    //for (f = 171; f <= 174; f++) { checkUnmodifiedForm(f); }
+    for (f = 163; f <= 166; f++) { checkForm(f, "", "testuser", "testpass"); }
+    // 167-170 have the password prefilled, we skip filling the username.
+    for (f = 167; f <= 170; f++) { checkUnmodifiedForm(f); }
+    for (f = 171; f <= 174; f++) { checkUnmodifiedForm(f); }
     for (f = 175; f <= 182; f++) { checkForm(f, "", "testuser", "testpass"); }
-    //for (f = 183; f <= 186; f++) { checkUnmodifiedForm(f); }
+    for (f = 183; f <= 186; f++) { checkUnmodifiedForm(f); }
     for (f = 187; f <= 198; f++) { checkUnmodifiedForm(f); }
 
     todo(false, "Add support for password before username");
     //for (f = 199; f <= 206; f++) { checkForm(f, "testpass", "testuser", ""); }
     //for (f = 207; f <= 210; f++) { checkUnmodifiedForm(f); }
diff -r 14ce7619e9c1 toolkit/components/passwordmgr/test/test_basic_form_1pw_2.html
--- a/toolkit/components/passwordmgr/test/test_basic_form_1pw_2.html	Sat Sep 06 22:21:37 2008 +1200
+++ b/toolkit/components/passwordmgr/test/test_basic_form_1pw_2.html	Mon Sep 08 10:35:46 2008 +0300
@@ -56,25 +56,34 @@ Login Manager test: forms with 1 passwor
     <input type='text'     name='uname' value=''>
     <input type='password' name='pname' value='' readonly>
     <button type='submit'>Submit</button>
 </form>
 
+<form id='form9' action='formtest.js'> 9
+    <input type='text'     name='uname' value='TESTUSER'>
+    <input type='password' name='pname' value=''>
+    <button type='submit'>Submit</button>
+</form>
+
 </div>
 
 <pre id="test">
 <script class="testbody" type="text/javascript">
 
 /** Test for Login Manager: simple form fill, part 2 **/
 
 function startTest() {
     var f;
 
+    // Test various combinations of disabled/readonly inputs
     checkForm(1, "testpass"); // control
     checkUnmodifiedForm(2);
     checkUnmodifiedForm(3);
     checkForm(4, "testuser", "testpass"); // control
     for (f = 5;  f <= 8;  f++) { checkUnmodifiedForm(f); }
+    // Test case-insensitive comparison of username field
+    checkForm(9, "testuser", "testpass");
 
     SimpleTest.finish();
 }
 
 
diff -r 14ce7619e9c1 toolkit/components/passwordmgr/test/test_basic_form_2pw_1.html
--- a/toolkit/components/passwordmgr/test/test_basic_form_2pw_1.html	Sat Sep 06 22:21:37 2008 +1200
+++ b/toolkit/components/passwordmgr/test/test_basic_form_2pw_1.html	Mon Sep 08 10:35:46 2008 +0300
@@ -15632,14 +15632,15 @@ print "</form>\n\n";
 /** Test for Login Manager: simple form fill **/
 
 function startTest() {
     var f;
 
-    for (f = 1;   f <= 64;  f++) { checkForm(f, "testuser", "testpass", null); }
-
-    todo(false, "testing forms 65-96 disabled");
-    //for (f = 65;  f <= 96;  f++) { checkUnmodifiedForm(f); }
+    for (f = 1;   f <= 32;  f++) { checkForm(f, "testuser", "testpass", null); }
+    // 33-64 have the password prefilled, we skip filling the username.
+    for (f = 33;  f <= 64;  f++) { checkUnmodifiedForm(f); }
+
+    for (f = 65;  f <= 96;  f++) { checkUnmodifiedForm(f); }
     todo(false, "testing forms 101-192 disabled");
     //for (f = 97;  f <= 160; f++) { checkForm(f, "testuser", "testpass", null); }
     //for (f = 161; f <= 192; f++) { checkUnmodifiedForm(f); }
     for (f = 193; f <= 288; f++) { checkUnmodifiedForm(f); }
 
diff -r 14ce7619e9c1 toolkit/components/passwordmgr/test/test_basic_form_autocomplete.html
--- a/toolkit/components/passwordmgr/test/test_basic_form_autocomplete.html	Sat Sep 06 22:21:37 2008 +1200
+++ b/toolkit/components/passwordmgr/test/test_basic_form_autocomplete.html	Mon Sep 08 10:35:46 2008 +0300
@@ -51,10 +51,17 @@ Login Manager test: multiple login autoc
   <form id="form6" action="http://autocomplete2" onsubmit="return false;">
     <input  type="text"       name="uname">
     <input  type="password"   name="pword">
     <button type="submit">Submit</button>
   </form>
+
+  <!-- This form will be manipulated to insert a different username field. -->
+  <form id="form7" action="http://autocomplete3" onsubmit="return false;">
+    <input  type="text"       name="uname">
+    <input  type="password"   name="pword">
+    <button type="submit">Submit</button>
+  </form>
 </div>
 
 <pre id="test">
 <script class="testbody" type="text/javascript">
 
@@ -101,17 +108,26 @@ var login4 = new nsLoginInfo(
 // login 5 only used in the single-user forms
 var login5 = new nsLoginInfo(
     "http://localhost:8888", "http://autocomplete2", null,
     "singleuser5", "singlepass5", "uname", "pword");
 
+var login6A = new nsLoginInfo(
+    "http://localhost:8888", "http://autocomplete3", null,
+    "form7user1", "form7pass1", "uname", "pword");
+var login6B = new nsLoginInfo(
+    "http://localhost:8888", "http://autocomplete3", null,
+    "form7user2", "form7pass2", "uname", "pword");
+
 // try/catch in case someone runs the tests manually, twice.
 try {
     pwmgr.addLogin(login1);
     pwmgr.addLogin(login2);
     pwmgr.addLogin(login3);
     pwmgr.addLogin(login4);
     pwmgr.addLogin(login5);
+    pwmgr.addLogin(login6A);
+    pwmgr.addLogin(login6B);
 } catch (e) {
     ok(false, "addLogin threw: " + e);
 }
 
 
@@ -532,14 +548,57 @@ function runTest(testNum) {
         // that was being suppressed would have been filled in otherwise)
         uname = $_(6, "uname");
         pword = $_(6, "pword");
         checkACForm("singleuser5", "singlepass5");
 
-        /* FALLTHRU */
+        pwmgr.removeLogin(login5);
+        testNum = 499;
+        break;
+
+    case 500:
+        // Turn our attention to form7
+        uname = $_(7, "uname");
+        pword = $_(7, "pword");
+        checkACForm("", "");
+
+        // Insert a new username field into the form. We'll then make sure
+        // that invoking the autocomplete doesn't try to fill the form.
+        var newField = document.createElement("input");
+        newField.setAttribute("type", "text");
+        newField.setAttribute("name", "uname2");
+        pword.parentNode.insertBefore(newField, pword);
+        is($_(7, "uname2").value, "", "Verifying empty uname2");;
+
+        // Delete login6B. It was created just to prevent filling in a login
+        // automatically, removing it makes it more likely that we'll catch a
+        // future regression with form filling here.
+        pwmgr.removeLogin(login6B);
+
+        // Trigger autocomplete popup
+        restoreForm();
+        doKey("down");
+        break;
+
+    case 501:
+        // Check first entry
+        doKey("down");
+        checkACForm("", ""); // value shouldn't update
+        doKey("return"); // not "enter"!
+        // The form changes, so we expect the old username field to get the
+        // selected autocomplete value, but neither the new username field nor
+        // the password field should have any values filled in.
+        checkACForm("form7user1", "");
+        is($_(7, "uname2").value, "", "Verifying empty uname2");;
+
+        pwmgr.removeLogin(login6A);
+
+
+        SimpleTest.finish();
+        return;
 
     default:
-        pwmgr.removeLogin(login5);
+        ok(false, "Unexpected invocataion of test #" + testNum);
         SimpleTest.finish();
         return;
   }
 
   setTimeout(runTest, 50, testNum + 1); // XXX 40ms was too slow, why?
diff -r 14ce7619e9c1 toolkit/components/places/src/nsNavHistoryResult.cpp
--- a/toolkit/components/places/src/nsNavHistoryResult.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/toolkit/components/places/src/nsNavHistoryResult.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -3495,10 +3495,13 @@ nsNavHistoryResultNode::OnItemChanged(PR
 nsNavHistoryResultNode::OnItemChanged(PRInt64 aItemId,
                                       const nsACString& aProperty,
                                       PRBool aIsAnnotationProperty,
                                       const nsACString& aValue)
 {
+  if (aItemId != mItemId)
+    return NS_OK;
+
   if (aProperty.EqualsLiteral("title")) {
     // XXX: what should we do if the new title is void?
     mTitle = aValue;
   }
   else if (aProperty.EqualsLiteral("uri")) {
diff -r 14ce7619e9c1 toolkit/components/places/tests/bookmarks/test_417228-other-roots.js
--- a/toolkit/components/places/tests/bookmarks/test_417228-other-roots.js	Sat Sep 06 22:21:37 2008 +1200
+++ b/toolkit/components/places/tests/bookmarks/test_417228-other-roots.js	Mon Sep 08 10:35:46 2008 +0300
@@ -84,11 +84,11 @@ tests.push({
                                            PlacesUtils.bookmarks.DEFAULT_INDEX, "test");
     }, this);
 
     // add a folder to exclude from replacing during restore
     // this will still be present post-restore
-    excludedFolderId =
+    var excludedFolderId =
       PlacesUtils.bookmarks.createFolder(PlacesUtils.placesRootId,
                                          "excluded",
                                          PlacesUtils.bookmarks.DEFAULT_INDEX);
     do_check_eq(rootNode.childCount, 6);
     this.excludeItemsFromRestore.push(excludedFolderId); 
diff -r 14ce7619e9c1 toolkit/components/places/tests/unit/test_451499.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/components/places/tests/unit/test_451499.js	Mon Sep 08 10:35:46 2008 +0300
@@ -0,0 +1,138 @@
+/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Bug 451499 code.
+ *
+ * The Initial Developer of the Original Code is Mozilla Corp.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Marco Bonardo <mak77bonardo.net> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+const TESTDIR = "toolkit/components/places/tests/unit/";
+ 
+// Get services
+try {
+  var histsvc = Cc["@mozilla.org/browser/nav-history-service;1"].
+                  getService(Ci.nsINavHistoryService);
+  var bmsvc = Cc["@mozilla.org/browser/nav-bookmarks-service;1"].
+                getService(Ci.nsINavBookmarksService);
+  var iconsvc = Cc["@mozilla.org/browser/favicon-service;1"].
+                  getService(Ci.nsIFaviconService);
+} catch(ex) {
+  do_throw("Could not get services\n");
+}
+
+/*
+ * readFileData()
+ *
+ * Reads the data from the specified nsIFile, and returns an array of bytes.
+ */
+function readFileData(aFile) {
+  var inputStream = Cc["@mozilla.org/network/file-input-stream;1"].
+                    createInstance(Ci.nsIFileInputStream);
+  // init the stream as RD_ONLY, -1 == default permissions.
+  inputStream.init(aFile, 0x01, -1, null);
+  var size = inputStream.available();
+
+  // use a binary input stream to grab the bytes.
+  var bis = Cc["@mozilla.org/binaryinputstream;1"].
+            createInstance(Ci.nsIBinaryInputStream);
+  bis.setInputStream(inputStream);
+
+  var bytes = bis.readByteArray(size);
+
+  if (size != bytes.length)
+      throw "Didn't read expected number of bytes";
+
+  return bytes;
+}
+
+var result;
+
+// main
+function run_test() {
+  var testURI = uri("http://places.test/");
+
+  // Setup a real favicon data
+  var iconName = "favicon-normal16.png";
+  var iconURI = uri("http://places.test/" + iconName);
+  var iconMimeType = "image/png";
+  var iconFile = do_get_file(TESTDIR + iconName);
+  var iconData = readFileData(iconFile);
+  do_check_eq(iconData.length, 286);
+  iconsvc.setFaviconData(iconURI,
+                         iconData, iconData.length, iconMimeType,
+                         Number.MAX_VALUE);
+
+  // Bookmark our test page, so it will appear in the query resultset
+  var testBookmark = bmsvc.insertBookmark(bmsvc.bookmarksMenuFolder,
+                                          testURI,
+                                          bmsvc.DEFAULT_INDEX,
+                                          "foo");
+
+  // Get the last 10 bookmarks added to menu or toolbar
+  var options = histsvc.getNewQueryOptions();
+  var query = histsvc.getNewQuery();
+  query.setFolders([bmsvc.bookmarksMenuFolder, bmsvc.toolbarFolder], 2);
+  options.queryType = Ci.nsINavHistoryQueryOptions.QUERY_TYPE_BOOKMARKS;
+  options.maxResults = 10;
+  options.excludeQueries = 1;
+  options.sortingMode = options.SORT_BY_DATE_DESCENDING;
+  result = histsvc.executeQuery(query, options);
+  // Associate a viewer to our result
+  result.viewer = {
+                    itemChanged: function(item) {
+                      // The favicon should not be set on the containing query.
+                      if (item.uri.substr(0,5) == "place")
+                        dump("\nTesting itemChanged on: \n " + item.uri + "\n\n");
+                        do_check_eq(item.icon.spec, null);
+                    }
+                  };
+  var root = result.root;
+  root.containerOpen = true;
+
+  // We set a favicon on testURI while the container is open.
+  // This favicon should be setup only for this website, not for the containing
+  // query, this will be checked by the viewer
+  iconsvc.setFaviconUrlForPage(testURI, iconURI);
+
+  do_test_pending();
+  // lazy timeout is 3s and favicons are lazy added
+  do_timeout(3500, "end_test();");
+}
+
+function end_test() {
+  var root = result.root;
+  root.containerOpen = false;
+  result.viewer = null;
+
+  do_test_finished();
+}
diff -r 14ce7619e9c1 toolkit/components/viewconfig/content/config.js
--- a/toolkit/components/viewconfig/content/config.js	Sat Sep 06 22:21:37 2008 +1200
+++ b/toolkit/components/viewconfig/content/config.js	Mon Sep 08 10:35:46 2008 +0300
@@ -419,19 +419,10 @@ function FilterPrefs()
       gPrefView.sort(gSortFunction);
   }
   view.treebox.invalidate();
   view.treebox.rowCountChanged(oldlen, gPrefView.length - oldlen);
   gotoPref(prefCol);
-  document.getElementById("button").disabled = !substring;
-}
-
-function ClearFilter(button)
-{
-  var textbox = document.getElementById("textbox");
-  textbox.value = "";
-  textbox.focus();
-  FilterPrefs();
 }
 
 function prefColSortFunction(x, y)
 {
   if (x.prefCol > y.prefCol)
diff -r 14ce7619e9c1 toolkit/components/viewconfig/content/config.xul
--- a/toolkit/components/viewconfig/content/config.xul	Sat Sep 06 22:21:37 2008 +1200
+++ b/toolkit/components/viewconfig/content/config.xul	Mon Sep 08 10:35:46 2008 +0300
@@ -97,12 +97,11 @@
     <spacer flex="2"/>
   </vbox>
   <vbox flex="1">
     <hbox id="filterRow" align="center">
       <label value="&filterPrefs.label;" accesskey="&filterPrefs.accesskey;" control="textbox"/>
-      <textbox id="textbox" flex="1" type="timed" timeout="500" oncommand="FilterPrefs();"/>
-      <button id="button" label="&showAll.label;" accesskey="&showAll.accesskey;" oncommand="ClearFilter();" disabled="true"/>
+      <textbox id="textbox" flex="1" type="search" oncommand="FilterPrefs();"/>
     </hbox>
   
     <tree id="configTree" flex="1" class="plain focusring" seltype="single"
           onselect="updateCommands('select');"
           enableColumnDrag="true" context="configContext">
diff -r 14ce7619e9c1 toolkit/library/libxul-config.mk
--- a/toolkit/library/libxul-config.mk	Sat Sep 06 22:21:37 2008 +1200
+++ b/toolkit/library/libxul-config.mk	Mon Sep 08 10:35:46 2008 +0300
@@ -39,17 +39,21 @@
 
 CPPSRCS += \
 	nsStaticXULComponents.cpp \
 	$(NULL)
 
+ifeq ($(OS_ARCH),WINNT)
+REQUIRES += libreg widget gfx
+CPPSRCS += \
+	nsDllMain.cpp \
+	$(NULL)
+endif
+
 ifeq ($(OS_ARCH)_$(GNU_CC),WINNT_)
-REQUIRES += libreg widget gfx
-
 CPPSRCS += \
 	dlldeps.cpp \
 	nsGFXDeps.cpp \
-	nsDllMain.cpp \
 	$(NULL)
 
 RCINCLUDE = xulrunner.rc
 
 ifndef MOZ_NATIVE_ZLIB
diff -r 14ce7619e9c1 toolkit/library/libxul-rules.mk
--- a/toolkit/library/libxul-rules.mk	Sat Sep 06 22:21:37 2008 +1200
+++ b/toolkit/library/libxul-rules.mk	Mon Sep 08 10:35:46 2008 +0300
@@ -41,10 +41,11 @@ EXTRA_DSO_LDOPTS += \
 	$(JPEG_LIBS) \
 	$(PNG_LIBS) \
 	$(LCMS_LIBS) \
 	$(MOZ_JS_LIBS) \
 	$(NSS_LIBS) \
+	$(MOZ_CAIRO_LIBS) \
 	$(NULL)
 
 ifdef MOZ_NATIVE_ZLIB
 EXTRA_DSO_LDOPTS += $(ZLIB_LIBS)
 else
@@ -87,12 +88,10 @@ endif
 
 ifeq ($(MOZ_WIDGET_TOOLKIT),gtk2)
 EXTRA_DSO_LDOPTS += $(MOZ_PANGO_LIBS)
 endif
 
-EXTRA_DSO_LDOPTS += $(MOZ_CAIRO_LIBS)
-
 export:: dlldeps.cpp
 
 dlldeps.cpp: $(topsrcdir)/xpcom/build/dlldeps.cpp
 	$(INSTALL) $^ .
 
diff -r 14ce7619e9c1 toolkit/locales/en-US/chrome/global/config.dtd
--- a/toolkit/locales/en-US/chrome/global/config.dtd	Sat Sep 06 22:21:37 2008 +1200
+++ b/toolkit/locales/en-US/chrome/global/config.dtd	Mon Sep 08 10:35:46 2008 +0300
@@ -42,13 +42,11 @@
 <!ENTITY aboutWarningText.label "Changing these advanced settings can be harmful to the stability, security, and performance of this application. You should only continue if you are sure of what you are doing.">
 <!ENTITY aboutWarningButton.label "I'll be careful, I promise!">
 <!ENTITY aboutWarningCheckbox.label "Show this warning next time">
 
 <!ENTITY filterPrefs.label "Filter:">
-<!ENTITY filterPrefs.accesskey "I">
-<!ENTITY showAll.label "Show All">
-<!ENTITY showAll.accesskey "W">
+<!ENTITY filterPrefs.accesskey "F">
 
 <!-- Columns -->
 <!ENTITY prefColumn.label "Preference Name">
 <!ENTITY lockColumn.label "Status">
 <!ENTITY typeColumn.label "Type">
diff -r 14ce7619e9c1 toolkit/mozapps/update/src/updater/updater.cpp
--- a/toolkit/mozapps/update/src/updater/updater.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/toolkit/mozapps/update/src/updater/updater.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -139,10 +139,12 @@ void LaunchChild(int argc, char **argv);
 
 // This variable lives in libbz2.  It's declared in bzlib_private.h, so we just
 // declare it here to avoid including that entire header file.
 #if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3)
 extern "C"  __attribute__((visibility("default"))) unsigned int BZ2_crc32Table[256];
+#elif defined(__SUNPRO_C) || defined(__SUNPRO_CC)
+extern "C" __global unsigned int BZ2_crc32Table[256];
 #else
 extern "C" unsigned int BZ2_crc32Table[256];
 #endif
 
 static unsigned int
diff -r 14ce7619e9c1 view/src/nsViewManager.cpp
--- a/view/src/nsViewManager.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/view/src/nsViewManager.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -1921,20 +1921,20 @@ NS_IMETHODIMP nsViewManager::EnableRefre
   if (mUpdateBatchCnt > 0)
     return NS_OK;
 
   mRefreshEnabled = PR_TRUE;
 
-  if (!mHasPendingUpdates) {
-    // Nothing to do
-    return NS_OK;
-  }
-
   // nested batching can combine IMMEDIATE with DEFERRED. Favour
-  // IMMEDIATE over DEFERRED and DEFERRED over NO_SYNC.
+  // IMMEDIATE over DEFERRED and DEFERRED over NO_SYNC.  We need to
+  // check for IMMEDIATE before checking mHasPendingUpdates, because
+  // the latter might be false as far as gecko is concerned but the OS
+  // might still have queued up expose events that it hasn't sent yet.
   if (aUpdateFlags & NS_VMREFRESH_IMMEDIATE) {
     FlushPendingInvalidates();
     Composite();
+  } else if (!mHasPendingUpdates) {
+    // Nothing to do
   } else if (aUpdateFlags & NS_VMREFRESH_DEFERRED) {
     PostInvalidateEvent();
   } else { // NO_SYNC
     FlushPendingInvalidates();
   }
diff -r 14ce7619e9c1 widget/src/windows/nsDataObj.cpp
--- a/widget/src/windows/nsDataObj.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/widget/src/windows/nsDataObj.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -366,11 +366,10 @@ nsDataObj::nsDataObj(nsIURI * uri)
   m_enumFE        = new CEnumFormatEtc(32);
  
   m_enumFE->AddRef();
 
   if (uri) {
-
     // A URI was obtained, so pass this through to the DataObject
     // so it can create a SourceURL for CF_HTML flavour
     uri->GetSpec(mSourceURL);
   }
 
@@ -381,16 +380,15 @@ nsDataObj::nsDataObj(nsIURI * uri)
 // destruction
 //-----------------------------------------------------
 nsDataObj::~nsDataObj()
 {
   NS_IF_RELEASE(mTransferable);
-  PRInt32 i;
-  for (i=0;i<mDataFlavors->Count();i++) {
-    nsCAutoString* df = reinterpret_cast<nsCAutoString *>(mDataFlavors->ElementAt(i));
+
+  for (PRInt32 i = 0; i < mDataFlavors->Count(); ++i) {
+    nsCString* df = reinterpret_cast<nsCString *>(mDataFlavors->ElementAt(i));
     delete df;
   }
-
   delete mDataFlavors;
 
   m_cRef = 0;
   m_enumFE->Release();
 
@@ -494,11 +492,11 @@ STDMETHODIMP nsDataObj::GetData(LPFORMAT
   // Firefox internal formats
   ULONG count;
   FORMATETC fe;
   m_enumFE->Reset();
   while (NOERROR == m_enumFE->Next(1, &fe, &count)) {
-    nsCAutoString * df = reinterpret_cast<nsCAutoString*>(mDataFlavors->SafeElementAt(dfInx));
+    nsCString * df = reinterpret_cast<nsCString*>(mDataFlavors->SafeElementAt(dfInx));
     if ( df ) {
       if (FormatsMatch(fe, *pFE)) {
         pSTM->pUnkForRelease = NULL;        // caller is responsible for deleting this data
         CLIPFORMAT format = pFE->cfFormat;
         switch(format) {
@@ -1439,29 +1437,29 @@ CLSID nsDataObj::GetClassID() const
 {
 	return CLSID_nsDataObj;
 }
 
 //-----------------------------------------------------
-// Registers a the DataFlavor/FE pair
+// Registers the DataFlavor/FE pair.
 //-----------------------------------------------------
 void nsDataObj::AddDataFlavor(const char* aDataFlavor, LPFORMATETC aFE)
 {
-  // These two lists are the mapping to and from data flavors and FEs
-  // Later, OLE will tell us it's needs a certain type of FORMATETC (text, unicode, etc)
-  // so we will look up data flavor that corresponds to the FE
-  // and then ask the transferable for that type of data
+  // These two lists are the mapping to and from data flavors and FEs.
+  // Later, OLE will tell us it needs a certain type of FORMATETC (text,
+  // unicode, etc), so we will look up the data flavor that corresponds to
+  // the FE and then ask the transferable for that type of data.
 
+#ifndef WINCE
   // Just ignore the CF_HDROP here
-  // all file drags are now hangled by CFSTR_FileContents format
-#ifndef WINCE
+  // all file drags are now handled by CFSTR_FileContents format
   if (aFE->cfFormat == CF_HDROP) {
     return;
   }  
   else 
 #endif
   {
-    mDataFlavors->AppendElement(new nsCAutoString(aDataFlavor));
+    mDataFlavors->AppendElement(new nsCString(aDataFlavor));
     m_enumFE->AddFE(aFE);
   }
 }
 
 //-----------------------------------------------------
diff -r 14ce7619e9c1 xpcom/base/nscore.h
--- a/xpcom/base/nscore.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/xpcom/base/nscore.h	Mon Sep 08 10:35:46 2008 +0300
@@ -105,10 +105,12 @@
 #define NS_VISIBILITY_HIDDEN
 #endif
 
 #if defined(HAVE_VISIBILITY_ATTRIBUTE)
 #define NS_VISIBILITY_DEFAULT __attribute__ ((visibility ("default")))
+#elif defined(__SUNPRO_C) || defined(__SUNPRO_CC)
+#define NS_VISIBILITY_DEFAULT __global
 #else
 #define NS_VISIBILITY_DEFAULT
 #endif
 
 #define NS_HIDDEN_(type)   NS_VISIBILITY_HIDDEN type
diff -r 14ce7619e9c1 xpcom/glue/nsISupportsImpl.h
--- a/xpcom/glue/nsISupportsImpl.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/xpcom/glue/nsISupportsImpl.h	Mon Sep 08 10:35:46 2008 +0300
@@ -962,25 +962,10 @@ NS_IMETHODIMP_(nsrefcnt) Class::Release(
     NS_INTERFACE_TABLE_ENTRY(Class, i10)                                      \
     NS_INTERFACE_TABLE_ENTRY(Class, i11)                                      \
     NS_INTERFACE_TABLE_ENTRY(Class, i12)                                      \
   NS_INTERFACE_TABLE_END
 
-#define NS_INTERFACE_TABLE_INHERITED10(Class, i1, i2, i3, i4, i5, i6, i7,     \
-                                       i8, i9, i10)                           \
-  NS_INTERFACE_TABLE_BEGIN                                                    \
-    NS_INTERFACE_TABLE_ENTRY(Class, i1)                                       \
-    NS_INTERFACE_TABLE_ENTRY(Class, i2)                                       \
-    NS_INTERFACE_TABLE_ENTRY(Class, i3)                                       \
-    NS_INTERFACE_TABLE_ENTRY(Class, i4)                                       \
-    NS_INTERFACE_TABLE_ENTRY(Class, i5)                                       \
-    NS_INTERFACE_TABLE_ENTRY(Class, i6)                                       \
-    NS_INTERFACE_TABLE_ENTRY(Class, i7)                                       \
-    NS_INTERFACE_TABLE_ENTRY(Class, i8)                                       \
-    NS_INTERFACE_TABLE_ENTRY(Class, i9)                                       \
-    NS_INTERFACE_TABLE_ENTRY(Class, i10)                                      \
-  NS_INTERFACE_TABLE_END
-
 #define NS_IMPL_QUERY_INTERFACE_INHERITED0(Class, Super)                      \
   NS_INTERFACE_TABLE_HEAD(Class)                                              \
   NS_INTERFACE_TABLE_INHERITED0(Class)                                        \
   NS_INTERFACE_TABLE_TAIL_INHERITING(Super)
 
diff -r 14ce7619e9c1 xpcom/glue/nsTraceRefcnt.h
--- a/xpcom/glue/nsTraceRefcnt.h	Sat Sep 06 22:21:37 2008 +1200
+++ b/xpcom/glue/nsTraceRefcnt.h	Mon Sep 08 10:35:46 2008 +0300
@@ -62,12 +62,10 @@
   NS_LogAddRef((_p), (_rc), (_type), (PRUint32) (_size))
 
 #define NS_LOG_RELEASE(_p, _rc, _type) \
   NS_LogRelease((_p), (_rc), (_type))
 
-#define MOZ_DECL_CTOR_COUNTER(_type)
-
 #define MOZ_COUNT_CTOR(_type)                                 \
 PR_BEGIN_MACRO                                                \
   NS_LogCtor((void*)this, #_type, sizeof(*this));             \
 PR_END_MACRO
 
@@ -89,11 +87,10 @@ PR_END_MACRO
 
 #else /* !NS_BUILD_REFCNT_LOGGING */
 
 #define NS_LOG_ADDREF(_p, _rc, _type, _size)
 #define NS_LOG_RELEASE(_p, _rc, _type)
-#define MOZ_DECL_CTOR_COUNTER(_type)
 #define MOZ_COUNT_CTOR(_type)
 #define MOZ_COUNT_DTOR(_type)
 
 #endif /* NS_BUILD_REFCNT_LOGGING */
 
diff -r 14ce7619e9c1 xpcom/tests/TestPipe.cpp
--- a/xpcom/tests/TestPipe.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/xpcom/tests/TestPipe.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -39,15 +39,15 @@
 
 #include "nsIPipe.h"
 #include "nsIMemory.h"
 
 /** NS_NewPipe2 reimplemented, because it's not exported by XPCOM */
-nsresult NS_NewPipe2(nsIAsyncInputStream** input,
+nsresult TP_NewPipe2(nsIAsyncInputStream** input,
                      nsIAsyncOutputStream** output,
                      PRBool nonBlockingInput,
                      PRBool nonBlockingOutput,
-                     size_t segmentSize,
+                     PRUint32 segmentSize,
                      PRUint32 segmentCount,
                      nsIMemory* segmentAlloc)
 {
   nsCOMPtr<nsIPipe> pipe = do_CreateInstance("@mozilla.org/pipe;1");
   if (!pipe)
@@ -181,11 +181,11 @@ NS_IMETHODIMP BackwardsAllocator::IsLowM
 
 
 nsresult TestBackwardsAllocator()
 {
   const PRUint32 SEGMENT_COUNT = 10;
-  const size_t SEGMENT_SIZE = 10;
+  const PRUint32 SEGMENT_SIZE = 10;
 
   nsRefPtr<BackwardsAllocator> allocator = new BackwardsAllocator();
   if (!allocator)
   {
     printf("Allocation of BackwardsAllocator failed!\n");
@@ -195,18 +195,18 @@ nsresult TestBackwardsAllocator()
   if (NS_FAILED(rv))
     return rv;
 
   nsCOMPtr<nsIAsyncInputStream> input;
   nsCOMPtr<nsIAsyncOutputStream> output;
-  rv = NS_NewPipe2(getter_AddRefs(input),
+  rv = TP_NewPipe2(getter_AddRefs(input),
                    getter_AddRefs(output),
                    PR_FALSE,
                    PR_FALSE,
                    SEGMENT_SIZE, SEGMENT_COUNT, allocator); 
   if (NS_FAILED(rv))
   {
-    printf("FAIL NS_NewPipe2 failed: %x\n", rv);
+    printf("FAIL TP_NewPipe2 failed: %x\n", rv);
     return rv;
   }
 
   const PRUint32 BUFFER_LENGTH = 100;
   const char written[] =
diff -r 14ce7619e9c1 xpfe/components/autocomplete/resources/content/autocomplete.xml
--- a/xpfe/components/autocomplete/resources/content/autocomplete.xml	Sat Sep 06 22:21:37 2008 +1200
+++ b/xpfe/components/autocomplete/resources/content/autocomplete.xml	Mon Sep 08 10:35:46 2008 +0300
@@ -592,10 +592,14 @@
 
       <!--  -->
       <method name="startLookup">
         <body><![CDATA[
           var str = this.currentSearchString;
+          if (!str) {
+            this.closeResultPopup();
+            return;
+          }
 
           this.isSearching = true;
           this.mFirstReturn = true;
           this.mSessionReturns = this.sessionCount;
           this.mFailureCount = 0;
@@ -707,17 +711,14 @@
           
           // if all searches are done and they all failed...
           if (this.mSessionReturns == 0 && this.mFailureCount == this.sessionCount) {
             if (this.minResultsForPopup == 0) {
               this.clearResults(true); // clear data and repaint empty
-              
-              if (this.value) {
-                this.openResultPopup();
-              } else
-                this.closeResultPopup(); 
-            } else
+              this.openResultPopup();
+            } else {
               this.closeResultPopup(); 
+            }
           }
         ]]></body>
       </method>
 
       <!-- does some stuff after a search is done (success or failure) -->
@@ -1303,10 +1304,11 @@
           clearResults: function()
           {
             var oldCount = this.mRowCount;
             this.mRowCount = 0;  
             this.mResults = [];
+            this.mCounts = [];
             
             if (this.mTree) {
               this.mTree.rowCountChanged(0, -oldCount);
               this.mTree.scrollToRow(0);
             }
diff -r 14ce7619e9c1 xpinstall/src/nsJSInstallTriggerGlobal.cpp
--- a/xpinstall/src/nsJSInstallTriggerGlobal.cpp	Sat Sep 06 22:21:37 2008 +1200
+++ b/xpinstall/src/nsJSInstallTriggerGlobal.cpp	Mon Sep 08 10:35:46 2008 +0300
@@ -100,11 +100,11 @@ JSClass InstallTriggerGlobalClass = {
 
 
 //
 // InstallTriggerGlobal finalizer
 //
-JS_STATIC_DLL_CALLBACK(void)
+static void
 FinalizeInstallTriggerGlobal(JSContext *cx, JSObject *obj)
 {
   nsISupports *nativeThis = (nsISupports*)JS_GetPrivate(cx, obj);
 
   if (nsnull != nativeThis) {
@@ -202,11 +202,11 @@ static nsIDOMInstallTriggerGlobal* getTr
 }
 
 //
 // Native method UpdateEnabled
 //
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 InstallTriggerGlobalUpdateEnabled(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
   nsIDOMInstallTriggerGlobal *nativeThis = getTriggerNative(cx, obj);
   if (!nativeThis)
     return JS_FALSE;
@@ -228,11 +228,11 @@ InstallTriggerGlobalUpdateEnabled(JSCont
 
 
 //
 // Native method Install
 //
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 InstallTriggerGlobalInstall(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
   nsIDOMInstallTriggerGlobal *nativeThis = getTriggerNative(cx, obj);
   if (!nativeThis)
     return JS_FALSE;
@@ -429,11 +429,11 @@ InstallTriggerGlobalInstall(JSContext *c
 
 
 //
 // Native method InstallChrome
 //
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 InstallTriggerGlobalInstallChrome(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
   nsIDOMInstallTriggerGlobal *nativeThis = getTriggerNative(cx, obj);
   if (!nativeThis)
     return JS_FALSE;
@@ -539,11 +539,11 @@ InstallTriggerGlobalInstallChrome(JSCont
 
 
 //
 // Native method StartSoftwareUpdate
 //
-JS_STATIC_DLL_CALLBACK(JSBool)
+static JSBool
 InstallTriggerGlobalStartSoftwareUpdate(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
   nsIDOMInstallTriggerGlobal *nativeThis = getTriggerNative(cx, obj);
   if (!nativeThis)
     return JS_FALSE;
diff -r 14ce7619e9c1 xulrunner/config/mozconfig
--- a/xulrunner/config/mozconfig	Sat Sep 06 22:21:37 2008 +1200
+++ b/xulrunner/config/mozconfig	Mon Sep 08 10:35:46 2008 +0300
@@ -1,7 +1,5 @@
-
 # This file specifies the build flags for XULRunner.  You can use it by adding:
 #  . $topsrcdir/xulrunner/config/mozconfig
 # to the top of your mozconfig file.
 
-mk_add_options MOZ_CO_PROJECT=xulrunner
 ac_add_options --enable-application=xulrunner
