diff -r 4f1383af8f10 browser/app/profile/firefox.js
--- a/browser/app/profile/firefox.js	Sat Nov 01 09:52:29 2008 +0100
+++ b/browser/app/profile/firefox.js	Mon Nov 03 05:09:07 2008 -0500
@@ -75,16 +75,19 @@ pref("extensions.getAddons.recommended.b
 pref("extensions.getAddons.recommended.browseURL", "https://%LOCALE%.add-ons.mozilla.com/%LOCALE%/%APP%/recommended");
 pref("extensions.getAddons.recommended.url", "https://services.addons.mozilla.org/%LOCALE%/%APP%/api/%API_VERSION%/list/featured/all/10/%OS%/%VERSION%");
 pref("extensions.getAddons.search.browseURL", "https://%LOCALE%.add-ons.mozilla.com/%LOCALE%/%APP%/search?q=%TERMS%");
 pref("extensions.getAddons.search.url", "https://services.addons.mozilla.org/%LOCALE%/%APP%/api/%API_VERSION%/search/%TERMS%/all/10/%OS%/%VERSION%");
 
 // Blocklist preferences
 pref("extensions.blocklist.enabled", true);
 pref("extensions.blocklist.interval", 86400);
+// Controls what level the blocklist switches from warning about items to forcibly
+// blocking them.
+pref("extensions.blocklist.level", 2);
 pref("extensions.blocklist.url", "https://addons.mozilla.org/blocklist/2/%APP_ID%/%APP_VERSION%/%PRODUCT%/%BUILD_ID%/%BUILD_TARGET%/%LOCALE%/%CHANNEL%/%OS_VERSION%/%DISTRIBUTION%/%DISTRIBUTION_VERSION%/");
 pref("extensions.blocklist.detailsURL", "http://%LOCALE%.www.mozilla.com/%LOCALE%/blocklist/");
 
 // Dictionary download preference
 pref("browser.dictionaries.download.url", "https://%LOCALE%.add-ons.mozilla.com/%LOCALE%/firefox/%VERSION%/dictionaries/");
 
 // App-specific update preferences
 
@@ -411,16 +414,27 @@ pref("intl.charsetmenu.browser.more5",  
 pref("intl.charsetmenu.browser.more5",  "chrome://global/locale/intl.properties");
 pref("intl.charsetmenu.browser.unicode",  "chrome://global/locale/intl.properties");
 pref("intl.charset.detector", "chrome://global/locale/intl.properties");
 pref("intl.charset.default",  "chrome://global-platform/locale/intl.properties");
 pref("font.language.group", "chrome://global/locale/intl.properties");
 pref("intl.menuitems.alwaysappendaccesskeys","chrome://global/locale/intl.properties");
 pref("intl.menuitems.insertseparatorbeforeaccesskeys","chrome://global/locale/intl.properties");
 
+pref("browser.gesture.swipe.left", "Browser:BackOrBackDuplicate");
+pref("browser.gesture.swipe.right", "Browser:ForwardOrForwardDuplicate");
+pref("browser.gesture.swipe.up", "cmd_scrollTop");
+pref("browser.gesture.swipe.down", "cmd_scrollBottom");
+pref("browser.gesture.pinch.out", "cmd_fullZoomEnlarge");
+pref("browser.gesture.pinch.in", "cmd_fullZoomReduce");
+pref("browser.gesture.pinch.out.shift", "cmd_fullZoomReset");
+pref("browser.gesture.pinch.in.shift", "cmd_fullZoomReset");
+pref("browser.gesture.twist.right", "Browser:NextTab");
+pref("browser.gesture.twist.left", "Browser:PrevTab");
+
 // 0=lines, 1=pages, 2=history , 3=text size
 #ifdef XP_MACOSX
 // On OS X, if the wheel has one axis only, shift+wheel comes through as a
 // horizontal scroll event. Thus, we can't assign anything other than normal
 // scrolling to shift+wheel.
 pref("mousewheel.withshiftkey.action",0);
 pref("mousewheel.withshiftkey.sysnumlines",true);
 pref("mousewheel.withshiftkey.numlines",1);
diff -r 4f1383af8f10 browser/base/content/browser-sets.inc
--- a/browser/base/content/browser-sets.inc	Sat Nov 01 09:52:29 2008 +0100
+++ b/browser/base/content/browser-sets.inc	Mon Nov 03 05:09:07 2008 -0500
@@ -108,16 +108,18 @@
     <command id="Browser:Stop"    oncommand="BrowserStop();" disabled="true"/>
     <command id="Browser:Reload"  oncommand="if (event.shiftKey) BrowserReloadSkipCache(); else BrowserReload()" disabled="true"/>
     <command id="Browser:ReloadOrDuplicate" oncommand="BrowserReloadOrDuplicate(event)" disabled="true">
       <observes element="Browser:Reload" attribute="disabled"/>
     </command>
     <command id="Browser:ReloadSkipCache" oncommand="BrowserReloadSkipCache()" disabled="true">
       <observes element="Browser:Reload" attribute="disabled"/>
     </command>
+    <command id="Browser:NextTab" oncommand="gBrowser.mTabContainer.advanceSelectedTab(1, true);"/>
+    <command id="Browser:PrevTab" oncommand="gBrowser.mTabContainer.advanceSelectedTab(-1, true);"/>
     <command id="cmd_fullZoomReduce"  oncommand="FullZoom.reduce()"/>
     <command id="cmd_fullZoomEnlarge" oncommand="FullZoom.enlarge()"/>
     <command id="cmd_fullZoomReset"   oncommand="FullZoom.reset()"/>
     <command id="cmd_fullZoomToggle"  oncommand="ZoomManager.toggleZoom();"/>
     <command id="Browser:OpenLocation" oncommand="openLocation();"/>
 
     <command id="Tools:Search" oncommand="BrowserSearch.webSearch();"/>    
     <command id="Tools:Downloads" oncommand="BrowserDownloadsUI();"/>
diff -r 4f1383af8f10 browser/base/content/browser.js
--- a/browser/base/content/browser.js	Sat Nov 01 09:52:29 2008 +0100
+++ b/browser/base/content/browser.js	Mon Nov 03 05:09:07 2008 -0500
@@ -676,17 +676,17 @@ let gGestureSupport = {
    * Add or remove mouse gesture event listeners
    *
    * @param aAddListener
    *        True to add/init listeners and false to remove/uninit
    */
   init: function GS_init(aAddListener) {
     const gestureEvents = ["SwipeGesture",
       "MagnifyGestureStart", "MagnifyGestureUpdate", "MagnifyGesture",
-      "RotateGesture", "RotateGestureUpdate", "RotateGesture"];
+      "RotateGestureStart", "RotateGestureUpdate", "RotateGesture"];
 
     let addRemove = aAddListener ? window.addEventListener :
       window.removeEventListener;
 
     for each (let event in gestureEvents)
       addRemove("Moz" + event, this, true);
   },
 
@@ -697,50 +697,129 @@ let gGestureSupport = {
    * @param aEvent
    *        The gesture event to handle
    */
   handleEvent: function GS_handleEvent(aEvent) {
     aEvent.stopPropagation();
 
     switch (aEvent.type) {
       case "MozSwipeGesture":
-        this.onSwipe(aEvent);
-        break;
+        return this.onSwipe(aEvent);
       case "MozMagnifyGestureStart":
       case "MozRotateGestureStart":
-        this.onStart(aEvent);
-        break;
+        return this.onStart(aEvent);
       case "MozMagnifyGestureUpdate":
-        this.onMagnify(aEvent);
-        break;
+        return this._handleUpdate(aEvent, 100, "pinch.out", "pinch.in");
       case "MozRotateGestureUpdate":
-        this.onRotate(aEvent);
-        break;
-    }
+        return this._handleUpdate(aEvent, 22.5, "twist.right", "twist.left");
+    }
+  },
+
+  /**
+   * Convert a gesture and pressed keys into the corresponding command action.
+   * The preference must have "shift" before "alt" before "ctrl" before "meta"
+   * with each separated by periods.
+   *
+   * @param aGestureKeys
+   *        An array that has the gesture type as the first element and
+   *        additional elements for each key pressed
+   * @return Id of the command to execute
+   */
+  _getCommand: function GS__getCommand(aGestureKeys) {
+    const gestureBranch = "browser.gesture."
+    try {
+      return gPrefService.getCharPref(gestureBranch + aGestureKeys.join("."));
+    }
+    // No preference is set, so don't give a command
+    catch (e) {}
+  },
+
+  /**
+   * Generator producing the powerset of the input array where the first result
+   * is the complete set and the last result (before StopIteration) is empty.
+   *
+   * @param aArray
+   *        Source array containing any number of elements
+   * @yield Array that is a subset of the input array from full set to empty
+   */
+  _power: function GS__power(aArray) {
+    // Create a bitmask based on the length of the array
+    let num = 1 << aArray.length;
+    while (--num >= 0)
+      // Only select array elements where the current bit is set
+      yield aArray.reduce(function(aPrev, aCurr, aIndex) {
+        if (num & 1 << aIndex)
+          aPrev.push(aCurr);
+        return aPrev;
+      }, []);
+  },
+
+  /**
+   * Determine what action to do for the gesture based on which keys are
+   * pressed and which commands are set
+   *
+   * @param aEvent
+   *        The original gesture event to convert into a fake click event
+   * @param aGesture
+   *        Name of the gesture
+   */
+  _doAction: function GS__doAction(aEvent, aGesture) {
+    // Create a fake event that pretends the gesture is a button click
+    let fakeEvent = { shiftKey: aEvent.shiftKey, ctrlKey: aEvent.ctrlKey,
+      metaKey: aEvent.metaKey, altKey: aEvent.altKey, button: 0 };
+
+    // Create an array of pressed keys in a fixed order so that a command for
+    // "meta" is preferred over "ctrl" when both buttons are pressed (and a
+    // command for both don't exist)
+    let keyCombos = [];
+    const keys = ["shift", "alt", "ctrl", "meta"];
+    for each (let key in keys)
+      if (aEvent[key + "Key"]) 
+        keyCombos.push(key);
+
+    try {
+      // Try each combination of key presses in decreasing order for commands
+      for (let subCombo in this._power(keyCombos)) {
+        let command = this._getCommand([aGesture].concat(subCombo));
+        // Do the command if we found one to do
+        if (command) {
+          let node = document.getElementById(command);
+          // Use the command element if it exists
+          if (node && node.hasAttribute("oncommand"))
+            // XXX: Use node.oncommand(event) once bug 246720 is fixed
+            return node.getAttribute("disabled") == "true" ? true :
+              new Function("event", node.getAttribute("oncommand")).
+              call(node, fakeEvent);
+
+          // Otherwise it should be a "standard" command
+          return goDoCommand(command);
+        }
+      }
+    }
+    // The generator ran out of key combinations, so just do nothing
+    catch (e) {}
   },
 
   /**
    * Convert the swipe gesture into a browser action based on the direction
    *
    * @param aEvent
    *        The swipe event to handle
    */
   onSwipe: function GS_onSwipe(aEvent) {
-    // Create a fake event that pretends the swipe is a button click
-    let fakeEvent = { shiftKey: aEvent.shiftKey, ctrlKey: aEvent.ctrlKey,
-      metaKey: aEvent.metaKey, altKey: aEvent.altKey, button: 0 };
-
-    if (aEvent.direction == SimpleGestureEvent.DIRECTION_LEFT)
-      BrowserBack(fakeEvent);
-    else if (aEvent.direction == SimpleGestureEvent.DIRECTION_RIGHT)
-      BrowserForward(fakeEvent);
-    else if (aEvent.direction == SimpleGestureEvent.DIRECTION_UP)
-      goDoCommand("cmd_scrollTop");
-    else if (aEvent.direction == SimpleGestureEvent.DIRECTION_DOWN)
-      goDoCommand("cmd_scrollBottom");
+    switch (aEvent.direction) {
+      case SimpleGestureEvent.DIRECTION_LEFT:
+        return this._doAction(aEvent, "swipe.left");
+      case SimpleGestureEvent.DIRECTION_RIGHT:
+        return this._doAction(aEvent, "swipe.right");
+      case SimpleGestureEvent.DIRECTION_UP:
+        return this._doAction(aEvent, "swipe.up");
+      case SimpleGestureEvent.DIRECTION_DOWN:
+        return this._doAction(aEvent, "swipe.down");
+    }
   },
 
   // Keep track of offsets for continual motion events, e.g., zoom and rotate
   _lastOffset: 0,
 
   /**
    * Handle the beginning of a continual motion event
    *
@@ -755,50 +834,30 @@ let gGestureSupport = {
    * Helper function to determine if a continual motion event has passed some
    * threshold and should trigger some action. If the action is triggered, the
    * tracking of the motion is reset as if a new motion has started.
    *
    * @param aEvent
    *        The continual motion event to handle
    * @param aThreshold
    *        Minimum positive/negative difference before the action is triggered
-   * @param aIncDec
-   *        Callback function that takes in the current offset
-   */
-  _handleUpdate: function GS__handleUpdate(aEvent, aThreshold, aIncDec) {
+   * @param aInc
+   *        Name of the gesture for increasing motion
+   * @param aDec
+   *        Name of the gesture for decreasing motion
+   */
+  _handleUpdate: function GS__handleUpdate(aEvent, aThreshold, aInc, aDec) {
     // Update the offset with new event data
     this._lastOffset += aEvent.delta;
 
-    // Inform the callback that we passed the threshold and then reset motion
+    // Do the gesture action when we pass the threshold and then reset motion
     if (Math.abs(this._lastOffset) > aThreshold) {
-      aIncDec(this._lastOffset);
+      this._doAction(aEvent, this._lastOffset > 0 ? aInc : aDec);
       this.onStart(aEvent);
     }
-  },
-
-  /**
-   * Convert zoom motions into a page zoom in/out
-   *
-   * @param aEvent
-   *        The zoom event to handle
-   */
-  onMagnify: function GS_onMagnify(aEvent) {
-    this._handleUpdate(aEvent, 100, function(aOffset) aOffset > 0 ?
-      FullZoom.enlarge() : FullZoom.reduce());
-  },
-
-  /**
-   * Convert rotate motions into a next/prev tab
-   *
-   * @param aEvent
-   *        The rotate event to handle
-   */
-  onRotate: function GS_onRotate(aEvent) {
-    this._handleUpdate(aEvent, 22.5, function(aOffset) gBrowser.mTabContainer.
-      advanceSelectedTab(aOffset > 0 ? 1 : -1, true));
   },
 };
 
 function BrowserStartup() {
   var uriToLoad = null;
 
   // window.arguments[0]: URI to load (string), or an nsISupportsArray of
   //                      nsISupportsStrings to load
@@ -1143,24 +1202,16 @@ function delayedStartup(isLoadingBlank, 
 
 #ifdef XP_MACOSX
   // Setup click-and-hold gestures access to the session history
   // menus if global click-and-hold isn't turned on
   if (!getBoolPref("ui.click_hold_context_menus", false))
     SetClickAndHoldHandlers();
 #endif
 
-  // Initialize the microsummary service by retrieving it, prompting its factory
-  // to create its singleton, whose constructor initializes the service.
-  try {
-    Cc["@mozilla.org/microsummary/service;1"].getService(Ci.nsIMicrosummaryService);
-  } catch (ex) {
-    Components.utils.reportError("Failed to init microsummary service:\n" + ex);
-  }
-
   // Initialize the full zoom setting.
   // We do this before the session restore service gets initialized so we can
   // apply full zoom settings to tabs restored by the session restore service.
   try {
     FullZoom.init();
   }
   catch(ex) {
     Components.utils.reportError("Failed to init content pref service:\n" + ex);
@@ -1206,21 +1257,32 @@ function delayedStartup(isLoadingBlank, 
   gBrowser.addEventListener("command", BrowserOnCommand, false);
 
   tabPreviews.init();
   if ((!gPrefService.prefHasUserValue("browser.ctrlTab.disallowForScreenReaders") ||
        !gPrefService.getBoolPref("browser.ctrlTab.disallowForScreenReaders")) &&
        gPrefService.getBoolPref("browser.ctrlTab.mostRecentlyUsed"))
     ctrlTab.init();
 
+  // Initialize the microsummary service by retrieving it, prompting its factory
+  // to create its singleton, whose constructor initializes the service.
+  // Started 4 seconds after delayedStartup (before the livemarks service below).
+  setTimeout(function() {
+    try {
+      Cc["@mozilla.org/microsummary/service;1"].getService(Ci.nsIMicrosummaryService);
+    } catch (ex) {
+      Components.utils.reportError("Failed to init microsummary service:\n" + ex);
+    }
+  }, 4000);
+
   // Delayed initialization of the livemarks update timer.
   // Livemark updates don't need to start until after bookmark UI 
   // such as the toolbar has initialized. Starting 5 seconds after
-  // delayedStartup in order to stagger this before the download
-  // manager starts (see below).
+  // delayedStartup in order to stagger this after the microsummary
+  // service (see above) and before the download manager starts (see below).
   setTimeout(function() PlacesUtils.livemarks.start(), 5000);
 
   // Initialize the download manager some time after the app starts so that
   // auto-resume downloads begin (such as after crashing or quitting with
   // active downloads) and speeds up the first-load of the download manager UI.
   // If the user manually opens the download manager before the timeout, the
   // downloads will start right away, and getting the service again won't hurt.
   setTimeout(function() {
diff -r 4f1383af8f10 browser/components/places/content/editBookmarkOverlay.js
--- a/browser/components/places/content/editBookmarkOverlay.js	Sat Nov 01 09:52:29 2008 +0100
+++ b/browser/components/places/content/editBookmarkOverlay.js	Mon Nov 03 05:09:07 2008 -0500
@@ -190,18 +190,23 @@ var gEditItemOverlay = {
         var tags = PlacesUtils.tagging.getTagsForURI(this._uri, {}).join(", ");
         this._initTextField("tagsField", tags, false);
       }
       else {
         this._multiEdit = true;
         this._allTags = [];
         this._itemIds = aItemIdList;
         var nodeToCheck = 0;
-        for (var i = 0; i < this._itemIds.length; i++) {
-          this._uris[i] = PlacesUtils.bookmarks.getBookmarkURI(this._itemIds[i], {});
+        for (var i = 0; i < aItemIdList.length; i++) {
+          if (aItemIdList[i] instanceof Ci.nsIURI) {
+            this._uris[i] = aItemIdList[i];
+            this._itemIds[i] = -1;
+          }
+          else
+            this._uris[i] = PlacesUtils.bookmarks.getBookmarkURI(this._itemIds[i], {});
           this._tags[i] = PlacesUtils.tagging.getTagsForURI(this._uris[i], {});
           if (this._tags[i].length < this._tags[nodeToCheck].length)
             nodeToCheck =  i;
         }
         this._getCommonTags(nodeToCheck);
         this._initTextField("tagsField", this._allTags.join(", "), false);
         this._element("itemsCountText").value =
           PlacesUIUtils.getFormattedString("detailsPane.multipleItems",
diff -r 4f1383af8f10 browser/components/places/content/places.js
--- a/browser/components/places/content/places.js	Sat Nov 01 09:52:29 2008 +0100
+++ b/browser/components/places/content/places.js	Mon Nov 03 05:09:07 2008 -0500
@@ -678,27 +678,29 @@ var PlacesOrganizer = {
                                    PlacesUtils._uri(aSelectedNode.uri),
                                    { hiddenRows: ["folderPicker"] });
       }
       this._detectAndSetDetailsPaneMinimalState(aSelectedNode);
     }
     else if (!aSelectedNode && aNodeList[0]) {
       var itemIds = [];
       for (var i = 0; i < aNodeList.length; i++) {
-        if (!PlacesUtils.nodeIsBookmark(aNodeList[i])) {
+        if (!PlacesUtils.nodeIsBookmark(aNodeList[i]) &&
+            !PlacesUtils.nodeIsURI(aNodeList[i])) {
           detailsDeck.selectedIndex = 0;
           var selectItemDesc = document.getElementById("selectItemDescription");
           var itemsCountLabel = document.getElementById("itemsCountText");
           selectItemDesc.hidden = false;
           itemsCountLabel.value =
             PlacesUIUtils.getFormattedString("detailsPane.multipleItems",
                                              [aNodeList.length]);
           return;
         }
-        itemIds[i] = PlacesUtils.getConcreteItemId(aNodeList[i]);
+        itemIds[i] = aNodeList[i].itemId != -1 ? aNodeList[i].itemId :
+                     PlacesUtils._uri(aNodeList[i].uri);
       }
       detailsDeck.selectedIndex = 1;
       gEditItemOverlay.initPanel(itemIds,
                                  { hiddenRows: ["folderPicker",
                                                 "loadInSidebar",
                                                 "location",
                                                 "keyword",
                                                 "description",
diff -r 4f1383af8f10 browser/components/sessionstore/src/nsSessionStore.js
--- a/browser/components/sessionstore/src/nsSessionStore.js	Sat Nov 01 09:52:29 2008 +0100
+++ b/browser/components/sessionstore/src/nsSessionStore.js	Mon Nov 03 05:09:07 2008 -0500
@@ -146,16 +146,19 @@ SessionStoreService.prototype = {
 
   // in case the last closed window ain't a navigator:browser one
   // (also contains browser popup windows closed after the last non-popup one)
   _lastClosedWindows: null,
 
   // not-"dirty" windows usually don't need to have their data updated
   _dirtyWindows: {},
 
+  // collection of session states yet to be restored
+  _statesToRestore: {},
+
   // counts the number of crashes since the last clean start
   _recentCrashes: 0,
 
 /* ........ Global Event Handlers .............. */
 
   /**
    * Initialize the component
    */
@@ -215,20 +218,24 @@ SessionStoreService.prototype = {
         
         let lastSessionCrashed =
           this._initialState.session && this._initialState.session.state &&
           this._initialState.session.state == STATE_RUNNING_STR;
         if (lastSessionCrashed) {
           this._recentCrashes = (this._initialState.session &&
                                  this._initialState.session.recentCrashes || 0) + 1;
           
-          if (this._needsRestorePage(this._initialState, this._recentCrashes))
+          if (this._needsRestorePage(this._initialState, this._recentCrashes)) {
             // replace the crashed session with a restore-page-only session
-            this._initialState =
-              { windows: [{ tabs: [{ entries: [{ url: "about:sessionrestore" }] }] }] };
+            let pageData = {
+              url: "about:sessionrestore",
+              formdata: { "#sessionData": iniString }
+            };
+            this._initialState = { windows: [{ tabs: [{ entries: [pageData] }] }] };
+          }
         }
         
         // make sure that at least the first window doesn't have anything hidden
         delete this._initialState.windows[0].hidden;
       }
       catch (ex) { debug("The session file is invalid: " + ex); }
     }
 
@@ -433,34 +440,38 @@ SessionStoreService.prototype = {
     if (!aWindow.toolbar.visible)
       this._windows[aWindow.__SSi].isPopup = true;
     
     // perform additional initialization when the first window is loading
     if (this._loadState == STATE_STOPPED) {
       this._loadState = STATE_RUNNING;
       this._lastSaveTime = Date.now();
       
-      // don't save during the first ten seconds
-      // (until most of the pages have been restored)
-      this.saveStateDelayed(aWindow, 10000);
-
       // restore a crashed session resp. resume the last session if requested
       if (this._initialState) {
         // make sure that the restored tabs are first in the window
         this._initialState._firstTabs = true;
         this._restoreCount = this._initialState.windows ? this._initialState.windows.length : 0;
         this.restoreWindow(aWindow, this._initialState, this._isCmdLineEmpty(aWindow));
         delete this._initialState;
       }
       else {
         // Nothing to restore, notify observers things are complete.
         var observerService = Cc["@mozilla.org/observer-service;1"].
                               getService(Ci.nsIObserverService);
         observerService.notifyObservers(null, NOTIFY_WINDOWS_RESTORED, "");
       }
+      
+      // mark ourselves as running
+      this.saveState(true);
+    }
+    // this window was opened by _openWindowWithState
+    else if (!this._isWindowLoaded(aWindow)) {
+      let followUp = this._statesToRestore[aWindow.__SS_restoreID].windows.length == 1;
+      this.restoreWindow(aWindow, this._statesToRestore[aWindow.__SS_restoreID], true, followUp);
     }
     
     var tabbrowser = aWindow.getBrowser();
     var tabpanels = tabbrowser.mPanelContainer;
     
     // add tab change listeners to all already existing tabs
     for (var i = 0; i < tabpanels.childNodes.length; i++) {
       this.onTabAdd(aWindow, tabpanels.childNodes[i], true);
@@ -474,61 +485,72 @@ SessionStoreService.prototype = {
   /**
    * On window close...
    * - remove event listeners from tabs
    * - save all window data
    * @param aWindow
    *        Window reference
    */
   onClose: function sss_onClose(aWindow) {
+    // this window was about to be restored - conserve its original data, if any
+    let isFullyLoaded = this._isWindowLoaded(aWindow);
+    if (!isFullyLoaded) {
+      if (!aWindow.__SSi)
+        aWindow.__SSi = "window" + Date.now();
+      this._window[aWindow.__SSi] = this._statesToRestore[aWindow.__SS_restoreID];
+      delete this._statesToRestore[aWindow.__SS_restoreID];
+      delete aWindow.__SS_restoreID;
+    }
+    
     // ignore windows not tracked by SessionStore
     if (!aWindow.__SSi || !this._windows[aWindow.__SSi]) {
       return;
     }
     
     if (this.windowToFocus && this.windowToFocus == aWindow) {
       delete this.windowToFocus;
     }
     
     var tabbrowser = aWindow.getBrowser();
     var tabpanels = tabbrowser.mPanelContainer;
 
     tabbrowser.removeEventListener("TabOpen", this, true);
     tabbrowser.removeEventListener("TabClose", this, true);
     tabbrowser.removeEventListener("TabSelect", this, true);
     
+    let winData = this._windows[aWindow.__SSi];
     if (this._loadState == STATE_RUNNING) { // window not closed during a regular shut-down 
       // update all window data for a last time
       this._collectWindowData(aWindow);
       
       // preserve this window's data (in case it was the last navigator:browser)
-      var winData = this._windows[aWindow.__SSi];
-      winData.title = aWindow.content.document.title;
-      
       // if this is a popup window, append it to what we've already got (cf. bug 368677)
       if (!this._lastClosedWindows || !winData.isPopup)
         this._lastClosedWindows = [winData];
       else
         this._lastClosedWindows.push(winData);
       
-      this._updateCookies(this._lastClosedWindows);
+      if (isFullyLoaded) {
+        winData.title = aWindow.content.document.title;
+        this._updateCookies(this._lastClosedWindows);
+      }
       
       // clear this window from the list
       delete this._windows[aWindow.__SSi];
       
       // save the state without this window to disk
       this.saveStateDelayed();
     }
     
     for (var i = 0; i < tabpanels.childNodes.length; i++) {
       this.onTabRemove(aWindow, tabpanels.childNodes[i], true);
     }
     
     // cache the window state until the window is completely gone
-    aWindow.__SS_dyingCache = this._windows[aWindow.__SSi] || winData;
+    aWindow.__SS_dyingCache = winData;
     
     // reset the _tab property to avoid keeping the tab's XUL element alive
     // longer than we need it
     var tabCount = aWindow.__SS_dyingCache.tabs.length;
     for (var t = 0; t < tabCount; t++) {
       delete aWindow.__SS_dyingCache.tabs[t]._tab;
     }
     
@@ -696,31 +718,38 @@ SessionStoreService.prototype = {
 
 /* ........ nsISessionStore API .............. */
 
   getBrowserState: function sss_getBrowserState() {
     return this._toJSONString(this._getCurrentState());
   },
 
   setBrowserState: function sss_setBrowserState(aState) {
+    try {
+      var state = this._safeEval("(" + aState + ")");
+    }
+    catch (ex) { /* invalid state object - don't restore anything */ }
+    if (!state || !state.windows)
+      throw (Components.returnCode = Cr.NS_ERROR_INVALID_ARG);
+    
     var window = this._getMostRecentBrowserWindow();
     if (!window) {
-      this._openWindowWithState("(" + aState + ")");
+      this._openWindowWithState(state);
       return;
     }
 
     // close all other browser windows
     this._forEachBrowserWindow(function(aWindow) {
       if (aWindow != window) {
         aWindow.close();
       }
     });
 
     // restore to the given state
-    this.restoreWindow(window, "(" + aState + ")", true);
+    this.restoreWindow(window, state, true);
   },
 
   getWindowState: function sss_getWindowState(aWindow) {
     if (!aWindow.__SSi && !aWindow.__SS_dyingCache)
       throw (Components.returnCode = Cr.NS_ERROR_INVALID_ARG);
     
     if (!aWindow.__SSi)
       return this._toJSONString({ windows: [aWindow.__SS_dyingCache] });
@@ -1409,16 +1438,18 @@ SessionStoreService.prototype = {
    * @returns string
    */
   _getCurrentState: function sss_getCurrentState(aUpdateAll) {
     var activeWindow = this._getMostRecentBrowserWindow();
     
     if (this._loadState == STATE_RUNNING) {
       // update the data for all windows with activities since the last save operation
       this._forEachBrowserWindow(function(aWindow) {
+        if (!this._isWindowLoaded(aWindow)) // window data is still in _statesToRestore
+          return;
         if (aUpdateAll || this._dirtyWindows[aWindow.__SSi] || aWindow == activeWindow) {
           this._collectWindowData(aWindow);
         }
         else { // always update the window features (whose change alone never triggers a save operation)
           this._updateWindowFeatures(aWindow);
         }
       }, this);
       this._dirtyWindows = [];
@@ -1431,16 +1462,25 @@ SessionStoreService.prototype = {
     for (ix in this._windows) {
       total.push(this._windows[ix]);
       windows.push(ix);
       if (!this._windows[ix].isPopup)
         nonPopupCount++;
     }
     this._updateCookies(total);
     
+    // collect the data for all windows yet to be restored
+    for (ix in this._statesToRestore) {
+      for each (let winData in this._statesToRestore[ix].windows) {
+        total.push(winData);
+        if (!winData.isPopup)
+          nonPopupCount++;
+      }
+    }
+    
     // if no non-popup browser window remains open, return the state of the last closed window(s)
     if (nonPopupCount == 0 && this._lastClosedWindows) {
       // prepend the last non-popup browser window, so that if the user loads more tabs
       // at startup we don't accidentally add them to a popup window
       total = this._lastClosedWindows.concat(total);
     }
     if (activeWindow) {
       this.activeWindowSSiCache = activeWindow.__SSi || "";
@@ -1452,27 +1492,33 @@ SessionStoreService.prototype = {
 
   /**
    * serialize session data for a window 
    * @param aWindow
    *        Window reference
    * @returns string
    */
   _getWindowState: function sss_getWindowState(aWindow) {
+    if (!this._isWindowLoaded(aWindow))
+      return this._statesToRestore[aWindow.__SS_restoreID];
+    
     if (this._loadState == STATE_RUNNING) {
       this._collectWindowData(aWindow);
     }
     
     var total = [this._windows[aWindow.__SSi]];
     this._updateCookies(total);
     
     return { windows: total };
   },
 
   _collectWindowData: function sss_collectWindowData(aWindow) {
+    if (!this._isWindowLoaded(aWindow))
+      return;
+    
     // update the internal state data for this window
     this._saveWindowHistory(aWindow);
     this._updateTextAndScrollData(aWindow);
     this._updateCookieHosts(aWindow);
     this._updateWindowFeatures(aWindow);
     
     this._dirtyWindows[aWindow.__SSi] = false;
   },
@@ -1643,16 +1689,22 @@ SessionStoreService.prototype = {
     }
     
     // make sure to restore the selected tab first (if any)
     if (aSelectTab-- && aTabs[aSelectTab]) {
         aTabs.unshift(aTabs.splice(aSelectTab, 1)[0]);
         tabbrowser.selectedTab = aTabs[0]._tab;
     }
 
+    if (!this._isWindowLoaded(aWindow)) {
+      // from now on, the data will come from the actual window
+      delete this._statesToRestore[aWindow.__SS_restoreID];
+      delete aWindow.__SS_restoreID;
+    }
+    
     // helper hash for ensuring unique frame IDs
     var idMap = { used: {} };
     this.restoreHistory(aWindow, aTabs, idMap);
   },
 
   /**
    * Restory history for a window
    * @param aWindow
@@ -2199,23 +2251,20 @@ SessionStoreService.prototype = {
     argString.data = "";
 
     //XXXzeniko shouldn't it be possible to set the window's dimensions here (as feature)?
     var window = Cc["@mozilla.org/embedcomp/window-watcher;1"].
                  getService(Ci.nsIWindowWatcher).
                  openWindow(null, this._prefBranch.getCharPref("chromeURL"), "_blank",
                             "chrome,dialog=no,all", argString);
     
-    window.__SS_state = aState;
-    var _this = this;
-    window.addEventListener("load", function(aEvent) {
-      aEvent.currentTarget.removeEventListener("load", arguments.callee, true);
-      _this.restoreWindow(aEvent.currentTarget, aEvent.currentTarget.__SS_state, true, true);
-      delete aEvent.currentTarget.__SS_state;
-    }, true);
+    do {
+      var ID = "window" + Math.random();
+    } while (ID in this._statesToRestore);
+    this._statesToRestore[(window.__SS_restoreID = ID)] = aState;
     
     return window;
   },
 
   /**
    * Whether or not to resume session, if not recovering from a crash.
    * @returns bool
    */
@@ -2396,16 +2445,26 @@ SessionStoreService.prototype = {
         // This was the last window restored at startup, notify observers.
         var observerService = Cc["@mozilla.org/observer-service;1"].
                               getService(Ci.nsIObserverService);
         observerService.notifyObservers(null, NOTIFY_WINDOWS_RESTORED, "");
       }
     }
   },
 
+  /**
+   * @param aWindow
+   *        Window reference
+   * @returns whether this window's data is still cached in _statesToRestore
+   *          because it's not fully loaded yet
+   */
+  _isWindowLoaded: function sss_isWindowLoaded(aWindow) {
+    return !aWindow.__SS_restoreID;
+  },
+
 /* ........ Storage API .............. */
 
   /**
    * write file to disk
    * @param aFile
    *        nsIFile
    * @param aData
    *        String data
diff -r 4f1383af8f10 browser/components/sessionstore/test/browser/browser_448741.js
--- a/browser/components/sessionstore/test/browser/browser_448741.js	Sat Nov 01 09:52:29 2008 +0100
+++ b/browser/components/sessionstore/test/browser/browser_448741.js	Mon Nov 03 05:09:07 2008 -0500
@@ -40,16 +40,17 @@ function test() {
   // test setup
   let ss = Cc["@mozilla.org/browser/sessionstore;1"].getService(Ci.nsISessionStore);
   let os = Cc["@mozilla.org/observer-service;1"].getService(Ci.nsIObserverService);
   let tabbrowser = getBrowser();
   waitForExplicitFinish();
   
   let uniqueName = "bug 448741";
   let uniqueValue = "as good as unique: " + Date.now();
+  let interval = gPrefService.getIntPref("browser.sessionstore.interval");
   
   // set a unique value on a new, blank tab
   var tab = tabbrowser.addTab();
   ss.setTabValue(tab, uniqueName, uniqueValue);
   let valueWasCleaned = false;
   
   // prevent our value from being written to disk
   let cleaningObserver = {
@@ -81,16 +82,20 @@ function test() {
     observe: function(aSubject, aTopic, aData) {
       ok(valueWasCleaned && aSubject instanceof Ci.nsISupportsString,
          "ready to check the cleaned state?");
       ok(aSubject.data.indexOf(uniqueValue) == -1, "data no longer contains our value?");
       
       // clean up
       tabbrowser.removeTab(tab);
       os.removeObserver(this, aTopic, false);
+      gPrefService.setIntPref("browser.sessionstore.interval", interval);
       finish();
     }
   };
   
   // last added observers are invoked first
   os.addObserver(checkingObserver, "sessionstore-state-write", false);
   os.addObserver(cleaningObserver, "sessionstore-state-write", false);
+  
+  // trigger an immediate save operation
+  gPrefService.setIntPref("browser.sessionstore.interval", 0);
 }
diff -r 4f1383af8f10 build/wince/shunt/include/errno.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/build/wince/shunt/include/errno.h	Mon Nov 03 05:09:07 2008 -0500
@@ -0,0 +1,38 @@
+#define EPERM           1       /* Operation not permitted */
+#define ENOENT          2       /* No such file or directory */
+#define ESRCH           3       /* No such process */
+#define EINTR           4       /* Interrupted system call */
+#define EIO             5       /* Input/output error */
+#define ENXIO           6       /* Device not configured */
+#define E2BIG           7       /* Argument list too long */
+#define ENOEXEC         8       /* Exec format error */
+#define EBADF           9       /* Bad file descriptor */
+#define ECHILD          10      /* No child processes */
+#define EDEADLK         11      /* Resource deadlock avoided */
+#define ENOMEM          12      /* Cannot allocate memory */
+#define EACCES          13      /* Permission denied */
+#define EFAULT          14      /* Bad address */
+#define ENOTBLK         15      /* Block device required */
+#define EBUSY           16      /* Device busy */
+#define EEXIST          17      /* File exists */
+#define EXDEV           18      /* Cross-device link */
+#define ENODEV          19      /* Operation not supported by device */
+#define ENOTDIR         20      /* Not a directory */
+#define EISDIR          21      /* Is a directory */
+#define EINVAL          22      /* Invalid argument */
+#define ENFILE          23      /* Too many open files in system */
+#define EMFILE          24      /* Too many open files */
+#define ENOTTY          25      /* Inappropriate ioctl for device */
+#define ETXTBSY         26      /* Text file busy */
+#define EFBIG           27      /* File too large */
+#define ENOSPC          28      /* No space left on device */
+#define ESPIPE          29      /* Illegal seek */
+#define EROFS           30      /* Read-only file system */
+#define EMLINK          31      /* Too many links */
+#define EPIPE           32      /* Broken pipe */
+#define EDOM            33      /* Numerical argument out of domain */
+#define ERANGE          34      /* Result too large */
+#define EAGAIN          35      /* Resource temporarily unavailable */
+#define ENOTEMPTY       39      /* Directory not empty */
+
+
diff -r 4f1383af8f10 build/wince/shunt/include/mozce_shunt.h
--- a/build/wince/shunt/include/mozce_shunt.h	Sat Nov 01 09:52:29 2008 +0100
+++ b/build/wince/shunt/include/mozce_shunt.h	Mon Nov 03 05:09:07 2008 -0500
@@ -49,16 +49,21 @@
 #define strcmpi _stricmp
 #define stricmp _stricmp
 #define wgetcwd _wgetcwd
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
+/* errno and family */
+extern MOZCE_SHUNT_API int errno;
+MOZCE_SHUNT_API char* strerror(int);
+
+/* abort */
 MOZCE_SHUNT_API void abort(void);
   
 /* Environment stuff */
 MOZCE_SHUNT_API char* getenv(const char* inName);
 MOZCE_SHUNT_API int putenv(const char *a);
 MOZCE_SHUNT_API char SetEnvironmentVariableW(const unsigned short * name, const unsigned short * value );
 MOZCE_SHUNT_API char GetEnvironmentVariableW(const unsigned short * lpName, unsigned short* lpBuffer, unsigned long nSize);
   
diff -r 4f1383af8f10 build/wince/shunt/map.cpp
--- a/build/wince/shunt/map.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/build/wince/shunt/map.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -187,16 +187,28 @@ MOZCE_SHUNT_API char SetEnvironmentVaria
                            256,
                            NULL,
                            NULL);
   if(rv < 0)
     return rv;
   
   return map_put(key,val);
 }
+
+////////////////////////////////////////////////////////
+//  errno
+////////////////////////////////////////////////////////
+
+MOZCE_SHUNT_API char* strerror(int inErrno)
+{
+  return "Unknown Error";
+}
+
+MOZCE_SHUNT_API int errno = 0;
+
 
 ////////////////////////////////////////////////////////
 //  File System Stuff
 ////////////////////////////////////////////////////////
 
 MOZCE_SHUNT_API unsigned short * _wgetcwd(unsigned short * dir, unsigned long size)
 {
   unsigned long i;
diff -r 4f1383af8f10 config/rules.mk
--- a/config/rules.mk	Sat Nov 01 09:52:29 2008 +0100
+++ b/config/rules.mk	Mon Nov 03 05:09:07 2008 -0500
@@ -378,16 +378,18 @@ LOOP_OVER_TOOL_DIRS = \
     @$(EXIT_ON_ERROR) \
     $(foreach dir,$(TOOL_DIRS),$(UPDATE_TITLE) $(MAKE) -C $(dir) $@; ) true
 
 ifdef PARALLEL_DIRS
 # create a bunch of fake targets for order-only processing
 PARALLEL_DIRS_export = $(addsuffix _export,$(PARALLEL_DIRS))
 PARALLEL_DIRS_libs = $(addsuffix _libs,$(PARALLEL_DIRS))
 PARALLEL_DIRS_tools = $(addsuffix _tools,$(PARALLEL_DIRS))
+
+.PHONY: $(PARALLEL_DIRS_export) $(PARALLEL_DIRS_libs) $(PARALLEL_DIRS_tools)
 endif
 
 #
 # Now we can differentiate between objects used to build a library, and
 # objects used to build an executable in the same directory.
 #
 ifndef PROGOBJS
 PROGOBJS		= $(OBJS)
@@ -588,19 +590,17 @@ HOST_OUTOPTION = -o # eol
 HOST_OUTOPTION = -o # eol
 endif
 
 endif
 ################################################################################
 
 # SUBMAKEFILES: List of Makefiles for next level down.
 #   This is used to update or create the Makefiles before invoking them.
-SUBMAKEFILES += $(addsuffix /Makefile, $(DIRS) $(TOOL_DIRS))
-PARALLEL_SUBMAKEFILES += $(addsuffix /Makefile, $(PARALLEL_DIRS))
-SUBMAKEFILES += $(PARALLEL_SUBMAKEFILES)
+SUBMAKEFILES += $(addsuffix /Makefile, $(DIRS) $(TOOL_DIRS) $(PARALLEL_DIRS))
 
 # The root makefile doesn't want to do a plain export/libs, because
 # of the tiers and because of libxul. Suppress the default rules in favor
 # of something else. Makefiles which use this var *must* provide a sensible
 # default rule before including rules.mk
 ifndef SUPPRESS_DEFAULT_RULES
 ifdef TIERS
 
@@ -693,31 +693,31 @@ makefiles: $(SUBMAKEFILES)
 makefiles: $(SUBMAKEFILES)
 ifneq (,$(DIRS)$(TOOL_DIRS)$(PARALLEL_DIRS))
 	+$(LOOP_OVER_PARALLEL_DIRS)
 	+$(LOOP_OVER_DIRS)
 	+$(LOOP_OVER_TOOL_DIRS)
 endif
 
 ifdef PARALLEL_DIRS
-export:: $(PARALLEL_SUBMAKEFILES) | $(PARALLEL_DIRS_export)
+export:: $(PARALLEL_DIRS_export)
 
-$(PARALLEL_DIRS_export):: %_export: %
-	+$(MAKE) -C $< export
+$(PARALLEL_DIRS_export): %_export: %/Makefile
+	+$(MAKE) -C $* export
 endif
 
 export:: $(SUBMAKEFILES) $(MAKE_DIRS) $(if $(EXPORTS)$(XPIDLSRCS)$(SDK_HEADERS)$(SDK_XPIDLSRCS),$(PUBLIC)) $(if $(SDK_HEADERS)$(SDK_XPIDLSRCS),$(SDK_PUBLIC)) $(if $(XPIDLSRCS),$(IDL_DIR)) $(if $(SDK_XPIDLSRCS),$(SDK_IDL_DIR))
 	+$(LOOP_OVER_DIRS)
 	+$(LOOP_OVER_TOOL_DIRS)
 
 ifdef PARALLEL_DIRS
-tools:: $(PARALLEL_SUBMAKEFILES) | $(PARALLEL_DIRS_tools)
+tools:: $(PARALLEL_DIRS_tools)
 
-$(PARALLEL_DIRS_tools):: %_tools: %
-	+$(MAKE) -C $< tools
+$(PARALLEL_DIRS_tools): %_tools: %/Makefile
+	+$(MAKE) -C $* tools
 endif
 
 tools:: $(SUBMAKEFILES) $(MAKE_DIRS)
 	+$(LOOP_OVER_DIRS)
 ifdef TOOL_DIRS
 	@$(EXIT_ON_ERROR) \
 	$(foreach dir,$(TOOL_DIRS),$(UPDATE_TITLE) $(MAKE) -C $(dir) libs; ) true
 endif
@@ -743,20 +743,20 @@ endif # LIBRARY_NAME
 
 # Create dependencies on static (and shared EXTRA_DSO_LIBS) libraries
 LIBS_DEPS = $(filter %.$(LIB_SUFFIX), $(LIBS))
 HOST_LIBS_DEPS = $(filter %.$(LIB_SUFFIX), $(HOST_LIBS))
 DSO_LDOPTS_DEPS = $(EXTRA_DSO_LIBS) $(filter %.$(LIB_SUFFIX), $(EXTRA_DSO_LDOPTS))
 
 ##############################################
 ifdef PARALLEL_DIRS
-libs:: $(PARALLEL_SUBMAKEFILES) | $(PARALLEL_DIRS_libs)
+libs:: $(PARALLEL_DIRS_libs)
 
-$(PARALLEL_DIRS_libs):: %_libs: %
-	+$(MAKE) -C $< libs
+$(PARALLEL_DIRS_libs): %_libs: %/Makefile
+	+$(MAKE) -C $* libs
 endif
 
 libs:: $(SUBMAKEFILES) $(MAKE_DIRS) $(HOST_LIBRARY) $(LIBRARY) $(SHARED_LIBRARY) $(IMPORT_LIBRARY) $(HOST_PROGRAM) $(PROGRAM) $(HOST_SIMPLE_PROGRAMS) $(SIMPLE_PROGRAMS) $(JAVA_LIBRARY)
 ifndef NO_DIST_INSTALL
 ifdef LIBRARY
 ifdef EXPORT_LIBRARY # Stage libs that will be linked into a static build
 ifdef IS_COMPONENT
 	$(INSTALL) $(IFLAGS1) $(LIBRARY) $(DEPTH)/staticlib/components
diff -r 4f1383af8f10 content/base/public/nsINode.h
--- a/content/base/public/nsINode.h	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/base/public/nsINode.h	Mon Nov 03 05:09:07 2008 -0500
@@ -742,11 +742,112 @@ protected:
    * Used for either storing flags for this node or a pointer to
    * this contents nsContentSlots. See the definition of the
    * NODE_* macros for the layout of the bits in this
    * member.
    */
   PtrBits mFlagsOrSlots;
 };
 
+
+extern const nsIID kThisPtrOffsetsSID;
+
+// _implClass is the class to use to cast to nsISupports
+#define NS_OFFSET_AND_INTERFACE_TABLE_BEGIN_AMBIGUOUS(_class, _implClass)     \
+  static const QITableEntry offsetAndQITable[] = {                            \
+    NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsISupports, _implClass)
+
+#define NS_OFFSET_AND_INTERFACE_TABLE_BEGIN(_class)                           \
+  NS_OFFSET_AND_INTERFACE_TABLE_BEGIN_AMBIGUOUS(_class, _class)
+
+#define NS_OFFSET_AND_INTERFACE_TABLE_END                                     \
+  { nsnull, 0 } };                                                            \
+  if (aIID.Equals(kThisPtrOffsetsSID)) {                                      \
+    *aInstancePtr =                                                           \
+      const_cast<void*>(static_cast<const void*>(&offsetAndQITable));         \
+    return NS_OK;                                                             \
+  }
+
+#define NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE                            \
+  rv = NS_TableDrivenQI(this, offsetAndQITable, aIID, aInstancePtr);          \
+  NS_INTERFACE_TABLE_TO_MAP_SEGUE
+
+// nsNodeSH::PreCreate() depends on the identity pointer being the same as
+// nsINode, so if you change the nsISupports line  below, make sure
+// nsNodeSH::PreCreate() still does the right thing!
+#define NS_NODE_OFFSET_AND_INTERFACE_TABLE_BEGIN(_class)                      \
+  NS_OFFSET_AND_INTERFACE_TABLE_BEGIN_AMBIGUOUS(_class, nsINode)
+
+#define NS_NODE_INTERFACE_TABLE2(_class, _i1, _i2)                            \
+  NS_NODE_OFFSET_AND_INTERFACE_TABLE_BEGIN(_class)                            \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i1)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i2)                                     \
+  NS_OFFSET_AND_INTERFACE_TABLE_END                                           \
+  NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
+
+#define NS_NODE_INTERFACE_TABLE3(_class, _i1, _i2, _i3)                       \
+  NS_NODE_OFFSET_AND_INTERFACE_TABLE_BEGIN(_class)                            \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i1)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i2)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i3)                                     \
+  NS_OFFSET_AND_INTERFACE_TABLE_END                                           \
+  NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
+
+#define NS_NODE_INTERFACE_TABLE4(_class, _i1, _i2, _i3, _i4)                  \
+  NS_NODE_OFFSET_AND_INTERFACE_TABLE_BEGIN(_class)                            \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i1)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i2)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i3)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i4)                                     \
+  NS_OFFSET_AND_INTERFACE_TABLE_END                                           \
+  NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
+
+#define NS_NODE_INTERFACE_TABLE5(_class, _i1, _i2, _i3, _i4, _i5)             \
+  NS_NODE_OFFSET_AND_INTERFACE_TABLE_BEGIN(_class)                            \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i1)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i2)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i3)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i4)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i5)                                     \
+  NS_OFFSET_AND_INTERFACE_TABLE_END                                           \
+  NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
+
+#define NS_NODE_INTERFACE_TABLE6(_class, _i1, _i2, _i3, _i4, _i5, _i6)        \
+  NS_NODE_OFFSET_AND_INTERFACE_TABLE_BEGIN(_class)                            \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i1)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i2)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i3)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i4)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i5)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i6)                                     \
+  NS_OFFSET_AND_INTERFACE_TABLE_END                                           \
+  NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
+
+#define NS_NODE_INTERFACE_TABLE7(_class, _i1, _i2, _i3, _i4, _i5, _i6, _i7)   \
+  NS_NODE_OFFSET_AND_INTERFACE_TABLE_BEGIN(_class)                            \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i1)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i2)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i3)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i4)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i5)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i6)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i7)                                     \
+  NS_OFFSET_AND_INTERFACE_TABLE_END                                           \
+  NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
+
+#define NS_NODE_INTERFACE_TABLE8(_class, _i1, _i2, _i3, _i4, _i5, _i6, _i7,   \
+                                 _i8)                                         \
+  NS_NODE_OFFSET_AND_INTERFACE_TABLE_BEGIN(_class)                            \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i1)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i2)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i3)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i4)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i5)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i6)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i7)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i8)                                     \
+  NS_OFFSET_AND_INTERFACE_TABLE_END                                           \
+  NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
+
+
 NS_DEFINE_STATIC_IID_ACCESSOR(nsINode, NS_INODE_IID)
 
 #endif /* nsINode_h___ */
diff -r 4f1383af8f10 content/base/public/nsINodeList.h
--- a/content/base/public/nsINodeList.h	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/base/public/nsINodeList.h	Mon Nov 03 05:09:07 2008 -0500
@@ -55,11 +55,14 @@ public:
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_INODELIST_IID)
 
   /**
    * Get the node at the index.  Returns null if the index is out of bounds
    */
   virtual nsINode* GetNodeAt(PRUint32 aIndex) = 0;
 };
 
+#define NS_NODELIST_OFFSET_AND_INTERFACE_TABLE_BEGIN(_class)                  \
+  NS_OFFSET_AND_INTERFACE_TABLE_BEGIN_AMBIGUOUS(_class, nsINodeList)
+
 NS_DEFINE_STATIC_IID_ACCESSOR(nsINodeList, NS_INODELIST_IID)
 
 #endif /* nsINodeList_h___ */
diff -r 4f1383af8f10 content/base/src/nsCommentNode.cpp
--- a/content/base/src/nsCommentNode.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/base/src/nsCommentNode.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -104,20 +104,19 @@ nsCommentNode::nsCommentNode(nsINodeInfo
 }
 
 nsCommentNode::~nsCommentNode()
 {
 }
 
 
 // QueryInterface implementation for nsCommentNode
-NS_INTERFACE_MAP_BEGIN(nsCommentNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMCharacterData)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMComment)
+NS_INTERFACE_TABLE_HEAD(nsCommentNode)
+  NS_NODE_INTERFACE_TABLE3(nsCommentNode, nsIDOMNode, nsIDOMCharacterData,
+                           nsIDOMComment)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(Comment)
 NS_INTERFACE_MAP_END_INHERITING(nsGenericDOMDataNode)
 
 
 NS_IMPL_ADDREF_INHERITED(nsCommentNode, nsGenericDOMDataNode)
 NS_IMPL_RELEASE_INHERITED(nsCommentNode, nsGenericDOMDataNode)
 
 
diff -r 4f1383af8f10 content/base/src/nsContentList.cpp
--- a/content/base/src/nsContentList.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/base/src/nsContentList.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -77,21 +77,28 @@ NS_IMPL_CYCLE_COLLECTION_CLASS(nsBaseCon
 NS_IMPL_CYCLE_COLLECTION_CLASS(nsBaseContentList)
 NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsBaseContentList)
   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMARRAY(mElements)
 NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsBaseContentList)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mElements)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
+#define NS_CONTENT_LIST_INTERFACES(_class)                                    \
+    NS_INTERFACE_TABLE_ENTRY(_class, nsINodeList)                             \
+    NS_INTERFACE_TABLE_ENTRY(_class, nsIDOMNodeList)
+
+
 // QueryInterface implementation for nsBaseContentList
-NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsBaseContentList)
-  NS_INTERFACE_MAP_ENTRY(nsINodeList)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNodeList)
-  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsINodeList)
+NS_INTERFACE_TABLE_HEAD(nsBaseContentList)
+  NS_NODELIST_OFFSET_AND_INTERFACE_TABLE_BEGIN(nsBaseContentList)
+    NS_CONTENT_LIST_INTERFACES(nsBaseContentList)
+  NS_OFFSET_AND_INTERFACE_TABLE_END
+  NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
+  NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION(nsBaseContentList)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(NodeList)
 NS_INTERFACE_MAP_END
 
 
 NS_IMPL_CYCLE_COLLECTING_ADDREF(nsBaseContentList)
 NS_IMPL_CYCLE_COLLECTING_RELEASE(nsBaseContentList)
 
 
@@ -345,20 +352,24 @@ nsContentList::~nsContentList()
   if (mDestroyFunc) {
     // Clean up mData
     (*mDestroyFunc)(mData);
   }
 }
 
 
 // QueryInterface implementation for nsContentList
-NS_INTERFACE_MAP_BEGIN(nsContentList)
-  NS_INTERFACE_MAP_ENTRY(nsIHTMLCollection)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMHTMLCollection)
-  NS_INTERFACE_MAP_ENTRY(nsIMutationObserver)
+NS_INTERFACE_TABLE_HEAD(nsContentList)
+  NS_NODELIST_OFFSET_AND_INTERFACE_TABLE_BEGIN(nsContentList)
+    NS_CONTENT_LIST_INTERFACES(nsContentList)
+    NS_INTERFACE_TABLE_ENTRY(nsContentList, nsIHTMLCollection)
+    NS_INTERFACE_TABLE_ENTRY(nsContentList, nsIDOMHTMLCollection)
+    NS_INTERFACE_TABLE_ENTRY(nsContentList, nsIMutationObserver)
+  NS_OFFSET_AND_INTERFACE_TABLE_END
+  NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(ContentList)
 NS_INTERFACE_MAP_END_INHERITING(nsBaseContentList)
 
 
 NS_IMPL_ADDREF_INHERITED(nsContentList, nsBaseContentList)
 NS_IMPL_RELEASE_INHERITED(nsContentList, nsBaseContentList)
 
 
diff -r 4f1383af8f10 content/base/src/nsContentUtils.cpp
--- a/content/base/src/nsContentUtils.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/base/src/nsContentUtils.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -1667,22 +1667,24 @@ nsContentUtils::ComparePoints(nsINode* a
   } while (node1);
   do {
     parents2.AppendElement(node2);
     node2 = node2->GetNodeParent();
   } while (node2);
 
   PRUint32 pos1 = parents1.Length() - 1;
   PRUint32 pos2 = parents2.Length() - 1;
-
-  NS_ASSERTION(parents1.ElementAt(pos1) == parents2.ElementAt(pos2) ||
-               aDisconnected,
-               "disconnected nodes");
+  
+  PRBool disconnected = parents1.ElementAt(pos1) != parents2.ElementAt(pos2);
   if (aDisconnected) {
-    *aDisconnected = (parents1.ElementAt(pos1) != parents2.ElementAt(pos2));
+    *aDisconnected = disconnected;
+  }
+  if (disconnected) {
+    NS_ASSERTION(aDisconnected, "unexpected disconnected nodes");
+    return 1;
   }
 
   // Find where the parent chains differ
   nsINode* parent = parents1.ElementAt(pos1);
   PRUint32 len;
   for (len = PR_MIN(pos1, pos2); len > 0; --len) {
     nsINode* child1 = parents1.ElementAt(--pos1);
     nsINode* child2 = parents2.ElementAt(--pos2);
diff -r 4f1383af8f10 content/base/src/nsDOMAttribute.cpp
--- a/content/base/src/nsDOMAttribute.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/base/src/nsDOMAttribute.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -95,31 +95,23 @@ NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(ns
     static_cast<nsTextNode*>(tmp->mChild)->UnbindFromAttribute();
     NS_RELEASE(tmp->mChild);
   }
   NS_IMPL_CYCLE_COLLECTION_UNLINK_LISTENERMANAGER
   NS_IMPL_CYCLE_COLLECTION_UNLINK_USERDATA
   NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
 NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 // QueryInterface implementation for nsDOMAttribute
-NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsDOMAttribute)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMAttr)
-  NS_INTERFACE_MAP_ENTRY(nsIAttribute)
-  NS_INTERFACE_MAP_ENTRY(nsINode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOM3Node)
-  NS_INTERFACE_MAP_ENTRY(nsIDOM3Attr)
-  NS_INTERFACE_MAP_ENTRY(nsPIDOMEventTarget)
+NS_INTERFACE_TABLE_HEAD(nsDOMAttribute)
+  NS_NODE_INTERFACE_TABLE7(nsDOMAttribute, nsIDOMAttr, nsIAttribute, nsINode,
+                           nsIDOMNode, nsIDOM3Node, nsIDOM3Attr,
+                           nsPIDOMEventTarget)
+  NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION(nsDOMAttribute)
   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsISupportsWeakReference,
                                  new nsNodeSupportsWeakRefTearoff(this))
-  // nsNodeSH::PreCreate() depends on the identity pointer being the
-  // same as nsINode (which nsIAttribute inherits), so if you change
-  // the below line, make sure nsNodeSH::PreCreate() still does the
-  // right thing!
-  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIAttribute)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(Attr)
 NS_INTERFACE_MAP_END
 
 NS_IMPL_CYCLE_COLLECTING_ADDREF_AMBIGUOUS(nsDOMAttribute, nsIDOMAttr)
 NS_IMPL_CYCLE_COLLECTING_RELEASE_FULL(nsDOMAttribute, nsIDOMAttr,
                                       nsNodeUtils::LastRelease(this))
 
 void
diff -r 4f1383af8f10 content/base/src/nsDOMAttributeMap.cpp
--- a/content/base/src/nsDOMAttributeMap.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/base/src/nsDOMAttributeMap.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -111,19 +111,22 @@ TraverseMapEntry(nsAttrHashKey::KeyType 
 }
 
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsDOMAttributeMap)
   tmp->mAttributeCache.Enumerate(TraverseMapEntry, &cb);
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 
 // QueryInterface implementation for nsDOMAttributeMap
-NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsDOMAttributeMap)
-  NS_INTERFACE_MAP_ENTRY(nsISupports)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNamedNodeMap)
+NS_INTERFACE_TABLE_HEAD(nsDOMAttributeMap)
+  NS_OFFSET_AND_INTERFACE_TABLE_BEGIN(nsDOMAttributeMap)
+    NS_INTERFACE_TABLE_ENTRY(nsDOMAttributeMap, nsIDOMNamedNodeMap)
+  NS_OFFSET_AND_INTERFACE_TABLE_END
+  NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
+  NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION(nsDOMAttributeMap)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(NamedNodeMap)
 NS_INTERFACE_MAP_END
 
 NS_IMPL_CYCLE_COLLECTING_ADDREF(nsDOMAttributeMap)
 NS_IMPL_CYCLE_COLLECTING_RELEASE(nsDOMAttributeMap)
 
 PLDHashOperator
 SetOwnerDocumentFunc(nsAttrHashKey::KeyType aKey, nsCOMPtr<nsIDOMNode>& aData,
diff -r 4f1383af8f10 content/base/src/nsDOMDocumentType.cpp
--- a/content/base/src/nsDOMDocumentType.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/base/src/nsDOMDocumentType.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -118,19 +118,19 @@ nsDOMDocumentType::nsDOMDocumentType(nsI
 }
 
 nsDOMDocumentType::~nsDOMDocumentType()
 {
 }
 
 
 // QueryInterface implementation for nsDOMDocumentType
-NS_INTERFACE_MAP_BEGIN(nsDOMDocumentType)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMDocumentType)
+NS_INTERFACE_TABLE_HEAD(nsDOMDocumentType)
+  NS_NODE_INTERFACE_TABLE2(nsDOMDocumentType, nsIDOMNode, nsIDOMDocumentType)
+  NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION(nsDOMDocumentType)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(DocumentType)
 NS_INTERFACE_MAP_END_INHERITING(nsGenericDOMDataNode)
 
 
 NS_IMPL_ADDREF_INHERITED(nsDOMDocumentType, nsGenericDOMDataNode)
 NS_IMPL_RELEASE_INHERITED(nsDOMDocumentType, nsGenericDOMDataNode)
 
 PRBool
diff -r 4f1383af8f10 content/base/src/nsDOMLists.cpp
--- a/content/base/src/nsDOMLists.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/base/src/nsDOMLists.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -41,30 +41,33 @@
  * Implementations of nsIDOMDOMStringList and nsIDOMNameList, used by various
  * DOM3 stuff and some interfaces specified by WHATWG.
  */
 
 #include "nsDOMLists.h"
 #include "nsDOMError.h"
 #include "nsIDOMClassInfo.h"
 #include "nsContentUtils.h"
+#include "nsINode.h"
 
 nsDOMStringList::nsDOMStringList()
 {
 }
 
 nsDOMStringList::~nsDOMStringList()
 {
 }
 
 NS_IMPL_ADDREF(nsDOMStringList)
 NS_IMPL_RELEASE(nsDOMStringList)
-NS_INTERFACE_MAP_BEGIN(nsDOMStringList)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMDOMStringList)
-  NS_INTERFACE_MAP_ENTRY(nsISupports)
+NS_INTERFACE_TABLE_HEAD(nsDOMStringList)
+  NS_OFFSET_AND_INTERFACE_TABLE_BEGIN(nsDOMStringList)
+    NS_INTERFACE_TABLE_ENTRY(nsDOMStringList, nsIDOMDOMStringList)
+  NS_OFFSET_AND_INTERFACE_TABLE_END
+  NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(DOMStringList)
 NS_INTERFACE_MAP_END
 
 NS_IMETHODIMP
 nsDOMStringList::Item(PRUint32 aIndex, nsAString& aResult)
 {
   if (aIndex >= (PRUint32)mNames.Count()) {
     SetDOMStringToNull(aResult);
@@ -96,20 +99,22 @@ nsNameList::nsNameList()
 {
 }
 
 nsNameList::~nsNameList()
 {
 }
 
 NS_IMPL_ADDREF(nsNameList)
-  NS_IMPL_RELEASE(nsNameList)
-  NS_INTERFACE_MAP_BEGIN(nsNameList)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNameList)
-  NS_INTERFACE_MAP_ENTRY(nsISupports)
+NS_IMPL_RELEASE(nsNameList)
+NS_INTERFACE_TABLE_HEAD(nsNameList)
+  NS_OFFSET_AND_INTERFACE_TABLE_BEGIN(nsNameList)
+    NS_INTERFACE_TABLE_ENTRY(nsNameList, nsIDOMNameList)
+  NS_OFFSET_AND_INTERFACE_TABLE_END
+  NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(NameList)
   NS_INTERFACE_MAP_END
 
 NS_IMETHODIMP
 nsNameList::GetName(PRUint32 aIndex, nsAString& aResult)
 {
   if (aIndex >= (PRUint32)mNames.Count()) {
     SetDOMStringToNull(aResult);
diff -r 4f1383af8f10 content/base/src/nsDocument.cpp
--- a/content/base/src/nsDocument.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/base/src/nsDocument.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -1195,19 +1195,21 @@ protected:
   nsresult GetSets(nsStringArray& aStyleSets);
   
   nsIDocument* mDocument;  // Our document; weak ref.  It'll let us know if it
                            // dies.
 };
 
 NS_IMPL_ADDREF(nsDOMStyleSheetSetList)
 NS_IMPL_RELEASE(nsDOMStyleSheetSetList)
-NS_INTERFACE_MAP_BEGIN(nsDOMStyleSheetSetList)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMDOMStringList)
-  NS_INTERFACE_MAP_ENTRY(nsISupports)
+NS_INTERFACE_TABLE_HEAD(nsDOMStyleSheetSetList)
+  NS_OFFSET_AND_INTERFACE_TABLE_BEGIN(nsDOMStyleSheetSetList)
+    NS_INTERFACE_TABLE_ENTRY(nsDOMStyleSheetSetList, nsIDOMDOMStringList)
+  NS_OFFSET_AND_INTERFACE_TABLE_END
+  NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(DOMStringList)
 NS_INTERFACE_MAP_END
 
 nsDOMStyleSheetSetList::nsDOMStyleSheetSetList(nsIDocument* aDocument)
   : mDocument(aDocument)
 {
   NS_ASSERTION(mDocument, "Must have document!");
 }
@@ -1567,49 +1569,36 @@ nsDocument::~nsDocument()
   }
 
   delete mContentWrapperHash;
 }
 
 NS_IMPL_CYCLE_COLLECTION_CLASS(nsDocument)
 
 NS_INTERFACE_TABLE_HEAD(nsDocument)
-  NS_INTERFACE_TABLE_BEGIN
+  NS_DOCUMENT_INTERFACE_TABLE_BEGIN(nsDocument)
     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsINode)
     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDocument)
-    NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDOMDocument)
-    NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDOMNSDocument)
-    NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDOMDocumentEvent)
     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDOM3DocumentEvent)
     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDOMDocumentStyle)
     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDOMNSDocumentStyle)
-    NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDOMDocumentView)
     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDOMDocumentRange)
-    NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDOMDocumentTraversal)
     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDOMDocumentXBL)
     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIScriptObjectPrincipal)
-    NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDOMEventTarget)
     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDOM3EventTarget)
     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDOMNSEventTarget)
-    NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDOMNode)
     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsPIDOMEventTarget)
-    NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDOM3Node)
-    NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDOM3Document)
     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsISupportsWeakReference)
     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIRadioGroupContainer)
     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIMutationObserver)
     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDOMNodeSelector)
     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIApplicationCacheContainer)
-    // nsNodeSH::PreCreate() depends on the identity pointer being the
-    // same as nsINode (which nsIDocument inherits), so if you change
-    // the below line, make sure nsNodeSH::PreCreate() still does the
-    // right thing!
-    NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(nsDocument, nsISupports, nsIDocument)
-  NS_INTERFACE_TABLE_END
-  NS_INTERFACE_TABLE_TO_MAP_SEGUE_CYCLE_COLLECTION(nsDocument)
+  NS_OFFSET_AND_INTERFACE_TABLE_END
+  NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
+  NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION(nsDocument)
   if (aIID.Equals(NS_GET_IID(nsIDOMXPathEvaluator)) ||
       aIID.Equals(NS_GET_IID(nsIXPathEvaluatorInternal))) {
     if (!mXPathEvaluatorTearoff) {
       nsresult rv;
       mXPathEvaluatorTearoff =
         do_CreateInstance(NS_XPATH_EVALUATOR_CONTRACTID,
                           static_cast<nsIDocument *>(this), &rv);
       NS_ENSURE_SUCCESS(rv, rv);
diff -r 4f1383af8f10 content/base/src/nsDocument.h
--- a/content/base/src/nsDocument.h	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/base/src/nsDocument.h	Mon Nov 03 05:09:07 2008 -0500
@@ -1222,9 +1222,22 @@ private:
   nsTArray<nsRefPtr<nsFrameLoader> > mInitializableFrameLoaders;
   nsTArray<nsRefPtr<nsFrameLoader> > mFinalizableFrameLoaders;
 
   nsRevocableEventPtr<nsRunnableMethod<nsDocument> > mPendingTitleChangeEvent;
 
   nsExternalResourceMap mExternalResourceMap;
 };
 
+#define NS_DOCUMENT_INTERFACE_TABLE_BEGIN(_class)                             \
+  NS_NODE_OFFSET_AND_INTERFACE_TABLE_BEGIN(_class)                            \
+  NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOMDocument, nsDocument)      \
+  NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOMNSDocument, nsDocument)    \
+  NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOMDocumentEvent, nsDocument) \
+  NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOMDocumentView, nsDocument)  \
+  NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOMDocumentTraversal,         \
+                                     nsDocument)                              \
+  NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOMEventTarget, nsDocument)   \
+  NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOMNode, nsDocument)          \
+  NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOM3Node, nsDocument)         \
+  NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOM3Document, nsDocument)
+
 #endif /* nsDocument_h___ */
diff -r 4f1383af8f10 content/base/src/nsDocumentFragment.cpp
--- a/content/base/src/nsDocumentFragment.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/base/src/nsDocumentFragment.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -190,20 +190,19 @@ nsDocumentFragment::~nsDocumentFragment(
 
 PRBool
 nsDocumentFragment::IsNodeOfType(PRUint32 aFlags) const
 {
   return !(aFlags & ~(eCONTENT | eDOCUMENT_FRAGMENT));
 }
 
 // QueryInterface implementation for nsDocumentFragment
-NS_INTERFACE_MAP_BEGIN(nsDocumentFragment)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMDocumentFragment)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOM3Node, new nsNode3Tearoff(this))
+NS_INTERFACE_TABLE_HEAD(nsDocumentFragment)
+  NS_NODE_INTERFACE_TABLE2(nsDocumentFragment, nsIDOMNode,
+                           nsIDOMDocumentFragment)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(DocumentFragment)
 NS_INTERFACE_MAP_END_INHERITING(nsGenericElement)
 
 
 NS_IMPL_ADDREF_INHERITED(nsDocumentFragment, nsGenericElement)
 NS_IMPL_RELEASE_INHERITED(nsDocumentFragment, nsGenericElement)
 
 NS_IMETHODIMP    
diff -r 4f1383af8f10 content/base/src/nsGenericElement.cpp
--- a/content/base/src/nsGenericElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/base/src/nsGenericElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -164,16 +164,18 @@ DebugListContentTree(nsIContent* aElemen
 DebugListContentTree(nsIContent* aElement)
 {
   aElement->List(stdout, 0);
   printf("\n");
 }
 
 #endif
 
+NS_DEFINE_IID(kThisPtrOffsetsSID, NS_THISPTROFFSETS_SID);
+
 PRInt32 nsIContent::sTabFocusModel = eTabFocus_any;
 PRBool nsIContent::sTabFocusModelAppliesToXUL = PR_FALSE;
 nsresult NS_NewContentIterator(nsIContentIterator** aInstancePtrResult);
 
 //----------------------------------------------------------------------
 
 nsINode::nsSlots::~nsSlots()
 {
@@ -454,20 +456,22 @@ nsIContent::FindFirstNonNativeAnonymous(
   return nsnull;
 }
 
 //----------------------------------------------------------------------
 
 NS_IMPL_ADDREF(nsChildContentList)
 NS_IMPL_RELEASE(nsChildContentList)
 
-NS_INTERFACE_MAP_BEGIN(nsChildContentList)
-  NS_INTERFACE_MAP_ENTRY(nsINodeList)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNodeList)
-  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsINodeList)
+NS_INTERFACE_TABLE_HEAD(nsChildContentList)
+  NS_NODELIST_OFFSET_AND_INTERFACE_TABLE_BEGIN(nsChildContentList)
+    NS_INTERFACE_TABLE_ENTRY(nsChildContentList, nsINodeList)
+    NS_INTERFACE_TABLE_ENTRY(nsChildContentList, nsIDOMNodeList)
+  NS_OFFSET_AND_INTERFACE_TABLE_END
+  NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(NodeList)
 NS_INTERFACE_MAP_END
 
 NS_IMETHODIMP
 nsChildContentList::GetLength(PRUint32* aLength)
 {
   *aLength = mNode ? mNode->GetChildCount() : 0;
 
diff -r 4f1383af8f10 content/base/src/nsGenericElement.h
--- a/content/base/src/nsGenericElement.h	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/base/src/nsGenericElement.h	Mon Nov 03 05:09:07 2008 -0500
@@ -1076,9 +1076,28 @@ private:
    * @note This method flushes pending notifications (Flush_Layout).
    * @param aScrollableView the scrollable view [OUT]
    * @param aFrame (optional) the frame [OUT]
    */
   void GetScrollInfo(nsIScrollableView **aScrollableView,
                      nsIFrame **aFrame = nsnull);
 };
 
+#define NS_ELEMENT_INTERFACE_TABLE_TO_MAP_SEGUE                               \
+    rv = nsGenericElement::QueryInterface(aIID, aInstancePtr);                \
+    if (NS_SUCCEEDED(rv))                                                     \
+      return rv;                                                              \
+                                                                              \
+    NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
+
+#define NS_ELEMENT_INTERFACE_MAP_END                                          \
+    {                                                                         \
+      return PostQueryInterface(aIID, aInstancePtr);                          \
+    }                                                                         \
+                                                                              \
+    NS_ADDREF(foundInterface);                                                \
+                                                                              \
+    *aInstancePtr = foundInterface;                                           \
+                                                                              \
+    return NS_OK;                                                             \
+  }
+
 #endif /* nsGenericElement_h___ */
diff -r 4f1383af8f10 content/base/src/nsTextNode.cpp
--- a/content/base/src/nsTextNode.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/base/src/nsTextNode.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -148,21 +148,21 @@ nsTextNode::~nsTextNode()
 {
 }
 
 NS_IMPL_ADDREF_INHERITED(nsTextNode, nsGenericDOMDataNode)
 NS_IMPL_RELEASE_INHERITED(nsTextNode, nsGenericDOMDataNode)
 
 
 // QueryInterface implementation for nsTextNode
-NS_INTERFACE_MAP_BEGIN(nsTextNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMText)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMCharacterData)
+NS_INTERFACE_TABLE_HEAD(nsTextNode)
+  NS_NODE_INTERFACE_TABLE3(nsTextNode, nsIDOMNode, nsIDOMText,
+                           nsIDOMCharacterData)
   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOM3Text, new nsText3Tearoff(this))
+  NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION(nsTextNode)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(Text)
 NS_INTERFACE_MAP_END_INHERITING(nsGenericDOMDataNode)
 
 NS_IMETHODIMP
 nsTextNode::GetNodeName(nsAString& aNodeName)
 {
   aNodeName.AssignLiteral("#text");
   return NS_OK;
diff -r 4f1383af8f10 content/events/src/nsEventStateManager.cpp
--- a/content/events/src/nsEventStateManager.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/events/src/nsEventStateManager.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -151,19 +151,17 @@
 #ifdef MOZ_XUL
 #include "nsTreeBodyFrame.h"
 #endif
 
 #ifdef XP_MACOSX
 #include <Events.h>
 #endif
 
-#if defined(DEBUG_rods) || defined(DEBUG_bryner)
 //#define DEBUG_DOCSHELL_FOCUS
-#endif
 
 #define NS_USER_INTERACTION_INTERVAL 5000 // ms
 
 static NS_DEFINE_CID(kFrameTraversalCID, NS_FRAMETRAVERSAL_CID);
 
 
 //we will use key binding by default now. this wil lbreak viewer for now
 #define NON_KEYBINDING 0
@@ -187,16 +185,84 @@ static PRBool sKeyCausesActivation = PR_
 static PRBool sKeyCausesActivation = PR_TRUE;
 static PRUint32 sESMInstanceCount = 0;
 static PRInt32 sChromeAccessModifier = 0, sContentAccessModifier = 0;
 PRInt32 nsEventStateManager::sUserInputEventDepth = 0;
 
 static PRUint32 gMouseOrKeyboardEventCounter = 0;
 static nsITimer* gUserInteractionTimer = nsnull;
 static nsITimerCallback* gUserInteractionTimerCallback = nsnull;
+
+#ifdef DEBUG_DOCSHELL_FOCUS
+static void
+PrintDocTree(nsIDocShellTreeItem* aParentItem, int aLevel)
+{
+  for (PRInt32 i=0;i<aLevel;i++) printf("  ");
+
+  PRInt32 childWebshellCount;
+  aParentItem->GetChildCount(&childWebshellCount);
+  nsCOMPtr<nsIDocShell> parentAsDocShell(do_QueryInterface(aParentItem));
+  PRInt32 type;
+  aParentItem->GetItemType(&type);
+  nsCOMPtr<nsIPresShell> presShell;
+  parentAsDocShell->GetPresShell(getter_AddRefs(presShell));
+  nsCOMPtr<nsPresContext> presContext;
+  parentAsDocShell->GetPresContext(getter_AddRefs(presContext));
+  nsCOMPtr<nsIContentViewer> cv;
+  parentAsDocShell->GetContentViewer(getter_AddRefs(cv));
+  nsCOMPtr<nsIDOMDocument> domDoc;
+  if (cv)
+    cv->GetDOMDocument(getter_AddRefs(domDoc));
+  nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
+  nsCOMPtr<nsIDOMWindowInternal> domwin = doc ? doc->GetWindow() : nsnull;
+  nsIURI* uri = doc ? doc->GetDocumentURI() : nsnull;
+
+  nsCOMPtr<nsIWidget> widget;
+  nsIViewManager* vm = presShell ? presShell->GetViewManager() : nsnull;
+  if (vm) {
+    vm->GetWidget(getter_AddRefs(widget));
+  }
+
+  printf("DS %p  Type %s  Cnt %d  Doc %p  DW %p  EM %p%c",
+    static_cast<void*>(parentAsDocShell.get()),
+    type==nsIDocShellTreeItem::typeChrome?"Chrome":"Content",
+    childWebshellCount, static_cast<void*>(doc.get()),
+    static_cast<void*>(domwin.get()),
+    static_cast<void*>(presContext ? presContext->EventStateManager() : nsnull),
+    uri ? ' ' : '\n');
+  if (uri) {
+    nsCAutoString spec;
+    uri->GetSpec(spec);
+    printf("\"%s\"\n", spec.get());
+  }
+
+  if (childWebshellCount > 0) {
+    for (PRInt32 i = 0; i < childWebshellCount; i++) {
+      nsCOMPtr<nsIDocShellTreeItem> child;
+      aParentItem->GetChildAt(i, getter_AddRefs(child));
+      PrintDocTree(child, aLevel + 1);
+    }
+  }
+}
+
+static void
+PrintDocTreeAll(nsIDocShellTreeItem* aItem)
+{
+  nsCOMPtr<nsIDocShellTreeItem> item = aItem;
+  for(;;) {
+    nsCOMPtr<nsIDocShellTreeItem> parent;
+    item->GetParent(getter_AddRefs(parent));
+    if (!parent)
+      break;
+    item = parent;
+  }
+
+  PrintDocTree(item, 0);
+}
+#endif
 
 class nsUITimerCallback : public nsITimerCallback
 {
 public:
   nsUITimerCallback() : mPreviousCount(0) {}
   NS_DECL_ISUPPORTS
   NS_DECL_NSITIMERCALLBACK
 private:
@@ -1401,18 +1467,18 @@ nsEventStateManager::PreHandleEvent(nsPr
         }
 
         msEvent->delta = deltaUp ? -userSize : userSize;
       }
       if ((useSysNumLines &&
            (msEvent->scrollFlags & nsMouseScrollEvent::kIsFullPage)) ||
           action == MOUSE_SCROLL_PAGE) {
           msEvent->delta = (msEvent->delta > 0)
-            ? nsIDOMNSUIEvent::SCROLL_PAGE_DOWN
-            : nsIDOMNSUIEvent::SCROLL_PAGE_UP;
+            ? PRInt32(nsIDOMNSUIEvent::SCROLL_PAGE_DOWN)
+            : PRInt32(nsIDOMNSUIEvent::SCROLL_PAGE_UP);
       }
     }
     break;
   case NS_MOUSE_PIXEL_SCROLL:
     {
       if (mCurrentFocus) {
         mCurrentTargetContent = mCurrentFocus;
       }
@@ -2611,21 +2677,22 @@ nsEventStateManager::DoScrollText(nsPres
       scrollY = (scrollY > 0) ? 1 : -1;
       
     if (aScrollHorizontal) {
       scrollX = scrollY;
       scrollY = 0;
     }
     
     if (aScrollQuantity == eScrollByPage)
-      scrollView->ScrollByPages(scrollX, scrollY);
+      scrollView->ScrollByPages(scrollX, scrollY, NS_VMREFRESH_DEFERRED);
     else if (aScrollQuantity == eScrollByPixel)
-      scrollView->ScrollByPixels(scrollX, scrollY);
+      scrollView->ScrollByPixels(scrollX, scrollY, NS_VMREFRESH_DEFERRED);
     else
-      scrollView->ScrollByLines(scrollX, scrollY);
+      scrollView->ScrollByLines(scrollX, scrollY,
+                                NS_VMREFRESH_SMOOTHSCROLL | NS_VMREFRESH_DEFERRED);
 
     ForceViewUpdate(scrollView->View());
   }
   if (passToParent) {
     nsresult rv;
     nsIFrame* newFrame = nsnull;
     nsCOMPtr<nsPresContext> newPresContext;
     rv = GetParentScrollingView(aEvent, aPresContext, newFrame,
@@ -3925,60 +3992,16 @@ nsEventStateManager::ChangeFocusWith(nsI
           inputElement->Select();
         }
       }
     }
   }
   return NS_OK;
 }
 
-//---------------------------------------------------------
-// Debug Helpers
-#ifdef DEBUG_DOCSHELL_FOCUS
-static void
-PrintDocTree(nsIDocShellTreeNode * aParentNode, int aLevel)
-{
-  for (PRInt32 i=0;i<aLevel;i++) printf("  ");
-
-  PRInt32 childWebshellCount;
-  aParentNode->GetChildCount(&childWebshellCount);
-  nsCOMPtr<nsIDocShell> parentAsDocShell(do_QueryInterface(aParentNode));
-  nsCOMPtr<nsIDocShellTreeItem> parentAsItem(do_QueryInterface(aParentNode));
-  PRInt32 type;
-  parentAsItem->GetItemType(&type);
-  nsCOMPtr<nsIPresShell> presShell;
-  parentAsDocShell->GetPresShell(getter_AddRefs(presShell));
-  nsCOMPtr<nsPresContext> presContext;
-  parentAsDocShell->GetPresContext(getter_AddRefs(presContext));
-  nsIDocument *doc = presShell->GetDocument();
-
-  nsCOMPtr<nsIDOMWindowInternal> domwin = doc->GetWindow();
-
-  nsCOMPtr<nsIWidget> widget;
-  nsIViewManager* vm = presShell->GetViewManager();
-  if (vm) {
-    vm->GetWidget(getter_AddRefs(widget));
-  }
-
-  printf("DS %p  Type %s  Cnt %d  Doc %p  DW %p  EM %p\n",
-    parentAsDocShell.get(),
-    type==nsIDocShellTreeItem::typeChrome?"Chrome":"Content",
-    childWebshellCount, doc, domwin.get(),
-    presContext->EventStateManager());
-
-  if (childWebshellCount > 0) {
-    for (PRInt32 i=0;i<childWebshellCount;i++) {
-      nsCOMPtr<nsIDocShellTreeItem> child;
-      aParentNode->GetChildAt(i, getter_AddRefs(child));
-      nsCOMPtr<nsIDocShellTreeNode> childAsNode(do_QueryInterface(child));
-      PrintDocTree(childAsNode, aLevel+1);
-    }
-  }
-}
-#endif // end debug helpers
 
 NS_IMETHODIMP
 nsEventStateManager::ShiftFocus(PRBool aForward, nsIContent* aStart)
 {
   nsCOMPtr<nsILookAndFeel> lookNFeel(do_GetService(kLookAndFeelCID));
   lookNFeel->GetMetric(nsILookAndFeel::eMetric_TabFocusModel,
                        nsIContent::sTabFocusModel);
 
@@ -3992,17 +4015,18 @@ nsEventStateManager::ShiftFocus(PRBool a
   return ShiftFocusInternal(aForward, aStart);
 }
 
 nsresult
 nsEventStateManager::ShiftFocusInternal(PRBool aForward, nsIContent* aStart)
 {
 #ifdef DEBUG_DOCSHELL_FOCUS
   printf("[%p] ShiftFocusInternal: aForward=%d, aStart=%p, mCurrentFocus=%p\n",
-         this, aForward, aStart, mCurrentFocus.get());
+         static_cast<void*>(this), aForward, static_cast<void*>(aStart),
+         static_cast<void*>(mCurrentFocus.get()));
 #endif
   NS_ASSERTION(mPresContext, "no pres context");
   EnsureDocument(mPresContext);
   NS_ASSERTION(mDocument, "no document");
 
   nsCOMPtr<nsIContent> rootContent = mDocument->GetRootContent();
 
   nsCOMPtr<nsISupports> pcContainer = mPresContext->GetContainer();
@@ -4190,17 +4214,18 @@ nsEventStateManager::ShiftFocusInternal(
       // see bug #195011 and bug #137191
       if (mTabbingFromDocShells.IndexOf(sub_shell) != -1)
         return NS_OK;
 
       TabIntoDocument(sub_shell, aForward);
     } else {
       // there is no subshell, so just focus nextFocus
 #ifdef DEBUG_DOCSHELL_FOCUS
-      printf("focusing next focusable content: %p\n", nextFocus.get());
+      printf("focusing next focusable content: %p\n",
+             static_cast<void*>(nextFocus.get()));
 #endif
       mCurrentTarget = nextFocusFrame;
 
       nsCOMPtr<nsIContent> oldFocus(mCurrentFocus);
       ChangeFocusWith(nextFocus, eEventFocusedByKey);
       if (!mCurrentFocus && oldFocus) {
         // ChangeFocusWith failed to move focus to nextFocus because a blur handler
         // made it unfocusable. (bug #118685)
diff -r 4f1383af8f10 content/html/content/src/nsGenericHTMLElement.h
--- a/content/html/content/src/nsGenericHTMLElement.h	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsGenericHTMLElement.h	Mon Nov 03 05:09:07 2008 -0500
@@ -1104,73 +1104,45 @@ NS_NewHTML##_elementName##Element(nsINod
   {                                                                          \
     return SetAttrHelper(nsGkAtoms::_atom, aValue);                        \
   }
 
 /**
  * QueryInterface() implementation helper macros
  */
 
-#define NS_HTML_CONTENT_INTERFACE_TABLE_AMBIGOUS_HEAD(_class, _base,          \
-                                                      _base_if)               \
-  NS_IMETHODIMP _class::QueryInterface(REFNSIID aIID, void** aInstancePtr)    \
-  {                                                                           \
-    NS_PRECONDITION(aInstancePtr, "null out param");                          \
+#define NS_HTML_CONTENT_INTERFACE_TABLE_AMBIGUOUS_BEGIN(_class, _base)        \
+  NS_NODE_OFFSET_AND_INTERFACE_TABLE_BEGIN(_class)                            \
+    NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOMNode, _base)             \
+    NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOMElement, _base)          \
+    NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOMHTMLElement, _base)
+
+#define NS_HTML_CONTENT_INTERFACE_TABLE_BEGIN(_class)                         \
+  NS_HTML_CONTENT_INTERFACE_TABLE_AMBIGUOUS_BEGIN(_class, nsIDOMHTMLElement)
+
+#define NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE_AMBIGUOUS(_class, _base, \
+                                                               _base_if)      \
+  rv = _base::QueryInterface(aIID, aInstancePtr);                             \
+  if (NS_SUCCEEDED(rv))                                                       \
+    return rv;                                                                \
                                                                               \
-    nsresult rv;                                                              \
+  rv = DOMQueryInterface(static_cast<_base_if *>(this), aIID, aInstancePtr);  \
+  if (NS_SUCCEEDED(rv))                                                       \
+    return rv;                                                                \
                                                                               \
-    rv = _base::QueryInterface(aIID, aInstancePtr);                           \
-                                                                              \
-    if (NS_SUCCEEDED(rv))                                                     \
-      return rv;                                                              \
-                                                                              \
-    rv = DOMQueryInterface(static_cast<_base_if *>(this), aIID,               \
-                           aInstancePtr);                                     \
-                                                                              \
-    if (NS_SUCCEEDED(rv))                                                     \
-      return rv;
+  NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
 
-
-#define NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(_class, _base)                   \
-  NS_HTML_CONTENT_INTERFACE_TABLE_AMBIGOUS_HEAD(_class, _base,                \
-                                                nsIDOMHTMLElement)
-
-#define NS_HTML_CONTENT_CC_INTERFACE_TABLE_AMBIGUOUS_HEAD(_class, _base,      \
-                                                          _base_if)           \
-  NS_INTERFACE_TABLE_HEAD_CYCLE_COLLECTION_INHERITED(_class)                  \
-                                                                              \
-    rv = _base::QueryInterface(aIID, aInstancePtr);                           \
-                                                                              \
-    if (NS_SUCCEEDED(rv))                                                     \
-      return rv;                                                              \
-                                                                              \
-    rv = DOMQueryInterface(static_cast<_base_if *>(this), aIID,               \
-                           aInstancePtr);                                     \
-                                                                              \
-    if (NS_SUCCEEDED(rv))                                                     \
-      return rv;
-
-#define NS_HTML_CONTENT_CC_INTERFACE_TABLE_HEAD(_class, _base)                \
-  NS_HTML_CONTENT_CC_INTERFACE_TABLE_AMBIGUOUS_HEAD(_class, _base,            \
-                                                    nsIDOMHTMLElement)
+#define NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(_class, _base)           \
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE_AMBIGUOUS(_class, _base,       \
+                                                         nsIDOMHTMLElement)
 
 #define NS_HTML_CONTENT_INTERFACE_MAP_END                                     \
-    {                                                                         \
-      return PostQueryInterface(aIID, aInstancePtr);                          \
-    }                                                                         \
-                                                                              \
-    NS_ADDREF(foundInterface);                                                \
-                                                                              \
-    *aInstancePtr = foundInterface;                                           \
-                                                                              \
-    return NS_OK;                                                             \
-  }
+  NS_ELEMENT_INTERFACE_MAP_END
 
 #define NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(_class)                \
-    NS_INTERFACE_TABLE_TO_MAP_SEGUE                                           \
     NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(_class)                          \
   NS_HTML_CONTENT_INTERFACE_MAP_END
 
 #define NS_INTERFACE_MAP_ENTRY_IF_TAG(_interface, _tag)                       \
   NS_INTERFACE_MAP_ENTRY_CONDITIONAL(_interface,                              \
                                      mNodeInfo->Equals(nsGkAtoms::_tag))
 
 
@@ -1179,16 +1151,87 @@ NS_NewHTML##_elementName##Element(nsINod
       aIID.Equals(NS_GET_IID(nsIClassInfo))) {                                \
     foundInterface = NS_GetDOMClassInfoInstance(eDOMClassInfo_##_class##_id); \
     if (!foundInterface) {                                                    \
       *aInstancePtr = nsnull;                                                 \
       return NS_ERROR_OUT_OF_MEMORY;                                          \
     }                                                                         \
   } else
 
+#define NS_HTML_CONTENT_INTERFACE_TABLE0(_class)                              \
+  NS_HTML_CONTENT_INTERFACE_TABLE_BEGIN(_class)                               \
+  NS_OFFSET_AND_INTERFACE_TABLE_END
+
+#define NS_HTML_CONTENT_INTERFACE_TABLE1(_class, _i1)                         \
+  NS_HTML_CONTENT_INTERFACE_TABLE_BEGIN(_class)                               \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i1)                                     \
+  NS_OFFSET_AND_INTERFACE_TABLE_END
+
+#define NS_HTML_CONTENT_INTERFACE_TABLE2(_class, _i1, _i2)                    \
+  NS_HTML_CONTENT_INTERFACE_TABLE_BEGIN(_class)                               \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i1)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i2)                                     \
+  NS_OFFSET_AND_INTERFACE_TABLE_END
+
+#define NS_HTML_CONTENT_INTERFACE_TABLE4(_class, _i1, _i2, _i3, _i4)          \
+  NS_HTML_CONTENT_INTERFACE_TABLE_BEGIN(_class)                               \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i1)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i2)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i3)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i4)                                     \
+  NS_OFFSET_AND_INTERFACE_TABLE_END
+
+#define NS_HTML_CONTENT_INTERFACE_TABLE5(_class, _i1, _i2, _i3, _i4, _i5)     \
+  NS_HTML_CONTENT_INTERFACE_TABLE_BEGIN(_class)                               \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i1)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i2)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i3)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i4)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i5)                                     \
+  NS_OFFSET_AND_INTERFACE_TABLE_END
+
+#define NS_HTML_CONTENT_INTERFACE_TABLE6(_class, _i1, _i2, _i3, _i4, _i5,     \
+                                         _i6)                                 \
+  NS_HTML_CONTENT_INTERFACE_TABLE_BEGIN(_class)                               \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i1)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i2)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i3)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i4)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i5)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i6)                                     \
+  NS_OFFSET_AND_INTERFACE_TABLE_END
+
+#define NS_HTML_CONTENT_INTERFACE_TABLE9(_class, _i1, _i2, _i3, _i4, _i5,     \
+                                         _i6, _i7, _i8, _i9)                  \
+  NS_HTML_CONTENT_INTERFACE_TABLE_BEGIN(_class)                               \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i1)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i2)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i3)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i4)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i5)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i6)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i7)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i8)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i9)                                     \
+  NS_OFFSET_AND_INTERFACE_TABLE_END
+
+#define NS_HTML_CONTENT_INTERFACE_TABLE10(_class, _i1, _i2, _i3, _i4, _i5,    \
+                                          _i6, _i7, _i8, _i9, _i10)           \
+  NS_HTML_CONTENT_INTERFACE_TABLE_BEGIN(_class)                               \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i1)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i2)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i3)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i4)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i5)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i6)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i7)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i8)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i9)                                     \
+    NS_INTERFACE_TABLE_ENTRY(_class, _i10)                                    \
+  NS_OFFSET_AND_INTERFACE_TABLE_END
 
 
 // Element class factory methods
 
 #define NS_DECLARE_NS_NEW_HTML_ELEMENT(_elementName)              \
 nsGenericHTMLElement*                                             \
 NS_NewHTML##_elementName##Element(nsINodeInfo *aNodeInfo,         \
                                   PRBool aFromParser = PR_FALSE);
diff -r 4f1383af8f10 content/html/content/src/nsHTMLAnchorElement.cpp
--- a/content/html/content/src/nsHTMLAnchorElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLAnchorElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -152,22 +152,24 @@ nsHTMLAnchorElement::~nsHTMLAnchorElemen
 }
 
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLAnchorElement, nsGenericElement) 
 NS_IMPL_RELEASE_INHERITED(nsHTMLAnchorElement, nsGenericElement) 
 
 
 // QueryInterface implementation for nsHTMLAnchorElement
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLAnchorElement, nsGenericHTMLElement)
-  NS_INTERFACE_TABLE_INHERITED4(nsHTMLAnchorElement,
-                                nsIDOMHTMLAnchorElement,
-                                nsIDOMNSHTMLAnchorElement,
-                                nsIDOMNSHTMLAnchorElement2,
-                                nsILink)
+NS_INTERFACE_TABLE_HEAD(nsHTMLAnchorElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE4(nsHTMLAnchorElement,
+                                   nsIDOMHTMLAnchorElement,
+                                   nsIDOMNSHTMLAnchorElement,
+                                   nsIDOMNSHTMLAnchorElement2,
+                                   nsILink)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLAnchorElement,
+                                               nsGenericHTMLElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLAnchorElement)
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLAnchorElement)
 
 
 NS_IMPL_STRING_ATTR(nsHTMLAnchorElement, Charset, charset)
 NS_IMPL_STRING_ATTR(nsHTMLAnchorElement, Coords, coords)
diff -r 4f1383af8f10 content/html/content/src/nsHTMLAreaElement.cpp
--- a/content/html/content/src/nsHTMLAreaElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLAreaElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -131,22 +131,24 @@ nsHTMLAreaElement::~nsHTMLAreaElement()
 {
 }
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLAreaElement, nsGenericElement) 
 NS_IMPL_RELEASE_INHERITED(nsHTMLAreaElement, nsGenericElement) 
 
 
 // QueryInterface implementation for nsHTMLAreaElement
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLAreaElement, nsGenericHTMLElement)
-  NS_INTERFACE_TABLE_INHERITED4(nsHTMLAreaElement,
-                                nsIDOMHTMLAreaElement,
-                                nsIDOMNSHTMLAreaElement,
-                                nsIDOMNSHTMLAreaElement2,
-                                nsILink)
+NS_INTERFACE_TABLE_HEAD(nsHTMLAreaElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE4(nsHTMLAreaElement,
+                                   nsIDOMHTMLAreaElement,
+                                   nsIDOMNSHTMLAreaElement,
+                                   nsIDOMNSHTMLAreaElement2,
+                                   nsILink)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLAreaElement,
+                                               nsGenericHTMLElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLAreaElement)
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLAreaElement)
 
 
 NS_IMPL_STRING_ATTR(nsHTMLAreaElement, AccessKey, accesskey)
 NS_IMPL_STRING_ATTR(nsHTMLAreaElement, Alt, alt)
diff -r 4f1383af8f10 content/html/content/src/nsHTMLAudioElement.cpp
--- a/content/html/content/src/nsHTMLAudioElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLAudioElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -68,18 +68,20 @@
 #include "nsIDOMProgressEvent.h"
 #include "nsHTMLMediaError.h"
 
 NS_IMPL_NS_NEW_HTML_ELEMENT_CHECK_PARSER(Audio)
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLAudioElement, nsHTMLMediaElement)
 NS_IMPL_RELEASE_INHERITED(nsHTMLAudioElement, nsHTMLMediaElement)
 
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLAudioElement, nsHTMLMediaElement)
-  NS_INTERFACE_TABLE_INHERITED1(nsHTMLAudioElement, nsIDOMHTMLAudioElement)
+NS_INTERFACE_TABLE_HEAD(nsHTMLAudioElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE1(nsHTMLAudioElement, nsIDOMHTMLAudioElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLAudioElement,
+                                               nsHTMLMediaElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLAudioElement)
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLAudioElement)
 
 
 nsHTMLAudioElement::nsHTMLAudioElement(nsINodeInfo *aNodeInfo, PRBool aFromParser)
   : nsHTMLMediaElement(aNodeInfo, aFromParser)
 {
diff -r 4f1383af8f10 content/html/content/src/nsHTMLBRElement.cpp
--- a/content/html/content/src/nsHTMLBRElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLBRElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -87,18 +87,20 @@ nsHTMLBRElement::~nsHTMLBRElement()
 {
 }
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLBRElement, nsGenericElement) 
 NS_IMPL_RELEASE_INHERITED(nsHTMLBRElement, nsGenericElement) 
 
 
 // QueryInterface implementation for nsHTMLBRElement
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLBRElement, nsGenericHTMLElement)
-  NS_INTERFACE_TABLE_INHERITED1(nsHTMLBRElement, nsIDOMHTMLBRElement)
+NS_INTERFACE_TABLE_HEAD(nsHTMLBRElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE1(nsHTMLBRElement, nsIDOMHTMLBRElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLBRElement,
+                                               nsGenericHTMLElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLBRElement)
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLBRElement)
 
 
 NS_IMPL_STRING_ATTR(nsHTMLBRElement, Clear, clear)
 
diff -r 4f1383af8f10 content/html/content/src/nsHTMLBodyElement.cpp
--- a/content/html/content/src/nsHTMLBodyElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLBodyElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -294,20 +294,21 @@ nsHTMLBodyElement::~nsHTMLBodyElement()
   }
 }
 
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLBodyElement, nsGenericElement) 
 NS_IMPL_RELEASE_INHERITED(nsHTMLBodyElement, nsGenericElement) 
 
 // QueryInterface implementation for nsHTMLBodyElement
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLBodyElement, nsGenericHTMLElement)
-  NS_INTERFACE_TABLE_INHERITED1(nsHTMLBodyElement, nsIDOMHTMLBodyElement)
+NS_INTERFACE_TABLE_HEAD(nsHTMLBodyElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE1(nsHTMLBodyElement, nsIDOMHTMLBodyElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLBodyElement,
+                                               nsGenericHTMLElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLBodyElement)
-
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLBodyElement)
 
 
 NS_IMPL_URI_ATTR(nsHTMLBodyElement, Background, background)
 
 static nscolor
 GetDefaultColor(nsPresContext* aContext, nsIAtom* aAtom)
diff -r 4f1383af8f10 content/html/content/src/nsHTMLButtonElement.cpp
--- a/content/html/content/src/nsHTMLButtonElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLButtonElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -156,21 +156,22 @@ nsHTMLButtonElement::~nsHTMLButtonElemen
 
 // nsISupports
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLButtonElement, nsGenericElement)
 NS_IMPL_RELEASE_INHERITED(nsHTMLButtonElement, nsGenericElement)
 
 
 // QueryInterface implementation for nsHTMLButtonElement
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLButtonElement,
-                                     nsGenericHTMLFormElement)
-  NS_INTERFACE_TABLE_INHERITED2(nsHTMLButtonElement,
-                                nsIDOMHTMLButtonElement,
-                                nsIDOMNSHTMLButtonElement)
+NS_INTERFACE_TABLE_HEAD(nsHTMLButtonElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE2(nsHTMLButtonElement,
+                                   nsIDOMHTMLButtonElement,
+                                   nsIDOMNSHTMLButtonElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLButtonElement,
+                                               nsGenericHTMLFormElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLButtonElement)
 
 // nsIDOMHTMLButtonElement
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLButtonElement)
 
 
diff -r 4f1383af8f10 content/html/content/src/nsHTMLCanvasElement.cpp
--- a/content/html/content/src/nsHTMLCanvasElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLCanvasElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -154,20 +154,22 @@ nsHTMLCanvasElement::~nsHTMLCanvasElemen
     internalctx->SetCanvasElement(nsnull);
     mCurrentContext = nsnull;
   }
 }
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLCanvasElement, nsGenericElement)
 NS_IMPL_RELEASE_INHERITED(nsHTMLCanvasElement, nsGenericElement)
 
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLCanvasElement, nsGenericHTMLElement)
-  NS_INTERFACE_TABLE_INHERITED2(nsHTMLCanvasElement,
-                                nsIDOMHTMLCanvasElement,
-                                nsICanvasElement)
+NS_INTERFACE_TABLE_HEAD(nsHTMLCanvasElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE2(nsHTMLCanvasElement,
+                                   nsIDOMHTMLCanvasElement,
+                                   nsICanvasElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLCanvasElement,
+                                               nsGenericHTMLElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLCanvasElement)
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLCanvasElement)
 
 nsIntSize
 nsHTMLCanvasElement::GetWidthHeight()
 {
   nsIntSize size(0,0);
diff -r 4f1383af8f10 content/html/content/src/nsHTMLDelElement.cpp
--- a/content/html/content/src/nsHTMLDelElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLDelElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -80,19 +80,20 @@ nsHTMLModElement::~nsHTMLModElement()
 }
 
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLModElement, nsGenericElement)
 NS_IMPL_RELEASE_INHERITED(nsHTMLModElement, nsGenericElement)
 
 
 // QueryInterface implementation for nsHTMLModElement
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLModElement, nsGenericHTMLElement)
-  NS_INTERFACE_TABLE_INHERITED1(nsHTMLModElement, nsIDOMHTMLModElement)
-  NS_INTERFACE_TABLE_TO_MAP_SEGUE
+NS_INTERFACE_TABLE_HEAD(nsHTMLModElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE1(nsHTMLModElement, nsIDOMHTMLModElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLModElement,
+                                               nsGenericHTMLElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO_IF_TAG(HTMLDelElement, del)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO_IF_TAG(HTMLInsElement, ins)
 NS_HTML_CONTENT_INTERFACE_MAP_END
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLModElement)
 
 
diff -r 4f1383af8f10 content/html/content/src/nsHTMLDivElement.cpp
--- a/content/html/content/src/nsHTMLDivElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLDivElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -88,18 +88,20 @@ nsHTMLDivElement::~nsHTMLDivElement()
 
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLDivElement, nsGenericElement) 
 NS_IMPL_RELEASE_INHERITED(nsHTMLDivElement, nsGenericElement) 
 
 
 
 // QueryInterface implementation for nsHTMLDivElement
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLDivElement, nsGenericHTMLElement)
-  NS_INTERFACE_TABLE_INHERITED1(nsHTMLDivElement, nsIDOMHTMLDivElement)
+NS_INTERFACE_TABLE_HEAD(nsHTMLDivElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE1(nsHTMLDivElement, nsIDOMHTMLDivElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLDivElement,
+                                               nsGenericHTMLElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLDivElement)
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLDivElement)
 
 
 NS_IMPL_STRING_ATTR(nsHTMLDivElement, Align, align)
 
 
diff -r 4f1383af8f10 content/html/content/src/nsHTMLFieldSetElement.cpp
--- a/content/html/content/src/nsHTMLFieldSetElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLFieldSetElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -91,20 +91,21 @@ nsHTMLFieldSetElement::~nsHTMLFieldSetEl
 
 // nsISupports
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLFieldSetElement, nsGenericElement)
 NS_IMPL_RELEASE_INHERITED(nsHTMLFieldSetElement, nsGenericElement)
 
 
 // QueryInterface implementation for nsHTMLFieldSetElement
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLFieldSetElement,
-                                     nsGenericHTMLFormElement)
-  NS_INTERFACE_TABLE_INHERITED1(nsHTMLFieldSetElement,
-                                nsIDOMHTMLFieldSetElement)
+NS_INTERFACE_TABLE_HEAD(nsHTMLFieldSetElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE1(nsHTMLFieldSetElement,
+                                   nsIDOMHTMLFieldSetElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLFieldSetElement,
+                                               nsGenericHTMLFormElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLFieldSetElement)
 
 
 // nsIDOMHTMLFieldSetElement
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLFieldSetElement)
 
diff -r 4f1383af8f10 content/html/content/src/nsHTMLFontElement.cpp
--- a/content/html/content/src/nsHTMLFontElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLFontElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -91,18 +91,20 @@ nsHTMLFontElement::~nsHTMLFontElement()
 {
 }
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLFontElement, nsGenericElement)
 NS_IMPL_RELEASE_INHERITED(nsHTMLFontElement, nsGenericElement)
 
 
 // QueryInterface implementation for nsHTMLFontElement
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLFontElement, nsGenericHTMLElement)
-  NS_INTERFACE_TABLE_INHERITED1(nsHTMLFontElement, nsIDOMHTMLFontElement)
+NS_INTERFACE_TABLE_HEAD(nsHTMLFontElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE1(nsHTMLFontElement, nsIDOMHTMLFontElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLFontElement,
+                                               nsGenericHTMLElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLFontElement)
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLFontElement)
 
 
 NS_IMPL_STRING_ATTR(nsHTMLFontElement, Color, color)
 NS_IMPL_STRING_ATTR(nsHTMLFontElement, Face, face)
diff -r 4f1383af8f10 content/html/content/src/nsHTMLFormElement.cpp
--- a/content/html/content/src/nsHTMLFormElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLFormElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -560,24 +560,25 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_
   tmp->mSelectedRadioButtons.EnumerateRead(ElementTraverser, &cb);
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLFormElement, nsGenericElement) 
 NS_IMPL_RELEASE_INHERITED(nsHTMLFormElement, nsGenericElement) 
 
 
 // QueryInterface implementation for nsHTMLFormElement
-NS_HTML_CONTENT_CC_INTERFACE_TABLE_HEAD(nsHTMLFormElement,
-                                        nsGenericHTMLElement)
-  NS_INTERFACE_TABLE_INHERITED5(nsHTMLFormElement,
-                                nsIDOMHTMLFormElement,
-                                nsIDOMNSHTMLFormElement,
-                                nsIForm,
-                                nsIWebProgressListener,
-                                nsIRadioGroupContainer)
+NS_INTERFACE_TABLE_HEAD_CYCLE_COLLECTION_INHERITED(nsHTMLFormElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE5(nsHTMLFormElement,
+                                   nsIDOMHTMLFormElement,
+                                   nsIDOMNSHTMLFormElement,
+                                   nsIForm,
+                                   nsIWebProgressListener,
+                                   nsIRadioGroupContainer)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLFormElement,
+                                               nsGenericHTMLElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLFormElement)
 
 
 // nsIDOMHTMLFormElement
 
 NS_IMPL_ELEMENT_CLONE_WITH_INIT(nsHTMLFormElement)
 
 NS_IMETHODIMP
diff -r 4f1383af8f10 content/html/content/src/nsHTMLFrameElement.cpp
--- a/content/html/content/src/nsHTMLFrameElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLFrameElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -89,19 +89,20 @@ nsHTMLFrameElement::~nsHTMLFrameElement(
 }
 
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLFrameElement, nsGenericElement)
 NS_IMPL_RELEASE_INHERITED(nsHTMLFrameElement, nsGenericElement)
 
 
 // QueryInterface implementation for nsHTMLFrameElement
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLFrameElement,
-                                     nsGenericHTMLFrameElement)
-  NS_INTERFACE_TABLE_INHERITED1(nsHTMLFrameElement, nsIDOMHTMLFrameElement)
+NS_INTERFACE_TABLE_HEAD(nsHTMLFrameElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE1(nsHTMLFrameElement, nsIDOMHTMLFrameElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLFrameElement,
+                                               nsGenericHTMLFrameElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLFrameElement)
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLFrameElement)
 
 
 NS_IMPL_STRING_ATTR(nsHTMLFrameElement, FrameBorder, frameborder)
 NS_IMPL_URI_ATTR(nsHTMLFrameElement, LongDesc, longdesc)
diff -r 4f1383af8f10 content/html/content/src/nsHTMLFrameSetElement.cpp
--- a/content/html/content/src/nsHTMLFrameSetElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLFrameSetElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -133,21 +133,22 @@ nsHTMLFrameSetElement::~nsHTMLFrameSetEl
 }
 
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLFrameSetElement, nsGenericElement) 
 NS_IMPL_RELEASE_INHERITED(nsHTMLFrameSetElement, nsGenericElement) 
 
 
 // QueryInterface implementation for nsHTMLFrameSetElement
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLFrameSetElement,
-                                      nsGenericHTMLElement)
-  NS_INTERFACE_TABLE_INHERITED2(nsHTMLFrameSetElement,
-                                nsIDOMHTMLFrameSetElement,
-                                nsIFrameSetElement)
+NS_INTERFACE_TABLE_HEAD(nsHTMLFrameSetElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE2(nsHTMLFrameSetElement,
+                                   nsIDOMHTMLFrameSetElement,
+                                   nsIFrameSetElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLFrameSetElement,
+                                               nsGenericHTMLElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLFrameSetElement)
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLFrameSetElement)
 
 
 NS_IMPL_STRING_ATTR(nsHTMLFrameSetElement, Cols, cols)
 NS_IMPL_STRING_ATTR(nsHTMLFrameSetElement, Rows, rows)
diff -r 4f1383af8f10 content/html/content/src/nsHTMLHRElement.cpp
--- a/content/html/content/src/nsHTMLHRElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLHRElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -93,20 +93,22 @@ nsHTMLHRElement::~nsHTMLHRElement()
 }
 
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLHRElement, nsGenericElement) 
 NS_IMPL_RELEASE_INHERITED(nsHTMLHRElement, nsGenericElement) 
 
 
 // QueryInterface implementation for nsHTMLHRElement
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLHRElement, nsGenericHTMLElement)
-  NS_INTERFACE_TABLE_INHERITED2(nsHTMLHRElement,
-                                nsIDOMHTMLHRElement,
-                                nsIDOMNSHTMLHRElement)
+NS_INTERFACE_TABLE_HEAD(nsHTMLHRElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE2(nsHTMLHRElement,
+                                   nsIDOMHTMLHRElement,
+                                   nsIDOMNSHTMLHRElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLHRElement,
+                                               nsGenericHTMLElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLHRElement)
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLHRElement)
 
 
 NS_IMPL_STRING_ATTR(nsHTMLHRElement, Align, align)
 NS_IMPL_BOOL_ATTR(nsHTMLHRElement, NoShade, noshade)
diff -r 4f1383af8f10 content/html/content/src/nsHTMLHeadElement.cpp
--- a/content/html/content/src/nsHTMLHeadElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLHeadElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -81,17 +81,19 @@ nsHTMLHeadElement::~nsHTMLHeadElement()
 }
 
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLHeadElement, nsGenericElement)
 NS_IMPL_RELEASE_INHERITED(nsHTMLHeadElement, nsGenericElement)
 
 
 // QueryInterface implementation for nsHTMLHeadElement
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLHeadElement, nsGenericHTMLElement)
-  NS_INTERFACE_TABLE_INHERITED1(nsHTMLHeadElement, nsIDOMHTMLHeadElement)
+NS_INTERFACE_TABLE_HEAD(nsHTMLHeadElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE1(nsHTMLHeadElement, nsIDOMHTMLHeadElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLHeadElement,
+                                               nsGenericHTMLElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLHeadElement)
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLHeadElement)
 
 
 NS_IMPL_URI_ATTR(nsHTMLHeadElement, Profile, profile)
diff -r 4f1383af8f10 content/html/content/src/nsHTMLHeadingElement.cpp
--- a/content/html/content/src/nsHTMLHeadingElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLHeadingElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -89,19 +89,21 @@ nsHTMLHeadingElement::~nsHTMLHeadingElem
 }
 
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLHeadingElement, nsGenericElement) 
 NS_IMPL_RELEASE_INHERITED(nsHTMLHeadingElement, nsGenericElement) 
 
 
 // QueryInterface implementation for nsHTMLHeadingElement
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLHeadingElement,
-                                     nsGenericHTMLElement)
-  NS_INTERFACE_TABLE_INHERITED1(nsHTMLHeadingElement, nsIDOMHTMLHeadingElement)
+NS_INTERFACE_TABLE_HEAD(nsHTMLHeadingElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE1(nsHTMLHeadingElement,
+                                   nsIDOMHTMLHeadingElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLHeadingElement,
+                                               nsGenericHTMLElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLHeadingElement)
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLHeadingElement)
 
 
 NS_IMPL_STRING_ATTR(nsHTMLHeadingElement, Align, align)
 
diff -r 4f1383af8f10 content/html/content/src/nsHTMLHtmlElement.cpp
--- a/content/html/content/src/nsHTMLHtmlElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLHtmlElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -83,17 +83,19 @@ nsHTMLHtmlElement::~nsHTMLHtmlElement()
 
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLHtmlElement, nsGenericElement) 
 NS_IMPL_RELEASE_INHERITED(nsHTMLHtmlElement, nsGenericElement) 
 
 
 
 // QueryInterface implementation for nsHTMLHtmlElement
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLHtmlElement, nsGenericHTMLElement)
-  NS_INTERFACE_TABLE_INHERITED1(nsHTMLHtmlElement, nsIDOMHTMLHtmlElement)
+NS_INTERFACE_TABLE_HEAD(nsHTMLHtmlElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE1(nsHTMLHtmlElement, nsIDOMHTMLHtmlElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLHtmlElement,
+                                               nsGenericHTMLElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLHtmlElement)
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLHtmlElement)
 
 
 NS_IMPL_STRING_ATTR(nsHTMLHtmlElement, Version, version)
diff -r 4f1383af8f10 content/html/content/src/nsHTMLIFrameElement.cpp
--- a/content/html/content/src/nsHTMLIFrameElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLIFrameElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -104,24 +104,25 @@ nsHTMLIFrameElement::~nsHTMLIFrameElemen
 {
 }
 
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLIFrameElement,nsGenericElement)
 NS_IMPL_RELEASE_INHERITED(nsHTMLIFrameElement,nsGenericElement)
 
 // QueryInterface implementation for nsHTMLIFrameElement
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLIFrameElement,
-                                     nsGenericHTMLFrameElement)
-  NS_INTERFACE_TABLE_BEGIN
+NS_INTERFACE_TABLE_HEAD(nsHTMLIFrameElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_BEGIN(nsHTMLIFrameElement)
     NS_INTERFACE_TABLE_ENTRY(nsHTMLIFrameElement, nsIDOMHTMLIFrameElement)
 #ifdef MOZ_SVG
     NS_INTERFACE_TABLE_ENTRY(nsHTMLIFrameElement, nsIDOMGetSVGDocument)
 #endif
-  NS_INTERFACE_TABLE_END
+  NS_OFFSET_AND_INTERFACE_TABLE_END
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLIFrameElement,
+                                               nsGenericHTMLFrameElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLIFrameElement)
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLIFrameElement)
 
 
 NS_IMPL_STRING_ATTR(nsHTMLIFrameElement, Align, align)
 NS_IMPL_STRING_ATTR(nsHTMLIFrameElement, FrameBorder, frameborder)
diff -r 4f1383af8f10 content/html/content/src/nsHTMLImageElement.cpp
--- a/content/html/content/src/nsHTMLImageElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLImageElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -187,24 +187,26 @@ nsHTMLImageElement::~nsHTMLImageElement(
 }
 
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLImageElement, nsGenericElement)
 NS_IMPL_RELEASE_INHERITED(nsHTMLImageElement, nsGenericElement)
 
 
 // QueryInterface implementation for nsHTMLImageElement
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLImageElement, nsGenericHTMLElement)
-  NS_INTERFACE_TABLE_INHERITED6(nsHTMLImageElement,
-                                nsIDOMHTMLImageElement,
-                                nsIDOMNSHTMLImageElement,
-                                nsIJSNativeInitializer,
-                                imgIDecoderObserver,
-                                nsIImageLoadingContent,
-                                imgIContainerObserver)
+NS_INTERFACE_TABLE_HEAD(nsHTMLImageElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE6(nsHTMLImageElement,
+                                   nsIDOMHTMLImageElement,
+                                   nsIDOMNSHTMLImageElement,
+                                   nsIJSNativeInitializer,
+                                   imgIDecoderObserver,
+                                   nsIImageLoadingContent,
+                                   imgIContainerObserver)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLImageElement,
+                                               nsGenericHTMLElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLImageElement)
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLImageElement)
 
 
 NS_IMPL_STRING_ATTR(nsHTMLImageElement, Name, name)
 NS_IMPL_STRING_ATTR(nsHTMLImageElement, Align, align)
diff -r 4f1383af8f10 content/html/content/src/nsHTMLInputElement.cpp
--- a/content/html/content/src/nsHTMLInputElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLInputElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -405,29 +405,30 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mControllers)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLInputElement, nsGenericElement) 
 NS_IMPL_RELEASE_INHERITED(nsHTMLInputElement, nsGenericElement) 
 
 
 // QueryInterface implementation for nsHTMLInputElement
-NS_HTML_CONTENT_CC_INTERFACE_TABLE_HEAD(nsHTMLInputElement,
-                                        nsGenericHTMLFormElement)
-  NS_INTERFACE_TABLE_INHERITED10(nsHTMLInputElement,
-                                 nsIDOMHTMLInputElement,
-                                 nsIDOMNSHTMLInputElement,
-                                 nsITextControlElement,
-                                 nsIFileControlElement,
-                                 nsIRadioControlElement,
-                                 nsIPhonetic,
-                                 imgIDecoderObserver,
-                                 nsIImageLoadingContent,
-                                 imgIContainerObserver,
-                                 nsIDOMNSEditableElement)
+NS_INTERFACE_TABLE_HEAD_CYCLE_COLLECTION_INHERITED(nsHTMLInputElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE10(nsHTMLInputElement,
+                                    nsIDOMHTMLInputElement,
+                                    nsIDOMNSHTMLInputElement,
+                                    nsITextControlElement,
+                                    nsIFileControlElement,
+                                    nsIRadioControlElement,
+                                    nsIPhonetic,
+                                    imgIDecoderObserver,
+                                    nsIImageLoadingContent,
+                                    imgIContainerObserver,
+                                    nsIDOMNSEditableElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLInputElement,
+                                               nsGenericHTMLFormElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLInputElement)
 
 
 // nsIDOMNode
 
 nsresult
 nsHTMLInputElement::Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const
 {
@@ -2383,26 +2384,30 @@ nsHTMLInputElement::SubmitNamesValues(ns
   nsAutoString name;
   PRBool nameThere = GetNameIfExists(name);
 
   //
   // Submit .x, .y for input type=image
   //
   if (mType == NS_FORM_INPUT_IMAGE) {
     // Get a property set by the frame to find out where it was clicked.
-    nsAutoString xVal;
-    nsAutoString yVal;
-
     nsIntPoint* lastClickedPoint =
       static_cast<nsIntPoint*>(GetProperty(nsGkAtoms::imageClickedPoint));
+    PRInt32 x, y;
     if (lastClickedPoint) {
       // Convert the values to strings for submission
-      xVal.AppendInt(lastClickedPoint->x);
-      yVal.AppendInt(lastClickedPoint->y);
+      x = lastClickedPoint->x;
+      y = lastClickedPoint->y;
+    } else {
+      x = y = 0;
     }
+
+    nsAutoString xVal, yVal;
+    xVal.AppendInt(x);
+    yVal.AppendInt(y);
 
     if (!name.IsEmpty()) {
       aFormSubmission->AddNameValuePair(this,
                                         name + NS_LITERAL_STRING(".x"), xVal);
       aFormSubmission->AddNameValuePair(this,
                                         name + NS_LITERAL_STRING(".y"), yVal);
     } else {
       // If the Image Element has no name, simply return x and y
diff -r 4f1383af8f10 content/html/content/src/nsHTMLLIElement.cpp
--- a/content/html/content/src/nsHTMLLIElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLLIElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -88,18 +88,20 @@ nsHTMLLIElement::~nsHTMLLIElement()
 }
 
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLLIElement, nsGenericElement)
 NS_IMPL_RELEASE_INHERITED(nsHTMLLIElement, nsGenericElement)
 
 
 // QueryInterface implementation for nsHTMLLIElement
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLLIElement, nsGenericHTMLElement)
-  NS_INTERFACE_TABLE_INHERITED1(nsHTMLLIElement, nsIDOMHTMLLIElement)
+NS_INTERFACE_TABLE_HEAD(nsHTMLLIElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE1(nsHTMLLIElement, nsIDOMHTMLLIElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLLIElement,
+                                               nsGenericHTMLElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLLIElement)
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLLIElement)
 
 
 NS_IMPL_STRING_ATTR(nsHTMLLIElement, Type, type)
 NS_IMPL_INT_ATTR(nsHTMLLIElement, Value, value)
diff -r 4f1383af8f10 content/html/content/src/nsHTMLLabelElement.cpp
--- a/content/html/content/src/nsHTMLLabelElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLLabelElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -135,19 +135,20 @@ nsHTMLLabelElement::~nsHTMLLabelElement(
 // nsISupports 
 
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLLabelElement, nsGenericElement) 
 NS_IMPL_RELEASE_INHERITED(nsHTMLLabelElement, nsGenericElement) 
 
 
 // QueryInterface implementation for nsHTMLLabelElement
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLLabelElement,
-                                     nsGenericHTMLFormElement)
-  NS_INTERFACE_TABLE_INHERITED1(nsHTMLLabelElement, nsIDOMHTMLLabelElement)
+NS_INTERFACE_TABLE_HEAD(nsHTMLLabelElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE1(nsHTMLLabelElement, nsIDOMHTMLLabelElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLLabelElement,
+                                               nsGenericHTMLFormElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLLabelElement)
 
 
 // nsIDOMHTMLLabelElement
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLLabelElement)
 
diff -r 4f1383af8f10 content/html/content/src/nsHTMLLegendElement.cpp
--- a/content/html/content/src/nsHTMLLegendElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLLegendElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -123,19 +123,20 @@ nsHTMLLegendElement::~nsHTMLLegendElemen
 }
 
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLLegendElement, nsGenericElement) 
 NS_IMPL_RELEASE_INHERITED(nsHTMLLegendElement, nsGenericElement) 
 
 
 // QueryInterface implementation for nsHTMLLegendElement
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLLegendElement,
-                                     nsGenericHTMLFormElement)
-  NS_INTERFACE_TABLE_INHERITED1(nsHTMLLegendElement, nsIDOMHTMLLegendElement)
+NS_INTERFACE_TABLE_HEAD(nsHTMLLegendElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE1(nsHTMLLegendElement, nsIDOMHTMLLegendElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLLegendElement,
+                                               nsGenericHTMLFormElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLLegendElement)
 
 
 // nsIDOMHTMLLegendElement
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLLegendElement)
 
diff -r 4f1383af8f10 content/html/content/src/nsHTMLLinkElement.cpp
--- a/content/html/content/src/nsHTMLLinkElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLLinkElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -142,22 +142,24 @@ nsHTMLLinkElement::~nsHTMLLinkElement()
 }
 
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLLinkElement, nsGenericElement) 
 NS_IMPL_RELEASE_INHERITED(nsHTMLLinkElement, nsGenericElement) 
 
 
 // QueryInterface implementation for nsHTMLLinkElement
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLLinkElement, nsGenericHTMLElement)
-  NS_INTERFACE_TABLE_INHERITED4(nsHTMLLinkElement,
-                                nsIDOMHTMLLinkElement,
-                                nsIDOMLinkStyle,
-                                nsILink,
-                                nsIStyleSheetLinkingElement)
+NS_INTERFACE_TABLE_HEAD(nsHTMLLinkElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE4(nsHTMLLinkElement,
+                                   nsIDOMHTMLLinkElement,
+                                   nsIDOMLinkStyle,
+                                   nsILink,
+                                   nsIStyleSheetLinkingElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLLinkElement,
+                                               nsGenericHTMLElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLLinkElement)
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLLinkElement)
 
 
 NS_IMETHODIMP
 nsHTMLLinkElement::GetDisabled(PRBool* aDisabled)
diff -r 4f1383af8f10 content/html/content/src/nsHTMLMapElement.cpp
--- a/content/html/content/src/nsHTMLMapElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLMapElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -97,19 +97,20 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_
                                                        nsIDOMNodeList)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLMapElement, nsGenericElement) 
 NS_IMPL_RELEASE_INHERITED(nsHTMLMapElement, nsGenericElement) 
 
 
 // QueryInterface implementation for nsHTMLMapElement
-NS_HTML_CONTENT_CC_INTERFACE_TABLE_HEAD(nsHTMLMapElement,
-                                        nsGenericHTMLElement)
-  NS_INTERFACE_TABLE_INHERITED1(nsHTMLMapElement, nsIDOMHTMLMapElement)
+NS_INTERFACE_TABLE_HEAD_CYCLE_COLLECTION_INHERITED(nsHTMLMapElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE1(nsHTMLMapElement, nsIDOMHTMLMapElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLMapElement,
+                                               nsGenericHTMLElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLMapElement)
 
 
 nsresult
 nsHTMLMapElement::BindToTree(nsIDocument* aDocument, nsIContent* aParent,
                              nsIContent* aBindingParent,
                              PRBool aCompileEventHandlers)
 {
diff -r 4f1383af8f10 content/html/content/src/nsHTMLMetaElement.cpp
--- a/content/html/content/src/nsHTMLMetaElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLMetaElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -82,19 +82,20 @@ nsHTMLMetaElement::~nsHTMLMetaElement()
 
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLMetaElement, nsGenericElement) 
 NS_IMPL_RELEASE_INHERITED(nsHTMLMetaElement, nsGenericElement) 
 
 
 
 // QueryInterface implementation for nsHTMLMetaElement
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLMetaElement,
-                                     nsGenericHTMLElement)
-  NS_INTERFACE_TABLE_INHERITED1(nsHTMLMetaElement, nsIDOMHTMLMetaElement)
+NS_INTERFACE_TABLE_HEAD(nsHTMLMetaElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE1(nsHTMLMetaElement, nsIDOMHTMLMetaElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLMetaElement,
+                                               nsGenericHTMLElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLMetaElement)
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLMetaElement)
 
 
 NS_IMPL_STRING_ATTR(nsHTMLMetaElement, Content, content)
 NS_IMPL_STRING_ATTR(nsHTMLMetaElement, HttpEquiv, httpEquiv)
diff -r 4f1383af8f10 content/html/content/src/nsHTMLOListElement.cpp
--- a/content/html/content/src/nsHTMLOListElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLOListElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -98,20 +98,23 @@ nsHTMLSharedListElement::~nsHTMLSharedLi
 }
 
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLSharedListElement, nsGenericElement) 
 NS_IMPL_RELEASE_INHERITED(nsHTMLSharedListElement, nsGenericElement) 
 
 
 // QueryInterface implementation for nsHTMLSharedListElement
-NS_HTML_CONTENT_INTERFACE_TABLE_AMBIGOUS_HEAD(nsHTMLSharedListElement,
-                                              nsGenericHTMLElement,
-                                              nsIDOMHTMLOListElement)
-  NS_INTERFACE_TABLE_TO_MAP_SEGUE
+NS_INTERFACE_TABLE_HEAD(nsHTMLSharedListElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_AMBIGUOUS_BEGIN(nsHTMLSharedListElement,
+                                                  nsIDOMHTMLOListElement)
+  NS_OFFSET_AND_INTERFACE_TABLE_END
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE_AMBIGUOUS(nsHTMLSharedListElement,
+                                                         nsGenericHTMLElement,
+                                                         nsIDOMHTMLOListElement)
   NS_INTERFACE_MAP_ENTRY_IF_TAG(nsIDOMHTMLOListElement, ol)
   NS_INTERFACE_MAP_ENTRY_IF_TAG(nsIDOMHTMLDListElement, dl)
   NS_INTERFACE_MAP_ENTRY_IF_TAG(nsIDOMHTMLUListElement, ul)
 
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO_IF_TAG(HTMLOListElement, ol)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO_IF_TAG(HTMLDListElement, dl)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO_IF_TAG(HTMLUListElement, ul)
 NS_HTML_CONTENT_INTERFACE_MAP_END
diff -r 4f1383af8f10 content/html/content/src/nsHTMLObjectElement.cpp
--- a/content/html/content/src/nsHTMLObjectElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLObjectElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -173,33 +173,34 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsHTMLObjectElement,
                                                   nsGenericHTMLFormElement)
   tmp->Traverse(cb);
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLObjectElement, nsGenericElement) 
 NS_IMPL_RELEASE_INHERITED(nsHTMLObjectElement, nsGenericElement) 
 
-NS_HTML_CONTENT_CC_INTERFACE_TABLE_HEAD(nsHTMLObjectElement,
-                                        nsGenericHTMLFormElement)
-  NS_INTERFACE_TABLE_BEGIN
+NS_INTERFACE_TABLE_HEAD_CYCLE_COLLECTION_INHERITED(nsHTMLObjectElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_BEGIN(nsHTMLObjectElement)
     NS_INTERFACE_TABLE_ENTRY(nsHTMLObjectElement, nsIDOMHTMLObjectElement)
     NS_INTERFACE_TABLE_ENTRY(nsHTMLObjectElement, imgIDecoderObserver)
     NS_INTERFACE_TABLE_ENTRY(nsHTMLObjectElement, nsIRequestObserver)
     NS_INTERFACE_TABLE_ENTRY(nsHTMLObjectElement, nsIStreamListener)
     NS_INTERFACE_TABLE_ENTRY(nsHTMLObjectElement, nsIFrameLoaderOwner)
     NS_INTERFACE_TABLE_ENTRY(nsHTMLObjectElement, nsIObjectLoadingContent)
     NS_INTERFACE_TABLE_ENTRY(nsHTMLObjectElement, nsIImageLoadingContent)
     NS_INTERFACE_TABLE_ENTRY(nsHTMLObjectElement, imgIContainerObserver)
     NS_INTERFACE_TABLE_ENTRY(nsHTMLObjectElement, nsIInterfaceRequestor)
     NS_INTERFACE_TABLE_ENTRY(nsHTMLObjectElement, nsIChannelEventSink)
 #ifdef MOZ_SVG
     NS_INTERFACE_TABLE_ENTRY(nsHTMLObjectElement, nsIDOMGetSVGDocument)
 #endif
-  NS_INTERFACE_TABLE_END
+  NS_OFFSET_AND_INTERFACE_TABLE_END
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLObjectElement,
+                                               nsGenericHTMLFormElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLObjectElement)
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLObjectElement)
 
 
 NS_IMETHODIMP
 nsHTMLObjectElement::GetForm(nsIDOMHTMLFormElement **aForm)
 {
diff -r 4f1383af8f10 content/html/content/src/nsHTMLOptGroupElement.cpp
--- a/content/html/content/src/nsHTMLOptGroupElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLOptGroupElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -110,20 +110,21 @@ nsHTMLOptGroupElement::~nsHTMLOptGroupEl
 }
 
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLOptGroupElement, nsGenericElement)
 NS_IMPL_RELEASE_INHERITED(nsHTMLOptGroupElement, nsGenericElement)
 
 
 // QueryInterface implementation for nsHTMLOptGroupElement
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLOptGroupElement,
-                                     nsGenericHTMLElement)
-  NS_INTERFACE_TABLE_INHERITED1(nsHTMLOptGroupElement,
-                                nsIDOMHTMLOptGroupElement)
+NS_INTERFACE_TABLE_HEAD(nsHTMLOptGroupElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE1(nsHTMLOptGroupElement,
+                                   nsIDOMHTMLOptGroupElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLOptGroupElement,
+                                               nsGenericHTMLElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLOptGroupElement)
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLOptGroupElement)
 
 
 NS_IMPL_BOOL_ATTR(nsHTMLOptGroupElement, Disabled, disabled)
 NS_IMPL_STRING_ATTR(nsHTMLOptGroupElement, Label, label)
diff -r 4f1383af8f10 content/html/content/src/nsHTMLOptionElement.cpp
--- a/content/html/content/src/nsHTMLOptionElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLOptionElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -174,23 +174,24 @@ nsHTMLOptionElement::~nsHTMLOptionElemen
 // ISupports
 
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLOptionElement, nsGenericElement)
 NS_IMPL_RELEASE_INHERITED(nsHTMLOptionElement, nsGenericElement)
 
 
 // QueryInterface implementation for nsHTMLOptionElement
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLOptionElement,
-                                     nsGenericHTMLElement)
-  NS_INTERFACE_TABLE_INHERITED4(nsHTMLOptionElement,
-                                nsIDOMHTMLOptionElement,
-                                nsIDOMNSHTMLOptionElement,
-                                nsIJSNativeInitializer,
-                                nsIOptionElement)
+NS_INTERFACE_TABLE_HEAD(nsHTMLOptionElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE4(nsHTMLOptionElement,
+                                   nsIDOMHTMLOptionElement,
+                                   nsIDOMNSHTMLOptionElement,
+                                   nsIJSNativeInitializer,
+                                   nsIOptionElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLOptionElement,
+                                               nsGenericHTMLElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLOptionElement)
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLOptionElement)
 
 
 NS_IMETHODIMP
 nsHTMLOptionElement::GetForm(nsIDOMHTMLFormElement** aForm)
diff -r 4f1383af8f10 content/html/content/src/nsHTMLParagraphElement.cpp
--- a/content/html/content/src/nsHTMLParagraphElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLParagraphElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -92,20 +92,21 @@ nsHTMLParagraphElement::~nsHTMLParagraph
 }
 
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLParagraphElement, nsGenericElement)
 NS_IMPL_RELEASE_INHERITED(nsHTMLParagraphElement, nsGenericElement)
 
 
 // QueryInterface implementation for nsHTMLParagraphElement
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLParagraphElement,
-                                     nsGenericHTMLElement)
-  NS_INTERFACE_TABLE_INHERITED1(nsHTMLParagraphElement,
-                                nsIDOMHTMLParagraphElement)
+NS_INTERFACE_TABLE_HEAD(nsHTMLParagraphElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE1(nsHTMLParagraphElement,
+                                   nsIDOMHTMLParagraphElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLParagraphElement,
+                                               nsGenericHTMLElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLParagraphElement)
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLParagraphElement)
 
 
 NS_IMPL_STRING_ATTR(nsHTMLParagraphElement, Align, align)
 
diff -r 4f1383af8f10 content/html/content/src/nsHTMLPreElement.cpp
--- a/content/html/content/src/nsHTMLPreElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLPreElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -94,18 +94,20 @@ nsHTMLPreElement::~nsHTMLPreElement()
 }
 
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLPreElement, nsGenericElement)
 NS_IMPL_RELEASE_INHERITED(nsHTMLPreElement, nsGenericElement)
 
 
 // QueryInterface implementation for nsHTMLPreElement
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLPreElement, nsGenericHTMLElement)
-  NS_INTERFACE_TABLE_INHERITED1(nsHTMLPreElement, nsIDOMHTMLPreElement)
+NS_INTERFACE_TABLE_HEAD(nsHTMLPreElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE1(nsHTMLPreElement, nsIDOMHTMLPreElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLPreElement,
+                                               nsGenericHTMLElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLPreElement)
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLPreElement)
 
 
 NS_IMPL_INT_ATTR(nsHTMLPreElement, Width, width)
 
diff -r 4f1383af8f10 content/html/content/src/nsHTMLScriptElement.cpp
--- a/content/html/content/src/nsHTMLScriptElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLScriptElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -380,23 +380,24 @@ nsHTMLScriptElement::~nsHTMLScriptElemen
 {
 }
 
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLScriptElement, nsGenericElement)
 NS_IMPL_RELEASE_INHERITED(nsHTMLScriptElement, nsGenericElement)
 
 // QueryInterface implementation for nsHTMLScriptElement
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLScriptElement, nsGenericHTMLElement)
-  NS_INTERFACE_TABLE_INHERITED4(nsHTMLScriptElement,
-                                nsIDOMHTMLScriptElement,
-                                nsIScriptLoaderObserver,
-                                nsIScriptElement,
-                                nsIMutationObserver)
-  NS_INTERFACE_TABLE_TO_MAP_SEGUE
+NS_INTERFACE_TABLE_HEAD(nsHTMLScriptElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE4(nsHTMLScriptElement,
+                                   nsIDOMHTMLScriptElement,
+                                   nsIScriptLoaderObserver,
+                                   nsIScriptElement,
+                                   nsIMutationObserver)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLScriptElement,
+                                               nsGenericHTMLElement)
   if (mScriptEventHandler && aIID.Equals(NS_GET_IID(nsIScriptEventHandler)))
     foundInterface = static_cast<nsIScriptEventHandler*>
                                 (mScriptEventHandler);
   else
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(HTMLScriptElement)
 NS_HTML_CONTENT_INTERFACE_MAP_END
 
 
diff -r 4f1383af8f10 content/html/content/src/nsHTMLSelectElement.cpp
--- a/content/html/content/src/nsHTMLSelectElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLSelectElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -166,23 +166,24 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_
                                                        nsIDOMHTMLCollection)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLSelectElement, nsGenericElement)
 NS_IMPL_RELEASE_INHERITED(nsHTMLSelectElement, nsGenericElement)
 
 
 // QueryInterface implementation for nsHTMLSelectElement
-NS_HTML_CONTENT_CC_INTERFACE_TABLE_HEAD(nsHTMLSelectElement,
-                                        nsGenericHTMLFormElement)
-  NS_INTERFACE_TABLE_INHERITED4(nsHTMLSelectElement,
-                                nsIDOMHTMLSelectElement,
-                                nsIDOMNSHTMLSelectElement,
-                                nsIDOMNSXBLFormControl,
-                                nsISelectElement)
+NS_INTERFACE_TABLE_HEAD_CYCLE_COLLECTION_INHERITED(nsHTMLSelectElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE4(nsHTMLSelectElement,
+                                   nsIDOMHTMLSelectElement,
+                                   nsIDOMNSHTMLSelectElement,
+                                   nsIDOMNSXBLFormControl,
+                                   nsISelectElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLSelectElement,
+                                               nsGenericHTMLFormElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLSelectElement)
 
 
 // nsIDOMHTMLSelectElement
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLSelectElement)
 
diff -r 4f1383af8f10 content/html/content/src/nsHTMLSharedElement.cpp
--- a/content/html/content/src/nsHTMLSharedElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLSharedElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -122,20 +122,23 @@ nsHTMLSharedElement::~nsHTMLSharedElemen
 }
 
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLSharedElement, nsGenericElement)
 NS_IMPL_RELEASE_INHERITED(nsHTMLSharedElement, nsGenericElement)
 
 
 // QueryInterface implementation for nsHTMLSharedElement
-NS_HTML_CONTENT_INTERFACE_TABLE_AMBIGOUS_HEAD(nsHTMLSharedElement,
-                                              nsGenericHTMLElement,
-                                              nsIDOMHTMLParamElement)
-  NS_INTERFACE_TABLE_TO_MAP_SEGUE
+NS_INTERFACE_TABLE_HEAD(nsHTMLSharedElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_AMBIGUOUS_BEGIN(nsHTMLSharedElement,
+                                                  nsIDOMHTMLParamElement)
+  NS_OFFSET_AND_INTERFACE_TABLE_END
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE_AMBIGUOUS(nsHTMLSharedElement,
+                                                         nsGenericHTMLElement,
+                                                         nsIDOMHTMLParamElement)
   NS_INTERFACE_MAP_ENTRY_IF_TAG(nsIDOMHTMLParamElement, param)
   NS_INTERFACE_MAP_ENTRY_IF_TAG(nsIDOMHTMLIsIndexElement, isindex)
   NS_INTERFACE_MAP_ENTRY_IF_TAG(nsIDOMHTMLBaseElement, base)
   NS_INTERFACE_MAP_ENTRY_IF_TAG(nsIDOMHTMLDirectoryElement, dir)
   NS_INTERFACE_MAP_ENTRY_IF_TAG(nsIDOMHTMLMenuElement, menu)
   NS_INTERFACE_MAP_ENTRY_IF_TAG(nsIDOMHTMLQuoteElement, q)
   NS_INTERFACE_MAP_ENTRY_IF_TAG(nsIDOMHTMLQuoteElement, blockquote)
   NS_INTERFACE_MAP_ENTRY_IF_TAG(nsIDOMHTMLBaseFontElement, basefont)
diff -r 4f1383af8f10 content/html/content/src/nsHTMLSharedObjectElement.cpp
--- a/content/html/content/src/nsHTMLSharedObjectElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLSharedObjectElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -205,30 +205,32 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsHTMLSharedObjectElement,
                                                   nsGenericHTMLElement)
   tmp->Traverse(cb);
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLSharedObjectElement, nsGenericElement) 
 NS_IMPL_RELEASE_INHERITED(nsHTMLSharedObjectElement, nsGenericElement) 
 
-NS_HTML_CONTENT_CC_INTERFACE_TABLE_AMBIGUOUS_HEAD(nsHTMLSharedObjectElement,
-                                                  nsGenericHTMLElement,
+NS_INTERFACE_TABLE_HEAD_CYCLE_COLLECTION_INHERITED(nsHTMLSharedObjectElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_AMBIGUOUS_BEGIN(nsHTMLSharedObjectElement,
                                                   nsIDOMHTMLAppletElement)
-  NS_INTERFACE_TABLE_INHERITED9(nsHTMLSharedObjectElement,
-                                nsIRequestObserver,
-                                nsIStreamListener,
-                                nsIFrameLoaderOwner,
-                                imgIContainerObserver,
-                                nsIObjectLoadingContent,
-                                imgIDecoderObserver,
-                                nsIImageLoadingContent,
-                                nsIInterfaceRequestor,
-                                nsIChannelEventSink)
-  NS_INTERFACE_TABLE_TO_MAP_SEGUE
+    NS_INTERFACE_TABLE_ENTRY(nsHTMLSharedObjectElement, nsIRequestObserver)
+    NS_INTERFACE_TABLE_ENTRY(nsHTMLSharedObjectElement, nsIStreamListener)
+    NS_INTERFACE_TABLE_ENTRY(nsHTMLSharedObjectElement, nsIFrameLoaderOwner)
+    NS_INTERFACE_TABLE_ENTRY(nsHTMLSharedObjectElement, imgIContainerObserver)
+    NS_INTERFACE_TABLE_ENTRY(nsHTMLSharedObjectElement, nsIObjectLoadingContent)
+    NS_INTERFACE_TABLE_ENTRY(nsHTMLSharedObjectElement, imgIDecoderObserver)
+    NS_INTERFACE_TABLE_ENTRY(nsHTMLSharedObjectElement, nsIImageLoadingContent)
+    NS_INTERFACE_TABLE_ENTRY(nsHTMLSharedObjectElement, nsIInterfaceRequestor)
+    NS_INTERFACE_TABLE_ENTRY(nsHTMLSharedObjectElement, nsIChannelEventSink)
+  NS_OFFSET_AND_INTERFACE_TABLE_END
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE_AMBIGUOUS(nsHTMLSharedObjectElement,
+                                                         nsGenericHTMLElement,
+                                                         nsIDOMHTMLAppletElement)
   NS_INTERFACE_MAP_ENTRY_IF_TAG(nsIDOMHTMLAppletElement, applet)
   NS_INTERFACE_MAP_ENTRY_IF_TAG(nsIDOMHTMLEmbedElement, embed)
 #ifdef MOZ_SVG
   NS_INTERFACE_MAP_ENTRY_IF_TAG(nsIDOMGetSVGDocument, embed)
 #endif
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO_IF_TAG(HTMLAppletElement, applet)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO_IF_TAG(HTMLEmbedElement, embed)
 NS_HTML_CONTENT_INTERFACE_MAP_END
diff -r 4f1383af8f10 content/html/content/src/nsHTMLSourceElement.cpp
--- a/content/html/content/src/nsHTMLSourceElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLSourceElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -87,18 +87,20 @@ nsHTMLSourceElement::~nsHTMLSourceElemen
 }
 
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLSourceElement, nsGenericElement)
 NS_IMPL_RELEASE_INHERITED(nsHTMLSourceElement, nsGenericElement)
 
 
 // QueryInterface implementation for nsHTMLSourceElement
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLSourceElement, nsGenericHTMLElement)
-  NS_INTERFACE_TABLE_INHERITED1(nsHTMLSourceElement, nsIDOMHTMLSourceElement)
+NS_INTERFACE_TABLE_HEAD(nsHTMLSourceElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE1(nsHTMLSourceElement, nsIDOMHTMLSourceElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLSourceElement,
+                                               nsGenericHTMLElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLSourceElement)
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLSourceElement)
 
 
 NS_IMPL_URI_ATTR(nsHTMLSourceElement, Src, src)
 NS_IMPL_STRING_ATTR(nsHTMLSourceElement, Type, type)
diff -r 4f1383af8f10 content/html/content/src/nsHTMLSpanElement.cpp
--- a/content/html/content/src/nsHTMLSpanElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLSpanElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -82,17 +82,20 @@ nsHTMLSpanElement::~nsHTMLSpanElement()
 }
 
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLSpanElement, nsGenericElement)
 NS_IMPL_RELEASE_INHERITED(nsHTMLSpanElement, nsGenericElement)
 
 
 // QueryInterface implementation for nsHTMLSpanElement
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLSpanElement, nsGenericHTMLElement)
+NS_INTERFACE_TABLE_HEAD(nsHTMLSpanElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE0(nsHTMLSpanElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLSpanElement,
+                                               nsGenericHTMLElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLSpanElement)
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLSpanElement)
 
 
 nsresult
 nsHTMLSpanElement::GetInnerHTML(nsAString& aInnerHTML)
diff -r 4f1383af8f10 content/html/content/src/nsHTMLStyleElement.cpp
--- a/content/html/content/src/nsHTMLStyleElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLStyleElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -132,22 +132,24 @@ nsHTMLStyleElement::~nsHTMLStyleElement(
 }
 
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLStyleElement, nsGenericElement) 
 NS_IMPL_RELEASE_INHERITED(nsHTMLStyleElement, nsGenericElement) 
 
 
 // QueryInterface implementation for nsHTMLStyleElement
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLStyleElement, nsGenericHTMLElement)
-  NS_INTERFACE_TABLE_INHERITED4(nsHTMLStyleElement,
-                                nsIDOMHTMLStyleElement,
-                                nsIDOMLinkStyle,
-                                nsIStyleSheetLinkingElement,
-                                nsIMutationObserver)
+NS_INTERFACE_TABLE_HEAD(nsHTMLStyleElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE4(nsHTMLStyleElement,
+                                   nsIDOMHTMLStyleElement,
+                                   nsIDOMLinkStyle,
+                                   nsIStyleSheetLinkingElement,
+                                   nsIMutationObserver)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLStyleElement,
+                                               nsGenericHTMLElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLStyleElement)
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLStyleElement)
 
 
 NS_IMETHODIMP
 nsHTMLStyleElement::GetDisabled(PRBool* aDisabled)
diff -r 4f1383af8f10 content/html/content/src/nsHTMLTableCaptionElement.cpp
--- a/content/html/content/src/nsHTMLTableCaptionElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLTableCaptionElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -89,20 +89,21 @@ nsHTMLTableCaptionElement::~nsHTMLTableC
 }
 
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLTableCaptionElement, nsGenericElement)
 NS_IMPL_RELEASE_INHERITED(nsHTMLTableCaptionElement, nsGenericElement)
 
 
 // QueryInterface implementation for nsHTMLTableCaptionElement
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLTableCaptionElement,
-                                     nsGenericHTMLElement)
-  NS_INTERFACE_TABLE_INHERITED1(nsHTMLTableCaptionElement,
-                                nsIDOMHTMLTableCaptionElement)
+NS_INTERFACE_TABLE_HEAD(nsHTMLTableCaptionElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE1(nsHTMLTableCaptionElement,
+                                   nsIDOMHTMLTableCaptionElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLTableCaptionElement,
+                                               nsGenericHTMLElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLTableCaptionElement)
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLTableCaptionElement)
 
 
 NS_IMPL_STRING_ATTR(nsHTMLTableCaptionElement, Align, align)
 
diff -r 4f1383af8f10 content/html/content/src/nsHTMLTableCellElement.cpp
--- a/content/html/content/src/nsHTMLTableCellElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLTableCellElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -100,20 +100,21 @@ nsHTMLTableCellElement::~nsHTMLTableCell
 }
 
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLTableCellElement, nsGenericElement) 
 NS_IMPL_RELEASE_INHERITED(nsHTMLTableCellElement, nsGenericElement) 
 
 
 // QueryInterface implementation for nsHTMLTableCellElement
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLTableCellElement,
-                                     nsGenericHTMLElement)
-  NS_INTERFACE_TABLE_INHERITED1(nsHTMLTableCellElement,
-                                nsIDOMHTMLTableCellElement)
+NS_INTERFACE_TABLE_HEAD(nsHTMLTableCellElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE1(nsHTMLTableCellElement,
+                                   nsIDOMHTMLTableCellElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLTableCellElement,
+                                               nsGenericHTMLElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLTableCellElement)
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLTableCellElement)
 
 
 // protected method
 void
diff -r 4f1383af8f10 content/html/content/src/nsHTMLTableColElement.cpp
--- a/content/html/content/src/nsHTMLTableColElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLTableColElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -93,20 +93,21 @@ nsHTMLTableColElement::~nsHTMLTableColEl
 }
 
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLTableColElement, nsGenericElement) 
 NS_IMPL_RELEASE_INHERITED(nsHTMLTableColElement, nsGenericElement) 
 
 
 // QueryInterface implementation for nsHTMLTableColElement
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLTableColElement,
-                                    nsGenericHTMLElement)
-  NS_INTERFACE_TABLE_INHERITED1(nsHTMLTableColElement,
-                                nsIDOMHTMLTableColElement)
+NS_INTERFACE_TABLE_HEAD(nsHTMLTableColElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE1(nsHTMLTableColElement,
+                                   nsIDOMHTMLTableColElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLTableColElement,
+                                               nsGenericHTMLElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLTableColElement)
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLTableColElement)
 
 
 NS_IMPL_STRING_ATTR_DEFAULT_VALUE(nsHTMLTableColElement, Align, align, "left")
 NS_IMPL_STRING_ATTR_DEFAULT_VALUE(nsHTMLTableColElement, Ch, _char, ".")
 NS_IMPL_STRING_ATTR(nsHTMLTableColElement, ChOff, charoff)
diff -r 4f1383af8f10 content/html/content/src/nsHTMLTableElement.cpp
--- a/content/html/content/src/nsHTMLTableElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLTableElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -404,19 +404,20 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mRows)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLTableElement, nsGenericElement) 
 NS_IMPL_RELEASE_INHERITED(nsHTMLTableElement, nsGenericElement) 
 
 
 // QueryInterface implementation for nsHTMLTableElement
-NS_HTML_CONTENT_CC_INTERFACE_TABLE_HEAD(nsHTMLTableElement,
-                                        nsGenericHTMLElement)
-  NS_INTERFACE_TABLE_INHERITED1(nsHTMLTableElement, nsIDOMHTMLTableElement)
+NS_INTERFACE_TABLE_HEAD_CYCLE_COLLECTION_INHERITED(nsHTMLTableElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE1(nsHTMLTableElement, nsIDOMHTMLTableElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLTableElement,
+                                               nsGenericHTMLElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLTableElement)
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLTableElement)
 
 
 // the DOM spec says border, cellpadding, cellSpacing are all "wstring"
 // in fact, they are integers or they are meaningless.  so we store them
diff -r 4f1383af8f10 content/html/content/src/nsHTMLTableRowElement.cpp
--- a/content/html/content/src/nsHTMLTableRowElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLTableRowElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -104,20 +104,21 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_
                                                        nsIDOMNodeList)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLTableRowElement, nsGenericElement) 
 NS_IMPL_RELEASE_INHERITED(nsHTMLTableRowElement, nsGenericElement) 
 
 
 // QueryInterface implementation for nsHTMLTableRowElement
-NS_HTML_CONTENT_CC_INTERFACE_TABLE_HEAD(nsHTMLTableRowElement,
-                                        nsGenericHTMLElement)
-  NS_INTERFACE_TABLE_INHERITED1(nsHTMLTableRowElement,
-                                nsIDOMHTMLTableRowElement)
+NS_INTERFACE_TABLE_HEAD_CYCLE_COLLECTION_INHERITED(nsHTMLTableRowElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE1(nsHTMLTableRowElement,
+                                   nsIDOMHTMLTableRowElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLTableRowElement,
+                                               nsGenericHTMLElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLTableRowElement)
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLTableRowElement)
 
 
 // protected method
 nsresult
diff -r 4f1383af8f10 content/html/content/src/nsHTMLTableSectionElement.cpp
--- a/content/html/content/src/nsHTMLTableSectionElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLTableSectionElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -102,20 +102,21 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_
                                                        nsIDOMNodeList)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLTableSectionElement, nsGenericElement) 
 NS_IMPL_RELEASE_INHERITED(nsHTMLTableSectionElement, nsGenericElement) 
 
 
 // QueryInterface implementation for nsHTMLTableSectionElement
-NS_HTML_CONTENT_CC_INTERFACE_TABLE_HEAD(nsHTMLTableSectionElement,
-                                        nsGenericHTMLElement)
-  NS_INTERFACE_TABLE_INHERITED1(nsHTMLTableSectionElement,
-                                nsIDOMHTMLTableSectionElement)
+NS_INTERFACE_TABLE_HEAD_CYCLE_COLLECTION_INHERITED(nsHTMLTableSectionElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE1(nsHTMLTableSectionElement,
+                                   nsIDOMHTMLTableSectionElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLTableSectionElement,
+                                               nsGenericHTMLElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLTableSectionElement)
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLTableSectionElement)
 
 
 NS_IMPL_STRING_ATTR_DEFAULT_VALUE(nsHTMLTableSectionElement, Align, align, "left")
 NS_IMPL_STRING_ATTR_DEFAULT_VALUE(nsHTMLTableSectionElement, VAlign, valign, "middle")
diff -r 4f1383af8f10 content/html/content/src/nsHTMLTextAreaElement.cpp
--- a/content/html/content/src/nsHTMLTextAreaElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLTextAreaElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -252,24 +252,25 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mControllers)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLTextAreaElement, nsGenericElement) 
 NS_IMPL_RELEASE_INHERITED(nsHTMLTextAreaElement, nsGenericElement) 
 
 
 // QueryInterface implementation for nsHTMLTextAreaElement
-NS_HTML_CONTENT_CC_INTERFACE_TABLE_HEAD(nsHTMLTextAreaElement,
-                                        nsGenericHTMLFormElement)
-  NS_INTERFACE_TABLE_INHERITED5(nsHTMLTextAreaElement,
-                                nsIDOMHTMLTextAreaElement,
-                                nsIDOMNSHTMLTextAreaElement,
-                                nsITextControlElement,
-                                nsIDOMNSEditableElement,
-                                nsIMutationObserver)
+NS_INTERFACE_TABLE_HEAD_CYCLE_COLLECTION_INHERITED(nsHTMLTextAreaElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE5(nsHTMLTextAreaElement,
+                                   nsIDOMHTMLTextAreaElement,
+                                   nsIDOMNSHTMLTextAreaElement,
+                                   nsITextControlElement,
+                                   nsIDOMNSEditableElement,
+                                   nsIMutationObserver)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLTextAreaElement,
+                                               nsGenericHTMLFormElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLTextAreaElement)
 
 
 // nsIDOMHTMLTextAreaElement
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLTextAreaElement)
 
diff -r 4f1383af8f10 content/html/content/src/nsHTMLTitleElement.cpp
--- a/content/html/content/src/nsHTMLTitleElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLTitleElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -105,20 +105,22 @@ nsHTMLTitleElement::~nsHTMLTitleElement(
 }
 
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLTitleElement, nsGenericElement) 
 NS_IMPL_RELEASE_INHERITED(nsHTMLTitleElement, nsGenericElement) 
 
 
 // QueryInterface implementation for nsHTMLTitleElement
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLTitleElement, nsGenericHTMLElement)
-  NS_INTERFACE_TABLE_INHERITED2(nsHTMLTitleElement,
-                                nsIDOMHTMLTitleElement,
-                                nsIMutationObserver)
+NS_INTERFACE_TABLE_HEAD(nsHTMLTitleElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE2(nsHTMLTitleElement,
+                                   nsIDOMHTMLTitleElement,
+                                   nsIMutationObserver)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLTitleElement,
+                                               nsGenericHTMLElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLTitleElement)
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLTitleElement)
 
 
 NS_IMETHODIMP 
 nsHTMLTitleElement::GetText(nsAString& aTitle)
diff -r 4f1383af8f10 content/html/content/src/nsHTMLVideoElement.cpp
--- a/content/html/content/src/nsHTMLVideoElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/src/nsHTMLVideoElement.cpp	Mon Nov 03 05:09:07 2008 -0500
@@ -68,18 +68,20 @@
 #include "nsIDOMProgressEvent.h"
 #include "nsHTMLMediaError.h"
 
 NS_IMPL_NS_NEW_HTML_ELEMENT_CHECK_PARSER(Video)
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLVideoElement, nsHTMLMediaElement)
 NS_IMPL_RELEASE_INHERITED(nsHTMLVideoElement, nsHTMLMediaElement)
 
-NS_HTML_CONTENT_INTERFACE_TABLE_HEAD(nsHTMLVideoElement, nsHTMLMediaElement)
-  NS_INTERFACE_TABLE_INHERITED1(nsHTMLVideoElement, nsIDOMHTMLVideoElement)
+NS_INTERFACE_TABLE_HEAD(nsHTMLVideoElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE1(nsHTMLVideoElement, nsIDOMHTMLVideoElement)
+  NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLVideoElement,
+                                               nsHTMLMediaElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLVideoElement)
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLVideoElement)
 
 // nsIDOMHTMLVideoElement
 NS_IMPL_INT_ATTR(nsHTMLVideoElement, Width, width)
 NS_IMPL_INT_ATTR(nsHTMLVideoElement, Height, height)
 NS_IMPL_URI_ATTR(nsHTMLVideoElement, Poster, poster)
diff -r 4f1383af8f10 content/html/content/test/Makefile.in
--- a/content/html/content/test/Makefile.in	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/content/test/Makefile.in	Mon Nov 03 05:09:08 2008 -0500
@@ -94,16 +94,17 @@ _TEST_FILES = 	test_bug589.html \
 		test_bug375003-1.html \
 		test_bug375003-2.html \
 		test_bug384419.html \
 		test_bug386496.html \
 		test_bug386728.html \
 		test_bug386996.html \
 		test_bug388558.html \
 		test_bug388746.html \
+		test_bug388794.html \
 		test_bug389797.html \
 		test_bug390975.html \
 		test_bug391994.html \
 		test_bug392567.html \
 		bug392567.jar       \
 		bug392567.jar^headers^ \
 		test_bug394700.html \
 		test_bug395107.html \
diff -r 4f1383af8f10 content/html/content/test/test_bug388794.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/html/content/test/test_bug388794.html	Mon Nov 03 05:09:08 2008 -0500
@@ -0,0 +1,97 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=388794
+-->
+<head>
+  <title>Test for Bug 388794</title>
+  <script type="application/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <script type="application/javascript" src="/tests/SimpleTest/EventUtils.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
+  <style>
+    input { padding: 0; margin: 0; border: none; }
+  </style>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=388794">Mozilla Bug 388794</a>
+<p id="display">
+  <form action="data:text/html," target="test1" method="GET">
+    <input id="test1image" type="image" name="testImage">
+  </form>
+  <form action="data:text/html," target="test2" method="GET">
+    <input id="test2image" type="image">
+  </form>
+  <form action="data:text/html," target="test3" method="GET">
+    <input id="test3image" type="image" src="nnc_lockup.gif" name="testImage">
+  </form>
+  <form action="data:text/html," target="test4" method="GET">
+    <input id="test4image" type="image" src="nnc_lockup.gif">
+  </form>
+  <form action="data:text/html," target="test5" method="GET">
+    <input id="test5image" type="image" src="nnc_lockup.gif" name="testImage">
+  </form>
+  <form action="data:text/html," target="test6" method="GET">
+    <input id="test6image" type="image" src="nnc_lockup.gif">
+  </form>
+  <iframe name="test1" id="test1"></iframe>
+  <iframe name="test2" id="test2"></iframe>
+  <iframe name="test3" id="test3"></iframe>
+  <iframe name="test4" id="test4"></iframe>
+  <iframe name="test5" id="test5"></iframe>
+  <iframe name="test6" id="test6"></iframe>
+</p>
+<div id="content" style="display: none">
+  
+</div>
+<pre id="test">
+<script type="application/javascript">
+
+/** Test for Bug 388794 **/
+SimpleTest.waitForExplicitFinish();
+
+var pendingLoads = 0;
+
+var hrefs = {
+  test1: "data:text/html,?testImage.x=0&testImage.y=0",
+  test2: "data:text/html,?x=0&y=0",
+  test3: "data:text/html,?testImage.x=0&testImage.y=0",
+  test4: "data:text/html,?x=0&y=0",
+  test5: "data:text/html,?testImage.x=5&testImage.y=5",
+  test6: "data:text/html,?x=5&y=5",
+};
+
+function submitForm(idNum) {
+  $("test"+idNum).setAttribute("onload", "frameLoaded(this)");
+  sendKey("return", "test" + idNum + "image");
+}
+
+function submitFormMouse(idNum) {
+  $("test"+idNum).setAttribute("onload", "frameLoaded(this)");
+  synthesizeMouse($("test" + idNum + "image"), 5, 5, {});
+}
+
+addLoadEvent(function() {
+  // Need the timeout so painting has a chance to be unsuppressed.
+  setTimeout(function() {
+    submitForm(++pendingLoads);
+    submitForm(++pendingLoads);
+    submitForm(++pendingLoads);
+    submitForm(++pendingLoads);
+    submitFormMouse(++pendingLoads);
+    submitFormMouse(++pendingLoads);
+  }, 0);
+});
+
+function frameLoaded(frame) {
+  is(frame.contentWindow.location.href, hrefs[frame.name],
+     "Unexpected href for frame " + frame.name);
+  if (--pendingLoads == 0) {
+    SimpleTest.finish();
+  }
+}
+
+</script>
+</pre>
+</body>
+</html>
diff -r 4f1383af8f10 content/html/document/src/nsHTMLDocument.cpp
--- a/content/html/document/src/nsHTMLDocument.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/document/src/nsHTMLDocument.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -248,21 +248,22 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLDocument, nsDocument)
 NS_IMPL_RELEASE_INHERITED(nsHTMLDocument, nsDocument)
 
 
 // QueryInterface implementation for nsHTMLDocument
 NS_INTERFACE_TABLE_HEAD_CYCLE_COLLECTION_INHERITED(nsHTMLDocument)
-  NS_INTERFACE_TABLE_INHERITED3(nsHTMLDocument,
-                                nsIHTMLDocument,
-                                nsIDOMHTMLDocument,
-                                nsIDOMNSHTMLDocument)
-  NS_INTERFACE_TABLE_TO_MAP_SEGUE
+  NS_DOCUMENT_INTERFACE_TABLE_BEGIN(nsHTMLDocument)
+    NS_INTERFACE_TABLE_ENTRY(nsHTMLDocument, nsIHTMLDocument)
+    NS_INTERFACE_TABLE_ENTRY(nsHTMLDocument, nsIDOMHTMLDocument)
+    NS_INTERFACE_TABLE_ENTRY(nsHTMLDocument, nsIDOMNSHTMLDocument)
+  NS_OFFSET_AND_INTERFACE_TABLE_END
+  NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(HTMLDocument)
 NS_INTERFACE_MAP_END_INHERITING(nsDocument)
 
 
 nsresult
 nsHTMLDocument::Init()
 {
   nsresult rv = nsDocument::Init();
diff -r 4f1383af8f10 content/html/document/src/nsHTMLDocument.h
--- a/content/html/document/src/nsHTMLDocument.h	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/document/src/nsHTMLDocument.h	Mon Nov 03 05:09:08 2008 -0500
@@ -368,9 +368,15 @@ protected:
 
   // When false, the .cookies property is completely disabled
   PRBool mDisableCookieAccess;
 
   // Parser used for constructing document fragments.
   nsCOMPtr<nsIParser> mFragmentParser;
 };
 
+#define NS_HTML_DOCUMENT_INTERFACE_TABLE_BEGIN(_class)                        \
+    NS_DOCUMENT_INTERFACE_TABLE_BEGIN(_class)                                 \
+    NS_INTERFACE_TABLE_ENTRY(_class, nsIHTMLDocument)                         \
+    NS_INTERFACE_TABLE_ENTRY(_class, nsIDOMHTMLDocument)                      \
+    NS_INTERFACE_TABLE_ENTRY(_class, nsIDOMNSHTMLDocument)
+
 #endif /* nsHTMLDocument_h___ */
diff -r 4f1383af8f10 content/html/document/src/nsImageDocument.cpp
--- a/content/html/document/src/nsImageDocument.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/html/document/src/nsImageDocument.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -273,22 +273,23 @@ nsImageDocument::~nsImageDocument()
 }
 
 // XXXbz shouldn't this participate in cycle collection?  It's got
 // mImageContent!
 NS_IMPL_ADDREF_INHERITED(nsImageDocument, nsMediaDocument)
 NS_IMPL_RELEASE_INHERITED(nsImageDocument, nsMediaDocument)
 
 NS_INTERFACE_TABLE_HEAD(nsImageDocument)
-  NS_INTERFACE_TABLE_INHERITED4(nsImageDocument,
-                                nsIImageDocument,
-                                imgIDecoderObserver,
-                                imgIContainerObserver,
-                                nsIDOMEventListener)
-  NS_INTERFACE_TABLE_TO_MAP_SEGUE
+  NS_HTML_DOCUMENT_INTERFACE_TABLE_BEGIN(nsImageDocument)
+    NS_INTERFACE_TABLE_ENTRY(nsImageDocument, nsIImageDocument)
+    NS_INTERFACE_TABLE_ENTRY(nsImageDocument, imgIDecoderObserver)
+    NS_INTERFACE_TABLE_ENTRY(nsImageDocument, imgIContainerObserver)
+    NS_INTERFACE_TABLE_ENTRY(nsImageDocument, nsIDOMEventListener)
+  NS_OFFSET_AND_INTERFACE_TABLE_END
+  NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(ImageDocument)
 NS_INTERFACE_MAP_END_INHERITING(nsMediaDocument)
 
 
 nsresult
 nsImageDocument::Init()
 {
   nsresult rv = nsMediaDocument::Init();
diff -r 4f1383af8f10 content/svg/content/src/nsSVGAElement.cpp
--- a/content/svg/content/src/nsSVGAElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/svg/content/src/nsSVGAElement.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -106,22 +106,19 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(A)
 
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGAElement, nsSVGAElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGAElement, nsSVGAElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGAElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGAElement)
-  NS_INTERFACE_MAP_ENTRY(nsILink)
+NS_INTERFACE_TABLE_HEAD(nsSVGAElement)
+  NS_NODE_INTERFACE_TABLE5(nsSVGAElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement, nsIDOMSVGAElement, nsILink)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGAElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGAElementBase)
 
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsSVGAElement::nsSVGAElement(nsINodeInfo *aNodeInfo)
diff -r 4f1383af8f10 content/svg/content/src/nsSVGCircleElement.cpp
--- a/content/svg/content/src/nsSVGCircleElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/svg/content/src/nsSVGCircleElement.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -87,21 +87,19 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(Circle)
 NS_IMPL_NS_NEW_SVG_ELEMENT(Circle)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGCircleElement,nsSVGCircleElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGCircleElement,nsSVGCircleElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGCircleElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGCircleElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGCircleElement)
+  NS_NODE_INTERFACE_TABLE4(nsSVGCircleElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement, nsIDOMSVGCircleElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGCircleElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGCircleElementBase)
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsSVGCircleElement::nsSVGCircleElement(nsINodeInfo *aNodeInfo)
   : nsSVGCircleElementBase(aNodeInfo)
diff -r 4f1383af8f10 content/svg/content/src/nsSVGClipPathElement.cpp
--- a/content/svg/content/src/nsSVGClipPathElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/svg/content/src/nsSVGClipPathElement.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -48,22 +48,20 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(ClipPath)
 NS_IMPL_NS_NEW_SVG_ELEMENT(ClipPath)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGClipPathElement,nsSVGClipPathElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGClipPathElement,nsSVGClipPathElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGClipPathElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGClipPathElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGUnitTypes)
+NS_INTERFACE_TABLE_HEAD(nsSVGClipPathElement)
+  NS_NODE_INTERFACE_TABLE5(nsSVGClipPathElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement, nsIDOMSVGClipPathElement,
+                           nsIDOMSVGUnitTypes)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGClipPathElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGClipPathElementBase)
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsSVGClipPathElement::nsSVGClipPathElement(nsINodeInfo *aNodeInfo)
   : nsSVGClipPathElementBase(aNodeInfo)
diff -r 4f1383af8f10 content/svg/content/src/nsSVGDefsElement.cpp
--- a/content/svg/content/src/nsSVGDefsElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/svg/content/src/nsSVGDefsElement.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -74,20 +74,19 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(Defs)
 
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGDefsElement,nsSVGDefsElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGDefsElement,nsSVGDefsElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGDefsElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGDefsElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGDefsElement)
+  NS_NODE_INTERFACE_TABLE4(nsSVGDefsElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement, nsIDOMSVGDefsElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGDefsElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGDefsElementBase)
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsSVGDefsElement::nsSVGDefsElement(nsINodeInfo *aNodeInfo)
   : nsSVGDefsElementBase(aNodeInfo)
diff -r 4f1383af8f10 content/svg/content/src/nsSVGDescElement.cpp
--- a/content/svg/content/src/nsSVGDescElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/svg/content/src/nsSVGDescElement.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -68,21 +68,19 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(Desc)
 
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGDescElement, nsSVGDescElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGDescElement, nsSVGDescElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGDescElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGDescElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGDescElement)
+  NS_NODE_INTERFACE_TABLE4(nsSVGDescElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement, nsIDOMSVGDescElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGDescElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGDescElementBase)
 
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsSVGDescElement::nsSVGDescElement(nsINodeInfo *aNodeInfo)
diff -r 4f1383af8f10 content/svg/content/src/nsSVGEllipseElement.cpp
--- a/content/svg/content/src/nsSVGEllipseElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/svg/content/src/nsSVGEllipseElement.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -89,21 +89,19 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(Ellipse)
 NS_IMPL_NS_NEW_SVG_ELEMENT(Ellipse)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGEllipseElement,nsSVGEllipseElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGEllipseElement,nsSVGEllipseElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGEllipseElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGEllipseElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGEllipseElement)
+  NS_NODE_INTERFACE_TABLE4(nsSVGEllipseElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement, nsIDOMSVGEllipseElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGEllipseElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGEllipseElementBase)
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsSVGEllipseElement::nsSVGEllipseElement(nsINodeInfo *aNodeInfo)
   : nsSVGEllipseElementBase(aNodeInfo)
diff -r 4f1383af8f10 content/svg/content/src/nsSVGFilterElement.cpp
--- a/content/svg/content/src/nsSVGFilterElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/svg/content/src/nsSVGFilterElement.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -72,22 +72,20 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(Filter)
 NS_IMPL_NS_NEW_SVG_ELEMENT(Filter)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGFilterElement,nsSVGFilterElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGFilterElement,nsSVGFilterElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGFilterElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFilterElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGURIReference)
+NS_INTERFACE_TABLE_HEAD(nsSVGFilterElement)
+  NS_NODE_INTERFACE_TABLE5(nsSVGFilterElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement, nsIDOMSVGFilterElement,
+                           nsIDOMSVGURIReference)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGFilterElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGFilterElementBase)
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsSVGFilterElement::nsSVGFilterElement(nsINodeInfo *aNodeInfo)
   : nsSVGFilterElementBase(aNodeInfo)
diff -r 4f1383af8f10 content/svg/content/src/nsSVGFilters.cpp
--- a/content/svg/content/src/nsSVGFilters.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/svg/content/src/nsSVGFilters.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -382,22 +382,21 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(FEGaussianBlu
 NS_IMPL_NS_NEW_SVG_ELEMENT(FEGaussianBlur)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGFEGaussianBlurElement,nsSVGFEGaussianBlurElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGFEGaussianBlurElement,nsSVGFEGaussianBlurElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGFEGaussianBlurElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFilterPrimitiveStandardAttributes)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFEGaussianBlurElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGFEGaussianBlurElement)
+  NS_NODE_INTERFACE_TABLE5(nsSVGFEGaussianBlurElement, nsIDOMNode,
+                           nsIDOMElement, nsIDOMSVGElement,
+                           nsIDOMSVGFilterPrimitiveStandardAttributes,
+                           nsIDOMSVGFEGaussianBlurElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGFEGaussianBlurElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGFEGaussianBlurElementBase)
 
 //----------------------------------------------------------------------
 // nsIDOMNode methods
 
 
 NS_IMPL_ELEMENT_CLONE_WITH_INIT(nsSVGFEGaussianBlurElement)
@@ -841,22 +840,21 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(FEBlend)
 NS_IMPL_NS_NEW_SVG_ELEMENT(FEBlend)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGFEBlendElement,nsSVGFEBlendElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGFEBlendElement,nsSVGFEBlendElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGFEBlendElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFilterPrimitiveStandardAttributes)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFEBlendElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGFEBlendElement)
+  NS_NODE_INTERFACE_TABLE5(nsSVGFEBlendElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement,
+                           nsIDOMSVGFilterPrimitiveStandardAttributes,
+                           nsIDOMSVGFEBlendElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGFEBlendElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGFEBlendElementBase)
 
 //----------------------------------------------------------------------
 // nsIDOMNode methods
 
 
 NS_IMPL_ELEMENT_CLONE_WITH_INIT(nsSVGFEBlendElement)
@@ -1043,22 +1041,21 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(FEColorMatrix
 NS_IMPL_NS_NEW_SVG_ELEMENT(FEColorMatrix)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGFEColorMatrixElement,nsSVGFEColorMatrixElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGFEColorMatrixElement,nsSVGFEColorMatrixElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGFEColorMatrixElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFilterPrimitiveStandardAttributes)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFEColorMatrixElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGFEColorMatrixElement)
+  NS_NODE_INTERFACE_TABLE5(nsSVGFEColorMatrixElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement,
+                           nsIDOMSVGFilterPrimitiveStandardAttributes,
+                           nsIDOMSVGFEColorMatrixElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGFEColorMatrixElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGFEColorMatrixElementBase)
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsresult
 nsSVGFEColorMatrixElement::Init()
@@ -1382,22 +1379,21 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(FEComposite)
 NS_IMPL_NS_NEW_SVG_ELEMENT(FEComposite)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGFECompositeElement,nsSVGFECompositeElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGFECompositeElement,nsSVGFECompositeElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGFECompositeElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFilterPrimitiveStandardAttributes)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFECompositeElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGFECompositeElement)
+  NS_NODE_INTERFACE_TABLE5(nsSVGFECompositeElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement,
+                           nsIDOMSVGFilterPrimitiveStandardAttributes,
+                           nsIDOMSVGFECompositeElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGFECompositeElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGFECompositeElementBase)
 
 //----------------------------------------------------------------------
 // nsIDOMNode methods
 
 NS_IMPL_ELEMENT_CLONE_WITH_INIT(nsSVGFECompositeElement)
 
@@ -1642,22 +1638,21 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(FEComponentTr
 NS_IMPL_NS_NEW_SVG_ELEMENT(FEComponentTransfer)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGFEComponentTransferElement,nsSVGFEComponentTransferElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGFEComponentTransferElement,nsSVGFEComponentTransferElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGFEComponentTransferElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFilterPrimitiveStandardAttributes)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFEComponentTransferElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGFEComponentTransferElement)
+  NS_NODE_INTERFACE_TABLE5(nsSVGFEComponentTransferElement, nsIDOMNode,
+                           nsIDOMElement, nsIDOMSVGElement,
+                           nsIDOMSVGFilterPrimitiveStandardAttributes,
+                           nsIDOMSVGFEComponentTransferElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGFEComponentTransferElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGFEComponentTransferElementBase)
 
 //----------------------------------------------------------------------
 // nsIDOMNode methods
 
 NS_IMPL_ELEMENT_CLONE_WITH_INIT(nsSVGFEComponentTransferElement)
 
@@ -2028,22 +2023,21 @@ public:
   NS_FORWARD_NSIDOMELEMENT(nsSVGComponentTransferFunctionElement::)
 
   virtual nsresult Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const;
 };
 
 NS_IMPL_ADDREF_INHERITED(nsSVGFEFuncRElement,nsSVGComponentTransferFunctionElement)
 NS_IMPL_RELEASE_INHERITED(nsSVGFEFuncRElement,nsSVGComponentTransferFunctionElement)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGFEFuncRElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGComponentTransferFunctionElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFEFuncRElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGFEFuncRElement)
+  NS_NODE_INTERFACE_TABLE5(nsSVGFEFuncRElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement,
+                           nsIDOMSVGComponentTransferFunctionElement,
+                           nsIDOMSVGFEFuncRElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGFEFuncRElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGComponentTransferFunctionElement)
 
 NS_IMPL_NS_NEW_SVG_ELEMENT(FEFuncR)
 NS_IMPL_ELEMENT_CLONE_WITH_INIT(nsSVGFEFuncRElement)
 
 
 class nsSVGFEFuncGElement : public nsSVGComponentTransferFunctionElement,
@@ -2070,22 +2064,21 @@ public:
   NS_FORWARD_NSIDOMELEMENT(nsSVGComponentTransferFunctionElement::)
 
   virtual nsresult Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const;
 };
 
 NS_IMPL_ADDREF_INHERITED(nsSVGFEFuncGElement,nsSVGComponentTransferFunctionElement)
 NS_IMPL_RELEASE_INHERITED(nsSVGFEFuncGElement,nsSVGComponentTransferFunctionElement)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGFEFuncGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGComponentTransferFunctionElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFEFuncGElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGFEFuncGElement)
+  NS_NODE_INTERFACE_TABLE5(nsSVGFEFuncGElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement,
+                           nsIDOMSVGComponentTransferFunctionElement,
+                           nsIDOMSVGFEFuncGElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGFEFuncGElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGComponentTransferFunctionElement)
 
 NS_IMPL_NS_NEW_SVG_ELEMENT(FEFuncG)
 NS_IMPL_ELEMENT_CLONE_WITH_INIT(nsSVGFEFuncGElement)
 
 
 class nsSVGFEFuncBElement : public nsSVGComponentTransferFunctionElement,
@@ -2112,22 +2105,21 @@ public:
   NS_FORWARD_NSIDOMELEMENT(nsSVGComponentTransferFunctionElement::)
 
   virtual nsresult Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const;
 };
 
 NS_IMPL_ADDREF_INHERITED(nsSVGFEFuncBElement,nsSVGComponentTransferFunctionElement)
 NS_IMPL_RELEASE_INHERITED(nsSVGFEFuncBElement,nsSVGComponentTransferFunctionElement)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGFEFuncBElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGComponentTransferFunctionElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFEFuncBElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGFEFuncBElement)
+  NS_NODE_INTERFACE_TABLE5(nsSVGFEFuncBElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement,
+                           nsIDOMSVGComponentTransferFunctionElement,
+                           nsIDOMSVGFEFuncBElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGFEFuncBElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGComponentTransferFunctionElement)
 
 NS_IMPL_NS_NEW_SVG_ELEMENT(FEFuncB)
 NS_IMPL_ELEMENT_CLONE_WITH_INIT(nsSVGFEFuncBElement)
 
 
 class nsSVGFEFuncAElement : public nsSVGComponentTransferFunctionElement,
@@ -2154,22 +2146,21 @@ public:
   NS_FORWARD_NSIDOMELEMENT(nsSVGComponentTransferFunctionElement::)
 
   virtual nsresult Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const;
 };
 
 NS_IMPL_ADDREF_INHERITED(nsSVGFEFuncAElement,nsSVGComponentTransferFunctionElement)
 NS_IMPL_RELEASE_INHERITED(nsSVGFEFuncAElement,nsSVGComponentTransferFunctionElement)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGFEFuncAElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGComponentTransferFunctionElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFEFuncAElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGFEFuncAElement)
+  NS_NODE_INTERFACE_TABLE5(nsSVGFEFuncAElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement,
+                           nsIDOMSVGComponentTransferFunctionElement,
+                           nsIDOMSVGFEFuncAElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGFEFuncAElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGComponentTransferFunctionElement)
 
 NS_IMPL_NS_NEW_SVG_ELEMENT(FEFuncA)
 NS_IMPL_ELEMENT_CLONE_WITH_INIT(nsSVGFEFuncAElement)
 
 //---------------------Merge------------------------
 
@@ -2267,22 +2258,21 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(FEMerge)
 NS_IMPL_NS_NEW_SVG_ELEMENT(FEMerge)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGFEMergeElement,nsSVGFEMergeElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGFEMergeElement,nsSVGFEMergeElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGFEMergeElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFilterPrimitiveStandardAttributes)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFEMergeElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGFEMergeElement)
+  NS_NODE_INTERFACE_TABLE5(nsSVGFEMergeElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement,
+                           nsIDOMSVGFilterPrimitiveStandardAttributes,
+                           nsIDOMSVGFEMergeElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGFEMergeElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGFEMergeElementBase)
 
 //----------------------------------------------------------------------
 // nsIDOMNode methods
 
 NS_IMPL_ELEMENT_CLONE_WITH_INIT(nsSVGFEMergeElement)
 
@@ -2338,21 +2328,19 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(FEMergeNode)
 NS_IMPL_NS_NEW_SVG_ELEMENT(FEMergeNode)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGFEMergeNodeElement,nsSVGFEMergeNodeElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGFEMergeNodeElement,nsSVGFEMergeNodeElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGFEMergeNodeElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFEMergeNodeElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGFEMergeNodeElement)
+  NS_NODE_INTERFACE_TABLE4(nsSVGFEMergeNodeElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement, nsIDOMSVGFEMergeNodeElement)
    // nsISupports is an ambiguous base of nsSVGFE so we have to work
    // around that
    if ( aIID.Equals(NS_GET_IID(nsSVGFEMergeNodeElement)) )
      foundInterface = static_cast<nsISupports*>(static_cast<void*>(this));
    else
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGFEMergeNodeElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGFEMergeNodeElementBase)
 
@@ -2453,22 +2441,21 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(FEOffset)
 NS_IMPL_NS_NEW_SVG_ELEMENT(FEOffset)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGFEOffsetElement,nsSVGFEOffsetElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGFEOffsetElement,nsSVGFEOffsetElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGFEOffsetElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFilterPrimitiveStandardAttributes)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFEOffsetElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGFEOffsetElement)
+  NS_NODE_INTERFACE_TABLE5(nsSVGFEOffsetElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement,
+                           nsIDOMSVGFilterPrimitiveStandardAttributes,
+                           nsIDOMSVGFEOffsetElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGFEOffsetElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGFEOffsetElementBase)
 
 //----------------------------------------------------------------------
 // nsIDOMNode methods
 
 
 NS_IMPL_ELEMENT_CLONE_WITH_INIT(nsSVGFEOffsetElement)
@@ -2642,22 +2629,21 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(FEFlood)
 NS_IMPL_NS_NEW_SVG_ELEMENT(FEFlood)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGFEFloodElement,nsSVGFEFloodElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGFEFloodElement,nsSVGFEFloodElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGFEFloodElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFilterPrimitiveStandardAttributes)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFEFloodElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGFEFloodElement)
+  NS_NODE_INTERFACE_TABLE5(nsSVGFEFloodElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement,
+                           nsIDOMSVGFilterPrimitiveStandardAttributes,
+                           nsIDOMSVGFEFloodElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGFEFloodElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGFEFloodElementBase)
 
 //----------------------------------------------------------------------
 // nsIDOMNode methods
 
 NS_IMPL_ELEMENT_CLONE_WITH_INIT(nsSVGFEFloodElement)
 
@@ -2782,22 +2768,21 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(FETile)
 NS_IMPL_NS_NEW_SVG_ELEMENT(FETile)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGFETileElement,nsSVGFETileElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGFETileElement,nsSVGFETileElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGFETileElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFilterPrimitiveStandardAttributes)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFETileElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGFETileElement)
+  NS_NODE_INTERFACE_TABLE5(nsSVGFETileElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement,
+                           nsIDOMSVGFilterPrimitiveStandardAttributes,
+                           nsIDOMSVGFETileElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGFETileElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGFETileElementBase)
 
 //----------------------------------------------------------------------
 // nsIDOMNode methods
 
 
 NS_IMPL_ELEMENT_CLONE_WITH_INIT(nsSVGFETileElement)
@@ -3079,22 +3064,21 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(FETurbulence)
 NS_IMPL_NS_NEW_SVG_ELEMENT(FETurbulence)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGFETurbulenceElement,nsSVGFETurbulenceElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGFETurbulenceElement,nsSVGFETurbulenceElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGFETurbulenceElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFilterPrimitiveStandardAttributes)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFETurbulenceElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGFETurbulenceElement)
+  NS_NODE_INTERFACE_TABLE5(nsSVGFETurbulenceElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement,
+                           nsIDOMSVGFilterPrimitiveStandardAttributes,
+                           nsIDOMSVGFETurbulenceElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGFETurbulenceElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGFETurbulenceElementBase)
 
 //----------------------------------------------------------------------
 // nsIDOMNode methods
 
 NS_IMPL_ELEMENT_CLONE_WITH_INIT(nsSVGFETurbulenceElement)
 
@@ -3516,22 +3500,21 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(FEMorphology)
 NS_IMPL_NS_NEW_SVG_ELEMENT(FEMorphology)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGFEMorphologyElement,nsSVGFEMorphologyElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGFEMorphologyElement,nsSVGFEMorphologyElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGFEMorphologyElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFilterPrimitiveStandardAttributes)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFEMorphologyElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGFEMorphologyElement)
+  NS_NODE_INTERFACE_TABLE5(nsSVGFEMorphologyElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement,
+                           nsIDOMSVGFilterPrimitiveStandardAttributes,
+                           nsIDOMSVGFEMorphologyElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGFEMorphologyElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGFEMorphologyElementBase)
 
 //----------------------------------------------------------------------
 // nsIDOMNode methods
 
 
 NS_IMPL_ELEMENT_CLONE_WITH_INIT(nsSVGFEMorphologyElement)
@@ -3867,22 +3850,21 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(FEConvolveMat
 NS_IMPL_NS_NEW_SVG_ELEMENT(FEConvolveMatrix)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGFEConvolveMatrixElement,nsSVGFEConvolveMatrixElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGFEConvolveMatrixElement,nsSVGFEConvolveMatrixElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGFEConvolveMatrixElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFilterPrimitiveStandardAttributes)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFEConvolveMatrixElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGFEConvolveMatrixElement)
+  NS_NODE_INTERFACE_TABLE5(nsSVGFEConvolveMatrixElement, nsIDOMNode,
+                           nsIDOMElement, nsIDOMSVGElement,
+                           nsIDOMSVGFilterPrimitiveStandardAttributes,
+                           nsIDOMSVGFEConvolveMatrixElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGFEConvolveMatrixElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGFEConvolveMatrixElementBase)
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsresult
 nsSVGFEConvolveMatrixElement::Init()
@@ -4261,21 +4243,20 @@ nsSVGElement::NumberInfo nsSVGFEDistantL
 };
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGFEDistantLightElement,nsSVGFEDistantLightElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGFEDistantLightElement,nsSVGFEDistantLightElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGFEDistantLightElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFEDistantLightElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGFEDistantLightElement)
+  NS_NODE_INTERFACE_TABLE4(nsSVGFEDistantLightElement, nsIDOMNode,
+                           nsIDOMElement, nsIDOMSVGElement,
+                           nsIDOMSVGFEDistantLightElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGFEDistantLightElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGFEDistantLightElementBase)
 
 //----------------------------------------------------------------------
 // nsIDOMNode methods
 
 NS_IMPL_ELEMENT_CLONE_WITH_INIT(nsSVGFEDistantLightElement)
 
@@ -4348,21 +4329,20 @@ nsSVGElement::NumberInfo nsSVGFEPointLig
 };
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGFEPointLightElement,nsSVGFEPointLightElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGFEPointLightElement,nsSVGFEPointLightElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGFEPointLightElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFEPointLightElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGFEPointLightElement)
+  NS_NODE_INTERFACE_TABLE4(nsSVGFEPointLightElement, nsIDOMNode,
+                           nsIDOMElement, nsIDOMSVGElement,
+                           nsIDOMSVGFEPointLightElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGFEPointLightElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGFEPointLightElementBase)
 
 //----------------------------------------------------------------------
 // nsIDOMNode methods
 
 NS_IMPL_ELEMENT_CLONE_WITH_INIT(nsSVGFEPointLightElement)
 
@@ -4445,21 +4425,20 @@ nsSVGElement::NumberInfo nsSVGFESpotLigh
 };
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGFESpotLightElement,nsSVGFESpotLightElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGFESpotLightElement,nsSVGFESpotLightElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGFESpotLightElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFESpotLightElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGFESpotLightElement)
+  NS_NODE_INTERFACE_TABLE4(nsSVGFESpotLightElement, nsIDOMNode,
+                           nsIDOMElement, nsIDOMSVGElement,
+                           nsIDOMSVGFESpotLightElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGFESpotLightElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGFESpotLightElementBase)
 
 //----------------------------------------------------------------------
 // nsIDOMNode methods
 
 NS_IMPL_ELEMENT_CLONE_WITH_INIT(nsSVGFESpotLightElement)
 
@@ -4915,22 +4894,21 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(FEDiffuseLigh
 NS_IMPL_NS_NEW_SVG_ELEMENT(FEDiffuseLighting)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGFEDiffuseLightingElement,nsSVGFEDiffuseLightingElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGFEDiffuseLightingElement,nsSVGFEDiffuseLightingElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGFEDiffuseLightingElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFilterPrimitiveStandardAttributes)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFEDiffuseLightingElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGFEDiffuseLightingElement)
+  NS_NODE_INTERFACE_TABLE5(nsSVGFEDiffuseLightingElement, nsIDOMNode,
+                           nsIDOMElement, nsIDOMSVGElement,
+                           nsIDOMSVGFilterPrimitiveStandardAttributes,
+                           nsIDOMSVGFEDiffuseLightingElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGFEDiffuseLightingElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGFEDiffuseLightingElementBase)
 
 //----------------------------------------------------------------------
 // nsIDOMNode methods
 
 NS_IMPL_ELEMENT_CLONE_WITH_INIT(nsSVGFEDiffuseLightingElement)
 
@@ -5038,22 +5016,21 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(FESpecularLig
 NS_IMPL_NS_NEW_SVG_ELEMENT(FESpecularLighting)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGFESpecularLightingElement,nsSVGFESpecularLightingElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGFESpecularLightingElement,nsSVGFESpecularLightingElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGFESpecularLightingElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFilterPrimitiveStandardAttributes)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFESpecularLightingElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGFESpecularLightingElement)
+  NS_NODE_INTERFACE_TABLE5(nsSVGFESpecularLightingElement, nsIDOMNode,
+                           nsIDOMElement, nsIDOMSVGElement,
+                           nsIDOMSVGFilterPrimitiveStandardAttributes,
+                           nsIDOMSVGFESpecularLightingElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGFESpecularLightingElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGFESpecularLightingElementBase)
 
 //----------------------------------------------------------------------
 // nsIDOMNode methods
 
 NS_IMPL_ELEMENT_CLONE_WITH_INIT(nsSVGFESpecularLightingElement)
 
@@ -5245,25 +5222,22 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(FEImage)
 NS_IMPL_NS_NEW_SVG_ELEMENT(FEImage)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGFEImageElement,nsSVGFEImageElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGFEImageElement,nsSVGFEImageElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGFEImageElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFilterPrimitiveStandardAttributes)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFEImageElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGURIReference)
-  NS_INTERFACE_MAP_ENTRY(imgIDecoderObserver)
-  NS_INTERFACE_MAP_ENTRY(nsIImageLoadingContent)
+NS_INTERFACE_TABLE_HEAD(nsSVGFEImageElement)
+  NS_NODE_INTERFACE_TABLE8(nsSVGFEImageElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement,
+                           nsIDOMSVGFilterPrimitiveStandardAttributes,
+                           nsIDOMSVGFEImageElement, nsIDOMSVGURIReference,
+                           imgIDecoderObserver, nsIImageLoadingContent)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGFEImageElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGFEImageElementBase)
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsSVGFEImageElement::nsSVGFEImageElement(nsINodeInfo *aNodeInfo)
   : nsSVGFEImageElementBase(aNodeInfo)
@@ -5606,22 +5580,21 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(FEDisplacemen
 NS_IMPL_NS_NEW_SVG_ELEMENT(FEDisplacementMap)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGFEDisplacementMapElement,nsSVGFEDisplacementMapElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGFEDisplacementMapElement,nsSVGFEDisplacementMapElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGFEDisplacementMapElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFilterPrimitiveStandardAttributes)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFEDisplacementMapElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGFEDisplacementMapElement)
+  NS_NODE_INTERFACE_TABLE5(nsSVGFEDisplacementMapElement, nsIDOMNode,
+                           nsIDOMElement, nsIDOMSVGElement,
+                           nsIDOMSVGFilterPrimitiveStandardAttributes,
+                           nsIDOMSVGFEDisplacementMapElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGFEDisplacementMapElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGFEDisplacementMapElementBase)
 
 //----------------------------------------------------------------------
 // nsIDOMNode methods
 
 NS_IMPL_ELEMENT_CLONE_WITH_INIT(nsSVGFEDisplacementMapElement)
 
diff -r 4f1383af8f10 content/svg/content/src/nsSVGForeignObjectElement.cpp
--- a/content/svg/content/src/nsSVGForeignObjectElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/svg/content/src/nsSVGForeignObjectElement.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -51,21 +51,19 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(ForeignObject
 NS_IMPL_NS_NEW_SVG_ELEMENT(ForeignObject)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGForeignObjectElement,nsSVGForeignObjectElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGForeignObjectElement,nsSVGForeignObjectElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGForeignObjectElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGForeignObjectElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGForeignObjectElement)
+  NS_NODE_INTERFACE_TABLE4(nsSVGForeignObjectElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement, nsIDOMSVGForeignObjectElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGForeignObjectElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGForeignObjectElementBase)
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsSVGForeignObjectElement::nsSVGForeignObjectElement(nsINodeInfo *aNodeInfo)
   : nsSVGForeignObjectElementBase(aNodeInfo)
diff -r 4f1383af8f10 content/svg/content/src/nsSVGGElement.cpp
--- a/content/svg/content/src/nsSVGGElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/svg/content/src/nsSVGGElement.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -74,21 +74,19 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(G)
 
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGGElement,nsSVGGElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGGElement,nsSVGGElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGGElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGGElement)
+  NS_NODE_INTERFACE_TABLE4(nsSVGGElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement, nsIDOMSVGGElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGGElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGGElementBase)
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsSVGGElement::nsSVGGElement(nsINodeInfo *aNodeInfo)
   : nsSVGGElementBase(aNodeInfo)
diff -r 4f1383af8f10 content/svg/content/src/nsSVGGradientElement.cpp
--- a/content/svg/content/src/nsSVGGradientElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/svg/content/src/nsSVGGradientElement.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -192,22 +192,21 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(LinearGradien
 NS_IMPL_NS_NEW_SVG_ELEMENT(LinearGradient)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGLinearGradientElement,nsSVGLinearGradientElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGLinearGradientElement,nsSVGLinearGradientElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGLinearGradientElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGGradientElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGLinearGradientElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGLinearGradientElement)
+  NS_NODE_INTERFACE_TABLE5(nsSVGLinearGradientElement, nsIDOMNode,
+                           nsIDOMElement, nsIDOMSVGElement,
+                           nsIDOMSVGGradientElement,
+                           nsIDOMSVGLinearGradientElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGLinearGradientElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGLinearGradientElementBase)
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsSVGLinearGradientElement::nsSVGLinearGradientElement(nsINodeInfo* aNodeInfo)
   : nsSVGLinearGradientElementBase(aNodeInfo)
@@ -271,22 +270,21 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(RadialGradien
 NS_IMPL_NS_NEW_SVG_ELEMENT(RadialGradient)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGRadialGradientElement,nsSVGRadialGradientElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGRadialGradientElement,nsSVGRadialGradientElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGRadialGradientElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGGradientElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGRadialGradientElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGRadialGradientElement)
+  NS_NODE_INTERFACE_TABLE5(nsSVGRadialGradientElement, nsIDOMNode,
+                           nsIDOMElement, nsIDOMSVGElement,
+                           nsIDOMSVGGradientElement,
+                           nsIDOMSVGRadialGradientElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGRadialGradientElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGRadialGradientElementBase)
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsSVGRadialGradientElement::nsSVGRadialGradientElement(nsINodeInfo* aNodeInfo)
   : nsSVGRadialGradientElementBase(aNodeInfo)
diff -r 4f1383af8f10 content/svg/content/src/nsSVGImageElement.cpp
--- a/content/svg/content/src/nsSVGImageElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/svg/content/src/nsSVGImageElement.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -130,24 +130,21 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(Image)
 NS_IMPL_NS_NEW_SVG_ELEMENT(Image)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGImageElement,nsSVGImageElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGImageElement,nsSVGImageElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGImageElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGImageElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGURIReference)
-  NS_INTERFACE_MAP_ENTRY(imgIDecoderObserver)
-  NS_INTERFACE_MAP_ENTRY(nsIImageLoadingContent)
+NS_INTERFACE_TABLE_HEAD(nsSVGImageElement)
+  NS_NODE_INTERFACE_TABLE7(nsSVGImageElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement, nsIDOMSVGImageElement,
+                           nsIDOMSVGURIReference, imgIDecoderObserver,
+                           nsIImageLoadingContent)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGImageElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGImageElementBase)
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsSVGImageElement::nsSVGImageElement(nsINodeInfo *aNodeInfo)
   : nsSVGImageElementBase(aNodeInfo)
diff -r 4f1383af8f10 content/svg/content/src/nsSVGLineElement.cpp
--- a/content/svg/content/src/nsSVGLineElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/svg/content/src/nsSVGLineElement.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -93,21 +93,19 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(Line)
 NS_IMPL_NS_NEW_SVG_ELEMENT(Line)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGLineElement,nsSVGLineElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGLineElement,nsSVGLineElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGLineElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGLineElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGLineElement)
+  NS_NODE_INTERFACE_TABLE4(nsSVGLineElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement, nsIDOMSVGLineElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGLineElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGLineElementBase)
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsSVGLineElement::nsSVGLineElement(nsINodeInfo *aNodeInfo)
   : nsSVGLineElementBase(aNodeInfo)
diff -r 4f1383af8f10 content/svg/content/src/nsSVGMarkerElement.cpp
--- a/content/svg/content/src/nsSVGMarkerElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/svg/content/src/nsSVGMarkerElement.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -85,22 +85,20 @@ NS_INTERFACE_MAP_BEGIN(nsSVGOrientType::
   NS_INTERFACE_MAP_ENTRY(nsIDOMSVGAnimatedEnumeration)
   NS_INTERFACE_MAP_ENTRY(nsISupports)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGAnimatedEnumeration)
 NS_INTERFACE_MAP_END
 
 NS_IMPL_ADDREF_INHERITED(nsSVGMarkerElement,nsSVGMarkerElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGMarkerElement,nsSVGMarkerElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGMarkerElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFitToViewBox)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGMarkerElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGMarkerElement)
+  NS_NODE_INTERFACE_TABLE5(nsSVGMarkerElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement, nsIDOMSVGFitToViewBox,
+                           nsIDOMSVGMarkerElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGMarkerElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGMarkerElementBase)
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsresult
 nsSVGOrientType::SetBaseValue(PRUint16 aValue,
diff -r 4f1383af8f10 content/svg/content/src/nsSVGMaskElement.cpp
--- a/content/svg/content/src/nsSVGMaskElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/svg/content/src/nsSVGMaskElement.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -63,22 +63,20 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(Mask)
 NS_IMPL_NS_NEW_SVG_ELEMENT(Mask)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGMaskElement,nsSVGMaskElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGMaskElement,nsSVGMaskElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGMaskElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGMaskElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGUnitTypes)
+NS_INTERFACE_TABLE_HEAD(nsSVGMaskElement)
+  NS_NODE_INTERFACE_TABLE5(nsSVGMaskElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement, nsIDOMSVGMaskElement,
+                           nsIDOMSVGUnitTypes)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGMaskElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGMaskElementBase)
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsSVGMaskElement::nsSVGMaskElement(nsINodeInfo* aNodeInfo)
   : nsSVGMaskElementBase(aNodeInfo)
diff -r 4f1383af8f10 content/svg/content/src/nsSVGMetadataElement.cpp
--- a/content/svg/content/src/nsSVGMetadataElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/svg/content/src/nsSVGMetadataElement.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -68,21 +68,19 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(Metadata)
 
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGMetadataElement, nsSVGMetadataElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGMetadataElement, nsSVGMetadataElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGMetadataElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGMetadataElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGMetadataElement)
+  NS_NODE_INTERFACE_TABLE4(nsSVGMetadataElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement, nsIDOMSVGMetadataElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGMetadataElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGMetadataElementBase)
 
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsSVGMetadataElement::nsSVGMetadataElement(nsINodeInfo *aNodeInfo)
diff -r 4f1383af8f10 content/svg/content/src/nsSVGPathElement.cpp
--- a/content/svg/content/src/nsSVGPathElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/svg/content/src/nsSVGPathElement.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -55,22 +55,20 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(Path)
 NS_IMPL_NS_NEW_SVG_ELEMENT(Path)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGPathElement,nsSVGPathElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGPathElement,nsSVGPathElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGPathElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGPathElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGAnimatedPathData)
+NS_INTERFACE_TABLE_HEAD(nsSVGPathElement)
+  NS_NODE_INTERFACE_TABLE5(nsSVGPathElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement, nsIDOMSVGPathElement,
+                           nsIDOMSVGAnimatedPathData)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGPathElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGPathElementBase)
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsSVGPathElement::nsSVGPathElement(nsINodeInfo* aNodeInfo)
   : nsSVGPathElementBase(aNodeInfo)
diff -r 4f1383af8f10 content/svg/content/src/nsSVGPatternElement.cpp
--- a/content/svg/content/src/nsSVGPatternElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/svg/content/src/nsSVGPatternElement.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -78,25 +78,21 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(Pattern)
 NS_IMPL_NS_NEW_SVG_ELEMENT(Pattern)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGPatternElement,nsSVGPatternElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGPatternElement,nsSVGPatternElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGPatternElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFitToViewBox)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGURIReference)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGPatternElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGUnitTypes)
-  NS_INTERFACE_MAP_ENTRY(nsIMutationObserver)
+NS_INTERFACE_TABLE_HEAD(nsSVGPatternElement)
+  NS_NODE_INTERFACE_TABLE8(nsSVGPatternElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement, nsIDOMSVGFitToViewBox,
+                           nsIDOMSVGURIReference, nsIDOMSVGPatternElement,
+                           nsIDOMSVGUnitTypes, nsIMutationObserver)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGPatternElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGPatternElementBase)
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsSVGPatternElement::nsSVGPatternElement(nsINodeInfo* aNodeInfo)
   : nsSVGPatternElementBase(aNodeInfo)
diff -r 4f1383af8f10 content/svg/content/src/nsSVGPolygonElement.cpp
--- a/content/svg/content/src/nsSVGPolygonElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/svg/content/src/nsSVGPolygonElement.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -71,21 +71,19 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(Polygon)
 NS_IMPL_NS_NEW_SVG_ELEMENT(Polygon)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGPolygonElement,nsSVGPolygonElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGPolygonElement,nsSVGPolygonElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGPolygonElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGPolygonElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGPolygonElement)
+  NS_NODE_INTERFACE_TABLE4(nsSVGPolygonElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement, nsIDOMSVGPolygonElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGPolygonElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGPolygonElementBase)
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsSVGPolygonElement::nsSVGPolygonElement(nsINodeInfo* aNodeInfo)
   : nsSVGPolygonElementBase(aNodeInfo)
diff -r 4f1383af8f10 content/svg/content/src/nsSVGPolylineElement.cpp
--- a/content/svg/content/src/nsSVGPolylineElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/svg/content/src/nsSVGPolylineElement.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -67,21 +67,19 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(Polyline)
 NS_IMPL_NS_NEW_SVG_ELEMENT(Polyline)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGPolylineElement,nsSVGPolylineElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGPolylineElement,nsSVGPolylineElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGPolylineElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGPolylineElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGPolylineElement)
+  NS_NODE_INTERFACE_TABLE4(nsSVGPolylineElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement, nsIDOMSVGPolylineElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGPolylineElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGPolylineElementBase)
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsSVGPolylineElement::nsSVGPolylineElement(nsINodeInfo* aNodeInfo)
   : nsSVGPolylineElementBase(aNodeInfo)
diff -r 4f1383af8f10 content/svg/content/src/nsSVGRectElement.cpp
--- a/content/svg/content/src/nsSVGRectElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/svg/content/src/nsSVGRectElement.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -90,21 +90,19 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(Rect)
 NS_IMPL_NS_NEW_SVG_ELEMENT(Rect)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGRectElement,nsSVGRectElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGRectElement,nsSVGRectElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGRectElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGRectElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGRectElement)
+  NS_NODE_INTERFACE_TABLE4(nsSVGRectElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement, nsIDOMSVGRectElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGRectElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGRectElementBase)
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsSVGRectElement::nsSVGRectElement(nsINodeInfo *aNodeInfo)
   : nsSVGRectElementBase(aNodeInfo)
diff -r 4f1383af8f10 content/svg/content/src/nsSVGSVGElement.cpp
--- a/content/svg/content/src/nsSVGSVGElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/svg/content/src/nsSVGSVGElement.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -89,24 +89,21 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(SVG)
 NS_IMPL_NS_NEW_SVG_ELEMENT(SVG)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGSVGElement,nsSVGSVGElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGSVGElement,nsSVGSVGElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFitToViewBox)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGLocatable)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGZoomAndPan)
+NS_INTERFACE_TABLE_HEAD(nsSVGSVGElement)
+  NS_NODE_INTERFACE_TABLE7(nsSVGSVGElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement, nsIDOMSVGSVGElement,
+                           nsIDOMSVGFitToViewBox, nsIDOMSVGLocatable,
+                           nsIDOMSVGZoomAndPan)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGSVGElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGSVGElementBase)
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsSVGSVGElement::nsSVGSVGElement(nsINodeInfo* aNodeInfo)
   : nsSVGSVGElementBase(aNodeInfo),
diff -r 4f1383af8f10 content/svg/content/src/nsSVGScriptElement.cpp
--- a/content/svg/content/src/nsSVGScriptElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/svg/content/src/nsSVGScriptElement.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -115,25 +115,21 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(Script)
 NS_IMPL_NS_NEW_SVG_ELEMENT(Script)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGScriptElement,nsSVGScriptElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGScriptElement,nsSVGScriptElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGScriptElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGScriptElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGURIReference)
-  NS_INTERFACE_MAP_ENTRY(nsIScriptLoaderObserver)
-  NS_INTERFACE_MAP_ENTRY(nsIScriptElement)
-  NS_INTERFACE_MAP_ENTRY(nsIMutationObserver)
+NS_INTERFACE_TABLE_HEAD(nsSVGScriptElement)
+  NS_NODE_INTERFACE_TABLE8(nsSVGScriptElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement, nsIDOMSVGScriptElement,
+                           nsIDOMSVGURIReference, nsIScriptLoaderObserver,
+                           nsIScriptElement, nsIMutationObserver)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGScriptElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGScriptElementBase)
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsSVGScriptElement::nsSVGScriptElement(nsINodeInfo *aNodeInfo)
   : nsSVGScriptElementBase(aNodeInfo),
diff -r 4f1383af8f10 content/svg/content/src/nsSVGStopElement.cpp
--- a/content/svg/content/src/nsSVGStopElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/svg/content/src/nsSVGStopElement.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -85,21 +85,19 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(Stop)
 NS_IMPL_NS_NEW_SVG_ELEMENT(Stop)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGStopElement,nsSVGStopElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGStopElement,nsSVGStopElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGStopElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGStopElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGStopElement)
+  NS_NODE_INTERFACE_TABLE4(nsSVGStopElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement, nsIDOMSVGStopElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGStopElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGStopElementBase)
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsSVGStopElement::nsSVGStopElement(nsINodeInfo* aNodeInfo)
   : nsSVGStopElementBase(aNodeInfo)
diff -r 4f1383af8f10 content/svg/content/src/nsSVGStyleElement.cpp
--- a/content/svg/content/src/nsSVGStyleElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/svg/content/src/nsSVGStyleElement.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -118,24 +118,21 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(Style)
 
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGStyleElement,nsSVGStyleElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGStyleElement,nsSVGStyleElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGStyleElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGStyleElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMLinkStyle)
-  NS_INTERFACE_MAP_ENTRY(nsIStyleSheetLinkingElement)
-  NS_INTERFACE_MAP_ENTRY(nsIMutationObserver)
+NS_INTERFACE_TABLE_HEAD(nsSVGStyleElement)
+  NS_NODE_INTERFACE_TABLE7(nsSVGStyleElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement, nsIDOMSVGStyleElement,
+                           nsIDOMLinkStyle, nsIStyleSheetLinkingElement,
+                           nsIMutationObserver)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGStyleElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGStyleElementBase)
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsSVGStyleElement::nsSVGStyleElement(nsINodeInfo *aNodeInfo)
   : nsSVGStyleElementBase(aNodeInfo)
diff -r 4f1383af8f10 content/svg/content/src/nsSVGSwitchElement.cpp
--- a/content/svg/content/src/nsSVGSwitchElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/svg/content/src/nsSVGSwitchElement.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -50,21 +50,19 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(Switch)
 
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGSwitchElement,nsSVGSwitchElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGSwitchElement,nsSVGSwitchElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGSwitchElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGSwitchElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGSwitchElement)
+  NS_NODE_INTERFACE_TABLE4(nsSVGSwitchElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement, nsIDOMSVGSwitchElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGSwitchElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGSwitchElementBase)
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsSVGSwitchElement::nsSVGSwitchElement(nsINodeInfo *aNodeInfo)
   : nsSVGSwitchElementBase(aNodeInfo)
diff -r 4f1383af8f10 content/svg/content/src/nsSVGSymbolElement.cpp
--- a/content/svg/content/src/nsSVGSymbolElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/svg/content/src/nsSVGSymbolElement.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -83,22 +83,20 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(Symbol)
 NS_IMPL_NS_NEW_SVG_ELEMENT(Symbol)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGSymbolElement,nsSVGSymbolElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGSymbolElement,nsSVGSymbolElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGSymbolElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFitToViewBox)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGSymbolElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGSymbolElement)
+  NS_NODE_INTERFACE_TABLE5(nsSVGSymbolElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement, nsIDOMSVGFitToViewBox,
+                           nsIDOMSVGSymbolElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGSymbolElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGSymbolElementBase)
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsSVGSymbolElement::nsSVGSymbolElement(nsINodeInfo *aNodeInfo)
   : nsSVGSymbolElementBase(aNodeInfo)
diff -r 4f1383af8f10 content/svg/content/src/nsSVGTSpanElement.cpp
--- a/content/svg/content/src/nsSVGTSpanElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/svg/content/src/nsSVGTSpanElement.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -97,23 +97,21 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(TSpan)
 
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGTSpanElement,nsSVGTSpanElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGTSpanElement,nsSVGTSpanElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGTSpanElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGTSpanElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGTextPositioningElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGTextContentElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGTSpanElement)
+  NS_NODE_INTERFACE_TABLE6(nsSVGTSpanElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement, nsIDOMSVGTSpanElement,
+                           nsIDOMSVGTextPositioningElement,
+                           nsIDOMSVGTextContentElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGTSpanElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGTSpanElementBase)
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsSVGTSpanElement::nsSVGTSpanElement(nsINodeInfo *aNodeInfo)
   : nsSVGTSpanElementBase(aNodeInfo)
diff -r 4f1383af8f10 content/svg/content/src/nsSVGTextElement.cpp
--- a/content/svg/content/src/nsSVGTextElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/svg/content/src/nsSVGTextElement.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -95,23 +95,21 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(Text)
 
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGTextElement,nsSVGTextElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGTextElement,nsSVGTextElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGTextElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGTextElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGTextPositioningElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGTextContentElement)
+NS_INTERFACE_TABLE_HEAD(nsSVGTextElement)
+  NS_NODE_INTERFACE_TABLE6(nsSVGTextElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement, nsIDOMSVGTextElement,
+                           nsIDOMSVGTextPositioningElement,
+                           nsIDOMSVGTextContentElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGTextElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGTextElementBase)
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsSVGTextElement::nsSVGTextElement(nsINodeInfo* aNodeInfo)
   : nsSVGTextElementBase(aNodeInfo)
diff -r 4f1383af8f10 content/svg/content/src/nsSVGTextPathElement.cpp
--- a/content/svg/content/src/nsSVGTextPathElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/svg/content/src/nsSVGTextPathElement.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -81,23 +81,20 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(TextPath)
 NS_IMPL_NS_NEW_SVG_ELEMENT(TextPath)
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGTextPathElement,nsSVGTextPathElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGTextPathElement,nsSVGTextPathElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGTextPathElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGTextPathElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGTextContentElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGURIReference)
+NS_INTERFACE_TABLE_HEAD(nsSVGTextPathElement)
+  NS_NODE_INTERFACE_TABLE6(nsSVGTextPathElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement, nsIDOMSVGTextPathElement,
+                           nsIDOMSVGTextContentElement, nsIDOMSVGURIReference)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGTextPathElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGTextPathElementBase)
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsSVGTextPathElement::nsSVGTextPathElement(nsINodeInfo *aNodeInfo)
   : nsSVGTextPathElementBase(aNodeInfo)
diff -r 4f1383af8f10 content/svg/content/src/nsSVGTitleElement.cpp
--- a/content/svg/content/src/nsSVGTitleElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/svg/content/src/nsSVGTitleElement.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -87,22 +87,20 @@ NS_IMPL_NS_NEW_SVG_ELEMENT(Title)
 
 
 //----------------------------------------------------------------------
 // nsISupports methods
 
 NS_IMPL_ADDREF_INHERITED(nsSVGTitleElement, nsSVGTitleElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGTitleElement, nsSVGTitleElementBase)
 
-NS_INTERFACE_MAP_BEGIN(nsSVGTitleElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGTitleElement)
-  NS_INTERFACE_MAP_ENTRY(nsIMutationObserver)
+NS_INTERFACE_TABLE_HEAD(nsSVGTitleElement)
+  NS_NODE_INTERFACE_TABLE5(nsSVGTitleElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement, nsIDOMSVGTitleElement,
+                           nsIMutationObserver)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGTitleElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGTitleElementBase)
 
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsSVGTitleElement::nsSVGTitleElement(nsINodeInfo *aNodeInfo)
diff -r 4f1383af8f10 content/svg/content/src/nsSVGUseElement.cpp
--- a/content/svg/content/src/nsSVGUseElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/svg/content/src/nsSVGUseElement.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -77,23 +77,20 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOriginal)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mClone)
   tmp->mSource.Traverse(&cb);
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_ADDREF_INHERITED(nsSVGUseElement,nsSVGUseElementBase)
 NS_IMPL_RELEASE_INHERITED(nsSVGUseElement,nsSVGUseElementBase)
 
-NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsSVGUseElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGURIReference)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGUseElement)
-  NS_INTERFACE_MAP_ENTRY(nsIMutationObserver)
+NS_INTERFACE_TABLE_HEAD(nsSVGUseElement)
+  NS_NODE_INTERFACE_TABLE6(nsSVGUseElement, nsIDOMNode, nsIDOMElement,
+                           nsIDOMSVGElement, nsIDOMSVGURIReference,
+                           nsIDOMSVGUseElement, nsIMutationObserver)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGUseElement)
   if (aIID.Equals(NS_GET_IID(nsSVGUseElement)))
     foundInterface = reinterpret_cast<nsISupports*>(this);
   else
 NS_INTERFACE_MAP_END_INHERITING(nsSVGUseElementBase)
 
 //----------------------------------------------------------------------
 // Implementation
diff -r 4f1383af8f10 content/xbl/src/nsBindingManager.cpp
--- a/content/xbl/src/nsBindingManager.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/xbl/src/nsBindingManager.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -132,21 +132,23 @@ nsAnonymousContentList::~nsAnonymousCont
   delete mElements;
 }
 
 NS_IMPL_CYCLE_COLLECTION_CLASS(nsAnonymousContentList)
 
 NS_IMPL_CYCLE_COLLECTING_ADDREF(nsAnonymousContentList)
 NS_IMPL_CYCLE_COLLECTING_RELEASE(nsAnonymousContentList)
 
-NS_INTERFACE_MAP_BEGIN(nsAnonymousContentList)
-  NS_INTERFACE_MAP_ENTRY(nsINodeList)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNodeList)
-  NS_INTERFACE_MAP_ENTRY(nsAnonymousContentList)
-  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsINodeList)
+NS_INTERFACE_TABLE_HEAD(nsAnonymousContentList)
+  NS_NODELIST_OFFSET_AND_INTERFACE_TABLE_BEGIN(nsAnonymousContentList)
+    NS_INTERFACE_TABLE_ENTRY(nsAnonymousContentList, nsINodeList)
+    NS_INTERFACE_TABLE_ENTRY(nsAnonymousContentList, nsIDOMNodeList)
+    NS_INTERFACE_TABLE_ENTRY(nsAnonymousContentList, nsAnonymousContentList)
+  NS_OFFSET_AND_INTERFACE_TABLE_END
+  NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(NodeList)
   NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION(nsAnonymousContentList)
 NS_INTERFACE_MAP_END
 
 NS_IMPL_CYCLE_COLLECTION_UNLINK_0(nsAnonymousContentList)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsAnonymousContentList)
   {
     PRInt32 i, count = tmp->mElements->Length();
diff -r 4f1383af8f10 content/xml/content/src/nsXMLCDATASection.cpp
--- a/content/xml/content/src/nsXMLCDATASection.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/xml/content/src/nsXMLCDATASection.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -102,22 +102,20 @@ nsXMLCDATASection::nsXMLCDATASection(nsI
 }
 
 nsXMLCDATASection::~nsXMLCDATASection()
 {
 }
 
 
 // QueryInterface implementation for nsXMLCDATASection
-NS_INTERFACE_MAP_BEGIN(nsXMLCDATASection)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMCharacterData)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMText)
+NS_INTERFACE_TABLE_HEAD(nsXMLCDATASection)
+  NS_NODE_INTERFACE_TABLE4(nsXMLCDATASection, nsIDOMNode, nsIDOMCharacterData,
+                           nsIDOMText, nsIDOMCDATASection)
   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOM3Text, new nsText3Tearoff(this))
-  NS_INTERFACE_MAP_ENTRY(nsIDOMCDATASection)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(CDATASection)
 NS_INTERFACE_MAP_END_INHERITING(nsGenericDOMDataNode)
 
 NS_IMPL_ADDREF_INHERITED(nsXMLCDATASection, nsGenericDOMDataNode)
 NS_IMPL_RELEASE_INHERITED(nsXMLCDATASection, nsGenericDOMDataNode)
 
 
 PRBool
diff -r 4f1383af8f10 content/xml/content/src/nsXMLElement.cpp
--- a/content/xml/content/src/nsXMLElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/xml/content/src/nsXMLElement.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -59,45 +59,24 @@ NS_NewXMLElement(nsIContent** aInstanceP
 
 nsXMLElement::nsXMLElement(nsINodeInfo *aNodeInfo)
   : nsGenericElement(aNodeInfo)
 {
 }
 
 
 // QueryInterface implementation for nsXMLElement
-NS_IMETHODIMP 
-nsXMLElement::QueryInterface(REFNSIID aIID, void** aInstancePtr)
-{
-  NS_PRECONDITION(aInstancePtr, "null out param");
-
-  nsresult rv = nsGenericElement::QueryInterface(aIID, aInstancePtr);
-
-  if (NS_SUCCEEDED(rv))
-    return rv;
-
-  nsISupports *inst = nsnull;
-
-  if (aIID.Equals(NS_GET_IID(nsIDOMNode))) {
-    inst = static_cast<nsIDOMNode *>(this);
-  } else if (aIID.Equals(NS_GET_IID(nsIDOMElement))) {
-    inst = static_cast<nsIDOMElement *>(this);
-  } else if (aIID.Equals(NS_GET_IID(nsIClassInfo))) {
-    inst = NS_GetDOMClassInfoInstance(eDOMClassInfo_Element_id);
-    NS_ENSURE_TRUE(inst, NS_ERROR_OUT_OF_MEMORY);
-  } else {
-    return PostQueryInterface(aIID, aInstancePtr);
-  }
-
-  NS_ADDREF(inst);
-
-  *aInstancePtr = inst;
-
-  return NS_OK;
-}
+NS_INTERFACE_TABLE_HEAD(nsXMLElement)
+  NS_NODE_OFFSET_AND_INTERFACE_TABLE_BEGIN(nsXMLElement)
+    NS_INTERFACE_TABLE_ENTRY(nsXMLElement, nsIDOMNode)
+    NS_INTERFACE_TABLE_ENTRY(nsXMLElement, nsIDOMElement)
+  NS_OFFSET_AND_INTERFACE_TABLE_END
+  NS_ELEMENT_INTERFACE_TABLE_TO_MAP_SEGUE
+  NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(Element)
+NS_ELEMENT_INTERFACE_MAP_END
 
 
 NS_IMPL_ADDREF_INHERITED(nsXMLElement, nsGenericElement)
 NS_IMPL_RELEASE_INHERITED(nsXMLElement, nsGenericElement)
 
 
 static nsresult
 DocShellToPresContext(nsIDocShell *aShell, nsPresContext **aPresContext)
diff -r 4f1383af8f10 content/xml/content/src/nsXMLProcessingInstruction.cpp
--- a/content/xml/content/src/nsXMLProcessingInstruction.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/xml/content/src/nsXMLProcessingInstruction.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -85,19 +85,23 @@ nsXMLProcessingInstruction::nsXMLProcess
 }
 
 nsXMLProcessingInstruction::~nsXMLProcessingInstruction()
 {
 }
 
 
 // QueryInterface implementation for nsXMLProcessingInstruction
-NS_INTERFACE_MAP_BEGIN(nsXMLProcessingInstruction)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMProcessingInstruction)
+NS_INTERFACE_TABLE_HEAD(nsXMLProcessingInstruction)
+  NS_NODE_OFFSET_AND_INTERFACE_TABLE_BEGIN(nsXMLProcessingInstruction)
+    NS_INTERFACE_TABLE_ENTRY(nsXMLProcessingInstruction, nsIDOMNode)
+    NS_INTERFACE_TABLE_ENTRY(nsXMLProcessingInstruction,
+                             nsIDOMProcessingInstruction)
+  NS_OFFSET_AND_INTERFACE_TABLE_END
+  NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(ProcessingInstruction)
 NS_INTERFACE_MAP_END_INHERITING(nsGenericDOMDataNode)
 
 
 NS_IMPL_ADDREF_INHERITED(nsXMLProcessingInstruction, nsGenericDOMDataNode)
 NS_IMPL_RELEASE_INHERITED(nsXMLProcessingInstruction, nsGenericDOMDataNode)
 
 
diff -r 4f1383af8f10 content/xml/content/src/nsXMLStylesheetPI.cpp
--- a/content/xml/content/src/nsXMLStylesheetPI.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/xml/content/src/nsXMLStylesheetPI.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -84,19 +84,20 @@ protected:
                          nsAString& aMedia,
                          PRBool* aIsAlternate);
   virtual nsGenericDOMDataNode* CloneDataNode(nsINodeInfo *aNodeInfo,
                                               PRBool aCloneText) const;
 };
 
 // nsISupports implementation
 
-NS_INTERFACE_MAP_BEGIN(nsXMLStylesheetPI)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMLinkStyle)
-  NS_INTERFACE_MAP_ENTRY(nsIStyleSheetLinkingElement)
+NS_INTERFACE_TABLE_HEAD(nsXMLStylesheetPI)
+  NS_NODE_INTERFACE_TABLE4(nsXMLStylesheetPI, nsIDOMNode,
+                           nsIDOMProcessingInstruction, nsIDOMLinkStyle,
+                           nsIStyleSheetLinkingElement)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(XMLStylesheetProcessingInstruction)
 NS_INTERFACE_MAP_END_INHERITING(nsXMLProcessingInstruction)
 
 NS_IMPL_ADDREF_INHERITED(nsXMLStylesheetPI, nsXMLProcessingInstruction)
 NS_IMPL_RELEASE_INHERITED(nsXMLStylesheetPI, nsXMLProcessingInstruction)
 
 
 nsXMLStylesheetPI::nsXMLStylesheetPI(nsINodeInfo *aNodeInfo,
diff -r 4f1383af8f10 content/xml/document/src/nsXMLDocument.cpp
--- a/content/xml/document/src/nsXMLDocument.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/xml/document/src/nsXMLDocument.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -230,21 +230,22 @@ nsXMLDocument::~nsXMLDocument()
 nsXMLDocument::~nsXMLDocument()
 {
   // XXX We rather crash than hang
   mLoopingForSyncLoad = PR_FALSE;
 }
 
 // QueryInterface implementation for nsXMLDocument
 NS_INTERFACE_TABLE_HEAD(nsXMLDocument)
-  NS_INTERFACE_TABLE_INHERITED3(nsXMLDocument,
-                                nsIInterfaceRequestor,
-                                nsIChannelEventSink,
-                                nsIDOMXMLDocument)
-  NS_INTERFACE_TABLE_TO_MAP_SEGUE
+  NS_DOCUMENT_INTERFACE_TABLE_BEGIN(nsXMLDocument)
+    NS_INTERFACE_TABLE_ENTRY(nsXMLDocument, nsIInterfaceRequestor)
+    NS_INTERFACE_TABLE_ENTRY(nsXMLDocument, nsIChannelEventSink)
+    NS_INTERFACE_TABLE_ENTRY(nsXMLDocument, nsIDOMXMLDocument)
+  NS_OFFSET_AND_INTERFACE_TABLE_END
+  NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(XMLDocument)
 NS_INTERFACE_MAP_END_INHERITING(nsDocument)
 
 
 NS_IMPL_ADDREF_INHERITED(nsXMLDocument, nsDocument)
 NS_IMPL_RELEASE_INHERITED(nsXMLDocument, nsDocument)
 
 
diff -r 4f1383af8f10 content/xul/content/src/nsXULElement.cpp
--- a/content/xul/content/src/nsXULElement.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/xul/content/src/nsXULElement.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -369,61 +369,31 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_
     }
     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_MEMBER(mPrototype,
                                                     nsXULPrototypeElement)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_ADDREF_INHERITED(nsXULElement, nsGenericElement)
 NS_IMPL_RELEASE_INHERITED(nsXULElement, nsGenericElement)
 
-NS_IMETHODIMP
-nsXULElement::QueryInterface(REFNSIID aIID, void** aInstancePtr)
-{
-    NS_PRECONDITION(aInstancePtr, "null out param");
-
-    if (aIID.Equals(NS_GET_IID(nsXPCOMCycleCollectionParticipant))) {
-      *aInstancePtr = &NS_CYCLE_COLLECTION_NAME(nsXULElement);
-      return NS_OK;
-    }
-
-    nsresult rv = nsGenericElement::QueryInterface(aIID, aInstancePtr);
-    if (NS_SUCCEEDED(rv))
-        return rv;
-
-    nsISupports *inst = nsnull;
-
-    if (aIID.Equals(NS_GET_IID(nsIDOMNode))) {
-        inst = static_cast<nsIDOMNode *>(this);
-    } else if (aIID.Equals(NS_GET_IID(nsIDOMElement))) {
-        inst = static_cast<nsIDOMElement *>(this);
-    } else if (aIID.Equals(NS_GET_IID(nsIDOMXULElement))) {
-        inst = static_cast<nsIDOMXULElement *>(this);
-    } else if (aIID.Equals(NS_GET_IID(nsIScriptEventHandlerOwner))) {
-        inst = static_cast<nsIScriptEventHandlerOwner*>
-                          (new nsScriptEventHandlerOwnerTearoff(this));
-        NS_ENSURE_TRUE(inst, NS_ERROR_OUT_OF_MEMORY);
-    } else if (aIID.Equals(NS_GET_IID(nsIDOMElementCSSInlineStyle))) {
-        inst = static_cast<nsIDOMElementCSSInlineStyle *>
-                          (new nsXULElementTearoff(this));
-        NS_ENSURE_TRUE(inst, NS_ERROR_OUT_OF_MEMORY);
-    } else if (aIID.Equals(NS_GET_IID(nsIClassInfo))) {
-        inst = NS_GetDOMClassInfoInstance(eDOMClassInfo_XULElement_id);
-        NS_ENSURE_TRUE(inst, NS_ERROR_OUT_OF_MEMORY);
-    } else if (aIID.Equals(NS_GET_IID(nsIFrameLoaderOwner))) {
-        inst = static_cast<nsIFrameLoaderOwner*>(new nsXULElementTearoff(this));
-        NS_ENSURE_TRUE(inst, NS_ERROR_OUT_OF_MEMORY);
-    } else {
-        return PostQueryInterface(aIID, aInstancePtr);
-    }
-
-    NS_ADDREF(inst);
- 
-    *aInstancePtr = inst;
-    return NS_OK;
-}
+NS_INTERFACE_TABLE_HEAD_CYCLE_COLLECTION_INHERITED(nsXULElement)
+    NS_NODE_OFFSET_AND_INTERFACE_TABLE_BEGIN(nsXULElement)
+        NS_INTERFACE_TABLE_ENTRY(nsXULElement, nsIDOMNode)
+        NS_INTERFACE_TABLE_ENTRY(nsXULElement, nsIDOMElement)
+        NS_INTERFACE_TABLE_ENTRY(nsXULElement, nsIDOMXULElement)
+    NS_OFFSET_AND_INTERFACE_TABLE_END
+    NS_ELEMENT_INTERFACE_TABLE_TO_MAP_SEGUE
+    NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIScriptEventHandlerOwner,
+                                   new nsScriptEventHandlerOwnerTearoff(this))
+    NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOMElementCSSInlineStyle,
+                                   new nsXULElementTearoff(this))
+    NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIFrameLoaderOwner,
+                                   new nsXULElementTearoff(this))
+    NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(XULElement)
+NS_ELEMENT_INTERFACE_MAP_END
 
 //----------------------------------------------------------------------
 // nsIDOMNode interface
 
 nsresult
 nsXULElement::Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const
 {
     *aResult = nsnull;
diff -r 4f1383af8f10 content/xul/document/src/nsXULDocument.cpp
--- a/content/xul/document/src/nsXULDocument.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/xul/document/src/nsXULDocument.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -372,22 +372,23 @@ NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 
 NS_IMPL_ADDREF_INHERITED(nsXULDocument, nsXMLDocument)
 NS_IMPL_RELEASE_INHERITED(nsXULDocument, nsXMLDocument)
 
 
 // QueryInterface implementation for nsXULDocument
 NS_INTERFACE_TABLE_HEAD_CYCLE_COLLECTION_INHERITED(nsXULDocument)
-    NS_INTERFACE_TABLE_INHERITED4(nsXULDocument,
-                                  nsIXULDocument,
-                                  nsIDOMXULDocument,
-                                  nsIStreamLoaderObserver,
-                                  nsICSSLoaderObserver)
-    NS_INTERFACE_TABLE_TO_MAP_SEGUE
+    NS_DOCUMENT_INTERFACE_TABLE_BEGIN(nsXULDocument)
+      NS_INTERFACE_TABLE_ENTRY(nsXULDocument, nsIXULDocument)
+      NS_INTERFACE_TABLE_ENTRY(nsXULDocument, nsIDOMXULDocument)
+      NS_INTERFACE_TABLE_ENTRY(nsXULDocument, nsIStreamLoaderObserver)
+      NS_INTERFACE_TABLE_ENTRY(nsXULDocument, nsICSSLoaderObserver)
+    NS_OFFSET_AND_INTERFACE_TABLE_END
+    NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
     NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(XULDocument)
 NS_INTERFACE_MAP_END_INHERITING(nsXMLDocument)
 
 
 //----------------------------------------------------------------------
 //
 // nsIDocument interface
 //
diff -r 4f1383af8f10 content/xul/templates/src/nsXULTemplateQueryProcessorXML.cpp
--- a/content/xul/templates/src/nsXULTemplateQueryProcessorXML.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/content/xul/templates/src/nsXULTemplateQueryProcessorXML.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -172,18 +172,16 @@ nsXULTemplateQueryProcessorXML::GetDatas
     if (!root)
         return NS_ERROR_UNEXPECTED;
 
     nsCOMPtr<nsIDocument> doc = root->GetCurrentDoc();
     if (!doc)
         return NS_ERROR_UNEXPECTED;
 
     nsIPrincipal *docPrincipal = doc->NodePrincipal();
-    nsCOMPtr<nsIURI> uri2;
-    docPrincipal->GetURI(getter_AddRefs(uri2));
 
     PRBool hasHadScriptObject = PR_TRUE;
     nsIScriptGlobalObject* scriptObject =
       doc->GetScriptHandlingObject(hasHadScriptObject);
     NS_ENSURE_STATE(scriptObject || !hasHadScriptObject);
 
     nsIScriptContext *context = scriptObject->GetContext();
     NS_ENSURE_TRUE(context, NS_OK);
diff -r 4f1383af8f10 docshell/base/nsDocShell.cpp
--- a/docshell/base/nsDocShell.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/docshell/base/nsDocShell.cpp	Mon Nov 03 05:09:08 2008 -0500
@@ -290,23 +290,23 @@ nsDocShell::nsDocShell():
     mAllowImages(PR_TRUE),
     mFocusDocFirst(PR_FALSE),
     mHasFocus(PR_FALSE),
     mCreatingDocument(PR_FALSE),
     mUseErrorPages(PR_FALSE),
     mObserveErrorPages(PR_TRUE),
     mAllowAuth(PR_TRUE),
     mAllowKeywordFixup(PR_FALSE),
+    mIsOffScreenBrowser(PR_FALSE),
     mFiredUnloadEvent(PR_FALSE),
     mEODForCurrentDocument(PR_FALSE),
     mURIResultedInDocument(PR_FALSE),
     mIsBeingDestroyed(PR_FALSE),
     mIsExecutingOnLoadHandler(PR_FALSE),
     mIsPrintingOrPP(PR_FALSE),
-    mIsOffScreenBrowser(PR_FALSE),
     mSavingOldViewer(PR_FALSE),
     mAppType(nsIDocShell::APP_TYPE_UNKNOWN),
     mChildOffset(0),
     mBusyFlags(BUSY_FLAGS_NONE),
     mMarginWidth(0),
     mMarginHeight(0),
     mItemType(typeContent),
     mDefaultScrollbarPref(Scrollbar_Auto, Scrollbar_Auto),
@@ -3916,41 +3916,39 @@ nsDocShell::SetParentNativeWindow(native
 {
     return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP
 nsDocShell::GetVisibility(PRBool * aVisibility)
 {
     NS_ENSURE_ARG_POINTER(aVisibility);
-    if (!mContentViewer) {
-        *aVisibility = PR_FALSE;
-        return NS_OK;
-    }
-
-    // get the pres shell
+
+    *aVisibility = PR_FALSE;
+
+    if (!mContentViewer)
+        return NS_OK;
+
     nsCOMPtr<nsIPresShell> presShell;
-    NS_ENSURE_SUCCESS(GetPresShell(getter_AddRefs(presShell)),
-                      NS_ERROR_FAILURE);
-    NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
+    GetPresShell(getter_AddRefs(presShell));
+    if (!presShell)
+        return NS_OK;
 
     // get the view manager
     nsIViewManager* vm = presShell->GetViewManager();
     NS_ENSURE_TRUE(vm, NS_ERROR_FAILURE);
 
     // get the root view
     nsIView *view = nsnull; // views are not ref counted
     NS_ENSURE_SUCCESS(vm->GetRootView(view), NS_ERROR_FAILURE);
     NS_ENSURE_TRUE(view, NS_ERROR_FAILURE);
 
     // if our root view is hidden, we are not visible
-    if (view->GetVisibility() == nsViewVisibility_kHide) {
-        *aVisibility = PR_FALSE;
-        return NS_OK;
-    }
+    if (view->GetVisibility() == nsViewVisibility_kHide)
+        return NS_OK;
 
     // otherwise, we must walk up the document and view trees checking
     // for a hidden view, unless we're an off screen browser, which 
     // would make this test meaningless.
 
     nsCOMPtr<nsIDocShellTreeItem> treeItem = this;
     nsCOMPtr<nsIDocShellTreeItem> parentItem;
     treeItem->GetParent(getter_AddRefs(parentItem));
@@ -3959,39 +3957,35 @@ nsDocShell::GetVisibility(PRBool * aVisi
         docShell->GetPresShell(getter_AddRefs(presShell));
 
         nsCOMPtr<nsIDocShell> parentDS = do_QueryInterface(parentItem);
         nsCOMPtr<nsIPresShell> pPresShell;
         parentDS->GetPresShell(getter_AddRefs(pPresShell));
 
         // Null-check for crash in bug 267804
         if (!pPresShell) {
-            NS_NOTREACHED("docshell has null pres shell");
-            *aVisibility = PR_FALSE;
+            NS_NOTREACHED("parent docshell has null pres shell");
             return NS_OK;
         }
 
         nsIContent *shellContent =
             pPresShell->GetDocument()->FindContentForSubDocument(presShell->GetDocument());
         NS_ASSERTION(shellContent, "subshell not in the map");
 
         nsIFrame* frame = pPresShell->GetPrimaryFrameFor(shellContent);
         PRBool isDocShellOffScreen = PR_FALSE;
         docShell->GetIsOffScreenBrowser(&isDocShellOffScreen);
-        if (frame && !frame->AreAncestorViewsVisible() && !isDocShellOffScreen) {
-            *aVisibility = PR_FALSE;
-            return NS_OK;
-        }
+        if (frame && !frame->AreAncestorViewsVisible() && !isDocShellOffScreen)
+            return NS_OK;
 
         treeItem = parentItem;
         treeItem->GetParent(getter_AddRefs(parentItem));
     }
 
-    nsCOMPtr<nsIBaseWindow>
-        treeOwnerAsWin(do_QueryInterface(mTreeOwner));
+    nsCOMPtr<nsIBaseWindow> treeOwnerAsWin(do_QueryInterface(mTreeOwner));
     if (!treeOwnerAsWin) {
         *aVisibility = PR_TRUE;
         return NS_OK;
     }
 
     // Check with the tree owner as well to give embedders a chance to
     // expose visibility as well.
     return treeOwnerAsWin->GetVisibility(aVisibility);
diff -r 4f1383af8f10 gfx/public/nsThemeConstants.h
--- a/gfx/public/nsThemeConstants.h	Sat Nov 01 09:52:29 2008 +0100
+++ b/gfx/public/nsThemeConstants.h	Mon Nov 03 05:09:08 2008 -0500
@@ -4,22 +4,16 @@
 // A typical dialog button.
 #define NS_THEME_BUTTON                                    1
 
 // A radio element within a radio group.
 #define NS_THEME_RADIO                                     2
 
 // A checkbox element. 
 #define NS_THEME_CHECKBOX                                  3
-
-// A small radio button, for HTML forms
-#define NS_THEME_RADIO_SMALL                               4
-
-// A small checkbox, for HTML forms
-#define NS_THEME_CHECKBOX_SMALL                            5
 
 // A rectangular button that contains complex content
 // like images (e.g. HTML <button> elements)
 #define NS_THEME_BUTTON_BEVEL                              7
 
 // The toolbox that contains the toolbars.
 #define NS_THEME_TOOLBOX                                   11
 
diff -r 4f1383af8f10 gfx/thebes/src/gfxAtsuiFonts.cpp
--- a/gfx/thebes/src/gfxAtsuiFonts.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/gfx/thebes/src/gfxAtsuiFonts.cpp	Mon Nov 03 05:09:09 2008 -0500
@@ -173,27 +173,25 @@ DisableUncommonLigatures(ATSUStyle aStyl
 DisableUncommonLigatures(ATSUStyle aStyle)
 {
     static const ATSUFontFeatureType types[] = {
         kLigaturesType,
         kLigaturesType,
         kLigaturesType,
         kLigaturesType,
         kLigaturesType,
-        kLigaturesType,
         kLigaturesType
     };
     static const ATSUFontFeatureType selectors[NS_ARRAY_LENGTH(types)] = {
         kRareLigaturesOffSelector,
         kLogosOffSelector,
         kRebusPicturesOffSelector,
         kDiphthongLigaturesOffSelector,
         kSquaredLigaturesOffSelector,
-        kAbbrevSquaredLigaturesOffSelector,
-        kSymbolLigaturesOffSelector
+        kAbbrevSquaredLigaturesOffSelector
     };
     ATSUSetFontFeatures(aStyle, NS_ARRAY_LENGTH(types), types, selectors);
 }
 
 static void
 DisableCommonLigatures(ATSUStyle aStyle)
 {
     static const ATSUFontFeatureType types[] = {
diff -r 4f1383af8f10 js/src/aclocal.m4
--- a/js/src/aclocal.m4	Sat Nov 01 09:52:29 2008 +0100
+++ b/js/src/aclocal.m4	Mon Nov 03 05:09:09 2008 -0500
@@ -1,10 +1,9 @@ dnl
 dnl
 dnl Local autoconf macros used with mozilla
 dnl The contents of this file are under the Public Domain.
 dnl 
 
-builtin(include, build/autoconf/glib.m4)dnl
 builtin(include, build/autoconf/pkg.m4)dnl
 builtin(include, build/autoconf/nspr.m4)dnl
 builtin(include, build/autoconf/altoptions.m4)dnl
 
diff -r 4f1383af8f10 js/src/build/autoconf/glib.m4
--- a/js/src/build/autoconf/glib.m4	Sat Nov 01 09:52:29 2008 +0100
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,200 +0,0 @@
-# Configure paths for GLIB
-# Owen Taylor     97-11-3
-
-dnl AM_PATH_GLIB([MINIMUM-VERSION, [ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND [, MODULES]]]])
-dnl Test for GLIB, and define GLIB_CFLAGS and GLIB_LIBS, if "gmodule" or 
-dnl gthread is specified in MODULES, pass to glib-config
-dnl
-AC_DEFUN([AM_PATH_GLIB],
-[dnl 
-dnl Get the cflags and libraries from the glib-config script
-dnl
-AC_ARG_WITH(glib-prefix,[  --with-glib-prefix=PFX  Prefix where GLIB is installed (optional)],
-            glib_config_prefix="$withval", glib_config_prefix="")
-AC_ARG_WITH(glib-exec-prefix,[  --with-glib-exec-prefix=PFX
-                          Exec prefix where GLIB is installed (optional)],
-            glib_config_exec_prefix="$withval", glib_config_exec_prefix="")
-AC_ARG_ENABLE(glibtest, [  --disable-glibtest      Do not try to compile and run a test GLIB program],
-		    , enable_glibtest=yes)
-
-  if test x$glib_config_exec_prefix != x ; then
-     glib_config_args="$glib_config_args --exec-prefix=$glib_config_exec_prefix"
-     if test x${GLIB_CONFIG+set} != xset ; then
-        GLIB_CONFIG=$glib_config_exec_prefix/bin/glib-config
-     fi
-  fi
-  if test x$glib_config_prefix != x ; then
-     glib_config_args="$glib_config_args --prefix=$glib_config_prefix"
-     if test x${GLIB_CONFIG+set} != xset ; then
-        GLIB_CONFIG=$glib_config_prefix/bin/glib-config
-     fi
-  fi
-
-  for module in . $4
-  do
-      case "$module" in
-         gmodule) 
-             glib_config_args="$glib_config_args gmodule"
-         ;;
-         gthread) 
-             glib_config_args="$glib_config_args gthread"
-         ;;
-      esac
-  done
-
-  dnl Force a version check to keep upgraded versions from being overridden by the cached value.
-  unset ac_cv_path_GLIB_CONFIG
-
-  AC_PATH_PROG(GLIB_CONFIG, glib-config, no)
-  min_glib_version=ifelse([$1], ,0.99.7,$1)
-  AC_MSG_CHECKING(for GLIB - version >= $min_glib_version)
-  no_glib=""
-  if test "$GLIB_CONFIG" = "no" ; then
-    no_glib=yes
-  else
-    GLIB_CFLAGS=`$GLIB_CONFIG $glib_config_args --cflags`
-    GLIB_LIBS=`$GLIB_CONFIG $glib_config_args --libs`
-    glib_config_major_version=`$GLIB_CONFIG $glib_config_args --version | \
-           sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\1/'`
-    glib_config_minor_version=`$GLIB_CONFIG $glib_config_args --version | \
-           sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\2/'`
-    glib_config_micro_version=`$GLIB_CONFIG $glib_config_args --version | \
-           sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\3/'`
-    if test "x$enable_glibtest" = "xyes" ; then
-      ac_save_CFLAGS="$CFLAGS"
-      ac_save_LIBS="$LIBS"
-      CFLAGS="$CFLAGS $GLIB_CFLAGS"
-      LIBS="$GLIB_LIBS $LIBS"
-dnl
-dnl Now check if the installed GLIB is sufficiently new. (Also sanity
-dnl checks the results of glib-config to some extent
-dnl
-      rm -f conf.glibtest
-      AC_TRY_RUN([
-#include <glib.h>
-#include <stdio.h>
-#include <stdlib.h>
-
-int 
-main ()
-{
-  int major, minor, micro;
-  char *tmp_version;
-
-  system ("touch conf.glibtest");
-
-  /* HP/UX 9 (%@#!) writes to sscanf strings */
-  tmp_version = g_strdup("$min_glib_version");
-  if (sscanf(tmp_version, "%d.%d.%d", &major, &minor, &micro) != 3) {
-     printf("%s, bad version string\n", "$min_glib_version");
-     exit(1);
-   }
-
-  if ((glib_major_version != $glib_config_major_version) ||
-      (glib_minor_version != $glib_config_minor_version) ||
-      (glib_micro_version != $glib_config_micro_version))
-    {
-      printf("\n*** 'glib-config --version' returned %d.%d.%d, but GLIB (%d.%d.%d)\n", 
-             $glib_config_major_version, $glib_config_minor_version, $glib_config_micro_version,
-             glib_major_version, glib_minor_version, glib_micro_version);
-      printf ("*** was found! If glib-config was correct, then it is best\n");
-      printf ("*** to remove the old version of GLIB. You may also be able to fix the error\n");
-      printf("*** by modifying your LD_LIBRARY_PATH environment variable, or by editing\n");
-      printf("*** /etc/ld.so.conf. Make sure you have run ldconfig if that is\n");
-      printf("*** required on your system.\n");
-      printf("*** If glib-config was wrong, set the environment variable GLIB_CONFIG\n");
-      printf("*** to point to the correct copy of glib-config, and remove the file config.cache\n");
-      printf("*** before re-running configure\n");
-    } 
-  else if ((glib_major_version != GLIB_MAJOR_VERSION) ||
-	   (glib_minor_version != GLIB_MINOR_VERSION) ||
-           (glib_micro_version != GLIB_MICRO_VERSION))
-    {
-      printf("*** GLIB header files (version %d.%d.%d) do not match\n",
-	     GLIB_MAJOR_VERSION, GLIB_MINOR_VERSION, GLIB_MICRO_VERSION);
-      printf("*** library (version %d.%d.%d)\n",
-	     glib_major_version, glib_minor_version, glib_micro_version);
-    }
-  else
-    {
-      if ((glib_major_version > major) ||
-        ((glib_major_version == major) && (glib_minor_version > minor)) ||
-        ((glib_major_version == major) && (glib_minor_version == minor) && (glib_micro_version >= micro)))
-      {
-        return 0;
-       }
-     else
-      {
-        printf("\n*** An old version of GLIB (%d.%d.%d) was found.\n",
-               glib_major_version, glib_minor_version, glib_micro_version);
-        printf("*** You need a version of GLIB newer than %d.%d.%d. The latest version of\n",
-	       major, minor, micro);
-        printf("*** GLIB is always available from ftp://ftp.gtk.org.\n");
-        printf("***\n");
-        printf("*** If you have already installed a sufficiently new version, this error\n");
-        printf("*** probably means that the wrong copy of the glib-config shell script is\n");
-        printf("*** being found. The easiest way to fix this is to remove the old version\n");
-        printf("*** of GLIB, but you can also set the GLIB_CONFIG environment to point to the\n");
-        printf("*** correct copy of glib-config. (In this case, you will have to\n");
-        printf("*** modify your LD_LIBRARY_PATH environment variable, or edit /etc/ld.so.conf\n");
-        printf("*** so that the correct libraries are found at run-time))\n");
-      }
-    }
-  return 1;
-}
-],, no_glib=yes,[echo $ac_n "cross compiling; assumed OK... $ac_c"])
-       CFLAGS="$ac_save_CFLAGS"
-       LIBS="$ac_save_LIBS"
-     fi
-  fi
-  if test "x$no_glib" = x ; then
-     AC_MSG_RESULT(yes)
-     ifelse([$2], , :, [$2])     
-  else
-     AC_MSG_RESULT(no)
-     if test "$GLIB_CONFIG" = "no" ; then
-       echo "*** The glib-config script installed by GLIB could not be found"
-       echo "*** If GLIB was installed in PREFIX, make sure PREFIX/bin is in"
-       echo "*** your path, or set the GLIB_CONFIG environment variable to the"
-       echo "*** full path to glib-config."
-     else
-       if test -f conf.glibtest ; then
-        :
-       else
-          echo "*** Could not run GLIB test program, checking why..."
-          CFLAGS="$CFLAGS $GLIB_CFLAGS"
-          LIBS="$LIBS $GLIB_LIBS"
-          AC_TRY_LINK([
-#include <glib.h>
-#include <stdio.h>
-],      [ return ((glib_major_version) || (glib_minor_version) || (glib_micro_version)); ],
-        [ echo "*** The test program compiled, but did not run. This usually means"
-          echo "*** that the run-time linker is not finding GLIB or finding the wrong"
-          echo "*** version of GLIB. If it is not finding GLIB, you'll need to set your"
-          echo "*** LD_LIBRARY_PATH environment variable, or edit /etc/ld.so.conf to point"
-          echo "*** to the installed location  Also, make sure you have run ldconfig if that"
-          echo "*** is required on your system"
-	  echo "***"
-          echo "*** If you have an old version installed, it is best to remove it, although"
-          echo "*** you may also be able to get things to work by modifying LD_LIBRARY_PATH"
-          echo "***"
-          echo "*** If you have a RedHat 5.0 system, you should remove the GTK package that"
-          echo "*** came with the system with the command"
-          echo "***"
-          echo "***    rpm --erase --nodeps gtk gtk-devel" ],
-        [ echo "*** The test program failed to compile or link. See the file config.log for the"
-          echo "*** exact error that occured. This usually means GLIB was incorrectly installed"
-          echo "*** or that you have moved GLIB since it was installed. In the latter case, you"
-          echo "*** may want to edit the glib-config script: $GLIB_CONFIG" ])
-          CFLAGS="$ac_save_CFLAGS"
-          LIBS="$ac_save_LIBS"
-       fi
-     fi
-     GLIB_CFLAGS=""
-     GLIB_LIBS=""
-     ifelse([$3], , :, [$3])
-  fi
-  AC_SUBST(GLIB_CFLAGS)
-  AC_SUBST(GLIB_LIBS)
-  rm -f conf.glibtest
-])
diff -r 4f1383af8f10 js/src/config/Makefile.in
--- a/js/src/config/Makefile.in	Sat Nov 01 09:52:29 2008 +0100
+++ b/js/src/config/Makefile.in	Mon Nov 03 05:09:09 2008 -0500
@@ -54,24 +54,16 @@ HOST_CSRCS	= nsinstall.c pathsub.c
 HOST_CSRCS	= nsinstall.c pathsub.c
 endif
 endif
 
 PLSRCS		= nfspwd.pl revdepth.pl
 
 TARGETS		= $(HOST_PROGRAM) $(PLSRCS:.pl=) $(SIMPLE_PROGRAMS)
 
-ifndef CROSS_COMPILE
-ifdef USE_ELF_DYNSTR_GC
-TARGETS		+= elf-dynstr-gc
-MAKE_DIRS	+= $(MDDEPDIR)
-GARBAGE_DIRS	+= $(MDDEPDIR)
-endif
-endif
-
 # IMPORTANT: Disable NSBUILDROOT for this directory only, otherwise we have
 # a recursive rule for finding nsinstall and the Perl scripts.
 ifdef NSBUILDROOT
 override NSBUILDROOT :=
 endif
 
 ifdef GNU_CC
 MODULE_OPTIMIZE_FLAGS = -O3
@@ -101,21 +93,14 @@ export::
 	$(PERL) $(srcdir)/preprocessor.pl $(DEFINES) $(ACDEFINES) \
 		-DBUILD_STATIC_LIBS=$(BUILD_STATIC_LIBS) \
 		$(srcdir)/system-headers | $(PERL) $(srcdir)/make-system-wrappers.pl system_wrappers
 	$(INSTALL) system_wrappers $(DIST)/include
 
 GARBAGE_DIRS += system_wrappers
 endif
 
-ifndef CROSS_COMPILE
-ifdef USE_ELF_DYNSTR_GC
-elf-dynstr-gc: elf-dynstr-gc.c Makefile Makefile.in
-	$(CC) $(COMPILE_CFLAGS) $(GLIB_CFLAGS) -o $@ $< $(LDFLAGS) $(GLIB_LIBS) 
-endif
-endif
-
 FORCE:
 
 ifdef MKDEPEND_DIR
 clean clobber realclean clobber_all::
 	cd $(MKDEPEND_DIR); $(MAKE) $@
 endif
diff -r 4f1383af8f10 js/src/config/autoconf.mk.in
--- a/js/src/config/autoconf.mk.in	Sat Nov 01 09:52:29 2008 +0100
+++ b/js/src/config/autoconf.mk.in	Mon Nov 03 05:09:09 2008 -0500
@@ -91,17 +91,16 @@ MOZ_VTUNE       = @MOZ_VTUNE@
 MOZ_VTUNE       = @MOZ_VTUNE@
 DEHYDRA_PATH    = @DEHYDRA_PATH@
 
 ENABLE_EAZEL_PROFILER=@ENABLE_EAZEL_PROFILER@
 EAZEL_PROFILER_CFLAGS=@EAZEL_PROFILER_CFLAGS@
 EAZEL_PROFILER_LIBS=@EAZEL_PROFILER_LIBS@
 GC_LEAK_DETECTOR = @GC_LEAK_DETECTOR@
 NS_TRACE_MALLOC = @NS_TRACE_MALLOC@
-USE_ELF_DYNSTR_GC = @USE_ELF_DYNSTR_GC@
 INCREMENTAL_LINKER = @INCREMENTAL_LINKER@
 MACOSX_DEPLOYMENT_TARGET = @MACOSX_DEPLOYMENT_TARGET@
 BUILD_STATIC_LIBS = @BUILD_STATIC_LIBS@
 ENABLE_TESTS	= @ENABLE_TESTS@
 JS_ULTRASPARC_OPTS = @JS_ULTRASPARC_OPTS@
 JS_STATIC_BUILD = @JS_STATIC_BUILD@
 
 TAR=@TAR@
@@ -281,20 +280,16 @@ DSO_LDOPTS              = @DSO_LDOPTS@
 DSO_LDOPTS              = @DSO_LDOPTS@
 DLL_SUFFIX              = @DLL_SUFFIX@
 
 NO_LD_ARCHIVE_FLAGS     = @NO_LD_ARCHIVE_FLAGS@
 
 MOZ_TOOLKIT_REGISTRY_CFLAGS = \
 	$(TK_CFLAGS)
 
-GLIB_CFLAGS	= @GLIB_CFLAGS@
-GLIB_LIBS	= @GLIB_LIBS@
-GLIB_GMODULE_LIBS	= @GLIB_GMODULE_LIBS@
-
 MOZ_NATIVE_MAKEDEPEND	= @SYSTEM_MAKEDEPEND@
 
 # Used for LD_LIBRARY_PATH
 LIBS_PATH       = @LIBS_PATH@
 
 MOZ_AUTO_DEPS	= @MOZ_AUTO_DEPS@
 COMPILER_DEPEND = @COMPILER_DEPEND@
 MDDEPDIR        := @MDDEPDIR@
diff -r 4f1383af8f10 js/src/config/elf-dynstr-gc.c
--- a/js/src/config/elf-dynstr-gc.c	Sat Nov 01 09:52:29 2008 +0100
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,1245 +0,0 @@
-/* elf_gc_dynst
- *
- * This is a program that removes unreferenced strings from the .dynstr
- * section in ELF shared objects. It also shrinks the .dynstr section and
- * relocates all symbols after it.
- *
- * This program was written and copyrighted by:
- *   Alexander Larsson <alla@lysator.liu.se>
- *
- *
- *
- * ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org Code.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 2001
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either of the GNU General Public License Version 2 or later (the "GPL"),
- * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-
-#include <stdio.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/mman.h>
-
-#include <elf.h>
-#include <glib.h>
-#include <string.h>
-
-
-Elf32_Ehdr *elf_header = NULL;
-#define FILE_OFFSET(offset) ((unsigned char *)(elf_header) + (offset))
-
-struct dynamic_symbol {
-  Elf32_Word old_index;
-  Elf32_Word new_index;
-  char *string;
-};
-
-GHashTable *used_dynamic_symbols = NULL;
-/* Data is dynamic_symbols, hashes on old_index */
-Elf32_Word hole_index;
-Elf32_Word hole_end;
-Elf32_Word hole_len;
-
-Elf32_Addr hole_addr_start;
-Elf32_Addr hole_addr_remap_start;
-Elf32_Addr hole_addr_remap_end;
-
-int need_byteswap;
-
-unsigned char machine_type;
-
-Elf32_Word
-read_word(Elf32_Word w)
-{
-  if (need_byteswap) 
-    w = GUINT32_SWAP_LE_BE(w);
-  return w;
-}
-
-Elf32_Sword
-read_sword(Elf32_Sword w)
-{
-  if (need_byteswap) 
-    w = (Elf32_Sword)GUINT32_SWAP_LE_BE((guint32)w);
-  return w;
-}
-
-void 
-write_word(Elf32_Word *ptr, Elf32_Word w)
-{
-  if (need_byteswap) 
-    w = GUINT32_SWAP_LE_BE(w);
-  *ptr = w;
-}
-
-Elf32_Half
-read_half(Elf32_Half h)
-{
-  if (need_byteswap) 
-    h = GUINT16_SWAP_LE_BE(h);
-  return h;
-}
-
-void 
-write_half(Elf32_Half *ptr, Elf32_Half h)
-{
-  if (need_byteswap) 
-    h = GUINT16_SWAP_LE_BE(h);
-  *ptr = h;
-}
-
-void
-setup_byteswapping(unsigned char ei_data)
-{
-  need_byteswap = 0;
-#if G_BYTE_ORDER == G_BIG_ENDIAN
-  if (ei_data == ELFDATA2LSB)
-    need_byteswap = 1;
-#endif
-#if G_BYTE_ORDER == G_LITTLE_ENDIAN
-  if (ei_data == ELFDATA2MSB)
-    need_byteswap = 1;
-#endif
-}
-
-
-Elf32_Shdr *
-elf_find_section_num(int section_index)
-{
-  Elf32_Shdr *section;
-  Elf32_Word sectionsize;
-
-  section = (Elf32_Shdr *)FILE_OFFSET(read_word(elf_header->e_shoff));
-  sectionsize = read_half(elf_header->e_shentsize);
-
-  section = (Elf32_Shdr *)((char *)section + sectionsize*section_index);
-
-  return section;
-}
-
-Elf32_Shdr *
-elf_find_section_named(char *name)
-{
-  Elf32_Shdr *section;
-  Elf32_Shdr *strtab_section;
-  Elf32_Word sectionsize;
-  int numsections;
-  char *strtab;
-  int i = 0;
-
-  section = (Elf32_Shdr *)FILE_OFFSET(read_word(elf_header->e_shoff));
-
-  strtab_section = elf_find_section_num(read_half(elf_header->e_shstrndx));
-  
-  strtab = (char *)FILE_OFFSET(read_word(strtab_section->sh_offset));
-  
-  sectionsize = read_half(elf_header->e_shentsize);
-  numsections = read_half(elf_header->e_shnum);
-
-  for (i=0;i<numsections;i++) {
-    if (strcmp(&strtab[read_word(section->sh_name)], name) == 0) {
-      return section;
-    }
-    section = (Elf32_Shdr *)((char *)section + sectionsize);
-  }
-  return NULL;
-}
-
-
-Elf32_Shdr *
-elf_find_section(Elf32_Word sh_type)
-{
-  Elf32_Shdr *section;
-  Elf32_Word sectionsize;
-  int numsections;
-  int i = 0;
-
-  section = (Elf32_Shdr *)FILE_OFFSET(read_word(elf_header->e_shoff));
-  sectionsize = read_half(elf_header->e_shentsize);
-  numsections = read_half(elf_header->e_shnum);
-
-  for (i=0;i<numsections;i++) {
-    if (read_word(section->sh_type) == sh_type) {
-      return section;
-    }
-    section = (Elf32_Shdr *)((char *)section + sectionsize);
-  }
-  return NULL;
-}
-
-Elf32_Shdr *
-elf_find_next_higher_section(Elf32_Word offset)
-{
-  Elf32_Shdr *section;
-  Elf32_Shdr *higher;
-  Elf32_Word sectionsize;
-  int numsections;
-  int i = 0;
-
-  section = (Elf32_Shdr *)FILE_OFFSET(read_word(elf_header->e_shoff));
-  sectionsize = read_half(elf_header->e_shentsize);
-  numsections = read_half(elf_header->e_shnum);
-
-  higher = NULL;
-
-  for (i=0;i<numsections;i++) {
-    if (read_word(section->sh_offset) >= offset) {
-      if (higher == NULL) {
-	higher = section;
-      } else if (read_word(section->sh_offset) < read_word(higher->sh_offset)) {
-	higher = section;
-      }
-    }
-    
-    section = (Elf32_Shdr *)((char *)section + sectionsize);
-  }
-  
-  return higher;
-}
-
-Elf32_Word
-vma_to_offset(Elf32_Addr addr)
-{
-  Elf32_Shdr *section;
-  Elf32_Shdr *higher;
-  Elf32_Word sectionsize;
-  int numsections;
-  int i = 0;
-
-  section = (Elf32_Shdr *)FILE_OFFSET(read_word(elf_header->e_shoff));
-  sectionsize = read_half(elf_header->e_shentsize);
-  numsections = read_half(elf_header->e_shnum);
-
-  higher = NULL;
-
-  for (i=0;i<numsections;i++) {
-    if ( (addr >= read_word(section->sh_addr)) &&
-	 (addr < read_word(section->sh_addr) + read_word(section->sh_size)) ) {
-      return read_word(section->sh_offset) + (addr - read_word(section->sh_addr));
-    }
-    
-    section = (Elf32_Shdr *)((char *)section + sectionsize);
-  }
-
-  fprintf(stderr, "Warning, unable to convert address %d (0x%x) to file offset\n",
-	 addr, addr);
-  return 0;
-}
-
-
-void
-find_segment_addr_min_max(Elf32_Word file_offset,
-			  Elf32_Addr *start, Elf32_Addr *end)
-{
-  Elf32_Phdr *segment;
-  Elf32_Word segmentsize;
-  int numsegments;
-  int i = 0;
-
-  segment = (Elf32_Phdr *)FILE_OFFSET(read_word(elf_header->e_phoff));
-  segmentsize = read_half(elf_header->e_phentsize);
-  numsegments = read_half(elf_header->e_phnum);
-
-  for (i=0;i<numsegments;i++) {
-    if ((file_offset >= read_word(segment->p_offset)) &&
-	(file_offset < read_word(segment->p_offset) + read_word(segment->p_filesz)))  {
-      *start = read_word(segment->p_vaddr);
-      *end = read_word(segment->p_vaddr) + read_word(segment->p_memsz);
-      return;
-    }
-
-    segment = (Elf32_Phdr *)((char *)segment + segmentsize);
-  }
-  fprintf(stderr, "Error: Couldn't find segment in find_segment_addr_min_max()\n");
-}
-
-void *
-dynamic_find_tag(Elf32_Shdr *dynamic, Elf32_Sword d_tag)
-{
-  int i;
-  Elf32_Dyn *element;
-
-  element = (Elf32_Dyn *)FILE_OFFSET(read_word(dynamic->sh_offset));
-  for (i=0; read_sword(element[i].d_tag) != DT_NULL; i++) {
-    if (read_sword(element[i].d_tag) == d_tag) {
-      return FILE_OFFSET(read_word(element[i].d_un.d_ptr));
-    }
-  }
-  
-  return NULL;
-}
-
-Elf32_Word
-fixup_offset(Elf32_Word offset)
-{
-  if (offset >= hole_index) {
-    return offset - hole_len;
-  }
-  return offset;
-}
-
-Elf32_Word
-fixup_size(Elf32_Word offset, Elf32_Word size)
-{
-  /* Note: Doesn't handle the cases where the hole and the size intersect
-     partially. */
-  
-  if ( (hole_index >= offset) &&
-       (hole_index < offset + size)){
-    return size - hole_len;
-  }
-  
-  return size;
-}
-
-Elf32_Addr
-fixup_addr(Elf32_Addr addr)
-{
-  if (addr == 0)
-    return 0;
-
-  /*
-  if ( (addr < hole_addr_remap_start) ||
-       (addr >= hole_addr_remap_end))
-    return addr;
-  */
-  
-  if (addr >= hole_addr_start) {
-    return addr - hole_len;
-  }
-  return addr;
-}
-
-Elf32_Word
-fixup_addr_size(Elf32_Addr addr, Elf32_Word size)
-{
-  /* Note: Doesn't handle the cases where the hole and the size intersect
-     partially. */
-  /*
-  if ( (addr < hole_addr_remap_start) ||
-       (addr >= hole_addr_remap_end))
-    return size;
-  */
-  if ( (hole_addr_start >= addr) &&
-       (hole_addr_start < addr + size)){
-    return size - hole_len;
-  }
-  
-  return size;
-}
-
-void
-possibly_add_string(int name_idx, const char *name)
-{
-  struct dynamic_symbol *dynamic_symbol;
-  if (name_idx != 0) {
-    dynamic_symbol = g_hash_table_lookup(used_dynamic_symbols, (gpointer) name_idx);
-    
-    if (dynamic_symbol == NULL) {
-      
-      dynamic_symbol = g_new(struct dynamic_symbol, 1);
-      
-      dynamic_symbol->old_index = name_idx;
-      dynamic_symbol->new_index = 0;
-      dynamic_symbol->string = g_strdup(name);
-      
-      g_hash_table_insert(used_dynamic_symbols, (gpointer)name_idx, dynamic_symbol);
-      /*printf("added dynamic string: %s (%d)\n", dynamic_symbol->string, name_idx);*/
-    }
-  }
-}
-
-Elf32_Word
-fixup_string(Elf32_Word old_idx)
-{
-  struct dynamic_symbol *dynamic_symbol;
-
-  if (old_idx == 0)
-    return 0;
-  
-  dynamic_symbol = g_hash_table_lookup(used_dynamic_symbols, (gpointer) old_idx);
-
-  if (dynamic_symbol == NULL) {
-    fprintf(stderr, "AAAAAAAAAAAARGH!? Unknown string found in fixup (index: %d)!\n", old_idx);
-    return 0;
-  }
-  
-  return dynamic_symbol->new_index;
-}
-
-
-
-void
-add_strings_from_dynsym(Elf32_Shdr *dynsym, char *strtab)
-{
-  Elf32_Sym *symbol;
-  Elf32_Sym *symbol_end;
-  Elf32_Word entry_size;
-  
-
-  symbol = (Elf32_Sym *)FILE_OFFSET(read_word(dynsym->sh_offset));
-  symbol_end = (Elf32_Sym *)FILE_OFFSET(read_word(dynsym->sh_offset) + read_word(dynsym->sh_size));
-  entry_size = read_word(dynsym->sh_entsize);
-
-  while (symbol < symbol_end) {
-    int name_idx;
-    struct dynamic_symbol *dynamic_symbol;
-
-    name_idx = read_word(symbol->st_name);
-    possibly_add_string(name_idx, &strtab[name_idx]);
-
-    
-    symbol = (Elf32_Sym *)((char *)symbol + entry_size);
-  }
-}
-
-
-void
-fixup_strings_in_dynsym(Elf32_Shdr *dynsym)
-{
-  Elf32_Sym *symbol;
-  Elf32_Sym *symbol_end;
-  Elf32_Word entry_size;
-  
-
-  symbol = (Elf32_Sym *)FILE_OFFSET(read_word(dynsym->sh_offset));
-  symbol_end = (Elf32_Sym *)FILE_OFFSET(read_word(dynsym->sh_offset) + read_word(dynsym->sh_size));
-  entry_size = read_word(dynsym->sh_entsize);
-  
-  while (symbol < symbol_end) {
-    struct dynamic_symbol *dynamic_symbol;
-
-    write_word(&symbol->st_name,
-	       fixup_string(read_word(symbol->st_name)));
-			 
-    symbol = (Elf32_Sym *)((char *)symbol + entry_size);
-  }
-}
-
-
-void
-add_strings_from_dynamic(Elf32_Shdr *dynamic, char *strtab)
-{
-  int i;
-  int name_idx;
-  Elf32_Dyn *element;
-  Elf32_Word entry_size;
-
-  entry_size = read_word(dynamic->sh_entsize);
-  
-
-  element = (Elf32_Dyn *)FILE_OFFSET(read_word(dynamic->sh_offset));
-  while (read_sword(element->d_tag) != DT_NULL) {
-
-    switch(read_sword(element->d_tag)) {
-    case DT_NEEDED:
-    case DT_SONAME:
-    case DT_RPATH:
-      name_idx = read_word(element->d_un.d_val);
-      /*if (name_idx) printf("d_tag: %d\n", element->d_tag);*/
-      possibly_add_string(name_idx, &strtab[name_idx]);
-      break;
-    default:
-      ;
-      /*printf("unhandled d_tag: %d (0x%x)\n", element->d_tag, element->d_tag);*/
-    }
-
-    element = (Elf32_Dyn *)((char *)element + entry_size);
-  }
-  
-}
-
-void
-fixup_strings_in_dynamic(Elf32_Shdr *dynamic)
-{
-  int i;
-  int name_idx;
-  Elf32_Dyn *element;
-  Elf32_Word entry_size;
-
-  entry_size = read_word(dynamic->sh_entsize);
-
-  element = (Elf32_Dyn *)FILE_OFFSET(read_word(dynamic->sh_offset));
-  while (read_sword(element->d_tag) != DT_NULL) {
-
-    switch(read_sword(element->d_tag)) {
-    case DT_NEEDED:
-    case DT_SONAME:
-    case DT_RPATH:
-      write_word(&element->d_un.d_val,
-		 fixup_string(read_word(element->d_un.d_val)));
-      break;
-    default:
-      ;
-      /*printf("unhandled d_tag: %d (0x%x)\n", element->d_tag, element->d_tag);*/
-    }
-
-    element = (Elf32_Dyn *)((char *)element + entry_size);
-  }
-  
-}
-
-
-void
-add_strings_from_ver_d(Elf32_Shdr *ver_d, char *strtab)
-{
-  Elf32_Verdaux *veraux;
-  Elf32_Verdef *verdef;
-  int num_aux;
-  int name_idx;
-  int i;
-  int cont;
-
-  verdef = (Elf32_Verdef *)FILE_OFFSET(read_word(ver_d->sh_offset));
-
-  do {
-    num_aux = read_half(verdef->vd_cnt);
-    veraux = (Elf32_Verdaux *)((char *)verdef + read_word(verdef->vd_aux));
-    for (i=0; i<num_aux; i++) {
-      name_idx = read_word(veraux->vda_name);
-      possibly_add_string(name_idx, &strtab[name_idx]);
-      veraux = (Elf32_Verdaux *)((char *)veraux + read_word(veraux->vda_next));
-    }
-
-    cont = read_word(verdef->vd_next) != 0;
-    verdef = (Elf32_Verdef *)((char *)verdef + read_word(verdef->vd_next));
-  } while (cont);
-  
-}
-
-void
-fixup_strings_in_ver_d(Elf32_Shdr *ver_d)
-{
-  Elf32_Verdaux *veraux;
-  Elf32_Verdef *verdef;
-  int num_aux;
-  int name_idx;
-  int i;
-  int cont;
-
-  verdef = (Elf32_Verdef *)FILE_OFFSET(read_word(ver_d->sh_offset));
-
-  do {
-    num_aux = read_half(verdef->vd_cnt);
-    veraux = (Elf32_Verdaux *)((char *)verdef + read_word(verdef->vd_aux));
-    for (i=0; i<num_aux; i++) {
-      write_word(&veraux->vda_name,
-		 fixup_string(read_word(veraux->vda_name)));
-      veraux = (Elf32_Verdaux *)((char *)veraux + read_word(veraux->vda_next));
-    }
-
-    cont = read_word(verdef->vd_next) != 0;
-    verdef = (Elf32_Verdef *)((char *)verdef + read_word(verdef->vd_next));
-  } while (cont);
-  
-}
-
-void
-add_strings_from_ver_r(Elf32_Shdr *ver_r, char *strtab)
-{
-  Elf32_Vernaux *veraux;
-  Elf32_Verneed *verneed;
-  int num_aux;
-  int name_idx;
-  int i;
-  int cont;
-
-  verneed = (Elf32_Verneed *)FILE_OFFSET(read_word(ver_r->sh_offset));
-
-  do {
-    name_idx = read_word(verneed->vn_file);
-    possibly_add_string(name_idx, &strtab[name_idx]);
-    num_aux = read_half(verneed->vn_cnt);
-    veraux = (Elf32_Vernaux *)((char *)verneed + read_word(verneed->vn_aux));
-    for (i=0; i<num_aux; i++) {
-      name_idx = read_word(veraux->vna_name);
-      possibly_add_string(name_idx, &strtab[name_idx]);
-      veraux = (Elf32_Vernaux *)((char *)veraux + read_word(veraux->vna_next));
-    }
-
-    cont = read_word(verneed->vn_next) != 0;
-    verneed = (Elf32_Verneed *)((char *)verneed + read_word(verneed->vn_next));
-  } while (cont);
-}
-
-void
-fixup_strings_in_ver_r(Elf32_Shdr *ver_r)
-{
-  Elf32_Vernaux *veraux;
-  Elf32_Verneed *verneed;
-  int num_aux;
-  int name_idx;
-  int i;
-  int cont;
-
-  verneed = (Elf32_Verneed *)FILE_OFFSET(read_word(ver_r->sh_offset));
-
-  do {
-    write_word(&verneed->vn_file,
-	       fixup_string(read_word(verneed->vn_file)));
-    num_aux = read_half(verneed->vn_cnt);
-    veraux = (Elf32_Vernaux *)((char *)verneed + read_word(verneed->vn_aux));
-    for (i=0; i<num_aux; i++) {
-      write_word(&veraux->vna_name,
-		 fixup_string(read_word(veraux->vna_name)));
-      veraux = (Elf32_Vernaux *)((char *)veraux + read_word(veraux->vna_next));
-    }
-
-    cont = read_word(verneed->vn_next) != 0;
-    verneed = (Elf32_Verneed *)((char *)verneed + read_word(verneed->vn_next));
-  } while (cont);
-}
-
-gboolean sum_size(gpointer	key,
-		  struct dynamic_symbol *sym,
-		  int *size)
-{
-  *size += strlen(sym->string) + 1;
-  return 1;
-}
-
-struct index_n_dynstr {
-  int index;
-  unsigned char *dynstr;
-};
-
-gboolean output_string(gpointer	key,
-		       struct dynamic_symbol *sym,
-		       struct index_n_dynstr *x)
-{
-  sym->new_index = x->index;
-  memcpy(x->dynstr + x->index, sym->string, strlen(sym->string) + 1);
-  x->index += strlen(sym->string) + 1;
-  return 1;
-}
-
-
-unsigned char *
-generate_new_dynstr(Elf32_Word *size_out)
-{
-  int size;
-  unsigned char *new_dynstr;
-  struct index_n_dynstr x;
-
-  size = 1; /* first a zero */
-  g_hash_table_foreach	(used_dynamic_symbols,
-			 (GHFunc)sum_size,
-			 &size);
-
-
-  new_dynstr = g_malloc(size);
-
-  new_dynstr[0] = 0;
-  x.index = 1;
-  x.dynstr = new_dynstr;
-  g_hash_table_foreach	(used_dynamic_symbols,
-			 (GHFunc)output_string,
-			 &x);
-  
-  *size_out = size;
-  return new_dynstr;
-}
-
-void
-remap_sections(void)
-{
-  Elf32_Shdr *section;
-  Elf32_Word sectionsize;
-  int numsections;
-  int i = 0;
-
-  section = (Elf32_Shdr *)FILE_OFFSET(read_word(elf_header->e_shoff));
-  sectionsize = read_half(elf_header->e_shentsize);
-  numsections = read_half(elf_header->e_shnum);
-
-  for (i=0;i<numsections;i++) {
-    write_word(&section->sh_size,
-	       fixup_size(read_word(section->sh_offset),
-			  read_word(section->sh_size)));
-    write_word(&section->sh_offset,
-	       fixup_offset(read_word(section->sh_offset)));
-    write_word(&section->sh_addr,
-	       fixup_addr(read_word(section->sh_addr)));
-    
-    section = (Elf32_Shdr *)((char *)section + sectionsize);
-  }
-}
-
-
-void
-remap_segments(void)
-{
-  Elf32_Phdr *segment;
-  Elf32_Word segmentsize;
-  Elf32_Word p_align;
-  int numsegments;
-  int i = 0;
-
-  segment = (Elf32_Phdr *)FILE_OFFSET(read_word(elf_header->e_phoff));
-  segmentsize = read_half(elf_header->e_phentsize);
-  numsegments = read_half(elf_header->e_phnum);
-
-  for (i=0;i<numsegments;i++) {
-    write_word(&segment->p_filesz,
-	       fixup_size(read_word(segment->p_offset),
-			  read_word(segment->p_filesz)));
-    write_word(&segment->p_offset,
-	       fixup_offset(read_word(segment->p_offset)));
-
-    write_word(&segment->p_memsz,
-	       fixup_addr_size(read_word(segment->p_vaddr),
-			       read_word(segment->p_memsz)));
-    write_word(&segment->p_vaddr,
-	       fixup_addr(read_word(segment->p_vaddr)));
-    write_word(&segment->p_paddr,
-	       read_word(segment->p_vaddr));
-
-    /* Consistancy checking: */
-    p_align = read_word(segment->p_align);
-    if (p_align > 1) {
-      if ((read_word(segment->p_vaddr) - read_word(segment->p_offset))%p_align != 0) {
-	fprintf(stderr, "Warning, creating non-aligned segment addr: %x offset: %x allign: %x\n",
-		read_word(segment->p_vaddr), read_word(segment->p_offset), p_align);
-      }
-    }
-    
-    segment = (Elf32_Phdr *)((char *)segment + segmentsize);
-  }
-}
-
-void
-remap_elf_header(void)
-{
-  write_word(&elf_header->e_phoff,
-	     fixup_offset(read_word(elf_header->e_phoff)));
-  write_word(&elf_header->e_shoff,
-	     fixup_offset(read_word(elf_header->e_shoff)));
-
-  write_word(&elf_header->e_entry,
-	     fixup_addr(read_word(elf_header->e_entry)));
-}
-
-void
-remap_symtab(Elf32_Shdr *symtab)
-{
-  Elf32_Sym *symbol;
-  Elf32_Sym *symbol_end;
-  Elf32_Word entry_size;
-
-  symbol = (Elf32_Sym *)FILE_OFFSET(read_word(symtab->sh_offset));
-  symbol_end = (Elf32_Sym *)FILE_OFFSET(read_word(symtab->sh_offset) +
-					read_word(symtab->sh_size));
-  entry_size = read_word(symtab->sh_entsize);
-
-  while (symbol < symbol_end) {
-    write_word(&symbol->st_value,
-	       fixup_addr(read_word(symbol->st_value)));
-    symbol = (Elf32_Sym *)((char *)symbol + entry_size);
-  }
-}
-
-
-/* Ugly global variables: */
-Elf32_Addr got_data_start = 0;
-Elf32_Addr got_data_end = 0;
-
-
-void
-remap_rel_section(Elf32_Rel *rel, Elf32_Word size, Elf32_Word entry_size)
-{
-  Elf32_Rel *rel_end;
-  Elf32_Word offset;
-  Elf32_Addr *addr;
-  Elf32_Word type;
-
-  rel_end = (Elf32_Rel *)((char *)rel + size);
-
-  while (rel < rel_end) {
-    type = ELF32_R_TYPE(read_word(rel->r_info)); 
-    switch (machine_type) {
-    case EM_386:
-      if ((type == R_386_RELATIVE) || (type == R_386_JMP_SLOT)) {
-	/* We need to relocate the data this is pointing to too. */
-	offset = vma_to_offset(read_word(rel->r_offset));
-	
-	addr =  (Elf32_Addr *)FILE_OFFSET(offset);
-	write_word(addr, 
-		   fixup_addr(read_word(*addr)));
-      }
-      write_word(&rel->r_offset,
-		 fixup_addr(read_word(rel->r_offset)));
-      break;
-    case EM_PPC:
-      /* The PPC always uses RELA relocations */
-      break;
-    }
-
-    
-    rel = (Elf32_Rel *)((char *)rel + entry_size);
-  }
-}
-
-void
-remap_rela_section(Elf32_Rela *rela, Elf32_Word size, Elf32_Word entry_size)
-{
-  Elf32_Rela *rela_end;
-  Elf32_Addr *addr;
-  Elf32_Word offset;
-  Elf32_Word type;
-  Elf32_Word bitmask;
-
-  rela_end = (Elf32_Rela *)((char *)rela + size);
-
-  while (rela < rela_end) {
-    type = ELF32_R_TYPE(read_word(rela->r_info));
-    switch (machine_type) {
-    case EM_386:
-      if ((type == R_386_RELATIVE) || (type == R_386_JMP_SLOT)) {
-	/* We need to relocate the data this is pointing to too. */
-	offset = vma_to_offset(read_word(rela->r_offset));
-	
-	addr =  (Elf32_Addr *)FILE_OFFSET(offset);
-	write_word(addr,
-		   fixup_addr(read_word(*addr)));
-      }
-      write_word(&rela->r_offset,
-		 fixup_addr(read_word(rela->r_offset)));
-      break;
-    case EM_PPC:
-/* Some systems do not have PowerPC relocations defined */
-#ifdef R_PPC_NONE
-      switch (type) {
-      case R_PPC_RELATIVE:
-	write_word((Elf32_Word *)&rela->r_addend,
-		   fixup_addr(read_word(rela->r_addend)));
-	/* Fall through for 32bit offset fixup */
-      case R_PPC_ADDR32:
-      case R_PPC_GLOB_DAT:
-      case R_PPC_JMP_SLOT:
-	write_word(&rela->r_offset,
-		   fixup_addr(read_word(rela->r_offset)));
-	break;
-      case R_PPC_NONE:
-	break;
-      default:
-	fprintf(stderr, "Warning, unhandled PPC relocation type %d\n", type);
-      }
-#endif
-      break;
-    }
-    
-    rela = (Elf32_Rela *)((char *)rela + entry_size);
-  }
-}
-
-void 
-remap_i386_got(void)
-{
-  Elf32_Shdr *got_section;
-  Elf32_Addr *got;
-  Elf32_Addr *got_end;
-  Elf32_Word entry_size;
-
-  got_section = elf_find_section_named(".got");
-  if (got_section == NULL) {
-    fprintf(stderr, "Warning, no .got section\n");
-    return;
-  }
-
-  got_data_start = read_word(got_section->sh_offset);
-  got_data_end = got_data_start + read_word(got_section->sh_size);
-  
-  got = (Elf32_Addr *)FILE_OFFSET(got_data_start);
-  got_end = (Elf32_Addr *)FILE_OFFSET(got_data_end);
-  entry_size = read_word(got_section->sh_entsize);
-
-  write_word(got,
-	     fixup_addr(read_word(*got))); /* Pointer to .dynamic */
-}
-
-void 
-remap_ppc_got(void)
-{
-  Elf32_Shdr *got_section;
-  Elf32_Addr *got;
-  Elf32_Addr *got_end;
-  Elf32_Word entry_size;
-
-  got_section = elf_find_section_named(".got");
-  if (got_section == NULL) {
-    fprintf(stderr, "Warning, no .got section\n");
-    return;
-  }
-
-  got_data_start = read_word(got_section->sh_offset);
-  got_data_end = got_data_start + read_word(got_section->sh_size);
-  
-  got = (Elf32_Addr *)FILE_OFFSET(got_data_start);
-  got_end = (Elf32_Addr *)FILE_OFFSET(got_data_end);
-  entry_size = read_word(got_section->sh_entsize);
-
-  /* Skip reserved part.
-   * Note that this should really be found by finding the
-   * _GLOBAL_OFFSET_TABLE symbol, as it could (according to
-   * the spec) point to the middle of the got.
-   */
-  got = (Elf32_Addr *)((char *)got + entry_size); /* Skip blrl instruction */
-  write_word(got,
-	     fixup_addr(read_word(*got))); /* Pointer to .dynamic */
-}
-
-
-Elf32_Word
-get_dynamic_val(Elf32_Shdr *dynamic, Elf32_Sword tag)
-{
-  Elf32_Dyn *element;
-  Elf32_Word entry_size;
-
-  entry_size = read_word(dynamic->sh_entsize);
-
-  element = (Elf32_Dyn *)FILE_OFFSET(read_word(dynamic->sh_offset));
-  while (read_sword(element->d_tag) != DT_NULL) {
-    if (read_sword(element->d_tag) == tag) {
-      return read_word(element->d_un.d_val);
-    }
-    element = (Elf32_Dyn *)((char *)element + entry_size);
-  }
-  return 0;
-}
-
-void
-remap_dynamic(Elf32_Shdr *dynamic, Elf32_Word new_dynstr_size)
-{
-  Elf32_Dyn *element;
-  Elf32_Word entry_size;
-  Elf32_Word rel_size;
-  Elf32_Word rel_entry_size;
-  Elf32_Rel *rel;
-  Elf32_Rela *rela;
-  int jmprel_overlaps;
-  Elf32_Word rel_start, rel_end, jmprel_start, jmprel_end;
-    
-  entry_size = read_word(dynamic->sh_entsize);
-
-  /* Find out if REL/RELA and JMPREL overlaps: */
-  if (get_dynamic_val(dynamic, DT_PLTREL) == DT_REL) {
-    rel_start = get_dynamic_val(dynamic, DT_REL);
-    rel_end = rel_start + get_dynamic_val(dynamic, DT_RELSZ);
-  } else {
-    rel_start = get_dynamic_val(dynamic, DT_RELA);
-    rel_end = rel_start + get_dynamic_val(dynamic, DT_RELASZ);
-  }
-  jmprel_start = get_dynamic_val(dynamic, DT_JMPREL);
-  
-  jmprel_overlaps = 0;
-  if ((jmprel_start >= rel_start) && (jmprel_start < rel_end))
-    jmprel_overlaps = 1;
-    
-  element = (Elf32_Dyn *)FILE_OFFSET(read_word(dynamic->sh_offset));
-  while (read_sword(element->d_tag) != DT_NULL) {
-    switch(read_sword(element->d_tag)) {
-    case DT_STRSZ:
-      write_word(&element->d_un.d_val, new_dynstr_size);
-      break;
-    case DT_PLTGOT:
-    case DT_HASH:
-    case DT_STRTAB:
-    case DT_INIT:
-    case DT_FINI:
-    case DT_VERDEF:
-    case DT_VERNEED:
-    case DT_VERSYM:
-      write_word(&element->d_un.d_ptr,
-		 fixup_addr(read_word(element->d_un.d_ptr)));
-      break;
-    case DT_JMPREL:
-      rel_size = get_dynamic_val(dynamic, DT_PLTRELSZ);
-      if (!jmprel_overlaps) {
-	if (get_dynamic_val(dynamic, DT_PLTREL) == DT_REL) {
-	  rel_entry_size = get_dynamic_val(dynamic, DT_RELENT);
-	  rel = (Elf32_Rel *)FILE_OFFSET(vma_to_offset(read_word(element->d_un.d_ptr)));
-	  remap_rel_section(rel, rel_size, rel_entry_size);
-	} else {
-	  rel_entry_size = get_dynamic_val(dynamic, DT_RELAENT);
-	  rela = (Elf32_Rela *)FILE_OFFSET(vma_to_offset(read_word(element->d_un.d_ptr)));
-	  remap_rela_section(rela, rel_size, rel_entry_size);
-	}
-      }
-      write_word(&element->d_un.d_ptr,
-		 fixup_addr(read_word(element->d_un.d_ptr)));
-      break;
-    case DT_REL:
-      rel_size = get_dynamic_val(dynamic, DT_RELSZ);
-      rel_entry_size = get_dynamic_val(dynamic, DT_RELENT);
-      rel = (Elf32_Rel *)FILE_OFFSET(vma_to_offset(read_word(element->d_un.d_ptr)));
-      remap_rel_section(rel, rel_size, rel_entry_size);
-
-      write_word(&element->d_un.d_ptr,
-		 fixup_addr(read_word(element->d_un.d_ptr)));
-      break;
-    case DT_RELA:
-      rel_size = get_dynamic_val(dynamic, DT_RELASZ);
-      rel_entry_size = get_dynamic_val(dynamic, DT_RELAENT);
-      rela = (Elf32_Rela *)FILE_OFFSET(vma_to_offset(read_word(element->d_un.d_ptr)));
-      remap_rela_section(rela, rel_size, rel_entry_size);
-
-      write_word(&element->d_un.d_ptr,
-		 fixup_addr(read_word(element->d_un.d_ptr)));
-      break;
-    default:
-      /*printf("unhandled d_tag: %d (0x%x)\n", read_sword(element->d_tag), read_sword(element->d_tag));*/
-      break;
-    }
-
-    element = (Elf32_Dyn *)((char *)element + entry_size);
-  }
-}
-
-void
-align_hole(Elf32_Word *start, Elf32_Word *end)
-{
-  Elf32_Word len;
-  Elf32_Word align;
-  Elf32_Shdr *section;
-  Elf32_Word sectionsize;
-  int numsections;
-  int i = 0;
-  int unaligned;
-  
-  len = *end - *start;
-  align = 0;
-    
-  sectionsize = read_half(elf_header->e_shentsize);
-  numsections = read_half(elf_header->e_shnum);
-  do {
-    section = (Elf32_Shdr *)FILE_OFFSET(read_word(elf_header->e_shoff));
-    unaligned = 0;
-    
-    for (i=0;i<numsections;i++) {
-      if ( (read_word(section->sh_addralign) > 1) &&
-	   ( (read_word(section->sh_offset) - len + align)%read_word(section->sh_addralign) != 0) ) {
-	unaligned = 1;
-      }
-      
-      section = (Elf32_Shdr *)((char *)section + sectionsize);
-    }
-
-    if (unaligned) {
-      align++;
-    }
-      
-  } while (unaligned);
-
-  *start += align;
-}
-
-int
-main(int argc, char *argv[])
-{
-  int fd;
-  unsigned char *mapping;
-  Elf32_Word size;
-  struct stat statbuf;
-  Elf32_Shdr *dynamic;
-  Elf32_Shdr *dynsym;
-  Elf32_Shdr *symtab;
-  Elf32_Shdr *dynstr;
-  Elf32_Shdr *hash;
-  Elf32_Shdr *higher_section;
-  Elf32_Word dynstr_index;
-  Elf32_Shdr *ver_r;
-  Elf32_Shdr *ver_d;
-  char *dynstr_data;
-  unsigned char *new_dynstr;
-  Elf32_Word old_dynstr_size;
-  Elf32_Word new_dynstr_size;
-  
-  if (argc != 2) {
-    fprintf(stderr, "Usage: %s <filename>\n", argv[0]);
-    return 1;
-  }
-
-  fd = open(argv[1], O_RDWR);
-  if (fd == -1) {
-    fprintf(stderr, "Cannot open file %s\n", argv[1]);
-    return 1;
-  }
-  
-  if (fstat(fd, &statbuf) == -1) {
-    fprintf(stderr, "Cannot stat file %s\n", argv[1]);
-    return 1;
-  }
-  
-  size = statbuf.st_size;
-    
-  mapping = mmap(0, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
-
-  if (mapping == (unsigned char *)-1) {
-    fprintf(stderr, "Cannot mmap file %s\n", argv[1]);
-    return 1;
-  }
-
-  used_dynamic_symbols = g_hash_table_new(g_direct_hash, g_direct_equal);
-
-  elf_header = (Elf32_Ehdr *)mapping;
-
-  if (strncmp((void *)elf_header, ELFMAG, SELFMAG)!=0) {
-    fprintf(stderr, "Not an ELF file\n");
-    return 1;
-  }
-
-  if (elf_header->e_ident[EI_VERSION] != EV_CURRENT) {
-    fprintf(stderr, "Wrong ELF file version\n");
-    return 1;
-  }
-
-  if (elf_header->e_ident[EI_CLASS] != ELFCLASS32) {
-    fprintf(stderr, "Only 32bit ELF files supported\n");
-    return 1;
-  }
-  
-  setup_byteswapping(elf_header->e_ident[EI_DATA]);
-
-  machine_type = read_half(elf_header->e_machine);
-  if ( (machine_type != EM_386) &&
-       (machine_type != EM_PPC) ) {
-    fprintf(stderr, "Unsupported architecture. Supported are: x86, ppc\n");
-    return 1;
-  }
-
-  if (read_half(elf_header->e_type) != ET_DYN) {
-    fprintf(stderr, "Not an ELF shared object\n");
-    return 1;
-  }
-  
-  dynamic = elf_find_section(SHT_DYNAMIC);
-  dynsym = elf_find_section(SHT_DYNSYM);
-  symtab = elf_find_section(SHT_SYMTAB);
-  dynstr_index = read_word(dynsym->sh_link);
-  dynstr = elf_find_section_num(dynstr_index);
-  dynstr_data = (char *)FILE_OFFSET(read_word(dynstr->sh_offset));
-  old_dynstr_size = read_word(dynstr->sh_size);
-  ver_d = elf_find_section(SHT_GNU_verdef);
-  ver_r = elf_find_section(SHT_GNU_verneed);
-  hash = elf_find_section(SHT_HASH);
-
-  /* Generate hash table with all used strings: */
-  
-  add_strings_from_dynsym(dynsym, dynstr_data);
-  add_strings_from_dynamic(dynamic, dynstr_data);
-  if (ver_d && (read_word(ver_d->sh_link) == dynstr_index))
-    add_strings_from_ver_d(ver_d, dynstr_data);
-  if (ver_r && (read_word(ver_r->sh_link) == dynstr_index))
-    add_strings_from_ver_r(ver_r, dynstr_data);
-
-  /* Generate new dynstr section from the used strings hashtable: */
-  
-  new_dynstr = generate_new_dynstr(&new_dynstr_size);
-  /*
-  printf("New dynstr size: %d\n", new_dynstr_size);
-  printf("Old dynstr size: %d\n", old_dynstr_size);
-  */
-  
-  if (new_dynstr_size >= old_dynstr_size) {
-    fprintf(stderr, "Couldn't GC any strings, exiting.\n");
-    return 0;
-  }
-
-  /* Fixup all references: */
-  fixup_strings_in_dynsym(dynsym);
-  fixup_strings_in_dynamic(dynamic);
-  if (ver_d && (read_word(ver_d->sh_link) == dynstr_index))
-    fixup_strings_in_ver_d(ver_d);
-  if (ver_r && (read_word(ver_r->sh_link) == dynstr_index))
-    fixup_strings_in_ver_r(ver_r);
-  
-  /* Copy over the new dynstr: */
-  memcpy(dynstr_data, new_dynstr, new_dynstr_size);
-  memset(dynstr_data + new_dynstr_size, ' ', old_dynstr_size-new_dynstr_size);
-
-  /* Compact the dynstr section and the file: */
-
-  /* 1. Set up the data for the fixup_offset() function: */
-  hole_index = read_word(dynstr->sh_offset) + new_dynstr_size;
-  higher_section = elf_find_next_higher_section(hole_index);
-  hole_end = read_word(higher_section->sh_offset);
-
-  align_hole(&hole_index, &hole_end);
-  hole_len = hole_end - hole_index;
-
-  hole_addr_start = hole_index; /* TODO: Fix this to something better */
-
-  find_segment_addr_min_max(read_word(dynstr->sh_offset),
-			    &hole_addr_remap_start, &hole_addr_remap_end);
-  
-  /*
-  printf("Hole remap: 0x%lx - 0x%lx\n", hole_addr_remap_start, hole_addr_remap_end);
-
-  printf("hole: %lu - %lu (%lu bytes)\n", hole_index, hole_end, hole_len);
-  printf("hole: 0x%lx - 0x%lx (0x%lx bytes)\n", hole_index, hole_end, hole_len);
-  */
-  
-  /* 2. Change all section and segment sizes and offsets: */
-  remap_symtab(dynsym);
-  if (symtab)
-    remap_symtab(symtab);
-
-  if (machine_type == EM_386)
-    remap_i386_got();
-  if (machine_type == EM_PPC)
-    remap_ppc_got();
-  
-  remap_dynamic(dynamic, new_dynstr_size);
-  remap_sections(); /* After this line the section headers are wrong */
-  remap_segments();
-  remap_elf_header();
-    
-  /* 3. Do the real compacting. */
-
-  memmove(mapping + hole_index,
-	  mapping + hole_index + hole_len,
-	  size - (hole_index + hole_len));
-  
-  munmap(mapping, size);
-
-  ftruncate(fd, size - hole_len);
-  close(fd);
-
-  return 0;
-}
-
-
-
diff -r 4f1383af8f10 js/src/config/rules.mk
--- a/js/src/config/rules.mk	Sat Nov 01 09:52:29 2008 +0100
+++ b/js/src/config/rules.mk	Mon Nov 03 05:09:09 2008 -0500
@@ -378,16 +378,18 @@ LOOP_OVER_TOOL_DIRS = \
     @$(EXIT_ON_ERROR) \
     $(foreach dir,$(TOOL_DIRS),$(UPDATE_TITLE) $(MAKE) -C $(dir) $@; ) true
 
 ifdef PARALLEL_DIRS
 # create a bunch of fake targets for order-only processing
 PARALLEL_DIRS_export = $(addsuffix _export,$(PARALLEL_DIRS))
 PARALLEL_DIRS_libs = $(addsuffix _libs,$(PARALLEL_DIRS))
 PARALLEL_DIRS_tools = $(addsuffix _tools,$(PARALLEL_DIRS))
+
+.PHONY: $(PARALLEL_DIRS_export) $(PARALLEL_DIRS_libs) $(PARALLEL_DIRS_tools)
 endif
 
 #
 # Now we can differentiate between objects used to build a library, and
 # objects used to build an executable in the same directory.
 #
 ifndef PROGOBJS
 PROGOBJS		= $(OBJS)
@@ -588,19 +590,17 @@ HOST_OUTOPTION = -o # eol
 HOST_OUTOPTION = -o # eol
 endif
 
 endif
 ################################################################################
 
 # SUBMAKEFILES: List of Makefiles for next level down.
 #   This is used to update or create the Makefiles before invoking them.
-SUBMAKEFILES += $(addsuffix /Makefile, $(DIRS) $(TOOL_DIRS))
-PARALLEL_SUBMAKEFILES += $(addsuffix /Makefile, $(PARALLEL_DIRS))
-SUBMAKEFILES += $(PARALLEL_SUBMAKEFILES)
+SUBMAKEFILES += $(addsuffix /Makefile, $(DIRS) $(TOOL_DIRS) $(PARALLEL_DIRS))
 
 # The root makefile doesn't want to do a plain export/libs, because
 # of the tiers and because of libxul. Suppress the default rules in favor
 # of something else. Makefiles which use this var *must* provide a sensible
 # default rule before including rules.mk
 ifndef SUPPRESS_DEFAULT_RULES
 ifdef TIERS
 
@@ -693,31 +693,31 @@ makefiles: $(SUBMAKEFILES)
 makefiles: $(SUBMAKEFILES)
 ifneq (,$(DIRS)$(TOOL_DIRS)$(PARALLEL_DIRS))
 	+$(LOOP_OVER_PARALLEL_DIRS)
 	+$(LOOP_OVER_DIRS)
 	+$(LOOP_OVER_TOOL_DIRS)
 endif
 
 ifdef PARALLEL_DIRS
-export:: $(PARALLEL_SUBMAKEFILES) | $(PARALLEL_DIRS_export)
+export:: $(PARALLEL_DIRS_export)
 
-$(PARALLEL_DIRS_export):: %_export: %
-	+$(MAKE) -C $< export
+$(PARALLEL_DIRS_export): %_export: %/Makefile
+	+$(MAKE) -C $* export
 endif
 
 export:: $(SUBMAKEFILES) $(MAKE_DIRS) $(if $(EXPORTS)$(XPIDLSRCS)$(SDK_HEADERS)$(SDK_XPIDLSRCS),$(PUBLIC)) $(if $(SDK_HEADERS)$(SDK_XPIDLSRCS),$(SDK_PUBLIC)) $(if $(XPIDLSRCS),$(IDL_DIR)) $(if $(SDK_XPIDLSRCS),$(SDK_IDL_DIR))
 	+$(LOOP_OVER_DIRS)
 	+$(LOOP_OVER_TOOL_DIRS)
 
 ifdef PARALLEL_DIRS
-tools:: $(PARALLEL_SUBMAKEFILES) | $(PARALLEL_DIRS_tools)
+tools:: $(PARALLEL_DIRS_tools)
 
-$(PARALLEL_DIRS_tools):: %_tools: %
-	+$(MAKE) -C $< tools
+$(PARALLEL_DIRS_tools): %_tools: %/Makefile
+	+$(MAKE) -C $* tools
 endif
 
 tools:: $(SUBMAKEFILES) $(MAKE_DIRS)
 	+$(LOOP_OVER_DIRS)
 ifdef TOOL_DIRS
 	@$(EXIT_ON_ERROR) \
 	$(foreach dir,$(TOOL_DIRS),$(UPDATE_TITLE) $(MAKE) -C $(dir) libs; ) true
 endif
@@ -743,20 +743,20 @@ endif # LIBRARY_NAME
 
 # Create dependencies on static (and shared EXTRA_DSO_LIBS) libraries
 LIBS_DEPS = $(filter %.$(LIB_SUFFIX), $(LIBS))
 HOST_LIBS_DEPS = $(filter %.$(LIB_SUFFIX), $(HOST_LIBS))
 DSO_LDOPTS_DEPS = $(EXTRA_DSO_LIBS) $(filter %.$(LIB_SUFFIX), $(EXTRA_DSO_LDOPTS))
 
 ##############################################
 ifdef PARALLEL_DIRS
-libs:: $(PARALLEL_SUBMAKEFILES) | $(PARALLEL_DIRS_libs)
+libs:: $(PARALLEL_DIRS_libs)
 
-$(PARALLEL_DIRS_libs):: %_libs: %
-	+$(MAKE) -C $< libs
+$(PARALLEL_DIRS_libs): %_libs: %/Makefile
+	+$(MAKE) -C $* libs
 endif
 
 libs:: $(SUBMAKEFILES) $(MAKE_DIRS) $(HOST_LIBRARY) $(LIBRARY) $(SHARED_LIBRARY) $(IMPORT_LIBRARY) $(HOST_PROGRAM) $(PROGRAM) $(HOST_SIMPLE_PROGRAMS) $(SIMPLE_PROGRAMS) $(JAVA_LIBRARY)
 ifndef NO_DIST_INSTALL
 ifdef LIBRARY
 ifdef EXPORT_LIBRARY # Stage libs that will be linked into a static build
 ifdef IS_COMPONENT
 	$(INSTALL) $(IFLAGS1) $(LIBRARY) $(DEPTH)/staticlib/components
diff -r 4f1383af8f10 js/src/configure.in
--- a/js/src/configure.in	Sat Nov 01 09:52:29 2008 +0100
+++ b/js/src/configure.in	Mon Nov 03 05:09:09 2008 -0500
@@ -102,17 +102,16 @@ _SUBDIR_CONFIG_ARGS="$ac_configure_args"
 _SUBDIR_CONFIG_ARGS="$ac_configure_args"
 
 dnl Set the version number of the libs included with mozilla
 dnl ========================================================
 NSPR_VERSION=4
 
 dnl Set the minimum version of toolkit libs used by mozilla
 dnl ========================================================
-GLIB_VERSION=1.2.0
 PERL_VERSION=5.006
 MAKE_VERSION=3.78
 WINDRES_VERSION=2.14.90
 W32API_VERSION=3.8
 
 MSMANIFEST_TOOL=
 
 dnl Set various checks
@@ -281,18 +280,37 @@ if test -n "$CROSS_COMPILE" && test "$ta
     AC_CHECK_PROGS(RANLIB, $RANLIB "${target_alias}-ranlib" "${target}-ranlib", :)
     AC_CHECK_PROGS(AR, $AR "${target_alias}-ar" "${target}-ar", :)
     AC_PATH_PROGS(AS, $AS "${target_alias}-as" "${target}-as", :)
     AC_CHECK_PROGS(LD, $LD "${target_alias}-ld" "${target}-ld", :)
     AC_CHECK_PROGS(STRIP, $STRIP "${target_alias}-strip" "${target}-strip", :)
     AC_CHECK_PROGS(WINDRES, $WINDRES "${target_alias}-windres" "${target}-windres", :)
     AC_DEFINE(CROSS_COMPILE)
 else
+    case "$build:$target" in
+      powerpc-apple-darwin8*:i?86-apple-darwin*)
+        dnl The Darwin cross compiler doesn't necessarily point itself at a
+        dnl root that has libraries for the proper architecture, it defaults
+        dnl to the system root.  The libraries in the system root on current
+        dnl versions of PPC OS X 10.4 aren't fat, so these target compiler
+        dnl checks will fail.  Fake a working SDK in that case.
+        _SAVE_CFLAGS=$CFLAGS
+        _SAVE_CXXFLAGS=$CXXLAGS
+        CFLAGS="-isysroot /Developer/SDKs/MacOSX10.4u.sdk $CFLAGS"
+        CXXFLAGS="-isysroot /Developer/SDKs/MacOSX10.4u.sdk $CXXFLAGS"
+        ;;
+    esac
     AC_PROG_CC
     AC_PROG_CXX
+    case "$build:$target" in
+      powerpc-apple-darwin8*:i?86-apple-darwin*)
+        CFLAGS=$_SAVE_CFLAGS
+        CXXFLAGS=$_SAVE_CXXFLAGS
+        ;;
+    esac
     AC_PROG_RANLIB
     AC_PATH_PROGS(AS, $AS as, $CC)
     AC_CHECK_PROGS(AR, ar, :)
     AC_CHECK_PROGS(LD, ld, :)
     AC_CHECK_PROGS(STRIP, strip, :)
     AC_CHECK_PROGS(WINDRES, windres, :)
     if test -z "$HOST_CC"; then
         HOST_CC="$CC"
@@ -1777,17 +1795,16 @@ case "$target" in
 
 
     case "${target_cpu}" in
     alpha*)
     	CFLAGS="$CFLAGS -mieee"
     	CXXFLAGS="$CXXFLAGS -mieee"
     ;;
     i*86)
-    	USE_ELF_DYNSTR_GC=1
         MOZ_ENABLE_OLD_ABI_COMPAT_WRAPPERS=1
     ;;
     mips*)
         MOZ_DEBUG_FLAGS="-g" # We want inlining
     ;;
     esac
     ;;
 
@@ -2012,55 +2029,17 @@ case "$target" in
     MOZ_TOOLS_DIR=`cd $MOZ_TOOLS && pwd`
     if test "$?" != "0" || test -z "$MOZ_TOOLS_DIR"; then
         AC_MSG_ERROR([cd \$MOZ_TOOLS failed. MOZ_TOOLS ==? $MOZ_TOOLS])
     fi
     if test `echo ${PATH}: | grep -ic "$MOZ_TOOLS_DIR/bin:"` = 0; then
         AC_MSG_ERROR([\$MOZ_TOOLS\\bin must be in your path.])
     fi
     MOZ_TOOLS_DIR=`$CYGPATH_W $MOZ_TOOLS_DIR | $CYGPATH_S`
-
-    if test -n "$GLIB_PREFIX"; then
-        _GLIB_PREFIX_DIR=`cd $GLIB_PREFIX && pwd`
-        if test "$?" = "0"; then
-            if test `echo ${PATH}: | grep -ic "$_GLIB_PREFIX_DIR/bin:"` = 0; then
-                AC_MSG_ERROR([GLIB_PREFIX must be in your \$PATH.])
-            fi
-            _GLIB_PREFIX_DIR=`$CYGPATH_W $_GLIB_PREFIX_DIR | $CYGPATH_S`
-        else
-            AC_MSG_ERROR([GLIB_PREFIX is set but "${GLIB_PREFIX}" is not a directory.])
-        fi
-    else
-        _GLIB_PREFIX_DIR=$MOZ_TOOLS_DIR
-    fi
-    if test ! -f "${_GLIB_PREFIX_DIR}/include/glib.h"; then
-        AC_MSG_ERROR([Cannot find $_GLIB_PREFIX_DIR/include/glib.h .])
-    fi
-    GLIB_CFLAGS="-I${_GLIB_PREFIX_DIR}/include"
-    if test -f "${_GLIB_PREFIX_DIR}/lib/glib-1.2_s.lib"; then
-        GLIB_LIBS="${_GLIB_PREFIX_DIR}/lib/glib-1.2_s.lib"
-    elif test -f "${_GLIB_PREFIX_DIR}/lib/glib-1.2.lib"; then
-        GLIB_LIBS="${_GLIB_PREFIX_DIR}/lib/glib-1.2.lib"
-    else
-        AC_MSG_ERROR([Cannot find $_GLIB_PREFIX_DIR/lib/glib-1.2.lib or $_GLIB_PREFIX_DIR/lib/glib-1.2_s.lib])
-    fi
-    ;;
-
-    *) # else cross-compiling
-        if test -n "$GLIB_PREFIX"; then
-            GLIB_CFLAGS="-I${GLIB_PREFIX}/include"
-            if test -f "${GLIB_PREFIX}/lib/glib-1.2_s.lib"; then
-                GLIB_LIBS="${GLIB_PREFIX}/lib/glib-1.2_s.lib"
-            elif test -f "${GLIB_PREFIX}/lib/glib-1.2.lib"; then
-                GLIB_LIBS="${GLIB_PREFIX}/lib/glib-1.2.lib"
-            else
-                AC_MSG_ERROR([Cannot find $GLIB_PREFIX/lib/glib-1.2.lib or $GLIB_PREFIX/lib/glib-1.2_s.lib])
-            fi
-        fi
-        ;;
+    ;;
     esac 
 
 
     case "$host_os" in
     cygwin*|msvc*|mks*)
         AC_MSG_WARN([Using a cygwin build environment is unsupported. Configure cannot check for the presence of necessary headers. Please upgrade to MozillaBuild; see http://developer.mozilla.org/en/docs/Windows_Build_Prerequisites])
         ;;
 
@@ -2131,21 +2110,16 @@ case "$target" in
 	then
 		_PLATFORM_DEFAULT_TOOLKIT="photon"
 	    TK_CFLAGS='-I/usr/include/photon'
 		TK_LIBS='-lph'
 	fi
 	case "${target_cpu}" in
 	ppc*)
 	AC_DEFINE(HAVE_VA_LIST_AS_ARRAY)	
-	;;
-	esac
-	case "${host_cpu}" in
-	i*86)
-	USE_ELF_DYNSTR_GC=1
 	;;
 	esac
 	;;
 
 *-openbsd*)
     DLL_SUFFIX=".so.1.0"
     DSO_CFLAGS=''
     DSO_PIC_CFLAGS='-fPIC'
@@ -4040,17 +4014,16 @@ NS_TRACE_MALLOC=${MOZ_TRACE_MALLOC}
 NS_TRACE_MALLOC=${MOZ_TRACE_MALLOC}
 MOZ_ARG_ENABLE_BOOL(trace-malloc,
 [  --enable-trace-malloc   Enable malloc tracing],
     NS_TRACE_MALLOC=1,
     NS_TRACE_MALLOC= )
 if test "$NS_TRACE_MALLOC"; then
   # Please, Mr. Linker Man, don't take away our symbol names
   MOZ_COMPONENTS_VERSION_SCRIPT_LDFLAGS=
-  USE_ELF_DYNSTR_GC=
   AC_DEFINE(NS_TRACE_MALLOC)
 fi
 AC_SUBST(NS_TRACE_MALLOC)
 
 dnl ========================================================
 dnl = Enable jemalloc
 dnl ========================================================
 MOZ_ARG_ENABLE_BOOL(jemalloc,
@@ -4276,24 +4249,16 @@ dnl = Enable stripping of libs & executa
 dnl = Enable stripping of libs & executables when packaging
 dnl ========================================================
 MOZ_ARG_ENABLE_BOOL(install-strip,
 [  --enable-install-strip  Enable stripping of libs & executables when packaging ],
     PKG_SKIP_STRIP= ,
     PKG_SKIP_STRIP=1)
 
 dnl ========================================================
-dnl = --enable-elf-dynstr-gc
-dnl ========================================================
-MOZ_ARG_ENABLE_BOOL(elf-dynstr-gc,
-[  --enable-elf-dynstr-gc  Enable elf dynstr garbage collector (opt builds only)],
-    USE_ELF_DYNSTR_GC=1,
-    USE_ELF_DYNSTR_GC= )
-
-dnl ========================================================
 dnl = --enable-old-abi-compat-wrappers
 dnl ========================================================
 dnl on x86 linux, the current builds of some popular plugins (notably
 dnl flashplayer and real) expect a few builtin symbols from libgcc
 dnl which were available in some older versions of gcc.  However,
 dnl they're _NOT_ available in newer versions of gcc (eg 3.1), so if
 dnl we want those plugin to work with a gcc-3.1 built binary, we need
 dnl to provide these symbols.  MOZ_ENABLE_OLD_ABI_COMPAT_WRAPPERS defaults
@@ -4341,17 +4306,16 @@ dnl ====================================
 dnl ========================================================
 MOZ_ARG_ENABLE_BOOL(eazel-profiler-support,
 [  --enable-eazel-profiler-support
                           Enable Corel/Eazel profiler support],
     ENABLE_EAZEL_PROFILER=1,
     ENABLE_EAZEL_PROFILER= )
 if test -n "$ENABLE_EAZEL_PROFILER"; then
     AC_DEFINE(ENABLE_EAZEL_PROFILER)
-    USE_ELF_DYNSTR_GC=
     MOZ_COMPONENTS_VERSION_SCRIPT_LDFLAGS=
     EAZEL_PROFILER_CFLAGS="-g -O -gdwarf-2 -finstrument-functions -D__NO_STRING_INLINES  -D__NO_MATH_INLINES"
     EAZEL_PROFILER_LIBS="-lprofiler -lpthread"
 fi
 
 MOZ_ARG_ENABLE_STRING(profile-modules,
 [  --enable-profile-modules
                           Enable/disable profiling for specific modules],
@@ -4792,30 +4756,16 @@ fi
 fi
 
 dnl ========================================================
 dnl =
 dnl = Standalone module options
 dnl = 
 dnl ========================================================
 MOZ_ARG_HEADER(Standalone module options (Not for building Mozilla))
-
-if test -z "$SKIP_PATH_CHECKS"; then
-if test -z "${GLIB_CFLAGS}" || test -z "${GLIB_LIBS}" ; then
-    PKG_CHECK_MODULES(GLIB, glib-2.0 >= 1.3.7 gobject-2.0)
-fi
-fi
-
-if test -z "${GLIB_GMODULE_LIBS}" -a -n "${GLIB_CONFIG}"; then
-    GLIB_GMODULE_LIBS=`$GLIB_CONFIG gmodule --libs`
-fi
-
-AC_SUBST(GLIB_CFLAGS)
-AC_SUBST(GLIB_LIBS)
-AC_SUBST(GLIB_GMODULE_LIBS)
 
 dnl ========================================================
 if test "$MOZ_DEBUG" || test "$NS_TRACE_MALLOC"; then
     MOZ_COMPONENTS_VERSION_SCRIPT_LDFLAGS=
 fi
 
 MOZ_ARG_WITH_STRING(sync-build-files,
 [  --with-sync-build-files=DIR
@@ -4879,17 +4829,16 @@ AC_SUBST(MOZ_INSURIFYING)
 AC_SUBST(MOZ_INSURIFYING)
 AC_SUBST(LIBICONV)
 
 AC_SUBST(BUILD_STATIC_LIBS)
 AC_SUBST(ENABLE_TESTS)
 
 AC_SUBST(ENABLE_STRIP)
 AC_SUBST(PKG_SKIP_STRIP)
-AC_SUBST(USE_ELF_DYNSTR_GC)
 AC_SUBST(INCREMENTAL_LINKER)
 AC_SUBST(MOZ_COMPONENTS_VERSION_SCRIPT_LDFLAGS)
 AC_SUBST(MOZ_COMPONENT_NSPR_LIBS)
 
 AC_SUBST(MOZ_FIX_LINK_PATHS)
 
 AC_SUBST(USE_DEPENDENT_LIBS)
 
diff -r 4f1383af8f10 js/src/jsemit.cpp
--- a/js/src/jsemit.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/js/src/jsemit.cpp	Mon Nov 03 05:09:09 2008 -0500
@@ -1887,17 +1887,17 @@ BindNameToSlot(JSContext *cx, JSCodeGene
             if (PN_OP(pn) != JSOP_NAME || cg->staticDepth > JS_DISPLAY_SIZE)
                 goto arguments_check;
             localKind = js_LookupLocal(cx, caller->fun, atom, &index);
             if (localKind == JSLOCAL_NONE)
                 goto arguments_check;
 
             ATOM_LIST_SEARCH(ale, &cg->upvarList, atom);
             if (!ale) {
-                uint32 cookie, length, *vector;
+                uint32 length, *vector;
 
                 ale = js_IndexAtom(cx, atom, &cg->upvarList);
                 if (!ale)
                     return JS_FALSE;
                 JS_ASSERT(ALE_INDEX(ale) == cg->upvarList.count - 1);
 
                 length = cg->upvarMap.length;
                 JS_ASSERT(ALE_INDEX(ale) <= length);
@@ -1914,18 +1914,19 @@ BindNameToSlot(JSContext *cx, JSCodeGene
 
                 if (localKind != JSLOCAL_ARG)
                     index += caller->fun->nargs;
                 if (index >= JS_BIT(16)) {
                     cg->treeContext.flags |= TCF_FUN_USES_NONLOCALS;
                     return JS_TRUE;
                 }
 
-                cookie = MAKE_UPVAR_COOKIE(1, index);
-                cg->upvarMap.vector[ALE_INDEX(ale)] = cookie;
+                JS_ASSERT(cg->staticDepth > caller->fun->u.i.script->staticDepth);
+                uintN skip = cg->staticDepth - caller->fun->u.i.script->staticDepth;
+                cg->upvarMap.vector[ALE_INDEX(ale)] = MAKE_UPVAR_COOKIE(skip, index);
             }
 
             pn->pn_op = JSOP_GETUPVAR;
             pn->pn_slot = ALE_INDEX(ale);
             return JS_TRUE;
         }
 
         /*
diff -r 4f1383af8f10 js/src/xpconnect/src/qsgen.py
--- a/js/src/xpconnect/src/qsgen.py	Sat Nov 01 09:52:29 2008 +0100
+++ b/js/src/xpconnect/src/qsgen.py	Mon Nov 03 05:09:09 2008 -0500
@@ -109,19 +109,16 @@
 #   Ordinarily, XPConnect searches the prototype chain of the "this" JSObject
 #   for an XPCOM object of the desired "proto".  For details, see the parts of
 #   XPCWrappedNative::GetWrappedNativeOfJSObject that use "proto".  Some quick
 #   stubs (methods, not getters or setters, that have XPCCallContexts) do this,
 #   but most instead look for an XPCOM object that supports the desired
 #   *interface*.  This is more lenient.  The difference is observable in some
 #   cases where a getter/setter/method is taken from one object and applied to
 #   another object.
-#
-#   Another notable difference in this area: Quick stubs don't support split
-#   objects.
 #
 # - Quick stubs never suspend the JS request.  So they are only suitable for
 #   main-thread-only interfaces.
 #
 # - Quick stubs don't call XPCContext::SetLastResult.  This is visible on the
 #   Components object.
 #
 # - Quick stubs skip a security check that XPConnect does in
@@ -348,64 +345,76 @@ def substitute(template, vals):
     def replacement(match):
         return vals[match.group(1)]
     return re.sub(r'\${(\w+)}', replacement, template)
 
 # From JSData2Native.
 argumentUnboxingTemplates = {
     'short':
         "    int32 ${name}_i32;\n"
-        "    if (!JS_ValueToECMAInt32(cx, ${argVal}, &${name}_i32)) ${failBlock}\n"
+        "    if (!JS_ValueToECMAInt32(cx, ${argVal}, &${name}_i32))\n"
+        "        return JS_FALSE;\n"
         "    int16 ${name} = (int16) ${name}_i32;\n",
 
     'unsigned short':
         "    uint32 ${name}_u32;\n"
-        "    if (!JS_ValueToECMAUint32(cx, ${argVal}, &${name}_u32)) ${failBlock}\n"
+        "    if (!JS_ValueToECMAUint32(cx, ${argVal}, &${name}_u32))\n"
+        "        return JS_FALSE;\n"
         "    uint16 ${name} = (uint16) ${name}_u32;\n",
 
     'long':
         "    int32 ${name};\n"
-        "    if (!JS_ValueToECMAInt32(cx, ${argVal}, &${name})) ${failBlock}\n",
+        "    if (!JS_ValueToECMAInt32(cx, ${argVal}, &${name}))\n"
+        "        return JS_FALSE;\n",
 
     'unsigned long':
         "    uint32 ${name};\n"
-        "    if (!JS_ValueToECMAUint32(cx, ${argVal}, &${name})) ${failBlock}\n",
+        "    if (!JS_ValueToECMAUint32(cx, ${argVal}, &${name}))\n"
+        "        return JS_FALSE;\n",
 
     'float':
         "    jsdouble ${name}_dbl;\n"
-        "    if (!JS_ValueToNumber(cx, ${argVal}, &${name}_dbl)) ${failBlock}\n"
+        "    if (!JS_ValueToNumber(cx, ${argVal}, &${name}_dbl))\n"
+        "        return JS_FALSE;\n"
         "    float ${name} = (float) ${name}_dbl;\n",
 
     'double':
         "    jsdouble ${name};\n"
-        "    if (!JS_ValueToNumber(cx, ${argVal}, &${name})) ${failBlock}\n",
+        "    if (!JS_ValueToNumber(cx, ${argVal}, &${name}))\n"
+        "        return JS_FALSE;\n",
 
     'boolean':
         "    PRBool ${name};\n"
-        "    if (!JS_ValueToBoolean(cx, ${argVal}, &${name})) ${failBlock}\n",
+        "    if (!JS_ValueToBoolean(cx, ${argVal}, &${name}))\n"
+        "        return JS_FALSE;\n",
 
     '[astring]':
         "    xpc_qsAString ${name}(cx, ${argPtr});\n"
-        "    if (!${name}.IsValid()) ${failBlock}\n",
+        "    if (!${name}.IsValid())\n"
+        "        return JS_FALSE;\n",
 
     '[domstring]':
         "    xpc_qsDOMString ${name}(cx, ${argPtr});\n"
-        "    if (!${name}.IsValid()) ${failBlock}\n",
+        "    if (!${name}.IsValid())\n"
+        "        return JS_FALSE;\n",
 
     'string':
         "    char *${name};\n"
-        "    if (!xpc_qsJsvalToCharStr(cx, ${argPtr}, &${name})) ${failBlock}\n",
+        "    if (!xpc_qsJsvalToCharStr(cx, ${argPtr}, &${name}))\n"
+        "        return JS_FALSE;\n",
 
     'wstring':
         "    PRUnichar *${name};\n"
-        "    if (!xpc_qsJsvalToWcharStr(cx, ${argPtr}, &${name})) ${failBlock}\n",
+        "    if (!xpc_qsJsvalToWcharStr(cx, ${argPtr}, &${name}))\n"
+        "        return JS_FALSE;\n",
 
     '[cstring]':
         "    xpc_qsACString ${name}(cx, ${argPtr});\n"
-        "    if (!${name}.IsValid()) ${failBlock}\n"
+        "    if (!${name}.IsValid())\n"
+        "        return JS_FALSE;\n"
     }
 
 # From JSData2Native.
 #
 # Omitted optional arguments are treated as though the caller had passed JS
 # `null`; this behavior is from XPCWrappedNative::CallMethod.
 #
 def writeArgumentUnboxing(f, i, name, type, haveCcx, optional):
@@ -415,36 +424,30 @@ def writeArgumentUnboxing(f, i, name, ty
     #     which can only happen if optional is True, the argument is missing;
     #     use JSVAL_NULL as the source jsval instead.
     # name - str - name of the native C++ variable to create.
     # type - xpidl.{Interface,Native,Builtin} - IDL type of argument
     # optional - bool - True if the parameter is optional.
 
     isSetter = (i is None)
 
-    # Spell this out each time rather than use a goto.  The most common methods
-    # only have one parameter, and in that case the goto looks silly.
-    fail = ("        NS_RELEASE(self);\n"
-            "        return JS_FALSE;\n")
-
     if isSetter:
         argPtr = "vp"
         argVal = "*vp"
     elif optional:
         argPtr = '!  /* TODO - optional parameter of this type not supported */'
         argVal = "(%d < argc ? argv[%d] : JSVAL_NULL)" % (i, i)
     else:
         argVal = "argv[%d]" % i
         argPtr = "&" + argVal
 
     params = {
         'name': name,
         'argVal': argVal,
-        'argPtr': argPtr,
-        'failBlock': '{\n' + fail + '    }'
+        'argPtr': argPtr
         }
 
     typeName = getBuiltinOrNativeTypeName(type)
     if typeName is not None:
         template = argumentUnboxingTemplates.get(typeName)
         if template is not None:
             if optional and ("${argPtr}" in template):
                 warn("Optional parameters of type %s are not supported."
@@ -454,38 +457,38 @@ def writeArgumentUnboxing(f, i, name, ty
         # else fall through; the type isn't supported yet.
     elif isInterfaceType(type):
         if type.name == 'nsIVariant':
             # Totally custom.
             assert haveCcx
             template = (
                 "    nsCOMPtr<nsIVariant> ${name}(already_AddRefed<nsIVariant>("
                 "XPCVariant::newVariant(ccx, ${argVal})));\n"
-                "    if (!${name}) ${failBlock}\n")
+                "    if (!${name})\n"
+                "        return JS_FALSE;\n")
             f.write(substitute(template, params))
             return
         elif type.name == 'nsIAtom':
             # Should have special atomizing behavior.  Fall through.
             pass
         else:
             f.write("    nsCOMPtr<%s> %s;\n" % (type.name, name))
             f.write("    rv = xpc_qsUnwrapArg<%s>("
                     "cx, %s, getter_AddRefs(%s));\n"
                     % (type.name, argVal, name))
             f.write("    if (NS_FAILED(rv)) {\n")
             if isSetter:
                 f.write("        xpc_qsThrowBadSetterValue("
-                        "cx, rv, wrapper, id);\n")
+                        "cx, rv, JSVAL_TO_OBJECT(*tvr.addr()), id);\n")
             elif haveCcx:
                 f.write("        xpc_qsThrowBadArgWithCcx(ccx, rv, %d);\n" % i)
             else:
-                f.write("        xpc_qsThrowBadArg(cx, rv, wrapper, vp, %d);\n"
-                        % i)
-            f.write(fail);
-            f.write("    }\n")
+                f.write("        xpc_qsThrowBadArg(cx, rv, vp, %d);\n" % i)
+            f.write("        return JS_FALSE;\n"
+                    "    }\n")
             return
 
     warn("Unable to unbox argument of type %s" % type.name)
     if i is None:
         src = '*vp'
     else:
         src = 'argv[%d]' % i
     f.write("    !; // TODO - Unbox argument %s = %s\n" % (name, src))
@@ -647,38 +650,47 @@ def writeQuickStub(f, member, stubName, 
         # In some cases we emit a ccx, but it does not count as
         # "haveCcx" because it's not complete.
         if isAttr and isInterfaceType(member.realtype):
             f.write("    XPCCallContext ccx(JS_CALLER, cx, obj);\n")
 
     # Get the 'self' pointer.
     thisType = member.iface.name
     f.write("    %s *self;\n" % thisType)
+    f.write("    xpc_qsSelfRef selfref;\n")
     # Don't use FromCcx for getters or setters; the way we construct the ccx in
     # a getter/setter causes it to find the wrong wrapper in some cases.
     if isMethod and haveCcx:
-        f.write("    if (!xpc_qsUnwrapThisFromCcx(ccx, &self))\n"
-                "        return JS_FALSE;\n")
+        # Undocumented, but the interpreter puts 'this' at argv[-1],
+        # which is vp[1]; and it's ok to overwrite it.
+        f.write("    if (!xpc_qsUnwrapThisFromCcx(ccx, &self, &selfref.ptr, "
+                "&vp[1]))\n")
+        f.write("        return JS_FALSE;\n")
     else:
-        # 'wrapper' is needed only for error messages.
-        f.write("    XPCWrappedNative *wrapper;\n"
-                "    if (!xpc_qsUnwrapThis(cx, obj, &self, &wrapper))\n"
-                "        return JS_FALSE;\n")
+        if isGetter:
+            pthisval = 'vp'
+        elif isSetter:
+            f.write("    xpc_qsTempRoot tvr(cx);\n")
+            pthisval = 'tvr.addr()'
+        else:
+            pthisval = '&vp[1]' # as above, ok to overwrite vp[1]
+
+        f.write("    if (!xpc_qsUnwrapThis(cx, obj, &self, &selfref.ptr, "
+                "%s))\n" % pthisval)
+        f.write("        return JS_FALSE;\n")
 
     if isMethod:
         # If there are any required arguments, check argc.
         requiredArgs = len(member.params)
         while requiredArgs and member.params[requiredArgs-1].optional:
             requiredArgs -= 1
         if requiredArgs:
-            f.write("    if (argc < %d) {\n" % requiredArgs)
-            f.write("        NS_RELEASE(self);\n"
-                    "        return xpc_qsThrow(cx, "
-                    "NS_ERROR_XPC_NOT_ENOUGH_ARGS);\n"
-                    "    }\n")
+            f.write("    if (argc < %d)\n" % requiredArgs)
+            f.write("        return xpc_qsThrow(cx, "
+                    "NS_ERROR_XPC_NOT_ENOUGH_ARGS);\n")
 
     def pfail(msg):
         raise UserError(
             member.iface.name + '.' + member.name + ": "
             "parameter " + param.name + ": " + msg)
 
     # Convert in-parameters.
     f.write("    nsresult rv;\n")
@@ -718,37 +730,40 @@ def writeQuickStub(f, member, stubName, 
         args = ', '.join(argv)
     else:
         comName = header.attributeNativeName(member, isGetter)
         if isGetter:
             args = outParamForm("result", member.realtype)
         else:
             args = "arg0"
     f.write("    rv = self->%s(%s);\n" % (comName, args))
-    f.write("    NS_RELEASE(self);\n")
 
     # Check for errors.
     f.write("    if (NS_FAILED(rv))\n")
     if isMethod:
         if haveCcx:
             f.write("        return xpc_qsThrowMethodFailedWithCcx(ccx, rv);\n")
         else:
             f.write("        return xpc_qsThrowMethodFailed("
-                    "cx, rv, wrapper, vp);\n")
+                    "cx, rv, vp);\n")
     else:
-        f.write("        return xpc_qsThrowGetterSetterFailed("
-                "cx, rv, wrapper, id);\n")
+        if isGetter:
+            thisval = '*vp'
+        else:
+            thisval = '*tvr.addr()'
+        f.write("        return xpc_qsThrowGetterSetterFailed(cx, rv, " +
+                "JSVAL_TO_OBJECT(%s), id);\n" % thisval)
 
     # Convert the return value.
     if isMethod:
         writeResultConv(f, member.realtype, len(member.params) + 1, 'vp', '*vp')
     elif isGetter:
         writeResultConv(f, member.realtype, None, 'vp', '*vp')
     else:
-        f.write("    return JS_TRUE;\n");
+        f.write("    return JS_TRUE;\n")
 
     # Epilog.
     f.write("}\n\n")
 
 def writeAttrStubs(f, attr):
     getterName = (attr.iface.name + '_'
                   + header.attributeNativeName(attr, True))
     writeQuickStub(f, attr, getterName)
@@ -895,16 +910,17 @@ def writeDefiner(f, conf, interfaces):
     f.write("    return xpc_qsDefineQuickStubs("
             "cx, proto, flags, count, iids, %d, tableData);\n" % size)
     f.write("}\n\n\n")
 
 
 stubTopTemplate = '''\
 /* THIS FILE IS AUTOGENERATED - DO NOT EDIT */
 #include "jsapi.h"
+#include "jscntxt.h"
 #include "prtypes.h"
 #include "nsID.h"
 #include "%s"
 #include "nscore.h"
 #include "nsCOMPtr.h"
 #include "nsDependentString.h"
 #include "xpcprivate.h"  // for XPCCallContext
 #include "xpcquickstubs.h"
diff -r 4f1383af8f10 js/src/xpconnect/src/xpcprivate.h
--- a/js/src/xpconnect/src/xpcprivate.h	Sat Nov 01 09:52:29 2008 +0100
+++ b/js/src/xpconnect/src/xpcprivate.h	Mon Nov 03 05:09:09 2008 -0500
@@ -1848,26 +1848,29 @@ private:
     nsCOMPtr<nsIXPCScriptable>  mCallback;
     XPCNativeScriptableFlags    mFlags;
 };
 
 /***********************************************/
 // XPCWrappedNativeProto hold the additional (potentially shared) wrapper data
 // for XPCWrappedNative whose native objects expose nsIClassInfo.
 
+#define UNKNOWN_OFFSETS ((QITableEntry*)1)
+
 class XPCWrappedNativeProto
 {
 public:
     static XPCWrappedNativeProto*
     GetNewOrUsed(XPCCallContext& ccx,
                  XPCWrappedNativeScope* Scope,
                  nsIClassInfo* ClassInfo,
                  const XPCNativeScriptableCreateInfo* ScriptableCreateInfo,
                  JSBool ForceNoSharing,
-                 JSBool isGlobal);
+                 JSBool isGlobal,
+                 QITableEntry* offsets = UNKNOWN_OFFSETS);
 
     XPCWrappedNativeScope*
     GetScope()   const {return mScope;}
 
     XPCJSRuntime*
     GetRuntime() const {return mScope->GetRuntime();}
 
     JSObject*
@@ -1882,16 +1885,55 @@ public:
     XPCNativeScriptableInfo*
     GetScriptableInfo()   {return mScriptableInfo;}
 
     void**
     GetSecurityInfoAddr() {return &mSecurityInfo;}
 
     JSUint32
     GetClassInfoFlags() const {return mClassInfoFlags;}
+
+    QITableEntry*
+    GetOffsets()
+    {
+        return InitedOffsets() ? mOffsets : nsnull;
+    }
+    QITableEntry*
+    GetOffsetsMasked()
+    {
+        return mOffsets;
+    }
+    void
+    CacheOffsets(nsISupports* identity)
+    {
+        static NS_DEFINE_IID(kThisPtrOffsetsSID, NS_THISPTROFFSETS_SID);
+
+#ifdef DEBUG
+        if(InitedOffsets() && mOffsets)
+        {
+            QITableEntry* offsets;
+            identity->QueryInterface(kThisPtrOffsetsSID, (void**)&offsets);
+            NS_ASSERTION(offsets == mOffsets,
+                         "We can't deal with objects that have the same "
+                         "classinfo but different offset tables.");
+        }
+#endif
+
+        if(!InitedOffsets())
+        {
+            if(mClassInfoFlags & nsIClassInfo::CONTENT_NODE)
+            {
+                identity->QueryInterface(kThisPtrOffsetsSID, (void**)&mOffsets);
+            }
+            else
+            {
+                mOffsets = nsnull;
+            }
+        }
+    }
 
 #ifdef GET_IT
 #undef GET_IT
 #endif
 #define GET_IT(f_) const {return !!(mClassInfoFlags & nsIClassInfo:: f_ );}
 
     JSBool ClassIsSingleton()           GET_IT(SINGLETON)
     JSBool ClassIsThreadSafe()          GET_IT(THREADSAFE)
@@ -1947,34 +1989,42 @@ protected:
     // disable copy ctor and assignment
     XPCWrappedNativeProto(const XPCWrappedNativeProto& r); // not implemented
     XPCWrappedNativeProto& operator= (const XPCWrappedNativeProto& r); // not implemented
 
     // hide ctor
     XPCWrappedNativeProto(XPCWrappedNativeScope* Scope,
                           nsIClassInfo* ClassInfo,
                           PRUint32 ClassInfoFlags,
-                          XPCNativeSet* Set);
+                          XPCNativeSet* Set,
+                          QITableEntry* offsets);
 
     JSBool Init(XPCCallContext& ccx, JSBool isGlobal,
                 const XPCNativeScriptableCreateInfo* scriptableCreateInfo);
 
 private:
 #if defined(DEBUG_xpc_hacker) || defined(DEBUG)
     static PRInt32 gDEBUG_LiveProtoCount;
 #endif
 
 private:
+    PRBool
+    InitedOffsets()
+    {
+        return mOffsets != UNKNOWN_OFFSETS;
+    }
+
     XPCWrappedNativeScope*   mScope;
     JSObject*                mJSProtoObject;
     nsCOMPtr<nsIClassInfo>   mClassInfo;
     PRUint32                 mClassInfoFlags;
     XPCNativeSet*            mSet;
     void*                    mSecurityInfo;
     XPCNativeScriptableInfo* mScriptableInfo;
+    QITableEntry*            mOffsets;
 };
 
 
 /***********************************************/
 // XPCWrappedNativeTearOff represents the info needed to make calls to one
 // interface on the underlying native object of a XPCWrappedNative.
 
 class XPCWrappedNativeTearOff
@@ -2309,16 +2359,31 @@ public:
                         XPCNativeScriptableCreateInfo* sciProto);
 
     JSBool HasExternalReference() const {return mRefCnt > 1;}
 
     JSObject* GetWrapper()              { return mWrapper; }
     void      SetWrapper(JSObject *obj) { mWrapper = obj; }
 
     void NoteTearoffs(nsCycleCollectionTraversalCallback& cb);
+
+    QITableEntry* GetOffsets()
+    {
+        if(!HasProto() || !GetProto()->ClassIsDOMObject())
+            return nsnull;
+
+        XPCWrappedNativeProto* proto = GetProto();
+        QITableEntry* offsets = proto->GetOffsets();
+        if(!offsets)
+        {
+            static NS_DEFINE_IID(kThisPtrOffsetsSID, NS_THISPTROFFSETS_SID);
+            mIdentity->QueryInterface(kThisPtrOffsetsSID, (void**)&offsets);
+        }
+        return offsets;
+    }
 
     // Make ctor and dtor protected (rather than private) to placate nsCOMPtr.
 protected:
     XPCWrappedNative(); // not implemented
 
     // This ctor is used if this object will have a proto.
     XPCWrappedNative(nsISupports* aIdentity,
                      XPCWrappedNativeProto* aProto);
diff -r 4f1383af8f10 js/src/xpconnect/src/xpcquickstubs.cpp
--- a/js/src/xpconnect/src/xpcquickstubs.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/js/src/xpconnect/src/xpcquickstubs.cpp	Mon Nov 03 05:09:09 2008 -0500
@@ -173,27 +173,32 @@ xpc_qsThrow(JSContext *cx, nsresult rv)
  *
  * We could instead have each quick stub pass its name to the error-handling
  * functions, as that name is statically known.  But that would be redundant;
  * the information is handy at runtime anyway.  Also, this code often produces
  * a more specific error message, e.g. "[nsIDOMHTMLDocument.appendChild]"
  * rather than "[nsIDOMNode.appendChild]".
  */
 static void
-GetMemberInfo(XPCWrappedNative *wrapper,
+GetMemberInfo(JSObject *obj,
               jsval memberId,
               const char **ifaceName,
               const char **memberName)
 {
     // Get the interface name.  From DefinePropertyIfFound (in
     // xpcwrappednativejsops.cpp) and XPCThrower::Verbosify.
     //
     // We could instead make the quick stub could pass in its interface name,
     // but this code often produces a more specific error message, e.g.
     *ifaceName = "Unknown";
+
+    NS_ASSERTION(IS_WRAPPER_CLASS(STOBJ_GET_CLASS(obj)) ||
+                 STOBJ_GET_CLASS(obj) == &XPC_WN_Tearoff_JSClass,
+                 "obj must be an XPCWrappedNative");
+    XPCWrappedNative *wrapper = (XPCWrappedNative *) STOBJ_GET_PRIVATE(obj);
     XPCWrappedNativeProto *proto = wrapper->GetProto();
     if(proto)
     {
         XPCNativeSet *set = proto->GetSet();
         if(set)
         {
             XPCNativeMember *member;
             XPCNativeInterface *iface;
@@ -205,28 +210,27 @@ GetMemberInfo(XPCWrappedNative *wrapper,
 
     *memberName = (JSVAL_IS_STRING(memberId)
                    ? JS_GetStringBytes(JSVAL_TO_STRING(memberId))
                    : "unknown");
 }
 
 static void
 GetMethodInfo(JSContext *cx,
-              XPCWrappedNative *wrapper,
               jsval *vp,
               const char **ifaceName,
               const char **memberName)
 {
     JSObject *funobj = JSVAL_TO_OBJECT(JS_CALLEE(cx, vp));
     NS_ASSERTION(JS_ObjectIsFunction(cx, funobj),
                  "JSFastNative callee should be Function object");
     JSString *str = JS_GetFunctionId((JSFunction *) JS_GetPrivate(cx, funobj));
     jsval methodId = str ? STRING_TO_JSVAL(str) : JSVAL_NULL;
 
-    GetMemberInfo(wrapper, methodId, ifaceName, memberName);
+    GetMemberInfo(JSVAL_TO_OBJECT(vp[1]), methodId, ifaceName, memberName);
 }
 
 static JSBool
 ThrowCallFailed(JSContext *cx, nsresult rv,
                 const char *ifaceName, const char *memberName)
 {
     // From XPCThrower::ThrowBadResult.
     char* sz;
@@ -267,30 +271,29 @@ ThrowCallFailed(JSContext *cx, nsresult 
 
     if(sz)
         JS_smprintf_free(sz);
 
     return JS_FALSE;
 }
 
 JSBool
-xpc_qsThrowGetterSetterFailed(JSContext *cx, nsresult rv,
-                              XPCWrappedNative *wrapper, jsval memberId)
+xpc_qsThrowGetterSetterFailed(JSContext *cx, nsresult rv, JSObject *obj,
+                              jsval memberId)
 {
     const char *ifaceName, *memberName;
-    GetMemberInfo(wrapper, memberId, &ifaceName, &memberName);
+    GetMemberInfo(obj, memberId, &ifaceName, &memberName);
     return ThrowCallFailed(cx, rv, ifaceName, memberName);
 }
 
 JSBool
-xpc_qsThrowMethodFailed(JSContext *cx, nsresult rv,
-                        XPCWrappedNative *wrapper, jsval *vp)
+xpc_qsThrowMethodFailed(JSContext *cx, nsresult rv, jsval *vp)
 {
     const char *ifaceName, *memberName;
-    GetMethodInfo(cx, wrapper, vp, &ifaceName, &memberName);
+    GetMethodInfo(cx, vp, &ifaceName, &memberName);
     return ThrowCallFailed(cx, rv, ifaceName, memberName);
 }
 
 JSBool
 xpc_qsThrowMethodFailedWithCcx(XPCCallContext &ccx, nsresult rv)
 {
     ThrowBadResult(rv, ccx);
     return JS_FALSE;
@@ -312,36 +315,35 @@ ThrowBadArg(JSContext *cx, nsresult rv,
 
     XPCThrower::BuildAndThrowException(cx, rv, sz);
 
     if(sz)
         JS_smprintf_free(sz);
 }
 
 void
-xpc_qsThrowBadArg(JSContext *cx, nsresult rv,
-                  XPCWrappedNative *wrapper, jsval *vp, uintN paramnum)
+xpc_qsThrowBadArg(JSContext *cx, nsresult rv, jsval *vp, uintN paramnum)
 {
     const char *ifaceName, *memberName;
-    GetMethodInfo(cx, wrapper, vp, &ifaceName, &memberName);
+    GetMethodInfo(cx, vp, &ifaceName, &memberName);
     ThrowBadArg(cx, rv, ifaceName, memberName, paramnum);
 }
 
 void
 xpc_qsThrowBadArgWithCcx(XPCCallContext &ccx, nsresult rv, uintN paramnum)
 {
     XPCThrower::ThrowBadParam(rv, paramnum, ccx);
 }
 
 void
 xpc_qsThrowBadSetterValue(JSContext *cx, nsresult rv,
-                          XPCWrappedNative *wrapper, jsval propId)
+                          JSObject *obj, jsval propId)
 {
     const char *ifaceName, *memberName;
-    GetMemberInfo(wrapper, propId, &ifaceName, &memberName);
+    GetMemberInfo(obj, propId, &ifaceName, &memberName);
     ThrowBadArg(cx, rv, ifaceName, memberName, 0);
 }
 
 xpc_qsDOMString::xpc_qsDOMString(JSContext *cx, jsval *pval)
 {
     // From the T_DOMSTRING case in XPCConvert::JSData2Native.
     typedef implementation_type::char_traits traits;
     jsval v;
@@ -448,36 +450,68 @@ xpc_qsACString::xpc_qsACString(JSContext
     }
 
     const char *bytes = JS_GetStringBytes(s);
     size_t len = JS_GetStringLength(s);
     new(mBuf) implementation_type(bytes, len);
     mValid = JS_TRUE;
 }
 
+static nsresult
+getNativeFromWrapper(XPCWrappedNative *wrapper,
+                     const nsIID &iid,
+                     void **ppThis,
+                     nsISupports **pThisRef,
+                     jsval *vp)
+{
+    nsISupports *idobj = wrapper->GetIdentityObject();
+
+    // Try using the QITableEntry to avoid the extra AddRef and Release.
+    QITableEntry* entries = wrapper->GetOffsets();
+    if(entries)
+    {
+        for(QITableEntry* e = entries; e->iid; e++)
+        {
+            if(e->iid->Equals(iid))
+            {
+                *ppThis = (char*) idobj + e->offset - entries[0].offset;
+                *vp = OBJECT_TO_JSVAL(wrapper->GetFlatJSObject());
+                *pThisRef = nsnull;
+                return NS_OK;
+            }
+        }
+    }
+
+    nsresult rv = idobj->QueryInterface(iid, ppThis);
+    *pThisRef = static_cast<nsISupports*>(*ppThis);
+    if(NS_SUCCEEDED(rv))
+        *vp = OBJECT_TO_JSVAL(wrapper->GetFlatJSObject());
+    return rv;
+}
+
 JSBool
 xpc_qsUnwrapThisImpl(JSContext *cx,
                      JSObject *obj,
                      const nsIID &iid,
                      void **ppThis,
-                     XPCWrappedNative **ppWrapper)
+                     nsISupports **pThisRef,
+                     jsval *vp)
 {
     // From XPCWrappedNative::GetWrappedNativeOfJSObject.
     //
     // Usually IS_WRAPPER_CLASS is true the first time through the while loop,
     // and the QueryInterface then succeeds.
 
     NS_ASSERTION(obj, "this == null");
 
     JSObject *cur = obj;
     while(cur)
     {
         JSClass *clazz;
         XPCWrappedNative *wrapper;
-        nsISupports *idobj;
         nsresult rv;
 
         clazz = STOBJ_GET_CLASS(cur);
         if(IS_WRAPPER_CLASS(clazz))
         {
             wrapper = (XPCWrappedNative*) xpc_GetJSPrivate(cur);
             NS_ASSERTION(wrapper, "XPCWN wrapping nothing");
         }
@@ -509,23 +543,19 @@ xpc_qsUnwrapThisImpl(JSContext *cx,
             cur = STOBJ_GET_PARENT(cur);
             NS_ASSERTION(cur, "SJOW wrapping nothing");
             continue;
         }
         else {
             goto next;
         }
 
-        idobj = wrapper->GetIdentityObject();
-        rv = idobj->QueryInterface(iid, ppThis);
+        rv = getNativeFromWrapper(wrapper, iid, ppThis, pThisRef, vp);
         if(NS_SUCCEEDED(rv))
-        {
-            *ppWrapper = wrapper;
             return JS_TRUE;
-        }
         if(rv != NS_ERROR_NO_INTERFACE)
             return xpc_qsThrow(cx, rv);
 
     next:
         cur = STOBJ_GET_PROTO(cur);
     }
 
     // If we didn't find a wrapper using the given obj, try again with obj's
@@ -543,35 +573,37 @@ xpc_qsUnwrapThisImpl(JSContext *cx,
         clazz = STOBJ_GET_CLASS(outer);
         if(clazz == &sXPC_XOW_JSClass.base &&
            (unsafeObj = XPCWrapper::Unwrap(cx, outer)))
         {
             outer = unsafeObj;
         }
 
         if(outer && outer != obj)
-            return xpc_qsUnwrapThisImpl(cx, outer, iid, ppThis, ppWrapper);
+            return xpc_qsUnwrapThisImpl(cx, outer, iid, ppThis, pThisRef, vp);
     }
 
+    *pThisRef = nsnull;
     return xpc_qsThrow(cx, NS_ERROR_XPC_BAD_OP_ON_WN_PROTO);
 }
 
 JSBool
 xpc_qsUnwrapThisFromCcxImpl(XPCCallContext &ccx,
                             const nsIID &iid,
-                            void **ppThis)
+                            void **ppThis,
+                            nsISupports **pThisRef,
+                            jsval *vp)
 {
     XPCWrappedNative *wrapper = ccx.GetWrapper();
     if(!wrapper)
         return xpc_qsThrow(ccx.GetJSContext(), NS_ERROR_XPC_BAD_OP_ON_WN_PROTO);
     if(!wrapper->IsValid())
         return xpc_qsThrow(ccx.GetJSContext(), NS_ERROR_XPC_HAS_BEEN_SHUTDOWN);
 
-    nsISupports *idobj = wrapper->GetIdentityObject();
-    nsresult rv = idobj->QueryInterface(iid, ppThis);
+    nsresult rv = getNativeFromWrapper(wrapper, iid, ppThis, pThisRef, vp);
     if(NS_FAILED(rv))
         return xpc_qsThrow(ccx.GetJSContext(), rv);
     return JS_TRUE;
 }
 
 nsresult
 xpc_qsUnwrapArgImpl(JSContext *cx,
                     jsval v,
diff -r 4f1383af8f10 js/src/xpconnect/src/xpcquickstubs.h
--- a/js/src/xpconnect/src/xpcquickstubs.h	Sat Nov 01 09:52:29 2008 +0100
+++ b/js/src/xpconnect/src/xpcquickstubs.h	Mon Nov 03 05:09:09 2008 -0500
@@ -73,39 +73,63 @@ xpc_qsDefineQuickStubs(JSContext *cx, JS
 xpc_qsDefineQuickStubs(JSContext *cx, JSObject *proto, uintN extraFlags,
                        PRUint32 ifacec, const nsIID **interfaces,
                        PRUint32 tableSize, const xpc_qsHashEntry *table);
 
 /** Raise an exception on @a cx and return JS_FALSE. */
 JSBool
 xpc_qsThrow(JSContext *cx, nsresult rv);
 
-/** Elaborately fail after an XPCOM method returned rv. */
+/**
+ * Fail after an XPCOM getter or setter returned rv.
+ *
+ * NOTE: Here @a obj must be the JSObject whose private data field points to an
+ * XPCWrappedNative, not merely an object that has an XPCWrappedNative
+ * somewhere along the prototype chain!  The same applies to @a obj in
+ * xpc_qsThrowBadSetterValue and <code>vp[1]</code> in xpc_qsThrowMethodFailed
+ * and xpc_qsThrowBadArg.
+ *
+ * This is one reason the UnwrapThis functions below have an out parameter that
+ * receives the wrapper JSObject.  (The other reason is to help the caller keep
+ * that JSObject GC-reachable.)
+ */
 JSBool
 xpc_qsThrowGetterSetterFailed(JSContext *cx, nsresult rv,
-                              XPCWrappedNative *wrapper, jsval memberId);
+                              JSObject *obj, jsval memberId);
 
+/**
+ * Fail after an XPCOM method returned rv.
+ *
+ * See NOTE at xpc_qsThrowGetterSetterFailed.
+ */
 JSBool
-xpc_qsThrowMethodFailed(JSContext *cx, nsresult rv,
-                        XPCWrappedNative *wrapper, jsval *vp);
+xpc_qsThrowMethodFailed(JSContext *cx, nsresult rv, jsval *vp);
 
 JSBool
 xpc_qsThrowMethodFailedWithCcx(XPCCallContext &ccx, nsresult rv);
 
-/** Elaborately fail after converting an argument fails. */
+/**
+ * Fail after converting a method argument fails.
+ *
+ * See NOTE at xpc_qsThrowGetterSetterFailed.
+ */
 void
-xpc_qsThrowBadArg(JSContext *cx, nsresult rv,
-                  XPCWrappedNative *wrapper, jsval *vp, uintN paramnum);
+xpc_qsThrowBadArg(JSContext *cx, nsresult rv, jsval *vp, uintN paramnum);
 
 void
 xpc_qsThrowBadArgWithCcx(XPCCallContext &ccx, nsresult rv, uintN paramnum);
 
+/**
+ * Fail after converting a setter argument fails.
+ *
+ * See NOTE at xpc_qsThrowGetterSetterFailed.
+ */
 void
-xpc_qsThrowBadSetterValue(JSContext *cx, nsresult rv,
-                          XPCWrappedNative *wrapper, jsval propId);
+xpc_qsThrowBadSetterValue(JSContext *cx, nsresult rv, JSObject *obj,
+                          jsval propId);
 
 
 /* Functions for converting values between COM and JS. */
 
 inline JSBool
 xpc_qsInt32ToJsval(JSContext *cx, PRInt32 i, jsval *rv)
 {
     if(INT_FITS_IN_JSVAL(i))
@@ -235,16 +259,46 @@ public:
  * with [cstring] rather than [domstring] or [astring].
  */
 class xpc_qsACString : public xpc_qsBasicString<nsACString, nsCString>
 {
 public:
     xpc_qsACString(JSContext *cx, jsval *pval);
 };
 
+struct xpc_qsSelfRef
+{
+    xpc_qsSelfRef() {}
+    explicit xpc_qsSelfRef(nsISupports *p) : ptr(p) {}
+    ~xpc_qsSelfRef() { NS_IF_RELEASE(ptr); }
+
+    nsISupports* ptr;
+};
+
+struct xpc_qsTempRoot
+{
+  public:
+    explicit xpc_qsTempRoot(JSContext *cx)
+        : mContext(cx) {
+        JS_PUSH_SINGLE_TEMP_ROOT(cx, JSVAL_NULL, &mTvr);
+    }
+
+    ~xpc_qsTempRoot() {
+        JS_POP_TEMP_ROOT(mContext, &mTvr);
+    }
+
+    jsval * addr() {
+        return &mTvr.u.value;
+    }
+
+  private:
+    JSContext *mContext;
+    JSTempValueRooter mTvr;
+};
+
 /**
  * Convert a jsval to char*, returning JS_TRUE on success.
  *
  * @param cx
  *      A context.
  * @param pval
  *     In/out. *pval is the jsval to convert; the function may write to *pval,
  *     using it as a GC root (like xpc_qsDOMString's constructor).
@@ -263,61 +317,74 @@ JSBool
 JSBool
 xpc_qsStringToJsval(JSContext *cx, const nsAString &str, jsval *rval);
 
 JSBool
 xpc_qsUnwrapThisImpl(JSContext *cx,
                      JSObject *obj,
                      const nsIID &iid,
                      void **ppThis,
-                     XPCWrappedNative **ppWrapper);
+                     nsISupports **ppThisRef,
+                     jsval *vp);
 
 /**
  * Search @a obj and its prototype chain for an XPCOM object that implements
  * the interface T.
  *
- * If an object implementing T is found, AddRef it, store the pointer in
- * @a *ppThis, store a pointer to the wrapper in @a *ppWrapper, and return
+ * If an object implementing T is found, store a reference to the wrapper
+ * JSObject in @a *pThisVal, store a pointer to the T in @a *ppThis, and return
  * JS_TRUE. Otherwise, raise an exception on @a cx and return JS_FALSE.
  *
- * This does not consult inner objects. It does support XPConnect tear-offs
- * and it sees through XOWs, XPCNativeWrappers, and SafeJSObjectWrappers.
+ * @a *pThisRef receives the same pointer as *ppThis if the T was AddRefed.
+ * Otherwise it receives null (even on error).
+ *
+ * This supports split objects and XPConnect tear-offs and it sees through
+ * XOWs, XPCNativeWrappers, and SafeJSObjectWrappers.
  *
  * Requires a request on @a cx.
  */
 template <class T>
 inline JSBool
 xpc_qsUnwrapThis(JSContext *cx,
                  JSObject *obj,
                  T **ppThis,
-                 XPCWrappedNative **ppWrapper)
+                 nsISupports **pThisRef,
+                 jsval *pThisVal)
 {
     return xpc_qsUnwrapThisImpl(cx,
                                 obj,
                                 NS_GET_TEMPLATE_IID(T),
                                 reinterpret_cast<void **>(ppThis),
-                                ppWrapper);
+                                pThisRef,
+                                pThisVal);
 }
 
 JSBool
 xpc_qsUnwrapThisFromCcxImpl(XPCCallContext &ccx,
                             const nsIID &iid,
-                            void **ppThis);
+                            void **ppThis,
+                            nsISupports **pThisRef,
+                            jsval *vp);
 
 /**
  * Alternate implementation of xpc_qsUnwrapThis using information already
  * present in the given XPCCallContext.
  */
 template <class T>
 inline JSBool
 xpc_qsUnwrapThisFromCcx(XPCCallContext &ccx,
-                        T **ppThis)
+                        T **ppThis,
+                        nsISupports **pThisRef,
+                        jsval *pThisVal)
 {
-    return xpc_qsUnwrapThisFromCcxImpl(ccx, NS_GET_TEMPLATE_IID(T),
-                                       reinterpret_cast<void **>(ppThis));
+    return xpc_qsUnwrapThisFromCcxImpl(ccx,
+                                       NS_GET_TEMPLATE_IID(T),
+                                       reinterpret_cast<void **>(ppThis),
+                                       pThisRef,
+                                       pThisVal);
 }
 
 nsresult
 xpc_qsUnwrapArgImpl(JSContext *cx, jsval v, const nsIID &iid, void **ppArg);
 
 /** Convert a jsval to an XPCOM pointer. */
 template <class T>
 inline nsresult
diff -r 4f1383af8f10 js/src/xpconnect/src/xpcwrappednative.cpp
--- a/js/src/xpconnect/src/xpcwrappednative.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/js/src/xpconnect/src/xpcwrappednative.cpp	Mon Nov 03 05:09:09 2008 -0500
@@ -449,16 +449,18 @@ XPCWrappedNative::GetNewOrUsed(XPCCallCo
     // wrapper is actually created, but before JS code can see it.
 
     if(info && !isClassInfo)
     {
         proto = XPCWrappedNativeProto::GetNewOrUsed(ccx, Scope, info, &sciProto,
                                                     JS_FALSE, isGlobal);
         if(!proto)
             return NS_ERROR_FAILURE;
+
+        proto->CacheOffsets(identity);
 
         wrapper = new XPCWrappedNative(identity, proto);
         if(!wrapper)
             return NS_ERROR_FAILURE;
     }
     else
     {
         AutoMarkingNativeSetPtr set(ccx);
@@ -1226,17 +1228,18 @@ XPCWrappedNative::ReparentWrapperIfFound
             oldProto = wrapper->GetProto();
             XPCNativeScriptableInfo *info = oldProto->GetScriptableInfo();
             XPCNativeScriptableCreateInfo ci(*info);
             newProto =
                 XPCWrappedNativeProto::GetNewOrUsed(ccx, aNewScope,
                                                     oldProto->GetClassInfo(),
                                                     &ci,
                                                     !oldProto->IsShared(),
-                                                    (info->GetJSClass()->flags & JSCLASS_IS_GLOBAL));
+                                                    (info->GetJSClass()->flags & JSCLASS_IS_GLOBAL),
+                                                    oldProto->GetOffsetsMasked());
             if(!newProto)
             {
                 NS_RELEASE(wrapper);
                 return NS_ERROR_FAILURE;
             }
         }
 
         if(!XPC_XOW_WrapperMoved(ccx, wrapper, aNewScope))
@@ -2708,17 +2711,18 @@ NS_IMETHODIMP XPCWrappedNative::RefreshP
     oldProto = GetProto();
 
     XPCNativeScriptableInfo *info = oldProto->GetScriptableInfo();
     XPCNativeScriptableCreateInfo ci(*info);
     newProto = XPCWrappedNativeProto::GetNewOrUsed(ccx, oldProto->GetScope(),
                                                    oldProto->GetClassInfo(),
                                                    &ci,
                                                    !oldProto->IsShared(),
-                                                   (info->GetJSClass()->flags & JSCLASS_IS_GLOBAL));
+                                                   (info->GetJSClass()->flags & JSCLASS_IS_GLOBAL),
+                                                   oldProto->GetOffsetsMasked());
     if(!newProto)
         return UnexpectedFailure(NS_ERROR_FAILURE);
 
     // If nothing needs to change then we're done.
 
     if(newProto.get() == oldProto.get())
         return NS_OK;
 
diff -r 4f1383af8f10 js/src/xpconnect/src/xpcwrappednativeproto.cpp
--- a/js/src/xpconnect/src/xpcwrappednativeproto.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/js/src/xpconnect/src/xpcwrappednativeproto.cpp	Mon Nov 03 05:09:09 2008 -0500
@@ -44,24 +44,26 @@
 
 #if defined(DEBUG_xpc_hacker) || defined(DEBUG)
 PRInt32 XPCWrappedNativeProto::gDEBUG_LiveProtoCount = 0;
 #endif
 
 XPCWrappedNativeProto::XPCWrappedNativeProto(XPCWrappedNativeScope* Scope,
                                              nsIClassInfo* ClassInfo,
                                              PRUint32 ClassInfoFlags,
-                                             XPCNativeSet* Set)
+                                             XPCNativeSet* Set,
+                                             QITableEntry* offsets)
     : mScope(Scope),
       mJSProtoObject(nsnull),
       mClassInfo(ClassInfo),
       mClassInfoFlags(ClassInfoFlags),
       mSet(Set),
       mSecurityInfo(nsnull),
-      mScriptableInfo(nsnull)
+      mScriptableInfo(nsnull),
+      mOffsets(offsets)
 {
     // This native object lives as long as its associated JSObject - killed
     // by finalization of the JSObject (or explicitly if Init fails).
 
     MOZ_COUNT_CTOR(XPCWrappedNativeProto);
 
 #ifdef DEBUG
     PR_AtomicIncrement(&gDEBUG_LiveProtoCount);
@@ -200,17 +202,18 @@ XPCWrappedNativeProto::SystemIsBeingShut
 
 // static
 XPCWrappedNativeProto*
 XPCWrappedNativeProto::GetNewOrUsed(XPCCallContext& ccx,
                                     XPCWrappedNativeScope* Scope,
                                     nsIClassInfo* ClassInfo,
                                     const XPCNativeScriptableCreateInfo* ScriptableCreateInfo,
                                     JSBool ForceNoSharing,
-                                    JSBool isGlobal)
+                                    JSBool isGlobal,
+                                    QITableEntry* offsets)
 {
     NS_ASSERTION(Scope, "bad param");
     NS_ASSERTION(ClassInfo, "bad param");
 
     AutoMarkingWrappedNativeProtoPtr proto(ccx);
     ClassInfo2WrappedNativeProtoMap* map;
     XPCLock* lock;
     JSBool shared;
@@ -249,17 +252,17 @@ XPCWrappedNativeProto::GetNewOrUsed(XPCC
         }
     }
 
     AutoMarkingNativeSetPtr set(ccx);
     set = XPCNativeSet::GetNewOrUsed(ccx, ClassInfo);
     if(!set)
         return nsnull;
 
-    proto = new XPCWrappedNativeProto(Scope, ClassInfo, ciFlags, set);
+    proto = new XPCWrappedNativeProto(Scope, ClassInfo, ciFlags, set, offsets);
 
     if(!proto || !proto->Init(ccx, isGlobal, ScriptableCreateInfo))
     {
         delete proto.get();
         return nsnull;
     }
 
     if(shared)
diff -r 4f1383af8f10 layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/base/nsCSSFrameConstructor.cpp	Mon Nov 03 05:09:09 2008 -0500
@@ -13262,16 +13262,20 @@ nsCSSFrameConstructor::RebuildAllStyleDa
                "Should not reconstruct the root of the frame tree.  "
                "Use ReconstructDocElementHierarchy instead.");
 
   mRebuildAllStyleData = PR_FALSE;
 
   if (!mPresShell || !mPresShell->GetRootFrame())
     return;
 
+  // Processing the style changes could cause a flush that propagates to
+  // the parent frame and thus destroys the pres shell.
+  nsCOMPtr<nsIPresShell> kungFuDeathGrip(mPresShell);
+
   // Tell the style set to get the old rule tree out of the way
   // so we can recalculate while maintaining rule tree immutability
   nsresult rv = mPresShell->StyleSet()->BeginReconstruct();
   if (NS_FAILED(rv))
     return;
 
   // Recalculate all of the style contexts for the document
   // Note that we can ignore the return value of ComputeStyleChangeFor
diff -r 4f1383af8f10 layout/base/nsDocumentViewer.cpp
--- a/layout/base/nsDocumentViewer.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/base/nsDocumentViewer.cpp	Mon Nov 03 05:09:09 2008 -0500
@@ -316,17 +316,16 @@ public:
 
   // nsISupports interface...
   NS_DECL_ISUPPORTS
 
   // nsIContentViewer interface...
   NS_DECL_NSICONTENTVIEWER
 
   // nsIDocumentViewer interface...
-  NS_IMETHOD SetUAStyleSheet(nsIStyleSheet* aUAStyleSheet);
   NS_IMETHOD GetDocument(nsIDocument** aResult);
   NS_IMETHOD GetPresShell(nsIPresShell** aResult);
   NS_IMETHOD GetPresContext(nsPresContext** aResult);
 
   // nsIContentViewerEdit
   NS_DECL_NSICONTENTVIEWEREDIT
 
   // nsIContentViewerFile
@@ -419,18 +418,16 @@ protected:
 
   // the following six items are explicitly in this order
   // so they will be destroyed in the reverse order (pinkerton, scc)
   nsCOMPtr<nsIDocument>    mDocument;
   nsCOMPtr<nsIWidget>      mWindow;      // ??? should we really own it?
   nsCOMPtr<nsIViewManager> mViewManager;
   nsCOMPtr<nsPresContext> mPresContext;
   nsCOMPtr<nsIPresShell>   mPresShell;
-
-  nsCOMPtr<nsIStyleSheet>  mUAStyleSheet;
 
   nsCOMPtr<nsISelectionListener> mSelectionListener;
   nsCOMPtr<nsIDOMFocusListener> mFocusListener;
 
   nsCOMPtr<nsIContentViewer> mPreviousViewer;
   nsCOMPtr<nsISHEntry> mSHEntry;
 
   nsIWidget* mParentWidget; // purposely won't be ref counted.  May be null
@@ -1655,29 +1652,16 @@ DocumentViewerImpl::SetDOMDocument(nsIDO
 
     rv = InitPresentationStuff(PR_FALSE, PR_TRUE);
   }
 
   return rv;
 }
 
 NS_IMETHODIMP
-DocumentViewerImpl::SetUAStyleSheet(nsIStyleSheet* aUAStyleSheet)
-{
-  NS_ASSERTION(aUAStyleSheet, "unexpected null pointer");
-  nsCOMPtr<nsICSSStyleSheet> sheet(do_QueryInterface(aUAStyleSheet));
-  if (sheet) {
-    nsCOMPtr<nsICSSStyleSheet> newSheet;
-    sheet->Clone(nsnull, nsnull, nsnull, nsnull, getter_AddRefs(newSheet));
-    mUAStyleSheet = newSheet;
-  }
-  return NS_OK;
-}
-
-NS_IMETHODIMP
 DocumentViewerImpl::GetDocument(nsIDocument** aResult)
 {
   NS_IF_ADDREF(*aResult = mDocument);
 
   return NS_OK;
 }
 
 nsIPresShell*
@@ -2086,20 +2070,16 @@ nsresult
 nsresult
 DocumentViewerImpl::CreateStyleSet(nsIDocument* aDocument,
                                    nsStyleSet** aStyleSet)
 {
   // Make sure this does the same thing as PresShell::AddSheet wrt ordering.
 
   // this should eventually get expanded to allow for creating
   // different sets for different media
-  if (!mUAStyleSheet) {
-    NS_WARNING("unable to load UA style sheet");
-  }
-
   nsStyleSet *styleSet = new nsStyleSet();
   if (!styleSet) {
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
   styleSet->BeginUpdate();
   
   // The document will fill in the document sheets when we create the presshell
@@ -2172,19 +2152,34 @@ DocumentViewerImpl::CreateStyleSet(nsIDo
     }
   }
 
   sheet = nsLayoutStylesheetCache::FormsSheet();
   if (sheet) {
     styleSet->PrependStyleSheet(nsStyleSet::eAgentSheet, sheet);
   }
 
-  if (mUAStyleSheet) {
-    styleSet->PrependStyleSheet(nsStyleSet::eAgentSheet, mUAStyleSheet);
-  }
+  // Make sure to clone the quirk sheet so that it can be usefully
+  // enabled/disabled as needed.
+  nsCOMPtr<nsICSSStyleSheet> quirkClone;
+  if (!nsLayoutStylesheetCache::UASheet() ||
+      !nsLayoutStylesheetCache::QuirkSheet() ||
+      NS_FAILED(nsLayoutStylesheetCache::QuirkSheet()->
+                Clone(nsnull, nsnull, nsnull, nsnull,
+                      getter_AddRefs(quirkClone))) ||
+      !sheet) {
+    delete styleSet;
+    return NS_ERROR_OUT_OF_MEMORY;
+  }
+  // quirk.css needs to come after the regular UA sheet (or more precisely,
+  // after the html.css and so forth that the UA sheet imports).
+  styleSet->PrependStyleSheet(nsStyleSet::eAgentSheet, quirkClone);
+  styleSet->SetQuirkStyleSheet(quirkClone);
+  styleSet->PrependStyleSheet(nsStyleSet::eAgentSheet,
+                              nsLayoutStylesheetCache::UASheet());
 
   nsCOMPtr<nsIStyleSheetService> dummy =
     do_GetService(NS_STYLESHEETSERVICE_CONTRACTID);
 
   nsStyleSheetService *sheetService = nsStyleSheetService::gInstance;
   if (sheetService) {
     sheetService->AgentStyleSheets()->EnumerateForwards(AppendAgentSheet,
                                                         styleSet);
diff -r 4f1383af8f10 layout/base/nsFrameManager.cpp
--- a/layout/base/nsFrameManager.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/base/nsFrameManager.cpp	Mon Nov 03 05:09:09 2008 -0500
@@ -197,17 +197,25 @@ public:
       mNext(nsnull)
   {
     MOZ_COUNT_CTOR(UndisplayedNode);
   }
 
   NS_HIDDEN ~UndisplayedNode()
   {
     MOZ_COUNT_DTOR(UndisplayedNode);
-    delete mNext;
+
+    // Delete mNext iteratively to avoid blowing up the stack (bug 460461).
+    UndisplayedNode *cur = mNext;
+    while (cur) {
+      UndisplayedNode *next = cur->mNext;
+      cur->mNext = nsnull;
+      delete cur;
+      cur = next;
+    }
   }
 
   nsCOMPtr<nsIContent>      mContent;
   nsRefPtr<nsStyleContext>  mStyle;
   UndisplayedNode*          mNext;
 };
 
 class nsFrameManagerBase::UndisplayedMap {
diff -r 4f1383af8f10 layout/base/nsIDocumentViewer.h
--- a/layout/base/nsIDocumentViewer.h	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/base/nsIDocumentViewer.h	Mon Nov 03 05:09:09 2008 -0500
@@ -43,29 +43,27 @@
 #include "nsIContentViewer.h"
 
 class nsIDocument;
 class nsPresContext;
 class nsIPresShell;
 class nsIStyleSheet;
 
 #define NS_IDOCUMENT_VIEWER_IID \
- { 0x41796e63, 0xbd1f, 0x401d,{0xb6, 0x63, 0x5b, 0x86, 0xa9, 0x70, 0x72, 0x31}}
+ { 0xf81fc126, 0x6693, 0x4bc5,{0xa7, 0xe9, 0xfc, 0xb0, 0x76, 0xd9, 0x06, 0x6d} }
 
 /**
  * A document viewer is a kind of content viewer that uses NGLayout
  * to manage the presentation of the content.
  */
 class nsIDocumentViewer : public nsIContentViewer
 {
 public:
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_IDOCUMENT_VIEWER_IID)
 
-  NS_IMETHOD SetUAStyleSheet(nsIStyleSheet* aUAStyleSheet) = 0;
-  
   NS_IMETHOD GetDocument(nsIDocument** aResult) = 0;
   
   NS_IMETHOD GetPresShell(nsIPresShell** aResult) = 0;
   
   NS_IMETHOD GetPresContext(nsPresContext** aResult) = 0;
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(nsIDocumentViewer, NS_IDOCUMENT_VIEWER_IID)
diff -r 4f1383af8f10 layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/base/nsPresShell.cpp	Mon Nov 03 05:09:09 2008 -0500
@@ -2632,16 +2632,17 @@ PresShell::FireResizeEvent()
 
   //Send resize event from here.
   nsEvent event(PR_TRUE, NS_RESIZE_EVENT);
   nsEventStatus status = nsEventStatus_eIgnore;
 
   nsPIDOMWindow *window = mDocument->GetWindow();
   if (window) {
     nsEventDispatcher::Dispatch(window, mPresContext, &event, nsnull, &status);
+    // |this| may now be destroyed
   }
 }
 
 NS_IMETHODIMP
 PresShell::SetIgnoreFrameDestruction(PRBool aIgnore)
 {
   mIgnoreFrameDestruction = aIgnore;
   return NS_OK;
diff -r 4f1383af8f10 layout/build/nsContentDLF.cpp
--- a/layout/build/nsContentDLF.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/build/nsContentDLF.cpp	Mon Nov 03 05:09:09 2008 -0500
@@ -64,19 +64,16 @@
 #include "nsIParser.h"
 
 // plugins
 #include "nsIPluginManager.h"
 #include "nsIPluginHost.h"
 static NS_DEFINE_CID(kPluginManagerCID, NS_PLUGINMANAGER_CID);
 static NS_DEFINE_CID(kPluginDocumentCID, NS_PLUGINDOCUMENT_CID);
 
-// URL for the "user agent" style sheet
-#define UA_CSS_URL "resource://gre/res/ua.css"
-
 // Factory code for creating variations on html documents
 
 #undef NOISY_REGISTRY
 
 static NS_DEFINE_IID(kHTMLDocumentCID, NS_HTMLDOCUMENT_CID);
 static NS_DEFINE_IID(kXMLDocumentCID, NS_XMLDOCUMENT_CID);
 #ifdef MOZ_SVG
 static NS_DEFINE_IID(kSVGDocumentCID, NS_SVGDOCUMENT_CID);
@@ -126,18 +123,16 @@ PRBool NS_SVGEnabled();
 #endif
 
 static const char* const gXULTypes[] = {
   "application/vnd.mozilla.xul+xml",
   "mozilla.application/cached-xul",
   0
 };
 
-nsICSSStyleSheet* nsContentDLF::gUAStyleSheet;
-
 nsresult
 NS_NewContentDocumentLoaderFactory(nsIDocumentLoaderFactory** aResult)
 {
   NS_PRECONDITION(aResult, "null OUT ptr");
   if (!aResult) {
     return NS_ERROR_NULL_POINTER;
   }
   nsContentDLF* it = new nsContentDLF();
@@ -164,18 +159,16 @@ nsContentDLF::CreateInstance(const char*
                              nsIChannel* aChannel,
                              nsILoadGroup* aLoadGroup,
                              const char* aContentType, 
                              nsISupports* aContainer,
                              nsISupports* aExtraInfo,
                              nsIStreamListener** aDocListener,
                              nsIContentViewer** aDocViewer)
 {
-  EnsureUAStyleSheet();
-
   // Are we viewing source?
 #ifdef MOZ_VIEW_SOURCE
   nsCOMPtr<nsIViewSourceChannel> viewSourceChannel = do_QueryInterface(aChannel);
   if (viewSourceChannel)
   {
     aCommand = "view-source";
 
     // The parser freaks out when it sees the content-type that a
@@ -309,25 +302,21 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsContentDLF::CreateInstanceForDocument(nsISupports* aContainer,
                                         nsIDocument* aDocument,
                                         const char *aCommand,
                                         nsIContentViewer** aDocViewerResult)
 {
   nsresult rv = NS_ERROR_FAILURE;  
 
-  EnsureUAStyleSheet();
-
   do {
     nsCOMPtr<nsIDocumentViewer> docv;
     rv = NS_NewDocumentViewer(getter_AddRefs(docv));
     if (NS_FAILED(rv))
       break;
-
-    docv->SetUAStyleSheet(static_cast<nsIStyleSheet*>(gUAStyleSheet));
 
     // Bind the document to the Content Viewer
     nsIContentViewer* cv = static_cast<nsIContentViewer*>(docv.get());
     rv = cv->LoadStart(aDocument);
     NS_ADDREF(*aDocViewerResult = cv);
   } while (PR_FALSE);
 
   return rv;
@@ -434,17 +423,16 @@ nsContentDLF::CreateDocument(const char*
     doc = do_CreateInstance(aDocumentCID, &rv);
     if (NS_FAILED(rv))
       break;
 
     // Create the document viewer  XXX: could reuse document viewer here!
     rv = NS_NewDocumentViewer(getter_AddRefs(docv));
     if (NS_FAILED(rv))
       break;
-    docv->SetUAStyleSheet(gUAStyleSheet);
 
     doc->SetContainer(aContainer);
 
     // Initialize the document to begin loading the data.  An
     // nsIStreamListener connected to the parser is returned in
     // aDocListener.
     rv = doc->StartDocumentLoad(aCommand, aChannel, aLoadGroup, aContainer, aDocListener, PR_TRUE);
     if (NS_FAILED(rv))
@@ -471,19 +459,16 @@ nsContentDLF::CreateXULDocument(const ch
 {
   nsresult rv;
   nsCOMPtr<nsIDocument> doc = do_CreateInstance(kXULDocumentCID, &rv);
   if (NS_FAILED(rv)) return rv;
 
   nsCOMPtr<nsIDocumentViewer> docv;
   rv = NS_NewDocumentViewer(getter_AddRefs(docv));
   if (NS_FAILED(rv)) return rv;
-
-  // Load the UA style sheet if we haven't already done that
-  docv->SetUAStyleSheet(gUAStyleSheet);
 
   nsCOMPtr<nsIURI> aURL;
   rv = aChannel->GetURI(getter_AddRefs(aURL));
   if (NS_FAILED(rv)) return rv;
 
   /* 
    * Initialize the document to begin loading the data...
    *
@@ -613,35 +598,8 @@ nsContentDLF::UnregisterDocumentFactorie
 #endif
     rv = UnregisterTypes(catmgr, gXULTypes);
     if (NS_FAILED(rv))
       break;
   } while (PR_FALSE);
 
   return rv;
 }
-
-/* static */ nsresult
-nsContentDLF::EnsureUAStyleSheet()
-{
-  if (gUAStyleSheet)
-    return NS_OK;
-
-  // Load the UA style sheet
-  nsCOMPtr<nsIURI> uri;
-  nsresult rv = NS_NewURI(getter_AddRefs(uri), NS_LITERAL_CSTRING(UA_CSS_URL));
-  if (NS_FAILED(rv)) {
-#ifdef DEBUG
-    printf("*** open of %s failed: error=%x\n", UA_CSS_URL, rv);
-#endif
-    return rv;
-  }
-  nsCOMPtr<nsICSSLoader> cssLoader;
-  NS_NewCSSLoader(getter_AddRefs(cssLoader));
-  if (!cssLoader)
-    return NS_ERROR_OUT_OF_MEMORY;
-  rv = cssLoader->LoadSheetSync(uri, PR_TRUE, &gUAStyleSheet);
-#ifdef DEBUG
-  if (NS_FAILED(rv))
-    printf("*** open of %s failed: error=%x\n", UA_CSS_URL, rv);
-#endif
-  return rv;
-}
diff -r 4f1383af8f10 layout/build/nsContentDLF.h
--- a/layout/build/nsContentDLF.h	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/build/nsContentDLF.h	Mon Nov 03 05:09:09 2008 -0500
@@ -76,18 +76,16 @@ public:
                              nsIChannel* aChannel,
                              nsILoadGroup* aLoadGroup,
                              const char* aContentType,
                              nsISupports* aContainer,
                              nsISupports* aExtraInfo,
                              nsIStreamListener** aDocListener,
                              nsIContentViewer** aDocViewer);
 
-  static nsICSSStyleSheet* gUAStyleSheet;
-
 #ifdef MOZ_SVG
   static NS_IMETHODIMP RegisterSVG();
   static NS_IMETHODIMP UnregisterSVG();
 #endif
 
   static NS_IMETHODIMP
   RegisterDocumentFactories(nsIComponentManager* aCompMgr,
                             nsIFile* aPath,
diff -r 4f1383af8f10 layout/build/nsLayoutStatics.cpp
--- a/layout/build/nsLayoutStatics.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/build/nsLayoutStatics.cpp	Mon Nov 03 05:09:09 2008 -0500
@@ -307,28 +307,26 @@ nsLayoutStatics::Shutdown()
 #endif
 
   nsCSSFrameConstructor::ReleaseGlobals();
   nsSpaceManager::Shutdown();
   nsImageFrame::ReleaseGlobals();
 
   nsCSSScanner::ReleaseGlobals();
 
-  NS_IF_RELEASE(nsContentDLF::gUAStyleSheet);
   NS_IF_RELEASE(nsRuleNode::gLangService);
   nsStyledElement::Shutdown();
 
   nsTextFragment::Shutdown();
 
   nsAttrValue::Shutdown();
   nsContentUtils::Shutdown();
   nsNodeInfo::ClearCache();
   nsLayoutStylesheetCache::Shutdown();
   NS_NameSpaceManagerShutdown();
-  nsStyleSet::FreeGlobals();
 
   nsJSRuntime::Shutdown();
   nsGlobalWindow::ShutDown();
   nsDOMClassInfo::ShutDown();
   nsTextControlFrame::ShutDown();
   nsXBLWindowKeyHandler::ShutDown();
   nsAutoCopyListener::Shutdown();
 
diff -r 4f1383af8f10 layout/generic/nsObjectFrame.cpp
--- a/layout/generic/nsObjectFrame.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/generic/nsObjectFrame.cpp	Mon Nov 03 05:09:09 2008 -0500
@@ -1544,24 +1544,17 @@ nsObjectFrame::PaintPlugin(nsIRenderingC
       if (printProc) {
         HWND hwnd = reinterpret_cast<HWND>(window->window);
         RECT rc;
         GetWindowRect(hwnd, &rc);
         nsRefPtr<gfxWindowsSurface> surface =
           new gfxWindowsSurface(gfxIntSize(rc.right - rc.left, rc.bottom - rc.top));
 
         if (surface && printProc) {
-          // CAUTION: EVIL AHEAD
-          // We have to temporarily make hwnd a top-level window so that
-          // PrintWindow won't clip it
-          HWND parent = ::GetParent(hwnd);
-          ::SetParent(hwnd, NULL);
           printProc(hwnd, surface->GetDC(), 0);
-          ::SetParent(hwnd, parent);
-          // END EVIL
         
           ctx->Translate(frameGfxRect.pos);
           ctx->SetSource(surface);
           gfxRect r = frameGfxRect.Intersect(dirtyGfxRect) - frameGfxRect.pos;
           ctx->NewPath();
           ctx->Rectangle(r);
           ctx->Fill();
         }
diff -r 4f1383af8f10 layout/reftests/bugs/385823-2c.html
--- a/layout/reftests/bugs/385823-2c.html	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/reftests/bugs/385823-2c.html	Mon Nov 03 05:09:09 2008 -0500
@@ -2,15 +2,14 @@
 <body>
 <!-- Specify a width on the table, to make sure it's wide enough
      to hold the scaled image. -->
 <table cellspacing="0" cellpadding="0" height="70px" width="724px">
  <tr><td>
   <img src="mozilla-banner.gif" height="100%"/>
   <br/>
   <!-- Add some text content, but make it small enough not
-       to push us to over 70px before we scale the image.
-       This text should end up hidden behind the image. -->
-  <font style="font-size: 20%">text text</font>
+       to push us to over 70px before we scale the image. -->
+  <font style="font-size: 20%; color:rgba(0,0,0,0);">text text</font>
  </tr></td>
 </table>
 </body>
 </html>
diff -r 4f1383af8f10 layout/reftests/bugs/461266-1-ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/461266-1-ref.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,17 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
+<html>
+<head>
+    <title>Testcase for bug 461266</title>
+    <style type="text/css">
+        div {
+            height: 100px; width: 100px;
+            background-color: blue; 
+            float: right;
+        }
+    </style>
+</head>
+
+<body>
+  <div></div>
+</body>
+</html>
diff -r 4f1383af8f10 layout/reftests/bugs/461266-1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/461266-1.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,20 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
+<html>
+<head>
+    <title>Testcase for bug 461266</title>
+    <style type="text/css">
+      div { height: 100px; width: 100px; }
+
+      @media all and (min-width:0) {}
+      div { background-color: blue; }
+
+      /* This line stops parsing of following selectors  */
+      @media all and(min-width:0) {}
+      div { float: right; }
+    </style>
+</head>
+
+<body>
+  <div></div>
+</body>
+</html>
diff -r 4f1383af8f10 layout/reftests/bugs/reftest.list
--- a/layout/reftests/bugs/reftest.list	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/reftests/bugs/reftest.list	Mon Nov 03 05:09:09 2008 -0500
@@ -926,9 +926,10 @@ fails == 441259-2.html 441259-2-ref.html
 == 451168-1.html 451168-1-ref.html
 == 452964-1.html 452964-1-ref.html
 == 454361.html about:blank
 == 455105-1.html 455105-ref.html
 == 455105-2.html 455105-ref.html
 == 455280-1.xhtml 455280-1-ref.xhtml
 fails-if(MOZ_WIDGET_TOOLKIT=="cocoa") == 456147.xul 456147-ref.html # bug 456147, but not caused by it
 == 456484-1.html 456484-1-ref.html
+== 461266-1.html 461266-1-ref.html
 fails == 461512-1.html 461512-1-ref.html # Bug 461512
diff -r 4f1383af8f10 layout/reftests/reftest.list
--- a/layout/reftests/reftest.list	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/reftests/reftest.list	Mon Nov 03 05:09:09 2008 -0500
@@ -88,16 +88,19 @@ include svg/reftest.list
 include svg/reftest.list
 
 # svg-integration/
 include svg-integration/reftest.list
 
 # table-background/
 include table-background/reftest.list
 
+# table-bordercollapse/
+include table-bordercollapse/reftest.list
+
 # table-dom/
 include table-dom/reftest.list
 
 # table-width/
 include table-width/reftest.list
 
 # text/
 include text/reftest.list
diff -r 4f1383af8f10 layout/reftests/table-bordercollapse/bc_dyn_cell1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/table-bordercollapse/bc_dyn_cell1.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,20 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
+<head><title>border collapse dynamical change cell style</title>
+<script>
+function doTest(){
+ var t1 =document.getElementById('target');
+ t1.style.borderStyle="solid";
+}
+</script>
+<style>
+td { border: 10px green outset;}
+table {margin: 30px}
+</style>
+</head>
+<body onload="doTest()";>
+<table style="border-collapse:collapse">
+ <tr><td>c11</td><td>c12</td><td>c13</td></tr>
+ <tr><td>c21</td><td id="target" style="border-style:none">c22</td><td>c23</td></tr>
+ <tr><td>c31</td><td>c32</td><td>c33</td></tr>
+</table>
+
diff -r 4f1383af8f10 layout/reftests/table-bordercollapse/bc_dyn_cell1_ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/table-bordercollapse/bc_dyn_cell1_ref.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,14 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
+<head><title>border collapse dynamical change cell style</title>
+<style>
+td { border: 10px green outset;}
+table {margin: 30px}
+</style>
+</head>
+<body>
+<table style="border-collapse:collapse">
+ <tr><td>c11</td><td>c12</td><td>c13</td></tr>
+ <tr><td>c21</td><td style="border-style:solid">c22</td><td>c23</td></tr>
+ <tr><td>c31</td><td>c32</td><td>c33</td></tr>
+</table>
+
diff -r 4f1383af8f10 layout/reftests/table-bordercollapse/bc_dyn_cell2.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/table-bordercollapse/bc_dyn_cell2.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,20 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
+<head><title>border collapse dynamical change cell color</title>
+<script>
+function doTest(){
+ var t1 =document.getElementById('target');
+ t1.style.borderColor="yellow";
+}
+</script>
+<style>
+td { border: 10px green solid;}
+table {margin: 30px}
+</style>
+</head>
+<body onload="doTest()";>
+<table style="border-collapse:collapse">
+ <tr><td>c11</td><td>c12</td><td>c13</td></tr>
+ <tr><td>c21</td><td id="target" style="border-width:11px">c22</td><td>c23</td></tr>
+ <tr><td>c31</td><td>c32</td><td>c33</td></tr>
+</table>
+
diff -r 4f1383af8f10 layout/reftests/table-bordercollapse/bc_dyn_cell2_ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/table-bordercollapse/bc_dyn_cell2_ref.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,15 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
+<head><title>border collapse dynamical change cell color</title>
+
+<style>
+td { border: 10px green solid;}
+table {margin: 30px}
+</style>
+</head>
+<body>
+<table style="border-collapse:collapse">
+ <tr><td>c11</td><td>c12</td><td>c13</td></tr>
+ <tr><td>c21</td><td style="border-width:11px;border-color:yellow">c22</td><td>c23</td></tr>
+ <tr><td>c31</td><td>c32</td><td>c33</td></tr>
+</table>
+
diff -r 4f1383af8f10 layout/reftests/table-bordercollapse/bc_dyn_cell3.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/table-bordercollapse/bc_dyn_cell3.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,20 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
+<head><title>border collapse dynamical change cell border width</title>
+<script>
+function doTest(){
+ var t1 =document.getElementById('target');
+ t1.style.borderWidth="20px";
+}
+</script>
+<style>
+td { border: 10px green solid;}
+table {margin: 30px}
+</style>
+</head>
+<body onload="doTest()";>
+<table style="border-collapse:collapse">
+ <tr><td>c11</td><td>c12</td><td>c13</td></tr>
+ <tr><td>c21</td><td id="target">c22</td><td>c23</td></tr>
+ <tr><td>c31</td><td>c32</td><td>c33</td></tr>
+</table>
+
diff -r 4f1383af8f10 layout/reftests/table-bordercollapse/bc_dyn_cell3_ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/table-bordercollapse/bc_dyn_cell3_ref.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,14 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
+<head><title>border collapse dynamical change cell border width</title>
+<style>
+td { border: 10px green solid;}
+table {margin: 30px}
+</style>
+</head>
+<body>
+<table style="border-collapse:collapse">
+ <tr><td>c11</td><td>c12</td><td>c13</td></tr>
+ <tr><td>c21</td><td style="border-width:20px">c22</td><td>c23</td></tr>
+ <tr><td>c31</td><td>c32</td><td>c33</td></tr>
+</table>
+
diff -r 4f1383af8f10 layout/reftests/table-bordercollapse/bc_dyn_cell4.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/table-bordercollapse/bc_dyn_cell4.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,20 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
+<head><title>border collapse dynamical change colspan cell style</title>
+<script>
+function doTest(){
+ var t1 =document.getElementById('target');
+ t1.style.borderStyle="solid";
+}
+</script>
+<style>
+td { border: 10px green outset;}
+table {margin: 30px}
+</style>
+</head>
+<body onload="doTest()";>
+<table style="border-collapse:collapse">
+ <tr><td>c11</td><td>c12</td><td>c13</td></tr>
+ <tr><td id="target" colspan="3" style="border-style:none">c21</td></tr>
+ <tr><td>c31</td><td>c32</td><td>c33</td></tr>
+</table>
+
diff -r 4f1383af8f10 layout/reftests/table-bordercollapse/bc_dyn_cell4_ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/table-bordercollapse/bc_dyn_cell4_ref.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,14 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
+<head><title>border collapse dynamical change colspan cell style</title>
+<style>
+td { border: 10px green outset;}
+table {margin: 30px}
+</style>
+</head>
+<body>
+<table style="border-collapse:collapse">
+ <tr><td>c11</td><td>c12</td><td>c13</td></tr>
+ <tr><td style="border-style:solid;" colspan="3">c21</td></tr>
+ <tr><td>c31</td><td>c32</td><td>c33</td></tr>
+</table>
+
diff -r 4f1383af8f10 layout/reftests/table-bordercollapse/bc_dyn_cell5.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/table-bordercollapse/bc_dyn_cell5.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,20 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
+<head><title>border collapse dynamical change rowspan cell style </title>
+<script>
+function doTest(){
+ var t1 =document.getElementById('target');
+ t1.style.borderStyle="solid";
+}
+</script>
+<style>
+td { border: 10px green outset;}
+table {margin: 30px}
+</style>
+</head>
+<body onload="doTest()";>
+<table style="border-collapse:collapse">
+  <tr><td>c11</td><td id="target" rowspan="3" style="border-style:none">c12</td><td>c13</td></tr>
+  <tr><td>c21</td><td>c23</td></tr>
+  <tr><td>c31</td><td>c33</td></tr>
+</table>
+
diff -r 4f1383af8f10 layout/reftests/table-bordercollapse/bc_dyn_cell5_ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/table-bordercollapse/bc_dyn_cell5_ref.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,14 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
+<head><title>border collapse dynamical change rowspan cell style </title>
+<style>
+td { border: 10px green outset;}
+table {margin: 30px}
+</style>
+</head>
+<body>
+<table style="border-collapse:collapse">
+  <tr><td>c11</td><td rowspan="3" style="border-style:solid">c12</td><td>c13</td></tr>
+  <tr><td>c21</td><td>c23</td></tr>
+  <tr><td>c31</td><td>c33</td></tr>
+</table>
+
diff -r 4f1383af8f10 layout/reftests/table-bordercollapse/bc_dyn_cg1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/table-bordercollapse/bc_dyn_cg1.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,27 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
+<head><title>border collapse dynamical change colgroup border color</title>
+<script>
+function doTest(){
+ var t1 =document.getElementById('target');
+ t1.style.borderColor="yellow";
+}
+</script>
+<style>
+td { border: 10px green solid;}
+table {margin: 30px}
+</style>
+</head>
+<body onload="doTest()";>
+<table style="border-collapse:collapse">
+<colgroup><col></colgroup>
+<colgroup id="target" style="border:solid green 11px"><col></colgroup>
+<colgroup><col></colgroup>
+<tbody></tbody><tr><td>c11</td><td>c12</td><td>c13</td></tr></tbody>
+ <tbody>
+ <tr><td>c21</td><td>c22</td><td>c23</td></tr>
+ </tbody>
+ <tbody>
+ <tr><td>c31</td><td>c32</td><td>c33</td></tr>
+ </tbody>
+</table>
+
diff -r 4f1383af8f10 layout/reftests/table-bordercollapse/bc_dyn_cg1_ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/table-bordercollapse/bc_dyn_cg1_ref.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,21 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
+<head><title>border collapse dynamical change colgroup border color</title>
+<style>
+td { border: 10px green solid;}
+table {margin: 30px}
+</style>
+</head>
+<body>
+<table style="border-collapse:collapse">
+<colgroup><col></colgroup>
+<colgroup style="border:solid yellow 11px"><col></colgroup>
+<colgroup><col></colgroup>
+<tbody></tbody><tr><td>c11</td><td>c12</td><td>c13</td></tr></tbody>
+ <tbody>
+ <tr><td>c21</td><td>c22</td><td>c23</td></tr>
+ </tbody>
+ <tbody>
+ <tr><td>c31</td><td>c32</td><td>c33</td></tr>
+ </tbody>
+</table>
+
diff -r 4f1383af8f10 layout/reftests/table-bordercollapse/bc_dyn_cg2.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/table-bordercollapse/bc_dyn_cg2.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,27 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
+<head><title>border collapse dynamical change colgroup border width</title>
+<script>
+function doTest(){
+ var t1 =document.getElementById('target');
+ t1.style.borderWidth="20px";
+}
+</script>
+<style>
+td { border: 10px green solid;}
+table {margin: 30px}
+</style>
+</head>
+<body onload="doTest()";>
+<table style="border-collapse:collapse">
+<colgroup><col></colgroup>
+<colgroup id="target" style="border:solid green 11px"><col></colgroup>
+<colgroup><col></colgroup>
+<tbody></tbody><tr><td>c11</td><td>c12</td><td>c13</td></tr></tbody>
+ <tbody>
+ <tr><td>c21</td><td>c22</td><td>c23</td></tr>
+ </tbody>
+ <tbody>
+ <tr><td>c31</td><td>c32</td><td>c33</td></tr>
+ </tbody>
+</table>
+
diff -r 4f1383af8f10 layout/reftests/table-bordercollapse/bc_dyn_cg2_ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/table-bordercollapse/bc_dyn_cg2_ref.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,21 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
+<head><title>border collapse dynamical change colgroup border width</title>
+<style>
+td { border: 10px green solid;}
+table {margin: 30px}
+</style>
+</head>
+<body>
+<table style="border-collapse:collapse">
+<colgroup><col></colgroup>
+<colgroup style="border:solid green 20px"><col></colgroup>
+<colgroup><col></colgroup>
+<tbody></tbody><tr><td>c11</td><td>c12</td><td>c13</td></tr></tbody>
+ <tbody>
+ <tr><td>c21</td><td>c22</td><td>c23</td></tr>
+ </tbody>
+ <tbody>
+ <tr><td>c31</td><td>c32</td><td>c33</td></tr>
+ </tbody>
+</table>
+
diff -r 4f1383af8f10 layout/reftests/table-bordercollapse/bc_dyn_cg3.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/table-bordercollapse/bc_dyn_cg3.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,27 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
+<head><title>border collapse dynamical change colgroup border style</title>
+<script>
+function doTest(){
+ var t1 =document.getElementById('target');
+ t1.style.borderStyle="solid";
+}
+</script>
+<style>
+td { border: 10px green outset;}
+table {margin: 30px}
+</style>
+</head>
+<body onload="doTest()";>
+<table style="border-collapse:collapse">
+<colgroup><col></colgroup>
+<colgroup id="target" style="border:outset green 10px"><col></colgroup>
+<colgroup><col></colgroup>
+<tbody></tbody><tr><td>c11</td><td>c12</td><td>c13</td></tr></tbody>
+ <tbody>
+ <tr><td>c21</td><td>c22</td><td>c23</td></tr>
+ </tbody>
+ <tbody>
+ <tr><td>c31</td><td>c32</td><td>c33</td></tr>
+ </tbody>
+</table>
+
diff -r 4f1383af8f10 layout/reftests/table-bordercollapse/bc_dyn_cg3_ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/table-bordercollapse/bc_dyn_cg3_ref.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,21 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
+<head><title>border collapse dynamical change colgroup border style</title>
+<style>
+td { border: 10px green outset;}
+table {margin: 30px}
+</style>
+</head>
+<body>
+<table style="border-collapse:collapse">
+<colgroup><col></colgroup>
+<colgroup style="border:solid green 10px"><col></colgroup>
+<colgroup><col></colgroup>
+<tbody></tbody><tr><td>c11</td><td>c12</td><td>c13</td></tr></tbody>
+ <tbody>
+ <tr><td>c21</td><td>c22</td><td>c23</td></tr>
+ </tbody>
+ <tbody>
+ <tr><td>c31</td><td>c32</td><td>c33</td></tr>
+ </tbody>
+</table>
+
diff -r 4f1383af8f10 layout/reftests/table-bordercollapse/bc_dyn_col1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/table-bordercollapse/bc_dyn_col1.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,27 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
+<head><title>border collapse dynamical change col border color</title>
+<script>
+function doTest(){
+ var t1 =document.getElementById('target');
+ t1.style.borderColor="yellow";
+}
+</script>
+<style>
+td { border: 10px green solid;}
+table {margin: 30px}
+</style>
+</head>
+<body onload="doTest()";>
+<table style="border-collapse:collapse">
+<colgroup><col></colgroup>
+<colgroup><col id="target" style="border:solid green 11px"></colgroup>
+<colgroup><col></colgroup>
+<tbody></tbody><tr><td>c11</td><td>c12</td><td>c13</td></tr></tbody>
+ <tbody>
+ <tr><td>c21</td><td>c22</td><td>c23</td></tr>
+ </tbody>
+ <tbody>
+ <tr><td>c31</td><td>c32</td><td>c33</td></tr>
+ </tbody>
+</table>
+
diff -r 4f1383af8f10 layout/reftests/table-bordercollapse/bc_dyn_col2.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/table-bordercollapse/bc_dyn_col2.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,27 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
+<head><title>border collapse dynamical change col border width</title>
+<script>
+function doTest(){
+ var t1 =document.getElementById('target');
+ t1.style.borderWidth="20px";
+}
+</script>
+<style>
+td { border: 10px green solid;}
+table {margin: 30px}
+</style>
+</head>
+<body onload="doTest()";>
+<table style="border-collapse:collapse">
+<colgroup><col></colgroup>
+<colgroup><col id="target" style="border:solid green 11px"></colgroup>
+<colgroup><col></colgroup>
+<tbody></tbody><tr><td>c11</td><td>c12</td><td>c13</td></tr></tbody>
+ <tbody>
+ <tr><td>c21</td><td>c22</td><td>c23</td></tr>
+ </tbody>
+ <tbody>
+ <tr><td>c31</td><td>c32</td><td>c33</td></tr>
+ </tbody>
+</table>
+
diff -r 4f1383af8f10 layout/reftests/table-bordercollapse/bc_dyn_col3.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/table-bordercollapse/bc_dyn_col3.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,27 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
+<head><title>border collapse dynamical change col border style</title>
+<script>
+function doTest(){
+ var t1 =document.getElementById('target');
+ t1.style.borderStyle="solid";
+}
+</script>
+<style>
+td { border: 10px green outset;}
+table {margin: 30px}
+</style>
+</head>
+<body onload="doTest()";>
+<table style="border-collapse:collapse">
+<colgroup><col></colgroup>
+<colgroup><col id="target" style="border:outset green 10px"></colgroup>
+<colgroup><col></colgroup>
+<tbody></tbody><tr><td>c11</td><td>c12</td><td>c13</td></tr></tbody>
+ <tbody>
+ <tr><td>c21</td><td>c22</td><td>c23</td></tr>
+ </tbody>
+ <tbody>
+ <tr><td>c31</td><td>c32</td><td>c33</td></tr>
+ </tbody>
+</table>
+
diff -r 4f1383af8f10 layout/reftests/table-bordercollapse/bc_dyn_rg1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/table-bordercollapse/bc_dyn_rg1.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,24 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
+<head><title>border collapse dynamical change rowgroup border color</title>
+<script>
+function doTest(){
+ var t1 =document.getElementById('target');
+ t1.style.borderColor="yellow";
+}
+</script>
+<style>
+td { border: 10px green solid;}
+table {margin: 30px}
+</style>
+</head>
+<body onload="doTest()";>
+<table style="border-collapse:collapse">
+<tbody></tbody><tr><td>c11</td><td>c12</td><td>c13</td></tr></tbody>
+ <tbody id="target" style="border:solid green 11px">
+ <tr><td>c21</td><td>c22</td><td>c23</td></tr>
+ </tbody>
+ <tbody>
+ <tr><td>c31</td><td>c32</td><td>c33</td></tr>
+ </tbody>
+</table>
+
diff -r 4f1383af8f10 layout/reftests/table-bordercollapse/bc_dyn_rg1_ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/table-bordercollapse/bc_dyn_rg1_ref.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,18 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
+<head><title>border collapse dynamical change rowgroup border color</title>
+<style>
+td { border: 10px green solid;}
+table {margin: 30px}
+</style>
+</head>
+<body>
+<table style="border-collapse:collapse">
+<tbody></tbody><tr><td>c11</td><td>c12</td><td>c13</td></tr></tbody>
+ <tbody style="border:solid yellow 11px">
+ <tr><td>c21</td><td>c22</td><td>c23</td></tr>
+ </tbody>
+ <tbody>
+ <tr><td>c31</td><td>c32</td><td>c33</td></tr>
+ </tbody>
+</table>
+
diff -r 4f1383af8f10 layout/reftests/table-bordercollapse/bc_dyn_rg2.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/table-bordercollapse/bc_dyn_rg2.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,24 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
+<head><title>border collapse dynamical change rowgroup border width</title>
+<script>
+function doTest(){
+ var t1 =document.getElementById('target');
+ t1.style.borderWidth="20px";
+}
+</script>
+<style>
+td { border: 10px green solid;}
+table {margin: 30px}
+</style>
+</head>
+<body onload="doTest()";>
+<table style="border-collapse:collapse">
+<tbody></tbody><tr><td>c11</td><td>c12</td><td>c13</td></tr></tbody>
+ <tbody id="target" style="border:solid green 11px">
+ <tr><td>c21</td><td>c22</td><td>c23</td></tr>
+ </tbody>
+ <tbody>
+ <tr><td>c31</td><td>c32</td><td>c33</td></tr>
+ </tbody>
+</table>
+
diff -r 4f1383af8f10 layout/reftests/table-bordercollapse/bc_dyn_rg2_ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/table-bordercollapse/bc_dyn_rg2_ref.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,19 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
+<head><title>border collapse dynamical change rowgroup border width</title>
+
+<style>
+td { border: 10px green solid;}
+table {margin: 30px}
+</style>
+</head>
+<body>
+<table style="border-collapse:collapse">
+<tbody></tbody><tr><td>c11</td><td>c12</td><td>c13</td></tr></tbody>
+ <tbody style="border:solid green 20px">
+ <tr><td>c21</td><td>c22</td><td>c23</td></tr>
+ </tbody>
+ <tbody>
+ <tr><td>c31</td><td>c32</td><td>c33</td></tr>
+ </tbody>
+</table>
+
diff -r 4f1383af8f10 layout/reftests/table-bordercollapse/bc_dyn_rg3.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/table-bordercollapse/bc_dyn_rg3.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,24 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
+<head><title>border collapse dynamical change rowgroup border style</title>
+<script>
+function doTest(){
+ var t1 =document.getElementById('target');
+ t1.style.borderStyle="solid";
+}
+</script>
+<style>
+td { border: 10px green outset;}
+table {margin: 30px}
+</style>
+</head>
+<body onload="doTest()";>
+<table style="border-collapse:collapse">
+<tbody></tbody><tr><td>c11</td><td>c12</td><td>c13</td></tr></tbody>
+ <tbody id="target" style="border:outset green 10px">
+ <tr><td>c21</td><td>c22</td><td>c23</td></tr>
+ </tbody>
+ <tbody>
+ <tr><td>c31</td><td>c32</td><td>c33</td></tr>
+ </tbody>
+</table>
+
diff -r 4f1383af8f10 layout/reftests/table-bordercollapse/bc_dyn_rg3_ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/table-bordercollapse/bc_dyn_rg3_ref.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,19 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
+<head><title>border collapse dynamical change rowgroup border style</title>
+
+<style>
+td { border: 10px green outset;}
+table {margin: 30px}
+</style>
+</head>
+<body>
+<table style="border-collapse:collapse">
+<tbody></tbody><tr><td>c11</td><td>c12</td><td>c13</td></tr></tbody>
+ <tbody style="border:solid green 10px">
+ <tr><td>c21</td><td>c22</td><td>c23</td></tr>
+ </tbody>
+ <tbody>
+ <tr><td>c31</td><td>c32</td><td>c33</td></tr>
+ </tbody>
+</table>
+
diff -r 4f1383af8f10 layout/reftests/table-bordercollapse/bc_dyn_row1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/table-bordercollapse/bc_dyn_row1.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,20 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
+<head><title>border collapse dynamical change row border color</title>
+<script>
+function doTest(){
+ var t1 =document.getElementById('target');
+ t1.style.borderColor="yellow";
+}
+</script>
+<style>
+td { border: 10px green solid;}
+table {margin: 30px}
+</style>
+</head>
+<body onload="doTest()";>
+<table style="border-collapse:collapse">
+ <tr><td>c11</td><td>c12</td><td>c13</td></tr>
+ <tr id="target" style="border:solid green 11px"><td>c21</td><td>c22</td><td>c23</td></tr>
+ <tr><td>c31</td><td>c32</td><td>c33</td></tr>
+</table>
+
diff -r 4f1383af8f10 layout/reftests/table-bordercollapse/bc_dyn_row2.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/table-bordercollapse/bc_dyn_row2.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,20 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
+<head><title>border collapse dynamical change row border width</title>
+<script>
+function doTest(){
+ var t1 =document.getElementById('target');
+ t1.style.borderWidth="20px";
+}
+</script>
+<style>
+td { border: 10px green solid;}
+table {margin: 30px}
+</style>
+</head>
+<body onload="doTest()";>
+<table style="border-collapse:collapse">
+ <tr><td>c11</td><td>c12</td><td>c13</td></tr>
+ <tr id="target" style="border:solid green 2px"><td>c21</td><td>c22</td><td>c23</td></tr>
+ <tr><td>c31</td><td>c32</td><td>c33</td></tr>
+</table>
+
diff -r 4f1383af8f10 layout/reftests/table-bordercollapse/bc_dyn_row3.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/table-bordercollapse/bc_dyn_row3.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,20 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
+<head><title>border collapse dynamical change row border style</title>
+<script>
+function doTest(){
+ var t1 =document.getElementById('target');
+ t1.style.borderStyle="solid";
+}
+</script>
+<style>
+td { border: 10px green outset;}
+table {margin: 30px}
+</style>
+</head>
+<body onload="doTest()";>
+<table style="border-collapse:collapse">
+ <tr><td>c11</td><td>c12</td><td>c13</td></tr>
+ <tr id="target" style="border:outset green 10px"><td>c21</td><td>c22</td><td>c23</td></tr>
+ <tr><td>c31</td><td>c32</td><td>c33</td></tr>
+</table>
+
diff -r 4f1383af8f10 layout/reftests/table-bordercollapse/bc_dyn_table1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/table-bordercollapse/bc_dyn_table1.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,27 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
+<head><title>border collapse dynamical change table border color</title>
+<script>
+function doTest(){
+ var t1 =document.getElementById('target');
+ t1.style.borderColor="yellow";
+}
+</script>
+<style>
+td { border: 10px green solid;}
+table {margin: 30px}
+</style>
+</head>
+<body onload="doTest()";>
+<table style="border-collapse:collapse; border:solid green 11px" id="target">
+<colgroup><col></colgroup>
+<colgroup><col></colgroup>
+<colgroup><col></colgroup>
+<tbody></tbody><tr><td>c11</td><td>c12</td><td>c13</td></tr></tbody>
+ <tbody>
+ <tr><td>c21</td><td>c22</td><td>c23</td></tr>
+ </tbody>
+ <tbody>
+ <tr><td>c31</td><td>c32</td><td>c33</td></tr>
+ </tbody>
+</table>
+
diff -r 4f1383af8f10 layout/reftests/table-bordercollapse/bc_dyn_table1_ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/table-bordercollapse/bc_dyn_table1_ref.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,22 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
+<head><title>border collapse dynamical change table border color</title>
+
+<style>
+td { border: 10px green solid;}
+table {margin: 30px}
+</style>
+</head>
+<body>
+<table style="border-collapse:collapse; border:solid yellow 11px">
+<colgroup><col></colgroup>
+<colgroup><col></colgroup>
+<colgroup><col></colgroup>
+<tbody></tbody><tr><td>c11</td><td>c12</td><td>c13</td></tr></tbody>
+ <tbody>
+ <tr><td>c21</td><td>c22</td><td>c23</td></tr>
+ </tbody>
+ <tbody>
+ <tr><td>c31</td><td>c32</td><td>c33</td></tr>
+ </tbody>
+</table>
+
diff -r 4f1383af8f10 layout/reftests/table-bordercollapse/bc_dyn_table2.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/table-bordercollapse/bc_dyn_table2.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,27 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
+<head><title>border collapse dynamical change table border width</title>
+<script>
+function doTest(){
+ var t1 =document.getElementById('target');
+ t1.style.borderWidth="20px";
+}
+</script>
+<style>
+td { border: 10px green solid;}
+table {margin: 30px}
+</style>
+</head>
+<body onload="doTest()";>
+<table style="border-collapse:collapse; border:solid green 11px" id="target">
+<colgroup><col></colgroup>
+<colgroup><col></colgroup>
+<colgroup><col></colgroup>
+<tbody></tbody><tr><td>c11</td><td>c12</td><td>c13</td></tr></tbody>
+ <tbody>
+ <tr><td>c21</td><td>c22</td><td>c23</td></tr>
+ </tbody>
+ <tbody>
+ <tr><td>c31</td><td>c32</td><td>c33</td></tr>
+ </tbody>
+</table>
+
diff -r 4f1383af8f10 layout/reftests/table-bordercollapse/bc_dyn_table2_ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/table-bordercollapse/bc_dyn_table2_ref.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,21 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
+<head><title>border collapse dynamical change table border width</title>
+<style>
+td { border: 10px green solid;}
+table {margin: 30px}
+</style>
+</head>
+<body>
+<table style="border-collapse:collapse; border:solid green 20px">
+<colgroup><col></colgroup>
+<colgroup><col></colgroup>
+<colgroup><col></colgroup>
+<tbody></tbody><tr><td>c11</td><td>c12</td><td>c13</td></tr></tbody>
+ <tbody>
+ <tr><td>c21</td><td>c22</td><td>c23</td></tr>
+ </tbody>
+ <tbody>
+ <tr><td>c31</td><td>c32</td><td>c33</td></tr>
+ </tbody>
+</table>
+
diff -r 4f1383af8f10 layout/reftests/table-bordercollapse/bc_dyn_table3.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/table-bordercollapse/bc_dyn_table3.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,27 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
+<head><title>border collapse dynamical change table border style</title>
+<script>
+function doTest(){
+ var t1 =document.getElementById('target');
+ t1.style.borderStyle="solid";
+}
+</script>
+<style>
+td { border: 10px green outset;}
+table {margin: 30px}
+</style>
+</head>
+<body onload="doTest()";>
+<table style="border-collapse:collapse; border:none green 10px" id="target">
+<colgroup><col></colgroup>
+<colgroup><col></colgroup>
+<colgroup><col></colgroup>
+<tbody></tbody><tr><td>c11</td><td>c12</td><td>c13</td></tr></tbody>
+ <tbody>
+ <tr><td>c21</td><td>c22</td><td>c23</td></tr>
+ </tbody>
+ <tbody>
+ <tr><td>c31</td><td>c32</td><td>c33</td></tr>
+ </tbody>
+</table>
+
diff -r 4f1383af8f10 layout/reftests/table-bordercollapse/bc_dyn_table3_ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/table-bordercollapse/bc_dyn_table3_ref.html	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,22 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
+<head><title>border collapse dynamical change table border style</title>
+
+<style>
+td { border: 10px green outset;}
+table {margin: 30px}
+</style>
+</head>
+<body>
+<table style="border-collapse:collapse; border:solid green 10px">
+<colgroup><col></colgroup>
+<colgroup><col></colgroup>
+<colgroup><col></colgroup>
+<tbody></tbody><tr><td>c11</td><td>c12</td><td>c13</td></tr></tbody>
+ <tbody>
+ <tr><td>c21</td><td>c22</td><td>c23</td></tr>
+ </tbody>
+ <tbody>
+ <tr><td>c31</td><td>c32</td><td>c33</td></tr>
+ </tbody>
+</table>
+
diff -r 4f1383af8f10 layout/reftests/table-bordercollapse/reftest.list
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/table-bordercollapse/reftest.list	Mon Nov 03 05:09:09 2008 -0500
@@ -0,0 +1,20 @@
+== bc_dyn_cell1.html bc_dyn_cell1_ref.html
+== bc_dyn_cell2.html bc_dyn_cell2_ref.html
+== bc_dyn_cell3.html bc_dyn_cell3_ref.html
+== bc_dyn_cell4.html bc_dyn_cell4_ref.html
+== bc_dyn_cell5.html bc_dyn_cell5_ref.html
+== bc_dyn_row1.html bc_dyn_rg1_ref.html
+== bc_dyn_row2.html bc_dyn_rg2_ref.html
+== bc_dyn_row3.html bc_dyn_rg3_ref.html
+== bc_dyn_rg1.html bc_dyn_rg1_ref.html
+== bc_dyn_rg2.html bc_dyn_rg2_ref.html
+== bc_dyn_rg3.html bc_dyn_rg3_ref.html
+== bc_dyn_col1.html bc_dyn_cg1_ref.html
+== bc_dyn_col2.html bc_dyn_cg2_ref.html
+== bc_dyn_col3.html bc_dyn_cg3_ref.html
+== bc_dyn_cg1.html bc_dyn_cg1_ref.html
+== bc_dyn_cg2.html bc_dyn_cg2_ref.html
+== bc_dyn_cg3.html bc_dyn_cg3_ref.html
+== bc_dyn_table1.html bc_dyn_table1_ref.html
+== bc_dyn_table2.html bc_dyn_table2_ref.html
+== bc_dyn_table3.html bc_dyn_table3_ref.html
diff -r 4f1383af8f10 layout/style/forms.css
--- a/layout/style/forms.css	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/style/forms.css	Mon Nov 03 05:09:09 2008 -0500
@@ -391,30 +391,30 @@ input[type="file"] > input[type="button"
 input[type="file"] > input[type="button"] {
   height: inherit;
   font-size: inherit;
   letter-spacing: inherit;
 }
 
 /* radio buttons */
 input[type="radio"] {
-  -moz-appearance: radio-small;
+  -moz-appearance: radio;
   width: 13px;
   height: 13px;
   margin: 3px 3px 0px 5px;
   padding: 0 !important;
   cursor: default;
   -moz-binding: none;
 
   -moz-border-radius: 100% !important;
 }
 
 /* check boxes */
 input[type="checkbox"] {
-  -moz-appearance: checkbox-small;
+  -moz-appearance: checkbox;
   width: 13px;
   height: 13px;
   margin: 3px 3px 3px 4px;
   padding: 0 !important;
   cursor: default;
   -moz-binding: none;
 
   -moz-border-radius: 0 !important;
diff -r 4f1383af8f10 layout/style/nsCSSKeywordList.h
--- a/layout/style/nsCSSKeywordList.h	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/style/nsCSSKeywordList.h	Mon Nov 03 05:09:09 2008 -0500
@@ -489,18 +489,16 @@ CSS_KEY(x-small, x_small)
 CSS_KEY(x-small, x_small)
 CSS_KEY(x-soft, x_soft)
 CSS_KEY(xx-large, xx_large)
 CSS_KEY(xx-small, xx_small)
 
 // Appearance keywords for widget styles
 CSS_KEY(radio, radio)
 CSS_KEY(checkbox, checkbox)
-CSS_KEY(radio-small, radio_small)
-CSS_KEY(checkbox-small, checkbox_small)
 CSS_KEY(button-bevel, button_bevel)
 CSS_KEY(toolbox, toolbox)
 CSS_KEY(toolbar, toolbar)
 CSS_KEY(toolbarbutton, toolbarbutton)
 CSS_KEY(toolbargripper, toolbargripper)
 CSS_KEY(dualbutton, dualbutton)
 CSS_KEY(toolbarbutton-dropdown, toolbarbutton_dropdown)
 CSS_KEY(separator, separator)
diff -r 4f1383af8f10 layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/style/nsCSSParser.cpp	Mon Nov 03 05:09:09 2008 -0500
@@ -268,16 +268,17 @@ protected:
     NS_PRECONDITION(!mParsingCompoundProperty, "Bad initial state");
   }
 
   PRBool ExpectSymbol(PRUnichar aSymbol, PRBool aSkipWS);
   PRBool ExpectEndProperty();
   PRBool CheckEndProperty();
   nsSubstring* NextIdent();
   void SkipUntil(PRUnichar aStopSymbol);
+  void SkipUntilOneOf(const PRUnichar* aStopSymbolChars);
   void SkipRuleSet();
   PRBool SkipAtRule();
   PRBool SkipDeclaration(PRBool aCheckForBraces);
   PRBool GetNonCloseParenToken(PRBool aSkipWS);
 
   PRBool PushGroup(nsICSSGroupRule* aRule);
   void PopGroup(void);
 
@@ -1586,20 +1587,28 @@ CSSParserImpl::GatherMedia(nsMediaList* 
 CSSParserImpl::GatherMedia(nsMediaList* aMedia,
                            PRUnichar aStopSymbol)
 {
   for (;;) {
     nsAutoPtr<nsMediaQuery> query;
     PRBool parsedSomething, hitStop;
     if (!ParseMediaQuery(aStopSymbol, getter_Transfers(query),
                          &parsedSomething, &hitStop)) {
+      NS_ASSERTION(!hitStop, "should return true when hit stop");
       if (NS_FAILED(mScanner.GetLowLevelError())) {
         return PR_FALSE;
       }
-      SkipUntil(',');
+      const PRUnichar stopChars[] =
+        { PRUnichar(','), aStopSymbol /* may be null */, PRUnichar(0) };
+      SkipUntilOneOf(stopChars);
+      // Rely on SkipUntilOneOf leaving mToken around as the last token read.
+      if (mToken.mType == eCSSToken_Symbol && mToken.mSymbol == aStopSymbol) {
+        UngetToken();
+        hitStop = PR_TRUE;
+      }
     }
     if (parsedSomething) {
       aMedia->SetNonEmpty();
     }
     if (query) {
       nsresult rv = aMedia->AppendQuery(query);
       if (NS_FAILED(rv)) {
         mScanner.SetLowLevelError(rv);
@@ -2140,16 +2149,40 @@ CSSParserImpl::SkipUntil(PRUnichar aStop
   nsCSSToken* tk = &mToken;
   for (;;) {
     if (!GetToken(PR_TRUE)) {
       break;
     }
     if (eCSSToken_Symbol == tk->mType) {
       PRUnichar symbol = tk->mSymbol;
       if (symbol == aStopSymbol) {
+        break;
+      } else if ('{' == symbol) {
+        SkipUntil('}');
+      } else if ('[' == symbol) {
+        SkipUntil(']');
+      } else if ('(' == symbol) {
+        SkipUntil(')');
+      }
+    }
+  }
+}
+
+void
+CSSParserImpl::SkipUntilOneOf(const PRUnichar* aStopSymbolChars)
+{
+  nsCSSToken* tk = &mToken;
+  nsDependentString stopSymbolChars(aStopSymbolChars);
+  for (;;) {
+    if (!GetToken(PR_TRUE)) {
+      break;
+    }
+    if (eCSSToken_Symbol == tk->mType) {
+      PRUnichar symbol = tk->mSymbol;
+      if (stopSymbolChars.FindChar(symbol) != -1) {
         break;
       } else if ('{' == symbol) {
         SkipUntil('}');
       } else if ('[' == symbol) {
         SkipUntil(']');
       } else if ('(' == symbol) {
         SkipUntil(')');
       }
diff -r 4f1383af8f10 layout/style/nsCSSProps.cpp
--- a/layout/style/nsCSSProps.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/style/nsCSSProps.cpp	Mon Nov 03 05:09:09 2008 -0500
@@ -234,18 +234,16 @@ nsCSSProps::GetStringValue(nsCSSFontDesc
 
 /***************************************************************************/
 
 const PRInt32 nsCSSProps::kAppearanceKTable[] = {
   eCSSKeyword_none,                   NS_THEME_NONE,
   eCSSKeyword_button,                 NS_THEME_BUTTON,
   eCSSKeyword_radio,                  NS_THEME_RADIO,
   eCSSKeyword_checkbox,               NS_THEME_CHECKBOX,
-  eCSSKeyword_radio_small,            NS_THEME_RADIO_SMALL,
-  eCSSKeyword_checkbox_small,         NS_THEME_CHECKBOX_SMALL,
   eCSSKeyword_button_bevel,           NS_THEME_BUTTON_BEVEL,
   eCSSKeyword_toolbox,                NS_THEME_TOOLBOX,
   eCSSKeyword_toolbar,                NS_THEME_TOOLBAR,
   eCSSKeyword_toolbarbutton,          NS_THEME_TOOLBAR_BUTTON,
   eCSSKeyword_toolbargripper,         NS_THEME_TOOLBAR_GRIPPER,
   eCSSKeyword_dualbutton,             NS_THEME_TOOLBAR_DUAL_BUTTON,
   eCSSKeyword_toolbarbutton_dropdown, NS_THEME_TOOLBAR_BUTTON_DROPDOWN,
   eCSSKeyword_separator,              NS_THEME_TOOLBAR_SEPARATOR,
diff -r 4f1383af8f10 layout/style/nsCSSStyleSheet.cpp
--- a/layout/style/nsCSSStyleSheet.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/style/nsCSSStyleSheet.cpp	Mon Nov 03 05:09:09 2008 -0500
@@ -1272,56 +1272,16 @@ nsCSSStyleSheet::SetOwnerRule(nsICSSImpo
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCSSStyleSheet::GetOwnerRule(nsICSSImportRule** aOwnerRule)
 {
   *aOwnerRule = mOwnerRule;
   NS_IF_ADDREF(*aOwnerRule);
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCSSStyleSheet::ContainsStyleSheet(nsIURI* aURL, PRBool& aContains, nsIStyleSheet** aTheChild /*=nsnull*/)
-{
-  NS_PRECONDITION(nsnull != aURL, "null arg");
-
-  if (!mInner->mSheetURI) {
-    // We're not yet far enough along in our load to know what our URL is (we
-    // may still get redirected and such).  Assert (caller should really not be
-    // calling this on us at this stage) and return.
-    NS_ERROR("ContainsStyleSheet called on a sheet that's still loading");
-    aContains = PR_FALSE;
-    return NS_OK;
-  }
-  
-  // first check ourself out
-  nsresult rv = mInner->mSheetURI->Equals(aURL, &aContains);
-  if (NS_FAILED(rv)) aContains = PR_FALSE;
-
-  if (aContains) {
-    // if we found it and the out-param is there, set it and addref
-    if (aTheChild) {
-      rv = CallQueryInterface(this, aTheChild);
-    }
-  } else {
-    // now check the chil'ins out (recursively)
-    for (nsCSSStyleSheet* child = mInner->mFirstChild;
-         child;
-         child = child->mNext) {
-      child->ContainsStyleSheet(aURL, aContains, aTheChild);
-      if (aContains) {
-        break;
-      }
-    }
-  }
-
-  // NOTE: if there are errors in the above we are handling them locally 
-  //       and not promoting them to the caller
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCSSStyleSheet::AppendStyleSheet(nsICSSStyleSheet* aSheet)
 {
   NS_PRECONDITION(nsnull != aSheet, "null arg");
 
diff -r 4f1383af8f10 layout/style/nsCSSStyleSheet.h
--- a/layout/style/nsCSSStyleSheet.h	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/style/nsCSSStyleSheet.h	Mon Nov 03 05:09:09 2008 -0500
@@ -128,18 +128,16 @@ public:
   NS_IMETHOD GetParentSheet(nsIStyleSheet*& aParent) const;  // may be null
   NS_IMETHOD GetOwningDocument(nsIDocument*& aDocument) const;  // may be null
   NS_IMETHOD SetOwningDocument(nsIDocument* aDocument);
 #ifdef DEBUG
   virtual void List(FILE* out = stdout, PRInt32 aIndent = 0) const;
 #endif
   
   // nsICSSStyleSheet interface
-  NS_IMETHOD ContainsStyleSheet(nsIURI* aURL, PRBool& aContains,
-                                nsIStyleSheet** aTheChild=nsnull);
   NS_IMETHOD AppendStyleSheet(nsICSSStyleSheet* aSheet);
   NS_IMETHOD InsertStyleSheetAt(nsICSSStyleSheet* aSheet, PRInt32 aIndex);
   NS_IMETHOD PrependStyleRule(nsICSSRule* aRule);
   NS_IMETHOD AppendStyleRule(nsICSSRule* aRule);
   NS_IMETHOD ReplaceStyleRule(nsICSSRule* aOld, nsICSSRule* aNew);
   NS_IMETHOD StyleRuleCount(PRInt32& aCount) const;
   NS_IMETHOD GetStyleRuleAt(PRInt32 aIndex, nsICSSRule*& aRule) const;
   NS_IMETHOD DeleteRuleFromGroup(nsICSSGroupRule* aGroup, PRUint32 aIndex);
diff -r 4f1383af8f10 layout/style/nsICSSStyleSheet.h
--- a/layout/style/nsICSSStyleSheet.h	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/style/nsICSSStyleSheet.h	Mon Nov 03 05:09:09 2008 -0500
@@ -48,26 +48,24 @@ class nsXMLNameSpaceMap;
 class nsXMLNameSpaceMap;
 class nsCSSRuleProcessor;
 class nsMediaList;
 class nsICSSGroupRule;
 class nsICSSImportRule;
 class nsIPrincipal;
 
 // IID for the nsICSSStyleSheet interface
-// 363c1c5f-81ec-4d83-ad8a-b48d48f1398d
+// ee0270c7-5581-4165-92a5-a83ff691f60d
 #define NS_ICSS_STYLE_SHEET_IID     \
-{ 0x363c1c5f, 0x81ec, 0x4d83, \
- { 0xad, 0x8a, 0xb4, 0x8d, 0x48, 0xf1, 0x39, 0x8d } }
+{ 0xee0270c7, 0x5581, 0x4165, \
+ { 0x92, 0xa5, 0xa8, 0x3f, 0xf6, 0x91, 0xf6, 0x0d } }
 
 class nsICSSStyleSheet : public nsIStyleSheet {
 public:
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_ICSS_STYLE_SHEET_IID)
-
-  NS_IMETHOD  ContainsStyleSheet(nsIURI* aURL, PRBool& aContains, nsIStyleSheet** aTheChild=nsnull) = 0;
 
   NS_IMETHOD  AppendStyleSheet(nsICSSStyleSheet* aSheet) = 0;
   NS_IMETHOD  InsertStyleSheetAt(nsICSSStyleSheet* aSheet, PRInt32 aIndex) = 0;
 
   // XXX do these belong here or are they generic?
   NS_IMETHOD  PrependStyleRule(nsICSSRule* aRule) = 0;
   NS_IMETHOD  AppendStyleRule(nsICSSRule* aRule) = 0;
   NS_IMETHOD  ReplaceStyleRule(nsICSSRule* aOld, nsICSSRule* aNew) = 0;
diff -r 4f1383af8f10 layout/style/nsLayoutStylesheetCache.cpp
--- a/layout/style/nsLayoutStylesheetCache.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/style/nsLayoutStylesheetCache.cpp	Mon Nov 03 05:09:09 2008 -0500
@@ -128,16 +128,36 @@ nsLayoutStylesheetCache::UserChromeSheet
 {
   EnsureGlobal();
   if (!gStyleCache)
     return nsnull;
 
   return gStyleCache->mUserChromeSheet;
 }
 
+nsICSSStyleSheet*
+nsLayoutStylesheetCache::UASheet()
+{
+  EnsureGlobal();
+  if (!gStyleCache)
+    return nsnull;
+
+  return gStyleCache->mUASheet;
+}
+
+nsICSSStyleSheet*
+nsLayoutStylesheetCache::QuirkSheet()
+{
+  EnsureGlobal();
+  if (!gStyleCache)
+    return nsnull;
+
+  return gStyleCache->mQuirkSheet;
+}
+
 void
 nsLayoutStylesheetCache::Shutdown()
 {
   NS_IF_RELEASE(gCSSLoader);
   NS_IF_RELEASE(gStyleCache);
 }
 
 nsLayoutStylesheetCache::nsLayoutStylesheetCache()
@@ -149,16 +169,31 @@ nsLayoutStylesheetCache::nsLayoutStylesh
   if (obsSvc) {
     obsSvc->AddObserver(this, "profile-before-change", PR_FALSE);
     obsSvc->AddObserver(this, "profile-do-change", PR_FALSE);
     obsSvc->AddObserver(this, "chrome-flush-skin-caches", PR_FALSE);
     obsSvc->AddObserver(this, "chrome-flush-caches", PR_FALSE);
   }
 
   InitFromProfile();
+
+  // And make sure that we load our UA sheets.  No need to do this
+  // per-profile, since they're profile-invariant.
+  nsCOMPtr<nsIURI> uri;
+  NS_NewURI(getter_AddRefs(uri), "resource://gre/res/ua.css");
+  if (uri) {
+    LoadSheet(uri, mUASheet, PR_TRUE);
+  }
+  NS_ASSERTION(mUASheet, "Could not load ua.css");
+
+  NS_NewURI(getter_AddRefs(uri), "resource://gre/res/quirk.css");
+  if (uri) {
+    LoadSheet(uri, mQuirkSheet, PR_TRUE);
+  }
+  NS_ASSERTION(mQuirkSheet, "Could not load quirk.css");
 }
 
 nsLayoutStylesheetCache::~nsLayoutStylesheetCache()
 {
   gCSSLoader = nsnull;
   gStyleCache = nsnull;
 }
 
diff -r 4f1383af8f10 layout/style/nsLayoutStylesheetCache.h
--- a/layout/style/nsLayoutStylesheetCache.h	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/style/nsLayoutStylesheetCache.h	Mon Nov 03 05:09:09 2008 -0500
@@ -50,16 +50,18 @@ class nsLayoutStylesheetCache
 {
   NS_DECL_ISUPPORTS
   NS_DECL_NSIOBSERVER
 
   static nsICSSStyleSheet* ScrollbarsSheet();
   static nsICSSStyleSheet* FormsSheet();
   static nsICSSStyleSheet* UserContentSheet();
   static nsICSSStyleSheet* UserChromeSheet();
+  static nsICSSStyleSheet* UASheet();
+  static nsICSSStyleSheet* QuirkSheet();
 
   static void Shutdown();
 
 private:
   nsLayoutStylesheetCache();
   ~nsLayoutStylesheetCache();
 
   static void EnsureGlobal();
@@ -69,11 +71,13 @@ private:
                         PRBool aEnableUnsafeRules);
 
   static nsLayoutStylesheetCache* gStyleCache;
   static nsICSSLoader* gCSSLoader;
   nsCOMPtr<nsICSSStyleSheet> mScrollbarsSheet;
   nsCOMPtr<nsICSSStyleSheet> mFormsSheet;
   nsCOMPtr<nsICSSStyleSheet> mUserContentSheet;
   nsCOMPtr<nsICSSStyleSheet> mUserChromeSheet;
+  nsCOMPtr<nsICSSStyleSheet> mUASheet;
+  nsCOMPtr<nsICSSStyleSheet> mQuirkSheet;
 };
 
 #endif
diff -r 4f1383af8f10 layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/style/nsStyleSet.cpp	Mon Nov 03 05:09:09 2008 -0500
@@ -53,39 +53,31 @@
 #include "nsICSSStyleRule.h"
 #include "nsCSSAnonBoxes.h"
 #include "nsCSSPseudoElements.h"
 #include "nsCSSRuleProcessor.h"
 #include "nsIContent.h"
 #include "nsIFrame.h"
 #include "nsContentUtils.h"
 
-nsIURI *nsStyleSet::gQuirkURI = 0;
-
 nsStyleSet::nsStyleSet()
   : mRuleTree(nsnull),
     mRuleWalker(nsnull),
     mDestroyedCount(0),
     mBatching(0),
     mOldRuleTree(nsnull),
     mInShutdown(PR_FALSE),
     mAuthorStyleDisabled(PR_FALSE),
     mDirty(0)
 {
 }
 
 nsresult
 nsStyleSet::Init(nsPresContext *aPresContext)
 {
-  if (!gQuirkURI) {
-    static const char kQuirk_href[] = "resource://gre/res/quirk.css";
-    NS_NewURI(&gQuirkURI, kQuirk_href);
-    NS_ENSURE_TRUE(gQuirkURI, NS_ERROR_OUT_OF_MEMORY);
-  }
-
   if (!BuildDefaultStyleData(aPresContext)) {
     mDefaultStyleData.Destroy(0, aPresContext);
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
   mRuleTree = nsRuleNode::CreateRootNode(aPresContext);
   if (!mRuleTree) {
     mDefaultStyleData.Destroy(0, aPresContext);
@@ -137,16 +129,26 @@ nsStyleSet::EndReconstruct()
 {
   NS_ASSERTION(mOldRuleTree, "Unmatched begin/end?");
   // Reset the destroyed count; it's no longer valid
   mDestroyedCount = 0;
   // Destroy the old rule tree (all the associated style contexts should have
   // been destroyed by the caller beforehand)
   mOldRuleTree->Destroy();
   mOldRuleTree = nsnull;
+}
+
+void
+nsStyleSet::SetQuirkStyleSheet(nsIStyleSheet* aQuirkStyleSheet)
+{
+  NS_ASSERTION(aQuirkStyleSheet, "Must have quirk sheet if this is called");
+  NS_ASSERTION(!mQuirkStyleSheet, "Multiple calls to SetQuirkStyleSheet?");
+  NS_ASSERTION(mSheets[eAgentSheet].IndexOf(aQuirkStyleSheet) != -1,
+               "Quirk style sheet not one of our agent sheets?");
+  mQuirkStyleSheet = aQuirkStyleSheet;
 }
 
 nsresult
 nsStyleSet::GatherRuleProcessors(sheetType aType)
 {
   mRuleProcessors[aType] = nsnull;
   if (mAuthorStyleDisabled && (aType == eDocSheet || 
                                aType == ePresHintSheet ||
@@ -336,60 +338,31 @@ nsStyleSet::EndUpdate()
 
   mDirty = 0;
   return NS_OK;
 }
 
 void
 nsStyleSet::EnableQuirkStyleSheet(PRBool aEnable)
 {
-  if (!mQuirkStyleSheet) {
-    // first find the quirk sheet:
-    // - run through all of the agent sheets and check for a CSSStyleSheet that
-    //   has the URL we want
-    PRInt32 nSheets = mSheets[eAgentSheet].Count();
-    for (PRInt32 i = 0; i < nSheets; ++i) {
-      nsIStyleSheet *sheet = mSheets[eAgentSheet].ObjectAt(i);
-      NS_ASSERTION(sheet, "mAgentSheets should not contain null sheets");
-
-      nsICSSStyleSheet *cssSheet = static_cast<nsICSSStyleSheet*>(sheet);
-      NS_ASSERTION(nsCOMPtr<nsICSSStyleSheet>(do_QueryInterface(sheet)) == cssSheet,
-                   "Agent sheet must be a CSSStyleSheet");
-
-      nsCOMPtr<nsIStyleSheet> quirkSheet;
-      PRBool bHasSheet = PR_FALSE;
-      if (NS_SUCCEEDED(cssSheet->ContainsStyleSheet(gQuirkURI, bHasSheet, 
-                                                    getter_AddRefs(quirkSheet))) 
-          && bHasSheet) {
-        NS_ASSERTION(quirkSheet, "QuirkSheet must be set: ContainsStyleSheet is hosed");
-        // cache the sheet for faster lookup next time
-        mQuirkStyleSheet = quirkSheet;
-        // only one quirk style sheet can exist, so stop looking
-        break;
-      }
-    }
+#ifdef DEBUG
+  if (mRuleProcessors[eAgentSheet]) {
+    static_cast<nsCSSRuleProcessor*>(static_cast<nsIStyleRuleProcessor*>(
+      mRuleProcessors[eAgentSheet]))->AssertQuirksChangeOK();
   }
-  NS_ASSERTION(mQuirkStyleSheet, "no quirk stylesheet");
-  if (mQuirkStyleSheet) {
-#ifdef DEBUG
-    if (mRuleProcessors[eAgentSheet]) {
-      static_cast<nsCSSRuleProcessor*>(static_cast<nsIStyleRuleProcessor*>(
-        mRuleProcessors[eAgentSheet]))->AssertQuirksChangeOK();
-    }
 #endif
 #ifdef DEBUG_dbaron_off // XXX Make this |DEBUG| once it stops firing.
-    PRBool applicableNow;
-    mQuirkStyleSheet->GetApplicable(applicableNow);
-    NS_ASSERTION(!mRuleProcessors[eAgentSheet] || aEnable == applicableNow,
-                 "enabling/disabling quirk stylesheet too late or incomplete quirk stylesheet");
-    if (mRuleProcessors[eAgentSheet] && aEnable == applicableNow)
-      printf("WARNING: We set the quirks mode too many times.\n"); // we do!
+  PRBool applicableNow;
+  mQuirkStyleSheet->GetApplicable(applicableNow);
+  NS_ASSERTION(!mRuleProcessors[eAgentSheet] || aEnable == applicableNow,
+               "enabling/disabling quirk stylesheet too late or incomplete quirk stylesheet");
+  if (mRuleProcessors[eAgentSheet] && aEnable == applicableNow)
+    printf("WARNING: We set the quirks mode too many times.\n"); // we do!
 #endif
-    mQuirkStyleSheet->SetEnabled(aEnable);
-  }
+  mQuirkStyleSheet->SetEnabled(aEnable);
 }
 
 static PRBool
 EnumRulesMatching(nsIStyleRuleProcessor* aProcessor, void* aData)
 {
   ElementRuleProcessorData* data =
     static_cast<ElementRuleProcessorData*>(aData);
 
diff -r 4f1383af8f10 layout/style/nsStyleSet.h
--- a/layout/style/nsStyleSet.h	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/style/nsStyleSet.h	Mon Nov 03 05:09:09 2008 -0500
@@ -153,19 +153,16 @@ class nsStyleSet
 
   // APIs for registering objects that can supply additional
   // rules during processing.
   void SetBindingManager(nsBindingManager* aBindingManager)
   {
     mBindingManager = aBindingManager;
   }
 
-  // Free global data at module shutdown
-  static void FreeGlobals() { NS_IF_RELEASE(gQuirkURI); }
-
   // The "origins" of the CSS cascade, from lowest precedence to
   // highest (for non-!important rules).
   enum sheetType {
     eAgentSheet, // CSS
     ePresHintSheet,
     eUserSheet, // CSS
     eHTMLPresHintSheet,
     eDocSheet, // CSS
@@ -204,16 +201,21 @@ class nsStyleSet
 
   // Methods for reconstructing the tree; BeginReconstruct basically moves the
   // old rule tree root and style context roots out of the way,
   // and EndReconstruct destroys the old rule tree when we're done
   nsresult BeginReconstruct();
   // Note: EndReconstruct should not be called if BeginReconstruct fails
   void EndReconstruct();
 
+  // Let the style set know that a particular sheet is the quirks sheet.  This
+  // sheet must already have been added to the UA sheets.  The pointer must not
+  // be null.  This should only be called once for a given style set.
+  void SetQuirkStyleSheet(nsIStyleSheet* aQuirkStyleSheet);
+  
  private:
   // Not to be implemented
   nsStyleSet(const nsStyleSet& aCopy);
   nsStyleSet& operator=(const nsStyleSet& aCopy);
 
   // Returns false on out-of-memory.
   PRBool BuildDefaultStyleData(nsPresContext* aPresContext);
 
@@ -248,18 +250,16 @@ class nsStyleSet
                           RuleProcessorData* aData);
 
   already_AddRefed<nsStyleContext> GetContext(nsPresContext* aPresContext,
                                               nsStyleContext* aParentContext,
                                               nsIAtom* aPseudoTag);
 
   nsPresContext* PresContext() { return mRuleTree->GetPresContext(); }
 
-  static nsIURI  *gQuirkURI;
-
   // The sheets in each array in mSheets are stored with the most significant
   // sheet last.
   nsCOMArray<nsIStyleSheet> mSheets[eSheetTypeCount];
 
   nsCOMPtr<nsIStyleRuleProcessor> mRuleProcessors[eSheetTypeCount];
 
   // cached instance for enabling/disabling
   nsCOMPtr<nsIStyleSheet> mQuirkStyleSheet;
diff -r 4f1383af8f10 layout/style/nsStyleStruct.cpp
--- a/layout/style/nsStyleStruct.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/style/nsStyleStruct.cpp	Mon Nov 03 05:09:09 2008 -0500
@@ -447,64 +447,63 @@ nsStyleBorder::Destroy(nsPresContext* aC
 nsStyleBorder::Destroy(nsPresContext* aContext) {
   this->~nsStyleBorder();
   aContext->FreeToShell(sizeof(nsStyleBorder), this);
 }
 
 
 nsChangeHint nsStyleBorder::CalcDifference(const nsStyleBorder& aOther) const
 {
+  nsChangeHint shadowDifference =
+    CalcShadowDifference(mBoxShadow, aOther.mBoxShadow);
+
   // Note that differences in mBorder don't affect rendering (which should only
   // use mComputedBorder), so don't need to be tested for here.
-  if (mTwipsPerPixel == aOther.mTwipsPerPixel &&
-      GetActualBorder() == aOther.GetActualBorder() && 
-      mFloatEdge == aOther.mFloatEdge) {
-    // Note that mBorderStyle stores not only the border style but also
-    // color-related flags.  Given that we've already done an mComputedBorder
-    // comparison, border-style differences can only lead to a VISUAL hint.  So
-    // it's OK to just compare the values directly -- if either the actual
-    // style or the color flags differ we want to repaint.
+  if (mTwipsPerPixel != aOther.mTwipsPerPixel ||
+      GetActualBorder() != aOther.GetActualBorder() || 
+      mFloatEdge != aOther.mFloatEdge ||
+      (shadowDifference & nsChangeHint_ReflowFrame))
+    return NS_STYLE_HINT_REFLOW;
+
+  // Note that mBorderStyle stores not only the border style but also
+  // color-related flags.  Given that we've already done an mComputedBorder
+  // comparison, border-style differences can only lead to a VISUAL hint.  So
+  // it's OK to just compare the values directly -- if either the actual
+  // style or the color flags differ we want to repaint.
+  NS_FOR_CSS_SIDES(ix) {
+    if (mBorderStyle[ix] != aOther.mBorderStyle[ix] || 
+        mBorderColor[ix] != aOther.mBorderColor[ix])
+      return NS_STYLE_HINT_VISUAL;
+  }
+
+  if (mBorderRadius != aOther.mBorderRadius ||
+      !mBorderColors != !aOther.mBorderColors)
+    return NS_STYLE_HINT_VISUAL;
+
+  if (IsBorderImageLoaded() || aOther.IsBorderImageLoaded()) {
+    if (mBorderImage != aOther.mBorderImage ||
+        mBorderImageHFill != aOther.mBorderImageHFill ||
+        mBorderImageVFill != aOther.mBorderImageVFill ||
+        mBorderImageSplit != aOther.mBorderImageSplit)
+      return NS_STYLE_HINT_VISUAL;
+    // The call to GetActualBorder above already considered
+    // mBorderImageWidth and mHaveBorderImageWidth.
+  }
+
+  // Note that at this point if mBorderColors is non-null so is
+  // aOther.mBorderColors
+  if (mBorderColors) {
     NS_FOR_CSS_SIDES(ix) {
-      if (mBorderStyle[ix] != aOther.mBorderStyle[ix] || 
-          mBorderColor[ix] != aOther.mBorderColor[ix]) {
+      if (!nsBorderColors::Equal(mBorderColors[ix],
+                                 aOther.mBorderColors[ix]))
         return NS_STYLE_HINT_VISUAL;
-      }
     }
+  }
 
-    if (mBorderRadius != aOther.mBorderRadius ||
-        !mBorderColors != !aOther.mBorderColors) {
-      return NS_STYLE_HINT_VISUAL;
-    }
-
-    if (IsBorderImageLoaded() || aOther.IsBorderImageLoaded()) {
-      if (mBorderImage != aOther.mBorderImage ||
-          mBorderImageHFill != aOther.mBorderImageHFill ||
-          mBorderImageVFill != aOther.mBorderImageVFill ||
-          mBorderImageSplit != aOther.mBorderImageSplit) {
-        return NS_STYLE_HINT_VISUAL;
-      }
-      // The call to GetActualBorder above already considered
-      // mBorderImageWidth and mHaveBorderImageWidth.
-    }
-
-    // Note that at this point if mBorderColors is non-null so is
-    // aOther.mBorderColors
-    if (mBorderColors) {
-      NS_FOR_CSS_SIDES(ix) {
-        if (!nsBorderColors::Equal(mBorderColors[ix],
-                                   aOther.mBorderColors[ix])) {
-          return NS_STYLE_HINT_VISUAL;
-        }
-      }
-    }
-
-    // Decide what to do with regards to box-shadow
-    return CalcShadowDifference(mBoxShadow, aOther.mBoxShadow);
-  }
-  return NS_STYLE_HINT_REFLOW;
+  return shadowDifference;
 }
 
 #ifdef DEBUG
 /* static */
 nsChangeHint nsStyleBorder::MaxDifference()
 {
   return NS_STYLE_HINT_REFLOW;
 }
@@ -1745,16 +1744,18 @@ nsCSSShadowArray::Release()
   mRefCnt--;
   if (mRefCnt == 0) {
     delete this;
     return 0;
   }
   return mRefCnt;
 }
 
+// Allowed to return one of NS_STYLE_HINT_NONE, NS_STYLE_HINT_REFLOW
+// or NS_STYLE_HINT_VISUAL. Currently we just return NONE or REFLOW, though.
 static nsChangeHint
 CalcShadowDifference(nsCSSShadowArray* lhs,
                      nsCSSShadowArray* rhs)
 {
   if (lhs == rhs)
     return NS_STYLE_HINT_NONE;
 
   if (!lhs || !rhs || lhs->Length() != rhs->Length())
diff -r 4f1383af8f10 layout/style/test/test_acid3_test46.html
--- a/layout/style/test/test_acid3_test46.html	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/style/test/test_acid3_test46.html	Mon Nov 03 05:09:10 2008 -0500
@@ -102,18 +102,18 @@ extracted from the test framework there 
   check('j', true); // 10
   check('k', true);
   check('l', true);
   check('m', true);
   check('n', true);
   check('o', true);
   check('p', false);
   check('q', false);
-  check('r', false);
-  check('s', false);
+  check('r', true); // false in old spec
+  check('s', true); // false in old spec
   check('t', true); // 20 - false in old spec
   check('u', false);
   check('v', true);
   check('w', true);
   check('x', true);
   // here the viewport is 0x0
   check('y1', false); // 25
   check('y2', false);
diff -r 4f1383af8f10 layout/style/test/test_media_queries.html
--- a/layout/style/test/test_media_queries.html	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/style/test/test_media_queries.html	Mon Nov 03 05:09:10 2008 -0500
@@ -52,23 +52,21 @@ function run() {
   parse_test_style_element.type = "text/css";
   parse_test_style_element.disabled = true; // for performance, hopefully
   var parse_test_style_text = document.createTextNode("");
   parse_test_style_element.appendChild(parse_test_style_text);
   document.getElementsByTagName("head")[0]
     .appendChild(parse_test_style_element);
 
   function query_is_parseable(q) {
-    parse_test_style_text.data = "@media " + q + " {}";
+    parse_test_style_text.data = "@media screen, " + q + " {}";
     var sheet = parse_test_style_element.sheet; // XXX yikes, not live!
-    if (sheet.cssRules.length == 0)
-      return false;
     if (sheet.cssRules.length == 1 &&
         sheet.cssRules[0].type == CSSRule.MEDIA_RULE)
-      return true;
+      return sheet.cssRules[0].media.mediaText != "screen";
     ok(false, "unexpected result testing whether query " + q +
               " is parseable");
     return true; // doesn't matter, we already failed
   }
 
   function query_should_be_parseable(q) {
     ok(query_is_parseable(q), "query " + q + " should be parseable");
   }
diff -r 4f1383af8f10 layout/style/ua.css
--- a/layout/style/ua.css	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/style/ua.css	Mon Nov 03 05:09:10 2008 -0500
@@ -31,17 +31,16 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 @import url(resource://gre/res/html.css);
 @import url(chrome://global/content/xul.css);
-@import url(resource://gre/res/quirk.css);
 
 @namespace parsererror url(http://www.mozilla.org/newlayout/xml/parsererror.xml);
 
 /* magic -- some of these rules are important to keep pages from overriding
             them
 */
 
 /* Tables */
diff -r 4f1383af8f10 layout/svg/base/src/nsSVGGlyphFrame.cpp
--- a/layout/svg/base/src/nsSVGGlyphFrame.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/svg/base/src/nsSVGGlyphFrame.cpp	Mon Nov 03 05:09:10 2008 -0500
@@ -420,35 +420,41 @@ static gfxContext *
 static gfxContext *
 MakeTmpCtx() {
   return new gfxContext(nsSVGUtils::GetThebesComputationalSurface());
 }
 
 NS_IMETHODIMP
 nsSVGGlyphFrame::UpdateCoveredRegion()
 {
+  mRect.Empty();
+
   nsRefPtr<gfxContext> tmpCtx = MakeTmpCtx();
-  SetupGlobalTransform(tmpCtx);
   CharacterIterator iter(this, PR_TRUE);
-  iter.SetInitialMatrix(tmpCtx);
   
   gfxRect extent;
 
   if (SetupCairoStrokeGeometry(tmpCtx)) {
     AddCharactersToPath(&iter, tmpCtx);
-    extent = tmpCtx->UserToDevice(tmpCtx->GetUserStrokeExtent());
+    extent = tmpCtx->GetUserStrokeExtent();
   } else if (GetStyleSVG()->mFill.mType != eStyleSVGPaintType_None) {
     AddBoundingBoxesToPath(&iter, tmpCtx);
-    tmpCtx->IdentityMatrix();
     extent = tmpCtx->GetUserPathExtent();
   } else {
     extent = gfxRect(0, 0, 0, 0);
   }
 
-  mRect = nsSVGUtils::ToAppPixelRect(PresContext(), extent);
+  if (!extent.IsEmpty()) {
+    gfxMatrix matrix;
+    GetGlobalTransform(&matrix);
+
+    extent = matrix.TransformBounds(extent);
+    mRect = nsSVGUtils::ToAppPixelRect(PresContext(), extent);
+  }
+
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsSVGGlyphFrame::InitialUpdate()
 {
   NS_ASSERTION(GetStateBits() & NS_FRAME_FIRST_REFLOW,
                "Yikes! We've been called already! Hopefully we weren't called "
diff -r 4f1383af8f10 layout/svg/base/src/nsSVGOuterSVGFrame.cpp
--- a/layout/svg/base/src/nsSVGOuterSVGFrame.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/svg/base/src/nsSVGOuterSVGFrame.cpp	Mon Nov 03 05:09:10 2008 -0500
@@ -780,19 +780,17 @@ nsSVGOuterSVGFrame::GetCanvasTM()
     } else {
       NS_WARNING("We should propagate the fact that the viewBox is invalid.");
       mCanvasTM = devPxToCSSPxMatrix;
     }
 
     // our content is the document element so we must premultiply the values
     // of its currentScale and currentTranslate properties
     if (mCurrentScale &&
-        mCurrentTranslate &&
-        svgElement->mEnumAttributes[nsSVGSVGElement::ZOOMANDPAN].GetAnimValue()
-        == nsIDOMSVGZoomAndPan::SVG_ZOOMANDPAN_MAGNIFY) {
+        mCurrentTranslate) {
       nsCOMPtr<nsIDOMSVGMatrix> zoomPanMatrix;
       nsCOMPtr<nsIDOMSVGMatrix> temp;
       float scale, x, y;
       mCurrentScale->GetValue(&scale);
       mCurrentTranslate->GetX(&x);
       mCurrentTranslate->GetY(&y);
       svgElement->CreateSVGMatrix(getter_AddRefs(zoomPanMatrix));
       zoomPanMatrix->Translate(x, y, getter_AddRefs(temp));
diff -r 4f1383af8f10 layout/svg/base/src/nsSVGPathGeometryFrame.cpp
--- a/layout/svg/base/src/nsSVGPathGeometryFrame.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/svg/base/src/nsSVGPathGeometryFrame.cpp	Mon Nov 03 05:09:10 2008 -0500
@@ -248,32 +248,37 @@ nsSVGPathGeometryFrame::GetCoveredRegion
 
 NS_IMETHODIMP
 nsSVGPathGeometryFrame::UpdateCoveredRegion()
 {
   mRect.Empty();
 
   gfxContext context(nsSVGUtils::GetThebesComputationalSurface());
 
-  GeneratePath(&context);
+  static_cast<nsSVGPathGeometryElement*>(mContent)->ConstructPath(&context);
 
   gfxRect extent;
 
   if (SetupCairoStrokeGeometry(&context)) {
     extent = context.GetUserStrokeExtent();
-    if (!IsDegeneratePath(extent)) {
-      extent = context.UserToDevice(extent);
-      mRect = nsSVGUtils::ToAppPixelRect(PresContext(),extent);
-    }
+  } else if (GetStyleSVG()->mFill.mType != eStyleSVGPaintType_None) {
+    extent = context.GetUserPathExtent();
   } else {
-    context.IdentityMatrix();
-    extent = context.GetUserPathExtent();
-    if (!IsDegeneratePath(extent)) {
-      mRect = nsSVGUtils::ToAppPixelRect(PresContext(),extent);
-    }
+    extent = gfxRect(0, 0, 0, 0);
+  }
+
+  if (!extent.IsEmpty()) {
+    nsCOMPtr<nsIDOMSVGMatrix> ctm;
+    GetCanvasTM(getter_AddRefs(ctm));
+    NS_ASSERTION(ctm, "graphic source didn't specify a ctm");
+
+    gfxMatrix matrix = nsSVGUtils::ConvertSVGMatrixToThebes(ctm);
+
+    extent = matrix.TransformBounds(extent);
+    mRect = nsSVGUtils::ToAppPixelRect(PresContext(), extent);
   }
 
   // Add in markers
   mRect = GetCoveredRegion();
 
   return NS_OK;
 }
 
diff -r 4f1383af8f10 layout/svg/base/src/nsSVGPathGeometryFrame.h
--- a/layout/svg/base/src/nsSVGPathGeometryFrame.h	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/svg/base/src/nsSVGPathGeometryFrame.h	Mon Nov 03 05:09:10 2008 -0500
@@ -118,28 +118,16 @@ protected:
 
 protected:
   virtual PRUint16 GetHittestMask();
 
 private:
   void Render(nsSVGRenderState *aContext);
   void GeneratePath(gfxContext *aContext);
 
-  /*
-   * Check for what cairo returns for the fill extents of a degenerate path
-   *
-   * @return PR_TRUE if the path is degenerate
-   */
-  static PRBool
-  IsDegeneratePath(const gfxRect& rect)
-  {
-    return (rect.X() == 0 && rect.Y() == 0 &&
-            rect.Width() == 0 && rect.Height() == 0);
-  }
-
   struct MarkerProperties {
     nsSVGMarkerProperty* mMarkerStart;
     nsSVGMarkerProperty* mMarkerMid;
     nsSVGMarkerProperty* mMarkerEnd;
 
     PRBool MarkersExist() const {
       return mMarkerStart || mMarkerMid || mMarkerEnd;
     }
diff -r 4f1383af8f10 layout/tables/nsTableCellFrame.cpp
--- a/layout/tables/nsTableCellFrame.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/tables/nsTableCellFrame.cpp	Mon Nov 03 05:09:10 2008 -0500
@@ -476,40 +476,25 @@ nsTableCellFrame::BuildDisplayList(nsDis
       NS_ENSURE_SUCCESS(rv, rv);
     }
   }
 
   // the 'empty-cells' property has no effect on 'outline'
   nsresult rv = DisplayOutline(aBuilder, aLists);
   NS_ENSURE_SUCCESS(rv, rv);
 
-  PRBool quirkyClip = HasPctOverHeight() &&
-    eCompatibility_NavQuirks == PresContext()->CompatibilityMode();
   nsIFrame* kid = mFrames.FirstChild();
   NS_ASSERTION(kid && !kid->GetNextSibling(), "Table cells should have just one child");
-  if (!quirkyClip) {
-    // The child's background will go in our BorderBackground() list.
-    // This isn't a problem since it won't have a real background except for
-    // event handling. We do not call BuildDisplayListForNonBlockChildren
-    // because that/ would put the child's background in the Content() list
-    // which isn't right (e.g., would end up on top of our child floats for
-    // event handling).
-    return BuildDisplayListForChild(aBuilder, kid, aDirtyRect, aLists);
-  }
-    
-  // Unfortunately there is some wacky clipping to do
-  nsDisplayListCollection set;
-  rv = BuildDisplayListForChild(aBuilder, kid, aDirtyRect, set);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  nsRect clip = GetOverflowRect();
-  if (quirkyClip) {
-    clip = nsRect(nsPoint(0, 0), GetSize());
-  }
-  return OverflowClip(aBuilder, set, aLists, clip + aBuilder->ToReferenceFrame(this));
+  // The child's background will go in our BorderBackground() list.
+  // This isn't a problem since it won't have a real background except for
+  // event handling. We do not call BuildDisplayListForNonBlockChildren
+  // because that/ would put the child's background in the Content() list
+  // which isn't right (e.g., would end up on top of our child floats for
+  // event handling).
+  return BuildDisplayListForChild(aBuilder, kid, aDirtyRect, aLists);
 }
 
 //null range means the whole thing
 NS_IMETHODIMP
 nsTableCellFrame::SetSelected(nsPresContext* aPresContext,
                               nsIDOMRange*    aRange,
                               PRBool          aSelected,
                               nsSpread        aSpread,
diff -r 4f1383af8f10 layout/tables/nsTableColGroupFrame.cpp
--- a/layout/tables/nsTableColGroupFrame.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/tables/nsTableColGroupFrame.cpp	Mon Nov 03 05:09:10 2008 -0500
@@ -207,20 +207,23 @@ nsTableColGroupFrame::SetInitialChildLis
 
 /* virtual */ void
 nsTableColGroupFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
 {
   if (!aOldStyleContext) //avoid this on init
     return;
      
   nsTableFrame* tableFrame = nsTableFrame::GetTableFrame(this);
-    
+
   if (tableFrame->IsBorderCollapse() &&
       tableFrame->BCRecalcNeeded(aOldStyleContext, GetStyleContext())) {
-    nsRect damageArea(GetFirstColumn()->GetColIndex(), 0, GetColCount(),
+    PRInt32 colCount = GetColCount();
+    if (!colCount)
+      return; // this is a degenerated colgroup 
+    nsRect damageArea(GetFirstColumn()->GetColIndex(), 0, colCount,
                       tableFrame->GetRowCount());
     tableFrame->SetBCDamageArea(damageArea);
   }
   return;
 }
 
 NS_IMETHODIMP
 nsTableColGroupFrame::AppendFrames(nsIAtom*        aListName,
diff -r 4f1383af8f10 layout/tables/nsTableFrame.cpp
--- a/layout/tables/nsTableFrame.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/tables/nsTableFrame.cpp	Mon Nov 03 05:09:10 2008 -0500
@@ -4721,26 +4721,25 @@ nsTableFrame::BCRecalcNeeded(nsStyleCont
 
   const nsStyleBorder* newStyleData = aNewStyleContext->GetStyleBorder();
   nsChangeHint change = newStyleData->CalcDifference(*oldStyleData);
   if (change == NS_STYLE_HINT_NONE)
     return PR_FALSE;
   if ((change & NS_STYLE_HINT_REFLOW) == NS_STYLE_HINT_REFLOW)
     return PR_TRUE; // the caller only needs to mark the bc damage area
   if ((change & NS_STYLE_HINT_VISUAL) == NS_STYLE_HINT_VISUAL) {
-    NS_FOR_CSS_SIDES(side) {
-      if (newStyleData->GetBorderStyle(side) !=
-          oldStyleData->GetBorderStyle(side)) {
-        // we need to recompute the borders and the caller needs to mark
-        // the bc damage area
-        nsCOMPtr<nsIRunnable> evt = new nsDelayedCalcBCBorders(this);
-        NS_DispatchToCurrentThread(evt);
-        return PR_TRUE;
-      }
-    }
+    // we need to recompute the borders and the caller needs to mark
+    // the bc damage area
+    // XXX In principle this should only be necessary for border style changes
+    // However the bc painting code tries to maximize the drawn border segments
+    // so it stores in the cellmap where a new border segment starts and this
+    // introduces a unwanted cellmap data dependence on color
+    nsCOMPtr<nsIRunnable> evt = new nsDelayedCalcBCBorders(this);
+    NS_DispatchToCurrentThread(evt);
+    return PR_TRUE;
   }
   return PR_FALSE;
 }
 
 /* BCCellBorder represents a border segment which can be either a horizontal
  * or a vertical segment. For each segment we need to know the color, width,
  * style, who owns it and how long it is in cellmap coordinates.
  * Ownership of these segments is  important to calculate which corners should
diff -r 4f1383af8f10 layout/xul/base/src/nsListBoxBodyFrame.cpp
--- a/layout/xul/base/src/nsListBoxBodyFrame.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/xul/base/src/nsListBoxBodyFrame.cpp	Mon Nov 03 05:09:10 2008 -0500
@@ -1005,17 +1005,17 @@ nsListBoxBodyFrame::VerticalScroll(PRInt
   nsIScrollableFrame* scrollFrame
     = nsLayoutUtils::GetScrollableFrameFor(this);
   if (!scrollFrame) {
     return;
   }
 
   nsPoint scrollPosition = scrollFrame->GetScrollPosition();
  
-  scrollFrame->ScrollTo(nsPoint(scrollPosition.x, aPosition), NS_SCROLL_PROPERTY_ALWAYS_BLIT);
+  scrollFrame->ScrollTo(nsPoint(scrollPosition.x, aPosition));
 
   mYPosition = aPosition;
 }
 
 ////////// frame and box retrieval
 
 nsIFrame*
 nsListBoxBodyFrame::GetFirstFrame()
diff -r 4f1383af8f10 layout/xul/base/src/nsMenuPopupFrame.cpp
--- a/layout/xul/base/src/nsMenuPopupFrame.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/xul/base/src/nsMenuPopupFrame.cpp	Mon Nov 03 05:09:10 2008 -0500
@@ -1372,21 +1372,21 @@ void nsMenuPopupFrame::EnsureMenuItemIsV
       nscoord scrollX, scrollY;
 
       nsRect viewRect = scrollableView->View()->GetBounds();
       nsRect itemRect = aMenuItem->GetRect();
       scrollableView->GetScrollPosition(scrollX, scrollY);
   
       // scroll down
       if ( itemRect.y + itemRect.height > scrollY + viewRect.height )
-        scrollableView->ScrollTo(scrollX, itemRect.y + itemRect.height - viewRect.height, NS_SCROLL_PROPERTY_ALWAYS_BLIT);
+        scrollableView->ScrollTo(scrollX, itemRect.y + itemRect.height - viewRect.height, 0);
       
       // scroll up
       else if ( itemRect.y < scrollY )
-        scrollableView->ScrollTo(scrollX, itemRect.y, NS_SCROLL_PROPERTY_ALWAYS_BLIT);
+        scrollableView->ScrollTo(scrollX, itemRect.y, 0);
     }
   }
 }
 
 NS_IMETHODIMP nsMenuPopupFrame::SetCurrentMenuItem(nsMenuFrame* aMenuItem)
 {
   if (mCurrentMenu == aMenuItem)
     return NS_OK;
diff -r 4f1383af8f10 layout/xul/base/src/nsScrollBoxObject.cpp
--- a/layout/xul/base/src/nsScrollBoxObject.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/layout/xul/base/src/nsScrollBoxObject.cpp	Mon Nov 03 05:09:10 2008 -0500
@@ -86,18 +86,17 @@ nsScrollBoxObject::~nsScrollBoxObject()
 /* void scrollTo (in long x, in long y); */
 NS_IMETHODIMP nsScrollBoxObject::ScrollTo(PRInt32 x, PRInt32 y)
 {
   nsIScrollableView* scrollableView = GetScrollableView();
   if (!scrollableView)
     return NS_ERROR_FAILURE;
 
   return scrollableView->ScrollTo(nsPresContext::CSSPixelsToAppUnits(x),
-                                  nsPresContext::CSSPixelsToAppUnits(y),
-                                  NS_SCROLL_PROPERTY_ALWAYS_BLIT);
+                                  nsPresContext::CSSPixelsToAppUnits(y), 0);
 }
 
 /* void scrollBy (in long dx, in long dy); */
 NS_IMETHODIMP nsScrollBoxObject::ScrollBy(PRInt32 dx, PRInt32 dy)
 {
   PRInt32 x, y;
   nsresult rv = GetPosition(&x, &y);
   if (NS_FAILED(rv))
@@ -223,32 +222,31 @@ NS_IMETHODIMP nsScrollBoxObject::ScrollB
    }
 
    if (horiz)
        // In the left-to-right case we scroll so that the left edge of the
        // selected child is scrolled to the left edge of the scrollbox.
        // In the right-to-left case we scroll so that the right edge of the
        // selected child is scrolled to the right edge of the scrollbox.
        return scrollableView->ScrollTo((isLTR) ? rect.x :
-                                       rect.x + rect.width - frameWidth, 
-                                       cp.y, NS_SCROLL_PROPERTY_ALWAYS_BLIT);
+                                       rect.x + rect.width - frameWidth, cp.y, 0);
    else
-       return scrollableView->ScrollTo(cp.x, rect.y, NS_SCROLL_PROPERTY_ALWAYS_BLIT);
+       return scrollableView->ScrollTo(cp.x, rect.y, 0);
 }
 
 /* void scrollToLine (in long line); */
 NS_IMETHODIMP nsScrollBoxObject::ScrollToLine(PRInt32 line)
 {
   nsIScrollableView* scrollableView = GetScrollableView();
   if (!scrollableView)
     return NS_ERROR_FAILURE;
   
   nscoord height = 0;
   scrollableView->GetLineHeight(&height);
-  scrollableView->ScrollTo(0,height*line, NS_SCROLL_PROPERTY_ALWAYS_BLIT);
+  scrollableView->ScrollTo(0, height * line, 0);
 
   return NS_OK;
 }
 
 /* void scrollToElement (in nsIDOMElement child); */
 NS_IMETHODIMP nsScrollBoxObject::ScrollToElement(nsIDOMElement *child)
 {
     NS_ENSURE_ARG_POINTER(child);
@@ -298,17 +296,17 @@ NS_IMETHODIMP nsScrollBoxObject::ScrollT
     // we only scroll in the direction of the scrollbox orientation
     // always scroll to left or top edge of child element
     if (scrolledBox->IsHorizontal()) {
         newx = rect.x - crect.x;
     } else {
         newy = rect.y - crect.y;
     }
     // scroll away
-    return scrollableView->ScrollTo(newx, newy, NS_SCROLL_PROPERTY_ALWAYS_BLIT);
+    return scrollableView->ScrollTo(newx, newy, 0);
 }
 
 /* void scrollToIndex (in long index); */
 NS_IMETHODIMP nsScrollBoxObject::ScrollToIndex(PRInt32 index)
 {
     return NS_ERROR_NOT_IMPLEMENTED;
 }
 
@@ -409,17 +407,17 @@ NS_IMETHODIMP nsScrollBoxObject::EnsureE
         if ((rect.y - crect.y) + rect.height > cp.y + crect.height) {
             newy = cp.y + (((rect.y - crect.y) + rect.height)-(cp.y + crect.height));
         } else if (rect.y - crect.y < cp.y) {
             newy = rect.y - crect.y;
         }
     }
     
     // scroll away
-    return scrollableView->ScrollTo(newx, newy, NS_SCROLL_PROPERTY_ALWAYS_BLIT);
+    return scrollableView->ScrollTo(newx, newy, 0);
 }
 
 /* void ensureIndexIsVisible (in long index); */
 NS_IMETHODIMP nsScrollBoxObject::EnsureIndexIsVisible(PRInt32 index)
 {
     return NS_ERROR_NOT_IMPLEMENTED;
 }
 
diff -r 4f1383af8f10 modules/plugin/base/src/nsNPAPIPlugin.cpp
--- a/modules/plugin/base/src/nsNPAPIPlugin.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/modules/plugin/base/src/nsNPAPIPlugin.cpp	Mon Nov 03 05:09:10 2008 -0500
@@ -184,47 +184,47 @@ PR_END_EXTERN_C
 
 #if defined(XP_MACOSX) && defined(__POWERPC__)
 
 #define TV2FP(tvp) _TV2FP((void *)tvp)
 
 static void*
 _TV2FP(void *tvp)
 {
-    static uint32_t glue[6] = {
-      0x3D800000, 0x618C0000, 0x800C0000, 0x804C0004, 0x7C0903A6, 0x4E800420
-    };
-    uint32_t* newGlue = NULL;
+  static uint32_t glue[6] = {
+    0x3D800000, 0x618C0000, 0x800C0000, 0x804C0004, 0x7C0903A6, 0x4E800420
+  };
+  uint32_t* newGlue = NULL;
 
-    if (tvp != NULL) {
-        newGlue = (uint32_t*) malloc(sizeof(glue));
-        if (newGlue != NULL) {
-            memcpy(newGlue, glue, sizeof(glue));
-            newGlue[0] |= ((UInt32)tvp >> 16);
-            newGlue[1] |= ((UInt32)tvp & 0xFFFF);
-            MakeDataExecutable(newGlue, sizeof(glue));
-        }
+  if (tvp) {
+    newGlue = (uint32_t*)malloc(sizeof(glue));
+    if (newGlue) {
+      memcpy(newGlue, glue, sizeof(glue));
+      newGlue[0] |= ((UInt32)tvp >> 16);
+      newGlue[1] |= ((UInt32)tvp & 0xFFFF);
+      MakeDataExecutable(newGlue, sizeof(glue));
     }
-    return newGlue;
+  }
+  return newGlue;
 }
 
 #define FP2TV(fp) _FP2TV((void *)fp)
 
 static void*
 _FP2TV(void *fp)
 {
-    void **newGlue = NULL;
-    if (fp != NULL) {
-        newGlue = (void**) malloc(2 * sizeof(void *));
-        if (newGlue != NULL) {
-            newGlue[0] = fp;
-            newGlue[1] = NULL;
-        }
+  void **newGlue = NULL;
+  if (fp) {
+    newGlue = (void**)malloc(2 * sizeof(void*));
+    if (newGlue) {
+      newGlue[0] = fp;
+      newGlue[1] = NULL;
     }
-    return newGlue;
+  }
+  return newGlue;
 }
 
 #else
 
 #define TV2FP(f) (f)
 #define FP2TV(f) (f)
 
 #endif /* XP_MACOSX && __POWERPC__ */
@@ -498,18 +498,18 @@ nsNPAPIPlugin::CreatePlugin(const char* 
   // we must init here because the plugin may call NPN functions
   // when we call into the NP_Initialize entry point - NPN functions
   // require that mBrowserManager be set up
   plptr->Initialize();
 
   NP_PLUGINUNIXINIT pfnInitialize =
     (NP_PLUGINUNIXINIT)PR_FindFunctionSymbol(aLibrary, "NP_Initialize");
 
-  if (pfnInitialize == NULL)
-    return NS_ERROR_UNEXPECTED; // XXX Right error?
+  if (!pfnInitialize)
+    return NS_ERROR_UNEXPECTED;
 
   if (pfnInitialize(&(nsNPAPIPlugin::CALLBACKS),&callbacks) != NS_OK)
     return NS_ERROR_UNEXPECTED;
 
   // now copy function table back to nsNPAPIPlugin instance
   memcpy((void*) &(plptr->fCallbacks), (void*)&callbacks, sizeof(callbacks));
 #endif
 
@@ -530,17 +530,17 @@ nsNPAPIPlugin::CreatePlugin(const char* 
   if (NS_FAILED((*aResult)->Initialize())) {
     NS_RELEASE(*aResult);
     return NS_ERROR_FAILURE;
   }
 
   NP_PLUGININIT pfnInitialize =
     (NP_PLUGININIT)PR_FindSymbol(aLibrary, "NP_Initialize");
 
-  if (pfnInitialize == NULL)
+  if (!pfnInitialize)
     return NS_ERROR_UNEXPECTED;
 
   if (pfnInitialize(&(nsNPAPIPlugin::CALLBACKS)) != NS_OK)
     return NS_ERROR_UNEXPECTED;
 #endif
 
 #ifdef XP_OS2
   // create the new plugin handler
@@ -557,18 +557,18 @@ nsNPAPIPlugin::CreatePlugin(const char* 
   if (NS_FAILED((*aResult)->Initialize())) {
     NS_RELEASE(*aResult);
     return NS_ERROR_FAILURE;
   }
 
   NP_PLUGININIT pfnInitialize =
     (NP_PLUGININIT)PR_FindSymbol(aLibrary, "NP_Initialize");
 
-  if (pfnInitialize == NULL)
-    return NS_ERROR_UNEXPECTED; // XXX Right error?
+  if (!pfnInitialize)
+    return NS_ERROR_UNEXPECTED;
 
   // Fixes problem where the OS/2 native multimedia plugins weren't
   // working on mozilla though did work on 4.x.  Problem is that they
   // expect the current working directory to be the plugins dir.
   // Since these plugins are no longer maintained and they represent
   // the majority of the OS/2 plugin contingency, we'll have to make
   // them work here.
 
@@ -659,50 +659,49 @@ nsNPAPIPlugin::CreatePlugin(const char* 
   NPPluginFuncs callbacks;
   memset((void*) &callbacks, 0, sizeof(callbacks));
   callbacks.size = sizeof(callbacks);
 
   NP_PLUGINSHUTDOWN pfnShutdown =
     (NP_PLUGINSHUTDOWN)PR_FindSymbol(aLibrary, "NP_Shutdown");
 
   // create the new plugin handler
-  *aResult = plptr =
-    new nsNPAPIPlugin(&callbacks, aLibrary, pfnShutdown);
+  *aResult = plptr = new nsNPAPIPlugin(&callbacks, aLibrary, pfnShutdown);
 
   if (*aResult == NULL)
     return NS_ERROR_OUT_OF_MEMORY;
 
   NS_ADDREF(*aResult);
 
   // we must init here because the plugin may call NPN functions
   // when we call into the NP_Initialize entry point - NPN functions
   // require that mBrowserManager be set up
   plptr->Initialize();
 
   NP_PLUGINUNIXINIT pfnInitialize =
     (NP_PLUGINUNIXINIT)PR_FindSymbol(aLibrary, "NP_Initialize");
 
-  if (pfnInitialize == NULL)
+  if (!pfnInitialize)
     return NS_ERROR_FAILURE;
 
   if (pfnInitialize(&(nsNPAPIPlugin::CALLBACKS),&callbacks) != NS_OK)
     return NS_ERROR_FAILURE;
 
   // now copy function table back to nsNPAPIPlugin instance
   memcpy((void*) &(plptr->fCallbacks), (void*)&callbacks, sizeof(callbacks));
 #endif
 
   return NS_OK;
 }
 
 nsresult
 nsNPAPIPlugin::CreateInstance(nsISupports *aOuter, const nsIID &aIID,
                            void **aResult)
 {
-  if (aResult == NULL)
+  if (!aResult)
     return NS_ERROR_NULL_POINTER;
 
   *aResult = NULL;
 
   // XXX This is suspicuous!
   nsRefPtr<nsNPAPIPluginInstance> inst =
     new nsNPAPIPluginInstance(&fCallbacks, fLibrary);
 
@@ -724,17 +723,17 @@ nsNPAPIPlugin::CreatePluginInstance(nsIS
                                     const char *aPluginMIMEType, void **aResult)
 {
   return CreateInstance(aOuter, aIID, aResult);
 }
 
 nsresult
 nsNPAPIPlugin::Initialize(void)
 {
-  if (nsnull == fLibrary)
+  if (!fLibrary)
     return NS_ERROR_FAILURE;
   return NS_OK;
 }
 
 nsresult
 nsNPAPIPlugin::Shutdown(void)
 {
   NPP_PLUGIN_LOG(PLUGIN_LOG_BASIC,
@@ -804,26 +803,26 @@ MakeNewNPAPIStreamInternal(NPP npp, cons
 {
   if (!npp)
     return NPERR_INVALID_INSTANCE_ERROR;
 
   PluginDestructionGuard guard(npp);
 
   nsIPluginInstance *inst = (nsIPluginInstance *) npp->ndata;
 
-  NS_ASSERTION(inst != NULL, "null instance");
-  if (inst == NULL)
+  NS_ASSERTION(inst, "null instance");
+  if (!inst)
     return NPERR_INVALID_INSTANCE_ERROR;
 
   nsCOMPtr<nsIPluginManager> pm = do_GetService(kPluginManagerCID);
   NS_ASSERTION(pm, "failed to get plugin manager");
   if (!pm) return NPERR_GENERIC_ERROR;
 
   nsCOMPtr<nsIPluginStreamListener> listener;
-  if (target == nsnull)
+  if (!target)
     ((nsNPAPIPluginInstance*)inst)->NewNotifyStream(getter_AddRefs(listener),
                                                     notifyData,
                                                     bDoNotify, relativeURL);
 
   switch (type) {
   case eNPPStreamTypeInternal_Get:
     {
       if (NS_FAILED(pm->GetURL(inst, relativeURL, target, listener)))
@@ -859,17 +858,17 @@ _geturl(NPP npp, const char* relativeURL
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
   ("NPN_GetURL: npp=%p, target=%s, url=%s\n", (void *)npp, target,
    relativeURL));
 
   PluginDestructionGuard guard(npp);
 
   // Block Adobe Acrobat from loading URLs that are not http:, https:,
   // or ftp: URLs if the given target is null.
-  if (target == nsnull && relativeURL &&
+  if (!target && relativeURL &&
       (strncmp(relativeURL, "http:", 5) != 0) &&
       (strncmp(relativeURL, "https:", 6) != 0) &&
       (strncmp(relativeURL, "ftp:", 4) != 0)) {
     nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *) npp->ndata;
 
     const char *name = nsPluginHostImpl::GetPluginName(inst);
 
     if (name && strstr(name, "Adobe") && strstr(name, "Acrobat")) {
@@ -961,17 +960,17 @@ public:
   NPStream* GetNPStream(void) { return &fNPStream; }
 };
 
 NS_IMPL_ISUPPORTS1(nsNPAPIStreamWrapper, nsISupports)
 
 nsNPAPIStreamWrapper::nsNPAPIStreamWrapper(nsIOutputStream* stream)
 : fStream(stream)
 {
-  NS_ASSERTION(stream != NULL, "bad stream");
+  NS_ASSERTION(stream, "bad stream");
 
   fStream = stream;
   NS_ADDREF(fStream);
 
   memset(&fNPStream, 0, sizeof(fNPStream));
   fNPStream.ndata = (void*) this;
 }
 
@@ -1038,19 +1037,18 @@ _write(NPP npp, NPStream *pstream, int32
 
   // negative return indicates failure to the plugin
   if (!npp)
     return -1;
 
   PluginDestructionGuard guard(npp);
 
   nsNPAPIStreamWrapper* wrapper = (nsNPAPIStreamWrapper*) pstream->ndata;
-  NS_ASSERTION(wrapper != NULL, "null stream");
-
-  if (wrapper == NULL)
+  NS_ASSERTION(wrapper, "null stream");
+  if (!wrapper)
     return -1;
 
   nsIOutputStream* stream;
   wrapper->GetStream(stream);
 
   PRUint32 count = 0;
   nsresult rv = stream->Write((char *)buffer, len, &count);
   NS_RELEASE(stream);
@@ -1088,19 +1086,19 @@ _destroystream(NPP npp, NPStream *pstrea
 
     // FIXME: http://bugzilla.mozilla.org/show_bug.cgi?id=240131
     //
     // Is it ok to leave pstream->ndata set here, and who releases it
     // (or is it even properly ref counted)? And who closes the stream
     // etc?
   } else {
     nsNPAPIStreamWrapper* wrapper = (nsNPAPIStreamWrapper *)pstream->ndata;
-    NS_ASSERTION(wrapper != NULL, "null wrapper");
+    NS_ASSERTION(wrapper, "null wrapper");
 
-    if (wrapper == NULL)
+    if (!wrapper)
       return NPERR_INVALID_PARAM;
 
     // This will release the wrapped nsIOutputStream.
     delete wrapper;
     pstream->ndata = nsnull;
   }
 
   return NPERR_NO_ERROR;
@@ -1214,17 +1212,17 @@ _invalidateregion(NPP npp, NPRegion inva
                  ("NPN_InvalidateRegion: npp=%p, region=%p\n", (void*)npp,
                   (void*)invalidRegion));
 
   if (!npp || !npp->ndata) {
     NS_WARNING("_invalidateregion: npp or npp->ndata == 0");
     return;
   }
 
-  nsIPluginInstance *inst = (nsIPluginInstance *) npp->ndata;
+  nsIPluginInstance *inst = (nsIPluginInstance *)npp->ndata;
 
   PluginDestructionGuard guard(inst);
 
   nsCOMPtr<nsIPluginInstancePeer> peer;
   if (NS_SUCCEEDED(inst->GetPeer(getter_AddRefs(peer))) && peer) {
     nsCOMPtr<nsIWindowlessPluginInstancePeer> wpeer(do_QueryInterface(peer));
     if (wpeer) {
       // nsPluginRegion & NPRegion are typedef'd to the same thing
@@ -2212,19 +2210,19 @@ _setvalue(NPP npp, NPPVariable variable,
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_SetValue: npp=%p, var=%d\n",
                                      (void*)npp, (int)variable));
 
   if (!npp)
     return NPERR_INVALID_INSTANCE_ERROR;
 
   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *) npp->ndata;
 
-  NS_ASSERTION(inst != NULL, "null instance");
+  NS_ASSERTION(inst, "null instance");
 
-  if (inst == NULL)
+  if (!inst)
     return NPERR_INVALID_INSTANCE_ERROR;
 
   PluginDestructionGuard guard(inst);
 
   switch (variable) {
 
     // we should keep backward compatibility with NPAPI where the
     // actual pointer value is checked rather than its content
diff -r 4f1383af8f10 modules/plugin/base/src/nsNPAPIPluginInstance.cpp
--- a/modules/plugin/base/src/nsNPAPIPluginInstance.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/modules/plugin/base/src/nsNPAPIPluginInstance.cpp	Mon Nov 03 05:09:10 2008 -0500
@@ -81,17 +81,16 @@ nsNPAPIPluginStreamListener::nsNPAPIPlug
     mStreamCleanedUp(PR_FALSE),
     mCallNotify(PR_FALSE),
     mIsSuspended(PR_FALSE),
     mIsPluginInitJSStream(mInst->mInPluginInitCall &&
                           aURL && strncmp(aURL, "javascript:",
                                           sizeof("javascript:") - 1) == 0),
     mResponseHeaderBuf(nsnull)
 {
-  // Initialize the 4.x interface structure
   memset(&mNPStream, 0, sizeof(mNPStream));
 
   NS_IF_ADDREF(mInst);
 }
 
 nsNPAPIPluginStreamListener::~nsNPAPIPluginStreamListener(void)
 {
   // remove itself from the instance stream list
@@ -281,17 +280,16 @@ nsNPAPIPluginStreamListener::SuspendRequ
                "Suspending a request that's already suspended!");
 
   nsCOMPtr<nsINPAPIPluginStreamInfo> pluginInfoNPAPI =
     do_QueryInterface(mStreamInfo);
   nsIRequest *request;
 
   if (!pluginInfoNPAPI || !(request = pluginInfoNPAPI->GetRequest())) {
     NS_ERROR("Trying to suspend a non-suspendable stream!");
-
     return NS_ERROR_FAILURE;
   }
 
   nsresult rv = StartDataPump();
   NS_ENSURE_SUCCESS(rv, rv);
 
   mIsSuspended = PR_TRUE;
 
@@ -302,19 +300,18 @@ nsNPAPIPluginStreamListener::ResumeReque
 nsNPAPIPluginStreamListener::ResumeRequest()
 {
   nsCOMPtr<nsINPAPIPluginStreamInfo> pluginInfoNPAPI =
     do_QueryInterface(mStreamInfo);
 
   nsIRequest *request = pluginInfoNPAPI->GetRequest();
 
   // request can be null if the network stream is done.
-  if (request) {
+  if (request)
     request->Resume();
-  }
 
   mIsSuspended = PR_FALSE;
 }
 
 nsresult
 nsNPAPIPluginStreamListener::StartDataPump()
 {
   nsresult rv;
@@ -327,17 +324,16 @@ nsNPAPIPluginStreamListener::StartDataPu
                                           nsITimer::TYPE_REPEATING_SLACK);
 }
 
 void
 nsNPAPIPluginStreamListener::StopDataPump()
 {
   if (mDataPumpTimer) {
     mDataPumpTimer->Cancel();
-
     mDataPumpTimer = nsnull;
   }
 }
 
 // Return true if a javascript: load that was started while the plugin
 // was being initialized is still in progress.
 PRBool
 nsNPAPIPluginStreamListener::PluginInitJSLoadInProgress()
@@ -426,26 +422,25 @@ nsNPAPIPluginStreamListener::OnDataAvail
     // and some plugins (e.g. acrobat) can fail. 
     if ((PRInt32)mNPStream.end < streamOffset)
       mNPStream.end = streamOffset;
   }
 
   nsresult rv = NS_OK;
   while (NS_SUCCEEDED(rv) && length > 0) {
     if (input && length) {
-      if (mStreamBufferSize < mStreamBufferByteCount + length &&
-          mIsSuspended) {
+      if (mStreamBufferSize < mStreamBufferByteCount + length && mIsSuspended) {
         // We're in the ::OnDataAvailable() call that we might get
         // after suspending a request, or we suspended the request
         // from within this ::OnDataAvailable() call while there's
         // still data in the input, and we don't have enough space to
         // store what we got off the network. Reallocate our internal
         // buffer.
         mStreamBufferSize = mStreamBufferByteCount + length;
-        char *buf = (char *)PR_Realloc(mStreamBuffer, mStreamBufferSize);
+        char *buf = (char*)PR_Realloc(mStreamBuffer, mStreamBufferSize);
         if (!buf)
           return NS_ERROR_OUT_OF_MEMORY;
 
         mStreamBuffer = buf;
       }
 
       PRUint32 bytesToRead =
         PR_MIN(length, mStreamBufferSize - mStreamBufferByteCount);
@@ -539,17 +534,16 @@ nsNPAPIPluginStreamListener::OnDataAvail
                      ("NPP Write called: this=%p, npp=%p, pos=%d, len=%d, "
                       "buf=%s, return(written)=%d,  url=%s\n",
                       this, npp, streamPosition, numtowrite,
                       ptrStreamBuffer, writeCount, mNPStream.url));
 
       if (!mStreamStarted) {
         // The plugin called NPN_DestroyStream() from within
         // NPP_Write(), kill the stream.
-
         return NS_BINDING_ABORTED;
       }
 
       if (writeCount > 0) {
         NS_ASSERTION(writeCount <= mStreamBufferByteCount,
                      "Plugin read past the end of the available data!");
 
         writeCount = PR_MIN(writeCount, mStreamBufferByteCount);
@@ -702,32 +696,28 @@ nsNPAPIPluginStreamListener::Notify(nsIT
   NS_ASSERTION(aTimer == mDataPumpTimer, "Uh, wrong timer?");
 
   PRInt32 oldStreamBufferByteCount = mStreamBufferByteCount;
 
   nsresult rv = OnDataAvailable(mStreamInfo, nsnull, mStreamBufferByteCount);
 
   if (NS_FAILED(rv)) {
     // We ran into an error, no need to keep firing this timer then.
-
     aTimer->Cancel();
-
     return NS_OK;
   }
 
   if (mStreamBufferByteCount != oldStreamBufferByteCount &&
       ((mStreamStarted && mStreamBufferByteCount < 1024) ||
        mStreamBufferByteCount == 0)) {
     // The plugin read some data and we've got less than 1024 bytes in
     // our buffer (or its empty and the stream is already
     // done). Resume the request so that we get more data off the
     // network.
-
     ResumeRequest();
-
     // Necko will pump data now that we've resumed the request.
     StopDataPump();
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
@@ -863,17 +853,17 @@ NS_IMETHODIMP nsNPAPIPluginInstance::Sto
   // started as other threads might be checking that inside a lock.
   EnterAsyncPluginThreadCallLock();
   mStarted = PR_FALSE;
   ExitAsyncPluginThreadCallLock();
 
   OnPluginDestroy(&fNPP);
 
   if (fCallbacks->destroy == NULL)
-    return NS_ERROR_FAILURE; // XXX right error?
+    return NS_ERROR_FAILURE;
 
   NPSavedData *sdata = 0;
 
   // clean up open streams
   for (nsInstanceStream *is = mStreams; is != nsnull;) {
     nsNPAPIPluginStreamListener * listener = is->mPluginStreamListener;
 
     nsInstanceStream *next = is->mNext;
@@ -899,33 +889,28 @@ NS_IMETHODIMP nsNPAPIPluginInstance::Sto
   else
     return NS_OK;
 }
 
 already_AddRefed<nsPIDOMWindow>
 nsNPAPIPluginInstance::GetDOMWindow()
 {
   nsCOMPtr<nsPIPluginInstancePeer> pp (do_QueryInterface(mPeer));
-  if (!pp) {
+  if (!pp)
     return nsnull;
-  }
 
   nsCOMPtr<nsIPluginInstanceOwner> owner;
   pp->GetOwner(getter_AddRefs(owner));
-
-  if (!owner) {
+  if (!owner)
     return nsnull;
-  }
 
   nsCOMPtr<nsIDocument> doc;
   owner->GetDocument(getter_AddRefs(doc));
-
-  if (!doc) {
+  if (!doc)
     return nsnull;
-  }
 
   nsPIDOMWindow *window = doc->GetWindow();
   NS_IF_ADDREF(window);
 
   return window;
 }
 
 nsresult nsNPAPIPluginInstance::InitializePlugin(nsIPluginInstancePeer* peer)
@@ -952,19 +937,20 @@ nsresult nsNPAPIPluginInstance::Initiali
     // crafted specially to be directly behind the arrays from GetAttributes()
     // with a null entry as a separator. This is for 4.x backwards compatibility!
     // see bug 111008 for details
     if (tagtype != nsPluginTagType_Embed) {
       PRUint16 pcount = 0;
       const char* const* pnames = nsnull;
       const char* const* pvalues = nsnull;    
       if (NS_SUCCEEDED(taginfo->GetParameters(pcount, pnames, pvalues))) {
-        NS_ASSERTION(nsnull == values[count], "attribute/parameter array not setup correctly for 4.x plugins");
+        NS_ASSERTION(!values[count], "attribute/parameter array not setup correctly for NPAPI plugins");
         if (pcount)
-          count += ++pcount; //if it's all setup correctly, then all we need is to change the count (attrs + PARAM/blank + params)
+          count += ++pcount; // if it's all setup correctly, then all we need is to
+                             // change the count (attrs + PARAM/blank + params)
       }
     }
   }
 
   NS_ENSURE_TRUE(fCallbacks->newp, NS_ERROR_FAILURE);
   
   // XXX Note that the NPPluginType_* enums were crafted to be
   // backward compatible...
@@ -1062,17 +1048,17 @@ NS_IMETHODIMP nsNPAPIPluginInstance::Des
   PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsNPAPIPluginInstance::Destroy this=%p\n",this));
 
   // destruction is handled in the Stop call
   return NS_OK;
 }
 
 NS_IMETHODIMP nsNPAPIPluginInstance::SetWindow(nsPluginWindow* window)
 {
-  // XXX 4.x plugins don't want a SetWindow(NULL).
+  // XXX NPAPI plugins don't want a SetWindow(NULL).
   if (!window || !mStarted)
     return NS_OK;
 
   NPError error;
 
 #if defined (MOZ_WIDGET_GTK2)
   // bug 108347, flash plugin on linux doesn't like window->width <=
   // 0, but Java needs wants this call.
@@ -1100,17 +1086,16 @@ NS_IMETHODIMP nsNPAPIPluginInstance::Set
     NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
     ("NPP SetWindow called: this=%p, [x=%d,y=%d,w=%d,h=%d], clip[t=%d,b=%d,l=%d,r=%d], return=%d\n",
     this, window->x, window->y, window->width, window->height,
     window->clipRect.top, window->clipRect.bottom, window->clipRect.left, window->clipRect.right, error));
       
     // XXX In the old code, we'd just ignore any errors coming
     // back from the plugin's SetWindow(). Is this the correct
     // behavior?!?
-
   }
   return NS_OK;
 }
 
 /* NOTE: the caller must free the stream listener */
 // Create a normal stream, one without a urlnotify callback
 NS_IMETHODIMP nsNPAPIPluginInstance::NewStream(nsIPluginStreamListener** listener)
 {
@@ -1128,19 +1113,19 @@ nsresult nsNPAPIPluginInstance::NewNotif
 
   // add it to the list
   nsInstanceStream * is = new nsInstanceStream();
   NS_ENSURE_TRUE(is, NS_ERROR_OUT_OF_MEMORY);
 
   is->mNext = mStreams;
   is->mPluginStreamListener = stream;
   mStreams = is;
-  stream->SetCallNotify(aCallNotify);  // set flag in stream to call URLNotify
+  stream->SetCallNotify(aCallNotify); // set flag in stream to call URLNotify
 
-  NS_ADDREF(stream);  // Stabilize
+  NS_ADDREF(stream); // Stabilize
     
   nsresult res = stream->QueryInterface(kIPluginStreamListenerIID, (void**)listener);
 
   // Destabilize and avoid leaks. Avoid calling delete <interface pointer>
   NS_RELEASE(stream);
 
   return res;
 }
@@ -1149,17 +1134,17 @@ NS_IMETHODIMP nsNPAPIPluginInstance::Pri
 {
   NS_ENSURE_TRUE(platformPrint, NS_ERROR_NULL_POINTER);
 
   PluginDestructionGuard guard(this);
 
   NPPrint* thePrint = (NPPrint *)platformPrint;
 
   // to be compatible with the older SDK versions and to match what
-  // 4.x and other browsers do, overwrite |window.type| field with one
+  // NPAPI and other browsers do, overwrite |window.type| field with one
   // more copy of |platformPrint|. See bug 113264
   if (fCallbacks) {
     PRUint16 sdkmajorversion = (fCallbacks->version & 0xff00)>>8;
     PRUint16 sdkminorversion = fCallbacks->version & 0x00ff;
     if ((sdkmajorversion == 0) && (sdkminorversion < 11)) { 
       // Let's copy platformPrint bytes over to where it was supposed to be 
       // in older versions -- four bytes towards the beginning of the struct
       // but we should be careful about possible misalignments
@@ -1238,27 +1223,24 @@ nsresult nsNPAPIPluginInstance::GetValue
 
     NS_TRY_SAFE_CALL_RETURN(res, (*fCallbacks->getvalue)(&fNPP, variable, value), fLibrary, this);
     NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
     ("NPP GetValue called: this=%p, npp=%p, var=%d, value=%d, return=%d\n", 
     this, &fNPP, variable, value, res));
 
 #ifdef XP_OS2
     /* Query interface for legacy Flash plugin */
-    if (res == NS_OK && variable == NPPVpluginScriptableInstance)
-    {
+    if (res == NS_OK && variable == NPPVpluginScriptableInstance) {
       nsCOMPtr<nsILegacyPluginWrapperOS2> wrapper =
                do_GetService(NS_LEGACY_PLUGIN_WRAPPER_CONTRACTID, &res);
-      if (res == NS_OK)
-      {
+      if (res == NS_OK) {
         nsIID *iid = nsnull; 
         res = (*fCallbacks->getvalue)(&fNPP, NPPVpluginScriptableIID, (void *)&iid);
         if (res == NS_OK)
-          res = wrapper->MaybeWrap(*iid, *(nsISupports**)value,
-                                   (nsISupports**)value);
+          res = wrapper->MaybeWrap(*iid, *(nsISupports**)value, (nsISupports**)value);
       }
     }
 #endif
   }
 
   return res;
 }
 
@@ -1293,27 +1275,27 @@ NS_IMETHODIMP nsNPAPIPluginInstance::Get
       res = GetValueInternal((NPPVariable)variable, value);
   }
 
   return res;
 }
 
 nsresult nsNPAPIPluginInstance::GetNPP(NPP* aNPP) 
 {
-  if (aNPP != nsnull)
+  if (aNPP)
     *aNPP = &fNPP;
   else
     return NS_ERROR_NULL_POINTER;
 
   return NS_OK;
 }
 
 nsresult nsNPAPIPluginInstance::GetCallbacks(const NPPluginFuncs ** aCallbacks)
 {
-  if (aCallbacks != nsnull)
+  if (aCallbacks)
     *aCallbacks = fCallbacks;
   else
     return NS_ERROR_NULL_POINTER;
 
   return NS_OK;
 }
 
 NPError nsNPAPIPluginInstance::SetWindowless(PRBool aWindowless)
@@ -1462,17 +1444,16 @@ nsNPAPIPluginInstance::PushPopupsEnabled
     return;
 
   PopupControlState oldState =
     window->PushPopupControlState(aEnabled ? openAllowed : openAbused,
                                   PR_TRUE);
 
   if (!mPopupStates.AppendElement(NS_INT32_TO_PTR(oldState))) {
     // Appending to our state stack failed, push what we just popped.
-
     window->PopPopupControlState(oldState);
   }
 }
 
 void
 nsNPAPIPluginInstance::PopPopupsEnabledState()
 {
   PRInt32 last = mPopupStates.Count() - 1;
diff -r 4f1383af8f10 modules/plugin/base/src/nsPluginHostImpl.cpp
--- a/modules/plugin/base/src/nsPluginHostImpl.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/modules/plugin/base/src/nsPluginHostImpl.cpp	Mon Nov 03 05:09:10 2008 -0500
@@ -87,16 +87,18 @@
 #include "nsHashtable.h"
 #include "nsIProxyInfo.h"
 #include "nsObsoleteModuleLoading.h"
 #include "nsIComponentRegistrar.h"
 #include "nsPluginLogging.h"
 #include "nsIPrefBranch2.h"
 #include "nsIScriptChannel.h"
 #include "nsPrintfCString.h"
+#include "nsIBlocklistService.h"
+#include "nsVersionComparator.h"
 
 // Friggin' X11 has to "#define None". Lame!
 #ifdef None
 #undef None
 #endif
 
 #ifdef CursorShape
 #undef CursorShape /*X.h defines it as 0,
@@ -198,27 +200,29 @@
 // 0.03 changed name, description and mime desc from string to bytes, bug 108246
 // 0.04 added new mime entry point on Mac, bug 113464
 // 0.05 added new entry point check for the default plugin, bug 132430
 // 0.06 strip off suffixes in mime description strings, bug 53895
 // 0.07 changed nsIRegistry to flat file support for caching plugins info
 // 0.08 mime entry point on MachO, bug 137535
 // 0.09 the file encoding is changed to UTF-8, bug 420285
 // 0.10 added plugin versions on appropriate platforms, bug 427743
+// The current plugin registry version (and the maximum version we know how to read)
 static const char *kPluginRegistryVersion = "0.10";
-////////////////////////////////////////////////////////////////////////
+// The minimum registry version we know how to read
+static const char *kMinimumRegistryVersion = "0.9";
+
 // CID's && IID's
 static NS_DEFINE_IID(kIPluginInstanceIID, NS_IPLUGININSTANCE_IID);
 static NS_DEFINE_CID(kPluginCID, NS_PLUGIN_CID);
 static NS_DEFINE_IID(kIPluginTagInfo2IID, NS_IPLUGINTAGINFO2_IID);
 static const char kDirectoryServiceContractID[] = "@mozilla.org/file/directory_service;1";
 // for the dialog
 static NS_DEFINE_CID(kCPluginManagerCID, NS_PLUGINMANAGER_CID); // needed for NS_TRY_SAFE_CALL
 
-////////////////////////////////////////////////////////////////////////
 // Registry keys for caching plugin info
 static const char kPluginsRootKey[] = "software/plugins";
 static const char kPluginsNameKey[] = "name";
 static const char kPluginsDescKey[] = "description";
 static const char kPluginsFilenameKey[] = "filename";
 static const char kPluginsFullpathKey[] = "fullpath";
 static const char kPluginsModTimeKey[] = "lastModTimeStamp";
 static const char kPluginsCanUnload[] = "canUnload";
@@ -256,17 +260,16 @@ static nsActivePluginList *gActivePlugin
 
 #ifdef CALL_SAFETY_ON
 PRBool gSkipPluginSafeCalls = PR_FALSE;
 #endif
 
 nsIFile *nsPluginHostImpl::sPluginTempDir;
 nsPluginHostImpl *nsPluginHostImpl::sInst;
 
-////////////////////////////////////////////////////////////////////////
 // flat file reg funcs
 static
 PRBool ReadSectionHeader(nsPluginManifestLineReader& reader, const char *token)
 {
   do {
     if (*reader.LinePtr() == '[') {
       char* p = reader.LinePtr() + (reader.LineLength() - 1);
       if (*p != ']')
@@ -281,17 +284,16 @@ PRBool ReadSectionHeader(nsPluginManifes
         break; // it's wrong token
       }
       return PR_TRUE;
     }
   } while (reader.NextLine());
   return PR_FALSE;
 }
 
-////////////////////////////////////////////////////////////////////////
 // Little helper struct to asynchronously reframe any presentations (embedded)
 // or reload any documents (full-page), that contained plugins
 // which were shutdown as a result of a plugins.refresh(1)
 class nsPluginDocReframeEvent: public nsRunnable {
 public:
   nsPluginDocReframeEvent(nsISupportsArray* aDocs) { mDocs = aDocs; }
 
   NS_DECL_NSIRUNNABLE
@@ -309,18 +311,17 @@ NS_IMETHODIMP nsPluginDocReframeEvent::R
   // the frame constructor to rebuild
   for (PRUint32 i = 0; i < c; i++) {
     nsCOMPtr<nsIDocument> doc (do_QueryElementAt(mDocs, i));
     if (doc) {
       nsIPresShell *shell = doc->GetPrimaryShell();
 
       // if this document has a presentation shell, then it has frames and can be reframed
       if (shell) {
-        /**
-         * A reframe will cause a fresh object frame, instance owner, and instance
+        /* A reframe will cause a fresh object frame, instance owner, and instance
          * to be created. Reframing of the entire document is necessary as we may have
          * recently found new plugins and we want a shot at trying to use them instead
          * of leaving alternate renderings.
          * We do not want to completely reload all the documents that had running plugins
          * because we could possibly trigger a script to run in the unload event handler
          * which may want to access our defunct plugin and cause us to crash.
          */
 
@@ -331,50 +332,44 @@ NS_IMETHODIMP nsPluginDocReframeEvent::R
 
       }
     }
   }
 
   return mDocs->Clear();
 }
 
-////////////////////////////////////////////////////////////////////////
 nsActivePlugin::nsActivePlugin(nsPluginTag* aPluginTag,
                                nsIPluginInstance* aInstance,
                                const char * url,
                                PRBool aDefaultPlugin,
                                nsIPluginInstancePeer* peer)
 {
   mNext = nsnull;
   mPeer = nsnull;
   mPluginTag = aPluginTag;
 
   mURL = PL_strdup(url);
   mInstance = aInstance;
-  if(aInstance && peer)
-  {
+  if (aInstance && peer) {
     mPeer = peer;
     NS_ADDREF(mPeer);
     NS_ADDREF(aInstance);
   }
   mXPConnected = PR_FALSE;
   mDefaultPlugin = aDefaultPlugin;
   mStopped = PR_FALSE;
   mllStopTime = LL_ZERO;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 nsActivePlugin::~nsActivePlugin()
 {
   mPluginTag = nsnull;
-  if(mInstance != nsnull)
-  {
-    if(mPeer)
-    {
+  if (mInstance) {
+    if (mPeer) {
       nsresult rv = NS_OK;
       nsCOMPtr<nsPIPluginInstancePeer> peer(do_QueryInterface(mPeer));
       nsCOMPtr<nsIPluginInstanceOwner> owner;
       rv = peer->GetOwner(getter_AddRefs(owner));
       if (owner)
         owner->SetInstance(nsnull);
     }
 
@@ -387,168 +382,143 @@ nsActivePlugin::~nsActivePlugin()
       mInstance->Destroy();
 
     NS_RELEASE(mInstance);
     NS_IF_RELEASE(mPeer);
   }
   PL_strfree(mURL);
 }
 
-
-////////////////////////////////////////////////////////////////////////
 void nsActivePlugin::setStopped(PRBool stopped)
 {
   mStopped = stopped;
-  if(mStopped) // plugin instance is told to stop
+  if (mStopped) // plugin instance is told to stop
     mllStopTime = PR_Now();
   else
     mllStopTime = LL_ZERO;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 nsActivePluginList::nsActivePluginList()
 {
   mFirst = nsnull;
   mLast = nsnull;
   mCount = 0;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 nsActivePluginList::~nsActivePluginList()
 {
-  if(mFirst == nsnull)
+  if (mFirst == nsnull)
     return;
   shut();
 }
 
-
-////////////////////////////////////////////////////////////////////////
 void nsActivePluginList::shut()
 {
-  if(mFirst == nsnull)
-    return;
-
-  for(nsActivePlugin * plugin = mFirst; plugin != nsnull;)
-  {
+  if (!mFirst)
+    return;
+
+  for (nsActivePlugin * plugin = mFirst; plugin != nsnull;) {
     nsActivePlugin * next = plugin->mNext;
     remove(plugin);
     plugin = next;
   }
   mFirst = nsnull;
   mLast = nsnull;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 PRInt32 nsActivePluginList::add(nsActivePlugin * plugin)
 {
-  if (mFirst == nsnull)
-  {
+  if (!mFirst) {
     mFirst = plugin;
     mLast = plugin;
     mFirst->mNext = nsnull;
   }
-  else
-  {
+  else {
     mLast->mNext = plugin;
     mLast = plugin;
   }
   mLast->mNext = nsnull;
   mCount++;
   return mCount;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 PRBool nsActivePluginList::IsLastInstance(nsActivePlugin * plugin)
 {
-  if(!plugin)
-    return PR_FALSE;
-
-  if(!plugin->mPluginTag)
-    return PR_FALSE;
-
-  for(nsActivePlugin * p = mFirst; p != nsnull; p = p->mNext)
-  {
-    if((p->mPluginTag == plugin->mPluginTag) && (p != plugin))
+  if (!plugin)
+    return PR_FALSE;
+
+  if (!plugin->mPluginTag)
+    return PR_FALSE;
+
+  for (nsActivePlugin * p = mFirst; p != nsnull; p = p->mNext) {
+    if ((p->mPluginTag == plugin->mPluginTag) && (p != plugin))
       return PR_FALSE;
   }
   return PR_TRUE;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 PRBool nsActivePluginList::remove(nsActivePlugin * plugin)
 {
-  if(mFirst == nsnull)
+  if (mFirst == nsnull)
     return PR_FALSE;
 
   nsActivePlugin * prev = nsnull;
-  for(nsActivePlugin * p = mFirst; p != nsnull; p = p->mNext)
-  {
-    if(p == plugin)
-    {
+  for (nsActivePlugin * p = mFirst; p != nsnull; p = p->mNext) {
+    if (p == plugin) {
       PRBool lastInstance = IsLastInstance(p);
 
-      if(p == mFirst)
+      if (p == mFirst)
         mFirst = p->mNext;
       else
         prev->mNext = p->mNext;
 
-      if((prev != nsnull) && (prev->mNext == nsnull))
+      if ((prev != nsnull) && (prev->mNext == nsnull))
         mLast = prev;
 
       // see if this is going to be the last instance of a plugin
       // if so we should perform nsIPlugin::Shutdown and unload the library
       // by calling nsPluginTag::TryUnloadPlugin()
-      if(lastInstance)
-      {
+      if (lastInstance) {
         // cache some things as we are going to destroy it right now
         nsPluginTag *pluginTag = p->mPluginTag;
 
         delete p; // plugin instance is destroyed here
 
-        if(pluginTag)
+        if (pluginTag)
           pluginTag->TryUnloadPlugin();
         else
           NS_ASSERTION(pluginTag, "pluginTag was not set, plugin not shutdown");
 
       }
       else
         delete p;
 
       mCount--;
       return PR_TRUE;
     }
     prev = p;
   }
   return PR_FALSE;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 // This method terminates all running instances of plugins and collects their
 // documents to be returned through an array. This method is used
 // when we are shutting down or when a plugins.refresh(1) happens.
 // If aPluginTag is given, then only that plugin is terminated
 void nsActivePluginList::stopRunning(nsISupportsArray* aReloadDocs,
                                      nsPluginTag* aPluginTag)
 {
-  if(mFirst == nsnull)
+  if (mFirst == nsnull)
     return;
 
   PRBool doCallSetWindowAfterDestroy = PR_FALSE;
 
-  for(nsActivePlugin * p = mFirst; p != nsnull; p = p->mNext)
-  {
-    if(!p->mStopped && p->mInstance &&
-       (!aPluginTag || aPluginTag == p->mPluginTag))
-    {
+  for (nsActivePlugin * p = mFirst; p != nsnull; p = p->mNext) {
+    if (!p->mStopped && p->mInstance &&
+       (!aPluginTag || aPluginTag == p->mPluginTag)) {
       // then determine if the plugin wants Destroy to be called after
       // Set Window.  This is for bug 50547.
       p->mInstance->GetValue(nsPluginInstanceVariable_CallSetWindowAfterDestroyBool,
                              (void *) &doCallSetWindowAfterDestroy);
       if (doCallSetWindowAfterDestroy) {
         p->mInstance->Stop();
         p->mInstance->Destroy();
         p->mInstance->SetWindow(nsnull);
@@ -574,166 +544,142 @@ void nsActivePluginList::stopRunning(nsI
           if (doc && aReloadDocs->IndexOf(doc) == -1)  // don't allow for duplicates
             aReloadDocs->AppendElement(doc);
         }
       }
     }
   }
 }
 
-
-////////////////////////////////////////////////////////////////////////
 void nsActivePluginList::removeAllStopped()
 {
-  if(mFirst == nsnull)
+  if (mFirst == nsnull)
     return;
 
   nsActivePlugin * next = nsnull;
 
-  for(nsActivePlugin * p = mFirst; p != nsnull;)
-  {
+  for (nsActivePlugin * p = mFirst; p != nsnull;) {
     next = p->mNext;
 
-    if(p->mStopped)
+    if (p->mStopped)
       remove(p);
 
     p = next;
   }
   return;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 nsActivePlugin * nsActivePluginList::find(nsIPluginInstance* instance)
 {
-  for(nsActivePlugin * p = mFirst; p != nsnull; p = p->mNext)
-  {
-    if(p->mInstance == instance)
-    {
+  for (nsActivePlugin * p = mFirst; p != nsnull; p = p->mNext) {
+    if (p->mInstance == instance) {
 #ifdef NS_DEBUG
       PRBool doCache = PR_TRUE;
       p->mInstance->GetValue(nsPluginInstanceVariable_DoCacheBool, (void *) &doCache);
       NS_ASSERTION(!p->mStopped || doCache, "This plugin is not supposed to be cached!");
 #endif
       return p;
     }
   }
   return nsnull;
 }
 
 nsActivePlugin * nsActivePluginList::find(const char * mimetype)
 {
   PRBool defaultplugin = (PL_strcmp(mimetype, "*") == 0);
 
-  for(nsActivePlugin * p = mFirst; p != nsnull; p = p->mNext)
-  {
+  for (nsActivePlugin * p = mFirst; p != nsnull; p = p->mNext) {
     // give it some special treatment for the default plugin first
     // because we cannot tell the default plugin by asking peer for a mime type
-    if(defaultplugin && p->mDefaultPlugin)
+    if (defaultplugin && p->mDefaultPlugin)
       return p;
 
-    if(!p->mPeer)
+    if (!p->mPeer)
       continue;
 
     nsMIMEType mt;
 
     nsresult res = p->mPeer->GetMIMEType(&mt);
 
-    if(NS_FAILED(res))
-      continue;
-
-    if(PL_strcasecmp(mt, mimetype) == 0)
-    {
+    if (NS_FAILED(res))
+      continue;
+
+    if (PL_strcasecmp(mt, mimetype) == 0) {
 #ifdef NS_DEBUG
       PRBool doCache = PR_TRUE;
       p->mInstance->GetValue(nsPluginInstanceVariable_DoCacheBool, (void *) &doCache);
       NS_ASSERTION(!p->mStopped || doCache, "This plugin is not supposed to be cached!");
 #endif
        return p;
     }
   }
   return nsnull;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 nsActivePlugin * nsActivePluginList::findStopped(const char * url)
 {
-  for(nsActivePlugin * p = mFirst; p != nsnull; p = p->mNext)
-  {
-    if(!PL_strcmp(url, p->mURL) && p->mStopped)
-    {
+  for (nsActivePlugin * p = mFirst; p != nsnull; p = p->mNext) {
+    if (!PL_strcmp(url, p->mURL) && p->mStopped) {
 #ifdef NS_DEBUG
       PRBool doCache = PR_TRUE;
       p->mInstance->GetValue(nsPluginInstanceVariable_DoCacheBool, (void *) &doCache);
       NS_ASSERTION(doCache, "This plugin is not supposed to be cached!");
 #endif
        return p;
     }
   }
   return nsnull;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 PRUint32 nsActivePluginList::getStoppedCount()
 {
   PRUint32 stoppedCount = 0;
-  for(nsActivePlugin * p = mFirst; p != nsnull; p = p->mNext)
-  {
-    if(p->mStopped)
+  for (nsActivePlugin * p = mFirst; p != nsnull; p = p->mNext) {
+    if (p->mStopped)
       stoppedCount++;
   }
   return stoppedCount;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 nsActivePlugin * nsActivePluginList::findOldestStopped()
 {
   nsActivePlugin * res = nsnull;
   PRInt64 llTime = LL_MAXINT;
-  for(nsActivePlugin * p = mFirst; p != nsnull; p = p->mNext)
-  {
-    if(!p->mStopped)
-      continue;
-
-    if(LL_CMP(p->mllStopTime, <, llTime))
-    {
+  for (nsActivePlugin * p = mFirst; p != nsnull; p = p->mNext) {
+    if (!p->mStopped)
+      continue;
+
+    if (LL_CMP(p->mllStopTime, <, llTime)) {
       llTime = p->mllStopTime;
       res = p;
     }
   }
 
 #ifdef NS_DEBUG
-  if(res)
-  {
+  if (res) {
     PRBool doCache = PR_TRUE;
     res->mInstance->GetValue(nsPluginInstanceVariable_DoCacheBool, (void *) &doCache);
     NS_ASSERTION(doCache, "This plugin is not supposed to be cached!");
   }
 #endif
 
   return res;
 }
 
-////////////////////////////////////////////////////////////////////////
 inline char* new_str(const char* str)
 {
-  if(str == nsnull)
+  if (str == nsnull)
     return nsnull;
 
   char* result = new char[strlen(str) + 1];
   if (result != nsnull)
     return strcpy(result, str);
   return result;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 nsPluginTag::nsPluginTag(nsPluginTag* aPluginTag)
   : mPluginHost(nsnull),
     mName(aPluginTag->mName),
     mDescription(aPluginTag->mDescription),
     mVariants(aPluginTag->mVariants),
     mMimeTypeArray(nsnull),
     mMimeDescriptionArray(aPluginTag->mMimeDescriptionArray),
     mExtensionsArray(nsnull),
@@ -744,33 +690,29 @@ nsPluginTag::nsPluginTag(nsPluginTag* aP
     mIsJavaPlugin(aPluginTag->mIsJavaPlugin),
     mIsNPRuntimeEnabledJavaPlugin(aPluginTag->mIsNPRuntimeEnabledJavaPlugin),
     mFileName(aPluginTag->mFileName),
     mFullPath(aPluginTag->mFullPath),
     mVersion(aPluginTag->mVersion),
     mLastModifiedTime(0),
     mFlags(NS_PLUGIN_FLAG_ENABLED)
 {
-  if(aPluginTag->mMimeTypeArray != nsnull)
-  {
+  if (aPluginTag->mMimeTypeArray != nsnull) {
     mMimeTypeArray = new char*[mVariants];
     for (int i = 0; i < mVariants; i++)
       mMimeTypeArray[i] = new_str(aPluginTag->mMimeTypeArray[i]);
   }
 
-  if(aPluginTag->mExtensionsArray != nsnull)
-  {
+  if (aPluginTag->mExtensionsArray != nsnull) {
     mExtensionsArray = new char*[mVariants];
     for (int i = 0; i < mVariants; i++)
       mExtensionsArray[i] = new_str(aPluginTag->mExtensionsArray[i]);
   }
 }
 
-
-////////////////////////////////////////////////////////////////////////
 nsPluginTag::nsPluginTag(nsPluginInfo* aPluginInfo)
   : mPluginHost(nsnull),
     mName(aPluginInfo->fName),
     mDescription(aPluginInfo->fDescription),
     mVariants(aPluginInfo->fVariantCount),
     mMimeTypeArray(nsnull),
     mExtensionsArray(nsnull),
     mLibrary(nsnull),
@@ -784,18 +726,17 @@ nsPluginTag::nsPluginTag(nsPluginInfo* a
     mIsJavaPlugin(PR_FALSE),
     mIsNPRuntimeEnabledJavaPlugin(PR_FALSE),
     mFileName(aPluginInfo->fFileName),
     mFullPath(aPluginInfo->fFullPath),
     mVersion(aPluginInfo->fVersion),
     mLastModifiedTime(0),
     mFlags(NS_PLUGIN_FLAG_ENABLED)
 {
-  if(aPluginInfo->fMimeTypeArray != nsnull)
-  {
+  if (aPluginInfo->fMimeTypeArray != nsnull) {
     mMimeTypeArray = new char*[mVariants];
     for (int i = 0; i < mVariants; i++) {
       if (mIsJavaPlugin && aPluginInfo->fMimeTypeArray[i] &&
           strcmp(aPluginInfo->fMimeTypeArray[i],
                  "application/x-java-vm-npruntime") == 0) {
         mIsNPRuntimeEnabledJavaPlugin = PR_TRUE;
 
         // Stop processing here, any mimetypes after the magic "I'm a
@@ -806,18 +747,17 @@ nsPluginTag::nsPluginTag(nsPluginInfo* a
       }
 
       mMimeTypeArray[i] = new_str(aPluginInfo->fMimeTypeArray[i]);
       if (nsPluginHostImpl::IsJavaMIMEType(mMimeTypeArray[i]))
         mIsJavaPlugin = PR_TRUE;
     }
   }
 
-  if(aPluginInfo->fMimeDescriptionArray != nsnull)
-  {
+  if (aPluginInfo->fMimeDescriptionArray != nsnull) {
     for (int i = 0; i < mVariants; i++) {
       // we should cut off the list of suffixes which the mime
       // description string may have, see bug 53895
       // it is usually in form "some description (*.sf1, *.sf2)"
       // so we can search for the opening round bracket
       char cur = '\0';
       char pre = '\0';
       char * p = PL_strrchr(aPluginInfo->fMimeDescriptionArray[i], '(');
@@ -838,29 +778,25 @@ nsPluginTag::nsPluginTag(nsPluginInfo* a
         *p = cur;
       if (pre != '\0')
         *(p - 1) = pre;
     }
   } else {
     mMimeDescriptionArray.SetLength(mVariants);
   }
 
-  if(aPluginInfo->fExtensionArray != nsnull)
-  {
+  if (aPluginInfo->fExtensionArray != nsnull) {
     mExtensionsArray = new char*[mVariants];
     for (int i = 0; i < mVariants; i++)
       mExtensionsArray[i] = new_str(aPluginInfo->fExtensionArray[i]);
   }
 
   EnsureMembersAreUTF8();
 }
 
-
-
-////////////////////////////////////////////////////////////////////////
 nsPluginTag::nsPluginTag(const char* aName,
                          const char* aDescription,
                          const char* aFileName,
                          const char* aFullPath,
                          const char* aVersion,
                          const char* const* aMimeTypes,
                          const char* const* aMimeDescriptions,
                          const char* const* aExtensions,
@@ -1091,17 +1027,16 @@ nsPluginTag::SetBlocklisted(PRBool aBloc
     Mark(NS_PLUGIN_FLAG_BLOCKLISTED);
   else
     UnMark(NS_PLUGIN_FLAG_BLOCKLISTED);
 
   mPluginHost->UpdatePluginInfo(nsnull);
   return NS_OK;
 }
 
-//----------------------------------------------------------------------
 // helper struct for asynchronous handeling of plugin unloading
 class nsPluginUnloadEvent : public nsRunnable {
 public:
   nsPluginUnloadEvent(PRLibrary* aLibrary)
     : mLibrary(aLibrary)
   {}
  
   NS_DECL_NSIRUNNABLE
@@ -1128,28 +1063,25 @@ nsresult PostPluginUnloadEvent(PRLibrary
     return NS_OK;
 
   // failure case
   NS_TRY_SAFE_CALL_VOID(PR_UnloadLibrary(aLibrary), nsnull, nsnull);
 
   return NS_ERROR_FAILURE;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 void nsPluginTag::TryUnloadPlugin(PRBool aForceShutdown)
 {
   PRBool isXPCOM = PR_FALSE;
   if (!(mFlags & NS_PLUGIN_FLAG_OLDSCHOOL))
     isXPCOM = PR_TRUE;
 
   if (isXPCOM && !aForceShutdown) return;
 
-  if (mEntryPoint)
-  {
+  if (mEntryPoint) {
     mEntryPoint->Shutdown();
     mEntryPoint->Release();
     mEntryPoint = nsnull;
   }
 
   // before we unload check if we are allowed to, see bug #61388
   // also, never unload an XPCOM plugin library
   if (mLibrary && mCanUnloadLibrary && !isXPCOM) {
@@ -1166,36 +1098,34 @@ void nsPluginTag::TryUnloadPlugin(PRBool
 
   // we should zero it anyway, it is going to be unloaded by
   // CleanUnsedLibraries before we need to call the library
   // again so the calling code should not be fooled and reload
   // the library fresh
   mLibrary = nsnull;
 }
 
-////////////////////////////////////////////////////////////////////////
 PRBool nsPluginTag::Equals(nsPluginTag *aPluginTag)
 {
   NS_ENSURE_TRUE(aPluginTag, PR_FALSE);
 
-  if ( (!mName.Equals(aPluginTag->mName)) ||
-       (!mDescription.Equals(aPluginTag->mDescription)) ||
-       (mVariants != aPluginTag->mVariants) )
+  if ((!mName.Equals(aPluginTag->mName)) ||
+      (!mDescription.Equals(aPluginTag->mDescription)) ||
+      (mVariants != aPluginTag->mVariants))
     return PR_FALSE;
 
   if (mVariants && mMimeTypeArray && aPluginTag->mMimeTypeArray) {
     for (PRInt32 i = 0; i < mVariants; i++) {
       if (PL_strcmp(mMimeTypeArray[i], aPluginTag->mMimeTypeArray[i]) != 0)
         return PR_FALSE;
     }
   }
   return PR_TRUE;
 }
 
-////////////////////////////////////////////////////////////////////////
 class nsPluginStreamListenerPeer;
 
 class nsPluginStreamInfo : public nsINPAPIPluginStreamInfo
 {
 public:
   nsPluginStreamInfo();
   virtual ~nsPluginStreamInfo();
 
@@ -1272,19 +1202,16 @@ private:
   PRBool mSeekable;
   PRUint32 mLength;
   PRUint32 mModified;
   nsIPluginInstance * mPluginInstance;
   nsPluginStreamListenerPeer * mPluginStreamListenerPeer;
   PRInt32 mStreamOffset;
   PRBool mStreamComplete;
 };
-
-
-///////////////////////////////////////////////////////////////////////////////////////////////////
 
 class nsPluginStreamListenerPeer : public nsIStreamListener,
                                    public nsIProgressEventSink,
                                    public nsIHttpHeaderVisitor,
                                    public nsSupportsWeakReference
 {
 public:
   nsPluginStreamListenerPeer();
@@ -1351,17 +1278,16 @@ private:
 
 public:
   PRBool                  mAbort;
   PRInt32                 mPendingRequests;
   nsWeakPtr               mWeakPtrChannelCallbacks;
   nsWeakPtr               mWeakPtrChannelLoadGroup;
 };
 
-////////////////////////////////////////////////////////////////////////
 class nsPluginByteRangeStreamListener : public nsIStreamListener {
 public:
   nsPluginByteRangeStreamListener(nsIWeakReference* aWeakPtr);
   virtual ~nsPluginByteRangeStreamListener();
 
   // nsISupports
   NS_DECL_ISUPPORTS
 
@@ -1372,47 +1298,42 @@ public:
   NS_DECL_NSISTREAMLISTENER
 
 private:
   nsCOMPtr<nsIStreamListener> mStreamConverter;
   nsWeakPtr mWeakPtrPluginStreamListenerPeer;
   PRBool mRemoveMagicNumber;
 };
 
-////////////////////////////////////////////////////////////////////////
 nsPluginStreamInfo::nsPluginStreamInfo()
 {
   mPluginInstance = nsnull;
   mPluginStreamListenerPeer = nsnull;
 
   mContentType = nsnull;
   mURL = nsnull;
   mSeekable = PR_FALSE;
   mLength = 0;
   mModified = 0;
   mStreamOffset = 0;
   mStreamComplete = PR_FALSE;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 nsPluginStreamInfo::~nsPluginStreamInfo()
 {
-  if(mContentType != nsnull)
-  PL_strfree(mContentType);
-  if(mURL != nsnull)
+  if (mContentType)
+    PL_strfree(mContentType);
+  if (mURL)
     PL_strfree(mURL);
 
   NS_IF_RELEASE(mPluginInstance);
 }
 
-////////////////////////////////////////////////////////////////////////
 NS_IMPL_ISUPPORTS2(nsPluginStreamInfo, nsIPluginStreamInfo,
                    nsINPAPIPluginStreamInfo)
-////////////////////////////////////////////////////////////////////////
 
 NS_IMETHODIMP
 nsPluginStreamInfo::GetContentType(nsMIMEType* result)
 {
   *result = mContentType;
   return NS_OK;
 }
 
@@ -1445,48 +1366,45 @@ nsPluginStreamInfo::GetURL(const char** 
 }
 
 void
 nsPluginStreamInfo::MakeByteRangeString(nsByteRange* aRangeList, nsACString &rangeRequest, PRInt32 *numRequests)
 {
   rangeRequest.Truncate();
   *numRequests  = 0;
   //the string should look like this: bytes=500-700,601-999
-  if(!aRangeList)
+  if (!aRangeList)
     return;
 
   PRInt32 requestCnt = 0;
   nsCAutoString string("bytes=");
 
-  for(nsByteRange * range = aRangeList; range != nsnull; range = range->next)
-  {
+  for (nsByteRange * range = aRangeList; range != nsnull; range = range->next) {
     // XXX zero length?
-    if(!range->length)
+    if (!range->length)
       continue;
 
     // XXX needs to be fixed for negative offsets
     string.AppendInt(range->offset);
     string.Append("-");
     string.AppendInt(range->offset + range->length - 1);
-    if(range->next)
+    if (range->next)
       string += ",";
 
     requestCnt++;
   }
 
   // get rid of possible trailing comma
   string.Trim(",", PR_FALSE);
 
   rangeRequest = string;
   *numRequests  = requestCnt;
   return;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP
 nsPluginStreamInfo::RequestRead(nsByteRange* rangeList)
 {
   nsCAutoString rangeString;
   PRInt32 numRequests;
 
   //first of all lets see if mPluginStreamListenerPeer is still alive
   nsCOMPtr<nsISupportsWeakReference> suppWeakRef(
@@ -1496,33 +1414,33 @@ nsPluginStreamInfo::RequestRead(nsByteRa
 
   nsCOMPtr<nsIWeakReference> pWeakRefPluginStreamListenerPeer =
            do_GetWeakReference(suppWeakRef);
   if (!pWeakRefPluginStreamListenerPeer)
     return NS_ERROR_FAILURE;
 
   MakeByteRangeString(rangeList, rangeString, &numRequests);
 
-  if(numRequests == 0)
+  if (numRequests == 0)
     return NS_ERROR_FAILURE;
 
   nsresult rv = NS_OK;
   nsCOMPtr<nsIURI> url;
 
   rv = NS_NewURI(getter_AddRefs(url), nsDependentCString(mURL));
 
   nsCOMPtr<nsIInterfaceRequestor> callbacks = do_QueryReferent(mPluginStreamListenerPeer->mWeakPtrChannelCallbacks);
   nsCOMPtr<nsILoadGroup> loadGroup = do_QueryReferent(mPluginStreamListenerPeer->mWeakPtrChannelLoadGroup);
   nsCOMPtr<nsIChannel> channel;
   rv = NS_NewChannel(getter_AddRefs(channel), url, nsnull, loadGroup, callbacks);
   if (NS_FAILED(rv))
     return rv;
 
   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(channel));
-  if(!httpChannel)
+  if (!httpChannel)
     return NS_ERROR_FAILURE;
 
   httpChannel->SetRequestHeader(NS_LITERAL_CSTRING("Range"), rangeString, PR_FALSE);
 
   mPluginStreamListenerPeer->mAbort = PR_TRUE; // instruct old stream listener to cancel
                                                // the request on the next ODA.
 
   nsCOMPtr<nsIStreamListener> converter;
@@ -1557,164 +1475,136 @@ nsPluginStreamInfo::RequestRead(nsByteRa
 
 NS_IMETHODIMP
 nsPluginStreamInfo::GetStreamOffset(PRInt32 *result)
 {
   *result = mStreamOffset;
   return NS_OK;
 }
 
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP
 nsPluginStreamInfo::SetStreamOffset(PRInt32 offset)
 {
   mStreamOffset = offset;
   return NS_OK;
 }
 
-////////////////////////////////////////////////////////////////////////
 void
 nsPluginStreamInfo::SetContentType(const nsMIMEType contentType)
 {
-  if(mContentType != nsnull)
+  if (mContentType != nsnull)
     PL_strfree(mContentType);
 
   mContentType = PL_strdup(contentType);
 }
 
-
-////////////////////////////////////////////////////////////////////////
 void
 nsPluginStreamInfo::SetSeekable(const PRBool seekable)
 {
   mSeekable = seekable;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 void
 nsPluginStreamInfo::SetLength(const PRUint32 length)
 {
   mLength = length;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 void
 nsPluginStreamInfo::SetLastModified(const PRUint32 modified)
 {
   mModified = modified;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 void
 nsPluginStreamInfo::SetURL(const char* url)
 {
-  if(mURL != nsnull)
+  if (mURL)
     PL_strfree(mURL);
 
   mURL = PL_strdup(url);
 }
 
-////////////////////////////////////////////////////////////////////////
 void
 nsPluginStreamInfo::SetPluginInstance(nsIPluginInstance * aPluginInstance)
 {
-    NS_IF_ADDREF(mPluginInstance = aPluginInstance);
-}
-
-
-////////////////////////////////////////////////////////////////////////
+  NS_IF_ADDREF(mPluginInstance = aPluginInstance);
+}
+
 void
 nsPluginStreamInfo::SetPluginStreamListenerPeer(nsPluginStreamListenerPeer * aPluginStreamListenerPeer)
 {
-    // not addref'd - nsPluginStreamInfo is owned by mPluginStreamListenerPeer
-    mPluginStreamListenerPeer = aPluginStreamListenerPeer;
-}
-
-
-///////////////////////////////////////////////////////////////////////////////////////////////////
+  // not addref'd - nsPluginStreamInfo is owned by mPluginStreamListenerPeer
+  mPluginStreamListenerPeer = aPluginStreamListenerPeer;
+}
 
 class nsPluginCacheListener : public nsIStreamListener
 {
 public:
   nsPluginCacheListener(nsPluginStreamListenerPeer* aListener);
   virtual ~nsPluginCacheListener();
 
   NS_DECL_ISUPPORTS
 
   NS_DECL_NSIREQUESTOBSERVER
   NS_DECL_NSISTREAMLISTENER
 
 private:
   nsPluginStreamListenerPeer* mListener;
 };
 
-
-////////////////////////////////////////////////////////////////////////
 nsPluginCacheListener::nsPluginCacheListener(nsPluginStreamListenerPeer* aListener)
 {
   mListener = aListener;
   NS_ADDREF(mListener);
 }
 
-
-////////////////////////////////////////////////////////////////////////
 nsPluginCacheListener::~nsPluginCacheListener()
 {
   NS_IF_RELEASE(mListener);
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMPL_ISUPPORTS1(nsPluginCacheListener, nsIStreamListener)
-////////////////////////////////////////////////////////////////////////
+
 NS_IMETHODIMP
 nsPluginCacheListener::OnStartRequest(nsIRequest *request, nsISupports* ctxt)
 {
   return NS_OK;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP
 nsPluginCacheListener::OnDataAvailable(nsIRequest *request, nsISupports* ctxt,
                                        nsIInputStream* aIStream,
                                        PRUint32 sourceOffset,
                                        PRUint32 aLength)
 {
 
   PRUint32 readlen;
   char* buffer = (char*) PR_Malloc(aLength);
 
   // if we don't read from the stream, OnStopRequest will never be called
-  if(!buffer)
+  if (!buffer)
     return NS_ERROR_OUT_OF_MEMORY;
 
   nsresult rv = aIStream->Read(buffer, aLength, &readlen);
 
   NS_ASSERTION(aLength == readlen, "nsCacheListener->OnDataAvailable: "
                "readlen != aLength");
 
   PR_Free(buffer);
   return rv;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP
 nsPluginCacheListener::OnStopRequest(nsIRequest *request,
                                      nsISupports* aContext,
                                      nsresult aStatus)
 {
   return NS_OK;
 }
-
-///////////////////////////////////////////////////////////////////////////////////////////////////////
 
 nsPluginStreamListenerPeer::nsPluginStreamListenerPeer()
 {
   mURL = nsnull;
   mOwner = nsnull;
   mInstance = nsnull;
   mPStreamListener = nsnull;
   mHost = nsnull;
@@ -1724,23 +1614,21 @@ nsPluginStreamListenerPeer::nsPluginStre
   mRequestFailed = PR_FALSE;
 
   mPendingRequests = 0;
   mHaveFiredOnStartRequest = PR_FALSE;
   mDataForwardToRequest = nsnull;
   mLocalCachedFile = nsnull;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 nsPluginStreamListenerPeer::~nsPluginStreamListenerPeer()
 {
 #ifdef PLUGIN_LOGGING
   nsCAutoString urlSpec;
-  if(mURL != nsnull) (void)mURL->GetSpec(urlSpec);
+  if (mURL != nsnull) (void)mURL->GetSpec(urlSpec);
 
   PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_NORMAL,
     ("nsPluginStreamListenerPeer::dtor this=%p, url=%s%c",this, urlSpec.get(), mLocalCachedFile?',':'\n'));
 #endif
 
   NS_IF_RELEASE(mURL);
   NS_IF_RELEASE(mOwner);
   NS_IF_RELEASE(mInstance);
@@ -1770,36 +1658,31 @@ nsPluginStreamListenerPeer::~nsPluginStr
       mLocalCachedFile->Remove(PR_FALSE);
       NS_RELEASE(mLocalCachedFile);
     }
   }
 
   delete mDataForwardToRequest;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMPL_ISUPPORTS4(nsPluginStreamListenerPeer,
                    nsIStreamListener,
                    nsIRequestObserver,
                    nsIHttpHeaderVisitor,
                    nsISupportsWeakReference)
-////////////////////////////////////////////////////////////////////////
-
-
-/* Called as a result of GetURL and PostURL */
-////////////////////////////////////////////////////////////////////////
+
+// Called as a result of GetURL and PostURL
 nsresult nsPluginStreamListenerPeer::Initialize(nsIURI *aURL,
                                                 nsIPluginInstance *aInstance,
                                                 nsIPluginStreamListener* aListener,
                                                 PRInt32 requestCount)
 {
 #ifdef PLUGIN_LOGGING
   nsCAutoString urlSpec;
-  if(aURL != nsnull) (void)aURL->GetAsciiSpec(urlSpec);
+  if (aURL != nsnull) (void)aURL->GetAsciiSpec(urlSpec);
 
   PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_NORMAL,
         ("nsPluginStreamListenerPeer::Initialize instance=%p, url=%s\n", aInstance, urlSpec.get()));
 
   PR_LogFlush();
 #endif
 
   mURL = aURL;
@@ -1823,23 +1706,21 @@ nsresult nsPluginStreamListenerPeer::Ini
   mDataForwardToRequest = new nsHashtable(16, PR_FALSE);
   if (!mDataForwardToRequest)
       return NS_ERROR_FAILURE;
 
   return NS_OK;
 }
 
 
-/*
-    Called by NewEmbeddedPluginStream() - if this is called, we weren't
-    able to load the plugin, so we need to load it later once we figure
-    out the mimetype.  In order to load it later, we need the plugin
-    host and instance owner.
-*/
-////////////////////////////////////////////////////////////////////////
+/* Called by NewEmbeddedPluginStream() - if this is called, we weren't
+ * able to load the plugin, so we need to load it later once we figure
+ * out the mimetype.  In order to load it later, we need the plugin
+ * host and instance owner.
+ */
 nsresult nsPluginStreamListenerPeer::InitializeEmbedded(nsIURI *aURL,
                                                         nsIPluginInstance* aInstance,
                                                         nsIPluginInstanceOwner *aOwner,
                                                         nsIPluginHost *aHost)
 {
 #ifdef PLUGIN_LOGGING
   nsCAutoString urlSpec;
   (void)aURL->GetSpec(urlSpec);
@@ -1848,17 +1729,17 @@ nsresult nsPluginStreamListenerPeer::Ini
         ("nsPluginStreamListenerPeer::InitializeEmbedded url=%s\n", urlSpec.get()));
 
   PR_LogFlush();
 #endif
 
   mURL = aURL;
   NS_ADDREF(mURL);
 
-  if(aInstance != nsnull) {
+  if (aInstance) {
     NS_ASSERTION(mInstance == nsnull, "nsPluginStreamListenerPeer::InitializeEmbedded mInstance != nsnull");
     mInstance = aInstance;
     NS_ADDREF(mInstance);
   } else {
     mOwner = aOwner;
     NS_IF_ADDREF(mOwner);
 
     mHost = aHost;
@@ -1875,18 +1756,17 @@ nsresult nsPluginStreamListenerPeer::Ini
   mDataForwardToRequest = new nsHashtable(16, PR_FALSE);
   if (!mDataForwardToRequest)
       return NS_ERROR_FAILURE;
 
   return NS_OK;
 }
 
 
-/* Called by NewFullPagePluginStream() */
-////////////////////////////////////////////////////////////////////////
+// Called by NewFullPagePluginStream()
 nsresult nsPluginStreamListenerPeer::InitializeFullPage(nsIPluginInstance *aInstance)
 {
   PLUGIN_LOG(PLUGIN_LOG_NORMAL,
   ("nsPluginStreamListenerPeer::InitializeFullPage instance=%p\n",aInstance));
 
   NS_ASSERTION(mInstance == nsnull, "nsPluginStreamListenerPeer::InitializeFullPage mInstance != nsnull");
   mInstance = aInstance;
   NS_ADDREF(mInstance);
@@ -1900,18 +1780,16 @@ nsresult nsPluginStreamListenerPeer::Ini
 
   mDataForwardToRequest = new nsHashtable(16, PR_FALSE);
   if (!mDataForwardToRequest)
       return NS_ERROR_FAILURE;
 
   return NS_OK;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 // SetupPluginCacheFile is called if we have to save the stream to disk.
 // the most likely cause for this is either there is no disk cache available
 // or the stream is coming from a https server.
 //
 // These files will be deleted when the host is destroyed.
 //
 // TODO? What if we fill up the the dest dir?
 nsresult
@@ -1933,18 +1811,17 @@ nsPluginStreamListenerPeer::SetupPluginC
     pActivePlugins->mStreams->Count((PRUint32*)&cnt);
     while (--cnt >= 0 && !useExistingCacheFile) {
       nsPluginStreamListenerPeer *lp =
         reinterpret_cast<nsPluginStreamListenerPeer *>(pActivePlugins->mStreams->ElementAt(cnt));
       if (lp) {
         if (lp->mLocalCachedFile &&
             lp->mPluginStreamInfo &&
             (useExistingCacheFile =
-             lp->mPluginStreamInfo->UseExistingPluginCacheFile(mPluginStreamInfo)))
-        {
+             lp->mPluginStreamInfo->UseExistingPluginCacheFile(mPluginStreamInfo))) {
             NS_ADDREF(mLocalCachedFile = lp->mLocalCachedFile);
         }
         NS_RELEASE(lp);
       }
     }
     pActivePlugins = pActivePlugins->mNext;
   }
 
@@ -1956,17 +1833,17 @@ nsPluginStreamListenerPeer::SetupPluginC
     }
 
     // Get the filename from the channel
     nsCOMPtr<nsIURI> uri;
     rv = channel->GetURI(getter_AddRefs(uri));
     if (NS_FAILED(rv)) return rv;
 
     nsCOMPtr<nsIURL> url(do_QueryInterface(uri));
-    if(!url)
+    if (!url)
       return NS_ERROR_FAILURE;
 
     nsCAutoString filename;
     url->GetFileName(filename);
     if (NS_FAILED(rv))
       return rv;
 
     // Create a file to save our stream into. Should we scramble the name?
@@ -2005,18 +1882,16 @@ nsPluginStreamListenerPeer::SetupPluginC
 
     nsISupports* supports = static_cast<nsISupports*>((static_cast<nsIStreamListener*>(this)));
     pActivePlugins->mStreams->AppendElement(supports);
   }
 
   return rv;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP
 nsPluginStreamListenerPeer::OnStartRequest(nsIRequest *request,
                                            nsISupports* aContext)
 {
   nsresult  rv = NS_OK;
 
   if (mHaveFiredOnStartRequest) {
       return NS_OK;
@@ -2041,17 +1916,17 @@ nsPluginStreamListenerPeer::OnStartReque
       mRequestFailed = PR_TRUE;
       return NS_ERROR_FAILURE;
     }
 
     if (responseCode > 206) { // not normal
       PRBool bWantsAllNetworkStreams = PR_FALSE;
       mInstance->GetValue(nsPluginInstanceVariable_WantsAllNetworkStreams,
                           (void *)&bWantsAllNetworkStreams);
-      if(!bWantsAllNetworkStreams) {
+      if (!bWantsAllNetworkStreams) {
         mRequestFailed = PR_TRUE;
         return NS_ERROR_FAILURE;
       }
     }
   }
 
   // do a little sanity check to make sure our frame isn't gone
   // by getting the tag type and checking for an error, we can determine if
@@ -2127,148 +2002,126 @@ nsPluginStreamListenerPeer::OnStartReque
 
   // if we don't have an nsIPluginInstance (mInstance), it means
   // we weren't able to load a plugin previously because we
   // didn't have the mimetype.  Now that we do (aContentType),
   // we'll try again with SetUpPluginInstance()
   // which is called by InstantiateEmbeddedPlugin()
   // NOTE: we don't want to try again if we didn't get the MIME type this time
 
-  if ((nsnull == mInstance) && (nsnull != mOwner) && (!aContentType.IsEmpty()))
-  {
+  if (!mInstance && mOwner && !aContentType.IsEmpty()) {
     mOwner->GetInstance(mInstance);
     mOwner->GetWindow(window);
-
-    if ((nsnull == mInstance) && (nsnull != mHost) && (nsnull != window))
-    {
+    if (!mInstance && mHost && window) {
       // determine if we need to try embedded again. FullPage takes a different code path
       nsPluginMode mode;
       mOwner->GetMode(&mode);
       if (mode == nsPluginMode_Embedded)
         rv = mHost->InstantiateEmbeddedPlugin(aContentType.get(), aURL, mOwner);
       else
         rv = mHost->SetUpPluginInstance(aContentType.get(), aURL, mOwner);
 
-      if (NS_OK == rv)
-      {
+      if (NS_OK == rv) {
         // GetInstance() adds a ref
         mOwner->GetInstance(mInstance);
-
-        if (nsnull != mInstance)
-        {
+        if (mInstance) {
           mInstance->Start();
           mOwner->CreateWidget();
-
-          // If we've got a native window, the let the plugin know
-          // about it.
-          if (window->window)
-          {
+          // If we've got a native window, the let the plugin know about it.
+          if (window->window) {
             nsCOMPtr<nsIPluginInstance> inst = mInstance;
             ((nsPluginNativeWindow*)window)->CallSetWindow(inst);
           }
         }
       }
     }
   }
 
-  //
   // Set up the stream listener...
-  //
   rv = SetUpStreamListener(request, aURL);
   if (NS_FAILED(rv)) return rv;
 
   return rv;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP nsPluginStreamListenerPeer::OnProgress(nsIRequest *request,
                                                      nsISupports* aContext,
                                                      PRUint64 aProgress,
                                                      PRUint64 aProgressMax)
 {
   nsresult rv = NS_OK;
   return rv;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP nsPluginStreamListenerPeer::OnStatus(nsIRequest *request,
                                                    nsISupports* aContext,
                                                    nsresult aStatus,
                                                    const PRUnichar* aStatusArg)
 {
   return NS_OK;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 class nsPRUintKey : public nsHashKey {
 protected:
-    PRUint32 mKey;
-public:
-    nsPRUintKey(PRUint32 key) : mKey(key) {}
-
-    PRUint32 HashCode(void) const {
-        return mKey;
-    }
-
-    PRBool Equals(const nsHashKey *aKey) const {
-        return mKey == ((const nsPRUintKey *) aKey)->mKey;
-    }
-    nsHashKey *Clone() const {
-        return new nsPRUintKey(mKey);
-    }
-    PRUint32 GetValue() { return mKey; }
-};
-
-
-////////////////////////////////////////////////////////////////////////
+  PRUint32 mKey;
+public:
+  nsPRUintKey(PRUint32 key) : mKey(key) {}
+
+  PRUint32 HashCode(void) const {
+    return mKey;
+  }
+
+  PRBool Equals(const nsHashKey *aKey) const {
+    return mKey == ((const nsPRUintKey*)aKey)->mKey;
+  }
+  nsHashKey *Clone() const {
+    return new nsPRUintKey(mKey);
+  }
+  PRUint32 GetValue() { return mKey; }
+};
+
 NS_IMETHODIMP nsPluginStreamListenerPeer::OnDataAvailable(nsIRequest *request,
                                                           nsISupports* aContext,
                                                           nsIInputStream *aIStream,
                                                           PRUint32 sourceOffset,
                                                           PRUint32 aLength)
 {
   if (mRequestFailed)
     return NS_ERROR_FAILURE;
 
-  if(mAbort)
-  {
+  if (mAbort) {
       PRUint32 magicNumber = 0;  // set it to something that is not the magic number.
       nsCOMPtr<nsISupportsPRUint32> container = do_QueryInterface(aContext);
       if (container)
         container->GetData(&magicNumber);
 
-      if (magicNumber != MAGIC_REQUEST_CONTEXT)
-      {
+      if (magicNumber != MAGIC_REQUEST_CONTEXT) {
         // this is not one of our range requests
         mAbort = PR_FALSE;
         return NS_BINDING_ABORTED;
       }
   }
 
   nsresult rv = NS_OK;
 
-  if(!mPStreamListener || !mPluginStreamInfo)
+  if (!mPStreamListener || !mPluginStreamInfo)
     return NS_ERROR_FAILURE;
 
   mPluginStreamInfo->SetRequest(request);
 
   const char * url = nsnull;
   mPluginStreamInfo->GetURL(&url);
 
   PLUGIN_LOG(PLUGIN_LOG_NOISY,
   ("nsPluginStreamListenerPeer::OnDataAvailable this=%p request=%p, offset=%d, length=%d, url=%s\n",
   this, request, sourceOffset, aLength, url ? url : "no url set"));
 
   // if the plugin has requested an AsFileOnly stream, then don't
   // call OnDataAvailable
-  if(mStreamType != nsPluginStreamType_AsFileOnly)
-  {
+  if (mStreamType != nsPluginStreamType_AsFileOnly) {
     // get the absolute offset of the request, if one exists.
     nsCOMPtr<nsIByteRangeRequest> brr = do_QueryInterface(request);
     if (brr) {
       if (!mDataForwardToRequest)
         return NS_ERROR_FAILURE;
 
       PRInt64 absoluteOffset64 = LL_ZERO;
       brr->GetStartRange(&absoluteOffset64);
@@ -2325,18 +2178,16 @@ NS_IMETHODIMP nsPluginStreamListenerPeer
         rv = mFileCacheOutputStream->Write(buffer, amountRead, &amountWrote);
       }
     }
     delete [] buffer;
   }
   return rv;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP nsPluginStreamListenerPeer::OnStopRequest(nsIRequest *request,
                                                         nsISupports* aContext,
                                                         nsresult aStatus)
 {
   nsresult rv = NS_OK;
 
   PLUGIN_LOG(PLUGIN_LOG_NOISY,
   ("nsPluginStreamListenerPeer::OnStopRequest this=%p aStatus=%d request=%p\n",
@@ -2376,17 +2227,17 @@ NS_IMETHODIMP nsPluginStreamListenerPeer
     PRUint32 magicNumber = 0;  // set it to something that is not the magic number.
     container->GetData(&magicNumber);
     if (magicNumber == MAGIC_REQUEST_CONTEXT) {
       // this is one of our range requests
       return NS_OK;
     }
   }
 
-  if(!mPStreamListener)
+  if (!mPStreamListener)
       return NS_ERROR_FAILURE;
 
   nsCOMPtr<nsIChannel> channel = do_QueryInterface(request);
   if (!channel)
     return NS_ERROR_FAILURE;
   // Set the content type to ensure we don't pass null to the plugin
   nsCAutoString aContentType;
   rv = channel->GetContentType(aContentType);
@@ -2423,63 +2274,56 @@ NS_IMETHODIMP nsPluginStreamListenerPeer
       }
     }
 
     if (localFile) {
       OnFileAvailable(localFile);
     }
   }
 
-  if (mStartBinding)
-  {
+  if (mStartBinding) {
     // On start binding has been called
     mPStreamListener->OnStopBinding(mPluginStreamInfo, aStatus);
-  }
-  else
-  {
+  } else {
     // OnStartBinding hasn't been called, so complete the action.
     mPStreamListener->OnStartBinding(mPluginStreamInfo);
     mPStreamListener->OnStopBinding(mPluginStreamInfo, aStatus);
   }
 
   if (NS_SUCCEEDED(aStatus))
     mPluginStreamInfo->SetStreamComplete(PR_TRUE);
 
   return NS_OK;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 // private methods for nsPluginStreamListenerPeer
 nsresult nsPluginStreamListenerPeer::SetUpCache(nsIURI* aURL)
 {
   nsPluginCacheListener* cacheListener = new nsPluginCacheListener(this);
   // XXX: Null LoadGroup?
   return NS_OpenURI(cacheListener, nsnull, aURL, nsnull);
 }
 
-
-////////////////////////////////////////////////////////////////////////
 nsresult nsPluginStreamListenerPeer::SetUpStreamListener(nsIRequest *request,
                                                          nsIURI* aURL)
 {
   nsresult rv = NS_OK;
 
   // If we don't yet have a stream listener, we need to get
   // one from the plugin.
   // NOTE: this should only happen when a stream was NOT created
   // with GetURL or PostURL (i.e. it's the initial stream we
   // send to the plugin as determined by the SRC or DATA attribute)
-  if(mPStreamListener == nsnull && mInstance != nsnull)
+  if (mPStreamListener == nsnull && mInstance != nsnull)
     rv = mInstance->NewStream(&mPStreamListener);
 
-  if(rv != NS_OK)
-    return rv;
-
-  if(mPStreamListener == nsnull)
+  if (rv != NS_OK)
+    return rv;
+
+  if (mPStreamListener == nsnull)
     return NS_ERROR_NULL_POINTER;
 
   PRBool useLocalCache = PR_FALSE;
 
   // get httpChannel to retrieve some info we need for nsIPluginStreamInfo setup
   nsCOMPtr<nsIChannel> channel = do_QueryInterface(request);
   nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(channel);
 
@@ -2555,18 +2399,17 @@ nsresult nsPluginStreamListenerPeer::Set
         }
       }
     }
 
     // we require a content len
     // get Last-Modified header for plugin info
     nsCAutoString lastModified;
     if (NS_SUCCEEDED(httpChannel->GetResponseHeader(NS_LITERAL_CSTRING("last-modified"), lastModified)) &&
-        !lastModified.IsEmpty())
-    {
+        !lastModified.IsEmpty()) {
       PRTime time64;
       PR_ParseTimeString(lastModified.get(), PR_TRUE, &time64);  //convert string time to integer time
 
       // Convert PRTime to unix-style time_t, i.e. seconds since the epoch
       double fpTime;
       LL_L2D(fpTime, time64);
       mPluginStreamInfo->SetLastModified((PRUint32)(fpTime * 1e-6 + 0.5));
     }
@@ -2595,18 +2438,16 @@ nsresult nsPluginStreamListenerPeer::Set
 
   if (useLocalCache) {
     SetupPluginCacheFile(channel);
   }
 
   return NS_OK;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 nsresult
 nsPluginStreamListenerPeer::OnFileAvailable(nsIFile* aFile)
 {
   nsresult rv;
   if (!mPStreamListener)
     return NS_ERROR_FAILURE;
 
   nsCAutoString path;
@@ -2617,30 +2458,26 @@ nsPluginStreamListenerPeer::OnFileAvaila
     NS_WARNING("empty path");
     return NS_OK;
   }
 
   rv = mPStreamListener->OnFileAvailable(mPluginStreamInfo, path.get());
   return rv;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP
 nsPluginStreamListenerPeer::VisitHeader(const nsACString &header, const nsACString &value)
 {
   nsCOMPtr<nsIHTTPHeaderListener> listener = do_QueryInterface(mPStreamListener);
   if (!listener)
     return NS_ERROR_FAILURE;
 
   return listener->NewResponseHeader(PromiseFlatCString(header).get(),
                                      PromiseFlatCString(value).get());
 }
-
-/////////////////////////////////////////////////////////////////////////
 
 nsPluginHostImpl::nsPluginHostImpl()
 {
   mPluginsLoaded = PR_FALSE;
   mDontShowBadPluginMessage = PR_FALSE;
   mIsDestroyed = PR_FALSE;
   mOverrideInternalTypes = PR_FALSE;
   mAllowAlienStarHandler = PR_FALSE;
@@ -2697,45 +2534,41 @@ nsPluginHostImpl::nsPluginHostImpl()
   PR_LOG(nsPluginLogging::gNPPLog, PLUGIN_LOG_ALWAYS,("NPP Logging Active!\n"));
 
   PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("nsPluginHostImpl::ctor\n"));
   PR_LogFlush();
 #endif
   mCachedPlugins = nsnull;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 nsPluginHostImpl::~nsPluginHostImpl()
 {
   PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("nsPluginHostImpl::dtor\n"));
 
   Destroy();
   sInst = nsnull;
 }
 
-////////////////////////////////////////////////////////////////////////
 NS_IMPL_ISUPPORTS8(nsPluginHostImpl,
                    nsIPluginManager,
                    nsIPluginManager2,
                    nsIPluginHost,
                    nsIFileUtilities,
                    nsICookieStorage,
                    nsIObserver,
                    nsPIPluginHost,
                    nsISupportsWeakReference)
-////////////////////////////////////////////////////////////////////////
+
 nsPluginHostImpl*
 nsPluginHostImpl::GetInst()
 {
   if (!sInst) {
     sInst = new nsPluginHostImpl();
-    if (!sInst) {
+    if (!sInst)
       return nsnull;
-    }
     NS_ADDREF(sInst);
 
     // Must call this after the refcount is already 1!
     if (NS_FAILED(sInst->AddPrefObserver())) {
       NS_RELEASE(sInst);
       return nsnull;
     }
   }
@@ -2746,74 +2579,67 @@ nsPluginHostImpl::GetInst()
 
 // static
 const char *
 nsPluginHostImpl::GetPluginName(nsIPluginInstance *aPluginInstance)
 {
   nsActivePlugin *plugin =
     gActivePluginList ? gActivePluginList->find(aPluginInstance) : nsnull;
 
-  if (plugin && plugin->mPluginTag) {
+  if (plugin && plugin->mPluginTag)
     return plugin->mPluginTag->mName.get();
-  }
-
-  return nsnull;
-}
-
-
-////////////////////////////////////////////////////////////////////////
+
+  return nsnull;
+}
+
 NS_IMETHODIMP nsPluginHostImpl::GetValue(nsPluginManagerVariable aVariable, void *aValue)
 {
   nsresult rv = NS_OK;
 
   NS_ENSURE_ARG_POINTER(aValue);
 
 #if defined(XP_UNIX) && !defined(XP_MACOSX) && defined(MOZ_X11)
   if (nsPluginManagerVariable_XDisplay == aVariable) {
     Display** value = reinterpret_cast<Display**>(aValue);
 #if defined (MOZ_WIDGET_GTK2)
     *value = GDK_DISPLAY();
 #endif
-    if (!(*value)) {
-      return NS_ERROR_FAILURE;
-    }
+    if (!(*value))
+      return NS_ERROR_FAILURE;
   }
 #endif
   if (nsPluginManagerVariable_SupportsXEmbed == aVariable) {
 #ifdef MOZ_WIDGET_GTK2
     *(NPBool*)aValue = PR_TRUE;
 #else
     *(NPBool*)aValue = PR_FALSE;
 #endif
   }
   return rv;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 PRBool nsPluginHostImpl::IsRunningPlugin(nsPluginTag * plugin)
 {
-  if(!plugin)
+  if (!plugin)
     return PR_FALSE;
 
   // we can check for mLibrary to be non-zero and then querry nsIPluginInstancePeer
   // in nsActivePluginList to see if plugin with matching mime type is not stopped
-  if(!plugin->mLibrary)
-    return PR_FALSE;
-
-  for(int i = 0; i < plugin->mVariants; i++) {
+  if (!plugin->mLibrary)
+    return PR_FALSE;
+
+  for (int i = 0; i < plugin->mVariants; i++) {
     nsActivePlugin * p = mActivePluginList.find(plugin->mMimeTypeArray[i]);
-    if(p && !p->mStopped)
+    if (p && !p->mStopped)
       return PR_TRUE;
   }
 
   return PR_FALSE;
 }
 
-////////////////////////////////////////////////////////////////////////
 nsresult nsPluginHostImpl::ReloadPlugins(PRBool reloadPages)
 {
   PLUGIN_LOG(PLUGIN_LOG_NORMAL,
   ("nsPluginHostImpl::ReloadPlugins Begin reloadPages=%d, active_instance_count=%d\n",
   reloadPages, mActivePluginList.mCount));
 
   nsresult rv = NS_OK;
 
@@ -2834,41 +2660,41 @@ nsresult nsPluginHostImpl::ReloadPlugins
   FindPlugins(PR_FALSE, &pluginschanged);
 
   // if no changed detected, return an appropriate error code
   if (!pluginschanged)
     return NS_ERROR_PLUGINS_PLUGINSNOTCHANGED;
 
   nsCOMPtr<nsISupportsArray> instsToReload;
 
-  if(reloadPages) {
+  if (reloadPages) {
     NS_NewISupportsArray(getter_AddRefs(instsToReload));
 
     // Then stop any running plugin instances but hold on to the documents in the array
     // We are going to need to restart the instances in these documents later
     mActivePluginList.stopRunning(instsToReload, nsnull);
   }
 
   // clean active plugin list
   mActivePluginList.removeAllStopped();
 
   // shutdown plugins and kill the list if there are no running plugins
   nsRefPtr<nsPluginTag> prev;
   nsRefPtr<nsPluginTag> next;
 
-  for(nsRefPtr<nsPluginTag> p = mPlugins; p != nsnull;) {
+  for (nsRefPtr<nsPluginTag> p = mPlugins; p != nsnull;) {
     next = p->mNext;
 
     // XXX only remove our plugin from the list if it's not running and not
     // an XPCOM plugin. XPCOM plugins do not get a call to nsIPlugin::Shutdown
     // if plugins are reloaded. This also fixes a crash on UNIX where the call
     // to shutdown would break the ProxyJNI connection to the JRE after a reload.
     // see bug 86591
-    if(!IsRunningPlugin(p) && (!p->mEntryPoint || p->HasFlag(NS_PLUGIN_FLAG_OLDSCHOOL))) {
-      if(p == mPlugins)
+    if (!IsRunningPlugin(p) && (!p->mEntryPoint || p->HasFlag(NS_PLUGIN_FLAG_OLDSCHOOL))) {
+      if (p == mPlugins)
         mPlugins = next;
       else
         prev->mNext = next;
 
       p->mNext = nsnull;
       p = next;
       continue;
     }
@@ -2900,54 +2726,49 @@ nsresult nsPluginHostImpl::ReloadPlugins
   ("nsPluginHostImpl::ReloadPlugins End active_instance_count=%d\n",
   mActivePluginList.mCount));
 
   return rv;
 }
 
 #define NS_RETURN_UASTRING_SIZE 128
 
-
-////////////////////////////////////////////////////////////////////////
 nsresult nsPluginHostImpl::UserAgent(const char **retstring)
 {
   static char resultString[NS_RETURN_UASTRING_SIZE];
   nsresult res;
 
   nsCOMPtr<nsIHttpProtocolHandler> http = do_GetService(NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX "http", &res);
   if (NS_FAILED(res))
     return res;
 
   nsCAutoString uaString;
   res = http->GetUserAgent(uaString);
 
-  if (NS_SUCCEEDED(res))
-  {
-    if(NS_RETURN_UASTRING_SIZE > uaString.Length())
+  if (NS_SUCCEEDED(res)) {
+    if (NS_RETURN_UASTRING_SIZE > uaString.Length()) {
       PL_strcpy(resultString, uaString.get());
-    else
-    {
+    } else {
       // Copy as much of UA string as we can (terminate at right-most space).
       PL_strncpy(resultString, uaString.get(), NS_RETURN_UASTRING_SIZE);
-      for (int i = NS_RETURN_UASTRING_SIZE - 1; i >= 0; i--)
-      {
-        if (0 == i)
+      for (int i = NS_RETURN_UASTRING_SIZE - 1; i >= 0; i--) {
+        if (i == 0) {
           resultString[NS_RETURN_UASTRING_SIZE - 1] = '\0';
-        else if (resultString[i] == ' ')
-        {
+        }
+        else if (resultString[i] == ' ') {
           resultString[i] = '\0';
           break;
         }
       }
     }
-
     *retstring = resultString;
   }
-  else
+  else {
     *retstring = nsnull;
+  }
 
   PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsPluginHostImpl::UserAgent return=%s\n", *retstring));
 
   return res;
 }
 
 nsresult nsPluginHostImpl::GetPrompt(nsIPluginInstanceOwner *aOwner, nsIPrompt **aPrompt)
 {
@@ -2970,233 +2791,202 @@ nsresult nsPluginHostImpl::GetPrompt(nsI
     }
     rv = wwatch->GetNewPrompter(domWindow, getter_AddRefs(prompt));
   }
 
   NS_IF_ADDREF(*aPrompt = prompt);
   return rv;
 }
 
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP nsPluginHostImpl::GetURL(nsISupports* pluginInst,
                      const char* url,
                      const char* target,
                      nsIPluginStreamListener* streamListener,
                      const char* altHost,
                      const char* referrer,
                      PRBool forceJSEnabled)
 {
   return GetURLWithHeaders(pluginInst, url, target, streamListener,
                            altHost, referrer, forceJSEnabled, nsnull, nsnull);
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP nsPluginHostImpl::GetURLWithHeaders(nsISupports* pluginInst,
                      const char* url,
                      const char* target,
                      nsIPluginStreamListener* streamListener,
                      const char* altHost,
                      const char* referrer,
                      PRBool forceJSEnabled,
                      PRUint32 getHeadersLength,
                      const char* getHeaders)
 {
-  nsAutoString      string; string.AssignWithConversion(url);
-  nsresult          rv;
+  nsAutoString string;
+  string.AssignWithConversion(url);
 
   // we can only send a stream back to the plugin (as specified by a
   // null target) if we also have a nsIPluginStreamListener to talk to
-  if(target == nsnull && streamListener == nsnull)
+  if (!target && !streamListener)
    return NS_ERROR_ILLEGAL_VALUE;
 
+  nsresult rv;
   nsCOMPtr<nsIPluginInstance> instance = do_QueryInterface(pluginInst, &rv);
-
   if (NS_SUCCEEDED(rv))
-  {
     rv = DoURLLoadSecurityCheck(instance, url);
-  }
-
-  if (NS_SUCCEEDED(rv))
-  {
-    if (nsnull != target)
-    {
+
+  if (NS_SUCCEEDED(rv)) {
+    if (target) {
       nsCOMPtr<nsIPluginInstancePeer> peer;
       rv = instance->GetPeer(getter_AddRefs(peer));
-      if (NS_SUCCEEDED(rv) && peer)
-      {
+      if (NS_SUCCEEDED(rv) && peer) {
         nsCOMPtr<nsPIPluginInstancePeer> privpeer(do_QueryInterface(peer));
         nsCOMPtr<nsIPluginInstanceOwner> owner;
         rv = privpeer->GetOwner(getter_AddRefs(owner));
-        if (owner)
-        {
+        if (owner) {
           if ((0 == PL_strcmp(target, "newwindow")) ||
               (0 == PL_strcmp(target, "_new")))
             target = "_blank";
           else if (0 == PL_strcmp(target, "_current"))
             target = "_self";
 
           rv = owner->GetURL(url, target, nsnull, 0, (void *) getHeaders, getHeadersLength);
         }
       }
     }
 
-    if (nsnull != streamListener)
+    if (streamListener) {
       rv = NewPluginURLStream(string, instance, streamListener, nsnull,
                               PR_FALSE, nsnull, getHeaders, getHeadersLength);
-  }
-
-  return rv;
-}
-
-
-////////////////////////////////////////////////////////////////////////
+    }
+  }
+
+  return rv;
+}
+
 NS_IMETHODIMP nsPluginHostImpl::PostURL(nsISupports* pluginInst,
                     const char* url,
                     PRUint32 postDataLen,
                     const char* postData,
                     PRBool isFile,
                     const char* target,
                     nsIPluginStreamListener* streamListener,
                     const char* altHost,
                     const char* referrer,
                     PRBool forceJSEnabled,
                     PRUint32 postHeadersLength,
                     const char* postHeaders)
 {
-  nsAutoString      string; string.AssignWithConversion(url);
-  nsresult          rv;
+  nsAutoString string; string.AssignWithConversion(url);
+  nsresult rv;
 
   // we can only send a stream back to the plugin (as specified
   // by a null target) if we also have a nsIPluginStreamListener
   // to talk to also
-  if(target == nsnull && streamListener == nsnull)
+  if (!target && !streamListener)
    return NS_ERROR_ILLEGAL_VALUE;
 
   nsCOMPtr<nsIPluginInstance> instance = do_QueryInterface(pluginInst, &rv);
-
   if (NS_SUCCEEDED(rv))
-  {
     rv = DoURLLoadSecurityCheck(instance, url);
-  }
-
-  if (NS_SUCCEEDED(rv))
-  {
-      char *dataToPost;
-      if (isFile) {
-        rv = CreateTmpFileToPost(postData, &dataToPost);
-        if (NS_FAILED(rv) || !dataToPost) return rv;
-
-      } else {
-        PRUint32 newDataToPostLen;
-        ParsePostBufferToFixHeaders(postData, postDataLen, &dataToPost, &newDataToPostLen);
-        if (!dataToPost)
-          return NS_ERROR_UNEXPECTED;
-
-        // we use nsIStringInputStream::adoptDataa()
-        // in NS_NewPluginPostDataStream to set the stream
-        // all new data alloced in  ParsePostBufferToFixHeaders()
-        // well be nsMemory::Free()d on destroy the stream
-        postDataLen = newDataToPostLen;
-      }
-
-      if (nsnull != target)
-        {
-          nsCOMPtr<nsIPluginInstancePeer> peer;
-          rv = instance->GetPeer(getter_AddRefs(peer));
-
-          if (NS_SUCCEEDED(rv) && peer)
-            {
-              nsCOMPtr<nsPIPluginInstancePeer> privpeer(do_QueryInterface(peer));
-              nsCOMPtr<nsIPluginInstanceOwner> owner;
-              rv = privpeer->GetOwner(getter_AddRefs(owner));
-              if (owner)
-                {
-                  if (!target) {
-                    target = "_self";
-                  }
-                  else {
-                    if ((0 == PL_strcmp(target, "newwindow")) ||
-                        (0 == PL_strcmp(target, "_new")))
-                      target = "_blank";
-                    else if (0 == PL_strcmp(target, "_current"))
-                      target = "_self";
-                  }
-
-                  rv = owner->GetURL(url, target, (void*)dataToPost, postDataLen,
-                                     (void*) postHeaders, postHeadersLength, isFile);
-                }
+
+  if (NS_SUCCEEDED(rv)) {
+    char *dataToPost;
+    if (isFile) {
+      rv = CreateTmpFileToPost(postData, &dataToPost);
+      if (NS_FAILED(rv) || !dataToPost)
+        return rv;
+    } else {
+      PRUint32 newDataToPostLen;
+      ParsePostBufferToFixHeaders(postData, postDataLen, &dataToPost, &newDataToPostLen);
+      if (!dataToPost)
+        return NS_ERROR_UNEXPECTED;
+
+      // we use nsIStringInputStream::adoptDataa()
+      // in NS_NewPluginPostDataStream to set the stream
+      // all new data alloced in  ParsePostBufferToFixHeaders()
+      // well be nsMemory::Free()d on destroy the stream
+      postDataLen = newDataToPostLen;
+    }
+
+    if (target) {
+      nsCOMPtr<nsIPluginInstancePeer> peer;
+      rv = instance->GetPeer(getter_AddRefs(peer));
+      if (NS_SUCCEEDED(rv) && peer) {
+        nsCOMPtr<nsPIPluginInstancePeer> privpeer(do_QueryInterface(peer));
+        nsCOMPtr<nsIPluginInstanceOwner> owner;
+        rv = privpeer->GetOwner(getter_AddRefs(owner));
+        if (owner) {
+          if (!target) {
+            target = "_self";
+          }
+          else {
+            if ((0 == PL_strcmp(target, "newwindow")) ||
+                (0 == PL_strcmp(target, "_new"))) {
+              target = "_blank";
             }
-        }
-
-      // if we don't have a target, just create a stream.  This does
-      // NS_OpenURI()!
-      if (streamListener != nsnull)
-        rv = NewPluginURLStream(string, instance, streamListener,
-                                (const char*)dataToPost, isFile, postDataLen,
-                                postHeaders, postHeadersLength);
-      if (isFile) {
-        NS_Free(dataToPost);
-      }
-  }
-
-  return rv;
-}
-
-
-////////////////////////////////////////////////////////////////////////
+            else if (0 == PL_strcmp(target, "_current")) {
+              target = "_self";
+            }
+          }
+          rv = owner->GetURL(url, target, (void*)dataToPost, postDataLen,
+                             (void*)postHeaders, postHeadersLength, isFile);
+        }
+      }
+    }
+
+    // if we don't have a target, just create a stream.  This does
+    // NS_OpenURI()!
+    if (streamListener)
+      rv = NewPluginURLStream(string, instance, streamListener,
+                              (const char*)dataToPost, isFile, postDataLen,
+                              postHeaders, postHeadersLength);
+    if (isFile)
+      NS_Free(dataToPost);
+  }
+
+  return rv;
+}
+
 NS_IMETHODIMP nsPluginHostImpl::RegisterPlugin(REFNSIID aCID,
                                                const char* aPluginName,
                                                const char* aDescription,
                                                const char** aMimeTypes,
                                                const char** aMimeDescriptions,
                                                const char** aFileExtensions,
                                                PRInt32 aCount)
 {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP nsPluginHostImpl::UnregisterPlugin(REFNSIID aCID)
 {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP nsPluginHostImpl::BeginWaitCursor(void)
 {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP nsPluginHostImpl::EndWaitCursor(void)
 {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP nsPluginHostImpl::SupportsURLProtocol(const char* protocol, PRBool *result)
 {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP nsPluginHostImpl::NotifyStatusChange(nsIPlugin* plugin, nsresult errorStatus)
 {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 
-/*////////////////////////////////////////////////////////////////////////
- * This method queries the prefs for proxy information.
+/* This method queries the prefs for proxy information.
  * It has been tested and is known to work in the following three cases
  * when no proxy host or port is specified
  * when only the proxy host is specified
  * when only the proxy port is specified
  * This method conforms to the return code specified in
  * http://developer.netscape.com/docs/manuals/proxy/adminnt/autoconf.htm#1020923
  * with the exception that multiple values are not implemented.
  */
@@ -3208,37 +2998,33 @@ NS_IMETHODIMP nsPluginHostImpl::FindProx
   }
   nsresult res;
 
   nsCOMPtr<nsIURI> uriIn;
   nsCOMPtr<nsIProtocolProxyService> proxyService;
   nsCOMPtr<nsIIOService> ioService;
 
   proxyService = do_GetService(NS_PROTOCOLPROXYSERVICE_CONTRACTID, &res);
-  if (NS_FAILED(res) || !proxyService) {
+  if (NS_FAILED(res) || !proxyService)
     return res;
-  }
 
   ioService = do_GetService(NS_IOSERVICE_CONTRACTID, &res);
-  if (NS_FAILED(res) || !ioService) {
+  if (NS_FAILED(res) || !ioService)
     return res;
-  }
 
   // make an nsURI from the argument url
   res = ioService->NewURI(nsDependentCString(url), nsnull, nsnull, getter_AddRefs(uriIn));
-  if (NS_FAILED(res)) {
+  if (NS_FAILED(res))
     return res;
-  }
 
   nsCOMPtr<nsIProxyInfo> pi;
 
   res = proxyService->Resolve(uriIn, 0, getter_AddRefs(pi));
-  if (NS_FAILED(res)) {
+  if (NS_FAILED(res))
     return res;
-  }
 
   nsCAutoString host, type;
   PRInt32 port = -1;
 
   // These won't fail, and even if they do... we'll be ok.
   if (pi) {
     pi->GetType(type);
     pi->GetHost(host);
@@ -3258,153 +3044,125 @@ NS_IMETHODIMP nsPluginHostImpl::FindProx
     // For a long time this was returning an http proxy type, so
     // very little is probably broken by this
     *result = PR_smprintf("SOCKS %s:%d", host.get(), port);
   } else {
     NS_ASSERTION(PR_FALSE, "Unknown proxy type!");
     *result = PL_strdup("DIRECT");
   }
 
-  if (nsnull == *result) {
+  if (nsnull == *result)
     res = NS_ERROR_OUT_OF_MEMORY;
-  }
 
   return res;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP nsPluginHostImpl::RegisterWindow(nsIEventHandler* handler, nsPluginPlatformWindowRef window)
 {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP nsPluginHostImpl::UnregisterWindow(nsIEventHandler* handler, nsPluginPlatformWindowRef window)
 {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP nsPluginHostImpl::AllocateMenuID(nsIEventHandler* handler, PRBool isSubmenu, PRInt16 *result)
 {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP nsPluginHostImpl::DeallocateMenuID(nsIEventHandler* handler, PRInt16 menuID)
 {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP nsPluginHostImpl::HasAllocatedMenuID(nsIEventHandler* handler, PRInt16 menuID, PRBool *result)
 {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP nsPluginHostImpl::ProcessNextEvent(PRBool *bEventHandled)
 {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP nsPluginHostImpl::CreateInstance(nsISupports *aOuter,
                                                REFNSIID aIID,
                                                void **aResult)
 {
   NS_NOTREACHED("how'd I get here?");
   return NS_ERROR_UNEXPECTED;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP nsPluginHostImpl::LockFactory(PRBool aLock)
 {
   NS_NOTREACHED("how'd I get here?");
   return NS_ERROR_UNEXPECTED;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP nsPluginHostImpl::Init(void)
 {
   return NS_OK;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP nsPluginHostImpl::Destroy(void)
 {
   PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsPluginHostImpl::Destroy Called\n"));
 
   if (mIsDestroyed)
     return NS_OK;
 
   mIsDestroyed = PR_TRUE;
 
   // we should call nsIPluginInstance::Stop and nsIPluginInstance::SetWindow
   // for those plugins who want it
   mActivePluginList.stopRunning(nsnull, nsnull);
 
   // at this point nsIPlugin::Shutdown calls will be performed if needed
   mActivePluginList.shut();
 
-  if (nsnull != mPluginPath)
-  {
+  if (mPluginPath) {
     PR_Free(mPluginPath);
     mPluginPath = nsnull;
   }
 
-  while (nsnull != mPlugins)
-  {
+  while (mPlugins) {
     nsRefPtr<nsPluginTag> temp = mPlugins->mNext;
-
     // while walking through the list of the plugins see if we still have anything
     // to shutdown some plugins may have never created an instance but still expect
     // the shutdown call see bugzilla bug 73071
     // with current logic, no need to do anything special as nsIPlugin::Shutdown
     // will be performed in the destructor
-
     mPlugins->mNext = nsnull;
     mPlugins = temp;
   }
 
   // Delete any remaining cached plugins list
   mCachedPlugins = nsnull;
 
   // Lets remove any of the temporary files that we created.
   if (sPluginTempDir) {
     sPluginTempDir->Remove(PR_TRUE);
-
     NS_RELEASE(sPluginTempDir);
   }
 
 #ifdef XP_WIN
-  if (mPrivateDirServiceProvider)
-  {
+  if (mPrivateDirServiceProvider) {
     nsCOMPtr<nsIDirectoryService> dirService =
       do_GetService(kDirectoryServiceContractID);
     if (dirService)
       dirService->UnregisterProvider(mPrivateDirServiceProvider);
     mPrivateDirServiceProvider = nsnull;
   }
 #endif /* XP_WIN */
 
   nsCOMPtr<nsIPrefBranch2> prefBranch(do_QueryInterface(mPrefService));
-  if (prefBranch) {
+  if (prefBranch)
     prefBranch->RemoveObserver("security.enable_java", this);
-  }
   mPrefService = nsnull; // release prefs service to avoid leaks!
 
   return NS_OK;
 }
 
 void nsPluginHostImpl::UnloadUnusedLibraries()
 {
   // unload any remaining plugin libraries from memory
@@ -3462,52 +3220,50 @@ NS_IMETHODIMP nsPluginHostImpl::Instanti
 #endif
 
   // XXX do we need to look for stopped plugins, like InstantiateEmbeddedPlugin
   // does?
 
   return NewEmbeddedPluginStreamListener(uri, aOwner, nsnull, aListener);
 }
 
-////////////////////////////////////////////////////////////////////////
-/* Called by nsPluginInstanceOwner (nsObjectFrame.cpp - embedded case) */
+// Called by nsPluginInstanceOwner (nsObjectFrame.cpp - embedded case)
 NS_IMETHODIMP nsPluginHostImpl::InstantiateEmbeddedPlugin(const char *aMimeType,
                                                          nsIURI* aURL,
                                                          nsIPluginInstanceOwner *aOwner)
 {
   NS_ENSURE_ARG_POINTER(aOwner);
 
 #ifdef PLUGIN_LOGGING
   nsCAutoString urlSpec;
-  if(aURL != nsnull) (void)aURL->GetAsciiSpec(urlSpec);
+  if (aURL)
+    aURL->GetAsciiSpec(urlSpec);
 
   PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_NORMAL,
         ("nsPluginHostImpl::InstantiateEmbeddedPlugin Begin mime=%s, owner=%p, url=%s\n",
         aMimeType, aOwner, urlSpec.get()));
 
   PR_LogFlush();
 #endif
 
   nsresult  rv;
   nsIPluginInstance *instance = nsnull;
   nsCOMPtr<nsIPluginTagInfo2> pti2;
   nsPluginTagType tagType;
 
   rv = aOwner->QueryInterface(kIPluginTagInfo2IID, getter_AddRefs(pti2));
 
-  if(rv != NS_OK) {
-    return rv;
-  }
+  if (rv != NS_OK)
+    return rv;
 
   rv = pti2->GetTagType(&tagType);
 
-  if((rv != NS_OK) || !((tagType == nsPluginTagType_Embed)
+  if ((rv != NS_OK) || !((tagType == nsPluginTagType_Embed)
                         || (tagType == nsPluginTagType_Applet)
-                        || (tagType == nsPluginTagType_Object)))
-  {
+                        || (tagType == nsPluginTagType_Object))) {
     return rv;
   }
 
   // Security checks
   // Can't do security checks without a URI - hopefully the plugin will take
   // care of that
   if (aURL) {
     nsCOMPtr<nsIScriptSecurityManager> secMan =
@@ -3539,19 +3295,18 @@ NS_IMETHODIMP nsPluginHostImpl::Instanti
     if (NS_FAILED(rv) || NS_CP_REJECTED(shouldLoad))
       return NS_ERROR_CONTENT_BLOCKED_SHOW_ALT;
   }
 
   // Look for even disabled plugins, because if the plugin for this type is
   // disabled, we don't want to go on and end up in SetUpDefaultPluginInstance.
   nsPluginTag* pluginTag = FindPluginForType(aMimeType, PR_FALSE);
   if (pluginTag) {
-    if (!pluginTag->IsEnabled()) {
+    if (!pluginTag->IsEnabled())
       return NS_ERROR_NOT_AVAILABLE;
-    }
   } else if (!mJavaEnabled && IsJavaMIMEType(aMimeType)) {
     // Even if we had no Java plugin, if mJavaEnabled is false we should throw
     // here for Java types.  Note that we only need to do this for the case
     // when pluginTag is null; if we had a pluginTag, it would have its
     // NS_PLUGIN_FLAG_ENABLED set the right way.
     return NS_ERROR_NOT_AVAILABLE;
   }
     
@@ -3566,23 +3321,23 @@ NS_IMETHODIMP nsPluginHostImpl::Instanti
       nsCAutoString contractID(NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX);
       contractID += scheme;
       ToLowerCase(contractID);
       nsCOMPtr<nsIProtocolHandler> handler = do_GetService(contractID.get());
       if (handler)
         bCanHandleInternally = PR_TRUE;
   }
 
-  if(FindStoppedPluginForURL(aURL, aOwner) == NS_OK) {
+  if (FindStoppedPluginForURL(aURL, aOwner) == NS_OK) {
 
     PLUGIN_LOG(PLUGIN_LOG_NOISY,
     ("nsPluginHostImpl::InstantiateEmbeddedPlugin FoundStopped mime=%s\n", aMimeType));
 
     aOwner->GetInstance(instance);
-    if(!isJava && bCanHandleInternally)
+    if (!isJava && bCanHandleInternally)
       rv = NewEmbeddedPluginStream(aURL, aOwner, instance);
 
     // notify Java DOM component
     nsresult res;
     nsCOMPtr<nsIPluginInstanceOwner> javaDOM =
              do_GetService("@mozilla.org/blackwood/java-dom;1", &res);
     if (NS_SUCCEEDED(res) && javaDOM)
       javaDOM->SetInstance(instance);
@@ -3593,155 +3348,147 @@ NS_IMETHODIMP nsPluginHostImpl::Instanti
 
   // if we don't have a MIME type at this point, we still have one more chance by
   // opening the stream and seeing if the server hands one back
   if (!aMimeType)
     return bCanHandleInternally ? NewEmbeddedPluginStream(aURL, aOwner, nsnull) : NS_ERROR_FAILURE;
 
   rv = SetUpPluginInstance(aMimeType, aURL, aOwner);
 
-  if(rv == NS_OK)
+  if (rv == NS_OK) {
     rv = aOwner->GetInstance(instance);
-  else
-  {
-   /*
-    * If we are here, it's time to either show the default plugin
+  } else {
+   /* If we are here, it's time to either show the default plugin
     * or return failure so layout will replace us.
     *
     * Currently, the default plugin is shown for all EMBED and APPLET
     * tags and also any OBJECT tag that has a PLUGINURL PARAM tag name.
     */
 
     PRBool bHasPluginURL = PR_FALSE;
     nsCOMPtr<nsIPluginTagInfo2> pti2(do_QueryInterface(aOwner));
 
-    if(pti2) {
+    if (pti2) {
       const char *value;
       bHasPluginURL = NS_SUCCEEDED(pti2->GetParameter("PLUGINURL", &value));
     }
 
     // if we didn't find a pluginURL param on the object tag,
     // there's nothing more to do here
-    if(nsPluginTagType_Object == tagType && !bHasPluginURL)
-      return rv;
-
-    if(NS_FAILED(SetUpDefaultPluginInstance(aMimeType, aURL, aOwner)))
-      return NS_ERROR_FAILURE;
-
-    if(NS_FAILED(aOwner->GetInstance(instance)))
+    if (nsPluginTagType_Object == tagType && !bHasPluginURL)
+      return rv;
+
+    if (NS_FAILED(SetUpDefaultPluginInstance(aMimeType, aURL, aOwner)))
+      return NS_ERROR_FAILURE;
+
+    if (NS_FAILED(aOwner->GetInstance(instance)))
       return NS_ERROR_FAILURE;
 
     rv = NS_OK;
   }
 
   // if we have a failure error, it means we found a plugin for the mimetype,
   // but we had a problem with the entry point
-  if(rv == NS_ERROR_FAILURE)
+  if (rv == NS_ERROR_FAILURE)
     return rv;
 
   // if we are here then we have loaded a plugin for this mimetype
   // and it could be the Default plugin
 
   nsPluginWindow    *window = nsnull;
 
   //we got a plugin built, now stream
   aOwner->GetWindow(window);
 
-  if (nsnull != instance)
-  {
+  if (instance) {
     instance->Start();
     aOwner->CreateWidget();
 
     // If we've got a native window, the let the plugin know about it.
-    if (window->window)
-    {
+    if (window->window) {
       nsCOMPtr<nsIPluginInstance> inst = instance;
       ((nsPluginNativeWindow*)window)->CallSetWindow(inst);
     }
 
     // create an initial stream with data
     // don't make the stream if it's a java applet or we don't have SRC or DATA attribute
     PRBool havedata = PR_FALSE;
 
     nsCOMPtr<nsIPluginTagInfo> pti(do_QueryInterface(aOwner, &rv));
 
-    if(pti) {
+    if (pti) {
       const char *value;
       havedata = NS_SUCCEEDED(pti->GetAttribute("SRC", &value));
       // no need to check for "data" as it would have been converted to "src"
     }
 
-    if(havedata && !isJava && bCanHandleInternally)
+    if (havedata && !isJava && bCanHandleInternally)
       rv = NewEmbeddedPluginStream(aURL, aOwner, instance);
 
     // notify Java DOM component
     nsresult res;
     nsCOMPtr<nsIPluginInstanceOwner> javaDOM =
              do_GetService("@mozilla.org/blackwood/java-dom;1", &res);
     if (NS_SUCCEEDED(res) && javaDOM)
       javaDOM->SetInstance(instance);
 
     NS_RELEASE(instance);
   }
 
 #ifdef PLUGIN_LOGGING
   nsCAutoString urlSpec2;
-  if(aURL != nsnull) (void)aURL->GetAsciiSpec(urlSpec2);
+  if (aURL != nsnull) (void)aURL->GetAsciiSpec(urlSpec2);
 
   PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_NORMAL,
         ("nsPluginHostImpl::InstantiateEmbeddedPlugin Finished mime=%s, rv=%d, owner=%p, url=%s\n",
         aMimeType, rv, aOwner, urlSpec2.get()));
 
   PR_LogFlush();
 #endif
 
   return rv;
 }
 
-
-////////////////////////////////////////////////////////////////////////
-/* Called by full-page case */
+// Called by full-page case
 NS_IMETHODIMP nsPluginHostImpl::InstantiateFullPagePlugin(const char *aMimeType,
                                                           nsIURI* aURI,
                                                           nsIStreamListener *&aStreamListener,
                                                           nsIPluginInstanceOwner *aOwner)
 {
 #ifdef PLUGIN_LOGGING
   nsCAutoString urlSpec;
   aURI->GetSpec(urlSpec);
   PLUGIN_LOG(PLUGIN_LOG_NORMAL,
   ("nsPluginHostImpl::InstantiateFullPagePlugin Begin mime=%s, owner=%p, url=%s\n",
   aMimeType, aOwner, urlSpec.get()));
 #endif
 
-  if(FindStoppedPluginForURL(aURI, aOwner) == NS_OK) {
+  if (FindStoppedPluginForURL(aURI, aOwner) == NS_OK) {
     PLUGIN_LOG(PLUGIN_LOG_NOISY,
     ("nsPluginHostImpl::InstantiateFullPagePlugin FoundStopped mime=%s\n",aMimeType));
 
     nsIPluginInstance* instance;
     aOwner->GetInstance(instance);
     nsPluginTag* pluginTag = FindPluginForType(aMimeType, PR_TRUE);
-    if(!pluginTag || !pluginTag->mIsJavaPlugin)
+    if (!pluginTag || !pluginTag->mIsJavaPlugin)
       NewFullPagePluginStream(aStreamListener, instance);
     NS_IF_RELEASE(instance);
     return NS_OK;
   }
 
   nsresult rv = SetUpPluginInstance(aMimeType, aURI, aOwner);
 
-  if (NS_OK == rv)
-  {
+  if (NS_OK == rv) {
     nsCOMPtr<nsIPluginInstance> instance;
     nsPluginWindow * win = nsnull;
 
     aOwner->GetInstance(*getter_AddRefs(instance));
     aOwner->GetWindow(win);
 
-    if (win && instance)
-    {
+    if (win && instance) {
       instance->Start();
       aOwner->CreateWidget();
 
       // If we've got a native window, the let the plugin know about it.
       nsPluginNativeWindow * window = (nsPluginNativeWindow *)win;
       if (window->window)
         window->CallSetWindow(instance);
 
@@ -3755,59 +3502,53 @@ NS_IMETHODIMP nsPluginHostImpl::Instanti
 
   PLUGIN_LOG(PLUGIN_LOG_NORMAL,
   ("nsPluginHostImpl::InstantiateFullPagePlugin End mime=%s, rv=%d, owner=%p, url=%s\n",
   aMimeType, rv, aOwner, urlSpec.get()));
 
   return rv;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 nsresult nsPluginHostImpl::FindStoppedPluginForURL(nsIURI* aURL,
                                                    nsIPluginInstanceOwner *aOwner)
 {
   nsCAutoString url;
-  if(!aURL)
-    return NS_ERROR_FAILURE;
-
-  (void)aURL->GetAsciiSpec(url);
+  if (!aURL)
+    return NS_ERROR_FAILURE;
+
+  aURL->GetAsciiSpec(url);
 
   nsActivePlugin * plugin = mActivePluginList.findStopped(url.get());
 
-  if((plugin != nsnull) && (plugin->mStopped))
-  {
+  if (plugin && plugin->mStopped) {
     nsIPluginInstance* instance = plugin->mInstance;
     nsPluginWindow    *window = nsnull;
     aOwner->GetWindow(window);
 
     aOwner->SetInstance(instance);
 
     // we have to reset the owner and instance in the plugin instance peer
     //instance->GetPeer(&peer);
     ((nsPluginInstancePeerImpl*)plugin->mPeer)->SetOwner(aOwner);
 
     instance->Start();
     aOwner->CreateWidget();
 
     // If we've got a native window, the let the plugin know about it.
-    if (window->window)
-    {
+    if (window->window) {
       nsCOMPtr<nsIPluginInstance> inst = instance;
       ((nsPluginNativeWindow*)window)->CallSetWindow(inst);
     }
 
     plugin->setStopped(PR_FALSE);
     return NS_OK;
   }
   return NS_ERROR_FAILURE;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 nsresult nsPluginHostImpl::AddInstanceToActiveList(nsCOMPtr<nsIPlugin> aPlugin,
                                                nsIPluginInstance* aInstance,
                                                nsIURI* aURL,
                                                PRBool aDefaultPlugin,
                                                nsIPluginInstancePeer* peer)
 
 {
   nsCAutoString url;
@@ -3817,35 +3558,33 @@ nsresult nsPluginHostImpl::AddInstanceTo
     aURL->GetSpec(url);
 
   // let's find the corresponding plugin tag by matching nsIPlugin pointer
   // it's legal for XPCOM plugins not to have nsIPlugin implemented but
   // this is OK, we don't need the plugin tag for XPCOM plugins. It is going
   // to be used later when we decide whether or not we should delay unloading
   // NPAPI dll from memory, and XPCOM dlls will stay in memory anyway.
   nsPluginTag * pluginTag = nsnull;
-  if(aPlugin) {
-    for(pluginTag = mPlugins; pluginTag != nsnull; pluginTag = pluginTag->mNext) {
-      if(pluginTag->mEntryPoint == aPlugin)
+  if (aPlugin) {
+    for (pluginTag = mPlugins; pluginTag != nsnull; pluginTag = pluginTag->mNext) {
+      if (pluginTag->mEntryPoint == aPlugin)
         break;
     }
     NS_ASSERTION(pluginTag, "Plugin tag not found");
   }
 
   nsActivePlugin * plugin = new nsActivePlugin(pluginTag, aInstance, url.get(), aDefaultPlugin, peer);
 
-  if(!plugin)
+  if (!plugin)
     return NS_ERROR_OUT_OF_MEMORY;
 
   mActivePluginList.add(plugin);
   return NS_OK;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 void
 nsPluginTag::RegisterWithCategoryManager(PRBool aOverrideInternalTypes,
                                          nsPluginTag::nsRegisterType aType)
 {
   if (!mMimeTypeArray)
     return;
 
   PLUGIN_LOG(PLUGIN_LOG_NORMAL,
@@ -3872,17 +3611,17 @@ nsPluginTag::RegisterWithCategoryManager
   nsXPIDLCString overrideTypes;
   psvc->GetCharPref("plugin.disable_full_page_plugin_for_types", getter_Copies(overrideTypes));
   nsCAutoString overrideTypesFormatted;
   overrideTypesFormatted.Assign(',');
   overrideTypesFormatted += overrideTypes;
   overrideTypesFormatted.Append(',');
 
   nsACString::const_iterator start, end;
-  for(int i = 0; i < mVariants; i++) {
+  for (int i = 0; i < mVariants; i++) {
     if (aType == ePluginUnregister) {
       nsXPIDLCString value;
       if (NS_SUCCEEDED(catMan->GetCategoryEntry("Gecko-Content-Viewers",
                                                 mMimeTypeArray[i],
                                                 getter_Copies(value)))) {
         // Only delete the entry if a plugin registered for it
         if (strcmp(value, contractId) == 0) {
           catMan->DeleteCategoryEntry("Gecko-Content-Viewers",
@@ -3910,18 +3649,16 @@ nsPluginTag::RegisterWithCategoryManager
     }
 
     PLUGIN_LOG(PLUGIN_LOG_NOISY,
     ("nsPluginTag::RegisterWithCategoryManager mime=%s, plugin=%s\n",
     mMimeTypeArray[i], mFileName.get()));
   }
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP nsPluginHostImpl::SetUpPluginInstance(const char *aMimeType,
                                                     nsIURI *aURL,
                                                     nsIPluginInstanceOwner *aOwner)
 {
   nsresult rv = NS_OK;
 
   rv = TrySetUpPluginInstance(aMimeType, aURL, aOwner);
 
@@ -3956,17 +3693,17 @@ NS_IMETHODIMP nsPluginHostImpl::SetUpPlu
 
 NS_IMETHODIMP
 nsPluginHostImpl::TrySetUpPluginInstance(const char *aMimeType,
                                          nsIURI *aURL,
                                          nsIPluginInstanceOwner *aOwner)
 {
 #ifdef PLUGIN_LOGGING
   nsCAutoString urlSpec;
-  if(aURL != nsnull) (void)aURL->GetSpec(urlSpec);
+  if (aURL != nsnull) (void)aURL->GetSpec(urlSpec);
 
   PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_NORMAL,
         ("nsPluginHostImpl::TrySetupPluginInstance Begin mime=%s, owner=%p, url=%s\n",
         aMimeType, aOwner, urlSpec.get()));
 
   PR_LogFlush();
 #endif
 
@@ -4063,17 +3800,17 @@ nsPluginHostImpl::TrySetUpPluginInstance
 
   GetPluginFactory(mimetype, getter_AddRefs(plugin));
 
   instance = do_CreateInstance(contractID.get(), &result);
 
   // couldn't create an XPCOM plugin, try to create wrapper for a
   // legacy plugin
   if (NS_FAILED(result)) {
-    if(plugin) {
+    if (plugin) {
 #ifdef XP_WIN
       static BOOL firstJavaPlugin = FALSE;
       BOOL restoreOrigDir = FALSE;
       char origDir[_MAX_PATH];
       if (isJavaPlugin && !firstJavaPlugin) {
         DWORD dw = ::GetCurrentDirectory(_MAX_PATH, origDir);
         NS_ASSERTION(dw <= _MAX_PATH, "Falied to obtain the current directory, which may leads to incorrect class laoding");
         nsCOMPtr<nsIFile> binDirectory;
@@ -4121,18 +3858,18 @@ nsPluginHostImpl::TrySetUpPluginInstance
   nsRefPtr<nsPluginInstancePeerImpl> peer = new nsPluginInstancePeerImpl();
   if (!peer)
     return NS_ERROR_OUT_OF_MEMORY;
 
   // set up the peer for the instance
   peer->Initialize(aOwner, mimetype);
 
   result = instance->Initialize(peer);  // this should addref the peer but not the instance or owner
-  if (NS_FAILED(result))                 // except in some cases not Java, see bug 140931
-    return result;       // our COM pointer will free the peer
+  if (NS_FAILED(result))                // except in some cases not Java, see bug 140931
+    return result;                      // our COM pointer will free the peer
 
   // instance and peer will be addreffed here
   result = AddInstanceToActiveList(plugin, instance, aURL, PR_FALSE, peer);
 
 #ifdef PLUGIN_LOGGING
   nsCAutoString urlSpec2;
   if (aURL)
     aURL->GetSpec(urlSpec2);
@@ -4142,73 +3879,68 @@ nsPluginHostImpl::TrySetUpPluginInstance
         aMimeType, result, aOwner, urlSpec2.get()));
 
   PR_LogFlush();
 #endif
 
   return result;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 nsresult
 nsPluginHostImpl::SetUpDefaultPluginInstance(const char *aMimeType,
                                              nsIURI *aURL,
                                              nsIPluginInstanceOwner *aOwner)
 {
   if (mDefaultPluginDisabled) {
     // The default plugin is disabled, don't load it.
 
     return NS_OK;
   }
 
   nsCOMPtr<nsIPluginInstance> instance;
   nsCOMPtr<nsIPlugin> plugin = NULL;
   const char* mimetype = aMimeType;
 
-  if(!aURL)
+  if (!aURL)
     return NS_ERROR_FAILURE;
 
   GetPluginFactory("*", getter_AddRefs(plugin));
 
   nsresult result;
   instance = do_CreateInstance(NS_INLINE_PLUGIN_CONTRACTID_PREFIX "*",
                                &result);
 
   // couldn't create an XPCOM plugin, try to create wrapper for a
   // legacy plugin
-  if (NS_FAILED(result))
-  {
-    if(plugin)
+  if (NS_FAILED(result)) {
+    if (plugin)
       result = plugin->CreateInstance(NULL, kIPluginInstanceIID,
                                       getter_AddRefs(instance));
   }
 
   // neither an XPCOM or legacy plugin could be instantiated, so
   // return the failure
-  if(NS_FAILED(result))
+  if (NS_FAILED(result))
     return result;
 
   // it is adreffed here
   aOwner->SetInstance(instance);
 
   nsRefPtr<nsPluginInstancePeerImpl> peer = new nsPluginInstancePeerImpl();
   if (!peer)
     return NS_ERROR_OUT_OF_MEMORY;
 
   // if we don't have a mimetype, check by file extension
   nsXPIDLCString mt;
-  if (!mimetype || !*mimetype)
-  {
+  if (!mimetype || !*mimetype) {
     nsresult res = NS_OK;
     nsCOMPtr<nsIMIMEService> ms (do_GetService(NS_MIMESERVICE_CONTRACTID, &res));
-    if(NS_SUCCEEDED(res))
-    {
+    if (NS_SUCCEEDED(res)) {
       res = ms->GetTypeFromURI(aURL, mt);
-      if(NS_SUCCEEDED(res))
+      if (NS_SUCCEEDED(res))
         mimetype = mt.get();
     }
   }
 
   // set up the peer for the instance
   peer->Initialize(aOwner, mimetype);
 
   // this should addref the peer but not the instance or owner except
@@ -4219,80 +3951,67 @@ nsPluginHostImpl::SetUpDefaultPluginInst
     return result;
 
   // instance and peer will be addreffed here
   result = AddInstanceToActiveList(plugin, instance, aURL, PR_TRUE, peer);
 
   return result;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP
 nsPluginHostImpl::IsPluginEnabledForType(const char* aMimeType)
 {
   // Pass PR_FALSE as the second arg so we can return NS_ERROR_PLUGIN_DISABLED
   // for disabled plug-ins.
   nsPluginTag *plugin = FindPluginForType(aMimeType, PR_FALSE);
-  if (!plugin) {
-    return NS_ERROR_FAILURE;
-  }
+  if (!plugin)
+    return NS_ERROR_FAILURE;
 
   if (!plugin->IsEnabled()) {
     if (plugin->HasFlag(NS_PLUGIN_FLAG_BLOCKLISTED))
       return NS_ERROR_PLUGIN_BLOCKLISTED;
     else
       return NS_ERROR_PLUGIN_DISABLED;
   }
 
   return NS_OK;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 // check comma delimitered extensions
 static int CompareExtensions(const char *aExtensionList, const char *aExtension)
 {
-  if((aExtensionList == nsnull) || (aExtension == nsnull))
+  if (!aExtensionList || !aExtension)
     return -1;
 
   const char *pExt = aExtensionList;
   const char *pComma = strchr(pExt, ',');
-
-  if(pComma == nsnull)
+  if (!pComma)
     return PL_strcasecmp(pExt, aExtension);
 
   int extlen = strlen(aExtension);
-  while(pComma != nsnull)
-  {
+  while (pComma) {
     int length = pComma - pExt;
-    if(length == extlen && 0 == PL_strncasecmp(aExtension, pExt, length))
+    if (length == extlen && 0 == PL_strncasecmp(aExtension, pExt, length))
       return 0;
-
     pComma++;
     pExt = pComma;
     pComma = strchr(pExt, ',');
   }
 
   // the last one
   return PL_strcasecmp(pExt, aExtension);
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP
 nsPluginHostImpl::IsPluginEnabledForExtension(const char* aExtension,
                                               const char* &aMimeType)
 {
   nsPluginTag *plugin = FindPluginEnabledForExtension(aExtension, aMimeType);
   return plugin ? NS_OK : NS_ERROR_FAILURE;
 }
-
-
-////////////////////////////////////////////////////////////////////////
 
 class DOMMimeTypeImpl : public nsIDOMMimeType {
 public:
   NS_DECL_ISUPPORTS
 
   DOMMimeTypeImpl(nsPluginTag* aTag, PRUint32 aMimeTypeIndex)
   {
     if (!aTag)
@@ -4333,20 +4052,18 @@ public:
   }
 
 private:
   nsString mDescription;
   nsString mSuffixes;
   nsString mType;
 };
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMPL_ISUPPORTS1(DOMMimeTypeImpl, nsIDOMMimeType)
-////////////////////////////////////////////////////////////////////////
+
 class DOMPluginImpl : public nsIDOMPlugin {
 public:
   NS_DECL_ISUPPORTS
 
   DOMPluginImpl(nsPluginTag* aPluginTag) : mPluginTag(aPluginTag)
   {
   }
 
@@ -4360,38 +4077,34 @@ public:
   }
 
   NS_METHOD GetFilename(nsAString& aFilename)
   {
     PRBool bShowPath;
     nsCOMPtr<nsIPrefBranch> prefService = do_GetService(NS_PREFSERVICE_CONTRACTID);
     if (prefService &&
         NS_SUCCEEDED(prefService->GetBoolPref("plugin.expose_full_path",&bShowPath)) &&
-        bShowPath)
-    {
+        bShowPath) {
       // only show the full path if people have set the pref,
       // the default should not reveal path information (bug 88183)
 #if defined(XP_MACOSX)
       CopyUTF8toUTF16(mPluginTag.mFullPath, aFilename);
 #else
       CopyUTF8toUTF16(mPluginTag.mFileName, aFilename);
 #endif
       return NS_OK;
     }
 
     nsAutoString spec;
-    if (!mPluginTag.mFullPath.IsEmpty())
-    {
+    if (!mPluginTag.mFullPath.IsEmpty()) {
 #if !defined(XP_MACOSX)
       NS_ERROR("Only MAC should be using nsPluginTag::mFullPath!");
 #endif
       CopyUTF8toUTF16(mPluginTag.mFullPath, spec);
-    }
-    else
-    {
+    } else {
       CopyUTF8toUTF16(mPluginTag.mFileName, spec);
     }
 
     nsCString leafName;
     nsCOMPtr<nsILocalFile> pluginPath;
     NS_NewLocalFile(spec, PR_TRUE, getter_AddRefs(pluginPath));
 
     return pluginPath->GetLeafName(aFilename);
@@ -4425,20 +4138,17 @@ public:
     }
     return NS_OK;
   }
 
 private:
   nsPluginTag mPluginTag;
 };
 
-////////////////////////////////////////////////////////////////////////
 NS_IMPL_ISUPPORTS1(DOMPluginImpl, nsIDOMPlugin)
-////////////////////////////////////////////////////////////////////////
-
 
 NS_IMETHODIMP
 nsPluginHostImpl::GetPluginCount(PRUint32* aPluginCount)
 {
   LoadPlugins();
 
   PRUint32 count = 0;
 
@@ -4450,18 +4160,16 @@ nsPluginHostImpl::GetPluginCount(PRUint3
     plugin = plugin->mNext;
   }
 
   *aPluginCount = count;
 
   return NS_OK;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP
 nsPluginHostImpl::GetPlugins(PRUint32 aPluginCount, nsIDOMPlugin** aPluginArray)
 {
   LoadPlugins();
 
   nsPluginTag* plugin = mPlugins;
   for (PRUint32 i = 0; i < aPluginCount && plugin; plugin = plugin->mNext) {
     if (plugin->IsEnabled()) {
@@ -4469,17 +4177,16 @@ nsPluginHostImpl::GetPlugins(PRUint32 aP
       NS_IF_ADDREF(domPlugin);
       aPluginArray[i++] = domPlugin;
     }
   }
 
   return NS_OK;
 }
 
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP
 nsPluginHostImpl::GetPluginTags(PRUint32* aPluginCount, nsIPluginTag*** aResults)
 {
   LoadPlugins();
 
   PRUint32 count = 0;
   nsRefPtr<nsPluginTag> plugin = mPlugins;
   while (plugin != nsnull) {
@@ -4500,34 +4207,32 @@ nsPluginHostImpl::GetPluginTags(PRUint32
     (*aResults)[i] = plugin;
     NS_ADDREF((*aResults)[i]);
     plugin = plugin->mNext;
   }
 
   return NS_OK;
 }
 
-////////////////////////////////////////////////////////////////////////
 nsPluginTag*
 nsPluginHostImpl::FindPluginForType(const char* aMimeType,
                                     PRBool aCheckEnabled)
 {
   nsPluginTag *plugins = nsnull;
   PRInt32     variants, cnt;
 
   LoadPlugins();
 
   // if we have a mimetype passed in, search the mPlugins
   // linked list for a match
   if (nsnull != aMimeType) {
     plugins = mPlugins;
 
     while (nsnull != plugins) {
       variants = plugins->mVariants;
-
       for (cnt = 0; cnt < variants; cnt++) {
         if ((!aCheckEnabled || plugins->IsEnabled()) &&
             plugins->mMimeTypeArray[cnt] &&
             (0 == PL_strcasecmp(plugins->mMimeTypeArray[cnt], aMimeType))) {
           return plugins;
         }
       }
 
@@ -4544,49 +4249,41 @@ nsPluginHostImpl::FindPluginEnabledForEx
 {
   nsPluginTag *plugins = nsnull;
   PRInt32     variants, cnt;
 
   LoadPlugins();
 
   // if we have a mimetype passed in, search the mPlugins linked
   // list for a match
-  if (nsnull != aExtension)
-  {
+  if (aExtension) {
     plugins = mPlugins;
-
-    while (nsnull != plugins)
-    {
+    while (plugins) {
       variants = plugins->mVariants;
-
-      if (plugins->mExtensionsArray)
-      {
-        for (cnt = 0; cnt < variants; cnt++)
-        {
+      if (plugins->mExtensionsArray) {
+        for (cnt = 0; cnt < variants; cnt++) {
           // mExtensionsArray[cnt] is a list of extensions separated
           // by commas
           if (plugins->IsEnabled() &&
-              0 == CompareExtensions(plugins->mExtensionsArray[cnt], aExtension))
-          {
+              0 == CompareExtensions(plugins->mExtensionsArray[cnt], aExtension)) {
             aMimeType = plugins->mMimeTypeArray[cnt];
             return plugins;
           }
         }
       }
 
       plugins = plugins->mNext;
     }
   }
 
   return nsnull;
 }
 
 #if defined(XP_MACOSX)
-/**
- * The following code examines the format of a Mac OS X binary, and determines whether it
+/* The following code examines the format of a Mac OS X binary, and determines whether it
  * is compatible with the current executable.
  */
 
 #include <sys/stat.h>
 #include <sys/fcntl.h>
 #include <unistd.h>
 
 static inline PRBool is_directory(const char* path)
@@ -4725,44 +4422,40 @@ static nsresult CreateNPAPIPlugin(nsISer
   }
 
   return nsNPAPIPlugin::CreatePlugin(fileName.get(),
                                      fullPath.get(),
                                      aPluginTag->mLibrary,
                                      aOutNPAPIPlugnin);
 }
 
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP nsPluginHostImpl::GetPluginFactory(const char *aMimeType, nsIPlugin** aPlugin)
 {
   nsresult rv = NS_ERROR_FAILURE;
   *aPlugin = NULL;
 
-  if(!aMimeType)
+  if (!aMimeType)
     return NS_ERROR_ILLEGAL_VALUE;
 
   // If plugins haven't been scanned yet, do so now
   LoadPlugins();
 
   nsPluginTag* pluginTag = FindPluginForType(aMimeType, PR_TRUE);
-  if(pluginTag)
-  {
+  if (pluginTag) {
     rv = NS_OK;
     PLUGIN_LOG(PLUGIN_LOG_BASIC,
     ("nsPluginHostImpl::GetPluginFactory Begin mime=%s, plugin=%s\n",
     aMimeType, pluginTag->mFileName.get()));
 
 #ifdef NS_DEBUG
-    if(aMimeType && !pluginTag->mFileName.IsEmpty())
+    if (aMimeType && !pluginTag->mFileName.IsEmpty())
       printf("For %s found plugin %s\n", aMimeType, pluginTag->mFileName.get());
 #endif
 
-    if (nsnull == pluginTag->mLibrary)  // if we haven't done this yet
-    {
-
+    if (!pluginTag->mLibrary) { // if we haven't done this yet
      nsCOMPtr<nsILocalFile> file = do_CreateInstance("@mozilla.org/file/local;1");
 #if !defined(XP_MACOSX)
       file->InitWithPath(NS_ConvertUTF8toUTF16(pluginTag->mFileName));
 #else
       if (pluginTag->mFullPath.IsEmpty())
         return NS_ERROR_FAILURE;
       file->InitWithPath(NS_ConvertUTF8toUTF16(pluginTag->mFullPath));
 #endif
@@ -4775,79 +4468,72 @@ NS_IMETHODIMP nsPluginHostImpl::GetPlugi
       // remove from unused lib list, if it is there
       if (mUnusedLibraries.IndexOf(pluginLibrary) > -1)
         mUnusedLibraries.RemoveElement(pluginLibrary);
 
       pluginTag->mLibrary = pluginLibrary;
     }
 
     nsIPlugin* plugin = pluginTag->mEntryPoint;
-    if(plugin == NULL)
-    {
+    if (!plugin) {
       // nsIPlugin* of xpcom plugins can be found thru a call to
       // nsIComponentManager::GetClassObjectByContractID()
       nsCAutoString contractID(
               NS_LITERAL_CSTRING(NS_INLINE_PLUGIN_CONTRACTID_PREFIX) +
               nsDependentCString(aMimeType));
       nsresult rv = CallGetClassObject(contractID.get(), &plugin);
-      if (NS_SUCCEEDED(rv) && plugin)
-      {
+      if (NS_SUCCEEDED(rv) && plugin) {
         // plugin is already addref'd
         pluginTag->mEntryPoint = plugin;
         plugin->Initialize();
       }
     }
 
-    if (plugin == NULL)
-    {
+    if (!plugin) {
       // No, this is not a leak. GetGlobalServiceManager() doesn't
       // addref the pointer on the way out. It probably should.
       nsIServiceManagerObsolete* serviceManager;
       nsServiceManager::GetGlobalServiceManager((nsIServiceManager**)&serviceManager);
 
       // need to get the plugin factory from this plugin.
       nsFactoryProc nsGetFactory = nsnull;
 #ifdef XP_OS2
       nsGetFactory = (nsFactoryProc) PR_FindFunctionSymbol(pluginTag->mLibrary, "_NSGetFactory");
 #else
       nsGetFactory = (nsFactoryProc) PR_FindFunctionSymbol(pluginTag->mLibrary, "NSGetFactory");
 #endif
-      if(nsGetFactory && IsCompatibleExecutable(pluginTag->mFullPath.get()))
-      {
+      if (nsGetFactory && IsCompatibleExecutable(pluginTag->mFullPath.get())) {
 // XPCOM-style plugins (or at least the OJI one) cause crashes on
 // on windows GCC builds, so we're just turning them off for now.
 #if !defined(XP_WIN) || !defined(__GNUC__)
         rv = nsGetFactory(serviceManager, kPluginCID, nsnull, nsnull,    // XXX fix ClassName/ContractID
                           (nsIFactory**)&pluginTag->mEntryPoint);
         plugin = pluginTag->mEntryPoint;
-        if (plugin != NULL)
+        if (plugin)
           plugin->Initialize();
 #endif
       }
 #ifdef XP_OS2
       // on OS2, first check if this might be legacy XPCOM module.
       else if (PR_FindSymbol(pluginTag->mLibrary, "NSGetFactory") &&
-               IsCompatibleExecutable(pluginTag->mFullPath.get()))
-      {
+               IsCompatibleExecutable(pluginTag->mFullPath.get())) {
         // Possibly a legacy XPCOM module. We'll need to create a calling
         // vtable/calling convention wrapper for it.
         nsCOMPtr<nsILegacyPluginWrapperOS2> wrapper =
                        do_GetService(NS_LEGACY_PLUGIN_WRAPPER_CONTRACTID, &rv);
-        if (NS_SUCCEEDED(rv))
-        {
+        if (NS_SUCCEEDED(rv)) {
           rv = wrapper->GetFactory(serviceManager, kPluginCID, nsnull, nsnull,
                                    pluginTag->mLibrary, &pluginTag->mEntryPoint);
           plugin = pluginTag->mEntryPoint;
-          if (plugin != NULL)
+          if (plugin)
             plugin->Initialize();
         }
       }
 #endif
-      else
-      {
+      else {
         // Now lets try to get the entry point from a 4.x plugin
         rv = CreateNPAPIPlugin(serviceManager, pluginTag, &plugin);
         if (NS_SUCCEEDED(rv))
           pluginTag->mEntryPoint = plugin;
         pluginTag->Mark(NS_PLUGIN_FLAG_OLDSCHOOL);
         // no need to initialize, already done by CreatePlugin()
       }
     }
@@ -4857,56 +4543,52 @@ NS_IMETHODIMP nsPluginHostImpl::GetPlugi
       which turn off all our inline IME. Turn it back after the plugin
       initializtion and hope that future versions will be fixed. See bug 159016
    */
     if (StringBeginsWith(pluginTag->mDescription,
                          NS_LITERAL_CSTRING("Shockwave Flash 6.0"),
                          nsCaseInsensitiveCStringComparator()) &&
         pluginTag->mDescription.Length() > 21) {
        int ver = atoi(pluginTag->mDescription.get() + 21);
-       if  (ver && ver <= 50) {
+       if (ver && ver <= 50)
          ::UseInputWindow(NULL, false);
-       }
-    }
-#endif
-
-    if (plugin != nsnull)
-    {
+    }
+#endif
+
+    if (plugin) {
       *aPlugin = plugin;
       plugin->AddRef();
       return NS_OK;
     }
   }
 
   PLUGIN_LOG(PLUGIN_LOG_NORMAL,
   ("nsPluginHostImpl::GetPluginFactory End mime=%s, rv=%d, plugin=%p name=%s\n",
   aMimeType, rv, *aPlugin,
   (pluginTag ? pluginTag->mFileName.get() : "(not found)")));
 
   return rv;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 // XXX called from ScanPluginsDirectory only when told to filter
 // currently 'unwanted' plugins are Java, and all other plugins except
 // Acrobat, Flash, Quicktime and Shockwave
 static PRBool isUnwantedPlugin(nsPluginTag * tag)
 {
-  if(tag->mFileName.IsEmpty())
+  if (tag->mFileName.IsEmpty())
     return PR_TRUE;
 
   for (PRInt32 i = 0; i < tag->mVariants; ++i) {
-    if(nsnull == PL_strcasecmp(tag->mMimeTypeArray[i], "application/pdf"))
+    if (nsnull == PL_strcasecmp(tag->mMimeTypeArray[i], "application/pdf"))
       return PR_FALSE;
 
-    if(nsnull == PL_strcasecmp(tag->mMimeTypeArray[i], "application/x-shockwave-flash"))
+    if (nsnull == PL_strcasecmp(tag->mMimeTypeArray[i], "application/x-shockwave-flash"))
       return PR_FALSE;
 
-    if(nsnull == PL_strcasecmp(tag->mMimeTypeArray[i],"application/x-director"))
+    if (nsnull == PL_strcasecmp(tag->mMimeTypeArray[i],"application/x-director"))
       return PR_FALSE;
   }
 
   // On Windows, we also want to include the Quicktime plugin from the 4.x directory
   // But because it spans several DLL's, the best check for now is by filename
   if (tag->mFileName.Find("npqtplugin", PR_TRUE, 0, -1) != kNotFound)
     return PR_FALSE;
 
@@ -4921,18 +4603,18 @@ PRBool nsPluginHostImpl::IsJavaMIMEType(
      (0 == PL_strncasecmp(aType, "application/x-java-applet",
                           sizeof("application/x-java-applet") - 1)) ||
      (0 == PL_strncasecmp(aType, "application/x-java-bean",
                           sizeof("application/x-java-bean") - 1)));
 }
 
 nsPluginTag * nsPluginHostImpl::HaveSamePlugin(nsPluginTag * aPluginTag)
 {
-  for(nsPluginTag* tag = mPlugins; tag; tag = tag->mNext) {
-    if(tag->Equals(aPluginTag))
+  for (nsPluginTag* tag = mPlugins; tag; tag = tag->mNext) {
+    if (tag->Equals(aPluginTag))
       return tag;
   }
   return nsnull;
 }
 
 PRBool nsPluginHostImpl::IsDuplicatePlugin(nsPluginTag * aPluginTag)
 {
   nsPluginTag * tag = HaveSamePlugin(aPluginTag);
@@ -5020,18 +4702,17 @@ static nsresult FixUpPluginInfo(nsPlugin
     PL_strfree(aInfo.fMimeTypeArray[i]);
     aInfo.fMimeTypeArray[i] = PL_strdup("[*]");
 
     // continue the loop?
   }
   return NS_OK;
 }
 
-/**
- * Helper class which automatically deallocates a nsVoidArray of 
+/* Helper class which automatically deallocates a nsVoidArray of 
  * pluginFileinDirectories when the array goes out of scope.
  */
 class nsAutoPluginFileDeleter
 {
 public:
   nsAutoPluginFileDeleter (nsAutoVoidArray& aPluginFiles)
     :mPluginFiles(aPluginFiles)
   {}
@@ -5043,17 +4724,16 @@ public:
       delete pfd;
     }
   }
 protected:
   // A reference to the array for which to perform deallocation.
   nsAutoVoidArray& mPluginFiles;
 };
 
-////////////////////////////////////////////////////////////////////////
 nsresult nsPluginHostImpl::ScanPluginsDirectory(nsIFile * pluginsDir,
                                                 nsIComponentManager * compManager,
                                                 PRBool aCreatePluginList,
                                                 PRBool * aPluginsChanged,
                                                 PRBool checkForUnwantedPlugins)
 {
   NS_ENSURE_ARG_POINTER(aPluginsChanged);
   nsresult rv;
@@ -5124,32 +4804,33 @@ nsresult nsPluginHostImpl::ScanPluginsDi
     localfile->InitWithPath(pfd->mFilename);
     PRInt64 fileModTime = pfd->mModTime;
 
     // Look for it in our cache
     nsRefPtr<nsPluginTag> pluginTag;
     RemoveCachedPluginsInfo(NS_ConvertUTF16toUTF8(pfd->mFilename).get(),
                             getter_AddRefs(pluginTag));
 
-    PRUint32 oldFlags = NS_PLUGIN_FLAG_ENABLED;
+    PRBool enabled = PR_TRUE;
+    PRBool seenBefore = PR_FALSE;
     if (pluginTag) {
+      seenBefore = PR_TRUE;
       // If plugin changed, delete cachedPluginTag and don't use cache
       if (LL_NE(fileModTime, pluginTag->mLastModifiedTime)) {
         // Plugins has changed. Don't use cached plugin info.
-        oldFlags = pluginTag->Flags() &
-                   (NS_PLUGIN_FLAG_ENABLED | NS_PLUGIN_FLAG_BLOCKLISTED);
+        enabled = (pluginTag->Flags() & NS_PLUGIN_FLAG_ENABLED) != 0;
         pluginTag = nsnull;
 
         // plugin file changed, flag this fact
         *aPluginsChanged = PR_TRUE;
       }
       else {
         // if it is unwanted plugin we are checking for, get it back to the cache info list
         // if this is a duplicate plugin, too place it back in the cache info list marking unwantedness
-        if((checkForUnwantedPlugins && isUnwantedPlugin(pluginTag)) ||
+        if ((checkForUnwantedPlugins && isUnwantedPlugin(pluginTag)) ||
            IsDuplicatePlugin(pluginTag)) {
           if (!pluginTag->HasFlag(NS_PLUGIN_FLAG_UNWANTED)) {
             // Plugin switched from wanted to unwanted
             *aPluginsChanged = PR_TRUE;
           }
           pluginTag->Mark(NS_PLUGIN_FLAG_UNWANTED);
           pluginTag->mNext = mCachedPlugins;
           mCachedPlugins = pluginTag;
@@ -5183,81 +4864,94 @@ nsresult nsPluginHostImpl::ScanPluginsDi
 #ifndef XP_WIN
       if (pluginFile.LoadPlugin(pluginLibrary) != NS_OK || pluginLibrary == nsnull)
         continue;
 #endif
 
       // create a tag describing this plugin.
       nsPluginInfo info = { sizeof(info) };
       nsresult res = pluginFile.GetPluginInfo(info);
-      if(NS_FAILED(res))
+      if (NS_FAILED(res))
         continue;
 
       // if we don't have mime type -- don't proceed, this is not a plugin
-      if(!info.fMimeTypeArray) {
+      if (!info.fMimeTypeArray) {
         pluginFile.FreePluginInfo(info);
         continue;
       }
 
       // Check for any potential '*' mime type handlers which are not our
       // own default plugin and disable them as they will break the plugin
       // finder service, see Bugzilla bug 132430
       if (!mAllowAlienStarHandler)
         FixUpPluginInfo(info, pluginFile);
 
       pluginTag = new nsPluginTag(&info);
       pluginFile.FreePluginInfo(info);
 
-      if(pluginTag == nsnull)
+      if (pluginTag == nsnull)
         return NS_ERROR_OUT_OF_MEMORY;
 
       pluginTag->mLibrary = pluginLibrary;
       pluginTag->mLastModifiedTime = fileModTime;
-      if (!(oldFlags & NS_PLUGIN_FLAG_ENABLED) ||
-          (pluginTag->mIsJavaPlugin && !mJavaEnabled))
+
+      nsCOMPtr<nsIBlocklistService> blocklist = do_GetService("@mozilla.org/extensions/blocklist;1");
+      if (blocklist) {
+        PRUint32 state;
+        rv = blocklist->GetPluginBlocklistState(pluginTag, EmptyString(),
+                                                EmptyString(), &state);
+
+        if (NS_SUCCEEDED(rv)) {
+          // If the blocklist says so then block the plugin. If the blocklist says
+          // it is risky and we have never seen this plugin before then disable it
+          if (state == nsIBlocklistService::STATE_BLOCKED)
+            pluginTag->Mark(NS_PLUGIN_FLAG_BLOCKLISTED);
+          else if (state == nsIBlocklistService::STATE_SOFTBLOCKED && !seenBefore)
+            enabled = PR_FALSE;
+        }
+      }
+
+      if (!enabled || (pluginTag->mIsJavaPlugin && !mJavaEnabled))
         pluginTag->UnMark(NS_PLUGIN_FLAG_ENABLED);
-
-      if (oldFlags & NS_PLUGIN_FLAG_BLOCKLISTED)
-        pluginTag->Mark(NS_PLUGIN_FLAG_BLOCKLISTED);
 
       // if this is unwanted plugin we are checkin for, or this is a duplicate plugin,
       // add it to our cache info list so we can cache the unwantedness of this plugin
       // when we sync cached plugins to registry
       NS_ASSERTION(!pluginTag->HasFlag(NS_PLUGIN_FLAG_UNWANTED),
                    "Brand-new tags should not be unwanted");
-      if((checkForUnwantedPlugins && isUnwantedPlugin(pluginTag)) ||
+      if ((checkForUnwantedPlugins && isUnwantedPlugin(pluginTag)) ||
          IsDuplicatePlugin(pluginTag)) {
         pluginTag->Mark(NS_PLUGIN_FLAG_UNWANTED);
         pluginTag->mNext = mCachedPlugins;
         mCachedPlugins = pluginTag;
       }
     }
 
     // set the flag that we want to add this plugin to the list for now
     // and see if it remains after we check several reasons not to do so
     PRBool bAddIt = PR_TRUE;
 
     // check if this is a specific plugin we don't want
-    if(checkForUnwantedPlugins && isUnwantedPlugin(pluginTag))
+    if (checkForUnwantedPlugins && isUnwantedPlugin(pluginTag))
       bAddIt = PR_FALSE;
 
     // check if we already have this plugin in the list which
     // is possible if we do refresh
-    if(bAddIt) {
+    if (bAddIt) {
       if (HaveSamePlugin(pluginTag)) {
         // we cannot get here if the plugin has just been added
         // and thus |pluginTag| is not from cache, because otherwise
         // it would not be present in the list;
         // so there is no need to delete |pluginTag| -- it _is_ from the cache info list.
         bAddIt = PR_FALSE;
       }
     }
 
-    // so if we still want it -- do it
-    if(bAddIt) {
+    // do it if we still want it
+    if (bAddIt) {
       pluginTag->SetHost(this);
       pluginTag->mNext = mPlugins;
       mPlugins = pluginTag;
 
       if (pluginTag->IsEnabled())
         pluginTag->RegisterWithCategoryManager(mOverrideInternalTypes);
     }
     else if (!pluginTag->HasFlag(NS_PLUGIN_FLAG_UNWANTED)) {
@@ -5299,17 +4993,17 @@ nsresult nsPluginHostImpl::ScanPluginsDi
     }
     return NS_OK;
 }
 
 NS_IMETHODIMP nsPluginHostImpl::LoadPlugins()
 {
   // do not do anything if it is already done
   // use ReloadPlugins() to enforce loading
-  if(mPluginsLoaded)
+  if (mPluginsLoaded)
     return NS_OK;
 
   PRBool pluginschanged;
   nsresult rv = FindPlugins(PR_TRUE, &pluginschanged);
   if (NS_FAILED(rv))
     return rv;
 
   // only if plugins have changed will we ask XPTI to refresh
@@ -5522,17 +5216,16 @@ nsresult nsPluginHostImpl::FindPlugins(P
   mPlugins = prev;
 
   NS_TIMELINE_STOP_TIMER("LoadPlugins");
   NS_TIMELINE_MARK_TIMER("LoadPlugins");
 
   return NS_OK;
 }
 
-////////////////////////////////////////////////////////////////////////
 nsresult
 nsPluginHostImpl::LoadXPCOMPlugins(nsIComponentManager* aComponentManager)
 {
   // the component reg is a flat file now see 48888
   // we have to reimplement this method if we need it
 
   // The "new style" XPCOM plugins have their information stored in
   // the component registry, under the key
@@ -5556,19 +5249,17 @@ nsPluginHostImpl::UpdatePluginInfo(nsPlu
     return NS_OK;
 
   nsCOMPtr<nsISupportsArray> instsToReload;
   NS_NewISupportsArray(getter_AddRefs(instsToReload));
   mActivePluginList.stopRunning(instsToReload, aPluginTag);
   mActivePluginList.removeAllStopped();
   
   PRUint32 c;
-  if (instsToReload &&
-      NS_SUCCEEDED(instsToReload->Count(&c)) &&
-      c > 0) {
+  if (instsToReload && NS_SUCCEEDED(instsToReload->Count(&c)) && c > 0) {
     nsCOMPtr<nsIRunnable> ev = new nsPluginDocReframeEvent(instsToReload);
     if (ev)
       NS_DispatchToCurrentThread(ev);
   }
 
   return NS_OK;
 }
 
@@ -5719,92 +5410,98 @@ nsPluginHostImpl::ReadPluginInfo()
     return rv;
 
   nsCOMPtr<nsILocalFile> localFile = do_QueryInterface(pluginReg, &rv);
   if (NS_FAILED(rv))
     return rv;
 
   PRInt64 fileSize;
   rv = localFile->GetFileSize(&fileSize);
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
+  if (NS_FAILED(rv))
+    return rv;
 
   PRInt32 flen = nsInt64(fileSize);
   if (flen == 0) {
     NS_WARNING("Plugins Registry Empty!");
     return NS_OK; // ERROR CONDITION
   }
 
   nsPluginManifestLineReader reader;
   char* registry = reader.Init(flen);
-  if (!registry) {
-    return NS_ERROR_OUT_OF_MEMORY;
-  }
+  if (!registry)
+    return NS_ERROR_OUT_OF_MEMORY;
 
   rv = localFile->OpenNSPRFileDesc(PR_RDONLY, 0444, &fd);
   if (NS_FAILED(rv))
     return rv;
 
   // set rv to return an error on goto out
   rv = NS_ERROR_FAILURE;
 
   PRInt32 bread = PR_Read(fd, registry, flen);
   PR_Close(fd);
 
   if (flen > bread)
     return rv;
 
-  if (!ReadSectionHeader(reader, "HEADER")) {
+  if (!ReadSectionHeader(reader, "HEADER"))
     return rv;;
-  }
-
-  if (!reader.NextLine()) {
-    return rv;
-  }
+
+  if (!reader.NextLine())
+    return rv;
 
   char* values[6];
 
   // VersionLiteral, kPluginRegistryVersion
-  if (2 != reader.ParseLine(values, 2)) {
-    return rv;
-  }
+  if (2 != reader.ParseLine(values, 2))
+    return rv;
 
   // VersionLiteral
-  if (PL_strcmp(values[0], "Version")) {
-    return rv;
-  }
+  if (PL_strcmp(values[0], "Version"))
+    return rv;
 
   // kPluginRegistryVersion
-  if (PL_strcmp(values[1], kPluginRegistryVersion)) {
-    return rv;
-  }
-
-  if (!ReadSectionHeader(reader, "PLUGINS")) {
-    return rv;
-  }
+  PRInt32 vdiff = NS_CompareVersions(values[1], kPluginRegistryVersion);
+  // If this is a registry from some future version then don't attempt to read it
+  if (vdiff > 0)
+    return rv;
+  // If this is a registry from before the minimum then don't attempt to read it
+  if (NS_CompareVersions(values[1], kMinimumRegistryVersion) < 0)
+    return rv;
+
+  // Registry v0.10 and upwards includes the plugin version field
+  PRBool regHasVersion = NS_CompareVersions(values[1], "0.10") >= 0;
+
+  if (!ReadSectionHeader(reader, "PLUGINS"))
+    return rv;
 
   while (reader.NextLine()) {
     char *filename = reader.LinePtr();
     if (!reader.NextLine())
       return rv;
 
     char *fullpath = reader.LinePtr();
     if (!reader.NextLine())
       return rv;
 
-    char *version = reader.LinePtr();
-    if (!reader.NextLine())
-      return rv;
+    char *version;
+    if (regHasVersion) {
+      version = reader.LinePtr();
+      if (!reader.NextLine())
+        return rv;
+    } else {
+      version = "0";
+    }
 
     // lastModifiedTimeStamp|canUnload|tag.mFlag
-    if (3 != reader.ParseLine(values, 3))
-      return rv;
-
-    PRInt64 lastmod = nsCRT::atoll(values[0]);
+    if (reader.ParseLine(values, 3) != 3)
+      return rv;
+
+    // If this is an old plugin registry mark this plugin tag to be refreshed
+    PRInt64 lastmod = vdiff == 0 ? nsCRT::atoll(values[0]) : -1;
     PRBool canunload = atoi(values[1]);
     PRUint32 tagflag = atoi(values[2]);
     if (!reader.NextLine())
       return rv;
 
     char *description = reader.LinePtr();
     if (!reader.NextLine())
       return rv;
@@ -5856,23 +5553,21 @@ nsPluginHostImpl::ReadPluginInfo()
       description,
       filename,
       (*fullpath ? fullpath : 0), // we have to pass 0 prt if it's empty str
       version,
       (const char* const*)mimetypes,
       (const char* const*)mimedescriptions,
       (const char* const*)extensions,
       mimetypecount, lastmod, canunload, PR_TRUE);
-    if (heapalloced) {
+    if (heapalloced)
       delete [] heapalloced;
-    }
-
-    if (!tag) {
-      continue;
-    }
+
+    if (!tag)
+      continue;
 
     // Mark plugin as loaded from cache
     tag->Mark(tagflag | NS_PLUGIN_FLAG_FROMCACHE);
     if (tag->mIsJavaPlugin) {
       if (mJavaEnabled)
         tag->Mark(NS_PLUGIN_FLAG_ENABLED);
       else
         tag->UnMark(NS_PLUGIN_FLAG_ENABLED);
@@ -5892,18 +5587,17 @@ nsPluginHostImpl::RemoveCachedPluginsInf
   nsRefPtr<nsPluginTag> prev;
   nsRefPtr<nsPluginTag> tag = mCachedPlugins;
   while (tag)
   {
     // compare filename or else the mFullPath if it exists. Mac seems to use
     // mFullPath for fullpath and mFileName for just the leafname of fullpath.
     // On win and unix, mFullPath is never used and mFileName is contains the
     // full pathname. All this should move to using nsIFile.
-    if (tag->mFileName.Equals(filename) || tag->mFullPath.Equals(filename))
-    {
+    if (tag->mFileName.Equals(filename) || tag->mFullPath.Equals(filename)) {
       // Found it. Remove it from our list
       if (prev)
         prev->mNext = tag->mNext;
       else
         mCachedPlugins = tag->mNext;
       tag->mNext = nsnull;
       *result = tag;
       NS_ADDREF(*result);
@@ -5913,35 +5607,33 @@ nsPluginHostImpl::RemoveCachedPluginsInf
     tag = tag->mNext;
   }
 }
 
 #ifdef XP_WIN
 nsresult
 nsPluginHostImpl::EnsurePrivateDirServiceProvider()
 {
-  if (!mPrivateDirServiceProvider)
-  {
+  if (!mPrivateDirServiceProvider) {
     nsresult rv;
     mPrivateDirServiceProvider = new nsPluginDirServiceProvider();
     if (!mPrivateDirServiceProvider)
       return NS_ERROR_OUT_OF_MEMORY;
     nsCOMPtr<nsIDirectoryService> dirService(do_GetService(kDirectoryServiceContractID, &rv));
     if (NS_FAILED(rv))
       return rv;
     rv = dirService->RegisterProvider(mPrivateDirServiceProvider);
     if (NS_FAILED(rv))
       return rv;
   }
   return NS_OK;
 }
 #endif /* XP_WIN */
 
-////////////////////////////////////////////////////////////////////////
-/* Called by GetURL and PostURL */
+// Called by GetURL and PostURL
 NS_IMETHODIMP nsPluginHostImpl::NewPluginURLStream(const nsString& aURL,
                                                    nsIPluginInstance *aInstance,
                                                    nsIPluginStreamListener* aListener,
                                                    const char *aPostData,
                                                    PRBool aIsFile,
                                                    PRUint32 aPostDataLen,
                                                    const char *aHeadersData,
                                                    PRUint32 aHeadersDataLen)
@@ -5954,38 +5646,34 @@ NS_IMETHODIMP nsPluginHostImpl::NewPlugi
     return NS_OK;
 
   // get the full URL of the document that the plugin is embedded
   //   in to create an absolute url in case aURL is relative
   nsCOMPtr<nsIDocument> doc;
   nsCOMPtr<nsIPluginInstancePeer> peer;
   nsCOMPtr<nsIPluginInstanceOwner> owner;
   rv = aInstance->GetPeer(getter_AddRefs(peer));
-  if (NS_SUCCEEDED(rv) && peer)
-  {
+  if (NS_SUCCEEDED(rv) && peer) {
     nsCOMPtr<nsPIPluginInstancePeer> privpeer(do_QueryInterface(peer));
     rv = privpeer->GetOwner(getter_AddRefs(owner));
-    if (owner)
-    {
+    if (owner) {
       rv = owner->GetDocument(getter_AddRefs(doc));
-      if (NS_SUCCEEDED(rv) && doc)
-      {
+      if (NS_SUCCEEDED(rv) && doc) {
         // Create an absolute URL
         rv = NS_MakeAbsoluteURI(absUrl, aURL, doc->GetBaseURI());
       }
     }
   }
 
   if (absUrl.IsEmpty())
     absUrl.Assign(aURL);
 
   rv = NS_NewURI(getter_AddRefs(url), absUrl);
 
-  if (NS_SUCCEEDED(rv))
-  {
+  if (NS_SUCCEEDED(rv)) {
     nsCOMPtr<nsIPluginTagInfo2> pti2 = do_QueryInterface(owner);
     nsCOMPtr<nsIDOMElement> element;
     if (pti2)
       pti2->GetDOMElement(getter_AddRefs(element));
 
     PRInt16 shouldLoad = nsIContentPolicy::ACCEPT;
     rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_OBJECT_SUBREQUEST,
                                    url,
@@ -6002,70 +5690,62 @@ NS_IMETHODIMP nsPluginHostImpl::NewPlugi
 
     nsPluginStreamListenerPeer *listenerPeer = new nsPluginStreamListenerPeer;
     if (listenerPeer == NULL)
       return NS_ERROR_OUT_OF_MEMORY;
 
     NS_ADDREF(listenerPeer);
     rv = listenerPeer->Initialize(url, aInstance, aListener);
 
-    if (NS_SUCCEEDED(rv))
-    {
+    if (NS_SUCCEEDED(rv)) {
       nsCOMPtr<nsIInterfaceRequestor> callbacks;
-
-      if (doc)
-      {
+      if (doc) {
         // Get the script global object owner and use that as the
         // notification callback.
         nsIScriptGlobalObject* global = doc->GetScriptGlobalObject();
-
-        if (global)
-        {
+        if (global) {
           nsCOMPtr<nsIWebNavigation> webNav = do_GetInterface(global);
-
           callbacks = do_QueryInterface(webNav);
         }
       }
 
       nsCOMPtr<nsIChannel> channel;
 
       rv = NS_NewChannel(getter_AddRefs(channel), url, nsnull,
         nsnull, /* do not add this internal plugin's channel
                 on the load group otherwise this channel could be canceled
                 form |nsWebShell::OnLinkClickSync| bug 166613 */
         callbacks);
       if (NS_FAILED(rv))
         return rv;
 
-      if (doc)
-      {
+      if (doc) {
         // Set the owner of channel to the document principal...
         channel->SetOwner(doc->NodePrincipal());
 
         // And if it's a script allow it to execute against the
         // document's script context.
         nsCOMPtr<nsIScriptChannel> scriptChannel(do_QueryInterface(channel));
         if (scriptChannel) {
           scriptChannel->SetExecutionPolicy(nsIScriptChannel::EXECUTE_NORMAL);
           // Plug-ins seem to depend on javascript: URIs running synchronously
           scriptChannel->SetExecuteAsync(PR_FALSE);
         }
       }
 
       // deal with headers and post data
       nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(channel));
-      if(httpChannel) {
+      if (httpChannel) {
         if (aPostData) {
 
           nsCOMPtr<nsIInputStream> postDataStream;
           rv = NS_NewPluginPostDataStream(getter_AddRefs(postDataStream), (const char*)aPostData,
                                           aPostDataLen, aIsFile);
 
-          if (!postDataStream)
-          {
+          if (!postDataStream) {
             NS_RELEASE(aInstance);
             return NS_ERROR_UNEXPECTED;
           }
 
           // XXX it's a bit of a hack to rewind the postdata stream
           // here but it has to be done in case the post data is
           // being reused multiple times.
           nsCOMPtr<nsISeekableStream>
@@ -6084,18 +5764,17 @@ NS_IMETHODIMP nsPluginHostImpl::NewPlugi
       }
       rv = channel->AsyncOpen(listenerPeer, nsnull);
     }
     NS_RELEASE(listenerPeer);
   }
   return rv;
 }
 
-////////////////////////////////////////////////////////////////////////
-/* Called by GetURL and PostURL */
+// Called by GetURL and PostURL
 nsresult
 nsPluginHostImpl::DoURLLoadSecurityCheck(nsIPluginInstance *aInstance,
                                          const char* aURL)
 {
   nsresult rv;
 
   if (!aURL || *aURL == '\0')
     return NS_OK;
@@ -6129,18 +5808,16 @@ nsPluginHostImpl::DoURLLoadSecurityCheck
   if (NS_FAILED(rv))
     return rv;
 
   return secMan->CheckLoadURIWithPrincipal(doc->NodePrincipal(), targetURL,
                                            nsIScriptSecurityManager::STANDARD);
 
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP
 nsPluginHostImpl::AddHeadersToChannel(const char *aHeadersData,
                                       PRUint32 aHeadersDataLen,
                                       nsIChannel *aGenericChannel)
 {
   nsresult rv = NS_OK;
 
   nsCOMPtr<nsIHttpChannel> aChannel = do_QueryInterface(aGenericChannel);
@@ -6151,26 +5828,21 @@ nsPluginHostImpl::AddHeadersToChannel(co
   // used during the manipulation of the String from the aHeadersData
   nsCAutoString headersString;
   nsCAutoString oneHeader;
   nsCAutoString headerName;
   nsCAutoString headerValue;
   PRInt32 crlf = 0;
   PRInt32 colon = 0;
 
-  //
   // Turn the char * buffer into an nsString.
-  //
   headersString = aHeadersData;
 
-  //
   // Iterate over the nsString: for each "\r\n" delimited chunk,
   // add the value as a header to the nsIHTTPChannel
-  //
-
   while (PR_TRUE) {
     crlf = headersString.Find("\r\n", PR_TRUE);
     if (-1 == crlf) {
       rv = NS_OK;
       return rv;
     }
     headersString.Mid(oneHeader, 0, crlf);
     headersString.Cut(0, crlf + 2);
@@ -6179,72 +5851,67 @@ nsPluginHostImpl::AddHeadersToChannel(co
     if (-1 == colon) {
       rv = NS_ERROR_NULL_POINTER;
       return rv;
     }
     oneHeader.Left(headerName, colon);
     colon++;
     oneHeader.Mid(headerValue, colon, oneHeader.Length() - colon);
 
-    //
     // FINALLY: we can set the header!
-    //
 
     rv = aChannel->SetRequestHeader(headerName, headerValue, PR_TRUE);
     if (NS_FAILED(rv)) {
       rv = NS_ERROR_NULL_POINTER;
       return rv;
     }
   }
   return rv;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP
 nsPluginHostImpl::StopPluginInstance(nsIPluginInstance* aInstance)
 {
   if (PluginDestructionGuard::DelayDestroy(aInstance)) {
     return NS_OK;
   }
 
   PLUGIN_LOG(PLUGIN_LOG_NORMAL,
   ("nsPluginHostImpl::StopPluginInstance called instance=%p\n",aInstance));
 
   nsActivePlugin * plugin = mActivePluginList.find(aInstance);
 
-  if(plugin != nsnull) {
+  if (plugin) {
     plugin->setStopped(PR_TRUE);  // be sure we set the "stop" bit
 
     // if the plugin does not want to be 'cached' just remove it
     PRBool doCache = PR_TRUE;
     aInstance->GetValue(nsPluginInstanceVariable_DoCacheBool, (void *) &doCache);
 
     if (!doCache) {
       PRLibrary * library = nsnull;
-      if(plugin->mPluginTag)
+      if (plugin->mPluginTag)
         library = plugin->mPluginTag->mLibrary;
 
       mActivePluginList.remove(plugin);
-    }
-    else {
+    } else {
       // if it is allowed to be cached simply stop it, but first we should check
       // if we haven't exceeded the maximum allowed number of cached instances
 
       // try to get the max cached plugins from a pref or use default
       PRUint32 max_num;
       nsresult rv = NS_ERROR_FAILURE;
-      if (mPrefService) {
+      if (mPrefService)
         rv = mPrefService->GetIntPref(NS_PREF_MAX_NUM_CACHED_PLUGINS, (int*)&max_num);
-      }
-      if (NS_FAILED(rv)) max_num = DEFAULT_NUMBER_OF_STOPPED_PLUGINS;
-
-      if(mActivePluginList.getStoppedCount() >= max_num) {
+      if (NS_FAILED(rv))
+        max_num = DEFAULT_NUMBER_OF_STOPPED_PLUGINS;
+
+      if (mActivePluginList.getStoppedCount() >= max_num) {
         nsActivePlugin * oldest = mActivePluginList.findOldestStopped();
-        if(oldest != nsnull)
+        if (oldest != nsnull)
           mActivePluginList.remove(oldest);
       }
     }
   }
   return NS_OK;
 }
 
 nsresult nsPluginHostImpl::NewEmbeddedPluginStreamListener(nsIURI* aURL,
@@ -6261,51 +5928,46 @@ nsresult nsPluginHostImpl::NewEmbeddedPl
     return NS_ERROR_OUT_OF_MEMORY;
 
   nsresult rv;
 
   // if we have an instance, everything has been set up
   // if we only have an owner, then we need to pass it in
   // so the listener can set up the instance later after
   // we've determined the mimetype of the stream
-  if(aInstance != nsnull)
+  if (aInstance != nsnull)
     rv = listener->InitializeEmbedded(aURL, aInstance);
-  else if(aOwner != nsnull)
+  else if (aOwner != nsnull)
     rv = listener->InitializeEmbedded(aURL, nsnull, aOwner, this);
   else
     rv = NS_ERROR_ILLEGAL_VALUE;
   if (NS_SUCCEEDED(rv))
     NS_ADDREF(*aListener = listener);
 
   return rv;
 }
 
-
-////////////////////////////////////////////////////////////////////////
-/* Called by InstantiateEmbeddedPlugin() */
+// Called by InstantiateEmbeddedPlugin()
 nsresult nsPluginHostImpl::NewEmbeddedPluginStream(nsIURI* aURL,
                                                    nsIPluginInstanceOwner *aOwner,
                                                    nsIPluginInstance* aInstance)
 {
   nsCOMPtr<nsIStreamListener> listener;
   nsresult rv = NewEmbeddedPluginStreamListener(aURL, aOwner, aInstance,
                                                 getter_AddRefs(listener));
   if (NS_SUCCEEDED(rv)) {
     nsCOMPtr<nsIDocument> doc;
     nsCOMPtr<nsILoadGroup> loadGroup;
-
     if (aOwner) {
       rv = aOwner->GetDocument(getter_AddRefs(doc));
       if (NS_SUCCEEDED(rv) && doc) {
         loadGroup = doc->GetDocumentLoadGroup();
       }
     }
-
     nsCOMPtr<nsIChannel> channel;
-
     rv = NS_NewChannel(getter_AddRefs(channel), aURL, nsnull, loadGroup, nsnull);
     if (NS_SUCCEEDED(rv)) {
       // if this is http channel, set referrer, some servers are configured
       // to reject requests without referrer set, see bug 157796
       nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(channel));
       if (httpChannel && doc)
         httpChannel->SetReferrer(doc->GetDocumentURI());
 
@@ -6313,23 +5975,22 @@ nsresult nsPluginHostImpl::NewEmbeddedPl
       if (NS_SUCCEEDED(rv))
         return NS_OK;
     }
   }
 
   return rv;
 }
 
-////////////////////////////////////////////////////////////////////////
-/* Called by InstantiateFullPagePlugin() */
+// Called by InstantiateFullPagePlugin()
 nsresult nsPluginHostImpl::NewFullPagePluginStream(nsIStreamListener *&aStreamListener,
                                                    nsIPluginInstance *aInstance)
 {
   nsPluginStreamListenerPeer  *listener = new nsPluginStreamListenerPeer();
-  if (listener == nsnull)
+  if (!listener)
     return NS_ERROR_OUT_OF_MEMORY;
 
   nsresult rv;
 
   rv = listener->InitializeFullPage(aInstance);
 
   aStreamListener = listener;
   NS_ADDREF(listener);
@@ -6342,17 +6003,16 @@ nsresult nsPluginHostImpl::NewFullPagePl
     p->mStreams->AppendElement(aStreamListener);
   }
 
   return rv;
 }
 
 
 // nsIFileUtilities interface
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP nsPluginHostImpl::GetProgramPath(const char* *result)
 {
   nsresult rv;
   NS_ENSURE_ARG_POINTER(result);
   *result = nsnull;
 
   nsCOMPtr<nsIProperties> dirService(do_GetService(kDirectoryServiceContractID, &rv));
   if (NS_FAILED(rv))
@@ -6363,18 +6023,16 @@ NS_IMETHODIMP nsPluginHostImpl::GetProgr
     return rv;
 
   nsCAutoString temp;
   rv = programDir->GetNativePath(temp);
   *result = ToNewCString(temp);
   return rv;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP nsPluginHostImpl::GetTempDirPath(const char* *result)
 {
   nsresult rv;
   NS_ENSURE_ARG_POINTER(result);
   *result = nsnull;
 
   nsCOMPtr<nsIProperties> dirService(do_GetService(kDirectoryServiceContractID, &rv));
   if (NS_FAILED(rv))
@@ -6385,166 +6043,149 @@ NS_IMETHODIMP nsPluginHostImpl::GetTempD
     return rv;
 
   nsCAutoString temp;
   rv = tempDir->GetNativePath(temp);
   *result = ToNewCString(temp);
   return rv;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP nsPluginHostImpl::NewTempFileName(const char* prefix, PRUint32 bufLen, char* resultBuf)
 {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
-
 // nsICookieStorage interface
 
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP nsPluginHostImpl::GetCookie(const char* inCookieURL, void* inOutCookieBuffer, PRUint32& inOutCookieSize)
 {
   nsresult rv = NS_ERROR_NOT_IMPLEMENTED;
   nsXPIDLCString cookieString;
   PRUint32 cookieStringLen = 0;
   nsCOMPtr<nsIURI> uriIn;
 
-  if ((nsnull == inCookieURL) || (0 >= inOutCookieSize)) {
+  if (!inCookieURL || (0 >= inOutCookieSize)) {
     return NS_ERROR_INVALID_ARG;
   }
 
   nsCOMPtr<nsIIOService> ioService(do_GetService(NS_IOSERVICE_CONTRACTID, &rv));
 
-  if (NS_FAILED(rv) || (nsnull == ioService)) {
-    return rv;
-  }
+  if (NS_FAILED(rv) || !ioService)
+    return rv;
 
   nsCOMPtr<nsICookieService> cookieService =
            do_GetService(NS_COOKIESERVICE_CONTRACTID, &rv);
 
-  if (NS_FAILED(rv) || (nsnull == cookieService)) {
+  if (NS_FAILED(rv) || !cookieService)
     return NS_ERROR_INVALID_ARG;
-  }
 
   // make an nsURI from the argument url
   rv = ioService->NewURI(nsDependentCString(inCookieURL), nsnull, nsnull, getter_AddRefs(uriIn));
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
+  if (NS_FAILED(rv))
+    return rv;
 
   rv = cookieService->GetCookieString(uriIn, nsnull, getter_Copies(cookieString));
 
-  if (NS_FAILED(rv) || (!cookieString) ||
+  if (NS_FAILED(rv) || !cookieString ||
       (inOutCookieSize <= (cookieStringLen = PL_strlen(cookieString.get())))) {
     return NS_ERROR_FAILURE;
   }
 
   PL_strcpy((char *) inOutCookieBuffer, cookieString.get());
   inOutCookieSize = cookieStringLen;
   rv = NS_OK;
 
   return rv;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP nsPluginHostImpl::SetCookie(const char* inCookieURL, const void* inCookieBuffer, PRUint32 inCookieSize)
 {
   nsresult rv = NS_ERROR_NOT_IMPLEMENTED;
   nsCOMPtr<nsIURI> uriIn;
 
-  if ((nsnull == inCookieURL) || (nsnull == inCookieBuffer) ||
+  if (!inCookieURL || !inCookieBuffer ||
       (0 >= inCookieSize)) {
     return NS_ERROR_INVALID_ARG;
   }
 
   nsCOMPtr<nsIIOService> ioService(do_GetService(NS_IOSERVICE_CONTRACTID, &rv));
 
-  if (NS_FAILED(rv) || (nsnull == ioService)) {
-    return rv;
-  }
+  if (NS_FAILED(rv) || !ioService)
+    return rv;
 
   nsCOMPtr<nsICookieService> cookieService =
            do_GetService(NS_COOKIESERVICE_CONTRACTID, &rv);
 
-  if (NS_FAILED(rv) || (nsnull == cookieService)) {
-    return NS_ERROR_FAILURE;
-  }
+  if (NS_FAILED(rv) || !cookieService)
+    return NS_ERROR_FAILURE;
 
   // make an nsURI from the argument url
   rv = ioService->NewURI(nsDependentCString(inCookieURL), nsnull, nsnull, getter_AddRefs(uriIn));
-  if (NS_FAILED(rv)) {
-    return NS_ERROR_FAILURE;
-  }
+  if (NS_FAILED(rv))
+    return NS_ERROR_FAILURE;
 
   nsCOMPtr<nsIPrompt> prompt;
   GetPrompt(nsnull, getter_AddRefs(prompt));
 
   char * cookie = (char *)inCookieBuffer;
   char c = cookie[inCookieSize];
   cookie[inCookieSize] = '\0';
   rv = cookieService->SetCookieString(uriIn, prompt, cookie, nsnull);
   cookie[inCookieSize] = c;
 
   return rv;
 }
 
-
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP nsPluginHostImpl::Observe(nsISupports *aSubject,
                                         const char *aTopic,
                                         const PRUnichar *someData)
 {
-  if (!nsCRT::strcmp(NS_XPCOM_SHUTDOWN_OBSERVER_ID, aTopic))
-  {
+  if (!nsCRT::strcmp(NS_XPCOM_SHUTDOWN_OBSERVER_ID, aTopic)) {
     OnShutdown();
     Destroy();
     UnloadUnusedLibraries();
     sInst->Release();
   }
   if (!nsCRT::strcmp(NS_PREFBRANCH_PREFCHANGE_TOPIC_ID, aTopic)) {
     NS_ASSERTION(someData &&
                  nsDependentString(someData).EqualsLiteral("security.enable_java"),
                  "Unexpected pref");
     nsCOMPtr<nsIPrefBranch> branch = do_QueryInterface(aSubject);
     NS_ASSERTION(branch, "Not a pref branch?");
     PRBool enabled;
-    if (NS_FAILED(branch->GetBoolPref("security.enable_java", &enabled))) {
+    if (NS_FAILED(branch->GetBoolPref("security.enable_java", &enabled)))
       enabled = PR_TRUE;
-    }
 
     if (enabled != mJavaEnabled) {
       mJavaEnabled = enabled;
       // We want to keep the java PluginTag around so we'll know that it's
       // actually disabled, not just not present.  So just manually mark it as
       // disabled so at least FindPluginForType/Extension doesn't return
       // anything.
       for (nsPluginTag* cur = mPlugins; cur; cur = cur->mNext) {
         if (cur->mIsJavaPlugin)
           cur->SetDisabled(!mJavaEnabled);
       }            
     }
   }
   return NS_OK;
 }
 
-////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP
 nsPluginHostImpl::HandleBadPlugin(PRLibrary* aLibrary, nsIPluginInstance *aInstance)
 {
   // the |aLibrary| parameter is not needed anymore, after we added |aInstance| which
   // can also be used to look up the plugin name, but we cannot get rid of it because
   // the |nsIPluginHost| interface is deprecated which in fact means 'frozen'
 
   nsresult rv = NS_OK;
 
   NS_ASSERTION(PR_FALSE, "Plugin performed illegal operation");
 
-  if(mDontShowBadPluginMessage)
+  if (mDontShowBadPluginMessage)
     return rv;
 
   nsCOMPtr<nsIPluginInstanceOwner> owner;
 
   if (aInstance) {
     nsCOMPtr<nsIPluginInstancePeer> peer;
     rv = aInstance->GetPeer(getter_AddRefs(peer));
     if (NS_SUCCEEDED(rv) && peer) {
@@ -6615,29 +6256,27 @@ nsPluginHostImpl::HandleBadPlugin(PRLibr
 
     if (NS_SUCCEEDED(rv) && checkboxState)
       mDontShowBadPluginMessage = PR_TRUE;
   }
 
   return rv;
 }
 
-/**
- *  nsPIPluginHost interface
- */
+// nsPIPluginHost interface
 
 NS_IMETHODIMP
 nsPluginHostImpl::SetIsScriptableInstance(nsIPluginInstance * aPluginInstance, PRBool aScriptable)
 {
   nsActivePlugin * p = mActivePluginList.find(aPluginInstance);
-  if(p == nsnull)
+  if (p == nsnull)
     return NS_ERROR_FAILURE;
 
   p->mXPConnected = aScriptable;
-  if(p->mPluginTag)
+  if (p->mPluginTag)
     p->mPluginTag->mXPConnected = aScriptable;
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsPluginHostImpl::ParsePostBufferToFixHeaders(
                             const char *inPostData, PRUint32 inPostDataLen,
@@ -6946,17 +6585,17 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsPluginHostImpl::GetPluginName(nsIPluginInstance *aPluginInstance,
                                 const char** aPluginName)
 {
   *aPluginName = GetPluginName(aPluginInstance);
   return NS_OK;
 }
 
-/* ----- end of nsPIPluginHost implementation ----- */
+// end of nsPIPluginHost implementation
 
 nsresult
 nsPluginHostImpl::ScanForRealInComponentsFolder(nsIComponentManager * aCompManager)
 {
   nsresult rv = NS_OK;
 
 #ifdef XP_WIN
 
@@ -7035,17 +6674,16 @@ nsresult nsPluginHostImpl::AddPrefObserv
 nsresult nsPluginHostImpl::AddPrefObserver()
 {
   nsCOMPtr<nsIPrefBranch2> prefBranch(do_QueryInterface(mPrefService));
   NS_ENSURE_TRUE(prefBranch, NS_ERROR_UNEXPECTED);
   
   return prefBranch->AddObserver("security.enable_java", this, PR_TRUE);
 }
 
-////////////////////////////////////////////////////////////////////////////////////
 nsresult nsPluginStreamListenerPeer::ServeStreamAsFile(nsIRequest *request,
                                                        nsISupports* aContext)
 {
   if (!mInstance)
     return NS_ERROR_FAILURE;
 
   // mInstance->Stop calls mPStreamListener->CleanUpStream(), so stream will be properly clean up
   mInstance->Stop();
@@ -7093,17 +6731,16 @@ nsresult nsPluginStreamListenerPeer::Ser
   }
 
   // unset mPendingRequests
   mPendingRequests = 0;
 
   return NS_OK;
 }
 
-//////////////////////////////////////////////////////////////////////
 NS_IMPL_ISUPPORTS1(nsPluginByteRangeStreamListener, nsIStreamListener)
 nsPluginByteRangeStreamListener::nsPluginByteRangeStreamListener(nsIWeakReference* aWeakPtr)
 {
   mWeakPtrPluginStreamListenerPeer = aWeakPtr;
   mRemoveMagicNumber = PR_FALSE;
 }
 
 nsPluginByteRangeStreamListener::~nsPluginByteRangeStreamListener()
@@ -7232,17 +6869,16 @@ nsPluginStreamInfo::UseExistingPluginCac
 
 void
 nsPluginStreamInfo::SetStreamComplete(const PRBool complete)
 {
   mStreamComplete = complete;
 
   if (complete) {
     // We're done, release the request.
-
     SetRequest(nsnull);
   }
 }
 
 // Runnable that does an async destroy of a plugin.
 
 class nsPluginDestroyRunnable : public nsRunnable,
                                 public PRCList
@@ -7267,44 +6903,40 @@ public:
     // Null out mInstance to make sure this code in another runnable
     // will do the right thing even if someone was holding on to this
     // runnable longer than we expect.
     instance.swap(mInstance);
 
     if (PluginDestructionGuard::DelayDestroy(instance)) {
       // It's still not safe to destroy the plugin, it's now up to the
       // outermost guard on the stack to take care of the destruction.
-
       return NS_OK;
     }
 
     nsPluginDestroyRunnable *r =
       static_cast<nsPluginDestroyRunnable*>(PR_NEXT_LINK(&sRunnableListHead));
 
     while (r != &sRunnableListHead) {
       if (r != this && r->mInstance == instance) {
         // There's another runnable scheduled to tear down
         // instance. Let it do the job.
- 
         return NS_OK;
       }
-
       r = static_cast<nsPluginDestroyRunnable*>(PR_NEXT_LINK(r));
     }
 
     PLUGIN_LOG(PLUGIN_LOG_NORMAL,
                ("Doing delayed destroy of instance %p\n", instance.get()));
 
     instance->Stop();
 
     nsRefPtr<nsPluginHostImpl> host = nsPluginHostImpl::GetInst();
 
-    if (host) {
+    if (host)
       host->StopPluginInstance(instance);
-    }
 
     PLUGIN_LOG(PLUGIN_LOG_NORMAL,
                ("Done with delayed destroy of instance %p\n", instance.get()));
 
     return NS_OK;
   }
 
 protected:
@@ -7350,14 +6982,13 @@ PluginDestructionGuard::DelayDestroy(nsI
     static_cast<PluginDestructionGuard*>(PR_LIST_HEAD(&sListHead));
 
   while (g != &sListHead) {
     if (g->mInstance == aInstance) {
       g->mDelayedDestroy = PR_TRUE;
 
       return PR_TRUE;
     }
-
     g = static_cast<PluginDestructionGuard*>(PR_NEXT_LINK(g));    
   }
 
   return PR_FALSE;
 }
diff -r 4f1383af8f10 modules/plugin/base/src/nsPluginHostImpl.h
--- a/modules/plugin/base/src/nsPluginHostImpl.h	Sat Nov 01 09:52:29 2008 +0100
+++ b/modules/plugin/base/src/nsPluginHostImpl.h	Mon Nov 03 05:09:10 2008 -0500
@@ -53,29 +53,27 @@
 #include "nsIPlugin.h"
 #include "nsIPluginTag.h"
 #include "nsIPluginTagInfo2.h"
 #include "nsIPluginInstancePeer2.h"
 
 #include "nsIFileUtilities.h"
 #include "nsICookieStorage.h"
 #include "nsPluginsDir.h"
-#include "nsVoidArray.h"  // array for holding "active" streams
+#include "nsVoidArray.h"
 #include "nsPluginDirServiceProvider.h"
 #include "nsAutoPtr.h"
 #include "nsWeakPtr.h"
 #include "nsIPrompt.h"
 #include "nsISupportsArray.h"
 #include "nsPluginNativeWindow.h"
 #include "nsIPrefBranch.h"
 #include "nsWeakReference.h"
 #include "nsThreadUtils.h"
 #include "nsTArray.h"
-
-// XXX this file really doesn't think this is possible, but ...
 #include "nsIFactory.h"
 
 class nsNPAPIPlugin;
 class nsIComponentManager;
 class nsIFile;
 class nsIChannel;
 class nsIRegistry;
 class nsPluginHostImpl;
@@ -181,17 +179,17 @@ struct nsActivePlugin
   char*                  mURL;
   nsIPluginInstancePeer* mPeer;
   nsRefPtr<nsPluginTag>  mPluginTag;
   nsIPluginInstance*     mInstance;
   PRTime                 mllStopTime;
   PRPackedBool           mStopped;
   PRPackedBool           mDefaultPlugin;
   PRPackedBool           mXPConnected;
-  //Array holding all opened stream listeners for this entry
+  // Array holding all opened stream listeners for this entry
   nsCOMPtr <nsISupportsArray>  mStreams; 
 
   nsActivePlugin(nsPluginTag* aPluginTag,
                  nsIPluginInstance* aInstance, 
                  const char * url,
                  PRBool aDefaultPlugin,
                  nsIPluginInstancePeer *peer);
   ~nsActivePlugin();
diff -r 4f1383af8f10 modules/plugin/test/Makefile.in
--- a/modules/plugin/test/Makefile.in	Sat Nov 01 09:52:29 2008 +0100
+++ b/modules/plugin/test/Makefile.in	Mon Nov 03 05:09:10 2008 -0500
@@ -37,13 +37,17 @@
 
 DEPTH		= ../../..
 topsrcdir	= @top_srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
-MODULE = plugin
+MODULE = test_plugin
 
 DIRS = testplugin
 
+XPCSHELL_TESTS = \
+  unit \
+  $(NULL)
+
 include $(topsrcdir)/config/rules.mk
diff -r 4f1383af8f10 modules/plugin/test/unit/test_bug455213.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/modules/plugin/test/unit/test_bug455213.js	Mon Nov 03 05:09:10 2008 -0500
@@ -0,0 +1,188 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *      Dave Townsend <dtownsend@oxymoronical.com>.
+ *
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK *****
+ */
+
+const Cc = Components.classes;
+const Ci = Components.interfaces;
+
+const NS_APP_USER_PROFILE_50_DIR      = "ProfD";
+const NS_APP_PROFILE_DIR_STARTUP      = "ProfDS";
+
+// Plugin registry uses different field delimeters on different platforms
+var DELIM = ":";
+if ("@mozilla.org/windows-registry-key;1" in Components.classes)
+  DELIM = "|";
+
+var gProfD;
+var gDirSvc = Cc["@mozilla.org/file/directory_service;1"].
+             getService(Ci.nsIProperties);
+
+// Creates a fake profile folder that the pluginhost will read our crafted
+// pluginreg.dat from
+function createProfileFolder() {
+  gProfD = gDirSvc.get("CurProcD", Ci.nsILocalFile);
+  gProfD = gProfD.parent.parent;
+  gProfD.append("_tests");
+  gProfD.append("xpcshell-simple");
+  gProfD.append("test_plugin");
+  gProfD.append("profile");
+  
+  if (gProfD.exists())
+    gProfD.remove(true);
+  gProfD.create(Components.interfaces.nsIFile.DIRECTORY_TYPE, 0755);
+  
+  var dirProvider = {
+    getFile: function(prop, persistent) {
+      persistent.value = true;
+      if (prop == NS_APP_USER_PROFILE_50_DIR ||
+          prop == NS_APP_PROFILE_DIR_STARTUP)
+        return gProfD.clone();
+      return null;
+    },
+    QueryInterface: function(iid) {
+      if (iid.equals(Ci.nsIDirectoryServiceProvider) ||
+          iid.equals(Ci.nsISupports)) {
+        return this;
+      }
+      throw Components.results.NS_ERROR_NO_INTERFACE;
+    }
+  };
+  gDirSvc.QueryInterface(Ci.nsIDirectoryService)
+         .registerProvider(dirProvider);
+}
+
+// Writes out some plugin registry to the profile
+function write_registry(version, info) {
+  var header = "Generated File. Do not edit.\n\n";
+  header += "[HEADER]\n";
+  header += "Version" + DELIM + version + DELIM + "$\n\n";
+  header += "[PLUGINS]\n";
+
+  var registry = gProfD.clone();
+  registry.append("pluginreg.dat");
+  var foStream = Components.classes["@mozilla.org/network/file-output-stream;1"]
+                           .createInstance(Components.interfaces.nsIFileOutputStream);
+  // write, create, truncate
+  foStream.init(registry, 0x02 | 0x08 | 0x20, 0666, 0); 
+
+  var charset = "UTF-8"; // Can be any character encoding name that Mozilla supports
+  var os = Cc["@mozilla.org/intl/converter-output-stream;1"].
+           createInstance(Ci.nsIConverterOutputStream);
+  os.init(foStream, charset, 0, 0x0000);
+  
+  os.writeString(header);
+  os.writeString(info);
+  os.close();
+}
+
+// Finds the test plugin library
+function get_test_plugin() {
+  var plugins = gDirSvc.get("CurProcD", Ci.nsILocalFile);
+  plugins.append("plugins");
+  do_check_true(plugins.exists());
+  var plugin = plugins.clone();
+  // OSX plugin
+  plugin.append("Test.plugin");
+  if (plugin.exists()) {
+    plugin.normalize();
+    return plugin;
+  }
+  plugin = plugins.clone();
+  // *nix plugin
+  plugin.append("libnptest.so");
+  if (plugin.exists()) {
+    plugin.normalize();
+    return plugin;
+  }
+  // Windows plugin
+  plugin = plugins.clone();
+  plugin.append("nptest.dll");
+  if (plugin.exists()) {
+    plugin.normalize();
+    return plugin;
+  }
+  return null;
+}
+
+// Finds the test nsIPluginTag
+function get_test_plugintag() {
+  var host = Cc["@mozilla.org/plugin/host;1"].
+             getService(Ci.nsIPluginHost);
+  var tags = host.getPluginTags({});
+  for (var i = 0; i < tags.length; i++) {
+    if (tags[i].name == "Test Plug-in")
+      return tags[i];
+  }
+  return null;
+}
+
+function run_test() {
+  createProfileFolder();
+  var file = get_test_plugin();
+  if (!file)
+    do_throw("Plugin library not found");
+
+  // Write out a 0.9 version registry that marks the test plugin as disabled
+  var registry = "";
+  registry += file.leafName + DELIM + "$\n";
+  registry += file.path + DELIM + "$\n";
+  registry += file.lastModifiedTime + DELIM + "0" + DELIM + "0" + DELIM + "$\n";
+  registry += "Plug-in for testing purposes." + DELIM + "$\n";
+  registry += "Test Plug-in" + DELIM + "$\n";
+  registry += "1\n";
+  registry += "0" + DELIM + "application/x-test" + DELIM + "Test mimetype" +
+              DELIM + "tst" + DELIM + "$\n";
+  write_registry("0.9", registry);
+
+  var plugin = get_test_plugintag();
+  if (!plugin)
+    do_throw("Plugin tag not found");
+
+  // If the plugin was not rescanned then this version will not be correct
+  do_check_eq(plugin.version, "1.0.0.0");
+  do_check_eq(plugin.description, "Plug-in for testing purposes.");
+  // If the plugin registry was not read then the plugin will not be disabled
+  do_check_true(plugin.disabled);
+  do_check_false(plugin.blocklisted);
+
+  try {
+    gProfD.remove(true);
+  }
+  catch (e) {
+    // Failure to remove temp dir shouldn't be a test failure
+  }
+}
diff -r 4f1383af8f10 netwerk/base/public/nsNetUtil.h
--- a/netwerk/base/public/nsNetUtil.h	Sat Nov 01 09:52:29 2008 +0100
+++ b/netwerk/base/public/nsNetUtil.h	Mon Nov 03 05:09:10 2008 -0500
@@ -1438,32 +1438,16 @@ NS_GetFinalChannelURI(nsIChannel* channe
     
     if (loadFlags & nsIChannel::LOAD_REPLACE) {
         return channel->GetURI(uri);
     }
     
     return channel->GetOriginalURI(uri);
 }
 
-static inline PRInt32
-GetEffectivePort(nsIURI* aURI)
-{
-    PRInt32 port;
-
-    nsCOMPtr<nsIURI> baseURI = NS_GetInnermostURI(aURI);
-    if (NS_SUCCEEDED(baseURI->GetPort(&port)) && port != -1)
-        return port;
-
-    nsCAutoString scheme;
-    if (NS_FAILED(baseURI->GetScheme(scheme)))
-        return -1;
-
-    return NS_GetDefaultPort(scheme.get());
-}
-
 // NS_SecurityHashURI must return the same hash value for any two URIs that
 // compare equal according to NS_SecurityCompareURIs.  Unfortunately, in the
 // case of files, it's not clear we can do anything better than returning
 // the schemeHash, so hashing files degenerates to storing them in a list.
 inline PRUint32
 NS_SecurityHashURI(nsIURI* aURI)
 {
     nsCOMPtr<nsIURI> baseURI = NS_GetInnermostURI(aURI);
@@ -1489,17 +1473,17 @@ NS_SecurityHashURI(nsIURI* aURI)
     }
 
     nsCAutoString host;
     PRUint32 hostHash = 0;
     if (NS_SUCCEEDED(baseURI->GetHost(host)))
         hostHash = nsCRT::HashCode(host.get());
 
     // XOR to combine hash values
-    return schemeHash ^ hostHash ^ GetEffectivePort(aURI);
+    return schemeHash ^ hostHash ^ NS_GetRealPort(baseURI);
 }
 
 inline PRBool
 NS_SecurityCompareURIs(nsIURI* aSourceURI,
                        nsIURI* aTargetURI,
                        PRBool aStrictFileOriginPolicy)
 {
     // Note that this is not an Equals() test on purpose -- for URIs that don't
@@ -1589,12 +1573,12 @@ NS_SecurityCompareURIs(nsIURI* aSourceUR
     if (!targetHost.Equals(sourceHost, nsCaseInsensitiveCStringComparator() ))
 #else
     if (!targetHost.Equals(sourceHost, CaseInsensitiveCompare))
 #endif
     {
         return PR_FALSE;
     }
 
-    return GetEffectivePort(targetBaseURI) == GetEffectivePort(sourceBaseURI);
+    return NS_GetRealPort(targetBaseURI) == NS_GetRealPort(sourceBaseURI);
 }
 
 #endif // !nsNetUtil_h__
diff -r 4f1383af8f10 netwerk/test/httpserver/Makefile.in
--- a/netwerk/test/httpserver/Makefile.in	Sat Nov 01 09:52:29 2008 +0100
+++ b/netwerk/test/httpserver/Makefile.in	Mon Nov 03 05:09:10 2008 -0500
@@ -8,17 +8,17 @@
 # the License. You may obtain a copy of the License at
 # http://www.mozilla.org/MPL/
 #
 # Software distributed under the License is distributed on an "AS IS" basis,
 # WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 # for the specific language governing rights and limitations under the
 # License.
 #
-# The Original Code is MozJSHTTP code.
+# The Original Code is httpd.js code.
 #
 # The Initial Developer of the Original Code is
 # Jeff Walden <jwalden+code@mit.edu>.
 # Portions created by the Initial Developer are Copyright (C) 2006
 # the Initial Developer. All Rights Reserved.
 #
 # Contributor(s):
 #
diff -r 4f1383af8f10 netwerk/test/httpserver/httpd.js
--- a/netwerk/test/httpserver/httpd.js	Sat Nov 01 09:52:29 2008 +0100
+++ b/netwerk/test/httpserver/httpd.js	Mon Nov 03 05:09:10 2008 -0500
@@ -8,17 +8,17 @@
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
- * The Original Code is the MozJSHTTP server.
+ * The Original Code is the httpd.js server.
  *
  * The Initial Developer of the Original Code is
  * Mozilla Corporation.
  * Portions created by the Initial Developer are Copyright (C) 2006
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Darin Fisher (v1, netwerk/test/TestServ.js)
@@ -38,17 +38,17 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 /*
  * An implementation of an HTTP server both as a loadable script and as an XPCOM
  * component.  See the accompanying README file for user documentation on
- * MozJSHTTP.
+ * httpd.js.
  */
 
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cr = Components.results;
 const Cu = Components.utils;
 const CC = Components.Constructor;
 
@@ -2936,20 +2936,20 @@ ServerHandler.prototype =
   _defaultPaths:
   {
     "/": function(metadata, response)
     {
       response.setStatusLine(metadata.httpVersion, 200, "OK");
       response.setHeader("Content-Type", "text/html", false);
 
       var body = "<html>\
-                    <head><title>MozJSHTTP</title></head>\
+                    <head><title>httpd.js</title></head>\
                     <body>\
-                      <h1>MozJSHTTP</h1>\
-                      <p>If you're seeing this page, MozJSHTTP is up and\
+                      <h1>httpd.js</h1>\
+                      <p>If you're seeing this page, httpd.js is up and\
                         serving requests!  Now set a base path and serve some\
                         files!</p>\
                     </body>\
                   </html>";
 
       response.bodyOutputStream.write(body, body.length);
     },
 
@@ -3900,17 +3900,17 @@ const module =
 
   // private implementation
   _objects:
   {
     server:
     {
       CID:         Components.ID("{54ef6f81-30af-4b1d-ac55-8ba811293e41}"),
       contractID:  "@mozilla.org/server/jshttp;1",
-      className:   "MozJSHTTP server",
+      className:   "httpd.js server",
       factory:     makeFactory(nsHttpServer)
     }
   }
 };
 
 
 /** NSGetModule, so this code can be used as a JS component. */
 function NSGetModule(compMgr, fileSpec)
diff -r 4f1383af8f10 netwerk/test/httpserver/nsIHttpServer.idl
--- a/netwerk/test/httpserver/nsIHttpServer.idl	Sat Nov 01 09:52:29 2008 +0100
+++ b/netwerk/test/httpserver/nsIHttpServer.idl	Mon Nov 03 05:09:10 2008 -0500
@@ -6,17 +6,17 @@
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
- * The Original Code is the MozJSHTTP server.
+ * The Original Code is the httpd.js server.
  *
  * The Initial Developer of the Original Code is
  * Mozilla Corporation.
  * Portions created by the Initial Developer are Copyright (C) 2006
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Jeff Walden <jwalden+code@mit.edu>          (original author)
diff -r 4f1383af8f10 netwerk/test/httpserver/test/head_utils.js
--- a/netwerk/test/httpserver/test/head_utils.js	Sat Nov 01 09:52:29 2008 +0100
+++ b/netwerk/test/httpserver/test/head_utils.js	Mon Nov 03 05:09:10 2008 -0500
@@ -8,17 +8,17 @@
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
- * The Original Code is MozJSHTTP code.
+ * The Original Code is httpd.js code.
  *
  * The Initial Developer of the Original Code is
  * Jeff Walden <jwalden+code@mit.edu>.
  * Portions created by the Initial Developer are Copyright (C) 2006
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *
diff -r 4f1383af8f10 netwerk/test/httpserver/test/test_basic_functionality.js
--- a/netwerk/test/httpserver/test/test_basic_functionality.js	Sat Nov 01 09:52:29 2008 +0100
+++ b/netwerk/test/httpserver/test/test_basic_functionality.js	Mon Nov 03 05:09:10 2008 -0500
@@ -8,17 +8,17 @@
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
- * The Original Code is MozJSHTTP code.
+ * The Original Code is httpd.js code.
  *
  * The Initial Developer of the Original Code is
  * Jeff Walden <jwalden+code@mit.edu>.
  * Portions created by the Initial Developer are Copyright (C) 2006
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *
diff -r 4f1383af8f10 netwerk/test/httpserver/test/test_byte_range.js
--- a/netwerk/test/httpserver/test/test_byte_range.js	Sat Nov 01 09:52:29 2008 +0100
+++ b/netwerk/test/httpserver/test/test_byte_range.js	Mon Nov 03 05:09:10 2008 -0500
@@ -8,17 +8,17 @@
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
- * The Original Code is MozJSHTTP code.
+ * The Original Code is httpd.js code.
  *
  * The Initial Developer of the Original Code is
  * Chris Double <chris.double@double.co.nz>.
  *
  * Contributor(s):
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
diff -r 4f1383af8f10 netwerk/test/httpserver/test/test_cern_meta.js
--- a/netwerk/test/httpserver/test/test_cern_meta.js	Sat Nov 01 09:52:29 2008 +0100
+++ b/netwerk/test/httpserver/test/test_cern_meta.js	Mon Nov 03 05:09:10 2008 -0500
@@ -8,17 +8,17 @@
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
- * The Original Code is MozJSHTTP code.
+ * The Original Code is httpd.js code.
  *
  * The Initial Developer of the Original Code is
  * Jeff Walden <jwalden+code@mit.edu>.
  * Portions created by the Initial Developer are Copyright (C) 2007
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *
diff -r 4f1383af8f10 netwerk/test/httpserver/test/test_default_index_handler.js
--- a/netwerk/test/httpserver/test/test_default_index_handler.js	Sat Nov 01 09:52:29 2008 +0100
+++ b/netwerk/test/httpserver/test/test_default_index_handler.js	Mon Nov 03 05:09:10 2008 -0500
@@ -8,17 +8,17 @@
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
- * The Original Code is MozJSHTTP code.
+ * The Original Code is httpd.js code.
  *
  * The Initial Developer of the Original Code is
  * Jeff Walden <jwalden+code@mit.edu>.
  * Portions created by the Initial Developer are Copyright (C) 2007
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *
diff -r 4f1383af8f10 netwerk/test/httpserver/test/test_empty_body.js
--- a/netwerk/test/httpserver/test/test_empty_body.js	Sat Nov 01 09:52:29 2008 +0100
+++ b/netwerk/test/httpserver/test/test_empty_body.js	Mon Nov 03 05:09:10 2008 -0500
@@ -8,17 +8,17 @@
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
- * The Original Code is MozJSHTTP code.
+ * The Original Code is httpd.js code.
  *
  * The Initial Developer of the Original Code is
  * Jeff Walden <jwalden+code@mit.edu>.
  * Portions created by the Initial Developer are Copyright (C) 2006
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *
diff -r 4f1383af8f10 netwerk/test/httpserver/test/test_errorhandler_exception.js
--- a/netwerk/test/httpserver/test/test_errorhandler_exception.js	Sat Nov 01 09:52:29 2008 +0100
+++ b/netwerk/test/httpserver/test/test_errorhandler_exception.js	Mon Nov 03 05:09:10 2008 -0500
@@ -8,17 +8,17 @@
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
- * The Original Code is MozJSHTTP code.
+ * The Original Code is httpd.js code.
  *
  * The Initial Developer of the Original Code is
  * Jeff Walden <jwalden+code@mit.edu>.
  * Portions created by the Initial Developer are Copyright (C) 2006
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *
diff -r 4f1383af8f10 netwerk/test/httpserver/test/test_headers.js
--- a/netwerk/test/httpserver/test/test_headers.js	Sat Nov 01 09:52:29 2008 +0100
+++ b/netwerk/test/httpserver/test/test_headers.js	Mon Nov 03 05:09:10 2008 -0500
@@ -8,17 +8,17 @@
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
- * The Original Code is MozJSHTTP code.
+ * The Original Code is httpd.js code.
  *
  * The Initial Developer of the Original Code is
  * Jeff Walden <jwalden+code@mit.edu>.
  * Portions created by the Initial Developer are Copyright (C) 2006
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *
@@ -31,17 +31,17 @@
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
-// tests for header storage in MozJSHTTP; nsHttpHeaders is an *internal* data
+// tests for header storage in httpd.js; nsHttpHeaders is an *internal* data
 // structure and is not to be used directly outside of httpd.js itself except
 // for testing purposes
 
 
 /**
  * Ensures that a fieldname-fieldvalue combination is a valid header.
  *
  * @param fieldName
diff -r 4f1383af8f10 netwerk/test/httpserver/test/test_host.js
--- a/netwerk/test/httpserver/test/test_host.js	Sat Nov 01 09:52:29 2008 +0100
+++ b/netwerk/test/httpserver/test/test_host.js	Mon Nov 03 05:09:10 2008 -0500
@@ -8,17 +8,17 @@
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
- * The Original Code is MozJSHTTP code.
+ * The Original Code is httpd.js code.
  *
  * The Initial Developer of the Original Code is
  * Jeff Walden <jwalden+code@mit.edu>.
  * Portions created by the Initial Developer are Copyright (C) 2008
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *
diff -r 4f1383af8f10 netwerk/test/httpserver/test/test_name_scheme.js
--- a/netwerk/test/httpserver/test/test_name_scheme.js	Sat Nov 01 09:52:29 2008 +0100
+++ b/netwerk/test/httpserver/test/test_name_scheme.js	Mon Nov 03 05:09:10 2008 -0500
@@ -8,17 +8,17 @@
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
- * The Original Code is MozJSHTTP code.
+ * The Original Code is httpd.js code.
  *
  * The Initial Developer of the Original Code is
  * Jeff Walden <jwalden+code@mit.edu>.
  * Portions created by the Initial Developer are Copyright (C) 2007
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *
diff -r 4f1383af8f10 netwerk/test/httpserver/test/test_registerdirectory.js
--- a/netwerk/test/httpserver/test/test_registerdirectory.js	Sat Nov 01 09:52:29 2008 +0100
+++ b/netwerk/test/httpserver/test/test_registerdirectory.js	Mon Nov 03 05:09:10 2008 -0500
@@ -8,17 +8,17 @@
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
- * The Original Code is MozJSHTTP code.
+ * The Original Code is httpd.js code.
  *
  * The Initial Developer of the Original Code is
  * Jeff Walden <jwalden+code@mit.edu>.
  * Portions created by the Initial Developer are Copyright (C) 2006
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *
diff -r 4f1383af8f10 netwerk/test/httpserver/test/test_registerfile.js
--- a/netwerk/test/httpserver/test/test_registerfile.js	Sat Nov 01 09:52:29 2008 +0100
+++ b/netwerk/test/httpserver/test/test_registerfile.js	Mon Nov 03 05:09:10 2008 -0500
@@ -8,17 +8,17 @@
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
- * The Original Code is MozJSHTTP code.
+ * The Original Code is httpd.js code.
  *
  * The Initial Developer of the Original Code is
  * Jeff Walden <jwalden+code@mit.edu>.
  * Portions created by the Initial Developer are Copyright (C) 2007
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *
diff -r 4f1383af8f10 netwerk/test/httpserver/test/test_remotesetpath.js
--- a/netwerk/test/httpserver/test/test_remotesetpath.js	Sat Nov 01 09:52:29 2008 +0100
+++ b/netwerk/test/httpserver/test/test_remotesetpath.js	Mon Nov 03 05:09:10 2008 -0500
@@ -8,17 +8,17 @@
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
- * The Original Code is MozJSHTTP code.
+ * The Original Code is httpd.js code.
  *
  * The Initial Developer of the Original Code is
  * Jeff Walden <jwalden+code@mit.edu>.
  * Portions created by the Initial Developer are Copyright (C) 2006
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *
diff -r 4f1383af8f10 netwerk/test/httpserver/test/test_response_write.js
--- a/netwerk/test/httpserver/test/test_response_write.js	Sat Nov 01 09:52:29 2008 +0100
+++ b/netwerk/test/httpserver/test/test_response_write.js	Mon Nov 03 05:09:10 2008 -0500
@@ -8,17 +8,17 @@
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
- * The Original Code is MozJSHTTP code.
+ * The Original Code is httpd.js code.
  *
  * The Initial Developer of the Original Code is
  * Jeff Walden <jwalden+code@mit.edu>.
  * Portions created by the Initial Developer are Copyright (C) 2006
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *
diff -r 4f1383af8f10 netwerk/test/httpserver/test/test_setindexhandler.js
--- a/netwerk/test/httpserver/test/test_setindexhandler.js	Sat Nov 01 09:52:29 2008 +0100
+++ b/netwerk/test/httpserver/test/test_setindexhandler.js	Mon Nov 03 05:09:10 2008 -0500
@@ -8,17 +8,17 @@
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
- * The Original Code is MozJSHTTP code.
+ * The Original Code is httpd.js code.
  *
  * The Initial Developer of the Original Code is
  * Jeff Walden <jwalden+code@mit.edu>.
  * Portions created by the Initial Developer are Copyright (C) 2006
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *
diff -r 4f1383af8f10 netwerk/test/httpserver/test/test_setstatusline.js
--- a/netwerk/test/httpserver/test/test_setstatusline.js	Sat Nov 01 09:52:29 2008 +0100
+++ b/netwerk/test/httpserver/test/test_setstatusline.js	Mon Nov 03 05:09:10 2008 -0500
@@ -8,17 +8,17 @@
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
- * The Original Code is MozJSHTTP code.
+ * The Original Code is httpd.js code.
  *
  * The Initial Developer of the Original Code is
  * Jeff Walden <jwalden+code@mit.edu>.
  * Portions created by the Initial Developer are Copyright (C) 2006
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *
diff -r 4f1383af8f10 testing/mochitest/browser-harness.xul
--- a/testing/mochitest/browser-harness.xul	Sat Nov 01 09:52:29 2008 +0100
+++ b/testing/mochitest/browser-harness.xul	Mon Nov 03 05:09:10 2008 -0500
@@ -18,16 +18,17 @@
    - The Initial Developer of the Original Code is
    - Mozilla Corporation.
    -
    - Portions created by the Initial Developer are Copyright (C) 2007
    - the Initial Developer. All Rights Reserved.
    -
    - Contributor(s):
    -      Gavin Sharp <gavin@gavinsharp.com> (original author)
+   -      Ehsan Akhgari <ehsan.akhgari@gmail.com>
    -
    - Alternatively, the contents of this file may be used under the terms of
    - either the GNU General Public License Version 2 or later (the "GPL"), or
    - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    - in which case the provisions of the GPL or the LGPL are applicable instead
    - of those above. If you wish to allow use of your version of this file only
    - under the terms of either the GPL or the LGPL, and not to allow others to
    - use your version of this file under the terms of the MPL, indicate your
@@ -156,21 +157,27 @@
       },
       get log() {
         var path = this.path;
         return this.tests.map(function (t) {
                                   return t.result + " | " + path + " | " + t.msg;
                               }).join("\n");
       },
       get htmlLog() {
-        var path = this.path;
+        let txtToHTML = Cc["@mozilla.org/txttohtmlconv;1"].
+                        getService(Ci.mozITXTToHTMLConv);
+        function _entityEncode(str) {
+          return txtToHTML.scanTXT(str, Ci.mozITXTToHTMLConv.kEntities);
+        }
+        var path = _entityEncode( this.path );
         return this.tests.map(function (t) {
                                   var result = "<p class=\"result ";
                                   result += t.pass ? "passed" : "failed";
-                                  result += "\">" + t.result + " | " + path + " | " + t.msg + "</p>";
+                                  result += "\">" + t.result + " | " + path +
+                                    " | " + _entityEncode( t.msg ) + "</p>";
                                   return result;
                               }).join("\n");
       }
     };
 
     // Returns an array of chrome:// URLs to all the test files
     function listTests() {
       const Cc = Components.classes; const Ci = Components.interfaces;
diff -r 4f1383af8f10 testing/mochitest/tests/SimpleTest/EventUtils.js
--- a/testing/mochitest/tests/SimpleTest/EventUtils.js	Sat Nov 01 09:52:29 2008 +0100
+++ b/testing/mochitest/tests/SimpleTest/EventUtils.js	Mon Nov 03 05:09:10 2008 -0500
@@ -206,25 +206,28 @@ function synthesizeMouse(aTarget, aOffse
   var utils = aWindow.QueryInterface(Components.interfaces.nsIInterfaceRequestor).
                       getInterface(Components.interfaces.nsIDOMWindowUtils);
   if (utils) {
     var button = aEvent.button || 0;
     var clickCount = aEvent.clickCount || 1;
     var modifiers = _parseModifiers(aEvent);
 
     var rect = aTarget.getBoundingClientRect();
-    var left = rect.left;
-    var top = rect.top;
+
+    // Need to round, since rect could have non-integer coordinates, and sadly
+    // our event code can't deal with fractional pixel click coords.
+    var left = Math.round(rect.left + aOffsetX);
+    var top = Math.round(rect.top + aOffsetY);
 
     if (aEvent.type) {
-      utils.sendMouseEvent(aEvent.type, left + aOffsetX, top + aOffsetY, button, clickCount, modifiers);
+      utils.sendMouseEvent(aEvent.type, left, top, button, clickCount, modifiers);
     }
     else {
-      utils.sendMouseEvent("mousedown", left + aOffsetX, top + aOffsetY, button, clickCount, modifiers);
-      utils.sendMouseEvent("mouseup", left + aOffsetX, top + aOffsetY, button, clickCount, modifiers);
+      utils.sendMouseEvent("mousedown", left, top, button, clickCount, modifiers);
+      utils.sendMouseEvent("mouseup", left, top, button, clickCount, modifiers);
     }
   }
 }
 
 /**
  * Synthesize a mouse scroll event on a target. The actual client point is determined
  * by taking the aTarget's client box and offseting it by aOffsetX and
  * aOffsetY.
diff -r 4f1383af8f10 toolkit/content/tests/widgets/window_tooltip.xul
--- a/toolkit/content/tests/widgets/window_tooltip.xul	Sat Nov 01 09:52:29 2008 +0100
+++ b/toolkit/content/tests/widgets/window_tooltip.xul	Mon Nov 03 05:09:10 2008 -0500
@@ -39,19 +39,19 @@ function checkCoords(event)
 function checkCoords(event)
 {
   // all but one test open the tooltip at the button location offset by 6
   // in each direction. Test 5 opens it at 4 in each direction.
   var mod = (gTestIndex == 5) ? 4 : 6;
 
   var rect = gButton.getBoundingClientRect();
   var popupstyle = window.getComputedStyle(gButton, "");
-  is(event.clientX, Math.floor(rect.left) + mod,
+  is(event.clientX, Math.round(rect.left + mod),
      "step " + (gTestIndex + 1) + " clientX");
-  is(event.clientY, Math.floor(rect.top) + mod,
+  is(event.clientY, Math.round(rect.top + mod),
      "step " + (gTestIndex + 1) + " clientY");
   ok(event.screenX > 0, "step " + (gTestIndex + 1) + " screenX");
   ok(event.screenY > 0, "step " + (gTestIndex + 1) + " screenY");
 }
 
 var popupTests = [
 {
   testname: "hover tooltiptext attribute",
@@ -92,21 +92,21 @@ var popupTests = [
     synthesizeMouse(gButton, 4, 4, { type: "mousemove" });
     synthesizeMouse(gButton, 6, 6, { type: "mousemove" });
   },
   result: function(testname) {
     var buttonrect = document.getElementById("withtooltip").getBoundingClientRect();
     var rect = document.getElementById("thetooltip").getBoundingClientRect();
     var popupstyle = window.getComputedStyle(document.getElementById("thetooltip"), "");
 
-    is(Math.floor(rect.left), Math.floor(buttonrect.left) +
-       parseInt(popupstyle.marginLeft) + 6,
+    is(Math.round(rect.left),
+       Math.round(buttonrect.left + parseFloat(popupstyle.marginLeft) + 6),
        testname + " top position of tooltip");
-    is(Math.floor(rect.top), Math.floor(buttonrect.top) +
-       parseInt(popupstyle.marginTop) + 6,
+    is(Math.round(rect.top),
+       Math.round(buttonrect.top + parseFloat(popupstyle.marginTop) + 6),
        testname + " top position of tooltip");
 
     var labelrect = document.getElementById("label").getBoundingClientRect();
     ok(labelrect.right < rect.right, testname + " tooltip width");
     ok(labelrect.bottom < rect.bottom, testname + " tooltip height");
 
     gOriginalWidth = rect.right - rect.left;
     gOriginalHeight = rect.bottom - rect.top;
@@ -134,21 +134,21 @@ var popupTests = [
     synthesizeMouse(gButton, 4, 4, { type: "mousemove" });
   },
   result: function(testname) {
     var buttonrect = document.getElementById("withtooltip").getBoundingClientRect();
     var rect = document.getElementById("thetooltip").getBoundingClientRect();
     var popupstyle = window.getComputedStyle(document.getElementById("thetooltip"), "");
     var buttonstyle = window.getComputedStyle(document.getElementById("withtooltip"), "");
 
-    is(Math.floor(rect.left), Math.floor(buttonrect.left) +
-       parseInt(popupstyle.marginLeft) + 4,
+    is(Math.round(rect.left),
+       Math.round(buttonrect.left + parseFloat(popupstyle.marginLeft) + 4),
        testname + " top position of tooltip");
-    is(Math.floor(rect.top), Math.floor(buttonrect.top) +
-       parseInt(popupstyle.marginTop) + 4,
+    is(Math.round(rect.top),
+       Math.round(buttonrect.top + parseFloat(popupstyle.marginTop) + 4),
        testname + " top position of tooltip");
 
     var labelrect = document.getElementById("label").getBoundingClientRect();
     ok(labelrect.right < rect.right, testname + " tooltip width");
     ok(labelrect.bottom < rect.bottom, testname + " tooltip height");
 
     // make sure that the tooltip is larger than it was before by just
     // checking against the original height plus an arbitrary 15 pixels
@@ -177,21 +177,21 @@ var popupTests = [
     synthesizeMouse(gButton, 6, 6, { type: "mousemove" });
   },
   result: function(testname) {
     var buttonrect = document.getElementById("withtooltip").getBoundingClientRect();
     var rect = document.getElementById("thetooltip").getBoundingClientRect();
     var popupstyle = window.getComputedStyle(document.getElementById("thetooltip"), "");
     var buttonstyle = window.getComputedStyle(document.getElementById("withtooltip"), "");
 
-    is(Math.floor(rect.left), Math.floor(buttonrect.left) +
-       parseInt(popupstyle.marginLeft) + 6,
+    is(Math.round(rect.left),
+       Math.round(buttonrect.left + parseFloat(popupstyle.marginLeft) + 6),
        testname + " top position of tooltip");
-    is(Math.floor(rect.top), Math.floor(buttonrect.top) +
-       parseInt(popupstyle.marginTop) + 6,
+    is(Math.round(rect.top),
+       Math.round(buttonrect.top + parseFloat(popupstyle.marginTop) + 6),
        testname + " top position of tooltip");
 
     var labelrect = document.getElementById("label").getBoundingClientRect();
     ok(labelrect.right < rect.right, testname + " tooltip width");
     ok(labelrect.bottom < rect.bottom, testname + " tooltip height");
 
     is(gOriginalWidth, rect.right - rect.left, testname + " tooltip is original width");
     is(gOriginalHeight, rect.bottom - rect.top, testname + " tooltip is original height");
diff -r 4f1383af8f10 toolkit/locales/en-US/chrome/mozapps/extensions/blocklist.dtd
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/locales/en-US/chrome/mozapps/extensions/blocklist.dtd	Mon Nov 03 05:09:10 2008 -0500
@@ -0,0 +1,10 @@
+<!ENTITY blocklist.title             "Add-ons may be causing problems">
+<!ENTITY blocklist.style             "width: 45em; height: 30em">
+<!ENTITY blocklist.summary           "&brandShortName; has determined that the following add-ons are known to cause stability or security problems:">
+<!ENTITY blocklist.softblocked       "For your protection, it is highly recommended that you restart with these add-ons disabled.">
+<!ENTITY blocklist.hardblocked       "These add-ons have a high risk of causing stability or security problems and have been blocked, but a restart is required to disable them completely.">
+<!ENTITY blocklist.softandhard       "The add-ons that have a high risk of causing stability or security problems have been blocked. The others are lower risk, but it is highly recommended that you restart with them disabled.">
+<!ENTITY blocklist.moreinfo          "More information">
+
+<!ENTITY blocklist.accept.label      "Restart &brandShortName;">
+<!ENTITY blocklist.accept.accesskey  "R">
diff -r 4f1383af8f10 toolkit/locales/en-US/chrome/mozapps/extensions/extensions.dtd
--- a/toolkit/locales/en-US/chrome/mozapps/extensions/extensions.dtd	Sat Nov 01 09:52:29 2008 +0100
+++ b/toolkit/locales/en-US/chrome/mozapps/extensions/extensions.dtd	Mon Nov 03 05:09:10 2008 -0500
@@ -107,16 +107,17 @@
 <!ENTITY includeUpdate.label              "Include this update">
 <!ENTITY includeUpdate.accesskey          "n">
 <!ENTITY includeUpdate.tooltip            "Include this Add-on when installing the updates">
 
 <!-- Status Messsages -->
 <!ENTITY insecureUpdate.label             "Does not provide secure updates.">
 <!ENTITY needsDependencies.label          "Requires additional items.">
 <!ENTITY blocklisted.label                "Disabled for your protection.">
+<!ENTITY softBlocklisted.label            "Known to cause security or stability issues.">
 <!ENTITY toBeDisabled.label               "This add-on will be disabled when &brandShortName; is restarted.">
 <!ENTITY toBeEnabled.label                "This add-on will be enabled when &brandShortName; is restarted.">
 <!ENTITY toBeInstalled.label              "This add-on will be installed when &brandShortName; is restarted.">
 <!ENTITY toBeUninstalled.label            "This add-on will be uninstalled when &brandShortName; is restarted.">
 <!ENTITY toBeUpdated.label                "This add-on will be updated when &brandShortName; is restarted.">
 
 <!ENTITY getExtensions.label              "Get Extensions">
 <!ENTITY getThemes.label                  "Get Themes">
@@ -163,8 +164,11 @@
 <!ENTITY installFailure.label             "Install failed.">
 
 <!ENTITY progressStatus.label             "Checking For Updates">
 
 <!ENTITY eula.title                       "End-User License Agreement">
 <!ENTITY eula.width                       "560px">
 <!ENTITY eula.height                      "400px">
 <!ENTITY eula.accept                      "Accept and Install">
+
+<!ENTITY blocklist.blocked.label          "Blocked">
+<!ENTITY blocklist.checkbox.label         "Disable">
diff -r 4f1383af8f10 toolkit/locales/en-US/chrome/mozapps/extensions/extensions.properties
--- a/toolkit/locales/en-US/chrome/mozapps/extensions/extensions.properties	Sat Nov 01 09:52:29 2008 +0100
+++ b/toolkit/locales/en-US/chrome/mozapps/extensions/extensions.properties	Mon Nov 03 05:09:10 2008 -0500
@@ -54,21 +54,22 @@ incompatibleExtension=Disabled - not com
 incompatibleExtension=Disabled - not compatible with %S %S
 incompatibleAddonMsg=Not compatible with %S %S
 insecureUpdateMessage="%S" will not be installed because it does not provide secure updates
 
 invalidGUIDMessage="%S" could not be installed because of an error in its Install Manifest ("%S" is not a valid GUID). Please contact the author of this item about the problem.
 invalidVersionMessage="%S" could not be installed because of an error in its Install Manifest ("%S" is not a valid Version String). Please contact the author of this item about the problem.
 incompatiblePlatformMessage="%S" could not be installed because it is not compatible with your %S build type (%S). Please contact the author of this item about the problem.
 
-blocklistedInstallTitle=This extension is not secure
-blocklistedInstallMsg=The extension %S is known to be dangerous, and can't be installed.
-blocklistNotifyTitle2=Add-ons may be causing problems
-blocklistNotifyMsg2=%S has determined that the following add-ons may be unstable or insecure.
-blocklistRestartMsg2=You should restart %S so that these add-ons can be disabled.
+blocklistedInstallTitle2=This add-on is dangerous to use
+blocklistedInstallMsg2=The add-on %S has a high risk of causing stability or security problems and can't be installed.
+softBlockedInstallTitle=This add-on may be dangerous to use
+softBlockedInstallMsg=The add-on %S may cause stability or security problems. It is highly recommended that you do not install it.
+softBlockedInstallAcceptLabel=Install Anyway
+softBlockedInstallAcceptKey=I
 
 missingFileTitle=Missing File
 missingFileMessage=%S could not load this item because the file %S was missing.
 
 malformedMessage=%S could not install this item because "%S" (provided by the item) is not well-formed or does not exist. Please contact the author about this problem.
 malformedTitle=Malformed File
 
 malformedRegistrationTitle=Chrome Registration Failed
diff -r 4f1383af8f10 toolkit/locales/jar.mn
--- a/toolkit/locales/jar.mn	Sat Nov 01 09:52:29 2008 +0100
+++ b/toolkit/locales/jar.mn	Mon Nov 03 05:09:10 2008 -0500
@@ -72,16 +72,17 @@
 % locale mozapps @AB_CD@ %locale/@AB_CD@/mozapps/
 * locale/@AB_CD@/mozapps/downloads/unknownContentType.properties  (%chrome/mozapps/downloads/unknownContentType.properties)
 * locale/@AB_CD@/mozapps/downloads/unknownContentType.dtd         (%chrome/mozapps/downloads/unknownContentType.dtd)
 * locale/@AB_CD@/mozapps/downloads/settingsChange.dtd             (%chrome/mozapps/downloads/settingsChange.dtd)
   locale/@AB_CD@/mozapps/downloads/downloads.dtd                  (%chrome/mozapps/downloads/downloads.dtd)
   locale/@AB_CD@/mozapps/downloads/downloads.properties           (%chrome/mozapps/downloads/downloads.properties)
   locale/@AB_CD@/mozapps/extensions/extensions.dtd                (%chrome/mozapps/extensions/extensions.dtd)
   locale/@AB_CD@/mozapps/extensions/extensions.properties         (%chrome/mozapps/extensions/extensions.properties)
+  locale/@AB_CD@/mozapps/extensions/blocklist.dtd                 (%chrome/mozapps/extensions/blocklist.dtd)
   locale/@AB_CD@/mozapps/extensions/about.dtd                     (%chrome/mozapps/extensions/about.dtd)
   locale/@AB_CD@/mozapps/extensions/errors.dtd                    (%chrome/mozapps/extensions/errors.dtd)
   locale/@AB_CD@/mozapps/extensions/update.dtd                    (%chrome/mozapps/extensions/update.dtd)
   locale/@AB_CD@/mozapps/extensions/update.properties             (%chrome/mozapps/extensions/update.properties)
   locale/@AB_CD@/mozapps/handling/handling.dtd                    (%chrome/mozapps/handling/handling.dtd)
   locale/@AB_CD@/mozapps/handling/handling.properties             (%chrome/mozapps/handling/handling.properties)
   locale/@AB_CD@/mozapps/plugins/plugins.dtd                      (%chrome/mozapps/plugins/plugins.dtd)
   locale/@AB_CD@/mozapps/plugins/plugins.properties               (%chrome/mozapps/plugins/plugins.properties)
diff -r 4f1383af8f10 toolkit/mozapps/extensions/content/blocklist.css
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/mozapps/extensions/content/blocklist.css	Mon Nov 03 05:09:10 2008 -0500
@@ -0,0 +1,11 @@
+hbox.addon-name-version {
+  -moz-binding: url("chrome://mozapps/content/extensions/extensions.xml#addon-name-version");
+}
+
+.hardBlockedAddon {
+  -moz-binding: url("chrome://mozapps/content/extensions/extensions.xml#hardblockedaddon");
+}
+
+.softBlockedAddon {
+  -moz-binding: url("chrome://mozapps/content/extensions/extensions.xml#softblockedaddon");
+}
diff -r 4f1383af8f10 toolkit/mozapps/extensions/content/blocklist.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/mozapps/extensions/content/blocklist.js	Mon Nov 03 05:09:10 2008 -0500
@@ -0,0 +1,81 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Extension Blocklist UI.
+#
+# The Initial Developer of the Original Code is
+# Mozilla Corporation
+# Portions created by the Initial Developer are Copyright (C) 2008
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Dave Townsend <dtownsend@oxymoronical.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+var gArgs;
+
+function init() {
+  var hasHardBlocks = false;
+  var hasSoftBlocks = false;
+  gArgs = window.arguments[0].wrappedJSObject;
+
+  var richlist = document.getElementById("addonList");
+  var list = gArgs.list;
+  list.sort(function(a, b) { return String.localeCompare(a.name, b.name); });
+  for (let i = 0; i < list.length; i++) {
+    let item = document.createElement("richlistitem");
+    item.setAttribute("name", list[i].name);
+    item.setAttribute("version", list[i].version);
+    item.setAttribute("icon", list[i].icon);
+    if (list[i].blocked) {
+      item.setAttribute("class", "hardBlockedAddon");
+      hasHardBlocks = true;
+    }
+    else {
+      item.setAttribute("class", "softBlockedAddon");
+      hasSoftBlocks = true;
+    }
+    richlist.appendChild(item);
+  }
+
+  if (hasHardBlocks && hasSoftBlocks)
+    document.getElementById("bothMessage").hidden = false;
+  else if (hasHardBlocks)
+    document.getElementById("hardBlockMessage").hidden = false;
+  else
+    document.getElementById("softBlockMessage").hidden = false;
+}
+
+function accept() {
+  gArgs.restart = true;
+  var list = gArgs.list;
+  var items = document.getElementById("addonList").childNodes;
+  for (let i = 0; i < list.length; i++) {
+    if (!list[i].blocked)
+      list[i].disable = items[i].checked;
+  }
+  return true;
+}
diff -r 4f1383af8f10 toolkit/mozapps/extensions/content/blocklist.xul
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/mozapps/extensions/content/blocklist.xul	Mon Nov 03 05:09:10 2008 -0500
@@ -0,0 +1,80 @@
+<?xml version="1.0"?>
+
+# -*- Mode: Java; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Extension List UI.
+#
+# The Initial Developer of the Original Code is Google Inc.
+# Portions created by the Initial Developer are Copyright (C) 2005
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Ben Goodger <ben@mozilla.org>
+#   Robert Strong <robert.bugzilla@gmail.com>
+#   Dave Townsend <dtownsend@oxymoronical.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+<?xml-stylesheet href="chrome://global/skin/"?>
+<?xml-stylesheet href="chrome://mozapps/skin/extensions/blocklist.css"?>
+<?xml-stylesheet href="chrome://mozapps/content/extensions/blocklist.css"?>
+
+<!DOCTYPE dialog [
+<!ENTITY % brandDTD SYSTEM "chrome://branding/locale/brand.dtd">
+%brandDTD;
+<!ENTITY % extensionsDTD SYSTEM "chrome://mozapps/locale/extensions/blocklist.dtd">
+%extensionsDTD;
+]>
+
+<dialog windowtype="Addons:Blocklist" title="&blocklist.title;" align="stretch"
+        xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
+        onload="init();" ondialogaccept="return accept()"
+        buttons="accept,cancel" style="&blocklist.style;"
+        buttonlabelaccept="&blocklist.accept.label;"
+        buttonaccesskeyaccept="&blocklist.accept.accesskey;">
+
+  <script type="application/javascript" src="chrome://global/content/globalOverlay.js"/>
+  <script type="application/javascript" src="chrome://mozapps/content/extensions/blocklist.js"/>
+
+  <hbox align="stretch" flex="1">
+    <vbox pack="start">
+      <image class="error-icon"/>
+    </vbox>
+    <vbox flex="1">
+      <label>&blocklist.summary;</label>
+      <separator class="thin"/>
+      <richlistbox id="addonList" flex="1"/>
+      <separator class="thin"/>
+      <description id="bothMessage" hidden="true" class="bold">&blocklist.softandhard;</description>
+      <description id="hardBlockMessage" hidden="true" class="bold">&blocklist.hardblocked;</description>
+      <description id="softBlockMessage" hidden="true" class="bold">&blocklist.softblocked;</description>
+      <hbox pack="start">
+        <label class="text-link" value="&blocklist.moreinfo;"/>
+      </hbox>
+    </vbox>
+  </hbox>
+</dialog>
diff -r 4f1383af8f10 toolkit/mozapps/extensions/content/extensions.js
--- a/toolkit/mozapps/extensions/content/extensions.js	Sat Nov 01 09:52:29 2008 +0100
+++ b/toolkit/mozapps/extensions/content/extensions.js	Mon Nov 03 05:09:10 2008 -0500
@@ -293,16 +293,17 @@ function showView(aView) {
   // Using disabled to represent add-on state in regards to the EM causes evil
   // focus behavior when used as an element attribute when the element isn't
   // really disabled.
   var bindingList = [ [ ["aboutURL", "?aboutURL"],
                         ["addonID", "?addonID"],
                         ["availableUpdateURL", "?availableUpdateURL"],
                         ["availableUpdateVersion", "?availableUpdateVersion"],
                         ["blocklisted", "?blocklisted"],
+                        ["blocklistedsoft", "?blocklistedsoft"],
                         ["compatible", "?compatible"],
                         ["description", "?description"],
                         ["downloadURL", "?downloadURL"],
                         ["isDisabled", "?isDisabled"],
                         ["hidden", "?hidden"],
                         ["homepageURL", "?homepageURL"],
                         ["iconURL", "?iconURL"],
                         ["internalName", "?internalName"],
@@ -379,16 +380,17 @@ function showView(aView) {
       showInstallUpdatesAll = true;
       if (gUpdatesOnly)
         showSkip = true;
       bindingList = [ [ ["aboutURL", "?aboutURL"],
                         ["availableUpdateURL", "?availableUpdateURL"],
                         ["availableUpdateVersion", "?availableUpdateVersion"],
                         ["availableUpdateInfo", "?availableUpdateInfo"],
                         ["blocklisted", "?blocklisted"],
+                        ["blocklistedsoft", "?blocklistedsoft"],
                         ["homepageURL", "?homepageURL"],
                         ["iconURL", "?iconURL"],
                         ["internalName", "?internalName"],
                         ["locked", "?locked"],
                         ["name", "?name"],
                         ["opType", "?opType"],
                         ["previewImage", "?previewImage"],
                         ["satisfiesDependencies", "?satisfiesDependencies"],
@@ -405,16 +407,17 @@ function showView(aView) {
       showInstallFile = false;
       showCheckUpdatesAll = false;
       showInstallUpdatesAll = false;
       bindingList = [ [ ["aboutURL", "?aboutURL"],
                         ["addonID", "?addonID"],
                         ["availableUpdateURL", "?availableUpdateURL"],
                         ["availableUpdateVersion", "?availableUpdateVersion"],
                         ["blocklisted", "?blocklisted"],
+                        ["blocklistedsoft", "?blocklistedsoft"],
                         ["compatible", "?compatible"],
                         ["description", "?description"],
                         ["downloadURL", "?downloadURL"],
                         ["incompatibleUpdate", "?incompatibleUpdate"],
                         ["isDisabled", "?isDisabled"],
                         ["hidden", "?hidden"],
                         ["homepageURL", "?homepageURL"],
                         ["iconURL", "?iconURL"],
@@ -913,16 +916,18 @@ function rebuildPluginsDS()
                                homepageURL : homepageURL,
                                disabled    : plugin.disabled,
                                blocklisted : plugin.blocklisted,
                                plugins     : [] };
     }
     gPlugins[name][desc].plugins.push(plugin);
   }
 
+  var blocklist = Components.classes["@mozilla.org/extensions/blocklist;1"]
+                            .getService(Components.interfaces.nsIBlocklistService);
   for (var pluginName in gPlugins) {
     for (var pluginDesc in gPlugins[pluginName]) {
       plugin = gPlugins[pluginName][pluginDesc];
       var pluginNode = gRDF.GetResource(PREFIX_ITEM_URI + plugin.filename);
       rootctr.AppendElement(pluginNode);
       gPluginsDS.Assert(pluginNode,
                         gRDF.GetResource(PREFIX_NS_EM + "name"),
                         gRDF.GetLiteral(pluginName),
@@ -947,16 +952,22 @@ function rebuildPluginsDS()
       gPluginsDS.Assert(pluginNode,
                         gRDF.GetResource(PREFIX_NS_EM + "isDisabled"),
                         gRDF.GetLiteral((plugin.disabled ||
                                          plugin.blocklisted) ? "true" : "false"),
                         true);
       gPluginsDS.Assert(pluginNode,
                         gRDF.GetResource(PREFIX_NS_EM + "blocklisted"),
                         gRDF.GetLiteral(plugin.blocklisted ? "true" : "false"),
+                        true);
+      var softblocked = blocklist.getPluginBlocklistState(plugin) == 
+                        Components.interfaces.nsIBlocklistService.STATE_SOFTBLOCKED;
+      gPluginsDS.Assert(pluginNode,
+                        gRDF.GetResource(PREFIX_NS_EM + "blocklistedsoft"),
+                        gRDF.GetLiteral(softblocked ? "true" : "false"),
                         true);
       gPluginsDS.Assert(pluginNode,
                         gRDF.GetResource(PREFIX_NS_EM + "compatible"),
                         gRDF.GetLiteral("true"),
                         true);
       gPluginsDS.Assert(pluginNode,
                         gRDF.GetResource(PREFIX_NS_EM + "plugin"),
                         gRDF.GetLiteral("true"),
diff -r 4f1383af8f10 toolkit/mozapps/extensions/content/extensions.xml
--- a/toolkit/mozapps/extensions/content/extensions.xml	Sat Nov 01 09:52:29 2008 +0100
+++ b/toolkit/mozapps/extensions/content/extensions.xml	Mon Nov 03 05:09:10 2008 -0500
@@ -90,16 +90,17 @@
       <stylesheet src="chrome://mozapps/skin/extensions/extensions.css"/>
     </resources>
 
     <implementation>
       <field name="eventPrefix">"extension-"</field>
       <property name="type" onget="return parseInt(this.getAttribute('type'));"/>
       <property name="isCompatible" onget="return this.getAttribute('compatible') == 'true';"/>
       <property name="isBlocklisted" onget="return this.getAttribute('blocklisted') == 'true';"/>
+      <property name="isSoftBlocklisted" onget="return this.getAttribute('blocklistedsoft') == 'true';"/>
       <property name="isDisabled" onget="return this.getAttribute('isDisabled') == 'true';"/>
       <property name="providesUpdatesSecurely" onget="return this.getAttribute('providesUpdatesSecurely') == 'true';"/>
       <property name="satisfiesDependencies" onget="return this.getAttribute('satisfiesDependencies') == 'true';"/>
       <property name="opType">
         <getter>
           <![CDATA[
             var opType = this.getAttribute('opType');
             return opType == 'none' ? null : opType;
@@ -128,20 +129,46 @@
 
   <binding id="addon" extends="chrome://mozapps/content/extensions/extensions.xml#addon-base">
     <content>
       <xul:hbox flex="1">
         <xul:vbox class="addon-icon" xbl:inherits="iconURL"/>
         <xul:vbox flex="1" class="addonTextBox">
           <xul:hbox class="addon-name-version" xbl:inherits="name, version"/>
           <xul:hbox anonid="addonDescription" class="addon-description" xbl:inherits="description, opType"/>
+          <xul:vbox anonid="addonSelectedStatusMsgs" class="selectedStatusMsgs">
+            <xul:hbox flex="1" class="blocklistedBox attention" align="center">
+              <xul:label class="blocklistedLabel" value="&blocklisted.label;" crop="end"/>
+              <xul:label class="softBlocklistedLabel" value="&softBlocklisted.label;" crop="end"/>
+              <xul:label anonid="blocklistMoreInfo" class="text-link" value="&moreInfo.label;"
+                         onclick="if (event.button == 0) { openURL(this.getAttribute('moreInfoURL')); }" />
+            </xul:hbox>
+          </xul:vbox>
         </xul:vbox>
       </xul:hbox>
     </content>
     <implementation implements="nsIAccessibleProvider, nsIDOMXULSelectControlItemElement">
+      <constructor>
+        <![CDATA[
+          if (this.isBlocklisted || this.isSoftBlocklisted) {
+            try {
+              var blocklistMoreInfo = document.getAnonymousElementByAttribute(this, "anonid", "blocklistMoreInfo");
+              var prefs = Components.classes["@mozilla.org/preferences-service;1"]
+                                    .getService(Components.interfaces.nsIPrefBranch);
+              var formatter = Components.classes["@mozilla.org/toolkit/URLFormatterService;1"]
+                                        .getService(Components.interfaces.nsIURLFormatter);
+              var url = formatter.formatURLPref("extensions.blocklist.detailsURL");
+              blocklistMoreInfo.setAttribute("moreInfoURL", url);
+            } catch(e) {
+              blocklistMoreInfo.hidden = true;
+            }
+          }
+        ]]>
+      </constructor>
+
       <field name="_addonDescription">
         document.getAnonymousElementByAttribute(this, "anonid", "addonDescription");
       </field>
 
       <property name="label" readonly="true">
         <getter>
           <![CDATA[
             var labelPieces = [];
@@ -209,17 +236,18 @@
             </xul:hbox>
             <xul:hbox flex="1" class="insecureUpdateBox attention">
               <xul:label value="&insecureUpdate.label;" crop="end"/>
             </xul:hbox>
             <xul:hbox flex="1" class="needsDependenciesBox attention">
               <xul:label value="&needsDependencies.label;" crop="end"/>
             </xul:hbox>
             <xul:hbox flex="1" class="blocklistedBox attention" align="center">
-              <xul:label value="&blocklisted.label;" crop="end"/>
+              <xul:label class="blocklistedLabel" value="&blocklisted.label;" crop="end"/>
+              <xul:label class="softBlocklistedLabel" value="&softBlocklisted.label;" crop="end"/>
               <xul:label anonid="blocklistMoreInfo" class="text-link" value="&moreInfo.label;"
                          onclick="if (event.button == 0) { openURL(this.getAttribute('moreInfoURL')); }" />
             </xul:hbox>
           </xul:vbox>
           <xul:hbox anonid="selectedButtons" flex="1" class="selectedButtons">
             <xul:button class="uninstallHide optionsButton"
 #ifdef XP_WIN
               label="&cmd.options.label;" accesskey="&cmd.options.accesskey;"
@@ -254,17 +282,17 @@
           </xul:hbox>
         </xul:vbox>
       </xul:hbox>
     </content>
 
     <implementation implements="nsIAccessibleProvider, nsIDOMXULSelectControlItemElement">
       <constructor>
         <![CDATA[
-          if (this.isBlocklisted) {
+          if (this.isBlocklisted || this.isSoftBlocklisted) {
             try {
               var blocklistMoreInfo = document.getAnonymousElementByAttribute(this, "anonid", "blocklistMoreInfo");
               var prefs = Components.classes["@mozilla.org/preferences-service;1"]
                                     .getService(Components.interfaces.nsIPrefBranch);
               var formatter = Components.classes["@mozilla.org/toolkit/URLFormatterService;1"]
                                         .getService(Components.interfaces.nsIURLFormatter);
               var url = formatter.formatURLPref("extensions.blocklist.detailsURL");
               blocklistMoreInfo.setAttribute("moreInfoURL", url);
@@ -919,9 +947,45 @@
           <![CDATA[
             return Components.interfaces.nsIAccessibleProvider.XULListitem;
           ]]>
         </getter>
       </property>
     </implementation>
   </binding>
 
+  <binding id="hardblockedaddon">
+    <content align="start">
+      <xul:image xbl:inherits="src=icon"/>
+      <xul:vbox flex="1">
+        <xul:hbox class="addon-name-version" xbl:inherits="name, version"/>
+        <xul:hbox>
+          <xul:spacer flex="1"/>
+          <xul:label class="blockedLabel" value="&blocklist.blocked.label;"/>
+        </xul:hbox>
+      </xul:vbox>
+    </content>
+  </binding>
+
+  <binding id="softblockedaddon">
+    <content align="start">
+      <xul:image xbl:inherits="src=icon"/>
+      <xul:vbox flex="1">
+        <xul:hbox class="addon-name-version" xbl:inherits="name, version"/>
+        <xul:hbox>
+          <xul:spacer flex="1"/>
+          <xul:checkbox class="disableCheckbox" checked="true" label="&blocklist.checkbox.label;"/>
+        </xul:hbox>
+      </xul:vbox>
+    </content>
+    <implementation>
+      <field name="_checkbox">
+        document.getAnonymousElementByAttribute(this, "class", "disableCheckbox")
+      </field>
+      <property name="checked" readonly="true">
+        <getter>
+          return this._checkbox.checked;
+        </getter>
+      </property>
+    </implementation>
+  </binding>
+
 </bindings>
diff -r 4f1383af8f10 toolkit/mozapps/extensions/content/list.js
--- a/toolkit/mozapps/extensions/content/list.js	Sat Nov 01 09:52:29 2008 +0100
+++ b/toolkit/mozapps/extensions/content/list.js	Mon Nov 03 05:09:10 2008 -0500
@@ -76,79 +76,61 @@ const kDialog = "dialog";
  */
 
 var gButtons = { };
 
 function init() {
   var de = document.documentElement;
   var items = [];
   if (window.arguments[0] instanceof Components.interfaces.nsIDialogParamBlock) {
+    // This is a warning about a blocklisted item the user is trying to install
     var args = window.arguments[0];
-    var fromInstall = args.GetInt(0) == 1 ? true : false;
-    var numberOfItems = args.GetInt(1);
-    for (var i = 0; i < numberOfItems; ++i)
-      items.push(args.GetString(i));
+    var softblocked = args.GetInt(0) == 1 ? true : false;
 
     var extensionsBundle = document.getElementById("extensionsBundle");
     try {
       var formatter = Components.classes["@mozilla.org/toolkit/URLFormatterService;1"]
                                 .getService(Components.interfaces.nsIURLFormatter);
       var url = formatter.formatURLPref("extensions.blocklist.detailsURL");
     }
     catch (e) { }
 
-    if (fromInstall) { // Blocklist blocked install
-      var params = {
-        message1: extensionsBundle.getFormattedString("blocklistedInstallMsg",
-                                                      [items[0]]),
-        moreInfoURL: url,
-        title: extensionsBundle.getString("blocklistedInstallTitle")
-      };
-      items = [];
-      var button = document.getElementById("centeredButton");
-      button.setAttribute("dlgtype", "accept");
+    var params = {
+      moreInfoURL: url,
+    };
+
+    if (softblocked) {
+      params.title = extensionsBundle.getString("softBlockedInstallTitle");
+      params.message1 = extensionsBundle.getFormattedString("softBlockedInstallMsg",
+                                                           [args.GetString(0)]);
+      var accept = de.getButton("accept");
+      accept.label = extensionsBundle.getString("softBlockedInstallAcceptLabel");
+      accept.accessKey = extensionsBundle.getString("softBlockedInstallAcceptKey");
+      de.getButton("cancel").focus();
+      document.addEventListener("dialogaccept", allowInstall, false);
+    }
+    else {
+      params.title = extensionsBundle.getString("blocklistedInstallTitle2");
+      params.message1 = extensionsBundle.getFormattedString("blocklistedInstallMsg2",
+                                                           [args.GetString(0)]);
       de.buttons = "accept";
       de.getButton("accept").focus();
     }
-    else { // Blocklist background notification
-      // only hide when not used due to focus issues
-      document.getElementById("buttonCenteredBox").hidden = true;
-      var brandBundle = document.getElementById("brandBundle");
-      var brandShortName = brandBundle.getString("brandShortName");
-      params = {
-        message1: extensionsBundle.getFormattedString("blocklistNotifyMsg2",
-                                                      [brandShortName]),
-        message2: extensionsBundle.getFormattedString("blocklistRestartMsg2",
-                                                      [brandShortName]),
-        moreInfoURL: url,
-        title: extensionsBundle.getString("blocklistNotifyTitle2")
-      };
-      de.buttons = "extra1,cancel";
-      button = de.getButton("cancel");
-      button.label = extensionsBundle.getString("laterButton");
-      de.setAttribute("ondialogextra1", "restartApp();");
-      button.focus();
-      button = de.getButton("extra1");
-      button.label = extensionsBundle.getFormattedString("restartButton",
-                                                         [brandShortName]);
-    }
   }
   else {
-    // only hide when not used due to focus issues
-    document.getElementById("buttonCenteredBox").hidden = true;
     items = window.arguments[0];
     params = window.arguments[1];
   }
 
   var addons = document.getElementById("addonsChildren");
   if (items.length > 0)
     document.getElementById("addonsTree").hidden = false;
 
   // Fill the addons list
-  for (i = 0; i < items.length; ++i) {
+  for (var i = 0; i < items.length; ++i) {
     var treeitem = document.createElementNS(kXULNS, "treeitem");
     var treerow  = document.createElementNS(kXULNS, "treerow");
     var treecell = document.createElementNS(kXULNS, "treecell");
     treecell.setAttribute("label", items[i]);
     treerow.appendChild(treecell);
     treeitem.appendChild(treerow);
     addons.appendChild(treeitem);
   }
@@ -180,45 +162,33 @@ function init() {
   // Set up the buttons
   if ("buttons" in params) {
     gButtons = params.buttons;
     var buttonString = "";
     for (var buttonType in gButtons)
       buttonString += "," + buttonType;
     de.buttons = buttonString.substr(1);
     for (buttonType in gButtons) {
-      button = de.getButton(buttonType);
+      var button = de.getButton(buttonType);
       button.label = gButtons[buttonType].label;
       if (gButtons[buttonType].focused)
         button.focus();
       document.addEventListener(kDialog + buttonType, handleButtonCommand, true);
     }
   }
 }
 
 function shutdown() {
-  for (buttonType in gButtons)
+  for (var buttonType in gButtons)
     document.removeEventListener(kDialog + buttonType, handleButtonCommand, true);
 }
 
-function restartApp() {
-  const nsIAppStartup = Components.interfaces.nsIAppStartup;
-  // Notify all windows that an application quit has been requested.
-  var os = Components.classes["@mozilla.org/observer-service;1"]
-                     .getService(Components.interfaces.nsIObserverService);
-  var cancelQuit = Components.classes["@mozilla.org/supports-PRBool;1"]
-                             .createInstance(Components.interfaces.nsISupportsPRBool);
-  os.notifyObservers(cancelQuit, "quit-application-requested", null);
-
-  // Something aborted the quit process. 
-  if (cancelQuit.data)
-    return;
-
-  Components.classes["@mozilla.org/toolkit/app-startup;1"].getService(nsIAppStartup)
-            .quit(nsIAppStartup.eRestart | nsIAppStartup.eAttemptQuit);
+function allowInstall() {
+  var args = window.arguments[0];
+  args.SetInt(1, 1);
 }
 
 /**
  * Watch for the user hitting one of the buttons to dismiss the dialog
  * and report the result back to the caller through the |result| property on
  * the arguments object.
  */
 function handleButtonCommand(event) {
diff -r 4f1383af8f10 toolkit/mozapps/extensions/content/list.xul
--- a/toolkit/mozapps/extensions/content/list.xul	Sat Nov 01 09:52:29 2008 +0100
+++ b/toolkit/mozapps/extensions/content/list.xul	Mon Nov 03 05:09:10 2008 -0500
@@ -53,31 +53,26 @@
                 src="chrome://mozapps/locale/extensions/extensions.properties"/>
   <stringbundle id="brandBundle"
                 src="chrome://branding/locale/brand.properties"/>
 
   <hbox align="start">
     <vbox>
       <image id="infoIcon"/>
     </vbox>
-    <vbox class="spaced" style="min-width: 20em;">
+    <vbox class="spaced" style="min-width: 20em; max-width: 40em">
       <label id="message1" class="spaced" hidden="true"/>
       <separator class="thin"/>
       <tree id="addonsTree" rows="6" hidecolumnpicker="true" hidden="true" class="spaced">
         <treecols style="max-width: 25em;">
           <treecol flex="1" id="nameColumn" hideheader="true"/>
         </treecols>
         <treechildren id="addonsChildren"/>
       </tree>
       <label id="message2" class="spaced" hidden="true"/>
       <label class="bold spaced" id="message3" hidden="true"/>
       <hbox id="moreInfoBox" hidden="true">
         <label id="moreInfo" class="text-link spaced"/>
         <spacer flex="1"/>
       </hbox>
     </vbox>
   </hbox>
-  <hbox id="buttonCenteredBox">
-    <spacer flex="1"/>
-    <button id="centeredButton"/>
-    <spacer flex="1"/>
-  </hbox>
 </dialog>
diff -r 4f1383af8f10 toolkit/mozapps/extensions/jar.mn
--- a/toolkit/mozapps/extensions/jar.mn	Sat Nov 01 09:52:29 2008 +0100
+++ b/toolkit/mozapps/extensions/jar.mn	Mon Nov 03 05:09:10 2008 -0500
@@ -4,13 +4,16 @@ toolkit.jar:
 * content/mozapps/extensions/extensions.js                      (content/extensions.js)
 * content/mozapps/extensions/extensions.xml                     (content/extensions.xml)
   content/mozapps/extensions/updateinfo.xsl                     (content/updateinfo.xsl)
   content/mozapps/extensions/extensions.css                     (content/extensions.css)
 * content/mozapps/extensions/about.xul                          (content/about.xul)
 * content/mozapps/extensions/about.js                           (content/about.js)
 * content/mozapps/extensions/list.xul                           (content/list.xul)
 * content/mozapps/extensions/list.js                            (content/list.js)
+* content/mozapps/extensions/blocklist.xul                      (content/blocklist.xul)
+* content/mozapps/extensions/blocklist.js                       (content/blocklist.js)
+* content/mozapps/extensions/blocklist.css                      (content/blocklist.css)
 * content/mozapps/extensions/errors.xul                         (content/errors.xul)
 * content/mozapps/extensions/update.xul                         (content/update.xul)
 * content/mozapps/extensions/update.js                          (content/update.js)
 * content/mozapps/extensions/eula.xul                           (content/eula.xul)
 * content/mozapps/extensions/eula.js                            (content/eula.js)
diff -r 4f1383af8f10 toolkit/mozapps/extensions/public/Makefile.in
--- a/toolkit/mozapps/extensions/public/Makefile.in	Sat Nov 01 09:52:29 2008 +0100
+++ b/toolkit/mozapps/extensions/public/Makefile.in	Mon Nov 03 05:09:10 2008 -0500
@@ -41,14 +41,13 @@ VPATH   = @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 MODULE        = extensions
 XPIDL_MODULE  = extensions
 
 XPIDLSRCS = \
   nsIExtensionManager.idl \
-  nsIBlocklistService.idl \
   nsIAddonRepository.idl \
   $(NULL)
 
 include $(topsrcdir)/config/rules.mk
 
diff -r 4f1383af8f10 toolkit/mozapps/extensions/public/nsIBlocklistService.idl
--- a/toolkit/mozapps/extensions/public/nsIBlocklistService.idl	Sat Nov 01 09:52:29 2008 +0100
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,64 +0,0 @@
-/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is the Blocklist Service.
- *
- * The Initial Developer of the Original Code is
- * Mozilla Corporation
- * Portions created by the Initial Developer are Copyright (C) 2007
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Michael Wu <flamingice@sourmilk.net>  (original author)
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-
-#include "nsISupports.idl"
-
-[scriptable, uuid(0c3fe697-d50d-4f42-b747-0c5855cfc60e)]
-interface nsIBlocklistService : nsISupports
-{
-  /**
-   * Determine if an item is blocklisted
-   * @param   id
-   *          The GUID of the item.
-   * @param   version
-   *          The item's version.
-   * @param   appVersion
-   *          The version of the application we are checking in the blocklist.
-   *          If this parameter is null, the version of the running application
-   *          is used.
-   * @param   toolkitVersion
-   *          The version of the toolkit we are checking in the blocklist.
-   *          If this parameter is null, the version of the running toolkit
-   *          is used.
-   * @returns true if the item is compatible with this version of the
-   *          application or this version of the toolkit, false, otherwise.
-   */
-  boolean isAddonBlocklisted(in AString id, in AString version,
-                             in AString appVersion, in AString toolkitVersion);
-};
diff -r 4f1383af8f10 toolkit/mozapps/extensions/public/nsIExtensionManager.idl
--- a/toolkit/mozapps/extensions/public/nsIExtensionManager.idl	Sat Nov 01 09:52:29 2008 +0100
+++ b/toolkit/mozapps/extensions/public/nsIExtensionManager.idl	Mon Nov 03 05:09:10 2008 -0500
@@ -194,17 +194,17 @@ interface nsIInstallLocation : nsISuppor
 
 /**
  * Interface representing a system for the installation and management of
  * Extensions, Themes etc.
  *
  * XXXben - Some of this stuff should go into a management-ey interface,
  *          some into an app-startup-ey interface.
  */
-[scriptable, uuid(23080b61-dab9-48b7-bd68-b5ea23cae14b)]
+[scriptable, uuid(7fbb049a-00e6-4ce2-82fc-854c52788df9)]
 interface nsIExtensionManager : nsISupports
 {
   /**
    * Constants representing types of update checks.
    */
   const unsigned long UPDATE_CHECK_NEWVERSION    = 0;
   const unsigned long UPDATE_CHECK_COMPATIBILITY = 1;
   const unsigned long UPDATE_SYNC_COMPATIBILITY  = 2;
@@ -465,25 +465,30 @@ interface nsIExtensionManager : nsISuppo
    *          specified by the id parameter.
    */
   void getDependentItemListForID(in AString id,
                                  in boolean includeDisabled,
                                  out unsigned long itemCount,
                                  [retval, array, size_is(itemCount)] out nsIUpdateItem items);
 
   /**
-   * Checks for changes to the blocklist using the local blocklist file,
-   * application disables / enables items that have been added / removed from
-   * the blocklist, and if there are additions to the blocklist this will
-   * inform the user by displaying a list of the items added.
+   * Checks for changes to the blocklist using the local blocklist file.
+   * This will immediately application disable items that have been hard blocked
+   * and application enable items that are no longer hard blocked. It will also
+   * return items that are either soft or hard blocked and aren't already
+   * disabled or disabled pending a restart.
    *
-   * XXXrstrong - this method is not terribly useful and was added so we can
-   * trigger this check from the additional timer used by blocklisting.
+   * This is likely to change or go away in the future and should not be used
+   * by anyone outside of the blocklist service.
+   *
+   * @returns An array of nsIUpdateItems that are blocklisted or the user should
+   *          be warned about but are currently enabled.
    */
-  void checkForBlocklistChanges();
+  void updateAndGetNewBlocklistedItems(out unsigned long itemCount,
+                                       [retval, array, size_is(itemCount)] out nsIUpdateItem items);
 
   /**
    * Sorts addons of the specified type by the specified property in the
    * Extensions Datasource container starting from the top of their container.
    * If the addons are already sorted then no action is performed.
    * @param   type
    *          The nsIUpdateItem type of the items to sort.
    * @param   propertyName
diff -r 4f1383af8f10 toolkit/mozapps/extensions/src/nsBlocklistService.js
--- a/toolkit/mozapps/extensions/src/nsBlocklistService.js	Sat Nov 01 09:52:29 2008 +0100
+++ b/toolkit/mozapps/extensions/src/nsBlocklistService.js	Mon Nov 03 05:09:10 2008 -0500
@@ -48,25 +48,30 @@ Components.utils.import("resource://gre/
 
 const TOOLKIT_ID                      = "toolkit@mozilla.org"
 const KEY_PROFILEDIR                  = "ProfD";
 const KEY_APPDIR                      = "XCurProcD";
 const FILE_BLOCKLIST                  = "blocklist.xml";
 const PREF_BLOCKLIST_URL              = "extensions.blocklist.url";
 const PREF_BLOCKLIST_ENABLED          = "extensions.blocklist.enabled";
 const PREF_BLOCKLIST_INTERVAL         = "extensions.blocklist.interval";
+const PREF_BLOCKLIST_LEVEL            = "extensions.blocklist.level";
 const PREF_GENERAL_USERAGENT_LOCALE   = "general.useragent.locale";
 const PREF_PARTNER_BRANCH             = "app.partner.";
 const PREF_APP_DISTRIBUTION           = "distribution.id";
 const PREF_APP_DISTRIBUTION_VERSION   = "distribution.version";
 const PREF_APP_UPDATE_CHANNEL         = "app.update.channel";
 const PREF_EM_LOGGING_ENABLED         = "extensions.logging.enabled";
 const XMLURI_BLOCKLIST                = "http://www.mozilla.org/2006/addons-blocklist";
 const XMLURI_PARSE_ERROR              = "http://www.mozilla.org/newlayout/xml/parsererror.xml"
 const UNKNOWN_XPCOM_ABI               = "unknownABI";
+const URI_BLOCKLIST_DIALOG            = "chrome://mozapps/content/extensions/blocklist.xul"
+const DEFAULT_SEVERITY                = 3;
+const DEFAULT_LEVEL                   = 2;
+const MAX_BLOCK_LEVEL                 = 3;
 
 const MODE_RDONLY   = 0x01;
 const MODE_WRONLY   = 0x02;
 const MODE_CREATE   = 0x08;
 const MODE_APPEND   = 0x10;
 const MODE_TRUNCATE = 0x20;
 
 const PERMS_FILE      = 0644;
@@ -75,16 +80,18 @@ var gApp = null;
 var gApp = null;
 var gPref = null;
 var gOS = null;
 var gConsole = null;
 var gVersionChecker = null;
 var gLoggingEnabled = null;
 var gABI = null;
 var gOSVersion = null;
+var gBlocklistEnabled = true;
+var gBlocklistLevel = DEFAULT_LEVEL;
 
 // shared code for suppressing bad cert dialogs
 #include ../../shared/src/badCertHandler.js
 
 /**
  * Logs a string to the error console.
  * @param   string
  *          The string to write to the error console..
@@ -182,16 +189,34 @@ function closeSafeFileOutputStream(strea
  * @returns The nsIURI constructed.
  */
 function newURI(spec) {
   var ioServ = Cc["@mozilla.org/network/io-service;1"].
                getService(Ci.nsIIOService);
   return ioServ.newURI(spec, null, null);
 }
 
+// Restarts the application checking in with observers first
+function restartApp() {
+  // Notify all windows that an application quit has been requested.
+  var os = Cc["@mozilla.org/observer-service;1"].
+           getService(Ci.nsIObserverService);
+  var cancelQuit = Cc["@mozilla.org/supports-PRBool;1"].
+                   createInstance(Ci.nsISupportsPRBool);
+  os.notifyObservers(cancelQuit, "quit-application-requested", null);
+
+  // Something aborted the quit process. 
+  if (cancelQuit.data)
+    return;
+
+  var as = Cc["@mozilla.org/toolkit/app-startup;1"].
+           getService(Ci.nsIAppStartup);
+  as.quit(Ci.nsIAppStartup.eRestart | Ci.nsIAppStartup.eAttemptQuit);
+}
+
 /**
  * Checks whether this blocklist element is valid for the current OS and ABI.
  * If the element has an "os" attribute then the current OS must appear in
  * its comma separated list for the element to be valid. Similarly for the
  * xpcomabi attribute.
  */
 function matchesOSABI(blocklistElement) {
   if (blocklistElement.hasAttribute("os")) {
@@ -212,38 +237,34 @@ function matchesOSABI(blocklistElement) 
 /**
  * Gets the current value of the locale.  It's possible for this preference to
  * be localized, so we have to do a little extra work here.  Similar code
  * exists in nsHttpHandler.cpp when building the UA string.
  */
 function getLocale() {
   try {
       // Get the default branch
-      var prefs = Components.classes["@mozilla.org/preferences-service;1"]
-          .getService(Components.interfaces.nsIPrefService);
-      var defaultPrefs = prefs.getDefaultBranch(null);
+      var defaultPrefs = gPref.getDefaultBranch(null);
       return defaultPrefs.getCharPref(PREF_GENERAL_USERAGENT_LOCALE);
   } catch (e) {}
 
   return gPref.getCharPref(PREF_GENERAL_USERAGENT_LOCALE);
 }
 
 /**
  * Read the update channel from defaults only.  We do this to ensure that
  * the channel is tightly coupled with the application and does not apply
  * to other installations of the application that may use the same profile.
  */
 function getUpdateChannel() {
   var channel = "default";
   var prefName;
   var prefValue;
 
-  var defaults =
-      gPref.QueryInterface(Components.interfaces.nsIPrefService).
-      getDefaultBranch(null);
+  var defaults = gPref.getDefaultBranch(null);
   try {
     channel = defaults.getCharPref(PREF_APP_UPDATE_CHANNEL);
   } catch (e) {
     // use default when pref not found
   }
 
   try {
     var partners = gPref.getChildList(PREF_PARTNER_BRANCH, { });
@@ -263,19 +284,17 @@ function getUpdateChannel() {
 
   return channel;
 }
 
 /* Get the distribution pref values, from defaults only */
 function getDistributionPrefValue(aPrefName) {
   var prefValue = "default";
 
-  var defaults =
-      gPref.QueryInterface(Components.interfaces.nsIPrefService).
-      getDefaultBranch(null);
+  var defaults = gPref.getDefaultBranch(null);
   try {
     prefValue = defaults.getCharPref(aPrefName);
   } catch (e) {
     // use default when pref not found
   }
 
   return prefValue;
 }
@@ -286,17 +305,18 @@ function getDistributionPrefValue(aPrefN
  * items managed by the Extension Manager with an item's appDisabled property.
  * It also blocklists plugins with data from blocklist.xml.
  */
 
 function Blocklist() {
   gApp = Cc["@mozilla.org/xre/app-info;1"].getService(Ci.nsIXULAppInfo);
   gApp.QueryInterface(Ci.nsIXULRuntime);
   gPref = Cc["@mozilla.org/preferences-service;1"].
-          getService(Ci.nsIPrefBranch2);
+          getService(Ci.nsIPrefService).
+          QueryInterface(Ci.nsIPrefBranch2);
   gVersionChecker = Cc["@mozilla.org/xpcom/version-comparator;1"].
                     getService(Ci.nsIVersionComparator);
   gConsole = Cc["@mozilla.org/consoleservice;1"].
              getService(Ci.nsIConsoleService);
 
   gOS = Cc["@mozilla.org/observer-service;1"].
         getService(Ci.nsIObserverService);
   gOS.addObserver(this, "xpcom-shutdown", false);
@@ -358,67 +378,116 @@ Blocklist.prototype = {
    *                                 (default = *)
    */
   _addonEntries: null,
   _pluginEntries: null,
 
   observe: function (aSubject, aTopic, aData) {
     switch (aTopic) {
     case "app-startup":
-      gOS.addObserver(this, "plugins-list-updated", false);
       gOS.addObserver(this, "profile-after-change", false);
       gOS.addObserver(this, "quit-application", false);
       break;
     case "profile-after-change":
       gLoggingEnabled = getPref("getBoolPref", PREF_EM_LOGGING_ENABLED, false);
+      gBlocklistEnabled = getPref("getBoolPref", PREF_BLOCKLIST_ENABLED, true);
+      gBlocklistLevel = Math.min(getPref("getIntPref", PREF_BLOCKLIST_LEVEL, DEFAULT_LEVEL),
+                                 MAX_BLOCK_LEVEL);
+      gPref.addObserver("extensions.blocklist.", this, false);
       var tm = Cc["@mozilla.org/updates/timer-manager;1"].
                getService(Ci.nsIUpdateTimerManager);
       var interval = getPref("getIntPref", PREF_BLOCKLIST_INTERVAL, 86400);
       tm.registerTimer("blocklist-background-update-timer", this, interval);
       break;
-    case "plugins-list-updated":
-      this._checkPluginsList();
-      break;
     case "quit-application":
-      gOS.removeObserver(this, "plugins-list-updated");
       gOS.removeObserver(this, "profile-after-change");
       gOS.removeObserver(this, "quit-application");
+      gPref.removeObserver("extensions.blocklist.", this);
       break;
     case "xpcom-shutdown":
       gOS.removeObserver(this, "xpcom-shutdown");
       gOS = null;
       gPref = null;
       gConsole = null;
       gVersionChecker = null;
       gApp = null;
       break;
+    case "nsPref:changed":
+      switch (aData) {
+        case PREF_BLOCKLIST_ENABLED:
+          gBlocklistEnabled = getPref("getBoolPref", PREF_BLOCKLIST_ENABLED, true);
+          this._loadBlocklist();
+          this._blocklistUpdated(null, null);
+          break;
+        case PREF_BLOCKLIST_LEVEL:
+          gBlocklistLevel = Math.min(getPref("getIntPref", PREF_BLOCKLIST_LEVEL, DEFAULT_LEVEL),
+                                     MAX_BLOCK_LEVEL);
+          this._blocklistUpdated(null, null);
+          break;
+      }
+      break;
     }
   },
 
+  /* See nsIBlocklistService */
   isAddonBlocklisted: function(id, version, appVersion, toolkitVersion) {
+    return this.getAddonBlocklistState(id, version, appVersion, toolkitVersion) ==
+                   Ci.nsIBlocklistService.STATE_BLOCKED;
+  },
+
+  /* See nsIBlocklistService */
+  getAddonBlocklistState: function(id, version, appVersion, toolkitVersion) {
     if (!this._addonEntries)
       this._loadBlocklist();
+    return this._getAddonBlocklistState(id, version, this._addonEntries,
+                                        appVersion, toolkitVersion);
+  },
+
+  /**
+   * Private version of getAddonBlocklistState that allows the caller to pass in
+   * the add-on blocklist entries to compare against.
+   *
+   * @param   id
+   *          The ID of the item to get the blocklist state for.
+   * @param   version
+   *          The version of the item to get the blocklist state for.
+   * @param   addonEntries
+   *          The add-on blocklist entries to compare against.
+   * @param   appVersion
+   *          The application version to compare to, will use the current
+   *          version if null.
+   * @param   toolkitVersion
+   *          The toolkit version to compare to, will use the current version if
+   *          null.
+   * @returns The blocklist state for the item, one of the STATE constants as
+   *          defined in nsIBlocklistService.
+   */
+  _getAddonBlocklistState: function(id, version, addonEntries, appVersion, toolkitVersion) {
+    if (!gBlocklistEnabled)
+      return Ci.nsIBlocklistService.STATE_NOT_BLOCKED;
+
     if (!appVersion)
       appVersion = gApp.version;
     if (!toolkitVersion)
       toolkitVersion = gApp.platformVersion;
 
-    var blItem = this._addonEntries[id];
+    var blItem = addonEntries[id];
     if (!blItem)
-      return false;
+      return Ci.nsIBlocklistService.STATE_NOT_BLOCKED;
 
     for (var i = 0; i < blItem.length; ++i) {
       if (blItem[i].includesItem(version, appVersion, toolkitVersion))
-        return true;
+        return blItem[i].severity >= gBlocklistLevel ? Ci.nsIBlocklistService.STATE_BLOCKED :
+                                                       Ci.nsIBlocklistService.STATE_SOFTBLOCKED;
     }
-    return false;
+    return Ci.nsIBlocklistService.STATE_NOT_BLOCKED;
   },
 
   notify: function(aTimer) {
-    if (getPref("getBoolPref", PREF_BLOCKLIST_ENABLED, true) == false)
+    if (!gBlocklistEnabled)
       return;
 
     try {
       var dsURI = gPref.getCharPref(PREF_BLOCKLIST_URL);
     }
     catch (e) {
       LOG("Blocklist::notify: The " + PREF_BLOCKLIST_URL + " preference" +
           " is missing!");
@@ -458,16 +527,21 @@ Blocklist.prototype = {
     request.overrideMimeType("text/xml");
     request.setRequestHeader("Cache-Control", "no-cache");
     request.QueryInterface(Components.interfaces.nsIJSXMLHttpRequest);
 
     var self = this;
     request.onerror = function(event) { self.onXMLError(event); };
     request.onload  = function(event) { self.onXMLLoad(event);  };
     request.send(null);
+
+    // When the blocklist loads we need to compare it to the current copy so
+    // make sure we have loaded it.
+    if (!this._addonEntries)
+      this._loadBlocklist();
   },
 
   onXMLLoad: function(aEvent) {
     var request = aEvent.target;
     try {
       checkCert(request.channel);
     }
     catch (e) {
@@ -481,21 +555,24 @@ Blocklist.prototype = {
       return;
     }
     var blocklistFile = getFile(KEY_PROFILEDIR, [FILE_BLOCKLIST]);
     if (blocklistFile.exists())
       blocklistFile.remove(false);
     var fos = openSafeFileOutputStream(blocklistFile);
     fos.write(request.responseText, request.responseText.length);
     closeSafeFileOutputStream(fos);
+
+    var oldAddonEntries = this._addonEntries;
+    var oldPluginEntries = this._pluginEntries;
+    this._addonEntries = { };
+    this._pluginEntries = { };
     this._loadBlocklistFromFile(getFile(KEY_PROFILEDIR, [FILE_BLOCKLIST]));
-    var em = Cc["@mozilla.org/extensions/manager;1"].
-             getService(Ci.nsIExtensionManager);
-    em.checkForBlocklistChanges();
-    this._checkPluginsList();
+
+    this._blocklistUpdated(oldAddonEntries, oldPluginEntries);
   },
 
   onXMLError: function(aEvent) {
     try {
       var request = aEvent.target;
       // the following may throw (e.g. a local file or timeout)
       var status = request.status;
     }
@@ -579,17 +656,17 @@ Blocklist.prototype = {
 #          <match name="name" exp="some plugin"/>
 #          <match name="description" exp="1[.]2[.]3"/>
 #        </pluginItem>
 #      </pluginItems>
 #    </blocklist>
    */
 
   _loadBlocklistFromFile: function(file) {
-    if (getPref("getBoolPref", PREF_BLOCKLIST_ENABLED, true) == false) {
+    if (!gBlocklistEnabled) {
       LOG("Blocklist::_loadBlocklistFromFile: blocklist is disabled");
       return;
     }
 
     if (!file.exists()) {
       LOG("Blocklist::_loadBlocklistFromFile: XML File does not exist");
       return;
     }
@@ -685,58 +762,168 @@ Blocklist.prototype = {
       if (matchElement.localName == "match") {
         var name = matchElement.getAttribute("name");
         var exp = matchElement.getAttribute("exp");
         blockEntry.matches[name] = new RegExp(exp, "m");
       }
       if (matchElement.localName == "versionRange")
         blockEntry.versions.push(new BlocklistItemData(matchElement));
     }
+    // Add a default versionRange if there wasn't one specified
+    if (blockEntry.versions.length == 0)
+      blockEntry.versions.push(new BlocklistItemData(null));
     result.push(blockEntry);
   },
 
-  _isPluginBlocklisted: function(plugin, appVersion, toolkitVersion) {
-    for each (var blockEntry in this._pluginEntries) {
+  /* See nsIBlocklistService */
+  getPluginBlocklistState: function(plugin, appVersion, toolkitVersion) {
+    if (!this._pluginEntries)
+      this._loadBlocklist();
+    return this._getPluginBlocklistState(plugin, this._pluginEntries,
+                                         appVersion, toolkitVersion);
+  },
+
+  /**
+   * Private version of getPluginBlocklistState that allows the caller to pass in
+   * the plugin blocklist entries.
+   *
+   * @param   plugin
+   *          The nsIPluginTag to get the blocklist state for.
+   * @param   pluginEntries
+   *          The plugin blocklist entries to compare against.
+   * @param   appVersion
+   *          The application version to compare to, will use the current
+   *          version if null.
+   * @param   toolkitVersion
+   *          The toolkit version to compare to, will use the current version if
+   *          null.
+   * @returns The blocklist state for the item, one of the STATE constants as
+   *          defined in nsIBlocklistService.
+   */
+  _getPluginBlocklistState: function(plugin, pluginEntries, appVersion, toolkitVersion) {
+    if (!gBlocklistEnabled)
+      return Ci.nsIBlocklistService.STATE_NOT_BLOCKED;
+
+    if (!appVersion)
+      appVersion = gApp.version;
+    if (!toolkitVersion)
+      toolkitVersion = gApp.platformVersion;
+
+    for each (var blockEntry in pluginEntries) {
       var matchFailed = false;
       for (var name in blockEntry.matches) {
         if (!(name in plugin) ||
             typeof(plugin[name]) != "string" ||
             !blockEntry.matches[name].test(plugin[name])) {
           matchFailed = true;
           break;
         }
       }
 
       if (matchFailed)
         continue;
 
-      // No version ranges means match any versions
-      if (blockEntry.versions.length == 0)
-        return true;
-
       for (var i = 0; i < blockEntry.versions.length; i++) {
         if (blockEntry.versions[i].includesItem(plugin.version, appVersion,
                                                 toolkitVersion))
-          return true;
+          return blockEntry.versions[i].severity >= gBlocklistLevel ?
+                                                    Ci.nsIBlocklistService.STATE_BLOCKED :
+                                                    Ci.nsIBlocklistService.STATE_SOFTBLOCKED;
       }
     }
 
-    return false;
+    return Ci.nsIBlocklistService.STATE_NOT_BLOCKED;
   },
 
-  _checkPluginsList: function() {
-    if (!this._addonEntries)
-      this._loadBlocklist();
+  _blocklistUpdated: function(oldAddonEntries, oldPluginEntries) {
+    var addonList = [];
+
+    var em = Cc["@mozilla.org/extensions/manager;1"].
+             getService(Ci.nsIExtensionManager);
+    var addons = em.updateAndGetNewBlocklistedItems({});
+
+    for (let i = 0; i < addons.length; i++) {
+      let oldState = -1;
+      if (oldAddonEntries)
+        oldState = this._getAddonBlocklistState(addons[i].id, addons[i].version,
+                                                oldAddonEntries);
+      let state = this.getAddonBlocklistState(addons[i].id, addons[i].version);
+      // We don't want to re-warn about items
+      if (state == oldState)
+        continue;
+
+      addonList.push({
+        name: addons[i].name,
+        version: addons[i].version,
+        icon: addons[i].iconURL,
+        disable: false,
+        blocked: state == Ci.nsIBlocklistService.STATE_BLOCKED,
+        item: addons[i]
+      });
+    }
+
     var phs = Cc["@mozilla.org/plugin/host;1"].
               getService(Ci.nsIPluginHost);
     var plugins = phs.getPluginTags({});
-    for (var i = 0; i < plugins.length; i++)
-      plugins[i].blocklisted = this._isPluginBlocklisted(plugins[i],
-                                                         gApp.version,
-                                                         gApp.platformVersion);
+
+    for (let i = 0; i < plugins.length; i++) {
+      let oldState = -1;
+      if (oldPluginEntries)
+        oldState = this._getPluginBlocklistState(plugins[i], oldPluginEntries);
+      let state = this.getPluginBlocklistState(plugins[i]);
+      // We don't want to re-warn about items
+      if (state == oldState)
+        continue;
+
+      if (plugins[i].blocklisted) {
+        if (state == Ci.nsIBlocklistService.STATE_SOFTBLOCKED)
+          plugins[i].disabled = true;
+      }
+      else if (!plugins[i].disabled && state != Ci.nsIBlocklistService.STATE_NOT_BLOCKED) {
+        addonList.push({
+          name: plugins[i].name,
+          version: plugins[i].version,
+          icon: "chrome://mozapps/skin/plugins/pluginGeneric.png",
+          disable: false,
+          blocked: state == Ci.nsIBlocklistService.STATE_BLOCKED,
+          item: plugins[i]
+        });
+      }
+      plugins[i].blocklisted = state == Ci.nsIBlocklistService.STATE_BLOCKED;
+    }
+
+    if (addonList.length == 0)
+      return;
+
+    var args = {
+      restart: false,
+      list: addonList
+    };
+    // This lets the dialog get the raw js object
+    args.wrappedJSObject = args;
+
+    var ww = Cc["@mozilla.org/embedcomp/window-watcher;1"].
+             getService(Ci.nsIWindowWatcher);
+    ww.openWindow(null, URI_BLOCKLIST_DIALOG, "",
+                  "chrome,centerscreen,dialog,modal,titlebar", args);
+
+    for (let i = 0; i < addonList.length; i++) {
+      if (!addonList[i].disable)
+        continue;
+
+      if (addonList[i].item instanceof Ci.nsIUpdateItem)
+        em.disableItem(addonList[i].item.id);
+      else if (addonList[i].item instanceof Ci.nsIPluginTag)
+        addonList[i].item.disabled = true;
+      else
+        LOG("Unknown add-on type: " + addonList[i].item);
+    }
+
+    if (args.restart)
+      restartApp();
   },
 
   classDescription: "Blocklist Service",
   contractID: "@mozilla.org/extensions/blocklist;1",
   classID: Components.ID("{66354bc9-7ed1-4692-ae1d-8da97d6b205e}"),
   QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver,
                                          Ci.nsIBlocklistService,
                                          Ci.nsITimerCallback]),
@@ -748,16 +935,20 @@ Blocklist.prototype = {
 
 /**
  * Helper for constructing a blocklist.
  */
 function BlocklistItemData(versionRangeElement) {
   var versionRange = this.getBlocklistVersionRange(versionRangeElement);
   this.minVersion = versionRange.minVersion;
   this.maxVersion = versionRange.maxVersion;
+  if (versionRangeElement && versionRangeElement.hasAttribute("severity"))
+    this.severity = versionRangeElement.getAttribute("severity");
+  else
+    this.severity = DEFAULT_SEVERITY;
   this.targetApps = { };
   var found = false;
 
   if (versionRangeElement) {
     for (var i = 0; i < versionRangeElement.childNodes.length; ++i) {
       var targetAppElement = versionRangeElement.childNodes.item(i);
       if (!(targetAppElement instanceof Ci.nsIDOMElement) ||
           targetAppElement.localName != "targetApplication")
diff -r 4f1383af8f10 toolkit/mozapps/extensions/src/nsExtensionManager.js.in
--- a/toolkit/mozapps/extensions/src/nsExtensionManager.js.in	Sat Nov 01 09:52:29 2008 +0100
+++ b/toolkit/mozapps/extensions/src/nsExtensionManager.js.in	Mon Nov 03 05:09:10 2008 -0500
@@ -147,16 +147,17 @@ const INSTALLERROR_INVALID_GUID         
 const INSTALLERROR_INVALID_GUID          = -2;
 const INSTALLERROR_INCOMPATIBLE_VERSION  = -3;
 const INSTALLERROR_PHONED_HOME           = -4;
 const INSTALLERROR_INCOMPATIBLE_PLATFORM = -5;
 const INSTALLERROR_BLOCKLISTED           = -6;
 const INSTALLERROR_INSECURE_UPDATE       = -7;
 const INSTALLERROR_INVALID_MANIFEST      = -8;
 const INSTALLERROR_RESTRICTED            = -9;
+const INSTALLERROR_SOFTBLOCKED           = -10;
 
 const MODE_RDONLY   = 0x01;
 const MODE_WRONLY   = 0x02;
 const MODE_CREATE   = 0x08;
 const MODE_APPEND   = 0x10;
 const MODE_TRUNCATE = 0x20;
 
 const PERMS_FILE      = 0644;
@@ -764,43 +765,40 @@ function showMessage(titleKey, titlePara
   else
     message = extensionStrings.GetStringFromName(messageKey);
   var ps = Cc["@mozilla.org/embedcomp/prompt-service;1"].
            getService(Ci.nsIPromptService);
   ps.alert(null, title, message);
 }
 
 /**
- * Shows a dialog for blocklisted items.
- * @param   items
- *          An array of nsIUpdateItems.
- * @param   fromInstall
- *          Whether this is called from an install or from the blocklist
- *          background check.
- */
-function showBlocklistMessage(items, fromInstall) {
-  var win = null;
+ * Shows a dialog for a blocklisted item. For soft blocked items this will
+ * return true if the item should still be installed
+ * @param   item
+ *          The nsIUpdateItem that is blocklisted
+ * @param   softblocked
+ *          True if this item is only soft blocked and may still be installed.
+ */
+function showBlocklistMessage(item, softblocked) {
   var params = Cc["@mozilla.org/embedcomp/dialogparam;1"].
                createInstance(Ci.nsIDialogParamBlock);
-  params.SetInt(0, (fromInstall ? 1 : 0));
-  params.SetInt(1, items.length);
-  params.SetNumberStrings(items.length * 2);
-  for (var i = 0; i < items.length; ++i)
-    params.SetString(i, items[i].name + " " + items[i].version);
-
-  // if this was initiated from an install try to find the appropriate manager
-  if (fromInstall) {
-    var wm = Cc["@mozilla.org/appshell/window-mediator;1"].
-             getService(Ci.nsIWindowMediator);
-    win = wm.getMostRecentWindow("Extension:Manager");
-  }
+  params.SetInt(0, softblocked ? 1 : 0);
+  params.SetInt(1, 0);
+  params.SetNumberStrings(1);
+  params.SetString(0, item.name + " " + item.version);
+
+  var wm = Cc["@mozilla.org/appshell/window-mediator;1"].
+           getService(Ci.nsIWindowMediator);
+  var win = wm.getMostRecentWindow("Extension:Manager");
   var ww = Cc["@mozilla.org/embedcomp/window-watcher;1"].
            getService(Ci.nsIWindowWatcher);
   ww.openWindow(win, URI_EXTENSION_LIST_DIALOG, "",
                 "chrome,centerscreen,modal,dialog,titlebar", params);
+
+  return params.GetInt(1) == 0 ? false : true;
 }
 
 /**
  * Gets a zip reader for the file specified.
  * @param   zipFile
  *          A ZIP archive to open with a nsIZipReader.
  * @return  A nsIZipReader for the file specified.
  */
@@ -2973,16 +2971,21 @@ ExtensionManager.prototype = {
         LOG("... success, item installed but does not provide updates securely");
         callback(installManifest, installData.id, location, installData.type);
         this._appDisableItem(id);
       }
       else if (installData.error == INSTALLERROR_BLOCKLISTED) {
         LOG("... success, item installed but is blocklisted");
         callback(installManifest, installData.id, location, installData.type);
         this._appDisableItem(id);
+      }
+      else if (installData.error == INSTALLERROR_SOFTBLOCKED) {
+        LOG("... success, item installed but is soft blocked, item will be disabled");
+        callback(installManifest, installData.id, location, installData.type);
+        this.disableItem(id);
       }
       else {
         /**
          * Turns an error code into a message for logging
          * @param   error
          *          an Install Error code
          * @returns A string message to be logged.
          */
@@ -4251,19 +4254,21 @@ ExtensionManager.prototype = {
       installData.error = INSTALLERROR_INCOMPATIBLE_VERSION;
       return installData;
     }
     
     // Check if the item is blocklisted.
     if (!gBlocklist)
       gBlocklist = Cc["@mozilla.org/extensions/blocklist;1"].
                    getService(Ci.nsIBlocklistService);
-    if (gBlocklist.isAddonBlocklisted(installData.id, installData.version,
-                                      null, null))
+    var state = gBlocklist.getAddonBlocklistState(installData.id, installData.version);
+    if (state == Ci.nsIBlocklistService.STATE_BLOCKED)
       installData.error = INSTALLERROR_BLOCKLISTED;
+    else if (state == Ci.nsIBlocklistService.STATE_SOFTBLOCKED)
+      installData.error = INSTALLERROR_SOFTBLOCKED;
 
     return installData;
   },
 
   /**
    * Installs an item from a XPI/JAR file.
    * This is the main entry point into the Install system from outside code
    * (e.g. XPInstall).
@@ -4477,56 +4482,56 @@ ExtensionManager.prototype = {
        * @param   installManifest
        *          The Install Manifest datasource for the item.
        * @param   xpiFile
        *          The staged source XPI file that contains the item. Cleaned
        *          up by this process.
        * @param   installRDF
        *          The install.rdf file that was extracted from the xpi.
        */
-      checkForUpdates: function EM_checkForUpdates(item, installManifest, xpiFile) {
+      checkForUpdates: function IncObs_checkForUpdates(item, installManifest, xpiFile) {
         this._xpi             = xpiFile;
         this._installManifest = installManifest;
 
         for (var i = 0; i < em._installListeners.length; ++i)
           em._installListeners[i].onCompatibilityCheckStarted(item);
         em._compatibilityCheckCount++;
         em.update([item], 1, Ci.nsIExtensionManager.UPDATE_CHECK_COMPATIBILITY, this);
       },
 
       /**
        * See nsIExtensionManager.idl
        */
-      onUpdateStarted: function EM_onUpdateStarted() {
+      onUpdateStarted: function IncObs_onUpdateStarted() {
         LOG("Phone Home Listener: Update Started");
       },
 
       /**
        * See nsIExtensionManager.idl
        */
-      onUpdateEnded: function EM_onUpdateEnded() {
+      onUpdateEnded: function IncObs_onUpdateEnded() {
         LOG("Phone Home Listener: Update Ended");
       },
 
       /**
        * See nsIExtensionManager.idl
        */
-      onAddonUpdateStarted: function EM_onAddonUpdateStarted(addon) {
+      onAddonUpdateStarted: function IncObs_onAddonUpdateStarted(addon) {
         if (!addon)
           throw Cr.NS_ERROR_INVALID_ARG;
 
         LOG("Phone Home Listener: Update For " + addon.id + " started");
         em.datasource.addIncompatibleUpdateItem(addon.name, this._xpi.path,
                                                 addon.type, addon.version);
       },
 
       /**
        * See nsIExtensionManager.idl
        */
-      onAddonUpdateEnded: function EM_onAddonUpdateEnded(addon, status) {
+      onAddonUpdateEnded: function IncObs_onAddonUpdateEnded(addon, status) {
         if (!addon)
           throw Cr.NS_ERROR_INVALID_ARG;
 
         LOG("Phone Home Listener: Update For " + addon.id + " ended, status = " + status);
         em.datasource.removeDownload(this._xpi.path);
         LOG("Version Check Phone Home Completed");
 
         for (var i = 0; i < em._installListeners.length; ++i)
@@ -4661,16 +4666,20 @@ ExtensionManager.prototype = {
         //        app that can handle this item, if so just stage and don't show
         //        this error!
         showIncompatibleError(installData);
         LOG("Add-on " + installData.id + " is incompatible with " +
             BundleManager.appName + " " + gApp.version + ", Toolkit " +
             gApp.platformVersion + ". Remote compatibility check was not performed.");
       }
       break;
+    case INSTALLERROR_SOFTBLOCKED:
+      if (!showBlocklistMessage(installData, true))
+        break;
+      // Fall through to continue the install
     case INSTALLERROR_SUCCESS:
       // Installation of multiple extensions / themes contained within a single xpi.
       if (installData.type == Ci.nsIUpdateItem.TYPE_MULTI_XPI) {
         installMultiXPI(aXPIFile, installData);
         break;
       }
 
       // Stage the extension's XPI so it can be extracted at the next restart.
@@ -4754,17 +4763,17 @@ ExtensionManager.prototype = {
       showMessage("incompatibleTitle",
                   [bundle.GetStringFromName("type-" + installData.type)],
                   "incompatiblePlatformMessage",
                   [installData.name, BundleManager.appName, osABI]);
       break;
     case INSTALLERROR_BLOCKLISTED:
       LOG("Blocklisted Item: Item: \"" + installData.id + "\" version " +
           installData.version + " was not installed.");
-      showBlocklistMessage([installData], true);
+      showBlocklistMessage(installData, false);
       break;
     case INSTALLERROR_INSECURE_UPDATE:
       LOG("No secure updates: Item: \"" + installData.id + "\" version " + 
           installData.version + " was not installed.");
       var bundle = BundleManager.getBundle(URI_EXTENSIONS_PROPERTIES);
       showMessage("incompatibleTitle", 
                   [bundle.GetStringFromName("type-" + installData.type)], 
                   "insecureUpdateMessage", [installData.name]);
@@ -5484,42 +5493,61 @@ ExtensionManager.prototype = {
       items = this.getItemList(Ci.nsIUpdateItem.TYPE_ANY, { });
 
     var updater = new ExtensionItemUpdater(this);
     updater.checkForUpdates(items, items.length, updateCheckType, listener,
                             appVersion, platformVersion);
   },
 
   /**
-   * Checks for changes to the blocklist using the local blocklist file,
-   * application disables / enables items that have been added / removed from
-   * the blocklist, and if there are additions to the blocklist this will
-   * inform the user by displaying a list of the items added.
-   *
-   * XXXrstrong - this method is not terribly useful and was added so we can
-   * trigger this check from the additional timer used by blocklisting.
-   */
-  checkForBlocklistChanges: function EM_checkForBlocklistChanges() {
+   * See nsIExtensionManager.idl
+   */
+  updateAndGetNewBlocklistedItems: function EM_updateAndGetNewBlocklistedItems(itemCount) {
+    if (!gBlocklist)
+      gBlocklist = Cc["@mozilla.org/extensions/blocklist;1"].
+                   getService(Ci.nsIBlocklistService);
+
+    var list = [];
     var ds = this.datasource;
     var items = this.getItemList(Ci.nsIUpdateItem.TYPE_ANY, { });
     for (var i = 0; i < items.length; ++i) {
       var id = items[i].id;
+
+      // Get whether the add-on is currently disabled or set to be disabled.
+      var appDisabled = (ds.getItemProperty(id, "appDisabled") == "true" ||
+                         ds.getItemProperty(id, "appDisabled") == OP_NEEDS_DISABLE);
+      var userDisabled = (ds.getItemProperty(id, "userDisabled") == "true" ||
+                          ds.getItemProperty(id, "userDisabled") == OP_NEEDS_DISABLE);
+      var usable = this._isUsableItem(id);
+      var state = gBlocklist.getAddonBlocklistState(items[i].id, items[i].version);
+
+      // We only return items that are now blocked or to be warned about and aren't
+      // already disabled for some reason.
+      if (!appDisabled && !userDisabled && state != Ci.nsIBlocklistService.STATE_NOT_BLOCKED)
+        list.push(items[i]);
+
+      // Update the appDisabled status based on the new blocked state
+      if (usable)
+        this._appEnableItem(id);
+      else
+        this._appDisableItem(id);
+
+      // If the item was appDisabled and is now usable then it is something
+      // that is no longer hard blocked. If it is still to be warned about then
+      // just user disable it.
+      if (appDisabled && usable && !userDisabled &&
+          state == Ci.nsIBlocklistService.STATE_SOFTBLOCKED)
+        this.disableItem(id);
+
       ds.updateProperty(id, "blocklisted");
-      if (this._isUsableItem(id))
-        this._appEnableItem(id);
-    }
-
-    items = ds.getBlocklistedItemList(null, null, Ci.nsIUpdateItem.TYPE_ANY,
-                                      false);
-    for (i = 0; i < items.length; ++i)
-      this._appDisableItem(items[i].id);
-
-    // show the blocklist notification window if there are new blocklist items.
-    if (items.length > 0)
-      showBlocklistMessage(items, false);
+      ds.updateProperty(id, "blocklistedsoft");
+    }
+
+    itemCount.value = list.length;
+    return list;
   },
 
   /**
    * @returns An enumeration of all registered Install Locations.
    */
   get installLocations () {
     return InstallLocations.enumeration;
   },
@@ -5558,24 +5586,17 @@ ExtensionManager.prototype = {
    *          specified by the id parameter.
    */
   getDependentItemListForID: function EM_getDependentItemListForID(id,
                                                                    includeDisabled,
                                                                    countRef) {
     return this.datasource.getDependentItemListForID(id, includeDisabled, countRef);
   },
 
-  /**
-   * Retrieves a list of nsIUpdateItems of items matching the specified type.
-   * @param   type
-   *          The type of item to return.
-   * @param   countRef
-   *          The XPCJS reference to the number of items returned.
-   * @returns An array of nsIUpdateItems matching the id/type filter.
-   */
+  /* See nsIExtensionManager.idl */
   getItemList: function EM_getItemList(type, countRef) {
     return this.datasource.getItemList(type, countRef);
   },
 
   /* See nsIExtensionManager.idl */
   getIncompatibleItemList: function EM_getIncompatibleItemList(id, appVersion,
                                                                platformVersion,
                                                                type,
@@ -6306,18 +6327,20 @@ ExtensionItemUpdater.prototype = {
 
     // Check if the update will only run on an older version of the application.
     if (!max || gVersionChecker.compare(appExtensionsVersion, max) > 0)
       return false;
 
     if (!gBlocklist)
       gBlocklist = Cc["@mozilla.org/extensions/blocklist;1"].
                    getService(Ci.nsIBlocklistService);
+    // Denies updates that are hard blocked, soft blocked items will be warned
+    // about during the install.
     if (gBlocklist.isAddonBlocklisted(aLocalItem.id, aRemoteItem.version,
-                                      null, null))
+                                      this._appVersion, this._platformVersion))
       return false;
 
     return true;
   },
 
   checkForDone: function ExtensionItemUpdater_checkForDone(item, status) {
     if (this._listener) {
       try {
@@ -7238,59 +7261,16 @@ ExtensionsDataSource.prototype = {
       if (type != -1 && (type & desiredType) &&
           !this.isCompatible(this, item, appVersion, platformVersion))
         items.push(this.getItemForID(id));
     }
     return items;
   },
 
   /**
-   * Retrieves a list of items that will be blocklisted by the application for
-   * a specific application or toolkit version.
-   * @param   appVersion
-   *          The Version of the application to check the blocklist against.
-   * @param   platformVersion
-   *          The Version of the toolkit to check the blocklist against.
-   * @param   desiredType
-   *          The nsIUpdateItem type of items to look for
-   * @param   includeAppDisabled
-   *          Whether or not items that are or are already set to be disabled
-   *          by the app on next restart should be included in the set returned
-   * @returns An array of nsIUpdateItems that are blocklisted with the application
-   *          or toolkit version supplied.
-   */
-  getBlocklistedItemList: function EMDS_getBlocklistedItemList(appVersion,
-                                                               platformVersion,
-                                                               desiredType,
-                                                               includeAppDisabled) {
-    if (!gBlocklist)
-      gBlocklist = Cc["@mozilla.org/extensions/blocklist;1"].
-                   getService(Ci.nsIBlocklistService);
-    var items = [];
-    var ctr = getContainer(this._inner, this._itemRoot);
-    var elements = ctr.GetElements();
-    while (elements.hasMoreElements()) {
-      var item = elements.getNext().QueryInterface(Ci.nsIRDFResource);
-      var id = stripPrefix(item.Value, PREFIX_ITEM_URI);
-      var type = this.getItemProperty(id, "type");
-
-      if (!includeAppDisabled &&
-          (this.getItemProperty(id, "appDisabled") == "true" ||
-          this.getItemProperty(id, "appDisabled") == OP_NEEDS_DISABLE))
-        continue;
-
-      var version = this.getItemProperty(id, "version");
-      if (type != -1 && (type & desiredType) &&
-          gBlocklist.isAddonBlocklisted(id, version, appVersion, platformVersion))
-        items.push(this.getItemForID(id));
-    }
-    return items;
-  },
-
-  /**
    * Gets a list of items of a specific type
    * @param   desiredType
    *          The nsIUpdateItem type of items to return
    * @param   countRef
    *          The XPCJS reference to the size of the returned array
    * @returns An array of nsIUpdateItems, populated only with an item for |id|
    *          if |id| is non-null, otherwise all items matching the specified
    *          type.
@@ -8450,17 +8430,33 @@ ExtensionsDataSource.prototype = {
    * Get the em:blocklisted property (whether or not this item is blocklisted)
    */
   _rdfGet_blocklisted: function EMDS__rdfGet_blocklisted(item, property) {
     var id = stripPrefix(item.Value, PREFIX_ITEM_URI);
     var version = this.getItemProperty(id, "version");
     if (!gBlocklist)
       gBlocklist = Cc["@mozilla.org/extensions/blocklist;1"].
                    getService(Ci.nsIBlocklistService);
-    if (gBlocklist.isAddonBlocklisted(id, version, null, null))
+    if (gBlocklist.getAddonBlocklistState(id, version) == Ci.nsIBlocklistService.STATE_BLOCKED)
+      return EM_L("true");
+
+    return EM_L("false");
+  },
+
+  /**
+   * Get the em:blocklistedsoft property (whether or not this item is listed in the blocklist
+   * at a low severity)
+   */
+  _rdfGet_blocklistedsoft: function EMDS__rdfGet_blocklistedsoft(item, property) {
+    var id = stripPrefix(item.Value, PREFIX_ITEM_URI);
+    var version = this.getItemProperty(id, "version");
+    if (!gBlocklist)
+      gBlocklist = Cc["@mozilla.org/extensions/blocklist;1"].
+                   getService(Ci.nsIBlocklistService);
+    if (gBlocklist.getAddonBlocklistState(id, version) == Ci.nsIBlocklistService.STATE_SOFTBLOCKED)
       return EM_L("true");
 
     return EM_L("false");
   },
 
   /**
    * Get the em:state property (represents the current phase of an install).
    */
diff -r 4f1383af8f10 toolkit/mozapps/extensions/test/unit/data/bug455906_block.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/mozapps/extensions/test/unit/data/bug455906_block.xml	Mon Nov 03 05:09:10 2008 -0500
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<blocklist xmlns="http://www.mozilla.org/2006/addons-blocklist">
+  <emItems>
+    <emItem id="test_bug455906_1@tests.mozilla.org"/>
+    <emItem id="test_bug455906_2@tests.mozilla.org"/>
+    <emItem id="test_bug455906_3@tests.mozilla.org"/>
+    <emItem id="test_bug455906_4@tests.mozilla.org"/>
+    <emItem id="test_bug455906_5@tests.mozilla.org"/>
+    <emItem id="test_bug455906_6@tests.mozilla.org"/>
+    <emItem id="test_bug455906_7@tests.mozilla.org"/>
+  </emItems>
+  <pluginItems>
+    <pluginItem>
+      <match name="name" exp="^test_bug455906"/>
+    </pluginItem>
+  </pluginItems>
+</blocklist>
diff -r 4f1383af8f10 toolkit/mozapps/extensions/test/unit/data/bug455906_empty.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/mozapps/extensions/test/unit/data/bug455906_empty.xml	Mon Nov 03 05:09:10 2008 -0500
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<blocklist xmlns="http://www.mozilla.org/2006/addons-blocklist">
+  <emItems>
+    <emItem id="dummy_bug455906_2@tests.mozilla.org"/>
+  </emItems>
+</blocklist>
diff -r 4f1383af8f10 toolkit/mozapps/extensions/test/unit/data/bug455906_start.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/mozapps/extensions/test/unit/data/bug455906_start.xml	Mon Nov 03 05:09:10 2008 -0500
@@ -0,0 +1,30 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<blocklist xmlns="http://www.mozilla.org/2006/addons-blocklist">
+  <emItems>
+    <emItem id="test_bug455906_4@tests.mozilla.org">
+      <versionRange severity="0"/>
+    </emItem>
+    <emItem id="test_bug455906_5@tests.mozilla.org">
+      <versionRange severity="1"/>
+    </emItem>
+    <emItem id="test_bug455906_6@tests.mozilla.org">
+      <versionRange severity="2"/>
+    </emItem>
+    <emItem id="dummy_bug455906_1@tests.mozilla.org"/>
+  </emItems>
+  <pluginItems>
+    <pluginItem>
+      <match name="name" exp="^test_bug455906_4$"/>
+      <versionRange severity="0"/>
+    </pluginItem>
+    <pluginItem>
+      <match name="name" exp="^test_bug455906_5$"/>
+      <versionRange severity="1"/>
+    </pluginItem>
+    <pluginItem>
+      <match name="name" exp="^test_bug455906_6$"/>
+      <versionRange severity="2"/>
+    </pluginItem>
+  </pluginItems>
+</blocklist>
diff -r 4f1383af8f10 toolkit/mozapps/extensions/test/unit/data/bug455906_warn.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/mozapps/extensions/test/unit/data/bug455906_warn.xml	Mon Nov 03 05:09:10 2008 -0500
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<blocklist xmlns="http://www.mozilla.org/2006/addons-blocklist">
+  <emItems>
+    <emItem id="test_bug455906_1@tests.mozilla.org">
+      <versionRange severity="0"/>
+    </emItem>
+    <emItem id="test_bug455906_2@tests.mozilla.org">
+      <versionRange severity="0"/>
+    </emItem>
+    <emItem id="test_bug455906_3@tests.mozilla.org">
+      <versionRange severity="0"/>
+    </emItem>
+    <emItem id="test_bug455906_4@tests.mozilla.org">
+      <versionRange severity="0"/>
+    </emItem>
+    <emItem id="test_bug455906_5@tests.mozilla.org">
+      <versionRange severity="0"/>
+    </emItem>
+    <emItem id="test_bug455906_6@tests.mozilla.org">
+      <versionRange severity="0"/>
+    </emItem>
+    <emItem id="test_bug455906_7@tests.mozilla.org">
+      <versionRange severity="0"/>
+    </emItem>
+  </emItems>
+  <pluginItems>
+    <pluginItem>
+      <match name="name" exp="^test_bug455906"/>
+      <versionRange severity="0"/>
+    </pluginItem>
+  </pluginItems>
+</blocklist>
diff -r 4f1383af8f10 toolkit/mozapps/extensions/test/unit/test_bug449027.js
--- a/toolkit/mozapps/extensions/test/unit/test_bug449027.js	Sat Nov 01 09:52:29 2008 +0100
+++ b/toolkit/mozapps/extensions/test/unit/test_bug449027.js	Mon Nov 03 05:09:10 2008 -0500
@@ -30,17 +30,17 @@
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL
  *
  * ***** END LICENSE BLOCK *****
  */
-const URI_EXTENSION_LIST_DIALOG = "chrome://mozapps/content/extensions/list.xul";
+const URI_EXTENSION_BLOCKLIST_DIALOG = "chrome://mozapps/content/extensions/blocklist.xul";
 
 do_import_script("netwerk/test/httpserver/httpd.js");
 
 var ADDONS = [{
   id: "test_bug449027_1@tests.mozilla.org",
   name: "Bug 449027 Addon Test 1",
   version: "5",
   start: false,
@@ -421,24 +421,25 @@ var PluginHostFactory = {
   }
 };
 
 // Don't need the full interface, attempts to call other methods will just
 // throw which is just fine
 var WindowWatcher = {
   openWindow: function(parent, url, name, features, arguments) {
     // Should be called to list the newly blocklisted items
-    do_check_eq(url, URI_EXTENSION_LIST_DIALOG);
+    do_check_eq(url, URI_EXTENSION_BLOCKLIST_DIALOG);
     do_check_neq(gCallback, null);
-    do_check_true(arguments instanceof Components.interfaces.nsIDialogParamBlock);
+
+    var args = arguments.wrappedJSObject;
 
     gNewBlocks = [];
-    var count = arguments.GetInt(1);
-    for (var i = 0; i < count; i++)
-      gNewBlocks.push(arguments.GetString(i));
+    var list = args.list;
+    for (var i = 0; i < list.length; i++)
+      gNewBlocks.push(list[i].name + " " + list[i].version);
 
     // Call the callback after the blocklist has finished up
     do_timeout(0, "gCallback()");
   },
 
   QueryInterface: function(iid) {
     if (iid.equals(Components.interfaces.nsIWindowWatcher)
      || iid.equals(Components.interfaces.nsISupports))
@@ -513,16 +514,23 @@ function check_state(test, lastTest) {
     var expected = 0;
     for (i = 0; i < ADDONS.length; i++) {
       if (ADDONS[i][test] && !ADDONS[i][lastTest]) {
         if (gNewBlocks.indexOf(ADDONS[i].name + " " + ADDONS[i].version) < 0)
           do_throw("Addon " + (i + 1) + " should have been listed in the blocklist notification for test " + test);
         expected++;
       }
     }
+    for (i = 0; i < PLUGINS.length; i++) {
+      if (PLUGINS[i][test] && !PLUGINS[i][lastTest]) {
+        if (gNewBlocks.indexOf(PLUGINS[i].name + " " + PLUGINS[i].version) < 0)
+          do_throw("Plugin " + (i + 1) + " should have been listed in the blocklist notification for test " + test);
+        expected++;
+      }
+    }
 
     do_check_eq(expected, gNewBlocks.length);
   }
 }
 
 function load_blocklist(file) {
   gPrefs.setCharPref("extensions.blocklist.url", "http://localhost:4444/data/" + file);
   var blocklist = Components.classes["@mozilla.org/extensions/blocklist;1"]
@@ -535,16 +543,17 @@ function run_test() {
   dump("Setting up tests\n");
   // Rather than keeping lots of identical add-ons in version control, just
   // write them into the profile.
   for (var i = 0; i < ADDONS.length; i++)
     create_addon(ADDONS[i]);
 
   createAppInfo("xpcshell@tests.mozilla.org", "XPCShell", "3", "8");
   startupEM();
+
   gTestserver = new nsHttpServer();
   gTestserver.registerDirectory("/data/", do_get_file("toolkit/mozapps/extensions/test/unit/data"));
   gTestserver.start(4444);
 
   do_test_pending();
   check_test_pt1();
 }
 
diff -r 4f1383af8f10 toolkit/mozapps/extensions/test/unit/test_bug455906.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/mozapps/extensions/test/unit/test_bug455906.js	Mon Nov 03 05:09:10 2008 -0500
@@ -0,0 +1,531 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Dave Townsend <dtownsend@oxymoronical.com>.
+ *
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL
+ *
+ * ***** END LICENSE BLOCK *****
+ */
+const URI_EXTENSION_BLOCKLIST_DIALOG = "chrome://mozapps/content/extensions/blocklist.xul";
+
+do_import_script("netwerk/test/httpserver/httpd.js");
+
+var ADDONS = [{
+  // Tests how the blocklist affects a disabled add-on
+  id: "test_bug455906_1@tests.mozilla.org",
+  name: "Bug 455906 Addon Test 1",
+  version: "5",
+  appVersion: "3"
+}, {
+  // Tests how the blocklist affects an enabled add-on
+  id: "test_bug455906_2@tests.mozilla.org",
+  name: "Bug 455906 Addon Test 2",
+  version: "5",
+  appVersion: "3"
+}, {
+  // Tests how the blocklist affects an enabled add-on, to be disabled by the notification
+  id: "test_bug455906_3@tests.mozilla.org",
+  name: "Bug 455906 Addon Test 3",
+  version: "5",
+  appVersion: "3"
+}, {
+  // Tests how the blocklist affects a disabled add-on that was already warned about
+  id: "test_bug455906_4@tests.mozilla.org",
+  name: "Bug 455906 Addon Test 4",
+  version: "5",
+  appVersion: "3"
+}, {
+  // Tests how the blocklist affects an enabled add-on that was already warned about
+  id: "test_bug455906_5@tests.mozilla.org",
+  name: "Bug 455906 Addon Test 5",
+  version: "5",
+  appVersion: "3"
+}, {
+  // Tests how the blocklist affects an already blocked add-on
+  id: "test_bug455906_6@tests.mozilla.org",
+  name: "Bug 455906 Addon Test 6",
+  version: "5",
+  appVersion: "3"
+}, {
+  // Tests how the blocklist affects an incompatible add-on
+  id: "test_bug455906_7@tests.mozilla.org",
+  name: "Bug 455906 Addon Test 7",
+  version: "5",
+  appVersion: "2"
+}, {
+  // Spare add-on used to ensure we get a notification when switching lists
+  id: "dummy_bug455906_1@tests.mozilla.org",
+  name: "Dummy Addon 1",
+  version: "5",
+  appVersion: "3"
+}, {
+  // Spare add-on used to ensure we get a notification when switching lists
+  id: "dummy_bug455906_2@tests.mozilla.org",
+  name: "Dummy Addon 2",
+  version: "5",
+  appVersion: "3"
+}];
+
+var PLUGINS = [{
+  // Tests how the blocklist affects a disabled plugin
+  name: "test_bug455906_1",
+  version: "5",
+  disabled: true,
+  blocklisted: false
+}, {
+  // Tests how the blocklist affects an enabled plugin
+  name: "test_bug455906_2",
+  version: "5",
+  disabled: false,
+  blocklisted: false
+}, {
+  // Tests how the blocklist affects an enabled plugin, to be disabled by the notification
+  name: "test_bug455906_3",
+  version: "5",
+  disabled: false,
+  blocklisted: false
+}, {
+  // Tests how the blocklist affects a disabled plugin that was already warned about
+  name: "test_bug455906_4",
+  version: "5",
+  disabled: true,
+  blocklisted: false
+}, {
+  // Tests how the blocklist affects an enabled plugin that was already warned about
+  name: "test_bug455906_5",
+  version: "5",
+  disabled: false,
+  blocklisted: false
+}, {
+  // Tests how the blocklist affects an already blocked plugin
+  name: "test_bug455906_6",
+  version: "5",
+  disabled: false,
+  blocklisted: true
+}];
+
+var gNotificationCheck = null;
+var gTestCheck = null;
+var gTestserver = null;
+
+// A fake plugin host for the blocklist service to use
+var PluginHost = {
+  getPluginTags: function(countRef) {
+    countRef.value = PLUGINS.length;
+    return PLUGINS;
+  },
+
+  QueryInterface: function(iid) {
+    if (iid.equals(Ci.nsIPluginHost)
+     || iid.equals(Ci.nsISupports))
+      return this;
+  
+    throw Components.results.NS_ERROR_NO_INTERFACE;
+  }
+}
+
+var PluginHostFactory = {
+  createInstance: function (outer, iid) {
+    if (outer != null)
+      throw Components.results.NS_ERROR_NO_AGGREGATION;
+    return PluginHost.QueryInterface(iid);
+  }
+};
+
+// Don't need the full interface, attempts to call other methods will just
+// throw which is just fine
+var WindowWatcher = {
+  openWindow: function(parent, url, name, features, arguments) {
+    // Should be called to list the newly blocklisted items
+    do_check_eq(url, URI_EXTENSION_BLOCKLIST_DIALOG);
+
+    if (gNotificationCheck) {
+      var args = arguments.wrappedJSObject;
+      gNotificationCheck(args);
+    }
+
+    // Call the next test after the blocklist has finished up
+    do_timeout(0, "gTestCheck()");
+  },
+
+  QueryInterface: function(iid) {
+    if (iid.equals(Ci.nsIWindowWatcher)
+     || iid.equals(Ci.nsISupports))
+      return this;
+
+    throw Cr.NS_ERROR_NO_INTERFACE;
+  }
+}
+
+var WindowWatcherFactory = {
+  createInstance: function createInstance(outer, iid) {
+    if (outer != null)
+      throw Components.results.NS_ERROR_NO_AGGREGATION;
+    return WindowWatcher.QueryInterface(iid);
+  }
+};
+var registrar = Components.manager.QueryInterface(Components.interfaces.nsIComponentRegistrar);
+registrar.registerFactory(Components.ID("{721c3e73-969e-474b-a6dc-059fd288c428}"),
+                          "Fake Plugin Host",
+                          "@mozilla.org/plugin/host;1", PluginHostFactory);
+registrar.registerFactory(Components.ID("{1dfeb90a-2193-45d5-9cb8-864928b2af55}"),
+                          "Fake Window Watcher",
+                          "@mozilla.org/embedcomp/window-watcher;1", WindowWatcherFactory);
+
+function create_addon(addon) {
+  var installrdf = "<?xml version=\"1.0\"?>\n" +
+                   "\n" +
+                   "<RDF xmlns=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\n" +
+                   "     xmlns:em=\"http://www.mozilla.org/2004/em-rdf#\">\n" +
+                   "  <Description about=\"urn:mozilla:install-manifest\">\n" +
+                   "    <em:id>" + addon.id + "</em:id>\n" +
+                   "    <em:version>" + addon.version + "</em:version>\n" +
+                   "    <em:targetApplication>\n" +
+                   "      <Description>\n" +
+                   "        <em:id>xpcshell@tests.mozilla.org</em:id>\n" +
+                   "        <em:minVersion>" + addon.appVersion + "</em:minVersion>\n" +
+                   "        <em:maxVersion>" + addon.appVersion + "</em:maxVersion>\n" +
+                   "      </Description>\n" +
+                   "    </em:targetApplication>\n" +
+                   "    <em:name>" + addon.name + "</em:name>\n" +
+                   "  </Description>\n" +
+                   "</RDF>\n";
+  var target = gProfD.clone();
+  target.append("extensions");
+  target.append(addon.id);
+  target.append("install.rdf");
+  target.create(target.NORMAL_FILE_TYPE, 0644);
+  var stream = Cc["@mozilla.org/network/file-output-stream;1"].
+               createInstance(Ci.nsIFileOutputStream);
+  stream.init(target, 0x04 | 0x08 | 0x20, 0664, 0); // write, create, truncate
+  stream.write(installrdf, installrdf.length);
+  stream.close();
+}
+
+function load_blocklist(file) {
+  gPrefs.setCharPref("extensions.blocklist.url", "http://localhost:4444/data/" + file);
+  var blocklist = Cc["@mozilla.org/extensions/blocklist;1"].
+                  getService(Ci.nsITimerCallback);
+  blocklist.notify(null);
+}
+
+function isUserDisabled(id) {
+  return getManifestProperty(id, "userDisabled") == "true";
+}
+
+function isAppDisabled(id) {
+  return getManifestProperty(id, "appDisabled") == "true";
+}
+
+function check_addon_state(id) {
+  return isUserDisabled(id) + "," + isAppDisabled(id);
+}
+
+function check_plugin_state(plugin) {
+  return plugin.disabled + "," + plugin.blocklisted;
+}
+
+// Performs the initial setup
+function run_test() {
+  // Setup for test
+  dump("Setting up tests\n");
+  // Rather than keeping lots of identical add-ons in version control, just
+  // write them into the profile.
+  for (var i = 0; i < ADDONS.length; i++)
+    create_addon(ADDONS[i]);
+
+  // Copy the initial blocklist into the profile to check add-ons start in the
+  // right state.
+  var blocklist = do_get_file("toolkit/mozapps/extensions/test/unit/data/bug455906_start.xml")
+  blocklist.copyTo(gProfD, "blocklist.xml");
+
+  createAppInfo("xpcshell@tests.mozilla.org", "XPCShell", "3", "8");
+  startupEM();
+
+  gTestserver = new nsHttpServer();
+  gTestserver.registerDirectory("/data/", do_get_file("toolkit/mozapps/extensions/test/unit/data"));
+  gTestserver.start(4444);
+
+  do_test_pending();
+  check_test_pt1();
+}
+
+// Before every main test this is the state the add-ons are meant to be in
+function check_initial_state() {
+  do_check_eq(check_addon_state(ADDONS[0].id), "true,false");
+  do_check_eq(check_addon_state(ADDONS[1].id), "false,false");
+  do_check_eq(check_addon_state(ADDONS[2].id), "false,false");
+  do_check_eq(check_addon_state(ADDONS[3].id), "true,false");
+  do_check_eq(check_addon_state(ADDONS[4].id), "false,false");
+  do_check_eq(check_addon_state(ADDONS[5].id), "false,true");
+  do_check_eq(check_addon_state(ADDONS[6].id), "false,true");
+
+  do_check_eq(check_plugin_state(PLUGINS[0]), "true,false");
+  do_check_eq(check_plugin_state(PLUGINS[1]), "false,false");
+  do_check_eq(check_plugin_state(PLUGINS[2]), "false,false");
+  do_check_eq(check_plugin_state(PLUGINS[3]), "true,false");
+  do_check_eq(check_plugin_state(PLUGINS[4]), "false,false");
+  do_check_eq(check_plugin_state(PLUGINS[5]), "false,true");
+}
+
+// Tests the add-ons were installed and the initial blocklist applied as expected
+function check_test_pt1() {
+  dump("Checking pt 1\n");
+  for (var i = 0; i < ADDONS.length; i++) {
+    if (!gEM.getItemForID(ADDONS[i].id))
+      do_throw("Addon " + (i + 1) + " did not get installed correctly");
+  }
+
+  do_check_eq(check_addon_state(ADDONS[0].id), "false,false");
+  do_check_eq(check_addon_state(ADDONS[1].id), "false,false");
+  do_check_eq(check_addon_state(ADDONS[2].id), "false,false");
+
+  // Warn add-ons should be user disabled automatically
+  do_check_eq(check_addon_state(ADDONS[3].id), "true,false");
+  do_check_eq(check_addon_state(ADDONS[4].id), "true,false");
+
+  // Blocked and incompatible should be app disabled only
+  do_check_eq(check_addon_state(ADDONS[5].id), "false,true");
+  do_check_eq(check_addon_state(ADDONS[6].id), "false,true");
+
+  // We've overridden the plugin host so we cannot tell what that would have
+  // initialised the plugins as
+
+  // Put the add-ons into the base state
+  gEM.disableItem(ADDONS[0].id);
+  gEM.enableItem(ADDONS[4].id);
+  restartEM();
+  check_initial_state();
+
+  gNotificationCheck = check_notification_pt2;
+  gTestCheck = check_test_pt2;
+  load_blocklist("bug455906_warn.xml");
+}
+
+function check_notification_pt2(args) {
+  dump("Checking notification pt 2\n");
+  do_check_eq(args.list.length, 4);
+
+  for (let i = 0; i < args.list.length; i++) {
+    let addon = args.list[i];
+    if (addon.item instanceof Ci.nsIUpdateItem) {
+      switch (addon.item.id) {
+        case "test_bug455906_2@tests.mozilla.org":
+          do_check_false(addon.blocked);
+          break;
+        case "test_bug455906_3@tests.mozilla.org":
+          do_check_false(addon.blocked);
+          addon.disable = true;
+          break;
+        default:
+          do_throw("Unknown addon: " + addon.item.id);
+      }
+    }
+    else if (addon.item instanceof Ci.nsIPluginTag) {
+      switch (addon.item.name) {
+        case "test_bug455906_2":
+          do_check_false(addon.blocked);
+          break;
+        case "test_bug455906_3":
+          do_check_false(addon.blocked);
+          addon.disable = true;
+          break;
+        default:
+          do_throw("Unknown addon: " + addon.item.name);
+      }
+    }
+    else {
+      do_throw("Unknown add-on type " + addon.item);
+    }
+  }
+}
+
+function check_test_pt2() {
+  restartEM();
+  dump("Checking results pt 2\n");
+
+  // Should have disabled this add-on as requested
+  do_check_eq(check_addon_state(ADDONS[2].id), "true,false");
+  do_check_eq(check_plugin_state(PLUGINS[2]), "true,false");
+
+  // The blocked add-on should have changed to user disabled
+  do_check_eq(check_addon_state(ADDONS[5].id), "true,false");
+  do_check_eq(check_plugin_state(PLUGINS[5]), "true,false");
+
+  // These should have been unchanged
+  do_check_eq(check_addon_state(ADDONS[0].id), "true,false");
+  do_check_eq(check_addon_state(ADDONS[1].id), "false,false");
+  do_check_eq(check_addon_state(ADDONS[3].id), "true,false");
+  do_check_eq(check_addon_state(ADDONS[4].id), "false,false");
+  do_check_eq(check_addon_state(ADDONS[6].id), "false,true");
+  do_check_eq(check_plugin_state(PLUGINS[0]), "true,false");
+  do_check_eq(check_plugin_state(PLUGINS[1]), "false,false");
+  do_check_eq(check_plugin_state(PLUGINS[3]), "true,false");
+  do_check_eq(check_plugin_state(PLUGINS[4]), "false,false");
+
+  // Back to starting state
+  gEM.enableItem(ADDONS[2].id);
+  gEM.enableItem(ADDONS[5].id);
+  PLUGINS[2].disabled = false;
+  PLUGINS[5].disabled = false;
+  restartEM();
+  gNotificationCheck = null;
+  gTestCheck = run_test_pt3;
+  load_blocklist("bug455906_start.xml");
+}
+
+function run_test_pt3() {
+  restartEM();
+  check_initial_state();
+
+  gNotificationCheck = check_notification_pt3;
+  gTestCheck = check_test_pt3;
+  load_blocklist("bug455906_block.xml");
+}
+
+function check_notification_pt3(args) {
+  dump("Checking notification pt 3\n");
+  do_check_eq(args.list.length, 6);
+
+  for (let i = 0; i < args.list.length; i++) {
+    let addon = args.list[i];
+    if (addon.item instanceof Ci.nsIUpdateItem) {
+      switch (addon.item.id) {
+        case "test_bug455906_2@tests.mozilla.org":
+          do_check_true(addon.blocked);
+          break;
+        case "test_bug455906_3@tests.mozilla.org":
+          do_check_true(addon.blocked);
+          break;
+        case "test_bug455906_5@tests.mozilla.org":
+          do_check_true(addon.blocked);
+          break;
+        default:
+          do_throw("Unknown addon: " + addon.item.id);
+      }
+    }
+    else if (addon.item instanceof Ci.nsIPluginTag) {
+      switch (addon.item.name) {
+        case "test_bug455906_2":
+          do_check_true(addon.blocked);
+          break;
+        case "test_bug455906_3":
+          do_check_true(addon.blocked);
+          break;
+        case "test_bug455906_5":
+          do_check_true(addon.blocked);
+          break;
+        default:
+          do_throw("Unknown addon: " + addon.item.name);
+      }
+    }
+    else {
+      do_throw("Unknown add-on type " + addon.item);
+    }
+  }
+}
+
+function check_test_pt3() {
+  restartEM();
+  dump("Checking results pt 3\n");
+
+  // All should have gained the blocklist state, user disabled as previously
+  do_check_eq(check_addon_state(ADDONS[0].id), "true,true");
+  do_check_eq(check_addon_state(ADDONS[1].id), "false,true");
+  do_check_eq(check_addon_state(ADDONS[2].id), "false,true");
+  do_check_eq(check_addon_state(ADDONS[3].id), "true,true");
+  do_check_eq(check_addon_state(ADDONS[4].id), "false,true");
+  do_check_eq(check_plugin_state(PLUGINS[0]), "true,true");
+  do_check_eq(check_plugin_state(PLUGINS[1]), "false,true");
+  do_check_eq(check_plugin_state(PLUGINS[2]), "false,true");
+  do_check_eq(check_plugin_state(PLUGINS[3]), "true,true");
+  do_check_eq(check_plugin_state(PLUGINS[4]), "false,true");
+
+  // Shouldn't be changed
+  do_check_eq(check_addon_state(ADDONS[5].id), "false,true");
+  do_check_eq(check_addon_state(ADDONS[6].id), "false,true");
+  do_check_eq(check_plugin_state(PLUGINS[5]), "false,true");
+
+  // Back to starting state
+  gNotificationCheck = null;
+  gTestCheck = run_test_pt4;
+  load_blocklist("bug455906_start.xml");
+}
+
+function run_test_pt4() {
+  gEM.enableItem(ADDONS[4].id);
+  PLUGINS[4].disabled = false;
+  restartEM();
+  check_initial_state();
+
+  gNotificationCheck = check_notification_pt4;
+  gTestCheck = check_test_pt4;
+  load_blocklist("bug455906_empty.xml");
+}
+
+function check_notification_pt4(args) {
+  dump("Checking notification pt 4\n");
+
+  // Should be just the dummy add-on to force this notification
+  do_check_eq(args.list.length, 1);
+  do_check_true(args.list[0].item instanceof Ci.nsIUpdateItem);
+  do_check_eq(args.list[0].item.id, "dummy_bug455906_2@tests.mozilla.org");
+}
+
+function check_test_pt4() {
+  restartEM();
+  dump("Checking results pt 4\n");
+
+  // This should have become unblocked
+  do_check_eq(check_addon_state(ADDONS[5].id), "false,false");
+  do_check_eq(check_plugin_state(PLUGINS[5]), "false,false");
+
+  // No change for anything else
+  do_check_eq(check_addon_state(ADDONS[0].id), "true,false");
+  do_check_eq(check_addon_state(ADDONS[1].id), "false,false");
+  do_check_eq(check_addon_state(ADDONS[2].id), "false,false");
+  do_check_eq(check_addon_state(ADDONS[3].id), "true,false");
+  do_check_eq(check_addon_state(ADDONS[4].id), "false,false");
+  do_check_eq(check_addon_state(ADDONS[6].id), "false,true");
+  do_check_eq(check_plugin_state(PLUGINS[0]), "true,false");
+  do_check_eq(check_plugin_state(PLUGINS[1]), "false,false");
+  do_check_eq(check_plugin_state(PLUGINS[2]), "false,false");
+  do_check_eq(check_plugin_state(PLUGINS[3]), "true,false");
+  do_check_eq(check_plugin_state(PLUGINS[4]), "false,false");
+
+  finish();
+}
+
+function finish() {
+  gTestserver.stop();
+  do_test_finished();
+}
diff -r 4f1383af8f10 toolkit/themes/gnomestripe/mozapps/extensions/extensions.css
--- a/toolkit/themes/gnomestripe/mozapps/extensions/extensions.css	Sat Nov 01 09:52:29 2008 +0100
+++ b/toolkit/themes/gnomestripe/mozapps/extensions/extensions.css	Mon Nov 03 05:09:10 2008 -0500
@@ -161,16 +161,17 @@ richlistitem[selected="true"]:not([opTyp
   display: none;
 }
 
 richlistitem[availableUpdateURL][updateable="true"] .updateBadge,
 richlistitem[availableUpdateURL][updateable="true"] .updateAvailableBox,
 richlistitem[compatible="false"] .notifyBadge,
 richlistitem[providesUpdatesSecurely="false"] .notifyBadge,
 richlistitem[blocklisted="true"] .notifyBadge,
+richlistitem[blocklistedsoft="true"] .notifyBadge,
 richlistitem[satisfiesDependencies="false"] .notifyBadge {
   display: -moz-box;
 }
 
 /* Selected Add-on buttons
    See content/extensions.css to hide / display buttons */
 .selectedButtons {
   margin-top: 4px;
@@ -193,17 +194,20 @@ richlistitem[satisfiesDependencies="fals
 .uninstallButton, .cancelUninstallButton {
   -moz-margin-start: 5px;
 }
 
 /* Selected Add-on status messages and images */
 richlistitem[compatible="true"] .incompatibleBox,
 richlistitem[providesUpdatesSecurely="true"] .insecureUpdateBox,
 richlistitem[satisfiesDependencies="true"] .needsDependenciesBox,
-richlistitem[blocklisted="false"] .blocklistedBox,
+richlistitem:not([blocklisted="true"]):not([blocklistedsoft="true"]) .blocklistedBox,
+richlistitem[blocklistedsoft="false"]:not([selected="true"]) .blocklistedBox,
+richlistitem[blocklisted="false"] .blocklistedLabel,
+richlistitem[blocklistedsoft="false"] .softBlocklistedLabel,
 richlistitem[opType="needs-uninstall"] .blocklistedBox,
 richlistitem[opType="needs-uninstall"] .incompatibleBox,
 richlistitem[opType="needs-uninstall"] .needsDependenciesBox,
 richlistitem[opType="needs-uninstall"] .blocklistedBox {
   display: none;
 }
 
 richlistitem[loading="true"] .updateBadge {
diff -r 4f1383af8f10 toolkit/themes/pinstripe/mozapps/extensions/blocklist.css
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/themes/pinstripe/mozapps/extensions/blocklist.css	Mon Nov 03 05:09:10 2008 -0500
@@ -0,0 +1,16 @@
+richlistitem {
+  padding-top: 6px;
+  padding-bottom: 6px;
+  -moz-padding-start: 7px;
+  -moz-padding-end: 7px;
+  border-bottom: 1px solid #C0C0C0;
+}
+
+.addon-name-version {
+  font-size: 110%;
+}
+
+.blockedLabel {
+  font-weight: bold;
+  font-style: italic;
+}
diff -r 4f1383af8f10 toolkit/themes/pinstripe/mozapps/extensions/extensions.css
--- a/toolkit/themes/pinstripe/mozapps/extensions/extensions.css	Sat Nov 01 09:52:29 2008 +0100
+++ b/toolkit/themes/pinstripe/mozapps/extensions/extensions.css	Mon Nov 03 05:09:10 2008 -0500
@@ -159,16 +159,17 @@ richlistitem[selected="true"]:not([opTyp
   display: none;
 }
 
 richlistitem[availableUpdateURL][updateable="true"] .updateBadge,
 richlistitem[availableUpdateURL][updateable="true"] .updateAvailableBox,
 richlistitem[compatible="false"] .notifyBadge,
 richlistitem[providesUpdatesSecurely="false"] .notifyBadge,
 richlistitem[blocklisted="true"] .notifyBadge,
+richlistitem[blocklistedsoft="true"] .notifyBadge,
 richlistitem[satisfiesDependencies="false"] .notifyBadge {
   display: -moz-box;
 }
 
 /* Selected Add-on buttons
    See content/extensions.css to hide / display buttons */
 .selectedButtons {
   margin-top: 4px;
@@ -192,25 +193,26 @@ richlistitem[satisfiesDependencies="fals
 .uninstallButton, .cancelUninstallButton {
   -moz-margin-start: 5px;
 }
 
 /* Selected Add-on status messages and images */
 richlistitem[compatible="true"] .incompatibleBox,
 richlistitem[providesUpdatesSecurely="true"] .insecureUpdateBox,
 richlistitem[satisfiesDependencies="true"] .needsDependenciesBox,
-richlistitem[blocklisted="false"] .blocklistedBox,
+richlistitem:not([blocklisted="true"]):not([blocklistedsoft="true"]) .blocklistedBox,
+richlistitem[blocklistedsoft="false"]:not([selected="true"]) .blocklistedBox,
+richlistitem[blocklisted="false"] .blocklistedLabel,
+richlistitem[blocklistedsoft="false"] .softBlocklistedLabel,
 richlistitem[opType="needs-uninstall"] .blocklistedBox,
 richlistitem[opType="needs-uninstall"] .incompatibleBox,
 richlistitem[opType="needs-uninstall"] .needsDependenciesBox,
 richlistitem[opType="needs-uninstall"] .blocklistedBox {
   display: none;
 }
-
-
 
 richlistitem[loading="true"] .updateBadge {
   display: -moz-box;
   width: 16px;
   height: 16px;
   margin-bottom: -3px;
   -moz-margin-end: -2px;
   list-style-image: url("chrome://global/skin/icons/loading_16.png");
diff -r 4f1383af8f10 toolkit/themes/pinstripe/mozapps/jar.mn
--- a/toolkit/themes/pinstripe/mozapps/jar.mn	Sat Nov 01 09:52:29 2008 +0100
+++ b/toolkit/themes/pinstripe/mozapps/jar.mn	Mon Nov 03 05:09:10 2008 -0500
@@ -13,16 +13,17 @@ classic.jar:
   skin/classic/mozapps/extensions/viewButtons.png                 (extensions/viewButtons.png)
   skin/classic/mozapps/extensions/ratings.png                     (extensions/ratings.png)
   skin/classic/mozapps/extensions/extensionIcons.png              (extensions/extensionIcons.png)
   skin/classic/mozapps/extensions/about.css                       (extensions/about.css)
   skin/classic/mozapps/extensions/extensions.css                  (extensions/extensions.css)
   skin/classic/mozapps/extensions/extensions.xml                  (extensions/extensions.xml)
   skin/classic/mozapps/extensions/update.css                      (extensions/update.css)
   skin/classic/mozapps/extensions/eula.css                        (extensions/eula.css)
+  skin/classic/mozapps/extensions/blocklist.css                   (extensions/blocklist.css)
   skin/classic/mozapps/passwordmgr/key.png                        (passwordmgr/key.png)
   skin/classic/mozapps/plugins/missingPlugin.css                  (plugins/missingPlugin.css)
   skin/classic/mozapps/plugins/pluginGeneric.png                  (plugins/pluginGeneric.png)
   skin/classic/mozapps/plugins/pluginDisabled.png                 (plugins/pluginDisabled.png)
   skin/classic/mozapps/plugins/pluginBlocked.png                  (plugins/pluginBlocked.png)
   skin/classic/mozapps/plugins/pluginGeneric-16.png               (plugins/pluginGeneric-16.png)
   skin/classic/mozapps/plugins/pluginBlocked-16.png               (plugins/pluginBlocked-16.png)
   skin/classic/mozapps/profile/profileicon.png                    (profile/profileicon.png)
diff -r 4f1383af8f10 toolkit/themes/winstripe/mozapps/extensions/blocklist.css
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/themes/winstripe/mozapps/extensions/blocklist.css	Mon Nov 03 05:09:10 2008 -0500
@@ -0,0 +1,16 @@
+richlistitem {
+  padding-top: 6px;
+  padding-bottom: 6px;
+  -moz-padding-start: 7px;
+  -moz-padding-end: 7px;
+  border-bottom: 1px solid #C0C0C0;
+}
+
+.addonName {
+  font-weight: bold;
+}
+
+.blockedLabel {
+  font-weight: bold;
+  font-style: italic;
+}
diff -r 4f1383af8f10 toolkit/themes/winstripe/mozapps/extensions/extensions.css
--- a/toolkit/themes/winstripe/mozapps/extensions/extensions.css	Sat Nov 01 09:52:29 2008 +0100
+++ b/toolkit/themes/winstripe/mozapps/extensions/extensions.css	Mon Nov 03 05:09:10 2008 -0500
@@ -152,16 +152,17 @@ richlistitem[selected="true"]:not([opTyp
   display: none;
 }
 
 richlistitem[availableUpdateURL][updateable="true"] .updateBadge,
 richlistitem[availableUpdateURL][updateable="true"] .updateAvailableBox,
 richlistitem[compatible="false"] .notifyBadge,
 richlistitem[providesUpdatesSecurely="false"] .notifyBadge,
 richlistitem[blocklisted="true"] .notifyBadge,
+richlistitem[blocklistedsoft="true"] .notifyBadge,
 richlistitem[satisfiesDependencies="false"] .notifyBadge {
   display: -moz-box;
 }
 
 /* Selected Add-on buttons
    See content/extensions.css to hide / display buttons */
 .selectedButtons {
   margin-top: 4px;
@@ -184,17 +185,20 @@ richlistitem[satisfiesDependencies="fals
 .uninstallButton, .cancelUninstallButton {
   -moz-margin-start: 5px;
 }
 
 /* Selected Add-on status messages and images */
 richlistitem[compatible="true"] .incompatibleBox,
 richlistitem[providesUpdatesSecurely="true"] .insecureUpdateBox,
 richlistitem[satisfiesDependencies="true"] .needsDependenciesBox,
-richlistitem[blocklisted="false"] .blocklistedBox,
+richlistitem:not([blocklisted="true"]):not([blocklistedsoft="true"]) .blocklistedBox,
+richlistitem[blocklistedsoft="false"]:not([selected="true"]) .blocklistedBox,
+richlistitem[blocklisted="false"] .blocklistedLabel,
+richlistitem[blocklistedsoft="false"] .softBlocklistedLabel,
 richlistitem[opType="needs-uninstall"] .blocklistedBox,
 richlistitem[opType="needs-uninstall"] .incompatibleBox,
 richlistitem[opType="needs-uninstall"] .needsDependenciesBox,
 richlistitem[opType="needs-uninstall"] .blocklistedBox {
   display: none;
 }
 
 richlistitem[loading="true"] .updateBadge {
diff -r 4f1383af8f10 toolkit/themes/winstripe/mozapps/jar.mn
--- a/toolkit/themes/winstripe/mozapps/jar.mn	Sat Nov 01 09:52:29 2008 +0100
+++ b/toolkit/themes/winstripe/mozapps/jar.mn	Mon Nov 03 05:09:10 2008 -0500
@@ -3,16 +3,17 @@ classic.jar:
 % skin mozapps classic/1.0 %skin/classic/mozapps/ os!=WINNT
 # NOTE: If you add a new file here, you'll need to add it to the aero
 # section at the bottom of this file
         skin/classic/mozapps/downloads/downloadButtons.png         (downloads/downloadButtons.png)
         skin/classic/mozapps/downloads/downloadIcon.png            (downloads/downloadIcon.png)
         skin/classic/mozapps/downloads/downloads.css               (downloads/downloads.css)
         skin/classic/mozapps/downloads/unknownContentType.css      (downloads/unknownContentType.css)
         skin/classic/mozapps/extensions/about.css                  (extensions/about.css)
+        skin/classic/mozapps/extensions/blocklist.css              (extensions/blocklist.css)
         skin/classic/mozapps/extensions/extensions.css             (extensions/extensions.css)
         skin/classic/mozapps/extensions/itemDisabledFader.png      (extensions/itemDisabledFader.png)
         skin/classic/mozapps/extensions/itemEnabledFader.png       (extensions/itemEnabledFader.png)
         skin/classic/mozapps/extensions/notifyBadges.png           (extensions/notifyBadges.png)
         skin/classic/mozapps/extensions/update.css                 (extensions/update.css)
         skin/classic/mozapps/extensions/themeGeneric.png           (extensions/themeGeneric.png)
         skin/classic/mozapps/extensions/viewButtons.png            (extensions/viewButtons.png)
         skin/classic/mozapps/extensions/ratings.png                (extensions/ratings.png)
diff -r 4f1383af8f10 view/public/nsIScrollableView.h
--- a/view/public/nsIScrollableView.h	Sat Nov 01 09:52:29 2008 +0100
+++ b/view/public/nsIScrollableView.h	Mon Nov 03 05:09:10 2008 -0500
@@ -41,18 +41,18 @@
 #include "nsCoord.h"
 
 class nsIView;
 class nsIScrollPositionListener;
 struct nsSize;
 
 // IID for the nsIScrollableView interface
 #define NS_ISCROLLABLEVIEW_IID    \
-{ 0x1fcd151c, 0x5e26, 0x4c9d, \
-{ 0xa5, 0x2c, 0x87, 0x43, 0x7d, 0x7b, 0x1c, 0xe8 } }
+{ 0x00bba69f, 0xbbef, 0x4725, \
+{ 0x8b, 0xee, 0xec, 0xfe, 0x82, 0xf7, 0xbd, 0xb0 } }
 
 /**
  * A scrolling view allows an arbitrary view that you supply to be scrolled
  * vertically or horizontally (or both). The scrolling view creates and
  * manages the scrollbars.
  *
  * You must use SetScrolledView() to specify the view that is to be scrolled,
  * because the scrolled view is made a child of the clip view (an internal
@@ -95,17 +95,17 @@ public:
   NS_IMETHOD  GetScrollPosition(nscoord &aX, nscoord& aY) const = 0;
 
   /**
    * Scroll the view to the given x,y, update's the scrollbar's thumb
    * positions and the view's offset. Clamps the values to be
    * legal. Updates the display based on aUpdateFlags.
    * @param aX left edge to scroll to
    * @param aY top edge to scroll to
-   * @param aUpdateFlags passed onto nsIViewManager->UpdateView()
+   * @param aUpdateFlags indicate smooth or async scrolling
    * @return error status
    */
   NS_IMETHOD ScrollTo(nscoord aX, nscoord aY, PRUint32 aUpdateFlags) = 0;
 
   /**
    * Set the properties describing how scrolling can be performed
    * in this scrollable.
    * @param aProperties new properties
@@ -137,55 +137,62 @@ public:
   NS_IMETHOD GetLineHeight(nscoord *aHeight) = 0;
 
   /**
    * Scroll the view left or right by aNumLinesX columns. Positive values move right. 
    * Scroll the view up or down by aNumLinesY lines. Positive values move down. 
    * Prevents scrolling off the end of the view.
    * @param aNumLinesX number of lines to scroll the view horizontally
    * @param aNumLinesY number of lines to scroll the view vertically
+   * @param aUpdateFlags indicate smooth or async scrolling
    * @return error status
    */
-  NS_IMETHOD ScrollByLines(PRInt32 aNumLinesX, PRInt32 aNumLinexY) = 0;
+  NS_IMETHOD ScrollByLines(PRInt32 aNumLinesX, PRInt32 aNumLinexY,
+                           PRUint32 aUpdateFlags = 0) = 0;
 
   /**
    * Get the desired size of a page scroll in each dimension.
    * ScrollByPages will scroll by independent multiples of these amounts
    * unless it hits the edge of the view.
    */
   NS_IMETHOD GetPageScrollDistances(nsSize *aDistances) = 0;
 
   /**
    * Scroll the view left or right by aNumPagesX pages. Positive values move right. 
    * Scroll the view up or down by aNumPagesY pages. Positive values move down. 
    * A page is considered to be the amount displayed by the clip view.
    * Prevents scrolling off the end of the view.
    * @param aNumPagesX number of pages to scroll the view horizontally
    * @param aNumPagesY number of pages to scroll the view vertically
+   * @param aUpdateFlags indicate smooth or async scrolling
    * @return error status
    */
-  NS_IMETHOD ScrollByPages(PRInt32 aNumPagesX, PRInt32 aNumPagesY) = 0;
+  NS_IMETHOD ScrollByPages(PRInt32 aNumPagesX, PRInt32 aNumPagesY,
+                           PRUint32 aUpdateFlags = 0) = 0;
 
   /**
    * Scroll the view to the top or bottom of the document depending
    * on the value of aTop.
    * @param aForward indicates whether to scroll to top or bottom
+   * @param aUpdateFlags indicate smooth or async scrolling
    * @return error status
    */
-  NS_IMETHOD ScrollByWhole(PRBool aTop) = 0;
+  NS_IMETHOD ScrollByWhole(PRBool aTop, PRUint32 aUpdateFlags = 0) = 0;
 
   /**
    * Scroll the view left or right by aNumLinesX pixels.  Positive values move 
    * right.  Scroll the view up or down by aNumLinesY pixels.  Positive values
    * move down.  Prevents scrolling off the end of the view.
    * @param aNumLinesX number of lines to scroll the view horizontally
    * @param aNumLinesY number of lines to scroll the view vertically
+   * @param aUpdateFlags indicate smooth or async scrolling
    * @return error status
    */
-  NS_IMETHOD ScrollByPixels(PRInt32 aNumPixelsX, PRInt32 aNumPixelsY) = 0;
+  NS_IMETHOD ScrollByPixels(PRInt32 aNumPixelsX, PRInt32 aNumPixelsY,
+                            PRUint32 aUpdateFlags = 0) = 0;
 
   /**
    * Check the view can scroll from current offset.
    * @param aHorizontal If checking to Left or to Right, true. Otherwise, false.
    * @param aForward    If checking to Right or Bottom, true. Otherwise, false.
    * @param aResult     If the view can scroll, true. Otherwise, false.
    * @return            error status
    */
diff -r 4f1383af8f10 view/src/nsScrollPortView.cpp
--- a/view/src/nsScrollPortView.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/view/src/nsScrollPortView.cpp	Mon Nov 03 05:09:10 2008 -0500
@@ -57,40 +57,40 @@
 
 static NS_DEFINE_IID(kWidgetCID, NS_CHILD_CID);
 
 #define SMOOTH_SCROLL_MSECS_PER_FRAME 10
 #define SMOOTH_SCROLL_FRAMES    10
 
 #define SMOOTH_SCROLL_PREF_NAME "general.smoothScroll"
 
-class SmoothScroll {
+class AsyncScroll {
 public:
-  SmoothScroll() {}
-  ~SmoothScroll() {
-    if (mScrollAnimationTimer) mScrollAnimationTimer->Cancel();
+  AsyncScroll() {}
+  ~AsyncScroll() {
+    if (mScrollTimer) mScrollTimer->Cancel();
   }
 
-  nsCOMPtr<nsITimer> mScrollAnimationTimer;
+  nsCOMPtr<nsITimer> mScrollTimer;
   PRInt32 mVelocities[SMOOTH_SCROLL_FRAMES*2];
   PRInt32 mFrameIndex;
-  nscoord mDestinationX;
-  nscoord mDestinationY;
+  PRPackedBool mIsSmoothScroll;
 };
 
 nsScrollPortView::nsScrollPortView(nsViewManager* aViewManager)
   : nsView(aViewManager)
 {
   mOffsetX = mOffsetY = 0;
+  mDestinationX = mDestinationY = 0;
   nsCOMPtr<nsIDeviceContext> dev;
   mViewManager->GetDeviceContext(*getter_AddRefs(dev));
   mLineHeight = dev->AppUnitsPerInch() / 6; // 12 pt
 
   mListeners = nsnull;
-  mSmoothScroll = nsnull;
+  mAsyncScroll = nsnull;
 }
 
 nsScrollPortView::~nsScrollPortView()
 {    
   if (nsnull != mListeners) {
     mListeners->Clear();
     NS_RELEASE(mListeners);
   }
@@ -98,17 +98,17 @@ nsScrollPortView::~nsScrollPortView()
   if (nsnull != mViewManager) {
      nsIScrollableView* scrollingView;
      mViewManager->GetRootScrollableView(&scrollingView);
      if ((nsnull != scrollingView) && (this == scrollingView)) {
        mViewManager->SetRootScrollableView(nsnull);
      }
   }
 
-  delete mSmoothScroll;
+  delete mAsyncScroll;
 }
 
 nsresult nsScrollPortView::QueryInterface(const nsIID& aIID, void** aInstancePtr)
 {
   if (nsnull == aInstancePtr) {
     return NS_ERROR_NULL_POINTER;
   }
   *aInstancePtr = nsnull;
@@ -239,83 +239,82 @@ static nsresult ClampScrollValues(nscoor
 /*
  * this method wraps calls to ScrollToImpl(), either in one shot or incrementally,
  *  based on the setting of the smooth scroll pref
  */
 NS_IMETHODIMP nsScrollPortView::ScrollTo(nscoord aDestinationX, nscoord aDestinationY,
                                          PRUint32 aUpdateFlags)
 {
   // do nothing if the we aren't scrolling.
-  if (aDestinationX == mOffsetX && aDestinationY == mOffsetY) {
+  if (aDestinationX == mDestinationX && aDestinationY == mDestinationY) {
     // kill any in-progress smooth scroll
-    delete mSmoothScroll;
-    mSmoothScroll = nsnull;
+    delete mAsyncScroll;
+    mAsyncScroll = nsnull;
     return NS_OK;
   }
-  
-  if ((aUpdateFlags & NS_VMREFRESH_SMOOTHSCROLL) == 0
-      || !IsSmoothScrollingEnabled()) {
-    // Smooth scrolling is not allowed, so we'll kill any existing smooth-scrolling process
-    // and do an instant scroll
-    delete mSmoothScroll;
-    mSmoothScroll = nsnull;
-    return ScrollToImpl(aDestinationX, aDestinationY, aUpdateFlags);
+
+  mDestinationX = aDestinationX;
+  mDestinationY = aDestinationY;
+  ClampScrollValues(mDestinationX, mDestinationY, this);
+
+  if (!(aUpdateFlags & NS_VMREFRESH_DEFERRED)) {
+    // Asynchronous scrolling is not allowed, so we'll kill any existing
+    // async-scrolling process and do an instant scroll
+    delete mAsyncScroll;
+    mAsyncScroll = nsnull;
+    return ScrollToImpl(mDestinationX, mDestinationY);
   }
 
-  PRInt32 currentVelocityX;
-  PRInt32 currentVelocityY;
+  PRInt32 currentVelocityX = 0;
+  PRInt32 currentVelocityY = 0;
+  PRBool isSmoothScroll = (aUpdateFlags & NS_VMREFRESH_SMOOTHSCROLL) &&
+                          IsSmoothScrollingEnabled();
 
-  if (mSmoothScroll) {
-    currentVelocityX = mSmoothScroll->mVelocities[mSmoothScroll->mFrameIndex*2];
-    currentVelocityY = mSmoothScroll->mVelocities[mSmoothScroll->mFrameIndex*2 + 1];
+  if (mAsyncScroll) {
+    if (mAsyncScroll->mIsSmoothScroll) {
+      currentVelocityX = mAsyncScroll->mVelocities[mAsyncScroll->mFrameIndex*2];
+      currentVelocityY = mAsyncScroll->mVelocities[mAsyncScroll->mFrameIndex*2 + 1];
+    }
   } else {
-    currentVelocityX = 0;
-    currentVelocityY = 0;
-
-    mSmoothScroll = new SmoothScroll;
-    if (mSmoothScroll) {
-      mSmoothScroll->mScrollAnimationTimer = do_CreateInstance("@mozilla.org/timer;1");
-      if (!mSmoothScroll->mScrollAnimationTimer) {
-        delete mSmoothScroll;
-        mSmoothScroll = nsnull;
+    mAsyncScroll = new AsyncScroll;
+    if (mAsyncScroll) {
+      mAsyncScroll->mScrollTimer = do_CreateInstance("@mozilla.org/timer;1");
+      if (!mAsyncScroll->mScrollTimer) {
+        delete mAsyncScroll;
+        mAsyncScroll = nsnull;
       }
     }
-    if (!mSmoothScroll) {
+    if (!mAsyncScroll) {
       // some allocation failed. Scroll the normal way.
-      return ScrollToImpl(aDestinationX, aDestinationY, aUpdateFlags);
+      return ScrollToImpl(mDestinationX, mDestinationY);
     }
-    mSmoothScroll->mScrollAnimationTimer->InitWithFuncCallback(
-      SmoothScrollAnimationCallback, this, SMOOTH_SCROLL_MSECS_PER_FRAME,
-      nsITimer::TYPE_REPEATING_PRECISE);
-    mSmoothScroll->mDestinationX = mOffsetX;
-    mSmoothScroll->mDestinationY = mOffsetY;
+    if (isSmoothScroll) {
+      mAsyncScroll->mScrollTimer->InitWithFuncCallback(
+        AsyncScrollCallback, this, SMOOTH_SCROLL_MSECS_PER_FRAME,
+        nsITimer::TYPE_REPEATING_PRECISE);
+    } else {
+      mAsyncScroll->mScrollTimer->InitWithFuncCallback(
+        AsyncScrollCallback, this, 0, nsITimer::TYPE_ONE_SHOT);
+    }
   }
 
-  // need to store these so we know when to stop scrolling
-  // Treat the desired scroll destination as an offset
-  // relative to the current position. This makes things
-  // work when someone starts a smooth scroll
-  // while an existing smooth scroll has not yet been
-  // completed.
-  mSmoothScroll->mDestinationX += aDestinationX - mOffsetX;
-  mSmoothScroll->mDestinationY += aDestinationY - mOffsetY;
-  mSmoothScroll->mFrameIndex = 0;
-  ClampScrollValues(mSmoothScroll->mDestinationX, mSmoothScroll->mDestinationY, this);
+  mAsyncScroll->mFrameIndex = 0;
+  mAsyncScroll->mIsSmoothScroll = isSmoothScroll;
 
-  nsCOMPtr<nsIDeviceContext> dev;
-  mViewManager->GetDeviceContext(*getter_AddRefs(dev));
-  PRInt32 p2a = dev->AppUnitsPerDevPixel();
+  if (isSmoothScroll) {
+    nsCOMPtr<nsIDeviceContext> dev;
+    mViewManager->GetDeviceContext(*getter_AddRefs(dev));
+    PRInt32 p2a = dev->AppUnitsPerDevPixel();
 
-  // compute velocity vectors
-  ComputeVelocities(currentVelocityX, mOffsetX,
-                    mSmoothScroll->mDestinationX, mSmoothScroll->mVelocities,
-                    p2a);
-  ComputeVelocities(currentVelocityY, mOffsetY,
-                    mSmoothScroll->mDestinationY, mSmoothScroll->mVelocities + 1,
-                    p2a);
+    // compute velocity vectors
+    ComputeVelocities(currentVelocityX, mOffsetX, mDestinationX,
+                      mAsyncScroll->mVelocities, p2a);
+    ComputeVelocities(currentVelocityY, mOffsetY, mDestinationY,
+                      mAsyncScroll->mVelocities + 1, p2a);
+  }
 
   return NS_OK;
 }
 
 static void AdjustChildWidgets(nsView *aView,
   nsPoint aWidgetToParentViewOrigin, PRInt32 aP2A, PRBool aInvalidate)
 {
   if (aView->HasWidget()) {
@@ -400,77 +399,81 @@ NS_IMETHODIMP nsScrollPortView::SetLineH
 }
 
 NS_IMETHODIMP nsScrollPortView::GetLineHeight(nscoord *aHeight)
 {
   *aHeight = mLineHeight;
   return NS_OK;
 }
 
-NS_IMETHODIMP nsScrollPortView::ScrollByLines(PRInt32 aNumLinesX, PRInt32 aNumLinesY)
+NS_IMETHODIMP nsScrollPortView::ScrollByLines(PRInt32 aNumLinesX, PRInt32 aNumLinesY,
+                                              PRUint32 aUpdateFlags)
 {
   nscoord dx = mLineHeight*aNumLinesX;
   nscoord dy = mLineHeight*aNumLinesY;
 
-  return ScrollTo(mOffsetX + dx, mOffsetY + dy, NS_VMREFRESH_SMOOTHSCROLL);
+  return ScrollTo(mDestinationX + dx, mDestinationY + dy, aUpdateFlags);
 }
 
 NS_IMETHODIMP nsScrollPortView::GetPageScrollDistances(nsSize *aDistances)
 {
   nsSize size;
   GetDimensions(size);
 
   // The page increment is the size of the page, minus the smaller of
   // 10% of the size or 2 lines.
   aDistances->width  = size.width  - PR_MIN(size.width  / 10, 2 * mLineHeight);
   aDistances->height = size.height - PR_MIN(size.height / 10, 2 * mLineHeight);
 
   return NS_OK;
 }
 
-NS_IMETHODIMP nsScrollPortView::ScrollByPages(PRInt32 aNumPagesX, PRInt32 aNumPagesY)
+NS_IMETHODIMP nsScrollPortView::ScrollByPages(PRInt32 aNumPagesX, PRInt32 aNumPagesY,
+                                              PRUint32 aUpdateFlags)
 {
   nsSize delta;
   GetPageScrollDistances(&delta);
     
   // put in the number of pages.
   delta.width *= aNumPagesX;
   delta.height *= aNumPagesY;
 
-  return ScrollTo(mOffsetX + delta.width, mOffsetY + delta.height,
-                  NS_VMREFRESH_SMOOTHSCROLL);
+  return ScrollTo(mDestinationX + delta.width, mDestinationY + delta.height,
+                  aUpdateFlags);
 }
 
-NS_IMETHODIMP nsScrollPortView::ScrollByWhole(PRBool aTop)
+NS_IMETHODIMP nsScrollPortView::ScrollByWhole(PRBool aTop,
+                                              PRUint32 aUpdateFlags)
 {
   nscoord   newPos = 0;
 
   if (!aTop) {
     nsSize scrolledSize;
     nsView* scrolledView = GetScrolledView();
     scrolledView->GetDimensions(scrolledSize);
     newPos = scrolledSize.height;
   }
 
-  ScrollTo(mOffsetX, newPos, 0);
+  ScrollTo(mDestinationX, newPos, aUpdateFlags);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP nsScrollPortView::ScrollByPixels(PRInt32 aNumPixelsX,
-                                               PRInt32 aNumPixelsY)
+                                               PRInt32 aNumPixelsY,
+                                               PRUint32 aUpdateFlags)
 {
   nsCOMPtr<nsIDeviceContext> dev;
   mViewManager->GetDeviceContext(*getter_AddRefs(dev));
   PRInt32 p2a = dev->AppUnitsPerDevPixel(); 
 
   nscoord dx = NSIntPixelsToAppUnits(aNumPixelsX, p2a);
   nscoord dy = NSIntPixelsToAppUnits(aNumPixelsY, p2a);
 
-  return ScrollTo(mOffsetX + dx, mOffsetY + dy, 0);
+  return ScrollTo(mDestinationX + dx, mDestinationY + dy, aUpdateFlags);
 }
 
 NS_IMETHODIMP nsScrollPortView::CanScroll(PRBool aHorizontal,
                                           PRBool aForward,
                                           PRBool &aResult)
 {
   nscoord offset = aHorizontal ? mOffsetX : mOffsetY;
 
@@ -593,17 +596,17 @@ void nsScrollPortView::Scroll(nsView *aS
       // Scroll the contents of the widget by the specified amount, and scroll
       // the child widgets
       scrollWidget->Scroll(aPixDelta.x, aPixDelta.y, toScrollPtr);
       mViewManager->UpdateViewAfterScroll(this, updateRegion);
     }
   }
 }
 
-NS_IMETHODIMP nsScrollPortView::ScrollToImpl(nscoord aX, nscoord aY, PRUint32 aUpdateFlags)
+NS_IMETHODIMP nsScrollPortView::ScrollToImpl(nscoord aX, nscoord aY)
 {
   PRInt32           dxPx = 0, dyPx = 0;
 
   // convert to pixels
   nsCOMPtr<nsIDeviceContext> dev;
   mViewManager->GetDeviceContext(*getter_AddRefs(dev));
   PRInt32 p2a = dev->AppUnitsPerDevPixel();
 
@@ -685,60 +688,54 @@ NS_IMETHODIMP nsScrollPortView::ScrollTo
         }
       }
     }
   }
  
   return NS_OK;
 }
 
-/************************
- *
- * smooth scrolling methods
- *
- ***********************/
-
 PRBool nsScrollPortView::IsSmoothScrollingEnabled() {
   nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
   if (prefs) {
     PRBool enabled;
     nsresult rv = prefs->GetBoolPref(SMOOTH_SCROLL_PREF_NAME, &enabled);
     if (NS_SUCCEEDED(rv)) {
       return enabled;
     }
   }
   return PR_FALSE;
 }
 
 /*
- * Callback function from timer used in nsScrollPortView::DoSmoothScroll
- * this cleans up the target coordinates and incrementally calls 
- * nsScrollPortView::ScrollTo
+ * Callback function from timer used in nsScrollPortView::ScrollTo
  */
 void
-nsScrollPortView::SmoothScrollAnimationCallback (nsITimer *aTimer, void* anInstance) 
+nsScrollPortView::AsyncScrollCallback(nsITimer *aTimer, void* anInstance) 
 {
   nsScrollPortView* self = static_cast<nsScrollPortView*>(anInstance);
   if (self) {
     self->IncrementalScroll();
   }
 }
 
 /*
- * manages data members and calls to ScrollTo from the (static) SmoothScrollAnimationCallback method
+ * manages data members and calls to ScrollTo from the (static) AsyncScrollCallback method
  */ 
 void
 nsScrollPortView::IncrementalScroll()
 {
-  if (!mSmoothScroll) {
+  if (!mAsyncScroll)
     return;
+
+  if (mAsyncScroll->mIsSmoothScroll) {
+    if (mAsyncScroll->mFrameIndex < SMOOTH_SCROLL_FRAMES) {
+      ScrollToImpl(mOffsetX + mAsyncScroll->mVelocities[mAsyncScroll->mFrameIndex*2],
+                   mOffsetY + mAsyncScroll->mVelocities[mAsyncScroll->mFrameIndex*2 + 1]);
+      mAsyncScroll->mFrameIndex++;
+      return;
+    }
+  } else {
+    ScrollToImpl(mDestinationX, mDestinationY);
   }
-
-  if (mSmoothScroll->mFrameIndex < SMOOTH_SCROLL_FRAMES) {
-    ScrollToImpl(mOffsetX + mSmoothScroll->mVelocities[mSmoothScroll->mFrameIndex*2],
-                 mOffsetY + mSmoothScroll->mVelocities[mSmoothScroll->mFrameIndex*2 + 1],
-                 0);
-    mSmoothScroll->mFrameIndex++;
-  } else {
-    delete mSmoothScroll;
-    mSmoothScroll = nsnull;
-  }
+  delete mAsyncScroll;
+  mAsyncScroll = nsnull;
 }
diff -r 4f1383af8f10 view/src/nsScrollPortView.h
--- a/view/src/nsScrollPortView.h	Sat Nov 01 09:52:29 2008 +0100
+++ b/view/src/nsScrollPortView.h	Mon Nov 03 05:09:10 2008 -0500
@@ -39,17 +39,17 @@
 #define nsScrollPortView_h___
 
 #include "nsView.h"
 #include "nsIScrollableView.h"
 #include "nsCOMPtr.h"
 #include "nsITimer.h"
 
 class nsISupportsArray;
-class SmoothScroll;
+class AsyncScroll;
 
 //this is a class that acts as a container for other views and provides
 //automatic management of scrolling of the views it contains.
 
 class nsScrollPortView : public nsView, public nsIScrollableView
 {
 public:
   nsScrollPortView(nsViewManager* aViewManager = nsnull);
@@ -66,49 +66,53 @@ public:
   NS_IMETHOD  GetScrolledView(nsIView *&aScrolledView) const;
 
   NS_IMETHOD  GetScrollPosition(nscoord &aX, nscoord &aY) const;
   NS_IMETHOD  ScrollTo(nscoord aX, nscoord aY, PRUint32 aUpdateFlags);
   NS_IMETHOD  SetScrollProperties(PRUint32 aProperties);
   NS_IMETHOD  GetScrollProperties(PRUint32 *aProperties);
   NS_IMETHOD  SetLineHeight(nscoord aHeight);
   NS_IMETHOD  GetLineHeight(nscoord *aHeight);
-  NS_IMETHOD  ScrollByLines(PRInt32 aNumLinesX, PRInt32 aNumLinesY);
+  NS_IMETHOD  ScrollByLines(PRInt32 aNumLinesX, PRInt32 aNumLinesY,
+                            PRUint32 aUpdateFlags = 0);
   NS_IMETHOD  GetPageScrollDistances(nsSize *aDistances);
-  NS_IMETHOD  ScrollByPages(PRInt32 aNumPagesX, PRInt32 aNumPagesY);
-  NS_IMETHOD  ScrollByWhole(PRBool aTop);
-  NS_IMETHOD  ScrollByPixels(PRInt32 aNumPixelsX, PRInt32 aNumPixelsY);
+  NS_IMETHOD  ScrollByPages(PRInt32 aNumPagesX, PRInt32 aNumPagesY,
+                            PRUint32 aUpdateFlags = 0);
+  NS_IMETHOD  ScrollByWhole(PRBool aTop, PRUint32 aUpdateFlags = 0);
+  NS_IMETHOD  ScrollByPixels(PRInt32 aNumPixelsX, PRInt32 aNumPixelsY,
+                             PRUint32 aUpdateFlags = 0);
   NS_IMETHOD  CanScroll(PRBool aHorizontal, PRBool aForward, PRBool &aResult);
 
   NS_IMETHOD_(nsIView*) View();
 
   NS_IMETHOD  AddScrollPositionListener(nsIScrollPositionListener* aListener);
   NS_IMETHOD  RemoveScrollPositionListener(nsIScrollPositionListener* aListener);
 
   // local to the view module
 
   nsView*     GetScrolledView() const { return GetFirstChild(); }
 
 private:
-  NS_IMETHOD  ScrollToImpl(nscoord aX, nscoord aY, PRUint32 aUpdateFlags);
+  NS_IMETHOD  ScrollToImpl(nscoord aX, nscoord aY);
 
   // data members
-  SmoothScroll* mSmoothScroll;
+  AsyncScroll* mAsyncScroll;
 
   // methods
   void        IncrementalScroll();
   PRBool      IsSmoothScrollingEnabled();
-  static void SmoothScrollAnimationCallback(nsITimer *aTimer, void* aESM);
+  static void AsyncScrollCallback(nsITimer *aTimer, void* aSPV);
 
 protected:
   virtual ~nsScrollPortView();
 
   //private
   void Scroll(nsView *aScrolledView, nsPoint aTwipsDelta, nsPoint aPixDelta, PRInt32 p2a);
   PRBool CannotBitBlt(nsView* aScrolledView);
 
   nscoord             mOffsetX, mOffsetY;
+  nscoord             mDestinationX, mDestinationY;
   PRUint32            mScrollProperties;
   nscoord             mLineHeight;
   nsISupportsArray   *mListeners;
 };
 
 #endif
diff -r 4f1383af8f10 widget/src/cocoa/nsNativeThemeCocoa.mm
--- a/widget/src/cocoa/nsNativeThemeCocoa.mm	Sat Nov 01 09:52:29 2008 +0100
+++ b/widget/src/cocoa/nsNativeThemeCocoa.mm	Mon Nov 03 05:09:10 2008 -0500
@@ -1329,21 +1329,18 @@ nsNativeThemeCocoa::DrawWidgetBackground
       break;
 
     case NS_THEME_TOOLTIP:
       CGContextSetRGBFillColor(cgContext, 1.0, 1.0, 0.78, 1.0);
       CGContextFillRect(cgContext, macRect);
       break;
 
     case NS_THEME_CHECKBOX:
-    case NS_THEME_CHECKBOX_SMALL:
-    case NS_THEME_RADIO:
-    case NS_THEME_RADIO_SMALL: {
-      PRBool isCheckbox = (aWidgetType == NS_THEME_CHECKBOX ||
-                           aWidgetType == NS_THEME_CHECKBOX_SMALL);
+    case NS_THEME_RADIO: {
+      PRBool isCheckbox = (aWidgetType == NS_THEME_CHECKBOX);
       DrawCheckboxOrRadio(cgContext, isCheckbox, macRect, GetCheckedOrSelected(aFrame, !isCheckbox),
                           IsDisabled(aFrame), eventState, aFrame);
     }
       break;
 
     case NS_THEME_BUTTON:
       DrawPushButton(cgContext, macRect, IsDefaultButton(aFrame), IsDisabled(aFrame), eventState, aFrame);
       break;
@@ -1701,19 +1698,17 @@ nsNativeThemeCocoa::GetWidgetPadding(nsI
   // We don't want CSS padding being used for certain widgets.
   // See bug 381639 for an example of why.
   switch (aWidgetType) {
     case NS_THEME_BUTTON:
     // Radios and checkboxes return a fixed size in GetMinimumWidgetSize
     // and have a meaningful baseline, so they can't have
     // author-specified padding.
     case NS_THEME_CHECKBOX:
-    case NS_THEME_CHECKBOX_SMALL:
     case NS_THEME_RADIO:
-    case NS_THEME_RADIO_SMALL:
       aResult->SizeTo(0, 0, 0, 0);
       return PR_TRUE;
   }
   return PR_FALSE;
 }
 
 
 PRBool
@@ -1723,19 +1718,17 @@ nsNativeThemeCocoa::GetWidgetOverflow(ns
   switch (aWidgetType) {
     case NS_THEME_BUTTON:
     case NS_THEME_TEXTFIELD:
     case NS_THEME_TEXTFIELD_MULTILINE:
     case NS_THEME_LISTBOX:
     case NS_THEME_DROPDOWN:
     case NS_THEME_DROPDOWN_BUTTON:
     case NS_THEME_CHECKBOX:
-    case NS_THEME_CHECKBOX_SMALL:
     case NS_THEME_RADIO:
-    case NS_THEME_RADIO_SMALL:
     {
       // We assume that the above widgets can draw a focus ring that will be less than
       // or equal to 4 pixels thick.
       nsIntMargin extraSize = nsIntMargin(MAX_FOCUS_RING_WIDTH, MAX_FOCUS_RING_WIDTH, MAX_FOCUS_RING_WIDTH, MAX_FOCUS_RING_WIDTH);
       PRInt32 p2a = aContext->AppUnitsPerDevPixel();
       nsMargin m(NSIntPixelsToAppUnits(extraSize.left, p2a),
                  NSIntPixelsToAppUnits(extraSize.top, p2a),
                  NSIntPixelsToAppUnits(extraSize.right, p2a),
@@ -2034,20 +2027,18 @@ nsNativeThemeCocoa::ThemeSupportsWidget(
     case NS_THEME_DIALOG:
     case NS_THEME_WINDOW:
     case NS_THEME_MENUPOPUP:
     case NS_THEME_MENUITEM:
     case NS_THEME_MENUSEPARATOR:
     case NS_THEME_TOOLTIP:
     
     case NS_THEME_CHECKBOX:
-    case NS_THEME_CHECKBOX_SMALL:
     case NS_THEME_CHECKBOX_CONTAINER:
     case NS_THEME_RADIO:
-    case NS_THEME_RADIO_SMALL:
     case NS_THEME_RADIO_CONTAINER:
     case NS_THEME_GROUPBOX:
     case NS_THEME_BUTTON:
     case NS_THEME_BUTTON_BEVEL:
     case NS_THEME_SPINNER:
     case NS_THEME_TOOLBAR:
     case NS_THEME_MOZ_MAC_UNIFIED_TOOLBAR:
     case NS_THEME_STATUSBAR:
@@ -2104,36 +2095,32 @@ nsNativeThemeCocoa::ThemeSupportsWidget(
 
 PRBool
 nsNativeThemeCocoa::WidgetIsContainer(PRUint8 aWidgetType)
 {
   // flesh this out at some point
   switch (aWidgetType) {
    case NS_THEME_DROPDOWN_BUTTON:
    case NS_THEME_RADIO:
-   case NS_THEME_RADIO_SMALL:
    case NS_THEME_CHECKBOX:
-   case NS_THEME_CHECKBOX_SMALL:
    case NS_THEME_PROGRESSBAR:
     return PR_FALSE;
     break;
   }
   return PR_TRUE;
 }
 
 
 PRBool
 nsNativeThemeCocoa::ThemeDrawsFocusForWidget(nsPresContext* aPresContext, nsIFrame* aFrame, PRUint8 aWidgetType)
 {
   if (aWidgetType == NS_THEME_DROPDOWN ||
       aWidgetType == NS_THEME_BUTTON ||
       aWidgetType == NS_THEME_RADIO ||
-      aWidgetType == NS_THEME_RADIO_SMALL ||
-      aWidgetType == NS_THEME_CHECKBOX ||
-      aWidgetType == NS_THEME_CHECKBOX_SMALL)
+      aWidgetType == NS_THEME_CHECKBOX)
     return PR_TRUE;
 
   return PR_FALSE;
 }
 
 PRBool
 nsNativeThemeCocoa::ThemeNeedsComboboxDropmarker()
 {
diff -r 4f1383af8f10 widget/src/gtk2/nsNativeThemeGTK.cpp
--- a/widget/src/gtk2/nsNativeThemeGTK.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/widget/src/gtk2/nsNativeThemeGTK.cpp	Mon Nov 03 05:09:10 2008 -0500
@@ -66,26 +66,16 @@
 
 #include "gfxContext.h"
 #include "gfxPlatformGtk.h"
 #include "gfxGdkNativeRenderer.h"
 
 NS_IMPL_ISUPPORTS2(nsNativeThemeGTK, nsITheme, nsIObserver)
 
 static int gLastGdkError;
-
-static inline bool IsCheckboxWidgetType(PRUint8 aWidgetType)
-{
-  return (aWidgetType == NS_THEME_CHECKBOX || aWidgetType == NS_THEME_CHECKBOX_SMALL);
-}
-
-static inline bool IsRadioWidgetType(PRUint8 aWidgetType)
-{
-  return (aWidgetType == NS_THEME_RADIO || aWidgetType == NS_THEME_RADIO_SMALL);
-}
 
 nsNativeThemeGTK::nsNativeThemeGTK()
 {
   if (moz_gtk_init() != MOZ_GTK_SUCCESS) {
     memset(mDisabledWidgetTypes, 0xff, sizeof(mDisabledWidgetTypes));
     return;
   }
 
@@ -189,18 +179,18 @@ nsNativeThemeGTK::GetGtkWidgetAndState(P
     if (!aFrame) {
       // reset the entire struct to zero
       memset(aState, 0, sizeof(GtkWidgetState));
     } else {
 
       // For XUL checkboxes and radio buttons, the state of the parent
       // determines our state.
       nsIFrame *stateFrame = aFrame;
-      if (aFrame && ((aWidgetFlags && (IsCheckboxWidgetType(aWidgetType) ||
-                                       IsRadioWidgetType(aWidgetType))) ||
+      if (aFrame && ((aWidgetFlags && (aWidgetType == NS_THEME_CHECKBOX ||
+                                       aWidgetType == NS_THEME_RADIO)) ||
                      aWidgetType == NS_THEME_CHECKBOX_LABEL ||
                      aWidgetType == NS_THEME_RADIO_LABEL)) {
 
         nsIAtom* atom = nsnull;
         nsIContent *content = aFrame->GetContent();
         if (content->IsNodeOfType(nsINode::eXUL)) {
           if (aWidgetType == NS_THEME_CHECKBOX_LABEL ||
               aWidgetType == NS_THEME_RADIO_LABEL) {
@@ -208,17 +198,17 @@ nsNativeThemeGTK::GetGtkWidgetAndState(P
             stateFrame = aFrame = aFrame->GetParent()->GetParent();
           } else {
             // GetContentState knows to look one frame up for radio/checkbox
             // widgets, so don't adjust stateFrame here.
             aFrame = aFrame->GetParent();
           }
           if (aWidgetFlags) {
             if (!atom) {
-              atom = (IsCheckboxWidgetType(aWidgetType) ||
+              atom = (aWidgetType == NS_THEME_CHECKBOX ||
                       aWidgetType == NS_THEME_CHECKBOX_LABEL) ? nsWidgetAtoms::checked
                                                               : nsWidgetAtoms::selected;
             }
             *aWidgetFlags = CheckBooleanAttr(aFrame, atom);
           }
         } else {
           if (aWidgetFlags) {
             nsCOMPtr<nsIDOMHTMLInputElement> inputElt(do_QueryInterface(content));
@@ -250,18 +240,18 @@ nsNativeThemeGTK::GetGtkWidgetAndState(P
         // to see whether to draw in the focused state.
         if (aWidgetType == NS_THEME_TEXTFIELD ||
             aWidgetType == NS_THEME_TEXTFIELD_MULTILINE ||
             aWidgetType == NS_THEME_DROPDOWN_TEXTFIELD ||
             aWidgetType == NS_THEME_SPINNER_TEXTFIELD ||
             aWidgetType == NS_THEME_RADIO_CONTAINER ||
             aWidgetType == NS_THEME_RADIO_LABEL) {
           aState->focused = IsFocused(aFrame);
-        } else if (IsRadioWidgetType(aWidgetType) ||
-                   IsCheckboxWidgetType(aWidgetType)) {
+        } else if (aWidgetType == NS_THEME_RADIO ||
+                   aWidgetType == NS_THEME_CHECKBOX) {
           // In XUL, checkboxes and radios shouldn't have focus rings, their labels do
           aState->focused = FALSE;
         }
 
         if (aWidgetType == NS_THEME_SCROLLBAR_THUMB_VERTICAL ||
             aWidgetType == NS_THEME_SCROLLBAR_THUMB_HORIZONTAL) {
           // for scrollbars we need to go up two to go from the thumb to
           // the slider to the actual scrollbar object
@@ -366,20 +356,18 @@ nsNativeThemeGTK::GetGtkWidgetAndState(P
   case NS_THEME_BUTTON:
   case NS_THEME_TOOLBAR_BUTTON:
   case NS_THEME_TOOLBAR_DUAL_BUTTON:
     if (aWidgetFlags)
       *aWidgetFlags = (aWidgetType == NS_THEME_BUTTON) ? GTK_RELIEF_NORMAL : GTK_RELIEF_NONE;
     aGtkWidgetType = MOZ_GTK_BUTTON;
     break;
   case NS_THEME_CHECKBOX:
-  case NS_THEME_CHECKBOX_SMALL:
   case NS_THEME_RADIO:
-  case NS_THEME_RADIO_SMALL:
-    aGtkWidgetType = IsRadioWidgetType(aWidgetType) ? MOZ_GTK_RADIOBUTTON : MOZ_GTK_CHECKBUTTON;
+    aGtkWidgetType = (aWidgetType == NS_THEME_RADIO) ? MOZ_GTK_RADIOBUTTON : MOZ_GTK_CHECKBUTTON;
     break;
   case NS_THEME_SCROLLBAR_BUTTON_UP:
   case NS_THEME_SCROLLBAR_BUTTON_DOWN:
   case NS_THEME_SCROLLBAR_BUTTON_LEFT:
   case NS_THEME_SCROLLBAR_BUTTON_RIGHT:
     aGtkWidgetType = MOZ_GTK_SCROLLBAR_BUTTON;
     break;
   case NS_THEME_SCROLLBAR_TRACK_VERTICAL:
@@ -665,23 +653,21 @@ GetExtraSizeForWidget(PRUint8 aWidgetTyp
     aExtra->top = aExtra->bottom = 1;
     return PR_TRUE;
   case NS_THEME_SCROLLBAR_THUMB_HORIZONTAL:
     aExtra->left = aExtra->right = 1;
     return PR_TRUE;
 
   // Include the indicator spacing (the padding around the control).
   case NS_THEME_CHECKBOX:
-  case NS_THEME_CHECKBOX_SMALL:
   case NS_THEME_RADIO:
-  case NS_THEME_RADIO_SMALL:
     {
       gint indicator_size, indicator_spacing;
 
-      if (IsCheckboxWidgetType(aWidgetType)) {
+      if (aWidgetType == NS_THEME_CHECKBOX) {
         moz_gtk_checkbox_get_metrics(&indicator_size, &indicator_spacing);
       } else {
         moz_gtk_radio_get_metrics(&indicator_size, &indicator_spacing);
       }
 
       aExtra->top = indicator_spacing;
       aExtra->right = indicator_spacing;
       aExtra->bottom = indicator_spacing;
@@ -875,19 +861,17 @@ nsNativeThemeGTK::GetWidgetPadding(nsIDe
     case NS_THEME_TOOLBAR_DUAL_BUTTON:
     case NS_THEME_TAB_SCROLLARROW_BACK:
     case NS_THEME_TAB_SCROLLARROW_FORWARD:
     case NS_THEME_DROPDOWN_BUTTON:
     // Radios and checkboxes return a fixed size in GetMinimumWidgetSize
     // and have a meaningful baseline, so they can't have
     // author-specified padding.
     case NS_THEME_CHECKBOX:
-    case NS_THEME_CHECKBOX_SMALL:
     case NS_THEME_RADIO:
-    case NS_THEME_RADIO_SMALL:
       aResult->SizeTo(0, 0, 0, 0);
       return PR_TRUE;
   }
 
   return PR_FALSE;
 }
 
 PRBool
@@ -1044,23 +1028,21 @@ nsNativeThemeGTK::GetMinimumWidgetSize(n
 
       moz_gtk_get_menu_separator_height(&separator_height);
       aResult->height = separator_height;
     
       *aIsOverridable = PR_FALSE;
     }
     break;
   case NS_THEME_CHECKBOX:
-  case NS_THEME_CHECKBOX_SMALL:
   case NS_THEME_RADIO:
-  case NS_THEME_RADIO_SMALL:
     {
       gint indicator_size, indicator_spacing;
 
-      if (IsCheckboxWidgetType(aWidgetType)) {
+      if (aWidgetType == NS_THEME_CHECKBOX) {
         moz_gtk_checkbox_get_metrics(&indicator_size, &indicator_spacing);
       } else {
         moz_gtk_radio_get_metrics(&indicator_size, &indicator_spacing);
       }
 
       // Include space for the indicator and the padding around it.
       aResult->width = indicator_size;
       aResult->height = indicator_size;
@@ -1212,19 +1194,17 @@ nsNativeThemeGTK::ThemeSupportsWidget(ns
 {
   if (IsWidgetTypeDisabled(mDisabledWidgetTypes, aWidgetType))
     return PR_FALSE;
 
   switch (aWidgetType) {
   case NS_THEME_BUTTON:
   case NS_THEME_BUTTON_FOCUS:
   case NS_THEME_RADIO:
-  case NS_THEME_RADIO_SMALL:
   case NS_THEME_CHECKBOX:
-  case NS_THEME_CHECKBOX_SMALL:
   case NS_THEME_TOOLBOX: // N/A
   case NS_THEME_TOOLBAR:
   case NS_THEME_TOOLBAR_BUTTON:
   case NS_THEME_TOOLBAR_DUAL_BUTTON: // so we can override the border with 0
   case NS_THEME_TOOLBAR_BUTTON_DROPDOWN:
   case NS_THEME_TOOLBAR_SEPARATOR:
   case NS_THEME_TOOLBAR_GRIPPER:
   case NS_THEME_STATUSBAR:
@@ -1305,18 +1285,18 @@ nsNativeThemeGTK::ThemeSupportsWidget(ns
   return PR_FALSE;
 }
 
 NS_IMETHODIMP_(PRBool)
 nsNativeThemeGTK::WidgetIsContainer(PRUint8 aWidgetType)
 {
   // XXXdwh At some point flesh all of this out.
   if (aWidgetType == NS_THEME_DROPDOWN_BUTTON ||
-      IsRadioWidgetType(aWidgetType) ||
-      IsCheckboxWidgetType(aWidgetType) ||
+      aWidgetType == NS_THEME_RADIO ||
+      aWidgetType == NS_THEME_CHECKBOX ||
       aWidgetType == NS_THEME_TAB_SCROLLARROW_BACK ||
       aWidgetType == NS_THEME_TAB_SCROLLARROW_FORWARD)
     return PR_FALSE;
   return PR_TRUE;
 }
 
 PRBool
 nsNativeThemeGTK::ThemeDrawsFocusForWidget(nsPresContext* aPresContext, nsIFrame* aFrame, PRUint8 aWidgetType)
diff -r 4f1383af8f10 widget/src/qt/nsNativeThemeQt.cpp
--- a/widget/src/qt/nsNativeThemeQt.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/widget/src/qt/nsNativeThemeQt.cpp	Mon Nov 03 05:09:10 2008 -0500
@@ -136,24 +136,21 @@ nsNativeThemeQt::DrawWidgetBackground(ns
 
     QRect r = qRectInPixels(aRect, p2a);
     QRect cr = qRectInPixels(aClipRect, p2a);
 
     QStyle::State extraFlags = QStyle::State_None;
 
     switch (aWidgetType) {
     case NS_THEME_RADIO:
-    case NS_THEME_RADIO_SMALL: 
-    case NS_THEME_CHECKBOX:
-    case NS_THEME_CHECKBOX_SMALL: {
+    case NS_THEME_CHECKBOX: {
         QStyleOptionButton opt;
         InitButtonStyle (aWidgetType, aFrame, r, opt);
 
-        if (aWidgetType == NS_THEME_CHECKBOX ||
-            aWidgetType == NS_THEME_CHECKBOX_SMALL)
+        if (aWidgetType == NS_THEME_CHECKBOX)
         {
             style->drawPrimitive (QStyle::PE_IndicatorCheckBox, &opt, qPainter);
         } else {
             style->drawPrimitive (QStyle::PE_IndicatorRadioButton, &opt, qPainter);
         }
         break;
     }
     case NS_THEME_BUTTON:
@@ -327,30 +324,28 @@ nsNativeThemeQt::GetMinimumWidgetSize(ns
     (*aResult).width = (*aResult).height = 0;
     *aIsOverridable = PR_TRUE;
 
     QStyle *s = qApp->style();
 
     PRInt32 p2a = GetAppUnitsPerDevPixel(aContext);
 
     switch (aWidgetType) {
-    case NS_THEME_RADIO_SMALL:
     case NS_THEME_RADIO:
-    case NS_THEME_CHECKBOX_SMALL:
     case NS_THEME_CHECKBOX: {
         nsRect frameRect = aFrame->GetRect();
 
         QRect qRect = qRectInPixels(frameRect, p2a);
 
         QStyleOptionButton option;
 
         InitButtonStyle(aWidgetType, aFrame, qRect, option);
 
         QRect rect = s->subElementRect(
-            (aWidgetType == NS_THEME_CHECKBOX || aWidgetType == NS_THEME_CHECKBOX_SMALL ) ?
+            (aWidgetType == NS_THEME_CHECKBOX) ?
                 QStyle::SE_CheckBoxIndicator :
                 QStyle::SE_RadioButtonIndicator,
             &option,
             NULL);
 
         (*aResult).width = rect.width();
         (*aResult).height = rect.height();
         break;
@@ -515,19 +510,17 @@ nsNativeThemeQt::ThemeSupportsWidget(nsP
     case NS_THEME_SCROLLBAR_BUTTON_RIGHT:
     case NS_THEME_SCROLLBAR_THUMB_HORIZONTAL:
     case NS_THEME_SCROLLBAR_THUMB_VERTICAL:
     //case NS_THEME_SCROLLBAR_GRIPPER_HORIZONTAL:
     //case NS_THEME_SCROLLBAR_GRIPPER_VERTICAL:
     case NS_THEME_SCROLLBAR_TRACK_HORIZONTAL:
     case NS_THEME_SCROLLBAR_TRACK_VERTICAL:
     case NS_THEME_RADIO:
-    case NS_THEME_RADIO_SMALL:
     case NS_THEME_CHECKBOX:
-    case NS_THEME_CHECKBOX_SMALL:
     case NS_THEME_BUTTON_BEVEL:
     case NS_THEME_BUTTON:
     case NS_THEME_DROPDOWN:
     case NS_THEME_DROPDOWN_BUTTON:
     case NS_THEME_DROPDOWN_TEXT:
     case NS_THEME_DROPDOWN_TEXTFIELD:
     case NS_THEME_TEXTFIELD:
     case NS_THEME_TEXTFIELD_MULTILINE:
@@ -590,19 +583,17 @@ nsNativeThemeQt::InitButtonStyle(PRUint8
     if (eventState & NS_EVENT_STATE_FOCUS)
         opt.state |= QStyle::State_HasFocus;
     if (!disabled && eventState & NS_EVENT_STATE_ACTIVE)
         // Don't allow sunken when disabled
         opt.state |= QStyle::State_Sunken;
 
     switch (aWidgetType) {
     case NS_THEME_RADIO:
-    case NS_THEME_RADIO_SMALL:
     case NS_THEME_CHECKBOX:
-    case NS_THEME_CHECKBOX_SMALL:
         if (IsChecked(aFrame))
             opt.state |= QStyle::State_On;
         else
             opt.state |= QStyle::State_Off;
 
         break;
     default:
         if (!(eventState & NS_EVENT_STATE_ACTIVE))
diff -r 4f1383af8f10 widget/src/windows/nsNativeThemeWin.cpp
--- a/widget/src/windows/nsNativeThemeWin.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/widget/src/windows/nsNativeThemeWin.cpp	Mon Nov 03 05:09:10 2008 -0500
@@ -66,26 +66,16 @@
 #include "gfxMatrix.h"
 #include "gfxWindowsSurface.h"
 #include "gfxWindowsNativeDrawing.h"
 
 #include "nsUXThemeData.h"
 #include "nsUXThemeConstants.h"
 
 NS_IMPL_ISUPPORTS1(nsNativeThemeWin, nsITheme)
-
-static inline bool IsCheckboxWidgetType(PRUint8 aWidgetType)
-{
-  return (aWidgetType == NS_THEME_CHECKBOX || aWidgetType == NS_THEME_CHECKBOX_SMALL);
-}
-
-static inline bool IsRadioWidgetType(PRUint8 aWidgetType)
-{
-  return (aWidgetType == NS_THEME_RADIO || aWidgetType == NS_THEME_RADIO_SMALL);
-}
 
 static inline bool IsHTMLContent(nsIFrame *frame)
 {
   nsIContent* content = frame->GetContent();
   return content && content->IsNodeOfType(nsINode::eHTML);
 }
 
 nsNativeThemeWin::nsNativeThemeWin() {
@@ -256,19 +246,17 @@ nsNativeThemeWin::GetTheme(PRUint8 aWidg
     // apps do the textfield border business as well).
     if (aWidgetType == NS_THEME_DROPDOWN)
       aWidgetType = NS_THEME_TEXTFIELD;
   }
 
   switch (aWidgetType) {
     case NS_THEME_BUTTON:
     case NS_THEME_RADIO:
-    case NS_THEME_RADIO_SMALL:
     case NS_THEME_CHECKBOX:
-    case NS_THEME_CHECKBOX_SMALL:
       return nsUXThemeData::GetTheme(eUXButton);
     case NS_THEME_TEXTFIELD:
     case NS_THEME_TEXTFIELD_MULTILINE:
       return nsUXThemeData::GetTheme(eUXEdit);
     case NS_THEME_TOOLTIP:
       // BUG #161600: XP/2K3 should force a classic treatment of tooltips
       return nsUXThemeData::sIsVistaOrLater ? nsUXThemeData::GetTheme(eUXTooltip) : NULL;
     case NS_THEME_TOOLBOX:
@@ -398,20 +386,18 @@ nsNativeThemeWin::GetThemePartAndState(n
       
       // Check for default dialog buttons.  These buttons should always look
       // focused.
       if (aState == TS_NORMAL && IsDefaultButton(aFrame))
         aState = TS_FOCUSED;
       return NS_OK;
     }
     case NS_THEME_CHECKBOX:
-    case NS_THEME_CHECKBOX_SMALL:
-    case NS_THEME_RADIO:
-    case NS_THEME_RADIO_SMALL: {
-      bool isCheckbox = IsCheckboxWidgetType(aWidgetType);
+    case NS_THEME_RADIO: {
+      bool isCheckbox = (aWidgetType == NS_THEME_CHECKBOX);
       aPart = isCheckbox ? BP_CHECKBOX : BP_RADIO;
 
       // XXXdwh This check will need to be more complicated, since HTML radio groups
       // use checked, but XUL radio groups use selected.  There will need to be an
       // IsNodeOfType test for HTML vs. XUL here.
       nsIAtom* atom = isCheckbox ? nsWidgetAtoms::checked
                                  : nsWidgetAtoms::selected;
 
@@ -1119,17 +1105,17 @@ RENDER_AGAIN:
   // If part is negative, the element wishes us to not render a themed
   // background, instead opting to be drawn specially below.
   else if (part >= 0) {
     nsUXThemeData::drawThemeBG(theme, hdc, part, state, &widgetRect, &clipRect);
   }
 
   // Draw focus rectangles for XP HTML checkboxes and radio buttons
   // XXX it'd be nice to draw these outside of the frame
-  if ((IsCheckboxWidgetType(aWidgetType) || IsRadioWidgetType(aWidgetType)) &&
+  if ((aWidgetType == NS_THEME_CHECKBOX || aWidgetType == NS_THEME_RADIO) &&
       aFrame->GetContent()->IsNodeOfType(nsINode::eHTML) ||
       aWidgetType == NS_THEME_SCALE_HORIZONTAL ||
       aWidgetType == NS_THEME_SCALE_VERTICAL) {
       PRInt32 contentState ;
       contentState = GetContentState(aFrame, aWidgetType);  
             
       if (contentState & NS_EVENT_STATE_FOCUS) {
         // setup DC to make DrawFocusRect draw correctly
@@ -1270,19 +1256,17 @@ nsNativeThemeWin::GetWidgetPadding(nsIDe
                                    PRUint8 aWidgetType,
                                    nsMargin* aResult)
 {
   switch (aWidgetType) {
     // Radios and checkboxes return a fixed size in GetMinimumWidgetSize
     // and have a meaningful baseline, so they can't have
     // author-specified padding.
     case NS_THEME_CHECKBOX:
-    case NS_THEME_CHECKBOX_SMALL:
     case NS_THEME_RADIO:
-    case NS_THEME_RADIO_SMALL:
       aResult->SizeTo(0, 0, 0, 0);
       return PR_TRUE;
   }
 
   HANDLE theme = GetTheme(aWidgetType);
   if (!theme)
     return PR_FALSE;
 
@@ -1648,18 +1632,18 @@ nsNativeThemeWin::ThemeSupportsWidget(ns
   return PR_FALSE;
 }
 
 PRBool 
 nsNativeThemeWin::WidgetIsContainer(PRUint8 aWidgetType)
 {
   // XXXdwh At some point flesh all of this out.
   if (aWidgetType == NS_THEME_DROPDOWN_BUTTON || 
-      IsRadioWidgetType(aWidgetType) ||
-      IsCheckboxWidgetType(aWidgetType))
+      aWidgetType == NS_THEME_RADIO ||
+      aWidgetType == NS_THEME_CHECKBOX)
     return PR_FALSE;
   return PR_TRUE;
 }
 
 PRBool
 nsNativeThemeWin::ThemeDrawsFocusForWidget(nsPresContext* aPresContext, nsIFrame* aFrame, PRUint8 aWidgetType)
 {
   return PR_FALSE;
@@ -1683,19 +1667,17 @@ nsNativeThemeWin::ClassicThemeSupportsWi
     case NS_THEME_MENUPOPUP:
       // Classic non-flat menus are handled almost entirely through CSS.
       if (!nsUXThemeData::sFlatMenus)
         return PR_FALSE;
     case NS_THEME_BUTTON:
     case NS_THEME_TEXTFIELD:
     case NS_THEME_TEXTFIELD_MULTILINE:
     case NS_THEME_CHECKBOX:
-    case NS_THEME_CHECKBOX_SMALL:
     case NS_THEME_RADIO:
-    case NS_THEME_RADIO_SMALL:
     case NS_THEME_SCROLLBAR_BUTTON_UP:
     case NS_THEME_SCROLLBAR_BUTTON_DOWN:
     case NS_THEME_SCROLLBAR_BUTTON_LEFT:
     case NS_THEME_SCROLLBAR_BUTTON_RIGHT:
     case NS_THEME_SCROLLBAR_THUMB_VERTICAL:
     case NS_THEME_SCROLLBAR_THUMB_HORIZONTAL:
     case NS_THEME_SCROLLBAR_TRACK_VERTICAL:
     case NS_THEME_SCROLLBAR_TRACK_HORIZONTAL:
@@ -1821,19 +1803,17 @@ nsNativeThemeWin::ClassicGetMinimumWidge
 nsNativeThemeWin::ClassicGetMinimumWidgetSize(nsIRenderingContext* aContext, nsIFrame* aFrame,
                                        PRUint8 aWidgetType,
                                        nsSize* aResult, PRBool* aIsOverridable)
 {
   (*aResult).width = (*aResult).height = 0;
   *aIsOverridable = PR_TRUE;
   switch (aWidgetType) {
     case NS_THEME_RADIO:
-    case NS_THEME_RADIO_SMALL:
     case NS_THEME_CHECKBOX:
-    case NS_THEME_CHECKBOX_SMALL:
       (*aResult).width = (*aResult).height = 13;
       break;
     case NS_THEME_MENUCHECKBOX:
     case NS_THEME_MENURADIO:
     case NS_THEME_MENUARROW:
 #ifdef WINCE
       (*aResult).width =  16;
       (*aResult).height = 16;
@@ -1969,29 +1949,27 @@ nsresult nsNativeThemeWin::ClassicGetThe
           aFocused = PR_TRUE;          
         }
 
       }
 
       return NS_OK;
     }
     case NS_THEME_CHECKBOX:
-    case NS_THEME_CHECKBOX_SMALL:
-    case NS_THEME_RADIO:
-    case NS_THEME_RADIO_SMALL: {
+    case NS_THEME_RADIO: {
       PRInt32 contentState ;
       aFocused = PR_FALSE;
 
       aPart = DFC_BUTTON;
-      aState = (IsCheckboxWidgetType(aWidgetType)) ? DFCS_BUTTONCHECK : DFCS_BUTTONRADIO;
+      aState = (aWidgetType == NS_THEME_CHECKBOX) ? DFCS_BUTTONCHECK : DFCS_BUTTONRADIO;
       nsIContent* content = aFrame->GetContent();
            
       if (content->IsNodeOfType(nsINode::eXUL)) {
         // XUL
-        if (IsCheckboxWidgetType(aWidgetType)) {
+        if (aWidgetType == NS_THEME_CHECKBOX) {
           if (IsChecked(aFrame))
             aState |= DFCS_CHECKED;
         }
         else
           if (IsSelected(aFrame))
             aState |= DFCS_CHECKED;
         contentState = GetContentState(aFrame, aWidgetType);
       }
@@ -2418,36 +2396,34 @@ RENDER_AGAIN:
         if (brush)
           ::FrameRect(hdc, &widgetRect, brush);
         InflateRect(&widgetRect, -1, -1);
       }
       // fall-through...
     }
     // Draw controls supported by DrawFrameControl
     case NS_THEME_CHECKBOX:
-    case NS_THEME_CHECKBOX_SMALL:
     case NS_THEME_RADIO:
-    case NS_THEME_RADIO_SMALL:
     case NS_THEME_SCROLLBAR_BUTTON_UP:
     case NS_THEME_SCROLLBAR_BUTTON_DOWN:
     case NS_THEME_SCROLLBAR_BUTTON_LEFT:
     case NS_THEME_SCROLLBAR_BUTTON_RIGHT:
     case NS_THEME_SPINNER_UP_BUTTON:
     case NS_THEME_SPINNER_DOWN_BUTTON:
     case NS_THEME_DROPDOWN_BUTTON:
     case NS_THEME_RESIZER: {
       PRInt32 oldTA;
       // setup DC to make DrawFrameControl draw correctly
       oldTA = ::SetTextAlign(hdc, TA_TOP | TA_LEFT | TA_NOUPDATECP);
       ::DrawFrameControl(hdc, &widgetRect, part, state);
       ::SetTextAlign(hdc, oldTA);
 
       // Draw focus rectangles for HTML checkboxes and radio buttons
       // XXX it'd be nice to draw these outside of the frame
-      if (focused && (IsCheckboxWidgetType(aWidgetType) || IsRadioWidgetType(aWidgetType))) {
+      if (focused && (aWidgetType == NS_THEME_CHECKBOX || aWidgetType == NS_THEME_RADIO)) {
         // setup DC to make DrawFocusRect draw correctly
         POINT vpOrg;
         ::GetViewportOrgEx(hdc, &vpOrg);
         ::SetBrushOrgEx(hdc, vpOrg.x + widgetRect.left, vpOrg.y + widgetRect.top, NULL);
         PRInt32 oldColor;
         oldColor = ::SetTextColor(hdc, 0);
         // draw focus rectangle
         ::DrawFocusRect(hdc, &widgetRect);
@@ -2736,19 +2712,17 @@ nsNativeThemeWin::GetWidgetNativeDrawing
       break;
 
     // the dropdown button /almost/ renders correctly with scaling,
     // except that the graphic in the dropdown button (the downward arrow)
     // doesn't get scaled up.
     case NS_THEME_DROPDOWN_BUTTON:
     // these are definitely no; they're all graphics that don't get scaled up
     case NS_THEME_CHECKBOX:
-    case NS_THEME_CHECKBOX_SMALL:
     case NS_THEME_RADIO:
-    case NS_THEME_RADIO_SMALL:
     case NS_THEME_CHECKMENUITEM:
     case NS_THEME_RADIOMENUITEM:
     case NS_THEME_MENUCHECKBOX:
     case NS_THEME_MENURADIO:
     case NS_THEME_MENUARROW:
       return
         gfxWindowsNativeDrawing::CANNOT_DRAW_TO_COLOR_ALPHA |
         gfxWindowsNativeDrawing::CANNOT_AXIS_ALIGNED_SCALE |
diff -r 4f1383af8f10 widget/src/xpwidgets/nsNativeTheme.cpp
--- a/widget/src/xpwidgets/nsNativeTheme.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/widget/src/xpwidgets/nsNativeTheme.cpp	Mon Nov 03 05:09:10 2008 -0500
@@ -69,31 +69,29 @@ PRInt32
 PRInt32
 nsNativeTheme::GetContentState(nsIFrame* aFrame, PRUint8 aWidgetType)
 {
   if (!aFrame)
     return 0;
 
   PRBool isXULCheckboxRadio = 
     (aWidgetType == NS_THEME_CHECKBOX ||
-     aWidgetType == NS_THEME_CHECKBOX_SMALL ||
-     aWidgetType == NS_THEME_RADIO ||
-     aWidgetType == NS_THEME_RADIO_SMALL) &&
+     aWidgetType == NS_THEME_RADIO) &&
     aFrame->GetContent()->IsNodeOfType(nsINode::eXUL);
   if (isXULCheckboxRadio)
     aFrame = aFrame->GetParent();
 
   nsIPresShell *shell = GetPresShell(aFrame);
   if (!shell)
     return 0;
 
   PRInt32 flags = 0;
   shell->GetPresContext()->EventStateManager()->GetContentState(aFrame->GetContent(), flags);
   
-  if (isXULCheckboxRadio && (aWidgetType == NS_THEME_RADIO || aWidgetType == NS_THEME_RADIO_SMALL)) {
+  if (isXULCheckboxRadio && aWidgetType == NS_THEME_RADIO) {
     if (IsFocused(aFrame))
       flags |= NS_EVENT_STATE_FOCUS;
   }
   
   return flags;
 }
 
 PRBool
diff -r 4f1383af8f10 xpcom/components/nsIClassInfo.idl
--- a/xpcom/components/nsIClassInfo.idl	Sat Nov 01 09:52:29 2008 +0100
+++ b/xpcom/components/nsIClassInfo.idl	Mon Nov 03 05:09:10 2008 -0500
@@ -34,16 +34,28 @@
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsISupports.idl"
+
+%{C++
+/**
+ * Calling QueryInterface with this special IID will return a null-terminated
+ * table of QITableEntry's. Not all objects support this.
+ * Note that this breaks XPCOM rules a bit (the table doesn't derive from
+ * nsISupports).
+ */
+#define NS_THISPTROFFSETS_SID \
+    { 0x23e017cc, 0x5d6f, 0x430c, \
+      { 0xb3, 0xe6, 0x9d, 0x32, 0x65, 0x70, 0xd6, 0xb8 } }
+%}
 
 /**
  * Provides information about a specific implementation class
  * @status FROZEN
  */
 
 [scriptable, uuid(986c11d0-f340-11d4-9075-0010a4e73d9a)]
 interface nsIClassInfo : nsISupports
diff -r 4f1383af8f10 xpcom/obsolete/nsFileSpecOS2.cpp
--- a/xpcom/obsolete/nsFileSpecOS2.cpp	Sat Nov 01 09:52:29 2008 +0100
+++ b/xpcom/obsolete/nsFileSpecOS2.cpp	Mon Nov 03 05:09:10 2008 -0500
@@ -49,20 +49,16 @@
  * 03/23/2000       IBM Corp.      Fixed bug where 2 char or less profile names treated as drive letters.
  * 06/20/2000       IBM Corp.      Make it more like Windows version.
  */
 
 #define INCL_DOSERRORS
 #define INCL_DOS
 #define INCL_WINWORKPLACE
 #include <os2.h>
-
-#ifdef XP_OS2_VACPP
-#include <direct.h>
-#endif
 
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <limits.h>
 #include <ctype.h>
 #include <io.h>
 
 //----------------------------------------------------------------------------------------
@@ -496,44 +492,34 @@ void nsFileSpec::operator += (const char
 } // nsFileSpec::operator +=
 
 //----------------------------------------------------------------------------------------
 void nsFileSpec::CreateDirectory(int /*mode*/)
 //----------------------------------------------------------------------------------------
 {
 	// Note that mPath is canonical!
 	if (!mPath.IsEmpty())
-#ifdef XP_OS2
-	    // OS2TODO - vacpp complains about mkdir but PR_MkDir should be ok?
-            PR_MkDir(nsNSPRPath(*this), PR_CREATE_FILE);
-#else
 	    mkdir(nsNSPRPath(*this));
-#endif
 } // nsFileSpec::CreateDirectory
 
 //----------------------------------------------------------------------------------------
 void nsFileSpec::Delete(PRBool inRecursive) const
 //----------------------------------------------------------------------------------------
 {
     if (IsDirectory())
     {
 	    if (inRecursive)
         {
             for (nsDirectoryIterator i(*this, PR_FALSE); i.Exists(); i++)
                 {
                     nsFileSpec& child = i.Spec();
                     child.Delete(inRecursive);
                 }		
         }
-#ifdef XP_OS2
-            // OS2TODO - vacpp complains if use rmdir but PR_RmDir should be ok?
-            PR_RmDir(nsNSPRPath(*this));
-#else
 	    rmdir(nsNSPRPath(*this));
-#endif
     }
 	else if (!mPath.IsEmpty())
     {
         remove(nsNSPRPath(*this));
     }
 } // nsFileSpec::Delete
 
 
diff -r 4f1383af8f10 xpcom/system/Makefile.in
--- a/xpcom/system/Makefile.in	Sat Nov 01 09:52:29 2008 +0100
+++ b/xpcom/system/Makefile.in	Mon Nov 03 05:09:10 2008 -0500
@@ -44,15 +44,16 @@ include $(DEPTH)/config/autoconf.mk
 
 MODULE          = xpcom
 XPIDL_MODULE    = xpcom_system
 
 XPIDLSRCS = \
         nsIXULAppInfo.idl \
         nsIGConfService.idl \
         nsIGnomeVFSService.idl \
+        nsIBlocklistService.idl \
         $(NULL)
 
 ifdef MOZ_CRASHREPORTER
 XPIDLSRCS += nsICrashReporter.idl
 endif
 
 include $(topsrcdir)/config/rules.mk
diff -r 4f1383af8f10 xpcom/system/nsIBlocklistService.idl
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/xpcom/system/nsIBlocklistService.idl	Mon Nov 03 05:09:10 2008 -0500
@@ -0,0 +1,113 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Blocklist Service.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Corporation
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Michael Wu <flamingice@sourmilk.net>  (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+
+#include "nsISupports.idl"
+
+interface nsIPluginTag;
+
+[scriptable, uuid(8439f9c0-da03-4260-8b21-dc635eed28fb)]
+interface nsIBlocklistService : nsISupports
+{
+  // Indicates that the item does not appear in the blocklist.
+  const unsigned long STATE_NOT_BLOCKED = 0;
+  // Indicates that the item is in the blocklist but the problem is not severe
+  // enough to warant forcibly blocking.
+  const unsigned long STATE_SOFTBLOCKED = 1;
+  // Indicates that the item should be blocked and never used.
+  const unsigned long STATE_BLOCKED     = 2;
+
+  /**
+   * Determine if an item is blocklisted
+   * @param   id
+   *          The ID of the item.
+   * @param   version
+   *          The item's version.
+   * @param   appVersion
+   *          The version of the application we are checking in the blocklist.
+   *          If this parameter is null, the version of the running application
+   *          is used.
+   * @param   toolkitVersion
+   *          The version of the toolkit we are checking in the blocklist.
+   *          If this parameter is null, the version of the running toolkit
+   *          is used.
+   * @returns true if the item is compatible with this version of the
+   *          application or this version of the toolkit, false, otherwise.
+   */
+  boolean isAddonBlocklisted(in AString id, in AString version,
+                             [optional] in AString appVersion,
+                             [optional] in AString toolkitVersion);
+
+  /**
+   * Determine the blocklist state of an add-on
+   * @param   id
+   *          The ID of the item.
+   * @param   version
+   *          The item's version.
+   * @param   appVersion
+   *          The version of the application we are checking in the blocklist.
+   *          If this parameter is null, the version of the running application
+   *          is used.
+   * @param   toolkitVersion
+   *          The version of the toolkit we are checking in the blocklist.
+   *          If this parameter is null, the version of the running toolkit
+   *          is used.
+   * @returns The STATE constant.
+   */
+  unsigned long getAddonBlocklistState(in AString id, in AString version,
+                                       [optional] in AString appVersion,
+                                       [optional] in AString toolkitVersion);
+
+  /**
+   * Determine the blocklist state of a plugin
+   * @param   plugin
+   *          The plugin to get the state for
+   * @param   appVersion
+   *          The version of the application we are checking in the blocklist.
+   *          If this parameter is null, the version of the running application
+   *          is used.
+   * @param   toolkitVersion
+   *          The version of the toolkit we are checking in the blocklist.
+   *          If this parameter is null, the version of the running toolkit
+   *          is used.
+   * @returns The STATE constant.
+   */
+  unsigned long getPluginBlocklistState(in nsIPluginTag plugin,
+                                        [optional] in AString appVersion,
+                                        [optional] in AString toolkitVersion);
+};
