diff -r 6c8c95fcaf9b accessible/src/base/nsAccessible.cpp
--- a/accessible/src/base/nsAccessible.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/accessible/src/base/nsAccessible.cpp	Thu Jul 17 14:13:03 2008 +0300
@@ -1591,19 +1591,10 @@ nsresult nsAccessible::AppendFlatStringF
   }
 
   nsAutoString textEquivalent;
   if (!aContent->IsNodeOfType(nsINode::eHTML)) {
     if (aContent->IsNodeOfType(nsINode::eXUL)) {
-      nsCOMPtr<nsIPresShell> shell = GetPresShell();
-      if (!shell) {
-        return NS_ERROR_FAILURE;  
-      }
-      nsIFrame *frame = shell->GetPrimaryFrameFor(aContent);
-      if (!frame || !frame->GetStyleVisibility()->IsVisible()) {
-        return NS_OK;
-      }
-
       nsCOMPtr<nsIDOMXULLabeledControlElement> labeledEl(do_QueryInterface(aContent));
       if (labeledEl) {
         labeledEl->GetLabel(textEquivalent);
       }
       else {
@@ -1659,12 +1650,21 @@ nsresult nsAccessible::AppendFlatStringF
 {
   static PRBool isAlreadyHere; // Prevent recursion which can cause infinite loops
   if (isAlreadyHere) {
     return NS_OK;
   }
+
   isAlreadyHere = PR_TRUE;
-  nsresult rv = AppendFlatStringFromSubtreeRecurse(aContent, aFlatString);
+
+  nsCOMPtr<nsIPresShell> shell = GetPresShell();
+  NS_ENSURE_TRUE(shell, NS_ERROR_FAILURE);
+
+  nsIFrame *frame = shell->GetPrimaryFrameFor(aContent);
+  PRBool isHidden = (!frame || !frame->GetStyleVisibility()->IsVisible());
+  nsresult rv = AppendFlatStringFromSubtreeRecurse(aContent, aFlatString,
+                                                   isHidden);
+
   isAlreadyHere = PR_FALSE;
 
   if (NS_SUCCEEDED(rv) && !aFlatString->IsEmpty()) {
     nsAString::const_iterator start, end;
     aFlatString->BeginReading(start);
@@ -1679,11 +1679,14 @@ nsresult nsAccessible::AppendFlatStringF
   }
 
   return rv;
 }
 
-nsresult nsAccessible::AppendFlatStringFromSubtreeRecurse(nsIContent *aContent, nsAString *aFlatString)
+nsresult
+nsAccessible::AppendFlatStringFromSubtreeRecurse(nsIContent *aContent,
+                                                 nsAString *aFlatString,
+                                                 PRBool aIsRootHidden)
 {
   // Depth first search for all text nodes that are decendants of content node.
   // Append all the text into one flat string
   PRUint32 numChildren = 0;
   nsCOMPtr<nsIDOMXULSelectControlElement> selectControlEl(do_QueryInterface(aContent));
@@ -1696,14 +1699,29 @@ nsresult nsAccessible::AppendFlatStringF
     AppendFlatStringFromContentNode(aContent, aFlatString);
     return NS_OK;
   }
 
   // There are relevant children: use them to get the text.
+  nsCOMPtr<nsIPresShell> shell = GetPresShell();
+  NS_ENSURE_TRUE(shell, NS_ERROR_FAILURE);
+
   PRUint32 index;
   for (index = 0; index < numChildren; index++) {
-    AppendFlatStringFromSubtreeRecurse(aContent->GetChildAt(index), aFlatString);
+    nsCOMPtr<nsIContent> childContent = aContent->GetChildAt(index);
+
+    // Walk into hidden subtree if the the root parent is also hidden. This
+    // happens when the author explictly uses a hidden label or description.
+    if (!aIsRootHidden) {
+      nsIFrame *childFrame = shell->GetPrimaryFrameFor(childContent);
+      if (!childFrame || !childFrame->GetStyleVisibility()->IsVisible())
+        continue;
+    }
+
+    AppendFlatStringFromSubtreeRecurse(childContent, aFlatString,
+                                       aIsRootHidden);
   }
+
   return NS_OK;
 }
 
 nsIContent *nsAccessible::GetLabelContent(nsIContent *aForNode)
 {
diff -r 6c8c95fcaf9b accessible/src/base/nsAccessible.h
--- a/accessible/src/base/nsAccessible.h	Tue Jul 15 15:16:43 2008 +1200
+++ b/accessible/src/base/nsAccessible.h	Thu Jul 17 14:13:03 2008 +0300
@@ -195,11 +195,26 @@ protected:
   nsresult AppendStringWithSpaces(nsAString *aFlatString, const nsAString& textEquivalent);
 
   // helper method to verify frames
   static nsresult GetFullKeyName(const nsAString& aModifierName, const nsAString& aKeyName, nsAString& aStringOut);
   static nsresult GetTranslatedString(const nsAString& aKey, nsAString& aStringOut);
-  nsresult AppendFlatStringFromSubtreeRecurse(nsIContent *aContent, nsAString *aFlatString);
+
+  /**
+   * Walk into subtree and calculate the string which is used as the accessible
+   * name or description.
+   *
+   * @param aContent      [in] traversed content
+   * @param aFlatString   [in, out] result string
+   * @param aIsRootHidden [in] specifies whether root content (we started to
+   *                      traverse from) is hidden, in this case the result
+   *                      string is calculated from hidden children
+   *                      (this is used when hidden root content is explicitly
+   *                      specified as label or description by author)
+   */
+  nsresult AppendFlatStringFromSubtreeRecurse(nsIContent *aContent,
+                                              nsAString *aFlatString,
+                                              PRBool aIsRootHidden);
 
   // Helpers for dealing with children
   virtual void CacheChildren();
   
   // nsCOMPtr<>& is useful here, because getter_AddRefs() nulls the comptr's value, and NextChild
diff -r 6c8c95fcaf9b accessible/src/base/nsCaretAccessible.cpp
--- a/accessible/src/base/nsCaretAccessible.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/accessible/src/base/nsCaretAccessible.cpp	Thu Jul 17 14:13:03 2008 +0300
@@ -37,11 +37,11 @@
 
 // NOTE: alphabetically ordered
 #include "nsAccessibilityService.h"
 #include "nsCaretAccessible.h"
 #include "nsIAccessibleEvent.h"
-#include "nsICaret.h"
+#include "nsCaret.h"
 #include "nsIDOMDocument.h"
 #include "nsIDOMHTMLAnchorElement.h"
 #include "nsIDOMHTMLInputElement.h"
 #include "nsIDOMHTMLTextAreaElement.h"
 #include "nsIFrame.h"
@@ -267,20 +267,20 @@ nsCaretAccessible::GetCaretRect(nsIWidge
   NS_ENSURE_TRUE(lastNodeWithCaret, caretRect);
 
   nsCOMPtr<nsIPresShell> presShell = mRootAccessible->GetPresShellFor(lastNodeWithCaret);
   NS_ENSURE_TRUE(presShell, caretRect);
 
-  nsCOMPtr<nsICaret> caret;
+  nsRefPtr<nsCaret> caret;
   presShell->GetCaret(getter_AddRefs(caret));
   NS_ENSURE_TRUE(caret, caretRect);
 
   PRBool isCollapsed;
   nsIView *view;
   nsCOMPtr<nsISelection> caretSelection(do_QueryReferent(mLastUsedSelection));
   NS_ENSURE_TRUE(caretSelection, caretRect);
   
-  caret->GetCaretCoordinates(nsICaret::eRenderingViewCoordinates, caretSelection,
+  caret->GetCaretCoordinates(nsCaret::eRenderingViewCoordinates, caretSelection,
                              &caretRect, &isCollapsed, &view);
   if (!view || caretRect.IsEmpty()) {
     return nsRect(); // Return empty rect
   }
 
diff -r 6c8c95fcaf9b accessible/src/base/nsCaretAccessible.h
--- a/accessible/src/base/nsCaretAccessible.h	Tue Jul 15 15:16:43 2008 +1200
+++ b/accessible/src/base/nsCaretAccessible.h	Thu Jul 17 14:13:03 2008 +0300
@@ -38,17 +38,18 @@
 #ifndef __nsCaretAccessible_h__
 #define __nsCaretAccessible_h__
 
 #include "nsIWeakReference.h"
 #include "nsIAccessibleText.h"
-#include "nsICaret.h"
 #include "nsIDOMNode.h"
 #include "nsISelectionListener.h"
 #include "nsRect.h"
 
 class nsRootAccessible;
 class nsIView;
+class nsIPresShell;
+class nsIWidget;
 
 /*
  * This special accessibility class is for the caret, which is really the currently focused selection.
  * There is only 1 visible caret per top level window (nsRootAccessible),
  * However, there may be several visible selections.
diff -r 6c8c95fcaf9b accessible/src/base/nsRootAccessible.cpp
--- a/accessible/src/base/nsRootAccessible.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/accessible/src/base/nsRootAccessible.cpp	Thu Jul 17 14:13:03 2008 +0300
@@ -38,11 +38,10 @@
 // NOTE: alphabetically ordered
 #include "nsAccessibilityService.h"
 #include "nsAccessibleEventData.h"
 #include "nsHTMLSelectAccessible.h"
 #include "nsIBaseWindow.h"
-#include "nsICaret.h"
 #include "nsIDocShell.h"
 #include "nsIDocShellTreeItem.h"
 #include "nsIDocShellTreeNode.h"
 #include "nsIDocShellTreeOwner.h"
 #include "nsIDOMDocument.h"
diff -r 6c8c95fcaf9b accessible/tests/mochitest/Makefile.in
--- a/accessible/tests/mochitest/Makefile.in	Tue Jul 15 15:16:43 2008 +1200
+++ b/accessible/tests/mochitest/Makefile.in	Thu Jul 17 14:13:03 2008 +0300
@@ -53,11 +53,11 @@ _TEST_FILES =\
 		test_aria_role_article.html \
 		test_bug368835.xul \
 		test_bug420863.html \
 		test_cssattrs.html \
 		test_groupattrs.xul \
-		test_table_indexes.html \
+	$(warning test_table_indexes.html temporarily disabled) \
 		test_nsIAccessible_name.html \
 		test_nsIAccessible_name.xul \
 		test_nsIAccessibleTable_1.html \
 		test_nsIAccessibleTable_2.html \
 		test_nsIAccessibleTable_3.html \
diff -r 6c8c95fcaf9b accessible/tests/mochitest/test_nsIAccessible_name.html
--- a/accessible/tests/mochitest/test_nsIAccessible_name.html	Tue Jul 15 15:16:43 2008 +1200
+++ b/accessible/tests/mochitest/test_nsIAccessible_name.html	Thu Jul 17 14:13:03 2008 +0300
@@ -56,11 +56,19 @@
       //////////////////////////////////////////////////////////////////////////
       // Name from subtree (single relation labelled_by).
       
       // Gets the name from text nodes contained by nested elements
       testName("btn_labelledby_mixed", "nomore text");
-  
+
+      // Gets the name from text nodes contained by nested elements, ignores
+      // hidden elements (bug 443081).
+      testName("btn_labelledby_mixed_hidden_child", "nomore text2");
+
+      // Gets the name from hidden text nodes contained by nested elements, 
+      // (label element is hidden entirely), (bug 443081).
+      testName("btn_labelledby_mixed_hidden", "lala more hidden text");
+
       // Gets the name from text nodes contained by nested elements having block
       // representation (every text node value in the name should be devided by
       // spaces)
       testName("btn_labelledby_mixed_block", "text more text");
 
@@ -110,10 +118,14 @@
       // name from children
 
       // ARIA role button is presented allowing the name calculation from
       // children.
       testName("btn_children", "14");
+
+      // ARIA role option is presented allowing the name calculation from
+      // visible children (bug 443081).
+      testName("lb_opt1_children_hidden", "i am visible");
 
 
       //////////////////////////////////////////////////////////////////////////
       // title attribute
 
@@ -156,10 +168,29 @@
 
   <!-- the name from subtree, mixed content -->
   <span id="labelledby_mixed">no<span>more text</span></span>
   <button id="btn_labelledby_mixed"
           aria-labelledby="labelledby_mixed">3</button>
+  <br/>
+
+  <!-- the name from subtree, mixed/hidden content -->
+  <span id="labelledby_mixed_hidden_child">
+    no<span>more 
+      <span style="display: none;">hidden</span>
+      text2
+      <span style="visibility: hidden">hidden2</span>
+    </span>
+  </span>
+  <button id="btn_labelledby_mixed_hidden_child"
+          aria-labelledby="labelledby_mixed_hidden_child">3.1</button>
+  <br/>
+
+  <!-- the name from subtree, mixed/completely hidden content -->
+  <span id="labelledby_mixed_hidden"
+        style="display: none;">lala <span>more hidden </span>text</span></span>
+  <button id="btn_labelledby_mixed_hidden"
+          aria-labelledby="labelledby_mixed_hidden">3.2</button>
   <br/>
 
   <!-- the name from subtree, mixed content, block structure -->
   <div id="labelledby_mixed_block"><div>text</div>more text</div></div>
   <button id="btn_labelledby_mixed_block"
@@ -226,9 +257,17 @@
   <button id="btn_label_indocument">13</button>
 
   <!-- name from children -->
   <span id="btn_children" role="button">14</span>
 
+  <!-- name from children, hidden children -->
+  <div role="listbox" tabindex="0">
+    <div id="lb_opt1_children_hidden" role="option" tabindex="0">
+      <span>i am visible</span>
+      <span style="display:none">i am hidden</span>
+    </div>
+  </div>
+
   <!-- name from title attribute -->
   <span id="btn_title" role="group" title="title">15</span>
 </body>
 </html>
diff -r 6c8c95fcaf9b accessible/tests/mochitest/test_nsIAccessible_name.xul
--- a/accessible/tests/mochitest/test_nsIAccessible_name.xul	Tue Jul 15 15:16:43 2008 +1200
+++ b/accessible/tests/mochitest/test_nsIAccessible_name.xul	Thu Jul 17 14:13:03 2008 +0300
@@ -70,10 +70,18 @@
       // Gets the name from text nodes and selected item of menulist
       // (other items are ignored).
       testName("btn_labelledby_mixed_menulist",
                "nomore text selected item more text");
       
+      // Gets the name from text nodes contained by nested elements, ignores
+      // hidden elements (bug 443081).
+      testName("btn_labelledby_mixed_hidden_child", "nomore text2");
+
+      // Gets the name from hidden text nodes contained by nested elements, 
+      // (label element is hidden entirely), (bug 443081)
+      testName("btn_labelledby_mixed_hidden", "lala more hidden text");
+
 
       //////////////////////////////////////////////////////////////////////////
       // Name for nsIDOMXULLabeledControlElement.
 
       // Gets the name from @label attribute.
@@ -137,10 +145,11 @@
 
       //////////////////////////////////////////////////////////////////////////
       // tooltiptext (if nothing above isn't presented then tooltiptext is used)
       testName("box_tooltiptext", "tooltiptext label");
 
+
       //////////////////////////////////////////////////////////////////////////
       // Name from the @title attribute of <toolbaritem/> (original bug 237249).
 
       // Direct child of toolbaritem.
       var textboxAcc = testName("toolbaritem_textbox", "ooospspss");
@@ -160,10 +169,14 @@
       // Name from children
 
       // ARIA role button is presented allowing the name calculation from
       // children.
       testName("box_children", "14");
+
+      // ARIA role option is presented allowing the name calculation from
+      // the visible children (bug 443081)
+      testName("lb_opt1_children_hidden", "i am visible");
 
 
       SimpleTest.finish();
     }
 
@@ -200,10 +213,22 @@
   <description id="labelledby_mixed">
     no<description>more text</description>
   </description>
   <button id="btn_labelledby_mixed"
           aria-labelledby="labelledby_mixed"/>
+
+  <!-- the name from subtree, mixed/hidden content -->
+  <description id="labelledby_mixed_hidden_child">no<description>more <description hidden="true">hidden</description>text2</description></description>
+  <button id="btn_labelledby_mixed_hidden_child"
+          aria-labelledby="labelledby_mixed_hidden_child"/>
+
+  <!-- the name from subtree, mixed/completely hidden content -->
+  <description id="labelledby_mixed_hidden"
+               hidden="true">lala <description>more hidden </description>text</description>
+  <button id="btn_labelledby_mixed_hidden"
+          aria-labelledby="labelledby_mixed_hidden"/>
+  <br/>
 
   <!-- the name from subtree, mixed content, ignore items of menulist -->
   <description id="labelledby_mixed_menulist">
     no<description>more text</description>
     <menulist>
@@ -279,7 +304,15 @@
   </toolbar>
 
   <!-- name from children -->
   <box id="box_children" role="button">14</box>
 
+  <!-- name from children, hidden children -->
+  <vbox role="listbox" tabindex="0">
+    <hbox id="lb_opt1_children_hidden" role="option" tabindex="0">
+      <description>i am visible</description>
+      <description style="display:none">i am hidden</description>
+    </hbox>
+  </vbox>
+
 </window>
 
diff -r 6c8c95fcaf9b browser/app/profile/firefox.js
--- a/browser/app/profile/firefox.js	Tue Jul 15 15:16:43 2008 +1200
+++ b/browser/app/profile/firefox.js	Thu Jul 17 14:13:03 2008 +0300
@@ -325,10 +325,13 @@ pref("browser.tabs.closeButtons", 1);
 // closed:
 // true   return to the tab that opened this tab (its owner)
 // false  return to the adjacent tab (old default)
 pref("browser.tabs.selectOwnerOnClose", true);
 
+pref("browser.ctrlTab.previewsCount", 3);
+pref("browser.ctrlTab.smoothScroll", true);
+
 // Default bookmark sorting
 pref("browser.bookmarks.sort.direction", "descending");
 pref("browser.bookmarks.sort.resource", "rdf:http://home.netscape.com/NC-rdf#Name");
 
 // By default, do not export HTML at shutdown.
diff -r 6c8c95fcaf9b browser/base/content/browser-tabPreviews.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/base/content/browser-tabPreviews.js	Thu Jul 17 14:13:03 2008 +0300
@@ -0,0 +1,518 @@
+/*
+#ifdef 0
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Tab Previews.
+ *
+ * The Initial Developer of the Original Code is Mozilla.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Dão Gottwald <dao@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK *****
+#endif
+ */
+
+/**
+ * Tab previews utility, produces thumbnails
+ */
+var tabPreviews = {
+  aspectRatio: 0.6875, // 16:11
+  init: function () {
+    this.width = Math.ceil(screen.availWidth / 7.5);
+    this.height = Math.round(this.width * this.aspectRatio);
+
+    gBrowser.tabContainer.addEventListener("TabSelect", this, false);
+    gBrowser.tabContainer.addEventListener("SSTabRestored", this, false);
+  },
+  uninit: function () {
+    gBrowser.tabContainer.removeEventListener("TabSelect", this, false);
+    gBrowser.tabContainer.removeEventListener("SSTabRestored", this, false);
+    this._selectedTab = null;
+  },
+  get: function (aTab) {
+    return aTab.__thumbnail || this.capture(aTab, !aTab.hasAttribute("busy"));
+  },
+  capture: function (aTab, aStore) {
+    var win = aTab.linkedBrowser.contentWindow;
+    var thumbnail = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
+    thumbnail.mozOpaque = true;
+    thumbnail.height = this.height;
+    thumbnail.width = this.width;
+    var ctx = thumbnail.getContext("2d");
+    var widthScale = this.width / win.innerWidth;
+    ctx.scale(widthScale, widthScale);
+    ctx.drawWindow(win, win.scrollX, win.scrollY,
+                   win.innerWidth, win.innerWidth * this.aspectRatio, "rgb(255,255,255)");
+    var data = thumbnail.toDataURL("image/jpeg", "quality=60");
+    if (aStore)
+      aTab.__thumbnail = data;
+    return data;
+  },
+  handleEvent: function (event) {
+    switch (event.type) {
+      case "TabSelect":
+        if (this._selectedTab &&
+            this._selectedTab.parentNode &&
+            !this._pendingUpdate) {
+          // Generate a thumbnail for the tab that was selected.
+          // The timeout keeps the UI snappy and prevents us from generating thumbnails
+          // for tabs that will be closed. During that timeout, don't generate other
+          // thumbnails in case multiple TabSelect events occur fast in succession.
+          this._pendingUpdate = true;
+          setTimeout(function (self, aTab) {
+            self._pendingUpdate = false;
+            if (aTab.parentNode && !aTab.hasAttribute("busy"))
+              self.capture(aTab, true);
+          }, 2000, this, this._selectedTab);
+        }
+        this._selectedTab = event.target;
+        break;
+      case "SSTabRestored":
+        this.capture(event.target, true);
+        break;
+    }
+  }
+};
+
+/**
+ * Ctrl-Tab panel
+ */
+var ctrlTab = {
+  tabs: [],
+  _uniqid: 0,
+  get panel () {
+    delete this.panel;
+    return this.panel = document.getElementById("ctrlTab-panel");
+  },
+  get label () {
+    delete this.label;
+    return this.label = document.getElementById("ctrlTab-label");
+  },
+  get svgRoot () {
+    delete this.svgRoot;
+
+    let (groundFade = document.getElementById("ctrlTab-groundFade")) {
+      groundFade.setAttribute("height", Math.ceil(tabPreviews.height * .25) + 1);
+      groundFade.setAttribute("y", tabPreviews.height + 1);
+    }
+
+    this.svgRoot = document.getElementById("ctrlTab-svgRoot");
+    this.svgRoot.setAttribute("height", tabPreviews.height * 1.25 + 2);
+    return this.svgRoot;
+  },
+  get container () {
+    delete this.container;
+    return this.container = document.getElementById("ctrlTab-container");
+  },
+  get rtl () {
+    delete this.rtl;
+    return this.rtl = getComputedStyle(this.panel, "").direction == "rtl";
+  },
+  get iconSize () {
+    delete this.iconSize;
+    return this.iconSize = Math.round(tabPreviews.height / 4);
+  },
+  get smoothScroll () {
+    delete this.smoothScroll;
+    return this.smoothScroll = gPrefService.getBoolPref("browser.ctrlTab.smoothScroll");
+  },
+  get previewsCount () {
+    delete this.previewsCount;
+    return this.previewsCount = Math.max(gPrefService.getIntPref("browser.ctrlTab.previewsCount"), 3);
+  },
+  get visibleCount () {
+    return Math.min(this.previewsCount, this.tabs.length);
+  },
+  get offscreenStart () {
+    return Array.indexOf(this.container.childNodes, this.selected) - 1;
+  },
+  get offscreenEnd () {
+    return this.container.childNodes.length - this.visibleCount - this.offscreenStart;
+  },
+  get offsetX () {
+    return - tabPreviews.width * (this.rtl ? this.offscreenEnd : this.offscreenStart);
+  },
+  init: function () {
+    var tabContainer = gBrowser.tabContainer;
+
+    Array.forEach(tabContainer.childNodes, function (tab) {
+      this.attachTab(tab, tab == gBrowser.selectedTab);
+    }, this);
+
+    tabContainer.addEventListener("TabOpen", this, false);
+    tabContainer.addEventListener("TabSelect", this, false);
+    tabContainer.addEventListener("TabClose", this, false);
+
+    gBrowser.mTabBox.handleCtrlTab = false;
+    window.addEventListener("keydown", this, true);
+  },
+  uninit: function () {
+    var tabContainer = gBrowser.tabContainer;
+    tabContainer.removeEventListener("TabOpen", this, false);
+    tabContainer.removeEventListener("TabSelect", this, false);
+    tabContainer.removeEventListener("TabClose", this, false);
+
+    this.panel.removeEventListener("popuphiding", this, false);
+    window.removeEventListener("keydown", this, true);
+  },
+  addBox: function (aAtStart) {
+    const SVGNS = "http://www.w3.org/2000/svg";
+
+    var thumbnail = document.createElementNS(SVGNS, "image");
+    thumbnail.setAttribute("class", "ctrlTab-thumbnail");
+    thumbnail.setAttribute("height", tabPreviews.height);
+    thumbnail.setAttribute("width", tabPreviews.width);
+
+    var thumbnail_border = document.createElementNS(SVGNS, "rect");
+    thumbnail_border.setAttribute("class", "ctrlTab-thumbnailborder");
+    thumbnail_border.setAttribute("height", tabPreviews.height);
+    thumbnail_border.setAttribute("width", tabPreviews.width);
+
+    var icon = document.createElementNS(SVGNS, "image");
+    icon.setAttribute("class", "ctrlTab-icon");
+    icon.setAttribute("height", this.iconSize);
+    icon.setAttribute("width", this.iconSize);
+    icon.setAttribute("transform", "skewY(10)");
+    icon.setAttribute("x", - this.iconSize / 3);
+    icon.setAttribute("y", tabPreviews.height * .9 - this.iconSize);
+
+    var thumbnail_and_icon = document.createElementNS(SVGNS, "g");
+    thumbnail_and_icon.appendChild(thumbnail);
+    thumbnail_and_icon.appendChild(thumbnail_border);
+    thumbnail_and_icon.appendChild(icon);
+
+    var reflection = document.createElementNS(SVGNS, "use");
+    reflection.setAttribute("class", "ctrlTab-reflection");
+    var ref_scale = .5;
+    reflection.setAttribute("transform", "scale(1,-" + ref_scale + ")");
+    reflection.setAttribute("y", - ((1 / ref_scale + 1) * tabPreviews.height +
+                                    (1 / ref_scale) * 2));
+
+    var box = document.createElementNS(SVGNS, "g");
+    box.setAttribute("class", "ctrlTab-box");
+    box.appendChild(thumbnail_and_icon);
+    box.appendChild(reflection);
+
+    if (aAtStart)
+      this.container.insertBefore(box, this.container.firstChild);
+    else
+      this.container.appendChild(box);
+    return box;
+  },
+  removeBox: function (aBox) {
+    this.container.removeChild(aBox);
+    if (!Array.some(this.container.childNodes, function (box) box._tab == aBox._tab))
+      aBox._tab.removeEventListener("DOMAttrModified", this, false);
+    aBox._tab = null;
+  },
+  addPreview: function (aBox, aTab) {
+    const XLinkNS = "http://www.w3.org/1999/xlink";
+
+    aBox._tab = aTab;
+    let (thumbnail = aBox.firstChild.firstChild)
+      thumbnail.setAttributeNS(XLinkNS, "href", tabPreviews.get(aTab));
+    this.updateIcon(aBox);
+
+    aTab.addEventListener("DOMAttrModified", this, false);
+
+    if (!aBox.firstChild.hasAttribute("id")) {
+      // set up reflection
+      this._uniqid++;
+      aBox.firstChild.setAttribute("id", "ctrlTab-preview-" + this._uniqid);
+      aBox.lastChild.setAttributeNS(XLinkNS, "href", "#ctrlTab-preview-" + this._uniqid);
+    }
+  },
+  updateIcon: function (aBox) {
+    const XLinkNS = "http://www.w3.org/1999/xlink";
+    var url = aBox._tab.hasAttribute("busy") ?
+              "chrome://global/skin/icons/loading_16.png" :
+              aBox._tab.getAttribute("image");
+    var icon = aBox.firstChild.lastChild;
+    if (url)
+      icon.setAttributeNS(XLinkNS, "href", url);
+    else
+      icon.removeAttributeNS(XLinkNS, "href");
+  },
+  tabAttrModified: function (aTab, aAttrName) {
+    switch (aAttrName) {
+      case "busy":
+      case "image":
+        Array.forEach(this.container.childNodes, function (box) {
+          if (box._tab == aTab) {
+            if (aAttrName == "busy")
+              this.addPreview(box, aTab);
+            else
+              this.updateIcon(box);
+          }
+        }, this);
+        break;
+      case "label":
+      case "crop":
+        if (!this._scrollTimer) {
+          let boxes = this.container.childNodes;
+          for (let i = boxes.length - 1; i >= 0; i--) {
+            if (boxes[i]._tab == aTab && boxes[i] == this.selected) {
+              this.label[aAttrName == "label" ? "value" : aAttrName] =
+                aTab.getAttribute(aAttrName);
+              break;
+            }
+          }
+        }
+        break;
+    }
+  },
+  scroll: function () {
+    if (!this.smoothScroll) {
+      this._move = true;
+      this.stopScroll();
+      return;
+    }
+
+    this.stopScroll();
+    this._move = true;
+    let (next = this.invertDirection ? this.selected.previousSibling : this.selected.nextSibling) {
+      this.setStatusbarValue(next);
+      this.label.value = next._tab.label;
+      this.label.crop = next._tab.crop;
+    }
+
+    const FRAME_LENGTH = 40;
+    var x = this.offsetX;
+    var scrollAmounts = let (tenth = tabPreviews.width / (this.invertDirection == this.rtl ? -10 : 10))
+                        [3 * tenth, 4 * tenth, 2 * tenth, tenth];
+
+    function processFrame(self, lateness) {
+      lateness += FRAME_LENGTH / 2;
+      do {
+        x += scrollAmounts.shift();
+        lateness -= FRAME_LENGTH;
+      } while (lateness > 0 && scrollAmounts.length);
+      self.container.setAttribute("transform", "translate("+ x +",0)");
+      self.svgRoot.forceRedraw();
+      if (!scrollAmounts.length)
+        self.stopScroll();
+    }
+
+    this._scrollTimer = setInterval(processFrame, FRAME_LENGTH, this);
+    processFrame(this, 0);
+  },
+  stopScroll: function () {
+    if (this._scrollTimer) {
+      clearInterval(this._scrollTimer);
+      this._scrollTimer = 0;
+    }
+    if (this._move)
+      this.updateSelected();
+  },
+  updateSelected: function (aClosing) {
+    var index = 1;
+    if (this._move) {
+      this._move = false;
+      index += this.invertDirection ? -1 : 1;
+    }
+    if (this.selected) {
+      index += this.offscreenStart + this.tabs.length;
+      index %= this.tabs.length;
+      if (index < 2)
+        index += this.tabs.length;
+      if (index > this.container.childNodes.length - this.visibleCount + 1)
+        index -= this.tabs.length;
+    }
+    this.selected = this.container.childNodes[index];
+
+    if (aClosing)
+      return;
+
+    this.addOffscreenBox(this.invertDirection);
+    this.addOffscreenBox(!this.invertDirection);
+
+    // having lots of off-screen boxes reduce the scrolling speed, remove some
+    for (let i = this.offscreenStart; i > 1; i--)
+      this.removeBox(this.container.firstChild);
+    for (let i = this.offscreenEnd; i > 1; i--)
+      this.removeBox(this.container.lastChild);
+
+    this.container.setAttribute("transform", "translate("+ this.offsetX +", 0)");
+
+    for (let i = 0, l = this.container.childNodes.length; i < l; i++)
+      this.arrange(i);
+  },
+  addOffscreenBox: function (aAtStart) {
+    if (this.container.childNodes.length < this.tabs.length + this.visibleCount + 1 &&
+        !(aAtStart ? this.offscreenStart : this.offscreenEnd)) {
+      let i = aAtStart ?
+              this.tabs.indexOf(this.container.firstChild._tab) - 1:
+              this.tabs.indexOf(this.container.lastChild._tab) + 1;
+      i = (i + this.tabs.length) % this.tabs.length;
+      this.addPreview(this.addBox(aAtStart), this.tabs[i]);
+    }
+  },
+  arrange: function (aIndex) {
+    var box = this.container.childNodes[aIndex];
+    var selected = box == this.selected;
+    if (selected) {
+      box.setAttribute("selected", "true");
+      this.setStatusbarValue(box);
+      this.label.value = box._tab.label;
+      this.label.crop = box._tab.crop;
+    } else {
+      box.removeAttribute("selected");
+    }
+    var scale = selected ? 1 : .75;
+    var pos = this.rtl ? this.container.childNodes.length - 1 - aIndex : aIndex;
+    var trans_x = tabPreviews.width * (pos + (1 - scale) / 2) / scale;
+    var trans_y = (tabPreviews.height + 1) * (1 / scale - 1);
+    box.setAttribute("transform", "scale(" + scale + "," + scale + ") " +
+                                  "translate("+ trans_x + "," + trans_y + ")");
+  },
+  setStatusbarValue: function (aBox) {
+    var value = "";
+    if (aBox) {
+      value = aBox._tab.linkedBrowser.currentURI.spec;
+      if (value == "about:blank") {
+        // XXXhack: Passing a space here (and not "")
+        // to make sure the browser implementation would
+        // still consider it a hovered link.
+        value = " ";
+      } else {
+        try {
+          value = decodeURI(value);
+        } catch (e) {}
+      }
+    }
+    XULBrowserWindow.setOverLink(value, null);
+  },
+  attachTab: function (aTab, aSelected) {
+    if (aSelected)
+      this.tabs.unshift(aTab);
+    else
+      this.tabs.push(aTab);
+  },
+  detachTab: function (aTab) {
+    var i = this.tabs.indexOf(aTab);
+    if (i >= 0)
+      this.tabs.splice(i, 1);
+  },
+  open: function () {
+    window.addEventListener("keyup", this, true);
+    window.addEventListener("keypress", this, true);
+    this.panel.addEventListener("popuphiding", this, false);
+    this.panel.hidden = false;
+    this.panel.width = tabPreviews.width * this.visibleCount;
+    this.panel.openPopupAtScreen(screen.availLeft + (screen.availWidth - this.panel.width) / 2,
+                                 screen.availTop + (screen.availHeight - this.svgRoot.getAttribute("height")) / 2,
+                                 false);
+
+    for (let index = this.invertDirection ? this.tabs.length - 2 : 0,
+             i = this.visibleCount; i > 0; i--)
+      this.addPreview(this.addBox(), this.tabs[index++ % this.tabs.length]);
+    this.updateSelected();
+  },
+  onKeyDown: function (event) {
+    var isOpen = this.panel.state == "open" || this.panel.state == "showing";
+    var propagate = !isOpen;
+    switch (event.keyCode) {
+      case event.DOM_VK_TAB:
+        if (event.ctrlKey && !event.altKey && !event.metaKey && this.tabs.length > 1) {
+          propagate = false;
+          this.invertDirection = event.shiftKey;
+          if (isOpen)
+            this.scroll();
+          else if (this.tabs.length == 2)
+            gBrowser.selectedTab = this.tabs[1];
+          else
+            this.open();
+        }
+        break;
+      case event.DOM_VK_ESCAPE:
+        if (isOpen)
+          this.panel.hidePopup();
+        break;
+    }
+    if (!propagate) {
+      event.stopPropagation();
+      event.preventDefault();
+    }
+  },
+  onKeyUp: function (event) {
+    if (event.keyCode == event.DOM_VK_CONTROL) {
+      if (this._move)
+        this.updateSelected(true);
+      let selectedTab = this.selected._tab;
+      this.panel.hidePopup();
+      gBrowser.selectedTab = selectedTab;
+    }
+  },
+  onPopupHiding: function () {
+    this.stopScroll();
+    window.removeEventListener("keyup", this, true);
+    window.removeEventListener("keypress", this, true);
+    while (this.container.childNodes.length)
+      this.removeBox(this.container.lastChild);
+    this.selected = null;
+    this.invertDirection = false;
+    this._move = false;
+    this._uniqid = 0;
+    this.label.value = "";
+    this.setStatusbarValue();
+    this.container.removeAttribute("transform");
+    this.svgRoot.forceRedraw();
+  },
+  handleEvent: function (event) {
+    switch (event.type) {
+      case "DOMAttrModified":
+        this.tabAttrModified(event.target, event.attrName);
+        break;
+      case "TabSelect":
+        this.detachTab(event.target);
+        this.attachTab(event.target, true);
+        break;
+      case "TabOpen":
+        this.attachTab(event.target);
+        break;
+      case "TabClose":
+        this.detachTab(event.target);
+        break;
+      case "keydown":
+        this.onKeyDown(event);
+        break;
+      case "keyup":
+      case "keypress":
+        // the panel is open; don't propagate any key events
+        event.stopPropagation();
+        event.preventDefault();
+      case "keyup":
+        this.onKeyUp(event);
+        break;
+      case "popuphiding":
+        this.onPopupHiding();
+        break;
+    }
+  }
+};
diff -r 6c8c95fcaf9b browser/base/content/browser.css
--- a/browser/base/content/browser.css	Tue Jul 15 15:16:43 2008 +1200
+++ b/browser/base/content/browser.css	Thu Jul 17 14:13:03 2008 +0300
@@ -1,5 +1,9 @@ searchbar {
+@namespace url("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul");
+@namespace svg url("http://www.w3.org/2000/svg");
+@namespace xlink url("http://www.w3.org/1999/xlink");
+
 searchbar {
   -moz-binding: url("chrome://browser/content/search/search.xml#searchbar");
 }
 
 tabbrowser {
@@ -80,5 +84,19 @@ window[chromehidden~="toolbar"] toolbar:
 }
 
 #navigator-toolbox[inFullscreen="true"] #fullscr-toggler {
   display: -moz-box;
 }
+
+/* Tab Previews */
+svg|*.ctrlTab-icon:not([xlink|href]) ,
+svg|*.ctrlTab-thumbnail:not([xlink|href]) {
+  display: none;
+}
+
+svg|*.ctrlTab-thumbnailborder {
+  fill: transparent;
+}
+
+svg|*.ctrlTab-icon {
+  filter: url(chrome://browser/content/browser.xul#ctrlTab-iconShadow);
+}
diff -r 6c8c95fcaf9b browser/base/content/browser.js
--- a/browser/base/content/browser.js	Tue Jul 15 15:16:43 2008 +1200
+++ b/browser/base/content/browser.js	Thu Jul 17 14:13:03 2008 +0300
@@ -1072,10 +1072,13 @@ function delayedStartup()
   // pages.  This lets us fix bugs like 401575 which require error page UI to
   // do privileged things, without letting error pages have any privilege
   // themselves.
   gBrowser.addEventListener("command", BrowserOnCommand, false);
 
+  tabPreviews.init();
+  ctrlTab.init();
+
   // Delayed initialization of the livemarks update timer.
   // Livemark updates don't need to start until after bookmark UI 
   // such as the toolbar has initialized. Starting 5 seconds after
   // delayedStartup in order to stagger this before the download
   // manager starts (see below).
@@ -1102,10 +1105,13 @@ function delayedStartup()
 #endif
 }
 
 function BrowserShutdown()
 {
+  tabPreviews.uninit();
+  ctrlTab.uninit();
+
   try {
     FullZoom.destroy();
   }
   catch(ex) {
     Components.utils.reportError(ex);
@@ -6137,10 +6143,12 @@ var FeedHandler = {
 
 #include browser-places.js
 
 #include browser-textZoom.js
 
+#include browser-tabPreviews.js
+
 HistoryMenu.toggleRecentlyClosedTabs = function PHM_toggleRecentlyClosedTabs() {
   // enable/disable the Recently Closed Tabs sub menu
   var undoPopup = document.getElementById("historyUndoPopup");
 
   // get closed-tabs from nsSessionStore
diff -r 6c8c95fcaf9b browser/base/content/browser.xul
--- a/browser/base/content/browser.xul	Tue Jul 15 15:16:43 2008 +1200
+++ b/browser/base/content/browser.xul	Thu Jul 17 14:13:03 2008 +0300
@@ -27,10 +27,11 @@
 #   David Hyatt <hyatt@mozilla.org>
 #   Joe Hewitt <hewitt@netscape.com>
 #   Pierre Chanial <chanial@noos.fr>
 #   Dean Tessman <dean_tessman@hotmail.com>
 #   Johnathan Nightingale <johnath@mozilla.com>
+#   Dão Gottwald <dao@mozilla.com>
 #
 # Alternatively, the contents of this file may be used under the terms of
 # either the GNU General Public License Version 2 or later (the "GPL"), or
 # the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 # in which case the provisions of the GPL or the LGPL are applicable instead
@@ -59,10 +60,11 @@
 # hiddenWindow.xul.
 #include browser-doctype.inc
 
 <window id="main-window"
         xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+        xmlns:svg="http://www.w3.org/2000/svg"
         xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
         onload="BrowserStartup()" onunload="BrowserShutdown()" onclose="return WindowIsClosing();"
         contenttitlesetting="true"
         title="&mainWindow.title;"
         titlemodifier="&mainWindow.title;"
@@ -225,10 +227,33 @@
     </panel>
 
     <tooltip id="urlTooltip">
       <label crop="center" flex="1"/>
     </tooltip>
+
+    <panel id="ctrlTab-panel" class="KUI-panel" hidden="true">
+      <label id="ctrlTab-label" flex="1"/>
+      <svg:svg id="ctrlTab-svgRoot">
+        <svg:defs>
+          <svg:linearGradient id="ctrlTab-fadeGradient" x1="1" y1="1" x2="1" y2="0">
+            <svg:stop id="ctrlTab-fadeGradientBottom" offset="0"/>
+            <svg:stop id="ctrlTab-fadeGradientTop" offset="1"/>
+          </svg:linearGradient>
+          <svg:filter id="ctrlTab-iconShadow">
+            <svg:feOffset result="shadow" in="SourceAlpha" dx="2" dy="-1"/>
+            <svg:feColorMatrix result="transparent-shadow" in="shadow"
+                               values="1 0 0 0   0
+                                       0 1 0 0   0
+                                       0 0 1 0   0
+                                       0 0 0 0.5 0"/>
+            <svg:feBlend in="SourceGraphic" in2="transparent-shadow"/>
+          </svg:filter>
+        </svg:defs>
+        <svg:g id="ctrlTab-container"/>
+        <svg:rect id="ctrlTab-groundFade" fill="url(#ctrlTab-fadeGradient)" width="100%"/>
+      </svg:svg>
+    </panel>
   </popupset>
 
   <!-- bookmarks toolbar tooltip -->
   <tooltip id="btTooltip" noautohide="true"
            onpopupshowing="return BookmarksEventHandler.fillInBTTooltip(document.tooltipNode)">
diff -r 6c8c95fcaf9b browser/components/nsBrowserGlue.js
--- a/browser/components/nsBrowserGlue.js	Tue Jul 15 15:16:43 2008 +1200
+++ b/browser/components/nsBrowserGlue.js	Thu Jul 17 14:13:03 2008 +0300
@@ -562,17 +562,33 @@ BrowserGlue.prototype = {
       // grab the localstore.rdf and make changes needed for new UI
       this._rdf = Cc["@mozilla.org/rdf/rdf-service;1"].getService(Ci.nsIRDFService);
       this._dataSource = this._rdf.GetDataSource("rdf:local-store");
       this._dirty = false;
 
-      var currentSet = this._rdf.GetResource("currentset");
-
-      // get an nsIRDFResource for the nav-bar item
-      var navBar = this._rdf.GetResource("chrome://browser/content/browser.xul#nav-bar");
-      var target = this._getPersist(navBar, currentSet);
-      if (target && !/(?:^|,)unified-back-forward-button(?:$|,)/.test(target))
-        this._setPersist(navBar, currentSet, "unified-back-forward-button," + target);
+      let currentsetResource = this._rdf.GetResource("currentset");
+      let toolbars = ["nav-bar", "toolbar-menubar", "PersonalToolbar"];
+      for (let i = 0; i < toolbars.length; i++) {
+        let toolbar = this._rdf.GetResource("chrome://browser/content/browser.xul#" + toolbars[i]);
+        let currentset = this._getPersist(toolbar, currentsetResource);
+        if (!currentset) {
+          // toolbar isn't customized
+          if (i == 0)
+            // new button is in the defaultset, nothing to migrate
+            break;
+          continue;
+        }
+        if (/(?:^|,)unified-back-forward-button(?:$|,)/.test(currentset))
+          // new button is already there, nothing to migrate
+          break;
+        if (/(?:^|,)back-button(?:$|,)/.test(currentset)) {
+          let newset = currentset.replace(/(^|,)back-button($|,)/,
+                                          "$1unified-back-forward-button,back-button$2")
+          this._setPersist(toolbar, currentsetResource, newset);
+          // done migrating
+          break;
+        }
+      }
 
       // force the RDF to be saved
       if (this._dirty)
         this._dataSource.QueryInterface(Ci.nsIRDFRemoteDataSource).Flush();
 
diff -r 6c8c95fcaf9b browser/components/places/tests/Makefile.in
--- a/browser/components/places/tests/Makefile.in	Tue Jul 15 15:16:43 2008 +1200
+++ b/browser/components/places/tests/Makefile.in	Thu Jul 17 14:13:03 2008 +0300
@@ -47,8 +47,9 @@ MODULE		= test_browser_places
 
 XPCSHELL_TESTS = unit
 
 ifdef MOZ_MOCHITEST
 	DIRS += browser
+	DIRS += perf
 endif
 
 include $(topsrcdir)/config/rules.mk
diff -r 6c8c95fcaf9b browser/components/places/tests/perf/Makefile.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/components/places/tests/perf/Makefile.in	Thu Jul 17 14:13:03 2008 +0300
@@ -0,0 +1,52 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+# Mozilla Corporation.
+# Portions created by the Initial Developer are Copyright (C) 2008
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#  	Shawn Wilsher <me@shawnwilsher.com> (Original Author)
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH          = ../../../../..
+topsrcdir      = @top_srcdir@
+srcdir         = @srcdir@
+VPATH          = @srcdir@
+relativesrcdir = browser/components/places/tests/perf
+
+include $(DEPTH)/config/autoconf.mk
+include $(topsrcdir)/config/rules.mk
+
+_CHROME_FILES = \
+  perf_large_delete.xul \
+  $(NULL)
+
+libs:: $(_CHROME_FILES)
+	$(INSTALL) $(foreach f,$^,"$f") $(DEPTH)/_tests/testing/mochitest/chrome/$(relativesrcdir)
diff -r 6c8c95fcaf9b browser/components/places/tests/perf/perf_large_delete.xul
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/components/places/tests/perf/perf_large_delete.xul	Thu Jul 17 14:13:03 2008 +0300
@@ -0,0 +1,169 @@
+<?xml version="1.0"?>
+<!--
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Shawn Wilsher <me@shawnwilsher.com> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/**
+ * This tests that the performance of deleting a large number of bookmarks.  See
+ * bug 432706 for more details.
+ *
+ * To run this test, run it like you would a standard chrome test, with the test
+ * path being:
+ * ../chrome/browser/components/places/tests/perf/perf_large_delete.xul
+ */
+-->
+
+<window title="Places Library Performance Test"
+        xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
+        onload="test();">
+
+  <script type="application/javascript"
+          src="chrome://mochikit/content/MochiKit/packed.js"/>
+  <script type="application/javascript"
+          src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"/>
+  <script type="application/javascript"
+          src="chrome://mochikit/content/tests/SimpleTest/EventUtils.js"/>
+
+  <script type="application/javascript">
+  <![CDATA[
+
+const Cc = Components.classes;
+const Ci = Components.interfaces;
+const Cr = Components.results;
+
+function test()
+{
+  let ios = Cc["@mozilla.org/network/io-service;1"].
+            getService(Ci.nsIIOService);
+
+  // First, add 250 bookmarks
+  let bs = Cc["@mozilla.org/browser/nav-bookmarks-service;1"].
+           getService(Ci.nsINavBookmarksService);
+  bs.runInBatchMode({
+    runBatched: function(aUserData)
+    {
+      for (let i = 0; i < 250; i++) {
+        let uri = ios.newURI("http://example.com/" + i, null, null);
+        bs.insertBookmark(bs.unfiledBookmarksFolder, uri, bs.DEFAULT_INDEX,
+                          "bookmark " + i);
+      }
+    }
+  }, null);
+
+  // Close the window if it's already open
+  let wm = Cc["@mozilla.org/appshell/window-mediator;1"].
+           getService(Ci.nsIWindowMediator);
+  let win = wm.getMostRecentWindow("Places:Orgainzier");
+  if (win)
+    win.close();
+
+
+  let ww = Cc["@mozilla.org/embedcomp/window-watcher;1"].
+           getService(Ci.nsIWindowWatcher);
+  ww.registerNotification({
+    observe: function(aSubject, aTopic, aData)
+    {
+      if (aTopic != "domwindowopened")
+        return;
+
+      let win = aSubject.QueryInterface(Ci.nsIDOMEventTarget);
+
+      // We need to run after the window is loaded, and has run its startup code
+      win.addEventListener("DOMContentLoaded", function() {
+        let tm = Cc["@mozilla.org/thread-manager;1"].
+                 getService(Ci.nsIThreadManager);
+        tm.mainThread.dispatch({
+          run: function() doTest(win.QueryInterface(Ci.nsIDOMWindow))
+        }, Ci.nsIThread.DISPATCH_NORMAL);
+      }, false);
+
+      // and now to unregister ourself as a listener
+      ww.unregisterNotification(this);
+    }
+  });
+
+  function doTest(aWin)
+  {
+    // Select all the bookmarks
+    synthesizeKey("a", {accelKey:true}, aWin);
+
+    // If we can, start shark
+    try {
+      connectShark();
+      startShark();
+    }
+    catch (e) { }
+
+    // Delete the bookmarks
+    let start = Date.now();
+    synthesizeKey("VK_BACK_SPACE", {}, aWin);
+    let end = Date.now();
+
+    // Stop shark, if we can
+    try {
+      stopShark();
+      disconnectionShark();
+    }
+    catch (e) { }
+
+    // Close the window, and write the results out
+    aWin.close();
+    document.getElementById("test-result").value =
+      "Duration was " + String(end - start) + "ms";
+
+    SimpleTest.finish();
+  }
+
+  // And open the window
+  wm.getMostRecentWindow("navigator:browser")
+    .openDialog("chrome://browser/content/places/places.xul",
+                "", "chrome,toolbar=yes,dialog=no,resizable",
+                "UnfiledBookmarks");
+
+  SimpleTest.waitForExplicitFinish();
+}
+
+  ]]>
+  </script>
+
+  <body xmlns="http://www.w3.org/1999/xhtml">
+    <p id="display"></p>
+    <div id="content" style="display:none;"></div>
+    <pre id="test"></pre>
+  </body>
+  <label id="test-result"/>
+</window>
diff -r 6c8c95fcaf9b browser/locales/l10n.ini
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/locales/l10n.ini	Thu Jul 17 14:13:03 2008 +0300
@@ -0,0 +1,16 @@
+[general]
+depth = ../..
+all = browser/locales/all-locales
+
+[compare]
+dirs = browser
+     extensions/reporter
+     other-licenses/branding/firefox
+
+[includes]
+# non-central apps might want to use %(topsrcdir)s here, or other vars
+# RFE: that needs to be supported by compare-locales, too, though
+toolkit = toolkit/locales/l10n.ini
+
+[extras]
+dirs = extensions/spellcheck
diff -r 6c8c95fcaf9b browser/themes/gnomestripe/browser/browser.css
--- a/browser/themes/gnomestripe/browser/browser.css	Tue Jul 15 15:16:43 2008 +1200
+++ b/browser/themes/gnomestripe/browser/browser.css	Thu Jul 17 14:13:03 2008 +0300
@@ -24,11 +24,11 @@
  *   Jason Kersey (kerz@netscape.com)
  *   Pierre Chanial (chanial@noos.fr)
  *   Dean Tessman (dean_tessman@hotmail.com)
  *   Blake Ross (blake@cs.stanford.edu)
  *   Pamela Greene (pamg.bugs@gmail.com)
- *   Dao Gottwald (dao@design-noir.de)
+ *   Dão Gottwald (dao@mozilla.com)
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
@@ -45,10 +45,11 @@
 
 @import url("chrome://global/skin/");
 
 @namespace url("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul");
 @namespace html url("http://www.w3.org/1999/xhtml");
+@namespace svg url("http://www.w3.org/2000/svg");
 
 #menubar-items {
   -moz-box-orient: vertical; /* for flex hack */
 }
 
@@ -1393,5 +1394,28 @@ toolbar[mode="text"] > #window-controls 
 
 #download-monitor {
   list-style-image: url("chrome://browser/skin/Toolbar-small.png");
   -moz-image-region: rect(0px 16px 16px 0px);
 }
+
+/* ::::: Ctrl-Tab Panel ::::: */
+#ctrlTab-label {
+  font-weight: bold;
+  text-align: center;
+  margin-top: .5em;
+  margin-bottom: .7em;
+}
+
+svg|*.ctrlTab-thumbnailborder {
+  stroke: ThreeDDarkShadow;
+  stroke-width: .7px;
+}
+
+svg|*#ctrlTab-fadeGradientTop {
+  stop-color: ThreeDShadow;
+  stop-opacity: .75;
+}
+
+svg|*#ctrlTab-fadeGradientBottom {
+  stop-color: -moz-dialog;
+  stop-opacity: 1;
+}
diff -r 6c8c95fcaf9b browser/themes/pinstripe/browser/browser.css
--- a/browser/themes/pinstripe/browser/browser.css	Tue Jul 15 15:16:43 2008 +1200
+++ b/browser/themes/pinstripe/browser/browser.css	Thu Jul 17 14:13:03 2008 +0300
@@ -22,11 +22,11 @@
  *   Joe Hewitt (hewitt@netscape.com)
  *   Jason Kersey (kerz@netscape.com)
  *   Pierre Chanial (chanial@noos.fr)
  *   Kevin Gerich (kevin@kmgerich.com)
  *   Pamela Greene (pamg.bugs@gmail.com)
- *   Dao Gottwald (dao@design-noir.de)
+ *   Dão Gottwald (dao@mozilla.com)
  *   Stephen Horlander (stephen@noved.org)
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
@@ -43,10 +43,11 @@
 
 @import url("chrome://global/skin/");
 
 @namespace url("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul");
 @namespace html url("http://www.w3.org/1999/xhtml");
+@namespace svg url("http://www.w3.org/2000/svg");
 
 #main-window {
   -moz-binding: url("chrome://global/skin/globalBindings.xml#unifiedWindow");
 }
 
@@ -2260,5 +2261,50 @@ tabpanels.plain {
 }
 
 #download-monitor {
   list-style-image: url("chrome://mozapps/skin/downloads/downloadStatusIcon.png");
 }
+
+/* ::::: Keyboard UI Panel ::::: */
+.KUI-panel {
+  -moz-appearance: none;
+  background: rgba(0, 0, 0, .8);
+  color: white;
+  border: 3px solid #ccc;
+  -moz-border-top-colors: #ccc #ccc black;
+  -moz-border-right-colors: #ccc #ccc black;
+  -moz-border-bottom-colors: #ccc #ccc black;
+  -moz-border-left-colors: #ccc #ccc black;
+  -moz-border-radius: 10px;
+  margin-top: -3px;
+  margin-left: -3px;
+}
+
+/* ::::: Ctrl-Tab Panel ::::: */
+#ctrlTab-panel {
+  margin-top: -18px;
+  border-bottom-width: 5px;
+  -moz-border-bottom-colors: #ccc #ccc black black black;
+}
+
+#ctrlTab-label {
+  font-weight: bold;
+  font-size: 14px;
+  text-align: center;
+  margin-top: 6px;
+  margin-bottom: 10px;
+}
+
+svg|*.ctrlTab-thumbnailborder {
+  stroke: white;
+  stroke-width: 1px;
+}
+
+svg|*#ctrlTab-fadeGradientTop {
+  stop-color: black;
+  stop-opacity: .5;
+}
+
+svg|*#ctrlTab-fadeGradientBottom {
+  stop-color: black;
+  stop-opacity: 1;
+}
diff -r 6c8c95fcaf9b browser/themes/winstripe/browser/browser.css
--- a/browser/themes/winstripe/browser/browser.css	Tue Jul 15 15:16:43 2008 +1200
+++ b/browser/themes/winstripe/browser/browser.css	Thu Jul 17 14:13:03 2008 +0300
@@ -23,11 +23,11 @@
  *   Jason Kersey (kerz@netscape.com)
  *   Pierre Chanial (chanial@noos.fr)
  *   Dean Tessman (dean_tessman@hotmail.com)
  *   Blake Ross (blake@cs.stanford.edu)
  *   Pamela Greene (pamg.bugs@gmail.com)
- *   Dao Gottwald (dao@design-noir.de)
+ *   Dão Gottwald (dao@mozilla.com)
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
@@ -43,10 +43,11 @@
 
 @import url("chrome://global/skin/");
 
 @namespace url("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul");
 @namespace html url("http://www.w3.org/1999/xhtml");
+@namespace svg url("http://www.w3.org/2000/svg");
 
 #menubar-items {
   -moz-box-orient: vertical; /* for flex hack */
 }
 
@@ -2056,5 +2057,50 @@ toolbarbutton.bookmark-item[dragover="tr
 #nav-bar[iconsize="large"][mode="icons"]:not([currentset]):-moz-system-metric(windows-default-theme),
 #nav-bar[iconsize="large"][mode="icons"][currentset$=",urlbar-container"]:-moz-system-metric(windows-default-theme),
 #nav-bar[iconsize="large"][mode="icons"][currentset$=",search-container"]:-moz-system-metric(windows-default-theme) {
   -moz-padding-end: 3px;
 }
+
+/* ::::: Keyboard UI Panel ::::: */
+.KUI-panel {
+  -moz-appearance: none;
+  background: rgba(0, 0, 0, .8);
+  color: white;
+  border: 3px solid #ccc;
+  -moz-border-top-colors: #ccc #ccc black;
+  -moz-border-right-colors: #ccc #ccc black;
+  -moz-border-bottom-colors: #ccc #ccc black;
+  -moz-border-left-colors: #ccc #ccc black;
+  -moz-border-radius: 10px;
+  margin-top: -3px;
+  margin-left: -3px;
+}
+
+/* ::::: Ctrl-Tab Panel ::::: */
+#ctrlTab-panel {
+  margin-top: -18px;
+  border-bottom-width: 5px;
+  -moz-border-bottom-colors: #ccc #ccc black black black;
+}
+
+#ctrlTab-label {
+  font-weight: bold;
+  font-size: 14px;
+  text-align: center;
+  margin-top: 6px;
+  margin-bottom: 10px;
+}
+
+svg|*.ctrlTab-thumbnailborder {
+  stroke: white;
+  stroke-width: 1px;
+}
+
+svg|*#ctrlTab-fadeGradientTop {
+  stop-color: black;
+  stop-opacity: .5;
+}
+
+svg|*#ctrlTab-fadeGradientBottom {
+  stop-color: black;
+  stop-opacity: 1;
+}
diff -r 6c8c95fcaf9b config/rules.mk
--- a/config/rules.mk	Tue Jul 15 15:16:43 2008 +1200
+++ b/config/rules.mk	Thu Jul 17 14:13:03 2008 +0300
@@ -621,11 +621,11 @@ alldep::
 	$(MAKE) tools
 
 endif # TIERS
 endif # SUPPRESS_DEFAULT_RULES
 
-ifneq ($(filter s,$(MAKE_FLAGS)),)
+ifeq ($(filter s,$(MAKEFLAGS)),)
 ECHO := echo
 QUIET :=
 else
 ECHO := true
 QUIET := -q
diff -r 6c8c95fcaf9b content/base/public/nsContentUtils.h
--- a/content/base/public/nsContentUtils.h	Tue Jul 15 15:16:43 2008 +1200
+++ b/content/base/public/nsContentUtils.h	Thu Jul 17 14:13:03 2008 +0300
@@ -1304,10 +1304,19 @@ public:
   static PRUint32 GetRemovableScriptBlockerLevel()
   {
     return sRemovableScriptBlockerCount;
   }
 
+  /* Process viewport META data. This gives us information for the scale
+   * and zoom of a page on mobile devices. We stick the information in
+   * the document header and use it later on after rendering.
+   *
+   * See Bug #436083
+   */
+  static nsresult ProcessViewportInfo(nsIDocument *aDocument,
+                                      const nsAString &viewportInfo);
+
 private:
 
   static PRBool InitializeEventTable();
 
   static nsresult doReparentContentWrapper(nsIContent *aChild,
diff -r 6c8c95fcaf9b content/base/src/nsContentSink.h
--- a/content/base/src/nsContentSink.h	Tue Jul 15 15:16:43 2008 +1200
+++ b/content/base/src/nsContentSink.h	Thu Jul 17 14:13:03 2008 +0300
@@ -125,11 +125,11 @@ class nsContentSink : public nsICSSLoade
 
   // nsICSSLoaderObserver
   NS_IMETHOD StyleSheetLoaded(nsICSSStyleSheet* aSheet, PRBool aWasAlternate,
                               nsresult aStatus);
 
-  nsresult ProcessMETATag(nsIContent* aContent);
+  virtual nsresult ProcessMETATag(nsIContent* aContent);
 
   // nsIContentSink implementation helpers
   NS_HIDDEN_(nsresult) WillInterruptImpl(void);
   NS_HIDDEN_(nsresult) WillResumeImpl(void);
   NS_HIDDEN_(nsresult) DidProcessATokenImpl(void);
diff -r 6c8c95fcaf9b content/base/src/nsContentUtils.cpp
--- a/content/base/src/nsContentUtils.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/content/base/src/nsContentUtils.cpp	Thu Jul 17 14:13:03 2008 +0300
@@ -4218,10 +4218,98 @@ nsContentUtils::AddScriptRunner(nsIRunna
   run->Run();
 
   return PR_TRUE;
 }
 
+/* 
+ * Helper function for nsContentUtils::ProcessViewportInfo.
+ *
+ * Handles a single key=value pair. If it corresponds to a valid viewport
+ * attribute, add it to the document header data. No validation is done on the
+ * value itself (this is done at display time).
+ */
+static void ProcessViewportToken(nsIDocument *aDocument, 
+                                 const nsAString &token) {
+
+  /* Iterators. */
+  nsAString::const_iterator tip, tail, end;
+  token.BeginReading(tip);
+  tail = tip;
+  token.EndReading(end);
+
+  /* Move tip to the '='. */
+  while ((tip != end) && (*tip != '='))
+    ++tip;
+
+  /* If we didn't find an '=', punt. */
+  if (tip == end)
+    return;
+
+  /* Extract the key and value. */
+  const nsAString &key = Substring(tail, tip);
+  const nsAString &value = Substring(++tip, end);
+
+  /* Check for known keys. If we find a match, insert the appropriate
+   * information into the document header. */
+  nsCOMPtr<nsIAtom> key_atom = do_GetAtom(key);
+  if (key_atom == nsGkAtoms::height)
+    aDocument->SetHeaderData(nsGkAtoms::viewport_height, value);
+  else if (key_atom == nsGkAtoms::width)
+    aDocument->SetHeaderData(nsGkAtoms::viewport_width, value);
+  else if (key_atom == nsGkAtoms::initial_scale)
+    aDocument->SetHeaderData(nsGkAtoms::viewport_initial_scale, value);
+  else if (key_atom == nsGkAtoms::minimum_scale)
+    aDocument->SetHeaderData(nsGkAtoms::viewport_minimum_scale, value);
+  else if (key_atom == nsGkAtoms::maximum_scale)
+    aDocument->SetHeaderData(nsGkAtoms::viewport_maximum_scale, value);
+  else if (key_atom == nsGkAtoms::user_scalable)
+    aDocument->SetHeaderData(nsGkAtoms::viewport_user_scalable, value);
+}
+
+#define IS_SEPARATOR(c) ((c == ' ') || (c == ',') || (c == ';'))
+/* static */
+nsresult
+nsContentUtils::ProcessViewportInfo(nsIDocument *aDocument,
+                                    const nsAString &viewportInfo) {
+
+  /* We never fail. */
+  nsresult rv = NS_OK;
+
+  /* Iterators. */
+  nsAString::const_iterator tip, tail, end;
+  viewportInfo.BeginReading(tip);
+  tail = tip;
+  viewportInfo.EndReading(end);
+
+  /* Read the tip to the first non-separator character. */
+  while ((tip != end) && IS_SEPARATOR(*tip))
+    ++tip;
+
+  /* Read through and find tokens seperated by separators. */
+  while (tip != end) {
+    
+    /* Synchronize tip and tail. */
+    tail = tip;
+
+    /* Advance tip past non-separator characters. */
+    while ((tip != end) && !IS_SEPARATOR(*tip))
+      ++tip;
+
+    /* Our token consists of the characters between tail and tip. */
+    ProcessViewportToken(aDocument, Substring(tail, tip));
+
+    /* Skip separators. */
+    while ((tip != end) && IS_SEPARATOR(*tip))
+      ++tip;
+  }
+
+  return rv;
+
+}
+
+#undef IS_SEPARATOR
+
 /* static */
 void
 nsContentUtils::HidePopupsInDocument(nsIDocument* aDocument)
 {
   NS_PRECONDITION(aDocument, "Null document");
diff -r 6c8c95fcaf9b content/base/src/nsGkAtomList.h
--- a/content/base/src/nsGkAtomList.h	Tue Jul 15 15:16:43 2008 +1200
+++ b/content/base/src/nsGkAtomList.h	Thu Jul 17 14:13:03 2008 +0300
@@ -427,10 +427,11 @@ GK_ATOM(infer, "infer")
 GK_ATOM(infer, "infer")
 GK_ATOM(infinity, "infinity")
 GK_ATOM(inherit, "inherit")
 GK_ATOM(inherits, "inherits")
 GK_ATOM(inheritstyle, "inheritstyle")
+GK_ATOM(initial_scale, "initial-scale")
 GK_ATOM(input, "input")
 GK_ATOM(ins, "ins")
 GK_ATOM(insertafter, "insertafter")
 GK_ATOM(insertbefore, "insertbefore")
 GK_ATOM(instanceOf, "instanceOf")
@@ -512,10 +513,11 @@ GK_ATOM(meta, "meta")
 GK_ATOM(meta, "meta")
 GK_ATOM(method, "method")
 GK_ATOM(middle, "middle")
 GK_ATOM(min, "min")
 GK_ATOM(minheight, "minheight")
+GK_ATOM(minimum_scale, "minimum-scale")
 GK_ATOM(minpos, "minpos")
 GK_ATOM(minusSign, "minus-sign")
 GK_ATOM(minwidth, "minwidth")
 GK_ATOM(mod, "mod")
 GK_ATOM(mode, "mode")
@@ -911,10 +913,11 @@ GK_ATOM(upperFirst, "upper-first")
 GK_ATOM(upperFirst, "upper-first")
 GK_ATOM(uri, "uri")
 GK_ATOM(use, "use")
 GK_ATOM(useAttributeSets, "use-attribute-sets")
 GK_ATOM(usemap, "usemap")
+GK_ATOM(user_scalable, "user-scalable")
 GK_ATOM(userInput, "userInput")
 GK_ATOM(validate, "validate")
 GK_ATOM(valign, "valign")
 GK_ATOM(value, "value")
 GK_ATOM(values, "values")
@@ -932,10 +935,17 @@ GK_ATOM(vertical, "vertical")
 #ifdef MOZ_MEDIA
 GK_ATOM(audio, "audio")
 GK_ATOM(video, "video")
 GK_ATOM(videocontrols, "videocontrols")
 #endif
+GK_ATOM(viewport, "viewport")
+GK_ATOM(viewport_height, "viewport-height")
+GK_ATOM(viewport_initial_scale, "viewport-initial-scale")
+GK_ATOM(viewport_maximum_scale, "viewport-maximum-scale")
+GK_ATOM(viewport_minimum_scale, "viewport-minimum-scale")
+GK_ATOM(viewport_user_scalable, "viewport-user-scalable")
+GK_ATOM(viewport_width, "viewport-width")
 GK_ATOM(visibility, "visibility")
 GK_ATOM(vlink, "vlink")
 GK_ATOM(vspace, "vspace")
 GK_ATOM(wbr, "wbr")
 GK_ATOM(when, "when")
@@ -1303,10 +1313,11 @@ GK_ATOM(mathbackground_, "mathbackground
 GK_ATOM(mathbackground_, "mathbackground")
 GK_ATOM(mathcolor_, "mathcolor")
 GK_ATOM(mathsize_, "mathsize")
 GK_ATOM(mathvariant_, "mathvariant")
 GK_ATOM(matrixrow_, "matrixrow")
+GK_ATOM(maximum_scale, "maximum-scale")
 GK_ATOM(maxsize_, "maxsize")
 GK_ATOM(mean_, "mean")
 GK_ATOM(median_, "median")
 GK_ATOM(mediummathspace_, "mediummathspace")
 GK_ATOM(menclose_, "menclose")
diff -r 6c8c95fcaf9b content/base/test/test_bug431833.html
--- a/content/base/test/test_bug431833.html	Tue Jul 15 15:16:43 2008 +1200
+++ b/content/base/test/test_bug431833.html	Thu Jul 17 14:13:03 2008 +0300
@@ -6,12 +6,20 @@ https://bugzilla.mozilla.org/show_bug.cg
 <head>
   <title>Test for Bug 431833</title>
   <script type="text/javascript" src="/MochiKit/MochiKit.js"></script>
   <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
   <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+  <script>
+    var loadsComplete = [];
+    function test(e) {
+      loadsComplete[e.target.id] = true;
+    }
+    window.addEventListener('DOMFrameContentLoaded',test,true);
+  </script>
 </head>
 <body>
+
 <a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=431833">Mozilla Bug 431833</a>
 <p id="display">
  <iframe id="f1" src="data:text/html,1"></iframe>
  <iframe id="f2" src="data:text/html,2"></iframe>
  <iframe id="f3" src="data:text/html,<iframe id='f4' src='data:text/html,3'></iframe>"></iframe>
@@ -22,25 +30,20 @@ https://bugzilla.mozilla.org/show_bug.cg
 <pre id="test">
 <script class="testbody" type="text/javascript">
 
 /** Test for Bug 431833 **/
 
-var str = "FAIL";
-function test(e) {
-  if (str == "FAIL")
-    str = "";
-
-  str += "PASS: " + e.target.id + '. '; 
-}
-
-window.addEventListener('DOMFrameContentLoaded',test,true);
-
 SimpleTest.waitForExplicitFinish();
 
 addLoadEvent(function() {
-  is(str, "PASS: f1. PASS: f2. PASS: f3. PASS: f4. ",
-     "DOMFrameContentLoaded events didn't fire?");
+    function check(id) {
+      ok(loadsComplete[id], "DOMFrameContentLoaded didn't fire for " + id);
+    }
+    check("f1");
+    check("f2");
+    check("f3");
+    check("f4");
   });
 
 addLoadEvent(SimpleTest.finish);
 </script>
 </pre>
diff -r 6c8c95fcaf9b content/events/src/nsEventListenerManager.cpp
--- a/content/events/src/nsEventListenerManager.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/content/events/src/nsEventListenerManager.cpp	Thu Jul 17 14:13:03 2008 +0300
@@ -37,11 +37,11 @@
 
 #include "nsISupports.h"
 #include "nsGUIEvent.h"
 #include "nsDOMEvent.h"
 #include "nsEventListenerManager.h"
-#include "nsICaret.h"
+#include "nsCaret.h"
 #include "nsIDOMNSEvent.h"
 #include "nsIDOMEventListener.h"
 #include "nsIDOMMouseListener.h"
 #include "nsIDOMMouseMotionListener.h"
 #include "nsIDOMContextMenuListener.h"
@@ -1443,24 +1443,23 @@ nsEventListenerManager::PrepareToUseCare
                                                   nsPoint& aTargetPt)
 {
   nsresult rv;
 
   // check caret visibility
-  nsCOMPtr<nsICaret> caret;
+  nsRefPtr<nsCaret> caret;
   rv = aShell->GetCaret(getter_AddRefs(caret));
   NS_ENSURE_SUCCESS(rv, PR_FALSE);
   NS_ENSURE_TRUE(caret, PR_FALSE);
 
   PRBool caretVisible = PR_FALSE;
   rv = caret->GetCaretVisible(&caretVisible);
   if (NS_FAILED(rv) || ! caretVisible)
     return PR_FALSE;
 
-  // caret selection, watch out: GetCaretDOMSelection can return null but NS_OK
-  nsCOMPtr<nsISelection> domSelection;
-  rv = caret->GetCaretDOMSelection(getter_AddRefs(domSelection));
-  NS_ENSURE_SUCCESS(rv, PR_FALSE);
+  // caret selection, this is a temporary weak reference, so no refcounting is 
+  // needed
+  nsISelection* domSelection = caret->GetCaretDOMSelection();
   NS_ENSURE_TRUE(domSelection, PR_FALSE);
 
   // since the match could be an anonymous textnode inside a
   // <textarea> or text <input>, we need to get the outer frame
   // note: frames are not refcounted
@@ -1519,11 +1518,11 @@ nsEventListenerManager::PrepareToUseCare
   // get caret position relative to some view (normally the same as the
   // event widget view, but this is not guaranteed)
   PRBool isCollapsed;
   nsIView* view;
   nsRect caretCoords;
-  rv = caret->GetCaretCoordinates(nsICaret::eRenderingViewCoordinates,
+  rv = caret->GetCaretCoordinates(nsCaret::eRenderingViewCoordinates,
                                   domSelection, &caretCoords, &isCollapsed,
                                   &view);
   NS_ENSURE_SUCCESS(rv, PR_FALSE);
 
   // in case the view used for caret coordinates was something else, we need
diff -r 6c8c95fcaf9b content/events/src/nsEventStateManager.cpp
--- a/content/events/src/nsEventStateManager.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/content/events/src/nsEventStateManager.cpp	Thu Jul 17 14:13:03 2008 +0300
@@ -117,11 +117,11 @@
 #include "nsIDOMDocumentView.h"
 #include "nsIDOMAbstractView.h"
 #include "nsIDOMNSUIEvent.h"
 
 #include "nsIDOMRange.h"
-#include "nsICaret.h"
+#include "nsCaret.h"
 #include "nsILookAndFeel.h"
 #include "nsWidgetsCID.h"
 
 #include "nsIFrameFrame.h"
 #include "nsIFrameTraversal.h"
@@ -1027,11 +1027,11 @@ nsEventStateManager::PreHandleEvent(nsPr
 #endif
       // Hide the caret if it's visible.
       if (mPresContext) {
         nsIPresShell *presShell = mPresContext->GetPresShell();
         if (presShell) {
-           nsCOMPtr<nsICaret> caret;
+           nsRefPtr<nsCaret> caret;
            presShell->GetCaret(getter_AddRefs(caret));
            if (caret) {
              PRBool caretVisible = PR_FALSE;
              caret->GetCaretVisible(&caretVisible);
              if (caretVisible) {
@@ -5045,15 +5045,15 @@ nsEventStateManager::GetDocSelectionLoca
           } while (!newCaretContent || newCaretContent == startContent);
 
           if (newCaretFrame && newCaretContent) {
             // If the caret is exactly at the same position of the new frame,
             // then we can use the newCaretFrame and newCaretContent for our position
-            nsCOMPtr<nsICaret> caret;
+            nsRefPtr<nsCaret> caret;
             shell->GetCaret(getter_AddRefs(caret));
             nsRect caretRect;
             nsIView *caretView;
-            caret->GetCaretCoordinates(nsICaret::eClosestViewCoordinates, 
+            caret->GetCaretCoordinates(nsCaret::eClosestViewCoordinates, 
                                        domSelection, &caretRect,
                                        &isCollapsed, &caretView);
             nsPoint framePt;
             nsIView *frameClosestView = newCaretFrame->GetClosestView(&framePt);
             if (caretView == frameClosestView && caretRect.y == framePt.y &&
@@ -5329,11 +5329,11 @@ nsEventStateManager::MoveCaretToFocus()
 }
 
 nsresult
 nsEventStateManager::SetCaretEnabled(nsIPresShell *aPresShell, PRBool aEnabled)
 {
-  nsCOMPtr<nsICaret> caret;
+  nsRefPtr<nsCaret> caret;
   aPresShell->GetCaret(getter_AddRefs(caret));
 
   nsCOMPtr<nsISelectionController> selCon(do_QueryInterface(aPresShell));
   if (!selCon || !caret)
     return NS_ERROR_FAILURE;
@@ -5349,11 +5349,11 @@ nsEventStateManager::SetContentCaretVisi
 nsEventStateManager::SetContentCaretVisible(nsIPresShell* aPresShell,
                                             nsIContent *aFocusedContent,
                                             PRBool aVisible)
 {
   // When browsing with caret, make sure caret is visible after new focus
-  nsCOMPtr<nsICaret> caret;
+  nsRefPtr<nsCaret> caret;
   aPresShell->GetCaret(getter_AddRefs(caret));
 
   nsCOMPtr<nsFrameSelection> frameSelection;
   if (aFocusedContent) {
     nsIFrame *focusFrame = aPresShell->GetPrimaryFrameFor(aFocusedContent);
diff -r 6c8c95fcaf9b content/events/src/nsQueryContentEventHandler.cpp
--- a/content/events/src/nsQueryContentEventHandler.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/content/events/src/nsQueryContentEventHandler.cpp	Thu Jul 17 14:13:03 2008 +0300
@@ -44,11 +44,11 @@
 #include "nsISelection.h"
 #include "nsIDOMText.h"
 #include "nsIDOMRange.h"
 #include "nsRange.h"
 #include "nsGUIEvent.h"
-#include "nsICaret.h"
+#include "nsCaret.h"
 #include "nsFrameSelection.h"
 #include "nsIFrame.h"
 #include "nsIView.h"
 #include "nsIContentIterator.h"
 #include "nsTextFragment.h"
@@ -411,11 +411,11 @@ nsQueryContentEventHandler::OnQueryTextC
 }
 
 nsresult
 nsQueryContentEventHandler::QueryRectFor(nsQueryContentEvent* aEvent,
                                          nsIRange* aRange,
-                                         nsICaret* aCaret)
+                                         nsCaret* aCaret)
 {
   PRInt32 offsetInFrame;
   nsIFrame* frame;
   nsresult rv = GetStartFrameAndOffset(aRange, &frame, &offsetInFrame);
   NS_ENSURE_SUCCESS(rv, rv);
@@ -472,11 +472,11 @@ nsQueryContentEventHandler::OnQueryCaret
 {
   nsresult rv = Init(aEvent);
   if (NS_FAILED(rv))
     return rv;
 
-  nsCOMPtr<nsICaret> caret;
+  nsRefPtr<nsCaret> caret;
   rv = mPresShell->GetCaret(getter_AddRefs(caret));
   NS_ENSURE_SUCCESS(rv, rv);
   NS_ASSERTION(caret, "GetCaret succeeded, but the result is null");
 
   // When the selection is collapsed and the queried offset is current caret
@@ -489,11 +489,11 @@ nsQueryContentEventHandler::OnQueryCaret
     PRUint32 offset;
     rv = GetFlatTextOffsetOfRange(mFirstSelectedRange, &offset);
     NS_ENSURE_SUCCESS(rv, rv);
     if (offset == aEvent->mInput.mOffset) {
       PRBool isCollapsed;
-      rv = caret->GetCaretCoordinates(nsICaret::eTopLevelWindowCoordinates,
+      rv = caret->GetCaretCoordinates(nsCaret::eTopLevelWindowCoordinates,
                                       mSelection, &aEvent->mReply.mRect,
                                       &isCollapsed, nsnull);
       NS_ENSURE_SUCCESS(rv, rv);
       aEvent->mSucceeded = PR_TRUE;
       return NS_OK;
diff -r 6c8c95fcaf9b content/events/src/nsQueryContentEventHandler.h
--- a/content/events/src/nsQueryContentEventHandler.h	Tue Jul 15 15:16:43 2008 +1200
+++ b/content/events/src/nsQueryContentEventHandler.h	Thu Jul 17 14:13:03 2008 +0300
@@ -48,11 +48,11 @@
 #include "nsIDOMTreeWalker.h"
 
 class nsPresContext;
 class nsIPresShell;
 class nsQueryContentEvent;
-class nsICaret;
+class nsCaret;
 struct nsRect;
 
 /*
  * Query Content Event Handler
  *   nsQueryContentEventHandler is a helper class for nsEventStateManager.
@@ -103,11 +103,11 @@ protected:
   // Convert the frame relative offset to the root view relative offset.
   nsresult ConvertToRootViewRelativeOffset(nsIFrame* aFrame, nsRect& aRect);
   // The helper for OnQueryCharacterRect/OnQueryCaretRect.
   // Don't call for another event.
   nsresult QueryRectFor(nsQueryContentEvent* aEvent, nsIRange* aRange,
-                        nsICaret* aCaret);
+                        nsCaret* aCaret);
   // Expand aXPOffset to the nearest offset in cluster boundary. aForward is
   // true, it is expanded to forward.
   nsresult ExpandToClusterBoundary(nsIContent* aContent, PRBool aForward,
                                    PRUint32* aXPOffset);
 };
diff -r 6c8c95fcaf9b content/html/content/src/Makefile.in
--- a/content/html/content/src/Makefile.in	Tue Jul 15 15:16:43 2008 +1200
+++ b/content/html/content/src/Makefile.in	Thu Jul 17 14:13:03 2008 +0300
@@ -151,9 +151,10 @@ INCLUDES	+= \
 INCLUDES	+= \
 		-I$(srcdir)/../../../base/src \
 		-I$(srcdir)/../../../events/src \
 		-I$(srcdir)/../../../xbl/src \
 		-I$(srcdir)/../../../../layout/style \
+		-I$(srcdir)/../../../../layout/tables \
 		-I$(srcdir) \
 		$(NULL)
 
 DEFINES += -D_IMPL_NS_LAYOUT
diff -r 6c8c95fcaf9b content/html/content/src/nsGenericHTMLElement.cpp
--- a/content/html/content/src/nsGenericHTMLElement.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/content/html/content/src/nsGenericHTMLElement.cpp	Thu Jul 17 14:13:03 2008 +0300
@@ -581,12 +581,12 @@ nsGenericHTMLElement::GetOffsetRect(nsRe
 
   // Subtract the parent border unless it uses border-box sizing.
   if (parent &&
       parent->GetStylePosition()->mBoxSizing != NS_STYLE_BOX_SIZING_BORDER) {
     const nsStyleBorder* border = parent->GetStyleBorder();
-    origin.x -= border->GetBorderWidth(NS_SIDE_LEFT);
-    origin.y -= border->GetBorderWidth(NS_SIDE_TOP);
+    origin.x -= border->GetActualBorderWidth(NS_SIDE_LEFT);
+    origin.y -= border->GetActualBorderWidth(NS_SIDE_TOP);
   }
 
   // XXX We should really consider subtracting out padding for
   // content-box sizing, but we should see what IE does....
 
diff -r 6c8c95fcaf9b content/html/content/src/nsHTMLTableCellElement.cpp
--- a/content/html/content/src/nsHTMLTableCellElement.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/content/html/content/src/nsHTMLTableCellElement.cpp	Thu Jul 17 14:13:03 2008 +0300
@@ -43,10 +43,11 @@
 #include "nsGkAtoms.h"
 #include "nsStyleConsts.h"
 #include "nsPresContext.h"
 #include "nsRuleData.h"
 #include "nsIDocument.h"
+#include "celldata.h"
 
 class nsHTMLTableCellElement : public nsGenericHTMLElement,
                                public nsIDOMHTMLTableCellElement
 {
 public:
@@ -258,13 +259,10 @@ static const nsAttrValue::EnumTable kCel
   { "col",      NS_STYLE_CELL_SCOPE_COL },
   { "rowgroup", NS_STYLE_CELL_SCOPE_ROWGROUP },
   { "colgroup", NS_STYLE_CELL_SCOPE_COLGROUP },
   { 0 }
 };
-
-#define MAX_ROWSPAN 8190 // celldata.h can not handle more
-#define MAX_COLSPAN 1000 // limit as IE and opera do
 
 PRBool
 nsHTMLTableCellElement::ParseAttribute(PRInt32 aNamespaceID,
                                        nsIAtom* aAttribute,
                                        const nsAString& aValue,
diff -r 6c8c95fcaf9b content/html/document/src/nsHTMLContentSink.cpp
--- a/content/html/document/src/nsHTMLContentSink.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/content/html/document/src/nsHTMLContentSink.cpp	Thu Jul 17 14:13:03 2008 +0300
@@ -207,10 +207,12 @@ public:
   NS_IMETHOD BeginContext(PRInt32 aID);
   NS_IMETHOD EndContext(PRInt32 aID);
   NS_IMETHOD OpenHead();
   NS_IMETHOD IsEnabled(PRInt32 aTag, PRBool* aReturn);
   NS_IMETHOD_(PRBool) IsFormOnStack();
+
+  virtual nsresult ProcessMETATag(nsIContent* aContent);
 
 #ifdef DEBUG
   // nsIDebugDumpContent
   NS_IMETHOD DumpContentModel();
 #endif
@@ -2997,10 +2999,37 @@ HTMLContentSink::ProcessLINKTag(const ns
   }
 
   return result;
 }
 
+/* 
+ * Extends nsContentSink::ProcessMETATag to grab the 'viewport' meta tag. This
+ * information is ignored by the generic content sink because it only stores
+ * http-equiv meta tags.
+ *
+ * Initially implemented for bug #436083
+ */
+nsresult
+HTMLContentSink::ProcessMETATag(nsIContent *aContent) {
+
+  /* Call the superclass method. */
+  nsContentSink::ProcessMETATag(aContent);
+
+  nsresult rv = NS_OK;
+
+  /* Look for the viewport meta tag. If we find it, process it and put the
+   * data into the document header. */
+  if (aContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::name,
+                            nsGkAtoms::viewport, eIgnoreCase)) {
+    nsAutoString value;
+    aContent->GetAttr(kNameSpaceID_None, nsGkAtoms::content, value);
+    rv = nsContentUtils::ProcessViewportInfo(mDocument, value);
+  }
+
+  return rv;
+}
+
 #ifdef DEBUG
 void
 HTMLContentSink::ForceReflow()
 {
   mCurrentContext->FlushTags();
diff -r 6c8c95fcaf9b content/html/document/src/nsImageDocument.cpp
--- a/content/html/document/src/nsImageDocument.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/content/html/document/src/nsImageDocument.cpp	Thu Jul 17 14:13:03 2008 +0300
@@ -664,11 +664,11 @@ nsImageDocument::CheckOverflowing(PRBool
       context->StyleSet()->ResolveStyleFor(content, nsnull);
 
     nsMargin m;
     if (styleContext->GetStyleMargin()->GetMargin(m))
       visibleArea.Deflate(m);
-    m = styleContext->GetStyleBorder()->GetBorder();
+    m = styleContext->GetStyleBorder()->GetActualBorder();
     visibleArea.Deflate(m);
     if (styleContext->GetStylePadding()->GetPadding(m))
       visibleArea.Deflate(m);
 
     float zoomLevel = GetZoomLevel();
diff -r 6c8c95fcaf9b content/html/document/test/Makefile.in
--- a/content/html/document/test/Makefile.in	Tue Jul 15 15:16:43 2008 +1200
+++ b/content/html/document/test/Makefile.in	Thu Jul 17 14:13:03 2008 +0300
@@ -67,9 +67,10 @@ _TEST_FILES = 	test_bug1682.html \
 		test_bug402680.html \
 		test_bug403868.html \
 		test_bug403868.xhtml \
 		test_bug404320.html \
 		test_form-parsing.html \
+		test_viewport.html \
 		$(NULL)
 
 libs:: $(_TEST_FILES)
 	$(INSTALL) $(foreach f,$^,"$f") $(DEPTH)/_tests/testing/mochitest/tests/$(relativesrcdir)
diff -r 6c8c95fcaf9b content/html/document/test/test_viewport.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/html/document/test/test_viewport.html	Thu Jul 17 14:13:03 2008 +0300
@@ -0,0 +1,62 @@
+<!DOCTYPE html>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=436083
+-->
+<head>
+  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
+  <meta name="viewport" content="height=398, width=4224, minimum-scale=0.1,
+  initial-scale=2.3, maximum-scale=45.2, user-scalable=no">
+  <title>Test for Viewport META Tag Parsing</title>
+  <script type="text/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>        
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+<a target="_blank"
+href="https://bugzilla.mozilla.org/show_bug.cgi?id=436083">Mozilla Bug 436083</a>
+<pre id="test">
+<script class="testbody" type="text/javascript">
+
+/** Test for Viewport META Tag **/
+
+SimpleTest.waitForExplicitFinish();
+
+function testViewport() {
+
+  /* We need to access the document headers, which are chrome-only. */
+  netscape.security.PrivilegeManager.enablePrivilege('UniversalXPConnect');
+
+  /* Grab Viewport Metadata from the document header. */
+  var iRequester =
+    window.QueryInterface(Components.interfaces.nsIInterfaceRequestor);
+  var windowUtils =
+    iRequester.getInterface(Components.interfaces.nsIDOMWindowUtils);
+  var vpWidth =
+    parseInt(windowUtils.getDocumentMetadata("viewport-width"));
+  var vpHeight =
+    parseInt(windowUtils.getDocumentMetadata("viewport-height"));
+  var vpInitialScale = 
+    parseFloat(windowUtils.getDocumentMetadata("viewport-initial-scale"));
+  var vpMaxScale = 
+    parseFloat(windowUtils.getDocumentMetadata("viewport-maximum-scale"));
+  var vpMinScale = 
+    parseFloat(windowUtils.getDocumentMetadata("viewport-minimum-scale"));
+  var vpUserScalable = 
+    windowUtils.getDocumentMetadata("viewport-user-scalable");
+
+  is(vpWidth, 4224, "Should get proper width");
+  is(vpHeight, 398, "Should get proper height");
+  is(vpInitialScale, 2.3, "Should get proper initial scale");
+  is(vpMaxScale, 45.2, "Should get proper max scale");
+  is(vpMinScale, 0.1, "Should get proper min scale");
+  is(vpUserScalable, "no", "Should get proper user scalable parameter");
+}
+
+addLoadEvent(testViewport);
+addLoadEvent(SimpleTest.finish);
+
+</script>
+</pre>
+</body>
+</html>
diff -r 6c8c95fcaf9b content/svg/content/src/nsSVGFilters.cpp
--- a/content/svg/content/src/nsSVGFilters.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/content/svg/content/src/nsSVGFilters.cpp	Thu Jul 17 14:13:03 2008 +0300
@@ -89,11 +89,11 @@ static void
 static void
 CopyRect(const nsSVGFE::Image* aDest, const nsSVGFE::Image* aSrc, const nsIntRect& aDataRect)
 {
   NS_ASSERTION(aDest->mImage->Stride() == aSrc->mImage->Stride(), "stride mismatch");
   NS_ASSERTION(aDest->mImage->GetSize() == aSrc->mImage->GetSize(), "size mismatch");
-  NS_ASSERTION(nsIntRect(0,0,aDest->mImage->Width(),aDest->mImage->Height()).Contains(aDataRect),
+  NS_ASSERTION(nsIntRect(0, 0, aDest->mImage->Width(), aDest->mImage->Height()).Contains(aDataRect),
                "aDataRect out of bounds");
 
   CopyDataRect(aDest->mImage->Data(), aSrc->mImage->Data(),
                aSrc->mImage->Stride(), aDataRect);
 }
@@ -218,24 +218,24 @@ nsSVGFE::FinishScalingFilter(ScaleInfo *
             double(aScaleInfo->mRealTarget->Height()) / scaledSize.height);
   ctx.SetSource(aScaleInfo->mTarget);
   ctx.Paint();
 }
 
-nsRect
-nsSVGFE::ComputeTargetBBox(const nsTArray<nsRect>& aSourceBBoxes,
+nsIntRect
+nsSVGFE::ComputeTargetBBox(const nsTArray<nsIntRect>& aSourceBBoxes,
                            const nsSVGFilterInstance& aInstance)
 {
-  nsRect r;
+  nsIntRect r;
   for (PRUint32 i = 0; i < aSourceBBoxes.Length(); ++i) {
     r.UnionRect(r, aSourceBBoxes[i]);
   }
   return r;
 }
 
 void
-nsSVGFE::ComputeNeededSourceBBoxes(const nsRect& aTargetBBox,
-                                   nsTArray<nsRect>& aSourceBBoxes,
+nsSVGFE::ComputeNeededSourceBBoxes(const nsIntRect& aTargetBBox,
+                                   nsTArray<nsIntRect>& aSourceBBoxes,
                                    const nsSVGFilterInstance& aInstance)
 {
   for (PRUint32 i = 0; i < aSourceBBoxes.Length(); ++i) {
     aSourceBBoxes[i] = aTargetBBox;
   }
@@ -313,14 +313,14 @@ public:
                           const nsTArray<const Image*>& aSources,
                           const Image* aTarget,
                           const nsIntRect& aDataRect);
   virtual nsSVGString* GetResultImageName() { return &mStringAttributes[RESULT]; }
   virtual void GetSourceImageNames(nsTArray<nsSVGString*>* aSources);
-  virtual nsRect ComputeTargetBBox(const nsTArray<nsRect>& aSourceBBoxes,
-          const nsSVGFilterInstance& aInstance);
-  virtual void ComputeNeededSourceBBoxes(const nsRect& aTargetBBox,
-          nsTArray<nsRect>& aSourceBBoxes, const nsSVGFilterInstance& aInstance);
+  virtual nsIntRect ComputeTargetBBox(const nsTArray<nsIntRect>& aSourceBBoxes,
+          const nsSVGFilterInstance& aInstance);
+  virtual void ComputeNeededSourceBBoxes(const nsIntRect& aTargetBBox,
+          nsTArray<nsIntRect>& aSourceBBoxes, const nsSVGFilterInstance& aInstance);
 
   // Gaussian
   NS_DECL_NSIDOMSVGFEGAUSSIANBLURELEMENT
 
   NS_FORWARD_NSIDOMSVGELEMENT(nsSVGFEGaussianBlurElementBase::)
@@ -342,11 +342,11 @@ protected:
   nsSVGString mStringAttributes[2];
   static StringInfo sStringInfo[2];
 
 private:
   nsresult GetDXY(PRUint32 *aDX, PRUint32 *aDY, const nsSVGFilterInstance& aInstance);
-  void InflateRectForBlur(nsRect* aRect, const nsSVGFilterInstance& aInstance);
+  void InflateRectForBlur(nsIntRect* aRect, const nsSVGFilterInstance& aInstance);
 
   void GaussianBlur(const Image *aSource, const Image *aTarget,
                     const nsIntRect& aDataRect,
                     PRUint32 aDX, PRUint32 aDY);
 };
@@ -574,11 +574,11 @@ nsSVGFEGaussianBlurElement::GaussianBlur
 nsSVGFEGaussianBlurElement::GaussianBlur(const Image *aSource,
                                          const Image *aTarget,                                         
                                          const nsIntRect& aDataRect,
                                          PRUint32 aDX, PRUint32 aDY)
 {
-  NS_ASSERTION(nsIntRect(0,0,aTarget->mImage->Width(),aTarget->mImage->Height()).Contains(aDataRect),
+  NS_ASSERTION(nsIntRect(0, 0, aTarget->mImage->Width(), aTarget->mImage->Height()).Contains(aDataRect),
                "aDataRect out of bounds");
 
   nsAutoArrayPtr<PRUint8> tmp(new PRUint8[aTarget->mImage->GetDataSize()]);
   if (!tmp)
     return;
@@ -663,11 +663,11 @@ static void
 static void
 ClipComputationRectToSurface(nsSVGFilterInstance* aInstance,
                              nsIntRect* aDataRect)
 {
   aDataRect->IntersectRect(*aDataRect,
-          nsRect(nsPoint(0, 0), aInstance->GetSurfaceRect().Size()));
+          nsIntRect(nsIntPoint(0, 0), aInstance->GetSurfaceRect().Size()));
 }
 
 nsresult
 nsSVGFEGaussianBlurElement::Filter(nsSVGFilterInstance* aInstance,
                                    const nsTArray<const Image*>& aSources,
@@ -694,34 +694,34 @@ nsSVGFEGaussianBlurElement::GetSourceIma
 {
   aSources->AppendElement(&mStringAttributes[IN1]);
 }
 
 void
-nsSVGFEGaussianBlurElement::InflateRectForBlur(nsRect* aRect,
+nsSVGFEGaussianBlurElement::InflateRectForBlur(nsIntRect* aRect,
                                                const nsSVGFilterInstance& aInstance)
 {
   PRUint32 dX, dY;
   nsresult rv = GetDXY(&dX, &dY, aInstance);
   if (NS_SUCCEEDED(rv)) {
     InflateRectForBlurDXY(aRect, dX, dY);
   }
 }
 
-nsRect
-nsSVGFEGaussianBlurElement::ComputeTargetBBox(const nsTArray<nsRect>& aSourceBBoxes,
-        const nsSVGFilterInstance& aInstance)
-{
-  nsRect r = aSourceBBoxes[0];
+nsIntRect
+nsSVGFEGaussianBlurElement::ComputeTargetBBox(const nsTArray<nsIntRect>& aSourceBBoxes,
+        const nsSVGFilterInstance& aInstance)
+{
+  nsIntRect r = aSourceBBoxes[0];
   InflateRectForBlur(&r, aInstance);
   return r;
 }
 
 void
-nsSVGFEGaussianBlurElement::ComputeNeededSourceBBoxes(const nsRect& aTargetBBox,
-          nsTArray<nsRect>& aSourceBBoxes, const nsSVGFilterInstance& aInstance)
-{
-  nsRect r = aTargetBBox;
+nsSVGFEGaussianBlurElement::ComputeNeededSourceBBoxes(const nsIntRect& aTargetBBox,
+          nsTArray<nsIntRect>& aSourceBBoxes, const nsSVGFilterInstance& aInstance)
+{
+  nsIntRect r = aTargetBBox;
   InflateRectForBlur(&r, aInstance);
   aSourceBBoxes[0] = r;
 }
 
 //----------------------------------------------------------------------
@@ -1291,11 +1291,11 @@ public:
                           const nsTArray<const Image*>& aSources,
                           const Image* aTarget,
                           const nsIntRect& aDataRect);
   virtual nsSVGString* GetResultImageName() { return &mStringAttributes[RESULT]; }
   virtual void GetSourceImageNames(nsTArray<nsSVGString*>* aSources);
-  virtual nsRect ComputeTargetBBox(const nsTArray<nsRect>& aSourceBBoxes,
+  virtual nsIntRect ComputeTargetBBox(const nsTArray<nsIntRect>& aSourceBBoxes,
           const nsSVGFilterInstance& aInstance);
 
   // Composite
   NS_DECL_NSIDOMSVGFECOMPOSITEELEMENT
 
@@ -1510,12 +1510,12 @@ nsSVGFECompositeElement::GetSourceImageN
 {
   aSources->AppendElement(&mStringAttributes[IN1]);
   aSources->AppendElement(&mStringAttributes[IN2]);
 }
 
-nsRect
-nsSVGFECompositeElement::ComputeTargetBBox(const nsTArray<nsRect>& aSourceBBoxes,
+nsIntRect
+nsSVGFECompositeElement::ComputeTargetBBox(const nsTArray<nsIntRect>& aSourceBBoxes,
         const nsSVGFilterInstance& aInstance)
 {
   PRUint16 op = mEnumAttributes[OPERATOR].GetAnimValue();
 
   if (op == nsSVGFECompositeElement::SVG_OPERATOR_ARITHMETIC) {
@@ -2383,14 +2383,14 @@ public:
                           const nsTArray<const Image*>& aSources,
                           const Image* aTarget,
                           const nsIntRect& aDataRect);
   virtual nsSVGString* GetResultImageName() { return &mStringAttributes[RESULT]; }
   virtual void GetSourceImageNames(nsTArray<nsSVGString*>* aSources);
-  virtual nsRect ComputeTargetBBox(const nsTArray<nsRect>& aSourceBBoxes,
-          const nsSVGFilterInstance& aInstance);
-  virtual void ComputeNeededSourceBBoxes(const nsRect& aTargetBBox,
-          nsTArray<nsRect>& aSourceBBoxes, const nsSVGFilterInstance& aInstance);
+  virtual nsIntRect ComputeTargetBBox(const nsTArray<nsIntRect>& aSourceBBoxes,
+          const nsSVGFilterInstance& aInstance);
+  virtual void ComputeNeededSourceBBoxes(const nsIntRect& aTargetBBox,
+          nsTArray<nsIntRect>& aSourceBBoxes, const nsSVGFilterInstance& aInstance);
 
   // Offset
   NS_DECL_NSIDOMSVGFEOFFSETELEMENT
 
   NS_FORWARD_NSIDOMSVGELEMENT(nsSVGFEOffsetElementBase::)
@@ -2517,20 +2517,20 @@ nsSVGFEOffsetElement::GetSourceImageName
 nsSVGFEOffsetElement::GetSourceImageNames(nsTArray<nsSVGString*>* aSources)
 {
   aSources->AppendElement(&mStringAttributes[IN1]);
 }
 
-nsRect
-nsSVGFEOffsetElement::ComputeTargetBBox(const nsTArray<nsRect>& aSourceBBoxes,
+nsIntRect
+nsSVGFEOffsetElement::ComputeTargetBBox(const nsTArray<nsIntRect>& aSourceBBoxes,
         const nsSVGFilterInstance& aInstance)
 {
   return aSourceBBoxes[0] + GetOffset(aInstance);
 }
 
 void
-nsSVGFEOffsetElement::ComputeNeededSourceBBoxes(const nsRect& aTargetBBox,
-          nsTArray<nsRect>& aSourceBBoxes, const nsSVGFilterInstance& aInstance)
+nsSVGFEOffsetElement::ComputeNeededSourceBBoxes(const nsIntRect& aTargetBBox,
+          nsTArray<nsIntRect>& aSourceBBoxes, const nsSVGFilterInstance& aInstance)
 {
   aSourceBBoxes[0] = aTargetBBox - GetOffset(aInstance);
 }
 
 //----------------------------------------------------------------------
@@ -2575,11 +2575,11 @@ public:
   virtual nsresult Filter(nsSVGFilterInstance* aInstance,
                           const nsTArray<const Image*>& aSources,
                           const Image* aTarget,
                           const nsIntRect& aDataRect);
   virtual nsSVGString* GetResultImageName() { return &mStringAttributes[RESULT]; }
-  virtual nsRect ComputeTargetBBox(const nsTArray<nsRect>& aSourceBBoxes,
+  virtual nsIntRect ComputeTargetBBox(const nsTArray<nsIntRect>& aSourceBBoxes,
           const nsSVGFilterInstance& aInstance);
 
   // Flood
   NS_DECL_NSIDOMSVGFEFLOODELEMENT
 
@@ -2656,12 +2656,12 @@ nsSVGFEFloodElement::Filter(nsSVGFilterI
   ctx.Rectangle(aTarget->mFilterPrimitiveSubregion);
   ctx.Fill();
   return NS_OK;
 }
 
-nsRect
-nsSVGFEFloodElement::ComputeTargetBBox(const nsTArray<nsRect>& aSourceBBoxes,
+nsIntRect
+nsSVGFEFloodElement::ComputeTargetBBox(const nsTArray<nsIntRect>& aSourceBBoxes,
         const nsSVGFilterInstance& aInstance)
 {
   return GetMaxRect();
 }
 
@@ -2716,14 +2716,14 @@ public:
                           const nsTArray<const Image*>& aSources,
                           const Image* aTarget,
                           const nsIntRect& aDataRect);
   virtual nsSVGString* GetResultImageName() { return &mStringAttributes[RESULT]; }
   virtual void GetSourceImageNames(nsTArray<nsSVGString*>* aSources);
-  virtual nsRect ComputeTargetBBox(const nsTArray<nsRect>& aSourceBBoxes,
-          const nsSVGFilterInstance& aInstance);
-  virtual void ComputeNeededSourceBBoxes(const nsRect& aTargetBBox,
-          nsTArray<nsRect>& aSourceBBoxes, const nsSVGFilterInstance& aInstance);
+  virtual nsIntRect ComputeTargetBBox(const nsTArray<nsIntRect>& aSourceBBoxes,
+          const nsSVGFilterInstance& aInstance);
+  virtual void ComputeNeededSourceBBoxes(const nsIntRect& aTargetBBox,
+          nsTArray<nsIntRect>& aSourceBBoxes, const nsSVGFilterInstance& aInstance);
 
   // Tile
   NS_DECL_NSIDOMSVGFETILEELEMENT
 
   NS_FORWARD_NSIDOMSVGELEMENT(nsSVGFETileElementBase::)
@@ -2784,20 +2784,20 @@ nsSVGFETileElement::GetSourceImageNames(
 nsSVGFETileElement::GetSourceImageNames(nsTArray<nsSVGString*>* aSources)
 {
   aSources->AppendElement(&mStringAttributes[IN1]);
 }
 
-nsRect
-nsSVGFETileElement::ComputeTargetBBox(const nsTArray<nsRect>& aSourceBBoxes,
-        const nsSVGFilterInstance& aInstance)
-{
-  return GetMaxRect();
-}
-
-void
-nsSVGFETileElement::ComputeNeededSourceBBoxes(const nsRect& aTargetBBox,
-          nsTArray<nsRect>& aSourceBBoxes, const nsSVGFilterInstance& aInstance)
+nsIntRect
+nsSVGFETileElement::ComputeTargetBBox(const nsTArray<nsIntRect>& aSourceBBoxes,
+        const nsSVGFilterInstance& aInstance)
+{
+  return GetMaxRect();
+}
+
+void
+nsSVGFETileElement::ComputeNeededSourceBBoxes(const nsIntRect& aTargetBBox,
+          nsTArray<nsIntRect>& aSourceBBoxes, const nsSVGFilterInstance& aInstance)
 {
   // Just assume we need the entire source bounding box, so do nothing.
 }
 
 static PRInt32 WrapInterval(PRInt32 aVal, PRInt32 aMax)
@@ -2891,11 +2891,11 @@ public:
   virtual nsresult Filter(nsSVGFilterInstance* aInstance,
                           const nsTArray<const Image*>& aSources,
                           const Image* aTarget,
                           const nsIntRect& aDataRect);
   virtual nsSVGString* GetResultImageName() { return &mStringAttributes[RESULT]; }
-  virtual nsRect ComputeTargetBBox(const nsTArray<nsRect>& aSourceBBoxes,
+  virtual nsIntRect ComputeTargetBBox(const nsTArray<nsIntRect>& aSourceBBoxes,
           const nsSVGFilterInstance& aInstance);
 
   // Turbulence
   NS_DECL_NSIDOMSVGFETURBULENCEELEMENT
 
@@ -3343,12 +3343,12 @@ nsSVGFETurbulenceElement::Turbulence(int
     }
   }
   return sum;
 }
 
-nsRect
-nsSVGFETurbulenceElement::ComputeTargetBBox(const nsTArray<nsRect>& aSourceBBoxes,
+nsIntRect
+nsSVGFETurbulenceElement::ComputeTargetBBox(const nsTArray<nsIntRect>& aSourceBBoxes,
         const nsSVGFilterInstance& aInstance)
 {
   return GetMaxRect();
 }
 
@@ -3407,14 +3407,14 @@ public:
                           const nsTArray<const Image*>& aSources,
                           const Image* aTarget,
                           const nsIntRect& aDataRect);
   virtual nsSVGString* GetResultImageName() { return &mStringAttributes[RESULT]; }
   virtual void GetSourceImageNames(nsTArray<nsSVGString*>* aSources);
-  virtual nsRect ComputeTargetBBox(const nsTArray<nsRect>& aSourceBBoxes,
-          const nsSVGFilterInstance& aInstance);
-  virtual void ComputeNeededSourceBBoxes(const nsRect& aTargetBBox,
-          nsTArray<nsRect>& aSourceBBoxes, const nsSVGFilterInstance& aInstance);
+  virtual nsIntRect ComputeTargetBBox(const nsTArray<nsIntRect>& aSourceBBoxes,
+          const nsSVGFilterInstance& aInstance);
+  virtual void ComputeNeededSourceBBoxes(const nsIntRect& aTargetBBox,
+          nsTArray<nsIntRect>& aSourceBBoxes, const nsSVGFilterInstance& aInstance);
 
   // Morphology
   NS_DECL_NSIDOMSVGFEMORPHOLOGYELEMENT
 
   NS_FORWARD_NSIDOMSVGELEMENT(nsSVGFEMorphologyElementBase::)
@@ -3424,11 +3424,11 @@ public:
 
   virtual nsresult Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const;
 
 protected:
   void GetRXY(PRInt32 *aRX, PRInt32 *aRY, const nsSVGFilterInstance& aInstance);
-  void InflateRect(nsRect* aRect, const nsSVGFilterInstance& aInstance);
+  void InflateRect(nsIntRect* aRect, const nsSVGFilterInstance& aInstance);
 
   virtual NumberAttributesInfo GetNumberInfo();
   virtual EnumAttributesInfo GetEnumInfo();
   virtual StringAttributesInfo GetStringInfo();
 
@@ -3537,32 +3537,32 @@ nsSVGFEMorphologyElement::GetSourceImage
 {
   aSources->AppendElement(&mStringAttributes[IN1]);
 }
 
 void
-nsSVGFEMorphologyElement::InflateRect(nsRect* aRect,
+nsSVGFEMorphologyElement::InflateRect(nsIntRect* aRect,
                                       const nsSVGFilterInstance& aInstance)
 {
   PRInt32 rx, ry;
   GetRXY(&rx, &ry, aInstance);
   aRect->Inflate(PR_MAX(0, rx), PR_MAX(0, ry));
 }
 
-nsRect
-nsSVGFEMorphologyElement::ComputeTargetBBox(const nsTArray<nsRect>& aSourceBBoxes,
-        const nsSVGFilterInstance& aInstance)
-{
-  nsRect r = aSourceBBoxes[0];
+nsIntRect
+nsSVGFEMorphologyElement::ComputeTargetBBox(const nsTArray<nsIntRect>& aSourceBBoxes,
+        const nsSVGFilterInstance& aInstance)
+{
+  nsIntRect r = aSourceBBoxes[0];
   InflateRect(&r, aInstance);
   return r;
 }
 
 void
-nsSVGFEMorphologyElement::ComputeNeededSourceBBoxes(const nsRect& aTargetBBox,
-          nsTArray<nsRect>& aSourceBBoxes, const nsSVGFilterInstance& aInstance)
-{
-  nsRect r = aTargetBBox;
+nsSVGFEMorphologyElement::ComputeNeededSourceBBoxes(const nsIntRect& aTargetBBox,
+          nsTArray<nsIntRect>& aSourceBBoxes, const nsSVGFilterInstance& aInstance)
+{
+  nsIntRect r = aTargetBBox;
   InflateRect(&r, aInstance);
   aSourceBBoxes[0] = r;
 }
 
 #define MORPHOLOGY_EPSILON 0.0001
@@ -3722,14 +3722,14 @@ public:
                           const nsTArray<const Image*>& aSources,
                           const Image* aTarget,
                           const nsIntRect& aDataRect);
   virtual nsSVGString* GetResultImageName() { return &mStringAttributes[RESULT]; }
   virtual void GetSourceImageNames(nsTArray<nsSVGString*>* aSources);
-  virtual nsRect ComputeTargetBBox(const nsTArray<nsRect>& aSourceBBoxes,
-          const nsSVGFilterInstance& aInstance);
-  virtual void ComputeNeededSourceBBoxes(const nsRect& aTargetBBox,
-          nsTArray<nsRect>& aSourceBBoxes, const nsSVGFilterInstance& aInstance);
+  virtual nsIntRect ComputeTargetBBox(const nsTArray<nsIntRect>& aSourceBBoxes,
+          const nsSVGFilterInstance& aInstance);
+  virtual void ComputeNeededSourceBBoxes(const nsIntRect& aTargetBBox,
+          nsTArray<nsIntRect>& aSourceBBoxes, const nsSVGFilterInstance& aInstance);
 
   // Color Matrix
   NS_DECL_NSIDOMSVGFECONVOLVEMATRIXELEMENT
 
   NS_FORWARD_NSIDOMSVGELEMENT(nsSVGFEConvolveMatrixElementBase::)
@@ -3938,23 +3938,23 @@ nsSVGFEConvolveMatrixElement::GetSourceI
 nsSVGFEConvolveMatrixElement::GetSourceImageNames(nsTArray<nsSVGString*>* aSources)
 {
   aSources->AppendElement(&mStringAttributes[IN1]);
 }
 
-nsRect
-nsSVGFEConvolveMatrixElement::ComputeTargetBBox(const nsTArray<nsRect>& aSourceBBoxes,
+nsIntRect
+nsSVGFEConvolveMatrixElement::ComputeTargetBBox(const nsTArray<nsIntRect>& aSourceBBoxes,
         const nsSVGFilterInstance& aInstance)
 {
   // XXX A more precise box is possible when 'bias' is zero and 'edgeMode' is
   // 'none', but it requires analysis of 'kernelUnitLength', 'order' and
   // 'targetX/Y', so it's quite a lot of work. Don't do it for now.
   return GetMaxRect();
 }
 
 void
-nsSVGFEConvolveMatrixElement::ComputeNeededSourceBBoxes(const nsRect& aTargetBBox,
-          nsTArray<nsRect>& aSourceBBoxes, const nsSVGFilterInstance& aInstance)
+nsSVGFEConvolveMatrixElement::ComputeNeededSourceBBoxes(const nsIntRect& aTargetBBox,
+          nsTArray<nsIntRect>& aSourceBBoxes, const nsSVGFilterInstance& aInstance)
 {
   // XXX Precise results are possible but we're going to skip that work
   // for now. Do nothing, which means the needed-box remains the
   // source's output bounding box.
 }
@@ -4490,12 +4490,12 @@ public:
                           const nsTArray<const Image*>& aSources,
                           const Image* aTarget,
                           const nsIntRect& aDataRect);
   virtual nsSVGString* GetResultImageName() { return &mStringAttributes[RESULT]; }
   virtual void GetSourceImageNames(nsTArray<nsSVGString*>* aSources);
-  virtual void ComputeNeededSourceBBoxes(const nsRect& aTargetBBox,
-          nsTArray<nsRect>& aSourceBBoxes, const nsSVGFilterInstance& aInstance);
+  virtual void ComputeNeededSourceBBoxes(const nsIntRect& aTargetBBox,
+          nsTArray<nsIntRect>& aSourceBBoxes, const nsSVGFilterInstance& aInstance);
 
   NS_FORWARD_NSIDOMSVGELEMENT(nsSVGFELightingElementBase::)
   NS_FORWARD_NSIDOMNODE(nsSVGFELightingElementBase::)
   NS_FORWARD_NSIDOMELEMENT(nsSVGFELightingElementBase::)
 
@@ -4563,12 +4563,12 @@ nsSVGFELightingElement::GetSourceImageNa
 {
   aSources->AppendElement(&mStringAttributes[IN1]);
 }
 
 void
-nsSVGFELightingElement::ComputeNeededSourceBBoxes(const nsRect& aTargetBBox,
-          nsTArray<nsRect>& aSourceBBoxes, const nsSVGFilterInstance& aInstance)
+nsSVGFELightingElement::ComputeNeededSourceBBoxes(const nsIntRect& aTargetBBox,
+          nsTArray<nsIntRect>& aSourceBBoxes, const nsSVGFilterInstance& aInstance)
 {
   // XXX lighting can depend on more than the target area, because
   // of the kernels it uses. We could compute something precise here
   // but just leave it and assume we use the entire source bounding box.
 }
@@ -5115,11 +5115,11 @@ public:
   virtual nsresult Filter(nsSVGFilterInstance* aInstance,
                           const nsTArray<const Image*>& aSources,
                           const Image* aTarget,
                           const nsIntRect& aDataRect);
   virtual nsSVGString* GetResultImageName() { return &mStringAttributes[RESULT]; }
-  virtual nsRect ComputeTargetBBox(const nsTArray<nsRect>& aSourceBBoxes,
+  virtual nsIntRect ComputeTargetBBox(const nsTArray<nsIntRect>& aSourceBBoxes,
           const nsSVGFilterInstance& aInstance);
 
   NS_DECL_NSIDOMSVGFEIMAGEELEMENT
   NS_DECL_NSIDOMSVGURIREFERENCE
 
@@ -5141,11 +5141,11 @@ public:
   // imgIDecoderObserver
   NS_IMETHOD OnStopDecode(imgIRequest *aRequest, nsresult status,
                           const PRUnichar *statusArg);
   // imgIContainerObserver
   NS_IMETHOD FrameChanged(imgIContainer *aContainer, gfxIImageFrame *newframe,
-                          nsRect * dirtyRect);
+                          nsIntRect *dirtyRect);
   // imgIContainerObserver
   NS_IMETHOD OnStartContainer(imgIRequest *aRequest,
                               imgIContainer *aContainer);
 
 private:
@@ -5345,12 +5345,12 @@ nsSVGFEImageElement::Filter(nsSVGFilterI
   }
 
   return NS_OK;
 }
 
-nsRect
-nsSVGFEImageElement::ComputeTargetBBox(const nsTArray<nsRect>& aSourceBBoxes,
+nsIntRect
+nsSVGFEImageElement::ComputeTargetBBox(const nsTArray<nsIntRect>& aSourceBBoxes,
         const nsSVGFilterInstance& aInstance)
 {
   // XXX can do better here ... we could check what we know of the source
   // image bounds and compute an accurate bounding box for the filter
   // primitive result.
@@ -5382,11 +5382,11 @@ nsSVGFEImageElement::OnStopDecode(imgIRe
 }
 
 NS_IMETHODIMP
 nsSVGFEImageElement::FrameChanged(imgIContainer *aContainer,
                                   gfxIImageFrame *newframe,
-                                  nsRect * dirtyRect)
+                                  nsIntRect *dirtyRect)
 {
   nsresult rv =
     nsImageLoadingContent::FrameChanged(aContainer, newframe, dirtyRect);
   Invalidate();
   return rv;
@@ -5438,14 +5438,14 @@ public:
                           const nsTArray<const Image*>& aSources,
                           const Image* aTarget,
                           const nsIntRect& aDataRect);
   virtual nsSVGString* GetResultImageName() { return &mStringAttributes[RESULT]; }
   virtual void GetSourceImageNames(nsTArray<nsSVGString*>* aSources);
-  virtual nsRect ComputeTargetBBox(const nsTArray<nsRect>& aSourceBBoxes,
-          const nsSVGFilterInstance& aInstance);
-  virtual void ComputeNeededSourceBBoxes(const nsRect& aTargetBBox,
-          nsTArray<nsRect>& aSourceBBoxes, const nsSVGFilterInstance& aInstance);
+  virtual nsIntRect ComputeTargetBBox(const nsTArray<nsIntRect>& aSourceBBoxes,
+          const nsSVGFilterInstance& aInstance);
+  virtual void ComputeNeededSourceBBoxes(const nsIntRect& aTargetBBox,
+          nsTArray<nsIntRect>& aSourceBBoxes, const nsSVGFilterInstance& aInstance);
 
   // DisplacementMap
   NS_DECL_NSIDOMSVGFEDISPLACEMENTMAPELEMENT
 
   NS_FORWARD_NSIDOMSVGELEMENT(nsSVGFEDisplacementMapElementBase::)
@@ -5640,23 +5640,23 @@ nsSVGFEDisplacementMapElement::GetSource
 {
   aSources->AppendElement(&mStringAttributes[IN1]);
   aSources->AppendElement(&mStringAttributes[IN2]);
 }
 
-nsRect
-nsSVGFEDisplacementMapElement::ComputeTargetBBox(const nsTArray<nsRect>& aSourceBBoxes,
+nsIntRect
+nsSVGFEDisplacementMapElement::ComputeTargetBBox(const nsTArray<nsIntRect>& aSourceBBoxes,
           const nsSVGFilterInstance& aInstance)
 {
   // XXX we could do something clever here involving analysis of 'scale'
   // to figure out the maximum displacement, and then return mIn1's bounds
   // adjusted for the maximum displacement
   return GetMaxRect();
 }
 
 void
-nsSVGFEDisplacementMapElement::ComputeNeededSourceBBoxes(const nsRect& aTargetBBox,
-          nsTArray<nsRect>& aSourceBBoxes, const nsSVGFilterInstance& aInstance)
+nsSVGFEDisplacementMapElement::ComputeNeededSourceBBoxes(const nsIntRect& aTargetBBox,
+          nsTArray<nsIntRect>& aSourceBBoxes, const nsSVGFilterInstance& aInstance)
 {
   // in2 contains the displacements, which we read for each target pixel
   aSourceBBoxes[1] = aTargetBBox;
   // XXX to figure out which parts of 'in' we might read, we could
   // do some analysis of 'scale' to figure out the maximum displacement.
diff -r 6c8c95fcaf9b content/svg/content/src/nsSVGSVGElement.cpp
--- a/content/svg/content/src/nsSVGSVGElement.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/content/svg/content/src/nsSVGSVGElement.cpp	Thu Jul 17 14:13:03 2008 +0300
@@ -1399,11 +1399,11 @@ nsSVGSVGElement::GetLength(PRUint8 aCtxT
   case nsSVGUtils::X:
     return w;
   case nsSVGUtils::Y:
     return h;
   case nsSVGUtils::XY:
-    return nsSVGUtils::ComputeNormalizedHypotenuse(w, h);
+    return float(nsSVGUtils::ComputeNormalizedHypotenuse(w, h));
   }
   return 0;
 }
 
 float
diff -r 6c8c95fcaf9b content/xml/document/src/nsXMLContentSink.cpp
--- a/content/xml/document/src/nsXMLContentSink.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/content/xml/document/src/nsXMLContentSink.cpp	Thu Jul 17 14:13:03 2008 +0300
@@ -1393,10 +1393,37 @@ nsXMLContentSink::ParsePIData(const nsSt
   nsParserUtils::GetQuotedAttributeValue(aData, nsGkAtoms::alternate, alternate);
 
   aIsAlternate = alternate.EqualsLiteral("yes");
 }
 
+/*
+ * Extends nsContentSink::ProcessMETATag to grab the 'viewport' meta tag. This
+ * information is ignored by the generic content sink because it only stores
+ * http-equiv meta tags. We need it in the XMLContentSink for XHTML documents.
+ *
+ * Initially implemented for bug #436083
+ */
+nsresult
+nsXMLContentSink::ProcessMETATag(nsIContent *aContent) {
+
+  /* Call the superclass method. */
+  nsContentSink::ProcessMETATag(aContent);
+
+  nsresult rv = NS_OK;
+
+  /* Look for the viewport meta tag. If we find it, process it and put the
+   * data into the document header. */
+  if (aContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::name,
+                            nsGkAtoms::viewport, eIgnoreCase)) {
+    nsAutoString value;
+    aContent->GetAttr(kNameSpaceID_None, nsGkAtoms::content, value);
+    rv = nsContentUtils::ProcessViewportInfo(mDocument, value);
+  }
+
+  return rv;
+}
+
 NS_IMETHODIMP
 nsXMLContentSink::HandleXMLDeclaration(const PRUnichar *aVersion,
                                        const PRUnichar *aEncoding,
                                        PRInt32 aStandalone)
 {
diff -r 6c8c95fcaf9b content/xml/document/src/nsXMLContentSink.h
--- a/content/xml/document/src/nsXMLContentSink.h	Tue Jul 15 15:16:43 2008 +1200
+++ b/content/xml/document/src/nsXMLContentSink.h	Thu Jul 17 14:13:03 2008 +0300
@@ -109,10 +109,12 @@ public:
                               nsresult aStatus);
   static void ParsePIData(const nsString &aData, nsString &aHref,
                           nsString &aTitle, nsString &aMedia,
                           PRBool &aIsAlternate);
 
+  virtual nsresult ProcessMETATag(nsIContent* aContent);
+
 protected:
   // Start layout.  If aIgnorePendingSheets is true, this will happen even if
   // we still have stylesheet loads pending.  Otherwise, we'll wait until the
   // stylesheets are all done loading.
   virtual void MaybeStartLayout(PRBool aIgnorePendingSheets);
diff -r 6c8c95fcaf9b content/xml/document/test/Makefile.in
--- a/content/xml/document/test/Makefile.in	Tue Jul 15 15:16:43 2008 +1200
+++ b/content/xml/document/test/Makefile.in	Thu Jul 17 14:13:03 2008 +0300
@@ -47,9 +47,10 @@ _TEST_FILES = 	test_bug232004.xhtml \
 _TEST_FILES = 	test_bug232004.xhtml \
 		test_bug343870.xhtml \
 		test_bug355213.xhtml \
 		test_bug392338.html \
 		test_bug399502.xhtml \
+		test_viewport.xhtml \
 		$(NULL)
 
 libs:: $(_TEST_FILES)
 	$(INSTALL) $(foreach f,$^,"$f") $(DEPTH)/_tests/testing/mochitest/tests/$(relativesrcdir)
diff -r 6c8c95fcaf9b content/xml/document/test/test_viewport.xhtml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/xml/document/test/test_viewport.xhtml	Thu Jul 17 14:13:03 2008 +0300
@@ -0,0 +1,64 @@
+<?xml version="1.0"?>
+<html xmlns="http://www.w3.org/1999/xhtml">
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=436083
+-->
+<head>
+  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
+  <meta name="viewport" content="height=398, width=4224, minimum-scale=0.1,
+  initial-scale=2.3, maximum-scale=45.2, user-scalable=no" />
+  <title>Test for Viewport META Tag Parsing</title>
+  <script type="text/javascript" src="/MochiKit/packed.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>        
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+<a target="_blank"
+href="https://bugzilla.mozilla.org/show_bug.cgi?id=436083">Mozilla Bug 436083</a>
+<pre id="test">
+<script class="testbody" type="text/javascript">
+<![CDATA[
+
+/** Test for Viewport META Tag **/
+
+SimpleTest.waitForExplicitFinish();
+
+function testViewport() {
+
+  /* We need to access the document headers, which are chrome-only. */
+  netscape.security.PrivilegeManager.enablePrivilege('UniversalXPConnect');
+
+  /* Grab Viewport Metadata from the document header. */
+  var iRequester =
+    window.QueryInterface(Components.interfaces.nsIInterfaceRequestor);
+  var windowUtils =
+    iRequester.getInterface(Components.interfaces.nsIDOMWindowUtils);
+  var vpWidth =
+    parseInt(windowUtils.getDocumentMetadata("viewport-width"));
+  var vpHeight =
+    parseInt(windowUtils.getDocumentMetadata("viewport-height"));
+  var vpInitialScale = 
+    parseFloat(windowUtils.getDocumentMetadata("viewport-initial-scale"));
+  var vpMaxScale = 
+    parseFloat(windowUtils.getDocumentMetadata("viewport-maximum-scale"));
+  var vpMinScale = 
+    parseFloat(windowUtils.getDocumentMetadata("viewport-minimum-scale"));
+  var vpUserScalable = 
+    windowUtils.getDocumentMetadata("viewport-user-scalable");
+
+  is(vpWidth, 4224, "Should get proper width");
+  is(vpHeight, 398, "Should get proper height");
+  is(vpInitialScale, 2.3, "Should get proper initial scale");
+  is(vpMaxScale, 45.2, "Should get proper max scale");
+  is(vpMinScale, 0.1, "Should get proper min scale");
+  is(vpUserScalable, "no", "Should get proper user scalable parameter");
+}
+
+addLoadEvent(testViewport);
+addLoadEvent(SimpleTest.finish);
+]]>
+
+</script>
+</pre>
+</body>
+</html>
diff -r 6c8c95fcaf9b content/xul/templates/src/nsRuleNetwork.cpp
--- a/content/xul/templates/src/nsRuleNetwork.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/content/xul/templates/src/nsRuleNetwork.cpp	Thu Jul 17 14:13:03 2008 +0300
@@ -137,15 +137,14 @@ nsAssignmentSet::Add(const nsAssignment&
 
     // XXXndeakin should this just silently fail?
     if (HasAssignmentFor(aAssignment.mVariable))
         return NS_ERROR_UNEXPECTED;
 
-    List* list = new List;
+    List* list = new List(aAssignment);
     if (! list)
         return NS_ERROR_OUT_OF_MEMORY;
 
-    list->mAssignment = aAssignment;
     list->mRefCnt     = 1;
     list->mNext       = mAssignments;
 
     mAssignments = list;
 
diff -r 6c8c95fcaf9b content/xul/templates/src/nsRuleNetwork.h
--- a/content/xul/templates/src/nsRuleNetwork.h	Tue Jul 15 15:16:43 2008 +1200
+++ b/content/xul/templates/src/nsRuleNetwork.h	Thu Jul 17 14:13:03 2008 +0300
@@ -225,15 +225,12 @@ public:
 /**
  * An assignment of a value to a variable
  */
 class nsAssignment {
 public:
-    nsCOMPtr<nsIAtom> mVariable;
+    const nsCOMPtr<nsIAtom> mVariable;
     nsCOMPtr<nsIRDFNode> mValue;
-
-    nsAssignment() : mValue()
-        { MOZ_COUNT_CTOR(nsAssignment); }
 
     nsAssignment(nsIAtom* aVariable, nsIRDFNode* aValue)
         : mVariable(aVariable),
           mValue(aValue)
         { MOZ_COUNT_CTOR(nsAssignment); }
@@ -242,15 +239,10 @@ public:
         : mVariable(aAssignment.mVariable),
           mValue(aAssignment.mValue)
         { MOZ_COUNT_CTOR(nsAssignment); }
 
     ~nsAssignment() { MOZ_COUNT_DTOR(nsAssignment); }
-
-    nsAssignment& operator=(const nsAssignment& aAssignment) {
-        mVariable = aAssignment.mVariable;
-        mValue    = aAssignment.mValue;
-        return *this; }
 
     PRBool operator==(const nsAssignment& aAssignment) const {
         return mVariable == aAssignment.mVariable && mValue == aAssignment.mValue; }
 
     PRBool operator!=(const nsAssignment& aAssignment) const {
@@ -275,11 +267,12 @@ public:
     friend class ConstIterator;
 
 protected:
     class List {
     public:
-        List() { MOZ_COUNT_CTOR(nsAssignmentSet::List); }
+        List(const nsAssignment &aAssignment) : mAssignment(aAssignment) {
+            MOZ_COUNT_CTOR(nsAssignmentSet::List); }
 
         ~List() {
             MOZ_COUNT_DTOR(nsAssignmentSet::List);
             NS_IF_RELEASE(mNext); }
 
diff -r 6c8c95fcaf9b dom/public/idl/Makefile.in
--- a/dom/public/idl/Makefile.in	Tue Jul 15 15:16:43 2008 +1200
+++ b/dom/public/idl/Makefile.in	Thu Jul 17 14:13:03 2008 +0300
@@ -57,11 +57,12 @@ DIRS =						\
 	xpath					\
 	ls					\
 	xul                                     \
 	storage                                 \
 	json                                    \
-	offline
+	offline                                 \
+	geolocation
 
 ifdef MOZ_SVG
 DIRS += svg
 endif
 
diff -r 6c8c95fcaf9b dom/public/idl/css/nsIDOMCSS2Properties.idl
--- a/dom/public/idl/css/nsIDOMCSS2Properties.idl	Tue Jul 15 15:16:43 2008 +1200
+++ b/dom/public/idl/css/nsIDOMCSS2Properties.idl	Thu Jul 17 14:13:03 2008 +0300
@@ -404,11 +404,11 @@ interface nsIDOMCSS2Properties : nsISupp
 
            attribute DOMString        zIndex;
                                         // raises(DOMException) on setting
 };
 
-[scriptable, uuid(816581b0-3d89-11dd-ae16-0800200c9a66)]
+[scriptable, uuid(f1781ae4-00e6-4751-8698-2925f925fd76)]
 interface nsIDOMNSCSS2Properties : nsIDOMCSS2Properties
 {
            /* Non-DOM 2 extensions */
 
            /* Mozilla extension CSS properties */
@@ -594,6 +594,10 @@ interface nsIDOMNSCSS2Properties : nsIDO
            attribute DOMString        MozStackSizing;
                                         // raises(DOMException) on setting
 
            attribute DOMString        MozBoxShadow;
                                         // raises(DOMException) on setting
+
+           attribute DOMString        MozBorderImage;
+                                        // raises(DOMException) on setting
+
 };
diff -r 6c8c95fcaf9b dom/public/idl/geolocation/Makefile.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/public/idl/geolocation/Makefile.in	Thu Jul 17 14:13:03 2008 +0300
@@ -0,0 +1,57 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org build system.
+#
+# The Initial Developer of the Original Code is Mozilla Corporation
+# Portions created by the Initial Developer are Copyright (C) 2008
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#  Doug Turner <dougt@meer.net>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+
+DEPTH          = ../../../..
+topsrcdir      = @top_srcdir@
+srcdir         = @srcdir@
+VPATH          = @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE         = dom
+XPIDL_MODULE   = dom_geolocation
+GRE_MODULE     = 1
+
+XPIDLSRCS = \
+			nsIDOMGeolocation.idl            \
+			nsIDOMGeolocationCallback.idl    \
+			nsIDOMGeolocator.idl             \
+			nsIDOMNavigatorGeolocator.idl    \
+			nsIGeolocationProvider.idl       \
+            $(NULL)
+
+include $(topsrcdir)/config/rules.mk
diff -r 6c8c95fcaf9b dom/public/idl/geolocation/nsIDOMGeolocation.idl
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/public/idl/geolocation/nsIDOMGeolocation.idl	Thu Jul 17 14:13:03 2008 +0300
@@ -0,0 +1,51 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Geolocation.
+ *
+ * The Initial Developer of the Original Code is Mozilla Corporation
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Doug Turner <dougt@meer.net>  (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+
+#include "domstubs.idl"
+
+[scriptable, uuid(CEEBF85D-F5E2-4E27-981A-0BF8705ABF0A)]
+interface nsIDOMGeolocation : nsISupports
+{
+  readonly attribute double latitude;
+  readonly attribute double longitude;
+  readonly attribute double altitude;
+
+  readonly attribute double horizontalAccuracy;
+  readonly attribute double verticalAccuracy;
+
+  readonly attribute DOMTimeStamp timestamp;
+};
diff -r 6c8c95fcaf9b dom/public/idl/geolocation/nsIDOMGeolocationCallback.idl
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/public/idl/geolocation/nsIDOMGeolocationCallback.idl	Thu Jul 17 14:13:03 2008 +0300
@@ -0,0 +1,45 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Geolocation.
+ *
+ * The Initial Developer of the Original Code is Mozilla Corporation
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Doug Turner <dougt@meer.net>  (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+
+#include "domstubs.idl"
+
+interface nsIDOMGeolocation;
+
+[scriptable, function, uuid(679C8833-5D8C-430D-A7A3-FF13FE082098)]
+interface nsIDOMGeolocationCallback : nsISupports {
+  void onRequest(in nsIDOMGeolocation position);
+};
diff -r 6c8c95fcaf9b dom/public/idl/geolocation/nsIDOMGeolocator.idl
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/public/idl/geolocation/nsIDOMGeolocator.idl	Thu Jul 17 14:13:03 2008 +0300
@@ -0,0 +1,54 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Geolocation.
+ *
+ * The Initial Developer of the Original Code is Mozilla Corporation
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Doug Turner <dougt@meer.net>  (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+
+
+#include "domstubs.idl"
+
+interface nsIDOMGeolocation;
+interface nsIDOMGeolocationCallback;
+
+[scriptable, uuid(3C3B69FF-3AFA-4D4C-BA3A-F03940E74E14)]
+interface nsIDOMGeolocator : nsISupports
+{
+  readonly attribute nsIDOMGeolocation lastPosition;
+
+  void getCurrentPosition(in nsIDOMGeolocationCallback callback);
+
+  unsigned short watchPosition(in nsIDOMGeolocationCallback callback);
+
+  void clearWatch(in unsigned short watchId);
+};
diff -r 6c8c95fcaf9b dom/public/idl/geolocation/nsIDOMNavigatorGeolocator.idl
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/public/idl/geolocation/nsIDOMNavigatorGeolocator.idl	Thu Jul 17 14:13:03 2008 +0300
@@ -0,0 +1,50 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Geolocation.
+ *
+ * The Initial Developer of the Original Code is Mozilla Corporation
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Doug Turner <dougt@meer.net>  (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+
+
+#include "domstubs.idl"
+interface nsIDOMGeolocator;
+
+/**
+ * Property that extends the navigator object.
+ */
+[scriptable, uuid(1470B9BC-F17C-4419-85A4-E6C1742977A3)]
+interface nsIDOMNavigatorGeolocator : nsISupports
+{
+  readonly attribute nsIDOMGeolocator geolocator;
+};
+
diff -r 6c8c95fcaf9b dom/public/idl/geolocation/nsIGeolocationProvider.idl
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/public/idl/geolocation/nsIGeolocationProvider.idl	Thu Jul 17 14:13:03 2008 +0300
@@ -0,0 +1,141 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Geolocation.
+ *
+ * The Initial Developer of the Original Code is Mozilla Corporation
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Doug Turner <dougt@meer.net>  (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+
+
+#include "nsISupports.idl"
+
+interface nsIURI;
+interface nsIDOMWindow;
+interface nsIDOMGeolocation;
+interface nsIGeolocationPrompt;
+
+/**
+ * nsIGeolocationService
+ */
+[scriptable, uuid(68300FFD-802C-431B-BF92-0A657696B853)]
+interface nsIGeolocationService : nsISupports {
+  attribute nsIGeolocationPrompt prompt;
+};
+
+/**
+ * Interface allows access to a geolocation and is passed to
+ * the nsIGeolocationPrompt so that the application can approve
+ * or deny the request.
+ */
+[scriptable, function, uuid(D681C322-C075-4C6E-9765-C22711A4A60E)]
+interface nsIGeolocationRequest : nsISupports {
+
+  readonly attribute nsIURI requestingURI;
+  readonly attribute nsIDOMWindow requestingWindow;
+
+  void cancel();
+  void allow();
+  void allowButFuzz();
+};
+
+/**
+ * Interface provides a way for the application to handle
+ * the UI prompts associated with geolocation.
+ */
+[scriptable, function, uuid(2300C895-1BEE-4297-912C-A57082F3E936)]
+interface nsIGeolocationPrompt : nsISupports {
+  /**
+   * Called when a request has been made to access geolocation data
+   */
+  void prompt(in nsIGeolocationRequest request);
+};
+
+/** 
+ * Interface provides a way for a geolocation provider to
+ * notify the system that a new location is available.
+ */
+[scriptable, uuid(B89D7227-9F04-4236-A582-25A3F2779D72)]
+interface nsIGeolocationUpdate : nsISupports {
+
+  /**
+   * Notify the geolocation service that a new geolocation
+   * has been discovered.
+   * This must be called on the main thread
+   */
+  void update(in nsIDOMGeolocation location);
+};
+
+
+/**
+ * Interface provides location information to the nsGeolocator
+ * via the nsIDOMGeolocationCallback interface.  After
+ * startup is called, any geo location change should call
+ * callback.onRequest().
+ */
+[scriptable, uuid(E319BE2D-B1D1-4CA6-AEF4-66178589B63D)]
+interface nsIGeolocationProvider : nsISupports {
+
+  /**
+   * Start up the provider.  This is called before any other
+   * method.  may be called multiple times.
+   */
+  void startup();
+
+  /**
+   * Returns true when the devices is ready and has a
+   * postion, otherwise false.
+   */
+   boolean isReady();
+
+  /**
+   * watch
+   * When a location change is observed, notify the callback
+   */
+  void watch(in nsIGeolocationUpdate callback);
+
+  /**
+   * currentLocation return the current location as seen by
+   * the provider.  may be null.
+   */
+  readonly attribute nsIDOMGeolocation currentLocation;
+  
+  /**
+   * shutdown
+   * Shuts down the location devices.
+   */
+  void shutdown();
+};
+
+%{C++
+#define NS_GEOLOCATION_SERVICE_CONTRACTID  "@mozilla.org/geolocation/service;1"
+#define NS_GEOLOCATION_PROVIDER_CONTRACTID "@mozilla.org/geolocation/provider;1"
+%}
diff -r 6c8c95fcaf9b dom/public/nsDOMClassInfoID.h
--- a/dom/public/nsDOMClassInfoID.h	Tue Jul 15 15:16:43 2008 +1200
+++ b/dom/public/nsDOMClassInfoID.h	Thu Jul 17 14:13:03 2008 +0300
@@ -422,10 +422,14 @@ enum nsDOMClassInfoID {
 
   // event used for cross-domain message-passing and for server-sent events in
   // HTML5
   eDOMClassInfo_MessageEvent_id,
 
+  // Geolocation
+  eDOMClassInfo_Geolocation_id,
+  eDOMClassInfo_Geolocator_id,
+
   // WhatWG Video Element
 #if defined(MOZ_MEDIA)
   eDOMClassInfo_HTMLVideoElement_id,
   eDOMClassInfo_HTMLSourceElement_id,
   eDOMClassInfo_ProgressEvent_id,
diff -r 6c8c95fcaf9b dom/src/Makefile.in
--- a/dom/src/Makefile.in	Tue Jul 15 15:16:43 2008 +1200
+++ b/dom/src/Makefile.in	Thu Jul 17 14:13:03 2008 +0300
@@ -40,11 +40,11 @@ srcdir		= @srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
-DIRS		= base jsurl events storage offline json
+DIRS		= base jsurl events storage offline json geolocation
 
 include $(topsrcdir)/config/rules.mk
 
 _FILES = \
 	$(srcdir)/res/hiddenWindow.html \
diff -r 6c8c95fcaf9b dom/src/base/Makefile.in
--- a/dom/src/base/Makefile.in	Tue Jul 15 15:16:43 2008 +1200
+++ b/dom/src/base/Makefile.in	Thu Jul 17 14:13:03 2008 +0300
@@ -122,10 +122,11 @@ FORCE_STATIC_LIB = 1
 
 LOCAL_INCLUDES = \
 		-I$(srcdir)/../events \
 		-I$(srcdir)/../storage \
 		-I$(srcdir)/../offline \
+		-I$(srcdir)/../geolocation \
 		-I$(topsrcdir)/content/xbl/src \
 		-I$(topsrcdir)/content/xul/document/src \
 		-I$(topsrcdir)/content/events/src \
 		-I$(topsrcdir)/content/base/src \
 		-I$(topsrcdir)/content/html/document/src \
diff -r 6c8c95fcaf9b dom/src/base/nsDOMClassInfo.cpp
--- a/dom/src/base/nsDOMClassInfo.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/dom/src/base/nsDOMClassInfo.cpp	Thu Jul 17 14:13:03 2008 +0300
@@ -451,10 +451,14 @@
 // Offline includes
 #include "nsIDOMLoadStatusList.h"
 #include "nsIDOMLoadStatus.h"
 #include "nsIDOMLoadStatusEvent.h"
 
+// Geolocation
+#include "nsIDOMGeolocation.h"
+#include "nsIDOMGeolocator.h"
+
 #include "nsIDOMFileList.h"
 #include "nsIDOMFile.h"
 #include "nsIDOMFileException.h"
 
 static NS_DEFINE_CID(kCPluginManagerCID, NS_PLUGINMANAGER_CID);
@@ -1239,10 +1243,16 @@ static nsDOMClassInfoData sClassInfoData
   NS_DEFINE_CLASSINFO_DATA(DataContainerEvent, nsDOMGenericSH,
                            DOM_DEFAULT_SCRIPTABLE_FLAGS)
 
   NS_DEFINE_CLASSINFO_DATA(MessageEvent, nsDOMGenericSH,
                            DOM_DEFAULT_SCRIPTABLE_FLAGS)
+
+  NS_DEFINE_CLASSINFO_DATA(Geolocation, nsDOMGenericSH,
+                           DOM_DEFAULT_SCRIPTABLE_FLAGS)
+ 
+   NS_DEFINE_CLASSINFO_DATA(Geolocator, nsDOMGenericSH,
+                            DOM_DEFAULT_SCRIPTABLE_FLAGS)
 
 #if defined(MOZ_MEDIA) 
   NS_DEFINE_CLASSINFO_DATA(HTMLVideoElement, nsHTMLElementSH,
                            ELEMENT_SCRIPTABLE_FLAGS)
   NS_DEFINE_CLASSINFO_DATA(HTMLSourceElement, nsHTMLElementSH,
@@ -1921,10 +1931,11 @@ nsDOMClassInfo::Init()
   DOM_CLASSINFO_MAP_END
 
   DOM_CLASSINFO_MAP_BEGIN(Navigator, nsIDOMNavigator)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMNavigator)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMJSNavigator)
+    DOM_CLASSINFO_MAP_ENTRY(nsIDOMNavigatorGeolocator)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMClientInformation)
   DOM_CLASSINFO_MAP_END
 
   DOM_CLASSINFO_MAP_BEGIN(Plugin, nsIDOMPlugin)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMPlugin)
@@ -3401,10 +3412,18 @@ nsDOMClassInfo::Init()
   DOM_CLASSINFO_MAP_END
 
   DOM_CLASSINFO_MAP_BEGIN(MessageEvent, nsIDOMMessageEvent)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMMessageEvent)
     DOM_CLASSINFO_EVENT_MAP_ENTRIES
+  DOM_CLASSINFO_MAP_END
+
+  DOM_CLASSINFO_MAP_BEGIN(Geolocation, nsIDOMGeolocation)
+     DOM_CLASSINFO_MAP_ENTRY(nsIDOMGeolocation)
+  DOM_CLASSINFO_MAP_END
+
+  DOM_CLASSINFO_MAP_BEGIN(Geolocator, nsIDOMGeolocator)
+     DOM_CLASSINFO_MAP_ENTRY(nsIDOMGeolocator)
   DOM_CLASSINFO_MAP_END
 
 #if defined(MOZ_MEDIA)
   DOM_CLASSINFO_MAP_BEGIN(HTMLVideoElement, nsIDOMHTMLVideoElement)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMHTMLVideoElement)
diff -r 6c8c95fcaf9b dom/src/base/nsGlobalWindow.cpp
--- a/dom/src/base/nsGlobalWindow.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/dom/src/base/nsGlobalWindow.cpp	Thu Jul 17 14:13:03 2008 +0300
@@ -71,10 +71,11 @@
 #include "nsNetUtil.h"
 #include "nsICachingChannel.h"
 #include "nsPluginArray.h"
 #include "nsIPluginHost.h"
 #include "nsPIPluginHost.h"
+#include "nsGeolocation.h"
 #ifdef OJI
 #include "nsIJVMManager.h"
 #include "nsILiveConnectManager.h"
 #endif
 #include "nsContentCID.h"
@@ -109,10 +110,11 @@
 #include "nsIDOMKeyEvent.h"
 #include "nsIDOMMessageEvent.h"
 #include "nsIDOMPopupBlockedEvent.h"
 #include "nsIDOMPkcs11.h"
 #include "nsIDOMOfflineResourceList.h"
+#include "nsIDOMGeolocation.h"
 #include "nsDOMString.h"
 #include "nsIEmbeddingSiteWindow2.h"
 #include "nsThreadUtils.h"
 #include "nsIEventStateManager.h"
 #include "nsIHttpProtocolHandler.h"
@@ -9006,10 +9008,11 @@ NS_INTERFACE_MAP_BEGIN(nsNavigator)
 NS_INTERFACE_MAP_BEGIN(nsNavigator)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMNavigator)
   NS_INTERFACE_MAP_ENTRY(nsIDOMNavigator)
   NS_INTERFACE_MAP_ENTRY(nsIDOMJSNavigator)
   NS_INTERFACE_MAP_ENTRY(nsIDOMClientInformation)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMNavigatorGeolocator)
   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(Navigator)
 NS_INTERFACE_MAP_END
 
 
 NS_IMPL_ADDREF(nsNavigator)
@@ -9020,10 +9023,17 @@ nsNavigator::SetDocShell(nsIDocShell *aD
 nsNavigator::SetDocShell(nsIDocShell *aDocShell)
 {
   mDocShell = aDocShell;
   if (mPlugins)
     mPlugins->SetDocShell(aDocShell);
+
+  // if there is a page transition, make sure delete the geolocation object
+  if (mGeolocator)
+  {
+    mGeolocator->Shutdown();
+    mGeolocator = nsnull;
+  }
 }
 
 //*****************************************************************************
 //    nsNavigator::nsIDOMNavigator
 //*****************************************************************************
@@ -9540,10 +9550,16 @@ nsNavigator::LoadingNewDocument()
   // Release these so that they will be recreated for the
   // new document (if requested).  The plugins or mime types
   // arrays may have changed.  See bug 150087.
   mMimeTypes = nsnull;
   mPlugins = nsnull;
+
+  if (mGeolocator)
+  {
+    mGeolocator->Shutdown();
+    mGeolocator = nsnull;
+  }
 }
 
 nsresult
 nsNavigator::RefreshMIMEArray()
 {
@@ -9660,5 +9676,22 @@ nsNavigator::MozIsLocallyAvailable(const
   }
 
   return NS_OK;
 }
 
+//*****************************************************************************
+//    nsNavigator::nsIDOMNavigatorGeolocator
+//*****************************************************************************
+
+NS_IMETHODIMP nsNavigator::GetGeolocator(nsIDOMGeolocator **_retval)
+{
+  NS_ENSURE_ARG_POINTER(_retval);
+
+  if (!mGeolocator) {
+    nsCOMPtr<nsIDOMWindow> contentDOMWindow(do_GetInterface(mDocShell));
+    mGeolocator = new nsGeolocator(contentDOMWindow);
+  }
+
+  NS_IF_ADDREF(*_retval = mGeolocator);
+  return NS_OK;
+}
+
diff -r 6c8c95fcaf9b dom/src/base/nsGlobalWindow.h
--- a/dom/src/base/nsGlobalWindow.h	Tue Jul 15 15:16:43 2008 +1200
+++ b/dom/src/base/nsGlobalWindow.h	Thu Jul 17 14:13:03 2008 +0300
@@ -63,10 +63,11 @@
 #include "nsIDOMViewCSS.h"
 #include "nsIDOMEventTarget.h"
 #include "nsIDOM3EventTarget.h"
 #include "nsIDOMNSEventTarget.h"
 #include "nsIDOMNavigator.h"
+#include "nsIDOMNavigatorGeolocator.h"
 #include "nsIDOMNSLocation.h"
 #include "nsIDOMWindowInternal.h"
 #include "nsIInterfaceRequestor.h"
 #include "nsIInterfaceRequestorUtils.h"
 #include "nsIDOMJSWindow.h"
@@ -122,10 +123,11 @@ class nsDummyJavaPluginOwner;
 class nsDummyJavaPluginOwner;
 class PostMessageEvent;
 
 class nsDOMOfflineResourceList;
 class nsDOMOfflineLoadStatusList;
+class nsGeolocator;
 
 // permissible values for CheckOpenAllow
 enum OpenAllowValue {
   allowNot = 0,     // the window opening is denied
   allowNoAbuse,     // allowed: not a popup
@@ -802,20 +804,22 @@ protected:
 // nsNavigator: Script "navigator" object
 //*****************************************************************************
 
 class nsNavigator : public nsIDOMNavigator,
                     public nsIDOMJSNavigator,
-                    public nsIDOMClientInformation
+                    public nsIDOMClientInformation,
+                    public nsIDOMNavigatorGeolocator
 {
 public:
   nsNavigator(nsIDocShell *aDocShell);
   virtual ~nsNavigator();
 
   NS_DECL_ISUPPORTS
   NS_DECL_NSIDOMNAVIGATOR
   NS_DECL_NSIDOMJSNAVIGATOR
   NS_DECL_NSIDOMCLIENTINFORMATION
+  NS_DECL_NSIDOMNAVIGATORGEOLOCATOR
   
   void SetDocShell(nsIDocShell *aDocShell);
   nsIDocShell *GetDocShell()
   {
     return mDocShell;
@@ -825,10 +829,11 @@ public:
   nsresult RefreshMIMEArray();
 
 protected:
   nsRefPtr<nsMimeTypeArray> mMimeTypes;
   nsRefPtr<nsPluginArray> mPlugins;
+  nsRefPtr<nsGeolocator> mGeolocator;
   nsIDocShell* mDocShell; // weak reference
 
   static jsval       sPrefInternal_id;
 };
 
diff -r 6c8c95fcaf9b dom/src/geolocation/MaemoLocationProvider.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/src/geolocation/MaemoLocationProvider.cpp	Thu Jul 17 14:13:03 2008 +0300
@@ -0,0 +1,119 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Geolocation.
+ *
+ * The Initial Developer of the Original Code is Mozilla Corporation
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Doug Turner <dougt@meer.net>  (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+
+
+#include "MaemoLocationProvider.h"
+#include "nsGeolocation.h"
+
+NS_IMPL_ISUPPORTS1(MaemoLocationProvider, nsIGeolocationProvider)
+
+MaemoLocationProvider::MaemoLocationProvider()
+: mGPSDevice(nsnull), mLocationCallbackHandle(0), mHasSeenLocation(PR_FALSE)
+{
+}
+
+MaemoLocationProvider::~MaemoLocationProvider()
+{
+}
+
+void location_changed (LocationGPSDevice *device, gpointer userdata)
+{
+  MaemoLocationProvider* provider = (MaemoLocationProvider*) userdata;
+  nsRefPtr<nsGeolocation> somewhere = new nsGeolocation(device->fix->latitude,
+                                                        device->fix->longitude,
+                                                        device->fix->altitude,
+                                                        device->fix->eph,
+                                                        device->fix->epv,
+                                                        device->fix->time);
+  provider->Update(somewhere);
+}
+
+NS_IMETHODIMP MaemoLocationProvider::Startup()
+{
+  if (!mGPSDevice)
+  {
+    // if we are already started, don't do anything
+    memset(&mGPSBT, 0, sizeof(gpsbt_t));
+    int result = gpsbt_start(NULL, 0, 0, 0, NULL, 0, 0, &mGPSBT);
+    if (result <0)
+      return NS_ERROR_NOT_AVAILABLE;
+    
+    mGPSDevice = (LocationGPSDevice*) g_object_new (LOCATION_TYPE_GPS_DEVICE, NULL);
+    mLocationCallbackHandle = g_signal_connect (mGPSDevice, "changed", G_CALLBACK (location_changed), this->mCallback);
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP MaemoLocationProvider::IsReady(PRBool *_retval NS_OUTPARAM)
+{
+  *_retval = mHasSeenLocation;
+  return NS_OK;
+}
+
+NS_IMETHODIMP MaemoLocationProvider::Watch(nsIGeolocationUpdate *callback)
+{
+  mCallback = callback; // weak ref
+  return NS_OK;
+}
+
+/* readonly attribute nsIDOMGeolocation currentLocation; */
+NS_IMETHODIMP MaemoLocationProvider::GetCurrentLocation(nsIDOMGeolocation * *aCurrentLocation)
+{
+  NS_IF_ADDREF(*aCurrentLocation = mLastLocation);
+  return NS_OK;
+}
+
+NS_IMETHODIMP MaemoLocationProvider::Shutdown()
+{
+  if (mGPSDevice && mLocationCallbackHandle) {
+    g_signal_handler_disconnect(mGPSDevice, mLocationCallbackHandle);
+    g_object_unref(mGPSDevice);
+    gpsbt_stop(&mGPSBT);
+    mLocationCallbackHandle = 0;
+    mGPSDevice = nsnull;
+    mHasSeenLocation = PR_FALSE;
+  }
+  return NS_OK;
+}
+
+void MaemoLocationProvider::Update(nsIDOMGeolocation* aLocation)
+{
+  mHasSeenLocation = PR_TRUE;
+  mLastLocation = aLocation;
+  if (mCallback)
+    mCallback->Update(aLocation);
+}
diff -r 6c8c95fcaf9b dom/src/geolocation/MaemoLocationProvider.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/src/geolocation/MaemoLocationProvider.h	Thu Jul 17 14:13:03 2008 +0300
@@ -0,0 +1,75 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Geolocation.
+ *
+ * The Initial Developer of the Original Code is Mozilla Corporation
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Doug Turner <dougt@meer.net>  (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsIGeolocationProvider.h"
+#include "nsIDOMGeolocation.h"
+#include "nsCOMPtr.h"
+
+#include <glib.h>
+#include <errno.h>
+#include <gpsbt.h>
+#include <gpsmgr.h>
+
+extern "C" {
+  // need to extern these because of:
+  // https://bugs.maemo.org/show_bug.cgi?id=3226
+  #include <location/location-gps-device.h>
+  #include <location/location-gpsd-control.h>
+}
+
+class MaemoLocationProvider : public nsIGeolocationProvider
+{
+public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIGEOLOCATIONPROVIDER
+
+  MaemoLocationProvider();
+
+  void Update(nsIDOMGeolocation* aLocation);
+
+private:
+  ~MaemoLocationProvider();
+
+  nsCOMPtr<nsIDOMGeolocation> mLastLocation;
+
+  nsIGeolocationUpdate* mCallback; // weak reference by contract.
+
+
+  gpsbt_t mGPSBT;
+  LocationGPSDevice *mGPSDevice;
+  gulong mLocationCallbackHandle;
+  PRBool mHasSeenLocation;
+};
diff -r 6c8c95fcaf9b dom/src/geolocation/Makefile.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/src/geolocation/Makefile.in	Thu Jul 17 14:13:03 2008 +0300
@@ -0,0 +1,84 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org build system.
+#
+# The Initial Developer of the Original Code is Mozilla Corporation
+# Portions created by the Initial Developer are Copyright (C) 2008
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#  Doug Turner <dougt@meer.net>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE         = dom
+LIBRARY_NAME   = jsdomgeolocation_s
+LIBXUL_LIBRARY = 1
+
+# we don't want the shared lib, but we want to force the creation of a static lib.
+FORCE_STATIC_LIB = 1
+
+REQUIRES = \
+        xpcom \
+		content \
+        layout \
+		pref \
+		widget \
+		string \
+		dom \
+		js \
+		caps \
+		xpconnect\
+		intl \
+		necko \
+		windowwatcher \
+		$(NULL)
+
+CPPSRCS		= \
+		nsGeolocation.cpp \
+		$(NULL)
+
+EXTRA_DSO_LDOPTS = \
+		$(MOZ_COMPONENT_LIBS) \
+		$(NULL)
+
+LOCAL_INCLUDES = \
+		-I$(srcdir)/../base \
+		$(NULL)
+
+ifdef NS_OSSO
+CPPSRCS		+= MaemoLocationProvider.cpp
+LOCAL_INCLUDES	+= $(MOZ_GTK2_CFLAGS)
+endif
+
+include $(topsrcdir)/config/rules.mk
diff -r 6c8c95fcaf9b dom/src/geolocation/nsGeolocation.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/src/geolocation/nsGeolocation.cpp	Thu Jul 17 14:13:03 2008 +0300
@@ -0,0 +1,612 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Geolocation.
+ *
+ * The Initial Developer of the Original Code is Mozilla Corporation
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Doug Turner <dougt@meer.net>  (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsGeolocation.h"
+#include "nsAutoPtr.h"
+#include "nsCOMPtr.h"
+#include "nsIDOMWindow.h"
+#include "nsDOMClassInfo.h"
+#include "nsComponentManagerUtils.h"
+#include "nsServiceManagerUtils.h"
+#include "nsContentUtils.h"
+#include "nsIURI.h"
+#include "nsIPermissionManager.h"
+#include "nsIObserverService.h"
+#include "nsIPrefService.h"
+#include "nsIPrefBranch2.h"
+
+#ifdef NS_OSSO
+#include "MaemoLocationProvider.h"
+#endif
+
+#include "nsIDOMDocument.h"
+#include "nsIDocument.h"
+////////////////////////////////////////////////////
+// nsGeolocationRequest
+////////////////////////////////////////////////////
+
+nsGeolocationRequest::nsGeolocationRequest(nsGeolocator* locator, nsIDOMGeolocationCallback* callback)
+  : mAllowed(PR_FALSE), mCleared(PR_FALSE), mFuzzLocation(PR_FALSE), mCallback(callback), mLocator(locator)
+{
+}
+
+nsGeolocationRequest::~nsGeolocationRequest()
+{
+}
+
+NS_INTERFACE_MAP_BEGIN(nsGeolocationRequest)
+  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIGeolocationRequest)
+  NS_INTERFACE_MAP_ENTRY(nsIGeolocationRequest)
+NS_INTERFACE_MAP_END
+
+NS_IMPL_ADDREF(nsGeolocationRequest)
+NS_IMPL_RELEASE(nsGeolocationRequest)
+
+NS_IMETHODIMP
+nsGeolocationRequest::GetRequestingURI(nsIURI * *aRequestingURI)
+{
+  NS_ENSURE_ARG_POINTER(aRequestingURI);
+  *aRequestingURI = mLocator->GetURI();
+  NS_IF_ADDREF(*aRequestingURI);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsGeolocationRequest::GetRequestingWindow(nsIDOMWindow * *aRequestingWindow)
+{
+  NS_ENSURE_ARG_POINTER(aRequestingWindow);
+  *aRequestingWindow = mLocator->GetOwner();
+  NS_IF_ADDREF(*aRequestingWindow);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsGeolocationRequest::Cancel()
+{
+  // pass a null back.
+  mCallback->OnRequest(nsnull);
+
+  // remove ourselves from the locators callback lists.
+  mLocator->RemoveRequest(this);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsGeolocationRequest::Allow()
+{
+  // Kick off the geo device, if it isn't already running
+  nsRefPtr<nsGeolocatorService> geoService = nsGeolocatorService::GetInstance();
+  geoService->StartDevice();
+
+  mAllowed = PR_TRUE;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsGeolocationRequest::AllowButFuzz()
+{
+  mFuzzLocation = PR_TRUE;
+  return Allow();
+}
+
+void
+nsGeolocationRequest::MarkCleared()
+{
+  mCleared = PR_TRUE;
+}
+
+void
+nsGeolocationRequest::SendLocation(nsIDOMGeolocation* location)
+{
+  if (mCleared)
+    return;
+
+  //TODO mFuzzLocation.  Needs to be defined what we do here.
+  if (mFuzzLocation)
+  {
+    // need to make a copy because nsIDOMGeolocation is
+    // readonly, and we are not sure of its implementation.
+
+    double lat, lon, alt, herror, verror;
+    DOMTimeStamp time;
+    location->GetLatitude(&lat);
+    location->GetLongitude(&lon);
+    location->GetAltitude(&alt);
+    location->GetHorizontalAccuracy(&herror);
+    location->GetVerticalAccuracy(&verror);
+    location->GetTimestamp(&time); 
+
+    // do something to the numbers...  TODO.
+    
+    // mask out any location until we figure out how to fuzz locations;
+    lat = 0; lon = 0; alt = 0; herror = 100000; verror = 100000;
+
+    nsRefPtr<nsGeolocation> somewhere = new nsGeolocation(lat,
+                                                          lon,
+                                                          alt,
+                                                          herror,
+                                                          verror,
+                                                          time);
+    mCallback->OnRequest(somewhere);
+    return;
+  }
+  
+  mCallback->OnRequest(location);
+}
+
+void
+nsGeolocationRequest::Shutdown()
+{
+  mCleared = PR_TRUE;
+  mCallback = nsnull;
+}
+
+////////////////////////////////////////////////////
+// nsGeolocation
+////////////////////////////////////////////////////
+NS_INTERFACE_MAP_BEGIN(nsGeolocation)
+  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMGeolocation)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMGeolocation)
+  NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(Geolocation)
+NS_INTERFACE_MAP_END
+
+NS_IMPL_THREADSAFE_ADDREF(nsGeolocation)
+NS_IMPL_THREADSAFE_RELEASE(nsGeolocation)
+
+NS_IMETHODIMP
+nsGeolocation::GetLatitude(double *aLatitude)
+{
+  *aLatitude = mLat;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsGeolocation::GetLongitude(double *aLongitude)
+{
+  *aLongitude = mLong;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsGeolocation::GetAltitude(double *aAltitude)
+{
+  *aAltitude = mAlt;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsGeolocation::GetHorizontalAccuracy(double *aHorizontalAccuracy)
+{
+  *aHorizontalAccuracy = mHError;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsGeolocation::GetVerticalAccuracy(double *aVerticalAccuracy)
+{
+  *aVerticalAccuracy = mVError;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsGeolocation::GetTimestamp(DOMTimeStamp* aTimestamp)
+{
+  *aTimestamp = mTimestamp;
+  return NS_OK;
+}
+
+////////////////////////////////////////////////////
+// nsGeolocatorService
+////////////////////////////////////////////////////
+NS_INTERFACE_MAP_BEGIN(nsGeolocatorService)
+  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIGeolocationUpdate)
+  NS_INTERFACE_MAP_ENTRY(nsIGeolocationUpdate)
+  NS_INTERFACE_MAP_ENTRY(nsIGeolocationService)
+  NS_INTERFACE_MAP_ENTRY(nsIObserver)
+NS_INTERFACE_MAP_END
+
+NS_IMPL_THREADSAFE_ADDREF(nsGeolocatorService)
+NS_IMPL_THREADSAFE_RELEASE(nsGeolocatorService)
+
+nsGeolocatorService::nsGeolocatorService()
+{
+  nsCOMPtr<nsIObserverService> obs = do_GetService("@mozilla.org/observer-service;1");
+  if (obs) {
+    obs->AddObserver(this, "quit-application", false);
+  }
+
+  mTimeout = nsContentUtils::GetIntPref("geo.timeout", 6000);
+}
+
+nsGeolocatorService::~nsGeolocatorService()
+{
+}
+
+NS_IMETHODIMP
+nsGeolocatorService::Observe(nsISupports* aSubject, const char* aTopic,
+                             const PRUnichar* aData)
+{
+  if (!strcmp("quit-application", aTopic))
+  {
+    nsCOMPtr<nsIObserverService> obs = do_GetService("@mozilla.org/observer-service;1");
+    if (obs) {
+      obs->RemoveObserver(this, "quit-application");
+    }
+
+    for (PRUint32 i = 0; i< mGeolocators.Length(); i++)
+      mGeolocators[i]->Shutdown();
+
+    StopDevice();
+
+    // Remove our reference to any prompt that may have been set.
+    mPrompt = nsnull;
+    return NS_OK;
+  }
+  
+  if (!strcmp("timer-callback", aTopic))
+  {
+    // decide if we can close down the service.
+    for (PRUint32 i = 0; i< mGeolocators.Length(); i++)
+      if (mGeolocators[i]->HasActiveCallbacks())
+      {
+        SetDisconnectTimer();
+        return NS_OK;
+      }
+    
+    // okay to close up.
+    StopDevice();
+    Update(nsnull);
+    return NS_OK;
+  }
+
+  return NS_ERROR_FAILURE;
+}
+
+NS_IMETHODIMP
+nsGeolocatorService::GetPrompt(nsIGeolocationPrompt * *aPrompt)
+{
+  NS_ENSURE_ARG_POINTER(aPrompt);
+  *aPrompt = mPrompt;
+  NS_IF_ADDREF(*aPrompt);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsGeolocatorService::SetPrompt(nsIGeolocationPrompt * aPrompt)
+{
+  mPrompt = aPrompt;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsGeolocatorService::Update(nsIDOMGeolocation *somewhere)
+{
+  for (PRUint32 i = 0; i< mGeolocators.Length(); i++)
+    mGeolocators[i]->Update(somewhere);
+  return NS_OK;
+}
+
+already_AddRefed<nsIDOMGeolocation>
+nsGeolocatorService::GetLastKnownPosition()
+{
+  nsIDOMGeolocation* location = nsnull;
+  if (mProvider)
+    mProvider->GetCurrentLocation(&location);
+
+  return location;
+}
+
+PRBool
+nsGeolocatorService::IsDeviceReady()
+{
+  PRBool ready = PR_FALSE;
+  if (mProvider)
+    mProvider->IsReady(&ready);
+
+  return ready;
+}
+
+nsresult
+nsGeolocatorService::StartDevice()
+{
+  if (!mProvider)
+  {
+    // Check to see if there is an override in place. if so, use it.
+    mProvider = do_GetService(NS_GEOLOCATION_PROVIDER_CONTRACTID);
+
+    // if NS_OSSO, see if we should try the MAEMO location provider
+#ifdef NS_OSSO
+    if (!mProvider)
+    {
+      // guess not, lets try a default one:  
+      mProvider = new MaemoLocationProvider();
+    }
+#endif
+
+    if (!mProvider)
+      return NS_ERROR_NOT_AVAILABLE;
+    
+    // if we have one, start it up.
+    nsresult rv = mProvider->Startup();
+    if (NS_FAILED(rv)) 
+      return NS_ERROR_NOT_AVAILABLE;;
+    
+    // lets monitor it for any changes.
+    mProvider->Watch(this);
+    
+    // we do not want to keep the geolocation devices online
+    // indefinitely.  Close them down after a reasonable period of
+    // inactivivity
+    SetDisconnectTimer();
+  }
+
+  return NS_OK;
+}
+
+void
+nsGeolocatorService::SetDisconnectTimer()
+{
+  if (!mDisconnectTimer)
+    mDisconnectTimer = do_CreateInstance("@mozilla.org/timer;1");
+  else
+    mDisconnectTimer->Cancel();
+
+  mDisconnectTimer->Init(this,
+                         mTimeout,
+                         nsITimer::TYPE_ONE_SHOT);
+}
+
+void 
+nsGeolocatorService::StopDevice()
+{
+  if (mProvider) {
+    mProvider->Shutdown();
+    mProvider = nsnull;
+  }
+
+  if(mDisconnectTimer) {
+    mDisconnectTimer->Cancel();
+    mDisconnectTimer = nsnull;
+  }
+}
+
+nsGeolocatorService* nsGeolocatorService::gService = nsnull;
+
+nsGeolocatorService*
+nsGeolocatorService::GetInstance()
+{
+  if (!nsGeolocatorService::gService) {
+    nsGeolocatorService::gService = new nsGeolocatorService();
+  }
+  return nsGeolocatorService::gService;
+}
+
+nsGeolocatorService*
+nsGeolocatorService::GetGeolocationService()
+{
+  nsGeolocatorService* inst = nsGeolocatorService::GetInstance();
+  NS_ADDREF(inst);
+  return inst;
+}
+
+void
+nsGeolocatorService::AddLocator(nsGeolocator* locator)
+{
+  mGeolocators.AppendElement(locator);
+}
+
+void
+nsGeolocatorService::RemoveLocator(nsGeolocator* locator)
+{
+  mGeolocators.RemoveElement(locator);
+}
+
+////////////////////////////////////////////////////
+// nsGeolocator
+////////////////////////////////////////////////////
+
+NS_INTERFACE_MAP_BEGIN(nsGeolocator)
+  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMGeolocator)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMGeolocator)
+  NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(Geolocator)
+NS_INTERFACE_MAP_END
+
+NS_IMPL_ADDREF(nsGeolocator)
+NS_IMPL_RELEASE(nsGeolocator)
+
+nsGeolocator::nsGeolocator(nsIDOMWindow* contentDom) 
+: mUpdateInProgress(PR_FALSE)
+{
+  // Remember the window
+  nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(contentDom);
+  if (window)
+    mOwner = window->GetCurrentInnerWindow();
+
+  // Grab the uri of the document
+  nsCOMPtr<nsIDOMDocument> domdoc;
+  contentDom->GetDocument(getter_AddRefs(domdoc));
+  nsCOMPtr<nsIDocument> doc = do_QueryInterface(domdoc);
+  if (doc)
+    doc->NodePrincipal()->GetURI(getter_AddRefs(mURI));
+
+  mService = nsGeolocatorService::GetInstance();
+  if (mService)
+    mService->AddLocator(this);
+}
+
+nsGeolocator::~nsGeolocator()
+{
+}
+
+void
+nsGeolocator::Shutdown()
+{
+  // Shutdown and release all callbacks
+  for (PRInt32 i = 0; i< mPendingCallbacks.Count(); i++)
+    mPendingCallbacks[i]->Shutdown();
+  mPendingCallbacks.Clear();
+
+  for (PRInt32 i = 0; i< mWatchingCallbacks.Count(); i++)
+    mWatchingCallbacks[i]->Shutdown();
+  mWatchingCallbacks.Clear();
+
+  if (mService)
+    mService->RemoveLocator(this);
+
+  mService = nsnull;
+  mOwner = nsnull;
+  mURI = nsnull;
+}
+
+PRBool
+nsGeolocator::HasActiveCallbacks()
+{
+  return (PRBool) mWatchingCallbacks.Count();
+}
+
+void
+nsGeolocator::RemoveRequest(nsGeolocationRequest* request)
+{
+  mPendingCallbacks.RemoveObject(request);
+
+  // if it is in the mWatchingCallbacks, we can't do much
+  // since we passed back the position in the array to who
+  // ever called WatchPosition() and we do not want to mess
+  // around with the ordering of the array.  Instead, just
+  // mark the request as "cleared".
+
+  request->MarkCleared();
+}
+
+void
+nsGeolocator::Update(nsIDOMGeolocation *somewhere)
+{
+  // This method calls out to objects which may spin and
+  // event loop which may add new location objects into
+  // mPendingCallbacks, and mWatchingCallbacks.  Since this
+  // function can only be called on the primary thread, we
+  // can lock this method with a member var.
+
+  if (mUpdateInProgress)
+    return;
+
+  mUpdateInProgress = PR_TRUE;
+  if (!OwnerStillExists())
+  {
+    Shutdown();
+    return;
+  }
+
+  // notify anyone that has been waiting
+  for (PRInt32 i = 0; i< mPendingCallbacks.Count(); i++)
+    mPendingCallbacks[i]->SendLocation(somewhere);
+  mPendingCallbacks.Clear();
+
+  // notify everyone that is watching
+  for (PRInt32 i = 0; i< mWatchingCallbacks.Count(); i++)
+      mWatchingCallbacks[i]->SendLocation(somewhere);
+
+  mUpdateInProgress = PR_FALSE;
+}
+
+NS_IMETHODIMP
+nsGeolocator::GetLastPosition(nsIDOMGeolocation * *aLastPosition)
+{
+  // we are advocating that this method be removed.
+  NS_ENSURE_ARG_POINTER(aLastPosition);
+  *aLastPosition = nsnull;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsGeolocator::GetCurrentPosition(nsIDOMGeolocationCallback *callback)
+{
+  nsIGeolocationPrompt* prompt = mService->GetPrompt();
+  if (prompt == nsnull)
+    return NS_ERROR_NOT_AVAILABLE;
+
+  nsRefPtr<nsGeolocationRequest> request = new nsGeolocationRequest(this, callback);
+  prompt->Prompt(request);
+
+  // What if you have a location provider that only sends a location once, then stops.?  fix.
+  mPendingCallbacks.AppendObject(request);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsGeolocator::WatchPosition(nsIDOMGeolocationCallback *callback, PRUint16 *_retval NS_OUTPARAM)
+{
+  nsIGeolocationPrompt* prompt = mService->GetPrompt();
+  if (prompt == nsnull)
+    return NS_ERROR_NOT_AVAILABLE;
+    
+  nsRefPtr<nsGeolocationRequest> request = new nsGeolocationRequest(this, callback);
+  prompt->Prompt(request);
+
+  // need to hand back an index/reference.
+  mWatchingCallbacks.AppendObject(request);
+  *_retval = mWatchingCallbacks.Count() - 1;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsGeolocator::ClearWatch(PRUint16 watchId)
+{
+  mWatchingCallbacks[watchId]->MarkCleared();
+  return NS_OK;
+}
+
+PRBool
+nsGeolocator::OwnerStillExists()
+{
+  if (!mOwner)
+    return PR_FALSE;
+
+  nsCOMPtr<nsIDOMWindowInternal> domWindow(mOwner);
+  if (domWindow)
+  {
+    PRBool closed = PR_FALSE;
+    domWindow->GetClosed(&closed);
+    if (closed)
+      return PR_FALSE;
+  }
+
+  nsPIDOMWindow* outer = mOwner->GetOuterWindow();
+  if (!outer || outer->GetCurrentInnerWindow() != mOwner)
+    return PR_FALSE;
+
+  return PR_TRUE;
+}
diff -r 6c8c95fcaf9b dom/src/geolocation/nsGeolocation.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/src/geolocation/nsGeolocation.h	Thu Jul 17 14:13:03 2008 +0300
@@ -0,0 +1,224 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Geolocation.
+ *
+ * The Initial Developer of the Original Code is Mozilla Corporation
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Doug Turner <dougt@meer.net>  (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+
+#include "nsCOMPtr.h"
+#include "nsAutoPtr.h"
+#include "nsCOMArray.h"
+#include "nsTArray.h"
+#include "nsITimer.h"
+#include "nsIObserver.h"
+#include "nsIURI.h"
+
+#include "nsIDOMGeolocation.h"
+#include "nsIDOMGeolocation.h"
+#include "nsIDOMGeolocationCallback.h"
+#include "nsIDOMGeolocator.h"
+#include "nsIDOMNavigatorGeolocator.h"
+
+#include "nsPIDOMWindow.h"
+
+#include "nsIGeolocationProvider.h"
+
+class nsGeolocator;
+class nsGeolocatorService;
+
+
+class nsGeolocationRequest : public nsIGeolocationRequest
+{
+ public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIGEOLOCATIONREQUEST
+
+  nsGeolocationRequest(nsGeolocator* locator, nsIDOMGeolocationCallback* callback);
+  void Shutdown();
+
+  void SendLocation(nsIDOMGeolocation* location);
+  void MarkCleared();
+  PRBool Allowed() {return mAllowed;}
+
+  ~nsGeolocationRequest();
+
+ private:
+  PRBool mAllowed;
+  PRBool mCleared;
+  PRBool mFuzzLocation;
+
+  nsCOMPtr<nsIDOMGeolocationCallback> mCallback;
+
+  nsGeolocator* mLocator; // The locator exists alonger than this object.
+};
+
+/**
+ * Simple object that holds a single point in space.
+ */ 
+class nsGeolocation : public nsIDOMGeolocation
+{
+public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIDOMGEOLOCATION
+
+    nsGeolocation(double aLat, double aLong, double aAlt, double aHError, double aVError, long long aTimestamp)
+    : mLat(aLat), mLong(aLong), mAlt(aAlt), mHError(aHError), mVError(aVError), mTimestamp(aTimestamp){};
+
+private:
+  ~nsGeolocation(){}
+  double mLat, mLong, mAlt, mHError, mVError;
+  long long mTimestamp;
+};
+
+/**
+ * Singleton that manages the geolocation provider
+ */
+class nsGeolocatorService : public nsIGeolocationService, public nsIGeolocationUpdate, public nsIObserver
+{
+public:
+
+  static nsGeolocatorService* GetGeolocationService();
+  static nsGeolocatorService* GetInstance();  // Non-Addref'ing
+  static nsGeolocatorService* gService;
+
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIGEOLOCATIONUPDATE
+  NS_DECL_NSIOBSERVER
+  NS_DECL_NSIGEOLOCATIONSERVICE
+
+  nsGeolocatorService();
+
+  // Management of the nsGeolocator objects
+  void AddLocator(nsGeolocator* locator);
+  void RemoveLocator(nsGeolocator* locator);
+
+  // Returns the last geolocation we have seen since calling StartDevice()
+  already_AddRefed<nsIDOMGeolocation> GetLastKnownPosition();
+  
+  // Returns the application defined UI prompt
+  nsIGeolocationPrompt* GetPrompt() { return mPrompt; } // does not addref.
+
+  // Returns true if the we have successfully found and started a
+  // geolocation device
+  PRBool   IsDeviceReady();
+
+  // Find and startup a geolocation device (gps, nmea, etc.)
+  nsresult StartDevice();
+
+  // Stop the started geolocation device (gps, nmea, etc.)
+  void     StopDevice();
+  
+  // create, or reinitalize the callback timer
+  void     SetDisconnectTimer();
+
+private:
+
+  ~nsGeolocatorService();
+
+  // Disconnect timer.  When this timer expires, it clears all pending callbacks
+  // and closes down the provider, unless we are watching a point, and in that
+  // case, we disable the disconnect timer.
+  nsCOMPtr<nsITimer> mDisconnectTimer;
+
+  // Time, in milliseconds, to wait for the location provider to spin up.
+  PRInt32 mTimeout;
+
+  // The object providing geo location information to us.
+  nsCOMPtr<nsIGeolocationProvider> mProvider;
+
+  // mGeolocators are not owned here.  Their constructor
+  // addes them to this list, and their destructor removes
+  // them from this list.
+  nsTArray<nsGeolocator*> mGeolocators;
+
+  // prompt callback, if any
+  nsCOMPtr<nsIGeolocationPrompt> mPrompt;
+};
+
+
+/**
+ * Can return a geolocation info
+ */ 
+class nsGeolocator : public nsIDOMGeolocator
+{
+public:
+
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIDOMGEOLOCATOR
+
+  nsGeolocator(nsIDOMWindow* contentDom);
+
+  // Called by the geolocation device to notify that a location has changed.
+  void Update(nsIDOMGeolocation* aLocation);
+
+  // Returns true if any of the callbacks are repeating
+  PRBool   HasActiveCallbacks();
+
+  // Remove request from all callbacks arrays
+  void     RemoveRequest(nsGeolocationRequest* request);
+
+  // Shutting down.
+  void     Shutdown();
+
+  // Setter and Getter of the URI that this nsGeolocator was loaded from
+  nsIURI* GetURI() { return mURI; }
+
+  // Setter and Getter of the window that this nsGeolocator is owned by
+  nsIDOMWindow* GetOwner() { return mOwner; }
+
+  // Check to see if the widnow still exists
+  PRBool OwnerStillExists();
+
+private:
+
+  ~nsGeolocator();
+
+  // Two callback arrays.  The first |mPendingCallbacks| holds objects for only
+  // one callback and then they are released/removed from the array.  The second
+  // |mWatchingCallbacks| holds objects until the object is explictly removed or
+  // there is a page change.
+
+  nsCOMArray<nsGeolocationRequest> mPendingCallbacks;
+  nsCOMArray<nsGeolocationRequest> mWatchingCallbacks;
+
+  PRBool mUpdateInProgress;
+
+  // window that this was created for.  Weak reference.
+  nsPIDOMWindow* mOwner;
+
+  // where the content was loaded from
+  nsCOMPtr<nsIURI> mURI;
+
+  // owning back pointer.
+  nsRefPtr<nsGeolocatorService> mService;
+};
diff -r 6c8c95fcaf9b dom/tests/mochitest/Makefile.in
--- a/dom/tests/mochitest/Makefile.in	Tue Jul 15 15:16:43 2008 +1200
+++ b/dom/tests/mochitest/Makefile.in	Thu Jul 17 14:13:03 2008 +0300
@@ -48,10 +48,11 @@ DIRS	+= \
 	dom-level2-core \
 	ajax \
 	bugs \
 	chrome \
 	whatwg \
+	geolocation \
 	$(NULL)
 
 # dom-level2-html disabled due to failures on multiple platforms
 # (bug 427878)
 #	dom-level2-html \
diff -r 6c8c95fcaf9b dom/tests/mochitest/geolocation/Makefile.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/tests/mochitest/geolocation/Makefile.in	Thu Jul 17 14:13:03 2008 +0300
@@ -0,0 +1,58 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org build system.
+#
+# The Initial Developer of the Original Code is Mozilla Corporation
+# Portions created by the Initial Developer are Copyright (C) 2008
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#  Doug Turner <dougt@meer.net>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+relativesrcdir	= dom/tests/mochitest/geolocation
+
+include $(DEPTH)/config/autoconf.mk
+
+include $(topsrcdir)/config/rules.mk
+
+_TEST_FILES	= \
+		test_lastPosition.html \
+		test_manyWindows.html \
+		prompt_common.js       \
+		geolocation_common.js  \
+		geolocator.html \
+		$(NULL)
+
+
+libs:: 	$(_TEST_FILES)
+	$(INSTALL) $(foreach f,$^,"$f") $(DEPTH)/_tests/testing/mochitest/tests/$(relativesrcdir)
+
diff -r 6c8c95fcaf9b dom/tests/mochitest/geolocation/geolocation_common.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/tests/mochitest/geolocation/geolocation_common.js	Thu Jul 17 14:13:03 2008 +0300
@@ -0,0 +1,12 @@
+function check_geolocation(location) {
+
+  ok(location, "Check to see if this location is non-null");
+
+  ok(location.latitude, "Check to see if there is a latitude");
+  ok(location.longitude, "Check to see if there is a longitude");
+  ok(location.altitude, "Check to see if there is a altitude");
+  ok(location.horizontalAccuracy, "Check to see if there is a horizontalAccuracy");
+  ok(location.verticalAccuracy, "Check to see if there is a verticalAccuracy");
+  ok(location.timestamp, "Check to see if there is a timestamp");
+
+}
diff -r 6c8c95fcaf9b dom/tests/mochitest/geolocation/geolocator.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/tests/mochitest/geolocation/geolocator.html	Thu Jul 17 14:13:03 2008 +0300
@@ -0,0 +1,12 @@
+<html> <head>
+<title>Simple access of geolocator</title>
+<script>
+
+document.writeln(navigator.geolocator);
+
+</script>
+</head>
+<body>
+<p>
+</body>
+</html>
diff -r 6c8c95fcaf9b dom/tests/mochitest/geolocation/prompt_common.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/tests/mochitest/geolocation/prompt_common.js	Thu Jul 17 14:13:03 2008 +0300
@@ -0,0 +1,75 @@
+netscape.security.PrivilegeManager.enablePrivilege('UniversalXPConnect');
+
+const Ci = Components.interfaces;
+ok(Ci != null, "Access Ci");
+const Cc = Components.classes;
+ok(Cc != null, "Access Cc");
+
+var didDialog;
+
+var timer; // keep in outer scope so it's not GC'd before firing
+function startCallbackTimer() {
+    netscape.security.PrivilegeManager.enablePrivilege('UniversalXPConnect');
+    didDialog = false;
+
+    // Delay before the callback twiddles the prompt.
+    const dialogDelay = 10;
+
+    // Use a timer to invoke a callback to twiddle the authentication dialog
+    timer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
+    timer.init(observer, dialogDelay, Ci.nsITimer.TYPE_ONE_SHOT);
+}
+
+var observer = {
+    QueryInterface : function (iid) {
+        const interfaces = [Ci.nsIObserver,
+                            Ci.nsISupports, Ci.nsISupportsWeakReference];
+
+        if (!interfaces.some( function(v) { return iid.equals(v) } ))
+            throw Components.results.NS_ERROR_NO_INTERFACE;
+        return this;
+    },
+
+    observe : function (subject, topic, data) {
+        netscape.security.PrivilegeManager.enablePrivilege('UniversalXPConnect');
+
+        var doc = getDialogDoc();
+        if (doc)
+            handleDialog(doc);
+        else
+            startCallbackTimer(); // try again in a bit
+    }
+};
+
+function getDialogDoc() {
+    // Find the <browser> which contains notifyWindow, by looking
+    // through all the open windows and all the <browsers> in each.
+  var wm = Cc["@mozilla.org/appshell/window-mediator;1"].
+      getService(Ci.nsIWindowMediator);
+  //var enumerator = wm.getEnumerator("navigator:browser");
+  var enumerator = wm.getXULWindowEnumerator(null);
+
+  while (enumerator.hasMoreElements()) {
+      var win = enumerator.getNext();
+      var windowDocShell = win.QueryInterface(Ci.nsIXULWindow).docShell;
+
+      var containedDocShells = windowDocShell.getDocShellEnumerator(
+                                                                    Ci.nsIDocShellTreeItem.typeChrome,
+                                                                    Ci.nsIDocShell.ENUMERATE_FORWARDS);
+      while (containedDocShells.hasMoreElements()) {
+          // Get the corresponding document for this docshell
+          var childDocShell = containedDocShells.getNext();
+          // We don't want it if it's not done loading.
+          if (childDocShell.busyFlags != Ci.nsIDocShell.BUSY_FLAGS_NONE)
+              continue;
+          var childDoc = childDocShell.QueryInterface(Ci.nsIDocShell).
+              contentViewer.DOMDocument;
+
+          //ok(true, "Got window: " + childDoc.location.href);
+          if (childDoc.location.href == "chrome://global/content/commonDialog.xul")
+              return childDoc;
+      }
+  }
+
+  return null;
+}
diff -r 6c8c95fcaf9b dom/tests/mochitest/geolocation/test_lastPosition.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/tests/mochitest/geolocation/test_lastPosition.html	Thu Jul 17 14:13:03 2008 +0300
@@ -0,0 +1,89 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=
+-->
+<head>
+  <title>Test for getCurrentPosition </title>
+  <script type="text/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <script type="text/javascript" src="prompt_common.js"></script>
+  <script type="text/javascript" src="geolocation_common.js"></script>
+
+<link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=">Mozilla Bug </a>
+<p id="display"></p>
+<div id="content" style="display: none">
+  
+</div>
+<pre id="test">
+<script class="testbody" type="text/javascript">
+
+/** Test for Bug  **/
+
+
+function handleDialog(doc) {
+  // Verify the error message is correct - the string (places) is not
+  // translated
+
+  var dialog = doc.getElementById("commonDialog");
+  var desc = doc.getElementById("info.body");
+  var errmsg = desc.childNodes[0].data;
+
+  ok(errmsg.indexOf("located") > 0, "Check for the correct message");
+
+  // Clear the dialog
+  if (allow_dialog)
+    dialog.acceptDialog();
+  else
+    dialog.cancelDialog();
+}
+
+
+
+ok(navigator.geolocator, "Ensure that the geolocation object is present");
+
+//first we want to prevent this proprerty from loading.
+/*
+Moving to the info bar very soon.  right now, there is no
+dialog in FF.  
+
+  allow_dialog = 0;
+  startCallbackTimer();
+*/
+
+last = navigator.geolocator.lastPosition;
+
+ok(last == null, "Check to ensure the lastPosition is null");
+
+// Try again, but this time allow the lookup.
+/*
+Moving to the info bar very soon.  right now, there is no
+dialog in FF
+
+allow_dialog = 1;
+startCallbackTimer();
+*/
+
+last = navigator.geolocator.lastPosition;
+
+if (last != null) {
+  check_geolocation(last);
+}
+else
+{
+  ok(1, "No geo location available");
+}
+
+SimpleTest.finish();
+
+
+
+
+</script>
+</pre>
+</body>
+</html>
+
diff -r 6c8c95fcaf9b dom/tests/mochitest/geolocation/test_manyWindows.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/tests/mochitest/geolocation/test_manyWindows.html	Thu Jul 17 14:13:03 2008 +0300
@@ -0,0 +1,59 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=
+-->
+<head>
+  <title>Test for many windows </title>
+  <script type="text/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <script type="text/javascript" src="prompt_common.js"></script>
+  <script type="text/javascript" src="geolocation_common.js"></script>
+
+<link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+<a target="_blank"
+href="https://bugzilla.mozilla.org/show_bug.cgi?id=">Crash in Multiple Windows</a>
+<p id="display"></p>
+<div id="content" style="display: none">
+  
+</div>
+<pre id="test">
+<script class="testbody" type="text/javascript">
+
+/** Test for Bug  **/
+
+ok(navigator.geolocator, "Ensure that the geolocation object is present");
+
+var numberOfWindows = 20;  // 20 seems to be the default max popups during the mochitest run
+var totalWindows = numberOfWindows;
+
+var windows = new Array(numberOfWindows);
+
+for(var i = 0; i < numberOfWindows; i++) {
+  windows[i] = window.open("geolocator.html", "_blank", "width=700,height=400");
+}
+
+for(var i = 0; i < numberOfWindows; i++) {
+  windows[i].close();
+  totalWindows --;
+}
+
+function checkDone()
+{
+    if (totalWindows == 0)
+    {
+        ok(navigator.geolocator, "Opened a bunch of windows and didn't crash.");
+        clearInterval(timer);
+        SimpleTest.finish();
+    }
+}
+
+var timer = setInterval(checkDone, 1000);
+
+</script>
+</pre>
+</body>
+</html>
+
diff -r 6c8c95fcaf9b editor/libeditor/base/nsEditor.cpp
--- a/editor/libeditor/base/nsEditor.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/editor/libeditor/base/nsEditor.cpp	Thu Jul 17 14:13:03 2008 +0300
@@ -75,11 +75,11 @@
 #include "nsISelection.h"
 #include "nsISelectionPrivate.h"
 #include "nsISelectionController.h"
 #include "nsIEnumerator.h"
 #include "nsIAtom.h"
-#include "nsICaret.h"
+#include "nsCaret.h"
 #include "nsIWidget.h"
 #include "nsIPlaintextEditor.h"
 #include "nsGUIEvent.h"  // nsTextEventReply
 
 #include "nsIFrame.h"  // Needed by IME code
@@ -1937,11 +1937,11 @@ nsEditor::QueryComposition(nsTextEventRe
     selcon->GetSelection(nsISelectionController::SELECTION_NORMAL, getter_AddRefs(selection));
 
   if (!mPresShellWeak) return NS_ERROR_NOT_INITIALIZED;
   nsCOMPtr<nsIPresShell> ps = do_QueryReferent(mPresShellWeak);
   if (!ps) return NS_ERROR_NOT_INITIALIZED;
-  nsCOMPtr<nsICaret> caretP; 
+  nsRefPtr<nsCaret> caretP; 
   result = ps->GetCaret(getter_AddRefs(caretP));
   
   if (NS_SUCCEEDED(result) && caretP) {
     if (aReply) {
       caretP->SetCaretDOMSelection(selection);
@@ -1980,11 +1980,11 @@ nsEditor::QueryComposition(nsTextEventRe
       }
 
 
       // XXX_kin: END HACK! HACK! HACK!
 
-      result = caretP->GetCaretCoordinates(nsICaret::eIMECoordinates, selection,
+      result = caretP->GetCaretCoordinates(nsCaret::eIMECoordinates, selection,
 		                      &(aReply->mCursorPosition), &(aReply->mCursorIsCollapsed), nsnull);
     }
   }
   return result;
 }
@@ -2225,18 +2225,18 @@ nsEditor::GetQueryCaretRect(nsQueryCaret
 
   nsCOMPtr<nsIPresShell> ps = do_QueryReferent(mPresShellWeak);
   if (!ps)
     return NS_ERROR_NOT_INITIALIZED;
 
-  nsCOMPtr<nsICaret> caretP;
+  nsRefPtr<nsCaret> caretP;
   rv = ps->GetCaret(getter_AddRefs(caretP));
 
   if (NS_FAILED(rv) || !caretP)
     return rv;
 
   PRBool cursorIsCollapsed;
-  rv = caretP->GetCaretCoordinates(nsICaret::eIMECoordinates, selection,
+  rv = caretP->GetCaretCoordinates(nsCaret::eIMECoordinates, selection,
                                    &aReply->mCaretRect, &cursorIsCollapsed, nsnull);
   if (NS_SUCCEEDED(rv))
     aReply->mRectIsValid = PR_TRUE;
   return rv;
 }
@@ -4341,11 +4341,11 @@ nsresult nsEditor::EndUpdateViewBatch()
     // Hide the caret with an StCaretHider. By the time it goes out
     // of scope and tries to show the caret, reflow and selection changed
     // notifications should've happened so the caret should have enough info
     // to draw at the correct position.
 
-    nsCOMPtr<nsICaret> caret;
+    nsRefPtr<nsCaret> caret;
     nsCOMPtr<nsIPresShell> presShell;
     GetPresShell(getter_AddRefs(presShell));
 
     if (presShell)
       presShell->GetCaret(getter_AddRefs(caret));
diff -r 6c8c95fcaf9b editor/libeditor/html/nsHTMLDataTransfer.cpp
--- a/editor/libeditor/html/nsHTMLDataTransfer.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/editor/libeditor/html/nsHTMLDataTransfer.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -33,11 +33,10 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
-#include "nsICaret.h"
 
 
 #include "nsHTMLEditor.h"
 #include "nsHTMLEditRules.h"
 #include "nsTextEditUtils.h"
diff -r 6c8c95fcaf9b editor/libeditor/html/nsHTMLEditor.cpp
--- a/editor/libeditor/html/nsHTMLEditor.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/editor/libeditor/html/nsHTMLEditor.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -34,11 +34,10 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
-#include "nsICaret.h"
 #include "nsCRT.h"
 
 #include "nsReadableUtils.h"
 #include "nsUnicharUtils.h"
 
diff -r 6c8c95fcaf9b editor/libeditor/text/nsEditorEventListeners.cpp
--- a/editor/libeditor/text/nsEditorEventListeners.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/editor/libeditor/text/nsEditorEventListeners.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -527,11 +527,11 @@ nsTextEditorDragListener::DragEnter(nsID
   if (!presShell)
     return NS_OK;
 
   if (!mCaret)
   {
-    mCaret = do_CreateInstance("@mozilla.org/layout/caret;1");
+    NS_NewCaret(getter_AddRefs(mCaret));
     if (mCaret)
     {
       mCaret->Init(presShell);
       mCaret->SetCaretReadOnly(PR_TRUE);
     }
@@ -1154,11 +1154,11 @@ nsTextEditorFocusListener::Focus(nsIDOME
         selCon->GetSelection(nsISelectionController::SELECTION_NORMAL,
                              getter_AddRefs(selection));
 
         nsCOMPtr<nsIPresShell> presShell = do_QueryReferent(mPresShell);
         if (presShell) {
-          nsCOMPtr<nsICaret> caret;
+          nsRefPtr<nsCaret> caret;
           presShell->GetCaret(getter_AddRefs(caret));
           if (caret) {
             caret->SetIgnoreUserModify(PR_FALSE);
             if (selection) {
               caret->SetCaretDOMSelection(selection);
@@ -1226,11 +1226,11 @@ nsTextEditorFocusListener::Blur(nsIDOMEv
           selectionPrivate->SetAncestorLimiter(nsnull);
         }
 
         nsCOMPtr<nsIPresShell> presShell = do_QueryReferent(mPresShell);
         if (presShell) {
-          nsCOMPtr<nsICaret> caret;
+          nsRefPtr<nsCaret> caret;
           presShell->GetCaret(getter_AddRefs(caret));
           if (caret) {
             caret->SetIgnoreUserModify(PR_TRUE);
           }
         }
diff -r 6c8c95fcaf9b editor/libeditor/text/nsEditorEventListeners.h
--- a/editor/libeditor/text/nsEditorEventListeners.h	Tue Jul 15 15:16:43 2008 +1200
+++ b/editor/libeditor/text/nsEditorEventListeners.h	Thu Jul 17 14:13:04 2008 +0300
@@ -49,11 +49,11 @@
 #include "nsIDOMCompositionListener.h"
 #include "nsIDOMFocusListener.h"
 
 #include "nsIEditor.h"
 #include "nsIPlaintextEditor.h"
-#include "nsICaret.h"
+#include "nsCaret.h"
 #include "nsIPresShell.h"
 #include "nsWeakPtr.h"
 #include "nsIWeakReferenceUtils.h"
 
 /** The nsTextEditorKeyListener public nsIDOMKeyListener
@@ -234,12 +234,12 @@ protected:
 protected:
 
   nsIEditor* mEditor;
   nsWeakPtr  mPresShell;
   
-  nsCOMPtr<nsICaret> mCaret;
-  PRBool             mCaretDrawn;
+  nsRefPtr<nsCaret> mCaret;
+  PRBool            mCaretDrawn;
 };
 
 /** editor Implementation of the FocusListener interface
  */
 class nsTextEditorFocusListener : public nsIDOMFocusListener 
diff -r 6c8c95fcaf9b editor/libeditor/text/nsPlaintextEditor.cpp
--- a/editor/libeditor/text/nsPlaintextEditor.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/editor/libeditor/text/nsPlaintextEditor.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -37,11 +37,11 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 
 #include "nsPlaintextEditor.h"
-#include "nsICaret.h"
+#include "nsCaret.h"
 #include "nsTextEditUtils.h"
 #include "nsTextEditRules.h"
 #include "nsEditorEventListeners.h"
 #include "nsIEditActionListener.h"
 #include "nsIDOMNodeList.h"
@@ -1656,11 +1656,11 @@ nsPlaintextEditor::SetCompositionString(
 
   nsCOMPtr<nsISelection> selection;
   nsresult result = GetSelection(getter_AddRefs(selection));
   if (NS_FAILED(result)) return result;
 
-  nsCOMPtr<nsICaret>  caretP;
+  nsRefPtr<nsCaret> caretP;
   ps->GetCaret(getter_AddRefs(caretP));
 
   // We should return caret position if it is possible. Because this event
   // dispatcher always expects to be returned the correct caret position.
   // But in following cases, we don't need to process the composition string,
@@ -1734,11 +1734,11 @@ nsPlaintextEditor::SetCompositionString(
     // XXX_kin: END HACK! HACK! HACK!
   }
 
   if (caretP)
   {
-    result = caretP->GetCaretCoordinates(nsICaret::eIMECoordinates,
+    result = caretP->GetCaretCoordinates(nsCaret::eIMECoordinates,
                                          selection,
                                          &(aReply->mCursorPosition),
                                          &(aReply->mCursorIsCollapsed),
                                          nsnull);
     NS_ASSERTION(NS_SUCCEEDED(result), "cannot get caret position");
diff -r 6c8c95fcaf9b extensions/access-builtin/accessproxy/nsAccessProxy.cpp
--- a/extensions/access-builtin/accessproxy/nsAccessProxy.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/extensions/access-builtin/accessproxy/nsAccessProxy.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -58,11 +58,11 @@
 #include "nsIPresShell.h"
 #include "nsIDOMDocument.h"
 #include "nsIDocument.h"
 #include "nsISelection.h"
 #include "nsISelectionController.h"
-#include "nsICaret.h"
+#include "nsCaret.h"
 
 // Header for this class
 #include "nsAccessProxy.h"
 
 // #define NS_DEBUG_ACCESS_BUILTIN 1
@@ -154,11 +154,11 @@ NS_IMETHODIMP nsAccessProxy::HandleEvent
       return NS_OK;
     nsCOMPtr<nsIDOMNode> focusDomNode;
     domSelection->GetAnchorNode(getter_AddRefs(focusDomNode));
     if (focusDomNode) domNode=focusDomNode;
     // first, tell the caret which selection to use
-    nsCOMPtr<nsICaret> caret;
+    nsRefPtr<nsCaret> caret;
     presShell->GetCaret(getter_AddRefs(caret));
     if (!caret) return NS_OK;
     caret->SetCaretDOMSelection(domSelection);
     // tell the pres shell to enable the caret, rather than settings its visibility directly.
     // this way the presShell's idea of caret visibility is maintained.
diff -r 6c8c95fcaf9b gfx/thebes/public/gfxContext.h
--- a/gfx/thebes/public/gfxContext.h	Tue Jul 15 15:16:43 2008 +1200
+++ b/gfx/thebes/public/gfxContext.h	Thu Jul 17 14:13:04 2008 +0300
@@ -335,11 +335,12 @@ public:
 
     /**
      * Uses a surface for drawing. This is a shorthand for creating a
      * pattern and setting it.
      *
-     * @param offset ?
+     * @param offset from the source surface, to use only part of it.
+     *        May need to make it negative.
      */
     void SetSource(gfxASurface *surface, const gfxPoint& offset = gfxPoint(0.0, 0.0));
 
     /**
      * Uses a pattern for drawing.
diff -r 6c8c95fcaf9b gfx/thebes/public/gfxFont.h
--- a/gfx/thebes/public/gfxFont.h	Tue Jul 15 15:16:43 2008 +1200
+++ b/gfx/thebes/public/gfxFont.h	Thu Jul 17 14:13:04 2008 +0300
@@ -413,10 +413,13 @@ public:
         gfxFloat maxDescent;
         gfxFloat maxAdvance;
 
         gfxFloat aveCharWidth;
         gfxFloat spaceWidth;
+        gfxFloat zeroOrAveCharWidth;  // width of '0', or if there is
+                                      // no '0' glyph in this font,
+                                      // equal to .aveCharWidth
     };
     virtual const gfxFont::Metrics& GetMetrics() = 0;
 
     /**
      * We let layout specify spacing on either side of any
diff -r 6c8c95fcaf9b gfx/thebes/public/gfxPlatform.h
--- a/gfx/thebes/public/gfxPlatform.h	Tue Jul 15 15:16:43 2008 +1200
+++ b/gfx/thebes/public/gfxPlatform.h	Thu Jul 17 14:13:04 2008 +0300
@@ -219,10 +219,15 @@ public:
      * Return the output device ICC profile.
      */
     static cmsHPROFILE GetCMSOutputProfile();
 
     /**
+     * Return the sRGB ICC profile.
+     */
+    static cmsHPROFILE GetCMSsRGBProfile();
+
+    /**
      * Return sRGB -> output device transform.
      */
     static cmsHTRANSFORM GetCMSRGBTransform();
 
     /**
diff -r 6c8c95fcaf9b gfx/thebes/src/cairo-xlib-utils.c
--- a/gfx/thebes/src/cairo-xlib-utils.c	Tue Jul 15 15:16:43 2008 +1200
+++ b/gfx/thebes/src/cairo-xlib-utils.c	Thu Jul 17 14:13:04 2008 +0300
@@ -296,12 +296,17 @@ _draw_with_xlib_direct (cairo_t *cr,
         screen != DefaultScreenOfDisplay (default_display)) {
         CAIRO_XLIB_DRAWING_NOTE("TAKING SLOW PATH: non-default display\n");
         return False;
     }
         
-    /* Check that the visual is supported */  
+    /* Check that there is a visual */
     visual = cairo_xlib_surface_get_visual (target);
+    if (!visual) {
+        CAIRO_XLIB_DRAWING_NOTE("TAKING SLOW PATH: no Visual for surface\n");
+        return False;
+    }        
+    /* Check that the visual is supported */
     if (!(capabilities & CAIRO_XLIB_DRAWING_SUPPORTS_NONDEFAULT_VISUAL) &&
         DefaultVisualOfScreen (screen) != visual) {
         CAIRO_XLIB_DRAWING_NOTE("TAKING SLOW PATH: non-default visual\n");
         return False;
     }
@@ -340,10 +345,11 @@ _create_temp_xlib_surface (cairo_t *cr, 
     if (target_drawable) {
         Screen *target_screen = cairo_xlib_surface_get_screen (target);
         Visual *target_visual = cairo_xlib_surface_get_visual (target);
         if ((target_screen == screen ||
              (capabilities & CAIRO_XLIB_DRAWING_SUPPORTS_ALTERNATE_SCREEN)) &&
+            target_visual &&
             (target_visual == DefaultVisualOfScreen (target_screen) ||
              (capabilities & CAIRO_XLIB_DRAWING_SUPPORTS_NONDEFAULT_VISUAL))) {
             drawable = target_drawable;
             dpy = cairo_xlib_surface_get_display (target);
             visual = target_visual;
diff -r 6c8c95fcaf9b gfx/thebes/src/gfxAtsuiFonts.cpp
--- a/gfx/thebes/src/gfxAtsuiFonts.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/gfx/thebes/src/gfxAtsuiFonts.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -279,10 +279,14 @@ gfxAtsuiFont::InitMetrics(ATSUFontID aFo
     mMetrics.strikeoutSize = mMetrics.underlineSize;
 
     PRUint32 glyphID;
     mMetrics.spaceWidth = GetCharWidth(' ', &glyphID);
     mSpaceGlyph = glyphID;
+
+    mMetrics.zeroOrAveCharWidth = GetCharWidth('0', &glyphID);
+    if (glyphID == 0) // no zero in this font
+        mMetrics.zeroOrAveCharWidth = mMetrics.aveCharWidth;
 
     SanitizeMetrics(&mMetrics, mFontEntry->FamilyEntry()->IsBadUnderlineFontFamily());
 
 #if 0
     fprintf (stderr, "Font: %p size: %f (fixed: %d)", this, size, gfxQuartzFontCache::SharedFontCache()->IsFixedPitch(aFontID));
diff -r 6c8c95fcaf9b gfx/thebes/src/gfxOS2Fonts.cpp
--- a/gfx/thebes/src/gfxOS2Fonts.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/gfx/thebes/src/gfxOS2Fonts.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -151,10 +151,20 @@ const gfxFont::Metrics& gfxOS2Font::GetM
         } else {
             // this font doesn't have an 'x'...
             // fake these metrics using a fraction of the font size
             mMetrics->xHeight = mMetrics->emHeight * 0.5;
             mMetrics->aveCharWidth = mMetrics->emHeight * 0.5;
+        }
+
+        // properties of '0', for 'ch' units
+        gid = FT_Get_Char_Index(face, '0');
+        if (gid) {
+            FT_Load_Glyph(face, gid, FT_LOAD_NO_SCALE);
+            mMetrics->zeroOrAveCharWidth = face->glyph->metrics.width * xScale;
+        } else {
+             // this font doesn't have a '0'
+             mMetrics->zeroOrAveCharWidth = mMetrics->aveCharWidth;
         }
 
         // compute an adjusted size if we need to
         if (mAdjustedSize == 0 && GetStyle()->sizeAdjust != 0) {
             gfxFloat aspect = mMetrics->xHeight / GetStyle()->size;
diff -r 6c8c95fcaf9b gfx/thebes/src/gfxPangoFonts.cpp
--- a/gfx/thebes/src/gfxPangoFonts.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/gfx/thebes/src/gfxPangoFonts.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -961,14 +961,20 @@ gfxPangoFont::GetMetrics()
     mMetrics.emAscent = lineHeight > 0.0 ?
         mMetrics.maxAscent * mMetrics.emHeight / lineHeight : 0.0;
     mMetrics.emDescent = mMetrics.emHeight - mMetrics.emAscent;
 
     gfxSize isz, lsz;
+    PRUint32 zeroGlyph;
     GetCharSize(' ', isz, lsz, &mSpaceGlyph);
     mMetrics.spaceWidth = lsz.width;
     GetCharSize('x', isz, lsz);
     mMetrics.xHeight = isz.height;
+    GetCharSize('0', isz, lsz, &zeroGlyph);
+    if (zeroGlyph)
+        mMetrics.zeroOrAveCharWidth = lsz.width;
+    else
+        mMetrics.zeroOrAveCharWidth = mMetrics.aveCharWidth;
 
     FT_Face face = NULL;
     if (pfm && PANGO_IS_FC_FONT(font))
         face = pango_fc_font_lock_face(PANGO_FC_FONT(font));
 
diff -r 6c8c95fcaf9b gfx/thebes/src/gfxPlatform.cpp
--- a/gfx/thebes/src/gfxPlatform.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/gfx/thebes/src/gfxPlatform.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -69,11 +69,15 @@
 #include "nsIPrefService.h"
 #include "nsIPrefBranch.h"
 
 gfxPlatform *gPlatform = nsnull;
 int gGlitzState = -1;
+
+// These two may point to the same profile
 static cmsHPROFILE gCMSOutputProfile = nsnull;
+static cmsHPROFILE gCMSsRGBProfile = nsnull;
+
 static cmsHTRANSFORM gCMSRGBTransform = nsnull;
 static cmsHTRANSFORM gCMSInverseRGBTransform = nsnull;
 static cmsHTRANSFORM gCMSRGBATransform = nsnull;
 
 // this needs to match the list of pref font.default.xx entries listed in all.js!
@@ -181,10 +185,37 @@ gfxPlatform::Shutdown()
     gfxTextRunWordCache::Shutdown();
     gfxFontCache::Shutdown();
 #if defined(XP_MACOSX)
     gfxQuartzFontCache::Shutdown();
 #endif
+
+    // Free the various non-null transforms and loaded profiles
+    if (gCMSRGBTransform) {
+        cmsDeleteTransform(gCMSRGBTransform);
+        gCMSRGBTransform = nsnull;
+    }
+    if (gCMSInverseRGBTransform) {
+        cmsDeleteTransform(gCMSInverseRGBTransform);
+        gCMSInverseRGBTransform = nsnull;
+    }
+    if (gCMSRGBATransform) {
+        cmsDeleteTransform(gCMSRGBATransform);
+        gCMSRGBATransform = nsnull;
+    }
+    if (gCMSOutputProfile) {
+        cmsCloseProfile(gCMSOutputProfile);
+
+        // handle the aliased case
+        if (gCMSsRGBProfile == gCMSOutputProfile)
+            gCMSsRGBProfile = nsnull;
+        gCMSOutputProfile = nsnull;
+    }
+    if (gCMSsRGBProfile) {
+        cmsCloseProfile(gCMSsRGBProfile);
+        gCMSsRGBProfile = nsnull;
+    }
+    
     delete gPlatform;
     gPlatform = nsnull;
 }
 
 gfxPlatform::~gfxPlatform()
@@ -476,24 +507,32 @@ gfxPlatform::GetCMSOutputProfile()
             gCMSOutputProfile =
                 gfxPlatform::GetPlatform()->GetPlatformCMSOutputProfile();
         }
 
         if (!gCMSOutputProfile) {
-            gCMSOutputProfile = cmsCreate_sRGBProfile();
+            gCMSOutputProfile = GetCMSsRGBProfile();
         }
     }
 
     return gCMSOutputProfile;
+}
+
+cmsHPROFILE
+gfxPlatform::GetCMSsRGBProfile()
+{
+    if (!gCMSsRGBProfile)
+        gCMSsRGBProfile = cmsCreate_sRGBProfile();
+    return gCMSsRGBProfile;
 }
 
 cmsHTRANSFORM
 gfxPlatform::GetCMSRGBTransform()
 {
     if (!gCMSRGBTransform) {
         cmsHPROFILE inProfile, outProfile;
         outProfile = GetCMSOutputProfile();
-        inProfile = cmsCreate_sRGBProfile();
+        inProfile = GetCMSsRGBProfile();
 
         if (!inProfile || !outProfile)
             return nsnull;
 
         gCMSRGBTransform = cmsCreateTransform(inProfile, TYPE_RGB_8,
@@ -508,11 +547,11 @@ gfxPlatform::GetCMSInverseRGBTransform()
 gfxPlatform::GetCMSInverseRGBTransform()
 {
     if (!gCMSInverseRGBTransform) {
         cmsHPROFILE inProfile, outProfile;
         inProfile = GetCMSOutputProfile();
-        outProfile = cmsCreate_sRGBProfile();
+        outProfile = GetCMSsRGBProfile();
 
         if (!inProfile || !outProfile)
             return nsnull;
 
         gCMSInverseRGBTransform = cmsCreateTransform(inProfile, TYPE_RGB_8,
@@ -527,11 +566,11 @@ gfxPlatform::GetCMSRGBATransform()
 gfxPlatform::GetCMSRGBATransform()
 {
     if (!gCMSRGBATransform) {
         cmsHPROFILE inProfile, outProfile;
         outProfile = GetCMSOutputProfile();
-        inProfile = cmsCreate_sRGBProfile();
+        inProfile = GetCMSsRGBProfile();
 
         if (!inProfile || !outProfile)
             return nsnull;
 
         gCMSRGBATransform = cmsCreateTransform(inProfile, TYPE_RGBA_8,
diff -r 6c8c95fcaf9b gfx/thebes/src/gfxWindowsFonts.cpp
--- a/gfx/thebes/src/gfxWindowsFonts.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/gfx/thebes/src/gfxWindowsFonts.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -628,10 +628,19 @@ gfxWindowsFont::ComputeMetrics()
 
     // Cache the width of a single space.
     SIZE size;
     GetTextExtentPoint32(dc, " ", 1, &size);
     mMetrics->spaceWidth = ROUND(size.cx);
+
+    // Cache the width of digit zero.
+    // XXX MSDN (http://msdn.microsoft.com/en-us/library/ms534223.aspx)
+    // does not say what the failure modes for GetTextExtentPoint32 are -
+    // is it safe to assume it will fail iff the font has no '0'?
+    if (GetTextExtentPoint32(dc, "0", 1, &size))
+        mMetrics->zeroOrAveCharWidth = ROUND(size.cx);
+    else
+        mMetrics->zeroOrAveCharWidth = mMetrics->aveCharWidth;
 
     mSpaceGlyph = 0;
     if (metrics.tmPitchAndFamily & TMPF_TRUETYPE) {
         WORD glyph;
         DWORD ret = GetGlyphIndicesA(dc, " ", 1, &glyph,
diff -r 6c8c95fcaf9b js/src/js.cpp
--- a/js/src/js.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/js/src/js.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -3198,11 +3198,11 @@ its_setProperty(JSContext *cx, JSObject 
  * Its enumerator, implemented using the "new" enumerate API,
  * see class flags.
  */
 static JSBool
 its_enumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op,
-		  jsval *statep, jsid *idp)
+              jsval *statep, jsid *idp)
 {
     JSObject *iterator;
 
     switch (enum_op) {
       case JSENUMERATE_INIT:
diff -r 6c8c95fcaf9b js/src/jsatom.cpp
--- a/js/src/jsatom.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/js/src/jsatom.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -576,23 +576,23 @@ js_AtomizeDouble(JSContext *cx, jsdouble
     jsval v;
 
     state = &cx->runtime->atomState;
     table = &state->doubleAtoms;
 
-    JS_LOCK(&state->lock, cx);
+    JS_LOCK(cx, &state->lock);
     entry = TO_ATOM_ENTRY(JS_DHashTableOperate(table, &d, JS_DHASH_ADD));
     if (!entry)
         goto failed_hash_add;
     if (entry->keyAndFlags == 0) {
         gen = ++table->generation;
-        JS_UNLOCK(&state->lock, cx);
+        JS_UNLOCK(cx, &state->lock);
 
         key = js_NewWeaklyRootedDouble(cx, d);
         if (!key)
             return NULL;
 
-        JS_LOCK(&state->lock, cx);
+        JS_LOCK(cx, &state->lock);
         if (table->generation == gen) {
             JS_ASSERT(entry->keyAndFlags == 0);
         } else {
             entry = TO_ATOM_ENTRY(JS_DHashTableOperate(table, key,
                                                        JS_DHASH_ADD));
@@ -606,16 +606,16 @@ js_AtomizeDouble(JSContext *cx, jsdouble
     }
 
   finish:
     v = DOUBLE_TO_JSVAL((jsdouble *)ATOM_ENTRY_KEY(entry));
     cx->weakRoots.lastAtom = v;
-    JS_UNLOCK(&state->lock,cx);
+    JS_UNLOCK(cx, &state->lock);
 
     return (JSAtom *)v;
 
   failed_hash_add:
-    JS_UNLOCK(&state->lock,cx);
+    JS_UNLOCK(cx, &state->lock);
     JS_ReportOutOfMemory(cx);
     return NULL;
 }
 
 JSAtom *
@@ -632,11 +632,11 @@ js_AtomizeString(JSContext *cx, JSString
     JS_ASSERT_IF(flags & ATOM_NOCOPY, flags & ATOM_TMPSTR);
 
     state = &cx->runtime->atomState;
     table = &state->stringAtoms;
 
-    JS_LOCK(&state->lock, cx);
+    JS_LOCK(cx, &state->lock);
     entry = TO_ATOM_ENTRY(JS_DHashTableOperate(table, str, JS_DHASH_ADD));
     if (!entry)
         goto failed_hash_add;
     if (entry->keyAndFlags != 0) {
         key = (JSString *)ATOM_ENTRY_KEY(entry);
@@ -651,11 +651,11 @@ js_AtomizeString(JSContext *cx, JSString
         if (!(flags & ATOM_TMPSTR) && JSSTRING_IS_FLAT(str)) {
             JSFLATSTR_CLEAR_MUTABLE(str);
             key = str;
         } else {
             gen = table->generation;
-            JS_UNLOCK(&state->lock, cx);
+            JS_UNLOCK(cx, &state->lock);
 
             if (flags & ATOM_TMPSTR) {
                 if (flags & ATOM_NOCOPY) {
                     key = js_NewString(cx, JSFLATSTR_CHARS(str),
                                        JSFLATSTR_LENGTH(str));
@@ -675,11 +675,11 @@ js_AtomizeString(JSContext *cx, JSString
                 if (!js_UndependString(cx, str))
                     return NULL;
                 key = str;
             }
 
-            JS_LOCK(&state->lock, cx);
+            JS_LOCK(cx, &state->lock);
             if (table->generation == gen) {
                 JS_ASSERT(entry->keyAndFlags == 0);
             } else {
                 entry = TO_ATOM_ENTRY(JS_DHashTableOperate(table, key,
                                                            JS_DHASH_ADD));
@@ -699,15 +699,15 @@ js_AtomizeString(JSContext *cx, JSString
   finish:
     ADD_ATOM_ENTRY_FLAGS(entry, flags & (ATOM_PINNED | ATOM_INTERNED));
     JS_ASSERT(JSSTRING_IS_ATOMIZED(key));
     v = STRING_TO_JSVAL(key);
     cx->weakRoots.lastAtom = v;
-    JS_UNLOCK(&state->lock, cx);
+    JS_UNLOCK(cx, &state->lock);
     return (JSAtom *)v;
 
   failed_hash_add:
-    JS_UNLOCK(&state->lock,cx);
+    JS_UNLOCK(cx, &state->lock);
     JS_ReportOutOfMemory(cx);
     return NULL;
 }
 
 JSAtom *
@@ -764,16 +764,16 @@ js_GetExistingStringAtom(JSContext *cx, 
     JSDHashEntryHdr *hdr;
 
     JSFLATSTR_INIT(&str, (jschar *)chars, length);
     state = &cx->runtime->atomState;
 
-    JS_LOCK(&state->lock, cx);
+    JS_LOCK(cx, &state->lock);
     hdr = JS_DHashTableOperate(&state->stringAtoms, &str, JS_DHASH_LOOKUP);
     str2 = JS_DHASH_ENTRY_IS_BUSY(hdr)
            ? (JSString *)ATOM_ENTRY_KEY(TO_ATOM_ENTRY(hdr))
            : NULL;
-    JS_UNLOCK(&state->lock, cx);
+    JS_UNLOCK(cx, &state->lock);
 
     return str2 ? (JSAtom *)STRING_TO_JSVAL(str2) : NULL;
 }
 
 JSBool
diff -r 6c8c95fcaf9b js/src/jsdate.cpp
--- a/js/src/jsdate.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/js/src/jsdate.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -926,11 +926,11 @@ static JSBool
 static JSBool
 GetUTCTime(JSContext *cx, JSObject *obj, jsval *vp, jsdouble *dp)
 {
     jsval v;
 
-    if (vp && !JS_InstanceOf(cx, obj, &js_DateClass, vp + 2))
+    if (!JS_InstanceOf(cx, obj, &js_DateClass, vp ? vp + 2 : NULL))
         return JS_FALSE;
     if (!JS_GetReservedSlot(cx, obj, UTC_TIME_SLOT, &v))
         return JS_FALSE;
 
     *dp = *JSVAL_TO_DOUBLE(v);
diff -r 6c8c95fcaf9b js/src/jsinterp.cpp
--- a/js/src/jsinterp.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/js/src/jsinterp.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -77,11 +77,12 @@
 #include "jsxml.h"
 #endif
 
 #include "jsautooplen.h"
 
-#ifdef js_invoke_c__
+/* jsinvoke_cpp___ indicates inclusion from jsinvoke.cpp. */
+#if !JS_LONE_INTERPRET ^ defined jsinvoke_cpp___
 
 uint32
 js_GenerateShape(JSContext *cx, JSBool gcLocked)
 {
     JSRuntime *rt;
@@ -534,11 +535,11 @@ AllocateAfterSP(JSContext *cx, jsval *sp
                            (nslots - surplus) * sizeof(jsval));
     JS_ASSERT(sp2 == sp + surplus);
     return JS_TRUE;
 }
 
-jsval *
+JS_STATIC_INTERPRET jsval *
 js_AllocRawStack(JSContext *cx, uintN nslots, void **markp)
 {
     jsval *sp;
 
     if (!cx->stackPool.first.next) {
@@ -559,11 +560,11 @@ js_AllocRawStack(JSContext *cx, uintN ns
     if (!sp)
         js_ReportOutOfScriptQuota(cx);
     return sp;
 }
 
-void
+JS_STATIC_INTERPRET void
 js_FreeRawStack(JSContext *cx, void *mark)
 {
     JS_ARENA_RELEASE(&cx->stackPool, mark);
 }
 
@@ -753,11 +754,11 @@ js_GetPrimitiveThis(JSContext *cx, jsval
  *   var h = w1.g()
  *   alert(h() == w1)
  *
  * The alert should display "true".
  */
-JSObject *
+JS_STATIC_INTERPRET JSObject *
 js_ComputeGlobalThis(JSContext *cx, JSBool lazy, jsval *argv)
 {
     JSObject *thisp;
 
     if (JSVAL_IS_PRIMITIVE(argv[-2]) ||
@@ -900,11 +901,11 @@ js_InitNoSuchMethodClass(JSContext *cx, 
  *
  * where id is the name of the method that this invocation attempted to
  * call by name, and args is an Array containing this invocation's actual
  * parameters.
  */
-JSBool
+JS_STATIC_INTERPRET JSBool
 js_OnUnknownMethod(JSContext *cx, jsval *vp)
 {
     JSObject *obj;
     jsid id;
     JSTempValueRooter tvr;
@@ -1576,11 +1577,11 @@ out:
 
 #if JS_HAS_EXPORT_IMPORT
 /*
  * If id is JSVAL_VOID, import all exported properties from obj.
  */
-JSBool
+JS_STATIC_INTERPRET JSBool
 js_ImportProperty(JSContext *cx, JSObject *obj, jsid id)
 {
     JSBool ok;
     JSIdArray *ida;
     JSProperty *prop;
@@ -1924,11 +1925,11 @@ js_InternNonIntElementId(JSContext *cx, 
 
 /*
  * Enter the new with scope using an object at sp[-1] and associate the depth
  * of the with block with sp + stackIndex.
  */
-JSBool
+JS_STATIC_INTERPRET JSBool
 js_EnterWith(JSContext *cx, jsint stackIndex)
 {
     JSStackFrame *fp;
     jsval *sp;
     JSObject *obj, *parent, *withobj;
@@ -1963,11 +1964,11 @@ js_EnterWith(JSContext *cx, jsint stackI
     fp->scopeChain = withobj;
     js_DisablePropertyCache(cx);
     return JS_TRUE;
 }
 
-void
+JS_STATIC_INTERPRET void
 js_LeaveWith(JSContext *cx)
 {
     JSObject *withobj;
 
     withobj = cx->fp->scopeChain;
@@ -1991,11 +1992,11 @@ js_IsActiveWithOrBlock(JSContext *cx, JS
         return clasp;
     }
     return NULL;
 }
 
-jsint
+JS_STATIC_INTERPRET jsint
 js_CountWithBlocks(JSContext *cx, JSStackFrame *fp)
 {
     jsint n;
     JSObject *obj;
     JSClass *clasp;
@@ -2046,11 +2047,11 @@ js_UnwindScope(JSContext *cx, JSStackFra
 
     fp->regs->sp = fp->spbase + stackDepth;
     return normalUnwind;
 }
 
-JSBool
+JS_STATIC_INTERPRET JSBool
 js_DoIncDec(JSContext *cx, const JSCodeSpec *cs, jsval *vp, jsval *vp2)
 {
     jsval v;
     jsdouble d;
 
@@ -2082,11 +2083,11 @@ js_DoIncDec(JSContext *cx, const JSCodeS
     return JS_TRUE;
 }
 
 #ifdef DEBUG
 
-void
+JS_STATIC_INTERPRET void
 js_TraceOpcode(JSContext *cx, jsint len)
 {
     FILE *tracefp;
     JSStackFrame *fp;
     JSFrameRegs *regs;
@@ -2165,18 +2166,18 @@ js_TraceOpcode(JSContext *cx, jsint len)
  * any particular row.
  */
 static uint32 succeeds[JSOP_LIMIT][256];
 static uint32 slot_ops[JSOP_LIMIT][HIST_NSLOTS];
 
-void
+JS_STATIC_INTERPRET void
 js_MeterOpcodePair(JSOp op1, JSOp op2)
 {
     if (op1 != JSOP_STOP)
         ++succeeds[op1][op2];
 }
 
-void
+JS_STATIC_INTERPRET void
 js_MeterSlotOpcode(JSOp op, uint32 slot)
 {
     if (slot < HIST_NSLOTS)
         ++slot_ops[op][slot];
 }
@@ -2291,11 +2292,13 @@ js_DumpOpMeters()
     fclose(fp);
 }
 
 #endif /* JS_OPSMETER */
 
-#else /* !defined js_invoke_c__ */
+#endif /* !JS_LONE_INTERPRET ^ defined jsinvoke_cpp___ */
+
+#ifndef  jsinvoke_cpp___
 
 #define PUSH(v)         (*regs.sp++ = (v))
 #define PUSH_OPND(v)    PUSH(v)
 #define STORE_OPND(n,v) (regs.sp[n] = (v))
 #define POP()           (*--regs.sp)
@@ -7052,6 +7055,6 @@ js_Interpret(JSContext *cx)
             js_ReportIsNotDefined(cx, printable);
         goto error;
     }
 }
 
-#endif /* !defined js_invoke_c__ */
+#endif /* !defined jsinvoke_cpp___ */
diff -r 6c8c95fcaf9b js/src/jsinterp.h
--- a/js/src/jsinterp.h	Tue Jul 15 15:16:43 2008 +1200
+++ b/js/src/jsinterp.h	Thu Jul 17 14:13:04 2008 +0300
@@ -334,16 +334,10 @@ js_AllocStack(JSContext *cx, uintN nslot
 js_AllocStack(JSContext *cx, uintN nslots, void **markp);
 
 extern JS_FRIEND_API(void)
 js_FreeStack(JSContext *cx, void *mark);
 
-extern jsval *
-js_AllocRawStack(JSContext *cx, uintN nslots, void **markp);
-
-extern void
-js_FreeRawStack(JSContext *cx, void *mark);
-
 /*
  * Refresh and return fp->scopeChain.  It may be stale if block scopes are
  * active but not yet reflected by objects in the scope chain.  If a block
  * scope contains a with, eval, XML filtering predicate, or similar such
  * dynamically scoped construct, then compile-time block scope at fp->blocks
@@ -371,28 +365,10 @@ js_GetPrimitiveThis(JSContext *cx, jsval
  * objects as, per ECMA-262, they may not be referred to by |this|. argv[-1]
  * must not be a JSVAL_VOID.
  */
 extern JSObject *
 js_ComputeThis(JSContext *cx, JSBool lazy, jsval *argv);
-
-/*
- * ECMA requires "the global object", but in embeddings such as the browser,
- * which have multiple top-level objects (windows, frames, etc. in the DOM),
- * we prefer fun's parent.  An example that causes this code to run:
- *
- *   // in window w1
- *   function f() { return this }
- *   function g() { return f }
- *
- *   // in window w2
- *   var h = w1.g()
- *   alert(h() == w1)
- *
- * The alert should display "true".
- */
-JSObject *
-js_ComputeGlobalThis(JSContext *cx, JSBool lazy, jsval *argv);
 
 extern const uint16 js_PrimitiveTestFlags[];
 
 #define PRIMITIVE_THIS_TEST(fun,thisv)                                        \
     (JS_ASSERT(!JSVAL_IS_VOID(thisv)),                                        \
@@ -467,10 +443,58 @@ js_CheckRedeclaration(JSContext *cx, JSO
                       JSObject **objp, JSProperty **propp);
 
 extern JSBool
 js_StrictlyEqual(JSContext *cx, jsval lval, jsval rval);
 
+/*
+ * JS_LONE_INTERPRET indicates that the compiler should see just the code for
+ * the js_Interpret function when compiling jsinterp.cpp. The rest of the code
+ * from the file should be visible only when compiling jsinvoke.cpp. It allows
+ * platform builds to optimize selectively js_Interpret when the granularity
+ * of the optimizations with the given compiler is a compilation unit.
+ *
+ * JS_STATIC_INTERPRET is the modifier for functions defined in jsinterp.cpp
+ * that only js_Interpret calls. When JS_LONE_INTERPRET is true all such
+ * functions are declared below.
+ */
+#ifndef JS_LONE_INTERPRET
+# ifdef _MSC_VER
+#  define JS_LONE_INTERPRET 0
+# else
+#  define JS_LONE_INTERPRET 1
+# endif
+#endif
+
+#if !JS_LONE_INTERPRET
+# define JS_STATIC_INTERPRET    static
+#else
+# define JS_STATIC_INTERPRET
+
+extern jsval *
+js_AllocRawStack(JSContext *cx, uintN nslots, void **markp);
+
+extern void
+js_FreeRawStack(JSContext *cx, void *mark);
+
+/*
+ * ECMA requires "the global object", but in embeddings such as the browser,
+ * which have multiple top-level objects (windows, frames, etc. in the DOM),
+ * we prefer fun's parent.  An example that causes this code to run:
+ *
+ *   // in window w1
+ *   function f() { return this }
+ *   function g() { return f }
+ *
+ *   // in window w2
+ *   var h = w1.g()
+ *   alert(h() == w1)
+ *
+ * The alert should display "true".
+ */
+extern JSObject *
+js_ComputeGlobalThis(JSContext *cx, JSBool lazy, jsval *argv);
+
 extern JSBool
 js_EnterWith(JSContext *cx, jsint stackIndex);
 
 extern void
 js_LeaveWith(JSContext *cx);
@@ -521,8 +545,10 @@ js_MeterOpcodePair(JSOp op1, JSOp op2);
 js_MeterOpcodePair(JSOp op1, JSOp op2);
 
 extern void
 js_MeterSlotOpcode(JSOp op, uint32 slot);
 
+#endif /* JS_LONE_INTERPRET */
+
 JS_END_EXTERN_C
 
 #endif /* jsinterp_h___ */
diff -r 6c8c95fcaf9b js/src/jsinvoke.cpp
--- a/js/src/jsinvoke.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/js/src/jsinvoke.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -36,8 +36,8 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
-#define js_invoke_c__
+#define jsinvoke_cpp___
 
 #include "jsinterp.cpp"
diff -r 6c8c95fcaf9b js/src/jslock.cpp
--- a/js/src/jslock.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/js/src/jslock.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -59,63 +59,41 @@
 
 #define ReadWord(W) (W)
 
 #ifndef NSPR_LOCK
 
-#include <memory.h>
+/* Implement NativeCompareAndSwap. */
 
-static PRLock **global_locks;
-static uint32 global_lock_count = 1;
-static uint32 global_locks_log2 = 0;
-static uint32 global_locks_mask = 0;
-
-#define GLOBAL_LOCK_INDEX(id)   (((uint32)(id) >> 2) & global_locks_mask)
-
-static void
-js_LockGlobal(void *id)
-{
-    uint32 i = GLOBAL_LOCK_INDEX(id);
-    PR_Lock(global_locks[i]);
-}
-
-static void
-js_UnlockGlobal(void *id)
-{
-    uint32 i = GLOBAL_LOCK_INDEX(id);
-    PR_Unlock(global_locks[i]);
-}
-
-/* Exclude Alpha NT. */
 #if defined(_WIN32) && defined(_M_IX86)
 #pragma warning( disable : 4035 )
 JS_BEGIN_EXTERN_C
 extern long __cdecl
 _InterlockedCompareExchange(long *volatile dest, long exchange, long comp);
 JS_END_EXTERN_C
 #pragma intrinsic(_InterlockedCompareExchange)
 
 static JS_INLINE int
-js_CompareAndSwapHelper(jsword *w, jsword ov, jsword nv)
+NativeCompareAndSwapHelper(jsword *w, jsword ov, jsword nv)
 {
     _InterlockedCompareExchange(w, nv, ov);
     __asm {
         sete al
     }
 }
 
 static JS_INLINE int
-js_CompareAndSwap(jsword *w, jsword ov, jsword nv)
+NativeCompareAndSwap(jsword *w, jsword ov, jsword nv)
 {
-    return (js_CompareAndSwapHelper(w, ov, nv) & 1);
+    return (NativeCompareAndSwapHelper(w, ov, nv) & 1);
 }
 
 #elif defined(XP_MACOSX) || defined(DARWIN)
 
 #include <libkern/OSAtomic.h>
 
 static JS_INLINE int
-js_CompareAndSwap(jsword *w, jsword ov, jsword nv)
+NativeCompareAndSwap(jsword *w, jsword ov, jsword nv)
 {
     /* Details on these functions available in the manpage for atomic */
 #if JS_BYTES_PER_WORD == 8 && JS_BYTES_PER_LONG != 8
     return OSAtomicCompareAndSwap64Barrier(ov, nv, (int64_t*) w);
 #else
@@ -125,11 +103,11 @@ js_CompareAndSwap(jsword *w, jsword ov, 
 
 #elif defined(__GNUC__) && defined(__i386__)
 
 /* Note: This fails on 386 cpus, cmpxchgl is a >= 486 instruction */
 static JS_INLINE int
-js_CompareAndSwap(jsword *w, jsword ov, jsword nv)
+NativeCompareAndSwap(jsword *w, jsword ov, jsword nv)
 {
     unsigned int res;
 
     __asm__ __volatile__ (
                           "lock\n"
@@ -143,11 +121,11 @@ js_CompareAndSwap(jsword *w, jsword ov, 
 }
 
 #elif defined(SOLARIS) && defined(sparc) && defined(ULTRA_SPARC)
 
 static JS_INLINE int
-js_CompareAndSwap(jsword *w, jsword ov, jsword nv)
+NativeCompareAndSwap(jsword *w, jsword ov, jsword nv)
 {
 #if defined(__GNUC__)
     unsigned int res;
     JS_ASSERT(ov != nv);
     asm volatile ("\
@@ -171,11 +149,11 @@ 1:"
 #elif defined(AIX)
 
 #include <sys/atomic_op.h>
 
 static JS_INLINE int
-js_CompareAndSwap(jsword *w, jsword ov, jsword nv)
+NativeCompareAndSwap(jsword *w, jsword ov, jsword nv)
 {
     return !_check_lock((atomic_p)w, ov, nv);
 }
 
 #elif defined(USE_ARM_KUSER)
@@ -188,21 +166,67 @@ typedef int (__kernel_cmpxchg_t)(int old
 #define __kernel_cmpxchg (*(__kernel_cmpxchg_t *)0xffff0fc0)
 
 JS_STATIC_ASSERT(sizeof(jsword) == sizeof(int));
 
 static JS_INLINE int
-js_CompareAndSwap(jsword *w, jsword ov, jsword nv)
+NativeCompareAndSwap(jsword *w, jsword ov, jsword nv)
 {
     volatile int *vp = (volatile int*)w;
     return !__kernel_cmpxchg(ov, nv, vp);
 }
 
+#elif defined(__GNUC__) &&                                                    \
+    (__GNUC__ >= 5 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 1))
+
+static JS_INLINE int
+NativeCompareAndSwap(jsword *w, jsword ov, jsword nv)
+{
+    return __sync_bool_compare_and_swap(w, ov, nv);
+}
+
 #else
 
-#error "Define NSPR_LOCK if your platform lacks a compare-and-swap instruction."
+#error "JS_HAS_NATIVE_COMPARE_AND_SWAP should be 0 if your platform lacks a compare-and-swap instruction."
 
 #endif /* arch-tests */
+
+struct JSFatLock {
+    int         susp;
+    PRLock      *slock;
+    PRCondVar   *svar;
+    JSFatLock   *next;
+    JSFatLock   **prevp;
+};
+
+typedef struct JSFatLockTable {
+    JSFatLock   *free;
+    JSFatLock   *taken;
+} JSFatLockTable;
+
+#define GLOBAL_LOCK_INDEX(id)   (((uint32)(jsuword)(id)>>2) & global_locks_mask)
+
+static void
+js_Dequeue(JSThinLock *);
+
+static PRLock **global_locks;
+static uint32 global_lock_count = 1;
+static uint32 global_locks_log2 = 0;
+static uint32 global_locks_mask = 0;
+
+static void
+js_LockGlobal(void *id)
+{
+    uint32 i = GLOBAL_LOCK_INDEX(id);
+    PR_Lock(global_locks[i]);
+}
+
+static void
+js_UnlockGlobal(void *id)
+{
+    uint32 i = GLOBAL_LOCK_INDEX(id);
+    PR_Unlock(global_locks[i]);
+}
 
 #endif /* !NSPR_LOCK */
 
 void
 js_InitLock(JSThinLock *tl)
@@ -225,14 +249,10 @@ js_FinishLock(JSThinLock *tl)
 #else
     JS_ASSERT(tl->owner == 0);
     JS_ASSERT(tl->fat == NULL);
 #endif
 }
-
-#ifndef NSPR_LOCK
-static void js_Dequeue(JSThinLock *);
-#endif
 
 #ifdef DEBUG_SCOPE_COUNT
 
 #include <stdio.h>
 #include "jsdhash.h"
@@ -583,29 +603,29 @@ js_GetSlotThreadSafe(JSContext *cx, JSOb
 
 #ifndef NSPR_LOCK
     tl = &title->lock;
     me = CX_THINLOCK_ID(cx);
     JS_ASSERT(CURRENT_THREAD_IS_ME(me));
-    if (js_CompareAndSwap(&tl->owner, 0, me)) {
+    if (NativeCompareAndSwap(&tl->owner, 0, me)) {
         /*
          * Got the lock with one compare-and-swap.  Even so, someone else may
          * have mutated obj so it now has its own scope and lock, which would
          * require either a restart from the top of this routine, or a thin
          * lock release followed by fat lock acquisition.
          */
         if (scope == OBJ_SCOPE(obj)) {
             v = STOBJ_GET_SLOT(obj, slot);
-            if (!js_CompareAndSwap(&tl->owner, me, 0)) {
+            if (!NativeCompareAndSwap(&tl->owner, me, 0)) {
                 /* Assert that scope locks never revert to flyweight. */
                 JS_ASSERT(title->ownercx != cx);
                 LOGIT(scope, '1');
                 title->u.count = 1;
                 js_UnlockObj(cx, obj);
             }
             return v;
         }
-        if (!js_CompareAndSwap(&tl->owner, me, 0))
+        if (!NativeCompareAndSwap(&tl->owner, me, 0))
             js_Dequeue(tl);
     }
     else if (Thin_RemoveWait(ReadWord(tl->owner)) == me) {
         return STOBJ_GET_SLOT(obj, slot);
     }
@@ -679,23 +699,23 @@ js_SetSlotThreadSafe(JSContext *cx, JSOb
 
 #ifndef NSPR_LOCK
     tl = &title->lock;
     me = CX_THINLOCK_ID(cx);
     JS_ASSERT(CURRENT_THREAD_IS_ME(me));
-    if (js_CompareAndSwap(&tl->owner, 0, me)) {
+    if (NativeCompareAndSwap(&tl->owner, 0, me)) {
         if (scope == OBJ_SCOPE(obj)) {
             LOCKED_OBJ_WRITE_BARRIER(cx, obj, slot, v);
-            if (!js_CompareAndSwap(&tl->owner, me, 0)) {
+            if (!NativeCompareAndSwap(&tl->owner, me, 0)) {
                 /* Assert that scope locks never revert to flyweight. */
                 JS_ASSERT(title->ownercx != cx);
                 LOGIT(scope, '1');
                 title->u.count = 1;
                 js_UnlockObj(cx, obj);
             }
             return;
         }
-        if (!js_CompareAndSwap(&tl->owner, me, 0))
+        if (!NativeCompareAndSwap(&tl->owner, me, 0))
             js_Dequeue(tl);
     }
     else if (Thin_RemoveWait(ReadWord(tl->owner)) == me) {
         LOCKED_OBJ_WRITE_BARRIER(cx, obj, slot, v);
         return;
@@ -878,11 +898,27 @@ js_CleanupLocks()
         fl_list_table_len = 0;
     }
 #endif /* !NSPR_LOCK */
 }
 
-#ifndef NSPR_LOCK
+#ifdef NSPR_LOCK
+
+static JS_INLINE void
+ThinLock(JSThinLock *tl, jsword me)
+{
+    JS_ACQUIRE_LOCK((JSLock *) tl->fat);
+    tl->owner = me;
+}
+
+static JS_INLINE void
+ThinUnlock(JSThinLock *tl, jsword /*me*/)
+{
+    tl->owner = 0;
+    JS_RELEASE_LOCK((JSLock *) tl->fat);
+}
+
+#else
 
 /*
  * Fast locking and unlocking is implemented by delaying the allocation of a
  * system lock (fat lock) until contention.  As long as a locking thread A
  * runs uncontended, the lock is represented solely by storing A's identity in
@@ -968,17 +1004,17 @@ js_Enqueue(JSThinLock *tl, jsword me)
 
     js_LockGlobal(tl);
     for (;;) {
         o = ReadWord(tl->owner);
         n = Thin_SetWait(o);
-        if (o != 0 && js_CompareAndSwap(&tl->owner, o, n)) {
+        if (o != 0 && NativeCompareAndSwap(&tl->owner, o, n)) {
             if (js_SuspendThread(tl))
                 me = Thin_RemoveWait(me);
             else
                 me = Thin_SetWait(me);
         }
-        else if (js_CompareAndSwap(&tl->owner, 0, me)) {
+        else if (NativeCompareAndSwap(&tl->owner, 0, me)) {
             js_UnlockGlobal(tl);
             return;
         }
     }
 }
@@ -990,39 +1026,39 @@ js_Dequeue(JSThinLock *tl)
 
     js_LockGlobal(tl);
     o = ReadWord(tl->owner);
     JS_ASSERT(Thin_GetWait(o) != 0);
     JS_ASSERT(tl->fat != NULL);
-    if (!js_CompareAndSwap(&tl->owner, o, 0)) /* release it */
+    if (!NativeCompareAndSwap(&tl->owner, o, 0)) /* release it */
         JS_ASSERT(0);
     js_ResumeThread(tl);
 }
 
-JS_INLINE void
-js_Lock(JSThinLock *tl, jsword me)
+static JS_INLINE void
+ThinLock(JSThinLock *tl, jsword me)
 {
     JS_ASSERT(CURRENT_THREAD_IS_ME(me));
-    if (js_CompareAndSwap(&tl->owner, 0, me))
+    if (NativeCompareAndSwap(&tl->owner, 0, me))
         return;
     if (Thin_RemoveWait(ReadWord(tl->owner)) != me)
         js_Enqueue(tl, me);
 #ifdef DEBUG
     else
         JS_ASSERT(0);
 #endif
 }
 
-JS_INLINE void
-js_Unlock(JSThinLock *tl, jsword me)
+static JS_INLINE void
+ThinUnlock(JSThinLock *tl, jsword me)
 {
     JS_ASSERT(CURRENT_THREAD_IS_ME(me));
 
     /*
-     * Since we can race with the CompareAndSwap in js_Enqueue, we need
+     * Since we can race with the NativeCompareAndSwap in js_Enqueue, we need
      * to use a C_A_S here as well -- Arjan van de Ven 30/1/08
      */
-    if (js_CompareAndSwap(&tl->owner, me, 0))
+    if (NativeCompareAndSwap(&tl->owner, me, 0))
         return;
 
     JS_ASSERT(Thin_GetWait(tl->owner));
     if (Thin_RemoveWait(ReadWord(tl->owner)) == me)
         js_Dequeue(tl);
@@ -1031,10 +1067,22 @@ js_Unlock(JSThinLock *tl, jsword me)
         JS_ASSERT(0);   /* unbalanced unlock */
 #endif
 }
 
 #endif /* !NSPR_LOCK */
+
+void
+js_Lock(JSContext *cx, JSThinLock *tl)
+{
+    ThinLock(tl, CX_THINLOCK_ID(cx));
+}
+
+void
+js_Unlock(JSContext *cx, JSThinLock *tl)
+{
+    ThinUnlock(tl, CX_THINLOCK_ID(cx));
+}
 
 void
 js_LockRuntime(JSRuntime *rt)
 {
     PR_Lock(rt->rtLock);
@@ -1067,12 +1115,11 @@ js_LockTitle(JSContext *cx, JSTitle *tit
     if (Thin_RemoveWait(ReadWord(title->lock.owner)) == me) {
         JS_ASSERT(title->u.count > 0);
         LOGIT(scope, '+');
         title->u.count++;
     } else {
-        JSThinLock *tl = &title->lock;
-        JS_LOCK0(tl, me);
+        ThinLock(&title->lock, me);
         JS_ASSERT(title->u.count == 0);
         LOGIT(scope, '1');
         title->u.count = 1;
     }
 }
@@ -1115,26 +1162,21 @@ js_UnlockTitle(JSContext *cx, JSTitle *t
     if (Thin_RemoveWait(ReadWord(title->lock.owner)) != me) {
         JS_ASSERT(0);   /* unbalanced unlock */
         return;
     }
     LOGIT(scope, '-');
-    if (--title->u.count == 0) {
-        JSThinLock *tl = &title->lock;
-        JS_UNLOCK0(tl, me);
-    }
+    if (--title->u.count == 0)
+        ThinUnlock(&title->lock, me);
 }
 
 /*
  * NB: oldtitle may be null if our caller is js_GetMutableScope and it just
  * dropped the last reference to oldtitle.
  */
 void
 js_TransferTitle(JSContext *cx, JSTitle *oldtitle, JSTitle *newtitle)
 {
-    jsword me;
-    JSThinLock *tl;
-
     JS_ASSERT(JS_IS_TITLE_LOCKED(cx, newtitle));
 
     /*
      * If the last reference to oldtitle went away, newtitle needs no lock
      * state update.
@@ -1189,13 +1231,11 @@ js_TransferTitle(JSContext *cx, JSTitle 
     /*
      * Reset oldtitle's lock state so that it is completely unlocked.
      */
     LOGIT(oldscope, '0');
     oldtitle->u.count = 0;
-    tl = &oldtitle->lock;
-    me = CX_THINLOCK_ID(cx);
-    JS_UNLOCK0(tl, me);
+    ThinUnlock(&oldtitle->lock, CX_THINLOCK_ID(cx));
 }
 
 void
 js_LockObj(JSContext *cx, JSObject *obj)
 {
diff -r 6c8c95fcaf9b js/src/jslock.h
--- a/js/src/jslock.h	Tue Jul 15 15:16:43 2008 +1200
+++ b/js/src/jslock.h	Thu Jul 17 14:13:04 2008 +0300
@@ -37,51 +37,58 @@
  *
  * ***** END LICENSE BLOCK ***** */
 #ifndef jslock_h__
 #define jslock_h__
 
-#ifdef JS_THREADSAFE
-
 #include "jstypes.h"
-#include "pratom.h"
-#include "prlock.h"
-#include "prcvar.h"
-#include "prthread.h"
-
 #include "jsprvtd.h"    /* for JSScope, etc. */
 #include "jspubtd.h"    /* for JSRuntime, etc. */
 
+#ifdef JS_THREADSAFE
+# include "pratom.h"
+# include "prlock.h"
+# include "prcvar.h"
+# include "prthread.h"
+#endif
+
 JS_BEGIN_EXTERN_C
+
+#ifdef JS_THREADSAFE
+
+#if (defined(_WIN32) && defined(_M_IX86)) ||                                  \
+    (defined(__GNUC__) && defined(__i386__)) ||                               \
+    (defined(SOLARIS) && defined(sparc) && defined(ULTRA_SPARC)) ||           \
+    defined(AIX) ||                                                           \
+    defined(USE_ARM_KUSER) ||                                                 \
+    (defined(__GNUC__) &&                                                     \
+     (__GNUC__ >= 5 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 1)))
+# define JS_HAS_NATIVE_COMPARE_AND_SWAP 1
+#else
+# define JS_HAS_NATIVE_COMPARE_AND_SWAP 0
+#endif
+
+#if defined(JS_USE_ONLY_NSPR_LOCKS) || !JS_HAS_NATIVE_COMPARE_AND_SWAP
+# define NSPR_LOCK 1
+#else
+# undef NSPR_LOCK
+#endif
 
 #define Thin_GetWait(W) ((jsword)(W) & 0x1)
 #define Thin_SetWait(W) ((jsword)(W) | 0x1)
 #define Thin_RemoveWait(W) ((jsword)(W) & ~0x1)
 
 typedef struct JSFatLock JSFatLock;
-
-struct JSFatLock {
-    int         susp;
-    PRLock      *slock;
-    PRCondVar   *svar;
-    JSFatLock   *next;
-    JSFatLock   **prevp;
-};
 
 typedef struct JSThinLock {
     jsword      owner;
     JSFatLock   *fat;
 } JSThinLock;
 
 #define CX_THINLOCK_ID(cx)       ((jsword)(cx)->thread)
 #define CURRENT_THREAD_IS_ME(me) (((JSThread *)me)->id == js_CurrentThreadId())
 
 typedef PRLock JSLock;
-
-typedef struct JSFatLockTable {
-    JSFatLock   *free;
-    JSFatLock   *taken;
-} JSFatLockTable;
 
 typedef struct JSTitle JSTitle;
 
 struct JSTitle {
     JSContext       *ownercx;           /* creating context, NULL if shared */
@@ -92,11 +99,11 @@ struct JSTitle {
     } u;
 #ifdef JS_DEBUG_TITLE_LOCKS
     const char      *file[4];           /* file where lock was (re-)taken */
     unsigned int    line[4];            /* line where lock was (re-)taken */
 #endif
-};    
+};
 
 /*
  * Title structures must be immediately preceded by JSObjectMap structures for
  * maps that use titles for threadsafety.  This is enforced by assertion in
  * jsscope.h; see bug 408416 for future remedies to this somewhat fragile
@@ -117,12 +124,10 @@ struct JSTitle {
 #define js_CurrentThreadId()        (jsword)PR_GetCurrentThread()
 #define JS_NEW_LOCK()               PR_NewLock()
 #define JS_DESTROY_LOCK(l)          PR_DestroyLock(l)
 #define JS_ACQUIRE_LOCK(l)          PR_Lock(l)
 #define JS_RELEASE_LOCK(l)          PR_Unlock(l)
-#define JS_LOCK0(P,M)               js_Lock(P,M)
-#define JS_UNLOCK0(P,M)             js_Unlock(P,M)
 
 #define JS_NEW_CONDVAR(l)           PR_NewCondVar(l)
 #define JS_DESTROY_CONDVAR(cv)      PR_DestroyCondVar(cv)
 #define JS_WAIT_CONDVAR(cv,to)      PR_WaitCondVar(cv,to)
 #define JS_NO_TIMEOUT               PR_INTERVAL_NO_TIMEOUT
@@ -136,10 +141,13 @@ struct JSTitle {
 
 #define SET_SCOPE_INFO(scope_, file_, line_)                                   \
     js_SetScopeInfo(scope_, file_, line_)
 
 #endif
+
+#define JS_LOCK(cx, tl)             js_Lock(cx, tl)
+#define JS_UNLOCK(cx, tl)           js_Unlock(cx, tl)
 
 #define JS_LOCK_RUNTIME(rt)         js_LockRuntime(rt)
 #define JS_UNLOCK_RUNTIME(rt)       js_UnlockRuntime(rt)
 
 /*
@@ -168,10 +176,13 @@ struct JSTitle {
 #define JS_UNLOCK_SCOPE(cx,scope) JS_UNLOCK_TITLE(cx,&(scope)->title)
 
 #define JS_TRANSFER_SCOPE_LOCK(cx, scope, newscope)                            \
     js_TransferTitle(cx, &scope->title, &newscope->title)
 
+
+extern void js_Lock(JSContext *cx, JSThinLock *tl);
+extern void js_Unlock(JSContext *cx, JSThinLock *tl);
 extern void js_LockRuntime(JSRuntime *rt);
 extern void js_UnlockRuntime(JSRuntime *rt);
 extern void js_LockObj(JSContext *cx, JSObject *obj);
 extern void js_UnlockObj(JSContext *cx, JSObject *obj);
 extern void js_InitTitle(JSContext *cx, JSTitle *title);
@@ -220,47 +231,23 @@ extern void js_SetScopeInfo(JSScope *sco
     JS_BEGIN_MACRO                                                            \
         JSRuntime *_rt = (cx)->runtime;                                       \
         JS_LOCK_RUNTIME_VOID(_rt, e);                                         \
     JS_END_MACRO
 
-#if defined(JS_USE_ONLY_NSPR_LOCKS) ||                                        \
-    !( (defined(_WIN32) && defined(_M_IX86)) ||                               \
-       (defined(__GNUC__) && defined(__i386__)) ||                            \
-       (defined(SOLARIS) && defined(sparc) && defined(ULTRA_SPARC)) ||        \
-       defined(AIX) || defined(USE_ARM_KUSER))
-
-#define NSPR_LOCK 1
-
-#undef JS_LOCK0
-#undef JS_UNLOCK0
-#define JS_LOCK0(P,M)   (JS_ACQUIRE_LOCK(((JSLock*)(P)->fat)), (P)->owner = (M))
-#define JS_UNLOCK0(P,M) ((P)->owner = 0, JS_RELEASE_LOCK(((JSLock*)(P)->fat)))
-
-#else  /* arch-tests */
-
-#undef NSPR_LOCK
-
-extern void js_Lock(JSThinLock *tl, jsword me);
-extern void js_Unlock(JSThinLock *tl, jsword me);
-
-#endif /* arch-tests */
-
 #else  /* !JS_THREADSAFE */
-
-JS_BEGIN_EXTERN_C
 
 #define JS_ATOMIC_INCREMENT(p)      (++*(p))
 #define JS_ATOMIC_DECREMENT(p)      (--*(p))
 #define JS_ATOMIC_ADD(p,v)          (*(p) += (v))
 
 #define JS_CurrentThreadId() 0
 #define JS_NEW_LOCK()               NULL
 #define JS_DESTROY_LOCK(l)          ((void)0)
 #define JS_ACQUIRE_LOCK(l)          ((void)0)
 #define JS_RELEASE_LOCK(l)          ((void)0)
-#define JS_LOCK0(P,M)               ((void)0)
-#define JS_UNLOCK0(P,M)             ((void)0)
+#define JS_LOCK(cx, tl)             ((void)0)
+#define JS_UNLOCK(cx, tl)           ((void)0)
 
 #define JS_NEW_CONDVAR(l)           NULL
 #define JS_DESTROY_CONDVAR(cv)      ((void)0)
 #define JS_WAIT_CONDVAR(cv,to)      ((void)0)
 #define JS_NOTIFY_CONDVAR(cv)       ((void)0)
@@ -296,13 +283,10 @@ JS_BEGIN_EXTERN_C
 #define JS_NOTIFY_GC_DONE(rt)       JS_NOTIFY_ALL_CONDVAR((rt)->gcDone)
 #define JS_AWAIT_REQUEST_DONE(rt)   JS_WAIT_CONDVAR((rt)->requestDone,        \
                                                     JS_NO_TIMEOUT)
 #define JS_NOTIFY_REQUEST_DONE(rt)  JS_NOTIFY_CONDVAR((rt)->requestDone)
 
-#define JS_LOCK(P,CX)               JS_LOCK0(P, CX_THINLOCK_ID(CX))
-#define JS_UNLOCK(P,CX)             JS_UNLOCK0(P, CX_THINLOCK_ID(CX))
- 
 #ifndef SET_OBJ_INFO
 #define SET_OBJ_INFO(obj,f,l)       ((void)0)
 #endif
 #ifndef SET_TITLE_INFO
 #define SET_TITLE_INFO(title,f,l)   ((void)0)
diff -r 6c8c95fcaf9b layout/base/Makefile.in
--- a/layout/base/Makefile.in	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/base/Makefile.in	Thu Jul 17 14:13:04 2008 +0300
@@ -89,18 +89,18 @@ XPIDLSRCS	= \
 		$(NULL)
 
 EXPORTS		= \
 		nsBidi.h \
 		nsBidiPresUtils.h \
+		nsCaret.h \
 		nsCSSFrameConstructor.h \
 		nsChangeHint.h \
 		nsCompatibility.h \
 		nsDisplayList.h \
 		nsFrameManager.h \
 		nsFrameManagerBase.h \
 		nsFrameTraversal.h \
-		nsICaret.h \
 		nsIDocumentViewer.h \
 		nsIFrameTraversal.h \
 		nsIImageMap.h \
 		nsILayoutDebugger.h \
 		nsILayoutHistoryState.h \
diff -r 6c8c95fcaf9b layout/base/nsCSSRendering.cpp
--- a/layout/base/nsCSSRendering.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/base/nsCSSRendering.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -24,10 +24,11 @@
  *   Mats Palmgren <mats.palmgren@bredband.net>
  *   Takeshi Ichimaru <ayakawa.m@gmail.com>
  *   Masayuki Nakano <masayuki@d-toybox.com>
  *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation
  *   Michael Ventnor <m.ventnor@gmail.com>
+ *   Rob Arnold <robarnold@mozilla.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
@@ -70,12 +71,15 @@
 #include "nsIServiceManager.h"
 #include "nsIHTMLDocument.h"
 #include "nsLayoutUtils.h"
 #include "nsINameSpaceManager.h"
 #include "nsBlockFrame.h"
-
 #include "gfxContext.h"
+#include "nsIInterfaceRequestorUtils.h"
+#include "gfxPlatform.h"
+#include "gfxImageSurface.h"
+#include "nsStyleStructInlines.h"
 
 #define BORDER_FULL    0        //entire side
 #define BORDER_INSIDE  1        //inside half
 #define BORDER_OUTSIDE 2        //outside half
 
@@ -2693,10 +2697,16 @@ nsCSSRendering::PaintBorder(nsPresContex
     nsITheme *theme = aPresContext->GetTheme();
     if (theme && theme->ThemeSupportsWidget(aPresContext, aForFrame, displayData->mAppearance))
       return; // Let the theme handle it.
   }
 
+  if (aBorderStyle.IsBorderImageLoaded()) {
+    DrawBorderImage(aPresContext, aRenderingContext, aForFrame,
+                    aBorderArea, aBorderStyle, aHardBorderSize);
+    return;
+  }
+  
   // Get our style context's color struct.
   const nsStyleColor* ourColor = aStyleContext->GetStyleColor();
 
   // in NavQuirks mode we want to use the parent's context as a starting point
   // for determining the background color
@@ -2704,11 +2714,11 @@ nsCSSRendering::PaintBorder(nsPresContex
     (aStyleContext, compatMode == eCompatibility_NavQuirks ? PR_TRUE : PR_FALSE);
 
   if (aHardBorderSize > 0) {
     border.SizeTo(aHardBorderSize, aHardBorderSize, aHardBorderSize, aHardBorderSize);
   } else {
-    border = aBorderStyle.GetBorder();
+    border = aBorderStyle.GetComputedBorder();
   }
 
   if ((0 == border.left) && (0 == border.right) &&
       (0 == border.top) && (0 == border.bottom)) {
     // Empty border area
@@ -3337,11 +3347,11 @@ nsCSSRendering::PaintBoxShadow(nsPresCon
   gfxFloat      borderRadii[4];
   PRIntn        sidesToSkip;
   nsRect        frameRect;
 
   const nsStyleBorder* styleBorder = aForFrame->GetStyleBorder();
-  borderValues = styleBorder->GetBorder();
+  borderValues = styleBorder->GetActualBorder();
   sidesToSkip = aForFrame->GetSkipSides();
   frameRect = nsRect(aForFramePt, aForFrame->GetSize());
 
   // Get any border radius, since box-shadow must also have rounded corners if the frame does
   nscoord twipsRadii[4];
@@ -3724,24 +3734,17 @@ nsCSSRendering::PaintBackgroundWithSC(ns
   nscoord tileWidth = imageSize.width;
   nscoord tileHeight = imageSize.height;
   PRBool  needBackgroundColor = !(aColor.mBackgroundFlags &
                                   NS_STYLE_BG_COLOR_TRANSPARENT);
   PRIntn  repeat = aColor.mBackgroundRepeat;
-  nscoord xDistance, yDistance;
 
   switch (repeat) {
     case NS_STYLE_BG_REPEAT_X:
-      xDistance = dirtyRect.width;
-      yDistance = tileHeight;
       break;
     case NS_STYLE_BG_REPEAT_Y:
-      xDistance = tileWidth;
-      yDistance = dirtyRect.height;
       break;
     case NS_STYLE_BG_REPEAT_XY:
-      xDistance = dirtyRect.width;
-      yDistance = dirtyRect.height;
       if (needBackgroundColor) {
         // If the image is completely opaque, we do not need to paint the
         // background color
         nsCOMPtr<gfxIImageFrame> gfxImgFrame;
         image->GetCurrentFrame(getter_AddRefs(gfxImgFrame));
@@ -3762,12 +3765,10 @@ nsCSSRendering::PaintBackgroundWithSC(ns
       }
       break;
     case NS_STYLE_BG_REPEAT_OFF:
     default:
       NS_ASSERTION(repeat == NS_STYLE_BG_REPEAT_OFF, "unknown background-repeat value");
-      xDistance = tileWidth;
-      yDistance = tileHeight;
       break;
   }
 
   // The background color is rendered over the 'background-clip' area
   if (needBackgroundColor) {
@@ -3844,11 +3845,11 @@ nsCSSRendering::PaintBackgroundWithSC(ns
       if (firstRootElementFrame) {
         firstRootElementFrameArea = firstRootElementFrame->GetRect();
 
         // Take the border out of the frame's rect
         const nsStyleBorder* borderStyle = firstRootElementFrame->GetStyleBorder();
-        firstRootElementFrameArea.Deflate(borderStyle->GetBorder());
+        firstRootElementFrameArea.Deflate(borderStyle->GetActualBorder());
 
         // Get the anchor point
         ComputeBackgroundAnchorPoint(aColor, firstRootElementFrameArea +
             aBorderArea.TopLeft(), bgClipArea, tileWidth, tileHeight, anchor);
       } else {
@@ -3884,11 +3885,11 @@ nsCSSRendering::PaintBackgroundWithSC(ns
   nscoord borderRadii[4];
   PRBool haveRadius = GetBorderRadiusTwips(aBorder.mBorderRadius, aForFrame->GetSize().width, borderRadii);
 
   if (haveRadius) {
     gfxFloat radii[4];
-    ComputePixelRadii(borderRadii, bgClipArea, aBorder.GetBorder(),
+    ComputePixelRadii(borderRadii, bgClipArea, aBorder.GetActualBorder(),
                       aForFrame ? aForFrame->GetSkipSides() : 0,
                       appUnitsPerPixel, radii);
 
     gfxRect oRect(RectToGfxRect(bgClipArea, appUnitsPerPixel));
     oRect.Round();
@@ -4060,10 +4061,405 @@ nsCSSRendering::PaintBackgroundWithSC(ns
   ctx->Restore();
 
 }
 
 void
+nsCSSRendering::DrawBorderImage(nsPresContext* aPresContext,
+                                nsIRenderingContext& aRenderingContext,
+                                nsIFrame* aForFrame,
+                                const nsRect& aBorderArea,
+                                const nsStyleBorder& aBorderStyle,
+                                nscoord aHardBorderSize)
+{
+    float percent;
+    nsStyleCoord borderImageSplit[4];
+    PRInt32 borderImageSplitInt[4];
+    nsMargin border;
+    gfxFloat borderTop, borderRight, borderBottom, borderLeft;
+    gfxFloat borderImageSplitGfx[4];
+
+    if (aHardBorderSize > 0) {
+      border.SizeTo(aHardBorderSize, aHardBorderSize, aHardBorderSize, aHardBorderSize);
+    } else {
+      border = aBorderStyle.GetActualBorder();
+    }
+
+    if ((0 == border.left) && (0 == border.right) &&
+        (0 == border.top) && (0 == border.bottom)) {
+      // Empty border area
+      return;
+    }
+
+    borderImageSplit[NS_SIDE_TOP] = aBorderStyle.mBorderImageSplit.GetTop();
+    borderImageSplit[NS_SIDE_RIGHT] = aBorderStyle.mBorderImageSplit.GetRight();
+    borderImageSplit[NS_SIDE_BOTTOM] = aBorderStyle.mBorderImageSplit.GetBottom();
+    borderImageSplit[NS_SIDE_LEFT] = aBorderStyle.mBorderImageSplit.GetLeft();
+
+    imgIRequest *req = aPresContext->LoadBorderImage(aBorderStyle.GetBorderImage(), aForFrame);
+
+    nsCOMPtr<imgIContainer> image;
+    req->GetImage(getter_AddRefs(image));
+
+    nsSize imageSize;
+    image->GetWidth(&imageSize.width);
+    image->GetHeight(&imageSize.height);
+    imageSize.width = nsPresContext::CSSPixelsToAppUnits(imageSize.width);
+    imageSize.height = nsPresContext::CSSPixelsToAppUnits(imageSize.height);
+
+    // convert percentage values
+    NS_FOR_CSS_SIDES(side) {
+      borderImageSplitInt[side] = 0;
+      switch (borderImageSplit[side].GetUnit()) {
+        case eStyleUnit_Percent:
+          percent = borderImageSplit[side].GetPercentValue();
+          if (side == NS_SIDE_TOP || side == NS_SIDE_BOTTOM)
+            borderImageSplitInt[side] = (nscoord)(percent * imageSize.height);
+          else
+            borderImageSplitInt[side] = (nscoord)(percent * imageSize.width);
+          break;
+        case eStyleUnit_Integer:
+          borderImageSplitInt[side] = nsPresContext::CSSPixelsToAppUnits(borderImageSplit[side].
+                                          GetIntValue());
+          break;
+        case eStyleUnit_Factor:
+          borderImageSplitInt[side] = nsPresContext::CSSPixelsToAppUnits(borderImageSplit[side].GetFactorValue());
+          break;
+        default:
+          break;
+      }
+    }
+
+    gfxContext *thebesCtx = aRenderingContext.ThebesContext();
+    nsCOMPtr<nsIDeviceContext> dc;
+    aRenderingContext.GetDeviceContext(*getter_AddRefs(dc));
+
+    NS_FOR_CSS_SIDES(side) {
+      borderImageSplitGfx[side] = nsPresContext::AppUnitsToFloatCSSPixels(borderImageSplitInt[side]);
+    }
+
+    borderTop = dc->AppUnitsToGfxUnits(border.top);
+    borderRight = dc->AppUnitsToGfxUnits(border.right);
+    borderBottom = dc->AppUnitsToGfxUnits(border.bottom);
+    borderLeft = dc->AppUnitsToGfxUnits(border.left);
+
+    gfxSize gfxImageSize;
+    gfxImageSize.width = nsPresContext::AppUnitsToFloatCSSPixels(imageSize.width);
+    gfxImageSize.height = nsPresContext::AppUnitsToFloatCSSPixels(imageSize.height);
+
+    nsRect outerRect(aBorderArea);
+    gfxRect rectToDraw,
+            rectToDrawSource;
+
+    gfxRect clipRect;
+    clipRect.pos.x = dc->AppUnitsToGfxUnits(outerRect.x);
+    clipRect.pos.y = dc->AppUnitsToGfxUnits(outerRect.y);
+    clipRect.size.width = dc->AppUnitsToGfxUnits(outerRect.width);
+    clipRect.size.height = dc->AppUnitsToGfxUnits(outerRect.height);
+    thebesCtx->UserToDevicePixelSnapped(clipRect);
+
+    thebesCtx->Save();
+    thebesCtx->PushGroup(gfxASurface::CONTENT_COLOR_ALPHA);
+
+    gfxSize middleSize(clipRect.size.width - (borderLeft + borderRight),
+                       clipRect.size.height - (borderTop + borderBottom));
+
+    // middle size in source space
+    gfxIntSize middleSizeSource(gfxImageSize.width - (borderImageSplitGfx[NS_SIDE_RIGHT] + borderImageSplitGfx[NS_SIDE_LEFT]), 
+                                gfxImageSize.height - (borderImageSplitGfx[NS_SIDE_TOP] + borderImageSplitGfx[NS_SIDE_BOTTOM]));
+
+    gfxSize interSizeTop, interSizeBottom, interSizeLeft, interSizeRight,
+            interSizeMiddle;
+    gfxFloat topScale = borderTop/borderImageSplitGfx[NS_SIDE_TOP];
+    gfxFloat bottomScale = borderBottom/borderImageSplitGfx[NS_SIDE_BOTTOM];
+    gfxFloat leftScale = borderLeft/borderImageSplitGfx[NS_SIDE_LEFT];
+    gfxFloat rightScale = borderRight/borderImageSplitGfx[NS_SIDE_RIGHT];
+    gfxFloat middleScaleH,
+             middleScaleV;
+    // TODO: check for nan and properly check for inf
+    if (topScale != 0.0 && borderImageSplitGfx[NS_SIDE_TOP] != 0.0) {
+      middleScaleH = topScale;
+    } else if (bottomScale != 0.0 && borderImageSplitGfx[NS_SIDE_BOTTOM] != 0.0) {
+      middleScaleH = bottomScale;
+    } else {
+      middleScaleH = 1.0;
+    }
+
+    if (leftScale != 0.0 && borderImageSplitGfx[NS_SIDE_LEFT] != 0.0) {
+      middleScaleV = leftScale;
+    } else if (rightScale != 0.0 && borderImageSplitGfx[NS_SIDE_RIGHT] != 0.0) {
+      middleScaleV = rightScale;
+    } else {
+      middleScaleV = 1.0;
+    }
+
+    interSizeTop.height = borderTop;
+    interSizeTop.width = middleSizeSource.width*topScale;
+
+    interSizeBottom.height = borderBottom;
+    interSizeBottom.width = middleSizeSource.width*bottomScale;
+
+    interSizeLeft.width = borderLeft;
+    interSizeLeft.height = middleSizeSource.height*leftScale;
+
+    interSizeRight.width = borderRight;
+    interSizeRight.height = middleSizeSource.height*rightScale;
+
+    interSizeMiddle.width = middleSizeSource.width*middleScaleH;
+    interSizeMiddle.height = middleSizeSource.height*middleScaleV;
+
+    // draw top left corner
+    rectToDraw = clipRect;
+    rectToDraw.size.width = borderLeft;
+    rectToDraw.size.height = borderTop;
+    rectToDrawSource.pos.x = 0;
+    rectToDrawSource.pos.y = 0;
+    rectToDrawSource.size.width = borderImageSplitGfx[NS_SIDE_LEFT];
+    rectToDrawSource.size.height = borderImageSplitGfx[NS_SIDE_TOP];
+    DrawBorderImageSide(thebesCtx, dc, image,
+                        rectToDraw, rectToDraw.size, rectToDrawSource,
+                        NS_STYLE_BORDER_IMAGE_STRETCH, NS_STYLE_BORDER_IMAGE_STRETCH);
+
+    // draw top
+    rectToDraw = clipRect;
+    rectToDraw.pos.x += borderLeft;
+    rectToDraw.size.width = middleSize.width;
+    rectToDraw.size.height = borderTop;
+    rectToDrawSource.pos.x = borderImageSplitGfx[NS_SIDE_LEFT];
+    rectToDrawSource.pos.y = 0;
+    rectToDrawSource.size.width = middleSizeSource.width;
+    rectToDrawSource.size.height = borderImageSplitGfx[NS_SIDE_TOP];
+    DrawBorderImageSide(thebesCtx, dc, image,
+                        rectToDraw, interSizeTop, rectToDrawSource, 
+                        aBorderStyle.mBorderImageHFill, NS_STYLE_BORDER_IMAGE_STRETCH);
+    
+    // draw top right corner
+    rectToDraw = clipRect;
+    rectToDraw.pos.x += clipRect.size.width - borderRight;
+    rectToDraw.size.width = borderRight;
+    rectToDraw.size.height = borderTop;
+    rectToDrawSource.pos.x = gfxImageSize.width - borderImageSplitGfx[NS_SIDE_RIGHT];
+    rectToDrawSource.pos.y = 0;
+    rectToDrawSource.size.width = borderImageSplitGfx[NS_SIDE_RIGHT];
+    rectToDrawSource.size.height = borderImageSplitGfx[NS_SIDE_TOP];
+    DrawBorderImageSide(thebesCtx, dc, image,
+                        rectToDraw, rectToDraw.size, rectToDrawSource,
+                        NS_STYLE_BORDER_IMAGE_STRETCH, NS_STYLE_BORDER_IMAGE_STRETCH);
+    
+    // draw right
+    rectToDraw = clipRect;
+    rectToDraw.pos.x += clipRect.size.width - borderRight;
+    rectToDraw.pos.y += borderTop;
+    rectToDraw.size.width = borderRight;
+    rectToDraw.size.height = middleSize.height;
+    rectToDrawSource.pos.x = gfxImageSize.width - borderImageSplitGfx[NS_SIDE_RIGHT];
+    rectToDrawSource.pos.y = borderImageSplitGfx[NS_SIDE_TOP];
+    rectToDrawSource.size.width = borderImageSplitGfx[NS_SIDE_RIGHT];
+    rectToDrawSource.size.height = middleSizeSource.height;
+    DrawBorderImageSide(thebesCtx, dc, image,
+                        rectToDraw, interSizeRight, rectToDrawSource, 
+                        NS_STYLE_BORDER_IMAGE_STRETCH, aBorderStyle.mBorderImageVFill);
+    
+    // draw bottom right corner
+    rectToDraw = clipRect;
+    rectToDraw.pos.x += clipRect.size.width - borderRight;
+    rectToDraw.pos.y += clipRect.size.height - borderBottom;
+    rectToDraw.size.width = borderRight;
+    rectToDraw.size.height = borderBottom;
+    rectToDrawSource.pos.x = gfxImageSize.width - borderImageSplitGfx[NS_SIDE_RIGHT];
+    rectToDrawSource.pos.y = gfxImageSize.height - borderImageSplitGfx[NS_SIDE_BOTTOM];
+    rectToDrawSource.size.width = borderImageSplitGfx[NS_SIDE_RIGHT];
+    rectToDrawSource.size.height = borderImageSplitGfx[NS_SIDE_BOTTOM];
+    DrawBorderImageSide(thebesCtx, dc, image,
+                        rectToDraw, rectToDraw.size, rectToDrawSource,
+                        NS_STYLE_BORDER_IMAGE_STRETCH, NS_STYLE_BORDER_IMAGE_STRETCH);
+    
+    // draw bottom
+    rectToDraw = clipRect;
+    rectToDraw.pos.x += borderLeft;
+    rectToDraw.pos.y += clipRect.size.height - borderBottom;
+    rectToDraw.size.width = middleSize.width;
+    rectToDraw.size.height = borderBottom;
+    rectToDrawSource.pos.x = borderImageSplitGfx[NS_SIDE_LEFT];
+    rectToDrawSource.pos.y = gfxImageSize.height - borderImageSplitGfx[NS_SIDE_BOTTOM];
+    rectToDrawSource.size.width = middleSizeSource.width;
+    rectToDrawSource.size.height = borderImageSplitGfx[NS_SIDE_BOTTOM];
+    DrawBorderImageSide(thebesCtx, dc, image,
+                        rectToDraw, interSizeBottom, rectToDrawSource, 
+                        aBorderStyle.mBorderImageHFill, NS_STYLE_BORDER_IMAGE_STRETCH);
+    
+    // draw bottom left corner
+    rectToDraw = clipRect;
+    rectToDraw.pos.y += clipRect.size.height - borderBottom;
+    rectToDraw.size.width = borderLeft;
+    rectToDraw.size.height = borderBottom;
+    rectToDrawSource.pos.x = 0;
+    rectToDrawSource.pos.y = gfxImageSize.height - borderImageSplitGfx[NS_SIDE_BOTTOM];
+    rectToDrawSource.size.width = borderImageSplitGfx[NS_SIDE_LEFT];
+    rectToDrawSource.size.height = borderImageSplitGfx[NS_SIDE_BOTTOM];
+    DrawBorderImageSide(thebesCtx, dc, image,
+                        rectToDraw, rectToDraw.size, rectToDrawSource,
+                        NS_STYLE_BORDER_IMAGE_STRETCH, NS_STYLE_BORDER_IMAGE_STRETCH);
+    
+    // draw left
+    rectToDraw = clipRect;
+    rectToDraw.pos.y += borderTop;
+    rectToDraw.size.width = borderLeft;
+    rectToDraw.size.height = middleSize.height;
+    rectToDrawSource.pos.x = 0;
+    rectToDrawSource.pos.y = borderImageSplitGfx[NS_SIDE_TOP];
+    rectToDrawSource.size.width = borderImageSplitGfx[NS_SIDE_LEFT];
+    rectToDrawSource.size.height = middleSizeSource.height;
+    DrawBorderImageSide(thebesCtx, dc, image,
+                        rectToDraw, interSizeLeft, rectToDrawSource, 
+                        NS_STYLE_BORDER_IMAGE_STRETCH, aBorderStyle.mBorderImageVFill);
+
+    // Draw middle
+    rectToDraw = clipRect;
+    rectToDraw.pos.x += borderLeft;
+    rectToDraw.pos.y += borderTop;
+    rectToDraw.size.width = middleSize.width;
+    rectToDraw.size.height = middleSize.height;
+    rectToDrawSource.pos.x = borderImageSplitGfx[NS_SIDE_LEFT];
+    rectToDrawSource.pos.y = borderImageSplitGfx[NS_SIDE_TOP];
+    rectToDrawSource.size = middleSizeSource;
+    DrawBorderImageSide(thebesCtx, dc, image,
+                        rectToDraw, interSizeMiddle, rectToDrawSource,
+                        aBorderStyle.mBorderImageHFill, aBorderStyle.mBorderImageVFill);
+
+    thebesCtx->PopGroupToSource();
+    thebesCtx->SetOperator(gfxContext::OPERATOR_OVER);
+    thebesCtx->Paint();
+    thebesCtx->Restore();
+}
+
+void
+nsCSSRendering::DrawBorderImageSide(gfxContext *aThebesContext,
+                                    nsIDeviceContext* aDeviceContext,
+                                    imgIContainer* aImage,
+                                    gfxRect& aDestRect,
+                                    gfxSize& aInterSize,
+                                    gfxRect& aSourceRect,
+                                    PRUint8 aHFillType,
+                                    PRUint8 aVFillType)
+{
+  if (aDestRect.size.width < 1.0 || aDestRect.size.height < 1.0 ||
+      aSourceRect.size.width < 1.0 || aSourceRect.size.height < 1.0) {
+    return;
+  }
+
+  gfxIntSize gfxSourceSize((PRInt32)aSourceRect.size.width,
+                           (PRInt32)aSourceRect.size.height);
+
+  // where the actual border ends up being rendered
+  aThebesContext->UserToDevicePixelSnapped(aDestRect);
+  aThebesContext->UserToDevicePixelSnapped(aSourceRect);
+
+  if (aDestRect.size.height < 1.0 ||
+     aDestRect.size.width < 1.0)
+    return;
+
+  if (aInterSize.width < 1.0 ||
+     aInterSize.height < 1.0)
+    return;
+
+  // Surface will hold just the part of the source image specified by the aSourceRect
+  // but at a different size
+  nsRefPtr<gfxASurface> interSurface =
+    gfxPlatform::GetPlatform()->CreateOffscreenSurface(
+        gfxSourceSize, gfxASurface::ImageFormatARGB32);
+
+  gfxMatrix srcMatrix;
+  // Adjust the matrix scale for Step 1 of the spec
+  srcMatrix.Scale(aSourceRect.size.width/aInterSize.width,
+                  aSourceRect.size.height/aInterSize.height);
+  {
+    nsCOMPtr<gfxIImageFrame> frame;
+    nsresult rv = aImage->GetCurrentFrame(getter_AddRefs(frame));
+    if(NS_FAILED(rv))
+      return;
+    nsCOMPtr<nsIImage> image;
+    image = do_GetInterface(frame);
+    if(!image)
+      return;
+
+    // surface for the whole image
+    nsRefPtr<gfxPattern> imagePattern;
+    rv = image->GetPattern(getter_AddRefs(imagePattern));
+    if(NS_FAILED(rv) || !imagePattern)
+      return;
+
+    gfxMatrix mat;
+    mat.Translate(aSourceRect.pos);
+    imagePattern->SetMatrix(mat);
+
+    // Straightforward blit - no resizing
+    nsRefPtr<gfxContext> srcCtx = new gfxContext(interSurface);
+    srcCtx->SetPattern(imagePattern);
+    srcCtx->SetOperator(gfxContext::OPERATOR_SOURCE);
+    srcCtx->Paint();
+    srcCtx = nsnull;
+
+  }
+
+  // offset to make the middle tile centered in the middle of the border
+  gfxPoint renderOffset(0, 0);
+  gfxSize rectSize(aDestRect.size);
+
+  aThebesContext->Save();
+  aThebesContext->Clip(aDestRect);
+
+  gfxFloat hScale(1.0), vScale(1.0);
+
+  nsRefPtr<gfxPattern> pattern = new gfxPattern(interSurface);
+  pattern->SetExtend(gfxPattern::EXTEND_PAD);
+  switch (aHFillType) {
+    case NS_STYLE_BORDER_IMAGE_REPEAT:
+      renderOffset.x = (rectSize.width - aInterSize.width*NS_ceil(rectSize.width/aInterSize.width))*-0.5;
+      aDestRect.pos.x -= renderOffset.x;
+      pattern->SetExtend(gfxPattern::EXTEND_REPEAT);
+      break;
+    case NS_STYLE_BORDER_IMAGE_ROUND:
+      hScale = aInterSize.width*(NS_ceil(aDestRect.size.width/aInterSize.width)/aDestRect.size.width);
+      pattern->SetExtend(gfxPattern::EXTEND_REPEAT);
+      break;
+    case NS_STYLE_BORDER_IMAGE_STRETCH:
+    default:
+      hScale = aInterSize.width/aDestRect.size.width;
+      break;
+  }
+
+  switch (aVFillType) {
+    case NS_STYLE_BORDER_IMAGE_REPEAT:
+      renderOffset.y = (rectSize.height - aInterSize.height*NS_ceil(rectSize.height/aInterSize.height))*-0.5;
+      aDestRect.pos.y -= renderOffset.y;
+      pattern->SetExtend(gfxPattern::EXTEND_REPEAT);
+      break;
+    case NS_STYLE_BORDER_IMAGE_ROUND:
+      vScale = aInterSize.height*(NS_ceil(aDestRect.size.height/aInterSize.height)/aDestRect.size.height);
+      pattern->SetExtend(gfxPattern::EXTEND_REPEAT);
+      break;
+    case NS_STYLE_BORDER_IMAGE_STRETCH:
+    default:
+      vScale = aInterSize.height/aDestRect.size.height;
+      break;
+  }
+
+  // Adjust the matrix scale for Step 2 of the spec
+  srcMatrix.Scale(hScale,vScale);
+  pattern->SetMatrix(srcMatrix);
+
+  // render
+  aThebesContext->Translate(aDestRect.pos);
+  aThebesContext->SetPattern(pattern);
+  aThebesContext->NewPath();
+  aThebesContext->Rectangle(gfxRect(renderOffset, rectSize));
+  aThebesContext->SetOperator(gfxContext::OPERATOR_ADD);
+  aThebesContext->Fill();
+  aThebesContext->Restore();
+}
+
+void
 nsCSSRendering::PaintBackgroundColor(nsPresContext* aPresContext,
                                      nsIRenderingContext& aRenderingContext,
                                      nsIFrame* aForFrame,
                                      const nsRect& aBgClipArea,
                                      const nsStyleBackground& aColor,
@@ -4138,11 +4534,11 @@ nsCSSRendering::PaintRoundedBackground(n
     NS_ASSERTION(aColor.mBackgroundClip == NS_STYLE_BG_CLIP_PADDING, "unknown background-clip value");
 
     // Get the radius to the outer edge of the padding.
     // -moz-border-radius is the radius to the outer edge of the border.
     NS_FOR_CSS_SIDES(side) {
-      aTheRadius[side] -= aBorder.GetBorderWidth(side);
+      aTheRadius[side] -= aBorder.GetActualBorderWidth(side);
       aTheRadius[side] = PR_MAX(aTheRadius[side], 0);
     }
   }
 
   // the bgClipArea is the outside
@@ -4152,11 +4548,11 @@ nsCSSRendering::PaintRoundedBackground(n
   if (oRect.IsEmpty())
     return;
 
   // convert the radii
   gfxFloat radii[4];
-  nsMargin border = aBorder.GetBorder();
+  nsMargin border = aBorder.GetActualBorder();
 
   ComputePixelRadii(aTheRadius, aBgClipArea, border,
                     aForFrame ? aForFrame->GetSkipSides() : 0,
                     appUnitsPerPixel, radii);
 
diff -r 6c8c95fcaf9b layout/base/nsCSSRendering.h
--- a/layout/base/nsCSSRendering.h	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/base/nsCSSRendering.h	Thu Jul 17 14:13:04 2008 +0300
@@ -271,10 +271,26 @@ public:
                                       const PRUint8 aDecoration,
                                       const PRUint8 aStyle);
 
 protected:
 
+  static void DrawBorderImage(nsPresContext* aPresContext,
+                              nsIRenderingContext& aRenderingContext,
+                              nsIFrame* aForFrame,
+                              const nsRect& aBorderArea,
+                              const nsStyleBorder& aBorderStyle,
+                              nscoord aHardBorderSize);
+
+  static void DrawBorderImageSide(gfxContext *aThebesContext,
+                                  nsIDeviceContext* aDeviceContext,
+                                  imgIContainer* aImage,
+                                  gfxRect& aDestRect,
+                                  gfxSize& aInterSize,
+                                  gfxRect& aSourceRect,
+                                  PRUint8 aHFillType,
+                                  PRUint8 aVFillType);
+
   static void PaintBackgroundColor(nsPresContext* aPresContext,
                                    nsIRenderingContext& aRenderingContext,
                                    nsIFrame* aForFrame,
                                    const nsRect& aBgClipArea,
                                    const nsStyleBackground& aColor,
diff -r 6c8c95fcaf9b layout/base/nsCaret.cpp
--- a/layout/base/nsCaret.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/base/nsCaret.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -108,14 +108,14 @@ nsCaret::~nsCaret()
 {
   KillTimer();
 }
 
 //-----------------------------------------------------------------------------
-NS_IMETHODIMP nsCaret::Init(nsIPresShell *inPresShell)
+nsresult nsCaret::Init(nsIPresShell *inPresShell)
 {
   NS_ENSURE_ARG(inPresShell);
-  
+
   mPresShell = do_GetWeakReference(inPresShell);    // the presshell owns us, so no addref
   NS_ASSERTION(mPresShell, "Hey, pres shell should support weak refs");
 
   // get nsILookAndFeel from the pres context, which has one cached.
   nsILookAndFeel *lookAndFeel = nsnull;
@@ -159,13 +159,11 @@ NS_IMETHODIMP nsCaret::Init(nsIPresShell
   mDomSelectionWeak = do_GetWeakReference(domSelection);
   
   // set up the blink timer
   if (mVisible)
   {
-    rv = StartBlinking();
-    if (NS_FAILED(rv))
-      return rv;
+    StartBlinking();
   }
 
   return NS_OK;
 }
 
@@ -202,11 +200,11 @@ nsCaret::Metrics nsCaret::ComputeMetrics
   result.mBidiIndicatorSize = NS_ROUND_BORDER_TO_PIXELS(bidiIndicatorSize, tpp);
   return result;
 }
 
 //-----------------------------------------------------------------------------
-NS_IMETHODIMP nsCaret::Terminate()
+void nsCaret::Terminate()
 {
   // this doesn't erase the caret if it's drawn. Should it? We might not have
   // a good drawing environment during teardown.
   
   KillTimer();
@@ -219,31 +217,24 @@ NS_IMETHODIMP nsCaret::Terminate()
     privateSelection->RemoveSelectionListener(this);
   mDomSelectionWeak = nsnull;
   mPresShell = nsnull;
 
   mLastContent = nsnull;
-  
-  return NS_OK;
 }
 
+//-----------------------------------------------------------------------------
+NS_IMPL_ISUPPORTS1(nsCaret, nsISelectionListener)
 
 //-----------------------------------------------------------------------------
-NS_IMPL_ISUPPORTS2(nsCaret, nsICaret, nsISelectionListener)
+nsISelection* nsCaret::GetCaretDOMSelection()
+{
+  nsCOMPtr<nsISelection> sel(do_QueryReferent(mDomSelectionWeak));
+  return sel;  
+}
 
 //-----------------------------------------------------------------------------
-NS_IMETHODIMP nsCaret::GetCaretDOMSelection(nsISelection **aDOMSel)
-{
-  nsCOMPtr<nsISelection> sel(do_QueryReferent(mDomSelectionWeak));
-  
-  NS_IF_ADDREF(*aDOMSel = sel);
-
-  return NS_OK;
-}
-
-
-//-----------------------------------------------------------------------------
-NS_IMETHODIMP nsCaret::SetCaretDOMSelection(nsISelection *aDOMSel)
+nsresult nsCaret::SetCaretDOMSelection(nsISelection *aDOMSel)
 {
   NS_ENSURE_ARG_POINTER(aDOMSel);
   mDomSelectionWeak = do_GetWeakReference(aDOMSel);   // weak reference to pres shell
   if (mVisible)
   {
@@ -255,49 +246,45 @@ NS_IMETHODIMP nsCaret::SetCaretDOMSelect
   return NS_OK;
 }
 
 
 //-----------------------------------------------------------------------------
-NS_IMETHODIMP nsCaret::SetCaretVisible(PRBool inMakeVisible)
+void nsCaret::SetCaretVisible(PRBool inMakeVisible)
 {
   mVisible = inMakeVisible;
-  nsresult  err = NS_OK;
   if (mVisible) {
-    err = StartBlinking();
+    StartBlinking();
     SetIgnoreUserModify(PR_TRUE);
   } else {
-    err = StopBlinking();
+    StopBlinking();
     SetIgnoreUserModify(PR_FALSE);
   }
-
-  return err;
 }
 
 
 //-----------------------------------------------------------------------------
-NS_IMETHODIMP nsCaret::GetCaretVisible(PRBool *outMakeVisible)
+nsresult nsCaret::GetCaretVisible(PRBool *outMakeVisible)
 {
   NS_ENSURE_ARG_POINTER(outMakeVisible);
   *outMakeVisible = (mVisible && MustDrawCaret(PR_TRUE));
   return NS_OK;
 }
 
 
 //-----------------------------------------------------------------------------
-NS_IMETHODIMP nsCaret::SetCaretReadOnly(PRBool inMakeReadonly)
+void nsCaret::SetCaretReadOnly(PRBool inMakeReadonly)
 {
   mReadOnly = inMakeReadonly;
-  return NS_OK;
 }
 
 
 //-----------------------------------------------------------------------------
-NS_IMETHODIMP nsCaret::GetCaretCoordinates(EViewCoordinates aRelativeToType,
-                                           nsISelection *aDOMSel,
-                                           nsRect *outCoordinates,
-                                           PRBool *outIsCollapsed,
-                                           nsIView **outView)
+nsresult nsCaret::GetCaretCoordinates(EViewCoordinates aRelativeToType,
+                                      nsISelection *aDOMSel,
+                                      nsRect *outCoordinates,
+                                      PRBool *outIsCollapsed,
+                                      nsIView **outView)
 {
   if (!mPresShell)
     return NS_ERROR_NOT_INITIALIZED;
   if (!outCoordinates || !outIsCollapsed)
     return NS_ERROR_NULL_POINTER;
@@ -391,32 +378,29 @@ void nsCaret::DrawCaretAfterBriefDelay()
 
   mBlinkTimer->InitWithFuncCallback(CaretBlinkCallback, this, 0,
                                     nsITimer::TYPE_ONE_SHOT);
 }
 
-NS_IMETHODIMP nsCaret::EraseCaret()
+void nsCaret::EraseCaret()
 {
   if (mDrawn) {
     DrawCaret(PR_TRUE);
     if (mReadOnly && mBlinkRate) {
       // If readonly we don't have a blink timer set, so caret won't
       // be redrawn automatically. We need to force the caret to get
       // redrawn right after the paint
       DrawCaretAfterBriefDelay();
     }
   }
-
-  return NS_OK;
 }
 
-NS_IMETHODIMP nsCaret::SetVisibilityDuringSelection(PRBool aVisibility) 
+void nsCaret::SetVisibilityDuringSelection(PRBool aVisibility) 
 {
   mShowDuringSelection = aVisibility;
-  return NS_OK;
 }
 
-NS_IMETHODIMP nsCaret::DrawAtPosition(nsIDOMNode* aNode, PRInt32 aOffset)
+nsresult nsCaret::DrawAtPosition(nsIDOMNode* aNode, PRInt32 aOffset)
 {
   NS_ENSURE_ARG(aNode);
 
   PRUint8 bidiLevel;
   nsCOMPtr<nsFrameSelection> frameSelection = GetFrameSelection();
@@ -577,17 +561,17 @@ nsresult nsCaret::PrimeTimer()
   return NS_OK;
 }
 
 
 //-----------------------------------------------------------------------------
-nsresult nsCaret::StartBlinking()
+void nsCaret::StartBlinking()
 {
   if (mReadOnly) {
     // Make sure the one draw command we use for a readonly caret isn't
     // done until the selection is set
     DrawCaretAfterBriefDelay();
-    return NS_OK;
+    return;
   }
   PrimeTimer();
 
   // If we are currently drawn, then the second call to DrawCaret below will
   // actually erase the caret. That would cause the caret to spend an "off"
@@ -596,25 +580,21 @@ nsresult nsCaret::StartBlinking()
   // StartBlinking is an "on" cycle.
   if (mDrawn)
     DrawCaret(PR_TRUE);
 
   DrawCaret(PR_TRUE);    // draw it right away
-  
-  return NS_OK;
 }
 
 
 //-----------------------------------------------------------------------------
-nsresult nsCaret::StopBlinking()
+void nsCaret::StopBlinking()
 {
   if (mDrawn)     // erase the caret if necessary
     DrawCaret(PR_TRUE);
 
   NS_ASSERTION(!mDrawn, "Caret still drawn after StopBlinking().");
   KillTimer();
-
-  return NS_OK;
 }
 
 PRBool
 nsCaret::DrawAtPositionWithHint(nsIDOMNode*             aNode,
                                 PRInt32                 aOffset,
@@ -735,11 +715,11 @@ AdjustCaretFrameForLineEnd(nsIFrame** aF
       return;
     }
   }
 }
 
-NS_IMETHODIMP 
+nsresult 
 nsCaret::GetCaretFrameForNodeOffset(nsIContent*             aContentNode,
                                     PRInt32                 aOffset,
                                     nsFrameSelection::HINT aFrameHint,
                                     PRUint8                 aBidiLevel,
                                     nsIFrame**              aReturnFrame,
@@ -1356,16 +1336,17 @@ nsCaret::SetIgnoreUserModify(PRBool aIgn
   }
   mIgnoreUserModify = aIgnoreUserModify;
 }
 
 //-----------------------------------------------------------------------------
-nsresult NS_NewCaret(nsICaret** aInstancePtrResult)
+nsresult NS_NewCaret(nsCaret** aInstancePtrResult)
 {
   NS_PRECONDITION(aInstancePtrResult, "null ptr");
   
   nsCaret* caret = new nsCaret();
   if (nsnull == caret)
       return NS_ERROR_OUT_OF_MEMORY;
-      
-  return caret->QueryInterface(NS_GET_IID(nsICaret), (void**) aInstancePtrResult);
+  NS_ADDREF(caret);
+  *aInstancePtrResult = caret;
+  return NS_OK;
 }
 
diff -r 6c8c95fcaf9b layout/base/nsCaret.h
--- a/layout/base/nsCaret.h	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/base/nsCaret.h	Thu Jul 17 14:13:04 2008 +0300
@@ -37,86 +37,174 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 /* the caret is the text cursor used, e.g., when editing */
 
+#ifndef nsCaret_h__
+#define nsCaret_h__
+
 #include "nsCoord.h"
 #include "nsISelectionListener.h"
 #include "nsIRenderingContext.h"
 #include "nsITimer.h"
-#include "nsICaret.h"
 #include "nsWeakPtr.h"
+#include "nsFrameSelection.h"
 
+class nsDisplayListBuilder;
 class nsIView;
 
 //-----------------------------------------------------------------------------
-
-class nsCaret : public nsICaret,
-                public nsISelectionListener
+class nsCaret : public nsISelectionListener
 {
   public:
 
                   nsCaret();
     virtual       ~nsCaret();
-        
+
+    enum EViewCoordinates {
+      eTopLevelWindowCoordinates,
+      eRenderingViewCoordinates,
+      eClosestViewCoordinates,
+      eIMECoordinates
+    };
+
+  public:
+
     NS_DECL_ISUPPORTS
 
-  public:
-  
-    // nsICaret interface
-    NS_IMETHOD    Init(nsIPresShell *inPresShell);
-    NS_IMETHOD    Terminate();
+    nsresult    Init(nsIPresShell *inPresShell);
+    void    Terminate();
 
-    NS_IMETHOD    GetCaretDOMSelection(nsISelection **outDOMSel);
-    NS_IMETHOD    SetCaretDOMSelection(nsISelection *inDOMSel);
-    NS_IMETHOD    GetCaretVisible(PRBool *outMakeVisible);
-    NS_IMETHOD    SetCaretVisible(PRBool intMakeVisible);
-    NS_IMETHOD    SetCaretReadOnly(PRBool inMakeReadonly);
-    virtual PRBool GetCaretReadOnly()
+    nsISelection*    GetCaretDOMSelection();
+    nsresult    SetCaretDOMSelection(nsISelection *inDOMSel);
+
+    /** GetCaretVisible will get the visibility of the caret
+     *  This function is virtual so that it can be used by nsCaretAccessible
+     *  without linking
+     *  @param inMakeVisible PR_TRUE it is shown, PR_FALSE it is hidden
+     *  @return false if and only if inMakeVisible is null, otherwise true 
+     */
+    virtual nsresult    GetCaretVisible(PRBool *outMakeVisible);
+
+    /** SetCaretVisible will set the visibility of the caret
+     *  @param inMakeVisible PR_TRUE to show the caret, PR_FALSE to hide it
+     */
+    void    SetCaretVisible(PRBool intMakeVisible);
+
+    /** SetCaretReadOnly set the appearance of the caret
+     *  @param inMakeReadonly PR_TRUE to show the caret in a 'read only' state,
+     *	    PR_FALSE to show the caret in normal, editing state
+     */
+    void    SetCaretReadOnly(PRBool inMakeReadonly);
+
+    /** GetCaretReadOnly get the appearance of the caret
+     *	@return PR_TRUE if the caret is in 'read only' state, otherwise,
+     *	    returns PR_FALSE
+     */
+    PRBool GetCaretReadOnly()
     {
       return mReadOnly;
     }
-    NS_IMETHOD    GetCaretCoordinates(EViewCoordinates aRelativeToType,
+    /** GetCaretCoordinates
+     *  Get the position of the caret in coordinates relative to the typed
+     *  specified (aRelativeToType).
+     *  This function is virtual so that it can be used by nsCaretAccessible
+     *  without linking
+     *  @param outISCollapsed set to true if and only if selection is collapsed
+     *  @return Caret location if selection is collapsed, otherwise, location
+     *	    of focus position 
+     */
+    virtual nsresult    GetCaretCoordinates(EViewCoordinates aRelativeToType,
                                       nsISelection *inDOMSel,
                                       nsRect* outCoordinates,
                                       PRBool* outIsCollapsed,
                                       nsIView **outView);
-    NS_IMETHOD    EraseCaret();
 
-    NS_IMETHOD    SetVisibilityDuringSelection(PRBool aVisibility);
-    NS_IMETHOD    DrawAtPosition(nsIDOMNode* aNode, PRInt32 aOffset);
+    /** EraseCaret
+     *  this will erase the caret if its drawn and reset drawn status
+     */
+    void    EraseCaret();
+
+    void    SetVisibilityDuringSelection(PRBool aVisibility);
+
+    /** DrawAtPosition
+     *
+     *  Draw the caret explicitly, at the specified node and offset.
+     *  To avoid drawing glitches, you should call EraseCaret()
+     *  after each call to DrawAtPosition().
+     *
+     *  Note: This call breaks the caret's ability to blink at all.
+     **/
+    nsresult    DrawAtPosition(nsIDOMNode* aNode, PRInt32 aOffset);
+
+    /** GetCaretFrame
+     *  Get the current frame that the caret should be drawn in. If the caret is
+     *  not currently visible (i.e., it is between blinks), then this will
+     *  return null.
+     */
     nsIFrame*     GetCaretFrame();
+
+    /** GetCaretRect
+     *  Get the current caret rect. Only call this when GetCaretFrame returns
+     *  non-null.
+     */
     nsRect        GetCaretRect()
     {
       nsRect r;
       r.UnionRect(mCaretRect, GetHookRect());
       return r;
     }
+
+    /** GetCaretContent
+     *  Get the content that the caret was last drawn in.
+     */
     nsIContent*   GetCaretContent()
     {
       if (mDrawn)
         return mLastContent;
 
       return nsnull;
     }
 
+    /** InvalidateOutsideCaret
+     *  Invalidate the area that the caret currently occupies if the caret is
+     *  outside of its frame's overflow area. This is used when the content that
+     *  the caret is currently drawn is is being deleted or reflowed.
+     */
     void      InvalidateOutsideCaret();
+
+    /** UpdateCaretPosition
+     *  Update the caret's current frame and rect, but don't draw yet. This is
+     *  useful for flickerless moving of the caret (e.g., when the frame the
+     *  caret is in reflows and is moved).
+     */
     void      UpdateCaretPosition();
 
+    /** PaintCaret
+     *  Actually paint the caret onto the given rendering context.
+     */
     void      PaintCaret(nsDisplayListBuilder *aBuilder,
                          nsIRenderingContext *aCtx,
                          nsIFrame *aForFrame,
                          const nsPoint &aOffset);
+    /**
+     * Sets whether the caret should only be visible in nodes that are not
+     * user-modify: read-only, or whether it should be visible in all nodes.
+     *
+     * @param aIgnoreUserModify PR_TRUE to have the cursor visible in all nodes,
+     *                          PR_FALSE to have it visible in all nodes except
+     *                          those with user-modify: read-only
+     */
 
     void SetIgnoreUserModify(PRBool aIgnoreUserModify);
 
     //nsISelectionListener interface
     NS_DECL_NSISELECTIONLISTENER
 
     static void   CaretBlinkCallback(nsITimer *aTimer, void *aClosure);
-  
-    NS_IMETHOD    GetCaretFrameForNodeOffset(nsIContent* aContentNode,
+
+    nsresult      GetCaretFrameForNodeOffset(nsIContent* aContentNode,
                                              PRInt32 aOffset,
                                              nsFrameSelection::HINT aFrameHint,
                                              PRUint8 aBidiLevel,
                                              nsIFrame** aReturnFrame,
                                              PRInt32* aReturnOffset);
@@ -126,12 +214,12 @@ protected:
 protected:
 
     void          KillTimer();
     nsresult      PrimeTimer();
 
-    nsresult      StartBlinking();
-    nsresult      StopBlinking();
+    void          StartBlinking();
+    void          StopBlinking();
     
     void          GetViewForRendering(nsIFrame *caretFrame,
                                       EViewCoordinates coordType,
                                       nsPoint &viewOffset,
                                       nsIView **outRenderingView,
@@ -223,5 +311,38 @@ protected:
     PRUint8               mLastBidiLevel;     // saved bidi level of the last draw request, to use when we erase
     PRPackedBool          mKeyboardRTL;       // is the keyboard language right-to-left
 #endif
 };
 
+nsresult
+NS_NewCaret(nsCaret** aInstancePtrResult);
+
+// handy stack-based class for temporarily disabling the caret
+
+class StCaretHider
+{
+public:
+               StCaretHider(nsCaret* aSelCon)
+               : mWasVisible(PR_FALSE), mCaret(aSelCon)
+               {
+                 if (mCaret)
+                 {
+                   mCaret->GetCaretVisible(&mWasVisible);
+                   if (mWasVisible)
+                     mCaret->SetCaretVisible(PR_FALSE);
+                 }
+               }
+
+               ~StCaretHider()
+               {
+                 if (mCaret && mWasVisible)
+                   mCaret->SetCaretVisible(PR_TRUE);
+                 // nsCOMPtr releases mPresShell
+               }
+
+protected:
+
+    PRBool                  mWasVisible;
+    nsCOMPtr<nsCaret>  mCaret;
+};
+
+#endif //nsCaret_h__
diff -r 6c8c95fcaf9b layout/base/nsDisplayList.cpp
--- a/layout/base/nsDisplayList.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/base/nsDisplayList.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -48,10 +48,11 @@
 #include "nsISelectionController.h"
 #include "nsIPresShell.h"
 #include "nsRegion.h"
 #include "nsFrameManager.h"
 #include "gfxContext.h"
+#include "nsStyleStructInlines.h"
 
 nsDisplayListBuilder::nsDisplayListBuilder(nsIFrame* aReferenceFrame,
     PRBool aIsForEvents, PRBool aBuildCaret)
     : mReferenceFrame(aReferenceFrame),
       mMovingFrame(nsnull),
@@ -141,13 +142,13 @@ nsDisplayListBuilder::~nsDisplayListBuil
 
   PL_FreeArenaPool(&mPool);
   PL_FinishArenaPool(&mPool);
 }
 
-nsICaret *
+nsCaret *
 nsDisplayListBuilder::GetCaret() {
-  nsCOMPtr<nsICaret> caret;
+  nsRefPtr<nsCaret> caret;
   CurrentPresShellState()->mPresShell->GetCaret(getter_AddRefs(caret));
   return caret;
 }
 
 void
@@ -161,11 +162,11 @@ nsDisplayListBuilder::EnterPresShell(nsI
   state->mFirstFrameMarkedForDisplay = mFramesMarkedForDisplay.Length();
 
   if (!mBuildCaret)
     return;
 
-  nsCOMPtr<nsICaret> caret;
+  nsRefPtr<nsCaret> caret;
   state->mPresShell->GetCaret(getter_AddRefs(caret));
   state->mCaretFrame = caret->GetCaretFrame();
 
   if (state->mCaretFrame) {
     // Check if the dirty rect intersects with the caret's dirty rect.
@@ -606,15 +607,20 @@ nsDisplayBorder::OptimizeVisibility(nsDi
   if (!nsDisplayItem::OptimizeVisibility(aBuilder, aVisibleRegion))
     return PR_FALSE;
 
   nsRect paddingRect = mFrame->GetPaddingRect() - mFrame->GetPosition() +
     aBuilder->ToReferenceFrame(mFrame);
+  const nsStyleBorder *styleBorder;
   if (paddingRect.Contains(aVisibleRegion->GetBounds()) &&
-      !nsLayoutUtils::HasNonZeroSide(mFrame->GetStyleBorder()->mBorderRadius)) {
+      !(styleBorder = mFrame->GetStyleBorder())->IsBorderImageLoaded() &&
+      !nsLayoutUtils::HasNonZeroSide(styleBorder->mBorderRadius)) {
     // the visible region is entirely inside the content rect, and no part
     // of the border is rendered inside the content rect, so we are not
     // visible
+    // Skip this if there's a border-image (which draws a background
+    // too) or if there is a border-radius (which makes the border draw
+    // further in).
     return PR_FALSE;
   }
 
   return PR_TRUE;
 }
diff -r 6c8c95fcaf9b layout/base/nsDisplayList.h
--- a/layout/base/nsDisplayList.h	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/base/nsDisplayList.h	Thu Jul 17 14:13:04 2008 +0300
@@ -48,13 +48,13 @@
 #include "nsCOMPtr.h"
 #include "nsIFrame.h"
 #include "nsPoint.h"
 #include "nsRect.h"
 #include "nsISelection.h"
+#include "nsCaret.h"
 #include "plarena.h"
 #include "nsLayoutUtils.h"
-#include "nsICaret.h"
 #include "nsTArray.h"
 
 #include <stdlib.h>
 
 class nsIPresShell;
@@ -246,11 +246,11 @@ public:
     return CurrentPresShellState()->mCaretFrame;
   }
   /**
    * Get the caret associated with the current presshell.
    */
-  nsICaret* GetCaret();
+  nsCaret* GetCaret();
   /**
    * Notify the display list builder that we're entering a presshell.
    * aReferenceFrame should be a frame in the new presshell and aDirtyRect
    * should be the current dirty rect in aReferenceFrame's coordinate space.
    */
@@ -953,11 +953,11 @@ protected:
 #endif // MOZ_REFLOW_PERF_DSP && MOZ_REFLOW_PERF
 
 MOZ_DECL_CTOR_COUNTER(nsDisplayCaret)
 class nsDisplayCaret : public nsDisplayItem {
 public:
-  nsDisplayCaret(nsIFrame* aCaretFrame, nsICaret *aCaret)
+  nsDisplayCaret(nsIFrame* aCaretFrame, nsCaret *aCaret)
     : nsDisplayItem(aCaretFrame), mCaret(aCaret) {
     MOZ_COUNT_CTOR(nsDisplayCaret);
   }
 #ifdef NS_BUILD_REFCNT_LOGGING
   virtual ~nsDisplayCaret() {
@@ -971,11 +971,11 @@ public:
   }
   virtual void Paint(nsDisplayListBuilder* aBuilder, nsIRenderingContext* aCtx,
       const nsRect& aDirtyRect);
   NS_DISPLAY_DECL_NAME("Caret")
 protected:
-  nsCOMPtr<nsICaret> mCaret;
+  nsRefPtr<nsCaret> mCaret;
 };
 
 /**
  * The standard display item to paint the CSS borders of a frame.
  */
diff -r 6c8c95fcaf9b layout/base/nsICaret.h
--- a/layout/base/nsICaret.h	Tue Jul 15 15:16:43 2008 +1200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,236 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=2 sw=2 et tw=78: */
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 1998
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either of the GNU General Public License Version 2 or later (the "GPL"),
- * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-/* the caret is the text cursor used, e.g., when editing */
-
-#ifndef nsICaret_h__
-#define nsICaret_h__
-
-#include "nsISupports.h"
-#include "nsCOMPtr.h"
-#include "nsCoord.h"
-#include "nsFrameSelection.h"
-
-struct nsRect;
-struct nsPoint;
-
-class nsIRenderingContext;
-class nsIFrame;
-class nsIView;
-class nsIPresShell;
-class nsISelection;
-class nsIDOMNode;
-
-// IID for the nsICaret interface
-#define NS_ICARET_IID \
-{ 0x48e23b7f, 0x264e, 0xab7d, \
-  { 0x20, 0x03, 0x2c, 0x79, 0x13, 0xe1, 0x09, 0x4d } }
-
-
-class nsICaret: public nsISupports
-{
-public:
-  NS_DECLARE_STATIC_IID_ACCESSOR(NS_ICARET_IID)
-
-  enum EViewCoordinates {
-      eTopLevelWindowCoordinates,
-      eRenderingViewCoordinates,
-      eClosestViewCoordinates,
-      eIMECoordinates
-    };
-
-  NS_IMETHOD Init(nsIPresShell *inPresShell) = 0;
-  NS_IMETHOD Terminate() = 0;
-  
-  NS_IMETHOD GetCaretDOMSelection(nsISelection **aDOMSel) = 0;
-  NS_IMETHOD SetCaretDOMSelection(nsISelection *aDOMSel) = 0;
-
-  /** SetCaretVisible will set the visibility of the caret
-   *  @param inMakeVisible PR_TRUE to show the caret, PR_FALSE to hide it
-   */
-  NS_IMETHOD SetCaretVisible(PRBool inMakeVisible) = 0;
-
-  /** GetCaretVisible will get the visibility of the caret
-   *  @param inMakeVisible PR_TRUE it is shown, PR_FALSE it is hidden
-   */
-  NS_IMETHOD GetCaretVisible(PRBool *outMakeVisible) = 0;
-
-  /** SetCaretReadOnly set the appearance of the caret
-   *  @param inMakeReadonly PR_TRUE to show the caret in a 'read only' state,
-   *  PR_FALSE to show the caret in normal, editing state
-   */
-  NS_IMETHOD SetCaretReadOnly(PRBool inMakeReadonly) = 0;
-
-  virtual PRBool GetCaretReadOnly() = 0;
-
-  /** GetCaretCoordinates
-   *  Get the position of the caret in coordinates relative to the typed
-   *  specified (aRelativeToType).
-   *  If the selection is collapsed, this returns the caret location
-   *    and true in outIsCollapsed.
-   *  If the selection is not collapsed, this returns the location of the focus pos,
-   *    and false in outIsCollapsed.
-   */
-  NS_IMETHOD GetCaretCoordinates(EViewCoordinates aRelativeToType,
-                                 nsISelection *aDOMSel,
-                                 nsRect *outCoordinates,
-                                 PRBool *outIsCollapsed,
-                                 nsIView **outView) = 0;
-
-  /** Erase Caret
-   *  this will erase the caret if its drawn and reset drawn status
-   */
-  NS_IMETHOD EraseCaret() = 0;
-
-  /**
-   * Checks if the caret is drawn when it shouldn't be, and erases it if so.
-   */
-  NS_IMETHOD CheckCaretDrawingState() = 0;
-
-  NS_IMETHOD SetVisibilityDuringSelection(PRBool aVisibilityDuringSelection) = 0;
-  
-  /** DrawAtPosition
-   *  
-   *  Draw the caret explicitly, at the specified node and offset.
-   *  To avoid drawing glitches, you should call EraseCaret()
-   *  after each call to DrawAtPosition().
-   *
-   *  Note: This call breaks the caret's ability to blink at all.
-   **/
-  NS_IMETHOD DrawAtPosition(nsIDOMNode* aNode, PRInt32 aOffset) = 0;
-
-  /** GetCaretFrameForNodeOffset
-   *  Get the frame and content offset at which the caret is drawn,
-   *  invoking the bidi caret positioning algorithm if necessary
-   **/
-  NS_IMETHOD GetCaretFrameForNodeOffset(nsIContent* aContentNode,
-                                        PRInt32 aOffset,
-                                        nsFrameSelection::HINT aFrameHint,
-                                        PRUint8 aBidiLevel,
-                                        nsIFrame** aReturnFrame,
-                                        PRInt32* aReturnOffset) = 0;
-
-  /** GetCaretFrame
-   *  Get the current frame that the caret should be drawn in. If the caret is
-   *  not currently visible (i.e., it is between blinks), then this will
-   *  return null.
-   */
-  virtual nsIFrame *GetCaretFrame() = 0;
-
-  /** GetCaretRect
-   *  Get the current caret rect. Only call this when GetCaretFrame returns
-   *  non-null.
-   */
-  virtual nsRect GetCaretRect() = 0;
-
-  /** GetCaretContent
-   *  Get the content that the caret was last drawn in.
-   */
-  virtual nsIContent* GetCaretContent() = 0;
-
-  /** InvalidateOutsideCaret
-   *  Invalidate the area that the caret currently occupies if the caret is
-   *  outside of its frame's overflow area. This is used when the content that
-   *  the caret is currently drawn is is being deleted or reflowed.
-   */
-  virtual void InvalidateOutsideCaret() = 0;
-
-  /** UpdateCaretPosition
-   *  Update the caret's current frame and rect, but don't draw yet. This is
-   *  useful for flickerless moving of the caret (e.g., when the frame the
-   *  caret is in reflows and is moved).
-   */
-  virtual void UpdateCaretPosition() = 0;
-
-  /** PaintCaret
-   *  Actually paint the caret onto the given rendering context.
-   */
-  virtual void PaintCaret(nsDisplayListBuilder *aBuilder,
-                          nsIRenderingContext *aCtx,
-                          nsIFrame *aForFrame,
-                          const nsPoint &aOffset) = 0;
-
-  /**
-   * Sets whether the caret should only be visible in nodes that are not
-   * user-modify: read-only, or whether it should be visible in all nodes.
-   *
-   * @param aIgnoreUserModify PR_TRUE to have the cursor visible in all nodes,
-   *                          PR_FALSE to have it visible in all nodes except
-   *                          those with user-modify: read-only
-   */
-  virtual void SetIgnoreUserModify(PRBool aIgnoreUserModify) = 0;
-};
-
-NS_DEFINE_STATIC_IID_ACCESSOR(nsICaret, NS_ICARET_IID)
-
-nsresult
-NS_NewCaret(nsICaret** aInstancePtrResult);
-
-
-// handy stack-based class for temporarily disabling the caret
-
-class NS_STACK_CLASS StCaretHider
-{
-public:
-               StCaretHider(nsICaret* aSelCon)
-               : mWasVisible(PR_FALSE), mCaret(aSelCon)
-               {
-                 if (mCaret)
-                 {
-                   mCaret->GetCaretVisible(&mWasVisible);
-                   if (mWasVisible)
-                     mCaret->SetCaretVisible(PR_FALSE);
-                 }
-               }
-               
-               ~StCaretHider()
-               {
-                 if (mCaret && mWasVisible)
-                   mCaret->SetCaretVisible(PR_TRUE);
-                 // nsCOMPtr releases mPresShell
-               }
-
-protected:
-
-    PRBool                  mWasVisible;
-    nsCOMPtr<nsICaret>  mCaret;
-};
-
-
-#endif  // nsICaret_h__
-
diff -r 6c8c95fcaf9b layout/base/nsIPresShell.h
--- a/layout/base/nsIPresShell.h	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/base/nsIPresShell.h	Thu Jul 17 14:13:04 2008 +0300
@@ -78,11 +78,11 @@ class nsIRenderingContext;
 class nsIRenderingContext;
 class nsIPageSequenceFrame;
 class nsString;
 class nsAString;
 class nsStringArray;
-class nsICaret;
+class nsCaret;
 class nsStyleContext;
 class nsFrameSelection;
 class nsFrameManager;
 class nsILayoutHistoryState;
 class nsIReflowCallback;
@@ -510,11 +510,11 @@ public:
   NS_IMETHOD DoGetContents(const nsACString& aMimeType, PRUint32 aFlags, PRBool aSelectionOnly, nsAString& outValue) = 0;
 
   /**
    * Get the caret, if it exists. AddRefs it.
    */
-  NS_IMETHOD GetCaret(nsICaret **aOutCaret) = 0;
+  NS_IMETHOD GetCaret(nsCaret **aOutCaret) = 0;
 
   /**
    * Invalidate the caret's current position if it's outside of its frame's
    * boundaries. This function is useful if you're batching selection
    * notifications and might remove the caret's frame out from under it.
@@ -522,11 +522,11 @@ public:
   NS_IMETHOD_(void) MaybeInvalidateCaretPosition() = 0;
 
   /**
    * Set the current caret to a new caret. To undo this, call RestoreCaret.
    */
-  virtual void SetCaret(nsICaret *aNewCaret) = 0;
+  virtual void SetCaret(nsCaret *aNewCaret) = 0;
 
   /**
    * Restore the caret to the original caret that this pres shell was created
    * with.
    */
diff -r 6c8c95fcaf9b layout/base/nsImageLoader.cpp
--- a/layout/base/nsImageLoader.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/base/nsImageLoader.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -78,14 +78,16 @@ nsImageLoader::~nsImageLoader()
   }
 }
 
 
 void
-nsImageLoader::Init(nsIFrame *aFrame, nsPresContext *aPresContext)
+nsImageLoader::Init(nsIFrame *aFrame, nsPresContext *aPresContext,
+                    PRBool aReflowOnLoad)
 {
   mFrame = aFrame;
   mPresContext = aPresContext;
+  mReflowOnLoad = aReflowOnLoad;
 }
 
 void
 nsImageLoader::Destroy()
 {
@@ -206,10 +208,20 @@ NS_IMETHODIMP nsImageLoader::FrameChange
 
 
 void
 nsImageLoader::RedrawDirtyFrame(const nsRect* aDamageRect)
 {
+  if (mReflowOnLoad) {
+    nsIPresShell *shell = mPresContext->GetPresShell();
+    nsresult rv = shell->FrameNeedsReflow(mFrame, nsIPresShell::eStyleChange, NS_FRAME_IS_DIRTY);
+    NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "Could not reflow after loading border-image");
+    // Note that we're assuming that the resulting reflow will
+    // invalidate the entire frame.  Given that we only set
+    // mReflowOnLoad if the actual border width will change when we do
+    // this reflow, this invalidate should happen.
+    return;
+  }
   // NOTE: It is not sufficient to invalidate only the size of the image:
   //       the image may be tiled! 
   //       The best option is to call into the frame, however lacking this
   //       we have to at least invalidate the frame's bounds, hence
   //       as long as we have a frame we'll use its size.
diff -r 6c8c95fcaf9b layout/base/nsImageLoader.h
--- a/layout/base/nsImageLoader.h	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/base/nsImageLoader.h	Thu Jul 17 14:13:04 2008 +0300
@@ -67,11 +67,12 @@ public:
 
   // imgIContainerObserver (override nsStubImageDecoderObserver)
   NS_IMETHOD FrameChanged(imgIContainer *aContainer, gfxIImageFrame *newframe,
                           nsRect * dirtyRect);
 
-  void Init(nsIFrame *aFrame, nsPresContext *aPresContext);
+  void Init(nsIFrame *aFrame, nsPresContext *aPresContext,
+            PRBool aReflowOnLoad);
   nsresult Load(imgIRequest *aImage);
 
   void Destroy();
 
   nsIFrame *GetFrame() { return mFrame; }
@@ -82,6 +83,7 @@ private:
 
 private:
   nsIFrame *mFrame;
   nsPresContext *mPresContext;
   nsCOMPtr<imgIRequest> mRequest;
+  PRBool mReflowOnLoad;
 };
diff -r 6c8c95fcaf9b layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/base/nsLayoutUtils.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -1491,29 +1491,10 @@ static nscoord AddPercents(nsLayoutUtils
       result = NSToCoordRound(float(result) / (1.0f - aPercent));
   }
   return result;
 }
 
-/* static */ PRBool
-nsLayoutUtils::GetAbsoluteCoord(const nsStyleCoord& aStyle,
-                                nsIRenderingContext* aRenderingContext,
-                                nsStyleContext* aStyleContext,
-                                nscoord& aResult)
-{
-  nsStyleUnit unit = aStyle.GetUnit();
-  if (eStyleUnit_Coord == unit) {
-    aResult = aStyle.GetCoordValue();
-    return PR_TRUE;
-  }
-  if (eStyleUnit_Chars == unit) {
-    aResult = nsLayoutUtils::CharsToCoord(aStyle, aRenderingContext,
-                                          aStyleContext);
-    return PR_TRUE;
-  }
-  return PR_FALSE;
-}
-
 static PRBool
 GetPercentHeight(const nsStyleCoord& aStyle,
                  nsIRenderingContext* aRenderingContext,
                  nsIFrame* aFrame,
                  nscoord& aResult)
@@ -2647,25 +2628,10 @@ nsLayoutUtils::SetFontFromStyle(nsIRende
   const nsStyleVisibility* visibility = aSC->GetStyleVisibility();
 
   aRC->SetFont(font->mFont, visibility->mLangGroup);
 }
 
-nscoord
-nsLayoutUtils::CharsToCoord(const nsStyleCoord& aStyle,
-                            nsIRenderingContext* aRenderingContext,
-                            nsStyleContext* aStyleContext)
-{
-  NS_ASSERTION(aStyle.GetUnit() == eStyleUnit_Chars,
-               "Shouldn't have called this");
-
-  SetFontFromStyle(aRenderingContext, aStyleContext);
-  nscoord fontWidth;
-  aRenderingContext->SetTextRunRTL(PR_FALSE);
-  aRenderingContext->GetWidth('M', fontWidth);
-  return aStyle.GetIntValue() * fontWidth;
-}
-
 static PRBool NonZeroStyleCoord(const nsStyleCoord& aCoord)
 {
   switch (aCoord.GetUnit()) {
   case eStyleUnit_Percent:
     return aCoord.GetPercentValue() > 0;
diff -r 6c8c95fcaf9b layout/base/nsLayoutUtils.h
--- a/layout/base/nsLayoutUtils.h	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/base/nsLayoutUtils.h	Thu Jul 17 14:13:04 2008 +0300
@@ -587,11 +587,11 @@ public:
    * reference to ancestors or children (e.g. is not a percentage width)
    * @param aStyle the style coord
    * @param aRenderingContext the rendering context to use for font measurement
    * @param aFrame the frame whose style context should be used for font information
    * @param aResult the nscoord value of the style coord
-   * @return TRUE if the unit is eStyleUnit_Coord or eStyleUnit_Chars
+   * @return TRUE if the unit is eStyleUnit_Coord
    */
   static PRBool GetAbsoluteCoord(const nsStyleCoord& aStyle,
                                  nsIRenderingContext* aRenderingContext,
                                  nsIFrame* aFrame,
                                  nscoord& aResult)
@@ -604,11 +604,20 @@ public:
    * Same as above but doesn't need a frame
    */
   static PRBool GetAbsoluteCoord(const nsStyleCoord& aStyle,
                                  nsIRenderingContext* aRenderingContext,
                                  nsStyleContext* aStyleContext,
-                                 nscoord& aResult);
+                                 nscoord& aResult)
+  {
+    nsStyleUnit unit = aStyle.GetUnit();
+    if (eStyleUnit_Coord == unit) {
+      aResult = aStyle.GetCoordValue();
+      return PR_TRUE;
+    }
+    return PR_FALSE;
+  }
+
   /**
    * Get the contribution of aFrame to its containing block's intrinsic
    * width.  This considers the child's intrinsic width, its 'width',
    * 'min-width', and 'max-width' properties, and its padding, border,
    * and margin.
@@ -760,21 +769,10 @@ public:
    * Set the font on aRC based on the style in aSC
    */
   static void SetFontFromStyle(nsIRenderingContext* aRC, nsStyleContext* aSC);
 
   /**
-   * Convert an eStyleUnit_Chars nsStyleCoord to an nscoord.
-   *
-   * @param aStyle the style coord
-   * @param aRenderingContext the rendering context to use for font measurement
-   * @param aStyleContext the style context to use for font infomation
-   */
-  static nscoord CharsToCoord(const nsStyleCoord& aStyle,
-                              nsIRenderingContext* aRenderingContext,
-                              nsStyleContext* aStyleContext);
-
-  /**
    * Determine if any style coordinate is nonzero
    *   @param aCoord the style sides
    *   @return PR_TRUE unless all the coordinates are 0%, 0 or null.
    */
   static PRBool HasNonZeroSide(const nsStyleSides& aSides);
diff -r 6c8c95fcaf9b layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/base/nsPresContext.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -797,10 +797,13 @@ nsPresContext::Init(nsIDeviceContext* aD
   if (mDeviceContext->SetPixelScale(mFullZoom))
     mDeviceContext->FlushFontCache();
   mCurAppUnitsPerDevPixel = AppUnitsPerDevPixel();
 
   if (!mImageLoaders.Init())
+    return NS_ERROR_OUT_OF_MEMORY;
+  
+  if (!mBorderImageLoaders.Init())
     return NS_ERROR_OUT_OF_MEMORY;
   
   // Get the look and feel service here; default colors will be initialized
   // from calling GetUserPreferences() when we get a presshell.
   nsresult rv = CallGetService(kLookAndFeelCID, &mLookAndFeel);
@@ -1166,32 +1169,47 @@ nsPresContext::SetFullZoom(float aZoom)
 
   mCurAppUnitsPerDevPixel = AppUnitsPerDevPixel();
 }
 
 imgIRequest*
-nsPresContext::LoadImage(imgIRequest* aImage, nsIFrame* aTargetFrame)
+nsPresContext::DoLoadImage(nsPresContext::ImageLoaderTable& aTable,
+                           imgIRequest* aImage,
+                           nsIFrame* aTargetFrame,
+                           PRBool aReflowOnLoad)
 {
   // look and see if we have a loader for the target frame.
   nsCOMPtr<nsImageLoader> loader;
-  mImageLoaders.Get(aTargetFrame, getter_AddRefs(loader));
+  aTable.Get(aTargetFrame, getter_AddRefs(loader));
 
   if (!loader) {
     loader = new nsImageLoader();
     if (!loader)
       return nsnull;
 
-    loader->Init(aTargetFrame, this);
+    loader->Init(aTargetFrame, this, aReflowOnLoad);
     mImageLoaders.Put(aTargetFrame, loader);
   }
 
   loader->Load(aImage);
 
   imgIRequest *request = loader->GetRequest();
 
   return request;
 }
 
+imgIRequest*
+nsPresContext::LoadImage(imgIRequest* aImage, nsIFrame* aTargetFrame)
+{
+  return DoLoadImage(mImageLoaders, aImage, aTargetFrame, PR_FALSE);
+}
+
+imgIRequest*
+nsPresContext::LoadBorderImage(imgIRequest* aImage, nsIFrame* aTargetFrame)
+{
+  return DoLoadImage(mBorderImageLoaders, aImage, aTargetFrame,
+                     aTargetFrame->GetStyleBorder()->ImageBorderDiffers());
+}
 
 void
 nsPresContext::StopImagesFor(nsIFrame* aTargetFrame)
 {
   nsCOMPtr<nsImageLoader> loader;
@@ -1199,10 +1217,18 @@ nsPresContext::StopImagesFor(nsIFrame* a
 
   if (loader) {
     loader->Destroy();
 
     mImageLoaders.Remove(aTargetFrame);
+  }
+  
+  mBorderImageLoaders.Get(aTargetFrame, getter_AddRefs(loader));
+  
+  if (loader) {
+    loader->Destroy();
+
+    mBorderImageLoaders.Remove(aTargetFrame);
   }
 }
 
 
 void
diff -r 6c8c95fcaf9b layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/base/nsPresContext.h	Thu Jul 17 14:13:04 2008 +0300
@@ -362,18 +362,32 @@ public:
   PRUint8 FocusRingWidth() const { return mFocusRingWidth; }
   PRBool GetFocusRingOnAnything() const { return mFocusRingOnAnything; }
  
 
   /**
-   * Load an image for the target frame. This call can be made
-   * repeated with only a single image ever being loaded. When the
-   * image's data is ready for rendering the target frame's Paint()
-   * method will be invoked (via the ViewManager) so that the
-   * appropriate damage repair is done.
+   * Set up observers so that aTargetFrame will be invalidated when
+   * aImage loads, where aImage is its background image.  Only a single
+   * image will be tracked per frame.
    */
   NS_HIDDEN_(imgIRequest*) LoadImage(imgIRequest* aImage,
                                      nsIFrame* aTargetFrame);
+  /**
+   * Set up observers so that aTargetFrame will be invalidated or
+   * reflowed (as appropriate) when aImage loads, where aImage is its
+   * *border* image.  Only a single image will be tracked per frame.
+   */
+  NS_HIDDEN_(imgIRequest*) LoadBorderImage(imgIRequest* aImage,
+                                           nsIFrame* aTargetFrame);
+
+private:
+  typedef nsInterfaceHashtable<nsVoidPtrHashKey, nsImageLoader> ImageLoaderTable;
+
+  NS_HIDDEN_(imgIRequest*) DoLoadImage(ImageLoaderTable& aTable,
+                                       imgIRequest* aImage,
+                                       nsIFrame* aTargetFrame,
+                                       PRBool aReflowOnLoad);
+public:
 
   /**
    * This method is called when a frame is being destroyed to
    * ensure that the image load gets disassociated from the prescontext
    */
@@ -798,11 +812,12 @@ protected:
                                         // weak pointer to static atom
 
   nsILinkHandler*       mLinkHandler;   // [WEAK]
   nsIAtom*              mLangGroup;     // [STRONG]
 
-  nsInterfaceHashtable<nsVoidPtrHashKey, nsImageLoader> mImageLoaders;
+  ImageLoaderTable      mImageLoaders;
+  ImageLoaderTable      mBorderImageLoaders;
   nsWeakPtr             mContainer;
 
   float                 mTextZoom;      // Text zoom, defaults to 1.0
   float                 mFullZoom;      // Page zoom, defaults to 1.0
 
diff -r 6c8c95fcaf9b layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/base/nsPresShell.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -104,11 +104,11 @@
 #include "nsAutoPtr.h"
 #include "nsReadableUtils.h"
 #include "nsUnicharUtils.h"
 #include "nsWeakReference.h"
 #include "nsIPageSequenceFrame.h"
-#include "nsICaret.h"
+#include "nsCaret.h"
 #include "nsIDOMHTMLDocument.h"
 #include "nsIXPointer.h"
 #include "nsIDOMXMLDocument.h"
 #include "nsIScrollableView.h"
 #include "nsIParser.h"
@@ -915,18 +915,18 @@ public:
   NS_IMETHOD ResizeReflow(nsIView *aView, nscoord aWidth, nscoord aHeight);
   NS_IMETHOD_(PRBool) IsVisible();
   NS_IMETHOD_(void) WillPaint();
 
   // caret handling
-  NS_IMETHOD GetCaret(nsICaret **aOutCaret);
+  NS_IMETHOD GetCaret(nsCaret **aOutCaret);
   NS_IMETHOD_(void) MaybeInvalidateCaretPosition();
   NS_IMETHOD SetCaretEnabled(PRBool aInEnable);
   NS_IMETHOD SetCaretReadOnly(PRBool aReadOnly);
   NS_IMETHOD GetCaretEnabled(PRBool *aOutEnabled);
   NS_IMETHOD SetCaretVisibilityDuringSelection(PRBool aVisibility);
   NS_IMETHOD GetCaretVisible(PRBool *_retval);
-  virtual void SetCaret(nsICaret *aNewCaret);
+  virtual void SetCaret(nsCaret *aNewCaret);
   virtual void RestoreCaret();
 
   NS_IMETHOD SetSelectionFlags(PRInt16 aInEnable);
   NS_IMETHOD GetSelectionFlags(PRInt16 *aOutEnable);
 
@@ -1145,12 +1145,12 @@ protected:
   nsVoidArray mCurrentEventFrameStack;
   nsCOMArray<nsIContent> mCurrentEventContentStack;
 
   nsCOMPtr<nsIContent>          mLastAnchorScrolledTo;
   nscoord                       mLastAnchorScrollPositionY;
-  nsCOMPtr<nsICaret>            mCaret;
-  nsCOMPtr<nsICaret>            mOriginalCaret;
+  nsRefPtr<nsCaret>             mCaret;
+  nsRefPtr<nsCaret>             mOriginalCaret;
   PRInt16                       mSelectionFlags;
   FrameArena                    mFrameArena;
   StackArena                    mStackArena;
   nsCOMPtr<nsIDragService>      mDragService;
   
@@ -2672,11 +2672,11 @@ PresShell::NotifyDestroyingFrame(nsIFram
 
   return NS_OK;
 }
 
 // note that this can return a null caret, but NS_OK
-NS_IMETHODIMP PresShell::GetCaret(nsICaret **outCaret)
+NS_IMETHODIMP PresShell::GetCaret(nsCaret **outCaret)
 {
   NS_ENSURE_ARG_POINTER(outCaret);
   
   *outCaret = mCaret;
   NS_IF_ADDREF(*outCaret);
@@ -2688,11 +2688,11 @@ NS_IMETHODIMP_(void) PresShell::MaybeInv
   if (mCaret) {
     mCaret->InvalidateOutsideCaret();
   }
 }
 
-void PresShell::SetCaret(nsICaret *aNewCaret)
+void PresShell::SetCaret(nsCaret *aNewCaret)
 {
   mCaret = aNewCaret;
 }
 
 void PresShell::RestoreCaret()
@@ -2712,14 +2712,14 @@ NS_IMETHODIMP PresShell::SetCaretEnabled
 /*  Don't change the caret's selection here! This was an evil side-effect of SetCaretEnabled()
     nsCOMPtr<nsIDOMSelection> domSel;
     if (NS_SUCCEEDED(GetSelection(nsISelectionController::SELECTION_NORMAL, getter_AddRefs(domSel))) && domSel)
       mCaret->SetCaretDOMSelection(domSel);
 */
-    result = mCaret->SetCaretVisible(mCaretEnabled);
-  }
-
-  return result;
+    mCaret->SetCaretVisible(mCaretEnabled);
+  }
+
+  return NS_OK;
 }
 
 NS_IMETHODIMP PresShell::SetCaretReadOnly(PRBool aReadOnly)
 {
   if (mCaret)
diff -r 6c8c95fcaf9b layout/base/nsStyleConsts.h
--- a/layout/base/nsStyleConsts.h	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/base/nsStyleConsts.h	Thu Jul 17 14:13:04 2008 +0300
@@ -268,10 +268,15 @@
 #define NS_STYLE_BORDER_STYLE_HIDDEN            9
 #define NS_STYLE_BORDER_STYLE_AUTO              10 // for outline-style only
 // a bit ORed onto the style for table border collapsing indicating that the style was 
 // derived from a table with its rules attribute set
 #define NS_STYLE_BORDER_STYLE_RULES_MARKER      0x10  
+
+// See nsStyleBorder mBorderImage
+#define NS_STYLE_BORDER_IMAGE_STRETCH           0
+#define NS_STYLE_BORDER_IMAGE_REPEAT            1
+#define NS_STYLE_BORDER_IMAGE_ROUND             2
 
 // See nsStyleDisplay
 #define NS_STYLE_CLEAR_NONE                     0
 #define NS_STYLE_CLEAR_LEFT                     1
 #define NS_STYLE_CLEAR_RIGHT                    2
diff -r 6c8c95fcaf9b layout/build/Makefile.in
--- a/layout/build/Makefile.in	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/build/Makefile.in	Thu Jul 17 14:13:04 2008 +0300
@@ -136,10 +136,11 @@ SHARED_LIBRARY_LIBS = \
 	$(DEPTH)/dom/src/events/$(LIB_PREFIX)jsdomevents_s.$(LIB_SUFFIX) \
 	$(DEPTH)/dom/src/json/$(LIB_PREFIX)json_s.$(LIB_SUFFIX) \
 	$(DEPTH)/dom/src/jsurl/$(LIB_PREFIX)jsurl_s.$(LIB_SUFFIX) \
 	$(DEPTH)/dom/src/storage/$(LIB_PREFIX)jsdomstorage_s.$(LIB_SUFFIX) \
 	$(DEPTH)/dom/src/offline/$(LIB_PREFIX)jsdomoffline_s.$(LIB_SUFFIX) \
+ 	$(DEPTH)/dom/src/geolocation/$(LIB_PREFIX)jsdomgeolocation_s.$(LIB_SUFFIX) \
 	$(DEPTH)/editor/libeditor/text/$(LIB_PREFIX)texteditor_s.$(LIB_SUFFIX) \
 	$(DEPTH)/editor/libeditor/base/$(LIB_PREFIX)editorbase_s.$(LIB_SUFFIX) \
 	$(NULL)
 
 ifdef MOZ_MEDIA
@@ -265,10 +266,11 @@ LOCAL_INCLUDES	+= -I$(srcdir)/../base \
 		   -I$(topsrcdir)/dom/src/base \
 		   -I$(topsrcdir)/dom/src/json \
 		   -I$(topsrcdir)/dom/src/jsurl \
 		   -I$(topsrcdir)/dom/src/storage \
 		   -I$(topsrcdir)/dom/src/offline \
+		   -I$(topsrcdir)/dom/src/geolocation \
 		   -I. \
 		   -I$(topsrcdir)/editor/libeditor/base \
 		   -I$(topsrcdir)/editor/libeditor/text \
 		   -I$(topsrcdir)/editor/libeditor/html \
 		   -I$(topsrcdir)/editor/txtsvc/src \
diff -r 6c8c95fcaf9b layout/build/nsLayoutModule.cpp
--- a/layout/build/nsLayoutModule.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/build/nsLayoutModule.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -83,11 +83,11 @@
 #include "nsIPrivateDOMImplementation.h"
 #include "nsIRangeUtils.h"
 #include "nsIScriptNameSpaceManager.h"
 #include "nsISelection.h"
 #include "nsIXBLService.h"
-#include "nsICaret.h"
+#include "nsCaret.h"
 #include "nsPlainTextSerializer.h"
 #include "mozSanitizingSerializer.h"
 #include "nsXMLContentSerializer.h"
 #include "nsRuleNode.h"
 #include "nsWyciwygProtocolHandler.h"
@@ -263,10 +263,12 @@ static void Shutdown();
 
 #ifdef MOZ_XTF
 #include "nsIXTFService.h"
 #include "nsIXMLContentBuilder.h"
 #endif
+
+#include "nsGeolocation.h"
 
 // Transformiix
 /* {0C351177-0159-4500-86B0-A219DFDE4258} */
 #define TRANSFORMIIX_XPATH1_SCHEME_CID \
 { 0xc351177, 0x159, 0x4500, { 0x86, 0xb0, 0xa2, 0x19, 0xdf, 0xde, 0x42, 0x58 } }
@@ -464,11 +466,10 @@ NS_GENERIC_FACTORY_CONSTRUCTOR(inFlasher
 NS_GENERIC_FACTORY_CONSTRUCTOR(inFlasher)
 NS_GENERIC_FACTORY_CONSTRUCTOR(inCSSValueSearch)
 NS_GENERIC_FACTORY_CONSTRUCTOR(inDOMUtils)
 #endif
 
-MAKE_CTOR(CreateCaret,                    nsICaret,                    NS_NewCaret)
 MAKE_CTOR(CreateNameSpaceManager,         nsINameSpaceManager,         NS_GetNameSpaceManager)
 MAKE_CTOR(CreateEventListenerManager,     nsIEventListenerManager,     NS_NewEventListenerManager)
 MAKE_CTOR(CreateDOMEventGroup,            nsIDOMEventGroup,            NS_NewDOMEventGroup)
 MAKE_CTOR(CreateDocumentViewer,           nsIDocumentViewer,           NS_NewDocumentViewer)
 MAKE_CTOR(CreateCSSStyleSheet,            nsICSSStyleSheet,            NS_NewCSSStyleSheet)
@@ -784,10 +785,15 @@ CreateWindowControllerWithSingletonComma
 }
 
 NS_GENERIC_FACTORY_CONSTRUCTOR(nsDOMScriptObjectFactory)
 NS_GENERIC_FACTORY_CONSTRUCTOR(nsBaseDOMException)
 
+#define NS_GEOLOCATION_SERVICE_CID \
+  { 0x404d02a, 0x1CA, 0xAAAB, { 0x47, 0x62, 0x94, 0x4b, 0x1b, 0xf2, 0xf7, 0xb5 } }
+
+NS_GENERIC_FACTORY_SINGLETON_CONSTRUCTOR(nsGeolocatorService, nsGeolocatorService::GetGeolocationService)
+
 // The list of components we register
 static const nsModuleComponentInfo gComponents[] = {
 #ifdef DEBUG
   { "Frame utility",
     NS_FRAME_UTIL_CID,
@@ -801,15 +807,10 @@ static const nsModuleComponentInfo gComp
 
   { "Frame Traversal",
     NS_FRAMETRAVERSAL_CID,
     nsnull,
     CreateNewFrameTraversal },
-
-  { "caret",
-    NS_CARET_CID,
-    "@mozilla.org/layout/caret;1",
-    CreateCaret },
 
   // XXX ick
   { "Presentation shell",
     NS_PRESSHELL_CID,
     nsnull,
@@ -1371,8 +1372,15 @@ static const nsModuleComponentInfo gComp
     { NULL,
       NS_TEXTSERVICESDOCUMENT_CID,
       "@mozilla.org/textservices/textservicesdocument;1",
       nsTextServicesDocumentConstructor },
 #endif
+
+    { "Geolocation Service",
+      NS_GEOLOCATION_SERVICE_CID,
+      "@mozilla.org/geolocation/service;1",
+      nsGeolocatorServiceConstructor },
+
+
 };
 
 NS_IMPL_NSGETMODULE_WITH_CTOR(nsLayoutModule, gComponents, Initialize)
diff -r 6c8c95fcaf9b layout/forms/nsButtonFrameRenderer.cpp
--- a/layout/forms/nsButtonFrameRenderer.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/forms/nsButtonFrameRenderer.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -261,11 +261,11 @@ nsButtonFrameRenderer::GetButtonOuterFoc
 
   if (mOuterFocusStyle) {
     if (!mOuterFocusStyle->GetStylePadding()->GetPadding(result)) {
       NS_NOTYETIMPLEMENTED("percentage padding");
     }
-    result += mOuterFocusStyle->GetStyleBorder()->GetBorder();
+    result += mOuterFocusStyle->GetStyleBorder()->GetActualBorder();
   }
 
   return result;
 }
 
@@ -300,11 +300,11 @@ nsButtonFrameRenderer::GetButtonInnerFoc
 
   if (mInnerFocusStyle) {
     if (!mInnerFocusStyle->GetStylePadding()->GetPadding(result)) {
       NS_NOTYETIMPLEMENTED("percentage padding");
     }
-    result += mInnerFocusStyle->GetStyleBorder()->GetBorder();
+    result += mInnerFocusStyle->GetStyleBorder()->GetActualBorder();
   }
 
   return result;
 }
 
diff -r 6c8c95fcaf9b layout/forms/nsFieldSetFrame.cpp
--- a/layout/forms/nsFieldSetFrame.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/forms/nsFieldSetFrame.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -260,11 +260,11 @@ nsFieldSetFrame::PaintBorderBackground(n
 {
   PRIntn skipSides = GetSkipSides();
   const nsStyleBorder* borderStyle = GetStyleBorder();
   const nsStylePadding* paddingStyle = GetStylePadding();
        
-  nscoord topBorder = borderStyle->GetBorderWidth(NS_SIDE_TOP);
+  nscoord topBorder = borderStyle->GetActualBorderWidth(NS_SIDE_TOP);
   nscoord yoff = 0;
   nsPresContext* presContext = PresContext();
      
   // if the border is smaller than the legend. Move the border down
   // to be centered on the legend. 
diff -r 6c8c95fcaf9b layout/forms/nsHTMLButtonControlFrame.cpp
--- a/layout/forms/nsHTMLButtonControlFrame.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/forms/nsHTMLButtonControlFrame.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -224,11 +224,11 @@ nsHTMLButtonControlFrame::BuildDisplayLi
     // XXX This is temporary
   // clips to its size minus the border 
   // but the real problem is the FirstChild (the AreaFrame)
   // isn't being constrained properly
   // Bug #17474
-  nsMargin border = GetStyleBorder()->GetBorder();
+  nsMargin border = GetStyleBorder()->GetActualBorder();
   nsRect rect(aBuilder->ToReferenceFrame(this), GetSize());
   rect.Deflate(border);
   
   nsresult rv = OverflowClip(aBuilder, set, aLists, rect);
   NS_ENSURE_SUCCESS(rv, rv);
diff -r 6c8c95fcaf9b layout/forms/nsTextControlFrame.cpp
--- a/layout/forms/nsTextControlFrame.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/forms/nsTextControlFrame.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -47,11 +47,11 @@
 #include "nsFrameSelection.h"
 #include "nsIPlaintextEditor.h"
 #include "nsEditorCID.h"
 #include "nsLayoutCID.h"
 #include "nsIDocumentEncoder.h"
-#include "nsICaret.h"
+#include "nsCaret.h"
 #include "nsISelectionListener.h"
 #include "nsISelectionPrivate.h"
 #include "nsIController.h"
 #include "nsIControllers.h"
 #include "nsIControllerContext.h"
@@ -738,17 +738,18 @@ nsTextInputSelectionImpl::SetCaretReadOn
   if (!mPresShellWeak) return NS_ERROR_NOT_INITIALIZED;
   nsresult result;
   nsCOMPtr<nsIPresShell> shell = do_QueryReferent(mPresShellWeak, &result);
   if (shell)
   {
-    nsCOMPtr<nsICaret> caret;
+    nsRefPtr<nsCaret> caret;
     if (NS_SUCCEEDED(shell->GetCaret(getter_AddRefs(caret))))
     {
       nsISelection* domSel = mFrameSelection->
         GetSelection(nsISelectionController::SELECTION_NORMAL);
       if (domSel)
-        return caret->SetCaretReadOnly(aReadOnly);
+        caret->SetCaretReadOnly(aReadOnly);
+      return NS_OK;
     }
   }
   return NS_ERROR_FAILURE;
 }
 
@@ -764,11 +765,11 @@ nsTextInputSelectionImpl::GetCaretVisibl
   if (!mPresShellWeak) return NS_ERROR_NOT_INITIALIZED;
   nsresult result;
   nsCOMPtr<nsIPresShell> shell = do_QueryReferent(mPresShellWeak, &result);
   if (shell)
   {
-    nsCOMPtr<nsICaret> caret;
+    nsRefPtr<nsCaret> caret;
     if (NS_SUCCEEDED(shell->GetCaret(getter_AddRefs(caret))))
     {
       nsISelection* domSel = mFrameSelection->
         GetSelection(nsISelectionController::SELECTION_NORMAL);
       if (domSel)
@@ -784,17 +785,18 @@ nsTextInputSelectionImpl::SetCaretVisibi
   if (!mPresShellWeak) return NS_ERROR_NOT_INITIALIZED;
   nsresult result;
   nsCOMPtr<nsIPresShell> shell = do_QueryReferent(mPresShellWeak, &result);
   if (shell)
   {
-    nsCOMPtr<nsICaret> caret;
+    nsRefPtr<nsCaret> caret;
     if (NS_SUCCEEDED(shell->GetCaret(getter_AddRefs(caret))))
     {
       nsISelection* domSel = mFrameSelection->
         GetSelection(nsISelectionController::SELECTION_NORMAL);
       if (domSel)
-        return caret->SetVisibilityDuringSelection(aVisibility);
+        caret->SetVisibilityDuringSelection(aVisibility);
+      return NS_OK;
     }
   }
   return NS_ERROR_FAILURE;
 }
 
@@ -1538,16 +1540,16 @@ nsTextControlFrame::CreateFrameFor(nsICo
     }
   }
     
   // Get the caret and make it a selection listener.
 
-  nsCOMPtr<nsISelection> domSelection;
+  nsRefPtr<nsISelection> domSelection;
   if (NS_SUCCEEDED(mSelCon->GetSelection(nsISelectionController::SELECTION_NORMAL,
                                          getter_AddRefs(domSelection))) &&
       domSelection) {
     nsCOMPtr<nsISelectionPrivate> selPriv(do_QueryInterface(domSelection));
-    nsCOMPtr<nsICaret> caret;
+    nsRefPtr<nsCaret> caret;
     nsCOMPtr<nsISelectionListener> listener;
     if (NS_SUCCEEDED(shell->GetCaret(getter_AddRefs(caret))) && caret) {
       listener = do_QueryInterface(caret);
       if (listener) {
         selPriv->AddSelectionListener(listener);
@@ -1897,11 +1899,11 @@ void nsTextControlFrame::SetFocus(PRBool
   mSelCon->GetSelection(nsISelectionController::SELECTION_NORMAL, 
     getter_AddRefs(ourSel));
   if (!ourSel) return;
 
   nsIPresShell* presShell = PresContext()->GetPresShell();
-  nsCOMPtr<nsICaret> caret;
+  nsRefPtr<nsCaret> caret;
   presShell->GetCaret(getter_AddRefs(caret));
   if (!caret) return;
   caret->SetCaretDOMSelection(ourSel);
 
   // mutual-exclusion: the selection is either controlled by the
diff -r 6c8c95fcaf9b layout/generic/nsAbsoluteContainingBlock.cpp
--- a/layout/generic/nsAbsoluteContainingBlock.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/generic/nsAbsoluteContainingBlock.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -208,30 +208,28 @@ nsAbsoluteContainingBlock::Reflow(nsCont
   NS_MergeReflowStatusInto(&aReflowStatus, reflowStatus);
   return NS_OK;
 }
 
 static inline PRBool IsFixedPaddingSize(nsStyleUnit aUnit) {
-  return aUnit == eStyleUnit_Coord || aUnit == eStyleUnit_Chars;
+  return aUnit == eStyleUnit_Coord;
 }
 static inline PRBool IsFixedMarginSize(nsStyleUnit aUnit) {
-  return aUnit == eStyleUnit_Coord || aUnit == eStyleUnit_Chars;
+  return aUnit == eStyleUnit_Coord;
 }
 static inline PRBool IsFixedMaxSize(nsStyleUnit aUnit) {
-  return aUnit == eStyleUnit_None || aUnit == eStyleUnit_Coord ||
-         aUnit == eStyleUnit_Chars;
+  return aUnit == eStyleUnit_None || aUnit == eStyleUnit_Coord;
 }
 static inline PRBool IsFixedOffset(nsStyleUnit aUnit) {
-  return aUnit == eStyleUnit_Coord || aUnit == eStyleUnit_Chars;
+  return aUnit == eStyleUnit_Coord;
 }
 static inline PRBool IsFixedHeight(nsStyleUnit aUnit) {
-  return aUnit == eStyleUnit_Coord || aUnit == eStyleUnit_Chars;
+  return aUnit == eStyleUnit_Coord;
 }
 
 static inline PRBool IsFixedWidth(const nsStyleCoord& aCoord)
 {
   return aCoord.GetUnit() == eStyleUnit_Coord ||
-         aCoord.GetUnit() == eStyleUnit_Chars ||
          (aCoord.GetUnit() == eStyleUnit_Enumerated &&
           (aCoord.GetIntValue() == NS_STYLE_WIDTH_MAX_CONTENT ||
            aCoord.GetIntValue() == NS_STYLE_WIDTH_MIN_CONTENT));
 }
 
@@ -395,11 +393,11 @@ nsAbsoluteContainingBlock::ReflowAbsolut
                          aKidFrame->GetPosition());
   nsRect oldRect = aKidFrame->GetRect();
 
   nsresult  rv;
   // Get the border values
-  const nsMargin& border = aReflowState.mStyleBorder->GetBorder();
+  const nsMargin& border = aReflowState.mStyleBorder->GetActualBorder();
 
   nscoord availWidth = aContainingBlockWidth;
   if (availWidth == -1) {
     NS_ASSERTION(aReflowState.ComputedWidth() != NS_UNCONSTRAINEDSIZE,
                  "Must have a useful width _somewhere_");
diff -r 6c8c95fcaf9b layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/generic/nsBlockFrame.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -794,11 +794,11 @@ CalculateContainingBlockSizeForAbsolutes
   // size as the dimensions.
   nsIFrame* frame = aReflowState.frame;
 
   nsSize cbSize(aFrameSize);
     // Containing block is relative to the padding edge
-  const nsMargin& border = aReflowState.mStyleBorder->GetBorder();
+  const nsMargin& border = aReflowState.mStyleBorder->GetActualBorder();
   cbSize.width -= border.left + border.right;
   cbSize.height -= border.top + border.bottom;
 
   if (frame->GetParent()->GetContent() == frame->GetContent()) {
     // We are a wrapped frame for the content. Use the container's
@@ -2648,12 +2648,12 @@ nsBlockFrame::IsSelfEmpty()
       return PR_FALSE;
   }
 
   const nsStyleBorder* border = GetStyleBorder();
   const nsStylePadding* padding = GetStylePadding();
-  if (border->GetBorderWidth(NS_SIDE_TOP) != 0 ||
-      border->GetBorderWidth(NS_SIDE_BOTTOM) != 0 ||
+  if (border->GetActualBorderWidth(NS_SIDE_TOP) != 0 ||
+      border->GetActualBorderWidth(NS_SIDE_BOTTOM) != 0 ||
       !IsPaddingZero(padding->mPadding.GetTopUnit(),
                      padding->mPadding.GetTop()) ||
       !IsPaddingZero(padding->mPadding.GetBottomUnit(),
                      padding->mPadding.GetBottom())) {
     return PR_FALSE;
diff -r 6c8c95fcaf9b layout/generic/nsContainerFrame.cpp
--- a/layout/generic/nsContainerFrame.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/generic/nsContainerFrame.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -664,11 +664,11 @@ nsContainerFrame::DoInlineIntrinsicWidth
   // continuation, in which case that continuation should handle the startSide 
   // border.
   if (!GetPrevContinuation()) {
     aData->currentLine +=
       GetCoord(stylePadding->mPadding.Get(startSide), 0) +
-      styleBorder->GetBorderWidth(startSide) +
+      styleBorder->GetActualBorderWidth(startSide) +
       GetCoord(styleMargin->mMargin.Get(startSide), 0);
   }
 
   const nsLineList_iterator* savedLine = aData->line;
 
@@ -701,11 +701,11 @@ nsContainerFrame::DoInlineIntrinsicWidth
   // continuation, in which case that continuation should handle 
   // the endSide border.
   if (!lastInFlow->GetNextContinuation()) {
     aData->currentLine +=
       GetCoord(stylePadding->mPadding.Get(endSide), 0) +
-      styleBorder->GetBorderWidth(endSide) +
+      styleBorder->GetActualBorderWidth(endSide) +
       GetCoord(styleMargin->mMargin.Get(endSide), 0);
   }
 }
 
 /* virtual */ nsSize
diff -r 6c8c95fcaf9b layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/generic/nsFrame.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -154,11 +154,10 @@ struct nsContentAndOffset
 #define SELECTION_DEBUG        0
 #define FORCE_SELECTION_UPDATE 1
 #define CALC_DEBUG             0
 
 
-#include "nsICaret.h"
 #include "nsILineIterator.h"
 
 //non Hack prototypes
 #if 0
 static void RefreshContentFrames(nsPresContext* aPresContext, nsIContent * aStartContent, nsIContent * aEndContent);
@@ -585,11 +584,11 @@ nsIFrame::GetUsedBorder() const
     result.bottom = presContext->DevPixelsToAppUnits(result.bottom);
     result.left = presContext->DevPixelsToAppUnits(result.left);
     return result;
   }
 
-  return GetStyleBorder()->GetBorder();
+  return GetStyleBorder()->GetActualBorder();
 }
 
 /* virtual */ nsMargin
 nsIFrame::GetUsedPadding() const
 {
@@ -2965,15 +2964,10 @@ AddCoord(const nsStyleCoord& aStyle,
       *aCoord += aStyle.GetCoordValue();
       break;
     case eStyleUnit_Percent:
       *aPercent += aStyle.GetPercentValue();
       break;
-    case eStyleUnit_Chars: {
-      *aCoord += nsLayoutUtils::CharsToCoord(aStyle, aRenderingContext,
-                                             aFrame->GetStyleContext());
-      break;
-    }
     default:
       break;
   }
 }
 
@@ -2993,12 +2987,12 @@ nsFrame::IntrinsicWidthOffsets(nsIRender
            &result.hPadding, &result.hPctPadding);
   AddCoord(stylePadding->mPadding.GetRight(), aRenderingContext, this,
            &result.hPadding, &result.hPctPadding);
 
   const nsStyleBorder *styleBorder = GetStyleBorder();
-  result.hBorder += styleBorder->GetBorderWidth(NS_SIDE_LEFT);
-  result.hBorder += styleBorder->GetBorderWidth(NS_SIDE_RIGHT);
+  result.hBorder += styleBorder->GetActualBorderWidth(NS_SIDE_LEFT);
+  result.hBorder += styleBorder->GetActualBorderWidth(NS_SIDE_RIGHT);
 
   const nsStyleDisplay *disp = GetStyleDisplay();
   if (IsThemed(disp)) {
     nsPresContext *presContext = PresContext();
 
@@ -3785,11 +3779,11 @@ nsFrame::CheckInvalidateSizeChange(nsPre
 
   // Invalidate the old frame borders if the frame has borders. Those borders
   // may be moving.
   const nsStyleBorder* border = GetStyleBorder();
   NS_FOR_CSS_SIDES(side) {
-    if (border->GetBorderWidth(side) != 0) {
+    if (border->GetActualBorderWidth(side) != 0) {
       Invalidate(nsRect(0, 0, mRect.width, mRect.height));
       return;
     }
   }
 
diff -r 6c8c95fcaf9b layout/generic/nsHTMLReflowState.cpp
--- a/layout/generic/nsHTMLReflowState.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/generic/nsHTMLReflowState.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -55,10 +55,11 @@
 #include "nsTableCellFrame.h"
 #include "nsIServiceManager.h"
 #include "nsIPercentHeightObserver.h"
 #include "nsContentUtils.h"
 #include "nsLayoutUtils.h"
+#include "nsStyleStructInlines.h"
 #ifdef IBMBIDI
 #include "nsBidiUtils.h"
 #endif
 
 #ifdef NS_DEBUG
@@ -305,10 +306,21 @@ nsHTMLReflowState::Init(nsPresContext* a
   InitCBReflowState();
 
   InitConstraints(aPresContext, aContainingBlockWidth, aContainingBlockHeight, aBorder, aPadding);
 
   InitResizeFlags(aPresContext);
+
+  // We have to start loading the border image now, because the
+  // border-image's width overrides only apply once the image is loaded.
+  // Starting the load of the image means we'll get a reflow when the
+  // image loads.  (If we didn't do it now, and the image loaded between
+  // reflow and paint, we'd never get the notification, and our size
+  // would be wrong.)
+  imgIRequest *borderImage = mStyleBorder->GetBorderImage();
+  if (borderImage) {
+    aPresContext->LoadBorderImage(borderImage, frame);
+  }
 
   NS_ASSERTION((mFrameType == NS_CSS_FRAME_TYPE_INLINE &&
                 !frame->IsFrameOfType(nsIFrame::eReplaced)) ||
                frame->GetType() == nsGkAtoms::textFrame ||
                mComputedWidth != NS_UNCONSTRAINEDSIZE,
@@ -797,11 +809,11 @@ nsHTMLReflowState::CalculateHorizBorderP
 nsHTMLReflowState::CalculateHorizBorderPaddingMargin(
                        nscoord aContainingBlockWidth,
                        nscoord* aInsideBoxSizing,
                        nscoord* aOutsideBoxSizing)
 {
-  const nsMargin& border = mStyleBorder->GetBorder();
+  const nsMargin& border = mStyleBorder->GetActualBorder();
   nsMargin padding, margin;
 
   // See if the style system can provide us the padding directly
   if (!mStylePadding->GetPadding(padding)) {
     // We have to compute the left and right values
@@ -1889,11 +1901,11 @@ nsCSSOffsetState::InitOffsets(nscoord aC
   }
   else if (aBorder) {  // border is an input arg
     mComputedBorderPadding = *aBorder;
   }
   else {
-    mComputedBorderPadding = frame->GetStyleBorder()->GetBorder();
+    mComputedBorderPadding = frame->GetStyleBorder()->GetActualBorder();
   }
   mComputedBorderPadding += mComputedPadding;
 
   if (frame->GetType() == nsGkAtoms::tableFrame) {
     nsTableFrame *tableFrame = static_cast<nsTableFrame*>(frame);
diff -r 6c8c95fcaf9b layout/generic/nsInlineFrame.cpp
--- a/layout/generic/nsInlineFrame.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/generic/nsInlineFrame.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -131,12 +131,12 @@ nsInlineFrame::IsSelfEmpty()
   const nsStyleBorder* border = GetStyleBorder();
   const nsStylePadding* padding = GetStylePadding();
   // XXX Top and bottom removed, since they shouldn't affect things, but this
   // doesn't really match with nsLineLayout.cpp's setting of
   // ZeroEffectiveSpanBox, anymore, so what should this really be?
-  if (border->GetBorderWidth(NS_SIDE_RIGHT) != 0 ||
-      border->GetBorderWidth(NS_SIDE_LEFT) != 0 ||
+  if (border->GetActualBorderWidth(NS_SIDE_RIGHT) != 0 ||
+      border->GetActualBorderWidth(NS_SIDE_LEFT) != 0 ||
       !IsPaddingZero(padding->mPadding.GetRightUnit(),
                      padding->mPadding.GetRight()) ||
       !IsPaddingZero(padding->mPadding.GetLeftUnit(),
                      padding->mPadding.GetLeft()) ||
       !IsMarginZero(margin->mMargin.GetRightUnit(),
diff -r 6c8c95fcaf9b layout/generic/nsPageContentFrame.cpp
--- a/layout/generic/nsPageContentFrame.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/generic/nsPageContentFrame.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -204,11 +204,11 @@ nsPageContentFrame::Reflow(nsPresContext
       // The background covers the content area and padding area, so check
       // for children sticking outside the child frame's padding edge
       if (aDesiredSize.mOverflowArea.XMost() > aDesiredSize.width) {
         mPD->mPageContentXMost =
           aDesiredSize.mOverflowArea.XMost() +
-          kidReflowState.mStyleBorder->GetBorderWidth(NS_SIDE_RIGHT) +
+          kidReflowState.mStyleBorder->GetActualBorderWidth(NS_SIDE_RIGHT) +
           padding.right;
       }
     }
 
     // Place and size the child
diff -r 6c8c95fcaf9b layout/generic/nsSelection.cpp
--- a/layout/generic/nsSelection.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/generic/nsSelection.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -87,11 +87,11 @@ static NS_DEFINE_CID(kFrameTraversalCID,
 #include "nsThreadUtils.h"
 
 //included for desired x position;
 #include "nsPresContext.h"
 #include "nsIPresShell.h"
-#include "nsICaret.h"
+#include "nsCaret.h"
 
 
 // included for view scrolling
 #include "nsIViewManager.h"
 #include "nsIScrollableView.h"
@@ -891,11 +891,11 @@ nsFrameSelection::FetchDesiredX(nscoord 
   {
     aDesiredX = mDesiredX;
     return NS_OK;
   }
 
-  nsCOMPtr<nsICaret> caret;
+  nsRefPtr<nsCaret> caret;
   nsresult result = mShell->GetCaret(getter_AddRefs(caret));
   if (NS_FAILED(result))
     return result;
   if (!caret)
     return NS_ERROR_NULL_POINTER;
@@ -905,11 +905,11 @@ nsFrameSelection::FetchDesiredX(nscoord 
   PRInt8 index = GetIndexFromSelectionType(nsISelectionController::SELECTION_NORMAL);
   result = caret->SetCaretDOMSelection(mDomSelections[index]);
   if (NS_FAILED(result))
     return result;
 
-  result = caret->GetCaretCoordinates(nsICaret::eClosestViewCoordinates, mDomSelections[index], &coord, &collapsed, nsnull);
+  result = caret->GetCaretCoordinates(nsCaret::eClosestViewCoordinates, mDomSelections[index], &coord, &collapsed, nsnull);
   if (NS_FAILED(result))
     return result;
    
   aDesiredX = coord.x;
   return NS_OK;
@@ -2717,20 +2717,20 @@ nsFrameSelection::CommonPageMove(PRBool 
   nsISelection* domSel = GetSelection(nsISelectionController::SELECTION_NORMAL);
   
   if (!domSel) 
     return;
   
-  nsCOMPtr<nsICaret> caret;
+  nsRefPtr<nsCaret> caret;
   nsRect caretPos;
   PRBool isCollapsed;
   result = mShell->GetCaret(getter_AddRefs(caret));
   
   if (NS_FAILED(result)) 
     return;
   
   nsIView *caretView;
-  result = caret->GetCaretCoordinates(nsICaret::eClosestViewCoordinates, domSel, &caretPos, &isCollapsed, &caretView);
+  result = caret->GetCaretCoordinates(nsCaret::eClosestViewCoordinates, domSel, &caretPos, &isCollapsed, &caretView);
   
   if (NS_FAILED(result)) 
     return;
   
   //need to adjust caret jump by percentage scroll
@@ -4999,11 +4999,11 @@ nsTypedSelection::GetPrimaryFrameForFocu
     aOffsetUsed = &frameOffset;
     
   nsFrameSelection::HINT hint = mFrameSelection->GetHint();
 
   if (aVisual) {
-    nsCOMPtr<nsICaret> caret;
+    nsRefPtr<nsCaret> caret;
     nsresult result = presShell->GetCaret(getter_AddRefs(caret));
     if (NS_FAILED(result) || !caret)
       return NS_ERROR_FAILURE;
     
     PRUint8 caretBidiLevel = mFrameSelection->GetCaretBidiLevel();
@@ -7363,11 +7363,11 @@ nsTypedSelection::ScrollIntoView(Selecti
   //
   nsCOMPtr<nsIPresShell> presShell;
   result = GetPresShell(getter_AddRefs(presShell));
   if (NS_FAILED(result) || !presShell)
     return result;
-  nsCOMPtr<nsICaret> caret;
+  nsRefPtr<nsCaret> caret;
   presShell->GetCaret(getter_AddRefs(caret));
   if (caret)
   {
     // Now that text frame character offsets are always valid (though not
     // necessarily correct), the worst that will happen if we don't flush here
diff -r 6c8c95fcaf9b layout/generic/nsTextFrameThebes.cpp
--- a/layout/generic/nsTextFrameThebes.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/generic/nsTextFrameThebes.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -68,11 +68,10 @@
 #include "nsITimer.h"
 #include "nsVoidArray.h"
 #include "nsIDOMText.h"
 #include "nsIDocument.h"
 #include "nsIDeviceContext.h"
-#include "nsICaret.h"
 #include "nsCSSPseudoElements.h"
 #include "nsCompatibility.h"
 #include "nsCSSColorUtils.h"
 #include "nsLayoutUtils.h"
 #include "nsDisplayList.h"
@@ -4306,15 +4305,18 @@ nsTextFrame::DrawText(gfxContext* aCtx, 
   // Paint the text and soft-hyphen (if any) onto the given graphics context
   mTextRun->Draw(aCtx, aTextBaselinePt, aOffset, aLength,
                  aDirtyRect, aProvider, &aAdvanceWidth);
 
   if (aDrawSoftHyphen) {
-    gfxFloat hyphenBaselineX = aTextBaselinePt.x + mTextRun->GetDirection() * aAdvanceWidth;
     // Don't use ctx as the context, because we need a reference context here,
     // ctx may be transformed.
     gfxTextRunCache::AutoTextRun hyphenTextRun(GetHyphenTextRun(mTextRun, nsnull, this));
     if (hyphenTextRun.get()) {
+      // For right-to-left text runs, the soft-hyphen is positioned at the left
+      // of the text, minus its own width
+      gfxFloat hyphenBaselineX = aTextBaselinePt.x + mTextRun->GetDirection() * aAdvanceWidth -
+        (mTextRun->IsRightToLeft() ? hyphenTextRun->GetAdvanceWidth(0, hyphenTextRun->GetLength(), nsnull) : 0);
       hyphenTextRun->Draw(aCtx, gfxPoint(hyphenBaselineX, aTextBaselinePt.y),
                           0, hyphenTextRun->GetLength(), aDirtyRect, nsnull, nsnull);
     }
   }
 }
diff -r 6c8c95fcaf9b layout/mathml/base/src/nsMathMLmtableFrame.cpp
--- a/layout/mathml/base/src/nsMathMLmtableFrame.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/mathml/base/src/nsMathMLmtableFrame.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -49,10 +49,11 @@
 #include "nsVoidArray.h"
 #include "nsCSSFrameConstructor.h"
 #include "nsTableOuterFrame.h"
 #include "nsTableFrame.h"
 #include "nsTableCellFrame.h"
+#include "celldata.h"
 
 #include "nsMathMLmtableFrame.h"
 
 //
 // <mtable> -- table or matrix - implementation
@@ -773,10 +774,11 @@ nsMathMLmtdFrame::GetRowSpan()
     if (!value.IsEmpty()) {
       PRInt32 error;
       rowspan = value.ToInteger(&error);
       if (error || rowspan < 0)
         rowspan = 1;
+      rowspan = PR_MIN(rowspan, MAX_ROWSPAN);
     }
   }
   return rowspan;
 }
 
@@ -790,11 +792,11 @@ nsMathMLmtdFrame::GetColSpan()
     nsAutoString value;
     mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::columnspan_, value);
     if (!value.IsEmpty()) {
       PRInt32 error;
       colspan = value.ToInteger(&error);
-      if (error || colspan < 0)
+      if (error || colspan < 0 || colspan > MAX_COLSPAN)
         colspan = 1;
     }
   }
   return colspan;
 }
diff -r 6c8c95fcaf9b layout/reftests/border-image/10x5multicolor.png
Binary file layout/reftests/border-image/10x5multicolor.png has changed
diff -r 6c8c95fcaf9b layout/reftests/border-image/3x3green-1DD813.png
Binary file layout/reftests/border-image/3x3green-1DD813.png has changed
diff -r 6c8c95fcaf9b layout/reftests/border-image/3x3multicolor.png
Binary file layout/reftests/border-image/3x3multicolor.png has changed
diff -r 6c8c95fcaf9b layout/reftests/border-image/3x3transparent.png
Binary file layout/reftests/border-image/3x3transparent.png has changed
diff -r 6c8c95fcaf9b layout/reftests/border-image/4x4multicolor.png
Binary file layout/reftests/border-image/4x4multicolor.png has changed
diff -r 6c8c95fcaf9b layout/reftests/border-image/multicolor-image-1-ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/border-image/multicolor-image-1-ref.html	Thu Jul 17 14:13:04 2008 +0300
@@ -0,0 +1,37 @@
+<!DOCTYPE html>
+<html lang="en-US">
+<head>
+  <title>test of -moz-border-image</title>
+  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
+  <meta http-equiv="Content-Style-Type" content="text/css">
+  <style type="text/css">
+
+  table { margin: 0; padding: 0; border-spacing: 0; empty-cells: show; }
+  td { padding: 0; }
+
+  </style>
+</head>
+<body>
+<table>
+  <col style="width: 7px">
+  <col style="width: 100px">
+  <col style="width: 7px">
+
+  <tr style="height: 7px">
+    <td style="background: #87f0b4"></td>
+    <td style="background: #4a298e"></td>
+    <td style="background: #c98bb7"></td>
+  </tr>
+  <tr style="height: 5px">
+    <td style="background: #90a213"></td>
+    <td style="background: #c9aa7d"></td>
+    <td style="background: #90c157"></td>
+  </tr>
+  <tr style="height: 7px">
+    <td style="background: #9d57c1"></td>
+    <td style="background: #3a8e20"></td>
+    <td style="background: #0e6f6c"></td>
+  </tr>
+</table>
+</body>
+</html>
diff -r 6c8c95fcaf9b layout/reftests/border-image/multicolor-image-1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/border-image/multicolor-image-1.html	Thu Jul 17 14:13:04 2008 +0300
@@ -0,0 +1,22 @@
+<!DOCTYPE html>
+<html lang="en-US">
+<head>
+  <title>test of -moz-border-image</title>
+  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
+  <meta http-equiv="Content-Style-Type" content="text/css">
+  <style type="text/css">
+
+  div {
+    background: red; /* fail if this shows through */
+    background-image: url('3x3multicolor.png'); /* fail if this shows through */
+    -moz-border-image: url('3x3multicolor.png') 1 1 1 1 / 7px;
+    -khtml-border-image: url('3x3multicolor.png') 1 1 1 1 / 7px;
+    border-image: url('3x3multicolor.png') 1 1 1 1 / 7px;
+  }
+
+  </style>
+</head>
+<body>
+<div style="width: 100px; height: 5px"></div>
+</body>
+</html>
diff -r 6c8c95fcaf9b layout/reftests/border-image/multicolor-image-2-ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/border-image/multicolor-image-2-ref.html	Thu Jul 17 14:13:04 2008 +0300
@@ -0,0 +1,165 @@
+<!DOCTYPE html>
+<html lang="en-US">
+<head>
+  <title>test of -moz-border-image</title>
+  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
+  <meta http-equiv="Content-Style-Type" content="text/css">
+  <style type="text/css">
+
+  table { margin: 0; padding: 0; border-spacing: 0; empty-cells: show; }
+  td { padding: 0; }
+  table { margin-bottom: 2px; }
+
+  </style>
+</head>
+<body>
+
+<table>
+  <col style="width: 11px">
+  <col style="width: 9px">
+  <col style="width: 6px">
+  <tr style="height: 4px">
+    <td style="background: #93bd5d"></td>
+    <td style="background: #b55dbd"></td>
+    <td style="background: #8d4921"></td>
+  </tr>
+  <tr style="height: 1px">
+    <td style="background: #21a02c"></td>
+    <td style="background: #4a298e"></td>
+    <td style="background: #ef9b23"></td>
+  </tr>
+  <tr style="height: 8px">
+    <td style="background: #9b733a"></td>
+    <td style="background: #f155ad"></td>
+    <td style="background: #adf3eb"></td>
+  </tr>
+</table>
+
+<table>
+  <col style="width: 4px">
+  <col style="width: 2px">
+  <col style="width: 1px">
+  <tr style="height: 3px">
+    <td style="background: #93bd5d"></td>
+    <td style="background: #b55dbd"></td>
+    <td style="background: #8d4921"></td>
+  </tr>
+  <tr style="height: 17px">
+    <td style="background: #21a02c"></td>
+    <td style="background: #4a298e"></td>
+    <td style="background: #ef9b23"></td>
+  </tr>
+  <tr style="height: 0px">
+    <td style="background: #9b733a"></td>
+    <td style="background: #f155ad"></td>
+    <td style="background: #adf3eb"></td>
+  </tr>
+</table>
+
+<table>
+  <col style="width: 3px">
+  <col style="width: 17px">
+  <col style="width: 2px">
+  <tr style="height: 10px">
+    <td style="background: #93bd5d"></td>
+    <td style="background: #b55dbd"></td>
+    <td style="background: #8d4921"></td>
+  </tr>
+  <tr style="height: 8px">
+    <td style="background: #21a02c"></td>
+    <td style="background: #4a298e"></td>
+    <td style="background: #ef9b23"></td>
+  </tr>
+  <tr style="height: 5px">
+    <td style="background: #9b733a"></td>
+    <td style="background: #f155ad"></td>
+    <td style="background: #adf3eb"></td>
+  </tr>
+</table>
+
+<table>
+  <col style="width: 0px">
+  <col style="width: 8px">
+  <col style="width: 7px">
+  <tr style="height: 5px">
+    <td style="background: #93bd5d"></td>
+    <td style="background: #b55dbd"></td>
+    <td style="background: #8d4921"></td>
+  </tr>
+  <tr style="height: 5px">
+    <td style="background: #21a02c"></td>
+    <td style="background: #4a298e"></td>
+    <td style="background: #ef9b23"></td>
+  </tr>
+  <tr style="height: 1px">
+    <td style="background: #9b733a"></td>
+    <td style="background: #f155ad"></td>
+    <td style="background: #adf3eb"></td>
+  </tr>
+</table>
+
+<table>
+  <col style="width: 2px">
+  <col style="width: 0px">
+  <col style="width: 8px">
+  <tr style="height: 4px">
+    <td style="background: #93bd5d"></td>
+    <td style="background: #b55dbd"></td>
+    <td style="background: #8d4921"></td>
+  </tr>
+  <tr style="height: 8px">
+    <td style="background: #21a02c"></td>
+    <td style="background: #4a298e"></td>
+    <td style="background: #ef9b23"></td>
+  </tr>
+  <tr style="height: 10px">
+    <td style="background: #9b733a"></td>
+    <td style="background: #f155ad"></td>
+    <td style="background: #adf3eb"></td>
+  </tr>
+</table>
+
+<table>
+  <col style="width: 2px">
+  <col style="width: 17px">
+  <col style="width: 0px">
+  <tr style="height: 4px">
+    <td style="background: #93bd5d"></td>
+    <td style="background: #b55dbd"></td>
+    <td style="background: #8d4921"></td>
+  </tr>
+  <tr style="height: 0px">
+    <td style="background: #21a02c"></td>
+    <td style="background: #4a298e"></td>
+    <td style="background: #ef9b23"></td>
+  </tr>
+  <tr style="height: 10px">
+    <td style="background: #9b733a"></td>
+    <td style="background: #f155ad"></td>
+    <td style="background: #adf3eb"></td>
+  </tr>
+</table>
+
+<table>
+  <col style="width: 0px">
+  <col style="width: 17px">
+  <col style="width: 3px">
+  <tr style="height: 1px">
+    <td style="background: #93bd5d"></td>
+    <td style="background: #b55dbd"></td>
+    <td style="background: #8d4921"></td>
+  </tr>
+  <tr style="height: 0px">
+    <td style="background: #21a02c"></td>
+    <td style="background: #4a298e"></td>
+    <td style="background: #ef9b23"></td>
+  </tr>
+  <tr style="height: 0px">
+    <td style="background: #9b733a"></td>
+    <td style="background: #f155ad"></td>
+    <td style="background: #adf3eb"></td>
+  </tr>
+</table>
+
+</body>
+</html>
diff -r 6c8c95fcaf9b layout/reftests/border-image/multicolor-image-2.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/border-image/multicolor-image-2.html	Thu Jul 17 14:13:04 2008 +0300
@@ -0,0 +1,96 @@
+<!DOCTYPE html>
+<html lang="en-US">
+<head>
+  <title>test of -moz-border-image</title>
+  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
+  <meta http-equiv="Content-Style-Type" content="text/css">
+  <style type="text/css">
+
+  div {
+    background: red; /* fail if this shows through */
+    background-image: url('3x3multicolor.png'); /* fail if this shows through */
+    margin-bottom: 2px;
+  }
+
+  div.one {
+    -moz-border-image: url(10x5multicolor.png) 2 2 1 3;
+    -khtml-border-image: url(10x5multicolor.png) 2 2 1 3;
+    border-image: url(10x5multicolor.png) 2 2 1 3;
+    border-width: 4px 6px 8px 11px;
+    width: 9px;
+    height: 1px;
+  }
+
+  div.two {
+    -moz-border-image: url(10x5multicolor.png) 40% 20% 20% 30%;
+    -khtml-border-image: url(10x5multicolor.png) 40% 20% 20% 30%;
+    border-image: url(10x5multicolor.png) 40% 20% 20% 30%;
+    border-width: 3px 1px 0px 4px;
+    width: 2px;
+    height: 17px;
+  }
+
+  div.three {
+    -moz-border-image: url(10x5multicolor.png) 40% 2 1 30%;
+    -khtml-border-image: url(10x5multicolor.png) 40% 2 1 30%;
+    border-image: url(10x5multicolor.png) 40% 2 1 30%;
+    border-width: 10px 2px 5px 3px;
+    width: 17px;
+    height: 8px;
+  }
+
+  div.four {
+    -moz-border-image: url(10x5multicolor.png) 2 2 20% 30%;
+    -khtml-border-image: url(10x5multicolor.png) 2 2 20% 30%;
+    border-image: url(10x5multicolor.png) 2 2 20% 30%;
+    border-width: 5px 7px 1px 0;
+    width: 8px;
+    height: 5px;
+  }
+
+  div.five {
+    border-width: 5px 6px 7px 8px; /* ignored */
+    border-width: 5px 6px 7px 8px ! important; /* ignored */
+    -moz-border-image: url(10x5multicolor.png) 40% 2 1 30% / 4px 8px 10px 2px;
+    -khtml-border-image: url(10x5multicolor.png) 40% 2 1 30% / 4px 8px 10px 2px;
+    border-image: url(10x5multicolor.png) 40% 2 1 30% / 4px 8px 10px 2px;
+    border-width: 5px 6px 7px 8px; /* ignored */
+    border-width: 5px 6px 7px 8px ! important; /* ignored */
+    width: 0;
+    height: 8px;
+  }
+  div.five {
+    border-width: 5px 6px 7px 8px; /* ignored */
+    border-width: 5px 6px 7px 8px ! important; /* ignored */
+  }
+
+  div.six {
+    border-width: 5px 6px 7px 8px; /* ignored */
+    -moz-border-image: url(10x5multicolor.png) 40% 2 1 30% / 4px 0 10px 2px;
+    -khtml-border-image: url(10x5multicolor.png) 40% 2 1 30% / 4px 0 10px 2px;
+    border-image: url(10x5multicolor.png) 40% 2 1 30% / 4px 0 10px 2px;
+    width: 17px;
+    height: 0;
+  }
+
+  div.seven {
+    -moz-border-image: url(10x5multicolor.png) 40% 2 1 30%;
+    -khtml-border-image: url(10x5multicolor.png) 40% 2 1 30%;
+    border-image: url(10x5multicolor.png) 40% 2 1 30%;
+    border-width: 1px 3px 0 0;
+    width: 17px;
+    height: 0;
+  }
+
+  </style>
+</head>
+<body>
+<div class="one"></div>
+<div class="two"></div>
+<div class="three"></div>
+<div class="four"></div>
+<div class="five"></div>
+<div class="six"></div>
+<div class="seven"></div>
+</body>
+</html>
diff -r 6c8c95fcaf9b layout/reftests/border-image/multicolor-image-3-ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/border-image/multicolor-image-3-ref.html	Thu Jul 17 14:13:04 2008 +0300
@@ -0,0 +1,55 @@
+<!DOCTYPE html>
+<html lang="en-US">
+<head>
+  <title>test of -moz-border-image: number repetition</title>
+  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
+  <meta http-equiv="Content-Style-Type" content="text/css">
+  <style type="text/css">
+
+  div {
+    background: red; /* fail if this shows through */
+    background-image: url('3x3multicolor.png'); /* fail if this shows through */
+    margin-bottom: 2px;
+  }
+
+  div.one {
+    -moz-border-image: url(10x5multicolor.png) 2 2 2 2 / 4px 6px 8px 6px;
+    -khtml-border-image: url(10x5multicolor.png) 2 2 2 2 / 4px 6px 8px 6px;
+    border-image: url(10x5multicolor.png) 2 2 2 2 / 4px 6px 8px 6px;
+    width: 5px;
+    height: 2px;
+  }
+
+  div.two {
+    -moz-border-image: url(10x5multicolor.png) 2 1 2 1/ 4px 4px 4px 4px;
+    -khtml-border-image: url(10x5multicolor.png) 2 1 2 1/ 4px 4px 4px 4px;
+    border-image: url(10x5multicolor.png) 2 1 2 1/ 4px 4px 4px 4px;
+    width: 5px;
+    height: 2px;
+  }
+
+  div.three {
+    -moz-border-image: url(10x5multicolor.png) 2 3 1 3 / 4px 2px 4px 2px;
+    -khtml-border-image: url(10x5multicolor.png) 2 3 1 3 / 4px 2px 4px 2px;
+    border-image: url(10x5multicolor.png) 2 3 1 3 / 4px 2px 4px 2px;
+    width: 5px;
+    height: 2px;
+  }
+
+  div.four {
+    -moz-border-image: url(10x5multicolor.png) 2 3 1 1 / 4px 3px 4px 3px;
+    -khtml-border-image: url(10x5multicolor.png) 2 3 1 1 / 4px 3px 4px 3px;
+    border-image: url(10x5multicolor.png) 2 3 1 1 / 4px 3px 4px 3px;
+    width: 5px;
+    height: 2px;
+  }
+
+  </style>
+</head>
+<body>
+<div class="one"></div>
+<div class="two"></div>
+<div class="three"></div>
+<div class="four"></div>
+</body>
+</html>
diff -r 6c8c95fcaf9b layout/reftests/border-image/multicolor-image-3.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/border-image/multicolor-image-3.html	Thu Jul 17 14:13:04 2008 +0300
@@ -0,0 +1,56 @@
+<!DOCTYPE html>
+<html lang="en-US">
+<head>
+  <title>test of -moz-border-image: number repetition</title>
+  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
+  <meta http-equiv="Content-Style-Type" content="text/css">
+  <style type="text/css">
+
+  div {
+    background: red; /* fail if this shows through */
+    background-image: url('3x3multicolor.png'); /* fail if this shows through */
+    margin-bottom: 2px;
+  }
+
+  div.one {
+    -moz-border-image: url(10x5multicolor.png) 2 / 4px 6px 8px;
+    -khtml-border-image: url(10x5multicolor.png) 2 / 4px 6px 8px;
+    border-image: url(10x5multicolor.png) 2 / 4px 6px 8px;
+    width: 5px;
+    height: 2px;
+  }
+
+  div.two {
+    -moz-border-image: url(10x5multicolor.png) 2 1 / 4px;
+    -khtml-border-image: url(10x5multicolor.png) 2 1 / 4px;
+    border-image: url(10x5multicolor.png) 2 1 / 4px;
+    width: 5px;
+    height: 2px;
+  }
+
+  div.three {
+    -moz-border-image: url(10x5multicolor.png) 2 3 1;
+    -khtml-border-image: url(10x5multicolor.png) 2 3 1;
+    border-image: url(10x5multicolor.png) 2 3 1;
+    border-width: 4px 2px;
+    width: 5px;
+    height: 2px;
+  }
+
+  div.four {
+    -moz-border-image: url(10x5multicolor.png) 2 3 1 1 / 4px 3px;
+    -khtml-border-image: url(10x5multicolor.png) 2 3 1 1 / 4px 3px;
+    border-image: url(10x5multicolor.png) 2 3 1 1 / 4px 3px;
+    width: 5px;
+    height: 2px;
+  }
+
+  </style>
+</head>
+<body>
+<div class="one"></div>
+<div class="two"></div>
+<div class="three"></div>
+<div class="four"></div>
+</body>
+</html>
diff -r 6c8c95fcaf9b layout/reftests/border-image/reftest.list
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/border-image/reftest.list	Thu Jul 17 14:13:04 2008 +0300
@@ -0,0 +1,7 @@
+fails-if(MOZ_WIDGET_TOOLKIT=="cocoa") == solid-image-1.html solid-image-1-ref.html
+== transparent-image-1.html transparent-image-1-ref.html
+fails-if(MOZ_WIDGET_TOOLKIT=="cocoa") == solid-image-2.html solid-image-2-ref.html
+== multicolor-image-1.html multicolor-image-1-ref.html
+== multicolor-image-2.html multicolor-image-2-ref.html
+== multicolor-image-3.html multicolor-image-3-ref.html
+!= repeat-image-1.html repeat-image-1-ref.html
diff -r 6c8c95fcaf9b layout/reftests/border-image/repeat-image-1-ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/border-image/repeat-image-1-ref.html	Thu Jul 17 14:13:04 2008 +0300
@@ -0,0 +1,57 @@
+<!DOCTYPE html>
+<html lang="en-US">
+<head>
+  <title>test of -moz-border-image</title>
+  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
+  <meta http-equiv="Content-Style-Type" content="text/css">
+  <style type="text/css">
+
+  table { margin: 0; padding: 0; border-spacing: 0; empty-cells: show; }
+  td { padding: 0; }
+
+  </style>
+</head>
+<body>
+<table>
+  <col style="width: 3px">
+  <col style="width: 1px">
+  <col style="width: 1px">
+  <col style="width: 1px">
+  <col style="width: 1px">
+  <col style="width: 3px">
+
+  <tr style="height: 1px">
+    <td style="background: #ff0000"></td>
+    <td style="background: #00ff00"></td>
+    <td style="background: #0000ff"></td>
+    <td style="background: #00ff00"></td>
+    <td style="background: #0000ff"></td>
+    <td style="background: #ff0000"></td>
+  </tr>
+  <tr style="height: 1px">
+    <td style="background: #00ff00"></td>
+    <td style="background: #ff0000"></td>
+    <td style="background: #ff0000"></td>
+    <td style="background: #ff0000"></td>
+    <td style="background: #ff0000"></td>
+    <td style="background: #0000ff"></td>
+  </tr>
+  <tr style="height: 1px">
+    <td style="background: #0000ff"></td>
+    <td style="background: #ff0000"></td>
+    <td style="background: #ff0000"></td>
+    <td style="background: #ff0000"></td>
+    <td style="background: #ff0000"></td>
+    <td style="background: #00ff00"></td>
+  </tr>
+  <tr style="height: 1px">
+    <td style="background: #ff0000"></td>
+    <td style="background: #00ff00"></td>
+    <td style="background: #0000ff"></td>
+    <td style="background: #00ff00"></td>
+    <td style="background: #0000ff"></td>
+    <td style="background: #ff0000"></td>
+  </tr>
+</table>
+</body>
+</html>
diff -r 6c8c95fcaf9b layout/reftests/border-image/repeat-image-1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/border-image/repeat-image-1.html	Thu Jul 17 14:13:04 2008 +0300
@@ -0,0 +1,31 @@
+<!DOCTYPE html>
+<html lang="en-US">
+<head>
+  <title>test of -moz-border-image</title>
+  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
+  <meta http-equiv="Content-Style-Type" content="text/css">
+  <style type="text/css">
+
+  div.p1 {
+    background: red; /* fail if this shows through */
+    background-image: url('3x3multicolor.png'); /* fail if this shows through */
+    -moz-border-image: url('4x4multicolor.png') 1 1 1 1 / 1px 3px repeat;
+    -khtml-border-image: url('4x4multicolor.png') 1 1 1 1 / 1px 3px repeat;
+    border-image: url('4x4multicolor.png') 1 1 1 1 / 1px 3px repeat;
+  }
+
+  div.p2 {
+    background: red; /* fail if this shows through */
+    background-image: url('3x3multicolor.png'); /* fail if this shows through */
+    -moz-border-image: url('4x4multicolor.png') 1 1 1 1 / 1px 3px;
+    -khtml-border-image: url('4x4multicolor.png') 1 1 1 1 / 1px 3px;
+    border-image: url('4x4multicolor.png') 1 1 1 1 / 1px 3px;
+  }
+
+  </style>
+</head>
+<body>
+<div class="p1" style="width: 4px; height: 2px"></div>
+<!--<div class="p2" style="width: 4px; height: 2px"></div> -->
+</body>
+</html>
diff -r 6c8c95fcaf9b layout/reftests/border-image/solid-image-1-ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/border-image/solid-image-1-ref.html	Thu Jul 17 14:13:04 2008 +0300
@@ -0,0 +1,11 @@
+<!DOCTYPE html>
+<html lang="en-US">
+<head>
+  <title>test of -moz-border-image</title>
+  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
+  <meta http-equiv="Content-Style-Type" content="text/css">
+</head>
+<body>
+<div style="border: solid #1DD813 1em;">border.png<br />second longer longer longer longer longer longer line<br />third longer longer longer longer longer longer line</div>
+</body>
+</html>
diff -r 6c8c95fcaf9b layout/reftests/border-image/solid-image-1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/border-image/solid-image-1.html	Thu Jul 17 14:13:04 2008 +0300
@@ -0,0 +1,18 @@
+<!DOCTYPE html>
+<html lang="en-US">
+<head>
+  <title>test of -moz-border-image</title>
+  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
+  <meta http-equiv="Content-Style-Type" content="text/css">
+  <style type="text/css">
+  div {
+    -moz-border-image: url('3x3green-1DD813.png') 1 1 1 1 / 1em;
+    -khtml-border-image: url('3x3green-1DD813.png') 1 1 1 1 / 1em;
+    border-image: url('3x3green-1DD813.png') 1 1 1 1 / 1em;
+  }
+  </style>
+</head>
+<body>
+<div>border.png<br />second longer longer longer longer longer longer line<br />third longer longer longer longer longer longer line</div>
+</body>
+</html>
diff -r 6c8c95fcaf9b layout/reftests/border-image/solid-image-2-ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/border-image/solid-image-2-ref.html	Thu Jul 17 14:13:04 2008 +0300
@@ -0,0 +1,38 @@
+<!DOCTYPE html>
+<html lang="en-US">
+<head>
+  <title>test of -moz-border-image</title>
+  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
+  <meta http-equiv="Content-Style-Type" content="text/css">
+  <style type="text/css">
+
+  div {
+    border: 10px solid #1DD813;
+    margin: 1px;
+  }
+
+  </style>
+</head>
+<body>
+<div style="width: 50px; height: 5px"></div>
+<div style="width: 51px; height: 5px"></div>
+<div style="width: 52px; height: 5px"></div>
+<div style="width: 53px; height: 5px"></div>
+<div style="width: 54px; height: 5px"></div>
+<div style="width: 55px; height: 5px"></div>
+<div style="width: 56px; height: 5px"></div>
+<div style="width: 57px; height: 5px"></div>
+<div style="width: 58px; height: 5px"></div>
+<div style="width: 59px; height: 5px"></div>
+<div style="width: 550px; height: 5px"></div>
+<div style="width: 551px; height: 5px"></div>
+<div style="width: 552px; height: 5px"></div>
+<div style="width: 553px; height: 5px"></div>
+<div style="width: 554px; height: 5px"></div>
+<div style="width: 555px; height: 5px"></div>
+<div style="width: 556px; height: 5px"></div>
+<div style="width: 557px; height: 5px"></div>
+<div style="width: 558px; height: 5px"></div>
+<div style="width: 559px; height: 5px"></div>
+</body>
+</html>
diff -r 6c8c95fcaf9b layout/reftests/border-image/solid-image-2.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/border-image/solid-image-2.html	Thu Jul 17 14:13:04 2008 +0300
@@ -0,0 +1,40 @@
+<!DOCTYPE html>
+<html lang="en-US">
+<head>
+  <title>test of -moz-border-image</title>
+  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
+  <meta http-equiv="Content-Style-Type" content="text/css">
+  <style type="text/css">
+
+  div {
+    -moz-border-image: url('3x3green-1DD813.png') 1 1 1 1 / 10px;
+    -khtml-border-image: url('3x3green-1DD813.png') 1 1 1 1 / 10px;
+    border-image: url('3x3green-1DD813.png') 1 1 1 1 / 10px;
+    margin: 1px;
+  }
+
+  </style>
+</head>
+<body>
+<div style="width: 50px; height: 5px"></div>
+<div style="width: 51px; height: 5px"></div>
+<div style="width: 52px; height: 5px"></div>
+<div style="width: 53px; height: 5px"></div>
+<div style="width: 54px; height: 5px"></div>
+<div style="width: 55px; height: 5px"></div>
+<div style="width: 56px; height: 5px"></div>
+<div style="width: 57px; height: 5px"></div>
+<div style="width: 58px; height: 5px"></div>
+<div style="width: 59px; height: 5px"></div>
+<div style="width: 550px; height: 5px"></div>
+<div style="width: 551px; height: 5px"></div>
+<div style="width: 552px; height: 5px"></div>
+<div style="width: 553px; height: 5px"></div>
+<div style="width: 554px; height: 5px"></div>
+<div style="width: 555px; height: 5px"></div>
+<div style="width: 556px; height: 5px"></div>
+<div style="width: 557px; height: 5px"></div>
+<div style="width: 558px; height: 5px"></div>
+<div style="width: 559px; height: 5px"></div>
+</body>
+</html>
diff -r 6c8c95fcaf9b layout/reftests/border-image/transparent-image-1-ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/border-image/transparent-image-1-ref.html	Thu Jul 17 14:13:04 2008 +0300
@@ -0,0 +1,11 @@
+<!DOCTYPE html>
+<html lang="en-US">
+<head>
+  <title>test of -moz-border-image</title>
+  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
+  <meta http-equiv="Content-Style-Type" content="text/css">
+</head>
+<body>
+<div style="padding: 1em;">border.png<br />second longer longer longer longer longer longer line<br />third longer longer longer longer longer longer line</div>
+</body>
+</html>
diff -r 6c8c95fcaf9b layout/reftests/border-image/transparent-image-1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/border-image/transparent-image-1.html	Thu Jul 17 14:13:04 2008 +0300
@@ -0,0 +1,18 @@
+<!DOCTYPE html>
+<html lang="en-US">
+<head>
+  <title>test of -moz-border-image</title>
+  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
+  <meta http-equiv="Content-Style-Type" content="text/css">
+  <style type="text/css">
+  div {
+    -moz-border-image: url('3x3transparent.png') 1 1 1 1; border: double orange 1em;
+    -khtml-border-image: url('3x3transparent.png') 1 1 1 1; border: double orange 1em;
+    border-image: url('3x3transparent.png') 1 1 1 1; border: double orange 1em;
+  }
+  </style>
+</head>
+<body>
+<div>border.png<br />second longer longer longer longer longer longer line<br />third longer longer longer longer longer longer line</div>
+</body>
+</html>
diff -r 6c8c95fcaf9b layout/reftests/bugs/371043-1-ref.html
--- a/layout/reftests/bugs/371043-1-ref.html	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/reftests/bugs/371043-1-ref.html	Thu Jul 17 14:13:04 2008 +0300
@@ -1,9 +1,9 @@
 <!DOCTYPE html>
 <body>
   <div id="source" style="font-size: 10px; -moz-column-gap: 2ch">
     <span id="test"
           style="background: green; color: green; display: inline-block;
-                 height: 30px; padding: 0 2px">MM
+                 height: 30px; padding: 0 2px">00
     </span>
   </div>
 </body>
diff -r 6c8c95fcaf9b layout/reftests/bugs/391979-ref.html
--- a/layout/reftests/bugs/391979-ref.html	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/reftests/bugs/391979-ref.html	Thu Jul 17 14:13:04 2008 +0300
@@ -6,11 +6,11 @@
 
         html,body {
             color:black; background-color:white; font-size:16px; padding:0; margin:0;
         }
 	
-        div { background:green; width:20ch; height:2ch; }
+        div { background:green; width:20ch; height:4ch; }
     </style>
 </head>
 <body>
 <div>green</div>
 <div>green</div>
diff -r 6c8c95fcaf9b layout/reftests/bugs/391979.html
--- a/layout/reftests/bugs/391979.html	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/reftests/bugs/391979.html	Thu Jul 17 14:13:04 2008 +0300
@@ -7,32 +7,32 @@
         html,body {
             color:black; background-color:white; font-size:16px; padding:0; margin:0;
         }
 	
         .float { float:left; clear:both; }
-        .t1 { -moz-column-count:2; -moz-column-width: 9ch; -moz-column-gap: 2ch; background:red; height:2ch; }
+        .t1 { -moz-column-count:2; -moz-column-width: 9ch; -moz-column-gap: 2ch; background:red; height:4ch; }
 
-        .abs { position:absolute; width:20ch; height:2ch; }
+        .abs { position:absolute; width:20ch; height:4ch; }
 
         .red { background:red; }
         .green { background:green; }
     </style>
 </head>
 <body>
 <div class="abs green" style="left:0; top:0;">green</div>
-<div class="abs red" style="left:0; top:2ch; z-index:-1;">green</div>
-<div class="abs green" style="left:0; top:4ch; z-index:2;">green</div>
-<div class="abs red" style="left:0; top:6ch;">green</div>
+<div class="abs red" style="left:0; top:4ch; z-index:-1;">green</div>
+<div class="abs green" style="left:0; top:8ch; z-index:2;">green</div>
+<div class="abs red" style="left:0; top:12ch;">green</div>
 
 <div class="float">
   <div class="t1 red">green</div>
 </div>
 
 <div class="float">
   <div class="t1 green">green</div>
 </div>
 
-<div class="t1" style="position: absolute; top:4ch; ">green</div>
-<div class="t1 green" style="position: absolute; top:6ch; z-index:2;">green</div>
+<div class="t1" style="position: absolute; top:8ch; ">green</div>
+<div class="t1 green" style="position: absolute; top:12ch; z-index:2;">green</div>
 
 </body>
 </html>
diff -r 6c8c95fcaf9b layout/reftests/bugs/reftest.list
--- a/layout/reftests/bugs/reftest.list	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/reftests/bugs/reftest.list	Thu Jul 17 14:13:04 2008 +0300
@@ -391,11 +391,11 @@ skip-if(MOZ_WIDGET_TOOLKIT=="windows") =
 == 363329-1.html 363329-1-ref.html
 == 363329-2.html 363329-2-ref.html
 == 363370-1.html 363370-1-ref.html
 == 363402-1.html 363402-1-ref.html
 == 363637-1.html 363637-1-ref.html
-fails == 363706-1.html 363706-1-ref.html
+== 363706-1.html 363706-1-ref.html
 != 363706-1.html about:blank
 == 363858-1.html 363858-1-ref.html
 == 363858-2.html 363858-2-ref.html
 == 363858-3.html 363858-3-ref.html
 == 363858-4.html 363858-4-ref.html
diff -r 6c8c95fcaf9b layout/reftests/pixel-rounding/border-image-width-0.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/pixel-rounding/border-image-width-0.html	Thu Jul 17 14:13:04 2008 +0300
@@ -0,0 +1,59 @@
+<!DOCTYPE HTML>
+<html>
+<head>
+<title>Pixel rounding testcase</title>
+<style type="text/css">
+
+html, body { margin: 0; border: none; padding: 0; }
+div { position: absolute; height: 10px; width: 10px; }
+
+</style>
+</head>
+<body>
+
+<div style="top: 10px; left: 10px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2px 2px;"></div>
+<div style="top: 10px; left: 30px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2px 2px;"></div>
+<div style="top: 10px; left: 50px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2px 2px;"></div>
+<div style="top: 10px; left: 70px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2px 2px;"></div>
+<div style="top: 10px; left: 90px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2px 2px;"></div>
+<div style="top: 10px; left: 110px; -moz-border-image: url(random-10x10.png) 3 2 2 3; border-width: 2px 2px 2px 2px;"></div>
+<div style="top: 10px; left: 130px; -moz-border-image: url(random-10x10.png) 3 2 2 3 stretch; border-width: 2px 2px 2px 2px;"></div>
+<div style="top: 10px; left: 150px; -moz-border-image: url(random-10x10.png) 3 2 2 3 stretch stretch; border-width: 2px 2px 2px 2px;"></div>
+<div style="top: 10px; left: 170px; -moz-border-image: url(random-10x10.png) 3 2 2 3; border-width: 2px 2px 2px 2px;"></div>
+<div style="top: 10px; left: 190px; -moz-border-image: url(random-10x10.png) 3 2 2 3; border-width: 2px 2px 2px 2px;"></div>
+
+<div style="top: 30px; left: 10px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2px 2px round;"></div>
+<div style="top: 30px; left: 30px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2px 2px round round;"></div>
+<div style="top: 30px; left: 50px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2px 2px round round;"></div>
+<div style="top: 30px; left: 70px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2px 2px round;"></div>
+<div style="top: 30px; left: 90px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2px 2px round;"></div>
+<div style="top: 30px; left: 110px; -moz-border-image: url(random-10x10.png) 3 2 2 3 round round; border-width: 2px 2px 2px 2px;"></div>
+<div style="top: 30px; left: 130px; -moz-border-image: url(random-10x10.png) 3 2 2 3 round; border-width: 2px 2px 2px 2px;"></div>
+<div style="top: 30px; left: 150px; -moz-border-image: url(random-10x10.png) 3 2 2 3 round; border-width: 2px 2px 2px 2px;"></div>
+<div style="top: 30px; left: 170px; -moz-border-image: url(random-10x10.png) 3 2 2 3 round; border-width: 2px 2px 2px 2px;"></div>
+<div style="top: 30px; left: 190px; -moz-border-image: url(random-10x10.png) 3 2 2 3 round round; border-width: 2px 2px 2px 2px;"></div>
+
+<div style="top: 50px; left: 10px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2px 2px repeat;"></div>
+<div style="top: 50px; left: 30px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2px 2px repeat repeat;"></div>
+<div style="top: 50px; left: 50px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2px 2px repeat repeat;"></div>
+<div style="top: 50px; left: 70px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2px 2px repeat;"></div>
+<div style="top: 50px; left: 90px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2px 2px repeat;"></div>
+<div style="top: 50px; left: 110px; -moz-border-image: url(random-10x10.png) 3 2 2 3 repeat repeat; border-width: 2px 2px 2px 2px;"></div>
+<div style="top: 50px; left: 130px; -moz-border-image: url(random-10x10.png) 3 2 2 3 repeat; border-width: 2px 2px 2px 2px;"></div>
+<div style="top: 50px; left: 150px; -moz-border-image: url(random-10x10.png) 3 2 2 3 repeat; border-width: 2px 2px 2px 2px;"></div>
+<div style="top: 50px; left: 170px; -moz-border-image: url(random-10x10.png) 3 2 2 3 repeat; border-width: 2px 2px 2px 2px;"></div>
+<div style="top: 50px; left: 190px; -moz-border-image: url(random-10x10.png) 3 2 2 3 repeat repeat; border-width: 2px 2px 2px 2px;"></div>
+
+<div style="top: 70px; left: 10px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2px 2px repeat round;"></div>
+<div style="top: 70px; left: 30px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2px 2px stretch repeat;"></div>
+<div style="top: 70px; left: 50px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2px 2px round repeat;"></div>
+<div style="top: 70px; left: 70px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2px 2px repeat stretch;"></div>
+<div style="top: 70px; left: 90px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2px 2px round stretch;"></div>
+<div style="top: 70px; left: 110px; -moz-border-image: url(random-10x10.png) 3 2 2 3 stretch round; border-width: 2px 2px 2px 2px;"></div>
+<div style="top: 70px; left: 130px; -moz-border-image: url(random-10x10.png) 3 2 2 3 round repeat; border-width: 2px 2px 2px 2px;"></div>
+<div style="top: 70px; left: 150px; -moz-border-image: url(random-10x10.png) 3 2 2 3 stretch repeat; border-width: 2px 2px 2px 2px;"></div>
+<div style="top: 70px; left: 170px; -moz-border-image: url(random-10x10.png) 3 2 2 3 repeat round; border-width: 2px 2px 2px 2px;"></div>
+<div style="top: 70px; left: 190px; -moz-border-image: url(random-10x10.png) 3 2 2 3 repeat round; border-width: 2px 2px 2px 2px;"></div>
+
+</body>
+</html>
diff -r 6c8c95fcaf9b layout/reftests/pixel-rounding/border-image-width-10.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/pixel-rounding/border-image-width-10.html	Thu Jul 17 14:13:04 2008 +0300
@@ -0,0 +1,59 @@
+<!DOCTYPE HTML>
+<html>
+<head>
+<title>Pixel rounding testcase</title>
+<style type="text/css">
+
+html, body { margin: 0; border: none; padding: 0; }
+div { position: absolute; height: 10px; width: 10px; }
+
+</style>
+</head>
+<body>
+
+<div style="top: 10px; left: 10px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 3px 2px 2px 2px;"></div>
+<div style="top: 10px; left: 30px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 3px 2px 2px;"></div>
+<div style="top: 10px; left: 50px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 3px 2px;"></div>
+<div style="top: 10px; left: 70px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2px 3px;"></div>
+<div style="top: 10px; left: 90px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 3px 3px 3px 3px;"></div>
+<div style="top: 10px; left: 110px; -moz-border-image: url(random-10x10.png) 3 2 2 3; border-width: 3px 2px 2px 2px;"></div>
+<div style="top: 10px; left: 130px; -moz-border-image: url(random-10x10.png) 3 2 2 3 stretch; border-width: 2px 3px 2px 2px;"></div>
+<div style="top: 10px; left: 150px; -moz-border-image: url(random-10x10.png) 3 2 2 3 stretch stretch; border-width: 2px 2px 3px 2px;"></div>
+<div style="top: 10px; left: 170px; -moz-border-image: url(random-10x10.png) 3 2 2 3; border-width: 2px 2px 2px 3px;"></div>
+<div style="top: 10px; left: 190px; -moz-border-image: url(random-10x10.png) 3 2 2 3; border-width: 3px 3px 3px 3px;"></div>
+
+<div style="top: 30px; left: 10px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 3px 2px 2px 2px round;"></div>
+<div style="top: 30px; left: 30px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 3px 2px 2px round round;"></div>
+<div style="top: 30px; left: 50px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 3px 2px round round;"></div>
+<div style="top: 30px; left: 70px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2px 3px round;"></div>
+<div style="top: 30px; left: 90px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 3px 3px 3px 3px round;"></div>
+<div style="top: 30px; left: 110px; -moz-border-image: url(random-10x10.png) 3 2 2 3 round round; border-width: 3px 2px 2px 2px;"></div>
+<div style="top: 30px; left: 130px; -moz-border-image: url(random-10x10.png) 3 2 2 3 round; border-width: 2px 3px 2px 2px;"></div>
+<div style="top: 30px; left: 150px; -moz-border-image: url(random-10x10.png) 3 2 2 3 round; border-width: 2px 2px 3px 2px;"></div>
+<div style="top: 30px; left: 170px; -moz-border-image: url(random-10x10.png) 3 2 2 3 round; border-width: 2px 2px 2px 3px;"></div>
+<div style="top: 30px; left: 190px; -moz-border-image: url(random-10x10.png) 3 2 2 3 round round; border-width: 3px 3px 3px 3px;"></div>
+
+<div style="top: 50px; left: 10px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 3px 2px 2px 2px repeat;"></div>
+<div style="top: 50px; left: 30px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 3px 2px 2px repeat repeat;"></div>
+<div style="top: 50px; left: 50px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 3px 2px repeat repeat;"></div>
+<div style="top: 50px; left: 70px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2px 3px repeat;"></div>
+<div style="top: 50px; left: 90px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 3px 3px 3px 3px repeat;"></div>
+<div style="top: 50px; left: 110px; -moz-border-image: url(random-10x10.png) 3 2 2 3 repeat repeat; border-width: 3px 2px 2px 2px;"></div>
+<div style="top: 50px; left: 130px; -moz-border-image: url(random-10x10.png) 3 2 2 3 repeat; border-width: 2px 3px 2px 2px;"></div>
+<div style="top: 50px; left: 150px; -moz-border-image: url(random-10x10.png) 3 2 2 3 repeat; border-width: 2px 2px 3px 2px;"></div>
+<div style="top: 50px; left: 170px; -moz-border-image: url(random-10x10.png) 3 2 2 3 repeat; border-width: 2px 2px 2px 3px;"></div>
+<div style="top: 50px; left: 190px; -moz-border-image: url(random-10x10.png) 3 2 2 3 repeat repeat; border-width: 3px 3px 3px 3px;"></div>
+
+<div style="top: 70px; left: 10px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 3px 2px 2px 2px repeat round;"></div>
+<div style="top: 70px; left: 30px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 3px 2px 2px stretch repeat;"></div>
+<div style="top: 70px; left: 50px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 3px 2px round repeat;"></div>
+<div style="top: 70px; left: 70px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2px 3px repeat stretch;"></div>
+<div style="top: 70px; left: 90px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 3px 3px 3px 3px round stretch;"></div>
+<div style="top: 70px; left: 110px; -moz-border-image: url(random-10x10.png) 3 2 2 3 stretch round; border-width: 3px 2px 2px 2px;"></div>
+<div style="top: 70px; left: 130px; -moz-border-image: url(random-10x10.png) 3 2 2 3 round repeat; border-width: 2px 3px 2px 2px;"></div>
+<div style="top: 70px; left: 150px; -moz-border-image: url(random-10x10.png) 3 2 2 3 stretch repeat; border-width: 2px 2px 3px 2px;"></div>
+<div style="top: 70px; left: 170px; -moz-border-image: url(random-10x10.png) 3 2 2 3 repeat round; border-width: 2px 2px 2px 3px;"></div>
+<div style="top: 70px; left: 190px; -moz-border-image: url(random-10x10.png) 3 2 2 3 repeat round; border-width: 3px 3px 3px 3px;"></div>
+
+</body>
+</html>
diff -r 6c8c95fcaf9b layout/reftests/pixel-rounding/border-image-width-4.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/pixel-rounding/border-image-width-4.html	Thu Jul 17 14:13:04 2008 +0300
@@ -0,0 +1,59 @@
+<!DOCTYPE HTML>
+<html>
+<head>
+<title>Pixel rounding testcase</title>
+<style type="text/css">
+
+html, body { margin: 0; border: none; padding: 0; }
+div { position: absolute; height: 10px; width: 10px; }
+
+</style>
+</head>
+<body>
+
+<div style="top: 10px; left: 10px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2.4px 2px 2px 2px;"></div>
+<div style="top: 10px; left: 30px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2.4px 2px 2px;"></div>
+<div style="top: 10px; left: 50px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2.4px 2px;"></div>
+<div style="top: 10px; left: 70px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2px 2.4px;"></div>
+<div style="top: 10px; left: 90px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2.4px 2.4px 2.4px 2.4px;"></div>
+<div style="top: 10px; left: 110px; -moz-border-image: url(random-10x10.png) 3 2 2 3; border-width: 2.4px 2px 2px 2px;"></div>
+<div style="top: 10px; left: 130px; -moz-border-image: url(random-10x10.png) 3 2 2 3 stretch; border-width: 2px 2.4px 2px 2px;"></div>
+<div style="top: 10px; left: 150px; -moz-border-image: url(random-10x10.png) 3 2 2 3 stretch stretch; border-width: 2px 2px 2.4px 2px;"></div>
+<div style="top: 10px; left: 170px; -moz-border-image: url(random-10x10.png) 3 2 2 3; border-width: 2px 2px 2px 2.4px;"></div>
+<div style="top: 10px; left: 190px; -moz-border-image: url(random-10x10.png) 3 2 2 3; border-width: 2.4px 2.4px 2.4px 2.4px;"></div>
+
+<div style="top: 30px; left: 10px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2.4px 2px 2px 2px round;"></div>
+<div style="top: 30px; left: 30px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2.4px 2px 2px round round;"></div>
+<div style="top: 30px; left: 50px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2.4px 2px round round;"></div>
+<div style="top: 30px; left: 70px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2px 2.4px round;"></div>
+<div style="top: 30px; left: 90px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2.4px 2.4px 2.4px 2.4px round;"></div>
+<div style="top: 30px; left: 110px; -moz-border-image: url(random-10x10.png) 3 2 2 3 round round; border-width: 2.4px 2px 2px 2px;"></div>
+<div style="top: 30px; left: 130px; -moz-border-image: url(random-10x10.png) 3 2 2 3 round; border-width: 2px 2.4px 2px 2px;"></div>
+<div style="top: 30px; left: 150px; -moz-border-image: url(random-10x10.png) 3 2 2 3 round; border-width: 2px 2px 2.4px 2px;"></div>
+<div style="top: 30px; left: 170px; -moz-border-image: url(random-10x10.png) 3 2 2 3 round; border-width: 2px 2px 2px 2.4px;"></div>
+<div style="top: 30px; left: 190px; -moz-border-image: url(random-10x10.png) 3 2 2 3 round round; border-width: 2.4px 2.4px 2.4px 2.4px;"></div>
+
+<div style="top: 50px; left: 10px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2.4px 2px 2px 2px repeat;"></div>
+<div style="top: 50px; left: 30px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2.4px 2px 2px repeat repeat;"></div>
+<div style="top: 50px; left: 50px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2.4px 2px repeat repeat;"></div>
+<div style="top: 50px; left: 70px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2px 2.4px repeat;"></div>
+<div style="top: 50px; left: 90px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2.4px 2.4px 2.4px 2.4px repeat;"></div>
+<div style="top: 50px; left: 110px; -moz-border-image: url(random-10x10.png) 3 2 2 3 repeat repeat; border-width: 2.4px 2px 2px 2px;"></div>
+<div style="top: 50px; left: 130px; -moz-border-image: url(random-10x10.png) 3 2 2 3 repeat; border-width: 2px 2.4px 2px 2px;"></div>
+<div style="top: 50px; left: 150px; -moz-border-image: url(random-10x10.png) 3 2 2 3 repeat; border-width: 2px 2px 2.4px 2px;"></div>
+<div style="top: 50px; left: 170px; -moz-border-image: url(random-10x10.png) 3 2 2 3 repeat; border-width: 2px 2px 2px 2.4px;"></div>
+<div style="top: 50px; left: 190px; -moz-border-image: url(random-10x10.png) 3 2 2 3 repeat repeat; border-width: 2.4px 2.4px 2.4px 2.4px;"></div>
+
+<div style="top: 70px; left: 10px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2.4px 2px 2px 2px repeat round;"></div>
+<div style="top: 70px; left: 30px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2.4px 2px 2px stretch repeat;"></div>
+<div style="top: 70px; left: 50px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2.4px 2px round repeat;"></div>
+<div style="top: 70px; left: 70px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2px 2.4px repeat stretch;"></div>
+<div style="top: 70px; left: 90px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2.4px 2.4px 2.4px 2.4px round stretch;"></div>
+<div style="top: 70px; left: 110px; -moz-border-image: url(random-10x10.png) 3 2 2 3 stretch round; border-width: 2.4px 2px 2px 2px;"></div>
+<div style="top: 70px; left: 130px; -moz-border-image: url(random-10x10.png) 3 2 2 3 round repeat; border-width: 2px 2.4px 2px 2px;"></div>
+<div style="top: 70px; left: 150px; -moz-border-image: url(random-10x10.png) 3 2 2 3 stretch repeat; border-width: 2px 2px 2.4px 2px;"></div>
+<div style="top: 70px; left: 170px; -moz-border-image: url(random-10x10.png) 3 2 2 3 repeat round; border-width: 2px 2px 2px 2.4px;"></div>
+<div style="top: 70px; left: 190px; -moz-border-image: url(random-10x10.png) 3 2 2 3 repeat round; border-width: 2.4px 2.4px 2.4px 2.4px;"></div>
+
+</body>
+</html>
diff -r 6c8c95fcaf9b layout/reftests/pixel-rounding/border-image-width-9.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/pixel-rounding/border-image-width-9.html	Thu Jul 17 14:13:04 2008 +0300
@@ -0,0 +1,59 @@
+<!DOCTYPE HTML>
+<html>
+<head>
+<title>Pixel rounding testcase</title>
+<style type="text/css">
+
+html, body { margin: 0; border: none; padding: 0; }
+div { position: absolute; height: 10px; width: 10px; }
+
+</style>
+</head>
+<body>
+
+<div style="top: 10px; left: 10px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2.9px 2px 2px 2px;"></div>
+<div style="top: 10px; left: 30px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2.9px 2px 2px;"></div>
+<div style="top: 10px; left: 50px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2.9px 2px;"></div>
+<div style="top: 10px; left: 70px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2px 2.9px;"></div>
+<div style="top: 10px; left: 90px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2.9px 2.9px 2.9px 2.9px;"></div>
+<div style="top: 10px; left: 110px; -moz-border-image: url(random-10x10.png) 3 2 2 3; border-width: 2.9px 2px 2px 2px;"></div>
+<div style="top: 10px; left: 130px; -moz-border-image: url(random-10x10.png) 3 2 2 3 stretch; border-width: 2px 2.9px 2px 2px;"></div>
+<div style="top: 10px; left: 150px; -moz-border-image: url(random-10x10.png) 3 2 2 3 stretch stretch; border-width: 2px 2px 2.9px 2px;"></div>
+<div style="top: 10px; left: 170px; -moz-border-image: url(random-10x10.png) 3 2 2 3; border-width: 2px 2px 2px 2.9px;"></div>
+<div style="top: 10px; left: 190px; -moz-border-image: url(random-10x10.png) 3 2 2 3; border-width: 2.9px 2.9px 2.9px 2.9px;"></div>
+
+<div style="top: 30px; left: 10px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2.9px 2px 2px 2px round;"></div>
+<div style="top: 30px; left: 30px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2.9px 2px 2px round round;"></div>
+<div style="top: 30px; left: 50px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2.9px 2px round round;"></div>
+<div style="top: 30px; left: 70px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2px 2.9px round;"></div>
+<div style="top: 30px; left: 90px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2.9px 2.9px 2.9px 2.9px round;"></div>
+<div style="top: 30px; left: 110px; -moz-border-image: url(random-10x10.png) 3 2 2 3 round round; border-width: 2.9px 2px 2px 2px;"></div>
+<div style="top: 30px; left: 130px; -moz-border-image: url(random-10x10.png) 3 2 2 3 round; border-width: 2px 2.9px 2px 2px;"></div>
+<div style="top: 30px; left: 150px; -moz-border-image: url(random-10x10.png) 3 2 2 3 round; border-width: 2px 2px 2.9px 2px;"></div>
+<div style="top: 30px; left: 170px; -moz-border-image: url(random-10x10.png) 3 2 2 3 round; border-width: 2px 2px 2px 2.9px;"></div>
+<div style="top: 30px; left: 190px; -moz-border-image: url(random-10x10.png) 3 2 2 3 round round; border-width: 2.9px 2.9px 2.9px 2.9px;"></div>
+
+<div style="top: 50px; left: 10px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2.9px 2px 2px 2px repeat;"></div>
+<div style="top: 50px; left: 30px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2.9px 2px 2px repeat repeat;"></div>
+<div style="top: 50px; left: 50px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2.9px 2px repeat repeat;"></div>
+<div style="top: 50px; left: 70px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2px 2.9px repeat;"></div>
+<div style="top: 50px; left: 90px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2.9px 2.9px 2.9px 2.9px repeat;"></div>
+<div style="top: 50px; left: 110px; -moz-border-image: url(random-10x10.png) 3 2 2 3 repeat repeat; border-width: 2.9px 2px 2px 2px;"></div>
+<div style="top: 50px; left: 130px; -moz-border-image: url(random-10x10.png) 3 2 2 3 repeat; border-width: 2px 2.9px 2px 2px;"></div>
+<div style="top: 50px; left: 150px; -moz-border-image: url(random-10x10.png) 3 2 2 3 repeat; border-width: 2px 2px 2.9px 2px;"></div>
+<div style="top: 50px; left: 170px; -moz-border-image: url(random-10x10.png) 3 2 2 3 repeat; border-width: 2px 2px 2px 2.9px;"></div>
+<div style="top: 50px; left: 190px; -moz-border-image: url(random-10x10.png) 3 2 2 3 repeat repeat; border-width: 2.9px 2.9px 2.9px 2.9px;"></div>
+
+<div style="top: 70px; left: 10px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2.9px 2px 2px 2px repeat round;"></div>
+<div style="top: 70px; left: 30px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2.9px 2px 2px stretch repeat;"></div>
+<div style="top: 70px; left: 50px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2.9px 2px round repeat;"></div>
+<div style="top: 70px; left: 70px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2px 2px 2px 2.9px repeat stretch;"></div>
+<div style="top: 70px; left: 90px; -moz-border-image: url(random-10x10.png) 3 2 2 3 / 2.9px 2.9px 2.9px 2.9px round stretch;"></div>
+<div style="top: 70px; left: 110px; -moz-border-image: url(random-10x10.png) 3 2 2 3 stretch round; border-width: 2.9px 2px 2px 2px;"></div>
+<div style="top: 70px; left: 130px; -moz-border-image: url(random-10x10.png) 3 2 2 3 round repeat; border-width: 2px 2.9px 2px 2px;"></div>
+<div style="top: 70px; left: 150px; -moz-border-image: url(random-10x10.png) 3 2 2 3 stretch repeat; border-width: 2px 2px 2.9px 2px;"></div>
+<div style="top: 70px; left: 170px; -moz-border-image: url(random-10x10.png) 3 2 2 3 repeat round; border-width: 2px 2px 2px 2.9px;"></div>
+<div style="top: 70px; left: 190px; -moz-border-image: url(random-10x10.png) 3 2 2 3 repeat round; border-width: 2.9px 2.9px 2.9px 2.9px;"></div>
+
+</body>
+</html>
diff -r 6c8c95fcaf9b layout/reftests/pixel-rounding/random-10x10.png
Binary file layout/reftests/pixel-rounding/random-10x10.png has changed
diff -r 6c8c95fcaf9b layout/reftests/pixel-rounding/reftest.list
--- a/layout/reftests/pixel-rounding/reftest.list	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/reftests/pixel-rounding/reftest.list	Thu Jul 17 14:13:04 2008 +0300
@@ -171,5 +171,9 @@ random-if(MOZ_WIDGET_TOOLKIT=="cocoa") =
 == rounded-background-color-width-left-4.html rounded-background-color-width-4.html
 == rounded-background-color-width-left-5.html rounded-background-color-width-5.html
 == rounded-background-color-width-left-6.html rounded-background-color-width-6.html
 
 fails-if(MOZ_WIDGET_TOOLKIT=="cocoa") == background-image-tiling.html background-image-tiling-ref.html # probably bug 379317
+
+!= border-image-width-0.html border-image-width-10.html
+== border-image-width-4.html border-image-width-0.html
+== border-image-width-9.html border-image-width-0.html
diff -r 6c8c95fcaf9b layout/reftests/reftest.list
--- a/layout/reftests/reftest.list	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/reftests/reftest.list	Thu Jul 17 14:13:04 2008 +0300
@@ -11,10 +11,13 @@ include reftest-sanity/reftest.list
 # images (if libpr0n is busted, could result in weird failures in other tests)
 include ../../modules/libpr0n/test/reftest/reftest.list
 
 # bidi/
 include bidi/reftest.list
+
+# border-image
+include border-image/reftest.list
 
 # box-properties/
 include box-properties/reftest.list
 
 # box-shadow/
diff -r 6c8c95fcaf9b layout/reftests/svg/filters/reftest.list
--- a/layout/reftests/svg/filters/reftest.list	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/reftests/svg/filters/reftest.list	Thu Jul 17 14:13:04 2008 +0300
@@ -23,11 +23,11 @@
 == feFlood-1.svg feFlood-1-ref.svg
 == feFlood-2.svg feFlood-2-ref.svg
 
 == feGaussianBlur-1.svg feGaussianBlur-1-ref.svg
 == feGaussianBlur-2.svg feGaussianBlur-2-ref.svg
-!= feGaussianBlur-3.svg feGaussianBlur-3-ref.svg
+# != feGaussianBlur-3.svg feGaussianBlur-3-ref.svg
 == feGaussianBlur-4.svg feGaussianBlur-4-ref.svg
 == feGaussianBlur-5.svg feGaussianBlur-5-ref.svg
 == feGaussianBlur-6.svg about:blank
 
 == feImage-1.svg feImage-1-ref.svg
diff -r 6c8c95fcaf9b layout/reftests/svg/reftest.list
--- a/layout/reftests/svg/reftest.list	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/reftests/svg/reftest.list	Thu Jul 17 14:13:04 2008 +0300
@@ -32,11 +32,10 @@ include moz-only/reftest.list
 == fallback-color-02b.svg fallback-color-02-ref.svg
 == fallback-color-03.svg pass.svg
 == filter-basic-01.svg pass.svg
 == filter-basic-02.svg pass.svg
 == filter-basic-03.svg pass.svg
-== filter-foreignObject-01.svg pass.svg
 == foreignObject-01.svg pass.svg
 == foreignObject-ancestor-style-change-01.svg foreignObject-ancestor-style-change-01-ref.svg
 == foreignObject-change-transform-01.svg pass.svg
 == foreignObject-display-01.svg pass.svg
 == foreignObject-move-repaint-01.svg pass.svg
diff -r 6c8c95fcaf9b layout/reftests/text/444656-ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/text/444656-ref.html	Thu Jul 17 14:13:04 2008 +0300
@@ -0,0 +1,14 @@
+<!DOCTYPE html>
+<html>
+ <head>
+  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
+  <title>Test soft hyphen in rtl text</title>
+  <style>
+   p { width: 240px; font-size: 12px; }
+  </style>
+ </head>
+ <body dir="rtl">
+  <p>אבגדהוזחטיכלמנסעפצקרשתאבגדהוזחטיכלמנסעפצקרשת&#x2010;<br>אבגדהוזחטיכלמנסעפצקרשתאבגדהוזחטיכלמנסעפצקרשת&#x2010;<br>אבגדהוזחטיכלמנסעפצקרשתאבגדהוזחטיכלמנסעפצקרשת&#x2010;<br>אבגדהוזחטיכלמנסעפצקרשתאבגדהוזחטיכלמנסעפצקרשת&#x2010;<br>אבגדהוזחטיכלמנסעפצקרשתאבגדהוזחטיכלמנסעפצקרשת&#x2010;<br>אבגדהוזחטיכלמנסעפצקרשתאבגדהוזחטיכלמנסעפצקרשת&#x2010;<br>אבגדהוזחטיכלמנסעפצקרשת</p>
+  </p>
+ </body>
+</html>
\ No newline at end of file
diff -r 6c8c95fcaf9b layout/reftests/text/444656.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/text/444656.html	Thu Jul 17 14:13:04 2008 +0300
@@ -0,0 +1,14 @@
+<!DOCTYPE html>
+<html>
+ <head>
+  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
+  <title>Test soft hyphen in rtl text</title>
+  <style>
+   p { width: 240px; font-size: 12px; }
+  </style>
+ </head>
+ <body dir="rtl">
+  <p>אבגדהוזחטיכלמנסעפצקרשת&shy;אבגדהוזחטיכלמנסעפצקרשת&shy;אבגדהוזחטיכלמנסעפצקרשת&shy;אבגדהוזחטיכלמנסעפצקרשת&shy;אבגדהוזחטיכלמנסעפצקרשת&shy;אבגדהוזחטיכלמנסעפצקרשת&shy;אבגדהוזחטיכלמנסעפצקרשת&shy;אבגדהוזחטיכלמנסעפצקרשת&shy;אבגדהוזחטיכלמנסעפצקרשת&shy;אבגדהוזחטיכלמנסעפצקרשת&shy;אבגדהוזחטיכלמנסעפצקרשת&shy;אבגדהוזחטיכלמנסעפצקרשת&shy;אבגדהוזחטיכלמנסעפצקרשת</p>
+  </p>
+ </body>
+</html>
\ No newline at end of file
diff -r 6c8c95fcaf9b layout/reftests/text/reftest.list
--- a/layout/reftests/text/reftest.list	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/reftests/text/reftest.list	Thu Jul 17 14:13:04 2008 +0300
@@ -6,5 +6,6 @@ random == soft-hyphens-1c.html soft-hyph
 == white-space-1b.html white-space-1-ref.html
 == white-space-2.html white-space-2-ref.html
 == zwnj-01.html zwnj-01-ref.html
 == zwnj-02.html zwnj-02-ref.html
 random-if(MOZ_WIDGET_TOOLKIT=="gtk2") != zwnj-01.html zwnj-02-ref.html # Bad fonts on the tinderbox -- works locally
+random == 444656.html 444656-ref.html # bug 406299
diff -r 6c8c95fcaf9b layout/style/Makefile.in
--- a/layout/style/Makefile.in	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/style/Makefile.in	Thu Jul 17 14:13:04 2008 +0300
@@ -115,10 +115,11 @@ EXPORTS		= \
 		nsStyleContext.h \
 		nsStyleCoord.h \
 		nsStyleSet.h \
 		nsStyleStruct.h \
 		nsStyleStructFwd.h \
+		nsStyleStructInlines.h \
 		nsStyleStructList.h \
 		nsStyleUtil.h \
 		$(NULL)
 
 CPPSRCS		= \
diff -r 6c8c95fcaf9b layout/style/nsCSSDataBlock.cpp
--- a/layout/style/nsCSSDataBlock.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/style/nsCSSDataBlock.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -204,14 +204,24 @@ nsCSSCompressedDataBlock::MapRuleInfoInt
                 case eCSSType_Value: {
                     nsCSSValue* target = static_cast<nsCSSValue*>(prop);
                     if (target->GetUnit() == eCSSUnit_Null) {
                         const nsCSSValue *val = ValueAtCursor(cursor);
                         NS_ASSERTION(val->GetUnit() != eCSSUnit_Null, "oops");
-                        if ((iProp == eCSSProperty_background_image ||
-                             iProp == eCSSProperty_list_style_image) &&
-                            val->GetUnit() == eCSSUnit_URL) {
-                            val->StartImageLoad(aRuleData->mPresContext->Document());
+                        if (iProp == eCSSProperty_background_image ||
+                            iProp == eCSSProperty_list_style_image) {
+                            if (val->GetUnit() == eCSSUnit_URL) {
+                                val->StartImageLoad(
+                                    aRuleData->mPresContext->Document());
+                            }
+                        } else if (iProp == eCSSProperty_border_image) {
+                            if (val->GetUnit() == eCSSUnit_Array) {
+                                nsCSSValue::Array *array = val->GetArrayValue();
+                                if (array->Item(0).GetUnit() == eCSSUnit_URL) {
+                                    array->Item(0).StartImageLoad(
+                                        aRuleData->mPresContext->Document());
+                                }
+                            }
                         }
                         *target = *val;
                         if (iProp == eCSSProperty_font_family) {
                             // XXX Are there other things like this?
                             aRuleData->mFontData->mFamilyFromHTML = PR_FALSE;
diff -r 6c8c95fcaf9b layout/style/nsCSSDeclaration.cpp
--- a/layout/style/nsCSSDeclaration.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/style/nsCSSDeclaration.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -327,10 +327,18 @@ nsCSSDeclaration::AppendCSSValueToString
     }
 
     nsCSSValue::Array *array = aValue.GetArrayValue();
     PRBool mark = PR_FALSE;
     for (PRUint16 i = 0, i_end = array->Count(); i < i_end; ++i) {
+      if (aProperty == eCSSProperty_border_image && i >= 5) {
+        if (array->Item(i).GetUnit() == eCSSUnit_Null) {
+          continue;
+        }
+        if (i == 5) {
+          aResult.AppendLiteral(" /");
+        }
+      }
       if (mark && array->Item(i).GetUnit() != eCSSUnit_Null) {
         if (unit == eCSSUnit_Array)
           aResult.AppendLiteral(" ");
         else
           aResult.AppendLiteral(", ");
diff -r 6c8c95fcaf9b layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/style/nsCSSParser.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -322,10 +322,11 @@ protected:
   PRBool ParseBackgroundPositionValues(nsresult& aErrorCode);
   PRBool ParseBorderColor(nsresult& aErrorCode);
   PRBool ParseBorderColors(nsresult& aErrorCode,
                            nsCSSValueList** aResult,
                            nsCSSProperty aProperty);
+  PRBool ParseBorderImage(nsresult& aErrorCode);
   PRBool ParseBorderSpacing(nsresult& aErrorCode);
   PRBool ParseBorderSide(nsresult& aErrorCode,
                          const nsCSSProperty aPropIDs[],
                          PRBool aSetAllSides);
   PRBool ParseDirectionalBorderSide(nsresult& aErrorCode,
@@ -4437,10 +4438,12 @@ PRBool CSSParserImpl::ParseProperty(nsre
                              aPropID);
   case eCSSProperty_border_top_colors:
     return ParseBorderColors(aErrorCode,
                              &mTempData.mMargin.mBorderColors.mTop,
                              aPropID);
+  case eCSSProperty_border_image:
+    return ParseBorderImage(aErrorCode);
   case eCSSProperty_border_width:
     return ParseBorderWidth(aErrorCode);
   case eCSSProperty_border_end_color:
     return ParseDirectionalBoxProperty(aErrorCode, 
                                        eCSSProperty_border_end_color,
@@ -4650,10 +4653,11 @@ PRBool CSSParserImpl::ParseSingleValuePr
   case eCSSProperty_background:
   case eCSSProperty_background_position:
   case eCSSProperty_border:
   case eCSSProperty_border_color:
   case eCSSProperty_border_bottom_colors:
+  case eCSSProperty_border_image:
   case eCSSProperty_border_left_colors:
   case eCSSProperty_border_right_colors:
   case eCSSProperty_border_end_color:
   case eCSSProperty_border_left_color:
   case eCSSProperty_border_right_color:
@@ -5487,10 +5491,97 @@ PRBool CSSParserImpl::ParseBorderColor(n
   InitBoxPropsAsPhysical(kBorderColorSources);
   return ParseBoxProperties(aErrorCode, mTempData.mMargin.mBorderColor,
                             kBorderColorIDs);
 }
 
+PRBool CSSParserImpl::ParseBorderImage(nsresult& aErrorCode)
+{
+  if (ParseVariant(aErrorCode, mTempData.mMargin.mBorderImage, 
+                   VARIANT_INHERIT | VARIANT_NONE, nsnull)) {
+    mTempData.SetPropertyBit(eCSSProperty_border_image);
+    return PR_TRUE;
+  }
+  
+  // <uri> [<number> | <percentage>]{1,4} [ / <border-width>{1,4} ]? [stretch | repeat | round]{0,2}
+  nsRefPtr<nsCSSValue::Array> arr = nsCSSValue::Array::Create(11);
+  if (!arr) {
+    aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+    return PR_FALSE;
+  }
+  
+  nsCSSValue& url = arr->Item(0);
+  nsCSSValue& splitTop = arr->Item(1);
+  nsCSSValue& splitRight = arr->Item(2);
+  nsCSSValue& splitBottom = arr->Item(3);
+  nsCSSValue& splitLeft = arr->Item(4);
+  nsCSSValue& borderWidthTop = arr->Item(5);
+  nsCSSValue& borderWidthRight = arr->Item(6);
+  nsCSSValue& borderWidthBottom = arr->Item(7);
+  nsCSSValue& borderWidthLeft = arr->Item(8);
+  nsCSSValue& horizontalKeyword = arr->Item(9);
+  nsCSSValue& verticalKeyword = arr->Item(10);
+  
+  // <uri>
+  if (!ParseVariant(aErrorCode, url, VARIANT_URL, nsnull)) {
+    return PR_FALSE;
+  }
+  
+  // [<number> | <percentage>]{1,4}
+  if (!ParsePositiveVariant(aErrorCode, splitTop,
+                            VARIANT_NUMBER | VARIANT_PERCENT, nsnull)) {
+    return PR_FALSE;
+  }
+  if (!ParsePositiveVariant(aErrorCode, splitRight,
+                            VARIANT_NUMBER | VARIANT_PERCENT, nsnull)) {
+    splitRight = splitTop;
+  }
+  if (!ParsePositiveVariant(aErrorCode, splitBottom,
+                            VARIANT_NUMBER | VARIANT_PERCENT, nsnull)) {
+    splitBottom = splitTop;
+  }
+  if (!ParsePositiveVariant(aErrorCode, splitLeft,
+                            VARIANT_NUMBER | VARIANT_PERCENT, nsnull)) {
+    splitLeft = splitRight;
+  }
+  
+  // [ / <border-width>{1,4} ]?
+  if (ExpectSymbol(aErrorCode, '/', PR_TRUE)) {
+    // if have '/', at least one value is required
+    if (!ParsePositiveVariant(aErrorCode, borderWidthTop,
+                              VARIANT_LENGTH, nsnull)) {
+      return PR_FALSE;
+    }
+    if (!ParsePositiveVariant(aErrorCode, borderWidthRight,
+                              VARIANT_LENGTH, nsnull)) {
+      borderWidthRight = borderWidthTop;
+    }
+    if (!ParsePositiveVariant(aErrorCode, borderWidthBottom,
+                              VARIANT_LENGTH, nsnull)) {
+      borderWidthBottom = borderWidthTop;
+    }
+    if (!ParsePositiveVariant(aErrorCode, borderWidthLeft,
+                              VARIANT_LENGTH, nsnull)) {
+      borderWidthLeft = borderWidthRight;
+    }
+  }
+  
+  // [stretch | repeat | round]{0,2}
+  // missing keywords are handled in nsRuleNode::ComputeBorderData()
+  if (ParseEnum(aErrorCode, horizontalKeyword, nsCSSProps::kBorderImageKTable)) {
+    ParseEnum(aErrorCode, verticalKeyword, nsCSSProps::kBorderImageKTable);
+  }
+  
+  if (!ExpectEndProperty(aErrorCode)) {
+    return PR_FALSE;
+  }
+  
+  mTempData.mMargin.mBorderImage.SetArrayValue(arr, eCSSUnit_Array);
+  mTempData.SetPropertyBit(eCSSProperty_border_image);
+  
+  return PR_TRUE;
+}
+
 PRBool CSSParserImpl::ParseBorderSpacing(nsresult& aErrorCode)
 {
   nsCSSValue  xValue;
   if (ParsePositiveVariant(aErrorCode, xValue, VARIANT_HL, nsnull)) {
     if (xValue.IsLengthUnit()) {
diff -r 6c8c95fcaf9b layout/style/nsCSSPropList.h
--- a/layout/style/nsCSSPropList.h	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/style/nsCSSPropList.h	Thu Jul 17 14:13:04 2008 +0300
@@ -302,10 +302,11 @@ CSS_PROP_BORDER(border-end-style-value, 
 #endif
 CSS_PROP_SHORTHAND(-moz-border-end-width, border_end_width, MozBorderEndWidth)
 #ifndef CSS_PROP_LIST_EXCLUDE_INTERNAL
 CSS_PROP_BORDER(border-end-width-value, border_end_width_value, X, Margin, mBorderEndWidth, eCSSType_Value, kBorderWidthKTable)
 #endif
+CSS_PROP_BORDER(-moz-border-image, border_image, MozBorderImage, Margin, mBorderImage, eCSSType_Value, kBorderImageKTable)
 CSS_PROP_SHORTHAND(border-left, border_left, BorderLeft)
 CSS_PROP_SHORTHAND(border-left-color, border_left_color, BorderLeftColor)
 #ifndef CSS_PROP_LIST_EXCLUDE_INTERNAL
 CSS_PROP_BORDER(border-left-color-value, border_left_color_value, X, Margin, mBorderColor.mLeft, eCSSType_Value, kBorderColorKTable)
 CSS_PROP_BORDER(border-left-color-ltr-source, border_left_color_ltr_source, X, Margin, mBorderLeftColorLTRSource, eCSSType_Value, kBoxPropSourceKTable)
diff -r 6c8c95fcaf9b layout/style/nsCSSProps.cpp
--- a/layout/style/nsCSSProps.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/style/nsCSSProps.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -347,10 +347,17 @@ const PRInt32 nsCSSProps::kBorderCollaps
 };
 
 const PRInt32 nsCSSProps::kBorderColorKTable[] = {
   eCSSKeyword_transparent, NS_STYLE_COLOR_TRANSPARENT,
   eCSSKeyword__moz_use_text_color, NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR,
+  eCSSKeyword_UNKNOWN,-1
+};
+
+const PRInt32 nsCSSProps::kBorderImageKTable[] = {
+  eCSSKeyword_stretch, NS_STYLE_BORDER_IMAGE_STRETCH,
+  eCSSKeyword_repeat, NS_STYLE_BORDER_IMAGE_REPEAT,
+  eCSSKeyword_round, NS_STYLE_BORDER_IMAGE_ROUND,
   eCSSKeyword_UNKNOWN,-1
 };
 
 const PRInt32 nsCSSProps::kBorderStyleKTable[] = {
   eCSSKeyword_hidden, NS_STYLE_BORDER_STYLE_HIDDEN,
diff -r 6c8c95fcaf9b layout/style/nsCSSProps.h
--- a/layout/style/nsCSSProps.h	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/style/nsCSSProps.h	Thu Jul 17 14:13:04 2008 +0300
@@ -120,10 +120,11 @@ public:
   static const PRInt32 kBackgroundOriginKTable[];
   static const PRInt32 kBackgroundPositionKTable[];
   static const PRInt32 kBackgroundRepeatKTable[];
   static const PRInt32 kBorderCollapseKTable[];
   static const PRInt32 kBorderColorKTable[];
+  static const PRInt32 kBorderImageKTable[];
   static const PRInt32 kBorderStyleKTable[];
   static const PRInt32 kBorderWidthKTable[];
   static const PRInt32 kBoxAlignKTable[];
   static const PRInt32 kBoxDirectionKTable[];
   static const PRInt32 kBoxOrientKTable[];
diff -r 6c8c95fcaf9b layout/style/nsCSSStruct.h
--- a/layout/style/nsCSSStruct.h	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/style/nsCSSStruct.h	Thu Jul 17 14:13:04 2008 +0300
@@ -352,10 +352,11 @@ struct nsCSSMargin : public nsCSSStruct 
   nsCSSValue  mOutlineColor;
   nsCSSValue  mOutlineStyle;
   nsCSSValue  mOutlineOffset;
   nsCSSRect   mOutlineRadius; // (extension)
   nsCSSValue  mFloatEdge; // NEW
+  nsCSSValue  mBorderImage;
   nsCSSValueList* mBoxShadow;
 private:
   nsCSSMargin(const nsCSSMargin& aOther); // NOT IMPLEMENTED
 };
 
diff -r 6c8c95fcaf9b layout/style/nsComputedDOMStyle.cpp
--- a/layout/style/nsComputedDOMStyle.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/style/nsComputedDOMStyle.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -59,10 +59,11 @@
 #include "nsDOMCSSRect.h"
 #include "nsGkAtoms.h"
 #include "nsHTMLReflowState.h"
 #include "nsThemeConstants.h"
 #include "nsStyleUtil.h"
+#include "nsStyleStructInlines.h"
 
 #include "nsPresContext.h"
 #include "nsIDocument.h"
 
 #include "nsCSSPseudoElements.h"
@@ -2172,10 +2173,97 @@ nsComputedDOMStyle::GetBoxSizing(nsIDOMC
 
   return CallQueryInterface(val, aValue);
 }
 
 nsresult
+nsComputedDOMStyle::GetBorderImage(nsIDOMCSSValue** aValue)
+{
+  const nsStyleBorder* border = GetStyleBorder();
+  
+  // none
+  if (!border->GetBorderImage()) {
+    nsROCSSPrimitiveValue *valNone = GetROCSSPrimitiveValue();
+    NS_ENSURE_TRUE(valNone, NS_ERROR_OUT_OF_MEMORY);
+    valNone->SetIdent(nsGkAtoms::none);
+    return CallQueryInterface(valNone, aValue);
+  }
+  
+  nsDOMCSSValueList *valueList = GetROCSSValueList(PR_FALSE);
+  NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
+  
+  // uri
+  nsROCSSPrimitiveValue *valURI = GetROCSSPrimitiveValue();
+  if (!valURI || !valueList->AppendCSSValue(valURI)) {
+    delete valURI;
+    delete valueList;
+    return NS_ERROR_OUT_OF_MEMORY;
+  }
+  nsCOMPtr<nsIURI> uri;
+  border->GetBorderImage()->GetURI(getter_AddRefs(uri));
+  valURI->SetURI(uri);
+  
+  // four split numbers
+  NS_FOR_CSS_SIDES(side) {
+    nsROCSSPrimitiveValue *valSplit = GetROCSSPrimitiveValue();
+    if (!valSplit || !valueList->AppendCSSValue(valSplit)) {
+      delete valSplit;
+      delete valueList;
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+    SetValueToCoord(valSplit, border->mBorderImageSplit.Get(side), nsnull,
+                    nsnull);
+  }
+  
+  // copy of border-width
+  if (border->mHaveBorderImageWidth) {
+    nsROCSSPrimitiveValue *slash = GetROCSSPrimitiveValue();
+    if (!slash || !valueList->AppendCSSValue(slash)) {
+      delete slash;
+      delete valueList;
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+    slash->SetString(NS_LITERAL_STRING("/"));
+    NS_FOR_CSS_SIDES(side) {
+      nsROCSSPrimitiveValue *borderWidth = GetROCSSPrimitiveValue();
+      if (!borderWidth || !valueList->AppendCSSValue(borderWidth)) {
+        delete borderWidth;
+        delete valueList;
+        return NS_ERROR_OUT_OF_MEMORY;
+      }
+      nscoord width = GetStyleBorder()->mBorderImageWidth.side(side);
+      borderWidth->SetAppUnits(width);
+    }
+  }
+  
+  // first keyword
+  nsROCSSPrimitiveValue *keyword = GetROCSSPrimitiveValue();
+  if (!keyword || !valueList->AppendCSSValue(keyword)) {
+    delete keyword;
+    delete valueList;
+    return NS_ERROR_OUT_OF_MEMORY;
+  }
+  const nsAFlatCString& borderImageIdent =
+            nsCSSProps::ValueToKeyword(GetStyleBorder()->mBorderImageHFill,
+                                       nsCSSProps::kBorderImageKTable);
+  keyword->SetIdent(borderImageIdent);
+  
+  // second keyword
+  nsROCSSPrimitiveValue *keyword2 = GetROCSSPrimitiveValue();
+  if (!keyword2 || !valueList->AppendCSSValue(keyword2)) {
+    delete keyword2;
+    delete valueList;
+    return NS_ERROR_OUT_OF_MEMORY;
+  }
+  const nsAFlatCString& borderImageIdent2 =
+            nsCSSProps::ValueToKeyword(GetStyleBorder()->mBorderImageVFill,
+                                       nsCSSProps::kBorderImageKTable);
+  keyword2->SetIdent(borderImageIdent2);
+  
+  return CallQueryInterface(valueList, aValue);
+}
+
+nsresult
 nsComputedDOMStyle::GetFloatEdge(nsIDOMCSSValue** aValue)
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 
@@ -2804,11 +2892,10 @@ nsComputedDOMStyle::GetRelativeOffset(PR
   PRInt32 sign = 1;
   nsStyleCoord coord = positionData->mOffset.Get(aSide);
 
   NS_ASSERTION(coord.GetUnit() == eStyleUnit_Coord ||
                coord.GetUnit() == eStyleUnit_Percent ||
-               coord.GetUnit() == eStyleUnit_Chars ||
                coord.GetUnit() == eStyleUnit_Auto,
                "Unexpected unit");
   
   if (coord.GetUnit() == eStyleUnit_Auto) {
     coord = positionData->mOffset.Get(NS_OPPOSITE_SIDE(aSide));
@@ -2965,11 +3052,11 @@ nsComputedDOMStyle::GetBorderWidthFor(PR
   nscoord width;
   if (mInnerFrame) {
     FlushPendingReflows();
     width = mInnerFrame->GetUsedBorder().side(aSide);
   } else {
-    width = GetStyleBorder()->GetBorderWidth(aSide);
+    width = GetStyleBorder()->GetActualBorderWidth(aSide);
   }
   val->SetAppUnits(width);
 
   return CallQueryInterface(val, aValue);
 }
@@ -3091,28 +3178,10 @@ nsComputedDOMStyle::SetValueToCoord(nsRO
       NS_ASSERTION(aTable, "Must have table to handle this case");
       aValue->SetIdent(nsCSSProps::ValueToKeyword(aCoord.GetIntValue(),
                                                   aTable));
       break;
       
-    case eStyleUnit_Chars: {
-      // Get a rendering context
-      nsCOMPtr<nsIRenderingContext> cx;
-      nsIFrame* frame = mPresShell->FrameManager()->GetRootFrame();
-      if (frame) {
-        mPresShell->CreateRenderingContext(frame, getter_AddRefs(cx));
-      }
-      if (cx) {
-        nscoord val =
-          nsLayoutUtils::CharsToCoord(aCoord, cx, mStyleContextHolder);
-        aValue->SetAppUnits(PR_MAX(aMinAppUnits, PR_MIN(val, aMaxAppUnits)));
-      } else {
-        // Oh, well.  Give up.
-        aValue->SetAppUnits(0);
-      }
-      break;
-    }
-
     case eStyleUnit_None:
       aValue->SetIdent(nsGkAtoms::none);
       break;
       
     default:
@@ -3128,25 +3197,10 @@ nsComputedDOMStyle::StyleCoordToNSCoord(
 {
   NS_PRECONDITION(aPercentageBaseGetter, "Must have a percentage base getter");
   switch (aCoord.GetUnit()) {
     case eStyleUnit_Coord:
       return aCoord.GetCoordValue();
-    case eStyleUnit_Chars:
-      {
-        // Get a rendering context
-        nsCOMPtr<nsIRenderingContext> cx;
-        nsIFrame* frame = mPresShell->FrameManager()->GetRootFrame();
-        if (frame) {
-          mPresShell->CreateRenderingContext(frame, getter_AddRefs(cx));
-        }
-        if (!cx) {
-          // Return the default value, I guess
-          break;
-        }
-
-        return nsLayoutUtils::CharsToCoord(aCoord, cx, mStyleContextHolder);
-      }
     case eStyleUnit_Percent:
       {
         nscoord percentageBase;
         if ((this->*aPercentageBaseGetter)(percentageBase)) {
           return nscoord(aCoord.GetPercentValue() * percentageBase);
@@ -3886,10 +3940,11 @@ nsComputedDOMStyle::GetQueryableProperty
     COMPUTED_STYLE_MAP_ENTRY(_moz_background_clip,          BackgroundClip),
     COMPUTED_STYLE_MAP_ENTRY(_moz_background_inline_policy, BackgroundInlinePolicy),
     COMPUTED_STYLE_MAP_ENTRY(_moz_background_origin,        BackgroundOrigin),
     COMPUTED_STYLE_MAP_ENTRY(binding,                       Binding),
     COMPUTED_STYLE_MAP_ENTRY(border_bottom_colors,          BorderBottomColors),
+    COMPUTED_STYLE_MAP_ENTRY(border_image,                  BorderImage),
     COMPUTED_STYLE_MAP_ENTRY(border_left_colors,            BorderLeftColors),
     COMPUTED_STYLE_MAP_ENTRY(border_right_colors,           BorderRightColors),
     COMPUTED_STYLE_MAP_ENTRY(border_top_colors,             BorderTopColors),
     COMPUTED_STYLE_MAP_ENTRY(_moz_border_radius_bottomLeft, BorderRadiusBottomLeft),
     COMPUTED_STYLE_MAP_ENTRY(_moz_border_radius_bottomRight,BorderRadiusBottomRight),
diff -r 6c8c95fcaf9b layout/style/nsComputedDOMStyle.h
--- a/layout/style/nsComputedDOMStyle.h	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/style/nsComputedDOMStyle.h	Thu Jul 17 14:13:04 2008 +0300
@@ -196,10 +196,11 @@ private:
   nsresult GetBorderRadiusBottomLeft(nsIDOMCSSValue** aValue);
   nsresult GetBorderRadiusBottomRight(nsIDOMCSSValue** aValue);
   nsresult GetBorderRadiusTopLeft(nsIDOMCSSValue** aValue);
   nsresult GetBorderRadiusTopRight(nsIDOMCSSValue** aValue);
   nsresult GetFloatEdge(nsIDOMCSSValue** aValue);
+  nsresult GetBorderImage(nsIDOMCSSValue** aValue);
 
   /* Box Shadow */
   nsresult GetBoxShadow(nsIDOMCSSValue** aValue);
 
   /* Margin Properties */
diff -r 6c8c95fcaf9b layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/style/nsRuleNode.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -51,11 +51,12 @@
 #include "nscore.h"
 #include "nsIServiceManager.h"
 #include "nsIDeviceContext.h"
 #include "nsILookAndFeel.h"
 #include "nsIPresShell.h"
-#include "nsIFontMetrics.h"
+#include "nsIThebesFontMetrics.h"
+#include "gfxFont.h"
 #include "nsStyleUtil.h"
 #include "nsCSSPseudoElements.h"
 #include "nsThemeConstants.h"
 #include "nsITheme.h"
 #include "pldhash.h"
@@ -65,10 +66,11 @@
 #include "imgIRequest.h"
 #include "nsRuleData.h"
 #include "nsILanguageAtomService.h"
 #include "nsIStyleRule.h"
 #include "nsBidiUtils.h"
+#include "nsStyleStructInlines.h"
 
 /*
  * For storage of an |nsRuleNode|'s children in a PLDHashTable.
  */
 
@@ -188,12 +190,11 @@ static nscoord CalcLengthWith(const nsCS
     // XXX Should this be aStyleFont->mSize instead to avoid taking minfontsize
     // prefs into account?
     aFontSize = aStyleFont->mFont.size;
   }
   switch (unit) {
-    case eCSSUnit_EM:
-    case eCSSUnit_Char: {
+    case eCSSUnit_EM: {
       return NSToCoordRound(aValue.GetFloatValue() * float(aFontSize));
       // XXX scale against font metrics height instead?
     }
     case eCSSUnit_EN: {
       return NSToCoordRound((aValue.GetFloatValue() * float(aFontSize)) / 2.0f);
@@ -208,10 +209,22 @@ static nscoord CalcLengthWith(const nsCS
     }
     case eCSSUnit_CapHeight: {
       NS_NOTYETIMPLEMENTED("cap height unit");
       nscoord capHeight = ((aFontSize / 3) * 2); // XXX HACK!
       return NSToCoordRound(aValue.GetFloatValue() * float(capHeight));
+    }
+    case eCSSUnit_Char: {
+      nsFont font = aStyleFont->mFont;
+      font.size = aFontSize;
+      nsCOMPtr<nsIFontMetrics> fm = aPresContext->GetMetricsFor(font);
+      nsCOMPtr<nsIThebesFontMetrics> tfm(do_QueryInterface(fm));
+      gfxFloat zeroWidth = (tfm->GetThebesFontGroup()->GetFontAt(0)
+                            ->GetMetrics().zeroOrAveCharWidth);
+
+      return NSToCoordRound(aValue.GetFloatValue() *
+                            NS_ceil(aPresContext->AppUnitsPerDevPixel() *
+                                    zeroWidth));
     }
     default:
       NS_NOTREACHED("unexpected unit");
       break;
   }
@@ -265,14 +278,10 @@ static PRBool SetCoord(const nsCSSValue&
 {
   PRBool  result = PR_TRUE;
   if (aValue.GetUnit() == eCSSUnit_Null) {
     result = PR_FALSE;
   }
-  else if (((aMask & SETCOORD_LENGTH) != 0) && 
-           (aValue.GetUnit() == eCSSUnit_Char)) {
-    aCoord.SetIntValue(NSToIntFloor(aValue.GetFloatValue()), eStyleUnit_Chars);
-  } 
   else if (((aMask & SETCOORD_LENGTH) != 0) && 
            aValue.IsLengthUnit()) {
     aCoord.SetCoordValue(CalcLength(aValue, aStyleContext, aPresContext, aInherited));
   }
   else if (((aMask & SETCOORD_PERCENT) != 0) && 
@@ -3756,27 +3765,25 @@ nsRuleNode::ComputeBorderData(void* aSta
                                (mPresContext->GetBorderWidthTable())[value.GetIntValue()]);
       }
       // OK to pass bad aParentCoord since we're not passing SETCOORD_INHERIT
       else if (SetCoord(value, coord, nsStyleCoord(), SETCOORD_LENGTH,
                         aContext, mPresContext, inherited)) {
-        if (coord.GetUnit() == eStyleUnit_Coord) {
-          border->SetBorderWidth(side, coord.GetCoordValue());
-        }
-#ifdef DEBUG
-        else {
-          NS_ASSERTION(coord.GetUnit() == eStyleUnit_Chars, "unexpected unit");
-          NS_WARNING("Border set in chars; we don't handle that");
-        }
-#endif        
+        NS_ASSERTION(coord.GetUnit() == eStyleUnit_Coord, "unexpected unit");
+        border->SetBorderWidth(side, coord.GetCoordValue());
       }
       else if (eCSSUnit_Inherit == value.GetUnit()) {
         inherited = PR_TRUE;
-        border->SetBorderWidth(side, parentBorder->GetBorderWidth(side));
+        border->SetBorderWidth(side,
+                               parentBorder->GetComputedBorder().side(side));
       }
       else if (eCSSUnit_Initial == value.GetUnit()) {
         border->SetBorderWidth(side,
           (mPresContext->GetBorderWidthTable())[NS_STYLE_BORDER_WIDTH_MEDIUM]);
+      }
+      else {
+        NS_ASSERTION(eCSSUnit_Null == value.GetUnit(),
+                     "missing case handling border width");
       }
     }
   }
 
   // border-style, border-*-style: enum, none, inherit
@@ -3909,10 +3916,82 @@ nsRuleNode::ComputeBorderData(void* aSta
     inherited = PR_TRUE;
     border->mFloatEdge = parentBorder->mFloatEdge;
   }
   else if (eCSSUnit_Initial == marginData.mFloatEdge.GetUnit()) {
     border->mFloatEdge = NS_STYLE_FLOAT_EDGE_CONTENT;
+  }
+  
+  // border-image
+  if (eCSSUnit_Array == marginData.mBorderImage.GetUnit()) {
+    nsCSSValue::Array *arr = marginData.mBorderImage.GetArrayValue();
+    
+    // the image
+    if (eCSSUnit_Image == arr->Item(0).GetUnit()) {
+      border->SetBorderImage(arr->Item(0).GetImageValue());
+    }
+    
+    // the numbers saying where to split the image
+    NS_FOR_CSS_SIDES(side) {
+      // an uninitialized parentCoord is ok because I'm not passing SETCOORD_INHERIT
+      if (SetCoord(arr->Item(1 + side), coord, nsStyleCoord(),
+                   SETCOORD_FACTOR | SETCOORD_PERCENT, aContext,
+                   mPresContext, inherited)) {
+        border->mBorderImageSplit.Set(side, coord);
+      }
+    }
+    
+    // possible replacement for border-width
+    // if have one - have all four (see CSSParserImpl::ParseBorderImage())
+    if (eCSSUnit_Null != arr->Item(5).GetUnit()) {
+      NS_FOR_CSS_SIDES(side) {
+        // an uninitialized parentCoord is ok because I'm not passing SETCOORD_INHERIT
+        if (!SetCoord(arr->Item(5 + side), coord, nsStyleCoord(),
+                      SETCOORD_LENGTH, aContext, mPresContext, inherited)) {
+          NS_NOTREACHED("SetCoord for border-width replacement from border-image failed");
+        }
+        if (coord.GetUnit() == eStyleUnit_Coord) {
+          border->SetBorderImageWidthOverride(side, coord.GetCoordValue());
+        } else {
+          NS_WARNING("a border-width replacement from border-image "
+                     "has a unit that's not eStyleUnit_Coord");
+          border->SetBorderImageWidthOverride(side, 0);
+        }
+      }
+      border->mHaveBorderImageWidth = PR_TRUE;
+    } else {
+      border->mHaveBorderImageWidth = PR_FALSE;
+    }
+    
+    // stretch/round/repeat keywords
+    if (eCSSUnit_Null == arr->Item(9).GetUnit()) {
+      // default, both horizontal and vertical are stretch
+      border->mBorderImageHFill = NS_STYLE_BORDER_IMAGE_STRETCH;
+      border->mBorderImageVFill = NS_STYLE_BORDER_IMAGE_STRETCH;
+    } else {
+      // have horizontal value
+      border->mBorderImageHFill = arr->Item(9).GetIntValue();
+      if (eCSSUnit_Null == arr->Item(10).GetUnit()) {
+        // vertical same as horizontal
+        border->mBorderImageVFill = border->mBorderImageHFill;
+      } else {
+        // have vertical value
+        border->mBorderImageVFill = arr->Item(10).GetIntValue();
+      }
+    }
+  } else if (eCSSUnit_None == marginData.mBorderImage.GetUnit() ||
+             eCSSUnit_Initial == marginData.mBorderImage.GetUnit()) {
+    border->mHaveBorderImageWidth = PR_FALSE;
+    border->SetBorderImage(nsnull);
+  } else if (eCSSUnit_Inherit == marginData.mBorderImage.GetUnit()) {
+    NS_FOR_CSS_SIDES(side) {
+      border->SetBorderImageWidthOverride(side, parentBorder->mBorderImageWidth.side(side));
+    }
+    border->mBorderImageSplit = parentBorder->mBorderImageSplit;
+    border->mBorderImageHFill = parentBorder->mBorderImageHFill;
+    border->mBorderImageVFill = parentBorder->mBorderImageVFill;
+    border->mHaveBorderImageWidth = parentBorder->mHaveBorderImageWidth;
+    border->SetBorderImage(parentBorder->GetBorderImage());
   }
 
   COMPUTE_END_RESET(Border, border)
 }
   
diff -r 6c8c95fcaf9b layout/style/nsStyleContext.cpp
--- a/layout/style/nsStyleContext.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/style/nsStyleContext.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -642,14 +642,14 @@ void nsStyleContext::DumpRegressionData(
   const char format [] = "top: %ftw right: %ftw bottom: %ftw left: %ftw";
 #else
   const char format [] = "top: %dtw right: %dtw bottom: %dtw left: %dtw";
 #endif
   nsPrintfCString output(format,
-                         border->GetBorderWidth(NS_SIDE_TOP),
-                         border->GetBorderWidth(NS_SIDE_RIGHT),
-                         border->GetBorderWidth(NS_SIDE_BOTTOM),
-                         border->GetBorderWidth(NS_SIDE_LEFT));
+                         border->GetActualBorderWidth(NS_SIDE_TOP),
+                         border->GetActualBorderWidth(NS_SIDE_RIGHT),
+                         border->GetActualBorderWidth(NS_SIDE_BOTTOM),
+                         border->GetActualBorderWidth(NS_SIDE_LEFT));
   fprintf(out, "%s ", output.get());
   border->mBorderRadius.ToString(str);
   fprintf(out, "%s ", NS_ConvertUTF16toUTF8(str).get());
   
   const nsStyleOutline* outline = GetStyleOutline();
diff -r 6c8c95fcaf9b layout/style/nsStyleCoord.cpp
--- a/layout/style/nsStyleCoord.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/style/nsStyleCoord.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -127,14 +127,12 @@ void nsStyleCoord::SetCoordValue(nscoord
 }
 
 void nsStyleCoord::SetIntValue(PRInt32 aValue, nsStyleUnit aUnit)
 {
   NS_ASSERTION((aUnit == eStyleUnit_Enumerated) ||
-               (aUnit == eStyleUnit_Chars) ||
                (aUnit == eStyleUnit_Integer), "not an int value");
   if ((aUnit == eStyleUnit_Enumerated) ||
-      (aUnit == eStyleUnit_Chars) ||
       (aUnit == eStyleUnit_Integer)) {
     mUnit = aUnit;
     mValue.mInt = aValue;
   }
   else {
@@ -194,11 +192,10 @@ void nsStyleCoord::AppendToString(nsStri
     case eStyleUnit_Normal:       aBuffer.AppendLiteral("Normal");   break;
     case eStyleUnit_Auto:         aBuffer.AppendLiteral("Auto");     break;
     case eStyleUnit_None:         aBuffer.AppendLiteral("None");     break;
     case eStyleUnit_Enumerated:   aBuffer.AppendLiteral("enum");     break;
     case eStyleUnit_Integer:      aBuffer.AppendLiteral("int");      break;
-    case eStyleUnit_Chars:        aBuffer.AppendLiteral("chars");    break;
   }
   aBuffer.Append(PRUnichar(' '));
 }
 
 void nsStyleCoord::ToString(nsString& aBuffer) const
diff -r 6c8c95fcaf9b layout/style/nsStyleCoord.h
--- a/layout/style/nsStyleCoord.h	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/style/nsStyleCoord.h	Thu Jul 17 14:13:04 2008 +0300
@@ -53,12 +53,11 @@ enum nsStyleUnit {
   eStyleUnit_None         = 3,      // (no value)
   eStyleUnit_Percent      = 10,     // (float) 1.0 == 100%
   eStyleUnit_Factor       = 11,     // (float) a multiplier
   eStyleUnit_Coord        = 20,     // (nscoord) value is twips
   eStyleUnit_Integer      = 30,     // (int) value is simple integer
-  eStyleUnit_Enumerated   = 32,     // (int) value has enumerated meaning
-  eStyleUnit_Chars        = 33      // (int) value is number of characters
+  eStyleUnit_Enumerated   = 32      // (int) value has enumerated meaning
 };
 
 typedef union {
   PRInt32     mInt;   // nscoord is a PRInt32 for now
   float       mFloat;
@@ -195,14 +194,12 @@ inline PRInt32 nsStyleCoord::GetCoordVal
 }
 
 inline PRInt32 nsStyleCoord::GetIntValue(void) const
 {
   NS_ASSERTION((mUnit == eStyleUnit_Enumerated) ||
-               (mUnit == eStyleUnit_Chars) ||
                (mUnit == eStyleUnit_Integer), "not an int value");
   if ((mUnit == eStyleUnit_Enumerated) ||
-      (mUnit == eStyleUnit_Chars) ||
       (mUnit == eStyleUnit_Integer)) {
     return mValue.mInt;
   }
   return 0;
 }
diff -r 6c8c95fcaf9b layout/style/nsStyleStruct.cpp
--- a/layout/style/nsStyleStruct.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/style/nsStyleStruct.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -42,10 +42,11 @@
  * structs that contain the data provided by nsStyleContext, the
  * internal API for computed style data for an element
  */
 
 #include "nsStyleStruct.h"
+#include "nsStyleStructInlines.h"
 #include "nsStyleConsts.h"
 #include "nsThemeConstants.h"
 #include "nsString.h"
 #include "nsPresContext.h"
 #include "nsIDeviceContext.h"
@@ -232,14 +233,10 @@ static nscoord CalcCoord(const nsStyleCo
         if ((0 <= value) && (value < aNumEnums)) {
           return aEnumTable[aCoord.GetIntValue()];
         }
       }
       break;
-    case eStyleUnit_Chars:
-      // XXX we need a frame and a rendering context to calculate this, bug 281972, bug 282126.
-      NS_NOTYETIMPLEMENTED("CalcCoord: eStyleUnit_Chars");
-      return 0;
     default:
       NS_ERROR("bad unit type");
       break;
   }
   return 0;
@@ -355,11 +352,13 @@ nsChangeHint nsStylePadding::MaxDifferen
   return NS_STYLE_HINT_REFLOW;
 }
 #endif
 
 nsStyleBorder::nsStyleBorder(nsPresContext* aPresContext)
-  : mActualBorder(0, 0, 0, 0)
+  : mHaveBorderImageWidth(PR_FALSE),
+    mComputedBorder(0, 0, 0, 0),
+    mBorderImage(nsnull)
 {
   nscoord medium =
     (aPresContext->GetBorderWidthTable())[NS_STYLE_BORDER_WIDTH_MEDIUM];
   NS_FOR_CSS_SIDES(side) {
     mBorder.side(side) = medium;
@@ -375,16 +374,22 @@ nsStyleBorder::nsStyleBorder(nsPresConte
 
   mTwipsPerPixel = aPresContext->DevPixelsToAppUnits(1);
 }
 
 nsStyleBorder::nsStyleBorder(const nsStyleBorder& aSrc)
-  : mActualBorder(aSrc.mActualBorder),
-    mTwipsPerPixel(aSrc.mTwipsPerPixel),
+  : mBorderRadius(aSrc.mBorderRadius),
+    mBorderImageSplit(aSrc.mBorderImageSplit),
+    mFloatEdge(aSrc.mFloatEdge),
+    mBorderImageHFill(aSrc.mBorderImageHFill),
+    mBorderImageVFill(aSrc.mBorderImageVFill),
+    mBoxShadow(aSrc.mBoxShadow),
+    mHaveBorderImageWidth(aSrc.mHaveBorderImageWidth),
+    mBorderImageWidth(aSrc.mBorderImageWidth),
+    mComputedBorder(aSrc.mComputedBorder),
     mBorder(aSrc.mBorder),
-    mBorderRadius(aSrc.mBorderRadius),
-    mFloatEdge(aSrc.mFloatEdge),
-    mBoxShadow(aSrc.mBoxShadow)
+    mBorderImage(aSrc.mBorderImage),
+    mTwipsPerPixel(aSrc.mTwipsPerPixel)
 {
   mBorderColors = nsnull;
   if (aSrc.mBorderColors) {
     EnsureBorderColors();
     for (PRInt32 i = 0; i < 4; i++)
@@ -398,10 +403,19 @@ nsStyleBorder::nsStyleBorder(const nsSty
     mBorderStyle[side] = aSrc.mBorderStyle[side];
     mBorderColor[side] = aSrc.mBorderColor[side];
   }
 }
 
+nsStyleBorder::~nsStyleBorder()
+{
+  if (mBorderColors) {
+    for (PRInt32 i = 0; i < 4; i++)
+      delete mBorderColors[i];
+    delete [] mBorderColors;
+  }
+}
+
 void* 
 nsStyleBorder::operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW {
   void* result = aContext->AllocateFromShell(sz);
   if (result)
     memset(result, 0, sz);
@@ -418,11 +432,11 @@ nsChangeHint nsStyleBorder::CalcDifferen
 nsChangeHint nsStyleBorder::CalcDifference(const nsStyleBorder& aOther) const
 {
   // Note that differences in mBorder don't affect rendering (which should only
   // use mComputedBorder), so don't need to be tested for here.
   if (mTwipsPerPixel == aOther.mTwipsPerPixel &&
-      mActualBorder == aOther.mActualBorder && 
+      mComputedBorder == aOther.mComputedBorder && 
       mFloatEdge == aOther.mFloatEdge) {
     // Note that mBorderStyle stores not only the border style but also
     // color-related flags.  Given that we've already done an mComputedBorder
     // comparison, border-style differences can only lead to a VISUAL hint.  So
     // it's OK to just compare the values directly -- if either the actual
@@ -463,10 +477,29 @@ nsChangeHint nsStyleBorder::MaxDifferenc
 nsChangeHint nsStyleBorder::MaxDifference()
 {
   return NS_STYLE_HINT_REFLOW;
 }
 #endif
+
+PRBool
+nsStyleBorder::ImageBorderDiffers() const
+{
+  return mComputedBorder !=
+           (mHaveBorderImageWidth ? mBorderImageWidth : mBorder);
+}
+
+const nsMargin&
+nsStyleBorder::GetActualBorder() const
+{
+  if (IsBorderImageLoaded())
+    if (mHaveBorderImageWidth)
+      return mBorderImageWidth;
+    else
+      return mBorder;
+  else
+    return mComputedBorder;
+}
 
 nsStyleOutline::nsStyleOutline(nsPresContext* aPresContext)
 {
   // spacing values not inherited
   nsStyleCoord zero(0);
diff -r 6c8c95fcaf9b layout/style/nsStyleStruct.h
--- a/layout/style/nsStyleStruct.h	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/style/nsStyleStruct.h	Thu Jul 17 14:13:04 2008 +0300
@@ -20,10 +20,11 @@
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Mats Palmgren <mats.palmgren@bredband.net>
  *   Masayuki Nakano <masayuki@d-toybox.com>
+ *   Rob Arnold <robarnold@mozilla.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
@@ -190,10 +191,11 @@ struct nsStyleBackground {
   }
 
   // We have to take slower codepaths for fixed background attachment,
   // but we don't want to do that when there's no image.
   // Not inline because it uses an nsCOMPtr<imgIRequest>
+  // FIXME: Should be in nsStyleStructInlines.h.
   PRBool HasFixedBackground() const;
 };
 
 #define BORDER_COLOR_TRANSPARENT  0x40
 #define BORDER_COLOR_FOREGROUND   0x20
@@ -397,31 +399,31 @@ class nsCSSShadowArray {
                 PR_MIN(-(tpp), ((l) - ((tpp) / 2)) / (tpp) * (tpp)))
 
 struct nsStyleBorder {
   nsStyleBorder(nsPresContext* aContext);
   nsStyleBorder(const nsStyleBorder& aBorder);
-  ~nsStyleBorder(void) {
-    if (mBorderColors) {
-      for (PRInt32 i = 0; i < 4; i++)
-        delete mBorderColors[i];
-      delete []mBorderColors;
-    }
-  }
+  ~nsStyleBorder();
 
   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW;
   void Destroy(nsPresContext* aContext);
 
   nsChangeHint CalcDifference(const nsStyleBorder& aOther) const;
 #ifdef DEBUG
   static nsChangeHint MaxDifference();
 #endif
+  PRBool ImageBorderDiffers() const;
  
   nsStyleSides  mBorderRadius;    // [reset] length, percent
+  nsStyleSides  mBorderImageSplit; // [reset] integer, percent
   PRUint8       mFloatEdge;       // [reset] see nsStyleConsts.h
+  PRUint8       mBorderImageHFill; // [reset]
+  PRUint8       mBorderImageVFill; // [reset]
   nsBorderColors** mBorderColors; // [reset] multiple levels of color for a border.
   nsRefPtr<nsCSSShadowArray> mBoxShadow; // [reset] NULL for 'none'
-
+  PRBool        mHaveBorderImageWidth; // [reset]
+  nsMargin      mBorderImageWidth; // [reset]
+  
   void EnsureBorderColors() {
     if (!mBorderColors) {
       mBorderColors = new nsBorderColors*[4];
       if (mBorderColors)
         for (PRInt32 i = 0; i < 4; i++)
@@ -436,38 +438,58 @@ struct nsStyleBorder {
     }
   }
 
   // Return whether aStyle is a visible style.  Invisible styles cause
   // the relevant computed border width to be 0.
-  static PRBool IsVisibleStyle(PRUint8 aStyle) {
-    return aStyle != NS_STYLE_BORDER_STYLE_NONE &&
-           aStyle != NS_STYLE_BORDER_STYLE_HIDDEN;
+  // Note that this does *not* consider the effects of 'border-image':
+  // if border-style is none, but there is a loaded border image,
+  // HasVisibleStyle will be false even though there *is* a border.
+  PRBool HasVisibleStyle(PRUint8 aSide)
+  {
+    PRUint8 style = GetBorderStyle(aSide);
+    return (style != NS_STYLE_BORDER_STYLE_NONE &&
+            style != NS_STYLE_BORDER_STYLE_HIDDEN);
   }
 
   // aBorderWidth is in twips
   void SetBorderWidth(PRUint8 aSide, nscoord aBorderWidth)
   {
-    mBorder.side(aSide) = aBorderWidth;
-    if (IsVisibleStyle(GetBorderStyle(aSide))) {
-      mActualBorder.side(aSide) =
-        NS_ROUND_BORDER_TO_PIXELS(aBorderWidth, mTwipsPerPixel);
-    }
+    nscoord roundedWidth =
+      NS_ROUND_BORDER_TO_PIXELS(aBorderWidth, mTwipsPerPixel);
+    mBorder.side(aSide) = roundedWidth;
+    if (HasVisibleStyle(aSide))
+      mComputedBorder.side(aSide) = roundedWidth;
   }
 
-  // Get the actual border, in twips.
-  const nsMargin& GetBorder() const
+  void SetBorderImageWidthOverride(PRUint8 aSide, nscoord aBorderWidth)
   {
-    return mActualBorder;
+    mBorderImageWidth.side(aSide) =
+      NS_ROUND_BORDER_TO_PIXELS(aBorderWidth, mTwipsPerPixel);
+  }
+
+  // Get the actual border, in twips.  (If there is no border-image
+  // loaded, this is the same as GetComputedBorder.  If there is a
+  // border-image loaded, it uses the border-image width overrides if
+  // present, and otherwise mBorder, which is GetComputedBorder without
+  // considering border-style: none.)
+  const nsMargin& GetActualBorder() const;
+  
+  // Get the computed border (plus rounding).  This does consider the
+  // effects of 'border-style: none', but does not consider
+  // 'border-image'.
+  const nsMargin& GetComputedBorder() const
+  {
+    return mComputedBorder;
   }
 
   // Get the actual border width for a particular side, in twips.  Note that
   // this is zero if and only if there is no border to be painted for this
   // side.  That is, this value takes into account the border style and the
   // value is rounded to the nearest device pixel by NS_ROUND_BORDER_TO_PIXELS.
-  nscoord GetBorderWidth(PRUint8 aSide) const
+  nscoord GetActualBorderWidth(PRUint8 aSide) const
   {
-    return mActualBorder.side(aSide);
+    return GetActualBorder().side(aSide);
   }
 
   PRUint8 GetBorderStyle(PRUint8 aSide) const
   {
     NS_ASSERTION(aSide <= NS_SIDE_LEFT, "bad side"); 
@@ -477,17 +499,16 @@ struct nsStyleBorder {
   void SetBorderStyle(PRUint8 aSide, PRUint8 aStyle)
   {
     NS_ASSERTION(aSide <= NS_SIDE_LEFT, "bad side"); 
     mBorderStyle[aSide] &= ~BORDER_STYLE_MASK; 
     mBorderStyle[aSide] |= (aStyle & BORDER_STYLE_MASK);
-    if (IsVisibleStyle(aStyle)) {
-      mActualBorder.side(aSide) =
-        NS_ROUND_BORDER_TO_PIXELS(mBorder.side(aSide), mTwipsPerPixel);
-    } else {
-      mActualBorder.side(aSide) = 0;
-    }
+    mComputedBorder.side(aSide) =
+      (HasVisibleStyle(aSide) ? mBorder.side(aSide) : 0);
   }
+
+  // Defined in nsStyleStructInlines.h
+  inline PRBool IsBorderImageLoaded() const;
 
   void GetBorderColor(PRUint8 aSide, nscolor& aColor,
                       PRBool& aTransparent, PRBool& aForeground) const
   {
     aTransparent = aForeground = PR_FALSE;
@@ -504,10 +525,14 @@ struct nsStyleBorder {
   {
     NS_ASSERTION(aSide <= NS_SIDE_LEFT, "bad side"); 
     mBorderColor[aSide] = aColor; 
     mBorderStyle[aSide] &= ~BORDER_COLOR_SPECIAL;
   }
+
+  // These are defined in nsStyleStructInlines.h
+  inline void SetBorderImage(imgIRequest* aImage);
+  inline imgIRequest* GetBorderImage() const;
 
   void GetCompositeColors(PRInt32 aIndex, nsBorderColors** aColors) const
   {
     if (!mBorderColors)
       *aColors = nsnull;
@@ -543,29 +568,37 @@ struct nsStyleBorder {
     mBorderStyle[aSide] &= ~BORDER_COLOR_SPECIAL;
     mBorderStyle[aSide] |= BORDER_COLOR_FOREGROUND; 
   }
 
 protected:
-  // mActualBorder holds the CSS2.1 actual border-width values.  In
+  // mComputedBorder holds the CSS2.1 computed border-width values.  In
   // particular, these widths take into account the border-style for the
-  // relevant side and the values are rounded to the nearest device pixel.
-  nsMargin      mActualBorder;
+  // relevant side and the values are rounded to the nearest device
+  // pixel.  They are also rounded (which is not part of the definition
+  // of computed values).  However, they do *not* take into account the
+  // presence of border-image.  See GetActualBorder above for how to
+  // really get the actual border.
+  nsMargin      mComputedBorder;
 
   // mBorder holds the nscoord values for the border widths as they would be if
   // all the border-style values were visible (not hidden or none).  This
-  // member exists solely so that when we create structs using the copy
+  // member exists so that when we create structs using the copy
   // constructor during style resolution the new structs will know what the
   // specified values of the border were in case they have more specific rules
   // setting the border style.  Note that this isn't quite the CSS specified
   // value, since this has had the enumerated border widths converted to
   // lengths, and all lengths converted to twips.  But it's not quite the
-  // computed value either.
+  // computed value either. The values are rounded to the nearest device pixel
+  // We also use these values when we have a loaded border-image that
+  // does not have width overrides.
   nsMargin      mBorder;
 
   PRUint8       mBorderStyle[4];  // [reset] See nsStyleConsts.h
   nscolor       mBorderColor[4];  // [reset] the colors to use for a simple border.  not used
                                   // if -moz-border-colors is specified
+
+  nsCOMPtr<imgIRequest> mBorderImage; // [reset]
 
   nscoord       mTwipsPerPixel;
 };
 
 
@@ -602,11 +635,11 @@ struct nsStyleOutline {
     if (mOutlineOffset.GetUnit() == eStyleUnit_Coord) {
       nscoord offset = mOutlineOffset.GetCoordValue();
       aOffset = NS_ROUND_OFFSET_TO_PIXELS(offset, mTwipsPerPixel);
       return PR_TRUE;
     } else {
-      NS_NOTYETIMPLEMENTED("GetOutlineOffset: eStyleUnit_Chars");
+      NS_ERROR("GetOutlineOffset: bad unit type");
       aOffset = 0;
       return PR_FALSE;
     }
   }
 
diff -r 6c8c95fcaf9b layout/style/nsStyleStructInlines.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/style/nsStyleStructInlines.h	Thu Jul 17 14:13:04 2008 +0300
@@ -0,0 +1,70 @@
+/* vim: set shiftwidth=2 tabstop=8 autoindent cindent expandtab: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is nsStyleStructInlines.h.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation (original author)
+ *   Rob Arnold <robarnold@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/*
+ * Inline methods that belong in nsStyleStruct.h, except that they
+ * require more headers.
+ */
+
+#ifndef nsStyleStructInlines_h_
+#define nsStyleStructInlines_h_
+
+#include "nsStyleStruct.h"
+#include "imgIRequest.h"
+
+inline void
+nsStyleBorder::SetBorderImage(imgIRequest* aImage)
+{
+  mBorderImage = aImage;
+}
+
+inline imgIRequest*
+nsStyleBorder::GetBorderImage() const
+{
+  return mBorderImage;
+}
+
+inline PRBool nsStyleBorder::IsBorderImageLoaded() const
+{
+  PRUint32 status;
+  return mBorderImage &&
+         NS_SUCCEEDED(mBorderImage->GetImageStatus(&status)) &&
+         (status & imgIRequest::STATUS_FRAME_COMPLETE);
+}
+
+#endif /* !defined(nsStyleStructInlines_h_) */
diff -r 6c8c95fcaf9b layout/style/test/property_database.js
--- a/layout/style/test/property_database.js	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/style/test/property_database.js	Thu Jul 17 14:13:04 2008 +0300
@@ -146,10 +146,27 @@ var gCSSProperties = {
 		get_computed: logical_box_prop_get_computed,
 		prerequisites: { "-moz-border-end-style": "solid" },
 		initial_values: [ "medium", "3px" ],
 		other_values: [ "thin", "thick", "1px", "2em" ],
 		invalid_values: [ "5%" ]
+	},
+	"-moz-border-image": {
+		domProp: "MozBorderImage",
+		inherited: false,
+		type: CSS_TYPE_LONGHAND,
+		initial_values: [ "none" ],
+		other_values: [ "url('border.png') 27 27 27 27",
+		                "url('border.png') 27",
+		                "url('border.png') 27 27 27 27 repeat",
+		                "url('border.png') 27 27 27 27 / 1em",
+		                "url('border.png') 27 27 27 27 / 1em 1em 1em 1em repeat",
+		                "url('border.png') 27 27 27 27 / 1em 1em 1em 1em stretch round" ],
+		invalid_values: [ "url('border.png')",
+		                  "url('border.png') 27 27 27 27 27",
+		                  "url('border.png') 27 27 27 27 / 1em 1em 1em 1em 1em",
+		                  "url('border.png') / repeat",
+		                  "url('border.png') 27 27 27 27 /" ]
 	},
 	"-moz-border-left-colors": {
 		domProp: "MozBorderLeftColors",
 		inherited: false,
 		type: CSS_TYPE_LONGHAND,
diff -r 6c8c95fcaf9b layout/style/test/test_value_storage.html
--- a/layout/style/test/test_value_storage.html	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/style/test/test_value_storage.html	Thu Jul 17 14:13:04 2008 +0300
@@ -197,18 +197,18 @@ function test_property(property)
     if (test_computed && "subproperties" in info)
       for (idx in info.subproperties)
         step1comps.push(gComputedStyle.getPropertyValue(info.subproperties[idx]));
 
     func = xfail_accepted(property, value) ? todo_isnot : isnot;
-    func(step1val, "", "setting '" + value + "' on '" + property);
+    func(step1val, "", "setting '" + value + "' on '" + property + "'");
     if ("subproperties" in info)
       for (idx in info.subproperties) {
         var subprop = info.subproperties[idx];
         func = xfail_accepted_split(property, subprop, value)
                  ? todo_isnot : isnot;
         func(gDeclaration.getPropertyValue(subprop), "",
-             "setting '" + value + "' on '" + property);
+             "setting '" + value + "' on '" + property + "'");
       }
 
     // We don't care particularly about the whitespace or the placement of
     // semicolons, but for simplicity we'll test the current behavior.
     func = xfail_ser_val(property, value) ? todo_is : is;
diff -r 6c8c95fcaf9b layout/svg/base/src/nsSVGFilterInstance.cpp
--- a/layout/svg/base/src/nsSVGFilterInstance.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/svg/base/src/nsSVGFilterInstance.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -35,10 +35,11 @@
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsSVGFilterInstance.h"
 #include "nsSVGUtils.h"
 #include "nsIDOMSVGUnitTypes.h"
+#include "gfxContext.h"
 
 static double Square(double aX)
 {
   return aX*aX;
 }
@@ -94,11 +95,11 @@ void
 void
 nsSVGFilterInstance::ComputeFilterPrimitiveSubregion(PrimitiveInfo* aPrimitive)
 {
   nsSVGFE* fE = aPrimitive->mFE;
 
-  gfxRect defaultFilterSubregion;
+  gfxRect defaultFilterSubregion(0,0,0,0);
   if (fE->SubregionIsUnionOfRegions()) {
     for (PRUint32 i = 0; i < aPrimitive->mInputs.Length(); ++i) {
       defaultFilterSubregion = 
           defaultFilterSubregion.Union(
               aPrimitive->mInputs[i]->mImage.mFilterPrimitiveSubregion);
@@ -315,11 +316,12 @@ nsSVGFilterInstance::BuildSourceImages()
 
   nsRefPtr<gfxImageSurface> sourceColorAlpha = CreateImage();
   if (!sourceColorAlpha)
     return NS_ERROR_OUT_OF_MEMORY;
 
-  nsSVGRenderState tmpState(sourceColorAlpha);
+  gfxContext tmpContext(sourceColorAlpha);
+  nsSVGRenderState tmpState(&tmpContext);
   nsresult rv = mTargetFrame->PaintSVG(&tmpState, nsnull);
   if (NS_FAILED(rv))
     return rv;
 
   if (!mSourceColorAlpha.mResultNeededBox.IsEmpty()) {
diff -r 6c8c95fcaf9b layout/svg/base/src/nsSVGForeignObjectFrame.cpp
--- a/layout/svg/base/src/nsSVGForeignObjectFrame.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/svg/base/src/nsSVGForeignObjectFrame.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -263,11 +263,11 @@ nsSVGForeignObjectFrame::PaintSVG(nsSVGR
   nsCOMPtr<nsIDOMSVGMatrix> tm;
   localTM->Multiply(cssPxToDevPxMatrix, getter_AddRefs(tm));
 
   gfxMatrix matrix = nsSVGUtils::ConvertSVGMatrixToThebes(tm);
 
-  nsIRenderingContext *ctx = aContext->GetRenderingContext(this);
+  nsIRenderingContext *ctx = aContext->GetRenderingContext();
 
   if (!ctx || matrix.IsSingular()) {
     NS_WARNING("Can't render foreignObject element!");
     return NS_ERROR_FAILURE;
   }
diff -r 6c8c95fcaf9b layout/svg/base/src/nsSVGPatternFrame.cpp
--- a/layout/svg/base/src/nsSVGPatternFrame.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/svg/base/src/nsSVGPatternFrame.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -319,21 +319,21 @@ nsSVGPatternFrame::PaintPattern(gfxASurf
     gfxPlatform::GetPlatform()->CreateOffscreenSurface(surfaceSize,
                                                        gfxASurface::ImageFormatARGB32);
   if (!tmpSurface || tmpSurface->CairoStatus())
     return NS_ERROR_FAILURE;
 
-  nsSVGRenderState tmpState(tmpSurface);
-  gfxContext* tmpContext = tmpState.GetGfxContext();
+  gfxContext tmpContext(tmpSurface);
+  nsSVGRenderState tmpState(&tmpContext);
 
   // Fill with transparent black
-  tmpContext->SetOperator(gfxContext::OPERATOR_CLEAR);
-  tmpContext->Paint();
-  tmpContext->SetOperator(gfxContext::OPERATOR_OVER);
+  tmpContext.SetOperator(gfxContext::OPERATOR_CLEAR);
+  tmpContext.Paint();
+  tmpContext.SetOperator(gfxContext::OPERATOR_OVER);
 
   if (aGraphicOpacity != 1.0f) {
-    tmpContext->Save();
-    tmpContext->PushGroup(gfxASurface::CONTENT_COLOR_ALPHA);
+    tmpContext.Save();
+    tmpContext.PushGroup(gfxASurface::CONTENT_COLOR_ALPHA);
   }
 
   // OK, now render -- note that we use "firstKid", which
   // we got at the beginning because it takes care of the
   // referenced pattern situation for us
@@ -346,13 +346,13 @@ nsSVGPatternFrame::PaintPattern(gfxASurf
     nsSVGUtils::PaintChildWithEffects(&tmpState, nsnull, kid);
   }
   mSource = nsnull;
 
   if (aGraphicOpacity != 1.0f) {
-    tmpContext->PopGroupToSource();
-    tmpContext->Paint(aGraphicOpacity);
-    tmpContext->Restore();
+    tmpContext.PopGroupToSource();
+    tmpContext.Paint(aGraphicOpacity);
+    tmpContext.Restore();
   }
 
   // caller now owns the surface
   tmpSurface.swap(*surface);
   return NS_OK;
diff -r 6c8c95fcaf9b layout/svg/base/src/nsSVGUtils.cpp
--- a/layout/svg/base/src/nsSVGUtils.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/svg/base/src/nsSVGUtils.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -942,12 +942,12 @@ nsSVGUtils::NotifyAncestorsOfFilterRegio
     }
     aFrame = aFrame->GetParent();
   }
 }
 
-float
-nsSVGUtils::ComputeNormalizedHypotenuse(float aWidth, float aHeight)
+double
+nsSVGUtils::ComputeNormalizedHypotenuse(double aWidth, double aHeight)
 {
   return sqrt((aWidth*aWidth + aHeight*aHeight)/2);
 }
 
 float
@@ -965,11 +965,11 @@ nsSVGUtils::ObjectSpace(nsIDOMSVGRect *a
   case XY:
   {
     float width, height;
     aRect->GetWidth(&width);
     aRect->GetHeight(&height);
-    axis = ComputeNormalizedHypotenuse(width, height);
+    axis = float(ComputeNormalizedHypotenuse(width, height));
   }
   }
 
   if (aLength->IsPercentage()) {
     fraction = aLength->GetAnimValInSpecifiedUnits() / 100;
@@ -1811,21 +1811,9 @@ nsSVGRenderState::nsSVGRenderState(nsIRe
   mRenderMode(NORMAL), mRenderingContext(aContext)
 {
   mGfxContext = aContext->ThebesContext();
 }
 
-nsSVGRenderState::nsSVGRenderState(gfxASurface *aSurface) :
-  mRenderMode(NORMAL)
+nsSVGRenderState::nsSVGRenderState(gfxContext *aContext) :
+  mRenderMode(NORMAL), mRenderingContext(nsnull), mGfxContext(aContext)
 {
-  mGfxContext = new gfxContext(aSurface);
 }
-
-nsIRenderingContext*
-nsSVGRenderState::GetRenderingContext(nsIFrame *aFrame)
-{
-  if (!mRenderingContext) {
-    nsIDeviceContext* devCtx = aFrame->PresContext()->DeviceContext();
-    devCtx->CreateRenderingContextInstance(*getter_AddRefs(mRenderingContext));
-    mRenderingContext->Init(devCtx, mGfxContext);
-  }
-  return mRenderingContext;
-}
diff -r 6c8c95fcaf9b layout/svg/base/src/nsSVGUtils.h
--- a/layout/svg/base/src/nsSVGUtils.h	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/svg/base/src/nsSVGUtils.h	Thu Jul 17 14:13:04 2008 +0300
@@ -43,12 +43,10 @@
 
 #include "nscore.h"
 #include "nsCOMPtr.h"
 #include "nsISVGValue.h"
 #include "nsRect.h"
-#include "gfxContext.h"
-#include "nsIRenderingContext.h"
 
 class nsIDocument;
 class nsPresContext;
 class nsIContent;
 class nsStyleCoord;
@@ -67,12 +65,14 @@ class nsIAtom;
 class nsIAtom;
 class nsSVGLength2;
 class nsSVGElement;
 class nsSVGSVGElement;
 class nsAttrValue;
+class gfxContext;
 class gfxASurface;
 class gfxPattern;
+class nsIRenderingContext;
 class gfxImageSurface;
 struct gfxRect;
 struct gfxMatrix;
 struct gfxSize;
 struct gfxIntSize;
@@ -136,29 +136,23 @@ class nsSVGRenderState
 class nsSVGRenderState
 {
 public:
   enum RenderMode { NORMAL, CLIP, CLIP_MASK };
 
-  /**
-   * Render SVG to a legacy rendering context
-   */
   nsSVGRenderState(nsIRenderingContext *aContext);
-  /**
-   * Render SVG to a temporary surface
-   */
-  nsSVGRenderState(gfxASurface *aSurface);
+  nsSVGRenderState(gfxContext *aContext);
 
-  nsIRenderingContext *GetRenderingContext(nsIFrame *aFrame);
+  nsIRenderingContext *GetRenderingContext() { return mRenderingContext; }
   gfxContext *GetGfxContext() { return mGfxContext; }
 
   void SetRenderMode(RenderMode aMode) { mRenderMode = aMode; }
   RenderMode GetRenderMode() { return mRenderMode; }
 
 private:
-  RenderMode                    mRenderMode;
-  nsCOMPtr<nsIRenderingContext> mRenderingContext;
-  nsRefPtr<gfxContext>          mGfxContext;
+  RenderMode           mRenderMode;
+  nsIRenderingContext *mRenderingContext;
+  gfxContext          *mGfxContext;
 };
 
 class nsAutoSVGRenderMode
 {
 public:
@@ -290,11 +284,11 @@ public:
   enum ctxDirection { X, Y, XY };
 
   /**
    * Computes sqrt((aWidth^2 + aHeight^2)/2);
    */
-  static float ComputeNormalizedHypotenuse(float aWidth, float aHeight);
+  static double ComputeNormalizedHypotenuse(double aWidth, double aHeight);
 
   /* Computes the input length in terms of object space coordinates.
      Input: rect - bounding box
             length - length to be converted
   */
diff -r 6c8c95fcaf9b layout/tables/BasicTableLayoutStrategy.cpp
--- a/layout/tables/BasicTableLayoutStrategy.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/tables/BasicTableLayoutStrategy.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -119,11 +119,11 @@ GetWidthInfo(nsIRenderingContext *aRende
     PRBool hasSpecifiedWidth = PR_FALSE;
 
     // XXXldb Should we consider -moz-box-sizing?
 
     nsStyleUnit unit = aStylePos->mWidth.GetUnit();
-    if (unit == eStyleUnit_Coord || unit == eStyleUnit_Chars) {
+    if (unit == eStyleUnit_Coord) {
         hasSpecifiedWidth = PR_TRUE;
         nscoord w = nsLayoutUtils::ComputeWidthValue(aRenderingContext,
                       aFrame, 0, 0, 0, aStylePos->mWidth);
         // Quirk: A cell with "nowrap" set and a coord value for the
         // width which is bigger than the intrinsic minimum width uses
@@ -169,12 +169,11 @@ GetWidthInfo(nsIRenderingContext *aRende
                                  eStyleUnit_Enumerated);
     }
     unit = maxWidth.GetUnit();
     // XXX To really implement 'max-width' well, we'd need to store
     // it separately on the columns.
-    if (unit == eStyleUnit_Coord || unit == eStyleUnit_Chars ||
-        unit == eStyleUnit_Enumerated) {
+    if (unit == eStyleUnit_Coord || unit == eStyleUnit_Enumerated) {
         nscoord w =
             nsLayoutUtils::ComputeWidthValue(aRenderingContext, aFrame,
                                              0, 0, 0, maxWidth);
         if (w < minCoord)
             minCoord = w;
@@ -195,12 +194,11 @@ GetWidthInfo(nsIRenderingContext *aRende
             // '-moz-min-content'
             minWidth.SetIntValue(NS_STYLE_WIDTH_MIN_CONTENT,
                                  eStyleUnit_Enumerated);
     }
     unit = minWidth.GetUnit();
-    if (unit == eStyleUnit_Coord || unit == eStyleUnit_Chars ||
-        unit == eStyleUnit_Enumerated) {
+    if (unit == eStyleUnit_Coord || unit == eStyleUnit_Enumerated) {
         nscoord w =
             nsLayoutUtils::ComputeWidthValue(aRenderingContext, aFrame,
                                              0, 0, 0, minWidth);
         if (w > minCoord)
             minCoord = w;
diff -r 6c8c95fcaf9b layout/tables/FixedTableLayoutStrategy.cpp
--- a/layout/tables/FixedTableLayoutStrategy.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/tables/FixedTableLayoutStrategy.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -96,12 +96,11 @@ FixedTableLayoutStrategy::GetMinWidth(ns
             NS_ERROR("column frames out of sync with cell map");
             continue;
         }
         const nsStyleCoord *styleWidth =
             &colFrame->GetStylePosition()->mWidth;
-        if (styleWidth->GetUnit() == eStyleUnit_Coord ||
-            styleWidth->GetUnit() == eStyleUnit_Chars) {
+        if (styleWidth->GetUnit() == eStyleUnit_Coord) {
             result += nsLayoutUtils::ComputeWidthValue(aRenderingContext,
                         colFrame, 0, 0, 0, *styleWidth);
         } else if (styleWidth->GetUnit() == eStyleUnit_Percent) {
             // do nothing
         } else {
@@ -116,11 +115,10 @@ FixedTableLayoutStrategy::GetMinWidth(ns
             nsTableCellFrame *cellFrame =
                 cellMap->GetCellInfoAt(0, col, &originates, &colSpan);
             if (cellFrame) {
                 styleWidth = &cellFrame->GetStylePosition()->mWidth;
                 if (styleWidth->GetUnit() == eStyleUnit_Coord ||
-                    styleWidth->GetUnit() == eStyleUnit_Chars ||
                     (styleWidth->GetUnit() == eStyleUnit_Enumerated &&
                      (styleWidth->GetIntValue() == NS_STYLE_WIDTH_MAX_CONTENT ||
                       styleWidth->GetIntValue() == NS_STYLE_WIDTH_MIN_CONTENT))) {
                     nscoord cellWidth = nsLayoutUtils::IntrinsicForContainer(
                         aRenderingContext, cellFrame, nsLayoutUtils::MIN_WIDTH);
@@ -214,12 +212,11 @@ FixedTableLayoutStrategy::ComputeColumnW
         }
         colFrame->ResetPrefPercent();
         const nsStyleCoord *styleWidth =
             &colFrame->GetStylePosition()->mWidth;
         nscoord colWidth;
-        if (styleWidth->GetUnit() == eStyleUnit_Coord ||
-            styleWidth->GetUnit() == eStyleUnit_Chars) {
+        if (styleWidth->GetUnit() == eStyleUnit_Coord) {
             colWidth = nsLayoutUtils::ComputeWidthValue(
                          aReflowState.rendContext,
                          colFrame, 0, 0, 0, *styleWidth);
         } else if (styleWidth->GetUnit() == eStyleUnit_Percent) {
             float pct = styleWidth->GetPercentValue();
@@ -238,11 +235,10 @@ FixedTableLayoutStrategy::ComputeColumnW
             nsTableCellFrame *cellFrame =
                 cellMap->GetCellInfoAt(0, col, &originates, &colSpan);
             if (cellFrame) {
                 styleWidth = &cellFrame->GetStylePosition()->mWidth;
                 if (styleWidth->GetUnit() == eStyleUnit_Coord ||
-                    styleWidth->GetUnit() == eStyleUnit_Chars ||
                     (styleWidth->GetUnit() == eStyleUnit_Enumerated &&
                      (styleWidth->GetIntValue() == NS_STYLE_WIDTH_MAX_CONTENT ||
                       styleWidth->GetIntValue() == NS_STYLE_WIDTH_MIN_CONTENT))) {
                     // XXX This should use real percentage padding
                     // Note that the difference between MIN_WIDTH and
diff -r 6c8c95fcaf9b layout/tables/celldata.h
--- a/layout/tables/celldata.h	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/tables/celldata.h	Thu Jul 17 14:13:04 2008 +0300
@@ -41,10 +41,14 @@
 #include "nsCoord.h"
 
 class nsTableCellFrame;
 class nsCellMap;
 class BCCellData;
+
+
+#define MAX_ROWSPAN 8190 // the cellmap can not handle more
+#define MAX_COLSPAN 1000 // limit as IE and opera do
 
 /** 
   * Data stored by nsCellMap to rationalize rowspan and colspan cells.
   */
 class CellData
diff -r 6c8c95fcaf9b layout/tables/nsTableCellFrame.cpp
--- a/layout/tables/nsTableCellFrame.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/tables/nsTableCellFrame.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -1038,11 +1038,11 @@ NS_NewTableCellFrame(nsIPresShell*   aPr
 }
 
 nsMargin* 
 nsTableCellFrame::GetBorderWidth(nsMargin&  aBorder) const
 {
-  aBorder = GetStyleBorder()->GetBorder();
+  aBorder = GetStyleBorder()->GetActualBorder();
   return &aBorder;
 }
 
 nsIAtom*
 nsTableCellFrame::GetType() const
diff -r 6c8c95fcaf9b layout/tables/nsTableFrame.cpp
--- a/layout/tables/nsTableFrame.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/tables/nsTableFrame.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -2544,11 +2544,11 @@ void GetSeparateModelBorderPadding(const
 {
   // XXXbz Either we _do_ have a reflow state and then we can use its
   // mComputedBorderPadding or we don't and then we get the padding
   // wrong!
   const nsStyleBorder* border = aStyleContext.GetStyleBorder();
-  aBorderPadding = border->GetBorder();
+  aBorderPadding = border->GetActualBorder();
   if (aReflowState) {
     aBorderPadding += aReflowState->mComputedPadding;
   }
 }
 
@@ -4646,11 +4646,11 @@ GetColorAndStyle(const nsIFrame*  aFrame
     }
     else if (NS_SIDE_LEFT == aSide) {
       aSide = NS_SIDE_RIGHT;
     }
   }
-  width = styleData->GetBorderWidth(aSide);
+  width = styleData->GetActualBorderWidth(aSide);
   aWidth = nsPresContext::AppUnitsToIntCSSPixels(width);
 }
  
  
 /* BCCellBorder represents a border segment which can be either a horizontal
diff -r 6c8c95fcaf9b layout/tools/reftest/README.txt
--- a/layout/tools/reftest/README.txt	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/tools/reftest/README.txt	Thu Jul 17 14:13:04 2008 +0300
@@ -159,10 +159,15 @@ that do not depend on XUL, or even ones 
 that do not depend on XUL, or even ones testing other layout engines.
 
 Running Tests
 =============
 
+(If you're not using a DEBUG build, first set browser.dom.window.dump.enabled
+to true (in about:config, in the profile you'll be using to run the tests).
+Create the option as a new boolean if it doesn't exist already. If you skip
+this step you won't get any output in the terminal.)
+
 At some point in the future there will hopefully be a cleaner way to do
 this.  For now, go to your object directory, and run (perhaps using
 MOZ_NO_REMOTE=1 or the -profile <directory> option)
 
 ./firefox -reftest /path/to/srcdir/mozilla/layout/reftests/reftest.list > reftest.out
diff -r 6c8c95fcaf9b layout/tools/reftest/clean-reftest-output.pl
--- a/layout/tools/reftest/clean-reftest-output.pl	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/tools/reftest/clean-reftest-output.pl	Thu Jul 17 14:13:04 2008 +0300
@@ -54,11 +54,11 @@ EOM
 
 while (<>) {
     next unless /REFTEST/;
     chomp;
     chop if /\r$/;
-    s,(PASS|FAIL)([^:]*):( \(!=\))? (.*),\1\2:\3 <a href="\4">\4</a>,;
+    s,(TEST-)([^\|]*) \| ([^\|]*) \|(.*),\1\2: <a href="\3">\3</a>\4,;
     s,(IMAGE[^:]*): (data:.*),<a href="\2">\1</a>,;
     print;
     print "\n";
 }
 
diff -r 6c8c95fcaf9b layout/tools/reftest/reftest-analyzer.xhtml
--- a/layout/tools/reftest/reftest-analyzer.xhtml	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/tools/reftest/reftest-analyzer.xhtml	Thu Jul 17 14:13:04 2008 +0300
@@ -139,21 +139,22 @@ function process_log(contents) {
 		var line = lines[j];
 		var match = line.match(/^REFTEST (.*)$/);
 		if (!match)
 			continue;
 		line = match[1];
-		match = line.match(/^(PASS|UNEXPECTED PASS|KNOWN FAIL|UNEXPECTED FAIL)( \(RESULT EXPECTED TO BE RANDOM\)| \(SKIP\)|): (.*)/);
+		match = line.match(/^(TEST-PASS|TEST-UNEXPECTED-PASS|TEST-KNOWN-FAIL|TEST-UNEXPECTED-FAIL)(\(EXPECTED RANDOM\)|) \| ([^\|]+) \|(.*)/);
 		if (match) {
 			var state = match[1];
-			var extra = match[2];
+			var random = match[2];
 			var url = match[3];
+                        var extra = match[4];
 			gTestItems.push(
 				{
 					pass: !state.match(/FAIL$/),
 					// only one of the following three should ever be true
-					unexpected: !!state.match(/^UNEXPECTED/),
-					random: (extra == " (RESULT EXPECTED TO BE RANDOM)"),
+					unexpected: !!state.match(/^TEST-UNEXPECTED/),
+					random: (random == "(EXPECTED RANDOM)"),
 					skip: (extra == " (SKIP)"),
 					url: url,
 					images: []
 				});
 			continue;
diff -r 6c8c95fcaf9b layout/tools/reftest/reftest-to-html.pl
--- a/layout/tools/reftest/reftest-to-html.pl	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/tools/reftest/reftest-to-html.pl	Thu Jul 17 14:13:04 2008 +0300
@@ -96,19 +96,19 @@ while (<>) {
   chop if /\r$/;
 
   s/^REFTEST *//;
 
   my $randomresult = 0;
-  if (/RESULT EXPECTED TO BE RANDOM/) {
-    s/\(RESULT EXPECTED TO BE RANDOM\) //;
+  if (/EXPECTED RANDOM/) {
+    s/\(EXPECTED RANDOM\)//;
     $randomresult = 1;
   }
 
-  if (/^PASS(.*)$/) {
+  if (/^TEST-PASS \| (.*)$/) {
     my $class = $randomresult ? "PASSRANDOM" : "PASS";
     print '<tr><td class="' . $class . '">' . do_html($1) . "</td></tr>\n";
-  } elsif (/^UNEXPECTED (....): (.*)$/) {
+  } elsif (/^TEST-UNEXPECTED-(....) \| (.*)$/) {
     if ($randomresult) {
       die "Error on line $l: UNEXPECTED with test marked random?!";
     }
     my $class = ($1 eq "PASS") ? "WEIRDPASS" : "FAIL";
     print '<tr><td class="' . $class . '">' . do_html($2) . "</td></tr>\n";
@@ -131,11 +131,11 @@ while (<>) {
     } else {
       die "Error on line $l";
     }
 
     print "</td></tr>\n";
-  } elsif (/^KNOWN FAIL(.*$)/) {
+  } elsif (/^TEST-KNOWN-FAIL \| (.*$)/) {
     my $class = $randomresult ? "XFAILRANDOM" : "XFAIL";
     print '<tr><td class="' . $class . '">' . do_html($1) . "</td></tr>\n";
   } else {
     print STDERR "Unknown Line: " . $_ . "\n";
     print "<tr><td><pre>" . $_ . "</pre></td></tr>\n";
diff -r 6c8c95fcaf9b layout/tools/reftest/reftest.js
--- a/layout/tools/reftest/reftest.js	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/tools/reftest/reftest.js	Thu Jul 17 14:13:04 2008 +0300
@@ -108,11 +108,11 @@ function OnRefTestLoad()
             gServer.start(HTTP_SERVER_PORT);
         }
         StartCurrentTest();
     } catch (ex) {
         //gBrowser.loadURI('data:text/plain,' + ex);
-        dump("REFTEST EXCEPTION: " + ex + "\n");
+        dump("REFTEST TEST-FAIL | | EXCEPTION: " + ex + "\n");
         DoneTests();
     }
 }
 
 function OnRefTestUnload()
@@ -279,11 +279,11 @@ function ServeFiles(manifestURL, directo
 
 function StartCurrentTest()
 {
     // make sure we don't run tests that are expected to kill the browser
     while (gURLs.length > 0 && gURLs[0].expected == EXPECTED_DEATH) {
-        dump("REFTEST KNOWN FAIL (SKIP): " + gURLs[0].url1.spec + "\n");
+        dump("REFTEST TEST-KNOWN-FAIL | " + gURLs[0].url1.spec + " | (SKIP)\n");
         gURLs.shift();
     }
 
     if (gURLs.length == 0)
         DoneTests();
@@ -394,11 +394,11 @@ function DocumentLoaded()
     }
 
     clearTimeout(gFailureTimeout);
 
     if (gURLs[0].expected == EXPECTED_LOAD) {
-        dump("REFTEST PASS (LOAD ONLY): " + gURLs[0].prettyPath + "\n");
+        dump("REFTEST TEST-PASS | " + gURLs[0].prettyPath + "| (LOAD ONLY)\n");
         gURLs.shift();
         StartCurrentTest();
         return;
     }
 
@@ -447,23 +447,23 @@ function DocumentLoaded()
             var test_passed = (equal == gURLs[0].equal);
             // what is expected on this platform (PASS, FAIL, or RANDOM)
             var expected = gURLs[0].expected;
             
             var outputs = {};
-            const randomMsg = " (RESULT EXPECTED TO BE RANDOM)";
-            outputs[EXPECTED_PASS] = {true: "PASS",
-                                      false: "UNEXPECTED FAIL"};
-            outputs[EXPECTED_FAIL] = {true: "UNEXPECTED PASS",
-                                      false: "KNOWN FAIL"};
-            outputs[EXPECTED_RANDOM] = {true: "PASS" + randomMsg,
-                                        false: "KNOWN FAIL" + randomMsg};
+            const randomMsg = "(EXPECTED RANDOM)";
+            outputs[EXPECTED_PASS] = {true: "TEST-PASS",
+                                      false: "TEST-UNEXPECTED-FAIL"};
+            outputs[EXPECTED_FAIL] = {true: "TEST-UNEXPECTED-PASS",
+                                      false: "TEST-KNOWN-FAIL"};
+            outputs[EXPECTED_RANDOM] = {true: "TEST-PASS" + randomMsg,
+                                        false: "TEST-KNOWN-FAIL" + randomMsg};
             
-            var result = "REFTEST " + outputs[expected][test_passed] + ": ";
+            var result = "REFTEST " + outputs[expected][test_passed] + " | ";
+            result += gURLs[0].prettyPath + " | "; // the URL being tested
             if (!gURLs[0].equal) {
                 result += "(!=) ";
             }
-            result += gURLs[0].prettyPath; // the URL being tested
             dump(result + "\n");
             if (!test_passed && expected == EXPECTED_PASS ||
                 test_passed && expected == EXPECTED_FAIL) {
                 if (!equal) {
                     dump("REFTEST   IMAGE 1 (TEST): " + gCanvas1.toDataURL() + "\n");
@@ -482,10 +482,10 @@ function DocumentLoaded()
     }
 }
 
 function LoadFailed()
 {
-    dump("REFTEST UNEXPECTED FAIL (LOADING): " +
-         gURLs[0]["url" + gState].spec + "\n");
+    dump("REFTEST TEST-UNEXPECTED-FAIL | " +
+         gURLs[0]["url" + gState].spec + "| Failed to load\n");
     gURLs.shift();
     StartCurrentTest();
 }
diff -r 6c8c95fcaf9b layout/xul/base/src/nsBox.cpp
--- a/layout/xul/base/src/nsBox.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/xul/base/src/nsBox.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -353,11 +353,11 @@ nsBox::GetBorder(nsMargin& aMargin)
       aMargin.left = context->DevPixelsToAppUnits(margin.left);
       return NS_OK;
     }
   }
 
-  aMargin = GetStyleBorder()->GetBorder();
+  aMargin = GetStyleBorder()->GetActualBorder();
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
@@ -681,11 +681,10 @@ nsIBox::AddCSSPrefSize(nsBoxLayoutState&
 
     if (position->mHeight.GetUnit() == eStyleUnit_Coord) {
         aSize.height = position->mHeight.GetCoordValue();     
         heightSet = PR_TRUE;
     }
-    // XXX Handle eStyleUnit_Chars?
     
     nsIContent* content = aBox->GetContent();
     // ignore 'height' and 'width' attributes if the actual element is not XUL
     // For example, we might be magic XUL frames whose primary content is an HTML
     // <select>
@@ -780,11 +779,10 @@ nsIBox::AddCSSMinSize(nsBoxLayoutState& 
         float min = position->mMinHeight.GetPercentValue();
         NS_ASSERTION(min == 0.0f, "Non-zero percentage values not currently supported");
         aSize.height = 0;
         heightSet = PR_TRUE;
     }
-    // XXX Handle eStyleUnit_Chars?
 
     nsIContent* content = aBox->GetContent();
     if (content) {
         nsAutoString value;
         PRInt32 error;
@@ -839,11 +837,10 @@ nsIBox::AddCSSMaxSize(nsBoxLayoutState& 
     if (position->mMaxHeight.GetUnit() == eStyleUnit_Coord) {
         nscoord max = position->mMaxHeight.GetCoordValue();
         aSize.height = max;
         heightSet = PR_TRUE;
     }
-    // XXX Handle eStyleUnit_Chars?
 
     nsIContent* content = aBox->GetContent();
     if (content) {
         nsAutoString value;
         PRInt32 error;
diff -r 6c8c95fcaf9b layout/xul/base/src/nsBoxObject.cpp
--- a/layout/xul/base/src/nsBoxObject.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/xul/base/src/nsBoxObject.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -195,17 +195,17 @@ nsBoxObject::GetOffsetRect(nsRect& aRect
       parent = next;
     }
   
     // For the origin, add in the border for the frame
     const nsStyleBorder* border = frame->GetStyleBorder();
-    origin.x += border->GetBorderWidth(NS_SIDE_LEFT);
-    origin.y += border->GetBorderWidth(NS_SIDE_TOP);
+    origin.x += border->GetActualBorderWidth(NS_SIDE_LEFT);
+    origin.y += border->GetActualBorderWidth(NS_SIDE_TOP);
 
     // And subtract out the border for the parent
     const nsStyleBorder* parentBorder = parent->GetStyleBorder();
-    origin.x -= parentBorder->GetBorderWidth(NS_SIDE_LEFT);
-    origin.y -= parentBorder->GetBorderWidth(NS_SIDE_TOP);
+    origin.x -= parentBorder->GetActualBorderWidth(NS_SIDE_LEFT);
+    origin.y -= parentBorder->GetActualBorderWidth(NS_SIDE_TOP);
 
     aRect.x = nsPresContext::AppUnitsToIntCSSPixels(origin.x);
     aRect.y = nsPresContext::AppUnitsToIntCSSPixels(origin.y);
     
     // Get the union of all rectangles in this and continuation frames.
diff -r 6c8c95fcaf9b layout/xul/base/src/nsGroupBoxFrame.cpp
--- a/layout/xul/base/src/nsGroupBoxFrame.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/xul/base/src/nsGroupBoxFrame.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -149,11 +149,11 @@ nsGroupBoxFrame::PaintBorderBackground(n
 nsGroupBoxFrame::PaintBorderBackground(nsIRenderingContext& aRenderingContext,
     nsPoint aPt, const nsRect& aDirtyRect) {
   PRIntn skipSides = 0;
   const nsStyleBorder* borderStyleData = GetStyleBorder();
   const nsStylePadding* paddingStyleData = GetStylePadding();
-  const nsMargin& border = borderStyleData->GetBorder();
+  const nsMargin& border = borderStyleData->GetActualBorder();
   nscoord yoff = 0;
   nsPresContext* presContext = PresContext();
 
   nsRect groupRect;
   nsIBox* groupBox = GetCaptionBox(presContext, groupRect);
diff -r 6c8c95fcaf9b layout/xul/base/src/nsListBoxBodyFrame.cpp
--- a/layout/xul/base/src/nsListBoxBodyFrame.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/xul/base/src/nsListBoxBodyFrame.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -774,11 +774,11 @@ nsListBoxBodyFrame::ComputeIntrinsicWidt
     nscoord width = 0;
     nsMargin margin(0,0,0,0);
 
     if (styleContext->GetStylePadding()->GetPadding(margin))
       width += margin.LeftRight();
-    width += styleContext->GetStyleBorder()->GetBorder().LeftRight();
+    width += styleContext->GetStyleBorder()->GetActualBorder().LeftRight();
     if (styleContext->GetStyleMargin()->GetMargin(margin))
       width += margin.LeftRight();
 
     nsIContent* listbox = mContent->GetBindingParent();
     NS_ENSURE_TRUE(listbox, largestWidth);
diff -r 6c8c95fcaf9b layout/xul/base/src/nsMenuBarFrame.cpp
--- a/layout/xul/base/src/nsMenuBarFrame.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/xul/base/src/nsMenuBarFrame.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -51,11 +51,10 @@
 #include "nsGkAtoms.h"
 #include "nsMenuFrame.h"
 #include "nsMenuPopupFrame.h"
 #include "nsGUIEvent.h"
 #include "nsUnicharUtils.h"
-#include "nsICaret.h"
 #include "nsIFocusController.h"
 #include "nsIDOMWindowInternal.h"
 #include "nsIDOMDocument.h"
 #include "nsPIDOMWindow.h"
 #include "nsIInterfaceRequestorUtils.h"
diff -r 6c8c95fcaf9b layout/xul/base/src/nsXULPopupManager.cpp
--- a/layout/xul/base/src/nsXULPopupManager.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/xul/base/src/nsXULPopupManager.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -62,11 +62,11 @@
 #include "nsPIDOMWindow.h"
 #include "nsIInterfaceRequestorUtils.h"
 #include "nsIBaseWindow.h"
 #include "nsIDocShellTreeItem.h"
 #include "nsIDOMMouseEvent.h"
-#include "nsICaret.h"
+#include "nsCaret.h"
 #include "nsIDocument.h"
 #include "nsPIDOMWindow.h"
 
 // See matching definitions in nsXULPopupManager.h
 nsNavigationDirection DirectionFromKeyCode_lr_tb [6] = {
@@ -528,11 +528,11 @@ CheckCaretDrawingState(nsIDocument *aDoc
 
   nsIPresShell* presShell = focusedDoc->GetPrimaryShell();
   if (!presShell)
     return;
 
-  nsCOMPtr<nsICaret> caret;
+  nsRefPtr<nsCaret> caret;
   nsresult res = presShell->GetCaret(getter_AddRefs(caret));
   if (!caret)
     return;
   caret->CheckCaretDrawingState();
 
diff -r 6c8c95fcaf9b layout/xul/base/src/tree/src/nsTreeBodyFrame.cpp
--- a/layout/xul/base/src/tree/src/nsTreeBodyFrame.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/layout/xul/base/src/tree/src/nsTreeBodyFrame.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -193,11 +193,11 @@ GetBorderPadding(nsStyleContext* aContex
 {
   aMargin.SizeTo(0, 0, 0, 0);
   if (!aContext->GetStylePadding()->GetPadding(aMargin)) {
     NS_NOTYETIMPLEMENTED("percentage padding");
   }
-  aMargin += aContext->GetStyleBorder()->GetBorder();
+  aMargin += aContext->GetStyleBorder()->GetActualBorder();
 }
 
 static void
 AdjustForBorderPadding(nsStyleContext* aContext, nsRect& aRect)
 {
diff -r 6c8c95fcaf9b modules/libpr0n/decoders/png/nsPNGDecoder.cpp
--- a/modules/libpr0n/decoders/png/nsPNGDecoder.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/modules/libpr0n/decoders/png/nsPNGDecoder.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -653,11 +653,11 @@ info_callback(png_structp png_ptr, png_i
     if (!decoder->mCMSLine)
       longjmp(decoder->mPNG->jmpbuf, 5); // NS_ERROR_OUT_OF_MEMORY
   }
 
   if (interlace_type == PNG_INTERLACE_ADAM7) {
-    if (height < INT_MAX / (width * channels))
+    if (height < PR_INT32_MAX / (width * channels))
       decoder->interlacebuf = (PRUint8 *)nsMemory::Alloc(channels * width * height);
     if (!decoder->interlacebuf) {
       longjmp(decoder->mPNG->jmpbuf, 5); // NS_ERROR_OUT_OF_MEMORY
     }
   }
diff -r 6c8c95fcaf9b modules/plugin/base/public/npupp.h
--- a/modules/plugin/base/public/npupp.h	Tue Jul 15 15:16:43 2008 +1200
+++ b/modules/plugin/base/public/npupp.h	Thu Jul 17 14:13:04 2008 +0300
@@ -705,10 +705,11 @@ extern "C" {
 extern "C" {
 #endif
 
 /* plugin meta member functions */
 
+NP_EXPORT(char*)   NP_GetPluginVersion(void);
 NP_EXPORT(char*)   NP_GetMIMEDescription(void);
 NP_EXPORT(NPError) NP_Initialize(NPNetscapeFuncs*, NPPluginFuncs*);
 NP_EXPORT(NPError) NP_Shutdown(void);
 NP_EXPORT(NPError) NP_GetValue(void *future, NPPVariable aVariable, void *aValue);
 
diff -r 6c8c95fcaf9b modules/plugin/base/public/nsIPluginTag.idl
--- a/modules/plugin/base/public/nsIPluginTag.idl	Tue Jul 15 15:16:43 2008 +1200
+++ b/modules/plugin/base/public/nsIPluginTag.idl	Thu Jul 17 14:13:04 2008 +0300
@@ -36,14 +36,15 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsISupports.idl"
 
-[scriptable, uuid(af36bf4d-5652-413f-a78c-745b702f2381)]
+[scriptable, uuid(13a1b39e-72e5-442d-aa73-5905ffaf837b)]
 interface nsIPluginTag : nsISupports
 {
   readonly attribute AUTF8String description;
   readonly attribute AUTF8String filename;
+  readonly attribute AUTF8String version;
   readonly attribute AUTF8String name;
            attribute boolean  disabled;
            attribute boolean  blocklisted;
 };
diff -r 6c8c95fcaf9b modules/plugin/base/src/ns4xPlugin.cpp
--- a/modules/plugin/base/src/ns4xPlugin.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/modules/plugin/base/src/ns4xPlugin.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -2186,13 +2186,17 @@ _getvalue(NPP npp, NPNVariable variable,
 #if defined(XP_UNIX) && !defined(XP_MACOSX)
   case NPNVxDisplay : {
 #ifdef MOZ_WIDGET_GTK2
     if (npp) {
       ns4xPluginInstance *inst = (ns4xPluginInstance *) npp->ndata;
-      NPBool rtv = PR_FALSE;
-      inst->GetValue((nsPluginInstanceVariable)NPPVpluginNeedsXEmbed, &rtv);
-      if (rtv) {
+      PRBool windowless = PR_FALSE;
+      inst->GetValue(nsPluginInstanceVariable_WindowlessBool, &windowless);
+      NPBool needXEmbed = PR_FALSE;
+      if (!windowless) {
+        inst->GetValue((nsPluginInstanceVariable)NPPVpluginNeedsXEmbed, &needXEmbed);
+      }
+      if (windowless || needXEmbed) {
         (*(Display **)result) = GDK_DISPLAY();
         return NPERR_NO_ERROR;
       }
     }
     // adobe nppdf calls XtGetApplicationNameAndClass(display,
diff -r 6c8c95fcaf9b modules/plugin/base/src/nsPluginHostImpl.cpp
--- a/modules/plugin/base/src/nsPluginHostImpl.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/modules/plugin/base/src/nsPluginHostImpl.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -200,11 +200,12 @@
 // 0.05 added new entry point check for the default plugin, bug 132430
 // 0.06 strip off suffixes in mime description strings, bug 53895
 // 0.07 changed nsIRegistry to flat file support for caching plugins info
 // 0.08 mime entry point on MachO, bug 137535
 // 0.09 the file encoding is changed to UTF-8, bug 420285
-static const char *kPluginRegistryVersion = "0.09";
+// 0.10 added plugin versions on appropriate platforms, bug 427743
+static const char *kPluginRegistryVersion = "0.10";
 ////////////////////////////////////////////////////////////////////////
 // CID's && IID's
 static NS_DEFINE_IID(kIPluginInstanceIID, NS_IPLUGININSTANCE_IID);
 static NS_DEFINE_CID(kPluginCID, NS_PLUGIN_CID);
 static NS_DEFINE_IID(kIPluginTagInfo2IID, NS_IPLUGINTAGINFO2_IID);
@@ -742,10 +743,11 @@ nsPluginTag::nsPluginTag(nsPluginTag* aP
     mXPConnected(PR_FALSE),
     mIsJavaPlugin(aPluginTag->mIsJavaPlugin),
     mIsNPRuntimeEnabledJavaPlugin(aPluginTag->mIsNPRuntimeEnabledJavaPlugin),
     mFileName(aPluginTag->mFileName),
     mFullPath(aPluginTag->mFullPath),
+    mVersion(aPluginTag->mVersion),
     mLastModifiedTime(0),
     mFlags(NS_PLUGIN_FLAG_ENABLED)
 {
   if(aPluginTag->mMimeTypeArray != nsnull)
   {
@@ -781,10 +783,11 @@ nsPluginTag::nsPluginTag(nsPluginInfo* a
     mXPConnected(PR_FALSE),
     mIsJavaPlugin(PR_FALSE),
     mIsNPRuntimeEnabledJavaPlugin(PR_FALSE),
     mFileName(aPluginInfo->fFileName),
     mFullPath(aPluginInfo->fFullPath),
+    mVersion(aPluginInfo->fVersion),
     mLastModifiedTime(0),
     mFlags(NS_PLUGIN_FLAG_ENABLED)
 {
   if(aPluginInfo->fMimeTypeArray != nsnull)
   {
@@ -855,10 +858,11 @@ nsPluginTag::nsPluginTag(nsPluginInfo* a
 ////////////////////////////////////////////////////////////////////////
 nsPluginTag::nsPluginTag(const char* aName,
                          const char* aDescription,
                          const char* aFileName,
                          const char* aFullPath,
+                         const char* aVersion,
                          const char* const* aMimeTypes,
                          const char* const* aMimeDescriptions,
                          const char* const* aExtensions,
                          PRInt32 aVariants,
                          PRInt64 aLastModifiedTime,
@@ -876,10 +880,11 @@ nsPluginTag::nsPluginTag(const char* aNa
     mXPConnected(PR_FALSE),
     mIsJavaPlugin(PR_FALSE),
     mIsNPRuntimeEnabledJavaPlugin(PR_FALSE),
     mFileName(aFileName),
     mFullPath(aFullPath),
+    mVersion(aVersion),
     mLastModifiedTime(aLastModifiedTime),
     mFlags(0) // Caller will read in our flags from cache
 {
   if (aVariants) {
     mMimeTypeArray        = new char*[mVariants];
@@ -1015,10 +1020,17 @@ nsPluginTag::GetDescription(nsACString& 
 
 NS_IMETHODIMP
 nsPluginTag::GetFilename(nsACString& aFileName)
 {
   aFileName = mFileName;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPluginTag::GetVersion(nsACString& aVersion)
+{
+  aVersion = mVersion;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsPluginTag::GetName(nsACString& aName)
@@ -5586,15 +5598,18 @@ nsPluginHostImpl::WritePluginInfo()
       if ((taglist[i] == mCachedPlugins) && !tag->HasFlag(NS_PLUGIN_FLAG_UNWANTED))
         continue;
       // store each plugin info into the registry
       // filename & fullpath are on separate line
       // because they can contain field delimiter char
-      PR_fprintf(fd, "%s%c%c\n%s%c%c\n",
+      PR_fprintf(fd, "%s%c%c\n%s%c%c\n%s%c%c\n",
         (!tag->mFileName.IsEmpty() ? tag->mFileName.get() : ""),
         PLUGIN_REGISTRY_FIELD_DELIMITER,
         PLUGIN_REGISTRY_END_OF_LINE_MARKER,
         (!tag->mFullPath.IsEmpty() ? tag->mFullPath.get() : ""),
+        PLUGIN_REGISTRY_FIELD_DELIMITER,
+        PLUGIN_REGISTRY_END_OF_LINE_MARKER,
+        (!tag->mVersion.IsEmpty() ? tag->mVersion.get() : ""),
         PLUGIN_REGISTRY_FIELD_DELIMITER,
         PLUGIN_REGISTRY_END_OF_LINE_MARKER);
 
       // lastModifiedTimeStamp|canUnload|tag->mFlags
       PR_fprintf(fd, "%lld%c%d%c%lu%c%c\n",
@@ -5747,10 +5762,14 @@ nsPluginHostImpl::ReadPluginInfo()
 
     char *fullpath = reader.LinePtr();
     if (!reader.NextLine())
       return rv;
 
+    char *version = reader.LinePtr();
+    if (!reader.NextLine())
+      return rv;
+
     // lastModifiedTimeStamp|canUnload|tag.mFlag
     if (3 != reader.ParseLine(values, 3))
       return rv;
 
     PRInt64 lastmod = nsCRT::atoll(values[0]);
@@ -5808,10 +5827,11 @@ nsPluginHostImpl::ReadPluginInfo()
 
     nsRefPtr<nsPluginTag> tag = new nsPluginTag(name,
       description,
       filename,
       (*fullpath ? fullpath : 0), // we have to pass 0 prt if it's empty str
+      version,
       (const char* const*)mimetypes,
       (const char* const*)mimedescriptions,
       (const char* const*)extensions,
       mimetypecount, lastmod, canunload, PR_TRUE);
     if (heapalloced) {
diff -r 6c8c95fcaf9b modules/plugin/base/src/nsPluginHostImpl.h
--- a/modules/plugin/base/src/nsPluginHostImpl.h	Tue Jul 15 15:16:43 2008 +1200
+++ b/modules/plugin/base/src/nsPluginHostImpl.h	Thu Jul 17 14:13:04 2008 +0300
@@ -102,10 +102,11 @@ public:
 
   nsPluginTag(const char* aName,
               const char* aDescription,
               const char* aFileName,
               const char* aFullPath,
+              const char* aVersion,
               const char* const* aMimeTypes,
               const char* const* aMimeDescriptions,
               const char* const* aExtensions,
               PRInt32 aVariants,
               PRInt64 aLastModifiedTime = 0,
@@ -164,10 +165,11 @@ public:
   PRPackedBool  mXPConnected;
   PRPackedBool  mIsJavaPlugin;
   PRPackedBool  mIsNPRuntimeEnabledJavaPlugin;
   nsCString     mFileName; // UTF-8
   nsCString     mFullPath; // UTF-8
+  nsCString     mVersion;  // UTF-8
   PRInt64       mLastModifiedTime;
 private:
   PRUint32      mFlags;
 
   nsresult EnsureMembersAreUTF8();
diff -r 6c8c95fcaf9b modules/plugin/base/src/nsPluginsDir.h
--- a/modules/plugin/base/src/nsPluginsDir.h	Tue Jul 15 15:16:43 2008 +1200
+++ b/modules/plugin/base/src/nsPluginsDir.h	Thu Jul 17 14:13:04 2008 +0300
@@ -64,10 +64,11 @@ struct nsPluginInfo {
 	char** fMimeTypeArray;
 	char** fMimeDescriptionArray;
 	char** fExtensionArray;
 	char* fFileName;
 	char* fFullPath;
+	char* fVersion;
 #ifdef XP_MACOSX
   PRBool fBundle;
 #endif
 };
 
diff -r 6c8c95fcaf9b modules/plugin/base/src/nsPluginsDirBeOS.cpp
--- a/modules/plugin/base/src/nsPluginsDirBeOS.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/modules/plugin/base/src/nsPluginsDirBeOS.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -161,10 +161,11 @@ typedef char* (*BeOS_Plugin_GetMIMEDescr
 /**
  * Obtains all of the information currently available for this plugin.
  */
 nsresult nsPluginFile::GetPluginInfo(nsPluginInfo& info)
 {
+    info.fVersion = nsnull;
     nsCAutoString fpath;
     nsresult rv = mPlugin->GetNativePath(fpath);
     if (NS_OK != rv) {
         return rv;
     }
@@ -278,7 +279,10 @@ nsresult nsPluginFile::FreePluginInfo(ns
     PR_FREEIF(info.fExtensionArray);
 
     if (info.fFileName)
         PL_strfree(info.fFileName);
 
+    if (info.fVersion)
+        PL_strfree(info.fFileVersion);
+
     return NS_OK;
 }
diff -r 6c8c95fcaf9b modules/plugin/base/src/nsPluginsDirDarwin.cpp
--- a/modules/plugin/base/src/nsPluginsDirDarwin.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/modules/plugin/base/src/nsPluginsDirDarwin.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -323,13 +323,26 @@ nsresult nsPluginFile::GetPluginInfo(nsP
   FSSpec spec;
   toFSSpec(mPlugin, spec);
   info.fFileName = p2cstrdup(spec.name);
   
   info.fFullPath = PL_strdup(path.get());
+  info.fVersion = nsnull;
   CFBundleRef bundle = getPluginBundle(path.get());
   if (bundle) {
     info.fBundle = PR_TRUE;
+    // Look for the release version first
+    CFStringRef version = (CFStringRef)::CFBundleGetValueForInfoDictionaryKey(bundle, CFSTR("CFBundleShortVersionString"));
+    // If not try the build version
+    if (!version)
+      version = (CFStringRef)::CFBundleGetValueForInfoDictionaryKey(bundle, kCFBundleVersionKey);
+    if (version) {
+      CFIndex versionLength = ::CFStringGetLength(version);
+      info.fVersion = (char*)malloc(versionLength + 1);
+      if (! ::CFStringGetCString(version, info.fVersion, versionLength + 1, 
+                                 kCFStringEncodingUTF8))
+        delete[] info.fVersion;
+    }
     CFRelease(bundle);
   }
   else {
     info.fBundle = PR_FALSE;
   }
@@ -424,9 +437,10 @@ nsresult nsPluginFile::FreePluginInfo(ns
     delete[] info.fMimeTypeArray;
     delete[] info.fMimeDescriptionArray;
     delete[] info.fExtensionArray;
     delete[] info.fFileName;
     delete[] info.fFullPath;
+    delete[] info.fVersion;
   }
 
   return NS_OK;
 }
diff -r 6c8c95fcaf9b modules/plugin/base/src/nsPluginsDirOS2.cpp
--- a/modules/plugin/base/src/nsPluginsDirOS2.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/modules/plugin/base/src/nsPluginsDirOS2.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -193,10 +193,11 @@ nsresult nsPluginFile::GetPluginInfo( ns
    const char* path;
    nsCAutoString temp;
    mPlugin->GetNativePath(temp);
    path = temp.get();
    ret = DosLoadModule( failure, CCHMAXPATH, path, &hPlug);
+   info.fVersion = nsnull;
 
    while( ret == NO_ERROR)
    {
       info.fPluginInfoSize = sizeof( nsPluginInfo);
 
@@ -240,10 +241,16 @@ nsresult nsPluginFile::FreePluginInfo(ns
 nsresult nsPluginFile::FreePluginInfo(nsPluginInfo& info)
 {
    if(info.fName != nsnull)
      PL_strfree(info.fName);
  
+   if(info.fFileName != nsnull)
+     PL_strfree(info.fFileName);
+ 
+   if(info.fVersion != nsnull)
+     PL_strfree(info.fFileVersion);
+ 
    if(info.fDescription != nsnull)
      PL_strfree(info.fDescription);
  
    if(info.fMimeTypeArray != nsnull)
      FreeStringArray(info.fVariantCount, info.fMimeTypeArray);
diff -r 6c8c95fcaf9b modules/plugin/base/src/nsPluginsDirUnix.cpp
--- a/modules/plugin/base/src/nsPluginsDirUnix.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/modules/plugin/base/src/nsPluginsDirUnix.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -439,10 +439,11 @@ nsresult nsPluginFile::GetPluginInfo(nsP
     nsFactoryProc nsGetFactory =
         (nsFactoryProc) PR_FindFunctionSymbol(pLibrary, "NSGetFactory");
 
     nsCOMPtr<nsIPlugin> plugin;
 
+    info.fVersion = nsnull;
     if (nsGetFactory) {
         // It's an almost-new-style plugin. The "truly new" plugins
         // are just XPCOM components, but there are some Mozilla
         // Classic holdovers that live in the plugins directory but
         // implement nsIPlugin and the factory stuff.
@@ -471,10 +472,15 @@ nsresult nsPluginFile::GetPluginInfo(nsP
 				      getter_AddRefs(plugin));
         if (NS_FAILED(rv)) return rv;
     }
 
     if (plugin) {
+        const char* (*npGetPluginVersion)() =
+          (const char* (*)()) PR_FindFunctionSymbol(pLibrary, "NP_GetPluginVersion");
+        if (npGetPluginVersion)
+            info.fVersion = PL_strdup(npGetPluginVersion());
+
         plugin->GetMIMEDescription(&mimedescr);
 #ifdef NS_DEBUG
         printf("GetMIMEDescription() returned \"%s\"\n", mimedescr);
 #endif
         if (NS_FAILED(rv = ParsePluginMimeDescription(mimedescr, info)))
@@ -521,7 +527,10 @@ nsresult nsPluginFile::FreePluginInfo(ns
     PR_FREEIF(info.fExtensionArray);
 
     if (info.fFileName != nsnull)
         PL_strfree(info.fFileName);
 
+    if (info.fVersion != nsnull)
+        PL_strfree(info.fVersion);
+
     return NS_OK;
 }
diff -r 6c8c95fcaf9b modules/plugin/base/src/nsPluginsDirWin.cpp
--- a/modules/plugin/base/src/nsPluginsDirWin.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/modules/plugin/base/src/nsPluginsDirWin.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -78,10 +78,31 @@ static char* GetKeyValue(char* verbuf, c
 		return PL_strdup(buf);	
 #endif
 	}
 
 	return nsnull;
+}
+
+static char* GetVersion(char* verbuf)
+{
+    VS_FIXEDFILEINFO *fileInfo;
+    UINT fileInfoLen;
+
+    ::VerQueryValue(verbuf,
+                    "\\",
+                    (void **)&fileInfo, &fileInfoLen);
+
+    if (fileInfo != NULL)
+    {
+        return PR_smprintf("%ld.%ld.%ld.%ld",
+                           HIWORD(fileInfo->dwFileVersionMS),
+                           LOWORD(fileInfo->dwFileVersionMS),
+                           HIWORD(fileInfo->dwFileVersionLS),
+                           LOWORD(fileInfo->dwFileVersionLS));
+    }
+
+    return nsnull;
 }
 
 static PRUint32 CalculateVariantCount(char* mimeTypes)
 {
 	PRUint32 variants = 1;
@@ -285,10 +306,11 @@ nsresult nsPluginFile::GetPluginInfo(nsP
 		info.fVariantCount = CalculateVariantCount(mimeType);
 		info.fMimeTypeArray = MakeStringArray(info.fVariantCount, mimeType);
 		info.fMimeDescriptionArray = MakeStringArray(info.fVariantCount, mimeDescription);
 		info.fExtensionArray = MakeStringArray(info.fVariantCount, extensions);
         info.fFileName = PL_strdup(path);
+        info.fVersion = GetVersion(verbuf);
         
         PL_strfree(mimeType);
         PL_strfree(mimeDescription);
         PL_strfree(extensions);
 	}
@@ -319,9 +341,12 @@ nsresult nsPluginFile::FreePluginInfo(ns
     FreeStringArray(info.fVariantCount, info.fExtensionArray);
 
   if(info.fFileName != NULL)
     PL_strfree(info.fFileName);
 
+  if(info.fVersion != NULL)
+    PL_strfree(info.fVersion);
+
   ZeroMemory((void *)&info, sizeof(info));
 
   return NS_OK;
 }
diff -r 6c8c95fcaf9b modules/plugin/samples/default/mac/Info-DefaultPlugin.plist
--- a/modules/plugin/samples/default/mac/Info-DefaultPlugin.plist	Tue Jul 15 15:16:43 2008 +1200
+++ b/modules/plugin/samples/default/mac/Info-DefaultPlugin.plist	Thu Jul 17 14:13:04 2008 +0300
@@ -15,10 +15,10 @@
 	<key>CFBundlePackageType</key>
 	<string>NSPL</string>
 	<key>CFBundleSignature</key>
 	<string>MOSS</string>
 	<key>CFBundleVersion</key>
-	<string>1.0</string>
+	<string>1.0.0.15</string>
 	<key>CSResourcesFileMapped</key>
 	<true/>
 </dict>
 </plist>
diff -r 6c8c95fcaf9b modules/plugin/samples/default/unix/npunix.c
--- a/modules/plugin/samples/default/unix/npunix.c	Tue Jul 15 15:16:43 2008 +1200
+++ b/modules/plugin/samples/default/unix/npunix.c	Thu Jul 17 14:13:04 2008 +0300
@@ -457,10 +457,21 @@ Private_Print(NPP instance, NPPrint* pla
  * These functions are located automagically by netscape.
  *
  ***********************************************************************/
 
 /*
+ * NP_GetPluginVersion [optional]
+ *  - The browser uses the return value to indicate to the user what version of
+ *    this plugin is installed.
+ */
+char *
+NP_GetPluginVersion(void)
+{
+    return "1.0.0.15";
+}
+
+/*
  * NP_GetMIMEDescription
  *  - Netscape needs to know about this symbol
  *  - Netscape uses the return value to identify when an object instance
  *    of this plugin should be created.
  */
diff -r 6c8c95fcaf9b modules/plugin/samples/unixprinting/npunix.c
--- a/modules/plugin/samples/unixprinting/npunix.c	Tue Jul 15 15:16:43 2008 +1200
+++ b/modules/plugin/samples/unixprinting/npunix.c	Thu Jul 17 14:13:04 2008 +0300
@@ -346,10 +346,21 @@ Private_Print(NPP instance, NPPrint* pla
  * These functions are located automagically by netscape.
  *
  ***********************************************************************/
 
 /*
+ * NP_GetPluginVersion [optional]
+ *  - The browser uses the return value to indicate to the user what version of
+ *    this plugin is installed.
+ */
+char *
+NP_GetPluginVersion(void)
+{
+    return "1.0.0";
+}
+
+/*
  * NP_GetMIMEDescription
  *  - Netscape needs to know about this symbol
  *  - Netscape uses the return value to identify when an object instance
  *    of this plugin should be created.
  */
diff -r 6c8c95fcaf9b parser/htmlparser/src/nsParser.cpp
--- a/parser/htmlparser/src/nsParser.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/parser/htmlparser/src/nsParser.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -1491,10 +1491,16 @@ nsParser::ParseFragment(const nsAString&
     theContext.AppendLiteral("<");
     theContext.Append(aTagStack[theCount - theIndex - 1]);
     theContext.AppendLiteral(">");
   }
 
+  if (theCount == 0) {
+    // Ensure that the buffer is not empty. Because none of the DTDs care
+    // about leading whitespace, this doesn't change the result.
+    theContext.AssignLiteral(" ");
+  }
+
   // First, parse the context to build up the DTD's tag stack. Note that we
   // pass PR_FALSE for the aLastCall parameter.
   result = Parse(theContext, (void*)&theContext, aMimeType, PR_FALSE, aMode);
   if (NS_FAILED(result)) {
     mFlags |= NS_PARSER_FLAG_OBSERVERS_ENABLED;
diff -r 6c8c95fcaf9b storage/test/unit/test_bug-444233.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/storage/test/unit/test_bug-444233.js	Thu Jul 17 14:13:04 2008 +0300
@@ -0,0 +1,95 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Storage Test Code.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * This code is based off of like.test from the sqlite code
+ *
+ * Contributor(s):
+ *   Paul O'Shannessy <poshannessy@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+// copy from test_storage_statement_wrapper.js
+var wrapper = new Components.Constructor("@mozilla.org/storage/statement-wrapper;1",
+                                         Ci.mozIStorageStatementWrapper,
+                                         "initialize");
+// we want to override the default function for this file
+createStatement = function(aSQL) {
+    return new wrapper(getOpenedDatabase().createStatement(aSQL));
+}
+
+function setup() {
+    // Create the table
+    getOpenedDatabase().createTable("test_bug444233",
+                                    "id INTEGER PRIMARY KEY, value TEXT");
+
+    // Insert dummy data, using wrapper methods
+    var stmt = createStatement("INSERT INTO test_bug444233 (value) VALUES (:value)");
+    stmt.params.value = "value1"
+    stmt.execute();
+    stmt.statement.finalize();
+    
+    stmt = createStatement("INSERT INTO test_bug444233 (value) VALUES (:value)");
+    stmt.params.value = "value2"
+    stmt.execute();
+    stmt.statement.finalize();
+}
+
+function test_bug444233() {
+    print("*** test_bug444233: started");
+    
+    // Check that there are 2 results
+    var stmt = createStatement("SELECT COUNT(*) AS number FROM test_bug444233");
+    do_check_true(stmt.step());
+    do_check_eq(2, stmt.row.number);
+    stmt.reset();
+    stmt.statement.finalize();
+
+    print("*** test_bug444233: doing delete");
+    
+    // Now try to delete using IN
+    // Cheating since we know ids are 1,2
+    try {
+        var ids = [1, 2];
+        stmt = createStatement("DELETE FROM test_bug444233 WHERE id IN (:ids)");
+        stmt.params.ids = ids;
+    } catch (e) {
+        print("*** test_bug444233: successfully caught exception");
+    }
+    stmt.statement.finalize();
+}
+
+function run_test() {
+    setup();
+    test_bug444233();
+    cleanup();
+}
+
diff -r 6c8c95fcaf9b storage/test/unit/test_storage_statement_executeAsync.js
--- a/storage/test/unit/test_storage_statement_executeAsync.js	Tue Jul 15 15:16:43 2008 +1200
+++ b/storage/test/unit/test_storage_statement_executeAsync.js	Thu Jul 17 14:13:04 2008 +0300
@@ -82,10 +82,14 @@ function test_create_table()
       // Verify that it's created correctly (this will throw if it wasn't)
       var stmt = getOpenedDatabase().createStatement(
         "SELECT id, string, number, nuller, blober FROM test"
       );
       stmt.finalize();
+
+      // Now we run the rest of the tests
+      for (var i = 0; i < tests.length; i++)
+        tests[i]();
 
       do_test_finished();
     }
   });
   stmt.finalize();
@@ -444,11 +448,10 @@ function test_double_execute()
   stmt.finalize();
 }
 
 var tests =
 [
-  test_create_table,
   test_add_data,
   test_get_data,
   test_tuple_out_of_bounds,
   test_no_listener_works,
   test_partial_listener_works,
@@ -457,13 +460,11 @@ var tests =
   test_double_execute,
 ];
 
 function run_test()
 {
-  // XXX disabling test due to odd failure on linux
-  // bug 444821
-  return;
   cleanup();
 
-  for (var i = 0; i < tests.length; i++)
-    tests[i]();
+  // This test has to run first and run to completion.  When it is done, it will
+  // run the rest of the tests.
+  test_create_table();
 }
diff -r 6c8c95fcaf9b testing/mochitest/browser-harness.xul
--- a/testing/mochitest/browser-harness.xul	Tue Jul 15 15:16:43 2008 +1200
+++ b/testing/mochitest/browser-harness.xul	Thu Jul 17 14:13:04 2008 +0300
@@ -123,13 +123,11 @@
         return this.tests.filter(function (t) !t.pass).length;
       },
       get log() {
         var path = this.path;
         return this.tests.map(function (t) {
-                                if (!t.pass)
-                                  return t.msg + " - " + path;
-                                return t.msg;
+                                  return t.result + " | " + path + " | " + t.msg;
                               }).join("\n");
       }
     };
 
     // Returns an array of chrome:// URLs to all the test files
@@ -180,11 +178,11 @@
       Tester.start();
     }
 
     function getLogFromTests(aTests) {
       if (!aTests.length)
-        return "PASS - No tests to run";
+        return "TEST-PASS | | No tests to run";
 
       var log = aTests.map(function (f) {
                              var output = f.path + "\n";
                              if (f.log)
                                output += f.log + "\n";
diff -r 6c8c95fcaf9b testing/mochitest/browser-test.js
--- a/testing/mochitest/browser-test.js	Tue Jul 15 15:16:43 2008 +1200
+++ b/testing/mochitest/browser-test.js	Thu Jul 17 14:13:04 2008 +0300
@@ -36,11 +36,11 @@ Tester.prototype = {
     return this.currentTestIndex == this.tests.length - 1;
   },
   step: function Tester_step() {
     this.currentTestIndex++;
   },
-  
+
   start: function Tester_start() {
     this.execTest();
   },
 
   finish: function Tester_finish() {
@@ -89,22 +89,23 @@ function testResult(aCondition, aName, a
 function testResult(aCondition, aName, aDiag, aIsTodo) {
   aName = aName || "";
 
   this.pass = !!aCondition;
   this.todo = aIsTodo;
+  this.msg = aName;
   if (this.pass) {
     if (aIsTodo)
-      this.msg = "\tTODO PASS - " + aName;
+      this.result = "TEST-KNOWN-FAIL";
     else
-      this.msg = "\tPASS - " + aName;
+      this.result = "TEST-PASS";
   } else {
-    this.msg = "\tFAIL - ";
-    if (aIsTodo)
-      this.msg += "TODO Worked? - ";
-    this.msg += aName;
     if (aDiag)
       this.msg += " - " + aDiag;
+    if (aIsTodo)
+      this.result = "TEST-UNEXPECTED-PASS";
+    else
+      this.result = "TEST-UNEXPECTED-FAIL";
   }
 }
 
 function testScope(aTests) {
   var scriptLoader = Cc["@mozilla.org/moz/jssubscript-loader;1"].
@@ -114,33 +115,33 @@ function testScope(aTests) {
   this.tests = aTests;
 
   var self = this;
   this.ok = function test_ok(condition, name, diag) {
     self.tests.push(new testResult(condition, name, diag, false));
-  }
+  };
   this.is = function test_is(a, b, name) {
     self.ok(a == b, name, "Got " + a + ", expected " + b);
-  }
+  };
   this.isnot = function test_isnot(a, b, name) {
     self.ok(a != b, name, "Didn't expect " + a + ", but got it");
-  }
+  };
   this.todo = function test_todo(condition, name, diag) {
     self.tests.push(new testResult(!condition, name, diag, true));
-  }
+  };
   this.todo_is = function test_todo_is(a, b, name) {
     self.todo(a == b, name, "Got " + a + ", expected " + b);
-  },
+  };
   this.todo_isnot = function test_todo_isnot(a, b, name) {
     self.todo(a != b, name, "Didn't expect " + a + ", but got it");
-  },
+  };
 
   this.waitForExplicitFinish = function test_WFEF() {
     self.done = false;
-  }
+  };
   this.finish = function test_finish() {
     self.done = true;
-  }
+  };
 }
 testScope.prototype = {
   done: true,
 
   EventUtils: {}
@@ -163,22 +164,22 @@ resultPoller.prototype = {
 
   start: function resultPoller_start() {
     var self = this;
     function checkDone() {
       self.loopCount++;
-  
+
       if (self.loopCount > MAX_LOOP_COUNT) {
         self.test.tests.push(new testResult(false, "Timed out", "", false));
         self.test.scope.done = true;
       }
 
       if (self.test.scope.done) {
         clearInterval(self.interval);
 
         // Notify the callback
         self.callback();
-        self.callback = null; 
+        self.callback = null;
         self.test = null;
       }
     }
     this.interval = setInterval(checkDone, CHECK_INTERVAL);
   }
diff -r 6c8c95fcaf9b testing/mochitest/runtests.py.in
--- a/testing/mochitest/runtests.py.in	Tue Jul 15 15:16:43 2008 +1200
+++ b/testing/mochitest/runtests.py.in	Thu Jul 17 14:13:04 2008 +0300
@@ -374,49 +374,49 @@ Are you executing $objdir/_tests/testing
     lineRe = re.compile(r"^\s*\d+\s+(?P<name>\S+)\s+"
                         r"(?P<size>\d+)\s+(?P<bytesLeaked>\d+)\s+"
                         r"\d+\s+(?P<numLeaked>\d+)")
     thresholdExceeded = False
     seenTotal = False
-    prefix = "WARNING"
+    prefix = "TEST-PASS"
     for line in leaks:
       matches = lineRe.match(line)
       if not matches:
         continue
       name = matches.group("name")
       if "TOTAL" == name:
         seenTotal = True
         bytesLeaked = int(matches.group("bytesLeaked"))
         if bytesLeaked > threshold:
           thresholdExceeded = True
-          prefix = "ERROR FAIL"
-          log.info("ERROR FAIL leaked %d bytes during test execution (should "
+          prefix = "TEST-UNEXPECTED-FAIL"
+          log.info("TEST-UNEXPECTED-FAIL | runtests-leaks | leaked %d bytes during test execution (should "
                    "have leaked no more than %d bytes)",
                    bytesLeaked, threshold)
         elif bytesLeaked > 0:
-          log.info("WARNING leaked %d bytes during test execution",
+          log.info("TEST-PASS | runtests-leaks | WARNING leaked %d bytes during test execution",
                    bytesLeaked)
         else:
-          log.info("SUCCESS no leaks detected!")
+          log.info("TEST-PASS | runtests-leaks | no leaks detected!")
       else:
         numLeaked = int(matches.group("numLeaked"))
         if numLeaked != 0:
           if numLeaked > 1:
             instance = "instances"
             rest = " each (%s bytes total)" % matches.group("bytesLeaked")
           else:
             instance = "instance"
             rest = ""
-          log.info("%(prefix)s leaked %(numLeaked)d %(instance)s of %(name)s "
+          log.info("%(prefix)s | runtests-leaks | leaked %(numLeaked)d %(instance)s of %(name)s "
                    "with size %(size)s bytes%(rest)s" %
                    { "prefix": prefix,
                      "numLeaked": numLeaked,
                      "instance": instance,
                      "name": name,
                      "size": matches.group("size"),
                      "rest": rest })
     if not seenTotal:
-      log.info("ERROR FAIL missing output line for total leaks!")
+      log.info("TEST-UNEXPECTED-FAIL | runtests-leaks | missing output line for total leaks!")
     leaks.close()
 
 
   # print test run times
   finish = datetime.now()
diff -r 6c8c95fcaf9b testing/mochitest/tests/SimpleTest/SimpleTest.js
--- a/testing/mochitest/tests/SimpleTest/SimpleTest.js	Tue Jul 15 15:16:43 2008 +1200
+++ b/testing/mochitest/tests/SimpleTest/SimpleTest.js	Thu Jul 17 14:13:04 2008 +0300
@@ -3,11 +3,11 @@
  *
  * Why?
  *
  * Test.Simple doesn't work on IE < 6.
  * TODO:
- *  * Support the Test.Simple API used by MochiKit, to be able to test MochiKit 
+ *  * Support the Test.Simple API used by MochiKit, to be able to test MochiKit
  * itself against IE 5.5
  *
 **/
 
 if (typeof(SimpleTest) == "undefined") {
@@ -34,11 +34,11 @@ SimpleTest._stopOnLoad = true;
  * Something like assert.
 **/
 SimpleTest.ok = function (condition, name, diag) {
     var test = {'result': !!condition, 'name': name, 'diag': diag || ""};
     if (SimpleTest._logEnabled)
-        SimpleTest._logResult(test, "PASS", "FAIL");
+        SimpleTest._logResult(test, "TEST-PASS", "TEST-UNEXPECTED-FAIL");
     SimpleTest._tests.push(test);
 };
 
 /**
  * Roughly equivalent to ok(a==b, name)
@@ -56,34 +56,35 @@ SimpleTest.isnot = function (a, b, name)
 //  --------------- Test.Builder/Test.More todo() -----------------
 
 SimpleTest.todo = function(condition, name, diag) {
   var test = {'result': !!condition, 'name': name, 'diag': diag || "", todo: true};
   if (SimpleTest._logEnabled)
-      SimpleTest._logResult(test, "TODO WORKED?", "TODO");
+      SimpleTest._logResult(test, "TEST-UNEXPECTED-PASS", "TEST-KNOWN-FAIL");
   SimpleTest._tests.push(test);
-}
+};
 
 SimpleTest._logResult = function(test, passString, failString) {
   var msg = test.result ? passString : failString;
+  msg += " | ";
+  if (parentRunner.currentTestURL)
+    msg += parentRunner.currentTestURL;
   msg += " | " + test.name;
-  var url = "";
-  if (parentRunner.currentTestURL)
-    url = " | " + parentRunner.currentTestURL;
-
+  var diag = "";
+  if (test.diag)
+    diag = " - " + test.diag;
   if (test.result) {
       if (test.todo)
-          parentRunner.logger.error(msg + url)
+          parentRunner.logger.error(msg + diag);
       else
           parentRunner.logger.log(msg);
   } else {
-      msg += " | " + test.diag;
       if (test.todo)
-          parentRunner.logger.log(msg)
+          parentRunner.logger.log(msg);
       else
-          parentRunner.logger.error(msg + url);
+          parentRunner.logger.error(msg + diag);
   }
-}
+};
 
 /**
  * Copies of is and isnot with the call to ok replaced by a call to todo.
 **/
 
@@ -109,11 +110,11 @@ SimpleTest.report = function () {
     var results = MochiKit.Base.map(
         function (test) {
             var cls, msg;
             if (test.todo && !test.result) {
                 todo++;
-                cls = "test_todo"
+                cls = "test_todo";
                 msg = "todo - " + test.name + " " + test.diag;
             } else if (test.result &&!test.todo) {
                 passed++;
                 cls = "test_ok";
                 msg = "ok - " + test.name;
@@ -199,21 +200,21 @@ SimpleTest.waitForExplicitFinish = funct
 SimpleTest.waitForExplicitFinish = function () {
     SimpleTest._stopOnLoad = false;
 };
 
 /**
- * Talks to the TestRunner if being ran on a iframe and the parent has a 
+ * Talks to the TestRunner if being ran on a iframe and the parent has a
  * TestRunner object.
 **/
 SimpleTest.talkToRunner = function () {
     if (parentRunner) {
         parentRunner.testFinished(document);
     }
 };
 
 /**
- * Finishes the tests. This is automatically called, except when 
+ * Finishes the tests. This is automatically called, except when
  * SimpleTest.waitForExplicitFinish() has been invoked.
 **/
 SimpleTest.finish = function () {
     SimpleTest.showReport();
     SimpleTest.talkToRunner();
@@ -377,11 +378,11 @@ SimpleTest._formatStack = function (stac
         }
     }
 
     out += vars[0] + ' = ' + vals[0] + SimpleTest.LF;
     out += vars[1] + ' = ' + vals[1] + SimpleTest.LF;
-    
+
     return '    ' + out;
 };
 
 
 SimpleTest.isDeeply = function (it, as, name) {
diff -r 6c8c95fcaf9b toolkit/components/places/src/nsNavHistoryExpire.cpp
--- a/toolkit/components/places/src/nsNavHistoryExpire.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/toolkit/components/places/src/nsNavHistoryExpire.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -974,21 +974,28 @@ nsNavHistoryExpire::ExpireAnnotationsPar
 }
 
 
 // nsNavHistoryExpire::ExpireInputHistoryParanoid
 //
-//    Deletes dangling input history
+//    Deletes dangling input history, decay potentially unused entries
 
 nsresult
 nsNavHistoryExpire::ExpireInputHistoryParanoid(mozIStorageConnection* aConnection)
 {
   // Delete dangling input history that have no associated pages
   nsresult rv = aConnection->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
     "DELETE FROM moz_inputhistory WHERE place_id IN "
     "(SELECT i.place_id FROM moz_inputhistory i "
       "LEFT OUTER JOIN moz_places h ON i.place_id = h.id "
       "WHERE h.id IS NULL)"));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // Decay potentially unused entries (e.g. those that are at 1) to allow
+  // better chances for new entries that will start at 1
+  rv = aConnection->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+    "UPDATE moz_inputhistory "
+    "SET use_count = use_count * .9"));
   NS_ENSURE_SUCCESS(rv, rv);
 
   return NS_OK;
 }
 
diff -r 6c8c95fcaf9b toolkit/components/typeaheadfind/src/nsTypeAheadFind.cpp
--- a/toolkit/components/typeaheadfind/src/nsTypeAheadFind.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/toolkit/components/typeaheadfind/src/nsTypeAheadFind.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -80,11 +80,10 @@
 #include "nsTextFragment.h"
 #include "nsIDOMNSEditableElement.h"
 #include "nsIDOMNSHTMLElement.h"
 #include "nsIEditor.h"
 
-#include "nsICaret.h"
 #include "nsIDocShellTreeItem.h"
 #include "nsIWebNavigation.h"
 #include "nsIInterfaceRequestor.h"
 #include "nsIInterfaceRequestorUtils.h"
 #include "nsContentCID.h"
diff -r 6c8c95fcaf9b toolkit/content/tests/chrome/Makefile.in
--- a/toolkit/content/tests/chrome/Makefile.in	Tue Jul 15 15:16:43 2008 +1200
+++ b/toolkit/content/tests/chrome/Makefile.in	Thu Jul 17 14:13:04 2008 +0300
@@ -62,10 +62,11 @@ _TEST_FILES = 	findbar_window.xul \
 		test_popup_anchor.xul \
 		window_popup_anchor.xul \
 		frame_popup_anchor.xul \
 		test_preferences.xul \
 		window_preferences.xul \
+		test_autocomplete2.xul \
 		$(NULL)
 
 ifeq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
 _TEST_FILES += test_panel_focus.xul \
                window_panel_focus.xul
diff -r 6c8c95fcaf9b toolkit/content/tests/chrome/test_autocomplete2.xul
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/content/tests/chrome/test_autocomplete2.xul	Thu Jul 17 14:13:04 2008 +0300
@@ -0,0 +1,131 @@
+<?xml version="1.0"?>
+<?xml-stylesheet href="chrome://global/skin" type="text/css"?>
+<?xml-stylesheet href="chrome://mochikit/content/tests/SimpleTest/test.css" type="text/css"?>
+
+<window title="Autocomplete Widget Test 2"
+        xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
+
+  <script type="application/javascript" 
+          src="chrome://mochikit/content/MochiKit/packed.js"/>
+  <script type="application/javascript"
+          src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"/>
+  <script type="application/javascript"
+          src="chrome://mochikit/content/tests/SimpleTest/EventUtils.js"/>
+
+<textbox id="autocomplete" type="autocomplete"
+         autocompletesearch="simple"
+         onsearchcomplete="checkResult();"/>
+
+<script class="testbody" type="application/javascript">
+<![CDATA[
+
+// Set to indicate whether or not we want autoCompleteSimple to return a result
+var returnResult = false;
+
+const ACR = Components.interfaces.nsIAutoCompleteResult;
+
+// This result can't be constructed in-line, because otherwise we leak memory.
+function nsAutoCompleteSimpleResult(aString)
+{
+  this.searchString = aString;
+  if (returnResult) {
+    this.searchResult = ACR.RESULT_SUCCESS;
+    this.matchCount = 1;
+    this._param = "SUCCESS";
+  }
+}
+
+nsAutoCompleteSimpleResult.prototype = {
+ _param: "",
+ searchString: null,
+ searchResult: ACR.RESULT_FAILURE,
+ defaultIndex: -1,
+ errorDescription: null,
+ matchCount: 0,
+ getValueAt: function() { return this._param; },
+ getCommentAt: function() { return null; },
+ getStyleAt: function() { return null; },
+ getImageAt: function() { return null; },
+ removeValueAt: function() {}
+};
+
+// A basic autocomplete implementation that either returns one result or none
+var autoCompleteSimpleID = Components.ID("0a2afbdb-f30e-47d1-9cb1-0cd160240aca");
+var autoCompleteSimpleName = "@mozilla.org/autocomplete/search;1?name=simple"
+var autoCompleteSimple = {
+  QueryInterface: function(iid) {
+    if (iid.equals(Components.interfaces.nsISupports) ||
+        iid.equals(Components.interfaces.nsIFactory) ||
+        iid.equals(Components.interfaces.nsIAutoCompleteSearch))
+      return this;
+
+    throw Components.results.NS_ERROR_NO_INTERFACE;
+  },
+
+  createInstance: function(outer, iid) {
+    return this.QueryInterface(iid);
+  },
+
+  startSearch: function(aString, aParam, aResult, aListener) {
+    var result = new nsAutoCompleteSimpleResult(aString);
+    aListener.onSearchResult(this, result);
+  },
+
+  stopSearch: function() {}
+};
+
+var componentManager = Components.manager
+                                 .QueryInterface(Components.interfaces.nsIComponentRegistrar);
+componentManager.registerFactory(autoCompleteSimpleID, "Test Simple Autocomplete",
+                                 autoCompleteSimpleName, autoCompleteSimple);
+
+
+// The main test code.
+
+SimpleTest.waitForExplicitFinish();
+setTimeout(check, 0);
+
+function check() {
+  var autocomplete = $("autocomplete");
+
+  // Toggle this value, so we can re-use the one function.
+  returnResult = !returnResult;
+
+  autocomplete.focus();
+  synthesizeKey("r", {});
+}
+
+function checkResult() {
+  var autocomplete = $("autocomplete");
+
+  if (returnResult) {
+    // Result was returned, so there should not be a nomatch attribute
+    is(autocomplete.hasAttribute("nomatch"), false,
+       "nomatch attribute shouldn't be present here");
+    setTimeout(check, 0);
+  }
+  else {
+    // No result was returned, so there should be nomatch attribute
+    is(autocomplete.getAttribute("nomatch"), "true",
+       "nomatch attribute not correctly set when expected");
+    setTimeout(function() {
+      // Unregister the factory so that we don't get in the way of other tests
+      componentManager.unregisterFactory(autoCompleteSimpleID, autoCompleteSimple);
+      SimpleTest.finish();
+    }, 0);
+  }
+}
+
+]]>
+</script>
+
+<body xmlns="http://www.w3.org/1999/xhtml">
+<p id="display">
+</p>
+<div id="content" style="display: none">
+</div>
+<pre id="test">
+</pre>
+</body>
+
+</window>
diff -r 6c8c95fcaf9b toolkit/content/widgets/autocomplete.xml
--- a/toolkit/content/widgets/autocomplete.xml	Tue Jul 15 15:16:43 2008 +1200
+++ b/toolkit/content/widgets/autocomplete.xml	Thu Jul 17 14:13:04 2008 +0300
@@ -208,13 +208,13 @@
       </method>
 
       <method name="onSearchComplete">
         <body><![CDATA[
           if (this.mController.matchCount == 0)
-            this.popup.setAttribute("nomatch", "true");
+            this.setAttribute("nomatch", "true");
           else
-            this.popup.removeAttribute("nomatch");
+            this.removeAttribute("nomatch");
 
           this.fireEvent("searchcomplete");
         ]]></body>
       </method>
 
diff -r 6c8c95fcaf9b toolkit/crashreporter/content/crashes.xhtml
--- a/toolkit/crashreporter/content/crashes.xhtml	Tue Jul 15 15:16:43 2008 +1200
+++ b/toolkit/crashreporter/content/crashes.xhtml	Thu Jul 17 14:13:04 2008 +0300
@@ -6,15 +6,10 @@
   <!ENTITY % crashesDTD SYSTEM "chrome://global/locale/crashes.dtd">
   %globalDTD;
   %crashesDTD;
 ]>
 
-#ifdef MOZ_THUNDERBIRD
-#ifdef XP_MACOSX
-#define FORCE_DIR
-#endif
-#endif
 <html xmlns="http://www.w3.org/1999/xhtml">
 <head>
 <style type="text/css">
 :root {
   font-family: sans-serif;
@@ -99,21 +94,11 @@ function populateReportList() {
     return;
   }
   var directoryService = Cc["@mozilla.org/file/directory_service;1"].
                          getService(Ci.nsIProperties);
 
-#ifdef FORCE_DIR
-  var app = Cc["@mozilla.org/xre/app-info;1"].
-            getService(Ci.nsIXULAppInfo);
-
-  // Doesn't appear to be a key for the app support directory
-  reportsDir = directoryService.get("ULibDir", Ci.nsIFile);
-  reportsDir.append("Application Support");
-  reportsDir.append(app.name);
-#else
   reportsDir = directoryService.get("UAppData", Ci.nsIFile);
-#endif
   reportsDir.append("Crash Reports");
   reportsDir.append("submitted");
 
   var reports = [];
   if (reportsDir.exists() && reportsDir.isDirectory()) {
diff -r 6c8c95fcaf9b toolkit/crashreporter/jar.mn
--- a/toolkit/crashreporter/jar.mn	Tue Jul 15 15:16:43 2008 +1200
+++ b/toolkit/crashreporter/jar.mn	Thu Jul 17 14:13:04 2008 +0300
@@ -1,2 +1,2 @@ toolkit.jar:
 toolkit.jar:
-*+ content/global/crashes.xhtml              (content/crashes.xhtml) 
+  content/global/crashes.xhtml              (content/crashes.xhtml)
diff -r 6c8c95fcaf9b toolkit/library/Makefile.in
--- a/toolkit/library/Makefile.in	Tue Jul 15 15:16:43 2008 +1200
+++ b/toolkit/library/Makefile.in	Thu Jul 17 14:13:04 2008 +0300
@@ -210,10 +210,14 @@ ifeq (gtk2,$(MOZ_WIDGET_TOOLKIT))
 ifeq (gtk2,$(MOZ_WIDGET_TOOLKIT))
 EXTRA_DSO_LDOPTS += $(XLDFLAGS) $(XLIBS) $(MOZ_XFT_LIBS) $(MOZ_GTK2_LIBS) $(XT_LIBS) -lgthread-2.0
 EXTRA_DSO_LDOPTS += $(FT2_LIBS)
 endif
 
+ifdef NS_OSSO
+EXTRA_DSO_LDOPTS += -llocation -lgpsbt
+endif
+
 ifdef MOZ_ENABLE_STARTUP_NOTIFICATION
 EXTRA_DSO_LDOPTS += $(MOZ_STARTUP_NOTIFICATION_LIBS)
 endif
 
 ifeq ($(OS_ARCH),BeOS)
diff -r 6c8c95fcaf9b toolkit/locales/l10n.ini
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/locales/l10n.ini	Thu Jul 17 14:13:04 2008 +0300
@@ -0,0 +1,8 @@
+[general]
+depth = ../..
+
+[compare]
+dirs = netwerk
+     dom
+     toolkit
+     security/manager
diff -r 6c8c95fcaf9b toolkit/mozapps/extensions/content/extensions.js
--- a/toolkit/mozapps/extensions/content/extensions.js	Tue Jul 15 15:16:43 2008 +1200
+++ b/toolkit/mozapps/extensions/content/extensions.js	Thu Jul 17 14:13:04 2008 +0300
@@ -925,10 +925,11 @@ function rebuildPluginsDS()
       // used to provide access to a plugins homepage in the add-ons mgr.
       if (/<A\s+HREF=[^>]*>/i.test(plugin.description))
         homepageURL = /<A\s+HREF=["']?([^>"'\s]*)/i.exec(plugin.description)[1];
 
       gPlugins[name][desc] = { filename    : plugin.filename,
+                               version     : plugin.version,
                                homepageURL : homepageURL,
                                disabled    : plugin.disabled,
                                blocklisted : plugin.blocklisted,
                                plugins     : [] };
     }
@@ -941,10 +942,14 @@ function rebuildPluginsDS()
       var pluginNode = gRDF.GetResource(PREFIX_ITEM_URI + plugin.filename);
       rootctr.AppendElement(pluginNode);
       gPluginsDS.Assert(pluginNode,
                         gRDF.GetResource(PREFIX_NS_EM + "name"),
                         gRDF.GetLiteral(pluginName),
+                        true);
+      gPluginsDS.Assert(pluginNode,
+                        gRDF.GetResource(PREFIX_NS_EM + "version"),
+                        gRDF.GetLiteral(plugin.version),
                         true);
       gPluginsDS.Assert(pluginNode,
                         gRDF.GetResource(PREFIX_NS_EM + "addonID"),
                         gRDF.GetLiteral(plugin.filename),
                         true);
diff -r 6c8c95fcaf9b toolkit/xre/MacApplicationDelegate.mm
--- a/toolkit/xre/MacApplicationDelegate.mm	Tue Jul 15 15:16:43 2008 +1200
+++ b/toolkit/xre/MacApplicationDelegate.mm	Thu Jul 17 14:13:04 2008 +0300
@@ -243,13 +243,16 @@ static NSWindow* GetCocoaWindowForXULWin
     rv = windowList->GetNext(getter_AddRefs(xulWindow));
     NS_ENSURE_SUCCESS(rv, nil);
     NSWindow *cocoaWindow = GetCocoaWindowForXULWindow(xulWindow);
     if (!cocoaWindow) continue;
     
+    NSString *windowTitle = [cocoaWindow title];
+    if (!windowTitle) continue;
+    
     // Now, create a menu item, and add it to the menu
     NSMenuItem *menuItem = [[NSMenuItem alloc]
-                              initWithTitle:[cocoaWindow title]
+                              initWithTitle:windowTitle
                                      action:@selector(dockMenuItemSelected:)
                               keyEquivalent:@""];
     [menuItem setTarget:self];
     [menuItem setRepresentedObject:cocoaWindow];
 
diff -r 6c8c95fcaf9b tools/test-harness/xpcshell-simple/head.js
--- a/tools/test-harness/xpcshell-simple/head.js	Tue Jul 15 15:16:43 2008 +1200
+++ b/tools/test-harness/xpcshell-simple/head.js	Thu Jul 17 14:13:04 2008 +0300
@@ -90,38 +90,48 @@ function do_timeout(delay, expr) {
   var timer = Components.classes["@mozilla.org/timer;1"]
                         .createInstance(Components.interfaces.nsITimer);
   timer.initWithCallback(new _TimerCallback(expr), delay, timer.TYPE_ONE_SHOT);
 }
 
-function do_throw(text) {
+function do_throw(text, stack) {
+  if (!stack)
+    stack = Components.stack.caller;
   _fail = true;
   _do_quit();
-  dump("*** CHECK FAILED: " + text + "\n");
+  dump("*** TEST-UNEXPECTED-FAIL | " + stack.filename + " | " + text + "\n");
   var frame = Components.stack;
   while (frame != null) {
     dump(frame + "\n");
     frame = frame.caller;
   }
   throw Components.results.NS_ERROR_ABORT;
 }
 
-function do_check_neq(left, right) {
+function do_check_neq(left, right, stack) {
+  if (!stack)
+    stack = Components.stack.caller;
   if (left == right)
-    do_throw(left + " != " + right);
+    do_throw(left + " != " + right, stack);
 }
 
-function do_check_eq(left, right) {
+function do_check_eq(left, right, stack) {
+  if (!stack)
+    stack = Components.stack.caller;
   if (left != right)
-    do_throw(left + " == " + right);
+    do_throw(left + " == " + right, stack);
 }
 
-function do_check_true(condition) {
-  do_check_eq(condition, true);
+function do_check_true(condition, stack) {
+  if (!stack)
+    stack = Components.stack.caller;
+  do_check_eq(condition, true, stack);
 }
 
-function do_check_false(condition) {
-  do_check_eq(condition, false);
+function do_check_false(condition, stack) {
+  if (!stack)
+    stack = Components.stack.caller;
+  do_check_eq(condition, false, stack);
 }
 
 function do_test_pending() {
   dump("*** test pending\n");
   _tests_pending++;
diff -r 6c8c95fcaf9b tools/test-harness/xpcshell-simple/test_all.sh
--- a/tools/test-harness/xpcshell-simple/test_all.sh	Tue Jul 15 15:16:43 2008 +1200
+++ b/tools/test-harness/xpcshell-simple/test_all.sh	Thu Jul 17 14:13:04 2008 +0300
@@ -108,24 +108,23 @@ done
 # RUN EACH TEST #
 #################
 
 for t in $testdir/test_*.js
 do
-    echo -n "$t: "
     NATIVE_TOPSRCDIR="$native_topsrcdir" TOPSRCDIR="$topsrcdir" $xpcshell -s $headfiles -f $t $tailfiles 2> $t.log 1>&2
     rv="$?"
     if [ ! "$rv" = "0"  -o \
          `grep -c '\*\*\* PASS' $t.log` = 0 ]
     then
-        echo "FAIL"
+        echo "TEST-UNEXPECTED-FAIL | $t | test failed, see log"
         echo "$t.log:"
         echo ">>>>>>>"
         cat $t.log
         echo ""
         echo "<<<<<<<"
         exit_status=1
     else
-        echo "PASS"
+        echo "TEST-PASS | $t | all tests passed"
     fi
 done
 
 exit $exit_status
diff -r 6c8c95fcaf9b widget/src/gtk2/nsNativeThemeGTK.cpp
--- a/widget/src/gtk2/nsNativeThemeGTK.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/widget/src/gtk2/nsNativeThemeGTK.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -665,23 +665,22 @@ ThemeRenderer::NativeDraw(Screen* screen
     // XXX gtk+2.10 has gdk_pixmap_foreign_new_for_screen which would not
     // use XGetGeometry.
     gdkPixmap = gdk_pixmap_foreign_new_for_display(gdkDpy, drawable);
     if (!gdkPixmap)
       return NS_ERROR_FAILURE;
-    if (visual) {
-      // We requested that gfxXlibNativeRenderer give us the default screen
-      GdkScreen* gdkScreen = gdk_display_get_default_screen(gdkDpy);
-      NS_ASSERTION(screen == GDK_SCREEN_XSCREEN(gdkScreen),
-                   "'screen' should be the default Screen");
-      // GDK requires a GdkColormap to be set on the GdkPixmap.
-      GdkVisual* gdkVisual =
-        gdk_x11_screen_lookup_visual(gdkScreen, visual->visualid);
-      GdkColormap* gdkColormap =
-        gdk_x11_colormap_foreign_new(gdkVisual, colormap);
-      gdk_drawable_set_colormap(gdkPixmap, gdkColormap);
-      g_object_unref(G_OBJECT(gdkColormap));
-    }
+
+    // We requested that gfxXlibNativeRenderer give us the default screen
+    GdkScreen* gdkScreen = gdk_display_get_default_screen(gdkDpy);
+    NS_ASSERTION(screen == GDK_SCREEN_XSCREEN(gdkScreen),
+                 "'screen' should be the default Screen");
+    // GDK requires a GdkColormap to be set on the GdkPixmap.
+    GdkVisual* gdkVisual =
+      gdk_x11_screen_lookup_visual(gdkScreen, visual->visualid);
+    GdkColormap* gdkColormap =
+      gdk_x11_colormap_foreign_new(gdkVisual, colormap);
+    gdk_drawable_set_colormap(gdkPixmap, gdkColormap);
+    g_object_unref(G_OBJECT(gdkColormap));
   }
 
   NS_ASSERTION(numClipRects == 0, "We don't support clipping!!!");
   moz_gtk_widget_paint(mGTKWidgetType, gdkPixmap, &gdk_rect, &gdk_clip, &mState,
                        mFlags, mDirection);
diff -r 6c8c95fcaf9b xpcom/glue/nsTArray.cpp
--- a/xpcom/glue/nsTArray.cpp	Tue Jul 15 15:16:43 2008 +1200
+++ b/xpcom/glue/nsTArray.cpp	Thu Jul 17 14:13:04 2008 +0300
@@ -63,11 +63,11 @@ nsTArray_base::EnsureCapacity(size_type 
 
   // If the requested memory allocation exceeds size_type(-1)/2, then our
   // doubling algorithm may not be able to allocate it.  Additionally we
   // couldn't fit in the Header::mCapacity member. Just bail out in cases
   // like that.  We don't want to be allocating 2 GB+ arrays anyway.
-  if (capacity * elemSize > size_type(-1)/2) {
+  if ((PRUint64)capacity * elemSize > size_type(-1)/2) {
     NS_ERROR("Attempting to allocate excessively large array");
     return PR_FALSE;
   }
 
   if (mHdr == &sEmptyHdr) {
