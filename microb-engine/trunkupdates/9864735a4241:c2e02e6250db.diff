diff -r 9864735a4241 .hgtags
--- a/.hgtags	Mon Sep 22 11:50:03 2008 -0700
+++ b/.hgtags	Fri Sep 26 09:30:25 2008 -0500
@@ -5,8 +5,11 @@ 9d9941eacb14827fdab4716710042fdde84eb60d
 9d9941eacb14827fdab4716710042fdde84eb60d FIREFOX_3_1a1_RELEASE
 9d9941eacb14827fdab4716710042fdde84eb60d FIREFOX_3_1a1_BUILD1
 c1d7e318a27574c995631fec166ad42672475702 FIREFOX_3_1a1_BUILD2
 c1d7e318a27574c995631fec166ad42672475702 FIREFOX_3_1a1_RELEASE
 afc4ee509d9ca3bb4031015c3c22963dcb4b7e7f FIREFOX_3_1a1_RELEASE
 afc4ee509d9ca3bb4031015c3c22963dcb4b7e7f FIREFOX_3_1a1_BUILD2
 f197b51bbc29a30860e750ee87fd0a047a024f2e FIREFOX_3_1a2_BUILD1
 f197b51bbc29a30860e750ee87fd0a047a024f2e FIREFOX_3_1a2_RELEASE
+269af1ed75649989575d41f53a12048015c6d50e FENNEC_M8
+920a4326d1087b174c2fa2b9a8358e12c697022c SEAMONKEY_2_0a1_BUILD1
+920a4326d1087b174c2fa2b9a8358e12c697022c SEAMONKEY_2_0a1_RELEASE
diff -r 9864735a4241 browser/app/Makefile.in
--- a/browser/app/Makefile.in	Mon Sep 22 11:50:03 2008 -0700
+++ b/browser/app/Makefile.in	Fri Sep 26 09:30:25 2008 -0500
@@ -67,17 +67,17 @@ DEFINES += -DAPP_UA_NAME="$(APP_UA_NAME)
 
 DIST_FILES = application.ini
 
 GRE_MILESTONE = $(shell $(PYTHON) $(topsrcdir)/config/printconfigsetting.py $(LIBXUL_DIST)/bin/platform.ini Build Milestone)
 GRE_BUILDID = $(shell $(PYTHON) $(topsrcdir)/config/printconfigsetting.py $(LIBXUL_DIST)/bin/platform.ini Build BuildID)
 
 DEFINES += -DGRE_MILESTONE=$(GRE_MILESTONE) -DGRE_BUILDID=$(GRE_BUILDID)
 
-SOURCE_STAMP := $(shell hg identify -i $(topsrcdir) 2>/dev/null)
+SOURCE_STAMP := $(shell cd $(topsrcdir) ; hg identify 2>/dev/null | cut -f1 -d' ')
 ifdef SOURCE_STAMP
 DEFINES += -DMOZ_SOURCE_STAMP="$(SOURCE_STAMP)"
 endif
 
 SOURCE_REPO := $(shell hg -R $(topsrcdir) showconfig paths.default 2>/dev/null | sed s/^ssh:/http:/)
 ifdef SOURCE_REPO
 DEFINES += -DMOZ_SOURCE_REPO="$(SOURCE_REPO)"
 endif
diff -r 9864735a4241 browser/components/places/content/toolbar.xml
--- a/browser/components/places/content/toolbar.xml	Mon Sep 22 11:50:03 2008 -0700
+++ b/browser/components/places/content/toolbar.xml	Fri Sep 26 09:30:25 2008 -0500
@@ -1192,17 +1192,17 @@
             !PlacesControllerDragHelper.getSession())
           this._openedMenuButton = null;
       ]]></handler>
 
       <handler event="mousedown"><![CDATA[
         // Allow drag and drop of folders in Linux.
         // We must prevent popupshowing event from firing when shift is pressed.
         var target = event.originalTarget;
-        if (event.button == 1 && event.shiftKey &&
+        if (event.button == 0 && event.shiftKey &&
             target.localName == "toolbarbutton" && target.type == "menu")
           this._draggingContainer = true;
       ]]></handler>
 
       <handler event="mousemove"><![CDATA[
         if (this._openedMenuButton == null ||
             PlacesControllerDragHelper.getSession())
           return;
diff -r 9864735a4241 browser/components/preferences/tabs.js
--- a/browser/components/preferences/tabs.js	Mon Sep 22 11:50:03 2008 -0700
+++ b/browser/components/preferences/tabs.js	Fri Sep 26 09:30:25 2008 -0500
@@ -66,31 +66,30 @@ var gTabsPane = {
    * browser.tabs.warnOnOpen
    * - true if the user should be warned if he attempts to open a lot of tabs at
    *   once (e.g. a large folder of bookmarks), false otherwise
    */
 
   /**
    * Determines where a link which opens a new window will open.
    *
-   * @returns 2 if such links should be opened in new windows,
-   *          3 if such links should be opened in new tabs
+   * @returns |true| if such links should be opened in new tabs
    */
   readLinkTarget: function() {
     var openExternal = document.getElementById("browser.link.open_external");
-    return openExternal.value != 2 ? 3 : 2;
+    return openExternal.value != 2;
   },
 
   /**
    * Ensures that pages opened in new windows by web pages and pages opened by
    * external applications both open in the same way (e.g. in a new tab, window,
    * etc.).
    *
    * @returns 2 if such links should be opened in new windows,
    *          3 if such links should be opened in new tabs
    */
   writeLinkTarget: function() {
     var linkTargeting = document.getElementById("linkTargeting");
-    document.getElementById("browser.link.open_newwindow").value = linkTargeting.value;
-    return linkTargeting.value;
+    var linkTarget = linkTargeting.checked ? 3 : 2;
+    document.getElementById("browser.link.open_newwindow").value = linkTarget;
+    return linkTarget;
   }
 };
-
diff -r 9864735a4241 browser/components/preferences/tabs.xul
--- a/browser/components/preferences/tabs.xul	Mon Sep 22 11:50:03 2008 -0700
+++ b/browser/components/preferences/tabs.xul	Fri Sep 26 09:30:25 2008 -0500
@@ -58,32 +58,24 @@
       <preference id="browser.tabs.autoHide"           name="browser.tabs.autoHide"           type="bool" inverted="true"/>
       <preference id="browser.tabs.loadInBackground"   name="browser.tabs.loadInBackground"   type="bool" inverted="true"/>
       <preference id="browser.tabs.warnOnClose"        name="browser.tabs.warnOnClose"        type="bool"/>
       <preference id="browser.tabs.warnOnOpen"         name="browser.tabs.warnOnOpen"         type="bool"/>
     </preferences>
     
     <script type="application/x-javascript" src="chrome://browser/content/preferences/tabs.js"/>
 
-    <vbox id="linksOpenInBox">
-      <label control="linkTargeting">&newPagesIn.label;</label>
-      <radiogroup id="linkTargeting" class="indent"
-                  preference="browser.link.open_external"
-                  onsyncfrompreference="return gTabsPane.readLinkTarget();"
-                  onsynctopreference="return gTabsPane.writeLinkTarget();">
-        <radio label="&inNewWindow.label;" accesskey="&inNewWindow.accesskey;" value="2"/>
-        <radio label="&inNewTab.label;" accesskey="&inNewTab.accesskey;" value="3"/>
-      </radiogroup>
-    </vbox>
-
-    <separator id="tabsSeparator"/>
-
     <!-- XXX flex below is a hack because wrapping checkboxes don't reflow
              properly; see bug 349098 -->
     <vbox id="tabPrefsBox" align="start" flex="1">
+      <checkbox id="linkTargeting" label="&newWindowsAsTabs.label;"
+                accesskey="&newWindowsAsTabs.accesskey;"
+                preference="browser.link.open_external"
+                onsyncfrompreference="return gTabsPane.readLinkTarget();"
+                onsynctopreference="return gTabsPane.writeLinkTarget();"/>
       <checkbox id="warnCloseMultiple" label="&warnCloseMultipleTabs.label;"
                 accesskey="&warnCloseMultipleTabs.accesskey;"
                 preference="browser.tabs.warnOnClose"/>
       <checkbox id="warnOpenMany" label="&warnOpenManyTabs.label;"
                 accesskey="&warnOpenManyTabs.accesskey;"
                 preference="browser.tabs.warnOnOpen"/>
       <checkbox id="showTabBar" label="&showTabBar.label;"
                 accesskey="&showTabBar.accesskey;"
diff -r 9864735a4241 browser/locales/en-US/chrome/browser/preferences/tabs.dtd
--- a/browser/locales/en-US/chrome/browser/preferences/tabs.dtd	Mon Sep 22 11:50:03 2008 -0700
+++ b/browser/locales/en-US/chrome/browser/preferences/tabs.dtd	Fri Sep 26 09:30:25 2008 -0500
@@ -1,13 +1,10 @@
-<!ENTITY newPagesIn.label             "New pages should be opened in:">
-<!ENTITY inNewWindow.label            "a new window">
-<!ENTITY inNewWindow.accesskey        "w">
-<!ENTITY inNewTab.label               "a new tab">
-<!ENTITY inNewTab.accesskey           "t">
+<!ENTITY newWindowsAsTabs.label       "Open new windows in a new tab instead">
+<!ENTITY newWindowsAsTabs.accesskey   "t">
 
 <!ENTITY warnCloseMultipleTabs.label  "Warn me when closing multiple tabs">
 <!ENTITY warnCloseMultipleTabs.accesskey  "m">
 
 <!ENTITY warnOpenManyTabs.label       "Warn me when opening multiple tabs might slow down &brandShortName;">
 <!ENTITY warnOpenManyTabs.accesskey   "o">
 
 <!ENTITY showTabBar.label             "Always show the tab bar">
diff -r 9864735a4241 build/wince/shunt/assert.cpp
--- a/build/wince/shunt/assert.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/build/wince/shunt/assert.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -42,19 +42,17 @@
 
 extern "C" {
 #if 0
 }
 #endif
 
 MOZCE_SHUNT_API void mozce_assert(int inExpression)
 {
-#ifdef API_LOGGING
-    mozce_printf("mozce_assert called\n");
-#endif
+    WINCE_LOG_API_CALL("mozce_assert called\n");
 
     if(0 == inExpression)
     {
         DebugBreak();
     }
 }
 
 #if 0
diff -r 9864735a4241 build/wince/shunt/build/vs9/mozce_shunt_static.sln
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/build/wince/shunt/build/vs9/mozce_shunt_static.sln	Fri Sep 26 09:30:25 2008 -0500
@@ -0,0 +1,62 @@
+ï»¿
+Microsoft Visual Studio Solution File, Format Version 10.00
+# Visual Studio 2008
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "mozce_shunt_static", "mozce_shunt_static.vcproj", "{082BAB06-D10F-4C57-B123-F84DC06C246D}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Pocket PC 2003 (ARMV4) = Debug|Pocket PC 2003 (ARMV4)
+		Debug|Smartphone 2003 (ARMV4) = Debug|Smartphone 2003 (ARMV4)
+		Debug|Windows Mobile 5.0 Pocket PC SDK (ARMV4I) = Debug|Windows Mobile 5.0 Pocket PC SDK (ARMV4I)
+		Debug|Windows Mobile 5.0 Smartphone SDK (ARMV4I) = Debug|Windows Mobile 5.0 Smartphone SDK (ARMV4I)
+		Debug|Windows Mobile 6 Professional SDK (ARMV4I) = Debug|Windows Mobile 6 Professional SDK (ARMV4I)
+		Debug|Windows Mobile 6 Standard SDK (ARMV4I) = Debug|Windows Mobile 6 Standard SDK (ARMV4I)
+		Release|Pocket PC 2003 (ARMV4) = Release|Pocket PC 2003 (ARMV4)
+		Release|Smartphone 2003 (ARMV4) = Release|Smartphone 2003 (ARMV4)
+		Release|Windows Mobile 5.0 Pocket PC SDK (ARMV4I) = Release|Windows Mobile 5.0 Pocket PC SDK (ARMV4I)
+		Release|Windows Mobile 5.0 Smartphone SDK (ARMV4I) = Release|Windows Mobile 5.0 Smartphone SDK (ARMV4I)
+		Release|Windows Mobile 6 Professional SDK (ARMV4I) = Release|Windows Mobile 6 Professional SDK (ARMV4I)
+		Release|Windows Mobile 6 Standard SDK (ARMV4I) = Release|Windows Mobile 6 Standard SDK (ARMV4I)
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Debug|Pocket PC 2003 (ARMV4).ActiveCfg = Debug|Pocket PC 2003 (ARMV4)
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Debug|Pocket PC 2003 (ARMV4).Build.0 = Debug|Pocket PC 2003 (ARMV4)
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Debug|Pocket PC 2003 (ARMV4).Deploy.0 = Debug|Pocket PC 2003 (ARMV4)
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Debug|Smartphone 2003 (ARMV4).ActiveCfg = Debug|Smartphone 2003 (ARMV4)
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Debug|Smartphone 2003 (ARMV4).Build.0 = Debug|Smartphone 2003 (ARMV4)
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Debug|Smartphone 2003 (ARMV4).Deploy.0 = Debug|Smartphone 2003 (ARMV4)
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Debug|Windows Mobile 5.0 Pocket PC SDK (ARMV4I).ActiveCfg = Debug|Windows Mobile 5.0 Pocket PC SDK (ARMV4I)
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Debug|Windows Mobile 5.0 Pocket PC SDK (ARMV4I).Build.0 = Debug|Windows Mobile 5.0 Pocket PC SDK (ARMV4I)
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Debug|Windows Mobile 5.0 Pocket PC SDK (ARMV4I).Deploy.0 = Debug|Windows Mobile 5.0 Pocket PC SDK (ARMV4I)
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Debug|Windows Mobile 5.0 Smartphone SDK (ARMV4I).ActiveCfg = Debug|Windows Mobile 5.0 Smartphone SDK (ARMV4I)
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Debug|Windows Mobile 5.0 Smartphone SDK (ARMV4I).Build.0 = Debug|Windows Mobile 5.0 Smartphone SDK (ARMV4I)
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Debug|Windows Mobile 5.0 Smartphone SDK (ARMV4I).Deploy.0 = Debug|Windows Mobile 5.0 Smartphone SDK (ARMV4I)
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Debug|Windows Mobile 6 Professional SDK (ARMV4I).ActiveCfg = Debug|Windows Mobile 6 Professional SDK (ARMV4I)
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Debug|Windows Mobile 6 Professional SDK (ARMV4I).Build.0 = Debug|Windows Mobile 6 Professional SDK (ARMV4I)
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Debug|Windows Mobile 6 Professional SDK (ARMV4I).Deploy.0 = Debug|Windows Mobile 6 Professional SDK (ARMV4I)
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Debug|Windows Mobile 6 Standard SDK (ARMV4I).ActiveCfg = Debug|Windows Mobile 6 Standard SDK (ARMV4I)
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Debug|Windows Mobile 6 Standard SDK (ARMV4I).Build.0 = Debug|Windows Mobile 6 Standard SDK (ARMV4I)
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Debug|Windows Mobile 6 Standard SDK (ARMV4I).Deploy.0 = Debug|Windows Mobile 6 Standard SDK (ARMV4I)
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Release|Pocket PC 2003 (ARMV4).ActiveCfg = Release|Pocket PC 2003 (ARMV4)
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Release|Pocket PC 2003 (ARMV4).Build.0 = Release|Pocket PC 2003 (ARMV4)
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Release|Pocket PC 2003 (ARMV4).Deploy.0 = Release|Pocket PC 2003 (ARMV4)
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Release|Smartphone 2003 (ARMV4).ActiveCfg = Release|Smartphone 2003 (ARMV4)
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Release|Smartphone 2003 (ARMV4).Build.0 = Release|Smartphone 2003 (ARMV4)
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Release|Smartphone 2003 (ARMV4).Deploy.0 = Release|Smartphone 2003 (ARMV4)
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Release|Windows Mobile 5.0 Pocket PC SDK (ARMV4I).ActiveCfg = Release|Windows Mobile 5.0 Pocket PC SDK (ARMV4I)
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Release|Windows Mobile 5.0 Pocket PC SDK (ARMV4I).Build.0 = Release|Windows Mobile 5.0 Pocket PC SDK (ARMV4I)
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Release|Windows Mobile 5.0 Pocket PC SDK (ARMV4I).Deploy.0 = Release|Windows Mobile 5.0 Pocket PC SDK (ARMV4I)
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Release|Windows Mobile 5.0 Smartphone SDK (ARMV4I).ActiveCfg = Release|Windows Mobile 5.0 Smartphone SDK (ARMV4I)
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Release|Windows Mobile 5.0 Smartphone SDK (ARMV4I).Build.0 = Release|Windows Mobile 5.0 Smartphone SDK (ARMV4I)
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Release|Windows Mobile 5.0 Smartphone SDK (ARMV4I).Deploy.0 = Release|Windows Mobile 5.0 Smartphone SDK (ARMV4I)
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Release|Windows Mobile 6 Professional SDK (ARMV4I).ActiveCfg = Release|Windows Mobile 6 Professional SDK (ARMV4I)
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Release|Windows Mobile 6 Professional SDK (ARMV4I).Build.0 = Release|Windows Mobile 6 Professional SDK (ARMV4I)
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Release|Windows Mobile 6 Professional SDK (ARMV4I).Deploy.0 = Release|Windows Mobile 6 Professional SDK (ARMV4I)
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Release|Windows Mobile 6 Standard SDK (ARMV4I).ActiveCfg = Release|Windows Mobile 6 Standard SDK (ARMV4I)
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Release|Windows Mobile 6 Standard SDK (ARMV4I).Build.0 = Release|Windows Mobile 6 Standard SDK (ARMV4I)
+		{082BAB06-D10F-4C57-B123-F84DC06C246D}.Release|Windows Mobile 6 Standard SDK (ARMV4I).Deploy.0 = Release|Windows Mobile 6 Standard SDK (ARMV4I)
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -r 9864735a4241 build/wince/shunt/build/vs9/mozce_shunt_static.vcproj
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/build/wince/shunt/build/vs9/mozce_shunt_static.vcproj	Fri Sep 26 09:30:25 2008 -0500
@@ -0,0 +1,1261 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="mozce_shunt_static"
+	ProjectGUID="{082BAB06-D10F-4C57-B123-F84DC06C246D}"
+	RootNamespace="mozce_shunt_static"
+	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
+	>
+	<Platforms>
+		<Platform
+			Name="Pocket PC 2003 (ARMV4)"
+		/>
+		<Platform
+			Name="Smartphone 2003 (ARMV4)"
+		/>
+		<Platform
+			Name="Windows Mobile 5.0 Pocket PC SDK (ARMV4I)"
+		/>
+		<Platform
+			Name="Windows Mobile 5.0 Smartphone SDK (ARMV4I)"
+		/>
+		<Platform
+			Name="Windows Mobile 6 Professional SDK (ARMV4I)"
+		/>
+		<Platform
+			Name="Windows Mobile 6 Standard SDK (ARMV4I)"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Pocket PC 2003 (ARMV4)"
+			OutputDirectory="Pocket PC 2003 (ARMV4)\$(ConfigurationName)"
+			IntermediateDirectory="Pocket PC 2003 (ARMV4)\$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="1"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);_DEBUG;DEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
+				MinimalRebuild="true"
+				ExceptionHandling="0"
+				RuntimeLibrary="1"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				TreatWChar_tAsBuiltInType="false"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				AdditionalOptions=" /subsystem:windowsce,5.01 /machine:THUMB"
+				OutputFile="$(InputDir)/shunt_dbg.lib"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory=""
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Smartphone 2003 (ARMV4)"
+			OutputDirectory="Smartphone 2003 (ARMV4)\$(ConfigurationName)"
+			IntermediateDirectory="Smartphone 2003 (ARMV4)\$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="1"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);_DEBUG;DEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
+				MinimalRebuild="true"
+				ExceptionHandling="0"
+				RuntimeLibrary="1"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				TreatWChar_tAsBuiltInType="false"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				AdditionalOptions=" /subsystem:windowsce,5.01 /machine:THUMB"
+				OutputFile="$(InputDir)/shunt_dbg.lib"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory=""
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Windows Mobile 5.0 Pocket PC SDK (ARMV4I)"
+			OutputDirectory="$(PlatformName)\Debug"
+			IntermediateDirectory="$(PlatformName)\Debug"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);_DEBUG;DEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
+				MinimalRebuild="true"
+				ExceptionHandling="0"
+				RuntimeLibrary="1"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				TreatWChar_tAsBuiltInType="false"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions=" /SUBSYSTEM:WINDOWSCE,5.01 /MACHINE:THUMB"
+				OutputFile="$(OutDir)\mozce_shunt.dll"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory=""
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Windows Mobile 5.0 Smartphone SDK (ARMV4I)"
+			OutputDirectory="Windows Mobile 5.0 Smartphone SDK (ARMV4I)\$(ConfigurationName)"
+			IntermediateDirectory="Windows Mobile 5.0 Smartphone SDK (ARMV4I)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="1"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);_DEBUG;DEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
+				MinimalRebuild="true"
+				ExceptionHandling="0"
+				RuntimeLibrary="1"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				TreatWChar_tAsBuiltInType="false"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions=" /SUBSYSTEM:WINDOWSCE,5.01 /MACHINE:THUMB"
+				OutputFile="$(OutDir)\mozce_shunt.dll"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory=""
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Windows Mobile 6 Professional SDK (ARMV4I)"
+			OutputDirectory="Windows Mobile 6 Professional SDK (ARMV4I)\$(ConfigurationName)"
+			IntermediateDirectory="Windows Mobile 6 Professional SDK (ARMV4I)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="1"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);_DEBUG;DEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_SHUNT_EXPORTS;DEBUG_NSPR_ALL;TIMELINE;API_LOGGING;WINCE_MEMORY_CHECKPOINTING;SHUNT_LOG_ENABLED"
+				MinimalRebuild="true"
+				ExceptionHandling="0"
+				RuntimeLibrary="1"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				TreatWChar_tAsBuiltInType="false"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions=" /SUBSYSTEM:WINDOWSCE,5.02"
+				OutputFile="$(OutDir)\mozce_shunt.dll"
+				GenerateDebugInformation="true"
+				ImportLibrary="$(OutDir)\mozce_shunt.lib"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy &quot;$(TargetDir)$(TargetName).dll&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;copy &quot;$(TargetDir)$(TargetName).lib&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory="\"
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Windows Mobile 6 Standard SDK (ARMV4I)"
+			OutputDirectory="Windows Mobile 6 Standard SDK (ARMV4I)\$(ConfigurationName)"
+			IntermediateDirectory="Windows Mobile 6 Standard SDK (ARMV4I)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="1"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);_DEBUG;DEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_SHUNT_EXPORTS;DEBUG_NSPR_ALL;TIMELINE;API_LOGGING;WINCE_MEMORY_CHECKPOINTING;SHUNT_LOG_ENABLED"
+				MinimalRebuild="true"
+				ExceptionHandling="0"
+				RuntimeLibrary="1"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				TreatWChar_tAsBuiltInType="false"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions=" /SUBSYSTEM:WINDOWSCE,5.02"
+				OutputFile="$(OutDir)\mozce_shunt.dll"
+				GenerateDebugInformation="true"
+				ImportLibrary="$(OutDir)\mozce_shunt.lib"
+				TargetMachine="0"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+				AuthenticodeSignature="false"
+				ProvisionDevice="0"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy &quot;$(TargetDir)$(TargetName).dll&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;copy &quot;$(TargetDir)$(TargetName).lib&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory="\"
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Pocket PC 2003 (ARMV4)"
+			OutputDirectory="Pocket PC 2003 (ARMV4)\$(ConfigurationName)"
+			IntermediateDirectory="Pocket PC 2003 (ARMV4)\$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="1"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="2"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);NDEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
+				ExceptionHandling="1"
+				RuntimeLibrary="0"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				FloatingPointModel="2"
+				TreatWChar_tAsBuiltInType="false"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+				CompileForArchitecture="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				AdditionalOptions=" /subsystem:windowsce,5.01 /machine:THUMB"
+				OutputFile="$(InputDir)/shunt.lib"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory=""
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Smartphone 2003 (ARMV4)"
+			OutputDirectory="Smartphone 2003 (ARMV4)\$(ConfigurationName)"
+			IntermediateDirectory="Smartphone 2003 (ARMV4)\$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="1"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="2"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);NDEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
+				ExceptionHandling="1"
+				RuntimeLibrary="0"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				FloatingPointModel="2"
+				TreatWChar_tAsBuiltInType="false"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+				CompileForArchitecture="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				AdditionalOptions=" /subsystem:windowsce,5.01 /machine:THUMB"
+				OutputFile="$(InputDir)/shunt.lib"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory=""
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Windows Mobile 5.0 Pocket PC SDK (ARMV4I)"
+			OutputDirectory="$(PlatformName)\Release"
+			IntermediateDirectory="$(PlatformName)\Release"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="2"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);NDEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
+				ExceptionHandling="0"
+				RuntimeLibrary="0"
+				BufferSecurityCheck="false"
+				TreatWChar_tAsBuiltInType="false"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions=" /SUBSYSTEM:WINDOWSCE,5.01 /MACHINE:THUMB"
+				OutputFile="$(OutDir)\mozce_shunt.dll"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory=""
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Windows Mobile 5.0 Smartphone SDK (ARMV4I)"
+			OutputDirectory="Windows Mobile 5.0 Smartphone SDK (ARMV4I)\$(ConfigurationName)"
+			IntermediateDirectory="Windows Mobile 5.0 Smartphone SDK (ARMV4I)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="1"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="2"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);NDEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_STATIC_BUILD;MOZCE_SHUNT_EXPORTS"
+				ExceptionHandling="0"
+				RuntimeLibrary="0"
+				BufferSecurityCheck="false"
+				TreatWChar_tAsBuiltInType="false"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions=" /SUBSYSTEM:WINDOWSCE,5.01 /MACHINE:THUMB"
+				OutputFile="$(OutDir)\mozce_shunt.dll"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory=""
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Windows Mobile 6 Professional SDK (ARMV4I)"
+			OutputDirectory="Windows Mobile 6 Professional SDK (ARMV4I)\$(ConfigurationName)"
+			IntermediateDirectory="Windows Mobile 6 Professional SDK (ARMV4I)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+				CommandLine=""
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="1"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="2"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);NDEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_SHUNT_EXPORTS"
+				ExceptionHandling="1"
+				RuntimeLibrary="0"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				FloatingPointModel="2"
+				TreatWChar_tAsBuiltInType="false"
+				RuntimeTypeInfo="false"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+				CompileAs="0"
+				CompileForArchitecture="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions=" /SUBSYSTEM:WINDOWSCE,5.02"
+				OutputFile="$(OutDir)\mozce_shunt.dll"
+				ImportLibrary="$(OutDir)\mozce_shunt.lib"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy &quot;$(TargetDir)$(TargetName).dll&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;copy &quot;$(TargetDir)$(TargetName).lib&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory=""
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Windows Mobile 6 Standard SDK (ARMV4I)"
+			OutputDirectory="Windows Mobile 6 Standard SDK (ARMV4I)\$(ConfigurationName)"
+			IntermediateDirectory="Windows Mobile 6 Standard SDK (ARMV4I)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+				CommandLine=""
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="1"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExecutionBucket="7"
+				Optimization="2"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_WIN32_WCE=$(CEVER);UNDER_CE=$(CEVER);WINCE;$(PLATFORMDEFINES);NDEBUG;_LIB;$(ARCHFAM);$(_ARCHFAM_);MOZCE_SHUNT_EXPORTS"
+				ExceptionHandling="1"
+				RuntimeLibrary="0"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				FloatingPointModel="2"
+				TreatWChar_tAsBuiltInType="false"
+				RuntimeTypeInfo="false"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+				CompileAs="0"
+				CompileForArchitecture="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG;_UNICODE;UNICODE;_WIN32_WCE;UNDER_CE"
+				Culture="1033"
+				AdditionalIncludeDirectories="$(IntDir)"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions=" /SUBSYSTEM:WINDOWSCE,5.02"
+				OutputFile="$(OutDir)\mozce_shunt.dll"
+				ImportLibrary="$(OutDir)\mozce_shunt.lib"
+				TargetMachine="0"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCCodeSignTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy &quot;$(TargetDir)$(TargetName).dll&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;copy &quot;$(TargetDir)$(TargetName).lib&quot; &quot;$(ProjectDir)&quot;&#x0D;&#x0A;"
+			/>
+			<DeploymentTool
+				ForceDirty="-1"
+				RemoteDirectory=""
+				RegisterOutput="0"
+				AdditionalFiles=""
+			/>
+			<DebuggerTool
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
+			>
+			<File
+				RelativePath="..\..\a2w.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\assert.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\clipboard.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\direct.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\errno.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\io.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\map.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\mbstring.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\mozce_dbg.c"
+				>
+			</File>
+			<File
+				RelativePath="..\..\nclog.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\process.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\signal.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\stat.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\stdio.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\stdlib.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\string.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\time.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\w2a.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\win32.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\win32A.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\win32W.cpp"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
+			>
+			<File
+				RelativePath="..\..\include\crtdbg.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\ddeml.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\direct.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\dlgs.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\errno.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\fcntl.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\intshcut.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\io.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\map.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\mbstring.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\mozce_defs.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\mozce_internal.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\mozce_shunt.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\new.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\process.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\rasdlg.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\signal.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\time_conversions.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\unistd.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\varargs.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\winresrc.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\winsock2.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\winspool.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\winsvc.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\zmouse.h"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
+			>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -r 9864735a4241 build/wince/shunt/direct.cpp
--- a/build/wince/shunt/direct.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/build/wince/shunt/direct.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -44,19 +44,17 @@ extern "C" {
 extern "C" {
 #if 0
 }
 #endif
 
 
 MOZCE_SHUNT_API int mkdir(const char* inDirname)
 {
-#ifdef API_LOGGING
-    mozce_printf("mkdir called\n");
-#endif
+    WINCE_LOG_API_CALL("mkdir called\n");
     
     int retval = -1;
     
     if(NULL != inDirname)
     {
         unsigned short wDirname[MAX_PATH];
         
         if(0 != a2w_buffer(inDirname, -1, wDirname, sizeof(wDirname) / sizeof(unsigned short)))
@@ -69,19 +67,17 @@ MOZCE_SHUNT_API int mkdir(const char* in
     }
     
     return retval;
 }
 
 
 MOZCE_SHUNT_API int rmdir(const char* inDirname)
 {
-#ifdef API_LOGGING
-    mozce_printf("rmdir called (%s)\n", inDirname);
-#endif
+    WINCE_LOG_API_CALL_1("rmdir called (%s)\n", inDirname);
     
     int retval = -1;
     
     if(NULL != inDirname)
     {
         unsigned short wDirname[MAX_PATH];
         
         if(0 != a2w_buffer(inDirname, -1, wDirname, sizeof(wDirname) / sizeof(unsigned short)))
diff -r 9864735a4241 build/wince/shunt/include/aclapi.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/build/wince/shunt/include/aclapi.h	Fri Sep 26 09:30:25 2008 -0500
@@ -0,0 +1,2 @@
+#include "mozce_shunt.h"
+
diff -r 9864735a4241 build/wince/shunt/include/mozce_defs.h
--- a/build/wince/shunt/include/mozce_defs.h	Mon Sep 22 11:50:03 2008 -0700
+++ b/build/wince/shunt/include/mozce_defs.h	Fri Sep 26 09:30:25 2008 -0500
@@ -97,26 +97,28 @@
 #define EACCES          13
 #define EFAULT          14
 #define EBUSY           16
 #define EEXIST          17
 #define EXDEV           18
 #define ENODEV          19
 #define ENOTDIR         20
 #define EISDIR          21
+#define EINVAL          22
 #define ENFILE          23
 #define EMFILE          24
 #define ENOTTY          25
 #define EFBIG           27
 #define ENOSPC          28
 #define ESPIPE          29
 #define EROFS           30
 #define EMLINK          31
 #define EPIPE           32
 #define EDOM            33
+#define ERANGE          34
 #define EDEADLK         36
 #ifndef ENAMETOOLONG
 #define ENAMETOOLONG    38
 #endif
 #define ENOLCK          39
 #define ENOSYS          40
 #ifndef ENOTEMPTY
 #define ENOTEMPTY       41
@@ -160,24 +162,29 @@
 // From stdlib.h
 #define _MAX_PATH       MAX_PATH
 
 // From sys/types.h
 typedef int ptrdiff_t;
 typedef long _off_t;
 typedef long off_t;
 
+// Not defined anywhere
+typedef INT_PTR intptr_t; 
+
 // From sys/stat.h
 #if !defined(_STAT_DEFINED)
 #define _STAT_DEFINED
 #define _S_IFDIR    0040000 /* stat, is a directory */
 #define _S_IFREG    0100000 /* stat, is a normal file */
 #define _S_IREAD    0000400 /* stat, can read */
 #define _S_IWRITE   0000200 /* stat, can write */
-#define	_S_IEXEC	0000100
+#define _S_IEXEC    0000100
+
+#define S_IFREG     0x8000
 
 struct stat
 {
     unsigned short st_mode;
     _off_t st_size;
     time_t st_ctime;
     time_t st_atime;
     time_t st_mtime;
@@ -296,28 +303,28 @@ typedef struct MAT2 {
 //
 // alpha format flags
 //
 
 #define AC_SRC_ALPHA                0x01
 
   
 struct color{
-	unsigned char Red;
-	unsigned char Green;
-	unsigned char Blue;
-	double Alpha;
+    unsigned char Red;
+    unsigned char Green;
+    unsigned char Blue;
+    double Alpha;
 };
 
 #ifndef SEE_MASK_FLAG_DDEWAIT
-#define SEE_MASK_FLAG_DDEWAIT	0
+#define SEE_MASK_FLAG_DDEWAIT   0
 #endif
 
 #ifndef SEE_MASK_INVOKEIDLIST
-#define SEE_MASK_INVOKEIDLIST	0
+#define SEE_MASK_INVOKEIDLIST   0
 #endif
 
 
 
 // if using WINCE 5.0 SDK, you need these:
 #define LPRASPBDLG void*
 #define LPRASDIALDLG void*
 
@@ -789,9 +796,34 @@ typedef struct
 
 #define SHGetPathFromIDListW SHGetPathFromIDList 
 #define GetUserNameW         GetUserName
 #define RemovePropW          RemoveProp
 #define GetPropW             GetProp
 #define SetPropW             SetProp
 #define FONTENUMPROCW        FONTENUMPROC
 #define GetLongPathNameW     GetLongPathName
+
+// ACL Defines
+
+
+typedef enum _SE_OBJECT_TYPE {
+  SE_UNKNOWN_OBJECT_TYPE       = 0,
+  SE_FILE_OBJECT,
+  SE_SERVICE,
+  SE_PRINTER,
+  SE_REGISTRY_KEY,
+  SE_LMSHARE,
+  SE_KERNEL_OBJECT,
+  SE_WINDOW_OBJECT,
+  SE_DS_OBJECT,
+  SE_DS_OBJECT_ALL,
+  SE_PROVIDER_DEFINED_OBJECT,
+  SE_WMIGUID_OBJECT,
+  SE_REGISTRY_WOW64_32KEY 
+} SE_OBJECT_TYPE;
+
+typedef DWORD SECURITY_INFORMATION, *PSECURITY_INFORMATION;
+
+#define UNPROTECTED_DACL_SECURITY_INFORMATION 0x0
+
+
 #endif // _MOZCE_DEFS
diff -r 9864735a4241 build/wince/shunt/include/mozce_shunt.h
--- a/build/wince/shunt/include/mozce_shunt.h	Mon Sep 22 11:50:03 2008 -0700
+++ b/build/wince/shunt/include/mozce_shunt.h	Fri Sep 26 09:30:25 2008 -0500
@@ -123,31 +123,45 @@
 #define CallWindowProcA            CallWindowProcW
 #define GetWindowLongA             GetWindowLongW
 #define SetWindowLongA             SetWindowLongW
 #define GetMonitorInfoW           GetMonitorInfo
 
 #undef  GetProcAddress
 #define GetProcAddress            GetProcAddressA
 
+#define SHELLEXECUTEINFOW         SHELLEXECUTEINFO
+#define ShellExecuteExW(x)        ShellExecuteEx(x)
+
+#define MapVirtualKeyEx(a,b,c)    MapVirtualKey(a,b)
+
 
 //still need these
 #define GetCurrentDirectory       GetCurrentDirectoryW
 #define OpenSemaphore             OpenSemaphoreW
 #define SetCurrentDirectoryW      SetCurrentDirectoryW
 
 #endif // MOZCE_SHUNT_EXPORTS
 
 //////////////////////////////////////////////////////////
 // Function Declarations
 //////////////////////////////////////////////////////////
 
 #ifdef __cplusplus
 extern "C" {
 #endif
+
+  MOZCE_SHUNT_API BOOL InitializeAcl(PACL apAcl, DWORD len, DWORD rev);
+  MOZCE_SHUNT_API DWORD SetNamedSecurityInfoW(unsigned short* pObjectName,
+					      SE_OBJECT_TYPE ObjectType,
+					      SECURITY_INFORMATION SecurityInfo,
+					      PSID psidOwner,
+					      PSID psidGroup,
+					      PACL pDacl,
+					      PACL pSacl);
 
   // From assert.cpp
   MOZCE_SHUNT_API void mozce_assert(int inExpression);
 
   // From direct.cpp
   MOZCE_SHUNT_API int mkdir(const char* inDirname);
   MOZCE_SHUNT_API int rmdir(const char* inDirname);
 
@@ -197,16 +211,17 @@ extern "C" {
 
   MOZCE_SHUNT_API int open(const char *pathname, int flags, int mode);
   MOZCE_SHUNT_API int close(int fp);
   MOZCE_SHUNT_API size_t read(int fp, void* buffer, size_t count);
   MOZCE_SHUNT_API size_t write(int fp, const void* buffer, size_t count);
   MOZCE_SHUNT_API int unlink(const char *pathname);
   MOZCE_SHUNT_API int lseek(int fildes, int offset, int whence);
 
+  MOZCE_SHUNT_API int fstat(FILE* handle, struct stat* buff);
 
   // From stdlib.cpp
   MOZCE_SHUNT_API void splitpath(const char* inPath, char* outDrive, char* outDir, char* outFname, char* outExt);
   MOZCE_SHUNT_API void makepath(char* outPath, const char* inDrive, const char* inDir, const char* inFname, const char* inExt);
   MOZCE_SHUNT_API char* fullpath(char *, const char *, size_t);
   MOZCE_SHUNT_API int _unlink(const char *filename );
 
   // From string.cpp
diff -r 9864735a4241 build/wince/shunt/io.cpp
--- a/build/wince/shunt/io.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/build/wince/shunt/io.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -46,19 +46,17 @@ extern "C" {
 #endif
 
 MOZCE_SHUNT_API void setbuf(FILE *, char *)
 {
 }
 
 MOZCE_SHUNT_API int chmod(const char* inFilename, int inMode)
 {
-#ifdef API_LOGGING
-    mozce_printf("chmod called\n");
-#endif
+    WINCE_LOG_API_CALL("chmod called\n");
     
     int retval = -1;
     
     if(NULL != inFilename)
     {
         unsigned short buffer[MAX_PATH];
         
         int convRes = a2w_buffer(inFilename, -1, buffer, sizeof(buffer) / sizeof(unsigned short));
@@ -88,19 +86,17 @@ MOZCE_SHUNT_API int chmod(const char* in
     }
     
     return retval;
 }
 
 
 MOZCE_SHUNT_API int isatty(int inHandle)
 {
-#ifdef API_LOGGING
-    mozce_printf("-- isatty called\n");
-#endif
+    WINCE_LOG_API_CALL("-- isatty called\n");
     
     int retval = 0;
     
     return retval;
 }
 
 
 #if 0
diff -r 9864735a4241 build/wince/shunt/mbstring.cpp
--- a/build/wince/shunt/mbstring.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/build/wince/shunt/mbstring.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -48,71 +48,59 @@ extern "C" {
 /*
 **  One day, these multi-byte routines will need to really do thier job.
 **
 **  Right now, bail with a default implementation.
 */
 
 MOZCE_SHUNT_API unsigned char* _mbsinc(const unsigned char* inCurrent)
 {
-#ifdef API_LOGGING
-    mozce_printf("mbsinc called\n");
-#endif
+    WINCE_LOG_API_CALL("mbsinc called\n");
     //IsDBCSLeadByte(path[len-1])
     return (unsigned char*)(inCurrent + 1);
 }
 
 
 MOZCE_SHUNT_API unsigned char* _mbspbrk(const unsigned char* inString, const unsigned char* inStrCharSet)
 {
-#ifdef API_LOGGING
-    mozce_printf("mbspbrk called\n");
-#endif
+    WINCE_LOG_API_CALL("mbspbrk called\n");
 
     LPWSTR wstring = a2w_malloc((const char *)inString, -1, NULL);
     LPWSTR wset    = a2w_malloc((const char *)inStrCharSet, -1, NULL);
     LPWSTR result  = wcspbrk(wstring, wset);
     free(wstring);
     free(wset);
     return (unsigned char *)result;
 }
 
 
 MOZCE_SHUNT_API unsigned char* mbsrchr(const unsigned char* inString, unsigned int inC)
 {
-#ifdef API_LOGGING
-    mozce_printf("mbsrchr called\n");
-#endif
+    WINCE_LOG_API_CALL("mbsrchr called\n");
 
     return (unsigned char*) strrchr((char*)inString, inC);
 }
 
 
 MOZCE_SHUNT_API unsigned char* mbschr(const unsigned char* inString, unsigned int inC)
 {
-#ifdef API_LOGGING
-    mozce_printf("mbschr called\n");
-#endif
+    WINCE_LOG_API_CALL("mbschr called\n");
     return (unsigned char*)strchr((const char*)inString, (int)inC);
 }
 
 
 MOZCE_SHUNT_API int mbsicmp(const unsigned char *string1, const unsigned char *string2)
 {
-#ifdef API_LOGGING
-    mozce_printf("mbsicmp called\n");
-#endif
+    WINCE_LOG_API_CALL("mbsicmp called\n");
     return _stricmp((const char*)string1, (const char*)string2);
 }
 
 MOZCE_SHUNT_API unsigned char* mbsdec(const unsigned char *string1, const unsigned char *string2)
 {
-#ifdef API_LOGGING
-    mozce_printf("mbsdec called\n");
-#endif
+    WINCE_LOG_API_CALL("mbsdec called\n");
     
     if (string1 == string2)
         return 0;
     
     return (unsigned char *)string2 - 1;
 }
 
 #if 0
diff -r 9864735a4241 build/wince/shunt/mozce_dbg.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/build/wince/shunt/mozce_dbg.c	Fri Sep 26 09:30:25 2008 -0500
@@ -0,0 +1,81 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla CE Shunt Library.
+ *
+ * The Initial Developer of the Original Code is Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   John Wolfe, 21-July-2008
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "mozce_internal.h"
+
+#include <stdarg.h>
+
+
+#ifndef SHUNT_LOG_ENABLED
+
+void mozce_DebugInit() { };
+void mozce_DebugDeinit() { };
+void mozce_DebugWriteToLog(char *str) { };
+
+#else
+
+#define LOGFILE     "\\Storage Card\\shuntlog.txt"
+
+FILE *gpDebugFile = NULL;
+
+void mozce_DebugInit()
+{
+    if ( NULL == gpDebugFile )
+        gpDebugFile = fopen(LOGFILE, "a+");
+}
+
+void mozce_DebugDeinit()
+{
+    if ( gpDebugFile ) {
+        fclose( gpDebugFile );
+        gpDebugFile = NULL;
+    }
+}
+
+void mozce_DebugWriteToLog(char *str)
+{
+    if ( NULL == gpDebugFile )
+        mozce_DebugInit();
+
+    if ( gpDebugFile ) {
+        fprintf(gpDebugFile, "%s", str);
+        fflush(gpDebugFile);
+    }
+}
+
+#endif
diff -r 9864735a4241 build/wince/shunt/mozce_internal.h
--- a/build/wince/shunt/mozce_internal.h	Mon Sep 22 11:50:03 2008 -0700
+++ b/build/wince/shunt/mozce_internal.h	Fri Sep 26 09:30:25 2008 -0500
@@ -150,16 +150,44 @@ char* w2a_malloc(unsigned short* inWideS
 
 // We use this API internally as well as externally.
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 	MOZCE_SHUNT_API int mozce_printf(const char *, ...);
 
+#ifdef SHUNT_LOG_ENABLED
+    void mozce_DebugInit();
+    void mozce_DebugDeinit();
+    void mozce_DebugWriteToLog(char * str);
+#endif
+
+#ifdef API_LOGGING
+
+#ifdef WINCE_MEMORY_CHECKPOINTING
+    MOZCE_SHUNT_API void mozce_MemoryCheckpoint();
+
+#define WINCE_LOG_API_CALL(x)          mozce_MemoryCheckpoint(); mozce_printf(x)
+#define WINCE_LOG_API_CALL_1(x,y)      mozce_MemoryCheckpoint(); mozce_printf(x,y)
+#define WINCE_LOG_API_CALL_2(x,y,z)    mozce_MemoryCheckpoint(); mozce_printf(x,y,z)
+#else
+#define WINCE_LOG_API_CALL(x)          mozce_printf(x)
+#define WINCE_LOG_API_CALL_1(x,y)      mozce_printf(x,y)
+#define WINCE_LOG_API_CALL_2(x,y,z)    mozce_printf(x,y,z)
+#endif
+
+#else
+
+#define WINCE_LOG_API_CALL(x)
+#define WINCE_LOG_API_CALL_1(x,y)
+#define WINCE_LOG_API_CALL_2(x,y,z)
+
+#endif          // #ifdef API_LOGGING
+
 #ifdef __cplusplus
 };
 #endif
 
 int nclog (const char *fmt, ...);
 void nclograw(const char* data, long length);
 
 #endif /* __mozce_internal_h */
diff -r 9864735a4241 build/wince/shunt/process.cpp
--- a/build/wince/shunt/process.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/build/wince/shunt/process.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -48,54 +48,49 @@ extern "C" {
 #if 0
 }
 #endif
 
 #include "kfuncs.h"
 
 MOZCE_SHUNT_API void abort(void)
 {
-#ifdef API_LOGGING
-    mozce_printf("abort called\n");
-#endif
+    WINCE_LOG_API_CALL("abort called\n");
 
 #if defined(DEBUG)
     DebugBreak();
 #endif
     TerminateProcess((HANDLE) GetCurrentProcessId(), 3);
 }
 
 
 MOZCE_SHUNT_API char* getenv(const char* inName)
 {
     return map_get(inName);
 }
 
 MOZCE_SHUNT_API int putenv(const char *a)
 {
-#ifdef API_LOGGING
-    mozce_printf("putenv called %s\n",a);
-#endif
+    WINCE_LOG_API_CALL_1("mozce_PutEnv called %s\n",a);
+
     int len = strlen(a);
     char* key = (char*) malloc(len*sizeof(char));
     strcpy(key,a);
     char* val = strchr(key,'=');
     val[0] = '\0';
     int rv;
     val++;
     rv = map_put(key,val);
     free(key);
     return rv;
 }
 
 MOZCE_SHUNT_API int getpid(void)
 {
-#ifdef API_LOGGING
-    mozce_printf("getpid called\n");
-#endif
+    WINCE_LOG_API_CALL("getpid called\n");
     
     int retval = 0;
     
     retval = (int)GetCurrentProcessId();
     
     return retval;
 }
 
diff -r 9864735a4241 build/wince/shunt/signal.cpp
--- a/build/wince/shunt/signal.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/build/wince/shunt/signal.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -54,19 +54,17 @@ static void defaultSighandler(int inSign
     // From process.cpp
     extern void abort(void);
     abort();
 }
 
 
 MOZCE_SHUNT_API int raise(int inSignal)
 {
-#ifdef API_LOGGING
-    mozce_printf("raise called\n");
-#endif
+    WINCE_LOG_API_CALL("raise called\n");
 
     void (*handler)(int inSignal) = defaultSighandler;
 
     if(inSignal >= 0 && inSignal < _SIGCOUNT)
     {
         if(NULL != sigArray[inSignal])
         {
             handler = sigArray[inSignal];
@@ -75,19 +73,17 @@ MOZCE_SHUNT_API int raise(int inSignal)
 
     handler(inSignal);
     return 0;
 }
 
 
 MOZCE_SHUNT_API _sigsig signal(int inSignal, _sigsig inFunc)
 {
-#ifdef API_LOGGING
-    mozce_printf("signal called\n");
-#endif
+    WINCE_LOG_API_CALL("signal called\n");
 
     void (*retval)(int inSignal) = defaultSighandler;
 
     if(inSignal >= 0 && inSignal < _SIGCOUNT)
     {
         if(NULL != sigArray[inSignal])
         {
             retval = sigArray[inSignal];
diff -r 9864735a4241 build/wince/shunt/stat.cpp
--- a/build/wince/shunt/stat.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/build/wince/shunt/stat.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -42,22 +42,46 @@
 #include "mozce_defs.h"
 #include "time_conversions.h"
 
 extern "C" {
 #if 0
 }
 #endif
 
+MOZCE_SHUNT_API int fstat(FILE* handle, struct stat* buff)
+{
+    WINCE_LOG_API_CALL("fstat called\n");
+
+    int position = ftell(handle);
+    if (position < 0)
+        return -1;
+
+    if (fseek(handle, 0, SEEK_END) < 0)
+        return -1;
+
+    buff->st_size = ftell(handle);
+
+    if (fseek(handle, position, SEEK_SET) < 0)
+        return -1;
+
+    if (buff->st_size < 0)
+        return -1;
+
+    buff->st_mode = _S_IFREG | _S_IREAD | _S_IWRITE | _S_IEXEC;
+    /* can't get time from a file handle on wince */
+    buff->st_ctime = 0;
+    buff->st_atime = 0;
+    buff->st_mtime = 0;
+    return 0;
+}
 
 MOZCE_SHUNT_API int stat(const char* inPath, struct stat* outStats)
 {
-#ifdef API_LOGGING
-        mozce_printf("stat called\n");
-#endif
+    WINCE_LOG_API_CALL("stat called\n");
     
     int retval = -1;
     
     if(NULL != outStats)
     {
         memset(outStats, 0, sizeof(struct stat));
         
         if(NULL != inPath)
@@ -68,17 +92,16 @@ MOZCE_SHUNT_API int stat(const char* inP
             if(0 != convRes)
             {
                 HANDLE readHandle;
                 WIN32_FIND_DATA findData;
                 readHandle = FindFirstFileW(wPath, &findData); 
                 
                 if (readHandle != INVALID_HANDLE_VALUE && readHandle != NULL)
                 {
-                    
                     retval = 0;
                     outStats->st_size = findData.nFileSizeLow;
                     
                     if(findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                     {
                         outStats->st_mode = _S_IFDIR;
                     }
                     else
diff -r 9864735a4241 build/wince/shunt/stdio.cpp
--- a/build/wince/shunt/stdio.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/build/wince/shunt/stdio.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -90,72 +90,59 @@ _getnewfd()
     }
     
     return -1;
 }
 
 
 MOZCE_SHUNT_API int _waccess(const wchar_t *path, int mode)
 {
-#ifdef API_LOGGING
-    mozce_printf("-- _waccess called\n");
-#endif
+    WINCE_LOG_API_CALL("-- _waccess called\n");
     
     return 0;
 }
 
 
 MOZCE_SHUNT_API int access(const char *path, int mode)
 {
-#ifdef API_LOGGING
-    mozce_printf("-- access called\n");
-#endif
+    WINCE_LOG_API_CALL("-- access called\n");
     
     return 0;
 }
 
 MOZCE_SHUNT_API void rewind(FILE* inStream)
 {
-#ifdef API_LOGGING
-        mozce_printf("rewind called\n");
-#endif
+    WINCE_LOG_API_CALL("rewind called\n");
     
     fseek(inStream, 0, SEEK_SET);
 }
 
 
 MOZCE_SHUNT_API FILE* fdopen(int fd, const char* inMode)
 {
-#ifdef API_LOGGING
-        mozce_printf("-- fdopen called (mode is ignored!) \n");
-#endif
-    
+    WINCE_LOG_API_CALL("-- fdopen called (mode is ignored!) \n");
     
     if(fd < 0 || fd >= MAXFDS || _fdtab[fd].fd == -1)
         return 0;
     
     return _fdtab[fd].file;
 }
 
 
 MOZCE_SHUNT_API void perror(const char* inString)
 {
-#ifdef API_LOGGING
-        mozce_printf("perror called\n");
-#endif
+    WINCE_LOG_API_CALL("perror called\n");
     
     fprintf(stderr, "%s", inString);
 }
 
 
 MOZCE_SHUNT_API int remove(const char* inPath)
 {
-#ifdef API_LOGGING
-        mozce_printf("remove called on %s\n", inPath);
-#endif
+    WINCE_LOG_API_CALL_1("remove called on %s\n", inPath);
     
     int retval = -1;
     
     if(NULL != inPath)
     {
         unsigned short wPath[MAX_PATH];
         
         if(0 != a2w_buffer(inPath, -1, wPath, sizeof(wPath) / sizeof(unsigned short)))
@@ -168,19 +155,18 @@ MOZCE_SHUNT_API int remove(const char* i
         }
     }
     
     return retval;
 }
 
 MOZCE_SHUNT_API char* getcwd(char* buff, size_t size)
 {
-#ifdef API_LOGGING
-        mozce_printf("getcwd called.\n");
-#endif
+    WINCE_LOG_API_CALL("getcwd called.\n");
+
     int i;
     unsigned short dir[MAX_PATH];
     GetModuleFileName(GetModuleHandle (NULL), dir, MAX_PATH);
     for (i = _tcslen(dir); i && dir[i] != TEXT('\\'); i--) {}
     dir[i + 1] = TCHAR('\0');
     
     w2a_buffer(dir, -1, buff, size);
     
@@ -198,16 +184,20 @@ MOZCE_SHUNT_API int mozce_printf(const c
     
     va_list ptr;
     va_start(ptr,format);
     vsprintf(buf,format,ptr);
     
     mbstowcs(tBuf, buf, MAX_CHARS_IN_VARIABLE_STRING);
     
     OutputDebugString(tBuf);
+
+#ifdef SHUNT_LOG_ENABLED
+    mozce_DebugWriteToLog(buf);
+#endif
     
     return 1;
     //#endif
 
     return 0;
 }
 
 static void mode2binstr(int mode, char* buffer)
@@ -235,19 +225,17 @@ static void mode2binstr(int mode, char* 
     else if (mode & O_RDONLY)
     {
         strcpy(buffer, "rb");
     }
 }
 
 MOZCE_SHUNT_API int open(const char *pathname, int flags, int mode)
 {
-#ifdef API_LOGGING
-        mozce_printf("open called\n");
-#endif
+    WINCE_LOG_API_CALL("open called\n");
     
     _initfds();
     
     
     char modestr[10];
     *modestr = '\0';
     
     mode2binstr(mode, modestr);
@@ -271,83 +259,68 @@ MOZCE_SHUNT_API int open(const char *pat
     }
     
     return fd;
 }
 
 
 MOZCE_SHUNT_API int close(int fd)
 {
-#ifdef API_LOGGING
-        mozce_printf("close called\n");
-#endif
-    
-    
-    
+    WINCE_LOG_API_CALL("close called\n");
     
     if(fd < 0 || fd >= MAXFDS || _fdtab[fd].fd == -1)
         return -1;
-    
     
     fclose(_fdtab[fd].file);
     _fdtab[fd].fd = -1;
     
     return 0;
 }
 
 MOZCE_SHUNT_API size_t read(int fd, void* buffer, size_t count)
 {
-#ifdef API_LOGGING
-        mozce_printf("read called\n");
-#endif
+    WINCE_LOG_API_CALL("read called\n");
     
     if(fd < 0 || fd >= MAXFDS || _fdtab[fd].fd == -1)
         return -1;
     
     size_t num = fread(buffer, 1, count, _fdtab[fd].file);
     
     if (ferror(_fdtab[fd].file))
         return -1;
     
     return num;
 }
 
 
 MOZCE_SHUNT_API size_t write(int fd, const void* buffer, size_t count)
 {
-#ifdef API_LOGGING
-        mozce_printf("write called\n");
-#endif
+    WINCE_LOG_API_CALL("write called\n");
     
     if(fd < 0 || fd >= MAXFDS || _fdtab[fd].fd == -1)
         return -1;
     
     size_t num = fwrite(buffer, 1, count, _fdtab[fd].file);
     if (ferror(_fdtab[fd].file))
         return -1;
     
     return num;
 }
 
 
 MOZCE_SHUNT_API int unlink(const char *pathname)
 {
-#ifdef API_LOGGING
-        mozce_printf("unlink called\n");
-#endif
+    WINCE_LOG_API_CALL("unlink called\n");
     return remove(pathname);
 }
 
 
 MOZCE_SHUNT_API int lseek(int fd, int offset, int whence)
 {
-#ifdef API_LOGGING
-        mozce_printf("lseek called\n");
-#endif
-    
+    WINCE_LOG_API_CALL("lseek called\n");
     
     if(fd < 0 || fd >= MAXFDS || _fdtab[fd].fd == -1)
         return -1;
     
     int newpos = -1;
     int error = fseek(_fdtab[fd].file, offset, whence);
     
     if (!error)
diff -r 9864735a4241 build/wince/shunt/stdlib.cpp
--- a/build/wince/shunt/stdlib.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/build/wince/shunt/stdlib.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -48,19 +48,17 @@
 
 extern "C" {
 #if 0
 }
 #endif
 
 MOZCE_SHUNT_API char *fullpath(char *absPath, const char *relPath, size_t maxLength)
 {
-#ifdef API_LOGGING
-    mozce_printf("fullpath called\n");
-#endif
+    WINCE_LOG_API_CALL("fullpath called\n");
 
     if (relPath[0] != '\\') 
     {
         int i;
         unsigned short dir[MAX_PATH];
         GetModuleFileName(GetModuleHandle (NULL), dir, MAX_PATH);
         for (i = _tcslen(dir); i && dir[i] != TEXT('\\'); i--) {}
         
@@ -70,19 +68,18 @@ MOZCE_SHUNT_API char *fullpath(char *abs
     }
     strcpy(absPath, relPath);
     
     return absPath;
 }
 
 MOZCE_SHUNT_API void splitpath(const char* inPath, char* outDrive, char* outDir, char* outFname, char* outExt)
 {
-#ifdef API_LOGGING
-    mozce_printf("splitpath called\n");
-#endif
+    WINCE_LOG_API_CALL("splitpath called\n");
+
     if(NULL != outDrive)
     {
         *outDrive = '\0';
     }
     if(NULL != outDir)
     {
         *outDir = '\0';
     }
@@ -177,19 +174,18 @@ MOZCE_SHUNT_API void splitpath(const cha
             free(dup);
         }
     }
 }
 
 
 MOZCE_SHUNT_API void makepath(char* outPath, const char* inDrive, const char* inDir, const char* inFname, const char* inExt)
 {
-#ifdef API_LOGGING
-    mozce_printf("makepath called\n");
-#endif
+    WINCE_LOG_API_CALL("makepath called\n");
+
     if(NULL != outPath)
     {
         int dirLen = 0;
         if(NULL != inDir)
         {
             dirLen = strlen(inDir);
             if(dirLen)
             {
@@ -203,19 +199,18 @@ MOZCE_SHUNT_API void makepath(char* outP
                   (NULL != inExt && '.' != inExt[0]) ? "." : "",
                   (NULL != inExt) ? inExt : ""
                   );
     }
 }
 
 MOZCE_SHUNT_API int mozce_strcmpi(const char *dest, const char *src)
 {
-#ifdef API_LOGGING
-    mozce_printf("mozce_strcmpi called\n");
-#endif
+    WINCE_LOG_API_CALL("mozce_strcmpi called\n");
+
     int f,l;
     
     do {
         if ( ((f = (unsigned char)(*(dest++))) >= 'A') && (f <= 'Z') )
             f -= ('A' - 'a');
         
         if ( ((l = (unsigned char)(*(src++))) >= 'A') && (l <= 'Z') )
             l -= ('A' - 'a');
diff -r 9864735a4241 build/wince/shunt/string.cpp
--- a/build/wince/shunt/string.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/build/wince/shunt/string.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -42,19 +42,17 @@
 
 extern "C" {
 #if 0
 }
 #endif
 
 MOZCE_SHUNT_API char* strerror(int inErrno)
 {
-#ifdef API_LOGGING
-    mozce_printf("strerror called\n");
-#endif
+    WINCE_LOG_API_CALL("strerror called\n");
     return "Unknown Error";
 }
 
 #if 0
 {
 #endif
 } /* extern "C" */
 
diff -r 9864735a4241 build/wince/shunt/time.cpp
--- a/build/wince/shunt/time.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/build/wince/shunt/time.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -65,29 +65,24 @@ static struct tm tmStorage;
 static struct tm tmStorage;
 
 #ifdef strftime
 #undef strftime
 #endif
 
 MOZCE_SHUNT_API size_t strftime(char *, size_t, const char *, const struct tm *)
 {
-#ifdef API_LOGGING
-    mozce_printf("mozce_strftime called\n");
-#endif
-
+    WINCE_LOG_API_CALL("mozce_strftime called\n");
     return 0;
 }
 
 
 MOZCE_SHUNT_API struct tm* mozce_localtime_r(const time_t* inTimeT,struct tm* outRetval)
 {
-#ifdef API_LOGGING
-    mozce_printf("tm* mozce_localtime_r called\n");
-#endif
+    WINCE_LOG_API_CALL("tm* mozce_localtime_r called\n");
 
     struct tm* retval = NULL;
 
     if(NULL != inTimeT && NULL != outRetval)
     {
         SYSTEMTIME winLocalTime;
         
         time_t_2_LOCALSYSTEMTIME(winLocalTime, *inTimeT);
@@ -124,29 +119,25 @@ MOZCE_SHUNT_API struct tm* mozce_localti
     }
 
     return retval;
 }
 
 
 MOZCE_SHUNT_API struct tm* localtime(const time_t* inTimeT)
 {
-#ifdef API_LOGGING
-    mozce_printf("tm* mozce_localtime called\n");
-#endif
+    WINCE_LOG_API_CALL("tm* mozce_localtime called\n");
 
     return mozce_localtime_r(inTimeT, &tmStorage);
 }
 
 
 MOZCE_SHUNT_API struct tm* mozce_gmtime_r(const time_t* inTimeT, struct tm* outRetval)
 {
-#ifdef API_LOGGING
-    mozce_printf("tm* mozce_gmtime_r called\n");
-#endif
+    WINCE_LOG_API_CALL("tm* mozce_gmtime_r called\n");
 
     struct tm* retval = NULL;
 
     if(NULL != inTimeT)
     {
         SYSTEMTIME winGMTime;
         
         time_t_2_SYSTEMTIME(winGMTime, *inTimeT);
@@ -183,29 +174,25 @@ MOZCE_SHUNT_API struct tm* mozce_gmtime_
     }
 
     return retval;
 }
 
 
 MOZCE_SHUNT_API struct tm* gmtime(const time_t* inTimeT)
 {
-#ifdef API_LOGGING
-    mozce_printf("tm* mozce_gmtime called\n");
-#endif
+    WINCE_LOG_API_CALL("tm* mozce_gmtime called\n");
 
     return mozce_gmtime_r(inTimeT, &tmStorage);
 }
 
 
 MOZCE_SHUNT_API time_t mktime(struct tm* inTM)
 {
-#ifdef API_LOGGING
-    mozce_printf("mozce_mktime called\n");
-#endif
+    WINCE_LOG_API_CALL("mozce_mktime called\n");
 
     time_t retval = (time_t)-1;
 
     if(NULL != inTM)
     {
         SYSTEMTIME winTime;
         struct tm* gmTime = NULL;
 
diff -r 9864735a4241 build/wince/shunt/win32.cpp
--- a/build/wince/shunt/win32.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/build/wince/shunt/win32.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -62,23 +62,50 @@ extern "C" {
 #define MOZCE_NOT_IMPLEMENTED_RV(fname, rv) \
   SetLastError(0); \
   mozce_printf("-- " fname  " called\n"); \
   SetLastError(ERROR_CALL_NOT_IMPLEMENTED); \
   return rv;
 
 #define wcharcount(array) (sizeof(array) / sizeof(TCHAR))
 
+
+
+static int memory_checkpoint_count = 0;
+
+MOZCE_SHUNT_API void mozce_MemoryCheckpoint()
+{
+#ifdef API_LOGGING
+#ifdef WINCE_MEMORY_CHECKPOINTING
+    MEMORYSTATUS memInfo;
+    STORE_INFORMATION si;
+
+    // Program memory.
+    memInfo.dwLength = sizeof(memInfo);
+    GlobalMemoryStatus(&memInfo);
+    GetStoreInformation(&si);
+    // OUTPUT: MEM_CHECKPOINT_STRING, counter, Storage Memory Free, RAM TOTAL, RAM FREE, RAM USED
+    // Can then grep for "MEM, ", put all those lines into one file,
+    // save the file, and use the resulting text file as 
+    // comma-delimited-text-file input into excel.
+    //   -- wolfe@lobo.us
+    if (memory_checkpoint_count == 0)
+        mozce_printf("MEM, counter, Storage Memory Free, RAM TOTAL, RAM FREE, RAM USED\n");
+
+    mozce_printf("MEM, %d, %d, %d, %d, %d\n", memory_checkpoint_count, si.dwFreeSize, memInfo.dwTotalPhys, memInfo.dwAvailPhys, memInfo.dwTotalPhys - memInfo.dwAvailPhys);
+    memory_checkpoint_count++;
+#endif
+#endif
+}
+
 /*this is defined in the WM6 header commdlg.h, but the sdk is missing commdlg.lib*/
 
 MOZCE_SHUNT_API DWORD CommDlgExtendedError()
 {
-#ifdef API_LOGGING
-    mozce_printf("CommDlgExtendedError called\n");
-#endif
+    WINCE_LOG_API_CALL("CommDlgExtendedError called\n");
     
     return -1 /*CDERR_DIALOGFAILURE*/;
 }
 
 
 MOZCE_SHUNT_API HBITMAP CreateDIBitmap(HDC inDC, CONST BITMAPINFOHEADER *inBMIH, DWORD inInit, CONST VOID *inBInit, CONST BITMAPINFO *inBMI, UINT inUsage)
 {
     MOZCE_NOT_IMPLEMENTED(__FUNCTION__);
@@ -114,19 +141,17 @@ MOZCE_SHUNT_API BOOL LPtoDP(HDC inDC, LP
 
 MOZCE_SHUNT_API BOOL LineDDA(int inXStart, int inYStart, int inXEnd, int inYEnd, LINEDDAPROC inLineFunc, LPARAM inData)
 {
     MOZCE_NOT_IMPLEMENTED(__FUNCTION__);
 }
 
 MOZCE_SHUNT_API int ExtSelectClipRgn(HDC inDC, HRGN inRGN, int inMode)
 {
-#ifdef API_LOGGING
-    mozce_printf("ExtSelectClipRgn called\n");
-#endif
+    WINCE_LOG_API_CALL("ExtSelectClipRgn called\n");
 
     // inModes are defined as:
     // RGN_AND = 1
     // RGN_OR = 2
     // RGN_XOR = 3
     // RGN_DIFF = 4
     // RGN_COPY = 5
 
@@ -180,19 +205,17 @@ MOZCE_SHUNT_API int ExtSelectClipRgn(HDC
     DeleteObject(rgn);
 
     return result;
 }
 
 
 MOZCE_SHUNT_API int FrameRect(HDC inDC, CONST RECT *inRect, HBRUSH inBrush)
 {
-#ifdef API_LOGGING
-    mozce_printf("FrameRect called\n");
-#endif
+    WINCE_LOG_API_CALL("FrameRect called\n");
 
     HBRUSH oldBrush = (HBRUSH)SelectObject(inDC, inBrush);
     RECT myRect = *inRect;
     InflateRect(&myRect, 1, 1); // The width and height of
                                 // the border are always one
                                 // logical unit.
 
     // 1  ---->   2
@@ -217,38 +240,33 @@ MOZCE_SHUNT_API int FrameRect(HDC inDC, 
 
     return 1;
 }
 
 
 
 MOZCE_SHUNT_API UINT GetTextCharset(HDC inDC)
 {
-
-#ifdef API_LOGGING
-    mozce_printf("GetTextCharset called\n");
-#endif
+    WINCE_LOG_API_CALL("GetTextCharset called\n");
 
     UINT retval = DEFAULT_CHARSET;
 
     TEXTMETRIC tm;
     if(GetTextMetrics(inDC, &tm))
     {
         retval = tm.tmCharSet;
     }
 
     return retval;
 }
 
 
 MOZCE_SHUNT_API UINT GetTextCharsetInfo(HDC inDC, LPFONTSIGNATURE outSig, DWORD inFlags)
 {
-#ifdef API_LOGGING
-    mozce_printf("GetTextCharsetInfo called\n");
-#endif
+    WINCE_LOG_API_CALL("GetTextCharsetInfo called\n");
 
     // Zero out the FONTSIGNATURE as we do not know how to fill it out properly.
     if(NULL != outSig)
     {
         memset(outSig, 0, sizeof(FONTSIGNATURE));
     }
 
     return GetTextCharset(inDC);
@@ -278,46 +296,40 @@ static int CALLBACK collectProc(CONST LO
         }
     }
 
     return retval;
 }
 
 MOZCE_SHUNT_API int GetMapMode(HDC inDC)
 {
-#ifdef API_LOGGING
-    mozce_printf("GetMapMode called\n");
-#endif
+    WINCE_LOG_API_CALL("GetMapMode called\n");
 
     int retval = MM_TEXT;
     return retval;
 }
 
 
 
 MOZCE_SHUNT_API LONG RegCreateKey(HKEY inKey, LPCTSTR inSubKey, PHKEY outResult)
 {
-#ifdef API_LOGGING
-    mozce_printf("RegCreateKey called\n");
-#endif
+    WINCE_LOG_API_CALL("RegCreateKey called\n");
 
     LONG retval = ERROR_SUCCESS;
     DWORD disp = 0;
 
     retval = RegCreateKeyEx(inKey, inSubKey, 0, NULL, 0, 0, NULL, outResult, &disp);
 
     return retval;
 }
 
 
 MOZCE_SHUNT_API BOOL WaitMessage(VOID)
 {
-#ifdef API_LOGGING
-    mozce_printf("WaitMessage called\n");
-#endif
+    WINCE_LOG_API_CALL("WaitMessage called\n");
 
     BOOL retval = TRUE;
 
     HANDLE hThread = GetCurrentThread();
     DWORD waitRes = MsgWaitForMultipleObjectsEx(1, &hThread, INFINITE, QS_ALLEVENTS, 0);
     if((DWORD)-1 == waitRes)
     {
         retval = FALSE;
@@ -349,19 +361,17 @@ static BOOL CALLBACK MyEnumWindowsProc(H
         return myParams->func(hwnd, myParams->params);
     }
 
     return TRUE;
 }
 
 MOZCE_SHUNT_API BOOL EnumChildWindows(HWND inParent, WNDENUMPROC inFunc, LPARAM inParam)
 {
-#ifdef API_LOGGING
-    mozce_printf("EnumChildWindows called\n");
-#endif
+    WINCE_LOG_API_CALL("EnumChildWindows called\n");
 
     ECWWindows myParams;
     myParams.params = inParam;
     myParams.func   = inFunc;
     myParams.parent = inParent;
 
     return EnumWindows(MyEnumWindowsProc, (LPARAM) &myParams);
 }
@@ -376,19 +386,17 @@ MOZCE_SHUNT_API BOOL IsIconic(HWND inWnd
 MOZCE_SHUNT_API BOOL IsIconic(HWND inWnd)
 {
     return false;
 }
 
 
 MOZCE_SHUNT_API BOOL OpenIcon(HWND inWnd)
 {
-#ifdef API_LOGGING
-    mozce_printf("OpenIcon called\n");
-#endif
+    WINCE_LOG_API_CALL("OpenIcon called\n");
     return SetActiveWindow(inWnd) ? 1:0;
 }
 
 
 MOZCE_SHUNT_API HHOOK SetWindowsHookEx(int inType, void* inFunc, HINSTANCE inMod, DWORD inThreadId)
 {
    MOZCE_NOT_IMPLEMENTED_RV(__FUNCTION__, NULL);
 }
@@ -411,37 +419,33 @@ MOZCE_SHUNT_API BOOL InvertRgn(HDC inDC,
 {
    MOZCE_NOT_IMPLEMENTED_RV(__FUNCTION__, FALSE);
 
 }
 
 
 MOZCE_SHUNT_API int GetScrollPos(HWND inWnd, int inBar)
 {
-#ifdef API_LOGGING
-    mozce_printf("GetScrollPos called\n");
-#endif
+    WINCE_LOG_API_CALL("GetScrollPos called\n");
 
     int retval = 0;
     SCROLLINFO info;
 
     if(GetScrollInfo(inWnd, inBar, &info))
     {
         return info.nPos;
     }
 
     return retval;
 }
 
 
 MOZCE_SHUNT_API BOOL GetScrollRange(HWND inWnd, int inBar, LPINT outMinPos, LPINT outMaxPos)
 {
- #ifdef API_LOGGING
-    mozce_printf("GetScrollRange called\n");
-#endif
+    WINCE_LOG_API_CALL("GetScrollRange called\n");
 
     BOOL retval = FALSE;
     SCROLLINFO info;
 
     if((retval = GetScrollInfo(inWnd, inBar, &info)))
     {
         if(NULL != outMinPos)
         {
@@ -454,19 +458,17 @@ MOZCE_SHUNT_API BOOL GetScrollRange(HWND
     }
 
     return retval;
 }
 
 
 MOZCE_SHUNT_API HRESULT CoLockObjectExternal(IUnknown* inUnk, BOOL inLock, BOOL inLastUnlockReleases)
 {
-#ifdef API_LOGGING
-    mozce_printf("CoLockObjectExternal called\n");
-#endif
+    WINCE_LOG_API_CALL("CoLockObjectExternal called\n");
 
     HRESULT retval = S_OK;
 
     if(NULL != inUnk)
     {
         if(FALSE == inLock)
         {
             inUnk->Release();
@@ -538,42 +540,36 @@ MOZCE_SHUNT_API DWORD GetEnvironmentVari
     return GetEnvironmentVariableW((LPCWSTR)lpName,(LPWSTR)lpBuffer,nSize);
 #else
 	return get(lpName,lpBuffer);
 #endif
 }
 
 MOZCE_SHUNT_API void GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime)
 {
-#ifdef API_LOGGING
-    mozce_printf("GetSystemTimeAsFileTime called\n");
-#endif
+    WINCE_LOG_API_CALL("GetSystemTimeAsFileTime called\n");
 
     SYSTEMTIME st;
     GetSystemTime(&st);
     SystemTimeToFileTime(&st,lpSystemTimeAsFileTime);
 }
 
 MOZCE_SHUNT_API DWORD GetLongPathNameW(LPCWSTR lpszShortPath, LPCWSTR lpszLongPath, DWORD cchBuffer)
 {
-#ifdef API_LOGGING
-    mozce_printf("GetLongPathNameW called\n");
-#endif
+    WINCE_LOG_API_CALL("GetLongPathNameW called\n");
 
     return 0;
 }
 
 MOZCE_SHUNT_API DWORD GetFullPathName(const char* lpFileName,
                                       DWORD nBufferLength,
                                       const char* lpBuffer,
                                       const char** lpFilePart)
 {
-#ifdef API_LOGGING
-    mozce_printf("GetFullPathName called\n");
-#endif
+    WINCE_LOG_API_CALL("GetFullPathName called\n");
 
     DWORD len = strlen(lpFileName);
     if (len > nBufferLength)
         return len;
 
     strncpy((char*)lpBuffer, lpFileName, len);
     ((char*)lpBuffer)[len] = '\0';
 
@@ -583,65 +579,57 @@ MOZCE_SHUNT_API DWORD GetFullPathName(co
         if (sep) {
             sep++; // pass the seperator
             *lpFilePart = sep;
         }
         else
             *lpFilePart = lpBuffer;
     }
 
-#ifdef API_LOGGING
-    mozce_printf("GetFullPathName called %s (%s)\n", lpBuffer, *lpFilePart);
-#endif
+    WINCE_LOG_API_CALL_2("GetFullPathName called %s (%s)\n", lpBuffer, *lpFilePart);
     return len;
 }
 
 static LONG gGetMessageTime = 0;
 
 MOZCE_SHUNT_API BOOL mozce_GetMessage(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax )
 {
     SetLastError(0);
 
-#ifdef API_LOGGING
-    mozce_printf("mozce_GetMessage called\n");
-#endif
+    WINCE_LOG_API_CALL("mozce_GetMessage called\n");
 
     BOOL b = GetMessage(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMin);
 
     if (b)
         gGetMessageTime = lpMsg->time;
 
     return b;
 }
 
 
 MOZCE_SHUNT_API BOOL mozce_PeekMessage(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg)
 {
     SetLastError(0);
 
-#ifdef API_LOGGING
-    mozce_printf("mozce_PeekMessageA called\n");
-#endif
+    WINCE_LOG_API_CALL("mozce_PeekMessageA called\n");
 
     BOOL b = PeekMessageW(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
 
     if (b && wRemoveMsg == PM_REMOVE)
         gGetMessageTime = lpMsg->time;
 
     return b;
 }
 
 
 MOZCE_SHUNT_API LONG GetMessageTime(void)
 {
     SetLastError(0);
 
-#ifdef API_LOGGING
-    mozce_printf("GetMessageTime called\n");
-#endif
+    WINCE_LOG_API_CALL("GetMessageTime called\n");
 
   return gGetMessageTime;
 }
 
 MOZCE_SHUNT_API DWORD ExpandEnvironmentStrings(LPCTSTR lpSrc, LPTSTR lpDst, DWORD nSize)
 {
     MOZCE_NOT_IMPLEMENTED_RV(__FUNCTION__, 0);
 }
@@ -655,19 +643,17 @@ MOZCE_SHUNT_API BOOL GdiFlush(void)
 {
     return TRUE;
 }
 
 MOZCE_SHUNT_API BOOL GetWindowPlacement(HWND hWnd, WINDOWPLACEMENT *lpwndpl)
 {
     SetLastError(0);
 
-#ifdef API_LOGGING
-    mozce_printf("GetWindowPlacement called\n");
-#endif
+    WINCE_LOG_API_CALL("GetWindowPlacement called\n");
 
    memset(lpwndpl, 0, sizeof(WINDOWPLACEMENT));
 
    // This is wrong when the window is minimized.
    lpwndpl->showCmd = SW_SHOWNORMAL;
    GetWindowRect(hWnd, &lpwndpl->rcNormalPosition);
 
    return TRUE;
@@ -707,22 +693,19 @@ MOZCE_SHUNT_API HINSTANCE ShellExecute(H
     if (dir)
         free(dir);
 
     return (HINSTANCE) info.hProcess;
 }
 
 MOZCE_SHUNT_API HINSTANCE ShellExecuteW(HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd)
 {
-
     SetLastError(0);
 
-#ifdef API_LOGGING
-    mozce_printf("ShellExecuteW called\n");
-#endif
+    WINCE_LOG_API_CALL("ShellExecuteW called\n");
 
     SHELLEXECUTEINFO info;
     info.cbSize = sizeof(SHELLEXECUTEINFO);
     info.fMask  = SEE_MASK_NOCLOSEPROCESS;
     info.hwnd   = hwnd;
     info.lpVerb = lpOperation;
     info.lpFile = lpFile;
     info.lpParameters = lpParameters;
@@ -753,19 +736,17 @@ struct lconv s_locale_conv =
     1,     /* n_cs_precedes */
     1,     /* n_sep_by_space */
     1,     /* p_sign_posn */
     1,     /* n_sign_posn */
 };
 
 MOZCE_SHUNT_API struct lconv * mozce_localeconv(void)
 {
-#ifdef API_LOGGING
-    mozce_printf("mozce_localeconv called\n");
-#endif
+    WINCE_LOG_API_CALL("mozce_localeconv called\n");
     return &s_locale_conv;
 }
 
 MOZCE_SHUNT_API BOOL CreatePipe(PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize)
 {
     MOZCE_NOT_IMPLEMENTED_RV(__FUNCTION__, FALSE);
 }
 MOZCE_SHUNT_API DWORD_PTR SetThreadAffinityMask(HANDLE hThread, DWORD_PTR dwThreadAffinityMask)
@@ -1050,19 +1031,17 @@ MOZCE_SHUNT_API int WINAPI SetMapMode(HD
 
 MOZCE_SHUNT_API DWORD WINAPI GetCharacterPlacementW(  __in HDC hdc, __in_ecount(nCount) LPCWSTR lpString, __in int nCount, __in int nMexExtent, __inout LPGCP_RESULTSW lpResults, __in DWORD dwFlags)
 {
     MOZCE_NOT_IMPLEMENTED(__FUNCTION__);
 }
 
 MOZCE_SHUNT_API wchar_t* wgetcwd(wchar_t* dir, size_t size)
 {
-#ifdef API_LOGGING
-        mozce_printf("getcwd called.\n");
-#endif
+    WINCE_LOG_API_CALL("getcwd called.\n");
     int i;
 
     GetModuleFileName(GetModuleHandle (NULL), dir, MAX_PATH);
     for (i = _tcslen(dir); i && dir[i] != TEXT('\\'); i--) {}
     dir[i + 1] = TCHAR('\0');
 
     return dir;
 }
@@ -1079,19 +1058,17 @@ MOZCE_SHUNT_API int  _wrmdir(const wchar
 
 MOZCE_SHUNT_API int _wremove(const wchar_t * _Filename)
 {
     return ::DeleteFileW(_Filename);
 }
 
 MOZCE_SHUNT_API int wchmod(const wchar_t * buffer, int inMode)
 {
-#ifdef API_LOGGING
-    mozce_printf("wchmod called\n");
-#endif
+    WINCE_LOG_API_CALL("wchmod called\n");
 
     int retval = -1;
 
     if(NULL != buffer)
     {
 
             DWORD attribs = 0;
 
@@ -1194,12 +1171,30 @@ MOZCE_SHUNT_API HWND GetAncestor(HWND hw
             break;
         default:
             return NULL;
     }
 
     return(hwndParent);
 }
 
+MOZCE_SHUNT_API BOOL InitializeAcl(PACL apAcl, DWORD len, DWORD rev)
+{
+    return FALSE;
+}
+
+MOZCE_SHUNT_API DWORD SetNamedSecurityInfoW(unsigned short* pObjectName,
+                                            SE_OBJECT_TYPE ObjectType,
+                                            SECURITY_INFORMATION SecurityInfo,
+                                            PSID psidOwner,
+                                            PSID psidGroup,
+                                            PACL pDacl,
+                                            PACL pSacl)
+{
+    return 0;
+}
+
+
+
 #if 0
 {
 #endif
 } /* extern "C" */
diff -r 9864735a4241 build/wince/tools/Makefile
--- a/build/wince/tools/Makefile	Mon Sep 22 11:50:03 2008 -0700
+++ b/build/wince/tools/Makefile	Fri Sep 26 09:30:25 2008 -0500
@@ -1,19 +1,99 @@ all:
-all:
-	cl vs8ppc2003arm/arm-wince-as.c
-	mv arm-wince-as.exe vs8ppc2003arm
-	cl vs8ppc2003arm/arm-wince-gcc.c
-	mv arm-wince-gcc.exe vs8ppc2003arm
-	cl vs8ppc2003arm/arm-wince-lib.c
-	mv arm-wince-lib.exe vs8ppc2003arm
-	cl vs8ppc2003arm/arm-wince-link.c
-	mv arm-wince-link.exe vs8ppc2003arm
-	rm -f *.obj
-	devenv ../shunt/build/vs8/mozce_shunt_static.sln -Rebuild "Release|Windows Mobile 6 Standard SDK (ARMV4I)"
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is Mozilla CE Shunt Library.
+#
+# The Initial Developer of the Original Code is Mozilla Corporation.
+# Portions created by the Initial Developer are Copyright (C) 2008
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#	John Wolfe (wolfe@lobo.us)
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEVENV_FLAG=-
+
+CC=cl
+
+MOZCE_DEVENV=vs$(MOZ_MSVCVERSION)
+
+MOZCE_SHUNT_SLN=../shunt/build/$(MOZCE_DEVENV)/mozce_shunt_static.sln
+MOZCE_PROJECT="Release|Windows Mobile 6 Standard SDK (ARMV4I)"
+MOZCE_SHUNT_DLL=../shunt/build/$(MOZCE_DEVENV)/mozce_shunt.dll
+MOZCE_TOOLS_DIR=$(MOZCE_DEVENV)ppc2003arm
+
+BUILD_SWITCH=$(DEVENV_FLAG)Build
+REBUILD_SWITCH=$(DEVENV_FLAG)Rebuild
+CLEAN_SWITCH=$(DEVENV_FLAG)clean
+
+
+all: output_some_env \
+	 $(MOZCE_TOOLS_DIR)/arm-wince-as.exe \
+	 $(MOZCE_TOOLS_DIR)/arm-wince-gcc.exe \
+	 $(MOZCE_TOOLS_DIR)/arm-wince-lib.exe \
+	 $(MOZCE_TOOLS_DIR)/arm-wince-link.exe \
+	 $(MOZCE_TOOLS_DIR)/arm-wince-res.exe 
+	devenv $(MOZCE_SHUNT_SLN) $(BUILD_SWITCH) $(MOZCE_PROJECT)
 
 clobber:
-	rm -f vs8ppc2003arm/*.exe
-	rm -f vs8ppc2003arm/*.obj
+	rm -f $(MOZCE_TOOLS_DIR)/*.exe
+	rm -f $(MOZCE_TOOLS_DIR)/*.obj
 	rm -f *.obj
 	rm -f *.exe
-	devenv ../shunt/build/vs8/mozce_shunt_static.sln -clean "Release|Windows Mobile 6 Standard SDK (ARMV4I)"
+	rm -rf bin
+	devenv $(MOZCE_SHUNT_SLN) $(CLEAN_SWITCH) $(MOZCE_PROJECT)
 
+output_some_env:
+	@echo FOUND $(MOZCE_DEVENV)
+	@echo FOUND $(MOZCE_DEVENV): VSINSTALLDIR=$(VSINSTALLDIR) / MINGW32=$(MINGW32) / MSYSTEM=$(MSYSTEM)
+	@echo FOUND $(MOZCE_DEVENV)
+
+$(MOZCE_TOOLS_DIR)/arm-wince-as.exe:	$(MOZCE_TOOLS_DIR)/arm-wince-as.c
+	$(CC) $(MOZCE_TOOLS_DIR)/arm-wince-as.c
+	mkdir -p bin;
+	cp arm-wince-as.exe bin; mv arm-wince-as.exe $(MOZCE_TOOLS_DIR); rm *.obj
+
+$(MOZCE_TOOLS_DIR)/arm-wince-gcc.exe:	$(MOZCE_TOOLS_DIR)/arm-wince-gcc.c
+	$(CC) $(MOZCE_TOOLS_DIR)/arm-wince-gcc.c
+	mkdir -p bin;
+	cp arm-wince-gcc.exe bin; mv arm-wince-gcc.exe $(MOZCE_TOOLS_DIR); rm *.obj
+
+$(MOZCE_TOOLS_DIR)/arm-wince-lib.exe:	$(MOZCE_TOOLS_DIR)/arm-wince-lib.c
+	$(CC) $(MOZCE_TOOLS_DIR)/arm-wince-lib.c
+	mkdir -p bin;
+	cp arm-wince-lib.exe bin; mv arm-wince-lib.exe $(MOZCE_TOOLS_DIR); rm *.obj
+
+$(MOZCE_TOOLS_DIR)/arm-wince-link.exe:	$(MOZCE_TOOLS_DIR)/arm-wince-link.c
+	$(CC) $(MOZCE_TOOLS_DIR)/arm-wince-link.c
+	mkdir -p bin;
+	cp arm-wince-link.exe bin; mv arm-wince-link.exe $(MOZCE_TOOLS_DIR); rm *.obj
+
+$(MOZCE_TOOLS_DIR)/arm-wince-res.exe:	$(MOZCE_TOOLS_DIR)/arm-wince-res.c
+	$(CC) $(MOZCE_TOOLS_DIR)/arm-wince-res.c
+	mkdir -p bin;
+	cp arm-wince-res.exe bin; mv arm-wince-res.exe $(MOZCE_TOOLS_DIR); rm *.obj
+
diff -r 9864735a4241 build/wince/tools/vs8ppc2003arm/arm-wince-res.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/build/wince/tools/vs8ppc2003arm/arm-wince-res.c	Fri Sep 26 09:30:25 2008 -0500
@@ -0,0 +1,19 @@
+#include "toolspath.h"
+
+int
+main(int argc, char **argv)
+{
+  int iRetVal;
+  char* args[1000];
+  int i = 0;
+  int j = 0;
+  int k = 0;
+  int s = 0;
+  args[i++] = RC_PATH;
+
+  argpath_conv(&argv[1], &args[i]);
+
+  dumpargs(args);
+
+  return run(args);
+}
diff -r 9864735a4241 build/wince/tools/vs8ppc2003arm/toolspath.h
--- a/build/wince/tools/vs8ppc2003arm/toolspath.h	Mon Sep 22 11:50:03 2008 -0700
+++ b/build/wince/tools/vs8ppc2003arm/toolspath.h	Fri Sep 26 09:30:25 2008 -0500
@@ -1,163 +1,276 @@
-#include <windows.h>
-#include <stdio.h>
-#include <process.h>
-
-#ifndef TOPSRCDIR
-#include "../topsrcdir.h"
-#endif
-
-#define WCE_BIN   "c:\\Program Files\\Microsoft Visual Studio 8\\VC\\ce\\bin\\x86_arm\\"
-#define WCE_CRT   "c:\\Program Files\\Microsoft Visual Studio 8\\VC/ce\\lib\\armv4i"
-#define WCE_INC   "C:\\Program Files\\Windows Mobile 6 SDK\\Smartphone\\Include\\Armv4i"
-#define WCE_LIB   "C:\\Program Files\\Windows Mobile 6 SDK\\Smartphone\\Lib\\Armv4i"
-
-#define SHUNT_LIB TOPSRCDIR "/build/wince/shunt/build/vs8/"
-#define SHUNT_INC TOPSRCDIR "/build/wince/shunt/include/"
-
-#define ASM_PATH  WCE_BIN "armasm.exe"
-#define CL_PATH   WCE_BIN "cl.exe"
-#define LIB_PATH  WCE_BIN "lib.exe"
-#define LINK_PATH WCE_BIN "link.exe"
-
-#define MAX_NOLEAK_BUFFERS 100
-char noleak_buffers[MAX_NOLEAK_BUFFERS][1024];
-static int next_buffer = 0;
-
-int argpath_conv(char **args_in, char **args_out)
-{
- int i = 0;
-
- while (args_in[i])
- {
-   args_out[i] = args_in[i];
-
-   if (args_in[i])
-   {
-     char *offset = strstr(args_out[i], "/cygdrive/");
-
-     if (offset) {
-
-       strcpy(offset, offset+9);
-       offset[0] = offset[1];
-       offset[1] = ':';
-       offset[2] = '/';
-     }
-
-     if ( (args_out[i][0] == '-' || args_out[i][0] == '/') &&
-          (args_out[i][1] == 'D'))
-     {
-
-       offset = strstr(args_out[i]+2, "=");
-       if (offset)
-       {
-         char* equalsChar = offset;
-
-         if (equalsChar[1] == '"')
-         {
-           *equalsChar = '\0';
-
-           strcpy(noleak_buffers[next_buffer], args_out[i]);
-
-           *equalsChar = '=';
-
-           strcat(noleak_buffers[next_buffer], "=\\\"");
-           strcat(noleak_buffers[next_buffer], equalsChar+1);
-           strcat(noleak_buffers[next_buffer], "\\\"");
-
-           args_out[i] = noleak_buffers[next_buffer];
-
-           next_buffer++;
-
-           if (next_buffer > MAX_NOLEAK_BUFFERS) {
-             printf("next_buffer>MAX_NOLEAK_BUFFERS\n");
-             exit(-1);
-           }
-         }
-       }
-     }
-   }
-   i++;
- }
- args_out[i] = NULL;
- return i;
-}
-
-void dumpargs(char** args)
-{
- int i = 0;
-
- if (args[0] == NULL)
-   printf(":: first element is null!\n");
-
- while(args[i])
-   printf("%s ", args[i++]);
-
- printf("\n");
- fflush(stdout);
- fflush(stderr);
-}
-
-
-DWORD run(char** args)
-{
-
- DWORD exitCode;
- STARTUPINFO si;
- PROCESS_INFORMATION pi;
-
- char theArgs[1024*16];
-
- int totalLen = 0;
- int i, j;
-
-
- // Clear any link env variable that might get us tangled up
- _putenv("LINK=");
- _putenv("LIBPATH=");
- _putenv("CC=");
-
- _putenv("INCLUDE=" WCE_INC);
- _putenv("LIB=" WCE_LIB);
-
- for (j=1; args[j]; j++)
- {
-   int len = strlen(args[j]);
-   strcat(&theArgs[totalLen], args[j]);
-   totalLen += len;
-
-   strcat(&theArgs[totalLen], " ");
-   totalLen++;
- }
-
- i = strlen(args[0]);
- for (j=0; j<i; j++)
- {
-   if (args[0][j] == '/')
-     args[0][j] = '\\';
- }
-
- ZeroMemory( &si, sizeof(si) );
- si.cb = sizeof(si);
- ZeroMemory( &pi, sizeof(pi));
-
- CreateProcess(args[0],
-               theArgs,
-               NULL,
-               NULL,
-               0,
-               0,
-               NULL,
-               NULL,
-               &si,              // Pointer to STARTUPINFO structure.
-               &pi);
-
-
- // Wait until child process exits.
- WaitForSingleObject( pi.hProcess, INFINITE );
- GetExitCodeProcess(pi.hProcess, &exitCode);
- // Close process and thread handles.
- CloseHandle( pi.hProcess );
- CloseHandle( pi.hThread );
-
- return exitCode;
-}
+#include <windows.h>
+#include <stdio.h>
+#include <process.h>
+
+#ifndef TOPSRCDIR
+#include "../topsrcdir.h"
+#endif
+
+#define WCE_BIN   "c:\\Program Files\\Microsoft Visual Studio 8\\VC\\ce\\bin\\x86_arm\\"
+#define WCE_RC_BIN "C:\\Program Files\\Microsoft SDKs\\Windows\\v6.0a\\bin\\"
+#define WCE_CRT   "c:\\Program Files\\Microsoft Visual Studio 8\\VC/ce\\lib\\armv4i"
+#define WCE_INC   "C:\\Program Files\\Windows Mobile 6 SDK\\Smartphone\\Include\\Armv4i"
+#define WCE_LIB   "C:\\Program Files\\Windows Mobile 6 SDK\\Smartphone\\Lib\\Armv4i"
+
+#define SHUNT_LIB TOPSRCDIR "/build/wince/shunt/build/vs8/"
+#define SHUNT_INC TOPSRCDIR "/build/wince/shunt/include/"
+
+#define ASM_PATH  WCE_BIN "armasm.exe"
+#define CL_PATH   WCE_BIN "cl.exe"
+#define LIB_PATH  WCE_BIN "lib.exe"
+#define LINK_PATH WCE_BIN "link.exe"
+#define RC_PATH   WCE_RC_BIN "rc.exe"
+
+#define MAX_NOLEAK_BUFFERS 100
+char noleak_buffers[MAX_NOLEAK_BUFFERS][1024];
+static int next_buffer = 0;
+
+int argpath_conv(char **args_in, char **args_out)
+{
+  int i = 0;
+
+  while (args_in[i])
+  {
+    char *offset;
+
+    args_out[i] = args_in[i];
+
+    if (args_in[i])
+    {
+      // First, look for the case of "-Fo/c/xxxxxxx" and "/Fo/c/xxxxx"
+      if ( (args_out[i][0] == '-' || args_out[i][0] == '/') &&
+           (args_out[i][1] == 'F') && (args_out[i][2] == 'o') &&
+           (args_out[i][3] == '/') && (strlen(args_out[i]) > 5) ) {
+
+        //printf("ARGS_IN: -FoXXXX is %s\n",args_in[i]);
+
+        strcpy(noleak_buffers[next_buffer], args_in[i]);
+
+        noleak_buffers[next_buffer][0] = '/';
+        noleak_buffers[next_buffer][3] = noleak_buffers[next_buffer][4];
+        noleak_buffers[next_buffer][4] = ':';
+
+        args_out[i] = noleak_buffers[next_buffer];
+
+        //printf("ARGS_OUT: -FoXXXX is %s\n",args_out[i]);
+
+        next_buffer++;
+      }
+      else if ((args_out[i][0] == '/') && (args_out[i][2] == '/'))
+      {
+        // Assume this is a pathname, and adjust accordingly
+        //printf("ARGS_IN: PATHNAME ASSUMED: %s\n", args_in[i]);
+
+        strcpy(noleak_buffers[next_buffer], args_in[i]);
+
+        noleak_buffers[next_buffer][0] = noleak_buffers[next_buffer][1];
+        noleak_buffers[next_buffer][1] = ':';
+
+        args_out[i] = noleak_buffers[next_buffer];
+        //printf("ARGS_OUT: PATHNAME MODIFIED TO BE: %s\n", args_out[i]);
+
+        next_buffer++;
+      }
+      else if ((args_out[i][0] == '\\') && (args_out[i][2] == '\\'))
+      {
+        // Assume this is a pathname, and adjust accordingly
+        //printf("ARGS_IN: PATHNAME ASSUMED: %s\n", args_in[i]);
+
+        strcpy(noleak_buffers[next_buffer], args_in[i]);
+
+        noleak_buffers[next_buffer][0] = noleak_buffers[next_buffer][1];
+        noleak_buffers[next_buffer][1] = ':';
+
+        args_out[i] = noleak_buffers[next_buffer];
+        //printf("ARGS_OUT: PATHNAME MODIFIED TO BE: %s\n", args_out[i]);
+
+        next_buffer++;
+      }
+      else if ((args_out[i][0] == '\\') && (args_out[i][1] == '\\') &&
+               (args_out[i][3] == '\\') && (args_out[i][4] == '\\'))
+      {
+        // Assume this is a pathname, and adjust accordingly
+        //printf("ARGS_IN: PATHNAME ASSUMED: %s\n", args_in[i]);
+
+        noleak_buffers[next_buffer][0] = args_in[i][2];
+        noleak_buffers[next_buffer][1] = ':';
+        noleak_buffers[next_buffer][2] = '\0';
+
+        strcpy(noleak_buffers[next_buffer], &args_in[i][3]);
+
+        args_out[i] = noleak_buffers[next_buffer];
+        //printf("ARGS_OUT: PATHNAME MODIFIED TO BE: %s\n", args_out[i]);
+
+        next_buffer++;
+      }
+      else if ( strstr(args_out[i], "OUT:") || strstr(args_out[i], "DEF:") )
+      {
+        // Deal with -OUT:/c/....
+        //
+        // NOTE: THERE IS A BUG IN THIS IMPLEMENTATION IF 
+        //       THERE IS A SPACE IN THE TOPSRCDIR PATH.
+        //
+        // Should really check for spaces, then double-quote
+        // the path if any space is found.
+        // -- wolfe@lobo.us  25-Aug-08
+        if ((args_out[i][5] == '/') && (args_out[i][7] == '/'))
+        {
+          // Assume this is a pathname, and adjust accordingly
+          //printf("ARGS_IN: PATHNAME ASSUMED: %s\n", args_in[i]);
+
+          strcpy(noleak_buffers[next_buffer], args_in[i]);
+
+          noleak_buffers[next_buffer][5] = noleak_buffers[next_buffer][6];
+          noleak_buffers[next_buffer][6] = ':';
+
+          args_out[i] = noleak_buffers[next_buffer];
+          //printf("ARGS_OUT: PATHNAME MODIFIED TO BE: %s\n", args_out[i]);
+        }
+        // Deal with -OUT:"/c/...."
+        else if ((args_out[i][6] == '/') && (args_out[i][8] == '/'))
+        {
+          // Assume this is a pathname, and adjust accordingly
+          //printf("ARGS_IN: PATHNAME ASSUMED: %s\n", args_in[i]);
+
+          strcpy(noleak_buffers[next_buffer], args_in[i]);
+
+          noleak_buffers[next_buffer][6] = noleak_buffers[next_buffer][7];
+          noleak_buffers[next_buffer][7] = ':';
+
+          args_out[i] = noleak_buffers[next_buffer];
+          //printf("ARGS_OUT: PATHNAME MODIFIED TO BE: %s\n", args_out[i]);
+        }
+
+        next_buffer++;
+      }
+      else
+      {
+        char *offset = strstr(args_out[i], "/cygdrive/");
+
+        if (offset) {
+
+          strcpy(offset, offset+9);
+          offset[0] = offset[1];
+          offset[1] = ':';
+          offset[2] = '/';
+        }
+
+        if ( (args_out[i][0] == '-' || args_out[i][0] == '/') &&
+             (args_out[i][1] == 'D'))
+        {
+
+          offset = strstr(args_out[i]+2, "=");
+          if (offset)
+          {
+            char* equalsChar = offset;
+
+            if (equalsChar[1] == '"')
+            {
+              *equalsChar = '\0';
+
+              strcpy(noleak_buffers[next_buffer], args_out[i]);
+
+              *equalsChar = '=';
+
+              strcat(noleak_buffers[next_buffer], "=\\\"");
+              strcat(noleak_buffers[next_buffer], equalsChar+1);
+              strcat(noleak_buffers[next_buffer], "\\\"");
+
+              args_out[i] = noleak_buffers[next_buffer];
+
+              next_buffer++;
+            }
+          }
+        }
+      }
+
+      if (next_buffer > MAX_NOLEAK_BUFFERS) {
+        printf("OOPS - next_buffer > MAX_NOLEAK_BUFFERS\n");
+        exit(-1);
+      }
+    }
+    i++;
+  }
+  args_out[i] = NULL;
+  return i;
+}
+
+void dumpargs(char** args)
+{
+ int i = 0;
+
+ if (args[0] == NULL)
+   printf(":: first element is null!\n");
+
+ while(args[i])
+   printf("%s ", args[i++]);
+
+ printf("\n");
+ fflush(stdout);
+ fflush(stderr);
+}
+
+
+DWORD run(char** args)
+{
+
+ DWORD exitCode;
+ STARTUPINFO si;
+ PROCESS_INFORMATION pi;
+
+ char theArgs[1024*16];
+
+ int totalLen = 0;
+ int i, j;
+
+
+ // Clear any link env variable that might get us tangled up
+ _putenv("LINK=");
+ _putenv("LIBPATH=");
+ _putenv("CC=");
+
+ _putenv("INCLUDE=" WCE_INC);
+ _putenv("LIB=" WCE_LIB);
+
+ for (j=1; args[j]; j++)
+ {
+   int len = strlen(args[j]);
+   strcat(&theArgs[totalLen], args[j]);
+   totalLen += len;
+
+   strcat(&theArgs[totalLen], " ");
+   totalLen++;
+ }
+
+ i = strlen(args[0]);
+ for (j=0; j<i; j++)
+ {
+   if (args[0][j] == '/')
+     args[0][j] = '\\';
+ }
+
+ ZeroMemory( &si, sizeof(si) );
+ si.cb = sizeof(si);
+ ZeroMemory( &pi, sizeof(pi));
+
+ CreateProcess(args[0],
+               theArgs,
+               NULL,
+               NULL,
+               0,
+               0,
+               NULL,
+               NULL,
+               &si,              // Pointer to STARTUPINFO structure.
+               &pi);
+
+
+ // Wait until child process exits.
+ WaitForSingleObject( pi.hProcess, INFINITE );
+ GetExitCodeProcess(pi.hProcess, &exitCode);
+ // Close process and thread handles.
+ CloseHandle( pi.hProcess );
+ CloseHandle( pi.hThread );
+
+ return exitCode;
+}
diff -r 9864735a4241 build/wince/tools/vs9ppc2003arm/arm-wince-as.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/build/wince/tools/vs9ppc2003arm/arm-wince-as.c	Fri Sep 26 09:30:25 2008 -0500
@@ -0,0 +1,17 @@
+#include "toolspath.h"
+
+int 
+main(int argc, char **argv)
+{  
+  char* args[1000];
+  int i = 0;
+  
+  args[i++] = ASM_PATH;
+  args[i++] = "-I\"" WCE_INC "\""; 
+
+  i += argpath_conv(&argv[1], &args[i]);
+
+  dumpargs(args);
+
+  return run(args);
+}
diff -r 9864735a4241 build/wince/tools/vs9ppc2003arm/arm-wince-gcc.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/build/wince/tools/vs9ppc2003arm/arm-wince-gcc.c	Fri Sep 26 09:30:25 2008 -0500
@@ -0,0 +1,92 @@
+#include "toolspath.h"
+
+int
+main(int argc, char **argv)
+{
+  int startOfArgvs;
+  int i = 0;
+  int j = 0;
+  int link = 0;
+
+  char* args[1000];
+  char  outputFileArg[1000];
+
+  args[i++] = CL_PATH;
+  args[i++] = "/I\"" WCE_INC "\"";
+  args[i++] = "/I\"" SHUNT_INC "\"";
+  args[i++] = "/FI\"mozce_shunt.h\"";
+
+  args[i++] = "/DMOZCE_STATIC_BUILD";
+  args[i++] = "/DUNICODE";
+  args[i++] = "/D_UNICODE_";
+  args[i++] = "/DARM";
+  args[i++] = "/D_ARM_";
+  args[i++] = "/DWINCE";
+  args[i++] = "/D_WIN32_WCE=0x502";
+  args[i++] = "/DUNDER_CE";
+  args[i++] = "/DWIN32_PLATFORM_WFSP";
+//  args[i++] = "/DWIN32_PLATFORM_PSPC";
+//  args[i++] = "/DPOCKETPC2003_UI_MODEL";
+  args[i++] = "/D_WINDOWS";
+
+  args[i++] = "/Zc:wchar_t-";          //
+  args[i++] = "/GS-";                  // disable security checks
+  args[i++] = "/GR-";                  // disable C++ RTTI
+  args[i++] = "/fp:fast";
+
+  startOfArgvs = i;
+
+  i += argpath_conv(&argv[1], &args[i]);
+
+  // if /Fe is passed, then link
+  //
+  // if -o is passed, then blank out this argument, and place a "/Fo"
+  // before the next argument
+  while(argv[j])
+    {
+      if (strncmp(argv[j], "-o", 2) == 0)
+	{
+	  printf("%s is -o\n",argv[j]);
+
+
+	  link = strstr(args[startOfArgvs+j], ".obj") ? 0:1;
+
+
+	  // If we are outputting a .OBJ file, then we are
+	  // NOT linking, and we need to do some fancy
+	  // footwork to output "/FoFILENAME" as an argument
+	  args[startOfArgvs+j-1] = "";
+	  strcpy(outputFileArg, ( strstr(args[startOfArgvs+j], ".exe") )?"/Fe":"/Fo");
+	  strcat(outputFileArg, args[startOfArgvs+j]);
+	  args[startOfArgvs+j] = outputFileArg;
+	}
+      j++;
+    }
+
+  if (link)
+    {
+      args[i++] = "/link";
+
+      args[i++] = "/ENTRY:main";
+
+      args[i++] = "/SUBSYSTEM:WINDOWSCE,5.02";
+
+      args[i++] = "/LIBPATH:\"" WCE_LIB "\"";
+      args[i++] = "/LIBPATH:\"" WCE_CRT "\"";
+      args[i++] = "/LIBPATH:\"" SHUNT_LIB "\"";
+      args[i++] = "mozce_shunt.lib";
+      args[i++] = "winsock.lib";
+      args[i++] = "corelibc.lib";
+      args[i++] = "coredll.lib";
+
+
+      args[i++] = "/NODEFAULTLIB:LIBC";
+      args[i++] = "/NODEFAULTLIB:OLDNAMES";
+
+    }
+
+  args[i] = NULL;
+
+  dumpargs(args);
+  return run(args);
+}
diff -r 9864735a4241 build/wince/tools/vs9ppc2003arm/arm-wince-lib.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/build/wince/tools/vs9ppc2003arm/arm-wince-lib.c	Fri Sep 26 09:30:25 2008 -0500
@@ -0,0 +1,16 @@
+#include "toolspath.h"
+
+
+int 
+main(int argc, char **argv)
+{
+  char* args[1000];
+  int i = 0;
+
+  args[i++] = LIB_PATH;
+
+  argpath_conv(&argv[1], &args[i]);
+
+  return run(args);
+
+}
diff -r 9864735a4241 build/wince/tools/vs9ppc2003arm/arm-wince-link.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/build/wince/tools/vs9ppc2003arm/arm-wince-link.c	Fri Sep 26 09:30:25 2008 -0500
@@ -0,0 +1,62 @@
+#include "toolspath.h"
+
+int
+main(int argc, char **argv)
+{
+  int iRetVal;
+  char* args[1000];
+  int i = 0;
+  int j = 0;
+  int k = 0;
+  int s = 0;
+  args[i++] = LINK_PATH;
+
+  args[i++] = "/LIBPATH:\"" WCE_LIB "\"";
+  args[i++] = "/LIBPATH:\"" WCE_CRT "\"";
+  args[i++] = "/LIBPATH:\"" SHUNT_LIB "\"";
+
+  args[i++] = "winsock.lib";
+  args[i++] = "corelibc.lib";
+  args[i++] = "coredll.lib";
+  args[i++] = "ceshell.lib";
+  args[i++] = "ole32.lib";
+  args[i++] = "mmtimer.lib";
+  args[i++] = "mozce_shunt.lib";
+
+  args[i++] = "/NODEFAULTLIB:LIBC";
+  args[i++] = "/NODEFAULTLIB:OLDNAMES";
+
+  // if -DLL is not passed, then change the entry to 'main'
+  while(argv[j])
+    {
+	  if (strncmp(argv[j], "-DLL", 4) == 0 || strncmp(argv[j], "/DLL", 4) == 0)
+		{
+		  k = 1;
+
+		}
+	  if (strncmp(argv[j], "-entry", 6) == 0 || strncmp(argv[j], "/entry", 6) == 0 || strncmp(argv[j], "-ENTRY", 6) == 0 || strncmp(argv[j], "/ENTRY",6 ) == 0)
+		{
+		  k = 1;
+
+		}
+	  if (strncmp(argv[j], "-subsystem:", 11) == 0 || strncmp(argv[j], "/subsystem:", 11) == 0 || strncmp(argv[j], "-SUBSYSTEM:", 11) == 0 || strncmp(argv[j], "/SUBSYSTEM:", 11) == 0)
+		{
+		  s = 1;
+
+		}
+      j++;
+    }
+
+  if (k==0)
+    args[i++] = "/ENTRY:main";
+
+  if (s==0){
+    args[i++] = "/subsystem:\"WINDOWSCE,5.02\"";
+  }
+
+  argpath_conv(&argv[1], &args[i]);
+
+  dumpargs(args);
+
+  return run(args);
+}
diff -r 9864735a4241 build/wince/tools/vs9ppc2003arm/arm-wince-res.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/build/wince/tools/vs9ppc2003arm/arm-wince-res.c	Fri Sep 26 09:30:25 2008 -0500
@@ -0,0 +1,19 @@
+#include "toolspath.h"
+
+int
+main(int argc, char **argv)
+{
+  int iRetVal;
+  char* args[1000];
+  int i = 0;
+  int j = 0;
+  int k = 0;
+  int s = 0;
+  args[i++] = RC_PATH;
+
+  argpath_conv(&argv[1], &args[i]);
+
+  dumpargs(args);
+
+  return run(args);
+}
diff -r 9864735a4241 build/wince/tools/vs9ppc2003arm/toolspath.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/build/wince/tools/vs9ppc2003arm/toolspath.h	Fri Sep 26 09:30:25 2008 -0500
@@ -0,0 +1,277 @@
+#include <windows.h>
+#include <stdio.h>
+#include <process.h>
+
+#ifndef TOPSRCDIR
+#include "../topsrcdir.h"
+#endif
+
+#define WCE_BIN    "c:\\Program Files\\Microsoft Visual Studio 9.0\\VC\\ce\\bin\\x86_arm\\"
+#define WCE_RC_BIN "c:\\Program Files\\Microsoft SDKs\\Windows\\v6.0a\\bin\\"
+#define WCE_CRT    "c:\\Program Files\\Microsoft Visual Studio 9.0\\VC\\ce\\lib\\armv4i"
+#define WCE_INC    "c:\\Program Files\\Windows Mobile 6 SDK\\Smartphone\\Include\\Armv4i"
+#define WCE_LIB    "c:\\Program Files\\Windows Mobile 6 SDK\\Smartphone\\Lib\\Armv4i"
+
+
+#define SHUNT_LIB TOPSRCDIR "/build/wince/shunt/build/vs9/"
+#define SHUNT_INC TOPSRCDIR "/build/wince/shunt/include/"
+
+#define ASM_PATH  WCE_BIN "armasm.exe"
+#define CL_PATH   WCE_BIN "cl.exe"
+#define LIB_PATH  WCE_BIN "lib.exe"
+#define LINK_PATH WCE_BIN "link.exe"
+#define RC_PATH   WCE_RC_BIN "rc.exe"
+
+#define MAX_NOLEAK_BUFFERS 100
+char noleak_buffers[MAX_NOLEAK_BUFFERS][1024];
+static int next_buffer = 0;
+
+int argpath_conv(char **args_in, char **args_out)
+{
+  int i = 0;
+
+  while (args_in[i])
+  {
+    char *offset;
+
+    args_out[i] = args_in[i];
+
+    if (args_in[i])
+    {
+      // First, look for the case of "-Fo/c/xxxxxxx" and "/Fo/c/xxxxx"
+      if ( (args_out[i][0] == '-' || args_out[i][0] == '/') &&
+           (args_out[i][1] == 'F') && (args_out[i][2] == 'o') &&
+           (args_out[i][3] == '/') && (strlen(args_out[i]) > 5) ) {
+
+        //printf("ARGS_IN: -FoXXXX is %s\n",args_in[i]);
+
+        strcpy(noleak_buffers[next_buffer], args_in[i]);
+
+        noleak_buffers[next_buffer][0] = '/';
+        noleak_buffers[next_buffer][3] = noleak_buffers[next_buffer][4];
+        noleak_buffers[next_buffer][4] = ':';
+
+        args_out[i] = noleak_buffers[next_buffer];
+
+        //printf("ARGS_OUT: -FoXXXX is %s\n",args_out[i]);
+
+        next_buffer++;
+      }
+      else if ((args_out[i][0] == '/') && (args_out[i][2] == '/'))
+      {
+        // Assume this is a pathname, and adjust accordingly
+        //printf("ARGS_IN: PATHNAME ASSUMED: %s\n", args_in[i]);
+
+        strcpy(noleak_buffers[next_buffer], args_in[i]);
+
+        noleak_buffers[next_buffer][0] = noleak_buffers[next_buffer][1];
+        noleak_buffers[next_buffer][1] = ':';
+
+        args_out[i] = noleak_buffers[next_buffer];
+        //printf("ARGS_OUT: PATHNAME MODIFIED TO BE: %s\n", args_out[i]);
+
+        next_buffer++;
+      }
+      else if ((args_out[i][0] == '\\') && (args_out[i][2] == '\\'))
+      {
+        // Assume this is a pathname, and adjust accordingly
+        //printf("ARGS_IN: PATHNAME ASSUMED: %s\n", args_in[i]);
+
+        strcpy(noleak_buffers[next_buffer], args_in[i]);
+
+        noleak_buffers[next_buffer][0] = noleak_buffers[next_buffer][1];
+        noleak_buffers[next_buffer][1] = ':';
+
+        args_out[i] = noleak_buffers[next_buffer];
+        //printf("ARGS_OUT: PATHNAME MODIFIED TO BE: %s\n", args_out[i]);
+
+        next_buffer++;
+      }
+      else if ((args_out[i][0] == '\\') && (args_out[i][1] == '\\') &&
+               (args_out[i][3] == '\\') && (args_out[i][4] == '\\'))
+      {
+        // Assume this is a pathname, and adjust accordingly
+        //printf("ARGS_IN: PATHNAME ASSUMED: %s\n", args_in[i]);
+
+        noleak_buffers[next_buffer][0] = args_in[i][2];
+        noleak_buffers[next_buffer][1] = ':';
+        noleak_buffers[next_buffer][2] = '\0';
+
+        strcpy(noleak_buffers[next_buffer], &args_in[i][3]);
+
+        args_out[i] = noleak_buffers[next_buffer];
+        //printf("ARGS_OUT: PATHNAME MODIFIED TO BE: %s\n", args_out[i]);
+
+        next_buffer++;
+      }
+      else if ( strstr(args_out[i], "OUT:") || strstr(args_out[i], "DEF:") )
+      {
+        // Deal with -OUT:/c/....
+        //
+        // NOTE: THERE IS A BUG IN THIS IMPLEMENTATION IF 
+        //       THERE IS A SPACE IN THE TOPSRCDIR PATH.
+        //
+        // Should really check for spaces, then double-quote
+        // the path if any space is found.
+        // -- wolfe@lobo.us  25-Aug-08
+        if ((args_out[i][5] == '/') && (args_out[i][7] == '/'))
+        {
+          // Assume this is a pathname, and adjust accordingly
+          //printf("ARGS_IN: PATHNAME ASSUMED: %s\n", args_in[i]);
+
+          strcpy(noleak_buffers[next_buffer], args_in[i]);
+
+          noleak_buffers[next_buffer][5] = noleak_buffers[next_buffer][6];
+          noleak_buffers[next_buffer][6] = ':';
+
+          args_out[i] = noleak_buffers[next_buffer];
+          //printf("ARGS_OUT: PATHNAME MODIFIED TO BE: %s\n", args_out[i]);
+        }
+        // Deal with -OUT:"/c/...."
+        else if ((args_out[i][6] == '/') && (args_out[i][8] == '/'))
+        {
+          // Assume this is a pathname, and adjust accordingly
+          //printf("ARGS_IN: PATHNAME ASSUMED: %s\n", args_in[i]);
+
+          strcpy(noleak_buffers[next_buffer], args_in[i]);
+
+          noleak_buffers[next_buffer][6] = noleak_buffers[next_buffer][7];
+          noleak_buffers[next_buffer][7] = ':';
+
+          args_out[i] = noleak_buffers[next_buffer];
+          //printf("ARGS_OUT: PATHNAME MODIFIED TO BE: %s\n", args_out[i]);
+        }
+
+        next_buffer++;
+      }
+      else
+      {
+        char *offset = strstr(args_out[i], "/cygdrive/");
+
+        if (offset) {
+
+          strcpy(offset, offset+9);
+          offset[0] = offset[1];
+          offset[1] = ':';
+          offset[2] = '/';
+        }
+
+        if ( (args_out[i][0] == '-' || args_out[i][0] == '/') &&
+             (args_out[i][1] == 'D'))
+        {
+
+          offset = strstr(args_out[i]+2, "=");
+          if (offset)
+          {
+            char* equalsChar = offset;
+
+            if (equalsChar[1] == '"')
+            {
+              *equalsChar = '\0';
+
+              strcpy(noleak_buffers[next_buffer], args_out[i]);
+
+              *equalsChar = '=';
+
+              strcat(noleak_buffers[next_buffer], "=\\\"");
+              strcat(noleak_buffers[next_buffer], equalsChar+1);
+              strcat(noleak_buffers[next_buffer], "\\\"");
+
+              args_out[i] = noleak_buffers[next_buffer];
+
+              next_buffer++;
+            }
+          }
+        }
+      }
+
+      if (next_buffer > MAX_NOLEAK_BUFFERS) {
+        printf("OOPS - next_buffer > MAX_NOLEAK_BUFFERS\n");
+        exit(-1);
+      }
+    }
+    i++;
+  }
+  args_out[i] = NULL;
+  return i;
+}
+
+void dumpargs(char** args)
+{
+ int i = 0;
+
+ if (args[0] == NULL)
+   printf(":: first element is null!\n");
+
+ while(args[i])
+   printf("%s ", args[i++]);
+
+ printf("\n");
+ fflush(stdout);
+ fflush(stderr);
+}
+
+
+DWORD run(char** args)
+{
+
+ DWORD exitCode;
+ STARTUPINFO si;
+ PROCESS_INFORMATION pi;
+
+ char theArgs[1024*16];
+
+ int totalLen = 0;
+ int i, j;
+
+
+ // Clear any link env variable that might get us tangled up
+ _putenv("LINK=");
+ _putenv("LIBPATH=");
+ _putenv("CC=");
+
+ _putenv("INCLUDE=" WCE_INC);
+ _putenv("LIB=" WCE_LIB);
+
+ for (j=1; args[j]; j++)
+ {
+   int len = strlen(args[j]);
+   strcat(&theArgs[totalLen], args[j]);
+   totalLen += len;
+
+   strcat(&theArgs[totalLen], " ");
+   totalLen++;
+ }
+
+ i = strlen(args[0]);
+ for (j=0; j<i; j++)
+ {
+   if (args[0][j] == '/')
+     args[0][j] = '\\';
+ }
+
+ ZeroMemory( &si, sizeof(si) );
+ si.cb = sizeof(si);
+ ZeroMemory( &pi, sizeof(pi));
+
+ CreateProcess(args[0],
+               theArgs,
+               NULL,
+               NULL,
+               0,
+               0,
+               NULL,
+               NULL,
+               &si,              // Pointer to STARTUPINFO structure.
+               &pi);
+
+
+ // Wait until child process exits.
+ WaitForSingleObject( pi.hProcess, INFINITE );
+ GetExitCodeProcess(pi.hProcess, &exitCode);
+ // Close process and thread handles.
+ CloseHandle( pi.hProcess );
+ CloseHandle( pi.hThread );
+
+ return exitCode;
+}
diff -r 9864735a4241 content/base/public/nsIXMLHttpRequest.idl
--- a/content/base/public/nsIXMLHttpRequest.idl	Mon Sep 22 11:50:03 2008 -0700
+++ b/content/base/public/nsIXMLHttpRequest.idl	Fri Sep 26 09:30:25 2008 -0500
@@ -96,17 +96,17 @@ interface nsIXMLHttpRequestUpload : nsIX
  *   The 'onload', 'onerror', and 'onreadystatechange' attributes moved to
  *   nsIJSXMLHttpRequest, but if you're coding in C++ you should avoid using
  *   those.
  *
  * Conclusion: Do not use event listeners on XMLHttpRequest from C++, unless
  * you're aware of all the security implications.  And then think twice about
  * it.
  */
-[scriptable, uuid(acda85ab-d06c-4176-b834-6d129ca97ca3)]
+[scriptable, uuid(ae8f1468-cd7f-4aea-9c40-a3f085db9369)]
 interface nsIXMLHttpRequest : nsISupports
 {
   /**
    * The request uses a channel in order to perform the
    * request.  This attribute represents the channel used
    * for the request.  NULL if the channel has not yet been
    * created.
    *
@@ -329,103 +329,57 @@ interface nsIXMLHttpRequest : nsISupport
    *                  null.
    * @param scriptContext The script context to use for the request. May be
    *                      null.
    * @param ownerWindow The associated window for the request. May be null.
    */
   [noscript] void init(in nsIPrincipal principal,
                        in nsIScriptContext scriptContext,
                        in nsPIDOMWindow ownerWindow);
-};
 
-[scriptable, uuid(6e127bd2-b4c1-4a82-be0d-012bd24efb37)]
-interface nsIXMLHttpRequestUploadGetter : nsISupports {
   /**
    * Upload process can be tracked by adding event listener to |upload|.
    */
   readonly attribute nsIXMLHttpRequestUpload upload;
-};
-
-[scriptable, uuid(261676b4-d508-43bf-b099-74635a0ee2e9)]
-interface nsIJSXMLHttpRequest : nsISupports {
-  /**
-   * Meant to be a script-only mechanism for setting a load event listener.
-   * The attribute is expected to be JavaScript function object. When
-   * the load event occurs, the function is invoked.
-   * This attribute should not be used from native code!!
-   *
-   * After the initial response, all event listeners will be cleared.
-   * // XXXbz what does that mean, exactly?   
-   *
-   * Call open() before setting an onload listener.
-   *
-   * Mozilla only.
-   */
-  attribute nsIDOMEventListener onload;
-
-  /**
-   * Meant to be a script-only mechanism for setting an error event listener.
-   * The attribute is expected to be JavaScript function object. When
-   * the error event occurs, the function is invoked.
-   * This attribute should not be used from native code!!
-   *
-   * After the initial response, all event listeners will be cleared.
-   * // XXXbz what does that mean, exactly?   
-   *
-   * Call open() before setting an onerror listener.
-   *
-   * Mozilla only.
-   */
-  attribute nsIDOMEventListener onerror;
-
-  /**
-   * Meant to be a script-only mechanism for setting a progress event listener.
-   * The attribute is expected to be JavaScript function object. When
-   * the error event occurs, the function is invoked.
-   * This attribute should not be used from native code!!
-   * This event listener may be called multiple times during the open request.
-   *
-   * After the initial response, all event listeners will be cleared.
-   * // XXXbz what does that mean, exactly?
-   *
-   * This event listener must be set BEFORE calling open().
-   *
-   * Mozilla only.
-   */
-  attribute nsIDOMEventListener onprogress;
-
-  /**
-   * Meant to be a script-only mechanism for setting an upload progress event
-   * listener.
-   * This attribute should not be used from native code!!
-   * This event listener may be called multiple times during the upload..
-   *
-   * After the initial response, all event listeners will be cleared.
-   * // XXXbz what does that mean, exactly?
-   *
-   * This event listener must be set BEFORE calling open().
-   *
-   * Mozilla only.
-   */
-  attribute nsIDOMEventListener onuploadprogress;
 
   /**
    * Meant to be a script-only mechanism for setting a callback function.
    * The attribute is expected to be JavaScript function object. When the
    * readyState changes, the callback function will be called.
    * This attribute should not be used from native code!!
    *
    * After the initial response, all event listeners will be cleared.
    * // XXXbz what does that mean, exactly?   
    *
    * Call open() before setting an onreadystatechange listener.
    */
   attribute nsIDOMEventListener onreadystatechange;
 };
 
+/**
+ * DEPRECATED.
+ */
+[scriptable, uuid(261676b4-d508-43bf-b099-74635a0ee2e9)]
+interface nsIJSXMLHttpRequest : nsISupports {
+  /**
+   * Meant to be a script-only mechanism for setting an upload progress event
+   * listener.
+   * This attribute should not be used from native code!!
+   * This event listener may be called multiple times during the upload..
+   *
+   * After the initial response, all event listeners will be cleared.
+   * // XXXbz what does that mean, exactly?
+   *
+   * This event listener must be set BEFORE calling open().
+   *
+   * Mozilla only.
+   */
+  attribute nsIDOMEventListener onuploadprogress;
+};
+
 %{ C++
 #define NS_XMLHTTPREQUEST_CID                       \
  { /* d164e770-4157-11d4-9a42-000064657374 */       \
   0xd164e770, 0x4157, 0x11d4,                       \
  {0x9a, 0x42, 0x00, 0x00, 0x64, 0x65, 0x73, 0x74} }
 #define NS_XMLHTTPREQUEST_CONTRACTID \
 "@mozilla.org/xmlextras/xmlhttprequest;1"
 %}
diff -r 9864735a4241 content/base/src/nsDocument.cpp
--- a/content/base/src/nsDocument.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/content/base/src/nsDocument.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -5256,31 +5256,36 @@ BlastSubtreeToPieces(nsINode *aNode)
   if (aNode->IsNodeOfType(nsINode::eELEMENT)) {
     nsGenericElement *element = static_cast<nsGenericElement*>(aNode);
     const nsDOMAttributeMap *map = element->GetAttributeMap();
     if (map) {
       nsCOMPtr<nsIAttribute> attr;
       while (map->Enumerate(BlastFunc, &attr) > 0) {
         BlastSubtreeToPieces(attr);
 
-        nsresult rv = element->UnsetAttr(attr->NodeInfo()->NamespaceID(),
-                                         attr->NodeInfo()->NameAtom(),
-                                         PR_FALSE);
+#ifdef DEBUG
+        nsresult rv =
+#endif
+          element->UnsetAttr(attr->NodeInfo()->NamespaceID(),
+                             attr->NodeInfo()->NameAtom(),
+                             PR_FALSE);
 
         // XXX Should we abort here?
         NS_ASSERTION(NS_SUCCEEDED(rv), "Uhoh, UnsetAttr shouldn't fail!");
       }
     }
   }
 
   count = aNode->GetChildCount();
   for (i = 0; i < count; ++i) {
     BlastSubtreeToPieces(aNode->GetChildAt(0));
-
-    nsresult rv = aNode->RemoveChildAt(0, PR_FALSE);
+#ifdef DEBUG
+    nsresult rv =
+#endif
+      aNode->RemoveChildAt(0, PR_FALSE);
 
     // XXX Should we abort here?
     NS_ASSERTION(NS_SUCCEEDED(rv), "Uhoh, RemoveChildAt shouldn't fail!");
   }
 }
 
 NS_IMETHODIMP
 nsDocument::AdoptNode(nsIDOMNode *aAdoptedNode, nsIDOMNode **aResult)
diff -r 9864735a4241 content/base/src/nsObjectLoadingContent.cpp
--- a/content/base/src/nsObjectLoadingContent.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/content/base/src/nsObjectLoadingContent.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -1674,17 +1674,17 @@ nsObjectLoadingContent::TryInstantiate(c
 {
   nsIObjectFrame* frame = GetExistingFrame(eFlushContent);
   if (!frame) {
     LOG(("OBJLC [%p]: No frame yet\n", this));
     return NS_OK; // Not a failure to have no frame
   }
 
   nsCOMPtr<nsIPluginInstance> instance;
-  nsresult rv = frame->GetPluginInstance(*getter_AddRefs(instance));
+  frame->GetPluginInstance(*getter_AddRefs(instance));
 
   if (!instance) {
     // The frame has no plugin instance yet. If the frame hasn't been
     // reflown yet, do nothing as once the reflow happens we'll end up
     // instantiating the plugin with the correct size n' all (which
     // isn't known until we've done the first reflow). But if the
     // frame does have a plugin instance already, be sure to
     // re-instantiate the plugin as its source or whatnot might have
diff -r 9864735a4241 content/canvas/src/nsCanvasRenderingContext2D.cpp
--- a/content/canvas/src/nsCanvasRenderingContext2D.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/content/canvas/src/nsCanvasRenderingContext2D.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -2148,17 +2148,20 @@ nsCanvasRenderingContext2D::GetMozTextSt
     // font and mozTextStyle are the same value
     return GetFont(textStyle);
 }
 
 gfxFontGroup *nsCanvasRenderingContext2D::GetCurrentFontStyle()
 {
     // use lazy initilization for the font group since it's rather expensive
     if(!CurrentState().fontGroup) {
-        nsresult res = SetMozTextStyle(NS_LITERAL_STRING("10px sans-serif"));
+#ifdef DEBUG
+        nsresult res =
+#endif
+            SetMozTextStyle(NS_LITERAL_STRING("10px sans-serif"));
         NS_ASSERTION(res == NS_OK, "Default canvas font is invalid");
     }
 
     return CurrentState().fontGroup;
 }
 
 NS_IMETHODIMP
 nsCanvasRenderingContext2D::MozDrawText(const nsAString& textToDraw)
diff -r 9864735a4241 content/html/document/src/nsImageDocument.cpp
--- a/content/html/document/src/nsImageDocument.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/content/html/document/src/nsImageDocument.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -366,17 +366,20 @@ nsImageDocument::SetScriptGlobalObject(n
 
   // Set the script global object on the superclass before doing
   // anything that might require it....
   nsHTMLDocument::SetScriptGlobalObject(aScriptGlobalObject);
 
   if (aScriptGlobalObject) {
     if (!GetRootContent()) {
       // Create synthetic document
-      nsresult rv = CreateSyntheticDocument();
+#ifdef DEBUG
+      nsresult rv =
+#endif
+        CreateSyntheticDocument();
       NS_ASSERTION(NS_SUCCEEDED(rv), "failed to create synthetic document");
 
       target = do_QueryInterface(mImageContent);
       target->AddEventListener(NS_LITERAL_STRING("click"), this, PR_FALSE);
     }
 
     target = do_QueryInterface(aScriptGlobalObject);
     target->AddEventListener(NS_LITERAL_STRING("resize"), this, PR_FALSE);
diff -r 9864735a4241 content/xbl/src/nsBindingManager.cpp
--- a/content/xbl/src/nsBindingManager.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/content/xbl/src/nsBindingManager.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -985,17 +985,16 @@ void
 void
 nsBindingManager::ProcessAttachedQueue(PRUint32 aSkipSize)
 {
   if (mProcessingAttachedStack || mAttachedStack.Length() <= aSkipSize)
     return;
 
   mProcessingAttachedStack = PR_TRUE;
 
-  PRUint32 currentIndex = aSkipSize;
   // Excute constructors. Do this from high index to low
   while (mAttachedStack.Length() > aSkipSize) {
     PRUint32 lastItem = mAttachedStack.Length() - 1;
     nsRefPtr<nsXBLBinding> binding = mAttachedStack.ElementAt(lastItem);
     mAttachedStack.RemoveElementAt(lastItem);
     if (binding) {
       binding->ExecuteAttachedHandler();
     }
diff -r 9864735a4241 embedding/components/find/public/nsIFind.idl
--- a/embedding/components/find/public/nsIFind.idl	Mon Sep 22 11:50:03 2008 -0700
+++ b/embedding/components/find/public/nsIFind.idl	Fri Sep 26 09:30:25 2008 -0500
@@ -46,31 +46,27 @@ interface nsIFind : nsISupports
 {
   attribute boolean findBackwards;
   attribute boolean caseSensitive;
 
   /**
    * Use "find entire words" mode by setting to a word breaker
    * or null, to disable "entire words" mode.
    */
-  attribute nsIWordBreaker wordBreaker;
+  [noscript] attribute nsIWordBreaker wordBreaker;
 
   /**
    * Find some text in the current context. The implementation is
    * responsible for performing the find and highlighting the text.
    *
    * @param aPatText     The text to search for.
    * @param aSearchRange A Range specifying domain of search.
    * @param aStartPoint  A Range specifying search start point.
    *                     If not collapsed, we'll start from
    *                     end (forward) or start (backward).
-   *                     May be null; if so, we'll start at the start
-   *                     (forward) or end (back) of aSearchRange.
    * @param aEndPoint    A Range specifying search end point.
    *                     If not collapsed, we'll end at
    *                     end (forward) or start (backward).
-   *                     May be null; if so, we'll end at the end
-   *                     (forward) or start (back) of aSearchRange.
    * @retval             A range spanning the match that was found (or null).
    */
   nsIDOMRange Find(in wstring aPatText, in nsIDOMRange aSearchRange,
                    in nsIDOMRange aStartPoint, in nsIDOMRange aEndPoint);
 };
diff -r 9864735a4241 embedding/test/Makefile.in
--- a/embedding/test/Makefile.in	Mon Sep 22 11:50:03 2008 -0700
+++ b/embedding/test/Makefile.in	Fri Sep 26 09:30:25 2008 -0500
@@ -38,15 +38,16 @@ topsrcdir	= @top_srcdir@
 topsrcdir	= @top_srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 relativesrcdir  = embedding/test
 
 include $(DEPTH)/config/autoconf.mk
 include $(topsrcdir)/config/rules.mk
 
-_TEST_FILES =	test_bug293834.html \
-		bug293834_form.html \
-		$(NULL)
+_TEST_FILES = \
+	test_bug293834.html \
+	bug293834_form.html \
+	test_nsFind.html \
+	$(NULL)
 
 libs:: $(_TEST_FILES)
 	$(INSTALL) $(foreach f,$^,"$f") $(DEPTH)/_tests/testing/mochitest/tests/$(relativesrcdir)
-
diff -r 9864735a4241 embedding/test/test_nsFind.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/embedding/test/test_nsFind.html	Fri Sep 26 09:30:25 2008 -0500
@@ -0,0 +1,128 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=450048
+-->
+<head>
+  <title>Test for nsFind::Find()</title>
+  <script type="application/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=450048">Mozilla Bug 450048</a>
+<p id="display">This is the text to search i<b>n&shy;t</b>o</p>
+<div id="content" style="display: none">
+  
+</div>
+<pre id="test">
+<script type="application/javascript">
+
+/** Test for Bug 450048 **/
+
+  // Check nsFind class and its nsIFind interface.
+
+  netscape.security.PrivilegeManager.enablePrivilege('UniversalXPConnect');
+
+  var rf = Components.classes["@mozilla.org/embedcomp/rangefind;1"]
+                     .getService(Components.interfaces.nsIFind);
+
+  var display = window.document.getElementById("display");
+  var searchRange = window.document.createRange();
+  searchRange.setStart(display, 0);
+  searchRange.setEnd(display, display.childNodes.length);
+  var startPt = searchRange;
+  var endPt = searchRange;
+
+  // Check |null| detection on |aPatText| parameter.
+  try {
+    rf.Find(null, searchRange, startPt, endPt);
+
+    ok(false, "Missing NS_ERROR_NULL_POINTER exception");
+  } catch (e if (e instanceof Components.interfaces.nsIException &&
+                 e.result == Components.results.NS_ERROR_NULL_POINTER)) {
+    ok(true, null);
+  }
+
+  // Check |null| detection on |aSearchRange| parameter.
+  try {
+    rf.Find("", null, startPt, endPt);
+
+    ok(false, "Missing NS_ERROR_ILLEGAL_VALUE exception");
+  } catch (e if (e instanceof Components.interfaces.nsIException &&
+                 e.result == Components.results.NS_ERROR_ILLEGAL_VALUE)) {
+    ok(true, null);
+  }
+
+  // Check |null| detection on |aStartPoint| parameter.
+  try {
+    rf.Find("", searchRange, null, endPt);
+
+    ok(false, "Missing NS_ERROR_ILLEGAL_VALUE exception");
+  } catch (e if (e instanceof Components.interfaces.nsIException &&
+                 e.result == Components.results.NS_ERROR_ILLEGAL_VALUE)) {
+    ok(true, null);
+  }
+
+  // Check |null| detection on |aEndPoint| parameter.
+  try {
+    rf.Find("", searchRange, startPt, null);
+
+    ok(false, "Missing NS_ERROR_ILLEGAL_VALUE exception");
+  } catch (e if (e instanceof Components.interfaces.nsIException &&
+                 e.result == Components.results.NS_ERROR_ILLEGAL_VALUE)) {
+    ok(true, null);
+  }
+
+  var searchValue, retRange;
+
+  rf.findBackwards = false;
+
+  rf.caseSensitive = false;
+
+  searchValue = "TexT";
+  retRange = rf.Find(searchValue, searchRange, startPt, endPt);
+  ok(retRange, "\"" + searchValue + "\" not found (not caseSensitive)");
+
+  rf.caseSensitive = true;
+
+  // searchValue = "TexT";
+  retRange = rf.Find(searchValue, searchRange, startPt, endPt);
+  ok(!retRange, "\"" + searchValue + "\" found (caseSensitive)");
+
+  searchValue = "text";
+  retRange = rf.Find(searchValue, searchRange, startPt, endPt);
+  ok(retRange, "\"" + searchValue + "\" not found");
+
+  // Matches |i<b>n&shy;t</b>o|.
+  searchValue = "into";
+  retRange = rf.Find(searchValue, searchRange, startPt, endPt);
+  ok(retRange, "\"" + searchValue + "\" not found");
+
+  // Matches inside |search|.
+  searchValue = "ear";
+  retRange = rf.Find(searchValue, searchRange, startPt, endPt);
+  ok(retRange, "\"" + searchValue + "\" not found");
+
+  // Set new start point (to end of last search).
+  startPt = retRange.endContainer.ownerDocument.createRange();
+  startPt.setStart(retRange.endContainer, retRange.endOffset);
+  startPt.setEnd(retRange.endContainer, retRange.endOffset);
+
+  searchValue = "t";
+  retRange = rf.Find(searchValue, searchRange, startPt, endPt);
+  ok(retRange, "\"" + searchValue + "\" not found (forward)");
+
+  searchValue = "the";
+  retRange = rf.Find(searchValue, searchRange, startPt, endPt);
+  ok(!retRange, "\"" + searchValue + "\" found (forward)");
+
+  rf.findBackwards = true;
+
+  // searchValue = "the";
+  retRange = rf.Find(searchValue, searchRange, startPt, endPt);
+  ok(retRange, "\"" + searchValue + "\" not found (backward)");
+</script>
+</pre>
+</body>
+</html>
diff -r 9864735a4241 gfx/thebes/src/gfxWindowsFonts.cpp
--- a/gfx/thebes/src/gfxWindowsFonts.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/gfx/thebes/src/gfxWindowsFonts.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -644,17 +644,17 @@ gfxWindowsFont::ComputeMetrics()
     SIZE size;
     GetTextExtentPoint32W(dc, L" ", 1, &size);
     mMetrics->spaceWidth = ROUND(size.cx);
 
     // Cache the width of digit zero.
     // XXX MSDN (http://msdn.microsoft.com/en-us/library/ms534223.aspx)
     // does not say what the failure modes for GetTextExtentPoint32 are -
     // is it safe to assume it will fail iff the font has no '0'?
-    if (GetTextExtentPoint32(dc, "0", 1, &size))
+    if (GetTextExtentPoint32W(dc, L"0", 1, &size))
         mMetrics->zeroOrAveCharWidth = ROUND(size.cx);
     else
         mMetrics->zeroOrAveCharWidth = mMetrics->aveCharWidth;
 
     mSpaceGlyph = 0;
     if (metrics.tmPitchAndFamily & TMPF_TRUETYPE) {
         WORD glyph;
         DWORD ret = GetGlyphIndicesW(dc, L" ", 1, &glyph,
diff -r 9864735a4241 js/src/Makefile.in
--- a/js/src/Makefile.in	Mon Sep 22 11:50:03 2008 -0700
+++ b/js/src/Makefile.in	Fri Sep 26 09:30:25 2008 -0500
@@ -55,16 +55,18 @@ else
 else
 MODULE_OPTIMIZE_FLAGS = -O2 -ip
 #XXX: do we want different INTERP_OPTIMIZER flags here?
 endif
 else
 MODULE_OPTIMIZE_FLAGS = -Os -fstrict-aliasing $(MOZ_OPTIMIZE_SIZE_TWEAK)
 # Special optimization flags for jsinterp.c
 INTERP_OPTIMIZER = -O3 -fstrict-aliasing
+BUILTINS_OPTIMIZER = -O9 -fstrict-aliasing
+REGEXP_OPTIMIZER = -O9 -fstrict-aliasing -fomit-frame-pointer
 endif
 else
 ifeq ($(OS_ARCH),SunOS)
 MODULE_OPTIMIZE_FLAGS = -xO4
 endif
 ifeq ($(OS_ARCH),WINNT)
 MODULE_OPTIMIZE_FLAGS = -O2 -GL
 endif
@@ -444,19 +446,27 @@ LIR.o: LIR.cpp Makefile.in
 LIR.o: LIR.cpp Makefile.in
 	$(REPORT_BUILD)
 	@$(MAKE_DEPS_AUTO_CXX)
 	$(CXX) -o $@ -c $(patsubst -xO%,-xO2,$(COMPILE_CFLAGS)) $<
 endif
 endif
 endif
 
-# Allow building jsinterp.c with special optimization flags
+# Allow building jsinterp.c and a few others with special optimization flags
 ifdef INTERP_OPTIMIZER
 jsinterp.$(OBJ_SUFFIX): MODULE_OPTIMIZE_FLAGS=$(INTERP_OPTIMIZER)
+endif
+
+ifdef BUILTINS_OPTIMIZER
+jsbuiltins.$(OBJ_SUFFIX): MODULE_OPTIMIZE_FLAGS=$(BUILTINS_OPTIMIZER)
+endif
+
+ifdef REGEXP_OPTIMIZER
+jsregexp.$(OBJ_SUFFIX): MODULE_OPTIMIZE_FLAGS=$(REGEXP_OPTIMIZER)
 endif
 
 ifeq ($(OS_ARCH),IRIX)
 ifndef GNU_CC
 _COMPILE_CFLAGS  = $(patsubst -O%,-O1,$(COMPILE_CFLAGS))
 jsapi.o jsxdrapi.o jsarena.o jsarray.o jsatom.o jsemit.o jsfun.o jsinterp.o jsregexp.o jsparse.o jsopcode.o jsscript.o: %.o: %.cpp Makefile.in
 	$(REPORT_BUILD)
 	@$(MAKE_DEPS_AUTO_CXX)
diff -r 9864735a4241 js/src/Makefile.ref
--- a/js/src/Makefile.ref	Mon Sep 22 11:50:03 2008 -0700
+++ b/js/src/Makefile.ref	Fri Sep 26 09:30:25 2008 -0500
@@ -101,16 +101,17 @@ endif
 
 
 #
 # XCFLAGS may be set in the environment or on the gmake command line
 #
 #CFLAGS += -DDEBUG -DDEBUG_brendan -DJS_ARENAMETER -DJS_HASHMETER -DJS_DUMP_PROPTREE_STATS -DJS_DUMP_SCOPE_METERS -DJS_SCOPE_DEPTH_METER -DJS_BASIC_STATS
 CFLAGS          += $(OPTIMIZER) $(OS_CFLAGS) $(DEFINES) $(INCLUDES) $(XCFLAGS)
 INTERP_CFLAGS   += $(INTERP_OPTIMIZER) $(OS_CFLAGS) $(DEFINES) $(INCLUDES) $(XCFLAGS) $(INTERP_XCFLAGS)
+REGEXP_CFLAGS   += $(REGEXP_OPTIMIZER) $(OS_CFLAGS) $(DEFINES) $(INCLUDES) $(XCFLAGS) $(REGEXP_XCFLAGS)
 BUILTINS_CFLAGS += $(BUILTINS_OPTIMIZER) $(OS_CFLAGS) $(DEFINES) $(INCLUDES) $(XCFLAGS) $(BUILTINS_XCFLAGS)
 
 LDFLAGS		= $(XLDFLAGS)
 LDFLAGS += $(OS_LDFLAGS)
 
 ifdef MOZ_SHARK
 DEFINES += -DMOZ_SHARK
 CFLAGS += -F/System/Library/PrivateFrameworks
diff -r 9864735a4241 js/src/builtins.tbl
--- a/js/src/builtins.tbl	Mon Sep 22 11:50:03 2008 -0700
+++ b/js/src/builtins.tbl	Fri Sep 26 09:30:25 2008 -0500
@@ -31,16 +31,43 @@
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
+/**
+ * This file declares the various builtins we recognize, and is
+ * included in various places in interesting ways.  Each line starts
+ * with "BUILTIN" then an integer indicating the number of arguments
+ * the builtin takes.  Builtins with no arguments are not supported at
+ * the moment.
+ *
+ * This is followed, in parentheses, by the following things, in order:
+ * - A name for the builtin.  Prefixed with "F_" this is the opcode name to
+ *   pass to insCall.  Prefixed with "js_" this is the name of the actual
+ *   native method to call.
+ * - The sizes of the arguments to the native, in order.  These can be "LO" for
+ *   integers (any size), pointers, or jsvals and "F" for doubles.
+ * - The size of the return value.  This can be "LO" for 32-bit integers, "P"
+ *   for pointers or jsvals, "F" for doubles, "Q" for 64-bit integers.
+ * - The actual C++ type of the return value
+ * - The C++ types of the arguments, in order
+ * - A boolean value (0 = false, 1 = true) indicating whether the builtin call
+ *   can be optimized away during common subexpression elimination.  This
+ *   should only be true if the the builtin is idempotent and the return value
+ *   is uniquely determined by the values of the arguments.
+ * - A boolean value  (0 = false, 1 = true) indicating whether the builtin call
+ *   can be optimized away during constant folding.  This should only be true
+ *   if the builtin is idempotent and if the return value can be determined at
+ *   compile time if the input values are known at compile time.
+ */
+
 /*
  * NB: bool FASTCALL is not compatible with Nanojit's calling convention usage.
  * Do not use bool FASTCALL, use JSBool only!
  */
 
 BUILTIN2(BoxDouble,             LO, F,  P,      jsval,     JSContext*, jsdouble, 1, 1)
 BUILTIN2(BoxInt32,              LO, LO, P,      jsval,     JSContext*, jsint, 1, 1)
 BUILTIN1(UnboxDouble,           LO,     F,      jsdouble,  jsval, 1, 1)
@@ -59,34 +86,41 @@ BUILTIN4(Array_dense_setelem,   LO, LO, 
 BUILTIN4(Array_dense_setelem,   LO, LO, LO, LO, LO, bool,  JSContext*, JSObject*, jsint, jsval, 0, 0)
 BUILTIN3(Array_p_join,          LO, LO, LO, P,  JSString*, JSContext*, JSObject*, JSString*, 0, 0)
 BUILTIN4(String_p_substring,    LO, LO, LO, LO, P,  JSString*, JSContext*, JSString*, jsint, jsint, 1, 1)
 BUILTIN3(String_p_substring_1,  LO, LO, LO, P,  JSString*, JSContext*, JSString*, jsint, 1, 1)
 BUILTIN3(ConcatStrings,         LO, LO, LO, P,  JSString*, JSContext*, JSString*, JSString*, 1, 1)
 BUILTIN3(String_getelem,        LO, LO, LO, P,  JSString*, JSContext*, JSString*, jsint, 1, 1)
 BUILTIN2(String_fromCharCode,   LO, LO, P,      JSString*, JSContext*, jsint, 1, 1)
 BUILTIN2(String_p_charCodeAt,   LO,     LO, LO, jsint,     JSString*, jsint, 1, 1)
-BUILTIN3(String_p_concat_1int,  LO, LO, LO, P,  JSString*, JSContest*, JSString*, jsint, 1, 1)
+BUILTIN3(String_p_concat_1int,  LO, LO, LO, P,  JSString*, JSContext*, JSString*, jsint, 1, 1)
+BUILTIN4(String_p_concat_2str,  LO, LO, LO, LO, P,  JSString*, JSContext*, JSString*, JSString*, JSString*, 1, 1)
+BUILTIN5(String_p_concat_3str,  LO, LO, LO, LO, LO, P,  JSString*, JSContext*, JSString*, JSString*, JSString*, JSString*, 1, 1)
 BUILTIN4(String_p_match,        LO, LO, LO, LO, P, JSObject*, JSContext*, JSString*, jsbytecode*, JSObject*, 1, 1)
+BUILTIN4(String_p_match_obj,    LO, LO, LO, LO, P, JSObject*, JSContext*, JSObject*, jsbytecode*, JSObject*, 1, 1)
 BUILTIN4(String_p_replace_str,  LO, LO, LO, LO, P, JSString*, JSContext*, JSString*, JSObject*, JSString*, 1, 1)
 BUILTIN4(String_p_replace_str2, LO, LO, LO, LO, P, JSString*, JSContext*, JSString*, JSString*, JSString*, 1, 1)
 BUILTIN5(String_p_replace_str3, LO, LO, LO, LO, LO, P, JSString*, JSContext*, JSString*, JSString*, JSString*, JSString*, 1, 1)
 BUILTIN3(String_p_split,        LO,     LO, LO, P, JSObject*, JSContext*, JSString*, JSString*, 0, 0)
 BUILTIN2(toLowerCase,           LO, LO, P,      JSString*, JSContext*, JSString*, 1, 1) 
 BUILTIN2(toUpperCase,           LO, LO, P,      JSString*, JSContext*, JSString*, 1, 1) 
 BUILTIN1(Math_random,           LO,     F,      jsdouble,  JSRuntime*, 0, 0)
 BUILTIN2(EqualStrings,          LO,     LO, LO, bool,      JSString*, JSString*, 1, 1)
 BUILTIN2(CompareStrings,        LO,     LO, LO, bool,      JSString*, JSString*, 1, 1)
 BUILTIN2(StringToNumber,        LO,     LO, F,  jsdouble,  JSContext*, JSString*, 1, 1)
 BUILTIN2(StringToInt32,         LO,     LO, LO, jsint,     JSContext*, JSString*, 1, 1)
 BUILTIN2(ParseInt,              LO,     LO, F,  jsdouble,  JSContext*, JSString*, 1, 1)
 BUILTIN1(ParseIntDouble,        F,          F,  jsdouble,  jsdouble, 1, 1)
 BUILTIN2(ParseFloat,            LO,     LO, F,  jsdouble,  JSContext*, JSString*, 1, 1)
-BUILTIN3(Any_getelem,           LO, LO, LO, P,  jsval,     JSContext*, JSObject*, JSString*, 0, 0)
-BUILTIN4(Any_setelem,           LO, LO, LO, LO, LO, bool,  JSContext*, JSObject*, JSString*, jsval, 0, 0)
+BUILTIN3(Any_getprop,           LO, LO, LO, P,  jsval,     JSContext*, JSObject*, JSString*, 0, 0)
+BUILTIN4(Any_setprop,           LO, LO, LO, LO, LO, bool,  JSContext*, JSObject*, JSString*, jsval, 0, 0)
+BUILTIN3(Any_getelem,           LO, LO, F,  P,  jsval,     JSContext*, JSObject*, jsdouble, 0, 0)
+BUILTIN4(Any_setelem,           LO, LO, F,  LO, LO, bool,  JSContext*, JSObject*, jsdouble, jsval, 0, 0)
+BUILTIN3(Any_getelem_int,       LO, LO, LO, P,  jsval,     JSContext*, JSObject*, jsuint, 0, 0)
+BUILTIN4(Any_setelem_int,       LO, LO, LO, LO, LO, bool,  JSContext*, JSObject*, jsuint, jsval, 0, 0)
 BUILTIN3(FastValueToIterator,   LO, LO, LO, P,  JSObject*, JSContext*, jsuint, jsval, 0, 0)
 BUILTIN2(FastCallIteratorNext,  LO,     LO, P,  JSObject*, JSContext*, JSObject*, 0, 0)
 BUILTIN2(CloseIterator,         LO,     LO, LO, bool,      JSContext*, jsval, 0, 0)
 BUILTIN2(CallTree,              LO, LO, P,      nanojit::GuardRecord*, avmplus::InterpState*, nanojit::Fragment*, 0, 0)
 BUILTIN2(FastNewArray,          LO,     LO, P,  JSObject*, JSContext*, JSObject*, 0, 0)
 BUILTIN2(FastNewObject,         LO,     LO, P,  JSObject*, JSContext*, JSObject*, 0, 0)
 BUILTIN3(AddProperty,           LO, LO, LO, LO, bool,      JSContext*, JSObject*, JSScopeProperty*, 0, 0)
 BUILTIN3(HasNamedProperty,      LO, LO, LO, LO, bool,      JSContext*, JSObject*, JSString*, 0, 0)
@@ -100,16 +134,17 @@ BUILTIN3(Object_p_propertyIsEnumerable,
                                 LO, LO, LO, LO, jsint,     JSContext*, JSObject*, JSString*, 0, 0)
 BUILTIN2(BooleanToNumber,       LO, LO, F,      jsdouble,  JSContext*, jsint, 1, 1)
 BUILTIN2(ObjectToString,        LO,     LO, P,  JSString*, JSContext*, JSObject*, 0, 0)
 BUILTIN3(Array_1int,            LO, LO, LO, P,  JSObject*, JSContext*, JSObject*, jsint, 0, 0)
 BUILTIN3(Array_1str,            LO, LO, LO, P,  JSObject*, JSContext*, JSObject*, JSString*, 0, 0)
 BUILTIN4(Array_2obj,            LO, LO, LO, LO, P, JSObject*, JSContext*, JSObject*, JSObject*, JSObject**, 0, 0)
 BUILTIN5(Array_3num,            LO, LO, F, F, F, P, JSObject*, JSContext*, JSObject*, jsdouble, jsdouble, jsdouble, 0, 0)
 BUILTIN1(Arguments,             LO,     P,      JSObject*, JSContext*, 0, 0)
+BUILTIN2(imod,                  LO, LO, LO,     jsint,     jsint,      jsint, 1, 1)
 
 // soft float
 BUILTIN1(fneg,   F,       F,  jsdouble, jsdouble, 1, 1)
 BUILTIN1(i2f,    LO,      F,  jsdouble, jsint,    1, 1)
 BUILTIN1(u2f,    LO,      F,  jsdouble, jsuint,   1, 1)
 BUILTIN2(fcmpeq, F,   F,  LO, jsint,    jsdouble, jsdouble, 1, 1)
 BUILTIN2(fcmplt, F,   F,  LO, jsint,    jsdouble, jsdouble, 1, 1)
 BUILTIN2(fcmple, F,   F,  LO, jsint,    jsdouble, jsdouble, 1, 1)
diff -r 9864735a4241 js/src/config.mk
--- a/js/src/config.mk	Mon Sep 22 11:50:03 2008 -0700
+++ b/js/src/config.mk	Fri Sep 26 09:30:25 2008 -0500
@@ -119,22 +119,24 @@ INSTALL	= $(DIST)/bin/nsinstall
 INSTALL	= $(DIST)/bin/nsinstall
 CP = cp
 endif
 
 ifdef BUILD_OPT
 ifdef USE_MSVC
 OPTIMIZER  = -O2 -GL
 INTERP_OPTIMIZER = -O2 -GL
+REGEXP_OPTIMIZER = -O2 -GL
 BUILTINS_OPTIMIZER = -O2 -GL
 LDFLAGS    += -LTCG
 else
 OPTIMIZER  = -Os -fno-exceptions -fno-rtti -fstrict-aliasing -Wall -Wstrict-aliasing=2
+INTERP_OPTIMIZER = -O3 -fstrict-aliasing -fno-exceptions -fno-rtti
+REGEXP_OPTIMIZER = -O9 -fomit-frame-pointer -fstrict-aliasing -fno-exceptions -fno-rtti
 BUILTINS_OPTIMIZER = -O9 -fstrict-aliasing -fno-exceptions -fno-rtti
-INTERP_OPTIMIZER = -O3 -fstrict-aliasing -fno-exceptions -fno-rtti
 endif
 DEFINES    += -UDEBUG -DNDEBUG -UDEBUG_$(USER)
 OBJDIR_TAG = _OPT
 else
 ifdef USE_MSVC
 OPTIMIZER  = -Zi
 INTERP_OPTIMIZER = -Zi
 BUILTINS_OPTIMIZER = $(INTERP_OPTIMIZER)
diff -r 9864735a4241 js/src/config/Linux_All.mk
--- a/js/src/config/Linux_All.mk	Mon Sep 22 11:50:03 2008 -0700
+++ b/js/src/config/Linux_All.mk	Fri Sep 26 09:30:25 2008 -0500
@@ -38,16 +38,17 @@
 # ***** END LICENSE BLOCK *****
 
 #
 # Config for all versions of Linux
 #
 
 CC = gcc
 CCC = g++
+LD = g++
 CFLAGS +=  -Wall -Wno-format -MMD
 OS_CFLAGS = -DXP_UNIX -DSVR4 -DSYSV -D_BSD_SOURCE -DPOSIX_SOURCE -DHAVE_LOCALTIME_R -DLINUX
 
 RANLIB = echo
 MKSHLIB = $(LD) -shared $(XMKSHLIBOPTS)
 
 #.c.o:
 #      $(CC) -c -MD $*.d $(CFLAGS) $<
diff -r 9864735a4241 js/src/correct/check-mont.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/correct/check-mont.js	Fri Sep 26 09:30:25 2008 -0500
@@ -0,0 +1,119 @@
+// regression test for Bug 452008 - TM: SRP in Clipperz crypto library fails when JIT (TraceMonkey) is enabled. 
+
+var x = [9385, 32112, 25383, 16317, 30138, 14565, 17812, 24500, 2719, 30174, 3546, 9096, 15352, 19120, 20648, 14334, 7426, 0, 0, 0];
+var n = [27875, 25925, 30422, 12227, 27798, 32170, 10873, 21748, 30629, 26296, 20697, 5125, 4815, 2221, 14392, 23369, 5560, 2, 0, 0];
+var np = 18229;
+var expected = [18770, 31456, 17999, 32635, 27508, 29131, 2856, 16233, 5439, 27580, 7093, 18192, 30804, 5472, 8529, 28649, 14852, 0, 0, 0];
+
+//globals
+bpe=0;         //bits stored per array element
+mask=0;        //AND this with an array element to chop it down to bpe bits
+
+//initialize the global variables
+for (bpe=0; (1<<(bpe+1)) > (1<<bpe); bpe++);  //bpe=number of bits in the mantissa on this platform
+bpe>>=1;                   //bpe=number of bits in one element of the array representing the bigInt
+mask=(1<<bpe)-1;           //AND the mask with an integer to get its bpe least significant bits
+
+
+//the following global variables are scratchpad memory to
+//reduce dynamic memory allocation in the inner loop
+sa = new Array(0); //used in mont_()
+
+//do x=y on bigInts x and y.  x must be an array at least as big as y (not counting the leading zeros in y).
+function copy_(x,y) {
+  var i;
+  var k=x.length<y.length ? x.length : y.length;
+  for (i=0;i<k;i++)
+    x[i]=y[i];
+  for (i=k;i<x.length;i++)
+    x[i]=0;
+}
+
+//do x=y on bigInt x and integer y.
+function copyInt_(x,n) {
+  var i,c;
+  for (c=n,i=0;i<x.length;i++) {
+    x[i]=c & mask;
+    c>>=bpe;
+  }
+}
+
+//is x > y? (x and y both nonnegative)
+function greater(x,y) {
+  var i;
+  var k=(x.length<y.length) ? x.length : y.length;
+
+  for (i=x.length;i<y.length;i++)
+    if (y[i])
+      return 0;  //y has more digits
+
+  for (i=y.length;i<x.length;i++)
+    if (x[i])
+      return 1;  //x has more digits
+
+  for (i=k-1;i>=0;i--)
+    if (x[i]>y[i])
+      return 1;
+    else if (x[i]<y[i])
+      return 0;
+  return 0;
+}
+
+
+//do x=x*y*Ri mod n for bigInts x,y,n,
+//  where Ri = 2**(-kn*bpe) mod n, and kn is the
+//  number of elements in the n array, not
+//  counting leading zeros.
+//x must be large enough to hold the answer.
+//It's OK if x and y are the same variable.
+//must have:
+//  x,y < n
+//  n is odd
+//  np = -(n^(-1)) mod radix
+function mont_(x,y,n,np) {
+  var i,j,c,ui,t;
+  var kn=n.length;
+  var ky=y.length;
+
+  if (sa.length!=kn)
+    sa=new Array(kn);
+
+  for (;kn>0 && n[kn-1]==0;kn--); //ignore leading zeros of n
+  for (;ky>0 && y[ky-1]==0;ky--); //ignore leading zeros of y
+
+  copyInt_(sa,0);
+
+  //the following loop consumes 95% of the runtime for randTruePrime_() and powMod_() for large keys
+  for (i=0; i<kn; i++) {
+    t=sa[0]+x[i]*y[0];
+    ui=((t & mask) * np) & mask;  //the inner "& mask" is needed on Macintosh MSIE, but not windows MSIE
+    c=(t+ui*n[0]) >> bpe;
+    t=x[i];
+
+    //do sa=(sa+x[i]*y+ui*n)/b   where b=2**bpe
+    for (j=1;j<ky;j++) {
+      c+=sa[j]+t*y[j]+ui*n[j];
+      sa[j-1]=c & mask;
+      c>>=bpe;
+    }
+    for (;j<kn;j++) {
+      c+=sa[j]+ui*n[j];
+      sa[j-1]=c & mask;
+      c>>=bpe;
+    }
+    sa[j-1]=c & mask;
+  }
+
+  if (!greater(n,sa))
+    sub_(sa,n);
+  copy_(x,sa);
+}
+
+mont_(x, x, n, np);
+
+var passed = expected.length == x.length;
+for (var i = 0; i < expected.length; i++) {
+  if (passed)
+    passed = expected[i] == x[i];
+}
+print(passed);
diff -r 9864735a4241 js/src/jitstats.tbl
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/jitstats.tbl	Fri Sep 26 09:30:25 2008 -0500
@@ -0,0 +1,50 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * vim: set ts=8 sw=4 et tw=0 ft=C:
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
+ * June 22, 2008.
+ *
+ * The Initial Developer of the Original Code is
+ *   Brian Crowder <crowder@fiverocks.com>
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+JITSTAT(recorderStarted)
+JITSTAT(recorderAborted)
+JITSTAT(traceCompleted)
+JITSTAT(sideExitIntoInterpreter)
+JITSTAT(typeMapMismatchAtEntry)
+JITSTAT(returnToDifferentLoopHeader)
+JITSTAT(traceTriggered)
+JITSTAT(globalShapeMismatchAtEntry)
+JITSTAT(treesTrashed)
+JITSTAT(slotPromoted)
+JITSTAT(unstableLoopVariable)
+JITSTAT(breakLoopExits)
+JITSTAT(returnLoopExits)
diff -r 9864735a4241 js/src/js.cpp
--- a/js/src/js.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/js/src/js.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -457,16 +457,23 @@ ProcessArgs(JSContext *cx, JSObject *obj
             break;
 
         case 'x':
             JS_ToggleOptions(cx, JSOPTION_XML);
             break;
 
         case 'j':
             JS_ToggleOptions(cx, JSOPTION_JIT);
+#if defined(JS_TRACER) && defined(DEBUG)
+extern struct JSClass jitstats_class;
+extern void js_InitJITStatsClass(JSContext *cx, JSObject *glob);
+            js_InitJITStatsClass(cx, JS_GetGlobalObject(cx));
+            JS_DefineObject(cx, JS_GetGlobalObject(cx), "tracemonkey",
+                            &jitstats_class, NULL, 0);
+#endif
             break;
             
         case 'o':
             if (++i == argc)
                 return usage();
 
             for (j = 0; js_options[j].name; ++j) {
                 if (strcmp(js_options[j].name, argv[i]) == 0) {
diff -r 9864735a4241 js/src/jsapi.cpp
--- a/js/src/jsapi.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/js/src/jsapi.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -75,17 +75,17 @@
 #include "jsregexp.h"
 #include "jsscan.h"
 #include "jsscope.h"
 #include "jsscript.h"
 #include "jsstr.h"
 #include "prmjtime.h"
 #include "jsstaticcheck.h"
 
-#ifdef JS_TRACER
+#if !defined JS_THREADSAFE && defined JS_TRACER
 #include "jstracer.h"
 #endif
 
 #if JS_HAS_FILE_OBJECT
 #include "jsfile.h"
 #endif
 
 #if JS_HAS_XML_SUPPORT
@@ -868,19 +868,16 @@ JS_ShutDown(void)
     js_DumpOpMeters();
 #endif
 
     js_FinishDtoa();
 #ifdef JS_THREADSAFE
     js_CleanupLocks();
 #endif
     PRMJ_NowShutdown();
-#ifdef JS_TRACER
-    js_ShutDownJIT();
-#endif    
 }
 
 JS_PUBLIC_API(void *)
 JS_GetRuntimePrivate(JSRuntime *rt)
 {
     return rt->data;
 }
 
@@ -5836,17 +5833,17 @@ JS_SetGCZeal(JSContext *cx, uint8 zeal)
 JS_SetGCZeal(JSContext *cx, uint8 zeal)
 {
     cx->runtime->gcZeal = zeal;
 }
 #endif
 
 /************************************************************************/
 
-#if !defined(STATIC_JS_API) && defined(XP_WIN)
+#if !defined(STATIC_JS_API) && defined(XP_WIN) && !defined (WINCE)
 
 #include <windows.h>
 
 /*
  * Initialization routine for the JS DLL.
  */
 BOOL WINAPI DllMain (HINSTANCE hDLL, DWORD dwReason, LPVOID lpReserved)
 {
diff -r 9864735a4241 js/src/jsarray.cpp
--- a/js/src/jsarray.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/js/src/jsarray.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -245,18 +245,18 @@ IndexToValue(JSContext *cx, jsuint index
 {
     if (index <= JSVAL_INT_MAX) {
         *vp = INT_TO_JSVAL(index);
         return JS_TRUE;
     }
     return JS_NewDoubleValue(cx, (jsdouble)index, vp);
 }
 
-static JSBool
-IndexToId(JSContext *cx, jsuint index, jsid *idp)
+JSBool JS_FASTCALL
+js_IndexToId(JSContext *cx, jsuint index, jsid *idp)
 {
     JSString *str;
 
     if (index <= JSVAL_INT_MAX) {
         *idp = INT_TO_JSID(index);
         return JS_TRUE;
     }
     str = js_NumberToString(cx, index);
@@ -626,16 +626,17 @@ array_length_setter(JSContext *cx, JSObj
     return JS_TRUE;
 }
 
 static JSBool
 array_lookupProperty(JSContext *cx, JSObject *obj, jsid id, JSObject **objp,
                      JSProperty **propp)
 {
     uint32 i;
+    union { JSProperty *p; jsval *v; } u;
 
     if (!OBJ_IS_DENSE_ARRAY(cx, obj))
         return js_LookupProperty(cx, obj, id, objp, propp);
 
     /*
      * We have only indexed properties up to DENSELEN (excepting holes), plus
      * the length property. For all else, we delegate to the prototype.
      */
@@ -656,17 +657,18 @@ array_lookupProperty(JSContext *cx, JSOb
         return OBJ_LOOKUP_PROPERTY(cx, proto, id, objp, propp);
     }
 
     /* FIXME 417501: threadsafety: could race with a lookup on another thread.
      * If we can only have a single lookup active per context, we could
      * pigeonhole this on the context instead. */
     JS_ASSERT(JSVAL_IS_VOID(obj->fslots[JSSLOT_ARRAY_LOOKUP_HOLDER]));
     obj->fslots[JSSLOT_ARRAY_LOOKUP_HOLDER] = (jsval) id;
-    *propp = (JSProperty *)&(obj->fslots[JSSLOT_ARRAY_LOOKUP_HOLDER]);
+    u.v = &(obj->fslots[JSSLOT_ARRAY_LOOKUP_HOLDER]);
+    *propp = u.p;
     *objp = obj;
     return JS_TRUE;
 }
 
 static void
 array_dropProperty(JSContext *cx, JSObject *obj, JSProperty *prop)
 {
     JS_ASSERT_IF(OBJ_IS_DENSE_ARRAY(cx, obj),
@@ -971,17 +973,17 @@ array_enumerate(JSContext *cx, JSObject 
             if (i != ii->length) {
                 /* Skip holes if any. */
                 if (ii->hasHoles) {
                     while (JS_TEST_BIT(ii->holes, i) && ++i != ii->length)
                         continue;
                 }
                 if (i != ii->length) {
                     ii->index = i + 1;
-                    return IndexToId(cx, i, idp);
+                    return js_IndexToId(cx, i, idp);
                 }
             }
         }
         /* FALL THROUGH */
 
       case JSENUMERATE_DESTROY:
         if (JSVAL_TAG(*statep) != JSVAL_BOOLEAN) {
             JS_ASSERT((*statep & INDEX_ITER_TAG) == INDEX_ITER_TAG);
@@ -2034,102 +2036,122 @@ array_sort(JSContext *cx, uintN argc, js
     }
     *vp = OBJECT_TO_JSVAL(obj);
     return JS_TRUE;
 }
 
 /*
  * Perl-inspired push, pop, shift, unshift, and splice methods.
  */
-static JSBool
-array_push_slowly(JSContext *cx, JSObject *obj, uintN argc, jsval *vp)
+JSBool
+js_array_push_slowly(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
     jsuint length, newlength;
 
     if (!js_GetLengthProperty(cx, obj, &length))
         return JS_FALSE;
     newlength = length + argc;
-    if (!InitArrayElements(cx, obj, length, newlength, vp + 2))
+    if (!InitArrayElements(cx, obj, length, newlength, argv))
         return JS_FALSE;
 
     /* Per ECMA-262, return the new array length. */
-    if (!IndexToValue(cx, newlength, vp))
+    if (!IndexToValue(cx, newlength, rval))
         return JS_FALSE;
     return js_SetLengthProperty(cx, obj, newlength);
 }
 
-static JSBool
-array_push(JSContext *cx, uintN argc, jsval *vp)
+JSBool
+js_array_push1_dense(JSContext* cx, JSObject* obj, jsval v, jsval *rval)
 {
-    JSObject *obj;
-    uint32 length;
-
-    /* Insist on one argument and obj of the expected class. */
-    obj = JS_THIS_OBJECT(cx, vp);
-    if (!obj)
-        return JS_FALSE;
-    if (argc != 1 || !OBJ_IS_DENSE_ARRAY(cx, obj))
-        return array_push_slowly(cx, obj, argc, vp);
-
-    length = obj->fslots[JSSLOT_ARRAY_LENGTH];
+    uint32 length = obj->fslots[JSSLOT_ARRAY_LENGTH];
     if (INDEX_TOO_SPARSE(obj, length)) {
         if (!js_MakeArraySlow(cx, obj))
             return JS_FALSE;
-        return array_push_slowly(cx, obj, argc, vp);
+        return js_array_push_slowly(cx, obj, 1, &v, rval);
     }
 
     if (!EnsureLength(cx, obj, length + 1))
         return JS_FALSE;
     obj->fslots[JSSLOT_ARRAY_LENGTH] = length + 1;
 
     JS_ASSERT(obj->dslots[length] == JSVAL_HOLE);
     obj->fslots[JSSLOT_ARRAY_COUNT]++;
-    obj->dslots[length] = vp[2];
-    return IndexToValue(cx, obj->fslots[JSSLOT_ARRAY_LENGTH], vp);
+    obj->dslots[length] = v;
+    return IndexToValue(cx, obj->fslots[JSSLOT_ARRAY_LENGTH], rval);
 }
 
 JSBool
-array_pop(JSContext *cx, uintN argc, jsval *vp)
+js_array_push(JSContext *cx, uintN argc, jsval *vp)
 {
     JSObject *obj;
-    jsuint index;
-    JSBool hole;
 
+    /* Insist on one argument and obj of the expected class. */
     obj = JS_THIS_OBJECT(cx, vp);
     if (!obj)
         return JS_FALSE;
-    if (OBJ_IS_DENSE_ARRAY(cx, obj)) {
-        index = obj->fslots[JSSLOT_ARRAY_LENGTH];
-        if (index == 0) {
-            *vp = JSVAL_VOID;
-            return JS_TRUE;
-        }
-        index--;
-        if (!GetArrayElement(cx, obj, index, &hole, vp))
-            return JS_FALSE;
-        if (!hole && !DeleteArrayElement(cx, obj, index))
-            return JS_FALSE;
-        obj->fslots[JSSLOT_ARRAY_LENGTH] = index;
-        return JS_TRUE;
-    }
+    if (argc != 1 || !OBJ_IS_DENSE_ARRAY(cx, obj))
+        return js_array_push_slowly(cx, obj, argc, vp + 2, vp);
+
+    return js_array_push1_dense(cx, obj, vp[2], vp);
+}
+
+JSBool
+js_array_pop_slowly(JSContext *cx, JSObject* obj, jsval *vp)
+{
+    jsuint index;
+    JSBool hole;
 
     if (!js_GetLengthProperty(cx, obj, &index))
         return JS_FALSE;
     if (index == 0) {
         *vp = JSVAL_VOID;
     } else {
         index--;
 
         /* Get the to-be-deleted property's value into vp. */
         if (!GetArrayElement(cx, obj, index, &hole, vp))
             return JS_FALSE;
         if (!hole && !DeleteArrayElement(cx, obj, index))
             return JS_FALSE;
     }
     return js_SetLengthProperty(cx, obj, index);
+}
+
+JSBool
+js_array_pop_dense(JSContext *cx, JSObject* obj, jsval *vp)
+{
+    jsuint index;
+    JSBool hole;
+
+    index = obj->fslots[JSSLOT_ARRAY_LENGTH];
+    if (index == 0) {
+        *vp = JSVAL_VOID;
+        return JS_TRUE;
+    }
+    index--;
+    if (!GetArrayElement(cx, obj, index, &hole, vp))
+        return JS_FALSE;
+    if (!hole && !DeleteArrayElement(cx, obj, index))
+        return JS_FALSE;
+    obj->fslots[JSSLOT_ARRAY_LENGTH] = index;
+    return JS_TRUE;
+    
+}
+
+JSBool
+js_array_pop(JSContext *cx, uintN argc, jsval *vp)
+{
+    JSObject *obj;
+
+    obj = JS_THIS_OBJECT(cx, vp);
+    if (!obj)
+        return JS_FALSE;
+    if (OBJ_IS_DENSE_ARRAY(cx, obj)) 
+        return js_array_pop_dense(cx, obj, vp);
+    return js_array_pop_slowly(cx, obj, vp);
 }
 
 static JSBool
 array_shift(JSContext *cx, uintN argc, jsval *vp)
 {
     JSObject *obj;
     jsuint length, i;
     JSBool hole, ok;
@@ -2877,18 +2899,18 @@ static JSFunctionSpec array_methods[] = 
 #endif
     JS_FN(js_toString_str,      array_toString,     0,0),
     JS_FN(js_toLocaleString_str,array_toLocaleString,0,0),
 
     /* Perl-ish methods. */
     JS_FN("join",               js_array_join,      1,JSFUN_GENERIC_NATIVE),
     JS_FN("reverse",            array_reverse,      0,JSFUN_GENERIC_NATIVE),
     JS_FN("sort",               array_sort,         1,JSFUN_GENERIC_NATIVE),
-    JS_FN("push",               array_push,         1,JSFUN_GENERIC_NATIVE),
-    JS_FN("pop",                array_pop,          0,JSFUN_GENERIC_NATIVE),
+    JS_FN("push",               js_array_push,      1,JSFUN_GENERIC_NATIVE),
+    JS_FN("pop",                js_array_pop,       0,JSFUN_GENERIC_NATIVE),
     JS_FN("shift",              array_shift,        0,JSFUN_GENERIC_NATIVE),
     JS_FN("unshift",            array_unshift,      1,JSFUN_GENERIC_NATIVE),
     JS_FN("splice",             array_splice,       2,JSFUN_GENERIC_NATIVE),
 
     /* Pythonic sequence methods. */
     JS_FN("concat",             array_concat,       1,JSFUN_GENERIC_NATIVE),
     JS_FN("slice",              array_slice,        2,JSFUN_GENERIC_NATIVE),
 
diff -r 9864735a4241 js/src/jsarray.h
--- a/js/src/jsarray.h	Mon Sep 22 11:50:03 2008 -0700
+++ b/js/src/jsarray.h	Fri Sep 26 09:30:25 2008 -0500
@@ -91,16 +91,19 @@ js_GetLengthProperty(JSContext *cx, JSOb
 js_GetLengthProperty(JSContext *cx, JSObject *obj, jsuint *lengthp);
 
 extern JSBool
 js_SetLengthProperty(JSContext *cx, JSObject *obj, jsuint length);
 
 extern JSBool
 js_HasLengthProperty(JSContext *cx, JSObject *obj, jsuint *lengthp);
 
+extern JSBool JS_FASTCALL
+js_IndexToId(JSContext *cx, jsuint index, jsid *idp);
+
 /*
  * Test whether an object is "array-like".  Currently this means whether obj
  * is an Array or an arguments object.  We would like an API, and probably a
  * way in the language, to bless other objects as array-like: having indexed
  * properties, and a 'length' property of uint32 value equal to one more than
  * the greatest index.
  */
 extern JSBool
@@ -125,16 +128,34 @@ js_MergeSort(void *vec, size_t nel, size
 
 #ifdef DEBUG_ARRAYS
 extern JSBool
 js_ArrayInfo(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 #endif
 
 extern JSBool
 js_array_join(JSContext *cx, uintN argc, jsval *vp);
+
+extern JSBool
+js_array_push_slowly(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+
+extern JSBool
+js_array_push1_dense(JSContext *cx, JSObject *obj, jsval v, jsval *rval);
+
+extern JSBool
+js_array_push(JSContext *cx, uintN argc, jsval *vp);
+
+extern JSBool
+js_array_pop_slowly(JSContext *cx, JSObject* obj, jsval *vp);
+
+extern JSBool
+js_array_pop_dense(JSContext *cx, JSObject* obj, jsval *vp);
+
+extern JSBool
+js_array_pop(JSContext *cx, uintN argc, jsval *vp);
 
 enum ArrayToStringOp {
     TO_STRING,
     TO_LOCALE_STRING,
     TO_SOURCE
 };
 
 extern JSBool
diff -r 9864735a4241 js/src/jsbuiltins.cpp
--- a/js/src/jsbuiltins.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/js/src/jsbuiltins.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -79,16 +79,27 @@ js_dmod(jsdouble a, jsdouble b)
 #ifdef XP_WIN
     /* Workaround MS fmod bug where 42 % (1/0) => NaN, not 42. */
     if (JSDOUBLE_IS_FINITE(a) && JSDOUBLE_IS_INFINITE(b))
         r = a;
     else
 #endif
         r = fmod(a, b);
     return r;
+}
+
+/*
+ * Note: Caller is responsible for ensuring that b is not 0, or really bad 
+ *       things are going to happen.
+ */
+
+jsint FASTCALL
+js_imod(jsint a, jsint b)
+{
+    return a % b;
 }
 
 /* The following boxing/unboxing primitives we can't emit inline because
    they either interact with the GC and depend on Spidermonkey's 32-bit
    integer representation. */
 
 jsval FASTCALL
 js_BoxDouble(JSContext* cx, jsdouble d)
@@ -230,16 +241,39 @@ js_Array_p_join(JSContext* cx, JSObject*
 {
     jsval v;
     if (!js_array_join_sub(cx, obj, TO_STRING, str, &v))
         return NULL;
     JS_ASSERT(JSVAL_IS_STRING(v));
     return JSVAL_TO_STRING(v);
 }
 
+jsval FASTCALL
+js_Array_p_push1(JSContext* cx, JSObject* obj, jsval v)
+{
+    if (!(OBJ_IS_DENSE_ARRAY(cx, obj) 
+          ? js_array_push1_dense(cx, obj, v, &v)
+          : js_array_push_slowly(cx, obj, 1, &v, &v))) {
+        return JSVAL_ERROR_COOKIE;
+    }
+    return v;
+}
+
+jsval FASTCALL
+js_Array_p_pop(JSContext* cx, JSObject* obj)
+{
+    jsval v;
+    if (!(OBJ_IS_DENSE_ARRAY(cx, obj) 
+          ? js_array_pop_dense(cx, obj, &v)
+          : js_array_pop_slowly(cx, obj, &v))) {
+        return JSVAL_ERROR_COOKIE;
+    }
+    return v;
+}
+
 JSString* FASTCALL
 js_String_p_substring(JSContext* cx, JSString* str, jsint begin, jsint end)
 {
     JS_ASSERT(end >= begin);
     JS_ASSERT(JS_ON_TRACE(cx));
     return js_NewDependentString(cx, str, (size_t)begin, (size_t)(end - begin));
 }
 
@@ -293,20 +327,52 @@ js_String_p_concat_1int(JSContext* cx, J
 {
     // FIXME: should be able to use stack buffer and avoid istr...
     JSString* istr = js_NumberToString(cx, i);
     if (!istr)
         return NULL;
     return js_ConcatStrings(cx, str, istr);
 }
 
+JSString* FASTCALL
+js_String_p_concat_2str(JSContext* cx, JSString* str, JSString* a, JSString* b)
+{
+    str = js_ConcatStrings(cx, str, a);
+    if (str)
+        return js_ConcatStrings(cx, str, b);
+    return NULL;
+}
+
+JSString* FASTCALL
+js_String_p_concat_3str(JSContext* cx, JSString* str, JSString* a, JSString* b, JSString* c)
+{
+    str = js_ConcatStrings(cx, str, a);
+    if (str) {
+        str = js_ConcatStrings(cx, str, b);
+        if (str)
+            return js_ConcatStrings(cx, str, c);
+    }
+    return NULL;
+}
+
 JSObject* FASTCALL
 js_String_p_match(JSContext* cx, JSString* str, jsbytecode *pc, JSObject* regexp)
 {
     jsval vp[3] = { JSVAL_NULL, STRING_TO_JSVAL(str), OBJECT_TO_JSVAL(regexp) };
+    if (!js_StringMatchHelper(cx, 1, vp, pc))
+        return (JSObject*) JSVAL_TO_BOOLEAN(JSVAL_VOID);
+    JS_ASSERT(JSVAL_IS_NULL(vp[0]) ||
+              (!JSVAL_IS_PRIMITIVE(vp[0]) && OBJ_IS_ARRAY(cx, JSVAL_TO_OBJECT(vp[0]))));
+    return JSVAL_TO_OBJECT(vp[0]);
+}
+
+JSObject* FASTCALL
+js_String_p_match_obj(JSContext* cx, JSObject* str, jsbytecode *pc, JSObject* regexp)
+{
+    jsval vp[3] = { JSVAL_NULL, OBJECT_TO_JSVAL(str), OBJECT_TO_JSVAL(regexp) };
     if (!js_StringMatchHelper(cx, 1, vp, pc))
         return (JSObject*) JSVAL_TO_BOOLEAN(JSVAL_VOID);
     JS_ASSERT(JSVAL_IS_NULL(vp[0]) ||
               (!JSVAL_IS_PRIMITIVE(vp[0]) && OBJ_IS_ARRAY(cx, JSVAL_TO_OBJECT(vp[0]))));
     return JSVAL_TO_OBJECT(vp[0]);
 }
 
 JSString* FASTCALL
@@ -422,33 +488,77 @@ js_ParseIntDouble(jsdouble d)
 js_ParseIntDouble(jsdouble d)
 {
     if (!JSDOUBLE_IS_FINITE(d))
         return js_NaN;
     return floor(d);
 }
 
 jsval FASTCALL
-js_Any_getelem(JSContext* cx, JSObject* obj, JSString* idstr)
+js_Any_getprop(JSContext* cx, JSObject* obj, JSString* idstr)
 {
     jsval v;
     jsid id;
 
     if (!js_ValueToStringId(cx, STRING_TO_JSVAL(idstr), &id))
         return JSVAL_ERROR_COOKIE;
     if (!OBJ_GET_PROPERTY(cx, obj, id, &v))
         return JSVAL_ERROR_COOKIE;
     return v;
 }
 
 JSBool FASTCALL
-js_Any_setelem(JSContext* cx, JSObject* obj, JSString* idstr, jsval v)
+js_Any_setprop(JSContext* cx, JSObject* obj, JSString* idstr, jsval v)
 {
     jsid id;
     if (!js_ValueToStringId(cx, STRING_TO_JSVAL(idstr), &id))
+        return JS_FALSE;
+    return OBJ_SET_PROPERTY(cx, obj, id, &v);
+}
+
+jsval FASTCALL
+js_Any_getelem(JSContext* cx, JSObject* obj, jsdouble index)
+{
+    jsval v;
+    jsid id;
+
+    if (!js_ValueToStringId(cx, DOUBLE_TO_JSVAL(&index), &id))
+        return JSVAL_ERROR_COOKIE;
+    if (!OBJ_GET_PROPERTY(cx, obj, id, &v))
+        return JSVAL_ERROR_COOKIE;
+    return v;
+}
+
+JSBool FASTCALL
+js_Any_setelem(JSContext* cx, JSObject* obj, jsdouble index, jsval v)
+{
+    jsid id;
+    if (!js_ValueToStringId(cx, DOUBLE_TO_JSVAL(&index), &id))
+        return JS_FALSE;
+    return OBJ_SET_PROPERTY(cx, obj, id, &v);
+}
+
+jsval FASTCALL
+js_Any_getelem_int(JSContext* cx, JSObject* obj, jsuint index)
+{
+    jsval v;
+    jsid id;
+
+    if (!js_IndexToId(cx, index, &id))
+        return JSVAL_ERROR_COOKIE;
+    if (!OBJ_GET_PROPERTY(cx, obj, id, &v))
+        return JSVAL_ERROR_COOKIE;
+    return v;
+}
+
+JSBool FASTCALL
+js_Any_setelem_int(JSContext* cx, JSObject* obj, jsuint index, jsval v)
+{
+    jsid id;
+    if (!js_IndexToId(cx, index, &id))
         return JS_FALSE;
     return OBJ_SET_PROPERTY(cx, obj, id, &v);
 }
 
 JSObject* FASTCALL
 js_FastValueToIterator(JSContext* cx, jsuint flags, jsval v)
 {
     if (!js_ValueToIterator(cx, flags, &v))
@@ -475,18 +585,29 @@ js_CallTree(InterpState* state, Fragment
     JS_ASSERT(u.code);
 
 #if defined(JS_NO_FASTCALL) && defined(NANOJIT_IA32)
     SIMULATE_FASTCALL(lr, state, NULL, u.func);
 #else
     lr = u.func(state, NULL);
 #endif
 
-    if (lr->exit->exitType == NESTED_EXIT)
-        lr = state->nestedExit;
+    if (lr->exit->exitType == NESTED_EXIT) {
+        /* This only occurs once a tree call guard mismatches and we unwind the tree call stack.
+           We store the first (innermost) tree call guard in state and we will try to grow
+           the outer tree the failing call was in starting at that guard. */
+        if (!state->lastTreeCallGuard)
+            state->lastTreeCallGuard = lr;
+    } else {
+        /* If the tree exits on a regular (non-nested) guard, keep updating lastTreeExitGuard
+           with that guard. If we mismatch on a tree call guard, this will contain the last
+           non-nested guard we encountered, which is the innermost loop or branch guard. */
+        state->lastTreeExitGuard = lr;
+    }
+
     return lr;
 }
 
 JS_STATIC_ASSERT(JSSLOT_PRIVATE == JSSLOT_ARRAY_LENGTH);
 JS_STATIC_ASSERT(JSSLOT_ARRAY_LENGTH + 1 == JSSLOT_ARRAY_COUNT);
 
 JSObject* FASTCALL
 js_FastNewArray(JSContext* cx, JSObject* proto)
@@ -520,33 +641,40 @@ JSObject* FASTCALL
 JSObject* FASTCALL
 js_FastNewObject(JSContext* cx, JSObject* ctor)
 {
     JS_ASSERT(HAS_FUNCTION_CLASS(ctor));
     JSFunction* fun = GET_FUNCTION_PRIVATE(cx, ctor);
     JSClass* clasp = FUN_INTERPRETED(fun) ? &js_ObjectClass : fun->u.n.clasp;
     JS_ASSERT(clasp != &js_ArrayClass);
 
-    JS_ASSERT(JS_ON_TRACE(cx));
-    JSObject* obj = (JSObject*) js_NewGCThing(cx, GCX_OBJECT, sizeof(JSObject));
-    if (!obj)
-        return NULL;
-
     JS_LOCK_OBJ(cx, ctor);
     JSScope *scope = OBJ_SCOPE(ctor);
     JS_ASSERT(scope->object == ctor);
     JSAtom* atom = cx->runtime->atomState.classPrototypeAtom;
 
     JSScopeProperty *sprop = SCOPE_GET_PROPERTY(scope, ATOM_TO_JSID(atom));
     JS_ASSERT(SPROP_HAS_VALID_SLOT(sprop, scope));
     jsval v = LOCKED_OBJ_GET_SLOT(ctor, sprop->slot);
     JS_UNLOCK_SCOPE(cx, scope);
 
-    JS_ASSERT(!JSVAL_IS_PRIMITIVE(v));
-    JSObject* proto = JSVAL_TO_OBJECT(v);
+    JSObject* proto;
+    if (JSVAL_IS_PRIMITIVE(v)) {
+        if (!js_GetClassPrototype(cx, JSVAL_TO_OBJECT(ctor->fslots[JSSLOT_PARENT]), 
+                                  INT_TO_JSID(JSProto_Object), &proto)) {
+            return NULL;
+        }
+    } else {
+        proto = JSVAL_TO_OBJECT(v);
+    }
+
+    JS_ASSERT(JS_ON_TRACE(cx));
+    JSObject* obj = (JSObject*) js_NewGCThing(cx, GCX_OBJECT, sizeof(JSObject));
+    if (!obj)
+        return NULL;
 
     obj->classword = jsuword(clasp);
     obj->fslots[JSSLOT_PROTO] = OBJECT_TO_JSVAL(proto);
     obj->fslots[JSSLOT_PARENT] = ctor->fslots[JSSLOT_PARENT];
     for (unsigned i = JSSLOT_PRIVATE; i != JS_INITIAL_NSLOTS; ++i)
         obj->fslots[i] = JSVAL_VOID;
 
     obj->map = js_HoldObjectMap(cx, proto->map);
@@ -704,17 +832,17 @@ js_Array_1int(JSContext* cx, JSObject* p
         obj->fslots[JSSLOT_ARRAY_LENGTH] = i;
     return obj;
 }
 
 #define ARRAY_CTOR_GUTS(exact_len, newslots_code)                             \
     JS_ASSERT(JS_ON_TRACE(cx));                                               \
     JSObject* obj = js_FastNewArray(cx, proto);                               \
     if (obj) {                                                                \
-        uint32 len = ARRAY_GROWBY;                                            \
+        const uint32 len = ARRAY_GROWBY;                                      \
         jsval* newslots = (jsval*) JS_malloc(cx, sizeof (jsval) * (len + 1)); \
         if (newslots) {                                                       \
             obj->dslots = newslots + 1;                                       \
             ARRAY_SET_DENSE_LENGTH(obj, len);                                 \
             {newslots_code}                                                   \
             while (++newslots < obj->dslots + len)                            \
                 *newslots = JSVAL_HOLE;                                       \
             obj->fslots[JSSLOT_ARRAY_LENGTH] = (exact_len);                   \
diff -r 9864735a4241 js/src/jsemit.cpp
--- a/js/src/jsemit.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/js/src/jsemit.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -4617,17 +4617,17 @@ js_EmitTree(JSContext *cx, JSCodeGenerat
                 return JS_FALSE;
             while (stmt->type != STMT_LABEL || stmt->u.label != atom)
                 stmt = stmt->down;
             noteType = SRC_BREAK2LABEL;
         } else {
             ale = NULL;
             while (!STMT_IS_LOOP(stmt) && stmt->type != STMT_SWITCH)
                 stmt = stmt->down;
-            noteType = SRC_BREAK;
+            noteType = (stmt->type == STMT_SWITCH) ? SRC_NULL : SRC_BREAK;
         }
 
         if (EmitGoto(cx, cg, stmt, &stmt->breaks, ale, noteType) < 0)
             return JS_FALSE;
         break;
 
       case TOK_CONTINUE:
         stmt = cg->treeContext.topStmt;
diff -r 9864735a4241 js/src/jsfun.cpp
--- a/js/src/jsfun.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/js/src/jsfun.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -1768,17 +1768,17 @@ fun_applyConstructor(JSContext *cx, uint
     *sp++ = JSVAL_NULL; /* this is filled automagically */
     for (i = 0; i < length; i++) {
         ok = JS_GetElement(cx, aobj, (jsint)i, sp);
         if (!ok)
             goto out;
         sp++;
     }
 
-    ok = js_InvokeConstructor(cx, length, invokevp);
+    ok = js_InvokeConstructor(cx, length, JS_TRUE, invokevp);
     *vp = *invokevp;
 out:
     js_FreeStack(cx, mark);
     return ok;
 }
 #endif
 
 static JSFunctionSpec function_methods[] = {
diff -r 9864735a4241 js/src/jsgc.cpp
--- a/js/src/jsgc.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/js/src/jsgc.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -3235,16 +3235,21 @@ js_GC(JSContext *cx, JSGCInvocationKind 
         rt->requestCount += requestDebit;
 #endif
         gckind = GC_LOCK_HELD;
         goto restart_at_beginning;
     }
 
     JS_UNLOCK_GC(rt);
 
+#ifdef JS_TRACER
+    if (JS_ON_TRACE(cx))
+        goto out;
+#endif
+
     /* Reset malloc counter. */
     rt->gcMallocBytes = 0;
 
 #ifdef JS_DUMP_SCOPE_METERS
   { extern void js_DumpScopeMeters(JSRuntime *rt);
     js_DumpScopeMeters(rt);
   }
 #endif
@@ -3540,16 +3545,19 @@ js_GC(JSContext *cx, JSGCInvocationKind 
         lsfp = fopen("/tmp/loopstats", "w");
     if (lsfp) {
         JS_DumpBasicStats(&rt->loopStats, "loops", lsfp);
         fflush(lsfp);
     }
   }
 #endif /* JS_DUMP_LOOP_STATS */
 
+#ifdef JS_TRACER
+out:
+#endif
     JS_LOCK_GC(rt);
 
     /*
      * We want to restart GC if js_GC was called recursively or if any of the
      * finalizers called js_RemoveRoot or js_UnlockGCThingRT.
      */
     if (rt->gcLevel > 1 || rt->gcPoke) {
         rt->gcLevel = 1;
diff -r 9864735a4241 js/src/jsinterp.cpp
--- a/js/src/jsinterp.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/js/src/jsinterp.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -1000,17 +1000,17 @@ NoSuchMethod(JSContext *cx, uintN argc, 
     invokevp[1] = vp[1];
     invokevp[2] = obj->fslots[JSSLOT_SAVED_ID];
     argsobj = js_NewArrayObject(cx, argc, vp + 2);
     if (!argsobj) {
         ok = JS_FALSE;
     } else {
         invokevp[3] = OBJECT_TO_JSVAL(argsobj);
         ok = (flags & JSINVOKE_CONSTRUCT)
-             ? js_InvokeConstructor(cx, 2, invokevp)
+             ? js_InvokeConstructor(cx, 2, JS_TRUE, invokevp)
              : js_Invoke(cx, 2, invokevp, flags);
         vp[0] = invokevp[0];
     }
     js_FreeStack(cx, mark);
     return ok;
 }
 
 #endif /* JS_HAS_NO_SUCH_METHOD */
@@ -1488,17 +1488,17 @@ js_Execute(JSContext *cx, JSObject *chai
         frame.fun = NULL;
         frame.thisp = chain;
         frame.argc = 0;
         frame.argv = NULL;
         frame.annotation = NULL;
         frame.sharpArray = NULL;
     }
     if (script->nslots != 0) {
-        frame.slots = js_AllocRawStack(cx, script->nslots, NULL);
+        frame.slots = js_AllocRawStack(cx, script->nslots, &mark);
         if (!frame.slots) {
             ok = JS_FALSE;
             goto out;
         }
         memset(frame.slots, 0, script->nfixed * sizeof(jsval));
     } else {
         frame.slots = NULL;
     }
@@ -1715,17 +1715,17 @@ js_StrictlyEqual(JSContext *cx, jsval lv
         ld = JSVAL_TO_INT(lval);
         rd = *JSVAL_TO_DOUBLE(rval);
         return JSDOUBLE_COMPARE(ld, ==, rd, JS_FALSE);
     }
     return lval == rval;
 }
 
 JSBool
-js_InvokeConstructor(JSContext *cx, uintN argc, jsval *vp)
+js_InvokeConstructor(JSContext *cx, uintN argc, JSBool clampReturn, jsval *vp)
 {
     JSFunction *fun, *fun2;
     JSObject *obj, *obj2, *proto, *parent;
     jsval lval, rval;
     JSClass *clasp;
 
     fun = NULL;
     obj2 = NULL;
@@ -1776,17 +1776,17 @@ js_InvokeConstructor(JSContext *cx, uint
     vp[1] = OBJECT_TO_JSVAL(obj);
     if (!js_Invoke(cx, argc, vp, JSINVOKE_CONSTRUCT)) {
         cx->weakRoots.newborn[GCX_OBJECT] = NULL;
         return JS_FALSE;
     }
 
     /* Check the return value and if it's primitive, force it to be obj. */
     rval = *vp;
-    if (JSVAL_IS_PRIMITIVE(rval)) {
+    if (clampReturn && JSVAL_IS_PRIMITIVE(rval)) {
         if (!fun) {
             /* native [[Construct]] returning primitive is error */
             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
                                  JSMSG_BAD_NEW_RESULT,
                                  js_ValueToPrintableString(cx, rval));
             return JS_FALSE;
         }
         *vp = OBJECT_TO_JSVAL(obj);
@@ -2566,16 +2566,17 @@ js_Interpret(JSContext *cx)
 #endif /* !JS_THREADED_INTERP */
 
 #ifdef JS_TRACER
     /* We had better not be entering the interpreter from JIT-compiled code. */
     TraceRecorder *tr = NULL;
     if (JS_ON_TRACE(cx)) {
         tr = TRACE_RECORDER(cx);
         SET_TRACE_RECORDER(cx, NULL);
+        JS_TRACE_MONITOR(cx).onTrace = JS_FALSE;
     }
 #endif
 
     /* Check for too deep of a native thread stack. */
     JS_CHECK_RECURSION(cx, return JS_FALSE);
 
     rt = cx->runtime;
 
@@ -2925,16 +2926,26 @@ js_Interpret(JSContext *cx)
           BEGIN_CASE(JSOP_RETRVAL)    /* fp->rval already set */
           BEGIN_CASE(JSOP_STOP)
             /*
              * When the inlined frame exits with an exception or an error, ok
              * will be false after the inline_return label.
              */
             ASSERT_NOT_THROWING(cx);
             JS_ASSERT(regs.sp == StackBase(fp));
+            if ((fp->flags & JSFRAME_CONSTRUCTING) &&
+                JSVAL_IS_PRIMITIVE(fp->rval)) {
+                if (!fp->fun) {
+                    JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
+                                         JSMSG_BAD_NEW_RESULT,
+                                         js_ValueToPrintableString(cx, rval));
+                    goto error;
+                }
+                fp->rval = OBJECT_TO_JSVAL(fp->thisp);
+            }
             ok = JS_TRUE;
             if (inlineCallCount)
           inline_return:
             {
                 JSInlineFrame *ifp = (JSInlineFrame *) fp;
                 void *hookData = ifp->hookData;
 
                 JS_ASSERT(JS_PROPERTY_CACHE(cx).disabled == fp->pcDisabledSave);
@@ -4445,30 +4456,29 @@ js_Interpret(JSContext *cx)
                         JS_LOCK_OBJ(cx, obj);
                         scope = OBJ_SCOPE(obj);
                         if (scope->shape == kshape) {
                             JS_ASSERT(PCVAL_IS_SPROP(entry->vword));
                             sprop = PCVAL_TO_SPROP(entry->vword);
                             JS_ASSERT(!(sprop->attrs & JSPROP_READONLY));
                             JS_ASSERT(!SCOPE_IS_SEALED(OBJ_SCOPE(obj)));
 
-                            TRACE_2(SetPropHit, entry, sprop);
-
                             if (scope->object == obj) {
                                 /*
                                  * Fastest path: the cached sprop is already
                                  * in scope. Just NATIVE_SET and break to get
                                  * out of the do-while(0).
                                  */
                                 if (sprop == scope->lastProp ||
                                     SCOPE_HAS_PROPERTY(scope, sprop)) {
                                     PCMETER(cache->pchits++);
                                     PCMETER(cache->setpchits++);
                                     NATIVE_SET(cx, obj, sprop, &rval);
                                     JS_UNLOCK_SCOPE(cx, scope);
+                                    TRACE_2(SetPropHit, entry, sprop);
                                     break;
                                 }
                             } else {
                                 scope = js_GetMutableScope(cx, obj);
                                 if (!scope) {
                                     JS_UNLOCK_OBJ(cx, obj);
                                     goto error;
                                 }
@@ -4550,16 +4560,17 @@ js_Interpret(JSContext *cx)
                                     scope->lastProp = sprop;
                                 }
 
                                 GC_WRITE_BARRIER(cx, scope,
                                                  LOCKED_OBJ_GET_SLOT(obj, slot),
                                                  rval);
                                 LOCKED_OBJ_SET_SLOT(obj, slot, rval);
                                 JS_UNLOCK_SCOPE(cx, scope);
+                                TRACE_2(SetPropHit, entry, sprop);
                                 break;
                             }
 
                             PCMETER(cache->setpcmisses++);
                             atom = NULL;
                         }
 
                         JS_UNLOCK_OBJ(cx, obj);
@@ -4567,31 +4578,29 @@ js_Interpret(JSContext *cx)
 
                     atom = js_FullTestPropertyCache(cx, regs.pc, &obj, &obj2,
                                                     &entry);
                     if (atom) {
                         PCMETER(cache->misses++);
                         PCMETER(cache->setmisses++);
                     } else {
                         ASSERT_VALID_PROPERTY_CACHE_HIT(0, obj, obj2, entry);
+                        sprop = NULL;
                         if (obj == obj2) {
-                            if (PCVAL_IS_SLOT(entry->vword)) {
-                                slot = PCVAL_TO_SLOT(entry->vword);
-                                JS_ASSERT(slot < obj->map->freeslot);
-                                LOCKED_OBJ_WRITE_BARRIER(cx, obj, slot, rval);
-                            } else if (PCVAL_IS_SPROP(entry->vword)) {
-                                sprop = PCVAL_TO_SPROP(entry->vword);
-                                JS_ASSERT(!(sprop->attrs & JSPROP_READONLY));
-                                JS_ASSERT(!SCOPE_IS_SEALED(OBJ_SCOPE(obj2)));
-                                NATIVE_SET(cx, obj, sprop, &rval);
-                            }
+                            JS_ASSERT(PCVAL_IS_SPROP(entry->vword));
+                            sprop = PCVAL_TO_SPROP(entry->vword);
+                            JS_ASSERT(!(sprop->attrs & JSPROP_READONLY));
+                            JS_ASSERT(!SCOPE_IS_SEALED(OBJ_SCOPE(obj2)));
+                            NATIVE_SET(cx, obj, sprop, &rval);
                         }
                         JS_UNLOCK_OBJ(cx, obj2);
-                        if (obj == obj2 && !PCVAL_IS_OBJECT(entry->vword))
+                        if (sprop) {
+                            TRACE_2(SetPropHit, entry, sprop);
                             break;
+                        }
                     }
                 }
 
                 if (!atom)
                     LOAD_ATOM(0);
                 id = ATOM_TO_JSID(atom);
                 if (entry) {
                     if (!js_SetPropertyHelper(cx, obj, id, &rval, &entry))
@@ -4599,16 +4608,22 @@ js_Interpret(JSContext *cx)
 #ifdef JS_TRACER
                     if (entry)
                         TRACE_1(SetPropMiss, entry);
 #endif
                 } else {
                     if (!OBJ_SET_PROPERTY(cx, obj, id, &rval))
                         goto error;
                 }
+#ifdef JS_TRACER
+                if (!entry && TRACE_RECORDER(cx)) {
+                    js_AbortRecording(cx, NULL, "SetPropUncached");
+                    ENABLE_TRACER(0);
+                }
+#endif
             } while (0);
           END_SET_CASE_STORE_RVAL(JSOP_SETPROP, 2);
 
           BEGIN_CASE(JSOP_GETELEM)
             /* Open-coded ELEMENT_OP optimized for strings and dense arrays. */
             lval = FETCH_OPND(-2);
             rval = FETCH_OPND(-1);
             if (JSVAL_IS_STRING(lval) && JSVAL_IS_INT(rval)) {
@@ -4740,17 +4755,17 @@ js_Interpret(JSContext *cx)
                     if (!obj2)
                         goto error;
                     vp[1] = OBJECT_TO_JSVAL(obj2);
                     flags = JSFRAME_CONSTRUCTING;
                     goto inline_call;
                 }
             }
 
-            if (!js_InvokeConstructor(cx, argc, vp))
+            if (!js_InvokeConstructor(cx, argc, JS_FALSE, vp))
                 goto error;
             regs.sp = vp + 1;
             LOAD_INTERRUPT_HANDLER(cx);
           END_CASE(JSOP_NEW)
 
           BEGIN_CASE(JSOP_CALL)
           BEGIN_CASE(JSOP_EVAL)
             argc = GET_ARGC(regs.pc);
@@ -4792,19 +4807,20 @@ js_Interpret(JSContext *cx)
                     if (fun->nargs <= argc) {
                         missing = 0;
                     } else {
                         newsp = vp + 2 + fun->nargs;
                         JS_ASSERT(newsp > regs.sp);
                         if ((jsuword) newsp <= a->limit) {
                             if ((jsuword) newsp > a->avail)
                                 a->avail = (jsuword) newsp;
+                            jsval *argsp = newsp;
                             do {
-                                *--newsp = JSVAL_VOID;
-                            } while (newsp != regs.sp);
+                                *--argsp = JSVAL_VOID;
+                            } while (argsp != regs.sp);
                             missing = 0;
                         } else {
                             missing = fun->nargs - argc;
                             nbytes += (2 + fun->nargs) * sizeof(jsval);
                         }
                     }
 
                     /* Allocate the inline frame with its slots and operands. */
@@ -4816,18 +4832,18 @@ js_Interpret(JSContext *cx)
                         JS_ARENA_ALLOCATE_CAST(newsp, jsval *, &cx->stackPool,
                                                nbytes);
                         if (!newsp) {
                             js_ReportOutOfScriptQuota(cx);
                             goto bad_inline_call;
                         }
 
                         /*
-                         * Move args if missing overflow arena a, then push
-                         * any missing args.
+                         * Move args if the missing ones overflow arena a, then
+                         * push undefined for the missing args.
                          */
                         if (missing) {
                             memcpy(newsp, vp, (2 + argc) * sizeof(jsval));
                             vp = newsp;
                             newsp = vp + 2 + argc;
                             do {
                                 *newsp++ = JSVAL_VOID;
                             } while (--missing != 0);
@@ -7018,16 +7034,17 @@ js_Interpret(JSContext *cx)
         cx->display[script->staticDepth] = fp->displaySave;
     JS_ASSERT(JS_PROPERTY_CACHE(cx).disabled == fp->pcDisabledSave);
     if (cx->version == currentVersion && currentVersion != originalVersion)
         js_SetVersion(cx, originalVersion);
     --cx->interpLevel;
 
 #ifdef JS_TRACER
     if (tr) {
+        JS_TRACE_MONITOR(cx).onTrace = JS_TRUE;
         SET_TRACE_RECORDER(cx, tr);
         tr->deepAbort();
     }
 #endif
     return ok;
 
   atom_not_defined:
     {
diff -r 9864735a4241 js/src/jsinterp.h
--- a/js/src/jsinterp.h	Mon Sep 22 11:50:03 2008 -0700
+++ b/js/src/jsinterp.h	Fri Sep 26 09:30:25 2008 -0500
@@ -450,17 +450,17 @@ js_InternalGetOrSet(JSContext *cx, JSObj
 js_InternalGetOrSet(JSContext *cx, JSObject *obj, jsid id, jsval fval,
                     JSAccessMode mode, uintN argc, jsval *argv, jsval *rval);
 
 extern JSBool
 js_Execute(JSContext *cx, JSObject *chain, JSScript *script,
            JSStackFrame *down, uintN flags, jsval *result);
 
 extern JSBool
-js_InvokeConstructor(JSContext *cx, uintN argc, jsval *vp);
+js_InvokeConstructor(JSContext *cx, uintN argc, JSBool clampReturn, jsval *vp);
 
 extern JSBool
 js_Interpret(JSContext *cx);
 
 #define JSPROP_INITIALIZER 0x100   /* NB: Not a valid property attribute. */
 
 extern JSBool
 js_CheckRedeclaration(JSContext *cx, JSObject *obj, jsid id, uintN attrs,
diff -r 9864735a4241 js/src/jstracer.cpp
--- a/js/src/jstracer.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/js/src/jstracer.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -65,17 +65,18 @@
 #include "jsopcode.h"
 #include "jsregexp.h"
 #include "jsscope.h"
 #include "jsscript.h"
 #include "jstracer.h"
 
 #include "jsautooplen.h"        // generated headers last
 
-/* Number of iterations of a loop before we start tracing. */
+/* Number of iterations of a loop where we start tracing.  That is, we don't
+   start tracing until the beginning of the HOTLOOP-th iteration. */
 #define HOTLOOP 2
 
 /* Number of times we wait to exit on a side exit before we try to extend the tree. */
 #define HOTEXIT 1
 
 /* Max call depths for inlining. */
 #define MAX_CALLDEPTH 10
 
@@ -93,24 +94,91 @@
 
 #ifdef DEBUG
 #define ABORT_TRACE(msg)   do { debug_only_v(fprintf(stdout, "abort: %d: %s\n", __LINE__, msg);)  return false; } while (0)
 #else
 #define ABORT_TRACE(msg)   return false
 #endif
 
 #ifdef DEBUG
-static struct {
-    uint64
-        recorderStarted, recorderAborted, traceCompleted, sideExitIntoInterpreter,
-        typeMapMismatchAtEntry, returnToDifferentLoopHeader, traceTriggered,
-        globalShapeMismatchAtEntry, treesTrashed, slotPromoted,
-        unstableLoopVariable, breakLoopExits, returnLoopExits;
-} stat = { 0LL, };
-#define AUDIT(x) (stat.x++)
+struct __jitstats {
+#define JITSTAT(x) uint64 x;
+#include "jitstats.tbl"
+#undef JITSTAT
+} jitstats = { 0LL, };
+
+JS_STATIC_ASSERT(sizeof(jitstats) % sizeof(uint64) == 0);
+
+enum jitstat_ids {
+#define JITSTAT(x) STAT ## x ## ID,
+#include "jitstats.tbl"
+#undef JITSTAT
+    STAT_IDS_TOTAL
+};
+
+static JSPropertySpec jitstats_props[] = {
+#define JITSTAT(x) { #x, STAT ## x ## ID, JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT },
+#include "jitstats.tbl"
+#undef JITSTAT
+    { 0 }
+};
+
+static JSBool
+jitstats_getProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
+{
+    int index = -1;
+
+    if (JSVAL_IS_STRING(id)) {
+        JSString* str = JSVAL_TO_STRING(id);
+        if (strcmp(JS_GetStringBytes(str), "HOTLOOP") == 0) {
+            *vp = INT_TO_JSVAL(HOTLOOP);
+            return JS_TRUE;
+        }
+    }
+
+    if (JSVAL_IS_INT(id))
+        index = JSVAL_TO_INT(id);
+
+    uint64 result = 0;
+    switch (index) {
+#define JITSTAT(x) case STAT ## x ## ID: result = jitstats.x; break;
+#include "jitstats.tbl"
+#undef JITSTAT
+    default:
+        *vp = JSVAL_VOID;
+        return JS_TRUE;
+    }
+
+    if (result < JSVAL_INT_MAX) {
+        *vp = INT_TO_JSVAL(result);
+        return JS_TRUE;
+    }
+    char retstr[64];
+    JS_snprintf(retstr, sizeof retstr, "%llu", result);
+    *vp = STRING_TO_JSVAL(JS_NewStringCopyZ(cx, retstr));
+    return JS_TRUE;
+}
+
+JSClass jitstats_class = {
+    "jitstats",
+    JSCLASS_HAS_PRIVATE,
+    JS_PropertyStub,       JS_PropertyStub,
+    jitstats_getProperty,  JS_PropertyStub,
+    JS_EnumerateStub,      JS_ResolveStub,
+    JS_ConvertStub,        JS_FinalizeStub,
+    JSCLASS_NO_OPTIONAL_MEMBERS
+};
+
+void
+js_InitJITStatsClass(JSContext *cx, JSObject *glob)
+{
+    JS_InitClass(cx, glob, NULL, &jitstats_class, NULL, 0, jitstats_props, NULL, NULL, NULL);
+}
+
+#define AUDIT(x) (jitstats.x++)
 #else
 #define AUDIT(x) ((void)0)
 #endif
 
 #define INS_CONST(c)    addName(lir->insImm(c), #c)
 #define INS_CONSTPTR(p) addName(lir->insImmPtr((void*) (p)), #p)
 
 using namespace avmplus;
@@ -131,17 +199,17 @@ static bool verbose_debug = getenv("TRAC
 static bool verbose_debug = getenv("TRACEMONKEY") && strstr(getenv("TRACEMONKEY"), "verbose");
 #define debug_only_v(x) if (verbose_debug) { x; }
 #else
 #define debug_only_v(x)
 #endif
 
 /* The entire VM shares one oracle. Collisions and concurrent updates are tolerated and worst
    case cause performance regressions. */
-static Oracle* oracle;
+static Oracle oracle;
 
 Tracker::Tracker()
 {
     pagelist = 0;
 }
 
 Tracker::~Tracker()
 {
@@ -236,16 +304,23 @@ static inline bool isInt32(jsval v)
 {
     if (!isNumber(v))
         return false;
     jsdouble d = asNumber(v);
     jsint i;
     return JSDOUBLE_IS_INT(d, i);
 }
 
+/* Return JSVAL_DOUBLE for all numbers (int and double) and the tag otherwise. */
+static inline uint8 getPromotedType(jsval v) 
+{
+    return JSVAL_IS_INT(v) ? JSVAL_DOUBLE : JSVAL_TAG(v);
+}
+
+/* Return JSVAL_INT for all whole numbers that fit into signed 32-bit and the tag otherwise. */
 static inline uint8 getCoercedType(jsval v)
 {
     return isInt32(v) ? JSVAL_INT : (uint8) JSVAL_TAG(v);
 }
 
 /* Tell the oracle that a certain global variable should not be demoted. */
 void
 Oracle::markGlobalSlotUndemotable(JSScript* script, unsigned slot)
@@ -352,32 +427,27 @@ static bool isPromoteInt(LIns* i)
     return isi2f(i) || i->isconst() ||
         (i->isconstq() && (d = i->constvalf()) == jsdouble(jsint(d)) && !JSDOUBLE_IS_NEGZERO(d));
 }
 
 static bool isPromoteUint(LIns* i)
 {
     jsdouble d;
     return isu2f(i) || i->isconst() ||
-        (i->isconstq() && ((d = i->constvalf()) == (jsdouble)(jsuint)d));
+        (i->isconstq() && (d = i->constvalf()) == (jsdouble)(jsuint)d && !JSDOUBLE_IS_NEGZERO(d));
 }
 
 static bool isPromote(LIns* i)
 {
     return isPromoteInt(i) || isPromoteUint(i);
 }
 
 static bool isconst(LIns* i, int32_t c)
 {
     return i->isconst() && i->constval() == c;
-}
-
-static bool isAnyConst(LIns* i)
-{
-    return i->isconst() || i->isconstq(); 
 }
 
 static bool overflowSafe(LIns* i)
 {
     LIns* c;
     return (i->isop(LIR_and) && ((c = i->oprnd2())->isconst()) &&
             ((c->constval() & 0xc0000000) == 0)) ||
            (i->isop(LIR_rsh) && ((c = i->oprnd2())->isconst()) &&
@@ -589,16 +659,30 @@ public:
           case F_BoxDouble:
             JS_ASSERT(s0->isQuad());
             if (s0->isop(LIR_i2f)) {
                 LIns* args2[] = { s0->oprnd1(), args[1] };
                 return out->insCall(F_BoxInt32, args2);
             }
             if (s0->isCall() && s0->fid() == F_UnboxDouble) 
                 return callArgN(s0, 0);
+            break;
+          case F_Any_getelem:
+            JS_ASSERT(s0->isQuad());
+            if (isPromote(s0)) {
+                LIns* args2[] = { demote(out, s0), args[1], args[2] };
+                return out->insCall(F_Any_getelem_int, args2);
+            }
+            break;
+          case F_Any_setelem:
+            JS_ASSERT(args[1]->isQuad());
+            if (isPromote(args[1])) {
+                LIns* args2[] = { s0, demote(out, args[1]), args[2], args[3] };
+                return out->insCall(F_Any_setelem_int, args2);
+            }
             break;
         }
         return out->insCall(fid, args);
     }
 };
 
 /* In debug mode vpname contains a textual description of the type of the
    slot during the forall iteration over al slots. */
@@ -737,33 +821,33 @@ TypeMap::captureGlobalTypes(JSContext* c
 {
     unsigned ngslots = slots.length();
     uint16* gslots = slots.data();
     setLength(ngslots);
     uint8* map = data();
     uint8* m = map;
     FORALL_GLOBAL_SLOTS(cx, ngslots, gslots,
         uint8 type = getCoercedType(*vp);
-        if ((type == JSVAL_INT) && oracle->isGlobalSlotUndemotable(cx->fp->script, gslots[n]))
+        if ((type == JSVAL_INT) && oracle.isGlobalSlotUndemotable(cx->fp->script, gslots[n]))
             type = JSVAL_DOUBLE;
         *m++ = type;
     );
 }
 
 /* Capture the type map for the currently pending stack frames. */
 void
 TypeMap::captureStackTypes(JSContext* cx, unsigned callDepth)
 {
     setLength(js_NativeStackSlots(cx, callDepth));
     uint8* map = data();
     uint8* m = map;
     FORALL_SLOTS_IN_PENDING_FRAMES(cx, callDepth,
         uint8 type = getCoercedType(*vp);
         if ((type == JSVAL_INT) &&
-            oracle->isStackSlotUndemotable(cx->fp->script, cx->fp->regs->pc, unsigned(m - map))) {
+            oracle.isStackSlotUndemotable(cx->fp->script, cx->fp->regs->pc, unsigned(m - map))) {
             type = JSVAL_DOUBLE;
         }
         *m++ = type;
     );
 }
 
 /* Compare this type map to another one and see whether they match. */
 bool
@@ -805,20 +889,22 @@ TraceRecorder::TraceRecorder(JSContext* 
     this->treeInfo = ti;
     this->callDepth = _fragment->calldepth;
     JS_ASSERT(!_anchor || _anchor->calldepth == _fragment->calldepth);
     this->atoms = cx->fp->script->atomMap.vector;
     this->deepAborted = false;
     this->applyingArguments = false;
     this->trashTree = false;
     this->whichTreeToTrash = _fragment->root;
+    this->global_dslots = this->globalObj->dslots;
 
     debug_only_v(printf("recording starting from %s:%u@%u\n", cx->fp->script->filename,
                         js_PCToLineNumber(cx, cx->fp->script, cx->fp->regs->pc),
                         cx->fp->regs->pc - cx->fp->script->code););
+    debug_only_v(printf("globalObj=%p, shape=%d\n", this->globalObj, OBJ_SHAPE(this->globalObj));)
 
     lir = lir_buf_writer = new (&gc) LirBufWriter(lirbuf);
 #ifdef DEBUG
     if (verbose_debug)
         lir = verbose_filter = new (&gc) VerboseWriter(&gc, lir, lirbuf->names);
 #endif
 #ifdef NJ_SOFTFLOAT
     lir = float_filter = new (&gc) SoftFloatFilter(lir);
@@ -841,17 +927,18 @@ TraceRecorder::TraceRecorder(JSContext* 
 
     /* read into registers all values on the stack and all globals we know so far */
     import(treeInfo, lirbuf->sp, ngslots, callDepth, globalTypeMap, stackTypeMap);
 
     /* If we are attached to a tree call guard, make sure the guard the inner tree exited from
        is what we expect it to be. */
     if (_anchor && _anchor->exit->exitType == NESTED_EXIT) {
         LIns* nested_ins = addName(lir->insLoad(LIR_ldp, lirbuf->state, 
-                                                offsetof(InterpState, nestedExit)), "nestedExit");
+                                                offsetof(InterpState, lastTreeExitGuard)), 
+                                                "lastTreeExitGuard");
         guard(true, lir->ins2(LIR_eq, nested_ins, INS_CONSTPTR(innermostNestedGuard)), NESTED_EXIT);
     }
 }
 
 TraceRecorder::~TraceRecorder()
 {
     JS_ASSERT(treeInfo);
     if (fragment->root == fragment && !fragment->root->code()) {
@@ -1359,17 +1446,17 @@ TraceRecorder::lazilyImportGlobalSlot(un
         return true; /* we already have it */
     unsigned index = traceMonitor->globalSlots->length();
     /* If this the first global we are adding, remember the shape of the global object. */
     if (index == 0)
         traceMonitor->globalShape = OBJ_SHAPE(JS_GetGlobalForObject(cx, cx->fp->scopeChain));
     /* Add the slot to the list of interned global slots. */
     traceMonitor->globalSlots->add(slot);
     uint8 type = getCoercedType(*vp);
-    if ((type == JSVAL_INT) && oracle->isGlobalSlotUndemotable(cx->fp->script, slot))
+    if ((type == JSVAL_INT) && oracle.isGlobalSlotUndemotable(cx->fp->script, slot))
         type = JSVAL_DOUBLE;
     traceMonitor->globalTypeMap->add(type);
     import(gp_ins, slot*sizeof(double), vp, type, "global", index, NULL);
     return true;
 }
 
 /* Write back a value onto the stack or global frames. */
 LIns*
@@ -1499,30 +1586,30 @@ TraceRecorder::adjustCallerTypes(Fragmen
     uint8* map = ((TreeInfo*)f->vmprivate)->stackTypeMap.data();
     bool ok = true;
     FORALL_GLOBAL_SLOTS(cx, ngslots, gslots, 
         LIns* i = get(vp);
         bool isPromote = isPromoteInt(i);
         if (isPromote && *m == JSVAL_DOUBLE) 
             lir->insStorei(get(vp), gp_ins, nativeGlobalOffset(vp));
         else if (!isPromote && *m == JSVAL_INT) {
-            oracle->markGlobalSlotUndemotable(script, nativeGlobalOffset(vp)/sizeof(double));
+            oracle.markGlobalSlotUndemotable(script, nativeGlobalOffset(vp)/sizeof(double));
             ok = false;
         }
         ++m;
     );
     m = map;
     FORALL_SLOTS_IN_PENDING_FRAMES(cx, 0,
         LIns* i = get(vp);
         bool isPromote = isPromoteInt(i);
         if (isPromote && *m == JSVAL_DOUBLE) 
             lir->insStorei(get(vp), lirbuf->sp, 
                            -treeInfo->nativeStackBase + nativeStackOffset(vp));
         else if (!isPromote && *m == JSVAL_INT) {
-            oracle->markStackSlotUndemotable(script, (jsbytecode*)f->ip, unsigned(m - map));
+            oracle.markStackSlotUndemotable(script, (jsbytecode*)f->ip, unsigned(m - map));
             ok = false;
         }
         ++m;
     );
     JS_ASSERT(f == f->root);
     if (!ok) {
         trashTree = true;
         whichTreeToTrash = f;
@@ -1662,29 +1749,29 @@ TraceRecorder::verifyTypeStability()
     JS_ASSERT(traceMonitor->globalTypeMap->length() == ngslots);
     bool recompile = false;
     uint8* m = typemap;
     FORALL_GLOBAL_SLOTS(cx, ngslots, gslots,
         bool demote = false;
         if (!checkType(*vp, *m, demote))
             return false;
         if (demote) {
-            oracle->markGlobalSlotUndemotable(cx->fp->script, gslots[n]);
+            oracle.markGlobalSlotUndemotable(cx->fp->script, gslots[n]);
             recompile = true;
         }
         ++m
     );
     typemap = treeInfo->stackTypeMap.data();
     m = typemap;
     FORALL_SLOTS_IN_PENDING_FRAMES(cx, callDepth,
         bool demote = false;
         if (!checkType(*vp, *m, demote))
             return false;
         if (demote) {
-            oracle->markStackSlotUndemotable(cx->fp->script, (jsbytecode*)fragment->ip,
+            oracle.markStackSlotUndemotable(cx->fp->script, (jsbytecode*)fragment->ip,
                     unsigned(m - typemap));
             recompile = true;
         }
         ++m
     );
     if (recompile) 
         trashTree = true;
     return !recompile;
@@ -1739,25 +1826,33 @@ TraceRecorder::closeLoop(Fragmento* frag
     SideExit *exit = snapshot(LOOP_EXIT);
     exit->target = fragment->root;
     if (fragment == fragment->root) {
         fragment->lastIns = lir->insGuard(LIR_loop, lir->insImm(1), exit);
     } else {
         fragment->lastIns = lir->insGuard(LIR_x, lir->insImm(1), exit);
     }
     compile(fragmento);
+
+    debug_only_v(printf("recording completed at %s:%u@%u via closeLoop\n", cx->fp->script->filename,
+                        js_PCToLineNumber(cx, cx->fp->script, cx->fp->regs->pc),
+                        cx->fp->regs->pc - cx->fp->script->code););
 }
 
 /* Emit an always-exit guard and compile the tree (used for break statements. */
 void
 TraceRecorder::endLoop(Fragmento* fragmento)
 {
     SideExit *exit = snapshot(LOOP_EXIT);
     fragment->lastIns = lir->insGuard(LIR_x, lir->insImm(1), exit);
     compile(fragmento);
+
+    debug_only_v(printf("recording completed at %s:%u@%u via endLoop\n", cx->fp->script->filename,
+                        js_PCToLineNumber(cx, cx->fp->script, cx->fp->regs->pc),
+                        cx->fp->regs->pc - cx->fp->script->code););
 }
 
 /* Emit code to adjust the stack to match the inner tree's stack expectations. */
 void
 TraceRecorder::prepareTreeCall(Fragment* inner)
 {
     TreeInfo* ti = (TreeInfo*)inner->vmprivate;
     inner_sp_ins = lirbuf->sp;
@@ -1794,27 +1889,24 @@ TraceRecorder::prepareTreeCall(Fragment*
                 lirbuf->state, offsetof(InterpState, rp));
     }
 }
 
 /* Record a call to an inner tree. */
 void
 TraceRecorder::emitTreeCall(Fragment* inner, GuardRecord* lr)
 {
-    JS_ASSERT(lr->exit->exitType == LOOP_EXIT && !lr->calldepth);
     TreeInfo* ti = (TreeInfo*)inner->vmprivate;
     /* Invoke the inner tree. */
     LIns* args[] = { INS_CONSTPTR(inner), lirbuf->state }; /* reverse order */
     LIns* ret = lir->insCall(F_CallTree, args);
     /* Read back all registers, in case the called tree changed any of them. */
     SideExit* exit = lr->exit;
     import(ti, inner_sp_ins, exit->numGlobalSlots, exit->calldepth,
            exit->typeMap, exit->typeMap + exit->numGlobalSlots);
-    /* Store the guard pointer in case we exit on an unexpected guard */
-    lir->insStorei(ret, lirbuf->state, offsetof(InterpState, nestedExit));
     /* Restore sp and rp to their original values (we still have them in a register). */
     if (callDepth > 0) {
         lir->insStorei(lirbuf->sp, lirbuf->state, offsetof(InterpState, sp));
         lir->insStorei(lirbuf->rp, lirbuf->state, offsetof(InterpState, rp));
     }
     /* Guard that we come out of the inner tree along the same side exit we came out when
        we called the inner tree at recording time. */
     guard(true, lir->ins2(LIR_eq, ret, INS_CONSTPTR(lr)), NESTED_EXIT);
@@ -1967,72 +2059,117 @@ js_TrashTree(JSContext* cx, Fragment* f)
     Fragment** data = ti->dependentTrees.data();
     unsigned length = ti->dependentTrees.length();
     for (unsigned n = 0; n < length; ++n)
         js_TrashTree(cx, data[n]);
     delete ti;
     JS_ASSERT(!f->code() && !f->vmprivate);
 }
 
-static unsigned
+static int
 js_SynthesizeFrame(JSContext* cx, const FrameInfo& fi)
 {
     JS_ASSERT(HAS_FUNCTION_CLASS(fi.callee));
 
     JSFunction* fun = GET_FUNCTION_PRIVATE(cx, fi.callee);
     JS_ASSERT(FUN_INTERPRETED(fun));
 
+    /* Assert that we have a correct sp distance from cx->fp->slots in fi. */
+    JS_ASSERT(js_ReconstructStackDepth(cx, cx->fp->script, fi.callpc) ==
+              uintN(fi.s.spdist - cx->fp->script->nfixed));
+
+    uintN nframeslots = JS_HOWMANY(sizeof(JSInlineFrame), sizeof(jsval));
+    JSScript* script = fun->u.i.script;
+    size_t nbytes = (nframeslots + script->nslots) * sizeof(jsval);
+
+    /* Code duplicated from inline_call: case in js_Interpret (FIXME). */
     JSArena* a = cx->stackPool.current;
     void* newmark = (void*) a->avail;
-    JSScript* script = fun->u.i.script;
-
-    // Assert that we have a correct sp distance from cx->fp->slots in fi.
-    JS_ASSERT(js_ReconstructStackDepth(cx, cx->fp->script, fi.callpc) ==
-              uintN(fi.s.spdist - cx->fp->script->nfixed));
-
-    uintN nframeslots = JS_HOWMANY(sizeof(JSInlineFrame), sizeof(jsval));
-    size_t nbytes = (nframeslots + script->nslots) * sizeof(jsval);
+    uintN argc = fi.s.argc & 0x7fff;
+    jsval* vp = cx->fp->slots + fi.s.spdist - (2 + argc);
+    uintN missing = 0;
+    jsval* newsp;
+
+    if (fun->nargs > argc) {
+        const JSFrameRegs& regs = *cx->fp->regs;
+
+        newsp = vp + 2 + fun->nargs;
+        JS_ASSERT(newsp > regs.sp);
+        if ((jsuword) newsp <= a->limit) {
+            if ((jsuword) newsp > a->avail)
+                a->avail = (jsuword) newsp;
+            jsval* argsp = newsp;
+            do {
+                *--argsp = JSVAL_VOID;
+            } while (argsp != regs.sp);
+            missing = 0;
+        } else {
+            missing = fun->nargs - argc;
+            nbytes += (2 + fun->nargs) * sizeof(jsval);
+        }
+    }
 
     /* Allocate the inline frame with its vars and operands. */
-    jsval* newsp;
     if (a->avail + nbytes <= a->limit) {
         newsp = (jsval *) a->avail;
         a->avail += nbytes;
+        JS_ASSERT(missing == 0);
     } else {
         JS_ARENA_ALLOCATE_CAST(newsp, jsval *, &cx->stackPool, nbytes);
         if (!newsp) {
             js_ReportOutOfScriptQuota(cx);
             return 0;
+        }
+
+        /*
+         * Move args if the missing ones overflow arena a, then push
+         * undefined for the missing args.
+         */
+        if (missing) {
+            memcpy(newsp, vp, (2 + argc) * sizeof(jsval));
+            vp = newsp;
+            newsp = vp + 2 + argc;
+            do {
+                *newsp++ = JSVAL_VOID;
+            } while (--missing != 0);
         }
     }
 
     /* Claim space for the stack frame and initialize it. */
     JSInlineFrame* newifp = (JSInlineFrame *) newsp;
     newsp += nframeslots;
 
     newifp->frame.callobj = NULL;
     newifp->frame.argsobj = NULL;
     newifp->frame.varobj = NULL;
     newifp->frame.script = script;
     newifp->frame.callee = fi.callee;
     newifp->frame.fun = fun;
 
-    newifp->frame.argc = fi.s.argc;
+    bool constructing = fi.s.argc & 0x8000;
+    
+    newifp->frame.argc = argc;
     newifp->callerRegs.pc = fi.callpc;
     newifp->callerRegs.sp = cx->fp->slots + fi.s.spdist;
-    newifp->frame.argv = newifp->callerRegs.sp - JS_MAX(fun->nargs, fi.s.argc);
+    newifp->frame.argv = newifp->callerRegs.sp - JS_MAX(fun->nargs, argc);
+    JS_ASSERT(newifp->frame.argv);
+#ifdef DEBUG
+    // Initialize argv[-1] to a known-bogus value so we'll catch it if
+    // someone forgets to initialize it later.
+    newifp->frame.argv[-1] = JSVAL_HOLE;
+#endif
     JS_ASSERT(newifp->frame.argv >= StackBase(cx->fp));
 
     newifp->frame.rval = JSVAL_VOID;
     newifp->frame.down = cx->fp;
     newifp->frame.annotation = NULL;
     newifp->frame.scopeChain = OBJ_GET_PARENT(cx, fi.callee);
     newifp->frame.sharpDepth = 0;
     newifp->frame.sharpArray = NULL;
-    newifp->frame.flags = 0;
+    newifp->frame.flags = constructing ? JSFRAME_CONSTRUCTING : 0;
     newifp->frame.dormantNext = NULL;
     newifp->frame.xmlNamespace = NULL;
     newifp->frame.blockChain = NULL;
     newifp->mark = newmark;
     newifp->frame.thisp = NULL; // will be set by js_ExecuteTree -> FlushNativeStackFrame
 
     newifp->frame.regs = cx->fp->regs;
     newifp->frame.regs->pc = script->code;
@@ -2044,16 +2181,21 @@ js_SynthesizeFrame(JSContext* cx, const 
         *disp = &newifp->frame;
     }
 #ifdef DEBUG
     newifp->frame.pcDisabledSave = 0;
 #endif
 
     cx->fp->regs = &newifp->callerRegs;
     cx->fp = &newifp->frame;
+
+    if (fun->flags & JSFUN_HEAVYWEIGHT) {
+        if (!js_GetCallObject(cx, &newifp->frame, newifp->frame.scopeChain))
+            return -1;
+    }
 
     // FIXME: we must count stack slots from caller's operand stack up to (but not including)
     // callee's, including missing arguments. Could we shift everything down to the caller's
     // fp->slots (where vars start) and avoid some of the complexity?
     return (fi.s.spdist - cx->fp->down->script->nfixed) +
            ((fun->nargs > cx->fp->argc) ? fun->nargs - cx->fp->argc : 0) +
            script->nfixed;
 }
@@ -2316,19 +2458,18 @@ js_ExecuteTree(JSContext* cx, Fragment**
 
     InterpState state;
     state.sp = (void*)entry_sp;
     state.eos = ((double*)state.sp) + MAX_NATIVE_STACK_SLOTS;
     state.rp = callstack;
     state.eor = callstack + MAX_CALL_STACK_ENTRIES;
     state.gp = global;
     state.cx = cx;
-#ifdef DEBUG
-    state.nestedExit = NULL;
-#endif    
+    state.lastTreeExitGuard = NULL;
+    state.lastTreeCallGuard = NULL;
     union { NIns *code; GuardRecord* (FASTCALL *func)(InterpState*, Fragment*); } u;
     u.code = f->code();
 
 #ifdef DEBUG
 #if defined(NANOJIT_IA32) || (defined(NANOJIT_AMD64) && defined(__GNUC__))
     uint64 start = rdtsc();
 #endif
 #endif
@@ -2344,67 +2485,86 @@ js_ExecuteTree(JSContext* cx, Fragment**
     GuardRecord* lr;
     
 #if defined(JS_NO_FASTCALL) && defined(NANOJIT_IA32)
     SIMULATE_FASTCALL(lr, &state, NULL, u.func);
 #else
     lr = u.func(&state, NULL);
 #endif
 
+    JS_ASSERT(lr->exit->exitType != LOOP_EXIT || !lr->calldepth);
+
     if (!onTrace)
         tm->onTrace = false;
 
-    /* If we bail out on a nested exit, the compiled code returns the outermost nesting
-       guard but what we are really interested in is the innermost guard that we hit
-       instead of the guard we were expecting there. */
-    int slots;
+    /* While executing a tree we do not update state.sp and state.rp even if they grow. Instead,
+       guards tell us by how much sp and rp should be incremented in case of a side exit. When
+       calling a nested tree, however, we actively adjust sp and rp. If we have such frames
+       from outer trees on the stack, then rp will have been adjusted. Before we can process
+       the stack of the frames of the tree we directly exited from, we have to first work our
+       way through the outer frames and generate interpreter frames for them. Once the call
+       stack (rp) is empty, we can process the final frames (which again are not directly
+       visible and only the guard we exited on will tells us about). */
+    FrameInfo* rp = (FrameInfo*)state.rp;
     if (lr->exit->exitType == NESTED_EXIT) {
-        /* Unwind all frames held by nested outer trees (since the innermost tree's frame which
-           we restore below doesn't contain such frames. */
-        do {
-            if (innermostNestedGuardp)
-                *innermostNestedGuardp = lr;
-            debug_only_v(printf("processing tree call guard %p, calldepth=%d\n",
-                                lr, lr->calldepth);)
-            unsigned calldepth = lr->calldepth;
-            if (calldepth > 0) {
-                /* We found a nesting guard that holds one or more frames to
-                   reconstruct. */
-                for (unsigned i = 0; i < calldepth; ++i)
-                    js_SynthesizeFrame(cx, callstack[i]);
-                /* Restore the native stack excluding the current frame, which the next tree
-                   call guard or the innermost tree exit guard will restore. */
-                slots = FlushNativeStackFrame(cx, calldepth,
-                                              lr->exit->typeMap + lr->exit->numGlobalSlots,
-                                              stack, cx->fp);
-                if (slots < 0)
-                    return NULL;
-                callstack += calldepth;
-                inlineCallCount += calldepth;
-                stack += slots;
-            }
-            JS_ASSERT(lr->guard->oprnd1()->oprnd2()->isconstp());
-            lr = (GuardRecord*)lr->guard->oprnd1()->oprnd2()->constvalp();
-        } while (lr->exit->exitType == NESTED_EXIT);
-        
-        /* We restored the nested frames, now we just need to deal with the innermost guard. */
-        lr = state.nestedExit;
-        JS_ASSERT(lr);
-    }
+        if (state.lastTreeCallGuard)
+            lr = state.lastTreeCallGuard;
+        JS_ASSERT(lr->exit->exitType == NESTED_EXIT);
+        if (innermostNestedGuardp)
+            *innermostNestedGuardp = lr;
+        rp += lr->calldepth;
+    }
+    while (callstack < rp) {
+        /* Synthesize a stack frame and write out the values in it using the type map pointer
+           on the native call stack. */
+        if (js_SynthesizeFrame(cx, *callstack) < 0)
+            return NULL;
+        int slots = FlushNativeStackFrame(cx, 1/*callDepth*/, callstack->typemap, stack, cx->fp);
+#ifdef DEBUG
+        JSStackFrame* fp = cx->fp;
+        debug_only_v(printf("synthesized deep frame for %s:%u@%u, slots=%d\n",
+                            fp->script->filename, js_PCToLineNumber(cx, fp->script, fp->regs->pc),
+                            fp->regs->pc - fp->script->code, slots);)
+#endif        
+        if (slots < 0)
+            return NULL;
+        /* Keep track of the additional frames we put on the interpreter stack and the native
+           stack slots we consumed. */
+        ++inlineCallCount;
+        ++callstack;
+        stack += slots;
+    }
+
+    /* If we bail out on a nested exit, the final state is contained in the innermost
+       guard which we stored in lastTreeExitGuard. */
+    if (lr->exit->exitType == NESTED_EXIT)
+        lr = state.lastTreeExitGuard;
+    JS_ASSERT(lr->exit->exitType != NESTED_EXIT);
 
     /* sp_adj and ip_adj are relative to the tree we exit out of, not the tree we
        entered into (which might be different in the presence of nested trees). */
     ti = (TreeInfo*)lr->from->root->vmprivate;
 
     /* We already synthesized the frames around the innermost guard. Here we just deal
        with additional frames inside the tree we are bailing out from. */
+    JS_ASSERT(rp == callstack);
     unsigned calldepth = lr->calldepth;
     unsigned calldepth_slots = 0;
-    for (unsigned n = 0; n < calldepth; ++n)
-        calldepth_slots += js_SynthesizeFrame(cx, callstack[n]);
+    for (unsigned n = 0; n < calldepth; ++n) {
+        int nslots = js_SynthesizeFrame(cx, callstack[n]);
+        if (nslots < 0)
+            return NULL;
+        calldepth_slots += nslots;
+#ifdef DEBUG        
+        JSStackFrame* fp = cx->fp;
+        debug_only_v(printf("synthesized shallow frame for %s:%u@%u\n",
+                            fp->script->filename, js_PCToLineNumber(cx, fp->script, fp->regs->pc),
+                            fp->regs->pc - fp->script->code);)
+#endif        
+    }
 
     /* Adjust sp and pc relative to the tree we exited from (not the tree we entered
        into). These are our final values for sp and pc since js_SynthesizeFrame has
        already taken care of all frames in between. */
     SideExit* e = lr->exit;
     JSStackFrame* fp = cx->fp;
 
     /* If we are not exiting from an inlined frame the state->sp is spbase, otherwise spbase
@@ -2416,50 +2576,59 @@ js_ExecuteTree(JSContext* cx, Fragment**
 
 #if defined(DEBUG) && (defined(NANOJIT_IA32) || (defined(NANOJIT_AMD64) && defined(__GNUC__)))
     uint64 cycles = rdtsc() - start;
 #elif defined(DEBUG)
     uint64 cycles = 0;
 #endif
 
     debug_only_v(printf("leaving trace at %s:%u@%u, op=%s, lr=%p, exitType=%d, sp=%d, ip=%p, "
-                        "cycles=%llu\n",
+                        "calldepth=%d, cycles=%llu\n",
                         fp->script->filename, js_PCToLineNumber(cx, fp->script, fp->regs->pc),
                         fp->regs->pc - fp->script->code,
                         js_CodeName[*fp->regs->pc],
                         lr,
                         lr->exit->exitType,
                         fp->regs->sp - StackBase(fp), lr->jmp,
+                        calldepth,
                         cycles));
 
     /* If this trace is part of a tree, later branches might have added additional globals for
        with we don't have any type information available in the side exit. We merge in this
        information from the entry type-map. See also comment in the constructor of TraceRecorder
        why this is always safe to do. */
     unsigned exit_gslots = e->numGlobalSlots;
     JS_ASSERT(ngslots == tm->globalTypeMap->length());
     JS_ASSERT(ngslots >= exit_gslots);
     uint8* globalTypeMap = e->typeMap;
     if (exit_gslots < ngslots)
         mergeTypeMaps(&globalTypeMap, &exit_gslots, tm->globalTypeMap->data(), ngslots,
                       (uint8*)alloca(sizeof(uint8) * ngslots));
     JS_ASSERT(exit_gslots == tm->globalTypeMap->length());
 
     /* write back interned globals */
-    slots = FlushNativeGlobalFrame(cx, exit_gslots, gslots, globalTypeMap, global);
+    int slots = FlushNativeGlobalFrame(cx, exit_gslots, gslots, globalTypeMap, global);
     if (slots < 0)
         return NULL;
     JS_ASSERT(globalFrameSize == STOBJ_NSLOTS(globalObj));
     JS_ASSERT(*(uint64*)&global[globalFrameSize] == 0xdeadbeefdeadbeefLL);
 
     /* write back native stack frame */
     slots = FlushNativeStackFrame(cx, e->calldepth, e->typeMap + e->numGlobalSlots, stack, NULL);
     if (slots < 0)
         return NULL;
     JS_ASSERT(unsigned(slots) == e->numStackSlots);
+
+#ifdef DEBUG
+    // Verify that our state restoration worked
+    for (JSStackFrame* fp = cx->fp; fp; fp = fp->down) {
+        JS_ASSERT(!fp->callee || JSVAL_IS_OBJECT(fp->argv[-1]));
+        JS_ASSERT(!fp->callee || fp->thisp == JSVAL_TO_OBJECT(fp->argv[-1]));
+    }
+#endif
 
     AUDIT(sideExitIntoInterpreter);
 
     if (!lr) /* did the tree actually execute? */
         return NULL;
 
     /* Adjust inlineCallCount (we already compensated for any outer nested frames). */
     inlineCallCount += lr->calldepth;
@@ -2527,16 +2696,22 @@ js_MonitorLoopEdge(JSContext* cx, jsbyte
 
 bool
 js_MonitorRecording(TraceRecorder* tr)
 {
     JSContext* cx = tr->cx;
 
     // Clear one-shot flag used to communicate between record_JSOP_CALL and record_EnterFrame.
     tr->applyingArguments = false;
+
+    // In the future, handle dslots realloc by computing an offset from dslots instead.
+    if (tr->global_dslots != tr->globalObj->dslots) {
+        js_AbortRecording(cx, NULL, "globalObj->dslots reallocated");
+        return false;
+    }
 
     // Process deepAbort() requests now.
     if (tr->wasDeepAborted()) {
         js_AbortRecording(cx, NULL, "deep abort requested");
         return false;
     }
 
     jsbytecode* pc = cx->fp->regs->pc;
@@ -2629,45 +2804,43 @@ js_InitJIT(JSTraceMonitor *tm)
 js_InitJIT(JSTraceMonitor *tm)
 {
 #if defined NANOJIT_IA32
     if (!did_we_check_sse2) {
         avmplus::AvmCore::sse2_available = js_CheckForSSE2();
         did_we_check_sse2 = true;
     }
 #endif
-    if (!oracle)
-        oracle = new (&gc) Oracle();
     if (!tm->fragmento) {
         JS_ASSERT(!tm->globalSlots && !tm->globalTypeMap);
         Fragmento* fragmento = new (&gc) Fragmento(core, 24);
         verbose_only(fragmento->labels = new (&gc) LabelMap(core, NULL);)
         fragmento->assm()->setCallTable(builtins);
         tm->fragmento = fragmento;
         tm->globalSlots = new (&gc) SlotList();
         tm->globalTypeMap = new (&gc) TypeMap();
     }
 #if !defined XP_WIN
-    debug_only(memset(&stat, 0, sizeof(stat)));
+    debug_only(memset(&jitstats, 0, sizeof(jitstats)));
 #endif
 }
 
 extern void
 js_FinishJIT(JSTraceMonitor *tm)
 {
 #ifdef DEBUG
     printf("recorder: started(%llu), aborted(%llu), completed(%llu), different header(%llu), "
            "trees trashed(%llu), slot promoted(%llu), unstable loop variable(%llu), "
            "breaks(%llu), returns(%llu)\n",
-           stat.recorderStarted, stat.recorderAborted, stat.traceCompleted,
-           stat.returnToDifferentLoopHeader, stat.treesTrashed, stat.slotPromoted,
-           stat.unstableLoopVariable, stat.breakLoopExits, stat.returnLoopExits);
+           jitstats.recorderStarted, jitstats.recorderAborted, jitstats.traceCompleted,
+           jitstats.returnToDifferentLoopHeader, jitstats.treesTrashed, jitstats.slotPromoted,
+           jitstats.unstableLoopVariable, jitstats.breakLoopExits, jitstats.returnLoopExits);
     printf("monitor: triggered(%llu), exits(%llu), type mismatch(%llu), "
-           "global mismatch(%llu)\n", stat.traceTriggered, stat.sideExitIntoInterpreter,
-           stat.typeMapMismatchAtEntry, stat.globalShapeMismatchAtEntry);
+           "global mismatch(%llu)\n", jitstats.traceTriggered, jitstats.sideExitIntoInterpreter,
+           jitstats.typeMapMismatchAtEntry, jitstats.globalShapeMismatchAtEntry);
 #endif
     if (tm->fragmento != NULL) {
         JS_ASSERT(tm->globalSlots && tm->globalTypeMap);
         verbose_only(delete tm->fragmento->labels;)
         delete tm->fragmento;
         tm->fragmento = NULL;
         delete tm->globalSlots;
         tm->globalSlots = NULL;
@@ -2676,18 +2849,17 @@ js_FinishJIT(JSTraceMonitor *tm)
     }
 }
 
 extern void
 js_FlushJITOracle(JSContext* cx)
 {
     if (!TRACING_ENABLED(cx))
         return;
-    if (oracle)
-        oracle->clear();
+    oracle.clear();
 }
 
 extern void
 js_FlushJITCache(JSContext* cx)
 {
     if (!TRACING_ENABLED(cx))
         return;
     debug_only_v(printf("Flushing cache.\n"););
@@ -2706,25 +2878,16 @@ js_FlushJITCache(JSContext* cx)
     memset(&tm->fcache, 0, sizeof(tm->fcache));
     if (cx->fp) {
         tm->globalShape = OBJ_SHAPE(JS_GetGlobalForObject(cx, cx->fp->scopeChain));
         tm->globalSlots->clear();
         tm->globalTypeMap->clear();
     }
 }
 
-void
-js_ShutDownJIT()
-{
-    if (oracle) {
-        delete oracle;
-        oracle = NULL;
-    }
-}
-
 jsval&
 TraceRecorder::argval(unsigned n) const
 {
     JS_ASSERT(n < cx->fp->fun->nargs);
     return cx->fp->argv[n];
 }
 
 jsval&
@@ -2852,72 +3015,72 @@ LIns* TraceRecorder::f2i(LIns* f)
 {
     return lir->insCall(F_DoubleToInt32, &f);
 }
 
 bool
 TraceRecorder::ifop()
 {
     jsval& v = stackval(-1);
+    LIns* v_ins = get(&v);
+    /* no need to guard if condition is constant */
+    if (v_ins->isconst() || v_ins->isconstq())
+        return true;
     if (JSVAL_TAG(v) == JSVAL_BOOLEAN) {
         guard(JSVAL_TO_BOOLEAN(v) != 1,
-              lir->ins_eq0(lir->ins2i(LIR_eq, get(&v), 1)),
+              lir->ins_eq0(lir->ins2i(LIR_eq, v_ins, 1)),
               BRANCH_EXIT);
     } else if (JSVAL_IS_OBJECT(v)) {
-        guard(JSVAL_IS_NULL(v), lir->ins_eq0(get(&v)), BRANCH_EXIT);
+        guard(JSVAL_IS_NULL(v), lir->ins_eq0(v_ins), BRANCH_EXIT);
     } else if (isNumber(v)) {
         jsdouble d = asNumber(v);
         jsdpun u;
         u.d = 0;
-        LIns* v_ins = get(&v);
-
-        // Only insert the guard if the condition is not constant, since in 
-        // that case at runtime we would always take the same path as the
-        // interpreter is taking right now and hence there is no need for
-        // a guard.        
-        if (!v_ins->isconst() && !v_ins->isconstq()) {
-            guard(d == 0 || JSDOUBLE_IS_NaN(d),
-                  lir->ins2(LIR_feq, v_ins, lir->insImmq(u.u64)),
-                  BRANCH_EXIT);
-        }
+        guard(d == 0 || JSDOUBLE_IS_NaN(d),
+              lir->ins2(LIR_feq, v_ins, lir->insImmq(u.u64)),
+              BRANCH_EXIT);
     } else if (JSVAL_IS_STRING(v)) {
         guard(JSSTRING_LENGTH(JSVAL_TO_STRING(v)) == 0,
               lir->ins_eq0(lir->ins2(LIR_piand,
                                      lir->insLoad(LIR_ldp, 
-                                                  get(&v), 
+                                                  v_ins, 
                                                   (int)offsetof(JSString, length)),
                                      INS_CONSTPTR(JSSTRING_LENGTH_MASK))),
               BRANCH_EXIT);
     } else {
         JS_NOT_REACHED("ifop");
     }
     return true;
 }
 
 bool
 TraceRecorder::switchop()
 {
     jsval& v = stackval(-1);
+    LIns* v_ins = get(&v);
+    /* no need to guard if condition is constant */
+    if (v_ins->isconst() || v_ins->isconstq())
+        return true;
     if (isNumber(v)) {
         jsdouble d = asNumber(v);
         jsdpun u;
         u.d = d;
         guard(true,
-              addName(lir->ins2(LIR_feq, get(&v), lir->insImmq(u.u64)),
+              addName(lir->ins2(LIR_feq, v_ins, lir->insImmq(u.u64)),
                       "guard(switch on numeric)"),
               BRANCH_EXIT);
     } else if (JSVAL_IS_STRING(v)) {
-        LIns* args[] = { get(&v), INS_CONSTPTR(JSVAL_TO_STRING(v)) };
+        LIns* args[] = { v_ins, INS_CONSTPTR(JSVAL_TO_STRING(v)) };
         guard(true,
               addName(lir->ins_eq0(lir->ins_eq0(lir->insCall(F_EqualStrings, args))),
                       "guard(switch on string)"),
               BRANCH_EXIT);
     } else if (JSVAL_IS_BOOLEAN(v)) {
         guard(true,
-              addName(lir->ins2(LIR_eq, get(&v), lir->insImm(JSVAL_TO_BOOLEAN(v))),
+              addName(lir->ins2(LIR_eq, v_ins, lir->insImm(JSVAL_TO_BOOLEAN(v))),
                       "guard(switch on boolean)"),
               BRANCH_EXIT);
     } else {
         ABORT_TRACE("switch on object, null, or undefined");
     }
     return true;
 }
 
@@ -2996,59 +3159,108 @@ TraceRecorder::incElem(jsint incr, bool 
     if (!inc(*vp, v_ins, incr, pre))
         return false;
     if (!box_jsval(*vp, v_ins))
         return false;
     lir->insStorei(v_ins, addr_ins, 0);
     return true;
 }
 
+static bool
+evalCmp(LOpcode op, double result)
+{
+    bool cond;
+    switch (op) {
+      case LIR_feq:
+        cond = (result == 0);
+        break;
+      case LIR_flt:
+        cond = result < 0;
+        break;
+      case LIR_fgt:
+        cond = result > 0;
+        break;
+      case LIR_fle:
+        cond = result <= 0;
+        break;
+      case LIR_fge:
+        cond = result >= 0;
+        break;
+      default:
+        JS_NOT_REACHED("unexpected comparison op");
+        return false;
+    }
+    return cond;
+}
+
+static bool
+evalCmp(LOpcode op, double l, double r)
+{
+    return evalCmp(op, l - r);
+}
+
+static bool
+evalCmp(LOpcode op, JSString* l, JSString* r)
+{
+    if (op == LIR_feq)
+        return js_EqualStrings(l, r);
+    return evalCmp(op, js_CompareStrings(l, r));
+}
+
 bool
 TraceRecorder::cmp(LOpcode op, int flags)
 {
     jsval& r = stackval(-1);
     jsval& l = stackval(-2);
-    LIns* x;
+    LIns* x = NULL;
     bool negate = !!(flags & CMP_NEGATE);
     bool cond;
     LIns* l_ins = get(&l);
     LIns* r_ins = get(&r);
 
-    if (JSVAL_IS_STRING(l) && JSVAL_IS_STRING(r)) {
-        JS_ASSERT(!negate);
-        LIns* args[] = { r_ins, l_ins };
-        x = lir->ins1(LIR_i2f, lir->insCall(F_CompareStrings, args));
-        x = lir->ins2i(op, x, 0);
-        jsint result = js_CompareStrings(JSVAL_TO_STRING(l), JSVAL_TO_STRING(r));
-        switch (op) {
-          case LIR_flt:
-            cond = result < 0;
-            break;
-          case LIR_fgt:
-            cond = result > 0;
-            break;
-          case LIR_fle:
-            cond = result <= 0;
-            break;
-          case LIR_fge:
-            cond = result >= 0;
-            break;
-          default:
-            JS_NOT_REACHED("unexpected comparison op for strings");
-            return false;
+    // CMP_STRICT is only set for JSOP_STRICTEQ and JSOP_STRICTNE, which correspond to the
+    // === and !== operators. negate is true for !== and false for ===. The strict equality
+    // operators produce false if the types of the operands differ, i.e. if only one of 
+    // them is a number. 
+    if ((flags & CMP_STRICT) && getPromotedType(l) != getPromotedType(r)) {
+        x = INS_CONST(negate);
+        cond = negate;
+    } else if (JSVAL_IS_STRING(l) || JSVAL_IS_STRING(r)) {
+        // The following cases always produce a constant false (or true if negated):
+        // - comparing a string against null
+        // - comparing a string against any boolean (including undefined)
+        if ((JSVAL_IS_NULL(l) && l_ins->isconst()) ||
+            (JSVAL_IS_NULL(r) && r_ins->isconst()) ||
+            (JSVAL_TAG(l) == JSVAL_BOOLEAN || JSVAL_TAG(r) == JSVAL_BOOLEAN)) {
+            x = INS_CONST(negate);
+            cond = negate;
+        } else if (!JSVAL_IS_STRING(l) || !JSVAL_IS_STRING(r)) {
+            ABORT_TRACE("unsupported type for cmp vs string");
+        } else {
+            LIns* args[] = { r_ins, l_ins };
+            if (op == LIR_feq)
+                l_ins = lir->ins_eq0(lir->insCall(F_EqualStrings, args));
+            else
+                l_ins = lir->insCall(F_CompareStrings, args);
+            r_ins = lir->insImm(0);
+            cond = evalCmp(op, JSVAL_TO_STRING(l), JSVAL_TO_STRING(r));
         }
     } else if (isNumber(l) || isNumber(r)) {
         jsval tmp[2] = {l, r};
         JSAutoTempValueRooter tvr(cx, 2, tmp);
 
         // TODO: coerce non-numbers to numbers if it's not string-on-string above
         jsdouble lnum;
         jsdouble rnum;
         LIns* args[] = { l_ins, cx_ins };
-        if (JSVAL_IS_STRING(l)) {
+        if (l == JSVAL_NULL && l_ins->isconst()) {
+            jsdpun u;
+            u.d = js_NaN;
+            l_ins = lir->insImmq(u.u64);
+        } else if (JSVAL_IS_STRING(l)) {
             l_ins = lir->insCall(F_StringToNumber, args);
         } else if (JSVAL_TAG(l) == JSVAL_BOOLEAN) {
             /*
              * What I really want here is for undefined to be type-specialized
              * differently from real booleans.  Failing that, I want to be able
              * to cmov on quads.  Failing that, I want to have small forward
              * branched.  Failing that, I want to be able to ins_choose on quads
              * without cmov.  Failing that, eat flaming builtin!
@@ -3056,80 +3268,63 @@ TraceRecorder::cmp(LOpcode op, int flags
             l_ins = lir->insCall(F_BooleanToNumber, args);
         } else if (!isNumber(l)) {
             ABORT_TRACE("unsupported LHS type for cmp vs number");
         }
         lnum = js_ValueToNumber(cx, &tmp[0]);
 
         args[0] = r_ins;
         args[1] = cx_ins;
-        if (JSVAL_IS_STRING(r)) {
+        if (r == JSVAL_NULL) {
+            jsdpun u;
+            u.d = js_NaN;
+            r_ins = lir->insImmq(u.u64);
+        } else if (JSVAL_IS_STRING(r)) {
             r_ins = lir->insCall(F_StringToNumber, args);
         } else if (JSVAL_TAG(r) == JSVAL_BOOLEAN) {
             // See above for the sob story.
             r_ins = lir->insCall(F_BooleanToNumber, args);
         } else if (!isNumber(r)) {
             ABORT_TRACE("unsupported RHS type for cmp vs number");
         }
         rnum = js_ValueToNumber(cx, &tmp[1]);
-
-        x = lir->ins2(op, l_ins, r_ins);
-
-        if (negate)
-            x = lir->ins_eq0(x);
-        switch (op) {
-          case LIR_flt:
-            cond = lnum < rnum;
-            break;
-          case LIR_fgt:
-            cond = lnum > rnum;
-            break;
-          case LIR_fle:
-            cond = lnum <= rnum;
-            break;
-          case LIR_fge:
-            cond = lnum >= rnum;
-            break;
-          default:
-            JS_ASSERT(op == LIR_feq);
-            cond = (lnum == rnum) ^ negate;
-            break;
-        }
+        cond = evalCmp(op, lnum, rnum);
     } else if (JSVAL_IS_BOOLEAN(l) && JSVAL_IS_BOOLEAN(r)) {
-        x = lir->ins2(op, lir->ins1(LIR_i2f, get(&l)), lir->ins1(LIR_i2f, get(&r)));
-        if (negate)
-            x = lir->ins_eq0(x);
-
         // The well-known values of JSVAL_TRUE and JSVAL_FALSE make this very easy.
         // In particular: JSVAL_TO_BOOLEAN(0) < JSVAL_TO_BOOLEAN(1) so all of these comparisons do
         // the right thing.
-        switch (op) {
-          case LIR_flt:
-            cond = l < r;
-            break;
-          case LIR_fgt:
-            cond = l > r;
-            break;
-          case LIR_fle:
-            cond = l <= r;
-            break;
-          case LIR_fge:
-            cond = l >= r;
-            break;
-          default:
-            JS_ASSERT(op == LIR_feq);
-            cond = (l == r) ^ negate;
-            break;
-        }
+        cond = evalCmp(op, l, r);
+    } else if (JSVAL_IS_OBJECT(l) && JSVAL_IS_OBJECT(r)) {
+        if (op != LIR_feq) {
+            negate = !(op == LIR_fle || op == LIR_fge);
+            op = LIR_feq;
+        }
+        cond = (l == r); 
     } else {
         ABORT_TRACE("unsupported operand types for cmp");
     }
 
+    /* If we didn't generate a constant result yet, than emit the comparison now. */
+    if (!x) {
+        if (!l_ins->isQuad()) {
+            JS_ASSERT(!r_ins->isQuad());
+            JS_ASSERT(op >= LIR_feq && op <= LIR_fge);
+            op = LOpcode(op + (LIR_eq - LIR_feq));
+        } else {
+            JS_ASSERT(r_ins->isQuad());
+        }
+        x = lir->ins2(op, l_ins, r_ins);
+        if (negate) {
+            x = lir->ins_eq0(x);
+            cond = !cond;
+        }
+    }
+    
     /* Don't guard if the same path is always taken. */
-    if (!(isAnyConst(r_ins) && isAnyConst(l_ins))) {
+    if (!x->isconst()) {
         if (flags & CMP_CASE) {
             guard(cond, x, BRANCH_EXIT);
             return true;
         }
 
         /* The interpreter fuses comparisons and the following branch,
            so we have to do that here as well. */
         if (flags & CMP_TRY_BRANCH_AFTER_COND) {
@@ -3141,93 +3336,16 @@ TraceRecorder::cmp(LOpcode op, int flags
 
     /* We update the stack after the guard. This is safe since
        the guard bails out at the comparison and the interpreter
        will therefore re-execute the comparison. This way the
        value of the condition doesn't have to be calculated and
        saved on the stack in most cases. */
     set(&l, x);
     return true;
-}
-
-// FIXME: we currently compare only like operand types; if for JSOP_EQ and
-// JSOP_NE we ever evolve to handle conversions then we must insist on like
-// "types" here (care required for 0 == -1, e.g.).
-bool
-TraceRecorder::equal(int flags)
-{
-    jsval& r = stackval(-1);
-    jsval& l = stackval(-2);
-    bool negate = !!(flags & CMP_NEGATE);
-
-    LIns* r_ins = get(&r);
-    LIns* l_ins = get(&l);
-
-    if (JSVAL_IS_STRING(l) && JSVAL_IS_STRING(r)) {
-        LIns* args[] = { r_ins, l_ins };
-        bool cond = js_EqualStrings(JSVAL_TO_STRING(l), JSVAL_TO_STRING(r)) ^ negate;
-        LIns* x = lir->ins_eq0(lir->insCall(F_EqualStrings, args));
-        if (!negate)
-            x = lir->ins_eq0(x);
-
-        /* Don't guard if the same path is always taken. */
-        if (!(isAnyConst(r_ins) && isAnyConst(l_ins))) {
-            if (flags & CMP_CASE) {
-                guard(cond, x, BRANCH_EXIT);
-                return true;
-            }
-
-            /* The interpreter fuses comparisons and the following branch,
-               so we have to do that here as well. */
-            if (flags & CMP_TRY_BRANCH_AFTER_COND) {
-                fuseIf(cx->fp->regs->pc + 1, cond, x);
-            }
-        } else if (flags & CMP_CASE) {
-            return true;
-        }
-
-        /* We update the stack after the guard. This is safe since
-           the guard bails out at the comparison and the interpreter
-           will therefore re-execute the comparison. This way the
-           value of the condition doesn't have to be calculated and
-           saved on the stack in most cases. */
-        set(&l, x);
-        return true;
-    }
-    if (JSVAL_IS_OBJECT(l) && JSVAL_IS_OBJECT(r)) {
-        bool cond = (l == r) ^ negate;
-        LIns* x = lir->ins2(LIR_eq, l_ins, r_ins);
-        if (negate)
-            x = lir->ins_eq0(x);
-
-        /* Don't guard if the same path is always taken. */
-        if (!(isAnyConst(r_ins) && isAnyConst(l_ins))) {
-            if (flags & CMP_CASE) {
-                guard(cond, x, BRANCH_EXIT);
-                return true;
-            }
-
-            /* The interpreter fuses comparisons and the following branch,
-               so we have to do that here as well. */
-            if (flags & CMP_TRY_BRANCH_AFTER_COND) {
-                fuseIf(cx->fp->regs->pc + 1, cond, x);
-            }
-        } else if (flags & CMP_CASE) {
-            return true;
-        }
-
-        /* We update the stack after the guard. This is safe since
-           the guard bails out at the comparison and the interpreter
-           will therefore re-execute the comparison. This way the
-           value of the condition doesn't have to be calculated and
-           saved on the stack in most cases. */
-        set(&l, x);
-        return true;
-    }
-    return cmp(LIR_feq, flags);
 }
 
 bool
 TraceRecorder::unary(LOpcode op)
 {
     jsval& v = stackval(-1);
     bool intop = !(op & LIR64);
     if (isNumber(v)) {
@@ -3459,25 +3577,25 @@ TraceRecorder::test_property_cache_direc
         return false;
 
     /* No such property means invalid slot, which callers must check for first. */
     if (PCVAL_IS_NULL(pcval)) {
         slot = SPROP_INVALID_SLOT;
         return true;
     }
 
-    /* If modifying the slot, insist on obj being the directly addressed object. */
-    uint32 setflags = (js_CodeSpec[*cx->fp->regs->pc].format & (JOF_SET | JOF_INCDEC));
-    if (setflags && obj2 != obj)
-        ABORT_TRACE("JOF_SET opcode hit prototype chain");
+    /* Insist on obj being the directly addressed object. */
+    if (obj2 != obj)
+        ABORT_TRACE("test_property_cache_direct_slot hit prototype chain");
 
     /* Don't trace getter or setter calls, our caller wants a direct slot. */
     if (PCVAL_IS_SPROP(pcval)) {
         JSScopeProperty* sprop = PCVAL_TO_SPROP(pcval);
 
+        uint32 setflags = (js_CodeSpec[*cx->fp->regs->pc].format & (JOF_SET | JOF_INCDEC));
         if (setflags && !SPROP_HAS_STUB_SETTER(sprop))
             ABORT_TRACE("non-stub setter");
         if (setflags != JOF_SET && !SPROP_HAS_STUB_GETTER(sprop))
             ABORT_TRACE("non-stub getter");
         if (!SPROP_HAS_VALID_SLOT(sprop, OBJ_SCOPE(obj)))
             ABORT_TRACE("no valid slot");
         slot = sprop->slot;
     } else {
@@ -3621,17 +3739,16 @@ TraceRecorder::getThis(LIns*& this_ins)
 TraceRecorder::getThis(LIns*& this_ins)
 {
     if (cx->fp->callee) { /* in a function */
         if (JSVAL_IS_NULL(cx->fp->argv[-1]))
             return false;
         this_ins = get(&cx->fp->argv[-1]);
         guard(false, lir->ins_eq0(this_ins), MISMATCH_EXIT);
     } else { /* in global code */
-        JS_ASSERT(!JSVAL_IS_NULL(cx->fp->argv[-1]));
         this_ins = scopeChain();
     }
     return true;
 }
 
 bool
 TraceRecorder::guardClass(JSObject* obj, LIns* obj_ins, JSClass* clasp)
 {
@@ -3711,17 +3828,17 @@ TraceRecorder::record_EnterFrame()
         ABORT_TRACE("recursive call");
     
     debug_only_v(printf("EnterFrame %s, callDepth=%d\n",
                         js_AtomToPrintableString(cx, cx->fp->fun->atom),
                         callDepth););
     LIns* void_ins = INS_CONST(JSVAL_TO_BOOLEAN(JSVAL_VOID));
 
     jsval* vp = &fp->argv[fp->argc];
-    jsval* vpstop = vp + (fp->fun->nargs - fp->argc);
+    jsval* vpstop = vp + ptrdiff_t(fp->fun->nargs) - ptrdiff_t(fp->argc);
     if (applyingArguments) {
         applyingArguments = false;
         while (vp < vpstop) {
             JS_ASSERT(vp >= fp->down->regs->sp);
             nativeFrameTracker.set(vp, (LIns*)0);
             LIns* arg_ins = get(&fp->down->argv[fp->argc + (vp - vpstop)]);
             set(vp++, arg_ins, true);
         }
@@ -3869,23 +3986,23 @@ TraceRecorder::record_JSOP_BITAND()
 TraceRecorder::record_JSOP_BITAND()
 {
     return binary(LIR_and);
 }
 
 bool
 TraceRecorder::record_JSOP_EQ()
 {
-    return equal(CMP_TRY_BRANCH_AFTER_COND);
+    return cmp(LIR_feq, CMP_TRY_BRANCH_AFTER_COND);
 }
 
 bool
 TraceRecorder::record_JSOP_NE()
 {
-    return equal(CMP_NEGATE | CMP_TRY_BRANCH_AFTER_COND);
+    return cmp(LIR_feq, CMP_NEGATE | CMP_TRY_BRANCH_AFTER_COND);
 }
 
 bool
 TraceRecorder::record_JSOP_LT()
 {
     return cmp(LIR_flt, CMP_TRY_BRANCH_AFTER_COND);
 }
 
@@ -3986,22 +4103,29 @@ TraceRecorder::record_JSOP_MOD()
 
 bool
 TraceRecorder::record_JSOP_NOT()
 {
     jsval& v = stackval(-1);
     if (JSVAL_TAG(v) == JSVAL_BOOLEAN) {
         set(&v, lir->ins_eq0(lir->ins2i(LIR_eq, get(&v), 1)));
         return true;
-    }
-    if (JSVAL_IS_INT(v) || JSVAL_IS_OBJECT(v)) {
-        LIns* a = get(&v);
-        if (JSVAL_IS_INT(v) && isPromoteInt(a))
-            a = ::demote(lir, a);
-        set(&v, lir->ins_eq0(a));
+    } 
+    if (isNumber(v)) {
+        set(&v, lir->ins2(LIR_feq, get(&v), lir->insImmq(0)));
+        return true;
+    } 
+    if (JSVAL_IS_OBJECT(v)) {
+        set(&v, lir->ins_eq0(get(&v)));
+        return true;
+    }
+    if (JSVAL_IS_STRING(v)) {
+        set(&v, lir->ins_eq0(lir->ins2(LIR_piand, 
+                lir->insLoad(LIR_ldp, get(&v), (int)offsetof(JSString, length)),
+                INS_CONSTPTR(JSSTRING_LENGTH_MASK))));
         return true;
     }
     return false;
 }
 
 bool
 TraceRecorder::record_JSOP_BITNOT()
 {
@@ -4079,17 +4203,17 @@ TraceRecorder::record_JSOP_NEW()
     JS_ASSERT(VALUE_IS_FUNCTION(cx, fval));
     JSFunction *fun = GET_FUNCTION_PRIVATE(cx, JSVAL_TO_OBJECT(fval));
 
     if (FUN_INTERPRETED(fun)) {
         LIns* args[] = { get(&fval), cx_ins };
         LIns* tv_ins = lir->insCall(F_FastNewObject, args);
         guard(false, lir->ins_eq0(tv_ins), OOM_EXIT);
         set(&tval, tv_ins);
-        return interpretedFunctionCall(fval, fun, argc);
+        return interpretedFunctionCall(fval, fun, argc, true);
     }
 
     static JSTraceableNative knownNatives[] = {
         { (JSFastNative)js_Array,  F_FastNewArray,  "pC", "",    FAIL_NULL },
         { (JSFastNative)js_Array,  F_Array_1int,    "pC", "i",   FAIL_NULL },
         { (JSFastNative)js_Array,  F_Array_2obj,    "pC", "oo",  FAIL_NULL },
         { (JSFastNative)js_Array,  F_Array_3num,    "pC", "ddd", FAIL_NULL },
         { (JSFastNative)js_Object, F_FastNewObject, "fC", "",    FAIL_NULL },
@@ -4482,30 +4606,39 @@ TraceRecorder::record_JSOP_GETELEM()
 
         LIns* args[] = { f2i(get(&r)), get(&l), cx_ins };
         LIns* unitstr_ins = lir->insCall(F_String_getelem, args);
         guard(false, lir->ins_eq0(unitstr_ins), MISMATCH_EXIT);
         set(&l, unitstr_ins);
         return true;
     }
 
-    if (!JSVAL_IS_PRIMITIVE(l) && JSVAL_IS_STRING(r)) {
+    if (!JSVAL_IS_PRIMITIVE(l) &&
+        (JSVAL_IS_STRING(r) || 
+         (isNumber(r) && (!JSVAL_IS_INT(r) || !OBJ_IS_DENSE_ARRAY(cx, JSVAL_TO_OBJECT(l)))))) {
         jsval v;
         jsid id;
-
-        if (!js_ValueToStringId(cx, r, &id))
-            return false;
-        r = ID_TO_VALUE(id);
+        uint32 fid;
+
+        if (JSVAL_IS_STRING(r)) {
+            if (!js_ValueToStringId(cx, r, &id))
+                return false;
+            r = ID_TO_VALUE(id);
+            fid = F_Any_getprop;
+        } else {
+            if (!js_IndexToId(cx, JSVAL_TO_INT(r), &id))
+                return false;
+            fid = F_Any_getelem;
+        }
         if (!OBJ_GET_PROPERTY(cx, JSVAL_TO_OBJECT(l), id, &v))
             return false;
 
         LIns* args[] = { get(&r), get(&l), cx_ins };
-        LIns* v_ins = lir->insCall(F_Any_getelem, args);
-        guard(false, lir->ins2(LIR_eq, v_ins, INS_CONST(JSVAL_ERROR_COOKIE)),
-              MISMATCH_EXIT);
+        LIns* v_ins = lir->insCall(fid, args);
+        guard(false, lir->ins2(LIR_eq, v_ins, INS_CONST(JSVAL_ERROR_COOKIE)), MISMATCH_EXIT);
         if (!unbox_jsval(v, v_ins))
             ABORT_TRACE("JSOP_GETELEM");
         set(&l, v_ins);
         return true;
     }
 
     jsval* vp;
     LIns* v_ins;
@@ -4524,33 +4657,30 @@ TraceRecorder::record_JSOP_SETELEM()
     jsval& l = stackval(-3);
 
     /* no guards for type checks, trace specialized this already */
     if (JSVAL_IS_PRIMITIVE(l))
         ABORT_TRACE("left JSOP_SETELEM operand is not an object");
     JSObject* obj = JSVAL_TO_OBJECT(l);
     LIns* obj_ins = get(&l);
 
-    if (JSVAL_IS_STRING(r)) {
+    if (JSVAL_IS_STRING(r) || 
+        (isNumber(r) && (!JSVAL_IS_INT(r) || !guardDenseArray(obj, obj_ins)))) {
         LIns* v_ins = get(&v);
         LIns* unboxed_v_ins = v_ins;
         if (!box_jsval(v, v_ins))
             ABORT_TRACE("boxing string-indexed JSOP_SETELEM value");
         LIns* args[] = { v_ins, get(&r), get(&l), cx_ins };
-        LIns* ok_ins = lir->insCall(F_Any_setelem, args);
+        LIns* ok_ins = lir->insCall(JSVAL_IS_STRING(r) ? F_Any_setprop : F_Any_setelem, args);
         guard(false, lir->ins_eq0(ok_ins), MISMATCH_EXIT);
         set(&l, unboxed_v_ins);
         return true;
     }
     if (!JSVAL_IS_INT(r))
         ABORT_TRACE("non-string, non-int JSOP_SETELEM index");
-
-    /* make sure the object is actually a dense array */
-    if (!guardDenseArray(obj, obj_ins))
-        ABORT_TRACE("not a dense array");
 
     /* check that the index is within bounds */
     LIns* idx_ins = f2i(get(&r));
 
     /* we have to check that its really an integer, but this check will to go away
        once we peel the loop type down to integer for this slot */
     guard(true, lir->ins2(LIR_feq, get(&r), lir->ins1(LIR_i2f, idx_ins)), MISMATCH_EXIT);
     /* ok, box the value we are storing, store it and we are done */
@@ -4617,17 +4747,17 @@ TraceRecorder::guardShapelessCallee(jsva
     guard(true,
           addName(lir->ins2(LIR_eq, get(&callee), INS_CONSTPTR(JSVAL_TO_OBJECT(callee))),
                   "guard(shapeless callee)"),
           MISMATCH_EXIT);
     return true;
 }
 
 bool
-TraceRecorder::interpretedFunctionCall(jsval& fval, JSFunction* fun, uintN argc)
+TraceRecorder::interpretedFunctionCall(jsval& fval, JSFunction* fun, uintN argc, bool constructing)
 {
     if (JS_GetGlobalForObject(cx, JSVAL_TO_OBJECT(fval)) != globalObj)
         ABORT_TRACE("JSOP_CALL or JSOP_NEW crosses global scopes");
 
     JSStackFrame* fp = cx->fp;
 
     // TODO: track the copying via the tracker...
     if (argc < fun->nargs &&
@@ -4641,32 +4771,37 @@ TraceRecorder::interpretedFunctionCall(j
     uint8* typemap = (uint8 *)data->payload();
     uint8* m = typemap;
     /* Determine the type of a store by looking at the current type of the actual value the
        interpreter is using. For numbers we have to check what kind of store we used last
        (integer or double) to figure out what the side exit show reflect in its typemap. */
     FORALL_SLOTS_IN_PENDING_FRAMES(cx, 0/*callDepth*/,
         *m++ = determineSlotType(vp);
     );
-    
+
+    if (argc >= 0x8000)
+        ABORT_TRACE("too many arguments");
+
     FrameInfo fi = {
         JSVAL_TO_OBJECT(fval),
         fp->regs->pc,
         typemap,
-        { { fp->regs->sp - fp->slots, argc } }
+        { { fp->regs->sp - fp->slots, argc | (constructing ? 0x8000 : 0) } }
     };
 
     unsigned callDepth = getCallDepth();
     if (callDepth >= treeInfo->maxCallDepth)
         treeInfo->maxCallDepth = callDepth + 1;
 
     lir->insStorei(INS_CONSTPTR(fi.callee), lirbuf->rp,
                    callDepth * sizeof(FrameInfo) + offsetof(FrameInfo, callee));
     lir->insStorei(INS_CONSTPTR(fi.callpc), lirbuf->rp,
                    callDepth * sizeof(FrameInfo) + offsetof(FrameInfo, callpc));
+    lir->insStorei(INS_CONSTPTR(fi.typemap), lirbuf->rp,
+                   callDepth * sizeof(FrameInfo) + offsetof(FrameInfo, typemap));
     lir->insStorei(INS_CONST(fi.word), lirbuf->rp,
                    callDepth * sizeof(FrameInfo) + offsetof(FrameInfo, word));
 
     atoms = fun->u.i.script->atomMap.vector;
     return true;
 }
 
 #define KNOWN_NATIVE_DECL(name) JSBool name(JSContext* cx, uintN argc, jsval* vp);
@@ -4712,17 +4847,17 @@ TraceRecorder::record_JSOP_CALL()
      *
      * Bytecode sequences that push shapeless callees must guard on the callee
      * class being Function and the function being interpreted.
      */
     JS_ASSERT(VALUE_IS_FUNCTION(cx, fval));
     JSFunction* fun = GET_FUNCTION_PRIVATE(cx, JSVAL_TO_OBJECT(fval));
 
     if (FUN_INTERPRETED(fun))
-        return interpretedFunctionCall(fval, fun, argc);
+        return interpretedFunctionCall(fval, fun, argc, false);
 
     if (FUN_SLOW_NATIVE(fun))
         ABORT_TRACE("slow native");
 
     static JSTraceableNative knownNatives[] = {
         { js_array_join,               F_Array_p_join,         "TC",  "s",    FAIL_NULL },
         { js_math_sin,                 F_Math_sin,             "",    "d",    INFALLIBLE },
         { js_math_cos,                 F_Math_cos,             "",    "d",    INFALLIBLE },
@@ -4736,35 +4871,39 @@ TraceRecorder::record_JSOP_CALL()
         { js_num_parseInt,             F_ParseInt,             "C",   "s",    INFALLIBLE },
         { js_num_parseInt,             F_ParseIntDouble,       "",    "d",    INFALLIBLE },
         { js_num_parseFloat,           F_ParseFloat,           "C",   "s",    INFALLIBLE },
         { js_num_toString,             F_NumberToString,       "TC",   "",    FAIL_NULL },
         { js_obj_hasOwnProperty,       F_Object_p_hasOwnProperty,
                                                                "TC",  "s",    FAIL_VOID },
         { js_obj_propertyIsEnumerable, F_Object_p_propertyIsEnumerable,
                                                                "TC",  "s",    FAIL_VOID },
-        { js_str_charAt,               F_String_getelem,       "TC",  "i",    FAIL_NULL },
-        { js_str_charCodeAt,           F_String_p_charCodeAt,  "T",   "i",    FAIL_NEG },
-        { js_str_concat,               F_String_p_concat_1int, "TC",  "i",    FAIL_NULL },
+        { js_str_charAt,               F_String_getelem,       "SC",  "i",    FAIL_NULL },
+        { js_str_charCodeAt,           F_String_p_charCodeAt,  "S",   "i",    FAIL_NEG },
+        { js_str_concat,               F_String_p_concat_1int, "SC",  "i",    FAIL_NULL },
+        { js_str_concat,               F_ConcatStrings,        "SC",  "s",    FAIL_NULL },
+        { js_str_concat,               F_String_p_concat_2str, "SC",  "ss",   FAIL_NULL },
+        { js_str_concat,               F_String_p_concat_3str, "SC",  "sss",  FAIL_NULL },
         { js_str_fromCharCode,         F_String_fromCharCode,  "C",   "i",    FAIL_NULL },
-        { js_str_match,                F_String_p_match,       "PTC", "r",    FAIL_VOID },
-        { js_str_replace,              F_String_p_replace_str, "TC",  "sr",   FAIL_NULL },
-        { js_str_replace,              F_String_p_replace_str2,"TC",  "ss",   FAIL_NULL },
-        { js_str_replace,              F_String_p_replace_str3,"TC",  "sss",  FAIL_NULL },
-        { js_str_split,                F_String_p_split,       "TC",  "s",    FAIL_NULL },
-        { js_str_substring,            F_String_p_substring,   "TC",  "ii",   FAIL_NULL },
-        { js_str_substring,            F_String_p_substring_1, "TC",  "i",    FAIL_NULL },
-        { js_str_toLowerCase,          F_toLowerCase,          "TC",   "",    FAIL_NULL },
-        { js_str_toUpperCase,          F_toUpperCase,          "TC",   "",    FAIL_NULL },
+        { js_str_match,                F_String_p_match,       "PSC", "r",    FAIL_VOID },
+        { js_str_match,                F_String_p_match_obj,   "PTC", "r",    FAIL_VOID },
+        { js_str_replace,              F_String_p_replace_str, "SC",  "sr",   FAIL_NULL },
+        { js_str_replace,              F_String_p_replace_str2,"SC",  "ss",   FAIL_NULL },
+        { js_str_replace,              F_String_p_replace_str3,"SC",  "sss",  FAIL_NULL },
+        { js_str_split,                F_String_p_split,       "SC",  "s",    FAIL_NULL },
+        { js_str_substring,            F_String_p_substring,   "SC",  "ii",   FAIL_NULL },
+        { js_str_substring,            F_String_p_substring_1, "SC",  "i",    FAIL_NULL },
+        { js_str_toLowerCase,          F_toLowerCase,          "SC",   "",    FAIL_NULL },
+        { js_str_toUpperCase,          F_toUpperCase,          "SC",   "",    FAIL_NULL },
     };
 
     uintN i = 0;
     LIns* arg1_ins = NULL;
     jsval arg1 = JSVAL_VOID;
-
+    jsval thisval = tval;
     if ((JSFastNative)fun->u.n.native == js_fun_apply) {
         if (argc != 2)
             ABORT_TRACE("can't trace Function.prototype.apply with other than 2 args");
 
         if (!guardShapelessCallee(tval))
             return false;
         JSObject* tfunobj = JSVAL_TO_OBJECT(tval);
         JSFunction* tfun = GET_FUNCTION_PRIVATE(cx, tfunobj);
@@ -4783,18 +4922,20 @@ TraceRecorder::record_JSOP_CALL()
             ABORT_TRACE("can't trace Function.prototype.apply on non-builtin-call 2nd arg");
 
         if (aval_ins->fid() == F_Arguments) {
             JS_ASSERT(OBJ_GET_CLASS(cx, aobj) == &js_ArgumentsClass);
             JS_ASSERT(OBJ_GET_PRIVATE(cx, aobj) == fp);
             if (!FUN_INTERPRETED(tfun))
                 ABORT_TRACE("can't trace Function.prototype.apply(native_function, arguments)");
 
+            // We can only fasttrack applys where the argument array we pass in has the
+            // same length (fp->argc) as the number of arguments the function expects (tfun->nargs).
             argc = fp->argc;
-            if (tfun->nargs != argc)
+            if (tfun->nargs != argc || fp->fun->nargs != argc)
                 ABORT_TRACE("can't trace Function.prototype.apply(scripted_function, arguments)");
 
             jsval* sp = fp->regs->sp - 4;
             set(sp, get(&tval));
             *sp++ = tval;
             set(sp, get(&oval));
             *sp++ = oval;
             jsval* newsp = sp + argc;
@@ -4807,17 +4948,17 @@ TraceRecorder::record_JSOP_CALL()
             }
 
             jsval* argv = fp->argv;
             for (uintN i = 0; i < JS_MIN(argc, 2); i++) {
                 set(&sp[i], get(&argv[i]));
                 sp[i] = argv[i];
             }
             applyingArguments = true;
-            return interpretedFunctionCall(tval, tfun, argc);
+            return interpretedFunctionCall(tval, tfun, argc, false);
         }
 
         if (aval_ins->fid() != F_Array_1str)
             ABORT_TRACE("can't trace Function.prototype.apply on other than [str] 2nd arg");
 
         JS_ASSERT(OBJ_IS_ARRAY(cx, aobj));
         JS_ASSERT(aobj->fslots[JSSLOT_ARRAY_LENGTH] == 1);
         JS_ASSERT(JSVAL_IS_STRING(aobj->dslots[0]));
@@ -4831,16 +4972,17 @@ TraceRecorder::record_JSOP_CALL()
             if (known->native == (JSFastNative)tfun->u.n.native)
                 break;
             if (++i == JS_ARRAY_LENGTH(knownNatives))
                 ABORT_TRACE("unknown native being Function.prototype.apply'ed");
         }
         if (strlen(known->argtypes) != 1)
             ABORT_TRACE("known native being Function.prototype.apply'ed with wrong argc");
 
+        thisval = oval;
         this_ins = get(&oval);
         arg1_ins = callArgN(aval_ins, 1);
         arg1 = aobj->dslots[0];
         fun = tfun;
         argc = 1;
     }
 
     for (; i < JS_ARRAY_LENGTH(knownNatives); i++) {
@@ -4856,32 +4998,42 @@ TraceRecorder::record_JSOP_CALL()
         LIns* args[5];
         LIns** argp = &args[argc + prefixc - 1];
         char argtype;
 
 #if defined _DEBUG
         memset(args, 0xCD, sizeof(args));
 #endif
 
+/*
+ * NB: do not use JS_BEGIN_MACRO/JS_END_MACRO or the do-while(0) loop they hide,
+ * because of the embedded continues below.
+ */
 #define HANDLE_PREFIX(i)                                                       \
-    JS_BEGIN_MACRO                                                             \
+    {                                                                          \
         argtype = known->prefix[i];                                            \
         if (argtype == 'C') {                                                  \
             *argp = cx_ins;                                                    \
-        } else if (argtype == 'T') {                                           \
+        } else if (argtype == 'T') {   /* this, as an object */                \
+            if (!JSVAL_IS_OBJECT(thisval))                                     \
+                continue;                                                      \
+            *argp = this_ins;                                                  \
+        } else if (argtype == 'S') {   /* this, as a string */                 \
+            if (!JSVAL_IS_STRING(thisval))                                     \
+                continue;                                                      \
             *argp = this_ins;                                                  \
         } else if (argtype == 'R') {                                           \
             *argp = INS_CONSTPTR(cx->runtime);                                 \
         } else if (argtype == 'P') {                                           \
             *argp = INS_CONSTPTR(pc);                                          \
         } else {                                                               \
             JS_NOT_REACHED("unknown prefix arg type");                         \
         }                                                                      \
         argp--;                                                                \
-    JS_END_MACRO
+    }
 
         switch (prefixc) {
           case 3:
             HANDLE_PREFIX(2);
             /* FALL THROUGH */
           case 2:
             HANDLE_PREFIX(1);
             /* FALL THROUGH */
@@ -5258,23 +5410,23 @@ TraceRecorder::record_JSOP_LOOKUPSWITCH(
 TraceRecorder::record_JSOP_LOOKUPSWITCH()
 {
     return switchop();
 }
 
 bool
 TraceRecorder::record_JSOP_STRICTEQ()
 {
-    return equal();
+    return cmp(LIR_feq, CMP_STRICT);
 }
 
 bool
 TraceRecorder::record_JSOP_STRICTNE()
 {
-    return equal(CMP_NEGATE);
+    return cmp(LIR_feq, CMP_STRICT | CMP_NEGATE);
 }
 
 bool
 TraceRecorder::record_JSOP_OBJECT()
 {
     JSStackFrame* fp = cx->fp;
     JSScript* script = fp->script;
     unsigned index = atoms - script->atomMap.vector + GET_INDEX(fp->regs->pc);
@@ -5713,17 +5865,17 @@ TraceRecorder::record_JSOP_CONDSWITCH()
 TraceRecorder::record_JSOP_CONDSWITCH()
 {
     return true;
 }
 
 bool
 TraceRecorder::record_JSOP_CASE()
 {
-    return equal(CMP_CASE);
+    return cmp(LIR_feq, CMP_CASE);
 }
 
 bool
 TraceRecorder::record_JSOP_DEFAULT()
 {
     return true;
 }
 
@@ -5838,17 +5990,17 @@ TraceRecorder::record_JSOP_NOP()
 }
 
 bool
 TraceRecorder::record_JSOP_ARGSUB()
 {
     JSStackFrame* fp = cx->fp;
     if (!(fp->fun->flags & JSFUN_HEAVYWEIGHT)) {
         uintN slot = GET_ARGNO(fp->regs->pc);
-        if (slot < fp->argc && !fp->argsobj) {
+        if (slot < fp->fun->nargs && slot < fp->argc && !fp->argsobj) {
             stack(0, get(&cx->fp->argv[slot]));
             return true;
         }
     }
     ABORT_TRACE("can't trace JSOP_ARGSUB hard case");
 }
 
 bool
@@ -5910,17 +6062,17 @@ TraceRecorder::record_JSOP_GOSUBX()
 TraceRecorder::record_JSOP_GOSUBX()
 {
     return record_JSOP_GOSUB();
 }
 
 bool
 TraceRecorder::record_JSOP_CASEX()
 {
-    return equal(CMP_CASE);
+    return cmp(LIR_feq, CMP_CASE);
 }
 
 bool
 TraceRecorder::record_JSOP_DEFAULTX()
 {
     return true;
 }
 
diff -r 9864735a4241 js/src/jstracer.h
--- a/js/src/jstracer.h	Mon Sep 22 11:50:03 2008 -0700
+++ b/js/src/jstracer.h	Fri Sep 26 09:30:25 2008 -0500
@@ -63,17 +63,17 @@
 /*
  * We also need a magic unboxed 32-bit integer that signals an error.  Again if
  * this number is hit we experience a performance regression, not a runtime
  * error.
  */
 #define INT32_ERROR_COOKIE 0xffffabcd
 
 template <typename T>
-class Queue {
+class Queue : public GCObject {
     T* _data;
     unsigned _len;
     unsigned _max;
     
     void ensure(unsigned size) {
         while (_max < size) 
             _max <<= 1;
         _data = (T*)realloc(_data, _max * sizeof(T));
@@ -198,17 +198,17 @@ public:
 
     TreeInfo(nanojit::Fragment* _fragment) { 
         fragment = _fragment;
     }
 };
 
 extern struct nanojit::CallInfo builtins[];
 
-class TraceRecorder {
+class TraceRecorder : public GCObject {
     JSContext*              cx;
     JSTraceMonitor*         traceMonitor;
     JSObject*               globalObj;
     Tracker                 tracker;
     Tracker                 nativeFrameTracker;
     char*                   entryTypeMap;
     unsigned                callDepth;
     JSAtom**                atoms;
@@ -233,16 +233,17 @@ class TraceRecorder {
     nanojit::LIns*          inner_sp_ins;
     nanojit::SideExit       exit;
     bool                    deepAborted;
     bool                    applyingArguments;
     bool                    trashTree;
     nanojit::Fragment*      whichTreeToTrash;
     Queue<jsbytecode*>      inlinedLoopEdges;
     Queue<jsbytecode*>      cfgMerges;
+    jsval*                  global_dslots;
 
     bool isGlobal(jsval* p) const;
     ptrdiff_t nativeGlobalOffset(jsval* p) const;
     ptrdiff_t nativeStackOffset(jsval* p) const;
     void import(nanojit::LIns* base, ptrdiff_t offset, jsval* p, uint8& t, 
                 const char *prefix, uintN index, JSStackFrame *fp);
     void import(TreeInfo* treeInfo, nanojit::LIns* sp, unsigned ngslots, unsigned callDepth, 
                 uint8* globalTypeMap, uint8* stackTypeMap);
@@ -279,19 +280,18 @@ class TraceRecorder {
     bool ifop();
     bool switchop();
     bool inc(jsval& v, jsint incr, bool pre = true);
     bool inc(jsval& v, nanojit::LIns*& v_ins, jsint incr, bool pre = true);
     bool incProp(jsint incr, bool pre = true);
     bool incElem(jsint incr, bool pre = true);
     bool incName(jsint incr, bool pre = true);
 
-    enum { CMP_NEGATE = 1, CMP_TRY_BRANCH_AFTER_COND = 2, CMP_CASE = 4 };
+    enum { CMP_NEGATE = 1, CMP_TRY_BRANCH_AFTER_COND = 2, CMP_CASE = 4, CMP_STRICT = 8 };
     bool cmp(nanojit::LOpcode op, int flags = 0);
-    bool equal(int flags = 0);
 
     bool unary(nanojit::LOpcode op);
     bool binary(nanojit::LOpcode op);
 
     bool ibinary(nanojit::LOpcode op);
     bool iunary(nanojit::LOpcode op);
     bool bbinary(nanojit::LOpcode op);
     void demote(jsval& v, jsdouble result);
@@ -322,17 +322,17 @@ class TraceRecorder {
     bool box_jsval(jsval v, nanojit::LIns*& v_ins);
     bool unbox_jsval(jsval v, nanojit::LIns*& v_ins);
     bool guardClass(JSObject* obj, nanojit::LIns* obj_ins, JSClass* clasp);
     bool guardDenseArray(JSObject* obj, nanojit::LIns* obj_ins);
     bool guardDenseArrayIndex(JSObject* obj, jsint idx, nanojit::LIns* obj_ins,
                               nanojit::LIns* dslots_ins, nanojit::LIns* idx_ins);
     void clearFrameSlotsFromCache();
     bool guardShapelessCallee(jsval& callee);
-    bool interpretedFunctionCall(jsval& fval, JSFunction* fun, uintN argc);
+    bool interpretedFunctionCall(jsval& fval, JSFunction* fun, uintN argc, bool constructing);
     bool forInLoop(jsval* vp);
 
     void trackCfgMerges(jsbytecode* pc);
     void fuseIf(jsbytecode* pc, bool cond, nanojit::LIns* x);
 
 public:
     friend bool js_MonitorRecording(TraceRecorder* tr);
 
@@ -395,16 +395,17 @@ public:
 #define TRACE_ARGS(x,args)                                                    \
     JS_BEGIN_MACRO                                                            \
         TraceRecorder* tr_ = TRACE_RECORDER(cx);                              \
         if (tr_)                                                              \
             TRACE_ARGS_(tr_, x, args);                                        \
     JS_END_MACRO
 
 #define RECORD(x)               RECORD_ARGS(x, ())
+#define TRACE_0(x)              TRACE_ARGS(x, ())
 #define TRACE_1(x,a)            TRACE_ARGS(x, (a))
 #define TRACE_2(x,a,b)          TRACE_ARGS(x, (a, b))
 
 extern bool
 js_MonitorLoopEdge(JSContext* cx, jsbytecode* oldpc, uintN& inlineCallCount);
 
 extern bool
 js_MonitorRecording(TraceRecorder *tr);
@@ -419,20 +420,18 @@ js_FinishJIT(JSTraceMonitor *tm);
 js_FinishJIT(JSTraceMonitor *tm);
 
 extern void
 js_FlushJITCache(JSContext* cx);
 
 extern void
 js_FlushJITOracle(JSContext* cx);
 
-extern void
-js_ShutDownJIT();
-
 #else  /* !JS_TRACER */
 
 #define RECORD(x)               ((void)0)
+#define TRACE_0(x)              ((void)0)
 #define TRACE_1(x,a)            ((void)0)
 #define TRACE_2(x,a,b)          ((void)0)
 
 #endif /* !JS_TRACER */
 
 #endif /* jstracer_h___ */
diff -r 9864735a4241 js/src/nanojit/Fragmento.h
--- a/js/src/nanojit/Fragmento.h	Mon Sep 22 11:50:03 2008 -0700
+++ b/js/src/nanojit/Fragmento.h	Fri Sep 26 09:30:25 2008 -0500
@@ -58,17 +58,17 @@ namespace nanojit
     };
     struct Page: public PageHeader
     {
         union {
             LIns lir[(NJ_PAGE_SIZE-sizeof(PageHeader))/sizeof(LIns)];
             NIns code[(NJ_PAGE_SIZE-sizeof(PageHeader))/sizeof(NIns)];
         };
     };
-    struct AllocEntry
+    struct AllocEntry : public GCObject
     {
         Page *page;
         uint32_t allocSize;
     };
 	typedef avmplus::List<AllocEntry*,avmplus::LIST_NonGCObjects>	AllocList;
 
 	typedef avmplus::GCSortedMap<const void*, uint32_t, avmplus::LIST_NonGCObjects> BlockSortedMap;
 	class BlockHist: public BlockSortedMap
diff -r 9864735a4241 js/src/nanojit/LIR.cpp
--- a/js/src/nanojit/LIR.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/js/src/nanojit/LIR.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -30,17 +30,16 @@
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
-
 
 #include "nanojit.h"
 #include <stdio.h>
 
 namespace nanojit
 {
     using namespace avmplus;
 	#ifdef FEATURE_NANOJIT
diff -r 9864735a4241 js/src/nanojit/LIR.h
--- a/js/src/nanojit/LIR.h	Mon Sep 22 11:50:03 2008 -0700
+++ b/js/src/nanojit/LIR.h	Fri Sep 26 09:30:25 2008 -0500
@@ -34,18 +34,27 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef __nanojit_LIR__
 #define __nanojit_LIR__
 
-namespace avmplus { class RegionTracker; }    
+namespace avmplus { class RegionTracker; }
 
+/**
+ * Fundamentally, the arguments to the various operands can be grouped along
+ * two dimensions.  One dimension is size: can the arguments fit into a 32-bit
+ * register, or not?  The other dimension is whether the argument is an integer
+ * (including pointers) or a floating-point value.  In all comments below,
+ * "integer" means integer of any size, including 64-bit, unless otherwise
+ * specified.  All floating-point values are always 64-bit.  Below, "quad" is
+ * used for a 64-bit value that might be either integer or floating-point.
+ */
 namespace nanojit
 {
 	#define is_trace_skip_tramp(op) ((op) <= LIR_tramp)
 	
 	enum LOpcode
 #if defined(_MSC_VER) && _MSC_VER >= 1400
           : unsigned
 #endif
@@ -57,91 +66,104 @@ namespace nanojit
 		LIR_trace = 2,	
 		LIR_nearskip = 3, // must be LIR_skip-1 and lsb=1
 		LIR_skip = 4,
         LIR_neartramp = 5, // must be LIR_tramp-1 and lsb=1
         LIR_tramp = 6,
 
 		// non-pure operations
 		LIR_param	= 10,
-		LIR_st		= 11,
-		LIR_ld		= 12,
+		LIR_st		= 11, // 32-bit store
+		LIR_ld		= 12, // 32-bit load
         LIR_sti     = 14,
-		LIR_call	= 18,
+		LIR_call	= 18, // subrouting call returning a 32-bit value
 			
 		// guards
 		LIR_loop    = 19, // loop fragment
 		LIR_x		= 20, // exit always
 
 		// operators
 
-		LIR_feq		= 26,
-		LIR_flt		= 27,
-		LIR_fgt		= 28,
-		LIR_fle		= 29,
-		LIR_fge		= 30,
-        LIR_cmov    = 31, // conditional move (op1=cond, op2=cond(iftrue,iffalse))
-		LIR_short   = 32,
-		LIR_int		= 33,
+		// LIR_feq though LIR_fge must only be used on float arguments.  They
+		// return integers.
+		LIR_feq		= 26, // floating-point equality [2 float inputs]
+		LIR_flt		= 27, // floating-point less than: arg1 < arg2
+		LIR_fgt		= 28, // floating-point greater than: arg1 > arg2
+		LIR_fle		= 29, // arg1 <= arg2, both floating-point
+		LIR_fge		= 30, // arg1 >= arg2, both floating-point
+
+		LIR_cmov    = 31, // conditional move (op1=cond, op2=cond(iftrue,iffalse))
+		LIR_short   = 32, // constant 16-bit integer
+		LIR_int		= 33, // constant 32-bit integer
 		LIR_ldc     = 34, // non-volatile load
 		LIR_2       = 35, // wraps a pair of refs
-		LIR_neg		= 36,					// [ 1 integer input / integer output ]
-		LIR_add		= 37,					// [ 2 operand integer intputs / integer output ]
-		LIR_sub		= 38,
-		LIR_mul		= 39,
-        LIR_callh   = 40,
+
+		// LIR_neg through LIR_ush are all integer operations
+		LIR_neg		= 36, // numeric negation [ 1 integer input / integer output ]
+		LIR_add		= 37, // integer addition [ 2 operand integer intputs / integer output ]
+		LIR_sub		= 38, // integer subtraction
+		LIR_mul		= 39, // integer multiplication
+		LIR_callh   = 40, 
 		LIR_and		= 41,
 		LIR_or		= 42,
 		LIR_xor		= 43,
 		LIR_not		= 44,
 		LIR_lsh		= 45,
 		LIR_rsh		= 46,	// >>
 		LIR_ush		= 47,	// >>>
-        // conditional guards, op^1 to complement
+
+		// conditional guards, op^1 to complement.  Only things that are
+		// isCond() can be passed to these.
 		LIR_xt		= 48, // exit if true   0x30 0011 0000
 		LIR_xf		= 49, // exit if false  0x31 0011 0001
+
+		// qlo and qhi take a single quad argument and return its low and high
+		// 32 bits respectively as 32-bit integers.
 		LIR_qlo		= 50,
 		LIR_qhi		= 51,
+
 		LIR_ldcb    = 52, // non-volatile 8-bit load
 
         LIR_ov      = 53,
         LIR_cs      = 54,
-        LIR_eq      = 55,
-        // relational operators.  op^1 to swap left/right, op^3 to complement.
+		LIR_eq      = 55, // integer equality
+        // integer (all sizes) relational operators.  op^1 to swap left/right,
+        // op^3 to complement.
 		LIR_lt      = 56, // 0x38 0011 1000
 		LIR_gt      = 57, // 0x39 0011 1001
 		LIR_le		= 58, // 0x3A 0011 1010
 		LIR_ge		= 59, // 0x3B 0011 1011
+		// and the unsigned integer versions
 		LIR_ult		= 60, // 0x3C 0011 1100
 		LIR_ugt		= 61, // 0x3D 0011 1101
 		LIR_ule		= 62, // 0x3E 0011 1110
 		LIR_uge		= 63, // 0x3F 0011 1111
 
 		/**
 		 * 64bit operations
 		 */
-		LIR_stq		= LIR_st | LIR64,
+		LIR_stq		= LIR_st | LIR64, // quad store
 		LIR_stqi	= LIR_sti | LIR64,
-		LIR_quad    = LIR_int | LIR64,
-		LIR_ldq		= LIR_ld    | LIR64,
+		LIR_quad    = LIR_int | LIR64, // quad constant value
+		LIR_ldq		= LIR_ld    | LIR64, // quad load
         LIR_qiand   = 24 | LIR64,
         LIR_qiadd   = 25 | LIR64,
         LIR_qilsh   = LIR_lsh | LIR64,
 
-        LIR_fcall   = LIR_call  | LIR64,
-		LIR_fneg	= LIR_neg  | LIR64,
-		LIR_fadd	= LIR_add  | LIR64,
-		LIR_fsub	= LIR_sub  | LIR64,
-		LIR_fmul	= LIR_mul  | LIR64,
-		LIR_fdiv	= 40        | LIR64,
-		LIR_qcmov	= LIR_cmov | LIR64,
+		LIR_fcall   = LIR_call  | LIR64, // subroutine call returning quad
+		LIR_fneg	= LIR_neg  | LIR64, // floating-point numeric negation
+		LIR_fadd	= LIR_add  | LIR64, // floating-point addition
+		LIR_fsub	= LIR_sub  | LIR64, // floating-point subtraction
+		LIR_fmul	= LIR_mul  | LIR64, // floating-point multiplication
+		LIR_fdiv	= 40        | LIR64, // floating-point division
+		LIR_qcmov	= LIR_cmov | LIR64, 
 
 		LIR_qjoin	= 41 | LIR64,
-		LIR_i2f		= 42 | LIR64,
-		LIR_u2f		= 43 | LIR64,
+		LIR_i2f		= 42 | LIR64, // convert an integer to a float
+		LIR_u2f		= 43 | LIR64, // convert an unsigned integer to a float
         LIR_qior    = 44 | LIR64
 	};
 
 	#if defined NANOJIT_64BIT
 	#define LIR_ldp     LIR_ldq
     #define LIR_piadd   LIR_qiadd
     #define LIR_piand   LIR_qiand
     #define LIR_pilsh   LIR_qilsh
@@ -343,28 +365,38 @@ namespace nanojit
 		bool isop(LOpcode o) const { return u.code == o; }
 		bool isQuad() const;
 		bool isCond() const;
 		bool isCmp() const;
 		bool isCall() const;
         bool isStore() const;
         bool isLoad() const;
 		bool isGuard() const;
+		// True if the instruction is a 32-bit or smaller constant integer.
 		bool isconst() const;
+		// True if the instruction is a 32-bit or smaller constant integer and
+		// has the value val when treated as a 32-bit signed integer.
 		bool isconstval(int32_t val) const;
+		// True if the instruction is a constant quad value.
 		bool isconstq() const;
+		// True if the instruction is a constant pointer value.
 		bool isconstp() const;
         bool isTramp() {
             return isop(LIR_neartramp) || isop(LIR_tramp);
         }
 
+		// Set the imm16 member.  Should only be used on instructions that use
+		// that.  If you're not sure, you shouldn't be calling it.
 		void setimm16(int32_t i);
-		void setimm24(int32_t i);
+		// Set the resv member.  Should only be used on instructions that use
+		// that.  If you're not sure, you shouldn't be calling it.
 		void setresv(uint32_t resv);
+		// Set the opcode
 		void initOpcode(LOpcode);
+		// operand-setting methods
 		void setOprnd1(LIns*);
 		void setOprnd2(LIns*);
 		void setOprnd3(LIns*);
         void setDisp(int8_t d);
 
         SideExit *exit();
 
 		inline uint32_t argc() {
@@ -434,16 +466,17 @@ namespace nanojit
 		virtual LInsp insCall(uint32_t fid, LInsp args[]) {
 			return out->insCall(fid, args);
 		}
 
 		// convenience
 	    LIns*		insLoadi(LIns *base, int disp);
 	    LIns*		insLoad(LOpcode op, LIns *base, int disp);
 	    LIns*		ins_choose(LIns* cond, LIns* iftrue, LIns* iffalse, bool);
+	    // Inserts an integer comparison to 0
 	    LIns*		ins_eq0(LIns* oprnd1);
         LIns*       ins2i(LOpcode op, LIns *oprnd1, int32_t);
 		LIns*		qjoin(LInsp lo, LInsp hi);
 		LIns*		insImmPtr(const void *ptr);
 	};
 
 #ifdef NJ_VERBOSE
 	extern const char* lirNames[];
diff -r 9864735a4241 js/src/nanojit/avmplus.h
--- a/js/src/nanojit/avmplus.h	Mon Sep 22 11:50:03 2008 -0700
+++ b/js/src/nanojit/avmplus.h	Fri Sep 26 09:30:25 2008 -0500
@@ -60,22 +60,22 @@
     );
 #endif /* defined(AVMPLUS_IA32) */
 #endif /* defined(JS_NO_FASTCALL) */
 
 #ifdef WIN32
 #include <windows.h>
 #endif
 
-#ifdef DEBUG
+#if defined(DEBUG) || defined(_MSC_VER) && _MSC_VER < 1400
 #if !defined _DEBUG
 #define _DEBUG
 #endif
-#define NJ_VERBOSE
-#define NJ_PROFILE
+#define NJ_VERBOSE 1
+#define NJ_PROFILE 1
 #include <stdarg.h>
 #endif
 
 #ifdef _DEBUG
 void NanoAssertFail();
 #endif
 
 #define AvmAssert(x) assert(x)
@@ -211,19 +211,27 @@ namespace nanojit
 		uint32_t sid;
 #endif
 	};
 
 	#define GuardRecordSize(g) sizeof(GuardRecord)
     #define SideExitSize(e) sizeof(SideExit)
 }
 
+class GC;
+
 class GCObject 
 {
 public:
+    inline void*
+    operator new(size_t size, GC* gc)
+    {
+        return calloc(1, size);
+    }
+
     static void operator delete (void *gcObject)
     {
         free(gcObject); 
     }
 };
 
 #define MMGC_SUBCLASS_DECL : public GCObject
 
@@ -311,28 +319,16 @@ public:
     
     static inline GCHeap*
     GetGCHeap()
     {
         return &heap;
     }
 };
 
-inline void*
-operator new(size_t size, GC* gc)
-{
-    return calloc(1, size);
-}
-
-inline void
-operator delete(void* p)
-{
-    free(p);
-}
-
 #define DWB(x) x
 #define DRCWB(x) x
 
 #define MMGC_MEM_TYPE(x)
 
 typedef int FunctionID;
 
 namespace avmplus
@@ -340,17 +336,19 @@ namespace avmplus
     struct InterpState
     {
         void* sp; /* native stack pointer, stack[0] is spbase[0] */
         void* rp; /* call stack pointer */
         void* gp; /* global frame pointer */
         JSContext *cx; /* current VM context handle */
         void* eos; /* first unusable word after the native stack */
         void* eor; /* first unusable word after the call stack */
-        nanojit::GuardRecord* nestedExit; /* innermost nested guard for NESTED_EXIT exits */
+        nanojit::GuardRecord* lastTreeExitGuard; /* guard we exited on during a tree call */
+        nanojit::GuardRecord* lastTreeCallGuard; /* guard we want to grow from if the tree
+                                                    call exit guard mismatched */
     };
 
     class String
     {
     };
 
     typedef class String AvmString;
     
@@ -743,17 +741,17 @@ namespace avmplus
      *   put() is O(1) if the key is higher than any existing 
      *         key; O(logN) if the key already exists,
      *         and O(N) otherwise. 
      *   get() is an O(logN) binary search.
      * 
      * no duplicates are allowed.
      */
     template <class K, class T, ListElementType valType>
-    class SortedMap
+    class SortedMap : public GCObject
     {
     public:
         enum { kInitialCapacity= 64 };
         
         SortedMap(GC* gc, int _capacity=kInitialCapacity)
           : keys(gc, _capacity), values(gc, _capacity)
         {
         }
@@ -909,17 +907,17 @@ namespace avmplus
             {
                 capacity = kDefaultCapacity;
                 reset();
             }
             
             ~BitSet()
             {
                 if (capacity > kDefaultCapacity)
-                    delete bits.ptr;
+                    free(bits.ptr);
             }
 
             void reset()
             {
                 if (capacity > kDefaultCapacity)
                     for(int i=0; i<capacity; i++)
                         bits.ptr[i] = 0;
                 else
diff -r 9864735a4241 js/src/rules.mk
--- a/js/src/rules.mk	Mon Sep 22 11:50:03 2008 -0700
+++ b/js/src/rules.mk	Fri Sep 26 09:30:25 2008 -0500
@@ -76,16 +76,20 @@ endif
 $(OBJDIR)/%.o: %.cpp %.h
 	@$(MAKE_OBJDIR)
 	$(CXX) -o $@ -c $(CFLAGS) $*.cpp
 
 $(OBJDIR)/jsinterp.o: jsinterp.cpp jsinterp.h
 	@$(MAKE_OBJDIR)
 	$(CXX) -o $@ -c $(INTERP_CFLAGS) jsinterp.cpp
 
+$(OBJDIR)/jsregexp.o: jsregexp.cpp jsregexp.h
+	@$(MAKE_OBJDIR)
+	$(CXX) -o $@ -c $(REGEXP_CFLAGS) jsregexp.cpp
+
 $(OBJDIR)/jsbuiltins.o: jsbuiltins.cpp jsinterp.h
 	@$(MAKE_OBJDIR)
 	$(CXX) -o $@ -c $(BUILTINS_CFLAGS) jsbuiltins.cpp
 
 $(OBJDIR)/%.o: %.cpp
 	@$(MAKE_OBJDIR)
 	$(CXX) -o $@ -c $(CFLAGS) $*.cpp
 
@@ -96,16 +100,20 @@ endif
 # This rule must come before rule with no dep on header
 $(OBJDIR)/%.obj: %.cpp %.h
 	@$(MAKE_OBJDIR)
 	$(CXX) -Fo$(OBJDIR)/ -c $(CFLAGS) $(JSDLL_CFLAGS) $*.cpp
 
 $(OBJDIR)/jsinterp.obj: jsinterp.cpp jsinterp.h
 	@$(MAKE_OBJDIR)
 	$(CXX) -Fo$(OBJDIR)/ -c $(INTERP_CFLAGS) $(JSDLL_CFLAGS) jsinterp.cpp
+
+$(OBJDIR)/jsregexp.obj: jsregexp.cpp jsregexp.h
+	@$(MAKE_OBJDIR)
+	$(CXX) -Fo$(OBJDIR)/ -c $(REGEXP_CFLAGS) $(JSDLL_CFLAGS) jsregexp.cpp
 
 $(OBJDIR)/jsbuiltins.obj: jsbuiltins.cpp jsinterp.h
 	@$(MAKE_OBJDIR)
 	$(CXX) -Fo$(OBJDIR)/ -c $(BUILTINS_CFLAGS) $(JSDLL_CFLAGS) jsbuiltins.c
 
 $(OBJDIR)/%.obj: %.cpp
 	@$(MAKE_OBJDIR)
 	$(CXX) -Fo$(OBJDIR)/ -c $(CFLAGS) $(JSDLL_CFLAGS) $*.cpp
diff -r 9864735a4241 js/src/trace-test.js
--- a/js/src/trace-test.js	Mon Sep 22 11:50:03 2008 -0700
+++ b/js/src/trace-test.js	Fri Sep 26 09:30:25 2008 -0500
@@ -1,28 +1,104 @@ var testName = null;
+/**
+ * A number of the tests in this file depend on the setting of
+ * HOTLOOP.  Define some constants up front, so they're easy to grep
+ * for.
+ */
+// The HOTLOOP constant we depend on; only readable from our stats
+// object in debug builds.
+const haveTracemonkey = !!(this.tracemonkey)
+const HOTLOOP = haveTracemonkey ? tracemonkey.HOTLOOP : 2;
+// The loop count at which we trace
+const RECORDLOOP = HOTLOOP;
+// The loop count at which we run the trace
+const RUNLOOP = HOTLOOP + 1;
+
 var testName = null;
 if ("arguments" in this && arguments.length > 0)
   testName = arguments[0];
 var fails = [], passes=[];
 
+function jitstatHandler(f)
+{
+    if (!haveTracemonkey) {
+	return;
+    }
+    // XXXbz this is a nasty hack, but I can't figure out a way to
+    // just use jitstats.tbl here
+    f("recorderStarted");
+    f("recorderAborted");
+    f("traceCompleted");
+    f("sideExitIntoInterpreter");
+    f("typeMapMismatchAtEntry");
+    f("returnToDifferentLoopHeader");
+    f("traceTriggered");
+    f("globalShapeMismatchAtEntry");
+    f("treesTrashed");
+    f("slotPromoted");
+    f("unstableLoopVariable");
+    f("breakLoopExits");
+    f("returnLoopExits");
+}
+
 function test(f)
 {
-  if (!testName || testName == f.name)
-    check(f.name, f(), f.expected);
+  if (!testName || testName == f.name) {
+    // Collect our jit stats
+    var localJITstats = {};
+    jitstatHandler(function(prop, local, global) {
+                     localJITstats[prop] = tracemonkey[prop];
+                   });
+    check(f.name, f(), f.expected, localJITstats, f.jitstats);
+  }
 }
 
-function check(desc, actual, expected)
+function check(desc, actual, expected, oldJITstats, expectedJITstats)
 {
   if (expected == actual) {
-    passes.push(desc);
-    return print(desc, ": passed");
+    var pass = true;
+    jitstatHandler(function(prop) {
+                     if (expectedJITstats && prop in expectedJITstats &&
+                         expectedJITstats[prop] !=
+                           tracemonkey[prop] - oldJITstats[prop]) {
+                       pass = false;
+                     }
+                   });
+    if (pass) {
+      passes.push(desc);
+      return print(desc, ": passed");
+    }
   }
   fails.push(desc);
-  print(desc, ": FAILED: expected", typeof(expected), "(", expected, ") != actual",
-	typeof(actual), "(", actual, ")");
+  var expectedStats = "";
+  if (expectedJITstats) {
+      jitstatHandler(function(prop) {
+                       if (prop in expectedJITstats) {
+                         if (expectedStats)
+                           expectedStats += " ";
+                         expectedStats +=
+                           prop + ": " + expectedJITstats[prop];
+                       }
+                     });
+  }
+  var actualStats = "";
+  if (expectedJITstats) {
+      jitstatHandler(function(prop) {
+                       if (prop in expectedJITstats) {
+                         if (actualStats)
+                           actualStats += " ";
+                         actualStats += prop + ": " + (tracemonkey[prop]-oldJITstats[prop]);
+                       }
+                     });
+  }
+  print(desc, ": FAILED: expected", typeof(expected), "(", expected, ")",
+	(expectedStats ? " [" + expectedStats + "] " : ""),
+	"!= actual",
+	typeof(actual), "(", actual, ")",
+	(actualStats ? " [" + actualStats + "] " : ""));
 }
 
 function ifInsideLoop()
 {
   var cond = true, intCond = 5, count = 0;
   for (var i = 0; i < 100; i++) {
     if (cond)
       count++;
@@ -1188,16 +1264,24 @@ function testConstSwitch() {
 function testConstSwitch() {
     var x;
     for (var j=0;j<5;++j) { switch(1.1) { case NaN: case 2: } x = 2; }
     return x;
 }
 testConstSwitch.expected = 2;
 test(testConstSwitch);
 
+function testConstSwitch2() {
+    var x;
+    for (var j = 0; j < 4; ++j) { switch(0/0) { } }
+    return "ok";
+}
+testConstSwitch2.expected = "ok";
+test(testConstSwitch2);
+
 function testConstIf() {
     var x;
     for (var j=0;j<5;++j) { if (1.1 || 5) { } x = 2;}
     return x;
 }
 testConstIf.expected = 2;
 test(testConstIf);
 
@@ -1296,11 +1380,222 @@ function testNativeMax() {
         k = Math.max(0, -0);
     }
     out.push((1 / k) < 0);
     return out.join(",");
 }
 testNativeMax.expected = "NaN,4,false";
 test(testNativeMax);
 
+function testFloatArrayIndex() {
+    var a = [];
+    for (var i = 0; i < 10; ++i) {
+	a[3] = 5;
+	a[3.5] = 7;
+    }
+    return a[3] + "," + a[3.5];
+}
+testFloatArrayIndex.expected = "5,7";
+test(testFloatArrayIndex);
+
+function testStrict() {
+    var n = 10, a = [];
+    for (var i = 0; i < 10; ++i) {
+	a[0] = (n === 10);
+	a[1] = (n !== 10);
+	a[2] = (n === null);
+	a[3] = (n == null);
+    }
+    return a.join(",");
+}
+testStrict.expected = "true,false,false,false";
+test(testStrict);
+
+function testSetPropNeitherMissNorHit() {
+    for (var j = 0; j < 5; ++j) { if (({}).__proto__ = 1) { } }
+    return "ok";
+}
+testSetPropNeitherMissNorHit.expected = "ok";
+test(testSetPropNeitherMissNorHit);
+
+function testPrimitiveConstructorPrototype() {
+    var f = function(){};
+    f.prototype = false;
+    for (let j=0;j<5;++j) { new f; }
+    return "ok";
+}    
+testPrimitiveConstructorPrototype.expected = "ok";
+test(testPrimitiveConstructorPrototype);
+
+function testSideExitInConstructor() {
+    var FCKConfig = {};
+    FCKConfig.CoreStyles =
+	{
+	    'Bold': { },
+	    'Italic': { },
+	    'FontFace': { },
+	    'Size' :
+	    {
+		Overrides: [ ]
+	    },
+
+	    'Color' :
+	    {
+		Element: '',
+		Styles: {  },
+		Overrides: [  ]
+	    },
+	    'BackColor': {
+		Element : '',
+		Styles : { 'background-color' : '' }
+	    },
+	    
+	};
+    var FCKStyle = function(A) {
+	A.Element;
+    };
+    
+    var pass = true;
+    for (var s in FCKConfig.CoreStyles) {
+	var x = new FCKStyle(FCKConfig.CoreStyles[s]);
+	if (!x) pass = false;
+    }
+    return pass;
+}
+testSideExitInConstructor.expected = true;
+test(testSideExitInConstructor);
+
+function testNot() {
+    var a = new Object(), b = null, c = "foo", d = "", e = 5, f = 0, g = 5.5, h = -0, i = true, j = false, k = undefined;
+    var r;
+    for (var i = 0; i < 10; ++i) {
+	r = [!a, !b, !c, !d, !e, !f, !g, !h, !i, !j, !k];
+    }
+    return r.join(",");
+}
+testNot.expected = "false,true,false,true,false,true,false,true,false,true,true";
+test(testNot);
+
+function doTestDifferingArgc(a, b)
+{
+    var k = 0;
+    for (var i = 0; i < 10; i++)
+    {
+        k += i;
+    }
+    return k;
+}
+function testDifferingArgc()
+{
+    var x = 0;
+    x += doTestDifferingArgc(1, 2);
+    x += doTestDifferingArgc(1);
+    x += doTestDifferingArgc(1, 2, 3);
+    return x;
+}
+testDifferingArgc.expected = 45*3;
+test(testDifferingArgc);
+
+function doTestMoreArgcThanNargs()
+{
+    var x = 0;
+    for (var i = 0; i < 10; i++)
+    {
+        x = x + arguments[3];
+    }
+    return x;
+}
+function testMoreArgcThanNargs()
+{
+    return doTestMoreArgcThanNargs(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
+}
+testMoreArgcThanNargs.expected = 4*10;
+test(testMoreArgcThanNargs);
+
+// Test stack reconstruction after a nested exit
+function testNestedExitStackInner(j, counter) {
+  ++counter;
+  var b = 0;
+  for (var i = 1; i <= RUNLOOP; i++) {
+    ++b;
+    var a;
+    // Make sure that once everything has been traced we suddenly switch to
+    // a different control flow the first time we run the outermost tree,
+    // triggering a side exit.
+    if (j < RUNLOOP)
+      a = 1;
+    else
+      a = 0;
+    ++b;
+    b += a;
+  }
+  return counter + b;
+}
+function testNestedExitStackOuter() {
+  var counter = 0;
+  for (var j = 1; j <= RUNLOOP; ++j) {
+    for (var k = 1; k <= RUNLOOP; ++k) {
+      counter = testNestedExitStackInner(j, counter);
+    }
+  }
+  return counter;
+}
+testNestedExitStackOuter.expected = 81;
+testNestedExitStackOuter.jitstats = {
+    recorderStarted: 4,
+    recorderAborted: 0,
+    traceTriggered: 9
+};
+test(testNestedExitStackOuter);
+
+function testHOTLOOPSize() {
+    return HOTLOOP > 1;
+}
+testHOTLOOPSize.expected = true;
+test(testHOTLOOPSize);
+
+function testGlobalProtoAccess() {
+    return "ok";
+}
+this.__proto__.a = 3; for (var j = 0; j < 4; ++j) { [a]; }
+testGlobalProtoAccess.expected = "ok";
+test(testGlobalProtoAccess);
+
+function testMatchStringObject() {
+    var a = new String("foo");
+    var b;
+    for (i = 0; i < 300; i++) {
+	b = a.match(/bar/);
+    }
+    return b;
+}
+testMatchStringObject.expected = null;
+test(testMatchStringObject);
+
+function innerSwitch(k)
+{
+    var m = 0;
+
+    switch (k)
+    {
+    case 0:
+        m = 1;
+        break;
+    }
+
+    return m;
+}
+function testInnerSwitchBreak()
+{
+    var r = new Array(5);
+    for (var i = 0; i < 5; i++)
+    {
+        r[i] = innerSwitch(0);
+    }
+
+    return r.join(",");
+}
+testInnerSwitchBreak.expected = "1,1,1,1,1";
+test(testInnerSwitchBreak);
+
 /* Keep these at the end so that we can see the summary after the trace-debug spew. */
 print("\npassed:", passes.length && passes.join(","));
 print("\nFAILED:", fails.length && fails.join(","));
diff -r 9864735a4241 js/tests/e4x/Namespace/regress-444608-02.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/tests/e4x/Namespace/regress-444608-02.js	Fri Sep 26 09:30:25 2008 -0500
@@ -0,0 +1,55 @@
+/* -*- Mode: java; tab-width:8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is JavaScript Engine testing utilities.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s): Igor Bukanov
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+gTestfile = 'regress-444608-02.js';
+
+var summary = '13.2 Namespaces - call constructors directly';
+var BUGNUMBER = 444608;
+var actual = 'No Crash';
+var expect = 'No Crash';
+
+printBugNumber(BUGNUMBER);
+START(summary);
+
+var x = <xml/>;
+Namespace = function() { return 10; };
+x.removeNamespace("x");
+
+TEST(1, expect, actual);
+
+END();
diff -r 9864735a4241 js/tests/e4x/Namespace/regress-444608.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/tests/e4x/Namespace/regress-444608.js	Fri Sep 26 09:30:25 2008 -0500
@@ -0,0 +1,55 @@
+/* -*- Mode: java; tab-width:8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is JavaScript Engine testing utilities.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s): Igor Bukanov
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+gTestfile = 'regress-444608.js';
+
+var summary = '13.2 Namespaces - call constructors directly';
+var BUGNUMBER = 444608;
+var actual = 'No Crash';
+var expect = 'No Crash';
+
+printBugNumber(BUGNUMBER);
+START(summary);
+
+var x = <xml/>;
+Namespace = function() { return 10; };
+x.addNamespace("x");
+
+TEST(1, expect, actual);
+
+END();
diff -r 9864735a4241 js/tests/e4x/QName/regress-444608.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/tests/e4x/QName/regress-444608.js	Fri Sep 26 09:30:25 2008 -0500
@@ -0,0 +1,56 @@
+/* -*- Mode: java; tab-width:8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is JavaScript Engine testing utilities.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s): Igor Bukanov
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+gTestfile = 'regress-444608.js';
+
+var summary = '13.3 QNames - call constructors directly';
+var BUGNUMBER = 444608;
+var actual = 'No Crash';
+var expect = 'No Crash';
+
+printBugNumber(BUGNUMBER);
+START(summary);
+
+
+var x = <a><b/></a>;
+QName = function() { return 10; };
+x.replace("b", 10);
+
+TEST(1, expect, actual);
+
+END();
diff -r 9864735a4241 js/tests/ecma_3/extensions/regress-430740.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/tests/ecma_3/extensions/regress-430740.js	Fri Sep 26 09:30:25 2008 -0500
@@ -0,0 +1,72 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is JavaScript Engine testing utilities.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s): Dave Reed
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+var gTestfile = 'regress-430740.js';
+//-----------------------------------------------------------------------------
+var BUGNUMBER = 430740;
+var summary = 'Do not strip format-control characters from string literals';
+var actual = '';
+var expect = '';
+
+
+//-----------------------------------------------------------------------------
+test();
+//-----------------------------------------------------------------------------
+
+function test()
+{
+  enterFunc ('test');
+  printBugNumber(BUGNUMBER);
+  printStatus (summary);
+ 
+  function doevil() {
+    print('evildone');
+    return 'evildone';
+  }
+
+  expect = 'a%E2%80%8D,+doevil()%5D)//';
+  actual += eval("(['a\\\u200d', '+doevil()])//'])");
+  actual = encodeURI(actual);
+  reportCompare(expect, actual, summary);
+
+  expect = 'a%EF%BF%BE,+doevil()%5D)//';
+  actual = eval("(['a\\\ufffe', '+doevil()])//'])"); 
+  actual = encodeURI(actual);
+  reportCompare(expect, actual, summary);
+
+  exitFunc ('test');
+}
diff -r 9864735a4241 js/tests/public-failures.txt
--- a/js/tests/public-failures.txt	Mon Sep 22 11:50:03 2008 -0700
+++ b/js/tests/public-failures.txt	Fri Sep 26 09:30:25 2008 -0500
@@ -67,40 +67,40 @@ TEST_ID=e4x/extensions/regress-337226.js
 TEST_ID=e4x/extensions/regress-337226.js, TEST_BRANCH=1.8.1, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=shell, TEST_OS=.*, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=ABNORMAL.*, TEST_DESCRIPTION=`.``*`/e4x/extensions/regress-337226.js:`.``*`: ReferenceError: reference to undefined XML name @mozilla.org/js/function::parseInt
 TEST_ID=e4x/extensions/regress-374025.js, TEST_BRANCH=1.8.1, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=.*, TEST_OS=.*, TEST_KERNEL=.*, TEST_PROCESSORTYPE=intel64, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=ABNORMAL 5, TEST_DESCRIPTION=`.``*`/e4x/extensions/regress-374025.js:`.``*`: out of memory
 TEST_ID=e4x/extensions/regress-374025.js, TEST_BRANCH=1.8.1, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=.*, TEST_OS=darwin, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=CRASHED.*, TEST_DESCRIPTION=
 TEST_ID=e4x/extensions/regress-374025.js, TEST_BRANCH=1.8.1, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=.*, TEST_OS=linux, TEST_KERNEL=.*, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=CRASHED.*, TEST_DESCRIPTION=
 TEST_ID=e4x/extensions/regress-374025.js, TEST_BRANCH=1.8.1, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=.*, TEST_OS=nt, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=ABNORMAL.*, TEST_DESCRIPTION=
 TEST_ID=e4x/extensions/regress-410192.js, TEST_BRANCH=1.8.1, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=.*, TEST_OS=.*, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=Section 1 of test - Proper quoting of attribute by uneval/toSource reason: Expected value '"v"', Actual value 'v'
 TEST_ID=ecma/Math/15.8.2.5.js, TEST_BRANCH=1.8.1, TEST_REPO=.*, TEST_BUILDTYPE=debug, TEST_TYPE=browser, TEST_OS=nt, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=Infinity/Math.atan2(-0, 1) reason: wrong value
 TEST_ID=ecma/Math/15.8.2.5.js, TEST_BRANCH=1.8.1, TEST_REPO=.*, TEST_BUILDTYPE=debug, TEST_TYPE=browser, TEST_OS=nt, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=Infinity/Math.atan2(-1, Infinity) reason: wrong value
-TEST_ID=ecma/Math/15.8.2.6.js, TEST_BRANCH=1.8.1, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=shell, TEST_OS=darwin, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=Infinity/Math.ceil(-0.9) reason: wrong value
-TEST_ID=ecma/Math/15.8.2.6.js, TEST_BRANCH=1.8.1, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=shell, TEST_OS=darwin, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=Infinity/Math.ceil(-Number.MIN_VALUE) reason: wrong value
-TEST_ID=ecma/Math/15.8.2.6.js, TEST_BRANCH=1.9.0, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=shell, TEST_OS=darwin, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=Infinity/Math.ceil(-0.9) reason: wrong value
-TEST_ID=ecma/Math/15.8.2.6.js, TEST_BRANCH=1.9.0, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=shell, TEST_OS=darwin, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=Infinity/Math.ceil(-Number.MIN_VALUE) reason: wrong value
+TEST_ID=ecma/Math/15.8.2.6.js, TEST_BRANCH=1.8.1, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=shell, TEST_OS=darwin, TEST_KERNEL=.*, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=Infinity/Math.ceil(-0.9) reason: wrong value
+TEST_ID=ecma/Math/15.8.2.6.js, TEST_BRANCH=1.8.1, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=shell, TEST_OS=darwin, TEST_KERNEL=.*, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=Infinity/Math.ceil(-Number.MIN_VALUE) reason: wrong value
+TEST_ID=ecma/Math/15.8.2.6.js, TEST_BRANCH=1.9.0, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=shell, TEST_OS=darwin, TEST_KERNEL=.*, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=Infinity/Math.ceil(-0.9) reason: wrong value
+TEST_ID=ecma/Math/15.8.2.6.js, TEST_BRANCH=1.9.0, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=shell, TEST_OS=darwin, TEST_KERNEL=.*, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=Infinity/Math.ceil(-Number.MIN_VALUE) reason: wrong value
 TEST_ID=ecma/Math/15.8.2.6.js, TEST_BRANCH=1.9.1, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=.*, TEST_OS=darwin, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=Infinity/Math.ceil(-0.9) reason: wrong value
 TEST_ID=ecma/Math/15.8.2.6.js, TEST_BRANCH=1.9.1, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=.*, TEST_OS=darwin, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=Infinity/Math.ceil(-Number.MIN_VALUE) reason: wrong value
 TEST_ID=ecma/String/15.5.4.6-2.js, TEST_BRANCH=1.8.1, TEST_REPO=.*, TEST_BUILDTYPE=debug, TEST_TYPE=browser, TEST_OS=.*, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=var f = new Object( String.prototype.indexOf ); f('[object Window @ `.``*` (native @ `.``*`)]') reason: wrong value
 TEST_ID=ecma/TypeConversion/9.2.js, TEST_BRANCH=1.8.1, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=.*, TEST_OS=.*, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=!(0/0) reason: wrong value
 TEST_ID=ecma/TypeConversion/9.2.js, TEST_BRANCH=1.8.1, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=.*, TEST_OS=.*, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=1000 % 0 ? true : false reason: wrong value
 TEST_ID=ecma/TypeConversion/9.3.1-3.js, TEST_BRANCH=.*, TEST_REPO=.*, TEST_BUILDTYPE=debug, TEST_TYPE=browser, TEST_OS=linux, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=-s2 == -Infinity || -s2 == -1.7976931348623157e+308  reason: wrong value
 TEST_ID=ecma/TypeConversion/9.3.1-3.js, TEST_BRANCH=.*, TEST_REPO=.*, TEST_BUILDTYPE=debug, TEST_TYPE=browser, TEST_OS=linux, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=parseInt(s2) == Infinity || parseInt(s2) == 1.7976931348623157e+308 reason: wrong value
 TEST_ID=ecma/TypeConversion/9.3.1-3.js, TEST_BRANCH=.*, TEST_REPO=.*, TEST_BUILDTYPE=debug, TEST_TYPE=browser, TEST_OS=linux, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=parseInt(s2,10) == Infinity || parseInt(s2,10) == 1.7976931348623157e+308 reason: wrong value
 TEST_ID=ecma/TypeConversion/9.3.1-3.js, TEST_BRANCH=1.8.1, TEST_REPO=.*, TEST_BUILDTYPE=debug, TEST_TYPE=.*, TEST_OS=linux, TEST_KERNEL=.*, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=-s2 == -Infinity || -s2 == -1.7976931348623157e+308  reason: wrong value
 TEST_ID=ecma/TypeConversion/9.3.1-3.js, TEST_BRANCH=1.8.1, TEST_REPO=.*, TEST_BUILDTYPE=debug, TEST_TYPE=.*, TEST_OS=linux, TEST_KERNEL=.*, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=parseInt(s2) == Infinity || parseInt(s2) == 1.7976931348623157e+308 reason: wrong value
 TEST_ID=ecma/TypeConversion/9.3.1-3.js, TEST_BRANCH=1.8.1, TEST_REPO=.*, TEST_BUILDTYPE=debug, TEST_TYPE=.*, TEST_OS=linux, TEST_KERNEL=.*, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=parseInt(s2,10) == Infinity || parseInt(s2,10) == 1.7976931348623157e+308 reason: wrong value
-TEST_ID=ecma/TypeConversion/9.3.1-3.js, TEST_BRANCH=1.8.1, TEST_REPO=.*, TEST_BUILDTYPE=opt, TEST_TYPE=shell, TEST_OS=darwin, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=-s2 == -Infinity || -s2 == -1.7976931348623157e+308  reason: wrong value
-TEST_ID=ecma/TypeConversion/9.3.1-3.js, TEST_BRANCH=1.8.1, TEST_REPO=.*, TEST_BUILDTYPE=opt, TEST_TYPE=shell, TEST_OS=darwin, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=parseInt(s2) == Infinity || parseInt(s2) == 1.7976931348623157e+308 reason: wrong value
-TEST_ID=ecma/TypeConversion/9.3.1-3.js, TEST_BRANCH=1.8.1, TEST_REPO=.*, TEST_BUILDTYPE=opt, TEST_TYPE=shell, TEST_OS=darwin, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=parseInt(s2,10) == Infinity || parseInt(s2,10) == 1.7976931348623157e+308 reason: wrong value
-TEST_ID=ecma/TypeConversion/9.3.1-3.js, TEST_BRANCH=1.9.0, TEST_REPO=.*, TEST_BUILDTYPE=debug, TEST_TYPE=.*, TEST_OS=linux, TEST_KERNEL=.*, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=-s2 == -Infinity || -s2 == -1.7976931348623157e+308  reason: wrong value
-TEST_ID=ecma/TypeConversion/9.3.1-3.js, TEST_BRANCH=1.9.0, TEST_REPO=.*, TEST_BUILDTYPE=debug, TEST_TYPE=.*, TEST_OS=linux, TEST_KERNEL=.*, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=parseInt(s2) == Infinity || parseInt(s2) == 1.7976931348623157e+308 reason: wrong value
-TEST_ID=ecma/TypeConversion/9.3.1-3.js, TEST_BRANCH=1.9.0, TEST_REPO=.*, TEST_BUILDTYPE=debug, TEST_TYPE=.*, TEST_OS=linux, TEST_KERNEL=.*, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=parseInt(s2,10) == Infinity || parseInt(s2,10) == 1.7976931348623157e+308 reason: wrong value
-TEST_ID=ecma/TypeConversion/9.3.1-3.js, TEST_BRANCH=1.9.0, TEST_REPO=.*, TEST_BUILDTYPE=opt, TEST_TYPE=shell, TEST_OS=darwin, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=-s2 == -Infinity || -s2 == -1.7976931348623157e+308  reason: wrong value
-TEST_ID=ecma/TypeConversion/9.3.1-3.js, TEST_BRANCH=1.9.0, TEST_REPO=.*, TEST_BUILDTYPE=opt, TEST_TYPE=shell, TEST_OS=darwin, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=parseInt(s2) == Infinity || parseInt(s2) == 1.7976931348623157e+308 reason: wrong value
-TEST_ID=ecma/TypeConversion/9.3.1-3.js, TEST_BRANCH=1.9.0, TEST_REPO=.*, TEST_BUILDTYPE=opt, TEST_TYPE=shell, TEST_OS=darwin, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=parseInt(s2,10) == Infinity || parseInt(s2,10) == 1.7976931348623157e+308 reason: wrong value
+TEST_ID=ecma/TypeConversion/9.3.1-3.js, TEST_BRANCH=1.8.1, TEST_REPO=.*, TEST_BUILDTYPE=opt, TEST_TYPE=shell, TEST_OS=darwin, TEST_KERNEL=.*, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=-s2 == -Infinity || -s2 == -1.7976931348623157e+308  reason: wrong value
+TEST_ID=ecma/TypeConversion/9.3.1-3.js, TEST_BRANCH=1.8.1, TEST_REPO=.*, TEST_BUILDTYPE=opt, TEST_TYPE=shell, TEST_OS=darwin, TEST_KERNEL=.*, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=parseInt(s2) == Infinity || parseInt(s2) == 1.7976931348623157e+308 reason: wrong value
+TEST_ID=ecma/TypeConversion/9.3.1-3.js, TEST_BRANCH=1.8.1, TEST_REPO=.*, TEST_BUILDTYPE=opt, TEST_TYPE=shell, TEST_OS=darwin, TEST_KERNEL=.*, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=parseInt(s2,10) == Infinity || parseInt(s2,10) == 1.7976931348623157e+308 reason: wrong value
+TEST_ID=ecma/TypeConversion/9.3.1-3.js, TEST_BRANCH=1.9.0, TEST_REPO=.*, TEST_BUILDTYPE=debug, TEST_TYPE=.*, TEST_OS=linux, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=-s2 == -Infinity || -s2 == -1.7976931348623157e+308  reason: wrong value
+TEST_ID=ecma/TypeConversion/9.3.1-3.js, TEST_BRANCH=1.9.0, TEST_REPO=.*, TEST_BUILDTYPE=debug, TEST_TYPE=.*, TEST_OS=linux, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=parseInt(s2) == Infinity || parseInt(s2) == 1.7976931348623157e+308 reason: wrong value
+TEST_ID=ecma/TypeConversion/9.3.1-3.js, TEST_BRANCH=1.9.0, TEST_REPO=.*, TEST_BUILDTYPE=debug, TEST_TYPE=.*, TEST_OS=linux, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=parseInt(s2,10) == Infinity || parseInt(s2,10) == 1.7976931348623157e+308 reason: wrong value
+TEST_ID=ecma/TypeConversion/9.3.1-3.js, TEST_BRANCH=1.9.0, TEST_REPO=.*, TEST_BUILDTYPE=opt, TEST_TYPE=shell, TEST_OS=darwin, TEST_KERNEL=.*, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=-s2 == -Infinity || -s2 == -1.7976931348623157e+308  reason: wrong value
+TEST_ID=ecma/TypeConversion/9.3.1-3.js, TEST_BRANCH=1.9.0, TEST_REPO=.*, TEST_BUILDTYPE=opt, TEST_TYPE=shell, TEST_OS=darwin, TEST_KERNEL=.*, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=parseInt(s2) == Infinity || parseInt(s2) == 1.7976931348623157e+308 reason: wrong value
+TEST_ID=ecma/TypeConversion/9.3.1-3.js, TEST_BRANCH=1.9.0, TEST_REPO=.*, TEST_BUILDTYPE=opt, TEST_TYPE=shell, TEST_OS=darwin, TEST_KERNEL=.*, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=parseInt(s2,10) == Infinity || parseInt(s2,10) == 1.7976931348623157e+308 reason: wrong value
 TEST_ID=ecma_3/Array/regress-322135-02.js, TEST_BRANCH=1.8.1, TEST_REPO=.*, TEST_BUILDTYPE=debug, TEST_TYPE=.*, TEST_OS=.*, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=TIMED OUT, TEST_DESCRIPTION=
 TEST_ID=ecma_3/Array/regress-322135-02.js, TEST_BRANCH=1.8.1, TEST_REPO=.*, TEST_BUILDTYPE=opt, TEST_TYPE=.*, TEST_OS=linux, TEST_KERNEL=.*, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=TIMED OUT, TEST_DESCRIPTION=
 TEST_ID=ecma_3/Array/regress-322135-02.js, TEST_BRANCH=1.8.1, TEST_REPO=.*, TEST_BUILDTYPE=opt, TEST_TYPE=browser, TEST_OS=.*, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=TIMED OUT, TEST_DESCRIPTION=
 TEST_ID=ecma_3/Array/regress-322135-03.js, TEST_BRANCH=1.8.1, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=.*, TEST_OS=.*, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=TIMED OUT, TEST_DESCRIPTION=
 TEST_ID=ecma_3/Array/regress-322135-03.js, TEST_BRANCH=1.9.0, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=browser, TEST_OS=.*, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=TIMED OUT, TEST_DESCRIPTION=
 TEST_ID=ecma_3/Array/regress-322135-03.js, TEST_BRANCH=1.9.0, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=shell, TEST_OS=.*, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=ABNORMAL.*, TEST_DESCRIPTION=`.``*`/ecma_3/Array/regress-322135-03.js:`.``*`: out of memory
 TEST_ID=ecma_3/Array/regress-322135-03.js, TEST_BRANCH=1.9.1, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=.*, TEST_OS=.*, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=ABNORMAL.*, TEST_DESCRIPTION=`.``*`/ecma_3/Array/regress-322135-03.js:`.``*`: out of memory
 TEST_ID=ecma_3/Array/regress-322135-04.js, TEST_BRANCH=1.8.1, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=.*, TEST_OS=.*, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=TIMED OUT, TEST_DESCRIPTION=
diff -r 9864735a4241 js/tests/spidermonkey-n-1.9.1.tests
--- a/js/tests/spidermonkey-n-1.9.1.tests	Mon Sep 22 11:50:03 2008 -0700
+++ b/js/tests/spidermonkey-n-1.9.1.tests	Fri Sep 26 09:30:25 2008 -0500
@@ -99,8 +99,10 @@ js1_5/extensions/regress-418730.js
 js1_5/extensions/regress-418730.js
 js1_5/GetSet/regress-353264.js
 js1_5/Regress/regress-249211.js
 js1_5/Regress/regress-350692.js
 js1_5/Regress/regress-354924.js
 js1_5/Regress/regress-362583.js
 js1_7/extensions/regress-353214-01.js
 js1_7/lexical/regress-346642-03.js
+# bug 450275
+js1_5/extensions/regress-434837-01.js
diff -r 9864735a4241 js/tests/universe.data
--- a/js/tests/universe.data	Mon Sep 22 11:50:03 2008 -0700
+++ b/js/tests/universe.data	Fri Sep 26 09:30:25 2008 -0500
@@ -1,8 +1,14 @@ TEST_OS=darwin, TEST_KERNEL=8.11.0, TEST
+TEST_OS=darwin, TEST_KERNEL=8.11.0, TEST_PROCESSORTYPE=powerpc32, TEST_MEMORY=1, TEST_CPUSPEED=slow, TEST_TIMEZONE=-0400, TEST_BRANCH=1.8.1, TEST_REPO=CVS, TEST_BUILDTYPE=debug, TEST_TYPE=shell
+TEST_OS=darwin, TEST_KERNEL=8.11.0, TEST_PROCESSORTYPE=powerpc32, TEST_MEMORY=1, TEST_CPUSPEED=slow, TEST_TIMEZONE=-0400, TEST_BRANCH=1.8.1, TEST_REPO=CVS, TEST_BUILDTYPE=opt, TEST_TYPE=shell
+TEST_OS=darwin, TEST_KERNEL=8.11.0, TEST_PROCESSORTYPE=powerpc32, TEST_MEMORY=1, TEST_CPUSPEED=slow, TEST_TIMEZONE=-0400, TEST_BRANCH=1.9.0, TEST_REPO=CVS, TEST_BUILDTYPE=debug, TEST_TYPE=shell
+TEST_OS=darwin, TEST_KERNEL=8.11.0, TEST_PROCESSORTYPE=powerpc32, TEST_MEMORY=1, TEST_CPUSPEED=slow, TEST_TIMEZONE=-0400, TEST_BRANCH=1.9.0, TEST_REPO=CVS, TEST_BUILDTYPE=opt, TEST_TYPE=shell
+TEST_OS=darwin, TEST_KERNEL=8.11.0, TEST_PROCESSORTYPE=powerpc32, TEST_MEMORY=1, TEST_CPUSPEED=slow, TEST_TIMEZONE=-0400, TEST_BRANCH=1.9.1, TEST_REPO=mozilla-central, TEST_BUILDTYPE=debug, TEST_TYPE=shell
+TEST_OS=darwin, TEST_KERNEL=8.11.0, TEST_PROCESSORTYPE=powerpc32, TEST_MEMORY=1, TEST_CPUSPEED=slow, TEST_TIMEZONE=-0400, TEST_BRANCH=1.9.1, TEST_REPO=mozilla-central, TEST_BUILDTYPE=opt, TEST_TYPE=shell
 TEST_OS=darwin, TEST_KERNEL=8.11.0, TEST_PROCESSORTYPE=powerpc32, TEST_MEMORY=4, TEST_CPUSPEED=slow, TEST_TIMEZONE=-0700, TEST_BRANCH=1.8.1, TEST_REPO=CVS, TEST_BUILDTYPE=debug, TEST_TYPE=browser
 TEST_OS=darwin, TEST_KERNEL=8.11.0, TEST_PROCESSORTYPE=powerpc32, TEST_MEMORY=4, TEST_CPUSPEED=slow, TEST_TIMEZONE=-0700, TEST_BRANCH=1.8.1, TEST_REPO=CVS, TEST_BUILDTYPE=debug, TEST_TYPE=shell
 TEST_OS=darwin, TEST_KERNEL=8.11.0, TEST_PROCESSORTYPE=powerpc32, TEST_MEMORY=4, TEST_CPUSPEED=slow, TEST_TIMEZONE=-0700, TEST_BRANCH=1.8.1, TEST_REPO=CVS, TEST_BUILDTYPE=opt, TEST_TYPE=browser
 TEST_OS=darwin, TEST_KERNEL=8.11.0, TEST_PROCESSORTYPE=powerpc32, TEST_MEMORY=4, TEST_CPUSPEED=slow, TEST_TIMEZONE=-0700, TEST_BRANCH=1.8.1, TEST_REPO=CVS, TEST_BUILDTYPE=opt, TEST_TYPE=shell
 TEST_OS=darwin, TEST_KERNEL=8.11.0, TEST_PROCESSORTYPE=powerpc32, TEST_MEMORY=4, TEST_CPUSPEED=slow, TEST_TIMEZONE=-0700, TEST_BRANCH=1.9.0, TEST_REPO=CVS, TEST_BUILDTYPE=debug, TEST_TYPE=browser
 TEST_OS=darwin, TEST_KERNEL=8.11.0, TEST_PROCESSORTYPE=powerpc32, TEST_MEMORY=4, TEST_CPUSPEED=slow, TEST_TIMEZONE=-0700, TEST_BRANCH=1.9.0, TEST_REPO=CVS, TEST_BUILDTYPE=debug, TEST_TYPE=shell
 TEST_OS=darwin, TEST_KERNEL=8.11.0, TEST_PROCESSORTYPE=powerpc32, TEST_MEMORY=4, TEST_CPUSPEED=slow, TEST_TIMEZONE=-0700, TEST_BRANCH=1.9.0, TEST_REPO=CVS, TEST_BUILDTYPE=opt, TEST_TYPE=browser
 TEST_OS=darwin, TEST_KERNEL=8.11.0, TEST_PROCESSORTYPE=powerpc32, TEST_MEMORY=4, TEST_CPUSPEED=slow, TEST_TIMEZONE=-0700, TEST_BRANCH=1.9.0, TEST_REPO=CVS, TEST_BUILDTYPE=opt, TEST_TYPE=shell
@@ -17,27 +23,40 @@ TEST_OS=darwin, TEST_KERNEL=9.5.0, TEST_
 TEST_OS=darwin, TEST_KERNEL=9.5.0, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=4, TEST_CPUSPEED=medium, TEST_TIMEZONE=-0700, TEST_BRANCH=1.9.1, TEST_REPO=mozilla-central, TEST_BUILDTYPE=debug, TEST_TYPE=browser
 TEST_OS=darwin, TEST_KERNEL=9.5.0, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=4, TEST_CPUSPEED=medium, TEST_TIMEZONE=-0700, TEST_BRANCH=1.9.1, TEST_REPO=mozilla-central, TEST_BUILDTYPE=debug, TEST_TYPE=shell
 TEST_OS=darwin, TEST_KERNEL=9.5.0, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=4, TEST_CPUSPEED=medium, TEST_TIMEZONE=-0700, TEST_BRANCH=1.9.1, TEST_REPO=mozilla-central, TEST_BUILDTYPE=opt, TEST_TYPE=browser
 TEST_OS=darwin, TEST_KERNEL=9.5.0, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=4, TEST_CPUSPEED=medium, TEST_TIMEZONE=-0700, TEST_BRANCH=1.9.1, TEST_REPO=mozilla-central, TEST_BUILDTYPE=opt, TEST_TYPE=shell
 TEST_OS=linux, TEST_KERNEL=2.6.18, TEST_PROCESSORTYPE=amd32, TEST_MEMORY=4, TEST_CPUSPEED=slow, TEST_TIMEZONE=-0700, TEST_BRANCH=1.9.0, TEST_REPO=CVS, TEST_BUILDTYPE=debug, TEST_TYPE=browser
 TEST_OS=linux, TEST_KERNEL=2.6.18, TEST_PROCESSORTYPE=amd32, TEST_MEMORY=4, TEST_CPUSPEED=slow, TEST_TIMEZONE=-0700, TEST_BRANCH=1.9.0, TEST_REPO=CVS, TEST_BUILDTYPE=debug, TEST_TYPE=shell
 TEST_OS=linux, TEST_KERNEL=2.6.18, TEST_PROCESSORTYPE=amd32, TEST_MEMORY=4, TEST_CPUSPEED=slow, TEST_TIMEZONE=-0700, TEST_BRANCH=1.9.0, TEST_REPO=CVS, TEST_BUILDTYPE=opt, TEST_TYPE=browser
 TEST_OS=linux, TEST_KERNEL=2.6.18, TEST_PROCESSORTYPE=amd32, TEST_MEMORY=4, TEST_CPUSPEED=slow, TEST_TIMEZONE=-0700, TEST_BRANCH=1.9.0, TEST_REPO=CVS, TEST_BUILDTYPE=opt, TEST_TYPE=shell
+TEST_OS=linux, TEST_KERNEL=2.6.18, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=4, TEST_CPUSPEED=medium, TEST_TIMEZONE=-0700, TEST_BRANCH=1.8.1, TEST_REPO=CVS, TEST_BUILDTYPE=debug, TEST_TYPE=shell
+TEST_OS=linux, TEST_KERNEL=2.6.18, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=4, TEST_CPUSPEED=medium, TEST_TIMEZONE=-0700, TEST_BRANCH=1.8.1, TEST_REPO=CVS, TEST_BUILDTYPE=opt, TEST_TYPE=browser
+TEST_OS=linux, TEST_KERNEL=2.6.18, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=4, TEST_CPUSPEED=medium, TEST_TIMEZONE=-0700, TEST_BRANCH=1.8.1, TEST_REPO=CVS, TEST_BUILDTYPE=opt, TEST_TYPE=shell
 TEST_OS=linux, TEST_KERNEL=2.6.18, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=4, TEST_CPUSPEED=medium, TEST_TIMEZONE=-0700, TEST_BRANCH=1.9.0, TEST_REPO=CVS, TEST_BUILDTYPE=debug, TEST_TYPE=shell
 TEST_OS=linux, TEST_KERNEL=2.6.18, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=4, TEST_CPUSPEED=medium, TEST_TIMEZONE=-0700, TEST_BRANCH=1.9.0, TEST_REPO=CVS, TEST_BUILDTYPE=opt, TEST_TYPE=shell
+TEST_OS=linux, TEST_KERNEL=2.6.18, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=4, TEST_CPUSPEED=medium, TEST_TIMEZONE=-0700, TEST_BRANCH=1.9.1, TEST_REPO=mozilla-central, TEST_BUILDTYPE=debug, TEST_TYPE=browser
+TEST_OS=linux, TEST_KERNEL=2.6.18, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=4, TEST_CPUSPEED=medium, TEST_TIMEZONE=-0700, TEST_BRANCH=1.9.1, TEST_REPO=mozilla-central, TEST_BUILDTYPE=debug, TEST_TYPE=shell
+TEST_OS=linux, TEST_KERNEL=2.6.18, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=4, TEST_CPUSPEED=medium, TEST_TIMEZONE=-0700, TEST_BRANCH=1.9.1, TEST_REPO=mozilla-central, TEST_BUILDTYPE=opt, TEST_TYPE=browser
+TEST_OS=linux, TEST_KERNEL=2.6.18, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=4, TEST_CPUSPEED=medium, TEST_TIMEZONE=-0700, TEST_BRANCH=1.9.1, TEST_REPO=mozilla-central, TEST_BUILDTYPE=opt, TEST_TYPE=shell
 TEST_OS=linux, TEST_KERNEL=2.6.18, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=4, TEST_CPUSPEED=medium, TEST_TIMEZONE=-0700, TEST_BRANCH=1.9.1, TEST_REPO=tracemonkey, TEST_BUILDTYPE=debug, TEST_TYPE=shell
 TEST_OS=linux, TEST_KERNEL=2.6.18, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=4, TEST_CPUSPEED=medium, TEST_TIMEZONE=-0700, TEST_BRANCH=1.9.1, TEST_REPO=tracemonkey, TEST_BUILDTYPE=opt, TEST_TYPE=shell
 TEST_OS=linux, TEST_KERNEL=2.6.18, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=4, TEST_CPUSPEED=slow, TEST_TIMEZONE=-0700, TEST_BRANCH=1.8.1, TEST_REPO=CVS, TEST_BUILDTYPE=debug, TEST_TYPE=shell
+TEST_OS=linux, TEST_KERNEL=2.6.18, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=4, TEST_CPUSPEED=slow, TEST_TIMEZONE=-0700, TEST_BRANCH=1.8.1, TEST_REPO=CVS, TEST_BUILDTYPE=opt, TEST_TYPE=browser
 TEST_OS=linux, TEST_KERNEL=2.6.18, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=4, TEST_CPUSPEED=slow, TEST_TIMEZONE=-0700, TEST_BRANCH=1.8.1, TEST_REPO=CVS, TEST_BUILDTYPE=opt, TEST_TYPE=shell
+TEST_OS=linux, TEST_KERNEL=2.6.18, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=4, TEST_CPUSPEED=slow, TEST_TIMEZONE=-0700, TEST_BRANCH=1.9.0, TEST_REPO=CVS, TEST_BUILDTYPE=debug, TEST_TYPE=browser
 TEST_OS=linux, TEST_KERNEL=2.6.18, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=4, TEST_CPUSPEED=slow, TEST_TIMEZONE=-0700, TEST_BRANCH=1.9.0, TEST_REPO=CVS, TEST_BUILDTYPE=debug, TEST_TYPE=shell
+TEST_OS=linux, TEST_KERNEL=2.6.18, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=4, TEST_CPUSPEED=slow, TEST_TIMEZONE=-0700, TEST_BRANCH=1.9.0, TEST_REPO=CVS, TEST_BUILDTYPE=opt, TEST_TYPE=browser
 TEST_OS=linux, TEST_KERNEL=2.6.18, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=4, TEST_CPUSPEED=slow, TEST_TIMEZONE=-0700, TEST_BRANCH=1.9.0, TEST_REPO=CVS, TEST_BUILDTYPE=opt, TEST_TYPE=shell
+TEST_OS=linux, TEST_KERNEL=2.6.18, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=4, TEST_CPUSPEED=slow, TEST_TIMEZONE=-0700, TEST_BRANCH=1.9.1, TEST_REPO=mozilla-central, TEST_BUILDTYPE=debug, TEST_TYPE=browser
 TEST_OS=linux, TEST_KERNEL=2.6.18, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=4, TEST_CPUSPEED=slow, TEST_TIMEZONE=-0700, TEST_BRANCH=1.9.1, TEST_REPO=mozilla-central, TEST_BUILDTYPE=debug, TEST_TYPE=shell
+TEST_OS=linux, TEST_KERNEL=2.6.18, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=4, TEST_CPUSPEED=slow, TEST_TIMEZONE=-0700, TEST_BRANCH=1.9.1, TEST_REPO=mozilla-central, TEST_BUILDTYPE=opt, TEST_TYPE=browser
 TEST_OS=linux, TEST_KERNEL=2.6.18, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=4, TEST_CPUSPEED=slow, TEST_TIMEZONE=-0700, TEST_BRANCH=1.9.1, TEST_REPO=mozilla-central, TEST_BUILDTYPE=opt, TEST_TYPE=shell
 TEST_OS=linux, TEST_KERNEL=2.6.18, TEST_PROCESSORTYPE=intel64, TEST_MEMORY=4, TEST_CPUSPEED=fast, TEST_TIMEZONE=-0700, TEST_BRANCH=1.8.1, TEST_REPO=CVS, TEST_BUILDTYPE=debug, TEST_TYPE=shell
+TEST_OS=linux, TEST_KERNEL=2.6.18, TEST_PROCESSORTYPE=intel64, TEST_MEMORY=4, TEST_CPUSPEED=fast, TEST_TIMEZONE=-0700, TEST_BRANCH=1.8.1, TEST_REPO=CVS, TEST_BUILDTYPE=opt, TEST_TYPE=browser
 TEST_OS=linux, TEST_KERNEL=2.6.18, TEST_PROCESSORTYPE=intel64, TEST_MEMORY=4, TEST_CPUSPEED=fast, TEST_TIMEZONE=-0700, TEST_BRANCH=1.8.1, TEST_REPO=CVS, TEST_BUILDTYPE=opt, TEST_TYPE=shell
 TEST_OS=linux, TEST_KERNEL=2.6.18, TEST_PROCESSORTYPE=intel64, TEST_MEMORY=4, TEST_CPUSPEED=fast, TEST_TIMEZONE=-0700, TEST_BRANCH=1.9.0, TEST_REPO=CVS, TEST_BUILDTYPE=debug, TEST_TYPE=shell
 TEST_OS=linux, TEST_KERNEL=2.6.18, TEST_PROCESSORTYPE=intel64, TEST_MEMORY=4, TEST_CPUSPEED=fast, TEST_TIMEZONE=-0700, TEST_BRANCH=1.9.0, TEST_REPO=CVS, TEST_BUILDTYPE=opt, TEST_TYPE=shell
 TEST_OS=linux, TEST_KERNEL=2.6.18, TEST_PROCESSORTYPE=intel64, TEST_MEMORY=4, TEST_CPUSPEED=fast, TEST_TIMEZONE=-0700, TEST_BRANCH=1.9.1, TEST_REPO=mozilla-central, TEST_BUILDTYPE=debug, TEST_TYPE=shell
 TEST_OS=linux, TEST_KERNEL=2.6.18, TEST_PROCESSORTYPE=intel64, TEST_MEMORY=4, TEST_CPUSPEED=fast, TEST_TIMEZONE=-0700, TEST_BRANCH=1.9.1, TEST_REPO=mozilla-central, TEST_BUILDTYPE=opt, TEST_TYPE=shell
 TEST_OS=nt, TEST_KERNEL=5.1, TEST_PROCESSORTYPE=amd32, TEST_MEMORY=2, TEST_CPUSPEED=medium, TEST_TIMEZONE=-0700, TEST_BRANCH=1.8.1, TEST_REPO=CVS, TEST_BUILDTYPE=debug, TEST_TYPE=browser
 TEST_OS=nt, TEST_KERNEL=5.1, TEST_PROCESSORTYPE=amd32, TEST_MEMORY=2, TEST_CPUSPEED=medium, TEST_TIMEZONE=-0700, TEST_BRANCH=1.8.1, TEST_REPO=CVS, TEST_BUILDTYPE=debug, TEST_TYPE=shell
 TEST_OS=nt, TEST_KERNEL=5.1, TEST_PROCESSORTYPE=amd32, TEST_MEMORY=2, TEST_CPUSPEED=medium, TEST_TIMEZONE=-0700, TEST_BRANCH=1.8.1, TEST_REPO=CVS, TEST_BUILDTYPE=opt, TEST_TYPE=browser
diff -r 9864735a4241 layout/base/nsCSSRendering.cpp
--- a/layout/base/nsCSSRendering.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/layout/base/nsCSSRendering.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -1253,26 +1253,26 @@ nsCSSRendering::PaintBoxShadow(nsPresCon
 }
 
 void
 nsCSSRendering::PaintBackground(nsPresContext* aPresContext,
                                 nsIRenderingContext& aRenderingContext,
                                 nsIFrame* aForFrame,
                                 const nsRect& aDirtyRect,
                                 const nsRect& aBorderArea,
-                                const nsStyleBorder& aBorder,
-                                const nsStylePadding& aPadding,
                                 PRBool aUsePrintSettings,
                                 nsRect* aBGClipRect)
 {
   NS_PRECONDITION(aForFrame,
                   "Frame is expected to be provided to PaintBackground");
 
   PRBool isCanvas;
   const nsStyleBackground *color;
+  const nsStylePadding* padding = aForFrame->GetStylePadding();
+  const nsStyleBorder* border = aForFrame->GetStyleBorder();
 
   if (!FindBackground(aPresContext, aForFrame, &color, &isCanvas)) {
     // we don't want to bail out of moz-appearance is set on a root
     // node. If it has a parent content node, bail because it's not
     // a root, other wise keep going in order to let the theme stuff
     // draw the background. The canvas really should be drawing the
     // bg, but there's no way to hook that up via css.
     if (!aForFrame->GetStyleDisplay()->mAppearance) {
@@ -1283,18 +1283,18 @@ nsCSSRendering::PaintBackground(nsPresCo
     if (!content || content->GetParent()) {
       return;
     }
         
     color = aForFrame->GetStyleBackground();
   }
   if (!isCanvas) {
     PaintBackgroundWithSC(aPresContext, aRenderingContext, aForFrame,
-                          aDirtyRect, aBorderArea, *color, aBorder,
-                          aPadding, aUsePrintSettings, aBGClipRect);
+                          aDirtyRect, aBorderArea, *color, *border,
+                          *padding, aUsePrintSettings, aBGClipRect);
     return;
   }
 
   nsStyleBackground canvasColor(*color);
 
   nsIViewManager* vm = aPresContext->GetViewManager();
 
   if (NS_GET_A(canvasColor.mBackgroundColor) < 255) {
@@ -1314,17 +1314,17 @@ nsCSSRendering::PaintBackground(nsPresCo
         NS_ComposeColors(backColor, canvasColor.mBackgroundColor);
     }
   }
 
   vm->SetDefaultBackgroundColor(canvasColor.mBackgroundColor);
 
   PaintBackgroundWithSC(aPresContext, aRenderingContext, aForFrame,
                         aDirtyRect, aBorderArea, canvasColor,
-                        aBorder, aPadding, aUsePrintSettings, aBGClipRect);
+                        *border, *padding, aUsePrintSettings, aBGClipRect);
 }
 
 inline nscoord IntDivFloor(nscoord aDividend, nscoord aDivisor)
 {
   NS_PRECONDITION(aDivisor > 0,
                   "this function only works for positive divisors");
   // ANSI C, ISO 9899:1999 section 6.5.5 defines integer division as
   // truncation of the result towards zero.  Earlier C standards, as
diff -r 9864735a4241 layout/base/nsCSSRendering.h
--- a/layout/base/nsCSSRendering.h	Mon Sep 22 11:50:03 2008 -0700
+++ b/layout/base/nsCSSRendering.h	Fri Sep 26 09:30:25 2008 -0500
@@ -139,24 +139,22 @@ public:
    * Both aDirtyRect and aBorderArea are in the local coordinate space
    * of aForFrame
    */
   static void PaintBackground(nsPresContext* aPresContext,
                               nsIRenderingContext& aRenderingContext,
                               nsIFrame* aForFrame,
                               const nsRect& aDirtyRect,
                               const nsRect& aBorderArea,
-                              const nsStyleBorder& aBorder,
-                              const nsStylePadding& aPadding,
                               PRBool aUsePrintSettings,
                               nsRect* aBGClipRect = nsnull);
 
   /**
-   * Same as |PaintBackground|, except using the provided style context
-   * (which short-circuits the code that ensures that the root element's
+   * Same as |PaintBackground|, except using the provided style structs.
+   * This short-circuits the code that ensures that the root element's
    * background is drawn on the canvas.
    */
   static void PaintBackgroundWithSC(nsPresContext* aPresContext,
                                     nsIRenderingContext& aRenderingContext,
                                     nsIFrame* aForFrame,
                                     const nsRect& aDirtyRect,
                                     const nsRect& aBorderArea,
                                     const nsStyleBackground& aColor,
diff -r 9864735a4241 layout/base/nsDisplayList.cpp
--- a/layout/base/nsDisplayList.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/layout/base/nsDisplayList.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -550,18 +550,16 @@ nsDisplayBackground::IsVaryingRelativeTo
 }
 
 void
 nsDisplayBackground::Paint(nsDisplayListBuilder* aBuilder,
      nsIRenderingContext* aCtx, const nsRect& aDirtyRect) {
   nsPoint offset = aBuilder->ToReferenceFrame(mFrame);
   nsCSSRendering::PaintBackground(mFrame->PresContext(), *aCtx, mFrame,
                                   aDirtyRect, nsRect(offset, mFrame->GetSize()),
-                                  *mFrame->GetStyleBorder(),
-                                  *mFrame->GetStylePadding(),
                                   mFrame->HonorPrintBackgroundSettings());
 }
 
 nsRect
 nsDisplayBackground::GetBounds(nsDisplayListBuilder* aBuilder) {
   if (mIsThemed)
     return mFrame->GetOverflowRect() + aBuilder->ToReferenceFrame(mFrame);
 
@@ -1085,42 +1083,34 @@ nsDisplayTransform::GetResultingTransfor
 
 /* Painting applies the transform, paints the sublist, then unapplies
  * the transform.
  */
 void nsDisplayTransform::Paint(nsDisplayListBuilder *aBuilder,
                                nsIRenderingContext *aCtx,
                                const nsRect &aDirtyRect)
 {
-  /* Here's how this is going to work:
-   * 1. Convert the stored transform matrix into a gfxMatrix
-   * 2. Read out the old graphics matrix.
-   * 3. Compute the net graphics matrix at this point.
-   * 4. Set that as the active matrix.
-   * 5. Apply the inverse transform to the dirty rect so that children think
-   *    they're drawing in local space.
-   * 6. Render everything.
-   * 7. Reset the matrix.
+  /* Get the local transform matrix with which we'll transform all wrapped
+   * elements.  If this matrix is singular, we shouldn't display anything
+   * and can abort.
    */
+  gfxMatrix newTransformMatrix =
+    GetResultingTransformMatrix(mFrame, aBuilder->ToReferenceFrame(mFrame),
+                                 mFrame->PresContext()->AppUnitsPerDevPixel(),
+                                nsnull);
+  if (newTransformMatrix.IsSingular())
+    return;
+
   /* Get the context and automatically save and restore it. */
   gfxContext* gfx = aCtx->ThebesContext();
   gfxContextAutoSaveRestore autoRestorer(gfx);
 
-  /* Unit conversion is based on the local presentation context. */
-  float factor = mFrame->PresContext()->AppUnitsPerDevPixel();
-
-  /* Compute the new matrix by taking the old matrix and multiplying the
-   * transform matrix of this frame only.  The new transform is prepended to
-   * the old transform, since that way, if we have several stacked transforms,
-   * the innermost transform is applied first.
+  /* Get the new CTM by applying this transform after all of the
+   * transforms preceding it.
    */
-  gfxMatrix newTransformMatrix =
-    GetResultingTransformMatrix(mFrame, aBuilder->ToReferenceFrame(mFrame),
-                                factor, nsnull);
-
   newTransformMatrix.Multiply(gfx->CurrentMatrix());
 
   /* Set the matrix for the transform based on the old matrix and the new
    * transform data.
    */
   gfx->SetMatrix(newTransformMatrix);
 
   /* Now, send the paint call down.  As we do this, we need to be sure to
diff -r 9864735a4241 layout/forms/nsButtonFrameRenderer.cpp
--- a/layout/forms/nsButtonFrameRenderer.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/layout/forms/nsButtonFrameRenderer.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -218,21 +218,19 @@ nsButtonFrameRenderer::PaintBorderAndBac
 {
   // get the button rect this is inside the focus and outline rects
   nsRect buttonRect;
   GetButtonRect(aRect, buttonRect);
 
   nsStyleContext* context = mFrame->GetStyleContext();
 
   const nsStyleBorder* border = context->GetStyleBorder();
-  const nsStylePadding* padding = context->GetStylePadding();
 
   nsCSSRendering::PaintBackground(aPresContext, aRenderingContext, mFrame,
-                                  aDirtyRect, buttonRect, *border, *padding,
-                                  PR_FALSE);
+                                  aDirtyRect, buttonRect, PR_FALSE);
   nsCSSRendering::PaintBorder(aPresContext, aRenderingContext, mFrame,
                               aDirtyRect, buttonRect, *border, context);
 }
 
 
 void
 nsButtonFrameRenderer::GetButtonOuterFocusRect(const nsRect& aRect, nsRect& focusRect)
 {
diff -r 9864735a4241 layout/forms/nsFieldSetFrame.cpp
--- a/layout/forms/nsFieldSetFrame.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/layout/forms/nsFieldSetFrame.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -255,32 +255,30 @@ nsFieldSetFrame::BuildDisplayList(nsDisp
 }
 
 void
 nsFieldSetFrame::PaintBorderBackground(nsIRenderingContext& aRenderingContext,
     nsPoint aPt, const nsRect& aDirtyRect)
 {
   PRIntn skipSides = GetSkipSides();
   const nsStyleBorder* borderStyle = GetStyleBorder();
-  const nsStylePadding* paddingStyle = GetStylePadding();
        
   nscoord topBorder = borderStyle->GetActualBorderWidth(NS_SIDE_TOP);
   nscoord yoff = 0;
   nsPresContext* presContext = PresContext();
      
   // if the border is smaller than the legend. Move the border down
   // to be centered on the legend. 
   if (topBorder < mLegendRect.height)
     yoff = (mLegendRect.height - topBorder)/2;
       
   nsRect rect(aPt.x, aPt.y + yoff, mRect.width, mRect.height - yoff);
 
   nsCSSRendering::PaintBackground(presContext, aRenderingContext, this,
-                                  aDirtyRect, rect, *borderStyle,
-                                  *paddingStyle, PR_TRUE);
+                                  aDirtyRect, rect, PR_TRUE);
 
    if (mLegendFrame) {
 
     // Use the rect of the legend frame, not mLegendRect, so we draw our
     // border under the legend's left and right margins.
     nsRect legendRect = mLegendFrame->GetRect() + aPt;
     
     // we should probably use PaintBorderEdges to do this but for now just use clipping
diff -r 9864735a4241 layout/generic/nsHTMLFrame.cpp
--- a/layout/generic/nsHTMLFrame.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/layout/generic/nsHTMLFrame.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -435,21 +435,21 @@ public:
   }
 
   virtual void Paint(nsDisplayListBuilder* aBuilder,
                      nsIRenderingContext* aCtx, const nsRect& aDirtyRect)
   {
     CanvasFrame* frame = static_cast<CanvasFrame*>(mFrame);
     nsPoint offset = aBuilder->ToReferenceFrame(mFrame);
     nsRect bgClipRect = frame->CanvasArea() + offset;
+    // XXXzw This is the only use of the bgClipRect argument.  Does this
+    // path need the propagation-of-root-background-to-viewport logic?
     nsCSSRendering::PaintBackground(mFrame->PresContext(), *aCtx, mFrame,
                                     aDirtyRect,
                                     nsRect(offset, mFrame->GetSize()),
-                                    *mFrame->GetStyleBorder(),
-                                    *mFrame->GetStylePadding(),
                                     mFrame->HonorPrintBackgroundSettings(),
                                     &bgClipRect);
   }
 
   NS_DISPLAY_DECL_NAME("CanvasBackground")
 };
 
 /**
diff -r 9864735a4241 layout/generic/nsObjectFrame.cpp
--- a/layout/generic/nsObjectFrame.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/layout/generic/nsObjectFrame.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -1805,23 +1805,26 @@ MatchPluginName(nsPluginInstanceOwner *a
                  aPluginName,
                  strlen(aPluginName)) == 0;
 }
 
 static PRBool
 DoDelayedStop(nsPluginInstanceOwner *aInstanceOwner, PRBool aDelayedStop)
 {
   // Don't delay stopping QuickTime (bug 425157), Flip4Mac (bug 426524),
-  // XStandard (bug 430219), CMISS Zinc (bug 429604).
+  // XStandard (bug 430219), CMISS Zinc (bug 429604). ARM Flash (454756)
   if (aDelayedStop
 #ifndef XP_WIN
       && !::MatchPluginName(aInstanceOwner, "QuickTime")
       && !::MatchPluginName(aInstanceOwner, "Flip4Mac")
       && !::MatchPluginName(aInstanceOwner, "XStandard plugin")
       && !::MatchPluginName(aInstanceOwner, "CMISS Zinc Plugin")
+#endif
+#if defined(XP_UNIX) && defined(__arm__)
+      && !::MatchPluginName(aInstanceOwner, "Shockwave Flash")
 #endif
       ) {
     nsCOMPtr<nsIRunnable> evt = new nsStopPluginRunnable(aInstanceOwner);
     NS_DispatchToCurrentThread(evt);
     return PR_TRUE;
   }
   return PR_FALSE;
 }
diff -r 9864735a4241 layout/generic/nsPageFrame.cpp
--- a/layout/generic/nsPageFrame.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/layout/generic/nsPageFrame.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -566,22 +566,19 @@ nsPageFrame::PaintPageContent(nsIRenderi
     clipRect.y = NSToCoordCeil((-pageContentFrame->GetRect().y + 
                                 mPD->mReflowMargin.top) / scale);
     clipRect.height = expectedPageContentHeight;
     NS_ASSERTION(clipRect.y < pageContentFrame->GetSize().height,
                  "Should be clipping to region inside the page content bounds");
   }
   aRenderingContext.SetClipRect(clipRect, nsClipCombine_kIntersect);
 
-  const nsStyleBorder* border = GetStyleBorder();
-  const nsStylePadding* padding = GetStylePadding();
   nsRect backgroundRect = nsRect(nsPoint(0, 0), pageContentFrame->GetSize());
   nsCSSRendering::PaintBackground(PresContext(), aRenderingContext, this,
-                                  rect, backgroundRect, *border, *padding,
-                                  PR_TRUE);
+                                  rect, backgroundRect, PR_TRUE);
 
   nsLayoutUtils::PaintFrame(&aRenderingContext, pageContentFrame,
                             nsRegion(rect), NS_RGBA(0,0,0,0));
 
   aRenderingContext.PopState();
 }
 
 void
diff -r 9864735a4241 layout/mathml/base/src/nsMathMLChar.cpp
--- a/layout/mathml/base/src/nsMathMLChar.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/layout/mathml/base/src/nsMathMLChar.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -2047,21 +2047,18 @@ nsMathMLChar::Display(nsDisplayListBuild
   else if (mRect.width && mRect.height) {
     const nsStyleBackground* backg = styleContext->GetStyleBackground();
     if (styleContext != parentContext &&
         NS_GET_A(backg->mBackgroundColor) > 0) {
       rv = aLists.BorderBackground()->AppendNewToTop(new (aBuilder)
           nsDisplayMathMLCharBackground(aForFrame, mRect, styleContext));
       NS_ENSURE_SUCCESS(rv, rv);
     }
-
     //else
     //  our container frame will take care of painting its background
-    //  nsCSSRendering::PaintBackground(aPresContext, aRenderingContext, aForFrame,
-    //                                  aDirtyRect, rect, *border, *padding, PR_TRUE);
 
 #if defined(NS_DEBUG) && defined(SHOW_BOUNDING_BOX)
     // for visual debug
     rv = aLists.BorderBackground()->AppendToTop(new (aBuilder)
         nsDisplayMathMLCharDebug(aForFrame, mRect));
     NS_ENSURE_SUCCESS(rv, rv);
 #endif
   }
diff -r 9864735a4241 layout/reftests/bugs/444928-1-ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/444928-1-ref.html	Fri Sep 26 09:30:25 2008 -0500
@@ -0,0 +1,17 @@
+<html>
+<head>
+<style type="text/css">
+table{ width: 500px; }
+
+</style>
+</head>
+<body>
+<table class="grid" cellspacing="50" cellpadding="0" border>
+<col width="10%"/>
+<col width="1" span="2"/>
+<tbody>
+<tr><th class="top" colspan="3"> Some Text</th></tr>
+</tbody>
+</table>
+</body>
+</html>
diff -r 9864735a4241 layout/reftests/bugs/444928-1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/444928-1.html	Fri Sep 26 09:30:25 2008 -0500
@@ -0,0 +1,17 @@
+<html>
+<head>
+<style type="text/css">
+table{table-layout: fixed; width: 500px; }
+
+</style>
+</head>
+<body>
+<table class="grid" cellspacing="50" cellpadding="0" border>
+<col width="10%"/>
+<col width="1" span="2"/>
+<tbody>
+<tr><th class="top" colspan="3"> Some Text</th></tr>
+</tbody>
+</table>
+</body>
+</html>
diff -r 9864735a4241 layout/reftests/bugs/444928-2-ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/444928-2-ref.html	Fri Sep 26 09:30:25 2008 -0500
@@ -0,0 +1,18 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
+<html>
+<head>
+<title>Examples for bug 444928</title>
+</head>
+<body>
+
+<table cellspacing="50" cellpadding="0" style="table-layout:fixed" width="652">
+<col width="150">
+<col width="150">
+<col>
+<tr><td colspan="2" style="background:yellow">1-2</td><td style="background:fuchsia">3</td></tr>
+<tr style="color:transparent"><td>1</td><td>2</td><td>3</td></tr>
+</tbody>
+</table>
+
+</body>
+</html>
diff -r 9864735a4241 layout/reftests/bugs/444928-2.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/444928-2.html	Fri Sep 26 09:30:25 2008 -0500
@@ -0,0 +1,17 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
+<html>
+<head>
+<title>Examples for bug 444928</title>
+</head>
+<body>
+
+<table cellspacing="50" cellpadding="0" style="table-layout:fixed" width="652">
+<col width="150">
+<col width="150">
+<col>
+<tr><td colspan="2" style="background:yellow">1-2</td><td style="background:fuchsia">3</td></tr>
+</tbody>
+</table>
+
+</body>
+</html>
diff -r 9864735a4241 layout/reftests/bugs/444928-3-notref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/444928-3-notref.html	Fri Sep 26 09:30:25 2008 -0500
@@ -0,0 +1,18 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
+<html>
+<head>
+<title>Examples for bug 444928</title>
+</head>
+<body>
+
+<table cellspacing="50" cellpadding="0" width="652">
+<col width="150">
+<col width="150">
+<col>
+<tr><td colspan="2" style="background:yellow">1-2</td><td style="background:fuchsia">3</td></tr>
+<tr style="color:transparent"><td>1</td><td>2</td><td>3</td></tr>
+</tbody>
+</table>
+
+</body>
+</html>
diff -r 9864735a4241 layout/reftests/bugs/444928-3.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/444928-3.html	Fri Sep 26 09:30:25 2008 -0500
@@ -0,0 +1,17 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
+<html>
+<head>
+<title>Examples for bug 444928</title>
+</head>
+<body>
+
+<table cellspacing="50" cellpadding="0" width="652">
+<col width="150">
+<col width="150">
+<col>
+<tr><td colspan="2" style="background:yellow">1-2</td><td style="background:fuchsia">3</td></tr>
+</tbody>
+</table>
+
+</body>
+</html>
diff -r 9864735a4241 layout/reftests/bugs/reftest.list
--- a/layout/reftests/bugs/reftest.list	Mon Sep 22 11:50:03 2008 -0700
+++ b/layout/reftests/bugs/reftest.list	Fri Sep 26 09:30:25 2008 -0500
@@ -903,17 +903,19 @@ random == 429849-1.html 429849-1-ref.htm
 == 438987-2c.html 438987-2-ref.html
 != about:blank 438987-2-ref.html # check that backgrounds work at all 
 == 439004-1.html 439004-1-ref.html
 == 439639-1.html 439639-1-ref.html
 == 439910.html 439910-ref.html
 == 441259-1.html 441259-1-ref.html
 fails == 441259-2.html 441259-2-ref.html # bug 441400
 == 444015-1.html 444015-1-ref.html
+== 444928-1.html 444928-1-ref.html
+== 444928-2.html 444928-2-ref.html
+!= 444928-3.html 444928-3-notref.html
 # == 448987.html 448987-ref.html  # Disabled for now - it needs privileges
 == 449171-1.html 449171-ref.html
 == 449519-1.html 449519-1-ref.html
 # == 449653-1.html 449653-1-ref.html # Disabled for now - it needs privileges
 == 450670-1.html 450670-1-ref.html
 == 451168-1.html 451168-1-ref.html
 == 454361.html about:blank
 == 455280-1.xhtml 455280-1-ref.xhtml
-
diff -r 9864735a4241 layout/reftests/reftest-sanity/reftest.list
--- a/layout/reftests/reftest-sanity/reftest.list	Mon Sep 22 11:50:03 2008 -0700
+++ b/layout/reftests/reftest-sanity/reftest.list	Fri Sep 26 09:30:25 2008 -0500
@@ -1,17 +1,18 @@
 == data:text/html,<body> about:blank
 == data:text/plain, about:blank
 != data:text/plain,HELLO about:blank
 
 # these tests make sure async reftests work:
-== test-async.xul test-async-ref.xul
+== test-async.xul test-async-ref.xul
 == test-async.html test-async-ref.html
 
-# This makes sure that the harness is choosing HTML vs. XHTML processing
-# based on the file extensions.
+# Makes sure that the file: protocol handler and HTTP server both
+# choose HTML vs. XHTML processing based on the file extensions.
 != html-vs-xhtml-by-extension.html html-vs-xhtml-by-extension.xhtml
+HTTP != html-vs-xhtml-by-extension.html html-vs-xhtml-by-extension.xhtml
 
 # make sure red and green colors are not the default and are different from
 # each other
 != green.html default.html
 != green.html red.html
 != red.html default.html
diff -r 9864735a4241 layout/reftests/transform/reftest.list
--- a/layout/reftests/transform/reftest.list	Mon Sep 22 11:50:03 2008 -0700
+++ b/layout/reftests/transform/reftest.list	Fri Sep 26 09:30:25 2008 -0500
@@ -1,59 +1,67 @@
+# Transforms specifying singular matrices shouldn't display at all.
+# NOTE: Regressions might manifest themselves as reftest timeouts on
+# this test.
+== singular-1a.html about:blank
 # Multiple transforms should act identically to nested divs.
 == compound-1a.html compound-1-ref.html
 != compound-1a.html compound-1-fail.html
 # translatex should act like position: relative
 == translatex-1a.html translatex-1-ref.html
-random == translatex-1b.html translatex-1-ref.html # bug 455138
+== translatex-1b.html translatex-1-ref.html
 == translatex-1c.html translatex-1-ref.html
 == translatex-1d.html translatex-1-ref.html
 == translatex-1e.html translatex-1-ref.html
 == translatex-1a.html translatex-1-ref-2.html
 # translatey should act like position: relative
 == translatey-1a.html translatey-1-ref.html
-random == translatey-1b.html translatey-1-ref.html # bug 455138
+== translatey-1b.html translatey-1-ref.html
 == translatey-1c.html translatey-1-ref.html
 == translatey-1d.html translatey-1-ref.html
 == translatey-1e.html translatey-1-ref.html
 # matrices defined to be translations should act like position: relative
 == translatex-2.html translatex-1-ref.html
 == translatey-2.html translatey-1-ref.html
 # translate should act like position: relative
 != translate-1a.html translate-1-ref.html
-random == translate-1b.html translate-1-ref.html # bug 455138
+== translate-1b.html translate-1-ref.html
 == translate-1c.html translate-1-ref.html
 == translate-1d.html translate-1-ref.html
 == translate-1e.html translate-1-ref.html
 == translate-2a.html translate-2-ref.html
-# rotate: Several rotations of the same object should be idempotent
-== rotate-1a.html rotate-1-ref.html
-== rotate-1b.html rotate-1-ref.html
-== rotate-1c.html rotate-1-ref.html
-== rotate-1d.html rotate-1-ref.html
-== rotate-1e.html rotate-1-ref.html
-# rotate: 90deg rotations should be indistinguishable from objects constructed to look the same.
+# rotate: Several rotations of the same object should be idempotent.  These
+# tests are currently disabled because of subpixel (< 0.00001 gfx units)
+# rounding errors.
+random == rotate-1a.html rotate-1-ref.html
+random == rotate-1b.html rotate-1-ref.html
+random == rotate-1c.html rotate-1-ref.html
+random == rotate-1d.html rotate-1-ref.html
+random == rotate-1e.html rotate-1-ref.html
+# rotate: 90deg rotations should be indistinguishable from objects constructed
+# to look the same.
 == rotate-2a.html rotate-2-ref.html
-# -moz-transform-origin: We should NOT get the same images when using different -moz-transform-origins.
+# -moz-transform-origin: We should NOT get the same images when using different
+# -moz-transform-origins.
 != origin-1a.html origin-1-ref.html
 != origin-1b.html origin-1-ref.html
-# -moz-transform-origin: We should get the same images when using equivalent -moz-transform-origins.
+# -moz-transform-origin: We should get the same images when using equivalent
+# -moz-transform-origins.
 == origin-2a.html origin-2-ref.html
 == origin-2b.html origin-2-ref.html
 == origin-2c.html origin-2-ref.html
 # "Translate" with percentages should be indistinguishable from translate with
-# equivalent values.  This entire family of reftests has subpixel rounding
-# errors, however, and so they're marked "random" until a resolution is found.
-random == percent-1a.html percent-1-ref.html
-random == percent-1b.html percent-1-ref.html
-random == percent-1c.html percent-1-ref.html
-random == percent-1d.html percent-1-ref.html # bug 455138
-random == percent-1e.html percent-1-ref.html # bug 455138
-random == percent-1f.html percent-1-ref.html # bug 455138
-random == percent-1g.html percent-1-ref.html
+# equivalent values.
+== percent-1a.html percent-1-ref.html
+== percent-1b.html percent-1-ref.html
+== percent-1c.html percent-1-ref.html
+== percent-1d.html percent-1-ref.html
+== percent-1e.html percent-1-ref.html
+== percent-1f.html percent-1-ref.html
+== percent-1g.html percent-1-ref.html
 # Transformed elements are abs-pos and fixed-pos containing blocks.
 == abspos-1a.html abspos-1-ref.html
 == abspos-1b.html abspos-1-ref.html
 == abspos-1c.html abspos-1-ref.html
 == abspos-1d.html abspos-1-ref.html
 != abspos-1e.html abspos-1-ref.html
 # Origin can use "top" "right" etc.
 == origin-name-1a.html origin-name-1-ref.html
diff -r 9864735a4241 layout/reftests/transform/rotate-1-ref.html
--- a/layout/reftests/transform/rotate-1-ref.html	Mon Sep 22 11:50:03 2008 -0700
+++ b/layout/reftests/transform/rotate-1-ref.html	Fri Sep 26 09:30:25 2008 -0500
@@ -1,9 +1,9 @@
 <html>
 <head>
 </head>
 <body>
-  <div style="-moz-transform: rotate(45deg);">
+  <div style="-moz-transform: rotate(45deg); width: 100px; height: 100px;">
     Test Text
   </div>
 </body>
 </html>
diff -r 9864735a4241 layout/reftests/transform/rotate-1a.html
--- a/layout/reftests/transform/rotate-1a.html	Mon Sep 22 11:50:03 2008 -0700
+++ b/layout/reftests/transform/rotate-1a.html	Fri Sep 26 09:30:25 2008 -0500
@@ -1,9 +1,9 @@
 <html>
 <head>
 </head>
 <body>
-  <div style="-moz-transform: rotate(45deg) rotate(360deg);">
+  <div style="-moz-transform: rotate(45deg) rotate(360deg); width: 100px; height: 100px;">
     Test Text
   </div>
 </body>
 </html>
diff -r 9864735a4241 layout/reftests/transform/rotate-1b.html
--- a/layout/reftests/transform/rotate-1b.html	Mon Sep 22 11:50:03 2008 -0700
+++ b/layout/reftests/transform/rotate-1b.html	Fri Sep 26 09:30:25 2008 -0500
@@ -1,9 +1,9 @@
 <html>
 <head>
 </head>
 <body>
-  <div style="-moz-transform: rotate(45deg) rotate(400grad);">
+  <div style="-moz-transform: rotate(45deg) rotate(400grad); width: 100px; height: 100px;">
     Test Text
   </div>
 </body>
 </html>
diff -r 9864735a4241 layout/reftests/transform/rotate-1c.html
--- a/layout/reftests/transform/rotate-1c.html	Mon Sep 22 11:50:03 2008 -0700
+++ b/layout/reftests/transform/rotate-1c.html	Fri Sep 26 09:30:25 2008 -0500
@@ -1,9 +1,9 @@
 <html>
 <head>
 </head>
 <body>
-  <div style="-moz-transform: rotate(45deg) rotate(100deg) rotate(80deg) rotate(200grad);">
+  <div style="-moz-transform: rotate(45deg) rotate(100deg) rotate(80deg) rotate(200grad); width: 100px; height: 100px;">
     Test Text
   </div>
 </body>
 </html>
diff -r 9864735a4241 layout/reftests/transform/rotate-1d.html
--- a/layout/reftests/transform/rotate-1d.html	Mon Sep 22 11:50:03 2008 -0700
+++ b/layout/reftests/transform/rotate-1d.html	Fri Sep 26 09:30:25 2008 -0500
@@ -1,9 +1,9 @@
 <html>
 <head>
 </head>
 <body>
-  <div style="-moz-transform: rotate(-45deg) rotate(100grad);">
+  <div style="-moz-transform: rotate(-45deg) rotate(100grad); width: 100px; height: 100px;">
     Test Text
   </div>
 </body>
 </html>
diff -r 9864735a4241 layout/reftests/transform/rotate-1e.html
--- a/layout/reftests/transform/rotate-1e.html	Mon Sep 22 11:50:03 2008 -0700
+++ b/layout/reftests/transform/rotate-1e.html	Fri Sep 26 09:30:25 2008 -0500
@@ -1,9 +1,9 @@
 <html>
 <head>
 </head>
 <body>
-  <div style="-moz-transform: rotate(-135deg) rotate(3.1415926535897932384626433rad);">
+  <div style="-moz-transform: rotate(-135deg) rotate(3.1415926535897932384626433rad); width: 100px; height: 100px;">
     Test Text
   </div>
 </body>
 </html>
diff -r 9864735a4241 layout/reftests/transform/singular-1a.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/transform/singular-1a.html	Fri Sep 26 09:30:25 2008 -0500
@@ -0,0 +1,9 @@
+<html>
+<head>
+</head>
+<body>
+  <div style="-moz-transform: matrix(1, 1, 1, 1, 0, 0); width: 100px; height: 100px; background-color: gold;">
+    This shouldn't be visible.
+  </div>
+</body>
+</html>
diff -r 9864735a4241 layout/reftests/transform/translate-1b.html
--- a/layout/reftests/transform/translate-1b.html	Mon Sep 22 11:50:03 2008 -0700
+++ b/layout/reftests/transform/translate-1b.html	Fri Sep 26 09:30:25 2008 -0500
@@ -1,9 +1,9 @@
 <html>
 <head>
 </head>
 <body>
-  <div style="-moz-transform: translate(50px) rotate(360deg);">
+  <div style="-moz-transform: translate(50px, 50px) rotate(360deg);">
     Test Text
   </div>
 </body>
 </html>
diff -r 9864735a4241 layout/style/nsStyleTransformMatrix.cpp
--- a/layout/style/nsStyleTransformMatrix.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/layout/style/nsStyleTransformMatrix.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -43,17 +43,18 @@
 #include "nsCSSValue.h"
 #include "nsStyleContext.h"
 #include "nsPresContext.h"
 #include "nsRuleNode.h"
 #include "nsCSSKeywords.h"
 #include <math.h>
 
 /* Arguably, this loses precision, but it doesn't hurt! */
-const float kPi = 3.1415926535897932384626433f;
+const float kPi      = 3.1415926535897932384626433832795f;
+const float kTwoPi   = 6.283185307179586476925286766559f;
 const float kEpsilon = 0.0001f;
 
 /* Computes tan(theta).  For values of theta such that
  * tan(theta) is undefined or arbitrarily large, SafeTangent
  * returns a managably large or small value of the correct sign.
  */
 static float SafeTangent(float aTheta)
 {
@@ -68,34 +69,48 @@ static float SafeTangent(float aTheta)
   if (cosTheta >= 0 && cosTheta < kEpsilon)
     cosTheta = kEpsilon;
   else if (cosTheta < 0 && cosTheta >= -kEpsilon)
     cosTheta = -kEpsilon;
   
   return sinTheta / cosTheta;
 }
 
+/* Helper function to constrain an angle to a value in the range [-pi, pi),
+ * which reduces accumulated floating point errors from trigonometric functions
+ * by keeping the error terms small.
+ */
+static inline float ConstrainFloatValue(float aValue)
+{
+  /* Get in range [0, 2pi) */
+  aValue = fmod(aValue, kTwoPi);
+  return aValue >= kPi ? aValue - kTwoPi : aValue;
+}
+
 /* Converts an nsCSSValue containing an angle into an equivalent measure
- * of radians.
+ * of radians.  The value is guaranteed to be in the range (-pi, pi) to
+ * minimize error.
  */
 static float CSSToRadians(const nsCSSValue &aValue)
 {
   NS_PRECONDITION(aValue.IsAngularUnit(),
                   "Expected an angle, but didn't find one!");
   
   switch (aValue.GetUnit()) {
   case eCSSUnit_Degree:
     /* 360deg = 2pi rad, so deg = pi / 180 rad */
-    return aValue.GetFloatValue() * kPi / 180.0f;
+    return
+      ConstrainFloatValue(aValue.GetFloatValue() * kPi / 180.0f);
   case eCSSUnit_Grad:
     /* 400grad = 2pi rad, so grad = pi / 200 rad */
-    return aValue.GetFloatValue() * kPi / 200.0f;
+    return
+      ConstrainFloatValue(aValue.GetFloatValue() * kPi / 200.0f);
   case eCSSUnit_Radian:
     /* Yay identity transforms! */
-    return aValue.GetFloatValue();
+    return ConstrainFloatValue(aValue.GetFloatValue());
   default:
     NS_NOTREACHED("Unexpected angular unit!");
     return 0.0f;
   }
 }
 
 /* Constructor sets the data to the identity matrix. */
 nsStyleTransformMatrix::nsStyleTransformMatrix()
@@ -119,39 +134,40 @@ void nsStyleTransformMatrix::SetToIdenti
   mX[1] = 0.0f;
   mY[0] = 0.0f;
   mY[1] = 0.0f;
 }
 
 /* Adds the constant translation to the scale factor translation components. */
 nscoord nsStyleTransformMatrix::GetXTranslation(const nsRect& aBounds) const
 {
-  return nscoord(aBounds.width * mX[0] + aBounds.height * mY[0]) + mDelta[0];
+  return NSToCoordRound(aBounds.width * mX[0] + aBounds.height * mY[0]) +
+    mDelta[0];
 }
 nscoord nsStyleTransformMatrix::GetYTranslation(const nsRect& aBounds) const
 {
-  return nscoord(aBounds.width * mX[1] + aBounds.height * mY[1]) + mDelta[1];
+  return NSToCoordRound(aBounds.width * mX[1] + aBounds.height * mY[1]) +
+    mDelta[1];
 }
 
 /* GetThebesMatrix converts the stored matrix in a few steps. */
 gfxMatrix nsStyleTransformMatrix::GetThebesMatrix(const nsRect& aBounds,
-                                                  PRInt32 aScale) const
+                                                  float aScale) const
 {
   /* Compute the graphics matrix.  We take the stored main elements, along with
    * the delta, and add in the matrices:
    *
    * | 0 0 dx1|
    * | 0 0 dx2| * width
    * | 0 0   0|
    *
    * | 0 0 dy1|
    * | 0 0 dy2| * height
    * | 0 0   0|
    */
-
   return gfxMatrix(mMain[0], mMain[1], mMain[2], mMain[3],
                    NSAppUnitsToFloatPixels(GetXTranslation(aBounds), aScale),
                    NSAppUnitsToFloatPixels(GetYTranslation(aBounds), aScale));
 }
 
 /* Performs the matrix multiplication necessary to multiply the two matrices,
  * then hands back a reference to ourself.
  */
@@ -171,22 +187,20 @@ nsStyleTransformMatrix::operator *= (con
    * |a1 c1 e1| |a0 c0 e0|   |a0a1 + b0c1    c0a1 + d0c1     e0a1 + f0c1 + e1|
    * |b1 d1 f1|x|b0 d0 f0| = |a0b1 + b0d1    c0b1 + d0d1     e0b1 + f0d1 + f1|
    * |0  0  1 | | 0  0  1|   |          0              0                    1|
    */
   newMatrix[0] = aOther.mMain[0] * mMain[0] + aOther.mMain[1] * mMain[2];
   newMatrix[1] = aOther.mMain[0] * mMain[1] + aOther.mMain[1] * mMain[3];
   newMatrix[2] = aOther.mMain[2] * mMain[0] + aOther.mMain[3] * mMain[2];
   newMatrix[3] = aOther.mMain[2] * mMain[1] + aOther.mMain[3] * mMain[3];
-  newDelta[0] =
-    NSCoordMultiply(aOther.mDelta[0], mMain[0]) +
-    NSCoordMultiply(aOther.mDelta[1], mMain[2]) + mDelta[0];
-  newDelta[1] =
-    NSCoordMultiply(aOther.mDelta[0], mMain[1]) +
-    NSCoordMultiply(aOther.mDelta[1], mMain[3]) + mDelta[1];
+  newDelta[0] = NSToCoordRound(aOther.mDelta[0] * mMain[0] +
+                               aOther.mDelta[1] * mMain[2]) + mDelta[0];
+  newDelta[1] = NSToCoordRound(aOther.mDelta[0] * mMain[1] +
+                               aOther.mDelta[1] * mMain[3]) + mDelta[1];
 
   /* For consistent terminology, let u0, u1, v0, and v1 be the four transform
    * coordinates from our matrix, and let x0, x1, y0, and y1 be the four
    * transform coordinates from the other  matrix.  Then the new transform
    * coordinates are:
    *
    * u0' = a1u0 + c1u1 + x0
    * u1' = b1u0 + d1u1 + x1
diff -r 9864735a4241 layout/style/nsStyleTransformMatrix.h
--- a/layout/style/nsStyleTransformMatrix.h	Mon Sep 22 11:50:03 2008 -0700
+++ b/layout/style/nsStyleTransformMatrix.h	Fri Sep 26 09:30:25 2008 -0500
@@ -76,17 +76,17 @@ class nsStyleTransformMatrix
    * matrix.  The transformation takes points in the frame's
    * local space and converts them to points in the frame's
    * transformed space.
    *
    * @param aBounds The frame's bounding rectangle.
    * @param aFactor The number of app units per device pixel.
    * @return A Thebes matrix corresponding to the transform.
    */
-  gfxMatrix GetThebesMatrix(const nsRect& aBounds, PRInt32 aFactor) const;
+  gfxMatrix GetThebesMatrix(const nsRect& aBounds, float aFactor) const;
 
   /**
    * Multiplies this matrix by another matrix, in that order.  If A'
    * is the value of A after A *= B, then for any vector x, the
    * equivalence A'(x) == A(B(x)) holds.
    *
    * @param aOther The matrix to multiply this matrix by.
    * @return A reference to this matrix.
@@ -170,14 +170,14 @@ class nsStyleTransformMatrix
    * |       0        0     mX[1]| <-- Scaled by width of element
    * |       0        0         1|
    *
    * |       0        0     mY[0]|
    * |       0        0     mY[1]| <-- Scaled by height of element
    * |       0        0         1|
    */
   float mMain[4];
-  nscoord  mDelta[2];
+  nscoord mDelta[2];
   float mX[2];
   float mY[2];
 };
 
 #endif
diff -r 9864735a4241 layout/tables/BasicTableLayoutStrategy.cpp
--- a/layout/tables/BasicTableLayoutStrategy.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/layout/tables/BasicTableLayoutStrategy.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -46,17 +46,18 @@
 #include "nsTableCellFrame.h"
 #include "nsLayoutUtils.h"
 #include "nsGkAtoms.h"
 #include "SpanningCellSorter.h"
 
 #undef  DEBUG_TABLE_STRATEGY 
 
 BasicTableLayoutStrategy::BasicTableLayoutStrategy(nsTableFrame *aTableFrame)
-  : mTableFrame(aTableFrame)
+  : nsITableLayoutStrategy(nsITableLayoutStrategy::Auto)
+  , mTableFrame(aTableFrame)
 {
     MarkIntrinsicWidthsDirty();
 }
 
 /* virtual */
 BasicTableLayoutStrategy::~BasicTableLayoutStrategy()
 {
 }
@@ -416,17 +417,17 @@ BasicTableLayoutStrategy::ComputeIntrins
                            // where a cell originates
 
     for (PRInt32 col = 0; col < colCount; ++col) {
         nsTableColFrame *colFrame = mTableFrame->GetColFrame(col);
         if (!colFrame) {
             NS_ERROR("column frames out of sync with cell map");
             continue;
         }
-        if (mTableFrame->GetNumCellsOriginatingInCol(col)) {
+        if (mTableFrame->ColumnHasCellSpacingBefore(col)) {
             add += spacing;
         }
         min += colFrame->GetMinCoord();
         pref = NSCoordSaturatingAdd(pref, colFrame->GetPrefCoord());
 
         // Percentages are of the table, so we have to reverse them for
         // intrinsic widths.
         float p = colFrame->GetPrefPercent();
@@ -625,17 +626,17 @@ BasicTableLayoutStrategy::DistributeWidt
 
     // border-spacing isn't part of the basis for percentages.
     nscoord spacing = mTableFrame->GetCellSpacingX();
     nscoord subtract = 0;    
     // aWidth initially includes border-spacing for the boundaries in between
     // each of the columns. We start at aFirstCol + 1 because the first
     // in-between boundary would be at the left edge of column aFirstCol + 1
     for (PRInt32 col = aFirstCol + 1; col < aFirstCol + aColCount; ++col) {
-        if (mTableFrame->GetNumCellsOriginatingInCol(col)) {
+        if (mTableFrame->ColumnHasCellSpacingBefore(col)) {
             subtract += spacing;
         }
     }
     if (aWidthType == BTLS_FINAL_WIDTH) {
         // If we're computing final col-width, then aWidth initially includes
         // border spacing on the table's far left + far right edge, too.  Need
         // to subtract those out, too.
         subtract += spacing * 2;
@@ -734,17 +735,17 @@ BasicTableLayoutStrategy::DistributeWidt
                 // loop
                 nscoord delta = NSCoordSaturatingSubtract(pref_width, 
                                                           min_width, 0);
                 guess_min_spec = NSCoordSaturatingAdd(guess_min_spec, delta);
                 total_fixed_pref = NSCoordSaturatingAdd(total_fixed_pref, 
                                                         pref_width);
             } else if (pref_width == 0) {
                 if (aWidthType == BTLS_FINAL_WIDTH &&
-                    mTableFrame->GetNumCellsOriginatingInCol(col)) {
+                    mTableFrame->ColumnHasCellSpacingBefore(col)) {
                     ++numNonSpecZeroWidthCols;
                 }
             } else {
                 total_flex_pref = NSCoordSaturatingAdd(total_flex_pref,
                                                        pref_width);
             }
         }
     }
@@ -932,17 +933,17 @@ BasicTableLayoutStrategy::DistributeWidt
                 }
                 break;
             case FLEX_FLEX_LARGE_ZERO:
                 NS_ASSERTION(aWidthType == BTLS_FINAL_WIDTH,
                              "FLEX_FLEX_LARGE_ZERO only should be hit "
                              "when we're setting final width.");
                 if (pct == 0.0f &&
                     !colFrame->GetHasSpecifiedCoord() &&
-                    mTableFrame->GetNumCellsOriginatingInCol(col)) {
+                    mTableFrame->ColumnHasCellSpacingBefore(col)) {
 
                     NS_ASSERTION(col_width == 0 &&
                                  colFrame->GetPrefCoord() == 0,
                                  "Since we're in FLEX_FLEX_LARGE_ZERO case, "
                                  "all auto-width cols should have zero pref "
                                  "width.");
                     float c = float(space) / float(basis.c);
                     col_width += NSToCoordRound(c);
diff -r 9864735a4241 layout/tables/FixedTableLayoutStrategy.cpp
--- a/layout/tables/FixedTableLayoutStrategy.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/layout/tables/FixedTableLayoutStrategy.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -42,17 +42,18 @@
  */
 
 #include "FixedTableLayoutStrategy.h"
 #include "nsTableFrame.h"
 #include "nsTableColFrame.h"
 #include "nsTableCellFrame.h"
 
 FixedTableLayoutStrategy::FixedTableLayoutStrategy(nsTableFrame *aTableFrame)
-  : mTableFrame(aTableFrame)
+  : nsITableLayoutStrategy(nsITableLayoutStrategy::Fixed)
+  , mTableFrame(aTableFrame)
 {
     MarkIntrinsicWidthsDirty();
 }
 
 /* virtual */
 FixedTableLayoutStrategy::~FixedTableLayoutStrategy()
 {
 }
@@ -60,38 +61,37 @@ FixedTableLayoutStrategy::~FixedTableLay
 /* virtual */ nscoord
 FixedTableLayoutStrategy::GetMinWidth(nsIRenderingContext* aRenderingContext)
 {
     DISPLAY_MIN_WIDTH(mTableFrame, mMinWidth);
     if (mMinWidth != NS_INTRINSIC_WIDTH_UNKNOWN)
         return mMinWidth;
 
     // It's theoretically possible to do something much better here that
-    // depends only on the columns and the first row, but it wouldn't be
-    // compatible with other browsers, or with the use of GetMinWidth by
-    // nsHTMLReflowState to determine the width of a fixed-layout table,
-    // since CSS2.1 says:
+    // depends only on the columns and the first row (where we look at
+    // intrinsic widths inside the first row and then reverse the
+    // algorithm to find the narrowest width that would hold all of
+    // those intrinsic widths), but it wouldn't be compatible with other
+    // browsers, or with the use of GetMinWidth by
+    // nsTableFrame::ComputeSize to determine the width of a fixed
+    // layout table, since CSS2.1 says:
     //   The width of the table is then the greater of the value of the
     //   'width' property for the table element and the sum of the
     //   column widths (plus cell spacing or borders).
 
     // XXX Should we really ignore 'min-width' and 'max-width'?
+    // XXX Should we really ignore widths on column groups?
 
     nsTableCellMap *cellMap = mTableFrame->GetCellMap();
     PRInt32 colCount = cellMap->GetColCount();
     nscoord spacing = mTableFrame->GetCellSpacingX();
 
-    // XXX Should this code do any pixel rounding?
-
     nscoord result = 0;
 
-    // XXX Consider widths on columns or column groups?
-
     if (colCount > 0) {
-        // XXX Should only add columns that have cells originating in them!
         result += spacing * (colCount + 1);
     }
 
     for (PRInt32 col = 0; col < colCount; ++col) {
         nsTableColFrame *colFrame = mTableFrame->GetColFrame(col);
         if (!colFrame) {
             NS_ERROR("column frames out of sync with cell map");
             continue;
@@ -146,18 +146,21 @@ FixedTableLayoutStrategy::GetMinWidth(ns
     return (mMinWidth = result);
 }
 
 /* virtual */ nscoord
 FixedTableLayoutStrategy::GetPrefWidth(nsIRenderingContext* aRenderingContext,
                                        PRBool aComputingSize)
 {
     // It's theoretically possible to do something much better here that
-    // depends only on the columns and the first row, but it wouldn't be
-    // compatible with other browsers.
+    // depends only on the columns and the first row (where we look at
+    // intrinsic widths inside the first row and then reverse the
+    // algorithm to find the narrowest width that would hold all of
+    // those intrinsic widths), but it wouldn't be compatible with other
+    // browsers.
     nscoord result = nscoord_MAX;
     DISPLAY_PREF_WIDTH(mTableFrame, result);
     return result;
 }
 
 /* virtual */ void
 FixedTableLayoutStrategy::MarkIntrinsicWidthsDirty()
 {
@@ -173,32 +176,28 @@ FixedTableLayoutStrategy::ComputeColumnW
     if (mLastCalcWidth == tableWidth)
         return;
     mLastCalcWidth = tableWidth;
 
     nsTableCellMap *cellMap = mTableFrame->GetCellMap();
     PRInt32 colCount = cellMap->GetColCount();
     nscoord spacing = mTableFrame->GetCellSpacingX();
 
-    // XXX Should this code do any pixel rounding?
-
-    // border-spacing isn't part of the basis for percentages.
-    if (colCount > 0) {
-        // XXX Should only add columns that have cells originating in them!
-        nscoord subtract = spacing * (colCount + 1);
-        tableWidth -= subtract;
-    } else {
+    if (colCount == 0) {
         // No Columns - nothing to compute
         return;
     }
 
+    // border-spacing isn't part of the basis for percentages.
+    tableWidth -= spacing * (colCount + 1);
+
     // XXX This ignores the 'min-width' and 'max-width' properties
     // throughout.  Then again, that's what the CSS spec says to do.
 
-    // XXX Consider widths on columns or column groups?
+    // XXX Should we really ignore widths on column groups?
 
     PRUint32 unassignedCount = 0;
     nscoord unassignedSpace = tableWidth;
     const nscoord unassignedMarker = nscoord_MIN;
 
     // We use the PrefPercent on the columns to store the percentages
     // used to compute column widths in case we need to reduce their
     // basis.
diff -r 9864735a4241 layout/tables/nsITableLayoutStrategy.h
--- a/layout/tables/nsITableLayoutStrategy.h	Mon Sep 22 11:50:03 2008 -0700
+++ b/layout/tables/nsITableLayoutStrategy.h	Fri Sep 26 09:30:25 2008 -0500
@@ -65,11 +65,23 @@ public:
     /** Implement nsIFrame::MarkIntrinsicWidthsDirty for the table */
     virtual void MarkIntrinsicWidthsDirty() = 0;
 
     /**
      * Compute final column widths based on the intrinsic width data and
      * the available width.
      */
     virtual void ComputeColumnWidths(const nsHTMLReflowState& aReflowState) = 0;
+
+    /**
+     * Return the type of table layout strategy, without the cost of
+     * a virtual function call
+     */
+    enum Type { Auto, Fixed };
+    Type GetType() const { return mType; }
+
+protected:
+    nsITableLayoutStrategy(Type aType) : mType(aType) {}
+private:
+    Type mType;
 };
 
 #endif /* !defined(nsITableLayoutStrategy_h_) */
diff -r 9864735a4241 layout/tables/nsTableCellFrame.cpp
--- a/layout/tables/nsTableCellFrame.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/layout/tables/nsTableCellFrame.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -340,18 +340,17 @@ nsTableCellFrame::DecorateForSelection(n
 
 void
 nsTableCellFrame::PaintBackground(nsIRenderingContext& aRenderingContext,
                                   const nsRect&        aDirtyRect,
                                   nsPoint              aPt)
 {
   nsRect rect(aPt, GetSize());
   nsCSSRendering::PaintBackground(PresContext(), aRenderingContext, this,
-                                  aDirtyRect, rect, *GetStyleBorder(),
-                                  *GetStylePadding(), PR_TRUE);
+                                  aDirtyRect, rect, PR_TRUE);
 }
 
 // Called by nsTablePainter
 void
 nsTableCellFrame::PaintCellBackground(nsIRenderingContext& aRenderingContext,
                                       const nsRect& aDirtyRect, nsPoint aPt)
 {
   if (!GetStyleVisibility()->IsVisible())
@@ -1197,12 +1196,15 @@ nsBCTableCellFrame::PaintBackground(nsIR
 
   nsStyleBorder myBorder(*GetStyleBorder());
 
   NS_FOR_CSS_SIDES(side) {
     myBorder.SetBorderWidth(side, borderWidth.side(side));
   }
 
   nsRect rect(aPt, GetSize());
-  nsCSSRendering::PaintBackground(PresContext(), aRenderingContext, this,
-                                  aDirtyRect, rect, myBorder, *GetStylePadding(),
-                                  PR_TRUE);
+  // bypassing nsCSSRendering::PaintBackground is safe because this kind
+  // of frame cannot be used for the root element
+  nsCSSRendering::PaintBackgroundWithSC(PresContext(), aRenderingContext, this,
+                                        aDirtyRect, rect,
+                                        *GetStyleBackground(), myBorder,
+                                        *GetStylePadding(), PR_TRUE, nsnull);
 }
diff -r 9864735a4241 layout/tables/nsTableFrame.cpp
--- a/layout/tables/nsTableFrame.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/layout/tables/nsTableFrame.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -425,22 +425,28 @@ void nsTableFrame::AttributeChangedFor(n
 
 
 /* ****** CellMap methods ******* */
 
 /* return the effective col count */
 PRInt32 nsTableFrame::GetEffectiveColCount() const
 {
   PRInt32 colCount = GetColCount();
-  // don't count cols at the end that don't have originating cells
-  for (PRInt32 colX = colCount - 1; colX >= 0; colX--) {
-    if (GetNumCellsOriginatingInCol(colX) <= 0) { 
+  if (LayoutStrategy()->GetType() == nsITableLayoutStrategy::Auto) {
+    nsTableCellMap* cellMap = GetCellMap();
+    if (!cellMap) {
+      return 0;
+    }
+    // don't count cols at the end that don't have originating cells
+    for (PRInt32 colX = colCount - 1; colX >= 0; colX--) {
+      if (cellMap->GetNumCellsOriginatingInCol(colX) > 0) { 
+        break;
+      }
       colCount--;
     }
-    else break;
   }
   return colCount;
 }
 
 PRInt32 nsTableFrame::GetIndexOfLastRealCol()
 {
   PRInt32 numCols = mColFrames.Count();
   if (numCols > 0) {
@@ -1608,18 +1614,17 @@ nsTableFrame::ProcessRowInserted(nscoord
       childFrame = childFrame->GetNextSibling();
     }
   }
 }
 
 /* virtual */ void
 nsTableFrame::MarkIntrinsicWidthsDirty()
 {
-  static_cast<nsTableFrame*>(GetFirstInFlow())->
-    mTableLayoutStrategy->MarkIntrinsicWidthsDirty();
+  LayoutStrategy()->MarkIntrinsicWidthsDirty();
 
   // XXXldb Call SetBCDamageArea?
 
   nsHTMLContainerFrame::MarkIntrinsicWidthsDirty();
 }
 
 /* virtual */ nscoord
 nsTableFrame::GetMinWidth(nsIRenderingContext *aRenderingContext)
@@ -2207,17 +2212,17 @@ nsTableFrame::GetCollapsedWidth(nsMargin
       const nsStyleDisplay* colDisplay = colFrame->GetStyleDisplay();
       PRInt32 colX = colFrame->GetColIndex();
       if (NS_STYLE_DISPLAY_TABLE_COLUMN == colDisplay->mDisplay) {
         const nsStyleVisibility* colVis = colFrame->GetStyleVisibility();
         PRBool collapseCol = (NS_STYLE_VISIBILITY_COLLAPSE == colVis->mVisible);
         PRInt32 colWidth = GetColumnWidth(colX);
         if (!collapseGroup && !collapseCol) {
           width += colWidth;
-          if (GetNumCellsOriginatingInCol(colX) > 0)
+          if (ColumnHasCellSpacingBefore(colX))
             width += cellSpacingX;
         }
       }
     }
   }
   return width;
 }
 
@@ -4012,32 +4017,27 @@ nsTableFrame::GetRowAndColumnByIndex(PRI
     return NS_ERROR_NOT_INITIALIZED;
 
   cellMap->GetRowAndColumnByIndex(aIndex, aRow, aColumn);
   return NS_OK;
 }
 
 /*---------------- end of nsITableLayout implementation ------------------*/
 
-PRInt32 nsTableFrame::GetNumCellsOriginatingInCol(PRInt32 aColIndex) const
-{
-  nsTableCellMap* cellMap = GetCellMap();
-  if (cellMap) 
-    return cellMap->GetNumCellsOriginatingInCol(aColIndex);
-  else
-    return 0;
-}
-
-PRInt32 nsTableFrame::GetNumCellsOriginatingInRow(PRInt32 aRowIndex) const
-{
-  nsTableCellMap* cellMap = GetCellMap();
-  if (cellMap) 
-    return cellMap->GetNumCellsOriginatingInRow(aRowIndex);
-  else
-    return 0;
+PRBool
+nsTableFrame::ColumnHasCellSpacingBefore(PRInt32 aColIndex) const
+{
+  // Since fixed-layout tables should not have their column sizes change
+  // as they load, we assume that all columns are significant.
+  if (LayoutStrategy()->GetType() == nsITableLayoutStrategy::Fixed)
+    return PR_TRUE;
+  nsTableCellMap* cellMap = GetCellMap();
+  if (!cellMap) 
+    return PR_FALSE;
+  return cellMap->GetNumCellsOriginatingInCol(aColIndex) > 0;
 }
 
 static void
 CheckFixDamageArea(PRInt32 aNumRows,
                    PRInt32 aNumCols,
                    nsRect& aDamageArea)
 {
   if (((aDamageArea.XMost() > aNumCols) && (aDamageArea.width  != 1) && (aNumCols != 0)) || 
diff -r 9864735a4241 layout/tables/nsTableFrame.h
--- a/layout/tables/nsTableFrame.h	Mon Sep 22 11:50:03 2008 -0700
+++ b/layout/tables/nsTableFrame.h	Fri Sep 26 09:30:25 2008 -0500
@@ -525,18 +525,18 @@ public:
 
   virtual void RemoveCol(nsTableColGroupFrame* aColGroupFrame,
                          PRInt32               aColIndex,
                          PRBool                aRemoveFromCache,
                          PRBool                aRemoveFromCellMap);
 
   NS_IMETHOD GetIndexByRowAndColumn(PRInt32 aRow, PRInt32 aColumn, PRInt32 *aIndex);
   NS_IMETHOD GetRowAndColumnByIndex(PRInt32 aIndex, PRInt32 *aRow, PRInt32 *aColumn);
-  PRInt32 GetNumCellsOriginatingInCol(PRInt32 aColIndex) const;
-  PRInt32 GetNumCellsOriginatingInRow(PRInt32 aRowIndex) const;
+
+  PRBool ColumnHasCellSpacingBefore(PRInt32 aColIndex) const;
 
   PRBool HasPctCol() const;
   void SetHasPctCol(PRBool aValue);
 
   PRBool HasCellSpanningPctCol() const;
   void SetHasCellSpanningPctCol(PRBool aValue);
 
   /**
@@ -606,17 +606,17 @@ protected:
   /** Adjust the table for visibilty.collapse set on rowgroups, rows, colgroups
     * and cols
     * @param aDesiredSize    the metrics of the table
     * @param aBorderPadding  the border and padding of the table
     */
   void AdjustForCollapsingRowsCols(nsHTMLReflowMetrics& aDesiredSize,
                                    nsMargin             aBorderPadding);
 
-  nsITableLayoutStrategy* LayoutStrategy() {
+  nsITableLayoutStrategy* LayoutStrategy() const {
     return static_cast<nsTableFrame*>(GetFirstInFlow())->
       mTableLayoutStrategy;
   }
 
 private:
   /* Handle a row that got inserted during reflow.  aNewHeight is the
      new height of the table after reflow. */
   void ProcessRowInserted(nscoord aNewHeight);
diff -r 9864735a4241 layout/tables/nsTableRowFrame.cpp
--- a/layout/tables/nsTableRowFrame.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/layout/tables/nsTableRowFrame.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -679,17 +679,17 @@ CalcAvailWidth(nsTableFrame&     aTableF
   for (PRInt32 spanX = 0; spanX < colspan; spanX++) {
     nscoord colWidth = aTableFrame.GetColumnWidth(colIndex + spanX);
     if (NS_UNCONSTRAINEDSIZE == aColAvailWidth) {
       aColAvailWidth = colWidth; 
     }
     else {
       aColAvailWidth += colWidth;
     }
-    if ((spanX > 0) && (aTableFrame.GetNumCellsOriginatingInCol(colIndex + spanX) > 0)) {
+    if ((spanX > 0) && aTableFrame.ColumnHasCellSpacingBefore(colIndex + spanX)) {
       cellSpacing += aCellSpacingX;
     }
   }
   if (NS_UNCONSTRAINEDSIZE != aColAvailWidth) {
     aColAvailWidth += cellSpacing;
   } 
   aCellAvailWidth = aColAvailWidth;
 }
@@ -718,17 +718,17 @@ GetSpaceBetween(PRInt32       aPrevColIn
         nsIFrame* cgFrame = colFrame->GetParent();
         const nsStyleVisibility* groupVis = cgFrame->GetStyleVisibility();
         PRBool collapseGroup = (NS_STYLE_VISIBILITY_COLLAPSE ==
                                 groupVis->mVisible);
         isCollapsed = collapseCol || collapseGroup;
         if (!isCollapsed)
           space += aTableFrame.GetColumnWidth(colX);
       }
-      if (!isCollapsed && (aTableFrame.GetNumCellsOriginatingInCol(colX) > 0)) {
+      if (!isCollapsed && aTableFrame.ColumnHasCellSpacingBefore(colX)) {
         space += aCellSpacingX;
       }
     }
   } 
   else {
     PRInt32 lastCol = aColIndex + aColSpan - 1;
     for (colX = aPrevColIndex - 1; colX > lastCol; colX--) {
       PRBool isCollapsed = PR_FALSE;
@@ -742,17 +742,17 @@ GetSpaceBetween(PRInt32       aPrevColIn
         nsIFrame* cgFrame = colFrame->GetParent();
         const nsStyleVisibility* groupVis = cgFrame->GetStyleVisibility();
         PRBool collapseGroup = (NS_STYLE_VISIBILITY_COLLAPSE ==
                                 groupVis->mVisible);
         isCollapsed = collapseCol || collapseGroup;
         if (!isCollapsed)
           space += aTableFrame.GetColumnWidth(colX);
       }
-      if (!isCollapsed && (aTableFrame.GetNumCellsOriginatingInCol(colX) > 0)) {
+      if (!isCollapsed && aTableFrame.ColumnHasCellSpacingBefore(colX)) {
         space += aCellSpacingX;
       }
     }
   }
   return space;
 }
 
 // subtract the heights of aRow's prev in flows from the unpaginated height
@@ -1237,17 +1237,17 @@ nsTableRowFrame::CollapseRowIfNecessary(
             isVisible = PR_TRUE;
           }
           if (!isCollapsed &&  (actualColSpan > 1)) {
             nsTableColFrame* nextColFrame =
               tableFrame->GetColFrame(colX + colIncrement);
             const nsStyleVisibility* nextColVis =
               nextColFrame->GetStyleVisibility();
             if ( (NS_STYLE_VISIBILITY_COLLAPSE != nextColVis->mVisible) &&
-                (tableFrame->GetNumCellsOriginatingInCol(colX + colIncrement) > 0)) {
+                tableFrame->ColumnHasCellSpacingBefore(colX + colIncrement)) {
               cRect.width += cellSpacingX;
             }
           }
         }
         x += cRect.width;
         if (isVisible)
           x += cellSpacingX;
         PRInt32 actualRowSpan = tableFrame->GetEffectiveRowSpan(*cellFrame);
diff -r 9864735a4241 layout/xul/base/src/nsGroupBoxFrame.cpp
--- a/layout/xul/base/src/nsGroupBoxFrame.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/layout/xul/base/src/nsGroupBoxFrame.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -145,17 +145,16 @@ nsGroupBoxFrame::BuildDisplayList(nsDisp
   // REVIEW: Debug borders now painted by nsFrame::BuildDisplayListForChild
 }
 
 void
 nsGroupBoxFrame::PaintBorderBackground(nsIRenderingContext& aRenderingContext,
     nsPoint aPt, const nsRect& aDirtyRect) {
   PRIntn skipSides = 0;
   const nsStyleBorder* borderStyleData = GetStyleBorder();
-  const nsStylePadding* paddingStyleData = GetStylePadding();
   const nsMargin& border = borderStyleData->GetActualBorder();
   nscoord yoff = 0;
   nsPresContext* presContext = PresContext();
 
   nsRect groupRect;
   nsIBox* groupBox = GetCaptionBox(presContext, groupRect);
 
   if (groupBox) {        
@@ -169,18 +168,17 @@ nsGroupBoxFrame::PaintBorderBackground(n
         yoff = (groupRect.height - border.top)/2 + groupRect.y;
   }
 
   nsRect rect(aPt.x, aPt.y + yoff, mRect.width, mRect.height - yoff);
 
   groupRect += aPt;
 
   nsCSSRendering::PaintBackground(presContext, aRenderingContext, this,
-                                  aDirtyRect, rect, *borderStyleData,
-                                  *paddingStyleData, PR_FALSE);
+                                  aDirtyRect, rect, PR_FALSE);
 
   if (groupBox) {
 
     // we should probably use PaintBorderEdges to do this but for now just use clipping
     // to achieve the same effect.
 
     // draw left side
     nsRect clipRect(rect);
diff -r 9864735a4241 media/libvorbis/README_MOZILLA
--- a/media/libvorbis/README_MOZILLA	Mon Sep 22 11:50:03 2008 -0700
+++ b/media/libvorbis/README_MOZILLA	Fri Sep 26 09:30:25 2008 -0500
@@ -1,7 +1,11 @@ The source from this directory was copie
 The source from this directory was copied from the libvorbis-1.2.0
 source distribution using the update.sh script. The only changes made
 were those applied by update.sh and the addition/upate of Makefile.in
 files for the Mozilla build system.
 
 Some files are renamed during the copy to prevent clashes with object
-file names with other Mozilla libraries.
\ No newline at end of file
+file names with other Mozilla libraries.
+
+BUG 455372 - WinCE LibVorbis No FPU Support on WinMobile, removed FPU
+support for builds with WINCE defined.
+
diff -r 9864735a4241 media/libvorbis/lib/os.h
--- a/media/libvorbis/lib/os.h	Mon Sep 22 11:50:03 2008 -0700
+++ b/media/libvorbis/lib/os.h	Fri Sep 26 09:30:25 2008 -0500
@@ -74,17 +74,17 @@ void *_alloca(size_t size);
 #ifndef min
 #  define min(x,y)  ((x)>(y)?(y):(x))
 #endif
 
 #ifndef max
 #  define max(x,y)  ((x)<(y)?(y):(x))
 #endif
 
-#if defined(__i386__) && defined(__GNUC__) && !defined(__BEOS__)
+#if defined(__i386__) && defined(__GNUC__) && !defined(__BEOS__) && !defined(WINCE)
 #  define VORBIS_FPU_CONTROL
 /* both GCC and MSVC are kinda stupid about rounding/casting to int.
    Because of encapsulation constraints (GCC can't see inside the asm
    block and so we end up doing stupid things like a store/load that
    is collectively a noop), we do it this way */
 
 /* we must set up the fpu before this works!! */
 
@@ -111,17 +111,17 @@ static inline int vorbis_ftoi(double f){
                                              truncate precision */
   int i;
   __asm__("fistl %0": "=m"(i) : "t"(f));
   return(i);
 }
 #endif
 
 
-#if defined(_WIN32) && !defined(__GNUC__) && !defined(__BORLANDC__)
+#if defined(_WIN32) && !defined(__GNUC__) && !defined(__BORLANDC__) && !defined(WINCE)
 #  define VORBIS_FPU_CONTROL
 
 typedef ogg_int16_t vorbis_fpu_control;
 
 static __inline int vorbis_ftoi(double f){
 	int i;
 	__asm{
 		fld f
diff -r 9864735a4241 modules/lcms/include/lcms.h
--- a/modules/lcms/include/lcms.h	Mon Sep 22 11:50:03 2008 -0700
+++ b/modules/lcms/include/lcms.h	Fri Sep 26 09:30:25 2008 -0500
@@ -29,17 +29,23 @@
 //   Optimization mode.
 //
 // Note that USE_ASSEMBLER Is fastest by far, but it is limited to Pentium.
 // USE_FLOAT are the generic floating-point routines. USE_C should work on
 // virtually any machine.
 
 //#define USE_FLOAT        1
 // #define USE_C            1
+
+#ifdef WINCE
+// WINCE ARM does not support inline ASM.
+#define USE_C            1
+#else
 #define USE_ASSEMBLER    1
+#endif
 
 // Define this if you are using this package as a DLL (windows only)
 
 // #define LCMS_DLL     1
 // #define LCMS_DLL_BUILD   1
 
 // Uncomment if you are trying the engine in a non-windows environment
 // like linux, SGI, VAX, FreeBSD, BeOS, etc. 
diff -r 9864735a4241 modules/libpr0n/decoders/icon/qt/Makefile.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/modules/libpr0n/decoders/icon/qt/Makefile.in	Fri Sep 26 09:30:25 2008 -0500
@@ -0,0 +1,70 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Mozilla icon channel for Qt.
+#
+# The Initial Developer of the Original Code is Nokia
+# Portions created by the Initial Developer are Copyright (C) 2008
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Oleg Romashin <romaxa@gmail.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../../../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE		= imgicon
+LIBRARY_NAME	= imgiconqt_s
+LIBXUL_LIBRARY	= 1
+
+REQUIRES	= xpcom \
+		  string \
+		  necko \
+		  intl \
+		  mimetype \
+		  gtkqticonsconverter \
+		  $(NULL)
+
+CPPSRCS		= nsIconChannel.cpp
+
+LOCAL_INCLUDES += $(MOZ_QT_CFLAGS)
+
+# we don't want the shared lib, but we want to force the creation of a static lib.
+FORCE_STATIC_LIB = 1
+# This library is used by other shared libs in a static build
+FORCE_USE_PIC = 1
+
+DIRS = public
+
+EXTRA_PP_COMPONENTS = gtkqticonsconverter.js
+
+include $(topsrcdir)/config/rules.mk
+
diff -r 9864735a4241 modules/libpr0n/decoders/icon/qt/gtkqticonsconverter.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/modules/libpr0n/decoders/icon/qt/gtkqticonsconverter.js	Fri Sep 26 09:30:25 2008 -0500
@@ -0,0 +1,173 @@
+/* vim:set ts=2 sw=2 sts=2 cin et: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla icon channel for Qt.
+ *
+ * The Initial Developer of the Original Code is Nokia
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Oleg Romashin <romaxa@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");
+
+
+function GtkQtIconsConverter() { };
+GtkQtIconsConverter.prototype = {
+  classDescription: "Gtk Qt stock icons converter",
+  classID:          Components.ID("{c0783c34-a831-40c6-8c03-98c9f74cca45}"),
+  contractID:       "@mozilla.org/gtkqticonsconverter;1",
+  QueryInterface: XPCOMUtils.generateQI([Components.interfaces.nsIGtkQtIconsConverter]),
+  convert: function(icon) { return this._gtk_qt_icons_table[icon]; },
+  _gtk_qt_icons_table: {
+    'about':
+    0,
+    'add':
+    0,
+    'apply':
+    44, /* QStyle::SP_DialogApplyButton */
+    'cancel':
+    39, /* QStyle::SP_DialogCancelButton */
+    'clear':
+    45, /* QStyle::SP_DialogResetButton  */
+    'color-picker':
+    0,
+    'copy':
+    0,
+    'close':
+    43, /* QStyle::SP_DialogCloseButton */
+    'cut':
+    0,
+    'delete':
+    0,
+    'dialog-error':
+    0,
+    'dialog-info':
+    0,
+    'dialog-question':
+    12, /* QStyle::SP_MessageBoxQuestion */
+    'dialog-warning':
+    10, /* QStyle::SP_MessageBoxWarning */
+    'directory':
+    37, /* QStyle::SP_DirIcon */
+    'file':
+    24, /* QStyle::SP_FileIcon */
+    'find':
+    0,
+    'go-back-ltr':
+    53, /* QStyle::SP_ArrowBack */
+    'go-back-rtl':
+    53, /* QStyle::SP_ArrowBack */
+    'go-back':
+    53, /* QStyle::SP_ArrowBack */
+    'go-forward-ltr':
+    54, /* QStyle::SP_ArrowForward */
+    'go-forward-rtl':
+    54, /* QStyle::SP_ArrowForward */
+    'go-forward':
+    54, /* QStyle::SP_ArrowForward */
+    'go-up':
+    49, /* QStyle::SP_ArrowUp */
+    'goto-first':
+    0,
+    'goto-last':
+    0,
+    'help':
+    7, /* QStyle::SP_TitleBarContextHelpButton */
+    'home':
+    55, /* QStyle::SP_DirHomeIcon */
+    'info':
+    9, /* QStyle::SP_MessageBoxInformation */
+    'jump-to':
+    0,
+    'media-pause':
+    0,
+    'media-play':
+    0,
+    'network':
+    20, /* QStyle::SP_DriveNetIcon */
+    'no':
+    48, /* QStyle::SP_DialogNoButton */
+    'ok':
+    38, /* QStyle::SP_DialogOkButton */
+    'open':
+    21, /* QStyle::SP_DirOpenIcon */
+    'orientation-landscape':
+    0,
+    'orientation-portrait':
+    0,
+    'paste':
+    0,
+    'preferences':
+    34, /* QStyle::SP_FileDialogContentsView */
+    'print-preview':
+    0,
+    'print':
+    0,
+    'properties':
+    0,
+    'quit':
+    0,
+    'redo':
+    0,
+    'refresh':
+    58, /* QStyle::SP_BrowserReload */
+    'remove':
+    0,
+    'revert-to-saved':
+    0,
+    'save-as':
+    42, /* QStyle::SP_DialogSaveButton */
+    'save':
+    42, /* QStyle::SP_DialogSaveButton */
+    'select-all':
+    0,
+    'select-font':
+    0,
+    'stop':
+    59, /* QStyle::SP_BrowserStop */
+    'undelete':
+    0,
+    'undo':
+    0,
+    'yes':
+    47, /* QStyle::SP_DialogYesButton */
+    'zoom-100':
+    0,
+    'zoom-in':
+    0,
+    'zoom-out':
+    0
+  },
+}
+var components = [GtkQtIconsConverter];
+function NSGetModule(compMgr, fileSpec) {
+  return XPCOMUtils.generateModule(components);
+}
+
diff -r 9864735a4241 modules/libpr0n/decoders/icon/qt/nsIconChannel.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/modules/libpr0n/decoders/icon/qt/nsIconChannel.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -0,0 +1,161 @@
+/* vim:set ts=2 sw=2 sts=2 cin et: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla icon channel for Qt.
+ *
+ * The Initial Developer of the Original Code is Nokia
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Oleg Romashin <romaxa@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "nsIMIMEService.h"
+
+#include "nsIStringBundle.h"
+
+#include "nsNetUtil.h"
+#include "nsIURL.h"
+#include "prlink.h"
+
+#include "nsIconChannel.h"
+#include "nsGtkQtIconsConverter.h"
+
+#include <QIcon>
+#include <QStyle>
+#include <QApplication>
+
+NS_IMPL_ISUPPORTS2(nsIconChannel,
+                   nsIRequest,
+                   nsIChannel)
+
+static nsresult
+moz_qicon_to_channel(QImage *image, nsIURI *aURI,
+                     nsIChannel **aChannel)
+{
+  NS_ENSURE_ARG_POINTER(image);
+
+  int width = image->width();
+  int height = image->height();
+
+  NS_ENSURE_TRUE(height < 256 && width < 256 && height > 0 && width > 0,
+                 NS_ERROR_UNEXPECTED);
+
+  const int n_channels = 4;
+  long int buf_size = 2 + n_channels * height * width;
+  PRUint8 * const buf = (PRUint8*)NS_Alloc(buf_size);
+  NS_ENSURE_TRUE(buf, NS_ERROR_OUT_OF_MEMORY);
+  PRUint8 *out = buf;
+
+  *(out++) = width;
+  *(out++) = height;
+
+  const uchar * const pixels = image->bits();
+  int rowextra = image->bytesPerLine() - width * n_channels;
+
+  // encode the RGB data and the A data
+  const uchar * in = pixels;
+  for (int y = 0; y < height; ++y, in += rowextra) {
+    for (int x = 0; x < width; ++x) {
+      PRUint8 r = *(in++);
+      PRUint8 g = *(in++);
+      PRUint8 b = *(in++);
+      PRUint8 a = *(in++);
+#define DO_PREMULTIPLY(c_) PRUint8(PRUint16(c_) * PRUint16(a) / PRUint16(255))
+#ifdef IS_LITTLE_ENDIAN
+      *(out++) = DO_PREMULTIPLY(b);
+      *(out++) = DO_PREMULTIPLY(g);
+      *(out++) = DO_PREMULTIPLY(r);
+      *(out++) = a;
+#else
+      *(out++) = a;
+      *(out++) = DO_PREMULTIPLY(r);
+      *(out++) = DO_PREMULTIPLY(g);
+      *(out++) = DO_PREMULTIPLY(b);
+#endif
+#undef DO_PREMULTIPLY
+    }
+  }
+
+  NS_ASSERTION(out == buf + buf_size, "size miscalculation");
+
+  nsresult rv;
+  nsCOMPtr<nsIStringInputStream> stream =
+    do_CreateInstance("@mozilla.org/io/string-input-stream;1", &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = stream->AdoptData((char*)buf, buf_size);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  return NS_NewInputStreamChannel(aChannel, aURI, stream,
+                                  NS_LITERAL_CSTRING("image/icon"));
+}
+
+nsresult
+nsIconChannel::Init(nsIURI* aURI)
+{
+
+  nsCOMPtr<nsIMozIconURI> iconURI = do_QueryInterface(aURI);
+  NS_ASSERTION(iconURI, "URI is not an nsIMozIconURI");
+
+  nsCAutoString stockIcon;
+  iconURI->GetStockIcon(stockIcon);
+
+  nsCAutoString iconSizeString;
+  iconURI->GetIconSize(iconSizeString);
+
+  PRUint32 desiredImageSize;
+  iconURI->GetImageSize(&desiredImageSize);
+
+  nsCAutoString iconStateString;
+  iconURI->GetIconState(iconStateString);
+  bool disabled = iconStateString.EqualsLiteral("disabled");
+
+  QStyle::StandardPixmap sp_icon = (QStyle::StandardPixmap)0;
+  nsCOMPtr <nsIGtkQtIconsConverter> converter = do_GetService("@mozilla.org/gtkqticonsconverter;1");
+  if (converter) {
+    PRInt32 res = 0;
+    stockIcon.Cut(0,4);
+    converter->Convert(stockIcon.get(), &res);
+    sp_icon = (QStyle::StandardPixmap)res;
+    // printf("ConvertIcon: icon:'%s' -> res:%i\n", stockIcon.get(), res);
+  }
+  if (!sp_icon)
+    return NS_ERROR_FAILURE;
+
+  QStyle *style = qApp->style();
+  NS_ENSURE_TRUE(style, NS_ERROR_NULL_POINTER);
+  QPixmap pixmap = style->standardIcon(sp_icon).pixmap(desiredImageSize, desiredImageSize, disabled?QIcon::Disabled:QIcon::Normal);
+  QImage image = pixmap.toImage();
+
+  return moz_qicon_to_channel(&image, iconURI,
+                              getter_AddRefs(mRealChannel));
+}
diff -r 9864735a4241 modules/libpr0n/decoders/icon/qt/nsIconChannel.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/modules/libpr0n/decoders/icon/qt/nsIconChannel.h	Fri Sep 26 09:30:25 2008 -0500
@@ -0,0 +1,75 @@
+/* vim:set ts=2 sw=2 sts=2 cin et: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla icon channel for Qt.
+ *
+ * The Initial Developer of the Original Code is Nokia
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Oleg Romashin <romaxa@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsIconChannel_h_
+#define nsIconChannel_h_
+
+#include "nsIChannel.h"
+#include "nsIStreamListener.h"
+#include "nsIURI.h"
+#include "nsIIconURI.h"
+#include "nsCOMPtr.h"
+
+/**
+ * This class is the gnome implementation of nsIconChannel. It basically asks
+ * qt for an icon, and creates a new channel for
+ * that file to which all calls will be proxied.
+ */
+class nsIconChannel : public nsIChannel {
+  public:
+    NS_DECL_ISUPPORTS
+    NS_FORWARD_NSIREQUEST(mRealChannel->)
+    NS_FORWARD_NSICHANNEL(mRealChannel->)
+
+    nsIconChannel() {}
+    ~nsIconChannel() {}
+
+    /**
+     * Called by nsIconProtocolHandler after it creates this channel.
+     * Must be called before calling any other function on this object.
+     * If this method fails, no other function must be called on this object.
+     */
+    NS_HIDDEN_(nsresult) Init(nsIURI* aURI);
+  private:
+    /**
+     * The channel to the temp icon file (e.g. to /tmp/2qy9wjqw.html).
+     * Will always be non-null after a successful Init.
+     */
+    nsCOMPtr<nsIChannel> mRealChannel;
+};
+
+#endif
diff -r 9864735a4241 modules/libpr0n/decoders/icon/qt/public/Makefile.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/modules/libpr0n/decoders/icon/qt/public/Makefile.in	Fri Sep 26 09:30:25 2008 -0500
@@ -0,0 +1,50 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Mozilla icon channel for Qt.
+#
+# The Initial Developer of the Original Code is Nokia
+# Portions created by the Initial Developer are Copyright (C) 2008
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Oleg Romashin <romaxa@gmail.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../../../../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE		= gtkqticonsconverter
+XPIDL_MODULE	= gtkqticonsconverter
+
+XPIDLSRCS	= nsGtkQtIconsConverter.idl
+
+include $(topsrcdir)/config/rules.mk
+
diff -r 9864735a4241 modules/libpr0n/decoders/icon/qt/public/nsGtkQtIconsConverter.idl
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/modules/libpr0n/decoders/icon/qt/public/nsGtkQtIconsConverter.idl	Fri Sep 26 09:30:25 2008 -0500
@@ -0,0 +1,44 @@
+/* vim:set ts=2 sw=2 sts=2 cin et: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla icon channel for Qt.
+ *
+ * The Initial Developer of the Original Code is Nokia
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Oleg Romashin <romaxa@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsISupports.idl"
+
+[scriptable, uuid(c0783c34-a831-40c6-8c03-98c9f74cca45)]
+interface nsIGtkQtIconsConverter : nsISupports
+{
+  long convert(in string icon);
+};
diff -r 9864735a4241 storage/public/mozIStorageError.idl
--- a/storage/public/mozIStorageError.idl	Mon Sep 22 11:50:03 2008 -0700
+++ b/storage/public/mozIStorageError.idl	Fri Sep 26 09:30:25 2008 -0500
@@ -33,16 +33,22 @@
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsISupports.idl"
+
+%{C++
+#ifdef ERROR
+#undef ERROR
+#endif
+%}
 
 [scriptable, uuid(1f350f96-7023-434a-8864-40a1c493aac1)]
 interface mozIStorageError : nsISupports {
 
   /**
    * General SQL error or missing database.
    */
   const long ERROR = 1;
diff -r 9864735a4241 storage/src/mozStorageRow.cpp
--- a/storage/src/mozStorageRow.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/storage/src/mozStorageRow.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -220,18 +220,18 @@ mozStorageRow::GetString(PRUint32 aIndex
 
 NS_IMETHODIMP
 mozStorageRow::GetBlob(PRUint32 aIndex, PRUint32 *_size, PRUint8 **_blob)
 {
   if (aIndex >= mNumCols)
     return NS_ERROR_ILLEGAL_VALUE;
 
   PRUint16 type;
-  nsIID interface;
-  return mData.ObjectAt(aIndex)->GetAsArray(&type, &interface, _size,
+  nsIID interfaceIID;
+  return mData.ObjectAt(aIndex)->GetAsArray(&type, &interfaceIID, _size,
                                             reinterpret_cast<void **>(_blob));
 }
 
 NS_IMETHODIMP
 mozStorageRow::GetIsNull(PRUint32 aIndex, PRBool *_isNull)
 {
   if (aIndex >= mNumCols)
     return NS_ERROR_ILLEGAL_VALUE;
diff -r 9864735a4241 testing/mochitest/harness-overlay.xul
--- a/testing/mochitest/harness-overlay.xul	Mon Sep 22 11:50:03 2008 -0700
+++ b/testing/mochitest/harness-overlay.xul	Fri Sep 26 09:30:25 2008 -0500
@@ -41,18 +41,21 @@
       var srvScope = {};
       scriptLoader.loadSubScript("chrome://mochikit/content/server.js",
                                  srvScope);
 
       // generate our test list
       srvScope.makeTags();
       var url = "chrome://mochikit/content/" + dir + "/";
       var [links, count] = srvScope.list(url, chromeDir, true);
-      var tableContent = srvScope.linksToTableRows(links, 0);
+      var listContent = srvScope.linksToListItems(links);
+      var tableContent = srvScope.linksToTableRows(links);
       function populate() {
+        $("list-holder").setAttribute("rowspan", 1 + count);
+        $("test-list").innerHTML += listContent;
         $("test-table").innerHTML += tableContent;
         $("wrapper").innerHTML += " "; // redraw the table
       }
       gTestList = eval(srvScope.jsonArrayOfTestFiles(links));
       populate();
       hookup();
 
       // if we got passed a test path, just run that single test
@@ -91,17 +94,19 @@
           <br />
         </div>
         <div id="wrapper">
           <table cellpadding="0" cellspacing="0" id="test-table">
             <tr>
               <td>Passed</td>
               <td>Failed</td>
               <td>Todo</td>
-              <td>Test Files</td>
+              <td id="list-holder">
+                <ul class="top" id="test-list"><li><b>Test Files</b></li></ul>
+              </td>
             </tr>
           </table>
         </div>
       </div>
     </body>
   </vbox>
 </window>
 
diff -r 9864735a4241 testing/mochitest/server.js
--- a/testing/mochitest/server.js	Mon Sep 22 11:50:03 2008 -0700
+++ b/testing/mochitest/server.js	Fri Sep 26 09:30:25 2008 -0500
@@ -394,55 +394,30 @@ function linksToListItems(links)
 
   }
   return response;
 }
 
 /**
  * Transform nested hashtables of paths to a flat table rows.
  */
-function linksToTableRows(links, recursionLevel)
+function linksToTableRows(links)
 {
   var response = "";
   for (var [link, value] in links) {
     var classVal = (!isTest(link) && !(value instanceof Object))
       ? "non-test invisible"
       : "";
-
-    spacer = "padding-left: " + (10 * recursionLevel) + "px";
-
     if (value instanceof Object) {
       response += TR({class: "dir", id: "tr-" + link },
-                     TD({colspan: "3"}, "&#160;"),
-                     TD({style: spacer},
-                        A({href: link}, link)));
-      response += linksToTableRows(value, recursionLevel + 1);
+                     TD({colspan: "3"},"&#160;"));
+      response += linksToTableRows(value);
     } else {
-      var bug_title = link.match(/test_bug\S+/);
-      var bug_num = null;
-      if (bug_title != null) {
-          bug_num = bug_title[0].match(/\d+/);
-      }
-      if ((bug_title == null) || (bug_num == null)) {
-        response += TR({class: classVal, id: "tr-" + link },
-                       TD("0"),
-                       TD("0"),
-                       TD("0"),
-                       TD({style: spacer},
-                          A({href: link}, link)));
-      } else {
-        var bug_url = "https://bugzilla.mozilla.org/show_bug.cgi?id=" + bug_num;
-        response += TR({class: classVal, id: "tr-" + link },
-                       TD("0"),
-                       TD("0"),
-                       TD("0"),
-                       TD({style: spacer},
-                          A({href: link}, link), " - ",
-                          A({href: bug_url}, "Bug " + bug_num)));
-      }
+      response += TR({class: classVal, id: "tr-" + link},
+                     TD("0"), TD("0"), TD("0"));
     }
   }
   return response;
 }
 
 function arrayOfTestFiles(linkArray, fileArray, testPattern) {
   for (var [link, value] in linkArray) {
     if (value instanceof Object) {
@@ -544,18 +519,25 @@ function testListing(metadata, response)
           ),
           DIV({class: "clear"}),
           DIV({class: "toggle"},
             A({href: "#", id: "toggleNonTests"}, "Show Non-Tests"),
             BR()
           ),
     
           TABLE({cellpadding: 0, cellspacing: 0, id: "test-table"},
-            TR(TD("Passed"), TD("Failed"), TD("Todo"), TD("Test Files")),
-            linksToTableRows(links, 0)
+            TR(TD("Passed"), TD("Failed"), TD("Todo"), 
+                TD({rowspan: count+1},
+                   UL({class: "top"},
+                      LI(B("Test Files")),        
+                      linksToListItems(links)
+                      )
+                )
+            ),
+            linksToTableRows(links)
           ),
           DIV({class: "clear"})
         )
       )
     )
   );
 }
 
diff -r 9864735a4241 testing/mochitest/tests/SimpleTest/TestRunner.js
--- a/testing/mochitest/tests/SimpleTest/TestRunner.js	Mon Sep 22 11:50:03 2008 -0700
+++ b/testing/mochitest/tests/SimpleTest/TestRunner.js	Fri Sep 26 09:30:25 2008 -0500
@@ -192,16 +192,17 @@ TestRunner.updateUI = function() {
   } else if (passCount > 0) {
     indicator.innerHTML = "Status: Pass";
     indicator.style.backgroundColor = "green";
   }
 
   // Set the table values
   var trID = "tr-" + $('current-test-path').innerHTML;
   var row = $(trID);
-  var tds = row.getElementsByTagName("td");
-  tds[0].style.backgroundColor = results.notOK > 0 ? "#f00" : "#0d0";
-  tds[0].textContent = results.OK;
-  tds[1].style.backgroundColor = results.notOK > 0 ? "#f00" : "#0d0";
-  tds[1].textContent = results.notOK;
-  tds[2].style.backgroundColor = results.todo > 0 ? "orange" : "#0d0";
-  tds[2].textContent = results.todo;
+  replaceChildNodes(row,
+    TD({'style':
+        {'backgroundColor': results.notOK > 0 ? "#f00":"#0d0"}}, results.OK),
+    TD({'style':
+        {'backgroundColor': results.notOK > 0 ? "#f00":"#0d0"}}, results.notOK),
+    TD({'style': {'backgroundColor':
+                   results.todo > 0 ? "orange":"#0d0"}}, results.todo)
+  );
 }
diff -r 9864735a4241 toolkit/components/Makefile.in
--- a/toolkit/components/Makefile.in	Mon Sep 22 11:50:03 2008 -0700
+++ b/toolkit/components/Makefile.in	Fri Sep 26 09:30:25 2008 -0500
@@ -48,21 +48,16 @@ ifdef MOZ_ENABLE_XREMOTE
 ifdef MOZ_ENABLE_XREMOTE
 DIRS += remote
 endif
 DIRS += \
         urlformatter \
         contentprefs \
         microformats \
         places \
-        $(NULL)
-
-# These component dirs are built only for XUL apps
-
-DIRS += \
 	apppicker \
 	filepicker \
 	console \
 	exthelper \
 	viewconfig \
 	typeaheadfind \
 	parentalcontrols \
 	$(NULL)
@@ -90,28 +85,29 @@ endif
 endif
 
 ifndef MOZ_SUITE
 ifndef MOZ_THUNDERBIRD
 DIRS +=	search
 endif
 endif
 
-ifdef MOZ_THUNDERBIRD
-DIRS += autocomplete/public
-else
+ifdef MOZ_XUL
+DIRS += \
+	autocomplete \
+	$(NULL)
+endif
+
+ifndef MOZ_THUNDERBIRD
 DIRS +=	\
 	cookie \
 	$(NULL)
 
 ifdef MOZ_XUL
-DIRS += \
-	autocomplete \
-	satchel \
-	$(NULL)
+DIRS += satchel
 endif # MOZ_XUL
 
 ifdef MOZ_SUITE
 # Suite can't use passwordmgr because mail still depends on wallet (bug 239131)
 DIRS += passwordmgr/public
 else
 DIRS += passwordmgr
 endif # MOZ_SUITE
diff -r 9864735a4241 toolkit/components/passwordmgr/src/storage-Legacy.js
--- a/toolkit/components/passwordmgr/src/storage-Legacy.js	Mon Sep 22 11:50:03 2008 -0700
+++ b/toolkit/components/passwordmgr/src/storage-Legacy.js	Fri Sep 26 09:30:25 2008 -0500
@@ -857,17 +857,21 @@ LoginManagerStorage_legacy.prototype = {
                         PASSFIELD : 5, PASSVALUE : 6, ACTIONURL : 7,
                         FILLER : 8 };
         var parseState = STATE.HEADER;
 
         var processEntry = false;
 
         do {
             var hasMore = lineStream.readLine(line);
-            line.value = this._utfConverter.ConvertToUnicode(line.value);
+            try {
+              line.value = this._utfConverter.ConvertToUnicode(line.value);
+            } catch (e) {
+              this.log("Bad UTF8 conversion: " + line.value);
+            }
 
             switch (parseState) {
                 // Check file header
                 case STATE.HEADER:
                     if (line.value == "#2c") {
                         formatVersion = 0x2c;
                     } else if (line.value == "#2d") {
                         formatVersion = 0x2d;
diff -r 9864735a4241 toolkit/components/passwordmgr/test/unit/data/signons-454708.txt
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/components/passwordmgr/test/unit/data/signons-454708.txt	Fri Sep 26 09:30:25 2008 -0500
@@ -0,0 +1,10 @@
+#2e
+.
+https://FcK.jp
+put_user_here
+MDoEEPgAAAAAAAAAAAAAAAAAAAEwFAYIKoZIhvcNAwcECEnlbhAkNBbBBBCexD5eaffSLGH/ORiFlQ4X
+*put_pw_here
+MDoEEPgAAAAAAAAAAAAAAAAAAAEwFAYIKoZIhvcNAwcECHmiTaseYjkkBBAA0ILJTFSa5CnlpD5PTEYR
+https://FcK.jp
+---
+.
diff -r 9864735a4241 toolkit/components/passwordmgr/test/unit/test_storage_legacy_3.js
--- a/toolkit/components/passwordmgr/test/unit/test_storage_legacy_3.js	Mon Sep 22 11:50:03 2008 -0700
+++ b/toolkit/components/passwordmgr/test/unit/test_storage_legacy_3.js	Fri Sep 26 09:30:25 2008 -0500
@@ -581,14 +581,41 @@ storage.setLoginSavingEnabled(utfHost, f
 
 LoginTest.checkStorageData(storage, [utfHost], [utfUser1, utfUser2]);
 
 testdesc = "[flush and reload for verification]"
 storage = LoginTest.reloadStorage(OUTDIR, "output-451155.txt");
 LoginTest.checkStorageData(storage, [utfHost], [utfUser1, utfUser2]);
 
 
+/*
+ * ---------------------- Bug 454708 ----------------------
+ * Check that previous saved entries that are not valid UTF8
+ * are read without blowing up.
+ */
+
+/* ========== 16 ========== */
+testnum++;
+testdesc = "ensure bogus UTF8 strings don't cause failures."
+
+var badHost = "https://FcK" + String.fromCharCode(0x8a) + ".jp";
+var bad8User = Cc["@mozilla.org/login-manager/loginInfo;1"].
+               createInstance(Ci.nsILoginInfo);
+bad8User.init(badHost, badHost, null,
+              "dummydude", "itsasecret", "put_user_here", "put_pw_here");
+
+storage = LoginTest.initStorage(INDIR, "signons-454708.txt",
+                               OUTDIR, "output-454708.txt");
+LoginTest.checkStorageData(storage, [], [bad8User]);
+
+// The output file should contain valid UTF8 now, but the resulting
+// JS string value remains the same.
+
+testdesc = "[flush and reload for verification]"
+storage = LoginTest.reloadStorage(OUTDIR, "output-454708.txt");
+LoginTest.checkStorageData(storage, [], [bad8User]);
+
 /* ========== end ========== */
 } catch (e) {
     throw ("FAILED in test #" + testnum + " -- " + testdesc + ": " + e);
 }
 
 };
diff -r 9864735a4241 toolkit/components/viewsource/content/viewSourceUtils.js
--- a/toolkit/components/viewsource/content/viewSourceUtils.js	Mon Sep 22 11:50:03 2008 -0700
+++ b/toolkit/components/viewsource/content/viewSourceUtils.js	Fri Sep 26 09:30:25 2008 -0500
@@ -124,16 +124,21 @@ var gViewSourceUtils = {
 
           var webBrowserPersist = Components
                                   .classes["@mozilla.org/embedding/browser/nsWebBrowserPersist;1"]
                                   .createInstance(this.mnsIWebBrowserPersist);
           // the default setting is to not decode. we need to decode.
           webBrowserPersist.persistFlags = this.mnsIWebBrowserPersist.PERSIST_FLAGS_REPLACE_EXISTING_FILES;
           webBrowserPersist.progressListener = this.viewSourceProgressListener;
           webBrowserPersist.saveURI(uri, null, null, null, null, file);
+
+          // register the file to be deleted on app exit
+          Components.classes["@mozilla.org/uriloader/external-helper-app-service;1"]
+                    .getService(Components.interfaces.nsPIExternalAppLauncher)
+                    .deleteTemporaryFileOnExit(file);
         } else {
           // we'll use nsIWebPageDescriptor to get the source because it may not have to refetch
           // the file from the server
           var webShell = Components.classes["@mozilla.org/webshell;1"].createInstance();
           this.viewSourceProgressListener.webShell = webShell;
           var progress = webShell.QueryInterface(this.mnsIWebProgress);
           progress.addProgressListener(this.viewSourceProgressListener,
                                        this.mnsIWebProgress.NOTIFY_STATE_DOCUMENT);
@@ -235,16 +240,21 @@ var gViewSourceUtils = {
             coStream.init(foStream, this.data.doc.characterSet, 0, null);
 
             // write the source to the file
             coStream.writeString(webNavigation.document.body.textContent);
           
             // clean up
             coStream.close();
             foStream.close();
+
+            // register the file to be deleted on app exit
+            Components.classes["@mozilla.org/uriloader/external-helper-app-service;1"]
+                      .getService(Components.interfaces.nsPIExternalAppLauncher)
+                      .deleteTemporaryFileOnExit(this.file);
           }
 
           // Determine the command line arguments to pass to the editor.
           // We currently support a %LINE% placeholder which is set to the passed
           // line number (or to 0 if there's none)
           var editorArgs = [];
           var prefs = Components.classes["@mozilla.org/preferences-service;1"]
                                 .getService(Components.interfaces.nsIPrefBranch);
diff -r 9864735a4241 toolkit/content/Makefile.in
--- a/toolkit/content/Makefile.in	Mon Sep 22 11:50:03 2008 -0700
+++ b/toolkit/content/Makefile.in	Fri Sep 26 09:30:25 2008 -0500
@@ -53,27 +53,29 @@ DEFINES += \
   -DCC_VERSION="$(CC_VERSION)" \
   -DCFLAGS="$(CFLAGS)" \
   -DCXX="$(CXX)" \
   -DCXX_VERSION="$(CXX_VERSION)" \
   -DCXXFLAGS="$(CXXFLAGS)" \
   -DCPPFLAGS="$(CPPFLAGS)" \
   $(NULL)
 
-CHANGESET := $(shell hg identify -i $(topsrcdir) 2>/dev/null)
+CHANGESET := $(shell cd $(topsrcdir) && hg identify 2>/dev/null | cut -f1 -d' ')
 ifdef CHANGESET
 DEFINES += -DSOURCE_CHANGESET="$(CHANGESET)"
 endif
 
 # strip a trailing slash from the repo URL because it's not always present,
 # and we want to construct a working URL in buildconfig.html
 # make+shell+sed = awful
 _dollar=$$
-SOURCE_REPO := $(shell hg -R $(topsrcdir) showconfig paths.default 2>/dev/null | sed -e "s/^ssh:/http:/" -e "s/\/$(_dollar)//" )
-ifdef SOURCE_REPO
+SOURCE_REPO := $(shell cd $(topsrcdir) && hg showconfig paths.default 2>/dev/null | head -n1 | sed -e "s/^ssh:/http:/" -e "s/\/$(_dollar)//" )
+# extra sanity check for old versions of hg
+# that don't support showconfig
+ifeq (http,$(patsubst http%,http,$(SOURCE_REPO)))
 DEFINES += -DSOURCE_REPO="$(SOURCE_REPO)"
 endif
 
 ifdef ENABLE_TESTS
 DIRS += tests
 endif
 
 EXTRA_JS_MODULES = debug.js
diff -r 9864735a4241 toolkit/mozapps/installer/windows/nsis/common.nsh
--- a/toolkit/mozapps/installer/windows/nsis/common.nsh	Mon Sep 22 11:50:03 2008 -0700
+++ b/toolkit/mozapps/installer/windows/nsis/common.nsh	Fri Sep 26 09:30:25 2008 -0500
@@ -3184,19 +3184,21 @@
   !endif
 !macroend
 
 /**
  * If present removes the VirtualStore directory for this installation. Uses the
  * program files directory path and the current install location to determine
  * the sub-directory in the VirtualStore directory.
  *
- * $R7 = stores the value of the open command and the path macros return values
- * $R8 = stores the handler's registry key name
- * $R9 = _DEFAULT_VALUE and _RESULT
+ * $R5 = various path values.
+ * $R6 = length of the long path to $PROGRAMFILES
+ * $R7 = length of the long path to $INSTDIR
+ * $R8 = long path to $PROGRAMFILES
+ * $R9 = long path to $INSTDIR
  */
 !macro CleanVirtualStore
 
   !ifndef ${_MOZFUNC_UN}CleanVirtualStore
     !define _MOZFUNC_UN_TMP ${_MOZFUNC_UN}
     !insertmacro ${_MOZFUNC_UN_TMP}GetLongPath
     !undef _MOZFUNC_UN
     !define _MOZFUNC_UN ${_MOZFUNC_UN_TMP}
@@ -3205,49 +3207,48 @@
     !verbose push
     !verbose ${_MOZFUNC_VERBOSE}
     !define ${_MOZFUNC_UN}CleanVirtualStore "!insertmacro ${_MOZFUNC_UN}CleanVirtualStoreCall"
 
     Function ${_MOZFUNC_UN}CleanVirtualStore
       Push $R9
       Push $R8
       Push $R7
-
-      StrLen $R9 "$INSTDIR"
-
-      ; Get the installation's directory name including the preceding slash
-      start:
-      IntOp $R8 $R8 - 1
-      IntCmp $R8 -$R9 end end +1
-      StrCpy $R7 "$INSTDIR" 1 $R8
-      StrCmp $R7 "\" +1 start
-
-      StrCpy $R9 "$INSTDIR" "" $R8
+      Push $R6
+      Push $R5
+
+      ${${_MOZFUNC_UN}GetLongPath} "$INSTDIR" $R9
+      StrCmp $R9 "" end +1
+      ${${_MOZFUNC_UN}GetLongPath} "$PROGRAMFILES" $R8
       StrCmp $R8 "" end +1
 
-      ClearErrors
-      ${${_MOZFUNC_UN}GetLongPath} "$PROGRAMFILES$R9" $R8
-      StrCmp $R8 "" end +1
-      ${${_MOZFUNC_UN}GetLongPath} "$INSTDIR" $R7
-      StrCmp $R7 "" end +1
-
-      ; Compare the installation's directory path with the path created by
-      ; concatenating the installation's directory name and the path to the
-      ; program files directory.
-      StrCmp "$R7" "$R8" +1 end
-
-      StrCpy $R8 "$PROGRAMFILES" "" 2 ; Remove the drive letter and colon
-      StrCpy $R7 "$PROFILE\AppData\Local\VirtualStore$R8$R9"
-
-      IfFileExists "$R7" 0 end
-      RmDir /r "$R7"
-
-      end:
-      ClearErrors
-
+      StrLen $R7 "$R9"
+      StrLen $R6 "$R8"
+      ; Only continue If the length of $INSTDIR is greater than the length of
+      ; $PROGRAMFILES
+      IntCmp $R7 $R6 end end +1
+
+      ; Copy from the start of $INSTDIR the length of $PROGRAMFILES 
+      StrCpy $R5 "$R9" $R6
+      StrCmp "$R5" "$R8" +1 end ; Check if $INSTDIR is under $PROGRAMFILES
+
+      ; Remove the drive letter and colon from the $INSTDIR long path
+      StrCpy $R5 "$R9" "" 2
+      StrCpy $R5 "$PROFILE\AppData\Local\VirtualStore$R5"
+      ${${_MOZFUNC_UN}GetLongPath} "$R5" $R5
+      StrCmp $R5 "" end +1
+
+      IfFileExists "$R5" +1 end
+      RmDir /r "$R5"
+
+      end:
+      ClearErrors
+
+      Pop $R5
+      Pop $R6
       Pop $R7
       Pop $R8
       Pop $R9
     FunctionEnd
 
     !verbose pop
   !endif
 !macroend
@@ -3283,21 +3284,21 @@
 
 /**
  * If present removes the updates directory located in the profile's local
  * directory for this installation.
  *
  * @param   _REL_PROFILE_PATH
  *          The relative path to the profile directory from $LOCALAPPDATA.
  *
- * $R6 = stores single characters to find the first "\" from the right of
- *       $INSTDIR and the long path to $INSTDIR
- * $R7 = long path of the concatenation of Program Files and the  installation
- *       directory name (e.g. $PROGRAMFILES$R68)
- * $R8 = installation directory name
+ * $R4 = various path values.
+ * $R5 = length of the long path to $PROGRAMFILES
+ * $R6 = length of the long path to $INSTDIR
+ * $R7 = long path to $PROGRAMFILES
+ * $R8 = long path to $INSTDIR
  * $R9 = _REL_PROFILE_PATH
  */
 !macro CleanUpdatesDir
 
   !ifndef ${_MOZFUNC_UN}CleanUpdatesDir
     !define _MOZFUNC_UN_TMP ${_MOZFUNC_UN}
     !insertmacro ${_MOZFUNC_UN_TMP}GetLongPath
     !undef _MOZFUNC_UN
@@ -3308,51 +3309,52 @@
     !verbose ${_MOZFUNC_VERBOSE}
     !define ${_MOZFUNC_UN}CleanUpdatesDir "!insertmacro ${_MOZFUNC_UN}CleanUpdatesDirCall"
 
     Function ${_MOZFUNC_UN}CleanUpdatesDir
       Exch $R9
       Push $R8
       Push $R7
       Push $R6
-
-      StrCmp $R9 "" end +1   ; The path to the app's profiles is required
-      StrLen $R8 "$INSTDIR"
-
-      ; Get the installation's directory name including the preceding slash
-      start:
-      IntOp $R7 $R7 - 1
-      IntCmp $R7 -$R8 end end +1
-      StrCpy $R6 "$INSTDIR" 1 $R7
-      StrCmp $R6 "\" +1 start
-
-      StrCpy $R8 "$INSTDIR" "" $R7
+      Push $R5
+      Push $R4
+
+      StrCmp $R9 "" end +1 ; The relative path to the app's profiles is required
+      ${${_MOZFUNC_UN}GetLongPath} "$INSTDIR" $R8
       StrCmp $R8 "" end +1
-
-      ClearErrors
-      ${${_MOZFUNC_UN}GetLongPath} "$PROGRAMFILES$R8" $R7
+      ${${_MOZFUNC_UN}GetLongPath} "$PROGRAMFILES" $R7
       StrCmp $R7 "" end +1
-      ${${_MOZFUNC_UN}GetLongPath} "$INSTDIR" $R6
-      StrCmp $R6 "" end +1
-
-      ; Compare the installation's directory path with the path created by
-      ; concatenating the installation's directory name and the path to the
-      ; program files directory.
-      StrCmp "$R6" "$R7" +1 end
-
-      StrCpy $R6 "$LOCALAPPDATA\$R9$R8"
-
-      ${${_MOZFUNC_UN}GetLongPath} "$R6" $R6
-      StrCmp $R6 "" end +1
-      IfFileExists "$R6\updates" +1 end
-      RmDir /r "$R6"
-
-      end:
-      ClearErrors
-
+
+      StrLen $R6 "$R8"
+      StrLen $R5 "$R7"
+      ; Only continue If the length of $INSTDIR is greater than the length of
+      ; $PROGRAMFILES
+      IntCmp $R6 $R5 end end +1
+
+      ; Copy from the start of $INSTDIR the length of $PROGRAMFILES 
+      StrCpy $R4 "$R8" $R5
+      StrCmp "$R4" "$R7" +1 end ; Check if $INSTDIR is under $PROGRAMFILES
+
+      ; Copy the relative path to $INSTDIR from $PROGRAMFILES
+      StrCpy $R4 "$R8" "" $R5
+
+      ; Concatenate the path to $LOCALAPPDATA the relative profile path and the
+      ; relative path to $INSTDIR from $PROGRAMFILES
+      StrCpy $R4 "$LOCALAPPDATA\$R9$R4"
+      ${${_MOZFUNC_UN}GetLongPath} "$R4" $R4
+      StrCmp $R4 "" end +1
+
+      IfFileExists "$R4\updates" +1 end
+      RmDir /r "$R4"
+
+      end:
+      ClearErrors
+
+      Pop $R4
+      Pop $R5
       Pop $R6
       Pop $R7
       Pop $R8
       Exch $R9
     FunctionEnd
 
     !verbose pop
   !endif
@@ -3818,17 +3820,17 @@
  * @param   _PATH_TO_DESTINATION
  *          Destination path to copy the files to. This must not end with a \.
  *
  * @param   _PREFIX_ERROR_CREATEDIR
  *          Prefix for the directory creation error message. The directory path
  *          will be inserted below this string.
  *
  * @param   _SUFFIX_ERROR_CREATEDIR
- *          Prefix for the directory creation error message. The directory path
+ *          Suffix for the directory creation error message. The directory path
  *          will be inserted above this string.
  *
  * $0  = destination file's parent directory used in the create_dir label
  * $R0 = copied value from $R6 (e.g. _PATH_TO_SOURCE)
  * $R1 = copied value from $R7 (e.g. _PATH_TO_DESTINATION)
  * $R2 = string length of the path to source
  * $R3 = relative path from the path to source
  * $R4 = copied value from $R8 (e.g. _PREFIX_ERROR_CREATEDIR)
diff -r 9864735a4241 tools/jprof/leaky.cpp
--- a/tools/jprof/leaky.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/tools/jprof/leaky.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -286,18 +286,18 @@ void leaky::open()
 
 //----------------------------------------------------------------------
 
 
 static int symbolOrder(void const* a, void const* b)
 {
   Symbol const* ap = (Symbol const *)a;
   Symbol const* bp = (Symbol const *)b;
-  ptrdiff_t diff = ap->address - bp->address;
-  return (diff == 0) ? 0 : ((diff > 0) ? 1 : -1);
+  return ap->address == bp->address ? 0 :
+    (ap->address > bp->address ? 1 : -1);
 }
 
 void leaky::ReadSharedLibrarySymbols()
 {
   LoadMapEntry* lme = loadMap;
   while (NULL != lme) {
     ReadSymbols(lme->name, lme->address);
     lme = lme->next;
diff -r 9864735a4241 uriloader/exthandler/tests/unit/test_punycodeURIs.js
--- a/uriloader/exthandler/tests/unit/test_punycodeURIs.js	Mon Sep 22 11:50:03 2008 -0700
+++ b/uriloader/exthandler/tests/unit/test_punycodeURIs.js	Fri Sep 26 09:30:25 2008 -0500
@@ -75,16 +75,27 @@ function checkFile() {
   // have to check for the argument mac gives us.
   if (data.substring(0, 7) != "-psn_0_")
     do_check_eq(data, kExpectedURI);
 
   do_test_finished();
 }
 
 function run_test() {
+  // don't run the test on Mac OS 10.4 - see bug 447999
+  const httpHandler =
+    Components.classes["@mozilla.org/network/protocol;1?name=http"]
+              .getService(Components.interfaces.nsIHttpProtocolHandler);
+  const oscpu = httpHandler.oscpu;
+  if (oscpu.match(/Mac OS X 10.4/)) {
+    dump("This test is not run on Mac OS 10.4 because it fails for unknown " +
+         "reasons. See bug 447999.\n");
+    return;
+  }
+
   // set up the uri to test with
   var ioService = Components.classes["@mozilla.org/network/io-service;1"].
     getService(Components.interfaces.nsIIOService);
 
   // set up the local handler object
   var localHandler = 
     Components.classes["@mozilla.org/uriloader/local-handler-app;1"].
     createInstance(Components.interfaces.nsILocalHandlerApp);
diff -r 9864735a4241 widget/src/cocoa/nsChildView.mm
--- a/widget/src/cocoa/nsChildView.mm	Mon Sep 22 11:50:03 2008 -0700
+++ b/widget/src/cocoa/nsChildView.mm	Fri Sep 26 09:30:25 2008 -0500
@@ -491,33 +491,16 @@ nsresult nsChildView::StandardCreate(nsI
     mParentView = reinterpret_cast<NSView*>(aNativeParent);
   
   // create our parallel NSView and hook it up to our parent. Recall
   // that NS_NATIVE_WIDGET is the NSView.
   NSRect r;
   GeckoRectToNSRect(mBounds, r);
   mView = [CreateCocoaView(r) retain];
   if (!mView) return NS_ERROR_FAILURE;
-  
-#if DEBUG
-  // if our parent is a popup window, we're most certainly coming from a <select> list dropdown which
-  // we handle in a different way than other platforms. It's ok that we don't have a parent
-  // view because we bailed before even creating the cocoa widgetry and as a result, we
-  // don't need to assert. However, if that's not the case, we definitely want to assert
-  // to show views aren't getting correctly parented.
-  if (aParent) {
-    nsWindowType windowType;
-    aParent->GetWindowType(windowType);
-    if (windowType != eWindowType_popup)
-      NS_ASSERTION(mParentView && mView, "couldn't hook up new NSView in hierarchy");
-  }
-  else {
-    NS_ASSERTION(mParentView && mView, "couldn't hook up new NSView in hierarchy");
-  }
-#endif
 
   // If this view was created in a Gecko view hierarchy, the initial state
   // is hidden.  If the view is attached only to a native NSView but has
   // no Gecko parent (as in embedding), the initial state is visible.
   if (mParentWidget)
     [mView setHidden:YES];
   else
     mVisible = PR_TRUE;
@@ -1641,16 +1624,20 @@ NS_IMETHODIMP nsChildView::Update()
 #pragma mark -
 
 
 // Scroll the bits of a view and its children
 // FIXME: I'm sure the invalidating can be optimized, just no time now.
 NS_IMETHODIMP nsChildView::Scroll(PRInt32 aDx, PRInt32 aDy, nsRect *aClipRect)
 {
   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
+
+  NS_ASSERTION(mParentView, "Attempting to scroll a view that does not have a parent");
+  if (!mParentView)
+    return NS_ERROR_NOT_AVAILABLE;
 
   BOOL viewWasDirty = NO;
   if (mVisible) {
     viewWasDirty = [mView needsDisplay];
 
     NSSize scrollVector = {aDx,aDy};
     [mView scrollRect: [mView visibleRect] by:scrollVector];
   }
diff -r 9864735a4241 widget/src/cocoa/nsPrintOptionsX.h
--- a/widget/src/cocoa/nsPrintOptionsX.h	Mon Sep 22 11:50:03 2008 -0700
+++ b/widget/src/cocoa/nsPrintOptionsX.h	Fri Sep 26 09:30:25 2008 -0500
@@ -36,32 +36,23 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef nsPrintOptionsX_h_
 #define nsPrintOptionsX_h_
 
 #include "nsPrintOptionsImpl.h"
 
-
-//*****************************************************************************
-//***    nsPrintOptions
-//*****************************************************************************
-
 class nsPrintOptionsX : public nsPrintOptions
 {
 public:
-              nsPrintOptionsX();
-  virtual     ~nsPrintOptionsX();
-
-  NS_IMETHOD  ShowPrintSetupDialog(nsIPrintSettings *aThePrintSettings);
-  
-  NS_IMETHOD  GetNativeData(PRInt16 aDataType, void * *_retval);
+             nsPrintOptionsX();
+  virtual    ~nsPrintOptionsX();
+  NS_IMETHOD ShowPrintSetupDialog(nsIPrintSettings *aThePrintSettings);
+  NS_IMETHOD GetNativeData(PRInt16 aDataType, void * *_retval);
 
 protected:
-  nsresult    _CreatePrintSettings(nsIPrintSettings **_retval);
-
-  nsresult    ReadPrefs(nsIPrintSettings* aPS, const nsAString& aPrinterName, PRUint32 aFlags);
-  nsresult    WritePrefs(nsIPrintSettings* aPS, const nsAString& aPrinterName, PRUint32 aFlags);
+  nsresult   _CreatePrintSettings(nsIPrintSettings **_retval);
+  nsresult   ReadPrefs(nsIPrintSettings* aPS, const nsAString& aPrinterName, PRUint32 aFlags);
+  nsresult   WritePrefs(nsIPrintSettings* aPS, const nsAString& aPrinterName, PRUint32 aFlags);
 };
 
-
 #endif // nsPrintOptionsX_h_
diff -r 9864735a4241 widget/src/cocoa/nsPrintOptionsX.mm
--- a/widget/src/cocoa/nsPrintOptionsX.mm	Mon Sep 22 11:50:03 2008 -0700
+++ b/widget/src/cocoa/nsPrintOptionsX.mm	Fri Sep 26 09:30:25 2008 -0500
@@ -51,56 +51,31 @@ nsPrintOptionsX::nsPrintOptionsX()
 }
 
 
 nsPrintOptionsX::~nsPrintOptionsX()
 {
 }
 
 
-nsresult nsPrintOptionsX::_CreatePrintSettings(nsIPrintSettings **_retval)
-{
-  nsresult rv;
-  *_retval = nsnull;
-
-  nsPrintSettingsX* printSettings = new nsPrintSettingsX; // does not initially ref count
-  NS_ENSURE_TRUE(printSettings, NS_ERROR_OUT_OF_MEMORY);
-
-  NS_ADDREF(*_retval = printSettings); // ref count
-
-  rv = printSettings->Init();
-  if (NS_FAILED(rv)) {
-    NS_RELEASE(*_retval);
-    return rv;
-  }
-
-  (void)InitPrintSettingsFromPrefs(*_retval, PR_FALSE,
-                                   nsIPrintSettings::kInitSaveAll);
-  return rv;
-}
-
-
 NS_IMETHODIMP
 nsPrintOptionsX::ShowPrintSetupDialog(nsIPrintSettings *aThePrintSettings)
 {
   return NS_ERROR_NOT_IMPLEMENTED;
 } 
 
 
 NS_IMETHODIMP
 nsPrintOptionsX::GetNativeData(PRInt16 aDataType, void **_retval)
 {
   NS_ENSURE_ARG_POINTER(_retval);
   *_retval = nsnull;
 
   return NS_ERROR_NOT_IMPLEMENTED;
 }
-
-
-#pragma mark -
 
 
 nsresult
 nsPrintOptionsX::ReadPrefs(nsIPrintSettings* aPS, const nsAString& aPrinterName, PRUint32 aFlags)
 {
   nsresult rv;
   
   rv = nsPrintOptions::ReadPrefs(aPS, aPrinterName, aFlags);
@@ -111,24 +86,44 @@ nsPrintOptionsX::ReadPrefs(nsIPrintSetti
     return NS_ERROR_NO_INTERFACE;
   rv = printSettingsX->ReadPageFormatFromPrefs();
   NS_ASSERTION(NS_SUCCEEDED(rv), "nsIPrintSettingsX::ReadPageFormatFromPrefs() failed");
   
   return NS_OK;
 }
 
 
+nsresult nsPrintOptionsX::_CreatePrintSettings(nsIPrintSettings **_retval)
+{
+  nsresult rv;
+  *_retval = nsnull;
+
+  nsPrintSettingsX* printSettings = new nsPrintSettingsX; // does not initially ref count
+  NS_ENSURE_TRUE(printSettings, NS_ERROR_OUT_OF_MEMORY);
+  NS_ADDREF(*_retval = printSettings);
+
+  rv = printSettings->Init();
+  if (NS_FAILED(rv)) {
+    NS_RELEASE(*_retval);
+    return rv;
+  }
+
+  InitPrintSettingsFromPrefs(*_retval, PR_FALSE, nsIPrintSettings::kInitSaveAll);
+  return rv;
+}
+
+
 nsresult
 nsPrintOptionsX::WritePrefs(nsIPrintSettings* aPS, const nsAString& aPrinterName, PRUint32 aFlags)
 {
   nsresult rv;
-  
+
   rv = nsPrintOptions::WritePrefs(aPS, aPrinterName, aFlags);
   NS_ASSERTION(NS_SUCCEEDED(rv), "nsPrintOptions::WritePrefs() failed");
-  
+
   nsCOMPtr<nsIPrintSettingsX> printSettingsX(do_QueryInterface(aPS));
   if (!printSettingsX)
     return NS_ERROR_NO_INTERFACE;
   rv = printSettingsX->WritePageFormatToPrefs();
   NS_ASSERTION(NS_SUCCEEDED(rv), "nsIPrintSettingsX::WritePageFormatToPrefs() failed");
-  
+
   return NS_OK;
 }
diff -r 9864735a4241 widget/src/cocoa/nsPrintSessionX.h
--- a/widget/src/cocoa/nsPrintSessionX.h	Mon Sep 22 11:50:03 2008 -0700
+++ b/widget/src/cocoa/nsPrintSessionX.h	Fri Sep 26 09:30:25 2008 -0500
@@ -37,29 +37,26 @@
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef nsPrintSessionX_h_
 #define nsPrintSessionX_h_
 
 #include "nsPrintSession.h"
 #include "nsIPrintSessionX.h"
 
-//*****************************************************************************
-//***    nsPrintSessionX
-//*****************************************************************************
 
 class nsPrintSessionX : public nsPrintSession,
                         public nsIPrintSessionX
 {
 public:
   NS_DECL_ISUPPORTS_INHERITED
   NS_DECL_NSIPRINTSESSIONX
 
   nsPrintSessionX();
   virtual ~nsPrintSessionX();
-  
+
   nsresult Init();
-  
+
 protected:
-  PMPrintSession    mSession;
+  PMPrintSession mSession;
 };
 
 #endif // nsPrintSessionX_h_
diff -r 9864735a4241 widget/src/cocoa/nsPrintSessionX.mm
--- a/widget/src/cocoa/nsPrintSessionX.mm	Mon Sep 22 11:50:03 2008 -0700
+++ b/widget/src/cocoa/nsPrintSessionX.mm	Fri Sep 26 09:30:25 2008 -0500
@@ -34,65 +34,60 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsPrintSessionX.h"
 #include "nsObjCExceptions.h"
 
-//*****************************************************************************
-//***    nsPrintSessionX
-//*****************************************************************************
 
 NS_IMPL_ISUPPORTS_INHERITED1(nsPrintSessionX, 
                              nsPrintSession, 
                              nsIPrintSessionX)
                              
-//-----------------------------------------------------------------------------
 nsPrintSessionX::nsPrintSessionX()
 {
 }
 
-//-----------------------------------------------------------------------------
+
 nsPrintSessionX::~nsPrintSessionX()
 {
   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 
   if (mSession) {
     ::PMRelease(mSession);
     mSession = nsnull;
   }
 
   NS_OBJC_END_TRY_ABORT_BLOCK;
 }
 
-//-----------------------------------------------------------------------------
+
 nsresult nsPrintSessionX::Init()
 {
   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 
   nsresult rv = nsPrintSession::Init();
   if (NS_FAILED(rv))
     return rv;
-  
+
   OSStatus status = ::PMCreateSession(&mSession);
   if (status != noErr)
     return NS_ERROR_FAILURE;
-    
+
   return NS_OK;
 
   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 }
 
-//-----------------------------------------------------------------------------
-/* readonly attribute nsPMPrintSession nativeSession; */
+
 NS_IMETHODIMP nsPrintSessionX::GetNativeSession(PMPrintSession *aNativeSession)
 {
   NS_ENSURE_ARG_POINTER(aNativeSession);
   *aNativeSession = nsnull;
-  
+
   if (!mSession)
     return NS_ERROR_NOT_INITIALIZED;
-    
+
   *aNativeSession = mSession;
   return NS_OK;
 }
diff -r 9864735a4241 widget/src/cocoa/nsPrintSettingsX.h
--- a/widget/src/cocoa/nsPrintSettingsX.h	Mon Sep 22 11:50:03 2008 -0700
+++ b/widget/src/cocoa/nsPrintSettingsX.h	Fri Sep 26 09:30:25 2008 -0500
@@ -1,11 +1,10 @@
-/* -*- Mode: IDL; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- *
- * ***** BEGIN LICENSE BLOCK *****
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Mozilla Public License Version
  * 1.1 (the "License"); you may not use this file except in compliance with
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
@@ -37,43 +36,38 @@
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef nsPrintSettingsX_h_
 #define nsPrintSettingsX_h_
 
 #include "nsPrintSettingsImpl.h"  
 #include "nsIPrintSettingsX.h"  
 
-//*****************************************************************************
-//***    nsPrintSettingsX
-//*****************************************************************************
 
 class nsPrintSettingsX : public nsPrintSettings,
                          public nsIPrintSettingsX
 {
 public:
   NS_DECL_ISUPPORTS_INHERITED
   NS_DECL_NSIPRINTSETTINGSX
 
   nsPrintSettingsX();
   virtual ~nsPrintSettingsX();
-  
+
   nsresult Init();
 
 protected:
   nsPrintSettingsX(const nsPrintSettingsX& src);
   nsPrintSettingsX& operator=(const nsPrintSettingsX& rhs);
 
   nsresult _Clone(nsIPrintSettings **_retval);
   nsresult _Assign(nsIPrintSettings *aPS);
-  
-  /**
-   * Re-initialize mUnwriteableMargin with values from mPageFormat.
-   * Should be called whenever mPageFormat is initialized or overwritten.
-   */
+
+  // Re-initialize mUnwriteableMargin with values from mPageFormat.
+  // Should be called whenever mPageFormat is initialized or overwritten.
   nsresult InitUnwriteableMargin();
 
   // The out param has a ref count of 1 on return so caller needs to PMRelase() when done.
   OSStatus CreateDefaultPageFormat(PMPrintSession aSession, PMPageFormat& outFormat);
   OSStatus CreateDefaultPrintSettings(PMPrintSession aSession, PMPrintSettings& outSettings);
 
   PMPageFormat mPageFormat;
   PMPrintSettings mPrintSettings;
diff -r 9864735a4241 widget/src/cocoa/nsPrintSettingsX.mm
--- a/widget/src/cocoa/nsPrintSettingsX.mm	Mon Sep 22 11:50:03 2008 -0700
+++ b/widget/src/cocoa/nsPrintSettingsX.mm	Fri Sep 26 09:30:25 2008 -0500
@@ -43,33 +43,30 @@
 #include "nsIPrefService.h"
 #include "nsIPrefBranch.h"
 #include "nsServiceManagerUtils.h"
 
 #include "plbase64.h"
 #include "prmem.h"
 #include "prnetdb.h"
 
+
 // This struct should be represented identically on all architectures, and
 // there shouldn't be any padding before the data field.
 struct FrozenHandle {
   PRUint32 size;
-  char     data[0];
+  char data[0];
 };
 
-// Constants
+
 #define PRINTING_PREF_BRANCH            "print."
 #define MAC_OS_X_PAGE_SETUP_PREFNAME    "macosx.pagesetup-2"
 
 
-
-/** ------------------------------------------------------------
- *	Utility class stack-based handle ownership
- */
-
+// Utility class stack-based handle ownership
 class StHandleOwner
 {
 public:
   StHandleOwner(Handle inHandle)
     : mHandle(inHandle)
   {
   }
 
@@ -93,29 +90,25 @@ public:
       ::DisposeHandle(mHandle);
 
     mHandle = nsnull;
 
     NS_OBJC_END_TRY_ABORT_BLOCK;
   }
 
 protected:
-
-  Handle            mHandle;
+  Handle mHandle;
 };
 
-/** ------------------------------------------------------------
- *	Utility class for saving, locking, and restoring handle state
- *  Ok with null handle
- */
 
+//	Utility class for saving, locking, and restoring handle state.
+//  Ok with null handle.
 class StHandleLocker
 {
 public:
-
   StHandleLocker(Handle theHandle)
     :	mHandle(theHandle)
   {
     NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 
     if (mHandle) {
       mOldHandleState = ::HGetState(mHandle);
       ::HLock(mHandle);
@@ -130,63 +123,55 @@ public:
 
     if (mHandle)
       ::HSetState(mHandle, mOldHandleState);
 
     NS_OBJC_END_TRY_ABORT_BLOCK;
   }
 
 protected:
-
-  Handle          mHandle;
-  SInt8           mOldHandleState;
+  Handle mHandle;
+  SInt8 mOldHandleState;
 };
 
 
-NS_IMPL_ISUPPORTS_INHERITED1(nsPrintSettingsX, 
-                             nsPrintSettings, 
-                             nsIPrintSettingsX)
+NS_IMPL_ISUPPORTS_INHERITED1(nsPrintSettingsX, nsPrintSettings, nsIPrintSettingsX)
 
-/** ---------------------------------------------------
- */
 nsPrintSettingsX::nsPrintSettingsX() :
   mPageFormat(kPMNoPageFormat),
   mPrintSettings(kPMNoPrintSettings)
 {
 }
 
-/** ---------------------------------------------------
- */
+
 nsPrintSettingsX::nsPrintSettingsX(const nsPrintSettingsX& src) :
   mPageFormat(kPMNoPageFormat),
   mPrintSettings(kPMNoPrintSettings)
 {
   *this = src;
 }
 
-/** ---------------------------------------------------
- */
+
 nsPrintSettingsX::~nsPrintSettingsX()
 {
   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 
   if (mPageFormat != kPMNoPageFormat) {
     ::PMRelease(mPageFormat);
     mPageFormat = kPMNoPageFormat;
   }
   if (mPrintSettings != kPMNoPrintSettings) {
     ::PMRelease(mPrintSettings);
     mPrintSettings = kPMNoPrintSettings;
   }
 
   NS_OBJC_END_TRY_ABORT_BLOCK;
 }
 
-/** ---------------------------------------------------
- */
+
 nsPrintSettingsX& nsPrintSettingsX::operator=(const nsPrintSettingsX& rhs)
 {
   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
 
   if (this == &rhs) {
     return *this;
   }
   
@@ -230,18 +215,17 @@ nsPrintSettingsX& nsPrintSettingsX::oper
     }
   }
 
   return *this;
 
   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(*this);
 }
 
-/** ---------------------------------------------------
- */
+
 nsresult nsPrintSettingsX::Init()
 {
   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 
   OSStatus status;
 
   PMPrintSession printSession = NULL;
   status = ::PMCreateSession(&printSession);
@@ -259,73 +243,70 @@ nsresult nsPrintSettingsX::Init()
     if (status == noErr)
       status = tempStatus;
   }
   return (status == noErr) ? NS_OK : NS_ERROR_FAILURE;
 
   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 }
 
+
 // Should be called whenever mPageFormat changes.
 NS_IMETHODIMP nsPrintSettingsX::InitUnwriteableMargin()
 {
   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 
-  if (mPageFormat == kPMNoPageFormat) {
+  if (mPageFormat == kPMNoPageFormat)
     return NS_OK;
-  }
 
   PMPaper paper;
   PMPaperMargins paperMargin;
   ::PMGetPageFormatPaper(mPageFormat, &paper);
   ::PMPaperGetMargins(paper, &paperMargin);
   mUnwriteableMargin.top    = NS_POINTS_TO_TWIPS(paperMargin.top);
   mUnwriteableMargin.left   = NS_POINTS_TO_TWIPS(paperMargin.left);
   mUnwriteableMargin.bottom = NS_POINTS_TO_TWIPS(paperMargin.bottom);
   mUnwriteableMargin.right  = NS_POINTS_TO_TWIPS(paperMargin.right);
 
   return NS_OK;
 
   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;  
 }
 
-/** ---------------------------------------------------
- */
+
 NS_IMETHODIMP nsPrintSettingsX::GetNativePrintSession(PMPrintSession *aNativePrintSession)
 {
    NS_ENSURE_ARG_POINTER(aNativePrintSession);
    *aNativePrintSession = nsnull;
    
    nsCOMPtr<nsIPrintSession> printSession;
    GetPrintSession(getter_AddRefs(printSession));
    if (!printSession)
     return NS_ERROR_FAILURE;
    nsCOMPtr<nsIPrintSessionX> printSessionX(do_QueryInterface(printSession));
    if (!printSession)
     return NS_ERROR_FAILURE;
 
    return printSessionX->GetNativeSession(aNativePrintSession);
 }
 
-/** ---------------------------------------------------
- */
+
 NS_IMETHODIMP nsPrintSettingsX::GetPMPageFormat(PMPageFormat *aPMPageFormat)
 {
   NS_ENSURE_ARG_POINTER(aPMPageFormat);
   *aPMPageFormat = kPMNoPageFormat;
   NS_ENSURE_STATE(mPageFormat != kPMNoPageFormat);
   
   *aPMPageFormat = mPageFormat;
   OSStatus status = noErr;
   
   return (status == noErr) ? NS_OK : NS_ERROR_FAILURE;
 }
 
-/** ---------------------------------------------------
- */
+
 NS_IMETHODIMP nsPrintSettingsX::SetPMPageFormat(PMPageFormat aPMPageFormat)
 {
   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 
   NS_ENSURE_ARG(aPMPageFormat);
   
   OSStatus status = ::PMRetain(aPMPageFormat);
   if (status == noErr) {
@@ -334,31 +315,29 @@ NS_IMETHODIMP nsPrintSettingsX::SetPMPag
     mPageFormat = aPMPageFormat;
     InitUnwriteableMargin();
   }        
   return (status == noErr) ? NS_OK : NS_ERROR_FAILURE;
 
   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 }
 
-/** ---------------------------------------------------
- */
+
 NS_IMETHODIMP nsPrintSettingsX::GetPMPrintSettings(PMPrintSettings *aPMPrintSettings)
 {
   NS_ENSURE_ARG_POINTER(aPMPrintSettings);
   *aPMPrintSettings = kPMNoPrintSettings;
   NS_ENSURE_STATE(mPrintSettings != kPMNoPrintSettings);
   
   *aPMPrintSettings = mPrintSettings;
 
   return NS_OK;
 }
 
-/** ---------------------------------------------------
- */
+
 NS_IMETHODIMP nsPrintSettingsX::SetPMPrintSettings(PMPrintSettings aPMPrintSettings)
 {
   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 
   NS_ENSURE_ARG(aPMPrintSettings);
   
   OSStatus status = ::PMRetain(aPMPrintSettings);
   if (status == noErr) {
@@ -366,18 +345,17 @@ NS_IMETHODIMP nsPrintSettingsX::SetPMPri
       status = ::PMRelease(mPrintSettings);
     mPrintSettings = aPMPrintSettings;
   }        
   return (status == noErr) ? NS_OK : NS_ERROR_FAILURE;
 
   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 }
 
-/** ---------------------------------------------------
- */
+
 NS_IMETHODIMP nsPrintSettingsX::ReadPageFormatFromPrefs()
 {
   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 
   nsresult rv;
   nsCOMPtr<nsIPrefService> prefService(do_GetService(NS_PREFSERVICE_CONTRACTID, &rv));
   if (NS_FAILED(rv))
     return rv;
@@ -431,18 +409,17 @@ NS_IMETHODIMP nsPrintSettingsX::ReadPage
       InitUnwriteableMargin();
     }
   }
   return (status == noErr) ? NS_OK : NS_ERROR_FAILURE;
 
   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 }
 
-/** ---------------------------------------------------
- */
+
 NS_IMETHODIMP nsPrintSettingsX::WritePageFormatToPrefs()
 {
   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 
   if (mPageFormat == kPMNoPageFormat)
     return NS_ERROR_NOT_INITIALIZED;
     
   nsresult rv;
@@ -483,42 +460,41 @@ NS_IMETHODIMP nsPrintSettingsX::WritePag
   if (!encodedData.get())
     return NS_ERROR_OUT_OF_MEMORY;
 
   return prefBranch->SetCharPref(MAC_OS_X_PAGE_SETUP_PREFNAME, encodedData);
 
   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 }
 
-//-------------------------------------------
+
 nsresult nsPrintSettingsX::_Clone(nsIPrintSettings **_retval)
 {
   NS_ENSURE_ARG_POINTER(_retval);
   *_retval = nsnull;
   
   nsPrintSettingsX *newSettings = new nsPrintSettingsX(*this);
   if (!newSettings)
     return NS_ERROR_FAILURE;
   *_retval = newSettings;
   NS_ADDREF(*_retval);
   return NS_OK;
 }
 
 
-//-------------------------------------------
 NS_IMETHODIMP nsPrintSettingsX::_Assign(nsIPrintSettings *aPS)
 {
   nsPrintSettingsX *printSettingsX = static_cast<nsPrintSettingsX*>(aPS);
   if (!printSettingsX)
     return NS_ERROR_UNEXPECTED;
   *this = *printSettingsX;
   return NS_OK;
 }
 
-//-------------------------------------------
+
 OSStatus nsPrintSettingsX::CreateDefaultPageFormat(PMPrintSession aSession, PMPageFormat& outFormat)
 {
   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
 
   OSStatus status;
   PMPageFormat pageFormat;
   
   outFormat = kPMNoPageFormat;
@@ -529,18 +505,17 @@ OSStatus nsPrintSettingsX::CreateDefault
       outFormat = pageFormat;
       return NS_OK;
     }
   }
   return status;
 
   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(noErr);
 }
-  
-//-------------------------------------------
+
 
 OSStatus nsPrintSettingsX::CreateDefaultPrintSettings(PMPrintSession aSession, PMPrintSettings& outSettings)
 {
   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
 
   OSStatus status;
   PMPrintSettings printSettings;
   
diff -r 9864735a4241 widget/src/os2/nsSound.cpp
--- a/widget/src/os2/nsSound.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/widget/src/os2/nsSound.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -1,8 +1,9 @@
+/* vim: set sw=2 sts=2 et cin: */
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
  *
  * ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Mozilla Public License Version
  * 1.1 (the "License"); you may not use this file except in compliance with
  * the License. You may obtain a copy of the License at
@@ -19,16 +20,18 @@
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 2000
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Stuart Parmenter <pavlov@netscape.com>
  *   John Fairhurst <john_fairhurst@iname.com>
  *   IBM Corp.
+ *   Peter Weilbacher <mozilla@Weilbacher.org>
+ *   Lars Erdmann
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -38,68 +41,380 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nscore.h"
 #include "plstr.h"
 #include <stdio.h>
 #include <string.h>
+#include <stdlib.h>
 
 #define INCL_DOS
 #define INCL_DOSERRORS
+#define INCL_MMIOOS2
 #include <os2.h>
+#include <mmioos2.h>
+#include <mcios2.h>
+#define MCI_ERROR_LENGTH 128
 
 #include "nsSound.h"
 #include "nsIURL.h"
 #include "nsNetUtil.h"
 
 #include "nsDirectoryServiceDefs.h"
 
 #include "nsNativeCharsetUtils.h"
 
 NS_IMPL_ISUPPORTS2(nsSound, nsISound, nsIStreamLoaderObserver)
 
-static int                gInitialized = 0;
-static PRBool             gMMPMInstalled = PR_FALSE;
+static int sInitialized = 0;
+static PRBool sMMPMInstalled = PR_FALSE;
+static HMODULE sHModMMIO = NULLHANDLE;
+static HMODULE sHModMDM = NULLHANDLE;
 
-static void
-InitGlobals(void)
+// function pointer definitions, include underscore (work around redef. warning)
+HMMIO (*APIENTRY _mmioOpen)(PSZ, PMMIOINFO, ULONG);
+USHORT (*APIENTRY _mmioClose)(HMMIO, USHORT);
+ULONG (*APIENTRY _mmioGetFormats)(PMMFORMATINFO, LONG, PVOID, PLONG, ULONG, ULONG);
+ULONG (*APIENTRY _mciSendCommand)(USHORT, USHORT, ULONG, PVOID, USHORT);
+#ifdef DEBUG
+ULONG (*APIENTRY _mmioGetLastError)(HMMIO);
+ULONG (*APIENTRY _mmioQueryFormatCount)(PMMFORMATINFO, PLONG, ULONG, ULONG);
+ULONG (*APIENTRY _mmioGetFormatName)(PMMFORMATINFO, PSZ, PLONG, ULONG, ULONG);
+ULONG (*APIENTRY _mciGetErrorString)(ULONG, PSZ, USHORT);
+#endif
+ULONG (*APIENTRY _mmioIniFileHandler)(PMMINIFILEINFO, ULONG);
+
+// argument structure to pass to the background thread
+typedef struct _ARGBUFFER
 {
-  APIRET ulrc;
-  HMODULE hmod;
+  HEV hev;
+  PRUint32 bufLen;
+  const char *buffer;
+  PSZ pszFilename;
+} ARGBUFFER;
+
+////////////////////////////////////////////////////////////////////////
+
+static void InitGlobals(void)
+{
+  ULONG ulrc = 0;
   char LoadError[CCHMAXPATH];
-  ulrc = DosLoadModule(LoadError, CCHMAXPATH, "MMPM", &hmod);
+
+  ulrc = DosLoadModule(LoadError, CCHMAXPATH, "MMIO", &sHModMMIO);
+  ulrc += DosLoadModule(LoadError, CCHMAXPATH, "MDM", &sHModMDM);
   if (ulrc == NO_ERROR) {
-    gMMPMInstalled = PR_TRUE;
+#ifdef DEBUG
+    printf("InitGlobals: MMOS2 is installed, both DLLs loaded\n");
+#endif
+    sMMPMInstalled = PR_TRUE;
+    // MMOS2 is installed, so we can query the necessary functions
+    // mmio functions are in MMIO.DLL
+    ulrc = DosQueryProcAddr(sHModMMIO, 0L, "mmioOpen", (PFN *)&_mmioOpen);
+    ulrc += DosQueryProcAddr(sHModMMIO, 0L, "mmioClose", (PFN *)&_mmioClose);
+    ulrc += DosQueryProcAddr(sHModMMIO, 0L, "mmioGetFormats", (PFN *)&_mmioGetFormats);
+    // mci functions are in MDM.DLL
+    ulrc += DosQueryProcAddr(sHModMDM, 0L, "mciSendCommand", (PFN *)&_mciSendCommand);
+#ifdef DEBUG
+    ulrc += DosQueryProcAddr(sHModMMIO, 0L, "mmioGetLastError", (PFN *)&_mmioGetLastError);
+    ulrc += DosQueryProcAddr(sHModMMIO, 0L, "mmioQueryFormatCount", (PFN *)&_mmioQueryFormatCount);
+    ulrc += DosQueryProcAddr(sHModMMIO, 0L, "mmioGetFormatName", (PFN *)&_mmioGetFormatName);
+    ulrc += DosQueryProcAddr(sHModMDM, 0L, "mciGetErrorString", (PFN *)&_mciGetErrorString);
+#endif
+
+    ulrc += DosQueryProcAddr(sHModMMIO, 0L, "mmioIniFileHandler", (PFN *)&_mmioIniFileHandler);
+
+    // if one of these failed, we have some kind of non-functional MMOS2 installation
+    if (ulrc != NO_ERROR) {
+      NS_WARNING("MMOS2 is installed, but seems to have corrupt DLLs");
+      sMMPMInstalled = PR_FALSE;
+    }
   }
-  DosFreeModule(hmod);
-  gInitialized = 1;
 }
 
+////////////////////////////////////////////////////////////////////////
+
+// Tries to determine the data format in the buffer using file "magic"
+// and a loop through MMOS2 audio codecs.
+// Returns the FourCC handle for the format, or 0 when failing to find format
+// and codec.
+FOURCC determineFourCC(PRUint32 aDataLen, const char *aData)
+{
+  FOURCC fcc = 0;
+
+  // Start to compare the first bytes of the data with magic to determine the
+  // most likely format upfront.
+  if (memcmp(aData, "RIFF", 4) == 0) {                                    // WAV
+    fcc = mmioFOURCC('W', 'A', 'V', 'E');
+  } else if (memcmp(aData, "ID3", 3) == 0 ||       // likely MP3 with ID3 header
+             ((aData[0] & 0xFF) == 0xFF &&   // various versions of MPEG layer 3
+              ((aData[1] & 0xFE) == 0xFA ||                                // v1
+               (aData[1] & 0xFE) == 0xF2 ||                                // v2
+               (aData[1] & 0xFE) == 0xE2)))                              // v2.5
+  {
+    fcc = mmioFOURCC('M','P','3',' ');
+  } else if (memcmp(aData, "OggS", 4) == 0) {                             // OGG
+    fcc = mmioFOURCC('O','G','G','S');
+  } else if (memcmp(aData, "fLaC", 4) == 0) {                            // FLAC
+    fcc = mmioFOURCC('f','L','a','C');
+  }
+
+  // The following is too flakey because several OS/2 IOProc don't behave as
+  // they should and would cause us to crash. So just skip this for now...
+#if 0
+  if (fcc) // already found one
+    return fcc;
+
+  // None of the popular formats found, so use the list of MMOS2 audio codecs to
+  // find one that can open the file.
+  MMFORMATINFO mmfi;
+  LONG lNum;
+  memset(&mmfi, '\0', sizeof(mmfi));
+  mmfi.ulStructLen = sizeof(mmfi);
+  mmfi.ulMediaType |= MMIO_MEDIATYPE_AUDIO;
+  ULONG ulrc = _mmioQueryFormatCount(&mmfi, &lNum, 0L, 0L);
+
+  PMMFORMATINFO mmflist = (PMMFORMATINFO)calloc(lNum, sizeof(MMFORMATINFO));
+  LONG lFormats;
+  ulrc = _mmioGetFormats(&mmfi, lNum, mmflist, &lFormats, 0L, 0L);
+
+  MMIOINFO mi;
+  memset(&mi, '\0', sizeof(mi));
+  mi.fccChildIOProc = FOURCC_MEM;
+  unsigned char szBuffer[sizeof(FOURCC) + CCHMAXPATH + 4];
+  for (int i = lFormats-1; i >= 0; i--) {
+    // Loop through formats. Do it backwards to find at least WAV before the
+    // faulty VORBIS/FLAC/MP3 IOProcs that will open any format.
+    MMFORMATINFO mmfi = mmflist[i];
+#ifdef DEBUG
+    LONG lBytesRead;
+    _mmioGetFormatName(&mmfi, (char *)szBuffer, &lBytesRead, 0L, 0L);
+    printf("determineFour Codec %d: name=%s media=0x%lx ext=%s fcc=%c%c%c%c/%ld/%p\n",
+           i, szBuffer, mmfi.ulMediaType, mmfi.szDefaultFormatExt,
+           (char)(mmfi.fccIOProc), (char)(mmfi.fccIOProc >> 8),
+           (char)(mmfi.fccIOProc >> 16), (char)(mmfi.fccIOProc >> 24),
+           mmfi.fccIOProc, (void *)mmfi.fccIOProc);
+#endif
+
+    // this codec likely crashes the program when the buffer is not of the
+    // expected format
+    if (mmfi.fccIOProc == mmioFOURCC('A','V','C','A')) {
+      continue;
+    }
+
+    mi.fccIOProc = mmfi.fccIOProc;
+    HMMIO hmmio= _mmioOpen(NULL, &mi, MMIO_READ);
+    if (hmmio) {
+      fcc = mmfi.fccIOProc;
+      _mmioClose(hmmio, 0);
+      break;
+    }
+  }
+  free(mmflist);
+#endif
+
+#ifdef DEBUG
+  printf("determineFourCC: Codec fcc is 0x%lx or --%c%c%c%c--\n", fcc,
+         (char)(fcc), (char)(fcc >> 8), (char)(fcc >> 16), (char)(fcc >> 24));
+#endif
+
+  return fcc;
+}
+
+// Play the sound that was set up in the argument structure. If an error occurs,
+// beep at least.  To be used as function for a new background thread.
+static void playSound(void *aArgs)
+{
+  ULONG ulrc = NO_ERROR;
+  ARGBUFFER args;
+  memcpy(&args, aArgs, sizeof(args));
+
+  MMIOINFO mi;
+  memset(&mi, '\0', sizeof(mi));
+  HMMIO hmmio = NULLHANDLE;
+
+  do { // inner block (break in case of error)
+    if (args.pszFilename) {
+      // determine size of file that we want to read
+      FILESTATUS3 fs3;
+      memset(&fs3, '\0', sizeof(fs3));
+      ulrc = DosQueryPathInfo(args.pszFilename, FIL_STANDARD, &fs3, sizeof(fs3));
+      mi.cchBuffer = fs3.cbFile;
+    } else {
+      // use size of the existing buffer
+      mi.cchBuffer = args.bufLen;
+    }
+
+    // Read or copy the sound into a local memory buffer for easy playback.
+    // (If we got the sound in a buffer originally, that buffer could
+    // "disappear" while we are still playing it.)
+    ulrc = DosAllocMem((PPVOID)&mi.pchBuffer, mi.cchBuffer,
+#ifdef OS2_HIGH_MEMORY             /* only if compiled with high-memory  */
+                       OBJ_ANY | /* support, we can allocate anywhere! */
+#endif
+                       PAG_READ | PAG_WRITE | PAG_COMMIT);
+    if (ulrc != NO_ERROR) {
+#ifdef DEBUG
+      printf("playSound: Could not allocate the sound buffer, ulrc=%ld\n", ulrc);
+#endif
+      break;
+    }
+
+    if (args.pszFilename) {
+      // read the sound from file into memory
+      HFILE hf = NULLHANDLE;
+      ULONG ulAction = 0;
+      ulrc = DosOpen(args.pszFilename, &hf, &ulAction, 0, FILE_NORMAL,
+                     OPEN_ACTION_OPEN_IF_EXISTS | OPEN_ACTION_FAIL_IF_NEW,
+                     OPEN_ACCESS_READONLY | OPEN_SHARE_DENYNONE,
+                     NULL);
+      if (ulrc != NO_ERROR) {
+#ifdef DEBUG
+        printf("playSound: could not open the sound file \"%s\" (%ld)\n",
+               args.pszFilename, ulrc);
+#endif
+        break;
+      }
+      ULONG ulRead = 0;
+      ulrc = DosRead(hf, mi.pchBuffer, mi.cchBuffer, &ulRead);
+      DosClose(hf);
+      if (ulrc != NO_ERROR) {
+#ifdef DEBUG
+        printf("playSound: read %ld of %ld bytes from the sound file \"%s\" (%ld)\n",
+               ulRead, mi.cchBuffer, args.pszFilename, ulrc);
+#endif
+        break;
+      }
+    } else {
+      // copy the passed sound buffer into local memory
+      memcpy(mi.pchBuffer, args.buffer, args.bufLen);
+    }
+
+    DosPostEventSem(args.hev); // calling thread can continue
+
+    // Now the sound is loaded into memory in any case, play it from there.
+    mi.fccChildIOProc = FOURCC_MEM;
+    mi.fccIOProc = determineFourCC(mi.cchBuffer, mi.pchBuffer);
+    if (!mi.fccIOProc) {
+      NS_WARNING("playSound: unknown sound format in memory buffer");
+      break;
+    }
+    mi.ulTranslate = MMIO_TRANSLATEDATA | MMIO_TRANSLATEHEADER;
+    hmmio = _mmioOpen(NULL, &mi, MMIO_READ | MMIO_DENYWRITE);
+
+    if (!hmmio) {
+#ifdef DEBUG
+      ULONG ulrc = _mmioGetLastError(hmmio);
+      if (args.pszFilename) {
+        printf("playSound: mmioOpen failed, cannot play sound from \"%s\" (%ld)\n",
+               args.pszFilename, ulrc);
+      } else {
+        printf("playSound: mmioOpen failed, cannot play sound buffer (%ld)\n",
+               ulrc);
+      }
+#endif
+      break;
+    }
+
+    // open the sound device
+    MCI_OPEN_PARMS mop;
+    memset(&mop, '\0', sizeof(mop));
+    mop.pszElementName = (PSZ)hmmio;
+    mop.pszDeviceType = (PSZ)MAKEULONG(MCI_DEVTYPE_WAVEFORM_AUDIO, 0);
+    ulrc = _mciSendCommand(0, MCI_OPEN,
+                           MCI_OPEN_MMIO | MCI_OPEN_TYPE_ID | MCI_OPEN_SHAREABLE | MCI_WAIT,
+                           (PVOID)&mop, 0);
+    if (ulrc != MCIERR_SUCCESS) {
+#ifdef DEBUG
+      CHAR errorBuffer[MCI_ERROR_LENGTH];
+      _mciGetErrorString(ulrc, errorBuffer, MCI_ERROR_LENGTH);
+      printf("playSound: mciSendCommand with MCI_OPEN_MMIO returned %ld: %s\n",
+             ulrc, errorBuffer);
+#endif
+      break;
+    }
+
+    // play the sound
+    MCI_PLAY_PARMS mpp;
+    memset(&mpp, '\0', sizeof(mpp));
+    ulrc = _mciSendCommand(mop.usDeviceID, MCI_PLAY, MCI_WAIT, &mpp, 0);
+#ifdef DEBUG
+    // just ignore further failures in non-debug mode
+    if (ulrc != MCIERR_SUCCESS) {
+      CHAR errorBuffer[MCI_ERROR_LENGTH];
+      _mciGetErrorString(ulrc, errorBuffer, MCI_ERROR_LENGTH);
+      printf("playSound: mciSendCommand with MCI_PLAY returned %ld: %s\n",
+             ulrc, errorBuffer);
+    }
+#endif
+
+    // end playing
+    ulrc = _mciSendCommand(mop.usDeviceID, MCI_STOP, MCI_WAIT, &mpp, 0); // be nice
+    ulrc = _mciSendCommand(mop.usDeviceID, MCI_CLOSE, MCI_WAIT, &mpp, 0);
+#ifdef DEBUG
+    if (ulrc != MCIERR_SUCCESS) {
+      CHAR errorBuffer[MCI_ERROR_LENGTH];
+      _mciGetErrorString(ulrc, errorBuffer, MCI_ERROR_LENGTH);
+      printf("playSound: mciSendCommand with MCI_CLOSE returned %ld: %s\n",
+             ulrc, errorBuffer);
+    }
+#endif
+    _mmioClose(hmmio, 0);
+    DosFreeMem(mi.pchBuffer);
+    _endthread();
+  } while(0); // end of inner block
+
+  // cleanup after an error
+  WinAlarm(HWND_DESKTOP, WA_WARNING); // Beep()
+  if (hmmio)
+    _mmioClose(hmmio, 0);
+  if (mi.pchBuffer)
+    DosFreeMem(mi.pchBuffer);
+}
 
 ////////////////////////////////////////////////////////////////////////
+
 nsSound::nsSound()
 {
-  if (!gInitialized) {
+  if (!sInitialized) {
     InitGlobals();
   }
+  sInitialized++;
+#ifdef DEBUG
+  printf("nsSound::nsSound: sInitialized=%d\n", sInitialized);
+#endif
 }
 
 nsSound::~nsSound()
 {
+  sInitialized--;
+#ifdef DEBUG
+  printf("nsSound::~nsSound: sInitialized=%d\n", sInitialized);
+#endif
+  // (try to) unload modules after last user ended
+  if (!sInitialized) {
+#ifdef DEBUG
+    printf("nsSound::~nsSound: Trying to free modules...\n");
+#endif
+    ULONG ulrc;
+    ulrc = DosFreeModule(sHModMMIO);
+    ulrc += DosFreeModule(sHModMDM);
+    if (ulrc != NO_ERROR) {
+      NS_WARNING("DosFreeModule did not work");
+    }
+  }
 }
 
 NS_IMETHODIMP nsSound::OnStreamComplete(nsIStreamLoader *aLoader,
                                         nsISupports *context,
                                         nsresult aStatus,
                                         PRUint32 dataLen,
                                         const PRUint8 *data)
 {
-
   if (NS_FAILED(aStatus)) {
 #ifdef DEBUG
     if (aLoader) {
       nsCOMPtr<nsIRequest> request;
       aLoader->GetRequest(getter_AddRefs(request));
       if (request) {
         nsCOMPtr<nsIURI> uri;
         nsCOMPtr<nsIChannel> channel = do_QueryInterface(request);
@@ -112,94 +427,38 @@ NS_IMETHODIMP nsSound::OnStreamComplete(
             }
         }
       }
     }
 #endif
     return NS_ERROR_FAILURE;
   }
 
-  if (memcmp(data, "RIFF", 4) || (!gMMPMInstalled)) {
-    NS_WARNING("We only support WAV files currently.\n");
+  if (!sMMPMInstalled) {
+    NS_WARNING("Sound output only works with MMOS2 installed");
     Beep();
     return NS_OK;
   }
 
-  nsresult rv;
-    
-  static const char *kSoundTmpFileName = "mozsound.wav";
+  ARGBUFFER arg;
+  memset(&arg, '\0', sizeof(arg));
+  APIRET rc = DosCreateEventSem(NULL, &(arg.hev), 0UL, 0UL);
 
-  nsCOMPtr<nsIFile> soundTmp;
-  rv = NS_GetSpecialDirectory(NS_OS_TEMP_DIR, getter_AddRefs(soundTmp));
-  if (NS_FAILED(rv)) return rv;
-  rv = soundTmp->AppendNative(nsDependentCString(kSoundTmpFileName));
-  nsCAutoString soundFilename;
-  (void) soundTmp->GetNativePath(soundFilename);
-  FILE *fp = fopen(soundFilename.get(), "wb+");
-  if (fp) {
-    fwrite(data, dataLen, 1, fp);
-    fclose(fp);
-    HOBJECT hobject = WinQueryObject(soundFilename.get());
-    WinSetObjectData(hobject, "OPEN=DEFAULT");
-  } else {
-    NS_WARNING("Could not open WAV file for binary writing.\n");
-    Beep();
-  }
+  // Play the sound on a new thread using MMOS2, in this case pass
+  // the memory buffer in the argument structure.
+  arg.bufLen = dataLen;
+  arg.buffer = (char *)data;
+  _beginthread(playSound, NULL, 32768, (void *)&arg);
+
+  // Wait until the buffer was copied, but not indefinitely to not block the
+  // UI in case a really large sound file is copied.
+  rc = DosWaitEventSem(arg.hev, 100);
+  rc = DosCloseEventSem(arg.hev);
 
   return NS_OK;
-
-#ifdef OLDCODE /* Some day we could try to get this working */
-  ULONG ulRC;
-  CHAR errorBuffer[128];
-
-  HMMIO hmmio;
-  MMIOINFO mmioinfo;
-
-  memset(&mmioinfo, 0, sizeof(MMIOINFO));
-  mmioinfo.fccIOProc = FOURCC_MEM;
-  mmioinfo.cchBuffer = dataLen;
-  mmioinfo.pchBuffer = (char*)data;
-  USHORT usDeviceID;
-
-  hmmio = mmioOpen(NULL, &mmioinfo, MMIO_READWRITE);
-
-  MCI_OPEN_PARMS mop;
-  memset(&mop, 0, sizeof(MCI_OPEN_PARMS));
-
-  mop.pszElementName = (char*)hmmio;
-  CHAR DeviceType[] = "waveaudio";
-  mop.pszDeviceType = (PSZ)&DeviceType;
-
-  ulRC = mciSendCommand(0, MCI_OPEN, MCI_OPEN_MMIO | MCI_WAIT, &mop, 0);
-
-  if (ulRC != MCIERR_SUCCESS) {
-     ulRC = mciGetErrorString(ulRC, errorBuffer, 128);
-  }
-
-  usDeviceID = mop.usDeviceID;
-
-  MCI_OPEN_PARMS mpp;
-
-  memset(&mpp, 0, sizeof(MCI_OPEN_PARMS));
-  ulRC = mciSendCommand(usDeviceID, MCI_PLAY, MCI_WAIT, &mpp, 0);
-
-  if (ulRC != MCIERR_SUCCESS) {
-     ulRC = mciGetErrorString(ulRC, errorBuffer, 128);
-  }
-
-  MCI_GENERIC_PARMS mgp;
-  memset(&mgp, 0, sizeof(MCI_GENERIC_PARMS));
-  ulRC = mciSendCommand(usDeviceID, MCI_CLOSE, MCI_WAIT, &mgp, 0);
-
-  if (ulRC != MCIERR_SUCCESS) {
-     ulRC = mciGetErrorString(ulRC, errorBuffer, 128);
-  }
-
-  mmioClose(hmmio, 0);
-#endif
 }
 
 NS_METHOD nsSound::Beep()
 {
   WinAlarm(HWND_DESKTOP, WA_WARNING);
 
   return NS_OK;
 }
@@ -216,25 +475,32 @@ NS_METHOD nsSound::Play(nsIURL *aURL)
 
 NS_IMETHODIMP nsSound::Init()
 {
   return NS_OK;
 }
 
 NS_IMETHODIMP nsSound::PlaySystemSound(const nsAString &aSoundAlias)
 {
-  /* We don't have a default mail sound on OS/2, so just beep */
-  /* Also just beep if MMPM isn't installed */
-  if (aSoundAlias.EqualsLiteral("_moz_mailbeep") || (!gMMPMInstalled)) {
+  // We don't have a default mail sound on OS/2, so just beep.
+  // Also just beep if MMPM isn't installed.
+  if (aSoundAlias.EqualsLiteral("_moz_mailbeep") || (!sMMPMInstalled)) {
     Beep();
+    return NS_OK;
   }
-  else {
-    nsCAutoString nativeSoundAlias;
-    NS_CopyUnicodeToNative(aSoundAlias, nativeSoundAlias);
-    HOBJECT hobject = WinQueryObject(nativeSoundAlias.get());
-    if (hobject)
-      WinSetObjectData(hobject, "OPEN=DEFAULT");
-    else 
-      Beep();
-  }
+  nsCAutoString nativeSoundAlias;
+  NS_CopyUnicodeToNative(aSoundAlias, nativeSoundAlias);
+
+  ARGBUFFER arg;
+  memset(&arg, '\0', sizeof(arg));
+  APIRET rc = DosCreateEventSem(NULL, &(arg.hev), 0UL, 0UL);
+
+  // Play the sound on a new thread using MMOS2, in this case pass
+  // the filename in the argument structure.
+  arg.pszFilename = (PSZ)nativeSoundAlias.get();
+  _beginthread(playSound, NULL, 32768, (void *)&arg);
+
+  // Try to wait a while until the file is loaded, but not too long...
+  rc = DosWaitEventSem(arg.hev, 100);
+  rc = DosCloseEventSem(arg.hev);
+
   return NS_OK;
 }
-
diff -r 9864735a4241 widget/src/windows/nsWindow.cpp
--- a/widget/src/windows/nsWindow.cpp	Mon Sep 22 11:50:03 2008 -0700
+++ b/widget/src/windows/nsWindow.cpp	Fri Sep 26 09:30:25 2008 -0500
@@ -3527,16 +3527,17 @@ SetupKeyModifiersSequence(nsTArray<KeyPa
 
 nsresult
 nsWindow::SynthesizeNativeKeyEvent(PRInt32 aNativeKeyboardLayout,
                                    PRInt32 aNativeKeyCode,
                                    PRUint32 aModifierFlags,
                                    const nsAString& aCharacters,
                                    const nsAString& aUnmodifiedCharacters)
 {
+#ifndef WINCE  //Win CE doesn't support many of the calls used in this method, perhaps theres another way
   nsPrintfCString layoutName("%08x", aNativeKeyboardLayout);
   HKL loadedLayout = LoadKeyboardLayoutA(layoutName.get(), KLF_NOTELLSHELL);
   if (loadedLayout == NULL)
     return NS_ERROR_NOT_AVAILABLE;
 
   // Setup clean key state and load desired layout
   BYTE originalKbdState[256];
   ::GetKeyboardState(originalKbdState);
@@ -3588,16 +3589,19 @@ nsWindow::SynthesizeNativeKeyEvent(PRInt
   // Restore old key state and layout
   ::SetKeyboardState(originalKbdState);
   gKeyboardLayout = oldLayout;
   gKbdLayout.LoadLayout(gKeyboardLayout);
   SetupModKeyState();
   
   UnloadKeyboardLayout(loadedLayout);
   return NS_OK;
+#else  //XXX: is there another way to do this?
+  return NS_ERROR_NOT_IMPLEMENTED;
+#endif  
 }
 
 void nsWindow::ConstrainZLevel(HWND *aAfter)
 {
   nsZLevelEvent  event(PR_TRUE, NS_SETZLEVEL, this);
   nsWindow      *aboveWindow = 0;
 
   InitEvent(event);
@@ -4137,16 +4141,17 @@ PRBool nsWindow::ProcessMessage(UINT msg
         nsMenuEvent event(PR_TRUE, NS_MENU_SELECTED, this);
         event.mCommand = LOWORD(wParam);
         InitEvent(event);
         result = DispatchWindowEvent(&event);
       }
     }
     break;
 
+#ifndef WINCE
     // WM_QUERYENDSESSION must be handled by all windows.
     // Otherwise Windows thinks the window can just be killed at will.
     case WM_QUERYENDSESSION:
       if (sCanQuit == TRI_UNKNOWN)
       {
         // Ask if it's ok to quit, and store the answer until we
         // get WM_ENDSESSION signaling the round is complete.
         nsCOMPtr<nsIObserverService> obsServ =
@@ -4181,18 +4186,17 @@ PRBool nsWindow::ProcessMessage(UINT msg
         obsServ->NotifyObservers(nsnull, "profile-change-teardown", context.get());
         obsServ->NotifyObservers(nsnull, "profile-before-change", context.get());
         // Then a controlled but very quick exit.
         _exit(0);
       }
       sCanQuit = TRI_UNKNOWN;
       result = PR_TRUE;
       break;
-    
-#ifndef WINCE
+
     case WM_DISPLAYCHANGE:
       DispatchStandardEvent(NS_DISPLAYCHANGED);
       break;
 #endif
 
     case WM_SYSCOLORCHANGE:
       // Note: This is sent for child windows as well as top-level windows.
       // The Win32 toolkit normally only sends these events to top-level windows.
@@ -4734,31 +4738,32 @@ PRBool nsWindow::ProcessMessage(UINT msg
             *aRetValue = MA_NOACTIVATE;
 
           if (gSwitchKeyboardLayout && mLastKeyboardLayout)
             ActivateKeyboardLayout(mLastKeyboardLayout, 0);
         }
       }
       break;
 
+#ifndef WINCE
+
     case WM_MOUSEACTIVATE:
       if (mWindowType == eWindowType_popup) {
         // a popup with a parent owner should not be activated when clicked
         // but should still allow the mouse event to be fired, so the return
         // value is set to MA_NOACTIVATE. But if the owner isn't the frontmost
         // window, just use default processing so that the window is activated.
         HWND owner = ::GetWindow(mWnd, GW_OWNER);
         if (owner && owner == ::GetForegroundWindow()) {
           *aRetValue = MA_NOACTIVATE;
           result = PR_TRUE;
         }
       }
       break;
 
-#ifndef WINCE
     case WM_WINDOWPOSCHANGING:
     {
       LPWINDOWPOS info = (LPWINDOWPOS) lParam;
       // enforce local z-order rules
       if (!(info->flags & SWP_NOZORDER))
         ConstrainZLevel(&info->hwndInsertAfter);
       // prevent rude external programs from making hidden window visible
       if (mWindowType == eWindowType_invisible)
@@ -6920,17 +6925,17 @@ BOOL nsWindow::OnIMEComposition(LPARAM a
 
     sIMEAttributeArrayLength = attrStrLen;
 
     //--------------------------------------------------------
     // 4. Get GCS_CURSOPOS
     //--------------------------------------------------------
     sIMECursorPosition = ::ImmGetCompositionStringW(hIMEContext, GCS_CURSORPOS, NULL, 0);
 
-    NS_ASSERTION(sIMECursorPosition <= sIMECompUnicode->Length(), "illegal pos");
+    NS_ASSERTION(sIMECursorPosition <= (long)sIMECompUnicode->Length(), "illegal pos");
 
 #ifdef DEBUG_IME
     printf("sIMECursorPosition(Unicode): %d\n", sIMECursorPosition);
 #endif
     //--------------------------------------------------------
     // 5. Send the text event
     //--------------------------------------------------------
     HandleTextEvent(hIMEContext);
diff -r 9864735a4241 xpfe/components/history/src/nsHistoryLoadListener.h
--- a/xpfe/components/history/src/nsHistoryLoadListener.h	Mon Sep 22 11:50:03 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,64 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 1998
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Alec Flett <alecf@netscape.com>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either of the GNU General Public License Version 2 or later (the "GPL"),
- * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-
-#include "nsIWebProgressListener.h"
-#include "nsIBrowserHistory.h"
-#include "nsCOMPtr.h"
-#include "nsIComponentManager.h"
-#include "nsWeakReference.h"
-#include "nsIGenericFactory.h"
-
-class nsHistoryLoadListener : public nsIWebProgressListener,
-                              public nsSupportsWeakReference
-{
- public:
-    nsHistoryLoadListener(nsIBrowserHistory *);
-    virtual ~nsHistoryLoadListener();
-
-    nsresult Init();
-
-    NS_DECL_ISUPPORTS
-    NS_DECL_NSIWEBPROGRESSLISTENER
-        
- protected:
-    nsCOMPtr<nsIBrowserHistory> mHistory;
-
-};
-
diff -r 9864735a4241 xpfe/global/resources/content/nsWidgetStateManager.js
--- a/xpfe/global/resources/content/nsWidgetStateManager.js	Mon Sep 22 11:50:03 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,425 +0,0 @@
-/* -*- Mode: Java; tab-width: 2; c-basic-offset: 2; -*-
- *
- * ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org Code.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 1998
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Ben Goodger <ben@netscape.com> (Original Author)
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either of the GNU General Public License Version 2 or later (the "GPL"),
- * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-/** Presenting widgetStateManager the Third.
- *   a production of ye olde bard Ben Goodger and his Merry XUL Widget Crewe.
- *  =>> MODIFICATIONS MUST BE REVIEWED BY ben@netscape.com!!! <<=
- **/
-
-var wsm;
-
-function nsWidgetStateManager (aFrameID)
-{
-
-  this.dataManager = {
-    /** Persisted Data Hash Table
-     *  Page_ID -> Element_ID -> Property -> Value
-     **/
-    pageData: { },
-
-    setPageData: function (aPageTag, aDataObject)
-    {
-      this.pageData[aPageTag] = aDataObject;
-    },
-
-    getPageData: function (aPageTag)
-    {
-      if (!(aPageTag in this.pageData))
-        this.pageData[aPageTag] = { };
-      return this.pageData[aPageTag];
-    },
-
-    setItemData: function (aPageTag, aItemID, aDataObject)
-    {
-      if (!(aPageTag in this.pageData))
-        this.pageData[aPageTag] = new Object();
-      
-      this.pageData[aPageTag][aItemID] = aDataObject;
-    },
-
-    getItemData: function (aPageTag, aItemID)
-    {
-      if (!(aItemID in this.pageData[aPageTag]))
-        this.pageData[aPageTag][aItemID] = new Object();
-      return this.pageData[aPageTag][aItemID];
-    }
-  }
-
-  this.contentID    = aFrameID;
-
-  wsm               = this;
-
-  /** Element Handlers
-   *  Provides default get and set handler functions for supported
-   *  widgets. Clients can override or add new widgets.
-   **/
-  this.handlers     = {
-    colorpicker:
-      {  get: wsm.get_Colorpicker, set: wsm.set_Colorpicker   },
-    menulist:
-      {  get: wsm.get_Menulist,    set: wsm.set_Menulist      },
-    radiogroup:
-      {  get: wsm.get_Radiogroup,  set: wsm.set_Radiogroup    },
-    checkbox:
-      {  get: wsm.get_Checkbox,    set: wsm.set_Checkbox      },
-    textbox:
-      {  get: wsm.get_Textbox,     set: wsm.set_Textbox       },
-    listitem:
-      {  get: wsm.get_Listitem,    set: wsm.set_Listitem      },
-    data:
-      {  get: wsm.get_Data,        set: wsm.set_Data          },
-    default_handler:
-      {  get: wsm.get_Default,     set: wsm.set_Default       }
-  }
-
-  // extra attributes to scan and save.
-  this.attributes   = [];
-}
-
-nsWidgetStateManager.prototype =
-{
-  get contentArea ()
-  {
-    return window.frames[this.contentID];
-  },
-
-  savePageData: function (aPageTag)
-  {
-    if (!(aPageTag in this.dataManager.pageData))
-      return;
-
-    // Automatic element retrieval. This is done in two ways.
-    // 1) if an element id array is present in the document, this is
-    //    used to build a list of elements to persist. <-- performant
-    // 2) otherwise, all elements with "wsm_persist" set to true
-    //    are persisted <-- non-performant.
-    var elements;
-    if ("_elementIDs" in this.contentArea) {
-      elements = [];
-      for (var i = 0; i < this.contentArea._elementIDs.length; i++) {
-        var elt = this.contentArea.document.getElementById(this.contentArea._elementIDs[i]);
-        if (elt)
-          elements[elements.length] = elt;
-        else {
-          // see bug #40329. People forget this too often, and it breaks Prefs
-          dump("*** FIX ME: '_elementIDs' in '" + this.contentArea.location.href.split('/').pop() +
-               "' contains a reference to a non-existent element ID '" +
-          this.contentArea._elementIDs[i] + "'.\n");
-        }
-      }
-    }
-    else 
-      elements = this.contentArea.document.getElementsByAttribute("wsm_persist", "true");
-
-    for (var ii = 0; ii < elements.length; ii++) {
-      var elementID   = elements[ii].id;
-      var elementType = elements[ii].localName;
-
-      if (!(aPageTag in this.dataManager.pageData))
-        this.dataManager.pageData[aPageTag] = [];
-      this.dataManager.pageData[aPageTag][elementID] = [];
-
-      // persist attributes
-      var get_Func = (elementType in this.handlers) ?
-      this.handlers[elementType].get :
-      this.handlers.default_handler.get;
-      this.dataManager.setItemData(aPageTag, elementID, get_Func(elementID));
-    }
-
-    if ("GetFields" in this.contentArea) {
-      // save page data based on user supplied function in content area
-      var dataObject = this.dataManager.getPageData(aPageTag);
-      dataObject = this.contentArea.GetFields(dataObject);
-      if (dataObject)        
-        this.dataManager.setPageData(aPageTag, dataObject);
-    }
-  },
-
-  setPageData: function (aPageTag)
-  {
-    var pageData = this.dataManager.getPageData(aPageTag);
-    if ("SetFields" in this.contentArea) {
-      if (!this.contentArea.SetFields(pageData))
-      {
-        // If the function returns false (or null/undefined) then it
-        // doesn't want *us* to process the page data.
-        return;
-      }
-    }
-
-    for (var elementID in pageData) {
-      var element = this.contentArea.document.getElementById(elementID);
-      if (element) {
-        var elementType = element.localName;
-        var set_Func = (elementType in this.handlers) ?
-          this.handlers[elementType].set :
-          this.handlers.default_handler.set;
-        set_Func(elementID, pageData[elementID]);
-      }
-    }
-  },
-
-
-  /** Widget Get/Set Function Implementations
-   *  These can be overridden by the client.
-   **/
-  generic_Set: function (aElement, aDataObject)
-  {
-    if (aElement) {
-      for (var property in aDataObject) {
-        if (property == "localname")
-          continue;
-        if (!aDataObject[property] && typeof aDataObject[property] == "boolean")
-          aElement.removeAttribute(property);
-        else
-          aElement.setAttribute(property, aDataObject[property]);
-      }
-      
-      if (!aElement.getAttribute("disabled","true"))
-        aElement.removeAttribute("disabled");
-    }
-  },
-
-  generic_Get: function (aElement)
-  {
-    if (aElement) {
-      var dataObject = new Object();
-      var wsmAttributes = aElement.getAttribute("wsm_attributes");
-      var attributes = wsm.attributes;              // make a copy
-      if (wsmAttributes != "")
-        attributes.push(wsmAttributes.split(" "));  // modify the copy
-
-      for (var i = 0; i < attributes.length; i++)
-        dataObject[attributes[i]] = aElement.getAttribute(attributes[i]);
-
-      dataObject.localname = aElement.localName;
-      return dataObject;
-    }
-    return null;
-  },
-
-  // <colorpicker>
-  set_Colorpicker: function (aElementID, aDataObject)
-  {
-    var element = wsm.contentArea.document.getElementById(aElementID);
-    // set all generic properties
-    wsm.generic_Set(element, aDataObject);
-    // set colorpicker specific properties
-    if ('color' in aDataObject) {
-      try {
-        element.color = aDataObject.color;
-      }
-      catch (ex) {
-        dump(aElementID +", ex: " + ex + "\n");
-      }
-    }
-  },
-
-  get_Colorpicker: function (aElementID)
-  {
-    var element     = wsm.contentArea.document.getElementById(aElementID);
-    // retrieve all generic attributes
-    var dataObject  = wsm.generic_Get(element);
-    // retrieve all colorpicker specific attributes
-    if (dataObject) {
-      dataObject.color = element.color;
-      return dataObject;
-    }
-    return null;
-  },
-
-  // <menulist>
-  set_Menulist: function (aElementID, aDataObject)
-  {
-    var element = wsm.contentArea.document.getElementById(aElementID);
-    // set all generic properties
-    wsm.generic_Set(element, aDataObject);
-    // set menulist specific properties
-    if ("value" in aDataObject) {
-      try {
-        element.value = aDataObject.value;
-      }
-      catch (ex) {
-        dump(aElementID + ", ex: " + ex + "\n");
-      }
-    }
-  },
-
-  get_Menulist: function (aElementID)
-  {
-    var element     = wsm.contentArea.document.getElementById(aElementID);
-    // retrieve all generic attributes
-    var dataObject  = wsm.generic_Get(element);
-    // retrieve all menulist specific attributes
-    if (dataObject) {
-      dataObject.value = element.getAttribute("value");
-      return dataObject;
-    }
-    return null;
-  },
-
-  // <radiogroup>
-  set_Radiogroup: function (aElementID, aDataObject)
-  {
-    var element = wsm.contentArea.document.getElementById(aElementID);
-    wsm.generic_Set(element, aDataObject);
-    if ("value" in aDataObject)
-      element.value = aDataObject.value;
-    if ("disabled" in aDataObject)
-      element.disabled = aDataObject.disabled;
-  },
-
-  get_Radiogroup: function (aElementID)
-  {
-    var element = wsm.contentArea.document.getElementById(aElementID);
-    var dataObject = wsm.generic_Get(element);
-    if (dataObject) {
-      dataObject.value = element.getAttribute("value");
-      return dataObject;
-    }
-    return null;
-  },
-
-  // <textbox>
-  set_Textbox: function (aElementID, aDataObject)
-  {
-    var element = wsm.contentArea.document.getElementById(aElementID);
-    wsm.generic_Set(element, aDataObject);
-  },
-
-  get_Textbox: function (aElementID)
-  {
-    var element = wsm.contentArea.document.getElementById(aElementID);
-    var dataObject = wsm.generic_Get(element);
-    if (dataObject) {
-      dataObject.value = element.value;
-      return dataObject;
-    }
-    return null;
-  },
-
-  // <checkbox>
-  set_Checkbox: function (aElementID, aDataObject)
-  {
-    var element = wsm.contentArea.document.getElementById(aElementID);
-    // Set generic properites. 
-    wsm.generic_Set(element, aDataObject);
-    // Handle reversed boolean values.
-    if ("checked" in aDataObject && element.hasAttribute("reversed"))
-      element.checked = !aDataObject.checked; 
-  },
-
-  get_Checkbox: function (aElementID)
-  {
-    var element = wsm.contentArea.document.getElementById(aElementID);
-    var dataObject = wsm.generic_Get(element);
-    if (dataObject) {
-      var checked = element.checked;
-      dataObject.checked = element.getAttribute("reversed") == "true" ? !checked : checked;
-      return dataObject;
-    }
-    return null;
-  },
-
-  // <listitem>
-  set_Listitem: function (aElementID, aDataObject)
-  {
-    var element = wsm.contentArea.document.getElementById(aElementID);
-    wsm.generic_Set(element, aDataObject);
-    // Handle reversed boolean values.
-    if ("checked" in aDataObject && element.hasAttribute("reversed"))
-      element.checked = !aDataObject.checked; 
-  },
-
-  get_Listitem: function (aElementID)
-  {
-    var element = wsm.contentArea.document.getElementById(aElementID);
-    var dataObject = wsm.generic_Get(element);
-    if (dataObject) {
-      if (element.getAttribute("type") == "checkbox") {
-        var checked = element.checked;
-        dataObject.checked = element.getAttribute("reversed") == "true" ? !checked : checked;
-      }
-      return dataObject;
-    }
-    return null;
-  },
-
-  // <data>
-  set_Data: function (aElementID, aDataObject)
-  {
-    var element = wsm.contentArea.document.getElementById(aElementID);
-    wsm.generic_Set(element, aDataObject);
-    if ("value" in aDataObject)
-      element.setAttribute("value", aDataObject.value);
-  },
-
-  get_Data: function (aElementID)
-  {
-    var element = wsm.contentArea.document.getElementById(aElementID);
-    var dataObject = wsm.generic_Get(element);
-    if (dataObject) {
-      dataObject.value = element.getAttribute("value");
-      return dataObject;
-    }
-    return null;
-  },
-
-  // <default>
-  set_Default: function (aElementID, aDataObject)
-  {
-    var element = wsm.contentArea.document.getElementById(aElementID);
-    wsm.generic_Set(element, aDataObject);
-  },
-
-  get_Default: function (aElementID)
-  {
-    var element = wsm.contentArea.document.getElementById(aElementID);
-    var dataObject = wsm.generic_Get(element);
-    return dataObject ? dataObject : null;
-  }
-}
-
-
-// M:tHoF Greatest Hits Section (Append one line per edit):
-// it will be dark soon 
-// MANOS MADE ME PERMANENT! 
-// there is no way out of here
-// [The Master] not dead as you know it. He is with us always.
-
