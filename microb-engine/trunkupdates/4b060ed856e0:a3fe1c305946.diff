diff -r 4b060ed856e0 accessible/src/atk/nsMaiInterfaceComponent.cpp
--- a/accessible/src/atk/nsMaiInterfaceComponent.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/accessible/src/atk/nsMaiInterfaceComponent.cpp	Thu Oct 16 21:24:47 2008 -0500
@@ -71,17 +71,17 @@ refAccessibleAtPointCB(AtkComponent *aCo
     nsAccessibleWrap *accWrap = GetAccessibleWrap(ATK_OBJECT(aComponent));
     if (!accWrap || nsAccessibleWrap::MustPrune(accWrap))
         return nsnull;
 
     // nsIAccessible getChildAtPoint (x,y) is in screen pixels.
     if (aCoordType == ATK_XY_WINDOW) {
         nsCOMPtr<nsIDOMNode> domNode;
         accWrap->GetDOMNode(getter_AddRefs(domNode));
-        nsIntPoint winCoords = nsAccUtils::GetScreenCoordsForWindow(domNode);
+        nsIntPoint winCoords = nsCoreUtils::GetScreenCoordsForWindow(domNode);
         aAccX += winCoords.x;
         aAccY += winCoords.y;
     }
 
     nsCOMPtr<nsIAccessible> pointAcc;
     accWrap->GetChildAtPoint(aAccX, aAccY, getter_AddRefs(pointAcc));
     if (!pointAcc) {
         return nsnull;
@@ -112,17 +112,17 @@ getExtentsCB(AtkComponent *aComponent,
     // Returned in screen coordinates
     nsresult rv = accWrap->GetBounds(&nsAccX, &nsAccY,
                                      &nsAccWidth, &nsAccHeight);
     if (NS_FAILED(rv))
         return;
     if (aCoordType == ATK_XY_WINDOW) {
         nsCOMPtr<nsIDOMNode> domNode;
         accWrap->GetDOMNode(getter_AddRefs(domNode));
-        nsIntPoint winCoords = nsAccUtils::GetScreenCoordsForWindow(domNode);
+        nsIntPoint winCoords = nsCoreUtils::GetScreenCoordsForWindow(domNode);
         nsAccX -= winCoords.x;
         nsAccY -= winCoords.y;
     }
 
     *aAccX = nsAccX;
     *aAccY = nsAccY;
     *aAccWidth = nsAccWidth;
     *aAccHeight = nsAccHeight;
diff -r 4b060ed856e0 accessible/src/base/Makefile.in
--- a/accessible/src/base/Makefile.in	Tue Oct 14 17:12:28 2008 -0700
+++ b/accessible/src/base/Makefile.in	Thu Oct 16 21:24:47 2008 -0500
@@ -74,17 +74,18 @@ REQUIRES	= appshell \
 
 CPPSRCS = \
   nsAccessNode.cpp \
   nsAccessibleEventData.cpp \
   nsARIAMap.cpp \
   nsDocAccessible.cpp \
   nsOuterDocAccessible.cpp \
   nsAccessibilityAtoms.cpp \
-  nsAccessibilityUtils.cpp \
+  nsCoreUtils.cpp \
+  nsAccUtils.cpp \
   nsAccessibilityService.cpp \
   nsAccessible.cpp \
   nsAccessibleRelation.cpp \
   nsAccessibleTreeWalker.cpp \
   nsBaseWidgetAccessible.cpp \
   nsFormControlAccessible.cpp \
   nsRootAccessible.cpp \
   nsApplicationAccessible.cpp \
diff -r 4b060ed856e0 accessible/src/base/nsAccUtils.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/accessible/src/base/nsAccUtils.cpp	Thu Oct 16 21:24:47 2008 -0500
@@ -0,0 +1,583 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Alexander Surkov <surkov.alexander@gmail.com> (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsCoreUtils.h"
+#include "nsAccUtils.h"
+
+#include "nsIAccessibleStates.h"
+#include "nsIAccessibleTypes.h"
+#include "nsPIAccessible.h"
+#include "nsPIAccessNode.h"
+#include "nsAccessibleEventData.h"
+
+#include "nsAccessibilityAtoms.h"
+#include "nsAccessible.h"
+#include "nsARIAMap.h"
+#include "nsIDOMXULContainerElement.h"
+#include "nsIDOMXULSelectCntrlEl.h"
+#include "nsIDOMXULSelectCntrlItemEl.h"
+#include "nsWhitespaceTokenizer.h"
+
+void
+nsAccUtils::GetAccAttr(nsIPersistentProperties *aAttributes,
+                       nsIAtom *aAttrName, nsAString& aAttrValue)
+{
+  aAttrValue.Truncate();
+
+  nsCAutoString attrName;
+  aAttrName->ToUTF8String(attrName);
+  aAttributes->GetStringProperty(attrName, aAttrValue);
+}
+
+void
+nsAccUtils::SetAccAttr(nsIPersistentProperties *aAttributes,
+                       nsIAtom *aAttrName, const nsAString& aAttrValue)
+{
+  nsAutoString oldValue;
+  nsCAutoString attrName;
+
+  aAttrName->ToUTF8String(attrName);
+  aAttributes->SetStringProperty(attrName, aAttrValue, oldValue);
+}
+
+void
+nsAccUtils::GetAccGroupAttrs(nsIPersistentProperties *aAttributes,
+                             PRInt32 *aLevel, PRInt32 *aPosInSet,
+                             PRInt32 *aSetSize)
+{
+  *aLevel = 0;
+  *aPosInSet = 0;
+  *aSetSize = 0;
+
+  nsAutoString value;
+  PRInt32 error = NS_OK;
+
+  GetAccAttr(aAttributes, nsAccessibilityAtoms::level, value);
+  if (!value.IsEmpty()) {
+    PRInt32 level = value.ToInteger(&error);
+    if (NS_SUCCEEDED(error))
+      *aLevel = level;
+  }
+
+  GetAccAttr(aAttributes, nsAccessibilityAtoms::posinset, value);
+  if (!value.IsEmpty()) {
+    PRInt32 posInSet = value.ToInteger(&error);
+    if (NS_SUCCEEDED(error))
+      *aPosInSet = posInSet;
+  }
+
+  GetAccAttr(aAttributes, nsAccessibilityAtoms::setsize, value);
+  if (!value.IsEmpty()) {
+    PRInt32 sizeSet = value.ToInteger(&error);
+    if (NS_SUCCEEDED(error))
+      *aSetSize = sizeSet;
+  }
+}
+
+PRBool
+nsAccUtils::HasAccGroupAttrs(nsIPersistentProperties *aAttributes)
+{
+  nsAutoString value;
+
+  GetAccAttr(aAttributes, nsAccessibilityAtoms::setsize, value);
+  if (!value.IsEmpty()) {
+    GetAccAttr(aAttributes, nsAccessibilityAtoms::posinset, value);
+    return !value.IsEmpty();
+  }
+
+  return PR_FALSE;
+}
+
+void
+nsAccUtils::SetAccGroupAttrs(nsIPersistentProperties *aAttributes,
+                             PRInt32 aLevel, PRInt32 aPosInSet,
+                             PRInt32 aSetSize)
+{
+  nsAutoString value;
+
+  if (aLevel) {
+    value.AppendInt(aLevel);
+    SetAccAttr(aAttributes, nsAccessibilityAtoms::level, value);
+  }
+
+  if (aSetSize && aPosInSet) {
+    value.Truncate();
+    value.AppendInt(aPosInSet);
+    SetAccAttr(aAttributes, nsAccessibilityAtoms::posinset, value);
+
+    value.Truncate();
+    value.AppendInt(aSetSize);
+    SetAccAttr(aAttributes, nsAccessibilityAtoms::setsize, value);
+  }
+}
+
+void
+nsAccUtils::SetAccAttrsForXULSelectControlItem(nsIDOMNode *aNode,
+                                               nsIPersistentProperties *aAttributes)
+{
+  nsCOMPtr<nsIDOMXULSelectControlItemElement> item(do_QueryInterface(aNode));
+  if (!item)
+    return;
+
+  nsCOMPtr<nsIDOMXULSelectControlElement> control;
+  item->GetControl(getter_AddRefs(control));
+  if (!control)
+    return;
+
+  PRUint32 itemsCount = 0;
+  control->GetItemCount(&itemsCount);
+
+  PRInt32 indexOf = 0;
+  control->GetIndexOfItem(item, &indexOf);
+
+  PRUint32 setSize = itemsCount, posInSet = indexOf;
+  for (PRUint32 index = 0; index < itemsCount; index++) {
+    nsCOMPtr<nsIDOMXULSelectControlItemElement> currItem;
+    control->GetItemAtIndex(index, getter_AddRefs(currItem));
+    nsCOMPtr<nsIDOMNode> currNode(do_QueryInterface(currItem));
+
+    nsCOMPtr<nsIAccessible> itemAcc;
+    nsAccessNode::GetAccService()->GetAccessibleFor(currNode,
+                                                    getter_AddRefs(itemAcc));
+    if (!itemAcc ||
+        nsAccessible::State(itemAcc) & nsIAccessibleStates::STATE_INVISIBLE) {
+      setSize--;
+      if (index < static_cast<PRUint32>(indexOf))
+        posInSet--;
+    }
+  }
+
+  SetAccGroupAttrs(aAttributes, 0, posInSet + 1, setSize);
+}
+
+void
+nsAccUtils::SetAccAttrsForXULContainerItem(nsIDOMNode *aNode,
+                                           nsIPersistentProperties *aAttributes)
+{
+  nsCOMPtr<nsIDOMXULContainerItemElement> item(do_QueryInterface(aNode));
+  if (!item)
+    return;
+
+  nsCOMPtr<nsIDOMXULContainerElement> container;
+  item->GetParentContainer(getter_AddRefs(container));
+  if (!container)
+    return;
+
+  // Get item count.
+  PRUint32 itemsCount = 0;
+  container->GetItemCount(&itemsCount);
+
+  // Get item index.
+  PRInt32 indexOf = 0;
+  container->GetIndexOfItem(item, &indexOf);
+
+  // Calculate set size and position in the set.
+  PRUint32 setSize = 0, posInSet = 0;
+  for (PRInt32 index = indexOf; index >= 0; index--) {
+    nsCOMPtr<nsIDOMXULElement> item;
+    container->GetItemAtIndex(index, getter_AddRefs(item));
+
+    nsCOMPtr<nsIAccessible> itemAcc;
+    nsAccessNode::GetAccService()->GetAccessibleFor(item,
+                                                    getter_AddRefs(itemAcc));
+
+    if (itemAcc) {
+      PRUint32 itemRole = nsAccessible::Role(itemAcc);
+      if (itemRole == nsIAccessibleRole::ROLE_SEPARATOR)
+        break; // We reached the beginning of our group.
+
+      PRUint32 itemState = nsAccessible::State(itemAcc);
+      if (!(itemState & nsIAccessibleStates::STATE_INVISIBLE)) {
+        setSize++;
+        posInSet++;
+      }
+    }
+  }
+
+  for (PRInt32 index = indexOf + 1; index < static_cast<PRInt32>(itemsCount);
+       index++) {
+    nsCOMPtr<nsIDOMXULElement> item;
+    container->GetItemAtIndex(index, getter_AddRefs(item));
+    
+    nsCOMPtr<nsIAccessible> itemAcc;
+    nsAccessNode::GetAccService()->GetAccessibleFor(item,
+                                                    getter_AddRefs(itemAcc));
+
+    if (itemAcc) {
+      PRUint32 itemRole = nsAccessible::Role(itemAcc);
+      if (itemRole == nsIAccessibleRole::ROLE_SEPARATOR)
+        break; // We reached the end of our group.
+
+      PRUint32 itemState = nsAccessible::State(itemAcc);
+      if (!(itemState & nsIAccessibleStates::STATE_INVISIBLE))
+        setSize++;
+    }
+  }
+
+  // Get level of the item.
+  PRInt32 level = -1;
+  while (container) {
+    level++;
+
+    nsCOMPtr<nsIDOMXULContainerElement> parentContainer;
+    container->GetParentContainer(getter_AddRefs(parentContainer));
+    parentContainer.swap(container);
+  }
+  
+  SetAccGroupAttrs(aAttributes, level, posInSet, setSize);
+}
+
+void
+nsAccUtils::SetLiveContainerAttributes(nsIPersistentProperties *aAttributes,
+                                       nsIContent *aStartContent,
+                                       nsIContent *aTopContent)
+{
+  nsAutoString atomic, live, relevant, channel, busy;
+  nsIContent *ancestor = aStartContent;
+  while (ancestor) {
+    if (relevant.IsEmpty() &&
+        ancestor->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_relevant, relevant))
+      SetAccAttr(aAttributes, nsAccessibilityAtoms::containerRelevant, relevant);
+
+    if (live.IsEmpty() &&
+        ancestor->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_live, live))
+      SetAccAttr(aAttributes, nsAccessibilityAtoms::containerLive, live);
+
+    if (channel.IsEmpty() &&
+        ancestor->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_channel, channel))
+      SetAccAttr(aAttributes, nsAccessibilityAtoms::containerChannel, channel);
+
+    if (atomic.IsEmpty() &&
+        ancestor->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_atomic, atomic))
+      SetAccAttr(aAttributes, nsAccessibilityAtoms::containerAtomic, atomic);
+
+    if (busy.IsEmpty() &&
+        ancestor->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_busy, busy))
+      SetAccAttr(aAttributes, nsAccessibilityAtoms::containerBusy, busy);
+
+    if (ancestor == aTopContent)
+      break;
+
+    ancestor = ancestor->GetParent();
+    if (!ancestor)
+      ancestor = aTopContent; // Use <body>/<frameset>
+  }
+}
+
+PRBool
+nsAccUtils::IsARIAPropForObjectAttr(nsIAtom *aAtom)
+{
+  return aAtom != nsAccessibilityAtoms::aria_activedescendant &&
+    aAtom != nsAccessibilityAtoms::aria_checked &&
+    aAtom != nsAccessibilityAtoms::aria_controls &&
+    aAtom != nsAccessibilityAtoms::aria_describedby &&
+    aAtom != nsAccessibilityAtoms::aria_disabled &&
+    aAtom != nsAccessibilityAtoms::aria_expanded &&
+    aAtom != nsAccessibilityAtoms::aria_flowto &&
+    aAtom != nsAccessibilityAtoms::aria_invalid &&
+    aAtom != nsAccessibilityAtoms::aria_haspopup &&
+    aAtom != nsAccessibilityAtoms::aria_labelledby &&
+    aAtom != nsAccessibilityAtoms::aria_multiline &&
+    aAtom != nsAccessibilityAtoms::aria_multiselectable &&
+    aAtom != nsAccessibilityAtoms::aria_owns &&
+    aAtom != nsAccessibilityAtoms::aria_pressed &&
+    aAtom != nsAccessibilityAtoms::aria_readonly &&
+    aAtom != nsAccessibilityAtoms::aria_relevant &&
+    aAtom != nsAccessibilityAtoms::aria_required &&
+    aAtom != nsAccessibilityAtoms::aria_selected &&
+    aAtom != nsAccessibilityAtoms::aria_valuemax &&
+    aAtom != nsAccessibilityAtoms::aria_valuemin &&
+    aAtom != nsAccessibilityAtoms::aria_valuenow &&
+    aAtom != nsAccessibilityAtoms::aria_valuetext;
+}
+
+nsresult
+nsAccUtils::FireAccEvent(PRUint32 aEventType, nsIAccessible *aAccessible,
+                         PRBool aIsAsynch)
+{
+  NS_ENSURE_ARG(aAccessible);
+
+  nsCOMPtr<nsPIAccessible> pAccessible(do_QueryInterface(aAccessible));
+  NS_ASSERTION(pAccessible, "Accessible doesn't implement nsPIAccessible");
+
+  nsCOMPtr<nsIAccessibleEvent> event =
+    new nsAccEvent(aEventType, aAccessible, aIsAsynch);
+  NS_ENSURE_TRUE(event, NS_ERROR_OUT_OF_MEMORY);
+
+  return pAccessible->FireAccessibleEvent(event);
+}
+
+already_AddRefed<nsIAccessible>
+nsAccUtils::GetAncestorWithRole(nsIAccessible *aDescendant, PRUint32 aRole)
+{
+  nsCOMPtr<nsIAccessible> parentAccessible = aDescendant, testRoleAccessible;
+  while (NS_SUCCEEDED(parentAccessible->GetParent(getter_AddRefs(testRoleAccessible))) &&
+         testRoleAccessible) {
+    PRUint32 testRole;
+    testRoleAccessible->GetFinalRole(&testRole);
+    if (testRole == aRole) {
+      nsIAccessible *returnAccessible = testRoleAccessible;
+      NS_ADDREF(returnAccessible);
+      return returnAccessible;
+    }
+    nsCOMPtr<nsIAccessibleDocument> docAccessible = do_QueryInterface(testRoleAccessible);
+    if (docAccessible) {
+      break;
+    }
+    parentAccessible.swap(testRoleAccessible);
+  }
+  return nsnull;
+}
+
+void
+nsAccUtils::GetARIATreeItemParent(nsIAccessible *aStartTreeItem,
+                                  nsIContent *aStartContent,
+                                  nsIAccessible **aTreeItemParentResult)
+{
+  *aTreeItemParentResult = nsnull;
+  nsAutoString levelStr;
+  PRInt32 level = 0;
+  if (aStartContent->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_level, levelStr)) {
+    // This is a tree that uses aria-level to define levels, so find the first previous
+    // sibling accessible where level is defined to be less than the current level
+    PRInt32 success;
+    level = levelStr.ToInteger(&success);
+    if (level > 1 && NS_SUCCEEDED(success)) {
+      nsCOMPtr<nsIAccessible> currentAccessible = aStartTreeItem, prevAccessible;
+      while (PR_TRUE) {
+        currentAccessible->GetPreviousSibling(getter_AddRefs(prevAccessible));
+        currentAccessible.swap(prevAccessible);
+        nsCOMPtr<nsIAccessNode> accessNode = do_QueryInterface(currentAccessible);
+        if (!accessNode) {
+          break; // Reached top of tree, no higher level found
+        }
+        PRUint32 role;
+        currentAccessible->GetFinalRole(&role);
+        if (role != nsIAccessibleRole::ROLE_OUTLINEITEM)
+          continue;
+        nsCOMPtr<nsIDOMNode> treeItemNode;
+        accessNode->GetDOMNode(getter_AddRefs(treeItemNode));
+        nsCOMPtr<nsIContent> treeItemContent = do_QueryInterface(treeItemNode);
+        if (treeItemContent &&
+            treeItemContent->GetAttr(kNameSpaceID_None,
+                                     nsAccessibilityAtoms::aria_level, levelStr)) {
+          if (levelStr.ToInteger(&success) < level && NS_SUCCEEDED(success)) {
+            NS_ADDREF(*aTreeItemParentResult = currentAccessible);
+            return;
+          }
+        }
+      }
+    }
+  }
+
+  // Possibly a tree arranged by using role="group" to organize levels
+  // In this case the parent of the tree item will be a group and the
+  // previous sibling of that should be the tree item parent.
+  // Or, if the parent is something other than a tree we will return that.
+  nsCOMPtr<nsIAccessible> parentAccessible;
+  aStartTreeItem->GetParent(getter_AddRefs(parentAccessible));
+  if (!parentAccessible)
+    return;
+  PRUint32 role;
+  parentAccessible->GetFinalRole(&role);
+  if (role != nsIAccessibleRole::ROLE_GROUPING) {
+    NS_ADDREF(*aTreeItemParentResult = parentAccessible);
+    return; // The container for the tree items
+  }
+  nsCOMPtr<nsIAccessible> prevAccessible;
+  parentAccessible->GetPreviousSibling(getter_AddRefs(prevAccessible));
+  if (!prevAccessible)
+    return;
+  prevAccessible->GetFinalRole(&role);
+  if (role == nsIAccessibleRole::ROLE_TEXT_LEAF) {
+    // XXX Sometimes an empty text accessible is in the hierarchy here,
+    // although the text does not appear to be rendered, GetRenderedText() says that it is
+    // so we need to skip past it to find the true previous sibling
+    nsCOMPtr<nsIAccessible> tempAccessible = prevAccessible;
+    tempAccessible->GetPreviousSibling(getter_AddRefs(prevAccessible));
+    if (!prevAccessible)
+      return;
+    prevAccessible->GetFinalRole(&role);
+  }
+  if (role == nsIAccessibleRole::ROLE_OUTLINEITEM) {
+    // Previous sibling of parent group is a tree item -- this is the conceptual tree item parent
+    NS_ADDREF(*aTreeItemParentResult = prevAccessible);
+  }
+}
+
+nsresult
+nsAccUtils::ConvertToScreenCoords(PRInt32 aX, PRInt32 aY,
+                                  PRUint32 aCoordinateType,
+                                  nsIAccessNode *aAccessNode,
+                                  nsIntPoint *aCoords)
+{
+  NS_ENSURE_ARG_POINTER(aCoords);
+
+  aCoords->MoveTo(aX, aY);
+
+  switch (aCoordinateType) {
+    case nsIAccessibleCoordinateType::COORDTYPE_SCREEN_RELATIVE:
+      break;
+
+    case nsIAccessibleCoordinateType::COORDTYPE_WINDOW_RELATIVE:
+    {
+      NS_ENSURE_ARG(aAccessNode);
+      *aCoords += GetScreenCoordsForWindow(aAccessNode);
+      break;
+    }
+
+    case nsIAccessibleCoordinateType::COORDTYPE_PARENT_RELATIVE:
+    {
+      NS_ENSURE_ARG(aAccessNode);
+      *aCoords += GetScreenCoordsForParent(aAccessNode);
+      break;
+    }
+
+    default:
+      return NS_ERROR_INVALID_ARG;
+  }
+
+  return NS_OK;
+}
+
+nsresult
+nsAccUtils::ConvertScreenCoordsTo(PRInt32 *aX, PRInt32 *aY,
+                                  PRUint32 aCoordinateType,
+                                  nsIAccessNode *aAccessNode)
+{
+  switch (aCoordinateType) {
+    case nsIAccessibleCoordinateType::COORDTYPE_SCREEN_RELATIVE:
+      break;
+
+    case nsIAccessibleCoordinateType::COORDTYPE_WINDOW_RELATIVE:
+    {
+      NS_ENSURE_ARG(aAccessNode);
+      nsIntPoint coords = nsAccUtils::GetScreenCoordsForWindow(aAccessNode);
+      *aX -= coords.x;
+      *aY -= coords.y;
+      break;
+    }
+
+    case nsIAccessibleCoordinateType::COORDTYPE_PARENT_RELATIVE:
+    {
+      NS_ENSURE_ARG(aAccessNode);
+      nsIntPoint coords = nsAccUtils::GetScreenCoordsForParent(aAccessNode);
+      *aX -= coords.x;
+      *aY -= coords.y;
+      break;
+    }
+
+    default:
+      return NS_ERROR_INVALID_ARG;
+  }
+
+  return NS_OK;
+}
+
+nsIntPoint
+nsAccUtils::GetScreenCoordsForWindow(nsIAccessNode *aAccessNode)
+{
+  nsCOMPtr<nsIDOMNode> DOMNode;
+  aAccessNode->GetDOMNode(getter_AddRefs(DOMNode));
+  if (DOMNode)
+    return nsCoreUtils::GetScreenCoordsForWindow(DOMNode);
+
+  return nsIntPoint(0, 0);
+}
+
+nsIntPoint
+nsAccUtils::GetScreenCoordsForParent(nsIAccessNode *aAccessNode)
+{
+  nsCOMPtr<nsPIAccessNode> parent;
+  nsCOMPtr<nsIAccessible> accessible(do_QueryInterface(aAccessNode));
+  if (accessible) {
+    nsCOMPtr<nsIAccessible> parentAccessible;
+    accessible->GetParent(getter_AddRefs(parentAccessible));
+    parent = do_QueryInterface(parentAccessible);
+  } else {
+    nsCOMPtr<nsIAccessNode> parentAccessNode;
+    aAccessNode->GetParentNode(getter_AddRefs(parentAccessNode));
+    parent = do_QueryInterface(parentAccessNode);
+  }
+
+  if (!parent)
+    return nsIntPoint(0, 0);
+
+  nsIFrame *parentFrame = parent->GetFrame();
+  if (!parentFrame)
+    return nsIntPoint(0, 0);
+
+  nsIntRect parentRect = parentFrame->GetScreenRectExternal();
+  return nsIntPoint(parentRect.x, parentRect.y);
+}
+
+nsRoleMapEntry*
+nsAccUtils::GetRoleMapEntry(nsIDOMNode *aNode)
+{
+  nsIContent *content = nsAccessible::GetRoleContent(aNode);
+  nsAutoString roleString;
+  if (!content || !content->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::role, roleString)) {
+    return nsnull;
+  }
+
+  nsWhitespaceTokenizer tokenizer(roleString);
+  while (tokenizer.hasMoreTokens()) {
+    // Do a binary search through table for the next role in role list
+    const char *role = NS_LossyConvertUTF16toASCII(tokenizer.nextToken()).get();
+    PRInt32 low = 0;
+    PRInt32 high = nsARIAMap::gWAIRoleMapLength;
+    while (low <= high) {
+      PRInt32 index = low + ((high - low) / 2);
+      PRInt32 compare = PL_strcmp(role, nsARIAMap::gWAIRoleMap[index].roleString);
+      if (compare == 0) {
+        // The  role attribute maps to an entry in the role table
+        return &nsARIAMap::gWAIRoleMap[index];
+      }
+      if (compare < 0) {
+        high = index - 1;
+      }
+      else {
+        low = index + 1;
+      }
+    }
+  }
+
+  // Always use some entry if there is a role string
+  // To ensure an accessible object is created
+  return &nsARIAMap::gLandmarkRoleMap;
+}
diff -r 4b060ed856e0 accessible/src/base/nsAccUtils.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/accessible/src/base/nsAccUtils.h	Thu Oct 16 21:24:47 2008 -0500
@@ -0,0 +1,217 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Alexander Surkov <surkov.alexander@gmail.com> (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsAccUtils_h_
+#define nsAccUtils_h_
+
+#include "nsIAccessible.h"
+#include "nsIAccessNode.h"
+#include "nsARIAMap.h"
+
+#include "nsIDOMNode.h"
+#include "nsIPersistentProperties2.h"
+#include "nsIContent.h"
+#include "nsPoint.h"
+
+class nsAccUtils
+{
+public:
+  /**
+   * Returns value of attribute from the given attributes container.
+   *
+   * @param aAttributes - attributes container
+   * @param aAttrName - the name of requested attribute
+   * @param aAttrValue - value of attribute
+   */
+  static void GetAccAttr(nsIPersistentProperties *aAttributes,
+                         nsIAtom *aAttrName,
+                         nsAString& aAttrValue);
+
+  /**
+   * Set value of attribute for the given attributes container.
+   *
+   * @param aAttributes - attributes container
+   * @param aAttrName - the name of requested attribute
+   * @param aAttrValue - new value of attribute
+   */
+  static void SetAccAttr(nsIPersistentProperties *aAttributes,
+                         nsIAtom *aAttrName,
+                         const nsAString& aAttrValue);
+
+  /**
+   * Return values of group attributes ('level', 'setsize', 'posinset')
+   */
+  static void GetAccGroupAttrs(nsIPersistentProperties *aAttributes,
+                               PRInt32 *aLevel,
+                               PRInt32 *aPosInSet,
+                               PRInt32 *aSetSize);
+
+  /**
+   * Returns true if there are level, posinset and sizeset attributes.
+   */
+  static PRBool HasAccGroupAttrs(nsIPersistentProperties *aAttributes);
+
+  /**
+   * Set group attributes ('level', 'setsize', 'posinset').
+   */
+  static void SetAccGroupAttrs(nsIPersistentProperties *aAttributes,
+                               PRInt32 aLevel,
+                               PRInt32 aPosInSet,
+                               PRInt32 aSetSize);
+
+  /**
+   * Set group attributes - 'level', 'setsize', 'posinset'.
+   *
+   * @param aNode - XUL element that implements
+   *                nsIDOMXULSelectControlItemElement interface
+   * @param aAttributes - attributes container
+   */
+  static void SetAccAttrsForXULSelectControlItem(nsIDOMNode *aNode,
+                                                 nsIPersistentProperties *aAttributes);
+
+  /**
+   * Set group attributes - 'level', 'setsize', 'posinset'.
+   *
+   * @param  aNode        XUL element that implements
+   *                      nsIDOMXULContainerItemElement interface
+   * @param  aAttributes  attributes container
+   */
+  static void SetAccAttrsForXULContainerItem(nsIDOMNode *aNode,
+                                             nsIPersistentProperties *aAttributes);
+
+  /**
+   * Set container-foo live region attributes for the given node.
+   *
+   * @param aAttributes    where to store the attributes
+   * @param aStartContent  node to start from
+   * @param aTopContent    node to end at
+   */
+  static void SetLiveContainerAttributes(nsIPersistentProperties *aAttributes,
+                                         nsIContent *aStartContent,
+                                         nsIContent *aTopContent);
+
+  /**
+   * Return PR_TRUE if the ARIA property should always be exposed as an object
+   * attribute.
+   */
+  static PRBool IsARIAPropForObjectAttr(nsIAtom *aAtom);
+
+  /**
+   * Fire accessible event of the given type for the given accessible.
+   */
+  static nsresult FireAccEvent(PRUint32 aEventType, nsIAccessible *aAccessible,
+                               PRBool aIsAsynch = PR_FALSE);
+
+  /**
+    * If an ancestor in this document exists with the given role, return it
+    * @param aDescendant Descendant to start search with
+    * @param aRole Role to find matching ancestor for
+    * @return The ancestor accessible with the given role, or nsnull if no match is found
+    */
+   static already_AddRefed<nsIAccessible>
+     GetAncestorWithRole(nsIAccessible *aDescendant, PRUint32 aRole);
+
+   /**
+     * For an ARIA tree item , get the accessible that represents its conceptual parent.
+     * This method will use the correct method for the given way the tree is constructed.
+     * The conceptual parent is what the user sees as the parent, not the DOM or accessible parent.
+     * @param aStartTreeItem  The tree item to get the parent for
+     * @param aStartTreeItemContent  The content node for the tree item
+     * @param The tree item's parent, or null if none
+     */
+   static void
+     GetARIATreeItemParent(nsIAccessible *aStartTreeItem,
+                           nsIContent *aStartTreeItemContent,
+                           nsIAccessible **aTreeItemParent);
+
+  /**
+   * Converts the given coordinates to coordinates relative screen.
+   *
+   * @param aX               [in] the given x coord
+   * @param aY               [in] the given y coord
+   * @param aCoordinateType  [in] specifies coordinates origin (refer to
+   *                         nsIAccessibleCoordinateType)
+   * @param aAccessNode      [in] the accessible if coordinates are given
+   *                         relative it.
+   * @param aCoords          [out] converted coordinates
+   */
+  static nsresult ConvertToScreenCoords(PRInt32 aX, PRInt32 aY,
+                                        PRUint32 aCoordinateType,
+                                        nsIAccessNode *aAccessNode,
+                                        nsIntPoint *aCoords);
+
+  /**
+   * Converts the given coordinates relative screen to another coordinate
+   * system.
+   *
+   * @param aX               [in, out] the given x coord
+   * @param aY               [in, out] the given y coord
+   * @param aCoordinateType  [in] specifies coordinates origin (refer to
+   *                         nsIAccessibleCoordinateType)
+   * @param aAccessNode      [in] the accessible if coordinates are given
+   *                         relative it
+   */
+  static nsresult ConvertScreenCoordsTo(PRInt32 *aX, PRInt32 *aY,
+                                        PRUint32 aCoordinateType,
+                                        nsIAccessNode *aAccessNode);
+
+  /**
+   * Returns coordinates relative screen for the top level window.
+   *
+   * @param aAccessNode  the accessible hosted in the window
+   */
+  static nsIntPoint GetScreenCoordsForWindow(nsIAccessNode *aAccessNode);
+
+  /**
+   * Returns coordinates relative screen for the parent of the given accessible.
+   *
+   * @param aAccessNode  the accessible
+   */
+  static nsIntPoint GetScreenCoordsForParent(nsIAccessNode *aAccessNode);
+
+  /**
+   * Get the role map entry for a given DOM node. This will use the first
+   * ARIA role if the role attribute provides a space delimited list of roles.
+   * @param aNode  The DOM node to get the role map entry for
+   * @return       A pointer to the role map entry for the ARIA role, or nsnull if none
+   */
+   static nsRoleMapEntry* GetRoleMapEntry(nsIDOMNode *aNode);
+};
+
+#endif
+
diff -r 4b060ed856e0 accessible/src/base/nsAccessNode.cpp
--- a/accessible/src/base/nsAccessNode.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/accessible/src/base/nsAccessNode.cpp	Thu Oct 16 21:24:47 2008 -0500
@@ -373,17 +373,17 @@ already_AddRefed<nsIAccessibleDocument> 
 already_AddRefed<nsIAccessibleDocument> nsAccessNode::GetDocAccessible()
 {
   return GetDocAccessibleFor(mWeakShell); // Addref'd
 }
 
 already_AddRefed<nsRootAccessible> nsAccessNode::GetRootAccessible()
 {
   nsCOMPtr<nsIDocShellTreeItem> docShellTreeItem =
-    nsAccUtils::GetDocShellTreeItemFor(mDOMNode);
+    nsCoreUtils::GetDocShellTreeItemFor(mDOMNode);
   NS_ASSERTION(docShellTreeItem, "No docshell tree item for mDOMNode");
   if (!docShellTreeItem) {
     return nsnull;
   }
   nsCOMPtr<nsIDocShellTreeItem> root;
   docShellTreeItem->GetRootTreeItem(getter_AddRefs(root));
   NS_ASSERTION(root, "No root content tree item");
   if (!root) {
@@ -464,17 +464,17 @@ nsAccessNode::ScrollTo(PRUint32 aScrollT
 
   nsIFrame *frame = GetFrame();
   NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
 
   nsCOMPtr<nsIContent> content = frame->GetContent();
   NS_ENSURE_TRUE(content, NS_ERROR_FAILURE);
 
   PRInt16 vPercent, hPercent;
-  nsAccUtils::ConvertScrollTypeToPercents(aScrollType, &vPercent, &hPercent);
+  nsCoreUtils::ConvertScrollTypeToPercents(aScrollType, &vPercent, &hPercent);
   return shell->ScrollContentIntoView(content, vPercent, hPercent);
 }
 
 NS_IMETHODIMP
 nsAccessNode::ScrollToPoint(PRUint32 aCoordinateType, PRInt32 aX, PRInt32 aY)
 {
   nsIFrame *frame = GetFrame();
   if (!frame)
@@ -482,17 +482,17 @@ nsAccessNode::ScrollToPoint(PRUint32 aCo
 
   nsIntPoint coords;
   nsresult rv = nsAccUtils::ConvertToScreenCoords(aX, aY, aCoordinateType,
                                                   this, &coords);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsIFrame *parentFrame = frame;
   while ((parentFrame = parentFrame->GetParent()))
-    nsAccUtils::ScrollFrameToPoint(parentFrame, frame, coords);
+    nsCoreUtils::ScrollFrameToPoint(parentFrame, frame, coords);
 
   return NS_OK;
 }
 
 nsresult
 nsAccessNode::MakeAccessNode(nsIDOMNode *aNode, nsIAccessNode **aAccessNode)
 {
   *aAccessNode = nsnull;
@@ -647,17 +647,17 @@ nsAccessNode::GetComputedStyleCSSValue(c
 
 void
 nsAccessNode::GetComputedStyleDeclaration(const nsAString& aPseudoElt,
                                           nsIDOMNode *aNode,
                                           nsIDOMCSSStyleDeclaration **aCssDecl)
 {
   *aCssDecl = nsnull;
 
-  nsCOMPtr<nsIDOMElement> domElement = nsAccUtils::GetDOMElementFor(aNode);
+  nsCOMPtr<nsIDOMElement> domElement = nsCoreUtils::GetDOMElementFor(aNode);
   if (!domElement)
     return;
 
   // Returns number of items in style declaration
   nsCOMPtr<nsIContent> content = do_QueryInterface(domElement);
   nsCOMPtr<nsIDocument> doc = content->GetDocument();
   if (!doc)
     return;
@@ -881,17 +881,17 @@ nsAccessNode::GetLanguage(nsAString& aLa
         content = do_QueryInterface(docElement);
       }
     }
     if (!content) {
       return NS_ERROR_FAILURE;
     }
   }
 
-  nsAccUtils::GetLanguageFor(content, nsnull, aLanguage);
+  nsCoreUtils::GetLanguageFor(content, nsnull, aLanguage);
 
   if (aLanguage.IsEmpty()) { // Nothing found, so use document's language
     nsIDocument *doc = content->GetOwnerDoc();
     if (doc) {
       doc->GetHeaderData(nsAccessibilityAtoms::headerContentLanguage, aLanguage);
     }
   }
  
diff -r 4b060ed856e0 accessible/src/base/nsAccessNode.h
--- a/accessible/src/base/nsAccessNode.h	Tue Oct 14 17:12:28 2008 -0700
+++ b/accessible/src/base/nsAccessNode.h	Thu Oct 16 21:24:47 2008 -0500
@@ -40,17 +40,18 @@
  * see http://lxr.mozilla.org/seamonkey/source/accessible/accessible-docs.html
  */
 
 #ifndef _nsAccessNode_H_
 #define _nsAccessNode_H_
 
 #include "nsCOMPtr.h"
 #include "nsAccessibilityAtoms.h"
-#include "nsAccessibilityUtils.h"
+#include "nsCoreUtils.h"
+#include "nsAccUtils.h"
 
 #include "nsIAccessibleTypes.h"
 #include "nsIAccessNode.h"
 #include "nsIContent.h"
 #include "nsPIAccessNode.h"
 #include "nsIDOMNode.h"
 #include "nsINameSpaceManager.h"
 #include "nsIStringBundle.h"
diff -r 4b060ed856e0 accessible/src/base/nsAccessibilityService.cpp
--- a/accessible/src/base/nsAccessibilityService.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/accessible/src/base/nsAccessibilityService.cpp	Thu Oct 16 21:24:47 2008 -0500
@@ -34,17 +34,18 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 // NOTE: alphabetically ordered
 #include "nsAccessibilityAtoms.h"
 #include "nsAccessibilityService.h"
-#include "nsAccessibilityUtils.h"
+#include "nsCoreUtils.h"
+#include "nsAccUtils.h"
 #include "nsARIAMap.h"
 #include "nsIContentViewer.h"
 #include "nsCURILoader.h"
 #include "nsDocAccessible.h"
 #include "nsHTMLImageAccessibleWrap.h"
 #include "nsHTMLLinkAccessible.h"
 #include "nsHTMLSelectAccessible.h"
 #include "nsHTMLTableAccessibleWrap.h"
@@ -586,17 +587,17 @@ nsAccessibilityService::CreateHyperTextA
   nsCOMPtr<nsIWeakReference> weakShell;
   nsresult rv = GetInfo(aFrame, &frame, getter_AddRefs(weakShell), getter_AddRefs(node));
   if (NS_FAILED(rv))
     return rv;
 
   nsCOMPtr<nsIContent> content(do_QueryInterface(node));
   NS_ENSURE_TRUE(content, NS_ERROR_FAILURE);
   
-  if (nsAccUtils::HasListener(content, NS_LITERAL_STRING("click"))) {
+  if (nsCoreUtils::HasListener(content, NS_LITERAL_STRING("click"))) {
     // nsLinkableAccessible inherits from nsHyperTextAccessible, but
     // it also includes code for dealing with the onclick
     *aAccessible = new nsLinkableAccessible(node, weakShell);
   }
   else {
     *aAccessible = new nsHyperTextAccessibleWrap(node, weakShell);
   }
   if (nsnull == *aAccessible)
@@ -1265,26 +1266,27 @@ nsresult nsAccessibilityService::InitAcc
     NS_ADDREF(*aAccessibleOut = aAccessibleIn);
   }
   return rv;
 }
 
 static PRBool HasRelatedContent(nsIContent *aContent)
 {
   nsAutoString id;
-  if (!aContent || !nsAccUtils::GetID(aContent, id) || id.IsEmpty()) {
+  if (!aContent || !nsCoreUtils::GetID(aContent, id) || id.IsEmpty()) {
     return PR_FALSE;
   }
 
   nsIAtom *relationAttrs[] = {nsAccessibilityAtoms::aria_labelledby,
                               nsAccessibilityAtoms::aria_describedby,
                               nsAccessibilityAtoms::aria_owns,
                               nsAccessibilityAtoms::aria_controls,
                               nsAccessibilityAtoms::aria_flowto};
-  if (nsAccUtils::FindNeighbourPointingToNode(aContent, relationAttrs, NS_ARRAY_LENGTH(relationAttrs))) {
+  if (nsCoreUtils::FindNeighbourPointingToNode(aContent, relationAttrs,
+                                               NS_ARRAY_LENGTH(relationAttrs))) {
     return PR_TRUE;
   }
 
   nsIContent *ancestorContent = aContent;
   while ((ancestorContent = ancestorContent->GetParent()) != nsnull) {
     if (ancestorContent->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_activedescendant)) {
         // ancestor has activedescendant property, this content could be active
       return PR_TRUE;
@@ -1522,17 +1524,18 @@ NS_IMETHODIMP nsAccessibilityService::Ge
         if (!tableFrame)
           continue;
         if (tableFrame->GetType() == nsAccessibilityAtoms::tableOuterFrame) {
           nsCOMPtr<nsIDOMNode> tableNode(do_QueryInterface(tableContent));
           nsCOMPtr<nsIAccessible> tableAccessible;
           GetAccessibleInShell(tableNode, aPresShell, getter_AddRefs(tableAccessible));
           if (!tableAccessible && !content->IsFocusable()) {
 #ifdef DEBUG
-            nsRoleMapEntry *tableRoleMapEntry = nsAccUtils::GetRoleMapEntry(tableNode);
+            nsRoleMapEntry *tableRoleMapEntry =
+              nsAccUtils::GetRoleMapEntry(tableNode);
             NS_ASSERTION(tableRoleMapEntry &&
                          !nsCRT::strcmp(tableRoleMapEntry->roleString, "presentation"),
                          "No accessible for parent table and it didn't have role of presentation");
 #endif
             // Table-related descendants of presentation table are also presentation
             // Don't create accessibles for them unless they need to fire focus events
             return NS_OK;
           }
@@ -1589,19 +1592,19 @@ NS_IMETHODIMP nsAccessibilityService::Ge
   }
 
   // If no accessible, see if we need to create a generic accessible because
   // of some property that makes this object interesting
   // We don't do this for <body>, <html>, <window>, <dialog> etc. which 
   // correspond to the doc accessible and will be created in any case
   if (!newAcc && content->Tag() != nsAccessibilityAtoms::body && content->GetParent() && 
       (frame->IsFocusable() ||
-       (isHTML && nsAccUtils::HasListener(content, NS_LITERAL_STRING("click"))) ||
+       (isHTML && nsCoreUtils::HasListener(content, NS_LITERAL_STRING("click"))) ||
        HasUniversalAriaProperty(content, aWeakShell) || roleMapEntry ||
-       HasRelatedContent(content) || nsAccUtils::IsXLink(content))) {
+       HasRelatedContent(content) || nsCoreUtils::IsXLink(content))) {
     // This content is focusable or has an interesting dynamic content accessibility property.
     // If it's interesting we need it in the accessibility hierarchy so that events or
     // other accessibles can point to it, or so that it can hold a state, etc.
     if (isHTML) {
       // Interesting HTML container which may have selectable text and/or embedded objects
       CreateHyperTextAccessible(frame, getter_AddRefs(newAcc));
     }
     else {  // XUL, SVG, MathML etc.
diff -r 4b060ed856e0 accessible/src/base/nsAccessibilityUtils.cpp
--- a/accessible/src/base/nsAccessibilityUtils.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,1116 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code.
- *
- * The Initial Developer of the Original Code is
- * Mozilla Foundation.
- * Portions created by the Initial Developer are Copyright (C) 2007
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Alexander Surkov <surkov.alexander@gmail.com> (original author)
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either of the GNU General Public License Version 2 or later (the "GPL"),
- * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#include "nsAccessibilityUtils.h"
-
-#include "nsIAccessibleStates.h"
-#include "nsIAccessibleTypes.h"
-#include "nsPIAccessible.h"
-#include "nsPIAccessNode.h"
-#include "nsAccessibleEventData.h"
-
-#include "nsAccessible.h"
-#include "nsARIAMap.h"
-#include "nsIDocument.h"
-#include "nsIDOMAbstractView.h"
-#include "nsIDOM3Node.h"
-#include "nsIDOMDocument.h"
-#include "nsIDOMDocumentView.h"
-#include "nsIDOMDocumentXBL.h"
-#include "nsIDOMHTMLDocument.h"
-#include "nsIDOMHTMLElement.h"
-#include "nsIDOMNodeList.h"
-#include "nsIDOMRange.h"
-#include "nsIDOMXULContainerElement.h"
-#include "nsIDOMXULSelectCntrlEl.h"
-#include "nsIDOMXULSelectCntrlItemEl.h"
-#include "nsIDOMWindowInternal.h"
-#include "nsIEventListenerManager.h"
-#include "nsIPresShell.h"
-#include "nsPresContext.h"
-#include "nsIScrollableFrame.h"
-#include "nsIEventStateManager.h"
-#include "nsISelection2.h"
-#include "nsISelectionController.h"
-#include "nsGUIEvent.h"
-
-#include "nsContentCID.h"
-#include "nsComponentManagerUtils.h"
-#include "nsIInterfaceRequestorUtils.h"
-#include "nsWhitespaceTokenizer.h"
-
-static NS_DEFINE_IID(kRangeCID, NS_RANGE_CID);
-
-void
-nsAccUtils::GetAccAttr(nsIPersistentProperties *aAttributes, nsIAtom *aAttrName,
-                       nsAString& aAttrValue)
-{
-  aAttrValue.Truncate();
-
-  nsCAutoString attrName;
-  aAttrName->ToUTF8String(attrName);
-  aAttributes->GetStringProperty(attrName, aAttrValue);
-}
-
-void
-nsAccUtils::SetAccAttr(nsIPersistentProperties *aAttributes, nsIAtom *aAttrName,
-                       const nsAString& aAttrValue)
-{
-  nsAutoString oldValue;
-  nsCAutoString attrName;
-
-  aAttrName->ToUTF8String(attrName);
-  aAttributes->SetStringProperty(attrName, aAttrValue, oldValue);
-}
-
-void
-nsAccUtils::GetAccGroupAttrs(nsIPersistentProperties *aAttributes,
-                             PRInt32 *aLevel, PRInt32 *aPosInSet,
-                             PRInt32 *aSetSize)
-{
-  *aLevel = 0;
-  *aPosInSet = 0;
-  *aSetSize = 0;
-
-  nsAutoString value;
-  PRInt32 error = NS_OK;
-
-  GetAccAttr(aAttributes, nsAccessibilityAtoms::level, value);
-  if (!value.IsEmpty()) {
-    PRInt32 level = value.ToInteger(&error);
-    if (NS_SUCCEEDED(error))
-      *aLevel = level;
-  }
-
-  GetAccAttr(aAttributes, nsAccessibilityAtoms::posinset, value);
-  if (!value.IsEmpty()) {
-    PRInt32 posInSet = value.ToInteger(&error);
-    if (NS_SUCCEEDED(error))
-      *aPosInSet = posInSet;
-  }
-
-  GetAccAttr(aAttributes, nsAccessibilityAtoms::setsize, value);
-  if (!value.IsEmpty()) {
-    PRInt32 sizeSet = value.ToInteger(&error);
-    if (NS_SUCCEEDED(error))
-      *aSetSize = sizeSet;
-  }
-}
-
-PRBool
-nsAccUtils::HasAccGroupAttrs(nsIPersistentProperties *aAttributes)
-{
-  nsAutoString value;
-
-  GetAccAttr(aAttributes, nsAccessibilityAtoms::setsize, value);
-  if (!value.IsEmpty()) {
-    GetAccAttr(aAttributes, nsAccessibilityAtoms::posinset, value);
-    return !value.IsEmpty();
-  }
-
-  return PR_FALSE;
-}
-
-void
-nsAccUtils::SetAccGroupAttrs(nsIPersistentProperties *aAttributes,
-                             PRInt32 aLevel, PRInt32 aPosInSet,
-                             PRInt32 aSetSize)
-{
-  nsAutoString value;
-
-  if (aLevel) {
-    value.AppendInt(aLevel);
-    SetAccAttr(aAttributes, nsAccessibilityAtoms::level, value);
-  }
-
-  if (aSetSize && aPosInSet) {
-    value.Truncate();
-    value.AppendInt(aPosInSet);
-    SetAccAttr(aAttributes, nsAccessibilityAtoms::posinset, value);
-
-    value.Truncate();
-    value.AppendInt(aSetSize);
-    SetAccAttr(aAttributes, nsAccessibilityAtoms::setsize, value);
-  }
-}
-
-void
-nsAccUtils::SetAccAttrsForXULSelectControlItem(nsIDOMNode *aNode,
-                                               nsIPersistentProperties *aAttributes)
-{
-  nsCOMPtr<nsIDOMXULSelectControlItemElement> item(do_QueryInterface(aNode));
-  if (!item)
-    return;
-
-  nsCOMPtr<nsIDOMXULSelectControlElement> control;
-  item->GetControl(getter_AddRefs(control));
-  if (!control)
-    return;
-
-  PRUint32 itemsCount = 0;
-  control->GetItemCount(&itemsCount);
-
-  PRInt32 indexOf = 0;
-  control->GetIndexOfItem(item, &indexOf);
-
-  PRUint32 setSize = itemsCount, posInSet = indexOf;
-  for (PRUint32 index = 0; index < itemsCount; index++) {
-    nsCOMPtr<nsIDOMXULSelectControlItemElement> currItem;
-    control->GetItemAtIndex(index, getter_AddRefs(currItem));
-    nsCOMPtr<nsIDOMNode> currNode(do_QueryInterface(currItem));
-
-    nsCOMPtr<nsIAccessible> itemAcc;
-    nsAccessNode::GetAccService()->GetAccessibleFor(currNode,
-                                                    getter_AddRefs(itemAcc));
-    if (!itemAcc ||
-        nsAccessible::State(itemAcc) & nsIAccessibleStates::STATE_INVISIBLE) {
-      setSize--;
-      if (index < static_cast<PRUint32>(indexOf))
-        posInSet--;
-    }
-  }
-
-  SetAccGroupAttrs(aAttributes, 0, posInSet + 1, setSize);
-}
-
-void
-nsAccUtils::SetAccAttrsForXULContainerItem(nsIDOMNode *aNode,
-                                           nsIPersistentProperties *aAttributes)
-{
-  nsCOMPtr<nsIDOMXULContainerItemElement> item(do_QueryInterface(aNode));
-  if (!item)
-    return;
-
-  nsCOMPtr<nsIDOMXULContainerElement> container;
-  item->GetParentContainer(getter_AddRefs(container));
-  if (!container)
-    return;
-
-  // Get item count.
-  PRUint32 itemsCount = 0;
-  container->GetItemCount(&itemsCount);
-
-  // Get item index.
-  PRInt32 indexOf = 0;
-  container->GetIndexOfItem(item, &indexOf);
-
-  // Calculate set size and position in the set.
-  PRUint32 setSize = 0, posInSet = 0;
-  for (PRInt32 index = indexOf; index >= 0; index--) {
-    nsCOMPtr<nsIDOMXULElement> item;
-    container->GetItemAtIndex(index, getter_AddRefs(item));
-
-    nsCOMPtr<nsIAccessible> itemAcc;
-    nsAccessNode::GetAccService()->GetAccessibleFor(item,
-                                                    getter_AddRefs(itemAcc));
-
-    if (itemAcc) {
-      PRUint32 itemRole = nsAccessible::Role(itemAcc);
-      if (itemRole == nsIAccessibleRole::ROLE_SEPARATOR)
-        break; // We reached the beginning of our group.
-
-      PRUint32 itemState = nsAccessible::State(itemAcc);
-      if (!(itemState & nsIAccessibleStates::STATE_INVISIBLE)) {
-        setSize++;
-        posInSet++;
-      }
-    }
-  }
-
-  for (PRInt32 index = indexOf + 1; index < itemsCount; index++) {
-    nsCOMPtr<nsIDOMXULElement> item;
-    container->GetItemAtIndex(index, getter_AddRefs(item));
-    
-    nsCOMPtr<nsIAccessible> itemAcc;
-    nsAccessNode::GetAccService()->GetAccessibleFor(item,
-                                                    getter_AddRefs(itemAcc));
-
-    if (itemAcc) {
-      PRUint32 itemRole = nsAccessible::Role(itemAcc);
-      if (itemRole == nsIAccessibleRole::ROLE_SEPARATOR)
-        break; // We reached the end of our group.
-
-      PRUint32 itemState = nsAccessible::State(itemAcc);
-      if (!(itemState & nsIAccessibleStates::STATE_INVISIBLE))
-        setSize++;
-    }
-  }
-
-  // Get level of the item.
-  PRInt32 level = -1;
-  while (container) {
-    level++;
-
-    nsCOMPtr<nsIDOMXULContainerElement> parentContainer;
-    container->GetParentContainer(getter_AddRefs(parentContainer));
-    parentContainer.swap(container);
-  }
-  
-  SetAccGroupAttrs(aAttributes, level, posInSet, setSize);
-}
-
-PRBool
-nsAccUtils::HasListener(nsIContent *aContent, const nsAString& aEventType)
-{
-  NS_ENSURE_TRUE(aContent, PR_FALSE);
-  nsCOMPtr<nsIEventListenerManager> listenerManager;
-  aContent->GetListenerManager(PR_FALSE, getter_AddRefs(listenerManager));
-
-  return listenerManager && listenerManager->HasListenersFor(aEventType);  
-}
-
-PRBool
-nsAccUtils::DispatchMouseEvent(PRUint32 aEventType,
-                               nsIPresShell *aPresShell,
-                               nsIContent *aContent)
-{
-  nsIFrame *frame = aPresShell->GetPrimaryFrameFor(aContent);
-  if (!frame)
-    return PR_FALSE;
-
-  nsIFrame* rootFrame = aPresShell->GetRootFrame();
-  if (!rootFrame)
-    return PR_FALSE;
-
-  nsCOMPtr<nsIWidget> rootWidget = rootFrame->GetWindow();
-  if (!rootWidget)
-    return PR_FALSE;
-
-  // Compute x and y coordinates.
-  nsPoint point = frame->GetOffsetToExternal(rootFrame);
-  nsSize size = frame->GetSize();
-
-  nsPresContext* presContext = aPresShell->GetPresContext();
-
-  PRInt32 x = presContext->AppUnitsToDevPixels(point.x + size.width / 2);
-  PRInt32 y = presContext->AppUnitsToDevPixels(point.y + size.height / 2);
-  
-  // Fire mouse event.
-  nsMouseEvent event(PR_TRUE, aEventType, rootWidget,
-                     nsMouseEvent::eReal, nsMouseEvent::eNormal);
-
-  event.refPoint = nsIntPoint(x, y);
-  
-  event.clickCount = 1;
-  event.button = nsMouseEvent::eLeftButton;
-  event.time = PR_IntervalNow();
-  
-  nsEventStatus status = nsEventStatus_eIgnore;
-  aPresShell->HandleEventWithTarget(&event, frame, aContent, &status);
-
-  return PR_TRUE;
-}
-
-PRUint32
-nsAccUtils::GetAccessKeyFor(nsIContent *aContent)
-{
-  if (!aContent)
-    return 0;
-
-  // Accesskeys are registered by @accesskey attribute only. At first check
-  // whether it is presented on the given element to avoid the slow
-  // nsIEventStateManager::GetRegisteredAccessKey() method.
-  if (!aContent->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::accesskey))
-    return 0;
-
-  nsCOMPtr<nsIDocument> doc = aContent->GetOwnerDoc();
-  if (!doc)
-    return 0;
-
-  nsCOMPtr<nsIPresShell> presShell = doc->GetPrimaryShell();
-  if (!presShell)
-    return 0;
-
-  nsPresContext *presContext = presShell->GetPresContext();
-  if (!presContext)
-    return 0;
-
-  nsIEventStateManager *esm = presContext->EventStateManager();
-  if (!esm)
-    return 0;
-
-  PRUint32 key = 0;
-  esm->GetRegisteredAccessKey(aContent, &key);
-  return key;
-}
-
-nsresult
-nsAccUtils::FireAccEvent(PRUint32 aEventType, nsIAccessible *aAccessible,
-                         PRBool aIsAsynch)
-{
-  NS_ENSURE_ARG(aAccessible);
-
-  nsCOMPtr<nsPIAccessible> pAccessible(do_QueryInterface(aAccessible));
-  NS_ASSERTION(pAccessible, "Accessible doesn't implement nsPIAccessible");
-
-  nsCOMPtr<nsIAccessibleEvent> event =
-    new nsAccEvent(aEventType, aAccessible, aIsAsynch);
-  NS_ENSURE_TRUE(event, NS_ERROR_OUT_OF_MEMORY);
-
-  return pAccessible->FireAccessibleEvent(event);
-}
-
-already_AddRefed<nsIDOMElement>
-nsAccUtils::GetDOMElementFor(nsIDOMNode *aNode)
-{
-  nsCOMPtr<nsINode> node(do_QueryInterface(aNode));
-  nsIDOMElement *element = nsnull;
-
-  if (node->IsNodeOfType(nsINode::eELEMENT))
-    CallQueryInterface(node, &element);
-
-  else if (node->IsNodeOfType(nsINode::eTEXT))
-    CallQueryInterface(node->GetNodeParent(), &element);
-
-  else if (node->IsNodeOfType(nsINode::eDOCUMENT)) {
-    nsCOMPtr<nsIDOMHTMLDocument> htmlDoc(do_QueryInterface(node));
-    if (htmlDoc) {
-      nsCOMPtr<nsIDOMHTMLElement> bodyElement;
-      htmlDoc->GetBody(getter_AddRefs(bodyElement));
-      if (bodyElement) {
-        CallQueryInterface(bodyElement, &element);
-        return element;
-      }
-    }
-
-    nsCOMPtr<nsIDOMDocument> domDoc(do_QueryInterface(node));
-    domDoc->GetDocumentElement(&element);
-  }
-
-  return element;
-}
-
-PRBool
-nsAccUtils::IsAncestorOf(nsIDOMNode *aPossibleAncestorNode,
-                         nsIDOMNode *aPossibleDescendantNode)
-{
-  NS_ENSURE_TRUE(aPossibleAncestorNode && aPossibleDescendantNode, PR_FALSE);
-
-  nsCOMPtr<nsIDOMNode> loopNode = aPossibleDescendantNode;
-  nsCOMPtr<nsIDOMNode> parentNode;
-  while (NS_SUCCEEDED(loopNode->GetParentNode(getter_AddRefs(parentNode))) &&
-         parentNode) {
-    if (parentNode == aPossibleAncestorNode) {
-      return PR_TRUE;
-    }
-    loopNode.swap(parentNode);
-  }
-  return PR_FALSE;
-}
-
-PRBool
-nsAccUtils::AreSiblings(nsIDOMNode *aDOMNode1,
-                       nsIDOMNode *aDOMNode2)
-{
-  NS_ENSURE_TRUE(aDOMNode1 && aDOMNode2, PR_FALSE);
-
-  nsCOMPtr<nsIDOMNode> parentNode1, parentNode2;
-  if (NS_SUCCEEDED(aDOMNode1->GetParentNode(getter_AddRefs(parentNode1))) &&
-      NS_SUCCEEDED(aDOMNode2->GetParentNode(getter_AddRefs(parentNode2))) &&
-      parentNode1 == parentNode2) {
-    return PR_TRUE;
-  }
-  return PR_FALSE;
-}
-
-already_AddRefed<nsIAccessible>
-nsAccUtils::GetAncestorWithRole(nsIAccessible *aDescendant, PRUint32 aRole)
-{
-  nsCOMPtr<nsIAccessible> parentAccessible = aDescendant, testRoleAccessible;
-  while (NS_SUCCEEDED(parentAccessible->GetParent(getter_AddRefs(testRoleAccessible))) &&
-         testRoleAccessible) {
-    PRUint32 testRole;
-    testRoleAccessible->GetFinalRole(&testRole);
-    if (testRole == aRole) {
-      nsIAccessible *returnAccessible = testRoleAccessible;
-      NS_ADDREF(returnAccessible);
-      return returnAccessible;
-    }
-    nsCOMPtr<nsIAccessibleDocument> docAccessible = do_QueryInterface(testRoleAccessible);
-    if (docAccessible) {
-      break;
-    }
-    parentAccessible.swap(testRoleAccessible);
-  }
-  return nsnull;
-}
-
-void
-nsAccUtils::GetARIATreeItemParent(nsIAccessible *aStartTreeItem, nsIContent *aStartContent,
-                                  nsIAccessible **aTreeItemParentResult)
-{
-  *aTreeItemParentResult = nsnull;
-  nsAutoString levelStr;
-  PRInt32 level = 0;
-  if (aStartContent->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_level, levelStr)) {
-    // This is a tree that uses aria-level to define levels, so find the first previous
-    // sibling accessible where level is defined to be less than the current level
-    PRInt32 success;
-    level = levelStr.ToInteger(&success);
-    if (level > 1 && NS_SUCCEEDED(success)) {
-      nsCOMPtr<nsIAccessible> currentAccessible = aStartTreeItem, prevAccessible;
-      while (PR_TRUE) {
-        currentAccessible->GetPreviousSibling(getter_AddRefs(prevAccessible));
-        currentAccessible.swap(prevAccessible);
-        nsCOMPtr<nsIAccessNode> accessNode = do_QueryInterface(currentAccessible);
-        if (!accessNode) {
-          break; // Reached top of tree, no higher level found
-        }
-        PRUint32 role;
-        currentAccessible->GetFinalRole(&role);
-        if (role != nsIAccessibleRole::ROLE_OUTLINEITEM)
-          continue;
-        nsCOMPtr<nsIDOMNode> treeItemNode;
-        accessNode->GetDOMNode(getter_AddRefs(treeItemNode));
-        nsCOMPtr<nsIContent> treeItemContent = do_QueryInterface(treeItemNode);
-        if (treeItemContent &&
-            treeItemContent->GetAttr(kNameSpaceID_None,
-                                     nsAccessibilityAtoms::aria_level, levelStr)) {
-          if (levelStr.ToInteger(&success) < level && NS_SUCCEEDED(success)) {
-            NS_ADDREF(*aTreeItemParentResult = currentAccessible);
-            return;
-          }
-        }
-      }
-    }
-  }
-
-  // Possibly a tree arranged by using role="group" to organize levels
-  // In this case the parent of the tree item will be a group and the
-  // previous sibling of that should be the tree item parent.
-  // Or, if the parent is something other than a tree we will return that.
-  nsCOMPtr<nsIAccessible> parentAccessible;
-  aStartTreeItem->GetParent(getter_AddRefs(parentAccessible));
-  if (!parentAccessible)
-    return;
-  PRUint32 role;
-  parentAccessible->GetFinalRole(&role);
-  if (role != nsIAccessibleRole::ROLE_GROUPING) {
-    NS_ADDREF(*aTreeItemParentResult = parentAccessible);
-    return; // The container for the tree items
-  }
-  nsCOMPtr<nsIAccessible> prevAccessible;
-  parentAccessible->GetPreviousSibling(getter_AddRefs(prevAccessible));
-  if (!prevAccessible)
-    return;
-  prevAccessible->GetFinalRole(&role);
-  if (role == nsIAccessibleRole::ROLE_TEXT_LEAF) {
-    // XXX Sometimes an empty text accessible is in the hierarchy here,
-    // although the text does not appear to be rendered, GetRenderedText() says that it is
-    // so we need to skip past it to find the true previous sibling
-    nsCOMPtr<nsIAccessible> tempAccessible = prevAccessible;
-    tempAccessible->GetPreviousSibling(getter_AddRefs(prevAccessible));
-    if (!prevAccessible)
-      return;
-    prevAccessible->GetFinalRole(&role);
-  }
-  if (role == nsIAccessibleRole::ROLE_OUTLINEITEM) {
-    // Previous sibling of parent group is a tree item -- this is the conceptual tree item parent
-    NS_ADDREF(*aTreeItemParentResult = prevAccessible);
-  }
-}
-
-nsresult
-nsAccUtils::ScrollSubstringTo(nsIFrame *aFrame,
-                              nsIDOMNode *aStartNode, PRInt32 aStartIndex,
-                              nsIDOMNode *aEndNode, PRInt32 aEndIndex,
-                              PRUint32 aScrollType)
-{
-  PRInt16 vPercent, hPercent;
-  ConvertScrollTypeToPercents(aScrollType, &vPercent, &hPercent);
-
-  return ScrollSubstringTo(aFrame, aStartNode, aStartIndex, aEndNode, aEndIndex,
-                           vPercent, hPercent);
-}
-
-nsresult
-nsAccUtils::ScrollSubstringTo(nsIFrame *aFrame,
-                              nsIDOMNode *aStartNode, PRInt32 aStartIndex,
-                              nsIDOMNode *aEndNode, PRInt32 aEndIndex,
-                              PRInt16 aVPercent, PRInt16 aHPercent)
-{
-  if (!aFrame || !aStartNode || !aEndNode)
-    return NS_ERROR_FAILURE;
-
-  nsPresContext *presContext = aFrame->PresContext();
-
-  nsCOMPtr<nsIDOMRange> scrollToRange = do_CreateInstance(kRangeCID);
-  NS_ENSURE_TRUE(scrollToRange, NS_ERROR_FAILURE);
-
-  nsCOMPtr<nsISelectionController> selCon;
-  aFrame->GetSelectionController(presContext, getter_AddRefs(selCon));
-  NS_ENSURE_TRUE(selCon, NS_ERROR_FAILURE);
-
-  scrollToRange->SetStart(aStartNode, aStartIndex);
-  scrollToRange->SetEnd(aEndNode, aEndIndex);
-
-  nsCOMPtr<nsISelection> selection1;
-  selCon->GetSelection(nsISelectionController::SELECTION_ACCESSIBILITY,
-                       getter_AddRefs(selection1));
-
-  nsCOMPtr<nsISelection2> selection(do_QueryInterface(selection1));
-  if (selection) {
-    selection->RemoveAllRanges();
-    selection->AddRange(scrollToRange);
-
-    selection->ScrollIntoView(nsISelectionController::SELECTION_ANCHOR_REGION,
-                              PR_TRUE, aVPercent, aHPercent);
-
-    selection->CollapseToStart();
-  }
-
-  return NS_OK;
-}
-
-void
-nsAccUtils::ScrollFrameToPoint(nsIFrame *aScrollableFrame,
-                               nsIFrame *aFrame,
-                               const nsIntPoint& aPoint)
-{
-  nsIScrollableFrame *scrollableFrame = nsnull;
-  CallQueryInterface(aScrollableFrame, &scrollableFrame);
-  if (!scrollableFrame)
-    return;
-
-  nsPresContext *presContext = aFrame->PresContext();
-
-  nsIntRect frameRect = aFrame->GetScreenRectExternal();
-  PRInt32 devDeltaX = aPoint.x - frameRect.x;
-  PRInt32 devDeltaY = aPoint.y - frameRect.y;
-
-  nsPoint deltaPoint;
-  deltaPoint.x = presContext->DevPixelsToAppUnits(devDeltaX);
-  deltaPoint.y = presContext->DevPixelsToAppUnits(devDeltaY);
-
-  nsPoint scrollPoint = scrollableFrame->GetScrollPosition();
-  scrollPoint -= deltaPoint;
-
-  scrollableFrame->ScrollTo(scrollPoint);
-}
-
-void
-nsAccUtils::ConvertScrollTypeToPercents(PRUint32 aScrollType,
-                                        PRInt16 *aVPercent,
-                                        PRInt16 *aHPercent)
-{
-  switch (aScrollType)
-  {
-    case nsIAccessibleScrollType::SCROLL_TYPE_TOP_LEFT:
-      *aVPercent = NS_PRESSHELL_SCROLL_TOP;
-      *aHPercent = NS_PRESSHELL_SCROLL_LEFT;
-      break;
-    case nsIAccessibleScrollType::SCROLL_TYPE_BOTTOM_RIGHT:
-      *aVPercent = NS_PRESSHELL_SCROLL_BOTTOM;
-      *aHPercent = NS_PRESSHELL_SCROLL_RIGHT;
-      break;
-    case nsIAccessibleScrollType::SCROLL_TYPE_TOP_EDGE:
-      *aVPercent = NS_PRESSHELL_SCROLL_TOP;
-      *aHPercent = NS_PRESSHELL_SCROLL_ANYWHERE;
-      break;
-    case nsIAccessibleScrollType::SCROLL_TYPE_BOTTOM_EDGE:
-      *aVPercent = NS_PRESSHELL_SCROLL_BOTTOM;
-      *aHPercent = NS_PRESSHELL_SCROLL_ANYWHERE;
-      break;
-    case nsIAccessibleScrollType::SCROLL_TYPE_LEFT_EDGE:
-      *aVPercent = NS_PRESSHELL_SCROLL_ANYWHERE;
-      *aHPercent = NS_PRESSHELL_SCROLL_LEFT;
-      break;
-    case nsIAccessibleScrollType::SCROLL_TYPE_RIGHT_EDGE:
-      *aVPercent = NS_PRESSHELL_SCROLL_ANYWHERE;
-      *aHPercent = NS_PRESSHELL_SCROLL_RIGHT;
-      break;
-    default:
-      *aVPercent = NS_PRESSHELL_SCROLL_ANYWHERE;
-      *aHPercent = NS_PRESSHELL_SCROLL_ANYWHERE;
-  }
-}
-
-nsresult
-nsAccUtils::ConvertToScreenCoords(PRInt32 aX, PRInt32 aY,
-                                  PRUint32 aCoordinateType,
-                                  nsIAccessNode *aAccessNode,
-                                  nsIntPoint *aCoords)
-{
-  NS_ENSURE_ARG_POINTER(aCoords);
-
-  aCoords->MoveTo(aX, aY);
-
-  switch (aCoordinateType) {
-    case nsIAccessibleCoordinateType::COORDTYPE_SCREEN_RELATIVE:
-      break;
-
-    case nsIAccessibleCoordinateType::COORDTYPE_WINDOW_RELATIVE:
-    {
-      NS_ENSURE_ARG(aAccessNode);
-      *aCoords += GetScreenCoordsForWindow(aAccessNode);
-      break;
-    }
-
-    case nsIAccessibleCoordinateType::COORDTYPE_PARENT_RELATIVE:
-    {
-      NS_ENSURE_ARG(aAccessNode);
-      *aCoords += GetScreenCoordsForParent(aAccessNode);
-      break;
-    }
-
-    default:
-      return NS_ERROR_INVALID_ARG;
-  }
-
-  return NS_OK;
-}
-
-nsresult
-nsAccUtils::ConvertScreenCoordsTo(PRInt32 *aX, PRInt32 *aY,
-                                  PRUint32 aCoordinateType,
-                                  nsIAccessNode *aAccessNode)
-{
-  switch (aCoordinateType) {
-    case nsIAccessibleCoordinateType::COORDTYPE_SCREEN_RELATIVE:
-      break;
-
-    case nsIAccessibleCoordinateType::COORDTYPE_WINDOW_RELATIVE:
-    {
-      NS_ENSURE_ARG(aAccessNode);
-      nsIntPoint coords = GetScreenCoordsForWindow(aAccessNode);
-      *aX -= coords.x;
-      *aY -= coords.y;
-      break;
-    }
-
-    case nsIAccessibleCoordinateType::COORDTYPE_PARENT_RELATIVE:
-    {
-      NS_ENSURE_ARG(aAccessNode);
-      nsIntPoint coords = GetScreenCoordsForParent(aAccessNode);
-      *aX -= coords.x;
-      *aY -= coords.y;
-      break;
-    }
-
-    default:
-      return NS_ERROR_INVALID_ARG;
-  }
-
-  return NS_OK;
-}
-
-nsIntPoint
-nsAccUtils::GetScreenCoordsForWindow(nsIDOMNode *aNode)
-{
-  nsIntPoint coords(0, 0);
-  nsCOMPtr<nsIDocShellTreeItem> treeItem(GetDocShellTreeItemFor(aNode));
-  if (!treeItem)
-    return coords;
-
-  nsCOMPtr<nsIDocShellTreeItem> rootTreeItem;
-  treeItem->GetRootTreeItem(getter_AddRefs(rootTreeItem));
-  nsCOMPtr<nsIDOMDocument> domDoc = do_GetInterface(rootTreeItem);
-  nsCOMPtr<nsIDOMDocumentView> docView(do_QueryInterface(domDoc));
-  if (!docView)
-    return coords;
-
-  nsCOMPtr<nsIDOMAbstractView> abstractView;
-  docView->GetDefaultView(getter_AddRefs(abstractView));
-  nsCOMPtr<nsIDOMWindowInternal> windowInter(do_QueryInterface(abstractView));
-  if (!windowInter)
-    return coords;
-
-  windowInter->GetScreenX(&coords.x);
-  windowInter->GetScreenY(&coords.y);
-  return coords;
-}
-
-nsIntPoint
-nsAccUtils::GetScreenCoordsForWindow(nsIAccessNode *aAccessNode)
-{
-  nsCOMPtr<nsIDOMNode> DOMNode;
-  aAccessNode->GetDOMNode(getter_AddRefs(DOMNode));
-  if (DOMNode)
-    return GetScreenCoordsForWindow(DOMNode);
-
-  return nsIntPoint(0, 0);
-}
-
-nsIntPoint
-nsAccUtils::GetScreenCoordsForParent(nsIAccessNode *aAccessNode)
-{
-  nsCOMPtr<nsPIAccessNode> parent;
-  nsCOMPtr<nsIAccessible> accessible(do_QueryInterface(aAccessNode));
-  if (accessible) {
-    nsCOMPtr<nsIAccessible> parentAccessible;
-    accessible->GetParent(getter_AddRefs(parentAccessible));
-    parent = do_QueryInterface(parentAccessible);
-  } else {
-    nsCOMPtr<nsIAccessNode> parentAccessNode;
-    aAccessNode->GetParentNode(getter_AddRefs(parentAccessNode));
-    parent = do_QueryInterface(parentAccessNode);
-  }
-
-  if (!parent)
-    return nsIntPoint(0, 0);
-
-  nsIFrame *parentFrame = parent->GetFrame();
-  if (!parentFrame)
-    return nsIntPoint(0, 0);
-
-  nsIntRect parentRect = parentFrame->GetScreenRectExternal();
-  return nsIntPoint(parentRect.x, parentRect.y);
-}
-
-already_AddRefed<nsIDocShellTreeItem>
-nsAccUtils::GetDocShellTreeItemFor(nsIDOMNode *aNode)
-{
-  if (!aNode)
-    return nsnull;
-
-  nsCOMPtr<nsIDOMDocument> domDoc;
-  aNode->GetOwnerDocument(getter_AddRefs(domDoc));
-  nsCOMPtr<nsIDocument> doc(do_QueryInterface(domDoc));
-  if (!doc)
-    doc = do_QueryInterface(aNode);
-
-  NS_ASSERTION(doc, "No document for node passed in");
-  NS_ENSURE_TRUE(doc, nsnull);
-
-  nsCOMPtr<nsISupports> container = doc->GetContainer();
-  nsIDocShellTreeItem *docShellTreeItem = nsnull;
-  if (container)
-    CallQueryInterface(container, &docShellTreeItem);
-
-  return docShellTreeItem;
-}
-
-nsIFrame*
-nsAccUtils::GetFrameFor(nsIDOMElement *aElm)
-{
-  nsCOMPtr<nsIPresShell> shell = nsAccessNode::GetPresShellFor(aElm);
-  if (!shell)
-    return nsnull;
-  
-  nsCOMPtr<nsIContent> content(do_QueryInterface(aElm));
-  if (!content)
-    return nsnull;
-  
-  return shell->GetPrimaryFrameFor(content);
-}
-
-PRBool
-nsAccUtils::GetID(nsIContent *aContent, nsAString& aID)
-{
-  nsIAtom *idAttribute = aContent->GetIDAttributeName();
-  return idAttribute ? aContent->GetAttr(kNameSpaceID_None, idAttribute, aID) : PR_FALSE;
-}
-
-PRBool
-nsAccUtils::IsXLink(nsIContent *aContent)
-{
-  if (!aContent)
-    return PR_FALSE;
-
-  return aContent->AttrValueIs(kNameSpaceID_XLink, nsAccessibilityAtoms::type,
-                               nsAccessibilityAtoms::simple, eCaseMatters) &&
-         aContent->HasAttr(kNameSpaceID_XLink, nsAccessibilityAtoms::href);
-}
-
-nsIContent*
-nsAccUtils::FindNeighbourPointingToNode(nsIContent *aForNode, 
-                                        nsIAtom *aRelationAttr,
-                                        nsIAtom *aTagName,
-                                        PRUint32 aAncestorLevelsToSearch)
-{
-  return FindNeighbourPointingToNode(aForNode, &aRelationAttr, 1, aTagName, aAncestorLevelsToSearch);
-}
-
-nsIContent*
-nsAccUtils::FindNeighbourPointingToNode(nsIContent *aForNode, 
-                                        nsIAtom **aRelationAttrs,
-                                        PRUint32 aAttrNum,
-                                        nsIAtom *aTagName,
-                                        PRUint32 aAncestorLevelsToSearch)
-{
-  nsAutoString controlID;
-  if (!nsAccUtils::GetID(aForNode, controlID)) {
-    if (!aForNode->IsInAnonymousSubtree())
-      return nsnull;
-
-    aForNode->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::anonid, controlID);
-    if (controlID.IsEmpty())
-      return nsnull;
-  }
-
-  // Look for label in subtrees of nearby ancestors
-  nsCOMPtr<nsIContent> binding(aForNode->GetBindingParent());
-  PRUint32 count = 0;
-  nsIContent *labelContent = nsnull;
-  nsIContent *prevSearched = nsnull;
-
-  while (!labelContent && ++count <= aAncestorLevelsToSearch &&
-         (aForNode = aForNode->GetParent()) != nsnull) {
-
-    if (aForNode == binding) {
-      // When we reach the binding parent, make sure to check
-      // all of its anonymous child subtrees
-      nsCOMPtr<nsIDocument> doc = aForNode->GetCurrentDoc();
-      nsCOMPtr<nsIDOMDocumentXBL> xblDoc(do_QueryInterface(doc));
-      if (!xblDoc)
-        return nsnull;
-
-      nsCOMPtr<nsIDOMNodeList> nodes;
-      nsCOMPtr<nsIDOMElement> forElm(do_QueryInterface(aForNode));
-      xblDoc->GetAnonymousNodes(forElm, getter_AddRefs(nodes));
-      if (!nodes)
-        return nsnull;
-
-      PRUint32 length;
-      nsresult rv = nodes->GetLength(&length);
-      if (NS_FAILED(rv))
-        return nsnull;
-
-      for (PRUint32 index = 0; index < length && !labelContent; index++) {
-        nsCOMPtr<nsIDOMNode> node;
-        rv = nodes->Item(index, getter_AddRefs(node));
-        if (NS_FAILED(rv))
-          return nsnull;
-
-        nsCOMPtr<nsIContent> content = do_QueryInterface(node);
-        if (!content)
-          return nsnull;
-
-        if (content != prevSearched) {
-          labelContent = FindDescendantPointingToID(&controlID, content,
-                                                    aRelationAttrs, aAttrNum,
-                                                    nsnull, aTagName);
-        }
-      }
-      break;
-    }
-
-    labelContent = FindDescendantPointingToID(&controlID, aForNode,
-                                              aRelationAttrs, aAttrNum,
-                                              prevSearched, aTagName);
-    prevSearched = aForNode;
-  }
-
-  return labelContent;
-}
-
-// Pass in aAriaProperty = null and aRelationAttr == nsnull if any <label> will do
-nsIContent*
-nsAccUtils::FindDescendantPointingToID(const nsString *aId,
-                                       nsIContent *aLookContent,
-                                       nsIAtom **aRelationAttrs,
-                                       PRUint32 aAttrNum,
-                                       nsIContent *aExcludeContent,
-                                       nsIAtom *aTagType)
-{
-  // Surround id with spaces for search
-  nsCAutoString idWithSpaces(' ');
-  LossyAppendUTF16toASCII(*aId, idWithSpaces);
-  idWithSpaces += ' ';
-  return FindDescendantPointingToIDImpl(idWithSpaces, aLookContent,
-                                        aRelationAttrs, aAttrNum,
-                                        aExcludeContent, aTagType);
-}
-
-nsIContent*
-nsAccUtils::FindDescendantPointingToID(const nsString *aId,
-                                       nsIContent *aLookContent,
-                                       nsIAtom *aRelationAttr,
-                                       nsIContent *aExcludeContent,
-                                       nsIAtom *aTagType)
-{
-  return FindDescendantPointingToID(aId, aLookContent, &aRelationAttr, 1, aExcludeContent, aTagType);
-}
-
-nsIContent*
-nsAccUtils::FindDescendantPointingToIDImpl(nsCString& aIdWithSpaces,
-                                           nsIContent *aLookContent,
-                                           nsIAtom **aRelationAttrs,
-                                           PRUint32 aAttrNum,
-                                           nsIContent *aExcludeContent,
-                                           nsIAtom *aTagType)
-{
-  NS_ENSURE_TRUE(aLookContent, nsnull);
-  NS_ENSURE_TRUE(aRelationAttrs && *aRelationAttrs, nsnull);
-
-  if (!aTagType || aLookContent->Tag() == aTagType) {
-    // Tag matches
-    // Check for ID in the attributes aRelationAttrs, which can be a list
-    for (PRUint32 i = 0; i < aAttrNum; i++) {
-      nsAutoString idList;
-      if (aLookContent->GetAttr(kNameSpaceID_None, aRelationAttrs[i], idList)) {
-        idList.Insert(' ', 0);  // Surround idlist with spaces for search
-        idList.Append(' ');
-        // idList is now a set of id's with spaces around each,
-        // and id also has spaces around it.
-        // If id is a substring of idList then we have a match
-        if (idList.Find(aIdWithSpaces) != -1) {
-          return aLookContent;
-        }
-      }
-    }
-    if (aTagType) {
-      // Don't bother to search descendants of an element with matching tag.
-      // That would be like looking for a nested <label> or <description>
-      return nsnull;
-    }
-  }
-
-  // Recursively search descendants for match
-  PRUint32 count  = 0;
-  nsIContent *child;
-  nsIContent *labelContent = nsnull;
-
-  while ((child = aLookContent->GetChildAt(count++)) != nsnull) {
-    if (child != aExcludeContent) {
-      labelContent = FindDescendantPointingToIDImpl(aIdWithSpaces, child,
-                                                    aRelationAttrs, aAttrNum,
-                                                    aExcludeContent, aTagType);
-      if (labelContent) {
-        return labelContent;
-      }
-    }
-  }
-  return nsnull;
-}
-
-void
-nsAccUtils::GetLanguageFor(nsIContent *aContent, nsIContent *aRootContent,
-                           nsAString& aLanguage)
-{
-  aLanguage.Truncate();
-
-  nsIContent *walkUp = aContent;
-  while (walkUp && walkUp != aRootContent &&
-         !walkUp->GetAttr(kNameSpaceID_None,
-                          nsAccessibilityAtoms::lang, aLanguage))
-    walkUp = walkUp->GetParent();
-}
-
-nsRoleMapEntry*
-nsAccUtils::GetRoleMapEntry(nsIDOMNode *aNode)
-{
-  nsIContent *content = nsAccessible::GetRoleContent(aNode);
-  nsAutoString roleString;
-  if (!content || !content->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::role, roleString)) {
-    return nsnull;
-  }
-
-  nsWhitespaceTokenizer tokenizer(roleString);
-  while (tokenizer.hasMoreTokens()) {
-    // Do a binary search through table for the next role in role list
-    const char *role = NS_LossyConvertUTF16toASCII(tokenizer.nextToken()).get();
-    PRInt32 low = 0;
-    PRInt32 high = nsARIAMap::gWAIRoleMapLength;
-    while (low <= high) {
-      PRInt32 index = low + ((high - low) / 2);
-      PRInt32 compare = PL_strcmp(role, nsARIAMap::gWAIRoleMap[index].roleString);
-      if (compare == 0) {
-        // The  role attribute maps to an entry in the role table
-        return &nsARIAMap::gWAIRoleMap[index];
-      }
-      if (compare < 0) {
-        high = index - 1;
-      }
-      else {
-        low = index + 1;
-      }
-    }
-  }
-
-  // Always use some entry if there is a role string
-  // To ensure an accessible object is created
-  return &nsARIAMap::gLandmarkRoleMap;
-}
-
-PRBool
-nsAccUtils::IsARIAPropForObjectAttr(nsIAtom *aAtom)
-{
-  return aAtom != nsAccessibilityAtoms::aria_activedescendant &&
-         aAtom != nsAccessibilityAtoms::aria_checked &&
-         aAtom != nsAccessibilityAtoms::aria_controls &&
-         aAtom != nsAccessibilityAtoms::aria_describedby &&
-         aAtom != nsAccessibilityAtoms::aria_disabled &&
-         aAtom != nsAccessibilityAtoms::aria_expanded &&
-         aAtom != nsAccessibilityAtoms::aria_flowto &&
-         aAtom != nsAccessibilityAtoms::aria_invalid &&
-         aAtom != nsAccessibilityAtoms::aria_haspopup &&
-         aAtom != nsAccessibilityAtoms::aria_labelledby &&
-         aAtom != nsAccessibilityAtoms::aria_multiline &&
-         aAtom != nsAccessibilityAtoms::aria_multiselectable &&
-         aAtom != nsAccessibilityAtoms::aria_owns &&
-         aAtom != nsAccessibilityAtoms::aria_pressed &&
-         aAtom != nsAccessibilityAtoms::aria_readonly &&
-         aAtom != nsAccessibilityAtoms::aria_relevant &&
-         aAtom != nsAccessibilityAtoms::aria_required &&
-         aAtom != nsAccessibilityAtoms::aria_selected &&
-         aAtom != nsAccessibilityAtoms::aria_valuemax &&
-         aAtom != nsAccessibilityAtoms::aria_valuemin &&
-         aAtom != nsAccessibilityAtoms::aria_valuenow &&
-         aAtom != nsAccessibilityAtoms::aria_valuetext;
-}
-
-void nsAccUtils::GetLiveContainerAttributes(nsIPersistentProperties *aAttributes,
-                                                nsIContent *aStartContent, nsIContent *aTopContent)
-{
-  nsAutoString atomic, live, relevant, channel, busy;
-  nsIContent *ancestor = aStartContent;
-  while (ancestor) {
-    if (relevant.IsEmpty() &&
-        ancestor->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_relevant, relevant))
-      SetAccAttr(aAttributes, nsAccessibilityAtoms::containerRelevant, relevant);
-    if (live.IsEmpty() &&
-        ancestor->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_live, live))
-      SetAccAttr(aAttributes, nsAccessibilityAtoms::containerLive, live);
-    if (channel.IsEmpty() &&
-        ancestor->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_channel, channel))
-      SetAccAttr(aAttributes, nsAccessibilityAtoms::containerChannel, channel);
-    if (atomic.IsEmpty() &&
-        ancestor->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_atomic, atomic))
-      SetAccAttr(aAttributes, nsAccessibilityAtoms::containerAtomic, atomic);
-    if (busy.IsEmpty() &&
-        ancestor->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_busy, busy))
-      SetAccAttr(aAttributes, nsAccessibilityAtoms::containerBusy, busy);
-    if (ancestor == aTopContent)
-      break;
-    ancestor = ancestor->GetParent();
-    if (!ancestor) {
-      ancestor = aTopContent; // Use <body>/<frameset>
-    }
-  }
-}
diff -r 4b060ed856e0 accessible/src/base/nsAccessibilityUtils.h
--- a/accessible/src/base/nsAccessibilityUtils.h	Tue Oct 14 17:12:28 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,434 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code.
- *
- * The Initial Developer of the Original Code is
- * Mozilla Foundation.
- * Portions created by the Initial Developer are Copyright (C) 2007
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Alexander Surkov <surkov.alexander@gmail.com> (original author)
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either of the GNU General Public License Version 2 or later (the "GPL"),
- * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#ifndef nsAccessibilityUtils_h_
-#define nsAccessibilityUtils_h_
-
-#include "nsAccessibilityAtoms.h"
-#include "nsIAccessible.h"
-#include "nsIAccessNode.h"
-#include "nsARIAMap.h"
-
-#include "nsIDOMNode.h"
-#include "nsIPersistentProperties2.h"
-#include "nsIContent.h"
-#include "nsIFrame.h"
-#include "nsIDocShellTreeItem.h"
-#include "nsPoint.h"
-#include "nsIAccessibleDocument.h"
-
-class nsAccUtils
-{
-public:
-  /**
-   * Returns value of attribute from the given attributes container.
-   *
-   * @param aAttributes - attributes container
-   * @param aAttrName - the name of requested attribute
-   * @param aAttrValue - value of attribute
-   */
-  static void GetAccAttr(nsIPersistentProperties *aAttributes,
-                         nsIAtom *aAttrName,
-                         nsAString& aAttrValue);
-
-  /**
-   * Set value of attribute for the given attributes container.
-   *
-   * @param aAttributes - attributes container
-   * @param aAttrName - the name of requested attribute
-   * @param aAttrValue - new value of attribute
-   */
-  static void SetAccAttr(nsIPersistentProperties *aAttributes,
-                         nsIAtom *aAttrName,
-                         const nsAString& aAttrValue);
-
-  /**
-   * Return values of group attributes ('level', 'setsize', 'posinset')
-   */
-  static void GetAccGroupAttrs(nsIPersistentProperties *aAttributes,
-                               PRInt32 *aLevel,
-                               PRInt32 *aPosInSet,
-                               PRInt32 *aSetSize);
-
-  /**
-   * Returns true if there are level, posinset and sizeset attributes.
-   */
-  static PRBool HasAccGroupAttrs(nsIPersistentProperties *aAttributes);
-
-  /**
-   * Set group attributes ('level', 'setsize', 'posinset').
-   */
-  static void SetAccGroupAttrs(nsIPersistentProperties *aAttributes,
-                               PRInt32 aLevel,
-                               PRInt32 aPosInSet,
-                               PRInt32 aSetSize);
-
-  /**
-   * Set group attributes - 'level', 'setsize', 'posinset'.
-   *
-   * @param aNode - XUL element that implements
-   *                nsIDOMXULSelectControlItemElement interface
-   * @param aAttributes - attributes container
-   */
-  static void SetAccAttrsForXULSelectControlItem(nsIDOMNode *aNode,
-                                                 nsIPersistentProperties *aAttributes);
-
-  /**
-   * Set group attributes - 'level', 'setsize', 'posinset'.
-   *
-   * @param  aNode        XUL element that implements
-   *                      nsIDOMXULContainerItemElement interface
-   * @param  aAttributes  attributes container
-   */
-  static void SetAccAttrsForXULContainerItem(nsIDOMNode *aNode,
-                                             nsIPersistentProperties *aAttributes);
-
-  /**
-   * Return true if the given node has registered event listener of the given
-   * type.
-   */
-  static PRBool HasListener(nsIContent *aContent, const nsAString& aEventType);
-
-  /**
-   * Send mouse events to the given element.
-   *
-   * @param aEventType  an event type (see nsGUIEvent.h for constants)
-   * @param aPresShell  the presshell for the given element
-   * @param aContent    the element element
-   */
-  static PRBool DispatchMouseEvent(PRUint32 aEventType,
-                                   nsIPresShell *aPresShell,
-                                   nsIContent *aContent);
-
-  /**
-   * Return an accesskey registered on the given element by
-   * nsIEventStateManager or 0 if there is no registered accesskey.
-   *
-   * @param aContent - the given element.
-   */
-  static PRUint32 GetAccessKeyFor(nsIContent *aContent);
-
-  /**
-   * Fire accessible event of the given type for the given accessible.
-   */
-  static nsresult FireAccEvent(PRUint32 aEventType, nsIAccessible *aAccessible,
-                               PRBool aIsAsynch = PR_FALSE);
-
-  /**
-   * Return DOM element related with the given node, i.e.
-   * a) itself if it is DOM element
-   * b) parent element if it is text node
-   * c) body element if it is HTML document node
-   * d) document element if it is document node.
-   *
-   * @param aNode  [in] the given DOM node
-   */
-  static already_AddRefed<nsIDOMElement> GetDOMElementFor(nsIDOMNode *aNode);
-
-  /**
-   * Is the first passed in node an ancestor of the second?
-   * Note: A node is not considered to be the ancestor of itself.
-   * @param aPossibleAncestorNode -- node to test for ancestor-ness of aPossibleDescendantNode
-   * @param aPossibleDescendantNode -- node to test for descendant-ness of aPossibleAncestorNode
-   * @return PR_TRUE if aPossibleAncestorNode is an ancestor of aPossibleDescendantNode
-   */
-   static PRBool IsAncestorOf(nsIDOMNode *aPossibleAncestorNode,
-                              nsIDOMNode *aPossibleDescendantNode);
-
-  /**
-   * Are the first node and the second siblings?
-   * @return PR_TRUE if aDOMNode1 and aDOMNode2 have same parent
-   */
-   static PRBool AreSiblings(nsIDOMNode *aDOMNode1,
-                             nsIDOMNode *aDOMNode2);
-
-  /**
-    * If an ancestor in this document exists with the given role, return it
-    * @param aDescendant Descendant to start search with
-    * @param aRole Role to find matching ancestor for
-    * @return The ancestor accessible with the given role, or nsnull if no match is found
-    */
-   static already_AddRefed<nsIAccessible>
-     GetAncestorWithRole(nsIAccessible *aDescendant, PRUint32 aRole);
-
-   /**
-     * For an ARIA tree item , get the accessible that represents its conceptual parent.
-     * This method will use the correct method for the given way the tree is constructed.
-     * The conceptual parent is what the user sees as the parent, not the DOM or accessible parent.
-     * @param aStartTreeItem  The tree item to get the parent for
-     * @param aStartTreeItemContent  The content node for the tree item
-     * @param The tree item's parent, or null if none
-     */
-   static void
-     GetARIATreeItemParent(nsIAccessible *aStartTreeItem,
-                           nsIContent *aStartTreeItemContent,
-                           nsIAccessible **aTreeItemParent);
-
-  /**
-   * Helper method to scroll range into view, used for implementation of
-   * nsIAccessibleText::scrollSubstringTo().
-   *
-   * @param aFrame        the frame for accessible the range belongs to.
-   * @param aStartNode    start node of a range
-   * @param aStartOffset  an offset inside the start node
-   * @param aEndNode      end node of a range
-   * @param aEndOffset    an offset inside the end node
-   * @param aScrollType   the place a range should be scrolled to
-   */
-  static nsresult ScrollSubstringTo(nsIFrame *aFrame,
-                                    nsIDOMNode *aStartNode, PRInt32 aStartIndex,
-                                    nsIDOMNode *aEndNode, PRInt32 aEndIndex,
-                                    PRUint32 aScrollType);
-
-  /** Helper method to scroll range into view, used for implementation of
-   * nsIAccessibleText::scrollSubstringTo[Point]().
-   *
-   * @param aFrame        the frame for accessible the range belongs to.
-   * @param aStartNode    start node of a range
-   * @param aStartOffset  an offset inside the start node
-   * @param aEndNode      end node of a range
-   * @param aEndOffset    an offset inside the end node
-   * @param aVPercent     how to align vertically, specified in percents
-   * @param aHPercent     how to align horizontally, specified in percents
-   */
-  static nsresult ScrollSubstringTo(nsIFrame *aFrame,
-                                    nsIDOMNode *aStartNode, PRInt32 aStartIndex,
-                                    nsIDOMNode *aEndNode, PRInt32 aEndIndex,
-                                    PRInt16 aVPercent, PRInt16 aHPercent);
-
-  /**
-   * Scrolls the given frame to the point, used for implememntation of
-   * nsIAccessNode::scrollToPoint and nsIAccessibleText::scrollSubstringToPoint.
-   *
-   * @param aScrollableFrame  the scrollable frame
-   * @param aFrame            the frame to scroll
-   * @param aPoint            the point scroll to
-   */
-  static void ScrollFrameToPoint(nsIFrame *aScrollableFrame,
-                                 nsIFrame *aFrame, const nsIntPoint& aPoint);
-
-  /**
-   * Converts scroll type constant defined in nsIAccessibleScrollType to
-   * vertical and horizontal percents.
-   */
-  static void ConvertScrollTypeToPercents(PRUint32 aScrollType,
-                                          PRInt16 *aVPercent,
-                                          PRInt16 *aHPercent);
-
-  /**
-   * Converts the given coordinates to coordinates relative screen.
-   *
-   * @param aX               [in] the given x coord
-   * @param aY               [in] the given y coord
-   * @param aCoordinateType  [in] specifies coordinates origin (refer to
-   *                         nsIAccessibleCoordinateType)
-   * @param aAccessNode      [in] the accessible if coordinates are given
-   *                         relative it.
-   * @param aCoords          [out] converted coordinates
-   */
-  static nsresult ConvertToScreenCoords(PRInt32 aX, PRInt32 aY,
-                                        PRUint32 aCoordinateType,
-                                        nsIAccessNode *aAccessNode,
-                                        nsIntPoint *aCoords);
-
-  /**
-   * Converts the given coordinates relative screen to another coordinate
-   * system.
-   *
-   * @param aX               [in, out] the given x coord
-   * @param aY               [in, out] the given y coord
-   * @param aCoordinateType  [in] specifies coordinates origin (refer to
-   *                         nsIAccessibleCoordinateType)
-   * @param aAccessNode      [in] the accessible if coordinates are given
-   *                         relative it
-   */
-  static nsresult ConvertScreenCoordsTo(PRInt32 *aX, PRInt32 *aY,
-                                        PRUint32 aCoordinateType,
-                                        nsIAccessNode *aAccessNode);
-
-  /**
-   * Returns coordinates relative screen for the top level window.
-   *
-   * @param aNode  the DOM node hosted in the window.
-   */
-  static nsIntPoint GetScreenCoordsForWindow(nsIDOMNode *aNode);
-
-  /**
-   * Returns coordinates relative screen for the top level window.
-   *
-   * @param aAccessNode  the accessible hosted in the window
-   */
-  static nsIntPoint GetScreenCoordsForWindow(nsIAccessNode *aAccessNode);
-
-  /**
-   * Returns coordinates relative screen for the parent of the given accessible.
-   *
-   * @param aAccessNode  the accessible
-   */
-  static nsIntPoint GetScreenCoordsForParent(nsIAccessNode *aAccessNode);
-
-  /**
-   * Return document shell tree item for the given DOM node.
-   */
-  static already_AddRefed<nsIDocShellTreeItem>
-    GetDocShellTreeItemFor(nsIDOMNode *aNode);
-
-  /**
-   * Retrun frame for the given DOM element.
-   */
-  static nsIFrame* GetFrameFor(nsIDOMElement *aElm);
-
-  /**
-   * Get the ID for an element, in some types of XML this may not be the ID attribute
-   * @param aContent  Node to get the ID for
-   * @param aID       Where to put ID string
-   * @return          PR_TRUE if there is an ID set for this node
-   */
-  static PRBool GetID(nsIContent *aContent, nsAString& aID);
-
-  /**
-   * Check if the given element is XLink.
-   *
-   * @param aContent  the given element
-   * @return          PR_TRUE if the given element is XLink
-   */
-  static PRBool IsXLink(nsIContent *aContent);
-
-  /**
-   * Returns language for the given node.
-   *
-   * @param aContent     [in] the given node
-   * @param aRootContent [in] container of the given node
-   * @param aLanguage    [out] language
-   */
-  static void GetLanguageFor(nsIContent *aContent, nsIContent *aRootContent,
-                             nsAString& aLanguage);
-
-  /**
-   * Get the role map entry for a given DOM node. This will use the first
-   * ARIA role if the role attribute provides a space delimited list of roles.
-   * @param aNode  The DOM node to get the role map entry for
-   * @return       A pointer to the role map entry for the ARIA role, or nsnull if none
-   */
-   static nsRoleMapEntry* GetRoleMapEntry(nsIDOMNode *aNode);
-
-  /**
-   * Search element in neighborhood of the given element by tag name and
-   * attribute value that equals to ID attribute of the given element.
-   * ID attribute can be either 'id' attribute or 'anonid' if the element is
-   * anonymous.
-   * The first matched content will be returned.
-   *
-   * @param aForNode - the given element the search is performed for
-   * @param aRelationAttrs - an array of attributes, element is attribute name of searched element, ignored if aAriaProperty passed in
-   * @param aAttrNum - how many attributes in aRelationAttrs
-   * @param aTagName - tag name of searched element, or nsnull for any -- ignored if aAriaProperty passed in
-   * @param aAncestorLevelsToSearch - points how is the neighborhood of the
-   *                                  given element big.
-   */
-  static nsIContent *FindNeighbourPointingToNode(nsIContent *aForNode,
-                                                 nsIAtom **aRelationAttrs, 
-                                                 PRUint32 aAttrNum,
-                                                 nsIAtom *aTagName = nsnull,
-                                                 PRUint32 aAncestorLevelsToSearch = 5);
-
-  /**
-   * Overloaded version of FindNeighbourPointingToNode to accept only one
-   * relation attribute.
-   */
-  static nsIContent *FindNeighbourPointingToNode(nsIContent *aForNode,
-                                                 nsIAtom *aRelationAttr, 
-                                                 nsIAtom *aTagName = nsnull,
-                                                 PRUint32 aAncestorLevelsToSearch = 5);
-
-  /**
-   * Search for element that satisfies the requirements in subtree of the given
-   * element. The requirements are tag name, attribute name and value of
-   * attribute.
-   * The first matched content will be returned.
-   *
-   * @param aId - value of searched attribute
-   * @param aLookContent - element that search is performed inside
-   * @param aRelationAttrs - an array of searched attributes
-   * @param aAttrNum - how many attributes in aRelationAttrs
-   * @param                 if both aAriaProperty and aRelationAttrs are null, then any element with aTagType will do
-   * @param aExcludeContent - element that is skiped for search
-   * @param aTagType - tag name of searched element, by default it is 'label' --
-   *                   ignored if aAriaProperty passed in
-   */
-  static nsIContent *FindDescendantPointingToID(const nsString *aId,
-                                                nsIContent *aLookContent,
-                                                nsIAtom **aRelationAttrs,
-                                                PRUint32 aAttrNum = 1,
-                                                nsIContent *aExcludeContent = nsnull,
-                                                nsIAtom *aTagType = nsAccessibilityAtoms::label);
-
-  /**
-   * Overloaded version of FindDescendantPointingToID to accept only one
-   * relation attribute.
-   */
-  static nsIContent *FindDescendantPointingToID(const nsString *aId,
-                                                nsIContent *aLookContent,
-                                                nsIAtom *aRelationAttr,
-                                                nsIContent *aExcludeContent = nsnull,
-                                                nsIAtom *aTagType = nsAccessibilityAtoms::label);
-
-  // Helper for FindDescendantPointingToID(), same args
-  static nsIContent *FindDescendantPointingToIDImpl(nsCString& aIdWithSpaces,
-                                                    nsIContent *aLookContent,
-                                                    nsIAtom **aRelationAttrs,
-                                                    PRUint32 aAttrNum = 1,
-                                                    nsIContent *aExcludeContent = nsnull,
-                                                    nsIAtom *aTagType = nsAccessibilityAtoms::label);
-  
-  // Return PR_TRUE if the ARIA property should always be exposed as an object attribute
-  static PRBool IsARIAPropForObjectAttr(nsIAtom *aAtom);
-
-
-  /**
-   * Get container-foo live region attributes for the given node
-   * @param aAttributes     Where to store the attributes
-   * @param aStartContent   Node to start from
-   * @param aTopContent     Node to end at
-   */
-  static void GetLiveContainerAttributes(nsIPersistentProperties *aAttributes,
-                                         nsIContent *aStartContent, nsIContent *aTopContent);
-};
-
-#endif
-
diff -r 4b060ed856e0 accessible/src/base/nsAccessible.cpp
--- a/accessible/src/base/nsAccessible.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/accessible/src/base/nsAccessible.cpp	Thu Oct 16 21:24:47 2008 -0500
@@ -336,18 +336,19 @@ NS_IMETHODIMP nsAccessible::GetDescripti
   if (!content->IsNodeOfType(nsINode::eTEXT)) {
     nsAutoString description;
     nsresult rv = GetTextFromRelationID(nsAccessibilityAtoms::aria_describedby, description);
     if (NS_FAILED(rv)) {
       PRBool isXUL = content->IsNodeOfType(nsINode::eXUL);
       if (isXUL) {
         // Try XUL <description control="[id]">description text</description>
         nsIContent *descriptionContent =
-          nsAccUtils::FindNeighbourPointingToNode(content, nsAccessibilityAtoms::control,
-                                                  nsAccessibilityAtoms::description);
+          nsCoreUtils::FindNeighbourPointingToNode(content,
+                                                   nsAccessibilityAtoms::control,
+                                                   nsAccessibilityAtoms::description);
 
         if (descriptionContent) {
           // We have a description content node
           AppendFlatStringFromSubtree(descriptionContent, &description);
         }
       }
       if (description.IsEmpty()) {
         nsIAtom *descAtom = isXUL ? nsAccessibilityAtoms::tooltiptext :
@@ -431,24 +432,24 @@ nsAccessible::GetKeyboardShortcut(nsAStr
 nsAccessible::GetKeyboardShortcut(nsAString& aAccessKey)
 {
   aAccessKey.Truncate();
 
   nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
   if (!content)
     return NS_ERROR_FAILURE;
 
-  PRUint32 key = nsAccUtils::GetAccessKeyFor(content);
+  PRUint32 key = nsCoreUtils::GetAccessKeyFor(content);
   if (!key && content->IsNodeOfType(nsIContent::eELEMENT)) {
     // Copy access key from label node unless it is labeled
     // via an ancestor <label>, in which case that would be redundant
     nsCOMPtr<nsIContent> labelContent(GetLabelContent(content));
     nsCOMPtr<nsIDOMNode> labelNode = do_QueryInterface(labelContent);
-    if (labelNode && !nsAccUtils::IsAncestorOf(labelNode, mDOMNode))
-      key = nsAccUtils::GetAccessKeyFor(labelContent);
+    if (labelNode && !nsCoreUtils::IsAncestorOf(labelNode, mDOMNode))
+      key = nsCoreUtils::GetAccessKeyFor(labelContent);
   }
 
   if (!key)
     return NS_OK;
 
   nsAutoString accesskey(key);
 
   // Append the modifiers in reverse order, result: Control+Alt+Shift+Meta+<key>
@@ -1065,17 +1066,17 @@ nsAccessible::GetState(PRUint32 *aState,
     *aState |= nsIAccessibleStates::STATE_OFFSCREEN;
   }
 
   nsIFrame *frame = GetFrame();
   if (frame && (frame->GetStateBits() & NS_FRAME_OUT_OF_FLOW))
     *aState |= nsIAccessibleStates::STATE_FLOATING;
 
   // Add 'linked' state for simple xlink.
-  if (nsAccUtils::IsXLink(content))
+  if (nsCoreUtils::IsXLink(content))
     *aState |= nsIAccessibleStates::STATE_LINKED;
 
   return NS_OK;
 }
 
   /* readonly attribute boolean focusedChild; */
 NS_IMETHODIMP nsAccessible::GetFocusedChild(nsIAccessible **aFocusedChild) 
 { 
@@ -1490,17 +1491,17 @@ nsAccessible::TakeFocus()
   NS_ENSURE_STATE(frame);
 
   // If the current element can't take real DOM focus and if it has an ID and
   // ancestor with a the aria-activedescendant attribute present, then set DOM
   // focus to that ancestor and set aria-activedescendant on the ancestor to
   // the ID of the desired element.
   if (!frame->IsFocusable()) {
     nsAutoString id;
-    if (content && nsAccUtils::GetID(content, id)) {
+    if (content && nsCoreUtils::GetID(content, id)) {
 
       nsCOMPtr<nsIContent> ancestorContent = content;
       while ((ancestorContent = ancestorContent->GetParent()) &&
              !ancestorContent->HasAttr(kNameSpaceID_None,
                                        nsAccessibilityAtoms::aria_activedescendant));
 
       if (ancestorContent) {
         nsCOMPtr<nsIPresShell> presShell(do_QueryReferent(mWeakShell));
@@ -1763,18 +1764,18 @@ nsAccessible::AppendFlatStringFromSubtre
   }
 
   return NS_OK;
 }
 
 nsIContent *nsAccessible::GetLabelContent(nsIContent *aForNode)
 {
   if (aForNode->IsNodeOfType(nsINode::eXUL))
-    return nsAccUtils::FindNeighbourPointingToNode(aForNode, nsAccessibilityAtoms::control,
-                                                   nsAccessibilityAtoms::label);
+    return nsCoreUtils::FindNeighbourPointingToNode(aForNode, nsAccessibilityAtoms::control,
+                                                    nsAccessibilityAtoms::label);
 
   return GetHTMLLabelContent(aForNode);
 }
 
 nsIContent* nsAccessible::GetHTMLLabelContent(nsIContent *aForNode)
 {
   // Get either <label for="[id]"> element which explictly points to aForNode, or 
   // <label> ancestor which implicitly point to it
@@ -1788,22 +1789,22 @@ nsIContent* nsAccessible::GetHTMLLabelCo
     }
     if (tag == nsAccessibilityAtoms::form ||
         tag == nsAccessibilityAtoms::body) {
       // Reached top ancestor in form
       // There can be a label targeted at this control using the 
       // for="control_id" attribute. To save computing time, only 
       // look for those inside of a form element
       nsAutoString forId;
-      if (!nsAccUtils::GetID(aForNode, forId)) {
+      if (!nsCoreUtils::GetID(aForNode, forId)) {
         break;
       }
       // Actually we'll be walking down the content this time, with a depth first search
-      return nsAccUtils::FindDescendantPointingToID(&forId, walkUpContent,
-                                                    nsAccessibilityAtoms::_for);
+      return nsCoreUtils::FindDescendantPointingToID(&forId, walkUpContent,
+                                                     nsAccessibilityAtoms::_for);
     }
   }
 
   return nsnull;
 }
 
 nsresult nsAccessible::GetTextFromRelationID(nsIAtom *aIDProperty, nsString &aName)
 {
@@ -1945,18 +1946,18 @@ nsresult nsAccessible::GetXULName(nsAStr
   // CASES #2 and #3 ------ label as a child or <label control="id" ... > </label>
   nsCOMPtr<nsIContent> content = GetRoleContent(mDOMNode);
   if (!content)
     return NS_OK;
 
   if (NS_FAILED(rv) || label.IsEmpty()) {
     label.Truncate();
     nsIContent *labelContent =
-      nsAccUtils::FindNeighbourPointingToNode(content, nsAccessibilityAtoms::control,
-                                              nsAccessibilityAtoms::label);
+      nsCoreUtils::FindNeighbourPointingToNode(content, nsAccessibilityAtoms::control,
+                                               nsAccessibilityAtoms::label);
 
     nsCOMPtr<nsIDOMXULLabelElement> xulLabel(do_QueryInterface(labelContent));
     // Check if label's value attribute is used
     if (xulLabel && NS_SUCCEEDED(xulLabel->GetValue(label)) && label.IsEmpty()) {
       // If no value attribute, a non-empty label must contain
       // children that define its text -- possibly using HTML
       AppendFlatStringFromSubtree(labelContent, &label);
     }
@@ -2120,17 +2121,17 @@ nsAccessible::GetAttributes(nsIPersisten
     NS_ADDREF(*aAttributes = attributes);
   }
  
   nsresult rv = GetAttributesInternal(attributes);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsAutoString id;
   nsAutoString oldValueUnused;
-  if (nsAccUtils::GetID(content, id)) {
+  if (nsCoreUtils::GetID(content, id)) {
     // Expose ID. If an <iframe id> exists override the one on the <body> of the source doc,
     // because the specific instance is what makes the ID useful for scripts
     attributes->SetStringProperty(NS_LITERAL_CSTRING("id"), id, oldValueUnused);
   }
   
   nsAutoString xmlRoles;
   if (content->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::role, xmlRoles)) {
     attributes->SetStringProperty(NS_LITERAL_CSTRING("xml-roles"),  xmlRoles, oldValueUnused);          
@@ -2315,17 +2316,18 @@ nsAccessible::GetAttributesInternal(nsIP
   nsIContent *startContent = content;
   while (PR_TRUE) {
     NS_ENSURE_STATE(startContent);
     nsIDocument *doc = startContent->GetDocument();
     nsCOMPtr<nsIDOMNode> docNode = do_QueryInterface(doc);
     NS_ENSURE_STATE(docNode);
     nsIContent *topContent = GetRoleContent(docNode);
     NS_ENSURE_STATE(topContent);
-    nsAccUtils::GetLiveContainerAttributes(aAttributes, startContent, topContent);
+    nsAccUtils::SetLiveContainerAttributes(aAttributes, startContent,
+                                           topContent);
     // Allow ARIA live region markup from outer documents to override
     nsCOMPtr<nsISupports> container = doc->GetContainer();
     nsIDocShellTreeItem *docShellTreeItem = nsnull;
     if (container)
       CallQueryInterface(container, &docShellTreeItem);
     if (!docShellTreeItem)
       break;
     nsIDocShellTreeItem *sameTypeParent = nsnull;
@@ -2439,17 +2441,17 @@ nsAccessible::GetFinalState(PRUint32 *aS
       NS_ENSURE_SUCCESS(rv, rv);
 
       if (tabPanel && Role(tabPanel) == nsIAccessibleRole::ROLE_PROPERTYPAGE) {
         nsCOMPtr<nsIAccessNode> tabPanelAccessNode(do_QueryInterface(tabPanel));
         nsCOMPtr<nsIDOMNode> tabPanelNode;
         tabPanelAccessNode->GetDOMNode(getter_AddRefs(tabPanelNode));
         NS_ENSURE_STATE(tabPanelNode);
 
-        if (nsAccUtils::IsAncestorOf(tabPanelNode, gLastFocusedNode))
+        if (nsCoreUtils::IsAncestorOf(tabPanelNode, gLastFocusedNode))
           *aState |= nsIAccessibleStates::STATE_SELECTED;
       }
     }
   }
 
   const PRUint32 kExpandCollapseStates =
     nsIAccessibleStates::STATE_COLLAPSED | nsIAccessibleStates::STATE_EXPANDED;
   if ((*aState & kExpandCollapseStates) == kExpandCollapseStates) {
@@ -2476,17 +2478,17 @@ nsAccessible::GetFinalState(PRUint32 *aS
 
   if (mRoleMapEntry) {
     // If an object has an ancestor with the activedescendant property
     // pointing at it, we mark it as ACTIVE even if it's not currently focused.
     // This allows screen reader virtual buffer modes to know which descendant
     // is the current one that would get focus if the user navigates to the container widget.
     nsCOMPtr<nsIContent> content = do_QueryInterface(mDOMNode);
     nsAutoString id;
-    if (content && nsAccUtils::GetID(content, id)) {
+    if (content && nsCoreUtils::GetID(content, id)) {
       nsIContent *ancestorContent = content;
       nsAutoString activeID;
       while ((ancestorContent = ancestorContent->GetParent()) != nsnull) {
         if (ancestorContent->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_activedescendant, activeID)) {
           if (id == activeID) {
             *aExtraState |= nsIAccessibleStates::EXT_STATE_ACTIVE;
           }
           break;
@@ -2636,17 +2638,17 @@ nsAccessible::GetValue(nsAString& aValue
       content->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_valuenow, aValue);
     }
   }
 
   if (!aValue.IsEmpty())
     return NS_OK;
 
   // Check if it's a simple xlink.
-  if (nsAccUtils::IsXLink(content)) {
+  if (nsCoreUtils::IsXLink(content)) {
     nsCOMPtr<nsIPresShell> presShell(do_QueryReferent(mWeakShell));
     if (presShell)
       return presShell->GetLinkLocation(mDOMNode, aValue);
   }
 
   return NS_OK;
 }
 
@@ -2750,17 +2752,17 @@ NS_IMETHODIMP nsAccessible::GetRole(PRUi
 {
   NS_ENSURE_ARG_POINTER(aRole);
   *aRole = nsIAccessibleRole::ROLE_NOTHING;
 
   if (IsDefunct())
     return NS_ERROR_FAILURE;
 
   nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
-  if (nsAccUtils::IsXLink(content))
+  if (nsCoreUtils::IsXLink(content))
     *aRole = nsIAccessibleRole::ROLE_LINK;
 
   return NS_OK;
 }
 
 // readonly attribute PRUint8 numActions
 NS_IMETHODIMP
 nsAccessible::GetNumActions(PRUint8 *aNumActions)
@@ -2933,54 +2935,54 @@ NS_IMETHODIMP nsAccessible::GetAccessibl
     {
       if (content->Tag() == nsAccessibilityAtoms::label) {
         nsIAtom *relatedIDAttr = content->IsNodeOfType(nsINode::eHTML) ?
           nsAccessibilityAtoms::_for : nsAccessibilityAtoms::control;
         content->GetAttr(kNameSpaceID_None, relatedIDAttr, relatedID);
       }
       if (relatedID.IsEmpty()) {
         relatedNode =
-          do_QueryInterface(nsAccUtils::FindNeighbourPointingToNode(content, nsAccessibilityAtoms::aria_labelledby));
+          do_QueryInterface(nsCoreUtils::FindNeighbourPointingToNode(content, nsAccessibilityAtoms::aria_labelledby));
       }
       break;
     }
   case nsIAccessibleRelation::RELATION_LABELLED_BY:
     {
       if (!content->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_labelledby, relatedID)) {
         relatedNode = do_QueryInterface(GetLabelContent(content));
       }
       break;
     }
   case nsIAccessibleRelation::RELATION_DESCRIBED_BY:
     {
       if (!content->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_describedby, relatedID)) {
         relatedNode = do_QueryInterface(
-          nsAccUtils::FindNeighbourPointingToNode(content, nsAccessibilityAtoms::control, nsAccessibilityAtoms::description));
+          nsCoreUtils::FindNeighbourPointingToNode(content, nsAccessibilityAtoms::control, nsAccessibilityAtoms::description));
       }
       break;
     }
   case nsIAccessibleRelation::RELATION_DESCRIPTION_FOR:
     {
       relatedNode =
-        do_QueryInterface(nsAccUtils::FindNeighbourPointingToNode(content, nsAccessibilityAtoms::aria_describedby));
+        do_QueryInterface(nsCoreUtils::FindNeighbourPointingToNode(content, nsAccessibilityAtoms::aria_describedby));
 
       if (!relatedNode && content->Tag() == nsAccessibilityAtoms::description &&
           content->IsNodeOfType(nsINode::eXUL)) {
         // This affectively adds an optional control attribute to xul:description,
         // which only affects accessibility, by allowing the description to be
         // tied to a control.
         content->GetAttr(kNameSpaceID_None,
                          nsAccessibilityAtoms::control, relatedID);
       }
       break;
     }
   case nsIAccessibleRelation::RELATION_NODE_CHILD_OF:
     {
       relatedNode =
-        do_QueryInterface(nsAccUtils::FindNeighbourPointingToNode(content, nsAccessibilityAtoms::aria_owns));
+        do_QueryInterface(nsCoreUtils::FindNeighbourPointingToNode(content, nsAccessibilityAtoms::aria_owns));
       if (!relatedNode && mRoleMapEntry && mRoleMapEntry->role == nsIAccessibleRole::ROLE_OUTLINEITEM) {
         // This is an ARIA tree that doesn't use owns, so we need to get the parent the hard way
         nsAccUtils::GetARIATreeItemParent(this, content, aRelated);
         return NS_OK;
       }
       // If accessible is in its own Window then we should provide NODE_CHILD_OF relation
       // so that MSAA clients can easily get to true parent instead of getting to oleacc's
       // ROLE_WINDOW accessible which will prevent us from going up further (because it is
@@ -2996,33 +2998,33 @@ NS_IMETHODIMP nsAccessible::GetAccessibl
           }
         }
       }
       break;
     }
   case nsIAccessibleRelation::RELATION_CONTROLLED_BY:
     {
       relatedNode =
-        do_QueryInterface(nsAccUtils::FindNeighbourPointingToNode(content, nsAccessibilityAtoms::aria_controls));
+        do_QueryInterface(nsCoreUtils::FindNeighbourPointingToNode(content, nsAccessibilityAtoms::aria_controls));
       break;
     }
   case nsIAccessibleRelation::RELATION_CONTROLLER_FOR:
     {
       content->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_controls, relatedID);
       break;
     }
   case nsIAccessibleRelation::RELATION_FLOWS_TO:
     {
       content->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_flowto, relatedID);
       break;
     }
   case nsIAccessibleRelation::RELATION_FLOWS_FROM:
     {
       relatedNode =
-        do_QueryInterface(nsAccUtils::FindNeighbourPointingToNode(content, nsAccessibilityAtoms::aria_flowto));
+        do_QueryInterface(nsCoreUtils::FindNeighbourPointingToNode(content, nsAccessibilityAtoms::aria_flowto));
       break;
     }
   case nsIAccessibleRelation::RELATION_DEFAULT_BUTTON:
     {
       if (content->IsNodeOfType(nsINode::eHTML)) {
         // HTML form controls implements nsIFormControl interface.
         nsCOMPtr<nsIFormControl> control(do_QueryInterface(content));
         if (control) {
@@ -3194,22 +3196,22 @@ void nsAccessible::DoCommandCallback(nsI
 
   nsCOMPtr<nsIPresShell> presShell = doc->GetPrimaryShell();
 
   // Scroll into view.
   presShell->ScrollContentIntoView(content, NS_PRESSHELL_SCROLL_ANYWHERE,
                                    NS_PRESSHELL_SCROLL_ANYWHERE);
 
   // Fire mouse down and mouse up events.
-  PRBool res = nsAccUtils::DispatchMouseEvent(NS_MOUSE_BUTTON_DOWN, presShell,
-                                              content);
+  PRBool res = nsCoreUtils::DispatchMouseEvent(NS_MOUSE_BUTTON_DOWN, presShell,
+                                               content);
   if (!res)
     return;
 
-  nsAccUtils::DispatchMouseEvent(NS_MOUSE_BUTTON_UP, presShell, content);
+  nsCoreUtils::DispatchMouseEvent(NS_MOUSE_BUTTON_UP, presShell, content);
 }
 
 /*
  * Use Timer to execute "Click" command of XUL/HTML element (e.g. menuitem, button...).
  *
  * When "Click" is to open a "modal" dialog/window, it won't return untill the
  * dialog/window is closed. If executing "Click" command directly in
  * nsXXXAccessible::DoAction, it will block AT-Tools(e.g. GOK) that invoke
@@ -3440,17 +3442,17 @@ nsAccessible::GetURI(PRInt32 aIndex, nsI
   NS_ENSURE_ARG_POINTER(aURI);
   *aURI = nsnull;
 
   if (aIndex != 0)
     return NS_ERROR_INVALID_ARG;
 
   // Check if it's a simple xlink.
   nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
-  if (nsAccUtils::IsXLink(content)) {
+  if (nsCoreUtils::IsXLink(content)) {
     nsAutoString href;
     content->GetAttr(kNameSpaceID_XLink, nsAccessibilityAtoms::href, href);
 
     nsCOMPtr<nsIURI> baseURI = content->GetBaseURI();
     nsCOMPtr<nsIDocument> document = content->GetOwnerDoc();
     return NS_NewURI(aURI, href,
                      document ? document->GetDocumentCharacterSet().get() : nsnull,
                      baseURI);
@@ -3709,22 +3711,22 @@ PRUint32
 PRUint32
 nsAccessible::GetActionRule(PRUint32 aStates)
 {
   if (aStates & nsIAccessibleStates::STATE_UNAVAILABLE)
     return eNoAction;
 
   // Check if it's simple xlink.
   nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
-  if (nsAccUtils::IsXLink(content))
+  if (nsCoreUtils::IsXLink(content))
     return eJumpAction;
 
   // Has registered 'click' event handler.
-  PRBool isOnclick = nsAccUtils::HasListener(content,
-                                             NS_LITERAL_STRING("click"));
+  PRBool isOnclick = nsCoreUtils::HasListener(content,
+                                              NS_LITERAL_STRING("click"));
 
   if (isOnclick)
     return eClickAction;
 
   // Get an action based on ARIA role.
   if (mRoleMapEntry)
     return mRoleMapEntry->actionRule;
 
diff -r 4b060ed856e0 accessible/src/base/nsAccessibleEventData.cpp
--- a/accessible/src/base/nsAccessibleEventData.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/accessible/src/base/nsAccessibleEventData.cpp	Thu Oct 16 21:24:47 2008 -0500
@@ -33,17 +33,17 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsAccessibleEventData.h"
 #include "nsAccessibilityAtoms.h"
-#include "nsAccessibilityUtils.h"
+#include "nsCoreUtils.h"
 #include "nsIAccessibilityService.h"
 #include "nsIAccessNode.h"
 #include "nsIDocument.h"
 #include "nsIDOMDocument.h"
 #include "nsIEventStateManager.h"
 #include "nsIPersistentProperties2.h"
 #include "nsIServiceManager.h"
 #ifdef MOZ_XUL
@@ -317,28 +317,28 @@ nsAccEvent::ApplyEventRules(nsCOMArray<n
               thisEvent->mEventRule == nsAccEvent::eDoNotEmit)
             continue; //  Do not need to check
 
           if (thisEvent->mDOMNode == tailEvent->mDOMNode) {
             // Dupe
             thisEvent->mEventRule = nsAccEvent::eDoNotEmit;
             continue;
           }
-          if (nsAccUtils::IsAncestorOf(tailEvent->mDOMNode,
-                                       thisEvent->mDOMNode)) {
+          if (nsCoreUtils::IsAncestorOf(tailEvent->mDOMNode,
+                                        thisEvent->mDOMNode)) {
             // thisDOMNode is a descendant of tailDOMNode
             // Do not emit thisEvent, also apply this result to sibling
             // nodes of thisDOMNode.
             thisEvent->mEventRule = nsAccEvent::eDoNotEmit;
             ApplyToSiblings(aEventsToFire, 0, index, thisEvent->mEventType,
                             thisEvent->mDOMNode, nsAccEvent::eDoNotEmit);
             continue;
           }
-          if (nsAccUtils::IsAncestorOf(thisEvent->mDOMNode,
-                                       tailEvent->mDOMNode)) {
+          if (nsCoreUtils::IsAncestorOf(thisEvent->mDOMNode,
+                                        tailEvent->mDOMNode)) {
             // tailDOMNode is a descendant of thisDOMNode
             // Do not emit tailEvent, also apply this result to sibling
             // nodes of tailDOMNode.
             tailEvent->mEventRule = nsAccEvent::eDoNotEmit;
             ApplyToSiblings(aEventsToFire, 0, tail, tailEvent->mEventType,
                             tailEvent->mDOMNode, nsAccEvent::eDoNotEmit);
             break;
           }
@@ -376,17 +376,17 @@ nsAccEvent::ApplyToSiblings(nsCOMArray<n
                             PRUint32 aStart, PRUint32 aEnd,
                              PRUint32 aEventType, nsIDOMNode* aDOMNode,
                              EEventRule aEventRule)
 {
   for (PRUint32 index = aStart; index < aEnd; index ++) {
     nsRefPtr<nsAccEvent> accEvent = GetAccEventPtr(aEventsToFire[index]);
     if (accEvent->mEventType == aEventType &&
         accEvent->mEventRule != nsAccEvent::eDoNotEmit &&
-        nsAccUtils::AreSiblings(accEvent->mDOMNode, aDOMNode)) {
+        nsCoreUtils::AreSiblings(accEvent->mDOMNode, aDOMNode)) {
       accEvent->mEventRule = aEventRule;
     }
   }
 }
 
 // nsAccStateChangeEvent
 NS_IMPL_ISUPPORTS_INHERITED1(nsAccStateChangeEvent, nsAccEvent,
                              nsIAccessibleStateChangeEvent)
diff -r 4b060ed856e0 accessible/src/base/nsBaseWidgetAccessible.cpp
--- a/accessible/src/base/nsBaseWidgetAccessible.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/accessible/src/base/nsBaseWidgetAccessible.cpp	Thu Oct 16 21:24:47 2008 -0500
@@ -37,17 +37,17 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsBaseWidgetAccessible.h"
 #include "nsAccessibilityAtoms.h"
 #include "nsIAccessibilityService.h"
 #include "nsIAccessibleDocument.h"
 #include "nsAccessibleWrap.h"
-#include "nsAccessibilityUtils.h"
+#include "nsCoreUtils.h"
 #include "nsIDOMNSHTMLElement.h"
 #include "nsGUIEvent.h"
 #include "nsHyperTextAccessibleWrap.h"
 #include "nsILink.h"
 #include "nsIFrame.h"
 #include "nsINameSpaceManager.h"
 #include "nsPresContext.h"
 #include "nsIPresShell.h"
@@ -251,28 +251,28 @@ nsLinkableAccessible::Shutdown()
 
 ////////////////////////////////////////////////////////////////////////////////
 // nsLinkableAccessible
 
 void
 nsLinkableAccessible::CacheActionContent()
 {
   nsCOMPtr<nsIContent> walkUpContent(do_QueryInterface(mDOMNode));
-  PRBool isOnclick = nsAccUtils::HasListener(walkUpContent,
-                                             NS_LITERAL_STRING("click"));
+  PRBool isOnclick = nsCoreUtils::HasListener(walkUpContent,
+                                              NS_LITERAL_STRING("click"));
 
   if (isOnclick) {
     mActionContent = walkUpContent;
     mIsOnclick = PR_TRUE;
     return;
   }
 
   while ((walkUpContent = walkUpContent->GetParent())) {
-    isOnclick = nsAccUtils::HasListener(walkUpContent,
-                                        NS_LITERAL_STRING("click"));
+    isOnclick = nsCoreUtils::HasListener(walkUpContent,
+                                         NS_LITERAL_STRING("click"));
   
     nsCOMPtr<nsIDOMNode> walkUpNode(do_QueryInterface(walkUpContent));
 
     nsCOMPtr<nsIAccessible> walkUpAcc;
     GetAccService()->GetAccessibleInWeakShell(walkUpNode, mWeakShell,
                                               getter_AddRefs(walkUpAcc));
 
     if (walkUpAcc && Role(walkUpAcc) == nsIAccessibleRole::ROLE_LINK &&
diff -r 4b060ed856e0 accessible/src/base/nsCoreUtils.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/accessible/src/base/nsCoreUtils.cpp	Thu Oct 16 21:24:47 2008 -0500
@@ -0,0 +1,588 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Alexander Surkov <surkov.alexander@gmail.com> (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsCoreUtils.h"
+
+#include "nsIAccessibleTypes.h"
+
+#include "nsAccessNode.h"
+
+#include "nsIDocument.h"
+#include "nsIDOMAbstractView.h"
+#include "nsIDOM3Node.h"
+#include "nsIDOMDocument.h"
+#include "nsIDOMDocumentView.h"
+#include "nsIDOMDocumentXBL.h"
+#include "nsIDOMHTMLDocument.h"
+#include "nsIDOMHTMLElement.h"
+#include "nsIDOMNodeList.h"
+#include "nsIDOMRange.h"
+#include "nsIDOMWindowInternal.h"
+#include "nsIEventListenerManager.h"
+#include "nsIPresShell.h"
+#include "nsPresContext.h"
+#include "nsIScrollableFrame.h"
+#include "nsIEventStateManager.h"
+#include "nsISelection2.h"
+#include "nsISelectionController.h"
+#include "nsGUIEvent.h"
+
+#include "nsContentCID.h"
+#include "nsComponentManagerUtils.h"
+#include "nsIInterfaceRequestorUtils.h"
+
+static NS_DEFINE_IID(kRangeCID, NS_RANGE_CID);
+
+PRBool
+nsCoreUtils::HasListener(nsIContent *aContent, const nsAString& aEventType)
+{
+  NS_ENSURE_TRUE(aContent, PR_FALSE);
+  nsCOMPtr<nsIEventListenerManager> listenerManager;
+  aContent->GetListenerManager(PR_FALSE, getter_AddRefs(listenerManager));
+
+  return listenerManager && listenerManager->HasListenersFor(aEventType);  
+}
+
+PRBool
+nsCoreUtils::DispatchMouseEvent(PRUint32 aEventType,
+                                nsIPresShell *aPresShell,
+                                nsIContent *aContent)
+{
+  nsIFrame *frame = aPresShell->GetPrimaryFrameFor(aContent);
+  if (!frame)
+    return PR_FALSE;
+
+  nsIFrame* rootFrame = aPresShell->GetRootFrame();
+  if (!rootFrame)
+    return PR_FALSE;
+
+  nsCOMPtr<nsIWidget> rootWidget = rootFrame->GetWindow();
+  if (!rootWidget)
+    return PR_FALSE;
+
+  // Compute x and y coordinates.
+  nsPoint point = frame->GetOffsetToExternal(rootFrame);
+  nsSize size = frame->GetSize();
+
+  nsPresContext* presContext = aPresShell->GetPresContext();
+
+  PRInt32 x = presContext->AppUnitsToDevPixels(point.x + size.width / 2);
+  PRInt32 y = presContext->AppUnitsToDevPixels(point.y + size.height / 2);
+  
+  // Fire mouse event.
+  nsMouseEvent event(PR_TRUE, aEventType, rootWidget,
+                     nsMouseEvent::eReal, nsMouseEvent::eNormal);
+
+  event.refPoint = nsIntPoint(x, y);
+  
+  event.clickCount = 1;
+  event.button = nsMouseEvent::eLeftButton;
+  event.time = PR_IntervalNow();
+  
+  nsEventStatus status = nsEventStatus_eIgnore;
+  aPresShell->HandleEventWithTarget(&event, frame, aContent, &status);
+
+  return PR_TRUE;
+}
+
+PRUint32
+nsCoreUtils::GetAccessKeyFor(nsIContent *aContent)
+{
+  if (!aContent)
+    return 0;
+
+  // Accesskeys are registered by @accesskey attribute only. At first check
+  // whether it is presented on the given element to avoid the slow
+  // nsIEventStateManager::GetRegisteredAccessKey() method.
+  if (!aContent->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::accesskey))
+    return 0;
+
+  nsCOMPtr<nsIDocument> doc = aContent->GetOwnerDoc();
+  if (!doc)
+    return 0;
+
+  nsCOMPtr<nsIPresShell> presShell = doc->GetPrimaryShell();
+  if (!presShell)
+    return 0;
+
+  nsPresContext *presContext = presShell->GetPresContext();
+  if (!presContext)
+    return 0;
+
+  nsIEventStateManager *esm = presContext->EventStateManager();
+  if (!esm)
+    return 0;
+
+  PRUint32 key = 0;
+  esm->GetRegisteredAccessKey(aContent, &key);
+  return key;
+}
+
+already_AddRefed<nsIDOMElement>
+nsCoreUtils::GetDOMElementFor(nsIDOMNode *aNode)
+{
+  nsCOMPtr<nsINode> node(do_QueryInterface(aNode));
+  nsIDOMElement *element = nsnull;
+
+  if (node->IsNodeOfType(nsINode::eELEMENT))
+    CallQueryInterface(node, &element);
+
+  else if (node->IsNodeOfType(nsINode::eTEXT))
+    CallQueryInterface(node->GetNodeParent(), &element);
+
+  else if (node->IsNodeOfType(nsINode::eDOCUMENT)) {
+    nsCOMPtr<nsIDOMHTMLDocument> htmlDoc(do_QueryInterface(node));
+    if (htmlDoc) {
+      nsCOMPtr<nsIDOMHTMLElement> bodyElement;
+      htmlDoc->GetBody(getter_AddRefs(bodyElement));
+      if (bodyElement) {
+        CallQueryInterface(bodyElement, &element);
+        return element;
+      }
+    }
+
+    nsCOMPtr<nsIDOMDocument> domDoc(do_QueryInterface(node));
+    domDoc->GetDocumentElement(&element);
+  }
+
+  return element;
+}
+
+PRBool
+nsCoreUtils::IsAncestorOf(nsIDOMNode *aPossibleAncestorNode,
+                          nsIDOMNode *aPossibleDescendantNode)
+{
+  NS_ENSURE_TRUE(aPossibleAncestorNode && aPossibleDescendantNode, PR_FALSE);
+
+  nsCOMPtr<nsIDOMNode> loopNode = aPossibleDescendantNode;
+  nsCOMPtr<nsIDOMNode> parentNode;
+  while (NS_SUCCEEDED(loopNode->GetParentNode(getter_AddRefs(parentNode))) &&
+         parentNode) {
+    if (parentNode == aPossibleAncestorNode) {
+      return PR_TRUE;
+    }
+    loopNode.swap(parentNode);
+  }
+  return PR_FALSE;
+}
+
+PRBool
+nsCoreUtils::AreSiblings(nsIDOMNode *aDOMNode1,
+                        nsIDOMNode *aDOMNode2)
+{
+  NS_ENSURE_TRUE(aDOMNode1 && aDOMNode2, PR_FALSE);
+
+  nsCOMPtr<nsIDOMNode> parentNode1, parentNode2;
+  if (NS_SUCCEEDED(aDOMNode1->GetParentNode(getter_AddRefs(parentNode1))) &&
+      NS_SUCCEEDED(aDOMNode2->GetParentNode(getter_AddRefs(parentNode2))) &&
+      parentNode1 == parentNode2) {
+    return PR_TRUE;
+  }
+  return PR_FALSE;
+}
+
+nsresult
+nsCoreUtils::ScrollSubstringTo(nsIFrame *aFrame,
+                               nsIDOMNode *aStartNode, PRInt32 aStartIndex,
+                               nsIDOMNode *aEndNode, PRInt32 aEndIndex,
+                               PRUint32 aScrollType)
+{
+  PRInt16 vPercent, hPercent;
+  ConvertScrollTypeToPercents(aScrollType, &vPercent, &hPercent);
+
+  return ScrollSubstringTo(aFrame, aStartNode, aStartIndex, aEndNode, aEndIndex,
+                           vPercent, hPercent);
+}
+
+nsresult
+nsCoreUtils::ScrollSubstringTo(nsIFrame *aFrame,
+                               nsIDOMNode *aStartNode, PRInt32 aStartIndex,
+                               nsIDOMNode *aEndNode, PRInt32 aEndIndex,
+                               PRInt16 aVPercent, PRInt16 aHPercent)
+{
+  if (!aFrame || !aStartNode || !aEndNode)
+    return NS_ERROR_FAILURE;
+
+  nsPresContext *presContext = aFrame->PresContext();
+
+  nsCOMPtr<nsIDOMRange> scrollToRange = do_CreateInstance(kRangeCID);
+  NS_ENSURE_TRUE(scrollToRange, NS_ERROR_FAILURE);
+
+  nsCOMPtr<nsISelectionController> selCon;
+  aFrame->GetSelectionController(presContext, getter_AddRefs(selCon));
+  NS_ENSURE_TRUE(selCon, NS_ERROR_FAILURE);
+
+  scrollToRange->SetStart(aStartNode, aStartIndex);
+  scrollToRange->SetEnd(aEndNode, aEndIndex);
+
+  nsCOMPtr<nsISelection> selection1;
+  selCon->GetSelection(nsISelectionController::SELECTION_ACCESSIBILITY,
+                       getter_AddRefs(selection1));
+
+  nsCOMPtr<nsISelection2> selection(do_QueryInterface(selection1));
+  if (selection) {
+    selection->RemoveAllRanges();
+    selection->AddRange(scrollToRange);
+
+    selection->ScrollIntoView(nsISelectionController::SELECTION_ANCHOR_REGION,
+                              PR_TRUE, aVPercent, aHPercent);
+
+    selection->CollapseToStart();
+  }
+
+  return NS_OK;
+}
+
+void
+nsCoreUtils::ScrollFrameToPoint(nsIFrame *aScrollableFrame,
+                                nsIFrame *aFrame,
+                                const nsIntPoint& aPoint)
+{
+  nsIScrollableFrame *scrollableFrame = nsnull;
+  CallQueryInterface(aScrollableFrame, &scrollableFrame);
+  if (!scrollableFrame)
+    return;
+
+  nsPresContext *presContext = aFrame->PresContext();
+
+  nsIntRect frameRect = aFrame->GetScreenRectExternal();
+  PRInt32 devDeltaX = aPoint.x - frameRect.x;
+  PRInt32 devDeltaY = aPoint.y - frameRect.y;
+
+  nsPoint deltaPoint;
+  deltaPoint.x = presContext->DevPixelsToAppUnits(devDeltaX);
+  deltaPoint.y = presContext->DevPixelsToAppUnits(devDeltaY);
+
+  nsPoint scrollPoint = scrollableFrame->GetScrollPosition();
+  scrollPoint -= deltaPoint;
+
+  scrollableFrame->ScrollTo(scrollPoint);
+}
+
+void
+nsCoreUtils::ConvertScrollTypeToPercents(PRUint32 aScrollType,
+                                         PRInt16 *aVPercent,
+                                         PRInt16 *aHPercent)
+{
+  switch (aScrollType)
+  {
+    case nsIAccessibleScrollType::SCROLL_TYPE_TOP_LEFT:
+      *aVPercent = NS_PRESSHELL_SCROLL_TOP;
+      *aHPercent = NS_PRESSHELL_SCROLL_LEFT;
+      break;
+    case nsIAccessibleScrollType::SCROLL_TYPE_BOTTOM_RIGHT:
+      *aVPercent = NS_PRESSHELL_SCROLL_BOTTOM;
+      *aHPercent = NS_PRESSHELL_SCROLL_RIGHT;
+      break;
+    case nsIAccessibleScrollType::SCROLL_TYPE_TOP_EDGE:
+      *aVPercent = NS_PRESSHELL_SCROLL_TOP;
+      *aHPercent = NS_PRESSHELL_SCROLL_ANYWHERE;
+      break;
+    case nsIAccessibleScrollType::SCROLL_TYPE_BOTTOM_EDGE:
+      *aVPercent = NS_PRESSHELL_SCROLL_BOTTOM;
+      *aHPercent = NS_PRESSHELL_SCROLL_ANYWHERE;
+      break;
+    case nsIAccessibleScrollType::SCROLL_TYPE_LEFT_EDGE:
+      *aVPercent = NS_PRESSHELL_SCROLL_ANYWHERE;
+      *aHPercent = NS_PRESSHELL_SCROLL_LEFT;
+      break;
+    case nsIAccessibleScrollType::SCROLL_TYPE_RIGHT_EDGE:
+      *aVPercent = NS_PRESSHELL_SCROLL_ANYWHERE;
+      *aHPercent = NS_PRESSHELL_SCROLL_RIGHT;
+      break;
+    default:
+      *aVPercent = NS_PRESSHELL_SCROLL_ANYWHERE;
+      *aHPercent = NS_PRESSHELL_SCROLL_ANYWHERE;
+  }
+}
+
+nsIntPoint
+nsCoreUtils::GetScreenCoordsForWindow(nsIDOMNode *aNode)
+{
+  nsIntPoint coords(0, 0);
+  nsCOMPtr<nsIDocShellTreeItem> treeItem(GetDocShellTreeItemFor(aNode));
+  if (!treeItem)
+    return coords;
+
+  nsCOMPtr<nsIDocShellTreeItem> rootTreeItem;
+  treeItem->GetRootTreeItem(getter_AddRefs(rootTreeItem));
+  nsCOMPtr<nsIDOMDocument> domDoc = do_GetInterface(rootTreeItem);
+  nsCOMPtr<nsIDOMDocumentView> docView(do_QueryInterface(domDoc));
+  if (!docView)
+    return coords;
+
+  nsCOMPtr<nsIDOMAbstractView> abstractView;
+  docView->GetDefaultView(getter_AddRefs(abstractView));
+  nsCOMPtr<nsIDOMWindowInternal> windowInter(do_QueryInterface(abstractView));
+  if (!windowInter)
+    return coords;
+
+  windowInter->GetScreenX(&coords.x);
+  windowInter->GetScreenY(&coords.y);
+  return coords;
+}
+
+already_AddRefed<nsIDocShellTreeItem>
+nsCoreUtils::GetDocShellTreeItemFor(nsIDOMNode *aNode)
+{
+  if (!aNode)
+    return nsnull;
+
+  nsCOMPtr<nsIDOMDocument> domDoc;
+  aNode->GetOwnerDocument(getter_AddRefs(domDoc));
+  nsCOMPtr<nsIDocument> doc(do_QueryInterface(domDoc));
+  if (!doc)
+    doc = do_QueryInterface(aNode);
+
+  NS_ASSERTION(doc, "No document for node passed in");
+  NS_ENSURE_TRUE(doc, nsnull);
+
+  nsCOMPtr<nsISupports> container = doc->GetContainer();
+  nsIDocShellTreeItem *docShellTreeItem = nsnull;
+  if (container)
+    CallQueryInterface(container, &docShellTreeItem);
+
+  return docShellTreeItem;
+}
+
+nsIFrame*
+nsCoreUtils::GetFrameFor(nsIDOMElement *aElm)
+{
+  nsCOMPtr<nsIPresShell> shell = nsAccessNode::GetPresShellFor(aElm);
+  if (!shell)
+    return nsnull;
+  
+  nsCOMPtr<nsIContent> content(do_QueryInterface(aElm));
+  if (!content)
+    return nsnull;
+  
+  return shell->GetPrimaryFrameFor(content);
+}
+
+PRBool
+nsCoreUtils::GetID(nsIContent *aContent, nsAString& aID)
+{
+  nsIAtom *idAttribute = aContent->GetIDAttributeName();
+  return idAttribute ? aContent->GetAttr(kNameSpaceID_None, idAttribute, aID) : PR_FALSE;
+}
+
+PRBool
+nsCoreUtils::IsXLink(nsIContent *aContent)
+{
+  if (!aContent)
+    return PR_FALSE;
+
+  return aContent->AttrValueIs(kNameSpaceID_XLink, nsAccessibilityAtoms::type,
+                               nsAccessibilityAtoms::simple, eCaseMatters) &&
+         aContent->HasAttr(kNameSpaceID_XLink, nsAccessibilityAtoms::href);
+}
+
+nsIContent*
+nsCoreUtils::FindNeighbourPointingToNode(nsIContent *aForNode, 
+                                         nsIAtom *aRelationAttr,
+                                         nsIAtom *aTagName,
+                                         PRUint32 aAncestorLevelsToSearch)
+{
+  return FindNeighbourPointingToNode(aForNode, &aRelationAttr, 1, aTagName, aAncestorLevelsToSearch);
+}
+
+nsIContent*
+nsCoreUtils::FindNeighbourPointingToNode(nsIContent *aForNode, 
+                                         nsIAtom **aRelationAttrs,
+                                         PRUint32 aAttrNum,
+                                         nsIAtom *aTagName,
+                                         PRUint32 aAncestorLevelsToSearch)
+{
+  nsAutoString controlID;
+  if (!nsCoreUtils::GetID(aForNode, controlID)) {
+    if (!aForNode->IsInAnonymousSubtree())
+      return nsnull;
+
+    aForNode->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::anonid, controlID);
+    if (controlID.IsEmpty())
+      return nsnull;
+  }
+
+  // Look for label in subtrees of nearby ancestors
+  nsCOMPtr<nsIContent> binding(aForNode->GetBindingParent());
+  PRUint32 count = 0;
+  nsIContent *labelContent = nsnull;
+  nsIContent *prevSearched = nsnull;
+
+  while (!labelContent && ++count <= aAncestorLevelsToSearch &&
+         (aForNode = aForNode->GetParent()) != nsnull) {
+
+    if (aForNode == binding) {
+      // When we reach the binding parent, make sure to check
+      // all of its anonymous child subtrees
+      nsCOMPtr<nsIDocument> doc = aForNode->GetCurrentDoc();
+      nsCOMPtr<nsIDOMDocumentXBL> xblDoc(do_QueryInterface(doc));
+      if (!xblDoc)
+        return nsnull;
+
+      nsCOMPtr<nsIDOMNodeList> nodes;
+      nsCOMPtr<nsIDOMElement> forElm(do_QueryInterface(aForNode));
+      xblDoc->GetAnonymousNodes(forElm, getter_AddRefs(nodes));
+      if (!nodes)
+        return nsnull;
+
+      PRUint32 length;
+      nsresult rv = nodes->GetLength(&length);
+      if (NS_FAILED(rv))
+        return nsnull;
+
+      for (PRUint32 index = 0; index < length && !labelContent; index++) {
+        nsCOMPtr<nsIDOMNode> node;
+        rv = nodes->Item(index, getter_AddRefs(node));
+        if (NS_FAILED(rv))
+          return nsnull;
+
+        nsCOMPtr<nsIContent> content = do_QueryInterface(node);
+        if (!content)
+          return nsnull;
+
+        if (content != prevSearched) {
+          labelContent = FindDescendantPointingToID(&controlID, content,
+                                                    aRelationAttrs, aAttrNum,
+                                                    nsnull, aTagName);
+        }
+      }
+      break;
+    }
+
+    labelContent = FindDescendantPointingToID(&controlID, aForNode,
+                                              aRelationAttrs, aAttrNum,
+                                              prevSearched, aTagName);
+    prevSearched = aForNode;
+  }
+
+  return labelContent;
+}
+
+// Pass in aAriaProperty = null and aRelationAttr == nsnull if any <label> will do
+nsIContent*
+nsCoreUtils::FindDescendantPointingToID(const nsString *aId,
+                                        nsIContent *aLookContent,
+                                        nsIAtom **aRelationAttrs,
+                                        PRUint32 aAttrNum,
+                                        nsIContent *aExcludeContent,
+                                        nsIAtom *aTagType)
+{
+  // Surround id with spaces for search
+  nsCAutoString idWithSpaces(' ');
+  LossyAppendUTF16toASCII(*aId, idWithSpaces);
+  idWithSpaces += ' ';
+  return FindDescendantPointingToIDImpl(idWithSpaces, aLookContent,
+                                        aRelationAttrs, aAttrNum,
+                                        aExcludeContent, aTagType);
+}
+
+nsIContent*
+nsCoreUtils::FindDescendantPointingToID(const nsString *aId,
+                                        nsIContent *aLookContent,
+                                        nsIAtom *aRelationAttr,
+                                        nsIContent *aExcludeContent,
+                                        nsIAtom *aTagType)
+{
+  return FindDescendantPointingToID(aId, aLookContent, &aRelationAttr, 1, aExcludeContent, aTagType);
+}
+
+nsIContent*
+nsCoreUtils::FindDescendantPointingToIDImpl(nsCString& aIdWithSpaces,
+                                            nsIContent *aLookContent,
+                                            nsIAtom **aRelationAttrs,
+                                            PRUint32 aAttrNum,
+                                            nsIContent *aExcludeContent,
+                                            nsIAtom *aTagType)
+{
+  NS_ENSURE_TRUE(aLookContent, nsnull);
+  NS_ENSURE_TRUE(aRelationAttrs && *aRelationAttrs, nsnull);
+
+  if (!aTagType || aLookContent->Tag() == aTagType) {
+    // Tag matches
+    // Check for ID in the attributes aRelationAttrs, which can be a list
+    for (PRUint32 i = 0; i < aAttrNum; i++) {
+      nsAutoString idList;
+      if (aLookContent->GetAttr(kNameSpaceID_None, aRelationAttrs[i], idList)) {
+        idList.Insert(' ', 0);  // Surround idlist with spaces for search
+        idList.Append(' ');
+        // idList is now a set of id's with spaces around each,
+        // and id also has spaces around it.
+        // If id is a substring of idList then we have a match
+        if (idList.Find(aIdWithSpaces) != -1) {
+          return aLookContent;
+        }
+      }
+    }
+    if (aTagType) {
+      // Don't bother to search descendants of an element with matching tag.
+      // That would be like looking for a nested <label> or <description>
+      return nsnull;
+    }
+  }
+
+  // Recursively search descendants for match
+  PRUint32 count  = 0;
+  nsIContent *child;
+  nsIContent *labelContent = nsnull;
+
+  while ((child = aLookContent->GetChildAt(count++)) != nsnull) {
+    if (child != aExcludeContent) {
+      labelContent = FindDescendantPointingToIDImpl(aIdWithSpaces, child,
+                                                    aRelationAttrs, aAttrNum,
+                                                    aExcludeContent, aTagType);
+      if (labelContent) {
+        return labelContent;
+      }
+    }
+  }
+  return nsnull;
+}
+
+void
+nsCoreUtils::GetLanguageFor(nsIContent *aContent, nsIContent *aRootContent,
+                            nsAString& aLanguage)
+{
+  aLanguage.Truncate();
+
+  nsIContent *walkUp = aContent;
+  while (walkUp && walkUp != aRootContent &&
+         !walkUp->GetAttr(kNameSpaceID_None,
+                          nsAccessibilityAtoms::lang, aLanguage))
+    walkUp = walkUp->GetParent();
+}
diff -r 4b060ed856e0 accessible/src/base/nsCoreUtils.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/accessible/src/base/nsCoreUtils.h	Thu Oct 16 21:24:47 2008 -0500
@@ -0,0 +1,272 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Alexander Surkov <surkov.alexander@gmail.com> (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsCoreUtils_h_
+#define nsCoreUtils_h_
+
+#include "nsAccessibilityAtoms.h"
+
+#include "nsIDOMNode.h"
+#include "nsIContent.h"
+#include "nsIFrame.h"
+#include "nsIDocShellTreeItem.h"
+#include "nsPoint.h"
+
+class nsCoreUtils
+{
+public:
+  /**
+   * Return true if the given node has registered event listener of the given
+   * type.
+   */
+  static PRBool HasListener(nsIContent *aContent, const nsAString& aEventType);
+
+  /**
+   * Send mouse events to the given element.
+   *
+   * @param aEventType  an event type (see nsGUIEvent.h for constants)
+   * @param aPresShell  the presshell for the given element
+   * @param aContent    the element element
+   */
+  static PRBool DispatchMouseEvent(PRUint32 aEventType,
+                                   nsIPresShell *aPresShell,
+                                   nsIContent *aContent);
+
+  /**
+   * Return an accesskey registered on the given element by
+   * nsIEventStateManager or 0 if there is no registered accesskey.
+   *
+   * @param aContent - the given element.
+   */
+  static PRUint32 GetAccessKeyFor(nsIContent *aContent);
+
+  /**
+   * Return DOM element related with the given node, i.e.
+   * a) itself if it is DOM element
+   * b) parent element if it is text node
+   * c) body element if it is HTML document node
+   * d) document element if it is document node.
+   *
+   * @param aNode  [in] the given DOM node
+   */
+  static already_AddRefed<nsIDOMElement> GetDOMElementFor(nsIDOMNode *aNode);
+
+  /**
+   * Is the first passed in node an ancestor of the second?
+   * Note: A node is not considered to be the ancestor of itself.
+   * @param aPossibleAncestorNode -- node to test for ancestor-ness of aPossibleDescendantNode
+   * @param aPossibleDescendantNode -- node to test for descendant-ness of aPossibleAncestorNode
+   * @return PR_TRUE if aPossibleAncestorNode is an ancestor of aPossibleDescendantNode
+   */
+   static PRBool IsAncestorOf(nsIDOMNode *aPossibleAncestorNode,
+                              nsIDOMNode *aPossibleDescendantNode);
+
+  /**
+   * Are the first node and the second siblings?
+   * @return PR_TRUE if aDOMNode1 and aDOMNode2 have same parent
+   */
+   static PRBool AreSiblings(nsIDOMNode *aDOMNode1,
+                             nsIDOMNode *aDOMNode2);
+
+  /**
+   * Helper method to scroll range into view, used for implementation of
+   * nsIAccessibleText::scrollSubstringTo().
+   *
+   * @param aFrame        the frame for accessible the range belongs to.
+   * @param aStartNode    start node of a range
+   * @param aStartOffset  an offset inside the start node
+   * @param aEndNode      end node of a range
+   * @param aEndOffset    an offset inside the end node
+   * @param aScrollType   the place a range should be scrolled to
+   */
+  static nsresult ScrollSubstringTo(nsIFrame *aFrame,
+                                    nsIDOMNode *aStartNode, PRInt32 aStartIndex,
+                                    nsIDOMNode *aEndNode, PRInt32 aEndIndex,
+                                    PRUint32 aScrollType);
+
+  /** Helper method to scroll range into view, used for implementation of
+   * nsIAccessibleText::scrollSubstringTo[Point]().
+   *
+   * @param aFrame        the frame for accessible the range belongs to.
+   * @param aStartNode    start node of a range
+   * @param aStartOffset  an offset inside the start node
+   * @param aEndNode      end node of a range
+   * @param aEndOffset    an offset inside the end node
+   * @param aVPercent     how to align vertically, specified in percents
+   * @param aHPercent     how to align horizontally, specified in percents
+   */
+  static nsresult ScrollSubstringTo(nsIFrame *aFrame,
+                                    nsIDOMNode *aStartNode, PRInt32 aStartIndex,
+                                    nsIDOMNode *aEndNode, PRInt32 aEndIndex,
+                                    PRInt16 aVPercent, PRInt16 aHPercent);
+
+  /**
+   * Scrolls the given frame to the point, used for implememntation of
+   * nsIAccessNode::scrollToPoint and nsIAccessibleText::scrollSubstringToPoint.
+   *
+   * @param aScrollableFrame  the scrollable frame
+   * @param aFrame            the frame to scroll
+   * @param aPoint            the point scroll to
+   */
+  static void ScrollFrameToPoint(nsIFrame *aScrollableFrame,
+                                 nsIFrame *aFrame, const nsIntPoint& aPoint);
+
+  /**
+   * Converts scroll type constant defined in nsIAccessibleScrollType to
+   * vertical and horizontal percents.
+   */
+  static void ConvertScrollTypeToPercents(PRUint32 aScrollType,
+                                          PRInt16 *aVPercent,
+                                          PRInt16 *aHPercent);
+
+  /**
+   * Returns coordinates relative screen for the top level window.
+   *
+   * @param aNode  the DOM node hosted in the window.
+   */
+  static nsIntPoint GetScreenCoordsForWindow(nsIDOMNode *aNode);
+
+  /**
+   * Return document shell tree item for the given DOM node.
+   */
+  static already_AddRefed<nsIDocShellTreeItem>
+    GetDocShellTreeItemFor(nsIDOMNode *aNode);
+
+  /**
+   * Retrun frame for the given DOM element.
+   */
+  static nsIFrame* GetFrameFor(nsIDOMElement *aElm);
+
+  /**
+   * Get the ID for an element, in some types of XML this may not be the ID attribute
+   * @param aContent  Node to get the ID for
+   * @param aID       Where to put ID string
+   * @return          PR_TRUE if there is an ID set for this node
+   */
+  static PRBool GetID(nsIContent *aContent, nsAString& aID);
+
+  /**
+   * Check if the given element is XLink.
+   *
+   * @param aContent  the given element
+   * @return          PR_TRUE if the given element is XLink
+   */
+  static PRBool IsXLink(nsIContent *aContent);
+
+  /**
+   * Returns language for the given node.
+   *
+   * @param aContent     [in] the given node
+   * @param aRootContent [in] container of the given node
+   * @param aLanguage    [out] language
+   */
+  static void GetLanguageFor(nsIContent *aContent, nsIContent *aRootContent,
+                             nsAString& aLanguage);
+
+  /**
+   * Search element in neighborhood of the given element by tag name and
+   * attribute value that equals to ID attribute of the given element.
+   * ID attribute can be either 'id' attribute or 'anonid' if the element is
+   * anonymous.
+   * The first matched content will be returned.
+   *
+   * @param aForNode - the given element the search is performed for
+   * @param aRelationAttrs - an array of attributes, element is attribute name of searched element, ignored if aAriaProperty passed in
+   * @param aAttrNum - how many attributes in aRelationAttrs
+   * @param aTagName - tag name of searched element, or nsnull for any -- ignored if aAriaProperty passed in
+   * @param aAncestorLevelsToSearch - points how is the neighborhood of the
+   *                                  given element big.
+   */
+  static nsIContent *FindNeighbourPointingToNode(nsIContent *aForNode,
+                                                 nsIAtom **aRelationAttrs, 
+                                                 PRUint32 aAttrNum,
+                                                 nsIAtom *aTagName = nsnull,
+                                                 PRUint32 aAncestorLevelsToSearch = 5);
+
+  /**
+   * Overloaded version of FindNeighbourPointingToNode to accept only one
+   * relation attribute.
+   */
+  static nsIContent *FindNeighbourPointingToNode(nsIContent *aForNode,
+                                                 nsIAtom *aRelationAttr, 
+                                                 nsIAtom *aTagName = nsnull,
+                                                 PRUint32 aAncestorLevelsToSearch = 5);
+
+  /**
+   * Search for element that satisfies the requirements in subtree of the given
+   * element. The requirements are tag name, attribute name and value of
+   * attribute.
+   * The first matched content will be returned.
+   *
+   * @param aId - value of searched attribute
+   * @param aLookContent - element that search is performed inside
+   * @param aRelationAttrs - an array of searched attributes
+   * @param aAttrNum - how many attributes in aRelationAttrs
+   * @param                 if both aAriaProperty and aRelationAttrs are null, then any element with aTagType will do
+   * @param aExcludeContent - element that is skiped for search
+   * @param aTagType - tag name of searched element, by default it is 'label' --
+   *                   ignored if aAriaProperty passed in
+   */
+  static nsIContent *FindDescendantPointingToID(const nsString *aId,
+                                                nsIContent *aLookContent,
+                                                nsIAtom **aRelationAttrs,
+                                                PRUint32 aAttrNum = 1,
+                                                nsIContent *aExcludeContent = nsnull,
+                                                nsIAtom *aTagType = nsAccessibilityAtoms::label);
+
+  /**
+   * Overloaded version of FindDescendantPointingToID to accept only one
+   * relation attribute.
+   */
+  static nsIContent *FindDescendantPointingToID(const nsString *aId,
+                                                nsIContent *aLookContent,
+                                                nsIAtom *aRelationAttr,
+                                                nsIContent *aExcludeContent = nsnull,
+                                                nsIAtom *aTagType = nsAccessibilityAtoms::label);
+
+  // Helper for FindDescendantPointingToID(), same args
+  static nsIContent *FindDescendantPointingToIDImpl(nsCString& aIdWithSpaces,
+                                                    nsIContent *aLookContent,
+                                                    nsIAtom **aRelationAttrs,
+                                                    PRUint32 aAttrNum = 1,
+                                                    nsIContent *aExcludeContent = nsnull,
+                                                    nsIAtom *aTagType = nsAccessibilityAtoms::label);
+};
+
+#endif
+
diff -r 4b060ed856e0 accessible/src/base/nsDocAccessible.cpp
--- a/accessible/src/base/nsDocAccessible.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/accessible/src/base/nsDocAccessible.cpp	Thu Oct 16 21:24:47 2008 -0500
@@ -112,17 +112,17 @@ nsDocAccessible::nsDocAccessible(nsIDOMN
       }
     }
   }
 
   // XXX aaronl should we use an algorithm for the initial cache size?
   mAccessNodeCache.Init(kDefaultCacheSize);
 
   nsCOMPtr<nsIDocShellTreeItem> docShellTreeItem =
-    nsAccUtils::GetDocShellTreeItemFor(mDOMNode);
+    nsCoreUtils::GetDocShellTreeItemFor(mDOMNode);
   nsCOMPtr<nsIDocShell> docShell = do_QueryInterface(docShellTreeItem);
   if (docShell) {
     PRUint32 busyFlags;
     docShell->GetBusyFlags(&busyFlags);
     if (busyFlags == nsIDocShell::BUSY_FLAGS_NONE) {
       mIsContentLoaded = PR_TRUE;                                               
     }
   }
@@ -198,17 +198,17 @@ nsDocAccessible::GetName(nsAString& aNam
   return rv;
 }
 
 NS_IMETHODIMP nsDocAccessible::GetRole(PRUint32 *aRole)
 {
   *aRole = nsIAccessibleRole::ROLE_PANE; // Fall back
 
   nsCOMPtr<nsIDocShellTreeItem> docShellTreeItem =
-    nsAccUtils::GetDocShellTreeItemFor(mDOMNode);
+    nsCoreUtils::GetDocShellTreeItemFor(mDOMNode);
   if (docShellTreeItem) {
     nsCOMPtr<nsIDocShellTreeItem> sameTypeRoot;
     docShellTreeItem->GetSameTypeRootTreeItem(getter_AddRefs(sameTypeRoot));
     PRInt32 itemType;
     docShellTreeItem->GetItemType(&itemType);
     if (sameTypeRoot == docShellTreeItem) {
       // Root of content or chrome tree
       if (itemType == nsIDocShellTreeItem::typeChrome) {
@@ -366,17 +366,17 @@ NS_IMETHODIMP nsDocAccessible::TakeFocus
   NS_ENSURE_TRUE(mDocument, NS_ERROR_FAILURE);
   PRUint32 state;
   GetState(&state, nsnull);
   if (0 == (state & nsIAccessibleStates::STATE_FOCUSABLE)) {
     return NS_ERROR_FAILURE; // Not focusable
   }
 
   nsCOMPtr<nsIDocShellTreeItem> treeItem =
-    nsAccUtils::GetDocShellTreeItemFor(mDOMNode);
+    nsCoreUtils::GetDocShellTreeItemFor(mDOMNode);
   nsCOMPtr<nsIDocShell> docShell = do_QueryInterface(treeItem);
   NS_ENSURE_TRUE(docShell, NS_ERROR_FAILURE);
 
   nsCOMPtr<nsIPresShell> shell(GetPresShell());
   if (!shell) {
     NS_WARNING("Was not shutdown properly via InvalidateCacheSubtree()");
     return NS_ERROR_FAILURE;
   }
@@ -502,17 +502,17 @@ NS_IMETHODIMP nsDocAccessible::GetAssoci
   if (!mDocument)
     return NS_ERROR_FAILURE;
 
   // Check if document is editable (designMode="on" case). Otherwise check if
   // the html:body (for HTML document case) or document element is editable.
   if (!mDocument->HasFlag(NODE_IS_EDITABLE)) {
     nsCOMPtr<nsIDOMNode> DOMDocument(do_QueryInterface(mDocument));
     nsCOMPtr<nsIDOMElement> DOMElement =
-      nsAccUtils::GetDOMElementFor(DOMDocument);
+      nsCoreUtils::GetDOMElementFor(DOMDocument);
     nsCOMPtr<nsIContent> content(do_QueryInterface(DOMElement));
 
     if (!content->HasFlag(NODE_IS_EDITABLE))
       return NS_OK;
   }
 
   nsCOMPtr<nsISupports> container = mDocument->GetContainer();
   nsCOMPtr<nsIEditingSession> editingSession(do_GetInterface(container));
@@ -612,17 +612,17 @@ NS_IMETHODIMP nsDocAccessible::Init()
 
 NS_IMETHODIMP nsDocAccessible::Shutdown()
 {
   if (!mWeakShell) {
     return NS_OK;  // Already shutdown
   }
 
   nsCOMPtr<nsIDocShellTreeItem> treeItem =
-    nsAccUtils::GetDocShellTreeItemFor(mDOMNode);
+    nsCoreUtils::GetDocShellTreeItemFor(mDOMNode);
   ShutdownChildDocuments(treeItem);
 
   RemoveEventListeners();
 
   mWeakShell = nsnull;  // Avoid reentrancy
 
   ClearCache(mAccessNodeCache);
 
@@ -868,17 +868,17 @@ NS_IMETHODIMP nsDocAccessible::FireDocLo
   mIsContentLoaded = isFinished;
   if (isFinished) {
     if (mIsLoadCompleteFired)
       return NS_OK;
     mIsLoadCompleteFired = PR_TRUE;
   }
 
   nsCOMPtr<nsIDocShellTreeItem> treeItem =
-    nsAccUtils::GetDocShellTreeItemFor(mDOMNode);
+    nsCoreUtils::GetDocShellTreeItemFor(mDOMNode);
   if (!treeItem) {
     return NS_OK;
   }
   nsCOMPtr<nsIDocShellTreeItem> sameTypeRoot;
   treeItem->GetSameTypeRootTreeItem(getter_AddRefs(sameTypeRoot));
 
   if (isFinished) {
     // Need to wait until scrollable view is available
@@ -892,17 +892,17 @@ NS_IMETHODIMP nsDocAccessible::FireDocLo
     if (sameTypeRoot != treeItem) {
       // Fire show/hide events to indicate frame/iframe content is new, rather than
       // doc load event which causes screen readers to act is if entire page is reloaded
       InvalidateCacheSubtree(nsnull, nsIAccessibleEvent::EVENT_DOM_SIGNIFICANT_CHANGE);
     }
     // Fire STATE_CHANGE event for doc load finish if focus is in same doc tree
     if (gLastFocusedNode) {
       nsCOMPtr<nsIDocShellTreeItem> focusedTreeItem =
-        nsAccUtils::GetDocShellTreeItemFor(gLastFocusedNode);
+        nsCoreUtils::GetDocShellTreeItemFor(gLastFocusedNode);
       if (focusedTreeItem) {
         nsCOMPtr<nsIDocShellTreeItem> sameTypeRootOfFocus;
         focusedTreeItem->GetSameTypeRootTreeItem(getter_AddRefs(sameTypeRootOfFocus));
         if (sameTypeRoot == sameTypeRootOfFocus) {
           nsCOMPtr<nsIAccessibleStateChangeEvent> accEvent =
             new nsAccStateChangeEvent(this, nsIAccessibleStates::STATE_BUSY, PR_FALSE, PR_FALSE);
           FireAccessibleEvent(accEvent);
           FireAnchorJumpEvent();
@@ -1475,17 +1475,17 @@ nsDocAccessible::CreateTextChangeEventFo
       return nsnull; // No descendant content that represents any text in the hypertext parent
     }
     nsCOMPtr<nsIAccessible> child = changeAccessible;
     while (PR_TRUE) {
       nsCOMPtr<nsIAccessNode> childAccessNode =
         do_QueryInterface(changeAccessible);
       nsCOMPtr<nsIDOMNode> childNode;
       childAccessNode->GetDOMNode(getter_AddRefs(childNode));
-      if (!nsAccUtils::IsAncestorOf(aChangeNode, childNode)) {
+      if (!nsCoreUtils::IsAncestorOf(aChangeNode, childNode)) {
         break;  // We only want accessibles with DOM nodes as children of this node
       }
       length += TextLength(child);
       child->GetNextSibling(getter_AddRefs(changeAccessible));
       if (!changeAccessible) {
         break;
       }
       child.swap(changeAccessible);
diff -r 4b060ed856e0 accessible/src/base/nsRootAccessible.cpp
--- a/accessible/src/base/nsRootAccessible.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/accessible/src/base/nsRootAccessible.cpp	Thu Oct 16 21:24:47 2008 -0500
@@ -130,17 +130,17 @@ nsRootAccessible::GetName(nsAString& aNa
   if (mRoleMapEntry) {
     nsAccessible::GetName(aName);
     if (!aName.IsEmpty()) {
       return NS_OK;
     }
   }
 
   nsCOMPtr<nsIDocShellTreeItem> docShellAsItem =
-    nsAccUtils::GetDocShellTreeItemFor(mDOMNode);
+    nsCoreUtils::GetDocShellTreeItemFor(mDOMNode);
   NS_ENSURE_TRUE(docShellAsItem, NS_ERROR_FAILURE);
 
   nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
   docShellAsItem->GetTreeOwner(getter_AddRefs(treeOwner));
 
   nsCOMPtr<nsIBaseWindow> baseWindow(do_QueryInterface(treeOwner));
   if (baseWindow) {
     nsXPIDLString title;
@@ -190,17 +190,17 @@ NS_IMETHODIMP nsRootAccessible::GetRole(
 
 #ifdef MOZ_XUL
 PRUint32 nsRootAccessible::GetChromeFlags()
 {
   // Return the flag set for the top level window as defined 
   // by nsIWebBrowserChrome::CHROME_WINDOW_[FLAGNAME]
   // Not simple: nsIXULWindow is not just a QI from nsIDOMWindow
   nsCOMPtr<nsIDocShellTreeItem> treeItem =
-    nsAccUtils::GetDocShellTreeItemFor(mDOMNode);
+    nsCoreUtils::GetDocShellTreeItemFor(mDOMNode);
   NS_ENSURE_TRUE(treeItem, 0);
   nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
   treeItem->GetTreeOwner(getter_AddRefs(treeOwner));
   NS_ENSURE_TRUE(treeOwner, 0);
   nsCOMPtr<nsIXULWindow> xulWin(do_GetInterface(treeOwner));
   if (!xulWin) {
     return 0;
   }
@@ -381,17 +381,17 @@ void nsRootAccessible::TryFireEarlyLoadE
 
   // Note, we don't fire any page load finished events for chrome or for
   // frame/iframe page loads during the initial complete page load -- that page
   // load event for the entire content pane needs to stand alone.
 
   // This also works for firing events for error pages
 
   nsCOMPtr<nsIDocShellTreeItem> treeItem =
-    nsAccUtils::GetDocShellTreeItemFor(aDocNode);
+    nsCoreUtils::GetDocShellTreeItemFor(aDocNode);
   NS_ASSERTION(treeItem, "No docshelltreeitem for aDocNode");
   if (!treeItem) {
     return;
   }
   PRInt32 itemType;
   treeItem->GetItemType(&itemType);
   if (itemType != nsIDocShellTreeItem::typeContent) {
     return;
@@ -493,22 +493,24 @@ PRBool nsRootAccessible::FireAccessibleF
   gLastFocusedAccessiblesState = State(finalFocusAccessible);
   PRUint32 role = Role(finalFocusAccessible);
   if (role == nsIAccessibleRole::ROLE_MENUITEM) {
     if (!mCurrentARIAMenubar) {  // Entering menus
       PRUint32 naturalRole; // The natural role is the role that this type of element normally has
       finalFocusAccessible->GetRole(&naturalRole);
       if (role != naturalRole) { // Must be a DHTML menuitem
         nsCOMPtr<nsIAccessible> menuBarAccessible =
-          nsAccUtils::GetAncestorWithRole(finalFocusAccessible, nsIAccessibleRole::ROLE_MENUBAR);
+          nsAccUtils::GetAncestorWithRole(finalFocusAccessible,
+                                          nsIAccessibleRole::ROLE_MENUBAR);
         nsCOMPtr<nsIAccessNode> menuBarAccessNode = do_QueryInterface(menuBarAccessible);
         if (menuBarAccessNode) {
           menuBarAccessNode->GetDOMNode(getter_AddRefs(mCurrentARIAMenubar));
           if (mCurrentARIAMenubar) {
-            nsAccUtils::FireAccEvent(nsIAccessibleEvent::EVENT_MENU_START, menuBarAccessible);
+            nsAccUtils::FireAccEvent(nsIAccessibleEvent::EVENT_MENU_START,
+                                     menuBarAccessible);
           }
         }
       }
     }
   }
   else if (mCurrentARIAMenubar) {
     nsCOMPtr<nsIAccessibleEvent> menuEndEvent =
       new nsAccEvent(nsIAccessibleEvent::EVENT_MENU_END, mCurrentARIAMenubar,
@@ -648,17 +650,17 @@ nsresult nsRootAccessible::HandleEventWi
   if (eventType.EqualsLiteral("popuphiding")) {
     // If accessible focus was on or inside popup that closes,
     // then restore it to true current focus.
     // This is the case when we've been getting DOMMenuItemActive events
     // inside of a combo box that closes. The real focus is on the combo box.
     // It's also the case when a popup gets focus in ATK -- when it closes
     // we need to fire an event to restore focus to where it was
     if (!gLastFocusedNode ||
-        !nsAccUtils::IsAncestorOf(aTargetNode, gLastFocusedNode)) {
+        !nsCoreUtils::IsAncestorOf(aTargetNode, gLastFocusedNode)) {
       return NS_OK;  // And was not focused on an item inside the popup
     }
     // Focus was on or inside of a popup that's being hidden
     FireCurrentFocusEvent();
   }
 
   nsCOMPtr<nsIAccessible> accessible;
   accService->GetAccessibleInShell(aTargetNode, eventShell,
@@ -907,29 +909,32 @@ nsresult nsRootAccessible::HandleEventWi
     }
     if (fireFocus) {
       nsAccEvent::PrepareForEvent(aTargetNode, PR_TRUE);  // Always asynch, always from user input
       FireAccessibleFocusEvent(accessible, aTargetNode, aEvent, PR_TRUE, PR_TRUE);
     }
   }
   else if (eventType.EqualsLiteral("DOMMenuBarActive")) {  // Always asynch, always from user input
     nsAccEvent::PrepareForEvent(aTargetNode, PR_TRUE);
-    nsAccUtils::FireAccEvent(nsIAccessibleEvent::EVENT_MENU_START, accessible, PR_TRUE);
+    nsAccUtils::FireAccEvent(nsIAccessibleEvent::EVENT_MENU_START,
+                             accessible, PR_TRUE);
   }
   else if (eventType.EqualsLiteral("DOMMenuBarInactive")) {  // Always asynch, always from user input
     nsAccEvent::PrepareForEvent(aTargetNode, PR_TRUE);
-    nsAccUtils::FireAccEvent(nsIAccessibleEvent::EVENT_MENU_END, accessible, PR_TRUE);
+    nsAccUtils::FireAccEvent(nsIAccessibleEvent::EVENT_MENU_END,
+                             accessible, PR_TRUE);
     FireCurrentFocusEvent();
   }
   else if (eventType.EqualsLiteral("ValueChange")) {
     FireDelayedToolkitEvent(nsIAccessibleEvent::EVENT_VALUE_CHANGE, aTargetNode, nsAccEvent::eRemoveDupes);
   }
 #ifdef DEBUG
   else if (eventType.EqualsLiteral("mouseover")) {
-    nsAccUtils::FireAccEvent(nsIAccessibleEvent::EVENT_DRAGDROP_START, accessible);
+    nsAccUtils::FireAccEvent(nsIAccessibleEvent::EVENT_DRAGDROP_START,
+                             accessible);
   }
 #endif
   return NS_OK;
 }
 
 void nsRootAccessible::GetTargetNode(nsIDOMEvent *aEvent, nsIDOMNode **aTargetNode)
 {
   *aTargetNode = nsnull;
@@ -1052,17 +1057,17 @@ NS_IMETHODIMP nsRootAccessible::GetAcces
 {
   *aRelated = nsnull;
 
   if (!mDOMNode || aRelationType != nsIAccessibleRelation::RELATION_EMBEDS) {
     return nsDocAccessibleWrap::GetAccessibleRelated(aRelationType, aRelated);
   }
 
   nsCOMPtr<nsIDocShellTreeItem> treeItem =
-    nsAccUtils::GetDocShellTreeItemFor(mDOMNode);
+    nsCoreUtils::GetDocShellTreeItemFor(mDOMNode);
   nsCOMPtr<nsIDocShellTreeItem> contentTreeItem = GetContentDocShell(treeItem);
   // there may be no content area, so we need a null check
   if (contentTreeItem) {
     nsCOMPtr<nsIAccessibleDocument> accDoc =
       GetDocAccessibleFor(contentTreeItem, PR_TRUE);
     NS_ASSERTION(accDoc, "No EMBEDS document");
     if (accDoc) {
       accDoc->QueryInterface(NS_GET_IID(nsIAccessible), (void**)aRelated);
@@ -1073,17 +1078,17 @@ NS_IMETHODIMP nsRootAccessible::GetAcces
 
 NS_IMETHODIMP nsRootAccessible::FireDocLoadEvents(PRUint32 aEventType)
 {
   if (!mDocument || !mWeakShell) {
     return NS_OK;  // Document has been shut down
   }
 
   nsCOMPtr<nsIDocShellTreeItem> docShellTreeItem =
-    nsAccUtils::GetDocShellTreeItemFor(mDOMNode);
+    nsCoreUtils::GetDocShellTreeItemFor(mDOMNode);
   NS_ASSERTION(docShellTreeItem, "No doc shell tree item for document");
   NS_ENSURE_TRUE(docShellTreeItem, NS_ERROR_FAILURE);
   PRInt32 contentType;
   docShellTreeItem->GetItemType(&contentType);
   if (contentType == nsIDocShellTreeItem::typeContent) {
     return nsDocAccessibleWrap::FireDocLoadEvents(aEventType); // Content might need to fire event
   }
 
diff -r 4b060ed856e0 accessible/src/base/nsTextUtils.cpp
--- a/accessible/src/base/nsTextUtils.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/accessible/src/base/nsTextUtils.cpp	Thu Oct 16 21:24:47 2008 -0500
@@ -34,30 +34,30 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsTextUtils.h"
 
 #include "nsAccessNode.h"
-#include "nsAccessibilityUtils.h"
+#include "nsCoreUtils.h"
 
 ////////////////////////////////////////////////////////////////////////////////
 // nsLangTextAttr
 
 PRBool
 nsLangTextAttr::Equal(nsIDOMElement *aElm)
 {
   nsCOMPtr<nsIContent> content(do_QueryInterface(aElm));
   if (!content)
     return PR_FALSE;
 
   nsAutoString lang;
-  nsAccUtils::GetLanguageFor(content, mRootContent, lang);
+  nsCoreUtils::GetLanguageFor(content, mRootContent, lang);
 
   return lang == mLang;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // nsCSSTextAttr
 
 /**
@@ -186,17 +186,17 @@ nsBackgroundTextAttr::nsBackgroundTextAt
                                            nsIFrame *aRootFrame) :
   mFrame(aFrame), mRootFrame(aRootFrame)
 {
 }
 
 PRBool
 nsBackgroundTextAttr::Equal(nsIDOMElement *aElm)
 {
-  nsIFrame *frame = nsAccUtils::GetFrameFor(aElm);
+  nsIFrame *frame = nsCoreUtils::GetFrameFor(aElm);
   if (!frame)
     return PR_FALSE;
 
   return GetColor(mFrame) == GetColor(frame);    
 }
 
 PRBool
 nsBackgroundTextAttr::Get(nsAString& aValue)
diff -r 4b060ed856e0 accessible/src/html/nsHTMLLinkAccessible.cpp
--- a/accessible/src/html/nsHTMLLinkAccessible.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/accessible/src/html/nsHTMLLinkAccessible.cpp	Thu Oct 16 21:24:47 2008 -0500
@@ -105,18 +105,18 @@ nsHTMLLinkAccessible::GetState(PRUint32 
   NS_ENSURE_STATE(link);
 
   nsLinkState linkState;
   link->GetLinkState(linkState);
   if (linkState == eLinkState_NotLink || linkState == eLinkState_Unknown) {
     // This is a either named anchor (a link with also a name attribute) or
     // it doesn't have any attributes. Check if 'click' event handler is
     // registered, otherwise bail out.
-    PRBool isOnclick = nsAccUtils::HasListener(content,
-                                               NS_LITERAL_STRING("click"));
+    PRBool isOnclick = nsCoreUtils::HasListener(content,
+                                                NS_LITERAL_STRING("click"));
     if (!isOnclick)
       return NS_OK;
   }
 
   *aState |= nsIAccessibleStates::STATE_LINKED;
 
   if (linkState == eLinkState_Visited)
     *aState |= nsIAccessibleStates::STATE_TRAVERSED;
diff -r 4b060ed856e0 accessible/src/html/nsHyperTextAccessible.cpp
--- a/accessible/src/html/nsHyperTextAccessible.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/accessible/src/html/nsHyperTextAccessible.cpp	Thu Oct 16 21:24:47 2008 -0500
@@ -1196,27 +1196,27 @@ nsHyperTextAccessible::GetDefaultTextAtt
     do_CreateInstance(NS_PERSISTENTPROPERTIES_CONTRACTID);
   NS_ENSURE_TRUE(attributes, NS_ERROR_OUT_OF_MEMORY);
 
   NS_ADDREF(*aAttributes = attributes);
 
   if (!mDOMNode)
     return NS_ERROR_FAILURE;
 
-  nsCOMPtr<nsIDOMElement> element = nsAccUtils::GetDOMElementFor(mDOMNode);
+  nsCOMPtr<nsIDOMElement> element = nsCoreUtils::GetDOMElementFor(mDOMNode);
 
   nsCSSTextAttr textAttr(PR_TRUE, element, nsnull);
   while (textAttr.Iterate()) {
     nsCAutoString name;
     nsAutoString value, oldValue;
     if (textAttr.Get(name, value))
       attributes->SetStringProperty(name, value, oldValue);
   }
 
-  nsIFrame *sourceFrame = nsAccUtils::GetFrameFor(element);
+  nsIFrame *sourceFrame = nsCoreUtils::GetFrameFor(element);
   if (sourceFrame) {
     nsBackgroundTextAttr backgroundTextAttr(sourceFrame, nsnull);
 
     nsAutoString value;
     if (backgroundTextAttr.Get(value)) {
       nsAccUtils::SetAccAttr(attributes,
                              nsAccessibilityAtoms::backgroundColor, value);
     }
@@ -1567,17 +1567,17 @@ nsHyperTextAccessible::GetAssociatedEdit
         return ancestorTextAccessible->GetAssociatedEditor(aEditor);
       }
       current = ancestor;
     }
     return NS_OK;
   }
 
   nsCOMPtr<nsIDocShellTreeItem> docShellTreeItem =
-    nsAccUtils::GetDocShellTreeItemFor(mDOMNode);
+    nsCoreUtils::GetDocShellTreeItemFor(mDOMNode);
   nsCOMPtr<nsIEditingSession> editingSession(do_GetInterface(docShellTreeItem));
   if (!editingSession)
     return NS_OK; // No editing session interface
 
   nsCOMPtr<nsIPresShell> shell = GetPresShell();
   NS_ENSURE_TRUE(shell, NS_ERROR_FAILURE);
 
   nsCOMPtr<nsIDocument> doc = shell->GetDocument();
@@ -1662,17 +1662,17 @@ PRInt32 nsHyperTextAccessible::GetCaretL
   NS_ENSURE_TRUE(privateSelection, -1);
   nsCOMPtr<nsFrameSelection> frameSelection;
   privateSelection->GetFrameSelection(getter_AddRefs(frameSelection));
   NS_ENSURE_TRUE(frameSelection, -1);
 
   nsCOMPtr<nsIDOMNode> caretNode;
   domSel->GetFocusNode(getter_AddRefs(caretNode));
   nsCOMPtr<nsIContent> caretContent = do_QueryInterface(caretNode);
-  if (!caretContent || !nsAccUtils::IsAncestorOf(mDOMNode, caretNode)) {
+  if (!caretContent || !nsCoreUtils::IsAncestorOf(mDOMNode, caretNode)) {
     return -1;
   }
 
   PRInt32 caretOffset, returnOffsetUnused;
   domSel->GetFocusOffset(&caretOffset);
   nsFrameSelection::HINT hint = frameSelection->GetHint();
   nsIFrame *caretFrame = frameSelection->GetFrameForNodeOffset(caretContent, caretOffset,
                                                                hint, &returnOffsetUnused);
@@ -1982,18 +1982,18 @@ nsHyperTextAccessible::ScrollSubstringTo
 
   nsresult rv = HypertextOffsetsToDOMRange(aStartIndex, aEndIndex,
                                            getter_AddRefs(startNode),
                                            &startOffset,
                                            getter_AddRefs(endNode),
                                            &endOffset);
   NS_ENSURE_SUCCESS(rv, rv);
 
-  return nsAccUtils::ScrollSubstringTo(GetFrame(), startNode, startOffset,
-                                       endNode, endOffset, aScrollType);
+  return nsCoreUtils::ScrollSubstringTo(GetFrame(), startNode, startOffset,
+                                        endNode, endOffset, aScrollType);
 }
 
 // void nsIAccessibleText::
 //   scrollSubstringToPoint(in long startIndex, in long endIndex,
 //                          in unsigned long coordinateType,
 //                          in long x, in long y);
 NS_IMETHODIMP
 nsHyperTextAccessible::ScrollSubstringToPoint(PRInt32 aStartIndex,
@@ -2023,40 +2023,40 @@ nsHyperTextAccessible::ScrollSubstringTo
   PRBool initialScrolled = PR_FALSE;
   nsIFrame *parentFrame = frame;
   while ((parentFrame = parentFrame->GetParent())) {
     nsIScrollableFrame *scrollableFrame = nsnull;
     CallQueryInterface(parentFrame, &scrollableFrame);
     if (scrollableFrame) {
       if (!initialScrolled) {
         // Scroll substring to the given point. Turn the point into percents
-        // relative scrollable area to use nsAccUtils::ScrollSubstringTo.
+        // relative scrollable area to use nsCoreUtils::ScrollSubstringTo.
         nsIntRect frameRect = parentFrame->GetScreenRectExternal();
         PRInt32 devOffsetX = coords.x - frameRect.x;
         PRInt32 devOffsetY = coords.y - frameRect.y;
 
         nsPoint offsetPoint(presContext->DevPixelsToAppUnits(devOffsetX),
                             presContext->DevPixelsToAppUnits(devOffsetY));
 
         nsSize size(parentFrame->GetSize());
         PRInt16 hPercent = offsetPoint.x * 100 / size.width;
         PRInt16 vPercent = offsetPoint.y * 100 / size.height;
 
-        rv = nsAccUtils::ScrollSubstringTo(GetFrame(), startNode, startOffset,
-                                           endNode, endOffset,
-                                           vPercent, hPercent);
+        rv = nsCoreUtils::ScrollSubstringTo(GetFrame(), startNode, startOffset,
+                                            endNode, endOffset,
+                                            vPercent, hPercent);
         NS_ENSURE_SUCCESS(rv, rv);
 
         initialScrolled = PR_TRUE;
       } else {
         // Substring was scrolled to the given point already inside its closest
         // scrollable area. If there are nested scrollable areas then make
         // sure we scroll lower areas to the given point inside currently
         // traversed scrollable area.
-        nsAccUtils::ScrollFrameToPoint(parentFrame, frame, coords);
+        nsCoreUtils::ScrollFrameToPoint(parentFrame, frame, coords);
       }
     }
     frame = parentFrame;
   }
 
   return NS_OK;
 }
 
@@ -2280,23 +2280,23 @@ nsHyperTextAccessible::GetSpellTextAttri
 // nsHyperTextAccessible
 nsresult
 nsHyperTextAccessible::GetLangTextAttributes(PRBool aIncludeDefAttrs,
                                              nsIDOMNode *aSourceNode,
                                              PRInt32 *aStartHTOffset,
                                              PRInt32 *aEndHTOffset,
                                              nsIPersistentProperties *aAttributes)
 {
-  nsCOMPtr<nsIDOMElement> sourceElm(nsAccUtils::GetDOMElementFor(aSourceNode));
+  nsCOMPtr<nsIDOMElement> sourceElm(nsCoreUtils::GetDOMElementFor(aSourceNode));
 
   nsCOMPtr<nsIContent> content(do_QueryInterface(sourceElm));
   nsCOMPtr<nsIContent> rootContent(do_QueryInterface(mDOMNode));
 
   nsAutoString lang;
-  nsAccUtils::GetLanguageFor(content, rootContent, lang);
+  nsCoreUtils::GetLanguageFor(content, rootContent, lang);
 
   nsAutoString rootLang;
   nsresult rv = GetLanguage(rootLang);
   NS_ENSURE_SUCCESS(rv, rv);
 
   if (aAttributes) {
     // Expose 'language' text attribute if the DOM 'lang' attribute is
     // presented and it's different from the 'lang' attribute on the root
@@ -2315,37 +2315,37 @@ nsHyperTextAccessible::GetLangTextAttrib
 // nsHyperTextAccessible
 nsresult
 nsHyperTextAccessible::GetCSSTextAttributes(PRBool aIncludeDefAttrs,
                                             nsIDOMNode *aSourceNode,
                                             PRInt32 *aStartHTOffset,
                                             PRInt32 *aEndHTOffset,
                                             nsIPersistentProperties *aAttributes)
 {
-  nsCOMPtr<nsIDOMElement> sourceElm(nsAccUtils::GetDOMElementFor(aSourceNode));
-  nsCOMPtr<nsIDOMElement> rootElm(nsAccUtils::GetDOMElementFor(mDOMNode));
+  nsCOMPtr<nsIDOMElement> sourceElm(nsCoreUtils::GetDOMElementFor(aSourceNode));
+  nsCOMPtr<nsIDOMElement> rootElm(nsCoreUtils::GetDOMElementFor(mDOMNode));
 
   nsCSSTextAttr textAttr(aIncludeDefAttrs, sourceElm, rootElm);
   while (textAttr.Iterate()) {
     nsCAutoString name;
     nsAutoString value, oldValue;
     if (aAttributes && textAttr.Get(name, value))
       aAttributes->SetStringProperty(name, value, oldValue);
 
     nsresult rv = GetRangeForTextAttr(aSourceNode, &textAttr,
                                       aStartHTOffset, aEndHTOffset);
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
-  nsIFrame *sourceFrame = nsAccUtils::GetFrameFor(sourceElm);
+  nsIFrame *sourceFrame = nsCoreUtils::GetFrameFor(sourceElm);
   if (sourceFrame) {
     nsIFrame *rootFrame = nsnull;
 
     if (!aIncludeDefAttrs)
-      rootFrame = nsAccUtils::GetFrameFor(rootElm);
+      rootFrame = nsCoreUtils::GetFrameFor(rootElm);
 
     nsBackgroundTextAttr backgroundTextAttr(sourceFrame, rootFrame);
     nsAutoString value;
     if (backgroundTextAttr.Get(value)) {
       nsAccUtils::SetAccAttr(aAttributes,
                              nsAccessibilityAtoms::backgroundColor, value);
     }
 
@@ -2359,33 +2359,33 @@ nsHyperTextAccessible::GetCSSTextAttribu
 
 // nsHyperTextAccessible
 nsresult
 nsHyperTextAccessible::GetRangeForTextAttr(nsIDOMNode *aNode,
                                            nsTextAttr *aComparer,
                                            PRInt32 *aStartHTOffset,
                                            PRInt32 *aEndHTOffset)
 {
-  nsCOMPtr<nsIDOMElement> rootElm(nsAccUtils::GetDOMElementFor(mDOMNode));
+  nsCOMPtr<nsIDOMElement> rootElm(nsCoreUtils::GetDOMElementFor(mDOMNode));
   NS_ENSURE_STATE(rootElm);
 
   nsCOMPtr<nsIDOMNode> tmpNode(aNode);
   nsCOMPtr<nsIDOMNode> currNode(aNode);
 
   // Navigate backwards and forwards from current node to the root node to
   // calculate range bounds for the text attribute. Navigation sequence is the
   // following:
   // 1. Navigate through the siblings.
   // 2. If the traversed sibling has children then navigate from its leaf child
   //    to it through whole tree of the traversed sibling.
   // 3. Get the parent and cycle algorithm until the root node.
 
   // Navigate backwards (find the start offset).
   while (currNode && currNode != rootElm) {
-    nsCOMPtr<nsIDOMElement> currElm(nsAccUtils::GetDOMElementFor(currNode));
+    nsCOMPtr<nsIDOMElement> currElm(nsCoreUtils::GetDOMElementFor(currNode));
     NS_ENSURE_STATE(currElm);
 
     if (currNode != aNode && !aComparer->Equal(currElm)) {
       PRInt32 startHTOffset = 0;
       nsCOMPtr<nsIAccessible> startAcc;
       nsresult rv = DOMPointToHypertextOffset(tmpNode, -1, &startHTOffset,
                                               getter_AddRefs(startAcc));
       NS_ENSURE_SUCCESS(rv, rv);
@@ -2409,17 +2409,17 @@ nsHyperTextAccessible::GetRangeForTextAt
     currNode->GetParentNode(getter_AddRefs(tmpNode));
     currNode.swap(tmpNode);
   }
 
   // Navigate forwards (find the end offset).
   PRBool moveIntoSubtree = PR_TRUE;
   currNode = aNode;
   while (currNode && currNode != rootElm) {
-    nsCOMPtr<nsIDOMElement> currElm(nsAccUtils::GetDOMElementFor(currNode));
+    nsCOMPtr<nsIDOMElement> currElm(nsCoreUtils::GetDOMElementFor(currNode));
     NS_ENSURE_STATE(currElm);
 
     // Stop new end offset searching if the given text attribute changes its
     // value.
     if (!aComparer->Equal(currElm)) {
       PRInt32 endHTOffset = 0;
       nsresult rv = DOMPointToHypertextOffset(currNode, -1, &endHTOffset);
       NS_ENSURE_SUCCESS(rv, rv);
@@ -2455,17 +2455,17 @@ PRBool
 PRBool
 nsHyperTextAccessible::FindEndOffsetInSubtree(nsIDOMNode *aCurrNode,
                                               nsTextAttr *aComparer,
                                               PRInt32 *aHTOffset)
 {
   if (!aCurrNode)
     return PR_FALSE;
 
-  nsCOMPtr<nsIDOMElement> currElm(nsAccUtils::GetDOMElementFor(aCurrNode));
+  nsCOMPtr<nsIDOMElement> currElm(nsCoreUtils::GetDOMElementFor(aCurrNode));
   NS_ENSURE_STATE(currElm);
 
   // If the given text attribute (pointed by nsTextAttr object) changes its
   // value on the traversed element then fit the end of range.
   if (!aComparer->Equal(currElm)) {
     PRInt32 endHTOffset = 0;
     nsresult rv = DOMPointToHypertextOffset(aCurrNode, -1, &endHTOffset);
     NS_ENSURE_SUCCESS(rv, rv);
@@ -2506,17 +2506,17 @@ nsHyperTextAccessible::FindStartOffsetIn
   // Find the closest element back to the traversed element.
   nsCOMPtr<nsIDOMNode> nextNode;
   aCurrNode->GetLastChild(getter_AddRefs(nextNode));
   if (nextNode) {
     if (FindStartOffsetInSubtree(nextNode, aPrevNode, aComparer, aHTOffset))
       return PR_TRUE;
   }
 
-  nsCOMPtr<nsIDOMElement> currElm(nsAccUtils::GetDOMElementFor(aCurrNode));
+  nsCOMPtr<nsIDOMElement> currElm(nsCoreUtils::GetDOMElementFor(aCurrNode));
   NS_ENSURE_STATE(currElm);
 
   // If the given text attribute (pointed by nsTextAttr object) changes its
   // value on the traversed element then fit the start of range.
   if (!aComparer->Equal(currElm)) {
     PRInt32 startHTOffset = 0;
     nsCOMPtr<nsIAccessible> startAcc;
     nsresult rv = DOMPointToHypertextOffset(aPrevNode, -1, &startHTOffset,
diff -r 4b060ed856e0 accessible/src/msaa/nsTextAccessibleWrap.cpp
--- a/accessible/src/msaa/nsTextAccessibleWrap.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/accessible/src/msaa/nsTextAccessibleWrap.cpp	Thu Oct 16 21:24:47 2008 -0500
@@ -167,19 +167,20 @@ __try {
 }
 
 
 STDMETHODIMP nsTextAccessibleWrap::scrollToSubstring(
     /* [in] */ unsigned int aStartIndex,
     /* [in] */ unsigned int aEndIndex)
 {
 __try {
-  nsresult rv = nsAccUtils::ScrollSubstringTo(GetFrame(), mDOMNode, aStartIndex,
-                                              mDOMNode, aEndIndex,
-                                              nsIAccessibleScrollType::SCROLL_TYPE_ANYWHERE);
+  nsresult rv =
+    nsCoreUtils::ScrollSubstringTo(GetFrame(), mDOMNode, aStartIndex,
+                                   mDOMNode, aEndIndex,
+                                   nsIAccessibleScrollType::SCROLL_TYPE_ANYWHERE);
   if (NS_FAILED(rv))
     return E_FAIL;
 } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
   return S_OK;
 }
 
 nsIFrame* nsTextAccessibleWrap::GetPointFromOffset(nsIFrame *aContainingFrame, 
                                                    PRInt32 aOffset, 
diff -r 4b060ed856e0 accessible/src/xul/nsXULMenuAccessible.cpp
--- a/accessible/src/xul/nsXULMenuAccessible.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/accessible/src/xul/nsXULMenuAccessible.cpp	Thu Oct 16 21:24:47 2008 -0500
@@ -414,17 +414,17 @@ nsXULMenuitemAccessible::GetKeyboardShor
 {
   aAccessKey.Truncate();
 
   static PRInt32 gMenuAccesskeyModifier = -1;  // magic value of -1 indicates unitialized state
 
   nsCOMPtr<nsIDOMElement> elt(do_QueryInterface(mDOMNode));
   if (elt) {
     nsAutoString accesskey;
-    // We do not use nsAccUtils::GetAccesskeyFor() because accesskeys for
+    // We do not use nsCoreUtils::GetAccesskeyFor() because accesskeys for
     // menu are't registered by nsIEventStateManager.
     elt->GetAttribute(NS_LITERAL_STRING("accesskey"), accesskey);
     if (accesskey.IsEmpty())
       return NS_OK;
 
     nsCOMPtr<nsIAccessible> parentAccessible(GetParent());
     if (parentAccessible) {
       PRUint32 role;
diff -r 4b060ed856e0 accessible/src/xul/nsXULTextAccessible.cpp
--- a/accessible/src/xul/nsXULTextAccessible.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/accessible/src/xul/nsXULTextAccessible.cpp	Thu Oct 16 21:24:47 2008 -0500
@@ -34,17 +34,18 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 // NOTE: alphabetically ordered
 #include "nsAccessibilityAtoms.h"
-#include "nsAccessibilityUtils.h"
+#include "nsCoreUtils.h"
+#include "nsAccUtils.h"
 #include "nsBaseWidgetAccessible.h"
 #include "nsIDOMXULDescriptionElement.h"
 #include "nsINameSpaceManager.h"
 #include "nsString.h"
 #include "nsXULTextAccessible.h"
 #include "nsNetUtil.h"
 
 /**
diff -r 4b060ed856e0 browser/themes/pinstripe/browser/browser.css
--- a/browser/themes/pinstripe/browser/browser.css	Tue Oct 14 17:12:28 2008 -0700
+++ b/browser/themes/pinstripe/browser/browser.css	Thu Oct 16 21:24:48 2008 -0500
@@ -1392,21 +1392,23 @@ richlistitem[selected="true"][current="t
 }
 
 #editBookmarkPanel > #editBookmarkPanelContent > #editBookmarkPanelGrid > rows > row > label {
   text-align: right;
 }
 
 /* ----- SIDEBAR ELEMENTS ----- */
 
-#sidebar,
+#sidebar { 
+  background-color: #d4dde5;
+}
+
 sidebarheader { 
   background-color: #d4dde5;
   padding: 2px;
-  text-transform: uppercase;
 }
 
 #sidebar-box {
   -moz-appearance: dialog;
   -moz-appearance: none;
 }
 
 #sidebar-splitter {
diff -r 4b060ed856e0 browser/themes/pinstripe/browser/jar.mn
--- a/browser/themes/pinstripe/browser/jar.mn	Tue Oct 14 17:12:28 2008 -0700
+++ b/browser/themes/pinstripe/browser/jar.mn	Thu Oct 16 21:24:48 2008 -0500
@@ -111,29 +111,25 @@ classic.jar:
   skin/classic/browser/preferences/alwaysAsk.png            (preferences/alwaysAsk.png)
   skin/classic/browser/preferences/application.png          (preferences/application.png)
   skin/classic/browser/preferences/Options.png              (preferences/Options.png)
   skin/classic/browser/preferences/saveFile.png             (preferences/saveFile.png)
   skin/classic/browser/preferences/preferences.css          (preferences/preferences.css)
   skin/classic/browser/preferences/applications.css         (preferences/applications.css)
   skin/classic/browser/tabbrowser/alltabs-box-bkgnd.png                  (tabbrowser/alltabs-box-bkgnd.png)
   skin/classic/browser/tabbrowser/alltabs-box-bkgnd-icon.png             (tabbrowser/alltabs-box-bkgnd-icon.png)
-  skin/classic/browser/tabbrowser/alltabs-box-overflow-bkgnd.png         (tabbrowser/alltabs-box-overflow-bkgnd.png)
   skin/classic/browser/tabbrowser/alltabs-box-overflow-bkgnd-animate.png (tabbrowser/alltabs-box-overflow-bkgnd-animate.png)
   skin/classic/browser/tabbrowser/newtab.png                             (tabbrowser/newtab.png)
   skin/classic/browser/tabbrowser/tab-arrow-start.png                    (tabbrowser/tab-arrow-start.png)
   skin/classic/browser/tabbrowser/tab-arrow-start-bkgnd.png              (tabbrowser/tab-arrow-start-bkgnd.png)
-  skin/classic/browser/tabbrowser/tab-arrow-start-bkgnd-animate.png      (tabbrowser/tab-arrow-start-bkgnd-animate.png)
   skin/classic/browser/tabbrowser/tab-arrow-end.png                      (tabbrowser/tab-arrow-end.png)
   skin/classic/browser/tabbrowser/tab-arrow-end-bkgnd.png                (tabbrowser/tab-arrow-end-bkgnd.png)
-  skin/classic/browser/tabbrowser/tab-arrow-end-bkgnd-animate.png        (tabbrowser/tab-arrow-end-bkgnd-animate.png)
   skin/classic/browser/tabbrowser/tabbrowser-tabs-bkgnd.png              (tabbrowser/tabbrowser-tabs-bkgnd.png)
   skin/classic/browser/tabbrowser/tabDragIndicator.png                   (tabbrowser/tabDragIndicator.png)
   skin/classic/browser/tabbrowser/tab-bkgnd.png                          (tabbrowser/tab-bkgnd.png)
-  skin/classic/browser/tabbrowser/tabs-bottom-bg.png                     (tabbrowser/tabs-bottom-bg.png)
   skin/classic/browser/urlbar/endcap.png                                 (urlbar/endcap.png)
   skin/classic/browser/urlbar/endcap-rtl.png                             (urlbar/endcap-rtl.png)
   skin/classic/browser/urlbar/endcap-focused.png                         (urlbar/endcap-focused.png)
   skin/classic/browser/urlbar/endcap-focused-rtl.png                     (urlbar/endcap-focused-rtl.png)
   skin/classic/browser/urlbar/startcap.png                               (urlbar/startcap.png)
   skin/classic/browser/urlbar/startcap-rtl.png                           (urlbar/startcap-rtl.png)
   skin/classic/browser/urlbar/startcap-focused.png                       (urlbar/startcap-focused.png)
   skin/classic/browser/urlbar/startcap-focused-rtl.png                   (urlbar/startcap-focused-rtl.png)
diff -r 4b060ed856e0 browser/themes/pinstripe/browser/tabbrowser/alltabs-box-overflow-bkgnd.png
Binary file browser/themes/pinstripe/browser/tabbrowser/alltabs-box-overflow-bkgnd.png has changed
diff -r 4b060ed856e0 browser/themes/pinstripe/browser/tabbrowser/tab-arrow-end-bkgnd-animate.png
Binary file browser/themes/pinstripe/browser/tabbrowser/tab-arrow-end-bkgnd-animate.png has changed
diff -r 4b060ed856e0 browser/themes/pinstripe/browser/tabbrowser/tab-arrow-start-bkgnd-animate.png
Binary file browser/themes/pinstripe/browser/tabbrowser/tab-arrow-start-bkgnd-animate.png has changed
diff -r 4b060ed856e0 browser/themes/pinstripe/browser/tabbrowser/tabs-bottom-bg.png
Binary file browser/themes/pinstripe/browser/tabbrowser/tabs-bottom-bg.png has changed
diff -r 4b060ed856e0 caps/src/nsScriptSecurityManager.cpp
--- a/caps/src/nsScriptSecurityManager.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/caps/src/nsScriptSecurityManager.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -1984,37 +1984,16 @@ nsScriptSecurityManager::GetCodebasePrin
     rv = CreateCodebasePrincipal(aURI, getter_AddRefs(principal));
     if (NS_FAILED(rv)) return rv;
 
     if (mPrincipals.Count() > 0)
     {
         //-- Check to see if we already have this principal.
         nsCOMPtr<nsIPrincipal> fromTable;
         mPrincipals.Get(principal, getter_AddRefs(fromTable));
-        if (!fromTable)
-        {
-            //-- Check to see if we have a more general principal
-
-            // XXXbz if only GetOrigin returned a URI!  Or better yet if the
-            // HashKey function on principals were smarter.  As it is, we can
-            // have cases where two principals will have different hashkeys but
-            // test equal via KeyEquals, which is absolutely silly.  That's
-            // what we're working around here.
-            nsXPIDLCString originUrl;
-            rv = principal->GetOrigin(getter_Copies(originUrl));
-            if (NS_FAILED(rv)) return rv;
-            nsCOMPtr<nsIURI> newURI;
-            rv = NS_NewURI(getter_AddRefs(newURI), originUrl, nsnull, sIOService);
-            if (NS_FAILED(rv)) return rv;
-            nsCOMPtr<nsIPrincipal> principal2;
-            rv = CreateCodebasePrincipal(newURI, getter_AddRefs(principal2));
-            if (NS_FAILED(rv)) return rv;
-            mPrincipals.Get(principal2, getter_AddRefs(fromTable));
-        }
-
         if (fromTable) {
             // We found an existing codebase principal.  But it might have a
             // generic codebase for this origin on it.  Install our particular
             // codebase.
             // XXXbz this is kinda similar to the code in
             // GetCertificatePrincipal, but just ever so slightly different.
             // Oh, well.
             nsXPIDLCString prefName;
diff -r 4b060ed856e0 chrome/src/nsChromeProtocolHandler.cpp
--- a/chrome/src/nsChromeProtocolHandler.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/chrome/src/nsChromeProtocolHandler.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -155,16 +155,17 @@ PRLogModuleInfo* nsCachedChromeChannel::
 PRLogModuleInfo* nsCachedChromeChannel::gLog;
 #endif
 
 NS_IMPL_ISUPPORTS3(nsCachedChromeChannel, nsIChannel, nsIRequest,
                    nsCachedChromeChannel)
 
 nsCachedChromeChannel::nsCachedChromeChannel(nsIURI* aURI)
     : mURI(aURI)
+    , mOriginalURI(aURI)
     , mLoadFlags(nsIRequest::LOAD_NORMAL)
     , mStatus(NS_OK)
 {
 #ifdef PR_LOGGING
     if (! gLog)
         gLog = PR_NewLogModule("nsCachedChromeChannel");
 #endif
 
@@ -176,24 +177,25 @@ nsCachedChromeChannel::~nsCachedChromeCh
 {
     LOG(("nsCachedChromeChannel[%p]: destroyed", this));
 }
 
 
 NS_IMETHODIMP
 nsCachedChromeChannel::GetOriginalURI(nsIURI* *aOriginalURI)
 {
-    *aOriginalURI = mOriginalURI ? mOriginalURI : mURI;
+    *aOriginalURI = mOriginalURI;
     NS_ADDREF(*aOriginalURI);
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCachedChromeChannel::SetOriginalURI(nsIURI* aOriginalURI)
 {
+    NS_ENSURE_ARG_POINTER(aOriginalURI);
     mOriginalURI = aOriginalURI;
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCachedChromeChannel::GetURI(nsIURI* *aURI)
 {
     *aURI = mURI;
diff -r 4b060ed856e0 content/base/public/nsContentUtils.h
--- a/content/base/public/nsContentUtils.h	Tue Oct 14 17:12:28 2008 -0700
+++ b/content/base/public/nsContentUtils.h	Thu Oct 16 21:24:48 2008 -0500
@@ -1184,22 +1184,22 @@ public:
   static nsIWidget* GetTopLevelWidget(nsIWidget* aWidget);
 
   /**
    * Return the localized ellipsis for UI.
    */
   static const nsDependentString GetLocalizedEllipsis();
 
   /**
-   * The routine GetNativeEvent is used to fill nsNativeKeyEvent
-   * nsNativeKeyEvent. It's also used in DOMEventToNativeKeyEvent.
+   * The routine GetNativeEvent is used to fill nsNativeKeyEvent.
+   * It's also used in DOMEventToNativeKeyEvent.
    * See bug 406407 for details.
    */
   static nsEvent* GetNativeEvent(nsIDOMEvent* aDOMEvent);
-  static PRBool DOMEventToNativeKeyEvent(nsIDOMEvent* aDOMEvent,
+  static PRBool DOMEventToNativeKeyEvent(nsIDOMKeyEvent* aKeyEvent,
                                          nsNativeKeyEvent* aNativeEvent,
                                          PRBool aGetCharCode);
 
   /**
    * Get the candidates for accelkeys for aDOMKeyEvent.
    *
    * @param aDOMKeyEvent [in] the key event for accelkey handling.
    * @param aCandidates [out] the candidate shortcut key combination list.
diff -r 4b060ed856e0 content/base/public/nsIContentIterator.h
--- a/content/base/public/nsIContentIterator.h	Tue Oct 14 17:12:28 2008 -0700
+++ b/content/base/public/nsIContentIterator.h	Thu Oct 16 21:24:48 2008 -0500
@@ -35,31 +35,31 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef __nsIContentIterator_h___
 #define __nsIContentIterator_h___
 
 #include "nsISupports.h"
 
-class nsIContent;
+class nsINode;
 class nsIDOMRange;
 
-#define NS_ICONTENTITERTOR_IID \
-{0xa6cf90e4, 0x15b3, 0x11d2,   \
-{0x93, 0x2e, 0x00, 0x80, 0x5f, 0x8a, 0xdd, 0x32} }
+#define NS_ICONTENTITERATOR_IID \
+{ 0x716a396c, 0xdc4e, 0x4d10, \
+  { 0xbd, 0x07, 0x27, 0xee, 0xae, 0x85, 0xe3, 0x86 } }
 
 class nsIContentIterator : public nsISupports
 {
 public:
-  NS_DECLARE_STATIC_IID_ACCESSOR(NS_ICONTENTITERTOR_IID)
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_ICONTENTITERATOR_IID)
 
   /* Initializes an iterator for the subtree rooted by the node aRoot
    */
-  virtual nsresult Init(nsIContent* aRoot) = 0;
+  virtual nsresult Init(nsINode* aRoot) = 0;
 
   /* Initializes an iterator for the subtree defined by the range aRange
    */
   virtual nsresult Init(nsIDOMRange* aRange) = 0;
 
   /** First will reset the list.
    */
   virtual void First() = 0;
@@ -74,25 +74,25 @@ public:
 
   /** Prev will decrement the list.
    */
   virtual void Prev() = 0;
 
   /** CurrentItem will return the current item, or null if the list is empty
    *  @return the current node
    */
-  virtual nsIContent *GetCurrentNode() = 0;
+  virtual nsINode *GetCurrentNode() = 0;
 
   /** return if the collection is at the end. that is the beginning following a call to Prev
    *  and it is the end of the list following a call to next
    *  @return if the iterator is done.
    */
   virtual PRBool IsDone() = 0;
 
   /** PositionAt will position the iterator to the supplied node
    */
-  virtual nsresult PositionAt(nsIContent* aCurNode) = 0;
+  virtual nsresult PositionAt(nsINode* aCurNode) = 0;
 };
 
-NS_DEFINE_STATIC_IID_ACCESSOR(nsIContentIterator, NS_ICONTENTITERTOR_IID)
+NS_DEFINE_STATIC_IID_ACCESSOR(nsIContentIterator, NS_ICONTENTITERATOR_IID)
 
 #endif // __nsIContentIterator_h___
 
diff -r 4b060ed856e0 content/base/public/nsISelectionController.idl
--- a/content/base/public/nsISelectionController.idl	Tue Oct 14 17:12:28 2008 -0700
+++ b/content/base/public/nsISelectionController.idl	Thu Oct 16 21:24:48 2008 -0500
@@ -46,17 +46,17 @@ typedef short SelectionType;
 typedef short SelectionType;
 typedef short SelectionRegion;
 %}
 
 interface nsIDOMNode;
 interface nsISelection;
 interface nsISelectionDisplay;
 
-[scriptable, uuid(29a6d846-e100-4933-ad7a-2e19d91eb692)]
+[scriptable, uuid(b5c3ffc4-f48a-4f25-86e1-4cf79db1bcbb)]
 interface nsISelectionController : nsISelectionDisplay
 {
    const short SELECTION_NONE=0;
    const short SELECTION_NORMAL=1;
    const short SELECTION_SPELLCHECK=2;
    const short SELECTION_IME_RAWINPUT=4;
    const short SELECTION_IME_SELECTEDRAWTEXT=8;
    const short SELECTION_IME_CONVERTEDTEXT=16;
@@ -160,16 +160,23 @@ interface nsISelectionController : nsISe
    *  this will also have the effect of collapsing the selection if the aExtend = PR_FALSE
    *  the "point" of selection that is extended is considered the "focus" point. 
    *  or the last point adjusted by the selection.
    *  @param aForward forward or backward if PR_FALSE
    *  @param aExtend  should it collapse the selection of extend it?
    */
     void characterMove(in boolean forward, in boolean extend);
 
+   /**
+    * CharacterExtendForDelete will extend the selection one character cell
+    * forward in the document.
+    * this method is used internally for handling del key.
+    */
+    [noscript] void characterExtendForDelete();
+
    /** WordMove will move the selection one word forward/backward in the document.
    *  this will also have the effect of collapsing the selection if the aExtend = PR_FALSE
    *  the "point" of selection that is extended is considered the "focus" point. 
    *  or the last point adjusted by the selection.
    *  @param aForward forward or backward if PR_FALSE
    *  @param aExtend  should it collapse the selection of extend it?
    */
 
diff -r 4b060ed856e0 content/base/src/nsContentIterator.cpp
--- a/content/base/src/nsContentIterator.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/content/base/src/nsContentIterator.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -60,57 +60,57 @@ static NS_DEFINE_IID(kISupportsIID, NS_I
 //
 static inline PRBool
 NodeHasChildren(nsINode *aNode)
 {
   return aNode->GetChildCount() > 0;
 }
 
 ///////////////////////////////////////////////////////////////////////////
-// ContentToParentOffset: returns the content node's parent and offset.
+// NodeToParentOffset: returns the node's parent and offset.
 //
 
-static nsIContent*
-ContentToParentOffset(nsIContent *aContent, PRInt32 *aOffset)
+static nsINode*
+NodeToParentOffset(nsINode *aNode, PRInt32 *aOffset)
 {
   *aOffset  = 0;
 
-  nsIContent* parent = aContent->GetParent();
+  nsINode* parent = aNode->GetNodeParent();
 
   if (parent) {
-    *aOffset = parent->IndexOf(aContent);
+    *aOffset = parent->IndexOf(aNode);
   }
   
   return parent;
 }
 
 ///////////////////////////////////////////////////////////////////////////
-// ContentIsInTraversalRange: returns true if content is visited during
+// NodeIsInTraversalRange: returns true if content is visited during
 // the traversal of the range in the specified mode.
 //
 static PRBool
-ContentIsInTraversalRange(nsIContent *aContent, PRBool aIsPreMode,
-                          nsINode *aStartNode, PRInt32 aStartOffset,
-                          nsINode *aEndNode, PRInt32 aEndOffset)
+NodeIsInTraversalRange(nsINode *aNode, PRBool aIsPreMode,
+                       nsINode *aStartNode, PRInt32 aStartOffset,
+                       nsINode *aEndNode, PRInt32 aEndOffset)
 {
-  if (!aStartNode || !aEndNode || !aContent)
+  if (!aStartNode || !aEndNode || !aNode)
     return PR_FALSE;
 
   // If a chardata node contains an end point of the traversal range,
   // it is always in the traversal range.
-  if (aContent->IsNodeOfType(nsINode::eDATA_NODE) &&
-      (aContent == aStartNode || aContent == aEndNode)) {
+  if (aNode->IsNodeOfType(nsINode::eDATA_NODE) &&
+      (aNode == aStartNode || aNode == aEndNode)) {
     return PR_TRUE;
   }
 
-  nsIContent* parent = aContent->GetParent();
+  nsINode* parent = aNode->GetNodeParent();
   if (!parent)
     return PR_FALSE;
 
-  PRInt32 indx = parent->IndexOf(aContent);
+  PRInt32 indx = parent->IndexOf(aNode);
 
   if (!aIsPreMode)
     ++indx;
 
   return (nsContentUtils::ComparePoints(aStartNode, aStartOffset,
                                         parent, indx) <= 0) &&
          (nsContentUtils::ComparePoints(aEndNode, aEndOffset,
                                         parent, indx) >= 0);
@@ -126,62 +126,62 @@ public:
 public:
   NS_DECL_ISUPPORTS
 
   nsContentIterator();
   virtual ~nsContentIterator();
 
   // nsIContentIterator interface methods ------------------------------
 
-  virtual nsresult Init(nsIContent* aRoot);
+  virtual nsresult Init(nsINode* aRoot);
 
   virtual nsresult Init(nsIDOMRange* aRange);
 
   virtual void First();
 
   virtual void Last();
   
   virtual void Next();
 
   virtual void Prev();
 
-  virtual nsIContent *GetCurrentNode();
+  virtual nsINode *GetCurrentNode();
 
   virtual PRBool IsDone();
 
-  virtual nsresult PositionAt(nsIContent* aCurNode);
+  virtual nsresult PositionAt(nsINode* aCurNode);
 
   // nsIEnumertor interface methods ------------------------------
   
   //NS_IMETHOD CurrentItem(nsISupports **aItem);
 
 protected:
 
-  nsIContent *GetDeepFirstChild(nsIContent *aRoot, nsVoidArray *aIndexes);
-  nsIContent *GetDeepLastChild(nsIContent *aRoot, nsVoidArray *aIndexes);
+  nsINode* GetDeepFirstChild(nsINode *aRoot, nsVoidArray *aIndexes);
+  nsINode* GetDeepLastChild(nsINode *aRoot, nsVoidArray *aIndexes);
 
   // Get the next sibling of aNode.  Note that this will generally return null
   // if aNode happens not to be a content node.  That's OK.
-  nsIContent *GetNextSibling(nsINode *aNode, nsVoidArray *aIndexes);
+  nsINode* GetNextSibling(nsINode *aNode, nsVoidArray *aIndexes);
 
   // Get the prev sibling of aNode.  Note that this will generally return null
   // if aNode happens not to be a content node.  That's OK.
-  nsIContent *GetPrevSibling(nsINode *aNode, nsVoidArray *aIndexes);
+  nsINode* GetPrevSibling(nsINode *aNode, nsVoidArray *aIndexes);
 
-  nsIContent *NextNode(nsIContent *aNode, nsVoidArray *aIndexes);
-  nsIContent *PrevNode(nsIContent *aNode, nsVoidArray *aIndexes);
+  nsINode* NextNode(nsINode *aNode, nsVoidArray *aIndexes);
+  nsINode* PrevNode(nsINode *aNode, nsVoidArray *aIndexes);
 
   // WARNING: This function is expensive
   nsresult RebuildIndexStack();
 
   void MakeEmpty();
   
-  nsCOMPtr<nsIContent> mCurNode;
-  nsCOMPtr<nsIContent> mFirst;
-  nsCOMPtr<nsIContent> mLast;
+  nsCOMPtr<nsINode> mCurNode;
+  nsCOMPtr<nsINode> mFirst;
+  nsCOMPtr<nsINode> mLast;
   nsCOMPtr<nsINode> mCommonParent;
 
   // used by nsContentIterator to cache indices
   nsAutoVoidArray mIndexes;
 
   // used by nsSubtreeIterator to cache indices.  Why put them in the base class?
   // Because otherwise I have to duplicate the routines GetNextSibling etc across both classes,
   // with slight variations for caching.  Or alternately, create a base class for the cache
@@ -277,20 +277,21 @@ nsContentIterator::~nsContentIterator()
 
 
 /******************************************************
  * Init routines
  ******************************************************/
 
 
 nsresult
-nsContentIterator::Init(nsIContent* aRoot)
+nsContentIterator::Init(nsINode* aRoot)
 {
   if (!aRoot) 
     return NS_ERROR_NULL_POINTER; 
+
   mIsDone = PR_FALSE;
   mIndexes.Clear();
   
   if (mPre)
   {
     mFirst = aRoot;
     mLast  = GetDeepLastChild(aRoot, nsnull);
   }
@@ -383,18 +384,18 @@ nsContentIterator::Init(nsIDOMRange* aRa
       {
         mFirst = GetNextSibling(startNode, nsnull);
 
         // Does mFirst node really intersect the range?
         // The range could be 'degenerate', ie not collapsed 
         // but still contain no content.
   
         if (mFirst &&
-            !ContentIsInTraversalRange(mFirst, mPre, startNode, startIndx,
-                                       endNode, endIndx)) {
+            !NodeIsInTraversalRange(mFirst, mPre, startNode, startIndx,
+                                    endNode, endIndx)) {
           mFirst = nsnull;
         }
       }
       else {
         NS_ASSERTION(startNode->IsNodeOfType(nsINode::eCONTENT),
                    "Data node that's not content?");
 
         mFirst = static_cast<nsIContent*>(startNode);
@@ -418,18 +419,18 @@ nsContentIterator::Init(nsIDOMRange* aRa
     {
       mFirst = GetDeepFirstChild(cChild, nsnull);
 
       // Does mFirst node really intersect the range?
       // The range could be 'degenerate', ie not collapsed 
       // but still contain no content.
   
       if (mFirst &&
-          !ContentIsInTraversalRange(mFirst, mPre, startNode, startIndx,
-                                     endNode, endIndx))
+          !NodeIsInTraversalRange(mFirst, mPre, startNode, startIndx,
+                                  endNode, endIndx))
         mFirst = nsnull;
     }
   }
 
 
   // Find last node in range.
 
   PRBool endIsData = endNode->IsNodeOfType(nsINode::eDATA_NODE);
@@ -449,18 +450,18 @@ nsContentIterator::Init(nsIDOMRange* aRa
       // XXX: In the future, if end offset is before the first
       //      character in the cdata node, should we set mLast to
       //      the prev sibling?
 
       if (!endIsData)
       {
         mLast = GetPrevSibling(endNode, nsnull);
 
-        if (!ContentIsInTraversalRange(mLast, mPre, startNode, startIndx,
-                                       endNode, endIndx))
+        if (!NodeIsInTraversalRange(mLast, mPre, startNode, startIndx,
+                                    endNode, endIndx))
           mLast = nsnull;
       }
       else {
         NS_ASSERTION(endNode->IsNodeOfType(nsINode::eCONTENT),
                      "Data node that's not content?");
 
         mLast = static_cast<nsIContent*>(endNode);
       }
@@ -477,18 +478,18 @@ nsContentIterator::Init(nsIDOMRange* aRa
       NS_NOTREACHED("nsContentIterator::nsContentIterator");
       return NS_ERROR_FAILURE; 
     }
 
     if (mPre)
     {
       mLast  = GetDeepLastChild(cChild, nsnull);
 
-      if (!ContentIsInTraversalRange(mLast, mPre, startNode, startIndx,
-                                     endNode, endIndx)) {
+      if (!NodeIsInTraversalRange(mLast, mPre, startNode, startIndx,
+                                  endNode, endIndx)) {
         mLast = nsnull;
       }
     }
     else { // post-order 
       mLast = cChild;
     }
   }
 
@@ -517,28 +518,28 @@ nsContentIterator::Init(nsIDOMRange* aRa
  * Helper routines
  ******************************************************/
 // WARNING: This function is expensive
 nsresult nsContentIterator::RebuildIndexStack()
 {
   // Make sure we start at the right indexes on the stack!  Build array up
   // to common parent of start and end.  Perhaps it's too many entries, but
   // that's far better than too few.
-  nsIContent* parent;
-  nsIContent* current;
+  nsINode* parent;
+  nsINode* current;
 
   mIndexes.Clear();
   current = mCurNode;
   if (!current) {
     return NS_OK;
   }
 
   while (current != mCommonParent)
   {
-    parent = current->GetParent();
+    parent = current->GetNodeParent();
     
     if (!parent)
       return NS_ERROR_FAILURE;
   
     mIndexes.InsertElementAt(NS_INT32_TO_PTR(parent->IndexOf(current)), 0);
 
     current = parent;
   }
@@ -551,72 +552,72 @@ nsContentIterator::MakeEmpty()
   mCurNode      = nsnull;
   mFirst        = nsnull;
   mLast         = nsnull;
   mCommonParent = nsnull;
   mIsDone       = PR_TRUE;
   mIndexes.Clear();
 }
 
-nsIContent *
-nsContentIterator::GetDeepFirstChild(nsIContent *aRoot, nsVoidArray *aIndexes)
+nsINode*
+nsContentIterator::GetDeepFirstChild(nsINode *aRoot, nsVoidArray *aIndexes)
 {
   if (!aRoot) {
     return nsnull;
   }
 
-  nsIContent *cN = aRoot;
-  nsIContent *cChild = cN->GetChildAt(0);
+  nsINode *n = aRoot;
+  nsINode *nChild = n->GetChildAt(0);
 
-  while (cChild)
+  while (nChild)
   {
     if (aIndexes)
     {
       // Add this node to the stack of indexes
       aIndexes->AppendElement(NS_INT32_TO_PTR(0));
     }
-    cN = cChild;
-    cChild = cN->GetChildAt(0);
+    n = nChild;
+    nChild = n->GetChildAt(0);
   }
 
-  return cN;
+  return n;
 }
 
-nsIContent *
-nsContentIterator::GetDeepLastChild(nsIContent *aRoot, nsVoidArray *aIndexes)
+nsINode*
+nsContentIterator::GetDeepLastChild(nsINode *aRoot, nsVoidArray *aIndexes)
 {
   if (!aRoot) {
     return nsnull;
   }
 
-  nsIContent *deepLastChild = aRoot;
+  nsINode *deepLastChild = aRoot;
 
-  nsIContent *cN = aRoot;
-  PRInt32 numChildren = cN->GetChildCount();
+  nsINode *n = aRoot;
+  PRInt32 numChildren = n->GetChildCount();
 
   while (numChildren)
   {
-    nsIContent *cChild = cN->GetChildAt(--numChildren);
+    nsINode *nChild = n->GetChildAt(--numChildren);
 
     if (aIndexes)
     {
       // Add this node to the stack of indexes
       aIndexes->AppendElement(NS_INT32_TO_PTR(numChildren));
     }
-    numChildren = cChild->GetChildCount();
-    cN = cChild;
+    numChildren = nChild->GetChildCount();
+    n = nChild;
 
-    deepLastChild = cN;
+    deepLastChild = n;
   }
 
   return deepLastChild;
 }
 
 // Get the next sibling, or parents next sibling, or grandpa's next sibling...
-nsIContent *
+nsINode *
 nsContentIterator::GetNextSibling(nsINode *aNode, 
                                   nsVoidArray *aIndexes)
 {
   if (!aNode) 
     return nsnull;
 
   nsINode *parent = aNode->GetNodeParent();
   if (!parent)
@@ -631,17 +632,17 @@ nsContentIterator::GetNextSibling(nsINod
     indx = NS_PTR_TO_INT32((*aIndexes)[aIndexes->Count()-1]);
   }
   else
     indx = mCachedIndex;
 
   // reverify that the index of the current node hasn't changed.
   // not super cheap, but a lot cheaper than IndexOf(), and still O(1).
   // ignore result this time - the index may now be out of range.
-  nsIContent *sib = parent->GetChildAt(indx);
+  nsINode *sib = parent->GetChildAt(indx);
   if (sib != aNode)
   {
     // someone changed our index - find the new index the painful way
     indx = parent->IndexOf(aNode);
   }
 
   // indx is now canonically correct
   if ((sib = parent->GetChildAt(++indx)))
@@ -670,17 +671,17 @@ nsContentIterator::GetNextSibling(nsINod
     // ok to leave cache out of date here if parent == mCommonParent?
     sib = GetNextSibling(parent, aIndexes);
   }
   
   return sib;
 }
 
 // Get the prev sibling, or parents prev sibling, or grandpa's prev sibling...
-nsIContent *
+nsINode*
 nsContentIterator::GetPrevSibling(nsINode *aNode, 
                                   nsVoidArray *aIndexes)
 {
   if (!aNode)
     return nsnull;
 
   nsINode *parent = aNode->GetNodeParent();
   if (!parent)
@@ -694,17 +695,17 @@ nsContentIterator::GetPrevSibling(nsINod
     // use the last entry on the Indexes array for the current index
     indx = NS_PTR_TO_INT32((*aIndexes)[aIndexes->Count()-1]);
   }
   else
     indx = mCachedIndex;
 
   // reverify that the index of the current node hasn't changed
   // ignore result this time - the index may now be out of range.
-  nsIContent *sib = parent->GetChildAt(indx);
+  nsINode *sib = parent->GetChildAt(indx);
   if (sib != aNode)
   {
     // someone changed our index - find the new index the painful way
     indx = parent->IndexOf(aNode);
   }
 
   // indx is now canonically correct
   if (indx > 0 && (sib = parent->GetChildAt(--indx)))
@@ -724,83 +725,83 @@ nsContentIterator::GetPrevSibling(nsINod
       aIndexes->RemoveElementAt(aIndexes->Count()-1);
     }
     return GetPrevSibling(parent, aIndexes);
   }
 
   return sib;
 }
 
-nsIContent *
-nsContentIterator::NextNode(nsIContent *aNode, nsVoidArray *aIndexes)
+nsINode*
+nsContentIterator::NextNode(nsINode *aNode, nsVoidArray *aIndexes)
 {
-  nsIContent *cN = aNode;
-  nsIContent *nextNode = nsnull;
+  nsINode *n = aNode;
+  nsINode *nextNode = nsnull;
 
   if (mPre)  // if we are a Pre-order iterator, use pre-order
   {
     // if it has children then next node is first child
-    if (NodeHasChildren(cN))
+    if (NodeHasChildren(n))
     {
-      nsIContent *cFirstChild = cN->GetChildAt(0);
+      nsINode *nFirstChild = n->GetChildAt(0);
 
       // update cache
       if (aIndexes)
       {
         // push an entry on the index stack
         aIndexes->AppendElement(NS_INT32_TO_PTR(0));
       }
       else mCachedIndex = 0;
       
-      return cFirstChild;
+      return nFirstChild;
     }
 
     // else next sibling is next
-    nextNode = GetNextSibling(cN, aIndexes);
+    nextNode = GetNextSibling(n, aIndexes);
   }
   else  // post-order
   {
-    nsIContent *parent = cN->GetParent();
-    nsIContent *cSibling = nsnull;
+    nsINode *parent = n->GetNodeParent();
+    nsINode *nSibling = nsnull;
     PRInt32 indx;
 
     // get the cached index
     if (aIndexes)
     {
       NS_ASSERTION(aIndexes->Count() > 0, "ContentIterator stack underflow");
       // use the last entry on the Indexes array for the current index
       indx = NS_PTR_TO_INT32((*aIndexes)[aIndexes->Count()-1]);
     }
     else indx = mCachedIndex;
 
     // reverify that the index of the current node hasn't changed.
     // not super cheap, but a lot cheaper than IndexOf(), and still O(1).
     // ignore result this time - the index may now be out of range.
     if (indx >= 0)
-      cSibling = parent->GetChildAt(indx);
-    if (cSibling != cN)
+      nSibling = parent->GetChildAt(indx);
+    if (nSibling != n)
     {
       // someone changed our index - find the new index the painful way
-      indx = parent->IndexOf(cN);
+      indx = parent->IndexOf(n);
     }
 
     // indx is now canonically correct
-    cSibling = parent->GetChildAt(++indx);
-    if (cSibling)
+    nSibling = parent->GetChildAt(++indx);
+    if (nSibling)
     {
       // update cache
       if (aIndexes)
       {
         // replace an entry on the index stack
         aIndexes->ReplaceElementAt(NS_INT32_TO_PTR(indx),aIndexes->Count()-1);
       }
       else mCachedIndex = indx;
       
       // next node is siblings "deep left" child
-      return GetDeepFirstChild(cSibling, aIndexes); 
+      return GetDeepFirstChild(nSibling, aIndexes); 
     }
   
     // else it's the parent
     // update cache
     if (aIndexes)
     {
       // pop an entry off the index stack
       // Don't leave the index empty, especially if we're
@@ -810,96 +811,96 @@ nsContentIterator::NextNode(nsIContent *
     }
     else mCachedIndex = 0;   // this might be wrong, but we are better off guessing
     nextNode = parent;
   }
 
   return nextNode;
 }
 
-nsIContent *
-nsContentIterator::PrevNode(nsIContent *aNode, nsVoidArray *aIndexes)
+nsINode*
+nsContentIterator::PrevNode(nsINode *aNode, nsVoidArray *aIndexes)
 {
-  nsIContent *prevNode = nsnull;
-  nsIContent *cN = aNode;
+  nsINode *prevNode = nsnull;
+  nsINode *n = aNode;
    
   if (mPre)  // if we are a Pre-order iterator, use pre-order
   {
-    nsIContent *parent = cN->GetParent();
-    nsIContent *cSibling = nsnull;
+    nsINode *parent = n->GetNodeParent();
+    nsINode *nSibling = nsnull;
     PRInt32 indx;
 
     // get the cached index
     if (aIndexes)
     {
       NS_ASSERTION(aIndexes->Count() > 0, "ContentIterator stack underflow");
       // use the last entry on the Indexes array for the current index
       indx = NS_PTR_TO_INT32((*aIndexes)[aIndexes->Count()-1]);
     }
     else indx = mCachedIndex;
 
     // reverify that the index of the current node hasn't changed.
     // not super cheap, but a lot cheaper than IndexOf(), and still O(1).
     // ignore result this time - the index may now be out of range.
     if (indx >= 0)
-      cSibling = parent->GetChildAt(indx);
+      nSibling = parent->GetChildAt(indx);
 
-    if (cSibling != cN)
+    if (nSibling != n)
     {
       // someone changed our index - find the new index the painful way
-      indx = parent->IndexOf(cN);
+      indx = parent->IndexOf(n);
     }
 
     // indx is now canonically correct
-    if (indx && (cSibling = parent->GetChildAt(--indx)))
+    if (indx && (nSibling = parent->GetChildAt(--indx)))
     {
       // update cache
       if (aIndexes)
       {
         // replace an entry on the index stack
         aIndexes->ReplaceElementAt(NS_INT32_TO_PTR(indx),aIndexes->Count()-1);
       }
       else mCachedIndex = indx;
       
       // prev node is siblings "deep right" child
-      return GetDeepLastChild(cSibling, aIndexes); 
+      return GetDeepLastChild(nSibling, aIndexes); 
     }
   
     // else it's the parent
     // update cache
     if (aIndexes)
     {
       // pop an entry off the index stack
       aIndexes->RemoveElementAt(aIndexes->Count()-1);
     }
     else mCachedIndex = 0;   // this might be wrong, but we are better off guessing
     prevNode = parent;
   }
   else  // post-order
   {
-    PRInt32 numChildren = cN->GetChildCount();
+    PRInt32 numChildren = n->GetChildCount();
   
     // if it has children then prev node is last child
     if (numChildren)
     {
-      nsIContent *cLastChild = cN->GetChildAt(--numChildren);
+      nsINode *nLastChild = n->GetChildAt(--numChildren);
 
       // update cache
       if (aIndexes)
       {
         // push an entry on the index stack
         aIndexes->AppendElement(NS_INT32_TO_PTR(numChildren));
       }
       else mCachedIndex = numChildren;
       
-      return cLastChild;
+      return nLastChild;
     }
 
     // else prev sibling is previous
-    prevNode = GetPrevSibling(cN, aIndexes);
+    prevNode = GetPrevSibling(n, aIndexes);
   }
 
   return prevNode;
 }
 
 /******************************************************
  * ContentIterator routines
  ******************************************************/
@@ -977,69 +978,69 @@ nsContentIterator::IsDone()
 {
   return mIsDone;
 }
 
 
 // Keeping arrays of indexes for the stack of nodes makes PositionAt
 // interesting...
 nsresult
-nsContentIterator::PositionAt(nsIContent* aCurNode)
+nsContentIterator::PositionAt(nsINode* aCurNode)
 {
   if (!aCurNode)
     return NS_ERROR_NULL_POINTER;
 
-  nsIContent *newCurNode = aCurNode;
-  nsIContent *tempNode = mCurNode;
+  nsINode *newCurNode = aCurNode;
+  nsINode *tempNode = mCurNode;
 
   mCurNode = aCurNode;
   // take an early out if this doesn't actually change the position
   if (mCurNode == tempNode)
   {
     mIsDone = PR_FALSE;  // paranoia
     return NS_OK;
   }
 
   // Check to see if the node falls within the traversal range.
 
-  nsIContent* firstNode = mFirst;
-  nsIContent* lastNode = mLast;
+  nsINode* firstNode = mFirst;
+  nsINode* lastNode = mLast;
   PRInt32 firstOffset=0, lastOffset=0;
 
   if (firstNode && lastNode)
   {
     if (mPre)
     {
-      firstNode = ContentToParentOffset(mFirst, &firstOffset);
+      firstNode = NodeToParentOffset(mFirst, &firstOffset);
 
       if (lastNode->GetChildCount())
         lastOffset = 0;
       else
       {
-        lastNode = ContentToParentOffset(mLast, &lastOffset);
+        lastNode = NodeToParentOffset(mLast, &lastOffset);
         ++lastOffset;
       }
     }
     else
     {
       PRUint32 numChildren = firstNode->GetChildCount();
 
       if (numChildren)
         firstOffset = numChildren;
       else
-        firstNode = ContentToParentOffset(mFirst, &firstOffset);
+        firstNode = NodeToParentOffset(mFirst, &firstOffset);
 
-      lastNode = ContentToParentOffset(mLast, &lastOffset);
+      lastNode = NodeToParentOffset(mLast, &lastOffset);
       ++lastOffset;
     }
   }
 
   if (!firstNode || !lastNode ||
-      !ContentIsInTraversalRange(mCurNode, mPre, firstNode, firstOffset,
-                                 lastNode, lastOffset))
+      !NodeIsInTraversalRange(mCurNode, mPre, firstNode, firstOffset,
+                              lastNode, lastOffset))
   {
     mIsDone = PR_TRUE;
     return NS_ERROR_FAILURE;
   }
 
   // We can be at ANY node in the sequence.
   // Need to regenerate the array of indexes back to the root or common parent!
   nsAutoVoidArray      oldParentStack;
@@ -1061,17 +1062,17 @@ nsContentIterator::PositionAt(nsIContent
   // sure we include mCommonParent in the oldParentStack, for use in the next
   // for loop, and mIndexes only has entries for nodes from tempNode up through
   // an ancestor of tempNode that's a child of mCommonParent.
   for (PRInt32 i = mIndexes.Count()+1; i > 0 && tempNode; i--)
   {
     // Insert at head since we're walking up
     oldParentStack.InsertElementAt(tempNode,0);
 
-    nsIContent *parent = tempNode->GetParent();
+    nsINode *parent = tempNode->GetNodeParent();
 
     if (!parent)  // this node has no parent, and thus no index
       break;
 
     if (parent == mCurNode)
     {
       // The position was moved to a parent of the current position. 
       // All we need to do is drop some indexes.  Shortcut here.
@@ -1081,17 +1082,17 @@ nsContentIterator::PositionAt(nsIContent
       return NS_OK;
     }
     tempNode = parent;
   }
 
   // Ok.  We have the array of old parents.  Look for a match.
   while (newCurNode)
   {
-    nsIContent *parent = newCurNode->GetParent();
+    nsINode *parent = newCurNode->GetNodeParent();
 
     if (!parent)  // this node has no parent, and thus no index
       break;
 
     PRInt32 indx = parent->IndexOf(newCurNode);
 
     // insert at the head!
     newIndexes.InsertElementAt(NS_INT32_TO_PTR(indx),0);
@@ -1116,18 +1117,17 @@ nsContentIterator::PositionAt(nsIContent
   }
 
   // phew!
 
   mIsDone = PR_FALSE;
   return NS_OK;
 }
 
-
-nsIContent *
+nsINode*
 nsContentIterator::GetCurrentNode()
 {
   if (mIsDone) {
     return nsnull;
   }
 
   NS_ASSERTION(mCurNode, "Null current node in an iterator that's not done!");
 
@@ -1157,36 +1157,36 @@ class nsContentSubtreeIterator : public 
 class nsContentSubtreeIterator : public nsContentIterator 
 {
 public:
   nsContentSubtreeIterator() {}
   virtual ~nsContentSubtreeIterator() {}
 
   // nsContentIterator overrides ------------------------------
 
-  virtual nsresult Init(nsIContent* aRoot);
+  virtual nsresult Init(nsINode* aRoot);
 
   virtual nsresult Init(nsIDOMRange* aRange);
 
   virtual void Next();
 
   virtual void Prev();
 
-  virtual nsresult PositionAt(nsIContent* aCurNode);
+  virtual nsresult PositionAt(nsINode* aCurNode);
 
   // Must override these because we don't do PositionAt
   virtual void First();
 
   // Must override these because we don't do PositionAt
   virtual void Last();
 
 protected:
 
-  nsresult GetTopAncestorInRange(nsIContent *aNode,
-                                 nsCOMPtr<nsIContent> *outAnestor);
+  nsresult GetTopAncestorInRange(nsINode *aNode,
+                                 nsCOMPtr<nsINode> *outAnestor);
 
   // no copy's or assigns  FIX ME
   nsContentSubtreeIterator(const nsContentSubtreeIterator&);
   nsContentSubtreeIterator& operator=(const nsContentSubtreeIterator&);
 
   nsCOMPtr<nsIDOMRange> mRange;
   // these arrays all typically are used and have elements
 #if 0
@@ -1221,72 +1221,65 @@ nsresult NS_NewContentSubtreeIterator(ns
 
 
 
 /******************************************************
  * Init routines
  ******************************************************/
 
 
-nsresult nsContentSubtreeIterator::Init(nsIContent* aRoot)
+nsresult nsContentSubtreeIterator::Init(nsINode* aRoot)
 {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 
 nsresult nsContentSubtreeIterator::Init(nsIDOMRange* aRange)
 {
   if (!aRange) 
     return NS_ERROR_NULL_POINTER; 
 
   mIsDone = PR_FALSE;
 
   mRange = aRange;
   
-  // get the start node and offset, convert to nsIContent
+  // get the start node and offset, convert to nsINode
   nsCOMPtr<nsIDOMNode> commonParent;
   nsCOMPtr<nsIDOMNode> startParent;
   nsCOMPtr<nsIDOMNode> endParent;
-  nsCOMPtr<nsIContent> cStartP;
-  nsCOMPtr<nsIContent> cEndP;
-  nsCOMPtr<nsIContent> cN;
-  nsIContent *firstCandidate = nsnull;
-  nsIContent *lastCandidate = nsnull;
+  nsCOMPtr<nsINode> nStartP;
+  nsCOMPtr<nsINode> nEndP;
+  nsCOMPtr<nsINode> n;
+  nsINode *firstCandidate = nsnull;
+  nsINode *lastCandidate = nsnull;
   PRInt32 indx, startIndx, endIndx;
 
   // get common content parent
   if (NS_FAILED(aRange->GetCommonAncestorContainer(getter_AddRefs(commonParent))) || !commonParent)
     return NS_ERROR_FAILURE;
   mCommonParent = do_QueryInterface(commonParent);
 
   // get start content parent
   if (NS_FAILED(aRange->GetStartContainer(getter_AddRefs(startParent))) || !startParent)
     return NS_ERROR_FAILURE;
-  cStartP = do_QueryInterface(startParent);
+  nStartP = do_QueryInterface(startParent);
   aRange->GetStartOffset(&startIndx);
 
   // get end content parent
   if (NS_FAILED(aRange->GetEndContainer(getter_AddRefs(endParent))) || !endParent)
     return NS_ERROR_FAILURE;
-  cEndP = do_QueryInterface(endParent);
+  nEndP = do_QueryInterface(endParent);
   aRange->GetEndOffset(&endIndx);
 
-  if (!cStartP || !cEndP)
-  {
-    // XXX Hack to account for the fact that not everything QIs to nsIContent.
-    // See bug 302775
-    return NS_ERROR_FAILURE;
-  }
-  
   // short circuit when start node == end node
   if (startParent == endParent)
   {
-    nsIContent* cChild = cStartP->GetChildAt(0);
+    nsINode* nChild = nStartP->GetChildAt(0);
   
-    if (!cChild) // no children, must be a text node or empty container
+    if (!nChild) // no children, must be a text node or empty container
     {
       // all inside one text node - empty subtree iterator
       MakeEmpty();
       return NS_OK;
     }
     else
     {
       if (startIndx == endIndx)  // collapsed range
@@ -1303,37 +1296,37 @@ nsresult nsContentSubtreeIterator::Init(
                                          &mStartNodes, &mStartOffsets);
 #endif
   nsContentUtils::GetAncestorsAndOffsets(endParent, endIndx,
                                          &mEndNodes, &mEndOffsets);
 
   // find first node in range
   aRange->GetStartOffset(&indx);
 
-  if (!cStartP->GetChildCount()) // no children, start at the node itself
+  if (!nStartP->GetChildCount()) // no children, start at the node itself
   {
-    cN = cStartP; 
+    n = nStartP;
   }
   else
   {
-    nsIContent* cChild = cStartP->GetChildAt(indx);
-    if (!cChild)  // offset after last child
+    nsINode* nChild = nStartP->GetChildAt(indx);
+    if (!nChild)  // offset after last child
     {
-      cN = cStartP;
+      n = nStartP;
     }
     else
     {
-      firstCandidate = cChild;
+      firstCandidate = nChild;
     }
   }
   
   if (!firstCandidate)
   {
     // then firstCandidate is next node after cN
-    firstCandidate = GetNextSibling(cN, nsnull);
+    firstCandidate = GetNextSibling(n, nsnull);
 
     if (!firstCandidate)
     {
       MakeEmpty();
       return NS_OK;
     }
   }
   
@@ -1357,41 +1350,41 @@ nsresult nsContentSubtreeIterator::Init(
   // cool, we have the first node in the range.  Now we walk
   // up it's ancestors to find the most senior that is still
   // in the range.  That's the real first node.
   if (NS_FAILED(GetTopAncestorInRange(firstCandidate, address_of(mFirst))))
     return NS_ERROR_FAILURE;
 
   // now to find the last node
   aRange->GetEndOffset(&indx);
-  PRInt32 numChildren = cEndP->GetChildCount();
+  PRInt32 numChildren = nEndP->GetChildCount();
 
   if (indx > numChildren) indx = numChildren;
   if (!indx)
   {
-    cN = cEndP;
+    n = nEndP;
   }
   else
   {
     if (!numChildren) // no children, must be a text node
     {
-      cN = cEndP; 
+      n = nEndP;
     }
     else
     {
-      lastCandidate = cEndP->GetChildAt(--indx);
+      lastCandidate = nEndP->GetChildAt(--indx);
       NS_ASSERTION(lastCandidate,
                    "tree traversal trouble in nsContentSubtreeIterator::Init");
     }
   }
   
   if (!lastCandidate)
   {
-    // then lastCandidate is prev node before cN
-    lastCandidate = GetPrevSibling(cN, nsnull);
+    // then lastCandidate is prev node before n
+    lastCandidate = GetPrevSibling(n, nsnull);
   }
   
   lastCandidate = GetDeepLastChild(lastCandidate, nsnull);
   
   // confirm that this last possible contained node
   // is indeed contained.  Else we have a range that
   // does not fully contain any node.
   
@@ -1447,17 +1440,17 @@ nsContentSubtreeIterator::Next()
     return;
 
   if (mCurNode == mLast) 
   {
     mIsDone = PR_TRUE;
     return;
   }
 
-  nsIContent *nextNode = GetNextSibling(mCurNode, nsnull);
+  nsINode *nextNode = GetNextSibling(mCurNode, nsnull);
   NS_ASSERTION(nextNode, "No next sibling!?! This could mean deadlock!");
 
 /*
   nextNode = GetDeepFirstChild(nextNode);
   return GetTopAncestorInRange(nextNode, address_of(mCurNode));
 */
   PRInt32 i = mEndNodes.IndexOf(nextNode);
   while (i != -1)
@@ -1494,80 +1487,80 @@ nsContentSubtreeIterator::Prev()
     return;
 
   if (mCurNode == mFirst) 
   {
     mIsDone = PR_TRUE;
     return;
   }
 
-  nsIContent *prevNode = PrevNode(GetDeepFirstChild(mCurNode, nsnull), nsnull);
+  nsINode *prevNode = PrevNode(GetDeepFirstChild(mCurNode, nsnull), nsnull);
 
   prevNode = GetDeepLastChild(prevNode, nsnull);
   
   GetTopAncestorInRange(prevNode, address_of(mCurNode));
 
   // This shouldn't be needed, but since our selection code can put us
   // in a situation where mFirst is in generated content, we need this
   // to stop the iterator when we've walked past past the first node!
   mIsDone = mCurNode == nsnull;
 }
 
 
 nsresult
-nsContentSubtreeIterator::PositionAt(nsIContent* aCurNode)
+nsContentSubtreeIterator::PositionAt(nsINode* aCurNode)
 {
   NS_ERROR("Not implemented!");
 
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 /****************************************************************
  * nsContentSubtreeIterator helper routines
  ****************************************************************/
 
 nsresult
-nsContentSubtreeIterator::GetTopAncestorInRange(nsIContent *aNode,
-                                                nsCOMPtr<nsIContent> *outAnestor)
+nsContentSubtreeIterator::GetTopAncestorInRange(nsINode *aNode,
+                                                nsCOMPtr<nsINode> *outAncestor)
 {
   if (!aNode) 
     return NS_ERROR_NULL_POINTER;
-  if (!outAnestor) 
+  if (!outAncestor) 
     return NS_ERROR_NULL_POINTER;
   
   
   // sanity check: aNode is itself in the range
   PRBool nodeBefore, nodeAfter;
   if (NS_FAILED(nsRange::CompareNodeToRange(aNode, mRange, &nodeBefore,
                                             &nodeAfter)))
     return NS_ERROR_FAILURE;
 
   if (nodeBefore || nodeAfter)
     return NS_ERROR_FAILURE;
   
-  nsCOMPtr<nsIContent> parent, tmp;
+  nsCOMPtr<nsINode> parent, tmp;
   while (aNode)
   {
-    parent = aNode->GetParent();
+    parent = aNode->GetNodeParent();
     if (!parent)
     {
       if (tmp)
       {
-        *outAnestor = tmp;
+        *outAncestor = tmp;
         return NS_OK;
       }
       else return NS_ERROR_FAILURE;
     }
     if (NS_FAILED(nsRange::CompareNodeToRange(parent, mRange, &nodeBefore,
                                               &nodeAfter)))
       return NS_ERROR_FAILURE;
 
     if (nodeBefore || nodeAfter)
     {
-      *outAnestor = aNode;
+      *outAncestor = aNode;
       return NS_OK;
     }
     tmp = aNode;
     aNode = parent;
   }
   return NS_ERROR_FAILURE;
 }
 
diff -r 4b060ed856e0 content/base/src/nsContentUtils.cpp
--- a/content/base/src/nsContentUtils.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/content/base/src/nsContentUtils.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -3948,46 +3948,44 @@ nsContentUtils::GetNativeEvent(nsIDOMEve
   nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(aDOMEvent));
   if (!privateEvent)
     return nsnull;
   return privateEvent->GetInternalNSEvent();
 }
 
 //static
 PRBool
-nsContentUtils::DOMEventToNativeKeyEvent(nsIDOMEvent* aDOMEvent,
+nsContentUtils::DOMEventToNativeKeyEvent(nsIDOMKeyEvent* aKeyEvent,
                                          nsNativeKeyEvent* aNativeEvent,
                                          PRBool aGetCharCode)
 {
-  nsCOMPtr<nsIDOMNSUIEvent> uievent = do_QueryInterface(aDOMEvent);
+  nsCOMPtr<nsIDOMNSUIEvent> uievent = do_QueryInterface(aKeyEvent);
   PRBool defaultPrevented;
   uievent->GetPreventDefault(&defaultPrevented);
   if (defaultPrevented)
     return PR_FALSE;
 
-  nsCOMPtr<nsIDOMNSEvent> nsevent = do_QueryInterface(aDOMEvent);
+  nsCOMPtr<nsIDOMNSEvent> nsevent = do_QueryInterface(aKeyEvent);
   PRBool trusted = PR_FALSE;
   nsevent->GetIsTrusted(&trusted);
   if (!trusted)
     return PR_FALSE;
 
-  nsCOMPtr<nsIDOMKeyEvent> keyEvent = do_QueryInterface(aDOMEvent);
-
   if (aGetCharCode) {
-    keyEvent->GetCharCode(&aNativeEvent->charCode);
+    aKeyEvent->GetCharCode(&aNativeEvent->charCode);
   } else {
     aNativeEvent->charCode = 0;
   }
-  keyEvent->GetKeyCode(&aNativeEvent->keyCode);
-  keyEvent->GetAltKey(&aNativeEvent->altKey);
-  keyEvent->GetCtrlKey(&aNativeEvent->ctrlKey);
-  keyEvent->GetShiftKey(&aNativeEvent->shiftKey);
-  keyEvent->GetMetaKey(&aNativeEvent->metaKey);
-
-  aNativeEvent->nativeEvent = GetNativeEvent(aDOMEvent);
+  aKeyEvent->GetKeyCode(&aNativeEvent->keyCode);
+  aKeyEvent->GetAltKey(&aNativeEvent->altKey);
+  aKeyEvent->GetCtrlKey(&aNativeEvent->ctrlKey);
+  aKeyEvent->GetShiftKey(&aNativeEvent->shiftKey);
+  aKeyEvent->GetMetaKey(&aNativeEvent->metaKey);
+
+  aNativeEvent->nativeEvent = GetNativeEvent(aKeyEvent);
 
   return PR_TRUE;
 }
 
 static PRBool
 HasASCIIDigit(const nsTArray<nsShortcutCandidate>& aCandidates)
 {
   for (PRUint32 i = 0; i < aCandidates.Length(); ++i) {
diff -r 4b060ed856e0 content/base/src/nsDOMAttribute.cpp
--- a/content/base/src/nsDOMAttribute.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/content/base/src/nsDOMAttribute.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -51,16 +51,19 @@
 #include "nsIDOMDocument.h"
 #include "nsIDOM3Attr.h"
 #include "nsIDOMUserDataHandler.h"
 #include "nsEventDispatcher.h"
 #include "nsGkAtoms.h"
 #include "nsCOMArray.h"
 #include "nsNodeUtils.h"
 #include "nsIEventListenerManager.h"
+#include "nsTextNode.h"
+#include "mozAutoDocUpdate.h"
+#include "nsMutationEvent.h"
 
 //----------------------------------------------------------------------
 PRBool nsDOMAttribute::sInitialized;
 
 nsDOMAttribute::nsDOMAttribute(nsDOMAttributeMap *aAttrMap,
                                nsINodeInfo       *aNodeInfo,
                                const nsAString   &aValue)
   : nsIAttribute(aAttrMap, aNodeInfo), mValue(aValue), mChild(nsnull)
@@ -83,17 +86,20 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mNodeInfo)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_RAWPTR(mChild)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_LISTENERMANAGER
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_USERDATA
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_PRESERVED_WRAPPER
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsDOMAttribute)
-  NS_IF_RELEASE(tmp->mChild);
+  if (tmp->mChild) {
+    static_cast<nsTextNode*>(tmp->mChild)->UnbindFromAttribute();
+    NS_RELEASE(tmp->mChild);
+  }
   NS_IMPL_CYCLE_COLLECTION_UNLINK_LISTENERMANAGER
   NS_IMPL_CYCLE_COLLECTION_UNLINK_USERDATA
   NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
 NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 // QueryInterface implementation for nsDOMAttribute
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsDOMAttribute)
   NS_INTERFACE_MAP_ENTRY(nsIDOMAttr)
   NS_INTERFACE_MAP_ENTRY(nsIAttribute)
@@ -353,17 +359,20 @@ nsDOMAttribute::ReplaceChild(nsIDOMNode*
 nsDOMAttribute::ReplaceChild(nsIDOMNode* aNewChild, nsIDOMNode* aOldChild, nsIDOMNode** aReturn)
 {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP
 nsDOMAttribute::RemoveChild(nsIDOMNode* aOldChild, nsIDOMNode** aReturn)
 {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  nsCOMPtr<nsIContent> content = do_QueryInterface(aOldChild);
+  PRInt32 index = IndexOf(content);
+  return (index == -1) ? NS_ERROR_DOM_NOT_FOUND_ERR :
+    RemoveChildAt(index, PR_TRUE);
 }
 
 NS_IMETHODIMP
 nsDOMAttribute::AppendChild(nsIDOMNode* aNewChild, nsIDOMNode** aReturn)
 {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
@@ -702,17 +711,47 @@ nsDOMAttribute::AppendChildTo(nsIContent
 nsDOMAttribute::AppendChildTo(nsIContent* aKid, PRBool aNotify)
 {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 nsresult
 nsDOMAttribute::RemoveChildAt(PRUint32 aIndex, PRBool aNotify)
 {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  if (aIndex != 0 || !mChild) {
+    return NS_OK;
+  }
+
+  nsCOMPtr<nsIContent> child = mChild;
+  nsMutationGuard::DidMutate();
+  mozAutoDocUpdate updateBatch(GetOwnerDoc(), UPDATE_CONTENT_MODEL, aNotify);
+  nsMutationGuard guard;
+
+  mozAutoSubtreeModified subtree(nsnull, nsnull);
+  if (aNotify &&
+      nsContentUtils::HasMutationListeners(mChild,
+                                           NS_EVENT_BITS_MUTATION_NODEREMOVED,
+                                           this)) {
+    mozAutoRemovableBlockerRemover blockerRemover;
+    nsMutationEvent mutation(PR_TRUE, NS_MUTATION_NODEREMOVED);
+    mutation.mRelatedNode =
+      do_QueryInterface(static_cast<nsIAttribute*>(this));
+    subtree.UpdateTarget(GetOwnerDoc(), this);
+    nsEventDispatcher::Dispatch(mChild, nsnull, &mutation);
+  }
+  if (guard.Mutated(0) && mChild != child) {
+    return NS_OK;
+  }
+  NS_RELEASE(mChild);
+  static_cast<nsTextNode*>(child.get())->UnbindFromAttribute();
+
+  nsString nullString;
+  SetDOMStringToNull(nullString);
+  SetValue(nullString);
+  return NS_OK;
 }
 
 nsresult
 nsDOMAttribute::PreHandleEvent(nsEventChainPreVisitor& aVisitor)
 {
   // We don't support event dispatching to attributes yet.
   aVisitor.mCanHandle = PR_FALSE;
   return NS_OK;
@@ -784,17 +823,17 @@ nsDOMAttribute::EnsureChildState(PRBool 
   nsAutoString value;
   mutableThis->GetValue(value);
 
   if (!mChild && !value.IsEmpty()) {
     nsresult rv = NS_NewTextNode(&mutableThis->mChild,
                                  mNodeInfo->NodeInfoManager());
     NS_ENSURE_SUCCESS(rv, rv);
 
-    // XXX We should be setting |this| as the parent of the textnode!
+    static_cast<nsTextNode*>(mChild)->BindToAttribute(mutableThis);
   }
 
   aHasChild = !value.IsEmpty();
 
   if (aSetText && aHasChild) {
     mChild->SetText(value, PR_TRUE);
   }
 
diff -r 4b060ed856e0 content/base/src/nsGenericDOMDataNode.cpp
--- a/content/base/src/nsGenericDOMDataNode.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/content/base/src/nsGenericDOMDataNode.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -992,17 +992,18 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_CYCLE_COLLECTING_ADDREF(nsText3Tearoff)
 NS_IMPL_CYCLE_COLLECTING_RELEASE(nsText3Tearoff)
 
 NS_IMETHODIMP
 nsText3Tearoff::GetIsElementContentWhitespace(PRBool *aReturn)
 {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  *aReturn = mNode->TextIsOnlyWhitespace();
+  return NS_OK;
 }
 
 NS_IMETHODIMP
 nsText3Tearoff::GetWholeText(nsAString& aWholeText)
 {
   return mNode->GetWholeText(aWholeText);
 }
 
diff -r 4b060ed856e0 content/base/src/nsNodeUtils.cpp
--- a/content/base/src/nsNodeUtils.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/content/base/src/nsNodeUtils.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -585,16 +585,19 @@ nsNodeUtils::CloneAndAdopt(nsINode *aNod
       }
 
       nsPIDOMWindow* window = newDoc->GetInnerWindow();
       if (window) {
         nsCOMPtr<nsIEventListenerManager> elm;
         aNode->GetListenerManager(PR_FALSE, getter_AddRefs(elm));
         if (elm) {
           window->SetMutationListeners(elm->MutationListenerBits());
+          if (elm->MayHavePaintEventListener()) {
+            window->SetHasPaintEventListeners();
+          }
         }
       }
     }
 
     if (elem) {
       elem->RecompileScriptEventListeners();
     }
 
diff -r 4b060ed856e0 content/base/src/nsRange.cpp
--- a/content/base/src/nsRange.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/content/base/src/nsRange.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -84,29 +84,29 @@ nsresult NS_NewContentSubtreeIterator(ns
 // If outNodeBefore is returned true, then the node starts before the range does.
 // If outNodeAfter is returned true, then the node ends after the range does.
 // Note that both of the above might be true.
 // If neither are true, the node is contained inside of the range.
 // XXX - callers responsibility to ensure node in same doc as range! 
 
 // static
 nsresult
-nsRange::CompareNodeToRange(nsIContent* aNode, nsIDOMRange* aRange,
+nsRange::CompareNodeToRange(nsINode* aNode, nsIDOMRange* aRange,
                             PRBool *outNodeBefore, PRBool *outNodeAfter)
 {
   nsresult rv;
   nsCOMPtr<nsIRange> range = do_QueryInterface(aRange, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
 
   return CompareNodeToRange(aNode, range, outNodeBefore, outNodeAfter);
 }
 
 // static
 nsresult
-nsRange::CompareNodeToRange(nsIContent* aNode, nsIRange* aRange,
+nsRange::CompareNodeToRange(nsINode* aNode, nsIRange* aRange,
                             PRBool *outNodeBefore, PRBool *outNodeAfter)
 {
   NS_ENSURE_STATE(aNode);
   // create a pair of dom points that expresses location of node:
   //     NODE(start), NODE(end)
   // Let incoming range be:
   //    {RANGE(start), RANGE(end)}
   // if (RANGE(start) <= NODE(start))  and (RANGE(end) => NODE(end))
@@ -119,24 +119,21 @@ nsRange::CompareNodeToRange(nsIContent* 
   if (!range->IsPositioned()) 
     return NS_ERROR_UNEXPECTED; 
   
   // gather up the dom point info
   PRInt32 nodeStart, nodeEnd;
   nsINode* parent = aNode->GetNodeParent();
   if (!parent) {
     // can't make a parent/offset pair to represent start or 
-    // end of the root node, becasue it has no parent.
+    // end of the root node, because it has no parent.
     // so instead represent it by (node,0) and (node,numChildren)
     parent = aNode;
     nodeStart = 0;
     nodeEnd = aNode->GetChildCount();
-    if (!nodeEnd) {
-      return NS_ERROR_FAILURE;
-    }
   }
   else {
     nodeStart = parent->IndexOf(aNode);
     nodeEnd = nodeStart + 1;
   }
 
   nsINode* rangeStartParent = range->GetStartParent();
   nsINode* rangeEndParent = range->GetEndParent();
@@ -923,20 +920,20 @@ RangeSubtreeIterator::GetCurrentNode()
   nsIDOMNode *node = nsnull;
 
   if (mIterState == eUseStart && mStart) {
     NS_ADDREF(node = mStart);
   } else if (mIterState == eUseEnd && mEnd)
     NS_ADDREF(node = mEnd);
   else if (mIterState == eUseIterator && mIter)
   {
-    nsIContent *content = mIter->GetCurrentNode();
+    nsINode* n = mIter->GetCurrentNode();
 
-    if (content) {
-      CallQueryInterface(content, &node);
+    if (n) {
+      CallQueryInterface(n, &node);
     }
   }
 
   return node;
 }
 
 void
 RangeSubtreeIterator::First()
@@ -1943,43 +1940,44 @@ nsresult nsRange::ToString(nsAString& aR
     }
   } 
   
   /* complex case: mStartParent != mEndParent, or mStartParent not a text node
      revisit - there are potential optimizations here and also tradeoffs.
   */
 
   nsCOMPtr<nsIContentIterator> iter;
-  NS_NewContentIterator(getter_AddRefs(iter));
-  nsresult rv = iter->Init(this);
+  nsresult rv = NS_NewContentIterator(getter_AddRefs(iter));
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = iter->Init(this);
   NS_ENSURE_SUCCESS(rv, rv);
   
   nsString tempString;
  
   // loop through the content iterator, which returns nodes in the range in 
   // close tag order, and grab the text from any text node
   while (!iter->IsDone())
   {
-    nsIContent *cN = iter->GetCurrentNode();
+    nsINode *n = iter->GetCurrentNode();
 
 #ifdef DEBUG_range
     // If debug, dump it:
-    cN->List(stdout);
+    n->List(stdout);
 #endif /* DEBUG */
-    nsCOMPtr<nsIDOMText> textNode( do_QueryInterface(cN) );
+    nsCOMPtr<nsIDOMText> textNode(do_QueryInterface(n));
     if (textNode) // if it's a text node, get the text
     {
-      if (cN == mStartParent) // only include text past start offset
+      if (n == mStartParent) // only include text past start offset
       {
         PRUint32 strLength;
         textNode->GetLength(&strLength);
         textNode->SubstringData(mStartOffset,strLength-mStartOffset,tempString);
         aReturn += tempString;
       }
-      else if (cN == mEndParent)  // only include text before end offset
+      else if (n == mEndParent)  // only include text before end offset
       {
         textNode->SubstringData(0,mEndOffset,tempString);
         aReturn += tempString;
       }
       else  // grab the whole kit-n-kaboodle
       {
         textNode->GetData(tempString);
         aReturn += tempString;
diff -r 4b060ed856e0 content/base/src/nsRange.h
--- a/content/base/src/nsRange.h	Tue Oct 14 17:12:28 2008 -0700
+++ b/content/base/src/nsRange.h	Thu Oct 16 21:24:48 2008 -0500
@@ -135,20 +135,20 @@ public:
 public:
 /******************************************************************************
  *  Utility routine to detect if a content node starts before a range and/or 
  *  ends after a range.  If neither it is contained inside the range.
  *  
  *  XXX - callers responsibility to ensure node in same doc as range!
  *
  *****************************************************************************/
-  static nsresult CompareNodeToRange(nsIContent* aNode, nsIDOMRange* aRange,
+  static nsresult CompareNodeToRange(nsINode* aNode, nsIDOMRange* aRange,
                                      PRBool *outNodeBefore,
                                      PRBool *outNodeAfter);
-  static nsresult CompareNodeToRange(nsIContent* aNode, nsIRange* aRange,
+  static nsresult CompareNodeToRange(nsINode* aNode, nsIRange* aRange,
                                      PRBool *outNodeBefore,
                                      PRBool *outNodeAfter);
 
 protected:
   void DoSetRange(nsINode* aStartN, PRInt32 aStartOffset,
                   nsINode* aEndN, PRInt32 aEndOffset,
                   nsINode* aRoot);
 };
diff -r 4b060ed856e0 content/base/src/nsTextNode.cpp
--- a/content/base/src/nsTextNode.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/content/base/src/nsTextNode.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -34,56 +34,26 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 /*
  * Implementation of DOM Core's nsIDOMText node.
  */
 
-#include "nsGenericDOMDataNode.h"
-#include "nsIDOMText.h"
+#include "nsTextNode.h"
 #include "nsIDOM3Text.h"
 #include "nsContentUtils.h"
 #include "nsIDOMEventListener.h"
 #include "nsIDOMEventTarget.h"
 #include "nsIDOMMutationEvent.h"
 #include "nsIAttribute.h"
 #include "nsIDocument.h"
 #include "nsThreadUtils.h"
 
-/**
- * Class used to implement DOM text nodes
- */
-class nsTextNode : public nsGenericDOMDataNode,
-                   public nsIDOMText
-{
-public:
-  nsTextNode(nsINodeInfo *aNodeInfo);
-  virtual ~nsTextNode();
-
-  // nsISupports
-  NS_DECL_ISUPPORTS_INHERITED
-
-  // nsIDOMNode
-  NS_IMPL_NSIDOMNODE_USING_GENERIC_DOM_DATA
-
-  // nsIDOMCharacterData
-  NS_FORWARD_NSIDOMCHARACTERDATA(nsGenericDOMDataNode::)
-
-  // nsIDOMText
-  NS_FORWARD_NSIDOMTEXT(nsGenericDOMDataNode::)
-
-  // nsIContent
-  virtual PRBool IsNodeOfType(PRUint32 aFlags) const;
-#ifdef DEBUG
-  virtual void List(FILE* out, PRInt32 aIndent) const;
-  virtual void DumpContent(FILE* out, PRInt32 aIndent, PRBool aDumpAll) const;
-#endif
-};
 
 /**
  * class used to implement attr() generated content
  */
 class nsAttributeTextNode : public nsTextNode,
                             public nsStubMutationObserver
 {
 public:
@@ -227,16 +197,38 @@ nsTextNode::CloneDataNode(nsINodeInfo *a
 nsTextNode::CloneDataNode(nsINodeInfo *aNodeInfo, PRBool aCloneText) const
 {
   nsTextNode *it = new nsTextNode(aNodeInfo);
   if (it && aCloneText) {
     it->mText = mText;
   }
 
   return it;
+}
+
+nsresult
+nsTextNode::BindToAttribute(nsIAttribute* aAttr)
+{
+  NS_ASSERTION(!IsInDoc(), "Unbind before binding!");
+  NS_ASSERTION(!GetNodeParent(), "Unbind before binding!");
+  NS_ASSERTION(HasSameOwnerDoc(aAttr), "Wrong owner document!");
+
+  mParentPtrBits = reinterpret_cast<PtrBits>(aAttr);
+  return NS_OK;
+}
+
+nsresult
+nsTextNode::UnbindFromAttribute()
+{
+  NS_ASSERTION(GetNodeParent(), "Bind before unbinging!");
+  NS_ASSERTION(GetNodeParent() &&
+               GetNodeParent()->IsNodeOfType(nsINode::eATTRIBUTE),
+               "Use this method only to unbind from an attribute!");
+  mParentPtrBits = 0;
+  return NS_OK;
 }
 
 #ifdef DEBUG
 void
 nsTextNode::List(FILE* out, PRInt32 aIndent) const
 {
   PRInt32 index;
   for (index = aIndent; --index >= 0; ) fputs("  ", out);
diff -r 4b060ed856e0 content/base/src/nsTextNode.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/base/src/nsTextNode.h	Thu Oct 16 21:24:48 2008 -0500
@@ -0,0 +1,85 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/*
+ * Implementation of DOM Core's nsIDOMText node.
+ */
+
+#include "nsGenericDOMDataNode.h"
+#include "nsIDOMText.h"
+#include "nsIDOM3Text.h"
+#include "nsContentUtils.h"
+#include "nsIDOMEventListener.h"
+#include "nsIDOMEventTarget.h"
+#include "nsIDOMMutationEvent.h"
+#include "nsIAttribute.h"
+#include "nsIDocument.h"
+#include "nsThreadUtils.h"
+
+/**
+ * Class used to implement DOM text nodes
+ */
+class nsTextNode : public nsGenericDOMDataNode,
+                   public nsIDOMText
+{
+public:
+  nsTextNode(nsINodeInfo *aNodeInfo);
+  virtual ~nsTextNode();
+
+  // nsISupports
+  NS_DECL_ISUPPORTS_INHERITED
+
+  // nsIDOMNode
+  NS_IMPL_NSIDOMNODE_USING_GENERIC_DOM_DATA
+
+  // nsIDOMCharacterData
+  NS_FORWARD_NSIDOMCHARACTERDATA(nsGenericDOMDataNode::)
+
+  // nsIDOMText
+  NS_FORWARD_NSIDOMTEXT(nsGenericDOMDataNode::)
+
+  // nsIContent
+  virtual PRBool IsNodeOfType(PRUint32 aFlags) const;
+
+  nsresult BindToAttribute(nsIAttribute* aAttr);
+  nsresult UnbindFromAttribute();
+
+#ifdef DEBUG
+  virtual void List(FILE* out, PRInt32 aIndent) const;
+  virtual void DumpContent(FILE* out, PRInt32 aIndent, PRBool aDumpAll) const;
+#endif
+};
diff -r 4b060ed856e0 content/events/public/nsIEventListenerManager.h
--- a/content/events/public/nsIEventListenerManager.h	Tue Oct 14 17:12:28 2008 -0700
+++ b/content/events/public/nsIEventListenerManager.h	Thu Oct 16 21:24:48 2008 -0500
@@ -48,24 +48,28 @@ class nsIDOMEventGroup;
 class nsIDOMEventGroup;
 class nsIAtom;
 class nsPIDOMEventTarget;
 
 /*
  * Event listener manager interface.
  */
 #define NS_IEVENTLISTENERMANAGER_IID \
-{ 0x0cdf1660, 0x3ac1, 0x4b84, \
-  { 0xa9, 0x35, 0xc0, 0xc0, 0xe5, 0x5d, 0x73, 0xca } }
-
+{ 0xadfdc265, 0xea1c, 0x4c0b, \
+  { 0x91, 0xca, 0x37, 0x67, 0x2c, 0x83, 0x92, 0x1f } }
 
 class nsIEventListenerManager : public nsISupports {
 
 public:
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_IEVENTLISTENERMANAGER_IID)
+
+  nsIEventListenerManager() : mMayHavePaintEventListener(PR_FALSE),
+    mMayHaveMutationListeners(PR_FALSE),
+    mNoListenerForEvent(0)
+  {}
 
   /**
   * Sets events listeners of all types.
   * @param an event listener
   */
   NS_IMETHOD AddEventListenerByIID(nsIDOMEventListener *aListener,
                                    const nsIID& aIID, PRInt32 flags) = 0;
 
@@ -189,16 +193,31 @@ public:
    * Returns PR_TRUE if there is at least one event listener for aEventName.
    */
   virtual PRBool HasListenersFor(const nsAString& aEventName) = 0;
 
   /**
    * Returns PR_TRUE if there is at least one event listener.
    */
   virtual PRBool HasListeners() = 0;
+
+
+  /**
+   * Returns PR_TRUE if there may be a paint event listener registered,
+   * PR_FALSE if there definitely isn't.
+   */
+  PRBool MayHavePaintEventListener() { return mMayHavePaintEventListener; }
+
+protected:
+  PRUint32 mMayHavePaintEventListener : 1;
+  PRUint32 mMayHaveMutationListeners : 1;
+  // These two member variables are used to cache the information
+  // about the last event which was handled but for which event listener manager
+  // didn't have event listeners.
+  PRUint32 mNoListenerForEvent : 30;
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(nsIEventListenerManager,
                               NS_IEVENTLISTENERMANAGER_IID)
 
 nsresult
 NS_NewEventListenerManager(nsIEventListenerManager** aInstancePtrResult);
 
diff -r 4b060ed856e0 content/events/src/nsEventListenerManager.cpp
--- a/content/events/src/nsEventListenerManager.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/content/events/src/nsEventListenerManager.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -337,19 +337,17 @@ nsIDOMEventGroup* gDOM2EventGroup = nsnu
 nsIDOMEventGroup* gDOM2EventGroup = nsnull;
 
 nsDataHashtable<nsISupportsHashKey, PRUint32>* gEventIdTable = nsnull;
 
 PRUint32 nsEventListenerManager::mInstanceCount = 0;
 PRUint32 nsEventListenerManager::sCreatedCount = 0;
 
 nsEventListenerManager::nsEventListenerManager() :
-  mTarget(nsnull),
-  mMayHaveMutationListeners(PR_FALSE),
-  mNoListenerForEvent(NS_EVENT_TYPE_NULL)
+  mTarget(nsnull)
 {
   ++mInstanceCount;
   ++sCreatedCount;
 }
 
 nsEventListenerManager::~nsEventListenerManager() 
 {
   NS_ASSERTION(!mTarget, "didn't call Disconnect");
@@ -422,16 +420,37 @@ nsEventListenerManager::GetTypeDataForEv
     for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(sEventTypes); ++i) {
       for (PRInt32 j = 0; j < sEventTypes[i].numEvents; ++j) {
          if (event == sEventTypes[i].events[j].message) {
            return &sEventTypes[i];
          }
       }
     }
   }
+  return nsnull;
+}
+
+nsPIDOMWindow*
+nsEventListenerManager::GetInnerWindowForTarget()
+{
+  nsCOMPtr<nsINode> node = do_QueryInterface(mTarget);
+  if (node) {
+    // XXX sXBL/XBL2 issue -- do we really want the owner here?  What
+    // if that's the XBL document?
+    nsIDocument* document = node->GetOwnerDoc();
+    if (document)
+      return document->GetInnerWindow();
+  }
+
+  nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(mTarget);
+  if (window) {
+    NS_ASSERTION(window->IsInnerWindow(), "Target should not be an outer window");
+    return window;
+  }
+
   return nsnull;
 }
 
 nsresult
 nsEventListenerManager::AddEventListener(nsIDOMEventListener *aListener,
                                          PRUint32 aType,
                                          nsIAtom* aTypeAtom,
                                          const EventTypeData* aTypeData,
@@ -492,39 +511,29 @@ nsEventListenerManager::AddEventListener
   ls->mListener = aListener;
   ls->mEventType = aType;
   ls->mTypeAtom = aTypeAtom;
   ls->mFlags = aFlags;
   ls->mGroupFlags = group;
   ls->mHandlerIsString = PR_FALSE;
   ls->mTypeData = aTypeData;
 
-  // For mutation listeners, we need to update the global bit on the DOM window.
-  // Otherwise we won't actually fire the mutation event.
-  if (aType >= NS_MUTATION_START && aType <= NS_MUTATION_END) {
+  if (aType == NS_AFTERPAINT) {
+    mMayHavePaintEventListener = PR_TRUE;
+    nsPIDOMWindow* window = GetInnerWindowForTarget();
+    if (window) {
+      window->SetHasPaintEventListeners();
+    }
+  } else if (aType >= NS_MUTATION_START && aType <= NS_MUTATION_END) {
+    // For mutation listeners, we need to update the global bit on the DOM window.
+    // Otherwise we won't actually fire the mutation event.
     mMayHaveMutationListeners = PR_TRUE;
     // Go from our target to the nearest enclosing DOM window.
-    nsCOMPtr<nsPIDOMWindow> window;
-    nsCOMPtr<nsIDocument> document;
-    nsCOMPtr<nsINode> node(do_QueryInterface(mTarget));
-    if (node) {
-      // XXX sXBL/XBL2 issue -- do we really want the owner here?  What
-      // if that's the XBL document?
-      document = node->GetOwnerDoc();
-      if (document) {
-        window = document->GetInnerWindow();
-      }
-    }
-
-    if (!window) {
-      window = do_QueryInterface(mTarget);
-    }
+    nsPIDOMWindow* window = GetInnerWindowForTarget();
     if (window) {
-      NS_ASSERTION(window->IsInnerWindow(),
-                   "Setting mutation listener bits on outer window?");
       // If aType is NS_MUTATION_SUBTREEMODIFIED, we need to listen all
       // mutations. nsContentUtils::HasMutationListeners relies on this.
       window->SetMutationListeners((aType == NS_MUTATION_SUBTREEMODIFIED) ?
                                    kAllMutationBits :
                                    MutationBitForEventType(aType));
     }
   }
 
diff -r 4b060ed856e0 content/events/src/nsEventListenerManager.h
--- a/content/events/src/nsEventListenerManager.h	Tue Oct 14 17:12:28 2008 -0700
+++ b/content/events/src/nsEventListenerManager.h	Thu Oct 16 21:24:48 2008 -0500
@@ -186,24 +186,20 @@ protected:
                                nsIDOMEvent** aDOMEvent);
   PRBool PrepareToUseCaretPosition(nsIWidget* aEventWidget,
                                    nsIPresShell* aShell,
                                    nsPoint& aTargetPt);
   void GetCoordinatesFor(nsIDOMElement *aCurrentEl, nsPresContext *aPresContext,
                          nsIPresShell *aPresShell, nsPoint& aTargetPt);
   nsresult GetDOM2EventGroup(nsIDOMEventGroup** aGroup);
   PRBool ListenerCanHandle(nsListenerStruct* aLs, nsEvent* aEvent);
+  nsPIDOMWindow* GetInnerWindowForTarget();
 
   nsAutoTObserverArray<nsListenerStruct, 2> mListeners;
   nsISupports*                              mTarget;  //WEAK
-  PRUint32                                  mMayHaveMutationListeners : 1;
-  // These two member variables are used to cache the information
-  // about the last event which was handled but for which event listener manager
-  // didn't have event listeners.
-  PRUint32                                  mNoListenerForEvent : 31;
   nsCOMPtr<nsIAtom>                         mNoListenerForEventAtom;
 
   static PRUint32                           mInstanceCount;
   static jsval                              sAddListenerID;
 
   friend class nsEventTargetChainItem;
   static PRUint32                           sCreatedCount;
 };
diff -r 4b060ed856e0 content/events/src/nsQueryContentEventHandler.cpp
--- a/content/events/src/nsQueryContentEventHandler.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/content/events/src/nsQueryContentEventHandler.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -203,19 +203,20 @@ nsQueryContentEventHandler::GenerateFlat
     AppendSubString(aString, content, aRange->StartOffset(),
                     aRange->EndOffset() - aRange->StartOffset());
     ConvertToNativeNewlines(aString);
     return NS_OK;
   }
 
   nsAutoString tmpStr;
   for (; !iter->IsDone(); iter->Next()) {
-    nsIContent* content = iter->GetCurrentNode();
-    if (!content)
+    nsINode* node = iter->GetCurrentNode();
+    if (!node || !node->IsNodeOfType(nsINode::eCONTENT))
       continue;
+    nsIContent* content = static_cast<nsIContent*>(node);
 
     if (content->IsNodeOfType(nsINode::eTEXT)) {
       if (content == startNode)
         AppendSubString(aString, content, aRange->StartOffset(),
                         content->TextLength() - aRange->StartOffset());
       else if (content == endNode)
         AppendSubString(aString, content, 0, aRange->EndOffset());
       else
@@ -284,21 +285,22 @@ nsQueryContentEventHandler::SetRangeFrom
   NS_ASSERTION(iter, "NS_NewContentIterator succeeded, but the result is null");
   rv = iter->Init(mRootContent);
   NS_ENSURE_SUCCESS(rv, rv);
   nsCOMPtr<nsIDOMRange> domRange(do_QueryInterface(aRange));
   NS_ASSERTION(domRange, "aRange doesn't have nsIDOMRange!");
 
   PRUint32 nativeOffset = 0;
   PRUint32 nativeEndOffset = aNativeOffset + aNativeLength;
-  nsIContent* content = nsnull;
+  nsCOMPtr<nsIContent> content;
   for (; !iter->IsDone(); iter->Next()) {
-    content = iter->GetCurrentNode();
-    if (!content)
+    nsINode* node = iter->GetCurrentNode();
+    if (!node || !node->IsNodeOfType(nsINode::eCONTENT))
       continue;
+    nsIContent* content = static_cast<nsIContent*>(node);
 
     PRUint32 nativeTextLength;
     nativeTextLength = GetNativeTextLength(content);
     if (nativeTextLength == 0)
       continue;
 
     if (nativeOffset <= aNativeOffset &&
         aNativeOffset < nativeOffset + nativeTextLength) {
diff -r 4b060ed856e0 content/events/test/Makefile.in
--- a/content/events/test/Makefile.in	Tue Oct 14 17:12:28 2008 -0700
+++ b/content/events/test/Makefile.in	Thu Oct 16 21:24:48 2008 -0500
@@ -57,16 +57,17 @@ _TEST_FILES = \
 		test_bug379120.html \
 		test_bug391568.xhtml \
 		test_bug402089.html \
 		test_bug405632.html \
 		test_bug409604.html \
 		test_bug412567.html \
 		test_bug443985.html \
 		test_bug447736.html \
+		test_bug456273.html \
 		test_draggableprop.html \
 		test_dragstart.html \
 		$(NULL)
 
 _CHROME_FILES = \
 		test_bug415498.xul \
 		bug415498-doc1.html \
 		bug415498-doc2.html \
diff -r 4b060ed856e0 content/events/test/test_bug456273.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/events/test/test_bug456273.html	Thu Oct 16 21:24:48 2008 -0500
@@ -0,0 +1,43 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=456273
+-->
+<head>
+  <title>Test for Bug 456273</title>
+  <script type="application/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=456273">Mozilla Bug 456273</a>
+<p id="display">PASS if Firefox does not crash.</p>
+<div id="content" style="display: none">
+  
+</div>
+
+<div id="edit456273" contenteditable="true">text</div>
+
+<pre id="test">
+<script type="application/javascript">
+
+/** Test for Bug 456273 **/
+
+function doTest() {
+  netscape.security.PrivilegeManager.enablePrivilege('UniversalXPConnect');
+
+  var ev = document.createEvent('KeyEvents');
+  ev.initKeyEvent("keypress", true, true, null, true, false,
+                 false, false, 0, "z".charCodeAt(0));
+  document.getElementById('edit456273').dispatchEvent(ev);
+  ok(true, "PASS");
+  SimpleTest.finish();
+}
+
+SimpleTest.waitForExplicitFinish();
+addLoadEvent(doTest);
+
+</script>
+</pre>
+</body>
+</html>
diff -r 4b060ed856e0 content/html/document/src/nsWyciwygChannel.cpp
--- a/content/html/document/src/nsWyciwygChannel.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/content/html/document/src/nsWyciwygChannel.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -76,16 +76,17 @@ NS_IMPL_ISUPPORTS6(nsWyciwygChannel,
                    nsICacheListener, 
                    nsIWyciwygChannel)
 
 nsresult
 nsWyciwygChannel::Init(nsIURI* uri)
 {
   NS_ENSURE_ARG_POINTER(uri);
   mURI = uri;
+  mOriginalURI = uri;
   return NS_OK;
 }
 
 ///////////////////////////////////////////////////////////////////////////////
 // nsIRequest methods:
 ///////////////////////////////////////////////////////////////////////////////
 
 NS_IMETHODIMP
@@ -171,27 +172,29 @@ nsWyciwygChannel::GetLoadFlags(PRUint32 
 ////////////////////////////////////////////////////////////////////////////////
 // nsIChannel methods:
 ///////////////////////////////////////////////////////////////////////////////
 
 NS_IMETHODIMP
 nsWyciwygChannel::GetOriginalURI(nsIURI* *aURI)
 {
   // Let's hope this isn't called before mOriginalURI is set or we will
-  // return the full wyciwyg URI for our originalURI  :S
-  NS_ASSERTION(mOriginalURI, "nsWyciwygChannel::GetOriginalURI - mOriginalURI not set!\n");
-
-  *aURI = mOriginalURI ? mOriginalURI : mURI;
-  NS_IF_ADDREF(*aURI);
+  // return the full wyciwyg URI for our originalURI :S
+  NS_ASSERTION(mOriginalURI != mURI,
+               "nsWyciwygChannel::GetOriginalURI - mOriginalURI not set!\n");
+  
+  *aURI = mOriginalURI;
+  NS_ADDREF(*aURI);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsWyciwygChannel::SetOriginalURI(nsIURI* aURI)
 {
+  NS_ENSURE_ARG_POINTER(aURI);
   mOriginalURI = aURI;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsWyciwygChannel::GetURI(nsIURI* *aURI)
 {
   *aURI = mURI;
diff -r 4b060ed856e0 content/media/video/src/nsAudioStream.cpp
--- a/content/media/video/src/nsAudioStream.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/content/media/video/src/nsAudioStream.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -37,17 +37,17 @@
  * ***** END LICENSE BLOCK ***** */
 #include <stdio.h>
 #include <math.h>
 #include "prlog.h"
 #include "prmem.h"
 #include "nsAutoPtr.h"
 #include "nsAudioStream.h"
 extern "C" {
-#include "oggplay_audio/sydney_audio.h"
+#include "sydneyaudio/sydney_audio.h"
 }
 
 #ifdef PR_LOGGING
 PRLogModuleInfo* gAudioStreamLog = nsnull;
 #endif
 
 nsresult nsAudioStream::InitLibrary()
 {
diff -r 4b060ed856e0 content/svg/content/src/nsSVGFilters.cpp
--- a/content/svg/content/src/nsSVGFilters.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/content/svg/content/src/nsSVGFilters.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -66,19 +66,21 @@
 #include "nsNetUtil.h"
 #include "nsSVGAnimatedPreserveAspectRatio.h"
 #include "nsSVGPreserveAspectRatio.h"
 #include "nsIInterfaceRequestorUtils.h"
 #include "nsSVGMatrix.h"
 #include "nsSVGFilterElement.h"
 #include "nsSVGString.h"
 
-#if defined(XP_WIN)
+#if defined(XP_WIN) 
 // Prevent Windows redefining LoadImage
+#ifndef WINCE
 #undef LoadImage
+#endif
 #endif
 
 static void
 CopyDataRect(PRUint8 *aDest, const PRUint8 *aSrc, PRUint32 aStride,
              const nsIntRect& aDataRect)
 {
   for (PRInt32 y = aDataRect.y; y < aDataRect.YMost(); y++) {
     memcpy(aDest + y * aStride + 4 * aDataRect.x,
diff -r 4b060ed856e0 content/xbl/src/nsXBLContentSink.cpp
--- a/content/xbl/src/nsXBLContentSink.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/content/xbl/src/nsXBLContentSink.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -113,93 +113,92 @@ nsXBLContentSink::Init(nsIDocument* aDoc
 
 void
 nsXBLContentSink::MaybeStartLayout(PRBool aIgnorePendingSheets)
 {
   return;
 }
 
 nsresult
-nsXBLContentSink::FlushText()
+nsXBLContentSink::FlushText(PRBool aReleaseTextNode)
 {
-  if (mTextLength == 0) {
-    return NS_OK;
-  }
-
-  const nsASingleFragmentString& text = Substring(mText, mText+mTextLength);
-  if (mState == eXBL_InHandlers) {
-    NS_ASSERTION(mBinding, "Must have binding here");
-    // Get the text and add it to the event handler.
-    if (mSecondaryState == eXBL_InHandler)
-      mHandler->AppendHandlerText(text);
-    mTextLength = 0;
-    return NS_OK;
-  }
-  else if (mState == eXBL_InImplementation) {
-    NS_ASSERTION(mBinding, "Must have binding here");
-    if (mSecondaryState == eXBL_InConstructor ||
-        mSecondaryState == eXBL_InDestructor) {
-      // Construct a method for the constructor/destructor.
-      nsXBLProtoImplMethod* method;
-      if (mSecondaryState == eXBL_InConstructor)
-        method = mBinding->GetConstructor();
-      else
-        method = mBinding->GetDestructor();
-
-      // Get the text and add it to the constructor/destructor.
-      method->AppendBodyText(text);
-    }
-    else if (mSecondaryState == eXBL_InGetter ||
-             mSecondaryState == eXBL_InSetter) {
-      // Get the text and add it to the getter/setter
-      if (mSecondaryState == eXBL_InGetter)
-        mProperty->AppendGetterText(text);
-      else
-        mProperty->AppendSetterText(text);
-    }
-    else if (mSecondaryState == eXBL_InBody) {
-      // Get the text and add it to the method
-      if (mMethod)
-        mMethod->AppendBodyText(text);
-    }
-    else if (mSecondaryState == eXBL_InField) {
-      // Get the text and add it to the method
-      mField->AppendFieldText(text);
-    }
-    mTextLength = 0;
-    return NS_OK;
-  }
-
-  nsIContent* content = GetCurrentContent();
-  if (content &&
-      (content->NodeInfo()->NamespaceEquals(kNameSpaceID_XBL) ||
-       (content->NodeInfo()->NamespaceEquals(kNameSpaceID_XUL) &&
-        content->Tag() != nsGkAtoms::label &&
-        content->Tag() != nsGkAtoms::description))) {
-
-    PRBool isWS = PR_TRUE;
-    if (mTextLength > 0) {
-      const PRUnichar* cp = mText;
-      const PRUnichar* end = mText + mTextLength;
-      while (cp < end) {
-        PRUnichar ch = *cp++;
-        if (!XP_IS_SPACE(ch)) {
-          isWS = PR_FALSE;
-          break;
-        }
-      }
-    }
-
-    if (isWS && mTextLength > 0) {
+  if (mTextLength != 0) {
+    const nsASingleFragmentString& text = Substring(mText, mText+mTextLength);
+    if (mState == eXBL_InHandlers) {
+      NS_ASSERTION(mBinding, "Must have binding here");
+      // Get the text and add it to the event handler.
+      if (mSecondaryState == eXBL_InHandler)
+        mHandler->AppendHandlerText(text);
       mTextLength = 0;
       return NS_OK;
     }
+    else if (mState == eXBL_InImplementation) {
+      NS_ASSERTION(mBinding, "Must have binding here");
+      if (mSecondaryState == eXBL_InConstructor ||
+          mSecondaryState == eXBL_InDestructor) {
+        // Construct a method for the constructor/destructor.
+        nsXBLProtoImplMethod* method;
+        if (mSecondaryState == eXBL_InConstructor)
+          method = mBinding->GetConstructor();
+        else
+          method = mBinding->GetDestructor();
+
+        // Get the text and add it to the constructor/destructor.
+        method->AppendBodyText(text);
+      }
+      else if (mSecondaryState == eXBL_InGetter ||
+               mSecondaryState == eXBL_InSetter) {
+        // Get the text and add it to the getter/setter
+        if (mSecondaryState == eXBL_InGetter)
+          mProperty->AppendGetterText(text);
+        else
+          mProperty->AppendSetterText(text);
+      }
+      else if (mSecondaryState == eXBL_InBody) {
+        // Get the text and add it to the method
+        if (mMethod)
+          mMethod->AppendBodyText(text);
+      }
+      else if (mSecondaryState == eXBL_InField) {
+        // Get the text and add it to the method
+        mField->AppendFieldText(text);
+      }
+      mTextLength = 0;
+      return NS_OK;
+    }
+
+    nsIContent* content = GetCurrentContent();
+    if (content &&
+        (content->NodeInfo()->NamespaceEquals(kNameSpaceID_XBL) ||
+         (content->NodeInfo()->NamespaceEquals(kNameSpaceID_XUL) &&
+          content->Tag() != nsGkAtoms::label &&
+          content->Tag() != nsGkAtoms::description))) {
+
+      PRBool isWS = PR_TRUE;
+      if (mTextLength > 0) {
+        const PRUnichar* cp = mText;
+        const PRUnichar* end = mText + mTextLength;
+        while (cp < end) {
+          PRUnichar ch = *cp++;
+          if (!XP_IS_SPACE(ch)) {
+            isWS = PR_FALSE;
+            break;
+          }
+        }
+      }
+
+      if (isWS && mTextLength > 0) {
+        mTextLength = 0;
+        // Make sure to drop the textnode, if any
+        return nsXMLContentSink::FlushText(aReleaseTextNode);
+      }
+    }
   }
 
-  return nsXMLContentSink::FlushText();
+  return nsXMLContentSink::FlushText(aReleaseTextNode);
 }
 
 NS_IMETHODIMP
 nsXBLContentSink::ReportError(const PRUnichar* aErrorText, 
                               const PRUnichar* aSourceText,
                               nsIScriptError *aError,
                               PRBool *_retval)
 {
diff -r 4b060ed856e0 content/xbl/src/nsXBLContentSink.h
--- a/content/xbl/src/nsXBLContentSink.h	Tue Oct 14 17:12:28 2008 -0700
+++ b/content/xbl/src/nsXBLContentSink.h	Thu Oct 16 21:24:48 2008 -0500
@@ -141,17 +141,17 @@ protected:
     void ConstructImplementation(const PRUnichar **aAtts);
     void ConstructProperty(const PRUnichar **aAtts);
     void ConstructMethod(const PRUnichar **aAtts);
     void ConstructParameter(const PRUnichar **aAtts);
     void ConstructField(const PRUnichar **aAtts, PRUint32 aLineNumber);
   
 
   // nsXMLContentSink overrides
-  nsresult FlushText();
+  nsresult FlushText(PRBool aReleaseTextNode = PR_TRUE);
 
   // nsIExpatSink overrides
   NS_IMETHOD ReportError(const PRUnichar* aErrorText,
                          const PRUnichar* aSourceText,
                          nsIScriptError *aError,
                          PRBool *_retval);
 
 protected:
diff -r 4b060ed856e0 content/xbl/src/nsXBLWindowKeyHandler.cpp
--- a/content/xbl/src/nsXBLWindowKeyHandler.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/content/xbl/src/nsXBLWindowKeyHandler.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -369,29 +369,30 @@ nsXBLWindowKeyHandler::WalkHandlers(nsID
     if (root) {
       nsCOMPtr<nsIFocusController> fc;
       root->GetFocusController(getter_AddRefs(fc));
       if (fc) {
         fc->GetControllers(getter_AddRefs(controllers));
       }
     }
 
-    PRBool handled;
+    PRBool handled = PR_FALSE;
     if (aEventType == nsGkAtoms::keypress) {
-      nsContentUtils::DOMEventToNativeKeyEvent(aKeyEvent, &nativeEvent, PR_TRUE);
-      handled = sNativeEditorBindings->KeyPress(nativeEvent,
-                                                DoCommandCallback, controllers);
+      if (nsContentUtils::DOMEventToNativeKeyEvent(aKeyEvent, &nativeEvent, PR_TRUE))
+        handled = sNativeEditorBindings->KeyPress(nativeEvent,
+                                                  DoCommandCallback, controllers);
     } else if (aEventType == nsGkAtoms::keyup) {
-      nsContentUtils::DOMEventToNativeKeyEvent(aKeyEvent, &nativeEvent, PR_FALSE);
-      handled = sNativeEditorBindings->KeyUp(nativeEvent,
-                                             DoCommandCallback, controllers);
+      if (nsContentUtils::DOMEventToNativeKeyEvent(aKeyEvent, &nativeEvent, PR_FALSE))
+        handled = sNativeEditorBindings->KeyUp(nativeEvent,
+                                               DoCommandCallback, controllers);
     } else {
-      nsContentUtils::DOMEventToNativeKeyEvent(aKeyEvent, &nativeEvent, PR_FALSE);
-      handled = sNativeEditorBindings->KeyDown(nativeEvent,
-                                               DoCommandCallback, controllers);
+      NS_ASSERTION(aEventType == nsGkAtoms::keydown, "unknown key event type");
+      if (nsContentUtils::DOMEventToNativeKeyEvent(aKeyEvent, &nativeEvent, PR_FALSE))
+        handled = sNativeEditorBindings->KeyDown(nativeEvent,
+                                                 DoCommandCallback, controllers);
     }
 
     if (handled)
       aKeyEvent->PreventDefault();
 
   }
   
   return NS_OK;
diff -r 4b060ed856e0 content/xml/document/src/nsXMLContentSink.cpp
--- a/content/xml/document/src/nsXMLContentSink.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/content/xml/document/src/nsXMLContentSink.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -822,32 +822,66 @@ nsXMLContentSink::SetDocumentCharset(nsA
 
 nsISupports *
 nsXMLContentSink::GetTarget()
 {
   return mDocument;
 }
 
 nsresult
-nsXMLContentSink::FlushText()
+nsXMLContentSink::FlushText(PRBool aReleaseTextNode)
 {
-  if (mTextLength == 0) {
-    return NS_OK;
+  nsresult rv = NS_OK;
+
+  if (mTextLength != 0) {
+    if (mLastTextNode) {
+      if ((mLastTextNodeSize + mTextLength) > mTextSize && !mXSLTProcessor) {
+        mLastTextNodeSize = 0;
+        mLastTextNode = nsnull;
+        FlushText(aReleaseTextNode);
+      } else {
+        PRBool notify = HaveNotifiedForCurrentContent();
+        // We could probably always increase mInNotification here since
+        // if AppendText doesn't notify it shouldn't trigger evil code.
+        // But just in case it does, we don't want to mask any notifications.
+        if (notify) {
+          ++mInNotification;
+        }
+        rv = mLastTextNode->AppendText(mText, mTextLength, notify);
+        if (notify) {
+          --mInNotification;
+        }
+
+        mLastTextNodeSize += mTextLength;
+        mTextLength = 0;
+      }
+    } else {
+      nsCOMPtr<nsIContent> textContent;
+      rv = NS_NewTextNode(getter_AddRefs(textContent),
+                          mNodeInfoManager);
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      mLastTextNode = textContent;
+      
+      // Set the text in the text node
+      textContent->SetText(mText, mTextLength, PR_FALSE);
+      mLastTextNodeSize += mTextLength;
+      mTextLength = 0;
+
+      // Add text to its parent
+      rv = AddContentAsLeaf(textContent);
+    }
   }
 
-  nsCOMPtr<nsIContent> textContent;
-  nsresult rv = NS_NewTextNode(getter_AddRefs(textContent), mNodeInfoManager);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  // Set the text in the text node
-  textContent->SetText(mText, mTextLength, PR_FALSE);
-  mTextLength = 0;
-
-  // Add text to its parent
-  return AddContentAsLeaf(textContent);
+  if (aReleaseTextNode) {
+    mLastTextNodeSize = 0;
+    mLastTextNode = nsnull;
+  }
+  
+  return rv;
 }
 
 nsIContent*
 nsXMLContentSink::GetCurrentContent()
 {
   if (mContentStack.Length() == 0) {
     return nsnull;
   }
@@ -1576,17 +1610,17 @@ nsXMLContentSink::FlushPendingNotificati
 {
   // Only flush tags if we're not doing the notification ourselves
   // (since we aren't reentrant)
   if (!mInNotification) {
     if (aType >= Flush_ContentAndNotify) {
       FlushTags();
     }
     else {
-      FlushText();
+      FlushText(PR_FALSE);
     }
     if (aType >= Flush_Layout) {
       // Make sure that layout has started so that the reflow flush
       // will actually happen.
       MaybeStartLayout(PR_TRUE);
     }
   }
 }
@@ -1610,17 +1644,17 @@ nsXMLContentSink::FlushTags()
   mUpdatesInNotification = 0;
   ++mInNotification;
   {
     // Scope so we call EndUpdate before we decrease mInNotification
     mozAutoDocUpdate updateBatch(mDocument, UPDATE_CONTENT_MODEL, PR_TRUE);
     mBeganUpdate = PR_TRUE;
 
     // Don't release last text node in case we need to add to it again
-    FlushText();
+    FlushText(PR_FALSE);
 
     // Start from the base of the stack (growing downward) and do
     // a notification from the node that is closest to the root of
     // tree for any content that has been added.
 
     PRInt32 stackPos;
     PRInt32 stackLen = mContentStack.Length();
     PRBool flushed = PR_FALSE;
diff -r 4b060ed856e0 content/xml/document/src/nsXMLContentSink.h
--- a/content/xml/document/src/nsXMLContentSink.h	Tue Oct 14 17:12:28 2008 -0700
+++ b/content/xml/document/src/nsXMLContentSink.h	Thu Oct 16 21:24:48 2008 -0500
@@ -137,17 +137,17 @@ protected:
                                  nsINodeInfo* aNodeInfo, PRUint32 aLineNumber,
                                  nsIContent** aResult, PRBool* aAppendContent,
                                  PRBool aFromParser);
 
   // aParent is allowed to be null here if this is the root content
   // being closed
   virtual nsresult CloseElement(nsIContent* aContent);
 
-  virtual nsresult FlushText();
+  virtual nsresult FlushText(PRBool aReleaseTextNode = PR_TRUE);
 
   nsresult AddContentAsLeaf(nsIContent *aContent);
 
   nsIContent* GetCurrentContent();
   StackNode & GetCurrentStackNode();
   nsresult PushContent(nsIContent *aContent);
   void PopContent();
   PRBool HaveNotifiedForCurrentContent() const;
@@ -194,16 +194,18 @@ protected:
   PRUnichar*       mText;
 
   XMLContentSinkState mState;
 
   PRInt32 mTextLength;
   PRInt32 mTextSize;
   
   PRInt32 mNotifyLevel;
+  nsCOMPtr<nsIContent> mLastTextNode;
+  PRInt32 mLastTextNodeSize;
 
   PRUint8 mConstrainSize : 1;
   PRUint8 mPrettyPrintXML : 1;
   PRUint8 mPrettyPrintHasSpecialRoot : 1;
   PRUint8 mPrettyPrintHasFactoredElements : 1;
   PRUint8 mHasProcessedBase : 1;
   PRUint8 mAllowAutoXLinks : 1;
   PRUint8 mPrettyPrinting : 1;  // True if we called PrettyPrint() and it
diff -r 4b060ed856e0 dom/public/base/nsPIDOMWindow.h
--- a/dom/public/base/nsPIDOMWindow.h	Tue Oct 14 17:12:28 2008 -0700
+++ b/dom/public/base/nsPIDOMWindow.h	Thu Oct 16 21:24:48 2008 -0500
@@ -71,18 +71,18 @@ class nsIDocument;
 class nsIDocument;
 class nsIScriptTimeoutHandler;
 class nsPresContext;
 struct nsTimeout;
 class nsScriptObjectHolder;
 class nsXBLPrototypeHandler;
 
 #define NS_PIDOMWINDOW_IID \
-{ 0x909852b5, 0xb9e6, 0x4d94, \
-  { 0x8d, 0xe3, 0x05, 0x16, 0x34, 0x80, 0x0b, 0x73 } }
+{ 0x3d2b6b38, 0x810d, 0x4ac5, \
+  { 0x81, 0x7c, 0xb9, 0x70, 0x81, 0x80, 0x4d, 0x9f } }
 
 class nsPIDOMWindow : public nsIDOMWindowInternal
 {
 public:
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_PIDOMWINDOW_IID)
 
   virtual nsPIDOMWindow* GetPrivateRoot() = 0;
 
@@ -375,16 +375,34 @@ public:
   }
 
   PRBool IsModalContentWindow() const
   {
     return mIsModalContentWindow;
   }
 
   /**
+   * Call this to indicate that some node (this window, its document,
+   * or content in that document) has a paint event listener.
+   */
+  void SetHasPaintEventListeners()
+  {
+    mMayHavePaintEventListener = PR_TRUE;
+  }
+
+  /**
+   * Call this to check whether some node (this window, its document,
+   * or content in that document) has a paint event listener.
+   */
+  PRBool HasPaintEventListeners()
+  {
+    return mMayHavePaintEventListener;
+  }
+  
+  /**
    * Initialize window.java and window.Packages, and start LiveConnect
    * if we're running with a non-NPRuntime enabled Java plugin.
    */
   virtual void InitJavaProperties() = 0;
 
   virtual void* GetCachedXBLPrototypeHandler(nsXBLPrototypeHandler* aKey) = 0;
   virtual void CacheXBLPrototypeHandler(nsXBLPrototypeHandler* aKey,
                                         nsScriptObjectHolder& aHandler) = 0;
@@ -393,16 +411,17 @@ protected:
   // The nsPIDOMWindow constructor. The aOuterWindow argument should
   // be null if and only if the created window itself is an outer
   // window. In all other cases aOuterWindow should be the outer
   // window for the inner window that is being created.
   nsPIDOMWindow(nsPIDOMWindow *aOuterWindow)
     : mFrameElement(nsnull), mDocShell(nsnull), mModalStateDepth(0),
       mRunningTimeout(nsnull), mMutationBits(0), mIsDocumentLoaded(PR_FALSE),
       mIsHandlingResizeEvent(PR_FALSE), mIsInnerWindow(aOuterWindow != nsnull),
+      mMayHavePaintEventListener(PR_FALSE),
       mIsModalContentWindow(PR_FALSE), mInnerWindow(nsnull),
       mOuterWindow(aOuterWindow)
   {
   }
 
   void SetChromeEventHandlerInternal(nsPIDOMEventTarget* aChromeEventHandler) {
     mChromeEventHandler = aChromeEventHandler;
   }
@@ -422,16 +441,17 @@ protected:
   // These variables are only used on inner windows.
   nsTimeout             *mRunningTimeout;
 
   PRUint32               mMutationBits;
 
   PRPackedBool           mIsDocumentLoaded;
   PRPackedBool           mIsHandlingResizeEvent;
   PRPackedBool           mIsInnerWindow;
+  PRPackedBool           mMayHavePaintEventListener;
 
   // This variable is used on both inner and outer windows (and they
   // should match).
   PRPackedBool           mIsModalContentWindow;
 
   // And these are the references between inner and outer windows.
   nsPIDOMWindow         *mInnerWindow;
   nsPIDOMWindow         *mOuterWindow;
diff -r 4b060ed856e0 dom/src/threads/nsDOMThreadService.cpp
--- a/dom/src/threads/nsDOMThreadService.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/dom/src/threads/nsDOMThreadService.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -315,17 +315,17 @@ public:
 
   NS_IMETHOD Run() {
     // This must have been set up by the thread service
     NS_ASSERTION(gJSContextIndex != BAD_TLS_INDEX, "No context index!");
 
     // Make sure we have a JSContext to run everything on.
     JSContext* cx = (JSContext*)PR_GetThreadPrivate(gJSContextIndex);
     NS_ASSERTION(cx, "nsDOMThreadService didn't give us a context!");
-  
+
     JS_SetContextPrivate(cx, mWorker);
 
     // Tell the worker which context it will be using
     if (mWorker->SetGlobalForContext(cx)) {
       RunQueue();
 
       // Remove the global object from the context so that it might be garbage
       // collected.
@@ -342,16 +342,19 @@ public:
     }
 
     return NS_OK;
   }
 
 protected:
 
   void RunQueue() {
+    JSContext* cx = (JSContext*)PR_GetThreadPrivate(gJSContextIndex);
+    NS_ASSERTION(cx, "nsDOMThreadService didn't give us a context!");
+
     while (1) {
       nsCOMPtr<nsIRunnable> runnable;
       {
         nsAutoMonitor mon(gDOMThreadService->mMonitor);
 
         runnable = dont_AddRef((nsIRunnable*)mRunnables.PopFront());
 
         if (!runnable || mWorker->IsCanceled()) {
@@ -361,16 +364,19 @@ protected:
                  static_cast<void*>(mWorker.get())));
           }
 #endif
           gDOMThreadService->WorkerComplete(this);
           mon.NotifyAll();
           return;
         }
       }
+
+      // Clear out any old cruft hanging around in the regexp statics.
+      JS_ClearRegExpStatics(cx);
 
 #ifdef DEBUG
       nsresult rv =
 #endif
       runnable->Run();
       NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "Runnable failed!");
     }
   }
diff -r 4b060ed856e0 dom/src/threads/nsDOMWorkerSecurityManager.cpp
--- a/dom/src/threads/nsDOMWorkerSecurityManager.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/dom/src/threads/nsDOMWorkerSecurityManager.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -84,24 +84,26 @@ nsDOMWorkerSecurityManager::CanCreateWra
 {
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsDOMWorkerSecurityManager::CanCreateInstance(JSContext* aJSContext,
                                               const nsCID& aCID)
 {
-  return NS_OK;
+  NS_NOTREACHED("Should not call this!");
+  return NS_ERROR_UNEXPECTED;
 }
 
 NS_IMETHODIMP
 nsDOMWorkerSecurityManager::CanGetService(JSContext* aJSContext,
                                           const nsCID& aCID)
 {
-  return NS_OK;
+  NS_NOTREACHED("Should not call this!");
+  return NS_ERROR_UNEXPECTED;
 }
 
 NS_IMETHODIMP
 nsDOMWorkerSecurityManager::CanAccess(PRUint32 aAction,
                                       nsAXPCNativeCallContext* aCallContext,
                                       JSContext* aJSContext,
                                       JSObject* aJSObject,
                                       nsISupports* aObj,
diff -r 4b060ed856e0 dom/src/threads/test/Makefile.in
--- a/dom/src/threads/test/Makefile.in	Tue Oct 14 17:12:28 2008 -0700
+++ b/dom/src/threads/test/Makefile.in	Thu Oct 16 21:24:48 2008 -0500
@@ -52,14 +52,16 @@ _TEST_FILES = \
   importScripts_worker_imported2.js \
   importScripts_worker_imported3.js \
   importScripts_worker_imported4.js \
   test_importScripts.html \
   test_simpleThread.html \
   test_threadErrors.html \
   test_threadTimeouts.html \
   test_longThread.html \
+  test_recursion.html \
+  test_regExpStatics.html \
   test_xhr.html \
   testXHR.txt \
   $(NULL)
 
 libs:: $(_TEST_FILES)
 	$(INSTALL) $(foreach f,$^,"$f") $(DEPTH)/_tests/testing/mochitest/tests/$(relativesrcdir)
diff -r 4b060ed856e0 dom/src/threads/test/test_recursion.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/src/threads/test/test_recursion.html	Thu Oct 16 21:24:48 2008 -0500
@@ -0,0 +1,52 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+Tests of DOM Worker Threads
+-->
+<head>
+  <title>Test for DOM Worker Threads Recursion</title>
+  <script type="text/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+<p id="display"></p>
+<div id="content" style="display: none">
+
+</div>
+<pre id="test">
+<script class="testbody" type="text/javascript">
+
+  function workerScript() {
+    function recurse() {
+      recurse();
+    }
+
+    this.messageListener = function(message, source) {
+      switch (message) {
+        case "start":
+          recurse();
+          break;
+        default:
+      }
+    }
+  }
+
+  var pool = navigator.newWorkerPool();
+
+  pool.errorListener = function(error, source) {
+    is(error.message,
+       '[JavaScript Error: "too much recursion" {file: "DOMWorker inline ' +
+       'script" line: 4}]');
+    SimpleTest.finish();
+  }
+
+  var worker = pool.createWorker("(" + workerScript + ")();");
+  worker.postMessage("start");
+
+  SimpleTest.waitForExplicitFinish();
+
+</script>
+</pre>
+</body>
+</html>
diff -r 4b060ed856e0 dom/src/threads/test/test_regExpStatics.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/src/threads/test/test_regExpStatics.html	Thu Oct 16 21:24:48 2008 -0500
@@ -0,0 +1,74 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+Tests of DOM Worker Threads RegExp statics
+-->
+<head>
+  <title>Test for DOM Worker Threads RegExp statics</title>
+  <script type="text/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+<p id="display"></p>
+<div id="content" style="display: none">
+
+</div>
+<pre id="test">
+<script class="testbody" type="text/javascript">
+
+  const WORKER_COUNT = 25;
+
+  function workerScript() {
+    var runCount = 0;
+    var timeout;
+
+    this.messageListener = function(message, source) {
+      run();
+      timeout = setTimeout(run, 0);
+      timeout = setTimeout(run, 5000);
+    };
+
+    function run() {
+      if (RegExp.$1) {
+        throw "RegExp.$1 already set!";
+        cancelTimeout(timeout);
+      }
+
+      var match = /a(sd)f/("asdf");
+      if (!RegExp.$1) {
+        throw "RegExp.$1 didn't get set!";
+        cancelTimeout(timeout);
+      }
+
+      if (++runCount == 3) {
+        postMessageToPool("done");
+      }
+    }
+  }
+
+  var pool = navigator.newWorkerPool();
+
+  var doneWorkers = 0;
+  pool.messageListener = function(message, source) {
+    if (++doneWorkers == WORKER_COUNT) {
+      SimpleTest.finish();
+    }
+  };
+
+  pool.errorListener = function(error, source) {
+    ok(false, "Worker had an error: " + error);
+    SimpleTest.finish();
+  };
+
+  for (var i = 0; i < WORKER_COUNT; i++) {
+    var worker = pool.createWorker("(" + workerScript + ")();");
+    worker.postMessage("start");
+  }
+
+  SimpleTest.waitForExplicitFinish();
+
+</script>
+</pre>
+</body>
+</html>
diff -r 4b060ed856e0 dom/tests/mochitest/dom-level1-core/test_hc_attrremovechild2.html
--- a/dom/tests/mochitest/dom-level1-core/test_hc_attrremovechild2.html	Tue Oct 14 17:12:28 2008 -0700
+++ b/dom/tests/mochitest/dom-level1-core/test_hc_attrremovechild2.html	Thu Oct 16 21:24:48 2008 -0500
@@ -77,20 +77,18 @@ function testFails (test) {
   if (!test.result) {
     test.todo = true;
     return true;
   }
   return false;
 }
 function markTodos() {
   if (todoTests[docName]) {
-    // mark the failures as todos
     var failures = filter(testFails, SimpleTest._tests);
-    // shouldn't be 0 failures
-    todo(SimpleTest._tests != 0 && failures == 0, "test marked todo should fail somewhere");
+    ok(SimpleTest._tests != 0 && failures == 0, "test failed somewhere");
   }
 }
 
 function runJSUnitTests() {
   builder = createConfiguredBuilder();
   try {
    forEach(exposeTestFunctionNames(), 
      function (testName) { 
diff -r 4b060ed856e0 editor/libeditor/html/nsHTMLEditRules.cpp
--- a/editor/libeditor/html/nsHTMLEditRules.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/editor/libeditor/html/nsHTMLEditRules.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -77,16 +77,18 @@
 #include "nsWSRunObject.h"
 
 #include "InsertTextTxn.h"
 #include "DeleteTextTxn.h"
 #include "nsReadableUtils.h"
 #include "nsUnicharUtils.h"
 
 #include "nsFrameSelection.h"
+#include "nsIDOM3Node.h"
+#include "nsContentUtils.h"
 
 //const static char* kMOZEditorBogusNodeAttr="MOZ_EDITOR_BOGUS_NODE";
 //const static char* kMOZEditorBogusNodeValue="TRUE";
 
 enum
 {
   kLonely = 0,
   kPrevSib = 1,
@@ -1993,20 +1995,44 @@ nsHTMLEditRules::WillDeleteSelection(nsI
       PRInt32 so = visOffset;
       PRInt32 eo = visOffset+1;
       if (aAction == nsIEditor::ePrevious) 
       { 
         if (so == 0) return NS_ERROR_UNEXPECTED;
         so--; 
         eo--; 
       }
+      else
+      {
+        res = mHTMLEditor->ExtendSelectionForDelete(aSelection, &aAction);
+        NS_ENSURE_SUCCESS(res, res);
+
+        nsCOMPtr<nsIDOMRange> range;
+        res = aSelection->GetRangeAt(0, getter_AddRefs(range));
+        NS_ENSURE_SUCCESS(res, res);
+
+#ifdef DEBUG
+        nsIDOMNode *container;
+
+        res = range->GetStartContainer(&container);
+        NS_ENSURE_SUCCESS(res, res);
+        NS_ASSERTION(container == visNode, "selection start not in visNode");
+
+        res = range->GetEndContainer(&container);
+        NS_ENSURE_SUCCESS(res, res);
+        NS_ASSERTION(container == visNode, "selection end not in visNode");
+#endif
+
+        res = range->GetEndOffset(&eo);
+        NS_ENSURE_SUCCESS(res, res);
+      }
       res = nsWSRunObject::PrepareToDeleteRange(mHTMLEditor, address_of(visNode), &so, address_of(visNode), &eo);
       if (NS_FAILED(res)) return res;
       nsCOMPtr<nsIDOMCharacterData> nodeAsText(do_QueryInterface(visNode));
-      res = mHTMLEditor->DeleteText(nodeAsText,so,1);
+      res = mHTMLEditor->DeleteText(nodeAsText, PR_MIN(so, eo), PR_ABS(eo - so));
       *aHandled = PR_TRUE;
       if (NS_FAILED(res)) return res;    
       res = InsertBRIfNeeded(aSelection);
       return res;
     }
     else if ( (wsType==nsWSRunObject::eSpecial)  || 
               (wsType==nsWSRunObject::eBreak)    ||
               nsHTMLEditUtils::IsHR(visNode) ) 
@@ -2473,16 +2499,30 @@ nsHTMLEditRules::WillDeleteSelection(nsI
           // delete to first character
           nsCOMPtr<nsIDOMCharacterData>nodeAsText;
           nodeAsText = do_QueryInterface(endNode);
           if (endOffset)
           {
             res = mHTMLEditor->DeleteText(nodeAsText,0,endOffset);
             if (NS_FAILED(res)) return res;
           }
+        }
+
+        PRBool join = leftBlockParent == rightBlockParent;
+        if (!join) {
+          nsCOMPtr<nsINode> parent1 = do_QueryInterface(leftParent);
+          nsCOMPtr<nsINode> parent2 = do_QueryInterface(rightParent);
+          PRUint16 pos = nsContentUtils::ComparePosition(parent1, parent2);
+          join = (pos & (nsIDOM3Node::DOCUMENT_POSITION_CONTAINS |
+                         nsIDOM3Node::DOCUMENT_POSITION_CONTAINED_BY)) != 0;
+        }
+        if (join) {
+          res = JoinBlocks(address_of(leftParent), address_of(rightParent),
+                           aCancel);
+          if (NS_FAILED(res)) return res;
         }
       }
     }
   }
   if (aAction == nsIEditor::eNext)
   {
     res = aSelection->Collapse(endNode,endOffset);
   }
diff -r 4b060ed856e0 editor/libeditor/html/nsHTMLEditor.cpp
--- a/editor/libeditor/html/nsHTMLEditor.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/editor/libeditor/html/nsHTMLEditor.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -847,17 +847,18 @@ nsHTMLEditor::GetBlockSectionsForRange(n
   nsCOMPtr<nsIContentIterator>iter =
     do_CreateInstance("@mozilla.org/content/post-content-iterator;1", &result);
   if ((NS_SUCCEEDED(result)) && iter)
   {
     nsCOMPtr<nsIDOMRange> lastRange;
     iter->Init(aRange);
     while (iter->IsDone())
     {
-      nsCOMPtr<nsIContent> currentContent = iter->GetCurrentNode();
+      nsCOMPtr<nsIContent> currentContent =
+        do_QueryInterface(iter->GetCurrentNode());
 
       nsCOMPtr<nsIDOMNode>currentNode = do_QueryInterface(currentContent);
       if (currentNode)
       {
         // <BR> divides block content ranges.  We can achieve this by nulling out lastRange
         if (currentContent->Tag() == nsEditProperty::br)
         {
           lastRange = nsnull;
@@ -3839,18 +3840,17 @@ nsHTMLEditor::GetEmbeddedObjects(nsISupp
     if (!doc)
       return NS_ERROR_UNEXPECTED;
 
     iter->Init(doc->GetRootContent());
 
     // loop through the content iterator for each content node
     while (!iter->IsDone())
     {
-      nsIContent *content = iter->GetCurrentNode();
-      nsCOMPtr<nsIDOMNode> node (do_QueryInterface(content));
+      nsCOMPtr<nsIDOMNode> node (do_QueryInterface(iter->GetCurrentNode()));
       if (node)
       {
         nsAutoString tagName;
         node->GetNodeName(tagName);
         ToLowerCase(tagName);
 
         // See if it's an image or an embed and also include all links.
         // Let mail decide which link to send or not
@@ -4545,23 +4545,20 @@ nsHTMLEditor::CollapseAdjacentTextNodes(
   nsCOMPtr<nsIContentIterator> iter =
     do_CreateInstance("@mozilla.org/content/subtree-content-iterator;1", &result);
   if (NS_FAILED(result)) return result;
 
   iter->Init(aInRange);
 
   while (!iter->IsDone())
   {
-    nsIContent *content = iter->GetCurrentNode();  
-
-    nsCOMPtr<nsIDOMCharacterData> text = do_QueryInterface(content);
-    nsCOMPtr<nsIDOMNode>          node = do_QueryInterface(content);
-    if (text && node && IsEditable(node))
-    {
-      textNodes.AppendElement(node.get());
+    nsCOMPtr<nsIDOMCharacterData> text = do_QueryInterface(iter->GetCurrentNode());
+    if (text && IsEditable(text))
+    {
+      textNodes.AppendElement(text);
     }
 
     iter->Next();
   }
 
   // now that I have a list of text nodes, collapse adjacent text nodes
   // NOTE: assumption that JoinNodes keeps the righthand node
   while (textNodes.Count() > 1)
diff -r 4b060ed856e0 editor/libeditor/html/nsHTMLEditorStyle.cpp
--- a/editor/libeditor/html/nsHTMLEditorStyle.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/editor/libeditor/html/nsHTMLEditorStyle.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -1100,17 +1100,17 @@ nsHTMLEditor::GetInlinePropertyBase(nsIA
     nsCOMPtr<nsIDOMNode> endNode;
     PRInt32 endOffset;
     result = range->GetEndContainer(getter_AddRefs(endNode));
     if (NS_FAILED(result)) return result;
     result = range->GetEndOffset(&endOffset);
     if (NS_FAILED(result)) return result;
     while (!iter->IsDone())
     {
-      nsIContent *content = iter->GetCurrentNode();
+      nsCOMPtr<nsIContent> content = do_QueryInterface(iter->GetCurrentNode());
 
       nsCOMPtr<nsIDOMNode> node = do_QueryInterface(content);
 
       if (node && nsTextEditUtils::IsBody(node))
         break;
 
       nsCOMPtr<nsIDOMCharacterData>text;
       text = do_QueryInterface(content);
diff -r 4b060ed856e0 editor/libeditor/text/nsPlaintextEditor.cpp
--- a/editor/libeditor/text/nsPlaintextEditor.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/editor/libeditor/text/nsPlaintextEditor.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -632,16 +632,73 @@ nsPlaintextEditor::GetTextSelectionOffse
   else {
     aOutStartOffset = endOffset;
     aOutEndOffset = startOffset;
   }
 
   return NS_OK;
 }
 
+nsresult
+nsPlaintextEditor::ExtendSelectionForDelete(nsISelection *aSelection,
+                                            nsIEditor::EDirection *aAction)
+{
+  nsresult result;
+
+  PRBool bCollapsed;
+  result = aSelection->GetIsCollapsed(&bCollapsed);
+  if (NS_FAILED(result)) return result;
+
+  if (*aAction == eNextWord || *aAction == ePreviousWord
+      || (*aAction == eNext && bCollapsed)
+      || *aAction == eToBeginningOfLine || *aAction == eToEndOfLine)
+  {
+    nsCOMPtr<nsISelectionController> selCont (do_QueryReferent(mSelConWeak));
+    if (!selCont)
+      return NS_ERROR_NO_INTERFACE;
+
+    switch (*aAction)
+    {
+      case eNextWord:
+        result = selCont->WordExtendForDelete(PR_TRUE);
+        // DeleteSelectionImpl doesn't handle these actions
+        // because it's inside batching, so don't confuse it:
+        *aAction = eNone;
+        break;
+      case ePreviousWord:
+        result = selCont->WordExtendForDelete(PR_FALSE);
+        *aAction = eNone;
+        break;
+      case eNext:
+        result = selCont->CharacterExtendForDelete();
+        *aAction = eNone;
+        break;
+      case ePrevious:
+        /* FIXME: extend selection over UTF-16 surrogates for Bug #332636
+         * and set *aAction = eNone
+         */
+        result = NS_OK;
+        break;
+      case eToBeginningOfLine:
+        selCont->IntraLineMove(PR_TRUE, PR_FALSE);          // try to move to end
+        result = selCont->IntraLineMove(PR_FALSE, PR_TRUE); // select to beginning
+        *aAction = eNone;
+        break;
+      case eToEndOfLine:
+        result = selCont->IntraLineMove(PR_TRUE, PR_TRUE);
+        *aAction = eNext;
+        break;
+      default:       // avoid several compiler warnings
+        result = NS_OK;
+        break;
+    }
+  }
+  return result;
+}
+
 NS_IMETHODIMP nsPlaintextEditor::DeleteSelection(nsIEditor::EDirection aAction)
 {
   if (!mRules) { return NS_ERROR_NOT_INITIALIZED; }
 
   nsresult result;
 
   // delete placeholder txns merge.
   nsAutoPlaceHolderBatch batch(this, nsGkAtoms::DeleteTxnName);
@@ -668,55 +725,16 @@ NS_IMETHODIMP nsPlaintextEditor::DeleteS
     {
       result = selection->CollapseToStart();
       if (NS_FAILED(result)) return result;
     }
     else
     { 
       aAction = eNone;
     }
-
-  // If it's one of these modes,
-  // we have to extend the selection first.
-  // This needs to happen inside selection batching,
-  // otherwise the deleted text is autocopied to the clipboard.
-  if (aAction == eNextWord || aAction == ePreviousWord
-      || aAction == eToBeginningOfLine || aAction == eToEndOfLine)
-  {
-    nsCOMPtr<nsISelectionController> selCont (do_QueryReferent(mSelConWeak));
-    if (!selCont)
-      return NS_ERROR_NO_INTERFACE;
-
-    switch (aAction)
-    {
-        case eNextWord:
-          result = selCont->WordExtendForDelete(PR_TRUE);
-          // DeleteSelectionImpl doesn't handle these actions
-          // because it's inside batching, so don't confuse it:
-          aAction = eNone;
-          break;
-        case ePreviousWord:
-          result = selCont->WordExtendForDelete(PR_FALSE);
-          aAction = eNone;
-          break;
-        case eToBeginningOfLine:
-          selCont->IntraLineMove(PR_TRUE, PR_FALSE);          // try to move to end
-          result = selCont->IntraLineMove(PR_FALSE, PR_TRUE); // select to beginning
-          aAction = eNone;
-          break;
-        case eToEndOfLine:
-          result = selCont->IntraLineMove(PR_TRUE, PR_TRUE);
-          aAction = eNext;
-          break;
-        default:       // avoid several compiler warnings
-          result = NS_OK;
-          break;
-    }
-    NS_ENSURE_SUCCESS(result, result);
-  }
 
   nsTextRulesInfo ruleInfo(nsTextEditRules::kDeleteSelection);
   ruleInfo.collapsedAction = aAction;
   PRBool cancel, handled;
   result = mRules->WillDoAction(selection, &ruleInfo, &cancel, &handled);
   if (NS_FAILED(result)) return result;
   if (!cancel && !handled)
   {
diff -r 4b060ed856e0 editor/libeditor/text/nsPlaintextEditor.h
--- a/editor/libeditor/text/nsPlaintextEditor.h	Tue Oct 14 17:12:28 2008 -0700
+++ b/editor/libeditor/text/nsPlaintextEditor.h	Thu Oct 16 21:24:48 2008 -0500
@@ -159,16 +159,24 @@ public:
                                    PRUint32 &aStartOffset, 
                                    PRUint32 &aEndOffset);
 
   nsresult InsertTextAt(const nsAString &aStringToInsert,
                         nsIDOMNode *aDestinationNode,
                         PRInt32 aDestOffset,
                         PRBool aDoDeleteSelection);
 
+  /**
+   * Extends the selection for given deletion operation
+   * If done, also update aAction to what's actually left to do after the
+   * extension.
+   */
+  nsresult ExtendSelectionForDelete(nsISelection* aSelection,
+                                    nsIEditor::EDirection *aAction);
+
 protected:
 
   NS_IMETHOD  InitRules();
   void        BeginEditorInit();
   nsresult    EndEditorInit();
 
   // Create the event listeners for the editor to install.
   virtual nsresult CreateEventListeners();
diff -r 4b060ed856e0 editor/libeditor/text/nsTextEditRules.cpp
--- a/editor/libeditor/text/nsTextEditRules.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/editor/libeditor/text/nsTextEditRules.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -918,96 +918,24 @@ nsTextEditRules::WillDeleteSelection(nsI
   
     if (bCollapsed)
     {
       // Test for distance between caret and text that will be deleted
       res = CheckBidiLevelForDeletion(aSelection, startNode, startOffset, aCollapsedAction, aCancel);
       if (NS_FAILED(res)) return res;
       if (*aCancel) return NS_OK;
 
-      nsCOMPtr<nsIDOMText> textNode;
-      PRUint32 strLength;
-      
-      // destroy any empty text nodes in our path
-      if (mEditor->IsTextNode(startNode))
-      {
-        textNode = do_QueryInterface(startNode);
-        res = textNode->GetLength(&strLength);
-        if (NS_FAILED(res)) return res;
-        // if it has a length and we aren't at the edge, we are done
-        if (strLength && !( ((aCollapsedAction == nsIEditor::ePrevious) && startOffset) ||
-                            ((aCollapsedAction == nsIEditor::eNext) && startOffset==PRInt32(strLength)) ) )
-          return NS_OK;
-        
-        // remember where we are
-        nsCOMPtr<nsIDOMNode> selNode = startNode;
-        res = nsEditor::GetNodeLocation(selNode, address_of(startNode), &startOffset);
-        if (NS_FAILED(res)) return res;
+      res = mEditor->ExtendSelectionForDelete(aSelection, &aCollapsedAction);
+      NS_ENSURE_SUCCESS(res, res);
 
-        // delete this text node if empty
-        if (!strLength)
-        {
-          // delete empty text node
-          res = mEditor->DeleteNode(selNode);
-          if (NS_FAILED(res)) return res;
-        }
-        else
-        {
-          // if text node isn't empty, but we are at end of it, remeber that we are after it
-          if (aCollapsedAction == nsIEditor::eNext)
-            startOffset++;
-        }
-      }
+      res = mEditor->DeleteSelectionImpl(aCollapsedAction);
+      NS_ENSURE_SUCCESS(res, res);
 
-      // find next node (we know we are in container here)
-      nsCOMPtr<nsIContent> child, content(do_QueryInterface(startNode));
-      if (!content) return NS_ERROR_NULL_POINTER;
-      if (aCollapsedAction == nsIEditor::ePrevious)
-        --startOffset;
-      child = content->GetChildAt(startOffset);
-
-      nsCOMPtr<nsIDOMNode> nextNode = do_QueryInterface(child);
-      
-      // scan for next node, deleting empty text nodes on way
-      while (nextNode && mEditor->IsTextNode(nextNode))
-      {
-        textNode = do_QueryInterface(nextNode);
-        if (!textNode) break;// found a br, stop there
-
-        res = textNode->GetLength(&strLength);
-        if (NS_FAILED(res)) return res;
-        if (strLength) break;  // found a non-empty text node
-        
-        // delete empty text node
-        res = mEditor->DeleteNode(nextNode);
-        if (NS_FAILED(res)) return res;
-        
-        // find next node
-        if (aCollapsedAction == nsIEditor::ePrevious)
-          --startOffset;
-          // don't need to increment startOffset for nsIEditor::eNext
-        child = content->GetChildAt(startOffset);
-
-        nextNode = do_QueryInterface(child);
-      }
-      // fix for bugzilla #125161: if we are about to forward delete a <BR>,
-      // make sure it is not last node in editfield.  If it is, cancel deletion.
-      if (nextNode && (aCollapsedAction == nsIEditor::eNext) && nsTextEditUtils::IsBreak(nextNode))
-      {
-        nsIDOMNode *body = mEditor->GetRoot();
-        if (!body)
-          return NS_ERROR_NULL_POINTER;
-        nsCOMPtr<nsIDOMNode> lastChild;
-        res = body->GetLastChild(getter_AddRefs(lastChild));
-        if (lastChild == nextNode)
-        {
-          *aCancel = PR_TRUE;
-          return NS_OK;
-        }
-      }
+      *aHandled = PR_TRUE;
+      return NS_OK;
     }
   }
 
   return res;
 }
 
 nsresult
 nsTextEditRules::DidDeleteSelection(nsISelection *aSelection, 
diff -r 4b060ed856e0 editor/libeditor/text/nsTextEditRulesBidi.cpp
--- a/editor/libeditor/text/nsTextEditRulesBidi.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/editor/libeditor/text/nsTextEditRulesBidi.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -90,17 +90,19 @@ nsTextEditRules::CheckBidiLevelForDeleti
     GetPrevNextBidiLevels(content, aSelOffset, PR_TRUE);
     
   levelBefore = levels.mLevelBefore;
   levelAfter = levels.mLevelAfter;
 
   PRUint8 currentCaretLevel = frameSelection->GetCaretBidiLevel();
 
   PRUint8 levelOfDeletion;
-  levelOfDeletion = (nsIEditor::eNext==aAction) ? levelAfter : levelBefore;
+  levelOfDeletion =
+    (nsIEditor::eNext==aAction || nsIEditor::eNextWord==aAction) ?
+    levelAfter : levelBefore;
 
   if (currentCaretLevel == levelOfDeletion)
     ; // perform the deletion
   else
   {
     if (mDeleteBidiImmediately || levelBefore == levelAfter)
       ; // perform the deletion
     else
diff -r 4b060ed856e0 editor/txtsvc/src/nsFilteredContentIterator.cpp
--- a/editor/txtsvc/src/nsFilteredContentIterator.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/editor/txtsvc/src/nsFilteredContentIterator.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -63,17 +63,17 @@ nsFilteredContentIterator::~nsFilteredCo
 {
 }
 
 //------------------------------------------------------------
 NS_IMPL_ISUPPORTS1(nsFilteredContentIterator, nsIContentIterator)
 
 //------------------------------------------------------------
 nsresult
-nsFilteredContentIterator::Init(nsIContent* aRoot)
+nsFilteredContentIterator::Init(nsINode* aRoot)
 {
   NS_ENSURE_TRUE(mPreIterator, NS_ERROR_FAILURE);
   NS_ENSURE_TRUE(mIterator, NS_ERROR_FAILURE);
   mIsOutOfRange    = PR_FALSE;
   mDirection       = eForward;
   mCurrentIterator = mPreIterator;
 
   nsresult rv;
@@ -110,17 +110,17 @@ nsFilteredContentIterator::Init(nsIDOMRa
   NS_ENSURE_SUCCESS(rv, rv);
   return mIterator->Init(domRange);
 }
 
 //------------------------------------------------------------
 nsresult 
 nsFilteredContentIterator::SwitchDirections(PRPackedBool aChangeToForward)
 {
-  nsIContent *node = mCurrentIterator->GetCurrentNode();
+  nsINode *node = mCurrentIterator->GetCurrentNode();
 
   if (aChangeToForward) {
     mCurrentIterator = mPreIterator;
     mDirection       = eForward;
   } else {
     mCurrentIterator = mIterator;
     mDirection       = eBackward;
   }
@@ -154,18 +154,18 @@ nsFilteredContentIterator::First()
   }
 
   mCurrentIterator->First();
 
   if (mCurrentIterator->IsDone()) {
     return;
   }
 
-  nsIContent *currentContent = mCurrentIterator->GetCurrentNode();
-  nsCOMPtr<nsIDOMNode> node(do_QueryInterface(currentContent));
+  nsINode *currentNode = mCurrentIterator->GetCurrentNode();
+  nsCOMPtr<nsIDOMNode> node(do_QueryInterface(currentNode));
 
   PRPackedBool didCross;
   CheckAdvNode(node, didCross, eForward);
 }
 
 //------------------------------------------------------------
 void
 nsFilteredContentIterator::Last()
@@ -185,18 +185,18 @@ nsFilteredContentIterator::Last()
   }
 
   mCurrentIterator->Last();
 
   if (mCurrentIterator->IsDone()) {
     return;
   }
 
-  nsIContent *currentContent = mCurrentIterator->GetCurrentNode();
-  nsCOMPtr<nsIDOMNode> node(do_QueryInterface(currentContent));
+  nsINode *currentNode = mCurrentIterator->GetCurrentNode();
+  nsCOMPtr<nsIDOMNode> node(do_QueryInterface(currentNode));
 
   PRPackedBool didCross;
   CheckAdvNode(node, didCross, eBackward);
 }
 
 ///////////////////////////////////////////////////////////////////////////
 // ContentToParentOffset: returns the content node's parent and offset.
 //
@@ -379,19 +379,19 @@ nsFilteredContentIterator::Next()
   mCurrentIterator->Next();
 
   if (mCurrentIterator->IsDone()) {
     return;
   }
 
   // If we can't get the current node then 
   // don't check to see if we can skip it
-  nsIContent *currentContent = mCurrentIterator->GetCurrentNode();
+  nsINode *currentNode = mCurrentIterator->GetCurrentNode();
 
-  nsCOMPtr<nsIDOMNode> node(do_QueryInterface(currentContent));
+  nsCOMPtr<nsIDOMNode> node(do_QueryInterface(currentNode));
   CheckAdvNode(node, mDidSkip, eForward);
 }
 
 void
 nsFilteredContentIterator::Prev()
 {
   if (mIsOutOfRange || !mCurrentIterator) {
     NS_ASSERTION(mCurrentIterator, "Missing iterator!");
@@ -411,23 +411,23 @@ nsFilteredContentIterator::Prev()
   mCurrentIterator->Prev();
 
   if (mCurrentIterator->IsDone()) {
     return;
   }
 
   // If we can't get the current node then 
   // don't check to see if we can skip it
-  nsIContent *currentContent = mCurrentIterator->GetCurrentNode();
+  nsINode *currentNode = mCurrentIterator->GetCurrentNode();
 
-  nsCOMPtr<nsIDOMNode> node(do_QueryInterface(currentContent));
+  nsCOMPtr<nsIDOMNode> node(do_QueryInterface(currentNode));
   CheckAdvNode(node, mDidSkip, eBackward);
 }
 
-nsIContent *
+nsINode *
 nsFilteredContentIterator::GetCurrentNode()
 {
   if (mIsOutOfRange || !mCurrentIterator) {
     return nsnull;
   }
 
   return mCurrentIterator->GetCurrentNode();
 }
@@ -438,14 +438,14 @@ nsFilteredContentIterator::IsDone()
   if (mIsOutOfRange || !mCurrentIterator) {
     return PR_TRUE;
   }
 
   return mCurrentIterator->IsDone();
 }
 
 nsresult
-nsFilteredContentIterator::PositionAt(nsIContent* aCurNode)
+nsFilteredContentIterator::PositionAt(nsINode* aCurNode)
 {
   NS_ENSURE_TRUE(mCurrentIterator, NS_ERROR_FAILURE);
   mIsOutOfRange = PR_FALSE;
   return mCurrentIterator->PositionAt(aCurNode);
 }
diff -r 4b060ed856e0 editor/txtsvc/src/nsFilteredContentIterator.h
--- a/editor/txtsvc/src/nsFilteredContentIterator.h	Tue Oct 14 17:12:28 2008 -0700
+++ b/editor/txtsvc/src/nsFilteredContentIterator.h	Thu Oct 16 21:24:48 2008 -0500
@@ -55,25 +55,25 @@ public:
   // nsISupports interface...
   NS_DECL_ISUPPORTS
 
   nsFilteredContentIterator(nsITextServicesFilter* aFilter);
 
   virtual ~nsFilteredContentIterator();
 
   /* nsIContentIterator */
-  virtual nsresult Init(nsIContent* aRoot);
+  virtual nsresult Init(nsINode* aRoot);
   virtual nsresult Init(nsIDOMRange* aRange);
   virtual void First();
   virtual void Last();
   virtual void Next();
   virtual void Prev();
-  virtual nsIContent *GetCurrentNode();
+  virtual nsINode *GetCurrentNode();
   virtual PRBool IsDone();
-  virtual nsresult PositionAt(nsIContent* aCurNode);
+  virtual nsresult PositionAt(nsINode* aCurNode);
 
   /* Helpers */
   PRPackedBool DidSkip()      { return mDidSkip; }
   void         ClearDidSkip() {  mDidSkip = PR_FALSE; }
 
 protected:
   nsFilteredContentIterator() { }
 
diff -r 4b060ed856e0 editor/txtsvc/src/nsTextServicesDocument.cpp
--- a/editor/txtsvc/src/nsTextServicesDocument.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/editor/txtsvc/src/nsTextServicesDocument.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -412,48 +412,48 @@ nsTextServicesDocument::ExpandRangeToWor
   NS_ENSURE_SUCCESS(result, result);
 
   if (iterStatus == nsTextServicesDocument::eIsDone)
   {
     // No text was found so there's no adjustment necessary!
     return NS_OK;
   }
 
-  nsIContent *firstTextContent = iter->GetCurrentNode();
-  NS_ENSURE_TRUE(firstTextContent, NS_ERROR_FAILURE);
+  nsINode *firstText = iter->GetCurrentNode();
+  NS_ENSURE_TRUE(firstText, NS_ERROR_FAILURE);
 
   // Find the last text node in the range.
 
   result = LastTextNode(iter, &iterStatus);
   NS_ENSURE_SUCCESS(result, result);
 
   if (iterStatus == nsTextServicesDocument::eIsDone)
   {
     // We should never get here because a first text block
     // was found above.
     NS_ASSERTION(PR_FALSE, "Found a first without a last!");
     return NS_ERROR_FAILURE;
   }
 
-  nsIContent *lastTextContent = iter->GetCurrentNode();
-  NS_ENSURE_TRUE(lastTextContent, NS_ERROR_FAILURE);
+  nsINode *lastText = iter->GetCurrentNode();
+  NS_ENSURE_TRUE(lastText, NS_ERROR_FAILURE);
 
   // Now make sure our end points are in terms of text nodes in the range!
 
-  nsCOMPtr<nsIDOMNode> firstTextNode = do_QueryInterface(firstTextContent);
+  nsCOMPtr<nsIDOMNode> firstTextNode = do_QueryInterface(firstText);
   NS_ENSURE_TRUE(firstTextNode, NS_ERROR_FAILURE);
 
   if (rngStartNode != firstTextNode)
   {
     // The range includes the start of the first text node!
     rngStartNode = firstTextNode;
     rngStartOffset = 0;
   }
 
-  nsCOMPtr<nsIDOMNode> lastTextNode = do_QueryInterface(lastTextContent);
+  nsCOMPtr<nsIDOMNode> lastTextNode = do_QueryInterface(lastText);
   NS_ENSURE_TRUE(lastTextNode, NS_ERROR_FAILURE);
 
   if (rngEndNode != lastTextNode)
   {
     // The range includes the end of the last text node!
     rngEndNode = lastTextNode;
     nsAutoString str;
     result = lastTextNode->GetNodeValue(str);
@@ -465,17 +465,17 @@ nsTextServicesDocument::ExpandRangeToWor
 
   nsCOMPtr<nsIContentIterator> docIter;
   result = CreateDocumentContentIterator(getter_AddRefs(docIter));
   NS_ENSURE_SUCCESS(result, result);
 
   // Grab all the text in the block containing our
   // first text node.
 
-  result = docIter->PositionAt(firstTextContent);
+  result = docIter->PositionAt(firstText);
   NS_ENSURE_SUCCESS(result, result);
 
   iterStatus = nsTextServicesDocument::eValid;
 
   nsVoidArray offsetTable;
   nsAutoString blockStr;
 
   result = CreateOffsetTable(&offsetTable, docIter, &iterStatus,
@@ -499,17 +499,17 @@ nsTextServicesDocument::ExpandRangeToWor
   NS_ENSURE_SUCCESS(result, result);
 
   rngStartNode = wordStartNode;
   rngStartOffset = wordStartOffset;
 
   // Grab all the text in the block containing our
   // last text node.
 
-  result = docIter->PositionAt(lastTextContent);
+  result = docIter->PositionAt(lastText);
   NS_ENSURE_SUCCESS(result, result);
 
   iterStatus = nsTextServicesDocument::eValid;
 
   result = CreateOffsetTable(&offsetTable, docIter, &iterStatus,
                              nsnull, &blockStr);
   if (NS_FAILED(result))
   {
@@ -854,20 +854,20 @@ nsTextServicesDocument::FirstSelectedBlo
       if (NS_FAILED(result))
       {
         UNLOCK_DOC(this);
         return result;
       }
 
       iter->Last();
 
-      nsIContent *content = nsnull;
+      nsCOMPtr<nsIContent> content;
       while (!iter->IsDone())
       {
-        content = iter->GetCurrentNode();
+        content = do_QueryInterface(iter->GetCurrentNode());
 
         if (IsTextNode(content))
           break;
 
         content = nsnull;
 
         iter->Prev();
       }
@@ -967,17 +967,17 @@ nsTextServicesDocument::FirstSelectedBlo
     }
 
     iter->First();
 
     // Now walk through the range till we find a text node.
 
     while (!iter->IsDone())
     {
-      nsIContent *content = iter->GetCurrentNode();
+      nsCOMPtr<nsIContent> content = do_QueryInterface(iter->GetCurrentNode());
 
       if (IsTextNode(content))
       {
         // We found a text node, so position the document's
         // iterator at the beginning of the block, then get
         // the selection in terms of the string offset.
 
         result = mIterator->PositionAt(content);
@@ -1092,17 +1092,17 @@ nsTextServicesDocument::FirstSelectedBlo
     UNLOCK_DOC(this);
     return result;
   }
 
   iter->Last();
 
   while (!iter->IsDone())
   {
-    nsIContent *content = iter->GetCurrentNode();
+    nsCOMPtr<nsIContent> content = do_QueryInterface(iter->GetCurrentNode());
 
     if (IsTextNode(content))
     {
       // We found a text node! Adjust the document's iterator to point
       // to the beginning of it's text block, then get the current selection.
 
       result = mIterator->PositionAt(content);
 
@@ -1332,20 +1332,20 @@ nsTextServicesDocument::LastSelectedBloc
       if (NS_FAILED(result))
       {
         UNLOCK_DOC(this);
         return result;
       }
 
       iter->First();
 
-      nsIContent *content = nsnull;
+      nsCOMPtr<nsIContent> content;
       while (!iter->IsDone())
       {
-        content = iter->GetCurrentNode();
+        content = do_QueryInterface(iter->GetCurrentNode());
 
         if (IsTextNode(content))
           break;
 
         content = nsnull;
 
         iter->Next();
       }
@@ -1445,17 +1445,17 @@ nsTextServicesDocument::LastSelectedBloc
     }
 
     iter->Last();
 
     // Now walk through the range till we find a text node.
 
     while (!iter->IsDone())
     {
-      nsIContent *content = iter->GetCurrentNode();
+      nsCOMPtr<nsIContent> content = do_QueryInterface(iter->GetCurrentNode());
 
       if (IsTextNode(content))
       {
         // We found a text node, so position the document's
         // iterator at the beginning of the block, then get
         // the selection in terms of the string offset.
 
         result = mIterator->PositionAt(content);
@@ -1570,17 +1570,17 @@ nsTextServicesDocument::LastSelectedBloc
     UNLOCK_DOC(this);
     return result;
   }
 
   iter->First();
 
   while (!iter->IsDone())
   {
-    nsIContent *content = iter->GetCurrentNode();
+    nsCOMPtr<nsIContent> content = do_QueryInterface(iter->GetCurrentNode());
 
     if (IsTextNode(content))
     {
       // We found a text node! Adjust the document's iterator to point
       // to the beginning of it's text block, then get the current selection.
 
       result = mIterator->PositionAt(content);
 
@@ -2040,25 +2040,25 @@ nsTextServicesDocument::DeleteSelection(
       return result;
     }
 
     if (origStartNode != curStartNode || origEndNode != curEndNode)
     {
       // The range has changed, so we need to create a new content
       // iterator based on the new range.
 
-      nsIContent *curContent = nsnull;
+      nsCOMPtr<nsIContent> curContent;
 
       if (mIteratorStatus != nsTextServicesDocument::eIsDone)
       {
         // The old iterator is still pointing to something valid,
         // so get it's current node so we can restore it after we
         // create the new iterator!
 
-        curContent = mIterator->GetCurrentNode();
+        curContent = do_QueryInterface(mIterator->GetCurrentNode());
       }
 
       // Create the new iterator.
 
       result = CreateContentIterator(mExtent, getter_AddRefs(mIterator));
 
       if (NS_FAILED(result))
       {
@@ -3590,17 +3590,17 @@ nsTextServicesDocument::GetCollapsedSele
   }
 
   // Now iterate to the left, towards the beginning of
   // the text block, to find the first text node you
   // come across.
 
   while (!iter->IsDone())
   {
-    nsIContent *content = iter->GetCurrentNode();
+    nsCOMPtr<nsIContent> content = do_QueryInterface(iter->GetCurrentNode());
 
     if (IsTextNode(content))
     {
       node = do_QueryInterface(content);
 
       if (!node)
         return NS_ERROR_FAILURE;
 
@@ -3639,17 +3639,17 @@ nsTextServicesDocument::GetCollapsedSele
       result = iter->PositionAt(content);
 
       if (NS_FAILED(result))
         return result;
     }
 
     while (!iter->IsDone())
     {
-      nsIContent *content = iter->GetCurrentNode();
+      nsCOMPtr<nsIContent> content = do_QueryInterface(iter->GetCurrentNode());
 
       if (IsTextNode(content))
       {
         node = do_QueryInterface(content);
 
         if (!node)
           return NS_ERROR_FAILURE;
 
@@ -3878,27 +3878,27 @@ nsTextServicesDocument::GetUncollapsedSe
   result = CreateContentIterator(range, getter_AddRefs(iter));
 
   if (NS_FAILED(result))
     return result;
 
   // Find the first text node in the range.
   
   PRBool found;
-  nsIContent *content;
+  nsCOMPtr<nsIContent> content;
 
   iter->First();
 
   if (!IsTextNode(p1))
   {
     found = PR_FALSE;
 
     while (!iter->IsDone())
     {
-      content = iter->GetCurrentNode();
+      content = do_QueryInterface(iter->GetCurrentNode());
 
       if (IsTextNode(content))
       {
         p1 = do_QueryInterface(content);
 
         if (!p1)
           return NS_ERROR_FAILURE;
 
@@ -3920,17 +3920,17 @@ nsTextServicesDocument::GetUncollapsedSe
   iter->Last();
 
   if (! IsTextNode(p2))
   {
     found = PR_FALSE;
 
     while (!iter->IsDone())
     {
-      content = iter->GetCurrentNode();
+      content = do_QueryInterface(iter->GetCurrentNode());
 
       if (IsTextNode(content))
       {
         p2 = do_QueryInterface(content);
 
         if (!p2)
           return NS_ERROR_FAILURE;
 
@@ -4116,17 +4116,17 @@ nsTextServicesDocument::FirstTextNode(ns
 {
   if (aIteratorStatus)
     *aIteratorStatus = nsTextServicesDocument::eIsDone;
 
   aIterator->First();
 
   while (!aIterator->IsDone())
   {
-    nsIContent *content = aIterator->GetCurrentNode();
+    nsCOMPtr<nsIContent> content = do_QueryInterface(aIterator->GetCurrentNode());
 
     if (IsTextNode(content))
     {
       if (aIteratorStatus)
         *aIteratorStatus = nsTextServicesDocument::eValid;
       break;
     }
 
@@ -4142,17 +4142,17 @@ nsTextServicesDocument::LastTextNode(nsI
 {
   if (aIteratorStatus)
     *aIteratorStatus = nsTextServicesDocument::eIsDone;
 
   aIterator->Last();
 
   while (!aIterator->IsDone())
   {
-    nsIContent *content = aIterator->GetCurrentNode();
+    nsCOMPtr<nsIContent> content = do_QueryInterface(aIterator->GetCurrentNode());
 
     if (IsTextNode(content))
     {
       if (aIteratorStatus)
         *aIteratorStatus = nsTextServicesDocument::eValid;
       break;
     }
 
@@ -4172,17 +4172,17 @@ nsTextServicesDocument::FirstTextNodeInC
 
   nsCOMPtr<nsIContent> last;
 
   // Walk backwards over adjacent text nodes until
   // we hit a block boundary:
 
   while (!iter->IsDone())
   {
-    nsIContent *content = iter->GetCurrentNode();
+    nsCOMPtr<nsIContent> content = do_QueryInterface(iter->GetCurrentNode());
 
     if (IsTextNode(content))
     {
       if (!last || HasSameBlockNodeParent(content, last))
         last = content;
       else
       {
         // We're done, the current text node is in a
@@ -4246,17 +4246,17 @@ nsTextServicesDocument::FirstTextNodeInN
 
   if (!aIterator)
     return NS_ERROR_NULL_POINTER;
 
   ClearDidSkip(aIterator);
 
   while (!aIterator->IsDone())
   {
-    nsIContent *content = aIterator->GetCurrentNode();
+    nsCOMPtr<nsIContent> content = do_QueryInterface(aIterator->GetCurrentNode());
 
     if (IsTextNode(content))
     {
       if (!crossedBlockBoundary && (!prev || HasSameBlockNodeParent(prev, content)))
         prev = content;
       else
         break;
     }
@@ -4280,68 +4280,70 @@ nsTextServicesDocument::GetFirstTextNode
   if (!aContent)
     return NS_ERROR_NULL_POINTER;
 
   *aContent = 0;
 
   // Save the iterator's current content node so we can restore
   // it when we are done:
 
-  nsIContent *content = mIterator->GetCurrentNode();
+  nsINode* node = mIterator->GetCurrentNode();
 
   result = FirstTextNodeInPrevBlock(mIterator);
 
   if (NS_FAILED(result))
   {
     // Try to restore the iterator before returning.
-    mIterator->PositionAt(content);
+    mIterator->PositionAt(node);
     return result;
   }
 
   if (!mIterator->IsDone())
   {
-    NS_ADDREF(*aContent = mIterator->GetCurrentNode());
+    nsCOMPtr<nsIContent> current = do_QueryInterface(mIterator->GetCurrentNode());
+    current.swap(*aContent);
   }
 
   // Restore the iterator:
 
-  return mIterator->PositionAt(content);
+  return mIterator->PositionAt(node);
 }
 
 nsresult
 nsTextServicesDocument::GetFirstTextNodeInNextBlock(nsIContent **aContent)
 {
   nsresult result;
 
   if (!aContent)
     return NS_ERROR_NULL_POINTER;
 
   *aContent = 0;
 
   // Save the iterator's current content node so we can restore
   // it when we are done:
 
-  nsIContent *content = mIterator->GetCurrentNode();
+  nsINode* node = mIterator->GetCurrentNode();
 
   result = FirstTextNodeInNextBlock(mIterator);
 
   if (NS_FAILED(result))
   {
     // Try to restore the iterator before returning.
-    mIterator->PositionAt(content);
+    mIterator->PositionAt(node);
     return result;
   }
 
   if (!mIterator->IsDone())
   {
-    NS_ADDREF(*aContent = mIterator->GetCurrentNode());
+    nsCOMPtr<nsIContent> current = do_QueryInterface(mIterator->GetCurrentNode());
+    current.swap(*aContent);
   }
 
   // Restore the iterator:
-  return mIterator->PositionAt(content);
+  return mIterator->PositionAt(node);
 }
 
 nsresult
 nsTextServicesDocument::CreateOffsetTable(nsVoidArray *aOffsetTable,
                                           nsIContentIterator *aIterator,
                                           TSDIteratorStatus *aIteratorStatus,
                                           nsIDOMRange *aIterRange,
                                           nsString *aStr)
@@ -4388,17 +4390,17 @@ nsTextServicesDocument::CreateOffsetTabl
     return result;
 
   PRInt32 offset = 0;
 
   ClearDidSkip(aIterator);
 
   while (!aIterator->IsDone())
   {
-    nsIContent *content = aIterator->GetCurrentNode();
+    nsCOMPtr<nsIContent> content = do_QueryInterface(aIterator->GetCurrentNode());
 
     if (IsTextNode(content))
     {
       if (!prev || HasSameBlockNodeParent(prev, content))
       {
         nsCOMPtr<nsIDOMNode> node = do_QueryInterface(content);
 
         if (node)
diff -r 4b060ed856e0 embedding/components/find/src/nsFind.cpp
--- a/embedding/components/find/src/nsFind.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/embedding/components/find/src/nsFind.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -117,36 +117,36 @@ public:
   virtual ~nsFindContentIterator()
   {
   }
 
   // nsISupports
   NS_DECL_ISUPPORTS
 
   // nsIContentIterator
-  virtual nsresult Init(nsIContent* aRoot)
+  virtual nsresult Init(nsINode* aRoot)
   {
     NS_NOTREACHED("internal error");
     return NS_ERROR_NOT_IMPLEMENTED;
   }
   virtual nsresult Init(nsIDOMRange* aRange)
   {
     NS_NOTREACHED("internal error");
     return NS_ERROR_NOT_IMPLEMENTED;
   }
   // Not a range because one of the endpoints may be anonymous.
   nsresult Init(nsIDOMNode* aStartNode, PRInt32 aStartOffset,
                 nsIDOMNode* aEndNode, PRInt32 aEndOffset);
   virtual void First();
   virtual void Last();
   virtual void Next();
   virtual void Prev();
-  virtual nsIContent* GetCurrentNode();
+  virtual nsINode* GetCurrentNode();
   virtual PRBool IsDone();
-  virtual nsresult PositionAt(nsIContent* aCurNode);
+  virtual nsresult PositionAt(nsINode* aCurNode);
 
 private:
   nsCOMPtr<nsIContentIterator> mOuterIterator;
   nsCOMPtr<nsIContentIterator> mInnerIterator;
   // Can't use a range here, since we want to represent part of the
   // flattened tree, including native anonymous content.
   nsCOMPtr<nsIDOMNode> mStartNode;
   PRInt32 mStartOffset;
@@ -232,17 +232,17 @@ nsFindContentIterator::Prev()
     // by construction, mOuterIterator is already on the previous node
   }
   else {
     mOuterIterator->Prev();
   }
   MaybeSetupInnerIterator();
 }
 
-nsIContent*
+nsINode*
 nsFindContentIterator::GetCurrentNode()
 {
   if (mInnerIterator && !mInnerIterator->IsDone()) {
     return mInnerIterator->GetCurrentNode();
   }
   return mOuterIterator->GetCurrentNode();
 }
 
@@ -250,19 +250,19 @@ nsFindContentIterator::IsDone() {
 nsFindContentIterator::IsDone() {
   if (mInnerIterator && !mInnerIterator->IsDone()) {
     return PR_FALSE;
   }
   return mOuterIterator->IsDone();
 }
 
 nsresult
-nsFindContentIterator::PositionAt(nsIContent* aCurNode)
+nsFindContentIterator::PositionAt(nsINode* aCurNode)
 {
-  nsIContent* oldNode = mOuterIterator->GetCurrentNode();
+  nsINode* oldNode = mOuterIterator->GetCurrentNode();
   nsresult rv = mOuterIterator->PositionAt(aCurNode);
   if (NS_SUCCEEDED(rv)) {
     MaybeSetupInnerIterator();
   }
   else {
     mOuterIterator->PositionAt(oldNode);
     if (mInnerIterator)
       rv = mInnerIterator->PositionAt(aCurNode);
@@ -328,17 +328,18 @@ nsFindContentIterator::Reset()
   }
 }
 
 void
 nsFindContentIterator::MaybeSetupInnerIterator()
 {
   mInnerIterator = nsnull;
 
-  nsIContent* content = mOuterIterator->GetCurrentNode();
+  nsCOMPtr<nsIContent> content =
+    do_QueryInterface(mOuterIterator->GetCurrentNode());
   if (!content || !content->IsNodeOfType(nsINode::eHTML_FORM_CONTROL))
     return;
 
   nsCOMPtr<nsIFormControl> formControl(do_QueryInterface(content));
   PRInt32 controlType = formControl->GetType();
   if (controlType != NS_FORM_TEXTAREA && 
       controlType != NS_FORM_INPUT_TEXT)
     return;
@@ -640,17 +641,17 @@ nsFind::SetWordBreaker(nsIWordBreaker* a
 
 nsresult
 nsFind::NextNode(nsIDOMRange* aSearchRange,
                  nsIDOMRange* aStartPoint, nsIDOMRange* aEndPoint,
                  PRBool aContinueOk)
 {
   nsresult rv;
 
-  nsIContent *content = nsnull;
+  nsCOMPtr<nsIContent> content;
 
   if (!mIterator || aContinueOk)
   {
     // If we are continuing, that means we have a match in progress.
     // In that case, we want to continue from the end point
     // (where we are now) to the beginning/end of the search range.
     nsCOMPtr<nsIDOMNode> startNode;
     nsCOMPtr<nsIDOMNode> endNode;
@@ -694,17 +695,17 @@ nsFind::NextNode(nsIDOMRange* aSearchRan
       }
     }
 
     rv = InitIterator(startNode, startOffset, endNode, endOffset);
     NS_ENSURE_SUCCESS(rv, rv);
     if (!aStartPoint)
       aStartPoint = aSearchRange;
 
-    content = mIterator->GetCurrentNode();
+    content = do_QueryInterface(mIterator->GetCurrentNode());
 #ifdef DEBUG_FIND
     nsCOMPtr<nsIDOMNode> dnode (do_QueryInterface(content));
     printf(":::::: Got the first node "); DumpNode(dnode);
 #endif
     if (content && content->IsNodeOfType(nsINode::eTEXT) &&
         !SkipNode(content))
     {
       mIterNode = do_QueryInterface(content);
@@ -734,17 +735,17 @@ nsFind::NextNode(nsIDOMRange* aSearchRan
 
   while (1)
   {
     if (mFindBackward)
       mIterator->Prev();
     else
       mIterator->Next();
 
-    content = mIterator->GetCurrentNode();
+    content = do_QueryInterface(mIterator->GetCurrentNode());
     if (!content)
       break;
 
 #ifdef DEBUG_FIND
     nsCOMPtr<nsIDOMNode> dnode (do_QueryInterface(content));
     printf(":::::: Got another node "); DumpNode(dnode);
 #endif
 
diff -r 4b060ed856e0 embedding/components/find/src/nsFind.h
--- a/embedding/components/find/src/nsFind.h	Tue Oct 14 17:12:28 2008 -0700
+++ b/embedding/components/find/src/nsFind.h	Thu Oct 16 21:24:48 2008 -0500
@@ -45,16 +45,17 @@
 #include "nsIDOMNode.h"
 #include "nsIDOMRange.h"
 #include "nsIContentIterator.h"
 #include "nsIParserService.h"
 #include "nsIWordBreaker.h"
 
 class nsIPresShell;
 class nsIAtom;
+class nsIContent;
 
 #define NS_FIND_CONTRACTID "@mozilla.org/embedcomp/rangefind;1"
 
 #define NS_FIND_CID \
  {0x471f4944, 0x1dd2, 0x11b2, {0x87, 0xac, 0x90, 0xbe, 0x0a, 0x51, 0xd6, 0x09}}
 
 class nsFindContentIterator;
 
diff -r 4b060ed856e0 embedding/tests/wxEmbed/GeckoProtocolHandler.cpp
--- a/embedding/tests/wxEmbed/GeckoProtocolHandler.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/embedding/tests/wxEmbed/GeckoProtocolHandler.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -267,16 +267,17 @@ NS_IMETHODIMP GeckoProtocolHandlerImpl::
 ///////////////////////////////////////////////////////////////////////////////
 ///////////////////////////////////////////////////////////////////////////////
 
 NS_IMPL_ISUPPORTS4(GeckoProtocolChannel, nsIRequest, nsIChannel, nsIRequestObserver, nsIStreamListener)
 
 nsresult GeckoProtocolChannel::Init(nsIURI *aURI)
 {
     mURI = aURI;
+    mOriginalURI = aURI;
     return NS_OK;
 }
 
 
 ///////////////////////////////////////////////////////////////////////////////
 // nsIRequest methods
 
 
@@ -323,24 +324,25 @@ GeckoProtocolChannel::Resume()
 
 
 ////////////////////////////////////////////////////////////////////////////////
 // nsIChannel methods:
 
 NS_IMETHODIMP
 GeckoProtocolChannel::GetOriginalURI(nsIURI* *aURI)
 {
-    *aURI = mOriginalURI ? mOriginalURI : mURI;
+    *aURI = mOriginalURI;
     NS_ADDREF(*aURI);
     return NS_OK;
 }
 
 NS_IMETHODIMP
 GeckoProtocolChannel::SetOriginalURI(nsIURI* aURI)
 {
+    NS_ENSURE_ARG_POINTER(aURI);
     mOriginalURI = aURI;
     return NS_OK;
 }
 
 NS_IMETHODIMP
 GeckoProtocolChannel::GetURI(nsIURI* *aURI)
 {
     *aURI = mURI;
diff -r 4b060ed856e0 gfx/thebes/src/gfxWindowsPlatform.cpp
--- a/gfx/thebes/src/gfxWindowsPlatform.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/gfx/thebes/src/gfxWindowsPlatform.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -51,17 +51,16 @@
 #include "nsIWindowsRegKey.h"
 #include "nsILocalFile.h"
 #include "plbase64.h"
 
 #include "gfxWindowsFonts.h"
 #include "gfxUserFontSet.h"
 
 #include <string>
-#include <time.h>
 
 #include "lcms.h"
 
 static void InitializeFontEmbeddingProcs();
 
 // font info loader constants
 static const PRUint32 kDelayBeforeLoadingCmaps = 8 * 1000; // 8secs
 static const PRUint32 kIntervalBetweenLoadingCmaps = 150; // 150ms
@@ -634,21 +633,20 @@ gfxWindowsPlatform::LookupLocalFont(cons
     return data.mFontEntry;
 }
 
 // make a unique font name, limited on Windows to 31 two-byte characters
 static void MakeUniqueFontName(PRUnichar aName[LF_FACESIZE])
 {
     static PRUint32 fontCount = 0;
     ++fontCount;
-    PRUint32 time = (PRUint32) _time32(nsnull);
 
     char buf[LF_FACESIZE];
 
-    sprintf(buf, "mozfont%8.8x%8.8x", time, fontCount);  // slightly retarded, figure something better later...
+    sprintf(buf, "mozfont%8.8x%8.8x", ::GetTickCount(), fontCount);  // slightly retarded, figure something better later...
 
     nsCAutoString fontName(buf);
 
     PRUint32 nameLen = PR_MIN(fontName.Length(), LF_FACESIZE - 1);
     memcpy(aName, nsPromiseFlatString(NS_ConvertUTF8toUTF16(fontName)).get(), nameLen * 2);
     aName[nameLen] = 0;
 }
 
@@ -666,27 +664,27 @@ typedef struct
 {
     unsigned short usStructSize;    // size in bytes of structure client should set to sizeof(TTLOADINFO)
     unsigned short usRefStrSize;    // size in wide characters of pusRefStr including NULL terminator
     unsigned short *pusRefStr;      // reference or actual string.
 }TTLOADINFO;
 
 LONG WINAPI TTLoadEmbeddedFont
 (
-    __out HANDLE*   phFontReference,            // on completion, contains handle to identify embedded font installed
+    HANDLE*  phFontReference,           // on completion, contains handle to identify embedded font installed
                                         // on system
-    __in ULONG    ulFlags,                  // flags specifying the request 
-    __out ULONG*    pulPrivStatus,          // on completion, contains the embedding status
-    __in ULONG     ulPrivs,                 // allows for the reduction of licensing privileges
-    __out ULONG*    pulStatus,              // on completion, may contain status flags for request 
-    __in READEMBEDPROC lpfnReadFromStream,  // callback function for doc/disk reads
-    __in LPVOID    lpvReadStream,           // the input stream tokin
-    __in_opt LPWSTR    szWinFamilyName,         // the new 16 bit windows family name can be NULL
-    __in_opt LPSTR    szMacFamilyName,          // the new 8 bit mac family name can be NULL
-    __in_opt TTLOADINFO* pTTLoadInfo                // optional security
+    ULONG    ulFlags,                   // flags specifying the request 
+    ULONG*   pulPrivStatus,             // on completion, contains the embedding status
+    ULONG    ulPrivs,                   // allows for the reduction of licensing privileges
+    ULONG*   pulStatus,                 // on completion, may contain status flags for request 
+    READEMBEDPROC lpfnReadFromStream,   // callback function for doc/disk reads
+    LPVOID   lpvReadStream,             // the input stream tokin
+    LPWSTR   szWinFamilyName,           // the new 16 bit windows family name can be NULL
+    LPSTR    szMacFamilyName,           // the new 8 bit mac family name can be NULL
+    TTLOADINFO* pTTLoadInfo             // optional security
 );
 
 #endif // __t2embapi__
 
 typedef LONG( WINAPI *TTLoadEmbeddedFontProc ) (HANDLE* phFontReference, ULONG ulFlags, ULONG* pulPrivStatus, ULONG ulPrivs, ULONG* pulStatus, 
                                              READEMBEDPROC lpfnReadFromStream, LPVOID lpvReadStream, LPWSTR szWinFamilyName, 
                                              LPSTR szMacFamilyName, TTLOADINFO* pTTLoadInfo);
 
diff -r 4b060ed856e0 intl/locale/src/windows/nsIWin32LocaleImpl.cpp
--- a/intl/locale/src/windows/nsIWin32LocaleImpl.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/intl/locale/src/windows/nsIWin32LocaleImpl.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -55,16 +55,20 @@ struct iso_pair
 };
 
 struct iso_map
 {
 	const char* iso_code;
 	DWORD       win_code;
 	iso_pair    sublang_list[20];
 };
+
+HMODULE nsIWin32LocaleImpl::sKernelDLL = NULL;
+nsIWin32LocaleImpl::LocaleNameToLCIDPtr nsIWin32LocaleImpl::localeNameToLCID = NULL;
+nsIWin32LocaleImpl::LCIDToLocaleNamePtr nsIWin32LocaleImpl::lcidToLocaleName = NULL;
 
 // Older versions of VC++ and Win32 SDK  and mingw don't have 
 // macros for languages and sublanguages recently added to Win32. 
 // see http://www.tug.org/ftp/tex/texinfo/intl/localename.c
 
 #ifndef LANG_URDU
 #define LANG_URDU                           0x20
 #endif
@@ -603,32 +607,51 @@ iso_pair dbg_list[] =
 #define CROATIAN_ISO_CODE "hr"
 #define SERBIAN_ISO_CODE "sr"
 
 /* nsIWin32LocaleImpl */
 NS_IMPL_ISUPPORTS1(nsIWin32LocaleImpl,nsIWin32Locale)
 
 nsIWin32LocaleImpl::nsIWin32LocaleImpl(void)
 {
+  // We use the Vista and above functions if we have them
+  sKernelDLL = LoadLibraryW(L"kernel32.dll");
+  if (sKernelDLL) {
+    localeNameToLCID = (LocaleNameToLCIDPtr) GetProcAddress(sKernelDLL, "LocaleNameToLCID");
+    lcidToLocaleName = (LCIDToLocaleNamePtr) GetProcAddress(sKernelDLL, "LCIDToLocaleName");
+  }
 }
 
 nsIWin32LocaleImpl::~nsIWin32LocaleImpl(void)
 {
-
+  if (sKernelDLL)
+    FreeLibrary(sKernelDLL);
 }
 
 //
 // the mapping routines are a first approximation to get us going on
 // the tier-1 languages.  we are making an assumption that we can map
 // language and country codes separately on Windows, which isn't true
 //
 
 NS_IMETHODIMP
 nsIWin32LocaleImpl::GetPlatformLocale(const nsAString& locale,LCID* winLCID)
 {
+  if (localeNameToLCID) {
+    nsAutoString locale_autostr(locale);
+    LCID lcid = localeNameToLCID(locale_autostr.get(), 0);
+    // The function returning 0 means that the locale name couldn't be matched,
+    // so we fallback to the old function
+    if (lcid != 0)
+    {
+      *winLCID = lcid;
+      return NS_OK;
+    }
+  }
+
   char    locale_string[9] = {'\0','\0','\0','\0','\0','\0','\0','\0','\0'};
   char*   language_code;
   char*   country_code;
   int     i,j;
 
   // parse the locale
   const PRUnichar* data;
   j = NS_StringGetData(locale, &data);
@@ -655,16 +678,29 @@ nsIWin32LocaleImpl::GetPlatformLocale(co
   }
     
   return NS_ERROR_FAILURE;
 }
 
 NS_IMETHODIMP
 nsIWin32LocaleImpl::GetXPLocale(LCID winLCID, nsAString& locale)
 {
+  if (lcidToLocaleName)
+  {
+    WCHAR ret_locale[LOCALE_NAME_MAX_LENGTH];
+    int rv = lcidToLocaleName(winLCID, ret_locale, LOCALE_NAME_MAX_LENGTH, 0);
+    // rv 0 means that the function failed to match up the LCID, so we fallback
+    // to the old function
+    if (rv != 0)
+    {
+      locale.Assign(ret_locale);
+      return NS_OK;
+    }
+  }
+
   DWORD    lang_id, sublang_id;
   int      i,j;
 
   lang_id = PRIMARYLANGID(LANGIDFROMLCID(winLCID));
   sublang_id = SUBLANGID(LANGIDFROMLCID(winLCID));
 
   /* Special-case Norwegian Bokmal and Norwegian Nynorsk, which have the same
      LANG_ID on Windows, but have separate ISO-639-2 codes */
diff -r 4b060ed856e0 intl/locale/src/windows/nsIwin32LocaleImpl.h
--- a/intl/locale/src/windows/nsIwin32LocaleImpl.h	Tue Oct 14 17:12:28 2008 -0700
+++ b/intl/locale/src/windows/nsIwin32LocaleImpl.h	Thu Oct 16 21:24:48 2008 -0500
@@ -54,11 +54,20 @@ public:
 public:
 
 	nsIWin32LocaleImpl(void);
 	~nsIWin32LocaleImpl(void);
 
 	NS_IMETHOD GetPlatformLocale(const nsAString& locale, LCID* winLCID);
 	NS_IMETHOD GetXPLocale(LCID winLCID, nsAString& locale);
 
+	typedef LCID (WINAPI*LocaleNameToLCIDPtr)(LPCWSTR lpName, DWORD dwFlags);
+	typedef int (WINAPI*LCIDToLocaleNamePtr)(LCID Locale, LPWSTR lpName,
+	                                         int cchName, DWORD dwFlags);
+
+	static LocaleNameToLCIDPtr localeNameToLCID;
+	static LCIDToLocaleNamePtr lcidToLocaleName;
+
+private:
+	static HMODULE sKernelDLL;
 };
 
 #endif
diff -r 4b060ed856e0 js/src/json.cpp
--- a/js/src/json.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/js/src/json.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -899,17 +899,16 @@ js_InitJSONClass(JSContext *cx, JSObject
 js_InitJSONClass(JSContext *cx, JSObject *obj)
 {
     JSObject *JSON;
 
     JSON = JS_NewObject(cx, &js_JSONClass, NULL, obj);
     if (!JSON)
         return NULL;
     if (!JS_DefineProperty(cx, obj, js_JSON_str, OBJECT_TO_JSVAL(JSON),
-                           JS_PropertyStub, JS_PropertyStub,
-                           JSPROP_READONLY | JSPROP_PERMANENT))
+                           JS_PropertyStub, JS_PropertyStub, 0))
         return NULL;
 
     if (!JS_DefineFunctions(cx, JSON, json_static_methods))
         return NULL;
 
     return JSON;
 }
diff -r 4b060ed856e0 layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/layout/base/nsPresContext.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -79,16 +79,17 @@
 #include "nsLayoutUtils.h"
 #include "nsIViewManager.h"
 #include "nsCSSFrameConstructor.h"
 #include "nsCSSRuleProcessor.h"
 #include "nsStyleChangeList.h"
 #include "nsRuleNode.h"
 #include "nsEventDispatcher.h"
 #include "gfxUserFontSet.h"
+#include "nsIEventListenerManager.h"
 
 #ifdef IBMBIDI
 #include "nsBidiPresUtils.h"
 #endif // IBMBIDI
 
 #include "nsContentUtils.h"
 
 // Needed for Start/Stop of Image Animation
@@ -1536,20 +1537,20 @@ nsPresContext::SetUserFontSet(gfxUserFon
   NS_IF_RELEASE(mUserFontSet);
   mUserFontSet = aUserFontSet;
   NS_IF_ADDREF(mUserFontSet);
 }
 
 void
 nsPresContext::FireDOMPaintEvent()
 {
-  nsCOMPtr<nsIDocShell> docShell(do_QueryReferent(mContainer));
-  if (!docShell)
+  nsCOMPtr<nsPIDOMWindow> ourWindow = mDocument->GetWindow();
+  if (!ourWindow)
     return;
-  nsCOMPtr<nsPIDOMWindow> ourWindow = do_GetInterface(docShell);
+
   nsISupports* eventTarget = ourWindow;
   if (mSameDocDirtyRegion.IsEmpty() && !IsChrome()) {
     // Don't tell the window about this event, it should not know that
     // something happened in a subdocument. Tell only the chrome event handler.
     // (Events sent to the window get propagated to the chrome event handler
     // automatically.)
     eventTarget = ourWindow->GetChromeEventHandler();
   }
@@ -1565,20 +1566,53 @@ nsPresContext::FireDOMPaintEvent()
   mCrossDocDirtyRegion.SetEmpty();
   // Even if we're not telling the window about the event (so eventTarget is
   // the chrome event handler, not the window), the window is still
   // logically the event target.
   event.target = do_QueryInterface(ourWindow);
   nsEventDispatcher::Dispatch(eventTarget, this, &event);
 }
 
+static PRBool MayHavePaintEventListener(nsPIDOMWindow* aInnerWindow)
+{
+  if (!aInnerWindow)
+    return PR_FALSE;
+  if (aInnerWindow->HasPaintEventListeners())
+    return PR_TRUE;
+
+  nsPIDOMEventTarget* chromeEventHandler = aInnerWindow->GetChromeEventHandler();
+  if (!chromeEventHandler)
+    return PR_FALSE;
+
+  nsCOMPtr<nsIEventListenerManager> manager;
+  chromeEventHandler->GetListenerManager(PR_FALSE, getter_AddRefs(manager));
+  if (manager && manager->MayHavePaintEventListener())
+    return PR_TRUE;
+
+  nsCOMPtr<nsINode> node = do_QueryInterface(chromeEventHandler);
+  if (node)
+    return MayHavePaintEventListener(node->GetOwnerDoc()->GetInnerWindow());
+
+  nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(chromeEventHandler);
+  if (window)
+    return MayHavePaintEventListener(window);
+
+  return PR_FALSE;
+}
+
 void
 nsPresContext::NotifyInvalidation(const nsRect& aRect, PRBool aIsCrossDoc)
 {
-  if (aRect.IsEmpty())
+  // If there is no paint event listener, then we don't need to fire
+  // the asynchronous event. We don't even need to record invalidation.
+  // MayHavePaintEventListener is pretty cheap and we could make it
+  // even cheaper by providing a more efficient
+  // nsPIDOMWindow::GetListenerManager.
+  if (aRect.IsEmpty() ||
+      !MayHavePaintEventListener(mDocument->GetInnerWindow()))
     return;
 
   if (mSameDocDirtyRegion.IsEmpty() && mCrossDocDirtyRegion.IsEmpty()) {
     // No event is pending. Dispatch one now.
     nsCOMPtr<nsIRunnable> ev =
       new nsRunnableMethod<nsPresContext>(this,
                                           &nsPresContext::FireDOMPaintEvent);
     NS_DispatchToCurrentThread(ev);
diff -r 4b060ed856e0 layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/layout/base/nsPresShell.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -927,16 +927,17 @@ public:
   virtual void RestoreCaret();
 
   NS_IMETHOD SetSelectionFlags(PRInt16 aInEnable);
   NS_IMETHOD GetSelectionFlags(PRInt16 *aOutEnable);
 
   // nsISelectionController
 
   NS_IMETHOD CharacterMove(PRBool aForward, PRBool aExtend);
+  NS_IMETHOD CharacterExtendForDelete();
   NS_IMETHOD WordMove(PRBool aForward, PRBool aExtend);
   NS_IMETHOD WordExtendForDelete(PRBool aForward);
   NS_IMETHOD LineMove(PRBool aForward, PRBool aExtend);
   NS_IMETHOD IntraLineMove(PRBool aForward, PRBool aExtend);
   NS_IMETHOD PageMove(PRBool aForward, PRBool aExtend);
   NS_IMETHOD ScrollPage(PRBool aForward);
   NS_IMETHOD ScrollLine(PRBool aForward);
   NS_IMETHOD ScrollHorizontal(PRBool aLeft);
@@ -2761,16 +2762,22 @@ NS_IMETHODIMP PresShell::GetSelectionFla
 }
 
 //implementation of nsISelectionController
 
 NS_IMETHODIMP 
 PresShell::CharacterMove(PRBool aForward, PRBool aExtend)
 {
   return mSelection->CharacterMove(aForward, aExtend);  
+}
+
+NS_IMETHODIMP
+PresShell::CharacterExtendForDelete()
+{
+  return mSelection->CharacterExtendForDelete();
 }
 
 NS_IMETHODIMP 
 PresShell::WordMove(PRBool aForward, PRBool aExtend)
 {
   return mSelection->WordMove(aForward, aExtend);  
 }
 
diff -r 4b060ed856e0 layout/build/Makefile.in
--- a/layout/build/Makefile.in	Tue Oct 14 17:12:28 2008 -0700
+++ b/layout/build/Makefile.in	Thu Oct 16 21:24:48 2008 -0500
@@ -151,17 +151,17 @@ endif
 endif
 
 ifdef MOZ_OGG
 SHARED_LIBRARY_LIBS 	+= \
 	$(DEPTH)/media/libfishsound/src/libfishsound/$(LIB_PREFIX)fishsound.$(LIB_SUFFIX) \
 	$(DEPTH)/media/libogg/src/$(LIB_PREFIX)ogg.$(LIB_SUFFIX) \
 	$(DEPTH)/media/liboggplay/src/liboggplay/$(LIB_PREFIX)oggplay.$(LIB_SUFFIX) \
 	$(DEPTH)/media/liboggz/src/liboggz/$(LIB_PREFIX)oggz.$(LIB_SUFFIX) \
-	$(DEPTH)/media/liboggplay_audio/$(LIB_PREFIX)oggplay_audio.$(LIB_SUFFIX) \
+	$(DEPTH)/media/libsydneyaudio/src/$(LIB_PREFIX)sydneyaudio.$(LIB_SUFFIX) \
 	$(DEPTH)/media/libtheora/lib/$(LIB_PREFIX)theora.$(LIB_SUFFIX) \
 	$(DEPTH)/media/libvorbis/lib/$(LIB_PREFIX)vorbis.$(LIB_SUFFIX) \
 	$(NULL)
 endif
 
 ifdef NS_PRINTING
 SHARED_LIBRARY_LIBS += \
 		../printing/$(LIB_PREFIX)gkprinting_s.$(LIB_SUFFIX) \
diff -r 4b060ed856e0 layout/forms/nsTextControlFrame.cpp
--- a/layout/forms/nsTextControlFrame.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/layout/forms/nsTextControlFrame.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -425,54 +425,63 @@ DoCommandCallback(const char *aCommand, 
   controllers->GetControllerForCommand(aCommand, getter_AddRefs(controller));
   if (controller) {
     controller->DoCommand(aCommand);
   }
 }
 
 
 NS_IMETHODIMP
-nsTextInputListener::KeyDown(nsIDOMEvent *aKeyEvent)
+nsTextInputListener::KeyDown(nsIDOMEvent *aDOMEvent)
 {
+  nsCOMPtr<nsIDOMKeyEvent> keyEvent(do_QueryInterface(aDOMEvent));
+  NS_ENSURE_TRUE(keyEvent, NS_ERROR_INVALID_ARG);
+
   nsNativeKeyEvent nativeEvent;
   nsINativeKeyBindings *bindings = GetKeyBindings();
   if (bindings &&
-      nsContentUtils::DOMEventToNativeKeyEvent(aKeyEvent, &nativeEvent, PR_FALSE)) {
+      nsContentUtils::DOMEventToNativeKeyEvent(keyEvent, &nativeEvent, PR_FALSE)) {
     if (bindings->KeyDown(nativeEvent, DoCommandCallback, mFrame)) {
-      aKeyEvent->PreventDefault();
+      aDOMEvent->PreventDefault();
     }
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
-nsTextInputListener::KeyPress(nsIDOMEvent *aKeyEvent)
+nsTextInputListener::KeyPress(nsIDOMEvent *aDOMEvent)
 {
+  nsCOMPtr<nsIDOMKeyEvent> keyEvent(do_QueryInterface(aDOMEvent));
+  NS_ENSURE_TRUE(keyEvent, NS_ERROR_INVALID_ARG);
+
   nsNativeKeyEvent nativeEvent;
   nsINativeKeyBindings *bindings = GetKeyBindings();
   if (bindings &&
-      nsContentUtils::DOMEventToNativeKeyEvent(aKeyEvent, &nativeEvent, PR_TRUE)) {
+      nsContentUtils::DOMEventToNativeKeyEvent(keyEvent, &nativeEvent, PR_TRUE)) {
     if (bindings->KeyPress(nativeEvent, DoCommandCallback, mFrame)) {
-      aKeyEvent->PreventDefault();
+      aDOMEvent->PreventDefault();
     }
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
-nsTextInputListener::KeyUp(nsIDOMEvent *aKeyEvent)
+nsTextInputListener::KeyUp(nsIDOMEvent *aDOMEvent)
 {
+  nsCOMPtr<nsIDOMKeyEvent> keyEvent(do_QueryInterface(aDOMEvent));
+  NS_ENSURE_TRUE(keyEvent, NS_ERROR_INVALID_ARG);
+
   nsNativeKeyEvent nativeEvent;
   nsINativeKeyBindings *bindings = GetKeyBindings();
   if (bindings &&
-      nsContentUtils::DOMEventToNativeKeyEvent(aKeyEvent, &nativeEvent, PR_FALSE)) {
+      nsContentUtils::DOMEventToNativeKeyEvent(keyEvent, &nativeEvent, PR_FALSE)) {
     if (bindings->KeyUp(nativeEvent, DoCommandCallback, mFrame)) {
-      aKeyEvent->PreventDefault();
+      aDOMEvent->PreventDefault();
     }
   }
 
   return NS_OK;
 }
 // END nsIDOMKeyListener
 
 // BEGIN nsIEditorObserver
@@ -586,16 +595,17 @@ public:
   NS_IMETHOD RepaintSelection(PRInt16 type);
   NS_IMETHOD RepaintSelection(nsPresContext* aPresContext, SelectionType aSelectionType);
   NS_IMETHOD SetCaretEnabled(PRBool enabled);
   NS_IMETHOD SetCaretReadOnly(PRBool aReadOnly);
   NS_IMETHOD GetCaretEnabled(PRBool *_retval);
   NS_IMETHOD GetCaretVisible(PRBool *_retval);
   NS_IMETHOD SetCaretVisibilityDuringSelection(PRBool aVisibility);
   NS_IMETHOD CharacterMove(PRBool aForward, PRBool aExtend);
+  NS_IMETHOD CharacterExtendForDelete();
   NS_IMETHOD WordMove(PRBool aForward, PRBool aExtend);
   NS_IMETHOD WordExtendForDelete(PRBool aForward);
   NS_IMETHOD LineMove(PRBool aForward, PRBool aExtend);
   NS_IMETHOD IntraLineMove(PRBool aForward, PRBool aExtend);
   NS_IMETHOD PageMove(PRBool aForward, PRBool aExtend);
   NS_IMETHOD CompleteScroll(PRBool aForward);
   NS_IMETHOD CompleteMove(PRBool aForward, PRBool aExtend);
   NS_IMETHOD ScrollPage(PRBool aForward);
@@ -812,16 +822,23 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsTextInputSelectionImpl::CharacterMove(PRBool aForward, PRBool aExtend)
 {
   if (mFrameSelection)
     return mFrameSelection->CharacterMove(aForward, aExtend);
   return NS_ERROR_NULL_POINTER;
 }
 
+NS_IMETHODIMP
+nsTextInputSelectionImpl::CharacterExtendForDelete()
+{
+  if (mFrameSelection)
+    return mFrameSelection->CharacterExtendForDelete();
+  return NS_ERROR_NULL_POINTER;
+}
 
 NS_IMETHODIMP
 nsTextInputSelectionImpl::WordMove(PRBool aForward, PRBool aExtend)
 {
   if (mFrameSelection)
     return mFrameSelection->WordMove(aForward, aExtend);
   return NS_ERROR_NULL_POINTER;
 }
diff -r 4b060ed856e0 layout/generic/crashtests/428263-1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/generic/crashtests/428263-1.html	Thu Oct 16 21:24:48 2008 -0500
@@ -0,0 +1,18 @@
+<!DOCTYPE html>
+<html style="display: table;">
+<head>
+<script type="text/javascript">
+
+function boom()
+{
+  document.documentElement.appendChild(document.body);
+  document.documentElement.offsetHeight;
+  document.documentElement.appendChild(document.body);
+}
+
+</script>
+</head>
+
+<body onload="boom();" style="-moz-column-count: 2;"><div style="height: 1px;"></div><span style="display: inline-block;"></span></body>
+
+</html>
diff -r 4b060ed856e0 layout/generic/crashtests/crashtests.list
--- a/layout/generic/crashtests/crashtests.list	Tue Oct 14 17:12:28 2008 -0700
+++ b/layout/generic/crashtests/crashtests.list	Thu Oct 16 21:24:48 2008 -0500
@@ -144,13 +144,14 @@ load 416476-1.html
 load 416476-1.html
 load 418532-1.html
 load 421404-1.html
 load 422283-1.html
 load 422301-1.html
 load 423055-1.html
 load 425253-1.html
 load 426272-1.html
+load 428263-1.html
 load 429981-1.html
 load 430352-1.html
 load 437156-1.html
 load 438259-1.html
 load 448903-1.html
diff -r 4b060ed856e0 layout/generic/nsAbsoluteContainingBlock.cpp
--- a/layout/generic/nsAbsoluteContainingBlock.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/layout/generic/nsAbsoluteContainingBlock.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -327,16 +327,29 @@ nsAbsoluteContainingBlock::FrameDependsO
 }
 
 void
 nsAbsoluteContainingBlock::DestroyFrames(nsIFrame* aDelegatingFrame)
 {
   mAbsoluteFrames.DestroyFrames();
 }
 
+void
+nsAbsoluteContainingBlock::MarkSizeDependentFramesDirty()
+{
+  for (nsIFrame* kidFrame = mAbsoluteFrames.FirstChild();
+       kidFrame;
+       kidFrame = kidFrame->GetNextSibling()) {
+    if (FrameDependsOnContainer(kidFrame, PR_TRUE, PR_TRUE)) {
+      // Add the weakest flags that will make sure we reflow this frame later
+      kidFrame->AddStateBits(NS_FRAME_HAS_DIRTY_CHILDREN);
+    }
+  }
+}
+
 // XXX Optimize the case where it's a resize reflow and the absolutely
 // positioned child has the exact same size and position and skip the
 // reflow...
 
 // When bug 154892 is checked in, make sure that when 
 // GetChildListName() == nsGkAtoms::fixedList, the height is unconstrained.
 // since we don't allow replicated frames to split.
 
diff -r 4b060ed856e0 layout/generic/nsAbsoluteContainingBlock.h
--- a/layout/generic/nsAbsoluteContainingBlock.h	Tue Oct 14 17:12:28 2008 -0700
+++ b/layout/generic/nsAbsoluteContainingBlock.h	Thu Oct 16 21:24:48 2008 -0500
@@ -122,16 +122,18 @@ public:
                   PRBool                   aCBHeightChanged,
                   nsRect*                  aChildBounds = nsnull);
 
 
   void DestroyFrames(nsIFrame* aDelegatingFrame);
 
   PRBool  HasAbsoluteFrames() {return mAbsoluteFrames.NotEmpty();}
 
+  void MarkSizeDependentFramesDirty();
+
 protected:
   // Returns PR_TRUE if the position of f depends on the position of
   // its placeholder or if the position or size of f depends on a
   // containing block dimension that changed.
   PRBool FrameDependsOnContainer(nsIFrame* f, PRBool aCBWidthChanged,
                                  PRBool aCBHeightChanged);
 
   nsresult ReflowAbsoluteFrame(nsIFrame*                aDelegatingFrame,
diff -r 4b060ed856e0 layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/layout/generic/nsBlockFrame.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -1148,50 +1148,58 @@ nsBlockFrame::Reflow(nsPresContext*     
   // condition 1.
   // XXX checking oldSize is bogus, there are various reasons we might have
   // reflowed but our size might not have been changed to what we
   // asked for (e.g., we ended up being pushed to a new page)
   // When WillReflowAgainForClearance is true, we will reflow again without
   // resetting the size. Because of this, we must not reflow our abs-pos children
   // in that situation --- what we think is our "new size"
   // will not be our real new size. This also happens to be more efficient.
-  if (mAbsoluteContainer.HasAbsoluteFrames() &&
-      !aReflowState.WillReflowAgainForClearance()) {
-    nsRect childBounds;
-    nsSize containingBlockSize
-      = CalculateContainingBlockSizeForAbsolutes(aReflowState,
-                                                 nsSize(aMetrics.width, aMetrics.height));
-
-    // Mark frames that depend on changes we just made to this frame as dirty:
-    // Now we can assume that the padding edge hasn't moved.
-    // We need to reflow the absolutes if one of them depends on
-    // its placeholder position, or the containing block size in a
-    // direction in which the containing block size might have
-    // changed.
-    PRBool cbWidthChanged = aMetrics.width != oldSize.width;
-    PRBool isRoot = !GetContent()->GetParent();
-    // If isRoot and we have auto height, then we are the initial
-    // containing block and the containing block height is the
-    // viewport height, which can't change during incremental
-    // reflow.
-    PRBool cbHeightChanged =
-      !(isRoot && NS_UNCONSTRAINEDSIZE == aReflowState.ComputedHeight()) &&
-      aMetrics.height != oldSize.height;
-
-    rv = mAbsoluteContainer.Reflow(this, aPresContext, aReflowState,
-                                   state.mReflowStatus,
-                                   containingBlockSize.width,
-                                   containingBlockSize.height, PR_TRUE,
-                                   cbWidthChanged, cbHeightChanged,
-                                   &childBounds);
-
-    //XXXfr Why isn't this rv (and others in this file) checked/returned?
-
-    // Factor the absolutely positioned child bounds into the overflow area
-    aMetrics.mOverflowArea.UnionRect(aMetrics.mOverflowArea, childBounds);
+  if (mAbsoluteContainer.HasAbsoluteFrames()) {
+    if (aReflowState.WillReflowAgainForClearance()) {
+      // Make sure that when we reflow again we'll actually reflow all the abs
+      // pos frames that might conceivably depend on our size.  Sadly, we can't
+      // do much better than that, because we don't really know what our size
+      // will be, and it might in fact not change on the followup reflow!
+      mAbsoluteContainer.MarkSizeDependentFramesDirty();
+    } else {
+      nsRect childBounds;
+      nsSize containingBlockSize =
+        CalculateContainingBlockSizeForAbsolutes(aReflowState,
+                                                 nsSize(aMetrics.width,
+                                                        aMetrics.height));
+
+      // Mark frames that depend on changes we just made to this frame as dirty:
+      // Now we can assume that the padding edge hasn't moved.
+      // We need to reflow the absolutes if one of them depends on
+      // its placeholder position, or the containing block size in a
+      // direction in which the containing block size might have
+      // changed.
+      PRBool cbWidthChanged = aMetrics.width != oldSize.width;
+      PRBool isRoot = !GetContent()->GetParent();
+      // If isRoot and we have auto height, then we are the initial
+      // containing block and the containing block height is the
+      // viewport height, which can't change during incremental
+      // reflow.
+      PRBool cbHeightChanged =
+        !(isRoot && NS_UNCONSTRAINEDSIZE == aReflowState.ComputedHeight()) &&
+        aMetrics.height != oldSize.height;
+
+      rv = mAbsoluteContainer.Reflow(this, aPresContext, aReflowState,
+                                     state.mReflowStatus,
+                                     containingBlockSize.width,
+                                     containingBlockSize.height, PR_TRUE,
+                                     cbWidthChanged, cbHeightChanged,
+                                     &childBounds);
+
+      //XXXfr Why isn't this rv (and others in this file) checked/returned?
+
+      // Factor the absolutely positioned child bounds into the overflow area
+      aMetrics.mOverflowArea.UnionRect(aMetrics.mOverflowArea, childBounds);
+    }
   }
 
   // Determine if we need to repaint our border, background or outline
   CheckInvalidateSizeChange(aMetrics);
 
   FinishAndStoreOverflow(&aMetrics);
 
   // Clear the space manager pointer in the block reflow state so we
diff -r 4b060ed856e0 layout/generic/nsFrameSelection.h
--- a/layout/generic/nsFrameSelection.h	Tue Oct 14 17:12:28 2008 -0700
+++ b/layout/generic/nsFrameSelection.h	Thu Oct 16 21:24:48 2008 -0500
@@ -412,16 +412,22 @@ public:
   /** CharacterMove will generally be called from the nsiselectioncontroller implementations.
    *  the effect being the selection will move one character left or right.
    * @param aForward move forward in document.
    * @param aExtend continue selection
    */
   /*unsafe*/
   nsresult CharacterMove(PRBool aForward, PRBool aExtend);
 
+  /** CharacterExtendForDelete extends the selection forward (logically) to
+   * the next character cell, so that the selected cell can be deleted.
+   */
+  /*unsafe*/
+  nsresult CharacterExtendForDelete();
+
   /** WordMove will generally be called from the nsiselectioncontroller implementations.
    *  the effect being the selection will move one word left or right.
    * @param aForward move forward in document.
    * @param aExtend continue selection
    */
   /*unsafe*/
   nsresult WordMove(PRBool aForward, PRBool aExtend);
 
diff -r 4b060ed856e0 layout/generic/nsLineLayout.cpp
--- a/layout/generic/nsLineLayout.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/layout/generic/nsLineLayout.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -1545,19 +1545,18 @@ nsLineLayout::VerticalAlignFrames(PerSpa
   rc->GetFontMetrics(*getter_AddRefs(fm));
 
   PRBool preMode = mStyleText->WhiteSpaceIsSignificant();
 
   // See if the span is an empty continuation. It's an empty continuation iff:
   // - it has a prev-in-flow
   // - it has no next in flow
   // - it's zero sized
-  nsIFrame* spanNextInFlow = spanFrame->GetNextInFlow();
-  nsIFrame* spanPrevInFlow = spanFrame->GetPrevInFlow();
-  PRBool emptyContinuation = spanPrevInFlow && !spanNextInFlow &&
+  PRBool emptyContinuation = psd != mRootSpan &&
+    spanFrame->GetPrevInFlow() && !spanFrame->GetNextInFlow() &&
     (0 == spanFramePFD->mBounds.width) && (0 == spanFramePFD->mBounds.height);
 
 #ifdef NOISY_VERTICAL_ALIGN
   printf("[%sSpan]", (psd == mRootSpan)?"Root":"");
   nsFrame::ListTag(stdout, spanFrame);
   printf(": preMode=%s strictMode=%s w/h=%d,%d emptyContinuation=%s",
          preMode ? "yes" : "no",
          mPresContext->CompatibilityMode() != eCompatibility_NavQuirks ? "yes" : "no",
@@ -1674,17 +1673,18 @@ nsLineLayout::VerticalAlignFrames(PerSpa
     // is based on the line-height value, not the font-size. Also
     // compute the top leading.
     nscoord logicalHeight = nsHTMLReflowState::CalcLineHeight(spanFrame);
     nscoord contentHeight = spanFramePFD->mBounds.height -
       spanFramePFD->mBorderPadding.top - spanFramePFD->mBorderPadding.bottom;
 
     // Special-case for a ::first-letter frame, set the line height to
     // the frame height if the user has left line-height == normal 
-    if (spanFramePFD->GetFlag(PFD_ISLETTERFRAME) && !spanPrevInFlow &&
+    if (spanFramePFD->GetFlag(PFD_ISLETTERFRAME) &&
+        !spanFrame->GetPrevInFlow() &&
         spanFrame->GetStyleText()->mLineHeight.GetUnit() == eStyleUnit_Normal) {
       logicalHeight = spanFramePFD->mBounds.height;
     }
 
     nscoord leading = logicalHeight - contentHeight;
     psd->mTopLeading = leading / 2;
     psd->mBottomLeading = leading - psd->mTopLeading;
     psd->mLogicalHeight = logicalHeight;
diff -r 4b060ed856e0 layout/generic/nsSelection.cpp
--- a/layout/generic/nsSelection.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/layout/generic/nsSelection.cpp	Thu Oct 16 21:24:48 2008 -0500
@@ -2307,16 +2307,22 @@ nsFrameSelection::CharacterMove(PRBool a
 {
   if (aForward)
     return MoveCaret(nsIDOMKeyEvent::DOM_VK_RIGHT,aExtend,eSelectCharacter);
   else
     return MoveCaret(nsIDOMKeyEvent::DOM_VK_LEFT,aExtend,eSelectCharacter);
 }
 
 nsresult
+nsFrameSelection::CharacterExtendForDelete()
+{
+  return MoveCaret(nsIDOMKeyEvent::DOM_VK_DELETE, PR_TRUE, eSelectCharacter);
+}
+
+nsresult
 nsFrameSelection::WordMove(PRBool aForward, PRBool aExtend)
 {
   if (aForward)
     return MoveCaret(nsIDOMKeyEvent::DOM_VK_RIGHT,aExtend,eSelectWord);
   else
     return MoveCaret(nsIDOMKeyEvent::DOM_VK_LEFT,aExtend,eSelectWord);
 }
 
@@ -4573,17 +4579,18 @@ nsTypedSelection::selectFrames(nsPresCon
         {
           return NS_OK;
         }
       }
     }
     // Now iterated through the child frames and set them
     while (!aInnerIter->IsDone())
     {
-      nsIContent *innercontent = aInnerIter->GetCurrentNode();
+      nsCOMPtr<nsIContent> innercontent =
+        do_QueryInterface(aInnerIter->GetCurrentNode());
 
       frame = mFrameSelection->GetShell()->GetPrimaryFrameFor(innercontent);
       if (frame)
       {
         //NOTE: eSpreadDown is now IGNORED. Selected state is set only
         //for given frame
 
         //spread from here to hit all frames in flow
@@ -4667,17 +4674,17 @@ nsTypedSelection::selectFrames(nsPresCon
       if (frame)
         frame->SetSelected(aPresContext, aRange, aFlags, eSpreadDown, mType);//spread from here to hit all frames in flow
     }
 //end start content
     iter->First();
 
     while (!iter->IsDone())
     {
-      content = iter->GetCurrentNode();
+      content = do_QueryInterface(iter->GetCurrentNode());
 
       selectFrames(aPresContext, inneriter, content, aRange, presShell,aFlags);
 
       iter->Next();
     }
 //we must now do the last one  if it is not the same as the first
     if (FetchEndParent(aRange) != FetchStartParent(aRange))
     {
diff -r 4b060ed856e0 layout/generic/test/test_backspace_delete.html
--- a/layout/generic/test/test_backspace_delete.html	Tue Oct 14 17:12:28 2008 -0700
+++ b/layout/generic/test/test_backspace_delete.html	Thu Oct 16 21:24:48 2008 -0500
@@ -48,24 +48,20 @@ function test() {
   netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
 
   var wordSelModifiers =
       (navigator.platform.indexOf("Mac") >= 0) ?
         {shiftKey:true, altKey:true} : {shiftKey:true, ctrlKey:true};
   var sel = window.getSelection();
   var editor = document.getElementById("editor");
 
-  var todo1 = false;
-  var todo2 = false;
-
   function testRight(node, offset) {
     synthesizeKey("VK_RIGHT", {});
     is(sel.anchorNode, node, "Right movement broken in \"" + editor.innerHTML + "\"");
-    var is_func2 = todo2 ? todo_is : is;
-    is_func2(sel.anchorOffset, offset, "Right movement broken in \"" + editor.innerHTML + "\"");
+    is(sel.anchorOffset, offset, "Right movement broken in \"" + editor.innerHTML + "\"");
   }
 
   function selErrString(dir) {
     return dir + " selection broken with eatSpace=" + eatSpace + " in \"" + editor.innerHTML + "\"";
   }
 
   function testWordSelRight(startNode, startOffset, endNode, endOffset) {
     synthesizeKey("VK_RIGHT", wordSelModifiers);
@@ -74,48 +70,42 @@ function test() {
     is(selRange.startOffset, startOffset, selErrString("Word right"));
     is(selRange.endContainer, endNode, selErrString("Word right"));
     is(selRange.endOffset, endOffset, selErrString("Word right"));
   }
 
   function testDelete(node, offset, text) {
     synthesizeKey("VK_DELETE", {});
     is(sel.anchorNode, node, "Delete broken in \"" + editor.innerHTML + "\"");
-    var is_func2 = todo2 ? todo_is : is;
-    is_func2(sel.anchorOffset, offset, "Delete broken in \"" + editor.innerHTML + "\"");
-    var is_func1 = todo1 ? todo_is : is;
-    is_func1(editor.textContent, text, "Delete broken in \"" + editor.innerHTML + "\"");
+    is(sel.anchorOffset, offset, "Delete broken in \"" + editor.innerHTML + "\"");
+    is(editor.textContent, text, "Delete broken in \"" + editor.innerHTML + "\"");
   }
 
   function testBackspace(node, offset, text) {
     synthesizeKey("VK_BACK_SPACE", {});
     is(sel.anchorNode, node, "Backspace broken in \"" + editor.innerHTML + "\"");
     is(sel.anchorOffset, offset, "Backspace broken in \"" + editor.innerHTML + "\"");
     is(editor.textContent, text, "Backspace broken in \"" + editor.innerHTML + "\"");
   }
 
   // Test cell-wise deletion of Delete
   editor.innerHTML = "";
   sel.collapse(editor.firstChild, 0);
-  todo1 = true;
   testRight(editor.firstChild, 1);
   testDelete(editor.firstChild, 1, "");
   testRight(editor.firstChild, 2);
   testDelete(editor.firstChild, 2, "");
   testRight(editor.firstChild, 4);
   testDelete(editor.firstChild, 4, "");
   testRight(editor.firstChild, 5);
   testDelete(editor.firstChild, 5, "");
-  todo2 = true;
   testRight(editor.firstChild, 8);
   testDelete(editor.firstChild, 8, "");
   testRight(editor.firstChild, 9);
   testDelete(editor.firstChild, 9, "");
-  todo1 = false;
-  todo2 = false;
 
   // Test character-wise deletion of Backspace
   editor.innerHTML = "";
   sel.collapse(editor.firstChild, 0);
   testRight(editor.firstChild, 1);
   testBackspace(editor.firstChild, 0, "");
   testRight(editor.firstChild, 2);
   testBackspace(editor.firstChild, 1, "");
@@ -161,16 +151,29 @@ function test() {
   testDelete(editor.firstChild, 0, "\u00A0yellow fox");
   testWordSelRight(editor.firstChild, 0, editor.firstChild, 7);
   testDelete(editor.firstChild, 0, "\u00A0fox");
   testWordSelRight(editor.firstChild, 0, editor.firstChild, 4);
   testDelete(editor, 0, "");
 
   restoreEatSpace();
 
+  // Tests for Bug 419217
+
+  editor.innerHTML = "foo<div>bar</div>";
+  sel.collapse(editor.firstChild, 3);
+  testDelete(editor.firstChild, 3, "foobar");
+
+  // Tests for Bug 419406
+
+  editor.innerHTML = "hello";
+  sel.collapse(editor.firstChild, 4);
+  testRight(editor.firstChild, 5);
+  testDelete(editor.firstChild, 5, "hello");
+
   SimpleTest.finish();
 }
 
 
 </script>
 </pre>
 </body>
 </html>
diff -r 4b060ed856e0 layout/reftests/bugs/306630-1-ref.html
--- a/layout/reftests/bugs/306630-1-ref.html	Tue Oct 14 17:12:28 2008 -0700
+++ b/layout/reftests/bugs/306630-1-ref.html	Thu Oct 16 21:24:48 2008 -0500
@@ -1,4 +1,6 @@
 <frameset rows="170,*">
-<frame src="data:text/html,frame1">
-<frame src="data:text/html,frame2">
+  <!-- Have to specify charset=ISO-8859-1 because that's what javascript: will
+       do and the fonts used depend on the charset. -->
+<frame src="data:text/html;charset=ISO-8859-1,frame1">
+<frame src="data:text/html;charset=ISO-8859-1,frame2">
 </frameset>
diff -r 4b060ed856e0 layout/reftests/bugs/411334-1-ref.xml
--- a/layout/reftests/bugs/411334-1-ref.xml	Tue Oct 14 17:12:28 2008 -0700
+++ b/layout/reftests/bugs/411334-1-ref.xml	Thu Oct 16 21:24:48 2008 -0500
@@ -1,7 +1,7 @@
 <html xmlns="http://www.w3.org/1999/xhtml">
 <body>
-<div style="font-family: serif; font-size: 100px;">
+<div style="font-family: serif; font-size: 100px; padding-left:10px;">
   W<img style="width:0px; height:200px;" src="mozilla-banner.gif"/>
 </div>
 </body>
 </html>
diff -r 4b060ed856e0 layout/reftests/bugs/411334-1.xml
--- a/layout/reftests/bugs/411334-1.xml	Tue Oct 14 17:12:28 2008 -0700
+++ b/layout/reftests/bugs/411334-1.xml	Thu Oct 16 21:24:48 2008 -0500
@@ -1,7 +1,7 @@
 <html xmlns="http://www.w3.org/1999/xhtml">
 <body>
 <svg xmlns="http://www.w3.org/2000/svg" style="font-family: serif; font-size: 100px;" height="500" width="500">
-  <text x="0" y="200">W</text>
+  <text x="10" y="200">W</text>
 </svg>
 </body>
 </html>
diff -r 4b060ed856e0 layout/reftests/bugs/413286-1a.html
--- a/layout/reftests/bugs/413286-1a.html	Tue Oct 14 17:12:28 2008 -0700
+++ b/layout/reftests/bugs/413286-1a.html	Thu Oct 16 21:24:48 2008 -0500
@@ -1,14 +1,14 @@
 <html>
   <head>
     <style>
       table     { width: 400px; height: 25px; }
-      td.blue   { background: lightblue;  color: lightblue  }
-      td.green  { background: lightgreen; color: lightgreen }
+      td.blue   { background: lightblue;  color: rgba(0,0,0,0) }
+      td.green  { background: lightgreen; color: rgba(0,0,0,0) }
       col.a     { width: 100px; }
       col.c     { width: 25%;   }
     </style>
   </head>
   <body>
     With colspan:
     <table cellspacing=0 cellpadding=0>
       <colgroup><col class="a"/><col/><col class="c"/></colgroup>
diff -r 4b060ed856e0 layout/reftests/bugs/413286-1b.html
--- a/layout/reftests/bugs/413286-1b.html	Tue Oct 14 17:12:28 2008 -0700
+++ b/layout/reftests/bugs/413286-1b.html	Thu Oct 16 21:24:48 2008 -0500
@@ -1,14 +1,14 @@
 <html>
   <head>
     <style>
       table     { width: 400px; height: 25px; }
-      td.blue   { background: lightblue;  color: lightblue  }
-      td.green  { background: lightgreen; color: lightgreen }
+      td.blue   { background: lightblue;  color: rgba(0,0,0,0) }
+      td.green  { background: lightgreen; color: rgba(0,0,0,0) }
       col.a     { width: 25%;   }
       col.c     { width: 25%;   }
     </style>
   </head>
   <body>
     With colspan:
     <table cellspacing=0 cellpadding=0>
       <colgroup><col class="a"/><col/><col class="c"/></colgroup>
diff -r 4b060ed856e0 layout/reftests/bugs/413286-1c.html
--- a/layout/reftests/bugs/413286-1c.html	Tue Oct 14 17:12:28 2008 -0700
+++ b/layout/reftests/bugs/413286-1c.html	Thu Oct 16 21:24:48 2008 -0500
@@ -1,14 +1,14 @@
 <html>
   <head>
     <style>
       table     { width: 400px; height: 25px; }
-      td.blue   { background: lightblue;  color: lightblue  }
-      td.green  { background: lightgreen; color: lightgreen }
+      td.blue   { background: lightblue;  color: rgba(0,0,0,0) }
+      td.green  { background: lightgreen; color: rgba(0,0,0,0) }
       col.a     { width: 100px; }
       col.c     { width: 100px; }
     </style>
   </head>
   <body>
     With colspan:
     <table cellspacing=0 cellpadding=0>
       <colgroup><col class="a"/><col/><col class="c"/></colgroup>
diff -r 4b060ed856e0 layout/reftests/bugs/427370-1-ref.html
--- a/layout/reftests/bugs/427370-1-ref.html	Tue Oct 14 17:12:28 2008 -0700
+++ b/layout/reftests/bugs/427370-1-ref.html	Thu Oct 16 21:24:48 2008 -0500
@@ -38,72 +38,75 @@
 
         .rtl { 
                 direction:rtl;
         }
         .ltr { 
                 direction:ltr;
         }
 
+        .C {
+                padding:0 0.2em 0 0.2em;
+        }
     </style>
 </head>
 <body>
 <div style="position:absolute;top:0;left: 50px;bottom:0;width:1px;background:lime;opacity:0.5"></div>
 <div style="position:absolute;top:0;right:50px;bottom:0;width:1px;background:lime;opacity:0.5"></div>
 
 <div class="ltr">
                 <ol>
                         <li><div style="overflow:hidden;">
                                 <label></label>
                                 Outside
                         </div></li>
                         <li><div style="overflow:hidden;">
-                                <div></div><div>C</div>
+                                <div></div><div><span class="C">C</span></div>
                         </div></li>
 </ol>
 </div>
 
 <div class="rtl">
 <ol>
                         <li><div style="overflow:hidden;">
                                 <label></label>
                                 Outside
                         </div></li>
                         <li><div style="overflow:hidden;">
-                                <div></div><div>C</div>
+                                <div></div><div><span class="C">C</span></div>
                         </div></li>
 </ol>
 </div>
 
 <br style="clear:both;">
 
 <div style="float:left; width:100px; height:5em; border:1px solid black"></div>
 <div class="ltr">
                 <ol>
                         <li><div style="overflow:hidden;">
                                 <label></label>
                                 Outside
                         </div></li>
                         <li><div style="overflow:hidden;">
-                                <div></div><div>C</div>
+                                <div></div><div><span class="C">C</span></div>
                         </div></li>
 </ol>
 </div>
 
 <br style="clear:both;">
 
 <div style="float:right; width:100px; height:5em; border:1px solid black"></div>
 <div class="rtl">
 <ol>
                         <li><div style="overflow:hidden;">
                                 <label></label>
                                 Outside
                         </div></li>
                         <li><div style="overflow:hidden;">
-                                <div></div><div>C</div>
+                                <div></div><div><span class="C">C</span></div>
                         </div></li>
 </ol>
 </div>
 
 
 <br style="clear:both;">
 
 <div class="ltr">
diff -r 4b060ed856e0 layout/reftests/bugs/427370-1.html
--- a/layout/reftests/bugs/427370-1.html	Tue Oct 14 17:12:28 2008 -0700
+++ b/layout/reftests/bugs/427370-1.html	Thu Oct 16 21:24:48 2008 -0500
@@ -38,72 +38,75 @@
 
         .rtl { 
                 direction:rtl;
         }
         .ltr { 
                 direction:ltr;
         }
 
+        .C {
+                padding:0 0.2em 0 0.2em;
+        }
     </style>
 </head>
 <body>
 <div style="position:absolute;top:0;left: 50px;bottom:0;width:1px;background:lime;opacity:0.5"></div>
 <div style="position:absolute;top:0;right:50px;bottom:0;width:1px;background:lime;opacity:0.5"></div>
 
 <div class="ltr">
                 <ol>
                         <li>
                                 <label></label>
                                 Outside
                         </li>
                         <li>
-                                <div></div><div>C</div>
+                                <div></div><div><span class="C">C</span></div>
                         </li>
 </ol>
 </div>
 
 <div class="rtl">
 <ol>
                         <li>
                                 <label></label>
                                 Outside
                         </li>
                         <li>
-                                <div></div><div>C</div>
+                                <div></div><div><span class="C">C</span></div>
                         </li>
 </ol>
 </div>
 
 <br style="clear:both;">
 
 <div style="float:left; width:100px; height:5em; border:1px solid black"></div>
 <div class="ltr">
                 <ol>
                         <li>
                                 <label></label>
                                 Outside
                         </li>
                         <li>
-                                <div></div><div>C</div>
+                                <div></div><div><span class="C">C</span></div>
                         </li>
 </ol>
 </div>
 
 <br style="clear:both;">
 
 <div style="float:right; width:100px; height:5em; border:1px solid black"></div>
 <div class="rtl">
 <ol>
                         <li>
                                 <label></label>
                                 Outside
                         </li>
                         <li>
-                                <div></div><div>C</div>
+                                <div></div><div><span class="C">C</span></div>
                         </li>
 </ol>
 </div>
 
 
 <br style="clear:both;">
 
 <div class="ltr">
diff -r 4b060ed856e0 layout/reftests/bugs/430813-3-ref.html
--- a/layout/reftests/bugs/430813-3-ref.html	Tue Oct 14 17:12:28 2008 -0700
+++ b/layout/reftests/bugs/430813-3-ref.html	Thu Oct 16 21:24:48 2008 -0500
@@ -3,12 +3,12 @@
 <head>
 	<title>Testcase, bug 430813</title>
 	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
 </head>
 <body>
 <div style="margin-bottom: 1px">text</div>
 <div style="float:left;width:90px;height:300px"></div>
 <div style="margin-left:90px">
-This text should be near the top of the page, not pushed below the float.
+<span style="padding:0.2em;">This text should be near the top of the page, not pushed below the float.</span>
 </div>
 </body>
 </html>
diff -r 4b060ed856e0 layout/reftests/bugs/430813-3.html
--- a/layout/reftests/bugs/430813-3.html	Tue Oct 14 17:12:28 2008 -0700
+++ b/layout/reftests/bugs/430813-3.html	Thu Oct 16 21:24:48 2008 -0500
@@ -3,12 +3,12 @@
 <head>
 	<title>Testcase, bug 430813</title>
 	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
 </head>
 <body>
 <div style="margin-bottom: 1px">text</div>
 <div style="float:left;width:90px;height:300px"></div>
 <div style="overflow:hidden">
-This text should be near the top of the page, not pushed below the float.
+<span style="padding:0.2em;">This text should be near the top of the page, not pushed below the float.</span>
 </div>
 </body>
 </html>
diff -r 4b060ed856e0 layout/reftests/bugs/442542-1-ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/442542-1-ref.html	Thu Oct 16 21:24:48 2008 -0500
@@ -0,0 +1,4 @@
+<!DOCTYPE html>
+<body>
+  <iframe src="442542-subframe.html" width="200" height="200"></iframe>
+</body>
diff -r 4b060ed856e0 layout/reftests/bugs/442542-1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/442542-1.html	Thu Oct 16 21:24:48 2008 -0500
@@ -0,0 +1,4 @@
+<!DOCTYPE html>
+<body onload="document.getElementsByTagName('iframe')[0].width = 200">
+  <iframe src="442542-subframe.html" width="300" height="200"></iframe>
+</body>
diff -r 4b060ed856e0 layout/reftests/bugs/442542-subframe.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/442542-subframe.html	Thu Oct 16 21:24:48 2008 -0500
@@ -0,0 +1,8 @@
+<!DOCTYPE html>
+<body>
+  <div style="position:relative">
+    <div style="float:right; height: 10px"></div>
+    <div style="clear:right"></div>
+    <div style="position:absolute; top:4em; right:0; background:green; width: 100px; height: 100px"></div>
+  </div>
+</body>
diff -r 4b060ed856e0 layout/reftests/bugs/reftest.list
--- a/layout/reftests/bugs/reftest.list	Tue Oct 14 17:12:28 2008 -0700
+++ b/layout/reftests/bugs/reftest.list	Thu Oct 16 21:24:48 2008 -0500
@@ -903,16 +903,17 @@ random == 429849-1.html 429849-1-ref.htm
 == 438987-2b.html 438987-2-ref.html
 == 438987-2c.html 438987-2-ref.html
 != about:blank 438987-2-ref.html # check that backgrounds work at all 
 == 439004-1.html 439004-1-ref.html
 == 439639-1.html 439639-1-ref.html
 == 439910.html 439910-ref.html
 == 441259-1.html 441259-1-ref.html
 fails == 441259-2.html 441259-2-ref.html # bug 441400
+== 442542-1.html 442542-1-ref.html
 == 444015-1.html 444015-1-ref.html
 == 444928-1.html 444928-1-ref.html
 == 444928-2.html 444928-2-ref.html
 != 444928-3.html 444928-3-notref.html
 # == 448193.html 448193-ref.html  # Fails due to 2 small single-pixel differences
 # == 448987.html 448987-ref.html  # Disabled for now - it needs privileges
 == 449171-1.html 449171-ref.html
 == 449519-1.html 449519-1-ref.html
diff -r 4b060ed856e0 layout/reftests/reftest-sanity/reftest.list
--- a/layout/reftests/reftest-sanity/reftest.list	Tue Oct 14 17:12:28 2008 -0700
+++ b/layout/reftests/reftest-sanity/reftest.list	Thu Oct 16 21:24:48 2008 -0500
@@ -1,15 +1,18 @@
 == data:text/html,<body> about:blank
 == data:text/plain, about:blank
 != data:text/plain,HELLO about:blank
 
 # these tests make sure async reftests work:
 == test-async.xul test-async-ref.xul
 == test-async.html test-async-ref.html
+
+# test that zoom works (and really zooms, not just scales)
+== test-zoom.html test-zoom-ref.html
 
 # Makes sure that the file: protocol handler and HTTP server both
 # choose HTML vs. XHTML processing based on the file extensions.
 != html-vs-xhtml-by-extension.html html-vs-xhtml-by-extension.xhtml
 HTTP != html-vs-xhtml-by-extension.html html-vs-xhtml-by-extension.xhtml
 
 # make sure red and green colors are not the default and are different from
 # each other
diff -r 4b060ed856e0 layout/reftests/reftest-sanity/test-zoom-ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/reftest-sanity/test-zoom-ref.html	Thu Oct 16 21:24:48 2008 -0500
@@ -0,0 +1,7 @@
+<!DOCTYPE HTML>
+<html>
+<body style="margin:0;">
+<div style="background:yellow; height:15px;"></div>
+<div style="position:absolute; top:150px; left:150px; width:150px; height:150px; border:1px solid black;"></div>
+</body>
+</html>
diff -r 4b060ed856e0 layout/reftests/reftest-sanity/test-zoom.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/reftest-sanity/test-zoom.html	Thu Oct 16 21:24:48 2008 -0500
@@ -0,0 +1,7 @@
+<!DOCTYPE HTML>
+<html reftest-zoom="1.5">
+<body style="margin:0;">
+<div style="background:yellow; height:10px;"></div>
+<div style="position:absolute; top:100px; left:100px; width:100px; height:100px; border:1px solid black;"></div>
+</body>
+</html>
diff -r 4b060ed856e0 layout/reftests/svg/filter-translated-01-ref.svg
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/svg/filter-translated-01-ref.svg	Thu Oct 16 21:24:48 2008 -0500
@@ -0,0 +1,9 @@
+<!--
+     Any copyright is dedicated to the Public Domain.
+     http://creativecommons.org/licenses/publicdomain/
+-->
+<svg xmlns="http://www.w3.org/2000/svg">
+  <g transform="translate(100)">
+    <rect fill="lime" width="50" height="50"/>
+  </g>
+</svg>
diff -r 4b060ed856e0 layout/reftests/svg/filter-translated-01.svg
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/svg/filter-translated-01.svg	Thu Oct 16 21:24:48 2008 -0500
@@ -0,0 +1,12 @@
+<!--
+     Any copyright is dedicated to the Public Domain.
+     http://creativecommons.org/licenses/publicdomain/
+-->
+<svg xmlns="http://www.w3.org/2000/svg">
+  <filter id="f" filterUnits="objectBoundingBox" x="0%" y="0%" width="100%" height="100%">
+    <feOffset/>
+  </filter>
+  <g transform="translate(100)" filter="url(#f)">
+    <rect fill="lime" width="50" height="50"/>
+  </g>
+</svg>
diff -r 4b060ed856e0 layout/reftests/svg/reftest.list
--- a/layout/reftests/svg/reftest.list	Tue Oct 14 17:12:28 2008 -0700
+++ b/layout/reftests/svg/reftest.list	Thu Oct 16 21:24:49 2008 -0500
@@ -46,16 +46,17 @@ include moz-only/reftest.list
 == fallback-color-01b.svg pass.svg
 == fallback-color-02a.svg fallback-color-02-ref.svg
 == fallback-color-02b.svg fallback-color-02-ref.svg
 == fallback-color-03.svg pass.svg
 == filter-basic-01.svg pass.svg
 == filter-basic-02.svg pass.svg
 == filter-basic-03.svg pass.svg
 == filter-foreignObject-01.svg pass.svg
+== filter-translated-01.svg filter-translated-01-ref.svg
 == foreignObject-01.svg pass.svg
 == foreignObject-ancestor-style-change-01.svg foreignObject-ancestor-style-change-01-ref.svg
 == foreignObject-change-transform-01.svg pass.svg
 == foreignObject-display-01.svg pass.svg
 == foreignObject-move-repaint-01.svg pass.svg
 == foreignObject-overflow-01.svg pass.svg
 == getElementById-a-element-01.svg pass.svg
 fails == inline-in-xul-basic-01.xul pass.svg
diff -r 4b060ed856e0 layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/layout/style/nsCSSParser.cpp	Thu Oct 16 21:24:49 2008 -0500
@@ -7735,18 +7735,16 @@ CSSParserImpl::GetNamespaceIdForPrefix(c
   PRInt32 nameSpaceID = kNameSpaceID_Unknown;
   if (mNameSpaceMap) {
     // user-specified identifiers are case-sensitive (bug 416106)
     nsCOMPtr<nsIAtom> prefix = do_GetAtom(aPrefix);
     nameSpaceID = mNameSpaceMap->FindNameSpaceID(prefix);
   }
   // else no declared namespaces
 
-  NS_ASSERTION(nameSpaceID != kNameSpaceID_None, "Shouldn't happen!");
-
   if (kNameSpaceID_Unknown == nameSpaceID) {   // unknown prefix, dump it
     const PRUnichar *params[] = {
       aPrefix.get()
     };
     REPORT_UNEXPECTED_P(PEUnknownNamespacePrefix, params);
     if (mUnresolvablePrefixException)
       mScanner.SetLowLevelError(NS_ERROR_DOM_NAMESPACE_ERR);
     return PR_FALSE;
@@ -7754,22 +7752,20 @@ CSSParserImpl::GetNamespaceIdForPrefix(c
 
   *aNameSpaceID = nameSpaceID;
   return PR_TRUE;
 }
 
 void
 CSSParserImpl::SetDefaultNamespaceOnSelector(nsCSSSelector& aSelector)
 {
-  aSelector.SetNameSpace(kNameSpaceID_Unknown); // wildcard
-  if (mNameSpaceMap) { // look for default namespace
-    PRInt32 defaultID = mNameSpaceMap->FindNameSpaceID(nsnull);
-    if (defaultID != kNameSpaceID_None) {
-      aSelector.SetNameSpace(defaultID);
-    }
+  if (mNameSpaceMap) {
+    aSelector.SetNameSpace(mNameSpaceMap->FindNameSpaceID(nsnull));
+  } else {
+    aSelector.SetNameSpace(kNameSpaceID_Unknown); // wildcard
   }
 }
 
 #ifdef MOZ_SVG
 PRBool
 CSSParserImpl::ParsePaint(nsCSSValuePair* aResult,
                           nsCSSProperty aPropID)
 {
diff -r 4b060ed856e0 layout/style/nsCSSStyleSheet.cpp
--- a/layout/style/nsCSSStyleSheet.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/layout/style/nsCSSStyleSheet.cpp	Thu Oct 16 21:24:49 2008 -0500
@@ -888,54 +888,69 @@ nsCSSStyleSheetInner::RemoveSheet(nsICSS
     mOrderedRules.EnumerateForwards(SetStyleSheetReference,
                                     (nsICSSStyleSheet*)mSheets.ElementAt(0));
   }
   else {
     mSheets.RemoveElement(aSheet);
   }
 }
 
+static void
+AddNamespaceRuleToMap(nsICSSRule* aRule, nsXMLNameSpaceMap* aMap)
+{
+#ifdef DEBUG
+  PRInt32 type;
+  aRule->GetType(type);
+  NS_ASSERTION(type == nsICSSRule::NAMESPACE_RULE, "Bogus rule type");
+#endif
+
+  nsCOMPtr<nsICSSNameSpaceRule> nameSpaceRule = do_QueryInterface(aRule);
+  
+  nsCOMPtr<nsIAtom> prefix;
+  nsAutoString  urlSpec;
+  nameSpaceRule->GetPrefix(*getter_AddRefs(prefix));
+  nameSpaceRule->GetURLSpec(urlSpec);
+
+  aMap->AddPrefix(prefix, urlSpec);
+}
+
 static PRBool
 CreateNameSpace(nsICSSRule* aRule, void* aNameSpacePtr)
 {
   PRInt32 type = nsICSSRule::UNKNOWN_RULE;
   aRule->GetType(type);
   if (nsICSSRule::NAMESPACE_RULE == type) {
-    nsICSSNameSpaceRule*  nameSpaceRule = (nsICSSNameSpaceRule*)aRule;
-    nsXMLNameSpaceMap *nameSpaceMap =
-      static_cast<nsXMLNameSpaceMap*>(aNameSpacePtr);
-
-    nsIAtom*      prefix = nsnull;
-    nsAutoString  urlSpec;
-    nameSpaceRule->GetPrefix(prefix);
-    nameSpaceRule->GetURLSpec(urlSpec);
-
-    nameSpaceMap->AddPrefix(prefix, urlSpec);
+    AddNamespaceRuleToMap(aRule,
+                          static_cast<nsXMLNameSpaceMap*>(aNameSpacePtr));
     return PR_TRUE;
   }
-  // stop if not namespace, import or charset because namespace can't follow anything else
-  return (((nsICSSRule::CHARSET_RULE == type) || 
-           (nsICSSRule::IMPORT_RULE)) ? PR_TRUE : PR_FALSE); 
+  // stop if not namespace, import or charset because namespace can't follow
+  // anything else
+  return (nsICSSRule::CHARSET_RULE == type || nsICSSRule::IMPORT_RULE == type);
 }
 
 void 
 nsCSSStyleSheetInner::RebuildNameSpaces()
 {
-  if (mNameSpaceMap) {
-    mNameSpaceMap->Clear();
-  } else {
-    mNameSpaceMap = nsXMLNameSpaceMap::Create();
-    if (!mNameSpaceMap) {
-      return; // out of memory
-    }
+  // Just nuke our existing namespace map, if any
+  if (NS_SUCCEEDED(CreateNamespaceMap())) {
+    mOrderedRules.EnumerateForwards(CreateNameSpace, mNameSpaceMap);
   }
-
-  mOrderedRules.EnumerateForwards(CreateNameSpace, mNameSpaceMap);
 }
 
+nsresult
+nsCSSStyleSheetInner::CreateNamespaceMap()
+{
+  mNameSpaceMap = nsXMLNameSpaceMap::Create();
+  NS_ENSURE_TRUE(mNameSpaceMap, NS_ERROR_OUT_OF_MEMORY);
+  // Override the default namespace map behavior for the null prefix to
+  // return the wildcard namespace instead of the null namespace.
+  mNameSpaceMap->AddPrefix(nsnull, kNameSpaceID_Unknown);
+  return NS_OK;
+}
 
 // -------------------------------
 // CSS Style Sheet
 //
 
 nsCSSStyleSheet::nsCSSStyleSheet()
   : nsICSSStyleSheet(),
     mRefCnt(0),
@@ -1365,29 +1380,18 @@ nsCSSStyleSheet::AppendStyleRule(nsICSSR
   if (NS_SUCCEEDED(WillDirty())) {
     mInner->mOrderedRules.AppendObject(aRule);
     aRule->SetStyleSheet(this);
     DidDirty();
 
     PRInt32 type = nsICSSRule::UNKNOWN_RULE;
     aRule->GetType(type);
     if (nsICSSRule::NAMESPACE_RULE == type) {
-      if (!mInner->mNameSpaceMap) {
-        mInner->mNameSpaceMap = nsXMLNameSpaceMap::Create();
-        NS_ENSURE_TRUE(mInner->mNameSpaceMap, NS_ERROR_OUT_OF_MEMORY);
-      }
-
-      nsCOMPtr<nsICSSNameSpaceRule> nameSpaceRule(do_QueryInterface(aRule));
-
-      nsCOMPtr<nsIAtom> prefix;
-      nsAutoString  urlSpec;
-      nameSpaceRule->GetPrefix(*getter_AddRefs(prefix));
-      nameSpaceRule->GetURLSpec(urlSpec);
-
-      mInner->mNameSpaceMap->AddPrefix(prefix, urlSpec);
+      nsresult rv = RegisterNamespaceRule(aRule);
+      NS_ENSURE_SUCCESS(rv, rv);
     }
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCSSStyleSheet::ReplaceStyleRule(nsICSSRule* aOld, nsICSSRule* aNew)
 {
@@ -1625,16 +1629,28 @@ nsCSSStyleSheet::SubjectSubsumesInnerPri
   if (subsumes) {
     return NS_OK;
   }
   
   if (!nsContentUtils::IsCallerTrustedForWrite()) {
     return NS_ERROR_DOM_SECURITY_ERR;
   }
 
+  return NS_OK;
+}
+
+nsresult
+nsCSSStyleSheet::RegisterNamespaceRule(nsICSSRule* aRule)
+{
+  if (!mInner->mNameSpaceMap) {
+    nsresult rv = mInner->CreateNamespaceMap();
+    NS_ENSURE_SUCCESS(rv, rv);
+  }
+
+  AddNamespaceRuleToMap(aRule, mInner->mNameSpaceMap);
   return NS_OK;
 }
 
 NS_IMETHODIMP 
 nsCSSStyleSheet::IsModified(PRBool* aSheetModified) const
 {
   *aSheetModified = mDirty;
   return NS_OK;
@@ -1922,29 +1938,21 @@ nsCSSStyleSheet::InsertRuleInternal(cons
 
   for (PRInt32 counter = 0; counter < rulecount; counter++) {
     nsICSSRule* cssRule = rules.ObjectAt(counter);
     cssRule->SetStyleSheet(this);
     
     PRInt32 type = nsICSSRule::UNKNOWN_RULE;
     cssRule->GetType(type);
     if (type == nsICSSRule::NAMESPACE_RULE) {
-      if (!mInner->mNameSpaceMap) {
-        mInner->mNameSpaceMap = nsXMLNameSpaceMap::Create();
-        NS_ENSURE_TRUE(mInner->mNameSpaceMap, NS_ERROR_OUT_OF_MEMORY);
-      }
-
-      nsCOMPtr<nsICSSNameSpaceRule> nameSpaceRule(do_QueryInterface(cssRule));
-    
-      nsCOMPtr<nsIAtom> prefix;
-      nsAutoString urlSpec;
-      nameSpaceRule->GetPrefix(*getter_AddRefs(prefix));
-      nameSpaceRule->GetURLSpec(urlSpec);
-
-      mInner->mNameSpaceMap->AddPrefix(prefix, urlSpec);
+      // XXXbz does this screw up when inserting a namespace rule before
+      // another namespace rule that binds the same prefix to a different
+      // namespace?
+      result = RegisterNamespaceRule(cssRule);
+      NS_ENSURE_SUCCESS(result, result);
     }
 
     // We don't notify immediately for @import rules, but rather when
     // the sheet the rule is importing is loaded
     PRBool notify = PR_TRUE;
     if (type == nsICSSRule::IMPORT_RULE) {
       nsCOMPtr<nsIDOMCSSImportRule> importRule(do_QueryInterface(cssRule));
       NS_ASSERTION(importRule, "Rule which has type IMPORT_RULE and does not implement nsIDOMCSSImportRule!");
diff -r 4b060ed856e0 layout/style/nsCSSStyleSheet.h
--- a/layout/style/nsCSSStyleSheet.h	Tue Oct 14 17:12:28 2008 -0700
+++ b/layout/style/nsCSSStyleSheet.h	Thu Oct 16 21:24:49 2008 -0500
@@ -62,23 +62,26 @@ class nsCSSStyleSheet;
 // CSS Style Sheet Inner Data Container
 //
 
 class nsCSSStyleSheetInner {
 public:
   nsCSSStyleSheetInner(nsICSSStyleSheet* aPrimarySheet);
   nsCSSStyleSheetInner(nsCSSStyleSheetInner& aCopy,
                        nsCSSStyleSheet* aPrimarySheet);
-  virtual ~nsCSSStyleSheetInner();
+  ~nsCSSStyleSheetInner();
 
-  virtual nsCSSStyleSheetInner* CloneFor(nsCSSStyleSheet* aPrimarySheet);
-  virtual void AddSheet(nsICSSStyleSheet* aSheet);
-  virtual void RemoveSheet(nsICSSStyleSheet* aSheet);
+  nsCSSStyleSheetInner* CloneFor(nsCSSStyleSheet* aPrimarySheet);
+  void AddSheet(nsICSSStyleSheet* aSheet);
+  void RemoveSheet(nsICSSStyleSheet* aSheet);
 
-  virtual void RebuildNameSpaces();
+  void RebuildNameSpaces();
+
+  // Create a new namespace map
+  nsresult CreateNamespaceMap();
 
   nsAutoVoidArray        mSheets;
   nsCOMPtr<nsIURI>       mSheetURI; // for error reports, etc.
   nsCOMPtr<nsIURI>       mOriginalSheetURI;  // for GetHref.  Can be null.
   nsCOMPtr<nsIURI>       mBaseURI; // for resolving relative URIs
   nsCOMPtr<nsIPrincipal> mPrincipal;
   nsCOMArray<nsICSSRule> mOrderedRules;
   nsAutoPtr<nsXMLNameSpaceMap> mNameSpaceMap;
@@ -200,16 +203,19 @@ protected:
   nsresult WillDirty();
   void     DidDirty();
 
   // Return success if the subject principal subsumes the principal of our
   // inner, error otherwise.  This will also succeed if the subject has
   // UniversalBrowserWrite.
   nsresult SubjectSubsumesInnerPrincipal() const;
 
+  // Add the namespace mapping from this @namespace rule to our namespace map
+  nsresult RegisterNamespaceRule(nsICSSRule* aRule);
+
 protected:
   nsString              mTitle;
   nsCOMPtr<nsMediaList> mMedia;
   nsRefPtr<nsCSSStyleSheet> mNext;
   nsICSSStyleSheet*     mParent;    // weak ref
   nsICSSImportRule*     mOwnerRule; // weak ref
 
   CSSRuleListImpl*      mRuleCollection;
diff -r 4b060ed856e0 layout/style/quirk.css
--- a/layout/style/quirk.css	Tue Oct 14 17:12:28 2008 -0700
+++ b/layout/style/quirk.css	Thu Oct 16 21:24:49 2008 -0500
@@ -32,56 +32,43 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 @namespace url(http://www.w3.org/1999/xhtml); /* set default namespace to HTML */
 
 
-/* Quirk: input images have a blue border (b=28010) */ 
-
-/* default border */
-input[type=image] {
-  border: 2px solid blue;
-}
-
-/* border when disabled -- only change color to gray */
-input[type=image][disabled] {
-  border-color: GrayText;
-}
-
-
 /* Quirk: make orphaned LIs have inside bullet (b=1049) */
 
 /* force inside position for orphaned lis */
 li {
-  list-style-position: inside; 
+  list-style-position: inside;
 }
 
 /* restore outside position for lists inside LIs */
-li ul, li ol, li dir, li menu { 
-  list-style-position: outside; 
+li ul, li ol, li dir, li menu {
+  list-style-position: outside;
 }
 
 /* undo previous two rules for properly nested lists */
   ul ul,   ul ol,   ul dir,   ul menu,   ul li,
   ol ul,   ol ol,   ol dir,   ol menu,   ol li,
  dir ul,  dir ol,  dir dir,  dir menu,  dir li,
 menu ul, menu ol, menu dir, menu menu, menu li {
   list-style-position: inherit;
 }
 
 
-/* Quirk: ensure that we get proper padding if the very first 
+/* Quirk: ensure that we get proper padding if the very first
  * node in an LI is another UL or OL. This is an ugly way to
  * fix the problem, because it extends the LI up into what
  * would otherwise appear to be the ULs space. (b=38832) */
 
-/* Note: this fix will fail once we implement marker box 
+/* Note: this fix will fail once we implement marker box
  * alignment correctly. */
 li > ul:-moz-first-node,
 li > ol:-moz-first-node {
   padding-top: 1em;
 }
 
 
 /* Quirk: prevent bullet from resizing with the list item
@@ -251,27 +238,27 @@ img[align=left] {
   margin-right: 3px;
 }
 
 img[align=right] {
   margin-left: 3px;
 }
 
 
-/* Quirk: Make sure that the residual style tags' size info. 
+/* Quirk: Make sure that the residual style tags' size info.
  * does not take precedence over heading tags' size. (b=77352)
- * Note: This special attribute is set only for a residual 
+ * Note: This special attribute is set only for a residual
  * style tag within a heading tag.
  */
 
 /* XXX This is a potential performance problem.  This should not be
  * using an attribute!
  */
-*[_moz-rs-heading] { 
-  font-size: inherit !important; 
+*[_moz-rs-heading] {
+  font-size: inherit !important;
 }
 
 
 /*
  * Quirk: Use border-box box sizing for text inputs, password inputs, and
  * textareas.  (b=184478 on why we use content-box sizing in standards mode)
  */
 
diff -r 4b060ed856e0 layout/svg/base/src/nsSVGEffects.cpp
--- a/layout/svg/base/src/nsSVGEffects.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/layout/svg/base/src/nsSVGEffects.cpp	Thu Oct 16 21:24:49 2008 -0500
@@ -234,20 +234,22 @@ void
 void
 nsSVGMarkerProperty::DoUpdate()
 {
   nsSVGRenderingObserver::DoUpdate();
   if (!mFrame)
     return;
 
   if (mFrame->IsFrameOfType(nsIFrame::eSVG)) {
-    nsSVGOuterSVGFrame *outerSVGFrame = nsSVGUtils::GetOuterSVGFrame(mFrame);
-    if (outerSVGFrame) {
-      // marker changes can change the covered region
-      outerSVGFrame->UpdateAndInvalidateCoveredRegion(mFrame);
+    if (!(mFrame->GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD)) {
+      nsSVGOuterSVGFrame *outerSVGFrame = nsSVGUtils::GetOuterSVGFrame(mFrame);
+      if (outerSVGFrame) {
+        // marker changes can change the covered region
+        outerSVGFrame->UpdateAndInvalidateCoveredRegion(mFrame);
+      }
     }
   } else {
     InvalidateAllContinuations(mFrame);
   }
 }
 
 void
 nsSVGTextPathProperty::DoUpdate()
diff -r 4b060ed856e0 layout/svg/base/src/nsSVGFilterInstance.cpp
--- a/layout/svg/base/src/nsSVGFilterInstance.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/layout/svg/base/src/nsSVGFilterInstance.cpp	Thu Oct 16 21:24:49 2008 -0500
@@ -346,35 +346,37 @@ nsSVGFilterInstance::BuildSourceImages()
       return NS_ERROR_OUT_OF_MEMORY;
     offscreen->SetDeviceOffset(gfxPoint(-mSurfaceRect.x, -mSurfaceRect.y));
   
     nsSVGRenderState tmpState(offscreen);
     nsCOMPtr<nsIDOMSVGMatrix> userSpaceToFilterSpaceTransform
       = GetUserSpaceToFilterSpaceTransform();
     if (!userSpaceToFilterSpaceTransform)
       return NS_ERROR_OUT_OF_MEMORY;
+    gfxMatrix userSpaceToFilterSpace =
+      nsSVGUtils::ConvertSVGMatrixToThebes(userSpaceToFilterSpaceTransform);
 
-    gfxMatrix m =
-      nsSVGUtils::ConvertSVGMatrixToThebes(userSpaceToFilterSpaceTransform);
     gfxRect r(neededRect.x, neededRect.y, neededRect.width, neededRect.height);
+    gfxMatrix m = userSpaceToFilterSpace;
     m.Invert();
     r = m.TransformBounds(r);
     r.RoundOut();
     nsIntRect dirty;
     nsresult rv = nsSVGUtils::GfxRectToIntRect(r, &dirty);
     if (NS_FAILED(rv))
       return rv;
-    mPaintCallback->Paint(&tmpState, mTargetFrame, &dirty,
-                          userSpaceToFilterSpaceTransform);
+
+    tmpState.GetGfxContext()->Multiply(userSpaceToFilterSpace);
+    mPaintCallback->Paint(&tmpState, mTargetFrame, &dirty);
 
     gfxContext copyContext(sourceColorAlpha);
     copyContext.SetSource(offscreen);
     copyContext.Paint();
   }
-  
+
   if (!mSourceColorAlpha.mResultNeededBox.IsEmpty()) {
     NS_ASSERTION(mSourceColorAlpha.mImageUsers > 0, "Some user must have needed this");
     mSourceColorAlpha.mImage.mImage = sourceColorAlpha;
     // color model is PREMULTIPLIED SRGB by default.
   }
 
   if (!mSourceAlpha.mResultNeededBox.IsEmpty()) {
     NS_ASSERTION(mSourceAlpha.mImageUsers > 0, "Some user must have needed this");
diff -r 4b060ed856e0 layout/svg/base/src/nsSVGFilterPaintCallback.h
--- a/layout/svg/base/src/nsSVGFilterPaintCallback.h	Tue Oct 14 17:12:28 2008 -0700
+++ b/layout/svg/base/src/nsSVGFilterPaintCallback.h	Thu Oct 16 21:24:49 2008 -0500
@@ -41,24 +41,22 @@
 
 class nsIFrame;
 class nsIDOMSVGMatrix;
 class nsSVGRenderState;
 
 class nsSVGFilterPaintCallback {
 public:
   /**
-   * Paint the frame contents. aTransform should be applied to aContext
-   * (either via SetOverrideCTM or by applying the transform to aContext
-   * directly).
+   * Paint the frame contents.
    * SVG frames will have had matrix propagation set to false already.
-   * frames have to do their own thing.
+   * Non-SVG frames have to do their own thing.
    * The caller will do a Save()/Restore() as necessary so feel free
    * to mess with context state.
+   * The context will be configured to use the "user space" coordinate
+   * system.
    * @param aDirtyRect the dirty rect *in user space pixels*
-   * @param aTransform the user-space-to-filter-space transform to apply.
-   * May be null if the identity matrix is requested.
    */
   virtual void Paint(nsSVGRenderState *aContext, nsIFrame *aTarget,
-                     const nsIntRect *aDirtyRect, nsIDOMSVGMatrix *aTransform) = 0;
+                     const nsIntRect *aDirtyRect) = 0;
 };
 
 #endif
diff -r 4b060ed856e0 layout/svg/base/src/nsSVGIntegrationUtils.cpp
--- a/layout/svg/base/src/nsSVGIntegrationUtils.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/layout/svg/base/src/nsSVGIntegrationUtils.cpp	Thu Oct 16 21:24:49 2008 -0500
@@ -192,26 +192,20 @@ class RegularFramePaintCallback : public
 {
 public:
   RegularFramePaintCallback(nsDisplayListBuilder* aBuilder,
                             nsDisplayList* aInnerList,
                             const nsPoint& aOffset)
     : mBuilder(aBuilder), mInnerList(aInnerList), mOffset(aOffset) {}
 
   virtual void Paint(nsSVGRenderState *aContext, nsIFrame *aTarget,
-                     const nsIntRect* aDirtyRect, nsIDOMSVGMatrix *aTransform)
+                     const nsIntRect* aDirtyRect)
   {
     nsIRenderingContext* ctx = aContext->GetRenderingContext(aTarget);
     gfxContext* gfxCtx = aContext->GetGfxContext();
-
-    if (aTransform) {
-      // Transform by aTransform first
-      gfxMatrix m = nsSVGUtils::ConvertSVGMatrixToThebes(aTransform);
-      gfxCtx->Multiply(m);
-    }
 
     // We're expected to paint with 1 unit equal to 1 CSS pixel. But
     // mInnerList->Paint expects 1 unit to equal 1 device pixel. So
     // adjust.
     gfxFloat scale =
       nsPresContext::AppUnitsToFloatCSSPixels(aTarget->PresContext()->AppUnitsPerDevPixel());
     gfxCtx->Scale(scale, scale);
 
diff -r 4b060ed856e0 layout/svg/base/src/nsSVGUtils.cpp
--- a/layout/svg/base/src/nsSVGUtils.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/layout/svg/base/src/nsSVGUtils.cpp	Thu Oct 16 21:24:49 2008 -0500
@@ -922,29 +922,47 @@ nsSVGUtils::RemoveObserver(nsISupports *
 }
 
 // ************************************************************
 
 class SVGPaintCallback : public nsSVGFilterPaintCallback
 {
 public:
   virtual void Paint(nsSVGRenderState *aContext, nsIFrame *aTarget,
-                     const nsIntRect* aDirtyRect, nsIDOMSVGMatrix *aTransform)
+                     const nsIntRect* aDirtyRect)
   {
     nsISVGChildFrame *svgChildFrame;
     CallQueryInterface(aTarget, &svgChildFrame);
     NS_ASSERTION(svgChildFrame, "Expected SVG frame here");
+    NS_ASSERTION(!svgChildFrame->GetMatrixPropagation(),
+                 "This should have been set to false already");
 
-    if (aTransform) {
-      svgChildFrame->SetOverrideCTM(aTransform);
-      svgChildFrame->NotifySVGChanged(nsISVGChildFrame::SUPPRESS_INVALIDATION |
-                                      nsISVGChildFrame::TRANSFORM_CHANGED);
+    nsIntRect* dirtyRect = nsnull;
+    nsIntRect tmpDirtyRect;
+
+    // aDirtyRect is in user-space pixels, we need to convert to
+    // outer-SVG-frame-relative device pixels.
+    if (aDirtyRect) {
+      // Temporarily set SetMatrixPropagation so we can find out what
+      // the actual CTM is.
+      svgChildFrame->SetMatrixPropagation(PR_TRUE);
+      nsCOMPtr<nsIDOMSVGMatrix> ctm = nsSVGUtils::GetCanvasTM(aTarget);
+      NS_ASSERTION(ctm, "graphic source didn't specify a ctm");
+      svgChildFrame->SetMatrixPropagation(PR_FALSE);
+
+      gfxMatrix matrix = nsSVGUtils::ConvertSVGMatrixToThebes(ctm);
+      gfxRect dirtyBounds = matrix.TransformBounds(
+        gfxRect(aDirtyRect->x, aDirtyRect->y, aDirtyRect->width, aDirtyRect->height));
+      dirtyBounds.RoundOut();
+      if (NS_SUCCEEDED(nsSVGUtils::GfxRectToIntRect(dirtyBounds, &tmpDirtyRect))) {
+        dirtyRect = &tmpDirtyRect;
+      }
     }
 
-    svgChildFrame->PaintSVG(aContext, const_cast<nsIntRect*>(aDirtyRect));
+    svgChildFrame->PaintSVG(aContext, dirtyRect);
   }
 };
 
 void
 nsSVGUtils::PaintChildWithEffects(nsSVGRenderState *aContext,
                                   nsIntRect *aDirtyRect,
                                   nsIFrame *aFrame)
 {
diff -r 4b060ed856e0 layout/tools/reftest/reftest.js
--- a/layout/tools/reftest/reftest.js	Tue Oct 14 17:12:28 2008 -0700
+++ b/layout/tools/reftest/reftest.js	Thu Oct 16 21:24:49 2008 -0500
@@ -328,22 +328,27 @@ function DoneTests()
     dump("REFTEST FINISHED: Slowest test took " + gSlowestTestTime +
          "ms (" + gSlowestTestURL + ")\n");
 
     if (gServer)
         gServer.stop();
     goQuitApplication();
 }
 
-function CanvasToURL(canvas)
-{
-    var ctx = whichCanvas.getContext("2d");
-    return canvas.toDataURL();
+function setupZoom(contentRootElement) {
+    if (!contentRootElement.hasAttribute('reftest-zoom'))
+        return;
+    gBrowser.markupDocumentViewer.fullZoom =
+        contentRootElement.getAttribute('reftest-zoom');
 }
 
+function resetZoom() {
+    gBrowser.markupDocumentViewer.fullZoom = 1.0;
+}
+    
 function OnDocumentLoad(event)
 {
     if (event.target != gBrowser.contentDocument)
         // Ignore load events for subframes.
         return;
 
     var contentRootElement = gBrowser.contentDocument.documentElement;
 
@@ -377,16 +382,18 @@ function OnDocumentLoad(event)
        ps.headerStrLeft = "";
        ps.headerStrCenter = "";
        ps.headerStrRight = "";
        ps.footerStrLeft = "";
        ps.footerStrCenter = "";
        ps.footerStrRight = "";
        gBrowser.docShell.contentViewer.setPageMode(true, ps);
     }
+
+    setupZoom(contentRootElement);
 
     if (shouldWait()) {
         // The testcase will let us know when the test snapshot should be made.
         // Register a mutation listener to know when the 'reftest-wait' class
         // gets removed.
         contentRootElement.addEventListener(
             "DOMAttrModified",
             function(event) {
@@ -436,18 +443,28 @@ function DocumentLoaded()
         canvas = gCanvas1;
     else
         canvas = gCanvas2;
 
     /* XXX This needs to be rgb(255,255,255) because otherwise we get
      * black bars at the bottom of every test that are different size
      * for the first test and the rest (scrollbar-related??) */
     var win = gBrowser.contentWindow;
-    canvas.getContext("2d").drawWindow(win, win.scrollX, win.scrollY,
-                                       canvas.width, canvas.height, "rgb(255,255,255)");
+    var ctx = canvas.getContext("2d");
+    var scale = gBrowser.markupDocumentViewer.fullZoom;
+    ctx.save();
+    // drawWindow always draws one canvas pixel for each CSS pixel in the source
+    // window, so scale the drawing to show the zoom (making each canvas pixel be one
+    // device pixel instead)
+    ctx.scale(scale, scale);
+    ctx.drawWindow(win, win.scrollX, win.scrollY,
+                   canvas.width, canvas.height, "rgb(255,255,255)");
+    ctx.restore();
+
+    resetZoom();
 
     switch (gState) {
         case 1:
             // First document has been loaded.
             // Proceed to load the second document.
 
             StartCurrentURI(2);
             break;
diff -r 4b060ed856e0 media/liboggplay/README_MOZILLA
--- a/media/liboggplay/README_MOZILLA	Tue Oct 14 17:12:28 2008 -0700
+++ b/media/liboggplay/README_MOZILLA	Thu Oct 16 21:24:49 2008 -0500
@@ -1,8 +1,8 @@ The source from this directory was copie
 The source from this directory was copied from the liboggplay svn
 source using the update.sh script. The only changes made were those
 applied by update.sh and the addition/upate of Makefile.in files for
 the Mozilla build system.
 
 http://svn.annodex.net/liboggplay/trunk/
 
-The svn revision number used was r3693. 
+The svn revision number used was r3729.
diff -r 4b060ed856e0 media/liboggplay/src/liboggplay/config.h
--- a/media/liboggplay/src/liboggplay/config.h	Tue Oct 14 17:12:28 2008 -0700
+++ b/media/liboggplay/src/liboggplay/config.h	Thu Oct 16 21:24:49 2008 -0500
@@ -69,17 +69,17 @@
 
 /* Define to the version of this package. */
 #define PACKAGE_VERSION ""
 
 /* Define to 1 if you have the ANSI C header files. */
 #define STDC_HEADERS 1
 
 /* Version number of package */
-#define VERSION "0.0.1.svn"
+#define VERSION "0.0.1"
 
 /* Define to 1 if your processor stores words with the most significant byte
    first (like Motorola and SPARC, unlike Intel and VAX). */
 /* #undef WORDS_BIGENDIAN */
 
 /* use MMX SSE2 compiler intrinsics */
 
 
diff -r 4b060ed856e0 media/liboggplay/src/liboggplay/oggplay_seek.c
--- a/media/liboggplay/src/liboggplay/oggplay_seek.c	Tue Oct 14 17:12:28 2008 -0700
+++ b/media/liboggplay/src/liboggplay/oggplay_seek.c	Thu Oct 16 21:24:49 2008 -0500
@@ -77,17 +77,17 @@ oggplay_seek(OggPlay *me, ogg_int64_t mi
   }
 
   /*
    * first, create a trash object to store the context that we want to
    * delete but can't until the presentation thread is no longer using it -
    * this will occur as soon as the thread calls oggplay_buffer_release_next
    */
 
-  trash = malloc(sizeof(OggPlaySeekTrash));
+  trash = calloc(sizeof(OggPlaySeekTrash), 1);
 
   /*
    * store the old buffer in it next.
    */
   trash->old_buffer = (OggPlayBuffer *)me->buffer;
 
   /*
    * replace the buffer with a new one.  From here on, the presentation thread
diff -r 4b060ed856e0 media/liboggplay_audio/Makefile.in
--- a/media/liboggplay_audio/Makefile.in	Tue Oct 14 17:12:28 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,79 +0,0 @@
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla code.
-#
-# The Initial Developer of the Original Code is the Mozilla Corporation.
-# Portions created by the Initial Developer are Copyright (C) 2007
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#  Chris Double <chris.double@double.co.nz>
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-DEPTH		= ../..
-topsrcdir	= @top_srcdir@
-srcdir		= @srcdir@
-VPATH		= @srcdir@
-
-include $(DEPTH)/config/autoconf.mk
-
-MODULE		= oggplay_audio
-LIBRARY_NAME	= oggplay_audio
-FORCE_STATIC_LIB= 1
-
-EXPORTS		= \
-		sydney_audio.h \
-		$(NULL)
-
-ifeq ($(OS_ARCH),Linux)
-CSRCS		= \
-		sydney_audio_alsa.c \
-		$(NULL)
-endif
-
-ifneq (,$(filter WINNT WINCE,$(OS_ARCH)))
-CSRCS		= \
-		sydney_audio_waveapi.c \
-		$(NULL)
-endif
-
-ifeq ($(OS_ARCH),Darwin)
-CSRCS		= \
-		sydney_audio_mac.c \
-		$(NULL)
-
-OS_LIBS += -framework CoreAudio -framework AudioToolbox -framework AudioUnit -framework Carbon
-endif
-
-ifeq ($(OS_ARCH),WINNT)
-OS_LIBS += winmm.lib
-endif
-
-include $(topsrcdir)/config/rules.mk
-
-LOCAL_INCLUDES = -I$(srcdir)
-
diff -r 4b060ed856e0 media/liboggplay_audio/README_MOZILLA
--- a/media/liboggplay_audio/README_MOZILLA	Tue Oct 14 17:12:28 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,11 +0,0 @@
-The liboggplay_audio code is from the audio portion of the Annodex
-browser_plugin svn repository:
-
-http://svn.annodex.net/browser_plugin/trunk/src/audio/
-
-It was originally part of liboggplay but recently split into the
-separate browser_plugin directory. I only use the audio portion so
-only the audio part of the source is here. Run update.sh giving it the
-path to a checked out version of browser_plugin to update this code.
-
-This code is using svn revision r3605 and apply the patch from bug 449564.
diff -r 4b060ed856e0 media/liboggplay_audio/sydney_audio.h
--- a/media/liboggplay_audio/sydney_audio.h	Tue Oct 14 17:12:28 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,414 +0,0 @@
-#ifndef foosydneyhfoo
-#define foosydneyhfoo
-
-/* Requirements:
-
-- In sync mode, the device will automatically write data so that an initial read causes writes
-of zeros to be issued to that one can do "while (1); {read(); write()}
-
-- All functions are thread-safe and can be called in any thread context. None of the functions is
-async-signal safe.
-  
-- It is assumed that duplex streams have a single clock (synchronised)
-*/
-
-#include <sys/types.h>
-#if !defined (WIN32)
-#include <sys/param.h>
-#include <inttypes.h>
-#else
-#include <stddef.h>
-#endif
-
-/* Detect byte order, based on sys/param.h */
-#undef SA_LITTLE_ENDIAN
-#undef SA_BIG_ENDIAN
-
-#if defined(__BYTE_ORDER)
-#   if __BYTE_ORDER == __LITTLE_ENDIAN
-#       define SA_LITTLE_ENDIAN 1
-#   elif __BYTE_ORDER == __BIG_ENDIAN
-#       define SA_BIG_ENDIAN 1
-#   endif
-#elif defined(WIN32)
-#   define SA_LITTLE_ENDIAN 1
-#elif defined(__APPLE__)
-#   if defined(__BIG_ENDIAN__)
-#       define SA_BIG_ENDIAN 1
-#   else
-#       define SA_LITTLE_ENDIAN 1
-#   endif
-#else
-#    error "Cannot determine byte order!"
-#endif
-
-#if defined(WIN32)
-#if !defined(int32_t)
-typedef __int32 int32_t;
-#endif
-#if !defined(int64_t)
-typedef __int64 int64_t;
-#endif
-#endif
-
-typedef struct sa_stream sa_stream_t;
-
-#if defined(WIN32)
-// (left << 16 | right) (16 bits per channel)
-#define SA_VOLUME_MUTED ((int32_t) (0x00000000))
-#else
-/** Volume that corresponds to muted in/out */
-#define SA_VOLUME_MUTED ((int32_t) (-0x80000000))
-#endif
-
-/** Ways to express seek offsets for pread/pwrite */
-typedef enum {
-    SA_SEEK_RELATIVE,
-    SA_SEEK_ABSOLUTE,
-    SA_SEEK_RELATIVE_END,
-    _SA_SEEK_MAX
-} sa_seek_t;
-
-/** Supported formats */
-typedef enum {
-    SA_PCM_FORMAT_U8,
-    SA_PCM_FORMAT_ULAW,
-    SA_PCM_FORMAT_ALAW,
-    SA_PCM_FORMAT_S16_LE,
-    SA_PCM_FORMAT_S16_BE,
-    SA_PCM_FORMAT_S24_LE,
-    SA_PCM_FORMAT_S24_BE,
-    SA_PCM_FORMAT_S32_LE,
-    SA_PCM_FORMAT_S32_BE,
-    SA_PCM_FORMAT_FLOAT32_LE,
-    SA_PCM_FORMAT_FLOAT32_BE,
-    _SA_PCM_FORMAT_MAX
-} sa_pcm_format_t;
-
-/* Native/reverse endianness definitions for PCM */
-#ifdef SA_LITTLE_ENDIAN
-#define SA_PCM_FORMAT_S16_NE SA_PCM_FORMAT_S16_LE
-#define SA_PCM_FORMAT_S24_NE SA_PCM_FORMAT_S24_LE
-#define SA_PCM_FORMAT_S32_NE SA_PCM_FORMAT_S32_LE
-#define SA_PCM_FORMAT_FLOAT32_NE SA_PCM_FORMAT_FLOAT32_LE
-#define SA_PCM_FORMAT_S16_RE SA_PCM_FORMAT_S16_BE
-#define SA_PCM_FORMAT_S24_RE SA_PCM_FORMAT_S24_BE
-#define SA_PCM_FORMAT_S32_RE SA_PCM_FORMAT_S32_BE
-#define SA_PCM_FORMAT_FLOAT32_RE SA_PCM_FORMAT_FLOAT32_BE
-#else
-#define SA_PCM_FORMAT_S16_NE SA_PCM_FORMAT_S16_BE
-#define SA_PCM_FORMAT_S24_NE SA_PCM_FORMAT_S24_BE
-#define SA_PCM_FORMAT_S32_NE SA_PCM_FORMAT_S32_BE
-#define SA_PCM_FORMAT_FLOAT32_NE SA_PCM_FORMAT_FLOAT32_BE
-#define SA_PCM_FORMAT_S16_RE SA_PCM_FORMAT_S16_LE
-#define SA_PCM_FORMAT_S24_RE SA_PCM_FORMAT_S24_LE
-#define SA_PCM_FORMAT_S32_RE SA_PCM_FORMAT_S32_LE
-#define SA_PCM_FORMAT_FLOAT32_RE SA_PCM_FORMAT_FLOAT32_LE
-#endif
-
-#define SA_CODEC_MPEG "mpeg"
-#define SA_CODEC_AC3 "ac3"
-#define SA_CODEC_GSM "gsm"
-#define SA_CODEC_VORBIS "vorbis"
-#define SA_CODEC_SPEEX "speex"
-
-/** Device opening modes */
-typedef enum {
-    SA_MODE_WRONLY = 1,
-    SA_MODE_RDONLY = 2,
-    SA_MODE_RDWR   = 3,
-    _SA_MODE_MAX   = 4
-} sa_mode_t;
-
-/** Error codes */
-typedef enum {
-    SA_SUCCESS = 0,
-    SA_ERROR_NOT_SUPPORTED = -1,
-    SA_ERROR_INVALID = -2,
-    SA_ERROR_STATE = -3,
-    SA_ERROR_OOM = -4,
-    SA_ERROR_NO_DEVICE = -5,
-    SA_ERROR_NO_DRIVER = -6,
-    SA_ERROR_NO_CODEC = -7,
-    SA_ERROR_NO_PCM_FORMAT = -7,
-    SA_ERROR_SYSTEM = -8,
-    SA_ERROR_NO_INIT = -9,
-    SA_ERROR_NO_META = -10,
-    SA_ERROR_NO_DATA = -11,
-    SA_ERROR_NO_SPACE = -12,
-    _SA_ERROR_MAX = -13
-} sa_error_t;
-
-/** Possible events for notifications */
-typedef enum {
-    SA_NOTIFY_REQUEST_START,
-    SA_NOTIFY_REQUEST_STOP,
-    SA_NOTIFY_CHANGED_READ_VOLUME,
-    SA_NOTIFY_CHANGED_WRITE_VOLUME,
-    SA_NOTIFY_CHANGED_DEVICE,
-    _SA_NOTIFY_MAX
-} sa_notify_t;
-
-/** Classes of events */
-typedef enum {
-    SA_EVENT_REQUEST_IO,
-    SA_EVENT_INIT_THREAD,
-    SA_EVENT_NOTIFY,
-    SA_EVENT_ERROR,
-    _SA_EVENT_MAX
-} sa_event_t;
-
-/** List of sample position queries */
-typedef enum {
-    SA_POSITION_WRITE_DELAY,
-    SA_POSITION_WRITE_HARDWARE,
-    SA_POSITION_WRITE_SOFTWARE,
-    SA_POSITION_READ_DELAY,
-    SA_POSITION_READ_HARDWARE,
-    SA_POSITION_READ_SOFTWARE,
-    SA_POSITION_DUPLEX_DELAY,
-    _SA_POSITION_MAX
-} sa_position_t;
-
-/* Channel positions */
-typedef enum {
-    SA_CHANNEL_MONO,
-    SA_CHANNEL_LEFT,
-    SA_CHANNEL_RIGHT,
-    SA_CHANNEL_CENTER,
-    SA_CHANNEL_FRONT_LEFT,
-    SA_CHANNEL_FRONT_RIGHT,
-    SA_CHANNEL_FRONT_CENTER,
-    SA_CHANNEL_REAR_LEFT,
-    SA_CHANNEL_REAR_RIGHT,
-    SA_CHANNEL_REAR_CENTER,
-    SA_CHANNEL_LFE,
-    SA_CHANNEL_FRONT_LEFT_OF_CENTER,
-    SA_CHANNEL_FRONT_RIGHT_OF_CENTER,
-    SA_CHANNEL_SIDE_LEFT,
-    SA_CHANNEL_SIDE_RIGHT,
-    SA_CHANNEL_TOP_CENTER,
-    SA_CHANNEL_TOP_FRONT_LEFT,
-    SA_CHANNEL_TOP_FRONT_RIGHT,
-    SA_CHANNEL_TOP_FRONT_CENTER,
-    SA_CHANNEL_TOP_REAR_LEFT,
-    SA_CHANNEL_TOP_REAR_RIGHT,
-    SA_CHANNEL_TOP_REAR_CENTER,
-    SA_CHANNEL_AUX0,
-    SA_CHANNEL_AUX1,
-    SA_CHANNEL_AUX2,
-    SA_CHANNEL_AUX3,
-    SA_CHANNEL_AUX4,
-    SA_CHANNEL_AUX5,
-    SA_CHANNEL_AUX6,
-    SA_CHANNEL_AUX7,
-    SA_CHANNEL_AUX8,
-    SA_CHANNEL_AUX9,
-    SA_CHANNEL_AUX10,
-    SA_CHANNEL_AUX11,
-    SA_CHANNEL_AUX12,
-    SA_CHANNEL_AUX13,
-    SA_CHANNEL_AUX14,
-    SA_CHANNEL_AUX15,
-    SA_CHANNEL_AUX16,
-    SA_CHANNEL_AUX17,
-    SA_CHANNEL_AUX18,
-    SA_CHANNEL_AUX19,
-    SA_CHANNEL_AUX20,
-    SA_CHANNEL_AUX21,
-    SA_CHANNEL_AUX22,
-    SA_CHANNEL_AUX23,
-    SA_CHANNEL_AUX24,
-    SA_CHANNEL_AUX25,
-    SA_CHANNEL_AUX26,
-    SA_CHANNEL_AUX27,
-    SA_CHANNEL_AUX28,
-    SA_CHANNEL_AUX29,
-    SA_CHANNEL_AUX30,
-    SA_CHANNEL_AUX31,
-    _SA_CHANNEL_MAX
-} sa_channel_t;
-
-typedef enum {
-    SA_STATE_INIT,
-    SA_STATE_RUNNING,
-    SA_STATE_STOPPED,
-    /* put more stuff */
-    _SA_STATE_MAX
-} sa_state_t;
-
-typedef enum {
-    SA_XRUN_MODE_STOP,
-    SA_XRUN_MODE_SPIN,
-    _SA_XRUN_MODE_MAX
-} sa_xrun_mode_t;
-
-typedef enum {
-    SA_ADJUST_UP = 1,
-    SA_ADJUST_DOWN = -1,
-    SA_ADJUST_NONE = 0
-} sa_adjust_t;
-
-/* Some kind of meta information.  */
-#define SA_META_CLIENT_NAME "sydney.client-name"     /* utf-8 */ 
-#define SA_META_PROCESS_ID "sydney.process-id"       /* getpid() */
-#define SA_META_LANGUAGE "sydney.language"           /* de_DE and similar */
-
-/* Some kind of meta information. Not filled in */
-#define SA_META_STREAM_NAME "sydney.stream-name"     /* utf-8 */ 
-#define SA_META_ICON_NAME "sydney.icon-name"         /* file name (no slashes) */
-#define SA_META_ICON_PNG "sydney.icon-png"           /* PNG blob */
-#define SA_META_ROLE "sydney.role"                   /* one of: "music", "phone", "game", "event" */
-#define SA_META_X11_DISPLAY "sydney.x11-display"     /* X11 display */
-#define SA_META_X11_WINDOW "sydney.x11-window"       /* X11 window id */
-
-/** Main callback function */
-typedef int (*sa_event_callback_t)(sa_stream_t *s, sa_event_t event);
-
-/** Create an opaque (e.g. AC3) codec stream */
-int sa_stream_create_opaque(sa_stream_t **s, const char *client_name, sa_mode_t mode, const char *codec);
-
-/** Normal way to open a PCM device */
-int sa_stream_create_pcm(sa_stream_t **s, const char *client_name, sa_mode_t mode, sa_pcm_format_t format, unsigned int rate, unsigned int nchannels);
-
-/** Initialise the device */
-int sa_stream_open(sa_stream_t *s);
-
-/** Close/destroy everything */
-int sa_stream_destroy(sa_stream_t *s);
-
-/* "Soft" params */
-int sa_stream_set_write_lower_watermark(sa_stream_t *s, size_t size);
-int sa_stream_set_read_lower_watermark(sa_stream_t *s, size_t size);
-int sa_stream_set_write_upper_watermark(sa_stream_t *s, size_t size);
-int sa_stream_set_read_upper_watermark(sa_stream_t *s, size_t size);
-
-/** Set the mapping between channels and the loudspeakers */
-int sa_stream_set_channel_map(sa_stream_t *s, const sa_channel_t map[], unsigned int n);
-
-/** Whether xruns cause the card to reset */
-int sa_stream_set_xrun_mode(sa_stream_t *s, sa_xrun_mode_t mode);
-
-/** Set the device to non-interleaved mode */
-int sa_stream_set_non_interleaved(sa_stream_t *s, int enable);
-
-/** Require dynamic sample rate */
-int sa_stream_set_dynamic_rate(sa_stream_t *s, int enable);
-
-/** Select driver */
-int sa_stream_set_driver(sa_stream_t *s, const char *driver);
-
-/** Start callback */
-int sa_stream_start_thread(sa_stream_t *s, sa_event_callback_t callback);
-
-/** Start callback */
-int sa_stream_stop_thread(sa_stream_t *s);
-
-/** Change the device connected to the stream */
-int sa_stream_change_device(sa_stream_t *s, const char *device_name);
-
-/** volume in hundreths of dB*/
-int sa_stream_change_read_volume(sa_stream_t *s, const int32_t vol[], unsigned int n);
-
-/** volume in hundreths of dB*/
-int sa_stream_change_write_volume(sa_stream_t *s, const int32_t vol[], unsigned int n);
-
-/** Change the sampling rate */
-int sa_stream_change_rate(sa_stream_t *s, unsigned int rate);
-
-/** Change some meta data that is attached to the stream */
-int sa_stream_change_meta_data(sa_stream_t *s, const char *name, const void *data, size_t size);
-
-/** Associate opaque user data */
-int sa_stream_change_user_data(sa_stream_t *s, const void *value);
-
-/* Hardware-related. This is implementation-specific and hardware specific. */
-int sa_stream_set_adjust_rate(sa_stream_t *s, sa_adjust_t direction);
-int sa_stream_set_adjust_nchannels(sa_stream_t *s, sa_adjust_t direction);
-int sa_stream_set_adjust_pcm_format(sa_stream_t *s, sa_adjust_t direction);
-int sa_stream_set_adjust_watermarks(sa_stream_t *s, sa_adjust_t direction);
-
-/* Query functions */
-
-int sa_stream_get_mode(sa_stream_t *s, sa_mode_t *access_mode);
-int sa_stream_get_codec(sa_stream_t *s, char *codec, size_t *size);
-int sa_stream_get_pcm_format(sa_stream_t *s, sa_pcm_format_t *format);
-int sa_stream_get_rate(sa_stream_t *s, unsigned int *rate);
-int sa_stream_get_nchannels(sa_stream_t *s, int *nchannels);
-int sa_stream_get_user_data(sa_stream_t *s, void **value);
-int sa_stream_get_write_lower_watermark(sa_stream_t *s, size_t *size);
-int sa_stream_get_read_lower_watermark(sa_stream_t *s, size_t *size);
-int sa_stream_get_write_upper_watermark(sa_stream_t *s, size_t *size);
-int sa_stream_get_read_upper_watermark(sa_stream_t *s, size_t *size);
-int sa_stream_get_channel_map(sa_stream_t *s, sa_channel_t map[], unsigned int *n);
-int sa_stream_get_xrun_mode(sa_stream_t *s, sa_xrun_mode_t *mode);
-int sa_stream_get_non_interleaved(sa_stream_t *s, int *enabled);
-int sa_stream_get_dynamic_rate(sa_stream_t *s, int *enabled);
-int sa_stream_get_driver(sa_stream_t *s, char *driver_name, size_t *size);
-int sa_stream_get_device(sa_stream_t *s, char *device_name, size_t *size);
-int sa_stream_get_read_volume(sa_stream_t *s, int32_t vol[], unsigned int *n);
-int sa_stream_get_write_volume(sa_stream_t *s, int32_t vol[], unsigned int *n);
-int sa_stream_get_meta_data(sa_stream_t *s, const char *name, void*data, size_t *size);
-int sa_stream_get_adjust_rate(sa_stream_t *s, sa_adjust_t *direction);
-int sa_stream_get_adjust_nchannels(sa_stream_t *s, sa_adjust_t *direction);
-int sa_stream_get_adjust_pcm_format(sa_stream_t *s, sa_adjust_t *direction);
-int sa_stream_get_adjust_watermarks(sa_stream_t *s, sa_adjust_t *direction);
-
-/** Get current state of the audio device */
-int sa_stream_get_state(sa_stream_t *s, sa_state_t *state);
-
-/** Obtain the error code */
-int sa_stream_get_event_error(sa_stream_t *s, sa_error_t *error);
-
-/** Obtain the notification code */
-int sa_stream_get_event_notify(sa_stream_t *s, sa_notify_t *notify);
-
-/** sync/timing */
-int sa_stream_get_position(sa_stream_t *s, sa_position_t position, int64_t *pos);
-
-
-/* Blocking IO calls */
-
-/** Interleaved capture function */
-int sa_stream_read(sa_stream_t *s, void *data, size_t nbytes);
-/** Non-interleaved capture function */
-int sa_stream_read_ni(sa_stream_t *s, unsigned int channel, void *data, size_t nbytes);
-
-/** Interleaved playback function */
-int sa_stream_write(sa_stream_t *s, const void *data, size_t nbytes);
-/** Non-interleaved playback function */
-int sa_stream_write_ni(sa_stream_t *s, unsigned int channel, const void *data, size_t nbytes);
-/** Interleaved playback function with seek offset */
-int sa_stream_pwrite(sa_stream_t *s, const void *data, size_t nbytes, int64_t offset, sa_seek_t whence);
-/** Non-interleaved playback function with seek offset */
-int sa_stream_pwrite_ni(sa_stream_t *s, unsigned int channel, const void *data, size_t nbytes, int64_t offset, sa_seek_t whence);
-
-
-/** Query how much can be read without blocking */
-int sa_stream_get_read_size(sa_stream_t *s, size_t *size);
-/** Query how much can be written without blocking */
-int sa_stream_get_write_size(sa_stream_t *s, size_t *size);
-
-
-/* Control/xrun */
-
-/** Resume playing after a pause */
-int sa_stream_resume(sa_stream_t *s);
-
-/** Pause audio playback (do not empty the buffer) */
-int sa_stream_pause(sa_stream_t *s);
-
-/** Block until all audio has been played */
-int sa_stream_drain(sa_stream_t *s);
-
-/** Return a human readable error */
-const char *sa_strerror(int code);
-
-/* Extensions */
-int
-sa_stream_set_volume_abs(sa_stream_t *s, float vol);
-
-int
-sa_stream_get_volume_abs(sa_stream_t *s, float *vol);
-
-#endif
diff -r 4b060ed856e0 media/liboggplay_audio/sydney_audio_alsa.c
--- a/media/liboggplay_audio/sydney_audio_alsa.c	Tue Oct 14 17:12:28 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,709 +0,0 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Initial Developer of the Original Code is
- * CSIRO
- * Portions created by the Initial Developer are Copyright (C) 2007
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s): Michael Martin
- *                 Chris Double (chris.double@double.co.nz)
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** *
- */
-#include <stdlib.h>
-#include <pthread.h>
-#include <alsa/asoundlib.h>
-#include "sydney_audio.h"
-
-/* ALSA implementation based heavily on sydney_audio_mac.c */
-
-/*
- * The audio interface is based on a "pull" I/O model, which means you
- * can't just provide a data buffer and tell the audio device to play; you must
- * register a callback and provide data as the device asks for it. To support
- * sydney audio's "write-to-play" style interface, we have to buffer up the
- * data as it arrives and feed it to the callback as required.
- *
- * This is handled by a simple linked list of buffers; data is always written
- * to the tail and read from the head. Each buffer tracks the start and end
- * positions of its contained data. Buffers are allocated when the tail buffer
- * fills, and freed when the head buffer empties. There is always at least one
- * buffer allocated.
- *
- *       s   e      s      e      s  e            + data read
- *    +++#####  ->  ########  ->  ####----        # data written
- *    ^                           ^               - empty
- *    bl_head                     bl_tail
- */
-
-typedef struct sa_buf sa_buf;
-struct sa_buf {
-  unsigned int      size;
-  unsigned int      start;
-  unsigned int      end;
-  sa_buf          * next;
-  unsigned char     data[0];
-};
-
-struct sa_stream {
-  snd_pcm_t*        output_unit;
-  pthread_t         thread_id;
-  pthread_mutex_t   mutex;
-  char              playing;
-  int64_t           bytes_played;
-
-  /* audio format info */
-  unsigned int      rate;
-  unsigned int      n_channels;
-  unsigned int      bytes_per_ch;
-
-  /* buffer list */
-  sa_buf          * bl_head;
-  sa_buf          * bl_tail;
-  int               n_bufs;
-};
-
-
-/*
- * Use a default buffer size with enough room for one second of audio,
- * assuming stereo data at 44.1kHz with 32 bits per channel, and impose
- * a generous limit on the number of buffers.
- */
-#define BUF_SIZE    (2 * 44100 * 4)
-#define BUF_LIMIT   5
-
-#if BUF_LIMIT < 2
-#error BUF_LIMIT must be at least 2!
-#endif
-
-static void audio_callback(void* s);
-static sa_buf *new_buffer(void);
-
-
-/*
- * -----------------------------------------------------------------------------
- * Startup and shutdown functions
- * -----------------------------------------------------------------------------
- */
-
-int
-sa_stream_create_pcm(
-  sa_stream_t      ** _s,
-  const char        * client_name,
-  sa_mode_t           mode,
-  sa_pcm_format_t     format,
-  unsigned  int       rate,
-  unsigned  int       n_channels
-) {
-  sa_stream_t   * s = 0;
-
-  /*
-   * Make sure we return a NULL stream pointer on failure.
-   */
-  if (_s == NULL) {
-    return SA_ERROR_INVALID;
-  }
-  *_s = NULL;
-
-  if (mode != SA_MODE_WRONLY) {
-    return SA_ERROR_NOT_SUPPORTED;
-  }
-  if (format != SA_PCM_FORMAT_S16_LE) {
-    return SA_ERROR_NOT_SUPPORTED;
-  }
-
-  /*
-   * Allocate the instance and required resources.
-   */
-  if ((s = malloc(sizeof(sa_stream_t))) == NULL) {
-    return SA_ERROR_OOM;
-  }
-  if ((s->bl_head = new_buffer()) == NULL) {
-    free(s);
-    return SA_ERROR_OOM;
-  }
-  if (pthread_mutex_init(&s->mutex, NULL) != 0) {
-    free(s->bl_head);
-    free(s);
-    return SA_ERROR_SYSTEM;
-  }
-
-  s->output_unit  = NULL;
-  s->thread_id    = 0;
-  s->playing      = 0;
-  s->bytes_played = 0;
-  s->rate         = rate;
-  s->n_channels   = n_channels;
-  s->bytes_per_ch = 2;
-  s->bl_tail      = s->bl_head;
-  s->n_bufs       = 1;
-
-  *_s = s;
-  return SA_SUCCESS;
-}
-
-
-int
-sa_stream_open(sa_stream_t *s) {
-
-  if (s == NULL) {
-    return SA_ERROR_NO_INIT;
-  }
-  if (s->output_unit != NULL) {
-    return SA_ERROR_INVALID;
-  }
-
-  if (snd_pcm_open(&s->output_unit, 
-		   "default", 
-		   SND_PCM_STREAM_PLAYBACK, 
-		   0) < 0) {
-    return SA_ERROR_NO_DEVICE;
-  }
-  
-  if (snd_pcm_set_params(s->output_unit,
-			 SND_PCM_FORMAT_S16_LE,
-			 SND_PCM_ACCESS_RW_INTERLEAVED,
-			 s->n_channels,
-			 s->rate,
-			 1,
-			 0) < 0) {
-    snd_pcm_close(s->output_unit);
-    s->output_unit = NULL;
-    return SA_ERROR_NOT_SUPPORTED;
-  }
-
-  return SA_SUCCESS;
-}
-
-
-int
-sa_stream_destroy(sa_stream_t *s) {
-  int result = SA_SUCCESS;
-
-  if (s == NULL) {
-    return SA_SUCCESS;
-  }
-
-  pthread_mutex_lock(&s->mutex);
-
-  /*
-   * This causes the thread sending data to ALSA to stop
-   */
-  s->thread_id = 0;
-
-  /*
-   * Shut down the audio output device.
-   */
-  if (s->output_unit != NULL) {
-    if (s->playing && snd_pcm_close(s->output_unit) < 0) {
-      result = SA_ERROR_SYSTEM;
-    }
-  }
-
-  pthread_mutex_unlock(&s->mutex);
-
-  /*
-   * Release resources.
-   */
-  if (pthread_mutex_destroy(&s->mutex) != 0) {
-    result = SA_ERROR_SYSTEM;
-  }
-  while (s->bl_head != NULL) {
-    sa_buf  * next = s->bl_head->next;
-    free(s->bl_head);
-    s->bl_head = next;
-  }
-  free(s);
-
-  return result;
-}
-
-
-
-/*
- * -----------------------------------------------------------------------------
- * Data read and write functions
- * -----------------------------------------------------------------------------
- */
-
-int
-sa_stream_write(sa_stream_t *s, const void *data, size_t nbytes) {
-  int result = SA_SUCCESS;
-
-  if (s == NULL || s->output_unit == NULL) {
-    return SA_ERROR_NO_INIT;
-  }
-  if (nbytes == 0) {
-    return SA_SUCCESS;
-  }
-
-  pthread_mutex_lock(&s->mutex);
-
-  /*
-   * Append the new data to the end of our buffer list.
-   */
-  while (1) {
-    unsigned int avail = s->bl_tail->size - s->bl_tail->end;
-
-    if (nbytes <= avail) {
-
-      /*
-       * The new data will fit into the current tail buffer, so
-       * just copy it in and we're done.
-       */
-      memcpy(s->bl_tail->data + s->bl_tail->end, data, nbytes);
-      s->bl_tail->end += nbytes;
-      break;
-
-    } else {
-
-      /*
-       * Copy what we can into the tail and allocate a new buffer
-       * for the rest.
-       */
-      memcpy(s->bl_tail->data + s->bl_tail->end, data, avail);
-      s->bl_tail->end += avail;
-      data = ((unsigned char *)data) + avail;
-      nbytes -= avail;
-
-      /* 
-       * If we still have data left to copy but we've hit the limit of
-       * allowable buffer allocations, we need to spin for a bit to allow
-       * the audio callback function to slurp some more data up.
-       */
-      if (nbytes > 0 && s->n_bufs == BUF_LIMIT) {
-#ifdef TIMING_TRACE
-        printf("#");  /* too much audio data */
-#endif
-        if (!s->playing) {
-          /*
-           * We haven't even started playing yet! That means the
-           * BUF_SIZE/BUF_LIMIT values are too low... Not much we can
-           * do here; spinning won't help because the audio callback
-           * hasn't been enabled yet. Oh well, error time.
-           */
-          printf("Too much audio data received before audio device enabled!\n");
-          result = SA_ERROR_SYSTEM;
-          break;
-        }
-        while (s->n_bufs == BUF_LIMIT) {
-          struct timespec ts = {0, 1000000};
-          pthread_mutex_unlock(&s->mutex);
-          nanosleep(&ts, NULL);
-          pthread_mutex_lock(&s->mutex);
-        }
-      }
-
-      /* 
-       * Allocate a new tail buffer, and go 'round again to fill it up.
-       */
-      if ((s->bl_tail->next = new_buffer()) == NULL) {
-        result = SA_ERROR_OOM;
-        break;
-      }
-      s->n_bufs++;
-      s->bl_tail = s->bl_tail->next;
-    
-    } /* if (nbytes <= avail), else */
-
-  } /* while (1) */
-
-  pthread_mutex_unlock(&s->mutex);
-
-  /*
-   * Once we have our first block of audio data, enable the audio callback
-   * function. This doesn't need to be protected by the mutex, because
-   * s->playing is not used in the audio callback thread, and it's probably
-   * better not to be inside the lock when we enable the audio callback.
-   */
-  if (!s->playing) {
-    s->playing = 1;
-    if (pthread_create(&s->thread_id, NULL, (void *)audio_callback, s) != 0) {
-      result = SA_ERROR_SYSTEM;
-    }
-  }
-
-  return result;
-}
-
-
-static void audio_callback(void* data)
-{
-  sa_stream_t* s = (sa_stream_t*)data;
-  snd_pcm_uframes_t buffer_size;
-  snd_pcm_uframes_t period_size;
-  unsigned int bytes_per_frame = s->n_channels * s->bytes_per_ch;
-  char* buffer = 0;
-
-#ifdef TIMING_TRACE
-  printf(".");  /* audio read 'tick' */
-#endif
-
-  snd_pcm_get_params(s->output_unit, &buffer_size, &period_size);
- 
-  buffer = malloc(period_size * bytes_per_frame);
- 
-  while(1) {
-   char* dst = buffer;
-   unsigned int bytes_to_copy   = period_size * bytes_per_frame;
-   snd_pcm_sframes_t frames;
-
-   pthread_mutex_lock(&s->mutex);
-   if (!s->thread_id)
-     break;
-
-    /*
-     * Consume data from the start of the buffer list.
-     */
-    while (1) {
-      unsigned int avail = s->bl_head->end - s->bl_head->start;
-      assert(s->bl_head->start <= s->bl_head->end);
-
-      if (avail >= bytes_to_copy) {
-	/*
-	 * We have all we need in the head buffer, so just grab it and go.
-	 */
-	memcpy(dst, s->bl_head->data + s->bl_head->start, bytes_to_copy);
-	s->bl_head->start += bytes_to_copy;
-	s->bytes_played += bytes_to_copy;
-	break;
-	
-      } else {
-	sa_buf* next = 0;
-	/*
-	 * Copy what we can from the head and move on to the next buffer.
-	 */
-	memcpy(dst, s->bl_head->data + s->bl_head->start, avail);
-	s->bl_head->start += avail;
-	dst += avail;
-	bytes_to_copy -= avail;
-	s->bytes_played += avail;
-
-	/*
-	 * We want to free the now-empty buffer, but not if it's also the
-	 * current tail. If it is the tail, we don't have enough data to fill
-	 * the destination buffer, so we'll just zero it out and give up.
-	 */
-	next = s->bl_head->next;
-	if (next == NULL) {
-#ifdef TIMING_TRACE
-	  printf("!");  /* not enough audio data */
-#endif
-	  memset(dst, 0, bytes_to_copy);
-	  break;
-	}
-	free(s->bl_head);
-	s->bl_head = next;
-	s->n_bufs--;
-	
-      } /* if (avail >= bytes_to_copy), else */
-      
-    } /* while (1) */
-    
-    pthread_mutex_unlock(&s->mutex);
-    
-    frames = snd_pcm_writei(s->output_unit, buffer, period_size);
-    if (frames < 0) {
-      frames = snd_pcm_recover(s->output_unit, frames, 1);
-      if (frames < 0) {
-	printf("snc_pcm_recover error: %s\n", snd_strerror(frames));
-      }
-      if(frames > 0 && frames < period_size)
-	printf("short write (expected %d, wrote %d)\n", (int)period_size, (int)frames);;
-    }
-  }
-  free(buffer);
-}
-
-
-
-/*
- * -----------------------------------------------------------------------------
- * General query and support functions
- * -----------------------------------------------------------------------------
- */
-
-int
-sa_stream_get_write_size(sa_stream_t *s, size_t *size) {
-  sa_buf  * b;
-  size_t    used = 0;
-
-  if (s == NULL || s->output_unit == NULL) {
-    return SA_ERROR_NO_INIT;
-  }
-
-  pthread_mutex_lock(&s->mutex);
-
-  /*
-   * Sum up the used portions of our buffers and subtract that from
-   * the pre-defined max allowed allocation.
-   */
-  for (b = s->bl_head; b != NULL; b = b->next) {
-    used += b->end - b->start;
-  }
-  *size = BUF_SIZE * BUF_LIMIT - used;
-
-  pthread_mutex_unlock(&s->mutex);
-  return SA_SUCCESS;
-}
-
-
-int
-sa_stream_get_position(sa_stream_t *s, sa_position_t position, int64_t *pos) {
-
-  if (s == NULL || s->output_unit == NULL) {
-    return SA_ERROR_NO_INIT;
-  }
-  if (position != SA_POSITION_WRITE_SOFTWARE) {
-    return SA_ERROR_NOT_SUPPORTED;
-  }
-
-  pthread_mutex_lock(&s->mutex);
-  *pos = s->bytes_played;
-  pthread_mutex_unlock(&s->mutex);
-  return SA_SUCCESS;
-}
-
-
-int
-sa_stream_pause(sa_stream_t *s) {
-
-  if (s == NULL || s->output_unit == NULL) {
-    return SA_ERROR_NO_INIT;
-  }
-
-  pthread_mutex_lock(&s->mutex);
-#if 0 /* TODO */
-  AudioOutputUnitStop(s->output_unit);
-#endif
-  pthread_mutex_unlock(&s->mutex);
-  return SA_SUCCESS;
-}
-
-
-int
-sa_stream_resume(sa_stream_t *s) {
-
-  if (s == NULL || s->output_unit == NULL) {
-    return SA_ERROR_NO_INIT;
-  }
-
-  pthread_mutex_lock(&s->mutex);
-
-  /*
-   * The audio device resets its mSampleTime counter after pausing,
-   * so we need to clear our tracking value to keep that in sync.
-   */
-  s->bytes_played = 0;
-#if 0 /* TODO */
-  AudioOutputUnitStart(s->output_unit);
-#endif
-  pthread_mutex_unlock(&s->mutex);
-  return SA_SUCCESS;
-}
-
-
-static sa_buf *
-new_buffer(void) {
-  sa_buf  * b = malloc(sizeof(sa_buf) + BUF_SIZE);
-  if (b != NULL) {
-    b->size  = BUF_SIZE;
-    b->start = 0;
-    b->end   = 0;
-    b->next  = NULL;
-  }
-  return b;
-}
-
-
-
-/*
- * -----------------------------------------------------------------------------
- * Extension functions
- * -----------------------------------------------------------------------------
- */
-
-int
-sa_stream_set_volume_abs(sa_stream_t *s, float vol) {
-  snd_mixer_t* mixer = 0;
-  snd_mixer_elem_t* elem = 0;
-  if (s == NULL || s->output_unit == NULL) {
-    return SA_ERROR_NO_INIT;
-  }
-
-  if (snd_mixer_open(&mixer, 0) < 0) {
-    return SA_ERROR_SYSTEM;
-  }
-
-  if (snd_mixer_attach(mixer, "default") < 0) {
-    snd_mixer_close(mixer);
-    return SA_ERROR_SYSTEM;
-  }
-
-  if (snd_mixer_selem_register(mixer, NULL, NULL) < 0) {
-    snd_mixer_close(mixer);
-    return SA_ERROR_SYSTEM;
-  }
-
-  if (snd_mixer_load(mixer) < 0) {
-    snd_mixer_close(mixer);
-    return SA_ERROR_SYSTEM;
-  }
-
-#if 0
-  snd_mixer_elem_t* elem = 0;
-  for (elem = snd_mixer_first_elem(mixer); elem != NULL; elem = snd_mixer_elem_next(elem)) {
-    if (snd_mixer_selem_has_playback_volume(elem)) {
-      printf("Playback %s\n", snd_mixer_selem_get_name(elem));
-    }
-    else {
-      printf("No Playback: %s\n", snd_mixer_selem_get_name(elem));
-    }
-  }
-#endif
-  elem = snd_mixer_first_elem(mixer);
-  if (elem && snd_mixer_selem_has_playback_volume(elem)) {
-    long min = 0;
-    long max = 0;
-    if (snd_mixer_selem_get_playback_volume_range(elem, &min, &max) >= 0) {
-      snd_mixer_selem_set_playback_volume_all(elem, (max-min)*vol + min);
-    } 
-  }
-  snd_mixer_close(mixer);
-
-  return SA_SUCCESS;
-}
-
-
-int
-sa_stream_get_volume_abs(sa_stream_t *s, float *vol) {
-  snd_mixer_t* mixer = 0;
-  snd_mixer_elem_t* elem = 0;
-  long value = 0;
-
-  if (s == NULL || s->output_unit == NULL) {
-    return SA_ERROR_NO_INIT;
-  }
-
-  if (snd_mixer_open(&mixer, 0) < 0) {
-    return SA_ERROR_SYSTEM;
-  }
-
-  if (snd_mixer_attach(mixer, "default") < 0) {
-    snd_mixer_close(mixer);
-    return SA_ERROR_SYSTEM;
-  }
-
-  if (snd_mixer_selem_register(mixer, NULL, NULL) < 0) {
-    snd_mixer_close(mixer);
-    return SA_ERROR_SYSTEM;
-  }
-
-  if (snd_mixer_load(mixer) < 0) {
-    snd_mixer_close(mixer);
-    return SA_ERROR_SYSTEM;
-  }
-
-  elem = snd_mixer_first_elem(mixer);
-  if (elem && snd_mixer_selem_get_playback_volume(elem, 0, &value) >= 0) {
-    long min = 0;
-    long max = 0;
-    if (snd_mixer_selem_get_playback_volume_range(elem, &min, &max) >= 0) {
-      *vol = (float)(value-min)/(float)(max-min);
-    } 
-  }
-  snd_mixer_close(mixer);
-
-  return SA_SUCCESS;
-}
-
-
-
-/*
- * -----------------------------------------------------------------------------
- * Unsupported functions
- * -----------------------------------------------------------------------------
- */
-#define UNSUPPORTED(func)   func { return SA_ERROR_NOT_SUPPORTED; }
-
-UNSUPPORTED(int sa_stream_create_opaque(sa_stream_t **s, const char *client_name, sa_mode_t mode, const char *codec))
-UNSUPPORTED(int sa_stream_set_write_lower_watermark(sa_stream_t *s, size_t size))
-UNSUPPORTED(int sa_stream_set_read_lower_watermark(sa_stream_t *s, size_t size))
-UNSUPPORTED(int sa_stream_set_write_upper_watermark(sa_stream_t *s, size_t size))
-UNSUPPORTED(int sa_stream_set_read_upper_watermark(sa_stream_t *s, size_t size))
-UNSUPPORTED(int sa_stream_set_channel_map(sa_stream_t *s, const sa_channel_t map[], unsigned int n))
-UNSUPPORTED(int sa_stream_set_xrun_mode(sa_stream_t *s, sa_xrun_mode_t mode))
-UNSUPPORTED(int sa_stream_set_non_interleaved(sa_stream_t *s, int enable))
-UNSUPPORTED(int sa_stream_set_dynamic_rate(sa_stream_t *s, int enable))
-UNSUPPORTED(int sa_stream_set_driver(sa_stream_t *s, const char *driver))
-UNSUPPORTED(int sa_stream_start_thread(sa_stream_t *s, sa_event_callback_t callback))
-UNSUPPORTED(int sa_stream_stop_thread(sa_stream_t *s))
-UNSUPPORTED(int sa_stream_change_device(sa_stream_t *s, const char *device_name))
-UNSUPPORTED(int sa_stream_change_read_volume(sa_stream_t *s, const int32_t vol[], unsigned int n))
-UNSUPPORTED(int sa_stream_change_write_volume(sa_stream_t *s, const int32_t vol[], unsigned int n))
-UNSUPPORTED(int sa_stream_change_rate(sa_stream_t *s, unsigned int rate))
-UNSUPPORTED(int sa_stream_change_meta_data(sa_stream_t *s, const char *name, const void *data, size_t size))
-UNSUPPORTED(int sa_stream_change_user_data(sa_stream_t *s, const void *value))
-UNSUPPORTED(int sa_stream_set_adjust_rate(sa_stream_t *s, sa_adjust_t direction))
-UNSUPPORTED(int sa_stream_set_adjust_nchannels(sa_stream_t *s, sa_adjust_t direction))
-UNSUPPORTED(int sa_stream_set_adjust_pcm_format(sa_stream_t *s, sa_adjust_t direction))
-UNSUPPORTED(int sa_stream_set_adjust_watermarks(sa_stream_t *s, sa_adjust_t direction))
-UNSUPPORTED(int sa_stream_get_mode(sa_stream_t *s, sa_mode_t *access_mode))
-UNSUPPORTED(int sa_stream_get_codec(sa_stream_t *s, char *codec, size_t *size))
-UNSUPPORTED(int sa_stream_get_pcm_format(sa_stream_t *s, sa_pcm_format_t *format))
-UNSUPPORTED(int sa_stream_get_rate(sa_stream_t *s, unsigned int *rate))
-UNSUPPORTED(int sa_stream_get_nchannels(sa_stream_t *s, int *nchannels))
-UNSUPPORTED(int sa_stream_get_user_data(sa_stream_t *s, void **value))
-UNSUPPORTED(int sa_stream_get_write_lower_watermark(sa_stream_t *s, size_t *size))
-UNSUPPORTED(int sa_stream_get_read_lower_watermark(sa_stream_t *s, size_t *size))
-UNSUPPORTED(int sa_stream_get_write_upper_watermark(sa_stream_t *s, size_t *size))
-UNSUPPORTED(int sa_stream_get_read_upper_watermark(sa_stream_t *s, size_t *size))
-UNSUPPORTED(int sa_stream_get_channel_map(sa_stream_t *s, sa_channel_t map[], unsigned int *n))
-UNSUPPORTED(int sa_stream_get_xrun_mode(sa_stream_t *s, sa_xrun_mode_t *mode))
-UNSUPPORTED(int sa_stream_get_non_interleaved(sa_stream_t *s, int *enabled))
-UNSUPPORTED(int sa_stream_get_dynamic_rate(sa_stream_t *s, int *enabled))
-UNSUPPORTED(int sa_stream_get_driver(sa_stream_t *s, char *driver_name, size_t *size))
-UNSUPPORTED(int sa_stream_get_device(sa_stream_t *s, char *device_name, size_t *size))
-UNSUPPORTED(int sa_stream_get_read_volume(sa_stream_t *s, int32_t vol[], unsigned int *n))
-UNSUPPORTED(int sa_stream_get_write_volume(sa_stream_t *s, int32_t vol[], unsigned int *n))
-UNSUPPORTED(int sa_stream_get_meta_data(sa_stream_t *s, const char *name, void*data, size_t *size))
-UNSUPPORTED(int sa_stream_get_adjust_rate(sa_stream_t *s, sa_adjust_t *direction))
-UNSUPPORTED(int sa_stream_get_adjust_nchannels(sa_stream_t *s, sa_adjust_t *direction))
-UNSUPPORTED(int sa_stream_get_adjust_pcm_format(sa_stream_t *s, sa_adjust_t *direction))
-UNSUPPORTED(int sa_stream_get_adjust_watermarks(sa_stream_t *s, sa_adjust_t *direction))
-UNSUPPORTED(int sa_stream_get_state(sa_stream_t *s, sa_state_t *state))
-UNSUPPORTED(int sa_stream_get_event_error(sa_stream_t *s, sa_error_t *error))
-UNSUPPORTED(int sa_stream_get_event_notify(sa_stream_t *s, sa_notify_t *notify))
-UNSUPPORTED(int sa_stream_read(sa_stream_t *s, void *data, size_t nbytes))
-UNSUPPORTED(int sa_stream_read_ni(sa_stream_t *s, unsigned int channel, void *data, size_t nbytes))
-UNSUPPORTED(int sa_stream_write_ni(sa_stream_t *s, unsigned int channel, const void *data, size_t nbytes))
-UNSUPPORTED(int sa_stream_pwrite(sa_stream_t *s, const void *data, size_t nbytes, int64_t offset, sa_seek_t whence))
-UNSUPPORTED(int sa_stream_pwrite_ni(sa_stream_t *s, unsigned int channel, const void *data, size_t nbytes, int64_t offset, sa_seek_t whence))
-UNSUPPORTED(int sa_stream_get_read_size(sa_stream_t *s, size_t *size))
-UNSUPPORTED(int sa_stream_drain(sa_stream_t *s))
-
-const char *sa_strerror(int code) { return NULL; }
-
diff -r 4b060ed856e0 media/liboggplay_audio/sydney_audio_mac.c
--- a/media/liboggplay_audio/sydney_audio_mac.c	Tue Oct 14 17:12:28 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,696 +0,0 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Initial Developer of the Original Code is
- * CSIRO
- * Portions created by the Initial Developer are Copyright (C) 2007
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s): Michael Martin
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** *
- */
-
-#include <AudioUnit/AudioUnit.h>
-#include "sydney_audio.h"
-
-/*
- * The Mac's audio interface is based on a "pull" I/O model, which means you
- * can't just provide a data buffer and tell the audio device to play; you must
- * register a callback and provide data as the device asks for it. To support
- * sydney audio's "write-to-play" style interface, we have to buffer up the
- * data as it arrives and feed it to the callback as required.
- *
- * This is handled by a simple linked list of buffers; data is always written
- * to the tail and read from the head. Each buffer tracks the start and end
- * positions of its contained data. Buffers are allocated when the tail buffer
- * fills, and freed when the head buffer empties. There is always at least one
- * buffer allocated.
- *
- *       s   e      s      e      s  e            + data read
- *    +++#####  ->  ########  ->  ####----        # data written
- *    ^                           ^               - empty
- *    bl_head                     bl_tail
- */
-
-typedef struct sa_buf sa_buf;
-struct sa_buf {
-  unsigned int      size;
-  unsigned int      start;
-  unsigned int      end;
-  sa_buf          * next;
-  unsigned char     data[0];
-};
-
-struct sa_stream {
-  AudioUnit         output_unit;
-  pthread_mutex_t   mutex;
-  bool              playing;
-  int64_t           bytes_played;
-
-  /* audio format info */
-  unsigned int      rate;
-  unsigned int      n_channels;
-  unsigned int      bytes_per_ch;
-
-  /* buffer list */
-  sa_buf          * bl_head;
-  sa_buf          * bl_tail;
-  int               n_bufs;
-};
-
-
-/*
- * Use a default buffer size with enough room for one second of audio,
- * assuming stereo data at 44.1kHz with 32 bits per channel, and impose
- * a generous limit on the number of buffers.
- */
-#define BUF_SIZE    (2 * 44100 * 4)
-#define BUF_LIMIT   5
-
-#if BUF_LIMIT < 2
-#error BUF_LIMIT must be at least 2!
-#endif
-
-
-static OSStatus audio_callback(void *arg, AudioUnitRenderActionFlags *action_flags,
-  const AudioTimeStamp *time_stamp, UInt32 bus_num, UInt32 n_frames, AudioBufferList *data);
-
-static sa_buf *new_buffer(void);
-
-
-/*
- * -----------------------------------------------------------------------------
- * Startup and shutdown functions
- * -----------------------------------------------------------------------------
- */
-
-int
-sa_stream_create_pcm(
-  sa_stream_t      ** _s,
-  const char        * client_name,
-  sa_mode_t           mode,
-  sa_pcm_format_t     format,
-  unsigned  int       rate,
-  unsigned  int       n_channels
-) {
-
-  /*
-   * Make sure we return a NULL stream pointer on failure.
-   */
-  if (_s == NULL) {
-    return SA_ERROR_INVALID;
-  }
-  *_s = NULL;
-
-  if (mode != SA_MODE_WRONLY) {
-    return SA_ERROR_NOT_SUPPORTED;
-  }
-  if (format != SA_PCM_FORMAT_S16_LE) {
-    return SA_ERROR_NOT_SUPPORTED;
-  }
-
-  /*
-   * Allocate the instance and required resources.
-   */
-  sa_stream_t   * s;
-  if ((s = malloc(sizeof(sa_stream_t))) == NULL) {
-    return SA_ERROR_OOM;
-  }
-  if ((s->bl_head = new_buffer()) == NULL) {
-    free(s);
-    return SA_ERROR_OOM;
-  }
-  if (pthread_mutex_init(&s->mutex, NULL) != 0) {
-    free(s->bl_head);
-    free(s);
-    return SA_ERROR_SYSTEM;
-  }
-
-  s->output_unit  = NULL;
-  s->playing      = FALSE;
-  s->bytes_played = 0;
-  s->rate         = rate;
-  s->n_channels   = n_channels;
-  s->bytes_per_ch = 2;
-  s->bl_tail      = s->bl_head;
-  s->n_bufs       = 1;
-
-  *_s = s;
-  return SA_SUCCESS;
-}
-
-
-int
-sa_stream_open(sa_stream_t *s) {
-
-  if (s == NULL) {
-    return SA_ERROR_NO_INIT;
-  }
-  if (s->output_unit != NULL) {
-    return SA_ERROR_INVALID;
-  }
-
-  /*
-   * Open the default audio output unit.
-   */
-  ComponentDescription desc;
-  desc.componentType         = kAudioUnitType_Output;
-  desc.componentSubType      = kAudioUnitSubType_DefaultOutput;
-  desc.componentManufacturer = kAudioUnitManufacturer_Apple;
-  desc.componentFlags        = 0;
-  desc.componentFlagsMask    = 0;
-
-  Component comp = FindNextComponent(NULL, &desc);
-  if (comp == NULL) {
-    return SA_ERROR_NO_DEVICE;
-  }
-
-  if (OpenAComponent(comp, &s->output_unit) != noErr) {
-    return SA_ERROR_NO_DEVICE;
-  }
-
-  /*
-   * Set up the render callback used to feed audio data into the output unit.
-   */
-  AURenderCallbackStruct input;
-  input.inputProc       = audio_callback;
-  input.inputProcRefCon = s;
-  if (AudioUnitSetProperty(s->output_unit, kAudioUnitProperty_SetRenderCallback,
-      kAudioUnitScope_Input, 0, &input, sizeof(input)) != 0) {
-    return SA_ERROR_SYSTEM;
-  }
-
-  /*
-   * Set up the format description for our audio data. Apple uses the
-   * following terminology:
-   *
-   * sample = a single data value for one channel
-   * frame  = a set of samples that includes one sample for each channel
-   * packet = the smallest indivisible block of audio data; for uncompressed
-   *          audio (which is what we have), this is one frame
-   * rate   = the number of complete frames per second
-   *
-   * Note that this definition of frame differs from, well, pretty much everyone
-   * else's. See this really long link for more info:
-   *
-   * http://developer.apple.com/documentation/MusicAudio/Reference/CoreAudioDataTypesRef/Reference/reference.html#//apple_ref/c/tdef/AudioStreamBasicDescription
-   */
-  AudioStreamBasicDescription fmt;
-  fmt.mFormatID         = kAudioFormatLinearPCM;
-  fmt.mFormatFlags      = kLinearPCMFormatFlagIsSignedInteger |
-#ifdef __BIG_ENDIAN__
-                          kLinearPCMFormatFlagIsBigEndian |
-#endif
-                          kLinearPCMFormatFlagIsPacked;
-  fmt.mSampleRate       = s->rate;
-  fmt.mChannelsPerFrame = s->n_channels;
-  fmt.mBitsPerChannel   = s->bytes_per_ch * 8;
-  fmt.mFramesPerPacket  = 1;  /* uncompressed audio */
-  fmt.mBytesPerFrame    = fmt.mChannelsPerFrame * fmt.mBitsPerChannel / 8;
-  fmt.mBytesPerPacket   = fmt.mBytesPerFrame * fmt.mFramesPerPacket;
-
-  /*
-   * We're feeding data in to the output bus of the audio system, so we set
-   * the format description on the input scope of the device, using the very
-   * obvious element value of 0 to indicate the output bus.
-   *
-   * http://developer.apple.com/technotes/tn2002/tn2091.html
-   */
-  if (AudioUnitSetProperty(s->output_unit, kAudioUnitProperty_StreamFormat,
-      kAudioUnitScope_Input, 0, &fmt, sizeof(AudioStreamBasicDescription)) != 0) {
-    return SA_ERROR_NOT_SUPPORTED;
-  }
-
-  if (AudioUnitInitialize(s->output_unit) != 0) {
-    return SA_ERROR_SYSTEM;
-  }
-
-  return SA_SUCCESS;
-}
-
-
-int
-sa_stream_destroy(sa_stream_t *s) {
-
-  if (s == NULL) {
-    return SA_SUCCESS;
-  }
-
-  pthread_mutex_lock(&s->mutex);
-
-  /*
-   * Shut down the audio output device.
-   */
-  int result = SA_SUCCESS;
-  if (s->output_unit != NULL) {
-    if (s->playing && AudioOutputUnitStop(s->output_unit) != 0) {
-      result = SA_ERROR_SYSTEM;
-    }
-    if (AudioUnitUninitialize(s->output_unit) != 0) {
-      result = SA_ERROR_SYSTEM;
-    }
-    if (CloseComponent(s->output_unit) != noErr) {
-      result = SA_ERROR_SYSTEM;
-    }
-  }
-
-  pthread_mutex_unlock(&s->mutex);
-
-  /*
-   * Release resources.
-   */
-  if (pthread_mutex_destroy(&s->mutex) != 0) {
-    result = SA_ERROR_SYSTEM;
-  }
-  while (s->bl_head != NULL) {
-    sa_buf  * next = s->bl_head->next;
-    free(s->bl_head);
-    s->bl_head = next;
-  }
-  free(s);
-
-  return result;
-}
-
-
-
-/*
- * -----------------------------------------------------------------------------
- * Data read and write functions
- * -----------------------------------------------------------------------------
- */
-
-int
-sa_stream_write(sa_stream_t *s, const void *data, size_t nbytes) {
-
-  if (s == NULL || s->output_unit == NULL) {
-    return SA_ERROR_NO_INIT;
-  }
-  if (nbytes == 0) {
-    return SA_SUCCESS;
-  }
-
-  pthread_mutex_lock(&s->mutex);
-
-  /*
-   * Append the new data to the end of our buffer list.
-   */
-  int result = SA_SUCCESS;
-  while (1) {
-    unsigned int avail = s->bl_tail->size - s->bl_tail->end;
-
-    if (nbytes <= avail) {
-
-      /*
-       * The new data will fit into the current tail buffer, so
-       * just copy it in and we're done.
-       */
-      memcpy(s->bl_tail->data + s->bl_tail->end, data, nbytes);
-      s->bl_tail->end += nbytes;
-      break;
-
-    } else {
-
-      /*
-       * Copy what we can into the tail and allocate a new buffer
-       * for the rest.
-       */
-      memcpy(s->bl_tail->data + s->bl_tail->end, data, avail);
-      s->bl_tail->end += avail;
-      data = ((unsigned char *)data) + avail;
-      nbytes -= avail;
-
-      /* 
-       * If we still have data left to copy but we've hit the limit of
-       * allowable buffer allocations, we need to spin for a bit to allow
-       * the audio callback function to slurp some more data up.
-       */
-      if (nbytes > 0 && s->n_bufs == BUF_LIMIT) {
-#ifdef TIMING_TRACE
-        printf("#");  /* too much audio data */
-#endif
-        if (!s->playing) {
-          /*
-           * We haven't even started playing yet! That means the
-           * BUF_SIZE/BUF_LIMIT values are too low... Not much we can
-           * do here; spinning won't help because the audio callback
-           * hasn't been enabled yet. Oh well, error time.
-           */
-          printf("Too much audio data received before audio device enabled!\n");
-          result = SA_ERROR_SYSTEM;
-          break;
-        }
-        while (s->n_bufs == BUF_LIMIT) {
-          pthread_mutex_unlock(&s->mutex);
-          struct timespec ts = {0, 1000000};
-          nanosleep(&ts, NULL);
-          pthread_mutex_lock(&s->mutex);
-        }
-      }
-
-      /* 
-       * Allocate a new tail buffer, and go 'round again to fill it up.
-       */
-      if ((s->bl_tail->next = new_buffer()) == NULL) {
-        result = SA_ERROR_OOM;
-        break;
-      }
-      s->n_bufs++;
-      s->bl_tail = s->bl_tail->next;
-    
-    } /* if (nbytes <= avail), else */
-
-  } /* while (1) */
-
-  pthread_mutex_unlock(&s->mutex);
-
-  /*
-   * Once we have our first block of audio data, enable the audio callback
-   * function. This doesn't need to be protected by the mutex, because
-   * s->playing is not used in the audio callback thread, and it's probably
-   * better not to be inside the lock when we enable the audio callback.
-   */
-  if (!s->playing) {
-    s->playing = TRUE;
-    if (AudioOutputUnitStart(s->output_unit) != 0) {
-      result = SA_ERROR_SYSTEM;
-    }
-  }
-
-  return result;
-}
-
-
-static OSStatus
-audio_callback(
-  void                        * arg,
-  AudioUnitRenderActionFlags  * action_flags,
-  const AudioTimeStamp        * time_stamp,
-  UInt32                        bus_num,
-  UInt32                        n_frames,
-  AudioBufferList             * data
-) {
-
-#ifdef TIMING_TRACE
-  printf(".");  /* audio read 'tick' */
-#endif
-
-  /*
-   * We're dealing with interleaved data, so the system should only
-   * have provided one buffer to be filled.
-   */
-  assert(data->mNumberBuffers == 1);
-
-  sa_stream_t     * s = arg;
-
-  pthread_mutex_lock(&s->mutex);
-
-  unsigned char   * dst             = data->mBuffers[0].mData;
-  unsigned int      bytes_per_frame = s->n_channels * s->bytes_per_ch;
-  unsigned int      bytes_to_copy   = n_frames * bytes_per_frame;
-
-  /*
-   * Keep track of the number of bytes we've consumed so far. mSampleTime
-   * is actually the number of *frames* that have been consumed by the
-   * audio output unit so far. I don't know why it's a float.
-   */
-  assert(time_stamp->mFlags & kAudioTimeStampSampleTimeValid);
-  s->bytes_played = (int64_t)time_stamp->mSampleTime * bytes_per_frame;
-
-  /*
-   * Consume data from the start of the buffer list.
-   */
-  while (1) {
-    assert(s->bl_head->start <= s->bl_head->end);
-    unsigned int avail = s->bl_head->end - s->bl_head->start;
-
-    if (avail >= bytes_to_copy) {
-
-      /*
-       * We have all we need in the head buffer, so just grab it and go.
-       */
-      memcpy(dst, s->bl_head->data + s->bl_head->start, bytes_to_copy);
-      s->bl_head->start += bytes_to_copy;
-      break;
-
-    } else {
-
-      /*
-       * Copy what we can from the head and move on to the next buffer.
-       */
-      memcpy(dst, s->bl_head->data + s->bl_head->start, avail);
-      s->bl_head->start += avail;
-      dst += avail;
-      bytes_to_copy -= avail;
-
-      /*
-       * We want to free the now-empty buffer, but not if it's also the
-       * current tail. If it is the tail, we don't have enough data to fill
-       * the destination buffer, so we'll just zero it out and give up.
-       */
-      sa_buf  * next = s->bl_head->next;
-      if (next == NULL) {
-#ifdef TIMING_TRACE
-        printf("!");  /* not enough audio data */
-#endif
-        memset(dst, 0, bytes_to_copy);
-        break;
-      }
-      free(s->bl_head);
-      s->bl_head = next;
-      s->n_bufs--;
-
-    } /* if (avail >= bytes_to_copy), else */
-
-  } /* while (1) */
-
-  pthread_mutex_unlock(&s->mutex);
-  return noErr;
-}
-
-
-
-/*
- * -----------------------------------------------------------------------------
- * General query and support functions
- * -----------------------------------------------------------------------------
- */
-
-int
-sa_stream_get_write_size(sa_stream_t *s, size_t *size) {
-
-  if (s == NULL || s->output_unit == NULL) {
-    return SA_ERROR_NO_INIT;
-  }
-
-  pthread_mutex_lock(&s->mutex);
-
-  /*
-   * Sum up the used portions of our buffers and subtract that from
-   * the pre-defined max allowed allocation.
-   */
-  sa_buf  * b;
-  size_t    used = 0;
-  for (b = s->bl_head; b != NULL; b = b->next) {
-    used += b->end - b->start;
-  }
-  *size = BUF_SIZE * BUF_LIMIT - used;
-
-  pthread_mutex_unlock(&s->mutex);
-  return SA_SUCCESS;
-}
-
-
-int
-sa_stream_get_position(sa_stream_t *s, sa_position_t position, int64_t *pos) {
-
-  if (s == NULL || s->output_unit == NULL) {
-    return SA_ERROR_NO_INIT;
-  }
-  if (position != SA_POSITION_WRITE_SOFTWARE) {
-    return SA_ERROR_NOT_SUPPORTED;
-  }
-
-  pthread_mutex_lock(&s->mutex);
-  *pos = s->bytes_played;
-  pthread_mutex_unlock(&s->mutex);
-  return SA_SUCCESS;
-}
-
-
-int
-sa_stream_pause(sa_stream_t *s) {
-
-  if (s == NULL || s->output_unit == NULL) {
-    return SA_ERROR_NO_INIT;
-  }
-
-  pthread_mutex_lock(&s->mutex);
-  AudioOutputUnitStop(s->output_unit);
-  pthread_mutex_unlock(&s->mutex);
-  return SA_SUCCESS;
-}
-
-
-int
-sa_stream_resume(sa_stream_t *s) {
-
-  if (s == NULL || s->output_unit == NULL) {
-    return SA_ERROR_NO_INIT;
-  }
-
-  pthread_mutex_lock(&s->mutex);
-
-  /*
-   * The audio device resets its mSampleTime counter after pausing,
-   * so we need to clear our tracking value to keep that in sync.
-   */
-  s->bytes_played = 0;
-  AudioOutputUnitStart(s->output_unit);
-
-  pthread_mutex_unlock(&s->mutex);
-  return SA_SUCCESS;
-}
-
-
-static sa_buf *
-new_buffer(void) {
-  sa_buf  * b = malloc(sizeof(sa_buf) + BUF_SIZE);
-  if (b != NULL) {
-    b->size  = BUF_SIZE;
-    b->start = 0;
-    b->end   = 0;
-    b->next  = NULL;
-  }
-  return b;
-}
-
-
-
-/*
- * -----------------------------------------------------------------------------
- * Extension functions
- * -----------------------------------------------------------------------------
- */
-
-int
-sa_stream_set_volume_abs(sa_stream_t *s, float vol) {
-
-  if (s == NULL || s->output_unit == NULL) {
-    return SA_ERROR_NO_INIT;
-  }
-
-  pthread_mutex_lock(&s->mutex);
-  AudioUnitSetParameter(s->output_unit, kHALOutputParam_Volume,
-      kAudioUnitParameterFlag_Output, 0, vol, 0);
-  pthread_mutex_unlock(&s->mutex);
-  return SA_SUCCESS;
-}
-
-
-int
-sa_stream_get_volume_abs(sa_stream_t *s, float *vol) {
-
-  if (s == NULL || s->output_unit == NULL) {
-    return SA_ERROR_NO_INIT;
-  }
-
-  pthread_mutex_lock(&s->mutex);
-  Float32 local_vol = 0;
-  AudioUnitGetParameter(s->output_unit, kHALOutputParam_Volume,
-      kAudioUnitParameterFlag_Output, 0, &local_vol);
-  *vol = local_vol;
-  pthread_mutex_unlock(&s->mutex);
-  return SA_SUCCESS;
-}
-
-
-
-/*
- * -----------------------------------------------------------------------------
- * Unsupported functions
- * -----------------------------------------------------------------------------
- */
-#define UNSUPPORTED(func)   func { return SA_ERROR_NOT_SUPPORTED; }
-
-UNSUPPORTED(int sa_stream_create_opaque(sa_stream_t **s, const char *client_name, sa_mode_t mode, const char *codec))
-UNSUPPORTED(int sa_stream_set_write_lower_watermark(sa_stream_t *s, size_t size))
-UNSUPPORTED(int sa_stream_set_read_lower_watermark(sa_stream_t *s, size_t size))
-UNSUPPORTED(int sa_stream_set_write_upper_watermark(sa_stream_t *s, size_t size))
-UNSUPPORTED(int sa_stream_set_read_upper_watermark(sa_stream_t *s, size_t size))
-UNSUPPORTED(int sa_stream_set_channel_map(sa_stream_t *s, const sa_channel_t map[], unsigned int n))
-UNSUPPORTED(int sa_stream_set_xrun_mode(sa_stream_t *s, sa_xrun_mode_t mode))
-UNSUPPORTED(int sa_stream_set_non_interleaved(sa_stream_t *s, int enable))
-UNSUPPORTED(int sa_stream_set_dynamic_rate(sa_stream_t *s, int enable))
-UNSUPPORTED(int sa_stream_set_driver(sa_stream_t *s, const char *driver))
-UNSUPPORTED(int sa_stream_start_thread(sa_stream_t *s, sa_event_callback_t callback))
-UNSUPPORTED(int sa_stream_stop_thread(sa_stream_t *s))
-UNSUPPORTED(int sa_stream_change_device(sa_stream_t *s, const char *device_name))
-UNSUPPORTED(int sa_stream_change_read_volume(sa_stream_t *s, const int32_t vol[], unsigned int n))
-UNSUPPORTED(int sa_stream_change_write_volume(sa_stream_t *s, const int32_t vol[], unsigned int n))
-UNSUPPORTED(int sa_stream_change_rate(sa_stream_t *s, unsigned int rate))
-UNSUPPORTED(int sa_stream_change_meta_data(sa_stream_t *s, const char *name, const void *data, size_t size))
-UNSUPPORTED(int sa_stream_change_user_data(sa_stream_t *s, const void *value))
-UNSUPPORTED(int sa_stream_set_adjust_rate(sa_stream_t *s, sa_adjust_t direction))
-UNSUPPORTED(int sa_stream_set_adjust_nchannels(sa_stream_t *s, sa_adjust_t direction))
-UNSUPPORTED(int sa_stream_set_adjust_pcm_format(sa_stream_t *s, sa_adjust_t direction))
-UNSUPPORTED(int sa_stream_set_adjust_watermarks(sa_stream_t *s, sa_adjust_t direction))
-UNSUPPORTED(int sa_stream_get_mode(sa_stream_t *s, sa_mode_t *access_mode))
-UNSUPPORTED(int sa_stream_get_codec(sa_stream_t *s, char *codec, size_t *size))
-UNSUPPORTED(int sa_stream_get_pcm_format(sa_stream_t *s, sa_pcm_format_t *format))
-UNSUPPORTED(int sa_stream_get_rate(sa_stream_t *s, unsigned int *rate))
-UNSUPPORTED(int sa_stream_get_nchannels(sa_stream_t *s, int *nchannels))
-UNSUPPORTED(int sa_stream_get_user_data(sa_stream_t *s, void **value))
-UNSUPPORTED(int sa_stream_get_write_lower_watermark(sa_stream_t *s, size_t *size))
-UNSUPPORTED(int sa_stream_get_read_lower_watermark(sa_stream_t *s, size_t *size))
-UNSUPPORTED(int sa_stream_get_write_upper_watermark(sa_stream_t *s, size_t *size))
-UNSUPPORTED(int sa_stream_get_read_upper_watermark(sa_stream_t *s, size_t *size))
-UNSUPPORTED(int sa_stream_get_channel_map(sa_stream_t *s, sa_channel_t map[], unsigned int *n))
-UNSUPPORTED(int sa_stream_get_xrun_mode(sa_stream_t *s, sa_xrun_mode_t *mode))
-UNSUPPORTED(int sa_stream_get_non_interleaved(sa_stream_t *s, int *enabled))
-UNSUPPORTED(int sa_stream_get_dynamic_rate(sa_stream_t *s, int *enabled))
-UNSUPPORTED(int sa_stream_get_driver(sa_stream_t *s, char *driver_name, size_t *size))
-UNSUPPORTED(int sa_stream_get_device(sa_stream_t *s, char *device_name, size_t *size))
-UNSUPPORTED(int sa_stream_get_read_volume(sa_stream_t *s, int32_t vol[], unsigned int *n))
-UNSUPPORTED(int sa_stream_get_write_volume(sa_stream_t *s, int32_t vol[], unsigned int *n))
-UNSUPPORTED(int sa_stream_get_meta_data(sa_stream_t *s, const char *name, void*data, size_t *size))
-UNSUPPORTED(int sa_stream_get_adjust_rate(sa_stream_t *s, sa_adjust_t *direction))
-UNSUPPORTED(int sa_stream_get_adjust_nchannels(sa_stream_t *s, sa_adjust_t *direction))
-UNSUPPORTED(int sa_stream_get_adjust_pcm_format(sa_stream_t *s, sa_adjust_t *direction))
-UNSUPPORTED(int sa_stream_get_adjust_watermarks(sa_stream_t *s, sa_adjust_t *direction))
-UNSUPPORTED(int sa_stream_get_state(sa_stream_t *s, sa_state_t *state))
-UNSUPPORTED(int sa_stream_get_event_error(sa_stream_t *s, sa_error_t *error))
-UNSUPPORTED(int sa_stream_get_event_notify(sa_stream_t *s, sa_notify_t *notify))
-UNSUPPORTED(int sa_stream_read(sa_stream_t *s, void *data, size_t nbytes))
-UNSUPPORTED(int sa_stream_read_ni(sa_stream_t *s, unsigned int channel, void *data, size_t nbytes))
-UNSUPPORTED(int sa_stream_write_ni(sa_stream_t *s, unsigned int channel, const void *data, size_t nbytes))
-UNSUPPORTED(int sa_stream_pwrite(sa_stream_t *s, const void *data, size_t nbytes, int64_t offset, sa_seek_t whence))
-UNSUPPORTED(int sa_stream_pwrite_ni(sa_stream_t *s, unsigned int channel, const void *data, size_t nbytes, int64_t offset, sa_seek_t whence))
-UNSUPPORTED(int sa_stream_get_read_size(sa_stream_t *s, size_t *size))
-UNSUPPORTED(int sa_stream_drain(sa_stream_t *s))
-
-const char *sa_strerror(int code) { return NULL; }
-
diff -r 4b060ed856e0 media/liboggplay_audio/sydney_audio_oss.c
--- a/media/liboggplay_audio/sydney_audio_oss.c	Tue Oct 14 17:12:28 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,640 +0,0 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Initial Developer of the Original Code is
- * CSIRO
- * Portions created by the Initial Developer are Copyright (C) 2007
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s): Marcin Lubonski 
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** *
- */
-
-#include "sydney_audio.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <sys/soundcard.h>
-
-#include <sys/ioctl.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <string.h>
-
-#define SA_READ_PERIOD 0 
-#define SA_WRITE_PERIOD 2560 // 40 ms of 16-bit, stereo, 16kHz
-#define SA_READ_BUFFER 0
-#define SA_WRITE_BUFFER 7680 // 3 periods per buffer
-
-// for versions newer than 3.6.1
-#define OSS_VERSION(x, y, z) (x << 16 | y << 8 | z)
-// support only versions newer than 3.6.1
-#define SUPP_OSS_VERSION OSS_VERSION(3,6,1)
-
-#if (SOUND_VERSION >= SUPP_OSS_VERSION)
-
-struct SAAudioHandle_ {
-   char *device_name;
-   int channels;
-   int read_period;
-   int write_period;
-   int read_buffer;
-   int write_buffer;
-   sa_pcm_mode_t rw_mode;
-   sa_pcm_format_t format;
-   int rate;
-   int interleaved;
-
-   int capture_handle;
-   int playback_handle;
-   int readN, writeN;
-   char *stored;
-   int stored_amount;
-   int stored_limit;
-   //int read_fd, write_fd;
-};
-
-/* Implemented API functions */
-/** Normal way to open PCM device */
-int sa_device_create_pcm(SAAudioHandle **_dev, const char *client_name, sa_pcm_mode_t rw_mode, sa_pcm_format_t format, int rate, int channels);
-/** Initialise the device */
-int sa_device_open(SAAudioHandle *dev);
-/** Close/destroy everything */
-int sa_device_close(SAAudioHandle *dev);
-
-/* Soft parameter setup - can only be called before calling open*/
-/** Set write buffer lower mark */
-int sa_device_set_write_lower_watermark(SAAudioHandle *dev, int size);
-/** Set read buffer lower mark */
-int sa_device_set_read_lower_watermark(SAAudioHandle *dev, int size);
-/** Set write buffer upper watermark */
-int sa_device_set_write_upper_watermark(SAAudioHandle *dev, int size);
-/** Set read buffer upper watermark */
-int sa_device_set_read_upper_watermark(SAAudioHandle *dev, int size);
-
-/** volume in hundreths of dB's*/
-int sa_device_change_input_volume(SAAudioHandle *dev, const int *vol);
-/** volume in hundreths of dB's*/
-int sa_device_change_output_volume(SAAudioHandle *dev, const int *vol);
-
-/** Read audio playback position */
-int sa_device_get_position(SAAudioHandle *dev, sa_pcm_index_t ref, int64_t *pos);
-
-/* Blocking I/O calls */
-/** Interleaved playback function */
-int sa_device_write(SAAudioHandle *dev, size_t nbytes, const void *data);
-
-
-/* Implementation-specific functions */
-static int oss_audio_format(sa_pcm_format_t sa_format, int* oss_format);
-//static void sa_print_handle_settings(SAAudioHandle* dev);
-
-/*!
- * \brief fills in the SAAudioHandle struct
- * \param SAAudioHandle - encapsulation of a handle to audio device
- * \param client_name - 
- * \param rw_mode - requested device access type as in :: sa_pcm_mode_t
- * \param format - audio format as specified in ::sa_pcm_format_t
- * \return - Sydney API error as in ::sa_pcm_error_t 
- */
-int sa_device_create_pcm(SAAudioHandle **_dev, const char *client_name, sa_pcm_mode_t rw_mode, sa_pcm_format_t format, int rate, int channels) {
-	SAAudioHandle* dev = NULL;
-	
-	dev = malloc(sizeof(SAAudioHandle));
-	
-	if (!dev) {
-		return SA_DEVICE_OOM;	
-	}		        
-	dev->channels = channels;
-	dev->format = format;
-	dev->rw_mode = rw_mode;
-	dev->rate = rate;
-	dev->readN = 0;
-	dev->readN = 0;
-	dev->capture_handle = -1;
-	dev->playback_handle = -1;
-	dev->interleaved = 1;
-	dev->read_period = SA_READ_PERIOD;
-	dev->write_period = SA_WRITE_PERIOD;
-	dev->read_buffer = SA_READ_BUFFER;
-	dev->write_buffer = SA_WRITE_BUFFER;
-  dev->device_name = "/dev/dsp";
-  dev->stored = NULL;
-  dev->stored_amount = 0;
-  dev->stored_limit = 0;
-	
-	*_dev = dev;
-	 //sa_print_handle_settings(dev);
-	 return SA_DEVICE_SUCCESS;
-}
-
-/*!
- * \brief creates and opens selected audio device
- * \param dev - encapsulated audio device handle
- * \return - Sydney API error as in ::sa_pcm_error_t  
- */
-int sa_device_open(SAAudioHandle *dev) {	
- 	int err;
-	int fmt;
-	int audio_fd = -1;
-
-	if (dev->rw_mode == SA_PCM_WRONLY) {
-		// open the default OSS device
-		dev->device_name = "/dev/dsp"; // replace with a function which returns audio ouput device best matching the settings
-		audio_fd = open(dev->device_name, O_WRONLY, 0);
-		if (audio_fd == -1) {
-		   fprintf(stderr, "Cannot open device: %s\n", dev->device_name);
-		   //assert(0);
-		   return SA_DEVICE_OOM;
-		}
-
-		// set the playback rate
-		if ((err = ioctl(audio_fd, SNDCTL_DSP_SPEED, &(dev->rate))) < 0) {
-		   fprintf(stderr, 
-			"Error setting the audio playback rate [%d]\n", 
-			dev->rate);
-		   //assert(0);
-		   return SA_DEVICE_OOM; 
-		}
-		// set the channel numbers
-		if ((err = ioctl(audio_fd,  SNDCTL_DSP_CHANNELS, 
-			&(dev->channels)))< 0) {
-		   fprintf(stderr, "Error setting audio channels\n");
-		   //assert(0);
-		   return SA_DEVICE_OOM;	
-		} 
-		if ((err = oss_audio_format(dev->format, &fmt)) < 0) {
-		   fprintf(stderr, "Format unknown\n");
-		   //assert(0);
-                   return SA_DEVICE_OOM;	   
-		}
-		printf("Setting format with value %d\n", fmt);
-		if ((err = ioctl(audio_fd, SNDCTL_DSP_SETFMT, &fmt)) < 0 ) {
-		   fprintf(stderr, "Error setting audio format\n");
-		   //assert(0);
-		   return SA_DEVICE_OOM;
-		}
-
-		dev->playback_handle = audio_fd;
- 		
-	}
-	if (dev->rw_mode == SA_PCM_RDONLY) {
-		return SA_DEVICE_NOT_SUPPORTED;
-	} 
-	if (dev->rw_mode == SA_PCM_RW) {
-		return SA_DEVICE_NOT_SUPPORTED;
-	}
-	fprintf(stderr, "Audio device opened successfully\n");
-	return SA_DEVICE_SUCCESS;
-}
-
-#define WRITE(data,amt)                                       \
-  if ((err = write(dev->playback_handle, data, amt)) < 0) {   \
-    fprintf(stderr, "Error writing data to audio device\n");  \
-    return SA_DEVICE_OOM;                                     \
-  }
-
-/*!
- * \brief Interleaved write operation
- * \param dev - device handle
- * \param nbytes - size of the audio buffer to be written to device
- * \param data - pointer to the buffer with audio samples
- * \return 
- * */
-int sa_device_write(SAAudioHandle *dev, size_t nbytes, const void *_data) {
-	int               err;
-  audio_buf_info    info;
-  int               bytes;
-  char            * data = (char *)_data;
-  /*
-  ioctl(dev->playback_handle, SNDCTL_DSP_GETOSPACE, &info);
-  printf("fragment size: %d, nfrags: %d, free: %d wtw: %d\n", info.fragsize, 
-                  info.fragstotal, info.bytes, nbytes);
-  */
-
-
-
-	if ((dev->playback_handle) > 0) {
-    ioctl(dev->playback_handle, SNDCTL_DSP_GETOSPACE, &info);
-    bytes = info.bytes;
-    if (dev->stored_amount > bytes) {
-      WRITE(dev->stored, bytes);
-      memmove(dev->stored, dev->stored + bytes, dev->stored_amount - bytes);
-      dev->stored_amount -= bytes;
-    } else if (dev->stored_amount > 0) {
-      WRITE(dev->stored, dev->stored_amount);
-      bytes -= dev->stored_amount;
-      dev->stored_amount = 0;
-      if (nbytes < bytes) {
-        WRITE(data, nbytes);
-        return SA_DEVICE_SUCCESS;
-      }
-      WRITE(data, bytes);
-      data += bytes;
-      nbytes -= bytes;
-    } else {
-      if (nbytes < bytes) {
-        WRITE(data, nbytes);
-        return SA_DEVICE_SUCCESS;
-      }
-      WRITE(data, bytes);
-      data += bytes;
-      nbytes -= bytes;
-    }
-
-    if (nbytes > 0) {
-      if (dev->stored_amount + nbytes > dev->stored_limit) {
-        dev->stored = realloc(dev->stored, dev->stored_amount + nbytes);
-      }
-      
-      memcpy(dev->stored + dev->stored_amount, data, nbytes);
-      dev->stored_amount += nbytes;
-    }
-	}
-	return SA_DEVICE_SUCCESS;
-}
-
-#define CLOSE_HANDLE(x) if (x != -1) close(x);
-
-/*!
- * \brief Closes and destroys allocated resources
- * \param dev - Sydney Audio device handle
- * \return Sydney API error as in ::sa_pcm_error_t
- **/
-int sa_device_close(SAAudioHandle *dev) {
-  int err;
-
-	if (dev != NULL) {
-
-    if (dev->stored_amount > 0) {
-      WRITE(dev->stored, dev->stored_amount);
-    }
-
-    if (dev->stored != NULL) {
-      free(dev->stored);
-    }
-
-    dev->stored = NULL;
-    dev->stored_amount = 0;
-    dev->stored_limit = 0;
-	  
-    CLOSE_HANDLE(dev->playback_handle);
-	  CLOSE_HANDLE(dev->capture_handle);
-
-	  printf("Closing audio device\n");	
-	  free(dev);
-	}
- 	return SA_DEVICE_SUCCESS;
-}
-
-/** 
- * \brief 
- * \param dev
- * \param size
- * \return  Sydney API error as in ::sa_pcm_error_t
- */
-int sa_device_set_write_lower_watermark(SAAudioHandle *dev, int size) {
-   dev->write_period = size;
-   return SA_DEVICE_SUCCESS;
-}
-/** 
- * \brief
- * \param dev
- * \param size
- * \return  Sydney API error as in ::sa_pcm_error_t
- */
-int sa_device_set_read_lower_watermark(SAAudioHandle *dev, int size) {
-   dev->read_period = size;
-   return SA_DEVICE_SUCCESS;
-}
-/** 
- * \brief
- * \param dev
- * \param size
- * \return  Sydney API error as in ::sa_pcm_error_t
- */
-int sa_device_set_write_upper_watermark(SAAudioHandle *dev, int size) {  
-   dev->write_buffer = size;
-   return SA_DEVICE_SUCCESS;
-}
-
-/** 
- * \brief
- * \param dev
- * \param size
- * \return  Sydney API error as in ::sa_pcm_error_t
- */
-int sa_device_set_read_upper_watermark(SAAudioHandle *dev, int size) {
-   dev->read_buffer = size;
-   return SA_DEVICE_SUCCESS;
-}
-
-
-int sa_device_set_xrun_mode(SAAudioHandle *dev, sa_xrun_mode_t mode) {
-   return SA_DEVICE_NOT_SUPPORTED;
-}
-
-
-int sa_device_set_ni(SAAudioHandle *dev) {
-   dev->interleaved = 1;
-   return SA_DEVICE_SUCCESS;
-}
-
-int sa_device_start_thread(SAAudioHandle *dev, sa_device_callback *callback) {
-   return SA_DEVICE_NOT_SUPPORTED;
-}
-
-int sa_device_set_channel_map(SAAudioHandle *dev, const sa_channel_def_t *map) {
-   return SA_DEVICE_NOT_SUPPORTED;
-}
-
-
-int sa_device_change_device(SAAudioHandle *dev, const char *device_name) {
-   return SA_DEVICE_NOT_SUPPORTED;
-}
-
-/*!
- * \brief volume in hundreths of dB's
- * \param dev - device handle
- * \param vol - volume level 
- * \return Sydney API error as in ::sa_pcm_error_t
- * */
-int sa_device_change_input_volume(SAAudioHandle *dev, const int *vol) {
-#if SOUND_VERSION >= OSS_VERSION(4,0,0)	
-	int err;
-	if ((err = ioctl(dev->capture_handle, SNDCTL_DSP_SETRECVOL, vol) < 0) {
-	   fpritnf(stderr, "Error setting new recording volume level\n");
-	   //assert(0);
-           return SA_DEVICE_OOM;	   
-	}
-	return SA_DEVICE_SUCCESS;
-#else
-	return SA_DEVICE_NOT_SUPPORTED;
-#endif
-}
-
-/*!
- * \brief volume in hundreths of dB's
- * \param dev - device handle
- * \param vol - volume level
- * \retrun  Sydney API error as in ::sa_pcm_error_t
- * */
-int sa_device_change_output_volume(SAAudioHandle *dev, const int *vol) {
-#if SOUND_VERSION >= OSS_VERSION(4,0,0)
-	int err;
-	if ((err = ioctl(dev->playback_handle, SNDCTL_DSP_SETPLAYVOL, vol) < 0){
-
-	fprintf(stderr, "Error setting new playback volume\n");
-	//assert(0);
-	return SA_DEVICE_OOM; 
-        }
-	return SA_DEVICE_SUCCESS;
-#else
-	return SA_DEVICE_NOT_SUPPORTED;
-#endif
-}
-
-int sa_device_change_sampling_rate(SAAudioHandle *dev, int rate) {
-   dev->rate = rate;
-   return SA_DEVICE_SUCCESS;
-}
-
-int sa_device_change_client_name(SAAudioHandle *dev, const char *client_name) {
-   return SA_DEVICE_NOT_SUPPORTED;
-}
-
-int sa_device_change_stream_name(SAAudioHandle *dev, const char *stream_name) {
-   return SA_DEVICE_NOT_SUPPORTED;
-}
-
-int sa_device_change_user_data(SAAudioHandle *dev, void *val) {
-   return SA_DEVICE_NOT_SUPPORTED;
-}
-
-
-/*!
- * \brief
- * \param dev
- * \param rate
- * \param direction
- * \return  Sydney API error as in ::sa_pcm_error_t
- * */
-int sa_device_adjust_rate(SAAudioHandle *dev, int rate, int direction) {
-   return  SA_DEVICE_NOT_SUPPORTED;
-}
-/*!
- * \brief
- * \param dev
- * \param nb_channels
- * \return  Sydney API error as in ::sa_pcm_error_t
- * */
-int sa_device_adjust_channels(SAAudioHandle *dev, int nb_channels) {               return SA_DEVICE_NOT_SUPPORTED;
-}
-/** Adjust bit sample format */
-int sa_device_adjust_format(SAAudioHandle *dev, sa_pcm_format_t format, int direction) {
-   return SA_DEVICE_NOT_SUPPORTED;
-}
-
-/** Get current state of the audio device */
-int sa_device_get_state(SAAudioHandle *dev, sa_state_t *running) {
-   return SA_DEVICE_NOT_SUPPORTED;
-}
-
-/** Get current sampling rate */
-int sa_device_get_sampling_rate(SAAudioHandle *dev, int *rate) {
-   return SA_DEVICE_NOT_SUPPORTED;
-}
-
-/** Get number of channels */
-int sa_device_get_nb_channels(SAAudioHandle *dev, int *nb_channels) {
-   return SA_DEVICE_NOT_SUPPORTED;
-}
-
-/** Get format being used */
-int sa_device_get_format(SAAudioHandle *dev, sa_pcm_format_t *format) {
-   return SA_DEVICE_NOT_SUPPORTED;
-}
-
-/** Get opaque pointer associated to the device */
-int sa_device_get_user_data(SAAudioHandle *dev, void **val) {
-   return SA_DEVICE_NOT_SUPPORTED;
-}
-
-/** Obtain the error code */
-int sa_device_get_event_error(SAAudioHandle *dev, sa_pcm_error_t *error) {
-   return SA_DEVICE_NOT_SUPPORTED;
-}
-
-/** Obtain the notification code */
-int sa_device_get_event_notify(SAAudioHandle *dev, sa_pcm_notification_t *notify) {
-   return SA_DEVICE_NOT_SUPPORTED;
-}
-
-/*!
- * \brief returns the current position of the audio playback capture
- * \param dev - device handle
- * \param ref - type of position to be returned by this function see ::sa_pcm_index_t
- * \param pos - position (in bytes or ms depending on 'ref' value)
- * \return  Sydney API error as in ::sa_pcm_error_t
- * */
-int sa_device_get_position(SAAudioHandle *dev, sa_pcm_index_t ref, int64_t *pos)
-{
-   int err;
-   int64_t _pos;
-   int delay;
-   count_info ptr;
-   switch (ref) {
-	 case SA_PCM_WRITE_DELAY:
-	      //int delay;
-	      if ((err = ioctl(dev->playback_handle, 
-			       SNDCTL_DSP_GETODELAY, 
- 			       &delay)) <0) {
-	      	fprintf(stderr, "Error reading playback buffering delay\n");
-		return SA_DEVICE_OOM;	
-	      };  
-	      _pos = (int64_t)delay;
-	      break;
-         case SA_PCM_WRITE_SOFTWARE_POS:
-              //count_info ptr;
-	      if ((err = ioctl(dev->playback_handle, 
-                               SNDCTL_DSP_GETOPTR, 
-                               &ptr)) <0) {
-                //fprintf(stderr, "Error reading audio playback position\n");
-		return SA_DEVICE_OOM;
-              };
-	      _pos = (int64_t)ptr.bytes;  
-	      break;
-         case SA_PCM_READ_SOFTWARE_POS:
-              //count_info ptr;
-	      if ((err = ioctl(dev->playback_handle, 
-                               SNDCTL_DSP_GETIPTR, 
-                               &ptr)) <0) {
-              	 fprintf(stderr, "Error reading audio capture position\n");
-		 return SA_DEVICE_OOM;
-	      };
-               _pos = (int64_t)ptr.bytes;
-	      break;
-
-	 case SA_PCM_READ_DELAY:
-	 case SA_PCM_READ_HARDWARE_POS:
-	 case SA_PCM_WRITE_HARDWARE_POS:               
-	 case SA_PCM_DUPLEX_DELAY:
-	 default:
-	      return SA_DEVICE_NOT_SUPPORTED;
-	      break;		
-   }
-   (*pos) = _pos;
-   return SA_DEVICE_SUCCESS;
-}
-
-/** Private functions - implementation specific */
-
-/*!
- * \brief private function mapping Sudney Audio format to OSS formats
- * \param format - Sydney Audio API specific format
- * \param - filled by the function with a value for corresponding OSS format
- * \return - Sydney API error value as in ::sa_pcm_format_t
- * */
-static int oss_audio_format(sa_pcm_format_t sa_format, int* oss_format) {
-#if SOUND_VERSION >= OSS_VERSION(4,0,0) 	
-	int fmt = AFMT_UNDEF;
-#else
-	int fmt = -1;
-#endif	
-	switch (sa_format) {
-                   case SA_PCM_UINT8:
-			fmt = AFMT_U8;
-			break;
-                   case SA_PCM_ULAW:
-			fmt = AFMT_MU_LAW;
-			break;
-                   case SA_PCM_ALAW:
-			fmt = AFMT_A_LAW;
-			break;
-		   /* 16-bit little endian (LE) format */
-                   case SA_PCM_S16_LE:
-			fmt = AFMT_S16_LE;
-			break;
-		   /* 16-bit big endian (BE) format */
-                   case SA_PCM_S16_BE:
-			fmt = AFMT_S16_BE;
-			break;
-#if SOUND_VERSION >= OSS_VERSION(4,0,0)
-		   /* 24-bit formats (LSB aligned in 32 bit word) */
-                   case SA_PCM_S24_LE:
-			fmt = AFMT_S24_LE;
-			break;
-		   /* 24-bit formats (LSB aligned in 32 bit word) */
-		   case SA_PCM_S24_BE:
-			fmt = AFMT_S24_BE;
-			break;
-		   /* 32-bit format little endian */
-                   case SA_PCM_S32_LE:
-			fmt = AFMT_S32_LE;
-			break;
-		   /* 32-bit format big endian */
-                   case SA_PCM_S32_BE:
-			fmt = AFMT_S32_BE;
-			break; 
-                   case SA_PCM_FLOAT32_NE:
-			fmt = AFMT_FLOAT;
-			break;
-#endif
-		   default:
-			return SA_DEVICE_NOT_SUPPORTED;
-			break;
-
-                }
-	(*oss_format) = fmt;
-	return SA_DEVICE_SUCCESS;
-}
-
-/*
-static void sa_print_handle_settings(SAAudioHandle* dev) {
-    printf(">>>>>>>>>>>> SA Device Handle <<<<<<<<<<<\n"); 
-    printf("[SA Audio] - Device name %s\n", dev->device_name);
-    printf("[SA_Audio] - Number of audio channels %d\n", dev->channels);
-    printf("[SA_Audio] - Read period size %d bytes\n", dev->read_period);
-    printf("[SA_Audio] - Write period size %d bytes\n", dev->write_period);
-    printf("[SA_Audio] - Write buffer size %d bytes\n", dev->write_buffer);
-    printf("[SA_Audio] - Read buffer size %d bytes\n", dev->read_buffer);
-    printf("[SA_Audio] - Read/write mode value %d\n", dev->rw_mode);
-    printf("[SA_Audio] - Audio sample bit format value %d\n", dev->format);
-    printf("[SA_Audio] - Audio playback rate %d\n", dev->rate);
-    if (dev->interleaved) {
-        printf("[SA_Audio] - Processing interleaved audio\n");
-    } else {
-	printf("[SA_Audio] - Processing non-interleaved audio\n");
-    }
-    if ((dev->capture_handle) > 0) {
-    	printf("[SA Audio] - Device opened for capture\n");
-    } 
-    if ((dev->playback_handle) > 0) {
-    	printf("[SA_Audio] - Device opened for playback\n");
-    }	    
-}
-*/
-
-#endif // (SOUND_VERSION > SUPP_OSS_VERSION)
diff -r 4b060ed856e0 media/liboggplay_audio/sydney_audio_waveapi.c
--- a/media/liboggplay_audio/sydney_audio_waveapi.c	Tue Oct 14 17:12:28 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,681 +0,0 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Initial Developer of the Original Code is
- * CSIRO
- * Portions created by the Initial Developer are Copyright (C) 2007
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s): Marcin Lubonski 
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** *
- */
-
-#include "sydney_audio.h"
-#include <stdio.h>
-#include <stdlib.h>
-
-#include <windows.h>
-#include <mmreg.h>
-#include <mmsystem.h>
-#include <math.h>
-
-
-// FIX ME: block size and block should be determined based on the OggPlay offset 
-// for audio track
-#define BLOCK_SIZE  2560
-#define BLOCK_COUNT 32
-#define DEFAULT_DEVICE_NAME "Default WAVE Device"
-#define DEFAULT_DEVICE WAVE_MAPPER
-
-#define VERBOSE_OUTPUT 1
-
-// INFO: if you get weird compile errors make sure there is no extra chars pass '\' 
-#if defined(VERBOSE_OUTPUT)
-#define WAVE_ERROR_VERBOSE(error, message) \
-  switch (error) { \
-    case MMSYSERR_ALLOCATED: \
-      printf("[WAVE API] Device allocation error returned while executing %s\n", message); \
-      break; \
-    case MMSYSERR_BADDEVICEID: \
-      printf("[WAVE API] Wrong device ID error returned while executing %s\n", message); \
-      break; \
-    case MMSYSERR_NODRIVER: \
-      printf("[WAVE API] System driver not present error returned while executing %s\n", message); \
-      break; \
-    case MMSYSERR_INVALHANDLE: \
-      printf("[WAVE API] Invalid device handle error returned while executing %s\n", message); \
-      break; \
-    case MMSYSERR_NOMEM: \
-      printf("[WAVE API] No memory error returned while executing %s\n", message); \
-      break; \
-    case MMSYSERR_NOTSUPPORTED: \
-      printf("[WAVE API] Not supported error returned while executing %s\n", message); \
-      break; \
-    case WAVERR_BADFORMAT: \
-      printf("[WAVE API] Not valid audio format returned while executing %s\n", message); \
-      break; \
-    case WAVERR_SYNC: \
-      printf("[WAVE API] Device synchronous error returned while executing %s\n", message); \
-      break; \
-    default: \
-      printf("[WAVE API] Error while executing %s\n", message); \
-      break; \
-  }
-#else
-#define WAVE_ERROR_VERBOSE(error, message) \
-  do {} while(0)
-#endif
-
-#define HANDLE_WAVE_ERROR(status, location) \
-  if (status != MMSYSERR_NOERROR) { \
-      WAVE_ERROR_VERBOSE(status, location); \
-      return getSAErrorCode(status); \
-  }
-
-#define ERROR_IF_NO_INIT(handle) \
-  if (handle == NULL) { \
-		return SA_ERROR_NO_INIT; \
-	}
-
-/* local implementation of the sa_stream_t type */
-struct sa_stream {   
-  char*           deviceName;
-  UINT				    device;
-  UINT				    channels;
-  UINT				    rate;
-	
-  sa_mode_t			  rwMode;
-  sa_pcm_format_t	format;   
- 
-  HWAVEOUT			  hWaveOut;
-  HANDLE			    callbackEvent;
-  CRITICAL_SECTION  waveCriticalSection;  
-  WAVEHDR*			  waveBlocks;  
-  volatile int		waveFreeBlockCount;
-  int				      waveCurrentBlock;
-};
-
-
-/** Forward definitions of audio api specific functions */
-int allocateBlocks(int size, int count, WAVEHDR** blocks);
-int freeBlocks(WAVEHDR* blocks);
-int openAudio(sa_stream_t *s);
-int closeAudio(sa_stream_t * s);
-int writeAudio(sa_stream_t *s, LPSTR data, int bytes);
-int getSAErrorCode(int waveErrorCode);
-
-void CALLBACK waveOutProc(HWAVEOUT hWaveOut, UINT uMsg, 
-    DWORD dwInstance, DWORD dwParam1, DWORD dwParam2);
-
-/** Normal way to open a PCM device */
-int sa_stream_create_pcm(sa_stream_t **s, 
-                         const char *client_name, 
-                         sa_mode_t mode, 
-                         sa_pcm_format_t format, 
-                         unsigned int rate, 
-                         unsigned int nchannels) {
-  sa_stream_t * _s = NULL;
-  
-  ERROR_IF_NO_INIT(s);
-  
-  *s = NULL;
-  
-  /* FIX ME: for formats different than PCM extend using WAVEFORMATEXTENSIBLE */
-  if (format != SA_PCM_FORMAT_S16_NE) {
-    return SA_ERROR_NOT_SUPPORTED;
-  }
-
-  if (mode != SA_MODE_WRONLY) {
-    return SA_ERROR_NOT_SUPPORTED;
-  }
-
-  if ((_s = (sa_stream_t*)malloc(sizeof(sa_stream_t))) == NULL) {
-    return SA_ERROR_OOM;
-  }
-   
-  _s->rwMode = mode;
-  _s->format = format;
-  _s->rate = rate;
-  _s->channels = nchannels;
-  _s->deviceName = DEFAULT_DEVICE_NAME;
-  _s->device = DEFAULT_DEVICE;
-
-  *s = _s; 
-  return SA_SUCCESS;
-}
-
-/** Initialise the device */
-int sa_stream_open(sa_stream_t *s) {  
-  int status = SA_SUCCESS;
-
-  ERROR_IF_NO_INIT(s);
-
-  switch (s->rwMode) {
-    case SA_MODE_WRONLY: 
-      status = openAudio(s);
-      break;
-	default:
-      status = SA_ERROR_NOT_SUPPORTED;      
-      break;
-  }    
-  return status;
-}
-
-/** Interleaved playback function */
-int sa_stream_write(sa_stream_t *s, const void *data, size_t nbytes) {
-  int status = SA_SUCCESS;
-
-  ERROR_IF_NO_INIT(s);
-
-  status = writeAudio(s, (LPSTR)data, nbytes);
-
-  return status;
-}
-
-/** Close/destroy everything */
-int sa_stream_destroy(sa_stream_t *s) {
-  int status;
-
-  ERROR_IF_NO_INIT(s);
-  /* close and release all allocated resources */
-  status = closeAudio(s);
-
-  return status;
-}
-
-#define LEFT_CHANNEL_MASK 0x0000FFFF
-#define RIGHT_CHANNEL_MASK 0xFFFF0000
-
-/** 
- * retrieved volume as an int in a scale from 0x0000 to 0xFFFF
- * only one value for all channels
- */
-int sa_stream_get_write_volume(sa_stream_t *s, int32_t vol[], unsigned int *n) {
-  int status;
-	DWORD volume;
-	WORD left;
-	WORD right;
-
-	ERROR_IF_NO_INIT(s);
-  
-	status = waveOutGetVolume(s->hWaveOut, &volume);
-	HANDLE_WAVE_ERROR(status, "reading audio volume level");
-
-	left = volume & LEFT_CHANNEL_MASK;
-	right = (volume & RIGHT_CHANNEL_MASK) >> 16;
-  vol[0] = (int32_t)(left + right /2);	
-
-	return SA_SUCCESS;
-
-}
-
-/** changes volume as an int in a scale from 0x0000 to 0xFFFF*/
-int sa_stream_change_write_volume(sa_stream_t *s, const int32_t vol[], unsigned int n) {
-  int status;
-	DWORD volume;
-	WORD left;
-	WORD right;
-	
-	ERROR_IF_NO_INIT(s);
-	
-  volume = (DWORD)vol[0];
-	left = volume & LEFT_CHANNEL_MASK;	  
-	right = left;	  
-	volume =  (left << 16) | right;	
-	
-	status = waveOutSetVolume(s->hWaveOut, volume);
-	HANDLE_WAVE_ERROR(status, "setting new audio volume level");	
-
-	return SA_SUCCESS;
-
-
-}
-
-/** sync/timing */
-int sa_stream_get_position(sa_stream_t *s, sa_position_t position, int64_t *pos) {
-	int status;
-  MMTIME  mm;
-
-  ERROR_IF_NO_INIT(s);
-
-  if (position != SA_POSITION_WRITE_HARDWARE) {
-    return SA_ERROR_NOT_SUPPORTED;
-  }
-  // request playback progress in bytes
-  mm.wType = TIME_BYTES;		
-	status = waveOutGetPosition(s->hWaveOut, &mm, sizeof(MMTIME));
-  HANDLE_WAVE_ERROR(status, "reading audio buffer position");
-  *pos = (int64_t)mm.u.cb;
-
-	return SA_SUCCESS;
-}
-
-/* Control/xrun */
-/** Resume playing after a pause */
-int sa_stream_resume(sa_stream_t *s) {
-  int status;  
-  
-  ERROR_IF_NO_INIT(s);
-
-  status = waveOutRestart(s->hWaveOut);
-  HANDLE_WAVE_ERROR(status, "resuming audio playback");
-
-  return SA_SUCCESS;
-}
-/** Pause audio playback (do not empty the buffer) */
-int sa_stream_pause(sa_stream_t *s) {
-  int status;
-
-  ERROR_IF_NO_INIT(s);
-  
-  status = waveOutPause(s->hWaveOut);
-  HANDLE_WAVE_ERROR(status, "resuming audio playback");
-
-  return SA_SUCCESS;
-}
-
-/*
- * -----------------------------------------------------------------------------
- * Private WAVE API specific functions
- * -----------------------------------------------------------------------------
- */
-
-/** 
- * \brief - allocate buffer for writing to system WAVE audio device
- * \param size - size of each audio block
- * \param cound - number of blocks to be allocated
- * \param blocks - pointer to the blocks buffer to be allocated
- * \return - completion status
- */
-int allocateBlocks(int size, int count, WAVEHDR** blocks)
-{
-  unsigned char* buffer;    
-  int i;    
-  WAVEHDR* headers;
-  DWORD totalBufferSize = (size + sizeof(WAVEHDR)) * count;
-    
-  /* allocate memory on heap for the entire set in one go  */    
-  if((buffer = HeapAlloc(
-     GetProcessHeap(), 
-     HEAP_ZERO_MEMORY, 
-     totalBufferSize
-     )) == NULL) {
-      printf("Memory allocation error\n");
-      return SA_ERROR_OOM;
-    }
-
-  /* and set up the pointers to each bit */
-  headers = *blocks = (WAVEHDR*)buffer;
-  buffer += sizeof(WAVEHDR) * count;
-  for(i = 0; i < count; i++) {    
-	  headers[i].dwBufferLength = size;
-    headers[i].lpData = buffer;
-    buffer += size;
-  }
-    
-  return SA_SUCCESS;
-}
-
-/**
- * \brief - free allocated audio buffer
- * \param blocks - pointer to allocated the buffer of audio bloks
- * \return - completion status
- */
-int freeBlocks(WAVEHDR* blocks)
-{    
-  if (blocks == NULL) 
-    return SA_ERROR_INVALID;
-
-  /* and this is why allocateBlocks works the way it does */     
-  HeapFree(GetProcessHeap(), 0, blocks);
-  blocks = NULL;
-
-  return SA_SUCCESS;
-}
-
-/** 
- * \brief - open system default WAVE device
- * \param s - sydney audio stream handle
- * \return - completion status
- */ 
-int openAudio(sa_stream_t *s) {
-  int status;
-  WAVEFORMATEX wfx;    
-  UINT supported = FALSE;
-		  
-  status = allocateBlocks(BLOCK_SIZE, BLOCK_COUNT, &(s->waveBlocks));  
-	HANDLE_WAVE_ERROR(status, "allocating audio buffer blocks");
-  
-  s->waveFreeBlockCount	= BLOCK_COUNT;
-  s->waveCurrentBlock	= 0;  
-  wfx.nSamplesPerSec	= (DWORD)s->rate;	/* sample rate */
-  wfx.wBitsPerSample	= 16;				/* sample size */
-  wfx.nChannels			= s->channels;	/* channels    */
-  wfx.cbSize			= 0;				/* size of _extra_ info */
-  wfx.wFormatTag		= WAVE_FORMAT_PCM;
-  wfx.nBlockAlign		= (wfx.wBitsPerSample * wfx.nChannels) >> 3;
-  wfx.nAvgBytesPerSec	= wfx.nBlockAlign * wfx.nSamplesPerSec;
-
-  supported = waveOutOpen(NULL, WAVE_MAPPER, &wfx, (DWORD_PTR)0, (DWORD_PTR)0, 
-				WAVE_FORMAT_QUERY);
-  if (supported == MMSYSERR_NOERROR) { // audio device opened sucessfully 
-    status = waveOutOpen((LPHWAVEOUT)&(s->hWaveOut), WAVE_MAPPER, &wfx, 
-	  (DWORD_PTR)waveOutProc, (DWORD_PTR)s, CALLBACK_FUNCTION);
-    HANDLE_WAVE_ERROR(status, "opening audio device for playback");
-		printf("Audio device sucessfully opened\n");
-  } 
-  else if (supported == WAVERR_BADFORMAT) {
-    printf("Requested format not supported...\n");
-	  // clean up the memory
-	  freeBlocks(s->waveBlocks);
-    return SA_ERROR_NOT_SUPPORTED;
-  } 
-  else {
-    printf("Error opening default audio device. Exiting...\n");
-	  // clean up the memory
-	  freeBlocks(s->waveBlocks);
-    return SA_ERROR_SYSTEM;
-  }
-  // create notification for data written to a device
-  s->callbackEvent = CreateEvent(0, FALSE, FALSE, 0);
-  // initialise critical section for operations on waveFreeBlockCound variable
-  InitializeCriticalSection(&(s->waveCriticalSection));
-
-  return SA_SUCCESS;
-}
-/**
- * \brief - closes opened audio device handle
- * \param s - sydney audio stream handle
- * \return - completion status
- */
-int closeAudio(sa_stream_t * s) {
-  int status, i;
-  
-  // reseting audio device and flushing buffers
-  status = waveOutReset(s->hWaveOut);    
-  HANDLE_WAVE_ERROR(status, "resetting audio device");
-  
-  /* wait for all blocks to complete */  
-  while(s->waveFreeBlockCount < BLOCK_COUNT)
-	  Sleep(10);
-
-  /* unprepare any blocks that are still prepared */  
-  for(i = 0; i < s->waveFreeBlockCount; i++) {
-    if(s->waveBlocks[i].dwFlags & WHDR_PREPARED) {
-	    status = waveOutUnprepareHeader(s->hWaveOut, &(s->waveBlocks[i]), sizeof(WAVEHDR));
-      HANDLE_WAVE_ERROR(status, "closing audio device");
-    }
-  }    
-
-  freeBlocks(s->waveBlocks);  
-  status = waveOutClose(s->hWaveOut);    
-  HANDLE_WAVE_ERROR(status, "closing audio device");
-
-  DeleteCriticalSection(&(s->waveCriticalSection));
-  CloseHandle(s->callbackEvent);
-  printf("[audio] audio resources cleanup completed\n");
-  
-  return SA_SUCCESS;
-}
-/**
- * \brief - writes PCM audio samples to audio device
- * \param s - valid handle to opened sydney stream
- * \param data - pointer to memory storing audio samples to be played
- * \param nsamples - number of samples in the memory pointed by previous parameter
- * \return - completion status
- */
-int writeAudio(sa_stream_t *s, LPSTR data, int bytes) {    
-  UINT status;
-  WAVEHDR* current;	  
-  int remain;
-
-  current = &(s->waveBlocks[s->waveCurrentBlock]);
-  
-  while(bytes > 0) {
-    /* first make sure the header we're going to use is unprepared */
-    if(current->dwFlags & WHDR_PREPARED) {      
-        status = waveOutUnprepareHeader(s->hWaveOut, current, sizeof(WAVEHDR));         
-        HANDLE_WAVE_ERROR(status, "preparing audio headers for writing");
-    }
-		  
-    if(bytes < (int)(BLOCK_SIZE - current->dwUser)) {							  	    
-		  memcpy(current->lpData + current->dwUser, data, bytes);
-      current->dwUser += bytes;
-      break;
-    }
-	
-    /* remain is even as BLOCK_SIZE and dwUser are even too */
-    remain = BLOCK_SIZE - current->dwUser;      
-  	memcpy(current->lpData + current->dwUser, data, remain);
-    bytes -= remain;
-    data += remain;
-	  current->dwBufferLength = BLOCK_SIZE;
-	  /* write to audio device */
-    waveOutPrepareHeader(s->hWaveOut, current, sizeof(WAVEHDR));
-	  status = waveOutWrite(s->hWaveOut, current, sizeof(WAVEHDR));      
-    HANDLE_WAVE_ERROR(status, "writing audio to audio device");
-      
-    EnterCriticalSection(&(s->waveCriticalSection));
-    s->waveFreeBlockCount--;
-    LeaveCriticalSection(&(s->waveCriticalSection));
-    /*
-     * wait for a block to become free
-     */
-    while (!(s->waveFreeBlockCount)) {
-        //printf("All audio buffer blocks empty\n");        
-      WaitForSingleObject(s->callbackEvent, INFINITE);
-        //Sleep(10);
-    }		  
-		
-    /*
-     * point to the next block
-     */
-    (s->waveCurrentBlock)++;
-    (s->waveCurrentBlock) %= BLOCK_COUNT;		
-
-    current = &(s->waveBlocks[s->waveCurrentBlock]);
-    current->dwUser = 0;
-  }
-  return SA_SUCCESS;
-}
-
-/**
- * \brief - audio callback function called when next WAVE header is played by audio device
- */
-void CALLBACK waveOutProc(
-    HWAVEOUT hWaveOut, 
-    UINT uMsg, 
-    DWORD dwInstance,  
-    DWORD dwParam1,    
-    DWORD dwParam2     
-)
-{
-    /*
-     * pointer to free block counter
-     */
-    sa_stream_t* handle = (sa_stream_t*)dwInstance;
-    /*
-     * ignore calls that occur due to openining and closing the
-     * device.
-     */
-    if(uMsg != WOM_DONE)
-        return;
-
-    EnterCriticalSection(&(handle->waveCriticalSection));
-    (handle->waveFreeBlockCount)++;
-    if ((handle->waveFreeBlockCount) == 1) 
-       SetEvent(handle->callbackEvent);
-    LeaveCriticalSection(&(handle->waveCriticalSection));	
-}
-
-/**
- * \brief - converts frequently reported WAVE error codes to Sydney audio API codes
- */
-int getSAErrorCode(int waveErrorCode) {
-  int error = SA_ERROR_NOT_SUPPORTED;
-
-  switch (waveErrorCode) {
-    case MMSYSERR_NOERROR: 
-      error = SA_SUCCESS;
-      break;
-    case MMSYSERR_ALLOCATED: 
-      error = SA_ERROR_SYSTEM;
-      break;
-    case MMSYSERR_BADDEVICEID:
-      error = SA_ERROR_INVALID;
-      break;
-    case MMSYSERR_NODRIVER:
-      error = SA_ERROR_NO_DRIVER;
-      break;
-    case MMSYSERR_NOTSUPPORTED:
-      error = SA_ERROR_NOT_SUPPORTED;
-      break;          
-    case MMSYSERR_NOMEM: 
-      error = SA_ERROR_OOM;
-      break;
-    case MMSYSERR_INVALHANDLE:
-      error = SA_ERROR_INVALID;
-      break;
-    case WAVERR_BADFORMAT: 
-      error = SA_ERROR_NOT_SUPPORTED;
-      break;
-    case WAVERR_SYNC: 
-      error = SA_ERROR_NOT_SUPPORTED;
-      break;    
-  }
-  return error;
-}
-
-
-/*
- * -----------------------------------------------------------------------------
- * Functions to be implemented next 
- * -----------------------------------------------------------------------------
- */
-
-#define NOT_IMPLEMENTED(func)   func { return SA_ERROR_NOT_SUPPORTED; }
-
-/* "Soft" params */
-NOT_IMPLEMENTED(int sa_stream_set_write_lower_watermark(sa_stream_t *s, size_t size))
-NOT_IMPLEMENTED(int sa_stream_set_read_lower_watermark(sa_stream_t *s, size_t size))
-NOT_IMPLEMENTED(int sa_stream_set_write_upper_watermark(sa_stream_t *s, size_t size))
-NOT_IMPLEMENTED(int sa_stream_set_read_upper_watermark(sa_stream_t *s, size_t size))
-
-/** Set the mapping between channels and the loudspeakers */
-NOT_IMPLEMENTED(int sa_stream_set_channel_map(sa_stream_t *s, const sa_channel_t map[], unsigned int n))
-
-/* Query functions */
-NOT_IMPLEMENTED(int sa_stream_get_mode(sa_stream_t *s, sa_mode_t *access_mode))
-NOT_IMPLEMENTED(int sa_stream_get_pcm_format(sa_stream_t *s, sa_pcm_format_t *format))
-NOT_IMPLEMENTED(int sa_stream_get_rate(sa_stream_t *s, unsigned int *rate))
-NOT_IMPLEMENTED(int sa_stream_get_nchannels(sa_stream_t *s, int *nchannels))
-NOT_IMPLEMENTED(int sa_stream_get_device(sa_stream_t *s, char *device_name, size_t *size))
-NOT_IMPLEMENTED(int sa_stream_get_write_lower_watermark(sa_stream_t *s, size_t *size))
-NOT_IMPLEMENTED(int sa_stream_get_read_lower_watermark(sa_stream_t *s, size_t *size))
-NOT_IMPLEMENTED(int sa_stream_get_write_upper_watermark(sa_stream_t *s, size_t *size))
-NOT_IMPLEMENTED(int sa_stream_get_read_upper_watermark(sa_stream_t *s, size_t *size))
-NOT_IMPLEMENTED(int sa_stream_get_channel_map(sa_stream_t *s, sa_channel_t map[], unsigned int *n))
-
-/*
- * -----------------------------------------------------------------------------
- * Unsupported functions
- * -----------------------------------------------------------------------------
- */
-#define UNSUPPORTED(func)   func { return SA_ERROR_NOT_SUPPORTED; }
-
-/** Create an opaque (e.g. AC3) codec stream */
-UNSUPPORTED(int sa_stream_create_opaque(sa_stream_t **s, const char *client_name, sa_mode_t mode, const char *codec))
-/** Whether xruns cause the card to reset */
-UNSUPPORTED(int sa_stream_set_xrun_mode(sa_stream_t *s, sa_xrun_mode_t mode))
-/** Set the device to non-interleaved mode */
-UNSUPPORTED(int sa_stream_set_non_interleaved(sa_stream_t *s, int enable))
-/** Require dynamic sample rate */
-UNSUPPORTED(int sa_stream_set_dynamic_rate(sa_stream_t *s, int enable))
-/** Select driver */
-UNSUPPORTED(int sa_stream_set_driver(sa_stream_t *s, const char *driver))
-/** Start callback */
-UNSUPPORTED(int sa_stream_start_thread(sa_stream_t *s, sa_event_callback_t callback))
-/** Stop callback */
-UNSUPPORTED(int sa_stream_stop_thread(sa_stream_t *s))
-/** Change the device connected to the stream */
-UNSUPPORTED(int sa_stream_change_device(sa_stream_t *s, const char *device_name))
-/** volume in hundreths of dB*/
-UNSUPPORTED(int sa_stream_change_read_volume(sa_stream_t *s, const int32_t vol[], unsigned int n))
-/** Change the sampling rate */
-UNSUPPORTED(int sa_stream_change_rate(sa_stream_t *s, unsigned int rate))
-/** Change some meta data that is attached to the stream */
-UNSUPPORTED(int sa_stream_change_meta_data(sa_stream_t *s, const char *name, const void *data, size_t size))
-/** Associate opaque user data */
-UNSUPPORTED(int sa_stream_change_user_data(sa_stream_t *s, const void *value))
-/* Hardware-related. This is implementation-specific and hardware specific. */
-UNSUPPORTED(int sa_stream_set_adjust_rate(sa_stream_t *s, sa_adjust_t direction))
-UNSUPPORTED(int sa_stream_set_adjust_nchannels(sa_stream_t *s, sa_adjust_t direction))
-UNSUPPORTED(int sa_stream_set_adjust_pcm_format(sa_stream_t *s, sa_adjust_t direction))
-UNSUPPORTED(int sa_stream_set_adjust_watermarks(sa_stream_t *s, sa_adjust_t direction))
-/* Query functions */
-UNSUPPORTED(int sa_stream_get_codec(sa_stream_t *s, char *codec, size_t *size))
-UNSUPPORTED(int sa_stream_get_user_data(sa_stream_t *s, void **value))
-
-UNSUPPORTED(int sa_stream_get_xrun_mode(sa_stream_t *s, sa_xrun_mode_t *mode))
-UNSUPPORTED(int sa_stream_get_non_interleaved(sa_stream_t *s, int *enabled))
-UNSUPPORTED(int sa_stream_get_dynamic_rate(sa_stream_t *s, int *enabled))
-UNSUPPORTED(int sa_stream_get_driver(sa_stream_t *s, char *driver_name, size_t *size))            
-UNSUPPORTED(int sa_stream_get_read_volume(sa_stream_t *s, int32_t vol[], unsigned int *n))
-UNSUPPORTED(int sa_stream_get_meta_data(sa_stream_t *s, const char *name, void*data, size_t *size))
-UNSUPPORTED(int sa_stream_get_adjust_rate(sa_stream_t *s, sa_adjust_t *direction))
-UNSUPPORTED(int sa_stream_get_adjust_nchannels(sa_stream_t *s, sa_adjust_t *direction))
-UNSUPPORTED(int sa_stream_get_adjust_pcm_format(sa_stream_t *s, sa_adjust_t *direction))
-UNSUPPORTED(int sa_stream_get_adjust_watermarks(sa_stream_t *s, sa_adjust_t *direction))
-/** Get current state of the audio device */
-UNSUPPORTED(int sa_stream_get_state(sa_stream_t *s, sa_state_t *state))
-/** Obtain the error code */
-UNSUPPORTED(int sa_stream_get_event_error(sa_stream_t *s, sa_error_t *error))
-/** Obtain the notification code */
-UNSUPPORTED(int sa_stream_get_event_notify(sa_stream_t *s, sa_notify_t *notify))
-
-/* Blocking IO calls */
-/** Interleaved capture function */
-UNSUPPORTED(int sa_stream_read(sa_stream_t *s, void *data, size_t nbytes))
-/** Non-interleaved capture function */
-UNSUPPORTED(int sa_stream_read_ni(sa_stream_t *s, unsigned int channel, void *data, size_t nbytes))
-
-/** Non-interleaved playback function */
-UNSUPPORTED(int sa_stream_write_ni(sa_stream_t *s, unsigned int channel, const void *data, size_t nbytes))
-/** Interleaved playback function with seek offset */
-UNSUPPORTED(int sa_stream_pwrite(sa_stream_t *s, const void *data, size_t nbytes, int64_t offset, sa_seek_t whence))
-/** Non-interleaved playback function with seek offset */
-UNSUPPORTED(int sa_stream_pwrite_ni(sa_stream_t *s, unsigned int channel, const void *data, size_t nbytes, int64_t offset, sa_seek_t whence))
-
-/** Query how much can be read without blocking */
-UNSUPPORTED(int sa_stream_get_read_size(sa_stream_t *s, size_t *size))
-/** Query how much can be written without blocking */
-UNSUPPORTED(int sa_stream_get_write_size(sa_stream_t *s, size_t *size))
-
-/** Block until all audio has been played */
-UNSUPPORTED(int sa_stream_drain(sa_stream_t *s))
-
-/** Return a human readable error */
-const char *sa_strerror(int code);
diff -r 4b060ed856e0 media/liboggplay_audio/update.sh
--- a/media/liboggplay_audio/update.sh	Tue Oct 14 17:12:28 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,5 +0,0 @@
-# Usage: ./update.sh <browser_plugin_src_directory>
-#
-# Copies the needed files from a directory containing the original
-# browser_plugin source that we need for the Mozilla HTML5 media support.
-cp $1/src/audio/* .
diff -r 4b060ed856e0 media/libsydneyaudio/AUTHORS
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/media/libsydneyaudio/AUTHORS	Thu Oct 16 21:24:49 2008 -0500
@@ -0,0 +1,34 @@
+Jean-Marc Valin (jmspeex) <jean-marc.valin@usherbrooke.ca>
+        - Design
+
+Lennart Poettering  <lennart@poettering.net>
+		- Design
+
+Shane Stephens (shans) <shans@annodex.net>
+        - First Implementation
+
+Chris Double (doublec) <chris.double@double.co.nz>
+		- ALSA support
+		- OSS support
+
+Brian Lu <brian.lu@sun.com>
+		- Sun Audio support
+
+Jeremy D. Lea (reg@openpave.org)
+		- OSS support
+
+Marcin Lubonski <marcin@it.uts.edu.au>
+        - Port to windows
+
+Michael Martin (tahn) <myk.martin@gmail.com>
+        - Port to Max OS X
+		- OSS support
+		- ALSA support
+
+Jan Gerber (j^) <j@oil21.org>
+		- Library creation
+
+Silvia Pfeiffer (ginger) <silvia@annodex.net>
+        - general maintenance
+
+
diff -r 4b060ed856e0 media/libsydneyaudio/Makefile.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/media/libsydneyaudio/Makefile.in	Thu Oct 16 21:24:49 2008 -0500
@@ -0,0 +1,51 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is Mozilla code.
+#
+# The Initial Developer of the Original Code is the Mozilla Corporation.
+# Portions created by the Initial Developer are Copyright (C) 2007
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#  Chris Double <chris.double@double.co.nz>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE		= sydneyaudio
+
+DIRS		= \
+		include \
+		src \
+		$(NULL)
+
+include $(topsrcdir)/config/rules.mk
diff -r 4b060ed856e0 media/libsydneyaudio/README_MOZILLA
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/media/libsydneyaudio/README_MOZILLA	Thu Oct 16 21:24:49 2008 -0500
@@ -0,0 +1,8 @@
+The source from this directory was copied from the libsydneyaudio svn
+source using the update.sh script. The only changes made were those
+applied by update.sh and the addition/upate of Makefile.in files for
+the Mozilla build system.
+
+http://svn.annodex.net/libsydneyaudio/trunk
+
+The svn revision number used was r3730. 
diff -r 4b060ed856e0 media/libsydneyaudio/include/Makefile.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/media/libsydneyaudio/include/Makefile.in	Thu Oct 16 21:24:49 2008 -0500
@@ -0,0 +1,50 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is Mozilla code.
+#
+# The Initial Developer of the Original Code is the Mozilla Corporation.
+# Portions created by the Initial Developer are Copyright (C) 2007
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#  Chris Double <chris.double@double.co.nz>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE		= sydneyaudio
+
+EXPORTS		= \
+		sydney_audio.h \
+		$(NULL)
+
+include $(topsrcdir)/config/rules.mk
diff -r 4b060ed856e0 media/libsydneyaudio/include/sydney_audio.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/media/libsydneyaudio/include/sydney_audio.h	Thu Oct 16 21:24:49 2008 -0500
@@ -0,0 +1,461 @@
+#ifndef foosydneyhfoo
+#define foosydneyhfoo
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Initial Developer of the Original Code is
+ * CSIRO
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** *
+ */
+
+/* Requirements:
+
+- In sync mode, the device will automatically write data so that an initial read causes writes
+of zeros to be issued to that one can do "while (1); {read(); write()}
+
+- All functions are thread-safe and can be called in any thread context. None of the functions is
+async-signal safe.
+  
+- It is assumed that duplex streams have a single clock (synchronised)
+*/
+
+#include <sys/types.h>
+#if !defined (WIN32)
+#include <sys/param.h>
+#include <inttypes.h>
+#if defined(__FreeBSD__)
+#include <sys/endian.h>
+#endif
+#else
+#include <stddef.h>
+#endif
+
+/* Detect byte order, based on sys/param.h */
+#undef SA_LITTLE_ENDIAN
+#undef SA_BIG_ENDIAN
+
+#if defined(__BYTE_ORDER)
+#   if __BYTE_ORDER == __LITTLE_ENDIAN
+#       define SA_LITTLE_ENDIAN 1
+#   elif __BYTE_ORDER == __BIG_ENDIAN
+#       define SA_BIG_ENDIAN 1
+#   endif
+#elif defined(_BYTE_ORDER)
+#   if _BYTE_ORDER == _LITTLE_ENDIAN
+#       define SA_LITTLE_ENDIAN 1
+#   elif _BYTE_ORDER == _BIG_ENDIAN
+#       define SA_BIG_ENDIAN 1
+#   endif
+#elif defined(WIN32)
+#   define SA_LITTLE_ENDIAN 1
+#elif defined(__APPLE__)
+#   if defined(__BIG_ENDIAN__)
+#       define SA_BIG_ENDIAN 1
+#   else
+#       define SA_LITTLE_ENDIAN 1
+#   endif
+#elif defined(SOLARIS)
+#   if defined(_BIG_ENDIAN)
+#       define SA_BIG_ENDIAN 1
+#   else
+#       define SA_LITTLE_ENDIAN 1
+#   endif
+#else
+#    error "Cannot determine byte order!"
+#endif
+
+#if defined(WIN32)
+#if !defined(int32_t)
+typedef __int32 int32_t;
+#endif
+#if !defined(int64_t)
+typedef __int64 int64_t;
+#endif
+#endif
+
+typedef struct sa_stream sa_stream_t;
+
+#if defined(WIN32)
+// (left << 16 | right) (16 bits per channel)
+#define SA_VOLUME_MUTED ((int32_t) (0x00000000))
+#else
+/** Volume that corresponds to muted in/out */
+#define SA_VOLUME_MUTED ((int32_t) (-0x80000000))
+#endif
+
+/** Ways to express seek offsets for pread/pwrite */
+typedef enum {
+    SA_SEEK_RELATIVE,
+    SA_SEEK_ABSOLUTE,
+    SA_SEEK_RELATIVE_END,
+    _SA_SEEK_MAX
+} sa_seek_t;
+
+/** Supported formats */
+typedef enum {
+    SA_PCM_FORMAT_U8,
+    SA_PCM_FORMAT_ULAW,
+    SA_PCM_FORMAT_ALAW,
+    SA_PCM_FORMAT_S16_LE,
+    SA_PCM_FORMAT_S16_BE,
+    SA_PCM_FORMAT_S24_LE,
+    SA_PCM_FORMAT_S24_BE,
+    SA_PCM_FORMAT_S32_LE,
+    SA_PCM_FORMAT_S32_BE,
+    SA_PCM_FORMAT_FLOAT32_LE,
+    SA_PCM_FORMAT_FLOAT32_BE,
+    _SA_PCM_FORMAT_MAX
+} sa_pcm_format_t;
+
+/* Native/reverse endianness definitions for PCM */
+#ifdef SA_LITTLE_ENDIAN
+#define SA_PCM_FORMAT_S16_NE SA_PCM_FORMAT_S16_LE
+#define SA_PCM_FORMAT_S24_NE SA_PCM_FORMAT_S24_LE
+#define SA_PCM_FORMAT_S32_NE SA_PCM_FORMAT_S32_LE
+#define SA_PCM_FORMAT_FLOAT32_NE SA_PCM_FORMAT_FLOAT32_LE
+#define SA_PCM_FORMAT_S16_RE SA_PCM_FORMAT_S16_BE
+#define SA_PCM_FORMAT_S24_RE SA_PCM_FORMAT_S24_BE
+#define SA_PCM_FORMAT_S32_RE SA_PCM_FORMAT_S32_BE
+#define SA_PCM_FORMAT_FLOAT32_RE SA_PCM_FORMAT_FLOAT32_BE
+#else
+#define SA_PCM_FORMAT_S16_NE SA_PCM_FORMAT_S16_BE
+#define SA_PCM_FORMAT_S24_NE SA_PCM_FORMAT_S24_BE
+#define SA_PCM_FORMAT_S32_NE SA_PCM_FORMAT_S32_BE
+#define SA_PCM_FORMAT_FLOAT32_NE SA_PCM_FORMAT_FLOAT32_BE
+#define SA_PCM_FORMAT_S16_RE SA_PCM_FORMAT_S16_LE
+#define SA_PCM_FORMAT_S24_RE SA_PCM_FORMAT_S24_LE
+#define SA_PCM_FORMAT_S32_RE SA_PCM_FORMAT_S32_LE
+#define SA_PCM_FORMAT_FLOAT32_RE SA_PCM_FORMAT_FLOAT32_LE
+#endif
+
+#define SA_CODEC_MPEG "mpeg"
+#define SA_CODEC_AC3 "ac3"
+#define SA_CODEC_GSM "gsm"
+#define SA_CODEC_VORBIS "vorbis"
+#define SA_CODEC_SPEEX "speex"
+
+/** Device opening modes */
+typedef enum {
+    SA_MODE_WRONLY = 1,
+    SA_MODE_RDONLY = 2,
+    SA_MODE_RDWR   = 3,
+    _SA_MODE_MAX   = 4
+} sa_mode_t;
+
+/** Error codes */
+typedef enum {
+    SA_SUCCESS = 0,
+    SA_ERROR_NOT_SUPPORTED = -1,
+    SA_ERROR_INVALID = -2,
+    SA_ERROR_STATE = -3,
+    SA_ERROR_OOM = -4,
+    SA_ERROR_NO_DEVICE = -5,
+    SA_ERROR_NO_DRIVER = -6,
+    SA_ERROR_NO_CODEC = -7,
+    SA_ERROR_NO_PCM_FORMAT = -7,
+    SA_ERROR_SYSTEM = -8,
+    SA_ERROR_NO_INIT = -9,
+    SA_ERROR_NO_META = -10,
+    SA_ERROR_NO_DATA = -11,
+    SA_ERROR_NO_SPACE = -12,
+    _SA_ERROR_MAX = -13
+} sa_error_t;
+
+/** Possible events for notifications */
+typedef enum {
+    SA_NOTIFY_REQUEST_START,
+    SA_NOTIFY_REQUEST_STOP,
+    SA_NOTIFY_CHANGED_READ_VOLUME,
+    SA_NOTIFY_CHANGED_WRITE_VOLUME,
+    SA_NOTIFY_CHANGED_DEVICE,
+    _SA_NOTIFY_MAX
+} sa_notify_t;
+
+/** Classes of events */
+typedef enum {
+    SA_EVENT_REQUEST_IO,
+    SA_EVENT_INIT_THREAD,
+    SA_EVENT_NOTIFY,
+    SA_EVENT_ERROR,
+    _SA_EVENT_MAX
+} sa_event_t;
+
+/** List of sample position queries */
+typedef enum {
+    SA_POSITION_WRITE_DELAY,
+    SA_POSITION_WRITE_HARDWARE,
+    SA_POSITION_WRITE_SOFTWARE,
+    SA_POSITION_READ_DELAY,
+    SA_POSITION_READ_HARDWARE,
+    SA_POSITION_READ_SOFTWARE,
+    SA_POSITION_DUPLEX_DELAY,
+    _SA_POSITION_MAX
+} sa_position_t;
+
+/* Channel positions */
+typedef enum {
+    SA_CHANNEL_MONO,
+    SA_CHANNEL_LEFT,
+    SA_CHANNEL_RIGHT,
+    SA_CHANNEL_CENTER,
+    SA_CHANNEL_FRONT_LEFT,
+    SA_CHANNEL_FRONT_RIGHT,
+    SA_CHANNEL_FRONT_CENTER,
+    SA_CHANNEL_REAR_LEFT,
+    SA_CHANNEL_REAR_RIGHT,
+    SA_CHANNEL_REAR_CENTER,
+    SA_CHANNEL_LFE,
+    SA_CHANNEL_FRONT_LEFT_OF_CENTER,
+    SA_CHANNEL_FRONT_RIGHT_OF_CENTER,
+    SA_CHANNEL_SIDE_LEFT,
+    SA_CHANNEL_SIDE_RIGHT,
+    SA_CHANNEL_TOP_CENTER,
+    SA_CHANNEL_TOP_FRONT_LEFT,
+    SA_CHANNEL_TOP_FRONT_RIGHT,
+    SA_CHANNEL_TOP_FRONT_CENTER,
+    SA_CHANNEL_TOP_REAR_LEFT,
+    SA_CHANNEL_TOP_REAR_RIGHT,
+    SA_CHANNEL_TOP_REAR_CENTER,
+    SA_CHANNEL_AUX0,
+    SA_CHANNEL_AUX1,
+    SA_CHANNEL_AUX2,
+    SA_CHANNEL_AUX3,
+    SA_CHANNEL_AUX4,
+    SA_CHANNEL_AUX5,
+    SA_CHANNEL_AUX6,
+    SA_CHANNEL_AUX7,
+    SA_CHANNEL_AUX8,
+    SA_CHANNEL_AUX9,
+    SA_CHANNEL_AUX10,
+    SA_CHANNEL_AUX11,
+    SA_CHANNEL_AUX12,
+    SA_CHANNEL_AUX13,
+    SA_CHANNEL_AUX14,
+    SA_CHANNEL_AUX15,
+    SA_CHANNEL_AUX16,
+    SA_CHANNEL_AUX17,
+    SA_CHANNEL_AUX18,
+    SA_CHANNEL_AUX19,
+    SA_CHANNEL_AUX20,
+    SA_CHANNEL_AUX21,
+    SA_CHANNEL_AUX22,
+    SA_CHANNEL_AUX23,
+    SA_CHANNEL_AUX24,
+    SA_CHANNEL_AUX25,
+    SA_CHANNEL_AUX26,
+    SA_CHANNEL_AUX27,
+    SA_CHANNEL_AUX28,
+    SA_CHANNEL_AUX29,
+    SA_CHANNEL_AUX30,
+    SA_CHANNEL_AUX31,
+    _SA_CHANNEL_MAX
+} sa_channel_t;
+
+typedef enum {
+    SA_STATE_INIT,
+    SA_STATE_RUNNING,
+    SA_STATE_STOPPED,
+    /* put more stuff */
+    _SA_STATE_MAX
+} sa_state_t;
+
+typedef enum {
+    SA_XRUN_MODE_STOP,
+    SA_XRUN_MODE_SPIN,
+    _SA_XRUN_MODE_MAX
+} sa_xrun_mode_t;
+
+typedef enum {
+    SA_ADJUST_UP = 1,
+    SA_ADJUST_DOWN = -1,
+    SA_ADJUST_NONE = 0
+} sa_adjust_t;
+
+/* Some kind of meta information.  */
+#define SA_META_CLIENT_NAME "sydney.client-name"     /* utf-8 */ 
+#define SA_META_PROCESS_ID "sydney.process-id"       /* getpid() */
+#define SA_META_LANGUAGE "sydney.language"           /* de_DE and similar */
+
+/* Some kind of meta information. Not filled in */
+#define SA_META_STREAM_NAME "sydney.stream-name"     /* utf-8 */ 
+#define SA_META_ICON_NAME "sydney.icon-name"         /* file name (no slashes) */
+#define SA_META_ICON_PNG "sydney.icon-png"           /* PNG blob */
+#define SA_META_ROLE "sydney.role"                   /* one of: "music", "phone", "game", "event" */
+#define SA_META_X11_DISPLAY "sydney.x11-display"     /* X11 display */
+#define SA_META_X11_WINDOW "sydney.x11-window"       /* X11 window id */
+
+/** Main callback function */
+typedef int (*sa_event_callback_t)(sa_stream_t *s, sa_event_t event);
+
+/** Create an opaque (e.g. AC3) codec stream */
+int sa_stream_create_opaque(sa_stream_t **s, const char *client_name, sa_mode_t mode, const char *codec);
+
+/** Normal way to open a PCM device */
+int sa_stream_create_pcm(sa_stream_t **s, const char *client_name, sa_mode_t mode, sa_pcm_format_t format, unsigned int rate, unsigned int nchannels);
+
+/** Initialise the device */
+int sa_stream_open(sa_stream_t *s);
+
+/** Close/destroy everything */
+int sa_stream_destroy(sa_stream_t *s);
+
+/* "Soft" params */
+int sa_stream_set_write_lower_watermark(sa_stream_t *s, size_t size);
+int sa_stream_set_read_lower_watermark(sa_stream_t *s, size_t size);
+int sa_stream_set_write_upper_watermark(sa_stream_t *s, size_t size);
+int sa_stream_set_read_upper_watermark(sa_stream_t *s, size_t size);
+
+/** Set the mapping between channels and the loudspeakers */
+int sa_stream_set_channel_map(sa_stream_t *s, const sa_channel_t map[], unsigned int n);
+
+/** Whether xruns cause the card to reset */
+int sa_stream_set_xrun_mode(sa_stream_t *s, sa_xrun_mode_t mode);
+
+/** Set the device to non-interleaved mode */
+int sa_stream_set_non_interleaved(sa_stream_t *s, int enable);
+
+/** Require dynamic sample rate */
+int sa_stream_set_dynamic_rate(sa_stream_t *s, int enable);
+
+/** Select driver */
+int sa_stream_set_driver(sa_stream_t *s, const char *driver);
+
+/** Start callback */
+int sa_stream_start_thread(sa_stream_t *s, sa_event_callback_t callback);
+
+/** Start callback */
+int sa_stream_stop_thread(sa_stream_t *s);
+
+/** Change the device connected to the stream */
+int sa_stream_change_device(sa_stream_t *s, const char *device_name);
+
+/** volume in hundreths of dB*/
+int sa_stream_change_read_volume(sa_stream_t *s, const int32_t vol[], unsigned int n);
+
+/** volume in hundreths of dB*/
+int sa_stream_change_write_volume(sa_stream_t *s, const int32_t vol[], unsigned int n);
+
+/** Change the sampling rate */
+int sa_stream_change_rate(sa_stream_t *s, unsigned int rate);
+
+/** Change some meta data that is attached to the stream */
+int sa_stream_change_meta_data(sa_stream_t *s, const char *name, const void *data, size_t size);
+
+/** Associate opaque user data */
+int sa_stream_change_user_data(sa_stream_t *s, const void *value);
+
+/* Hardware-related. This is implementation-specific and hardware specific. */
+int sa_stream_set_adjust_rate(sa_stream_t *s, sa_adjust_t direction);
+int sa_stream_set_adjust_nchannels(sa_stream_t *s, sa_adjust_t direction);
+int sa_stream_set_adjust_pcm_format(sa_stream_t *s, sa_adjust_t direction);
+int sa_stream_set_adjust_watermarks(sa_stream_t *s, sa_adjust_t direction);
+
+/* Query functions */
+
+int sa_stream_get_mode(sa_stream_t *s, sa_mode_t *access_mode);
+int sa_stream_get_codec(sa_stream_t *s, char *codec, size_t *size);
+int sa_stream_get_pcm_format(sa_stream_t *s, sa_pcm_format_t *format);
+int sa_stream_get_rate(sa_stream_t *s, unsigned int *rate);
+int sa_stream_get_nchannels(sa_stream_t *s, int *nchannels);
+int sa_stream_get_user_data(sa_stream_t *s, void **value);
+int sa_stream_get_write_lower_watermark(sa_stream_t *s, size_t *size);
+int sa_stream_get_read_lower_watermark(sa_stream_t *s, size_t *size);
+int sa_stream_get_write_upper_watermark(sa_stream_t *s, size_t *size);
+int sa_stream_get_read_upper_watermark(sa_stream_t *s, size_t *size);
+int sa_stream_get_channel_map(sa_stream_t *s, sa_channel_t map[], unsigned int *n);
+int sa_stream_get_xrun_mode(sa_stream_t *s, sa_xrun_mode_t *mode);
+int sa_stream_get_non_interleaved(sa_stream_t *s, int *enabled);
+int sa_stream_get_dynamic_rate(sa_stream_t *s, int *enabled);
+int sa_stream_get_driver(sa_stream_t *s, char *driver_name, size_t *size);
+int sa_stream_get_device(sa_stream_t *s, char *device_name, size_t *size);
+int sa_stream_get_read_volume(sa_stream_t *s, int32_t vol[], unsigned int *n);
+int sa_stream_get_write_volume(sa_stream_t *s, int32_t vol[], unsigned int *n);
+int sa_stream_get_meta_data(sa_stream_t *s, const char *name, void*data, size_t *size);
+int sa_stream_get_adjust_rate(sa_stream_t *s, sa_adjust_t *direction);
+int sa_stream_get_adjust_nchannels(sa_stream_t *s, sa_adjust_t *direction);
+int sa_stream_get_adjust_pcm_format(sa_stream_t *s, sa_adjust_t *direction);
+int sa_stream_get_adjust_watermarks(sa_stream_t *s, sa_adjust_t *direction);
+
+/** Get current state of the audio device */
+int sa_stream_get_state(sa_stream_t *s, sa_state_t *state);
+
+/** Obtain the error code */
+int sa_stream_get_event_error(sa_stream_t *s, sa_error_t *error);
+
+/** Obtain the notification code */
+int sa_stream_get_event_notify(sa_stream_t *s, sa_notify_t *notify);
+
+/** sync/timing */
+int sa_stream_get_position(sa_stream_t *s, sa_position_t position, int64_t *pos);
+
+
+/* Blocking IO calls */
+
+/** Interleaved capture function */
+int sa_stream_read(sa_stream_t *s, void *data, size_t nbytes);
+/** Non-interleaved capture function */
+int sa_stream_read_ni(sa_stream_t *s, unsigned int channel, void *data, size_t nbytes);
+
+/** Interleaved playback function */
+int sa_stream_write(sa_stream_t *s, const void *data, size_t nbytes);
+/** Non-interleaved playback function */
+int sa_stream_write_ni(sa_stream_t *s, unsigned int channel, const void *data, size_t nbytes);
+/** Interleaved playback function with seek offset */
+int sa_stream_pwrite(sa_stream_t *s, const void *data, size_t nbytes, int64_t offset, sa_seek_t whence);
+/** Non-interleaved playback function with seek offset */
+int sa_stream_pwrite_ni(sa_stream_t *s, unsigned int channel, const void *data, size_t nbytes, int64_t offset, sa_seek_t whence);
+
+
+/** Query how much can be read without blocking */
+int sa_stream_get_read_size(sa_stream_t *s, size_t *size);
+/** Query how much can be written without blocking */
+int sa_stream_get_write_size(sa_stream_t *s, size_t *size);
+
+
+/* Control/xrun */
+
+/** Resume playing after a pause */
+int sa_stream_resume(sa_stream_t *s);
+
+/** Pause audio playback (do not empty the buffer) */
+int sa_stream_pause(sa_stream_t *s);
+
+/** Block until all audio has been played */
+int sa_stream_drain(sa_stream_t *s);
+
+/** Return a human readable error */
+const char *sa_strerror(int code);
+
+/* Extensions */
+int
+sa_stream_set_volume_abs(sa_stream_t *s, float vol);
+
+int
+sa_stream_get_volume_abs(sa_stream_t *s, float *vol);
+
+#endif
diff -r 4b060ed856e0 media/libsydneyaudio/src/Makefile.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/media/libsydneyaudio/src/Makefile.in	Thu Oct 16 21:24:49 2008 -0500
@@ -0,0 +1,78 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is Mozilla code.
+#
+# The Initial Developer of the Original Code is the Mozilla Corporation.
+# Portions created by the Initial Developer are Copyright (C) 2007
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#  Chris Double <chris.double@double.co.nz>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE		= sydneyaudio
+LIBRARY_NAME	= sydneyaudio
+FORCE_STATIC_LIB= 1
+
+ifeq ($(OS_ARCH),Linux)
+CSRCS		= \
+		sydney_audio_alsa.c \
+		$(NULL)
+endif
+
+ifneq (,$(filter WINNT WINCE,$(OS_ARCH)))
+CSRCS		= \
+		sydney_audio_waveapi.c \
+		$(NULL)
+endif
+
+ifeq ($(OS_ARCH),Darwin)
+CSRCS		= \
+		sydney_audio_mac.c \
+		$(NULL)
+
+OS_LIBS += -framework CoreAudio -framework AudioToolbox -framework AudioUnit -framework Carbon
+endif
+
+ifeq ($(OS_ARCH),SunOS)
+CSRCS		= \
+		sydney_audio_sunaudio.c \
+		$(NULL)
+endif
+
+ifeq ($(OS_ARCH),WINNT)
+OS_LIBS += winmm.lib
+endif
+
+include $(topsrcdir)/config/rules.mk
diff -r 4b060ed856e0 media/libsydneyaudio/src/sydney_audio_alsa.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/media/libsydneyaudio/src/sydney_audio_alsa.c	Thu Oct 16 21:24:49 2008 -0500
@@ -0,0 +1,734 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Initial Developer of the Original Code is
+ * CSIRO
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s): Michael Martin
+ *                 Chris Double (chris.double@double.co.nz)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** *
+ */
+#include <stdlib.h>
+#include <pthread.h>
+#include <alsa/asoundlib.h>
+#include "sydney_audio.h"
+
+/* ALSA implementation based heavily on sydney_audio_mac.c */
+
+/*
+ * The audio interface is based on a "pull" I/O model, which means you
+ * can't just provide a data buffer and tell the audio device to play; you must
+ * register a callback and provide data as the device asks for it. To support
+ * sydney audio's "write-to-play" style interface, we have to buffer up the
+ * data as it arrives and feed it to the callback as required.
+ *
+ * This is handled by a simple linked list of buffers; data is always written
+ * to the tail and read from the head. Each buffer tracks the start and end
+ * positions of its contained data. Buffers are allocated when the tail buffer
+ * fills, and freed when the head buffer empties. There is always at least one
+ * buffer allocated.
+ *
+ *       s   e      s      e      s  e            + data read
+ *    +++#####  ->  ########  ->  ####----        # data written
+ *    ^                           ^               - empty
+ *    bl_head                     bl_tail
+ */
+
+typedef struct sa_buf sa_buf;
+struct sa_buf {
+  unsigned int      size;
+  unsigned int      start;
+  unsigned int      end;
+  sa_buf          * next;
+  unsigned char     data[0];
+};
+
+struct sa_stream {
+  snd_pcm_t*        output_unit;
+  pthread_t         thread_id;
+  pthread_mutex_t   mutex;
+  char              playing;
+  int64_t           bytes_played;
+
+  /* audio format info */
+  unsigned int      rate;
+  unsigned int      n_channels;
+  unsigned int      bytes_per_ch;
+
+  /* buffer list */
+  sa_buf          * bl_head;
+  sa_buf          * bl_tail;
+  int               n_bufs;
+};
+
+
+/*
+ * Use a default buffer size with enough room for one second of audio,
+ * assuming stereo data at 44.1kHz with 32 bits per channel, and impose
+ * a generous limit on the number of buffers.
+ */
+#define BUF_SIZE    (2 * 44100 * 4)
+#define BUF_LIMIT   5
+
+#if BUF_LIMIT < 2
+#error BUF_LIMIT must be at least 2!
+#endif
+
+static void audio_callback(void* s);
+static sa_buf *new_buffer(void);
+
+
+/*
+ * -----------------------------------------------------------------------------
+ * Startup and shutdown functions
+ * -----------------------------------------------------------------------------
+ */
+
+int
+sa_stream_create_pcm(
+  sa_stream_t      ** _s,
+  const char        * client_name,
+  sa_mode_t           mode,
+  sa_pcm_format_t     format,
+  unsigned  int       rate,
+  unsigned  int       n_channels
+) {
+  sa_stream_t   * s = 0;
+
+  /*
+   * Make sure we return a NULL stream pointer on failure.
+   */
+  if (_s == NULL) {
+    return SA_ERROR_INVALID;
+  }
+  *_s = NULL;
+
+  if (mode != SA_MODE_WRONLY) {
+    return SA_ERROR_NOT_SUPPORTED;
+  }
+  if (format != SA_PCM_FORMAT_S16_LE) {
+    return SA_ERROR_NOT_SUPPORTED;
+  }
+
+  /*
+   * Allocate the instance and required resources.
+   */
+  if ((s = malloc(sizeof(sa_stream_t))) == NULL) {
+    return SA_ERROR_OOM;
+  }
+  if ((s->bl_head = new_buffer()) == NULL) {
+    free(s);
+    return SA_ERROR_OOM;
+  }
+  if (pthread_mutex_init(&s->mutex, NULL) != 0) {
+    free(s->bl_head);
+    free(s);
+    return SA_ERROR_SYSTEM;
+  }
+
+  s->output_unit  = NULL;
+  s->thread_id    = 0;
+  s->playing      = 0;
+  s->bytes_played = 0;
+  s->rate         = rate;
+  s->n_channels   = n_channels;
+  s->bytes_per_ch = 2;
+  s->bl_tail      = s->bl_head;
+  s->n_bufs       = 1;
+
+  *_s = s;
+  return SA_SUCCESS;
+}
+
+
+int
+sa_stream_open(sa_stream_t *s) {
+
+  if (s == NULL) {
+    return SA_ERROR_NO_INIT;
+  }
+  if (s->output_unit != NULL) {
+    return SA_ERROR_INVALID;
+  }
+
+  if (snd_pcm_open(&s->output_unit, 
+                   "default", 
+                   SND_PCM_STREAM_PLAYBACK, 
+                   0) < 0) {
+    return SA_ERROR_NO_DEVICE;
+  }
+  
+  if (snd_pcm_set_params(s->output_unit,
+                         SND_PCM_FORMAT_S16_LE,
+                         SND_PCM_ACCESS_RW_INTERLEAVED,
+                         s->n_channels,
+                         s->rate,
+                         1,
+                         0) < 0) {
+    snd_pcm_close(s->output_unit);
+    s->output_unit = NULL;
+    return SA_ERROR_NOT_SUPPORTED;
+  }
+
+  return SA_SUCCESS;
+}
+
+
+int
+sa_stream_destroy(sa_stream_t *s) {
+  int result = SA_SUCCESS;
+
+  if (s == NULL) {
+    return SA_SUCCESS;
+  }
+
+  pthread_mutex_lock(&s->mutex);
+
+  /*
+   * This causes the thread sending data to ALSA to stop
+   */
+  s->thread_id = 0;
+
+  /*
+   * Shut down the audio output device.
+   */
+  if (s->output_unit != NULL) {
+    if (s->playing && snd_pcm_close(s->output_unit) < 0) {
+      result = SA_ERROR_SYSTEM;
+    }
+  }
+
+  pthread_mutex_unlock(&s->mutex);
+
+  /*
+   * Release resources.
+   */
+  if (pthread_mutex_destroy(&s->mutex) != 0) {
+    result = SA_ERROR_SYSTEM;
+  }
+  while (s->bl_head != NULL) {
+    sa_buf  * next = s->bl_head->next;
+    free(s->bl_head);
+    s->bl_head = next;
+  }
+  free(s);
+
+  return result;
+}
+
+
+
+/*
+ * -----------------------------------------------------------------------------
+ * Data read and write functions
+ * -----------------------------------------------------------------------------
+ */
+
+int
+sa_stream_write(sa_stream_t *s, const void *data, size_t nbytes) {
+  int result = SA_SUCCESS;
+
+  if (s == NULL || s->output_unit == NULL) {
+    return SA_ERROR_NO_INIT;
+  }
+  if (nbytes == 0) {
+    return SA_SUCCESS;
+  }
+
+  pthread_mutex_lock(&s->mutex);
+
+  /*
+   * Append the new data to the end of our buffer list.
+   */
+  while (1) {
+    unsigned int avail = s->bl_tail->size - s->bl_tail->end;
+
+    if (nbytes <= avail) {
+
+      /*
+       * The new data will fit into the current tail buffer, so
+       * just copy it in and we're done.
+       */
+      memcpy(s->bl_tail->data + s->bl_tail->end, data, nbytes);
+      s->bl_tail->end += nbytes;
+      break;
+
+    } else {
+
+      /*
+       * Copy what we can into the tail and allocate a new buffer
+       * for the rest.
+       */
+      memcpy(s->bl_tail->data + s->bl_tail->end, data, avail);
+      s->bl_tail->end += avail;
+      data = ((unsigned char *)data) + avail;
+      nbytes -= avail;
+
+      /* 
+       * If we still have data left to copy but we've hit the limit of
+       * allowable buffer allocations, we need to spin for a bit to allow
+       * the audio callback function to slurp some more data up.
+       */
+      if (nbytes > 0 && s->n_bufs == BUF_LIMIT) {
+#ifdef TIMING_TRACE
+        printf("#");  /* too much audio data */
+#endif
+        if (!s->playing) {
+          /*
+           * We haven't even started playing yet! That means the
+           * BUF_SIZE/BUF_LIMIT values are too low... Not much we can
+           * do here; spinning won't help because the audio callback
+           * hasn't been enabled yet. Oh well, error time.
+           */
+          printf("Too much audio data received before audio device enabled!\n");
+          result = SA_ERROR_SYSTEM;
+          break;
+        }
+        while (s->n_bufs == BUF_LIMIT) {
+          struct timespec ts = {0, 1000000};
+          pthread_mutex_unlock(&s->mutex);
+          nanosleep(&ts, NULL);
+          pthread_mutex_lock(&s->mutex);
+        }
+      }
+
+      /* 
+       * Allocate a new tail buffer, and go 'round again to fill it up.
+       */
+      if ((s->bl_tail->next = new_buffer()) == NULL) {
+        result = SA_ERROR_OOM;
+        break;
+      }
+      s->n_bufs++;
+      s->bl_tail = s->bl_tail->next;
+    
+    } /* if (nbytes <= avail), else */
+
+  } /* while (1) */
+
+  pthread_mutex_unlock(&s->mutex);
+
+  /*
+   * Once we have our first block of audio data, enable the audio callback
+   * function. This doesn't need to be protected by the mutex, because
+   * s->playing is not used in the audio callback thread, and it's probably
+   * better not to be inside the lock when we enable the audio callback.
+   */
+  if (!s->playing) {
+    s->playing = 1;
+    if (pthread_create(&s->thread_id, NULL, (void *)audio_callback, s) != 0) {
+      result = SA_ERROR_SYSTEM;
+    }
+  }
+
+  return result;
+}
+
+
+static void audio_callback(void* data)
+{
+  sa_stream_t* s = (sa_stream_t*)data;
+  snd_pcm_uframes_t buffer_size;
+  snd_pcm_uframes_t period_size;
+  unsigned int bytes_per_frame = s->n_channels * s->bytes_per_ch;
+  char* buffer = 0;
+
+#ifdef TIMING_TRACE
+  printf(".");  /* audio read 'tick' */
+#endif
+
+  snd_pcm_get_params(s->output_unit, &buffer_size, &period_size);
+ 
+  buffer = malloc(period_size * bytes_per_frame);
+ 
+  while(1) {
+    char* dst = buffer;
+    unsigned int bytes_to_copy   = period_size * bytes_per_frame;
+    snd_pcm_sframes_t frames;
+
+    pthread_mutex_lock(&s->mutex);
+    if (!s->thread_id)
+      break;
+
+    /*
+     * Consume data from the start of the buffer list.
+     */
+    while (1) {
+      unsigned int avail = s->bl_head->end - s->bl_head->start;
+      assert(s->bl_head->start <= s->bl_head->end);
+
+      if (avail >= bytes_to_copy) {
+        /*
+         * We have all we need in the head buffer, so just grab it and go.
+         */
+        memcpy(dst, s->bl_head->data + s->bl_head->start, bytes_to_copy);
+        s->bl_head->start += bytes_to_copy;
+        s->bytes_played += bytes_to_copy;
+        break;
+    
+      } else {
+        sa_buf* next = 0;
+        /*
+         * Copy what we can from the head and move on to the next buffer.
+         */
+        memcpy(dst, s->bl_head->data + s->bl_head->start, avail);
+        s->bl_head->start += avail;
+        dst += avail;
+        bytes_to_copy -= avail;
+        s->bytes_played += avail;
+
+        /*
+         * We want to free the now-empty buffer, but not if it's also the
+         * current tail. If it is the tail, we don't have enough data to fill
+         * the destination buffer, so we'll just zero it out and give up.
+         */
+        next = s->bl_head->next;
+        if (next == NULL) {
+#ifdef TIMING_TRACE
+          printf("!");  /* not enough audio data */
+#endif
+          memset(dst, 0, bytes_to_copy);
+          break;
+        }
+        free(s->bl_head);
+        s->bl_head = next;
+        s->n_bufs--;
+    
+      } /* if (avail >= bytes_to_copy), else */
+      
+    } /* while (1) */
+    
+    pthread_mutex_unlock(&s->mutex);
+    
+    frames = snd_pcm_writei(s->output_unit, buffer, period_size);
+    if (frames < 0) {
+      frames = snd_pcm_recover(s->output_unit, frames, 1);
+      if (frames < 0) {
+        printf("snc_pcm_recover error: %s\n", snd_strerror(frames));
+      }
+      if(frames > 0 && frames < period_size)
+        printf("short write (expected %d, wrote %d)\n", (int)period_size, (int)frames);;
+    }
+  }
+  free(buffer);
+}
+
+
+
+/*
+ * -----------------------------------------------------------------------------
+ * General query and support functions
+ * -----------------------------------------------------------------------------
+ */
+
+int
+sa_stream_get_write_size(sa_stream_t *s, size_t *size) {
+  sa_buf  * b;
+  size_t    used = 0;
+
+  if (s == NULL || s->output_unit == NULL) {
+    return SA_ERROR_NO_INIT;
+  }
+
+  pthread_mutex_lock(&s->mutex);
+
+  /*
+   * The sum of the free space in the tail buffer plus the size of any new
+   * buffers represents the write space available before blocking.
+   */
+  unsigned int avail = s->bl_tail->size - s->bl_tail->end;
+  avail += (BUF_LIMIT - s->n_bufs) * BUF_SIZE;
+  *size = avail;
+
+  pthread_mutex_unlock(&s->mutex);
+  return SA_SUCCESS;
+}
+
+
+int
+sa_stream_get_position(sa_stream_t *s, sa_position_t position, int64_t *pos) {
+
+  if (s == NULL || s->output_unit == NULL) {
+    return SA_ERROR_NO_INIT;
+  }
+  if (position != SA_POSITION_WRITE_SOFTWARE) {
+    return SA_ERROR_NOT_SUPPORTED;
+  }
+
+  pthread_mutex_lock(&s->mutex);
+  *pos = s->bytes_played;
+  pthread_mutex_unlock(&s->mutex);
+  return SA_SUCCESS;
+}
+
+
+int
+sa_stream_pause(sa_stream_t *s) {
+
+  if (s == NULL || s->output_unit == NULL) {
+    return SA_ERROR_NO_INIT;
+  }
+
+  pthread_mutex_lock(&s->mutex);
+#if 0 /* TODO */
+  AudioOutputUnitStop(s->output_unit);
+#endif
+  pthread_mutex_unlock(&s->mutex);
+  return SA_SUCCESS;
+}
+
+
+int
+sa_stream_resume(sa_stream_t *s) {
+
+  if (s == NULL || s->output_unit == NULL) {
+    return SA_ERROR_NO_INIT;
+  }
+
+  pthread_mutex_lock(&s->mutex);
+
+  /*
+   * The audio device resets its mSampleTime counter after pausing,
+   * so we need to clear our tracking value to keep that in sync.
+   */
+  s->bytes_played = 0;
+#if 0 /* TODO */
+  AudioOutputUnitStart(s->output_unit);
+#endif
+  pthread_mutex_unlock(&s->mutex);
+  return SA_SUCCESS;
+}
+
+
+static sa_buf *
+new_buffer(void) {
+  sa_buf  * b = malloc(sizeof(sa_buf) + BUF_SIZE);
+  if (b != NULL) {
+    b->size  = BUF_SIZE;
+    b->start = 0;
+    b->end   = 0;
+    b->next  = NULL;
+  }
+  return b;
+}
+
+
+int
+sa_stream_drain(sa_stream_t *s)
+{
+  if (s == NULL || s->output_unit == NULL) {
+    return SA_ERROR_NO_INIT;
+  }
+
+  while (1) {
+    pthread_mutex_lock(&s->mutex);
+    sa_buf  * b;
+    size_t    used = 0;
+    for (b = s->bl_head; b != NULL; b = b->next) {
+      used += b->end - b->start;
+    }
+    pthread_mutex_unlock(&s->mutex);
+
+    if (used == 0) {
+      break;
+    }
+
+    struct timespec ts = {0, 1000000};
+    nanosleep(&ts, NULL);
+  }
+  return SA_SUCCESS;
+}
+
+
+
+/*
+ * -----------------------------------------------------------------------------
+ * Extension functions
+ * -----------------------------------------------------------------------------
+ */
+
+int
+sa_stream_set_volume_abs(sa_stream_t *s, float vol) {
+  snd_mixer_t* mixer = 0;
+  snd_mixer_elem_t* elem = 0;
+  if (s == NULL || s->output_unit == NULL) {
+    return SA_ERROR_NO_INIT;
+  }
+
+  if (snd_mixer_open(&mixer, 0) < 0) {
+    return SA_ERROR_SYSTEM;
+  }
+
+  if (snd_mixer_attach(mixer, "default") < 0) {
+    snd_mixer_close(mixer);
+    return SA_ERROR_SYSTEM;
+  }
+
+  if (snd_mixer_selem_register(mixer, NULL, NULL) < 0) {
+    snd_mixer_close(mixer);
+    return SA_ERROR_SYSTEM;
+  }
+
+  if (snd_mixer_load(mixer) < 0) {
+    snd_mixer_close(mixer);
+    return SA_ERROR_SYSTEM;
+  }
+
+#if 0
+  snd_mixer_elem_t* elem = 0;
+  for (elem = snd_mixer_first_elem(mixer); elem != NULL; elem = snd_mixer_elem_next(elem)) {
+    if (snd_mixer_selem_has_playback_volume(elem)) {
+      printf("Playback %s\n", snd_mixer_selem_get_name(elem));
+    }
+    else {
+      printf("No Playback: %s\n", snd_mixer_selem_get_name(elem));
+    }
+  }
+#endif
+  elem = snd_mixer_first_elem(mixer);
+  if (elem && snd_mixer_selem_has_playback_volume(elem)) {
+    long min = 0;
+    long max = 0;
+    if (snd_mixer_selem_get_playback_volume_range(elem, &min, &max) >= 0) {
+      snd_mixer_selem_set_playback_volume_all(elem, (max-min)*vol + min);
+    } 
+  }
+  snd_mixer_close(mixer);
+
+  return SA_SUCCESS;
+}
+
+
+int
+sa_stream_get_volume_abs(sa_stream_t *s, float *vol) {
+  snd_mixer_t* mixer = 0;
+  snd_mixer_elem_t* elem = 0;
+  long value = 0;
+
+  if (s == NULL || s->output_unit == NULL) {
+    return SA_ERROR_NO_INIT;
+  }
+
+  if (snd_mixer_open(&mixer, 0) < 0) {
+    return SA_ERROR_SYSTEM;
+  }
+
+  if (snd_mixer_attach(mixer, "default") < 0) {
+    snd_mixer_close(mixer);
+    return SA_ERROR_SYSTEM;
+  }
+
+  if (snd_mixer_selem_register(mixer, NULL, NULL) < 0) {
+    snd_mixer_close(mixer);
+    return SA_ERROR_SYSTEM;
+  }
+
+  if (snd_mixer_load(mixer) < 0) {
+    snd_mixer_close(mixer);
+    return SA_ERROR_SYSTEM;
+  }
+
+  elem = snd_mixer_first_elem(mixer);
+  if (elem && snd_mixer_selem_get_playback_volume(elem, 0, &value) >= 0) {
+    long min = 0;
+    long max = 0;
+    if (snd_mixer_selem_get_playback_volume_range(elem, &min, &max) >= 0) {
+      *vol = (float)(value-min)/(float)(max-min);
+    } 
+  }
+  snd_mixer_close(mixer);
+
+  return SA_SUCCESS;
+}
+
+
+
+/*
+ * -----------------------------------------------------------------------------
+ * Unsupported functions
+ * -----------------------------------------------------------------------------
+ */
+#define UNSUPPORTED(func)   func { return SA_ERROR_NOT_SUPPORTED; }
+
+UNSUPPORTED(int sa_stream_create_opaque(sa_stream_t **s, const char *client_name, sa_mode_t mode, const char *codec))
+UNSUPPORTED(int sa_stream_set_write_lower_watermark(sa_stream_t *s, size_t size))
+UNSUPPORTED(int sa_stream_set_read_lower_watermark(sa_stream_t *s, size_t size))
+UNSUPPORTED(int sa_stream_set_write_upper_watermark(sa_stream_t *s, size_t size))
+UNSUPPORTED(int sa_stream_set_read_upper_watermark(sa_stream_t *s, size_t size))
+UNSUPPORTED(int sa_stream_set_channel_map(sa_stream_t *s, const sa_channel_t map[], unsigned int n))
+UNSUPPORTED(int sa_stream_set_xrun_mode(sa_stream_t *s, sa_xrun_mode_t mode))
+UNSUPPORTED(int sa_stream_set_non_interleaved(sa_stream_t *s, int enable))
+UNSUPPORTED(int sa_stream_set_dynamic_rate(sa_stream_t *s, int enable))
+UNSUPPORTED(int sa_stream_set_driver(sa_stream_t *s, const char *driver))
+UNSUPPORTED(int sa_stream_start_thread(sa_stream_t *s, sa_event_callback_t callback))
+UNSUPPORTED(int sa_stream_stop_thread(sa_stream_t *s))
+UNSUPPORTED(int sa_stream_change_device(sa_stream_t *s, const char *device_name))
+UNSUPPORTED(int sa_stream_change_read_volume(sa_stream_t *s, const int32_t vol[], unsigned int n))
+UNSUPPORTED(int sa_stream_change_write_volume(sa_stream_t *s, const int32_t vol[], unsigned int n))
+UNSUPPORTED(int sa_stream_change_rate(sa_stream_t *s, unsigned int rate))
+UNSUPPORTED(int sa_stream_change_meta_data(sa_stream_t *s, const char *name, const void *data, size_t size))
+UNSUPPORTED(int sa_stream_change_user_data(sa_stream_t *s, const void *value))
+UNSUPPORTED(int sa_stream_set_adjust_rate(sa_stream_t *s, sa_adjust_t direction))
+UNSUPPORTED(int sa_stream_set_adjust_nchannels(sa_stream_t *s, sa_adjust_t direction))
+UNSUPPORTED(int sa_stream_set_adjust_pcm_format(sa_stream_t *s, sa_adjust_t direction))
+UNSUPPORTED(int sa_stream_set_adjust_watermarks(sa_stream_t *s, sa_adjust_t direction))
+UNSUPPORTED(int sa_stream_get_mode(sa_stream_t *s, sa_mode_t *access_mode))
+UNSUPPORTED(int sa_stream_get_codec(sa_stream_t *s, char *codec, size_t *size))
+UNSUPPORTED(int sa_stream_get_pcm_format(sa_stream_t *s, sa_pcm_format_t *format))
+UNSUPPORTED(int sa_stream_get_rate(sa_stream_t *s, unsigned int *rate))
+UNSUPPORTED(int sa_stream_get_nchannels(sa_stream_t *s, int *nchannels))
+UNSUPPORTED(int sa_stream_get_user_data(sa_stream_t *s, void **value))
+UNSUPPORTED(int sa_stream_get_write_lower_watermark(sa_stream_t *s, size_t *size))
+UNSUPPORTED(int sa_stream_get_read_lower_watermark(sa_stream_t *s, size_t *size))
+UNSUPPORTED(int sa_stream_get_write_upper_watermark(sa_stream_t *s, size_t *size))
+UNSUPPORTED(int sa_stream_get_read_upper_watermark(sa_stream_t *s, size_t *size))
+UNSUPPORTED(int sa_stream_get_channel_map(sa_stream_t *s, sa_channel_t map[], unsigned int *n))
+UNSUPPORTED(int sa_stream_get_xrun_mode(sa_stream_t *s, sa_xrun_mode_t *mode))
+UNSUPPORTED(int sa_stream_get_non_interleaved(sa_stream_t *s, int *enabled))
+UNSUPPORTED(int sa_stream_get_dynamic_rate(sa_stream_t *s, int *enabled))
+UNSUPPORTED(int sa_stream_get_driver(sa_stream_t *s, char *driver_name, size_t *size))
+UNSUPPORTED(int sa_stream_get_device(sa_stream_t *s, char *device_name, size_t *size))
+UNSUPPORTED(int sa_stream_get_read_volume(sa_stream_t *s, int32_t vol[], unsigned int *n))
+UNSUPPORTED(int sa_stream_get_write_volume(sa_stream_t *s, int32_t vol[], unsigned int *n))
+UNSUPPORTED(int sa_stream_get_meta_data(sa_stream_t *s, const char *name, void*data, size_t *size))
+UNSUPPORTED(int sa_stream_get_adjust_rate(sa_stream_t *s, sa_adjust_t *direction))
+UNSUPPORTED(int sa_stream_get_adjust_nchannels(sa_stream_t *s, sa_adjust_t *direction))
+UNSUPPORTED(int sa_stream_get_adjust_pcm_format(sa_stream_t *s, sa_adjust_t *direction))
+UNSUPPORTED(int sa_stream_get_adjust_watermarks(sa_stream_t *s, sa_adjust_t *direction))
+UNSUPPORTED(int sa_stream_get_state(sa_stream_t *s, sa_state_t *state))
+UNSUPPORTED(int sa_stream_get_event_error(sa_stream_t *s, sa_error_t *error))
+UNSUPPORTED(int sa_stream_get_event_notify(sa_stream_t *s, sa_notify_t *notify))
+UNSUPPORTED(int sa_stream_read(sa_stream_t *s, void *data, size_t nbytes))
+UNSUPPORTED(int sa_stream_read_ni(sa_stream_t *s, unsigned int channel, void *data, size_t nbytes))
+UNSUPPORTED(int sa_stream_write_ni(sa_stream_t *s, unsigned int channel, const void *data, size_t nbytes))
+UNSUPPORTED(int sa_stream_pwrite(sa_stream_t *s, const void *data, size_t nbytes, int64_t offset, sa_seek_t whence))
+UNSUPPORTED(int sa_stream_pwrite_ni(sa_stream_t *s, unsigned int channel, const void *data, size_t nbytes, int64_t offset, sa_seek_t whence))
+UNSUPPORTED(int sa_stream_get_read_size(sa_stream_t *s, size_t *size))
+
+const char *sa_strerror(int code) { return NULL; }
+
diff -r 4b060ed856e0 media/libsydneyaudio/src/sydney_audio_mac.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/media/libsydneyaudio/src/sydney_audio_mac.c	Thu Oct 16 21:24:49 2008 -0500
@@ -0,0 +1,720 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Initial Developer of the Original Code is
+ * CSIRO
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s): Michael Martin
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** *
+ */
+
+#include <pthread.h>
+#include <AudioUnit/AudioUnit.h>
+#include "sydney_audio.h"
+
+/*
+ * The Mac's audio interface is based on a "pull" I/O model, which means you
+ * can't just provide a data buffer and tell the audio device to play; you must
+ * register a callback and provide data as the device asks for it. To support
+ * sydney audio's "write-to-play" style interface, we have to buffer up the
+ * data as it arrives and feed it to the callback as required.
+ *
+ * This is handled by a simple linked list of buffers; data is always written
+ * to the tail and read from the head. Each buffer tracks the start and end
+ * positions of its contained data. Buffers are allocated when the tail buffer
+ * fills, and freed when the head buffer empties. There is always at least one
+ * buffer allocated.
+ *
+ *       s   e      s      e      s  e            + data read
+ *    +++#####  ->  ########  ->  ####----        # data written
+ *    ^                           ^               - empty
+ *    bl_head                     bl_tail
+ */
+
+typedef struct sa_buf sa_buf;
+struct sa_buf {
+  unsigned int      size;
+  unsigned int      start;
+  unsigned int      end;
+  sa_buf          * next;
+  unsigned char     data[0];
+};
+
+struct sa_stream {
+  AudioUnit         output_unit;
+  pthread_mutex_t   mutex;
+  bool              playing;
+  int64_t           bytes_played;
+
+  /* audio format info */
+  unsigned int      rate;
+  unsigned int      n_channels;
+  unsigned int      bytes_per_ch;
+
+  /* buffer list */
+  sa_buf          * bl_head;
+  sa_buf          * bl_tail;
+  int               n_bufs;
+};
+
+
+/*
+ * Use a default buffer size with enough room for one second of audio,
+ * assuming stereo data at 44.1kHz with 32 bits per channel, and impose
+ * a generous limit on the number of buffers.
+ */
+#define BUF_SIZE    (2 * 44100 * 4)
+#define BUF_LIMIT   5
+
+#if BUF_LIMIT < 2
+#error BUF_LIMIT must be at least 2!
+#endif
+
+
+static OSStatus audio_callback(void *arg, AudioUnitRenderActionFlags *action_flags,
+  const AudioTimeStamp *time_stamp, UInt32 bus_num, UInt32 n_frames, AudioBufferList *data);
+
+static sa_buf *new_buffer(void);
+
+
+/*
+ * -----------------------------------------------------------------------------
+ * Startup and shutdown functions
+ * -----------------------------------------------------------------------------
+ */
+
+int
+sa_stream_create_pcm(
+  sa_stream_t      ** _s,
+  const char        * client_name,
+  sa_mode_t           mode,
+  sa_pcm_format_t     format,
+  unsigned  int       rate,
+  unsigned  int       n_channels
+) {
+
+  /*
+   * Make sure we return a NULL stream pointer on failure.
+   */
+  if (_s == NULL) {
+    return SA_ERROR_INVALID;
+  }
+  *_s = NULL;
+
+  if (mode != SA_MODE_WRONLY) {
+    return SA_ERROR_NOT_SUPPORTED;
+  }
+  if (format != SA_PCM_FORMAT_S16_LE) {
+    return SA_ERROR_NOT_SUPPORTED;
+  }
+
+  /*
+   * Allocate the instance and required resources.
+   */
+  sa_stream_t   * s;
+  if ((s = malloc(sizeof(sa_stream_t))) == NULL) {
+    return SA_ERROR_OOM;
+  }
+  if ((s->bl_head = new_buffer()) == NULL) {
+    free(s);
+    return SA_ERROR_OOM;
+  }
+  if (pthread_mutex_init(&s->mutex, NULL) != 0) {
+    free(s->bl_head);
+    free(s);
+    return SA_ERROR_SYSTEM;
+  }
+
+  s->output_unit  = NULL;
+  s->playing      = FALSE;
+  s->bytes_played = 0;
+  s->rate         = rate;
+  s->n_channels   = n_channels;
+  s->bytes_per_ch = 2;
+  s->bl_tail      = s->bl_head;
+  s->n_bufs       = 1;
+
+  *_s = s;
+  return SA_SUCCESS;
+}
+
+
+int
+sa_stream_open(sa_stream_t *s) {
+
+  if (s == NULL) {
+    return SA_ERROR_NO_INIT;
+  }
+  if (s->output_unit != NULL) {
+    return SA_ERROR_INVALID;
+  }
+
+  /*
+   * Open the default audio output unit.
+   */
+  ComponentDescription desc;
+  desc.componentType         = kAudioUnitType_Output;
+  desc.componentSubType      = kAudioUnitSubType_DefaultOutput;
+  desc.componentManufacturer = kAudioUnitManufacturer_Apple;
+  desc.componentFlags        = 0;
+  desc.componentFlagsMask    = 0;
+
+  Component comp = FindNextComponent(NULL, &desc);
+  if (comp == NULL) {
+    return SA_ERROR_NO_DEVICE;
+  }
+
+  if (OpenAComponent(comp, &s->output_unit) != noErr) {
+    return SA_ERROR_NO_DEVICE;
+  }
+
+  /*
+   * Set up the render callback used to feed audio data into the output unit.
+   */
+  AURenderCallbackStruct input;
+  input.inputProc       = audio_callback;
+  input.inputProcRefCon = s;
+  if (AudioUnitSetProperty(s->output_unit, kAudioUnitProperty_SetRenderCallback,
+      kAudioUnitScope_Input, 0, &input, sizeof(input)) != 0) {
+    return SA_ERROR_SYSTEM;
+  }
+
+  /*
+   * Set up the format description for our audio data. Apple uses the
+   * following terminology:
+   *
+   * sample = a single data value for one channel
+   * frame  = a set of samples that includes one sample for each channel
+   * packet = the smallest indivisible block of audio data; for uncompressed
+   *          audio (which is what we have), this is one frame
+   * rate   = the number of complete frames per second
+   *
+   * Note that this definition of frame differs from, well, pretty much everyone
+   * else's. See this really long link for more info:
+   *
+   * http://developer.apple.com/documentation/MusicAudio/Reference/CoreAudioDataTypesRef/Reference/reference.html#//apple_ref/c/tdef/AudioStreamBasicDescription
+   */
+  AudioStreamBasicDescription fmt;
+  fmt.mFormatID         = kAudioFormatLinearPCM;
+  fmt.mFormatFlags      = kLinearPCMFormatFlagIsSignedInteger |
+#ifdef __BIG_ENDIAN__
+                          kLinearPCMFormatFlagIsBigEndian |
+#endif
+                          kLinearPCMFormatFlagIsPacked;
+  fmt.mSampleRate       = s->rate;
+  fmt.mChannelsPerFrame = s->n_channels;
+  fmt.mBitsPerChannel   = s->bytes_per_ch * 8;
+  fmt.mFramesPerPacket  = 1;  /* uncompressed audio */
+  fmt.mBytesPerFrame    = fmt.mChannelsPerFrame * fmt.mBitsPerChannel / 8;
+  fmt.mBytesPerPacket   = fmt.mBytesPerFrame * fmt.mFramesPerPacket;
+
+  /*
+   * We're feeding data in to the output bus of the audio system, so we set
+   * the format description on the input scope of the device, using the very
+   * obvious element value of 0 to indicate the output bus.
+   *
+   * http://developer.apple.com/technotes/tn2002/tn2091.html
+   */
+  if (AudioUnitSetProperty(s->output_unit, kAudioUnitProperty_StreamFormat,
+      kAudioUnitScope_Input, 0, &fmt, sizeof(AudioStreamBasicDescription)) != 0) {
+    return SA_ERROR_NOT_SUPPORTED;
+  }
+
+  if (AudioUnitInitialize(s->output_unit) != 0) {
+    return SA_ERROR_SYSTEM;
+  }
+
+  return SA_SUCCESS;
+}
+
+
+int
+sa_stream_destroy(sa_stream_t *s) {
+
+  if (s == NULL) {
+    return SA_SUCCESS;
+  }
+
+  pthread_mutex_lock(&s->mutex);
+
+  /*
+   * Shut down the audio output device.
+   */
+  int result = SA_SUCCESS;
+  if (s->output_unit != NULL) {
+    if (s->playing && AudioOutputUnitStop(s->output_unit) != 0) {
+      result = SA_ERROR_SYSTEM;
+    }
+    if (AudioUnitUninitialize(s->output_unit) != 0) {
+      result = SA_ERROR_SYSTEM;
+    }
+    if (CloseComponent(s->output_unit) != noErr) {
+      result = SA_ERROR_SYSTEM;
+    }
+  }
+
+  pthread_mutex_unlock(&s->mutex);
+
+  /*
+   * Release resources.
+   */
+  if (pthread_mutex_destroy(&s->mutex) != 0) {
+    result = SA_ERROR_SYSTEM;
+  }
+  while (s->bl_head != NULL) {
+    sa_buf  * next = s->bl_head->next;
+    free(s->bl_head);
+    s->bl_head = next;
+  }
+  free(s);
+
+  return result;
+}
+
+
+
+/*
+ * -----------------------------------------------------------------------------
+ * Data read and write functions
+ * -----------------------------------------------------------------------------
+ */
+
+int
+sa_stream_write(sa_stream_t *s, const void *data, size_t nbytes) {
+
+  if (s == NULL || s->output_unit == NULL) {
+    return SA_ERROR_NO_INIT;
+  }
+  if (nbytes == 0) {
+    return SA_SUCCESS;
+  }
+
+  pthread_mutex_lock(&s->mutex);
+
+  /*
+   * Append the new data to the end of our buffer list.
+   */
+  int result = SA_SUCCESS;
+  while (1) {
+    unsigned int avail = s->bl_tail->size - s->bl_tail->end;
+
+    if (nbytes <= avail) {
+
+      /*
+       * The new data will fit into the current tail buffer, so
+       * just copy it in and we're done.
+       */
+      memcpy(s->bl_tail->data + s->bl_tail->end, data, nbytes);
+      s->bl_tail->end += nbytes;
+      break;
+
+    } else {
+
+      /*
+       * Copy what we can into the tail and allocate a new buffer
+       * for the rest.
+       */
+      memcpy(s->bl_tail->data + s->bl_tail->end, data, avail);
+      s->bl_tail->end += avail;
+      data = ((unsigned char *)data) + avail;
+      nbytes -= avail;
+
+      /* 
+       * If we still have data left to copy but we've hit the limit of
+       * allowable buffer allocations, we need to spin for a bit to allow
+       * the audio callback function to slurp some more data up.
+       */
+      if (nbytes > 0 && s->n_bufs == BUF_LIMIT) {
+#ifdef TIMING_TRACE
+        printf("#");  /* too much audio data */
+#endif
+        if (!s->playing) {
+          /*
+           * We haven't even started playing yet! That means the
+           * BUF_SIZE/BUF_LIMIT values are too low... Not much we can
+           * do here; spinning won't help because the audio callback
+           * hasn't been enabled yet. Oh well, error time.
+           */
+          printf("Too much audio data received before audio device enabled!\n");
+          result = SA_ERROR_SYSTEM;
+          break;
+        }
+        while (s->n_bufs == BUF_LIMIT) {
+          pthread_mutex_unlock(&s->mutex);
+          struct timespec ts = {0, 1000000};
+          nanosleep(&ts, NULL);
+          pthread_mutex_lock(&s->mutex);
+        }
+      }
+
+      /* 
+       * Allocate a new tail buffer, and go 'round again to fill it up.
+       */
+      if ((s->bl_tail->next = new_buffer()) == NULL) {
+        result = SA_ERROR_OOM;
+        break;
+      }
+      s->n_bufs++;
+      s->bl_tail = s->bl_tail->next;
+    
+    } /* if (nbytes <= avail), else */
+
+  } /* while (1) */
+
+  pthread_mutex_unlock(&s->mutex);
+
+  /*
+   * Once we have our first block of audio data, enable the audio callback
+   * function. This doesn't need to be protected by the mutex, because
+   * s->playing is not used in the audio callback thread, and it's probably
+   * better not to be inside the lock when we enable the audio callback.
+   */
+  if (!s->playing) {
+    s->playing = TRUE;
+    if (AudioOutputUnitStart(s->output_unit) != 0) {
+      result = SA_ERROR_SYSTEM;
+    }
+  }
+
+  return result;
+}
+
+
+static OSStatus
+audio_callback(
+  void                        * arg,
+  AudioUnitRenderActionFlags  * action_flags,
+  const AudioTimeStamp        * time_stamp,
+  UInt32                        bus_num,
+  UInt32                        n_frames,
+  AudioBufferList             * data
+) {
+
+#ifdef TIMING_TRACE
+  printf(".");  /* audio read 'tick' */
+#endif
+
+  /*
+   * We're dealing with interleaved data, so the system should only
+   * have provided one buffer to be filled.
+   */
+  assert(data->mNumberBuffers == 1);
+
+  sa_stream_t     * s = arg;
+
+  pthread_mutex_lock(&s->mutex);
+
+  unsigned char   * dst             = data->mBuffers[0].mData;
+  unsigned int      bytes_per_frame = s->n_channels * s->bytes_per_ch;
+  unsigned int      bytes_to_copy   = n_frames * bytes_per_frame;
+
+  /*
+   * Keep track of the number of bytes we've consumed so far. mSampleTime
+   * is actually the number of *frames* that have been consumed by the
+   * audio output unit so far. I don't know why it's a float.
+   */
+  assert(time_stamp->mFlags & kAudioTimeStampSampleTimeValid);
+  s->bytes_played = (int64_t)time_stamp->mSampleTime * bytes_per_frame;
+
+  /*
+   * Consume data from the start of the buffer list.
+   */
+  while (1) {
+    assert(s->bl_head->start <= s->bl_head->end);
+    unsigned int avail = s->bl_head->end - s->bl_head->start;
+
+    if (avail >= bytes_to_copy) {
+
+      /*
+       * We have all we need in the head buffer, so just grab it and go.
+       */
+      memcpy(dst, s->bl_head->data + s->bl_head->start, bytes_to_copy);
+      s->bl_head->start += bytes_to_copy;
+      break;
+
+    } else {
+
+      /*
+       * Copy what we can from the head and move on to the next buffer.
+       */
+      memcpy(dst, s->bl_head->data + s->bl_head->start, avail);
+      s->bl_head->start += avail;
+      dst += avail;
+      bytes_to_copy -= avail;
+
+      /*
+       * We want to free the now-empty buffer, but not if it's also the
+       * current tail. If it is the tail, we don't have enough data to fill
+       * the destination buffer, so we'll just zero it out and give up.
+       */
+      sa_buf  * next = s->bl_head->next;
+      if (next == NULL) {
+#ifdef TIMING_TRACE
+        printf("!");  /* not enough audio data */
+#endif
+        memset(dst, 0, bytes_to_copy);
+        break;
+      }
+      free(s->bl_head);
+      s->bl_head = next;
+      s->n_bufs--;
+
+    } /* if (avail >= bytes_to_copy), else */
+
+  } /* while (1) */
+
+  pthread_mutex_unlock(&s->mutex);
+  return noErr;
+}
+
+
+
+/*
+ * -----------------------------------------------------------------------------
+ * General query and support functions
+ * -----------------------------------------------------------------------------
+ */
+
+int
+sa_stream_get_write_size(sa_stream_t *s, size_t *size) {
+
+  if (s == NULL || s->output_unit == NULL) {
+    return SA_ERROR_NO_INIT;
+  }
+
+  pthread_mutex_lock(&s->mutex);
+
+  /*
+   * The sum of the free space in the tail buffer plus the size of any new
+   * buffers represents the write space available before blocking.
+   */
+  unsigned int avail = s->bl_tail->size - s->bl_tail->end;
+  avail += (BUF_LIMIT - s->n_bufs) * BUF_SIZE;
+  *size = avail;
+
+  pthread_mutex_unlock(&s->mutex);
+  return SA_SUCCESS;
+}
+
+
+int
+sa_stream_get_position(sa_stream_t *s, sa_position_t position, int64_t *pos) {
+
+  if (s == NULL || s->output_unit == NULL) {
+    return SA_ERROR_NO_INIT;
+  }
+  if (position != SA_POSITION_WRITE_SOFTWARE) {
+    return SA_ERROR_NOT_SUPPORTED;
+  }
+
+  pthread_mutex_lock(&s->mutex);
+  *pos = s->bytes_played;
+  pthread_mutex_unlock(&s->mutex);
+  return SA_SUCCESS;
+}
+
+
+int
+sa_stream_pause(sa_stream_t *s) {
+
+  if (s == NULL || s->output_unit == NULL) {
+    return SA_ERROR_NO_INIT;
+  }
+
+  pthread_mutex_lock(&s->mutex);
+  AudioOutputUnitStop(s->output_unit);
+  pthread_mutex_unlock(&s->mutex);
+  return SA_SUCCESS;
+}
+
+
+int
+sa_stream_resume(sa_stream_t *s) {
+
+  if (s == NULL || s->output_unit == NULL) {
+    return SA_ERROR_NO_INIT;
+  }
+
+  pthread_mutex_lock(&s->mutex);
+
+  /*
+   * The audio device resets its mSampleTime counter after pausing,
+   * so we need to clear our tracking value to keep that in sync.
+   */
+  s->bytes_played = 0;
+  AudioOutputUnitStart(s->output_unit);
+
+  pthread_mutex_unlock(&s->mutex);
+  return SA_SUCCESS;
+}
+
+
+static sa_buf *
+new_buffer(void) {
+  sa_buf  * b = malloc(sizeof(sa_buf) + BUF_SIZE);
+  if (b != NULL) {
+    b->size  = BUF_SIZE;
+    b->start = 0;
+    b->end   = 0;
+    b->next  = NULL;
+  }
+  return b;
+}
+
+
+int
+sa_stream_drain(sa_stream_t *s)
+{
+  if (s == NULL || s->output_unit == NULL) {
+    return SA_ERROR_NO_INIT;
+  }
+
+  while (1) {
+    pthread_mutex_lock(&s->mutex);
+    sa_buf  * b;
+    size_t    used = 0;
+    for (b = s->bl_head; b != NULL; b = b->next) {
+      used += b->end - b->start;
+    }
+    pthread_mutex_unlock(&s->mutex);
+
+    if (used == 0) {
+      break;
+    }
+
+    struct timespec ts = {0, 1000000};
+    nanosleep(&ts, NULL);
+  }
+  return SA_SUCCESS;
+}
+
+
+
+/*
+ * -----------------------------------------------------------------------------
+ * Extension functions
+ * -----------------------------------------------------------------------------
+ */
+
+int
+sa_stream_set_volume_abs(sa_stream_t *s, float vol) {
+
+  if (s == NULL || s->output_unit == NULL) {
+    return SA_ERROR_NO_INIT;
+  }
+
+  pthread_mutex_lock(&s->mutex);
+  AudioUnitSetParameter(s->output_unit, kHALOutputParam_Volume,
+      kAudioUnitParameterFlag_Output, 0, vol, 0);
+  pthread_mutex_unlock(&s->mutex);
+  return SA_SUCCESS;
+}
+
+
+int
+sa_stream_get_volume_abs(sa_stream_t *s, float *vol) {
+
+  if (s == NULL || s->output_unit == NULL) {
+    return SA_ERROR_NO_INIT;
+  }
+
+  pthread_mutex_lock(&s->mutex);
+  Float32 local_vol = 0;
+  AudioUnitGetParameter(s->output_unit, kHALOutputParam_Volume,
+      kAudioUnitParameterFlag_Output, 0, &local_vol);
+  *vol = local_vol;
+  pthread_mutex_unlock(&s->mutex);
+  return SA_SUCCESS;
+}
+
+
+
+/*
+ * -----------------------------------------------------------------------------
+ * Unsupported functions
+ * -----------------------------------------------------------------------------
+ */
+#define UNSUPPORTED(func)   func { return SA_ERROR_NOT_SUPPORTED; }
+
+UNSUPPORTED(int sa_stream_create_opaque(sa_stream_t **s, const char *client_name, sa_mode_t mode, const char *codec))
+UNSUPPORTED(int sa_stream_set_write_lower_watermark(sa_stream_t *s, size_t size))
+UNSUPPORTED(int sa_stream_set_read_lower_watermark(sa_stream_t *s, size_t size))
+UNSUPPORTED(int sa_stream_set_write_upper_watermark(sa_stream_t *s, size_t size))
+UNSUPPORTED(int sa_stream_set_read_upper_watermark(sa_stream_t *s, size_t size))
+UNSUPPORTED(int sa_stream_set_channel_map(sa_stream_t *s, const sa_channel_t map[], unsigned int n))
+UNSUPPORTED(int sa_stream_set_xrun_mode(sa_stream_t *s, sa_xrun_mode_t mode))
+UNSUPPORTED(int sa_stream_set_non_interleaved(sa_stream_t *s, int enable))
+UNSUPPORTED(int sa_stream_set_dynamic_rate(sa_stream_t *s, int enable))
+UNSUPPORTED(int sa_stream_set_driver(sa_stream_t *s, const char *driver))
+UNSUPPORTED(int sa_stream_start_thread(sa_stream_t *s, sa_event_callback_t callback))
+UNSUPPORTED(int sa_stream_stop_thread(sa_stream_t *s))
+UNSUPPORTED(int sa_stream_change_device(sa_stream_t *s, const char *device_name))
+UNSUPPORTED(int sa_stream_change_read_volume(sa_stream_t *s, const int32_t vol[], unsigned int n))
+UNSUPPORTED(int sa_stream_change_write_volume(sa_stream_t *s, const int32_t vol[], unsigned int n))
+UNSUPPORTED(int sa_stream_change_rate(sa_stream_t *s, unsigned int rate))
+UNSUPPORTED(int sa_stream_change_meta_data(sa_stream_t *s, const char *name, const void *data, size_t size))
+UNSUPPORTED(int sa_stream_change_user_data(sa_stream_t *s, const void *value))
+UNSUPPORTED(int sa_stream_set_adjust_rate(sa_stream_t *s, sa_adjust_t direction))
+UNSUPPORTED(int sa_stream_set_adjust_nchannels(sa_stream_t *s, sa_adjust_t direction))
+UNSUPPORTED(int sa_stream_set_adjust_pcm_format(sa_stream_t *s, sa_adjust_t direction))
+UNSUPPORTED(int sa_stream_set_adjust_watermarks(sa_stream_t *s, sa_adjust_t direction))
+UNSUPPORTED(int sa_stream_get_mode(sa_stream_t *s, sa_mode_t *access_mode))
+UNSUPPORTED(int sa_stream_get_codec(sa_stream_t *s, char *codec, size_t *size))
+UNSUPPORTED(int sa_stream_get_pcm_format(sa_stream_t *s, sa_pcm_format_t *format))
+UNSUPPORTED(int sa_stream_get_rate(sa_stream_t *s, unsigned int *rate))
+UNSUPPORTED(int sa_stream_get_nchannels(sa_stream_t *s, int *nchannels))
+UNSUPPORTED(int sa_stream_get_user_data(sa_stream_t *s, void **value))
+UNSUPPORTED(int sa_stream_get_write_lower_watermark(sa_stream_t *s, size_t *size))
+UNSUPPORTED(int sa_stream_get_read_lower_watermark(sa_stream_t *s, size_t *size))
+UNSUPPORTED(int sa_stream_get_write_upper_watermark(sa_stream_t *s, size_t *size))
+UNSUPPORTED(int sa_stream_get_read_upper_watermark(sa_stream_t *s, size_t *size))
+UNSUPPORTED(int sa_stream_get_channel_map(sa_stream_t *s, sa_channel_t map[], unsigned int *n))
+UNSUPPORTED(int sa_stream_get_xrun_mode(sa_stream_t *s, sa_xrun_mode_t *mode))
+UNSUPPORTED(int sa_stream_get_non_interleaved(sa_stream_t *s, int *enabled))
+UNSUPPORTED(int sa_stream_get_dynamic_rate(sa_stream_t *s, int *enabled))
+UNSUPPORTED(int sa_stream_get_driver(sa_stream_t *s, char *driver_name, size_t *size))
+UNSUPPORTED(int sa_stream_get_device(sa_stream_t *s, char *device_name, size_t *size))
+UNSUPPORTED(int sa_stream_get_read_volume(sa_stream_t *s, int32_t vol[], unsigned int *n))
+UNSUPPORTED(int sa_stream_get_write_volume(sa_stream_t *s, int32_t vol[], unsigned int *n))
+UNSUPPORTED(int sa_stream_get_meta_data(sa_stream_t *s, const char *name, void*data, size_t *size))
+UNSUPPORTED(int sa_stream_get_adjust_rate(sa_stream_t *s, sa_adjust_t *direction))
+UNSUPPORTED(int sa_stream_get_adjust_nchannels(sa_stream_t *s, sa_adjust_t *direction))
+UNSUPPORTED(int sa_stream_get_adjust_pcm_format(sa_stream_t *s, sa_adjust_t *direction))
+UNSUPPORTED(int sa_stream_get_adjust_watermarks(sa_stream_t *s, sa_adjust_t *direction))
+UNSUPPORTED(int sa_stream_get_state(sa_stream_t *s, sa_state_t *state))
+UNSUPPORTED(int sa_stream_get_event_error(sa_stream_t *s, sa_error_t *error))
+UNSUPPORTED(int sa_stream_get_event_notify(sa_stream_t *s, sa_notify_t *notify))
+UNSUPPORTED(int sa_stream_read(sa_stream_t *s, void *data, size_t nbytes))
+UNSUPPORTED(int sa_stream_read_ni(sa_stream_t *s, unsigned int channel, void *data, size_t nbytes))
+UNSUPPORTED(int sa_stream_write_ni(sa_stream_t *s, unsigned int channel, const void *data, size_t nbytes))
+UNSUPPORTED(int sa_stream_pwrite(sa_stream_t *s, const void *data, size_t nbytes, int64_t offset, sa_seek_t whence))
+UNSUPPORTED(int sa_stream_pwrite_ni(sa_stream_t *s, unsigned int channel, const void *data, size_t nbytes, int64_t offset, sa_seek_t whence))
+UNSUPPORTED(int sa_stream_get_read_size(sa_stream_t *s, size_t *size))
+
+const char *sa_strerror(int code) { return NULL; }
+
diff -r 4b060ed856e0 media/libsydneyaudio/src/sydney_audio_oss.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/media/libsydneyaudio/src/sydney_audio_oss.c	Thu Oct 16 21:24:49 2008 -0500
@@ -0,0 +1,719 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Initial Developer of the Original Code is
+ * CSIRO
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s): Michael Martin
+ *                 Chris Double (chris.double@double.co.nz)
+ *                 Jeremy D. Lea (reg@openpave.org)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/soundcard.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <string.h>
+#include <pthread.h>
+#include <assert.h>
+#include "sydney_audio.h"
+
+// for versions newer than 3.6.1
+#define OSS_VERSION(x, y, z) (x << 16 | y << 8 | z)
+// support only versions newer than 3.6.1
+#define SUPP_OSS_VERSION OSS_VERSION(3,6,1)
+
+#if (SOUND_VERSION < SUPP_OSS_VERSION)
+#error Unsupported OSS Version
+#else
+
+typedef struct sa_buf sa_buf;
+struct sa_buf {
+  unsigned int      size;
+  unsigned int      start;
+  unsigned int      end;
+  sa_buf          * next;
+  unsigned char     data[0];
+};
+
+struct sa_stream {
+  char*                output_unit;
+  int                output_fd;
+  pthread_t         thread_id;
+  pthread_mutex_t   mutex;
+  char              playing;
+  int64_t           bytes_played;
+
+  /* audio format info */
+  unsigned int      rate;
+  unsigned int      channels;
+  int               format;
+
+  /* buffer list */
+  sa_buf          * bl_head;
+  sa_buf          * bl_tail;
+  int               n_bufs;
+};
+
+
+/*
+ * Use a default buffer size with enough room for one second of audio,
+ * assuming stereo data at 44.1kHz with 32 bits per channel, and impose
+ * a generous limit on the number of buffers.
+ */
+#define BUF_SIZE    (2 * 44100 * 4)
+#define BUF_LIMIT   5
+
+#if BUF_LIMIT < 2
+#error BUF_LIMIT must be at least 2!
+#endif
+
+static void audio_callback(void* s);
+static sa_buf *new_buffer(void);
+
+/** Private functions - implementation specific */
+
+/*!
+ * \brief private function mapping Sudney Audio format to OSS formats
+ * \param format - Sydney Audio API specific format
+ * \param - filled by the function with a value for corresponding OSS format
+ * \return - Sydney API error value as in ::sa_pcm_format_t
+ * */
+static int oss_audio_format(sa_pcm_format_t sa_format, int *fmt) {
+    *fmt = -1;
+    switch (sa_format) {
+        case SA_PCM_FORMAT_U8:
+            *fmt = AFMT_U8;
+            break;
+        case SA_PCM_FORMAT_ULAW:
+            *fmt = AFMT_MU_LAW;
+            break;
+        case SA_PCM_FORMAT_ALAW:
+            *fmt = AFMT_A_LAW;
+            break;
+        /* 16-bit little endian (LE) format */
+        case SA_PCM_FORMAT_S16_LE:
+            *fmt = AFMT_S16_LE;
+            break;
+        /* 16-bit big endian (BE) format */
+        case SA_PCM_FORMAT_S16_BE:
+            *fmt = AFMT_S16_BE;
+            break;
+#if SOUND_VERSION >= OSS_VERSION(4,0,0)
+        /* 24-bit formats (LSB aligned in 32 bit word) */
+        case SA_PCM_FORMAT_S24_LE:
+            *fmt = AFMT_S24_LE;
+            break;
+        /* 24-bit formats (LSB aligned in 32 bit word) */
+        case SA_PCM_FORMAT_S24_BE:
+            *fmt = AFMT_S24_BE;
+            break;
+        /* 32-bit format little endian */
+        case SA_PCM_FORMAT_S32_LE:
+            *fmt = AFMT_S32_LE;
+            break;
+        /* 32-bit format big endian */
+        case SA_PCM_FORMAT_S32_BE:
+            *fmt = AFMT_S32_BE;
+            break;
+#endif
+        default:
+            return SA_ERROR_NOT_SUPPORTED;
+            break;
+    }
+    return SA_SUCCESS;
+}
+
+/*
+ * -----------------------------------------------------------------------------
+ * Startup and shutdown functions
+ * -----------------------------------------------------------------------------
+ */
+
+int
+sa_stream_create_pcm(
+  sa_stream_t      ** _s,
+  const char        * client_name,
+  sa_mode_t           mode,
+  sa_pcm_format_t     format,
+  unsigned  int       rate,
+  unsigned  int       channels
+) {
+  sa_stream_t * s = 0;
+  int fmt = 0;
+
+  /*
+   * Make sure we return a NULL stream pointer on failure.
+   */
+  if (_s == NULL) {
+    return SA_ERROR_INVALID;
+  }
+  *_s = NULL;
+
+  if (mode != SA_MODE_WRONLY) {
+    return SA_ERROR_NOT_SUPPORTED;
+  }
+  if (oss_audio_format(format, &fmt) != SA_SUCCESS) {
+    return SA_ERROR_NOT_SUPPORTED;
+  }
+
+  /*
+   * Allocate the instance and required resources.
+   */
+  if ((s = malloc(sizeof(sa_stream_t))) == NULL) {
+    return SA_ERROR_OOM;
+  }
+  if ((s->bl_head = new_buffer()) == NULL) {
+    free(s);
+    return SA_ERROR_OOM;
+  }
+  if (pthread_mutex_init(&s->mutex, NULL) != 0) {
+    free(s->bl_head);
+    free(s);
+    return SA_ERROR_SYSTEM;
+  }
+
+  s->output_unit  = "/dev/dsp";
+  s->output_fd    = -1;
+  s->thread_id    = 0;
+  s->playing      = 0;
+  s->bytes_played = 0;
+  s->rate         = rate;
+  s->channels     = channels;
+  s->format       = fmt;
+  s->bl_tail      = s->bl_head;
+  s->n_bufs       = 1;
+
+  *_s = s;
+  return SA_SUCCESS;
+}
+
+
+int
+sa_stream_open(sa_stream_t *s) {
+  if (s == NULL) {
+    return SA_ERROR_NO_INIT;
+  }
+  if (s->output_unit == NULL || s->output_fd != -1) {
+    return SA_ERROR_INVALID;
+  }
+
+  // open the default OSS device
+  if ((s->output_fd = open(s->output_unit, O_WRONLY, 0)) == -1) {
+    return SA_ERROR_NO_DEVICE;
+  }
+
+  // set the playback rate
+  if (ioctl(s->output_fd, SNDCTL_DSP_SPEED, &(s->rate)) < 0) {
+    close(s->output_fd);
+    s->output_fd = -1;
+    return SA_ERROR_NOT_SUPPORTED;
+  }
+
+  // set the channel numbers
+  if (ioctl(s->output_fd, SNDCTL_DSP_CHANNELS, &(s->channels)) < 0) {
+    close(s->output_fd);
+    s->output_fd = -1;
+    return SA_ERROR_NOT_SUPPORTED;
+  }
+
+  if (ioctl(s->output_fd, SNDCTL_DSP_SETFMT, &(s->format)) < 0 ) {
+    close(s->output_fd);
+    s->output_fd = -1;
+    return SA_ERROR_NOT_SUPPORTED;
+  }
+
+  return SA_SUCCESS;
+}
+
+
+int
+sa_stream_destroy(sa_stream_t *s) {
+  int result = SA_SUCCESS;
+
+  if (s == NULL) {
+    return SA_SUCCESS;
+  }
+
+  pthread_mutex_lock(&s->mutex);
+
+  /*
+   * This causes the thread sending data to ALSA to stop
+   */
+  s->thread_id = 0;
+
+  /*
+   * Shut down the audio output device.
+   */
+  if (s->output_fd != -1) {
+    if (s->playing && close(s->output_fd) < 0) {
+      result = SA_ERROR_SYSTEM;
+    }
+  }
+
+  pthread_mutex_unlock(&s->mutex);
+
+  /*
+   * Release resources.
+   */
+  if (pthread_mutex_destroy(&s->mutex) != 0) {
+    result = SA_ERROR_SYSTEM;
+  }
+  while (s->bl_head != NULL) {
+    sa_buf  * next = s->bl_head->next;
+    free(s->bl_head);
+    s->bl_head = next;
+  }
+  free(s);
+
+  return result;
+}
+
+
+
+/*
+ * -----------------------------------------------------------------------------
+ * Data read and write functions
+ * -----------------------------------------------------------------------------
+ */
+
+int
+sa_stream_write(sa_stream_t *s, const void *data, size_t nbytes) {
+  int result = SA_SUCCESS;
+
+  if (s == NULL || s->output_unit == NULL) {
+    return SA_ERROR_NO_INIT;
+  }
+  if (nbytes == 0) {
+    return SA_SUCCESS;
+  }
+
+  pthread_mutex_lock(&s->mutex);
+
+  /*
+   * Append the new data to the end of our buffer list.
+   */
+  while (1) {
+    unsigned int avail = s->bl_tail->size - s->bl_tail->end;
+
+    if (nbytes <= avail) {
+
+      /*
+       * The new data will fit into the current tail buffer, so
+       * just copy it in and we're done.
+       */
+      memcpy(s->bl_tail->data + s->bl_tail->end, data, nbytes);
+      s->bl_tail->end += nbytes;
+      break;
+
+    } else {
+
+      /*
+       * Copy what we can into the tail and allocate a new buffer
+       * for the rest.
+       */
+      memcpy(s->bl_tail->data + s->bl_tail->end, data, avail);
+      s->bl_tail->end += avail;
+      data = ((unsigned char *)data) + avail;
+      nbytes -= avail;
+
+      /*
+       * If we still have data left to copy but we've hit the limit of
+       * allowable buffer allocations, we need to spin for a bit to allow
+       * the audio callback function to slurp some more data up.
+       */
+      if (nbytes > 0 && s->n_bufs == BUF_LIMIT) {
+#ifdef TIMING_TRACE
+        printf("#");  /* too much audio data */
+#endif
+        if (!s->playing) {
+          /*
+           * We haven't even started playing yet! That means the
+           * BUF_SIZE/BUF_LIMIT values are too low... Not much we can
+           * do here; spinning won't help because the audio callback
+           * hasn't been enabled yet. Oh well, error time.
+           */
+          printf("Too much audio data received before audio device enabled!\n");
+          result = SA_ERROR_SYSTEM;
+          break;
+        }
+        while (s->n_bufs == BUF_LIMIT) {
+          struct timespec ts = {0, 1000000};
+          pthread_mutex_unlock(&s->mutex);
+          nanosleep(&ts, NULL);
+          pthread_mutex_lock(&s->mutex);
+        }
+      }
+
+      /*
+       * Allocate a new tail buffer, and go 'round again to fill it up.
+       */
+      if ((s->bl_tail->next = new_buffer()) == NULL) {
+        result = SA_ERROR_OOM;
+        break;
+      }
+      s->n_bufs++;
+      s->bl_tail = s->bl_tail->next;
+
+    } /* if (nbytes <= avail), else */
+
+  } /* while (1) */
+
+  pthread_mutex_unlock(&s->mutex);
+
+  /*
+   * Once we have our first block of audio data, enable the audio callback
+   * function. This doesn't need to be protected by the mutex, because
+   * s->playing is not used in the audio callback thread, and it's probably
+   * better not to be inside the lock when we enable the audio callback.
+   */
+  if (!s->playing) {
+    s->playing = 1;
+    if (pthread_create(&s->thread_id, NULL, (void *)audio_callback, s) != 0) {
+      result = SA_ERROR_SYSTEM;
+    }
+  }
+
+  return result;
+}
+
+
+static void audio_callback(void* data)
+{
+  sa_stream_t* s = (sa_stream_t*)data;
+  audio_buf_info info;
+  char* buffer = 0;
+  unsigned int avail;
+  int frames;
+
+#ifdef TIMING_TRACE
+  printf(".");  /* audio read 'tick' */
+#endif
+
+  ioctl(s->output_fd, SNDCTL_DSP_GETOSPACE, &info);
+  buffer = malloc(info.bytes);
+
+  while(1) {
+    char* dst = buffer;
+    unsigned int bytes_to_copy = info.bytes;
+    int bytes = info.bytes;
+
+    pthread_mutex_lock(&s->mutex);
+    if (!s->thread_id)
+      break;
+
+    /*
+     * Consume data from the start of the buffer list.
+     */
+    while (1) {
+      assert(s->bl_head->start <= s->bl_head->end);
+      avail = s->bl_head->end - s->bl_head->start;
+
+      if (avail >= bytes_to_copy) {
+        /*
+         * We have all we need in the head buffer, so just grab it and go.
+         */
+        memcpy(dst, s->bl_head->data + s->bl_head->start, bytes_to_copy);
+        s->bl_head->start += bytes_to_copy;
+        s->bytes_played += bytes_to_copy;
+        break;
+
+      } else {
+
+        sa_buf* next = 0;
+        /*
+         * Copy what we can from the head and move on to the next buffer.
+         */
+        memcpy(dst, s->bl_head->data + s->bl_head->start, avail);
+        s->bl_head->start += avail;
+        dst += avail;
+        bytes_to_copy -= avail;
+        s->bytes_played += avail;
+
+        /*
+         * We want to free the now-empty buffer, but not if it's also the
+         * current tail. If it is the tail, we don't have enough data to fill
+         * the destination buffer, so we write less and give up.
+         */
+        next = s->bl_head->next;
+        if (next == NULL) {
+#ifdef TIMING_TRACE
+          printf("!");  /* not enough audio data */
+#endif
+          bytes = bytes-bytes_to_copy;
+          break;
+        }
+        free(s->bl_head);
+        s->bl_head = next;
+        s->n_bufs--;
+
+      } /* if (avail >= bytes_to_copy), else */
+
+    } /* while (1) */
+
+    pthread_mutex_unlock(&s->mutex);
+
+    if(bytes > 0) {
+      frames = write(s->output_fd, buffer, bytes);
+      if (frames < 0) {
+          printf("error writing to sound device\n");
+      }
+      if (frames >= 0 && frames != bytes) {
+         printf("short write (expected %d, wrote %d)\n", (int)bytes, (int)frames);
+      }
+    }
+  }
+  free(buffer);
+}
+
+
+
+/*
+ * -----------------------------------------------------------------------------
+ * General query and support functions
+ * -----------------------------------------------------------------------------
+ */
+
+int
+sa_stream_get_write_size(sa_stream_t *s, size_t *size) {
+  sa_buf  * b;
+  size_t    used = 0;
+
+  if (s == NULL || s->output_unit == NULL) {
+    return SA_ERROR_NO_INIT;
+  }
+
+  pthread_mutex_lock(&s->mutex);
+
+  /*
+   * Sum up the used portions of our buffers and subtract that from
+   * the pre-defined max allowed allocation.
+   */
+  for (b = s->bl_head; b != NULL; b = b->next) {
+    used += b->end - b->start;
+  }
+  *size = BUF_SIZE * BUF_LIMIT - used;
+
+  pthread_mutex_unlock(&s->mutex);
+  return SA_SUCCESS;
+}
+
+
+int
+sa_stream_get_position(sa_stream_t *s, sa_position_t position, int64_t *pos) {
+   int err;
+   count_info ptr;
+
+  if (s == NULL || s->output_unit == NULL) {
+    return SA_ERROR_NO_INIT;
+  }
+  if (position != SA_POSITION_WRITE_SOFTWARE) {
+    return SA_ERROR_NOT_SUPPORTED;
+  }
+  if ((err = ioctl(s->output_fd, 
+                       SNDCTL_DSP_GETOPTR, 
+                       &ptr)) <0) {
+      fprintf(stderr, "Error reading playback position\n");
+      return SA_ERROR_OOM;
+  }
+
+  pthread_mutex_lock(&s->mutex);
+  *pos = (int64_t)ptr.bytes;
+  pthread_mutex_unlock(&s->mutex);
+  return SA_SUCCESS;
+}
+
+
+int
+sa_stream_pause(sa_stream_t *s) {
+
+  if (s == NULL || s->output_unit == NULL) {
+    return SA_ERROR_NO_INIT;
+  }
+
+  pthread_mutex_lock(&s->mutex);
+#if 0 /* TODO */
+  AudioOutputUnitStop(s->output_unit);
+#endif
+  pthread_mutex_unlock(&s->mutex);
+  return SA_SUCCESS;
+}
+
+
+int
+sa_stream_resume(sa_stream_t *s) {
+
+  if (s == NULL || s->output_unit == NULL) {
+    return SA_ERROR_NO_INIT;
+  }
+
+  pthread_mutex_lock(&s->mutex);
+
+  /*
+   * The audio device resets its mSampleTime counter after pausing,
+   * so we need to clear our tracking value to keep that in sync.
+   */
+  s->bytes_played = 0;
+#if 0 /* TODO */
+  AudioOutputUnitStart(s->output_unit);
+#endif
+  pthread_mutex_unlock(&s->mutex);
+  return SA_SUCCESS;
+}
+
+
+static sa_buf *
+new_buffer(void) {
+  sa_buf  * b = malloc(sizeof(sa_buf) + BUF_SIZE);
+  if (b != NULL) {
+    b->size  = BUF_SIZE;
+    b->start = 0;
+    b->end   = 0;
+    b->next  = NULL;
+  }
+  return b;
+}
+
+
+
+/*
+ * -----------------------------------------------------------------------------
+ * Extension functions
+ * -----------------------------------------------------------------------------
+ */
+
+int
+sa_stream_set_volume_abs(sa_stream_t *s, float vol) {
+  if (s == NULL || s->output_fd == -1) {
+    return SA_ERROR_NO_INIT;
+  }
+#if SOUND_VERSION >= OSS_VERSION(4,0,0)
+  int mvol = ((int)(100*vol)) | ((int)(100*vol) << 8);
+  if (ioctl(s->output_fd, SNDCTL_DSP_SETPLAYVOL, &mvol) < 0){
+    return SA_ERROR_SYSTEM;
+  }
+  return SA_SUCCESS;
+#else
+  return SA_ERROR_NOT_SUPPORTED;
+#endif
+}
+
+
+int
+sa_stream_get_volume_abs(sa_stream_t *s, float *vol) {
+
+  if (vol == NULL) {
+    return SA_ERROR_INVALID;
+  }
+  *vol = 0.0f;
+  if (s == NULL || s->output_fd == -1) {
+    return SA_ERROR_NO_INIT;
+  }
+#if SOUND_VERSION >= OSS_VERSION(4,0,0)
+  int mvol;
+  if (ioctl(s->output_fd, SNDCTL_DSP_SETPLAYVOL, &mvol) < 0){
+    return SA_ERROR_SYSTEM;
+  }
+  *vol = ((mvol & 0xFF) + (mvol >> 8)) / 200.0f;
+  return SA_SUCCESS;
+#else
+  return SA_ERROR_NOT_SUPPORTED;
+#endif
+}
+
+
+
+/*
+ * -----------------------------------------------------------------------------
+ * Unsupported functions
+ * -----------------------------------------------------------------------------
+ */
+#define UNSUPPORTED(func)   func { return SA_ERROR_NOT_SUPPORTED; }
+
+UNSUPPORTED(int sa_stream_create_opaque(sa_stream_t **s, const char *client_name, sa_mode_t mode, const char *codec))
+UNSUPPORTED(int sa_stream_set_write_lower_watermark(sa_stream_t *s, size_t size))
+UNSUPPORTED(int sa_stream_set_read_lower_watermark(sa_stream_t *s, size_t size))
+UNSUPPORTED(int sa_stream_set_write_upper_watermark(sa_stream_t *s, size_t size))
+UNSUPPORTED(int sa_stream_set_read_upper_watermark(sa_stream_t *s, size_t size))
+UNSUPPORTED(int sa_stream_set_channel_map(sa_stream_t *s, const sa_channel_t map[], unsigned int n))
+UNSUPPORTED(int sa_stream_set_xrun_mode(sa_stream_t *s, sa_xrun_mode_t mode))
+UNSUPPORTED(int sa_stream_set_non_interleaved(sa_stream_t *s, int enable))
+UNSUPPORTED(int sa_stream_set_dynamic_rate(sa_stream_t *s, int enable))
+UNSUPPORTED(int sa_stream_set_driver(sa_stream_t *s, const char *driver))
+UNSUPPORTED(int sa_stream_start_thread(sa_stream_t *s, sa_event_callback_t callback))
+UNSUPPORTED(int sa_stream_stop_thread(sa_stream_t *s))
+UNSUPPORTED(int sa_stream_change_device(sa_stream_t *s, const char *device_name))
+UNSUPPORTED(int sa_stream_change_read_volume(sa_stream_t *s, const int32_t vol[], unsigned int n))
+UNSUPPORTED(int sa_stream_change_write_volume(sa_stream_t *s, const int32_t vol[], unsigned int n))
+UNSUPPORTED(int sa_stream_change_rate(sa_stream_t *s, unsigned int rate))
+UNSUPPORTED(int sa_stream_change_meta_data(sa_stream_t *s, const char *name, const void *data, size_t size))
+UNSUPPORTED(int sa_stream_change_user_data(sa_stream_t *s, const void *value))
+UNSUPPORTED(int sa_stream_set_adjust_rate(sa_stream_t *s, sa_adjust_t direction))
+UNSUPPORTED(int sa_stream_set_adjust_nchannels(sa_stream_t *s, sa_adjust_t direction))
+UNSUPPORTED(int sa_stream_set_adjust_pcm_format(sa_stream_t *s, sa_adjust_t direction))
+UNSUPPORTED(int sa_stream_set_adjust_watermarks(sa_stream_t *s, sa_adjust_t direction))
+UNSUPPORTED(int sa_stream_get_mode(sa_stream_t *s, sa_mode_t *access_mode))
+UNSUPPORTED(int sa_stream_get_codec(sa_stream_t *s, char *codec, size_t *size))
+UNSUPPORTED(int sa_stream_get_pcm_format(sa_stream_t *s, sa_pcm_format_t *format))
+UNSUPPORTED(int sa_stream_get_rate(sa_stream_t *s, unsigned int *rate))
+UNSUPPORTED(int sa_stream_get_nchannels(sa_stream_t *s, int *nchannels))
+UNSUPPORTED(int sa_stream_get_user_data(sa_stream_t *s, void **value))
+UNSUPPORTED(int sa_stream_get_write_lower_watermark(sa_stream_t *s, size_t *size))
+UNSUPPORTED(int sa_stream_get_read_lower_watermark(sa_stream_t *s, size_t *size))
+UNSUPPORTED(int sa_stream_get_write_upper_watermark(sa_stream_t *s, size_t *size))
+UNSUPPORTED(int sa_stream_get_read_upper_watermark(sa_stream_t *s, size_t *size))
+UNSUPPORTED(int sa_stream_get_channel_map(sa_stream_t *s, sa_channel_t map[], unsigned int *n))
+UNSUPPORTED(int sa_stream_get_xrun_mode(sa_stream_t *s, sa_xrun_mode_t *mode))
+UNSUPPORTED(int sa_stream_get_non_interleaved(sa_stream_t *s, int *enabled))
+UNSUPPORTED(int sa_stream_get_dynamic_rate(sa_stream_t *s, int *enabled))
+UNSUPPORTED(int sa_stream_get_driver(sa_stream_t *s, char *driver_name, size_t *size))
+UNSUPPORTED(int sa_stream_get_device(sa_stream_t *s, char *device_name, size_t *size))
+UNSUPPORTED(int sa_stream_get_read_volume(sa_stream_t *s, int32_t vol[], unsigned int *n))
+UNSUPPORTED(int sa_stream_get_write_volume(sa_stream_t *s, int32_t vol[], unsigned int *n))
+UNSUPPORTED(int sa_stream_get_meta_data(sa_stream_t *s, const char *name, void*data, size_t *size))
+UNSUPPORTED(int sa_stream_get_adjust_rate(sa_stream_t *s, sa_adjust_t *direction))
+UNSUPPORTED(int sa_stream_get_adjust_nchannels(sa_stream_t *s, sa_adjust_t *direction))
+UNSUPPORTED(int sa_stream_get_adjust_pcm_format(sa_stream_t *s, sa_adjust_t *direction))
+UNSUPPORTED(int sa_stream_get_adjust_watermarks(sa_stream_t *s, sa_adjust_t *direction))
+UNSUPPORTED(int sa_stream_get_state(sa_stream_t *s, sa_state_t *state))
+UNSUPPORTED(int sa_stream_get_event_error(sa_stream_t *s, sa_error_t *error))
+UNSUPPORTED(int sa_stream_get_event_notify(sa_stream_t *s, sa_notify_t *notify))
+UNSUPPORTED(int sa_stream_read(sa_stream_t *s, void *data, size_t nbytes))
+UNSUPPORTED(int sa_stream_read_ni(sa_stream_t *s, unsigned int channel, void *data, size_t nbytes))
+UNSUPPORTED(int sa_stream_write_ni(sa_stream_t *s, unsigned int channel, const void *data, size_t nbytes))
+UNSUPPORTED(int sa_stream_pwrite(sa_stream_t *s, const void *data, size_t nbytes, int64_t offset, sa_seek_t whence))
+UNSUPPORTED(int sa_stream_pwrite_ni(sa_stream_t *s, unsigned int channel, const void *data, size_t nbytes, int64_t offset, sa_seek_t whence))
+UNSUPPORTED(int sa_stream_get_read_size(sa_stream_t *s, size_t *size))
+UNSUPPORTED(int sa_stream_drain(sa_stream_t *s))
+
+const char *sa_strerror(int code) { return NULL; }
+
+#endif
diff -r 4b060ed856e0 media/libsydneyaudio/src/sydney_audio_pulseaudio.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/media/libsydneyaudio/src/sydney_audio_pulseaudio.c	Thu Oct 16 21:24:49 2008 -0500
@@ -0,0 +1,707 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** *
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <pthread.h>
+#include <pulse/pulseaudio.h>
+#include "sydney_audio.h"
+
+/* Pulseaudio implementation based heavily on sydney_audio_alsa.c */
+
+/*
+ * The audio interface is based on a "pull" I/O model, which means you
+ * can't just provide a data buffer and tell the audio device to play; you must
+ * register a callback and provide data as the device asks for it. To support
+ * sydney audio's "write-to-play" style interface, we have to buffer up the
+ * data as it arrives and feed it to the callback as required.
+ *
+ * This is handled by a simple linked list of buffers; data is always written
+ * to the tail and read from the head. Each buffer tracks the start and end
+ * positions of its contained data. Buffers are allocated when the tail buffer
+ * fills, and freed when the head buffer empties. There is always at least one
+ * buffer allocated.
+ *
+ *       s   e      s      e      s  e            + data read
+ *    +++#####  ->  ########  ->  ####----        # data written
+ *    ^                           ^               - empty
+ *    bl_head                     bl_tail
+ */
+
+typedef struct sa_buf sa_buf;
+struct sa_buf {
+  unsigned int      size;
+  unsigned int      start;
+  unsigned int      end;
+  sa_buf          * next;
+  unsigned char     data[0];
+};
+
+struct sa_stream {
+  pa_context*       context;
+  pa_stream*        stream;
+  pa_sample_spec    sample_spec;
+  pa_threaded_mainloop* m;
+
+  pthread_t         thread_id;
+  pthread_mutex_t   mutex;
+
+  char              playing;
+  int64_t           bytes_written;
+  char              client_name[255];
+
+  /* buffer list */
+  sa_buf          * bl_head;
+  sa_buf          * bl_tail;
+  int               n_bufs;
+};
+
+
+/*
+ * Use a default buffer size with enough room for one second of audio,
+ * assuming stereo data at 44.1kHz with 32 bits per channel, and impose
+ * a generous limit on the number of buffers.
+ */
+#define BUF_SIZE    (2 * 44100 * 4)
+#define BUF_LIMIT   5
+
+#if BUF_LIMIT < 2
+#error BUF_LIMIT must be at least 2!
+#endif
+
+static void audio_callback(void* data);
+static void stream_write_callback(pa_stream *stream, size_t length, void *userdata);
+static void stream_latency_update_callback(pa_stream *stream, void *userdata);
+static void context_state_callback(pa_context *c, void *userdata);
+static sa_buf *new_buffer(void);
+
+
+
+/*
+ * -----------------------------------------------------------------------------
+ * Pulseaudio callback functions
+ * -----------------------------------------------------------------------------
+ */
+ 
+static void context_state_callback(pa_context *c, void *userdata) {
+  sa_stream_t* s = (sa_stream_t*)userdata;
+  switch (pa_context_get_state(c)) {
+    case PA_CONTEXT_READY:
+    case PA_CONTEXT_TERMINATED:
+    case PA_CONTEXT_FAILED:
+      pa_threaded_mainloop_signal(s->m, 0);
+      break;
+    case PA_CONTEXT_UNCONNECTED:
+    case PA_CONTEXT_CONNECTING:
+    case PA_CONTEXT_AUTHORIZING:
+    case PA_CONTEXT_SETTING_NAME:
+      break;
+  }
+}
+
+static void stream_state_callback(pa_stream *stream, void *userdata) {
+  sa_stream_t* s = (sa_stream_t*)userdata;
+  switch (pa_stream_get_state(stream)) {
+
+      case PA_STREAM_READY:
+      case PA_STREAM_FAILED:
+      case PA_STREAM_TERMINATED:
+        pa_threaded_mainloop_signal(s->m, 0);
+        break;
+      case PA_STREAM_UNCONNECTED:
+      case PA_STREAM_CREATING:
+        break;
+  }
+}
+
+static void stream_write_callback(pa_stream *stream, size_t length, void *userdata)
+{
+  sa_stream_t* s = (sa_stream_t*)userdata;
+  pa_threaded_mainloop_signal(s->m, 0);
+}
+
+static void stream_latency_update_callback(pa_stream *stream, void *userdata)
+{
+  sa_stream_t* s = (sa_stream_t*)userdata;
+  pa_threaded_mainloop_signal(s->m, 0);
+}
+
+
+
+/*
+ * -----------------------------------------------------------------------------
+ * Startup and shutdown functions
+ * -----------------------------------------------------------------------------
+ */
+
+int
+sa_stream_create_pcm(
+  sa_stream_t      ** _s,
+  const char        * client_name,
+  sa_mode_t           mode,
+  sa_pcm_format_t     format,
+  unsigned  int       rate,
+  unsigned  int       n_channels
+) {
+  sa_stream_t   * s = 0;
+  char *server = NULL;
+
+  /*
+   * Make sure we return a NULL stream pointer on failure.
+   */
+  if (_s == NULL) {
+    return SA_ERROR_INVALID;
+  }
+  *_s = NULL;
+
+  if (mode != SA_MODE_WRONLY) {
+    return SA_ERROR_NOT_SUPPORTED;
+  }
+  if (format != SA_PCM_FORMAT_S16_LE) {
+    return SA_ERROR_NOT_SUPPORTED;
+  }
+
+  /*
+   * Allocate the instance and required resources.
+   */
+  if ((s = malloc(sizeof(sa_stream_t))) == NULL) {
+    return SA_ERROR_OOM;
+  }
+  if ((s->bl_head = new_buffer()) == NULL) {
+    free(s);
+    return SA_ERROR_OOM;
+  }
+
+  if (pthread_mutex_init(&s->mutex, NULL) != 0) {
+    free(s->bl_head);
+    free(s);
+    return SA_ERROR_SYSTEM;
+  }
+
+  s->stream        = NULL;
+  s->m             = NULL;
+  s->thread_id     = 0;
+  s->playing       = 0;
+  s->bytes_written = 0;
+
+  s->bl_tail       = s->bl_head;
+  s->n_bufs        = 1;
+
+  s->sample_spec.format = PA_SAMPLE_S16LE;
+  s->sample_spec.channels = n_channels;
+  s->sample_spec.rate = rate;
+
+  strcpy(s->client_name, client_name);
+
+  /* Set up a new main loop */
+  s->m = pa_threaded_mainloop_new();
+  pa_threaded_mainloop_start(s->m);
+
+  pa_threaded_mainloop_lock(s->m);
+
+  /* Create a new connection context */
+  if (!(s->context = pa_context_new(pa_threaded_mainloop_get_api(s->m), "OggPlay"))) {
+    fprintf(stderr, "pa_context_new() failed.\n");
+    goto unlock_and_fail;
+  }
+  pa_context_set_state_callback(s->context, context_state_callback, s);
+
+  pa_context_connect(s->context, server, 0, NULL);
+
+  /* Wait until the context is ready */
+  pa_threaded_mainloop_wait(s->m);
+  if (pa_context_get_state(s->context) != PA_CONTEXT_READY) {
+    fprintf(stderr, "creating Pulseaudio Context failed\n");
+    goto unlock_and_fail;
+  }
+  pa_threaded_mainloop_unlock(s->m);
+
+  *_s = s;
+  return SA_SUCCESS;
+
+unlock_and_fail:
+  pa_threaded_mainloop_unlock(s->m);
+  free(s);
+  return SA_ERROR_OOM;
+}
+
+int
+sa_stream_open(sa_stream_t *s) {
+  if (s == NULL) {
+    return SA_ERROR_NO_INIT;
+  }
+  if (s->stream != NULL) {
+    return SA_ERROR_INVALID;
+  }
+
+  pa_threaded_mainloop_lock(s->m);
+  if (!(s->stream = pa_stream_new(s->context, s->client_name, &s->sample_spec, NULL))) {
+    fprintf(stderr, "pa_stream_new() failed: %s\n", pa_strerror(pa_context_errno(s->context)));
+    goto unlock_and_fail;
+  }
+
+  pa_stream_set_state_callback(s->stream, stream_state_callback, s);
+  pa_stream_set_write_callback(s->stream, stream_write_callback, s);
+  pa_stream_set_latency_update_callback(s->stream, stream_latency_update_callback, s);
+
+  if (pa_stream_connect_playback(s->stream, NULL, NULL, 0, NULL, NULL) < 0) {
+    fprintf(stderr, "pa_stream_connect_playback() failed: %s\n", pa_strerror(pa_context_errno(s->context)));
+    goto unlock_and_fail;
+  }
+
+  /* Wait until the stream is ready */
+  pa_threaded_mainloop_wait(s->m);
+
+  if (pa_stream_get_state(s->stream) != PA_STREAM_READY) {
+    fprintf(stderr, "Failed to connect stream: %s", pa_strerror(pa_context_errno(s->context)));
+    goto unlock_and_fail;
+  }
+  pa_threaded_mainloop_unlock(s->m);
+
+  if (!s->stream)
+    return SA_ERROR_NO_DEVICE;
+  return SA_SUCCESS;
+
+unlock_and_fail:
+  pa_threaded_mainloop_unlock(s->m);
+  return SA_ERROR_NO_DEVICE;
+}
+
+int
+sa_stream_destroy(sa_stream_t *s) {
+  if (s == NULL) {
+    return SA_SUCCESS;
+  }
+
+  pthread_mutex_lock(&s->mutex);
+  s->thread_id = 0;
+  pthread_mutex_unlock(&s->mutex);
+
+  pa_threaded_mainloop_lock(s->m);
+  pa_stream_disconnect(s->stream);
+  s->stream = NULL;
+  pa_context_disconnect(s->context);
+  pa_context_unref(s->context);
+  s->context = NULL;
+  pa_threaded_mainloop_unlock(s->m);
+
+  pa_threaded_mainloop_stop(s->m);
+  pa_threaded_mainloop_free(s->m);
+
+  pthread_mutex_destroy(&s->mutex);
+
+  while (s->bl_head != NULL) {
+    sa_buf  * next = s->bl_head->next;
+    free(s->bl_head);
+    s->bl_head = next;
+  }
+  free(s);
+
+  return SA_SUCCESS;
+}
+
+
+
+/*
+ * -----------------------------------------------------------------------------
+ * Data read and write functions
+ * -----------------------------------------------------------------------------
+ */
+
+int
+sa_stream_write(sa_stream_t *s, const void *data, size_t nbytes) {
+  int result = SA_SUCCESS;
+
+  if (s == NULL || s->stream == NULL) {
+    return SA_ERROR_NO_INIT;
+  }
+  if (nbytes == 0) {
+    return SA_SUCCESS;
+  }
+
+  pthread_mutex_lock(&s->mutex);
+
+  /*
+   * Append the new data to the end of our buffer list.
+   */
+  while (1) {
+    unsigned int avail = s->bl_tail->size - s->bl_tail->end;
+
+    if (nbytes <= avail) {
+
+      /*
+       * The new data will fit into the current tail buffer, so
+       * just copy it in and we're done.
+       */
+      memcpy(s->bl_tail->data + s->bl_tail->end, data, nbytes);
+      s->bl_tail->end += nbytes;
+      break;
+
+    } else {
+
+      /*
+       * Copy what we can into the tail and allocate a new buffer
+       * for the rest.
+       */
+      memcpy(s->bl_tail->data + s->bl_tail->end, data, avail);
+      s->bl_tail->end += avail;
+      data = ((unsigned char *)data) + avail;
+      nbytes -= avail;
+
+      /* 
+       * If we still have data left to copy but we've hit the limit of
+       * allowable buffer allocations, we need to spin for a bit to allow
+       * the audio callback function to slurp some more data up.
+       */
+      if (nbytes > 0 && s->n_bufs == BUF_LIMIT) {
+        if (!s->playing) {
+          /*
+           * We haven't even started playing yet! That means the
+           * BUF_SIZE/BUF_LIMIT values are too low... Not much we can
+           * do here; spinning won't help because the audio callback
+           * hasn't been enabled yet. Oh well, error time.
+           */
+          printf("Too much audio data received before audio device enabled!\n");
+          result = SA_ERROR_SYSTEM;
+          break;
+        }
+        while (s->n_bufs == BUF_LIMIT) {
+          struct timespec ts = {0, 1000000};
+          pthread_mutex_unlock(&s->mutex);
+          nanosleep(&ts, NULL);
+          pthread_mutex_lock(&s->mutex);
+        }
+      }
+
+      /* 
+       * Allocate a new tail buffer, and go 'round again to fill it up.
+       */
+      if ((s->bl_tail->next = new_buffer()) == NULL) {
+        result = SA_ERROR_OOM;
+        break;
+      }
+      s->n_bufs++;
+      s->bl_tail = s->bl_tail->next;
+    
+    } /* if (nbytes <= avail), else */
+
+  } /* while (1) */
+  pthread_mutex_unlock(&s->mutex);
+  /*
+   * Once we have our first block of audio data, enable the audio callback
+   * function. This doesn't need to be protected by the mutex, because
+   * s->playing is not used in the audio callback thread, and it's probably
+   * better not to be inside the lock when we enable the audio callback.
+   */
+  if (!s->playing) {
+    s->playing = 1;
+    if (pthread_create(&s->thread_id, NULL, (void *)audio_callback, s) != 0) {
+      result = SA_ERROR_SYSTEM;
+    }
+  }
+  return result;
+}
+
+static void audio_callback(void* data)
+{
+  sa_stream_t* s = (sa_stream_t*)data;
+  unsigned int bytes_per_frame = s->sample_spec.channels * pa_sample_size(&s->sample_spec);
+  size_t buffer_size = s->sample_spec.rate * bytes_per_frame;
+  char* buffer = malloc(buffer_size);
+
+  while(1) {
+    char* dst = buffer;
+    size_t bytes_to_copy, bytes;
+
+    pa_threaded_mainloop_lock(s->m);
+    while(1) {
+      if (s == NULL || s->stream == NULL) {
+        if (s != NULL && s->m != NULL) 
+          pa_threaded_mainloop_unlock(s->m);
+        goto free_buffer;
+      }
+      if ((bytes_to_copy = pa_stream_writable_size(s->stream)) == (size_t) -1) {
+        fprintf(stderr, "pa_stream_writable_size() failed: %s", pa_strerror(pa_context_errno(s->context)));
+        pa_threaded_mainloop_unlock(s->m);
+        goto free_buffer;
+      }
+      if(bytes_to_copy > 0)
+        break;
+      pa_threaded_mainloop_wait(s->m);
+    }
+    pa_threaded_mainloop_unlock(s->m);
+    if (bytes_to_copy > buffer_size)
+      bytes_to_copy = buffer_size;
+    bytes = bytes_to_copy;
+
+    pthread_mutex_lock(&s->mutex);
+    if (!s->thread_id) {
+      pthread_mutex_unlock(&s->mutex);
+      break;
+    }
+    /*
+     * Consume data from the start of the buffer list.
+     */
+    while (1) {
+      unsigned int avail = s->bl_head->end - s->bl_head->start;
+      assert(s->bl_head->start <= s->bl_head->end);
+
+      if (avail >= bytes_to_copy) {
+        /*
+         * We have all we need in the head buffer, so just grab it and go.
+         */
+        memcpy(dst, s->bl_head->data + s->bl_head->start, bytes_to_copy);
+        s->bl_head->start += bytes_to_copy;
+        break;
+    
+      } else {
+        sa_buf* next = 0;
+        /*
+         * Copy what we can from the head and move on to the next buffer.
+         */
+        memcpy(dst, s->bl_head->data + s->bl_head->start, avail);
+        s->bl_head->start += avail;
+        dst += avail;
+        bytes_to_copy -= avail;
+        /*
+         * We want to free the now-empty buffer, but not if it's also the
+         * current tail. If it is the tail, we don't have enough data to fill
+         * the destination buffer, so we write less and give up.
+         */
+        next = s->bl_head->next;
+        if (next == NULL) {
+          bytes = bytes-bytes_to_copy;
+          break;
+        }
+        free(s->bl_head);
+        s->bl_head = next;
+        s->n_bufs--;
+      } /* if (avail >= bytes_to_copy), else */
+    } /* while (1) */
+
+    if(bytes > 0) {
+      pa_threaded_mainloop_lock(s->m);
+      if (pa_stream_write(s->stream, buffer, bytes, NULL, 0, PA_SEEK_RELATIVE) < 0) {
+        fprintf(stderr, "pa_stream_write() failed: %s", pa_strerror(pa_context_errno(s->context)));
+        pa_threaded_mainloop_unlock(s->m);
+        return;
+      }
+      pa_stream_update_timing_info(s->stream, NULL, NULL);
+      s->bytes_written += bytes;
+      pa_threaded_mainloop_unlock(s->m);
+    }
+    pthread_mutex_unlock(&s->mutex);
+  }
+free_buffer:
+  free(buffer);
+}
+
+
+/*
+ * -----------------------------------------------------------------------------
+ * General query and support functions
+ * -----------------------------------------------------------------------------
+ */
+
+
+int
+sa_stream_get_write_size(sa_stream_t *s, size_t *size) {
+  sa_buf  * b;
+  size_t    used = 0;
+
+  if (s == NULL || s->stream == NULL) {
+    return SA_ERROR_NO_INIT;
+  }
+
+  pthread_mutex_lock(&s->mutex);
+
+  /*
+   * Sum up the used portions of our buffers and subtract that from
+   * the pre-defined max allowed allocation.
+   */
+  for (b = s->bl_head; b != NULL; b = b->next) {
+    used += b->end - b->start;
+  }
+  *size = BUF_SIZE * BUF_LIMIT - used;
+
+  pthread_mutex_unlock(&s->mutex);
+  return SA_SUCCESS;
+}
+
+
+int
+sa_stream_get_position(sa_stream_t *s, sa_position_t position, int64_t *pos) {
+  pa_usec_t usec;
+  if (s == NULL || s->stream == NULL) {
+    return SA_ERROR_NO_INIT;
+  }
+  if (position != SA_POSITION_WRITE_SOFTWARE) {
+    return SA_ERROR_NOT_SUPPORTED;
+  }
+  pa_threaded_mainloop_lock(s->m);
+  if(pa_stream_get_time(s->stream,  &usec) != PA_ERR_NODATA) {
+    *pos = pa_usec_to_bytes(usec, &s->sample_spec);
+  }
+  else {
+    *pos  = s->bytes_written;
+  }
+  pa_threaded_mainloop_unlock(s->m);
+  return SA_SUCCESS;
+}
+
+
+int
+sa_stream_pause(sa_stream_t *s) {
+  if (s == NULL || s->stream == NULL) {
+    return SA_ERROR_NO_INIT;
+  }
+  return SA_SUCCESS;
+}
+
+
+int
+sa_stream_resume(sa_stream_t *s) {
+  if (s == NULL || s->stream == NULL) {
+    return SA_ERROR_NO_INIT;
+  }
+
+  pa_threaded_mainloop_lock(s->m);
+  s->bytes_written = 0;
+  pa_threaded_mainloop_unlock(s->m);
+  return SA_SUCCESS;
+}
+
+
+static sa_buf *
+new_buffer(void) {
+  sa_buf  * b = malloc(sizeof(sa_buf) + BUF_SIZE);
+  if (b != NULL) {
+    b->size  = BUF_SIZE;
+    b->start = 0;
+    b->end   = 0;
+    b->next  = NULL;
+  }
+  return b;
+}
+
+
+
+/*
+ * -----------------------------------------------------------------------------
+ * Extension functions
+ * -----------------------------------------------------------------------------
+ */
+
+int
+sa_stream_set_volume_abs(sa_stream_t *s, float vol) {
+  pa_cvolume cv;
+
+  if (s == NULL || s->stream == NULL) {
+    return SA_ERROR_NO_INIT;
+  }
+  pa_cvolume_set(&cv, s->sample_spec.channels, pa_sw_volume_from_dB(vol));
+
+  return SA_SUCCESS;
+}
+
+
+int
+sa_stream_get_volume_abs(sa_stream_t *s, float *vol) {
+  if (s == NULL || s->stream == NULL) {
+    return SA_ERROR_NO_INIT;
+  }
+  printf("sa_stream_get_volume_abs not implemented\n");
+  return SA_SUCCESS;
+}
+
+
+/*
+ * -----------------------------------------------------------------------------
+ * Unsupported functions
+ * -----------------------------------------------------------------------------
+ */
+#define UNSUPPORTED(func)   func { return SA_ERROR_NOT_SUPPORTED; }
+
+UNSUPPORTED(int sa_stream_create_opaque(sa_stream_t **s, const char *client_name, sa_mode_t mode, const char *codec))
+UNSUPPORTED(int sa_stream_set_write_lower_watermark(sa_stream_t *s, size_t size))
+UNSUPPORTED(int sa_stream_set_read_lower_watermark(sa_stream_t *s, size_t size))
+UNSUPPORTED(int sa_stream_set_write_upper_watermark(sa_stream_t *s, size_t size))
+UNSUPPORTED(int sa_stream_set_read_upper_watermark(sa_stream_t *s, size_t size))
+UNSUPPORTED(int sa_stream_set_channel_map(sa_stream_t *s, const sa_channel_t map[], unsigned int n))
+UNSUPPORTED(int sa_stream_set_xrun_mode(sa_stream_t *s, sa_xrun_mode_t mode))
+UNSUPPORTED(int sa_stream_set_non_interleaved(sa_stream_t *s, int enable))
+UNSUPPORTED(int sa_stream_set_dynamic_rate(sa_stream_t *s, int enable))
+UNSUPPORTED(int sa_stream_set_driver(sa_stream_t *s, const char *driver))
+UNSUPPORTED(int sa_stream_start_thread(sa_stream_t *s, sa_event_callback_t callback))
+UNSUPPORTED(int sa_stream_stop_thread(sa_stream_t *s))
+UNSUPPORTED(int sa_stream_change_device(sa_stream_t *s, const char *device_name))
+UNSUPPORTED(int sa_stream_change_read_volume(sa_stream_t *s, const int32_t vol[], unsigned int n))
+UNSUPPORTED(int sa_stream_change_write_volume(sa_stream_t *s, const int32_t vol[], unsigned int n))
+UNSUPPORTED(int sa_stream_change_rate(sa_stream_t *s, unsigned int rate))
+UNSUPPORTED(int sa_stream_change_meta_data(sa_stream_t *s, const char *name, const void *data, size_t size))
+UNSUPPORTED(int sa_stream_change_user_data(sa_stream_t *s, const void *value))
+UNSUPPORTED(int sa_stream_set_adjust_rate(sa_stream_t *s, sa_adjust_t direction))
+UNSUPPORTED(int sa_stream_set_adjust_nchannels(sa_stream_t *s, sa_adjust_t direction))
+UNSUPPORTED(int sa_stream_set_adjust_pcm_format(sa_stream_t *s, sa_adjust_t direction))
+UNSUPPORTED(int sa_stream_set_adjust_watermarks(sa_stream_t *s, sa_adjust_t direction))
+UNSUPPORTED(int sa_stream_get_mode(sa_stream_t *s, sa_mode_t *access_mode))
+UNSUPPORTED(int sa_stream_get_codec(sa_stream_t *s, char *codec, size_t *size))
+UNSUPPORTED(int sa_stream_get_pcm_format(sa_stream_t *s, sa_pcm_format_t *format))
+UNSUPPORTED(int sa_stream_get_rate(sa_stream_t *s, unsigned int *rate))
+UNSUPPORTED(int sa_stream_get_nchannels(sa_stream_t *s, int *nchannels))
+UNSUPPORTED(int sa_stream_get_user_data(sa_stream_t *s, void **value))
+UNSUPPORTED(int sa_stream_get_write_lower_watermark(sa_stream_t *s, size_t *size))
+UNSUPPORTED(int sa_stream_get_read_lower_watermark(sa_stream_t *s, size_t *size))
+UNSUPPORTED(int sa_stream_get_write_upper_watermark(sa_stream_t *s, size_t *size))
+UNSUPPORTED(int sa_stream_get_read_upper_watermark(sa_stream_t *s, size_t *size))
+UNSUPPORTED(int sa_stream_get_channel_map(sa_stream_t *s, sa_channel_t map[], unsigned int *n))
+UNSUPPORTED(int sa_stream_get_xrun_mode(sa_stream_t *s, sa_xrun_mode_t *mode))
+UNSUPPORTED(int sa_stream_get_non_interleaved(sa_stream_t *s, int *enabled))
+UNSUPPORTED(int sa_stream_get_dynamic_rate(sa_stream_t *s, int *enabled))
+UNSUPPORTED(int sa_stream_get_driver(sa_stream_t *s, char *driver_name, size_t *size))
+UNSUPPORTED(int sa_stream_get_device(sa_stream_t *s, char *device_name, size_t *size))
+UNSUPPORTED(int sa_stream_get_read_volume(sa_stream_t *s, int32_t vol[], unsigned int *n))
+UNSUPPORTED(int sa_stream_get_write_volume(sa_stream_t *s, int32_t vol[], unsigned int *n))
+UNSUPPORTED(int sa_stream_get_meta_data(sa_stream_t *s, const char *name, void*data, size_t *size))
+UNSUPPORTED(int sa_stream_get_adjust_rate(sa_stream_t *s, sa_adjust_t *direction))
+UNSUPPORTED(int sa_stream_get_adjust_nchannels(sa_stream_t *s, sa_adjust_t *direction))
+UNSUPPORTED(int sa_stream_get_adjust_pcm_format(sa_stream_t *s, sa_adjust_t *direction))
+UNSUPPORTED(int sa_stream_get_adjust_watermarks(sa_stream_t *s, sa_adjust_t *direction))
+UNSUPPORTED(int sa_stream_get_state(sa_stream_t *s, sa_state_t *state))
+UNSUPPORTED(int sa_stream_get_event_error(sa_stream_t *s, sa_error_t *error))
+UNSUPPORTED(int sa_stream_get_event_notify(sa_stream_t *s, sa_notify_t *notify))
+UNSUPPORTED(int sa_stream_read(sa_stream_t *s, void *data, size_t nbytes))
+UNSUPPORTED(int sa_stream_read_ni(sa_stream_t *s, unsigned int channel, void *data, size_t nbytes))
+UNSUPPORTED(int sa_stream_write_ni(sa_stream_t *s, unsigned int channel, const void *data, size_t nbytes))
+UNSUPPORTED(int sa_stream_pwrite(sa_stream_t *s, const void *data, size_t nbytes, int64_t offset, sa_seek_t whence))
+UNSUPPORTED(int sa_stream_pwrite_ni(sa_stream_t *s, unsigned int channel, const void *data, size_t nbytes, int64_t offset, sa_seek_t whence))
+UNSUPPORTED(int sa_stream_get_read_size(sa_stream_t *s, size_t *size))
+UNSUPPORTED(int sa_stream_drain(sa_stream_t *s))
+
+const char *sa_strerror(int code) { return NULL; }
+
diff -r 4b060ed856e0 media/libsydneyaudio/src/sydney_audio_sunaudio.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/media/libsydneyaudio/src/sydney_audio_sunaudio.c	Thu Oct 16 21:24:49 2008 -0500
@@ -0,0 +1,407 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Initial Developer of the Original Code is
+ * Copyright (C) 2008 Sun Microsystems, Inc.,
+ *                Brian Lu <brian.lu@sun.com>
+ *
+ * Contributor(s): 
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** *
+ */
+#include <stdlib.h>
+#include <pthread.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stropts.h>
+#include <sys/audio.h>
+#include <sys/mixer.h>
+#include <errno.h>
+#include <stdio.h>
+#include <pthread.h>
+#include "sydney_audio.h"
+
+#define DEFAULT_AUDIO_DEVICE "/dev/audio" 
+
+#define LOOP_WHILE_EINTR(v,func) do { (v) = (func); } \
+                while ((v) == -1 && errno == EINTR);
+
+struct sa_stream 
+{
+  int        audio_fd;
+
+  /* audio format info */
+  /* default setting */
+  unsigned int      default_n_channels;
+  unsigned int      default_rate;
+  unsigned int      default_precision;
+
+  /* used settings */
+  unsigned int      rate;
+  unsigned int      n_channels;
+  unsigned int      precision;
+  int64_t           bytes_played;
+
+};
+
+
+/*
+ * -----------------------------------------------------------------------------
+ * Startup and shutdown functions
+ * -----------------------------------------------------------------------------
+ */
+
+int
+sa_stream_create_pcm(
+  sa_stream_t      ** _s,
+  const char        * client_name,
+  sa_mode_t           mode,
+  sa_pcm_format_t     format,
+  unsigned  int       rate,
+  unsigned  int       n_channels
+) 
+{
+  sa_stream_t   * s = 0;
+
+  /* Make sure we return a NULL stream pointer on failure. */
+  if (_s == NULL) 
+    return SA_ERROR_INVALID;
+
+  *_s = NULL;
+
+  if (mode != SA_MODE_WRONLY) 
+    return SA_ERROR_NOT_SUPPORTED;
+
+  if (format != SA_PCM_FORMAT_S16_LE) 
+    return SA_ERROR_NOT_SUPPORTED;
+
+  /*
+   * Allocate the instance and required resources.
+   */
+  if ((s = malloc(sizeof(sa_stream_t))) == NULL) 
+    return SA_ERROR_OOM;
+
+  s->audio_fd = NULL;
+
+  s->rate = rate;
+  s->n_channels = n_channels;
+  s->precision = 16;
+  s->bytes_played = 0;
+
+  *_s = s;
+
+  return SA_SUCCESS;
+}
+
+
+int
+sa_stream_open(sa_stream_t *s) 
+{
+  int fd,err;
+  audio_info_t audio_info;
+  char *device_name;
+  
+  /* according to the sun audio manual (man audio(7I))
+   * use the device name set in AUDIODEV
+   * environment variaible if it is set 
+   */
+  device_name = getenv("AUDIODEV");
+  if (!device_name)
+    device_name = DEFAULT_AUDIO_DEVICE;
+
+  if (s == NULL) 
+    return SA_ERROR_NO_INIT;
+
+  if (s->audio_fd != NULL) 
+    return SA_ERROR_INVALID;
+
+  fd = open(device_name,O_WRONLY | O_NONBLOCK);
+  if (fd >= 0) 
+  {
+     close (fd);
+     fd = open (device_name, O_WRONLY);
+  }
+
+  if ( fd < 0 )
+  {
+    printf("Open %s failed:%s ",device_name,strerror(errno));
+    return SA_ERROR_NO_DEVICE;
+  }
+  
+  AUDIO_INITINFO(&audio_info);
+
+  // save the default settings for resetting
+  err = ioctl(fd, AUDIO_GETINFO, &audio_info); 
+  if (err == -1)
+  {
+    perror("ioctl AUDIO_GETINFO failed");
+    close(fd);
+    return SA_ERROR_SYSTEM;
+  }
+
+  s->default_n_channels = audio_info.play.channels; 
+  s->default_rate = audio_info.play.sample_rate; 
+  s->default_precision =  audio_info.play.precision; 
+
+  AUDIO_INITINFO(&audio_info)
+
+  audio_info.play.sample_rate = s->rate;
+  audio_info.play.channels = s->n_channels;
+  audio_info.play.precision = s->precision;
+
+  /* Signed Linear PCM encoding */
+  audio_info.play.encoding = AUDIO_ENCODING_LINEAR;
+
+  err=ioctl(fd,AUDIO_SETINFO,&audio_info);
+  if (err== -1)
+    return SA_ERROR_NOT_SUPPORTED;
+
+  AUDIO_INITINFO(&audio_info)
+  err=ioctl(fd,AUDIO_GETINFO,&audio_info);
+  if (err== -1)
+  {
+    perror("ioctl AUDIO_SETINFO failed"); 
+    return SA_ERROR_NOT_SUPPORTED;
+  }
+
+  s->audio_fd = fd;
+
+  return SA_SUCCESS;
+}
+
+int
+sa_stream_destroy(sa_stream_t *s) 
+{
+  int result = SA_SUCCESS;
+
+  if (s == NULL) 
+    return SA_SUCCESS;
+
+  /*
+   * Shut down the audio output device.
+   */
+  if (s->audio_fd != NULL) 
+  {
+    if (close(s->audio_fd) < 0) 
+    {
+      perror("Close sun audio fd failed");
+      result = SA_ERROR_SYSTEM;
+    }
+  }
+
+  free(s);
+
+  return result;
+}
+
+/*
+ * -----------------------------------------------------------------------------
+ * Data read and write functions
+ * -----------------------------------------------------------------------------
+ */
+
+int
+sa_stream_write(sa_stream_t *s, const void *data, size_t nbytes) 
+{
+
+  int result = SA_SUCCESS;
+  int total = 0;
+  int bytes = 0;
+  int fd;
+  int i;
+  audio_info_t ainfo;
+
+  if (s == NULL || s->audio_fd == NULL) 
+    return SA_ERROR_NO_INIT;
+
+  if (nbytes == 0) 
+    return SA_SUCCESS;
+
+  fd = s->audio_fd;
+
+  while (total < nbytes ) 
+  {
+    LOOP_WHILE_EINTR(bytes,(write(fd, (void *)(((unsigned char *)data)  total), nbytes-total)));
+
+    total = bytes;
+    if (total != nbytes)
+      printf("SunAudio\tWrite completed short - %d vs %d. Write more data\n",total,nbytes);
+  }
+
+  s->bytes_played += nbytes;
+
+  return result;
+}
+
+
+
+/*
+ * -----------------------------------------------------------------------------
+ * General query and support functions
+ * -----------------------------------------------------------------------------
+ */
+
+int
+sa_stream_get_position(sa_stream_t *s, sa_position_t position, int64_t *pos) 
+{
+
+  if (s == NULL || s->audio_fd == NULL) 
+    return SA_ERROR_NO_INIT;
+
+  if (position != SA_POSITION_WRITE_SOFTWARE) 
+    return SA_ERROR_NOT_SUPPORTED;
+
+  *pos = s->bytes_played;
+  return SA_SUCCESS;
+}
+
+/*
+ * -----------------------------------------------------------------------------
+ * Extension functions
+ * -----------------------------------------------------------------------------
+ */
+
+int
+sa_stream_set_volume_abs(sa_stream_t *s, float vol) 
+{
+  unsigned int newVolume = 0;
+  int err;
+  audio_info_t audio_info;
+
+
+  newVolume = (AUDIO_MAX_GAIN-AUDIO_MIN_GAIN)*volAUDIO_MIN_GAIN;
+
+  /* Check if the new volume is valid or not */
+  if ( newVolume < AUDIO_MIN_GAIN || newVolume > AUDIO_MAX_GAIN )
+    return SA_ERROR_INVALID;
+
+  AUDIO_INITINFO(&audio_info);
+  audio_info.play.gain = newVolume;
+  err=ioctl(s->audio_fd,AUDIO_SETINFO,&audio_info);    // The actual setting of the parameters
+  if (err == -1)
+  {
+    perror("sa_stream_set_volume_abs failed") ; 
+    return SA_ERROR_SYSTEM;
+  }
+
+  return SA_SUCCESS;
+}
+
+int
+sa_stream_get_volume_abs(sa_stream_t *s, float *vol) 
+{
+  float volume;
+  int err;
+  audio_info_t audio_info;
+
+  if (s == NULL || s->audio_fd == NULL) {
+    return SA_ERROR_NO_INIT;
+  }
+
+  AUDIO_INITINFO(&audio_info);
+  err=ioctl(s->audio_fd,AUDIO_GETINFO,&audio_info);
+  if (err == -1)
+  {
+    perror("sa_stream_get_volume_abs failed");
+    return SA_ERROR_SYSTEM;
+  }
+
+  volume =  (float)((audio_info.play.gain - AUDIO_MIN_GAIN))/(AUDIO_MAX_GAIN - AUDIO_MIN_GAIN); 
+
+  *vol = volume;
+
+  return SA_SUCCESS;
+}
+
+/*
+ * -----------------------------------------------------------------------------
+ * Unsupported functions
+ * -----------------------------------------------------------------------------
+ */
+#define UNSUPPORTED(func)   func { return SA_ERROR_NOT_SUPPORTED; }
+
+UNSUPPORTED(int sa_stream_pause(sa_stream_t *s)) 
+UNSUPPORTED(int sa_stream_resume(sa_stream_t *s)) 
+UNSUPPORTED(int sa_stream_create_opaque(sa_stream_t **s, const char *client_name, sa_mode_t mode, const char *codec))
+UNSUPPORTED(int sa_stream_set_write_lower_watermark(sa_stream_t *s, size_t size))
+UNSUPPORTED(int sa_stream_set_read_lower_watermark(sa_stream_t *s, size_t size))
+UNSUPPORTED(int sa_stream_set_write_upper_watermark(sa_stream_t *s, size_t size))
+UNSUPPORTED(int sa_stream_set_read_upper_watermark(sa_stream_t *s, size_t size))
+UNSUPPORTED(int sa_stream_set_channel_map(sa_stream_t *s, const sa_channel_t map[], unsigned int n))
+UNSUPPORTED(int sa_stream_set_xrun_mode(sa_stream_t *s, sa_xrun_mode_t mode))
+UNSUPPORTED(int sa_stream_set_non_interleaved(sa_stream_t *s, int enable))
+UNSUPPORTED(int sa_stream_set_dynamic_rate(sa_stream_t *s, int enable))
+UNSUPPORTED(int sa_stream_set_driver(sa_stream_t *s, const char *driver))
+UNSUPPORTED(int sa_stream_start_thread(sa_stream_t *s, sa_event_callback_t callback))
+UNSUPPORTED(int sa_stream_stop_thread(sa_stream_t *s))
+UNSUPPORTED(int sa_stream_change_device(sa_stream_t *s, const char *device_name))
+UNSUPPORTED(int sa_stream_change_read_volume(sa_stream_t *s, const int32_t vol[], unsigned int n))
+UNSUPPORTED(int sa_stream_change_write_volume(sa_stream_t *s, const int32_t vol[], unsigned int n))
+UNSUPPORTED(int sa_stream_change_rate(sa_stream_t *s, unsigned int rate))
+UNSUPPORTED(int sa_stream_change_meta_data(sa_stream_t *s, const char *name, const void *data, size_t size))
+UNSUPPORTED(int sa_stream_change_user_data(sa_stream_t *s, const void *value))
+UNSUPPORTED(int sa_stream_set_adjust_rate(sa_stream_t *s, sa_adjust_t direction))
+UNSUPPORTED(int sa_stream_set_adjust_nchannels(sa_stream_t *s, sa_adjust_t direction))
+UNSUPPORTED(int sa_stream_set_adjust_pcm_format(sa_stream_t *s, sa_adjust_t direction))
+UNSUPPORTED(int sa_stream_set_adjust_watermarks(sa_stream_t *s, sa_adjust_t direction))
+UNSUPPORTED(int sa_stream_get_mode(sa_stream_t *s, sa_mode_t *access_mode))
+UNSUPPORTED(int sa_stream_get_codec(sa_stream_t *s, char *codec, size_t *size))
+UNSUPPORTED(int sa_stream_get_pcm_format(sa_stream_t *s, sa_pcm_format_t *format))
+UNSUPPORTED(int sa_stream_get_rate(sa_stream_t *s, unsigned int *rate))
+UNSUPPORTED(int sa_stream_get_nchannels(sa_stream_t *s, int *nchannels))
+UNSUPPORTED(int sa_stream_get_user_data(sa_stream_t *s, void **value))
+UNSUPPORTED(int sa_stream_get_write_lower_watermark(sa_stream_t *s, size_t *size))
+UNSUPPORTED(int sa_stream_get_read_lower_watermark(sa_stream_t *s, size_t *size))
+UNSUPPORTED(int sa_stream_get_write_upper_watermark(sa_stream_t *s, size_t *size))
+UNSUPPORTED(int sa_stream_get_read_upper_watermark(sa_stream_t *s, size_t *size))
+UNSUPPORTED(int sa_stream_get_channel_map(sa_stream_t *s, sa_channel_t map[], unsigned int *n))
+UNSUPPORTED(int sa_stream_get_xrun_mode(sa_stream_t *s, sa_xrun_mode_t *mode))
+UNSUPPORTED(int sa_stream_get_non_interleaved(sa_stream_t *s, int *enabled))
+UNSUPPORTED(int sa_stream_get_dynamic_rate(sa_stream_t *s, int *enabled))
+UNSUPPORTED(int sa_stream_get_driver(sa_stream_t *s, char *driver_name, size_t *size))
+UNSUPPORTED(int sa_stream_get_device(sa_stream_t *s, char *device_name, size_t *size))
+UNSUPPORTED(int sa_stream_get_read_volume(sa_stream_t *s, int32_t vol[], unsigned int *n))
+UNSUPPORTED(int sa_stream_get_write_volume(sa_stream_t *s, int32_t vol[], unsigned int *n))
+UNSUPPORTED(int sa_stream_get_meta_data(sa_stream_t *s, const char *name, void*data, size_t *size))
+UNSUPPORTED(int sa_stream_get_adjust_rate(sa_stream_t *s, sa_adjust_t *direction))
+UNSUPPORTED(int sa_stream_get_adjust_nchannels(sa_stream_t *s, sa_adjust_t *direction))
+UNSUPPORTED(int sa_stream_get_adjust_pcm_format(sa_stream_t *s, sa_adjust_t *direction))
+UNSUPPORTED(int sa_stream_get_adjust_watermarks(sa_stream_t *s, sa_adjust_t *direction))
+UNSUPPORTED(int sa_stream_get_state(sa_stream_t *s, sa_state_t *state))
+UNSUPPORTED(int sa_stream_get_event_error(sa_stream_t *s, sa_error_t *error))
+UNSUPPORTED(int sa_stream_get_event_notify(sa_stream_t *s, sa_notify_t *notify))
+UNSUPPORTED(int sa_stream_read(sa_stream_t *s, void *data, size_t nbytes))
+UNSUPPORTED(int sa_stream_read_ni(sa_stream_t *s, unsigned int channel, void *data, size_t nbytes))
+UNSUPPORTED(int sa_stream_write_ni(sa_stream_t *s, unsigned int channel, const void *data, size_t nbytes))
+UNSUPPORTED(int sa_stream_pwrite(sa_stream_t *s, const void *data, size_t nbytes, int64_t offset, sa_seek_t whence))
+UNSUPPORTED(int sa_stream_pwrite_ni(sa_stream_t *s, unsigned int channel, const void *data, size_t nbytes, int64_t offset, sa_seek_t whence))
+UNSUPPORTED(int sa_stream_get_read_size(sa_stream_t *s, size_t *size))
+UNSUPPORTED(int sa_stream_drain(sa_stream_t *s))
+
+const char *sa_strerror(int code) { return NULL; }
+
diff -r 4b060ed856e0 media/libsydneyaudio/src/sydney_audio_waveapi.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/media/libsydneyaudio/src/sydney_audio_waveapi.c	Thu Oct 16 21:24:49 2008 -0500
@@ -0,0 +1,711 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Initial Developer of the Original Code is
+ * CSIRO
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s): Marcin Lubonski 
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** *
+ */
+
+#include "sydney_audio.h"
+#include <stdio.h>
+#include <stdlib.h>
+
+#include <windows.h>
+#include <mmreg.h>
+#include <mmsystem.h>
+#include <math.h>
+
+
+// FIX ME: block size and block should be determined based on the OggPlay offset 
+// for audio track
+#define BLOCK_SIZE  2560
+#define BLOCK_COUNT 32
+#define DEFAULT_DEVICE_NAME "Default WAVE Device"
+#define DEFAULT_DEVICE WAVE_MAPPER
+
+#define VERBOSE_OUTPUT 1
+
+// INFO: if you get weird compile errors make sure there is no extra chars pass '\' 
+#if defined(VERBOSE_OUTPUT)
+#define WAVE_ERROR_VERBOSE(error, message) \
+  switch (error) { \
+    case MMSYSERR_ALLOCATED: \
+      printf("[WAVE API] Device allocation error returned while executing %s\n", message); \
+      break; \
+    case MMSYSERR_BADDEVICEID: \
+      printf("[WAVE API] Wrong device ID error returned while executing %s\n", message); \
+      break; \
+    case MMSYSERR_NODRIVER: \
+      printf("[WAVE API] System driver not present error returned while executing %s\n", message); \
+      break; \
+    case MMSYSERR_INVALHANDLE: \
+      printf("[WAVE API] Invalid device handle error returned while executing %s\n", message); \
+      break; \
+    case MMSYSERR_NOMEM: \
+      printf("[WAVE API] No memory error returned while executing %s\n", message); \
+      break; \
+    case MMSYSERR_NOTSUPPORTED: \
+      printf("[WAVE API] Not supported error returned while executing %s\n", message); \
+      break; \
+    case WAVERR_BADFORMAT: \
+      printf("[WAVE API] Not valid audio format returned while executing %s\n", message); \
+      break; \
+    case WAVERR_SYNC: \
+      printf("[WAVE API] Device synchronous error returned while executing %s\n", message); \
+      break; \
+    default: \
+      printf("[WAVE API] Error while executing %s\n", message); \
+      break; \
+  }
+#else
+#define WAVE_ERROR_VERBOSE(error, message) \
+  do {} while(0)
+#endif
+
+#define HANDLE_WAVE_ERROR(status, location) \
+  if (status != MMSYSERR_NOERROR) { \
+      WAVE_ERROR_VERBOSE(status, location); \
+      return getSAErrorCode(status); \
+  }
+
+#define ERROR_IF_NO_INIT(handle) \
+  if (handle == NULL) { \
+		return SA_ERROR_NO_INIT; \
+	}
+
+/* local implementation of the sa_stream_t type */
+struct sa_stream {   
+  char*           deviceName;
+  UINT				    device;
+  UINT				    channels;
+  UINT				    rate;
+	
+  sa_mode_t			  rwMode;
+  sa_pcm_format_t	format;   
+ 
+  HWAVEOUT			  hWaveOut;
+  HANDLE			    callbackEvent;
+  CRITICAL_SECTION  waveCriticalSection;  
+  WAVEHDR*			  waveBlocks;  
+  volatile int		waveFreeBlockCount;
+  int				      waveCurrentBlock;
+};
+
+
+/** Forward definitions of audio api specific functions */
+int allocateBlocks(int size, int count, WAVEHDR** blocks);
+int freeBlocks(WAVEHDR* blocks);
+int openAudio(sa_stream_t *s);
+int closeAudio(sa_stream_t * s);
+int writeAudio(sa_stream_t *s, LPSTR data, int bytes);
+int getSAErrorCode(int waveErrorCode);
+
+void CALLBACK waveOutProc(HWAVEOUT hWaveOut, UINT uMsg, 
+    DWORD dwInstance, DWORD dwParam1, DWORD dwParam2);
+
+/** Normal way to open a PCM device */
+int sa_stream_create_pcm(sa_stream_t **s, 
+                         const char *client_name, 
+                         sa_mode_t mode, 
+                         sa_pcm_format_t format, 
+                         unsigned int rate, 
+                         unsigned int nchannels) {
+  sa_stream_t * _s = NULL;
+  
+  ERROR_IF_NO_INIT(s);
+  
+  *s = NULL;
+  
+  /* FIX ME: for formats different than PCM extend using WAVEFORMATEXTENSIBLE */
+  if (format != SA_PCM_FORMAT_S16_NE) {
+    return SA_ERROR_NOT_SUPPORTED;
+  }
+
+  if (mode != SA_MODE_WRONLY) {
+    return SA_ERROR_NOT_SUPPORTED;
+  }
+
+  if ((_s = (sa_stream_t*)malloc(sizeof(sa_stream_t))) == NULL) {
+    return SA_ERROR_OOM;
+  }
+   
+  _s->rwMode = mode;
+  _s->format = format;
+  _s->rate = rate;
+  _s->channels = nchannels;
+  _s->deviceName = DEFAULT_DEVICE_NAME;
+  _s->device = DEFAULT_DEVICE;
+
+  *s = _s; 
+  return SA_SUCCESS;
+}
+
+/** Initialise the device */
+int sa_stream_open(sa_stream_t *s) {  
+  int status = SA_SUCCESS;
+
+  ERROR_IF_NO_INIT(s);
+
+  switch (s->rwMode) {
+    case SA_MODE_WRONLY: 
+      status = openAudio(s);
+      break;
+	default:
+      status = SA_ERROR_NOT_SUPPORTED;      
+      break;
+  }    
+  return status;
+}
+
+/** Interleaved playback function */
+int sa_stream_write(sa_stream_t *s, const void *data, size_t nbytes) {
+  int status = SA_SUCCESS;
+
+  ERROR_IF_NO_INIT(s);
+
+  status = writeAudio(s, (LPSTR)data, nbytes);
+
+  return status;
+}
+
+/** Query how much can be written without blocking */
+int sa_stream_get_write_size(sa_stream_t *s, size_t *size) {
+  unsigned int avail;
+  WAVEHDR* current;
+
+  ERROR_IF_NO_INIT(s);
+
+  EnterCriticalSection(&(s->waveCriticalSection));
+  avail = s->waveFreeBlockCount * BLOCK_SIZE;
+  if (s->waveFreeBlockCount != BLOCK_COUNT) {
+    current = &(s->waveBlocks[s->waveCurrentBlock]);
+    avail += BLOCK_SIZE - current->dwUser;
+  }
+  LeaveCriticalSection(&(s->waveCriticalSection));
+
+  *size = avail;
+
+  return SA_SUCCESS;
+}
+
+/** Close/destroy everything */
+int sa_stream_destroy(sa_stream_t *s) {
+  int status;
+
+  ERROR_IF_NO_INIT(s);
+  /* close and release all allocated resources */
+  status = closeAudio(s);
+
+  return status;
+}
+
+#define LEFT_CHANNEL_MASK 0x0000FFFF
+#define RIGHT_CHANNEL_MASK 0xFFFF0000
+
+/** 
+ * retrieved volume as an int in a scale from 0x0000 to 0xFFFF
+ * only one value for all channels
+ */
+int sa_stream_get_write_volume(sa_stream_t *s, int32_t vol[], unsigned int *n) {
+  int status;
+	DWORD volume;
+	WORD left;
+	WORD right;
+
+	ERROR_IF_NO_INIT(s);
+  
+	status = waveOutGetVolume(s->hWaveOut, &volume);
+	HANDLE_WAVE_ERROR(status, "reading audio volume level");
+
+	left = volume & LEFT_CHANNEL_MASK;
+	right = (volume & RIGHT_CHANNEL_MASK) >> 16;
+  vol[0] = (int32_t)(left + right /2);	
+
+	return SA_SUCCESS;
+
+}
+
+/** changes volume as an int in a scale from 0x0000 to 0xFFFF*/
+int sa_stream_change_write_volume(sa_stream_t *s, const int32_t vol[], unsigned int n) {
+  int status;
+	DWORD volume;
+	WORD left;
+	WORD right;
+	
+	ERROR_IF_NO_INIT(s);
+	
+  volume = (DWORD)vol[0];
+	left = volume & LEFT_CHANNEL_MASK;	  
+	right = left;	  
+	volume =  (left << 16) | right;	
+	
+	status = waveOutSetVolume(s->hWaveOut, volume);
+	HANDLE_WAVE_ERROR(status, "setting new audio volume level");	
+
+	return SA_SUCCESS;
+
+
+}
+
+/** sync/timing */
+int sa_stream_get_position(sa_stream_t *s, sa_position_t position, int64_t *pos) {
+	int status;
+  MMTIME  mm;
+
+  ERROR_IF_NO_INIT(s);
+
+  if (position != SA_POSITION_WRITE_HARDWARE) {
+    return SA_ERROR_NOT_SUPPORTED;
+  }
+  // request playback progress in bytes
+  mm.wType = TIME_BYTES;		
+	status = waveOutGetPosition(s->hWaveOut, &mm, sizeof(MMTIME));
+  HANDLE_WAVE_ERROR(status, "reading audio buffer position");
+  *pos = (int64_t)mm.u.cb;
+
+	return SA_SUCCESS;
+}
+
+/* Control/xrun */
+/** Resume playing after a pause */
+int sa_stream_resume(sa_stream_t *s) {
+  int status;  
+  
+  ERROR_IF_NO_INIT(s);
+
+  status = waveOutRestart(s->hWaveOut);
+  HANDLE_WAVE_ERROR(status, "resuming audio playback");
+
+  return SA_SUCCESS;
+}
+/** Pause audio playback (do not empty the buffer) */
+int sa_stream_pause(sa_stream_t *s) {
+  int status;
+
+  ERROR_IF_NO_INIT(s);
+  
+  status = waveOutPause(s->hWaveOut);
+  HANDLE_WAVE_ERROR(status, "resuming audio playback");
+
+  return SA_SUCCESS;
+}
+/** Block until all audio has been played */
+int sa_stream_drain(sa_stream_t *s) {
+  ERROR_IF_NO_INIT(s);
+  
+  /* wait for all blocks to complete */
+  EnterCriticalSection(&(s->waveCriticalSection));
+  while(s->waveFreeBlockCount < BLOCK_COUNT) {
+    LeaveCriticalSection(&(s->waveCriticalSection));
+    Sleep(10);
+    EnterCriticalSection(&(s->waveCriticalSection));
+  }
+  LeaveCriticalSection(&(s->waveCriticalSection));
+
+  return SA_SUCCESS;
+}
+
+/*
+ * -----------------------------------------------------------------------------
+ * Private WAVE API specific functions
+ * -----------------------------------------------------------------------------
+ */
+
+/** 
+ * \brief - allocate buffer for writing to system WAVE audio device
+ * \param size - size of each audio block
+ * \param cound - number of blocks to be allocated
+ * \param blocks - pointer to the blocks buffer to be allocated
+ * \return - completion status
+ */
+int allocateBlocks(int size, int count, WAVEHDR** blocks)
+{
+  unsigned char* buffer;    
+  int i;    
+  WAVEHDR* headers;
+  DWORD totalBufferSize = (size + sizeof(WAVEHDR)) * count;
+    
+  /* allocate memory on heap for the entire set in one go  */    
+  if((buffer = HeapAlloc(
+     GetProcessHeap(), 
+     HEAP_ZERO_MEMORY, 
+     totalBufferSize
+     )) == NULL) {
+      printf("Memory allocation error\n");
+      return SA_ERROR_OOM;
+    }
+
+  /* and set up the pointers to each bit */
+  headers = *blocks = (WAVEHDR*)buffer;
+  buffer += sizeof(WAVEHDR) * count;
+  for(i = 0; i < count; i++) {    
+	  headers[i].dwBufferLength = size;
+    headers[i].lpData = buffer;
+    buffer += size;
+  }
+    
+  return SA_SUCCESS;
+}
+
+/**
+ * \brief - free allocated audio buffer
+ * \param blocks - pointer to allocated the buffer of audio bloks
+ * \return - completion status
+ */
+int freeBlocks(WAVEHDR* blocks)
+{    
+  if (blocks == NULL) 
+    return SA_ERROR_INVALID;
+
+  /* and this is why allocateBlocks works the way it does */     
+  HeapFree(GetProcessHeap(), 0, blocks);
+  blocks = NULL;
+
+  return SA_SUCCESS;
+}
+
+/** 
+ * \brief - open system default WAVE device
+ * \param s - sydney audio stream handle
+ * \return - completion status
+ */ 
+int openAudio(sa_stream_t *s) {
+  int status;
+  WAVEFORMATEX wfx;    
+  UINT supported = FALSE;
+		  
+  status = allocateBlocks(BLOCK_SIZE, BLOCK_COUNT, &(s->waveBlocks));  
+	HANDLE_WAVE_ERROR(status, "allocating audio buffer blocks");
+  
+  s->waveFreeBlockCount	= BLOCK_COUNT;
+  s->waveCurrentBlock	= 0;  
+  wfx.nSamplesPerSec	= (DWORD)s->rate;	/* sample rate */
+  wfx.wBitsPerSample	= 16;				/* sample size */
+  wfx.nChannels			= s->channels;	/* channels    */
+  wfx.cbSize			= 0;				/* size of _extra_ info */
+  wfx.wFormatTag		= WAVE_FORMAT_PCM;
+  wfx.nBlockAlign		= (wfx.wBitsPerSample * wfx.nChannels) >> 3;
+  wfx.nAvgBytesPerSec	= wfx.nBlockAlign * wfx.nSamplesPerSec;
+
+  supported = waveOutOpen(NULL, WAVE_MAPPER, &wfx, (DWORD_PTR)0, (DWORD_PTR)0, 
+				WAVE_FORMAT_QUERY);
+  if (supported == MMSYSERR_NOERROR) { // audio device opened sucessfully 
+    status = waveOutOpen((LPHWAVEOUT)&(s->hWaveOut), WAVE_MAPPER, &wfx, 
+	  (DWORD_PTR)waveOutProc, (DWORD_PTR)s, CALLBACK_FUNCTION);
+    HANDLE_WAVE_ERROR(status, "opening audio device for playback");
+		printf("Audio device sucessfully opened\n");
+  } 
+  else if (supported == WAVERR_BADFORMAT) {
+    printf("Requested format not supported...\n");
+	  // clean up the memory
+	  freeBlocks(s->waveBlocks);
+    return SA_ERROR_NOT_SUPPORTED;
+  } 
+  else {
+    printf("Error opening default audio device. Exiting...\n");
+	  // clean up the memory
+	  freeBlocks(s->waveBlocks);
+    return SA_ERROR_SYSTEM;
+  }
+  // create notification for data written to a device
+  s->callbackEvent = CreateEvent(0, FALSE, FALSE, 0);
+  // initialise critical section for operations on waveFreeBlockCound variable
+  InitializeCriticalSection(&(s->waveCriticalSection));
+
+  return SA_SUCCESS;
+}
+/**
+ * \brief - closes opened audio device handle
+ * \param s - sydney audio stream handle
+ * \return - completion status
+ */
+int closeAudio(sa_stream_t * s) {
+  int status, i;
+  
+  // reseting audio device and flushing buffers
+  status = waveOutReset(s->hWaveOut);    
+  HANDLE_WAVE_ERROR(status, "resetting audio device");
+  
+  /* wait for all blocks to complete */  
+  while(s->waveFreeBlockCount < BLOCK_COUNT)
+	  Sleep(10);
+
+  /* unprepare any blocks that are still prepared */  
+  for(i = 0; i < s->waveFreeBlockCount; i++) {
+    if(s->waveBlocks[i].dwFlags & WHDR_PREPARED) {
+	    status = waveOutUnprepareHeader(s->hWaveOut, &(s->waveBlocks[i]), sizeof(WAVEHDR));
+      HANDLE_WAVE_ERROR(status, "closing audio device");
+    }
+  }    
+
+  freeBlocks(s->waveBlocks);  
+  status = waveOutClose(s->hWaveOut);    
+  HANDLE_WAVE_ERROR(status, "closing audio device");
+
+  DeleteCriticalSection(&(s->waveCriticalSection));
+  CloseHandle(s->callbackEvent);
+  printf("[audio] audio resources cleanup completed\n");
+  
+  return SA_SUCCESS;
+}
+/**
+ * \brief - writes PCM audio samples to audio device
+ * \param s - valid handle to opened sydney stream
+ * \param data - pointer to memory storing audio samples to be played
+ * \param nsamples - number of samples in the memory pointed by previous parameter
+ * \return - completion status
+ */
+int writeAudio(sa_stream_t *s, LPSTR data, int bytes) {    
+  UINT status;
+  WAVEHDR* current;	  
+  int remain;
+
+  current = &(s->waveBlocks[s->waveCurrentBlock]);
+  
+  while(bytes > 0) {
+    /* first make sure the header we're going to use is unprepared */
+    if(current->dwFlags & WHDR_PREPARED) {      
+        status = waveOutUnprepareHeader(s->hWaveOut, current, sizeof(WAVEHDR));         
+        HANDLE_WAVE_ERROR(status, "preparing audio headers for writing");
+    }
+		  
+    if(bytes < (int)(BLOCK_SIZE - current->dwUser)) {							  	    
+		  memcpy(current->lpData + current->dwUser, data, bytes);
+      current->dwUser += bytes;
+      break;
+    }
+	
+    /* remain is even as BLOCK_SIZE and dwUser are even too */
+    remain = BLOCK_SIZE - current->dwUser;      
+  	memcpy(current->lpData + current->dwUser, data, remain);
+    bytes -= remain;
+    data += remain;
+	  current->dwBufferLength = BLOCK_SIZE;
+	  /* write to audio device */
+    waveOutPrepareHeader(s->hWaveOut, current, sizeof(WAVEHDR));
+	  status = waveOutWrite(s->hWaveOut, current, sizeof(WAVEHDR));      
+    HANDLE_WAVE_ERROR(status, "writing audio to audio device");
+      
+    EnterCriticalSection(&(s->waveCriticalSection));
+    s->waveFreeBlockCount--;
+    LeaveCriticalSection(&(s->waveCriticalSection));
+    /*
+     * wait for a block to become free
+     */
+    while (!(s->waveFreeBlockCount)) {
+        //printf("All audio buffer blocks empty\n");        
+      WaitForSingleObject(s->callbackEvent, INFINITE);
+        //Sleep(10);
+    }		  
+		
+    /*
+     * point to the next block
+     */
+    (s->waveCurrentBlock)++;
+    (s->waveCurrentBlock) %= BLOCK_COUNT;		
+
+    current = &(s->waveBlocks[s->waveCurrentBlock]);
+    current->dwUser = 0;
+  }
+  return SA_SUCCESS;
+}
+
+/**
+ * \brief - audio callback function called when next WAVE header is played by audio device
+ */
+void CALLBACK waveOutProc(
+    HWAVEOUT hWaveOut, 
+    UINT uMsg, 
+    DWORD dwInstance,  
+    DWORD dwParam1,    
+    DWORD dwParam2     
+)
+{
+    /*
+     * pointer to free block counter
+     */
+    sa_stream_t* handle = (sa_stream_t*)dwInstance;
+    /*
+     * ignore calls that occur due to openining and closing the
+     * device.
+     */
+    if(uMsg != WOM_DONE)
+        return;
+
+    EnterCriticalSection(&(handle->waveCriticalSection));
+    (handle->waveFreeBlockCount)++;
+    if ((handle->waveFreeBlockCount) == 1) 
+       SetEvent(handle->callbackEvent);
+    LeaveCriticalSection(&(handle->waveCriticalSection));	
+}
+
+/**
+ * \brief - converts frequently reported WAVE error codes to Sydney audio API codes
+ */
+int getSAErrorCode(int waveErrorCode) {
+  int error = SA_ERROR_NOT_SUPPORTED;
+
+  switch (waveErrorCode) {
+    case MMSYSERR_NOERROR: 
+      error = SA_SUCCESS;
+      break;
+    case MMSYSERR_ALLOCATED: 
+      error = SA_ERROR_SYSTEM;
+      break;
+    case MMSYSERR_BADDEVICEID:
+      error = SA_ERROR_INVALID;
+      break;
+    case MMSYSERR_NODRIVER:
+      error = SA_ERROR_NO_DRIVER;
+      break;
+    case MMSYSERR_NOTSUPPORTED:
+      error = SA_ERROR_NOT_SUPPORTED;
+      break;          
+    case MMSYSERR_NOMEM: 
+      error = SA_ERROR_OOM;
+      break;
+    case MMSYSERR_INVALHANDLE:
+      error = SA_ERROR_INVALID;
+      break;
+    case WAVERR_BADFORMAT: 
+      error = SA_ERROR_NOT_SUPPORTED;
+      break;
+    case WAVERR_SYNC: 
+      error = SA_ERROR_NOT_SUPPORTED;
+      break;    
+  }
+  return error;
+}
+
+
+/*
+ * -----------------------------------------------------------------------------
+ * Functions to be implemented next 
+ * -----------------------------------------------------------------------------
+ */
+
+#define NOT_IMPLEMENTED(func)   func { return SA_ERROR_NOT_SUPPORTED; }
+
+/* "Soft" params */
+NOT_IMPLEMENTED(int sa_stream_set_write_lower_watermark(sa_stream_t *s, size_t size))
+NOT_IMPLEMENTED(int sa_stream_set_read_lower_watermark(sa_stream_t *s, size_t size))
+NOT_IMPLEMENTED(int sa_stream_set_write_upper_watermark(sa_stream_t *s, size_t size))
+NOT_IMPLEMENTED(int sa_stream_set_read_upper_watermark(sa_stream_t *s, size_t size))
+
+/** Set the mapping between channels and the loudspeakers */
+NOT_IMPLEMENTED(int sa_stream_set_channel_map(sa_stream_t *s, const sa_channel_t map[], unsigned int n))
+
+/* Query functions */
+NOT_IMPLEMENTED(int sa_stream_get_mode(sa_stream_t *s, sa_mode_t *access_mode))
+NOT_IMPLEMENTED(int sa_stream_get_pcm_format(sa_stream_t *s, sa_pcm_format_t *format))
+NOT_IMPLEMENTED(int sa_stream_get_rate(sa_stream_t *s, unsigned int *rate))
+NOT_IMPLEMENTED(int sa_stream_get_nchannels(sa_stream_t *s, int *nchannels))
+NOT_IMPLEMENTED(int sa_stream_get_device(sa_stream_t *s, char *device_name, size_t *size))
+NOT_IMPLEMENTED(int sa_stream_get_write_lower_watermark(sa_stream_t *s, size_t *size))
+NOT_IMPLEMENTED(int sa_stream_get_read_lower_watermark(sa_stream_t *s, size_t *size))
+NOT_IMPLEMENTED(int sa_stream_get_write_upper_watermark(sa_stream_t *s, size_t *size))
+NOT_IMPLEMENTED(int sa_stream_get_read_upper_watermark(sa_stream_t *s, size_t *size))
+NOT_IMPLEMENTED(int sa_stream_get_channel_map(sa_stream_t *s, sa_channel_t map[], unsigned int *n))
+
+/*
+ * -----------------------------------------------------------------------------
+ * Unsupported functions
+ * -----------------------------------------------------------------------------
+ */
+#define UNSUPPORTED(func)   func { return SA_ERROR_NOT_SUPPORTED; }
+
+/** Create an opaque (e.g. AC3) codec stream */
+UNSUPPORTED(int sa_stream_create_opaque(sa_stream_t **s, const char *client_name, sa_mode_t mode, const char *codec))
+/** Whether xruns cause the card to reset */
+UNSUPPORTED(int sa_stream_set_xrun_mode(sa_stream_t *s, sa_xrun_mode_t mode))
+/** Set the device to non-interleaved mode */
+UNSUPPORTED(int sa_stream_set_non_interleaved(sa_stream_t *s, int enable))
+/** Require dynamic sample rate */
+UNSUPPORTED(int sa_stream_set_dynamic_rate(sa_stream_t *s, int enable))
+/** Select driver */
+UNSUPPORTED(int sa_stream_set_driver(sa_stream_t *s, const char *driver))
+/** Start callback */
+UNSUPPORTED(int sa_stream_start_thread(sa_stream_t *s, sa_event_callback_t callback))
+/** Stop callback */
+UNSUPPORTED(int sa_stream_stop_thread(sa_stream_t *s))
+/** Change the device connected to the stream */
+UNSUPPORTED(int sa_stream_change_device(sa_stream_t *s, const char *device_name))
+/** volume in hundreths of dB*/
+UNSUPPORTED(int sa_stream_change_read_volume(sa_stream_t *s, const int32_t vol[], unsigned int n))
+/** Change the sampling rate */
+UNSUPPORTED(int sa_stream_change_rate(sa_stream_t *s, unsigned int rate))
+/** Change some meta data that is attached to the stream */
+UNSUPPORTED(int sa_stream_change_meta_data(sa_stream_t *s, const char *name, const void *data, size_t size))
+/** Associate opaque user data */
+UNSUPPORTED(int sa_stream_change_user_data(sa_stream_t *s, const void *value))
+/* Hardware-related. This is implementation-specific and hardware specific. */
+UNSUPPORTED(int sa_stream_set_adjust_rate(sa_stream_t *s, sa_adjust_t direction))
+UNSUPPORTED(int sa_stream_set_adjust_nchannels(sa_stream_t *s, sa_adjust_t direction))
+UNSUPPORTED(int sa_stream_set_adjust_pcm_format(sa_stream_t *s, sa_adjust_t direction))
+UNSUPPORTED(int sa_stream_set_adjust_watermarks(sa_stream_t *s, sa_adjust_t direction))
+/* Query functions */
+UNSUPPORTED(int sa_stream_get_codec(sa_stream_t *s, char *codec, size_t *size))
+UNSUPPORTED(int sa_stream_get_user_data(sa_stream_t *s, void **value))
+
+UNSUPPORTED(int sa_stream_get_xrun_mode(sa_stream_t *s, sa_xrun_mode_t *mode))
+UNSUPPORTED(int sa_stream_get_non_interleaved(sa_stream_t *s, int *enabled))
+UNSUPPORTED(int sa_stream_get_dynamic_rate(sa_stream_t *s, int *enabled))
+UNSUPPORTED(int sa_stream_get_driver(sa_stream_t *s, char *driver_name, size_t *size))            
+UNSUPPORTED(int sa_stream_get_read_volume(sa_stream_t *s, int32_t vol[], unsigned int *n))
+UNSUPPORTED(int sa_stream_get_meta_data(sa_stream_t *s, const char *name, void*data, size_t *size))
+UNSUPPORTED(int sa_stream_get_adjust_rate(sa_stream_t *s, sa_adjust_t *direction))
+UNSUPPORTED(int sa_stream_get_adjust_nchannels(sa_stream_t *s, sa_adjust_t *direction))
+UNSUPPORTED(int sa_stream_get_adjust_pcm_format(sa_stream_t *s, sa_adjust_t *direction))
+UNSUPPORTED(int sa_stream_get_adjust_watermarks(sa_stream_t *s, sa_adjust_t *direction))
+/** Get current state of the audio device */
+UNSUPPORTED(int sa_stream_get_state(sa_stream_t *s, sa_state_t *state))
+/** Obtain the error code */
+UNSUPPORTED(int sa_stream_get_event_error(sa_stream_t *s, sa_error_t *error))
+/** Obtain the notification code */
+UNSUPPORTED(int sa_stream_get_event_notify(sa_stream_t *s, sa_notify_t *notify))
+
+/* Blocking IO calls */
+/** Interleaved capture function */
+UNSUPPORTED(int sa_stream_read(sa_stream_t *s, void *data, size_t nbytes))
+/** Non-interleaved capture function */
+UNSUPPORTED(int sa_stream_read_ni(sa_stream_t *s, unsigned int channel, void *data, size_t nbytes))
+
+/** Non-interleaved playback function */
+UNSUPPORTED(int sa_stream_write_ni(sa_stream_t *s, unsigned int channel, const void *data, size_t nbytes))
+/** Interleaved playback function with seek offset */
+UNSUPPORTED(int sa_stream_pwrite(sa_stream_t *s, const void *data, size_t nbytes, int64_t offset, sa_seek_t whence))
+/** Non-interleaved playback function with seek offset */
+UNSUPPORTED(int sa_stream_pwrite_ni(sa_stream_t *s, unsigned int channel, const void *data, size_t nbytes, int64_t offset, sa_seek_t whence))
+
+/** Query how much can be read without blocking */
+UNSUPPORTED(int sa_stream_get_read_size(sa_stream_t *s, size_t *size))
+
+/** Return a human readable error */
+const char *sa_strerror(int code);
diff -r 4b060ed856e0 media/libsydneyaudio/update.sh
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/media/libsydneyaudio/update.sh	Thu Oct 16 21:24:49 2008 -0500
@@ -0,0 +1,7 @@
+# Usage: ./update.sh <oggplay_src_directory>
+#
+# Copies the needed files from a directory containing the original
+# liboggplay source that we need for the Mozilla HTML5 media support.
+cp $1/include/sydney_audio.h include/sydney_audio.h
+cp $1/src/*.c src/
+cp $1/AUTHORS ./AUTHORS
diff -r 4b060ed856e0 modules/libjar/nsJARChannel.cpp
--- a/modules/libjar/nsJARChannel.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/modules/libjar/nsJARChannel.cpp	Thu Oct 16 21:24:49 2008 -0500
@@ -257,16 +257,18 @@ nsresult
 nsresult 
 nsJARChannel::Init(nsIURI *uri)
 {
     nsresult rv;
     mJarURI = do_QueryInterface(uri, &rv);
     if (NS_FAILED(rv))
         return rv;
 
+    mOriginalURI = mJarURI;
+
     // Prevent loading jar:javascript URIs (see bug 290982).
     nsCOMPtr<nsIURI> innerURI;
     rv = mJarURI->GetJARFile(getter_AddRefs(innerURI));
     if (NS_FAILED(rv))
         return rv;
     PRBool isJS;
     rv = innerURI->SchemeIs("javascript", &isJS);
     if (NS_FAILED(rv))
@@ -436,27 +438,25 @@ nsJARChannel::SetLoadGroup(nsILoadGroup 
 
 //-----------------------------------------------------------------------------
 // nsIChannel
 //-----------------------------------------------------------------------------
 
 NS_IMETHODIMP
 nsJARChannel::GetOriginalURI(nsIURI **aURI)
 {
-    if (mOriginalURI)
-        *aURI = mOriginalURI;
-    else
-        *aURI = mJarURI;
-    NS_IF_ADDREF(*aURI);
+    *aURI = mOriginalURI;
+    NS_ADDREF(*aURI);
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsJARChannel::SetOriginalURI(nsIURI *aURI)
 {
+    NS_ENSURE_ARG_POINTER(aURI);
     mOriginalURI = aURI;
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsJARChannel::GetURI(nsIURI **aURI)
 {
     NS_IF_ADDREF(*aURI = mJarURI);
diff -r 4b060ed856e0 modules/libpr0n/decoders/icon/beos/nsIconChannel.cpp
--- a/modules/libpr0n/decoders/icon/beos/nsIconChannel.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/modules/libpr0n/decoders/icon/beos/nsIconChannel.cpp	Thu Oct 16 21:24:49 2008 -0500
@@ -78,17 +78,17 @@ NS_IMPL_THREADSAFE_ISUPPORTS4(nsIconChan
                               nsIRequest,
                               nsIRequestObserver,
                               nsIStreamListener)
 
 nsresult nsIconChannel::Init(nsIURI* uri)
 {
   NS_ASSERTION(uri, "no uri");
   mUrl = uri;
-
+  mOriginalURI = uri;
   nsresult rv;
   mPump = do_CreateInstance(NS_INPUTSTREAMPUMP_CONTRACTID, &rv);
   return rv;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // nsIRequest methods:
 
@@ -144,23 +144,24 @@ NS_IMETHODIMP nsIconChannel::SetLoadFlag
   return mPump->SetLoadFlags(aLoadAttributes);
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // nsIChannel methods:
 
 NS_IMETHODIMP nsIconChannel::GetOriginalURI(nsIURI* *aURI)
 {
-  *aURI = mOriginalURI ? mOriginalURI : mUrl;
+  *aURI = mOriginalURI;
   NS_ADDREF(*aURI);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsIconChannel::SetOriginalURI(nsIURI* aURI)
 {
+  NS_ENSURE_ARG_POINTER(aURI);
   mOriginalURI = aURI;
   return NS_OK;
 }
 
 NS_IMETHODIMP nsIconChannel::GetURI(nsIURI* *aURI)
 {
   *aURI = mUrl;
   NS_IF_ADDREF(*aURI);
diff -r 4b060ed856e0 modules/libpr0n/decoders/icon/mac/nsIconChannel.cpp
--- a/modules/libpr0n/decoders/icon/mac/nsIconChannel.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/modules/libpr0n/decoders/icon/mac/nsIconChannel.cpp	Thu Oct 16 21:24:49 2008 -0500
@@ -78,17 +78,17 @@ NS_IMPL_THREADSAFE_ISUPPORTS4(nsIconChan
                               nsIRequest,
 			       nsIRequestObserver,
 			       nsIStreamListener)
 
 nsresult nsIconChannel::Init(nsIURI* uri)
 {
   NS_ASSERTION(uri, "no uri");
   mUrl = uri;
-  
+  mOriginalURI = uri;
   nsresult rv;
   mPump = do_CreateInstance(NS_INPUTSTREAMPUMP_CONTRACTID, &rv);
   return rv;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // nsIRequest methods:
 
@@ -156,23 +156,24 @@ NS_IMETHODIMP nsIconChannel::OnDataAvail
   return NS_OK;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // nsIChannel methods:
 
 NS_IMETHODIMP nsIconChannel::GetOriginalURI(nsIURI* *aURI)
 {
-  *aURI = mOriginalURI ? mOriginalURI : mUrl;
+  *aURI = mOriginalURI;
   NS_ADDREF(*aURI);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsIconChannel::SetOriginalURI(nsIURI* aURI)
 {
+  NS_ENSURE_ARG_POINTER(aURI);
   mOriginalURI = aURI;
   return NS_OK;
 }
 
 NS_IMETHODIMP nsIconChannel::GetURI(nsIURI* *aURI)
 {
   *aURI = mUrl;
   NS_IF_ADDREF(*aURI);
diff -r 4b060ed856e0 modules/libpr0n/decoders/icon/mac/nsIconChannelCocoa.mm
--- a/modules/libpr0n/decoders/icon/mac/nsIconChannelCocoa.mm	Tue Oct 14 17:12:28 2008 -0700
+++ b/modules/libpr0n/decoders/icon/mac/nsIconChannelCocoa.mm	Thu Oct 16 21:24:49 2008 -0500
@@ -75,17 +75,17 @@ NS_IMPL_THREADSAFE_ISUPPORTS4(nsIconChan
                               nsIRequest,
 			       nsIRequestObserver,
 			       nsIStreamListener)
 
 nsresult nsIconChannel::Init(nsIURI* uri)
 {
   NS_ASSERTION(uri, "no uri");
   mUrl = uri;
-  
+  mOriginalURI = uri;
   nsresult rv;
   mPump = do_CreateInstance(NS_INPUTSTREAMPUMP_CONTRACTID, &rv);
   return rv;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // nsIRequest methods:
 
@@ -153,23 +153,24 @@ NS_IMETHODIMP nsIconChannel::OnDataAvail
   return NS_OK;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // nsIChannel methods:
 
 NS_IMETHODIMP nsIconChannel::GetOriginalURI(nsIURI* *aURI)
 {
-  *aURI = mOriginalURI ? mOriginalURI : mUrl;
+  *aURI = mOriginalURI;
   NS_ADDREF(*aURI);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsIconChannel::SetOriginalURI(nsIURI* aURI)
 {
+  NS_ENSURE_ARG_POINTER(aURI);
   mOriginalURI = aURI;
   return NS_OK;
 }
 
 NS_IMETHODIMP nsIconChannel::GetURI(nsIURI* *aURI)
 {
   *aURI = mUrl;
   NS_IF_ADDREF(*aURI);
diff -r 4b060ed856e0 modules/libpr0n/decoders/icon/os2/nsIconChannel.cpp
--- a/modules/libpr0n/decoders/icon/os2/nsIconChannel.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/modules/libpr0n/decoders/icon/os2/nsIconChannel.cpp	Thu Oct 16 21:24:49 2008 -0500
@@ -103,17 +103,17 @@ NS_IMPL_THREADSAFE_ISUPPORTS4(nsIconChan
                               nsIRequest,
                               nsIRequestObserver,
                               nsIStreamListener)
 
 nsresult nsIconChannel::Init(nsIURI* uri)
 {
   NS_ASSERTION(uri, "no uri");
   mUrl = uri;
-
+  mOriginalURI = uri;
   nsresult rv;
   mPump = do_CreateInstance(NS_INPUTSTREAMPUMP_CONTRACTID, &rv);
   return rv;
 }
 
 //------------------------------------------------------------------------
 // nsIRequest methods:
 
@@ -170,23 +170,24 @@ NS_IMETHODIMP nsIconChannel::SetLoadFlag
   return mPump->SetLoadFlags(aLoadAttributes);
 }
 
 //------------------------------------------------------------------------
 // nsIChannel methods:
 
 NS_IMETHODIMP nsIconChannel::GetOriginalURI(nsIURI* *aURI)
 {
-  *aURI = mOriginalURI ? mOriginalURI : mUrl;
+  *aURI = mOriginalURI;
   NS_ADDREF(*aURI);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsIconChannel::SetOriginalURI(nsIURI* aURI)
 {
+  NS_ENSURE_ARG_POINTER(aURI);
   mOriginalURI = aURI;
   return NS_OK;
 }
 
 NS_IMETHODIMP nsIconChannel::GetURI(nsIURI* *aURI)
 {
   *aURI = mUrl;
   NS_IF_ADDREF(*aURI);
diff -r 4b060ed856e0 modules/libpr0n/decoders/icon/win/nsIconChannel.cpp
--- a/modules/libpr0n/decoders/icon/win/nsIconChannel.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/modules/libpr0n/decoders/icon/win/nsIconChannel.cpp	Thu Oct 16 21:24:49 2008 -0500
@@ -95,17 +95,17 @@ NS_IMPL_THREADSAFE_ISUPPORTS4(nsIconChan
                               nsIRequest,
                               nsIRequestObserver,
                               nsIStreamListener)
 
 nsresult nsIconChannel::Init(nsIURI* uri)
 {
   NS_ASSERTION(uri, "no uri");
   mUrl = uri;
-
+  mOriginalURI = uri;
   nsresult rv;
   mPump = do_CreateInstance(NS_INPUTSTREAMPUMP_CONTRACTID, &rv);
   return rv;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // nsIRequest methods:
 
@@ -161,23 +161,24 @@ NS_IMETHODIMP nsIconChannel::SetLoadFlag
   return mPump->SetLoadFlags(aLoadAttributes);
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // nsIChannel methods:
 
 NS_IMETHODIMP nsIconChannel::GetOriginalURI(nsIURI* *aURI)
 {
-  *aURI = mOriginalURI ? mOriginalURI : mUrl;
+  *aURI = mOriginalURI;
   NS_ADDREF(*aURI);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsIconChannel::SetOriginalURI(nsIURI* aURI)
 {
+  NS_ENSURE_ARG_POINTER(aURI);
   mOriginalURI = aURI;
   return NS_OK;
 }
 
 NS_IMETHODIMP nsIconChannel::GetURI(nsIURI* *aURI)
 {
   *aURI = mUrl;
   NS_IF_ADDREF(*aURI);
diff -r 4b060ed856e0 netwerk/base/public/nsIChannel.idl
--- a/netwerk/base/public/nsIChannel.idl	Tue Oct 14 17:12:28 2008 -0700
+++ b/netwerk/base/public/nsIChannel.idl	Thu Oct 16 21:24:49 2008 -0500
@@ -55,19 +55,21 @@ interface nsIStreamListener;
  * response headers to be retrieved for the corresponding http transaction. 
  *
  * @status FROZEN
  */
 [scriptable, uuid(c63a055a-a676-4e71-bf3c-6cfa11082018)]
 interface nsIChannel : nsIRequest
 {
     /**
-     * The original URI used to construct the channel. This is used in the case
-     * of a redirect or URI "resolution" (e.g. resolving a resource: URI to a
-     * file: URI) so that the original pre-redirect URI can still be obtained. 
+     * The original URI used to construct the channel. This is used in
+     * the case of a redirect or URI "resolution" (e.g. resolving a
+     * resource: URI to a file: URI) so that the original pre-redirect
+     * URI can still be obtained.  This is never null.  Attempts to
+     * set it to null must throw.
      *
      * NOTE: this is distinctly different from the http Referer (referring URI),
      * which is typically the page that contained the original URI (accessible
      * from nsIHttpChannel).
      */
     attribute nsIURI originalURI;
 
     /**
diff -r 4b060ed856e0 netwerk/base/src/nsBaseChannel.cpp
--- a/netwerk/base/src/nsBaseChannel.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/netwerk/base/src/nsBaseChannel.cpp	Thu Oct 16 21:24:49 2008 -0500
@@ -370,23 +370,24 @@ nsBaseChannel::SetLoadGroup(nsILoadGroup
 
 //-----------------------------------------------------------------------------
 // nsBaseChannel::nsIChannel
 
 NS_IMETHODIMP
 nsBaseChannel::GetOriginalURI(nsIURI **aURI)
 {
   *aURI = OriginalURI();
-  NS_IF_ADDREF(*aURI);
+  NS_ADDREF(*aURI);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsBaseChannel::SetOriginalURI(nsIURI *aURI)
 {
+  NS_ENSURE_ARG_POINTER(aURI);
   mOriginalURI = aURI;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsBaseChannel::GetURI(nsIURI **aURI)
 {
   NS_IF_ADDREF(*aURI = mURI);
diff -r 4b060ed856e0 netwerk/base/src/nsBaseChannel.h
--- a/netwerk/base/src/nsBaseChannel.h	Tue Oct 14 17:12:28 2008 -0700
+++ b/netwerk/base/src/nsBaseChannel.h	Thu Oct 16 21:24:49 2008 -0500
@@ -150,20 +150,22 @@ public:
   // The URI member should be initialized before the channel is used, and then
   // it should never be changed again until the channel is destroyed.
   nsIURI *URI() {
     return mURI;
   }
   void SetURI(nsIURI *uri) {
     NS_ASSERTION(uri, "must specify a non-null URI");
     NS_ASSERTION(!mURI, "must not modify URI");
+    NS_ASSERTION(!mOriginalURI, "how did that get set so early?");
     mURI = uri;
+    mOriginalURI = uri;
   }
   nsIURI *OriginalURI() {
-    return mOriginalURI ? mOriginalURI : mURI;
+    return mOriginalURI;
   }
 
   // The security info is a property of the transport-layer, which should be
   // assigned by the subclass.
   nsISupports *SecurityInfo() {
     return mSecurityInfo; 
   }
   void SetSecurityInfo(nsISupports *info) {
diff -r 4b060ed856e0 netwerk/protocol/http/src/nsHttpChannel.cpp
--- a/netwerk/protocol/http/src/nsHttpChannel.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/netwerk/protocol/http/src/nsHttpChannel.cpp	Thu Oct 16 21:24:49 2008 -0500
@@ -3811,22 +3811,23 @@ nsHttpChannel::SetLoadFlags(nsLoadFlags 
 // nsHttpChannel::nsIChannel
 //-----------------------------------------------------------------------------
 
 NS_IMETHODIMP
 nsHttpChannel::GetOriginalURI(nsIURI **originalURI)
 {
     NS_ENSURE_ARG_POINTER(originalURI);
     *originalURI = mOriginalURI;
-    NS_IF_ADDREF(*originalURI);
+    NS_ADDREF(*originalURI);
     return NS_OK;
 }
 NS_IMETHODIMP
 nsHttpChannel::SetOriginalURI(nsIURI *originalURI)
 {
+    NS_ENSURE_ARG_POINTER(originalURI);
     mOriginalURI = originalURI;
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsHttpChannel::GetURI(nsIURI **URI)
 {
     NS_ENSURE_ARG_POINTER(URI);
diff -r 4b060ed856e0 netwerk/protocol/viewsource/src/nsViewSourceChannel.cpp
--- a/netwerk/protocol/viewsource/src/nsViewSourceChannel.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/netwerk/protocol/viewsource/src/nsViewSourceChannel.cpp	Thu Oct 16 21:24:49 2008 -0500
@@ -155,23 +155,24 @@ nsViewSourceChannel::Resume(void)
 ////////////////////////////////////////////////////////////////////////////////
 // nsIChannel methods:
 
 NS_IMETHODIMP
 nsViewSourceChannel::GetOriginalURI(nsIURI* *aURI)
 {
     NS_ASSERTION(aURI, "Null out param!");
     *aURI = mOriginalURI;
-    NS_IF_ADDREF(*aURI);
+    NS_ADDREF(*aURI);
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsViewSourceChannel::SetOriginalURI(nsIURI* aURI)
 {
+    NS_ENSURE_ARG_POINTER(aURI);
     mOriginalURI = aURI;
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsViewSourceChannel::GetURI(nsIURI* *aURI)
 {
     NS_ENSURE_TRUE(mChannel, NS_ERROR_FAILURE);
diff -r 4b060ed856e0 security/manager/locales/en-US/chrome/pipnss/pipnss.properties
--- a/security/manager/locales/en-US/chrome/pipnss/pipnss.properties	Tue Oct 14 17:12:28 2008 -0700
+++ b/security/manager/locales/en-US/chrome/pipnss/pipnss.properties	Thu Oct 16 21:24:49 2008 -0500
@@ -345,16 +345,17 @@ certErrorTrust_CaInvalid=The certificate
 certErrorTrust_CaInvalid=The certificate is not trusted because it was issued by an invalid CA certificate.
 certErrorTrust_Issuer=The certificate is not trusted because the issuer certificate is not trusted.
 certErrorTrust_ExpiredIssuer=The certificate is not trusted because the issuer certificate has expired.
 certErrorTrust_Untrusted=The certificate does not come from a trusted source.
 
 certErrorMismatch=The certificate is not valid for the name %S.
 # LOCALIZATION NOTE (certErrorMismatchSingle2): Do not translate <a id="cert_domain_link" title="%1$S">%1$S</a>
 certErrorMismatchSingle2=The certificate is only valid for <a id="cert_domain_link" title="%1$S">%1$S</a>
+certErrorMismatchSinglePlain=The certificate is only valid for %S
 certErrorMismatchMultiple=The certificate is only valid for the following names:
 certErrorMismatchNoNames=The certificate is not valid for any server names.
 
 certErrorExpired=The certificate expired on %S.
 certErrorNotYetValid=The certificate will not be valid until %S.
 
 certErrorCodePrefix=(Error code: %S)
 
diff -r 4b060ed856e0 security/manager/ssl/src/nsIdentityChecking.cpp
--- a/security/manager/ssl/src/nsIdentityChecking.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/security/manager/ssl/src/nsIdentityChecking.cpp	Thu Oct 16 21:24:49 2008 -0500
@@ -942,17 +942,17 @@ nsNSSCertificate::hasValidEVOidTag(SECOi
 
   rev.chainTests.number_of_defined_methods = cert_revocation_method_ocsp +1;
   rev.chainTests.cert_rev_flags_per_method = methodFlags;
   rev.chainTests.number_of_preferred_methods = 1;
   rev.chainTests.preferred_methods = preferedRevMethods;
   rev.chainTests.cert_rev_method_independent_flags =
     revMethodIndependentFlags;
 
-  CERTValInParam cvin[3];
+  CERTValInParam cvin[4];
   cvin[0].type = cert_pi_policyOID;
   cvin[0].value.arraySize = 1; 
   cvin[0].value.array.oids = &oid_tag;
 
   cvin[1].type = cert_pi_revocationFlags;
   cvin[1].value.pointer.revocation = &rev;
 
   cvin[2].type = cert_pi_trustAnchors;
diff -r 4b060ed856e0 security/manager/ssl/src/nsNSSIOLayer.cpp
--- a/security/manager/ssl/src/nsNSSIOLayer.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/security/manager/ssl/src/nsNSSIOLayer.cpp	Thu Oct 16 21:24:49 2008 -0500
@@ -967,16 +967,17 @@ GetSubjectAltNames(CERTCertificate *nssC
   PORT_FreeArena(san_arena, PR_FALSE);
   return PR_TRUE;
 }
 
 static void
 AppendErrorTextMismatch(const nsString &host,
                         nsIX509Cert* ix509,
                         nsINSSComponent *component,
+                        PRBool wantsHtml,
                         nsString &returnedMessage)
 {
   const PRUnichar *params[1];
   nsresult rv;
 
   CERTCertificate *nssCert = NULL;
   CERTCertificateCleaner nssCertCleaner(nssCert);
 
@@ -1030,18 +1031,24 @@ AppendErrorTextMismatch(const nsString &
       returnedMessage.Append(allNames);
       returnedMessage.Append(NS_LITERAL_STRING("  \n"));
     }
   }
   else if (nameCount == 1) {
     const PRUnichar *params[1];
     params[0] = allNames.get();
 
+    const char *stringID;
+    if (wantsHtml)
+      stringID = "certErrorMismatchSingle2";
+    else
+      stringID = "certErrorMismatchSinglePlain";
+
     nsString formattedString;
-    rv = component->PIPBundleFormatStringFromName("certErrorMismatchSingle2", 
+    rv = component->PIPBundleFormatStringFromName(stringID, 
                                                   params, 1, 
                                                   formattedString);
     if (NS_SUCCEEDED(rv)) {
       returnedMessage.Append(formattedString);
       returnedMessage.Append(NS_LITERAL_STRING("\n"));
     }
   }
   else { // nameCount == 0
@@ -1161,16 +1168,17 @@ getInvalidCertErrorMessage(PRUint32 mult
                            PRErrorCode errTrust, 
                            PRErrorCode errMismatch, 
                            PRErrorCode errExpired,
                            const nsString &host,
                            const nsString &hostWithPort,
                            PRInt32 port,
                            nsIX509Cert* ix509,
                            PRBool externalErrorReporting,
+                           PRBool wantsHtml,
                            nsINSSComponent *component,
                            nsString &returnedMessage)
 {
   NS_ENSURE_ARG_POINTER(component);
 
   const PRUnichar *params[1];
   nsresult rv;
 
@@ -1199,17 +1207,17 @@ getInvalidCertErrorMessage(PRUint32 mult
   if (multipleCollectedErrors & nsICertOverrideService::ERROR_UNTRUSTED)
   {
     AppendErrorTextUntrusted(errTrust, host, ix509, 
                              component, returnedMessage);
   }
 
   if (multipleCollectedErrors & nsICertOverrideService::ERROR_MISMATCH)
   {
-    AppendErrorTextMismatch(host, ix509, component, returnedMessage);
+    AppendErrorTextMismatch(host, ix509, component, wantsHtml, returnedMessage);
   }
 
   if (multipleCollectedErrors & nsICertOverrideService::ERROR_TIME)
   {
     AppendErrorTextTime(ix509, component, returnedMessage);
   }
 
   AppendErrorTextCode(errorCodeToReport, component, returnedMessage);
@@ -1338,16 +1346,17 @@ nsHandleInvalidCertError(nsNSSSocketInfo
                          PRUint32 multipleCollectedErrors, 
                          const nsACString &host, 
                          const nsACString &hostWithPort,
                          PRInt32 port,
                          PRErrorCode errorCodeToReport,
                          PRErrorCode errTrust, 
                          PRErrorCode errMismatch, 
                          PRErrorCode errExpired,
+                         PRBool wantsHtml,
                          nsIX509Cert* ix509)
 {
   nsresult rv;
   NS_DEFINE_CID(nssComponentCID, NS_NSSCOMPONENT_CID);
   nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(nssComponentCID, &rv));
   if (NS_FAILED(rv))
     return rv;
 
@@ -1360,17 +1369,18 @@ nsHandleInvalidCertError(nsNSSSocketInfo
 
   PRBool external = PR_FALSE;
   socketInfo->GetExternalErrorReporting(&external);
   
   nsString formattedString;
   rv = getInvalidCertErrorMessage(multipleCollectedErrors, errorCodeToReport,
                                   errTrust, errMismatch, errExpired,
                                   hostU, hostWithPortU, port, 
-                                  ix509, external, nssComponent, formattedString);
+                                  ix509, external, wantsHtml,
+                                  nssComponent, formattedString);
 
   if (external)
   {
     socketInfo->SetErrorMessage(formattedString.get());
   }
   else
   {
     nsPSMUITracker tracker;
@@ -3072,25 +3082,29 @@ nsNSSBadCertHandler(void *arg, PRFileDes
   if (remaining_display_errors & nsICertOverrideService::ERROR_UNTRUSTED)
     errorCodeToReport = errorCodeTrust;
   else if (remaining_display_errors & nsICertOverrideService::ERROR_MISMATCH)
     errorCodeToReport = errorCodeMismatch;
   else if (remaining_display_errors & nsICertOverrideService::ERROR_TIME)
     errorCodeToReport = errorCodeExpired;
 
   if (!suppressMessage) {
+    PRBool external = PR_FALSE;
+    infoObject->GetExternalErrorReporting(&external);
+
     nsHandleInvalidCertError(infoObject,
                              remaining_display_errors,
                              hostString,
                              hostWithPortString,
                              port,
                              errorCodeToReport,
                              errorCodeTrust,
                              errorCodeMismatch,
                              errorCodeExpired,
+                             external, // wantsHtml
                              ix509);
   }
 
   PR_SetError(errorCodeToReport, 0);
   return cancel_and_failure(infoObject);
 }
 
 static PRFileDesc*
diff -r 4b060ed856e0 toolkit/components/downloads/src/nsDownloadManager.cpp
--- a/toolkit/components/downloads/src/nsDownloadManager.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/toolkit/components/downloads/src/nsDownloadManager.cpp	Thu Oct 16 21:24:49 2008 -0500
@@ -21,16 +21,17 @@
  *
  * Contributor(s):
  *   Blake Ross <blaker@netscape.com> (Original Author)
  *   Ben Goodger <ben@netscape.com> (Original Author)
  *   Shawn Wilsher <me@shawnwilsher.com>
  *   Srirang G Doddihal <brahmana@doddihal.com>
  *   Edward Lee <edward.lee@engineering.uiuc.edu>
  *   Graeme McCutcheon <graememcc_firefox@graeme-online.co.uk>
+ *   Ehsan Akhgari <ehsan.akhgari@gmail.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -271,52 +272,95 @@ void // static
 void // static
 nsDownloadManager::ResumeOnWakeCallback(nsITimer *aTimer, void *aClosure)
 {
   // Resume the downloads that were set to autoResume
   nsDownloadManager *dlMgr = static_cast<nsDownloadManager *>(aClosure);
   (void)dlMgr->ResumeAllDownloads(PR_FALSE);
 }
 
+already_AddRefed<mozIStorageConnection>
+nsDownloadManager::GetFileDBConnection(nsIFile *dbFile) const
+{
+  NS_ASSERTION(dbFile, "GetFileDBConnection called with an invalid nsIFile");
+
+  nsCOMPtr<mozIStorageService> storage =
+    do_GetService(MOZ_STORAGE_SERVICE_CONTRACTID);
+  NS_ENSURE_TRUE(storage, nsnull);
+
+  nsCOMPtr<mozIStorageConnection> conn;
+  nsresult rv = storage->OpenDatabase(dbFile, getter_AddRefs(conn));
+  if (rv == NS_ERROR_FILE_CORRUPTED) {
+    // delete and try again, since we don't care so much about losing a user's
+    // download history
+    rv = dbFile->Remove(PR_FALSE);
+    NS_ENSURE_SUCCESS(rv, nsnull);
+    rv = storage->OpenDatabase(dbFile, getter_AddRefs(conn));
+  }
+  NS_ENSURE_SUCCESS(rv, nsnull);
+
+  return conn.forget();
+}
+
+already_AddRefed<mozIStorageConnection>
+nsDownloadManager::GetMemoryDBConnection() const
+{
+  nsCOMPtr<mozIStorageService> storage =
+    do_GetService(MOZ_STORAGE_SERVICE_CONTRACTID);
+  NS_ENSURE_TRUE(storage, nsnull);
+
+  nsCOMPtr<mozIStorageConnection> conn;
+  nsresult rv = storage->OpenSpecialDatabase("memory", getter_AddRefs(conn));
+  NS_ENSURE_SUCCESS(rv, nsnull);
+
+  return conn.forget();
+}
+
 nsresult
-nsDownloadManager::InitDB(PRBool *aDoImport)
+nsDownloadManager::InitMemoryDB()
+{
+  mDBConn = GetMemoryDBConnection();
+  if (!mDBConn)
+    return NS_ERROR_NOT_AVAILABLE;
+
+  nsresult rv = CreateTable();
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  mDBType = DATABASE_MEMORY;
+  return NS_OK;
+}
+
+nsresult
+nsDownloadManager::InitFileDB(PRBool *aDoImport)
 {
   nsresult rv;
   *aDoImport = PR_FALSE;
-
-  nsCOMPtr<mozIStorageService> storage =
-    do_GetService(MOZ_STORAGE_SERVICE_CONTRACTID, &rv);
-  NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIFile> dbFile;
   rv = NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR,
                               getter_AddRefs(dbFile));
   NS_ENSURE_SUCCESS(rv, rv);
   rv = dbFile->Append(DM_DB_NAME);
   NS_ENSURE_SUCCESS(rv, rv);
 
-  rv = storage->OpenDatabase(dbFile, getter_AddRefs(mDBConn));
-  if (rv == NS_ERROR_FILE_CORRUPTED) {
-    // delete and try again, since we don't care so much about losing a users
-    // download history
-    rv = dbFile->Remove(PR_FALSE);
-    NS_ENSURE_SUCCESS(rv, rv);
-    rv = storage->OpenDatabase(dbFile, getter_AddRefs(mDBConn));
-  }
-  NS_ENSURE_SUCCESS(rv, rv);
+  mDBConn = GetFileDBConnection(dbFile);
+  NS_ENSURE_TRUE(mDBConn, NS_ERROR_NOT_AVAILABLE);
 
   PRBool tableExists;
   rv = mDBConn->TableExists(NS_LITERAL_CSTRING("moz_downloads"), &tableExists);
   NS_ENSURE_SUCCESS(rv, rv);
   if (!tableExists) {
     *aDoImport = PR_TRUE;
     rv = CreateTable();
     NS_ENSURE_SUCCESS(rv, rv);
+    mDBType = DATABASE_DISK;
     return NS_OK;
   }
+
+  mDBType = DATABASE_DISK;
 
   // Checking the database schema now
   PRInt32 schemaVersion;
   rv = mDBConn->GetSchemaVersion(&schemaVersion);
   NS_ENSURE_SUCCESS(rv, rv);
 
   // Changing the database?  Be sure to do these two things!
   // 1) Increment DM_SCHEMA_VERSION
@@ -521,16 +565,19 @@ nsDownloadManager::InitDB(PRBool *aDoImp
                "referrer, entityID, currBytes, maxBytes, mimeType, "
                "preferredApplication, preferredAction, autoResume "
         "FROM moz_downloads"), getter_AddRefs(stmt));
       if (NS_SUCCEEDED(rv))
         break;
 
       // if the statement fails, that means all the columns were not there.
       // First we backup the database
+      nsCOMPtr<mozIStorageService> storage =
+        do_GetService(MOZ_STORAGE_SERVICE_CONTRACTID);
+      NS_ENSURE_TRUE(storage, NS_ERROR_NOT_AVAILABLE);
       nsCOMPtr<nsIFile> backup;
       rv = storage->BackupDatabaseFile(dbFile, DM_DB_CORRUPT_FILENAME, nsnull,
                                        getter_AddRefs(backup));
       NS_ENSURE_SUCCESS(rv, rv);
 
       // Then we dump it
       rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
         "DROP TABLE moz_downloads"));
@@ -889,18 +936,30 @@ nsDownloadManager::AddDownloadToDB(const
 
 nsresult
 nsDownloadManager::Init()
 {
   nsresult rv;
   mObserverService = do_GetService("@mozilla.org/observer-service;1", &rv);
   NS_ENSURE_SUCCESS(rv, rv);
 
-  PRBool doImport;
-  rv = InitDB(&doImport);
+  PRBool doImport = PR_FALSE;
+  switch (mDBType) {
+    case DATABASE_MEMORY:
+      rv = InitMemoryDB();
+      break;
+
+    case DATABASE_DISK:
+      rv = InitFileDB(&doImport);
+      break;
+
+    default:
+      NS_ASSERTION(0, "Unexpected value encountered for nsDownloadManager::mDBType");
+      break;
+  }
   NS_ENSURE_SUCCESS(rv, rv);
 
   if (doImport)
     ImportDownloadHistory();
 
   nsCOMPtr<nsIStringBundleService> bundleService =
     do_GetService(NS_STRINGBUNDLE_CONTRACTID, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
@@ -1778,16 +1837,30 @@ nsDownloadManager::NotifyListenersOnStat
                                                 nsresult aStatus,
                                                 nsIDownload *aDownload)
 {
   for (PRInt32 i = mListeners.Count() - 1; i >= 0; --i)
     mListeners[i]->OnStateChange(aProgress, aRequest, aStateFlags, aStatus,
                                  aDownload);
 }
 
+nsresult
+nsDownloadManager::SwitchDatabaseTypeTo(enum nsDownloadManager::DatabaseType aType)
+{
+  if (aType == mDBType)
+    return NS_OK; // no-op
+
+  mDBType = aType;
+
+  (void)PauseAllDownloads(PR_TRUE);
+  (void)RemoveAllDownloads();
+
+  return Init();
+}
+
 ////////////////////////////////////////////////////////////////////////////////
 //// nsINavHistoryObserver
 
 NS_IMETHODIMP
 nsDownloadManager::OnBeginUpdateBatch()
 {
   // We already have a transaction, so don't make another
   if (mHistoryTransaction)
@@ -1924,16 +1997,22 @@ nsDownloadManager::Observe(nsISupports *
   else if (strcmp(aTopic, NS_IOSERVICE_GOING_OFFLINE_TOPIC) == 0) {
     // Pause all downloads, and mark them to auto-resume.
     (void)PauseAllDownloads(PR_TRUE);
   }
   else if (strcmp(aTopic, NS_IOSERVICE_OFFLINE_STATUS_TOPIC) == 0 &&
            nsDependentString(aData).EqualsLiteral(NS_IOSERVICE_ONLINE)) {
     // We can now resume all downloads that are supposed to auto-resume.
     (void)ResumeAllDownloads(PR_FALSE);
+  }
+  else if (strcmp(aTopic, "dlmgr-switchdb") == 0) {
+    if (NS_LITERAL_STRING("memory").Equals(aData))
+      return SwitchDatabaseTypeTo(DATABASE_MEMORY);
+    else if (NS_LITERAL_STRING("disk").Equals(aData))
+      return SwitchDatabaseTypeTo(DATABASE_DISK);
   }
   else if (strcmp(aTopic, "alertclickcallback") == 0) {
     nsCOMPtr<nsIDownloadManagerUI> dmui =
       do_GetService("@mozilla.org/download-manager-ui;1", &rv);
     NS_ENSURE_SUCCESS(rv, rv);
     return dmui->Show(nsnull, 0, nsIDownloadManagerUI::REASON_USER_INTERACTED);
   } else if (strcmp(aTopic, "sleep_notification") == 0) {
     // Pause downloads if we're sleeping, and mark the downloads as auto-resume
@@ -2189,16 +2268,20 @@ nsDownload::SetState(DownloadState aStat
       mDownloadManager->SendEvent(this, "dl-done");
       break;
     case nsIDownloadManager::DOWNLOAD_BLOCKED_PARENTAL:
     case nsIDownloadManager::DOWNLOAD_BLOCKED_POLICY:
       mDownloadManager->SendEvent(this, "dl-blocked");
       break;
     case nsIDownloadManager::DOWNLOAD_DIRTY:
       mDownloadManager->SendEvent(this, "dl-dirty");
+      break;
+    case nsIDownloadManager::DOWNLOAD_CANCELED:
+      mDownloadManager->SendEvent(this, "dl-cancel");
+      break;
     default:
       break;
   }
   return NS_OK;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 //// nsIWebProgressListener2
diff -r 4b060ed856e0 toolkit/components/downloads/src/nsDownloadManager.h
--- a/toolkit/components/downloads/src/nsDownloadManager.h	Tue Oct 14 17:12:28 2008 -0700
+++ b/toolkit/components/downloads/src/nsDownloadManager.h	Thu Oct 16 21:24:49 2008 -0500
@@ -20,16 +20,17 @@
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Blake Ross <blaker@netscape.com>
  *   Ben Goodger <ben@netscape.com>
  *   Shawn Wilsher <me@shawnwilsher.com>
  *   Srirang G Doddihal <brahmana@doddihal.com>
  *   Edward Lee <edward.lee@engineering.uiuc.edu>
+ *   Ehsan Akhgari <ehsan.akhgari@gmail.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -88,20 +89,33 @@ public:
   NS_DECL_NSINAVHISTORYOBSERVER
   NS_DECL_NSIOBSERVER
 
   nsresult Init();
 
   static nsDownloadManager *GetSingleton();
 
   virtual ~nsDownloadManager();
-  nsDownloadManager() {};
+  nsDownloadManager() :
+      mDBType(DATABASE_DISK)
+  {
+  }
 
 protected:
-  nsresult InitDB(PRBool *aDoImport);
+  enum DatabaseType
+  {
+    DATABASE_DISK = 0, // default
+    DATABASE_MEMORY
+  };
+
+  nsresult InitFileDB(PRBool *aDoImport);
+  nsresult InitMemoryDB();
+  already_AddRefed<mozIStorageConnection> GetFileDBConnection(nsIFile *dbFile) const;
+  already_AddRefed<mozIStorageConnection> GetMemoryDBConnection() const;
+  nsresult SwitchDatabaseTypeTo(enum DatabaseType aType);
   nsresult CreateTable();
   nsresult ImportDownloadHistory();
 
   /**
    * Fix up the database after a crash such as dealing with previously-active
    * downloads. Call this before RestoreActiveDownloads to get the downloads
    * fixed here to be auto-resumed.
    */
@@ -248,16 +262,18 @@ private:
   nsCOMArray<nsIDownloadProgressListener> mListeners;
   nsCOMPtr<nsIStringBundle> mBundle;
   nsCOMPtr<mozIStorageConnection> mDBConn;
   nsCOMArray<nsDownload> mCurrentDownloads;
   nsCOMPtr<nsIObserverService> mObserverService;
   nsCOMPtr<mozIStorageStatement> mUpdateDownloadStatement;
   nsCOMPtr<mozIStorageStatement> mGetIdsForURIStatement;
   nsAutoPtr<mozStorageTransaction> mHistoryTransaction;
+
+  enum DatabaseType mDBType;
 
   static nsDownloadManager *gDownloadManagerService;
 
   friend class nsDownload;
 };
 
 class nsDownload : public nsIDownload
 {
diff -r 4b060ed856e0 toolkit/components/downloads/test/unit/test_memory_db_support.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/components/downloads/test/unit/test_memory_db_support.js	Thu Oct 16 21:24:49 2008 -0500
@@ -0,0 +1,83 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Download Manager Test Code.
+ *
+ * The Initial Developer of the Original Code is
+ * Ehsan Akhgari <ehsan.akhgari@gmail.com>.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+// This tests the switching of the download manager database types between disk
+// and memory based databases.  This feature was added in bug 457110.
+
+const nsIDownloadManager = Ci.nsIDownloadManager;
+const dm = Cc["@mozilla.org/download-manager;1"].getService(nsIDownloadManager);
+
+function run_test() {
+  let observer = dm.QueryInterface(Ci.nsIObserver);
+
+  // make sure the initial disk-based DB is initialized correctly
+  let connDisk = dm.DBConnection;
+  do_check_true(connDisk.connectionReady);
+  do_check_neq(connDisk.databaseFile, null);
+
+  // switch to a disk DB -- should be a no-op
+  observer.observe(null, "dlmgr-switchdb", "disk");
+
+  // make sure that the database has not changed
+  do_check_true(dm.DBConnection.connectionReady);
+  do_check_neq(dm.DBConnection.databaseFile, null);
+  do_check_true(connDisk.databaseFile.equals(dm.DBConnection.databaseFile));
+  connDisk = dm.DBConnection;
+
+  // switch to a memory DB
+  observer.observe(null, "dlmgr-switchdb", "memory");
+
+  // make sure the DB is has been switched correctly
+  let connMemory = dm.DBConnection;
+  do_check_true(connMemory.connectionReady);
+  do_check_eq(connMemory.databaseFile, null);
+
+  // switch to a memory DB -- should be a no-op
+  observer.observe(null, "dlmgr-switchdb", "memory");
+
+  // make sure that the database is still memory based
+  connMemory = dm.DBConnection;
+  do_check_true(connMemory.connectionReady);
+  do_check_eq(connMemory.databaseFile, null);
+
+  // switch back to the disk DB
+  observer.observe(null, "dlmgr-switchdb", "disk");
+
+  // make sure that the disk database is initialized correctly
+  do_check_true(dm.DBConnection.connectionReady);
+  do_check_neq(dm.DBConnection.databaseFile, null);
+  do_check_true(connDisk.databaseFile.equals(dm.DBConnection.databaseFile));
+}
diff -r 4b060ed856e0 toolkit/mozapps/extensions/content/extensions.js
--- a/toolkit/mozapps/extensions/content/extensions.js	Tue Oct 14 17:12:28 2008 -0700
+++ b/toolkit/mozapps/extensions/content/extensions.js	Thu Oct 16 21:24:49 2008 -0500
@@ -324,17 +324,16 @@ function showView(aView) {
   var showInstallFile = true;
   try {
     showInstallFile = !gPref.getBoolPref(PREF_EXTENSIONS_HIDE_INSTALL_BTN);
   }
   catch (e) { }
   var showCheckUpdatesAll = true;
   var showInstallUpdatesAll = false;
   var showSkip = false;
-  var showContinue = false;
   switch (aView) {
     case "search":
       var bindingList = [ [ ["action", "?action"],
                             ["addonID", "?addonID"],
                             ["description", "?description"],
                             ["eula", "?eula"],
                             ["homepageURL", "?homepageURL"],
                             ["iconURL", "?iconURL"],
@@ -401,18 +400,16 @@ function showView(aView) {
       types = [ [ ["availableUpdateVersion", "?availableUpdateVersion", null],
                   ["updateable", "true", null] ] ];
       break;
     case "installs":
       document.getElementById("installs-view").hidden = false;
       showInstallFile = false;
       showCheckUpdatesAll = false;
       showInstallUpdatesAll = false;
-      if (gUpdatesOnly)
-        showContinue = true;
       bindingList = [ [ ["aboutURL", "?aboutURL"],
                         ["addonID", "?addonID"],
                         ["availableUpdateURL", "?availableUpdateURL"],
                         ["availableUpdateVersion", "?availableUpdateVersion"],
                         ["blocklisted", "?blocklisted"],
                         ["compatible", "?compatible"],
                         ["description", "?description"],
                         ["downloadURL", "?downloadURL"],
@@ -464,17 +461,16 @@ function showView(aView) {
     el.setAttribute("tooltiptext", el.getAttribute(isThemes ? "tooltiptextthemes" :
                                                               "tooltiptextaddons"));
   }
 
   document.getElementById("installFileButton").hidden = !showInstallFile;
   document.getElementById("checkUpdatesAllButton").hidden = !showCheckUpdatesAll;
   document.getElementById("installUpdatesAllButton").hidden = !showInstallUpdatesAll;
   document.getElementById("skipDialogButton").hidden = !showSkip;
-  document.getElementById("continueDialogButton").hidden = !showContinue;
   document.getElementById("themePreviewArea").hidden = !isThemes;
   document.getElementById("themeSplitter").hidden = !isThemes;
   document.getElementById("showUpdateInfoButton").hidden = aView != "updates";
   document.getElementById("hideUpdateInfoButton").hidden = true;
   document.getElementById("searchPanel").hidden = aView != "search";
 
   AddonsViewBuilder.updateView(types, displays, bindingList, null);
 
@@ -482,21 +478,16 @@ function showView(aView) {
     gExtensionsView.selectedItem = gExtensionsView.children[0];
 
   if (showSkip) {
     var button = document.getElementById("installUpdatesAllButton");
     button.setAttribute("default", "true");
     window.setTimeout(function () { button.focus(); }, 0);
   } else
     document.getElementById("installUpdatesAllButton").removeAttribute("default");
-
-  if (showContinue)
-    document.getElementById("continueDialogButton").setAttribute("default", "true");
-  else
-    document.getElementById("continueDialogButton").removeAttribute("default");
 
   if (isThemes)
     onAddonSelect();
   updateGlobalCommands();
 }
 
 // manages the last-selected attribute for the view buttons and richlistbox
 function updateLastSelected(aView) {
@@ -1337,18 +1328,22 @@ XPInstallDownloadManager.prototype = {
   onCompatibilityCheckStarted: function(aAddon)
   {
   },
   
   onCompatibilityCheckEnded: function(aAddon, aStatus)
   {
   },
 
+  _failed: false,
   onInstallEnded: function(aAddon, aStatus)
   {
+    if (aStatus < 0)
+      this._failed = true;
+
     // From nsInstall.h
     // USER_CANCELLED = -210
     // All other xpinstall errors are <= -200
     // Any errors from the EM will have been displayed directly by the EM
     if (aStatus > -200 || aStatus == -210)
       return;
 
     var xpinstallStrings = document.getElementById("xpinstallStrings");
@@ -1366,18 +1361,25 @@ XPInstallDownloadManager.prototype = {
     ps.alert(window, title, message + "\n" + aStatus);
   },
 
   onInstallsCompleted: function()
   {
     gInstalling = false;
     gExtensionManager.sortTypeByProperty(nsIUpdateItem.TYPE_ANY, "name", true);
     if (gUpdatesOnly) {
-      setElementDisabledByID("cmd_continue", false);
-      document.getElementById("continueDialogButton").focus();
+      if (this._failed) {
+        let continueButton = document.getElementById("continueDialogButton");
+        setElementDisabledByID("cmd_continue", false);
+        continueButton.hidden = false;
+        continueButton.setAttribute("default", "true");
+        continueButton.focus();
+      } else {
+        setTimeout(closeEM, 2000);
+      }
     }
     else {
       updateOptionalViews();
       updateGlobalCommands();
     }
   },
 
   _urls: { },
diff -r 4b060ed856e0 toolkit/mozapps/extensions/content/extensions.xul
--- a/toolkit/mozapps/extensions/content/extensions.xul	Tue Oct 14 17:12:28 2008 -0700
+++ b/toolkit/mozapps/extensions/content/extensions.xul	Thu Oct 16 21:24:49 2008 -0500
@@ -262,32 +262,34 @@
       <spacer flex="1"/>
       <button id="skipDialogButton" label="&cmd.skip.label;"
               accesskey="&cmd.skip.accesskey;"
               tooltiptext="&cmd.skip.tooltip;"
               command="cmd_close"/>
       <button id="continueDialogButton" label="&cmd.continue.label;"
               accesskey="&cmd.continue.accesskey;"
               tooltiptext="&cmd.continue.tooltip;"
-              command="cmd_continue"/>
+              command="cmd_continue"
+              hidden="true"/>
       <button id="installUpdatesAllButton" label="&cmd.installUpdatesAll.label;"
               accesskey="&cmd.installUpdatesAll.accesskey;"
               tooltiptext="&cmd.installUpdatesAll.tooltip;"
               command="cmd_installUpdatesAll"/>
 #else
       <button id="installFileButton" label="&cmd.installLocalFile.label;"
               accesskey="&cmd.installLocalFile.accesskey;"
               tooltiptextaddons="&cmd.installFileAddon.tooltip;"
               tooltiptextthemes="&cmd.installFileTheme.tooltip;"
               command="cmd_installFile"/>
       <spacer flex="1"/>
       <button id="continueDialogButton" label="&cmd.continue.label;"
               accesskey="&cmd.continue.accesskey;"
               tooltiptext="&cmd.continue.tooltip;"
-              command="cmd_continue"/>
+              command="cmd_continue"
+              hidden="true"/>
       <button id="installUpdatesAllButton" label="&cmd.installUpdatesAll.label;"
               accesskey="&cmd.installUpdatesAll.accesskey;"
               tooltiptext="&cmd.installUpdatesAll.tooltip;"
               command="cmd_installUpdatesAll"/>
       <button id="checkUpdatesAllButton" label="&cmd.checkUpdatesAll.label;"
               accesskey="&cmd.checkUpdatesAll.accesskey;"
               tooltiptextaddons="&cmd.checkUpdatesAllAddon.tooltip;"
               tooltiptextthemes="&cmd.checkUpdatesAllTheme.tooltip;"
diff -r 4b060ed856e0 toolkit/themes/winstripe/global/wizard.css
--- a/toolkit/themes/winstripe/global/wizard.css	Tue Oct 14 17:12:28 2008 -0700
+++ b/toolkit/themes/winstripe/global/wizard.css	Thu Oct 16 21:24:49 2008 -0500
@@ -35,16 +35,16 @@ wizard[branded="true"] .wizard-header-ic
 .wizard-buttons-separator {
   margin-bottom: 0px !important;
 }
 
 .wizard-buttons-box-2 {
   margin: 10px;
 }
 
-.wizard-button[wizardbutton="finish"],
-.wizard-button[wizardbutton="next"] {
-  -moz-margin-start: -1px !important;
+.wizard-button[dlgtype="finish"],
+.wizard-button[dlgtype="next"] {
+  -moz-margin-start: 0px !important;
 }
 
-.wizard-button[wizardbutton="back"] {
+.wizard-button[dlgtype="back"] {
   -moz-margin-end: 0px !important;
 }
diff -r 4b060ed856e0 toolkit/toolkit-makefiles.sh
--- a/toolkit/toolkit-makefiles.sh	Tue Oct 14 17:12:28 2008 -0700
+++ b/toolkit/toolkit-makefiles.sh	Thu Oct 16 21:24:49 2008 -0500
@@ -329,18 +329,20 @@ MAKEFILES_liboggplay="
 MAKEFILES_liboggplay="
   media/liboggplay/Makefile
   media/liboggplay/src/Makefile
   media/liboggplay/src/liboggplay/Makefile
   media/liboggplay/include/Makefile
   media/liboggplay/include/oggplay/Makefile
 "
 
-MAKEFILES_liboggplay_audio="
-  media/liboggplay_audio/Makefile
+MAKEFILES_libsydneyaudio="
+  media/libsydneyaudio/Makefile
+  media/libsydneyaudio/include/Makefile
+  media/libsydneyaudio/src/Makefile
 "
 
 MAKEFILES_oji="
   modules/oji/Makefile
   modules/oji/public/Makefile
   modules/oji/src/Makefile
   plugin/oji/JEP/Makefile
 "
@@ -1121,11 +1123,11 @@ if [ "$MOZ_OGG" ]; then
 if [ "$MOZ_OGG" ]; then
  add_makefiles "
    $MAKEFILES_libvorbis
    $MAKEFILES_libtheora
    $MAKEFILES_liboggz
    $MAKEFILES_libogg
    $MAKEFILES_libfishsound
    $MAKEFILES_liboggplay
-   $MAKEFILES_liboggplay_audio
+   $MAKEFILES_libsydneyaudio
  "
 fi
diff -r 4b060ed856e0 toolkit/toolkit-tiers.mk
--- a/toolkit/toolkit-tiers.mk	Tue Oct 14 17:12:28 2008 -0700
+++ b/toolkit/toolkit-tiers.mk	Thu Oct 16 21:24:49 2008 -0500
@@ -118,18 +118,18 @@ tier_gecko_dirs += js/jsd
 tier_gecko_dirs += js/jsd
 endif
 
 ifdef MOZ_OGG
 tier_gecko_dirs += \
 		media/libfishsound \
 		media/libogg \
 		media/liboggplay \
-		media/liboggplay_audio \
 		media/liboggz \
+		media/libsydneyaudio \
 		media/libtheora \
 		media/libvorbis \
 		$(NULL)
 endif
 
 tier_gecko_dirs	+= \
 		uriloader \
 		modules/libimg \
diff -r 4b060ed856e0 uriloader/exthandler/nsExternalProtocolHandler.cpp
--- a/uriloader/exthandler/nsExternalProtocolHandler.cpp	Tue Oct 14 17:12:28 2008 -0700
+++ b/uriloader/exthandler/nsExternalProtocolHandler.cpp	Thu Oct 16 21:24:49 2008 -0500
@@ -135,17 +135,17 @@ nsExtProtocolChannel::GetSecurityInfo(ns
 nsExtProtocolChannel::GetSecurityInfo(nsISupports * *aSecurityInfo)
 {
   *aSecurityInfo = nsnull;
   return NS_OK;
 }
 
 NS_IMETHODIMP nsExtProtocolChannel::GetOriginalURI(nsIURI* *aURI)
 {
-  NS_IF_ADDREF(*aURI = mOriginalURI);
+  NS_ADDREF(*aURI = mOriginalURI);
   return NS_OK; 
 }
  
 NS_IMETHODIMP nsExtProtocolChannel::SetOriginalURI(nsIURI* aURI)
 {
   NS_ENSURE_ARG_POINTER(aURI);
   mOriginalURI = aURI;
   return NS_OK;
diff -r 4b060ed856e0 widget/src/cocoa/nsChildView.mm
--- a/widget/src/cocoa/nsChildView.mm	Tue Oct 14 17:12:28 2008 -0700
+++ b/widget/src/cocoa/nsChildView.mm	Thu Oct 16 21:24:49 2008 -0500
@@ -195,16 +195,103 @@ nsIWidget         * gRollupWidget   = ns
 - (BOOL)isFirstResponder;
 
 - (void)fireKeyEventForFlagsChanged:(NSEvent*)theEvent keyDown:(BOOL)isKeyDown;
 
 @end
 
 
 #pragma mark -
+
+// Key code constants
+enum
+{
+  kEscapeKeyCode      = 0x35,
+  kRCommandKeyCode    = 0x36, // right command key
+  kCommandKeyCode     = 0x37,
+  kShiftKeyCode       = 0x38,
+  kCapsLockKeyCode    = 0x39,
+  kOptionkeyCode      = 0x3A,
+  kControlKeyCode     = 0x3B,
+  kRShiftKeyCode      = 0x3C, // right shift key
+  kROptionKeyCode     = 0x3D, // right option key
+  kRControlKeyCode    = 0x3E, // right control key
+  kClearKeyCode       = 0x47,
+
+  // function keys
+  kF1KeyCode          = 0x7A,
+  kF2KeyCode          = 0x78,
+  kF3KeyCode          = 0x63,
+  kF4KeyCode          = 0x76,
+  kF5KeyCode          = 0x60,
+  kF6KeyCode          = 0x61,
+  kF7KeyCode          = 0x62,
+  kF8KeyCode          = 0x64,
+  kF9KeyCode          = 0x65,
+  kF10KeyCode         = 0x6D,
+  kF11KeyCode         = 0x67,
+  kF12KeyCode         = 0x6F,
+  kF13KeyCode         = 0x69,
+  kF14KeyCode         = 0x6B,
+  kF15KeyCode         = 0x71,
+  
+  kPrintScreenKeyCode = kF13KeyCode,
+  kScrollLockKeyCode  = kF14KeyCode,
+  kPauseKeyCode       = kF15KeyCode,
+  
+  // keypad
+  kKeypad0KeyCode     = 0x52,
+  kKeypad1KeyCode     = 0x53,
+  kKeypad2KeyCode     = 0x54,
+  kKeypad3KeyCode     = 0x55,
+  kKeypad4KeyCode     = 0x56,
+  kKeypad5KeyCode     = 0x57,
+  kKeypad6KeyCode     = 0x58,
+  kKeypad7KeyCode     = 0x59,
+  kKeypad8KeyCode     = 0x5B,
+  kKeypad9KeyCode     = 0x5C,
+
+// The following key codes are not defined until Mac OS X 10.5
+#if MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_4
+  kVK_ANSI_1          = 0x12,
+  kVK_ANSI_2          = 0x13,
+  kVK_ANSI_3          = 0x14,
+  kVK_ANSI_4          = 0x15,
+  kVK_ANSI_5          = 0x17,
+  kVK_ANSI_6          = 0x16,
+  kVK_ANSI_7          = 0x1A,
+  kVK_ANSI_8          = 0x1C,
+  kVK_ANSI_9          = 0x19,
+  kVK_ANSI_0          = 0x1D,
+#endif
+
+  kKeypadMultiplyKeyCode  = 0x43,
+  kKeypadAddKeyCode       = 0x45,
+  kKeypadSubtractKeyCode  = 0x4E,
+  kKeypadDecimalKeyCode   = 0x41,
+  kKeypadDivideKeyCode    = 0x4B,
+  kKeypadEqualsKeyCode    = 0x51, // no correpsonding gecko key code
+  kEnterKeyCode           = 0x4C,
+  kReturnKeyCode          = 0x24,
+  kPowerbookEnterKeyCode  = 0x34, // Enter on Powerbook's keyboard is different
+  
+  kInsertKeyCode          = 0x72, // also help key
+  kDeleteKeyCode          = 0x75, // also forward delete key
+  kTabKeyCode             = 0x30,
+  kTildeKeyCode           = 0x32,
+  kBackspaceKeyCode       = 0x33,
+  kHomeKeyCode            = 0x73, 
+  kEndKeyCode             = 0x77,
+  kPageUpKeyCode          = 0x74,
+  kPageDownKeyCode        = 0x79,
+  kLeftArrowKeyCode       = 0x7B,
+  kRightArrowKeyCode      = 0x7C,
+  kUpArrowKeyCode         = 0x7E,
+  kDownArrowKeyCode       = 0x7D
+};
 
 
 /* Convenience routines to go from a gecko rect to cocoa NSRects and back
  *
  * Gecko rects (nsRect) contain an origin (x,y) in a coordinate
  * system with (0,0) in the top-left of the screen. Cocoa rects
  * (NSRect) contain an origin (x,y) in a coordinate system with
  * (0,0) in the bottom-left of the screen. Both nsRect and NSRect
@@ -1372,36 +1459,40 @@ nsresult nsChildView::SynthesizeNativeKe
   
   PRUint32 modifierFlags = 0;
   for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(sModifierFlagMap); ++i) {
     if (aModifierFlags & sModifierFlagMap[i][0]) {
       modifierFlags |= sModifierFlagMap[i][1];
     }
   }
   int windowNumber = [[mView window] windowNumber];
-  NSEvent* downEvent = [NSEvent keyEventWithType:NSKeyDown
+  BOOL sendFlagsChangedEvent = aNativeKeyCode == kCapsLockKeyCode;
+  NSEventType eventType = sendFlagsChangedEvent ? NSFlagsChanged : NSKeyDown;
+  NSEvent* downEvent = [NSEvent keyEventWithType:eventType
                                         location:NSMakePoint(0,0)
                                    modifierFlags:modifierFlags
                                        timestamp:0
                                     windowNumber:windowNumber
                                          context:[NSGraphicsContext currentContext]
                                       characters:ToNSString(aCharacters)
                      charactersIgnoringModifiers:ToNSString(aUnmodifiedCharacters)
                                        isARepeat:NO
                                          keyCode:aNativeKeyCode];
 
-  NSEvent* upEvent = [ChildView makeNewCocoaEventWithType:NSKeyUp
-                                                fromEvent:downEvent];
-
-  if (downEvent && upEvent) {
+  NSEvent* upEvent = sendFlagsChangedEvent ? nil :
+                       [ChildView makeNewCocoaEventWithType:NSKeyUp
+                                                  fromEvent:downEvent];
+
+  if (downEvent && (sendFlagsChangedEvent || upEvent)) {
     KeyboardLayoutOverride currentLayout = gOverrideKeyboardLayout;
     gOverrideKeyboardLayout.mKeyboardLayout = aNativeKeyboardLayout;
     gOverrideKeyboardLayout.mOverrideEnabled = PR_TRUE;
     [NSApp sendEvent:downEvent];
-    [NSApp sendEvent:upEvent];
+    if (upEvent)
+      [NSApp sendEvent:upEvent];
     // processKeyDownEvent and keyUp block exceptions so we're sure to
     // reach here to restore gOverrideKeyboardLayout
     gOverrideKeyboardLayout = currentLayout;
   }
 
   return NS_OK;
 
   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
@@ -3859,104 +3950,16 @@ static void ConvertCocoaKeyEventToMacEve
     }
     macEvent.message = (charCode & 0x00FF) | (nsCocoaUtils::GetCocoaEventKeyCode(cocoaEvent) << 8);
     macEvent.when = ::TickCount();
     ::GetGlobalMouse(&macEvent.where);
     macEvent.modifiers = ::GetCurrentEventKeyModifiers();
 
   NS_OBJC_END_TRY_ABORT_BLOCK;
 }
-
-// Key code constants
-enum
-{
-  kEscapeKeyCode      = 0x35,
-  kRCommandKeyCode    = 0x36, // right command key
-  kCommandKeyCode     = 0x37,
-  kShiftKeyCode       = 0x38,
-  kCapsLockKeyCode    = 0x39,
-  kOptionkeyCode      = 0x3A,
-  kControlKeyCode     = 0x3B,
-  kRShiftKeyCode      = 0x3C, // right shift key
-  kROptionKeyCode     = 0x3D, // right option key
-  kRControlKeyCode    = 0x3E, // right control key
-  kClearKeyCode       = 0x47,
-
-  // function keys
-  kF1KeyCode          = 0x7A,
-  kF2KeyCode          = 0x78,
-  kF3KeyCode          = 0x63,
-  kF4KeyCode          = 0x76,
-  kF5KeyCode          = 0x60,
-  kF6KeyCode          = 0x61,
-  kF7KeyCode          = 0x62,
-  kF8KeyCode          = 0x64,
-  kF9KeyCode          = 0x65,
-  kF10KeyCode         = 0x6D,
-  kF11KeyCode         = 0x67,
-  kF12KeyCode         = 0x6F,
-  kF13KeyCode         = 0x69,
-  kF14KeyCode         = 0x6B,
-  kF15KeyCode         = 0x71,
-  
-  kPrintScreenKeyCode = kF13KeyCode,
-  kScrollLockKeyCode  = kF14KeyCode,
-  kPauseKeyCode       = kF15KeyCode,
-  
-  // keypad
-  kKeypad0KeyCode     = 0x52,
-  kKeypad1KeyCode     = 0x53,
-  kKeypad2KeyCode     = 0x54,
-  kKeypad3KeyCode     = 0x55,
-  kKeypad4KeyCode     = 0x56,
-  kKeypad5KeyCode     = 0x57,
-  kKeypad6KeyCode     = 0x58,
-  kKeypad7KeyCode     = 0x59,
-  kKeypad8KeyCode     = 0x5B,
-  kKeypad9KeyCode     = 0x5C,
-
-// The following key codes are not defined until Mac OS X 10.5
-#if MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_4
-  kVK_ANSI_1          = 0x12,
-  kVK_ANSI_2          = 0x13,
-  kVK_ANSI_3          = 0x14,
-  kVK_ANSI_4          = 0x15,
-  kVK_ANSI_5          = 0x17,
-  kVK_ANSI_6          = 0x16,
-  kVK_ANSI_7          = 0x1A,
-  kVK_ANSI_8          = 0x1C,
-  kVK_ANSI_9          = 0x19,
-  kVK_ANSI_0          = 0x1D,
-#endif
-
-  kKeypadMultiplyKeyCode  = 0x43,
-  kKeypadAddKeyCode       = 0x45,
-  kKeypadSubtractKeyCode  = 0x4E,
-  kKeypadDecimalKeyCode   = 0x41,
-  kKeypadDivideKeyCode    = 0x4B,
-  kKeypadEqualsKeyCode    = 0x51, // no correpsonding gecko key code
-  kEnterKeyCode           = 0x4C,
-  kReturnKeyCode          = 0x24,
-  kPowerbookEnterKeyCode  = 0x34, // Enter on Powerbook's keyboard is different
-  
-  kInsertKeyCode          = 0x72, // also help key
-  kDeleteKeyCode          = 0x75, // also forward delete key
-  kTabKeyCode             = 0x30,
-  kTildeKeyCode           = 0x32,
-  kBackspaceKeyCode       = 0x33,
-  kHomeKeyCode            = 0x73, 
-  kEndKeyCode             = 0x77,
-  kPageUpKeyCode          = 0x74,
-  kPageDownKeyCode        = 0x79,
-  kLeftArrowKeyCode       = 0x7B,
-  kRightArrowKeyCode      = 0x7C,
-  kUpArrowKeyCode         = 0x7E,
-  kDownArrowKeyCode       = 0x7D
-};
-
 
 static PRBool IsPrintableChar(PRUnichar aChar)
 {
   return (aChar >= 0x20 && aChar <= 0x7E) || aChar >= 0xA0;
 }
 
 static PRUint32 GetGeckoKeyCodeFromChar(PRUnichar aChar)
 {
@@ -4348,17 +4351,19 @@ GetUniCharFromKeyTranslate(KeyTranslateD
   }
   return 0;
 }
 
 static SInt32
 GetScriptFromKeyboardLayout(SInt32 aLayoutID)
 {
   switch (aLayoutID) {
+    case 0:                      // US
     case 3:                      // German
+    case 224:                    // Swedish
     case -2:     return smRoman; // US-Extended
     case -18944: return smGreek; // Greek
     default: NS_NOTREACHED("unknown keyboard layout");
   }
   return smRoman;
 }
 
 static CFStringRef
diff -r 4b060ed856e0 widget/src/cocoa/nsCocoaWindow.h
--- a/widget/src/cocoa/nsCocoaWindow.h	Tue Oct 14 17:12:28 2008 -0700
+++ b/widget/src/cocoa/nsCocoaWindow.h	Thu Oct 16 21:24:49 2008 -0500
@@ -42,17 +42,16 @@
 
 #undef DARWIN
 
 #import <Cocoa/Cocoa.h>
 
 #include "nsBaseWidget.h"
 #include "nsPIWidgetCocoa.h"
 #include "nsAutoPtr.h"
-#include "nsNativeThemeColors.h"
 
 class nsCocoaWindow;
 class nsChildView;
 class nsMenuBarX;
 
 typedef struct _nsCocoaWindowList {
   _nsCocoaWindowList() : prev(NULL), window(NULL) {}
   struct _nsCocoaWindowList *prev;
@@ -120,35 +119,16 @@ typedef struct _nsCocoaWindowList {
 @end
 
 struct UnifiedGradientInfo {
   float titlebarHeight;
   float toolbarHeight;
   BOOL windowIsMain;
   BOOL drawTitlebar; // NO for toolbar, YES for titlebar
 };
-
-// Callback used by the default titlebar and toolbar shading.
-// *aIn == 0 at the top of the titlebar/toolbar, *aIn == 1 at the bottom
-static void unifiedShading(void* aInfo, const float* aIn, float* aOut)
-{
-  UnifiedGradientInfo* info = (UnifiedGradientInfo*)aInfo;
-  // The gradient percentage at the bottom of the titlebar / top of the toolbar
-  float start = info->titlebarHeight / (info->titlebarHeight + info->toolbarHeight - 1);
-  const float startGrey = NativeGreyColorAsFloat(headerStartGrey, info->windowIsMain);
-  const float endGrey = NativeGreyColorAsFloat(headerEndGrey, info->windowIsMain);
-  // *aIn is the gradient percentage of the titlebar or toolbar gradient,
-  // a is the gradient percentage of the whole unified gradient.
-  float a = info->drawTitlebar ? *aIn * start : start + *aIn * (1 - start);
-  float result = (1.0f - a) * startGrey + a * endGrey;
-  aOut[0] = result;
-  aOut[1] = result;
-  aOut[2] = result;
-  aOut[3] = 1.0f;
-}
 
 // NSColor subclass that allows us to draw separate colors both in the titlebar 
 // and for background of the window.
 @interface TitlebarAndBackgroundColor : NSColor
 {
   NSColor *mActiveTitlebarColor;
   NSColor *mInactiveTitlebarColor;
   NSColor *mBackgroundColor;
@@ -298,16 +278,18 @@ public:
     // nsIKBStateControl interface
     NS_IMETHOD ResetInputState();
     
     void MakeBackgroundTransparent(PRBool aTransparent);
 
     NS_IMETHOD BeginSecureKeyboardInput();
     NS_IMETHOD EndSecureKeyboardInput();
 
+    static void UnifiedShading(void* aInfo, const float* aIn, float* aOut);
+
 protected:
   
   nsIWidget*           mParent;         // if we're a popup, this is our parent [WEAK]
   NSWindow*            mWindow;         // our cocoa window [STRONG]
   WindowDelegate*      mDelegate;       // our delegate for processing window msgs [STRONG]
   nsRefPtr<nsMenuBarX> mMenuBar;
   NSWindow*            mSheetWindowParent; // if this is a sheet, this is the NSWindow it's attached to
   nsChildView*         mPopupContentView; // if this is a popup, this is its content widget
diff -r 4b060ed856e0 widget/src/cocoa/nsCocoaWindow.mm
--- a/widget/src/cocoa/nsCocoaWindow.mm	Tue Oct 14 17:12:28 2008 -0700
+++ b/widget/src/cocoa/nsCocoaWindow.mm	Thu Oct 16 21:24:49 2008 -0500
@@ -61,16 +61,17 @@
 #include "nsIWindowWatcher.h"
 #include "nsIServiceManager.h"
 #include "nsIDOMWindow.h"
 #include "nsPIDOMWindow.h"
 #include "nsIDOMElement.h"
 #include "nsMenuBarX.h"
 #include "nsMenuUtilsX.h"
 #include "nsStyleConsts.h"
+#include "nsNativeThemeColors.h"
 
 #include "gfxPlatform.h"
 #include "lcms.h"
 
 PRInt32 gXULModalLevel = 0;
 // In principle there should be only one app-modal window at any given time.
 // But sometimes, despite our best efforts, another window appears above the
 // current app-modal window.  So we need to keep a linked list of app-modal
@@ -1402,16 +1403,37 @@ NS_IMETHODIMP nsCocoaWindow::EndSecureKe
   if (NS_SUCCEEDED(rv))
     ::DisableSecureEventInput();
   return rv;
 
   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 }
 
 
+// Callback used by the default titlebar and toolbar shading.
+// *aIn == 0 at the top of the titlebar/toolbar, *aIn == 1 at the bottom
+/* static */ void
+nsCocoaWindow::UnifiedShading(void* aInfo, const float* aIn, float* aOut)
+{
+  UnifiedGradientInfo* info = (UnifiedGradientInfo*)aInfo;
+  // The gradient percentage at the bottom of the titlebar / top of the toolbar
+  float start = info->titlebarHeight / (info->titlebarHeight + info->toolbarHeight - 1);
+  const float startGrey = NativeGreyColorAsFloat(headerStartGrey, info->windowIsMain);
+  const float endGrey = NativeGreyColorAsFloat(headerEndGrey, info->windowIsMain);
+  // *aIn is the gradient percentage of the titlebar or toolbar gradient,
+  // a is the gradient percentage of the whole unified gradient.
+  float a = info->drawTitlebar ? *aIn * start : start + *aIn * (1 - start);
+  float result = (1.0f - a) * startGrey + a * endGrey;
+  aOut[0] = result;
+  aOut[1] = result;
+  aOut[2] = result;
+  aOut[3] = 1.0f;
+}
+
+
 @implementation WindowDelegate
 
 
 // We try to find a gecko menu bar to paint. If one does not exist, just paint
 // the application menu by itself so that a window doesn't have some other
 // window's menu bar.
 + (void)paintMenubarForWindow:(NSWindow*)aWindow
 {
@@ -1978,18 +2000,18 @@ void patternDraw(void* aInfo, CGContextR
 
   UnifiedGradientInfo info = { titlebarHeight, [window unifiedToolbarHeight], isMain, YES };
 
   [NSGraphicsContext saveGraphicsState];
   [NSGraphicsContext setCurrentContext:[NSGraphicsContext graphicsContextWithGraphicsPort:aContext flipped:NO]];
 
   // If the titlebar color is nil, draw the default titlebar shading.
   if (!titlebarColor) {
-    // Create and draw a CGShading that uses unifiedShading() as its callback.
-    CGFunctionCallbacks callbacks = {0, unifiedShading, NULL};
+    // Create and draw a CGShading that uses nsCocoaWindow::UnifiedShading() as its callback.
+    CGFunctionCallbacks callbacks = {0, nsCocoaWindow::UnifiedShading, NULL};
     CGFunctionRef function = CGFunctionCreate(&info, 1, NULL, 4, NULL, &callbacks);
     CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
     CGShadingRef shading = CGShadingCreateAxial(colorSpace,
                                                 CGPointMake(0.0f, titlebarOrigin + titlebarHeight),
                                                 CGPointMake(0.0f, titlebarOrigin),
                                                 function, NO, NO);
     CGColorSpaceRelease(colorSpace);
     CGFunctionRelease(function);
diff -r 4b060ed856e0 widget/src/cocoa/nsNativeThemeCocoa.mm
--- a/widget/src/cocoa/nsNativeThemeCocoa.mm	Tue Oct 14 17:12:28 2008 -0700
+++ b/widget/src/cocoa/nsNativeThemeCocoa.mm	Thu Oct 16 21:24:49 2008 -0500
@@ -54,16 +54,17 @@
 #include "nsIAtom.h"
 #include "nsIEventStateManager.h"
 #include "nsINameSpaceManager.h"
 #include "nsPresContext.h"
 #include "nsILookAndFeel.h"
 #include "nsWidgetAtoms.h"
 #include "nsToolkit.h"
 #include "nsCocoaWindow.h"
+#include "nsNativeThemeColors.h"
 
 #include "gfxContext.h"
 #include "gfxQuartzSurface.h"
 #include "gfxQuartzNativeDrawing.h"
 
 #define DRAW_IN_FRAME_DEBUG 0
 #define SCROLLBARS_VISUAL_DEBUG 0
 
@@ -1184,17 +1185,17 @@ nsNativeThemeCocoa::DrawUnifiedToolbar(C
     // correct gradient in the titlebar.
     [(ToolbarWindow*)win setUnifiedToolbarHeight:inBoxRect.size.height];
   }
   
   BOOL isMain = win ? [win isMainWindow] : YES;
 
   // Draw the gradient
   UnifiedGradientInfo info = { titlebarHeight, inBoxRect.size.height, isMain, NO };
-  struct CGFunctionCallbacks callbacks = { 0, unifiedShading, NULL };
+  struct CGFunctionCallbacks callbacks = { 0, nsCocoaWindow::UnifiedShading, NULL };
   CGFunctionRef function = CGFunctionCreate(&info, 1,  NULL, 4, NULL, &callbacks);
   float srcY = inBoxRect.origin.y;
   float dstY = srcY + inBoxRect.size.height - 1;
   CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
   CGShadingRef shading = CGShadingCreateAxial(colorSpace,
                                               CGPointMake(0, srcY),
                                               CGPointMake(0, dstY), function,
                                               NO, NO);
diff -r 4b060ed856e0 widget/tests/test_keycodes.xul
--- a/widget/tests/test_keycodes.xul	Tue Oct 14 17:12:28 2008 -0700
+++ b/widget/tests/test_keycodes.xul	Thu Oct 16 21:24:49 2008 -0500
@@ -121,184 +121,295 @@ function synthesizeKey(aEvent, aFocusEle
 function synthesizeKey(aEvent, aFocusElementId)
 {
   document.getElementById(aFocusElementId).focus();
 
   synthesizeNativeKey(keyboardLayouts[aEvent.layout],
                       aEvent.keyCode, aEvent, aEvent.chars, aEvent.unmodifiedChars);
 }
 
-// Test the charcodes and modifiers being delivered to keypress handlers.
-function runPressTests()
+// Test the charcodes and modifiers being delivered to keypress handlers and
+// also keydown/keyup events too.
+function runKeyEventTests()
 {
-  var pressList;
-  function onKeyPress(e)
+  var eventList, keyDownFlags, keyUpFlags, testingEvent;
+  const kShiftFlag    = 0x1;
+  const kCtrlFlag     = 0x2;
+  const kAltFlag      = 0x4;
+  const kMetaFlag     = 0x8;
+  const kNumLockFlag  = 0x10;
+  const kCapsLockFlag = 0x20;
+
+  function onKeyEvent(e)
   {
-    pressList.push(e);
+    function removeFlag(e, aFlag)
+    {
+      if (e.type == "keydown") {
+        var oldValue = keyDownFlags;
+        keyDownFlags &= ~aFlag;
+        return oldValue != keyDownFlags;
+      } else if (e.type == "keyup") {
+        var oldValue = keyUpFlags;
+        keyUpFlags &= ~aFlag;
+        return oldValue != keyUpFlags;
+      }
+      return false;
+    }
+
+    function isStateChangingModifierKeyEvent(e)
+    {
+      switch (e.keyCode) {
+        case e.DOM_VK_SHIFT:
+          return (testingEvent.shift || testingEvent.shiftRight) && removeFlag(e, kShiftFlag);
+        case e.DOM_VK_CONTROL:
+          return (testingEvent.ctrl || testingEvent.ctrlRight) && removeFlag(e, kCtrlFlag);
+        case e.DOM_VK_ALT:
+          return (testingEvent.alt || testingEvent.altRight) && removeFlag(e, kAltFlag);
+        case e.DOM_VK_META:
+          return testingEvent.command && removeFlag(e, kMetaFlag);
+        case e.DOM_VK_NUM_LOCK:
+          return testingEvent.numLock && removeFlag(e, kNumLockFlag);
+        case e.DOM_VK_CAPS_LOCK:
+          return testingEvent.capsLock && removeFlag(e, kCapsLockFlag);
+      }
+      return false;
+    }
+
+    // Ignore the state changing key events which is fired by the testing event.
+    if (!isStateChangingModifierKeyEvent(e))
+      eventList.push(e);
     e.preventDefault();
   }
 
+  const SHOULD_DELIVER_NONE             = 0x0;
+  const SHOULD_DELIVER_KEYDOWN          = 0x1;
+  const SHOULD_DELIVER_KEYPRESS         = 0x2;
+  const SHOULD_DELIVER_KEYUP            = 0x4;
+  const SHOULD_DELIVER_ALL              = SHOULD_DELIVER_KEYDOWN |
+                                          SHOULD_DELIVER_KEYPRESS |
+                                          SHOULD_DELIVER_KEYUP;
+  const SHOULD_DELIVER_KEYDOWN_KEYUP    = SHOULD_DELIVER_KEYDOWN |
+                                          SHOULD_DELIVER_KEYUP;
+  const SHOULD_DELIVER_KEYDOWN_KEYPRESS = SHOULD_DELIVER_KEYDOWN |
+                                          SHOULD_DELIVER_KEYPRESS;
+
   // The first parameter is the complete input event. The second parameter is
-  // what to test against.
-  // XXX should probably check that keydown and keyup events were dispatched too
-  function testKey(aEvent, aExpectGeckoChar)
+  // what to test against. The third parameter is which key events should be
+  // delived for the event.
+  function testKey(aEvent, aExpectGeckoChar, aShouldDelivedEvent)
   {
-    pressList = [];
-    
+    eventList = [];
+
+    // The modifier key events which are fired for state changing are har to
+    // test. We should ignore them for now.
+    keyDownFlags = keyUpFlags = 0;
+    if (navigator.platform.indexOf("Mac") != 0) {
+      // On Mac, nsChildView doesn't generate modifier keydown/keyup events for
+      // state changing for synthesizeNativeKeyEvent.
+      if (aEvent.shift || aEvent.shiftRight)
+        keyDownFlags |= kShiftFlag;
+      if (aEvent.ctrl || aEvent.ctrlRight)
+        keyDownFlags |= kCtrlFlag;
+      if (aEvent.alt || aEvent.altRight)
+        keyDownFlags |= kAltFlag;
+      if (aEvent.command)
+        keyDownFlags |= kMetaFlag;
+      if (aEvent.numLock)
+        keyDownFlags |= kNumLockFlag;
+      if (aEvent.capsLock)
+        keyDownFlags |= kCapsLockFlag;
+      keyUpFlags = keyDownFlags;
+    }
+    testingEvent = aEvent;
+
     synthesizeKey(aEvent, "button");
 
     var name = eventToString(aEvent);
 
-    is(pressList.length, aExpectGeckoChar == "" ? 0 : 1, name + ", wrong number of press events");
-    if (pressList.length == 0)
-      return;
-    var e = pressList[0];
-    is(e.ctrlKey, aEvent.ctrl || 0, name + ", Ctrl mismatch");
-    is(e.metaKey, aEvent.command || 0, name + ", Command mismatch");
-    is(e.altKey, aEvent.alt || 0, name + ", Alt mismatch");
-    is(e.shiftKey, aEvent.shift || 0, name + ", Shift mismatch");
-  
-    if (aExpectGeckoChar.length > 0) {
-      is(e.charCode, aExpectGeckoChar.charCodeAt(0), name + ", charcode");
-    } else {
-      is(e.charCode, 0, name + ", no charcode");
+    var expectEventTypeList = [];
+    if (aShouldDelivedEvent & SHOULD_DELIVER_KEYDOWN)
+      expectEventTypeList.push("keydown");
+    if (aShouldDelivedEvent & SHOULD_DELIVER_KEYPRESS)
+      expectEventTypeList.push("keypress");
+    if (aShouldDelivedEvent & SHOULD_DELIVER_KEYUP)
+      expectEventTypeList.push("keyup");
+    is(eventList.length, expectEventTypeList.length, name + ", wrong number of key events");
+
+    var longerLength = Math.max(eventList.length, expectEventTypeList.length);
+    for (var i = 0; i < longerLength; i++) {
+      var firedEventType = i < eventList.length ? eventList[i].type : "";
+      var expectEventType = i < expectEventTypeList.length ? expectEventTypeList[i] : "";
+      if (firedEventType != "")
+        is(firedEventType, expectEventType, name + ", wrong type event fired");
+      else
+        is(firedEventType, expectEventType, name + ", a needed event is not fired");
+
+      if (firedEventType != "") {
+        var e = eventList[i];
+        is(e.ctrlKey, aEvent.ctrl || 0, name + ", Ctrl mismatch");
+        is(e.metaKey, aEvent.command || 0, name + ", Command mismatch");
+        is(e.altKey, aEvent.alt || 0, name + ", Alt mismatch");
+        is(e.shiftKey, aEvent.shift || 0, name + ", Shift mismatch");
+
+        if (aExpectGeckoChar.length > 0 && e.type == "keypress")
+          is(e.charCode, aExpectGeckoChar.charCodeAt(0), name + ", charcode");
+        else
+          is(e.charCode, 0, name + ", no charcode");
+      }
     }
   }
 
   // These tests have to be per-plaform.
-  document.addEventListener("keypress", onKeyPress, false);
+  document.addEventListener("keydown",  onKeyEvent, false);
+  document.addEventListener("keypress", onKeyEvent, false);
+  document.addEventListener("keyup",    onKeyEvent, false);
 
   if (navigator.platform.indexOf("Mac") == 0) {
     // On Mac, you can produce event records for any desired keyboard input
     // by running with NSPR_LOG_MODULES=nsCocoaWidgets:5 and typing into the browser.
     // We will dump the key event fields to the console. Use the International system
     // preferences widget to enable other keyboard layouts and select them from the
     // input menu to see what keyboard events they generate.
     // Note that it's possible to send bogus key events here, e.g.
     // {keyCode:0, chars:"z", unmodifiedChars:"P"} --- sendNativeKeyEvent
     // makes no attempt to verify that the keyCode matches the characters. So only
     // test key event records that you saw Cocoa send.
 
     // Plain text input
     testKey({layout:"US", keyCode:0, chars:"a", unmodifiedChars:"a"},
-            "a");
+            "a", SHOULD_DELIVER_ALL);
     testKey({layout:"US", keyCode:11, chars:"b", unmodifiedChars:"b"},
-            "b");
+            "b", SHOULD_DELIVER_ALL);
     testKey({layout:"US", keyCode:0, shift:1, chars:"A", unmodifiedChars:"A"},
-            "A");
+            "A", SHOULD_DELIVER_ALL);
 
     // Ctrl keys
     testKey({layout:"US", keyCode:0, ctrl:1, chars:"\u0001", unmodifiedChars:"a"},
-            "a");
+            "a", SHOULD_DELIVER_ALL);
     testKey({layout:"US", keyCode:0, ctrl:1, shift:1, chars:"\u0001", unmodifiedChars:"A"},
-            "A");
+            "A", SHOULD_DELIVER_ALL);
 
     // Alt keys
     testKey({layout:"US", keyCode:0, alt:1, chars:"\u00e5", unmodifiedChars:"a"},
-            "\u00e5");
+            "\u00e5", SHOULD_DELIVER_ALL);
     testKey({layout:"US", keyCode:0, alt:1, shift:1, chars:"\u00c5", unmodifiedChars:"A"},
-            "\u00c5");
+            "\u00c5", SHOULD_DELIVER_ALL);
     
     // Command keys
     testKey({layout:"US", keyCode:0, command:1, chars:"a", unmodifiedChars:"a"},
-            "a");
+            "a", SHOULD_DELIVER_KEYDOWN_KEYPRESS);
     // Shift-cmd gives us the shifted character
     testKey({layout:"US", keyCode:0, command:1, shift:1, chars:"a", unmodifiedChars:"A"},
-            "A");
+            "A", SHOULD_DELIVER_KEYDOWN_KEYPRESS);
     // Ctrl-cmd gives us the unshifted character
     testKey({layout:"US", keyCode:0, command:1, ctrl:1, chars:"\u0001", unmodifiedChars:"a"},
-            "a");
+            "a", SHOULD_DELIVER_KEYDOWN_KEYPRESS);
     // Alt-cmd gives us the shifted character
     testKey({layout:"US", keyCode:0, command:1, alt:1, chars:"\u00e5", unmodifiedChars:"a"},
-            "\u00e5");
+            "\u00e5", SHOULD_DELIVER_KEYDOWN_KEYPRESS);
     testKey({layout:"US", keyCode:0, command:1, alt:1, shift:1, chars:"\u00c5", unmodifiedChars:"a"},
-            "\u00c5");
+            "\u00c5", SHOULD_DELIVER_KEYDOWN_KEYPRESS);
 
     // Greek ctrl keys produce Latin charcodes
     testKey({layout:"Greek", keyCode:0, ctrl:1, chars:"\u0001", unmodifiedChars:"\u03b1"},
-            "a");
+            "a", SHOULD_DELIVER_ALL);
     testKey({layout:"Greek", keyCode:0, ctrl:1, shift:1, chars:"\u0001", unmodifiedChars:"\u0391"},
-            "A");
+            "A", SHOULD_DELIVER_ALL);
 
     // Greek command keys
     testKey({layout:"Greek", keyCode:0, command:1, chars:"a", unmodifiedChars:"\u03b1"},
-            "a");
+            "a", SHOULD_DELIVER_KEYDOWN_KEYPRESS);
     // Shift-cmd gives us the shifted character
     testKey({layout:"Greek", keyCode:0, command:1, shift:1, chars:"a", unmodifiedChars:"\u391"},
-            "A");
+            "A", SHOULD_DELIVER_KEYDOWN_KEYPRESS);
     // Ctrl-cmd gives us the unshifted character
     testKey({layout:"Greek", keyCode:0, command:1, ctrl:1, chars:"\u0001", unmodifiedChars:"\u03b1"},
-            "a");
+            "a", SHOULD_DELIVER_KEYDOWN_KEYPRESS);
     // Alt-cmd gives us the shifted character
     testKey({layout:"Greek", keyCode:0, command:1, alt:1, chars:"\u00a8", unmodifiedChars:"\u03b1"},
-            "\u00a8");
+            "\u00a8", SHOULD_DELIVER_KEYDOWN_KEYPRESS);
     testKey({layout:"Greek", keyCode:0, command:1, alt:1, shift:1, chars:"\u00b9", unmodifiedChars:"\u0391"},
-            "\u00b9");
+            "\u00b9", SHOULD_DELIVER_KEYDOWN_KEYPRESS);
 
     // German (KCHR/KeyTranslate case)
     testKey({layout:"German", keyCode:0, chars:"a", unmodifiedChars:"a"},
-            "a");
+            "a", SHOULD_DELIVER_ALL);
     testKey({layout:"German", keyCode:33, chars:"\u00fc", unmodifiedChars:"\u00fc"},
-            "\u00fc");
+            "\u00fc", SHOULD_DELIVER_ALL);
     testKey({layout:"German", keyCode:27, chars:"\u00df", unmodifiedChars:"\u00df"},
-            "\u00df");
+            "\u00df", SHOULD_DELIVER_ALL);
     testKey({layout:"German", keyCode:27, shift:1, chars:"?", unmodifiedChars:"?"},
-            "?");
+            "?", SHOULD_DELIVER_ALL);
     testKey({layout:"German", keyCode:27, command:1, chars:"\u00df", unmodifiedChars:"\u00df"},
-            "\u00df");
+            "\u00df", SHOULD_DELIVER_KEYDOWN_KEYPRESS);
     // Shift+SS is '?' but Cmd+Shift+SS is '/' on German layout.
     // XXX this test failed on 10.4
     //testKey({layout:"German", keyCode:27, command:1, shift:1, chars:"/", unmodifiedChars:"?"},
-    //        "?");
+    //        "?", SHOULD_DELIVER_KEYDOWN_KEYPRESS);
+
+    // Caps Lock key event
+    // XXX keyup event of Caps Lock key is not fired.
+    testKey({layout:"US", keyCode:57, capsLock:1, chars:"", unmodifiedChars:""},
+            "", SHOULD_DELIVER_KEYDOWN);
+    testKey({layout:"US", keyCode:57, chars:"", unmodifiedChars:""},
+            "", SHOULD_DELIVER_KEYDOWN);
   }
-  
+
   if (navigator.platform.indexOf("Win") == 0) {
     // On Windows, you can use Spy++ or Winspector (free) to watch window messages.
     // The keyCode is given by the wParam of the last WM_KEYDOWN message. The
     // chars string is given by the wParam of the WM_CHAR message. unmodifiedChars
     // is not needed on Windows.
 
     // Plain text input
     testKey({layout:"US", keyCode:65, chars:"a"},
-            "a");
+            "a", SHOULD_DELIVER_ALL);
     testKey({layout:"US", keyCode:66, chars:"b"},
-            "b");
+            "b", SHOULD_DELIVER_ALL);
     testKey({layout:"US", keyCode:65, shift:1, chars:"A"},
-            "A");
+            "A", SHOULD_DELIVER_ALL);
 
     // Ctrl keys
     testKey({layout:"US", keyCode:65, ctrl:1, chars:"\u0001"},
-            "a");
+            "a", SHOULD_DELIVER_ALL);
     testKey({layout:"US", keyCode:65, ctrl:1, shift:1, chars:"\u0001"},
-            "A");
+            "A", SHOULD_DELIVER_ALL);
 
     // Alt keys
     testKey({layout:"US", keyCode:65, alt:1, chars:"a"},
-            "a");
+            "a", SHOULD_DELIVER_ALL);
     testKey({layout:"US", keyCode:65, alt:1, shift:1, chars:"A"},
-            "A");
-            
+            "A", SHOULD_DELIVER_ALL);
+
     // Shift-ctrl-alt generates no WM_CHAR, but we still get a keypress
     testKey({layout:"US", keyCode:65, alt:1, ctrl:1, shift:1, chars:""},
-            "A");
+            "A", SHOULD_DELIVER_ALL);
 
     // Greek plain text
     testKey({layout:"Greek", keyCode:65, chars:"\u03b1"},
-            "\u03b1");
+            "\u03b1", SHOULD_DELIVER_ALL);
     testKey({layout:"Greek", keyCode:65, shift:1, chars:"\u0391"},
-            "\u0391");
+            "\u0391", SHOULD_DELIVER_ALL);
 
     // Greek ctrl keys produce Latin charcodes
     testKey({layout:"Greek", keyCode:65, ctrl:1, chars:"\u0001"},
-            "a");
+            "a", SHOULD_DELIVER_ALL);
     testKey({layout:"Greek", keyCode:65, ctrl:1, shift:1, chars:"\u0001"},
-            "A");
+            "A", SHOULD_DELIVER_ALL);
+
+    // Caps Lock key event
+    testKey({layout:"US", keyCode:20, capsLock:1, chars:""},
+             "", SHOULD_DELIVER_KEYDOWN_KEYUP);
+    testKey({layout:"US", keyCode:20, capsLock:0, chars:""},
+             "", SHOULD_DELIVER_KEYDOWN_KEYUP);
   }
 
-  document.removeEventListener("keypress", onKeyPress, false);
+  document.removeEventListener("keydown",  onKeyEvent, false);
+  document.removeEventListener("keypress", onKeyEvent, false);
+  document.removeEventListener("keyup",    onKeyEvent, false);
 }
 
 // Test the activation (or not) of an HTML accesskey
 function runAccessKeyTests()
 {
   var button = document.getElementById("button");
   var activationCount;
 
@@ -536,17 +647,17 @@ function runTextInputTests()
             "9");
     testKey({layout:"Lithuanian", keyCode:48, ctrl:1, alt:1, chars:"0"},
             "0");
   }
 }
 
 function runTest()
 {
-  runPressTests();
+  runKeyEventTests();
   runAccessKeyTests();
   runXULKeyTests();
   runTextInputTests();
   SimpleTest.finish();
 }
 
 ]]>
 </script>
